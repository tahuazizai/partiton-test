(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["fishTopoFlow"] = factory();
	else
		root["fishTopoFlow"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Export fishTopo as CommonJS module
	 */
	module.exports = __webpack_require__(2);
	//兼容IE8 引入VML 如果不需要兼容IE8请删除
	__webpack_require__(137);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * fishtopo流程实例
	 * @class fish.topo.FishTopoFlow
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *      var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 */
	
	/**
	 * @event click
	 * 节点或者线段的click事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          this.fishTopo.on("click", function(event) {
	 *              console.log("点击的是：" + event.target.model.get('elementType'));
	 *          });
	 */
	
	/**
	 * @event dblclick
	 * 节点或者线段的双击事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          this.fishTopo.on("dblclick", function(event) {
	 *              console.log("双击的是：" + event.target.model.get('elementType'));
	 *          });
	 */
	
	/**
	 * @event create
	 * 节点与线段创建完毕的事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          this.fishTopo.on("create", function(e) {
	 *               if (me.fishTopo.Flow.isLink(e.target.model)) {
	 *                  console.log("线段创建完毕：" + e.target.model);
	 *               }
	 *          });
	 */
	
	/**
	 * @event delete
	 * 节点与线段创建完毕的事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          //节点删除完毕事件
	 *          this.fishTopo.on("delete", function(event) {
	 *              console.log("删除的是：" + event.target.model.get('elementType'));
	 *          });
	 */
	
	/**
	 * @event dropDrag
	 * 节点移动完成的事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          //节点移动结束事件
	            this.fishTopo.on("dropDrag", function(event) {
	                console.log("移动的节点是："+event.target.model.get('elementType'));
	            });
	 */
	
	
	
	
	    __webpack_require__(3);
	    var graphic = __webpack_require__(4);
	    var Minimap = __webpack_require__(64);
	    var util = __webpack_require__(65);
	    var Point = __webpack_require__(66);
	    var ExtensionAPI = __webpack_require__(68);
	    var Eventful = __webpack_require__(12);
	    var zrender = __webpack_require__(69);
	    var zrUtil = __webpack_require__(5);
	    var OperationNode = __webpack_require__(80);
	    var FlowConnectionManager = __webpack_require__(90);
	    var FlowUtil = __webpack_require__(94);
	    var Constants = __webpack_require__(93);
	    var Model = __webpack_require__(87);
	    var eventTool = __webpack_require__(77);
	    var Connector = __webpack_require__(82);
	    var LineOperationManager = __webpack_require__(123);
	    var Flow = __webpack_require__(119);
	    var flowNode = __webpack_require__(96);
	    var GroupNode = __webpack_require__(95);
	    var flowLink = __webpack_require__(117);
	    var layout = __webpack_require__(124);
	    var textContain = __webpack_require__(26);
	    var ImagePool = __webpack_require__(132);
	    var ToolTipView = __webpack_require__(133);
	    var TooltipModel = __webpack_require__(136);
	    var actions = {};
	    var keyCode = {ENTER:13, ESCAPE:27}
	    function FishTopoFlow(dom, opts) {
	        this.id;
	        this.group = null;
	        this._dom = dom;
	        this.nowZoom = 1;
	        this.canScale = true;
	        this.eagleEye = false;
	        this.eagleEyeNode = null;
	        this.initScaleRatio = 1;
	        this.operationNode = null;
	        this.step = 0;//前进后退计步数
	        this.stepJson = [];//存放每步的json
	        this.selectedNode = null;
	        this.allNodes = [];
	        this.minimap = null;
	        this._api = new ExtensionAPI(this);
	        this.connectionManager = new FlowConnectionManager(this._api);
	        this.lineOperationManager = new LineOperationManager(this.connectionManager,this._api);
	        this._zr = zrender.init(dom, {
	            renderer: opts.renderer || 'canvas',
	            devicePixelRatio: opts.devicePixelRatio
	        });
	        this._tooltipView = new ToolTipView(new TooltipModel(opts.tooltip),this._api);
	        this.Shape = graphic;
	        this.lineOpt = {};  //初始的线段配置信息
	        this.selectedNodes = [];
	        this.model = new Model({});
	        this.model.set(Constants.ELEMENT_TYPE, "scene");
	        this.model.set(Constants.MODE, "normal");
	        this.options = opts;
	        this.cursorMap = {
	            tl: 'nw-resize',
	            tr: 'ne-resize',
	            bl: 'sw-resize',
	            br: 'se-resize',
	            mtr:'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAAYFBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD6T+iNAAAAH3RSTlMA7sUMoYXnEkYYzaaTjQiAQCweBcG7fvnULh2ZdjMy6Fzd7wAAALJJREFUGNN1kFkOwzAIBQHvW/Y6Sbfc/5Y1ltqoljIf2BohBA8qU096xeV5L/+uFH4SpsGAGSKmThCyMz64Ud38Te0meIpHcTP1ndTKvqzSUuQILFMQJAUwIngBLCd0UrJhSRGqzHHU3FcHBVMokqxS38YNGQLQbhmgZZ23sVEXnXVmS467Fq0892SSLaW5SHrN9rz9bXv9EHIB+E9pdMG7Ys48Z2cjxo7FL3k8kPIE13wAmEUIO2ML9YMAAAAASUVORK5CYII=) 10 10, auto'
	        }; // 节点控制点鼠标信息(上左，上右，下左，下右，旋转)
	        this.cursorMaps = [
	            'n-resize',
	            'ne-resize',
	            'e-resize',
	            'se-resize',
	            's-resize',
	            'sw-resize',
	            'w-resize',
	            'nw-resize'
	        ]
	        this.cursorOffset = {
	            tr: 1,
	            br: 3,
	            bl: 5,
	            tl: 7
	        }
	        Eventful.call(this);
	    }
	
	    var fishTopoProto = FishTopoFlow.prototype;
	
	    /**
	     * 获取 fishTopo 实例容器的 dom 节点
	     * @return {HTMLElement}
	     */
	    fishTopoProto.getDom = function () {
	        return this._dom;
	    };
	
	    /**
	     * @private
	     */
	    fishTopoProto.getZr = function () {
	        return this._zr;
	    };
	    /**
	     * 获取 fishTopo 实例容器的宽度。
	     * @return {number}
	     */
	    fishTopoProto.getWidth = function () {
	        return this._zr.getWidth();
	    };
	
	    /**
	     * 获取 fishTopo 实例容器的高度。
	     * @return {number}
	     */
	    fishTopoProto.getHeight = function () {
	        return this._zr.getHeight();
	    };
	
	
	    /**
	     * 当前实例是否已经被释放。
	     * @return {boolean}
	     */
	    fishTopoProto.isDisposed = function () {
	        return this._disposed;
	    };
	
	    /**
	     * 释放 当前实例
	     */
	    fishTopoProto.dispose = function () {
	        this._disposed = true;
	
	        this._zr.dispose();
	
	        instances[this.id] = null;
	    };
	
	
	    /**
	     * 调整尺寸  在窗口大小发生改变时需要手工调用
	     * @param {number} width 宽度
	     * @param {number} height 高度
	     */
	    fishTopoProto.resize = function () {
	        this._zr.resize();
	
	    };
	
	    fishTopoProto.dispatchAction = function (payload) {
	        if(!actions[payload.type]) {
	            return;
	        }
	    }
	
	    /**
	     * @method option
	     * 修改画布的选项
	     * @param {String} key 键  如：roam linkModify  textEditable等
	     * @param {Boolean|String|Function} value 选项值
	     */
	    fishTopoProto.option = function(key,value) {
	        var model = new Model(this.options);
	        if (arguments.length === 0) {
	            return zrUtil.clone(this.options);
	        } else if (arguments.length === 1) {
	            return model.get(key);
	        } else if (arguments.length === 2) {
	            if (key === "roam") {
	                this.setRoam(value);
	            }
	            return model.set(key,value);
	        }
	    }
	
	
	    fishTopoProto.init = function () {
	        var MOUSE_EVENT_NAMES = 'ontouchstart' in window ? ['touchstart', 'touchmove', 'touchend'] : ['mousedown', 'mousemove', 'mouseup'];
	        this.group = new graphic.Group();
	        this.group.model = this.model;
	        this.group.isBg = true;
	        this._zr.add(this.group);
	
	        //是否允许鼠标滚轮放大缩小
	        if (this.options.roam === true) {
	            this.zrScale();
	        }
	
	        this.connectionManager.connectors = [];
	        //mouseup 会在各个node或线的click事件之点执行  在选中节点或线前 先清空选中效果
	        this._zr.on("mouseup", function (e) { // clearSelect
	            // 1. 清空节点的选中效果
	            // this._removeOperationNode();
	            // 2. 点击的线 ，则直接返回
	            var shape = e.target;
	            if (shape && shape.model && Flow.isLink(shape.model)) {
	                return;
	            }
	            if (shape && shape.connector instanceof Connector) {
	                return;
	            }
	            // 3. 清空连接线
	            this.connectionManager.clearSelectCon();
	            // 4. 点击的是线上操作按钮，则直接返回
	            if (shape && shape._isLineOperationIcon && shape._isLineOperationIcon == true) {
	                return;
	            }
	            // 5.隐藏线上操作图标
	            this.lineOperationManager.hideAllLineOperation();
	        }.bind(this));
	
	        this._zr.on("click", function (e) {
	            // 如果点击了控制点，则不会取消选中状态(控制点不在节点范围内)
	            var target = e.target || {};
	            var type = target.type;
	            if (type !== 'ConnectControlLine' && type !== 'ConnectControl') {
	                this.hideConnectorPoint();
	                this.hideConnectorControl();
	                this._removeOperationNode();
	                var nodeTarget = e.target;
	                var shape;
	                if (nodeTarget) {
	                    shape = nodeTarget.model;
	                }
	                if ((nodeTarget && shape && Flow.isLink(shape)) || (nodeTarget && shape && Flow.isNode(
	                        shape))) {
	                    return;
	                }
	            }
	            var params = {};
	            params.event = e;
	            params.type = "click";
	            params.target = this;
	            this._api.trigger(params.type, params);
	        }.bind(this));
	
	        // mouseMode统一在mousedown事件里判断
	        this._zr.on("mousedown", function (e) {
	            if (this.options.mouseMode === 'drag-select') {
	                if ((e.target && e.target.model) ||
	                    (e.target && e.target.lineType && e.target.parent) ||
	                    (e.target && e.target.connector instanceof Connector) ||
	                    (e.target && e.target instanceof graphic.Circle) ||
	                    (e.target && e.target.name === "GROUP_RECT_NAME")) {
	                    return;
	                } else {
	                    this.hideConnectorPoint();
	                    this.hideConnectorControl();
	                    this._removeOperationNode();
	                    this._dragSelect(e.target, e.offsetX, e.offsetY);
	                }
	            }
	
	            if (this.options.mouseMode === 'drag-move') {
	                if ((e.target && e.target.model) || (e.target && e.target.lineType && e.target.parent) ||
	                    (e.target && e.target.connector instanceof Connector) || (e.target && e.target instanceof graphic
	                        .Circle)) {
	                    return;
	                } else {
	                    this._groupDragHandler(e.offsetX, e.offsetY);
	                }
	            }
	        }.bind(this));
	
	        this.on('conPointsGroup:click', function (argument) {
	            this.lineOperationManager.bindOperation(argument.lineNode);
	        }.bind(this));
	
	        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	            this._zr.on(eveName, function (e) {
	                var params = {};
	                params.event = e;
	                params.type = eveName;
	                params.target = this;
	                this._api.trigger(params.type, params);
	            }, this);
	        }, this);
	    };
	
	    fishTopoProto.setRoam = function (value) {
	        this._zr.off("mousewheel");//禁止用户缩放画布
	        if (value === true) {
	            this.zrScale();
	        }
	    }
	
	    fishTopoProto.addGroupModel = function (groupNode) {
	        var that = this;
	        groupNode.eachChild(function (node) {
	            if (node.model) { 
	                if (node instanceof GroupNode) {
	                    if (node.model && !node.model.option.childs && node.children().length > 0) {
	                        var childs = [];
	                        node.eachChild(function (childNode) {
	                            if (childNode.model) {
	                                if (childNode instanceof GroupNode) {
	                                    if (!childNode.model.option.childs && childNode.children().length > 0) {
	                                        that.addGroupModel(node);
	                                    }
	                                }
	                                childs.push(childNode.model.option);
	                                node.model.option.childs = childs;
	                            }
	                        })
	                    }
	                }
	            }
	        });
	    }
	
	    /**
	     * @method toJson
	     * 导出json
	     * @return {Object} json对象
	     */
	    fishTopoProto.toJson = function () {
	        this.addGroupModel(this.group);
	        return FlowUtil.toJson(this.model, this.group);
	    }
	
	    /**
	     * @method fromJson
	     * 导入json
	     * @param  {Object} json对象
	     * @param {Boolean} isNoCount 是否需要step计数，默认是需要计数
	     */
	    fishTopoProto.fromJson = function (json, isNoCount) {
	        this.clear(true);
	        var model = new Model(json);
	        this.setBackground(model.get(Constants.BACKGROUND));
	        var layoutRootNode = [];
	        FlowUtil.fromJson(this, this.group, model.get(Constants.CHILDS), false, layoutRootNode, isNoCount);
	        // for (var i = 0; i < layoutRootNode.length; i++) {
	        //     this.layoutNode("tree", {
	        //         "node": layoutRootNode[i],
	        //         "type": layoutRootNode[i].treeType
	        //     });
	        // }
	    };
	    /**
	     * 添加节点或线段到画布 同add方法
	     * @method addNode
	     * @param {Object} node createNode或createLink返回的对象
	     * @param {Object} [option] 参数对象
	     * @param {Boolean} [option.trigger] 是否触发 beforeCreate事件
	     * @returns {Object} 返回添加成功的节点 ，如被用户取消之类则 返回null
	     */
	    /**
	     * 添加节点或线段到画布 同addNode方法
	     * @method add
	     * @param {Object} node createNode或createLink返回的对象
	     * @param {Object} [option] 参数对象
	     * @param {Boolean} isNoCount 是否需要step计数，默认是需要计数
	     * @param {Boolean} [option.trigger] 是否触发 beforeCreate事件
	     * @returns {Object} 返回添加成功的节点 ，如被用户取消之类则 返回null
	     */
	    fishTopoProto.add = fishTopoProto.addNode = function (node, options, isNoCount) {
	        if (!node) return null;
	
	        var opt = options || {};
	        if(opt.trigger !==false && (!this._trigger('beforeCreate', {target:node}))) {
	            return null;
	        }
	        if (node instanceof Connector) {
	            this.addConnectorAttrEvent(node);
	        } else {
	            if (Flow.isGroupNode(node)) {
	                node.willRender(this._api);
	                var groupOptions = node.model.get(Constants.OPTIONS);
	                if (groupOptions.mergedImage) {
	                    var groupReplaceImage = new flowNode.Image({
	                        style: {
	                            image: groupOptions.mergedImage,
	                            text: groupOptions.style.text,
	                            textPosition: 'bottom'
	                        },
	                        position: [-5000, -5000]
	                    });
	                    this.drag(groupReplaceImage);
	                    node._relationImage = groupReplaceImage;
	                    this.group.add(groupReplaceImage);
	                    setTimeout(function () {
	                        groupReplaceImage.hide();
	                    }, 300);
	                    node.on('dblclick', function () {
	                        node.merged();
	                    })
	                }
	                //遍历组中所有节点
	                node.each(function (child) {
	                    this._addGroupNode(node,child);
	                }, this);
	            }
	            this.addNodeAttrEvent(node, true);
	        }
	        this._trigger("create", {target:node});
	
	        if (node.hoverStyle) {
	            graphic.setHoverStyle(node);
	        }
	
	        this.group.add(node);
	        if (node.relative) {  //必须在加入画布后执行
	            this._handleRelativePostion(node)
	        }
	        if (node.hoverAnimation && this.options.isAnimationEnabled) {
	            flowNode.addHoverAnimation(node);
	        }
	        if (isNoCount != true) {
	            this.stepCounter();
	        }
	        return node;
	    };
	
	
	    fishTopoProto._addGroupNode = function(groupNode, child){
	        if (child instanceof Connector) {
	            this.addConnectorAttrEvent(child);
	        } else {
	            this.addNodeAttrEvent(child, groupNode.options.childDraggable);
	            if (util.isUndefined(child.selectable)) {
	                child.selectable = false;  //组内默认不可选中
	            }
	            if (child.relative) {
	                this._handleRelativePostion(child)
	            }
	            if (child.hoverStyle) {
	                graphic.setHoverStyle(child);
	            }
	        }
	        this._trigger("create", {target:child});
	    };
	
	    /**
	     * 在链路连线上添加文本
	     * @method addTextOnChain
	     * @param {Object} line 链路连线对象
	     * @param {Object} [text] 数组类型，表示多个文本的数据。数组元素可以为字符串，表示每个文本的名字；也可以是个对象，对象中必须指定text属性，其值为文本的名字
	     * @returns {Object} 返回 链路连线对象
	     */
	    fishTopoProto.addTextOnChain = function (line, text) {
	        if (line.options.style.lineType === Connector.TYPE_CHAIN) {
	            this.connectionManager.removeLine(line, this._getParentZr(line));
	            line.options.text.text.push(text);
	            line.options.textContextMenu = line.opt.textContextMenu;   //不然左键菜单没有了！！！
	            var slink = new flowLink.Chain(line.startNode, line.endNode, line.options);
	            this.add(slink);
	            return slink;
	        }
	    }
	
	    /**
	     * 在链路连线上删除指定文本
	     * @method delTextOnChain
	     * @param {Object} txtObj 文本对象
	     * @returns {Object} 返回 链路连线对象
	     */
	    fishTopoProto.delTextOnChain = function (txtObj) {
	        var id = txtObj.id, line = txtObj.parent, pos;
	        if (line.options.style.lineType === Connector.TYPE_CHAIN && zrUtil.isArray(line.options.text.text)) {
	            line.options.text.text.forEach(function (v, i) {
	                if (v.textId === id) {
	                    pos = i;
	                }
	            });
	            line.options.text.text.splice(pos, 1);
	
	            this.connectionManager.removeLine(line, this._getParentZr(line));
	            line.options.textContextMenu = line.opt.textContextMenu;   //不然左键菜单没有了！！！
	            var slink = new flowLink.Chain(line.startNode, line.endNode, line.options);
	            this.add(slink);
	            return slink;
	        }
	    }
	    /**
	     * 在链路连线上修改指定文本
	     * @method delTextOnChain
	     * @param {Object} txtObj 文本对象
	     * @param {String} name 修改的文本
	     * @returns {Object} 返回 链路连线对象
	     */
	    fishTopoProto.modifyTextOnChain = function (txtObj, name) {
	        var id = txtObj.id, line = txtObj.parent;
	        if (line.options.style.lineType === Connector.TYPE_CHAIN && zrUtil.isArray(line.options.text.text)) {
	            line.options.text.text.forEach(function (v, i) {
	                if (v.textId === id) {
	                    v.text = name;
	                }
	            });
	            txtObj.setStyle("text", name);
	        }
	    }
	    /**
	     * 显示隐藏指定节点的连线
	     * @method toggleAllConNodeLine
	     * @param {Object} node 节点对象
	     * @param {String} type 显示还是隐藏 [hide|show]
	     */
	    fishTopoProto.toggleAllConNodeLine = function (node, type) {
	        var allLine = this.connectionManager.connectors;
	        if (zrUtil.isArray(allLine)) {
	            allLine.forEach(function (line) {
	                if (line.startNode.id === node.id) {
	                    type === 'hide' ? line.hide() : line.show();
	                }
	            })
	        }
	    };
	
	    fishTopoProto.addConnectorAttrEvent = function (connector) {
	        var that = this;
	        var chainLine = null;
	        if (connector.options.style.lineType === Connector.TYPE_CHAIN) {
	            var key = this.connectionManager.getTwoNodeId(connector.startNode, connector.endNode, connector.options.position);
	            var cons = this.connectionManager.connectorMap.get(key);
	            var orignText = [].concat(connector.options.text.text);
	            if (cons.length > 0) {
	                cons.forEach(function (v) {
	                    if (v.options.style.lineType === Connector.TYPE_CHAIN) {
	                        orignText = orignText.concat(v.options.text.text);
	                        chainLine = v;
	                    }
	                });
	            }
	        }
	        //如果已存在链路
	        if (chainLine) {
	            connector.options.text.text = orignText;
	            this.connectionManager.removeLine(chainLine, this._getParentZr(chainLine));
	        }
	        connector.options.isEdit = !!this.options.linkModify;
	        connector.on("mousedown", function () {
	            this.connectionManager.connectorForbidEdit(!this.options.linkModify);
	            this.isNode = false;
	        }.bind(this));
	        this.connectionManager.add(connector);
	        //支持双击编辑
	        connector.on("dblclick", function () {
	            if (typeof this.options.text.textEditable == "undefined") {
	                if (that.options.textEditable) {
	                    that.connectorEdit(this);
	                }
	            } else {
	                if (this.options.text.textEditable) {
	                    that.connectorEdit(this);
	                }
	            }
	        });
	    }
	
	    fishTopoProto.addNodeAttrEvent = function (node, childDraggable) {
	        var that = this;
	        if (childDraggable) {
	            this.drag(node);
	        }
	
	        node.attr("operationIcons", node.model.get('options.operationIcons'));
	
	        //侦听节点的click dblclick事件，选中，并派发出去
	        node.on('click', function (event) {
	            var targeNode = this;
	            that.nodeClickHandler(targeNode);
	
	            var params = {};
	            params.event = event;
	            params.type = 'click';
	            params.target = targeNode;
	            that._api.trigger(params.type, params);
	            event.cancelBubble = true;
	
	            // 判断一下是否是组内成组的点击事件，如果是的话，那组也也派发一下
	            if (Flow.isInGroup(targeNode)) {
	                var parentNode = targeNode.parent;
	                if (!parentNode.childDraggable) {
	                    parentNode.trigger('click', {event:event, type:'click',target:parentNode});
	                }
	            }
	        });
	        node.on('dblclick', function (e) {
	            var targeNode = this;
	            if (!targeNode.style || (typeof targeNode.style.textEditable == "undefined")) {
	                if (that.options.textEditable) {
	                    that.nodeEdit(targeNode);
	                }
	            } else {
	                if (targeNode.style.textEditable) {
	                    that.nodeEdit(targeNode);
	                }
	            }
	            var params = {};
	            params.event = e;
	            params.type = 'dblclick';
	            params.target = targeNode;
	            that._api.trigger(params.type, params);
	
	            e.cancelBubble = true;
	        });
	
	        this.allNodes.push(node);
	    }
	
	    fishTopoProto._handleRelativePostion = function(node) {
	        var parentEl = node.parent;
	        var containerInfo = parentEl === this.group
	            ? {
	                width:this._api.getWidth(),
	                height:this._api.getHeight()
	            }
	            : {
	                width:parentEl.getBoundingRect().width,
	                height:parentEl.getBoundingRect().height
	            }
	        layout.positionElement(node, node.relative, containerInfo, node.relative.padding, {boundingMode:node.relative.bounding||'all'});
	    }
	
	    fishTopoProto._getParentZr = function(node) {
	        var parentZr = null;
	        if (node && node.parent) {
	            parentZr = node.parent;
	        } else {
	            parentZr = this.group;
	        }
	        return parentZr;
	    }
	
	    fishTopoProto._removeOperationNode = function() {
	        if (this.operationNode) {
	            this.group.remove(this.operationNode);
	            this.operationNode.cleanup();
	            this.operationNode = null;
	        }
	    }
	
	    /**
	     * 清空当前实例，会移除实例中所有的节点与线
	     * @method clear
	     */
	    fishTopoProto.clear = function (isNoCount) {
	        for (var i = 0; i < this.allNodes.length; i++) {
	            var parentZr = this._getParentZr(this.allNodes[i]);
	            this.connectionManager.deleteSelectCon(this.allNodes[i], parentZr)
	        }
	        this.connectionManager.connectorMap.clear();
	        this.allNodes = [];
	        this.operationNode = null;
	        this.selectedNode = null;
	        this.dragSelectRect = null;
	        this.selectedNodes = [];
	        this.hideConnectorPoint();
	        this.hideConnectorControl();
	        this.connectionManager.connectors = [];
	        this._zr.clear();
	        this.group = new graphic.Group();
	        this.group.isBg = true;
	        this._zr.add(this.group);
	        if (isNoCount != true) {
	            this.stepCounter();
	        }
	    };
	
	    /**
	     * 创建连线的小图标操作
	     * @param {string} key 小图标的名称
	     * @param {Object} options 小图标的相关参数
	     * @param {String} [options.icon] 小图标路径
	     * @param {Object} [options.lineNode] 线段实例
	     * @param {Function} [options.callback] 点击后的回调
	     *
	     * **使用范例**：
	     *
	     *      @example
	     *                  this.fishTopo.addIcon("icon1", {
	     *                      icon: "https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo_top_ca79a146.png",
	     *                      lineNode: lineNode,
	     *                      callback: function(event) {
	     *                          alert(JSON.stringify(event.data))
	     *                      },
	     *                  });
	     */
	    fishTopoProto.addLineIcon = fishTopoProto.addIcon = function (key, options) {
	        this.lineOperationManager.addIcon(key, options);
	    };
	
	    /**
	     * 创建连线的默认删除操作
	     * @param  {Object} lineNode 线
	     *
	     *  **使用范例**：
	     *
	     *      @example
	     *      fishTopo.lineDefaultIcon(lineNode);
	     */
	    fishTopoProto.lineDefaultIcon = function (lineNode) {
	        this.addLineDeleteIcon(lineNode);
	        this.addLineChangeIcon(lineNode);
	    };
	
	    /**
	     * 创建连线的默认删除操作
	     * @param  {Object} lineNode 线
	     * @param {Object} [options] 连线操作的选项
	     *
	     *  **使用范例**：
	     *
	     *      @example
	     *      fishTopo.addLineChangeIcon(lineNode);
	     */
	    fishTopoProto.addLineDeleteIcon = function (lineNode,options) {
	        //创建删除
	        this.lineOperationManager.addDeleteIcon(lineNode,options);
	    };
	
	    /**
	     * 创建连线的默认切换类型操作
	     * @param  {Object} lineNode 线
	     * @param {Object} [options] 连线操作的选项
	     *
	     *  **使用范例**：
	     *
	     *      @example
	     *      fishTopo.addLineChangeIcon(lineNode);
	     */
	    fishTopoProto.addLineChangeIcon = function (lineNode,options) {
	        this.lineOperationManager.addChangeLineTypeIcon(lineNode,options);
	    };
	
	    /**
	     * 变更当前线的类型，如果不传则按顺序取下一个类型。先删除原来的线段 再增加一种类型的线段
	     * @param {String} lineType 欲变更线的类型
	     */
	    fishTopoProto.changeSelectConnectorType = function(lineType) {
	        var nextLineType = lineType;
	        var line = this.connectionManager.selConnector;
	        var originLineType = line.options.style.lineType;
	        if (nextLineType) {
	            if (nextLineType == originLineType) {
	                return;
	            }
	        } else {
	            var arrLineType = [Connector.TYPE_STRAIGHT, Connector.TYPE_JAGGED, Connector.TYPE_CURVE];
	            var index = zrUtil.indexOf(arrLineType, originLineType);
	            nextLineType = arrLineType[(index + 1) % arrLineType.length];
	        }
	
	        //this.remove(line, {trigger:false}); 这样会删除icons
	        this.connectionManager.deleteLine(this._getParentZr(line));
	        this.lineOperationManager.hideAllLineOperation();
	
	        zrUtil.merge(line.options, { dockers: [] }, true);
	        zrUtil.merge(line.options.style, { lineType: nextLineType }, true);
	        var nextLine = this.createConnectorByNodes(line.startNode, line.endNode, line.options, false);
	        if (nextLine) {
	            nextLine.icons = line.icons;
	            nextLine.on('Connector:click', function () {
	                this.lineOperationManager.bindOperation(nextLine);
	            }.bind(this));
	        }
	    }
	
	    /**
	     * @private
	     * 根据point创建节点上的连接点
	     * @param {Object} point x，y坐标  {x:x, y:y}
	     * @param {String} pos x，y坐标 [right|left|top|bottom]
	     * @param {String} lineType x，y坐标 [straight|jagged|curve]
	     */
	    fishTopoProto.createConnectorPoint = function(point, pos, lineType) {
	        var me = this;
	        var pointInstance = new graphic.Circle({
	            shape: {
	                cx: point.x,
	                cy: point.y,
	                r: 4
	            },
	            style: {
	                fill: '#FFFF33',
	                stroke:'#000000'
	            },
	                        z : 4,
	            draggable: true,
	            lineType: lineType
	        });
	        pointInstance.type = 'ConnectPoint';
	        pointInstance.pos = pos;                //记录是节点上哪个位置的连接点
	        var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];
	        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	            pointInstance.on(eveName, function(e) {
	                var params = {};
	                params.event = e;
	                params.type = "ConnectPoint:" + eveName;
	                me.group.trigger(params.type, params);
	            });
	        });
	        this.group.add(pointInstance);
	    }
	
	    /**
	     * @private
	     * 隐藏节点上的连接点
	     */
	    fishTopoProto.hideConnectorPoint = function() {
	        var that = this;
	        this.group.children().forEach(function (v) {
	            if (v.type === 'ConnectPoint') {
	                that.group.remove(v);
	            }
	        })
	        this.group.off("ConnectPoint:dragstart");
	        this.group.off("ConnectPoint:drag");
	        this.group.off("ConnectPoint:dragend");
	    }
	
	    /**
	     * @private
	     * 根据节点数组动态创建连接点
	     * @param  {Array} lineType 需要展示连接点的节点数组
	     * @param  {String} lineType 连线的线段类型 [straight|jagged|curve]
	     */
	    fishTopoProto.filterConnectPoint = function(targetNodes, lineType) {
	        var that = this;
	        var groupNodes = []; // 记录组内节点
	        var outsideNodes = []; // 记录组外节点
	        var nodes = [];
	        if (targetNodes.length > 1) {
	            targetNodes.forEach(function(item) {
	                if (Flow.isGroupNode(item)) {
	                    nodes.push(item);
	                    groupNodes = groupNodes.concat(item.children());
	                } else {
	                    outsideNodes.push(item);
	                }
	            });
	            // 比较组内外节点，过滤组内节点
	            outsideNodes.forEach(function(item) {
	                if (!groupNodes.includes(item)) {
	                    nodes.push(item);
	                }
	            });
	        } else {
	            nodes = targetNodes;
	        }
	        nodes.forEach(function(item) {
	            var rect = util.getRect(item);
	            var connectorPoint = util.getConnectorPoints(rect, item);
	            that.createConnectorPoint(connectorPoint.left, "left", lineType);
	            that.createConnectorPoint(connectorPoint.right, "right", lineType);
	            that.createConnectorPoint(connectorPoint.top, "top", lineType);
	            that.createConnectorPoint(connectorPoint.bottom, "bottom", lineType);
	        });
	    }
	
	    /**
	     * 在节点上显示连接点
	     * @param  {String} lineType 连线的线段类型 [straight|jagged|curve]
	     * @param {Object} [options] 连线的线段属性
	     *
	     *  **使用范例**：
	     *
	     *      @example
	     *       $('.btn-connect-jagged').click(function(e) {
	     *           fishTopo.showConnectorPoint("jagged", {
	     *               symbol: {
	     *                   // 箭头颜色
	     *                   color: "#BBBBBB"
	     *               },
	     *               style: {
	     *                   // 线条颜色
	     *                   stroke: "#BBBBBB",
	     *               }
	     *           });
	     *       });
	     */
	    fishTopoProto.showConnectorPoint = function(lineType, lineOpt, ifCurrentNode) {
	        var that = this;
	        this.hideConnectorPoint();
	        if (lineOpt) {
	            this.lineOpt = lineOpt;  //缓存线段的配置信息
	        }
	        if (!ifCurrentNode) {
	            ifCurrentNode = false;
	        }
	        var targetNodes = ifCurrentNode ? [that.selectedNode] : that.allNodes;
	
	        if (!ifCurrentNode) {
	            // 所有节点连接点展示前，首先清除画布上的框选dragSelect
	            that._removeOperationNode();
	            that._releaseSelectNode();
	        }
	
	        // 让所有画布中的节点/当前节点显示连接点
	        this.filterConnectPoint(targetNodes, lineType);
	
	        // 根据连线点查找节点(考虑优化 创建连接点的时候 就把连接点与node进行绑定，就不用这个复杂的计算了)
	        function findConnectorNode(x, y, offset, pos) {
	            var node, endPos = null;
	            that.allNodes.forEach(function(item) {
	                var rect = util.getRect(item);
	                var connectorPoint = util.getConnectorPoints(rect, item);
	                if (pos) {
	                    if (Math.abs(connectorPoint[pos].x - x) <= offset && Math.abs(connectorPoint[pos].y - y) <= offset) {
	                        node = item;
	                    }
	                } else {
	                    if (Math.abs(connectorPoint["left"].x - x) <= offset && Math.abs(connectorPoint["left"].y - y) <= offset) {
	                        endPos = "left";
	                        node = item;
	                    } else if (Math.abs(connectorPoint["top"].x - x) <= offset && Math.abs(connectorPoint["top"].y - y) <= offset) {
	                        endPos = "top";
	                        node = item;
	                    } else if (Math.abs(connectorPoint["right"].x - x) <= offset && Math.abs(connectorPoint["right"].y - y) <= offset) {
	                        endPos = "right";
	                        node = item;
	                    } else if (Math.abs(connectorPoint["bottom"].x - x) <= offset && Math.abs(connectorPoint["bottom"].y - y) <= offset) {
	                        endPos = "bottom";
	                        node = item;
	                    }
	                }
	            });
	            return {
	                node: node,
	                endPos: endPos
	            };
	        }
	        this.group.on("ConnectPoint:dragstart", function(e) {
	            // 如果是当前节点显示连接点，需要在拖动剪头时让画布中的其他节点显示连接点
	            if (ifCurrentNode) {
	                that.filterConnectPoint(that.allNodes, lineType);
	            }
	            var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;
	            var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;
	            var arrow = e.event.target;
	            that.startPos = arrow.pos;
	            that.selectConnNode = findConnectorNode(arrow.shape.cx, arrow.shape.cy, 0, that.startPos).node;
	            arrow.hide();
	            that.lineOperationManager.hideAllLineOperation();
	            that.reverseConnect = false;   //是否反向连线的标识
	            that.originNode = null;
	            var point = new Point(x, y);
	            that.connectionManager.connectors.forEach(function (v) {
	                if (v.endNode.id === that.selectConnNode.id && that.startPos === v.options.position.endPos) {
	                    that.connectionManager.deleteByLine(v, that.group);
	                    that.selectConnNode = v.startNode;
	                    that.startPos = v.options.position.startPos;
	                    that.originNode = v.endNode;
	                    that.originPos = v.options.position.endPos;
	                } else if (v.startNode.id === that.selectConnNode.id && that.startPos === v.options.position.startPos) {
	                    that.connectionManager.deleteByLine(v, that.group);
	                    that.reverseConnect = true;
	                    that.selectConnNode = v.endNode;
	                    that.endPos = v.options.position.endPos;
	                    that.originNode = v.startNode;
	                    that.originPos = v.options.position.startPos;
	                }
	            })
	            var connector;
	            if (that.reverseConnect) {
	                connector = that.connectionManager.manageReverseTempConnector(point, that.selectConnNode, arrow.lineType, that.endPos);
	            } else {
	                connector = that.connectionManager.manageTempConnector(that.selectConnNode, point, arrow.lineType, that.startPos);
	            }
	            that.group.add(connector);
	        });
	        this.group.on("ConnectPoint:drag", function(e) {
	            var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;
	            var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;
	            var point = new Point(x, y);
	            var arrow = e.event.target;
	            if (that.reverseConnect) {
	                that.connectionManager.manageReverseTempConnector(point, that.selectConnNode, arrow.lineType, that.endPos);
	            } else {
	                that.connectionManager.manageTempConnector(that.selectConnNode, point, arrow.lineType, that.startPos);
	            }
	            that.group.children().forEach(function (v) {
	                if (v.type === 'ConnectPoint') {
	                    v.attr({style:{fill: "#FFFF33"},scale:[1,1],origin:[v.shape.cx,v.shape.cy]});
	                    if (Math.abs(v.shape.cx - x) <= 10 && Math.abs(v.shape.cy - y) <= 10) {
	                        var res = findConnectorNode(x, y, 10);
	                        if (that.reverseConnect) {
	                            that.connectionManager.manageReverseTempConnector(point, that.selectConnNode, arrow.lineType, that.endPos, res.endPos, res.node);
	                        } else {
	                            that.connectionManager.manageTempConnector(that.selectConnNode, point, arrow.lineType, that.startPos, res.endPos, res.node);
	                        }
	                        v.attr({style:{fill: "#ff0000"},scale:[1.5,1.5],origin:[v.shape.cx,v.shape.cy]});
	                    }
	                }
	            })
	        });
	        this.group.on("ConnectPoint:dragend", function(e) {
	            var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;
	            var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;
	            var res = findConnectorNode(x, y, 10);
	            var targetNode = res.node;
	            var endPos = res.endPos || 'left';
	            var arrow = e.event.target;
	            //删除临时线
	            that.connectionManager.removeTempConnector(that.group);
	
	            //2.如果找到目标结点 则画线
	            if (targetNode && (that.selectConnNode.id !== targetNode.id)) {
	                var origin = {};
	                var connectOptions = {
	                    style: {
	                        lineType: arrow.lineType
	                    },
	                    position: {
	                        startPos: that.reverseConnect ? endPos : that.startPos,
	                        endPos: that.reverseConnect ? that.endPos : endPos
	                    }
	                }
	                var finalOpt = util.mergeOpt(connectOptions, that.lineOpt, true, 'position');
	                var start = that.reverseConnect ? targetNode : that.selectConnNode;
	                var end = that.reverseConnect ? that.selectConnNode : targetNode;
	                //如果有原始连线存在，则要暴露出去。
	                if (that.originNode) {
	                    origin.startNode = that.reverseConnect ? that.originNode : that.selectConnNode;
	                    origin.endNode = that.reverseConnect ? that.selectConnNode : that.originNode;
	                    origin.options = util.mergeOpt({
	                        style: {
	                            lineType: arrow.lineType
	                        },
	                        position: {
	                            startPos: that.reverseConnect ? that.originPos : that.startPos,
	                            endPos: that.reverseConnect ? that.endPos : that.originPos
	                        }
	                    }, that.lineOpt, true, 'position');
	                }
	                if(!that._trigger('beforeCreate', {target: start, endNode: end, connectOptions: finalOpt, origin: origin})) {
	                    return false;
	                }
	                that.createConnectorByNodes(start, end, finalOpt);
	                that.hideConnectorPoint();      //隐藏所有节点上的连接点
	                // 触发selectConnNode点击
	                // that.nodeClickHandler(that.selectConnNode);
	            } else {
	                arrow.show();
	                arrow.position = [0, 0];
	                //还原所有连接点的颜色
	                that.group.children().forEach(function (v) {
	                    if (v.type === 'ConnectPoint') {
	                        v.attr({style:{fill: "#FFFF33"},scale:[1,1],origin:[v.shape.cx,v.shape.cy]});
	                    }
	                });
	            }
	        });
	    }
	    fishTopoProto.createLineConnectorPoint = function(point, pos, lineType) {
	        var pointInstance = new graphic.Circle({
	            shape: {
	                cx: point.x,
	                cy: point.y,
	                r: 4
	            },
	            style: {
	                fill: '#FFFF33',
	                stroke:'#000000'
	            },
	            z : 4,
	            draggable: true,
	            lineType: lineType
	        });
	        pointInstance.type = 'ConnectPoint';
	        pointInstance.pos = pos;                //记录是节点上哪个位置的连接点
	        this.group.add(pointInstance);
	    }
	
	    fishTopoProto.getRotatedCornerCursor = function(node, pos) {
	        var that = this;
	        var rotation = node.rotation;
	        if (pos === 'mtr') {
	            return that.cursorMap[pos];
	        }
	        if (Math.abs(rotation) > 0) {
	            var angle = -rotation / (Math.PI/180);
	            var n = Math.round((angle % 360) / 45);
	            if (n < 0) {
	                n += 8; // full circle ahead
	            }
	            n += that.cursorOffset[pos];
	            n %= 8;
	            return that.cursorMaps[n];
	        }
	        return that.cursorMap[pos];
	    }
	
	    /**
	     * @private
	     * 根据point创建节点上的控制点
	     * @param {Object} point x，y坐标  {x:x, y:y}
	     * @param {String} pos x，y坐标 [tl|tc|tr|bl|br|mtr] (top-left, top-center, top-right, bottom-left, bottom-right, middle-top-rotate)
	     * @param {String} nodeId 创建控制点时传入当前节点的id，完成节点与控制点的绑定
	     */
	    fishTopoProto.createConnectorControl = function(point, pos, node) {
	        var me = this;
	        var posArr = pos.split(',');
	        if (posArr.length < 2) {
	            var controlCursor = me.getRotatedCornerCursor(node, pos);
	            var pointInstance = new graphic.Rect({
	                shape:{
	                    x: point.x - 4,
	                    y: point.y - 4,
	                    width: 8,
	                    height: 8
	                },
	                style: {
	                    fill: '#ffffff',
	                    stroke:'#000000'
	                },
	                z: 4,
	                rotation: node.rotation,
	                origin: [point.x, point.y],
	                cursor: controlCursor,
	                draggable: true
	            });
	            pointInstance.type = 'ConnectControl';
	            pointInstance.pos = pos;// 记录是节点上哪个位置的连接点
	            var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];
	            zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	                pointInstance.on(eveName, function(e) {
	                    var params = {};
	                    params.event = e;
	                    params.type = "ConnectControl:" + eveName;
	                    params.nodeId = node.id;
	                    params.cursor = controlCursor;
	                    me.group.trigger(params.type, params);
	                });
	            });
	            this.group.add(pointInstance);
	        } else {
	            // 旋转点与节点之间需要连线
	            var line = new graphic.Line({
	                shape: {
	                    x1: point.top.x,
	                    y1: point.top.y,
	                    x2: point.bottom.x,
	                    y2: point.bottom.y
	                },
	                style: {
	                    lineWidth: 1
	                },
	                z: 1,
	                draggable: false,
	                cursor: 'default'
	            });
	            line.type = 'ConnectControlLine';
	            line.nodeId = node.id;
	            this.group.add(line);
	        }
	    }
	
	    /**
	     * @method returnConnectorControlParam
	     * 返回旋转点和缩放点控制参数
	     * @param  {Object} 当前节点对象
	     */
	    fishTopoProto.returnConnectorControlParam = function(node) {
	        var scaleFlag = typeof node.scaleable === 'boolean' ? node.scaleable : this.options.scaleable;
	        var rotateFlag = typeof node.rotatable === 'boolean' ? node.rotatable : this.options.rotatable;
	        return {
	            scaleable: scaleFlag,
	            rotatable: rotateFlag
	        }
	    }
	
	    /**
	     * @private
	     * 隐藏节点上的控制点
	     */
	    fishTopoProto.hideConnectorControl = function() {
	        var that = this;
	        var types = ['ConnectControl', 'ConnectControlLine'];
	        this.group.children().forEach(function (v) {
	            if (types.includes(v.type)) {
	                that.group.remove(v);
	            }
	        })
	        this.group.off("ConnectControl:dragstart");
	        this.group.off("ConnectControl:drag");
	        this.group.off("ConnectControl:dragend");
	    }
	
	    /**
	     * 在节点上显示控制点
	     *
	     *  **使用范例**：
	     *
	     *      @example
	     *      fishTopo.showConnectorControl();
	    */
	   fishTopoProto.showConnectorControl = function() {
	    var that = this;
	    this.hideConnectorControl();
	    // 让当前节点显示控制点
	    var rect = util.getRect(this.selectedNode);
	    var connectorPoint = util.getConnectorControls(rect, this.selectedNode);
	    var params = this.returnConnectorControlParam(this.selectedNode);
	    if (params.scaleable) {
	        that.createConnectorControl(connectorPoint.tl, "tl", this.selectedNode);
	        that.createConnectorControl(connectorPoint.tr, "tr", this.selectedNode);
	        that.createConnectorControl(connectorPoint.bl, "bl", this.selectedNode);
	        that.createConnectorControl(connectorPoint.br, "br", this.selectedNode);
	    }
	    if (params.rotatable) {
	        that.createConnectorControl(connectorPoint.mtr, "mtr", this.selectedNode);
	        that.createConnectorControl({ top: connectorPoint.mtr, bottom: connectorPoint.tc }, "mtr,tc", this.selectedNode);
	    }
	
	    function findControlNode (id) {
	        var node = null;
	        that.group.children().forEach(function(item) {
	            if (item.id === id) {
	                    node = item;
	            }
	        });
	        return node;
	    }
	
	    this.group.on("ConnectControl:dragstart", function(e) {
	        // 首先清除其他所有节点的控制点和连接点
	        var cursor = e.event.target.cursor;
	        var pos = e.event.target.pos;
	        var posMap = {
	            'tl': 'br',
	            'tr': 'bl',
	            'bl': 'tr',
	            'br': 'tl'
	        };
	        that.selectConnNode = findControlNode(e.nodeId);
	        if (cursor && pos !== 'mtr') {
	            var originNode = that.group.children().find(function (node) {
	                return node.pos === posMap[pos];
	            });
	            var currentNode = that.group.children().find(function (node) {
	                return node.pos === pos;
	            });
	            var boundingRect = that.selectConnNode.getBoundingRect();
	            that.oppositeShape = zrUtil.clone(originNode.shape);
	            that.currentShape = zrUtil.clone(currentNode.shape);
	            var rect = zrUtil.clone(util.getRect(that.selectConnNode, true));
	            var diagonal = Math.sqrt(Math.pow(rect.width, 2) + Math.pow(rect.height, 2));// 对角线长度
	            that.diagonal = diagonal;
	            that.originRect = zrUtil.clone(rect);
	            that.ifPointCenter = boundingRect.x < -1; // 判断中心点是否在节点中心(原形在中心，矩形在左上角)
	            // 移除node高亮
	            that.selectConnNode.selectStyle && that._api.getZr().removeHover(that.selectConnNode);
	        }
	    });
	    this.group.on("ConnectControl:drag", function(e) {
	        var cursor = e.event.target.cursor;
	        var targetPos = e.event.target.pos;
	        var currentNode = that.selectConnNode;
	        var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;
	        var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;
	        var rect = util.getRect(currentNode, true);
	        if (targetPos === 'mtr') {
	            // 旋转
	            var r_x = x - currentNode.position[0];
	            var r_y = y - currentNode.position[1];
	            var origins = {
	                x: rect.x - currentNode.position[0],
	                y: rect.y - currentNode.position[1]
	            }
	            var rotation = Math.atan2(r_y, r_x);
	            that.selectedNode.attr({
	                'origin': [origins.x, origins.y],
	                'rotation': -rotation
	            });
	            var connectorPoint = util.getConnectorPoints(rect, that.selectedNode);
	            var controlPoint = util.getConnectorControls(rect, that.selectedNode);
	            // 节点连线点，控制点位置更新
	            that.group.children().forEach(function (item) {
	                var pos = item.pos;
	                if (item.type === 'ConnectControl') {
	                    if (pos === 'mtr') {
	                        item.attr('position', [0, 0]);
	                        item.attr('rotation', 0);
	                    }
	                    item.setShape({ x: controlPoint[pos].x - 4, y: controlPoint[pos].y - 4 });
	                    item.attr({
	                        'origin': [item.shape.x + 4, item.shape.y + 4],
	                        'rotation': -rotation
	                    });
	                } else if (item.type === 'ConnectControlLine') {
	                    item.setShape({ x1: controlPoint.mtr.x, x2: controlPoint.tc.x, y1: controlPoint.mtr.y, y2: controlPoint.tc.y });
	                } else if (item.type === 'ConnectPoint') {
	                    item.setShape({ cx: connectorPoint[pos].x, cy: connectorPoint[pos].y });
	                }
	            });
	        } else {
	            // 缩放(缩放点需要结合旋转角度计算)
	            var ratio = 1,
	                center = [],
	                centerPoint = {},
	                width0, height0;
	            var cursorsY = ['n-resize', 's-resize'];
	            var positionOrg = {
	                'tl': 'br',
	                'tr': 'bl',
	                'bl': 'tr',
	                'br': 'tl'
	            }
	
	            var scaleNodes = that.group.children().filter(function (node) {
	                return node.type === 'ConnectControl' && node.pos !== 'mtr'
	            });
	            var currentControlNode = scaleNodes.find(function(node) {
	                return node.pos === targetPos;
	            });
	
	            if (x <= 8) {
	                x = 8;
	            }
	            if (y <= 8) {
	                y = 8;
	            }
	
	            if (cursorsY.includes(cursor)) {
	                // 获取y轴比例即可
	                var startY = currentControlNode.shape.y + 4;
	                ratio = that.currentShape.y >= that.oppositeShape.y ? ((y - that.oppositeShape.y - 4) / (startY - that.oppositeShape.y)) : ((that.oppositeShape.y + 4 - y) / (that.oppositeShape.y - startY));
	            } else {
	                // 获取x轴比例即可
	                var startX = currentControlNode.shape.x + 4;
	                ratio = that.currentShape.x >= that.oppositeShape.x ? ((x - that.oppositeShape.x - 4) / (startX - that.oppositeShape.x)) : ((that.oppositeShape.x + 4 - x) / (that.oppositeShape.x - startX))
	            }
	            if (!/^[0-9]+.?[0-9]*/.test(ratio)) {
	                ratio = 1;
	            }
	            currentNode.updateShape(ratio);
	
	            var rectScale = util.getRect(currentNode, true);
	            centerPoint = that.ifPointCenter ? { x: that.originRect.x, y: that.originRect.y } : { x: that.originRect.boundingRect.x, y: that.originRect.boundingRect.y };
	            var diagonalNew = Math.sqrt(Math.pow(rectScale.width, 2) + Math.pow(rectScale.height, 2));// 对角线长度
	            switch (cursor) {
	                // 上,左上
	                case 'n-resize':
	                case 'nw-resize':
	                    width0 = (that.oppositeShape.x + 4 - centerPoint.x) * diagonalNew / that.diagonal;
	                    height0 = (that.oppositeShape.y + 4 - centerPoint.y) * diagonalNew / that.diagonal;
	                    center.push(that.oppositeShape.x - width0 + 4, that.oppositeShape.y - height0 + 4);
	                    break;
	                // 右,右上
	                case 'e-resize':
	                case 'ne-resize':
	                    width0 = (centerPoint.x - that.oppositeShape.x - 4) * diagonalNew / that.diagonal;
	                    height0 = (that.oppositeShape.y + 4 - centerPoint.y) * diagonalNew / that.diagonal;
	                    center.push(that.oppositeShape.x + width0 + 4, that.oppositeShape.y - height0 + 4);
	                    break;
	                // 下，右下
	                case 's-resize':
	                case 'se-resize':
	                    width0 = (centerPoint.x - that.oppositeShape.x - 4) * diagonalNew / that.diagonal;
	                    height0 = (centerPoint.y - that.oppositeShape.y - 4) * diagonalNew / that.diagonal;
	                    center.push(that.oppositeShape.x + width0 + 4, that.oppositeShape.y + height0 + 4);
	                    break;
	                // 左,左下
	                case 'w-resize':
	                case 'sw-resize':
	                    width0 = (that.oppositeShape.x + 4 - centerPoint.x) * diagonalNew / that.diagonal;
	                    height0 = (centerPoint.y - that.oppositeShape.y - 4) * diagonalNew / that.diagonal;
	                    center.push(that.oppositeShape.x - width0 + 4, that.oppositeShape.y + height0 + 4);
	                    break;
	                default:
	                    break;
	            }
	
	            var originScale = {
	                x: rectScale.x - center[0],
	                y: rectScale.y - center[1]
	            }
	            currentNode.attr({
	                'position': center,
	                'origin': [originScale.x, originScale.y]
	            });
	
	            // 此时节点包围盒需要重新计算
	            var rectNow = util.getRect(currentNode, true);
	            var connectorPointScale = util.getConnectorPoints(rectNow, currentNode);
	            var controlPointScale = util.getConnectorControls(rectNow, currentNode);
	            that.group.children().forEach(function(item) {
	                var pos = item.pos;
	                if (pos === targetPos) {
	                    item.attr('position', [0, 0]);
	                }
	                if (item.type === 'ConnectControl' && pos !== positionOrg[targetPos]) {
	                    item.setShape({ x: controlPointScale[pos].x - 4, y: controlPointScale[pos].y - 4 });
	                    item.attr('origin', [controlPointScale[pos].x, controlPointScale[pos].y]);
	                } else if (item.type === 'ConnectControlLine') {
	                    item.setShape({ x1: controlPointScale.mtr.x, x2: controlPointScale.tc.x, y1: controlPointScale.mtr.y, y2: controlPointScale.tc.y });
	
	                } else if (item.type === 'ConnectPoint') {
	                    item.setShape({ cx: connectorPointScale[pos].x, cy: connectorPointScale[pos].y });
	                }
	            });
	        }
	        that.operationNode.refreshPostion(that.selectedNode, util.getRect(that.selectedNode));
	        // 1.5 刷新连线
	        that.connectionManager.refreshLineByNode(that.selectedNode);
	        // 1.6 如果是组的话,需要把组内所有结果都刷新一下线
	        if (Flow.isGroupNode(that.selectedNode)) {
	            that.selectedNode.each(function(childNode) {
	                that.connectionManager.refreshLineByNode(childNode);
	            });
	        }
	
	    });
	    this.group.on("ConnectControl:dragend", function(e) {
	        // 更新节点position
	        var node = that.selectConnNode;
	        var position = node.position;
	        var origin = node.origin;
	        // position origin取整
	        that.selectConnNode.attr('position', [parseInt(position[0], 10), parseInt(position[1], 10)]);
	        if (Array.isArray(origin)) {
	            that.selectConnNode.attr('origin', [parseInt(origin[0], 10), parseInt(origin[1], 10)]);
	        }
	        node.updateShape(1, true);
	        if (node.model) {
	            // 更新model，支持序列化/反序列化
	            node.model.set("options.rotation", node.rotation);
	            node.model.set("options.origin", node.origin);
	            var elementType = node.model.option.elementType;
	            if (elementType === 'Image') {
	                node.model.set("options.style", node.style);
	            } else {
	                node.model.set("options.shape", node.shape);
	            }
	        }
	        // 1.4 触发点击
	        that.nodeClickHandler(node);
	        that.stepCounter();
	        that.oppositeShape = null;
	        that.currentShape = null;
	        that.diagonal = null;
	        that.originRect = null;
	        that.ifPointCenter = null;
	    });
	}
	
	    fishTopoProto.initOperationNode = function (node, ifCurrentNode) {
	        var that = this;
	        if (!ifCurrentNode) {
	            ifCurrentNode = false;
	        }
	        this.operationNode = new OperationNode(node, this.group, this._api);
	        // 根据连线点查找节点(考虑优化 创建连接点的时候 就把连接点与node进行绑定，就不用这个复杂的计算了)
	        function findConnectorNode(x, y, offset, pos) {
	            var node, endPos = null;
	            that.allNodes.forEach(function(item) {
	                var rect = util.getRect(item);
	                var connectorPoint = util.getConnectorPoints(rect, item);
	                if (pos) {
	                    if (Math.abs(connectorPoint[pos].x - x) <= offset && Math.abs(connectorPoint[pos].y - y) <= offset) {
	                        node = item;
	                    }
	                } else {
	                    if (Math.abs(connectorPoint["left"].x - x) <= offset && Math.abs(connectorPoint["left"].y - y) <= offset) {
	                        endPos = "left";
	                        node = item;
	                    } else if (Math.abs(connectorPoint["top"].x - x) <= offset && Math.abs(connectorPoint["top"].y - y) <= offset) {
	                        endPos = "top";
	                        node = item;
	                    } else if (Math.abs(connectorPoint["right"].x - x) <= offset && Math.abs(connectorPoint["right"].y - y) <= offset) {
	                        endPos = "right";
	                        node = item;
	                    } else if (Math.abs(connectorPoint["bottom"].x - x) <= offset && Math.abs(connectorPoint["bottom"].y - y) <= offset) {
	                        endPos = "bottom";
	                        node = item;
	                    }
	                }
	            });
	            return {
	                node: node,
	                endPos: endPos
	            };
	        }
	        this.operationNode.on(OperationNode.ARROW_DRAGSTART, function (e) {
	            this.hideConnectorPoint();
	            that.filterConnectPoint(that.allNodes, e.event.target.lineType);
	            var x = (e.event.offsetX - this.group.position[0]) / this.nowZoom;
	            var y = (e.event.offsetY - this.group.position[1]) / this.nowZoom;
	            if (e.data) {
	                this.lineOpt = e.data;  //缓存线段的配置信息
	            }
	            //拖拽开始先把 箭头图标 给隐藏
	            var arrow = e.event.target;
	            arrow.hide();
	            var rEndPoint = new Point(x, y);
	            var connector = this.connectionManager.manageTempConnector(this.selectedNode, rEndPoint,
	                arrow.lineType);
	            this.group.add(connector);
	            e.cancelBubble = true;
	        }.bind(this));
	
	        // 侦听 箭头 拖拽事件
	        this.operationNode.on(OperationNode.ARROW_DRAG, function (e) {
	            var x = (e.event.offsetX - this.group.position[0]) / this.nowZoom;
	            var y = (e.event.offsetY - this.group.position[1]) / this.nowZoom;
	            var arrow = e.event.target;
	            var rEndPoint = new Point(x, y);
	            this.connectionManager.manageTempConnector(this.selectedNode, rEndPoint, arrow.lineType);
	            that.group.children().forEach(function (v) {
	                if (v.type === 'ConnectPoint') {
	                    v.attr({style:{fill: "#FFFF33"},scale:[1,1],origin:[v.shape.cx,v.shape.cy]});
	                    if (Math.abs(v.shape.cx - x) <= 10 && Math.abs(v.shape.cy - y) <= 10) {
	                        var res = findConnectorNode(x, y, 10);
	                        that.connectionManager.manageTempConnector(that.selectedNode, rEndPoint, arrow.lineType, 'right', res.endPos, res.node);
	                        v.attr({style:{fill: "#ff0000"},scale:[1.5,1.5],origin:[v.shape.cx,v.shape.cy]});
	                    }
	                }
	            })
	            e.cancelBubble = true;
	        }.bind(this));
	
	        //侦听 箭头 拖拽结束事件 画线
	        this.operationNode.on(OperationNode.ARROW_DRAGEND, function (e) {
	            e.cancelBubble = true;
	            var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;
	            var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;
	            var res = findConnectorNode(x, y, 10);
	            var targetNode = res.node;
	            var endPos = res.endPos || 'left';
	            var arrow = e.event.target;
	            //拖拽结束先把 箭头图标 给显示
	            arrow.show();
	            //删除临时线
	            this.connectionManager.removeTempConnector(this.group);
	
	            //1.如果是子节点 内 节点拖拽 则 增加排除子节点的参数
	            // targetNode = findHover(this.allNodes, x, y);
	
	            //2.如果找到目标结点 则画线
	            if (targetNode && (this.selectedNode != targetNode)) {
	                var origin = {};
	                var connectOptions = {
	                    style: {
	                        lineType: arrow.lineType
	                    },
	                    position: {
	                        startPos: 'right',
	                        endPos: endPos
	                    }
	                }
	                var finalOpt = util.mergeOpt(connectOptions, that.lineOpt, true, 'position');
	                var start = that.selectedNode;
	                var end = targetNode;
	                //如果有原始连线存在，则要暴露出去。
	                if (that.originNode) {
	                    origin.startNode = that.selectedNode;
	                    origin.endNode = that.originNode;
	                    origin.options = util.mergeOpt({
	                        style: {
	                            lineType: arrow.lineType
	                        },
	                        position: {
	                            startPos: that.startPos,
	                            endPos: that.originPos
	                        }
	                    }, that.lineOpt, true, 'position');
	                }
	                if(!this._trigger('beforeCreate', {target:this.selectedNode,endNode:targetNode,connectOptions:connectOptions, origin: {}})) {
	                    return null;
	                }
	                that.createConnectorByNodes(start, end, finalOpt);
	            }
	            that.hideConnectorPoint();
	            // 连线成功/失败，当前节点依然是选中状态，需要重新计算虚线和图标位置
	            var node = that.selectedNode;
	            var shapeRect = util.getRect(node, true);
	            // 显示当前节点的连接点
	            that.showConnectorPoint('jagged', undefined, true);
	            that.operationNode.refreshPostion(node, shapeRect);
	        }.bind(this));
	
	        //删除按钮点击事件
	        this.operationNode.on(OperationNode.DELETE_CLICK, function () {
	            this.removeNode(this.selectedNode);
	        }.bind(this));
	        this.group.add(this.operationNode);
	    };
	
	    fishTopoProto.removeSelectedNodes = function() {
	        var that = this;
	        if (this.selectedNodes.length) {
	            this.selectedNodes.forEach(function(item, index) {
	                that.removeNode(item, {}, true);
	                if (index === that.selectedNodes.length - 1) {
	                    that.stepCounter();
	                }
	            });
	            this.selectedNodes = [];
	            this.dragSelectRect.off("mousedown");
	            this.group.remove(this.dragSelectRect);
	        } else if (that.selectedNode) {
	            that.removeNode(that.selectedNode);
	            // 1. 隐藏连线点
	            this.hideConnectorPoint();
	            // 2. 隐藏控制点
	            this.hideConnectorControl();
	            // 3. 隐藏操作node
	            this._removeOperationNode();
	        }
	    };
	
	    fishTopoProto.findNodeChildIds = function (node, childIds) {
	        childIds.push(node.id);
	        node.children().filter(function (v) {
	            var pos = this.allNodes.findIndex(function (item) {
	                return item.id === v.id
	            });
	            return pos !== -1
	        }.bind(this)).forEach(function (sub) {
	            if (Flow.isGroupNode(sub)) {
	                this.findNodeChildIds(sub, childIds);
	            } else {
	                childIds.push(sub.id);
	            }
	        }.bind(this));
	    }
	
	    /**
	     * 移除场景中的某个节点或者线段,同removeNode
	     * @method remove
	     * @param  {Object} node or link 待删除的节点或者线段
	     * @param {Object} [options] 参数
	     * @param {Boolean} [options.trigger=true] 是否触发删除事件
	     *
	     *  **使用范例**：
	     *
	     *      @example
	     *      fishTopo.remove(peopleNode);
	     */
	
	    /**
	     * 移除场景中的某个节点或者线段,同remove
	     * @method removeNode
	     * @param  {Object} node or link 待删除的节点或者线段
	     * @param {Object} [options] 参数
	     * @param {Boolean} [options.trigger=true] 是否触发删除事件
	     *
	     *  **使用范例**：
	     *
	     *      @example
	     *      fishTopo.removeNode(peopleNode);
	     */
	    fishTopoProto.remove = fishTopoProto.removeNode = function (delNode, options, isNoCount) {
	        var opt = options || {};
	        if(opt.trigger !==false && (!this._trigger('beforeDelete', {target:delNode}))) {
	            return;
	        }
	        var parentZr = this._getParentZr(delNode);
	        if (delNode instanceof Connector) {
	            // 1.1 删除线段上的操作图标
	            zrUtil.each(delNode.icons, function(lineOperationIcon) {
	                parentZr.remove(lineOperationIcon);
	            })
	            // 1.2 删除当前选中线段
	            this.connectionManager.deleteByLine(delNode,parentZr);
	        } else {
	            //2.1 删除节点
	            parentZr.remove(delNode);
	            var childIds = [];
	            if (Flow.isGroupNode(delNode)) {
	                this.findNodeChildIds(delNode, childIds);
	            } else {
	                childIds.push(delNode.id);
	            }
	            //2.从allNodes数组中删除
	            this.allNodes = this.allNodes.filter(function (v) {
	                return childIds.indexOf(v.id) === -1
	            });
	            //2.3 删除和节点相关联的线段
	            this.connectionManager.deleteSelectCon(delNode, this.group);
	            //2.4 删除节点操作
	            this._removeOperationNode();
	        }
	
	        //3. 清空连接线上的调整位置按钮
	        this.connectionManager.clearSelectCon();
	        //4. 清空连接线上的操作按钮
	        this.lineOperationManager.hideAllLineOperation();
	        if (isNoCount != true) {
	            this.stepCounter();
	        }
	        //4. 派发删除事件
	         this._trigger("delete", {target:delNode});
	    };
	
	    /**
	     * 选中场景中的某个节点,并且触发selectNode事件
	     * @param {Object} node 待选中的节点对象
	     * @since V2.3.0
	     *  **使用范例：**
	     * @example
	     * fishTopo.selectNode(node);
	     */
	
	    fishTopoProto.selectNode = function(node) {
	        if (node) {
	            this.nodeClickHandler(node);
	            this._trigger("selectNode", {target:node});
	        }
	    };
	
	    /**
	     * 根据节点创建连线
	     * @method createConnectorByNodes
	     * @param  {Object} startNode 开始节点
	     * @param  {Object} endNode   结束节点
	     * @param  {Object} options 线段选项 参见{@link fishTopoFlow.link#constructor 构造函数options参数}
	     * @param  {Boolean} trigger 是否触发create事件，默认是触发create事件，设置为false则不触发
	     */
	    fishTopoProto.createConnectorByNodes = function (startNode, endNode, options, trigger) {
	        var linkType = options.style.lineType || Connector.TYPE_STRAIGHT;
	        if (!flowLink[linkType]) {
	            return null;
	        }
	        var Link = flowLink[linkType];
	        var connector = new Link(startNode, endNode, options);
	        this.connectionManager.add(connector);
	
	        if (startNode.parent && endNode.parent && startNode.parent==endNode.parent ) {
	            endNode.parent.add(connector);
	        } else {
	            this.group.add(connector);
	        }
	
	        connector.on("mousedown", function (e) {
	            this.connectionManager.connectorForbidEdit();
	            this.isNode = false;
	            this.showConnectorPoint(e.target.style.lineType);
	        }.bind(this));
	        connector.on("dblclick", function () {
	            if (this.options.textEditable) {
	                this.connectorEdit(this);
	            }
	        }.bind(this));
	        if (trigger !== false) {
	            this._trigger("create", { target: connector });
	        }
	        this.stepCounter();
	        return connector;
	    };
	
	    /**
	     * @private
	     * 派发创建完成事件  返回fales则取消
	     */
	    fishTopoProto._trigger = function(type, event, data) {
	        var callback = this.options[type];
	
	        if (data === void 0) data = {};
	        if (event === null) {
	            event = {type:type, target:this}
	        } else {
	            event.type = type;
	        }
	        event.data = data;
	        this._api.trigger(event.type, event);
	        return !(zrUtil.isFunction(callback) && callback.apply(this, [event].concat(data)) === false);
	    }
	
	
	    fishTopoProto.nodeClickHandler = function (node) {
	        var ifShowPoint = node.type !== 'dragSelect';
	        if (node.parent && node.parent.type === "dragSelect") {
	            ifShowPoint = false;
	        }
	        // 1. 隐藏连线点
	        this.hideConnectorPoint();
	        // 2. 隐藏控制点
	        this.hideConnectorControl();
	        // 3. 隐藏操作node
	        this._removeOperationNode();
	        // 鼠标点下 将操作框 移到对应的节点上
	        if (node.selectable === false) {
	            if (Flow.isInGroup(node)) {
	                var group = node.parent;
	                if (group.selectable === false) {
	                    return;
	                } else {
	                    node = group;   // 如果有组的话，就针对组进行处理
	                }
	            } else {
	                return;
	            }
	        }
	
	        this.selectedNode = node;
	        var shapeRect = util.getRect(node,true);
	        if (!this.operationNode) {
	            this.initOperationNode(node, true);
	        }
	        if (ifShowPoint) {
	            // 显示当前节点的连接点
	            this.showConnectorPoint('jagged', undefined, true);
	            var params = this.returnConnectorControlParam(node);
	            if (params.scaleable || params.rotatable) {
	                // 显示当前节点的控制点
	                this.showConnectorControl();
	            }
	        }
	        // 在存在子流程的情况下 需要把node也传递一下
	        this.operationNode.refreshPostion(node, shapeRect);
	    };
	
	    /**
	     * @private
	     * 节点的移动操作, 为何要自己实现拖动？zredner Group不支持拖动，只能自己实现
	     */
	    fishTopoProto.drag = function (node) {
	        var that = this; // zrender中的一个bug event.target不会带group 只能用that 不能用bind(this)
	        node.on("mousedown", function (event) {
	            var draggingTarget = this;
	            //如果加了属性 draggable:false或者拖拽框选里 则不可以拖动
	            if (draggingTarget.isdraggable == false || (this.parent && this.parent.type === "dragSelect")) {
	                return;
	            }
	            that._nodeDragHandler(draggingTarget, event.offsetX, event.offsetY);
	            event.cancelBubble = true;
	        });
	    };
	
	    fishTopoProto._nodeDragHandler = function (node, x, y) {
	        var isMove = 0;
	        var ts = this;
	        var nowGroupPosition = node.position;
	        var groupPositionX = node.position[0];
	        var groupPositionY = node.position[1];
	        node._startX = x;
	        node._startY = y;
	        if (node.type === "dragSelect") {
	            var allLines = this.group.children().filter(function (v) {
	                return v.model && v.model.option.elementType === "connection";
	            });
	            var nodes = this.dragSelectRect.children().filter(function (v) {
	                return v.name !== "GROUP_RECT_NAME" && v.model && v.model.option.elementType !== "connection";
	            });
	            var lines = this.dragSelectRect.children().filter(function (v) {
	                return v.name !== "GROUP_RECT_NAME" && v.model && v.model.option.elementType === "connection";
	            });
	            allLines.forEach(function (v) {
	                var startNode = nodes.find(function(node) {
	                    return node.id === v.startNode.id
	                });
	                var endNode = nodes.find(function(node) {
	                    return node.id === v.endNode.id
	                });
	                var ifExist = lines.findIndex(function(line) {
	                    return line.id === v.id
	                });
	                if ((startNode || endNode) && ifExist === -1) {
	                    ts.connectionManager.removeLine(v, ts._getParentZr(v));
	                }
	            });
	        }
	        node.trigger("dragstart");
	        // 1、侦听移动事件
	
	        var moveHandler = function (event) {
	            event.cancelBubble = true;
	            var sX = (event.offsetX - node._startX) / (this.nowZoom);
	            var sY = (event.offsetY - node._startY) / (this.nowZoom);
	
	            if ((sX != 0) || (sY != 0)) {
	                isMove = 1;
	            }
	            node.trigger("drag");
	            // 1.1处理组内的情况（如果节点拖动，组也跟着变）
	            if (Flow.isInGroup(node)) {
	                //放入node现有数值，用于重绘group
	                var nodeMessage = {
	                    width: Flow.isGroupNode(node) ? node.options.shape.width : (node.shape ? node.shape.width : node.style.width),
	                    height: Flow.isGroupNode(node) ? node.options.shape.height : (node.shape ? node.shape.height : node.style.height),
	                    position: node.position,
	                    movePosition: [groupPositionX, groupPositionY],
	                    moveX: sX,
	                    moveY: sY,
	                    node: node,
	                    isMove: isMove
	                };
	                node.parent.modifyGroupRect(nodeMessage);
	            }
	            nowGroupPosition[0] = groupPositionX + sX;
	            nowGroupPosition[1] = groupPositionY + sY;
	            node.attr("position", nowGroupPosition);
	            // 1.2 处理告警的情况 （告警随着节点移动）
	            if (node.alarm) {
	                var newAlarmPosition = [nowGroupPosition[0] + node.getBoundingRect().width - (node.alarm
	                        .getBoundingRect().width - 6), nowGroupPosition[1] - node.alarm.getBoundingRect()
	                    .height - 3
	                ];
	                node.alarm.attr("position", newAlarmPosition);
	            }
	            // 1.4 触发点击
	            this.nodeClickHandler(node);
	            // 1.5 刷新连线
	            this.connectionManager.refreshLineByNode(node);
	            // 1.6 如果是组的话,需要把组内所有结果都刷新一下线
	            if (Flow.isGroupNode(node)) {
	                node.each(function(childNode) {
	                    this.connectionManager.refreshLineByNode(childNode);
	                }.bind(this));
	            }
	            if (!Flow.isInGroup(node)) {
	                var group = this.isPosInGroup(this.allNodes, node);
	                for (var i = 0; i < this.allNodes.length; i++) {
	                    var item = this.allNodes[i];
	                    if (Flow.isGroupNode(item)) {
	                        if (group && item.id === group.id && item.id !== node.id) {
	                            item.children().find(function (v) {
	                                return v.name === "GROUP_RECT_NAME"
	                            }).attr("style", {
	                                fill: "#b6e3f5"
	                            });
	                        } else {
	                            //恢复group的背景色
	                            item.children().find(function (v) {
	                                return v.name === "GROUP_RECT_NAME"
	                            }).attr("style", {
	                                fill: "rgba(0,0,0,0)"
	                            });
	                        }
	                    }
	                }
	            }
	        }.bind(this);
	        this._zr.on('mousemove', moveHandler);
	
	
	
	        //2. 拖拽结束
	        var endDragHandler = function () {
	            if (node.model) {
	                node.model.set("options.position", FlowUtil.truncPosition(node.position));
	            }
	
	            this._zr.off('mousemove', moveHandler);
	            this._zr.off('mouseup', endDragHandler);
	            this._zr.off("globalout", endDragHandler);
	
	            //2.1 缩微图
	            if (isMove == 1) {
	                this._trigger("dropDrag", {target:node});
	                node.trigger("dragend");
	                if (this.eagleEye == true) {
	                    this.openEagleEye(this.eagleEyeNode);
	                }
	                if (!Flow.isInGroup(node)) {
	                    var group = this.isPosInGroup(this.allNodes, node);
	                    if (group) {
	                        for (var i = 0; i < this.allNodes.length; i++) {
	                            var item = this.allNodes[i];
	                            if (Flow.isGroupNode(item) && item.id === group.id && item.id !== node.id) {
	                                var parentZr = this._getParentZr(node);
	                                parentZr.remove(node);
	                                item.add(node);
	                                var nodeX = Flow.isGroupNode(node) ? node.position[0] + node.options.shape.x : node.position[0];
	                                var nodeY = Flow.isGroupNode(node) ? node.position[1] + node.options.shape.y : node.position[1];
	                                var groupX = this.parentX(group);
	                                var groupY = this.parentY(group);
	                                node.attr("position", [nodeX - groupX + item.options.shape.x, nodeY - groupY + item.options.shape.y]);
	                                item.children().find(function (v) {
	                                    return v.name === "GROUP_RECT_NAME"
	                                }).attr("style", {
	                                    fill: "rgba(0,0,0,0)"
	                                });
	                            }
	                        }
	                    }
	                }
	                this.stepCounter();
	            }
	        }.bind(this);
	        this._zr.on('mouseup', endDragHandler);
	        this._zr.on('globalout', endDragHandler);
	    }
	    fishTopoProto.parentX = function (node) {
	        if (node.parent && Flow.isGroupNode(node.parent) && this.group.id !== node.parent.id) {
	            return node.position[0] + node.options.shape.x + this.parentX(node.parent);
	        } else {
	            return node.position[0] + node.options.shape.x;
	        }
	    }
	
	    fishTopoProto.parentY = function (node) {
	        if (node.parent && Flow.isGroupNode(node.parent) && this.group.id !== node.parent.id) {
	            return node.position[1] + node.options.shape.y + this.parentY(node.parent);
	        } else {
	            return node.position[1] + node.options.shape.y;
	        }
	    }
	
	    fishTopoProto.isPosInGroup = function (allNodes, node) {
	        if (allNodes.length > 0) {
	            var res = null;
	            for (var i = 0; i < allNodes.length; i++) {
	                var group = allNodes[i];
	                if (Flow.isGroupNode(group)) {
	                    var groupWidth = group.options.shape.width;
	                    var groupHeight = group.options.shape.height;
	                    var groupX = this.parentX(group);
	                    var groupY = this.parentY(group);
	                    var rect = util.getRect(node, true);
	                    var nodeWidth = rect.width;
	                    var nodeHeight = rect.height;
	                    var nodeX = rect.x - nodeWidth/2;
	                    var nodeY = rect.y - nodeHeight/2;
	                    if (nodeX >= groupX && nodeY >= groupY && nodeX+nodeWidth <= groupX+groupWidth && nodeY+nodeHeight <= groupY+groupHeight) {
	                        var children = group.children();
	                        var sub = this.isPosInGroup(children, node);
	                        res = sub ? sub : group;
	                        break;
	                    }
	                }
	            }
	            return res;
	        }
	        return null
	    }
	
	
	    /**
	     * 创建节点
	     * @method createNode
	     * @param  {String} type 类型 eg. 'Rect'、'Circle'、'Image'、'Group'、'Text'等
	     * @param  {Object} opt 节点选项 详见{@link fishTopoFlow.node Config options}
	     * @param {Object} userData 用户传递的业务数据
	     * @return {Object} 创建的节点对象
	     *
	     * **使用范例**：
	     *
	     *      @example
	     *      var rect = this.fishTopo.createNode("Rect", { //矩形
	     *          shape: {
	     *              width: 100,
	     *              height: 60,
	     *          },
	     *          style: {
	     *              text: "基本矩形",
	     *              fill: "#167CFF",
	     *              stroke: "rgb(255,255,255)",
	     *              textFont: '14px Microsoft YaHei'
	     *          },
	     *          position: [180, 100],
	     *          operationIcons: [{ name: 'DEL' },
	     *              { name: 'STRAIGHT' },
	     *              { name: 'JAGGED' },
	     *              { name: 'CURVE' },
	     *              {
	     *                  name: "custom1",
	     *                  iconPath: "img/host.png",
	     *                  callback: function(e) { alert(e.data.name + " clicked") }  //e.node是当前的节点
	     *              }
	     *          ]
	     *      });
	     */
	    fishTopoProto.createNode = fishTopoProto.creatNode = function (type, opt, userData) {
	        if (!flowNode[type]) {
	            return null;
	        }
	        var Shape = flowNode[type];
	        var node = new Shape(opt);
	
	        Flow.setUserData(node, userData);
	        return node;
	    };
	
	    /**
	     * 根据name获取节点
	     * @param  {String} name 在创建节点中  name属性设置的值
	     * @return {Object}      name对应的节点
	     */
	    fishTopoProto.childOfName = function (name) {
	        var arrResult = [];
	        var childrenNode = this.allNodes;
	        var childrenLine = this.connectionManager.connectors;
	        for (var i = 0; i < childrenNode.length; i++) {
	            if (childrenNode[i].model.get("options.name") && childrenNode[i].model.get("options.name") ==
	                name) {
	                arrResult.push(childrenNode[i]);
	            } else if (childrenNode[i].model.get("userData.name") == name) {
	                arrResult.push(childrenNode[i]);
	            }
	        }
	        for (var j = 0; j < childrenLine.length; j++) {
	            if (childrenLine[j].model.get("options.name") && childrenLine[j].model.get("options.name") ==
	                name) {
	                arrResult.push(childrenLine[j]);
	            } else if (childrenLine[j].model.get("userData.name") == name) {
	                arrResult.push(childrenLine[j]);
	            }
	        }
	        if (arrResult.length > 1) {
	            return arrResult;
	        } else {
	            return arrResult[0];
	        }
	    };
	
	    /**
	     * 查找场景中的对象   例如: x坐标大于100的节点 findElements(function(node){ return node.position[0] > 100; });
	     * @param  {Function} cb      回调函数 参数为遍历的节点
	     * @param  {Object}   context 回调函数执行的上下文
	     * @return {Array}           返回查找到的对象
	     */
	    fishTopoProto.findElements = function (cb, context) {
	        var childrenNode = this.allNodes;
	        var childrenLine = this.connectionManager.connectors;
	        var arr = [];
	        for (var i = 0; i < childrenNode.length; i++) {
	            var child = childrenNode[i];
	            if (cb.call(context, child, i)) {
	                arr.push(child);
	            }
	        }
	        for (var j = 0; j < childrenLine.length; j++) {
	            var childL = childrenLine[j];
	            if (cb.call(context, childL, j)) {
	                arr.push(childL);
	            }
	        }
	        return arr;
	    };
	
	    /**
	     * 根据节点查找连线   例如: 默认查找开始节点的连线 findConnectorsByNode(node);
	     * @param  {Object}   node    节点
	     * @param  {Object}   options 是否查找开始节点
	     * @return {Array}            返回查找到的对象
	     */
	    fishTopoProto.findConnectorsByNode = function (node,options) {
	        var opts = options || {};
	        var arr = [];
	        // Default value
	        zrUtil.defaults(opts, {
	            startNode: true
	        });
	        var childrenLine = this.connectionManager.connectors;
	        for (var j = 0; j < childrenLine.length; j++) {
	            var childL = childrenLine[j];
	            if (opts.startNode) {
	                if(childL.startNode.id === node.id) {
	                    arr.push(childL);
	                }
	            } else {
	                if(childL.endNode.id === node.id) {
	                    arr.push(childL);
	                }
	            }
	        }
	        return arr;
	    };
	
	    /**
	     * 设置背景色  或 背景图片
	     * @param {string} imageUrl 背景色  或 背景图片 eg. 'img/bg.jpg'，为‘gridLine’时网格背景
	     * @param {string} isRepeat 是否重复背景  如果重复的话，将使用css的repeat 因为canvas不支持repeat
	     */
	    fishTopoProto.setBackground = function (imageUrl, isRepeat) {
	        if (imageUrl && imageUrl.length > 0) {
	            this.model.set(Constants.BACKGROUND, imageUrl);
	            if (imageUrl.substr(0, 1) == "#" || imageUrl.substr(0, 4) == "rgba") { //如果是颜色创建rect为背景
	                if (!document.createElement('canvas').getContext) {
	                    this._dom.style.backgroundColor = imageUrl;
	                } else {
	                    var imageShape = new this.Shape.Rect({
	                        shape: {
	                            width: this._zr.getWidth(),
	                            height: this._zr.getHeight()
	                        },
	                        style: {
	                            fill: imageUrl
	                        },
	                        cursor: 'default',
	                        z: -1
	                    });
	                    this._zr.add(imageShape);
	                }
	
	            } else if (imageUrl == "gridLine") {
	                this.gridLineGroup = new graphic.Group();
	                this.gridLine(0.2);
	                this._zr.add(this.gridLineGroup);
	            } else {
	                if (!document.createElement('canvas').getContext || isRepeat) {
	                    this._dom.style.backgroundImage = "url(" + imageUrl + ")";
	                    this._dom.style.backgroundRepeat = "repeat";
	                } else {
	                    var imageShape1 = new this.Shape.Image({ //如果是图片创建image为背景
	                        position: [0, 0],
	                        scale: [1, 1],
	                        style: {
	                            x: 0,
	                            y: 0,
	                            image: imageUrl,
	                            width: this._zr.getWidth(),
	                            height: this._zr.getHeight()
	                        },
	                        cursor: 'default',
	                        z: -1
	                    });
	                    this._zr.add(imageShape1);
	                }
	            }
	        }
	    };
	
	    //背景网格线
	    fishTopoProto.gridLine = function (opacity) {
	        var pixel = 10;
	        var widthLen = parseInt(this.getWidth() / pixel);
	        for (var x = 0; x <= widthLen; x++) {
	            var lineX = new graphic.Line({
	                shape: {
	                    x1: x * pixel,
	                    y1: 0,
	                    x2: x * pixel,
	                    y2: this.getHeight()
	                },
	                style: {
	                    lineDash: [1],
	                    opacity: opacity
	                },
	                z: 0,
	                draggable: false,
	                cursor: 'default'
	            });
	            this.gridLineGroup.add(lineX);
	        }
	
	        var heightLen = parseInt(this.getHeight() / pixel, pixel);
	        for (var y = 0; y <= heightLen; y++) {
	            var lineY = new graphic.Line({
	                shape: {
	                    x1: 0,
	                    y1: y * pixel,
	                    x2: this.getWidth(),
	                    y2: y * pixel
	                },
	                style: {
	                    lineDash: [1],
	                    opacity: opacity
	                },
	                z: 0,
	                draggable: false,
	                cursor: 'default'
	            });
	            this.gridLineGroup.add(lineY);
	        }
	    };
	
	    /**
	     * 创建线段
	     * @method createLink
	     * @param  {Object} startNode 开始节点
	     * @param  {Object} endNode   结束节点
	     * @param  {Object} options 线段选项
	     * @param {Object} [options.style] 节点的样式
	     * @param {Number} [options.style.lineWidth=1] 线段的宽度
	     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'
	     * @param {String} [options.style.stroke="#000000"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'
	     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]
	     * @param {Object} [options.symbol] 线段的箭头
	     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸
	     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色
	     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]
	     * @param {Object} [options.text] 线段上的文字
	     * @param {String} [options.text.text] 线段上的文字内容
	     * @param {String} [options.text.color] 线段上的文字颜色
	     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center
	     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]
	     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {String} [options.position] 指定线段位置
	     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {Object} [options.position.startOffset] 线段开始位置的偏移
	     * @param {Object} [options.position.endOffset] 线段结束位置的偏移
	     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]
	     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom
	     * @param {Object} [options.effect] 线上动态效果
	     * @param {String} [options.effect.show] 是否显示箭头动效
	     * @param {Number} [options.effect.period] 动效移动速度
	     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase
	     * @param {Number} [options.z] [连线的层级，越大越在前面显示]
	     * @param {Object} userData 用户传递的业务数据
	     * @return {Object} 创建的线段对象
	     *
	     * **使用范例**：
	     *
	     *      @example
	     *      var link = me.fishTopo.createLink(startNode, endNode, {
	     *              symbol: { type: 'arrow', size: 10, color: "rgb(0,200,255)" }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	     *              style: { lineWidth: 3, stroke: "rgb(0,200,255)", lineDash: [3,3], lineType: "jagged"  }, //样式
	     *              text: {
	     *                  text: text,
	     *                  color: '#ffffff',
	     *                  textPos:textPos,//文字位置可选值 'start','center','end',默认值为center
	     *                  xOffset:10, //文字位置x偏移量
	     *              },
	     *              pos:'right,left',
	     *              effect: {
	     *                  show: true,//是否显示箭头动效
	     *                  period: 6,//箭头速度
	     *              },
	     *              position:{
	     *                    escapeDistance:[50,30],  //第一条折线的长度，最后一条折线的长度
	     *                    points:["x1,y1","x2,y2"]  不使用自动计算 指定连线的位置数组
	     *              },
	     *              z: 0
	     *          });
	     */
	    fishTopoProto.createLink = fishTopoProto.creatLink = function (startNode, endNode, options, userData) {
	        var linkType = Connector.TYPE_STRAIGHT;
	        if (options && options.style && options.style.lineType) {
	            linkType = options.style.lineType
	        }
	
	        if (!flowLink[linkType]) {
	            return null;
	        }
	        var Link = flowLink[linkType];
	        var connector = new Link(startNode, endNode, options);
	        if (userData) {
	            connector.model.set(Constants.USERDATA, zrUtil.clone(userData));
	        }
	
	        return connector;
	    };
	
	    /**
	     * 根据节点刷新节点所连的线（重新计算线的位置）
	     * @param  {Object} node [节点]
	     */
	    fishTopoProto.refreshLineByNode = function (node) {
	        this.connectionManager.refreshLineByNode(node);
	    };
	
	
	    /**
	     * @private
	     * 线上文字编辑
	     */
	    fishTopoProto.connectorEdit = function (thisConnector) {
	        var lineText = thisConnector.childOfName('lineText');
	        if (!lineText) {
	            return;
	        }
	        var textarea = this.createTextArea();
	        var textRect = textContain.getBoundingRect(lineText.style.text, lineText.style.textFont);
	        var maxWidth = 1.2 * util.getRect(lineText).width * this.nowZoom + 10;
	        textarea.style.width = 1.2 * util.getRect(lineText).width * this.nowZoom + "px";
	        textarea.style.height = (2 * textRect.height || 12) * this.nowZoom + "px";
	        textarea.style.border = "1px dashed #2e2e2e";
	        textarea.innerHTML = lineText.style.text;
	        thisConnector.setStyle({
	            text: {
	                text: ""
	            }
	        })
	        this._dom.appendChild(textarea);
	        this._dom.style.position = "relative";
	        textarea.style.lineHeight = (1.2 * textRect.lineHeight || 12) + "px";
	        textarea.style.top = (lineText.position[1] - textRect.height) * this.nowZoom + this.group
	            .position[1] + "px";
	        textarea.style.left = (lineText.position[0] - 0.55 * textRect.width) * this.nowZoom +
	            this.group.position[0] + "px";
	        textarea.focus();
	        textarea.select();
	        this._textareaResize(textRect, textarea, maxWidth);
	        textarea.onkeyup = function () {
	            textarea.style.width = textRect.width < 60 ? "80px" : textarea.style.width;
	            textarea.style.height = textarea.scrollHeight + 'px';
	        }
	        textarea.onfocusout = function () {
	            thisConnector.setStyle({
	                text: {
	                    text: textarea.value || ""
	                }
	            })
	            textarea.remove();
	        }
	    };
	    /**
	     * @private
	     * 节点上文字编辑
	     */
	    fishTopoProto.nodeEdit = function (thisNode) {
	        var MAXWIDTH_MULTIPLE_TOP_BOTTOM = 3.3; //text最大宽度与节点宽度的系数，在top/bottom位置
	        var isNotSetText = false;
	        var textarea = this.createTextArea();
	        var nodeText = zrUtil.clone(thisNode.style.text);
	        var textRect = textContain.getBoundingRect(nodeText, thisNode.style.textFont);
	        var textareaWidth = textRect.width < 25 ? (1.2 * textRect.width * this.nowZoom + 10) : 36;
	        var textareaHeight = (2 * textRect.height || 24) * this.nowZoom;
	        textarea.style.width = textareaWidth + 'px';
	        textarea.style.height = textareaHeight + "px";
	        var nodeRect = util.getRect(thisNode);
	        var maxWidth = 1.2 * nodeRect.width * this.nowZoom;
	        textarea.style.lineHeight = (1.2 * textRect.lineHeight || 14.4) + "px";
	        textarea.style.border = "1px dashed #2e2e2e";
	        textarea.innerHTML = thisNode.style.text;
	        textarea.style.maxWidth = maxWidth + 'px';
	        this.setStyle(thisNode, {text: ""});  //先把节点文本给清空，否则删除文本框中文字的时候，会显示出来
	        this._dom.appendChild(textarea);
	        this._dom.style.position = "relative";
	        var offestI = 1;
	        if (thisNode.style.textAlign == "left") {
	            offestI = 0;
	        }
	        if (thisNode.style.textAlign == "right") {
	            offestI = 2;
	        }
	        var offestP = 0;
	        if (thisNode.style.textPosition && thisNode.style.textPosition == "bottom") {
	            offestP = 1;
	            maxWidth = MAXWIDTH_MULTIPLE_TOP_BOTTOM * nodeRect.width * this.nowZoom;
	            textarea.style.maxWidth = maxWidth + "px";
	        }
	        if (thisNode.style.textPosition && thisNode.style.textPosition == "top") {
	            offestP = -1;
	            maxWidth = MAXWIDTH_MULTIPLE_TOP_BOTTOM * nodeRect.width * this.nowZoom;
	            textarea.style.maxWidth = maxWidth + "px";
	        }
	        textarea.style.top = (nodeRect.y - textareaHeight / 2 + offestP * (nodeRect.height - textRect.height /
	            2)) * this.nowZoom + this.group.position[1] + "px";
	        textarea.style.left = (nodeRect.x - offestI * textareaWidth / 2) * this.nowZoom +
	            this.group.position[0] + "px";
	        textarea.focus();
	        textarea.select();
	        textarea.onkeyup = function() {
	            if (event.keyCode == keyCode.ESCAPE) {
	                isNotSetText = true;
	                textarea.blur();
	            } else {
	                var textRect = textContain.getBoundingRect(textarea.value, thisNode.style.textFont);
	                this._textareaResize(textRect, textarea, maxWidth);
	            }
	        }.bind(this);
	
	        textarea.onblur = function() {
	            if (!isNotSetText) {
	                var text = this.handleWrap(textarea.value, textarea.style.maxWidth);
	                this.setStyle(thisNode, {text: text});
	            } else {
	                this.setStyle(thisNode, {text: nodeText});
	            }
	            textarea.remove();
	        }.bind(this);
	    };
	
	    /**
	     * @private
	     * 创建文本域
	     */
	    fishTopoProto.createTextArea = function () {
	        var textarea = document.createElement("textarea");
	        textarea.style.position = "absolute";
	        textarea.style.padding = "6px";
	        textarea.style.resize = "none";
	        textarea.style.whiteSpace = "pre";
	        textarea.style.lineHeight = "125%";
	        textarea.style.overflow = "hidden";
	        textarea.style.border = "0";
	        textarea.spellcheck = false;
	        return textarea;
	    };
	
	    /**
	     * @private
	     * 处理textarea自动换行
	     */
	    fishTopoProto.handleWrap = function (value, width) {
	        var spanNode = document.createElement("span");
	        spanNode.style.position = "absolute";
	        spanNode.style.overflow = "hidden";
	        spanNode.style.border = "0";
	        spanNode.style.padding = "0";
	        spanNode.style.left = "0";
	        spanNode.style.top = "0";
	        this._dom.appendChild(spanNode);
	        var content = value.split("\n");
	        var result = "";
	        content.forEach(function(val, i){
	            var valLength = val.length;
	            if (valLength == 0) {
	                //result += "\n";
	            } else {
	                var pre = "",
	                    innerVal, tempWidth, conWidth;
	                for (var innerI = 0; innerI < valLength; innerI++) {
	                    innerVal = val.charAt(innerI);
	                    spanNode.innerHTML = spanNode.innerHTML + innerVal;
	                    tempWidth = spanNode.clientWidth; //获取添加字符后隐藏域的宽度
	                    conWidth = Number(width.substring(0, width.length - 2));
	                    if (tempWidth > conWidth) {
	                        result += pre; //如果追加字符后隐藏域宽度大于TextArea宽度，则表明该字符为下一行字符，
	                        result += "\n";
	                        spanNode.innerHTML = innerVal;
	                        pre = innerVal;
	                    } else if (innerI == valLength - 1) {
	                        result += pre + innerVal; //最后一个字符
	                        if (i < content.length - 1) {
	                            result += "\n";
	                        }
	                        spanNode.innerHTML = "";
	                        pre = "";
	                    } else {
	                        pre += innerVal; //依次追加到pre变量中
	                    }
	
	                }
	            }
	        });
	        this._dom.removeChild(spanNode);
	        return result;
	    };
	
	    /**
	     * @private
	     * 文本域自适应高宽
	     */
	    fishTopoProto._textareaResize = function (textRect, textarea, width) {
	        var minWidth = 0;
	        textarea.style.width = 0;
	        textarea.style.width = (1.2 * textRect.width) * this.nowZoom + "px";
	        if (width < 60) {
	            minWidth = width;
	        } else {
	            minWidth = 80
	        }
	        if (textRect.width <= minWidth) {
	            textarea.style.width = minWidth + "px";
	        }
	        textarea.style.height = "0px";
	        textarea.style.height = textarea.scrollHeight + 'px';
	        if (textarea.scrollHeight <= 0) {
	            textarea.style.height = "12px";
	        }
	    }
	
	    /**
	     * @method setStyle
	     * 节点更改style里的属性
	     * @param {String} name 节点style里的某个属性名称
	     * @param {String} string 节点style里的某个属性名称对应的值
	     * **使用范例**：
	     *
	     *      @example
	     *          //节点设置文字
	     *         fishtopo.setStyle(node,{text:"例子"});
	     */
	    fishTopoProto.setStyle = function (node, options) {
	        node.setStyle(options);
	        zrUtil.merge(node.model.get("options.style"), options, true);
	    }
	
	    /**
	     * @method setShape
	     * 节点更改shape里的属性
	     * @param {String} name 节点shape里的某个属性名称
	     * @param {String} string 节点shape里的某个属性名称对应的值
	     * **使用范例**：
	     *
	     *      @example
	     *          //矩形节点设置宽
	     *         fishtopo.setShape(node,{width:100});
	     */
	    fishTopoProto.setShape = function (node, options) {
	        node.setShape(options);
	        if (node.model) {
	            zrUtil.merge(node.model.get("options.shape"), options, true);
	        }
	    }
	
	    /**
	     * 创建节点上面的警告
	     * @method createAlarm
	     * @param  {Object} node 节点
	     * @param  {Object} opt  选项值
	     * @param  {Object} [opt.text] 警告的文字
	     * @param  {Object} [opt.textFont] 警告的文字的字体
	     * @param  {Object} [opt.textFill] 警告的文字的颜色
	     * @param  {Object} [opt.textBackground] 警告的背景的颜色
	     * @return {Object} 返回节点上的警告
	     *
	     * **使用范例**：
	     *
	     *      @example
	     *          this.fishTopo.createAlarm(s1,{
	     *          text:"2 W",
	     *          textFont:"4px Microsoft YaHei",
	     *          textFill:"#FFFFFF",
	     *          textBackground:"rgba(255,0,0,0.6)"
	     *      });//创建小图片和节点绑定
	     */
	    fishTopoProto.createAlarm = fishTopoProto.creatAlarm = function (node, opt) {
	        var group = this.createNode("Group", {
	            style: {
	                fill: 'rgba(0,0,0,0)',
	                stroke: 'rgba(0,0,0,0)'
	            }
	        });
	        group.isdraggable = false;
	        var text = this.createNode("Text", { //文字
	            style: {
	                text: opt.text,
	                textFont: opt.textFont,
	                fill: opt.textFill,
	                textBaseline: "top" //垂直对齐,
	            },
	            selectable: false,
	            position: [2, 0],
	            z: 2
	        });
	        text.isdraggable = false;
	        group.add(text);
	        if (Flow.isInGroup(node)) {
	            node.parent.add(group);
	        } else {
	            this.group.add(group);
	        }
	        var groupWidth = group.getBoundingRect().width + 2;
	        var groupHeight = group.getBoundingRect().height + 6;
	        var points = [
	            [0, 0],
	            [groupWidth, 0],
	            [groupWidth, groupHeight],
	            [groupWidth - 3, groupHeight],
	            [groupWidth - 6, groupHeight + 3],
	            [groupWidth - 9, groupHeight],
	            [0, groupHeight],
	            [0, 0]
	        ];
	        var Polyline = this.createNode("Polyline", {
	            shape: {
	                points: points
	            },
	            style: {
	                fill: opt.textBackground,
	                stroke: opt.textBackground
	            },
	            selectable: false,
	            z: 1
	        });
	        Polyline.isdraggable = false;
	        group.add(Polyline);
	        var groupPosition = [node.position[0] + node.getBoundingRect().width - (group.getBoundingRect().width -
	            6), node.position[1] - group.getBoundingRect().height - 3];
	        group.attr("position", groupPosition);
	        node.alarm = group;
	        //设置模型 给json序列化用
	        var model = new Model({});
	        model.set(Constants.ELEMENT_TYPE, Constants.ALARM);
	        model.set(Constants.OPTIONS, zrUtil.clone(opt));
	        model.set(Constants.RELATIONID, node.model.get(Constants.ID));
	        group.model = model;
	        return group;
	    };
	
	    /**
	     * @private
	     * 返回当前画布的数据
	     */
	    fishTopoProto.toDataURL = function (opts) {
	        return FlowUtil.toDataURL(this._zr, opts);
	    };
	
	    fishTopoProto._releaseSelectNode = function () {
	        if (this.dragSelectRect) {
	            var nodes = this.dragSelectRect.children().filter(function (v) {
	                return v.name !== "GROUP_RECT_NAME";
	            });
	            var groupNodesIds = this.group.children()
	                .filter(function (v) {
	                    return v.name !== "GROUP_RECT_NAME";
	                })
	                .map(function(v) {
	                    return v.id
	                });
	            var startX = this.dragSelectRect.position[0];
	            var startY = this.dragSelectRect.position[1];
	            for (var i = 0; i < nodes.length; i++) {
	                var item = nodes[i];
	                var nodeX = Flow.isGroupNode(item) ? item.position[0] + item.options.shape.x : item.position[0];
	                var nodeY = Flow.isGroupNode(item) ? item.position[1] + item.options.shape.y : item.position[1];
	                this.dragSelectRect.remove(item);
	                // group内不存在dragSelectRect节点方可添加
	                if (!groupNodesIds.includes(item.id)) {
	                    this.group.add(item);
	                }
	                if (item.model.option.elementType !== "connection") {
	                    item.attr("position", [nodeX+startX, nodeY+startY]);
	                    this.connectionManager.refreshLineByNode(item);
	                }
	            }
	            this.dragSelectRect.off("mousedown");
	            this.group.remove(this.dragSelectRect);
	        }
	    }
	
	    fishTopoProto._dragSelect = function (node, x, y) {
	        var canvasOffsetX = this.group.position[0];
	        var canvasOffsetY = this.group.position[1];
	        this._releaseSelectNode();  //还原选中的节点
	        this.dragSelectRect = new GroupNode({
	            shape:{ width: 0, height: 0},
	            position:[(x-canvasOffsetX)/this.nowZoom, (y-canvasOffsetY)/this.nowZoom],
	            childDraggable: false,
	            style: {
	                lineDash:[2,2],
	                fill: "rgba(239,222,221,0.7)",
	                stroke: '#ddd'
	            }
	        });
	        this.dragSelectRect.type = "dragSelect";
	        this.group.add(this.dragSelectRect);
	        this.drag(this.dragSelectRect);
	
	        var moveHandler = function (event) {
	            var posX = x <= event.offsetX ? x : event.offsetX;
	            var posY = y <= event.offsetY ? y : event.offsetY;
	            var width = Math.abs(event.offsetX - x);
	            var height = Math.abs(event.offsetY - y);
	            this.dragSelectRect.shape = {
	                width: width/this.nowZoom,
	                height: height/this.nowZoom
	            }
	            this.dragSelectRect.setProperties({shape: {width:width/this.nowZoom, height: height/this.nowZoom}, position: [(posX-canvasOffsetX)/this.nowZoom, (posY-canvasOffsetY)/this.nowZoom]});
	        }.bind(this);
	        this._zr.on('mousemove', moveHandler);
	
	        var endDragHandler = function (event) {
	            this._zr.off('mousemove', moveHandler);
	            this._zr.off('mouseup', endDragHandler);
	            this._zr.off("globalout", endDragHandler);
	
	            var ts = this;
	            var allNodes = this.group.children().filter(function (v) {
	                return v.id !== ts.dragSelectRect.id && v.model && v.model.option.elementType !== "connection";
	            });
	            var allLines = this.group.children().filter(function (v) {
	                return v.model && v.model.option.elementType === "connection";
	            });
	            var startX = this.dragSelectRect.position[0];
	            var startY = this.dragSelectRect.position[1];
	            var width = this.dragSelectRect.options.shape.width;
	            var height = this.dragSelectRect.options.shape.height;
	            var cnt = 0;
	            allNodes.forEach(function (item) {
	                var rect = util.getRect(item, true);
	                var nodeWidth = rect.width;
	                var nodeHeight = rect.height;
	                var nodeX = rect.x - nodeWidth/2;
	                var nodeY = rect.y - nodeHeight/2;
	                if (nodeX >= startX && nodeY >= startY && nodeX+nodeWidth <= startX+width && nodeY+nodeHeight <= startY+height) {
	                    ts.group.remove(item);
	                    ts.dragSelectRect.add(item);
	                    ts.selectedNodes.push(item);
	                    item.attr("position", [item.position[0]-startX, item.position[1]-startY]);
	                    cnt++;
	                }
	            });
	            allLines.forEach(function (item) {
	                var startNode = ts.dragSelectRect.children().find(function (v) {
	                    return v.id === item.startNode.id;
	                });
	                var endNode = ts.dragSelectRect.children().find(function (v) {
	                    return v.id === item.endNode.id;
	                });
	                if (startNode && endNode) {
	                    ts.group.remove(item);
	                    ts.dragSelectRect.add(item);
	                    ts.selectedNodes.push(item);
	                    ts.connectionManager.refreshLineByNode(item.startNode);
	                } else if (startNode || endNode) {
	                    // 删除选框外的节点与内节点间的连线
	                    ts.group.remove(item);
	                }
	            });
	            if (!cnt) {
	                this.dragSelectRect.off("mousedown");
	                this.group.remove(this.dragSelectRect);
	            } else {
	                this.dragSelectRect.childOfName("GROUP_RECT_NAME").attr("style", {
	                    fill: "rgba(0,0,0,0)"
	                });
	            }
	            this.dragSelectRect.model.set("options.position", FlowUtil.truncPosition(this.dragSelectRect.position));
	            this.dragSelectRect.model.set("options.shape", this.dragSelectRect.shape);
	            // this.stepCounter();
	        }.bind(this);
	        this._zr.on('mouseup', endDragHandler);
	        this._zr.on("globalout", endDragHandler);
	    }
	
	    fishTopoProto._groupDragHandler = function (x, y) {
	        // flow中最外层的group移动操作
	        var nowGroupPosition = this.group.position;
	        var groupPositionX = this.group.position[0];
	        var groupPositionY = this.group.position[1];
	
	        var moveHandler = function (event) {
	            var width = this.group.getBoundingRect().width * this.nowZoom;
	            var height = this.group.getBoundingRect().height * this.nowZoom;
	            var gx = this.group.getBoundingRect().x * this.nowZoom;
	            var gy = this.group.getBoundingRect().y * this.nowZoom;
	            var min = [10 - (width + gx), 10 - (height + gy)];
	            var max = [(this._zr.getWidth() - gx) - 10, (this._zr.getHeight() - gy) - 10];
	            var sX = event.offsetX - x;
	            var sY = event.offsetY - y;
	            nowGroupPosition[0] = groupPositionX + sX;
	            nowGroupPosition[1] = groupPositionY + sY;
	            if (nowGroupPosition[0] > max[0] || nowGroupPosition[1] > max[1] || nowGroupPosition[0] <
	                min[0] || nowGroupPosition[1] < min[1]) {
	                return;
	            } else {
	                this.group.attr("position", nowGroupPosition);
	                if (this.eagleEye == true) {
	                    this.minimap.updataSelectionPosition(nowGroupPosition, this.nowZoom);
	                }
	            }
	        }.bind(this);
	        this._zr.on('mousemove', moveHandler);
	
	        var endDragHandler = function () {
	            this._zr.off('mousemove', moveHandler);
	            this._zr.off('mouseup', endDragHandler);
	            this._zr.off("globalout", endDragHandler);
	        }.bind(this);
	        this._zr.on('mouseup', endDragHandler);
	        this._zr.on("globalout", endDragHandler);
	    };
	
	    fishTopoProto.initScale = function () {
	        var groupMaxWidth = this.group.getBoundingRect().width;
	        var groupMaxHeight = this.group.getBoundingRect().height;
	        var rangeWidth = this.getWidth();
	        var rangeHeight = this.getHeight();
	        var initRatio = 1,
	            pos = [];
	        if (groupMaxWidth / groupMaxHeight > rangeWidth / rangeHeight) {
	            if (groupMaxWidth > rangeWidth) {
	                initRatio = rangeWidth / groupMaxWidth;
	            }
	        } else {
	            if (groupMaxHeight > rangeHeight) {
	                initRatio = rangeHeight / groupMaxHeight;
	            }
	        }
	        pos[0] = Math.abs(this.group.getBoundingRect().x) * initRatio;
	        pos[1] = Math.abs(this.group.getBoundingRect().y) * initRatio;
	        this.group.attr("position", [pos[0], pos[1]]);
	        this.group.attr("scale", [initRatio, initRatio]);
	        this.initScaleRatio = initRatio;
	        var distance = [pos[0], pos[1], this.initScaleRatio, groupMaxWidth, groupMaxHeight];
	        return distance;
	    };
	
		/**
		 * 画布元素在水平方向和垂直方向居中
	     * @param  {Object} boundPos 其中需传入的属性分别为minX,minY,maxX,maxY包围画布上所有节点的最小边框的最小的x坐标、y坐标、最大的x坐标、y坐标
		 */
		fishTopoProto.zrCenter = function (boundPos) {
	        var boundObj;
	        var nowGroupPosition = this.group.position;
	        if (zrUtil.isArray(boundPos)) {
	            boundObj = zrUtil.extend({}, {minX: boundPos[0], minY: boundPos[1], maxX: boundPos[2], maxY: boundPos[3]});
	        } else {
	            boundObj = zrUtil.extend({}, boundPos);
	        }
	        nowGroupPosition[0] = this._zr.dom.offsetWidth/2 - (boundObj.minX + ((boundObj.maxX - boundObj.minX)/2));
	        nowGroupPosition[1] = this._zr.dom.offsetHeight/2 - (boundObj.minY + ((boundObj.maxY - boundObj.minY)/2));
	        this.group.attr("position", nowGroupPosition);
	    };
	
	    fishTopoProto.stepCounter = function() {
	        this.stepJson.splice(this.step, this.stepJson.length - (this.step));
	        this.step += 1;
	        var json = this.toJson();
	        this.stepJson.push(JSON.stringify(json));
	    };
	
	    /**
	     * 放大或者缩小
	     * @param  {String|Number} type 当为字符串时 "enlarge"放大  "narrowing"缩小  当为数值时 缩放的比例  建议0.3-1.7
	     */
	    fishTopoProto.zrScale = function (type) {
	        if (type) {
	            var zoomDelta = 0;
	            if (type == "narrowing") {
	                zoomDelta = -0.07;
	                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);
	            }
	            if (type == "enlarge") {
	                zoomDelta = 0.07;
	                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);
	            }
	            if (!isNaN(type)) {
	                var target = this.group;
	                if (target) {
	                    var zoomScale = type / target.scale[0];
	                    this._zoom = type;
	                    this.nowZoom = type;
	                    this.setScale(this._zr.getWidth() / 2, this._zr.getHeight() / 2,zoomScale);
	                }
	            }
	        } else {
	            this._zr.on('mousewheel', zrUtil.bind(function (e) {
	                eventTool.stop(e.event);
	                var zoomDelta = e.wheelDelta > 0 ? 0.07 : -0.07;
	                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);
	            }, this));
	        }
	    };
	
	    /**
	     * @private
	     */
	    fishTopoProto.zoom = function (zoomDelta, zoomX, zoomY) {
	        if (this.canScale == false) {
	            return;
	        }
	        var target = this.group;
	        if (target) {
	
	            var newZoom = this._zoom = this._zoom || 1;
	            newZoom += zoomDelta;
	
	            newZoom = Number(newZoom.toFixed(2));
	            var zoomScale = newZoom / this._zoom;
	            if (newZoom > this.options.maxScale || newZoom < this.options.minScale) {
	                return;
	            }
	            this._zoom = newZoom;
	
	            this.nowZoom = newZoom;
	
	            this.setScale(zoomX, zoomY, zoomScale);
	        }
	    };
	
	    /**
	     * @private
	     */
	    fishTopoProto.setScale = function (zoomX, zoomY, zoomScale) {
	        var target = this.group;
	        var pos = target.position;
	        var scale = target.scale;
	        // Keep the mouse center when scaling
	        pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);
	        pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);
	        scale[0] *= zoomScale;
	        scale[1] *= zoomScale;
	        target.attr("position", [pos[0], pos[1]]);
	        target.attr("scale", [scale[0], scale[1]]);
	        if (this.eagleEye == true) {
	            this.minimap.updataSelection(pos[0], pos[1], zoomScale, this.nowZoom);
	        }
	    };
	
	    /**
	     * 鹰眼图
	     * @param  {HTMLElement} eagleEyeNode 显示鹰眼图的div元素
	     */
	    fishTopoProto.openEagleEye = function (eagleEyeNode) {
	        this.eagleEye = true;
	        this.eagleEyeNode = eagleEyeNode;
	        var groupPosition = zrUtil.clone(this.group.position);
	        var groupScale = zrUtil.clone(this.group.scale);
	        this.group.attr("position", [0, 0]);
	        this.group.attr("scale", [1, 1]);
	        var distance = this.initScale();
	        var imgSrc = this.toDataURL();
	        this.group.attr("position", groupPosition);
	        this.group.attr("scale", groupScale);
	        if (this.minimap) {
	            this.minimap.updataMap(imgSrc, this.group.getBoundingRect());
	        } else {
	            this.minimap = new Minimap(this, this.group.position, this.group.getBoundingRect(),
	                eagleEyeNode, distance, imgSrc);
	            setTimeout(zrUtil.bind(function () {
	                this.openEagleEye(this.eagleEyeNode)
	            }, this), 10);
	        }
	        this.minimap.selection.addEventListener("mousedown", function (e) {
	            var startX = e.clientX;
	            var startY = e.clientY;
	            var minimapLeft = Number(this.minimap.selection.style.left.substring(0, this.minimap.selection
	                .style.left.length - 2));
	            var minimapTop = Number(this.minimap.selection.style.top.substring(0, this.minimap.selection
	                .style.top.length - 2));
	            var eagleEyeMove = function (e) {
	                var offsetX = e.clientX - startX;
	                var offsetY = e.clientY - startY;
	                this.minimap.selection.style.left = minimapLeft + offsetX + "px";
	                this.minimap.selection.style.top = minimapTop + offsetY + "px";
	                this.minimap.updataGroupPosition(this.group, this.nowZoom);
	            }.bind(this);
	
	            this.minimap.selection.addEventListener("mousemove", eagleEyeMove);
	
	            var eagleEyeUp = function () {
	                this.minimap.selection.removeEventListener("mousemove", eagleEyeMove);
	                this.minimap.selection.removeEventListener("mouseup", eagleEyeUp);
	            }.bind(this);
	            this.minimap.selection.addEventListener("mouseup", eagleEyeUp);
	        }.bind(this))
	    };
	
	    /**
	     * 根据节点位置变化更新组边框的大小
	     * @param {Object} node 节点
	     * @since V2.3.0
	     */
	    fishTopoProto.refreshGroupByNode = function (node) {//#181
	        if (Flow.isInGroup(node)) {
	            //放入node现有数值，用于重绘group
	            var nodeMessage = {
	                width: node.shape.width,
	                height: node.shape.height,
	                position: node.position,
	                isMove: 0,
	                node: node
	            };
	            node.parent.modifyGroupRect(nodeMessage);
	        }
	        this.connectionManager.refreshLineByNode(node);
	        if (Flow.isGroupNode(node)) {
	            node.each(function (childNode) {
	                this.connectionManager.refreshLineByNode(childNode);
	            }.bind(this));
	        }
	    };
	
	    zrUtil.mixin(FishTopoFlow, Eventful);
	
	    // ---------对外暴露fishTopoFlow------------------
	    var idBase = new Date() - 0;
	    var instances = {};
	    var DOM_ATTRIBUTE_KEY = '_fishTopoFlow_instance_';
	
	    /**
	     * fishTopoFlow全局对象，如果是amd方式加载，则直接返回
	     * @class fishTopoFlow
	     * @singleton
	     *
	     * **使用范例**：
	     *
	     *      @example
	     *      var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	     */
	    var fishTopoFlow = {
	        /**
	         * 版本号
	         * @type {String}
	         */
	        version: '3.0.0',
	        dependencies: {
	            zrender: '3.6.3'
	        }
	    };
	
	    /**
	     * 初始化dom元素为 flow对象
	     * @member fishTopoFlow
	     * @param {HTMLElement} dom  一个div元素
	     * @param {Object} opts  传递的选项参数
	     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg' or 'vml'
	     * @param {number} [opts.devicePixelRatio=1] retina 屏幕优化
	     * @param {boolean} [opts.linkModify=false] 是否允许调整线段
	     * @param {boolean} [opts.textEditable=false] 是否允许双击节点编辑文字
	     * @param {boolean} [opts.mouseMode='default'] 设置鼠标在画布上的操作模式，默认为'default'：无任何操作，设为'drag-move'：平移漫游，设为'drag-select'：框选节点
	     * @param {boolean} [opts.roam=true] 是否开启鼠标缩放。默认开启，设为false表示关闭缩放功能。
	     * @param {Object} [opts.tooltip] tooltip配置项
	     * @param {boolean} [opts.tooltip.show] tooltip配置项:控制tooltip是否显示
	     * @param {boolean} [opts.isAnimationEnabled=true] 是否开启动画,默认为true
	     * @param {boolean} [opts.scaleable=false] 是否允许缩放,默认为false
	     * @param {boolean} [opts.rotatable=false] 是否允许旋转,默认为false
	     * @param {Function} [opts.beforeDelete] 删除节点或边线 之前的回调，如果返回false则不进行后续的删除操作
	     * @param {Object} [opts.beforeCreate] 创建节点或边线 之前的回调，如果返回false则不进行后续的删除操作
	     * @return {fish.topo.FishTopoFlow}
	     */
	    fishTopoFlow.init = function (dom, opts) {
	        if (!dom) {
	            throw new Error('Initialize failed: invalid dom.');
	        }
	
	        opts = opts || {};
	        // Default value
	        zrUtil.defaults(opts, {
	            type: "flow",
	            linkModify: false,
	            textEditable: false,
	            roam: true,
	            mouseMode: 'default',
	            tooltip: {
	                show:true
	            },  //覆盖tooltipModel
	            isAnimationEnabled: true,
	            scaleable: false,
	            rotatable: false,
	            beforeDelete: null,  // 删除之前的事件
	            beforeCreate:null,   //创建节点或连线之前的事件
	            maxScale: 1.7,       //画布放大的最大比例
	            minScale: 0.3        //画布缩小的最小比例
	        });
	
	        var fishTopoFlow = new FishTopoFlow(dom, opts);
	        fishTopoFlow.init();
	        fishTopoFlow.Flow = Flow;
	        fishTopoFlow.id = 'ft_' + idBase++;
	        instances[fishTopoFlow.id] = fishTopoFlow;
	
	        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoFlow.id);
	
	        return fishTopoFlow;
	    };
	
	
	    /**
	     * 获取 dom 容器上的实例。
	     * @member fishTopoFlow
	     * @param  {HTMLElement} dom 一个div元素
	     * @return {fish.topo.FishTopoFlow}
	     */
	    fishTopoFlow.getInstanceByDom = function (dom) {
	        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);
	        return instances[key];
	    };
	
	    /**
	     * 销毁实例，实例销毁后无法再被使用。
	     *
	     * @member fishTopoFlow
	     * @param  {Object|string} chart fishTopoBpmn实例 或 fishTopoBpmn的id
	     */
	    fishTopoFlow.dispose = function (chart) {
	        var topo;
	        if (zrUtil.isDom(chart)) {
	            topo = fishTopoFlow.getInstanceByDom(chart);
	        } else if (typeof chart === 'string') {
	            topo = instances[chart];
	        }
	        if ((topo instanceof fishTopoFlow) && !topo.isDisposed()) {
	            topo.dispose();
	        }
	    };
	
	    //暴露出去的类
	    fishTopoFlow.graphic = graphic;
	    fishTopoFlow.node = FlowUtil.registerFlowNode(flowNode);
	    fishTopoFlow.link = flowLink;
	
	    fishTopoFlow.layout = layout;
	    fishTopoFlow.Flow = Flow;
	    fishTopoFlow.constants = Constants;
	    fishTopoFlow.util = util;
	    fishTopoFlow.util['initImagePool'] = ImagePool.initImagePool;
	    zrUtil.each([
	            'map', 'each', 'filter', 'indexOf', 'inherits',
	            'reduce', 'filter', 'bind', 'curry', 'isArray',
	            'isString', 'isObject', 'isFunction', 'extend',
	            'merge', "mergeAll"
	        ],
	        function (name) {
	            fishTopoFlow.util[name] = zrUtil[name];
	        }
	    );
	
	    module.exports = fishTopoFlow;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

	
	    //polyfill bind
	    if (!Function.prototype.bind) {
	        Function.prototype.bind = function(oThis) {
	            if (typeof this !== "function") {
	                // closest thing possible to the ECMAScript 5 internal IsCallable function
	                throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
	            }
	
	            var aArgs = Array.prototype.slice.call(arguments, 1),
	                fToBind = this,
	                fNOP = function() {},
	                fBound = function() {
	                    return fToBind.apply(this instanceof fNOP && oThis ? this : oThis || window,
	                        aArgs.concat(Array.prototype.slice.call(arguments)));
	                };
	
	            fNOP.prototype = this.prototype;
	            fBound.prototype = new fNOP();
	
	            return fBound;
	        };
	    }
	
	    //polyfill remove
	    if (!('remove' in Element.prototype)) {
	        Element.prototype.remove = function() {
	            if (this.parentNode) {
	                this.parentNode.removeChild(this);
	            }
	        };
	    }
	
	    if (!String.prototype.endsWith) {
	    String.prototype.endsWith = function(searchString, position) {
	        var subjectString = this.toString();
	        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
	            position = subjectString.length;
	        }
	        position -= searchString.length;
	        var lastIndex = subjectString.indexOf(searchString, position);
	        return lastIndex !== -1 && lastIndex === position;
	    };
	    }
	


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(5);
	
	    var pathTool = __webpack_require__(6);
	    var round = Math.round;
	    var Path = __webpack_require__(7);
	    var colorTool = __webpack_require__(20);
	    var matrix = __webpack_require__(14);
	    var vector = __webpack_require__(15);
	    var Gradient = __webpack_require__(42);
	    var Draggable = __webpack_require__(43);
	
	    var graphic = {};
	    graphic.Util = zrUtil;
	    graphic.Group = __webpack_require__(44);
	
	    graphic.Image = __webpack_require__(45);
	
	    graphic.Text = __webpack_require__(46);
	
	    graphic.textContain = __webpack_require__(26);
	
	    graphic.Circle = __webpack_require__(47);
	
	    graphic.Sector = __webpack_require__(48);
	
	    graphic.Ring = __webpack_require__(51);
	
	    graphic.Polygon = __webpack_require__(52);
	
	    graphic.Polyline = __webpack_require__(56);
	
	    graphic.Rect = __webpack_require__(57);
	
	    graphic.Line = __webpack_require__(58);
	
	    graphic.BezierCurve = __webpack_require__(59);
	
	    graphic.Arc = __webpack_require__(60);
	
	    graphic.LinearGradient = __webpack_require__(61);
	
	    graphic.RadialGradient = __webpack_require__(62);
	
	    graphic.BoundingRect = __webpack_require__(27);
	    graphic.States = __webpack_require__(63);
	    /**
	     * Extend shape with parameters
	     */
	    graphic.extendShape = function (opts) {
	        return Path.extend(opts);
	    };
	
	    /**
	     * Extend path
	     */
	    graphic.extendPath = function (pathData, opts) {
	        return pathTool.extendFromString(pathData, opts);
	    };
	
	    /**
	     * Create a path element from path data string
	     * @param {string} pathData
	     * @param {Object} opts
	     * @param {module:zrender/core/BoundingRect} rect
	     * @param {string} [layout=cover] 'center' or 'cover'
	     */
	    graphic.makePath = function (pathData, opts, rect, layout) {
	        var path = pathTool.createFromString(pathData, opts);
	        Draggable.call(path);
	        var boundingRect = path.getBoundingRect();
	        if (rect) {
	            var aspect = boundingRect.width / boundingRect.height;
	
	            if (layout === 'center') {
	                // Set rect to center, keep width / height ratio.
	                var width = rect.height * aspect;
	                var height;
	                if (width <= rect.width) {
	                    height = rect.height;
	                }
	                else {
	                    width = rect.width;
	                    height = width / aspect;
	                }
	                var cx = rect.x + rect.width / 2;
	                var cy = rect.y + rect.height / 2;
	
	                rect.x = cx - width / 2;
	                rect.y = cy - height / 2;
	                rect.width = width;
	                rect.height = height;
	            }
	
	            this.resizePath(path, rect);
	        }
	
	        zrUtil.inherits(path, Draggable);
	        return path;
	    };
	
	    graphic.mergePath = pathTool.mergePath;
	
	    /**
	     * Resize a path to fit the rect
	     * @param {module:zrender/graphic/Path} path
	     * @param {Object} rect
	     */
	    graphic.resizePath = function (path, rect) {
	        if (!path.applyTransform) {
	            return;
	        }
	
	        var pathRect = path.getBoundingRect();
	
	        var m = pathRect.calculateTransform(rect);
	
	        path.applyTransform(m);
	    };
	
	    /**
	     * Sub pixel optimize line for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x1]
	     * @param {number} [param.shape.y1]
	     * @param {number} [param.shape.x2]
	     * @param {number} [param.shape.y2]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeLine = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	
	        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {
	            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);
	        }
	        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {
	            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);
	        }
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize rect for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x]
	     * @param {number} [param.shape.y]
	     * @param {number} [param.shape.width]
	     * @param {number} [param.shape.height]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeRect = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	        var originX = shape.x;
	        var originY = shape.y;
	        var originWidth = shape.width;
	        var originHeight = shape.height;
	        shape.x = subPixelOptimize(shape.x, lineWidth, true);
	        shape.y = subPixelOptimize(shape.y, lineWidth, true);
	        shape.width = Math.max(
	            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,
	            originWidth === 0 ? 0 : 1
	        );
	        shape.height = Math.max(
	            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,
	            originHeight === 0 ? 0 : 1
	        );
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize for canvas
	     *
	     * @param {number} position Coordinate, such as x, y
	     * @param {number} lineWidth Should be nonnegative integer.
	     * @param {boolean=} positiveOrNegative Default false (negative).
	     * @return {number} Optimized position.
	     */
	    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {
	        // Assure that (position + lineWidth / 2) is near integer edge,
	        // otherwise line will be fuzzy in canvas.
	        var doubledPosition = round(position * 2);
	        return (doubledPosition + round(lineWidth)) % 2 === 0
	            ? doubledPosition / 2
	            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
	    };
	
	    /**
	     * @private
	     */
	    function doSingleEnterHover(el) {
	        if (el.__isHover) {
	            return;
	        }
	        if (el.__hoverStlDirty) {
	            var stroke = el.style.stroke;
	            var fill = el.style.fill;
	
	            // Create hoverStyle on mouseover
	            var hoverStyle = el.__hoverStl;
	            var lift = colorTool.lift;
	            hoverStyle.fill = hoverStyle.fill
	                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));
	            hoverStyle.stroke = hoverStyle.stroke
	                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));
	
	            var normalStyle = {};
	            for (var name in hoverStyle) {
	                if (hoverStyle.hasOwnProperty(name)) {
	                    normalStyle[name] = el.style[name];
	                }
	            }
	
	            el.__normalStl = normalStyle;
	
	            el.__hoverStlDirty = false;
	        }
	        el.setStyle(el.__hoverStl);
	        el.z2 += 1;
	
	        el.__isHover = true;
	    }
	
	    /**
	     * @inner
	     */
	    function doSingleLeaveHover(el) {
	        if (!el.__isHover) {
	            return;
	        }
	
	        var normalStl = el.__normalStl;
	        normalStl && el.setStyle(normalStl);
	        el.z2 -= 1;
	
	        el.__isHover = false;
	    }
	
	    /**
	     * @inner
	     */
	    function doEnterHover(el) {
	        (el.type === 'group' || el.type === 'GroupNode')
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleEnterHover(child);
	                }
	            })
	            : doSingleEnterHover(el);
	    }
	    graphic.doEnterHover = doEnterHover;
	    function doLeaveHover(el) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleLeaveHover(child);
	                }
	            })
	            : doSingleLeaveHover(el);
	    }
	    graphic.doLeaveHover = doLeaveHover;
	    /**
	     * @inner
	     */
	    function setElementHoverStl(el, hoverStl) {
	        // If element has sepcified hoverStyle, then use it instead of given hoverStyle
	        // Often used when item group has a label element and it's hoverStyle is different
	        el.__hoverStl = el.hoverStyle || hoverStl || {};
	        el.__hoverStlDirty = true;
	    }
	    graphic.setElementHoverStl = setElementHoverStl;
	    /**
	     * @inner
	     */
	    function onElementMouseOver() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function onElementMouseOut() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doLeaveHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function enterEmphasis() {
	        this.__isEmphasis = true;
	        doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function leaveEmphasis() {
	        this.__isEmphasis = false;
	        doLeaveHover(this);
	    }
	
	    /**
	     * Set hover style of element
	     * @param {module:zrender/Element} el
	     * @param {Object} [hoverStyle]
	     */
	    graphic.setHoverStyle = function (el, hoverStyle) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    setElementHoverStl(child, hoverStyle);
	                }
	            })
	            : setElementHoverStl(el, hoverStyle);
	        // Remove previous bound handlers
	        el.on('mouseover', onElementMouseOver)
	          .on('mouseout', onElementMouseOut);
	
	        // Emphasis, normal can be triggered manually
	        el.on('emphasis', enterEmphasis)
	          .on('normal', leaveEmphasis);
	    };
	
	    graphic.setNormalStyle = function(el, options) {
	        if (el.__normalStl) {
	            for (var name in options) {
	                if (el.__normalStl.hasOwnProperty(name)) {
	                    el.__normalStl[name] = options[name];
	                }
	            }
	        }
	    };
	
	    /**
	     * Set text option in the style
	     * @param {Object} textStyle
	     * @param {module:echarts/model/Model} labelModel
	     * @param {string} color
	     */
	    graphic.setText = function (textStyle, labelModel, color) {
	        var labelPosition = labelModel.getShallow('position') || 'inside';
	        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;
	        var textStyleModel = labelModel.getModel('textStyle');
	        zrUtil.extend(textStyle, {
	            textDistance: labelModel.getShallow('distance') || 5,
	            textFont: textStyleModel.getFont(),
	            textPosition: labelPosition,
	            textFill: textStyleModel.getTextColor() || labelColor
	        });
	    };
	
	    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {
	        var postfix = isUpdate ? 'Update' : '';
	        var duration = animatableModel
	            && animatableModel.getShallow('animationDuration' + postfix);
	        var animationEasing = animatableModel
	            && animatableModel.getShallow('animationEasing' + postfix);
	
	        animatableModel && animatableModel.getShallow('animation')
	            ? el.animateTo(props, duration, animationEasing, cb)
	            : (el.attr(props), cb && cb());
	    }
	    /**
	     * Update graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
	    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);
	
	    /**
	     * Init graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
	    graphic.initProps = zrUtil.curry(animateOrSetProps, false);
	
	    /**
	     * Get transform matrix of target (param target),
	     * in coordinate of its ancestor (param ancestor)
	     *
	     * @param {module:zrender/mixin/Transformable} target
	     * @param {module:zrender/mixin/Transformable} ancestor
	     */
	    graphic.getTransform = function (target, ancestor) {
	        var mat = matrix.identity([]);
	
	        while (target && target !== ancestor) {
	            matrix.mul(mat, target.getLocalTransform(), mat);
	            target = target.parent;
	        }
	
	        return mat;
	    };
	
	    /**
	     * Apply transform to an vertex.
	     * @param {Array.<number>} vertex [x, y]
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {Array.<number>} [x, y]
	     */
	    graphic.applyTransform = function (vertex, transform, invert) {
	        if (invert) {
	            transform = matrix.invert([], transform);
	        }
	        return vector.applyTransform([], vertex, transform);
	    };
	
	    /**
	     * @param {string} direction 'left' 'right' 'top' 'bottom'
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'
	     */
	    graphic.transformDirection = function (direction, transform, invert) {
	
	        // Pick a base, ensure that transform result will not be (0, 0).
	        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[0]);
	        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[2]);
	
	        var vertex = [
	            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,
	            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0
	        ];
	
	        vertex = graphic.applyTransform(vertex, transform, invert);
	
	        return Math.abs(vertex[0]) > Math.abs(vertex[1])
	            ? (vertex[0] > 0 ? 'right' : 'left')
	            : (vertex[1] > 0 ? 'bottom' : 'top');
	    };
	
	    module.exports = graphic;
	


/***/ }),
/* 5 */
/***/ (function(module, exports) {

	/**
	 * @module zrender/core/util
	 */
	// 用于处理merge时无法遍历Date等对象的问题
	var BUILTIN_OBJECT = {
	  '[object Function]': 1,
	  '[object RegExp]': 1,
	  '[object Date]': 1,
	  '[object Error]': 1,
	  '[object CanvasGradient]': 1,
	  '[object CanvasPattern]': 1,
	  // For node-canvas
	  '[object Image]': 1,
	  '[object Canvas]': 1
	};
	var TYPED_ARRAY = {
	  '[object Int8Array]': 1,
	  '[object Uint8Array]': 1,
	  '[object Uint8ClampedArray]': 1,
	  '[object Int16Array]': 1,
	  '[object Uint16Array]': 1,
	  '[object Int32Array]': 1,
	  '[object Uint32Array]': 1,
	  '[object Float32Array]': 1,
	  '[object Float64Array]': 1
	};
	var objToString = Object.prototype.toString;
	var arrayProto = Array.prototype;
	var nativeForEach = arrayProto.forEach;
	var nativeFilter = arrayProto.filter;
	var nativeSlice = arrayProto.slice;
	var nativeMap = arrayProto.map;
	var nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.
	
	var methods = {};
	
	function $override(name, fn) {
	  methods[name] = fn;
	}
	/**
	 * Those data types can be cloned:
	 *     Plain object, Array, TypedArray, number, string, null, undefined.
	 * Those data types will be assgined using the orginal data:
	 *     BUILTIN_OBJECT
	 * Instance of user defined class will be cloned to a plain object, without
	 * properties in prototype.
	 * Other data types is not supported (not sure what will happen).
	 *
	 * Caution: do not support clone Date, for performance consideration.
	 * (There might be a large number of date in `series.data`).
	 * So date should not be modified in and out of echarts.
	 *
	 * @param {*} source
	 * @return {*} new
	 */
	
	
	function clone(source) {
	  if (source == null || typeof source != 'object') {
	    return source;
	  }
	
	  var result = source;
	  var typeStr = objToString.call(source);
	
	  if (typeStr === '[object Array]') {
	    result = [];
	
	    for (var i = 0, len = source.length; i < len; i++) {
	      result[i] = clone(source[i]);
	    }
	  } else if (TYPED_ARRAY[typeStr]) {
	    var Ctor = source.constructor;
	
	    if (source.constructor.from) {
	      result = Ctor.from(source);
	    } else {
	      result = new Ctor(source.length);
	
	      for (var i = 0, len = source.length; i < len; i++) {
	        result[i] = clone(source[i]);
	      }
	    }
	  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
	    result = {};
	
	    for (var key in source) {
	      if (source.hasOwnProperty(key)) {
	        result[key] = clone(source[key]);
	      }
	    }
	  }
	
	  return result;
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} target
	 * @param {*} source
	 * @param {boolean} [overwrite=false]
	 */
	
	
	function merge(target, source, overwrite) {
	  // We should escapse that source is string
	  // and enter for ... in ...
	  if (!isObject(source) || !isObject(target)) {
	    return overwrite ? clone(source) : target;
	  }
	
	  for (var key in source) {
	    if (source.hasOwnProperty(key)) {
	      var targetProp = target[key];
	      var sourceProp = source[key];
	
	      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
	        // 如果需要递归覆盖，就递归调用merge
	        merge(targetProp, sourceProp, overwrite);
	      } else if (overwrite || !(key in target)) {
	        // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
	        // NOTE，在 target[key] 不存在的时候也是直接覆盖
	        target[key] = clone(source[key], true);
	      }
	    }
	  }
	
	  return target;
	}
	/**
	 * @param {Array} targetAndSources The first item is target, and the rests are source.
	 * @param {boolean} [overwrite=false]
	 * @return {*} target
	 */
	
	
	function mergeAll(targetAndSources, overwrite) {
	  var result = targetAndSources[0];
	
	  for (var i = 1, len = targetAndSources.length; i < len; i++) {
	    result = merge(result, targetAndSources[i], overwrite);
	  }
	
	  return result;
	}
	/**
	 * @param {*} target
	 * @param {*} source
	 * @memberOf module:zrender/core/util
	 */
	
	
	function extend(target, source) {
	  for (var key in source) {
	    if (source.hasOwnProperty(key)) {
	      target[key] = source[key];
	    }
	  }
	
	  return target;
	}
	/**
	 * @param {*} target
	 * @param {*} source
	 * @param {boolean} [overlay=false]
	 * @memberOf module:zrender/core/util
	 */
	
	
	function defaults(target, source, overlay) {
	  for (var key in source) {
	    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {
	      target[key] = source[key];
	    }
	  }
	
	  return target;
	}
	
	var createCanvas = function () {
	  return methods.createCanvas();
	};
	
	methods.createCanvas = function () {
	  return document.createElement('canvas');
	}; // FIXME
	
	
	var _ctx;
	
	function getContext() {
	  if (!_ctx) {
	    // Use util.createCanvas instead of createCanvas
	    // because createCanvas may be overwritten in different environment
	    _ctx = createCanvas().getContext('2d');
	  }
	
	  return _ctx;
	}
	/**
	 * 查询数组中元素的index
	 * @memberOf module:zrender/core/util
	 */
	
	
	function indexOf(array, value) {
	  if (array) {
	    if (array.indexOf) {
	      return array.indexOf(value);
	    }
	
	    for (var i = 0, len = array.length; i < len; i++) {
	      if (array[i] === value) {
	        return i;
	      }
	    }
	  }
	
	  return -1;
	}
	/**
	 * 构造类继承关系
	 *
	 * @memberOf module:zrender/core/util
	 * @param {Function} clazz 源类
	 * @param {Function} baseClazz 基类
	 */
	
	
	function inherits(clazz, baseClazz) {
	  var clazzPrototype = clazz.prototype;
	
	  function F() {}
	
	  F.prototype = baseClazz.prototype;
	  clazz.prototype = new F();
	
	  for (var prop in clazzPrototype) {
	    clazz.prototype[prop] = clazzPrototype[prop];
	  }
	
	  clazz.prototype.constructor = clazz;
	  clazz.superClass = baseClazz;
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Object|Function} target
	 * @param {Object|Function} sorce
	 * @param {boolean} overlay
	 */
	
	
	function mixin(target, source, overlay) {
	  target = 'prototype' in target ? target.prototype : target;
	  source = 'prototype' in source ? source.prototype : source;
	  defaults(target, source, overlay);
	}
	/**
	 * Consider typed array.
	 * @param {Array|TypedArray} data
	 */
	
	
	function isArrayLike(data) {
	  if (!data) {
	    return;
	  }
	
	  if (typeof data == 'string') {
	    return false;
	  }
	
	  return typeof data.length == 'number';
	}
	/**
	 * 数组或对象遍历
	 * @memberOf module:zrender/core/util
	 * @param {Object|Array} obj
	 * @param {Function} cb
	 * @param {*} [context]
	 */
	
	
	function each(obj, cb, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  if (obj.forEach && obj.forEach === nativeForEach) {
	    obj.forEach(cb, context);
	  } else if (obj.length === +obj.length) {
	    for (var i = 0, len = obj.length; i < len; i++) {
	      cb.call(context, obj[i], i, obj);
	    }
	  } else {
	    for (var key in obj) {
	      if (obj.hasOwnProperty(key)) {
	        cb.call(context, obj[key], key, obj);
	      }
	    }
	  }
	}
	/**
	 * 数组映射
	 * @memberOf module:zrender/core/util
	 * @param {Array} obj
	 * @param {Function} cb
	 * @param {*} [context]
	 * @return {Array}
	 */
	
	
	function map(obj, cb, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  if (obj.map && obj.map === nativeMap) {
	    return obj.map(cb, context);
	  } else {
	    var result = [];
	
	    for (var i = 0, len = obj.length; i < len; i++) {
	      result.push(cb.call(context, obj[i], i, obj));
	    }
	
	    return result;
	  }
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Array} obj
	 * @param {Function} cb
	 * @param {Object} [memo]
	 * @param {*} [context]
	 * @return {Array}
	 */
	
	
	function reduce(obj, cb, memo, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  if (obj.reduce && obj.reduce === nativeReduce) {
	    return obj.reduce(cb, memo, context);
	  } else {
	    for (var i = 0, len = obj.length; i < len; i++) {
	      memo = cb.call(context, memo, obj[i], i, obj);
	    }
	
	    return memo;
	  }
	}
	/**
	 * 数组过滤
	 * @memberOf module:zrender/core/util
	 * @param {Array} obj
	 * @param {Function} cb
	 * @param {*} [context]
	 * @return {Array}
	 */
	
	
	function filter(obj, cb, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  if (obj.filter && obj.filter === nativeFilter) {
	    return obj.filter(cb, context);
	  } else {
	    var result = [];
	
	    for (var i = 0, len = obj.length; i < len; i++) {
	      if (cb.call(context, obj[i], i, obj)) {
	        result.push(obj[i]);
	      }
	    }
	
	    return result;
	  }
	}
	/**
	 * 数组项查找
	 * @memberOf module:zrender/core/util
	 * @param {Array} obj
	 * @param {Function} cb
	 * @param {*} [context]
	 * @return {*}
	 */
	
	
	function find(obj, cb, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  for (var i = 0, len = obj.length; i < len; i++) {
	    if (cb.call(context, obj[i], i, obj)) {
	      return obj[i];
	    }
	  }
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Function} func
	 * @param {*} context
	 * @return {Function}
	 */
	
	
	function bind(func, context) {
	  var args = nativeSlice.call(arguments, 2);
	  return function () {
	    return func.apply(context, args.concat(nativeSlice.call(arguments)));
	  };
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Function} func
	 * @return {Function}
	 */
	
	
	function curry(func) {
	  var args = nativeSlice.call(arguments, 1);
	  return function () {
	    return func.apply(this, args.concat(nativeSlice.call(arguments)));
	  };
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isArray(value) {
	  return objToString.call(value) === '[object Array]';
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isFunction(value) {
	  return typeof value === 'function';
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isString(value) {
	  return objToString.call(value) === '[object String]';
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return type === 'function' || !!value && type == 'object';
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isBuiltInObject(value) {
	  return !!BUILTIN_OBJECT[objToString.call(value)];
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isDom(value) {
	  return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';
	}
	/**
	 * Whether is exactly NaN. Notice isNaN('a') returns true.
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function eqNaN(value) {
	  return value !== value;
	}
	/**
	 * If value1 is not null, then return value1, otherwise judget rest of values.
	 * Low performance.
	 * @memberOf module:zrender/core/util
	 * @return {*} Final value
	 */
	
	
	function retrieve(values) {
	  for (var i = 0, len = arguments.length; i < len; i++) {
	    if (arguments[i] != null) {
	      return arguments[i];
	    }
	  }
	}
	
	function retrieve2(value0, value1) {
	  return value0 != null ? value0 : value1;
	}
	
	function retrieve3(value0, value1, value2) {
	  return value0 != null ? value0 : value1 != null ? value1 : value2;
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Array} arr
	 * @param {number} startIndex
	 * @param {number} endIndex
	 * @return {Array}
	 */
	
	
	function slice() {
	  return Function.call.apply(nativeSlice, arguments);
	}
	/**
	 * Normalize css liked array configuration
	 * e.g.
	 *  3 => [3, 3, 3, 3]
	 *  [4, 2] => [4, 2, 4, 2]
	 *  [4, 3, 2] => [4, 3, 2, 3]
	 * @param {number|Array.<number>} val
	 * @return {Array.<number>}
	 */
	
	
	function normalizeCssArray(val) {
	  if (typeof val === 'number') {
	    return [val, val, val, val];
	  }
	
	  var len = val.length;
	
	  if (len === 2) {
	    // vertical | horizontal
	    return [val[0], val[1], val[0], val[1]];
	  } else if (len === 3) {
	    // top | horizontal | bottom
	    return [val[0], val[1], val[2], val[1]];
	  }
	
	  return val;
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {boolean} condition
	 * @param {string} message
	 */
	
	
	function assert(condition, message) {
	  if (!condition) {
	    throw new Error(message);
	  }
	}
	
	var primitiveKey = '__ec_primitive__';
	/**
	 * Set an object as primitive to be ignored traversing children in clone or merge
	 */
	
	function setAsPrimitive(obj) {
	  obj[primitiveKey] = true;
	}
	
	function isPrimitive(obj) {
	  return obj[primitiveKey];
	}
	/**
	 * @constructor
	 * @param {Object} obj Only apply `ownProperty`.
	 */
	
	
	function HashMap(obj) {
	  obj && each(obj, function (value, key) {
	    this.set(key, value);
	  }, this);
	} // Add prefix to avoid conflict with Object.prototype.
	
	
	var HASH_MAP_PREFIX = '_ec_';
	var HASH_MAP_PREFIX_LENGTH = 4;
	HashMap.prototype = {
	  constructor: HashMap,
	  // Do not provide `has` method to avoid defining what is `has`.
	  // (We usually treat `null` and `undefined` as the same, different
	  // from ES6 Map).
	  get: function (key) {
	    return this[HASH_MAP_PREFIX + key];
	  },
	  set: function (key, value) {
	    this[HASH_MAP_PREFIX + key] = value; // Comparing with invocation chaining, `return value` is more commonly
	    // used in this case: `var someVal = map.set('a', genVal());`
	
	    return value;
	  },
	  // Although util.each can be performed on this hashMap directly, user
	  // should not use the exposed keys, who are prefixed.
	  each: function (cb, context) {
	    context !== void 0 && (cb = bind(cb, context));
	
	    for (var prefixedKey in this) {
	      this.hasOwnProperty(prefixedKey) && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));
	    }
	  },
	  // Do not use this method if performance sensitive.
	  removeKey: function (key) {
	    delete this[HASH_MAP_PREFIX + key];
	  }
	};
	
	function createHashMap(obj) {
	  return new HashMap(obj);
	}
	
	function noop() {}
	
	exports.$override = $override;
	exports.clone = clone;
	exports.merge = merge;
	exports.mergeAll = mergeAll;
	exports.extend = extend;
	exports.defaults = defaults;
	exports.createCanvas = createCanvas;
	exports.getContext = getContext;
	exports.indexOf = indexOf;
	exports.inherits = inherits;
	exports.mixin = mixin;
	exports.isArrayLike = isArrayLike;
	exports.each = each;
	exports.map = map;
	exports.reduce = reduce;
	exports.filter = filter;
	exports.find = find;
	exports.bind = bind;
	exports.curry = curry;
	exports.isArray = isArray;
	exports.isFunction = isFunction;
	exports.isString = isString;
	exports.isObject = isObject;
	exports.isBuiltInObject = isBuiltInObject;
	exports.isDom = isDom;
	exports.eqNaN = eqNaN;
	exports.retrieve = retrieve;
	exports.retrieve2 = retrieve2;
	exports.retrieve3 = retrieve3;
	exports.slice = slice;
	exports.normalizeCssArray = normalizeCssArray;
	exports.assert = assert;
	exports.setAsPrimitive = setAsPrimitive;
	exports.isPrimitive = isPrimitive;
	exports.createHashMap = createHashMap;
	exports.noop = noop;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(7);
	
	var PathProxy = __webpack_require__(30);
	
	var transformPath = __webpack_require__(41);
	
	// command chars
	var cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];
	var mathSqrt = Math.sqrt;
	var mathSin = Math.sin;
	var mathCos = Math.cos;
	var PI = Math.PI;
	
	var vMag = function (v) {
	  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
	};
	
	var vRatio = function (u, v) {
	  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
	};
	
	var vAngle = function (u, v) {
	  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
	};
	
	function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
	  var psi = psiDeg * (PI / 180.0);
	  var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;
	  var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;
	  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
	
	  if (lambda > 1) {
	    rx *= mathSqrt(lambda);
	    ry *= mathSqrt(lambda);
	  }
	
	  var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
	  var cxp = f * rx * yp / ry;
	  var cyp = f * -ry * xp / rx;
	  var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;
	  var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;
	  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
	  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
	  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
	  var dTheta = vAngle(u, v);
	
	  if (vRatio(u, v) <= -1) {
	    dTheta = PI;
	  }
	
	  if (vRatio(u, v) >= 1) {
	    dTheta = 0;
	  }
	
	  if (fs === 0 && dTheta > 0) {
	    dTheta = dTheta - 2 * PI;
	  }
	
	  if (fs === 1 && dTheta < 0) {
	    dTheta = dTheta + 2 * PI;
	  }
	
	  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
	}
	
	function createPathProxyFromString(data) {
	  if (!data) {
	    return [];
	  } // command string
	
	
	  var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');
	  var n; // create pipes so that we can split the data
	
	  for (n = 0; n < cc.length; n++) {
	    cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
	  } // create array
	
	
	  var arr = cs.split('|'); // init context point
	
	  var cpx = 0;
	  var cpy = 0;
	  var path = new PathProxy();
	  var CMD = PathProxy.CMD;
	  var prevCmd;
	
	  for (n = 1; n < arr.length; n++) {
	    var str = arr[n];
	    var c = str.charAt(0);
	    var off = 0;
	    var p = str.slice(1).replace(/e,-/g, 'e-').split(',');
	    var cmd;
	
	    if (p.length > 0 && p[0] === '') {
	      p.shift();
	    }
	
	    for (var i = 0; i < p.length; i++) {
	      p[i] = parseFloat(p[i]);
	    }
	
	    while (off < p.length && !isNaN(p[off])) {
	      if (isNaN(p[0])) {
	        break;
	      }
	
	      var ctlPtx;
	      var ctlPty;
	      var rx;
	      var ry;
	      var psi;
	      var fa;
	      var fs;
	      var x1 = cpx;
	      var y1 = cpy; // convert l, H, h, V, and v to L
	
	      switch (c) {
	        case 'l':
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'L':
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'm':
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.M;
	          path.addData(cmd, cpx, cpy);
	          c = 'l';
	          break;
	
	        case 'M':
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.M;
	          path.addData(cmd, cpx, cpy);
	          c = 'L';
	          break;
	
	        case 'h':
	          cpx += p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'H':
	          cpx = p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'v':
	          cpy += p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'V':
	          cpy = p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'C':
	          cmd = CMD.C;
	          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
	          cpx = p[off - 2];
	          cpy = p[off - 1];
	          break;
	
	        case 'c':
	          cmd = CMD.C;
	          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
	          cpx += p[off - 2];
	          cpy += p[off - 1];
	          break;
	
	        case 'S':
	          ctlPtx = cpx;
	          ctlPty = cpy;
	          var len = path.len();
	          var pathData = path.data;
	
	          if (prevCmd === CMD.C) {
	            ctlPtx += cpx - pathData[len - 4];
	            ctlPty += cpy - pathData[len - 3];
	          }
	
	          cmd = CMD.C;
	          x1 = p[off++];
	          y1 = p[off++];
	          cpx = p[off++];
	          cpy = p[off++];
	          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	          break;
	
	        case 's':
	          ctlPtx = cpx;
	          ctlPty = cpy;
	          var len = path.len();
	          var pathData = path.data;
	
	          if (prevCmd === CMD.C) {
	            ctlPtx += cpx - pathData[len - 4];
	            ctlPty += cpy - pathData[len - 3];
	          }
	
	          cmd = CMD.C;
	          x1 = cpx + p[off++];
	          y1 = cpy + p[off++];
	          cpx += p[off++];
	          cpy += p[off++];
	          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	          break;
	
	        case 'Q':
	          x1 = p[off++];
	          y1 = p[off++];
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.Q;
	          path.addData(cmd, x1, y1, cpx, cpy);
	          break;
	
	        case 'q':
	          x1 = p[off++] + cpx;
	          y1 = p[off++] + cpy;
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.Q;
	          path.addData(cmd, x1, y1, cpx, cpy);
	          break;
	
	        case 'T':
	          ctlPtx = cpx;
	          ctlPty = cpy;
	          var len = path.len();
	          var pathData = path.data;
	
	          if (prevCmd === CMD.Q) {
	            ctlPtx += cpx - pathData[len - 4];
	            ctlPty += cpy - pathData[len - 3];
	          }
	
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.Q;
	          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	          break;
	
	        case 't':
	          ctlPtx = cpx;
	          ctlPty = cpy;
	          var len = path.len();
	          var pathData = path.data;
	
	          if (prevCmd === CMD.Q) {
	            ctlPtx += cpx - pathData[len - 4];
	            ctlPty += cpy - pathData[len - 3];
	          }
	
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.Q;
	          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	          break;
	
	        case 'A':
	          rx = p[off++];
	          ry = p[off++];
	          psi = p[off++];
	          fa = p[off++];
	          fs = p[off++];
	          x1 = cpx, y1 = cpy;
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.A;
	          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
	          break;
	
	        case 'a':
	          rx = p[off++];
	          ry = p[off++];
	          psi = p[off++];
	          fa = p[off++];
	          fs = p[off++];
	          x1 = cpx, y1 = cpy;
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.A;
	          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
	          break;
	      }
	    }
	
	    if (c === 'z' || c === 'Z') {
	      cmd = CMD.Z;
	      path.addData(cmd);
	    }
	
	    prevCmd = cmd;
	  }
	
	  path.toStatic();
	  return path;
	} // TODO Optimize double memory cost problem
	
	
	function createPathOptions(str, opts) {
	  var pathProxy = createPathProxyFromString(str);
	  opts = opts || {};
	
	  opts.buildPath = function (path) {
	    if (path.setData) {
	      path.setData(pathProxy.data); // Svg and vml renderer don't have context
	
	      var ctx = path.getContext();
	
	      if (ctx) {
	        path.rebuildPath(ctx);
	      }
	    } else {
	      var ctx = path;
	      pathProxy.rebuildPath(ctx);
	    }
	  };
	
	  opts.applyTransform = function (m) {
	    transformPath(pathProxy, m);
	    this.dirty(true);
	  };
	
	  return opts;
	}
	/**
	 * Create a Path object from path string data
	 * http://www.w3.org/TR/SVG/paths.html#PathData
	 * @param  {Object} opts Other options
	 */
	
	
	function createFromString(str, opts) {
	  return new Path(createPathOptions(str, opts));
	}
	/**
	 * Create a Path class from path string data
	 * @param  {string} str
	 * @param  {Object} opts Other options
	 */
	
	
	function extendFromString(str, opts) {
	  return Path.extend(createPathOptions(str, opts));
	}
	/**
	 * Merge multiple paths
	 */
	// TODO Apply transform
	// TODO stroke dash
	// TODO Optimize double memory cost problem
	
	
	function mergePath(pathEls, opts) {
	  var pathList = [];
	  var len = pathEls.length;
	
	  for (var i = 0; i < len; i++) {
	    var pathEl = pathEls[i];
	
	    if (!pathEl.path) {
	      pathEl.createPathProxy();
	    }
	
	    if (pathEl.__dirtyPath) {
	      pathEl.buildPath(pathEl.path, pathEl.shape, true);
	    }
	
	    pathList.push(pathEl.path);
	  }
	
	  var pathBundle = new Path(opts); // Need path proxy.
	
	  pathBundle.createPathProxy();
	
	  pathBundle.buildPath = function (path) {
	    path.appendPath(pathList); // Svg and vml renderer don't have context
	
	    var ctx = path.getContext();
	
	    if (ctx) {
	      path.rebuildPath(ctx);
	    }
	  };
	
	  return pathBundle;
	}
	
	exports.createFromString = createFromString;
	exports.extendFromString = extendFromString;
	exports.mergePath = mergePath;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	var Displayable = __webpack_require__(8);
	
	var zrUtil = __webpack_require__(5);
	
	var PathProxy = __webpack_require__(30);
	
	var pathContain = __webpack_require__(33);
	
	var Pattern = __webpack_require__(40);
	
	var getCanvasPattern = Pattern.prototype.getCanvasPattern;
	var abs = Math.abs;
	var pathProxyForDraw = new PathProxy(true);
	/**
	 * @alias module:zrender/graphic/Path
	 * @extends module:zrender/graphic/Displayable
	 * @constructor
	 * @param {Object} opts
	 */
	
	function Path(opts) {
	  Displayable.call(this, opts);
	  /**
	   * @type {module:zrender/core/PathProxy}
	   * @readOnly
	   */
	
	  this.path = null;
	}
	
	Path.prototype = {
	  constructor: Path,
	  type: 'path',
	  __dirtyPath: true,
	  strokeContainThreshold: 5,
	  brush: function (ctx, prevEl) {
	    var style = this.style;
	    var path = this.path || pathProxyForDraw;
	    var hasStroke = style.hasStroke();
	    var hasFill = style.hasFill();
	    var fill = style.fill;
	    var stroke = style.stroke;
	    var hasFillGradient = hasFill && !!fill.colorStops;
	    var hasStrokeGradient = hasStroke && !!stroke.colorStops;
	    var hasFillPattern = hasFill && !!fill.image;
	    var hasStrokePattern = hasStroke && !!stroke.image;
	    style.bind(ctx, this, prevEl);
	    this.setTransform(ctx);
	
	    if (this.__dirty) {
	      var rect; // Update gradient because bounding rect may changed
	
	      if (hasFillGradient) {
	        rect = rect || this.getBoundingRect();
	        this._fillGradient = style.getGradient(ctx, fill, rect);
	      }
	
	      if (hasStrokeGradient) {
	        rect = rect || this.getBoundingRect();
	        this._strokeGradient = style.getGradient(ctx, stroke, rect);
	      }
	    } // Use the gradient or pattern
	
	
	    if (hasFillGradient) {
	      // PENDING If may have affect the state
	      ctx.fillStyle = this._fillGradient;
	    } else if (hasFillPattern) {
	      ctx.fillStyle = getCanvasPattern.call(fill, ctx);
	    }
	
	    if (hasStrokeGradient) {
	      ctx.strokeStyle = this._strokeGradient;
	    } else if (hasStrokePattern) {
	      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
	    }
	
	    var lineDash = style.lineDash;
	    var lineDashOffset = style.lineDashOffset;
	    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy
	
	    var scale = this.getGlobalScale();
	    path.setScale(scale[0], scale[1]); // Proxy context
	    // Rebuild path in following 2 cases
	    // 1. Path is dirty
	    // 2. Path needs javascript implemented lineDash stroking.
	    //    In this case, lineDash information will not be saved in PathProxy
	
	    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {
	      path.beginPath(ctx); // Setting line dash before build path
	
	      if (lineDash && !ctxLineDash) {
	        path.setLineDash(lineDash);
	        path.setLineDashOffset(lineDashOffset);
	      }
	
	      this.buildPath(path, this.shape, false); // Clear path dirty flag
	
	      if (this.path) {
	        this.__dirtyPath = false;
	      }
	    } else {
	      // Replay path building
	      ctx.beginPath();
	      this.path.rebuildPath(ctx);
	    }
	
	    hasFill && path.fill(ctx);
	
	    if (lineDash && ctxLineDash) {
	      ctx.setLineDash(lineDash);
	      ctx.lineDashOffset = lineDashOffset;
	    }
	
	    hasStroke && path.stroke(ctx);
	
	    if (lineDash && ctxLineDash) {
	      // PENDING
	      // Remove lineDash
	      ctx.setLineDash([]);
	    }
	
	    this.restoreTransform(ctx); // Draw rect text
	
	    if (style.text != null) {
	      this.drawRectText(ctx, this.getBoundingRect());
	    }
	  },
	  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
	  // Like in circle
	  buildPath: function (ctx, shapeCfg, inBundle) {},
	  createPathProxy: function () {
	    this.path = new PathProxy();
	  },
	  getBoundingRect: function () {
	    var rect = this._rect;
	    var style = this.style;
	    var needsUpdateRect = !rect;
	
	    if (needsUpdateRect) {
	      var path = this.path;
	
	      if (!path) {
	        // Create path on demand.
	        path = this.path = new PathProxy();
	      }
	
	      if (this.__dirtyPath) {
	        path.beginPath();
	        this.buildPath(path, this.shape, false);
	      }
	
	      rect = path.getBoundingRect();
	    }
	
	    this._rect = rect;
	
	    if (style.hasStroke()) {
	      // Needs update rect with stroke lineWidth when
	      // 1. Element changes scale or lineWidth
	      // 2. Shape is changed
	      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());
	
	      if (this.__dirty || needsUpdateRect) {
	        rectWithStroke.copy(rect); // FIXME Must after updateTransform
	
	        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical
	
	        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill
	
	        if (!style.hasFill()) {
	          w = Math.max(w, this.strokeContainThreshold || 4);
	        } // Consider line width
	        // Line scale can't be 0;
	
	
	        if (lineScale > 1e-10) {
	          rectWithStroke.width += w / lineScale;
	          rectWithStroke.height += w / lineScale;
	          rectWithStroke.x -= w / lineScale / 2;
	          rectWithStroke.y -= w / lineScale / 2;
	        }
	      } // Return rect with stroke
	
	
	      return rectWithStroke;
	    }
	
	    return rect;
	  },
	  contain: function (x, y) {
	    var localPos = this.transformCoordToLocal(x, y);
	    var rect = this.getBoundingRect();
	    var style = this.style;
	    x = localPos[0];
	    y = localPos[1];
	
	    if (rect.contain(x, y)) {
	      var pathData = this.path.data;
	
	      if (style.hasStroke()) {
	        var lineWidth = style.lineWidth;
	        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;
	
	        if (lineScale > 1e-10) {
	          // Only add extra hover lineWidth when there are no fill
	          if (!style.hasFill()) {
	            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
	          }
	
	          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {
	            return true;
	          }
	        }
	      }
	
	      if (style.hasFill()) {
	        return pathContain.contain(pathData, x, y);
	      }
	    }
	
	    return false;
	  },
	
	  /**
	   * @param  {boolean} dirtyPath
	   */
	  dirty: function (dirtyPath) {
	    if (dirtyPath == null) {
	      dirtyPath = true;
	    } // Only mark dirty, not mark clean
	
	
	    if (dirtyPath) {
	      this.__dirtyPath = dirtyPath;
	      this._rect = null;
	    }
	
	    this.__dirty = true;
	    this.__zr && this.__zr.refresh(); // Used as a clipping path
	
	    if (this.__clipTarget) {
	      this.__clipTarget.dirty();
	    }
	  },
	
	  /**
	   * Alias for animate('shape')
	   * @param {boolean} loop
	   */
	  animateShape: function (loop) {
	    return this.animate('shape', loop);
	  },
	  // Overwrite attrKV
	  attrKV: function (key, value) {
	    // FIXME
	    if (key === 'shape') {
	      this.setShape(value);
	      this.__dirtyPath = true;
	      this._rect = null;
	    } else {
	      Displayable.prototype.attrKV.call(this, key, value);
	    }
	  },
	
	  /**
	   * @param {Object|string} key
	   * @param {*} value
	   */
	  setShape: function (key, value) {
	    var shape = this.shape; // Path from string may not have shape
	
	    if (shape) {
	      if (zrUtil.isObject(key)) {
	        for (var name in key) {
	          if (key.hasOwnProperty(name)) {
	            shape[name] = key[name];
	          }
	        }
	      } else {
	        shape[key] = value;
	      }
	
	      this.dirty(true);
	    }
	
	    return this;
	  },
	  getLineScale: function () {
	    var m = this.transform; // Get the line scale.
	    // Determinant of `m` means how much the area is enlarged by the
	    // transformation. So its square root can be used as a scale factor
	    // for width.
	
	    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;
	  }
	};
	/**
	 * 扩展一个 Path element, 比如星形，圆等。
	 * Extend a path element
	 * @param {Object} props
	 * @param {string} props.type Path type
	 * @param {Function} props.init Initialize
	 * @param {Function} props.buildPath Overwrite buildPath method
	 * @param {Object} [props.style] Extended default style config
	 * @param {Object} [props.shape] Extended default shape config
	 */
	
	Path.extend = function (defaults) {
	  var Sub = function (opts) {
	    Path.call(this, opts);
	
	    if (defaults.style) {
	      // Extend default style
	      this.style.extendFrom(defaults.style, false);
	    } // Extend default shape
	
	
	    var defaultShape = defaults.shape;
	
	    if (defaultShape) {
	      this.shape = this.shape || {};
	      var thisShape = this.shape;
	
	      for (var name in defaultShape) {
	        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {
	          thisShape[name] = defaultShape[name];
	        }
	      }
	    }
	
	    defaults.init && defaults.init.call(this, opts);
	  };
	
	  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象
	
	  for (var name in defaults) {
	    // Extending prototype values and methods
	    if (name !== 'style' && name !== 'shape') {
	      Sub.prototype[name] = defaults[name];
	    }
	  }
	
	  return Sub;
	};
	
	zrUtil.inherits(Path, Displayable);
	var _default = Path;
	module.exports = _default;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(5);
	
	var Style = __webpack_require__(9);
	
	var Element = __webpack_require__(10);
	
	var RectText = __webpack_require__(24);
	
	/**
	 * 可绘制的图形基类
	 * Base class of all displayable graphic objects
	 * @module zrender/graphic/Displayable
	 */
	
	/**
	 * @alias module:zrender/graphic/Displayable
	 * @extends module:zrender/Element
	 * @extends module:zrender/graphic/mixin/RectText
	 */
	function Displayable(opts) {
	  opts = opts || {};
	  Element.call(this, opts); // Extend properties
	
	  for (var name in opts) {
	    if (opts.hasOwnProperty(name) && name !== 'style') {
	      this[name] = opts[name];
	    }
	  }
	  /**
	   * @type {module:zrender/graphic/Style}
	   */
	
	
	  this.style = new Style(opts.style, this);
	  this._rect = null; // Shapes for cascade clipping.
	
	  this.__clipPaths = []; // FIXME Stateful must be mixined after style is setted
	  // Stateful.call(this, opts);
	}
	
	Displayable.prototype = {
	  constructor: Displayable,
	  type: 'displayable',
	
	  /**
	   * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制
	   * Dirty flag. From which painter will determine if this displayable object needs brush
	   * @name module:zrender/graphic/Displayable#__dirty
	   * @type {boolean}
	   */
	  __dirty: true,
	
	  /**
	   * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件
	   * If ignore drawing of the displayable object. Mouse event will still be triggered
	   * @name module:/zrender/graphic/Displayable#invisible
	   * @type {boolean}
	   * @default false
	   */
	  invisible: false,
	
	  /**
	   * @name module:/zrender/graphic/Displayable#z
	   * @type {number}
	   * @default 0
	   */
	  z: 0,
	
	  /**
	   * @name module:/zrender/graphic/Displayable#z
	   * @type {number}
	   * @default 0
	   */
	  z2: 0,
	
	  /**
	   * z层level，决定绘画在哪层canvas中
	   * @name module:/zrender/graphic/Displayable#zlevel
	   * @type {number}
	   * @default 0
	   */
	  zlevel: 0,
	
	  /**
	   * 是否可拖拽
	   * @name module:/zrender/graphic/Displayable#draggable
	   * @type {boolean}
	   * @default false
	   */
	  draggable: false,
	
	  /**
	   * 是否正在拖拽
	   * @name module:/zrender/graphic/Displayable#draggable
	   * @type {boolean}
	   * @default false
	   */
	  dragging: false,
	
	  /**
	   * 是否相应鼠标事件
	   * @name module:/zrender/graphic/Displayable#silent
	   * @type {boolean}
	   * @default false
	   */
	  silent: false,
	
	  /**
	   * If enable culling
	   * @type {boolean}
	   * @default false
	   */
	  culling: false,
	
	  /**
	   * Mouse cursor when hovered
	   * @name module:/zrender/graphic/Displayable#cursor
	   * @type {string}
	   */
	  cursor: 'pointer',
	
	  /**
	   * If hover area is bounding rect
	   * @name module:/zrender/graphic/Displayable#rectHover
	   * @type {string}
	   */
	  rectHover: false,
	
	  /**
	   * Render the element progressively when the value >= 0,
	   * usefull for large data.
	   * @type {number}
	   */
	  progressive: -1,
	  beforeBrush: function (ctx) {},
	  afterBrush: function (ctx) {},
	
	  /**
	   * 图形绘制方法
	   * @param {CanvasRenderingContext2D} ctx
	   */
	  // Interface
	  brush: function (ctx, prevEl) {},
	
	  /**
	   * 获取最小包围盒
	   * @return {module:zrender/core/BoundingRect}
	   */
	  // Interface
	  getBoundingRect: function () {},
	
	  /**
	   * 判断坐标 x, y 是否在图形上
	   * If displayable element contain coord x, y
	   * @param  {number} x
	   * @param  {number} y
	   * @return {boolean}
	   */
	  contain: function (x, y) {
	    return this.rectContain(x, y);
	  },
	
	  /**
	   * @param  {Function} cb
	   * @param  {}   context
	   */
	  traverse: function (cb, context) {
	    cb.call(context, this);
	  },
	
	  /**
	   * 判断坐标 x, y 是否在图形的包围盒上
	   * If bounding rect of element contain coord x, y
	   * @param  {number} x
	   * @param  {number} y
	   * @return {boolean}
	   */
	  rectContain: function (x, y) {
	    var coord = this.transformCoordToLocal(x, y);
	    var rect = this.getBoundingRect();
	    return rect.contain(coord[0], coord[1]);
	  },
	
	  /**
	   * 标记图形元素为脏，并且在下一帧重绘
	   * Mark displayable element dirty and refresh next frame
	   */
	  dirty: function () {
	    this.__dirty = true;
	    this._rect = null;
	    this.__zr && this.__zr.refresh();
	  },
	
	  /**
	   * 图形是否会触发事件
	   * If displayable object binded any event
	   * @return {boolean}
	   */
	  // TODO, 通过 bind 绑定的事件
	  // isSilent: function () {
	  //     return !(
	  //         this.hoverable || this.draggable
	  //         || this.onmousemove || this.onmouseover || this.onmouseout
	  //         || this.onmousedown || this.onmouseup || this.onclick
	  //         || this.ondragenter || this.ondragover || this.ondragleave
	  //         || this.ondrop
	  //     );
	  // },
	
	  /**
	   * Alias for animate('style')
	   * @param {boolean} loop
	   */
	  animateStyle: function (loop) {
	    return this.animate('style', loop);
	  },
	  attrKV: function (key, value) {
	    if (key !== 'style') {
	      Element.prototype.attrKV.call(this, key, value);
	    } else {
	      this.style.set(value);
	    }
	  },
	
	  /**
	   * @param {Object|string} key
	   * @param {*} value
	   */
	  setStyle: function (key, value) {
	    this.style.set(key, value);
	    this.dirty(false);
	    return this;
	  },
	
	  /**
	   * Use given style object
	   * @param  {Object} obj
	   */
	  useStyle: function (obj) {
	    this.style = new Style(obj, this);
	    this.dirty(false);
	    return this;
	  }
	};
	zrUtil.inherits(Displayable, Element);
	zrUtil.mixin(Displayable, RectText); // zrUtil.mixin(Displayable, Stateful);
	
	var _default = Displayable;
	module.exports = _default;

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	var STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);
	// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);
	
	var Style = function (opts, host) {
	  this.extendFrom(opts, false);
	  this.host = host;
	};
	
	function createLinearGradient(ctx, obj, rect) {
	  var x = obj.x == null ? 0 : obj.x;
	  var x2 = obj.x2 == null ? 1 : obj.x2;
	  var y = obj.y == null ? 0 : obj.y;
	  var y2 = obj.y2 == null ? 0 : obj.y2;
	
	  if (!obj.global) {
	    x = x * rect.width + rect.x;
	    x2 = x2 * rect.width + rect.x;
	    y = y * rect.height + rect.y;
	    y2 = y2 * rect.height + rect.y;
	  }
	
	  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
	  return canvasGradient;
	}
	
	function createRadialGradient(ctx, obj, rect) {
	  var width = rect.width;
	  var height = rect.height;
	  var min = Math.min(width, height);
	  var x = obj.x == null ? 0.5 : obj.x;
	  var y = obj.y == null ? 0.5 : obj.y;
	  var r = obj.r == null ? 0.5 : obj.r;
	
	  if (!obj.global) {
	    x = x * width + rect.x;
	    y = y * height + rect.y;
	    r = r * min;
	  }
	
	  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
	  return canvasGradient;
	}
	
	Style.prototype = {
	  constructor: Style,
	
	  /**
	   * @type {module:zrender/graphic/Displayable}
	   */
	  host: null,
	
	  /**
	   * @type {string}
	   */
	  fill: '#000',
	
	  /**
	   * @type {string}
	   */
	  stroke: null,
	
	  /**
	   * @type {number}
	   */
	  opacity: 1,
	
	  /**
	   * @type {Array.<number>}
	   */
	  lineDash: null,
	
	  /**
	   * @type {number}
	   */
	  lineDashOffset: 0,
	
	  /**
	   * @type {number}
	   */
	  shadowBlur: 0,
	
	  /**
	   * @type {number}
	   */
	  shadowOffsetX: 0,
	
	  /**
	   * @type {number}
	   */
	  shadowOffsetY: 0,
	
	  /**
	   * @type {number}
	   */
	  lineWidth: 1,
	
	  /**
	   * If stroke ignore scale
	   * @type {Boolean}
	   */
	  strokeNoScale: false,
	  // Bounding rect text configuration
	  // Not affected by element transform
	
	  /**
	   * @type {string}
	   */
	  text: null,
	
	  /**
	   * If `fontSize` or `fontFamily` exists, `font` will be reset by
	   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.
	   * So do not visit it directly in upper application (like echarts),
	   * but use `contain/text#makeFont` instead.
	   * @type {string}
	   */
	  font: null,
	
	  /**
	   * The same as font. Use font please.
	   * @deprecated
	   * @type {string}
	   */
	  textFont: null,
	
	  /**
	   * It helps merging respectively, rather than parsing an entire font string.
	   * @type {string}
	   */
	  fontStyle: null,
	
	  /**
	   * It helps merging respectively, rather than parsing an entire font string.
	   * @type {string}
	   */
	  fontWeight: null,
	
	  /**
	   * It helps merging respectively, rather than parsing an entire font string.
	   * Should be 12 but not '12px'.
	   * @type {number}
	   */
	  fontSize: null,
	
	  /**
	   * It helps merging respectively, rather than parsing an entire font string.
	   * @type {string}
	   */
	  fontFamily: null,
	
	  /**
	   * Reserved for special functinality, like 'hr'.
	   * @type {string}
	   */
	  textTag: null,
	
	  /**
	   * @type {string}
	   */
	  textFill: '#000',
	
	  /**
	   * @type {string}
	   */
	  textStroke: null,
	
	  /**
	   * @type {number}
	   */
	  textWidth: null,
	
	  /**
	   * Only for textBackground.
	   * @type {number}
	   */
	  textHeight: null,
	
	  /**
	   * textStroke may be set as some color as a default
	   * value in upper applicaion, where the default value
	   * of textStrokeWidth should be 0 to make sure that
	   * user can choose to do not use text stroke.
	   * @type {number}
	   */
	  textStrokeWidth: 0,
	
	  /**
	   * @type {number}
	   */
	  textLineHeight: null,
	
	  /**
	   * 'inside', 'left', 'right', 'top', 'bottom'
	   * [x, y]
	   * Based on x, y of rect.
	   * @type {string|Array.<number>}
	   * @default 'inside'
	   */
	  textPosition: 'inside',
	
	  /**
	   * If not specified, use the boundingRect of a `displayable`.
	   * @type {Object}
	   */
	  textRect: null,
	
	  /**
	   * [x, y]
	   * @type {Array.<number>}
	   */
	  textOffset: null,
	
	  /**
	   * @type {string}
	   */
	  textAlign: null,
	
	  /**
	   * @type {string}
	   */
	  textVerticalAlign: null,
	
	  /**
	   * @type {number}
	   */
	  textDistance: 5,
	
	  /**
	   * @type {string}
	   */
	  textShadowColor: 'transparent',
	
	  /**
	   * @type {number}
	   */
	  textShadowBlur: 0,
	
	  /**
	   * @type {number}
	   */
	  textShadowOffsetX: 0,
	
	  /**
	   * @type {number}
	   */
	  textShadowOffsetY: 0,
	
	  /**
	   * @type {string}
	   */
	  textBoxShadowColor: 'transparent',
	
	  /**
	   * @type {number}
	   */
	  textBoxShadowBlur: 0,
	
	  /**
	   * @type {number}
	   */
	  textBoxShadowOffsetX: 0,
	
	  /**
	   * @type {number}
	   */
	  textBoxShadowOffsetY: 0,
	
	  /**
	   * Whether transform text.
	   * Only useful in Path and Image element
	   * @type {boolean}
	   */
	  transformText: false,
	
	  /**
	   * Text rotate around position of Path or Image
	   * Only useful in Path and Image element and transformText is false.
	   */
	  textRotation: 0,
	
	  /**
	   * Text origin of text rotation, like [10, 40].
	   * Based on x, y of rect.
	   * Useful in label rotation of circular symbol.
	   * By default, this origin is textPosition.
	   * Can be 'center'.
	   * @type {string|Array.<number>}
	   */
	  textOrigin: null,
	
	  /**
	   * @type {string}
	   */
	  textBackgroundColor: null,
	
	  /**
	   * @type {string}
	   */
	  textBorderColor: null,
	
	  /**
	   * @type {number}
	   */
	  textBorderWidth: 0,
	
	  /**
	   * @type {number}
	   */
	  textBorderRadius: 0,
	
	  /**
	   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`
	   * @type {number|Array.<number>}
	   */
	  textPadding: null,
	
	  /**
	   * Text styles for rich text.
	   * @type {Object}
	   */
	  rich: null,
	
	  /**
	   * {outerWidth, outerHeight, ellipsis, placeholder}
	   * @type {Object}
	   */
	  truncate: null,
	
	  /**
	   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
	   * @type {string}
	   */
	  blend: null,
	
	  /**
	   * @param {CanvasRenderingContext2D} ctx
	   */
	  bind: function (ctx, el, prevEl) {
	    var style = this;
	    var prevStyle = prevEl && prevEl.style;
	    var firstDraw = !prevStyle;
	
	    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
	      var prop = STYLE_COMMON_PROPS[i];
	      var styleName = prop[0];
	
	      if (firstDraw || style[styleName] !== prevStyle[styleName]) {
	        // FIXME Invalid property value will cause style leak from previous element.
	        ctx[styleName] = style[styleName] || prop[1];
	      }
	    }
	
	    if (firstDraw || style.fill !== prevStyle.fill) {
	      ctx.fillStyle = style.fill;
	    }
	
	    if (firstDraw || style.stroke !== prevStyle.stroke) {
	      ctx.strokeStyle = style.stroke;
	    }
	
	    if (firstDraw || style.opacity !== prevStyle.opacity) {
	      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
	    }
	
	    if (firstDraw || style.blend !== prevStyle.blend) {
	      ctx.globalCompositeOperation = style.blend || 'source-over';
	    }
	
	    if (this.hasStroke()) {
	      var lineWidth = style.lineWidth;
	      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);
	    }
	  },
	  hasFill: function () {
	    var fill = this.fill;
	    return fill != null && fill !== 'none';
	  },
	  hasStroke: function () {
	    var stroke = this.stroke;
	    return stroke != null && stroke !== 'none' && this.lineWidth > 0;
	  },
	
	  /**
	   * Extend from other style
	   * @param {zrender/graphic/Style} otherStyle
	   * @param {boolean} overwrite true: overwrirte any way.
	   *                            false: overwrite only when !target.hasOwnProperty
	   *                            others: overwrite when property is not null/undefined.
	   */
	  extendFrom: function (otherStyle, overwrite) {
	    if (otherStyle) {
	      for (var name in otherStyle) {
	        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {
	          this[name] = otherStyle[name];
	        }
	      }
	    }
	  },
	
	  /**
	   * Batch setting style with a given object
	   * @param {Object|string} obj
	   * @param {*} [obj]
	   */
	  set: function (obj, value) {
	    if (typeof obj === 'string') {
	      this[obj] = value;
	    } else {
	      this.extendFrom(obj, true);
	    }
	  },
	
	  /**
	   * Clone
	   * @return {zrender/graphic/Style} [description]
	   */
	  clone: function () {
	    var newStyle = new this.constructor();
	    newStyle.extendFrom(this, true);
	    return newStyle;
	  },
	  getGradient: function (ctx, obj, rect) {
	    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;
	    var canvasGradient = method(ctx, obj, rect);
	    var colorStops = obj.colorStops;
	
	    for (var i = 0; i < colorStops.length; i++) {
	      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
	    }
	
	    return canvasGradient;
	  }
	};
	var styleProto = Style.prototype;
	
	for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
	  var prop = STYLE_COMMON_PROPS[i];
	
	  if (!(prop[0] in styleProto)) {
	    styleProto[prop[0]] = prop[1];
	  }
	} // Provide for others
	
	
	Style.getGradient = styleProto.getGradient;
	var _default = Style;
	module.exports = _default;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	var guid = __webpack_require__(11);
	
	var Eventful = __webpack_require__(12);
	
	var Transformable = __webpack_require__(13);
	
	var Animatable = __webpack_require__(16);
	
	var zrUtil = __webpack_require__(5);
	
	/**
	 * @alias module:zrender/Element
	 * @constructor
	 * @extends {module:zrender/mixin/Animatable}
	 * @extends {module:zrender/mixin/Transformable}
	 * @extends {module:zrender/mixin/Eventful}
	 */
	var Element = function (opts) {
	  // jshint ignore:line
	  Transformable.call(this, opts);
	  Eventful.call(this, opts);
	  Animatable.call(this, opts);
	  /**
	   * 画布元素ID
	   * @type {string}
	   */
	
	  this.id = opts.id || guid();
	};
	
	Element.prototype = {
	  /**
	   * 元素类型
	   * Element type
	   * @type {string}
	   */
	  type: 'element',
	
	  /**
	   * 元素名字
	   * Element name
	   * @type {string}
	   */
	  name: '',
	
	  /**
	   * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
	   * ZRender instance will be assigned when element is associated with zrender
	   * @name module:/zrender/Element#__zr
	   * @type {module:zrender/ZRender}
	   */
	  __zr: null,
	
	  /**
	   * 图形是否忽略，为true时忽略图形的绘制以及事件触发
	   * If ignore drawing and events of the element object
	   * @name module:/zrender/Element#ignore
	   * @type {boolean}
	   * @default false
	   */
	  ignore: false,
	
	  /**
	   * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
	   * 该路径会继承被裁减对象的变换
	   * @type {module:zrender/graphic/Path}
	   * @see http://www.w3.org/TR/2dcontext/#clipping-region
	   * @readOnly
	   */
	  clipPath: null,
	
	  /**
	   * Drift element
	   * @param  {number} dx dx on the global space
	   * @param  {number} dy dy on the global space
	   */
	  drift: function (dx, dy) {
	    switch (this.draggable) {
	      case 'horizontal':
	        dy = 0;
	        break;
	
	      case 'vertical':
	        dx = 0;
	        break;
	    }
	
	    var m = this.transform;
	
	    if (!m) {
	      m = this.transform = [1, 0, 0, 1, 0, 0];
	    }
	
	    m[4] += dx;
	    m[5] += dy;
	    this.decomposeTransform();
	    this.dirty(false);
	  },
	
	  /**
	   * Hook before update
	   */
	  beforeUpdate: function () {},
	
	  /**
	   * Hook after update
	   */
	  afterUpdate: function () {},
	
	  /**
	   * Update each frame
	   */
	  update: function () {
	    this.updateTransform();
	  },
	
	  /**
	   * @param  {Function} cb
	   * @param  {}   context
	   */
	  traverse: function (cb, context) {},
	
	  /**
	   * @protected
	   */
	  attrKV: function (key, value) {
	    if (key === 'position' || key === 'scale' || key === 'origin') {
	      // Copy the array
	      if (value) {
	        var target = this[key];
	
	        if (!target) {
	          target = this[key] = [];
	        }
	
	        target[0] = value[0];
	        target[1] = value[1];
	      }
	    } else {
	      this[key] = value;
	    }
	  },
	
	  /**
	   * Hide the element
	   */
	  hide: function () {
	    this.ignore = true;
	    this.__zr && this.__zr.refresh();
	  },
	
	  /**
	   * Show the element
	   */
	  show: function () {
	    this.ignore = false;
	    this.__zr && this.__zr.refresh();
	  },
	
	  /**
	   * @param {string|Object} key
	   * @param {*} value
	   */
	  attr: function (key, value) {
	    if (typeof key === 'string') {
	      this.attrKV(key, value);
	    } else if (zrUtil.isObject(key)) {
	      for (var name in key) {
	        if (key.hasOwnProperty(name)) {
	          this.attrKV(name, key[name]);
	        }
	      }
	    }
	
	    this.dirty(false);
	    return this;
	  },
	
	  /**
	   * @param {module:zrender/graphic/Path} clipPath
	   */
	  setClipPath: function (clipPath) {
	    var zr = this.__zr;
	
	    if (zr) {
	      clipPath.addSelfToZr(zr);
	    } // Remove previous clip path
	
	
	    if (this.clipPath && this.clipPath !== clipPath) {
	      this.removeClipPath();
	    }
	
	    this.clipPath = clipPath;
	    clipPath.__zr = zr;
	    clipPath.__clipTarget = this;
	    this.dirty(false);
	  },
	
	  /**
	   */
	  removeClipPath: function () {
	    var clipPath = this.clipPath;
	
	    if (clipPath) {
	      if (clipPath.__zr) {
	        clipPath.removeSelfFromZr(clipPath.__zr);
	      }
	
	      clipPath.__zr = null;
	      clipPath.__clipTarget = null;
	      this.clipPath = null;
	      this.dirty(false);
	    }
	  },
	
	  /**
	   * Add self from zrender instance.
	   * Not recursively because it will be invoked when element added to storage.
	   * @param {module:zrender/ZRender} zr
	   */
	  addSelfToZr: function (zr) {
	    this.__zr = zr; // 添加动画
	
	    var animators = this.animators;
	
	    if (animators) {
	      for (var i = 0; i < animators.length; i++) {
	        zr.animation.addAnimator(animators[i]);
	      }
	    }
	
	    if (this.clipPath) {
	      this.clipPath.addSelfToZr(zr);
	    }
	  },
	
	  /**
	   * Remove self from zrender instance.
	   * Not recursively because it will be invoked when element added to storage.
	   * @param {module:zrender/ZRender} zr
	   */
	  removeSelfFromZr: function (zr) {
	    this.__zr = null; // 移除动画
	
	    var animators = this.animators;
	
	    if (animators) {
	      for (var i = 0; i < animators.length; i++) {
	        zr.animation.removeAnimator(animators[i]);
	      }
	    }
	
	    if (this.clipPath) {
	      this.clipPath.removeSelfFromZr(zr);
	    }
	  }
	};
	zrUtil.mixin(Element, Animatable);
	zrUtil.mixin(Element, Transformable);
	zrUtil.mixin(Element, Eventful);
	var _default = Element;
	module.exports = _default;

/***/ }),
/* 11 */
/***/ (function(module, exports) {

	/**
	 * zrender: 生成唯一id
	 *
	 * @author errorrik (errorrik@gmail.com)
	 */
	var idStart = 0x0907;
	
	function _default() {
	  return idStart++;
	}
	
	module.exports = _default;

/***/ }),
/* 12 */
/***/ (function(module, exports) {

	/**
	 * 事件扩展
	 * @module zrender/mixin/Eventful
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	var arrySlice = Array.prototype.slice;
	/**
	 * 事件分发器
	 * @alias module:zrender/mixin/Eventful
	 * @constructor
	 */
	
	var Eventful = function () {
	  this._$handlers = {};
	};
	
	Eventful.prototype = {
	  constructor: Eventful,
	
	  /**
	   * 单次触发绑定，trigger后销毁
	   *
	   * @param {string} event 事件名
	   * @param {Function} handler 响应函数
	   * @param {Object} context
	   */
	  one: function (event, handler, context) {
	    var _h = this._$handlers;
	
	    if (!handler || !event) {
	      return this;
	    }
	
	    if (!_h[event]) {
	      _h[event] = [];
	    }
	
	    for (var i = 0; i < _h[event].length; i++) {
	      if (_h[event][i].h === handler) {
	        return this;
	      }
	    }
	
	    _h[event].push({
	      h: handler,
	      one: true,
	      ctx: context || this
	    });
	
	    return this;
	  },
	
	  /**
	   * 绑定事件
	   * @param {string} event 事件名
	   * @param {Function} handler 事件处理函数
	   * @param {Object} [context]
	   */
	  on: function (event, handler, context) {
	    var _h = this._$handlers;
	
	    if (!handler || !event) {
	      return this;
	    }
	
	    if (!_h[event]) {
	      _h[event] = [];
	    }
	
	    for (var i = 0; i < _h[event].length; i++) {
	      if (_h[event][i].h === handler) {
	        return this;
	      }
	    }
	
	    _h[event].push({
	      h: handler,
	      one: false,
	      ctx: context || this
	    });
	
	    return this;
	  },
	
	  /**
	   * 是否绑定了事件
	   * @param  {string}  event
	   * @return {boolean}
	   */
	  isSilent: function (event) {
	    var _h = this._$handlers;
	    return _h[event] && _h[event].length;
	  },
	
	  /**
	   * 解绑事件
	   * @param {string} event 事件名
	   * @param {Function} [handler] 事件处理函数
	   */
	  off: function (event, handler) {
	    var _h = this._$handlers;
	
	    if (!event) {
	      this._$handlers = {};
	      return this;
	    }
	
	    if (handler) {
	      if (_h[event]) {
	        var newList = [];
	
	        for (var i = 0, l = _h[event].length; i < l; i++) {
	          if (_h[event][i]['h'] != handler) {
	            newList.push(_h[event][i]);
	          }
	        }
	
	        _h[event] = newList;
	      }
	
	      if (_h[event] && _h[event].length === 0) {
	        delete _h[event];
	      }
	    } else {
	      delete _h[event];
	    }
	
	    return this;
	  },
	
	  /**
	   * 事件分发
	   *
	   * @param {string} type 事件类型
	   */
	  trigger: function (type) {
	    if (this._$handlers[type]) {
	      var args = arguments;
	      var argLen = args.length;
	
	      if (argLen > 3) {
	        args = arrySlice.call(args, 1);
	      }
	
	      var _h = this._$handlers[type];
	      var len = _h.length;
	
	      for (var i = 0; i < len;) {
	        // Optimize advise from backbone
	        switch (argLen) {
	          case 1:
	            _h[i]['h'].call(_h[i]['ctx']);
	
	            break;
	
	          case 2:
	            _h[i]['h'].call(_h[i]['ctx'], args[1]);
	
	            break;
	
	          case 3:
	            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);
	
	            break;
	
	          default:
	            // have more than 2 given arguments
	            _h[i]['h'].apply(_h[i]['ctx'], args);
	
	            break;
	        }
	
	        if (_h[i]['one']) {
	          _h.splice(i, 1);
	
	          len--;
	        } else {
	          i++;
	        }
	      }
	    }
	
	    return this;
	  },
	
	  /**
	   * 带有context的事件分发, 最后一个参数是事件回调的context
	   * @param {string} type 事件类型
	   */
	  triggerWithContext: function (type) {
	    if (this._$handlers[type]) {
	      var args = arguments;
	      var argLen = args.length;
	
	      if (argLen > 4) {
	        args = arrySlice.call(args, 1, args.length - 1);
	      }
	
	      var ctx = args[args.length - 1];
	      var _h = this._$handlers[type];
	      var len = _h.length;
	
	      for (var i = 0; i < len;) {
	        // Optimize advise from backbone
	        switch (argLen) {
	          case 1:
	            _h[i]['h'].call(ctx);
	
	            break;
	
	          case 2:
	            _h[i]['h'].call(ctx, args[1]);
	
	            break;
	
	          case 3:
	            _h[i]['h'].call(ctx, args[1], args[2]);
	
	            break;
	
	          default:
	            // have more than 2 given arguments
	            _h[i]['h'].apply(ctx, args);
	
	            break;
	        }
	
	        if (_h[i]['one']) {
	          _h.splice(i, 1);
	
	          len--;
	        } else {
	          i++;
	        }
	      }
	    }
	
	    return this;
	  }
	}; // 对象可以通过 onxxxx 绑定事件
	
	/**
	 * @event module:zrender/mixin/Eventful#onclick
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmouseover
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmouseout
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmousemove
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmousewheel
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmousedown
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmouseup
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondrag
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragstart
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragend
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragenter
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragleave
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragover
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondrop
	 * @type {Function}
	 * @default null
	 */
	
	var _default = Eventful;
	module.exports = _default;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	var matrix = __webpack_require__(14);
	
	var vector = __webpack_require__(15);
	
	/**
	 * 提供变换扩展
	 * @module zrender/mixin/Transformable
	 * @author pissang (https://www.github.com/pissang)
	 */
	var mIdentity = matrix.identity;
	var EPSILON = 5e-5;
	
	function isNotAroundZero(val) {
	  return val > EPSILON || val < -EPSILON;
	}
	/**
	 * @alias module:zrender/mixin/Transformable
	 * @constructor
	 */
	
	
	var Transformable = function (opts) {
	  opts = opts || {}; // If there are no given position, rotation, scale
	
	  if (!opts.position) {
	    /**
	     * 平移
	     * @type {Array.<number>}
	     * @default [0, 0]
	     */
	    this.position = [0, 0];
	  }
	
	  if (opts.rotation == null) {
	    /**
	     * 旋转
	     * @type {Array.<number>}
	     * @default 0
	     */
	    this.rotation = 0;
	  }
	
	  if (!opts.scale) {
	    /**
	     * 缩放
	     * @type {Array.<number>}
	     * @default [1, 1]
	     */
	    this.scale = [1, 1];
	  }
	  /**
	   * 旋转和缩放的原点
	   * @type {Array.<number>}
	   * @default null
	   */
	
	
	  this.origin = this.origin || null;
	};
	
	var transformableProto = Transformable.prototype;
	transformableProto.transform = null;
	/**
	 * 判断是否需要有坐标变换
	 * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
	 */
	
	transformableProto.needLocalTransform = function () {
	  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);
	};
	
	transformableProto.updateTransform = function () {
	  var parent = this.parent;
	  var parentHasTransform = parent && parent.transform;
	  var needLocalTransform = this.needLocalTransform();
	  var m = this.transform;
	
	  if (!(needLocalTransform || parentHasTransform)) {
	    m && mIdentity(m);
	    return;
	  }
	
	  m = m || matrix.create();
	
	  if (needLocalTransform) {
	    this.getLocalTransform(m);
	  } else {
	    mIdentity(m);
	  } // 应用父节点变换
	
	
	  if (parentHasTransform) {
	    if (needLocalTransform) {
	      matrix.mul(m, parent.transform, m);
	    } else {
	      matrix.copy(m, parent.transform);
	    }
	  } // 保存这个变换矩阵
	
	
	  this.transform = m;
	  this.invTransform = this.invTransform || matrix.create();
	  matrix.invert(this.invTransform, m);
	};
	
	transformableProto.getLocalTransform = function (m) {
	  return Transformable.getLocalTransform(this, m);
	};
	/**
	 * 将自己的transform应用到context上
	 * @param {CanvasRenderingContext2D} ctx
	 */
	
	
	transformableProto.setTransform = function (ctx) {
	  var m = this.transform;
	  var dpr = ctx.dpr || 1;
	
	  if (m) {
	    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
	  } else {
	    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	  }
	};
	
	transformableProto.restoreTransform = function (ctx) {
	  var dpr = ctx.dpr || 1;
	  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	};
	
	var tmpTransform = [];
	/**
	 * 分解`transform`矩阵到`position`, `rotation`, `scale`
	 */
	
	transformableProto.decomposeTransform = function () {
	  if (!this.transform) {
	    return;
	  }
	
	  var parent = this.parent;
	  var m = this.transform;
	
	  if (parent && parent.transform) {
	    // Get local transform and decompose them to position, scale, rotation
	    matrix.mul(tmpTransform, parent.invTransform, m);
	    m = tmpTransform;
	  }
	
	  var sx = m[0] * m[0] + m[1] * m[1];
	  var sy = m[2] * m[2] + m[3] * m[3];
	  var position = this.position;
	  var scale = this.scale;
	
	  if (isNotAroundZero(sx - 1)) {
	    sx = Math.sqrt(sx);
	  }
	
	  if (isNotAroundZero(sy - 1)) {
	    sy = Math.sqrt(sy);
	  }
	
	  if (m[0] < 0) {
	    sx = -sx;
	  }
	
	  if (m[3] < 0) {
	    sy = -sy;
	  }
	
	  position[0] = m[4];
	  position[1] = m[5];
	  scale[0] = sx;
	  scale[1] = sy;
	  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
	};
	/**
	 * Get global scale
	 * @return {Array.<number>}
	 */
	
	
	transformableProto.getGlobalScale = function () {
	  var m = this.transform;
	
	  if (!m) {
	    return [1, 1];
	  }
	
	  var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
	  var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);
	
	  if (m[0] < 0) {
	    sx = -sx;
	  }
	
	  if (m[3] < 0) {
	    sy = -sy;
	  }
	
	  return [sx, sy];
	};
	/**
	 * 变换坐标位置到 shape 的局部坐标空间
	 * @method
	 * @param {number} x
	 * @param {number} y
	 * @return {Array.<number>}
	 */
	
	
	transformableProto.transformCoordToLocal = function (x, y) {
	  var v2 = [x, y];
	  var invTransform = this.invTransform;
	
	  if (invTransform) {
	    vector.applyTransform(v2, v2, invTransform);
	  }
	
	  return v2;
	};
	/**
	 * 变换局部坐标位置到全局坐标空间
	 * @method
	 * @param {number} x
	 * @param {number} y
	 * @return {Array.<number>}
	 */
	
	
	transformableProto.transformCoordToGlobal = function (x, y) {
	  var v2 = [x, y];
	  var transform = this.transform;
	
	  if (transform) {
	    vector.applyTransform(v2, v2, transform);
	  }
	
	  return v2;
	};
	/**
	 * @static
	 * @param {Object} target
	 * @param {Array.<number>} target.origin
	 * @param {number} target.rotation
	 * @param {Array.<number>} target.position
	 * @param {Array.<number>} [m]
	 */
	
	
	Transformable.getLocalTransform = function (target, m) {
	  m = m || [];
	  mIdentity(m);
	  var origin = target.origin;
	  var scale = target.scale || [1, 1];
	  var rotation = target.rotation || 0;
	  var position = target.position || [0, 0];
	
	  if (origin) {
	    // Translate to origin
	    m[4] -= origin[0];
	    m[5] -= origin[1];
	  }
	
	  matrix.scale(m, m, scale);
	
	  if (rotation) {
	    matrix.rotate(m, m, rotation);
	  }
	
	  if (origin) {
	    // Translate back from origin
	    m[4] += origin[0];
	    m[5] += origin[1];
	  }
	
	  m[4] += position[0];
	  m[5] += position[1];
	  return m;
	};
	
	var _default = Transformable;
	module.exports = _default;

/***/ }),
/* 14 */
/***/ (function(module, exports) {

	/**
	 * 3x2矩阵操作类
	 * @exports zrender/tool/matrix
	 */
	var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
	/**
	 * 创建一个单位矩阵
	 * @return {Float32Array|Array.<number>}
	 */
	
	function create() {
	  var out = new ArrayCtor(6);
	  identity(out);
	  return out;
	}
	/**
	 * 设置矩阵为单位矩阵
	 * @param {Float32Array|Array.<number>} out
	 */
	
	
	function identity(out) {
	  out[0] = 1;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 1;
	  out[4] = 0;
	  out[5] = 0;
	  return out;
	}
	/**
	 * 复制矩阵
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} m
	 */
	
	
	function copy(out, m) {
	  out[0] = m[0];
	  out[1] = m[1];
	  out[2] = m[2];
	  out[3] = m[3];
	  out[4] = m[4];
	  out[5] = m[5];
	  return out;
	}
	/**
	 * 矩阵相乘
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} m1
	 * @param {Float32Array|Array.<number>} m2
	 */
	
	
	function mul(out, m1, m2) {
	  // Consider matrix.mul(m, m2, m);
	  // where out is the same as m2.
	  // So use temp variable to escape error.
	  var out0 = m1[0] * m2[0] + m1[2] * m2[1];
	  var out1 = m1[1] * m2[0] + m1[3] * m2[1];
	  var out2 = m1[0] * m2[2] + m1[2] * m2[3];
	  var out3 = m1[1] * m2[2] + m1[3] * m2[3];
	  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
	  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
	  out[0] = out0;
	  out[1] = out1;
	  out[2] = out2;
	  out[3] = out3;
	  out[4] = out4;
	  out[5] = out5;
	  return out;
	}
	/**
	 * 平移变换
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} a
	 * @param {Float32Array|Array.<number>} v
	 */
	
	
	function translate(out, a, v) {
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  out[4] = a[4] + v[0];
	  out[5] = a[5] + v[1];
	  return out;
	}
	/**
	 * 旋转变换
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} a
	 * @param {number} rad
	 */
	
	
	function rotate(out, a, rad) {
	  var aa = a[0];
	  var ac = a[2];
	  var atx = a[4];
	  var ab = a[1];
	  var ad = a[3];
	  var aty = a[5];
	  var st = Math.sin(rad);
	  var ct = Math.cos(rad);
	  out[0] = aa * ct + ab * st;
	  out[1] = -aa * st + ab * ct;
	  out[2] = ac * ct + ad * st;
	  out[3] = -ac * st + ct * ad;
	  out[4] = ct * atx + st * aty;
	  out[5] = ct * aty - st * atx;
	  return out;
	}
	/**
	 * 缩放变换
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} a
	 * @param {Float32Array|Array.<number>} v
	 */
	
	
	function scale(out, a, v) {
	  var vx = v[0];
	  var vy = v[1];
	  out[0] = a[0] * vx;
	  out[1] = a[1] * vy;
	  out[2] = a[2] * vx;
	  out[3] = a[3] * vy;
	  out[4] = a[4] * vx;
	  out[5] = a[5] * vy;
	  return out;
	}
	/**
	 * 求逆矩阵
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} a
	 */
	
	
	function invert(out, a) {
	  var aa = a[0];
	  var ac = a[2];
	  var atx = a[4];
	  var ab = a[1];
	  var ad = a[3];
	  var aty = a[5];
	  var det = aa * ad - ab * ac;
	
	  if (!det) {
	    return null;
	  }
	
	  det = 1.0 / det;
	  out[0] = ad * det;
	  out[1] = -ab * det;
	  out[2] = -ac * det;
	  out[3] = aa * det;
	  out[4] = (ac * aty - ad * atx) * det;
	  out[5] = (ab * atx - aa * aty) * det;
	  return out;
	}
	
	exports.create = create;
	exports.identity = identity;
	exports.copy = copy;
	exports.mul = mul;
	exports.translate = translate;
	exports.rotate = rotate;
	exports.scale = scale;
	exports.invert = invert;

/***/ }),
/* 15 */
/***/ (function(module, exports) {

	var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
	/**
	 * 创建一个向量
	 * @param {number} [x=0]
	 * @param {number} [y=0]
	 * @return {Vector2}
	 */
	
	function create(x, y) {
	  var out = new ArrayCtor(2);
	
	  if (x == null) {
	    x = 0;
	  }
	
	  if (y == null) {
	    y = 0;
	  }
	
	  out[0] = x;
	  out[1] = y;
	  return out;
	}
	/**
	 * 复制向量数据
	 * @param {Vector2} out
	 * @param {Vector2} v
	 * @return {Vector2}
	 */
	
	
	function copy(out, v) {
	  out[0] = v[0];
	  out[1] = v[1];
	  return out;
	}
	/**
	 * 克隆一个向量
	 * @param {Vector2} v
	 * @return {Vector2}
	 */
	
	
	function clone(v) {
	  var out = new ArrayCtor(2);
	  out[0] = v[0];
	  out[1] = v[1];
	  return out;
	}
	/**
	 * 设置向量的两个项
	 * @param {Vector2} out
	 * @param {number} a
	 * @param {number} b
	 * @return {Vector2} 结果
	 */
	
	
	function set(out, a, b) {
	  out[0] = a;
	  out[1] = b;
	  return out;
	}
	/**
	 * 向量相加
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 */
	
	
	function add(out, v1, v2) {
	  out[0] = v1[0] + v2[0];
	  out[1] = v1[1] + v2[1];
	  return out;
	}
	/**
	 * 向量缩放后相加
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @param {number} a
	 */
	
	
	function scaleAndAdd(out, v1, v2, a) {
	  out[0] = v1[0] + v2[0] * a;
	  out[1] = v1[1] + v2[1] * a;
	  return out;
	}
	/**
	 * 向量相减
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 */
	
	
	function sub(out, v1, v2) {
	  out[0] = v1[0] - v2[0];
	  out[1] = v1[1] - v2[1];
	  return out;
	}
	/**
	 * 向量长度
	 * @param {Vector2} v
	 * @return {number}
	 */
	
	
	function len(v) {
	  return Math.sqrt(lenSquare(v));
	}
	
	var length = len; // jshint ignore:line
	
	/**
	 * 向量长度平方
	 * @param {Vector2} v
	 * @return {number}
	 */
	
	function lenSquare(v) {
	  return v[0] * v[0] + v[1] * v[1];
	}
	
	var lengthSquare = lenSquare;
	/**
	 * 向量乘法
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 */
	
	function mul(out, v1, v2) {
	  out[0] = v1[0] * v2[0];
	  out[1] = v1[1] * v2[1];
	  return out;
	}
	/**
	 * 向量除法
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 */
	
	
	function div(out, v1, v2) {
	  out[0] = v1[0] / v2[0];
	  out[1] = v1[1] / v2[1];
	  return out;
	}
	/**
	 * 向量点乘
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @return {number}
	 */
	
	
	function dot(v1, v2) {
	  return v1[0] * v2[0] + v1[1] * v2[1];
	}
	/**
	 * 向量缩放
	 * @param {Vector2} out
	 * @param {Vector2} v
	 * @param {number} s
	 */
	
	
	function scale(out, v, s) {
	  out[0] = v[0] * s;
	  out[1] = v[1] * s;
	  return out;
	}
	/**
	 * 向量归一化
	 * @param {Vector2} out
	 * @param {Vector2} v
	 */
	
	
	function normalize(out, v) {
	  var d = len(v);
	
	  if (d === 0) {
	    out[0] = 0;
	    out[1] = 0;
	  } else {
	    out[0] = v[0] / d;
	    out[1] = v[1] / d;
	  }
	
	  return out;
	}
	/**
	 * 计算向量间距离
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @return {number}
	 */
	
	
	function distance(v1, v2) {
	  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
	}
	
	var dist = distance;
	/**
	 * 向量距离平方
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @return {number}
	 */
	
	function distanceSquare(v1, v2) {
	  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
	}
	
	var distSquare = distanceSquare;
	/**
	 * 求负向量
	 * @param {Vector2} out
	 * @param {Vector2} v
	 */
	
	function negate(out, v) {
	  out[0] = -v[0];
	  out[1] = -v[1];
	  return out;
	}
	/**
	 * 插值两个点
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @param {number} t
	 */
	
	
	function lerp(out, v1, v2, t) {
	  out[0] = v1[0] + t * (v2[0] - v1[0]);
	  out[1] = v1[1] + t * (v2[1] - v1[1]);
	  return out;
	}
	/**
	 * 矩阵左乘向量
	 * @param {Vector2} out
	 * @param {Vector2} v
	 * @param {Vector2} m
	 */
	
	
	function applyTransform(out, v, m) {
	  var x = v[0];
	  var y = v[1];
	  out[0] = m[0] * x + m[2] * y + m[4];
	  out[1] = m[1] * x + m[3] * y + m[5];
	  return out;
	}
	/**
	 * 求两个向量最小值
	 * @param  {Vector2} out
	 * @param  {Vector2} v1
	 * @param  {Vector2} v2
	 */
	
	
	function min(out, v1, v2) {
	  out[0] = Math.min(v1[0], v2[0]);
	  out[1] = Math.min(v1[1], v2[1]);
	  return out;
	}
	/**
	 * 求两个向量最大值
	 * @param  {Vector2} out
	 * @param  {Vector2} v1
	 * @param  {Vector2} v2
	 */
	
	
	function max(out, v1, v2) {
	  out[0] = Math.max(v1[0], v2[0]);
	  out[1] = Math.max(v1[1], v2[1]);
	  return out;
	}
	
	exports.create = create;
	exports.copy = copy;
	exports.clone = clone;
	exports.set = set;
	exports.add = add;
	exports.scaleAndAdd = scaleAndAdd;
	exports.sub = sub;
	exports.len = len;
	exports.length = length;
	exports.lenSquare = lenSquare;
	exports.lengthSquare = lengthSquare;
	exports.mul = mul;
	exports.div = div;
	exports.dot = dot;
	exports.scale = scale;
	exports.normalize = normalize;
	exports.distance = distance;
	exports.dist = dist;
	exports.distanceSquare = distanceSquare;
	exports.distSquare = distSquare;
	exports.negate = negate;
	exports.lerp = lerp;
	exports.applyTransform = applyTransform;
	exports.min = min;
	exports.max = max;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	var Animator = __webpack_require__(17);
	
	var log = __webpack_require__(22);
	
	var _util = __webpack_require__(5);
	
	var isString = _util.isString;
	var isFunction = _util.isFunction;
	var isObject = _util.isObject;
	var isArrayLike = _util.isArrayLike;
	var indexOf = _util.indexOf;
	
	/**
	 * @alias modue:zrender/mixin/Animatable
	 * @constructor
	 */
	var Animatable = function () {
	  /**
	   * @type {Array.<module:zrender/animation/Animator>}
	   * @readOnly
	   */
	  this.animators = [];
	};
	
	Animatable.prototype = {
	  constructor: Animatable,
	
	  /**
	   * 动画
	   *
	   * @param {string} path The path to fetch value from object, like 'a.b.c'.
	   * @param {boolean} [loop] Whether to loop animation.
	   * @return {module:zrender/animation/Animator}
	   * @example:
	   *     el.animate('style', false)
	   *         .when(1000, {x: 10} )
	   *         .done(function(){ // Animation done })
	   *         .start()
	   */
	  animate: function (path, loop) {
	    var target;
	    var animatingShape = false;
	    var el = this;
	    var zr = this.__zr;
	
	    if (path) {
	      var pathSplitted = path.split('.');
	      var prop = el; // If animating shape
	
	      animatingShape = pathSplitted[0] === 'shape';
	
	      for (var i = 0, l = pathSplitted.length; i < l; i++) {
	        if (!prop) {
	          continue;
	        }
	
	        prop = prop[pathSplitted[i]];
	      }
	
	      if (prop) {
	        target = prop;
	      }
	    } else {
	      target = el;
	    }
	
	    if (!target) {
	      log('Property "' + path + '" is not existed in element ' + el.id);
	      return;
	    }
	
	    var animators = el.animators;
	    var animator = new Animator(target, loop);
	    animator.during(function (target) {
	      el.dirty(animatingShape);
	    }).done(function () {
	      // FIXME Animator will not be removed if use `Animator#stop` to stop animation
	      animators.splice(indexOf(animators, animator), 1);
	    });
	    animators.push(animator); // If animate after added to the zrender
	
	    if (zr) {
	      zr.animation.addAnimator(animator);
	    }
	
	    return animator;
	  },
	
	  /**
	   * 停止动画
	   * @param {boolean} forwardToLast If move to last frame before stop
	   */
	  stopAnimation: function (forwardToLast) {
	    var animators = this.animators;
	    var len = animators.length;
	
	    for (var i = 0; i < len; i++) {
	      animators[i].stop(forwardToLast);
	    }
	
	    animators.length = 0;
	    return this;
	  },
	
	  /**
	   * Caution: this method will stop previous animation.
	   * So do not use this method to one element twice before
	   * animation starts, unless you know what you are doing.
	   * @param {Object} target
	   * @param {number} [time=500] Time in ms
	   * @param {string} [easing='linear']
	   * @param {number} [delay=0]
	   * @param {Function} [callback]
	   * @param {Function} [forceAnimate] Prevent stop animation and callback
	   *        immediently when target values are the same as current values.
	   *
	   * @example
	   *  // Animate position
	   *  el.animateTo({
	   *      position: [10, 10]
	   *  }, function () { // done })
	   *
	   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
	   *  el.animateTo({
	   *      shape: {
	   *          width: 500
	   *      },
	   *      style: {
	   *          fill: 'red'
	   *      }
	   *      position: [10, 10]
	   *  }, 100, 100, 'cubicOut', function () { // done })
	   */
	  // TODO Return animation key
	  animateTo: function (target, time, delay, easing, callback, forceAnimate) {
	    // animateTo(target, time, easing, callback);
	    if (isString(delay)) {
	      callback = easing;
	      easing = delay;
	      delay = 0;
	    } // animateTo(target, time, delay, callback);
	    else if (isFunction(easing)) {
	        callback = easing;
	        easing = 'linear';
	        delay = 0;
	      } // animateTo(target, time, callback);
	      else if (isFunction(delay)) {
	          callback = delay;
	          delay = 0;
	        } // animateTo(target, callback)
	        else if (isFunction(time)) {
	            callback = time;
	            time = 500;
	          } // animateTo(target)
	          else if (!time) {
	              time = 500;
	            } // Stop all previous animations
	
	
	    this.stopAnimation();
	
	    this._animateToShallow('', this, target, time, delay); // Animators may be removed immediately after start
	    // if there is nothing to animate
	
	
	    var animators = this.animators.slice();
	    var count = animators.length;
	
	    function done() {
	      count--;
	
	      if (!count) {
	        callback && callback();
	      }
	    } // No animators. This should be checked before animators[i].start(),
	    // because 'done' may be executed immediately if no need to animate.
	
	
	    if (!count) {
	      callback && callback();
	    } // Start after all animators created
	    // Incase any animator is done immediately when all animation properties are not changed
	
	
	    for (var i = 0; i < animators.length; i++) {
	      animators[i].done(done).start(easing, forceAnimate);
	    }
	  },
	
	  /**
	   * @private
	   * @param {string} path=''
	   * @param {Object} source=this
	   * @param {Object} target
	   * @param {number} [time=500]
	   * @param {number} [delay=0]
	   *
	   * @example
	   *  // Animate position
	   *  el._animateToShallow({
	   *      position: [10, 10]
	   *  })
	   *
	   *  // Animate shape, style and position in 100ms, delayed 100ms
	   *  el._animateToShallow({
	   *      shape: {
	   *          width: 500
	   *      },
	   *      style: {
	   *          fill: 'red'
	   *      }
	   *      position: [10, 10]
	   *  }, 100, 100)
	   */
	  _animateToShallow: function (path, source, target, time, delay) {
	    var objShallow = {};
	    var propertyCount = 0;
	
	    for (var name in target) {
	      if (!target.hasOwnProperty(name)) {
	        continue;
	      }
	
	      if (source[name] != null) {
	        if (isObject(target[name]) && !isArrayLike(target[name])) {
	          this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);
	        } else {
	          objShallow[name] = target[name];
	          propertyCount++;
	        }
	      } else if (target[name] != null) {
	        // Attr directly if not has property
	        // FIXME, if some property not needed for element ?
	        if (!path) {
	          this.attr(name, target[name]);
	        } else {
	          // Shape or style
	          var props = {};
	          props[path] = {};
	          props[path][name] = target[name];
	          this.attr(props);
	        }
	      }
	    }
	
	    if (propertyCount > 0) {
	      this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);
	    }
	
	    return this;
	  }
	};
	var _default = Animatable;
	module.exports = _default;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	var Clip = __webpack_require__(18);
	
	var color = __webpack_require__(20);
	
	var _util = __webpack_require__(5);
	
	var isArrayLike = _util.isArrayLike;
	
	/**
	 * @module echarts/animation/Animator
	 */
	var arraySlice = Array.prototype.slice;
	
	function defaultGetter(target, key) {
	  return target[key];
	}
	
	function defaultSetter(target, key, value) {
	  target[key] = value;
	}
	/**
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} percent
	 * @return {number}
	 */
	
	
	function interpolateNumber(p0, p1, percent) {
	  return (p1 - p0) * percent + p0;
	}
	/**
	 * @param  {string} p0
	 * @param  {string} p1
	 * @param  {number} percent
	 * @return {string}
	 */
	
	
	function interpolateString(p0, p1, percent) {
	  return percent > 0.5 ? p1 : p0;
	}
	/**
	 * @param  {Array} p0
	 * @param  {Array} p1
	 * @param  {number} percent
	 * @param  {Array} out
	 * @param  {number} arrDim
	 */
	
	
	function interpolateArray(p0, p1, percent, out, arrDim) {
	  var len = p0.length;
	
	  if (arrDim == 1) {
	    for (var i = 0; i < len; i++) {
	      out[i] = interpolateNumber(p0[i], p1[i], percent);
	    }
	  } else {
	    var len2 = len && p0[0].length;
	
	    for (var i = 0; i < len; i++) {
	      for (var j = 0; j < len2; j++) {
	        out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);
	      }
	    }
	  }
	} // arr0 is source array, arr1 is target array.
	// Do some preprocess to avoid error happened when interpolating from arr0 to arr1
	
	
	function fillArr(arr0, arr1, arrDim) {
	  var arr0Len = arr0.length;
	  var arr1Len = arr1.length;
	
	  if (arr0Len !== arr1Len) {
	    // FIXME Not work for TypedArray
	    var isPreviousLarger = arr0Len > arr1Len;
	
	    if (isPreviousLarger) {
	      // Cut the previous
	      arr0.length = arr1Len;
	    } else {
	      // Fill the previous
	      for (var i = arr0Len; i < arr1Len; i++) {
	        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
	      }
	    }
	  } // Handling NaN value
	
	
	  var len2 = arr0[0] && arr0[0].length;
	
	  for (var i = 0; i < arr0.length; i++) {
	    if (arrDim === 1) {
	      if (isNaN(arr0[i])) {
	        arr0[i] = arr1[i];
	      }
	    } else {
	      for (var j = 0; j < len2; j++) {
	        if (isNaN(arr0[i][j])) {
	          arr0[i][j] = arr1[i][j];
	        }
	      }
	    }
	  }
	}
	/**
	 * @param  {Array} arr0
	 * @param  {Array} arr1
	 * @param  {number} arrDim
	 * @return {boolean}
	 */
	
	
	function isArraySame(arr0, arr1, arrDim) {
	  if (arr0 === arr1) {
	    return true;
	  }
	
	  var len = arr0.length;
	
	  if (len !== arr1.length) {
	    return false;
	  }
	
	  if (arrDim === 1) {
	    for (var i = 0; i < len; i++) {
	      if (arr0[i] !== arr1[i]) {
	        return false;
	      }
	    }
	  } else {
	    var len2 = arr0[0].length;
	
	    for (var i = 0; i < len; i++) {
	      for (var j = 0; j < len2; j++) {
	        if (arr0[i][j] !== arr1[i][j]) {
	          return false;
	        }
	      }
	    }
	  }
	
	  return true;
	}
	/**
	 * Catmull Rom interpolate array
	 * @param  {Array} p0
	 * @param  {Array} p1
	 * @param  {Array} p2
	 * @param  {Array} p3
	 * @param  {number} t
	 * @param  {number} t2
	 * @param  {number} t3
	 * @param  {Array} out
	 * @param  {number} arrDim
	 */
	
	
	function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {
	  var len = p0.length;
	
	  if (arrDim == 1) {
	    for (var i = 0; i < len; i++) {
	      out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);
	    }
	  } else {
	    var len2 = p0[0].length;
	
	    for (var i = 0; i < len; i++) {
	      for (var j = 0; j < len2; j++) {
	        out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);
	      }
	    }
	  }
	}
	/**
	 * Catmull Rom interpolate number
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} t
	 * @param  {number} t2
	 * @param  {number} t3
	 * @return {number}
	 */
	
	
	function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
	  var v0 = (p2 - p0) * 0.5;
	  var v1 = (p3 - p1) * 0.5;
	  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
	}
	
	function cloneValue(value) {
	  if (isArrayLike(value)) {
	    var len = value.length;
	
	    if (isArrayLike(value[0])) {
	      var ret = [];
	
	      for (var i = 0; i < len; i++) {
	        ret.push(arraySlice.call(value[i]));
	      }
	
	      return ret;
	    }
	
	    return arraySlice.call(value);
	  }
	
	  return value;
	}
	
	function rgba2String(rgba) {
	  rgba[0] = Math.floor(rgba[0]);
	  rgba[1] = Math.floor(rgba[1]);
	  rgba[2] = Math.floor(rgba[2]);
	  return 'rgba(' + rgba.join(',') + ')';
	}
	
	function getArrayDim(keyframes) {
	  var lastValue = keyframes[keyframes.length - 1].value;
	  return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;
	}
	
	function createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {
	  var getter = animator._getter;
	  var setter = animator._setter;
	  var useSpline = easing === 'spline';
	  var trackLen = keyframes.length;
	
	  if (!trackLen) {
	    return;
	  } // Guess data type
	
	
	  var firstVal = keyframes[0].value;
	  var isValueArray = isArrayLike(firstVal);
	  var isValueColor = false;
	  var isValueString = false; // For vertices morphing
	
	  var arrDim = isValueArray ? getArrayDim(keyframes) : 0;
	  var trackMaxTime; // Sort keyframe as ascending
	
	  keyframes.sort(function (a, b) {
	    return a.time - b.time;
	  });
	  trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe
	
	  var kfPercents = []; // Value of each keyframe
	
	  var kfValues = [];
	  var prevValue = keyframes[0].value;
	  var isAllValueEqual = true;
	
	  for (var i = 0; i < trackLen; i++) {
	    kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string
	
	    var value = keyframes[i].value; // Check if value is equal, deep check if value is array
	
	    if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {
	      isAllValueEqual = false;
	    }
	
	    prevValue = value; // Try converting a string to a color array
	
	    if (typeof value == 'string') {
	      var colorArray = color.parse(value);
	
	      if (colorArray) {
	        value = colorArray;
	        isValueColor = true;
	      } else {
	        isValueString = true;
	      }
	    }
	
	    kfValues.push(value);
	  }
	
	  if (!forceAnimate && isAllValueEqual) {
	    return;
	  }
	
	  var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value
	
	  for (var i = 0; i < trackLen - 1; i++) {
	    if (isValueArray) {
	      fillArr(kfValues[i], lastValue, arrDim);
	    } else {
	      if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
	        kfValues[i] = lastValue;
	      }
	    }
	  }
	
	  isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when
	  // animation playback is sequency
	
	  var lastFrame = 0;
	  var lastFramePercent = 0;
	  var start;
	  var w;
	  var p0;
	  var p1;
	  var p2;
	  var p3;
	
	  if (isValueColor) {
	    var rgba = [0, 0, 0, 0];
	  }
	
	  var onframe = function (target, percent) {
	    // Find the range keyframes
	    // kf1-----kf2---------current--------kf3
	    // find kf2 and kf3 and do interpolation
	    var frame; // In the easing function like elasticOut, percent may less than 0
	
	    if (percent < 0) {
	      frame = 0;
	    } else if (percent < lastFramePercent) {
	      // Start from next key
	      // PENDING start from lastFrame ?
	      start = Math.min(lastFrame + 1, trackLen - 1);
	
	      for (frame = start; frame >= 0; frame--) {
	        if (kfPercents[frame] <= percent) {
	          break;
	        }
	      } // PENDING really need to do this ?
	
	
	      frame = Math.min(frame, trackLen - 2);
	    } else {
	      for (frame = lastFrame; frame < trackLen; frame++) {
	        if (kfPercents[frame] > percent) {
	          break;
	        }
	      }
	
	      frame = Math.min(frame - 1, trackLen - 2);
	    }
	
	    lastFrame = frame;
	    lastFramePercent = percent;
	    var range = kfPercents[frame + 1] - kfPercents[frame];
	
	    if (range === 0) {
	      return;
	    } else {
	      w = (percent - kfPercents[frame]) / range;
	    }
	
	    if (useSpline) {
	      p1 = kfValues[frame];
	      p0 = kfValues[frame === 0 ? frame : frame - 1];
	      p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
	      p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];
	
	      if (isValueArray) {
	        catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);
	      } else {
	        var value;
	
	        if (isValueColor) {
	          value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);
	          value = rgba2String(rgba);
	        } else if (isValueString) {
	          // String is step(0.5)
	          return interpolateString(p1, p2, w);
	        } else {
	          value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);
	        }
	
	        setter(target, propName, value);
	      }
	    } else {
	      if (isValueArray) {
	        interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);
	      } else {
	        var value;
	
	        if (isValueColor) {
	          interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);
	          value = rgba2String(rgba);
	        } else if (isValueString) {
	          // String is step(0.5)
	          return interpolateString(kfValues[frame], kfValues[frame + 1], w);
	        } else {
	          value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
	        }
	
	        setter(target, propName, value);
	      }
	    }
	  };
	
	  var clip = new Clip({
	    target: animator._target,
	    life: trackMaxTime,
	    loop: animator._loop,
	    delay: animator._delay,
	    onframe: onframe,
	    ondestroy: oneTrackDone
	  });
	
	  if (easing && easing !== 'spline') {
	    clip.easing = easing;
	  }
	
	  return clip;
	}
	/**
	 * @alias module:zrender/animation/Animator
	 * @constructor
	 * @param {Object} target
	 * @param {boolean} loop
	 * @param {Function} getter
	 * @param {Function} setter
	 */
	
	
	var Animator = function (target, loop, getter, setter) {
	  this._tracks = {};
	  this._target = target;
	  this._loop = loop || false;
	  this._getter = getter || defaultGetter;
	  this._setter = setter || defaultSetter;
	  this._clipCount = 0;
	  this._delay = 0;
	  this._doneList = [];
	  this._onframeList = [];
	  this._clipList = [];
	};
	
	Animator.prototype = {
	  /**
	   * 设置动画关键帧
	   * @param  {number} time 关键帧时间，单位是ms
	   * @param  {Object} props 关键帧的属性值，key-value表示
	   * @return {module:zrender/animation/Animator}
	   */
	  when: function (time
	  /* ms */
	  , props) {
	    var tracks = this._tracks;
	
	    for (var propName in props) {
	      if (!props.hasOwnProperty(propName)) {
	        continue;
	      }
	
	      if (!tracks[propName]) {
	        tracks[propName] = []; // Invalid value
	
	        var value = this._getter(this._target, propName);
	
	        if (value == null) {
	          // zrLog('Invalid property ' + propName);
	          continue;
	        } // If time is 0
	        //  Then props is given initialize value
	        // Else
	        //  Initialize value from current prop value
	
	
	        if (time !== 0) {
	          tracks[propName].push({
	            time: 0,
	            value: cloneValue(value)
	          });
	        }
	      }
	
	      tracks[propName].push({
	        time: time,
	        value: props[propName]
	      });
	    }
	
	    return this;
	  },
	
	  /**
	   * 添加动画每一帧的回调函数
	   * @param  {Function} callback
	   * @return {module:zrender/animation/Animator}
	   */
	  during: function (callback) {
	    this._onframeList.push(callback);
	
	    return this;
	  },
	  pause: function () {
	    for (var i = 0; i < this._clipList.length; i++) {
	      this._clipList[i].pause();
	    }
	
	    this._paused = true;
	  },
	  resume: function () {
	    for (var i = 0; i < this._clipList.length; i++) {
	      this._clipList[i].resume();
	    }
	
	    this._paused = false;
	  },
	  isPaused: function () {
	    return !!this._paused;
	  },
	  _doneCallback: function () {
	    // Clear all tracks
	    this._tracks = {}; // Clear all clips
	
	    this._clipList.length = 0;
	    var doneList = this._doneList;
	    var len = doneList.length;
	
	    for (var i = 0; i < len; i++) {
	      doneList[i].call(this);
	    }
	  },
	
	  /**
	   * 开始执行动画
	   * @param  {string|Function} [easing]
	   *         动画缓动函数，详见{@link module:zrender/animation/easing}
	   * @param  {boolean} forceAnimate
	   * @return {module:zrender/animation/Animator}
	   */
	  start: function (easing, forceAnimate) {
	    var self = this;
	    var clipCount = 0;
	
	    var oneTrackDone = function () {
	      clipCount--;
	
	      if (!clipCount) {
	        self._doneCallback();
	      }
	    };
	
	    var lastClip;
	
	    for (var propName in this._tracks) {
	      if (!this._tracks.hasOwnProperty(propName)) {
	        continue;
	      }
	
	      var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);
	
	      if (clip) {
	        this._clipList.push(clip);
	
	        clipCount++; // If start after added to animation
	
	        if (this.animation) {
	          this.animation.addClip(clip);
	        }
	
	        lastClip = clip;
	      }
	    } // Add during callback on the last clip
	
	
	    if (lastClip) {
	      var oldOnFrame = lastClip.onframe;
	
	      lastClip.onframe = function (target, percent) {
	        oldOnFrame(target, percent);
	
	        for (var i = 0; i < self._onframeList.length; i++) {
	          self._onframeList[i](target, percent);
	        }
	      };
	    } // This optimization will help the case that in the upper application
	    // the view may be refreshed frequently, where animation will be
	    // called repeatly but nothing changed.
	
	
	    if (!clipCount) {
	      this._doneCallback();
	    }
	
	    return this;
	  },
	
	  /**
	   * 停止动画
	   * @param {boolean} forwardToLast If move to last frame before stop
	   */
	  stop: function (forwardToLast) {
	    var clipList = this._clipList;
	    var animation = this.animation;
	
	    for (var i = 0; i < clipList.length; i++) {
	      var clip = clipList[i];
	
	      if (forwardToLast) {
	        // Move to last frame before stop
	        clip.onframe(this._target, 1);
	      }
	
	      animation && animation.removeClip(clip);
	    }
	
	    clipList.length = 0;
	  },
	
	  /**
	   * 设置动画延迟开始的时间
	   * @param  {number} time 单位ms
	   * @return {module:zrender/animation/Animator}
	   */
	  delay: function (time) {
	    this._delay = time;
	    return this;
	  },
	
	  /**
	   * 添加动画结束的回调
	   * @param  {Function} cb
	   * @return {module:zrender/animation/Animator}
	   */
	  done: function (cb) {
	    if (cb) {
	      this._doneList.push(cb);
	    }
	
	    return this;
	  },
	
	  /**
	   * @return {Array.<module:zrender/animation/Clip>}
	   */
	  getClips: function () {
	    return this._clipList;
	  }
	};
	var _default = Animator;
	module.exports = _default;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	var easingFuncs = __webpack_require__(19);
	
	/**
	 * 动画主控制器
	 * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
	 * @config life(1000) 动画时长
	 * @config delay(0) 动画延迟时间
	 * @config loop(true)
	 * @config gap(0) 循环的间隔时间
	 * @config onframe
	 * @config easing(optional)
	 * @config ondestroy(optional)
	 * @config onrestart(optional)
	 *
	 * TODO pause
	 */
	function Clip(options) {
	  this._target = options.target; // 生命周期
	
	  this._life = options.life || 1000; // 延时
	
	  this._delay = options.delay || 0; // 开始时间
	  // this._startTime = new Date().getTime() + this._delay;// 单位毫秒
	
	  this._initialized = false; // 是否循环
	
	  this.loop = options.loop == null ? false : options.loop;
	  this.gap = options.gap || 0;
	  this.easing = options.easing || 'Linear';
	  this.onframe = options.onframe;
	  this.ondestroy = options.ondestroy;
	  this.onrestart = options.onrestart;
	  this._pausedTime = 0;
	  this._paused = false;
	}
	
	Clip.prototype = {
	  constructor: Clip,
	  step: function (globalTime, deltaTime) {
	    // Set startTime on first step, or _startTime may has milleseconds different between clips
	    // PENDING
	    if (!this._initialized) {
	      this._startTime = globalTime + this._delay;
	      this._initialized = true;
	    }
	
	    if (this._paused) {
	      this._pausedTime += deltaTime;
	      return;
	    }
	
	    var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // 还没开始
	
	    if (percent < 0) {
	      return;
	    }
	
	    percent = Math.min(percent, 1);
	    var easing = this.easing;
	    var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;
	    var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;
	    this.fire('frame', schedule); // 结束
	
	    if (percent == 1) {
	      if (this.loop) {
	        this.restart(globalTime); // 重新开始周期
	        // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件
	
	        return 'restart';
	      } // 动画完成将这个控制器标识为待删除
	      // 在Animation.update中进行批量删除
	
	
	      this._needsRemove = true;
	      return 'destroy';
	    }
	
	    return null;
	  },
	  restart: function (globalTime) {
	    var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;
	    this._startTime = globalTime - remainder + this.gap;
	    this._pausedTime = 0;
	    this._needsRemove = false;
	  },
	  fire: function (eventType, arg) {
	    eventType = 'on' + eventType;
	
	    if (this[eventType]) {
	      this[eventType](this._target, arg);
	    }
	  },
	  pause: function () {
	    this._paused = true;
	  },
	  resume: function () {
	    this._paused = false;
	  }
	};
	var _default = Clip;
	module.exports = _default;

/***/ }),
/* 19 */
/***/ (function(module, exports) {

	/**
	 * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
	 * @see http://sole.github.io/tween.js/examples/03_graphs.html
	 * @exports zrender/animation/easing
	 */
	var easing = {
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  linear: function (k) {
	    return k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quadraticIn: function (k) {
	    return k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quadraticOut: function (k) {
	    return k * (2 - k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quadraticInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return 0.5 * k * k;
	    }
	
	    return -0.5 * (--k * (k - 2) - 1);
	  },
	  // 三次方的缓动（t^3）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  cubicIn: function (k) {
	    return k * k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  cubicOut: function (k) {
	    return --k * k * k + 1;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  cubicInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return 0.5 * k * k * k;
	    }
	
	    return 0.5 * ((k -= 2) * k * k + 2);
	  },
	  // 四次方的缓动（t^4）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quarticIn: function (k) {
	    return k * k * k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quarticOut: function (k) {
	    return 1 - --k * k * k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quarticInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return 0.5 * k * k * k * k;
	    }
	
	    return -0.5 * ((k -= 2) * k * k * k - 2);
	  },
	  // 五次方的缓动（t^5）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quinticIn: function (k) {
	    return k * k * k * k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quinticOut: function (k) {
	    return --k * k * k * k * k + 1;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quinticInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return 0.5 * k * k * k * k * k;
	    }
	
	    return 0.5 * ((k -= 2) * k * k * k * k + 2);
	  },
	  // 正弦曲线的缓动（sin(t)）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  sinusoidalIn: function (k) {
	    return 1 - Math.cos(k * Math.PI / 2);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  sinusoidalOut: function (k) {
	    return Math.sin(k * Math.PI / 2);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  sinusoidalInOut: function (k) {
	    return 0.5 * (1 - Math.cos(Math.PI * k));
	  },
	  // 指数曲线的缓动（2^t）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  exponentialIn: function (k) {
	    return k === 0 ? 0 : Math.pow(1024, k - 1);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  exponentialOut: function (k) {
	    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  exponentialInOut: function (k) {
	    if (k === 0) {
	      return 0;
	    }
	
	    if (k === 1) {
	      return 1;
	    }
	
	    if ((k *= 2) < 1) {
	      return 0.5 * Math.pow(1024, k - 1);
	    }
	
	    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
	  },
	  // 圆形曲线的缓动（sqrt(1-t^2)）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  circularIn: function (k) {
	    return 1 - Math.sqrt(1 - k * k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  circularOut: function (k) {
	    return Math.sqrt(1 - --k * k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  circularInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return -0.5 * (Math.sqrt(1 - k * k) - 1);
	    }
	
	    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
	  },
	  // 创建类似于弹簧在停止前来回振荡的动画
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  elasticIn: function (k) {
	    var s;
	    var a = 0.1;
	    var p = 0.4;
	
	    if (k === 0) {
	      return 0;
	    }
	
	    if (k === 1) {
	      return 1;
	    }
	
	    if (!a || a < 1) {
	      a = 1;
	      s = p / 4;
	    } else {
	      s = p * Math.asin(1 / a) / (2 * Math.PI);
	    }
	
	    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  elasticOut: function (k) {
	    var s;
	    var a = 0.1;
	    var p = 0.4;
	
	    if (k === 0) {
	      return 0;
	    }
	
	    if (k === 1) {
	      return 1;
	    }
	
	    if (!a || a < 1) {
	      a = 1;
	      s = p / 4;
	    } else {
	      s = p * Math.asin(1 / a) / (2 * Math.PI);
	    }
	
	    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  elasticInOut: function (k) {
	    var s;
	    var a = 0.1;
	    var p = 0.4;
	
	    if (k === 0) {
	      return 0;
	    }
	
	    if (k === 1) {
	      return 1;
	    }
	
	    if (!a || a < 1) {
	      a = 1;
	      s = p / 4;
	    } else {
	      s = p * Math.asin(1 / a) / (2 * Math.PI);
	    }
	
	    if ((k *= 2) < 1) {
	      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
	    }
	
	    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
	  },
	  // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  backIn: function (k) {
	    var s = 1.70158;
	    return k * k * ((s + 1) * k - s);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  backOut: function (k) {
	    var s = 1.70158;
	    return --k * k * ((s + 1) * k + s) + 1;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  backInOut: function (k) {
	    var s = 1.70158 * 1.525;
	
	    if ((k *= 2) < 1) {
	      return 0.5 * (k * k * ((s + 1) * k - s));
	    }
	
	    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
	  },
	  // 创建弹跳效果
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  bounceIn: function (k) {
	    return 1 - easing.bounceOut(1 - k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  bounceOut: function (k) {
	    if (k < 1 / 2.75) {
	      return 7.5625 * k * k;
	    } else if (k < 2 / 2.75) {
	      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
	    } else if (k < 2.5 / 2.75) {
	      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
	    } else {
	      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
	    }
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  bounceInOut: function (k) {
	    if (k < 0.5) {
	      return easing.bounceIn(k * 2) * 0.5;
	    }
	
	    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
	  }
	};
	var _default = easing;
	module.exports = _default;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	var LRU = __webpack_require__(21);
	
	var kCSSColorTable = {
	  'transparent': [0, 0, 0, 0],
	  'aliceblue': [240, 248, 255, 1],
	  'antiquewhite': [250, 235, 215, 1],
	  'aqua': [0, 255, 255, 1],
	  'aquamarine': [127, 255, 212, 1],
	  'azure': [240, 255, 255, 1],
	  'beige': [245, 245, 220, 1],
	  'bisque': [255, 228, 196, 1],
	  'black': [0, 0, 0, 1],
	  'blanchedalmond': [255, 235, 205, 1],
	  'blue': [0, 0, 255, 1],
	  'blueviolet': [138, 43, 226, 1],
	  'brown': [165, 42, 42, 1],
	  'burlywood': [222, 184, 135, 1],
	  'cadetblue': [95, 158, 160, 1],
	  'chartreuse': [127, 255, 0, 1],
	  'chocolate': [210, 105, 30, 1],
	  'coral': [255, 127, 80, 1],
	  'cornflowerblue': [100, 149, 237, 1],
	  'cornsilk': [255, 248, 220, 1],
	  'crimson': [220, 20, 60, 1],
	  'cyan': [0, 255, 255, 1],
	  'darkblue': [0, 0, 139, 1],
	  'darkcyan': [0, 139, 139, 1],
	  'darkgoldenrod': [184, 134, 11, 1],
	  'darkgray': [169, 169, 169, 1],
	  'darkgreen': [0, 100, 0, 1],
	  'darkgrey': [169, 169, 169, 1],
	  'darkkhaki': [189, 183, 107, 1],
	  'darkmagenta': [139, 0, 139, 1],
	  'darkolivegreen': [85, 107, 47, 1],
	  'darkorange': [255, 140, 0, 1],
	  'darkorchid': [153, 50, 204, 1],
	  'darkred': [139, 0, 0, 1],
	  'darksalmon': [233, 150, 122, 1],
	  'darkseagreen': [143, 188, 143, 1],
	  'darkslateblue': [72, 61, 139, 1],
	  'darkslategray': [47, 79, 79, 1],
	  'darkslategrey': [47, 79, 79, 1],
	  'darkturquoise': [0, 206, 209, 1],
	  'darkviolet': [148, 0, 211, 1],
	  'deeppink': [255, 20, 147, 1],
	  'deepskyblue': [0, 191, 255, 1],
	  'dimgray': [105, 105, 105, 1],
	  'dimgrey': [105, 105, 105, 1],
	  'dodgerblue': [30, 144, 255, 1],
	  'firebrick': [178, 34, 34, 1],
	  'floralwhite': [255, 250, 240, 1],
	  'forestgreen': [34, 139, 34, 1],
	  'fuchsia': [255, 0, 255, 1],
	  'gainsboro': [220, 220, 220, 1],
	  'ghostwhite': [248, 248, 255, 1],
	  'gold': [255, 215, 0, 1],
	  'goldenrod': [218, 165, 32, 1],
	  'gray': [128, 128, 128, 1],
	  'green': [0, 128, 0, 1],
	  'greenyellow': [173, 255, 47, 1],
	  'grey': [128, 128, 128, 1],
	  'honeydew': [240, 255, 240, 1],
	  'hotpink': [255, 105, 180, 1],
	  'indianred': [205, 92, 92, 1],
	  'indigo': [75, 0, 130, 1],
	  'ivory': [255, 255, 240, 1],
	  'khaki': [240, 230, 140, 1],
	  'lavender': [230, 230, 250, 1],
	  'lavenderblush': [255, 240, 245, 1],
	  'lawngreen': [124, 252, 0, 1],
	  'lemonchiffon': [255, 250, 205, 1],
	  'lightblue': [173, 216, 230, 1],
	  'lightcoral': [240, 128, 128, 1],
	  'lightcyan': [224, 255, 255, 1],
	  'lightgoldenrodyellow': [250, 250, 210, 1],
	  'lightgray': [211, 211, 211, 1],
	  'lightgreen': [144, 238, 144, 1],
	  'lightgrey': [211, 211, 211, 1],
	  'lightpink': [255, 182, 193, 1],
	  'lightsalmon': [255, 160, 122, 1],
	  'lightseagreen': [32, 178, 170, 1],
	  'lightskyblue': [135, 206, 250, 1],
	  'lightslategray': [119, 136, 153, 1],
	  'lightslategrey': [119, 136, 153, 1],
	  'lightsteelblue': [176, 196, 222, 1],
	  'lightyellow': [255, 255, 224, 1],
	  'lime': [0, 255, 0, 1],
	  'limegreen': [50, 205, 50, 1],
	  'linen': [250, 240, 230, 1],
	  'magenta': [255, 0, 255, 1],
	  'maroon': [128, 0, 0, 1],
	  'mediumaquamarine': [102, 205, 170, 1],
	  'mediumblue': [0, 0, 205, 1],
	  'mediumorchid': [186, 85, 211, 1],
	  'mediumpurple': [147, 112, 219, 1],
	  'mediumseagreen': [60, 179, 113, 1],
	  'mediumslateblue': [123, 104, 238, 1],
	  'mediumspringgreen': [0, 250, 154, 1],
	  'mediumturquoise': [72, 209, 204, 1],
	  'mediumvioletred': [199, 21, 133, 1],
	  'midnightblue': [25, 25, 112, 1],
	  'mintcream': [245, 255, 250, 1],
	  'mistyrose': [255, 228, 225, 1],
	  'moccasin': [255, 228, 181, 1],
	  'navajowhite': [255, 222, 173, 1],
	  'navy': [0, 0, 128, 1],
	  'oldlace': [253, 245, 230, 1],
	  'olive': [128, 128, 0, 1],
	  'olivedrab': [107, 142, 35, 1],
	  'orange': [255, 165, 0, 1],
	  'orangered': [255, 69, 0, 1],
	  'orchid': [218, 112, 214, 1],
	  'palegoldenrod': [238, 232, 170, 1],
	  'palegreen': [152, 251, 152, 1],
	  'paleturquoise': [175, 238, 238, 1],
	  'palevioletred': [219, 112, 147, 1],
	  'papayawhip': [255, 239, 213, 1],
	  'peachpuff': [255, 218, 185, 1],
	  'peru': [205, 133, 63, 1],
	  'pink': [255, 192, 203, 1],
	  'plum': [221, 160, 221, 1],
	  'powderblue': [176, 224, 230, 1],
	  'purple': [128, 0, 128, 1],
	  'red': [255, 0, 0, 1],
	  'rosybrown': [188, 143, 143, 1],
	  'royalblue': [65, 105, 225, 1],
	  'saddlebrown': [139, 69, 19, 1],
	  'salmon': [250, 128, 114, 1],
	  'sandybrown': [244, 164, 96, 1],
	  'seagreen': [46, 139, 87, 1],
	  'seashell': [255, 245, 238, 1],
	  'sienna': [160, 82, 45, 1],
	  'silver': [192, 192, 192, 1],
	  'skyblue': [135, 206, 235, 1],
	  'slateblue': [106, 90, 205, 1],
	  'slategray': [112, 128, 144, 1],
	  'slategrey': [112, 128, 144, 1],
	  'snow': [255, 250, 250, 1],
	  'springgreen': [0, 255, 127, 1],
	  'steelblue': [70, 130, 180, 1],
	  'tan': [210, 180, 140, 1],
	  'teal': [0, 128, 128, 1],
	  'thistle': [216, 191, 216, 1],
	  'tomato': [255, 99, 71, 1],
	  'turquoise': [64, 224, 208, 1],
	  'violet': [238, 130, 238, 1],
	  'wheat': [245, 222, 179, 1],
	  'white': [255, 255, 255, 1],
	  'whitesmoke': [245, 245, 245, 1],
	  'yellow': [255, 255, 0, 1],
	  'yellowgreen': [154, 205, 50, 1]
	};
	
	function clampCssByte(i) {
	  // Clamp to integer 0 .. 255.
	  i = Math.round(i); // Seems to be what Chrome does (vs truncation).
	
	  return i < 0 ? 0 : i > 255 ? 255 : i;
	}
	
	function clampCssAngle(i) {
	  // Clamp to integer 0 .. 360.
	  i = Math.round(i); // Seems to be what Chrome does (vs truncation).
	
	  return i < 0 ? 0 : i > 360 ? 360 : i;
	}
	
	function clampCssFloat(f) {
	  // Clamp to float 0.0 .. 1.0.
	  return f < 0 ? 0 : f > 1 ? 1 : f;
	}
	
	function parseCssInt(str) {
	  // int or percentage.
	  if (str.length && str.charAt(str.length - 1) === '%') {
	    return clampCssByte(parseFloat(str) / 100 * 255);
	  }
	
	  return clampCssByte(parseInt(str, 10));
	}
	
	function parseCssFloat(str) {
	  // float or percentage.
	  if (str.length && str.charAt(str.length - 1) === '%') {
	    return clampCssFloat(parseFloat(str) / 100);
	  }
	
	  return clampCssFloat(parseFloat(str));
	}
	
	function cssHueToRgb(m1, m2, h) {
	  if (h < 0) {
	    h += 1;
	  } else if (h > 1) {
	    h -= 1;
	  }
	
	  if (h * 6 < 1) {
	    return m1 + (m2 - m1) * h * 6;
	  }
	
	  if (h * 2 < 1) {
	    return m2;
	  }
	
	  if (h * 3 < 2) {
	    return m1 + (m2 - m1) * (2 / 3 - h) * 6;
	  }
	
	  return m1;
	}
	
	function lerpNumber(a, b, p) {
	  return a + (b - a) * p;
	}
	
	function setRgba(out, r, g, b, a) {
	  out[0] = r;
	  out[1] = g;
	  out[2] = b;
	  out[3] = a;
	  return out;
	}
	
	function copyRgba(out, a) {
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  return out;
	}
	
	var colorCache = new LRU(20);
	var lastRemovedArr = null;
	
	function putToCache(colorStr, rgbaArr) {
	  // Reuse removed array
	  if (lastRemovedArr) {
	    copyRgba(lastRemovedArr, rgbaArr);
	  }
	
	  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
	}
	/**
	 * @param {string} colorStr
	 * @param {Array.<number>} out
	 * @return {Array.<number>}
	 * @memberOf module:zrender/util/color
	 */
	
	
	function parse(colorStr, rgbaArr) {
	  if (!colorStr) {
	    return;
	  }
	
	  rgbaArr = rgbaArr || [];
	  var cached = colorCache.get(colorStr);
	
	  if (cached) {
	    return copyRgba(rgbaArr, cached);
	  } // colorStr may be not string
	
	
	  colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.
	
	  var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.
	
	  if (str in kCSSColorTable) {
	    copyRgba(rgbaArr, kCSSColorTable[str]);
	    putToCache(colorStr, rgbaArr);
	    return rgbaArr;
	  } // #abc and #abc123 syntax.
	
	
	  if (str.charAt(0) === '#') {
	    if (str.length === 4) {
	      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.
	
	      if (!(iv >= 0 && iv <= 0xfff)) {
	        setRgba(rgbaArr, 0, 0, 0, 1);
	        return; // Covers NaN.
	      }
	
	      setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);
	      putToCache(colorStr, rgbaArr);
	      return rgbaArr;
	    } else if (str.length === 7) {
	      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.
	
	      if (!(iv >= 0 && iv <= 0xffffff)) {
	        setRgba(rgbaArr, 0, 0, 0, 1);
	        return; // Covers NaN.
	      }
	
	      setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);
	      putToCache(colorStr, rgbaArr);
	      return rgbaArr;
	    }
	
	    return;
	  }
	
	  var op = str.indexOf('('),
	      ep = str.indexOf(')');
	
	  if (op !== -1 && ep + 1 === str.length) {
	    var fname = str.substr(0, op);
	    var params = str.substr(op + 1, ep - (op + 1)).split(',');
	    var alpha = 1; // To allow case fallthrough.
	
	    switch (fname) {
	      case 'rgba':
	        if (params.length !== 4) {
	          setRgba(rgbaArr, 0, 0, 0, 1);
	          return;
	        }
	
	        alpha = parseCssFloat(params.pop());
	      // jshint ignore:line
	      // Fall through.
	
	      case 'rgb':
	        if (params.length !== 3) {
	          setRgba(rgbaArr, 0, 0, 0, 1);
	          return;
	        }
	
	        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);
	        putToCache(colorStr, rgbaArr);
	        return rgbaArr;
	
	      case 'hsla':
	        if (params.length !== 4) {
	          setRgba(rgbaArr, 0, 0, 0, 1);
	          return;
	        }
	
	        params[3] = parseCssFloat(params[3]);
	        hsla2rgba(params, rgbaArr);
	        putToCache(colorStr, rgbaArr);
	        return rgbaArr;
	
	      case 'hsl':
	        if (params.length !== 3) {
	          setRgba(rgbaArr, 0, 0, 0, 1);
	          return;
	        }
	
	        hsla2rgba(params, rgbaArr);
	        putToCache(colorStr, rgbaArr);
	        return rgbaArr;
	
	      default:
	        return;
	    }
	  }
	
	  setRgba(rgbaArr, 0, 0, 0, 1);
	  return;
	}
	/**
	 * @param {Array.<number>} hsla
	 * @param {Array.<number>} rgba
	 * @return {Array.<number>} rgba
	 */
	
	
	function hsla2rgba(hsla, rgba) {
	  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1
	  // NOTE(deanm): According to the CSS spec s/l should only be
	  // percentages, but we don't bother and let float or percentage.
	
	  var s = parseCssFloat(hsla[1]);
	  var l = parseCssFloat(hsla[2]);
	  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
	  var m1 = l * 2 - m2;
	  rgba = rgba || [];
	  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);
	
	  if (hsla.length === 4) {
	    rgba[3] = hsla[3];
	  }
	
	  return rgba;
	}
	/**
	 * @param {Array.<number>} rgba
	 * @return {Array.<number>} hsla
	 */
	
	
	function rgba2hsla(rgba) {
	  if (!rgba) {
	    return;
	  } // RGB from 0 to 255
	
	
	  var R = rgba[0] / 255;
	  var G = rgba[1] / 255;
	  var B = rgba[2] / 255;
	  var vMin = Math.min(R, G, B); // Min. value of RGB
	
	  var vMax = Math.max(R, G, B); // Max. value of RGB
	
	  var delta = vMax - vMin; // Delta RGB value
	
	  var L = (vMax + vMin) / 2;
	  var H;
	  var S; // HSL results from 0 to 1
	
	  if (delta === 0) {
	    H = 0;
	    S = 0;
	  } else {
	    if (L < 0.5) {
	      S = delta / (vMax + vMin);
	    } else {
	      S = delta / (2 - vMax - vMin);
	    }
	
	    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
	    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
	    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;
	
	    if (R === vMax) {
	      H = deltaB - deltaG;
	    } else if (G === vMax) {
	      H = 1 / 3 + deltaR - deltaB;
	    } else if (B === vMax) {
	      H = 2 / 3 + deltaG - deltaR;
	    }
	
	    if (H < 0) {
	      H += 1;
	    }
	
	    if (H > 1) {
	      H -= 1;
	    }
	  }
	
	  var hsla = [H * 360, S, L];
	
	  if (rgba[3] != null) {
	    hsla.push(rgba[3]);
	  }
	
	  return hsla;
	}
	/**
	 * @param {string} color
	 * @param {number} level
	 * @return {string}
	 * @memberOf module:zrender/util/color
	 */
	
	
	function lift(color, level) {
	  var colorArr = parse(color);
	
	  if (colorArr) {
	    for (var i = 0; i < 3; i++) {
	      if (level < 0) {
	        colorArr[i] = colorArr[i] * (1 - level) | 0;
	      } else {
	        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;
	      }
	    }
	
	    return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
	  }
	}
	/**
	 * @param {string} color
	 * @return {string}
	 * @memberOf module:zrender/util/color
	 */
	
	
	function toHex(color) {
	  var colorArr = parse(color);
	
	  if (colorArr) {
	    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
	  }
	}
	/**
	 * Map value to color. Faster than lerp methods because color is represented by rgba array.
	 * @param {number} normalizedValue A float between 0 and 1.
	 * @param {Array.<Array.<number>>} colors List of rgba color array
	 * @param {Array.<number>} [out] Mapped gba color array
	 * @return {Array.<number>} will be null/undefined if input illegal.
	 */
	
	
	function fastLerp(normalizedValue, colors, out) {
	  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
	    return;
	  }
	
	  out = out || [];
	  var value = normalizedValue * (colors.length - 1);
	  var leftIndex = Math.floor(value);
	  var rightIndex = Math.ceil(value);
	  var leftColor = colors[leftIndex];
	  var rightColor = colors[rightIndex];
	  var dv = value - leftIndex;
	  out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
	  out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
	  out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
	  out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
	  return out;
	}
	/**
	 * @deprecated
	 */
	
	
	var fastMapToColor = fastLerp;
	/**
	 * @param {number} normalizedValue A float between 0 and 1.
	 * @param {Array.<string>} colors Color list.
	 * @param {boolean=} fullOutput Default false.
	 * @return {(string|Object)} Result color. If fullOutput,
	 *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
	 * @memberOf module:zrender/util/color
	 */
	
	function lerp(normalizedValue, colors, fullOutput) {
	  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
	    return;
	  }
	
	  var value = normalizedValue * (colors.length - 1);
	  var leftIndex = Math.floor(value);
	  var rightIndex = Math.ceil(value);
	  var leftColor = parse(colors[leftIndex]);
	  var rightColor = parse(colors[rightIndex]);
	  var dv = value - leftIndex;
	  var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');
	  return fullOutput ? {
	    color: color,
	    leftIndex: leftIndex,
	    rightIndex: rightIndex,
	    value: value
	  } : color;
	}
	/**
	 * @deprecated
	 */
	
	
	var mapToColor = lerp;
	/**
	 * @param {string} color
	 * @param {number=} h 0 ~ 360, ignore when null.
	 * @param {number=} s 0 ~ 1, ignore when null.
	 * @param {number=} l 0 ~ 1, ignore when null.
	 * @return {string} Color string in rgba format.
	 * @memberOf module:zrender/util/color
	 */
	
	function modifyHSL(color, h, s, l) {
	  color = parse(color);
	
	  if (color) {
	    color = rgba2hsla(color);
	    h != null && (color[0] = clampCssAngle(h));
	    s != null && (color[1] = parseCssFloat(s));
	    l != null && (color[2] = parseCssFloat(l));
	    return stringify(hsla2rgba(color), 'rgba');
	  }
	}
	/**
	 * @param {string} color
	 * @param {number=} alpha 0 ~ 1
	 * @return {string} Color string in rgba format.
	 * @memberOf module:zrender/util/color
	 */
	
	
	function modifyAlpha(color, alpha) {
	  color = parse(color);
	
	  if (color && alpha != null) {
	    color[3] = clampCssFloat(alpha);
	    return stringify(color, 'rgba');
	  }
	}
	/**
	 * @param {Array.<number>} arrColor like [12,33,44,0.4]
	 * @param {string} type 'rgba', 'hsva', ...
	 * @return {string} Result color. (If input illegal, return undefined).
	 */
	
	
	function stringify(arrColor, type) {
	  if (!arrColor || !arrColor.length) {
	    return;
	  }
	
	  var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];
	
	  if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
	    colorStr += ',' + arrColor[3];
	  }
	
	  return type + '(' + colorStr + ')';
	}
	
	exports.parse = parse;
	exports.lift = lift;
	exports.toHex = toHex;
	exports.fastLerp = fastLerp;
	exports.fastMapToColor = fastMapToColor;
	exports.lerp = lerp;
	exports.mapToColor = mapToColor;
	exports.modifyHSL = modifyHSL;
	exports.modifyAlpha = modifyAlpha;
	exports.stringify = stringify;

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	// Simple LRU cache use doubly linked list
	// @module zrender/core/LRU
	
	/**
	 * Simple double linked list. Compared with array, it has O(1) remove operation.
	 * @constructor
	 */
	var LinkedList = function () {
	  /**
	   * @type {module:zrender/core/LRU~Entry}
	   */
	  this.head = null;
	  /**
	   * @type {module:zrender/core/LRU~Entry}
	   */
	
	  this.tail = null;
	  this._len = 0;
	};
	
	var linkedListProto = LinkedList.prototype;
	/**
	 * Insert a new value at the tail
	 * @param  {} val
	 * @return {module:zrender/core/LRU~Entry}
	 */
	
	linkedListProto.insert = function (val) {
	  var entry = new Entry(val);
	  this.insertEntry(entry);
	  return entry;
	};
	/**
	 * Insert an entry at the tail
	 * @param  {module:zrender/core/LRU~Entry} entry
	 */
	
	
	linkedListProto.insertEntry = function (entry) {
	  if (!this.head) {
	    this.head = this.tail = entry;
	  } else {
	    this.tail.next = entry;
	    entry.prev = this.tail;
	    entry.next = null;
	    this.tail = entry;
	  }
	
	  this._len++;
	};
	/**
	 * Remove entry.
	 * @param  {module:zrender/core/LRU~Entry} entry
	 */
	
	
	linkedListProto.remove = function (entry) {
	  var prev = entry.prev;
	  var next = entry.next;
	
	  if (prev) {
	    prev.next = next;
	  } else {
	    // Is head
	    this.head = next;
	  }
	
	  if (next) {
	    next.prev = prev;
	  } else {
	    // Is tail
	    this.tail = prev;
	  }
	
	  entry.next = entry.prev = null;
	  this._len--;
	};
	/**
	 * @return {number}
	 */
	
	
	linkedListProto.len = function () {
	  return this._len;
	};
	/**
	 * Clear list
	 */
	
	
	linkedListProto.clear = function () {
	  this.head = this.tail = null;
	  this._len = 0;
	};
	/**
	 * @constructor
	 * @param {} val
	 */
	
	
	var Entry = function (val) {
	  /**
	   * @type {}
	   */
	  this.value = val;
	  /**
	   * @type {module:zrender/core/LRU~Entry}
	   */
	
	  this.next;
	  /**
	   * @type {module:zrender/core/LRU~Entry}
	   */
	
	  this.prev;
	};
	/**
	 * LRU Cache
	 * @constructor
	 * @alias module:zrender/core/LRU
	 */
	
	
	var LRU = function (maxSize) {
	  this._list = new LinkedList();
	  this._map = {};
	  this._maxSize = maxSize || 10;
	  this._lastRemovedEntry = null;
	};
	
	var LRUProto = LRU.prototype;
	/**
	 * @param  {string} key
	 * @param  {} value
	 * @return {} Removed value
	 */
	
	LRUProto.put = function (key, value) {
	  var list = this._list;
	  var map = this._map;
	  var removed = null;
	
	  if (map[key] == null) {
	    var len = list.len(); // Reuse last removed entry
	
	    var entry = this._lastRemovedEntry;
	
	    if (len >= this._maxSize && len > 0) {
	      // Remove the least recently used
	      var leastUsedEntry = list.head;
	      list.remove(leastUsedEntry);
	      delete map[leastUsedEntry.key];
	      removed = leastUsedEntry.value;
	      this._lastRemovedEntry = leastUsedEntry;
	    }
	
	    if (entry) {
	      entry.value = value;
	    } else {
	      entry = new Entry(value);
	    }
	
	    entry.key = key;
	    list.insertEntry(entry);
	    map[key] = entry;
	  }
	
	  return removed;
	};
	/**
	 * @param  {string} key
	 * @return {}
	 */
	
	
	LRUProto.get = function (key) {
	  var entry = this._map[key];
	  var list = this._list;
	
	  if (entry != null) {
	    // Put the latest used entry in the tail
	    if (entry !== list.tail) {
	      list.remove(entry);
	      list.insertEntry(entry);
	    }
	
	    return entry.value;
	  }
	};
	/**
	 * Clear the cache
	 */
	
	
	LRUProto.clear = function () {
	  this._list.clear();
	
	  this._map = {};
	};
	
	var _default = LRU;
	module.exports = _default;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	var _config = __webpack_require__(23);
	
	var debugMode = _config.debugMode;
	
	var log = function () {};
	
	if (debugMode === 1) {
	  log = function () {
	    for (var k in arguments) {
	      throw new Error(arguments[k]);
	    }
	  };
	} else if (debugMode > 1) {
	  log = function () {
	    for (var k in arguments) {
	      console.log(arguments[k]);
	    }
	  };
	}
	
	var _default = log;
	module.exports = _default;

/***/ }),
/* 23 */
/***/ (function(module, exports) {

	var dpr = 1; // If in browser environment
	
	if (typeof window !== 'undefined') {
	  dpr = Math.max(window.devicePixelRatio || 1, 1);
	}
	/**
	 * config默认配置项
	 * @exports zrender/config
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 */
	
	/**
	 * debug日志选项：catchBrushException为true下有效
	 * 0 : 不生成debug数据，发布用
	 * 1 : 异常抛出，调试用
	 * 2 : 控制台输出，调试用
	 */
	
	
	var debugMode = 0; // retina 屏幕优化
	
	var devicePixelRatio = dpr;
	exports.debugMode = debugMode;
	exports.devicePixelRatio = devicePixelRatio;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	var textHelper = __webpack_require__(25);
	
	var BoundingRect = __webpack_require__(27);
	
	/**
	 * Mixin for drawing text in a element bounding rect
	 * @module zrender/mixin/RectText
	 */
	var tmpRect = new BoundingRect();
	
	var RectText = function () {};
	
	RectText.prototype = {
	  constructor: RectText,
	
	  /**
	   * Draw text in a rect with specified position.
	   * @param  {CanvasRenderingContext2D} ctx
	   * @param  {Object} rect Displayable rect
	   */
	  drawRectText: function (ctx, rect) {
	    var style = this.style;
	    rect = style.textRect || rect; // Optimize, avoid normalize every time.
	
	    this.__dirty && textHelper.normalizeTextStyle(style, true);
	    var text = style.text; // Convert to string
	
	    text != null && (text += '');
	
	    if (!textHelper.needDrawText(text, style)) {
	      return;
	    } // FIXME
	
	
	    ctx.save(); // Transform rect to view space
	
	    var transform = this.transform;
	
	    if (!style.transformText) {
	      if (transform) {
	        tmpRect.copy(rect);
	        tmpRect.applyTransform(transform);
	        rect = tmpRect;
	      }
	    } else {
	      this.setTransform(ctx);
	    } // transformText and textRotation can not be used at the same time.
	
	
	    textHelper.renderText(this, ctx, text, style, rect);
	    ctx.restore();
	  }
	};
	var _default = RectText;
	module.exports = _default;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	var _util = __webpack_require__(5);
	
	var retrieve2 = _util.retrieve2;
	var retrieve3 = _util.retrieve3;
	var each = _util.each;
	var normalizeCssArray = _util.normalizeCssArray;
	var isString = _util.isString;
	var isObject = _util.isObject;
	
	var textContain = __webpack_require__(26);
	
	var roundRectHelper = __webpack_require__(29);
	
	var imageHelper = __webpack_require__(28);
	
	// TODO: Have not support 'start', 'end' yet.
	var VALID_TEXT_ALIGN = {
	  left: 1,
	  right: 1,
	  center: 1
	};
	var VALID_TEXT_VERTICAL_ALIGN = {
	  top: 1,
	  bottom: 1,
	  middle: 1
	};
	/**
	 * @param {module:zrender/graphic/Style} style
	 * @return {module:zrender/graphic/Style} The input style.
	 */
	
	function normalizeTextStyle(style) {
	  normalizeStyle(style);
	  each(style.rich, normalizeStyle);
	  return style;
	}
	
	function normalizeStyle(style) {
	  if (style) {
	    style.font = textContain.makeFont(style);
	    var textAlign = style.textAlign;
	    textAlign === 'middle' && (textAlign = 'center');
	    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.
	
	    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;
	    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');
	    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';
	    var textPadding = style.textPadding;
	
	    if (textPadding) {
	      style.textPadding = normalizeCssArray(style.textPadding);
	    }
	  }
	}
	/**
	 * @param {CanvasRenderingContext2D} ctx
	 * @param {string} text
	 * @param {module:zrender/graphic/Style} style
	 * @param {Object|boolean} [rect] {x, y, width, height}
	 *                  If set false, rect text is not used.
	 */
	
	
	function renderText(hostEl, ctx, text, style, rect) {
	  style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);
	}
	
	function renderPlainText(hostEl, ctx, text, style, rect) {
	  var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);
	  var textPadding = style.textPadding;
	  var contentBlock = hostEl.__textCotentBlock;
	
	  if (!contentBlock || hostEl.__dirty) {
	    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, font, textPadding, style.truncate);
	  }
	
	  var outerHeight = contentBlock.outerHeight;
	  var textLines = contentBlock.lines;
	  var lineHeight = contentBlock.lineHeight;
	  var boxPos = getBoxPosition(outerHeight, style, rect);
	  var baseX = boxPos.baseX;
	  var baseY = boxPos.baseY;
	  var textAlign = boxPos.textAlign;
	  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.
	
	  applyTextRotation(ctx, style, rect, baseX, baseY);
	  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
	  var textX = baseX;
	  var textY = boxY;
	  var needDrawBg = needDrawBackground(style);
	
	  if (needDrawBg || textPadding) {
	    // Consider performance, do not call getTextWidth util necessary.
	    var textWidth = textContain.getWidth(text, font);
	    var outerWidth = textWidth;
	    textPadding && (outerWidth += textPadding[1] + textPadding[3]);
	    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
	    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);
	
	    if (textPadding) {
	      textX = getTextXForPadding(baseX, textAlign, textPadding);
	      textY += textPadding[0];
	    }
	  }
	
	  setCtx(ctx, 'textAlign', textAlign || 'left'); // Force baseline to be "middle". Otherwise, if using "top", the
	  // text will offset downward a little bit in font "Microsoft YaHei".
	
	  setCtx(ctx, 'textBaseline', 'middle'); // Always set shadowBlur and shadowOffset to avoid leak from displayable.
	
	  setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);
	  setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');
	  setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);
	  setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0); // `textBaseline` is set as 'middle'.
	
	  textY += lineHeight / 2;
	  var textStrokeWidth = style.textStrokeWidth;
	  var textStroke = getStroke(style.textStroke, textStrokeWidth);
	  var textFill = getFill(style.textFill);
	
	  if (textStroke) {
	    setCtx(ctx, 'lineWidth', textStrokeWidth);
	    setCtx(ctx, 'strokeStyle', textStroke);
	  }
	
	  if (textFill) {
	    setCtx(ctx, 'fillStyle', textFill);
	  }
	
	  for (var i = 0; i < textLines.length; i++) {
	    // Fill after stroke so the outline will not cover the main part.
	    textStroke && ctx.strokeText(textLines[i], textX, textY);
	    textFill && ctx.fillText(textLines[i], textX, textY);
	    textY += lineHeight;
	  }
	}
	
	function renderRichText(hostEl, ctx, text, style, rect) {
	  var contentBlock = hostEl.__textCotentBlock;
	
	  if (!contentBlock || hostEl.__dirty) {
	    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);
	  }
	
	  drawRichText(hostEl, ctx, contentBlock, style, rect);
	}
	
	function drawRichText(hostEl, ctx, contentBlock, style, rect) {
	  var contentWidth = contentBlock.width;
	  var outerWidth = contentBlock.outerWidth;
	  var outerHeight = contentBlock.outerHeight;
	  var textPadding = style.textPadding;
	  var boxPos = getBoxPosition(outerHeight, style, rect);
	  var baseX = boxPos.baseX;
	  var baseY = boxPos.baseY;
	  var textAlign = boxPos.textAlign;
	  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.
	
	  applyTextRotation(ctx, style, rect, baseX, baseY);
	  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
	  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
	  var xLeft = boxX;
	  var lineTop = boxY;
	
	  if (textPadding) {
	    xLeft += textPadding[3];
	    lineTop += textPadding[0];
	  }
	
	  var xRight = xLeft + contentWidth;
	  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);
	
	  for (var i = 0; i < contentBlock.lines.length; i++) {
	    var line = contentBlock.lines[i];
	    var tokens = line.tokens;
	    var tokenCount = tokens.length;
	    var lineHeight = line.lineHeight;
	    var usedWidth = line.width;
	    var leftIndex = 0;
	    var lineXLeft = xLeft;
	    var lineXRight = xRight;
	    var rightIndex = tokenCount - 1;
	    var token;
	
	    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {
	      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');
	      usedWidth -= token.width;
	      lineXLeft += token.width;
	      leftIndex++;
	    }
	
	    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {
	      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');
	      usedWidth -= token.width;
	      lineXRight -= token.width;
	      rightIndex--;
	    } // The other tokens are placed as textAlign 'center' if there is enough space.
	
	
	    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;
	
	    while (leftIndex <= rightIndex) {
	      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.
	
	      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');
	      lineXLeft += token.width;
	      leftIndex++;
	    }
	
	    lineTop += lineHeight;
	  }
	}
	
	function applyTextRotation(ctx, style, rect, x, y) {
	  // textRotation only apply in RectText.
	  if (rect && style.textRotation) {
	    var origin = style.textOrigin;
	
	    if (origin === 'center') {
	      x = rect.width / 2 + rect.x;
	      y = rect.height / 2 + rect.y;
	    } else if (origin) {
	      x = origin[0] + rect.x;
	      y = origin[1] + rect.y;
	    }
	
	    ctx.translate(x, y); // Positive: anticlockwise
	
	    ctx.rotate(-style.textRotation);
	    ctx.translate(-x, -y);
	  }
	}
	
	function placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {
	  var tokenStyle = style.rich[token.styleName] || {}; // 'ctx.textBaseline' is always set as 'middle', for sake of
	  // the bias of "Microsoft YaHei".
	
	  var textVerticalAlign = token.textVerticalAlign;
	  var y = lineTop + lineHeight / 2;
	
	  if (textVerticalAlign === 'top') {
	    y = lineTop + token.height / 2;
	  } else if (textVerticalAlign === 'bottom') {
	    y = lineTop + lineHeight - token.height / 2;
	  }
	
	  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);
	  var textPadding = token.textPadding;
	
	  if (textPadding) {
	    x = getTextXForPadding(x, textAlign, textPadding);
	    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;
	  }
	
	  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));
	  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');
	  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));
	  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));
	  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be "middle". Otherwise, if using "top", the
	  // text will offset downward a little bit in font "Microsoft YaHei".
	
	  setCtx(ctx, 'textBaseline', 'middle');
	  setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);
	  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);
	  var textFill = getFill(tokenStyle.textFill || style.textFill);
	  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.
	
	  if (textStroke) {
	    setCtx(ctx, 'lineWidth', textStrokeWidth);
	    setCtx(ctx, 'strokeStyle', textStroke);
	    ctx.strokeText(token.text, x, y);
	  }
	
	  if (textFill) {
	    setCtx(ctx, 'fillStyle', textFill);
	    ctx.fillText(token.text, x, y);
	  }
	}
	
	function needDrawBackground(style) {
	  return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;
	} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}
	// shape: {x, y, width, height}
	
	
	function drawBackground(hostEl, ctx, style, x, y, width, height) {
	  var textBackgroundColor = style.textBackgroundColor;
	  var textBorderWidth = style.textBorderWidth;
	  var textBorderColor = style.textBorderColor;
	  var isPlainBg = isString(textBackgroundColor);
	  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);
	  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');
	  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);
	  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);
	
	  if (isPlainBg || textBorderWidth && textBorderColor) {
	    ctx.beginPath();
	    var textBorderRadius = style.textBorderRadius;
	
	    if (!textBorderRadius) {
	      ctx.rect(x, y, width, height);
	    } else {
	      roundRectHelper.buildPath(ctx, {
	        x: x,
	        y: y,
	        width: width,
	        height: height,
	        r: textBorderRadius
	      });
	    }
	
	    ctx.closePath();
	  }
	
	  if (isPlainBg) {
	    setCtx(ctx, 'fillStyle', textBackgroundColor);
	    ctx.fill();
	  } else if (isObject(textBackgroundColor)) {
	    var image = textBackgroundColor.image;
	    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);
	
	    if (image && imageHelper.isImageReady(image)) {
	      ctx.drawImage(image, x, y, width, height);
	    }
	  }
	
	  if (textBorderWidth && textBorderColor) {
	    setCtx(ctx, 'lineWidth', textBorderWidth);
	    setCtx(ctx, 'strokeStyle', textBorderColor);
	    ctx.stroke();
	  }
	}
	
	function onBgImageLoaded(image, textBackgroundColor) {
	  // Replace image, so that `contain/text.js#parseRichText`
	  // will get correct result in next tick.
	  textBackgroundColor.image = image;
	}
	
	function getBoxPosition(blockHeiht, style, rect) {
	  var baseX = style.x || 0;
	  var baseY = style.y || 0;
	  var textAlign = style.textAlign;
	  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord
	
	  if (rect) {
	    var textPosition = style.textPosition;
	
	    if (textPosition instanceof Array) {
	      // Percent
	      baseX = rect.x + parsePercent(textPosition[0], rect.width);
	      baseY = rect.y + parsePercent(textPosition[1], rect.height);
	    } else {
	      var res = textContain.adjustTextPositionOnRect(textPosition, rect, style.textDistance);
	      baseX = res.x;
	      baseY = res.y; // Default align and baseline when has textPosition
	
	      textAlign = textAlign || res.textAlign;
	      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;
	    } // textOffset is only support in RectText, otherwise
	    // we have to adjust boundingRect for textOffset.
	
	
	    var textOffset = style.textOffset;
	
	    if (textOffset) {
	      baseX += textOffset[0];
	      baseY += textOffset[1];
	    }
	  }
	
	  return {
	    baseX: baseX,
	    baseY: baseY,
	    textAlign: textAlign,
	    textVerticalAlign: textVerticalAlign
	  };
	}
	
	function setCtx(ctx, prop, value) {
	  // FIXME ??? performance try
	  // if (ctx.__currentValues[prop] !== value) {
	  // ctx[prop] = ctx.__currentValues[prop] = value;
	  ctx[prop] = value; // }
	
	  return ctx[prop];
	}
	/**
	 * @param {string} [stroke] If specified, do not check style.textStroke.
	 * @param {string} [lineWidth] If specified, do not check style.textStroke.
	 * @param {number} style
	 */
	
	
	function getStroke(stroke, lineWidth) {
	  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?
	  : stroke.image || stroke.colorStops ? '#000' : stroke;
	}
	
	function getFill(fill) {
	  return fill == null || fill === 'none' ? null // TODO pattern and gradient?
	  : fill.image || fill.colorStops ? '#000' : fill;
	}
	
	function parsePercent(value, maxValue) {
	  if (typeof value === 'string') {
	    if (value.lastIndexOf('%') >= 0) {
	      return parseFloat(value) / 100 * maxValue;
	    }
	
	    return parseFloat(value);
	  }
	
	  return value;
	}
	
	function getTextXForPadding(x, textAlign, textPadding) {
	  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
	}
	/**
	 * @param {string} text
	 * @param {module:zrender/Style} style
	 * @return {boolean}
	 */
	
	
	function needDrawText(text, style) {
	  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);
	}
	
	exports.normalizeTextStyle = normalizeTextStyle;
	exports.renderText = renderText;
	exports.getStroke = getStroke;
	exports.getFill = getFill;
	exports.needDrawText = needDrawText;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	var BoundingRect = __webpack_require__(27);
	
	var imageHelper = __webpack_require__(28);
	
	var _util = __webpack_require__(5);
	
	var getContext = _util.getContext;
	var extend = _util.extend;
	var retrieve2 = _util.retrieve2;
	var retrieve3 = _util.retrieve3;
	var textWidthCache = {};
	var textWidthCacheCounter = 0;
	var TEXT_CACHE_MAX = 5000;
	var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
	var DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.
	
	var methods = {};
	
	function $override(name, fn) {
	  methods[name] = fn;
	}
	/**
	 * @public
	 * @param {string} text
	 * @param {string} font
	 * @return {number} width
	 */
	
	
	function getWidth(text, font) {
	  font = font || DEFAULT_FONT;
	  var key = text + ':' + font;
	
	  if (textWidthCache[key]) {
	    return textWidthCache[key];
	  }
	
	  var textLines = (text + '').split('\n');
	  var width = 0;
	
	  for (var i = 0, l = textLines.length; i < l; i++) {
	    // textContain.measureText may be overrided in SVG or VML
	    width = Math.max(measureText(textLines[i], font).width, width);
	  }
	
	  if (textWidthCacheCounter > TEXT_CACHE_MAX) {
	    textWidthCacheCounter = 0;
	    textWidthCache = {};
	  }
	
	  textWidthCacheCounter++;
	  textWidthCache[key] = width;
	  return width;
	}
	/**
	 * @public
	 * @param {string} text
	 * @param {string} font
	 * @param {string} [textAlign='left']
	 * @param {string} [textVerticalAlign='top']
	 * @param {Array.<number>} [textPadding]
	 * @param {Object} [rich]
	 * @param {Object} [truncate]
	 * @return {Object} {x, y, width, height, lineHeight}
	 */
	
	
	function getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
	  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);
	}
	
	function getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {
	  var contentBlock = parsePlainText(text, font, textPadding, truncate);
	  var outerWidth = getWidth(text, font);
	
	  if (textPadding) {
	    outerWidth += textPadding[1] + textPadding[3];
	  }
	
	  var outerHeight = contentBlock.outerHeight;
	  var x = adjustTextX(0, outerWidth, textAlign);
	  var y = adjustTextY(0, outerHeight, textVerticalAlign);
	  var rect = new BoundingRect(x, y, outerWidth, outerHeight);
	  rect.lineHeight = contentBlock.lineHeight;
	  return rect;
	}
	
	function getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
	  var contentBlock = parseRichText(text, {
	    rich: rich,
	    truncate: truncate,
	    font: font,
	    textAlign: textAlign,
	    textPadding: textPadding
	  });
	  var outerWidth = contentBlock.outerWidth;
	  var outerHeight = contentBlock.outerHeight;
	  var x = adjustTextX(0, outerWidth, textAlign);
	  var y = adjustTextY(0, outerHeight, textVerticalAlign);
	  return new BoundingRect(x, y, outerWidth, outerHeight);
	}
	/**
	 * @public
	 * @param {number} x
	 * @param {number} width
	 * @param {string} [textAlign='left']
	 * @return {number} Adjusted x.
	 */
	
	
	function adjustTextX(x, width, textAlign) {
	  // FIXME Right to left language
	  if (textAlign === 'right') {
	    x -= width;
	  } else if (textAlign === 'center') {
	    x -= width / 2;
	  }
	
	  return x;
	}
	/**
	 * @public
	 * @param {number} y
	 * @param {number} height
	 * @param {string} [textVerticalAlign='top']
	 * @return {number} Adjusted y.
	 */
	
	
	function adjustTextY(y, height, textVerticalAlign) {
	  if (textVerticalAlign === 'middle') {
	    y -= height / 2;
	  } else if (textVerticalAlign === 'bottom') {
	    y -= height;
	  }
	
	  return y;
	}
	/**
	 * @public
	 * @param {stirng} textPosition
	 * @param {Object} rect {x, y, width, height}
	 * @param {number} distance
	 * @return {Object} {x, y, textAlign, textVerticalAlign}
	 */
	
	
	function adjustTextPositionOnRect(textPosition, rect, distance) {
	  var x = rect.x;
	  var y = rect.y;
	  var height = rect.height;
	  var width = rect.width;
	  var halfHeight = height / 2;
	  var textAlign = 'left';
	  var textVerticalAlign = 'top';
	
	  switch (textPosition) {
	    case 'left':
	      x -= distance;
	      y += halfHeight;
	      textAlign = 'right';
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'right':
	      x += distance + width;
	      y += halfHeight;
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'top':
	      x += width / 2;
	      y -= distance;
	      textAlign = 'center';
	      textVerticalAlign = 'bottom';
	      break;
	
	    case 'bottom':
	      x += width / 2;
	      y += height + distance;
	      textAlign = 'center';
	      break;
	
	    case 'inside':
	      x += width / 2;
	      y += halfHeight;
	      textAlign = 'center';
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'insideLeft':
	      x += distance;
	      y += halfHeight;
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'insideRight':
	      x += width - distance;
	      y += halfHeight;
	      textAlign = 'right';
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'insideTop':
	      x += width / 2;
	      y += distance;
	      textAlign = 'center';
	      break;
	
	    case 'insideBottom':
	      x += width / 2;
	      y += height - distance;
	      textAlign = 'center';
	      textVerticalAlign = 'bottom';
	      break;
	
	    case 'insideTopLeft':
	      x += distance;
	      y += distance;
	      break;
	
	    case 'insideTopRight':
	      x += width - distance;
	      y += distance;
	      textAlign = 'right';
	      break;
	
	    case 'insideBottomLeft':
	      x += distance;
	      y += height - distance;
	      textVerticalAlign = 'bottom';
	      break;
	
	    case 'insideBottomRight':
	      x += width - distance;
	      y += height - distance;
	      textAlign = 'right';
	      textVerticalAlign = 'bottom';
	      break;
	  }
	
	  return {
	    x: x,
	    y: y,
	    textAlign: textAlign,
	    textVerticalAlign: textVerticalAlign
	  };
	}
	/**
	 * Show ellipsis if overflow.
	 *
	 * @public
	 * @param  {string} text
	 * @param  {string} containerWidth
	 * @param  {string} font
	 * @param  {number} [ellipsis='...']
	 * @param  {Object} [options]
	 * @param  {number} [options.maxIterations=3]
	 * @param  {number} [options.minChar=0] If truncate result are less
	 *                  then minChar, ellipsis will not show, which is
	 *                  better for user hint in some cases.
	 * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.
	 * @return {string}
	 */
	
	
	function truncateText(text, containerWidth, font, ellipsis, options) {
	  if (!containerWidth) {
	    return '';
	  }
	
	  var textLines = (text + '').split('\n');
	  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME
	  // It is not appropriate that every line has '...' when truncate multiple lines.
	
	  for (var i = 0, len = textLines.length; i < len; i++) {
	    textLines[i] = truncateSingleLine(textLines[i], options);
	  }
	
	  return textLines.join('\n');
	}
	
	function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
	  options = extend({}, options);
	  options.font = font;
	  var ellipsis = retrieve2(ellipsis, '...');
	  options.maxIterations = retrieve2(options.maxIterations, 2);
	  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME
	  // Other languages?
	
	  options.cnCharWidth = getWidth('国', font); // FIXME
	  // Consider proportional font?
	
	  var ascCharWidth = options.ascCharWidth = getWidth('a', font);
	  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.
	  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.
	
	  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.
	
	  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
	    contentWidth -= ascCharWidth;
	  }
	
	  var ellipsisWidth = getWidth(ellipsis);
	
	  if (ellipsisWidth > contentWidth) {
	    ellipsis = '';
	    ellipsisWidth = 0;
	  }
	
	  contentWidth = containerWidth - ellipsisWidth;
	  options.ellipsis = ellipsis;
	  options.ellipsisWidth = ellipsisWidth;
	  options.contentWidth = contentWidth;
	  options.containerWidth = containerWidth;
	  return options;
	}
	
	function truncateSingleLine(textLine, options) {
	  var containerWidth = options.containerWidth;
	  var font = options.font;
	  var contentWidth = options.contentWidth;
	
	  if (!containerWidth) {
	    return '';
	  }
	
	  var lineWidth = getWidth(textLine, font);
	
	  if (lineWidth <= containerWidth) {
	    return textLine;
	  }
	
	  for (var j = 0;; j++) {
	    if (lineWidth <= contentWidth || j >= options.maxIterations) {
	      textLine += options.ellipsis;
	      break;
	    }
	
	    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
	    textLine = textLine.substr(0, subLength);
	    lineWidth = getWidth(textLine, font);
	  }
	
	  if (textLine === '') {
	    textLine = options.placeholder;
	  }
	
	  return textLine;
	}
	
	function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
	  var width = 0;
	  var i = 0;
	
	  for (var len = text.length; i < len && width < contentWidth; i++) {
	    var charCode = text.charCodeAt(i);
	    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
	  }
	
	  return i;
	}
	/**
	 * @public
	 * @param {string} font
	 * @return {number} line height
	 */
	
	
	function getLineHeight(font) {
	  // FIXME A rough approach.
	  return getWidth('国', font);
	}
	/**
	 * @public
	 * @param {string} text
	 * @param {string} font
	 * @return {Object} width
	 */
	
	
	function measureText(text, font) {
	  return methods.measureText(text, font);
	} // Avoid assign to an exported variable, for transforming to cjs.
	
	
	methods.measureText = function (text, font) {
	  var ctx = getContext();
	  ctx.font = font || DEFAULT_FONT;
	  return ctx.measureText(text);
	};
	/**
	 * @public
	 * @param {string} text
	 * @param {string} font
	 * @param {Object} [truncate]
	 * @return {Object} block: {lineHeight, lines, height, outerHeight}
	 *  Notice: for performance, do not calculate outerWidth util needed.
	 */
	
	
	function parsePlainText(text, font, padding, truncate) {
	  text != null && (text += '');
	  var lineHeight = getLineHeight(font);
	  var lines = text ? text.split('\n') : [];
	  var height = lines.length * lineHeight;
	  var outerHeight = height;
	
	  if (padding) {
	    outerHeight += padding[0] + padding[2];
	  }
	
	  if (text && truncate) {
	    var truncOuterHeight = truncate.outerHeight;
	    var truncOuterWidth = truncate.outerWidth;
	
	    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {
	      text = '';
	      lines = [];
	    } else if (truncOuterWidth != null) {
	      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {
	        minChar: truncate.minChar,
	        placeholder: truncate.placeholder
	      }); // FIXME
	      // It is not appropriate that every line has '...' when truncate multiple lines.
	
	      for (var i = 0, len = lines.length; i < len; i++) {
	        lines[i] = truncateSingleLine(lines[i], options);
	      }
	    }
	  }
	
	  return {
	    lines: lines,
	    height: height,
	    outerHeight: outerHeight,
	    lineHeight: lineHeight
	  };
	}
	/**
	 * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'
	 * Also consider 'bbbb{a|xxx\nzzz}xxxx\naaaa'.
	 *
	 * @public
	 * @param {string} text
	 * @param {Object} style
	 * @return {Object} block
	 * {
	 *      width,
	 *      height,
	 *      lines: [{
	 *          lineHeight,
	 *          width,
	 *          tokens: [[{
	 *              styleName,
	 *              text,
	 *              width,      // include textPadding
	 *              height,     // include textPadding
	 *              textWidth, // pure text width
	 *              textHeight, // pure text height
	 *              lineHeihgt,
	 *              font,
	 *              textAlign,
	 *              textVerticalAlign
	 *          }], [...], ...]
	 *      }, ...]
	 * }
	 * If styleName is undefined, it is plain text.
	 */
	
	
	function parseRichText(text, style) {
	  var contentBlock = {
	    lines: [],
	    width: 0,
	    height: 0
	  };
	  text != null && (text += '');
	
	  if (!text) {
	    return contentBlock;
	  }
	
	  var lastIndex = STYLE_REG.lastIndex = 0;
	  var result;
	
	  while ((result = STYLE_REG.exec(text)) != null) {
	    var matchedIndex = result.index;
	
	    if (matchedIndex > lastIndex) {
	      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));
	    }
	
	    pushTokens(contentBlock, result[2], result[1]);
	    lastIndex = STYLE_REG.lastIndex;
	  }
	
	  if (lastIndex < text.length) {
	    pushTokens(contentBlock, text.substring(lastIndex, text.length));
	  }
	
	  var lines = contentBlock.lines;
	  var contentHeight = 0;
	  var contentWidth = 0; // For `textWidth: 100%`
	
	  var pendingList = [];
	  var stlPadding = style.textPadding;
	  var truncate = style.truncate;
	  var truncateWidth = truncate && truncate.outerWidth;
	  var truncateHeight = truncate && truncate.outerHeight;
	
	  if (stlPadding) {
	    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);
	    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);
	  } // Calculate layout info of tokens.
	
	
	  for (var i = 0; i < lines.length; i++) {
	    var line = lines[i];
	    var lineHeight = 0;
	    var lineWidth = 0;
	
	    for (var j = 0; j < line.tokens.length; j++) {
	      var token = line.tokens[j];
	      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.
	
	      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.
	
	      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.
	
	      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified
	      // as box height of the block.
	      tokenStyle.textHeight, getLineHeight(font));
	      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
	      token.height = tokenHeight;
	      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);
	      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;
	      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';
	
	      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {
	        return {
	          lines: [],
	          width: 0,
	          height: 0
	        };
	      }
	
	      token.textWidth = getWidth(token.text, font);
	      var tokenWidth = tokenStyle.textWidth;
	      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate
	      // line when box width is needed to be auto.
	
	      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {
	        token.percentWidth = tokenWidth;
	        pendingList.push(token);
	        tokenWidth = 0; // Do not truncate in this case, because there is no user case
	        // and it is too complicated.
	      } else {
	        if (tokenWidthNotSpecified) {
	          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling
	          // `getBoundingRect()` will not get correct result.
	
	          var textBackgroundColor = tokenStyle.textBackgroundColor;
	          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:
	          // (1) If image is not loaded, it will be loaded at render phase and call
	          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded
	          // image, and then the right size will be calculated here at the next tick.
	          // See `graphic/helper/text.js`.
	          // (2) If image loaded, and `textBackgroundColor.image` is image src string,
	          // use `imageHelper.findExistImage` to find cached image.
	          // `imageHelper.findExistImage` will always be called here before
	          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`
	          // which ensures that image will not be rendered before correct size calcualted.
	
	          if (bgImg) {
	            bgImg = imageHelper.findExistImage(bgImg);
	
	            if (imageHelper.isImageReady(bgImg)) {
	              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);
	            }
	          }
	        }
	
	        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;
	        tokenWidth += paddingW;
	        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;
	
	        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {
	          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {
	            token.text = '';
	            token.textWidth = tokenWidth = 0;
	          } else {
	            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {
	              minChar: truncate.minChar
	            });
	            token.textWidth = getWidth(token.text, font);
	            tokenWidth = token.textWidth + paddingW;
	          }
	        }
	      }
	
	      lineWidth += token.width = tokenWidth;
	      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
	    }
	
	    line.width = lineWidth;
	    line.lineHeight = lineHeight;
	    contentHeight += lineHeight;
	    contentWidth = Math.max(contentWidth, lineWidth);
	  }
	
	  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);
	  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);
	
	  if (stlPadding) {
	    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
	    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
	  }
	
	  for (var i = 0; i < pendingList.length; i++) {
	    var token = pendingList[i];
	    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.
	
	    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;
	  }
	
	  return contentBlock;
	}
	
	function pushTokens(block, str, styleName) {
	  var isEmptyStr = str === '';
	  var strs = str.split('\n');
	  var lines = block.lines;
	
	  for (var i = 0; i < strs.length; i++) {
	    var text = strs[i];
	    var token = {
	      styleName: styleName,
	      text: text,
	      isLineHolder: !text && !isEmptyStr
	    }; // The first token should be appended to the last line.
	
	    if (!i) {
	      var tokens = (lines[lines.length - 1] || (lines[0] = {
	        tokens: []
	      })).tokens; // Consider cases:
	      // (1) ''.split('\n') => ['', '\n', ''], the '' at the first item
	      // (which is a placeholder) should be replaced by new token.
	      // (2) A image backage, where token likes {a|}.
	      // (3) A redundant '' will affect textAlign in line.
	      // (4) tokens with the same tplName should not be merged, because
	      // they should be displayed in different box (with border and padding).
	
	      var tokensLen = tokens.length;
	      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the "lineHolder" or
	      // "emptyStr". Otherwise a redundant '' will affect textAlign in line.
	      (text || !tokensLen || isEmptyStr) && tokens.push(token);
	    } // Other tokens always start a new line.
	    else {
	        // If there is '', insert it as a placeholder.
	        lines.push({
	          tokens: [token]
	        });
	      }
	  }
	}
	
	function makeFont(style) {
	  // FIXME in node-canvas fontWeight is before fontStyle
	  // Use `fontSize` `fontFamily` to check whether font properties are defined.
	  return (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.
	  style.fontFamily || 'sans-serif'].join(' ') || style.textFont || style.font;
	}
	
	exports.DEFAULT_FONT = DEFAULT_FONT;
	exports.$override = $override;
	exports.getWidth = getWidth;
	exports.getBoundingRect = getBoundingRect;
	exports.adjustTextX = adjustTextX;
	exports.adjustTextY = adjustTextY;
	exports.adjustTextPositionOnRect = adjustTextPositionOnRect;
	exports.truncateText = truncateText;
	exports.getLineHeight = getLineHeight;
	exports.measureText = measureText;
	exports.parsePlainText = parsePlainText;
	exports.parseRichText = parseRichText;
	exports.makeFont = makeFont;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	var vec2 = __webpack_require__(15);
	
	var matrix = __webpack_require__(14);
	
	/**
	 * @module echarts/core/BoundingRect
	 */
	var v2ApplyTransform = vec2.applyTransform;
	var mathMin = Math.min;
	var mathMax = Math.max;
	/**
	 * @alias module:echarts/core/BoundingRect
	 */
	
	function BoundingRect(x, y, width, height) {
	  if (width < 0) {
	    x = x + width;
	    width = -width;
	  }
	
	  if (height < 0) {
	    y = y + height;
	    height = -height;
	  }
	  /**
	   * @type {number}
	   */
	
	
	  this.x = x;
	  /**
	   * @type {number}
	   */
	
	  this.y = y;
	  /**
	   * @type {number}
	   */
	
	  this.width = width;
	  /**
	   * @type {number}
	   */
	
	  this.height = height;
	}
	
	BoundingRect.prototype = {
	  constructor: BoundingRect,
	
	  /**
	   * @param {module:echarts/core/BoundingRect} other
	   */
	  union: function (other) {
	    var x = mathMin(other.x, this.x);
	    var y = mathMin(other.y, this.y);
	    this.width = mathMax(other.x + other.width, this.x + this.width) - x;
	    this.height = mathMax(other.y + other.height, this.y + this.height) - y;
	    this.x = x;
	    this.y = y;
	  },
	
	  /**
	   * @param {Array.<number>} m
	   * @methods
	   */
	  applyTransform: function () {
	    var lt = [];
	    var rb = [];
	    var lb = [];
	    var rt = [];
	    return function (m) {
	      // In case usage like this
	      // el.getBoundingRect().applyTransform(el.transform)
	      // And element has no transform
	      if (!m) {
	        return;
	      }
	
	      lt[0] = lb[0] = this.x;
	      lt[1] = rt[1] = this.y;
	      rb[0] = rt[0] = this.x + this.width;
	      rb[1] = lb[1] = this.y + this.height;
	      v2ApplyTransform(lt, lt, m);
	      v2ApplyTransform(rb, rb, m);
	      v2ApplyTransform(lb, lb, m);
	      v2ApplyTransform(rt, rt, m);
	      this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);
	      this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);
	      var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);
	      var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);
	      this.width = maxX - this.x;
	      this.height = maxY - this.y;
	    };
	  }(),
	
	  /**
	   * Calculate matrix of transforming from self to target rect
	   * @param  {module:zrender/core/BoundingRect} b
	   * @return {Array.<number>}
	   */
	  calculateTransform: function (b) {
	    var a = this;
	    var sx = b.width / a.width;
	    var sy = b.height / a.height;
	    var m = matrix.create(); // 矩阵右乘
	
	    matrix.translate(m, m, [-a.x, -a.y]);
	    matrix.scale(m, m, [sx, sy]);
	    matrix.translate(m, m, [b.x, b.y]);
	    return m;
	  },
	
	  /**
	   * @param {(module:echarts/core/BoundingRect|Object)} b
	   * @return {boolean}
	   */
	  intersect: function (b) {
	    if (!b) {
	      return false;
	    }
	
	    if (!(b instanceof BoundingRect)) {
	      // Normalize negative width/height.
	      b = BoundingRect.create(b);
	    }
	
	    var a = this;
	    var ax0 = a.x;
	    var ax1 = a.x + a.width;
	    var ay0 = a.y;
	    var ay1 = a.y + a.height;
	    var bx0 = b.x;
	    var bx1 = b.x + b.width;
	    var by0 = b.y;
	    var by1 = b.y + b.height;
	    return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
	  },
	  contain: function (x, y) {
	    var rect = this;
	    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
	  },
	
	  /**
	   * @return {module:echarts/core/BoundingRect}
	   */
	  clone: function () {
	    return new BoundingRect(this.x, this.y, this.width, this.height);
	  },
	
	  /**
	   * Copy from another rect
	   */
	  copy: function (other) {
	    this.x = other.x;
	    this.y = other.y;
	    this.width = other.width;
	    this.height = other.height;
	  },
	  plain: function () {
	    return {
	      x: this.x,
	      y: this.y,
	      width: this.width,
	      height: this.height
	    };
	  }
	};
	/**
	 * @param {Object|module:zrender/core/BoundingRect} rect
	 * @param {number} rect.x
	 * @param {number} rect.y
	 * @param {number} rect.width
	 * @param {number} rect.height
	 * @return {module:zrender/core/BoundingRect}
	 */
	
	BoundingRect.create = function (rect) {
	  return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
	};
	
	var _default = BoundingRect;
	module.exports = _default;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	var LRU = __webpack_require__(21);
	
	var globalImageCache = new LRU(50);
	/**
	 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
	 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
	 */
	
	function findExistImage(newImageOrSrc) {
	  if (typeof newImageOrSrc === 'string') {
	    var cachedImgObj = globalImageCache.get(newImageOrSrc);
	    return cachedImgObj && cachedImgObj.image;
	  } else {
	    return newImageOrSrc;
	  }
	}
	/**
	 * Caution: User should cache loaded images, but not just count on LRU.
	 * Consider if required images more than LRU size, will dead loop occur?
	 *
	 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
	 * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.
	 * @param {module:zrender/Element} [hostEl] For calling `dirty`.
	 * @param {Function} [cb] params: (image, cbPayload)
	 * @param {Object} [cbPayload] Payload on cb calling.
	 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
	 */
	
	
	function createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {
	  if (!newImageOrSrc) {
	    return image;
	  } else if (typeof newImageOrSrc === 'string') {
	    // Image should not be loaded repeatly.
	    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
	      return image;
	    } // Only when there is no existent image or existent image src
	    // is different, this method is responsible for load.
	
	
	    var cachedImgObj = globalImageCache.get(newImageOrSrc);
	    var pendingWrap = {
	      hostEl: hostEl,
	      cb: cb,
	      cbPayload: cbPayload
	    };
	
	    if (cachedImgObj) {
	      image = cachedImgObj.image;
	      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
	    } else {
	      !image && (image = new Image());
	      image.onload = imageOnLoad;
	      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
	        image: image,
	        pending: [pendingWrap]
	      });
	      image.src = image.__zrImageSrc = newImageOrSrc;
	    }
	
	    return image;
	  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas
	  else {
	      return newImageOrSrc;
	    }
	}
	
	function imageOnLoad() {
	  var cachedImgObj = this.__cachedImgObj;
	  this.onload = this.__cachedImgObj = null;
	
	  for (var i = 0; i < cachedImgObj.pending.length; i++) {
	    var pendingWrap = cachedImgObj.pending[i];
	    var cb = pendingWrap.cb;
	    cb && cb(this, pendingWrap.cbPayload);
	    pendingWrap.hostEl.dirty();
	  }
	
	  cachedImgObj.pending.length = 0;
	}
	
	function isImageReady(image) {
	  return image && image.width && image.height;
	}
	
	exports.findExistImage = findExistImage;
	exports.createOrUpdateImage = createOrUpdateImage;
	exports.isImageReady = isImageReady;

/***/ }),
/* 29 */
/***/ (function(module, exports) {

	function buildPath(ctx, shape) {
	  var x = shape.x;
	  var y = shape.y;
	  var width = shape.width;
	  var height = shape.height;
	  var r = shape.r;
	  var r1;
	  var r2;
	  var r3;
	  var r4; // Convert width and height to positive for better borderRadius
	
	  if (width < 0) {
	    x = x + width;
	    width = -width;
	  }
	
	  if (height < 0) {
	    y = y + height;
	    height = -height;
	  }
	
	  if (typeof r === 'number') {
	    r1 = r2 = r3 = r4 = r;
	  } else if (r instanceof Array) {
	    if (r.length === 1) {
	      r1 = r2 = r3 = r4 = r[0];
	    } else if (r.length === 2) {
	      r1 = r3 = r[0];
	      r2 = r4 = r[1];
	    } else if (r.length === 3) {
	      r1 = r[0];
	      r2 = r4 = r[1];
	      r3 = r[2];
	    } else {
	      r1 = r[0];
	      r2 = r[1];
	      r3 = r[2];
	      r4 = r[3];
	    }
	  } else {
	    r1 = r2 = r3 = r4 = 0;
	  }
	
	  var total;
	
	  if (r1 + r2 > width) {
	    total = r1 + r2;
	    r1 *= width / total;
	    r2 *= width / total;
	  }
	
	  if (r3 + r4 > width) {
	    total = r3 + r4;
	    r3 *= width / total;
	    r4 *= width / total;
	  }
	
	  if (r2 + r3 > height) {
	    total = r2 + r3;
	    r2 *= height / total;
	    r3 *= height / total;
	  }
	
	  if (r1 + r4 > height) {
	    total = r1 + r4;
	    r1 *= height / total;
	    r4 *= height / total;
	  }
	
	  ctx.moveTo(x + r1, y);
	  ctx.lineTo(x + width - r2, y);
	  r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);
	  ctx.lineTo(x + width, y + height - r3);
	  r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);
	  ctx.lineTo(x + r4, y + height);
	  r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);
	  ctx.lineTo(x, y + r1);
	  r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
	}
	
	exports.buildPath = buildPath;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	var curve = __webpack_require__(31);
	
	var vec2 = __webpack_require__(15);
	
	var bbox = __webpack_require__(32);
	
	var BoundingRect = __webpack_require__(27);
	
	var _config = __webpack_require__(23);
	
	var dpr = _config.devicePixelRatio;
	
	/**
	 * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
	 * 可以用于 isInsidePath 判断以及获取boundingRect
	 *
	 * @module zrender/core/PathProxy
	 * @author Yi Shen (http://www.github.com/pissang)
	 */
	// TODO getTotalLength, getPointAtLength
	var CMD = {
	  M: 1,
	  L: 2,
	  C: 3,
	  Q: 4,
	  A: 5,
	  Z: 6,
	  // Rect
	  R: 7
	}; // var CMD_MEM_SIZE = {
	//     M: 3,
	//     L: 3,
	//     C: 7,
	//     Q: 5,
	//     A: 9,
	//     R: 5,
	//     Z: 1
	// };
	
	var min = [];
	var max = [];
	var min2 = [];
	var max2 = [];
	var mathMin = Math.min;
	var mathMax = Math.max;
	var mathCos = Math.cos;
	var mathSin = Math.sin;
	var mathSqrt = Math.sqrt;
	var mathAbs = Math.abs;
	var hasTypedArray = typeof Float32Array != 'undefined';
	/**
	 * @alias module:zrender/core/PathProxy
	 * @constructor
	 */
	
	var PathProxy = function (notSaveData) {
	  this._saveData = !(notSaveData || false);
	
	  if (this._saveData) {
	    /**
	     * Path data. Stored as flat array
	     * @type {Array.<Object>}
	     */
	    this.data = [];
	  }
	
	  this._ctx = null;
	};
	/**
	 * 快速计算Path包围盒（并不是最小包围盒）
	 * @return {Object}
	 */
	
	
	PathProxy.prototype = {
	  constructor: PathProxy,
	  _xi: 0,
	  _yi: 0,
	  _x0: 0,
	  _y0: 0,
	  // Unit x, Unit y. Provide for avoiding drawing that too short line segment
	  _ux: 0,
	  _uy: 0,
	  _len: 0,
	  _lineDash: null,
	  _dashOffset: 0,
	  _dashIdx: 0,
	  _dashSum: 0,
	
	  /**
	   * @readOnly
	   */
	  setScale: function (sx, sy) {
	    this._ux = mathAbs(1 / dpr / sx) || 0;
	    this._uy = mathAbs(1 / dpr / sy) || 0;
	  },
	  getContext: function () {
	    return this._ctx;
	  },
	
	  /**
	   * @param  {CanvasRenderingContext2D} ctx
	   * @return {module:zrender/core/PathProxy}
	   */
	  beginPath: function (ctx) {
	    this._ctx = ctx;
	    ctx && ctx.beginPath();
	    ctx && (this.dpr = ctx.dpr); // Reset
	
	    if (this._saveData) {
	      this._len = 0;
	    }
	
	    if (this._lineDash) {
	      this._lineDash = null;
	      this._dashOffset = 0;
	    }
	
	    return this;
	  },
	
	  /**
	   * @param  {number} x
	   * @param  {number} y
	   * @return {module:zrender/core/PathProxy}
	   */
	  moveTo: function (x, y) {
	    this.addData(CMD.M, x, y);
	    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用
	    // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。
	    // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要
	    // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持
	
	    this._x0 = x;
	    this._y0 = y;
	    this._xi = x;
	    this._yi = y;
	    return this;
	  },
	
	  /**
	   * @param  {number} x
	   * @param  {number} y
	   * @return {module:zrender/core/PathProxy}
	   */
	  lineTo: function (x, y) {
	    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment
	    || this._len < 5;
	    this.addData(CMD.L, x, y);
	
	    if (this._ctx && exceedUnit) {
	      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);
	    }
	
	    if (exceedUnit) {
	      this._xi = x;
	      this._yi = y;
	    }
	
	    return this;
	  },
	
	  /**
	   * @param  {number} x1
	   * @param  {number} y1
	   * @param  {number} x2
	   * @param  {number} y2
	   * @param  {number} x3
	   * @param  {number} y3
	   * @return {module:zrender/core/PathProxy}
	   */
	  bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {
	    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);
	
	    if (this._ctx) {
	      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
	    }
	
	    this._xi = x3;
	    this._yi = y3;
	    return this;
	  },
	
	  /**
	   * @param  {number} x1
	   * @param  {number} y1
	   * @param  {number} x2
	   * @param  {number} y2
	   * @return {module:zrender/core/PathProxy}
	   */
	  quadraticCurveTo: function (x1, y1, x2, y2) {
	    this.addData(CMD.Q, x1, y1, x2, y2);
	
	    if (this._ctx) {
	      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
	    }
	
	    this._xi = x2;
	    this._yi = y2;
	    return this;
	  },
	
	  /**
	   * @param  {number} cx
	   * @param  {number} cy
	   * @param  {number} r
	   * @param  {number} startAngle
	   * @param  {number} endAngle
	   * @param  {boolean} anticlockwise
	   * @return {module:zrender/core/PathProxy}
	   */
	  arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {
	    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);
	    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
	    this._xi = mathCos(endAngle) * r + cx;
	    this._yi = mathSin(endAngle) * r + cx;
	    return this;
	  },
	  // TODO
	  arcTo: function (x1, y1, x2, y2, radius) {
	    if (this._ctx) {
	      this._ctx.arcTo(x1, y1, x2, y2, radius);
	    }
	
	    return this;
	  },
	  // TODO
	  rect: function (x, y, w, h) {
	    this._ctx && this._ctx.rect(x, y, w, h);
	    this.addData(CMD.R, x, y, w, h);
	    return this;
	  },
	
	  /**
	   * @return {module:zrender/core/PathProxy}
	   */
	  closePath: function () {
	    this.addData(CMD.Z);
	    var ctx = this._ctx;
	    var x0 = this._x0;
	    var y0 = this._y0;
	
	    if (ctx) {
	      this._needsDash() && this._dashedLineTo(x0, y0);
	      ctx.closePath();
	    }
	
	    this._xi = x0;
	    this._yi = y0;
	    return this;
	  },
	
	  /**
	   * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
	   * stroke 同样
	   * @param {CanvasRenderingContext2D} ctx
	   * @return {module:zrender/core/PathProxy}
	   */
	  fill: function (ctx) {
	    ctx && ctx.fill();
	    this.toStatic();
	  },
	
	  /**
	   * @param {CanvasRenderingContext2D} ctx
	   * @return {module:zrender/core/PathProxy}
	   */
	  stroke: function (ctx) {
	    ctx && ctx.stroke();
	    this.toStatic();
	  },
	
	  /**
	   * 必须在其它绘制命令前调用
	   * Must be invoked before all other path drawing methods
	   * @return {module:zrender/core/PathProxy}
	   */
	  setLineDash: function (lineDash) {
	    if (lineDash instanceof Array) {
	      this._lineDash = lineDash;
	      this._dashIdx = 0;
	      var lineDashSum = 0;
	
	      for (var i = 0; i < lineDash.length; i++) {
	        lineDashSum += lineDash[i];
	      }
	
	      this._dashSum = lineDashSum;
	    }
	
	    return this;
	  },
	
	  /**
	   * 必须在其它绘制命令前调用
	   * Must be invoked before all other path drawing methods
	   * @return {module:zrender/core/PathProxy}
	   */
	  setLineDashOffset: function (offset) {
	    this._dashOffset = offset;
	    return this;
	  },
	
	  /**
	   *
	   * @return {boolean}
	   */
	  len: function () {
	    return this._len;
	  },
	
	  /**
	   * 直接设置 Path 数据
	   */
	  setData: function (data) {
	    var len = data.length;
	
	    if (!(this.data && this.data.length == len) && hasTypedArray) {
	      this.data = new Float32Array(len);
	    }
	
	    for (var i = 0; i < len; i++) {
	      this.data[i] = data[i];
	    }
	
	    this._len = len;
	  },
	
	  /**
	   * 添加子路径
	   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
	   */
	  appendPath: function (path) {
	    if (!(path instanceof Array)) {
	      path = [path];
	    }
	
	    var len = path.length;
	    var appendSize = 0;
	    var offset = this._len;
	
	    for (var i = 0; i < len; i++) {
	      appendSize += path[i].len();
	    }
	
	    if (hasTypedArray && this.data instanceof Float32Array) {
	      this.data = new Float32Array(offset + appendSize);
	    }
	
	    for (var i = 0; i < len; i++) {
	      var appendPathData = path[i].data;
	
	      for (var k = 0; k < appendPathData.length; k++) {
	        this.data[offset++] = appendPathData[k];
	      }
	    }
	
	    this._len = offset;
	  },
	
	  /**
	   * 填充 Path 数据。
	   * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
	   */
	  addData: function (cmd) {
	    if (!this._saveData) {
	      return;
	    }
	
	    var data = this.data;
	
	    if (this._len + arguments.length > data.length) {
	      // 因为之前的数组已经转换成静态的 Float32Array
	      // 所以不够用时需要扩展一个新的动态数组
	      this._expandData();
	
	      data = this.data;
	    }
	
	    for (var i = 0; i < arguments.length; i++) {
	      data[this._len++] = arguments[i];
	    }
	
	    this._prevCmd = cmd;
	  },
	  _expandData: function () {
	    // Only if data is Float32Array
	    if (!(this.data instanceof Array)) {
	      var newData = [];
	
	      for (var i = 0; i < this._len; i++) {
	        newData[i] = this.data[i];
	      }
	
	      this.data = newData;
	    }
	  },
	
	  /**
	   * If needs js implemented dashed line
	   * @return {boolean}
	   * @private
	   */
	  _needsDash: function () {
	    return this._lineDash;
	  },
	  _dashedLineTo: function (x1, y1) {
	    var dashSum = this._dashSum;
	    var offset = this._dashOffset;
	    var lineDash = this._lineDash;
	    var ctx = this._ctx;
	    var x0 = this._xi;
	    var y0 = this._yi;
	    var dx = x1 - x0;
	    var dy = y1 - y0;
	    var dist = mathSqrt(dx * dx + dy * dy);
	    var x = x0;
	    var y = y0;
	    var dash;
	    var nDash = lineDash.length;
	    var idx;
	    dx /= dist;
	    dy /= dist;
	
	    if (offset < 0) {
	      // Convert to positive offset
	      offset = dashSum + offset;
	    }
	
	    offset %= dashSum;
	    x -= offset * dx;
	    y -= offset * dy;
	
	    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {
	      idx = this._dashIdx;
	      dash = lineDash[idx];
	      x += dx * dash;
	      y += dy * dash;
	      this._dashIdx = (idx + 1) % nDash; // Skip positive offset
	
	      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {
	        continue;
	      }
	
	      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));
	    } // Offset for next lineTo
	
	
	    dx = x - x1;
	    dy = y - y1;
	    this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	  },
	  // Not accurate dashed line to
	  _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {
	    var dashSum = this._dashSum;
	    var offset = this._dashOffset;
	    var lineDash = this._lineDash;
	    var ctx = this._ctx;
	    var x0 = this._xi;
	    var y0 = this._yi;
	    var t;
	    var dx;
	    var dy;
	    var cubicAt = curve.cubicAt;
	    var bezierLen = 0;
	    var idx = this._dashIdx;
	    var nDash = lineDash.length;
	    var x;
	    var y;
	    var tmpLen = 0;
	
	    if (offset < 0) {
	      // Convert to positive offset
	      offset = dashSum + offset;
	    }
	
	    offset %= dashSum; // Bezier approx length
	
	    for (t = 0; t < 1; t += 0.1) {
	      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);
	      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);
	      bezierLen += mathSqrt(dx * dx + dy * dy);
	    } // Find idx after add offset
	
	
	    for (; idx < nDash; idx++) {
	      tmpLen += lineDash[idx];
	
	      if (tmpLen > offset) {
	        break;
	      }
	    }
	
	    t = (tmpLen - offset) / bezierLen;
	
	    while (t <= 1) {
	      x = cubicAt(x0, x1, x2, x3, t);
	      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier
	      // Bad result if dash is long
	
	      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
	      t += lineDash[idx] / bezierLen;
	      idx = (idx + 1) % nDash;
	    } // Finish the last segment and calculate the new offset
	
	
	    idx % 2 !== 0 && ctx.lineTo(x3, y3);
	    dx = x3 - x;
	    dy = y3 - y;
	    this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	  },
	  _dashedQuadraticTo: function (x1, y1, x2, y2) {
	    // Convert quadratic to cubic using degree elevation
	    var x3 = x2;
	    var y3 = y2;
	    x2 = (x2 + 2 * x1) / 3;
	    y2 = (y2 + 2 * y1) / 3;
	    x1 = (this._xi + 2 * x1) / 3;
	    y1 = (this._yi + 2 * y1) / 3;
	
	    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
	  },
	
	  /**
	   * 转成静态的 Float32Array 减少堆内存占用
	   * Convert dynamic array to static Float32Array
	   */
	  toStatic: function () {
	    var data = this.data;
	
	    if (data instanceof Array) {
	      data.length = this._len;
	
	      if (hasTypedArray) {
	        this.data = new Float32Array(data);
	      }
	    }
	  },
	
	  /**
	   * @return {module:zrender/core/BoundingRect}
	   */
	  getBoundingRect: function () {
	    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
	    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
	    var data = this.data;
	    var xi = 0;
	    var yi = 0;
	    var x0 = 0;
	    var y0 = 0;
	
	    for (var i = 0; i < data.length;) {
	      var cmd = data[i++];
	
	      if (i == 1) {
	        // 如果第一个命令是 L, C, Q
	        // 则 previous point 同绘制命令的第一个 point
	        //
	        // 第一个命令为 Arc 的情况下会在后面特殊处理
	        xi = data[i];
	        yi = data[i + 1];
	        x0 = xi;
	        y0 = yi;
	      }
	
	      switch (cmd) {
	        case CMD.M:
	          // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	          // 在 closePath 的时候使用
	          x0 = data[i++];
	          y0 = data[i++];
	          xi = x0;
	          yi = y0;
	          min2[0] = x0;
	          min2[1] = y0;
	          max2[0] = x0;
	          max2[1] = y0;
	          break;
	
	        case CMD.L:
	          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
	          xi = data[i++];
	          yi = data[i++];
	          break;
	
	        case CMD.C:
	          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);
	          xi = data[i++];
	          yi = data[i++];
	          break;
	
	        case CMD.Q:
	          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);
	          xi = data[i++];
	          yi = data[i++];
	          break;
	
	        case CMD.A:
	          // TODO Arc 判断的开销比较大
	          var cx = data[i++];
	          var cy = data[i++];
	          var rx = data[i++];
	          var ry = data[i++];
	          var startAngle = data[i++];
	          var endAngle = data[i++] + startAngle; // TODO Arc 旋转
	
	          var psi = data[i++];
	          var anticlockwise = 1 - data[i++];
	
	          if (i == 1) {
	            // 直接使用 arc 命令
	            // 第一个命令起点还未定义
	            x0 = mathCos(startAngle) * rx + cx;
	            y0 = mathSin(startAngle) * ry + cy;
	          }
	
	          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
	          xi = mathCos(endAngle) * rx + cx;
	          yi = mathSin(endAngle) * ry + cy;
	          break;
	
	        case CMD.R:
	          x0 = xi = data[i++];
	          y0 = yi = data[i++];
	          var width = data[i++];
	          var height = data[i++]; // Use fromLine
	
	          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
	          break;
	
	        case CMD.Z:
	          xi = x0;
	          yi = y0;
	          break;
	      } // Union
	
	
	      vec2.min(min, min, min2);
	      vec2.max(max, max, max2);
	    } // No data
	
	
	    if (i === 0) {
	      min[0] = min[1] = max[0] = max[1] = 0;
	    }
	
	    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	  },
	
	  /**
	   * Rebuild path from current data
	   * Rebuild path will not consider javascript implemented line dash.
	   * @param {CanvasRenderingContext2D} ctx
	   */
	  rebuildPath: function (ctx) {
	    var d = this.data;
	    var x0, y0;
	    var xi, yi;
	    var x, y;
	    var ux = this._ux;
	    var uy = this._uy;
	    var len = this._len;
	
	    for (var i = 0; i < len;) {
	      var cmd = d[i++];
	
	      if (i == 1) {
	        // 如果第一个命令是 L, C, Q
	        // 则 previous point 同绘制命令的第一个 point
	        //
	        // 第一个命令为 Arc 的情况下会在后面特殊处理
	        xi = d[i];
	        yi = d[i + 1];
	        x0 = xi;
	        y0 = yi;
	      }
	
	      switch (cmd) {
	        case CMD.M:
	          x0 = xi = d[i++];
	          y0 = yi = d[i++];
	          ctx.moveTo(xi, yi);
	          break;
	
	        case CMD.L:
	          x = d[i++];
	          y = d[i++]; // Not draw too small seg between
	
	          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
	            ctx.lineTo(x, y);
	            xi = x;
	            yi = y;
	          }
	
	          break;
	
	        case CMD.C:
	          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);
	          xi = d[i - 2];
	          yi = d[i - 1];
	          break;
	
	        case CMD.Q:
	          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
	          xi = d[i - 2];
	          yi = d[i - 1];
	          break;
	
	        case CMD.A:
	          var cx = d[i++];
	          var cy = d[i++];
	          var rx = d[i++];
	          var ry = d[i++];
	          var theta = d[i++];
	          var dTheta = d[i++];
	          var psi = d[i++];
	          var fs = d[i++];
	          var r = rx > ry ? rx : ry;
	          var scaleX = rx > ry ? 1 : rx / ry;
	          var scaleY = rx > ry ? ry / rx : 1;
	          var isEllipse = Math.abs(rx - ry) > 1e-3;
	          var endAngle = theta + dTheta;
	
	          if (isEllipse) {
	            ctx.translate(cx, cy);
	            ctx.rotate(psi);
	            ctx.scale(scaleX, scaleY);
	            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
	            ctx.scale(1 / scaleX, 1 / scaleY);
	            ctx.rotate(-psi);
	            ctx.translate(-cx, -cy);
	          } else {
	            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
	          }
	
	          if (i == 1) {
	            // 直接使用 arc 命令
	            // 第一个命令起点还未定义
	            x0 = mathCos(theta) * rx + cx;
	            y0 = mathSin(theta) * ry + cy;
	          }
	
	          xi = mathCos(endAngle) * rx + cx;
	          yi = mathSin(endAngle) * ry + cy;
	          break;
	
	        case CMD.R:
	          x0 = xi = d[i];
	          y0 = yi = d[i + 1];
	          ctx.rect(d[i++], d[i++], d[i++], d[i++]);
	          break;
	
	        case CMD.Z:
	          ctx.closePath();
	          xi = x0;
	          yi = y0;
	      }
	    }
	  }
	};
	PathProxy.CMD = CMD;
	var _default = PathProxy;
	module.exports = _default;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	var _vector = __webpack_require__(15);
	
	var v2Create = _vector.create;
	var v2DistSquare = _vector.distSquare;
	
	/**
	 * 曲线辅助模块
	 * @module zrender/core/curve
	 * @author pissang(https://www.github.com/pissang)
	 */
	var mathPow = Math.pow;
	var mathSqrt = Math.sqrt;
	var EPSILON = 1e-8;
	var EPSILON_NUMERIC = 1e-4;
	var THREE_SQRT = mathSqrt(3);
	var ONE_THIRD = 1 / 3; // 临时变量
	
	var _v0 = v2Create();
	
	var _v1 = v2Create();
	
	var _v2 = v2Create();
	
	function isAroundZero(val) {
	  return val > -EPSILON && val < EPSILON;
	}
	
	function isNotAroundZero(val) {
	  return val > EPSILON || val < -EPSILON;
	}
	/**
	 * 计算三次贝塞尔值
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} t
	 * @return {number}
	 */
	
	
	function cubicAt(p0, p1, p2, p3, t) {
	  var onet = 1 - t;
	  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
	}
	/**
	 * 计算三次贝塞尔导数值
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} t
	 * @return {number}
	 */
	
	
	function cubicDerivativeAt(p0, p1, p2, p3, t) {
	  var onet = 1 - t;
	  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
	}
	/**
	 * 计算三次贝塞尔方程根，使用盛金公式
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} val
	 * @param  {Array.<number>} roots
	 * @return {number} 有效根数目
	 */
	
	
	function cubicRootAt(p0, p1, p2, p3, val, roots) {
	  // Evaluate roots of cubic functions
	  var a = p3 + 3 * (p1 - p2) - p0;
	  var b = 3 * (p2 - p1 * 2 + p0);
	  var c = 3 * (p1 - p0);
	  var d = p0 - val;
	  var A = b * b - 3 * a * c;
	  var B = b * c - 9 * a * d;
	  var C = c * c - 3 * b * d;
	  var n = 0;
	
	  if (isAroundZero(A) && isAroundZero(B)) {
	    if (isAroundZero(b)) {
	      roots[0] = 0;
	    } else {
	      var t1 = -c / b; //t1, t2, t3, b is not zero
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	    }
	  } else {
	    var disc = B * B - 4 * A * C;
	
	    if (isAroundZero(disc)) {
	      var K = B / A;
	      var t1 = -b / a + K; // t1, a is not zero
	
	      var t2 = -K / 2; // t2, t3
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	
	      if (t2 >= 0 && t2 <= 1) {
	        roots[n++] = t2;
	      }
	    } else if (disc > 0) {
	      var discSqrt = mathSqrt(disc);
	      var Y1 = A * b + 1.5 * a * (-B + discSqrt);
	      var Y2 = A * b + 1.5 * a * (-B - discSqrt);
	
	      if (Y1 < 0) {
	        Y1 = -mathPow(-Y1, ONE_THIRD);
	      } else {
	        Y1 = mathPow(Y1, ONE_THIRD);
	      }
	
	      if (Y2 < 0) {
	        Y2 = -mathPow(-Y2, ONE_THIRD);
	      } else {
	        Y2 = mathPow(Y2, ONE_THIRD);
	      }
	
	      var t1 = (-b - (Y1 + Y2)) / (3 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	    } else {
	      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
	      var theta = Math.acos(T) / 3;
	      var ASqrt = mathSqrt(A);
	      var tmp = Math.cos(theta);
	      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
	      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
	      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	
	      if (t2 >= 0 && t2 <= 1) {
	        roots[n++] = t2;
	      }
	
	      if (t3 >= 0 && t3 <= 1) {
	        roots[n++] = t3;
	      }
	    }
	  }
	
	  return n;
	}
	/**
	 * 计算三次贝塞尔方程极限值的位置
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {Array.<number>} extrema
	 * @return {number} 有效数目
	 */
	
	
	function cubicExtrema(p0, p1, p2, p3, extrema) {
	  var b = 6 * p2 - 12 * p1 + 6 * p0;
	  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
	  var c = 3 * p1 - 3 * p0;
	  var n = 0;
	
	  if (isAroundZero(a)) {
	    if (isNotAroundZero(b)) {
	      var t1 = -c / b;
	
	      if (t1 >= 0 && t1 <= 1) {
	        extrema[n++] = t1;
	      }
	    }
	  } else {
	    var disc = b * b - 4 * a * c;
	
	    if (isAroundZero(disc)) {
	      extrema[0] = -b / (2 * a);
	    } else if (disc > 0) {
	      var discSqrt = mathSqrt(disc);
	      var t1 = (-b + discSqrt) / (2 * a);
	      var t2 = (-b - discSqrt) / (2 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        extrema[n++] = t1;
	      }
	
	      if (t2 >= 0 && t2 <= 1) {
	        extrema[n++] = t2;
	      }
	    }
	  }
	
	  return n;
	}
	/**
	 * 细分三次贝塞尔曲线
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} t
	 * @param  {Array.<number>} out
	 */
	
	
	function cubicSubdivide(p0, p1, p2, p3, t, out) {
	  var p01 = (p1 - p0) * t + p0;
	  var p12 = (p2 - p1) * t + p1;
	  var p23 = (p3 - p2) * t + p2;
	  var p012 = (p12 - p01) * t + p01;
	  var p123 = (p23 - p12) * t + p12;
	  var p0123 = (p123 - p012) * t + p012; // Seg0
	
	  out[0] = p0;
	  out[1] = p01;
	  out[2] = p012;
	  out[3] = p0123; // Seg1
	
	  out[4] = p0123;
	  out[5] = p123;
	  out[6] = p23;
	  out[7] = p3;
	}
	/**
	 * 投射点到三次贝塞尔曲线上，返回投射距离。
	 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {number} x2
	 * @param {number} y2
	 * @param {number} x3
	 * @param {number} y3
	 * @param {number} x
	 * @param {number} y
	 * @param {Array.<number>} [out] 投射点
	 * @return {number}
	 */
	
	
	function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
	  // http://pomax.github.io/bezierinfo/#projections
	  var t;
	  var interval = 0.005;
	  var d = Infinity;
	  var prev;
	  var next;
	  var d1;
	  var d2;
	  _v0[0] = x;
	  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值
	  // PENDING
	
	  for (var _t = 0; _t < 1; _t += 0.05) {
	    _v1[0] = cubicAt(x0, x1, x2, x3, _t);
	    _v1[1] = cubicAt(y0, y1, y2, y3, _t);
	    d1 = v2DistSquare(_v0, _v1);
	
	    if (d1 < d) {
	      t = _t;
	      d = d1;
	    }
	  }
	
	  d = Infinity; // At most 32 iteration
	
	  for (var i = 0; i < 32; i++) {
	    if (interval < EPSILON_NUMERIC) {
	      break;
	    }
	
	    prev = t - interval;
	    next = t + interval; // t - interval
	
	    _v1[0] = cubicAt(x0, x1, x2, x3, prev);
	    _v1[1] = cubicAt(y0, y1, y2, y3, prev);
	    d1 = v2DistSquare(_v1, _v0);
	
	    if (prev >= 0 && d1 < d) {
	      t = prev;
	      d = d1;
	    } else {
	      // t + interval
	      _v2[0] = cubicAt(x0, x1, x2, x3, next);
	      _v2[1] = cubicAt(y0, y1, y2, y3, next);
	      d2 = v2DistSquare(_v2, _v0);
	
	      if (next <= 1 && d2 < d) {
	        t = next;
	        d = d2;
	      } else {
	        interval *= 0.5;
	      }
	    }
	  } // t
	
	
	  if (out) {
	    out[0] = cubicAt(x0, x1, x2, x3, t);
	    out[1] = cubicAt(y0, y1, y2, y3, t);
	  } // console.log(interval, i);
	
	
	  return mathSqrt(d);
	}
	/**
	 * 计算二次方贝塞尔值
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} t
	 * @return {number}
	 */
	
	
	function quadraticAt(p0, p1, p2, t) {
	  var onet = 1 - t;
	  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
	}
	/**
	 * 计算二次方贝塞尔导数值
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} t
	 * @return {number}
	 */
	
	
	function quadraticDerivativeAt(p0, p1, p2, t) {
	  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
	}
	/**
	 * 计算二次方贝塞尔方程根
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} t
	 * @param  {Array.<number>} roots
	 * @return {number} 有效根数目
	 */
	
	
	function quadraticRootAt(p0, p1, p2, val, roots) {
	  var a = p0 - 2 * p1 + p2;
	  var b = 2 * (p1 - p0);
	  var c = p0 - val;
	  var n = 0;
	
	  if (isAroundZero(a)) {
	    if (isNotAroundZero(b)) {
	      var t1 = -c / b;
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	    }
	  } else {
	    var disc = b * b - 4 * a * c;
	
	    if (isAroundZero(disc)) {
	      var t1 = -b / (2 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	    } else if (disc > 0) {
	      var discSqrt = mathSqrt(disc);
	      var t1 = (-b + discSqrt) / (2 * a);
	      var t2 = (-b - discSqrt) / (2 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	
	      if (t2 >= 0 && t2 <= 1) {
	        roots[n++] = t2;
	      }
	    }
	  }
	
	  return n;
	}
	/**
	 * 计算二次贝塞尔方程极限值
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @return {number}
	 */
	
	
	function quadraticExtremum(p0, p1, p2) {
	  var divider = p0 + p2 - 2 * p1;
	
	  if (divider === 0) {
	    // p1 is center of p0 and p2
	    return 0.5;
	  } else {
	    return (p0 - p1) / divider;
	  }
	}
	/**
	 * 细分二次贝塞尔曲线
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} t
	 * @param  {Array.<number>} out
	 */
	
	
	function quadraticSubdivide(p0, p1, p2, t, out) {
	  var p01 = (p1 - p0) * t + p0;
	  var p12 = (p2 - p1) * t + p1;
	  var p012 = (p12 - p01) * t + p01; // Seg0
	
	  out[0] = p0;
	  out[1] = p01;
	  out[2] = p012; // Seg1
	
	  out[3] = p012;
	  out[4] = p12;
	  out[5] = p2;
	}
	/**
	 * 投射点到二次贝塞尔曲线上，返回投射距离。
	 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {number} x2
	 * @param {number} y2
	 * @param {number} x
	 * @param {number} y
	 * @param {Array.<number>} out 投射点
	 * @return {number}
	 */
	
	
	function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
	  // http://pomax.github.io/bezierinfo/#projections
	  var t;
	  var interval = 0.005;
	  var d = Infinity;
	  _v0[0] = x;
	  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值
	  // PENDING
	
	  for (var _t = 0; _t < 1; _t += 0.05) {
	    _v1[0] = quadraticAt(x0, x1, x2, _t);
	    _v1[1] = quadraticAt(y0, y1, y2, _t);
	    var d1 = v2DistSquare(_v0, _v1);
	
	    if (d1 < d) {
	      t = _t;
	      d = d1;
	    }
	  }
	
	  d = Infinity; // At most 32 iteration
	
	  for (var i = 0; i < 32; i++) {
	    if (interval < EPSILON_NUMERIC) {
	      break;
	    }
	
	    var prev = t - interval;
	    var next = t + interval; // t - interval
	
	    _v1[0] = quadraticAt(x0, x1, x2, prev);
	    _v1[1] = quadraticAt(y0, y1, y2, prev);
	    var d1 = v2DistSquare(_v1, _v0);
	
	    if (prev >= 0 && d1 < d) {
	      t = prev;
	      d = d1;
	    } else {
	      // t + interval
	      _v2[0] = quadraticAt(x0, x1, x2, next);
	      _v2[1] = quadraticAt(y0, y1, y2, next);
	      var d2 = v2DistSquare(_v2, _v0);
	
	      if (next <= 1 && d2 < d) {
	        t = next;
	        d = d2;
	      } else {
	        interval *= 0.5;
	      }
	    }
	  } // t
	
	
	  if (out) {
	    out[0] = quadraticAt(x0, x1, x2, t);
	    out[1] = quadraticAt(y0, y1, y2, t);
	  } // console.log(interval, i);
	
	
	  return mathSqrt(d);
	}
	
	exports.cubicAt = cubicAt;
	exports.cubicDerivativeAt = cubicDerivativeAt;
	exports.cubicRootAt = cubicRootAt;
	exports.cubicExtrema = cubicExtrema;
	exports.cubicSubdivide = cubicSubdivide;
	exports.cubicProjectPoint = cubicProjectPoint;
	exports.quadraticAt = quadraticAt;
	exports.quadraticDerivativeAt = quadraticDerivativeAt;
	exports.quadraticRootAt = quadraticRootAt;
	exports.quadraticExtremum = quadraticExtremum;
	exports.quadraticSubdivide = quadraticSubdivide;
	exports.quadraticProjectPoint = quadraticProjectPoint;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	var vec2 = __webpack_require__(15);
	
	var curve = __webpack_require__(31);
	
	/**
	 * @author Yi Shen(https://github.com/pissang)
	 */
	var mathMin = Math.min;
	var mathMax = Math.max;
	var mathSin = Math.sin;
	var mathCos = Math.cos;
	var PI2 = Math.PI * 2;
	var start = vec2.create();
	var end = vec2.create();
	var extremity = vec2.create();
	/**
	 * 从顶点数组中计算出最小包围盒，写入`min`和`max`中
	 * @module zrender/core/bbox
	 * @param {Array<Object>} points 顶点数组
	 * @param {number} min
	 * @param {number} max
	 */
	
	function fromPoints(points, min, max) {
	  if (points.length === 0) {
	    return;
	  }
	
	  var p = points[0];
	  var left = p[0];
	  var right = p[0];
	  var top = p[1];
	  var bottom = p[1];
	  var i;
	
	  for (i = 1; i < points.length; i++) {
	    p = points[i];
	    left = mathMin(left, p[0]);
	    right = mathMax(right, p[0]);
	    top = mathMin(top, p[1]);
	    bottom = mathMax(bottom, p[1]);
	  }
	
	  min[0] = left;
	  min[1] = top;
	  max[0] = right;
	  max[1] = bottom;
	}
	/**
	 * @memberOf module:zrender/core/bbox
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {Array.<number>} min
	 * @param {Array.<number>} max
	 */
	
	
	function fromLine(x0, y0, x1, y1, min, max) {
	  min[0] = mathMin(x0, x1);
	  min[1] = mathMin(y0, y1);
	  max[0] = mathMax(x0, x1);
	  max[1] = mathMax(y0, y1);
	}
	
	var xDim = [];
	var yDim = [];
	/**
	 * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
	 * @memberOf module:zrender/core/bbox
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {number} x2
	 * @param {number} y2
	 * @param {number} x3
	 * @param {number} y3
	 * @param {Array.<number>} min
	 * @param {Array.<number>} max
	 */
	
	function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {
	  var cubicExtrema = curve.cubicExtrema;
	  var cubicAt = curve.cubicAt;
	  var i;
	  var n = cubicExtrema(x0, x1, x2, x3, xDim);
	  min[0] = Infinity;
	  min[1] = Infinity;
	  max[0] = -Infinity;
	  max[1] = -Infinity;
	
	  for (i = 0; i < n; i++) {
	    var x = cubicAt(x0, x1, x2, x3, xDim[i]);
	    min[0] = mathMin(x, min[0]);
	    max[0] = mathMax(x, max[0]);
	  }
	
	  n = cubicExtrema(y0, y1, y2, y3, yDim);
	
	  for (i = 0; i < n; i++) {
	    var y = cubicAt(y0, y1, y2, y3, yDim[i]);
	    min[1] = mathMin(y, min[1]);
	    max[1] = mathMax(y, max[1]);
	  }
	
	  min[0] = mathMin(x0, min[0]);
	  max[0] = mathMax(x0, max[0]);
	  min[0] = mathMin(x3, min[0]);
	  max[0] = mathMax(x3, max[0]);
	  min[1] = mathMin(y0, min[1]);
	  max[1] = mathMax(y0, max[1]);
	  min[1] = mathMin(y3, min[1]);
	  max[1] = mathMax(y3, max[1]);
	}
	/**
	 * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
	 * @memberOf module:zrender/core/bbox
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {number} x2
	 * @param {number} y2
	 * @param {Array.<number>} min
	 * @param {Array.<number>} max
	 */
	
	
	function fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {
	  var quadraticExtremum = curve.quadraticExtremum;
	  var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero
	
	  var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);
	  var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);
	  var x = quadraticAt(x0, x1, x2, tx);
	  var y = quadraticAt(y0, y1, y2, ty);
	  min[0] = mathMin(x0, x2, x);
	  min[1] = mathMin(y0, y2, y);
	  max[0] = mathMax(x0, x2, x);
	  max[1] = mathMax(y0, y2, y);
	}
	/**
	 * 从圆弧中计算出最小包围盒，写入`min`和`max`中
	 * @method
	 * @memberOf module:zrender/core/bbox
	 * @param {number} x
	 * @param {number} y
	 * @param {number} rx
	 * @param {number} ry
	 * @param {number} startAngle
	 * @param {number} endAngle
	 * @param {number} anticlockwise
	 * @param {Array.<number>} min
	 * @param {Array.<number>} max
	 */
	
	
	function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {
	  var vec2Min = vec2.min;
	  var vec2Max = vec2.max;
	  var diff = Math.abs(startAngle - endAngle);
	
	  if (diff % PI2 < 1e-4 && diff > 1e-4) {
	    // Is a circle
	    min[0] = x - rx;
	    min[1] = y - ry;
	    max[0] = x + rx;
	    max[1] = y + ry;
	    return;
	  }
	
	  start[0] = mathCos(startAngle) * rx + x;
	  start[1] = mathSin(startAngle) * ry + y;
	  end[0] = mathCos(endAngle) * rx + x;
	  end[1] = mathSin(endAngle) * ry + y;
	  vec2Min(min, start, end);
	  vec2Max(max, start, end); // Thresh to [0, Math.PI * 2]
	
	  startAngle = startAngle % PI2;
	
	  if (startAngle < 0) {
	    startAngle = startAngle + PI2;
	  }
	
	  endAngle = endAngle % PI2;
	
	  if (endAngle < 0) {
	    endAngle = endAngle + PI2;
	  }
	
	  if (startAngle > endAngle && !anticlockwise) {
	    endAngle += PI2;
	  } else if (startAngle < endAngle && anticlockwise) {
	    startAngle += PI2;
	  }
	
	  if (anticlockwise) {
	    var tmp = endAngle;
	    endAngle = startAngle;
	    startAngle = tmp;
	  } // var number = 0;
	  // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;
	
	
	  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
	    if (angle > startAngle) {
	      extremity[0] = mathCos(angle) * rx + x;
	      extremity[1] = mathSin(angle) * ry + y;
	      vec2Min(min, extremity, min);
	      vec2Max(max, extremity, max);
	    }
	  }
	}
	
	exports.fromPoints = fromPoints;
	exports.fromLine = fromLine;
	exports.fromCubic = fromCubic;
	exports.fromQuadratic = fromQuadratic;
	exports.fromArc = fromArc;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	var PathProxy = __webpack_require__(30);
	
	var line = __webpack_require__(34);
	
	var cubic = __webpack_require__(35);
	
	var quadratic = __webpack_require__(36);
	
	var arc = __webpack_require__(37);
	
	var _util = __webpack_require__(38);
	
	var normalizeRadian = _util.normalizeRadian;
	
	var curve = __webpack_require__(31);
	
	var windingLine = __webpack_require__(39);
	
	var CMD = PathProxy.CMD;
	var PI2 = Math.PI * 2;
	var EPSILON = 1e-4;
	
	function isAroundEqual(a, b) {
	  return Math.abs(a - b) < EPSILON;
	} // 临时数组
	
	
	var roots = [-1, -1, -1];
	var extrema = [-1, -1];
	
	function swapExtrema() {
	  var tmp = extrema[0];
	  extrema[0] = extrema[1];
	  extrema[1] = tmp;
	}
	
	function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
	  // Quick reject
	  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
	    return 0;
	  }
	
	  var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
	
	  if (nRoots === 0) {
	    return 0;
	  } else {
	    var w = 0;
	    var nExtrema = -1;
	    var y0_, y1_;
	
	    for (var i = 0; i < nRoots; i++) {
	      var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon
	
	      var unit = t === 0 || t === 1 ? 0.5 : 1;
	      var x_ = curve.cubicAt(x0, x1, x2, x3, t);
	
	      if (x_ < x) {
	        // Quick reject
	        continue;
	      }
	
	      if (nExtrema < 0) {
	        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
	
	        if (extrema[1] < extrema[0] && nExtrema > 1) {
	          swapExtrema();
	        }
	
	        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
	
	        if (nExtrema > 1) {
	          y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
	        }
	      }
	
	      if (nExtrema == 2) {
	        // 分成三段单调函数
	        if (t < extrema[0]) {
	          w += y0_ < y0 ? unit : -unit;
	        } else if (t < extrema[1]) {
	          w += y1_ < y0_ ? unit : -unit;
	        } else {
	          w += y3 < y1_ ? unit : -unit;
	        }
	      } else {
	        // 分成两段单调函数
	        if (t < extrema[0]) {
	          w += y0_ < y0 ? unit : -unit;
	        } else {
	          w += y3 < y0_ ? unit : -unit;
	        }
	      }
	    }
	
	    return w;
	  }
	}
	
	function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
	  // Quick reject
	  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
	    return 0;
	  }
	
	  var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
	
	  if (nRoots === 0) {
	    return 0;
	  } else {
	    var t = curve.quadraticExtremum(y0, y1, y2);
	
	    if (t >= 0 && t <= 1) {
	      var w = 0;
	      var y_ = curve.quadraticAt(y0, y1, y2, t);
	
	      for (var i = 0; i < nRoots; i++) {
	        // Remove one endpoint.
	        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
	        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
	
	        if (x_ < x) {
	          // Quick reject
	          continue;
	        }
	
	        if (roots[i] < t) {
	          w += y_ < y0 ? unit : -unit;
	        } else {
	          w += y2 < y_ ? unit : -unit;
	        }
	      }
	
	      return w;
	    } else {
	      // Remove one endpoint.
	      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
	      var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
	
	      if (x_ < x) {
	        // Quick reject
	        return 0;
	      }
	
	      return y2 < y0 ? unit : -unit;
	    }
	  }
	} // TODO
	// Arc 旋转
	
	
	function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
	  y -= cy;
	
	  if (y > r || y < -r) {
	    return 0;
	  }
	
	  var tmp = Math.sqrt(r * r - y * y);
	  roots[0] = -tmp;
	  roots[1] = tmp;
	  var diff = Math.abs(startAngle - endAngle);
	
	  if (diff < 1e-4) {
	    return 0;
	  }
	
	  if (diff % PI2 < 1e-4) {
	    // Is a circle
	    startAngle = 0;
	    endAngle = PI2;
	    var dir = anticlockwise ? 1 : -1;
	
	    if (x >= roots[0] + cx && x <= roots[1] + cx) {
	      return dir;
	    } else {
	      return 0;
	    }
	  }
	
	  if (anticlockwise) {
	    var tmp = startAngle;
	    startAngle = normalizeRadian(endAngle);
	    endAngle = normalizeRadian(tmp);
	  } else {
	    startAngle = normalizeRadian(startAngle);
	    endAngle = normalizeRadian(endAngle);
	  }
	
	  if (startAngle > endAngle) {
	    endAngle += PI2;
	  }
	
	  var w = 0;
	
	  for (var i = 0; i < 2; i++) {
	    var x_ = roots[i];
	
	    if (x_ + cx > x) {
	      var angle = Math.atan2(y, x_);
	      var dir = anticlockwise ? 1 : -1;
	
	      if (angle < 0) {
	        angle = PI2 + angle;
	      }
	
	      if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {
	        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
	          dir = -dir;
	        }
	
	        w += dir;
	      }
	    }
	  }
	
	  return w;
	}
	
	function containPath(data, lineWidth, isStroke, x, y) {
	  var w = 0;
	  var xi = 0;
	  var yi = 0;
	  var x0 = 0;
	  var y0 = 0;
	
	  for (var i = 0; i < data.length;) {
	    var cmd = data[i++]; // Begin a new subpath
	
	    if (cmd === CMD.M && i > 1) {
	      // Close previous subpath
	      if (!isStroke) {
	        w += windingLine(xi, yi, x0, y0, x, y);
	      } // 如果被任何一个 subpath 包含
	      // if (w !== 0) {
	      //     return true;
	      // }
	
	    }
	
	    if (i == 1) {
	      // 如果第一个命令是 L, C, Q
	      // 则 previous point 同绘制命令的第一个 point
	      //
	      // 第一个命令为 Arc 的情况下会在后面特殊处理
	      xi = data[i];
	      yi = data[i + 1];
	      x0 = xi;
	      y0 = yi;
	    }
	
	    switch (cmd) {
	      case CMD.M:
	        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	        // 在 closePath 的时候使用
	        x0 = data[i++];
	        y0 = data[i++];
	        xi = x0;
	        yi = y0;
	        break;
	
	      case CMD.L:
	        if (isStroke) {
	          if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN
	          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
	        }
	
	        xi = data[i++];
	        yi = data[i++];
	        break;
	
	      case CMD.C:
	        if (isStroke) {
	          if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
	        }
	
	        xi = data[i++];
	        yi = data[i++];
	        break;
	
	      case CMD.Q:
	        if (isStroke) {
	          if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
	        }
	
	        xi = data[i++];
	        yi = data[i++];
	        break;
	
	      case CMD.A:
	        // TODO Arc 判断的开销比较大
	        var cx = data[i++];
	        var cy = data[i++];
	        var rx = data[i++];
	        var ry = data[i++];
	        var theta = data[i++];
	        var dTheta = data[i++]; // TODO Arc 旋转
	
	        var psi = data[i++];
	        var anticlockwise = 1 - data[i++];
	        var x1 = Math.cos(theta) * rx + cx;
	        var y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令
	
	        if (i > 1) {
	          w += windingLine(xi, yi, x1, y1, x, y);
	        } else {
	          // 第一个命令起点还未定义
	          x0 = x1;
	          y0 = y1;
	        } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放
	
	
	        var _x = (x - cx) * ry / rx + cx;
	
	        if (isStroke) {
	          if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
	            return true;
	          }
	        } else {
	          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
	        }
	
	        xi = Math.cos(theta + dTheta) * rx + cx;
	        yi = Math.sin(theta + dTheta) * ry + cy;
	        break;
	
	      case CMD.R:
	        x0 = xi = data[i++];
	        y0 = yi = data[i++];
	        var width = data[i++];
	        var height = data[i++];
	        var x1 = x0 + width;
	        var y1 = y0 + height;
	
	        if (isStroke) {
	          if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          // FIXME Clockwise ?
	          w += windingLine(x1, y0, x1, y1, x, y);
	          w += windingLine(x0, y1, x0, y0, x, y);
	        }
	
	        break;
	
	      case CMD.Z:
	        if (isStroke) {
	          if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          // Close a subpath
	          w += windingLine(xi, yi, x0, y0, x, y); // 如果被任何一个 subpath 包含
	          // FIXME subpaths may overlap
	          // if (w !== 0) {
	          //     return true;
	          // }
	        }
	
	        xi = x0;
	        yi = y0;
	        break;
	    }
	  }
	
	  if (!isStroke && !isAroundEqual(yi, y0)) {
	    w += windingLine(xi, yi, x0, y0, x, y) || 0;
	  }
	
	  return w !== 0;
	}
	
	function contain(pathData, x, y) {
	  return containPath(pathData, 0, false, x, y);
	}
	
	function containStroke(pathData, lineWidth, x, y) {
	  return containPath(pathData, lineWidth, true, x, y);
	}
	
	exports.contain = contain;
	exports.containStroke = containStroke;

/***/ }),
/* 34 */
/***/ (function(module, exports) {

	/**
	 * 线段包含判断
	 * @param  {number}  x0
	 * @param  {number}  y0
	 * @param  {number}  x1
	 * @param  {number}  y1
	 * @param  {number}  lineWidth
	 * @param  {number}  x
	 * @param  {number}  y
	 * @return {boolean}
	 */
	function containStroke(x0, y0, x1, y1, lineWidth, x, y) {
	  if (lineWidth === 0) {
	    return false;
	  }
	
	  var _l = lineWidth;
	  var _a = 0;
	  var _b = x0; // Quick reject
	
	  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
	    return false;
	  }
	
	  if (x0 !== x1) {
	    _a = (y0 - y1) / (x0 - x1);
	    _b = (x0 * y1 - x1 * y0) / (x0 - x1);
	  } else {
	    return Math.abs(x - x0) <= _l / 2;
	  }
	
	  var tmp = _a * x - y + _b;
	
	  var _s = tmp * tmp / (_a * _a + 1);
	
	  return _s <= _l / 2 * _l / 2;
	}
	
	exports.containStroke = containStroke;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	var curve = __webpack_require__(31);
	
	/**
	 * 三次贝塞尔曲线描边包含判断
	 * @param  {number}  x0
	 * @param  {number}  y0
	 * @param  {number}  x1
	 * @param  {number}  y1
	 * @param  {number}  x2
	 * @param  {number}  y2
	 * @param  {number}  x3
	 * @param  {number}  y3
	 * @param  {number}  lineWidth
	 * @param  {number}  x
	 * @param  {number}  y
	 * @return {boolean}
	 */
	function containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
	  if (lineWidth === 0) {
	    return false;
	  }
	
	  var _l = lineWidth; // Quick reject
	
	  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
	    return false;
	  }
	
	  var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
	  return d <= _l / 2;
	}
	
	exports.containStroke = containStroke;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	var _curve = __webpack_require__(31);
	
	var quadraticProjectPoint = _curve.quadraticProjectPoint;
	
	/**
	 * 二次贝塞尔曲线描边包含判断
	 * @param  {number}  x0
	 * @param  {number}  y0
	 * @param  {number}  x1
	 * @param  {number}  y1
	 * @param  {number}  x2
	 * @param  {number}  y2
	 * @param  {number}  lineWidth
	 * @param  {number}  x
	 * @param  {number}  y
	 * @return {boolean}
	 */
	function containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
	  if (lineWidth === 0) {
	    return false;
	  }
	
	  var _l = lineWidth; // Quick reject
	
	  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
	    return false;
	  }
	
	  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
	  return d <= _l / 2;
	}
	
	exports.containStroke = containStroke;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	var _util = __webpack_require__(38);
	
	var normalizeRadian = _util.normalizeRadian;
	var PI2 = Math.PI * 2;
	/**
	 * 圆弧描边包含判断
	 * @param  {number}  cx
	 * @param  {number}  cy
	 * @param  {number}  r
	 * @param  {number}  startAngle
	 * @param  {number}  endAngle
	 * @param  {boolean}  anticlockwise
	 * @param  {number} lineWidth
	 * @param  {number}  x
	 * @param  {number}  y
	 * @return {Boolean}
	 */
	
	function containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
	  if (lineWidth === 0) {
	    return false;
	  }
	
	  var _l = lineWidth;
	  x -= cx;
	  y -= cy;
	  var d = Math.sqrt(x * x + y * y);
	
	  if (d - _l > r || d + _l < r) {
	    return false;
	  }
	
	  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {
	    // Is a circle
	    return true;
	  }
	
	  if (anticlockwise) {
	    var tmp = startAngle;
	    startAngle = normalizeRadian(endAngle);
	    endAngle = normalizeRadian(tmp);
	  } else {
	    startAngle = normalizeRadian(startAngle);
	    endAngle = normalizeRadian(endAngle);
	  }
	
	  if (startAngle > endAngle) {
	    endAngle += PI2;
	  }
	
	  var angle = Math.atan2(y, x);
	
	  if (angle < 0) {
	    angle += PI2;
	  }
	
	  return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;
	}
	
	exports.containStroke = containStroke;

/***/ }),
/* 38 */
/***/ (function(module, exports) {

	var PI2 = Math.PI * 2;
	
	function normalizeRadian(angle) {
	  angle %= PI2;
	
	  if (angle < 0) {
	    angle += PI2;
	  }
	
	  return angle;
	}
	
	exports.normalizeRadian = normalizeRadian;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

	function windingLine(x0, y0, x1, y1, x, y) {
	  if (y > y0 && y > y1 || y < y0 && y < y1) {
	    return 0;
	  } // Ignore horizontal line
	
	
	  if (y1 === y0) {
	    return 0;
	  }
	
	  var dir = y1 < y0 ? 1 : -1;
	  var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon
	
	  if (t === 1 || t === 0) {
	    dir = y1 < y0 ? 0.5 : -0.5;
	  }
	
	  var x_ = t * (x1 - x0) + x0;
	  return x_ > x ? dir : 0;
	}
	
	module.exports = windingLine;

/***/ }),
/* 40 */
/***/ (function(module, exports) {

	var Pattern = function (image, repeat) {
	  // Should do nothing more in this constructor. Because gradient can be
	  // declard by `color: {image: ...}`, where this constructor will not be called.
	  this.image = image;
	  this.repeat = repeat; // Can be cloned
	
	  this.type = 'pattern';
	};
	
	Pattern.prototype.getCanvasPattern = function (ctx) {
	  return ctx.createPattern(this.image, this.repeat || 'repeat');
	};
	
	var _default = Pattern;
	module.exports = _default;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	var PathProxy = __webpack_require__(30);
	
	var _vector = __webpack_require__(15);
	
	var v2ApplyTransform = _vector.applyTransform;
	var CMD = PathProxy.CMD;
	var points = [[], [], []];
	var mathSqrt = Math.sqrt;
	var mathAtan2 = Math.atan2;
	
	function _default(path, m) {
	  var data = path.data;
	  var cmd;
	  var nPoint;
	  var i;
	  var j;
	  var k;
	  var p;
	  var M = CMD.M;
	  var C = CMD.C;
	  var L = CMD.L;
	  var R = CMD.R;
	  var A = CMD.A;
	  var Q = CMD.Q;
	
	  for (i = 0, j = 0; i < data.length;) {
	    cmd = data[i++];
	    j = i;
	    nPoint = 0;
	
	    switch (cmd) {
	      case M:
	        nPoint = 1;
	        break;
	
	      case L:
	        nPoint = 1;
	        break;
	
	      case C:
	        nPoint = 3;
	        break;
	
	      case Q:
	        nPoint = 2;
	        break;
	
	      case A:
	        var x = m[4];
	        var y = m[5];
	        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);
	        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);
	        var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx
	
	        data[i] *= sx;
	        data[i++] += x; // cy
	
	        data[i] *= sy;
	        data[i++] += y; // Scale rx and ry
	        // FIXME Assume psi is 0 here
	
	        data[i++] *= sx;
	        data[i++] *= sy; // Start angle
	
	        data[i++] += angle; // end angle
	
	        data[i++] += angle; // FIXME psi
	
	        i += 2;
	        j = i;
	        break;
	
	      case R:
	        // x0, y0
	        p[0] = data[i++];
	        p[1] = data[i++];
	        v2ApplyTransform(p, p, m);
	        data[j++] = p[0];
	        data[j++] = p[1]; // x1, y1
	
	        p[0] += data[i++];
	        p[1] += data[i++];
	        v2ApplyTransform(p, p, m);
	        data[j++] = p[0];
	        data[j++] = p[1];
	    }
	
	    for (k = 0; k < nPoint; k++) {
	      var p = points[k];
	      p[0] = data[i++];
	      p[1] = data[i++];
	      v2ApplyTransform(p, p, m); // Write back
	
	      data[j++] = p[0];
	      data[j++] = p[1];
	    }
	  }
	}
	
	module.exports = _default;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

	/**
	 * @param {Array.<Object>} colorStops
	 */
	var Gradient = function (colorStops) {
	  this.colorStops = colorStops || [];
	};
	
	Gradient.prototype = {
	  constructor: Gradient,
	  addColorStop: function (offset, color) {
	    this.colorStops.push({
	      offset: offset,
	      color: color
	    });
	  }
	};
	var _default = Gradient;
	module.exports = _default;

/***/ }),
/* 43 */
/***/ (function(module, exports) {

	// TODO Draggable for group
	// FIXME Draggable on element which has parent rotation or scale
	function Draggable() {
	  this.on('mousedown', this._dragStart, this);
	  this.on('mousemove', this._drag, this);
	  this.on('mouseup', this._dragEnd, this);
	  this.on('globalout', this._dragEnd, this); // this._dropTarget = null;
	  // this._draggingTarget = null;
	  // this._x = 0;
	  // this._y = 0;
	}
	
	Draggable.prototype = {
	  constructor: Draggable,
	  _dragStart: function (e) {
	    var draggingTarget = e.target;
	
	    if (draggingTarget && draggingTarget.draggable) {
	      this._draggingTarget = draggingTarget;
	      draggingTarget.dragging = true;
	      this._x = e.offsetX;
	      this._y = e.offsetY;
	      this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);
	    }
	  },
	  _drag: function (e) {
	    var draggingTarget = this._draggingTarget;
	
	    if (draggingTarget) {
	      var x = e.offsetX;
	      var y = e.offsetY;
	      var dx = x - this._x;
	      var dy = y - this._y;
	      this._x = x;
	      this._y = y;
	      draggingTarget.drift(dx, dy, e);
	      this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);
	      var dropTarget = this.findHover(x, y, draggingTarget).target;
	      var lastDropTarget = this._dropTarget;
	      this._dropTarget = dropTarget;
	
	      if (draggingTarget !== dropTarget) {
	        if (lastDropTarget && dropTarget !== lastDropTarget) {
	          this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);
	        }
	
	        if (dropTarget && dropTarget !== lastDropTarget) {
	          this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);
	        }
	      }
	    }
	  },
	  _dragEnd: function (e) {
	    var draggingTarget = this._draggingTarget;
	
	    if (draggingTarget) {
	      draggingTarget.dragging = false;
	    }
	
	    this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);
	
	    if (this._dropTarget) {
	      this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);
	    }
	
	    this._draggingTarget = null;
	    this._dropTarget = null;
	  }
	};
	
	function param(target, e) {
	  return {
	    target: target,
	    topTarget: e && e.topTarget
	  };
	}
	
	var _default = Draggable;
	module.exports = _default;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(5);
	
	var Element = __webpack_require__(10);
	
	var BoundingRect = __webpack_require__(27);
	
	/**
	 * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
	 * @module zrender/graphic/Group
	 * @example
	 *     var Group = require('zrender/container/Group');
	 *     var Circle = require('zrender/graphic/shape/Circle');
	 *     var g = new Group();
	 *     g.position[0] = 100;
	 *     g.position[1] = 100;
	 *     g.add(new Circle({
	 *         style: {
	 *             x: 100,
	 *             y: 100,
	 *             r: 20,
	 *         }
	 *     }));
	 *     zr.add(g);
	 */
	
	/**
	 * @alias module:zrender/graphic/Group
	 * @constructor
	 * @extends module:zrender/mixin/Transformable
	 * @extends module:zrender/mixin/Eventful
	 */
	var Group = function (opts) {
	  opts = opts || {};
	  Element.call(this, opts);
	
	  for (var key in opts) {
	    if (opts.hasOwnProperty(key)) {
	      this[key] = opts[key];
	    }
	  }
	
	  this._children = [];
	  this.__storage = null;
	  this.__dirty = true;
	};
	
	Group.prototype = {
	  constructor: Group,
	  isGroup: true,
	
	  /**
	   * @type {string}
	   */
	  type: 'group',
	
	  /**
	   * 所有子孙元素是否响应鼠标事件
	   * @name module:/zrender/container/Group#silent
	   * @type {boolean}
	   * @default false
	   */
	  silent: false,
	
	  /**
	   * @return {Array.<module:zrender/Element>}
	   */
	  children: function () {
	    return this._children.slice();
	  },
	
	  /**
	   * 获取指定 index 的儿子节点
	   * @param  {number} idx
	   * @return {module:zrender/Element}
	   */
	  childAt: function (idx) {
	    return this._children[idx];
	  },
	
	  /**
	   * 获取指定名字的儿子节点
	   * @param  {string} name
	   * @return {module:zrender/Element}
	   */
	  childOfName: function (name) {
	    var children = this._children;
	
	    for (var i = 0; i < children.length; i++) {
	      if (children[i].name === name) {
	        return children[i];
	      }
	    }
	  },
	
	  /**
	   * @return {number}
	   */
	  childCount: function () {
	    return this._children.length;
	  },
	
	  /**
	   * 添加子节点到最后
	   * @param {module:zrender/Element} child
	   */
	  add: function (child) {
	    if (child && child !== this && child.parent !== this) {
	      this._children.push(child);
	
	      this._doAdd(child);
	    }
	
	    return this;
	  },
	
	  /**
	   * 添加子节点在 nextSibling 之前
	   * @param {module:zrender/Element} child
	   * @param {module:zrender/Element} nextSibling
	   */
	  addBefore: function (child, nextSibling) {
	    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {
	      var children = this._children;
	      var idx = children.indexOf(nextSibling);
	
	      if (idx >= 0) {
	        children.splice(idx, 0, child);
	
	        this._doAdd(child);
	      }
	    }
	
	    return this;
	  },
	  _doAdd: function (child) {
	    if (child.parent) {
	      child.parent.remove(child);
	    }
	
	    child.parent = this;
	    var storage = this.__storage;
	    var zr = this.__zr;
	
	    if (storage && storage !== child.__storage) {
	      storage.addToStorage(child);
	
	      if (child instanceof Group) {
	        child.addChildrenToStorage(storage);
	      }
	    }
	
	    zr && zr.refresh();
	  },
	
	  /**
	   * 移除子节点
	   * @param {module:zrender/Element} child
	   */
	  remove: function (child) {
	    var zr = this.__zr;
	    var storage = this.__storage;
	    var children = this._children;
	    var idx = zrUtil.indexOf(children, child);
	
	    if (idx < 0) {
	      return this;
	    }
	
	    children.splice(idx, 1);
	    child.parent = null;
	
	    if (storage) {
	      storage.delFromStorage(child);
	
	      if (child instanceof Group) {
	        child.delChildrenFromStorage(storage);
	      }
	    }
	
	    zr && zr.refresh();
	    return this;
	  },
	
	  /**
	   * 移除所有子节点
	   */
	  removeAll: function () {
	    var children = this._children;
	    var storage = this.__storage;
	    var child;
	    var i;
	
	    for (i = 0; i < children.length; i++) {
	      child = children[i];
	
	      if (storage) {
	        storage.delFromStorage(child);
	
	        if (child instanceof Group) {
	          child.delChildrenFromStorage(storage);
	        }
	      }
	
	      child.parent = null;
	    }
	
	    children.length = 0;
	    return this;
	  },
	
	  /**
	   * 遍历所有子节点
	   * @param  {Function} cb
	   * @param  {}   context
	   */
	  eachChild: function (cb, context) {
	    var children = this._children;
	
	    for (var i = 0; i < children.length; i++) {
	      var child = children[i];
	      cb.call(context, child, i);
	    }
	
	    return this;
	  },
	
	  /**
	   * 深度优先遍历所有子孙节点
	   * @param  {Function} cb
	   * @param  {}   context
	   */
	  traverse: function (cb, context) {
	    for (var i = 0; i < this._children.length; i++) {
	      var child = this._children[i];
	      cb.call(context, child);
	
	      if (child.type === 'group') {
	        child.traverse(cb, context);
	      }
	    }
	
	    return this;
	  },
	  addChildrenToStorage: function (storage) {
	    for (var i = 0; i < this._children.length; i++) {
	      var child = this._children[i];
	      storage.addToStorage(child);
	
	      if (child instanceof Group) {
	        child.addChildrenToStorage(storage);
	      }
	    }
	  },
	  delChildrenFromStorage: function (storage) {
	    for (var i = 0; i < this._children.length; i++) {
	      var child = this._children[i];
	      storage.delFromStorage(child);
	
	      if (child instanceof Group) {
	        child.delChildrenFromStorage(storage);
	      }
	    }
	  },
	  dirty: function () {
	    this.__dirty = true;
	    this.__zr && this.__zr.refresh();
	    return this;
	  },
	
	  /**
	   * @return {module:zrender/core/BoundingRect}
	   */
	  getBoundingRect: function (includeChildren) {
	    // TODO Caching
	    var rect = null;
	    var tmpRect = new BoundingRect(0, 0, 0, 0);
	    var children = includeChildren || this._children;
	    var tmpMat = [];
	
	    for (var i = 0; i < children.length; i++) {
	      var child = children[i];
	
	      if (child.ignore || child.invisible) {
	        continue;
	      }
	
	      var childRect = child.getBoundingRect();
	      var transform = child.getLocalTransform(tmpMat); // TODO
	      // The boundingRect cacluated by transforming original
	      // rect may be bigger than the actual bundingRect when rotation
	      // is used. (Consider a circle rotated aginst its center, where
	      // the actual boundingRect should be the same as that not be
	      // rotated.) But we can not find better approach to calculate
	      // actual boundingRect yet, considering performance.
	
	      if (transform) {
	        tmpRect.copy(childRect);
	        tmpRect.applyTransform(transform);
	        rect = rect || tmpRect.clone();
	        rect.union(tmpRect);
	      } else {
	        rect = rect || childRect.clone();
	        rect.union(childRect);
	      }
	    }
	
	    return rect || tmpRect;
	  }
	};
	zrUtil.inherits(Group, Element);
	var _default = Group;
	module.exports = _default;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	var Displayable = __webpack_require__(8);
	
	var BoundingRect = __webpack_require__(27);
	
	var zrUtil = __webpack_require__(5);
	
	var imageHelper = __webpack_require__(28);
	
	/**
	 * @alias zrender/graphic/Image
	 * @extends module:zrender/graphic/Displayable
	 * @constructor
	 * @param {Object} opts
	 */
	function ZImage(opts) {
	  Displayable.call(this, opts);
	}
	
	ZImage.prototype = {
	  constructor: ZImage,
	  type: 'image',
	  brush: function (ctx, prevEl) {
	    var style = this.style;
	    var src = style.image; // Must bind each time
	
	    style.bind(ctx, this, prevEl);
	    var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);
	
	    if (!image || !imageHelper.isImageReady(image)) {
	      return;
	    } // 图片已经加载完成
	    // if (image.nodeName.toUpperCase() == 'IMG') {
	    //     if (!image.complete) {
	    //         return;
	    //     }
	    // }
	    // Else is canvas
	
	
	    var x = style.x || 0;
	    var y = style.y || 0;
	    var width = style.width;
	    var height = style.height;
	    var aspect = image.width / image.height;
	
	    if (width == null && height != null) {
	      // Keep image/height ratio
	      width = height * aspect;
	    } else if (height == null && width != null) {
	      height = width / aspect;
	    } else if (width == null && height == null) {
	      width = image.width;
	      height = image.height;
	    } // 设置transform
	
	
	    this.setTransform(ctx);
	
	    if (style.sWidth && style.sHeight) {
	      var sx = style.sx || 0;
	      var sy = style.sy || 0;
	      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
	    } else if (style.sx && style.sy) {
	      var sx = style.sx;
	      var sy = style.sy;
	      var sWidth = width - sx;
	      var sHeight = height - sy;
	      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
	    } else {
	      ctx.drawImage(image, x, y, width, height);
	    }
	
	    this.restoreTransform(ctx); // Draw rect text
	
	    if (style.text != null) {
	      this.drawRectText(ctx, this.getBoundingRect());
	    }
	  },
	  getBoundingRect: function () {
	    var style = this.style;
	
	    if (!this._rect) {
	      this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);
	    }
	
	    return this._rect;
	  }
	};
	zrUtil.inherits(ZImage, Displayable);
	var _default = ZImage;
	module.exports = _default;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	var Displayable = __webpack_require__(8);
	
	var zrUtil = __webpack_require__(5);
	
	var textContain = __webpack_require__(26);
	
	var textHelper = __webpack_require__(25);
	
	/**
	 * @alias zrender/graphic/Text
	 * @extends module:zrender/graphic/Displayable
	 * @constructor
	 * @param {Object} opts
	 */
	var Text = function (opts) {
	  // jshint ignore:line
	  Displayable.call(this, opts);
	};
	
	Text.prototype = {
	  constructor: Text,
	  type: 'text',
	  brush: function (ctx, prevEl) {
	    var style = this.style; // Optimize, avoid normalize every time.
	
	    this.__dirty && textHelper.normalizeTextStyle(style, true); // Use props with prefix 'text'.
	
	    style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;
	    var text = style.text; // Convert to string
	
	    text != null && (text += ''); // Always bind style
	
	    style.bind(ctx, this, prevEl);
	
	    if (!textHelper.needDrawText(text, style)) {
	      return;
	    }
	
	    this.setTransform(ctx);
	    textHelper.renderText(this, ctx, text, style);
	    this.restoreTransform(ctx);
	  },
	  getBoundingRect: function () {
	    var style = this.style; // Optimize, avoid normalize every time.
	
	    this.__dirty && textHelper.normalizeTextStyle(style, true);
	
	    if (!this._rect) {
	      var text = style.text;
	      text != null ? text += '' : text = '';
	      var rect = textContain.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.rich);
	      rect.x += style.x || 0;
	      rect.y += style.y || 0;
	
	      if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {
	        var w = style.textStrokeWidth;
	        rect.x -= w / 2;
	        rect.y -= w / 2;
	        rect.width += w;
	        rect.height += w;
	      }
	
	      this._rect = rect;
	    }
	
	    return this._rect;
	  }
	};
	zrUtil.inherits(Text, Displayable);
	var _default = Text;
	module.exports = _default;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(7);
	
	/**
	 * 圆形
	 * @module zrender/shape/Circle
	 */
	var _default = Path.extend({
	  type: 'circle',
	  shape: {
	    cx: 0,
	    cy: 0,
	    r: 0
	  },
	  buildPath: function (ctx, shape, inBundle) {
	    // Better stroking in ShapeBundle
	    // Always do it may have performence issue ( fill may be 2x more cost)
	    if (inBundle) {
	      ctx.moveTo(shape.cx + shape.r, shape.cy);
	    } // else {
	    //     if (ctx.allocate && !ctx.data.length) {
	    //         ctx.allocate(ctx.CMD_MEM_SIZE.A);
	    //     }
	    // }
	    // Better stroking in ShapeBundle
	    // ctx.moveTo(shape.cx + shape.r, shape.cy);
	
	
	    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(7);
	
	var fixClipWithShadow = __webpack_require__(49);
	
	/**
	 * 扇形
	 * @module zrender/graphic/shape/Sector
	 */
	var _default = Path.extend({
	  type: 'sector',
	  shape: {
	    cx: 0,
	    cy: 0,
	    r0: 0,
	    r: 0,
	    startAngle: 0,
	    endAngle: Math.PI * 2,
	    clockwise: true
	  },
	  brush: fixClipWithShadow(Path.prototype.brush),
	  buildPath: function (ctx, shape) {
	    var x = shape.cx;
	    var y = shape.cy;
	    var r0 = Math.max(shape.r0 || 0, 0);
	    var r = Math.max(shape.r, 0);
	    var startAngle = shape.startAngle;
	    var endAngle = shape.endAngle;
	    var clockwise = shape.clockwise;
	    var unitX = Math.cos(startAngle);
	    var unitY = Math.sin(startAngle);
	    ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
	    ctx.lineTo(unitX * r + x, unitY * r + y);
	    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	    ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);
	
	    if (r0 !== 0) {
	      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
	    }
	
	    ctx.closePath();
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	var env = __webpack_require__(50);
	
	// Fix weird bug in some version of IE11 (like 11.0.9600.178**),
	// where exception "unexpected call to method or property access"
	// might be thrown when calling ctx.fill or ctx.stroke after a path
	// whose area size is zero is drawn and ctx.clip() is called and
	// shadowBlur is set. See #4572, #3112, #5777.
	// (e.g.,
	//  ctx.moveTo(10, 10);
	//  ctx.lineTo(20, 10);
	//  ctx.closePath();
	//  ctx.clip();
	//  ctx.shadowBlur = 10;
	//  ...
	//  ctx.fill();
	// )
	var shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];
	
	function _default(orignalBrush) {
	  // version string can be: '11.0'
	  return env.browser.ie && env.browser.version >= 11 ? function () {
	    var clipPaths = this.__clipPaths;
	    var style = this.style;
	    var modified;
	
	    if (clipPaths) {
	      for (var i = 0; i < clipPaths.length; i++) {
	        var clipPath = clipPaths[i];
	        var shape = clipPath && clipPath.shape;
	        var type = clipPath && clipPath.type;
	
	        if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {
	          for (var j = 0; j < shadowTemp.length; j++) {
	            // It is save to put shadowTemp static, because shadowTemp
	            // will be all modified each item brush called.
	            shadowTemp[j][2] = style[shadowTemp[j][0]];
	            style[shadowTemp[j][0]] = shadowTemp[j][1];
	          }
	
	          modified = true;
	          break;
	        }
	      }
	    }
	
	    orignalBrush.apply(this, arguments);
	
	    if (modified) {
	      for (var j = 0; j < shadowTemp.length; j++) {
	        style[shadowTemp[j][0]] = shadowTemp[j][2];
	      }
	    }
	  } : orignalBrush;
	}
	
	module.exports = _default;

/***/ }),
/* 50 */
/***/ (function(module, exports) {

	/**
	 * echarts设备环境识别
	 *
	 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
	 * @author firede[firede@firede.us]
	 * @desc thanks zepto.
	 */
	var env = {};
	
	if (typeof navigator === 'undefined') {
	  // In node
	  env = {
	    browser: {},
	    os: {},
	    node: true,
	    // Assume canvas is supported
	    canvasSupported: true,
	    svgSupported: true
	  };
	} else {
	  env = detect(navigator.userAgent);
	}
	
	var _default = env; // Zepto.js
	// (c) 2010-2013 Thomas Fuchs
	// Zepto.js may be freely distributed under the MIT license.
	
	function detect(ua) {
	  var os = {};
	  var browser = {}; // var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
	  // var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
	  // var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
	  // var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
	  // var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
	  // var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
	  // var touchpad = webos && ua.match(/TouchPad/);
	  // var kindle = ua.match(/Kindle\/([\d.]+)/);
	  // var silk = ua.match(/Silk\/([\d._]+)/);
	  // var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
	  // var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
	  // var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
	  // var playbook = ua.match(/PlayBook/);
	  // var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);
	
	  var firefox = ua.match(/Firefox\/([\d.]+)/); // var safari = webkit && ua.match(/Mobile\//) && !chrome;
	  // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;
	
	  var ie = ua.match(/MSIE\s([\d.]+)/) // IE 11 Trident/7.0; rv:11.0
	  || ua.match(/Trident\/.+?rv:(([\d.]+))/);
	  var edge = ua.match(/Edge\/([\d.]+)/); // IE 12 and 12+
	
	  var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:
	  // - discern (more) between multiple browsers on android
	  // - decide if kindle fire in silk mode is android or not
	  // - Firefox on Android doesn't specify the Android version
	  // - possibly devide in os, device and browser hashes
	  // if (browser.webkit = !!webkit) browser.version = webkit[1];
	  // if (android) os.android = true, os.version = android[2];
	  // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
	  // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
	  // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
	  // if (webos) os.webos = true, os.version = webos[2];
	  // if (touchpad) os.touchpad = true;
	  // if (blackberry) os.blackberry = true, os.version = blackberry[2];
	  // if (bb10) os.bb10 = true, os.version = bb10[2];
	  // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
	  // if (playbook) browser.playbook = true;
	  // if (kindle) os.kindle = true, os.version = kindle[1];
	  // if (silk) browser.silk = true, browser.version = silk[1];
	  // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
	  // if (chrome) browser.chrome = true, browser.version = chrome[1];
	
	  if (firefox) {
	    browser.firefox = true;
	    browser.version = firefox[1];
	  } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
	  // if (webview) browser.webview = true;
	
	
	  if (ie) {
	    browser.ie = true;
	    browser.version = ie[1];
	  }
	
	  if (edge) {
	    browser.edge = true;
	    browser.version = edge[1];
	  } // It is difficult to detect WeChat in Win Phone precisely, because ua can
	  // not be set on win phone. So we do not consider Win Phone.
	
	
	  if (weChat) {
	    browser.weChat = true;
	  } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
	  //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
	  // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||
	  //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
	  //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));
	
	
	  return {
	    browser: browser,
	    os: os,
	    node: false,
	    // 原生canvas支持，改极端点了
	    // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
	    canvasSupported: !!document.createElement('canvas').getContext,
	    svgSupported: typeof SVGRect !== 'undefined',
	    // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>
	    // works on most browsers
	    // IE10/11 does not support touch event, and MS Edge supports them but not by
	    // default, so we dont check navigator.maxTouchPoints for them here.
	    touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,
	    // <http://caniuse.com/#search=pointer%20event>.
	    pointerEventsSupported: 'onpointerdown' in window // Firefox supports pointer but not by default, only MS browsers are reliable on pointer
	    // events currently. So we dont use that on other browsers unless tested sufficiently.
	    // Although IE 10 supports pointer event, it use old style and is different from the
	    // standard. So we exclude that. (IE 10 is hardly used on touch device)
	    && (browser.edge || browser.ie && browser.version >= 11)
	  };
	}
	
	module.exports = _default;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(7);
	
	/**
	 * 圆环
	 * @module zrender/graphic/shape/Ring
	 */
	var _default = Path.extend({
	  type: 'ring',
	  shape: {
	    cx: 0,
	    cy: 0,
	    r: 0,
	    r0: 0
	  },
	  buildPath: function (ctx, shape) {
	    var x = shape.cx;
	    var y = shape.cy;
	    var PI2 = Math.PI * 2;
	    ctx.moveTo(x + shape.r, y);
	    ctx.arc(x, y, shape.r, 0, PI2, false);
	    ctx.moveTo(x + shape.r0, y);
	    ctx.arc(x, y, shape.r0, 0, PI2, true);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(7);
	
	var polyHelper = __webpack_require__(53);
	
	/**
	 * 多边形
	 * @module zrender/shape/Polygon
	 */
	var _default = Path.extend({
	  type: 'polygon',
	  shape: {
	    points: null,
	    smooth: false,
	    smoothConstraint: null
	  },
	  buildPath: function (ctx, shape) {
	    polyHelper.buildPath(ctx, shape, true);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	var smoothSpline = __webpack_require__(54);
	
	var smoothBezier = __webpack_require__(55);
	
	function buildPath(ctx, shape, closePath) {
	  var points = shape.points;
	  var smooth = shape.smooth;
	
	  if (points && points.length >= 2) {
	    if (smooth && smooth !== 'spline') {
	      var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);
	      ctx.moveTo(points[0][0], points[0][1]);
	      var len = points.length;
	
	      for (var i = 0; i < (closePath ? len : len - 1); i++) {
	        var cp1 = controlPoints[i * 2];
	        var cp2 = controlPoints[i * 2 + 1];
	        var p = points[(i + 1) % len];
	        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
	      }
	    } else {
	      if (smooth === 'spline') {
	        points = smoothSpline(points, closePath);
	      }
	
	      ctx.moveTo(points[0][0], points[0][1]);
	
	      for (var i = 1, l = points.length; i < l; i++) {
	        ctx.lineTo(points[i][0], points[i][1]);
	      }
	    }
	
	    closePath && ctx.closePath();
	  }
	}
	
	exports.buildPath = buildPath;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	var _vector = __webpack_require__(15);
	
	var v2Distance = _vector.distance;
	
	/**
	 * Catmull-Rom spline 插值折线
	 * @module zrender/shape/util/smoothSpline
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	
	/**
	 * @inner
	 */
	function interpolate(p0, p1, p2, p3, t, t2, t3) {
	  var v0 = (p2 - p0) * 0.5;
	  var v1 = (p3 - p1) * 0.5;
	  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
	}
	/**
	 * @alias module:zrender/shape/util/smoothSpline
	 * @param {Array} points 线段顶点数组
	 * @param {boolean} isLoop
	 * @return {Array}
	 */
	
	
	function _default(points, isLoop) {
	  var len = points.length;
	  var ret = [];
	  var distance = 0;
	
	  for (var i = 1; i < len; i++) {
	    distance += v2Distance(points[i - 1], points[i]);
	  }
	
	  var segs = distance / 2;
	  segs = segs < len ? len : segs;
	
	  for (var i = 0; i < segs; i++) {
	    var pos = i / (segs - 1) * (isLoop ? len : len - 1);
	    var idx = Math.floor(pos);
	    var w = pos - idx;
	    var p0;
	    var p1 = points[idx % len];
	    var p2;
	    var p3;
	
	    if (!isLoop) {
	      p0 = points[idx === 0 ? idx : idx - 1];
	      p2 = points[idx > len - 2 ? len - 1 : idx + 1];
	      p3 = points[idx > len - 3 ? len - 1 : idx + 2];
	    } else {
	      p0 = points[(idx - 1 + len) % len];
	      p2 = points[(idx + 1) % len];
	      p3 = points[(idx + 2) % len];
	    }
	
	    var w2 = w * w;
	    var w3 = w * w2;
	    ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);
	  }
	
	  return ret;
	}
	
	module.exports = _default;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	var _vector = __webpack_require__(15);
	
	var v2Min = _vector.min;
	var v2Max = _vector.max;
	var v2Scale = _vector.scale;
	var v2Distance = _vector.distance;
	var v2Add = _vector.add;
	var v2Clone = _vector.clone;
	var v2Sub = _vector.sub;
	
	/**
	 * 贝塞尔平滑曲线
	 * @module zrender/shape/util/smoothBezier
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	
	/**
	 * 贝塞尔平滑曲线
	 * @alias module:zrender/shape/util/smoothBezier
	 * @param {Array} points 线段顶点数组
	 * @param {number} smooth 平滑等级, 0-1
	 * @param {boolean} isLoop
	 * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内
	 *                           比如 [[0, 0], [100, 100]], 这个包围盒会与
	 *                           整个折线的包围盒做一个并集用来约束控制点。
	 * @param {Array} 计算出来的控制点数组
	 */
	function _default(points, smooth, isLoop, constraint) {
	  var cps = [];
	  var v = [];
	  var v1 = [];
	  var v2 = [];
	  var prevPoint;
	  var nextPoint;
	  var min, max;
	
	  if (constraint) {
	    min = [Infinity, Infinity];
	    max = [-Infinity, -Infinity];
	
	    for (var i = 0, len = points.length; i < len; i++) {
	      v2Min(min, min, points[i]);
	      v2Max(max, max, points[i]);
	    } // 与指定的包围盒做并集
	
	
	    v2Min(min, min, constraint[0]);
	    v2Max(max, max, constraint[1]);
	  }
	
	  for (var i = 0, len = points.length; i < len; i++) {
	    var point = points[i];
	
	    if (isLoop) {
	      prevPoint = points[i ? i - 1 : len - 1];
	      nextPoint = points[(i + 1) % len];
	    } else {
	      if (i === 0 || i === len - 1) {
	        cps.push(v2Clone(points[i]));
	        continue;
	      } else {
	        prevPoint = points[i - 1];
	        nextPoint = points[i + 1];
	      }
	    }
	
	    v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length
	
	    v2Scale(v, v, smooth);
	    var d0 = v2Distance(point, prevPoint);
	    var d1 = v2Distance(point, nextPoint);
	    var sum = d0 + d1;
	
	    if (sum !== 0) {
	      d0 /= sum;
	      d1 /= sum;
	    }
	
	    v2Scale(v1, v, -d0);
	    v2Scale(v2, v, d1);
	    var cp0 = v2Add([], point, v1);
	    var cp1 = v2Add([], point, v2);
	
	    if (constraint) {
	      v2Max(cp0, cp0, min);
	      v2Min(cp0, cp0, max);
	      v2Max(cp1, cp1, min);
	      v2Min(cp1, cp1, max);
	    }
	
	    cps.push(cp0);
	    cps.push(cp1);
	  }
	
	  if (isLoop) {
	    cps.push(cps.shift());
	  }
	
	  return cps;
	}
	
	module.exports = _default;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(7);
	
	var polyHelper = __webpack_require__(53);
	
	/**
	 * @module zrender/graphic/shape/Polyline
	 */
	var _default = Path.extend({
	  type: 'polyline',
	  shape: {
	    points: null,
	    smooth: false,
	    smoothConstraint: null
	  },
	  style: {
	    stroke: '#000',
	    fill: null
	  },
	  buildPath: function (ctx, shape) {
	    polyHelper.buildPath(ctx, shape, false);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(7);
	
	var roundRectHelper = __webpack_require__(29);
	
	/**
	 * 矩形
	 * @module zrender/graphic/shape/Rect
	 */
	var _default = Path.extend({
	  type: 'rect',
	  shape: {
	    // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
	    // r缩写为1         相当于 [1, 1, 1, 1]
	    // r缩写为[1]       相当于 [1, 1, 1, 1]
	    // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
	    // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
	    r: 0,
	    x: 0,
	    y: 0,
	    width: 0,
	    height: 0
	  },
	  buildPath: function (ctx, shape) {
	    var x = shape.x;
	    var y = shape.y;
	    var width = shape.width;
	    var height = shape.height;
	
	    if (!shape.r) {
	      ctx.rect(x, y, width, height);
	    } else {
	      roundRectHelper.buildPath(ctx, shape);
	    }
	
	    ctx.closePath();
	    return;
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(7);
	
	/**
	 * 直线
	 * @module zrender/graphic/shape/Line
	 */
	var _default = Path.extend({
	  type: 'line',
	  shape: {
	    // Start point
	    x1: 0,
	    y1: 0,
	    // End point
	    x2: 0,
	    y2: 0,
	    percent: 1
	  },
	  style: {
	    stroke: '#000',
	    fill: null
	  },
	  buildPath: function (ctx, shape) {
	    var x1 = shape.x1;
	    var y1 = shape.y1;
	    var x2 = shape.x2;
	    var y2 = shape.y2;
	    var percent = shape.percent;
	
	    if (percent === 0) {
	      return;
	    }
	
	    ctx.moveTo(x1, y1);
	
	    if (percent < 1) {
	      x2 = x1 * (1 - percent) + x2 * percent;
	      y2 = y1 * (1 - percent) + y2 * percent;
	    }
	
	    ctx.lineTo(x2, y2);
	  },
	
	  /**
	   * Get point at percent
	   * @param  {number} percent
	   * @return {Array.<number>}
	   */
	  pointAt: function (p) {
	    var shape = this.shape;
	    return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(7);
	
	var vec2 = __webpack_require__(15);
	
	var _curve = __webpack_require__(31);
	
	var quadraticSubdivide = _curve.quadraticSubdivide;
	var cubicSubdivide = _curve.cubicSubdivide;
	var quadraticAt = _curve.quadraticAt;
	var cubicAt = _curve.cubicAt;
	var quadraticDerivativeAt = _curve.quadraticDerivativeAt;
	var cubicDerivativeAt = _curve.cubicDerivativeAt;
	
	/**
	 * 贝塞尔曲线
	 * @module zrender/shape/BezierCurve
	 */
	var out = [];
	
	function someVectorAt(shape, t, isTangent) {
	  var cpx2 = shape.cpx2;
	  var cpy2 = shape.cpy2;
	
	  if (cpx2 === null || cpy2 === null) {
	    return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];
	  } else {
	    return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];
	  }
	}
	
	var _default = Path.extend({
	  type: 'bezier-curve',
	  shape: {
	    x1: 0,
	    y1: 0,
	    x2: 0,
	    y2: 0,
	    cpx1: 0,
	    cpy1: 0,
	    // cpx2: 0,
	    // cpy2: 0
	    // Curve show percent, for animating
	    percent: 1
	  },
	  style: {
	    stroke: '#000',
	    fill: null
	  },
	  buildPath: function (ctx, shape) {
	    var x1 = shape.x1;
	    var y1 = shape.y1;
	    var x2 = shape.x2;
	    var y2 = shape.y2;
	    var cpx1 = shape.cpx1;
	    var cpy1 = shape.cpy1;
	    var cpx2 = shape.cpx2;
	    var cpy2 = shape.cpy2;
	    var percent = shape.percent;
	
	    if (percent === 0) {
	      return;
	    }
	
	    ctx.moveTo(x1, y1);
	
	    if (cpx2 == null || cpy2 == null) {
	      if (percent < 1) {
	        quadraticSubdivide(x1, cpx1, x2, percent, out);
	        cpx1 = out[1];
	        x2 = out[2];
	        quadraticSubdivide(y1, cpy1, y2, percent, out);
	        cpy1 = out[1];
	        y2 = out[2];
	      }
	
	      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
	    } else {
	      if (percent < 1) {
	        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
	        cpx1 = out[1];
	        cpx2 = out[2];
	        x2 = out[3];
	        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
	        cpy1 = out[1];
	        cpy2 = out[2];
	        y2 = out[3];
	      }
	
	      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
	    }
	  },
	
	  /**
	   * Get point at percent
	   * @param  {number} t
	   * @return {Array.<number>}
	   */
	  pointAt: function (t) {
	    return someVectorAt(this.shape, t, false);
	  },
	
	  /**
	   * Get tangent at percent
	   * @param  {number} t
	   * @return {Array.<number>}
	   */
	  tangentAt: function (t) {
	    var p = someVectorAt(this.shape, t, true);
	    return vec2.normalize(p, p);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(7);
	
	/**
	 * 圆弧
	 * @module zrender/graphic/shape/Arc
	 */
	var _default = Path.extend({
	  type: 'arc',
	  shape: {
	    cx: 0,
	    cy: 0,
	    r: 0,
	    startAngle: 0,
	    endAngle: Math.PI * 2,
	    clockwise: true
	  },
	  style: {
	    stroke: '#000',
	    fill: null
	  },
	  buildPath: function (ctx, shape) {
	    var x = shape.cx;
	    var y = shape.cy;
	    var r = Math.max(shape.r, 0);
	    var startAngle = shape.startAngle;
	    var endAngle = shape.endAngle;
	    var clockwise = shape.clockwise;
	    var unitX = Math.cos(startAngle);
	    var unitY = Math.sin(startAngle);
	    ctx.moveTo(unitX * r + x, unitY * r + y);
	    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(5);
	
	var Gradient = __webpack_require__(42);
	
	/**
	 * x, y, x2, y2 are all percent from 0 to 1
	 * @param {number} [x=0]
	 * @param {number} [y=0]
	 * @param {number} [x2=1]
	 * @param {number} [y2=0]
	 * @param {Array.<Object>} colorStops
	 * @param {boolean} [globalCoord=false]
	 */
	var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {
	  // Should do nothing more in this constructor. Because gradient can be
	  // declard by `color: {type: 'linear', colorStops: ...}`, where
	  // this constructor will not be called.
	  this.x = x == null ? 0 : x;
	  this.y = y == null ? 0 : y;
	  this.x2 = x2 == null ? 1 : x2;
	  this.y2 = y2 == null ? 0 : y2; // Can be cloned
	
	  this.type = 'linear'; // If use global coord
	
	  this.global = globalCoord || false;
	  Gradient.call(this, colorStops);
	};
	
	LinearGradient.prototype = {
	  constructor: LinearGradient
	};
	zrUtil.inherits(LinearGradient, Gradient);
	var _default = LinearGradient;
	module.exports = _default;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(5);
	
	var Gradient = __webpack_require__(42);
	
	/**
	 * x, y, r are all percent from 0 to 1
	 * @param {number} [x=0.5]
	 * @param {number} [y=0.5]
	 * @param {number} [r=0.5]
	 * @param {Array.<Object>} [colorStops]
	 * @param {boolean} [globalCoord=false]
	 */
	var RadialGradient = function (x, y, r, colorStops, globalCoord) {
	  // Should do nothing more in this constructor. Because gradient can be
	  // declard by `color: {type: 'radial', colorStops: ...}`, where
	  // this constructor will not be called.
	  this.x = x == null ? 0.5 : x;
	  this.y = y == null ? 0.5 : y;
	  this.r = r == null ? 0.5 : r; // Can be cloned
	
	  this.type = 'radial'; // If use global coord
	
	  this.global = globalCoord || false;
	  Gradient.call(this, colorStops);
	};
	
	RadialGradient.prototype = {
	  constructor: RadialGradient
	};
	zrUtil.inherits(RadialGradient, Gradient);
	var _default = RadialGradient;
	module.exports = _default;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(5);
	
	var Style = __webpack_require__(9);
	
	var _vector = __webpack_require__(15);
	
	var vec2Copy = _vector.copy;
	
	/**
	 * States machine for managing graphic states
	 */
	
	/**
	 * @typedef {Object} IGraphicState
	 * @property {number} [zlevel]
	 * @property {number} [z]
	 * @property {Array.<number>} {position}
	 * @property {Array.<number>|number} {rotation}
	 * @property {Array.<number>} {scale}
	 * @property {Object} style
	 *
	 * @property {Function} onenter
	 * @property {Function} onleave
	 * @property {Function} ontransition
	 * @property {Array.<IGraphicStateTransition|string>} transition
	 *           Transition object or a string descriptor like '* 30 0 Linear'
	 */
	var transitionProperties = ['position', 'rotation', 'scale', 'style', 'shape'];
	/**
	 * @module zrender/graphic/States~TransitionObject
	 */
	
	var TransitionObject = function (opts) {
	  if (typeof opts == 'string') {
	    this._fromStr(opts);
	  } else if (opts) {
	    opts.property && (this.property = opts.property);
	    opts.duration != null && (this.duration = opts.duration);
	    opts.easing && (this.easing = opts.easing);
	    opts.delay && (this.delay = opts.delay);
	  }
	
	  if (this.property !== '*') {
	    this.property = this.property.split(',');
	  } else {
	    this.property = transitionProperties;
	  }
	};
	
	TransitionObject.prototype = {
	  constructor: TransitionObject,
	
	  /**
	   * List of all transition properties. Splitted by comma. Must not have spaces in the string.
	   * e.g. 'position,style.color'. '*' will match all the valid properties.
	   * @type {string}
	   * @default *
	   */
	  property: '*',
	
	  /**
	   * @type {string}
	   * @default 'Linear'
	   */
	  easing: 'Linear',
	
	  /**
	   * @type {number}
	   * @default 'number'
	   */
	  duration: 500,
	
	  /**
	   * @type {number}
	   */
	  delay: 0,
	  _fromStr: function (str) {
	    var arr = str.split(/\s+/g);
	    this.property = arr[0];
	    this.duration = +arr[1];
	    this.delay = +arr[2];
	    this.easing = arr[3];
	  }
	};
	/**
	 * @alias module:zrender/graphic/States
	 */
	
	var GraphicStates = function (opts) {
	  opts = opts || {};
	  this._states = {};
	  /**
	   * Target element
	   * @type {zrender/graphic/Displayable|zrender/container/Group}
	   */
	
	  this._el = opts.el;
	  this._subStates = [];
	  this._transitionAnimators = [];
	
	  if (opts.initialState) {
	    this._initialState = opts.initialState;
	  }
	
	  var optsStates = opts.states;
	
	  if (optsStates) {
	    for (var name in optsStates) {
	      if (optsStates.hasOwnProperty(name)) {
	        var state = optsStates[name];
	
	        this._addState(name, state);
	      }
	    }
	  }
	
	  this.setState(this._initialState);
	};
	
	GraphicStates.prototype = {
	  constructor: GraphicStates,
	
	  /**
	   * All other state will be extended from initial state
	   * @type {string}
	   * @private
	   */
	  _initialState: 'normal',
	
	  /**
	   * Current state
	   * @type {string}
	   * @private
	   */
	  _currentState: '',
	  el: function () {
	    return this._el;
	  },
	  _addState: function (name, state) {
	    this._states[name] = state;
	
	    if (state.transition) {
	      state.transition = new TransitionObject(state.transition);
	    } // Extend from initial state
	
	
	    if (name !== this._initialState) {
	      this._extendFromInitial(state);
	    } else {
	      var el = this._el; // setState 的时候自带的 style 和 shape 都会被直接覆盖
	      // 所以这边先把自带的 style 和 shape 扩展到初始状态中
	
	      zrUtil.merge(state.style, el.style, false, false);
	
	      if (state.shape) {
	        zrUtil.merge(state.shape, el.shape, false, true);
	      } else {
	        state.shape = zrUtil.clone(el.shape, true);
	      }
	
	      for (var name in this._states) {
	        if (this._states.hasOwnProperty(name)) {
	          this._extendFromInitial(this._states[name]);
	        }
	      }
	    }
	  },
	  _extendFromInitial: function (state) {
	    var initialState = this._states[this._initialState];
	
	    if (initialState && state !== initialState) {
	      zrUtil.merge(state, initialState, false, true);
	    }
	  },
	  setState: function (name, silent) {
	    if (name === this._currentState && !this.transiting()) {
	      return;
	    }
	
	    var state = this._states[name];
	
	    if (state) {
	      this._stopTransition();
	
	      if (!silent) {
	        var prevState = this._states[this._currentState];
	
	        if (prevState) {
	          prevState.onleave && prevState.onleave.call(this);
	        }
	
	        state.onenter && state.onenter.call(this);
	      }
	
	      this._currentState = name;
	
	      if (this._el) {
	        var el = this._el; // Setting attributes
	
	        if (state.zlevel != null) {
	          el.zlevel = state.zlevel;
	        }
	
	        if (state.z != null) {
	          el.z = state.z;
	        } // SRT
	
	
	        state.position && vec2Copy(el.position, state.position);
	        state.scale && vec2Copy(el.scale, state.scale);
	
	        if (state.rotation != null) {
	          el.rotation = state.rotation;
	        } // Style
	
	
	        if (state.style) {
	          var initialState = this._states[this._initialState];
	          el.style = new Style();
	
	          if (initialState) {
	            el.style.extendFrom(initialState.style, false);
	          }
	
	          if ( // Not initial state
	          name != this._initialState // Not copied from initial state in _extendFromInitial method
	          && initialState.style !== state.style) {
	            el.style.extendFrom(state.style, true);
	          }
	        }
	
	        if (state.shape) {
	          el.shape = zrUtil.clone(state.shape, true);
	        }
	
	        el.dirty();
	      }
	    }
	
	    for (var i = 0; i < this._subStates.length; i++) {
	      this._subStates.setState(name);
	    }
	  },
	  getState: function () {
	    return this._currentState;
	  },
	  transitionState: function (target, done) {
	    if (target === this._currentState && !this.transiting()) {
	      return;
	    }
	
	    var state = this._states[target];
	    var styleShapeReg = /$[style|shape]\./;
	    var self = this; // Animation 去重
	
	    var propPathMap = {};
	
	    if (state) {
	      self._stopTransition();
	
	      var el = self._el;
	
	      if (state.transition && el && el.__zr) {
	        // El can be animated
	        var transitionCfg = state.transition;
	        var property = transitionCfg.property;
	        var animatingCount = 0;
	
	        var animationDone = function () {
	          animatingCount--;
	
	          if (animatingCount === 0) {
	            self.setState(target);
	            done && done();
	          }
	        };
	
	        for (var i = 0; i < property.length; i++) {
	          var propName = property[i]; // Animating all the properties in style or shape
	
	          if (propName === 'style' || propName === 'shape') {
	            if (state[propName]) {
	              for (var key in state[propName]) {
	                if (!state[propName].hasOwnProperty(key)) {
	                  continue;
	                }
	
	                var path = propName + '.' + key;
	
	                if (propPathMap[path]) {
	                  continue;
	                }
	
	                propPathMap[path] = 1;
	                animatingCount += self._animProp(state, propName, key, transitionCfg, animationDone);
	              }
	            }
	          } else {
	            if (propPathMap[propName]) {
	              continue;
	            }
	
	            propPathMap[propName] = 1; // Animating particular property in style or style
	
	            if (propName.match(styleShapeReg)) {
	              // remove 'style.', 'shape.' prefix
	              var subProp = propName.slice(0, 5);
	              propName = propName.slice(6);
	              animatingCount += self._animProp(state, subProp, propName, transitionCfg, animationDone);
	            } else {
	              animatingCount += self._animProp(state, '', propName, transitionCfg, animationDone);
	            }
	          }
	        } // No transition properties
	
	
	        if (animatingCount === 0) {
	          self.setState(target);
	          done && done();
	        }
	      } else {
	        self.setState(target);
	        done && done();
	      }
	    }
	
	    var subStates = self._subStates;
	
	    for (var i = 0; i < subStates.length; i++) {
	      subStates.transitionState(target);
	    }
	  },
	
	  /**
	   * Do transition animation of particular property
	   * @param {Object} state
	   * @param {string} subPropKey
	   * @param {string} key
	   * @param {Object} transitionCfg
	   * @param {Function} done
	   * @private
	   */
	  _animProp: function (state, subPropKey, key, transitionCfg, done) {
	    var el = this._el;
	    var stateObj = subPropKey ? state[subPropKey] : state;
	    var elObj = subPropKey ? el[subPropKey] : el;
	    var availableProp = stateObj && key in stateObj && elObj && key in elObj;
	    var transitionAnimators = this._transitionAnimators;
	
	    if (availableProp) {
	      var obj = {};
	
	      if (stateObj[key] === elObj[key]) {
	        return 0;
	      }
	
	      obj[key] = stateObj[key];
	      var animator = el.animate(subPropKey).when(transitionCfg.duration, obj).delay(transitionCfg.dealy).done(function () {
	        var idx = zrUtil.indexOf(transitionAnimators, 1);
	
	        if (idx > 0) {
	          transitionAnimators.splice(idx, 1);
	        }
	
	        done();
	      }).start(transitionCfg.easing);
	      transitionAnimators.push(animator);
	      return 1;
	    }
	
	    return 0;
	  },
	  _stopTransition: function () {
	    var transitionAnimators = this._transitionAnimators;
	
	    for (var i = 0; i < transitionAnimators.length; i++) {
	      transitionAnimators[i].stop();
	    }
	
	    transitionAnimators.length = 0;
	  },
	  transiting: function () {
	    return this._transitionAnimators.length > 0;
	  },
	  addSubStates: function (states) {
	    this._subStates.push(states);
	  },
	  removeSubStates: function (states) {
	    var idx = zrUtil.indexOf(this._subStates, states);
	
	    if (idx >= 0) {
	      this._subStates.splice(states, 1);
	    }
	  }
	};
	var _default = GraphicStates;
	module.exports = _default;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	
	    var zrUtil = __webpack_require__(5);
	    var BoundingRect = __webpack_require__(27);
	    function Minimap(bigCanvas,groupPosition, group,eagleEyeNode,distance,imgSrc) {
	
	        this.bigCanvas = bigCanvas;
	        this.eagleEyeNode = eagleEyeNode;
	        this.distance = distance;
	        this.imgSrc = imgSrc;
	        this.ratio;
	        this.groupRatio;
	        this.group = group;
	        this.img = document.createElement("img");
	        this.selection = document.createElement('div');
	        this.groupPosition = zrUtil.clone(groupPosition);
	        this.selectPosition = [0,0];
	        this.render();
	    }
	
	    Minimap.prototype.render = function() {
	        var that = this;
	        that.ratio = 0.12;
	        var eagleEyeNodeWidth = that.group.width  * that.ratio;
	        var eagleEyeNodeHeight = that.group.height  * that.ratio;
	        that.eagleEyeNode.style.width = eagleEyeNodeWidth+"px";
	        that.eagleEyeNode.style.height = eagleEyeNodeHeight+"px";
	        that.eagleEyeNode.style.marginTop = -eagleEyeNodeHeight+"px";
	        that.eagleEyeNode.style.marginLeft = that.bigCanvas.getWidth()-eagleEyeNodeWidth+"px";
	        that.eagleEyeNode.style.position="relative";
	        that.eagleEyeNode.style.background = "url("+that.imgSrc+") no-repeat";
	        that.eagleEyeNode.style.backgroundSize = eagleEyeNodeWidth/(that.group.width*that.distance[2]/that.bigCanvas.getWidth())+"px";
	        that.backgroundSize = zrUtil.clone(that.eagleEyeNode.style.backgroundSize);
	        that.eagleEyeNode.innerHTML = "";
	        that.selection.style.border = "1px solid #ff0000";
	        that.selection.style.cursor = "pointer";
	        that.selection.style.width = that.bigCanvas.getWidth()/that.group.width*eagleEyeNodeWidth+"px";
	        that.selection.style.height = that.bigCanvas.getHeight()/that.group.height*eagleEyeNodeHeight+"px";
	        that.selectWidth = that.selection.style.width;
	        that.selectHeight = that.selection.style.height;
	        that.selection.style.position="absolute";
	        that.selection.style.top = 0+"px";
	        that.selection.style.left = 0+"px";
	        that.eagleEyeNode.appendChild(this.selection);
	    };
	    Minimap.prototype.updataSelection = function(offectLeft,offectTop,zoomScale,nowZoom){
	        var that = this;
	        that.zoomScale = zoomScale;
	        this.selection.style.width = this.selection.style.width.replace("px","")/zoomScale+"px";
	        this.selection.style.height = this.selection.style.height.replace("px","")/zoomScale+"px";
	        that.selectPosition[0] = zrUtil.clone(offectLeft)*that.ratio/nowZoom;
	        that.selectPosition[1] = zrUtil.clone(offectTop)*that.ratio/nowZoom;
	        this.selection.style.left = -that.selectPosition[0]+"px";
	        this.selection.style.top = -that.selectPosition[1]+"px";
	    };
	    Minimap.prototype.updataMap = function(imgSrc,newGroup){
	        var that = this;
	        that.eagleEyeNode.style.backgroundImage = "url("+imgSrc+")";
	        var eagleEyeNodeWidth = newGroup.width  * that.ratio;
	        var eagleEyeNodeHeight = newGroup.height  * that.ratio;
	        that.eagleEyeNode.style.width = eagleEyeNodeWidth+"px";
	        that.eagleEyeNode.style.height = eagleEyeNodeHeight+"px";
	        that.eagleEyeNode.style.marginTop = -eagleEyeNodeHeight+"px";
	        that.eagleEyeNode.style.marginLeft = that.bigCanvas.getWidth()-eagleEyeNodeWidth+"px";
	    };
	    Minimap.prototype.updataSelectionPosition = function(nowGroupPosition,nowZoom){
	        var that = this;
	        that.selectPosition[0] = zrUtil.clone(nowGroupPosition[0])*that.ratio/nowZoom;
	        that.selectPosition[1] = zrUtil.clone(nowGroupPosition[1])*that.ratio/nowZoom;
	        this.selection.style.left = -that.selectPosition[0]+"px";
	        this.selection.style.top = -that.selectPosition[1]+"px";
	    };
	    Minimap.prototype.updataGroupPosition = function(group,nowZoom){
	        var that = this;
	        var positionX = -Number(that.selection.style.left.substring(0,that.selection.style.left.length-2))/that.ratio*nowZoom;
	        var positionY = -Number(that.selection.style.top.substring(0,that.selection.style.top.length-2))/that.ratio*nowZoom;
	        group.attr("position",[positionX,positionY]);
	    };
	
	    module.exports = Minimap;
	


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 工具方法类
	 * @author wang.xiaohu
	 */
	
	    var Point = __webpack_require__(66);
	    var Line = __webpack_require__(67);
	    var BoundingRect = __webpack_require__(27);
	    var zrUtil = __webpack_require__(5);
	    /**
	     * 构造类继承关系
	     *
	     * @param {Function} clazz 源类
	     * @param {Function} baseClazz 基类
	     */
	    function inherits(clazz, baseClazz) {
	        var clazzPrototype = clazz.prototype;
	
	        function F() {}
	        F.prototype = baseClazz.prototype;
	        clazz.prototype = new F();
	
	        for (var prop in clazzPrototype) {
	            clazz.prototype[prop] = clazzPrototype[prop];
	        }
	        clazz.prototype.constructor = clazz;
	        clazz.superClass = baseClazz;
	    }
	
	    function getUUID() {
	        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),
	            uuid = new Array(36),
	            rnd = 0,
	            r;
	        for (var i = 0; i < 36; i++) {
	            if (i == 8 || i == 13 || i == 18 || i == 23) {
	                uuid[i] = '-';
	            } else if (i == 14) {
	                uuid[i] = '4';
	            } else {
	                if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;
	                r = rnd & 0xf;
	                rnd = rnd >> 4;
	                uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
	            }
	        }
	        return "sid-" + uuid.join('');
	    }
	
	
	    /**
	     * 计算两点之间的距离
	     *@param {Point} p1 - first {Point}
	     *@param {Point} p2 - second {Point}
	     *@return {Number} - the distance between those 2 points. It is always positive.
	     **/
	    function distance(p1, p2) {
	        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
	    }
	
	    /**
	     * 返回一条折线 最长的两个点
	     * @param  {[type]} points [description]
	     * @return {[type]}        [description]
	     */
	    function getMaxLineLength(points) {
	        var m = distance(points[0], points[1]);
	        var result = [points[0], points[1]];
	        for (var i = 1; i < points.length - 1; i++) {
	
	            if (m < distance(points[i], points[i + 1])) {
	                m = distance(points[i], points[i + 1])
	                result = [points[i], points[i + 1]];
	            }
	        }
	
	        return result;
	    }
	
	    /**Returns the length of a Polyline that would be created with a set of points
	     *@param {Array} v - an {Array} of {Points}
	     *@return {Number} - a positive number equal with total length*/
	    function getPolylineLength(v) {
	        var l = 0;
	        for (var i = 0; i < v.length - 1; i++) {
	            l += distance(v[i], v[i + 1]);
	        }
	
	        return l;
	    }
	
	
	    /**Returns the max of a vector
	     *@param {Array} v - vector of {Number}s
	     *@return {Number} - the maximum number from the vector or NaN if vector is empty
	     **/
	    function max(v) {
	        if (v.lenght == 0) {
	            return NaN;
	        } else {
	            var m = v[0];
	            for (var i = 0; i < v.length; i++) {
	                if (m < v[i]) {
	                    m = v[i];
	                }
	            }
	
	            return m;
	        }
	    }
	
	
	    /**Returns the min of a vector
	     *@param {Array} v - vector of {Number}s
	     *@return {Number} - the minimum number from the vector or NaN if vector is empty
	     *@author alex@scriptoid.com
	     **/
	    function min(v) {
	        if (v.lenght == 0) {
	            return NaN;
	        } else {
	            var m = v[0];
	            for (var i = 0; i < v.length; i++) {
	                if (m > v[i]) {
	                    m = v[i];
	                }
	            }
	
	            return m;
	        }
	    }
	
	    /**
	     * 判断 点数组 是否正交直线路径
	     *Tests if a vector of points is an orthogonal path (moving in multiples of 90 degrees)
	     *@param {Array} v - an {Array} of {Point}s
	     *@return {Boolean} - true if path is valid, false otherwise
	     **/
	    function orthogonalPath(v) {
	        if (v.length <= 1) {
	            return true;
	        }
	
	        for (var i = 0; i < v.length - 1; i++) {
	            if (v[i].x != v[i + 1].x && v[i].y != v[i + 1].y) {
	                return false;
	            }
	        }
	
	        return true;
	    }
	
	
	    /**
	     *Test to see if 2 {Line}s intersects. They are considered finite segments
	     *and not the infinite lines from geometry
	     *@param {Line} l1 - fist line/segment
	     *@param {Line} l2 - last line/segment
	     *@return {Boolean} true - if the lines intersect or false if not
	     **/
	    function lineIntersectsLine(l1, l2) {
	        // check for two vertical lines
	        if (l1.startPoint.x == l1.endPoint.x && l2.startPoint.x == l2.endPoint.x) {
	            return l1.startPoint.x == l2.startPoint.x ? // if 'infinite 'lines do coincide,
	                // then check segment bounds for overlapping
	                l1.contains(l2.startPoint.x, l2.startPoint.y) ||
	                l1.contains(l2.endPoint.x, l2.endPoint.y) :
	                // lines are paralel
	                false;
	        }
	        // if one line is vertical, and another line is not vertical
	        else if (l1.startPoint.x == l1.endPoint.x || l2.startPoint.x == l2.endPoint.x) {
	            // let assume l2 is vertical, otherwise exchange them
	            if (l1.startPoint.x == l1.endPoint.x) {
	                var l = l1;
	                l1 = l2;
	                l2 = l;
	            }
	            // finding intersection of 'infinite' lines
	            // equation of the first line is y = ax + b, second: x = c
	            var a = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);
	            var b = l1.startPoint.y - a * l1.startPoint.x;
	            var x0 = l2.startPoint.x;
	            var y0 = a * x0 + b;
	            return l1.contains(x0, y0) && l2.contains(x0, y0);
	        }
	
	        // check normal case - both lines are not vertical
	        else {
	            //line equation is : y = a*x + b, b = y - a * x
	            var a1 = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);
	            var b1 = l1.startPoint.y - a1 * l1.startPoint.x;
	
	            var a2 = (l2.endPoint.y - l2.startPoint.y) / (l2.endPoint.x - l2.startPoint.x);
	            var b2 = l2.startPoint.y - a2 * l2.startPoint.x;
	
	            if (a1 == a2) { //paralel lines
	                return b1 == b2 ?
	                    // for coincide lines, check for segment bounds overlapping
	                    l1.contains(l2.startPoint.x, l2.startPoint.y) || l1.contains(l2.endPoint.x, l2.endPoint.y) :
	                    // not coincide paralel lines have no chance to intersect
	                    false;
	            } else { //usual case - non paralel, the 'infinite' lines intersects...we only need to know if inside the segment
	
	                /*
	                 * if one of the lines are vertical, then x0 is equal to their x,
	                 * otherwise:
	                 * y1 = a1 * x + b1
	                 * y2 = a2 * x + b2
	                 * => x0 = (b2 - b1) / (a1 - a2)
	                 * => y0 = a1 * x0 + b1
	                 **/
	                x0 = (b2 - b1) / (a1 - a2);
	                y0 = a1 * x0 + b1;
	                return l1.contains(x0, y0) && l2.contains(x0, y0);
	            }
	        }
	    }
	
	    /**
	     *
	     *Tests if a a polyline defined by a set of points intersects a rectangle
	     *@param {Array} points - and {Array} of {Point}s
	     *@param {Array} bounds - the bounds of the rectangle defined by (x1, y1, x2, y2)
	     *@param {Boolean} closedPolyline - incase polyline is closed figure then true, else false
	     *
	     *@return true - if line intersects the rectangle, false - if not
	     **/
	    function polylineIntersectsRectangle(points, bounds, closedPolyline) {
	
	
	        //get the 4 lines/segments represented by the bounds
	        var lines = [];
	        lines.push(new Line(new Point(bounds[0], bounds[1]), new Point(bounds[2], bounds[1])));
	        lines.push(new Line(new Point(bounds[2], bounds[1]), new Point(bounds[2], bounds[3])));
	        lines.push(new Line(new Point(bounds[2], bounds[3]), new Point(bounds[0], bounds[3])));
	        lines.push(new Line(new Point(bounds[0], bounds[3]), new Point(bounds[0], bounds[1])));
	
	        for (var k = 0; k < points.length - 1; k++) {
	            //create a line out of each 2 consecutive points
	            var tempLine = new Line(points[k], points[k + 1]);
	
	            //see if that line intersect any of the line on bounds border
	            for (var i = 0; i < lines.length; i++) {
	                if (lineIntersectsLine(tempLine, lines[i])) {
	                    return true;
	                }
	            }
	        }
	
	        //check the closed figure - that is last point connected to the first
	        if (closedPolyline) {
	            //create a line out of each 2 consecutive points
	            var tempLine1 = new Line(points[points.length - 1], points[0]);
	
	            //see if that line intersect any of the line on bounds border
	            for (var j = 0; j < lines.length; j++) {
	                if (lineIntersectsLine(tempLine1, lines[j])) {
	                    return true;
	                }
	            }
	        }
	
	        return false;
	    }
	
	    /**
	     * 计算路径的分数
	     * Score a ortogonal path made out of Points
	     *Iterates over a set of points (minimum 3)
	     *For each 3 points (i, i+1, i+2) :
	     *  - if the 3rd one is after the 2nd on the same line we add +1
	     *  - if the 3rd is up or down related to the 2nd we do not do anything +0
	     *  - if the 3rd goes back we imediatelly return -1
	     *@param {Array} v - an array of {Point}s
	     *@return {Number} - -1 if the path is wrong (goes back) or something >= 0 if is fine
	     *  The bigger the number the smooth the path is
	     **/
	    function scorePath(v) {
	        if (v.length <= 2) {
	            return -1;
	        }
	
	        var score = 0;
	        for (var i = 1; i < v.length - 1; i++) {
	            if (v[i - 1].x == v[i].x && v[i].x == v[i + 1].x) { //on the same vertical
	                if (signum(v[i + 1].y - v[i].y) == signum(v[i].y - v[i - 1].y)) { //same direction
	                    score++;
	                } else { //going back - no good
	                    return -1;
	                }
	            } else if (v[i - 1].y == v[i].y && v[i].y == v[i + 1].y) { //on the same horizontal
	                if (signum(v[i + 1].x - v[i].x) == signum(v[i].x - v[i - 1].x)) { //same direction
	                    score++;
	                } else { //going back - no good
	                    return -1;
	                }
	            } else { //not on same vertical nor horizontal
	                score--;
	            }
	        }
	
	        return score;
	    }
	
	    /**
	     * 返回数字符号（+ -)
	     * Returns the sign of a number
	     *@param {Number} x - the number
	     *@returns {Number}
	     *@see <a href="http://en.wikipedia.org/wiki/Sign_function">http://en.wikipedia.org/wiki/Sign_function</a>
	     **/
	    function signum(x) {
	        if (x > 0)
	            return 1;
	        else if (x < 0)
	            return -1;
	        else
	            return 0;
	    }
	
	    /**
	     * 判断 点数组 是不是有效路径（没有回路）
	     *Tests if a vector of points is a valid path (not going back)
	     *There are a few problems here. If you have p1, p2, p3 and p4 and p2 = p3 you need to ignore that
	     *@param {Array} v - an {Array} of {Point}s
	     *@return {Boolean} - true if path is valid, false otherwise
	     **/
	    function forwardPath(v) {
	        if (v.length <= 2) {
	            return true;
	        }
	
	        for (var i = 0; i < v.length - 2; i++) {
	            if (v[i].x == v[i + 1].x && v[i + 1].x == v[i + 2].x) { //on the same vertical
	                if (signum(v[i + 1].y - v[i].y) != 0) { //test only we have a progressing path
	                    if (signum(v[i + 1].y - v[i].y) == -1 * signum(v[i + 2].y - v[i + 1].y)) { //going back (ignore zero)
	                        return false;
	                    }
	                }
	            } else if (v[i].y == v[i + 1].y && v[i + 1].y == v[i + 2].y) { //on the same horizontal
	                if (signum(v[i + 1].x - v[i].x) != 0) { //test only we have a progressing path
	                    if (signum(v[i + 1].x - v[i].x) == -1 * signum(v[i + 2].x - v[i + 1].x)) { //going back (ignore zero)
	                        return false;
	                    }
	                }
	            }
	        }
	
	        return true;
	    }
	
	    /**
	     * 将[x:0,y:0]转化为[0, 0]  给zrender使用
	     * @param  {[type]} points [description]
	     * @param  {[type]} isRevert [description]
	     * @return {[type]}        [description]
	     */
	    function traslatePoints(points, isRevert) {
	        var newPoints = [];
	        if (isRevert) {
	            for (var i = 0; i < points.length; i++) {
	                var point = points[i];
	                newPoints.push(new Point(point[0], point[1]));
	            }
	            return newPoints;
	        } else {
	            for (var j = 0; j < points.length; j++) {
	                var point1 = points[j];
	                newPoints.push([point1.x, point1.y]);
	            }
	            return newPoints;
	        }
	
	
	    }
	
	    function rotationMatrix(angle) {
	        var mReturn = [
	            [Math.cos(angle), -Math.sin(angle), 0],
	            [Math.sin(angle), Math.cos(angle), 0],
	            [0, 0, 1]
	        ];
	        return mReturn;
	    }
	
	    function translationMatrix(dx, dy) {
	        return [
	            [1, 0, dx],
	            [0, 1, dy],
	            [0, 0, 1]
	        ];
	    }
	
	    function scaleMatrix(sx, sy) {
	        if (sy == null) {
	            sy = sx;
	        }
	        return [
	            [sx, 0, 0],
	            [0, sy, 0],
	            [0, 0, 1]
	        ];
	    }
	
	    /** It will return the end point of a line on a given angle (clockwise).
	     * @param {Point} startPoint - the start of the line
	     * @param {Number} length - the length of the line
	     * @param {Number} angle - the angle of the line in radians
	     * @return {Point} - the endPoint of the line
	     */
	    function getEndPoint(startPoint, length, angle) {
	        var endPoint = startPoint.clone();
	        endPoint.transform(translationMatrix(-startPoint.x, -startPoint.y));
	        endPoint.y -= length;
	        endPoint.transform(rotationMatrix(angle));
	        endPoint.transform(translationMatrix(startPoint.x, startPoint.y));
	        return endPoint;
	    }
	
	    /**
	     * 获取获取两个图形的外面四个连接点
	     * @param  {[type]} rect [description]
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    function getConnectorPoints(rect, node) {
	        node = node || {};
	        var boundingRect = zrUtil.clone(rect.boundingRect || rect);
	        var rotation = node.rotation;
	        var points = {
	            left: new Point(boundingRect.x, boundingRect.y + boundingRect.height / 2), //矩形 左中的位置
	            top: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y), //矩形 上中的位置
	            right: new Point(boundingRect.x + boundingRect.width, boundingRect.y + boundingRect.height / 2), //矩形 右中的位置
	            bottom: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y + boundingRect.height), //矩形 下中的位置
	            center: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y + boundingRect.height / 2) //中间位置
	
	        };
	        if (Object.keys(node).length > 0 && Math.abs(rotation) > 0) {
	            var rectNew = rect.boundingRect ? rect : getRect(node);
	            var center = { x: rectNew.x, y: rectNew.y }; // 中心点
	            Object.keys(points).forEach(function(key) {
	                var value = points[key];
	                var x0 = center.x - value.x;
	                var y0 = center.y - value.y;
	                var sin = Math.sin(-rotation);
	                var cos = Math.cos(-rotation);
	                var position_n_x = center.x - (x0 * cos - y0 * sin);
	                var position_n_y = center.y - (x0 * sin + y0 * cos);
	                points[key].x = position_n_x;
	                points[key].y = position_n_y;
	            });
	        }
	        return points;
	    }
	
	    /**
	     * 获取节点外面四个控制点和旋转点
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    function getConnectorControls(rect, node) {
	        node = node || {};
	        var boundingRect = zrUtil.clone(rect.boundingRect);
	        var rotation = node.rotation;
	        var controls = {
	            tl: new Point(boundingRect.x, boundingRect.y), //矩形 左上角位置
	            tc: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y - 4), //矩形 上中位置
	            tr: new Point(boundingRect.x + boundingRect.width, boundingRect.y), //矩形 右上角位置
	            bl: new Point(boundingRect.x, boundingRect.y + boundingRect.height), //矩形 左下角
	            br: new Point(boundingRect.x + boundingRect.width, boundingRect.y + boundingRect.height), //矩形 右下角位置
	            mtr: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y - 20) // 旋转点位置
	        };
	        if (Object.keys(node).length > 0 && Math.abs(rotation) > 0) {
	            var rectNew = rect;
	            var center = { x: rectNew.x, y: rectNew.y }; // 中心点
	            Object.keys(controls).forEach(function(key) {
	                var value = controls[key];
	                var x0 = center.x - value.x;
	                var y0 = center.y - value.y;
	                var sin = Math.sin(-rotation);
	                var cos = Math.cos(-rotation);
	                var position_n_x = center.x - (x0 * cos - y0 * sin);
	                var position_n_y = center.y - (x0 * sin + y0 * cos);
	                controls[key].x = position_n_x;
	                controls[key].y = position_n_y;
	            });
	        }
	        return controls;
	    }
	
	    /**
	     * 根据中心点和旋转弧度，计算旋转后的点坐标
	     * @param  {[object|array]} points [原坐标]
	     * @param  {[object]}       center [中心点]
	     * @param  {[number]}       rotation [旋转弧度]
	     * @return {[type]}      [description]
	     */
	    function calculatePoints(points, center, rotation) {
	        var x = Array.isArray(points) ? points[0] : points.x;
	        var y = Array.isArray(points) ? points[1] : points.y;
	        var x0 = center.x - x;
	        var y0 = center.y - y;
	        var sin = Math.sin(-rotation);
	        var cos = Math.cos(-rotation);
	        var position_n_x = center.x - (x0 * cos - y0 * sin);
	        var position_n_y = center.y - (x0 * sin + y0 * cos);
	        if (Array.isArray(points)) {
	            return [position_n_x, position_n_y];
	        }
	        return {
	            x: position_n_x,
	            y: position_n_y
	        }
	    }
	
	    /**
	     * 获取获取两个图形的外面四个连接点
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    function getSoltPoints(node) {
	        return [
	            //top
	            [Math.round(node.getRect().width / 3 /10)*10, 0 ],
	            [Math.round(2*node.getRect().width / 3 /10)*10, 0 ],
	            //right
	            [node.getRect().width, Math.round(node.getRect().height / 3 /10)*10 ],
	            [node.getRect().width, Math.round(2*node.getRect().height / 3 /10)*10 ],
	            //bottom
	            [Math.round(node.getRect().width / 3 /10)*10, node.getRect().height ],
	            [Math.round(2*node.getRect().width / 3 /10)*10, node.getRect().height ],
	            //left
	            [0, Math.round(node.getRect().height / 3 /10)*10 ],
	            [0, Math.round(2*node.getRect().height / 3 /10)*10 ]
	
	        ]
	    }
	
	    /**
	     * 计算 p1 p2两点所连接的直线的角度
	     * @param  {[type]} p1 [description]
	     * @param  {[type]} p2 [description]
	     * @return {[type]}    [description]
	     */
	    function tangentRotation(p1, p2) {
	        return -Math.PI / 2 - Math.atan2(
	            p2.y - p1.y, p2.x - p1.x
	        );
	    }
	
	    /**
	     * 判断3点是否在一条直线上
	     * Tests if 3 points are coliniar with matrix determinants.
	     * If the determinat of matrix
	     * /         \
	     * | x1 y1 1 |
	     * | x2 y2 1 |
	     * | x3 y3 1 |
	     * \         /
	     * is zero it means that the points are colinear
	     *@param {Point} p1 - first point
	     *@param {Point} p2 - second point
	     *@param {Point} p3 - third point
	     * @param {Number} precission
	     *@return {Boolean} - true if coliniar and false if not
	     *@author Alex
	     *@see http://en.wikipedia.org/wiki/Determinant
	     *@see https://people.richland.edu/james/lecture/m116/matrices/applications.html
	     **/
	    function collinearity(p1, p2, p3, precission) {
	        var determinant = (p1.x * p2.y + p1.y * p3.x + p2.x * p3.y) - (p2.y * p3.x + p1.y * p2.x + p1.x * p3.y);
	
	        if (precission) {
	            return Math.abs(determinant) <= precission;
	        } else {
	            return determinant === 0;
	        }
	    }
	
	
	    /**
	     * 四舍五入 保存decimals的小数
	     **/
	    function enhancedRound(number, decimals) {
	        return Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);
	    }
	
	    /**
	     * 获取两点之间的长度
	     **/
	    function getLength(startPoint, endPoint) {
	        return Math.sqrt(Math.pow(startPoint.x - endPoint.x, 2) + Math.pow(startPoint.y - endPoint.y, 2));
	    }
	
	    /**
	     * 获取角度
	     * @param  {[type]} centerPoint  [description]
	     * @param  {[type]} outsidePoint [description]
	     * @param  {[type]} round        [description]
	     * @return {[type]}              [description]
	     */
	    function getAngle(centerPoint, outsidePoint, round) {
	        centerPoint.x = enhancedRound(centerPoint.x, 5);
	        centerPoint.y = enhancedRound(centerPoint.y, 5);
	        outsidePoint.x = enhancedRound(outsidePoint.x, 5);
	        outsidePoint.y = enhancedRound(outsidePoint.y, 5);
	        var angle = Math.atan((outsidePoint.x - centerPoint.x) / (outsidePoint.y - centerPoint.y));
	        angle = -angle;
	
	        //endAngle+=90;
	        if (outsidePoint.x >= centerPoint.x && outsidePoint.y >= centerPoint.y) {
	            angle += Math.PI;
	        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y >= centerPoint.y) {
	            angle += Math.PI;
	        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y <= centerPoint.y) {
	            angle += Math.PI * 2;
	        }
	        while (angle >= Math.PI * 2) {
	            angle -= Math.PI * 2;
	        }
	        if (isNaN(angle)) { //Nan
	            angle = 0; //we are at center point;
	        }
	        if (round) {
	            angle = Math.round(angle / round) * round
	        }
	        return angle;
	    }
	
	    function getRect(node, isCalcParent) {
	        var clipPath = node.clipPath;
	        var boundingRect = node.getBoundingRect();
	        // 节点裁剪后，以裁剪节点包围盒为准
	        if (clipPath) {
	            boundingRect = clipPath.getBoundingRect();
	        }
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];
	        points[1] = [boundingRect.width / 2, -boundingRect.height / 2];
	        points[2] = [boundingRect.width / 2, boundingRect.height / 2];
	        points[3] = [-boundingRect.width / 2, boundingRect.height / 2];
	        points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];
	
	        var positionX = node.position[0];
	        var positionY = node.position[1];
	        //这里要循环判断一把 有没有父节点 并且父节点不是根节点 然后进行相加
	        if (node.parent && node.parent.type === "GroupNode" && isCalcParent) {
	            positionX = positionX + node.parent.position[0];
	            positionY = positionY + node.parent.position[1];
	        }
	
	        var boundRect = new BoundingRect(
	                Number(positionX + boundingRect.x),   //注: 因事件为圆形  所以 x y 为圆心的位置  包围矩形要减去宽度一半
	                Number(positionY + boundingRect.y),
	                Number(boundingRect.width),
	                Number(boundingRect.height)
	            );
	        //中心点
	        var cx = Number(positionX) + Number(boundingRect.width) / 2 + Number(boundingRect.x);
	        var cy = Number(positionY) + Number(boundingRect.height) / 2 + Number(boundingRect.y);
	        return {
	            x: Number(cx),
	            y: Number(cy),
	            width: Number(boundingRect.width),
	            height: Number(boundingRect.height),
	            points: points,
	            boundingRect: boundRect
	        };
	    }
	
	    var StackedMap = {
	        createNew: function() {
	            var stack = [];
	
	            return {
	                add: function(key, value) {
	                    var arrKey = this.get(key);
	                    arrKey.push(value)
	
	                },
	                get: function(key) {
	                    for (var i = 0; i < stack.length; i++) {
	                        if (key == stack[i].key) {
	                            return stack[i].value;
	                        }
	                    }
	                    //如果没有找到的话，则创建一个新的数组
	                    var value = [];
	                    stack.push({ key: key, value: value });
	                    return value;
	                },
	                keys: function() {
	                    var keys = [];
	                    for (var i = 0; i < stack.length; i++) {
	                        keys.push(stack[i].key);
	                    }
	                    return keys;
	                },
	                top: function() {
	                    return stack[stack.length - 1];
	                },
	                remove: function(key) {
	                    var idx = -1;
	                    for (var i = 0; i < stack.length; i++) {
	                        if (key == stack[i].key) {
	                            idx = i;
	                            break;
	                        }
	                    }
	                    return stack.splice(idx, 1)[0];
	                },
	                removeItem: function(key, item) {
	                    var arrKey = this.get(key);
	                    var index = zrUtil.indexOf(arrKey, item);
	                    arrKey.splice(index, 1);
	
	                },
	                removeTop: function() {
	                    return stack.splice(stack.length - 1, 1)[0];
	                },
	                length: function() {
	                    return stack.length;
	                },
	                clear: function() {
	                    stack.splice(0, stack.length);
	                }
	            };
	        }
	    };
	
	    function randomColor() {
	        var arrHex = ["0", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d"],
	            strHex = "#",
	            index;
	        for (var i = 0; i < 6; i++) {
	            index = Math.round(Math.random() * 15);
	            strHex += arrHex[index];
	        }
	        return strHex;
	    }
	
	    function isUndefined(obj) {
	        return obj === void 0;
	    }
	
	    function collinearReduction (v) {
	        var r = [];
	
	        if(v.length < 3){
	            return Point.cloneArray(v);
	        }
	
	        r.push( v[0].clone() );
	        for(var i=1; i < v.length-1; i++){
	            if( (v[i-1].x == v[i].x && v[i].x == v[i+1].x)  ||  (v[i-1].y == v[i].y && v[i].y == v[i+1].y) )
	            {
	                continue;
	            }
	            else{
	                r.push( v[i].clone() );
	            }
	        }
	        r.push( v[v.length-1].clone() );
	
	        return r;
	    }
	
	    // By default, Underscore uses ERB-style template delimiters, change the
	    // following template settings to use alternative delimiters.
	    var templateSettings = {
	        evaluate: /<%([\s\S]+?)%>/g,
	        interpolate: /<%=([\s\S]+?)%>/g,
	        escape: /<%-([\s\S]+?)%>/g
	    };
	
	    // When customizing `templateSettings`, if you don't want to define an
	    // interpolation, evaluation or escaping regex, we need one that is
	    // guaranteed not to match.
	    var noMatch = /(.)^/;
	
	    // Certain characters need to be escaped so that they can be put into a
	    // string literal.
	    var escapes = {
	        "'": "'",
	        '\\': '\\',
	        '\r': 'r',
	        '\n': 'n',
	        '\u2028': 'u2028',
	        '\u2029': 'u2029'
	    };
	
	    var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
	
	    var escapeChar = function(match) {
	        return '\\' + escapes[match];
	    };
	
	    // JavaScript micro-templating, similar to John Resig's implementation.
	    // Underscore templating handles arbitrary delimiters, preserves whitespace,
	    // and correctly escapes quotes within interpolated code.
	    // NB: `oldSettings` only exists for backwards compatibility.
	    function template(text, settings, oldSettings) {
	        if (!settings && oldSettings) settings = oldSettings;
	        settings = settings || {};
	        settings = zrUtil.defaults(settings, templateSettings, true);
	
	        // Combine delimiters into one regular expression via alternation.
	        var matcher = RegExp([
	            (settings.escape || noMatch).source,
	            (settings.interpolate || noMatch).source,
	            (settings.evaluate || noMatch).source
	        ].join('|') + '|$', 'g');
	
	        // Compile the template source, escaping string literals appropriately.
	        var index = 0;
	        var source = "__p+='";
	        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	            source += text.slice(index, offset).replace(escaper, escapeChar);
	            index = offset + match.length;
	
	            if (escape) {
	                source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	            } else if (interpolate) {
	                source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	            } else if (evaluate) {
	                source += "';\n" + evaluate + "\n__p+='";
	            }
	
	            // Adobe VMs need the match returned to produce the correct offest.
	            return match;
	        });
	        source += "';\n";
	
	        // If a variable is not specified, place data values in local scope.
	        if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
	
	        source = "var __t,__p='',__j=Array.prototype.join," +
	            "print=function(){__p+=__j.call(arguments,'');};\n" +
	            source + 'return __p;\n';
	
	        try {
	            var render = new Function(settings.variable || 'obj', source);
	        } catch (e) {
	            e.source = source;
	            throw e;
	        }
	
	        var template = function(data) {
	            return render.call(this, data);
	        };
	
	        // Provide the compiled source as a convenience for precompilation.
	        var argument = settings.variable || 'obj';
	        template.source = 'function(' + argument + '){\n' + source + '}';
	
	        return template;
	    }
	
	    function isEmpty(obj) {
	        if (obj == null) return true;
	        if (zrUtil.isArrayLike(obj) && (zrUtil.isArray(obj) || zrUtil.isString(obj))) return obj.length === 0;
	    }
	    function mergeOpt(target, source, overwrite, exclude) {
	        // We should escapse that source is string
	        // and enter for ... in ...
	        if (!zrUtil.isObject(source) || !zrUtil.isObject(target)) {
	          return overwrite ? zrUtil.clone(source) : target;
	        }
	
	        for (var key in source) {
	          if (source.hasOwnProperty(key)) {
	            var targetProp = target[key];
	            var sourceProp = source[key];
	
	            if (zrUtil.isObject(sourceProp) && zrUtil.isObject(targetProp) && !zrUtil.isArray(sourceProp) && !zrUtil.isArray(targetProp) && !zrUtil.isDom(sourceProp) && !zrUtil.isDom(targetProp) && !zrUtil.isBuiltInObject(sourceProp) && !zrUtil.isBuiltInObject(targetProp) && !zrUtil.isPrimitive(sourceProp) && !zrUtil.isPrimitive(targetProp)) {
	              // 如果需要递归覆盖，就递归调用merge
	              mergeOpt(targetProp, sourceProp, overwrite, exclude);
	            } else if (overwrite || !(key in target)) {
	              // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
	              // NOTE，在 target[key] 不存在的时候也是直接覆盖
	                if (key !== exclude) {
	                    target[key] = zrUtil.clone(source[key], true);
	                }
	            }
	          }
	        }
	        return target;
	    }
	    function Class() {}
	    Class.extend = function(proto) {
	        var base = function() {},
	            member,
	            that = this,
	            subclass = proto && proto.init ? proto.init : function () {
	                that.apply(this, arguments);
	            },
	            fn;
	
	        base.prototype = that.prototype;
	        fn = subclass.fn = subclass.prototype = new base();
	
	        for (member in proto) {
	            if (proto[member] != null && proto[member].constructor === Object) {
	                // Merge object members
	                fn[member] = zrUtil.mergeAll([{}, base.prototype[member], proto[member]],true);
	            } else {
	                fn[member] = proto[member];
	            }
	        }
	
	        fn.constructor = subclass;
	        subclass.extend = that.extend;
	
	        return subclass;
	    };
	
	    module.exports = {
	        inherits: inherits,
	        getUUID: getUUID,
	        distance: distance,
	        getPolylineLength: getPolylineLength,
	        max: max,
	        min: min,
	        isEmpty: isEmpty,
	        mergeOpt: mergeOpt,
	        orthogonalPath: orthogonalPath,
	        polylineIntersectsRectangle: polylineIntersectsRectangle,
	        scorePath: scorePath,
	        forwardPath: forwardPath,
	        traslatePoints: traslatePoints,
	        getEndPoint: getEndPoint,
	        getConnectorPoints: getConnectorPoints,
	        getConnectorControls: getConnectorControls,
	        calculatePoints: calculatePoints,
	        tangentRotation: tangentRotation,
	        collinearity: collinearity,
	        translationMatrix: translationMatrix,
	        scaleMatrix: scaleMatrix,
	        round: enhancedRound,
	        getLength: getLength,
	        getAngle: getAngle,
	        getRect: getRect,
	        StackedMap: StackedMap,
	        getMaxLineLength: getMaxLineLength,
	        randomColor: randomColor,
	        template: template,
	        isUndefined: isUndefined,
	        getSoltPoints:getSoltPoints,
	        collinearReduction: collinearReduction,
	        Class:Class
	    };
	


/***/ }),
/* 66 */
/***/ (function(module, exports) {

	
	
	    /**
	      * Creates an instance of Point
	      *
	      *
	      * @constructor
	      * @this {Point}
	      * @param {Number} x The x coordinate of point.
	      * @param {Number} y The y coordinate of point.
	      * Note: Even if it is named Point this class should be named Dot as Dot is closer
	      * then Point from math perspective.
	      **/
	    function Point(x, y){
	        /**The x coordinate of point*/
	        this.x = x;
	
	        /**The y coordinate of point*/
	        this.y = y;
	
	
	    }
	
	    /**Creates a {Point} out of JSON parsed object
	     *@param {JSONObject} o - the JSON parsed object
	     *@return {Point} a newly constructed Point
	     **/
	    Point.load = function(o){
	        var newPoint = new Point(Number(o.x), Number(o.y));
	        return newPoint;
	    };
	
	
	    /**Creates an array of points from an array of {JSONObject}s
	     *@param {Array} v - the array of JSONObjects
	     *@return an {Array} of {Point}s
	     **/
	    Point.loadArray = function(v){
	        var newPoints = [];
	        for(var i=0; i< v.length; i++){
	            newPoints.push(Point.load(v[i]));
	        }
	        return newPoints;
	    };
	
	
	    /**Clones an array of points
	     *@param {Array} v - the array of {Point}s
	     *@return an {Array} of {Point}s
	     **/
	    Point.cloneArray = function(v){
	        var newPoints = [];
	        for(var i=0; i< v.length; i++){
	            newPoints.push(v[i].clone());
	        }
	        return newPoints;
	    };
	
	    Point.prototype = {
	        constructor : Point,
	
	        transform:function(matrix){
	            var oldX = this.x;
	            var oldY = this.y;
	            this.x = matrix[0][0] * oldX + matrix[0][1] * oldY + matrix[0][2];
	            this.y = matrix[1][0] * oldX + matrix[1][1] * oldY + matrix[1][2];
	        },
	
	        /**Tests if this point is similar to other point
	         *@param {Point} anotherPoint - the other point
	         **/
	        equals:function(anotherPoint){
	            if(! (anotherPoint instanceof Point) ){
	                return false;
	            }
	            return (this.x == anotherPoint.x)
	            && (this.y == anotherPoint.y)
	        },
	
	        /**Clone current Point
	         **/
	        clone: function(){
	            var newPoint = new Point(this.x, this.y);
	            return newPoint;
	        },
	
	        add: function(point) {
	            this.x = this.x + point.x;
	            this.y = this.y + point.y;
	            return this;
	        },
	
	        /**Tests to see if a point (x, y) is within a range of current Point
	         *@param {Numeric} x - the x coordinate of tested point
	         *@param {Numeric} y - the x coordinate of tested point
	         *@param {Numeric} radius - the radius of the vicinity
	         **/
	        near:function(x, y, radius){
	            var distance = Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));
	
	            return (distance <= radius);
	        },
	
	        contains: function(x,y){
	            return this.x == x && this.y == y;
	        },
	
	        toString:function(){
	            return '[' + this.x + ',' + this.y + ']';
	        },
	
	        getPoints:function(){
	            return [this];
	        }
	    };
	    module.exports = Point;


/***/ }),
/* 67 */
/***/ (function(module, exports) {

	
	
	    /**
	      * Creates an instance of a Line. A Line is actually a segment and not a pure
	      * geometrical Line
	      *
	      * @constructor
	      * @this {Line}
	      * @param {Point} startPoint - starting point of the line
	      * @param {Point} endPoint - the ending point of the line
	      **/
	    function Line(startPoint, endPoint){
	        /**Starting {@link Point} of the line*/
	        this.startPoint = startPoint;
	
	        /**Ending {@link Point} of the line*/
	        this.endPoint = endPoint;
	
	        /**Serialization type*/
	        this.oType = 'Line'; //object type used for JSON deserialization
	    }
	
	    /**Creates a {Line} out of JSON parsed object
	     *@param {JSONObject} o - the JSON parsed object
	     *@return {Line} a newly constructed Line
	     **/
	    Line.load = function(o){
	        var newLine = new Line(
	            Point.load(o.startPoint),
	            Point.load(o.endPoint)
	        );
	
	        return newLine;
	    };
	
	    Line.prototype = {
	        contructor: Line,
	
	
	
	        clone:function(){
	            var ret = new Line(this.startPoint.clone(), this.endPoint.clone());
	            return ret;
	        },
	
	        equals:function(anotherLine){
	            if(!anotherLine instanceof Line){
	                return false;
	            }
	            return this.startPoint.equals(anotherLine.startPoint)
	            && this.endPoint.equals(anotherLine.endPoint)
	        },
	
	        /** Tests to see if a point belongs to this line (not as infinite line but more like a segment)
	         * Algorithm: Compute line's equation and see if (x, y) verifies it.
	         * @param {Number} x - the X coordinates
	         * @param {Number} y - the Y coordinates
	         **/
	        contains: function(x, y){
	            // if the point is inside rectangle bounds of the segment
	            if (Math.min(this.startPoint.x, this.endPoint.x) <= x
	                && x <= Math.max(this.startPoint.x, this.endPoint.x)
	                && Math.min(this.startPoint.y, this.endPoint.y) <= y
	                && y <= Math.max(this.startPoint.y, this.endPoint.y)) {
	
	                // check for vertical line
	                if (this.startPoint.x == this.endPoint.x) {
	                    return x == this.startPoint.x;
	                } else { // usual (not vertical) line can be represented as y = a * x + b
	                    var a = (this.endPoint.y - this.startPoint.y) / (this.endPoint.x - this.startPoint.x);
	                    var b = this.startPoint.y - a * this.startPoint.x;
	                    return y == a * x + b;
	                }
	            } else {
	                return false;
	            }
	        },
	
	        /*
	         *See if we are near a {Line} by a certain radius (also includes the extremities into computation)
	         *@param {Number} x - the x coordinates
	         *@param {Number} y - the y coordinates
	         *@param {Number} radius - the radius to search for
	         *@see http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
	         *@see "Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227"
	         **/
	        near:function(x,y,radius){
	
	            if(this.endPoint.x === this.startPoint.x){ //Vertical line, so the vicinity area is a rectangle
	                return ( (this.startPoint.y-radius<=y && this.endPoint.y+radius>=y)
	                        || (this.endPoint.y-radius<=y && this.startPoint.y+radius>=y))
	                && x > this.startPoint.x - radius && x < this.startPoint.x + radius ;
	            }
	
	            if(this.startPoint.y === this.endPoint.y){ //Horizontal line, so the vicinity area is a rectangle
	                return ( (this.startPoint.x - radius<=x && this.endPoint.x+radius>=x)
	                        || (this.endPoint.x-radius<=x && this.startPoint.x+radius>=x))
	                        && y>this.startPoint.y-radius && y<this.startPoint.y+radius ;
	            }
	
	
	            var startX = Math.min(this.endPoint.x,this.startPoint.x);
	            var startY = Math.min(this.endPoint.y,this.startPoint.y);
	            var endX = Math.max(this.endPoint.x,this.startPoint.x);
	            var endY = Math.max(this.endPoint.y,this.startPoint.y);
	
	            /*We will compute the distance from point to the line
	             * by using the algorithm from
	             * http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
	             * */
	
	            //First we need to find a,b,c of the line equation ax + by + c = 0
	            var a = this.endPoint.y - this.startPoint.y;
	            var b = this.startPoint.x - this.endPoint.x;
	            var c = -(this.startPoint.x * this.endPoint.y - this.endPoint.x * this.startPoint.y);
	
	            //Secondly we get the distance "Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227"
	            var d = Math.abs( (a*x + b*y + c) / Math.sqrt(Math.pow(a,2) + Math.pow(b,2)) );
	
	            //Thirdly we get coordinates of closest line's point to target point
	            //http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Cartesian_coordinates
	            var closestX = (b * (b*x - a*y) - a*c) / ( Math.pow(a,2) + Math.pow(b,2) );
	            var closestY = (a * (-b*x + a*y) - b*c) / ( Math.pow(a,2) + Math.pow(b,2) );
	
	            var r = ( d <= radius && endX>=closestX && closestX>=startX && endY>=closestY && closestY>=startY ) //the projection of the point falls INSIDE of the segment
	                || this.startPoint.near(x,y,radius) || this.endPoint.near(x,y,radius); //the projection of the point falls OUTSIDE of the segment
	
	            return  r;
	
	        },
	
	        /**we need to create a new array each time, or we will affect the actual shape*/
	        getPoints:function(){
	            var points = [];
	            points.push(this.startPoint);
	            points.push(this.endPoint);
	            return points;
	        },
	
	        /**Return the {Point} corresponding the t certain t value
	         * @param {Number} t the value of parameter t, where t in [0,1], t is like a percent*/
	        getPoint: function(t){
	            var Xp = t * (this.endPoint.x - this.startPoint.x) + this.startPoint.x;
	            var Yp = t * (this.endPoint.y - this.startPoint.y) + this.startPoint.y;
	
	            return new Point(Xp, Yp);
	        },
	
	        // /**
	        //  * Returns the middle of the line
	        //  * @return {Point} the middle point
	        //  * */
	        // getMiddle : function(){
	        //     return Util.getMiddle(this.startPoint, this.endPoint);
	        // },
	
	
	        // getLength : function(){
	        //     return Util.getLength(this.startPoint, this.endPoint);
	        // },
	
	        // /**
	        //  *Get bounds for this line
	        //  *@author Alex Gheorghiu <alex@scriptoid.com>
	        //  **/
	        // getBounds:function(){
	        //     return Util.getBounds(this.getPoints());
	        // },
	
	        /**String representation*/
	        toString:function(){
	            return 'line(' + this.startPoint + ',' + this.endPoint + ')';
	        }
	    };
	    module.exports = Line;
	
	


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(5);
	
	    var apiList = [
	        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction',
	        'on', 'off', 'trigger', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption',
	        "remove", "_getParentZr", "changeSelectConnectorType","_addGroupNode"
	    ];
	
	    function ExtensionAPI(instance) {
	        zrUtil.each(apiList, function (name) {
	            this[name] = zrUtil.bind(instance[name], instance);
	        }, this);
	    }
	
	    module.exports = ExtensionAPI;
	


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	var guid = __webpack_require__(11);
	
	var env = __webpack_require__(50);
	
	var zrUtil = __webpack_require__(5);
	
	var Handler = __webpack_require__(70);
	
	var Storage = __webpack_require__(71);
	
	var Painter = __webpack_require__(73);
	
	var Animation = __webpack_require__(76);
	
	var HandlerProxy = __webpack_require__(78);
	
	/*!
	* ZRender, a high performance 2d drawing library.
	*
	* Copyright (c) 2013, Baidu Inc.
	* All rights reserved.
	*
	* LICENSE
	* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
	*/
	var useVML = !env.canvasSupported;
	var painterCtors = {
	  canvas: Painter
	};
	var instances = {}; // ZRender实例map索引
	
	/**
	 * @type {string}
	 */
	
	var version = '3.7.4';
	/**
	 * Initializing a zrender instance
	 * @param {HTMLElement} dom
	 * @param {Object} opts
	 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	 * @param {number} [opts.devicePixelRatio]
	 * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
	 * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
	 * @return {module:zrender/ZRender}
	 */
	
	function init(dom, opts) {
	  var zr = new ZRender(guid(), dom, opts);
	  instances[zr.id] = zr;
	  return zr;
	}
	/**
	 * Dispose zrender instance
	 * @param {module:zrender/ZRender} zr
	 */
	
	
	function dispose(zr) {
	  if (zr) {
	    zr.dispose();
	  } else {
	    for (var key in instances) {
	      if (instances.hasOwnProperty(key)) {
	        instances[key].dispose();
	      }
	    }
	
	    instances = {};
	  }
	
	  return this;
	}
	/**
	 * Get zrender instance by id
	 * @param {string} id zrender instance id
	 * @return {module:zrender/ZRender}
	 */
	
	
	function getInstance(id) {
	  return instances[id];
	}
	
	function registerPainter(name, Ctor) {
	  painterCtors[name] = Ctor;
	}
	
	function delInstance(id) {
	  delete instances[id];
	}
	/**
	 * @module zrender/ZRender
	 */
	
	/**
	 * @constructor
	 * @alias module:zrender/ZRender
	 * @param {string} id
	 * @param {HTMLElement} dom
	 * @param {Object} opts
	 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	 * @param {number} [opts.devicePixelRatio]
	 * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
	 * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
	 */
	
	
	var ZRender = function (id, dom, opts) {
	  opts = opts || {};
	  /**
	   * @type {HTMLDomElement}
	   */
	
	  this.dom = dom;
	  /**
	   * @type {string}
	   */
	
	  this.id = id;
	  var self = this;
	  var storage = new Storage();
	  var rendererType = opts.renderer; // TODO WebGL
	
	  if (useVML) {
	    if (!painterCtors.vml) {
	      throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
	    }
	
	    rendererType = 'vml';
	  } else if (!rendererType || !painterCtors[rendererType]) {
	    rendererType = 'canvas';
	  }
	
	  var painter = new painterCtors[rendererType](dom, storage, opts);
	  this.storage = storage;
	  this.painter = painter;
	  var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;
	  this.handler = new Handler(storage, painter, handerProxy, painter.root);
	  /**
	   * @type {module:zrender/animation/Animation}
	   */
	
	  this.animation = new Animation({
	    stage: {
	      update: zrUtil.bind(this.flush, this)
	    }
	  });
	  this.animation.start();
	  /**
	   * @type {boolean}
	   * @private
	   */
	
	  this._needsRefresh; // 修改 storage.delFromStorage, 每次删除元素之前删除动画
	  // FIXME 有点ugly
	
	  var oldDelFromStorage = storage.delFromStorage;
	  var oldAddToStorage = storage.addToStorage;
	
	  storage.delFromStorage = function (el) {
	    oldDelFromStorage.call(storage, el);
	    el && el.removeSelfFromZr(self);
	  };
	
	  storage.addToStorage = function (el) {
	    oldAddToStorage.call(storage, el);
	    el.addSelfToZr(self);
	  };
	};
	
	ZRender.prototype = {
	  constructor: ZRender,
	
	  /**
	   * 获取实例唯一标识
	   * @return {string}
	   */
	  getId: function () {
	    return this.id;
	  },
	
	  /**
	   * 添加元素
	   * @param  {module:zrender/Element} el
	   */
	  add: function (el) {
	    this.storage.addRoot(el);
	    this._needsRefresh = true;
	  },
	
	  /**
	   * 删除元素
	   * @param  {module:zrender/Element} el
	   */
	  remove: function (el) {
	    this.storage.delRoot(el);
	    this._needsRefresh = true;
	  },
	
	  /**
	   * Change configuration of layer
	   * @param {string} zLevel
	   * @param {Object} config
	   * @param {string} [config.clearColor=0] Clear color
	   * @param {string} [config.motionBlur=false] If enable motion blur
	   * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
	  */
	  configLayer: function (zLevel, config) {
	    this.painter.configLayer(zLevel, config);
	    this._needsRefresh = true;
	  },
	
	  /**
	   * Repaint the canvas immediately
	   */
	  refreshImmediately: function () {
	    // var start = new Date();
	    // Clear needsRefresh ahead to avoid something wrong happens in refresh
	    // Or it will cause zrender refreshes again and again.
	    this._needsRefresh = false;
	    this.painter.refresh();
	    /**
	     * Avoid trigger zr.refresh in Element#beforeUpdate hook
	     */
	
	    this._needsRefresh = false; // var end = new Date();
	    // var log = document.getElementById('log');
	    // if (log) {
	    //     log.innerHTML = log.innerHTML + '<br>' + (end - start);
	    // }
	  },
	
	  /**
	   * Mark and repaint the canvas in the next frame of browser
	   */
	  refresh: function () {
	    this._needsRefresh = true;
	  },
	
	  /**
	   * Perform all refresh
	   */
	  flush: function () {
	    if (this._needsRefresh) {
	      this.refreshImmediately();
	    }
	
	    if (this._needsRefreshHover) {
	      this.refreshHoverImmediately();
	    }
	  },
	
	  /**
	   * Add element to hover layer
	   * @param  {module:zrender/Element} el
	   * @param {Object} style
	   */
	  addHover: function (el, style) {
	    if (this.painter.addHover) {
	      this.painter.addHover(el, style);
	      this.refreshHover();
	    }
	  },
	
	  /**
	   * Add element from hover layer
	   * @param  {module:zrender/Element} el
	   */
	  removeHover: function (el) {
	    if (this.painter.removeHover) {
	      this.painter.removeHover(el);
	      this.refreshHover();
	    }
	  },
	
	  /**
	   * Clear all hover elements in hover layer
	   * @param  {module:zrender/Element} el
	   */
	  clearHover: function () {
	    if (this.painter.clearHover) {
	      this.painter.clearHover();
	      this.refreshHover();
	    }
	  },
	
	  /**
	   * Refresh hover in next frame
	   */
	  refreshHover: function () {
	    this._needsRefreshHover = true;
	  },
	
	  /**
	   * Refresh hover immediately
	   */
	  refreshHoverImmediately: function () {
	    this._needsRefreshHover = false;
	    this.painter.refreshHover && this.painter.refreshHover();
	  },
	
	  /**
	   * Resize the canvas.
	   * Should be invoked when container size is changed
	   * @param {Object} [opts]
	   * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
	   * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
	   */
	  resize: function (opts) {
	    opts = opts || {};
	    this.painter.resize(opts.width, opts.height);
	    this.handler.resize();
	  },
	
	  /**
	   * Stop and clear all animation immediately
	   */
	  clearAnimation: function () {
	    this.animation.clear();
	  },
	
	  /**
	   * Get container width
	   */
	  getWidth: function () {
	    return this.painter.getWidth();
	  },
	
	  /**
	   * Get container height
	   */
	  getHeight: function () {
	    return this.painter.getHeight();
	  },
	
	  /**
	   * Export the canvas as Base64 URL
	   * @param {string} type
	   * @param {string} [backgroundColor='#fff']
	   * @return {string} Base64 URL
	   */
	  // toDataURL: function(type, backgroundColor) {
	  //     return this.painter.getRenderedCanvas({
	  //         backgroundColor: backgroundColor
	  //     }).toDataURL(type);
	  // },
	
	  /**
	   * Converting a path to image.
	   * It has much better performance of drawing image rather than drawing a vector path.
	   * @param {module:zrender/graphic/Path} e
	   * @param {number} width
	   * @param {number} height
	   */
	  pathToImage: function (e, dpr) {
	    return this.painter.pathToImage(e, dpr);
	  },
	
	  /**
	   * Set default cursor
	   * @param {string} [cursorStyle='default'] 例如 crosshair
	   */
	  setCursorStyle: function (cursorStyle) {
	    this.handler.setCursorStyle(cursorStyle);
	  },
	
	  /**
	   * Find hovered element
	   * @param {number} x
	   * @param {number} y
	   * @return {Object} {target, topTarget}
	   */
	  findHover: function (x, y) {
	    return this.handler.findHover(x, y);
	  },
	
	  /**
	   * Bind event
	   *
	   * @param {string} eventName Event name
	   * @param {Function} eventHandler Handler function
	   * @param {Object} [context] Context object
	   */
	  on: function (eventName, eventHandler, context) {
	    this.handler.on(eventName, eventHandler, context);
	  },
	
	  /**
	   * Unbind event
	   * @param {string} eventName Event name
	   * @param {Function} [eventHandler] Handler function
	   */
	  off: function (eventName, eventHandler) {
	    this.handler.off(eventName, eventHandler);
	  },
	
	  /**
	   * Trigger event manually
	   *
	   * @param {string} eventName Event name
	   * @param {event=} event Event object
	   */
	  trigger: function (eventName, event) {
	    this.handler.trigger(eventName, event);
	  },
	
	  /**
	   * Clear all objects and the canvas.
	   */
	  clear: function () {
	    this.storage.delRoot();
	    this.painter.clear();
	  },
	
	  /**
	   * Dispose self.
	   */
	  dispose: function () {
	    this.animation.stop();
	    this.clear();
	    this.storage.dispose();
	    this.painter.dispose();
	    this.handler.dispose();
	    this.animation = this.storage = this.painter = this.handler = null;
	    delInstance(this.id);
	  }
	};
	exports.version = version;
	exports.init = init;
	exports.dispose = dispose;
	exports.getInstance = getInstance;
	exports.registerPainter = registerPainter;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(5);
	
	var vec2 = __webpack_require__(15);
	
	var Draggable = __webpack_require__(43);
	
	var Eventful = __webpack_require__(12);
	
	/**
	 * Handler
	 * @module zrender/Handler
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (shenyi.914@gmail.com)
	 */
	var SILENT = 'silent';
	
	function makeEventPacket(eveType, targetInfo, event) {
	  return {
	    type: eveType,
	    event: event,
	    // target can only be an element that is not silent.
	    target: targetInfo.target,
	    // topTarget can be a silent element.
	    topTarget: targetInfo.topTarget,
	    cancelBubble: false,
	    offsetX: event.zrX,
	    offsetY: event.zrY,
	    gestureEvent: event.gestureEvent,
	    pinchX: event.pinchX,
	    pinchY: event.pinchY,
	    pinchScale: event.pinchScale,
	    wheelDelta: event.zrDelta,
	    zrByTouch: event.zrByTouch,
	    which: event.which
	  };
	}
	
	function EmptyProxy() {}
	
	EmptyProxy.prototype.dispose = function () {};
	
	var handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
	/**
	 * @alias module:zrender/Handler
	 * @constructor
	 * @extends module:zrender/mixin/Eventful
	 * @param {module:zrender/Storage} storage Storage instance.
	 * @param {module:zrender/Painter} painter Painter instance.
	 * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.
	 * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).
	 */
	
	var Handler = function (storage, painter, proxy, painterRoot) {
	  Eventful.call(this);
	  this.storage = storage;
	  this.painter = painter;
	  this.painterRoot = painterRoot;
	  proxy = proxy || new EmptyProxy();
	  /**
	   * Proxy of event. can be Dom, WebGLSurface, etc.
	   */
	
	  this.proxy = proxy; // Attach handler
	
	  proxy.handler = this;
	  /**
	   * {target, topTarget, x, y}
	   * @private
	   * @type {Object}
	   */
	
	  this._hovered = {};
	  /**
	   * @private
	   * @type {Date}
	   */
	
	  this._lastTouchMoment;
	  /**
	   * @private
	   * @type {number}
	   */
	
	  this._lastX;
	  /**
	   * @private
	   * @type {number}
	   */
	
	  this._lastY;
	  Draggable.call(this);
	  util.each(handlerNames, function (name) {
	    proxy.on && proxy.on(name, this[name], this);
	  }, this);
	};
	
	Handler.prototype = {
	  constructor: Handler,
	  mousemove: function (event) {
	    var x = event.zrX;
	    var y = event.zrY;
	    var lastHovered = this._hovered;
	    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call
	    // (like 'setOption' or 'dispatchAction') in event handlers, we should find
	    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.
	    // See #6198.
	
	    if (lastHoveredTarget && !lastHoveredTarget.__zr) {
	      lastHovered = this.findHover(lastHovered.x, lastHovered.y);
	      lastHoveredTarget = lastHovered.target;
	    }
	
	    var hovered = this._hovered = this.findHover(x, y);
	    var hoveredTarget = hovered.target;
	    var proxy = this.proxy;
	    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element
	
	    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
	      this.dispatchToElement(lastHovered, 'mouseout', event);
	    } // Mouse moving on one element
	
	
	    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element
	
	    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
	      this.dispatchToElement(hovered, 'mouseover', event);
	    }
	  },
	  mouseout: function (event) {
	    this.dispatchToElement(this._hovered, 'mouseout', event); // There might be some doms created by upper layer application
	    // at the same level of painter.getViewportRoot() (e.g., tooltip
	    // dom created by echarts), where 'globalout' event should not
	    // be triggered when mouse enters these doms. (But 'mouseout'
	    // should be triggered at the original hovered element as usual).
	
	    var element = event.toElement || event.relatedTarget;
	    var innerDom;
	
	    do {
	      element = element && element.parentNode;
	    } while (element && element.nodeType != 9 && !(innerDom = element === this.painterRoot));
	
	    !innerDom && this.trigger('globalout', {
	      event: event
	    });
	  },
	
	  /**
	   * Resize
	   */
	  resize: function (event) {
	    this._hovered = {};
	  },
	
	  /**
	   * Dispatch event
	   * @param {string} eventName
	   * @param {event=} eventArgs
	   */
	  dispatch: function (eventName, eventArgs) {
	    var handler = this[eventName];
	    handler && handler.call(this, eventArgs);
	  },
	
	  /**
	   * Dispose
	   */
	  dispose: function () {
	    this.proxy.dispose();
	    this.storage = this.proxy = this.painter = null;
	  },
	
	  /**
	   * 设置默认的cursor style
	   * @param {string} [cursorStyle='default'] 例如 crosshair
	   */
	  setCursorStyle: function (cursorStyle) {
	    var proxy = this.proxy;
	    proxy.setCursor && proxy.setCursor(cursorStyle);
	  },
	
	  /**
	   * 事件分发代理
	   *
	   * @private
	   * @param {Object} targetInfo {target, topTarget} 目标图形元素
	   * @param {string} eventName 事件名称
	   * @param {Object} event 事件对象
	   */
	  dispatchToElement: function (targetInfo, eventName, event) {
	    targetInfo = targetInfo || {};
	    var el = targetInfo.target;
	
	    if (el && el.silent) {
	      return;
	    }
	
	    var eventHandler = 'on' + eventName;
	    var eventPacket = makeEventPacket(eventName, targetInfo, event);
	
	    while (el) {
	      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
	      el.trigger(eventName, eventPacket);
	      el = el.parent;
	
	      if (eventPacket.cancelBubble) {
	        break;
	      }
	    }
	
	    if (!eventPacket.cancelBubble) {
	      // 冒泡到顶级 zrender 对象
	      this.trigger(eventName, eventPacket); // 分发事件到用户自定义层
	      // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在
	
	      this.painter && this.painter.eachOtherLayer(function (layer) {
	        if (typeof layer[eventHandler] == 'function') {
	          layer[eventHandler].call(layer, eventPacket);
	        }
	
	        if (layer.trigger) {
	          layer.trigger(eventName, eventPacket);
	        }
	      });
	    }
	  },
	
	  /**
	   * @private
	   * @param {number} x
	   * @param {number} y
	   * @param {module:zrender/graphic/Displayable} exclude
	   * @return {model:zrender/Element}
	   * @method
	   */
	  findHover: function (x, y, exclude) {
	    var list = this.storage.getDisplayList();
	    var out = {
	      x: x,
	      y: y
	    };
	
	    for (var i = list.length - 1; i >= 0; i--) {
	      var hoverCheckResult;
	
	      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode
	      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {
	        !out.topTarget && (out.topTarget = list[i]);
	
	        if (hoverCheckResult !== SILENT) {
	          out.target = list[i];
	          break;
	        }
	      }
	    }
	
	    return out;
	  }
	}; // Common handlers
	
	util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
	  Handler.prototype[name] = function (event) {
	    // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover
	    var hovered = this.findHover(event.zrX, event.zrY);
	    var hoveredTarget = hovered.target;
	
	    if (name === 'mousedown') {
	      this._downEl = hoveredTarget;
	      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup
	
	      this._upEl = hoveredTarget;
	    } else if (name === 'mosueup') {
	      this._upEl = hoveredTarget;
	    } else if (name === 'click') {
	      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,
	      // including the case that `mousedown` - `mousemove` - `mouseup`,
	      // which should be filtered, otherwise it will bring trouble to
	      // pan and zoom.
	      || !this._downPoint // Arbitrary value
	      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {
	        return;
	      }
	
	      this._downPoint = null;
	    }
	
	    this.dispatchToElement(hovered, name, event);
	  };
	});
	
	function isHover(displayable, x, y) {
	  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
	    var el = displayable;
	    var isSilent;
	
	    while (el) {
	      // If clipped by ancestor.
	      // FIXME: If clipPath has neither stroke nor fill,
	      // el.clipPath.contain(x, y) will always return false.
	      if (el.clipPath && !el.clipPath.contain(x, y)) {
	        return false;
	      }
	
	      if (el.silent) {
	        isSilent = true;
	      }
	
	      el = el.parent;
	    }
	
	    return isSilent ? SILENT : true;
	  }
	
	  return false;
	}
	
	util.mixin(Handler, Eventful);
	util.mixin(Handler, Draggable);
	var _default = Handler;
	module.exports = _default;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(5);
	
	var env = __webpack_require__(50);
	
	var Group = __webpack_require__(44);
	
	var timsort = __webpack_require__(72);
	
	/**
	 * Storage内容仓库模块
	 * @module zrender/Storage
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 * @author errorrik (errorrik@gmail.com)
	 * @author pissang (https://github.com/pissang/)
	 */
	// Use timsort because in most case elements are partially sorted
	// https://jsfiddle.net/pissang/jr4x7mdm/8/
	function shapeCompareFunc(a, b) {
	  if (a.zlevel === b.zlevel) {
	    if (a.z === b.z) {
	      // if (a.z2 === b.z2) {
	      //     // FIXME Slow has renderidx compare
	      //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement
	      //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012
	      //     return a.__renderidx - b.__renderidx;
	      // }
	      return a.z2 - b.z2;
	    }
	
	    return a.z - b.z;
	  }
	
	  return a.zlevel - b.zlevel;
	}
	/**
	 * 内容仓库 (M)
	 * @alias module:zrender/Storage
	 * @constructor
	 */
	
	
	var Storage = function () {
	  // jshint ignore:line
	  this._roots = [];
	  this._displayList = [];
	  this._displayListLen = 0;
	};
	
	Storage.prototype = {
	  constructor: Storage,
	
	  /**
	   * @param  {Function} cb
	   *
	   */
	  traverse: function (cb, context) {
	    for (var i = 0; i < this._roots.length; i++) {
	      this._roots[i].traverse(cb, context);
	    }
	  },
	
	  /**
	   * 返回所有图形的绘制队列
	   * @param {boolean} [update=false] 是否在返回前更新该数组
	   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
	   *
	   * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
	   * @return {Array.<module:zrender/graphic/Displayable>}
	   */
	  getDisplayList: function (update, includeIgnore) {
	    includeIgnore = includeIgnore || false;
	
	    if (update) {
	      this.updateDisplayList(includeIgnore);
	    }
	
	    return this._displayList;
	  },
	
	  /**
	   * 更新图形的绘制队列。
	   * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
	   * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
	   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
	   */
	  updateDisplayList: function (includeIgnore) {
	    this._displayListLen = 0;
	    var roots = this._roots;
	    var displayList = this._displayList;
	
	    for (var i = 0, len = roots.length; i < len; i++) {
	      this._updateAndAddDisplayable(roots[i], null, includeIgnore);
	    }
	
	    displayList.length = this._displayListLen; // for (var i = 0, len = displayList.length; i < len; i++) {
	    //     displayList[i].__renderidx = i;
	    // }
	    // displayList.sort(shapeCompareFunc);
	
	    env.canvasSupported && timsort(displayList, shapeCompareFunc);
	  },
	  _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {
	    if (el.ignore && !includeIgnore) {
	      return;
	    }
	
	    el.beforeUpdate();
	
	    if (el.__dirty) {
	      el.update();
	    }
	
	    el.afterUpdate();
	    var userSetClipPath = el.clipPath;
	
	    if (userSetClipPath) {
	      // FIXME 效率影响
	      if (clipPaths) {
	        clipPaths = clipPaths.slice();
	      } else {
	        clipPaths = [];
	      }
	
	      var currentClipPath = userSetClipPath;
	      var parentClipPath = el; // Recursively add clip path
	
	      while (currentClipPath) {
	        // clipPath 的变换是基于使用这个 clipPath 的元素
	        currentClipPath.parent = parentClipPath;
	        currentClipPath.updateTransform();
	        clipPaths.push(currentClipPath);
	        parentClipPath = currentClipPath;
	        currentClipPath = currentClipPath.clipPath;
	      }
	    }
	
	    if (el.isGroup) {
	      var children = el._children;
	
	      for (var i = 0; i < children.length; i++) {
	        var child = children[i]; // Force to mark as dirty if group is dirty
	        // FIXME __dirtyPath ?
	
	        if (el.__dirty) {
	          child.__dirty = true;
	        }
	
	        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
	      } // Mark group clean here
	
	
	      el.__dirty = false;
	    } else {
	      el.__clipPaths = clipPaths;
	      this._displayList[this._displayListLen++] = el;
	    }
	  },
	
	  /**
	   * 添加图形(Shape)或者组(Group)到根节点
	   * @param {module:zrender/Element} el
	   */
	  addRoot: function (el) {
	    if (el.__storage === this) {
	      return;
	    }
	
	    if (el instanceof Group) {
	      el.addChildrenToStorage(this);
	    }
	
	    this.addToStorage(el);
	
	    this._roots.push(el);
	  },
	
	  /**
	   * 删除指定的图形(Shape)或者组(Group)
	   * @param {string|Array.<string>} [el] 如果为空清空整个Storage
	   */
	  delRoot: function (el) {
	    if (el == null) {
	      // 不指定el清空
	      for (var i = 0; i < this._roots.length; i++) {
	        var root = this._roots[i];
	
	        if (root instanceof Group) {
	          root.delChildrenFromStorage(this);
	        }
	      }
	
	      this._roots = [];
	      this._displayList = [];
	      this._displayListLen = 0;
	      return;
	    }
	
	    if (el instanceof Array) {
	      for (var i = 0, l = el.length; i < l; i++) {
	        this.delRoot(el[i]);
	      }
	
	      return;
	    }
	
	    var idx = util.indexOf(this._roots, el);
	
	    if (idx >= 0) {
	      this.delFromStorage(el);
	
	      this._roots.splice(idx, 1);
	
	      if (el instanceof Group) {
	        el.delChildrenFromStorage(this);
	      }
	    }
	  },
	  addToStorage: function (el) {
	    el.__storage = this;
	    el.dirty(false);
	    return this;
	  },
	  delFromStorage: function (el) {
	    if (el) {
	      el.__storage = null;
	    }
	
	    return this;
	  },
	
	  /**
	   * 清空并且释放Storage
	   */
	  dispose: function () {
	    this._renderList = this._roots = null;
	  },
	  displayableSortFunc: shapeCompareFunc
	};
	var _default = Storage;
	module.exports = _default;

/***/ }),
/* 72 */
/***/ (function(module, exports) {

	// https://github.com/mziccard/node-timsort
	var DEFAULT_MIN_MERGE = 32;
	var DEFAULT_MIN_GALLOPING = 7;
	var DEFAULT_TMP_STORAGE_LENGTH = 256;
	
	function minRunLength(n) {
	  var r = 0;
	
	  while (n >= DEFAULT_MIN_MERGE) {
	    r |= n & 1;
	    n >>= 1;
	  }
	
	  return n + r;
	}
	
	function makeAscendingRun(array, lo, hi, compare) {
	  var runHi = lo + 1;
	
	  if (runHi === hi) {
	    return 1;
	  }
	
	  if (compare(array[runHi++], array[lo]) < 0) {
	    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
	      runHi++;
	    }
	
	    reverseRun(array, lo, runHi);
	  } else {
	    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
	      runHi++;
	    }
	  }
	
	  return runHi - lo;
	}
	
	function reverseRun(array, lo, hi) {
	  hi--;
	
	  while (lo < hi) {
	    var t = array[lo];
	    array[lo++] = array[hi];
	    array[hi--] = t;
	  }
	}
	
	function binaryInsertionSort(array, lo, hi, start, compare) {
	  if (start === lo) {
	    start++;
	  }
	
	  for (; start < hi; start++) {
	    var pivot = array[start];
	    var left = lo;
	    var right = start;
	    var mid;
	
	    while (left < right) {
	      mid = left + right >>> 1;
	
	      if (compare(pivot, array[mid]) < 0) {
	        right = mid;
	      } else {
	        left = mid + 1;
	      }
	    }
	
	    var n = start - left;
	
	    switch (n) {
	      case 3:
	        array[left + 3] = array[left + 2];
	
	      case 2:
	        array[left + 2] = array[left + 1];
	
	      case 1:
	        array[left + 1] = array[left];
	        break;
	
	      default:
	        while (n > 0) {
	          array[left + n] = array[left + n - 1];
	          n--;
	        }
	
	    }
	
	    array[left] = pivot;
	  }
	}
	
	function gallopLeft(value, array, start, length, hint, compare) {
	  var lastOffset = 0;
	  var maxOffset = 0;
	  var offset = 1;
	
	  if (compare(value, array[start + hint]) > 0) {
	    maxOffset = length - hint;
	
	    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
	      lastOffset = offset;
	      offset = (offset << 1) + 1;
	
	      if (offset <= 0) {
	        offset = maxOffset;
	      }
	    }
	
	    if (offset > maxOffset) {
	      offset = maxOffset;
	    }
	
	    lastOffset += hint;
	    offset += hint;
	  } else {
	    maxOffset = hint + 1;
	
	    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
	      lastOffset = offset;
	      offset = (offset << 1) + 1;
	
	      if (offset <= 0) {
	        offset = maxOffset;
	      }
	    }
	
	    if (offset > maxOffset) {
	      offset = maxOffset;
	    }
	
	    var tmp = lastOffset;
	    lastOffset = hint - offset;
	    offset = hint - tmp;
	  }
	
	  lastOffset++;
	
	  while (lastOffset < offset) {
	    var m = lastOffset + (offset - lastOffset >>> 1);
	
	    if (compare(value, array[start + m]) > 0) {
	      lastOffset = m + 1;
	    } else {
	      offset = m;
	    }
	  }
	
	  return offset;
	}
	
	function gallopRight(value, array, start, length, hint, compare) {
	  var lastOffset = 0;
	  var maxOffset = 0;
	  var offset = 1;
	
	  if (compare(value, array[start + hint]) < 0) {
	    maxOffset = hint + 1;
	
	    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
	      lastOffset = offset;
	      offset = (offset << 1) + 1;
	
	      if (offset <= 0) {
	        offset = maxOffset;
	      }
	    }
	
	    if (offset > maxOffset) {
	      offset = maxOffset;
	    }
	
	    var tmp = lastOffset;
	    lastOffset = hint - offset;
	    offset = hint - tmp;
	  } else {
	    maxOffset = length - hint;
	
	    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
	      lastOffset = offset;
	      offset = (offset << 1) + 1;
	
	      if (offset <= 0) {
	        offset = maxOffset;
	      }
	    }
	
	    if (offset > maxOffset) {
	      offset = maxOffset;
	    }
	
	    lastOffset += hint;
	    offset += hint;
	  }
	
	  lastOffset++;
	
	  while (lastOffset < offset) {
	    var m = lastOffset + (offset - lastOffset >>> 1);
	
	    if (compare(value, array[start + m]) < 0) {
	      offset = m;
	    } else {
	      lastOffset = m + 1;
	    }
	  }
	
	  return offset;
	}
	
	function TimSort(array, compare) {
	  var minGallop = DEFAULT_MIN_GALLOPING;
	  var length = 0;
	  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
	  var stackLength = 0;
	  var runStart;
	  var runLength;
	  var stackSize = 0;
	  length = array.length;
	
	  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
	    tmpStorageLength = length >>> 1;
	  }
	
	  var tmp = [];
	  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
	  runStart = [];
	  runLength = [];
	
	  function pushRun(_runStart, _runLength) {
	    runStart[stackSize] = _runStart;
	    runLength[stackSize] = _runLength;
	    stackSize += 1;
	  }
	
	  function mergeRuns() {
	    while (stackSize > 1) {
	      var n = stackSize - 2;
	
	      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
	        if (runLength[n - 1] < runLength[n + 1]) {
	          n--;
	        }
	      } else if (runLength[n] > runLength[n + 1]) {
	        break;
	      }
	
	      mergeAt(n);
	    }
	  }
	
	  function forceMergeRuns() {
	    while (stackSize > 1) {
	      var n = stackSize - 2;
	
	      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
	        n--;
	      }
	
	      mergeAt(n);
	    }
	  }
	
	  function mergeAt(i) {
	    var start1 = runStart[i];
	    var length1 = runLength[i];
	    var start2 = runStart[i + 1];
	    var length2 = runLength[i + 1];
	    runLength[i] = length1 + length2;
	
	    if (i === stackSize - 3) {
	      runStart[i + 1] = runStart[i + 2];
	      runLength[i + 1] = runLength[i + 2];
	    }
	
	    stackSize--;
	    var k = gallopRight(array[start2], array, start1, length1, 0, compare);
	    start1 += k;
	    length1 -= k;
	
	    if (length1 === 0) {
	      return;
	    }
	
	    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);
	
	    if (length2 === 0) {
	      return;
	    }
	
	    if (length1 <= length2) {
	      mergeLow(start1, length1, start2, length2);
	    } else {
	      mergeHigh(start1, length1, start2, length2);
	    }
	  }
	
	  function mergeLow(start1, length1, start2, length2) {
	    var i = 0;
	
	    for (i = 0; i < length1; i++) {
	      tmp[i] = array[start1 + i];
	    }
	
	    var cursor1 = 0;
	    var cursor2 = start2;
	    var dest = start1;
	    array[dest++] = array[cursor2++];
	
	    if (--length2 === 0) {
	      for (i = 0; i < length1; i++) {
	        array[dest + i] = tmp[cursor1 + i];
	      }
	
	      return;
	    }
	
	    if (length1 === 1) {
	      for (i = 0; i < length2; i++) {
	        array[dest + i] = array[cursor2 + i];
	      }
	
	      array[dest + length2] = tmp[cursor1];
	      return;
	    }
	
	    var _minGallop = minGallop;
	    var count1, count2, exit;
	
	    while (1) {
	      count1 = 0;
	      count2 = 0;
	      exit = false;
	
	      do {
	        if (compare(array[cursor2], tmp[cursor1]) < 0) {
	          array[dest++] = array[cursor2++];
	          count2++;
	          count1 = 0;
	
	          if (--length2 === 0) {
	            exit = true;
	            break;
	          }
	        } else {
	          array[dest++] = tmp[cursor1++];
	          count1++;
	          count2 = 0;
	
	          if (--length1 === 1) {
	            exit = true;
	            break;
	          }
	        }
	      } while ((count1 | count2) < _minGallop);
	
	      if (exit) {
	        break;
	      }
	
	      do {
	        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);
	
	        if (count1 !== 0) {
	          for (i = 0; i < count1; i++) {
	            array[dest + i] = tmp[cursor1 + i];
	          }
	
	          dest += count1;
	          cursor1 += count1;
	          length1 -= count1;
	
	          if (length1 <= 1) {
	            exit = true;
	            break;
	          }
	        }
	
	        array[dest++] = array[cursor2++];
	
	        if (--length2 === 0) {
	          exit = true;
	          break;
	        }
	
	        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);
	
	        if (count2 !== 0) {
	          for (i = 0; i < count2; i++) {
	            array[dest + i] = array[cursor2 + i];
	          }
	
	          dest += count2;
	          cursor2 += count2;
	          length2 -= count2;
	
	          if (length2 === 0) {
	            exit = true;
	            break;
	          }
	        }
	
	        array[dest++] = tmp[cursor1++];
	
	        if (--length1 === 1) {
	          exit = true;
	          break;
	        }
	
	        _minGallop--;
	      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	
	      if (exit) {
	        break;
	      }
	
	      if (_minGallop < 0) {
	        _minGallop = 0;
	      }
	
	      _minGallop += 2;
	    }
	
	    minGallop = _minGallop;
	    minGallop < 1 && (minGallop = 1);
	
	    if (length1 === 1) {
	      for (i = 0; i < length2; i++) {
	        array[dest + i] = array[cursor2 + i];
	      }
	
	      array[dest + length2] = tmp[cursor1];
	    } else if (length1 === 0) {
	      throw new Error(); // throw new Error('mergeLow preconditions were not respected');
	    } else {
	      for (i = 0; i < length1; i++) {
	        array[dest + i] = tmp[cursor1 + i];
	      }
	    }
	  }
	
	  function mergeHigh(start1, length1, start2, length2) {
	    var i = 0;
	
	    for (i = 0; i < length2; i++) {
	      tmp[i] = array[start2 + i];
	    }
	
	    var cursor1 = start1 + length1 - 1;
	    var cursor2 = length2 - 1;
	    var dest = start2 + length2 - 1;
	    var customCursor = 0;
	    var customDest = 0;
	    array[dest--] = array[cursor1--];
	
	    if (--length1 === 0) {
	      customCursor = dest - (length2 - 1);
	
	      for (i = 0; i < length2; i++) {
	        array[customCursor + i] = tmp[i];
	      }
	
	      return;
	    }
	
	    if (length2 === 1) {
	      dest -= length1;
	      cursor1 -= length1;
	      customDest = dest + 1;
	      customCursor = cursor1 + 1;
	
	      for (i = length1 - 1; i >= 0; i--) {
	        array[customDest + i] = array[customCursor + i];
	      }
	
	      array[dest] = tmp[cursor2];
	      return;
	    }
	
	    var _minGallop = minGallop;
	
	    while (true) {
	      var count1 = 0;
	      var count2 = 0;
	      var exit = false;
	
	      do {
	        if (compare(tmp[cursor2], array[cursor1]) < 0) {
	          array[dest--] = array[cursor1--];
	          count1++;
	          count2 = 0;
	
	          if (--length1 === 0) {
	            exit = true;
	            break;
	          }
	        } else {
	          array[dest--] = tmp[cursor2--];
	          count2++;
	          count1 = 0;
	
	          if (--length2 === 1) {
	            exit = true;
	            break;
	          }
	        }
	      } while ((count1 | count2) < _minGallop);
	
	      if (exit) {
	        break;
	      }
	
	      do {
	        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);
	
	        if (count1 !== 0) {
	          dest -= count1;
	          cursor1 -= count1;
	          length1 -= count1;
	          customDest = dest + 1;
	          customCursor = cursor1 + 1;
	
	          for (i = count1 - 1; i >= 0; i--) {
	            array[customDest + i] = array[customCursor + i];
	          }
	
	          if (length1 === 0) {
	            exit = true;
	            break;
	          }
	        }
	
	        array[dest--] = tmp[cursor2--];
	
	        if (--length2 === 1) {
	          exit = true;
	          break;
	        }
	
	        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);
	
	        if (count2 !== 0) {
	          dest -= count2;
	          cursor2 -= count2;
	          length2 -= count2;
	          customDest = dest + 1;
	          customCursor = cursor2 + 1;
	
	          for (i = 0; i < count2; i++) {
	            array[customDest + i] = tmp[customCursor + i];
	          }
	
	          if (length2 <= 1) {
	            exit = true;
	            break;
	          }
	        }
	
	        array[dest--] = array[cursor1--];
	
	        if (--length1 === 0) {
	          exit = true;
	          break;
	        }
	
	        _minGallop--;
	      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	
	      if (exit) {
	        break;
	      }
	
	      if (_minGallop < 0) {
	        _minGallop = 0;
	      }
	
	      _minGallop += 2;
	    }
	
	    minGallop = _minGallop;
	
	    if (minGallop < 1) {
	      minGallop = 1;
	    }
	
	    if (length2 === 1) {
	      dest -= length1;
	      cursor1 -= length1;
	      customDest = dest + 1;
	      customCursor = cursor1 + 1;
	
	      for (i = length1 - 1; i >= 0; i--) {
	        array[customDest + i] = array[customCursor + i];
	      }
	
	      array[dest] = tmp[cursor2];
	    } else if (length2 === 0) {
	      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');
	    } else {
	      customCursor = dest - (length2 - 1);
	
	      for (i = 0; i < length2; i++) {
	        array[customCursor + i] = tmp[i];
	      }
	    }
	  }
	
	  this.mergeRuns = mergeRuns;
	  this.forceMergeRuns = forceMergeRuns;
	  this.pushRun = pushRun;
	}
	
	function sort(array, compare, lo, hi) {
	  if (!lo) {
	    lo = 0;
	  }
	
	  if (!hi) {
	    hi = array.length;
	  }
	
	  var remaining = hi - lo;
	
	  if (remaining < 2) {
	    return;
	  }
	
	  var runLength = 0;
	
	  if (remaining < DEFAULT_MIN_MERGE) {
	    runLength = makeAscendingRun(array, lo, hi, compare);
	    binaryInsertionSort(array, lo, hi, lo + runLength, compare);
	    return;
	  }
	
	  var ts = new TimSort(array, compare);
	  var minRun = minRunLength(remaining);
	
	  do {
	    runLength = makeAscendingRun(array, lo, hi, compare);
	
	    if (runLength < minRun) {
	      var force = remaining;
	
	      if (force > minRun) {
	        force = minRun;
	      }
	
	      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
	      runLength = force;
	    }
	
	    ts.pushRun(lo, runLength);
	    ts.mergeRuns();
	    remaining -= runLength;
	    lo += runLength;
	  } while (remaining !== 0);
	
	  ts.forceMergeRuns();
	}
	
	module.exports = sort;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	var _config = __webpack_require__(23);
	
	var devicePixelRatio = _config.devicePixelRatio;
	
	var util = __webpack_require__(5);
	
	var log = __webpack_require__(22);
	
	var BoundingRect = __webpack_require__(27);
	
	var timsort = __webpack_require__(72);
	
	var Layer = __webpack_require__(74);
	
	var requestAnimationFrame = __webpack_require__(75);
	
	var Image = __webpack_require__(45);
	
	/**
	 * Default canvas painter
	 * @module zrender/Painter
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	// PENDIGN
	// Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.
	//
	// Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.
	var MAX_PROGRESSIVE_LAYER_NUMBER = 5;
	
	function parseInt10(val) {
	  return parseInt(val, 10);
	}
	
	function isLayerValid(layer) {
	  if (!layer) {
	    return false;
	  }
	
	  if (layer.__builtin__) {
	    return true;
	  }
	
	  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {
	    return false;
	  }
	
	  return true;
	}
	
	function preProcessLayer(layer) {
	  layer.__unusedCount++;
	}
	
	function postProcessLayer(layer) {
	  if (layer.__unusedCount == 1) {
	    layer.clear();
	  }
	}
	
	var tmpRect = new BoundingRect(0, 0, 0, 0);
	var viewRect = new BoundingRect(0, 0, 0, 0);
	
	function isDisplayableCulled(el, width, height) {
	  tmpRect.copy(el.getBoundingRect());
	
	  if (el.transform) {
	    tmpRect.applyTransform(el.transform);
	  }
	
	  viewRect.width = width;
	  viewRect.height = height;
	  return !tmpRect.intersect(viewRect);
	}
	
	function isClipPathChanged(clipPaths, prevClipPaths) {
	  if (clipPaths == prevClipPaths) {
	    // Can both be null or undefined
	    return false;
	  }
	
	  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
	    return true;
	  }
	
	  for (var i = 0; i < clipPaths.length; i++) {
	    if (clipPaths[i] !== prevClipPaths[i]) {
	      return true;
	    }
	  }
	}
	
	function doClip(clipPaths, ctx) {
	  for (var i = 0; i < clipPaths.length; i++) {
	    var clipPath = clipPaths[i];
	    clipPath.setTransform(ctx);
	    ctx.beginPath();
	    clipPath.buildPath(ctx, clipPath.shape);
	    ctx.clip(); // Transform back
	
	    clipPath.restoreTransform(ctx);
	  }
	}
	
	function createRoot(width, height) {
	  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬
	
	  domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';
	  return domRoot;
	}
	/**
	 * @alias module:zrender/Painter
	 * @constructor
	 * @param {HTMLElement} root 绘图容器
	 * @param {module:zrender/Storage} storage
	 * @param {Object} opts
	 */
	
	
	var Painter = function (root, storage, opts) {
	  this.type = 'canvas'; // In node environment using node-canvas
	
	  var singleCanvas = !root.nodeName // In node ?
	  || root.nodeName.toUpperCase() === 'CANVAS';
	  this._opts = opts = util.extend({}, opts || {});
	  /**
	   * @type {number}
	   */
	
	  this.dpr = opts.devicePixelRatio || devicePixelRatio;
	  /**
	   * @type {boolean}
	   * @private
	   */
	
	  this._singleCanvas = singleCanvas;
	  /**
	   * 绘图容器
	   * @type {HTMLElement}
	   */
	
	  this.root = root;
	  var rootStyle = root.style;
	
	  if (rootStyle) {
	    rootStyle['-webkit-tap-highlight-color'] = 'transparent';
	    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';
	    root.innerHTML = '';
	  }
	  /**
	   * @type {module:zrender/Storage}
	   */
	
	
	  this.storage = storage;
	  /**
	   * @type {Array.<number>}
	   * @private
	   */
	
	  var zlevelList = this._zlevelList = [];
	  /**
	   * @type {Object.<string, module:zrender/Layer>}
	   * @private
	   */
	
	  var layers = this._layers = {};
	  /**
	   * @type {Object.<string, Object>}
	   * @type {private}
	   */
	
	  this._layerConfig = {};
	
	  if (!singleCanvas) {
	    this._width = this._getSize(0);
	    this._height = this._getSize(1);
	    var domRoot = this._domRoot = createRoot(this._width, this._height);
	    root.appendChild(domRoot);
	  } else {
	    if (opts.width != null) {
	      root.width = opts.width;
	    }
	
	    if (opts.height != null) {
	      root.height = opts.height;
	    } // Use canvas width and height directly
	
	
	    var width = root.width;
	    var height = root.height;
	    this._width = width;
	    this._height = height; // Create layer if only one given canvas
	    // Device pixel ratio is fixed to 1 because given canvas has its specified width and height
	
	    var mainLayer = new Layer(root, this, 1);
	    mainLayer.initContext(); // FIXME Use canvas width and height
	    // mainLayer.resize(width, height);
	
	    layers[0] = mainLayer;
	    zlevelList.push(0);
	    this._domRoot = root;
	  } // Layers for progressive rendering
	
	
	  this._progressiveLayers = [];
	  /**
	   * @type {module:zrender/Layer}
	   * @private
	   */
	
	  this._hoverlayer;
	  this._hoverElements = [];
	};
	
	Painter.prototype = {
	  constructor: Painter,
	  getType: function () {
	    return 'canvas';
	  },
	
	  /**
	   * If painter use a single canvas
	   * @return {boolean}
	   */
	  isSingleCanvas: function () {
	    return this._singleCanvas;
	  },
	
	  /**
	   * @return {HTMLDivElement}
	   */
	  getViewportRoot: function () {
	    return this._domRoot;
	  },
	  getViewportRootOffset: function () {
	    var viewportRoot = this.getViewportRoot();
	
	    if (viewportRoot) {
	      return {
	        offsetLeft: viewportRoot.offsetLeft || 0,
	        offsetTop: viewportRoot.offsetTop || 0
	      };
	    }
	  },
	
	  /**
	   * 刷新
	   * @param {boolean} [paintAll=false] 强制绘制所有displayable
	   */
	  refresh: function (paintAll) {
	    var list = this.storage.getDisplayList(true);
	    var zlevelList = this._zlevelList;
	
	    this._paintList(list, paintAll); // Paint custum layers
	
	
	    for (var i = 0; i < zlevelList.length; i++) {
	      var z = zlevelList[i];
	      var layer = this._layers[z];
	
	      if (!layer.__builtin__ && layer.refresh) {
	        layer.refresh();
	      }
	    }
	
	    this.refreshHover();
	
	    if (this._progressiveLayers.length) {
	      this._startProgessive();
	    }
	
	    return this;
	  },
	  addHover: function (el, hoverStyle) {
	    if (el.__hoverMir) {
	      return;
	    }
	
	    var elMirror = new el.constructor({
	      style: el.style,
	      shape: el.shape
	    });
	    elMirror.__from = el;
	    el.__hoverMir = elMirror;
	    elMirror.setStyle(hoverStyle);
	
	    this._hoverElements.push(elMirror);
	  },
	  removeHover: function (el) {
	    var elMirror = el.__hoverMir;
	    var hoverElements = this._hoverElements;
	    var idx = util.indexOf(hoverElements, elMirror);
	
	    if (idx >= 0) {
	      hoverElements.splice(idx, 1);
	    }
	
	    el.__hoverMir = null;
	  },
	  clearHover: function (el) {
	    var hoverElements = this._hoverElements;
	
	    for (var i = 0; i < hoverElements.length; i++) {
	      var from = hoverElements[i].__from;
	
	      if (from) {
	        from.__hoverMir = null;
	      }
	    }
	
	    hoverElements.length = 0;
	  },
	  refreshHover: function () {
	    var hoverElements = this._hoverElements;
	    var len = hoverElements.length;
	    var hoverLayer = this._hoverlayer;
	    hoverLayer && hoverLayer.clear();
	
	    if (!len) {
	      return;
	    }
	
	    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel
	    // FIXME?
	
	    if (!hoverLayer) {
	      hoverLayer = this._hoverlayer = this.getLayer(1e5);
	    }
	
	    var scope = {};
	    hoverLayer.ctx.save();
	
	    for (var i = 0; i < len;) {
	      var el = hoverElements[i];
	      var originalEl = el.__from; // Original el is removed
	      // PENDING
	
	      if (!(originalEl && originalEl.__zr)) {
	        hoverElements.splice(i, 1);
	        originalEl.__hoverMir = null;
	        len--;
	        continue;
	      }
	
	      i++; // Use transform
	      // FIXME style and shape ?
	
	      if (!originalEl.invisible) {
	        el.transform = originalEl.transform;
	        el.invTransform = originalEl.invTransform;
	        el.__clipPaths = originalEl.__clipPaths; // el.
	
	        this._doPaintEl(el, hoverLayer, true, scope);
	      }
	    }
	
	    hoverLayer.ctx.restore();
	  },
	  _startProgessive: function () {
	    var self = this;
	
	    if (!self._furtherProgressive) {
	      return;
	    } // Use a token to stop progress steps triggered by
	    // previous zr.refresh calling.
	
	
	    var token = self._progressiveToken = +new Date();
	    self._progress++;
	    requestAnimationFrame(step);
	
	    function step() {
	      // In case refreshed or disposed
	      if (token === self._progressiveToken && self.storage) {
	        self._doPaintList(self.storage.getDisplayList());
	
	        if (self._furtherProgressive) {
	          self._progress++;
	          requestAnimationFrame(step);
	        } else {
	          self._progressiveToken = -1;
	        }
	      }
	    }
	  },
	  _clearProgressive: function () {
	    this._progressiveToken = -1;
	    this._progress = 0;
	    util.each(this._progressiveLayers, function (layer) {
	      layer.__dirty && layer.clear();
	    });
	  },
	  _paintList: function (list, paintAll) {
	    if (paintAll == null) {
	      paintAll = false;
	    }
	
	    this._updateLayerStatus(list);
	
	    this._clearProgressive();
	
	    this.eachBuiltinLayer(preProcessLayer);
	
	    this._doPaintList(list, paintAll);
	
	    this.eachBuiltinLayer(postProcessLayer);
	  },
	  _doPaintList: function (list, paintAll) {
	    var currentLayer;
	    var currentZLevel;
	    var ctx; // var invTransform = [];
	
	    var scope;
	    var progressiveLayerIdx = 0;
	    var currentProgressiveLayer;
	    var width = this._width;
	    var height = this._height;
	    var layerProgress;
	    var frame = this._progress;
	
	    function flushProgressiveLayer(layer) {
	      var dpr = ctx.dpr || 1;
	      ctx.save();
	      ctx.globalAlpha = 1;
	      ctx.shadowBlur = 0; // Avoid layer don't clear in next progressive frame
	
	      currentLayer.__dirty = true;
	      ctx.setTransform(1, 0, 0, 1, 0, 0);
	      ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);
	      ctx.restore();
	    }
	
	    for (var i = 0, l = list.length; i < l; i++) {
	      var el = list[i];
	      var elZLevel = this._singleCanvas ? 0 : el.zlevel;
	      var elFrame = el.__frame; // Flush at current context
	      // PENDING
	
	      if (elFrame < 0 && currentProgressiveLayer) {
	        flushProgressiveLayer(currentProgressiveLayer);
	        currentProgressiveLayer = null;
	      } // Change draw layer
	
	
	      if (currentZLevel !== elZLevel) {
	        if (ctx) {
	          ctx.restore();
	        } // Reset scope
	
	
	        scope = {}; // Only 0 zlevel if only has one canvas
	
	        currentZLevel = elZLevel;
	        currentLayer = this.getLayer(currentZLevel);
	
	        if (!currentLayer.__builtin__) {
	          log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);
	        }
	
	        ctx = currentLayer.ctx;
	        ctx.save(); // Reset the count
	
	        currentLayer.__unusedCount = 0;
	
	        if (currentLayer.__dirty || paintAll) {
	          currentLayer.clear();
	        }
	      }
	
	      if (!(currentLayer.__dirty || paintAll)) {
	        continue;
	      }
	
	      if (elFrame >= 0) {
	        // Progressive layer changed
	        if (!currentProgressiveLayer) {
	          currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];
	          currentProgressiveLayer.ctx.save();
	          currentProgressiveLayer.renderScope = {};
	
	          if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {
	            // flushProgressiveLayer(currentProgressiveLayer);
	            // Quick jump all progressive elements
	            // All progressive element are not dirty, jump over and flush directly
	            i = currentProgressiveLayer.__nextIdxNotProg - 1; // currentProgressiveLayer = null;
	
	            continue;
	          }
	
	          layerProgress = currentProgressiveLayer.__progress;
	
	          if (!currentProgressiveLayer.__dirty) {
	            // Keep rendering
	            frame = layerProgress;
	          }
	
	          currentProgressiveLayer.__progress = frame + 1;
	        }
	
	        if (elFrame === frame) {
	          this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);
	        }
	      } else {
	        this._doPaintEl(el, currentLayer, paintAll, scope);
	      }
	
	      el.__dirty = false;
	    }
	
	    if (currentProgressiveLayer) {
	      flushProgressiveLayer(currentProgressiveLayer);
	    } // Restore the lastLayer ctx
	
	
	    ctx && ctx.restore(); // If still has clipping state
	    // if (scope.prevElClipPaths) {
	    //     ctx.restore();
	    // }
	
	    this._furtherProgressive = false;
	    util.each(this._progressiveLayers, function (layer) {
	      if (layer.__maxProgress >= layer.__progress) {
	        this._furtherProgressive = true;
	      }
	    }, this);
	  },
	  _doPaintEl: function (el, currentLayer, forcePaint, scope) {
	    var ctx = currentLayer.ctx;
	    var m = el.transform;
	
	    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element
	    !el.invisible // Ignore transparent element
	    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas
	    // Draw a scale 0 element can cause all following draw wrong
	    // And setTransform with scale 0 will cause set back transform failed.
	    && !(m && !m[0] && !m[3]) // Ignore culled element
	    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {
	      var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements
	
	      if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {
	        // If has previous clipping state, restore from it
	        if (scope.prevElClipPaths) {
	          scope.prevClipLayer.ctx.restore();
	          scope.prevClipLayer = scope.prevElClipPaths = null; // Reset prevEl since context has been restored
	
	          scope.prevEl = null;
	        } // New clipping state
	
	
	        if (clipPaths) {
	          ctx.save();
	          doClip(clipPaths, ctx);
	          scope.prevClipLayer = currentLayer;
	          scope.prevElClipPaths = clipPaths;
	        }
	      }
	
	      el.beforeBrush && el.beforeBrush(ctx);
	      el.brush(ctx, scope.prevEl || null);
	      scope.prevEl = el;
	      el.afterBrush && el.afterBrush(ctx);
	    }
	  },
	
	  /**
	   * 获取 zlevel 所在层，如果不存在则会创建一个新的层
	   * @param {number} zlevel
	   * @return {module:zrender/Layer}
	   */
	  getLayer: function (zlevel) {
	    if (this._singleCanvas) {
	      return this._layers[0];
	    }
	
	    var layer = this._layers[zlevel];
	
	    if (!layer) {
	      // Create a new layer
	      layer = new Layer('zr_' + zlevel, this, this.dpr);
	      layer.__builtin__ = true;
	
	      if (this._layerConfig[zlevel]) {
	        util.merge(layer, this._layerConfig[zlevel], true);
	      }
	
	      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document
	      // Or excanvas will get 0px clientWidth and clientHeight
	
	      layer.initContext();
	    }
	
	    return layer;
	  },
	  insertLayer: function (zlevel, layer) {
	    var layersMap = this._layers;
	    var zlevelList = this._zlevelList;
	    var len = zlevelList.length;
	    var prevLayer = null;
	    var i = -1;
	    var domRoot = this._domRoot;
	
	    if (layersMap[zlevel]) {
	      log('ZLevel ' + zlevel + ' has been used already');
	      return;
	    } // Check if is a valid layer
	
	
	    if (!isLayerValid(layer)) {
	      log('Layer of zlevel ' + zlevel + ' is not valid');
	      return;
	    }
	
	    if (len > 0 && zlevel > zlevelList[0]) {
	      for (i = 0; i < len - 1; i++) {
	        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
	          break;
	        }
	      }
	
	      prevLayer = layersMap[zlevelList[i]];
	    }
	
	    zlevelList.splice(i + 1, 0, zlevel);
	    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.
	    // (It can be a WebGL layer and assigned to a ZImage element)
	    // But it still under management of zrender.
	
	    if (!layer.virtual) {
	      if (prevLayer) {
	        var prevDom = prevLayer.dom;
	
	        if (prevDom.nextSibling) {
	          domRoot.insertBefore(layer.dom, prevDom.nextSibling);
	        } else {
	          domRoot.appendChild(layer.dom);
	        }
	      } else {
	        if (domRoot.firstChild) {
	          domRoot.insertBefore(layer.dom, domRoot.firstChild);
	        } else {
	          domRoot.appendChild(layer.dom);
	        }
	      }
	    }
	  },
	  // Iterate each layer
	  eachLayer: function (cb, context) {
	    var zlevelList = this._zlevelList;
	    var z;
	    var i;
	
	    for (i = 0; i < zlevelList.length; i++) {
	      z = zlevelList[i];
	      cb.call(context, this._layers[z], z);
	    }
	  },
	  // Iterate each buildin layer
	  eachBuiltinLayer: function (cb, context) {
	    var zlevelList = this._zlevelList;
	    var layer;
	    var z;
	    var i;
	
	    for (i = 0; i < zlevelList.length; i++) {
	      z = zlevelList[i];
	      layer = this._layers[z];
	
	      if (layer.__builtin__) {
	        cb.call(context, layer, z);
	      }
	    }
	  },
	  // Iterate each other layer except buildin layer
	  eachOtherLayer: function (cb, context) {
	    var zlevelList = this._zlevelList;
	    var layer;
	    var z;
	    var i;
	
	    for (i = 0; i < zlevelList.length; i++) {
	      z = zlevelList[i];
	      layer = this._layers[z];
	
	      if (!layer.__builtin__) {
	        cb.call(context, layer, z);
	      }
	    }
	  },
	
	  /**
	   * 获取所有已创建的层
	   * @param {Array.<module:zrender/Layer>} [prevLayer]
	   */
	  getLayers: function () {
	    return this._layers;
	  },
	  _updateLayerStatus: function (list) {
	    var layers = this._layers;
	    var progressiveLayers = this._progressiveLayers;
	    var elCountsLastFrame = {};
	    var progressiveElCountsLastFrame = {};
	    this.eachBuiltinLayer(function (layer, z) {
	      elCountsLastFrame[z] = layer.elCount;
	      layer.elCount = 0;
	      layer.__dirty = false;
	    });
	    util.each(progressiveLayers, function (layer, idx) {
	      progressiveElCountsLastFrame[idx] = layer.elCount;
	      layer.elCount = 0;
	      layer.__dirty = false;
	    });
	    var progressiveLayerCount = 0;
	    var currentProgressiveLayer;
	    var lastProgressiveKey;
	    var frameCount = 0;
	
	    for (var i = 0, l = list.length; i < l; i++) {
	      var el = list[i];
	      var zlevel = this._singleCanvas ? 0 : el.zlevel;
	      var layer = layers[zlevel];
	      var elProgress = el.progressive;
	
	      if (layer) {
	        layer.elCount++;
	        layer.__dirty = layer.__dirty || el.__dirty;
	      } /////// Update progressive
	
	
	      if (elProgress >= 0) {
	        // Fix wrong progressive sequence problem.
	        if (lastProgressiveKey !== elProgress) {
	          lastProgressiveKey = elProgress;
	          frameCount++;
	        }
	
	        var elFrame = el.__frame = frameCount - 1;
	
	        if (!currentProgressiveLayer) {
	          var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);
	          currentProgressiveLayer = progressiveLayers[idx];
	
	          if (!currentProgressiveLayer) {
	            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);
	            currentProgressiveLayer.initContext();
	          }
	
	          currentProgressiveLayer.__maxProgress = 0;
	        }
	
	        currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;
	        currentProgressiveLayer.elCount++;
	        currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);
	
	        if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {
	          // Should keep rendering this  layer because progressive rendering is not finished yet
	          layer.__dirty = true;
	        }
	      } else {
	        el.__frame = -1;
	
	        if (currentProgressiveLayer) {
	          currentProgressiveLayer.__nextIdxNotProg = i;
	          progressiveLayerCount++;
	          currentProgressiveLayer = null;
	        }
	      }
	    }
	
	    if (currentProgressiveLayer) {
	      progressiveLayerCount++;
	      currentProgressiveLayer.__nextIdxNotProg = i;
	    } // 层中的元素数量有发生变化
	
	
	    this.eachBuiltinLayer(function (layer, z) {
	      if (elCountsLastFrame[z] !== layer.elCount) {
	        layer.__dirty = true;
	      }
	    });
	    progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);
	    util.each(progressiveLayers, function (layer, idx) {
	      if (progressiveElCountsLastFrame[idx] !== layer.elCount) {
	        el.__dirty = true;
	      }
	
	      if (layer.__dirty) {
	        layer.__progress = 0;
	      }
	    });
	  },
	
	  /**
	   * 清除hover层外所有内容
	   */
	  clear: function () {
	    this.eachBuiltinLayer(this._clearLayer);
	    return this;
	  },
	  _clearLayer: function (layer) {
	    layer.clear();
	  },
	
	  /**
	   * 修改指定zlevel的绘制参数
	   *
	   * @param {string} zlevel
	   * @param {Object} config 配置对象
	   * @param {string} [config.clearColor=0] 每次清空画布的颜色
	   * @param {string} [config.motionBlur=false] 是否开启动态模糊
	   * @param {number} [config.lastFrameAlpha=0.7]
	   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	   */
	  configLayer: function (zlevel, config) {
	    if (config) {
	      var layerConfig = this._layerConfig;
	
	      if (!layerConfig[zlevel]) {
	        layerConfig[zlevel] = config;
	      } else {
	        util.merge(layerConfig[zlevel], config, true);
	      }
	
	      var layer = this._layers[zlevel];
	
	      if (layer) {
	        util.merge(layer, layerConfig[zlevel], true);
	      }
	    }
	  },
	
	  /**
	   * 删除指定层
	   * @param {number} zlevel 层所在的zlevel
	   */
	  delLayer: function (zlevel) {
	    var layers = this._layers;
	    var zlevelList = this._zlevelList;
	    var layer = layers[zlevel];
	
	    if (!layer) {
	      return;
	    }
	
	    layer.dom.parentNode.removeChild(layer.dom);
	    delete layers[zlevel];
	    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
	  },
	
	  /**
	   * 区域大小变化后重绘
	   */
	  resize: function (width, height) {
	    var domRoot = this._domRoot; // FIXME Why ?
	
	    domRoot.style.display = 'none'; // Save input w/h
	
	    var opts = this._opts;
	    width != null && (opts.width = width);
	    height != null && (opts.height = height);
	    width = this._getSize(0);
	    height = this._getSize(1);
	    domRoot.style.display = ''; // 优化没有实际改变的resize
	
	    if (this._width != width || height != this._height) {
	      domRoot.style.width = width + 'px';
	      domRoot.style.height = height + 'px';
	
	      for (var id in this._layers) {
	        if (this._layers.hasOwnProperty(id)) {
	          this._layers[id].resize(width, height);
	        }
	      }
	
	      util.each(this._progressiveLayers, function (layer) {
	        layer.resize(width, height);
	      });
	      this.refresh(true);
	    }
	
	    this._width = width;
	    this._height = height;
	    return this;
	  },
	
	  /**
	   * 清除单独的一个层
	   * @param {number} zlevel
	   */
	  clearLayer: function (zlevel) {
	    var layer = this._layers[zlevel];
	
	    if (layer) {
	      layer.clear();
	    }
	  },
	
	  /**
	   * 释放
	   */
	  dispose: function () {
	    this.root.innerHTML = '';
	    this.root = this.storage = this._domRoot = this._layers = null;
	  },
	
	  /**
	   * Get canvas which has all thing rendered
	   * @param {Object} opts
	   * @param {string} [opts.backgroundColor]
	   * @param {number} [opts.pixelRatio]
	   */
	  getRenderedCanvas: function (opts) {
	    opts = opts || {};
	
	    if (this._singleCanvas) {
	      return this._layers[0].dom;
	    }
	
	    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);
	    imageLayer.initContext();
	    imageLayer.clearColor = opts.backgroundColor;
	    imageLayer.clear();
	    var displayList = this.storage.getDisplayList(true);
	    var scope = {};
	    var zlevel;
	    var self = this;
	
	    function findAndDrawOtherLayer(smaller, larger) {
	      var zlevelList = self._zlevelList;
	
	      if (smaller == null) {
	        smaller = -Infinity;
	      }
	
	      var intermediateLayer;
	
	      for (var i = 0; i < zlevelList.length; i++) {
	        var z = zlevelList[i];
	        var layer = self._layers[z];
	
	        if (!layer.__builtin__ && z > smaller && z < larger) {
	          intermediateLayer = layer;
	          break;
	        }
	      }
	
	      if (intermediateLayer && intermediateLayer.renderToCanvas) {
	        imageLayer.ctx.save();
	        intermediateLayer.renderToCanvas(imageLayer.ctx);
	        imageLayer.ctx.restore();
	      }
	    }
	
	    for (var i = 0; i < displayList.length; i++) {
	      var el = displayList[i];
	
	      if (el.zlevel !== zlevel) {
	        findAndDrawOtherLayer(zlevel, el.zlevel);
	        zlevel = el.zlevel;
	      }
	
	      this._doPaintEl(el, imageLayer, true, scope);
	    }
	
	    findAndDrawOtherLayer(zlevel, Infinity);
	    return imageLayer.dom;
	  },
	
	  /**
	   * 获取绘图区域宽度
	   */
	  getWidth: function () {
	    return this._width;
	  },
	
	  /**
	   * 获取绘图区域高度
	   */
	  getHeight: function () {
	    return this._height;
	  },
	  _getSize: function (whIdx) {
	    var opts = this._opts;
	    var wh = ['width', 'height'][whIdx];
	    var cwh = ['clientWidth', 'clientHeight'][whIdx];
	    var plt = ['paddingLeft', 'paddingTop'][whIdx];
	    var prb = ['paddingRight', 'paddingBottom'][whIdx];
	
	    if (opts[wh] != null && opts[wh] !== 'auto') {
	      return parseFloat(opts[wh]);
	    }
	
	    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.
	
	    var stl = document.defaultView.getComputedStyle(root);
	    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
	  },
	  pathToImage: function (path, dpr) {
	    dpr = dpr || this.dpr;
	    var canvas = document.createElement('canvas');
	    var ctx = canvas.getContext('2d');
	    var rect = path.getBoundingRect();
	    var style = path.style;
	    var shadowBlurSize = style.shadowBlur;
	    var shadowOffsetX = style.shadowOffsetX;
	    var shadowOffsetY = style.shadowOffsetY;
	    var lineWidth = style.hasStroke() ? style.lineWidth : 0;
	    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);
	    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);
	    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);
	    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);
	    var width = rect.width + leftMargin + rightMargin;
	    var height = rect.height + topMargin + bottomMargin;
	    canvas.width = width * dpr;
	    canvas.height = height * dpr;
	    ctx.scale(dpr, dpr);
	    ctx.clearRect(0, 0, width, height);
	    ctx.dpr = dpr;
	    var pathTransform = {
	      position: path.position,
	      rotation: path.rotation,
	      scale: path.scale
	    };
	    path.position = [leftMargin - rect.x, topMargin - rect.y];
	    path.rotation = 0;
	    path.scale = [1, 1];
	    path.updateTransform();
	
	    if (path) {
	      path.brush(ctx);
	    }
	
	    var ImageShape = Image;
	    var imgShape = new ImageShape({
	      style: {
	        x: 0,
	        y: 0,
	        image: canvas
	      }
	    });
	
	    if (pathTransform.position != null) {
	      imgShape.position = path.position = pathTransform.position;
	    }
	
	    if (pathTransform.rotation != null) {
	      imgShape.rotation = path.rotation = pathTransform.rotation;
	    }
	
	    if (pathTransform.scale != null) {
	      imgShape.scale = path.scale = pathTransform.scale;
	    }
	
	    return imgShape;
	  }
	};
	var _default = Painter;
	module.exports = _default;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(5);
	
	var _config = __webpack_require__(23);
	
	var devicePixelRatio = _config.devicePixelRatio;
	
	var Style = __webpack_require__(9);
	
	var Pattern = __webpack_require__(40);
	
	/**
	 * @module zrender/Layer
	 * @author pissang(https://www.github.com/pissang)
	 */
	function returnFalse() {
	  return false;
	}
	/**
	 * 创建dom
	 *
	 * @inner
	 * @param {string} id dom id 待用
	 * @param {Painter} painter painter instance
	 * @param {number} number
	 */
	
	
	function createDom(id, painter, dpr) {
	  var newDom = util.createCanvas();
	  var width = painter.getWidth();
	  var height = painter.getHeight();
	  var newDomStyle = newDom.style; // 没append呢，请原谅我这样写，清晰~
	
	  newDomStyle.position = 'absolute';
	  newDomStyle.left = 0;
	  newDomStyle.top = 0;
	  newDomStyle.width = width + 'px';
	  newDomStyle.height = height + 'px';
	  newDom.width = width * dpr;
	  newDom.height = height * dpr; // id不作为索引用，避免可能造成的重名，定义为私有属性
	
	  newDom.setAttribute('data-zr-dom-id', id);
	  return newDom;
	}
	/**
	 * @alias module:zrender/Layer
	 * @constructor
	 * @extends module:zrender/mixin/Transformable
	 * @param {string} id
	 * @param {module:zrender/Painter} painter
	 * @param {number} [dpr]
	 */
	
	
	var Layer = function (id, painter, dpr) {
	  var dom;
	  dpr = dpr || devicePixelRatio;
	
	  if (typeof id === 'string') {
	    dom = createDom(id, painter, dpr);
	  } // Not using isDom because in node it will return false
	  else if (util.isObject(id)) {
	      dom = id;
	      id = dom.id;
	    }
	
	  this.id = id;
	  this.dom = dom;
	  var domStyle = dom.style;
	
	  if (domStyle) {
	    // Not in node
	    dom.onselectstart = returnFalse; // 避免页面选中的尴尬
	
	    domStyle['-webkit-user-select'] = 'none';
	    domStyle['user-select'] = 'none';
	    domStyle['-webkit-touch-callout'] = 'none';
	    domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
	    domStyle['padding'] = 0;
	    domStyle['margin'] = 0;
	    domStyle['border-width'] = 0;
	  }
	
	  this.domBack = null;
	  this.ctxBack = null;
	  this.painter = painter;
	  this.config = null; // Configs
	
	  /**
	   * 每次清空画布的颜色
	   * @type {string}
	   * @default 0
	   */
	
	  this.clearColor = 0;
	  /**
	   * 是否开启动态模糊
	   * @type {boolean}
	   * @default false
	   */
	
	  this.motionBlur = false;
	  /**
	   * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	   * @type {number}
	   * @default 0.7
	   */
	
	  this.lastFrameAlpha = 0.7;
	  /**
	   * Layer dpr
	   * @type {number}
	   */
	
	  this.dpr = dpr;
	};
	
	Layer.prototype = {
	  constructor: Layer,
	  elCount: 0,
	  __dirty: true,
	  initContext: function () {
	    this.ctx = this.dom.getContext('2d');
	    this.ctx.__currentValues = {};
	    this.ctx.dpr = this.dpr;
	  },
	  createBackBuffer: function () {
	    var dpr = this.dpr;
	    this.domBack = createDom('back-' + this.id, this.painter, dpr);
	    this.ctxBack = this.domBack.getContext('2d');
	    this.ctxBack.__currentValues = {};
	
	    if (dpr != 1) {
	      this.ctxBack.scale(dpr, dpr);
	    }
	  },
	
	  /**
	   * @param  {number} width
	   * @param  {number} height
	   */
	  resize: function (width, height) {
	    var dpr = this.dpr;
	    var dom = this.dom;
	    var domStyle = dom.style;
	    var domBack = this.domBack;
	    domStyle.width = width + 'px';
	    domStyle.height = height + 'px';
	    dom.width = width * dpr;
	    dom.height = height * dpr;
	
	    if (domBack) {
	      domBack.width = width * dpr;
	      domBack.height = height * dpr;
	
	      if (dpr != 1) {
	        this.ctxBack.scale(dpr, dpr);
	      }
	    }
	  },
	
	  /**
	   * 清空该层画布
	   * @param {boolean} clearAll Clear all with out motion blur
	   */
	  clear: function (clearAll) {
	    var dom = this.dom;
	    var ctx = this.ctx;
	    var width = dom.width;
	    var height = dom.height;
	    var clearColor = this.clearColor;
	    var haveMotionBLur = this.motionBlur && !clearAll;
	    var lastFrameAlpha = this.lastFrameAlpha;
	    var dpr = this.dpr;
	
	    if (haveMotionBLur) {
	      if (!this.domBack) {
	        this.createBackBuffer();
	      }
	
	      this.ctxBack.globalCompositeOperation = 'copy';
	      this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);
	    }
	
	    ctx.clearRect(0, 0, width, height);
	
	    if (clearColor) {
	      var clearColorGradientOrPattern; // Gradient
	
	      if (clearColor.colorStops) {
	        // Cache canvas gradient
	        clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {
	          x: 0,
	          y: 0,
	          width: width,
	          height: height
	        });
	        clearColor.__canvasGradient = clearColorGradientOrPattern;
	      } // Pattern
	      else if (clearColor.image) {
	          clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);
	        }
	
	      ctx.save();
	      ctx.fillStyle = clearColorGradientOrPattern || clearColor;
	      ctx.fillRect(0, 0, width, height);
	      ctx.restore();
	    }
	
	    if (haveMotionBLur) {
	      var domBack = this.domBack;
	      ctx.save();
	      ctx.globalAlpha = lastFrameAlpha;
	      ctx.drawImage(domBack, 0, 0, width, height);
	      ctx.restore();
	    }
	  }
	};
	var _default = Layer;
	module.exports = _default;

/***/ }),
/* 75 */
/***/ (function(module, exports) {

	var _default = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809
	window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {
	  setTimeout(func, 16);
	};
	
	module.exports = _default;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(5);
	
	var _event = __webpack_require__(77);
	
	var Dispatcher = _event.Dispatcher;
	
	var requestAnimationFrame = __webpack_require__(75);
	
	var Animator = __webpack_require__(17);
	
	/**
	 * 动画主类, 调度和管理所有动画控制器
	 *
	 * @module zrender/animation/Animation
	 * @author pissang(https://github.com/pissang)
	 */
	// TODO Additive animation
	// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/
	// https://developer.apple.com/videos/wwdc2014/#236
	
	/**
	 * @typedef {Object} IZRenderStage
	 * @property {Function} update
	 */
	
	/**
	 * @alias module:zrender/animation/Animation
	 * @constructor
	 * @param {Object} [options]
	 * @param {Function} [options.onframe]
	 * @param {IZRenderStage} [options.stage]
	 * @example
	 *     var animation = new Animation();
	 *     var obj = {
	 *         x: 100,
	 *         y: 100
	 *     };
	 *     animation.animate(node.position)
	 *         .when(1000, {
	 *             x: 500,
	 *             y: 500
	 *         })
	 *         .when(2000, {
	 *             x: 100,
	 *             y: 100
	 *         })
	 *         .start('spline');
	 */
	var Animation = function (options) {
	  options = options || {};
	  this.stage = options.stage || {};
	
	  this.onframe = options.onframe || function () {}; // private properties
	
	
	  this._clips = [];
	  this._running = false;
	  this._time;
	  this._pausedTime;
	  this._pauseStart;
	  this._paused = false;
	  Dispatcher.call(this);
	};
	
	Animation.prototype = {
	  constructor: Animation,
	
	  /**
	   * 添加 clip
	   * @param {module:zrender/animation/Clip} clip
	   */
	  addClip: function (clip) {
	    this._clips.push(clip);
	  },
	
	  /**
	   * 添加 animator
	   * @param {module:zrender/animation/Animator} animator
	   */
	  addAnimator: function (animator) {
	    animator.animation = this;
	    var clips = animator.getClips();
	
	    for (var i = 0; i < clips.length; i++) {
	      this.addClip(clips[i]);
	    }
	  },
	
	  /**
	   * 删除动画片段
	   * @param {module:zrender/animation/Clip} clip
	   */
	  removeClip: function (clip) {
	    var idx = util.indexOf(this._clips, clip);
	
	    if (idx >= 0) {
	      this._clips.splice(idx, 1);
	    }
	  },
	
	  /**
	   * 删除动画片段
	   * @param {module:zrender/animation/Animator} animator
	   */
	  removeAnimator: function (animator) {
	    var clips = animator.getClips();
	
	    for (var i = 0; i < clips.length; i++) {
	      this.removeClip(clips[i]);
	    }
	
	    animator.animation = null;
	  },
	  _update: function () {
	    var time = new Date().getTime() - this._pausedTime;
	
	    var delta = time - this._time;
	    var clips = this._clips;
	    var len = clips.length;
	    var deferredEvents = [];
	    var deferredClips = [];
	
	    for (var i = 0; i < len; i++) {
	      var clip = clips[i];
	      var e = clip.step(time, delta); // Throw out the events need to be called after
	      // stage.update, like destroy
	
	      if (e) {
	        deferredEvents.push(e);
	        deferredClips.push(clip);
	      }
	    } // Remove the finished clip
	
	
	    for (var i = 0; i < len;) {
	      if (clips[i]._needsRemove) {
	        clips[i] = clips[len - 1];
	        clips.pop();
	        len--;
	      } else {
	        i++;
	      }
	    }
	
	    len = deferredEvents.length;
	
	    for (var i = 0; i < len; i++) {
	      deferredClips[i].fire(deferredEvents[i]);
	    }
	
	    this._time = time;
	    this.onframe(delta);
	    this.trigger('frame', delta);
	
	    if (this.stage.update) {
	      this.stage.update();
	    }
	  },
	  _startLoop: function () {
	    var self = this;
	    this._running = true;
	
	    function step() {
	      if (self._running) {
	        requestAnimationFrame(step);
	        !self._paused && self._update();
	      }
	    }
	
	    requestAnimationFrame(step);
	  },
	
	  /**
	   * 开始运行动画
	   */
	  start: function () {
	    this._time = new Date().getTime();
	    this._pausedTime = 0;
	
	    this._startLoop();
	  },
	
	  /**
	   * 停止运行动画
	   */
	  stop: function () {
	    this._running = false;
	  },
	
	  /**
	   * Pause
	   */
	  pause: function () {
	    if (!this._paused) {
	      this._pauseStart = new Date().getTime();
	      this._paused = true;
	    }
	  },
	
	  /**
	   * Resume
	   */
	  resume: function () {
	    if (this._paused) {
	      this._pausedTime += new Date().getTime() - this._pauseStart;
	      this._paused = false;
	    }
	  },
	
	  /**
	   * 清除所有动画片段
	   */
	  clear: function () {
	    this._clips = [];
	  },
	
	  /**
	   * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画
	   * @param  {Object} target
	   * @param  {Object} options
	   * @param  {boolean} [options.loop=false] 是否循环播放动画
	   * @param  {Function} [options.getter=null]
	   *         如果指定getter函数，会通过getter函数取属性值
	   * @param  {Function} [options.setter=null]
	   *         如果指定setter函数，会通过setter函数设置属性值
	   * @return {module:zrender/animation/Animation~Animator}
	   */
	  // TODO Gap
	  animate: function (target, options) {
	    options = options || {};
	    var animator = new Animator(target, options.loop, options.getter, options.setter);
	    this.addAnimator(animator);
	    return animator;
	  }
	};
	util.mixin(Animation, Dispatcher);
	var _default = Animation;
	module.exports = _default;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	var Eventful = __webpack_require__(12);
	
	exports.Dispatcher = Eventful;
	
	var env = __webpack_require__(50);
	
	/**
	 * 事件辅助类
	 * @module zrender/core/event
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 */
	var isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;
	var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
	
	function getBoundingClientRect(el) {
	  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect
	  return el.getBoundingClientRect ? el.getBoundingClientRect() : {
	    left: 0,
	    top: 0
	  };
	} // `calculate` is optional, default false
	
	
	function clientToLocal(el, e, out, calculate) {
	  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative
	  // to the padding edge of the target element. The only browser using this convention
	  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does
	  // not support the properties.
	  // (see http://www.jacklmoore.com/notes/mouse-position/)
	  // In zr painter.dom, padding edge equals to border edge.
	  // FIXME
	  // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and
	  // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y
	  // is too complex. So css-transfrom dont support in this case temporarily.
	
	  if (calculate || !env.canvasSupported) {
	    defaultGetZrXY(el, e, out);
	  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned
	  // ancestor element, so we should make sure el is positioned (e.g., not position:static).
	  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add
	  // zoom-factor, overflow / opacity layers, transforms ...)
	  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.
	  // <https://bugs.jquery.com/ticket/8523#comment:14>
	  // BTW3, In ff, offsetX/offsetY is always 0.
	  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {
	      out.zrX = e.layerX;
	      out.zrY = e.layerY;
	    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)
	    else if (e.offsetX != null) {
	        out.zrX = e.offsetX;
	        out.zrY = e.offsetY;
	      } // For some other device, e.g., IOS safari.
	      else {
	          defaultGetZrXY(el, e, out);
	        }
	
	  return out;
	}
	
	function defaultGetZrXY(el, e, out) {
	  // This well-known method below does not support css transform.
	  var box = getBoundingClientRect(el);
	  out.zrX = e.clientX - box.left;
	  out.zrY = e.clientY - box.top;
	}
	/**
	 * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.
	 * `calculate` is optional, default false.
	 */
	
	
	function normalizeEvent(el, e, calculate) {
	  e = e || window.event;
	
	  if (e.zrX != null) {
	    return e;
	  }
	
	  var eventType = e.type;
	  var isTouch = eventType && eventType.indexOf('touch') >= 0;
	
	  if (!isTouch) {
	    clientToLocal(el, e, e, calculate);
	    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
	  } else {
	    var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];
	    touch && clientToLocal(el, touch, e, calculate);
	  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;
	  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js
	  // If e.which has been defined, if may be readonly,
	  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which
	
	
	  var button = e.button;
	
	  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {
	    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
	  }
	
	  return e;
	}
	
	function addEventListener(el, name, handler) {
	  if (isDomLevel2) {
	    el.addEventListener(name, handler);
	  } else {
	    el.attachEvent('on' + name, handler);
	  }
	}
	
	function removeEventListener(el, name, handler) {
	  if (isDomLevel2) {
	    el.removeEventListener(name, handler);
	  } else {
	    el.detachEvent('on' + name, handler);
	  }
	}
	/**
	 * preventDefault and stopPropagation.
	 * Notice: do not do that in zrender. Upper application
	 * do that if necessary.
	 *
	 * @memberOf module:zrender/core/event
	 * @method
	 * @param {Event} e : event对象
	 */
	
	
	var stop = isDomLevel2 ? function (e) {
	  e.preventDefault();
	  e.stopPropagation();
	  e.cancelBubble = true;
	} : function (e) {
	  e.returnValue = false;
	  e.cancelBubble = true;
	};
	
	function notLeftMouse(e) {
	  // If e.which is undefined, considered as left mouse event.
	  return e.which > 1;
	} // 做向上兼容
	
	
	exports.clientToLocal = clientToLocal;
	exports.normalizeEvent = normalizeEvent;
	exports.addEventListener = addEventListener;
	exports.removeEventListener = removeEventListener;
	exports.stop = stop;
	exports.notLeftMouse = notLeftMouse;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	var _event = __webpack_require__(77);
	
	var addEventListener = _event.addEventListener;
	var removeEventListener = _event.removeEventListener;
	var normalizeEvent = _event.normalizeEvent;
	
	var zrUtil = __webpack_require__(5);
	
	var Eventful = __webpack_require__(12);
	
	var env = __webpack_require__(50);
	
	var GestureMgr = __webpack_require__(79);
	
	var TOUCH_CLICK_DELAY = 300;
	var mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
	var touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];
	var pointerEventNames = {
	  pointerdown: 1,
	  pointerup: 1,
	  pointermove: 1,
	  pointerout: 1
	};
	var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {
	  var nm = name.replace('mouse', 'pointer');
	  return pointerEventNames[nm] ? nm : name;
	});
	
	function eventNameFix(name) {
	  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;
	}
	
	function processGesture(proxy, event, stage) {
	  var gestureMgr = proxy._gestureMgr;
	  stage === 'start' && gestureMgr.clear();
	  var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null).target, proxy.dom);
	  stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.
	
	  if (gestureInfo) {
	    var type = gestureInfo.type;
	    event.gestureEvent = type;
	    proxy.handler.dispatchToElement({
	      target: gestureInfo.target
	    }, type, gestureInfo.event);
	  }
	} // function onMSGestureChange(proxy, event) {
	//     if (event.translationX || event.translationY) {
	//         // mousemove is carried by MSGesture to reduce the sensitivity.
	//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);
	//     }
	//     if (event.scale !== 1) {
	//         event.pinchX = event.offsetX;
	//         event.pinchY = event.offsetY;
	//         event.pinchScale = event.scale;
	//         proxy.handler.dispatchToElement(event.target, 'pinch', event);
	//     }
	// }
	
	/**
	 * Prevent mouse event from being dispatched after Touch Events action
	 * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
	 * 1. Mobile browsers dispatch mouse events 300ms after touchend.
	 * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
	 * Result: Blocking Mouse Events for 700ms.
	 */
	
	
	function setTouchTimer(instance) {
	  instance._touching = true;
	  clearTimeout(instance._touchTimer);
	  instance._touchTimer = setTimeout(function () {
	    instance._touching = false;
	  }, 700);
	}
	
	var domHandlers = {
	  /**
	   * Mouse move handler
	   * @inner
	   * @param {Event} event
	   */
	  mousemove: function (event) {
	    event = normalizeEvent(this.dom, event);
	    this.trigger('mousemove', event);
	  },
	
	  /**
	   * Mouse out handler
	   * @inner
	   * @param {Event} event
	   */
	  mouseout: function (event) {
	    event = normalizeEvent(this.dom, event);
	    var element = event.toElement || event.relatedTarget;
	
	    if (element != this.dom) {
	      while (element && element.nodeType != 9) {
	        // 忽略包含在root中的dom引起的mouseOut
	        if (element === this.dom) {
	          return;
	        }
	
	        element = element.parentNode;
	      }
	    }
	
	    this.trigger('mouseout', event);
	  },
	
	  /**
	   * Touch开始响应函数
	   * @inner
	   * @param {Event} event
	   */
	  touchstart: function (event) {
	    // Default mouse behaviour should not be disabled here.
	    // For example, page may needs to be slided.
	    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
	    // mouse event in upper applicatoin.
	
	    event.zrByTouch = true;
	    this._lastTouchMoment = new Date();
	    processGesture(this, event, 'start'); // In touch device, trigger `mousemove`(`mouseover`) should
	    // be triggered, and must before `mousedown` triggered.
	
	    domHandlers.mousemove.call(this, event);
	    domHandlers.mousedown.call(this, event);
	    setTouchTimer(this);
	  },
	
	  /**
	   * Touch移动响应函数
	   * @inner
	   * @param {Event} event
	   */
	  touchmove: function (event) {
	    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
	    // mouse event in upper applicatoin.
	
	    event.zrByTouch = true;
	    processGesture(this, event, 'change'); // Mouse move should always be triggered no matter whether
	    // there is gestrue event, because mouse move and pinch may
	    // be used at the same time.
	
	    domHandlers.mousemove.call(this, event);
	    setTouchTimer(this);
	  },
	
	  /**
	   * Touch结束响应函数
	   * @inner
	   * @param {Event} event
	   */
	  touchend: function (event) {
	    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
	    // mouse event in upper applicatoin.
	
	    event.zrByTouch = true;
	    processGesture(this, event, 'end');
	    domHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is
	    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,
	    // we can conveniently implement "hover style" in both PC and touch device just
	    // by listening to `mouseover` to add "hover style" and listening to `mouseout`
	    // to remove "hover style" on an element, without any additional code for
	    // compatibility. (`mouseout` will not be triggered in `touchend`, so "hover
	    // style" will remain for user view)
	    // click event should always be triggered no matter whether
	    // there is gestrue event. System click can not be prevented.
	
	    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
	      domHandlers.click.call(this, event);
	    }
	
	    setTouchTimer(this);
	  },
	  pointerdown: function (event) {
	    domHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {
	    //     this._msGesture.addPointer(event.pointerId);
	    // }
	  },
	  pointermove: function (event) {
	    // FIXME
	    // pointermove is so sensitive that it always triggered when
	    // tap(click) on touch screen, which affect some judgement in
	    // upper application. So, we dont support mousemove on MS touch
	    // device yet.
	    if (!isPointerFromTouch(event)) {
	      domHandlers.mousemove.call(this, event);
	    }
	  },
	  pointerup: function (event) {
	    domHandlers.mouseup.call(this, event);
	  },
	  pointerout: function (event) {
	    // pointerout will be triggered when tap on touch screen
	    // (IE11+/Edge on MS Surface) after click event triggered,
	    // which is inconsistent with the mousout behavior we defined
	    // in touchend. So we unify them.
	    // (check domHandlers.touchend for detailed explanation)
	    if (!isPointerFromTouch(event)) {
	      domHandlers.mouseout.call(this, event);
	    }
	  }
	};
	
	function isPointerFromTouch(event) {
	  var pointerType = event.pointerType;
	  return pointerType === 'pen' || pointerType === 'touch';
	} // function useMSGuesture(handlerProxy, event) {
	//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;
	// }
	// Common handlers
	
	
	zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
	  domHandlers[name] = function (event) {
	    event = normalizeEvent(this.dom, event);
	    this.trigger(name, event);
	  };
	});
	/**
	 * 为控制类实例初始化dom 事件处理函数
	 *
	 * @inner
	 * @param {module:zrender/Handler} instance 控制类实例
	 */
	
	function initDomHandler(instance) {
	  zrUtil.each(touchHandlerNames, function (name) {
	    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
	  });
	  zrUtil.each(pointerHandlerNames, function (name) {
	    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
	  });
	  zrUtil.each(mouseHandlerNames, function (name) {
	    instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);
	  });
	
	  function makeMouseHandler(fn, instance) {
	    return function () {
	      if (instance._touching) {
	        return;
	      }
	
	      return fn.apply(instance, arguments);
	    };
	  }
	}
	
	function HandlerDomProxy(dom) {
	  Eventful.call(this);
	  this.dom = dom;
	  /**
	   * @private
	   * @type {boolean}
	   */
	
	  this._touching = false;
	  /**
	   * @private
	   * @type {number}
	   */
	
	  this._touchTimer;
	  /**
	   * @private
	   * @type {module:zrender/core/GestureMgr}
	   */
	
	  this._gestureMgr = new GestureMgr();
	  this._handlers = {};
	  initDomHandler(this);
	
	  if (env.pointerEventsSupported) {
	    // Only IE11+/Edge
	    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),
	    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event
	    // at the same time.
	    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on
	    // screen, which do not occurs in pointer event.
	    // So we use pointer event to both detect touch gesture and mouse behavior.
	    mountHandlers(pointerHandlerNames, this); // FIXME
	    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,
	    // which does not prevent defuault behavior occasionally (which may cause view port
	    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.
	    // So we have to not to use MSGesture and not to support touchmove and pinch on MS
	    // touch screen. And we only support click behavior on MS touch screen now.
	    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.
	    // We dont support touch on IE on win7.
	    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>
	    // if (typeof MSGesture === 'function') {
	    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line
	    //     dom.addEventListener('MSGestureChange', onMSGestureChange);
	    // }
	  } else {
	    if (env.touchEventsSupported) {
	      mountHandlers(touchHandlerNames, this); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.
	      // addEventListener(root, 'mouseout', this._mouseoutHandler);
	    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface
	    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise
	    // mouse event can not be handle in those devices.
	    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent
	    // mouseevent after touch event triggered, see `setTouchTimer`.
	
	
	    mountHandlers(mouseHandlerNames, this);
	  }
	
	  function mountHandlers(handlerNames, instance) {
	    zrUtil.each(handlerNames, function (name) {
	      addEventListener(dom, eventNameFix(name), instance._handlers[name]);
	    }, instance);
	  }
	}
	
	var handlerDomProxyProto = HandlerDomProxy.prototype;
	
	handlerDomProxyProto.dispose = function () {
	  var handlerNames = mouseHandlerNames.concat(touchHandlerNames);
	
	  for (var i = 0; i < handlerNames.length; i++) {
	    var name = handlerNames[i];
	    removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);
	  }
	};
	
	handlerDomProxyProto.setCursor = function (cursorStyle) {
	  this.dom.style.cursor = cursorStyle || 'default';
	};
	
	zrUtil.mixin(HandlerDomProxy, Eventful);
	var _default = HandlerDomProxy;
	module.exports = _default;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	var eventUtil = __webpack_require__(77);
	
	/**
	 * Only implements needed gestures for mobile.
	 */
	var GestureMgr = function () {
	  /**
	   * @private
	   * @type {Array.<Object>}
	   */
	  this._track = [];
	};
	
	GestureMgr.prototype = {
	  constructor: GestureMgr,
	  recognize: function (event, target, root) {
	    this._doTrack(event, target, root);
	
	    return this._recognize(event);
	  },
	  clear: function () {
	    this._track.length = 0;
	    return this;
	  },
	  _doTrack: function (event, target, root) {
	    var touches = event.touches;
	
	    if (!touches) {
	      return;
	    }
	
	    var trackItem = {
	      points: [],
	      touches: [],
	      target: target,
	      event: event
	    };
	
	    for (var i = 0, len = touches.length; i < len; i++) {
	      var touch = touches[i];
	      var pos = eventUtil.clientToLocal(root, touch, {});
	      trackItem.points.push([pos.zrX, pos.zrY]);
	      trackItem.touches.push(touch);
	    }
	
	    this._track.push(trackItem);
	  },
	  _recognize: function (event) {
	    for (var eventName in recognizers) {
	      if (recognizers.hasOwnProperty(eventName)) {
	        var gestureInfo = recognizers[eventName](this._track, event);
	
	        if (gestureInfo) {
	          return gestureInfo;
	        }
	      }
	    }
	  }
	};
	
	function dist(pointPair) {
	  var dx = pointPair[1][0] - pointPair[0][0];
	  var dy = pointPair[1][1] - pointPair[0][1];
	  return Math.sqrt(dx * dx + dy * dy);
	}
	
	function center(pointPair) {
	  return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];
	}
	
	var recognizers = {
	  pinch: function (track, event) {
	    var trackLen = track.length;
	
	    if (!trackLen) {
	      return;
	    }
	
	    var pinchEnd = (track[trackLen - 1] || {}).points;
	    var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;
	
	    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
	      var pinchScale = dist(pinchEnd) / dist(pinchPre);
	      !isFinite(pinchScale) && (pinchScale = 1);
	      event.pinchScale = pinchScale;
	      var pinchCenter = center(pinchEnd);
	      event.pinchX = pinchCenter[0];
	      event.pinchY = pinchCenter[1];
	      return {
	        type: 'pinch',
	        target: track[0].target,
	        event: event
	      };
	    }
	  } // Only pinch currently.
	
	};
	var _default = GestureMgr;
	module.exports = _default;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 选中节点后，出现的操作框及按钮
	 * @author wang.xiaohu
	 */
	
	    var Node = __webpack_require__(81);
	    var zrUtil = __webpack_require__(5);
	    var Util = __webpack_require__(65);
	    var graphic = __webpack_require__(4);
	    var Connector = __webpack_require__(82);
	    var env = __webpack_require__(50);
	    var icon = __webpack_require__(89);
	    var symbolUtil = __webpack_require__(83);
	    function OperationNode(node, zr, api,forbidEdit) {
	        Node.call(this);
	        this.node = node;
	        this.zr = zr;
	        this.forbidEdit = forbidEdit;
	        this._api = api;
	        this.render();
	    }
	
	    //事件
	    OperationNode.ARROW_DRAGEND = "OperationNode:dragendArrow";
	    OperationNode.ARROW_DRAG = "OperationNode:dragArrow";
	    OperationNode.ARROW_DRAGSTART = "OperationNode:dragstartArrow";
	    OperationNode.DELETE_CLICK = "OperationNode:deleteClick";
	    OperationNode.DEL = "DEL";
	    OperationNode.COMMENT_CLICK = "OperationNode:commentClick";
	    OperationNode.COMMENT = "COMMENT";
	        //内置操作图标的图像
	    OperationNode.opicons = {
	        STRAIGHT: icon.STRAIGHT_SVG,
	        JAGGED: icon.JAGGED_SVG,
	        CURVE: icon.CURVE_SVG,
	        DEL: icon.DEL_SVG,
	        COMMENT: icon.COMMENT_SVG
	    };
	
	    OperationNode.prototype.render = function() {
	        this.renderBase();
	        if (!this.forbidEdit) {
	            this.renderOther();
	        }
	    };
	
	    OperationNode.prototype.renderBase = function() {
	        this.createOperation();
	    };
	
	    OperationNode.prototype.createOperation = function() {
	        var me = this;
	        var ifShowNodeOperationIcons = this.node.operationIcons;
	        if (this.node.parent && this.node.parent.type === 'dragSelect') {
	            ifShowNodeOperationIcons = false;
	        }
	        if (!this.node.selectStyle) {
	            this.virtualRect = new graphic.Polyline({ style: { lineDash: [2] } });
	            this.virtualRect.isSelfComputePos = true;  // 自己计算位置
	            this.add(this.virtualRect);
	        } else {
	             if (this.node.type === 'ZPath') {  //addHover需要从它自身的构造函数中创建。1.Painter中addHover源码是根据shape与style创建 2.path中的构造函数是返回另一个元素
	                this.node._zCloneStyle = this.node.style.clone();
	                 this.node.setStyle(this.node.selectStyle);
	             } else if(this.node.setOrCancelSelectStyle) {
	                this.node.setOrCancelSelectStyle(true);
	             } else {
	                this._api.getZr().addHover(this.node, this.node.selectStyle);
	             }
	
	        }
	
	        if (ifShowNodeOperationIcons) {
	            zrUtil.each(this.node.operationIcons, function(item) {
	                //检查是否是内置图标
	                var opIconInstance = null;
	                var operationIcon = OperationNode.opicons[item.name.toUpperCase() + ""]
	                if (operationIcon) {
	
	                    if (this.forbidEdit) {
	                        return;
	                    }
	                    if (item.hidden) {
	                        return;
	                    }
	                    if (item.name == OperationNode.DEL) {
	                        //垃圾桶
	                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' },z:me.node.z+1,rectHover: true }, { x: 0, y: 0, width: 10, height: 15 });
	
	                        if(item.callback){
	                            opIconInstance.on("click", function(e) {
	                                e.data = item;
	                                e.node = me.node;  // 将所附的节点也传递出去
	                                if (item.callback) {
	                                    item.callback(e);
	                                }
	                            });
	                        }else{
	                            opIconInstance.on("click", function(e) {
	                                var params = {};
	                                params.event = e;
	                                params.target = this;
	                                params.type = OperationNode.DELETE_CLICK;
	                                me.trigger(params.type, params);
	                            });
	                        }
	                    } else if (item.name == OperationNode.COMMENT) {
	                        var rect = { x: 0, y: 0, width: 16, height: 16 };
	                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' }, z:me.node.z+2, rectHover: true }, rect);
	                        opIconInstance.on("click", function(e) {
	                            var params = {};
	                            params.event = e;
	                            params.target = this;
	                            params.type = OperationNode.COMMENT_CLICK;
	                            me.trigger(params.type, params);
	                        });
	                    } else {
	                        var rectOther = { x: 0, y: 0, width: 15, height: 15 };
	                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' },draggable:true,z:me.node.z+2,lineType: Connector["TYPE_" + item.name.toUpperCase()],rectHover: true }, rectOther);
	                        var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];
	                        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	                            opIconInstance.on(eveName, function(e) {
	                                var params = {};
	                                params.event = e;
	                                params.data = item.options
	                                params.type = "OperationNode:" + eveName + "Arrow";
	                                me.trigger(params.type, params);
	                            });
	                        });
	                    }
	
	                } else {
	                    opIconInstance = symbolUtil.createSymbol(item.iconPath, 0, 0, item.width || 15, item.height || 15, me.node.z+1, item.color||'#000');
	                    opIconInstance.on("click", function(e) {
	                        e.data = item;
	                        e.node = me.node;  // 将所附的节点也传递出去
	                        if (item.callback) {
	                            item.callback(e);
	                        }
	                        var param = {event:e, type:"OperationNode:" + item.name + "Click"};
	                        me._api.trigger(param.type, param);
	                    });
	                }
	                opIconInstance.name = item.name;
	                me.add(opIconInstance);
	            });
	        }
	    };
	
	    OperationNode.prototype.refreshPostion = function(node, nodeRect) {
	        var i = 0;
	        var rbPoint = zrUtil.clone(nodeRect.points[2]); //取右下角坐标
	        var rotation = node.rotation;
	        var angle = rotation / (Math.PI/180);
	        if (Math.abs(rotation) > 0) {
	            var connectorControls = Util.getConnectorControls(nodeRect, node);
	            var brControl = connectorControls.br;
	            rbPoint = [brControl.x - nodeRect.x,  brControl.y - nodeRect.y];
	        }
	        //1.定位虚框
	        if (this.virtualRect) {
	            this.virtualRect.setShape({ points: nodeRect.points });
	            this.virtualRect.attr('rotation', rotation);
	        }
	        //2.定位每个小图标
	        this.eachChild(function(nodeItem) {
	            if (!nodeItem.isSelfComputePos) {
	                // 8px是第一个操作按钮图标的距离 靠太近不好看    20px是每个图标的间隔  10px是图标向偏的距离
	                nodeItem.attr("position", [angle >= 0 ? rbPoint[0] + 8 + (i++ * 20) : rbPoint[0] - 20 - (i++ * 20), rbPoint[1] - 10]);
	            }
	        });
	
	        this.refreshPositionOther(node,nodeRect);
	    };
	
	    OperationNode.prototype.renderOther = function() {
	        //留给扩展使用
	    };
	    OperationNode.prototype.refreshPositionOther = function(node,nodeRect) {
	        //留给扩展使用
	        //3.定位整个operationNode
	        if ((node.parent && node.parent.isBg && node.parent.isBg == true) || (node.parent.type === "GroupNode")) {
	            this.attr("position", [nodeRect.x, nodeRect.y])
	        } else {
	            var nodeShapeX = node.shape? node.shape.x:0;
	            var nodeSahpeY = node.shape? node.shape.y:0;
	            this.attr("position", [nodeRect.x + node.parent.position[0]+nodeShapeX, nodeRect.y + node.parent.position[1]+nodeSahpeY])
	        }
	    };
	
	    OperationNode.prototype.cleanup = function() {
	        if(this.node.selectStyle) {
	            if (this.node.type === 'ZPath') {
	                this.node.setStyle(this.node._zCloneStyle);
	            } else if(this.node.setOrCancelSelectStyle) {
	                this.node.setOrCancelSelectStyle(false);
	             } else {
	                this._api.getZr().removeHover(this.node);
	            }
	
	        }
	    };
	
	    zrUtil.inherits(OperationNode, Node);
	    module.exports = OperationNode;
	


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	
	    var graphic = __webpack_require__(4);
	    var util = __webpack_require__(65)
	    //创建Node类 所有形状都继承Node  包括fromJSON toJSON
	    function Node() {
	        this.resourceId = util.getUUID(); // 生成节点ID
	        graphic.Group.call(this);
	    }
	
	    /**
	     * 由父类实现
	     * @return {[type]} [description]
	     */
	    Node.prototype.render = function() {};
	
	    /**
	     * 由父类实现
	     * @param  {[type]} json [description]
	     * @return {[type]}      [description]
	     */
	    Node.prototype.getRect = function(json) {};
	
	    /**
	     * drawText
	     * @description 画一个文本
	     * @param {string} name
	     * @param {string} color
	     */
	    Node.prototype.drawText = function(name, color, position) {
	        var textName = this.bpmnInfo.name, x, y;
	        if(name != null){
	            textName = name;
	        }
	        var text = new graphic.Text({
	            style: {
	                text: textName,
	                color: color ? color : this.options.text.color,
	                textFont: '12px Microsoft YaHei'
	            },
	            zlevel: 20
	        });
	        //文字绘制的位置 
	        position = position ? position : 'init';
	        switch (position) {
	            //节点下方居中位置
	            case 'init': 
	                //x = 中心点.x - 起始位置.x - 文字宽度的一半
	                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	                //y = 中心点.y - 起始位置.y + 偏移值（6）
	                y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + 6;
	                break;
	            //节点内部居中位置
	            case 'center':
	                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	                y = this.getRect().y - this.position[1] - 6;
	                break;
	            //节点内部居左位置
	            case 'left': 
	                x = this.getRect().x - this.position[0] - text.getBoundingRect().width + 6;
	                y = this.getRect().y - this.position[1] - 6;
	                break;
	            default: break;
	        }
	        text.attr("style", { x: x, y: y });
	        return {
	            text: text,
	            rect: text.getBoundingRect()
	        };
	    };
	    /**
	     * refreshText
	     * @description 刷新文本
	     */
	    Node.prototype.refreshText = function(pos) {
	        var text = this.childOfName("Title"), x, y;
	        pos = pos ? pos : 'init';
	        switch (pos) {
	            case 'init': 
	                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	                y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + 6;
	                break;
	            case 'center':
	                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	                y = this.getRect().y - this.position[1] - 6;
	                break;
	            case 'left':
	                x = 2;
	                y = this.getRect().y - this.position[1] - 6;
	                break;
	            default: break;
	        }
	        text.attr("style", { x: x, y: y });
	    };
	    /**
	     * 由父类实现
	     * @return {[type]} [description]
	     */
	    Node.prototype.toJSON = function() {};
	
	    graphic.Util.inherits(Node, graphic.Group);
	    module.exports = Node;
	


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 连接线
	 * @author wang.xiaohu
	 */
	
	    var Util = __webpack_require__(65);
	    var zrUtil = __webpack_require__(5);
	    var vec2 = __webpack_require__(15);
	    var graphic = __webpack_require__(4);
	    var Node = __webpack_require__(81);
	    var symbolUtil = __webpack_require__(83);
	    var Handle = __webpack_require__(84);
	    var EffectLine = __webpack_require__(85);
	    var ConnectionPoint = __webpack_require__(86);
	    var Point = __webpack_require__(66);
	    var Model = __webpack_require__(87);
	
	    Connector.TYPE_STRAIGHT = 'straight';
	    Connector.TYPE_JAGGED = 'jagged';
	    Connector.TYPE_CURVE = 'curve';
	    Connector.TYPE_CHAIN = 'chain';
	    Connector.RADIUS = 3;
	    Connector.START_NODE = "startNode";
	    Connector.END_NODE = "endNode";
	    Connector.LEFT = "left";
	    Connector.RIGHT = "right";
	    Connector.TOP = "top";
	    Connector.BOTTOM = "bottom";
	    Connector.BOTTOM = "bottom";
	    Connector.SEPERATOR = "-";
	    Connector.NORMAL_COLOR = "#000";
	    Connector.SELECTED_COLOR = '#74B7E0';
	    /**
	     * 构造函数
	     * @param {[type]} options [description]
	     */
	    function Connector(options) {
	        Node.call(this);
	        this.opt = options || {};
	        if (this.opt.model) {
	            this.resourceId = this.opt.model.get("resourceId");
	            this.model = this.opt.model;
	            this.opt = this.opt.model.option;
	        } else {
	            this.resourceId = Util.getUUID(); // 生成节点ID
	            this.model = new Model({});
	        }
	        var defaultOptions = {
	            symbol: { type: "arrow", size: 10, color: Connector.NORMAL_COLOR, both:false, offset:0 }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	            style: { lineWidth: 1, stroke: Connector.NORMAL_COLOR, lineType: Connector.TYPE_STRAIGHT }, //样式
	            hoverStyle: { lineWidth: 2, stroke: Connector.SELECTED_COLOR }, //移上去的样式
	            arrowHoverStyle: { fill: Connector.SELECTED_COLOR},
	            shape: { points: null, smooth: false, smoothConstraint: null }, //形状
	            position: { startPos:null, endPos:null,  //指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	                        startOffset:[0,0],  // 起始线段离节点的偏移
	                        endOffset:[0,0],    // 终止线段离节点的偏移
	                        escapeDistance:[30,30], // 第一条折线的长度，最后一条折线的长度
	                        points:null    //不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom
	                    },
	            autoChangePosition: false,
	            textContextMenu: null,
	            isEdit: true, //是否可编辑
	            text: {
	                text: null,
	                textFill: '#000000', // 文本颜色
	                textFont: '12px Microsoft YaHei',
	                textPos: 'center',
	                textRotateable: true
	            },
	            z: 0
	        }
	
	        this.options = Util.mergeOpt(defaultOptions, this.opt, true, 'textContextMenu');
	        this.handles = [];
	        this.conPointsGroup = new graphic.Group();
	        this.startNode = null;
	        this.endNode = null;
	        this.line = null;
	        this.groupCurve = new graphic.Group();
	        this.icons = []; // 用于存储线段上面的操作图标
	        this.render();
	    }
	
	
	    /**
	     * 重新画线，如果传空则根据turningPoints 重新画线
	     * @param  {[type]} points [description]
	     * @return {[type]}        [description]
	     */
	    Connector.prototype.refresh = function(arrPoints) {
	        if (arrPoints) {
	            this.turningPoints = arrPoints;
	        }
	        //将[x:0,y:0]转化为[0, 0]  给zrender使用
	        var points = Util.traslatePoints(this.turningPoints);
	
	        if ((this.options.style.lineType == Connector.TYPE_CURVE) && (points.length > 2)) {
	            this.modifyCurve(this.turningPoints);
	        } else {
	            this.line.attr('shape', { points: points });
	        }
	
	        var lineText = this.childOfName('lineText');
	        var self = this, lineTextArr = [];
	        if (this.options.style.lineType == Connector.TYPE_CHAIN && zrUtil.isArray(this.options.text.text)) {
	            this.options.text.text.forEach(function (v, i) {
	                lineTextArr.push(self.childOfName('lineText-'+i));
	            });
	        } else if (!lineText && this.options.text.text) {
	            var text = this.drawText("lineText", this.options.text.text, 0, 0);
	            this.add(text.text);
	            lineText = this.childOfName('lineText');
	        }
	        if (lineTextArr.length > 0) {
	            var cnt = lineTextArr.length,
	                distance = this.turningPoints[1].x - this.turningPoints[0].x,
	                gap = parseInt(distance/cnt),
	                pos = -(gap) * parseInt(cnt/2);
	
	            lineTextArr.forEach(function (v, i) {
	                var textPoint = self.getTextPostion(self.options.text), way = '';
	
	                var rate = self.getTextRotation(textPoint);
	                if (rate === -0 || rate === 0) {
	                    rate = 0;
	                } else {
	                    way = rate > 0 ? 'plus' : 'minus';
	                }
	                rate = Math.abs(rate);
	                var deg = (180*rate)/Math.PI;
	                var rotation = null, length = null;
	                v.setStyle("text", zrUtil.isString(self.options.text.text[i]) ? self.options.text.text[i] : self.options.text.text[i].text);
	
	                if (way) {
	                    rotation = deg > 90 ? ((deg-45)*Math.PI)/180 : ((45+deg)*Math.PI)/180;
	                    rotation = way === 'minus' ? -(rotation) : rotation;
	                } else {
	                    rotation = (45*Math.PI)/180
	                }
	                v.attr('rotation', rotation);
	
	                if (deg === 90) {
	                    textPoint[1] -= pos;
	                } else {
	                    textPoint[0] += pos;
	                    if (rate !== 0) {
	                        length = Math.tan(deg*Math.PI/180)*pos;
	                        if (pos > 0) {
	                            textPoint[1] -= way === 'plus' ? length : -(length);
	                        } else {
	                            textPoint[1] += way === 'plus' ? -(length) : (length);
	                        }
	                    }
	                }
	
	                v.attr("position", textPoint);
	                pos += gap;
	            });
	        }
	        if (lineText) {
	            lineText.setStyle("text", this.options.text.text);
	            var textPoint = this.getTextPostion(this.options.text);
	            if (this.options.style.lineType == Connector.TYPE_STRAIGHT && this.options.text.textRotateable) { //#187
	                lineText.attr('rotation', this.getTextRotation(textPoint));
	            }
	            lineText.attr("position", textPoint);
	        }
	        this.refreshFromToSymbol(points);
	    };
	    /**
	     * 渲染
	     * @return {[type]} [description]
	     */
	    Connector.prototype.render = function() {
	        var that = this;
	        //1.创建箭头
	        this.renderFromToSymbol();
	
	        //2.创建线
	        this.curveLine = new graphic.BezierCurve({
	            //position: this.options.position,
	            style: this.options.style,
	            z: this.options.z
	        });
	        this.groupCurve.add(this.curveLine);
	        this.add(this.groupCurve);
	        this.add(this.conPointsGroup);
	
	        this.polyLine = new graphic.Polyline({
	            //position: this.options.position,
	            shape: this.options.shape,
	            style: this.options.style,
	            z: this.options.z
	        });
	        this.add(this.polyLine);
	
	        if ((this.options.style.lineType == Connector.TYPE_CURVE)) {
	            this.line = this.groupCurve;
	            this.createHoverStyle(this.curveLine);
	            this.polyLine.hide();
	        } else {
	            this.line = this.polyLine;
	            this.createHoverStyle(this.polyLine);
	            this.curveLine.hide();
	        }
	
	        //3.侦听线事件
	        var MOUSE_EVENT_NAMES = ['dblclick', 'click']; //'click', 'dblclick', 'mouseover', 'mouseout'
	        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	            this.line.on(eveName, zrUtil.bind(function(e) {
	                e.cancelBubble = true;
	                var params = {};
	                params.event = e;
	                params.type = "Connector:" + eveName;
	                params.target = that;
	                this.trigger(params.type, params);
	                this.setStyle({color:Connector.SELECTED_COLOR},true);
	                if (this.options.isEdit == false) {
	                    return; }
	
	                if (this.options.isEdit && this.turningPoints.length >= 2) {
	                    this.createAllconnectionPoint()
	                }
	                if (this.handles.length < 1) {
	                    this.shapeSetHandle();
	                }
	
	            }, this));
	        }, this);
	
	        //4.创建线上文本
	        if (this.options.text.text) {
	            var text = null;
	            if (zrUtil.isArray(this.options.text.text) && this.options.style.lineType == Connector.TYPE_CHAIN) {
	                this.options.text.text.forEach(function (v, i) {
	                    var content = that.drawText("lineText-"+i, v, 0, 0);
	                    if (zrUtil.isString(v)) {
	                        var obj = {};
	                        obj.text = v;
	                        obj.textId = content.text.id;
	                        that.options.text.text[i] = obj;
	                    } else {
	                        that.options.text.text[i].textId = content.text.id;
	                    }
	                    that.add(content.text);
	                    if(content && that.opt.textContextMenu) {
	                        var textContextMenu = that.opt.textContextMenu;
	                        content.text.on("contextmenu",function(e) {
	                            e.event.preventDefault();
	                            e.event.stopPropagation();
	                            textContextMenu.buildMenu(e.event,this);
	                        })
	                    }
	                });
	            } else {
	                text = this.drawText("lineText", this.options.text.text, 0, 0);
	                this.add(text.text);
	            }
	            if(text && this.opt.textContextMenu) {
	                var textContextMenu = this.opt.textContextMenu;
	                text.text.on("contextmenu",function(e) {
	                    e.event.preventDefault();
	                    e.event.stopPropagation();
	                    textContextMenu.buildMenu(e.event,this);
	                })
	            }
	        }
	    };
	
	    Connector.prototype.renderFromToSymbol = function(options) {
	        var symbolTo = this.createSymbol('toSymbol', this.options); //arrow,triangle
	        if (symbolTo) {
	            this.add(symbolTo);
	        }
	        //如果双向箭头 则再创建首箭头
	        if (this.options.symbol.both) {
	            var symbolFrom = this.createSymbol('fromSymbol', this.options); //arrow,triangle
	            if (symbolFrom) {
	                this.add(symbolFrom);
	            }
	        }
	    }
	
	    Connector.prototype.refreshFromToSymbol = function(points) {
	        var symbolTo = this.childOfName('toSymbol');
	        var symbolFrom = this.childOfName('fromSymbol');
	        var position = [], offset = this.options.symbol.offset;
	        if (symbolTo) {
	            if (this.options.effect && this.options.effect.show) {
	                new EffectLine(symbolTo, this.options, this.groupCurve, this.polyLine);
	            } else {
	                position = points[points.length - 1];
	                if (this.options.style.lineType !== Connector.TYPE_CURVE) {
	                    var distance = vec2.distance(points[points.length - 1], points[points.length - 2]);
	                    if (offset <= distance) {
	                        position = vec2.lerp(
	                            [], points[points.length - 1], points[points.length - 2],
	                            offset / distance);
	                    } else {
	                        position = points[points.length - 1];
	                    }
	                }
	                symbolTo.attr('position', position);
	                symbolTo.attr('rotation', Util.tangentRotation(this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]));
	            }
	        }
	
	        if (symbolFrom) {
	            position = points[0];
	            if (this.options.style.lineType !== Connector.TYPE_CURVE) {
	                var distanceFrom = vec2.distance(points[0], points[1]);
	                if (offset <= distanceFrom) {
	                    position = vec2.lerp(
	                        [], points[0], points[1],
	                        offset / distanceFrom);
	                } else {
	                    position = points[0];
	                }
	            }
	            symbolFrom.attr('position', position);
	            symbolFrom.attr('rotation', Util.tangentRotation(this.turningPoints[1], this.turningPoints[0]));
	        }
	    }
	    /**
	     * 设置style
	     * @param {object} options 样式对象
	     * @param {boolean} notSaveModel 设置样式是否保存到模型中,默认是false
	     */
	    Connector.prototype.setStyle = function(options,notSaveModel) {
	        var symbolTo = null;
	        if (options.color) {
	            if (this.options.style.lineType == Connector.TYPE_CURVE) {
	                this.groupCurve.eachChild(function(curve) {
	                    curve.attr("style", { stroke: options.color });
	                    graphic.setNormalStyle(curve, { stroke: options.color });
	                });
	            } else {
	                this.polyLine.attr("style", { stroke: options.color });
	                graphic.setNormalStyle(this.polyLine, { stroke: options.color });
	            }
	            symbolTo = this.childOfName('toSymbol');
	            if (symbolTo) {
	                symbolTo.attr("style", { fill: options.color });
	                graphic.setNormalStyle(symbolTo, { fill: options.color });
	            }
	            if(!notSaveModel) {
	                this.options.style.stroke = options.color;
	                this.model.set("options.style.stroke", options.color);
	                this.model.set("options.symbol.color", options.color);
	                this.options.symbol.color = options.color;
	            }
	        }
	
	        if (options.text) {
	            var lineText = this.childOfName('lineText');
	            //开始没有创建文本，后来传进来text了，需要先创建文本
	            if (!lineText && options.text.text) {
	                var text = this.drawText("lineText", options.text.text, 0, 0);
	                this.add(text.text);
	                lineText = this.childOfName('lineText');
	            }
	
	            if (options.text.text || options.text.text == "") {
	                lineText.setStyle("text", options.text.text);
	                this.options.text.text = options.text.text;
	            }
	            var textPoint = this.getTextPostion(options.text);
	            lineText.attr("position", textPoint);
	            if (options.text.textPos) {
	                this.options.text.textPos = options.text.textPos;
	            }
	            if (options.text.offset) { //#187
	                this.options.text.offset = options.text.offset;
	            }
	
	            if (options.text.color) {
	                lineText.attr("style", {
	                    textFill: options.text.color
	                });
	                this.options.text.textFill = options.text.color;
	            }
	
	            if (options.text.textFont) {
	                lineText.attr("style", {
	                    textFont:options.text.textFont
	                });
	                this.options.text.textFont = options.text.textFont;
	            }
	
	            if (options.text.textFill) {
	                lineText.attr("style", {
	                    textFill: options.text.textFill
	                });
	                this.options.text.textFill = options.text.textFill;
	            }
	            this.model.set("options.text", options.text);
	        }
	
	        if (options.symbol) {
	            if (options.symbol.type) {
	                this.options.symbol.type = options.symbol.type;
	                this.model.set("options.symbol.type", options.symbol.type);
	            }
	            if (options.symbol.size) {
	                this.options.symbol.size = options.symbol.size;
	                this.model.set("options.symbol.size", options.symbol.size);
	            }
	            if (options.symbol.color) {
	                this.options.symbol.color = options.symbol.color;
	                this.model.set("options.symbol.color", options.symbol.color);
	            }
	            if (options.symbol.z) {
	                this.options.symbol.z = options.symbol.z;
	                this.model.set("options.symbol.z", options.symbol.z);
	            }
	
	            symbolTo = this.childOfName('toSymbol');
	            if (symbolTo) {
	                this.remove(symbolTo);
	            }
	            var symbol = this.createSymbol("toSymbol", this.model.get("options"))
	            if (symbol) {
	                this.add(symbol);
	            }
	            this.refresh();
	        }
	    };
	
	    /**
	     * 获取线段的位置
	     * @param  {Object} text {text:'', color:'', textPos:''}
	     * @return {Object}      {x,y}
	     */
	    Connector.prototype.getTextPostion = function(text) {
	        var textPostion = [];
	        var textWidth = graphic.textContain.getWidth(text.text, text.textFont);
	        if (text && text.textPos) {
	            var offset = text.offset || 0;
	            var arrOffset = offset;
	            if (!zrUtil.isArray(offset)) {
	                arrOffset = [offset, 0];
	            }
	            if (text.textPos == 'start') {
	                textPostion = [this.turningPoints[0].x + arrOffset[0], this.turningPoints[0].y + arrOffset[1]];
	            } else if (text.textPos == 'end') {
	                var points = Util.getMaxLineLength([this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]]);
	                var angle = Util.getAngle(points[0], points[1]);
	                var length = Util.distance(points[0], points[1]) - textWidth;
	                var newPoint = Util.getEndPoint(points[0], length, angle);
	                textPostion = [newPoint.x + arrOffset[0], newPoint.y + arrOffset[1]];
	            } else {
	                var midPoint = this.middle(text);
	                textPostion = [midPoint[0] + arrOffset[0], midPoint[1] + arrOffset[1]];
	            }
	        } else {
	            var position = this.middle(text);
	            textPostion = [position[0] - textWidth / 2, position[1]];
	        }
	
	        return textPostion;
	    };
	
	    /**
	     * 获取线段的旋转角度
	     * @param  {Object} textPostion {x,y}
	     * @return {Number}             角度值
	     */
	    Connector.prototype.getTextRotation = function(textPostion) {
	        //计算出极坐标的角度
	        var points = Util.getMaxLineLength(this.turningPoints);
	        var angle = -Math.atan2(points[1].y - textPostion[1], points[1].x - textPostion[0]); //,Math.PI/2
	        return angle;
	    };
	
	    Connector.prototype.createHoverStyle = function(el) {
	        if (this.options.hoverStyle) {
	            graphic.setElementHoverStl(el, this.options.hoverStyle);
	
	            var symbolTo = this.childOfName('toSymbol');
	            if (symbolTo) { graphic.setElementHoverStl(symbolTo, this.options.arrowHoverStyle); }
	
	            el.on('mouseover', zrUtil.bind(function() {
	                    graphic.doEnterHover(el);
	                    if (symbolTo) { graphic.doEnterHover(symbolTo); }
	
	                    this.groupCurve.eachChild(function(line) {
	                        graphic.doEnterHover(line);
	                    });
	                }, this))
	                .on('mouseout', zrUtil.bind(function() {
	                    graphic.doLeaveHover(el);
	                    if (symbolTo) { graphic.doLeaveHover(symbolTo); }
	                    this.groupCurve.eachChild(function(line) {
	                        graphic.doLeaveHover(line);
	                    });
	                }, this));
	        }
	    };
	    /**
	     * 创建Node的连接点
	     * @private
	     *
	     * @return {[type]} [description]
	     */
	    Connector.prototype.createAllconnectionPoint = function() {
	        this.connectionPointCreate(this, this.turningPoints[0].clone(), ConnectionPoint.TYPE_CONNECTOR);
	        this.connectionPointCreate(this, this.turningPoints[this.turningPoints.length - 1].clone(), ConnectionPoint.TYPE_CONNECTOR);
	    };
	
	    /**
	     * 创建连接点
	     * @private
	     * @param  {[type]} shape [description]
	     * @param  {[type]} point [description]
	     * @param  {[type]} type  [description]
	     * @return {[type]}       [description]
	     */
	    Connector.prototype.connectionPointCreate = function(shape, point, type) {
	        var conPoint = new ConnectionPoint(this, point, type, this.options);
	        this.conPointsGroup.add(conPoint.shape);
	    };
	
	    /**
	     * 清空控制点
	     * @return {[type]} [description]
	     */
	    Connector.prototype.clearHandles = function() {
	        for (var i = 0; i < this.handles.length; i++) {
	            this.remove(this.handles[i].handleShape);
	        }
	        this.handles = [];
	        if (this.conPointsGroup) {
	            this.conPointsGroup.removeAll();
	        }
	        //恢复原来的颜色
	        this.setStyle({color:this.options.style.stroke},true);
	    };
	
	    /**
	     * 创建拆线 线断的控制点
	     * @return {[type]} [description]
	     */
	    Connector.prototype.shapeSetHandle = function() {
	        for (var i = 1; i < this.turningPoints.length - 2; i++) {
	            var h;
	            var x, y;
	            //是否在一条线上
	            var isCollineaityFirst = Util.collinearity(this.turningPoints[i - 1], this.turningPoints[i], this.turningPoints[i + 1]);
	            var isCollineaitySecond = Util.collinearity(this.turningPoints[i], this.turningPoints[i + 1], this.turningPoints[i + 2]);
	            if ((!isCollineaityFirst && (!isCollineaitySecond || this.turningPoints[i + 1].equals(this.turningPoints[i + 2]))) || ((!isCollineaityFirst || this.turningPoints[i - 1].equals(this.turningPoints[i])) && !isCollineaitySecond)) {
	
	                if (this.turningPoints[i].x === this.turningPoints[i + 1].x) { //same vertical
	                    x = this.turningPoints[i].x;
	                    y = (this.turningPoints[i].y + this.turningPoints[i + 1].y) / 2;
	
	                    h = new Handle('h', x, y, this);
	
	
	                } else if (this.turningPoints[i].y === this.turningPoints[i + 1].y) { // same horizontal
	                    x = (this.turningPoints[i].x + this.turningPoints[i + 1].x) / 2;
	                    y = this.turningPoints[i].y;
	                    h = new Handle('v', x, y, this);
	                }
	                if (h) {
	                    this.add(h.handleShape);
	                    this.handles.push(h);
	                }
	
	            }
	        }
	    };
	
	
	    /**
	     * 创建箭头
	     * @param  {[type]} name       [description]
	     * @param  {[type]} options [description]
	     * @return {[type]}            [description]
	     */
	    Connector.prototype.createSymbol = function(name, options) {
	        var symbolType = options.symbol.type;
	        var symbolSize = options.symbol.size;
	        if (symbolType === 'none') {
	            return;
	        }
	
	        if (!zrUtil.isArray(symbolSize)) {
	            symbolSize = [symbolSize, symbolSize];
	        }
	
	        var symbolZIndex = options.z;
	
	        if (options.symbol.z) { symbolZIndex = options.symbol.z }
	
	        var symbolPath = symbolUtil.createSymbol(
	            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,
	            symbolSize[0], symbolSize[1], symbolZIndex, options.symbol.color
	        );
	        symbolPath.name = name;
	
	        return symbolPath;
	    };
	
	    /**
	     * 绘制线段上的文本
	     * @param  {[type]} content [description]
	     * @param  {[type]} name [description]
	     * @param  {[type]} x       [description]
	     * @param  {[type]} y       [description]
	     * @param  {[type]} color   [description]
	     * @return {[type]}         [description]
	     */
	    Connector.prototype.drawText = function(name, content, x, y, color) {
	        var opt = zrUtil.isString(content) ? {text:content, x:x, y:y, fill:color}
	                                           : zrUtil.defaults({x:x, y:y, fill:color}, content, true);
	
	        var textStyle = zrUtil.defaults(zrUtil.clone(this.options.text), opt, true);
	        var text = new graphic.Text({
	            style: textStyle,
	            zlevel: 20,
	            name : name
	        });
	        return {
	            text: text,
	            rect: text.getBoundingRect()
	        };
	    };
	
	    /**
	     * 获取线段的中间值
	     * @return {[type]} text
	     */
	    Connector.prototype.middle = function() {
	
	        if (this.options.style.lineType == Connector.TYPE_STRAIGHT || this.options.style.lineType == Connector.TYPE_CHAIN) {
	            var points = Util.getMaxLineLength(this.turningPoints);
	            //如果是求线段上的文字的中间值
	            // if(text) {
	            //     //取出字的长度，计算角度，
	            //     var textWidth = graphic.textContain.getWidth(text.text, text.textFont);
	            //     var angle = Util.getAngle(points[0],points[1]);
	            //     var length =  Util.distance(points[0],points[1])/2 - textWidth/2;
	            //     var newPoint = Util.getEndPoint(points[0], length, angle);
	            //     return [newPoint.x, newPoint.y];
	            // } else {
	            //     var middleX = (points[0].x + points[1].x)/2;
	            //     var middleY = (points[0].y + points[1].y) /2;
	            //     return [middleX, middleY];
	            // }
	            var middleX = (points[0].x + points[1].x) / 2;
	            var middleY = (points[0].y + points[1].y) / 2;
	            return [middleX, middleY];
	        } else if (this.options.style.lineType == Connector.TYPE_JAGGED) {
	
	            //find total distance
	            var distance = this.getLength();
	
	            //find between what turning points the half distance is
	            var index = -1;
	            var ellapsedDistance = 0;
	            for (var i = 0; i < this.turningPoints.length - 1; i++) {
	                index = i;
	                var segment = Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);
	                if (ellapsedDistance + segment < distance / 2) {
	                    ellapsedDistance += segment;
	                } else {
	                    break;
	                }
	            }
	
	            //we have the middle distance somewhere between i(ndex) and i(ndex)+1
	            if (index != -1) {
	                var missingDistance = distance / 2 - ellapsedDistance;
	                if (Util.round(this.turningPoints[index].x, 3) == Util.round(this.turningPoints[index + 1].x, 3)) { //vertical segment (same x)
	                    return [this.turningPoints[index].x, Math.min(this.turningPoints[index].y, this.turningPoints[index + 1].y) + missingDistance];
	                } else if (Util.round(this.turningPoints[index].y, 3) == Util.round(this.turningPoints[index + 1].y, 3)) { //horizontal segment (same y)
	                    return [Math.min(this.turningPoints[index].x, this.turningPoints[index + 1].x) + missingDistance, this.turningPoints[index].y];
	                } else {
	                    console.error("Connector:middle() - this should never happen " + this.turningPoints[index] + " " + this.turningPoints[index + 1] + " nr of points " + this.turningPoints.length);
	                }
	
	            }
	        } else if (this.options.style.lineType == Connector.TYPE_CURVE) {
	            var t = 0.5;
	            var l = this.getLength();
	
	            var walked = 0;
	            for (var j = 0; j < this.turningPoints.length - 1; j++) {
	                if (walked + Util.distance(this.turningPoints[j], this.turningPoints[j + 1]) > l * t) {
	                    break;
	                }
	
	                walked += Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);
	            }
	
	            var rest = l * t - walked;
	            var currentSegmentLength = Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);
	
	            //find the position/ration of the middle of Polyline on current segment
	            var segmentPercent = rest / currentSegmentLength;
	
	            var Xp = segmentPercent * (this.turningPoints[j + 1].x - this.turningPoints[j].x) + this.turningPoints[j].x;
	            var Yp = segmentPercent * (this.turningPoints[j + 1].y - this.turningPoints[j].y) + this.turningPoints[j].y;
	
	            return [Xp, Yp];
	
	        }
	
	        return null;
	    };
	
	    /**
	     * find total distance
	     * @return {Number} [description]
	     */
	    Connector.prototype.getLength = function() {
	        //find total distance
	        var distance = 0;
	        for (var i = 0; i < this.turningPoints.length - 1; i++) {
	            distance += Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);
	        }
	        return distance;
	    };
	
	    /**
	     * 转JSON对象 bpmn使用
	     * @return {[type]} [description]
	     */
	    Connector.prototype.toJSON = function() {
	
	        this.model.set("resourceId", this.resourceId);
	        this.model.set("properties.type", 14);
	
	        this.model.set("bounds.upperLeft.x", this.position[0]);
	        this.model.set("bounds.upperLeft.y", this.position[1]);
	        this.model.set("bounds.lowerRight.x", parseInt(this.position[0] + this.getBoundingRect().width));
	        this.model.set("bounds.lowerRight.y", parseInt(this.position[1] + this.getBoundingRect().height));
	        this.model.set("style.sPos", this.options.position.startPos);
	        this.model.set("style.ePos", this.options.position.endPos);
	        this.model.set("style.lineDash", this.options.style.lineDash);
	        this.model.set("style.stroke", this.options.style.stroke);
	        this.model.set("symbol.type", this.options.symbol.type);
	        this.model.set("dockers", this.turningPoints);
	        return this.model.option;
	    };
	
	    /**
	     * refreshModel  flow当序列化的时候调用 更新线段的位置 及线上的icons
	     * @return {[type]} [description]
	     */
	    Connector.prototype.refreshModel = function() {
	        this.model.set("options", zrUtil.clone(this.options));
	        this.model.set("options.dockers", this.turningPoints);
	        var icons = [];
	        for (var i = 0; i < this.icons.length; i++) {
	            var iconNode = this.icons[i];
	            var option = [iconNode.key, {
	                icon: iconNode.style.image,
	                width: iconNode.style.width,
	                height: iconNode.style.height
	            }];
	            icons.push(option);
	        }
	        this.model.set("icons", icons);
	    };
	
	    /**
	     * 调整曲线的形状
	     * @param  {array} points 点数组
	     * @return {void}
	     */
	    Connector.prototype.modifyCurve = function(points) {
	        var sol = this.getCurvePoint(points);
	
	        // 1. 如果曲线的数量 比数量的中数量要少 则删除多余的线段
	        var willDelCurves = [];
	        for (var j = sol.length, cntCurve = this.groupCurve.childCount(); j < cntCurve; j++) {
	            willDelCurves.push(this.groupCurve.childAt(j));
	        }
	        zrUtil.each(willDelCurves, function(curve) {
	            this.groupCurve.remove(curve);
	        }, this);
	        // 2. 遍历曲线   如果存在则直接设置形状，否则创建
	        for (var i = 0; i < sol.length; i++) {
	            var line = this.groupCurve.childAt(i);
	            if (line) {
	                line.attr('shape', sol[i]);
	            } else {
	                var cure = new graphic.BezierCurve({
	                   // position: this.options.position,
	                    style: this.options.style,
	                    shape: sol[i],
	                    z: this.options.z
	                });
	                this.groupCurve.add(cure);
	                this.createHoverStyle(cure);
	            }
	        }
	    };
	
	
	    /**
	     * 根据传入的点数组计算曲线的点
	     * @param  {array} P 点数组
	     * @return {object}        曲线的点数组
	     */
	    Connector.prototype.getCurvePoint = function(P) {
	        var n = P.length;
	        var sol = [];
	        if (n === 3) {
	            sol.push({
	                x1: P[0].x,
	                y1: P[0].y,
	                cpx1: P[1].x,
	                cpy1: P[1].y,
	                x2: P[2].x,
	                y2: P[2].y
	            });
	            return sol;
	        } else if (n === 4) {
	            sol.push({
	                x1: P[0].x,
	                y1: P[0].y,
	                cpx1: P[1].x,
	                cpy1: P[1].y,
	                cpx2: P[2].x,
	                cpy2: P[2].y,
	                x2: P[3].x,
	                y2: P[3].y
	            });
	            return sol;
	        }
	
	
	        /**Computes the sum between two point
	         *@param p1 - {Point}
	         *@param p2 - {Point}
	         *@return {Point} the sum of initial points
	         **/
	        function sum(p1, p2) {
	            return new Point(p1.x + p2.x, p1.y + p2.y);
	        }
	
	
	        /**Computes the division of a {Point} by a number
	         *@param p - {Point}
	         *@param nr - {Number}
	         *@return {Point}
	         **/
	        function divide(p, nr) {
	            if (nr == 0) {
	                throw "Division by zero not allowed (yet :) " + this.callee;
	            }
	            return new Point(p.x / nr, p.y / nr);
	        }
	
	        /**Computes the multiplication of a {Point} by a number
	         *@param p - {Point}
	         *@param nr - {Number}
	         *@return {Point}
	         **/
	        function multiply(p, nr) {
	            return new Point(p.x * nr, p.y * nr);
	        }
	
	
	
	
	        /*
	         *I do not get why first 4 must be 0 and last 3 of same value.....
	         *but otherwise we will get division by zero
	         */
	        var k = [0, 0, 0];
	
	        var j;
	        for (j = 0; j <= n - 3; j++) {
	            k.push(j);
	        }
	
	        k.push(n - 3, n - 3);
	
	
	
	        for (var i = 1; i <= n - 3; i++) {
	            //q1 - compute start point
	            var q1 = divide(sum(multiply(P[i], k[i + 4] - k[i + 2]), multiply(P[i + 1], k[i + 2] - k[i + 1])), k[i + 4] - k[i + 1]);
	
	            //q0 - compute 1st controll point
	            var q_01 = (k[i + 3] - k[i + 2]) / (k[i + 3] - k[i + 1]);
	            var q_02 = divide(sum(multiply(P[i - 1], k[i + 3] - k[i + 2]), multiply(P[i], k[i + 2] - k[i])), k[i + 3] - k[i]);
	            var q_03 = multiply(q1, (k[i + 2] - k[i + 1]) / (k[i + 3] - k[i + 1]));
	            var q0 = sum(multiply(q_02, q_01), q_03);
	
	            //q2 - compute 2nd controll point
	            var q2 = divide(sum(multiply(P[i], k[i + 4] - k[i + 3]), multiply(P[i + 1], k[i + 3] - k[i + 1])), k[i + 4] - k[i + 1]);
	
	            //q3 - compute end point
	            var q_31 = (k[i + 3] - k[i + 2]) / (k[i + 4] - k[i + 2]);
	            var q_32 = divide(sum(multiply(P[i + 1], k[i + 5] - k[i + 3]), multiply(P[i + 2], k[i + 3] - k[i + 2])), k[i + 5] - k[i + 2]);
	            var q_33 = multiply(q2, (k[i + 4] - k[i + 3]) / (k[i + 4] - k[i + 2]));
	            var q3 = sum(multiply(q_32, q_31), q_33);
	
	            //store solution
	            //
	            sol.push({
	                x1: q0.x,
	                y1: q0.y,
	                cpx1: q1.x,
	                cpy1: q1.y,
	                cpx2: q2.x,
	                cpy2: q2.y,
	                x2: q3.x,
	                y2: q3.y
	            });
	        }
	
	        return sol;
	    };
	
	
	    Util.inherits(Connector, Node);
	
	    module.exports = Connector;
	
	


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// Symbol factory
	
	
	    var graphic = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(27);
	    /**
	     * Triangle shape
	     * @inner
	     */
	    var Triangle = graphic.extendShape({
	        type: 'triangle',
	        shape: {
	            cx: 0,
	            cy: 0,
	            width: 0,
	            height: 0
	        },
	        buildPath: function (path, shape) {
	            var cx = shape.cx;
	            var cy = shape.cy;
	            var width = shape.width / 2;
	            var height = shape.height / 2;
	            path.moveTo(cx, cy - height);
	            path.lineTo(cx + width, cy + height);
	            path.lineTo(cx - width, cy + height);
	            path.closePath();
	        }
	    });
	    /**
	     * Diamond shape
	     * @inner
	     */
	    var Diamond = graphic.extendShape({
	        type: 'diamond',
	        shape: {
	            cx: 0,
	            cy: 0,
	            width: 0,
	            height: 0
	        },
	        buildPath: function (path, shape) {
	            var cx = shape.cx;
	            var cy = shape.cy;
	            var width = shape.width / 2;
	            var height = shape.height / 2;
	            path.moveTo(cx, cy - height);
	            path.lineTo(cx + width, cy);
	            path.lineTo(cx, cy + height);
	            path.lineTo(cx - width, cy);
	            path.closePath();
	        }
	    });
	
	    /**
	     * Pin shape
	     * @inner
	     */
	    var Pin = graphic.extendShape({
	        type: 'pin',
	        shape: {
	            // x, y on the cusp
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (path, shape) {
	            var x = shape.x;
	            var y = shape.y;
	            var w = shape.width / 5 * 3;
	            // Height must be larger than width
	            var h = Math.max(w, shape.height);
	            var r = w / 2;
	
	            // Dist on y with tangent point and circle center
	            var dy = r * r / (h - r);
	            var cy = y - h + r + dy;
	            var angle = Math.asin(dy / r);
	            // Dist on x with tangent point and circle center
	            var dx = Math.cos(angle) * r;
	
	            var tanX = Math.sin(angle);
	            var tanY = Math.cos(angle);
	
	            path.arc(
	                x, cy, r,
	                Math.PI - angle,
	                Math.PI * 2 + angle
	            );
	
	            var cpLen = r * 0.6;
	            var cpLen2 = r * 0.7;
	            path.bezierCurveTo(
	                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,
	                x, y - cpLen2,
	                x, y
	            );
	            path.bezierCurveTo(
	                x, y - cpLen2,
	                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,
	                x - dx, cy + dy
	            );
	            path.closePath();
	        }
	    });
	
	    /**
	     * Arrow shape
	     * @inner
	     */
	    var Arrow = graphic.extendShape({
	
	        type: 'arrow',
	
	        shape: {
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var height = shape.height;
	            var width = shape.width;
	            var x = shape.x;
	            var y = shape.y;
	            var dx = width / 3 * 2;
	            ctx.moveTo(x, y);
	            ctx.lineTo(x + dx, y + height);
	            ctx.lineTo(x, y + height / 4 * 3);
	            ctx.lineTo(x - dx, y + height);
	            ctx.lineTo(x, y);
	            ctx.closePath();
	        }
	    });
	
	    /**
	     * Map of path contructors
	     * @type {Object.<string, module:zrender/graphic/Path>}
	     */
	    var symbolCtors = {
	        line: graphic.Line,
	
	        rect: graphic.Rect,
	
	        roundRect: graphic.Rect,
	
	        square: graphic.Rect,
	
	        circle: graphic.Circle,
	
	        diamond: Diamond,
	
	        pin: Pin,
	
	        arrow: Arrow,
	
	        triangle: Triangle
	    };
	
	    var symbolShapeMakers = {
	
	        line: function (x, y, w, h, shape) {
	            // FIXME
	            shape.x1 = x;
	            shape.y1 = y + h / 2;
	            shape.x2 = x + w;
	            shape.y2 = y + h / 2;
	        },
	
	        rect: function (x, y, w, h, shape) {
	            shape.x = x;
	            shape.y = y;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        roundRect: function (x, y, w, h, shape) {
	            shape.x = x;
	            shape.y = y;
	            shape.width = w;
	            shape.height = h;
	            shape.r = Math.min(w, h) / 4;
	        },
	
	        square: function (x, y, w, h, shape) {
	            var size = Math.min(w, h);
	            shape.x = x;
	            shape.y = y;
	            shape.width = size;
	            shape.height = size;
	        },
	
	        circle: function (x, y, w, h, shape) {
	            // Put circle in the center of square
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.r = Math.min(w, h) / 2;
	        },
	
	        diamond: function (x, y, w, h, shape) {
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        pin: function (x, y, w, h, shape) {
	            shape.x = x + w / 2;
	            shape.y = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        arrow: function (x, y, w, h, shape) {
	            shape.x = x + w / 2;
	            shape.y = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        triangle: function (x, y, w, h, shape) {
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        }
	    };
	
	    var symbolBuildProxies = {};
	    for (var name in symbolCtors) {
	        symbolBuildProxies[name] = new symbolCtors[name]();
	    }
	
	    var Symbol = graphic.extendShape({
	
	        type: 'symbol',
	
	        shape: {
	            symbolType: '',
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        beforeBrush: function () {
	            var style = this.style;
	            var shape = this.shape;
	            // FIXME
	            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {
	                style.textPosition = ['50%', '40%'];
	                style.textAlign = 'center';
	                style.textVerticalAlign = 'middle';
	            }
	        },
	
	        buildPath: function (ctx, shape) {
	            var symbolType = shape.symbolType;
	            var proxySymbol = symbolBuildProxies[symbolType];
	            if (shape.symbolType !== 'none') {
	                if (!proxySymbol) {
	                    // Default rect
	                    symbolType = 'rect';
	                    proxySymbol = symbolBuildProxies[symbolType];
	                }
	                symbolShapeMakers[symbolType](
	                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape
	                );
	                proxySymbol.buildPath(ctx, proxySymbol.shape);
	            }
	        }
	    });
	
	    // Provide setColor helper method to avoid determine if set the fill or stroke outside
	    var symbolPathSetColor = function (color) {
	        if (this.type !== 'image') {
	            var symbolStyle = this.style;
	            var symbolShape = this.shape;
	            if (symbolShape && symbolShape.symbolType === 'line') {
	                symbolStyle.stroke = color;
	            }
	            else if (this.__isEmptyBrush) {
	                symbolStyle.stroke = color;
	                symbolStyle.fill = '#fff';
	            }
	            else {
	                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?
	                symbolStyle.fill && (symbolStyle.fill = color);
	                symbolStyle.stroke && (symbolStyle.stroke = color);
	            }
	            this.dirty();
	        }
	    };
	
	    var symbolUtil = {
	        /**
	         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
	         * @param {string} symbolType
	         * @param {number} x
	         * @param {number} y
	         * @param {number} w
	         * @param {number} h
	         * @param {number} z
	         * @param {string} color
	         */
	        createSymbol: function (symbolType, x, y, w, h, z, color) {
	            var isEmpty = symbolType.indexOf('empty') === 0;
	            if (isEmpty) {
	                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
	            }
	            var symbolPath;
	
	            if (symbolType.indexOf('image://') === 0) {
	                symbolPath = new graphic.Image({
	                    style: {
	                        image: symbolType.slice(8),
	                        x: x,
	                        y: y,
	                        width: w,
	                        height: h
	                    },
	                    z: z
	                });
	            }
	            else if (symbolType.indexOf('path://') === 0) {
	                symbolPath = graphic.makePath(symbolType.slice(7), {z: z, rectHover: true}, new BoundingRect(x, y, w, h));
	            }
	            else {
	                symbolPath = new Symbol({
	                    shape: {
	                        symbolType: symbolType,
	                        x: x,
	                        y: y,
	                        width: w,
	                        height: h
	                    },
	                    z: z
	                });
	            }
	
	            symbolPath.__isEmptyBrush = isEmpty;
	
	            symbolPath.setColor = symbolPathSetColor;
	
	            symbolPath.setColor(color);
	
	            return symbolPath;
	        }
	    };
	
	    module.exports = symbolUtil;
	


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 画句柄
	 * @author wang.xiaohu
	 */
	
	    var graphic = __webpack_require__(4);
	    var Util = __webpack_require__(65);
	    function Handle(type, x, y, connector){
	        this.type = type;
	
	        this.x = x;
	
	        this.y = y;
	
	        this.visible = true;
	
	        this.connector = connector;
	
	        this.handleShape = new graphic.Circle({
	            shape: {
	                cx: x,
	                cy: y,
	                r: Handle.RADIUS
	            },
	
	            style: {
	                fill: "rgb(0,255,0)",
	                stroke:"rgb(0,0,0)"
	            },
	            z : connector.options.z + 2,  //节点Z为1 线段为0;
	            draggable:true
	        });
	
	        var that = this;
	        this.handleShape.on("drag", function(e) {
	            that.actionConnector(e.offsetX,e.offsetY);
	        });
	       // return this.circle;
	    }
	
	    Handle.RADIUS = 4;
	
	    Handle.prototype = {
	
	        constructor : Handle,
	
	        equals : function(anotherHandle){
	            if(!anotherHandle instanceof Handle){
	                return false;
	            }
	
	            return this.type == anotherHandle.type
	            && this.x == anotherHandle.x
	            && this.y == anotherHandle.y
	            && this.visible == anotherHandle.visible;
	        },
	
	        /**
	         * 移动句柄
	         * @param  {[type]} newX [description]
	         * @param  {[type]} newY [description]
	         * @return {[type]}      [description]
	         */
	        actionConnector: function(newX, newY){
	            switch(this.type){
	                case 'v':
	                    var index;
	                    // 找出两个转折点（可移动句柄在这两个转折点中间）
	                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){
	                        if(this.connector.turningPoints[i-1].y == this.connector.turningPoints[i].y
	                            && this.connector.turningPoints[i].y == this.y
	                            && Math.min(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) <= this.x
	                            && Math.max(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) >= this.x)
	                        {
	                            index = i;
	                        }
	                    }
	                    var deltaY = newY - this.y;
	                    var translationMatrix = Util.translationMatrix(0, deltaY);
	
	                    this.connector.turningPoints[index-1].transform(translationMatrix);
	                    this.connector.turningPoints[index].transform(translationMatrix);
	                    this.connector.refresh();
	                    this.y = newY;  //将句柄新的位置赋值给y
	
	                    break;
	
	                case 'h':
	                    var index;
	                    // 找出两个转折点（可移动句柄在这两个转折点中间）
	                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){
	                        if(this.connector.turningPoints[i-1].x == this.connector.turningPoints[i].x
	                            && this.connector.turningPoints[i].x == this.x
	                            && Math.min(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) <= this.y
	                            && Math.max(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) >= this.y)
	                            {
	                            index = i;
	                        }
	                    }
	                    var deltaX = newX-this.x;
	                    var translationMatrix = Util.translationMatrix(deltaX, 0);
	                    this.connector.turningPoints[index-1].transform(translationMatrix);
	                    this.connector.turningPoints[index].transform(translationMatrix);
	                    this.connector.refresh();
	                    this.x = newX; //将句柄新的位置赋值给x
	
	                    break;
	            }
	           //. this.shape.updateMiddleText();
	        }
	    };
	    module.exports = Handle;
	
	
	


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 连线动态效果
	 * @author miao.cunzhi
	 */
	
	    var zrUtil = __webpack_require__(5);
	    var vec2 = __webpack_require__(15);
	    var curveUtil = __webpack_require__(31);
	    var symbolUtil = __webpack_require__(83);
	
	    function EffectLine(symbol, options, groupCurve, polyLine) {
	        this._lastFrame = 0;
	        this._lastFramePercent = 0;
	        this.symbol = symbol;
	        this.groupCurve = groupCurve;
	        this.initSymbol(options, polyLine);
	    }
	    var EffectLineProto = EffectLine.prototype;
	
	    EffectLineProto.initSymbol = function(options, polyLine) {
	        var that = this;
	        this.symbol.z2 = 100;
	        this.symbol.culling = true;
	        var period = options.effect.period * 1000;
	        this.symbol.__t = 0;
	        this.symbol.stopAnimation();
	        if ((options.style.lineType == "curve")) {
	            if (this.groupCurve) {
	                var i = 0;
	                period = period / this.groupCurve._children.length;
	                this.groupCurveAnimate(this.groupCurve._children[0], i, period);
	            }
	
	        } else {
	            this.symbol.animate('', true)
	                .when(period, {
	                    __t: 1
	                })
	                .delay(0)
	                .during(function() {
	                    that.updateSymbolPositionPolyline();
	                })
	                .start();
	            this.setAnimationPointsPolyline(polyLine.shape.points);
	        }
	
	    };
	
	    EffectLineProto.groupCurveAnimate = function(curveLine, i, period) {
	        var that = this;
	        if (curveLine == undefined) {
	            curveLine = this.groupCurve._children[0];
	            i = 0;
	        }
	        var points;
	        var pos = curveLine.shape;
	        points = [
	            [pos.x1, pos.y1],
	            [pos.x2, pos.y2],
	            [pos.cpx1, pos.cpy1],
	            [pos.cpx2, pos.cpy2]
	        ];
	        this.setAnimationPointsBezierCurve(points);
	        this.symbol.animate('')
	            .when(period, {
	                __t: 1
	            })
	            .delay(0)
	            .during(function() {
	                that.updateSymbolPositionBezierCurve();
	            })
	            .done(function() {
	                that.symbol.__t = 0;
	                that.groupCurveAnimate(that.groupCurve._children[i + 1], i + 1, period);
	            })
	            .start();
	
	    };
	
	
	    EffectLineProto.setAnimationPointsBezierCurve = function(points) {
	        this.symbol.__p1 = points[0];
	        this.symbol.__p2 = points[1];
	        this.symbol.__cp1 = points[2] || [
	            (points[0][0] + points[1][0]) / 2,
	            (points[0][1] + points[1][1]) / 2
	        ];
	        this.symbol.__cp2 = points[3];
	    };
	
	    EffectLineProto.updateSymbolPositionBezierCurve = function() {
	        var p1 = this.symbol.__p1;
	        var p2 = this.symbol.__p2;
	        var cp1 = this.symbol.__cp1;
	        var cp2 = this.symbol.__cp2;
	        var t = this.symbol.__t;
	        var pos = this.symbol.position;
	        var tx, ty;
	        if (cp2[0] != undefined) {
	            var cubicAt = curveUtil.cubicAt;
	            var cubicDerivativeAt = curveUtil.cubicDerivativeAt;
	            pos[0] = cubicAt(p1[0], cp1[0], cp2[0], p2[0], t);
	            pos[1] = cubicAt(p1[1], cp1[1], cp2[1], p2[1], t);
	            // Tangent
	            tx = cubicDerivativeAt(p1[0], cp1[0], cp2[0], p2[0], t);
	            ty = cubicDerivativeAt(p1[1], cp1[1], cp2[1], p2[1], t);
	        } else {
	            var quadraticAt = curveUtil.quadraticAt;
	            var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;
	            pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);
	            pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);
	            // Tangent
	            tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);
	            ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);
	        }
	        this.symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
	
	        this.symbol.ignore = false;
	    };
	
	    EffectLineProto.setAnimationPointsPolyline = function(points) {
	        this._points = points;
	        var accLenArr = [0];
	        var len = 0;
	        for (var i = 1; i < points.length; i++) {
	            var p1 = points[i - 1];
	            var p2 = points[i];
	            len += vec2.dist(p1, p2);
	            accLenArr.push(len);
	        }
	        if (len === 0) {
	            return;
	        }
	
	        for (var j = 0; j < accLenArr.length; j++) {
	            accLenArr[j] /= len;
	        }
	        this._offsets = accLenArr;
	        this._length = len;
	        this.symbol._lastFrame = 0;
	        this.symbol.__lastFramePercent = 0;
	    };
	
	    EffectLineProto.updateSymbolPositionPolyline = function() {
	        var t = this.symbol.__t;
	        var points = this._points;
	        var offsets = this._offsets;
	        var len = points.length;
	
	        if (!offsets) {
	            // Has length 0
	            return;
	        }
	
	        var lastFrame = this._lastFrame;
	        var frame;
	
	        if (t < this._lastFramePercent) {
	            // Start from the next frame
	            // PENDING start from lastFrame ?
	            var start = Math.min(lastFrame + 1, len - 1);
	            for (frame = start; frame >= 0; frame--) {
	                if (offsets[frame] <= t) {
	                    break;
	                }
	            }
	            // PENDING really need to do this ?
	            frame = Math.min(frame, len - 2);
	        } else {
	            for (var frame = lastFrame; frame < len; frame++) {
	                if (offsets[frame] > t) {
	                    break;
	                }
	            }
	            frame = Math.min(frame - 1, len - 2);
	        }
	        vec2.lerp(
	            this.symbol.position, points[frame], points[frame + 1],
	            (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame])
	        );
	
	        this._lastFrame = frame;
	        this._lastFramePercent = t;
	        var angle = -Math.atan2(points[frame + 1][1] - points[frame][1], points[frame + 1][0] - points[frame][0]);
	        this.symbol.rotation = angle - Math.PI / 2;
	        this.symbol.ignore = false;
	    };
	    module.exports = EffectLine;
	


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 控制点
	 * @author wang.xiaohu
	 */
	
	    var graphic = __webpack_require__(4);
	    function ConnectionPoint(connector, point, type, options){
	        this.connector = connector;
	
	        this.point = point.clone();
	
	        this.type = type;
	
	        this.color = ConnectionPoint.NORMAL_COLOR;
	
	        this.oType = 'ConnectionPoint';
	
	        this.shape = new graphic.Circle({
	            shape: {
	                cx: this.point.x,
	                cy: this.point.y,
	                r: ConnectionPoint.RADIUS
	            },
	
	            style: {
	                fill: this.color,
	                stroke:'#000000'
	            },
	            z : options.z + 2  //节点Z为1 线段为0;
	        });
	        this.shape.type =  this.type;
	
	        this.shape.connector = connector;
	        //return this.circle;
	    }
	
	    ConnectionPoint.NORMAL_COLOR = "#FFFF33"; //yellow.
	
	    ConnectionPoint.OVER_COLOR = "#FF9900"; //orange
	
	    ConnectionPoint.CONNECTED_COLOR = "#ff0000"; //red
	
	    ConnectionPoint.RADIUS = 4;
	
	    ConnectionPoint.TYPE_FIGURE = 'figure';
	
	    ConnectionPoint.TYPE_CONNECTOR = 'connector';
	
	    ConnectionPoint.prototype = {
	
	        constructor : ConnectionPoint,
	
	        equals : function(anotherConnectionPoint){
	            return this.point.equals(anotherConnectionPoint.point)
	            && this.connector == anotherConnectionPoint.connector
	            && this.type == anotherConnectionPoint.type
	            && this.color == anotherConnectionPoint.color
	            && this.radius == anotherConnectionPoint.radius;
	        }
	
	
	    };
	    module.exports = ConnectionPoint;
	
	
	


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 节点等的模型
	 * 里面存的数据用来处理序列化和反序列化
	 * @class fish.topo.model
	 */
	
	
	    var zrUtil = __webpack_require__(5);
	    var clazzUtil = __webpack_require__(88);
	
	    function Model(option, parentModel,  extraOpt) {
	        this.parentModel = parentModel;
	        this.option = option;
	
	        // Simple optimization
	        if (this.init) {
	            if (arguments.length <= 3) {
	                this.init(option, parentModel,  extraOpt);
	            }
	            else {
	                this.init.apply(this, arguments);
	            }
	        }
	    }
	
	    Model.prototype = {
	
	        constructor: Model,
	
	        /**
	         * Model 的初始化函数
	         * @private
	         * @param {Object} option
	         */
	        init: function (option) {
	            zrUtil.merge(option, this.getDefaultOption());
	        },
	
	        getDefaultOption: function () {
	            if (!this.hasOwnProperty('__defaultOption')) {
	                var optList = [];
	                var Class = this.constructor;
	                while (Class) {
	                    var opt = Class.prototype.defaultOption;
	                    opt && optList.push(opt);
	                    Class = Class.superClass;
	                }
	
	                var defaultOption = {};
	                for (var i = optList.length - 1; i >= 0; i--) {
	                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);
	                }
	                this.__defaultOption = defaultOption;
	            }
	            return this.__defaultOption;
	        },
	
	        /**
	         * @private
	         */
	        mergeOption: function (option) {
	            zrUtil.merge(this.option, option, true);
	        },
	
	        /**
	         * 获取model的某个属性的值
	         * @param {string} path model中的属性
	         * @return {String}
	         *
	         * **使用范例**：
	         *
	         *      @example
	         *          node.model.get("options.text");
	         */
	        get: function (path, ignoreParent) {
	            if (!path) {
	                return this.option;
	            }
	
	            if (typeof path === 'string') {
	                path = path.split('.');
	            }
	
	            var obj = this.option;
	            var parentModel = this.parentModel;
	            for (var i = 0; i < path.length; i++) {
	                // obj could be number/string/... (like 0)
	                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;
	                if (obj == null) {
	                    break;
	                }
	            }
	            if (obj == null && parentModel && !ignoreParent) {
	                obj = parentModel.get(path);
	            }
	            return obj;
	        },
	
	        /**
	         * 设置model的某个属性的值
	         * @param {string} path model中的属性
	         * @param {String} value 所需要设置的值
	         * @return {String}
	         *
	         * **使用范例**：
	         *
	         *      @example
	         *          node.model.set("options.text","例子");
	         */
	        set: function (path, value) {
	            var obj = this.option;
	
	            if (path.indexOf(".") == -1) {
	                obj[path] = value;
	            } else {
	                var fieldArray  = path.split('.');
	                var n = fieldArray.length;
	                var currentRef = obj;
	                var fieldName;
	
	                for (var i = 0; i < n - 1; i++) {
	                    fieldName = fieldArray[i];
	                    if(currentRef[fieldName] == null) {
	                        currentRef[fieldName] = {};
	                    }
	                    currentRef = currentRef[fieldName];
	                }
	                fieldName = fieldArray[n-1];
	                currentRef[fieldName] = value;
	            }
	        },
	
	        /**
	         * @private
	         */
	        getShallow: function (key, ignoreParent) {
	            var option = this.option;
	            var val = option && option[key];
	            var parentModel = this.parentModel;
	            if (val == null && parentModel && !ignoreParent) {
	                val = parentModel.getShallow(key);
	            }
	            return val;
	        },
	
	        /**
	         * @private
	         */
	        getModel: function (path, parentModel) {
	            var obj = this.get(path, true);
	            var thisParentModel = this.parentModel;
	            var model = new Model(
	                obj, parentModel || (thisParentModel && thisParentModel.getModel(path))
	            );
	            return model;
	        },
	
	        /**
	         *清空model的option
	         * @private
	         */
	        isEmpty: function () {
	            return this.option == null;
	        },
	
	        restoreData: function () {},
	
	        /**
	         * @private
	         */
	        clone: function () {
	            var Ctor = this.constructor;
	            return new Ctor(zrUtil.clone(this.option));
	        }
	    };
	
	    // Enable Model.extend.
	    clazzUtil.enableClassExtend(Model);
	
	    module.exports = Model;
	


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var zrUtil = __webpack_require__(5);
	
	    var clazz = {};
	
	    var TYPE_DELIMITER = '.';
	    var IS_CONTAINER = '___FT__COMPONENT__CONTAINER___';
	    /**
	     * @public
	     */
	    var parseClassType = clazz.parseClassType = function (componentType) {
	        var ret = {main: '', sub: ''};
	        if (componentType) {
	            componentType = componentType.split(TYPE_DELIMITER);
	            ret.main = componentType[0] || '';
	            ret.sub = componentType[1] || '';
	        }
	        return ret;
	    };
	    /**
	     * @public  相比 直接用zrUtil.inherits 好处是  可以直接调用父类的构造函数
	     */
	    clazz.enableClassExtend = function (RootClass, preConstruct) {
	        RootClass.extend = function (proto) {
	            var ExtendedClass = function () {
	                preConstruct && preConstruct.apply(this, arguments);
	                RootClass.apply(this, arguments);
	            };
	
	            zrUtil.extend(ExtendedClass.prototype, proto);
	
	            ExtendedClass.extend = this.extend;
	            ExtendedClass.superCall = superCall;
	            ExtendedClass.superApply = superApply;
	            zrUtil.inherits(ExtendedClass, this);
	            ExtendedClass.superClass = this;
	
	            return ExtendedClass;
	        };
	    };
	
	    // superCall should have class info, which can not be fetch from 'this'.
	    // Consider this case:
	    // class A has method f,
	    // class B inherits class A, overrides method f, f call superApply('f'),
	    // class C inherits class B, do not overrides method f,
	    // then when method of class C is called, dead loop occured.
	    function superCall(context, methodName) {
	        var args = zrUtil.slice(arguments, 2);
	        return this.superClass.prototype[methodName].apply(context, args);
	    }
	
	    function superApply(context, methodName, args) {
	        return this.superClass.prototype[methodName].apply(context, args);
	    }
	
	    /**
	     * @param {Object} entity
	     * @param {Object} options
	     * @param {boolean} [options.registerWhenExtend]
	     * @public
	     */
	    clazz.enableClassManagement = function (entity, options) {
	        options = options || {};
	
	        /**
	         * Component model classes
	         * key: componentType,
	         * value:
	         *     componentClass, when componentType is 'xxx'
	         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'
	         * @type {Object}
	         */
	        var storage = {};
	
	        entity.registerClass = function (Clazz, componentType) {
	            if (componentType) {
	                componentType = parseClassType(componentType);
	
	                if (!componentType.sub) {
	                    if (storage[componentType.main]) {
	                        //已经注册过了，直接返回
	                        return;
	                    }
	                    storage[componentType.main] = Clazz;
	                }
	                else if (componentType.sub !== IS_CONTAINER) {
	                    var container = makeContainer(componentType);
	                    container[componentType.sub] = Clazz;
	                }
	            }
	            return Clazz;
	        };
	
	        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {
	            var Clazz = storage[componentTypeMain];
	
	            if (Clazz && Clazz[IS_CONTAINER]) {
	                Clazz = subType ? Clazz[subType] : null;
	            }
	
	            if (throwWhenNotFound && !Clazz) {
	                throw new Error(
	                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'
	                );
	            }
	
	            return Clazz;
	        };
	
	        entity.getClassesByMainType = function (componentType) {
	            componentType = parseClassType(componentType);
	
	            var result = [];
	            var obj = storage[componentType.main];
	
	            if (obj && obj[IS_CONTAINER]) {
	                zrUtil.each(obj, function (o, type) {
	                    type !== IS_CONTAINER && result.push(o);
	                });
	            }
	            else {
	                result.push(obj);
	            }
	
	            return result;
	        };
	
	        entity.hasClass = function (componentType) {
	            // Just consider componentType.main.
	            componentType = parseClassType(componentType);
	            return !!storage[componentType.main];
	        };
	
	        /**
	         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']
	         */
	        entity.getAllClassMainTypes = function () {
	            var types = [];
	            zrUtil.each(storage, function (obj, type) {
	                types.push(type);
	            });
	            return types;
	        };
	
	        /**
	         * If a main type is container and has sub types
	         * @param  {string}  componentType
	         * @return {boolean}
	         */
	        entity.hasSubTypes = function (componentType) {
	            componentType = parseClassType(componentType);
	            var obj = storage[componentType.main];
	            return obj && obj[IS_CONTAINER];
	        };
	
	        entity.parseClassType = parseClassType;
	
	        function makeContainer(componentType) {
	            var container = storage[componentType.main];
	            if (!container || !container[IS_CONTAINER]) {
	                container = storage[componentType.main] = {};
	                container[IS_CONTAINER] = true;
	            }
	            return container;
	        }
	
	        if (options.registerWhenExtend) {
	            var originalExtend = entity.extend;
	            if (originalExtend) {
	                entity.extend = function (proto) {
	                    var ExtendedClass = originalExtend.call(this, proto);
	                    return entity.registerClass(ExtendedClass, proto.type);
	                };
	            }
	        }
	
	        return entity;
	    };
	
	    module.exports = clazz;
	


/***/ }),
/* 89 */
/***/ (function(module, exports) {

	/**
	 * 操作图标类
	 * @author wang.xiaohu
	 */
	
	
	    var IconOperation = {
	        STRAIGHT_SVG: 'M937.353846 724.676923C882.215385 669.538462 795.569231 661.661538 732.553846 701.046154L362.338462 330.830769C401.723077 267.815385 393.846154 181.169231 338.707692 126.030769 267.815385 55.138462 165.415385 55.138462 94.523077 126.030769 23.630769 196.923077 23.630769 299.323077 94.523077 370.215385 149.661538 425.353846 236.307692 433.230769 299.323077 393.846154L669.538462 764.061538C630.153846 827.076923 638.030769 913.723077 693.169231 968.861538 764.061538 1039.753846 866.461538 1039.753846 937.353846 968.861538 1000.369231 897.969231 1000.369231 795.569231 937.353846 724.676923L937.353846 724.676923ZM275.692308 307.2C244.184615 338.707692 189.046154 338.707692 157.538462 307.2 126.030769 275.692308 126.030769 220.553846 157.538462 189.046154 189.046154 157.538462 244.184615 157.538462 275.692308 189.046154 307.2 220.553846 307.2 267.815385 275.692308 307.2L275.692308 307.2ZM874.338462 913.723077C842.830769 945.230769 787.692308 945.230769 756.184615 913.723077 724.676923 882.215385 724.676923 827.076923 756.184615 795.569231 787.692308 764.061538 842.830769 764.061538 874.338462 795.569231 905.846154 827.076923 905.846154 874.338462 874.338462 913.723077L874.338462 913.723077Z',
	        JAGGED_SVG: 'M204.8 819.2l-51.2-102.4 204.8-307.2 51.2 102.4-204.8 307.2zM409.6 512l51.2-102.4 153.6 204.8-51.2 102.4-153.6-204.8zM819.2 204.8l51.2 102.4-204.8 409.6-51.2-102.4 204.8-409.6z                                    M153.6 716.8c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8H102.4v-102.4h102.4v102.4zM409.6 204.8C322.56 204.8 256 271.36 256 358.4s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8H358.4V307.2h102.4v102.4zM614.4 614.4c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8h-102.4v-102.4h102.4v102.4zM870.4 0c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8h-102.4V102.4h102.4v102.4z',
	        CURVE_SVG: 'M1014.285039 824.024234l-145.168428-144.37205c-12.969593-12.855825-37.543559-14.505466-44.597197 2.332252-1.877178 4.550734-2.275367 17.179022-2.275368 17.179022v97.556369H330.935383a118.319095 118.319095 0 0 1-118.546632-117.920905A118.319095 118.319095 0 0 1 330.992267 560.878016h445.516899c121.561493 0 220.426198-98.352747 220.426198-219.23163s-98.864705-219.174746-220.426198-219.174746H340.491925A174.236244 174.236244 0 0 0 174.105698 0 173.78117 173.78117 0 0 0 0.040107 173.09856a173.78117 173.78117 0 0 0 174.065591 173.09856 174.236244 174.236244 0 0 0 166.386227-122.471639h436.017241c65.416807 0 118.603516 52.902288 118.603515 117.920905A118.319095 118.319095 0 0 1 776.509166 459.624176H330.992267c-121.504609 0-220.369314 98.352747-220.369314 219.23163s98.864705 219.174746 220.369314 219.174746h491.194895v92.550561s0 14.221045 2.332252 19.795695c7.053638 16.894602 31.627604 17.577212 44.597197 4.664502l145.111543-144.315165a32.879056 32.879056 0 0 0 0-46.645027zM174.105698 244.94328c-39.818926 0-72.242909-32.25333-72.242909-71.84472s32.423983-71.787835 72.242909-71.787835c39.818926 0 72.186025 32.196446 72.186025 71.787835 0 39.591389-32.423983 71.787835-72.242909 71.787836z',
	        DEL_SVG: 'M980.992 256h-84.992v683.008c0 47.104-37.888 84.992-84.992 84.992H212.992c-47.104 0-84.992-37.888-84.992-84.992V256H43.008C19.456 256 0 236.544 0 212.992c0-23.552 19.456-43.008 43.008-43.008H256V84.992C256 37.888 293.888 0 340.992 0h340.992C730.112 0 768 37.888 768 84.992v84.992h214.016c23.552 0 43.008 19.456 43.008 43.008-1.024 23.552-20.48 43.008-44.032 43.008zM683.008 84.992H340.992v84.992h340.992V84.992zM212.992 939.008h596.992V256H212.992v683.008z m171.008-470.016v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-23.552 19.456-43.008 43.008-43.008 23.552 1.024 43.008 19.456 43.008 43.008zM512 427.008c23.552 0 43.008 19.456 43.008 43.008v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-24.576 19.456-43.008 43.008-43.008z m171.008 0c23.552 0 43.008 19.456 43.008 43.008v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-24.576 19.456-43.008 43.008-43.008z',
	        COMMENT_SVG: 'M209.92 152.064l572.416 1.536c12.8 0 23.04 10.24 23.04 23.04v237.568c0 12.8 10.24 23.04 23.04 23.04s23.04-10.24 23.04-23.04V125.44c0-12.8-10.24-23.04-23.04-23.04H158.72c-12.8 0-23.04 10.24-23.04 23.04v773.12c0 12.8 10.24 23.04 23.04 23.04h236.032c12.8 0 23.04-10.24 23.04-23.04s-10.24-22.528-22.528-23.04l-185.856-1.536c-12.8 0-22.528-10.24-22.528-23.04V174.592c0-12.288 10.24-22.528 23.04-22.528z                                            M268.8 570.368h159.232c13.312 0 24.064 10.752 24.576 24.064v2.56c0 13.312-10.752 24.576-24.576 24.576H268.8c-13.312 0-24.064-10.752-24.576-24.064v-2.56c0.512-13.312 11.264-24.576 24.576-24.576z m0-312.32h441.344c13.312 0 24.576 10.752 24.576 24.576v2.56c0 13.312-10.752 24.576-24.576 24.576H268.8c-13.312 0-24.576-10.752-24.576-24.576v-2.56c0.512-13.312 11.264-24.576 24.576-24.576z m0.512 155.648h269.312c13.312 0 24.576 10.752 24.576 24.064v2.56c0 13.312-10.752 24.576-24.576 24.576H269.312c-13.312 0-24.576-10.752-24.576-24.064v-2.56c0-13.824 10.752-24.576 24.576-24.576z m471.04 13.312l-246.784 339.456c-1.536 2.56-2.56 5.632-2.56 8.704l-1.536 132.096c0 9.728 9.728 16.896 18.944 14.336l122.88-37.888c3.072-1.024 5.632-3.072 7.68-5.632l246.784-338.944c4.608-6.144 3.584-15.36-2.56-19.968l-121.344-94.72c-7.168-5.632-16.896-4.096-21.504 2.56z m23.04 67.584l51.2 39.936c2.048 1.536 2.56 5.12 1.024 7.168l-26.112 35.84c-1.536 2.56-5.12 3.072-7.68 1.024l-51.712-38.912c-2.048-1.536-2.56-4.608-1.024-7.168l26.624-37.376c2.048-1.536 5.632-2.048 7.68-0.512z m-165.888 341.504l-35.328 10.752c-9.216 3.072-18.944-4.096-18.944-13.824l0.512-40.96c0-3.072 1.024-6.144 2.56-8.704l137.216-187.904c1.536-2.56 5.12-2.56 7.168-1.024l51.2 38.4c2.56 2.048 3.072 5.12 1.024 7.68l-137.728 189.952c-2.048 2.56-4.608 4.608-7.68 5.632z',
	        CHANGE_LINE_TYPE_SVG: 'M1008 335.2 1008 335.2l-160 144 0 0c-8.8 8-20 12.8-32 12.8-26.4 0-48-21.6-48-48 0-14.4 6.4-26.4 16-35.2l0 0 67.2-60L560 348.8c0 0 0 0 0 0L464 348.8l0 0L352 348.8 48 348.8c-26.4 0-48-21.6-48-48 0-26.4 21.6-48 48-48l124.8 0 0 0L416 252.8l0 0 208 0 0 0 227.2 0L784 192l0 0c-9.6-8.8-16-21.6-16-35.2 0-26.4 21.6-48 48-48 12 0 23.2 4.8 32 12.8l0 0 160 144 0 0c9.6 8.8 16 21.6 16 35.2C1024 314.4 1017.6 326.4 1008 335.2zM16 680.8 16 680.8l160-144 0 0c8.8-8 20-12.8 32-12.8 26.4 0 48 21.6 48 48 0 14.4-6.4 26.4-16 35.2l0 0-67.2 60L400 667.2l0 0 208 0 0 0 243.2 0 0 0L976 667.2c26.4 0 48 21.6 48 48 0 26.4-21.6 48-48 48L672 763.2 560 763.2c0 0 0 0 0 0L464 763.2l0 0L172.8 763.2 240 824l0 0c9.6 8.8 16 21.6 16 35.2 0 26.4-21.6 48-48 48-12 0-23.2-4.8-32-12.8l0 0L16 752l0 0c-9.6-8.8-16-21.6-16-35.2C0 701.6 6.4 689.6 16 680.8z'
	    }
	    module.exports = IconOperation;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * flow连线管理类
	 * @author miao.cunzhi
	 */
	
	    var zrUtil = __webpack_require__(5);
	    var ConnectionManager = __webpack_require__(91);
	    var Connector = __webpack_require__(82);
	    var Util = __webpack_require__(65);
	    var Point = __webpack_require__(66);
	    var Constants = __webpack_require__(93);
	
	    function FlowConnectionManager(api) {
	        ConnectionManager.call(this);
	        this.bundleOffset = 30; //多线段的偏移
	        this.bundleGap = 20; // 多线段的间隔
	        this.connectorMap = Util.StackedMap.createNew(); //存放多线段
	        this._api = api;
	    }
	
	    FlowConnectionManager.prototype.add = function(connector) {
	        this.connectors.push(connector);
	        //1.处理事件
	        this.handleConnectorEvent(connector);
	        //2.判断是否两节点相联
	        if(connector.startNode && connector.endNode) {
	            var key = this.getTwoNodeId(connector.startNode, connector.endNode, connector.options.position);
	            this.connectorMap.add(key, connector);
	
	            this.handleConnectorShrink(connector);
	
	            this.bundleOffset = connector.options.bundleOffset || this.bundleOffset;
	            this.bundleGap = connector.options.bundleGap || this.bundleGap;
	            //2. 获取这个key对应的线段数组
	            var arrCons = this.connectorMap.get(key);
	            if (arrCons.length == 1) {
	                //两个节点只有一个连线的情况
	                //判断一下 model里有没有dockers，如果有则调用构造point数组  或者调用refreshConnector计算如何画线
	                var dockers = connector.options.dockers;
	                var points = [];
	                if (dockers && dockers.length >= 2) {
	                    points = Point.loadArray(dockers);
	                    connector.refresh(points);
	                } else {
	                    if (connector.options.position.points) {
	                        var arrStartEndPoint = this.getStartEndPoint(connector);
	                        points = connector.options.position.points;
	                        points.unshift(arrStartEndPoint[0]);
	                        points.push(arrStartEndPoint[1]);
	                        connector.refresh(points);
	                    } else {
	                        this.refreshConnector(arrCons[0], true);
	                    }
	                }
	            } else if (arrCons.length > 1) {
	                //两个节点有多个连线的情况
	                this.refreshCons(arrCons);
	            }
	        } else {
	            //处理没有 起始节点与终止节点时的连线
	            this.handleConnectorPoints(connector)
	        }
	
	        //3.设置模型
	        this.handleConnectorModel(connector);
	        return connector;
	    }
	
	    FlowConnectionManager.prototype.handleConnectorEvent = function(connector) {
	        if (connector.conPointsGroup) {
	            connector.conPointsGroup.on("click", function(e) {
	                var arrSplit = e.target.type.split(Connector.SEPERATOR);
	                var connector = e.target.connector;
	                if (arrSplit[0] === Connector.START_NODE) {
	                    connector.options.position.startPos = arrSplit[1];
	                } else if (arrSplit[0] === Connector.END_NODE) {
	                    connector.options.position.endPos = arrSplit[1];
	                }
	                this.refreshConnector(connector, true);
	                e.cancelBubble = true;
	                var params = {};
	                params.event = e;
	                params.type = "conPointsGroup:click";
	                params.lineNode = this.selConnector;
	                this._api.trigger(params.type, params);
	            }.bind(this));
	        }
	
	
	        var MOUSE_EVENT_NAMES = ['click', 'dblclick'];
	        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	            connector.on("Connector:" + eveName, function(e) {
	                var selected = e.target;
	                if (this.selConnector !== selected) {
	                    this.selConnector && this.refreshConnector(this.selConnector);
	                    this.selConnector = selected;
	                }
	                e.cancelBubble = true;
	                var params = {};
	                params.event = e;
	                params.type = eveName;
	                params.target = this.selConnector;
	                this._api.trigger(params.type, params);
	            }.bind(this));
	        }.bind(this));
	    }
	
	    FlowConnectionManager.prototype.handleConnectorModel = function(connector) {
	        connector.model.set(Constants.ELEMENT_TYPE, Constants.CONNECTION);
	        if(connector.startNode && connector.endNode) {
	            connector.model.set(Constants.START_ID, connector.startNode.id);
	            connector.model.set(Constants.END_ID, connector.endNode.id);
	        }
	        connector.model.set(Constants.OPTIONS, zrUtil.clone(connector.options));
	    }
	
	    FlowConnectionManager.prototype.handleConnectorShrink = function(connector) {
	        var that = this;
	        //双击收紧为一条线
	        connector.line.on("dblclick", function() {
	            if (connector.options.isShrink == false) {
	                return;
	            }
	            var con = this.parent;
	            var startNode = con.startNode;
	            var endNode = con.endNode;
	            //1.获取所有的线段
	            var key = that.getTwoNodeId(startNode, endNode, connector.options.position);
	            var cons = that.connectorMap.get(key);
	            if (cons.length == 1) {
	                return
	            }
	            //2.判断线是否处于隐藏状态
	            //2.将除中间的一条线进行隐藏
	            var half = parseInt(cons.length / 2);
	            for (var i = 0; i < cons.length; i++) {
	                if (i != (half)) {
	                    if (cons[i].ignore) {
	                        cons[i].show();
	                    } else {
	                        cons[i].hide();
	                    }
	                }
	            }
	        })
	    }
	
	    //处理没有 起始节点与终止节点时的连线
	    FlowConnectionManager.prototype.handleConnectorPoints = function(connector) {
	        var options = connector.options;
	        var dockers = connector.options.dockers;
	        if (dockers && dockers.length >= 2) {
	            var points = Point.loadArray(dockers);
	            connector.refresh(points);
	        } else {
	            if (options.position && options.position.points) {
	                var oPoints = options.position.points;
	                connector.refresh(oPoints);
	            }
	        }
	    }
	
	    FlowConnectionManager.prototype.getTwoNodeId = function(startNode, endNode, pos) {
	        return startNode.id + '-' + pos.startPos + "," + endNode.id + '-' + pos.endPos;
	    }
	    //处理多条线段
	    FlowConnectionManager.prototype.refreshCons = function(arrCons) {
	        //如果是折线的话
	        if (arrCons[0].options.style.lineType == Connector.TYPE_JAGGED) {
	            for (var i = 0; i < arrCons.length; i++) {
	                this.refreshConnector(arrCons[i], true);
	            }
	        } else {
	            this.refreshConsStraight(arrCons);
	        }
	    }
	
	    //处理多条线段(直线)
	    FlowConnectionManager.prototype.refreshConsStraight = function(arrCons) {
	        var half = parseInt(arrCons.length / 2);
	        var arrConnectResult = []
	
	        var startNode = arrCons[0].startNode;
	        var endNode = arrCons[0].endNode;
	        var sRect = Util.getRect(startNode);
	        var eRect = Util.getRect(endNode).boundingRect;
	        var sConnectorPoint = Util.getConnectorPoints(sRect, startNode);
	        var eConnectorPoint = Util.getConnectorPoints(eRect, endNode);
	        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right
	        var position = arrCons[0].options.position;
	        if (!position.startPos || !position.endPos) {
	            if (sRect.x < eRect.x) {
	                position.startPos = "right";
	                position.endPos = "left";
	            } else {
	                position.startPos = "left";
	                position.endPos = "right";
	            }
	        }
	
	        var startPoint = sConnectorPoint[position.startPos];
	        var endPoint = eConnectorPoint[position.endPos];
	        var angle = Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x);
	        var points = [];
	        for (var i = half; i >= 1; i--) {
	            points = []; //var points = [];
	            points.push(startPoint); //
	            // points.push(new Point(startPoint.x + bundleOffset , startPoint.y + i * bundleGap));
	            // points.push(new Point(endPoint.x - bundleOffset , startPoint.y + i * bundleGap)); //startPoint.x + bundleOffset
	            var secondPoint = startPoint.clone();
	
	            //secondPoint.x =  secondPoint.x + this.bundleOffset;
	            secondPoint.transform(Util.translationMatrix(0, this.bundleGap * i));
	            //secondPoint = this.boundOffsetXY(secondPoint, true);
	            //
	            //直角坐标 x, 和 y, 计算出极坐标
	
	
	            //从极坐标计算出直角坐标
	            secondPoint.x = secondPoint.x + this.bundleOffset * Math.cos(angle);
	            secondPoint.y = secondPoint.y + this.bundleOffset * Math.sin(angle);
	
	
	
	            //secondPoint.transform(Util.scaleMatrix(0.5));
	            points.push(secondPoint);
	
	            var thirdPoint = endPoint.clone();
	            //thirdPoint.x =  thirdPoint.x - this.bundleOffset;
	
	
	
	            thirdPoint.transform(Util.translationMatrix(0, this.bundleGap * i));
	            //thirdPoint = this.boundOffsetXY(thirdPoint, false);
	            //secondPoint.transform(Util.scaleMatrix(0.5));
	            //
	            //直角坐标 x, 和 y, 计算出极坐标
	
	            //从极坐标计算出直角坐标
	            thirdPoint.x = thirdPoint.x - this.bundleOffset * Math.cos(angle);
	            thirdPoint.y = thirdPoint.y - this.bundleOffset * Math.sin(angle);
	
	            points.push(thirdPoint);
	
	            points.push(endPoint);
	            arrConnectResult.push(points);
	        }
	
	        arrConnectResult.push([startPoint, endPoint]);
	
	        var upHalf = Math.ceil(arrCons.length / 2);
	        for (i = 1; i < upHalf; i++) {
	            points = []; //var points = [];
	            points.push(startPoint);
	            var secPoint = startPoint.clone();
	            //secPoint.x =  secPoint.x + this.bundleOffset;
	            secPoint.transform(Util.translationMatrix(0, -this.bundleGap * i));
	            secPoint.x = secPoint.x + this.bundleOffset * Math.cos(angle);
	            secPoint.y = secPoint.y + this.bundleOffset * Math.sin(angle);
	            points.push(secPoint);
	
	            var thdPoint = endPoint.clone();
	            //thdPoint.x =  thdPoint.x - this.bundleOffset;
	            thdPoint.transform(Util.translationMatrix(0, -this.bundleGap * i));
	            //从极坐标计算出直角坐标
	            thdPoint.x = thdPoint.x - this.bundleOffset * Math.cos(angle);
	            thdPoint.y = thdPoint.y - this.bundleOffset * Math.sin(angle);
	            //secondPoint.transform(Util.scaleMatrix(0.5));
	            points.push(thdPoint);
	
	            points.push(endPoint);
	            arrConnectResult.push(points);
	        }
	
	
	        for (i = 0; i < arrConnectResult.length; i++) {
	            arrCons[i].refresh(arrConnectResult[i]);
	        }
	
	    }
	
	    FlowConnectionManager.prototype.boundOffsetXY = function(point, isPositive) {
	        var resultPoint = point.clone();
	        //直角坐标 x, 和 y, 计算出极坐标
	        var angle = Math.atan2(resultPoint.y, resultPoint.x);
	        var r = Math.sqrt(Math.pow(resultPoint.x, 2) + Math.pow(resultPoint.y, 2));
	        if (isPositive) {
	            r = r + this.bundleOffset;
	        } else {
	            r = r - this.bundleOffset;
	        }
	
	
	        //从极坐标计算出直角坐标
	        resultPoint.x = r * Math.cos(angle);
	        resultPoint.y = r * Math.sin(angle);
	        return resultPoint;
	    }
	
	    /**
	     * 设置线段的模型数据  (类型 文字)
	     * @param {[type]} connector [description]
	     * @param {[type]} option    [description]
	     */
	    FlowConnectionManager.prototype.setModel = function(connector, option) {
	        var originLineType = connector.model.get("style.lineType");
	        connector.model.mergeOption(option);
	        zrUtil.merge(connector.model.get("options"), option, true);
	        if (originLineType !== option.style.lineType) {
	            this.refreshConnector(connector, true);
	        }
	    }
	
	    /**
	     * 删除指定的线
	     * @param connector 欲删除的连线
	     * @param _zr zr
	     */
	    ConnectionManager.prototype.deleteByLine = function (connector,_zr) {
	        //1.将线 所联的startNode的outgoing数据删除
	        if(connector.startNode){
	            var startNodeOutgoing = connector.startNode.model.get("outgoing");
	            index = zrUtil.indexOf(startNodeOutgoing, connector.resourceId);
	            if (index != -1) {
	                startNodeOutgoing.splice(index, 1);
	            }
	
	            if (this.connectorMap) {
	                var key = this.getTwoNodeId(connector.startNode, connector.endNode, connector.options.position);
	                this.connectorMap.removeItem(key, connector);
	            }
	        }
	
	
	        //2.从_zr上删除
	        _zr.remove(connector);
	
	
	        //3.从线数据中删除
	        var index = zrUtil.indexOf(this.connectors, connector);
	        if (index != -1) {
	            this.connectors.splice(index, 1);
	        }
	        if (this.selConnector === connector) {
	            this.selConnector = null;
	        }
	    }
	    /**
	     * 刷新连接线
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    FlowConnectionManager.prototype.refreshLineByNode = function(node) {
	        // 判断这个节点是否有多条线段
	        var keys = this.connectorMap.keys();
	        for (var i = 0; i < keys.length; i++) {
	            var key = keys[i];
	            if (key.indexOf(node.id) != -1) {
	                var arrCons = this.connectorMap.get(key);
	                this.countLinePos(arrCons)
	                if (arrCons.length == 1) {
	                    //两个节点只有一个连线的情况
	                    this.refreshConnector(arrCons[0], true);
	                } else if (arrCons.length > 1) {
	                    //两个节点有多个连线的情况
	                    this.refreshCons(arrCons);
	                }
	            }
	        }
	    }
	
	    /**
	     * 刷新连接线
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    FlowConnectionManager.prototype.toggleLineByNode = function(node, isShow) {
	        // 判断这个节点是否有多条线段
	        var keys = this.connectorMap.keys();
	        for (var i = 0; i < keys.length; i++) {
	            var key = keys[i];
	            if (key.indexOf(node.id) != -1) {
	                var arrCons = this.connectorMap.get(key);
	
	                zrUtil.each(arrCons, function(connection) {
	                    if(isShow) {
	                        connection.show();
	                    } else {
	                        connection.hide();
	                    }
	                })
	            }
	        }
	    }
	    /**
	     * 重新调整线的位置
	     */
	    FlowConnectionManager.prototype.countLinePos = function(arrCons) {
	        zrUtil.each(arrCons, function(connector) {
	            var options = connector.options;
	            if (options.autoChangePosition == true) {
	                var sRect = Util.getRect(connector.startNode).boundingRect;
	                var eRect = Util.getRect(connector.endNode).boundingRect;
	                var startPos = options.position.startPos;
	                var endPos = options.position.endPos;
	                var startPosNow = this.posIsChange(startPos, sRect, eRect, "startNode");
	                var endPosNow = this.posIsChange(endPos, sRect, eRect, "endNode");
	                if (startPos != startPosNow || endPos != endPosNow) {
	                    options.position.startPos = startPosNow;
	                    options.position.endPos = endPosNow;
	                }
	            }
	        },this);
	    }
	
	    FlowConnectionManager.prototype.posIsChange = function(pos, sRect, eRect, nodeType) {
	        var newPos
	        if (pos.indexOf("top") != -1 || pos.indexOf("bottom") != -1) {
	            if (sRect.y + sRect.height < eRect.y) {
	                if (nodeType == "startNode") {
	                    newPos = pos.replace(/(top|bottom)/g, "bottom");
	                } else {
	                    newPos = pos.replace(/(top|bottom)/g, "top");
	                }
	            } else if (eRect.y + eRect.height < sRect.y) {
	                if (nodeType == "endNode") {
	                    newPos = pos.replace(/(top|bottom)/g, "bottom");
	                } else {
	                    newPos = pos.replace(/(top|bottom)/g, "top");
	                }
	            } else if (sRect.x + sRect.width < eRect.x) {
	                if (nodeType == "startNode") {
	                    newPos = pos.replace(/(top|bottom)/g, "right");
	                } else {
	                    newPos = pos.replace(/(top|bottom)/g, "left");
	                }
	            } else if (eRect.x + eRect.width < sRect.x) {
	                if (nodeType == "endNode") {
	                    newPos = pos.replace(/(top|bottom)/g, "right");
	                } else {
	                    newPos = pos.replace(/(top|bottom)/g, "left");
	                }
	            }else {
	                newPos = pos;
	            }
	        } else if (pos.indexOf("left") != -1 || pos.indexOf("right") != -1) {
	            if (sRect.x + sRect.width < eRect.x) {
	                if (nodeType == "startNode") {
	                    newPos = pos.replace(/(right|left)/g, "right");
	                } else {
	                    newPos = pos.replace(/(right|left)/g, "left");
	                }
	            } else if (eRect.x + eRect.width < sRect.x) {
	                if (nodeType == "endNode") {
	                    newPos = pos.replace(/(right|left)/g, "right");
	                } else {
	                    newPos = pos.replace(/(right|left)/g, "left");
	                }
	            } else if (sRect.y + sRect.height < eRect.y) {
	                if (nodeType == "startNode") {
	                    newPos = pos.replace(/(right|left)/g, "bottom");
	                } else {
	                    newPos = pos.replace(/(right|left)/g, "top");
	                }
	            } else if (eRect.y + eRect.height < sRect.y) {
	                if (nodeType == "endNode") {
	                    newPos = pos.replace(/(right|left)/g, "bottom");
	                } else {
	                    newPos = pos.replace(/(right|left)/g, "top");
	                }
	            } else {
	                newPos = pos;
	            }
	        } else {
	            newPos = pos;
	        }
	        return newPos;
	    }
	
	
	    zrUtil.inherits(FlowConnectionManager, ConnectionManager);
	    module.exports = FlowConnectionManager;
	


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 连线管理类
	 * @author wang.xiaohu
	 */
	
	    var Util = __webpack_require__(65);
	    var Point = __webpack_require__(66);
	    var Connector = __webpack_require__(82);
	    var Log = __webpack_require__(92);
	    var zrUtil = __webpack_require__(5);
	
	    function ConnectionManager() {
	        this.connectors = []; //当前画布所有的线段
	        this.selConnector = null; //当前选中的线段
	        this.tempConnector = null; //临时线段
	    }
	
	    /**
	     * 设置线的不可编辑
	     * @param  {[type]} forbidEdit [description]
	     * @return {[type]}            [description]
	     */
	    ConnectionManager.prototype.connectorForbidEdit = function (forbidEdit) {
	        for (var i = 0; i < this.connectors.length; i++) {
	            this.connectors[i].options.isEdit = !forbidEdit;
	        }
	    }
	
	
	    /**
	     * 清空连接线上的调整位置按钮
	     * @return {[type]} [description]
	     */
	    ConnectionManager.prototype.clearSelectCon = function () {
	        if (this.selConnector != null) {
	            this.refreshConnector(this.selConnector);
	        }
	    }
	    /**
	     * 删除和节点相关联的连接线
	     * @return {[type]} [description]
	     */
	    ConnectionManager.prototype.deleteSelectCon = function (node, _zr) {
	        for (var i = 0; i < this.connectors.length; i++) {
	            if (this.connectors[i].startNode == node || this.connectors[i].endNode == node) {
	                //1.将线 所联的startNode的outgoing数据删除
	                var startNodeOutgoing = this.connectors[i].startNode.model.get("outgoing");
	                var index = zrUtil.indexOf(startNodeOutgoing, this.connectors[i].resourceId);
	                if (index != -1) {
	                    startNodeOutgoing.splice(index, 1);
	                }
	                //2.从_zr上删除
	                _zr.remove(this.connectors[i]);
	                this.connectors.splice(i, 1);
	                i--;
	                this.selConnector = null;
	            }
	        }
	    }
	    ConnectionManager.prototype.removeLine = function (line, zr) {
	        this.selConnector = line;
	        this.deleteLine(zr);
	    }
	    /**
	     * 删除选定的线
	     * @return {[type]} [description]
	     */
	    ConnectionManager.prototype.deleteLine = function (_zr) {
	        //1.将线 所联的startNode的outgoing数据删除
	        if(this.selConnector.startNode){
	            var startNodeOutgoing = this.selConnector.startNode.model.get("outgoing");
	            index = zrUtil.indexOf(startNodeOutgoing, this.selConnector.resourceId);
	            if (index != -1) {
	                startNodeOutgoing.splice(index, 1);
	            }
	
	            if (this.connectorMap) {
	                var key = this.getTwoNodeId(this.selConnector.startNode, this.selConnector.endNode, this.selConnector.options.position);
	                this.connectorMap.removeItem(key, this.selConnector);
	            }
	        }
	
	
	        //2.从_zr上删除
	        _zr.remove(this.selConnector);
	
	
	        //3.从线数据中删除
	        var index = zrUtil.indexOf(this.connectors, this.selConnector);
	        if (index != -1) {
	            this.connectors.splice(index, 1);
	        }
	        this.selConnector = null;
	    }
	
	    /**
	     * 重新画线
	     * @param  {[type]} connector          [description]
	     * @param  {[type]} force
	     * @return {[type]}                    [description]
	     */
	    ConnectionManager.prototype.refreshConnector = function (connector, force) {
	        // 只有需要强制刷新  或者 连线为空（<2)时 才进行重新计算重绘
	        if (force || (!connector.turningPoints) || (connector.turningPoints.length < 2)) {
	            if (connector.model && connector.model.get("style.lineType")) {
	                connector.options.style.lineType = connector.model.get("style.lineType");
	            }
	            var arrStartEndPoint = this.getStartEndPoint(connector);
	            var escapeDistance = null;
	            if (connector.options.position && connector.options.position.escapeDistance) {
	                escapeDistance = connector.options.position.escapeDistance;
	            }
	            var solutions = this.connector2Points(connector.options.style.lineType, arrStartEndPoint[0],
	                arrStartEndPoint[1],
	                arrStartEndPoint[2], arrStartEndPoint[3], escapeDistance); // TYPE_STRAIGHT TYPE_JAGGED
	
	            connector.refresh(solutions[0][2]);
	        }
	
	        connector.clearHandles(); //清空handle
	    }
	
	
	    ConnectionManager.prototype.getStartEndPoint = function (connector) {
	        var startNode = connector.startNode;
	        var endNode = connector.endNode;
	        var isNotInSameGroup = true;
	        isNotInSameGroup = startNode.parent !== endNode.parent;
	
	        var sRect = startNode.getRect ? startNode.getRect().boundingRect : Util.getRect(startNode, isNotInSameGroup).boundingRect;
	        var sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(
	            sRect.y) + Number(sRect.height)];
	
	        var eRect = endNode.getRect ? endNode.getRect().boundingRect : Util.getRect(endNode, isNotInSameGroup).boundingRect;
	        var eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(
	            eRect.y) + Number(eRect.height)];
	
	
	        var sConnectorPoint = Util.getConnectorPoints(sRect, startNode);
	        var eConnectorPoint = Util.getConnectorPoints(eRect, endNode);
	
	        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right
	        var position = connector.options.position;
	        if (position.direction) {
	            var posArr = position.direction.split(',');
	            position.startPos = posArr[0];
	            position.endPos = posArr[1];
	        }
	        if (!position.startPos || !position.endPos) {
	            if (sRect.x < eRect.x) {
	                position.startPos = "right";
	                position.endPos = "left";
	            } else {
	                position.startPos = "left";
	                position.endPos = "right";
	            }
	        }
	        var startPoint = this.calcPointExpression(position.startPos, sConnectorPoint);
	        var endPoint = this.calcPointExpression(position.endPos, eConnectorPoint);
	        startPoint.add(new Point(position.startOffset[0], position.startOffset[1]));
	        endPoint.add(new Point(position.endOffset[0], position.endOffset[1]));
	        return [startPoint, endPoint, sBounds, eBounds];
	    }
	
	    ConnectionManager.prototype.calcPointExpression = function (pos, point) {
	        var variable = {
	            top: point.top.x,
	            left: point.left.y,
	            right: point.right.y,
	            bottom: point.bottom.x,
	            center: point.center.x
	        };
	
	        var expression = "<% print(" + pos + ") %>";
	        var val = parseInt(Util.template(expression)(variable));
	        if (pos.indexOf("top") != -1) {
	            return new Point(val, point.top.y);
	        } else if (pos.indexOf("left") != -1) {
	            return new Point(point.left.x, val);
	        } else if (pos.indexOf("right") != -1) {
	            return new Point(point.right.x, val);
	        } else if (pos.indexOf("bottom") != -1) {
	            return new Point(val, point.bottom.y);
	        } else if (pos.indexOf("center") != -1) {
	            return new Point(val, point.bottom.y);
	        } else {
	            throw new Error("pos参数错误");
	        }
	    }
	
	    /**
	     * 创建或修改临时线
	     * @param  {[type]} startNode             [description]
	     * @param  {[type]} rEndPoint             [description]
	     * @param  {[type]} lineType              [description]
	     * @param  {[type]} startPos              [description]
	     * @return {[type]}                       [description]
	     */
	    ConnectionManager.prototype.manageTempConnector = function (startNode, rEndPoint, lineType, startPos, endPos, endNode) {
	        var eRect = null;
	        var eBounds = null;
	        var sRect = startNode.getRect ? startNode.getRect().boundingRect : Util.getRect(startNode, true).boundingRect;
	        var sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(
	            sRect.y) + Number(sRect.height)];
	
	        var sConnectorPoint = Util.getConnectorPoints(sRect, startNode);
	
	        if (!this.tempConnector) {
	            this.tempConnector = new Connector({
	                isEdit: false,
	                style: {
	                    lineType: lineType
	                }
	            });
	        }
	
	        var connector = this.tempConnector;
	        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right
	        var position = connector.options.position;
	        position.startPos = startPos ? startPos : (sRect.x < rEndPoint.x ? "right" : "left");
	        position.endPos = endPos ? endPos : (sRect.x < rEndPoint.x ? "left" : "right");
	
	        connector.options.style.lineType = lineType;
	        if (endNode) {
	            eRect = endNode.getRect ? endNode.getRect().boundingRect : Util.getRect(endNode, true).boundingRect;
	            eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(
	                eRect.y) + Number(eRect.height)];
	        }
	        var solutions = this.connector2Points(lineType, sConnectorPoint[position.startPos], rEndPoint,
	            sBounds, eBounds); // TYPE_STRAIGHT TYPE_JAGGED
	
	        connector.refresh(solutions[0][2]);
	        return connector;
	    }
	
	    /**
	     * 创建或修改临时反转线
	     * @param  {[type]} startPoint              [description]
	     * @param  {[type]} endNode                 [description]
	     * @param  {[type]} lineType                [description]
	     * @param  {[type]} endPos                  [description]
	     * @return {[type]}                         [description]
	     */
	    ConnectionManager.prototype.manageReverseTempConnector = function (startPoint, endNode, lineType, endPos, startPos, startNode) {
	        var sRect = null;
	        var sBounds = null;
	        var eRect = endNode.getRect ? endNode.getRect().boundingRect : Util.getRect(endNode, true).boundingRect;
	        var eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(eRect.y) + Number(eRect.height)];
	        var eConnectorPoint = Util.getConnectorPoints(eRect, endNode);
	        if (!this.tempConnector) {
	            this.tempConnector = new Connector({
	                isEdit: false,
	                style: {
	                    lineType: lineType
	                }
	            });
	        }
	        var connector = this.tempConnector;
	        var position = connector.options.position;
	        position.endPos = endPos ? endPos : (eRect.x < startPoint.x ? "right" : "left");
	        position.startPos = startPos ? startPos : (eRect.x < startPoint.x ? "left" : "right");
	
	        connector.options.style.lineType = lineType;
	        if (startNode) {
	            sRect = startNode.getRect ? startNode.getRect().boundingRect : Util.getRect(startNode, true).boundingRect;
	            sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(
	            sRect.y) + Number(sRect.height)];
	        }
	        var solutions = this.connector2Points(lineType, startPoint, eConnectorPoint[position.endPos],
	            sBounds, eBounds); // TYPE_STRAIGHT TYPE_JAGGED
	
	        connector.refresh(solutions[0][2]);
	        return connector;
	    }
	
	    /**
	     * 删除临时线
	     * @param  {[type]} zr             [description]
	     */
	    ConnectionManager.prototype.removeTempConnector = function (zr) {
	        if (this.tempConnector) {
	            zr.remove(this.tempConnector);
	            this.tempConnector = null;
	        }
	    }
	
	
	    /**
	     * 算出 两个节点 指定两个点如何联线
	     * @param  {[type]} type       [description]
	     * @param  {[type]} startPoint [description]
	     * @param  {[type]} endPoint   [description]
	     * @param  {[type]} sBounds    [description]
	     * @param  {[type]} eBounds    [description]
	     * @return {[type]}            [description]
	     */
	    ConnectionManager.prototype.connector2Points = function (type, startPoint, endPoint, sBounds, eBounds,
	        escapeDistance) {
	        var figureEscapeDistance = [30, 30];
	        if (escapeDistance) {
	            if (!zrUtil.isArray(escapeDistance)) {
	                figureEscapeDistance = [escapeDistance, escapeDistance];
	            } else {
	                figureEscapeDistance = escapeDistance;
	            }
	        }
	
	        Log.group("connectionManager: connector2Points");
	
	
	        Log.info("ConnectionManager: connector2Points (" + type + ", " + startPoint + ", " + endPoint +
	            ", " + sBounds + ", " + eBounds + ')');
	        var solutions = [];
	
	
	
	        switch (type) {
	            case Connector.TYPE_CHAIN:
	
	            case Connector.TYPE_STRAIGHT: //直线
	                var points = [startPoint.clone(), endPoint.clone()];
	                solutions.push(['straight', 'straight', points]);
	                break;
	
	            case Connector.TYPE_CURVE: //曲线
	
	            case Connector.TYPE_JAGGED: //折线
	                var startExitPoint = null;
	                var endExitPoint = null;
	
	                //find start exit point  寻找开始出口
	                if (sBounds != null) {
	                    var potentialExits = [];
	
	                    potentialExits.push(new Point(startPoint.x, sBounds[1] - figureEscapeDistance[0])); //north 北
	                    potentialExits.push(new Point(sBounds[2] + figureEscapeDistance[0], startPoint.y)); //east  东
	                    potentialExits.push(new Point(startPoint.x, sBounds[3] + figureEscapeDistance[0])); //south  南
	                    potentialExits.push(new Point(sBounds[0] - figureEscapeDistance[0], startPoint.y)); //west  西
	
	                    //pick closest exit point  寻找与 startPoint 最靠近的出口点
	                    startExitPoint = potentialExits[0];
	                    for (var i = 1; i < potentialExits.length; i++) {
	                        if (Util.distance(startPoint, potentialExits[i]) < Util.distance(startPoint,
	                                startExitPoint)) {
	                            startExitPoint = potentialExits[i];
	                        }
	                    }
	                }
	
	
	                //find end exit point  寻找结束出口
	                if (eBounds != null) {
	                    var potentialExits = [];
	
	                    potentialExits.push(new Point(endPoint.x, eBounds[1] - figureEscapeDistance[1])); //north
	                    potentialExits.push(new Point(eBounds[2] + figureEscapeDistance[1], endPoint.y)); //east
	                    potentialExits.push(new Point(endPoint.x, eBounds[3] + figureEscapeDistance[1])); //south
	                    potentialExits.push(new Point(eBounds[0] - figureEscapeDistance[1], endPoint.y)); //west
	
	                    //pick closest exit point  寻找与 endPoint 最靠近的出口点
	                    endExitPoint = potentialExits[0];
	                    for (var i = 1; i < potentialExits.length; i++) {
	                        if (Util.distance(endPoint, potentialExits[i]) < Util.distance(endPoint,
	                                endExitPoint)) {
	                            endExitPoint = potentialExits[i];
	                        }
	                    }
	                }
	
	                //Basic solution 最基本的解决方案   为其他解决方案做准备
	                var s = [startPoint];
	                var gapIndex = 0; //the index of the gap (where do we need to insert new points) DO NOT CHANGE IT
	                if (startExitPoint) {
	                    s.push(startExitPoint);
	                    gapIndex = 1;
	                }
	                if (endExitPoint) {
	                    s.push(endExitPoint);
	                }
	                s.push(endPoint);
	
	
	
	                //SO - no additional points     S0 解决方案 不添加任何点  基本不会被采用
	                var s0 = Point.cloneArray(s);
	                solutions.push(['s0', 's0', s0]);
	
	
	
	                //S1   S1 解决方案  只有一个折点
	                var s1 = Point.cloneArray(s);
	
	                //first variant   第一个变体 s1 s1_1方案  折线点在 startExitPoint的X 与 endExitPoint的 Y位置
	                var s1_1 = Point.cloneArray(s1);
	                s1_1.splice(gapIndex + 1, 0, new Point(s1_1[gapIndex].x, s1_1[gapIndex + 1].y));
	                solutions.push(['s1', 's1_1', s1_1]);
	
	                //second variant  第二变体 s1 s1-2方案  折线点在 endExitPoint的X 与  startExitPoint的Y位置
	                var s1_2 = Point.cloneArray(s1);
	                s1_2.splice(gapIndex + 1, 0, new Point(s1_2[gapIndex + 1].x, s1_2[gapIndex].y));
	                solutions.push(['s1', 's1_2', s1_2]);
	
	
	                //S2  S2 解决方案  添加两个折点
	
	                //Variant I   s2_1方案
	                var s2_1 = Point.cloneArray(s);
	                var s2_1_1 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex].y);
	                var s2_1_2 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex + 1].y);
	                s2_1.splice(gapIndex + 1, 0, s2_1_1, s2_1_2);
	                solutions.push(['s2', 's2_1', s2_1]);
	
	
	                //Variant II  s2_1方案  1折线点 x: startExitPoint的X 位置 y: startExitPoint的y+endExitPoint的y/2
	                //1折线点 x:endExitPoint的x  y:startExitPoint的y+endExitPoint的y/2
	                var s2_2 = Point.cloneArray(s);
	                var s2_2_1 = new Point(s2_2[gapIndex].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);
	                var s2_2_2 = new Point(s2_2[gapIndex + 1].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);
	                s2_2.splice(gapIndex + 1, 0, s2_2_1, s2_2_2);
	                solutions.push(['s2', 's2_2', s2_2]);
	
	
	                //Variant III
	                var s2_3 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move right so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var eastExits = [s2_3[gapIndex].x + 20, s2_3[gapIndex + 1].x + 20]; //add points X coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    eastExits.push(sBounds[2] + 20);
	                }
	
	                if (eBounds) {
	                    eastExits.push(eBounds[2] + 20);
	                }
	
	                var eastExit = Util.max(eastExits);
	                var s2_3_1 = new Point(eastExit, s2_3[gapIndex].y);
	                var s2_3_2 = new Point(eastExit, s2_3[gapIndex + 1].y);
	                s2_3.splice(gapIndex + 1, 0, s2_3_1, s2_3_2);
	                solutions.push(['s2', 's2_3', s2_3]);
	
	
	                //Variant IV  s2_4方案
	                var s2_4 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move up so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var northExits = [s2_4[gapIndex].y - 20, s2_4[gapIndex + 1].y - 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    northExits.push(sBounds[1] - 20);
	                }
	
	                if (eBounds) {
	                    northExits.push(eBounds[1] - 20);
	                }
	
	                var northExit = Util.min(northExits);
	                var s2_4_1 = new Point(s2_4[gapIndex].x, northExit);
	                var s2_4_2 = new Point(s2_4[gapIndex + 1].x, northExit);
	                s2_4.splice(gapIndex + 1, 0, s2_4_1, s2_4_2);
	                solutions.push(['s2', 's2_4', s2_4]);
	
	
	                //Variant V
	                var s2_5 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move left so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var westExits = [s2_5[gapIndex].x - 20, s2_5[gapIndex + 1].x - 20]; //add points x coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    westExits.push(sBounds[0] - 20);
	                }
	
	                if (eBounds) {
	                    westExits.push(eBounds[0] - 20);
	                }
	
	                var westExit = Util.min(westExits);
	                var s2_5_1 = new Point(westExit, s2_5[gapIndex].y);
	                var s2_5_2 = new Point(westExit, s2_5[gapIndex + 1].y);
	                s2_5.splice(gapIndex + 1, 0, s2_5_1, s2_5_2);
	                solutions.push(['s2', 's2_5', s2_5]);
	
	
	                //Variant VI
	                var s2_6 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move down so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var southExits = [s2_6[gapIndex].y + 20, s2_6[gapIndex + 1].y + 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    southExits.push(sBounds[3] + 20);
	                }
	
	                if (eBounds) {
	                    southExits.push(eBounds[3] + 20);
	                }
	
	                var southExit = Util.max(southExits);
	                var s2_6_1 = new Point(s2_6[gapIndex].x, southExit);
	                var s2_6_2 = new Point(s2_6[gapIndex + 1].x, southExit);
	                s2_6.splice(gapIndex + 1, 0, s2_6_1, s2_6_2);
	                solutions.push(['s2', 's2_6', s2_6]);
	
	
	
	                //FILTER solutions
	
	                /*Algorithm
	                 * 0. solutions are ordered from minimmun nr of points to maximum >:)
	                 * 1. remove all solutions that are not orthogonal (mainly s0 solution)
	                 * 2. remove all solutions that go backward (we will not need them ever)
	                 * 3. remove all solutions with intersections
	                 * 4. pick first class of solutions with same nr of points (ex: 2)
	                 * 5. pick the first solution with 90 degree angles (less turnarounds)
	                 * (not interesteted) sort by length :p
	                 */
	
	                //1. filter non ortogonal solutions 删除不是正交直线的方案
	                Log.info("Filter orthogonal solutions. Initial number of solutions = " + solutions.length);
	                var orthogonalSolution = [];
	                for (var l = 0; l < solutions.length; l++) {
	                    var solution = solutions[l][2];
	                    if (Util.orthogonalPath(solution)) {
	                        orthogonalSolution.push(solutions[l]);
	                    }
	                }
	                solutions = orthogonalSolution;
	                Log.info("\n\tOrthogonalSolutions = " + solutions.length);
	
	                //2. filter backward solutions  过滤 倒退的方案
	                //do not allow start and end points to coincide - ignore them
	                if (startPoint.equals(endPoint)) {
	                    Log.info(
	                        "Start and end point coincide...skip backward solution. I think we will just fall on s0 :)"
	                    );
	                } else {
	                    Log.info("Filter backward solutions. Initial number of solutions = " + solutions.length);
	                    var forwardSolutions = [];
	                    var temp = '';
	                    for (var l = 0; l < solutions.length; l++) {
	                        var solution = solutions[l][2];
	                        if (Util.forwardPath(solution)) {
	                            forwardSolutions.push(solutions[l]);
	                        } else {
	                            temp = temp + "\n\t" + solution;
	                        }
	                    }
	                    solutions = forwardSolutions;
	                    Log.info("\n\t ForwardSolutions = " + solutions.length);
	                    if (solutions.length == 0) {
	                        Log.info("Discarded solutions: " + temp);
	                    }
	                }
	
	
	                //3. Filter non intersecting solutions  去除没有交集()的方案
	                Log.info("Filter non intersecting solutions. Initial number of solutions = " + solutions.length);
	                var nonIntersectionSolutions = []
	                for (var l = 0; l < solutions.length; l++) {
	                    var solution = solutions[l][2];
	                    //Log.info("Solution id= " + solutions[l][1] + ' nr points = ' + solution.length + ", points = " + solution);
	                    var intersect = false;
	
	                    var innerLines = solution.slice(); //just a shallow copy
	
	                    /*If any bounds just trim the solution. So we avoid the strange case when a connection
	                     *startes from a point on a figure and ends inside of the same figure, but not on a connection point*/
	                    if (eBounds || sBounds) {
	                        //i0nnerLines = innerLines.slice(0, innerLines.length - 1);
	                        innerLines = innerLines.slice(1, innerLines.length - 1);
	                        //Log.info("\t eBounds present,innerLines nr. points = " + innerLines.length + ", points = " + innerLines);
	                    }
	
	
	
	                    //now test for intersection
	                    if (sBounds) {
	                        intersect = intersect || Util.polylineIntersectsRectangle(innerLines, sBounds);
	                    }
	                    if (eBounds) {
	                        intersect = intersect || Util.polylineIntersectsRectangle(innerLines, eBounds);
	                    }
	
	                    if (!intersect) {
	                        nonIntersectionSolutions.push(solutions[l]);
	                    }
	                }
	
	                //If all solutions intersect than this is destiny  :) and just ignore the intersection filter
	                if (nonIntersectionSolutions.length != 0) {
	                    //reasign to solutions
	                    solutions = nonIntersectionSolutions;
	                }
	
	                Log.info("\n\t nonIntersectionSolutions = " + solutions.length);
	
	
	                //4. get first class of solutions with same nr of points 选择与第一个方案点数一样多的方案（因为第一个方案点数最少）
	                Log.info("Get first class of solutions with same nr of points");
	                if (solutions.length == 0) {
	                    Log.info("This is not possible");
	                }
	
	                var firstSolution = solutions[0][2]; //pick first solution
	                var nrOfPoints = firstSolution.length;
	                var sameNrPointsSolution = [];
	
	                for (var l = 0; l < solutions.length; l++) {
	                    var solution = solutions[l][2];
	                    if (solution.length == nrOfPoints) {
	                        sameNrPointsSolution.push(solutions[l]);
	                    }
	                }
	
	                solutions = sameNrPointsSolution;
	
	
	
	
	                /*5.  计算路径分数 ，取最分数高的
	                 Pick the first solution with 90 degree angles (less turnarounds)
	                 *in case we have more than one solution in our class
	                 */
	                Log.info("pick the first solution with 90 degree angles (less turnarounds)");
	                var solIndex = 0;
	                for (var l = 0; l < solutions.length; l++) {
	                    var solution = solutions[l][2];
	                    if (Util.scorePath(solutions[solIndex][2]) < Util.scorePath(solutions[l][2])) {
	                        solIndex = l;
	                    }
	                }
	                solutions = [solutions[solIndex]];
	
	
	                break;
	        }
	
	        //SMOOTHING curve
	        if (type === Connector.TYPE_CURVE) {
	            this.smoothCurve(solutions);
	        }
	        //END SMOOTHING curve
	
	        Log.groupEnd();
	
	        return solutions;
	    }
	
	    ConnectionManager.prototype.smoothCurve = function (solutions) {
	        var option = 3;
	
	        switch (option) {
	            case 0:
	                //do nothing
	                break;
	
	            case 1: //add intermediate points
	                //Add the middle point for start and end segment so that we "force" the
	                //curve to both come "perpendicular" on bounds and also make the curve
	                //"flee" more from bounds (on exit)
	                for (var s = 0; s < solutions.length; s++) {
	                    var solTurningPoints = solutions[s][2];
	
	                    //first segment
	                    var a1 = solTurningPoints[0];
	                    var a2 = solTurningPoints[1];
	                    var startMiddlePoint = Util.getMiddle(a1, a2);
	                    solTurningPoints.splice(1, 0, startMiddlePoint);
	
	                    //last segment
	                    var a3 = solTurningPoints[solTurningPoints.length - 2];
	                    var a4 = solTurningPoints[solTurningPoints.length - 1];
	                    var endMiddlePoint = Util.getMiddle(a3, a4);
	                    solTurningPoints.splice(solTurningPoints.length - 1, 0, endMiddlePoint);
	                }
	                break;
	
	            case 2: //remove points
	
	                zrUtil.each(solutions, function(solution) {
	                    var solType = solution[0];
	                    if (solType == 's1' || solType == 's2') {
	                        var solTurningPoints = solution[2];
	                        solTurningPoints.splice(1, 1);
	                        solTurningPoints.splice(solTurningPoints.length - 2, 1);
	                    }
	                });
	                break;
	
	            case 3:
	                /*remove colinear point for s1 as it seems that more colinear points do not look good
	                 * on organic solutions >:D*/
	                zrUtil.each(solutions, function(solution) {
	                    var solType = solution[0];
	                    if (solType == 's1') {
	                        var solTurningPoints = solution[2];
	                        var reducedSolution = Util.collinearReduction(solTurningPoints);
	                        solution[2] = reducedSolution;
	                    }
	                });
	                break;
	        } //end switch
	
	    }
	
	    module.exports = ConnectionManager;


/***/ }),
/* 92 */
/***/ (function(module, exports) {

	/**
	 * 日志类
	 * @author wang.xiaohu
	 */
	
	
	    var Log  = {
	        LOG_LEVEL_NONE  : 0,
	
	        LOG_LEVEL_DEBUG : 1,
	
	        LOG_LEVEL_INFO : 2,
	
	        LOG_LEVEL_ERROR : 3,
	
	        level : this.LOG_LEVEL_ERROR,
	        
	        /**
	        * The less important of all messages
	        * @param {String} message - the message to be logged
	        **/
	        debug: function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_DEBUG){
	                    
	                    //in FF is debug
	                    if(typeof console.debug == 'function'){
	                        console.debug(message);
	                    }
	                    else{//TODO: in IE is log
	    //                    console.info(message);
	                    }
	                }
	            }
	        },
	
	
	        /**
	        * The commonly used log message
	        * @param {String} message - the message to be logged
	        **/
	        info : function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_INFO){
	                    console.info(message);
	                }
	            }
	        },
	
	        /**
	        * The worse kind of message. Usually a crash
	        * @param {String} message - the message to be logged
	        **/
	        error : function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_ERROR){
	                    console.error(message);
	                }
	            }
	        },
	
	        /**
	         *Start grouping the log messages
	         *@param {String} title - the title of the group
	         *@see <a href="http://getfirebug.com/logging">http://getfirebug.com/logging</a>
	         **/
	        group : function(title){
	            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info
	                if(typeof console !== 'undefined'){           
	                    /**If we do not test for group() function you will get an error in Opera
	                     *as Opera has it's own console...which does not have a group() function*/
	                    if(typeof console.group === 'function'){
	                        console.group(title);
	                    }
	                }
	            }
	        },
	
	        /**Ends current message grouping*/
	        groupEnd : function(){
	            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info
	                if(typeof console !== 'undefined'){
	                    /**If we do not test for groupEnd() function you will get an error in Opera
	                     *as Opera has it's own console...which does not have a group() function*/
	                    if(typeof console.groupEnd === 'function'){
	                        console.groupEnd();
	                    }
	                }
	            }
	        }
	
	    };
	
	    //Log.level = Log.LOG_LEVEL_DEBUG; 
	    Log.level = Log.LOG_LEVEL_ERROR; 
	    //Log.level = Log.LOG_LEVEL_ERROR;
	    //Log.level = Log.LOG_LEVEL_NONE;
	    module.exports = Log;
	    


/***/ }),
/* 93 */
/***/ (function(module, exports) {

	/**
	 * 常量定义
	 */
	
		module.exports = 	{
			ELEMENT_TYPE: "elementType",
			MODE: "mode",
			BACKGROUND: "backgroud",
			OPTIONS: "options",
			USERDATA: "userData",
			ID: "id",
			START_ID: "startNodeId",
			END_ID: "endNodeId",
			ALARM: "Alarm",
			RELATIONID:"relationId",
			RELATION_IMAGE:"relationImage",
			GROUP: "Group",
			GROUP_NODE:"GroupNode",
			CONNECTION: "connection",
			CHILDS: "childs",
			TREE_ROOT: "treeRoot",
			DOCKERS:"options.dockers",
			STYLE_LINETYPE:"style.lineType",
			LINEOPERATIONICON:"LineOperationIcon",
			DEL:"DEL",
			LINK:"straight",
			FOLD:"jagged",
			CURVE:"curve"
		};
	


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Flow工具类
	 * @author wang.xiaohu9
	 */
	
	    var Constants = __webpack_require__(93);
	    var zrUtil = __webpack_require__(5);
	    var GroupNode = __webpack_require__(95);
	    var Rect = __webpack_require__(97);
	    var Circle = __webpack_require__(98);
	    var Image = __webpack_require__(99);
	    var Text = __webpack_require__(100);
	    var Sector = __webpack_require__(101);
	    var Ring = __webpack_require__(102);
	    var Ellipse = __webpack_require__(103);
	    var Heart = __webpack_require__(104);
	    var Droplet = __webpack_require__(105);
	    var Rose = __webpack_require__(106);
	    var Isogon = __webpack_require__(107);
	    var Polygon = __webpack_require__(108);
	    var Line = __webpack_require__(109);
	    var Polyline = __webpack_require__(110);
	    var BezierCurve = __webpack_require__(111);
	    var Arc = __webpack_require__(112);
	    var Star = __webpack_require__(113);
	    var Trochoid = __webpack_require__(114);
	    var Path = __webpack_require__(115);
	    var IconButton = __webpack_require__(116);
	    var Connector = __webpack_require__(82);
	    var flowLink = __webpack_require__(117);
	    /**
	     * 根据结点数组 导出JSON格式的数据
	     *
	     * @param {Array} model 总的模型
	     * @return {JSON} JSON格式的数据
	     */
	    function toJson(model, group) {
	        var jsonArr = [];
	        group.eachChild(function (node) {
	            if (node.model) {
	                //如果是组的话
	                if (node instanceof GroupNode) {
	                    var childArr = [];
	                    node.eachChild(function (childNode) {
	                        if (childNode.model) {
	                            if (childNode instanceof Connector) {
	                                childNode.refreshModel();
	                            } else {
	                                childNode.model.set("options.position", childNode.position);
	                            }
	                            childArr.push(childNode.model.option);
	                        }
	                    });
	                    node.model.set(Constants.CHILDS, childArr);
	                }
	                if (node instanceof Connector) {
	                    node.refreshModel();
	                }
	                jsonArr.push(node.model.option);
	
	            }
	
	        })
	        model.set(Constants.CHILDS, jsonArr);
	        return model.option;
	    }
	
	    /**
	     * 根据 JSON 生成节点
	     * @param  {[type]} fishTopoflow [description]
	     * @param  {[type]} json         [description]
	     * @param {Boolean} isNoCount 是否需要step计数，默认是需要计数
	     * @return {[type]}              [description]
	     */
	    function fromJson(fishTopoflow, group, childShapes, isChild, layoutRootNode, isNoCount) {
	        var connectors = [];
	        // 1.先创建节点  遍历形状 获取模型
	        for (var i = 0; i < childShapes.length; i++) {
	            var shape = childShapes[i];
	            if (shape.elementType === Constants.CONNECTION) {
	                connectors.push(shape);
	            } else if (shape.elementType === Constants.ALARM) {
	                var relationNode = findNodeById(fishTopoflow.allNodes, shape.relationId);
	                fishTopoflow.createAlarm(relationNode, shape.options);
	            } else if ((shape.elementType === Constants.GROUP_NODE) || (shape.elementType === Constants.GROUP)) {
	                // 解决反序列组，组连线无法匹配组问题
	                // shape.options.id = shape.id;
	                var createdGroup = fishTopoflow.createNode(Constants.GROUP, shape.options, shape.userData);
	                if (shape.childs) {
	                    fromJson(fishTopoflow, createdGroup, shape.childs, true, layoutRootNode, isNoCount);
	                }
	
	                // 判断组节点是否有父节点
	                if (isChild) {
	                    group.add(createdGroup);
	                } else {
	                    fishTopoflow.addNode(createdGroup, {}, isNoCount);
	                }
	
	
	            } else {
	                // 根据options创建节点
	                var node = fishTopoflow.createNode(shape.elementType, shape.options, shape.userData);
	                if (isChild) {
	                    group.add(node);
	                } else {
	                    fishTopoflow.addNode(node, {}, isNoCount);
	                }
	
	                if (shape.options.layout) {
	                    if (shape.options.layout.layout === Constants.TREE_ROOT) {
	                        var nodeForLayout = findNodeById(fishTopoflow.allNodes, shape.id)
	                        layoutRootNode.push(nodeForLayout);
	                        //  fishTopo.layoutNode("tree",{"node":node});
	                    }
	                }
	
	            }
	        }
	
	        // 2. 再创建线
	        zrUtil.each(connectors, function (line) {
	            var startNode = findNodeById(fishTopoflow.allNodes, line.startNodeId);
	            var endNode = findNodeById(fishTopoflow.allNodes, line.endNodeId);
	            if (startNode && endNode) {
	                var link = fishTopoflow.createLink(startNode, endNode, line.options, line.userData);
	                if (isChild) {
	                    group.add(link);
	                } else {
	                    fishTopoflow.addNode(link, {}, isNoCount);
	                }
	            }else{
	                var thisLink = flowLink.Link.createByPoint(line.options,line.userData);
	                if (isChild) {
	                    group.add(thisLink);
	                } else {
	                    fishTopoflow.addNode(thisLink, {}, isNoCount);
	                }
	            }
	        })
	    }
	
	    /**
	     * 根据id在group中查找,  因组内子节点之间的连线,在group中查找不到,所以要在allNodes里面取
	     * @param  {[type]} group  [description]
	     * @param  {[type]} nodeId [description]
	     * @return {[type]}        [description]
	     */
	    function findNodeById(allNodes, nodeId) {
	        var retNode = null;
	        allNodes.forEach(function (node) {
	            if (node.id === nodeId) {
	                retNode = node;
	            }
	        });
	        return retNode;
	    }
	
	    /**
	     * Get canvas which has all thing rendered
	     * @param {Object} opts
	     * @param {string} [opts.backgroundColor]
	     */
	    function getRenderedCanvas(zr, opts) {
	        opts = opts || {};
	        opts.pixelRatio = opts.pixelRatio || 1;
	        opts.backgroundColor = opts.backgroundColor ||
	            "#FFFFFF";
	        var list = zr.storage.getDisplayList();
	        // Stop animations
	        zrUtil.each(list, function (el) {
	            var animators = el.animators;
	            var len = animators.length;
	            for (var i = 0; i < len; i++) {
	                animators[i].stop(false);
	            }
	        });
	        return zr.painter.getRenderedCanvas(opts);
	    }
	
	    function toDataURL(zr, opts) {
	        opts = opts || {};
	        var url = getRenderedCanvas(zr, opts).toDataURL(
	            'image/' + (opts && opts.type || 'png')
	        );
	        var list = zr.storage.getDisplayList();
	        // Start animations
	        zrUtil.each(list, function (el) {
	            var animators = el.animators;
	            var len = animators.length;
	            for (var i = 0; i < len; i++) {
	                animators[i].start();
	            }
	        });
	        return url;
	    }
	
	    function truncPosition(position) {
	        var x = parseInt(position[0], 10);
	        var y = parseInt(position[1], 10);
	        if (x < 0) {
	            x = 0
	        }
	        if (y < 0) {
	            y = 0
	        }
	        return [x, y];
	    }
	
	    function registerFlowNode(flowNode) {
	        var nodeCtors = {
	            Rect: Rect,
	            Circle: Circle,
	            Image: Image,
	            Text: Text,
	            Sector: Sector,
	            Ring: Ring,
	            Ellipse: Ellipse,
	            Heart: Heart,
	            Droplet: Droplet,
	            Rose: Rose,
	            Isogon: Isogon,
	            Polygon: Polygon,
	            Line: Line,
	            Polyline: Polyline,
	            BezierCurve: BezierCurve,
	            Arc: Arc,
	            Star: Star,
	            Trochoid: Trochoid,
	            Path: Path,
	            Group: GroupNode,
	            IconButton: IconButton
	        }
	        for (var name in nodeCtors) {
	            flowNode[name] = nodeCtors[name]
	        }
	        return flowNode;
	    }
	
	    /**
	     * Normalize css liked array configuration
	     * e.g.
	     *  3 => [3, 3, 3, 3]
	     *  [4, 2] => [4, 2, 4, 2]
	     *  [4, 3, 2] => [4, 3, 2, 3]
	     * @param {number|Array.<number>} val
	     */
	    function normalizeCssArray(val) {
	        var len = val.length;
	        if (typeof (val) === 'number') {
	            return [val, val, val, val];
	        } else if (len === 2) {
	            // vertical | horizontal
	            return [val[0], val[1], val[0], val[1]];
	        } else if (len === 3) {
	            // top | horizontal | bottom
	            return [val[0], val[1], val[2], val[1]];
	        }
	        return val;
	    }
	
	    function _trim(str) {
	        return str.replace(/^\s+/, '').replace(/\s+$/, '');
	    }
	
	    function parsePercent(percent, all) {
	        switch (percent) {
	            case 'center':
	            case 'middle':
	                percent = '50%';
	                break;
	            case 'left':
	            case 'top':
	                percent = '0%';
	                break;
	            case 'right':
	            case 'bottom':
	                percent = '100%';
	                break;
	        }
	        if (typeof percent === 'string') {
	            if (_trim(percent).match(/%$/)) {
	                return parseFloat(percent) / 100 * all;
	            }
	
	            return parseFloat(percent);
	        }
	
	        return percent == null ? NaN : +percent;
	    }
	
	
	
	    /**
	     * @param {string} str
	     * @param {boolean} [upperCaseFirst=false]
	     * @return {string} str
	     */
	    function toCamelCase(str, upperCaseFirst) {
	        str = (str || '').toLowerCase().replace(/-(.)/g, function (match, group1) {
	            return group1.toUpperCase();
	        });
	
	        if (upperCaseFirst && str) {
	            str = str.charAt(0).toUpperCase() + str.slice(1);
	        }
	
	        return str;
	    }
	    /**
	     * Enable property storage to any host object.
	     * Notice: Serialization is not supported.
	     *
	     * For example:
	     * var get = modelUitl.makeGetter();
	     *
	     * function some(hostObj) {
	     *      get(hostObj)._someProperty = 1212;
	     *      ...
	     * }
	     *
	     * @return {Function}
	     */
	    var makeGetter = (function () {
	        var index = 0;
	        return function () {
	            var key = '\0__topo_prop_getter_' + index++;
	            return function (hostObj) {
	                return hostObj[key] || (hostObj[key] = {});
	            };
	        };
	    })();
	    var encodeHTML = function (source) {
	        return String(source)
	            .replace(/&/g, '&amp;')
	            .replace(/</g, '&lt;')
	            .replace(/>/g, '&gt;')
	            .replace(/"/g, '&quot;')
	            .replace(/'/g, '&#39;');
	    };
	
	    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];
	
	    var wrapVar = function (varName, seriesIdx) {
	        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';
	    };
	    /**
	     * Template formatter
	     * @param {string} tpl
	     * @param {Array.<Object>|Object} paramsList
	     * @param {boolean} [encode=false]
	     * @return {string}
	     */
	    function formatTpl(tpl, paramsList, encode) {
	        if (!zrUtil.isArray(paramsList)) {
	            paramsList = [paramsList];
	        }
	        var seriesLen = paramsList.length;
	        if (!seriesLen) {
	            return '';
	        }
	
	        var $vars = paramsList[0].$vars || [];
	        for (var i = 0; i < $vars.length; i++) {
	            var alias = TPL_VAR_ALIAS[i];
	            var val = wrapVar(alias, 0);
	            tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);
	        }
	        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
	            for (var k = 0; k < $vars.length; k++) {
	                var ret = paramsList[seriesIdx][$vars[k]];
	                tpl = tpl.replace(
	                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),
	                    encode ? encodeHTML(ret) : ret
	                );
	            }
	        }
	
	        return tpl;
	    }
	
	
	    module.exports = {
	        toJson: toJson,
	        fromJson: fromJson,
	        toDataURL: toDataURL,
	        truncPosition: truncPosition,
	        registerFlowNode: registerFlowNode,
	        normalizeCssArray: normalizeCssArray,
	        parsePercent: parsePercent,
	        toCamelCase: toCamelCase,
	        makeGetter: makeGetter,
	        formatTpl: formatTpl,
	        findNodeById: findNodeById
	    };


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 组， 组中元素的坐标都是相对于这个组的<br>
	 * @class fishTopoFlow.node.GroupNode
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var group1 = new node.Group({
	 *           position:[60,50]
	 *       });
	 *
	 *       var rect1 = new node.Rect({
	 *           shape:{width:120,height:30},
	 *           style:{text:"标题", fill:"#FFB90F",stroke:"#bbbbbb"},
	 *           position:[0,0],
	 *           selectable:false
	 *       });
	 *
	 *       var rect2 = new node.Rect({
	 *           shape:{width:120,height:60},
	 *           style:{text:"内容", fill:"#FFFFFF",stroke:"#bbbbbb"},
	 *           position:[0,30],
	 *           selectable:false
	 *       });
	 *
	 *       group1.add(rect1);
	 *       group1.add(rect2);
	 *       fishTopo.add(group1);
	 */
	
	
	
	    var zrUtil = __webpack_require__(5);
	    var BoundingRect = __webpack_require__(27);
	    var graphic = __webpack_require__(4);
	    var util = __webpack_require__(65);
	    var Connector = __webpack_require__(82);
	    var flowNode =__webpack_require__(96);
	
	    function GroupNode(opts) {
	        this.model = flowNode.genModel("GroupNode", opts);
	        graphic.Group.call(this, opts);
	
	        var defaultOptions = {
	            shape: {
	                width: 5,
	                height: 5,
	                r: 5
	            },
	            style: {
	                fill: 'rgba(0,0,0,0)',//'#f9f9f9',
	                stroke: 'rgba(0,0,0,0)'//'#bbbbbb'
	            },
	            position: [0, 0]
	        };
	        this.options = zrUtil.merge(defaultOptions, opts, true);
	        //函数无法clone 原型clone不上
	        this.options.layout = opts.layout;
	        this.max = [1024, 960];
	        this.render(this.options);
	    }
	    GroupNode.RECT_NAME = "GROUP_RECT_NAME";
	    GroupNode.prototype = {
	        constructor: GroupNode,
	        type: "GroupNode",
	        render: function (model) {
	            var rect = new graphic.Rect({
	                shape: model.shape,
	                style: model.style,
	                //silent:true, //加上后 拖动 组中没有子元素的地方 无法手动了
	                z: 1
	            });
	            rect.name = GroupNode.RECT_NAME;
	            this.add(rect);
	            this.position = model.position;
	            this.mergedImage = model.mergedImage;
	        },
	        rectContain: function (x, y) {
	            var rect = util.getRect(this);
	            return rect.boundingRect.contain(x, y);
	        },
	
	        add: function(child) {
	            if (child && child !== this && child.parent !== this) {
	                this._children.push(child);
	                this._doAdd(child);
	            }
	            this._api && this._api._addGroupNode(this,child);
	            return this;
	
	        },
	
	        /**
	         * 遍历组中每一个子节点
	         * @param  {Function} cb 回调函数cb
	         * @param  {Object} context   上下文context
	         */
	        each: function (cb, context) {
	            var children = this._children;
	            for (var i = 0; i < children.length; i++) {
	                var child = children[i];
	                if (child.name != GroupNode.RECT_NAME) {
	                    cb.call(context, child, i);
	                }
	            }
	            return this;
	        },
	        // 设置 group中框形大小为 group的包围和
	        willRender:function (api) {
	            if (this.options.layout) {
	                this.setLayout(this.options.layout);
	            }
	            this.setProperties({
	                shape: {
	                    width: this.getBoundingRect().width,
	                    height: this.getBoundingRect().height
	                }
	            });
	            this._api = api;
	        },
	
	        setLayout: function(Layout) {
	            Layout.run(this);
	        },
	
	        getRect: function () {
	            var boundingRect = this.getBoundingRect();
	            var clipPath = this.clipPath;
	            // 节点裁剪后，以裁剪节点包围盒为准
	            if (clipPath) {
	                boundingRect = clipPath.getBoundingRect();
	            }
	            //创建最小包围盒虚线
	            var points = [];
	            points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];
	            points[1] = [boundingRect.width / 2, -boundingRect.height / 2];
	            points[2] = [boundingRect.width / 2, boundingRect.height / 2];
	            points[3] = [-boundingRect.width / 2, boundingRect.height / 2];
	            points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];
	
	            var boundRect = new BoundingRect(this.position[0],
	                this.position[1],
	                boundingRect.width, boundingRect.height);
	            return {
	                x: this.position[0] + boundingRect.width / 2,
	                y: this.position[1] + boundingRect.height / 2,
	                width: boundingRect.width,
	                height: boundingRect.height,
	                points: points,
	                boundingRect: boundRect
	            };
	        },
	        /**
	         * 拖拽组内节点的时候，动态更改背景rect的大小
	         * @param nodeMessage 拖拽的组内节点的信息
	         */
	        modifyGroupRect: function (nodeMessage) {
	            //1.重置背景rect 的长宽
	            var minLength = this.options.shape.r;
	            this.setProperties({
	                shape: {
	                    width: minLength,
	                    height: minLength,
	                    r: minLength
	                }
	            });
	
	            var rect = this.childOfName(GroupNode.RECT_NAME);
	            var boundingRect = this.getBoundingRect();
	            var width = boundingRect.width;
	            var height = boundingRect.height;
	            var rx = rect.position[0],//rect.shape.x,
	                ry = rect.position[1];//rect.shape.y;
	            //2.取group中所有节点最靠上边和最高左边的值，不包括背景rect的值
	            var minX = this._children[1].position[0],
	                minY = this._children[1].position[1];
	            var maxX = this._children[1].position[0],
	                maxY = this._children[1].position[1];
	            var nowNodePosition = zrUtil.clone(nodeMessage.position);
	            for (var i = 1; i < this._children.length; i++) {
	                if (this._children[i] instanceof Connector || this._children[i].isIcon == true) {
	                    continue;
	                } else {
	                    if (minX > this._children[i].position[0]) {
	                        minX = this._children[i].position[0];
	                    }
	                    if (maxX < this._children[i].position[0]) {
	                        maxX = this._children[i].position[0];
	                    }
	                    if (minY > this._children[i].position[1]) {
	                        minY = this._children[i].position[1];
	                    }
	                    if (maxY < this._children[i].position[1]) {
	                        maxY = this._children[i].position[1];
	                    }
	                }
	            }
	
	            // 3. 宽度大于最大宽度
	            if (width > this.max[0]) {
	                width = this.max[0] - 2;
	                if (nodeMessage.position[0] > minX) {
	                    nowNodePosition[0] = minX + this.max[0] - nodeMessage.width;
	                } else {
	                    nowNodePosition[0] = maxX - this.max[0] + nodeMessage.width;
	                }
	            } else {
	                //移动节点改变group中背景rect的x位置，不超过最小的值
	                rx = rect.position[0] + nodeMessage.position[0];
	                if (rx > minX) {
	                    rx = minX;
	                }
	                if (nodeMessage.isMove) { //drag
	                    nowNodePosition[0] = nodeMessage.movePosition[0] + nodeMessage.moveX;
	                } else {
	                    nowNodePosition[0] = nodeMessage.position;
	                }
	                if (nodeMessage.position[0] > minX) {
	                    if (nowNodePosition[0] > minX + this.max[0] - nodeMessage.width) {
	                        nowNodePosition[0] = minX + this.max[0] - nodeMessage.width;
	                    }
	                } else {
	                    if (nowNodePosition[0] < maxX - this.max[0] + nodeMessage.width) {
	                        nowNodePosition[0] = maxX - this.max[0] + nodeMessage.width
	                    }
	                }
	            }
	            if (height > this.max[1]) {
	                height = this.max[1] - 2;
	                if (nodeMessage.position[1] > minY) {
	                    nowNodePosition[1] = minY + this.max[1] - nodeMessage.height;
	                } else {
	                    nowNodePosition[1] = maxY - this.max[1] + nodeMessage.height;
	                }
	            } else {
	                //移动节点改变group中背景rect的y位置，不超过最小的值
	                ry = rect.position[1] + (nodeMessage.position[1]);
	                if (ry > minY) {
	                    ry = minY;
	                }
	                if (nodeMessage.isMove) {
	                    nowNodePosition[1] = nodeMessage.movePosition[1] + nodeMessage.moveY;
	                } else {
	                    nowNodePosition[1] = nodeMessage.position[1];
	                }
	                if (nodeMessage.position[1] > minY) {
	                    if (nowNodePosition[1] > minY + this.max[1] - nodeMessage.height) {
	                        nowNodePosition[1] = minY + this.max[1] - nodeMessage.height;
	                    }
	                } else {
	                    if (nowNodePosition[1] < maxY - this.max[1] + nodeMessage.height) {
	                        nowNodePosition[1] = maxY - this.max[1] + nodeMessage.height
	                    }
	                }
	            }
	            if (nodeMessage.node.alarm) {
	                var newAlarmPosition = [nowNodePosition[0] + nodeMessage.node.getBoundingRect().width - (nodeMessage.node.alarm
	                        .getBoundingRect().width - 6), nowNodePosition[1] - nodeMessage.node.alarm.getBoundingRect()
	                    .height - 3
	                ];
	                nodeMessage.node.alarm.attr("position", newAlarmPosition);
	            }
	            //改变背景rect的长宽和位置
	            this.setProperties({
	                shape: {
	                    width: width,
	                    height: height,
	                    x: rx,
	                    y: ry
	                }
	            });
	
	        },
	
	        setProperties: function (opt) {
	            var rect = this.childOfName(GroupNode.RECT_NAME);
	            rect.setShape(opt.shape);
	           // rect.attr("style", opt.style);
	            this.attr('position', opt.position);
	           // this.attr("shape", opt.shape);
	        },
	
	        merged: function () {
	            var that = this;
	            //保留group的初始位置
	            var groupPosition = zrUtil.clone(this.position);
	            //给小图片设置属性，隐藏group
	            var width = this._relationImage.getBoundingRect().width;
	            var height = this._relationImage.getBoundingRect().height;
	            //计算合并后的小图片的position
	            var relationImagePosition = [this.position[0] + this.childOfName(GroupNode.RECT_NAME).shape.x + (this.getBoundingRect()
	                    .width / 2 - width / 2), this.position[1] + this.childOfName(GroupNode.RECT_NAME).shape.y +
	                (this.getBoundingRect().height / 2 - height / 2)
	            ];
	            //将小图片的位置保留下来
	            var cloneImagePosition = zrUtil.clone(relationImagePosition);
	            this._relationImage.attr("style", {
	                image: this.mergedImage,
	                width: width,
	                height: height
	            });
	            this._relationImage.attr("position", relationImagePosition);
	            if (width > 0 && height > 0) {
	                this.hide();
	                this._relationImage.show();
	            }
	
	            //双击图片放出组
	            this._relationImage.on("dblclick", function () {
	                //设置组的位置根据小图片的偏移量来计算
	                that.attr('position',[groupPosition[0] + (this.position[0] -cloneImagePosition[0]),
	                    groupPosition[1] + (this.position[1] - cloneImagePosition[1])]);
	                this.hide();
	                that.show();
	            });
	            return this._relationImage;
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.options.shape;
	            var newW = Number(shape.width * scaleRatio);
	            var newH = Number(newW * shape.height / shape.width);
	            if (ifParse) {
	                newW = parseInt(newW, 10);
	                newH = parseInt(newH, 10);
	            }
	            // 按比例缩放
	            this.setProperties({
	                shape: {
	                    width: newW,
	                    height: newH
	                }
	            });
	            // 更新组内节点
	            this.children().forEach(function(v) {
	                var position = v.position;
	                if (v.name !== GroupNode.RECT_NAME && !(v instanceof Connector) && v.type !== 'ZPath') {
	                    // 每个节点的position更新
	                    v.updateShape(ratio, ifParse);
	                    v.attr('position', [position[0] * scaleRatio, position[1] * scaleRatio]);
	                } else if (v.type === 'ZPath') {
	                    var rect = v.rect;
	                    rect.height = rect.height * scaleRatio;
	                    rect.width = rect.width * scaleRatio;
	                    v.attr({
	                        position: [position[0] * scaleRatio, position[1] * scaleRatio],
	                        rect: rect
	                    });
	                }
	            });
	        }
	    }
	
	    zrUtil.inherits(GroupNode, graphic.Group);
	    module.exports = GroupNode;
	
	/**
	 * @method add
	 * 将节点加入到这个组中最后
	 * @param {Object} node 欲添加到组的节点
	 */
	/**
	 * @method removeAll
	 * 移除所有子节点
	 */
	
	/**
	 * @method remove
	 * 移除所有子节点
	 * @param {Object} child 子节点
	 */
	/**
	 * @method childOfName
	 * 获取指定名字的儿子节点
	 * @param {String} name
	 * @return {Object} 节点
	 */
	/**
	 * @method traverse
	 * 深度优先遍历所有子孙节点（each只遍历子节点）
	 * @param {String} name
	 * @return {Object} 节点
	 */
	
	/**
	 * @cfg {String} mergedImage=''  控制当双击时 组可以缩小为指定的图形。
	 */
	
	/**
	 * @cfg {Boolean} childDraggable=false  控制组内成员是否可以拖动
	 */
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * fishTopoFlow的node对象，框架提供的节点都放在这个对象下。通过extend方法创建自定义节点<br>
	 * @class fishTopoFlow.node
	 * @abstract
	 *
	    * **使用范例**：
	    *
	    *      @example
	    *       var node = fishTopoFlow.node;
	    *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	    *      var Diamond = node.extend({
	    *          type: 'Diamond',
	    *          shape: {
	    *              width: 0,
	    *              height: 0
	    *          },
	    *          buildPath: function (path, shape) {
	    *              var cx = 0;
	    *              var cy = 0;
	    *              var width = shape.width / 2;
	    *              var height = shape.height / 2;
	    *              path.moveTo(cx, cy - height);
	    *              path.lineTo(cx + width, cy);
	    *              path.lineTo(cx, cy + height);
	    *              path.lineTo(cx - width, cy);
	    *              path.closePath();
	    *          }
	    *      });
	    *        var diamod = new Diamond({
	    *            shape: {
	    *                width:50,
	    *                height:50
	    *            },
	    *            position:[60,60]
	    *        })
	    *        fishTopo.add(diamod);
	 */
	
	    var Path = __webpack_require__(7);
	    var Constants = __webpack_require__(93);
	    var zrUtil = __webpack_require__(5);
	    var util = __webpack_require__(65);
	    var Model = __webpack_require__(87);
	    var flowNode = {};
	    /**
	     * 构造模型
	     * @private
	     */
	    flowNode.genModel = function (type, opts) {
	        var model = new Model({});
	        // 没有id的时候，缺少给一个UUID。创建节点或者反序列化的时候 节点的ID取的是opts.id
			if (!opts.id) {
				opts.id = util.getUUID();
	        }
	        if (opts.style && opts.style.textLineHeight !== 0 && !opts.style.rich) { //#170
	            opts.style.rich = {};
	        }
	        model.set(Constants.ELEMENT_TYPE, type);
	        // 防止 new el.constructor({ style: el.style,shape: el.shape }); zrUtil.clone报错
	        if (opts.style && opts.style.host) {
	            delete opts.style.host;
	        }
	        model.set(Constants.OPTIONS, zrUtil.clone(opts));
	        if ("draggable" in opts) {
	            opts.isdraggable = opts.draggable;
	            delete opts.draggable;
	        }
	        if (!opts.z) {
	            opts.z = 1; //节点默认为1，线段0;
	        }
	
	        if (util.isUndefined(opts.hoverAnimation)) {
	            opts.hoverAnimation = false;
	        }
	
	        if (util.isUndefined(opts.selectable)) {
	            opts.selectable = true;  //默认可以选中
	        }
	        return model;
	    }
	
	    flowNode.addHoverAnimation = function(node) {
	        var scale = zrUtil.clone(node.scale) || [1,1];
	        var onEmphasis = function() {
	            this.animateTo({
	                scale: [scale[0] * 1.1, scale[1] * 1.1]
	            }, 400, 'elasticOut');
	        };
	        var onNormal = function() {
	            this.animateTo({
	                scale: scale
	            }, 400, 'elasticOut');
	        };
	        node.on('mouseover', onEmphasis)
	            .on('mouseout', onNormal)
	            .on('emphasis', onEmphasis)
	            .on('normal', onNormal);
	    }
	
	    /**
	     * @method extend
	     * 扩展一个 自定义节点, 比如钻石形等。
	     * @param {Object} props
	     * @param {string} props.type 自定义结节的名称 Path type
	     * @param {Function} [props.init] 初始化 Initialize
	     * @param {Function} props.buildPath 进行构建节点 Overwrite buildPath method
	     * @param {Object} [props.style] 缺省样式 Extended default style config
	     * @param {Object} [props.shape] 缺省节点参数 Extended default shape config
	     *
	     */
	    flowNode.extend = function (defaults) {
	        var Sub = function (opts) {
	            this.model = flowNode.genModel(defaults.type, opts);
	            Path.call(this, opts);
	
	            if (defaults.style) {
	                // Extend default style
	                this.style.extendFrom(defaults.style, false);
	            }
	
	            // Extend default shape
	            var defaultShape = defaults.shape;
	            if (defaultShape) {
	                this.shape = this.shape || {};
	                var thisShape = this.shape;
	                for (var name in defaultShape) {
	                    if (
	                        !thisShape.hasOwnProperty(name)
	                        && defaultShape.hasOwnProperty(name)
	                    ) {
	                        thisShape[name] = defaultShape[name];
	                    }
	                }
	            }
	
	            defaults.init && defaults.init.call(this, opts);
	
	        };
	
	        zrUtil.inherits(Sub, Path);
	
	        // FIXME 不能 extend position, rotation 等引用对象
	        for (var name in defaults) {
	            // Extending prototype values and methods
	            if (name !== 'style' && name !== 'shape') {
	                Sub.prototype[name] = defaults[name];
	            }
	        }
	        // 重写setStyle
	        Sub.prototype.setStyle = function(key, value) {
	            this.style.set(key, value);
	            this.dirty(false);
	            zrUtil.merge(this.model.get("options.style"), key, true);
	            return this;
	        }
	
	        return Sub;
	    };
	    module.exports = flowNode;
	
	
	/**
	 * @cfg {Array} position 节点的位置,统一使用position进行定位[x,y] eg. [100,100]
	 */
	
	/**
	 * @cfg {Object} style 样式参数
	 * @cfg {string} style.fill=#000 填充色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red | gradient 注：单独文字使用textFill
	 * @cfg {string} style.stroke=null 笔画颜色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red | gradient 注：单独文字使用textStoke
	 * @cfg {number} style.lineWidth=1 笔画宽度
	 * @cfg {Array} style.lineDash=null 笔画的虚线间隔，参数为交替绘制线段和间距长度的数字 参见[lineDashOffset](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/setLineDash) eg. lineDash:[6,10]
	 * @cfg {number} style.lineDashOffset=0  笔画的虚线偏移量 参见[lineDashOffset](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineDashOffset)
	 * @cfg {string} style.text="" 节点上显示的文本,可以使用 \n 来换行
	 * @cfg {string} style.textFont='12px sans-serif' 字体大小、字体类型、粗细、字体样式。格式参见[css font](https://developer.mozilla.org/en-US/docs/Web/CSS/font) eg.textFont: 'italic bolder 14px Microsoft YaHei'
	 * @cfg {string} style.fontStyle=null 字体样式
	 * @cfg {string} style.fontWeight=#000 字体粗细
	 * @cfg {number} style.fontSize=null 字体大小
	 * @cfg {string} style.fontFamily=null 字体类型
	 * @cfg {string} style.textFill=#000 节点上文本的填充色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red
	 * @cfg {string} style.textStoke=null 节点上文本的描边色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red
	 * @cfg {string|Array} style.textPosition="" 文本在节点中的位置left|right|top|bottom|inside|insideLeft|insideRight|insideTop|insideBottom|insideTopLeft|insideTopRight|insideBottomLeft|insideBottomRight|[x,y]|[%,%]
	 * @cfg {string} style.textBaseline="alphabetic" 当前文本基线的属性 "top" || "hanging" || "middle" || "alphabetic" || "ideographic" || "bottom" 参见[css font](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/textBaseline)
	 * @cfg {Array} style.textOffset=null 文本在节点的偏移值[x,y] eg. [10,10]
	 * @cfg {string} style.textAlign="" 文本在节点中的对齐方式 left | center | right
	 * @cfg {string} style.textVerticalAlign=null 文本在节点中的垂直对齐方式 top | middle | bottom
	 * @cfg {number} style.textDistance=5 文字的相对textPos的偏移量 eg. textPosition='left' textDistance=5 则文字的x坐标的值为 (left的坐标x值) -5
	 * @cfg {string} style.textShadowColor='transparent' 文字阴影颜色
	 * @cfg {number} style.textShadowBlur=0 文本阴影宽度 参见[shadowBlur](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowBlur)
	 * @cfg {number} style.textShadowOffsetX=0 文本阴影 X 方向偏移 参见shadowOffsetX[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetX]
	 * @cfg {number} style.textShadowOffsetY=0 文本阴影 Y 方向偏移 参见shadowOffsetY[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetY]
	 * @cfg {number} style.textRotation=0 文本旋转的角度
	 * @cfg {number} style.textBorderWidth=0 文字描边宽度
	 * @cfg {string} style.textBorderColor=null 文字描边颜色
	 * @cfg {number} style.textBorderRadius=0 文字描边半径
	 * @cfg {string|Object} style.textBackgroundColor=null 文字背景(颜色或图片) eg. '#333' | {image:'./asset/img/clund.png'}
	 * @cfg {number|Array} style.textPadding=null 文字padding  eg. `2` or `[2, 4]` or `[2, 3, 4, 5]`
	 * @cfg {Object} style.rich=null 富文本样式属性
	 * @cfg {number} style.textLineHeight=0 文字的行高
	 * @cfg {number} style.opacity=1 图形透明度。支持从 0 到 1 的数字，为 0 时不绘制该图形。
	 * @cfg {number} style.shadowBlur=0 阴影宽度 参见[shadowBlur](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowBlur)
	 * @cfg {number} style.shadowOffsetX=0 阴影 X 方向偏移 参见shadowOffsetX[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetX]
	 * @cfg {number} style.shadowOffsetY=0 阴影 Y 方向偏移 参见shadowOffsetY[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetY]
	 * @cfg {string} style.shadowColor='#000' 阴影颜色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red 参见[shadowColor](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowColor)
	 * @cfg {string} style.image="" 图片的路径 用于Image
	 * @cfg {number} style.width 图片的宽度 用于Image
	 * @cfg {number} style.height 图片的高度 用于Image
	 */
	
	 /**
	 * @cfg {Object} hoverStyle hover样式, 参数见style
	  */
	 /**
	 * @cfg {Object} selectStyle 选中节点的样式, 参数见style;  默认是一个虚的边框;  设为空对象则不显示选中边框;
	*/
	/**
	 * @cfg {Boolean} draggable=true 是否可以被拖拽。
	 */
	
	/**
	 * @cfg {Boolean} ignore=false 是否隐藏状态（只读），fasle:隐藏,true:不隐藏
	 */
	
	/**
	 * @cfg {Boolean} selectable=true 节点是否可选中，默认是true
	 */
	
	/**
	 * @cfg {String} id 为了避免重复，目前由系统自动生成，如果不需要用可以忽略。建议使用nmae
	 */
	
	/**
	 *  @cfg {Boolean} hoverAnimation=false 是否开启 hover 在节点上的提示动画效果。，默认是false
	 */
	
	/**
	 * @cfg {String} name 指定节点的name, 可以使用childOfName等函数根据name查找节点
	 */
	
	/**
	 * @cfg {String} tooltip 节点的tooltip 内容可以包括HTML标签
	 */
	
	/**
	 * @cfg {Object} relative relative描述怎么根据父元素进行定位，设置了relative属性 就不需要设置position。支持：left、right、top、bottom
	 * @cfg {Number|String} relative.left  距离父元素左边的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.left 和 right 只有一个可以生效。
	 * @cfg {Number|String} relative.right  距离父元素右边的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.left 和 right 只有一个可以生效。
	 * @cfg {Number|String} relative.top  距离父元素顶部的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.top 和 bottom 只有一个可以生效。
	 * @cfg {Number|String} relative.bottom  距离父元素底部的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.top 和 bottom 只有一个可以生效。
	 * @cfg {String} [bounding='all'] 决定此图形元素在定位时，对自身的包围盒计算方式。 1.'all'：（默认） 表示用自身以及子节点整体的经过 transform 后的包围盒进行定位。 这种方式易于使整体都限制在父元素范围中。2.'raw'： 表示仅仅用自身（不包括子节点）的没经过 tranform 的包围盒进行定位。 这种方式易于内容超出父元素范围的定位方式。
	 */
	
	/**
	 * @cfg {Array} scale 节点的缩放因子, [x,y] 水平与垂直方向的 eg. [1,1]
	 */
	
	/**
	 * @cfg {number} rotation 节点的旋转因子, 单位是角度 eg. 0.5* Math.PI
	 */
	
	/**
	 * @cfg {Array} origin 旋转和缩放的原点, [x,y] eg. [75,75]
	 */
	
	/**
	 * @cfg {number} z=0  z方向的高度，决定层叠关系。类似css zIndex
	 */
	
	/**
	 * @cfg {number} zlevel=0  决定此元素绘制在哪个 canvas 层中。注意，越多 canvas 层会占用越多资源。
	 */
	
	/**
	 * @cfg {Boolean} silent=false  是否不响应鼠标以及触摸事件。
	 */
	/**
	 * @cfg {Boolean} invisible=false  节点是否可见。
	 */
	
	/**
	 * @cfg {Object} parent  节点的父元素
	 */
	/**
	 * @cfg {Object} operationIcons  节点操作为选中的节点，提供默认操作或用户自定义操作。
	 * @cfg {String} operationIcons.name 设置节点名称，可选值有constants.DEL(删除)，constants.LINK（直线），constants.FOLD（折线），constants.CURVE(曲线)，以及自定义名称
	 * @cfg {String} operationIcons.iconPath 设置自定义节点图标路径
	 * @cfg {Function} operationIcons.callback 设置节点被点击（click）的回调函数
	 * **使用范例**：
	 *
	 *      @example
	 *       var image1 = new node.Image({
	 *           style: {
	 *               image: "img/img-cic/icon-send-sms.svg",
	 *               width:120,
	 *               height:70,
	 *               text:"操作:线段",
	 *               textPosition:"insideBottom"
	 *           },
	 *           position:[60,60],
	 *           operationIcons: [
	 *               { name: constants.LINK} ,
	 *               { name: constants.FOLD },
	 *               { name: constants.CURVE }
	 *           ]
	 *       });
	 */
	
	/**
	 * @property {Object} states
	 * 用于设置节点的状态
	 */
	
	
	/**
	 * @property {Object} model
	 * 节点的模型，用于存储序列化数据 以及用户自定义数据
	 */
	
	/**
	 * @method attr
	 * 设置节点属性
	 * @param {String|Object} key 设置的属性。可以是 string 类型的属性名称，或者 Object 类型的属性及其值
	 * @param {*} 属性值
	 * **使用范例**
	 *
	 * @example
	 *
	 * node.attr('position', [100, 200]);
	 * node.attr({
	 *     style: {
	 *         fill: 'red'
	 *     },
	 *     shape: {
	 *         x: 100
	 *     }
	 * });
	 */
	
	/**
	 * @method setStyle
	 * 创建节点后，设置节点的样式（style属性）
	 * @param {String} key 键名
	 * @param {*} value 键值
	 * @return {Object} 返回节点对象自身
	 */
	
	/**
	 * @method setShape
	 * 创建节点后，设置节点的形状（shape属性）
	 * @param {String} key 键名
	 * @param {*} value 键值
	 * @return {Object} 返回节点对象自身
	 */
	
	/**
	 * @method hide
	 * 隐藏节点
	 */
	
	/**
	 * @method show
	 * 显示节点
	 */
	
	
	/**
	 * @method on
	 * 绑定事件
	 * @param {String} event 事件名
	 * @param {Function} handler 事件处理函数
	 * @param {Object} [context] 上下文
	 */
	
	/**
	 * @method off
	 * 解绑事件
	 * @param {String} event 事件名
	 * @param {Function} handler 事件处理函数
	 */
	
	/**
	 * @method one
	 * 单次触发绑定,trigger后销毁
	 * @param {String} event 事件名
	 * @param {Function} handler 事件处理函数
	 * @param {Object} [context] 上下文
	 */
	
	/**
	 * @method trigger
	 * 事件分发
	 * @param {String} type 事件类型
	 */
	
	/**
	 * @method isSilent
	 * 是否绑定了事件
	 * @param {String} event 事件名
	 * @return {boolean}
	 */
	
	/**
	 * @method animate
	 * 动画
	 * @param {String} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性
	 * @param {Boolean} [loop] 动画是否循环
	 * @return {Object} 返回Animator对象
	 * **使用范例**：
	 *
	 *      @example
	 *      el.animate('style', false)
	 *         .when(1000, {x: 10} )
	 *         .done(function(){ // Animation done })
	 *         .start()
	 */
	
	/**
	 * @method stopAnimation
	 * 停止动画
	 * @param {boolean} forwardToLast 是否在停止前移动到最后一帧
	 */
	
	/**
	 * @method animateTo
	 * 从一动属性过渡到另一种属性的动画
	 * @param {Object} target 目前属性
	 * @param {number} [time=500] 动画时间 单位ms
	 * @param {string} [easing='linear'] 动画函数 参见[缓动示例](http://echarts.baidu.com/gallery/editor.html?c=line-easing)
	 * @param {number} [delay=0] 延时时间
	 * @param {Function} [callback] 动画结束回调
	 * **使用范例**：
	 *
	 *      @example
	 *          // Animate position
	 *          el.animateTo({
	 *              position: [10, 10]
	 *          }, function () { // done })
	 *
	 *          // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
	 *          el.animateTo({
	 *              shape: {
	 *                  width: 500
	 *              },
	 *              style: {
	 *                  fill: 'red'
	 *              }
	 *              position: [10, 10]
	 *          }, 100, 100, 'cubicOut', function () { // done })
	 */
	
	/**
	 * @event click
	 * 单击事件
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('click', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	/**
	 * @event dblclick
	 * 当双击元素时，会发生 dblclick 事件。
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('dblclick', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	/**
	 * @event mouseover
	 * 当鼠标指针位于元素上方时，会发生 mouseover 事件
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('mouseover', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	/**
	 * @event mouseout
	 * 当鼠标指针从元素上移开时，发生 mouseout 事件。
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('mouseout', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	
	/**
	 * @event mousemove
	 * 当鼠标指针在指定的元素中移动时，就会发生 mousemove 事件
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('mousemove', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	
	/**
	 * @event mousewheel
	 * 当用户在指定的元素时滚动鼠标滑轮时,就会发生 mousewheel事件
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('mousewheel', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	
	/**
	 * @event mousedown
	 * 当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('mousedown', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	
	/**
	 * @event mouseup
	 * 当在元素上放松鼠标按钮时，会发生 mouseup 事件。
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('mouseup', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	/**
	 * @event contextmenu
	 * 当在元素上点击鼠标右键时，会发生 contextmenu 事件。
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象，如果想阻止默认的浏览器右键菜单请使用 event.event.preventDefault(); event.event.stopPropagation();
	
	 * <pre>
	 * node.on('contextmenu', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	/**
	 * @event dragstart
	 * 当开始拖动节点的时候，会发生 dragstart 事件。
	 *
	 * <pre>
	 * node.on('dragstart', function(e) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	
	/**
	 * @event drag
	 * 当拖动节点的时候，会发生 drag 事件。
	 *
	 * <pre>
	 * node.on('drag', function(e) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	/**
	 * @event dragend
	 * 当拖动节点结束的时候，会发生 dragend 事件。
	 *
	 * <pre>
	 * node.on('dragend', function(e) {
	 *   //do something
	 * })
	 * </pre>
	 */


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 矩形<br>
	 * @class fishTopoFlow.node.Rect
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var rect = new node.Rect({
	 *           shape:{width:100,height:60},
	 *           position:[20,20]
	 *       });
	 *       fishTopo.add(rect);
	 */
	
	    var roundRectHelper = __webpack_require__(29);
	
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Rect',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Array} shape.points=null 拆线点的坐标 可以从AI中获取。
	         * @cfg {Number|String|Boolean} [shape.smooth=false] 是否平滑曲线显示。如果为 number：表示贝塞尔 (bezier) 差值平滑，smooth 指定了平滑等级，范围 [0, 1];如果为 'spline'：表示 Catmull-Rom spline 差值平滑
	         * @cfg {Number} shape.smoothConstraint=null 是否将平滑曲线约束在包围盒中。smooth 为 number（bezier）时生效
	         */
	        shape: {
	            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
	            // r缩写为1         相当于 [1, 1, 1, 1]
	            // r缩写为[1]       相当于 [1, 1, 1, 1]
	            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
	            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
	            x: 0,
	            y: 0,
	            r: 0,
	            width: 50,
	            height: 50
	        },
	
	        buildPath: function (ctx, shape) {
	            var x = 0;
	            var y = 0;
	            var width = shape.width;
	            var height = shape.height;
	            if (!shape.r) {
	                ctx.rect(x, y, width, height);
	            }
	            else {
	                roundRectHelper.buildPath(ctx, shape);
	            }
	            ctx.closePath();
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newW = Number(shape.width * scaleRatio);
	            var newH = Number(newW * shape.height / shape.width);
	            if (ifParse) {
	                newW = parseInt(newW, 10);
	                newH = parseInt(newH, 10);
	            }
	            // 按比例缩放
	            this.setShape({
	                width: newW,
	                height: newH
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 圆形<br>
	 * @class fishTopoFlow.node.Circle
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var circle = new node.Circle({
	 *           shape:{r:24},
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(circle);
	 */
	
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Circle',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.r=20 半径。
	         */
	        shape: {
	            r: 20
	        },
	
	        buildPath : function (ctx, shape, inBundle) {
	            // Better stroking in ShapeBundle
	            // Always do it may have performence issue ( fill may be 2x more cost)
	            if (inBundle) {
	                ctx.moveTo(shape.r, 0);
	            }
	            // Better stroking in ShapeBundle
	            // ctx.moveTo(shape.cx + shape.r, shape.cy);
	            ctx.arc(0, 0, shape.r, 0, Math.PI * 2, true);
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newR = Number(shape.r * scaleRatio);
	            if (ifParse) {
	                newR = parseInt(newR, 10);
	            }
	            // 按比例缩放
	            this.setShape({
	                r: newR
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 图片节点<br>
	 * @class fishTopoFlow.node.Image
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var image = new node.Image({
	 *           style: {
	 *               image: "../../examples/flow/img/img-cic/start.svg",
	 *               width:120,
	 *               height:70,
	 *               text:"Event Name"
	 *           },
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(image);
	 */
	
	
	    var Displayable = __webpack_require__(8);
	    var BoundingRect = __webpack_require__(27);
	    var zrUtil = __webpack_require__(5);
	    var flowNode = __webpack_require__(96);
	    var LRU = __webpack_require__(21);
	    var globalImageCache = new LRU(50);
	
	
	    function ZImage(opts) {
	        this.model = flowNode.genModel("Image", opts);
	        Displayable.call(this, opts);
	
	        if (window.jQuery) {   //判断jQuery是否存在
	            this.resultDeferrd = jQuery.Deferred();
	            this.result = this.resultDeferrd.promise();
	        }
	    }
	
	    ZImage.prototype = {
	
	        constructor: ZImage,
	
	        type: 'Image',
	
	        brush: function (ctx, prevEl) {
	            var style = this.style;
	            var src = style.image;
	            var image;
	
	            // Must bind each time
	            style.bind(ctx, this, prevEl);
	            // style.image is a url string
	            if (typeof src === 'string') {
	                image = this._image;
	                if (image && image.src !== src) { //#171
	                    image = null;
	                }
	            }
	            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas
	            else {
	                image = src;
	                image.isLoaded = true;
	            }
	            // FIXME Case create many images with src
	            if (!image && src) {
	                // Try get from global image cache
	                var cachedImgObj = globalImageCache.get(src);
	                if (!cachedImgObj) {
	                    // Create a new image
	                    image = new Image();
	                    image.isLoaded = false;
	                    image.onload = function () {
	                        image.isLoaded = true;
	                        image.onload = null;
	                        for (var i = 0; i < cachedImgObj.pending.length; i++) {
	                            cachedImgObj.pending[i].dirty();
	                        }
	                    };
	                    cachedImgObj = {
	                        image: image,
	                        pending: [this]
	                    };
	                    image.src = src;
	                    globalImageCache.put(src, cachedImgObj);
	                    this._image = image;
	                    return;
	                }
	                else {
	                    image = cachedImgObj.image;
	                    this._image = image;
	                    // Image is not complete finish, add to pending list  如果使用的svg图片, IE11下就算加载成功image.width, image.height也都是为0
	                    if ((!image.width || !image.height) && (!image.src.endsWith("svg"))) {
	                        cachedImgObj.pending.push(this);
	                        return;
	                    }
	                }
	            }
	
	            if (image) {
	                // 图片已经加载完成
	                // if (image.nodeName.toUpperCase() == 'IMG') {
	                //     if (!image.complete) {
	                //         return;
	                //     }
	                // }
	                // Else is canvas
	
	                var x = style.x || 0;
	                var y = style.y || 0;
	                // 如果使用的svg图片, IE11下就算加载成功image.width, image.height也都是为0
	                //此处如不注释, 会导致IE11下svg图片无法使用
	                // 图片加载失败
	                // if (!image.width || !image.height) {
	                //     return;
	                // }
	                if (!image.isLoaded) {
	                    if (window.jQuery) {
	                        this.resultDeferrd.reject(image);
	                    }
	                    return;
	                }
	
	                var width = style.width;
	                var height = style.height;
	                var aspect = image.width / image.height;
	                if (width == null && height != null) {
	                    // Keep image/height ratio
	                    width = height * aspect;
	                }
	                else if (height == null && width != null) {
	                    height = width / aspect;
	                }
	                else if (width == null && height == null) {
	                    width = image.width;
	                    height = image.height;
	                }
	
	                // 设置transform
	                this.setTransform(ctx);
	
	                if (style.sWidth && style.sHeight) {
	                    var sx = style.sx || 0;
	                    var sy = style.sy || 0;
	                    ctx.drawImage(
	                        image,
	                        sx, sy, style.sWidth, style.sHeight,
	                        x, y, width, height
	                    );
	                }
	                else if (style.sx && style.sy) {
	                    var sx2 = style.sx;
	                    var sy2 = style.sy;
	                    var sWidth = width - sx2;
	                    var sHeight = height - sy2;
	                    ctx.drawImage(
	                        image,
	                        sx2, sy2, sWidth, sHeight,
	                        x, y, width, height
	                    );
	                }
	                else {
	                    ctx.drawImage(image, x, y, width, height);
	                }
	                // 如果没设置宽和高的话自动根据图片宽高设置
	                if (style.width == null) {
	                    style.width = width;
	                }
	                if (style.height == null) {
	                    style.height = height;
	                }
	
	                this.restoreTransform(ctx);
	
	                // Draw rect text
	                if (style.text != null) {
	                    this.drawRectText(ctx, this.getBoundingRect());
	                }
	                if (window.jQuery) {
	                    this.resultDeferrd.resolve(image);
	                }
	            }
	        },
	
	        getBoundingRect: function () {
	            var style = this.style;
	            if (! this._rect) {
	                this._rect = new BoundingRect(
	                    style.x || 0, style.y || 0, style.width || 0, style.height || 0
	                );
	            }
	            return this._rect;
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var style = this.style;
	            var newW = Number(style.width * scaleRatio);
	            var newH = Number(newW * style.height / style.width);
	            if (ifParse) {
	                newW = parseInt(newW, 10);
	                newH = parseInt(newH, 10);
	            }
	            // 按比例缩放
	            this.setStyle({
	                width: newW,
	                height: newH
	            });
	        }
	    };
	
	    zrUtil.inherits(ZImage, Displayable);
	
	    module.exports = ZImage;
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 文本<br>
	 * @class fishTopoFlow.node.Text
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"));
	 *       var text = new node.Text({
	 *           style:{text:"文本也可以作为独立的节点进行拖拽",fill:"#ff0000", textFont:"16px Microsoft YaHei"},
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(text);
	 */
	
	    var Text = __webpack_require__(46);
	    var zrUtil = __webpack_require__(5);
	    var flowNode = __webpack_require__(96);
	    function ZText(opts) {
	        var defaultOptions = {
	            style:{textBaseline:"top"}   // 默认值  这样选中时的框才正确
	        };
	        var options = zrUtil.merge(defaultOptions, opts, true);
	        this.model = flowNode.genModel("Text", options);
	        Text.call(this, options);
	    }
	
	    ZText.prototype = {
	        constructor: ZText,
	
	        type: 'Text',
	
	        updateShape: function () {
	            
	        }
	    }
	    zrUtil.inherits(ZText, Text);
	    module.exports = ZText;
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 扇形<br>
	 * @class fishTopoFlow.node.Sector
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"));
	 *       var sector = new node.Sector({
	 *           shape: {r:30, startAngle:0, endAngle:Math.PI * 0.5}, // startAngle\endAngle是弧度单位
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(sector);
	 */
	
	    var env = __webpack_require__(50);
	    var Path = __webpack_require__(7);
	
	    var shadowTemp = [
	        ['shadowBlur', 0],
	        ['shadowColor', '#000'],
	        ['shadowOffsetX', 0],
	        ['shadowOffsetY', 0]
	    ];
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Sector',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.r=0 外半径。
	         * @cfg {Number} shape.r0=0 内半径。
	         * @cfg {Number} shape.startAngle=0 开始弧度。
	         * @cfg {Number} shape.endAngle=Math.PI * 2  结束弧度。
	         * @cfg {Boolean} shape.clockwise=true 是否顺时针。
	         */
	        shape: {
	            cx: 0,
	
	            cy: 0,
	
	            r0: 0,
	
	            r: 0,
	
	            startAngle: 0,
	
	            endAngle: Math.PI * 2,
	
	            clockwise: true
	        },
	
	        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'
	            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),
	            // where exception "unexpected call to method or property access"
	            // might be thrown when calling ctx.fill after a path whose area size
	            // is zero is drawn and ctx.clip() is called and shadowBlur is set.
	            // (e.g.,
	            //  ctx.moveTo(10, 10);
	            //  ctx.lineTo(20, 10);
	            //  ctx.closePath();
	            //  ctx.clip();
	            //  ctx.shadowBlur = 10;
	            //  ...
	            //  ctx.fill();
	            // )
	            ? function () {
	                var clipPaths = this.__clipPaths;
	                var style = this.style;
	                var modified;
	
	                if (clipPaths) {
	                    for (var i = 0; i < clipPaths.length; i++) {
	                        var shape = clipPaths[i] && clipPaths[i].shape;
	                        if (shape && shape.startAngle === shape.endAngle) {
	                            for (var j = 0; j < shadowTemp.length; j++) {
	                                shadowTemp[j][2] = style[shadowTemp[j][0]];
	                                style[shadowTemp[j][0]] = shadowTemp[j][1];
	                            }
	                            modified = true;
	                            break;
	                        }
	                    }
	                }
	
	                Path.prototype.brush.apply(this, arguments);
	
	                if (modified) {
	                    for (var k = 0; k < shadowTemp.length; k++) {
	                        style[shadowTemp[k][0]] = shadowTemp[k][2];
	                    }
	                }
	            }
	            : Path.prototype.brush,
	
	        buildPath: function (ctx, shape) {
	
	            var x = shape.cx;
	            var y = shape.cy;
	            var r0 = Math.max(shape.r0 || 0, 0);
	            var r = Math.max(shape.r, 0);
	            var startAngle = shape.startAngle;
	            var endAngle = shape.endAngle;
	            var clockwise = shape.clockwise;
	
	            var unitX = Math.cos(startAngle);
	            var unitY = Math.sin(startAngle);
	
	            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
	
	            ctx.lineTo(unitX * r + x, unitY * r + y);
	
	            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	
	            ctx.lineTo(
	                Math.cos(endAngle) * r0 + x,
	                Math.sin(endAngle) * r0 + y
	            );
	
	            if (r0 !== 0) {
	                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
	            }
	
	            ctx.closePath();
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newR = Number(shape.r * scaleRatio);
	            var newR0 = Number(shape.r0 * scaleRatio);
	            if (ifParse) {
	                newR = parseInt(newR, 10);
	                newR0 = parseInt(newR0, 10);
	            }
	            // 按比例缩放
	            this.setShape({
	                r: newR,
	                r0: newR0
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 环形<br>
	 * @class fishTopoFlow.node.Ring
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"));
	 *       var ring = new node.Ring({
	 *           shape: {r:30,  r0:10},  // r0 内半径
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(ring);
	 */
	
	    module.exports = __webpack_require__(96).extend({
	
	         type: 'Ring',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.r=0 外半径。
	         * @cfg {Number} shape.r0=0 内半径。
	         */
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: 0,
	            r0: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var x = shape.cx;
	            var y = shape.cy;
	            var PI2 = Math.PI * 2;
	            ctx.moveTo(x + shape.r, y);
	            ctx.arc(x, y, shape.r, 0, PI2, false);
	            ctx.moveTo(x + shape.r0, y);
	            ctx.arc(x, y, shape.r0, 0, PI2, true);
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newR = Number(shape.r * scaleRatio);
	            var newR0 = Number(shape.r0 * scaleRatio);
	            if (ifParse) {
	                newR = parseInt(newR, 10);
	                newR0 = parseInt(newR0, 10);
	            }
	            // 按比例缩放
	            this.setShape({
	                r: newR,
	                r0: newR0
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 椭圆<br>
	 * @class fishTopoFlow.node.Droplet
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var ellipse = new node.Ellipse({
	 *           shape: {rx:70,  ry:30},  // rx:椭圆横半轴长 ry:椭圆纵半轴长
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(ellipse);
	 */
	
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Ellipse',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.rx=0 椭圆横半轴长
	         * @cfg {Number} shape.ry=0 椭圆纵半轴长
	         */
	        shape: {
	            rx: 0, ry: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var k = 0.5522848;
	            var x = 0;
	            var y = 0;
	            var a = shape.rx;
	            var b = shape.ry;
	            var ox = a * k; // 水平控制点偏移量
	            var oy = b * k; // 垂直控制点偏移量
	            // 从椭圆的左端点开始顺时针绘制四条三次贝塞尔曲线
	            ctx.moveTo(x - a, y);
	            ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
	            ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
	            ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
	            ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
	            ctx.closePath();
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newRx = Number(shape.rx * scaleRatio);
	            var newRy = Number(newRx * shape.ry / shape.rx);
	            if (ifParse) {
	                newRx = parseInt(newRx, 10);
	                newRy = parseInt(newRy, 10);
	            }
	            // 按比例缩放
	            this.setShape({
	                rx: newRx,
	                ry: newRy
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 心形<br>
	 * @class fishTopoFlow.node.Heart
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var heart  = new node.Heart({
	 *           shape: {width:40,  height:50},
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(heart );
	 */
	
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Heart',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.cx=0 中心在父节点坐标系（以父节点左上角为原点）中的横坐标值。
	         * @cfg {Number} shape.cy=0 中心在父节点坐标系（以父节点左上角为原点）中的纵坐标值。
	         * @cfg {Number} shape.width=0 宽度。
	         * @cfg {Number} shape.height=0 高度。
	         */
	        shape: {
	            cx: 0,
	            cy: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var x = shape.cx;
	            var y = shape.cy;
	            var a = shape.width;
	            var b = shape.height;
	            ctx.moveTo(x, y);
	            ctx.bezierCurveTo(
	                x + a / 2, y - b * 2 / 3,
	                x + a * 2, y + b / 3,
	                x, y + b
	            );
	            ctx.bezierCurveTo(
	                x - a *  2, y + b / 3,
	                x - a / 2, y - b * 2 / 3,
	                x, y
	            );
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newWidth = Number(shape.width * scaleRatio);
	            var newHeight = Number(newWidth * shape.height / shape.width);
	            if (ifParse) {
	                newWidth = parseInt(newWidth, 10);
	                newHeight = parseInt(newHeight, 10);
	            }
	            // 按比例缩放
	            this.setShape({
	                width: newWidth,
	                height: newHeight
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 水滴形<br>
	 * @class fishTopoFlow.node.Droplet
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var droplet = new node.Droplet({
	 *           shape: {width:10,  height:30},
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(droplet);
	 */
	
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Droplet',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.width=0 宽度。
	         * @cfg {Number} shape.height=0 高度。
	         */
	        shape: {
	            cx: 0, cy: 0,
	            width: 0, height: 0
	        },
	
	        buildPath : function (ctx, shape) {
	            var x = shape.cx;
	            var y = shape.cy;
	            var a = shape.width;
	            var b = shape.height;
	
	            ctx.moveTo(x, y + a);
	            ctx.bezierCurveTo(
	                x + a,
	                y + a,
	                x + a * 3 / 2,
	                y - a / 3,
	                x,
	                y - b
	            );
	            ctx.bezierCurveTo(
	                x - a * 3 / 2,
	                y - a / 3,
	                x - a,
	                y + a,
	                x,
	                y + a
	            );
	            ctx.closePath();
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newWidth = Number(shape.width * scaleRatio);
	            var newHeight = Number(newWidth * shape.height / shape.width);
	            if (ifParse) {
	                newWidth = parseInt(newWidth, 10);
	                newHeight = parseInt(newHeight, 10);
	            }
	            // 按比例缩放
	            this.setShape({
	                width: newWidth,
	                height: newHeight
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 玫瑰形<br>
	 * @class fishTopoFlow.node.Rose
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"));
	 *       var rose = new node.Rose({
	 *           shape: {r:[35], k:7, n:4},
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(rose);
	 */
	
	    var sin = Math.sin;
	    var cos = Math.cos;
	    var radian = Math.PI / 180;
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Rose',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Array} shape.r=[]
	         * @cfg {Number} shape.k=0
	         * @cfg {Number} shape.n=1
	         */
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: [],
	            k: 0,
	            n: 1
	        },
	
	        style: {
	            stroke: '#000',
	            fill: null,
	            lineWidth: 2
	        },
	
	        buildPath: function (ctx, shape) {
	            var x;
	            var y;
	            var R = shape.r;
	            var r;
	            var k = shape.k;
	            var n = shape.n;
	
	            var x0 = shape.cx;
	            var y0 = shape.cy;
	
	            ctx.moveTo(x0, y0);
	
	            for (var i = 0, len = R.length; i < len ; i++) {
	                r = R[i];
	
	                for (var j = 0; j <= 360 * n; j++) {
	                    x = r
	                         * sin(k / n * j % 360 * radian)
	                         * cos(j * radian)
	                         + x0;
	                    y = r
	                         * sin(k / n * j % 360 * radian)
	                         * sin(j * radian)
	                         + y0;
	                    ctx.lineTo(x, y);
	                }
	            }
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newR = [];
	            shape.r.forEach(function (v) {
	                newR.push(Number(v * scaleRatio))
	            });
	            if (ifParse) {
	                newR.forEach(function (v) {
	                    v = parseInt(v, 10);
	                });
	            }
	            // 按比例缩放
	            this.setShape({
	                r: newR
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 正多边形<br>
	 * @class fishTopoFlow.node.Isogon
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var isogon = new node.Isogon({
	 *           shape: {r:40,  n:9},  // r半径 n几个边
	 *           position:[60,50]
	 *       });
	 *       fishTopo.add(isogon);
	 */
	
	    var PI = Math.PI;
	    var sin = Math.sin;
	    var cos = Math.cos;
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Isogon',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.r=0 半径
	         * @cfg {Number} shape.n=0 几个边
	         */
	       shape: {
	            x: 0, y: 0,
	            r: 0, n: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var n = shape.n;
	            if (!n || n < 2) {
	                return;
	            }
	
	            var x = shape.x;
	            var y = shape.y;
	            var r = shape.r;
	
	            var dStep = 2 * PI / n;
	            var deg = -PI / 2;
	
	            ctx.moveTo(x + r * cos(deg), y + r * sin(deg));
	            for (var i = 0, end = n - 1; i < end; i++) {
	                deg += dStep;
	                ctx.lineTo(x + r * cos(deg), y + r * sin(deg));
	            }
	
	            ctx.closePath();
	
	            return;
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newR = Number(shape.r * scaleRatio);
	            if (ifParse) {
	                newR = parseInt(newR, 10);
	            }
	            // 按比例缩放
	            this.setShape({
	                r: newR
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 多边形<br>
	 * @class fishTopoFlow.node.Polygon
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var polygon = new node.Polygon({
	 *           shape: {points:[[85.275,0], [100,25.41], [85.275,50.821], [14.138,50.821], [0,25.41], [14.138,0]]},  // r半径 n几个边
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(polygon);
	 */
	
	    var polyHelper = __webpack_require__(53);
	
	    module.exports = __webpack_require__(96).extend({
	
	       type: 'Polygon',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Array} shape.points=null 多边形点的坐标 可以从AI中获取。
	         * @cfg {Number|String|Boolean} [shape.smooth=false] 是否平滑曲线显示。如果为 number：表示贝塞尔 (bezier) 差值平滑，smooth 指定了平滑等级，范围 [0, 1];如果为 'spline'：表示 Catmull-Rom spline 差值平滑
	         * @cfg {Number} shape.smoothConstraint=null 是否将平滑曲线约束在包围盒中。smooth 为 number（bezier）时生效
	         */
	        shape: {
	            points: null,
	
	            smooth: false,
	
	            smoothConstraint: null
	        },
	
	        buildPath: function (ctx, shape) {
	            polyHelper.buildPath(ctx, shape, true);
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var pointsNew = [];
	            shape.points.forEach(function(item) {
	                pointsNew.push([Number(item[0] * scaleRatio), Number(item[1] * scaleRatio)]);
	            });
	            if (ifParse) {
	                pointsNew.forEach(function(item) {
	                    item[0] = parseInt(item[0], 10);
	                    item[1] = parseInt(item[1], 10);
	                });
	            }
	            // 按比例缩放
	            this.setShape({
	                points: pointsNew
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 直线<br>
	 * @class fishTopoFlow.node.Line
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var line = new node.Line({
	 *           shape: {x1:60,  y1:60, x2:100, y2:100},  // x 起点 y终点
	 *           style: {lineWidth:3}
	 *       });
	 *       fishTopo.add(line);
	 */
	
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Line',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.x1=0 起始点的横坐标值。
	         * @cfg {Number} shape.y1=0 起始点的纵坐标值。
	         * @cfg {Number} shape.x2=0 终止点的横坐标值。
	         * @cfg {Number} shape.y2=0 终止点的纵坐标值。
	         */
	        shape: {
	            // Start point
	            x1: 0,
	            y1: 0,
	            // End point
	            x2: 0,
	            y2: 0,
	
	            percent: 1
	        },
	
	        style: {
	            stroke: '#000',
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            var x1 = shape.x1;
	            var y1 = shape.y1;
	            var x2 = shape.x2;
	            var y2 = shape.y2;
	            var percent = shape.percent;
	
	            if (percent === 0) {
	                return;
	            }
	
	            ctx.moveTo(x1, y1);
	
	            if (percent < 1) {
	                x2 = x1 * (1 - percent) + x2 * percent;
	                y2 = y1 * (1 - percent) + y2 * percent;
	            }
	            ctx.lineTo(x2, y2);
	        },
	
	        /**
	         * Get point at percent
	         * @param  {number} percent
	         * @return {Array.<number>}
	         */
	        pointAt: function (p) {
	            var shape = this.shape;
	            return [
	                shape.x1 * (1 - p) + shape.x2 * p,
	                shape.y1 * (1 - p) + shape.y2 * p
	            ];
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newX1 = Number(shape.x1 * scaleRatio);
	            var newX2 = Number(shape.x2 * scaleRatio);
	            var newY1 = Number(shape.y1 * scaleRatio);
	            var newY2 = Number(shape.y2 * scaleRatio);
	            if (ifParse) {
	                newX1 = parseInt(newX1, 10);
	            }
	            // 按比例缩放
	            this.setShape({
	                x1: newX1,
	                y1: newY1,
	                x2: newX2,
	                y2: newY2
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 拆线<br>
	 * @class fishTopoFlow.node.Polyline
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var polyline = new node.Polyline({
	 *           shape: {points:[[57,138],[95,184],[115,166],[151,184] ]}
	 *       });
	 *       fishTopo.add(polyline);
	 */
	
	    var polyHelper = __webpack_require__(53);
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Polyline',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Array} shape.points=null 拆线点的坐标 可以从AI中获取。
	         * @cfg {Number|String|Boolean} [shape.smooth=false] 是否平滑曲线显示。如果为 number：表示贝塞尔 (bezier) 差值平滑，smooth 指定了平滑等级，范围 [0, 1];如果为 'spline'：表示 Catmull-Rom spline 差值平滑
	         * @cfg {Number} shape.smoothConstraint=null 是否将平滑曲线约束在包围盒中。smooth 为 number（bezier）时生效
	         */
	        shape: {
	            points: null,
	
	            smooth: false,
	
	            smoothConstraint: null
	        },
	
	        style: {
	            stroke: '#000',
	
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            polyHelper.buildPath(ctx, shape, false);
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var pointsNew = [];
	            shape.points.forEach(function(item) {
	                pointsNew.push([Number(item[0] * scaleRatio), Number(item[1] * scaleRatio)]);
	            });
	            if (ifParse) {
	                pointsNew.forEach(function(item) {
	                    item[0] = parseInt(item[0], 10);
	                    item[1] = parseInt(item[1], 10);
	                });
	            }
	            // 按比例缩放
	            this.setShape({
	                points: pointsNew
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 贝塞尔曲线<br>
	 * @class fishTopoFlow.node.BezierCurve
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var bezierCurve = new node.BezierCurve({
	 *           shape: {x1:0, y1:100, cpx1:0, cpy1:0, cpx2:0, cpy2:0, x2:100, y2:0},
	 *           position: [60, 60]
	 *       });
	 *       fishTopo.add(bezierCurve);
	 */
	
	
	    var curveTool = __webpack_require__(31);
	    var vec2 = __webpack_require__(15);
	    var quadraticSubdivide = curveTool.quadraticSubdivide;
	    var cubicSubdivide = curveTool.cubicSubdivide;
	    var quadraticAt = curveTool.quadraticAt;
	    var cubicAt = curveTool.cubicAt;
	    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;
	    var cubicDerivativeAt = curveTool.cubicDerivativeAt;
	
	    var out = [];
	
	    function someVectorAt(shape, t, isTangent) {
	        var cpx2 = shape.cpx2;
	        var cpy2 = shape.cpy2;
	        if (cpx2 === null || cpy2 === null) {
	            return [
	                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),
	                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)
	            ];
	        }
	        else {
	            return [
	                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),
	                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)
	            ];
	        }
	    }
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'BezierCurve',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.x1=0 起始点的横坐标值。
	         * @cfg {Number} shape.y1=0 起始点的纵坐标值。
	         * @cfg {Number} shape.x2=0 终止点的横坐标值。
	         * @cfg {Number} shape.y2=0 终止点的纵坐标值。
	         * @cfg {Number} shape.cpx1=0 控制点的横坐标值。
	         * @cfg {Boolean} shape.cpx2=0 控制点的纵坐标值。
	         */
	        shape: {
	            x1: 0,
	            y1: 0,
	            x2: 0,
	            y2: 0,
	            cpx1: 0,
	            cpy1: 0,
	
	            // Curve show percent, for animating
	            percent: 1
	        },
	
	        style: {
	            stroke: '#000',
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            var x1 = shape.x1;
	            var y1 = shape.y1;
	            var x2 = shape.x2;
	            var y2 = shape.y2;
	            var cpx1 = shape.cpx1;
	            var cpy1 = shape.cpy1;
	            var cpx2 = shape.cpx2;
	            var cpy2 = shape.cpy2;
	            var percent = shape.percent;
	            if (percent === 0) {
	                return;
	            }
	
	            ctx.moveTo(x1, y1);
	
	            if (cpx2 == null || cpy2 == null) {
	                if (percent < 1) {
	                    quadraticSubdivide(
	                        x1, cpx1, x2, percent, out
	                    );
	                    cpx1 = out[1];
	                    x2 = out[2];
	                    quadraticSubdivide(
	                        y1, cpy1, y2, percent, out
	                    );
	                    cpy1 = out[1];
	                    y2 = out[2];
	                }
	
	                ctx.quadraticCurveTo(
	                    cpx1, cpy1,
	                    x2, y2
	                );
	            }
	            else {
	                if (percent < 1) {
	                    cubicSubdivide(
	                        x1, cpx1, cpx2, x2, percent, out
	                    );
	                    cpx1 = out[1];
	                    cpx2 = out[2];
	                    x2 = out[3];
	                    cubicSubdivide(
	                        y1, cpy1, cpy2, y2, percent, out
	                    );
	                    cpy1 = out[1];
	                    cpy2 = out[2];
	                    y2 = out[3];
	                }
	                ctx.bezierCurveTo(
	                    cpx1, cpy1,
	                    cpx2, cpy2,
	                    x2, y2
	                );
	            }
	        },
	
	        /**
	         * Get point at percent
	         * @param  {number} t
	         * @return {Array.<number>}
	         */
	        pointAt: function (t) {
	            return someVectorAt(this.shape, t, false);
	        },
	
	        /**
	         * Get tangent at percent
	         * @param  {number} t
	         * @return {Array.<number>}
	         */
	        tangentAt: function (t) {
	            var p = someVectorAt(this.shape, t, true);
	            return vec2.normalize(p, p);
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var pointsNew = {};
	            Object.keys(shape).forEach(function (key) {
	                var value = shape[key];
	                if (key !== 'percent') {
	                    pointsNew[key] = Number(value * scaleRatio);
	                } else {
	                    pointsNew[key] = value;
	                }
	            });
	            if (ifParse) {
	                Object.keys(pointsNew).forEach(function(key) {
	                    pointsNew[key] = parseInt(pointsNew[key], 10);
	                });
	            }
	            // 按比例缩放
	            this.setShape(pointsNew);
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 圆弧<br>
	 * @class fishTopoFlow.node.Arc
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var arc = new node.Arc({
	 *           shape: {r:50, startAngle:0, endAngle:1.2*Math.PI},
	 *           position: [60, 60]
	 *       });
	 *       fishTopo.add(arc);
	 */
	
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Arc',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.r=0 半径。
	         * @cfg {Number} shape.startAngle=0 开始弧度。
	         * @cfg {Number} shape.endAngle=Math.PI * 2  结束弧度。
	         * @cfg {Boolean} shape.clockwise=true 是否顺时针。
	         */
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: 0,
	            startAngle: 0,
	            endAngle: Math.PI * 2,
	            clockwise: true
	        },
	
	        style: {
	
	            stroke: '#000',
	
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	
	            var x = shape.cx;
	            var y = shape.cy;
	            var r = Math.max(shape.r, 0);
	            var startAngle = shape.startAngle;
	            var endAngle = shape.endAngle;
	            var clockwise = shape.clockwise;
	
	            var unitX = Math.cos(startAngle);
	            var unitY = Math.sin(startAngle);
	
	            ctx.moveTo(unitX * r + x, unitY * r + y);
	            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newR = Number(shape.r * scaleRatio);
	            if (ifParse) {
	                newR = parseInt(newR, 10);
	            }
	            // 按比例缩放
	            this.setShape({
	                r: newR
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 星形<br>
	 * @class fishTopoFlow.node.Star
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"));
	 *       var star = new node.Star({
	 *           shape: {n:7, r:30},  //r半径 n几个角
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(star);
	 */
	
	    var PI = Math.PI;
	
	    var cos = Math.cos;
	    var sin = Math.sin;
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Star',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.n=3 几个角。
	         * @cfg {Number} shape.r=0 外半径。
	         * @cfg {Number} shape.r0=0 内半径。
	         */
	        shape: {
	            cx: 0,
	            cy: 0,
	            n: 3,
	            r0: null,
	            r: 0
	        },
	
	        buildPath: function (ctx, shape) {
	
	            var n = shape.n;
	            if (!n || n < 2) {
	                return;
	            }
	
	            var x = shape.cx;
	            var y = shape.cy;
	            var r = shape.r;
	            var r0 = shape.r0;
	
	            // 如果未指定内部顶点外接圆半径，则自动计算
	            if (r0 == null) {
	                r0 = n > 4
	                    // 相隔的外部顶点的连线的交点，
	                    // 被取为内部交点，以此计算r0
	                    ? r * cos(2 * PI / n) / cos(PI / n)
	                    // 二三四角星的特殊处理
	                    : r / 3;
	            }
	
	            var dStep = PI / n;
	            var deg = -PI / 2;
	            var xStart = x + r * cos(deg);
	            var yStart = y + r * sin(deg);
	            deg += dStep;
	
	            // 记录边界点，用于判断inside
	            ctx.moveTo(xStart, yStart);
	            for (var i = 0, end = n * 2 - 1, ri; i < end; i++) {
	                ri = i % 2 === 0 ? r0 : r;
	                ctx.lineTo(x + ri * cos(deg), y + ri * sin(deg));
	                deg += dStep;
	            }
	
	            ctx.closePath();
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newR = Number(shape.r * scaleRatio);
	            if (ifParse) {
	                newR = parseInt(newR, 10);
	            }
	            // 按比例缩放
	            this.setShape({
	                r: newR
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 旋轮曲线<br>
	 * @class fishTopoFlow.node.Trochoid
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"));
	 *       var trochoid = new node.Trochoid({
	 *           shape: {r:50, r0:35, d:30, location:null},  //r半径 n几个角
	 *           position:[60,60],
	 *           tooltip: "旋轮曲线"
	 *       });
	 *       fishTopo.add(trochoid);
	 */
	
	
	    var cos = Math.cos;
	    var sin = Math.sin;
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Trochoid',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.r=0 外半径。
	         * @cfg {Number} shape.r0=0 内半径。
	         * @cfg {Number} shape.d=0
	         * @cfg {Number} shape.location='out'
	         */
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: 0,
	            r0: 0,
	            d: 0,
	            location: 'out'
	        },
	
	        style: {
	            stroke: '#000',
	
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            var x1;
	            var y1;
	            var x2;
	            var y2;
	            var R = shape.r;
	            var r = shape.r0;
	            var d = shape.d;
	            var offsetX = shape.cx;
	            var offsetY = shape.cy;
	            var delta = shape.location == 'out' ? 1 : -1;
	
	            if (shape.location && R <= r) {
	                return;
	            }
	
	            var num = 0;
	            var i = 1;
	            var theta;
	
	            x1 = (R + delta * r) * cos(0)
	                - delta * d * cos(0) + offsetX;
	            y1 = (R + delta * r) * sin(0)
	                - d * sin(0) + offsetY;
	
	            ctx.moveTo(x1, y1);
	
	            // 计算结束时的i
	            do {
	                num++;
	            }
	            while ((r * num) % (R + delta * r) !== 0);
	
	            do {
	                theta = Math.PI / 180 * i;
	                x2 = (R + delta * r) * cos(theta)
	                     - delta * d * cos((R / r +  delta) * theta)
	                     + offsetX;
	                y2 = (R + delta * r) * sin(theta)
	                     - d * sin((R / r + delta) * theta)
	                     + offsetY;
	                ctx.lineTo(x2, y2);
	                i++;
	            }
	            while (i <= (r * num) / (R + delta * r) * 360);
	
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newR = Number(shape.r * scaleRatio);
	            var newR0 = Number(shape.r0 * scaleRatio);
	            var newD = Number(shape.d * scaleRatio);
	            newR = parseInt(newR, 10);
	            newR0 = parseInt(newR0, 10);
	            newD = parseInt(newD, 10);
	            // 按比例缩放
	            this.setShape({
	                r: newR,
	                r0: newR0,
	                d: newD
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 路径<br>
	 * @class fishTopoFlow.node.Path
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var path = new node.Path({
	 *           pathData: 'M9 0l8 8-17 17 7 7 17-17 8 8v-23h-23z',
	 *           rect: {x:0,y:0,width:30,height:30},
	 *           position: [60,60]
	 *       });
	 *       fishTopo.add(path);
	 */
	
	    var pathTool = __webpack_require__(6);
	    var Draggable = __webpack_require__(43);
	    var zrUtil = __webpack_require__(5);
	    var flowNode = __webpack_require__(96);
	
	    function ZPath(opts) {
	        /**
	         * @cfg {Object} options 参数
	         * @cfg {String} options.pathData path数据。
	         * @cfg {Object} options.rect 图形的大小。
	         * @cfg {Object} options.rect.width 图形的宽度。
	         * @cfg {Object} options.rect.height 图形的高度。
	         * @cfg {Number} [options.layout=null] 默认为null  仅支持"center"
	         *
	         */
	        var defaultOptions = {
	            style:{ fill: 'none',stroke: '#2c2c2c'},
	            rect:{x:0,y:0,width:0,height:0},
	            rectHover: true
	        }
	
	        var pathData = opts.pathData;
	        var model = flowNode.genModel("Path", opts);
	        delete opts.pathData;
	        this.options = zrUtil.merge(defaultOptions, opts, true);
	        var path = pathTool.createFromString(pathData, this.options);
	        path.model = model;
	        Draggable.call(path);
	        var boundingRect = path.getBoundingRect();
	        var rect = this.options.rect;
	        var layout = opts.layout;
	        if (rect) {
	            var aspect = boundingRect.width / boundingRect.height;
	
	            if (layout === 'center') {
	                // Set rect to center, keep width / height ratio.
	                var width = rect.height * aspect;
	                var height;
	                if (width <= rect.width) {
	                    height = rect.height;
	                }
	                else {
	                    width = rect.width;
	                    height = width / aspect;
	                }
	                var cx = rect.x + rect.width / 2;
	                var cy = rect.y + rect.height / 2;
	
	                rect.x = cx - width / 2;
	                rect.y = cy - height / 2;
	                rect.width = width;
	                rect.height = height;
	            }
	
	            this.resizePath(path, rect);
	        }
	        path.type = 'ZPath';
	        return path;
	    }
	
	    ZPath.prototype = {
	
	        constructor: ZPath,
	
	        type: 'ZPath',
	        /**
	         * Resize a path to fit the rect
	         */
	        resizePath: function (path, rect) {
	                if (!path.applyTransform) {
	                    return;
	                }
	
	                var pathRect = path.getBoundingRect();
	
	                var m = pathRect.calculateTransform(rect);
	
	                path.applyTransform(m);
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var rect = this.rect;
	            var newW = Number(rect.width * scaleRatio);
	            var newH = Number(newW * rect.height / rect.width);
	            if (ifParse) {
	                newW = parseInt(newW, 10);
	                newH = parseInt(newH, 10);
	            }
	            rect.width = newW;
	            rect.height = newH;
	            // 按比例缩放
	            this.attr('rect', rect);
	        }
	    }
	    zrUtil.inherits(ZPath, Draggable);
	    module.exports = ZPath;
	
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 图形按钮<br>
	 * @class fishTopoFlow.node.IconButton
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var iconButton   = new node.IconButton({
	 *          title:'IconButton',
	 *          icon:'path://M432.45,595.444c0,2.177-4.661,6.82-11.305,6.82c-6.475,0-11.306-4.567-11.306-6.82s4.852-6.812,11.306-6.812C427.841,588.632,432.452,593.191,432.45,595.444L432.45,595.444z M421.155,589.876c-3.009,0-5.448,2.495-5.448,5.572s2.439,5.572,5.448,5.572c3.01,0,5.449-2.495,5.449-5.572C426.604,592.371,424.165,589.876,421.155,589.876L421.155,589.876z M421.146,591.891c-1.916,0-3.47,1.589-3.47,3.549c0,1.959,1.554,3.548,3.47,3.548s3.469-1.589,3.469-3.548C424.614,593.479,423.062,591.891,421.146,591.891L421.146,591.891zM421.146,591.891',
	 *          itemSize:50,
	 *          position:[60,60]
	 *       });
	 *       fishTopo.add(iconButton);
	 */
	
	
	
	    var zrUtil = __webpack_require__(5);
	    var graphic = __webpack_require__(4);
	    var flowNode = __webpack_require__(96);
	
	    function IconButton(opts) {
	
	        /**
	         * @cfg {Object} options 构造参数
	         * @cfg {String} options.title="" 鼠标移上去显示的文字
	         * @cfg {String} options.icon="" Icon 的 path 字符串，支持使用自定义的 svg path 作为 icon，格式参见 [SVG PathData](https://www.w3.org/TR/SVG/paths.html#PathData)。可以从 Adobe Illustrator 等工具编辑导出。
	         * @cfg {Number} options.itemSize=15  icon 的大小
	         * @cfg {Object} options.iconStyle  图标样式
	         * @cfg {Object} options.iconStyle.normal 正常的样式
	         * @cfg {Number} options.iconStyle.normal.stroke='#666' 正常的样式（描边色）
	         * @cfg {Number} options.iconStyle.normal.fill='none' 正常的样式（填充色）
	         * @cfg {Object} options.iconStyle.emphasis 高亮状态下的样式
	         * @cfg {Number} options.iconStyle.emphasis.stroke='#666' 高亮状态下的样式（描边色）
	         * @cfg {Number} options.iconStyle.emphasis.fill='none' 高亮状态下的样式（填充色）
	         */
	        var defaultOptions = {
	            backgroundColor: 'transparent',
	            borderColor: '#ccc',
	            draggable:false,
	            selectable:false,
	            borderWidth: 0,
	            itemSize: 15,
	            showTitle: true,
	            icon:"",  //Icon 的 path 字符串，支持使用自定义的 svg path 作为 icon，格式参见 SVG PathData。可以从 Adobe Illustrator 等工具编辑导出。
	            iconStyle: {
	                normal: {
	                    stroke: '#666',
	                    fill: 'none'
	                },
	                emphasis: {
	                    stroke: '#3E98c5'
	                }
	            }
	        };
	        this.options = zrUtil.merge(defaultOptions, opts, true);
	
	        this.model = flowNode.genModel("IconButton", this.options);
	        graphic.Group.call(this, this.options);
	        this.render();
	    }
	    IconButton.prototype = {
	        constructor: IconButton,
	        type: "IconButton",
	        render: function () {
	            var normalStyle = this.options.iconStyle.normal;
	            var hoverStyle = this.options.iconStyle.emphasis;
	            var itemSize = this.options.itemSize;
	            var icon = this.options.icon;
	            var style = {
	                x: -itemSize / 2,
	                y: -itemSize / 2,
	                width: itemSize,
	                height: itemSize
	            };
	            var path = icon.indexOf('image://') === 0 ?
	                (
	                    style.image = icon.slice(8),
	                    new graphic.Image({
	                        style: style
	                    })
	                ) :
	                graphic.makePath(
	                    icon.replace('path://', ''), {
	                        style: normalStyle,
	                        hoverStyle: hoverStyle,
	                        rectHover: true
	                    },
	                    style,
	                    'center'
	                );
	
	            graphic.setHoverStyle(path);
	
	            if (this.options.showTitle) {
	                path.__title = this.options.title;
	                path.on('mouseover', function () {
	                        // Should not reuse above hoverStyle, which might be modified.
	                        path.setStyle({
	                            text: this.options.title,
	                            textPosition: hoverStyle.textPosition || 'bottom',
	                            textFill: hoverStyle.fill || hoverStyle.stroke || '#000',
	                            textAlign: hoverStyle.textAlign || 'center'
	                        });
	                    }.bind(this))
	                    .on('mouseout', function () {
	                        path.setStyle({
	                            textFill: null
	                        });
	                    });
	            }
	
	            path.trigger('normal');
	            this.add(path);
	        }
	    }
	
	    zrUtil.inherits(IconButton, graphic.Group);
	    module.exports = IconButton;
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * fishTopoFlow的link对象，框架提供的连线都放在这个对象下。
	 * @class fishTopoFlow.link
	 * @abstract
	 */
	
	    var Link = __webpack_require__(118);
	    var Fold = __webpack_require__(120);
	    var Curve = __webpack_require__(121);
	    var Chain = __webpack_require__(122);
	    var Connector = __webpack_require__(82);
	    var flowLink = {};
	    flowLink.Link = flowLink[Connector.TYPE_STRAIGHT] = Link;
	    flowLink.Fold = flowLink[Connector.TYPE_JAGGED] = Fold;
	    flowLink.Curve = flowLink[Connector.TYPE_CURVE] = Curve;
	    flowLink.Chain = flowLink[Connector.TYPE_CHAIN] = Chain;
	    module.exports = flowLink;
	
	
	/**
	 * @method constructor
	 * 连线的构造函数
	 * @param  {Object} startNode 开始节点
	 * @param  {Object} endNode   结束节点
	 * @param  {Object} options 线段选项
	 * @param {Object} [options.style] 节点的样式
	 * @param {Number} [options.style.lineWidth=1] 线段的宽度
	 * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'
	 * @param {String} [options.style.stroke="#000000"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'
	 * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]
	 * @param {Object} [options.symbol] 线段的箭头
	 * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	 * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸
	 * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色
	 * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]
	 * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]
	 * @param {Number} [options.symbol.offset] 设置箭头在连线上的偏移量，默认是0；此属性只针对直线和折线类型有效，如果是折线，offset最大值不能超过options.bundleOffset(默认是30)设置的值 since V2.3.0
	 * @param {Object} [options.text] 线段上的文字
	 * @param {String} [options.text.text] 线段上的文字内容
	 * @param {String} [options.text.color] 线段上的文字颜色
	 * @param {String} [options.text.textFont] 线段上的文字字体
	 * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center
	 * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]
	 * @param {Boolean} [options.text.textRotateable] 文字随线段旋转, 默认值为true
	 * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	 * @param {String} [options.position] 指定线段位置
	 * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	 * @param {Object} [options.position.startOffset] 线段开始位置的偏移
	 * @param {Object} [options.position.endOffset] 线段结束位置的偏移
	 * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]
	 * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom
	 * @param {Object} [options.effect] 线上动态效果
	 * @param {String} [options.effect.show] 是否显示箭头动效
	 * @param {Number} [options.effect.period] 动效移动速度
	 * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase
	 * @param {Number} [options.z] 连线的层级，越大越在前面显示
	 * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)
	 * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)
	 * @return {Object} 返回创建成功的连线对象
	 */
	
	
	/**
	 * @method setStyle
	 * 创建连线后，设置连线的样式
	 * @param {Object} options 对应创建节点，传递的options参数
	 * @param {Object} [options.text] 连线文字的样式
	 * @param {Object} [options.symbol] 连线箭头的样式
	 * @param {String} [options.color] 连线的颜色
	 */
	/**
	 * @method on
	 * 绑定事件
	 * @param {String} event 事件名
	 * @param {Function} handler 事件处理函数
	 * @param {Object} [context] 上下文
	 */
	
	/**
	 * @method off
	 * 解绑事件
	 * @param {String} event 事件名
	 * @param {Function} handler 事件处理函数
	 */
	
	/**
	 * @method one
	 * 单次触发绑定,trigger后销毁
	 * @param {String} event 事件名
	 * @param {Function} handler 事件处理函数
	 * @param {Object} [context] 上下文
	 */
	
	/**
	 * @method trigger
	 * 事件分发
	 * @param {String} type 事件类型
	 */
	/**
	 * @event click
	 * 单击事件
	 *
	 * <pre>
	 * flink.on('Connector:click', function(e) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	/**
	 * @event dblclick
	 * 当双击元素时，会发生 dblclick 事件。
	 *
	 * <pre>
	 * flink.on('Connector:dblclick', function(e) {
	 *   //do something
	 * })
	 * </pre>
	 */


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 直线<br>
	 * @class fishTopoFlow.link.Link
	 * @extends fishTopoFlow.link
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var link = fishTopoFlow.link;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       //节点
	 *       function newNode(x, y, w, h) {
	 *           var rect = new node.Rect({
	 *               shape: {width: w,height: h},
	 *               position: [x, y],
	 *               style: {fill: "#167CFF"}
	 *           });
	 *           fishTopo.add(rect);
	 *           return rect;
	 *       }
	 *       //简单连线
	 *       function newLink(startNode, endNode, text, dashedPattern) {
	 *           var slink = new link.Link(startNode, endNode, {
	 *               style: {lineDash: [dashedPattern]},
	 *               text: {text: text}
	 *           })
	 *           fishTopo.add(slink);
	 *           return slink;
	 *       }
	 *       var from = newNode(100, 60, 30, 30);
	 *       var to = newNode(300, 60, 30, 30);
	 *       newLink(from, to, '虚线带箭头', 5);
	 */
	
	    var Connector = __webpack_require__(82);
	    var Flow = __webpack_require__(119);
	
	    function Link(startNode,endNode,options) {
	        var opt = Flow.translateLinkOptions(options);
	        //默认就是直线
	        var connector = new Connector(opt);
	        connector.startNode = startNode;
	        connector.endNode = endNode;
	
	        return connector;
	    }
	    /**
	     * @method createByPoint
	     * 用户指定连线的点，来进行画线
	     * @param  {Object} options 线段选项
	     * @param {Object} [options.style] 节点的样式
	     * @param {Number} [options.style.lineWidth=1] 线段的宽度
	     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'
	     * @param {String} [options.style.stroke="#000000"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'
	     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]
	     * @param {Object} [options.symbol] 线段的箭头
	     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸
	     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色
	     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]
	     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]
	     * @param {Number} [options.symbol.offset] 设置箭头在连线上的偏移量，默认是0 since V2.3.0
	     * @param {Object} [options.text] 线段上的文字
	     * @param {String} [options.text.text] 线段上的文字内容
	     * @param {String} [options.text.textFill] 线段上的文字颜色
	     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center
	     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]
	     * @param {Boolean} [options.text.textRotateable] 文字随线段旋转, 默认值为true
	     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {String} [options.position] 指定线段位置
	     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {Object} [options.position.startOffset] 线段开始位置的偏移[x,y]   eg. startOffset:[0,10] 在x上偏移0 y上偏移10
	     * @param {Object} [options.position.endOffset] 线段结束位置的偏移[x,y]   eg. startOffset:[0,10] 在x上偏移0 y上偏移10
	     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]
	     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom
	     * @param {Object} [options.effect] 线上动态效果
	     * @param {String} [options.effect.show] 是否显示箭头动效
	     * @param {Number} [options.effect.period] 动效移动速度
	     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase
	     * @param {Number} [options.z] 连线的层级，越大越在前面显示
	     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)
	     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)
	     */
	    Link.createByPoint = function(options) {
	        var opt = Flow.translateLinkOptions(options);
	        //默认就是直线
	        var connector = new Connector(opt);
	        return connector;
	    }
	
	    module.exports = Link;
	
	


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Flow静态方法类
	 * @class fish.topo.FishTopoFlow.Flow
	 */
	
	
	    var Constants = __webpack_require__(93);
	    var GroupNode = __webpack_require__(95);
	    var util = __webpack_require__(65);
	    var Flow = {
	        FLOW_TYPE: "elementType",
	        LINK: "connection",
	        RECT: "Rect",
	        Group: 'Group',
	        IMAGE: 'Image',
	        TEXT: 'Text',
	        CIRCLE: 'Circle',
	        SECTOR: 'Sector',
	        RING: 'Ring',
	        POLYGON: 'Polygon',
	        POLYLINE: 'Polyline',
	        LINE: 'Line',
	        BEZIERCURVE: 'Beziercurve',
	        ARC: 'Arc',
	        SCENE:'scene',
	
	        /**
	         * @method setUserData
	         * 设置用户数据
	         * @param {Object} node 需要设置数据的节点
	         * @param {Object} obj 数据
	         * **使用范例**：
	         *
	         *      @example
	         *      //设置自定义数据
	         *      this.fishTopo.Flow.setUserData(rect, { customObj: "rect" });
	         */
	        setUserData: function(node, obj) {
	            node.model.set(Constants.USERDATA, obj);
	        },
	        /**
	         * 获取设置的用户数据
	         * @param {Object} node 需要获取数据的节点
	         * @return {String}      数据
	         * **使用范例**：
	         *
	         *      @example
	         *      //获取自定义数据
	         *      this.fishTopo.Flow.getUserData(rect);
	         */
	        getUserData: function(node) {
	            var userData = node.model.get(Constants.USERDATA);
	            if (util.isUndefined(userData)) {
	                userData = {};
	            }
	            return userData;
	        },
	        /**
	         * 判断是否是连线
	         * @param {Object} model 对象的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是连线
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isLink(nodeModel)) { return true;}
	         */
	        isLink: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return elementType == Flow.LINK;
	        },
	        /**
	         * 判断是否是节点
	         * @param {Object} model 对象的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是节点
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isNode(nodeModel)) { return true;}
	         */
	
	        isNode: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            var isNode;
	            if(elementType !=  Flow.LINK && elementType !=  Flow.SCENE){
	                isNode = true;
	            }else{
	                isNode = false;
	            }
	            return isNode;
	        },
	
	        isInGroup: function(node) {
	            return node.parent && node.parent instanceof GroupNode;
	        },
	
	        isGroupNode: function(node) {
	            return node instanceof GroupNode;
	        },
	
	        /**
	         * 判断节点是否是矩形节点
	         * @param {Object} model 节点的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是矩形节点
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isRect(nodeModel)) { return true;}
	         */
	        isRect: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return  elementType == Flow.RECT;
	        },
	        /**
	         * 判断节点是否是图片节点
	         * @param {Object} model 节点的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是图片节点
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isImage(nodeModel)) { return true;}
	         */
	        isImage: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return elementType == Flow.IMAGE;
	        },
	        /**
	         * 判断节点是否是文字节点
	         * @param {Object} model 节点的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是文字节点
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isText(nodeModel)) { return true;}
	         */
	        isText: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return elementType == Flow.TEXT;
	        },
	        /**
	         * 判断节点是否是圆形节点
	         * @param {Object} model 节点的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是圆形节点
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isCircle(nodeModel)) { return true;}
	         */
	        isCircle: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return elementType == Flow.CIRCLE;
	        },
	        /**
	         * 获取节点的类型
	         * @param {Object} model 节点的model
	         * **使用范例**：
	         *
	         *      @example
	         *      //获取节点类型
	         *      var nodeModel = e.target.model;
	         *      return this.fishTopo.Flow.getType(nodeModel);
	         */
	        getType: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return elementType;
	        },
	        translateLinkOptions: function(options) {
	            if (options) {
	                if (options.pos) {
	                    var arrPos = options.pos.split(",");
	                    if (arrPos.length >= 2) {
	                        if (!options.position) {
	                            options.position = {};
	                        }
	                        options.position.startPos = arrPos[0];
	                        options.position.endPos = arrPos[1];
	                    }
	                }
	                if (options.text && options.text.color) {
	                    options.text.textFill = options.text.color;
	                }
	            }
	            return options;
	        }
	    };
	
	    module.exports = Flow;
	


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 折线<br>
	 * @class fishTopoFlow.link.Fold
	 * @extends fishTopoFlow.link
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var link = fishTopoFlow.link;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       //节点
	 *       function newNode(x, y, w, h) {
	 *           var rect = new node.Rect({
	 *               shape: {width: w,height: h},
	 *               position: [x, y],
	 *               style: {fill: "#167CFF"}
	 *           });
	 *           fishTopo.add(rect);
	 *           return rect;
	 *       }
	 *       //折线
	 *       function newFoldLink(startNode, endNode, text, direction, dashedPattern) {
	 *           var flink = new link.Fold(startNode, endNode, {
	 *               style: {lineDash: [dashedPattern]},
	 *               text: {text: text},
	 *               pos: direction
	 *           })
	 *           fishTopo.add(flink);
	 *           return flink;
	 *       }
	 *       var from = newNode(100, 40, 30, 30);
	 *       var to = newNode(300, 80, 30, 30);
	 *       newFoldLink(from, to, '折线');
	 */
	
	    var Connector = __webpack_require__(82);
	    var zrUtil = __webpack_require__(5);
	    var Flow = __webpack_require__(119);
	
	    function Fold(startNode,endNode,options) {
	        //折线
	        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_JAGGED}}, options, true);
	        opt = Flow.translateLinkOptions(opt);
	        var connector = new Connector(opt);
	        connector.startNode = startNode;
	        connector.endNode = endNode;
	
	        return connector;
	    }
	
	    /**
	     * @method createByPoint
	     * 用户指定连线的点，来进行画线
	     * @param  {Object} options 线段选项
	     * @param {Object} [options.style] 节点的样式
	     * @param {Number} [options.style.lineWidth=1] 线段的宽度
	     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'
	     * @param {String} [options.style.stroke="#000000"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'
	     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]
	     * @param {Object} [options.symbol] 线段的箭头
	     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸
	     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色
	     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]
	     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]
	     * @param {Number} [options.symbol.offset] 设置箭头在连线上的偏移量，默认是0；offset最大值不能超过options.bundleOffset(默认30) 设置的值 since V2.3.0
	     * @param {Object} [options.text] 线段上的文字
	     * @param {String} [options.text.text] 线段上的文字内容
	     * @param {String} [options.text.color] 线段上的文字颜色
	     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center
	     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]
	     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {String} [options.position] 指定线段位置
	     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {Object} [options.position.startOffset] 线段开始位置的偏移
	     * @param {Object} [options.position.endOffset] 线段结束位置的偏移
	     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]
	     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom
	     * @param {Object} [options.effect] 线上动态效果
	     * @param {String} [options.effect.show] 是否显示箭头动效
	     * @param {Number} [options.effect.period] 动效移动速度
	     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase
	     * @param {Number} [options.z] 连线的层级，越大越在前面显示
	     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)
	     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)
	     */
	    Fold.createByPoint = function(options) {
	        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_JAGGED}}, options, true);
	        opt = Flow.translateLinkOptions(opt);
	        var connector = new Connector(opt);
	        return connector;
	    }
	    module.exports = Fold;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 曲线<br>
	 * @class fishTopoFlow.link.Curve
	 * @extends fishTopoFlow.link
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var link = fishTopoFlow.link;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       //节点
	 *       function newNode(x, y, w, h) {
	 *           var rect = new node.Rect({
	 *               shape: {width: w,height: h},
	 *               position: [x, y],
	 *               style: {fill: "#167CFF"}
	 *           });
	 *           fishTopo.add(rect);
	 *           return rect;
	 *       }
	 *       //曲线
	 *       function newCurveLink(startNode, endNode, text, direction, dashedPattern) {
	 *           var clink = new link.Curve(startNode, endNode, {
	 *               style: {lineDash: [dashedPattern]},
	 *               text: {text: text},
	 *               pos: direction
	 *           })
	 *           fishTopo.add(clink);
	 *           return clink;
	 *       }
	 *       var from = newNode(100, 40, 30, 30);
	 *       var to = newNode(300, 80, 30, 30);
	 *       newCurveLink(from, to, '曲线');
	 */
	
	    var Connector = __webpack_require__(82);
	    var zrUtil = __webpack_require__(5);
	    var Flow = __webpack_require__(119);
	    function Curve(startNode,endNode,options) {
	        //曲线
	        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_CURVE}}, options, true);
	        opt = Flow.translateLinkOptions(opt);
	
	        var connector = new Connector(opt);
	        connector.startNode = startNode;
	        connector.endNode = endNode;
	
	        return connector;
	    }
	    /**
	     * @method createByPoint
	     * 用户指定连线的点，来进行画线
	     * @param  {Object} options 线段选项
	     * @param {Object} [options.style] 节点的样式
	     * @param {Number} [options.style.lineWidth=1] 线段的宽度
	     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'
	     * @param {String} [options.style.stroke="#000000"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'
	     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]
	     * @param {Object} [options.symbol] 线段的箭头
	     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸
	     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色
	     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]
	     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]
	     * @param {Object} [options.text] 线段上的文字
	     * @param {String} [options.text.text] 线段上的文字内容
	     * @param {String} [options.text.color] 线段上的文字颜色
	     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center
	     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]
	     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {String} [options.position] 指定线段位置
	     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {Object} [options.position.startOffset] 线段开始位置的偏移
	     * @param {Object} [options.position.endOffset] 线段结束位置的偏移
	     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]
	     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom
	     * @param {Object} [options.effect] 线上动态效果
	     * @param {String} [options.effect.show] 是否显示箭头动效
	     * @param {Number} [options.effect.period] 动效移动速度
	     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase
	     * @param {Number} [options.z] 连线的层级，越大越在前面显示
	     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)
	     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)
	     */
	    Curve.createByPoint = function(options) {
	        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_CURVE}}, options, true);
	        opt = Flow.translateLinkOptions(opt);
	        var connector = new Connector(opt);
	        return connector;
	    }
	    module.exports = Curve;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 链路 支持线上多文本展示， 最大的不同是text.text对象为数组类型，表示多个文本的数据。数组元素可以为字符串，表示每个文本的名字；也可以是个对象，对象中必须指定text属性，其值为文本的名字，其余属性则为业务侧自定义的<br>
	 * @class fishTopoFlow.link.Chain
	 * @extends fishTopoFlow.link
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var link = fishTopoFlow.link;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       //节点
	 *       function newNode(x, y, w, h) {
	 *           var rect = new node.Rect({
	 *               shape: {width: w,height: h},
	 *               position: [x, y],
	 *               style: {fill: "#167CFF"}
	 *           });
	 *           fishTopo.add(rect);
	 *           return rect;
	 *       }
	 *       //节点间链路
	 *       function newChain(startNode, endNode, text, dashedPattern) {
	 *           var slink = new link.Chain(startNode, endNode, {
	 *               style: {lineDash: [dashedPattern]},
	 *               text: {text: text}
	 *           })
	 *           fishTopo.add(slink);
	 *           return slink;
	 *       }
	 *       var from = newNode(100, 60, 30, 30);
	 *       var to = newNode(300, 60, 30, 30);
	 *       newChain(from, to, [{text: '倾斜文本1', linkId: 100}, {text: '倾斜文本2', linkId: 111}, {text: '倾斜文本3', linkId: 112}], 5);
	 */
	
	    var Connector = __webpack_require__(82);
	    var Flow = __webpack_require__(119);
	
	    function Chain(startNode,endNode,options) {
	        options.style.lineType = Connector.TYPE_CHAIN
	        var opt = Flow.translateLinkOptions(options);
	        var connector = new Connector(opt);
	        connector.startNode = startNode;
	        connector.endNode = endNode;
	
	        return connector;
	    }
	    /**
	     * @method createByPoint
	     * 用户指定连线的点，来进行画线
	     * @param  {Object} options 线段选项
	     * @param {Object} [options.style] 节点的样式
	     * @param {Number} [options.style.lineWidth=1] 线段的宽度
	     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'
	     * @param {String} [options.style.stroke="#000000"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'
	     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]
	     * @param {Object} [options.symbol] 线段的箭头
	     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸
	     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色
	     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]
	     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]
	     * @param {Number} [options.symbol.offset] 设置箭头在连线上的偏移量，默认是0 since V2.3.0
	     * @param {Object} [options.text] 线段上的文字
	     * @param {Object} [options.text.text] 为数组类型，表示多个文本的数据。数组元素可以为字符串，表示每个文本的名字；也可以是个对象，对象中必须指定text属性，其值为文本的名字，其余属性则为业务侧自定义的
	     * @param {String} [options.text.color] 线段上的文字颜色
	     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center
	     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]
	     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {String} [options.position] 指定线段位置
	     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {Object} [options.position.startOffset] 线段开始位置的偏移[x,y]   eg. startOffset:[0,10] 在x上偏移0 y上偏移10
	     * @param {Object} [options.position.endOffset] 线段结束位置的偏移[x,y]   eg. startOffset:[0,10] 在x上偏移0 y上偏移10
	     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]
	     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom
	     * @param {Object} [options.effect] 线上动态效果
	     * @param {String} [options.effect.show] 是否显示箭头动效
	     * @param {Number} [options.effect.period] 动效移动速度
	     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase
	     * @param {Number} [options.z] 连线的层级，越大越在前面显示
	     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)
	     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)
	     */
	    Chain.createByPoint = function(options) {
	        var opt = Flow.translateLinkOptions(options);
	        var connector = new Connector(opt);
	        return connector;
	    }
	
	    module.exports = Chain;
	
	


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 连线操作类
	 * @author miao.cunzhi
	 */
	
	    var symbolUtil = __webpack_require__(83);
	    var zrUtil = __webpack_require__(5);
	    var icon = __webpack_require__(89);
	    function LineOperationManager(connectionManager, api) {
	        this.lineOperations = [],
	        this.isEdit = true;
	        this.connectionManager = connectionManager;
	        this._api = api;
	    }
	
	    /**
	     *  this.lineOperationManager.addIcon(key, options);
	     */
	    LineOperationManager.prototype.addIcon = function(key, options) {
	        //判断是小图标否存在 ，存在则直接返回
	        var lineOperationIcon = zrUtil.find(options.lineNode.icons, function(icon) {
	            return icon.key === key;
	        });
	
	        if (lineOperationIcon) {
	            this.bindOperation(options.lineNode);
	            return;
	        }else {
	            var lineOperation = this.creatOperation(key, options);
	            this._api._getParentZr().add(lineOperation);
	            this.bindOperation(options.lineNode);
	            return lineOperation;
	        }
	    }
	
	
	    LineOperationManager.prototype.creatOperation = function(key, options) {
	        var lineOperation = symbolUtil.createSymbol(options.iconPath, 0, 0, options.width || 15, options.height || 15, 0, options.color||'#aaaaac');
	        lineOperation.key = key;
	        lineOperation._width =  options.width || 15;  // path情况下无法计算
	        lineOperation._isLineOperationIcon = true;
	        lineOperation.hide();
	        options.lineNode.icons.push(lineOperation);
	        this.lineOperations.push(lineOperation);
	
	        //小图标 点击事件  如果有回调则调用回调，否则派发事件
	        lineOperation.on("click", function(event) {
	            if (options.callback) {
	                event.data = options;
	                event.lineNode = options.lineNode;
	                options.callback(event);
	            } else {
	                var params = {};
	                params.event = event;
	                params.type = "click";
	                params.elementType = "LineOperationIcon";
	                this._api.trigger(params.type, params);
	            }
	        }.bind(this));
	        return lineOperation;
	    }
	
	    /**
	     * 计算小图标的位置，并显示
	     * @param  {[type]} connector [description]
	     * @return {[type]}           [description]
	     */
	    LineOperationManager.prototype.bindOperation = function(connector) {
	        function parentX(node) {
	            if (node.parent && node.parent.nodeType == "SubProcess") {
	                return node.position[0] + parentX(node.parent)
	            } else {
	                return node.position[0]
	            }
	        }
	    
	        function parentY(node) {
	            if (node.parent && node.parent.nodeType == "SubProcess") {
	                return node.position[1] + parentY(node.parent)
	            } else {
	                return node.position[1]
	            }
	        }
	
	        if (this.isEdit == false) {
	            return;
	        }
	        var pointPosition = connector.middle(), posX, posY;
	        if (connector.parent && connector.parent.nodeType == "SubProcess") {
	            posX = pointPosition[0] + parentX(connector.parent);
	            posY = pointPosition[1] + parentY(connector.parent);
	        } else {
	            posX = pointPosition[0];
	            posY = pointPosition[1];
	        }
	
	        var arrLength = zrUtil.map(connector.icons, function(icon) {
	            return icon._width;
	        });
	
	        var totalLength = zrUtil.reduce(arrLength, function(previousValue,currentValue) {
	            return previousValue + currentValue + 10;
	        }, 0 );
	
	        zrUtil.each(connector.icons, function(icon, index) {
	            var connectorPosition = 0;
	            for (var k = 0; k < index; k++) {
	                connectorPosition += arrLength[k] + 10;
	            }
	            icon.attr("position", [posX + connectorPosition - totalLength / 2, posY + 5]);
	            icon.show();
	            icon.attachLine = connector;
	        })
	    }
	
	    LineOperationManager.prototype.hideAllLineOperation = function() {
	        zrUtil.each(this.lineOperations, function(lineOperation) {
	            lineOperation.hide();
	        });
	    }
	
	    LineOperationManager.prototype.addDeleteIcon = function(lineNode,options) {
	        var opts = zrUtil.defaults({
	            iconPath: 'path://' + icon.DEL_SVG,
	            width: 12,
	            height: 14,
	            lineNode: lineNode,
	            callback: function(e) {
	                this._api.remove(e.target.attachLine);//this.connectionManager.selConnector);
	            }.bind(this)
	        }, options,true);
	
	        this.addIcon("delete", opts);
	    }
	
	    LineOperationManager.prototype.addChangeLineTypeIcon = function(lineNode,options) {
	        var opts = zrUtil.defaults({
	            iconPath: 'path://' + icon.CHANGE_LINE_TYPE_SVG,
	            width: 15,
	            height: 15,
	            lineNode: lineNode,
	            callback: function () {
	                this._api.changeSelectConnectorType();
	            }.bind(this)
	        }, options,true);
	
	        this.addIcon("change", opts)
	    }
	
	    module.exports = LineOperationManager;
	


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * fishTopoFlow的layout对象，框架提供的布局都放在这个对象下。通过addCustomLayout方法添加自定义布局
	 * @class fishTopoFlow.layout
	 * @abstract
	 */
	
	    var BoundingRect = __webpack_require__(27);
	    var zrUtil = __webpack_require__(5);
	    var flowUtil = __webpack_require__(94);
	    var HLayout = __webpack_require__(125);
	    var VLayout = __webpack_require__(126);
	    var TreeLayout = __webpack_require__(127);
	    var ForceLayout = __webpack_require__(130);
	    var parsePercent = flowUtil.parsePercent;
	    var Tree = __webpack_require__(128);
	    var layout = {};
	    layout.HLayout = HLayout;
	    layout.VLayout = VLayout;
	    layout.TreeLayout = TreeLayout;
	    layout.ForceLayout = ForceLayout;
	    layout.Tree = Tree
	
	    /**
	     * @method addCustomLayout
	     * 添加自定义布局类
	     * @param {Object} customLayout 自定义布局的类
	     */
	    layout.addCustomLayout = function(customLayout) {
	        layout.customLayout = customLayout;
	    }
	
	
	    layout.getLayoutRect = function (positionInfo, containerRect, margin) {
	        margin = flowUtil.normalizeCssArray(margin || 0);
	
	        var containerWidth = containerRect.width;
	        var containerHeight = containerRect.height;
	
	        var left = parsePercent(positionInfo.left, containerWidth);
	        var top = parsePercent(positionInfo.top, containerHeight);
	        var right = parsePercent(positionInfo.right, containerWidth);
	        var bottom = parsePercent(positionInfo.bottom, containerHeight);
	        var width = parsePercent(positionInfo.width, containerWidth);
	        var height = parsePercent(positionInfo.height, containerHeight);
	
	        var verticalMargin = margin[2] + margin[0];
	        var horizontalMargin = margin[1] + margin[3];
	        var aspect = positionInfo.aspect;
	
	        // If width is not specified, calculate width from left and right
	        if (isNaN(width)) {
	            width = containerWidth - right - horizontalMargin - left;
	        }
	        if (isNaN(height)) {
	            height = containerHeight - bottom - verticalMargin - top;
	        }
	
	        // If width and height are not given
	        // 1. Graph should not exceeds the container
	        // 2. Aspect must be keeped
	        // 3. Graph should take the space as more as possible
	        if (isNaN(width) && isNaN(height)) {
	            if (aspect > containerWidth / containerHeight) {
	                width = containerWidth * 0.8;
	            }
	            else {
	                height = containerHeight * 0.8;
	            }
	        }
	
	        if (aspect != null) {
	            // Calculate width or height with given aspect
	            if (isNaN(width)) {
	                width = aspect * height;
	            }
	            if (isNaN(height)) {
	                height = width / aspect;
	            }
	        }
	
	        // If left is not specified, calculate left from right and width
	        if (isNaN(left)) {
	            left = containerWidth - right - width - horizontalMargin;
	        }
	        if (isNaN(top)) {
	            top = containerHeight - bottom - height - verticalMargin;
	        }
	
	        // Align left and top
	        switch (positionInfo.left || positionInfo.right) {
	            case 'center':
	                left = containerWidth / 2 - width / 2 - margin[3];
	                break;
	            case 'right':
	                left = containerWidth - width - horizontalMargin;
	                break;
	        }
	        switch (positionInfo.top || positionInfo.bottom) {
	            case 'middle':
	            case 'center':
	                top = containerHeight / 2 - height / 2 - margin[0];
	                break;
	            case 'bottom':
	                top = containerHeight - height - verticalMargin;
	                break;
	        }
	        // If something is wrong and left, top, width, height are calculated as NaN
	        left = left || 0;
	        top = top || 0;
	        if (isNaN(width)) {
	            // Width may be NaN if only one value is given except width
	            width = containerWidth - left - (right || 0);
	        }
	        if (isNaN(height)) {
	            // Height may be NaN if only one value is given except height
	            height = containerHeight - top - (bottom || 0);
	        }
	
	        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);
	        rect.margin = margin;
	        return rect;
	    };
	
	
	    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {
	        var h = !opt || !opt.hv || opt.hv[0];
	        var v = !opt || !opt.hv || opt.hv[1];
	        var boundingMode = opt && opt.boundingMode || 'all';
	
	        if (!h && !v) {
	            return;
	        }
	
	        var rect;
	        if (boundingMode === 'raw') {
	            rect = (el.type === 'group' || el.type === 'GroupNode')
	                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)
	                : el.getBoundingRect();
	        }
	        else {
	            rect = el.getBoundingRect();
	            if (el.needLocalTransform()) {
	                var transform = el.getLocalTransform();
	                // Notice: raw rect may be inner object of el,
	                // which should not be modified.
	                rect = rect.clone();
	                rect.applyTransform(transform);
	            }
	        }
	
	        positionInfo = layout.getLayoutRect(
	            zrUtil.defaults(
	                {width: rect.width, height: rect.height},
	                positionInfo
	            ),
	            containerRect,
	            margin
	        );
	
	        // Because 'tranlate' is the last step in transform
	        // (see zrender/core/Transformable#getLocalTransfrom),
	        // we can just only modify el.position to get final result.
	        var elPos = el.position;
	        var dx = h ? positionInfo.x - rect.x : 0;
	        var dy = v ? positionInfo.y - rect.y : 0;
	
	        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);
	    };
	
	
	    module.exports = layout;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 水平布局<br>
	 * @class fishTopoFlow.layout.HLayout
	 * @extends fishTopoFlow.layout
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var layout = fishTopoFlow.layout;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       function newNode(group,text) {
	 *           var rect = new node.Rect({
	 *                   shape:{width:25,height:25},
	 *                   style: {text:text,fill: "#167CFF"}
	 *               });
	 *           group.add(rect);
	 *           return rect;
	 *       }
	 *       var hGroup =  new node.Group({
	 *           style: {
	 *               text: "水平布局",
	 *               textPosition:"bottom"
	 *           },
	 *           position:[50,50],
	 *           layout : new layout.HLayout({gap:10})
	 *       });
	 *       newNode(hGroup, "A_1")
	 *       newNode(hGroup, "A_2");
	 *       newNode(hGroup, "A_3");
	 *       newNode(hGroup, "A_4");
	 *       newNode(hGroup, "A_5");
	 *       fishTopo.add(hGroup);
	 */
	
	            var zrUtil = __webpack_require__(5);
	             var Connector = __webpack_require__(82);
	            function HLayout(opts) {
	                /**
	                 * @cfg {Number} gap 节点之间的间隔
	                 */
	                /**
	                 * @cfg {Number} maxHeight=Infinity 组最大的宽度，如果超过会换行
	                 */
	                var defaultOptions = {
	                    gap: 5,
	                    maxWidth: Infinity
	                };
	                this.options = zrUtil.merge(defaultOptions, opts, true);
	            }
	            /**
	             * @method run
	             * 进行垂直布局，一般不需要调用，直接将布局类 赋值给组layout 属性即可
	             * @param {Object} group 需要进行垂直布局的组
	             */
	            HLayout.prototype.run = function(group)  {
	                var x = 0;
	                var y = 0;
	                var currentLineMaxSize = 0;
	                group.each(function (child, idx) {
	                    if (child instanceof Connector) {
	                        return;
	                    }
	
	                    var position = child.position;
	                    var rect = child.getBoundingRect();
	                    var nextChild = group.childAt(idx + 1);
	                    var nextChildRect = nextChild && nextChild.getBoundingRect();
	                    var nextX;
	
	                    var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);
	                    nextX = x + moveX;
	                    // Wrap when width exceeds maxWidth or meet a `newline` group
	                    if (nextX > this.options.maxWidth || child.newline) {
	                        x = 0;
	                        nextX = moveX;
	                        y += currentLineMaxSize + parseInt(this.options.gap,10);
	                        currentLineMaxSize = rect.height;
	                    } else {
	                        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
	                    }
	
	                    if (child.newline) {
	                        return;
	                    }
	
	                    position[0] = x;
	                    position[1] = y;
	                    x = nextX + this.options.gap;
	                },this);
	
	                return HLayout;
	            }
	        module.exports = HLayout;
	
	/**
	 * @method addCustomLayout
	 * @hide
	 */

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 垂直布局<br>
	 * @class fishTopoFlow.layout.VLayout
	 * @extends fishTopoFlow.layout
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var layout = fishTopoFlow.layout;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       function newNode(group,text) {
	 *           var rect = new node.Rect({
	 *                   shape:{width:25,height:25},
	 *                   style: {text:text,fill: "#167CFF"}
	 *               });
	 *           group.add(rect);
	 *           return rect;
	 *       }
	 *       var vGroup =  new node.Group({
	 *           style: {
	 *               text: "垂直布局",
	 *               textPosition:"bottom"
	 *           },
	 *           position:[60,60],
	 *           layout : new layout.VLayout({gap:10})
	 *       });
	*
	 *       newNode(vGroup, "A_1")
	 *       newNode(vGroup, "A_2");
	 *       newNode(vGroup, "A_3");
	 *       newNode(vGroup, "A_4");
	 *       newNode(vGroup, "A_5");
	 *       fishTopo.add(vGroup);
	 */
	
	            var zrUtil = __webpack_require__(5);
	            var Connector = __webpack_require__(82);
	            function VLayout(opts) {
	                /**
	                 * @cfg {Number} gap 节点之间的间隔
	                 */
	                /**
	                 * @cfg {Number} maxHeight=Infinity 组最大的高度，如果超过会换行
	                 */
	                var defaultOptions = {
	                    gap: 5,
	                    maxHeight: Infinity
	                };
	                this.options = zrUtil.merge(defaultOptions, opts, true);
	            }
	
	            /**
	             * @method run
	             * 进行垂直布局，一般不需要调用，直接将布局类 赋值给组layout 属性即可
	             * @param {Object} group 需要进行垂直布局的组
	             */
	            VLayout.prototype.run = function(group)  {
	                var x = 0;
	                var y = 0;
	                var currentLineMaxSize = 0;
	                group.each(function (child, idx) {
	                    if (child instanceof Connector) {
	                        return;
	                    }
	
	                    var position = child.position;
	                    var rect = child.getBoundingRect();
	                    var nextChild = group.childAt(idx + 1);
	                    var nextChildRect = nextChild && nextChild.getBoundingRect();
	                    var nextY;
	
	                    var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);
	                    nextY = y + moveY;
	                    // Wrap when width exceeds maxHeight or meet a `newline` group
	                    if (nextY > this.options.maxHeight || child.newline) {
	                        x += currentLineMaxSize + parseInt(this.options.gap,10);
	                        y = 0;
	                        nextY = moveY;
	                        currentLineMaxSize = rect.width;
	                    }
	                    else {
	                        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
	                    }
	
	                    if (child.newline) {
	                        return;
	                    }
	
	                    position[0] = x;
	                    position[1] = y;
	                    y = nextY + this.options.gap;
	                },this);
	
	                return VLayout;
	            }
	        module.exports = VLayout;
	
	
	/**
	 * @method addCustomLayout
	 * @hide
	 */

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 树布局<br>
	 * @class fishTopoFlow.layout.TreeLayout
	 * @extends fishTopoFlow.layout
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var layout = fishTopoFlow.layout;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"));
	 *       function newNode(data) {
	 *           var circle = new node.Circle({
	 *               shape: { r: 15 },
	 *               style: { fill: "#4883b4" },
	 *               name: data.name
	 *           });
	 *           return circle;
	 *       }
	 *       var options = {
	 *           createNodeFunction: newNode,
	 *           data:[{
	 *               name: '根节点',
	 *               children: [
	 *                   {   name: '节点1',
	 *                       children: [
	 *                           {name: '叶子节点1'},
	 *                           {name: '叶子节点2'},
	 *                           {name: '叶子节点3'},
	 *                           {name: '叶子节点4'},
	 *                           {name: '叶子节点5'},
	 *                           {name: '叶子节点6'}
	 *                       ]
	 *                   },
	 *                   {   name: '节点2',
	 *                       children: [
	 *                           {name: '叶子节点7'},
	 *                           {name: '叶子节点8'}]
	 *                   },
	 *                   {   name: '节点3',
	 *                       children: [
	 *                           {name: '叶子节点9'},
	 *                           {name: '叶子节点10'},
	 *                           {name: '叶子节点11'},
	 *                           {name: '叶子节点12'}
	 *                       ]
	 *                   }
	 *               ]
	 *           }]
	 *       }
	*
	 *       var treeLayout = new layout.TreeLayout({
	 *           fishTopo:fishTopo,
	 *           rootLocation:{x:'center', y:50},
	 *           nodePadding:1
	 *       });
	 *       treeLayout.doLayout(options);
	 */
	
	            var zrUtil = __webpack_require__(5);
	            var BoundingRect = __webpack_require__(27);
	            var flowUtil = __webpack_require__(94);
	            var parsePercent = flowUtil.parsePercent;
	            var TreeData = __webpack_require__(128);  // 数据依赖
	            var TreeHelper = __webpack_require__(129); // 布局依赖
	            function TreeLayout(opts) {
	                /**
	                 * @cfg {Object} fishTopo fishTopo实例
	                 */
	                /**
	                 * @cfg {Object} rootLocation 根节点坐标，支持绝对值（px）、字符和百分比 'center' | 'left' | 'right' | 'x%' | number
	                 * @cfg {Number|String} rootLocation.x  根节点横坐标，支持绝对值（px）、字符和百分比 'center' | 'left' | 'right' | 'x%' | number
	                 * @cfg {Number|String} rootLocation.y  根节点纵坐标，支持绝对值（px）、字符和百分比 'center' | 'left' | 'right' | 'x%' | number
	                 */
	                /**
	                 * @cfg {Number} layerPadding=100 层间距,默认:100
	                 */
	                /**
	                 * @cfg {Number} nodePadding=30 节点间距,默认:30
	                 */
	                /**
	                 *@cfg {String} direction 树的方向可选：'vertical' | 'horizontal' ,默认:vertical
	                 */
	                /**
	                 * @cfg {Object} lineStyle 连线的样式  参见{@link fishTopoFlow.link#constructor 构造函数options参数}
	                 */
	                var defaultOptions = {
	                    orient:'vertical',  // vertical,horizontal
	                    nodePadding:30, //节点间距
	                    layerPadding:100,  //层间距
	                    rootLocation: {x:100, y:230}, // 根节点坐标，支持绝对值（px）、字符和百分比
	                    animateTime : 500,
	                    lineStyle: {pos:'bottom,top', symbol:{type:'none'}}
	                };
	                if (opts.orient === 'horizontal') {
	                    defaultOptions.lineStyle.pos = 'right,left';
	                }
	
	                this.options = zrUtil.defaults(defaultOptions, opts, true);
	                this.nodePadding = this.options.nodePadding;
	                this.layerPadding = this.options.layerPadding;
	                this.fishTopo = this.options.fishTopo;
	                this._layerOffsets = [];
	                this._layers = [];
	                this._hideNodes = [];
	            }
	
	            /**
	             * @method layoutByRootNode
	             * 根据根节点及连线的关系 ，生成树
	             * @param {Object} rootNode 树的根节点
	             * @return {Object} boundingbox 包围和
	             */
	            TreeLayout.prototype.layoutByRootNode = function(rootNode) {
	                var connectors = this.fishTopo.connectionManager.connectors;  //所有线段的数组
	                //递归生成树型数据结构
	                function traverseNode(parentNode, treeData) {
	                    var childrenData = [];
	                    var childrenNode = [];
	                    //1.根据连线，找出起始节点的所有子节点
	                    zrUtil.each(connectors, function(connector) {
	                        if(connector.startNode === parentNode) {
	                            if(!connector.endNode.exclude) {   //如果是排斥的节点则不加入
	                                childrenNode.push(connector.endNode);
	                            }
	                        }
	                    })
	
	                    if (childrenNode.length > 0) {
	                        //2.遍历子节点
	                        zrUtil.each(childrenNode, function(node) {
	                             var nodeData = {name: node.id, node:node};
	                             childrenData.push(nodeData);
	                             traverseNode(node, nodeData);
	                        })
	                    }
	                    //3.将子节点放入children中
	                    if (childrenData.length > 0) {
	                        treeData.children = childrenData;
	                    }
	                }
	                var rootTreeData = {name: rootNode.id, node:rootNode};
	                traverseNode(rootNode,rootTreeData);
	                return this.doLayout({data:[rootTreeData]}, true);
	            }
	
	            /**
	             * @method doLayout
	             * 根据传过来树型结构数据进行树布局
	             * @param {Object} treeData 树形数据
	             * @param {Function} treeData.createNodeFunction=null 创建节点的函数 会把data中的数据 传递过去  如果没有默认就是创建圆形
	             * @param {Object} treeData.data 创建树布局数据（必须包括name属性）
	             * @param {boolean} isNotBuildLink=true 默认是自动创建连线，传true则不会自动创建连线
	             * @return {Object} boundingbox 包围和
	             */
	            TreeLayout.prototype.doLayout = function(treeData, isNotBuildLink)  {
	                var rootData = treeData.data[0];
	                this.treeData = treeData;
	
	                this.tree = TreeData.fromOptionData(rootData.name, rootData.children);
	                this.tree.root.data = rootData;
	
	
	                this._buildNode(treeData);
	
	                //根据root坐标 方向 对每个节点的坐标进行映射
	                this._setTreeShape(function() {
	                    this._buildAllLink(isNotBuildLink);
	                }.bind(this));
	
	                return this.getBoundingRect();
	            }
	
	            /**
	             * @private
	             * @method _buildAllLink
	             * 递归画出连接线 与设置节点坐标
	             */
	             TreeLayout.prototype._buildAllLink = function (isNotBuildLink) {
	                this.tree.traverse(function(treeNode) {
	                    //画连接线
	                    if (treeNode.children.length > 0 && !isNotBuildLink) {
	                        this._buildLinkByParent(treeNode, this.treeData.createLinkFunction)
	                    } else {
	                        this.fishTopo.connectionManager.refreshLineByNode(treeNode.data.node);
	                    }
	                },this)
	             }
	
	
	            /**
	             * @method getBoundingRect
	             * 计算出树的包围和
	             * @return {Object} boundingbox 包围和
	             */
	            TreeLayout.prototype.getBoundingRect = function() {
	                var rect = null;
	                this.tree.traverse(function(treeNode) {
	                    var childRect = BoundingRect.create({x:treeNode.layout.position[0], y:treeNode.layout.position[1], width:treeNode.layout.width, height: treeNode.layout.height});
	                    if (!rect) rect = childRect.clone();
	                    rect.union(childRect);
	                },this)
	                return rect;
	            }
	
	
	
	            TreeLayout.prototype._setTreeShape = function(doneCallback) {
	                var animateCount = 0;
	                var treeHelper = new TreeHelper(
	                    {
	                        nodePadding: this.nodePadding,
	                        layerPadding: this.layerPadding
	                    }
	                );
	
	
	                this.tree.traverse(function(treeNode) {
	                    if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){
	                        var boundingRect = treeNode.data.node.getBoundingRect();
	                        treeNode.layout = {
	                            width: treeNode.data.node._width || boundingRect.width,
	                            height: treeNode.data.node._height || boundingRect.height
	                        }
	                    }
	
	                },this);
	                treeHelper._hideNodes = this._hideNodes;
	                treeHelper.run(this.tree);
	                // 树的方向
	                var orient = this.options.orient;
	                var rootX = this.options.rootLocation.x;
	                var rootY = this.options.rootLocation.y;
	                var zrWidth = this.fishTopo.getWidth();
	                var zrHeight = this.fishTopo.getHeight();
	                if (rootX === 'center') {
	                    rootX = zrWidth * 0.5;
	                }
	                else {
	                    rootX = parsePercent(rootX, zrWidth);
	                }
	                if (rootY === 'center') {
	                    rootY = zrHeight * 0.5;
	                }
	                else {
	                    rootY = parsePercent(rootY, zrHeight);
	                }
	                rootY = parsePercent(rootY, zrHeight);
	                // 水平树
	                if (orient === 'horizontal') {
	                    rootX = isNaN(rootX) ? 10 : rootX;
	                    rootY = isNaN(rootY) ? zrHeight * 0.5 : rootY;
	                }
	                // 纵向树
	                else {
	                    rootX = isNaN(rootX) ? zrWidth * 0.5 : rootX;
	                    rootY = isNaN(rootY) ? 10 : rootY;
	                }
	                // tree layout自动算出来的root的坐标
	                var originRootX = this.tree.root.layout.position[0];
	
	                var treeNodeCount = treeHelper.count(this.tree) - this._hideNodes.length;
	                var minY = Infinity;
	
	                this.tree.traverse(
	                    function (treeNode) {
	                        var x;
	                        var y;
	                        if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){
	                            if (orient === 'vertical' && this.options.direction === 'inverse') {
	                                x = treeNode.layout.position[0] - originRootX + rootX;
	                                y = rootY - treeNode.layout.position[1];
	                            }
	                            else if (orient === 'vertical') {
	                                x = treeNode.layout.position[0] - originRootX + rootX;
	                                y = treeNode.layout.position[1] + rootY;
	                            }
	                            else if (orient === 'horizontal' && this.options.direction === 'inverse') {
	                                y = treeNode.layout.position[0] - originRootX + rootY;
	                                x = rootX - treeNode.layout.position[1];
	                            }
	                            else if (orient === 'horizontal') {
	                                y = treeNode.layout.position[0] - originRootX + rootY;
	                                x = treeNode.layout.position[1] + rootX;
	                            }
	                            treeNode.layout.__x = x;
	                            treeNode.layout.__y = y;
	                            if (y < minY) {
	                                minY = y;
	                            }
	                        }
	                    },
	                    this
	                );
	
	                this.tree.traverse(function (treeNode) {
	                    if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){
	                        if (minY > 0) {
	                            treeNode.layout.position[0] = treeNode.layout.__x;
	                            treeNode.layout.position[1] = treeNode.layout.__y;
	                        } else  {
	                            treeNode.layout.position[0] = treeNode.layout.__x;
	                            treeNode.layout.position[1] = treeNode.layout.__y - minY;
	                        }
	
	                        treeNode.data.node.animateTo({
	                            position: [treeNode.layout.position[0], treeNode.layout.position[1]]
	                        }, this.options.animateTime, function() {
	                            if (++animateCount === treeNodeCount) {
	                                doneCallback();
	                            }
	                        }.bind(this));
	                        //节点有孩子才显示 收缩按钮
	                        if(this._hideNodes.length == 0){
	                            if (treeNode.children.length > 0 && treeNode.data.node._toggleShrink) {
	                                treeNode.data.node._toggleShrink(true);
	                            }
	                        }
	                    }
	
	                },this)
	            }
	
	            TreeLayout.prototype._buildNode = function(treeData) {
	                if(!treeData.createNodeFunction) {
	                    treeData.createNodeFunction = this._defaultCreateNodeFunction;
	                }
	                //判断一下是否有node 如果没有则自己创建
	                this.tree.traverse(function(treeNode) {
	                    if(!treeNode.data.node) {
	                        var createNodeFunction = treeNode.data.createNodeFunction || treeData.createNodeFunction;
	                        var node = createNodeFunction(treeNode.data, this);
	                        node._childShow = true;
	                        this.fishTopo.add(node);
	                        treeNode.data.node = node;
	                    }
	                },this);
	            }
	
	            TreeLayout.prototype._defaultCreateNodeFunction = function(item) {
	                var circle = this.fishTopo.createNode("Circle",{
	                    shape: { r: 15 },
	                    style: { fill: "#4883b4" },
	                    name: item.lable || item.name
	                });
	                return circle;
	            }
	
	            TreeLayout.prototype._buildLinkByParent = function (parentTreeNode, createLinkFunction) {
	                for (var i = 0, childLength = parentTreeNode.children.length; i < childLength; i++) {
	                    this._buildLink(parentTreeNode, parentTreeNode.children[i], createLinkFunction);
	                }
	            };
	
	
	            TreeLayout.prototype._buildLink = function (startTreeNode, endTreeNode, createLinkFunction) {
	                    var connector = null;
	                    var startNode = startTreeNode.data.node;
	                    var endNode = endTreeNode.data.node;
	                    if(createLinkFunction) {
	                        var paramObj =  endTreeNode.data;
	                        paramObj.startNode = startNode;
	                        paramObj.endNode = endNode;
	                        connector = createLinkFunction(paramObj);
	                    } else {
	                        var linkStyle = this.options.lineStyle;
	                        if (endTreeNode.data.lineStyle) {
	                            linkStyle = zrUtil.merge(zrUtil.clone(linkStyle), endTreeNode.data.lineStyle, true);
	                        }
	                        connector = this.fishTopo.createLink(startNode,endNode,linkStyle)
	                    }
	                    this.fishTopo.add(connector);
	            };
	
	            /**
	             * @method addChild
	             * 在指定topo节点下新增一个子节点
	             * @param {Object} treeNode 要增加子节点的topo节点
	             * @param {Object} data 新增子节点的数据
	             * @param {Function} callback 增加完子节点之后触发的回调函数
	             * @return {Object} 新增加的子节点
	             */
	            TreeLayout.prototype.addChild = function (treeNode, data, callback) {
	                var newTreeNode = (new TreeData(data.name)).root;
	                newTreeNode.data = data;
	
	                var node = this.treeData.createNodeFunction(newTreeNode.data, this);
	                node._childShow = true;
	                if (treeNode.children.length >= 1) {
	                    node.attr('position', zrUtil.clone(treeNode.children[treeNode.children.length - 1].layout.position));
	                } else {
	                    node.attr('position', zrUtil.clone(treeNode.layout.position));
	                }
	
	                this.fishTopo.add(node);
	                newTreeNode.data.node = node;
	                setTimeout(function () {
	                    this._buildLink(treeNode, newTreeNode, this.treeData.createLinkFunction);
	                }.bind(this), this.options.animateTime);
	
	                treeNode.add(newTreeNode);
	                this.refreshPositionAndLine(callback);
	                return node;
	            };
	
	            /**
	             * @method toggleChild
	             * 展示或者隐藏选中topo节点下的子节点以及与子节点之间的连线
	             * @param {Object} node 树节点
	             */
	            TreeLayout.prototype.toggleChild = function (node) {
	                var toggleTreeNode = this.findTreeNodeByNode(node);
	                if (node._childShow) {
	                    toggleTreeNode.traverse(function (treeNode) {
	                        if (treeNode.data.node !== node) {
	                            treeNode.data.node.hide();
	                            if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){
	                                this._hideNodes.push(treeNode);
	                            }
	                            this.fishTopo.connectionManager.toggleLineByNode(treeNode.data.node, false);
	                            if (treeNode.children.length > 0) {
	                                treeNode.data.node._childShow = false;
	                                treeNode.data.node._toggleShrink && treeNode.data.node._toggleShrink(false);
	                            }
	                        }
	                    },this);
	                    node._childShow = false;
	                    node._toggleShrink && node._toggleShrink(false);
	                    this.refreshPositionAndLine();
	                } else {
	                    toggleTreeNode.traverse(function (treeNode) {
	                        if (treeNode.data.node !== node) {
	                            treeNode.data.node.show();
	                            this._hideNodes.splice(zrUtil.indexOf(this._hideNodes, treeNode),1);
	                            this.fishTopo.connectionManager.toggleLineByNode(treeNode.data.node, true);
	                            if (treeNode.children.length > 0) {
	                                treeNode.data.node._childShow = true;
	                                treeNode.data.node._toggleShrink && treeNode.data.node._toggleShrink(true);
	                            }
	                        }
	                    },this);
	                    node._childShow = true;
	                    node._toggleShrink && node._toggleShrink(true);
	                    this.refreshPositionAndLine();
	                }
	            };
	
	            /**
	             * @method findTreeNodeByNode
	             * 根据topo节点找到树的节点
	             * @param {Object} node topo节点
	             * @return {Object} 
	             */
	            TreeLayout.prototype.findTreeNodeByNode = function (node) {
	                var returnTreeNode = null;
	                this.tree.traverse(function (treeNode) {
	                    if (treeNode.data.node === node) {
	                        returnTreeNode = treeNode;
	                    }
	                });
	                return returnTreeNode;
	            };
	
	            /**
	             * @method removeNode
	             * 删除选中topo节点
	             * @param {Object} node topo节点
	             * @return {Boolean} 删除是否成功
	             */
	            TreeLayout.prototype.removeNode = function (node) {
	                var treeNode = this.findTreeNodeByNode(node);
	                var parentTreeNode = treeNode.parent;
	                if (!parentTreeNode) return false;
	                //遍历 topo中删除自己及孩子节点
	                treeNode.traverse(function (eachTreeNode) {
	                    this.fishTopo.remove(eachTreeNode.data.node); //删除节点
	                },this)
	
	                parentTreeNode.remove(treeNode);
	
	                //判断一下父节点是不是没有了,如果没有的话,要把线与+-号给隐藏掉
	                if (parentTreeNode.children.length === 0) {
	                    parentTreeNode.data.node._hideToggle && parentTreeNode.data.node._hideToggle();
	                }
	
	                //重新生成数据
	                this.refreshPositionAndLine();
	                return true;
	            };
	
	            /**
	             * @method removeChildren
	             * 删除选中topo节点下的所有子节点
	             * @param {Object} node topo节点
	             * @return {Boolean} 删除是否成功
	             */
	            TreeLayout.prototype.removeChildren = function (node) {
	                var treeNode = this.findTreeNodeByNode(node);
	                //遍历 topo中删除孩子节点
	                treeNode.traverse(function (eachTreeNode) {
	                    if (eachTreeNode !== treeNode) {
	                        this.fishTopo.remove(eachTreeNode.data.node); //删除节点
	                    }
	                },this)
	
	                treeNode.removeAllChildren();
	                node._hideToggle && node._hideToggle(); //this._hidePath(node);
	
	                //重新生成数据
	                this.refreshPositionAndLine();
	                return true;
	            };
	
	            /**
	             * @method refreshPositionAndLine
	             * 刷新当前树布局中所有节点的位置和节点之间的连线
	             * @param {Function} callback 刷新之后所触发的回调函数
	             */
	            TreeLayout.prototype.refreshPositionAndLine = function (callback) {
	                this.tree.root.updateDepthAndHeight(0);
	                this._setTreeShape(function () {
	                    this.tree.traverse(function (eachTreeNode) {
	                        this.fishTopo.connectionManager.refreshLineByNode(eachTreeNode.data.node);
	                    }, this);
	                    callback && callback();
	                }.bind(this));
	            }
	
	            /**
	             * @method changePosition
	             * 更改当前topo节点在其兄弟节点中的位置
	             * @param {Object} node 树节点
	             * @param {String} direction 节点移动的方向，next表示往下移动，prev表示往上移动
	             */
	            TreeLayout.prototype.changePosition = function (node, direction) {
	                var parentNode = node.parent;
	                var nowIndex = zrUtil.indexOf(parentNode.children, node);
	                var targetIndex;
	                if(direction == "next"){
	                    targetIndex = nowIndex + 1;
	                }else if(direction == "prev"){
	                    targetIndex = nowIndex - 1;
	                }
	                var targetNode = parentNode.children[targetIndex];
	                if(targetNode){
	                    var storage = targetNode;
	                    parentNode.children[targetIndex] = node;
	                    parentNode.children[nowIndex] = storage;
	                }
	                this.refreshPositionAndLine();
	                this.fishTopo.trigger('treeLayout:changePosition',{
	                    node:node,
	                    parentNode:parentNode,
	                    targetNode:targetNode
	                })
	            }
	
	        module.exports = TreeLayout;
	
	
	/**
	 * @method addCustomLayout
	 * @hide
	 */

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	
	    var zrUtil = __webpack_require__(5);
	
	    /**
	     * @constructor TreeNode
	     * @param {string} id Node ID
	     * @param {Object} [data]
	     */
	    function TreeNode(id, data) {
	        /**
	         * @type {string}
	         */
	        this.id = id;
	        /**
	         * 节点的深度
	         * @type {number}
	         */
	        this.depth = 0;
	        /**
	         * 以当前节点为根节点的子树的高度
	         * @type {number}
	         */
	        this.height = 0;
	        /**
	         * 子节点列表
	         * @type {Array.<TreeNode>}
	         */
	        this.children = [];
	
	        /**
	         * @type {TreeNode}
	         */
	        this.parent = null;
	
	        /**
	         * 存储的用户数据
	         * @type {Object}
	         */
	        this.data = data || null;
	    }
	
	    /**
	     * 添加子节点
	     * @param {TreeNode} child
	     */
	    TreeNode.prototype.add = function (child) {
	        var children = this.children;
	        if (child.parent === this) {
	            return;
	        }
	
	        children.push(child);
	        child.parent = this;
	    };
	
	    /**
	     * 移除子节点
	     * @param {TreeNode} child
	     */
	    TreeNode.prototype.remove = function (child) {
	        var children = this.children;
	        var idx = zrUtil.indexOf(children, child);
	        if (idx >= 0) {
	            children.splice(idx, 1);
	            child.parent = null;
	        }
	    };
	
	     TreeNode.prototype.removeAllChildren = function () {
	         var children = this.children;
	         for (var i = 0; i < children.length; i++) {
	             var child = children[i];
	            child.parent = null;
	         }
	        this.children = [];
	     }
	
	    /**
	     * 遍历当前节点及其所有子节点
	     * @param  {Function} cb
	     * @param  {Object}   [context]
	     */
	    TreeNode.prototype.traverse = function (cb, context) {
	        cb.call(context, this);
	
	        for (var i = 0; i < this.children.length; i++) {
	            this.children[i].traverse(cb, context);
	        }
	    };
	
	    /**
	     * 遍历节前节点及所有子节点的数量
	     */
	    TreeNode.prototype.count = function () {
	        var count = 0;
	        this.traverse(function() {
	            count++;
	         });
	        return count;
	    }
	
	    /**
	     * 更新当前树及所有子树的高度和深度
	     * @param  {number} depth
	     */
	    TreeNode.prototype.updateDepthAndHeight = function (depth) {
	        var height = 0;
	        this.depth = depth;
	        for (var i = 0; i < this.children.length; i++) {
	            var child = this.children[i];
	            child.updateDepthAndHeight(depth + 1);
	            if (child.height > height) {
	                height = child.height;
	            }
	        }
	        this.height = height + 1;
	    };
	
	    /**
	     * @param  {string} id
	     * @return TreeNode
	     */
	    TreeNode.prototype.getNodeById = function (id) {
	        if (this.id === id) {
	            return this;
	        }
	        for (var i = 0; i < this.children.length; i++) {
	            var res = this.children[i].getNodeById(id);
	            if (res) {
	                return res;
	            }
	        }
	    };
	
	    /**
	     * @constructor
	     * @alias module:echarts/data/Tree
	     * @param {string} id
	     */
	    function Tree(id) {
	        /**
	         * @type {TreeNode}
	         */
	        this.root = new TreeNode(id);
	    }
	
	    /**
	     * 遍历树的所有子节点(深度优先遍历)
	     * @param  {Function} cb
	     * @param  {Object}   [context]
	     */
	    Tree.prototype.traverse = function(cb, context) {
	        this.root.traverse(cb, context);
	    };
	
	    /**
	     * 生成子树
	     * @param  {string} id 子树根节点 id
	     * @return {module:echarts/data/Tree}
	     */
	    Tree.prototype.getSubTree = function(id) {
	        var root = this.getNodeById(id);
	        if (root) {
	            var tree = new Tree(root.id);
	            tree.root = root;
	            return tree;
	        }
	    };
	
	    /**
	     * @param  {string} id
	     * @return TreeNode
	     */
	    Tree.prototype.getNodeById = function (id) {
	        return this.root.getNodeById(id);
	    };
	
	
	    /**
	     * 从 option 里的 data 数据构建树
	     * @param {string} id
	     * @param {Array.<Object>} data
	     * @return Tree
	     */
	    Tree.fromOptionData = function (id, data) {
	        var tree = new Tree(id);
	        var rootNode = tree.root;
	        // Root node
	        rootNode.data = {
	            name: id,
	            children: data
	        };
	
	        function buildHierarchy(dataNode, parentNode) {
	            var node = new TreeNode(dataNode.name, dataNode);
	            parentNode.add(node);
	            // 遍历添加子节点
	            var children = dataNode.children;
	            if (children) {
	                for (var i = 0; i < children.length; i++) {
	                    buildHierarchy(children[i], node);
	                }
	            }
	        }
	
	        for (var i = 0; i < data.length; i++) {
	            buildHierarchy(data[i], rootNode);
	        }
	
	        tree.root.updateDepthAndHeight(0);
	
	        return tree;
	    };
	
	
	    Tree.fromDataSource = function (dataSource, rootItem) {
	
	        function _findChildItem(nodeName) {
	            return zrUtil.filter(dataSource.link,function(item){
	                if(item.from === nodeName && !item.pos) {  // 数据中有pos属性的不是子节点
	                    return item;
	                }
	            });
	        }
	
	
	        function buildHierarchy(root) {
	            var childItem = _findChildItem(root.id);
	            for (var i = 0; i < childItem.length; i++) {
	                var item = childItem[i];
	                var childTreeNode = treeNodesMap[item.to];
	                root.children.push(childTreeNode);
	                buildHierarchy(childTreeNode);
	            }
	        }
	
	        var treeNodesMap = {};
	        for (var i = 0; i < dataSource.node.length; i++) {
	            var node = dataSource.node[i];
	            var treeNode = new TreeNode(node.name,node);
	            treeNodesMap[node.name] = treeNode;
	        }
	
	        var tree = new Tree(rootItem.name);
	        var rootNode = tree.root;
	        // Root node
	        rootNode.data = rootItem;
	
	
	        buildHierarchy(tree.root);
	        tree.root.updateDepthAndHeight(0);
	
	        return tree;
	    };
	
	    module.exports = Tree;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	
	    var vec2 = __webpack_require__(15);
	    var zrUtil = __webpack_require__(5);
	
	    function TreeHelper(opts) {
	        opts = opts || {};
	
	        this.nodePadding = opts.nodePadding || 30;
	
	        this.layerPadding = opts.layerPadding || 100;
	
	        this._layerOffsets = [];
	
	        this._layers = [];
	
	        this._hideNodes = [];
	    }
	
	    TreeHelper.prototype.count = function (tree) {
	        var count = 0;
	        tree.traverse(function() {
	            count++;
	         });
	        return count;
	    }
	
	    TreeHelper.prototype.run = function (tree) {
	        this._layerOffsets.length = 0;
	        for (var i = 0; i < tree.root.height + 1; i++) {
	            this._layerOffsets[i] = 0;
	            this._layers[i] = [];
	        }
	        this._updateNodeXPosition(tree.root);
	        var root = tree.root;
	        this._updateNodeYPosition(root, 0, root.layout.height);
	    };
	
	    TreeHelper.prototype._updateNodeXPosition = function (node) {
	        var minX = Infinity;
	        var maxX = -Infinity;
	        node.layout.position = node.layout.position || vec2.create();
	        for (var i = 0; i < node.children.length; i++) {
	            var child = node.children[i];
	            if(zrUtil.indexOf(this._hideNodes, child) == -1){
	                this._updateNodeXPosition(child);
	                var x = child.layout.position[0];
	                if (x < minX) {
	                    minX = x;
	                }
	                if (x > maxX) {
	                    maxX = x;
	                }
	            }
	        }
	        if (node.children.length > 0 && (zrUtil.indexOf(this._hideNodes, node.children[0]) == -1)) {
	            node.layout.position[0] = (minX + maxX) / 2;
	        } else {
	            node.layout.position[0] = 0;
	            node.height = 0;   // 隐藏节点的 深度设为0
	        }
	        var off = this._layerOffsets[node.depth] || 0;
	        if (off > node.layout.position[0]) {
	            var shift = off - node.layout.position[0];
	            this._shiftSubtree(node, shift);
	            for (var j = node.depth + 1; j < node.height + node.depth; j++) {
	                this._layerOffsets[j] += shift;
	            }
	        }
	        this._layerOffsets[node.depth] = node.layout.position[0] + node.layout.width + this.nodePadding;
	
	        if(zrUtil.indexOf(this._layers[node.depth], node) == -1){
	            this._layers[node.depth].push(node);
	        }
	    };
	
	    TreeHelper.prototype._shiftSubtree = function (root, offset) {
	        root.layout.position[0] += offset;
	        for (var i = 0; i < root.children.length; i++) {
	            if(zrUtil.indexOf(this._hideNodes,root.children[i]) == -1){
	                this._shiftSubtree(root.children[i], offset);
	            }
	        }
	    };
	
	    TreeHelper.prototype._updateNodeYPosition = function (node, y, prevLayerHeight) {
	        if(zrUtil.indexOf(this._hideNodes,node) == -1){
	            node.layout.position[1] = y;
	            var layerHeight = 0;
	            for (var i = 0; i < node.children.length; i++) {
	                layerHeight = Math.max(node.children[i].layout.height, layerHeight);
	            }
	            var layerPadding = this.layerPadding;
	            if (typeof (layerPadding) === 'function') {
	                layerPadding = layerPadding(node.depth);
	            }
	            for (var j = 0; j < node.children.length; j++) {
	                this._updateNodeYPosition(node.children[j], y + layerPadding + prevLayerHeight, layerHeight);
	            }
	        }
	
	    };
	    module.exports = TreeHelper;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 力导向布局<br>
	 * @class fishTopoFlow.layout.ForceLayout
	 * @extends fishTopoFlow.layout
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var layout = fishTopoFlow.layout;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       function newNode(data) {
	 *           var circle = new node.Circle({
	 *               shape: { r: 15 },
	 *               style: { fill: "#4883b4" },
	 *               name: data.name
	 *           });
	 *           return circle;
	 *       }
	 *       var options = {
	 *           createNodeFunction: newNode,
	 *           data:[{nodes:[
	 *                           {name: '节点1'},
	 *                           {name: '节点2'},
	 *                           {name: '节点3'},
	 *                           {name: '节点4'},
	 *                           {name: '节点5'},
	 *                           {name: '节点6'},
	 *                           {name: '节点7'},
	 *                           {name: '节点8'}
	 *                       ],
	 *                   links:[
	 *                           {source:'节点1', target:'节点2'},
	 *                           {source:'节点2', target:'节点3'},
	 *                           {source:'节点3', target:'节点4'},
	 *                           {source:'节点4', target:'节点5'},
	 *                           {source:'节点5', target:'节点6'},
	 *                           {source:'节点6', target:'节点7'},
	 *                           {source:'节点7', target:'节点8'}
	 *                       ]
	 *           }]
	 *       }
	 *       var forceLayout = new layout.ForceLayout({
	 *          fishTopo:fishTopo,
	 *           repulsion: 200
	 *       });
	 *       forceLayout.doLayout(options);
	 */
	
	
	
	    var forceHelper = __webpack_require__(131);
	    var vec2 = __webpack_require__(15);
	    var zrUtil = __webpack_require__(5);
	    function ForceLayout(opts) {
	         /**
	         * @cfg {Object} fishTopo fishTopo实例
	         */
	         /**
	         * @cfg {Number} [repulsion=100] 节点之间的斥力因子。该值越大节点之间的斥力越大，两个节点间的距离也会越远，默认为100
	         */
	         /**
	         * @cfg {Number} [gravity=0.1] 节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。默认为0.1
	         */
	        /**
	         * @cfg {Number} [edgeLength=30] 边的两个节点之间的距离，这个距离也会受 repulsion影响。 默认为30
	         */
	        /**
	         * @cfg {Boolean} [once=true] 是否只进行布局一次。<br/>
	         * 如果设置为false，在布局结束以后，再拖拽节点，节点的定位会设置为fixed，释放被拖拽的节点，节点会回到原来的位置, 导致重新布局，同样会再次触发forceLayoutEnd事件。
	         */
	        /**
	         * @cfg {Object} [rect] 布局显示范围
	         *
	         * @cfg {Object} [rect.x] 布局显示范围x坐标
	         * @cfg {Object} [rect.y] 布局显示范围y坐标
	         * @cfg {Object} [rect.width] 布局显示宽度
	         * @cfg {Object} [rect.height] 布局显示高度
	         */
	        /**
	         * @cfg {Boolean} [layoutAnimation=true] 是否显示布局动画
	         */
	        /**
	         * @cfg {Object} [lineStyle] 连线的样式  参见{@link fishTopoFlow.link#constructor 构造函数options参数}
	         */
	        this.fishTopo = opts.fishTopo;
	        var defaultOptions = {
	            repulsion: 100,  //节点之间的斥力因子。该值越大节点之间的斥力越大，两个节点间的距离也会越远，默认为100
	            gravity: 0.1, //节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。默认为0.1
	            edgeLength: 30, // 边的两个节点之间的距离，这个距离也会受 repulsion。 默认为30
	            once:true,
	            layoutAnimation:true,
	            rect: {x:0, y:0, width:this.fishTopo.getWidth() ,height:this.fishTopo.getHeight()},
	            lineStyle: {symbol:{type:'none'}},
	            preservedPoints: {}
	        };
	
	        this.options = zrUtil.defaults(defaultOptions, opts, true);
	    }
	
	    /**
	     * @method doLayout
	     * 根据forceData进行力导向布局
	     * @param {Object} forceData 力导向数据
	     * @param {Function} forceData.createNodeFunction=null 创建节点的函数 会把data中nodes的数据 传递过去  如果没有默认就是创建圆形
	     * @param {Function} forceData.createLinkFunction=null 创建线段函数，参数是data.links数据，如果没有默认创建直线 since V2.3.0
	     * @param {Object} forceData.data 创建力导向布局数据
	     * @param {Object} forceData.data.nodes 创建力导向布局节点的对象数据（必须包括name属性）
	     * @param {Object} forceData.data.links 创建力导向布局连线的对象数据（必须包括name属性）
	     *
	     */
	    ForceLayout.prototype.doLayout = function(forceData) {
	         var rootData = forceData.data[0];
	         this.allNodes = this._buildNode(rootData.nodes, forceData.createNodeFunction);
	         this.allLinks = this._buildLinks(rootData.links, forceData.createLinkFunction);
	         this._forceIns();
	
	         this._startForceLayoutIteration();
	    }
	    /**
	     * @method autoLayout
	     * 根据已有节点进行力导向布局
	     * @since V2.3.0
	     */
	    ForceLayout.prototype.autoLayout = function() {
	        this.allNodes = this.fishTopo.allNodes;
	        this.allLinks = this.fishTopo.connectionManager.connectors;
	        this._forceIns();
	        this._startForceLayoutIteration();
	    }
	
	    ForceLayout.prototype._buildNode = function(datas, createNodeFunction) {
	        if(!fish.isFunction(createNodeFunction)) {
	            createNodeFunction = this._defaultCreateNodeFunction.bind(this);
	        }
	        var allNodes = [];
	        //判断一下是否有node 如果没有则自己创建
	        zrUtil.each(datas,  function(item,idx) {
	            if(!item.node) {
	                var createNode = item.createNodeFunction || createNodeFunction;
	                var node = createNode(item);
	                this.fishTopo.add(node);
	                this._addNodeEvent(node,idx);
	                allNodes.push(node);
	            }
	        },this);
	        return allNodes;
	    }
	
	    ForceLayout.prototype._addNodeEvent = function(node,idx) {
	        if(!this.options.once) {
	            node.on('drag', function() {
	                if(this.options.forceLayout) {
	                    this.options.forceLayout.warmUp();
	                    !this._layouting && this._startForceLayoutIteration();
	                    this.options.forceLayout.setFixed(idx);
	                }
	            },this).on('dragend', function() {
	                if(this.options.forceLayout) {
	                    this.options.forceLayout.setUnfixed(idx);
	                }
	            },this)
	        }
	    }
	
	    ForceLayout.prototype._defaultCreateNodeFunction = function(item) {
	        var circle = this.fishTopo.createNode("Circle",{
	            shape: { r: 15 },
	            style: { fill: "#4883b4" },
	            name: item.lable || item.name
	        });
	        return circle;
	    }
	
	    ForceLayout.prototype._buildLinks = function(links,createLinkFunction) {
	        var allLinks = [];
	
	        zrUtil.each(links, function(link) {
	            var startNode = this.fishTopo.childOfName(link.source);
	            var endNode = this.fishTopo.childOfName(link.target);
	            if(startNode && endNode) {
	                 var connector = null;
	                if(createLinkFunction) {
	                    var paramObj = link;
	                    paramObj.startNode = startNode;
	                    paramObj.endNode = endNode;
	                    connector = createLinkFunction(paramObj);
	                } else {
	                    var linkStyle = this.options.lineStyle;
	                    if (link.style) {
	                        linkStyle = zrUtil.merge(zrUtil.clone(linkStyle), link.style, true);
	                    }
	                    connector = this.fishTopo.createLink(startNode,endNode,linkStyle);
	                }
	                this.fishTopo.add(connector);
	                allLinks.push(connector);
	            }
	        },this);
	        return allLinks;
	    }
	
	
	    ForceLayout.prototype._forceIns = function() {
	        var rect = this.options.rect;
	        var self = this;
	        var preservedPoints = this.options.preservedPoints;
	        var nodes = zrUtil.map(this.allNodes, function(node) {
	            var rep = this.options.repulsion; node.w = rep; node.rep = rep; node.p = null;
	            return {
	                w: rep,
	                rep: rep,
	                p: null
	            };
	        },this);
	        if (preservedPoints) {
	            zrUtil.each(this.allNodes, function(node,idx) {
	                node.attr("position", preservedPoints[idx]);
	            })
	        }
	        zrUtil.each(this.allLinks, function(link) {
	            link.n1 = link.startNode,
	            link.n2 = link.endNode,
	            link.d = this.options.edgeLength;
	            link.curveness = 0;
	        },this)
	
	        var forceInstance = forceHelper(this.allNodes, this.allLinks, {
	            rect: rect,
	            gravity: this.options.gravity
	        });
	        var oldStep = forceInstance.step;
	        forceInstance.step = function(cb) {
	            zrUtil.each(this.allNodes, function(node) {
	                if (nodes.fixed) {
	                    vec2.copy(nodes.p, nodes.position);
	                }
	            })
	
	            oldStep(function(allNodes, allLinks, stopped) {
	                for (var i = 0, l = allNodes.length; i < l; i++) {
	                    if (!allNodes[i].fixed) {
	                        allNodes[i].attr("position", allNodes[i].p);
	                    }
	                    preservedPoints[i] = allNodes[i].p;
	                }
	
	                zrUtil.each(allLinks, function(connector) {
	                    self.fishTopo.connectionManager.refreshConnector(connector, true);
	                })
	
	                cb && cb(stopped);
	            });
	        };
	        this.options.forceLayout = forceInstance;
	        this.options.preservedPoints = preservedPoints;
	        // Step to get the layout
	        forceInstance.step();
	    }
	
	
	    ForceLayout.prototype._startForceLayoutIteration = function () {
	        var self = this;
	        var layoutAnimation = this.options.layoutAnimation;
	        (function step() {
	            self.options.forceLayout.step(function (stopped) {
	                self._layouting = !stopped;
	                if (self._layouting) {
	                    if (layoutAnimation) {
	                        self._layoutTimeout = setTimeout(step, 16)
	                    } else {
	                        step();
	                    }
	                } else {
	                     self.fishTopo.trigger("forceLayoutEnd");  //派发布局结束事件
	                }
	            })
	        })();
	    };
	    module.exports = ForceLayout;
	
	/**
	 * @method addCustomLayout
	 * @hide
	 */
	
	/**
	 * @event forceLayoutEnd
	 * 布局结束事件
	 *
	 * <pre>
	 * fishtopo.on('forceLayoutEnd', function(e) {
	 *   //do something
	 * })
	 * </pre>
	 */


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var vec2 = __webpack_require__(15);
	    var scaleAndAdd = vec2.scaleAndAdd;
	
	    // function adjacentNode(n, e) {
	    //     return e.n1 === n ? e.n2 : e.n1;
	    // }
	
	    module.exports = function (nodes, edges, opts) {
	        var rect = opts.rect;
	        var width = rect.width;
	        var height = rect.height;
	        var center = [rect.x + width / 2, rect.y + height / 2];
	        // var scale = opts.scale || 1;
	        var gravity = opts.gravity == null ? 0.1 : opts.gravity;
	
	        // for (var i = 0; i < edges.length; i++) {
	        //     var e = edges[i];
	        //     var n1 = e.n1;
	        //     var n2 = e.n2;
	        //     n1.edges = n1.edges || [];
	        //     n2.edges = n2.edges || [];
	        //     n1.edges.push(e);
	        //     n2.edges.push(e);
	        // }
	        // Init position
	        for (var i = 0; i < nodes.length; i++) {
	            var n = nodes[i];
	            if (!n.p) {
	                // Use the position from first adjecent node with defined position
	                // Or use a random position
	                // From d3
	                // if (n.edges) {
	                //     var j = -1;
	                //     while (++j < n.edges.length) {
	                //         var e = n.edges[j];
	                //         var other = adjacentNode(n, e);
	                //         if (other.p) {
	                //             n.p = vec2.clone(other.p);
	                //             break;
	                //         }
	                //     }
	                // }
	                // if (!n.p) {
	                    n.p = vec2.create(
	                        width * (Math.random() - 0.5) + center[0],
	                        height * (Math.random() - 0.5) + center[1]
	                    );
	                // }
	            }
	            n.pp = vec2.clone(n.p);
	            n.edges = null;
	        }
	
	        // Formula in 'Graph Drawing by Force-directed Placement'
	        // var k = scale * Math.sqrt(width * height / nodes.length);
	        // var k2 = k * k;
	
	        var friction = 0.6;
	
	        return {
	            warmUp: function () {
	                friction = 0.5;
	            },
	
	            setFixed: function (idx) {
	                nodes[idx].fixed = true;
	            },
	
	            setUnfixed: function (idx) {
	                nodes[idx].fixed = false;
	            },
	
	            step: function (cb) {
	                var v12 = [];
	                var nLen = nodes.length;
	                for (var i = 0; i < edges.length; i++) {
	                    var e = edges[i];
	                    var n1 = e.n1;
	                    var n2 = e.n2;
	
	                    vec2.sub(v12, n2.p, n1.p);
	                    var d = vec2.len(v12) - e.d;
	                    var w = n2.w / (n1.w + n2.w);
	                    vec2.normalize(v12, v12);
	
	                    !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);
	                    !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);
	                }
	                // Gravity
	                for (var i = 0; i < nLen; i++) {
	                    var n = nodes[i];
	                    if (!n.fixed) {
	                        vec2.sub(v12, center, n.p);
	                        // var d = vec2.len(v12);
	                        // vec2.scale(v12, v12, 1 / d);
	                        // var gravityFactor = gravity;
	                        vec2.scaleAndAdd(n.p, n.p, v12, gravity * friction);
	                    }
	                }
	
	                // Repulsive
	                // PENDING
	                for (var i = 0; i < nLen; i++) {
	                    var n1 = nodes[i];
	                    for (var j = i + 1; j < nLen; j++) {
	                        var n2 = nodes[j];
	                        vec2.sub(v12, n2.p, n1.p);
	                        var d = vec2.len(v12);
	                        if (d === 0) {
	                            // Random repulse
	                            vec2.set(v12, Math.random() - 0.5, Math.random() - 0.5);
	                            d = 1;
	                        }
	                        var repFact = (n1.rep + n2.rep) / d / d;
	                        !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);
	                        !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);
	                    }
	                }
	                var v = [];
	                for (var i = 0; i < nLen; i++) {
	                    var n = nodes[i];
	                    if (!n.fixed) {
	                        vec2.sub(v, n.p, n.pp);
	                        vec2.scaleAndAdd(n.p, n.p, v, friction);
	                        vec2.copy(n.pp, n.p);
	                    }
	                }
	
	                friction = friction * 0.992;
	
	                cb && cb(nodes, edges, friction < 0.01);
	            }
	        };
	    }
	


/***/ }),
/* 132 */
/***/ (function(module, exports) {

	/**
	 * 工具类
	 * @class fishTopoFlow.util
	 */
	
	/**
	 * @method initImagePool
	 * 初始化图片池  用于对图片加载进行管理
	 * @param {number} max 最大连接数。数值。
	 * @returns {{load: Function, info: Function}}
	 *
	 * **使用范例**：
	 *
	 *      @example
	        var imagepool = fishTopoFlow.util.initImagePool(100);
	        imagepool.load(grayArray, {
	            success: function(imgs) {
	            },
	            once: true
	        });
	 */
	
	/**
	 * @method inherits
	 * 构造类继承关系
	 *
	 * @param {Function} clazz 源类
	 * @param {Function} baseClazz 基类
	 */
	
	
	    var emptyFn = function() {};
	    //初始默认配置
	    var config_default = {
	        //线程池"线程"数量
	        thread: 5,
	        //图片加载失败重试次数
	        //重试2次，加上原有的一次，总共是3次
	        "tries": 2
	    };
	    //工具
	    var _helpers = {
	        //设置dom属性
	        setAttr: (function() {
	            var img = new Image();
	            //判断浏览器是否支持HTML5 dataset
	            if (img.dataset) {
	                return function(dom, name, value) {
	                    dom.dataset[name] = value;
	                    return value;
	                };
	            } else {
	                return function(dom, name, value) {
	                    dom.setAttribute("data-" + name, value);
	                    return value;
	                };
	            }
	        }()),
	        //获取dom属性
	        getAttr: (function() {
	            var img = new Image();
	            //判断浏览器是否支持HTML5 dataset
	            if (img.dataset) {
	                return function(dom, name) {
	                    if(!dom.dataset[name]){
	                        return dom.getAttribute("data-" + name);
	                    }else{
	                        return dom.dataset[name];
	                    }
	                };
	            } else {
	                return function(dom, name) {
	                    return dom.getAttribute("data-" + name);
	                };
	            }
	        }())
	    };
	    /**
	     * 构造方法
	     * @private
	     * @param max 最大连接数。数值。
	     */
	    function ImagePool(max) {
	        //最大并发数量
	        this.max = max || config_default.thread;
	        this.linkHead = null;
	        this.linkNode = null;
	        //加载池
	        //[{img: dom,free: true, node: node}]
	        //node
	        //{src: "", options: {success: "fn",error: "fn", once: true}, tries: 0}
	        this.pool = [];
	    }
	    /**
	     * 初始化
	     * @private
	     */
	    ImagePool.prototype.initPool = function() {
	        var i, img, obj, _s;
	        _s = this;
	        for (i = 0; i < this.max; i++) {
	            obj = {};
	            img = new Image();
	            _helpers.setAttr(img, "id", i);
	            img.onload = function() {
	                //回调
	                _s.notice(_s.getNode(this), "success", this);
	                //处理任务
	                _s.executeLink(this);
	            };
	            img.onerror = function() {
	                var node = _s.getNode(this);
	                //判断尝试次数
	                if (node.tries < config_default.tries) {
	                    node.tries = node.tries+1;
	                    //再次追加到任务链表末尾
	                    _s.appendNode(_s.createNode(node.src, node.options, node.notice, node.group, node.tries));
	                } else {
	                    //error回调
	                    //node.options.error.call(null, this.src);
	                    _s.notice(node, "error", this);
	                }
	                //处理任务
	                _s.executeLink(this);
	            };
	            obj.img = img;
	            obj.free = true;
	            this.pool.push(obj);
	        }
	    };
	    /**
	     * 回调封装
	     * @private
	     * @param node 节点。对象。
	     * @param status 状态。字符串。可选值：success(成功)|error(失败)
	     * @param img 图片。
	     */
	    ImagePool.prototype.notice = function(node, status, img) {
	        node.notice(status, img);
	    };
	    /**
	     * 处理链表任务
	     * @private
	     * @param dom 图像dom对象。对象。
	     */
	    ImagePool.prototype.executeLink = function(dom) {
	        //判断链表是否存在节点
	        if (this.linkHead) {
	            //加载下一个图片
	            this.setSrc(dom, this.linkHead);
	            //去除链表头
	            this.shiftNode();
	        } else {
	            //设置自身状态为空闲
	            this.status(dom, true);
	        }
	    };
	    /**
	     * 获取空闲"线程"
	     * @private
	     */
	    ImagePool.prototype.getFree = function() {
	        var length, i;
	        for (i = 0, length = this.pool.length; i < length; i++) {
	            if (this.pool[i].free) {
	                return this.pool[i];
	            }
	        }
	        return null;
	    };
	    /**
	     * 封装src属性设置
	     * 因为改变src属性相当于加载图片，所以把操作封装起来
	     * @private
	     * @param dom 图像dom对象。对象。
	     * @param node 节点。对象。
	     */
	    ImagePool.prototype.setSrc = function(dom, node) {
	        //设置池中的"线程"为非空闲状态
	        this.status(dom, false);
	        //关联节点
	        this.setNode(dom, node);
	        //加载图片
	        dom.src = node.src;
	    };
	    /**
	     * 更新池中的"线程"状态
	     * @private
	     * @param dom 图像dom对象。对象。
	     * @param status 状态。布尔。可选值：true(空闲)|false(非空闲)
	     */
	    ImagePool.prototype.status = function(dom, status) {
	        var id = _helpers.getAttr(dom, "id");
	        if(id){
	            this.pool[id].free = status;
	        }
	
	        //空闲状态，清除关联的节点
	        if (status) {
	            this.pool[id].node = null;
	        }
	    };
	    /**
	     * 更新池中的"线程"的关联节点
	     * @private
	     * @param dom 图像dom对象。对象。
	     * @param node 节点。对象。
	     */
	    ImagePool.prototype.setNode = function(dom, node) {
	        var id = _helpers.getAttr(dom, "id");
	        if(id){
	            this.pool[id].node = node;
	            return this.pool[id].node === node;
	        }
	
	    };
	    /**
	     * 获取池中的"线程"的关联节点
	     * @private
	     * @param dom 图像dom对象。对象。
	     */
	    ImagePool.prototype.getNode = function(dom) {
	        var id = _helpers.getAttr(dom, "id");
	        if(id){
	            return this.pool[id].node;
	        }
	
	    };
	    /**
	     * 对外接口，加载图片
	     * @private
	     * @param src 可以是src字符串，也可以是src字符串数组。
	     * @param options 用户自定义参数。包含：success回调、error回调、once标识。
	     */
	    ImagePool.prototype._load = function(src, options) {
	        var srcs = [],
	            free = null,
	            length = 0,
	            i = 0,
	            //只初始化一次回调策略
	            notice = (function() {
	                if (options.once) {
	                    return function(status, img) {
	                        var g = this.group,
	                            o = this.options;
	                        //记录
	                        g[status].push(img);
	                        //判断改组是否全部处理完成
	                        if (g.success.length + g.error.length === g.count) {
	                            //异步
	                            //实际上是作为另一个任务单独执行，防止回调函数执行时间过长影响图片加载速度
	                            setTimeout(function() {
	                                o.success.call(null, g.success, g.error, g.count);
	                            }, 1);
	                        }
	                    };
	                } else {
	                    return function(status, img) {
	                        var o = this.options;
	                        //直接回调
	                        setTimeout(function() {
	                            o[status].call(null, img);
	                        }, 1);
	                    };
	                }
	            }()),
	            group = {
	                count: 0,
	                success: [],
	                error: []
	            },
	            node = null;
	        options = options || {};
	        options.success = options.success || emptyFn;
	        options.error = options.error || emptyFn;
	        srcs = srcs.concat(src);
	        //设置组元素个数
	        group.count = srcs.length;
	        //遍历需要加载的图片
	        for (i = 0, length = srcs.length; i < length; i++) {
	            //创建节点
	            node = this.createNode(srcs[i], options, notice, group);
	            //判断线程池是否有空闲
	            free = this.getFree();
	            if (free) {
	                //有空闲，则立即加载图片
	                this.setSrc(free.img, node);
	            } else {
	                //没有空闲，将任务添加到链表
	                this.appendNode(node);
	            }
	        }
	    };
	    /**
	     * 获取内部状态信息
	     * @private
	     * @returns {Object}
	     */
	    ImagePool.prototype._info = function() {
	        var info = {},
	            length = 0,
	            i = 0,
	            node = null;
	        //线程
	        info.thread = {};
	        //线程总数量
	        info.thread.count = this.pool.length;
	        //空闲线程数量
	        info.thread.free = 0;
	        //任务
	        info.task = {};
	        //待处理任务数量
	        info.task.count = 0;
	        //获取空闲"线程"数量
	        for (i = 0, length = this.pool.length; i < length; i++) {
	            if (this.pool[i].free) {
	                info.thread.free = info.thread.free + 1;
	            }
	        }
	        //获取任务数量(任务链长度)
	        node = this.linkHead;
	        if (node) {
	            info.task.count = info.task.count + 1;
	            while (node.next) {
	                info.task.count = info.task.count + 1;
	                node = node.next;
	            }
	        }
	        return info;
	    };
	
	    /**
	     * 创建节点
	     * @private
	     * @param src 图片路径。字符串。
	     * @param options 用户自定义参数。包含：success回调、error回调、once标识。
	     * @param notice 回调策略。 函数。
	     * @param group 组信息。对象。{count: 0, success: [], error: []}
	     * @param tr 出错重试次数。数值。默认为0。
	     * @returns {Object}
	     */
	    ImagePool.prototype.createNode = function(src, options, notice, group, tr) {
	        var node = {};
	        node.src = src;
	        node.options = options;
	        node.notice = notice;
	        node.group = group;
	        node.tries = tr || 0;
	        return node;
	    };
	    /**
	     * 向任务链表末尾追加节点
	     * @private
	     * @param node 节点。对象。
	     */
	    ImagePool.prototype.appendNode = function(node) {
	        //判断链表是否为空
	        if (!this.linkHead) {
	            this.linkHead = node;
	            this.linkNode = node;
	        } else {
	            this.linkNode.next = node;
	            this.linkNode = node;
	        }
	    };
	    /**
	     * 删除链表头
	     * @private
	     */
	    ImagePool.prototype.shiftNode = function() {
	        //判断链表是否存在节点
	        if (this.linkHead) {
	            //修改链表头
	            this.linkHead = this.linkHead.next || null;
	        }
	    };
	    /**
	     * 初始化图片池
	     * @param {number} max 最大连接数。数值。
	     * @returns {{load: Function, info: Function}}
	     */
	    var initImagePool = function(max) {
	        var instance = new ImagePool(max);
	        instance.initPool();
	        return {
	            /**
	             * 加载图片
	             * @param {string|Array} src 可以是src字符串，也可以是src字符串数组。
	             * @param {Object} options 用户自定义参数。包含：success回调、error回调、once标识。
	             * @param {Function} [options.success] success回调
	             * @param {Function} [options.error] error回调
	             * @param {boolean} [options.once] 是否全部加载完毕后，一次回调
	             */
	            load: function() {
	                instance._load.apply(instance, arguments);
	            },
	            /**
	             * 获取内部状态信息
	             * @returns {Object}
	             */
	            info: function() {
	                return instance._info.call(instance);
	            }
	        };
	    };
	
	    module.exports = { initImagePool: initImagePool }
	


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	
	    var TooltipContent = __webpack_require__(134);
	    var globalListener = __webpack_require__(135);
	    var Model = __webpack_require__(87);
	    var zrUtil = __webpack_require__(5);
	    var env = __webpack_require__(50);
	    var flowUtil = __webpack_require__(94);
	    var layout = __webpack_require__(124);
	    function TooltipView(tooltipModel, api) {
	        this._tooltipContent = new TooltipContent(api.getDom(),api);
	        this._api = api;
	        this._tooltipModel = tooltipModel;
	        this._alwaysShowContent = tooltipModel.get('alwaysShowContent');
	        this._initGloablListener();
	    }
	
	    TooltipView.prototype._initGloablListener = function() {
	        var triggerOn = this._tooltipModel.get('triggerOn');
	        // 当有 'click' | 'mousemove' | 'none' 事件时触发回调
	        globalListener.register(
	            'itemTooltip',
	            this._api,
	            function(currTrigger, e, dispatchAction){
	                if (triggerOn !== 'none') {
	                    if (triggerOn.indexOf(currTrigger) >= 0 ) {
	                        this._tryShow(e, dispatchAction);
	                    }
	                    else if (currTrigger === 'leave') {
	                        this._hide(dispatchAction)
	                    }
	                }
	            }.bind(this)
	        )
	    };
	
	    TooltipView.prototype._tryShow = function(e, dispatchAction) {
	            var el = e.target;
	            var tooltipModel = this._tooltipModel;
	
	            if (!tooltipModel) {
	                return;
	            }
	
	            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed
	            this._lastX = e.offsetX;
	            this._lastY = e.offsetY;
	
	            if (el && el.tooltip) {
	                this._showComponentItemTooltip(e, el);
	            }
	            else {
	                this._hide(dispatchAction);
	            }
	    };
	
	     TooltipView.prototype._hide = function(dispatchAction) {
	            // Do not directly hideLater here, because this behavior may be prevented
	            // in dispatchAction when showTip is dispatched.
	
	            // FIXME
	            // duplicated hideTip if manuallyHideTip is called from dispatchAction.
	            this._lastDataByCoordSys = null;
	            dispatchAction({
	                type: 'hideTip',
	                from: this.uid
	            });
	            this.manuallyHideTip();
	        };
	
	       TooltipView.prototype.dispose = function () {
	            if (env.node) {
	                return;
	            }
	            this._tooltipContent.hide();
	            globalListener.unregister('itemTooltip', this._api);
	        };
	
	        TooltipView.prototype.manuallyHideTip = function () {
	            var tooltipContent = this._tooltipContent;
	
	            if (!this._alwaysShowContent) {
	                tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));
	            }
	
	            this._lastX = this._lastY = null;
	
	
	        },
	
	    TooltipView.prototype._showComponentItemTooltip = function (e, el) {
	            var tooltipOpt = el.tooltip;
	            if (typeof tooltipOpt === 'string') {
	                var content = tooltipOpt;
	                tooltipOpt = {
	                    content: content,
	                    // Fixed formatter
	                    formatter: content
	                };
	            }
	            var subTooltipModel = new Model(tooltipOpt, this._tooltipModel);
	            var defaultHtml = subTooltipModel.get('content');
	            var asyncTicket = Math.random();
	
	            // Do not check whether `trigger` is 'none' here, because `trigger`
	            // only works on cooridinate system. In fact, we have not found case
	            // that requires setting `trigger` nothing on component yet.
	
	            this._showOrMove(subTooltipModel, function () {
	                this._showTooltipContent(
	                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},
	                    asyncTicket, e.offsetX, e.offsetY, e.position, el
	                );
	            });
	
	
	        };
	
	      TooltipView.prototype._showOrMove = function (tooltipModel, cb) {
	            // showDelay is used in this case: tooltip.enterable is set
	            // as true. User intent to move mouse into tooltip and click
	            // something. `showDelay` makes it easyer to enter the content
	            // but tooltip do not move immediately.
	            var delay = tooltipModel.get('showDelay');
	            cb = zrUtil.bind(cb, this);
	            clearTimeout(this._showTimout);
	            delay > 0
	                ? (this._showTimout = setTimeout(cb, delay))
	                : cb();
	        };
	
	        TooltipView.prototype._showTooltipContent = function (tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el) {
	            // Reset ticket
	            this._ticket = '';
	
	            if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {
	                return;
	            }
	
	            var tooltipContent = this._tooltipContent;
	
	            var formatter = tooltipModel.get('formatter');
	            positionExpr = positionExpr || tooltipModel.get('position');
	            var html = defaultHtml;
	
	            if (formatter && typeof formatter === 'string') {
	                html = flowUtil.formatTpl(formatter, params, true);
	            }
	            else if (typeof formatter === 'function') {
	                var callback = function (cbTicket, html) {
	                    if (cbTicket === this._ticket) {
	                        tooltipContent.setContent(html);
	                        this._updatePosition(
	                            tooltipModel, positionExpr, x, y, tooltipContent, params, el
	                        );
	                    }
	                }.bind(this);
	                this._ticket = asyncTicket;
	                html = formatter(params, asyncTicket, callback);
	            }
	
	            tooltipContent.setContent(html);
	            tooltipContent.show(tooltipModel);
	
	            this._updatePosition(
	                tooltipModel, positionExpr, x, y, tooltipContent, params, el
	            );
	        };
	
	        /**
	         * @param  {string|Function|Array.<number>} positionExpr
	         * @param  {number} x Mouse x
	         * @param  {number} y Mouse y
	         * @param  {boolean} confine Whether confine tooltip content in view rect.
	         * @param  {Object|<Array.<Object>} params
	         * @param  {module:zrender/Element} el target element
	         * @param  {module:echarts/ExtensionAPI} api
	         * @return {Array.<number>}
	         */
	        TooltipView.prototype._updatePosition = function (tooltipModel, positionExpr, x, y, content, params, el) {
	            var viewWidth = this._api.getWidth();
	            var viewHeight = this._api.getHeight();
	            positionExpr = positionExpr || tooltipModel.get('position');
	
	            var contentSize = content.getSize();
	            var align = tooltipModel.get('align');
	            var vAlign = tooltipModel.get('verticalAlign');
	            var rect = el && el.getBoundingRect().clone();
	            el && rect.applyTransform(el.transform);
	
	            if (typeof positionExpr === 'function') {
	                // Callback of position can be an array or a string specify the position
	                positionExpr = positionExpr([x, y], params, content.el, rect, {
	                    viewSize: [viewWidth, viewHeight],
	                    contentSize: contentSize.slice()
	                });
	            }
	
	            if (zrUtil.isArray(positionExpr)) {
	                x = flowUtil.parsePercent(positionExpr[0], viewWidth);
	                y = flowUtil.parsePercent(positionExpr[1], viewHeight);
	            }
	            else if (zrUtil.isObject(positionExpr)) {
	                positionExpr.width = contentSize[0];
	                positionExpr.height = contentSize[1];
	                var layoutRect = layout.getLayoutRect(
	                    positionExpr, {width: viewWidth, height: viewHeight}
	                );
	                x = layoutRect.x;
	                y = layoutRect.y;
	                align = null;
	                // When positionExpr is left/top/right/bottom,
	                // align and verticalAlign will not work.
	                vAlign = null;
	            }
	            // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element
	            else if (typeof positionExpr === 'string' && el) {
	                var pos = calcTooltipPosition(
	                    positionExpr, rect, contentSize
	                );
	                x = pos[0];
	                y = pos[1];
	            }
	            else {
	                var pos1 = refixTooltipPosition(
	                    x, y, content.el, viewWidth, viewHeight, align ? 0 : 20, vAlign ? 0 : 20
	                );
	                x = pos1[0];
	                y = pos1[1];
	            }
	
	            align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);
	            vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);
	
	            if (tooltipModel.get('confine')) {
	                var pos2 = confineTooltipPosition(
	                    x, y, content.el, viewWidth, viewHeight
	                );
	                x = pos2[0];
	                y = pos2[1];
	            }
	
	            content.moveTo(x, y);
	        }
	
	    function calcTooltipPosition(position, rect, contentSize) {
	        var domWidth = contentSize[0];
	        var domHeight = contentSize[1];
	        var gap = 5;
	        var x = 0;
	        var y = 0;
	        var rectWidth = rect.width;
	        var rectHeight = rect.height;
	        switch (position) {
	            case 'inside':
	                x = rect.x + rectWidth / 2 - domWidth / 2;
	                y = rect.y + rectHeight / 2 - domHeight / 2;
	                break;
	            case 'top':
	                x = rect.x + rectWidth / 2 - domWidth / 2;
	                y = rect.y - domHeight - gap;
	                break;
	            case 'bottom':
	                x = rect.x + rectWidth / 2 - domWidth / 2;
	                y = rect.y + rectHeight + gap;
	                break;
	            case 'left':
	                x = rect.x - domWidth - gap;
	                y = rect.y + rectHeight / 2 - domHeight / 2;
	                break;
	            case 'right':
	                x = rect.x + rectWidth + gap;
	                y = rect.y + rectHeight / 2 - domHeight / 2;
	        }
	        return [x, y];
	    }
	    function refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {
	        var width = el.clientWidth;
	        var height = el.clientHeight;
	
	        if (x + width + gapH > viewWidth) {
	            x -= width + gapH;
	        }
	        else {
	            x += gapH;
	        }
	        if (y + height + gapV > viewHeight) {
	            y -= height + gapV;
	        }
	        else {
	            y += gapV;
	        }
	        return [x, y];
	    }
	
	    function isCenterAlign(align) {
	        return align === 'center' || align === 'middle';
	    }
	
	    function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {
	        var width = el.clientWidth;
	        var height = el.clientHeight;
	
	        x = Math.min(x + width, viewWidth) - width;
	        y = Math.min(y + height, viewHeight) - height;
	        x = Math.max(x, 0);
	        y = Math.max(y, 0);
	
	        return [x, y];
	    }
	    module.exports = TooltipView;


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	
	    var zrUtil = __webpack_require__(5);
	    var zrColor = __webpack_require__(20);
	    var env = __webpack_require__(50);
	    var eventUtil = __webpack_require__(77);
	    var flowUtil = __webpack_require__(94);
	    var toCamelCase = flowUtil.toCamelCase;
	    var normalizeCssArray = flowUtil.normalizeCssArray;
	    var each = zrUtil.each;
	
	
	    var vendors = ['', '-webkit-', '-moz-', '-o-'];
	
	    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:999;';//fish popup zindex:1050
	    /**
	     * @param {number} duration
	     * @return {string}
	     * @inner
	     */
	    function assembleTransition(duration) {
	        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';
	        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','
	                            + 'top ' + duration + 's ' + transitionCurve;
	        return zrUtil.map(vendors, function (vendorPrefix) {
	            return vendorPrefix + 'transition:' + transitionText;
	        }).join(';');
	    }
	
	    /**
	     * @param {Object} textStyle
	     * @return {string}
	     * @inner
	     */
	    function assembleFont(textStyleModel) {
	        var cssText = [];
	
	        var fontSize = textStyleModel.get('fontSize');
	        var color = textStyleModel.get("color");
	
	        color && cssText.push('color:' + color);
	
	        var font = textStyleModel.get("font");
	        font && cssText.push('font:' + font);
	
	        fontSize &&
	            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');
	
	        each(['decoration', 'align'], function (name) {
	            var val = textStyleModel.get(name);
	            val && cssText.push('text-' + name + ':' + val);
	        });
	
	        return cssText.join(';');
	    }
	    /**
	     * @param {Object} tooltipModel
	     * @return {string}
	     * @inner
	     */
	    function assembleCssText(tooltipModel) {
	
	        var cssText = [];
	
	        var transitionDuration = tooltipModel.get('transitionDuration');
	        var backgroundColor = tooltipModel.get('backgroundColor');
	        var textStyleModel = tooltipModel.getModel('textStyle');
	        var padding = tooltipModel.get('padding');
	
	        // Animation transition. Do not animate when transitionDuration is 0.
	        transitionDuration &&
	            cssText.push(assembleTransition(transitionDuration));
	
	        if (backgroundColor) {
	            if (env.canvasSupported) {
	                cssText.push('background-Color:' + backgroundColor);
	            }
	            else {
	                // for ie
	                cssText.push(
	                    'background-Color:#' + zrColor.toHex(backgroundColor)
	                );
	                cssText.push('filter:alpha(opacity=70)');
	            }
	        }
	
	        // Border style
	        each(['width', 'color', 'radius'], function (name) {
	            var borderName = 'border-' + name;
	            var camelCase = toCamelCase(borderName);
	            var val = tooltipModel.get(camelCase);
	            val != null &&
	                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));
	        });
	
	        // Text style
	        cssText.push(assembleFont(textStyleModel));
	
	        // Padding
	        if (padding != null) {
	            cssText.push('padding:' + normalizeCssArray(padding).join('px ') + 'px');
	        }
	
	        return cssText.join(';') + ';';
	    }
	    /**
	     *
	     *
	     * @param {any} container
	     * @param {any} api
	     */
	    function TooltipContent(container, api) {
	        var el = document.createElement('div');
	        var zr = this._zr = api.getZr();
	
	        this.el = el;
	
	        this._x = api.getWidth() / 2;
	        this._y = api.getHeight() / 2;
	
	        container.appendChild(el);
	
	        this._container = container;
	
	        this._show = false;
	
	        /**
	         * @private
	         */
	        this._hideTimeout;
	
	        var self = this;
	        el.onmouseenter = function () {
	            // clear the timeout in hideLater and keep showing tooltip
	            if (self._enterable) {
	                clearTimeout(self._hideTimeout);
	                self._show = true;
	            }
	            self._inContent = true;
	        };
	        el.onmousemove = function (e) {
	            e = e || window.event;
	            if (!self._enterable) {
	                // Try trigger zrender event to avoid mouse
	                // in and out shape too frequently
	                var handler = zr.handler;
	                eventUtil.normalizeEvent(container, e, true);
	                handler.dispatch('mousemove', e);
	            }
	        };
	        el.onmouseleave = function () {
	            if (self._enterable) {
	                if (self._show) {
	                    self.hideLater(self._hideDelay);
	                }
	            }
	            self._inContent = false;
	        };
	    }
	    TooltipContent.prototype = {
	
	        constructor: TooltipContent,
	
	        /**
	         * @private
	         * @type {boolean}
	         */
	        _enterable: true,
	
	        /**
	         * Update when tooltip is rendered
	         */
	        update: function () {
	            // FIXME
	            // Move this logic to ec main?
	            var container = this._container;
	            var stl = container.currentStyle
	                || document.defaultView.getComputedStyle(container);
	            var domStyle = container.style;
	            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {
	                domStyle.position = 'relative';
	            }
	            // Hide the tooltip
	            // PENDING
	            // this.hide();
	        },
	
	        show: function (tooltipModel) {
	            clearTimeout(this._hideTimeout);
	            var el = this.el;
	
	            el.style.cssText = gCssText + assembleCssText(tooltipModel)
	                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore
	                + ';left:' + this._x + 'px;top:' + this._y + 'px;'
	                + (tooltipModel.get('extraCssText') || '');
	
	            el.style.display = el.innerHTML ?  'block' : 'none';
	
	            this._show = true;
	        },
	
	        setContent: function (content) {
	            this.el.innerHTML = content;
	        },
	
	        setEnterable: function (enterable) {
	            this._enterable = enterable;
	        },
	
	        getSize: function () {
	            var el = this.el;
	            return [el.clientWidth, el.clientHeight];
	        },
	
	        moveTo: function (x, y) {
	            // xy should be based on canvas root. But tooltipContent is
	            // the sibling of canvas root. So padding of ec container
	            // should be considered here.
	            var zr = this._zr;
	            var viewportRoot;
	            if (zr && zr.painter && (viewportRoot = zr.painter.getViewportRoot())) {
	                x += viewportRoot.offsetLeft || 0;
	                y += viewportRoot.offsetTop || 0;
	            }
	
	            var style = this.el.style;
	            style.left = x + 'px';
	            style.top = y + 'px';
	
	            this._x = x;
	            this._y = y;
	        },
	
	        hide: function () {
	            this.el.style.display = 'none';
	            this._show = false;
	        },
	
	        hideLater: function (time) {
	            if (this._show && !(this._inContent && this._enterable)) {
	                if (time) {
	                    this._hideDelay = time;
	                    // Set show false to avoid invoke hideLater mutiple times
	                    this._show = false;
	                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);
	                }
	                else {
	                    this.hide();
	                }
	            }
	        },
	
	        isShow: function () {
	            return this._show;
	        }
	    };
	
	    module.exports = TooltipContent;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var env = __webpack_require__(50);
	    var zrUtil = __webpack_require__(5);
	    var get = __webpack_require__(94).makeGetter();
	
	    var each = zrUtil.each;
	
	    var globalListener = {};
	
	    /**
	     * @param key 注册的字符串
	     * @param api ExtensionAPI
	     * @param handler 处理回调
	     */
	    globalListener.register = function (key, api, handler) {
	        if (env.node) {   //node环境下不执行
	            return;
	        }
	        //判断zrender的 records  并初始化
	        var zr = api.getZr();
	        get(zr).records || (get(zr).records = {});
	
	        initGlobalListeners(zr, api);
	
	        //将回调加入record
	        var record = get(zr).records[key] || (get(zr).records[key] = {});
	        record.handler = handler;
	    };
	
	    /**
	     * 初始化全局侦听
	     *
	     * @param {object} zr   zrender
	     * @param {object} api  ExtensionAPI
	     * @returns
	     */
	    function initGlobalListeners(zr, api) {
	        if (get(zr).initialized) {   //避免重复初始化
	            return;
	        }
	
	        get(zr).initialized = true;
	
	        //侦听事件
	        useHandler('click', zrUtil.curry(doEnter, 'click'));
	        useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove'));
	        // useHandler('mouseout', onLeave);
	        useHandler('globalout', onLeave);
	
	        function useHandler(eventType, cb) {
	            zr.on(eventType, function (e) {
	                var dis = makeDispatchAction(api);
	                //遍历注册的 所有records， 并进行调用
	                each(get(zr).records, function (record) {
	                    record && cb(record, e, dis.dispatchAction);
	                });
	
	                dispatchTooltipFinally(dis.pendings, api);
	            });
	        }
	    }
	
	    function dispatchTooltipFinally(pendings, api) {
	        var showLen = pendings.showTip.length;
	        var hideLen = pendings.hideTip.length;
	
	        var actuallyPayload;
	        if (showLen) {
	            actuallyPayload = pendings.showTip[showLen - 1];
	        }
	        else if (hideLen) {
	            actuallyPayload = pendings.hideTip[hideLen - 1];
	        }
	        if (actuallyPayload) {
	            actuallyPayload.dispatchAction = null;
	            api.dispatchAction(actuallyPayload);
	        }
	    }
	
	    function onLeave(record, e, dispatchAction) {
	        record.handler('leave', null, dispatchAction);
	    }
	
	    function doEnter(currTrigger, record, e, dispatchAction) {
	        record.handler(currTrigger, e, dispatchAction);
	    }
	
	    /**
	     * 派发action   行将发生的
	     *
	     * @param {any} api
	     * @returns
	     */
	    function makeDispatchAction(api) {
	        var pendings = {
	            showTip: [],
	            hideTip: []
	        };
	        // FIXME
	        // better approach?
	        // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,
	        // which may be conflict, (axisPointer call showTip but tooltip call hideTip);
	        // So we have to add "final stage" to merge those dispatched actions.
	        var dispatchAction = function (payload) {
	            var pendingList = pendings[payload.type];
	            if (pendingList) {
	                pendingList.push(payload);
	            }
	            else {
	                payload.dispatchAction = dispatchAction;
	                api.dispatchAction(payload);
	            }
	        };
	
	        return {
	            dispatchAction: dispatchAction,
	            pendings: pendings
	        };
	    }
	
	    /**
	     * @param {string} key
	     * @param {module:echarts/ExtensionAPI} api
	     */
	    globalListener.unregister = function (key, api) {
	        if (env.node) {
	            return;
	        }
	        var zr = api.getZr();
	        var record = (get(zr).records || {})[key];
	        if (record) {
	            get(zr).records[key] = null;
	        }
	    };
	
	    module.exports = globalListener;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var Model = __webpack_require__(87);
	    module.exports = Model.extend({
	
	        type: 'tooltip',
	
	        defaultOption: {
	            zlevel: 0,
	
	            z: 8,
	
	            show: true,
	
	            // tooltip主体内容
	            showContent: true,
	
	
	
	            // 'click' | 'mousemove' | 'none'
	            triggerOn: 'mousemove',
	
	            alwaysShowContent: false,
	
	            displayMode: 'single', // 'single' | 'multipleByCoordSys'
	
	            // 位置 {Array} | {Function}
	            // position: null
	            // Consider triggered from axisPointer handle, verticalAlign should be 'middle'
	            // align: null,
	            // verticalAlign: null,
	
	            // 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。
	            confine: false,
	
	            // 内容格式器：{string}（Template） ¦ {Function}
	            // formatter: null
	
	            showDelay: 0,
	
	            // 隐藏延迟，单位ms
	            hideDelay: 100,
	
	            // 动画变换时间，单位s
	            transitionDuration: 0.4,
	
	            enterable: false,
	
	            // 提示背景颜色，默认为透明度为0.7的黑色
	            backgroundColor: 'rgba(50,50,50,0.7)',
	
	            // 提示边框颜色
	            borderColor: '#333',
	
	            // 提示边框圆角，单位px，默认为4
	            borderRadius: 4,
	
	            // 提示边框线宽，单位px，默认为0（无边框）
	            borderWidth: 0,
	
	            // 提示内边距，单位px，默认各方向内边距为5，
	            // 接受数组分别设定上右下左边距，同css
	            padding: 5,
	
	            // Extra css text
	            extraCssText: '',
	
	            textStyle: {
	                color: '#fff',
	                fontSize: 14
	            }
	        }
	    });


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(138);
	
	var _zrender = __webpack_require__(69);
	
	var registerPainter = _zrender.registerPainter;
	
	var Painter = __webpack_require__(140);
	
	registerPainter('vml', Painter);

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	var env = __webpack_require__(50);
	
	var _vector = __webpack_require__(15);
	
	var applyTransform = _vector.applyTransform;
	
	var BoundingRect = __webpack_require__(27);
	
	var colorTool = __webpack_require__(20);
	
	var textContain = __webpack_require__(26);
	
	var textHelper = __webpack_require__(25);
	
	var RectText = __webpack_require__(24);
	
	var Displayable = __webpack_require__(8);
	
	var ZImage = __webpack_require__(45);
	
	var Text = __webpack_require__(46);
	
	var Path = __webpack_require__(7);
	
	var PathProxy = __webpack_require__(30);
	
	var Gradient = __webpack_require__(42);
	
	var vmlCore = __webpack_require__(139);
	
	// http://www.w3.org/TR/NOTE-VML
	// TODO Use proxy like svg instead of overwrite brush methods
	var CMD = PathProxy.CMD;
	var round = Math.round;
	var sqrt = Math.sqrt;
	var abs = Math.abs;
	var cos = Math.cos;
	var sin = Math.sin;
	var mathMax = Math.max;
	
	if (!env.canvasSupported) {
	  var comma = ',';
	  var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';
	  var Z = 21600;
	  var Z2 = Z / 2;
	  var ZLEVEL_BASE = 100000;
	  var Z_BASE = 1000;
	
	  var initRootElStyle = function (el) {
	    el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';
	    el.coordsize = Z + ',' + Z;
	    el.coordorigin = '0,0';
	  };
	
	  var encodeHtmlAttribute = function (s) {
	    return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
	  };
	
	  var rgb2Str = function (r, g, b) {
	    return 'rgb(' + [r, g, b].join(',') + ')';
	  };
	
	  var append = function (parent, child) {
	    if (child && parent && child.parentNode !== parent) {
	      parent.appendChild(child);
	    }
	  };
	
	  var remove = function (parent, child) {
	    if (child && parent && child.parentNode === parent) {
	      parent.removeChild(child);
	    }
	  };
	
	  var getZIndex = function (zlevel, z, z2) {
	    // z 的取值范围为 [0, 1000]
	    return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;
	  };
	
	  var parsePercent = function (value, maxValue) {
	    if (typeof value === 'string') {
	      if (value.lastIndexOf('%') >= 0) {
	        return parseFloat(value) / 100 * maxValue;
	      }
	
	      return parseFloat(value);
	    }
	
	    return value;
	  };
	  /***************************************************
	   * PATH
	   **************************************************/
	
	
	  var setColorAndOpacity = function (el, color, opacity) {
	    var colorArr = colorTool.parse(color);
	    opacity = +opacity;
	
	    if (isNaN(opacity)) {
	      opacity = 1;
	    }
	
	    if (colorArr) {
	      el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);
	      el.opacity = opacity * colorArr[3];
	    }
	  };
	
	  var getColorAndAlpha = function (color) {
	    var colorArr = colorTool.parse(color);
	    return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];
	  };
	
	  var updateFillNode = function (el, style, zrEl) {
	    // TODO pattern
	    var fill = style.fill;
	
	    if (fill != null) {
	      // Modified from excanvas
	      if (fill instanceof Gradient) {
	        var gradientType;
	        var angle = 0;
	        var focus = [0, 0]; // additional offset
	
	        var shift = 0; // scale factor for offset
	
	        var expansion = 1;
	        var rect = zrEl.getBoundingRect();
	        var rectWidth = rect.width;
	        var rectHeight = rect.height;
	
	        if (fill.type === 'linear') {
	          gradientType = 'gradient';
	          var transform = zrEl.transform;
	          var p0 = [fill.x * rectWidth, fill.y * rectHeight];
	          var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];
	
	          if (transform) {
	            applyTransform(p0, p0, transform);
	            applyTransform(p1, p1, transform);
	          }
	
	          var dx = p1[0] - p0[0];
	          var dy = p1[1] - p0[1];
	          angle = Math.atan2(dx, dy) * 180 / Math.PI; // The angle should be a non-negative number.
	
	          if (angle < 0) {
	            angle += 360;
	          } // Very small angles produce an unexpected result because they are
	          // converted to a scientific notation string.
	
	
	          if (angle < 1e-6) {
	            angle = 0;
	          }
	        } else {
	          gradientType = 'gradientradial';
	          var p0 = [fill.x * rectWidth, fill.y * rectHeight];
	          var transform = zrEl.transform;
	          var scale = zrEl.scale;
	          var width = rectWidth;
	          var height = rectHeight;
	          focus = [// Percent in bounding rect
	          (p0[0] - rect.x) / width, (p0[1] - rect.y) / height];
	
	          if (transform) {
	            applyTransform(p0, p0, transform);
	          }
	
	          width /= scale[0] * Z;
	          height /= scale[1] * Z;
	          var dimension = mathMax(width, height);
	          shift = 2 * 0 / dimension;
	          expansion = 2 * fill.r / dimension - shift;
	        } // We need to sort the color stops in ascending order by offset,
	        // otherwise IE won't interpret it correctly.
	
	
	        var stops = fill.colorStops.slice();
	        stops.sort(function (cs1, cs2) {
	          return cs1.offset - cs2.offset;
	        });
	        var length = stops.length; // Color and alpha list of first and last stop
	
	        var colorAndAlphaList = [];
	        var colors = [];
	
	        for (var i = 0; i < length; i++) {
	          var stop = stops[i];
	          var colorAndAlpha = getColorAndAlpha(stop.color);
	          colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);
	
	          if (i === 0 || i === length - 1) {
	            colorAndAlphaList.push(colorAndAlpha);
	          }
	        }
	
	        if (length >= 2) {
	          var color1 = colorAndAlphaList[0][0];
	          var color2 = colorAndAlphaList[1][0];
	          var opacity1 = colorAndAlphaList[0][1] * style.opacity;
	          var opacity2 = colorAndAlphaList[1][1] * style.opacity;
	          el.type = gradientType;
	          el.method = 'none';
	          el.focus = '100%';
	          el.angle = angle;
	          el.color = color1;
	          el.color2 = color2;
	          el.colors = colors.join(','); // When colors attribute is used, the meanings of opacity and o:opacity2
	          // are reversed.
	
	          el.opacity = opacity2; // FIXME g_o_:opacity ?
	
	          el.opacity2 = opacity1;
	        }
	
	        if (gradientType === 'radial') {
	          el.focusposition = focus.join(',');
	        }
	      } else {
	        // FIXME Change from Gradient fill to color fill
	        setColorAndOpacity(el, fill, style.opacity);
	      }
	    }
	  };
	
	  var updateStrokeNode = function (el, style) {
	    // if (style.lineJoin != null) {
	    //     el.joinstyle = style.lineJoin;
	    // }
	    // if (style.miterLimit != null) {
	    //     el.miterlimit = style.miterLimit * Z;
	    // }
	    // if (style.lineCap != null) {
	    //     el.endcap = style.lineCap;
	    // }
	    if (style.lineDash != null) {
	      el.dashstyle = style.lineDash.join(' ');
	    }
	
	    if (style.stroke != null && !(style.stroke instanceof Gradient)) {
	      setColorAndOpacity(el, style.stroke, style.opacity);
	    }
	  };
	
	  var updateFillAndStroke = function (vmlEl, type, style, zrEl) {
	    var isFill = type == 'fill';
	    var el = vmlEl.getElementsByTagName(type)[0]; // Stroke must have lineWidth
	
	    if (style[type] != null && style[type] !== 'none' && (isFill || !isFill && style.lineWidth)) {
	      vmlEl[isFill ? 'filled' : 'stroked'] = 'true'; // FIXME Remove before updating, or set `colors` will throw error
	
	      if (style[type] instanceof Gradient) {
	        remove(vmlEl, el);
	      }
	
	      if (!el) {
	        el = vmlCore.createNode(type);
	      }
	
	      isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);
	      append(vmlEl, el);
	    } else {
	      vmlEl[isFill ? 'filled' : 'stroked'] = 'false';
	      remove(vmlEl, el);
	    }
	  };
	
	  var points = [[], [], []];
	
	  var pathDataToString = function (path, m) {
	    var M = CMD.M;
	    var C = CMD.C;
	    var L = CMD.L;
	    var A = CMD.A;
	    var Q = CMD.Q;
	    var str = [];
	    var nPoint;
	    var cmdStr;
	    var cmd;
	    var i;
	    var xi;
	    var yi;
	    var data = path.data;
	    var dataLength = path.len();
	
	    for (i = 0; i < dataLength;) {
	      cmd = data[i++];
	      cmdStr = '';
	      nPoint = 0;
	
	      switch (cmd) {
	        case M:
	          cmdStr = ' m ';
	          nPoint = 1;
	          xi = data[i++];
	          yi = data[i++];
	          points[0][0] = xi;
	          points[0][1] = yi;
	          break;
	
	        case L:
	          cmdStr = ' l ';
	          nPoint = 1;
	          xi = data[i++];
	          yi = data[i++];
	          points[0][0] = xi;
	          points[0][1] = yi;
	          break;
	
	        case Q:
	        case C:
	          cmdStr = ' c ';
	          nPoint = 3;
	          var x1 = data[i++];
	          var y1 = data[i++];
	          var x2 = data[i++];
	          var y2 = data[i++];
	          var x3;
	          var y3;
	
	          if (cmd === Q) {
	            // Convert quadratic to cubic using degree elevation
	            x3 = x2;
	            y3 = y2;
	            x2 = (x2 + 2 * x1) / 3;
	            y2 = (y2 + 2 * y1) / 3;
	            x1 = (xi + 2 * x1) / 3;
	            y1 = (yi + 2 * y1) / 3;
	          } else {
	            x3 = data[i++];
	            y3 = data[i++];
	          }
	
	          points[0][0] = x1;
	          points[0][1] = y1;
	          points[1][0] = x2;
	          points[1][1] = y2;
	          points[2][0] = x3;
	          points[2][1] = y3;
	          xi = x3;
	          yi = y3;
	          break;
	
	        case A:
	          var x = 0;
	          var y = 0;
	          var sx = 1;
	          var sy = 1;
	          var angle = 0;
	
	          if (m) {
	            // Extract SRT from matrix
	            x = m[4];
	            y = m[5];
	            sx = sqrt(m[0] * m[0] + m[1] * m[1]);
	            sy = sqrt(m[2] * m[2] + m[3] * m[3]);
	            angle = Math.atan2(-m[1] / sy, m[0] / sx);
	          }
	
	          var cx = data[i++];
	          var cy = data[i++];
	          var rx = data[i++];
	          var ry = data[i++];
	          var startAngle = data[i++] + angle;
	          var endAngle = data[i++] + startAngle + angle; // FIXME
	          // var psi = data[i++];
	
	          i++;
	          var clockwise = data[i++];
	          var x0 = cx + cos(startAngle) * rx;
	          var y0 = cy + sin(startAngle) * ry;
	          var x1 = cx + cos(endAngle) * rx;
	          var y1 = cy + sin(endAngle) * ry;
	          var type = clockwise ? ' wa ' : ' at ';
	
	          if (Math.abs(x0 - x1) < 1e-4) {
	            // IE won't render arches drawn counter clockwise if x0 == x1.
	            if (Math.abs(endAngle - startAngle) > 1e-2) {
	              // Offset x0 by 1/80 of a pixel. Use something
	              // that can be represented in binary
	              if (clockwise) {
	                x0 += 270 / Z;
	              }
	            } else {
	              // Avoid case draw full circle
	              if (Math.abs(y0 - cy) < 1e-4) {
	                if (clockwise && x0 < cx || !clockwise && x0 > cx) {
	                  y1 -= 270 / Z;
	                } else {
	                  y1 += 270 / Z;
	                }
	              } else if (clockwise && y0 < cy || !clockwise && y0 > cy) {
	                x1 += 270 / Z;
	              } else {
	                x1 -= 270 / Z;
	              }
	            }
	          }
	
	          str.push(type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2));
	          xi = x1;
	          yi = y1;
	          break;
	
	        case CMD.R:
	          var p0 = points[0];
	          var p1 = points[1]; // x0, y0
	
	          p0[0] = data[i++];
	          p0[1] = data[i++]; // x1, y1
	
	          p1[0] = p0[0] + data[i++];
	          p1[1] = p0[1] + data[i++];
	
	          if (m) {
	            applyTransform(p0, p0, m);
	            applyTransform(p1, p1, m);
	          }
	
	          p0[0] = round(p0[0] * Z - Z2);
	          p1[0] = round(p1[0] * Z - Z2);
	          p0[1] = round(p0[1] * Z - Z2);
	          p1[1] = round(p1[1] * Z - Z2);
	          str.push( // x0, y0
	          ' m ', p0[0], comma, p0[1], // x1, y0
	          ' l ', p1[0], comma, p0[1], // x1, y1
	          ' l ', p1[0], comma, p1[1], // x0, y1
	          ' l ', p0[0], comma, p1[1]);
	          break;
	
	        case CMD.Z:
	          // FIXME Update xi, yi
	          str.push(' x ');
	      }
	
	      if (nPoint > 0) {
	        str.push(cmdStr);
	
	        for (var k = 0; k < nPoint; k++) {
	          var p = points[k];
	          m && applyTransform(p, p, m); // 不 round 会非常慢
	
	          str.push(round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k < nPoint - 1 ? comma : '');
	        }
	      }
	    }
	
	    return str.join('');
	  }; // Rewrite the original path method
	
	
	  Path.prototype.brushVML = function (vmlRoot) {
	    var style = this.style;
	    var vmlEl = this._vmlEl;
	
	    if (!vmlEl) {
	      vmlEl = vmlCore.createNode('shape');
	      initRootElStyle(vmlEl);
	      this._vmlEl = vmlEl;
	    }
	
	    updateFillAndStroke(vmlEl, 'fill', style, this);
	    updateFillAndStroke(vmlEl, 'stroke', style, this);
	    var m = this.transform;
	    var needTransform = m != null;
	    var strokeEl = vmlEl.getElementsByTagName('stroke')[0];
	
	    if (strokeEl) {
	      var lineWidth = style.lineWidth; // Get the line scale.
	      // Determinant of this.m_ means how much the area is enlarged by the
	      // transformation. So its square root can be used as a scale factor
	      // for width.
	
	      if (needTransform && !style.strokeNoScale) {
	        var det = m[0] * m[3] - m[1] * m[2];
	        lineWidth *= sqrt(abs(det));
	      }
	
	      strokeEl.weight = lineWidth + 'px';
	    }
	
	    var path = this.path || (this.path = new PathProxy());
	
	    if (this.__dirtyPath) {
	      path.beginPath();
	      this.buildPath(path, this.shape);
	      path.toStatic();
	      this.__dirtyPath = false;
	    }
	
	    vmlEl.path = pathDataToString(path, this.transform);
	    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root
	
	    append(vmlRoot, vmlEl); // Text
	
	    if (style.text != null) {
	      this.drawRectText(vmlRoot, this.getBoundingRect());
	    } else {
	      this.removeRectText(vmlRoot);
	    }
	  };
	
	  Path.prototype.onRemove = function (vmlRoot) {
	    remove(vmlRoot, this._vmlEl);
	    this.removeRectText(vmlRoot);
	  };
	
	  Path.prototype.onAdd = function (vmlRoot) {
	    append(vmlRoot, this._vmlEl);
	    this.appendRectText(vmlRoot);
	  };
	  /***************************************************
	   * IMAGE
	   **************************************************/
	
	
	  var isImage = function (img) {
	    // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错
	    return typeof img === 'object' && img.tagName && img.tagName.toUpperCase() === 'IMG'; // return img instanceof Image;
	  }; // Rewrite the original path method
	
	
	  ZImage.prototype.brushVML = function (vmlRoot) {
	    var style = this.style;
	    var image = style.image; // Image original width, height
	
	    var ow;
	    var oh;
	
	    if (isImage(image)) {
	      var src = image.src;
	
	      if (src === this._imageSrc) {
	        ow = this._imageWidth;
	        oh = this._imageHeight;
	      } else {
	        var imageRuntimeStyle = image.runtimeStyle;
	        var oldRuntimeWidth = imageRuntimeStyle.width;
	        var oldRuntimeHeight = imageRuntimeStyle.height;
	        imageRuntimeStyle.width = 'auto';
	        imageRuntimeStyle.height = 'auto'; // get the original size
	
	        ow = image.width;
	        oh = image.height; // and remove overides
	
	        imageRuntimeStyle.width = oldRuntimeWidth;
	        imageRuntimeStyle.height = oldRuntimeHeight; // Caching image original width, height and src
	
	        this._imageSrc = src;
	        this._imageWidth = ow;
	        this._imageHeight = oh;
	      }
	
	      image = src;
	    } else {
	      if (image === this._imageSrc) {
	        ow = this._imageWidth;
	        oh = this._imageHeight;
	      }
	    }
	
	    if (!image) {
	      return;
	    }
	
	    var x = style.x || 0;
	    var y = style.y || 0;
	    var dw = style.width;
	    var dh = style.height;
	    var sw = style.sWidth;
	    var sh = style.sHeight;
	    var sx = style.sx || 0;
	    var sy = style.sy || 0;
	    var hasCrop = sw && sh;
	    var vmlEl = this._vmlEl;
	
	    if (!vmlEl) {
	      // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。
	      // vmlEl = vmlCore.createNode('group');
	      vmlEl = vmlCore.doc.createElement('div');
	      initRootElStyle(vmlEl);
	      this._vmlEl = vmlEl;
	    }
	
	    var vmlElStyle = vmlEl.style;
	    var hasRotation = false;
	    var m;
	    var scaleX = 1;
	    var scaleY = 1;
	
	    if (this.transform) {
	      m = this.transform;
	      scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);
	      scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);
	      hasRotation = m[1] || m[2];
	    }
	
	    if (hasRotation) {
	      // If filters are necessary (rotation exists), create them
	      // filters are bog-slow, so only create them if abbsolutely necessary
	      // The following check doesn't account for skews (which don't exist
	      // in the canvas spec (yet) anyway.
	      // From excanvas
	      var p0 = [x, y];
	      var p1 = [x + dw, y];
	      var p2 = [x, y + dh];
	      var p3 = [x + dw, y + dh];
	      applyTransform(p0, p0, m);
	      applyTransform(p1, p1, m);
	      applyTransform(p2, p2, m);
	      applyTransform(p3, p3, m);
	      var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);
	      var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);
	      var transformFilter = [];
	      transformFilter.push('M11=', m[0] / scaleX, comma, 'M12=', m[2] / scaleY, comma, 'M21=', m[1] / scaleX, comma, 'M22=', m[3] / scaleY, comma, 'Dx=', round(x * scaleX + m[4]), comma, 'Dy=', round(y * scaleY + m[5]));
	      vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0'; // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用
	
	      vmlElStyle.filter = imageTransformPrefix + '.Matrix(' + transformFilter.join('') + ', SizingMethod=clip)';
	    } else {
	      if (m) {
	        x = x * scaleX + m[4];
	        y = y * scaleY + m[5];
	      }
	
	      vmlElStyle.filter = '';
	      vmlElStyle.left = round(x) + 'px';
	      vmlElStyle.top = round(y) + 'px';
	    }
	
	    var imageEl = this._imageEl;
	    var cropEl = this._cropEl;
	
	    if (!imageEl) {
	      imageEl = vmlCore.doc.createElement('div');
	      this._imageEl = imageEl;
	    }
	
	    var imageELStyle = imageEl.style;
	
	    if (hasCrop) {
	      // Needs know image original width and height
	      if (!(ow && oh)) {
	        var tmpImage = new Image();
	        var self = this;
	
	        tmpImage.onload = function () {
	          tmpImage.onload = null;
	          ow = tmpImage.width;
	          oh = tmpImage.height; // Adjust image width and height to fit the ratio destinationSize / sourceSize
	
	          imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
	          imageELStyle.height = round(scaleY * oh * dh / sh) + 'px'; // Caching image original width, height and src
	
	          self._imageWidth = ow;
	          self._imageHeight = oh;
	          self._imageSrc = image;
	        };
	
	        tmpImage.src = image;
	      } else {
	        imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
	        imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';
	      }
	
	      if (!cropEl) {
	        cropEl = vmlCore.doc.createElement('div');
	        cropEl.style.overflow = 'hidden';
	        this._cropEl = cropEl;
	      }
	
	      var cropElStyle = cropEl.style;
	      cropElStyle.width = round((dw + sx * dw / sw) * scaleX);
	      cropElStyle.height = round((dh + sy * dh / sh) * scaleY);
	      cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx=' + -sx * dw / sw * scaleX + ',Dy=' + -sy * dh / sh * scaleY + ')';
	
	      if (!cropEl.parentNode) {
	        vmlEl.appendChild(cropEl);
	      }
	
	      if (imageEl.parentNode != cropEl) {
	        cropEl.appendChild(imageEl);
	      }
	    } else {
	      imageELStyle.width = round(scaleX * dw) + 'px';
	      imageELStyle.height = round(scaleY * dh) + 'px';
	      vmlEl.appendChild(imageEl);
	
	      if (cropEl && cropEl.parentNode) {
	        vmlEl.removeChild(cropEl);
	        this._cropEl = null;
	      }
	    }
	
	    var filterStr = '';
	    var alpha = style.opacity;
	
	    if (alpha < 1) {
	      filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';
	    }
	
	    filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';
	    imageELStyle.filter = filterStr;
	    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root
	
	    append(vmlRoot, vmlEl); // Text
	
	    if (style.text != null) {
	      this.drawRectText(vmlRoot, this.getBoundingRect());
	    }
	  };
	
	  ZImage.prototype.onRemove = function (vmlRoot) {
	    remove(vmlRoot, this._vmlEl);
	    this._vmlEl = null;
	    this._cropEl = null;
	    this._imageEl = null;
	    this.removeRectText(vmlRoot);
	  };
	
	  ZImage.prototype.onAdd = function (vmlRoot) {
	    append(vmlRoot, this._vmlEl);
	    this.appendRectText(vmlRoot);
	  };
	  /***************************************************
	   * TEXT
	   **************************************************/
	
	
	  var DEFAULT_STYLE_NORMAL = 'normal';
	  var fontStyleCache = {};
	  var fontStyleCacheCount = 0;
	  var MAX_FONT_CACHE_SIZE = 100;
	  var fontEl = document.createElement('div');
	
	  var getFontStyle = function (fontString) {
	    var fontStyle = fontStyleCache[fontString];
	
	    if (!fontStyle) {
	      // Clear cache
	      if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {
	        fontStyleCacheCount = 0;
	        fontStyleCache = {};
	      }
	
	      var style = fontEl.style;
	      var fontFamily;
	
	      try {
	        style.font = fontString;
	        fontFamily = style.fontFamily.split(',')[0];
	      } catch (e) {}
	
	      fontStyle = {
	        style: style.fontStyle || DEFAULT_STYLE_NORMAL,
	        variant: style.fontVariant || DEFAULT_STYLE_NORMAL,
	        weight: style.fontWeight || DEFAULT_STYLE_NORMAL,
	        size: parseFloat(style.fontSize || 12) | 0,
	        family: fontFamily || 'Microsoft YaHei'
	      };
	      fontStyleCache[fontString] = fontStyle;
	      fontStyleCacheCount++;
	    }
	
	    return fontStyle;
	  };
	
	  var textMeasureEl; // Overwrite measure text method
	
	  textContain.$override('measureText', function (text, textFont) {
	    var doc = vmlCore.doc;
	
	    if (!textMeasureEl) {
	      textMeasureEl = doc.createElement('div');
	      textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;' + 'padding:0;margin:0;border:none;white-space:pre;';
	      vmlCore.doc.body.appendChild(textMeasureEl);
	    }
	
	    try {
	      textMeasureEl.style.font = textFont;
	    } catch (ex) {// Ignore failures to set to invalid font.
	    }
	
	    textMeasureEl.innerHTML = ''; // Don't use innerHTML or innerText because they allow markup/whitespace.
	
	    textMeasureEl.appendChild(doc.createTextNode(text));
	    return {
	      width: textMeasureEl.offsetWidth
	    };
	  });
	  var tmpRect = new BoundingRect();
	
	  var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {
	    var style = this.style; // Optimize, avoid normalize every time.
	
	    this.__dirty && textHelper.normalizeTextStyle(style, true);
	    var text = style.text; // Convert to string
	
	    text != null && (text += '');
	
	    if (!text) {
	      return;
	    } // Convert rich text to plain text. Rich text is not supported in
	    // IE8-, but tags in rich text template will be removed.
	
	
	    if (style.rich) {
	      var contentBlock = textContain.parseRichText(text, style);
	      text = [];
	
	      for (var i = 0; i < contentBlock.lines.length; i++) {
	        var tokens = contentBlock.lines[i].tokens;
	        var textLine = [];
	
	        for (var j = 0; j < tokens.length; j++) {
	          textLine.push(tokens[j].text);
	        }
	
	        text.push(textLine.join(''));
	      }
	
	      text = text.join('\n');
	    }
	
	    var x;
	    var y;
	    var align = style.textAlign;
	    var verticalAlign = style.textVerticalAlign;
	    var fontStyle = getFontStyle(style.font); // FIXME encodeHtmlAttribute ?
	
	    var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' ' + fontStyle.size + 'px "' + fontStyle.family + '"';
	    textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign); // Transform rect to view space
	
	    var m = this.transform; // Ignore transform for text in other element
	
	    if (m && !fromTextEl) {
	      tmpRect.copy(rect);
	      tmpRect.applyTransform(m);
	      rect = tmpRect;
	    }
	
	    if (!fromTextEl) {
	      var textPosition = style.textPosition;
	      var distance = style.textDistance; // Text position represented by coord
	
	      if (textPosition instanceof Array) {
	        x = rect.x + parsePercent(textPosition[0], rect.width);
	        y = rect.y + parsePercent(textPosition[1], rect.height);
	        align = align || 'left';
	      } else {
	        var res = textContain.adjustTextPositionOnRect(textPosition, rect, distance);
	        x = res.x;
	        y = res.y; // Default align and baseline when has textPosition
	
	        align = align || res.textAlign;
	        verticalAlign = verticalAlign || res.textVerticalAlign;
	      }
	    } else {
	      x = rect.x;
	      y = rect.y;
	    }
	
	    x = textContain.adjustTextX(x, textRect.width, align);
	    y = textContain.adjustTextY(y, textRect.height, verticalAlign); // Force baseline 'middle'
	
	    y += textRect.height / 2; // var fontSize = fontStyle.size;
	    // 1.75 is an arbitrary number, as there is no info about the text baseline
	    // switch (baseline) {
	    // case 'hanging':
	    // case 'top':
	    //     y += fontSize / 1.75;
	    //     break;
	    //     case 'middle':
	    //         break;
	    //     default:
	    //     // case null:
	    //     // case 'alphabetic':
	    //     // case 'ideographic':
	    //     // case 'bottom':
	    //         y -= fontSize / 2.25;
	    //         break;
	    // }
	    // switch (align) {
	    //     case 'left':
	    //         break;
	    //     case 'center':
	    //         x -= textRect.width / 2;
	    //         break;
	    //     case 'right':
	    //         x -= textRect.width;
	    //         break;
	    // case 'end':
	    // align = elementStyle.direction == 'ltr' ? 'right' : 'left';
	    // break;
	    // case 'start':
	    // align = elementStyle.direction == 'rtl' ? 'right' : 'left';
	    // break;
	    // default:
	    //     align = 'left';
	    // }
	
	    var createNode = vmlCore.createNode;
	    var textVmlEl = this._textVmlEl;
	    var pathEl;
	    var textPathEl;
	    var skewEl;
	
	    if (!textVmlEl) {
	      textVmlEl = createNode('line');
	      pathEl = createNode('path');
	      textPathEl = createNode('textpath');
	      skewEl = createNode('skew'); // FIXME Why here is not cammel case
	      // Align 'center' seems wrong
	
	      textPathEl.style['v-text-align'] = 'left';
	      initRootElStyle(textVmlEl);
	      pathEl.textpathok = true;
	      textPathEl.on = true;
	      textVmlEl.from = '0 0';
	      textVmlEl.to = '1000 0.05';
	      append(textVmlEl, skewEl);
	      append(textVmlEl, pathEl);
	      append(textVmlEl, textPathEl);
	      this._textVmlEl = textVmlEl;
	    } else {
	      // 这里是在前面 appendChild 保证顺序的前提下
	      skewEl = textVmlEl.firstChild;
	      pathEl = skewEl.nextSibling;
	      textPathEl = pathEl.nextSibling;
	    }
	
	    var coords = [x, y];
	    var textVmlElStyle = textVmlEl.style; // Ignore transform for text in other element
	
	    if (m && fromTextEl) {
	      applyTransform(coords, coords, m);
	      skewEl.on = true;
	      skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0'; // Text position
	
	      skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0); // Left top point as origin
	
	      skewEl.origin = '0 0';
	      textVmlElStyle.left = '0px';
	      textVmlElStyle.top = '0px';
	    } else {
	      skewEl.on = false;
	      textVmlElStyle.left = round(x) + 'px';
	      textVmlElStyle.top = round(y) + 'px';
	    }
	
	    textPathEl.string = encodeHtmlAttribute(text); // TODO
	
	    try {
	      textPathEl.style.font = font;
	    } // Error font format
	    catch (e) {}
	
	    updateFillAndStroke(textVmlEl, 'fill', {
	      fill: style.textFill,
	      opacity: style.opacity
	    }, this);
	    updateFillAndStroke(textVmlEl, 'stroke', {
	      stroke: style.textStroke,
	      opacity: style.opacity,
	      lineDash: style.lineDash
	    }, this);
	    textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Attached to root
	
	    append(vmlRoot, textVmlEl);
	  };
	
	  var removeRectText = function (vmlRoot) {
	    remove(vmlRoot, this._textVmlEl);
	    this._textVmlEl = null;
	  };
	
	  var appendRectText = function (vmlRoot) {
	    append(vmlRoot, this._textVmlEl);
	  };
	
	  var list = [RectText, Displayable, ZImage, Path, Text]; // In case Displayable has been mixed in RectText
	
	  for (var i = 0; i < list.length; i++) {
	    var proto = list[i].prototype;
	    proto.drawRectText = drawRectText;
	    proto.removeRectText = removeRectText;
	    proto.appendRectText = appendRectText;
	  }
	
	  Text.prototype.brushVML = function (vmlRoot) {
	    var style = this.style;
	
	    if (style.text != null) {
	      this.drawRectText(vmlRoot, {
	        x: style.x || 0,
	        y: style.y || 0,
	        width: 0,
	        height: 0
	      }, this.getBoundingRect(), true);
	    } else {
	      this.removeRectText(vmlRoot);
	    }
	  };
	
	  Text.prototype.onRemove = function (vmlRoot) {
	    this.removeRectText(vmlRoot);
	  };
	
	  Text.prototype.onAdd = function (vmlRoot) {
	    this.appendRectText(vmlRoot);
	  };
	}

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	var env = __webpack_require__(50);
	
	var urn = 'urn:schemas-microsoft-com:vml';
	var win = typeof window === 'undefined' ? null : window;
	var vmlInited = false;
	var doc = win && win.document;
	
	function createNode(tagName) {
	  return doCreateNode(tagName);
	} // Avoid assign to an exported variable, for transforming to cjs.
	
	
	var doCreateNode;
	
	if (doc && !env.canvasSupported) {
	  try {
	    !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);
	
	    doCreateNode = function (tagName) {
	      return doc.createElement('<zrvml:' + tagName + ' class="zrvml">');
	    };
	  } catch (e) {
	    doCreateNode = function (tagName) {
	      return doc.createElement('<' + tagName + ' xmlns="' + urn + '" class="zrvml">');
	    };
	  }
	} // From raphael
	
	
	function initVML() {
	  if (vmlInited || !doc) {
	    return;
	  }
	
	  vmlInited = true;
	  var styleSheets = doc.styleSheets;
	
	  if (styleSheets.length < 31) {
	    doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');
	  } else {
	    // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx
	    styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');
	  }
	}
	
	exports.doc = doc;
	exports.createNode = createNode;
	exports.initVML = initVML;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	var zrLog = __webpack_require__(22);
	
	var vmlCore = __webpack_require__(139);
	
	var _util = __webpack_require__(5);
	
	var each = _util.each;
	
	/**
	 * VML Painter.
	 *
	 * @module zrender/vml/Painter
	 */
	function parseInt10(val) {
	  return parseInt(val, 10);
	}
	/**
	 * @alias module:zrender/vml/Painter
	 */
	
	
	function VMLPainter(root, storage) {
	  vmlCore.initVML();
	  this.root = root;
	  this.storage = storage;
	  var vmlViewport = document.createElement('div');
	  var vmlRoot = document.createElement('div');
	  vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';
	  vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';
	  root.appendChild(vmlViewport);
	  this._vmlRoot = vmlRoot;
	  this._vmlViewport = vmlViewport;
	  this.resize(); // Modify storage
	
	  var oldDelFromStorage = storage.delFromStorage;
	  var oldAddToStorage = storage.addToStorage;
	
	  storage.delFromStorage = function (el) {
	    oldDelFromStorage.call(storage, el);
	
	    if (el) {
	      el.onRemove && el.onRemove(vmlRoot);
	    }
	  };
	
	  storage.addToStorage = function (el) {
	    // Displayable already has a vml node
	    el.onAdd && el.onAdd(vmlRoot);
	    oldAddToStorage.call(storage, el);
	  };
	
	  this._firstPaint = true;
	}
	
	VMLPainter.prototype = {
	  constructor: VMLPainter,
	  getType: function () {
	    return 'vml';
	  },
	
	  /**
	   * @return {HTMLDivElement}
	   */
	  getViewportRoot: function () {
	    return this._vmlViewport;
	  },
	  getViewportRootOffset: function () {
	    var viewportRoot = this.getViewportRoot();
	
	    if (viewportRoot) {
	      return {
	        offsetLeft: viewportRoot.offsetLeft || 0,
	        offsetTop: viewportRoot.offsetTop || 0
	      };
	    }
	  },
	
	  /**
	   * 刷新
	   */
	  refresh: function () {
	    var list = this.storage.getDisplayList(true, true);
	
	    this._paintList(list);
	  },
	  _paintList: function (list) {
	    var vmlRoot = this._vmlRoot;
	
	    for (var i = 0; i < list.length; i++) {
	      var el = list[i];
	
	      if (el.invisible || el.ignore) {
	        if (!el.__alreadyNotVisible) {
	          el.onRemove(vmlRoot);
	        } // Set as already invisible
	
	
	        el.__alreadyNotVisible = true;
	      } else {
	        if (el.__alreadyNotVisible) {
	          el.onAdd(vmlRoot);
	        }
	
	        el.__alreadyNotVisible = false;
	
	        if (el.__dirty) {
	          el.beforeBrush && el.beforeBrush();
	          (el.brushVML || el.brush).call(el, vmlRoot);
	          el.afterBrush && el.afterBrush();
	        }
	      }
	
	      el.__dirty = false;
	    }
	
	    if (this._firstPaint) {
	      // Detached from document at first time
	      // to avoid page refreshing too many times
	      // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变
	      this._vmlViewport.appendChild(vmlRoot);
	
	      this._firstPaint = false;
	    }
	  },
	  resize: function (width, height) {
	    var width = width == null ? this._getWidth() : width;
	    var height = height == null ? this._getHeight() : height;
	
	    if (this._width != width || this._height != height) {
	      this._width = width;
	      this._height = height;
	      var vmlViewportStyle = this._vmlViewport.style;
	      vmlViewportStyle.width = width + 'px';
	      vmlViewportStyle.height = height + 'px';
	    }
	  },
	  dispose: function () {
	    this.root.innerHTML = '';
	    this._vmlRoot = this._vmlViewport = this.storage = null;
	  },
	  getWidth: function () {
	    return this._width;
	  },
	  getHeight: function () {
	    return this._height;
	  },
	  clear: function () {
	    if (this._vmlViewport) {
	      this.root.removeChild(this._vmlViewport);
	    }
	  },
	  _getWidth: function () {
	    var root = this.root;
	    var stl = root.currentStyle;
	    return (root.clientWidth || parseInt10(stl.width)) - parseInt10(stl.paddingLeft) - parseInt10(stl.paddingRight) | 0;
	  },
	  _getHeight: function () {
	    var root = this.root;
	    var stl = root.currentStyle;
	    return (root.clientHeight || parseInt10(stl.height)) - parseInt10(stl.paddingTop) - parseInt10(stl.paddingBottom) | 0;
	  }
	}; // Not supported methods
	
	function createMethodNotSupport(method) {
	  return function () {
	    zrLog('In IE8.0 VML mode painter not support method "' + method + '"');
	  };
	} // Unsupported methods
	
	
	each(['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'], function (name) {
	  VMLPainter.prototype[name] = createMethodNotSupport(name);
	});
	var _default = VMLPainter;
	module.exports = _default;

/***/ })
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCAwMWU0NDk2MDFiMDBhNGY3MzNkMiIsIndlYnBhY2s6Ly8vLi9pbmRleC5mbG93LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvRmlzaFRvcG9GbG93LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS91dGlsLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvdG9vbC9wYXRoLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9QYXRoLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvU3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9FbGVtZW50LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9ndWlkLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9taXhpbi9UcmFuc2Zvcm1hYmxlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9tYXRyaXguanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL3ZlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL21peGluL0FuaW1hdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQ2xpcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9lYXNpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi90b29sL2NvbG9yLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9MUlUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL2xvZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvbWl4aW4vUmVjdFRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci90ZXh0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi90ZXh0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9pbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3JvdW5kUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvUGF0aFByb3h5LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9jdXJ2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvYmJveC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vbGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vY3ViaWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL3F1YWRyYXRpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vYXJjLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi91dGlsLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi93aW5kaW5nTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0dGVybi5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3Rvb2wvdHJhbnNmb3JtUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvR3JhZGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9taXhpbi9EcmFnZ2FibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9UZXh0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1NlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL2ZpeENsaXBXaXRoU2hhZG93LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9lbnYuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlnb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9wb2x5LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoU3BsaW5lLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoQmV6aWVyLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0FyYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9TdGF0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9taW5pbWFwLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL1BvaW50LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvTGluZVN0cnVjdC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL0V4dGVuc2lvbkFwaS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3pyZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9IYW5kbGVyLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvU3RvcmFnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvdGltc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL1BhaW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9MYXllci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0aW9uLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2RvbS9IYW5kbGVyUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL0dlc3R1cmVNZ3IuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL09wZXJhdGlvbk5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9Ob2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvSGFuZGxlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0VmZmVjdExpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdGlvblBvaW50LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9jbGF6ei5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvSWNvbk9wZXJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL21hbmFnZXIvRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9Db25uZWN0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL0xvZy5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL3V0aWwvRmxvd0NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL3V0aWwvRmxvd1V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0dyb3VwTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvZmxvd05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1JlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0NpcmNsZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1RleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1NlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvUmluZy5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvRWxsaXBzZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvSGVhcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0Ryb3BsZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1Jvc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0lzb2dvbi5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvUG9seWdvbi5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvUG9seWxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0JlemllckN1cnZlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9BcmMuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1N0YXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1Ryb2Nob2lkLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9QYXRoLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9JY29uQnV0dG9uLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGluay9mbG93TGluay5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL2xpbmsvTGluay5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL0Zsb3cuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9saW5rL0ZvbGQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9saW5rL0N1cnZlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGluay9DaGFpbi5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvTGluZU9wZXJhdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9sYXlvdXQvbGF5b3V0LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGF5b3V0L0hMYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9sYXlvdXQvVkxheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL2xheW91dC9UcmVlTGF5b3V0LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvZGF0YS9UcmVlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGF5b3V0L3RyZWVIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9sYXlvdXQvRm9yY2VMYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9sYXlvdXQvZm9yY2VIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9JbWFnZVBvb2wuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi90b29sdGlwL1Rvb2x0aXBWaWV3LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvdG9vbHRpcC9Ub29sdGlwQ29udGVudC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL3Rvb2x0aXAvZ2xvYmFsTGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi90b29sdGlwL1Rvb2x0aXBNb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3ZtbC92bWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi92bWwvZ3JhcGhpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3ZtbC9jb3JlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvdm1sL1BhaW50ZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUE4RSxXQUFXO0FBQ3pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjtBQUN0Qiw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMEI7QUFDMUI7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQztBQUNwQyxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7O0FBRUE7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixnQkFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLDJCQUEyQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCLGtCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QixrQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBb0UsWUFBWTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQyxZQUFZOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsMENBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUMsYUFBYTtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsa0JBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsa0JBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBLHFFQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGtCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWlELDRDQUE0QztBQUM3RjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUEyRiwyQ0FBMkM7QUFDdEk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QiwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQTZCLGNBQWMsRUFBRTtBQUM3QztBQUNBOztBQUVBLHFDQUFvQyxjQUFjO0FBQ2xELDJDQUEwQyx5QkFBeUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU8sZUFBZTtBQUNyQyxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixNQUFNO0FBQ3RCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QjtBQUM1QiwrQkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQixlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIsT0FBTyxnQkFBZ0IsNENBQTRDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxpQ0FBZ0MsT0FBTyxnQkFBZ0IsZ0RBQWdEO0FBQ3ZHO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0Esb0RBQW1ELHNFQUFzRTtBQUN6SDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDLE9BQU8sZ0JBQWdCLDRDQUE0QztBQUNuRztBQUNBLGtCQUFpQjtBQUNqQjtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsaUNBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTyxlQUFlO0FBQ3JDLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxxQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLGNBQWE7QUFDYjtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUMscURBQXFEO0FBQzFGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUF5RjtBQUN6RjtBQUNBO0FBQ0Esc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyx5REFBeUQ7QUFDNUY7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCLGtCQUFpQjtBQUNqQixvQ0FBbUMsK0ZBQStGO0FBQ2xJLGtCQUFpQjtBQUNqQixvQ0FBbUMsdURBQXVEO0FBQzFGO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWdELDZDQUE2QyxJQUFJO0FBQ2pHLHVHQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxtRUFBbUU7QUFDdEc7QUFDQSxrQkFBaUI7QUFDakIsb0NBQW1DLG1IQUFtSDs7QUFFdEosa0JBQWlCO0FBQ2pCLG9DQUFtQyxpRUFBaUU7QUFDcEc7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLE9BQU8sZ0JBQWdCLDRDQUE0QztBQUMvRjtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0MsT0FBTyxnQkFBZ0IsZ0RBQWdEO0FBQ3ZHO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBLG9EQUFtRCxzRkFBc0Y7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFvRSxlQUFlO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFrQyxlQUFlO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQXlDLFlBQVk7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTyxpQkFBaUI7QUFDeEMsaUJBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLHNDQUFxQyxvQkFBb0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckIsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQixrQ0FBaUM7QUFDakM7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGdDQUErQiwwQkFBMEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBLDhCQUE2QjtBQUM3QiwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLDBCQUEwQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPLGFBQWE7QUFDcEMsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBLG1DQUFrQyxjQUFjO0FBQ2hELHNCQUFxQixtQkFBbUI7QUFDeEMsc0JBQXFCLGlCQUFpQjtBQUN0QyxzQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGdEQUErQyxrQ0FBa0M7QUFDakY7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtEQUE4RCwrQkFBK0IsRUFBRTtBQUMvRixpQkFBZ0IsU0FBUztBQUN6QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSx3QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFrRjtBQUNsRjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBOztBQUVBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLDZEQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSx3QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsYUFBYTtBQUM1QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkIsbURBQW1EO0FBQ2hGLDZCQUE0QiwrRUFBK0U7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDLFNBQVMsRUFBRTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSwwQ0FBeUMsV0FBVztBQUNwRCxjQUFhO0FBQ2IsMENBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EscUNBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0Esc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCLGtEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCLHlDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QyxVQUFVO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLFVBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSw2Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLDRCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0M7QUFDbEM7QUFDQSxvQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBK0MsUUFBUSxzREFBc0QsbUZBQW1GO0FBQ2hNLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QyxHQUFHLDJFQUEyRTtBQUNySCxVQUFTO0FBQ1Qsd0NBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLHlEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQWtGLFdBQVc7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLFlBQVk7QUFDM0IsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsU0FBUztBQUN4QixnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixZQUFZO0FBQzVCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ2hyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM0NBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLGlDQUFpQztBQUNoRCxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLDRCQUE0QjtBQUMzQyxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFNBQVM7QUFDeEIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsdUJBQXVCO0FBQ3RDLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLDJCQUEyQjtBQUMxQyxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSx1QkFBdUI7QUFDdEMsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSwyQkFBMkI7QUFDMUMsZ0JBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSx1QkFBdUI7QUFDdEMsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSwyQkFBMkI7QUFDMUMsZ0JBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsbUNBQW1DO0FBQ2xELGdCQUFlLG1DQUFtQztBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsZUFBZTtBQUM5QixnQkFBZSxlQUFlO0FBQzlCLGdCQUFlLFNBQVM7QUFDeEIsaUJBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLGVBQWU7QUFDOUIsZ0JBQWUsU0FBUztBQUN4QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDcmNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUM7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsYUFBWSxFQUFFO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUEsMkNBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLFlBQVcsRUFBRTtBQUNiLFlBQVcsUUFBUTtBQUNuQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLFlBQVcsUUFBUTtBQUNuQixhQUFZLEVBQUU7QUFDZDs7O0FBR0E7QUFDQTs7QUFFQSxpREFBZ0QsU0FBUztBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLFlBQVcsRUFBRTtBQUNiO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixZQUFXLEVBQUU7QUFDYixZQUFXLFFBQVE7QUFDbkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOzs7QUFHRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsU0FBUztBQUNwQjs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxnQkFBZ0I7QUFDM0IsWUFBVyxnQkFBZ0I7QUFDM0IsWUFBVyxRQUFRO0FBQ25COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsaUJBQWlCO0FBQzVCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsYUFBYTtBQUN4QixZQUFXLFNBQVM7QUFDcEIsWUFBVyxFQUFFO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsc0NBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQixZQUFXLFNBQVM7QUFDcEIsWUFBVyxFQUFFO0FBQ2IsYUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBLHNDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQixZQUFXLFNBQVM7QUFDcEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsRUFBRTtBQUNiLGFBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSCxzQ0FBcUMsU0FBUztBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQixZQUFXLFNBQVM7QUFDcEIsWUFBVyxFQUFFO0FBQ2IsYUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBLHNDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQixZQUFXLFNBQVM7QUFDcEIsWUFBVyxFQUFFO0FBQ2IsYUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQixZQUFXLEVBQUU7QUFDYixhQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFNBQVM7QUFDcEIsYUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsYUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsYUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsYUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsYUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsYUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsYUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsYUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksRUFBRTtBQUNkOzs7QUFHQTtBQUNBLDBDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsc0JBQXNCO0FBQ2pDLGFBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsUUFBUTtBQUNuQixZQUFXLE9BQU87QUFDbEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxFQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSx5Q0FBd0M7QUFDeEMsaUVBQWdFOztBQUVoRTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCOzs7Ozs7QUNwcUJBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOzs7QUFHSDtBQUNBLFNBQVE7O0FBRVIsY0FBYSxlQUFlO0FBQzVCO0FBQ0EsSUFBRzs7O0FBR0gsMkJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBbUM7O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFP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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7O0FB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Q0E7QUFDQSxjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNB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QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxhQUFZLE9BQU87QUFDbkIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQjs7Ozs7O0FDelhBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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R0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVELDJCOzs7Ozs7QUN2QkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVELDJCOzs7Ozs7QUN2Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGVBQWMsT0FBTztBQUNyQixlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQsMkI7Ozs7OztBQ3JEQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVEsWUFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWUsYUFBYTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCLGFBQWE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCLGFBQWE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBcUIsWUFBWTtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EscUVBQW9FLHNCQUFzQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQSxrQkFBaUI7QUFDakI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEk7Ozs7OztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLHdFQUF3RTtBQUM1RjtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJOzs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQiwyQ0FB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Q0E7QUFDQSxjQUFhO0FBQ2IsVUFBUzs7QUFFVDtBQUNBOztBQUVBOzs7Ozs7OztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUIsdUNBQXVDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOzs7Ozs7O0FDM0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEwQyxPQUFPLE1BQU0sVUFBVSxXQUFXO0FBQzVFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUF5Qyx3QkFBd0I7QUFDakU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCOztBQUUzQix1QkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFxRDs7QUFFckQ7QUFDQTtBQUNBLFlBQVc7QUFDWDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxtQ0FBa0M7O0FBRWxDO0FBQ0E7O0FBRUEsd0JBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUM7QUFDdkM7O0FBRUEsaUNBQWdD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE2RTs7QUFFN0U7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQjs7QUFFL0I7QUFDQSxxRUFBb0U7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtFQUFpRTs7QUFFakUsNEJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQSxvQkFBbUIsaUJBQWlCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7OztBQUdUO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7QUFHRDtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0EsMkIiLCJmaWxlIjoiZmlzaFRvcG9GbG93LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiZmlzaFRvcG9GbG93XCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImZpc2hUb3BvRmxvd1wiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAwMWU0NDk2MDFiMDBhNGY3MzNkMiIsIi8qKlxyXG4gKiBFeHBvcnQgZmlzaFRvcG8gYXMgQ29tbW9uSlMgbW9kdWxlXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9GaXNoVG9wb0Zsb3cuanMnKTtcclxuLy/lhbzlrrlJRTgg5byV5YWlVk1MIOWmguaenOS4jemcgOimgeWFvOWuuUlFOOivt+WIoOmZpFxyXG5yZXF1aXJlKCd6cmVuZGVyL2xpYi92bWwvdm1sJyk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5kZXguZmxvdy5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogZmlzaHRvcG/mtYHnqIvlrp7kvotcclxuICogQGNsYXNzIGZpc2gudG9wby5GaXNoVG9wb0Zsb3dcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgY2xpY2tcclxuICog6IqC54K55oiW6ICF57q/5q6155qEY2xpY2vkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tiBldmVudC50YXJnZXTkuLrnm67moIflr7nosaEgZXZlbnQudGFyZ2V0Lm1vZGVs5Li655uu5qCH5a+56LGh55qE5Lia5Yqh5pWw5o2uXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICAgICB0aGlzLmZpc2hUb3BvLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICogICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi54K55Ye755qE5piv77yaXCIgKyBldmVudC50YXJnZXQubW9kZWwuZ2V0KCdlbGVtZW50VHlwZScpKTtcclxuICogICAgICAgICAgfSk7XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBldmVudCBkYmxjbGlja1xyXG4gKiDoioLngrnmiJbogIXnur/mrrXnmoTlj4zlh7vkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tiBldmVudC50YXJnZXTkuLrnm67moIflr7nosaEgZXZlbnQudGFyZ2V0Lm1vZGVs5Li655uu5qCH5a+56LGh55qE5Lia5Yqh5pWw5o2uXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICAgICB0aGlzLmZpc2hUb3BvLm9uKFwiZGJsY2xpY2tcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICogICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi5Y+M5Ye755qE5piv77yaXCIgKyBldmVudC50YXJnZXQubW9kZWwuZ2V0KCdlbGVtZW50VHlwZScpKTtcclxuICogICAgICAgICAgfSk7XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBldmVudCBjcmVhdGVcclxuICog6IqC54K55LiO57q/5q615Yib5bu65a6M5q+V55qE5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7YgZXZlbnQudGFyZ2V05Li655uu5qCH5a+56LGhIGV2ZW50LnRhcmdldC5tb2RlbOS4uuebruagh+WvueixoeeahOS4muWKoeaVsOaNrlxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgICAgdGhpcy5maXNoVG9wby5vbihcImNyZWF0ZVwiLCBmdW5jdGlvbihlKSB7XHJcbiAqICAgICAgICAgICAgICAgaWYgKG1lLmZpc2hUb3BvLkZsb3cuaXNMaW5rKGUudGFyZ2V0Lm1vZGVsKSkge1xyXG4gKiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi57q/5q615Yib5bu65a6M5q+V77yaXCIgKyBlLnRhcmdldC5tb2RlbCk7XHJcbiAqICAgICAgICAgICAgICAgfVxyXG4gKiAgICAgICAgICB9KTtcclxuICovXHJcblxyXG4vKipcclxuICogQGV2ZW50IGRlbGV0ZVxyXG4gKiDoioLngrnkuI7nur/mrrXliJvlu7rlrozmr5XnmoTkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tiBldmVudC50YXJnZXTkuLrnm67moIflr7nosaEgZXZlbnQudGFyZ2V0Lm1vZGVs5Li655uu5qCH5a+56LGh55qE5Lia5Yqh5pWw5o2uXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICAgICAvL+iKgueCueWIoOmZpOWujOavleS6i+S7tlxyXG4gKiAgICAgICAgICB0aGlzLmZpc2hUb3BvLm9uKFwiZGVsZXRlXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAqICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuWIoOmZpOeahOaYr++8mlwiICsgZXZlbnQudGFyZ2V0Lm1vZGVsLmdldCgnZWxlbWVudFR5cGUnKSk7XHJcbiAqICAgICAgICAgIH0pO1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgZHJvcERyYWdcclxuICog6IqC54K556e75Yqo5a6M5oiQ55qE5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7YgZXZlbnQudGFyZ2V05Li655uu5qCH5a+56LGhIGV2ZW50LnRhcmdldC5tb2RlbOS4uuebruagh+WvueixoeeahOS4muWKoeaVsOaNrlxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgICAgLy/oioLngrnnp7vliqjnu5PmnZ/kuovku7ZcclxuICAgICAgICAgICAgdGhpcy5maXNoVG9wby5vbihcImRyb3BEcmFnXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuenu+WKqOeahOiKgueCueaYr++8mlwiK2V2ZW50LnRhcmdldC5tb2RlbC5nZXQoJ2VsZW1lbnRUeXBlJykpO1xyXG4gICAgICAgICAgICB9KTtcclxuICovXHJcblxyXG5cclxuXHJcblxyXG4gICAgcmVxdWlyZShcIi4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9wb2x5ZmlsbC5qc1wiKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIE1pbmltYXAgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL21pbmltYXAuanNcIik7XHJcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvdXRpbC5qc1wiKTtcclxuICAgIHZhciBQb2ludCA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvUG9pbnQuanNcIik7XHJcbiAgICB2YXIgRXh0ZW5zaW9uQVBJID0gcmVxdWlyZSgnLi9FeHRlbnNpb25BcGknKTtcclxuICAgIHZhciBFdmVudGZ1bCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL21peGluL0V2ZW50ZnVsJyk7XHJcbiAgICB2YXIgenJlbmRlciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3pyZW5kZXInKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBPcGVyYXRpb25Ob2RlID0gcmVxdWlyZShcIi4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL09wZXJhdGlvbk5vZGUuanNcIik7XHJcbiAgICB2YXIgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZShcIi4vbWFuYWdlci9GbG93Q29ubmVjdGlvbk1hbmFnZXIuanNcIik7XHJcbiAgICB2YXIgRmxvd1V0aWwgPSByZXF1aXJlKFwiLi91dGlsL0Zsb3dVdGlsLmpzXCIpO1xyXG4gICAgdmFyIENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL3V0aWwvRmxvd0NvbnN0YW50cy5qc1wiKTtcclxuICAgIHZhciBNb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvbW9kZWwuanNcIik7XHJcbiAgICB2YXIgZXZlbnRUb29sID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9ldmVudCcpO1xyXG4gICAgdmFyIENvbm5lY3RvciA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rvci5qc1wiKTtcclxuICAgIHZhciBMaW5lT3BlcmF0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9MaW5lT3BlcmF0aW9uTWFuYWdlci5qc1wiKTtcclxuICAgIHZhciBGbG93ID0gcmVxdWlyZShcIi4vRmxvdy5qc1wiKTtcclxuICAgIHZhciBmbG93Tm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvZmxvd05vZGVcIik7XHJcbiAgICB2YXIgR3JvdXBOb2RlID0gcmVxdWlyZShcIi4vbm9kZS9Hcm91cE5vZGVcIik7XHJcbiAgICB2YXIgZmxvd0xpbmsgPSByZXF1aXJlKFwiLi9saW5rL2Zsb3dMaW5rXCIpO1xyXG4gICAgdmFyIGxheW91dCA9IHJlcXVpcmUoXCIuL2xheW91dC9sYXlvdXRcIik7XHJcbiAgICB2YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb250YWluL3RleHQnKTtcclxuICAgIHZhciBJbWFnZVBvb2wgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL0ltYWdlUG9vbC5qc1wiKTtcclxuICAgIHZhciBUb29sVGlwVmlldyA9IHJlcXVpcmUoXCIuL3Rvb2x0aXAvVG9vbHRpcFZpZXdcIik7XHJcbiAgICB2YXIgVG9vbHRpcE1vZGVsID0gcmVxdWlyZShcIi4vdG9vbHRpcC9Ub29sdGlwTW9kZWxcIik7XHJcbiAgICB2YXIgYWN0aW9ucyA9IHt9O1xyXG4gICAgdmFyIGtleUNvZGUgPSB7RU5URVI6MTMsIEVTQ0FQRToyN31cclxuICAgIGZ1bmN0aW9uIEZpc2hUb3BvRmxvdyhkb20sIG9wdHMpIHtcclxuICAgICAgICB0aGlzLmlkO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2RvbSA9IGRvbTtcclxuICAgICAgICB0aGlzLm5vd1pvb20gPSAxO1xyXG4gICAgICAgIHRoaXMuY2FuU2NhbGUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZWFnbGVFeWUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVhZ2xlRXllTm9kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbml0U2NhbGVSYXRpbyA9IDE7XHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlID0gbnVsbDtcclxuICAgICAgICB0aGlzLnN0ZXAgPSAwOy8v5YmN6L+b5ZCO6YCA6K6h5q2l5pWwXHJcbiAgICAgICAgdGhpcy5zdGVwSnNvbiA9IFtdOy8v5a2Y5pS+5q+P5q2l55qEanNvblxyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWROb2RlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmFsbE5vZGVzID0gW107XHJcbiAgICAgICAgdGhpcy5taW5pbWFwID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9hcGkgPSBuZXcgRXh0ZW5zaW9uQVBJKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBuZXcgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyKHRoaXMuX2FwaSk7XHJcbiAgICAgICAgdGhpcy5saW5lT3BlcmF0aW9uTWFuYWdlciA9IG5ldyBMaW5lT3BlcmF0aW9uTWFuYWdlcih0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLHRoaXMuX2FwaSk7XHJcbiAgICAgICAgdGhpcy5fenIgPSB6cmVuZGVyLmluaXQoZG9tLCB7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyOiBvcHRzLnJlbmRlcmVyIHx8ICdjYW52YXMnLFxyXG4gICAgICAgICAgICBkZXZpY2VQaXhlbFJhdGlvOiBvcHRzLmRldmljZVBpeGVsUmF0aW9cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl90b29sdGlwVmlldyA9IG5ldyBUb29sVGlwVmlldyhuZXcgVG9vbHRpcE1vZGVsKG9wdHMudG9vbHRpcCksdGhpcy5fYXBpKTtcclxuICAgICAgICB0aGlzLlNoYXBlID0gZ3JhcGhpYztcclxuICAgICAgICB0aGlzLmxpbmVPcHQgPSB7fTsgIC8v5Yid5aeL55qE57q/5q616YWN572u5L+h5oGvXHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGVzID0gW107XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG5ldyBNb2RlbCh7fSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoQ29uc3RhbnRzLkVMRU1FTlRfVFlQRSwgXCJzY2VuZVwiKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChDb25zdGFudHMuTU9ERSwgXCJub3JtYWxcIik7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0cztcclxuICAgICAgICB0aGlzLmN1cnNvck1hcCA9IHtcclxuICAgICAgICAgICAgdGw6ICdudy1yZXNpemUnLFxyXG4gICAgICAgICAgICB0cjogJ25lLXJlc2l6ZScsXHJcbiAgICAgICAgICAgIGJsOiAnc3ctcmVzaXplJyxcclxuICAgICAgICAgICAgYnI6ICdzZS1yZXNpemUnLFxyXG4gICAgICAgICAgICBtdHI6J3VybChkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJRQUFBQVVDQU1BQUFDNlYrMC9BQUFBWUZCTVZFVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFENlQraU5BQUFBSDNSU1RsTUE3c1VNb1lYbkVrWVl6YWFUalFpQVFDd2VCY0c3ZnZuVUxoMlpkak15NkZ6ZDd3QUFBTEpKUkVGVUdOTjFrRmtPd3pBSUJRSHZXL1k2U2JmYy81WTFsdHFvbGpJZjJCb2hCQThxVTA5NnhlVjVMLyt1Rkg0U3BzR0FHU0ttVGhDeU16NjRVZDM4VGUwbWVJcEhjVFAxbmRUS3ZxelNVdVFJTEZNUUpBVXdJbmdCTENkMFVySmhTUkdxekhIVTNGY0hCVk1va3F4UzM4WU5HUUxRYmhtZ1paMjNzVkVYblhWbVM0NjdGcTA4OTJTU0xhVzVTSHJOOXJ6OWJYdjlFSElCK0U5cGRNRzdZczQ4WjJjanhvN0ZMM2s4a1BJRTEzd0FtRVVJTzJNTDlZTUFBQUFBU1VWT1JLNUNZSUk9KSAxMCAxMCwgYXV0bydcclxuICAgICAgICB9OyAvLyDoioLngrnmjqfliLbngrnpvKDmoIfkv6Hmga8o5LiK5bem77yM5LiK5Y+z77yM5LiL5bem77yM5LiL5Y+z77yM5peL6L2sKVxyXG4gICAgICAgIHRoaXMuY3Vyc29yTWFwcyA9IFtcclxuICAgICAgICAgICAgJ24tcmVzaXplJyxcclxuICAgICAgICAgICAgJ25lLXJlc2l6ZScsXHJcbiAgICAgICAgICAgICdlLXJlc2l6ZScsXHJcbiAgICAgICAgICAgICdzZS1yZXNpemUnLFxyXG4gICAgICAgICAgICAncy1yZXNpemUnLFxyXG4gICAgICAgICAgICAnc3ctcmVzaXplJyxcclxuICAgICAgICAgICAgJ3ctcmVzaXplJyxcclxuICAgICAgICAgICAgJ253LXJlc2l6ZSdcclxuICAgICAgICBdXHJcbiAgICAgICAgdGhpcy5jdXJzb3JPZmZzZXQgPSB7XHJcbiAgICAgICAgICAgIHRyOiAxLFxyXG4gICAgICAgICAgICBicjogMyxcclxuICAgICAgICAgICAgYmw6IDUsXHJcbiAgICAgICAgICAgIHRsOiA3XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEV2ZW50ZnVsLmNhbGwodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZpc2hUb3BvUHJvdG8gPSBGaXNoVG9wb0Zsb3cucHJvdG90eXBlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+WIGZpc2hUb3BvIOWunuS+i+WuueWZqOeahCBkb20g6IqC54K5XHJcbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5nZXREb20gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvbTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmdldFpyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl96cjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPliBmaXNoVG9wbyDlrp7kvovlrrnlmajnmoTlrr3luqbjgIJcclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fenIuZ2V0V2lkdGgoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5YgZmlzaFRvcG8g5a6e5L6L5a655Zmo55qE6auY5bqm44CCXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl96ci5nZXRIZWlnaHQoKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5b2T5YmN5a6e5L6L5piv5ZCm5bey57uP6KKr6YeK5pS+44CCXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmlzRGlzcG9zZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3Bvc2VkO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOmHiuaUviDlvZPliY3lrp7kvotcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5fenIuZGlzcG9zZSgpO1xyXG5cclxuICAgICAgICBpbnN0YW5jZXNbdGhpcy5pZF0gPSBudWxsO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDosIPmlbTlsLrlr7ggIOWcqOeql+WPo+Wkp+Wwj+WPkeeUn+aUueWPmOaXtumcgOimgeaJi+W3peiwg+eUqFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIOWuveW6plxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCDpq5jluqZcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5yZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fenIucmVzaXplKCk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLmRpc3BhdGNoQWN0aW9uID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcclxuICAgICAgICBpZighYWN0aW9uc1twYXlsb2FkLnR5cGVdKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIG9wdGlvblxyXG4gICAgICog5L+u5pS555S75biD55qE6YCJ6aG5XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IOmUriAg5aaC77yacm9hbSBsaW5rTW9kaWZ5ICB0ZXh0RWRpdGFibGXnrYlcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd8RnVuY3Rpb259IHZhbHVlIOmAiemhueWAvFxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLm9wdGlvbiA9IGZ1bmN0aW9uKGtleSx2YWx1ZSkge1xyXG4gICAgICAgIHZhciBtb2RlbCA9IG5ldyBNb2RlbCh0aGlzLm9wdGlvbnMpO1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB6clV0aWwuY2xvbmUodGhpcy5vcHRpb25zKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vZGVsLmdldChrZXkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcInJvYW1cIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSb2FtKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbW9kZWwuc2V0KGtleSx2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLmluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIE1PVVNFX0VWRU5UX05BTUVTID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93ID8gWyd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZScsICd0b3VjaGVuZCddIDogWydtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ21vdXNldXAnXTtcclxuICAgICAgICB0aGlzLmdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcclxuICAgICAgICB0aGlzLmdyb3VwLm1vZGVsID0gdGhpcy5tb2RlbDtcclxuICAgICAgICB0aGlzLmdyb3VwLmlzQmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3pyLmFkZCh0aGlzLmdyb3VwKTtcclxuXHJcbiAgICAgICAgLy/mmK/lkKblhYHorrjpvKDmoIfmu5rova7mlL7lpKfnvKnlsI9cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJvYW0gPT09IHRydWUpIHtcclxuICAgICAgICAgICAgdGhpcy56clNjYWxlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvcnMgPSBbXTtcclxuICAgICAgICAvL21vdXNldXAg5Lya5Zyo5ZCE5Liqbm9kZeaIlue6v+eahGNsaWNr5LqL5Lu25LmL54K55omn6KGMICDlnKjpgInkuK3oioLngrnmiJbnur/liY0g5YWI5riF56m66YCJ5Lit5pWI5p6cXHJcbiAgICAgICAgdGhpcy5fenIub24oXCJtb3VzZXVwXCIsIGZ1bmN0aW9uIChlKSB7IC8vIGNsZWFyU2VsZWN0XHJcbiAgICAgICAgICAgIC8vIDEuIOa4heepuuiKgueCueeahOmAieS4reaViOaenFxyXG4gICAgICAgICAgICAvLyB0aGlzLl9yZW1vdmVPcGVyYXRpb25Ob2RlKCk7XHJcbiAgICAgICAgICAgIC8vIDIuIOeCueWHu+eahOe6vyDvvIzliJnnm7TmjqXov5Tlm55cclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gZS50YXJnZXQ7XHJcbiAgICAgICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5tb2RlbCAmJiBGbG93LmlzTGluayhzaGFwZS5tb2RlbCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2hhcGUgJiYgc2hhcGUuY29ubmVjdG9yIGluc3RhbmNlb2YgQ29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gMy4g5riF56m66L+e5o6l57q/XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY2xlYXJTZWxlY3RDb24oKTtcclxuICAgICAgICAgICAgLy8gNC4g54K55Ye755qE5piv57q/5LiK5pON5L2c5oyJ6ZKu77yM5YiZ55u05o6l6L+U5ZueXHJcbiAgICAgICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5faXNMaW5lT3BlcmF0aW9uSWNvbiAmJiBzaGFwZS5faXNMaW5lT3BlcmF0aW9uSWNvbiA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gNS7pmpDol4/nur/kuIrmk43kvZzlm77moIdcclxuICAgICAgICAgICAgdGhpcy5saW5lT3BlcmF0aW9uTWFuYWdlci5oaWRlQWxsTGluZU9wZXJhdGlvbigpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgIHRoaXMuX3pyLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgLy8g5aaC5p6c54K55Ye75LqG5o6n5Yi254K577yM5YiZ5LiN5Lya5Y+W5raI6YCJ5Lit54q25oCBKOaOp+WItueCueS4jeWcqOiKgueCueiMg+WbtOWGhSlcclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0IHx8IHt9O1xyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IHRhcmdldC50eXBlO1xyXG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gJ0Nvbm5lY3RDb250cm9sTGluZScgJiYgdHlwZSAhPT0gJ0Nvbm5lY3RDb250cm9sJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlQ29ubmVjdG9yUG9pbnQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZUNvbm5lY3RvckNvbnRyb2woKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZU9wZXJhdGlvbk5vZGUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBub2RlVGFyZ2V0ID0gZS50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2hhcGU7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZVRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlID0gbm9kZVRhcmdldC5tb2RlbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgobm9kZVRhcmdldCAmJiBzaGFwZSAmJiBGbG93LmlzTGluayhzaGFwZSkpIHx8IChub2RlVGFyZ2V0ICYmIHNoYXBlICYmIEZsb3cuaXNOb2RlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBcImNsaWNrXCI7XHJcbiAgICAgICAgICAgIHBhcmFtcy50YXJnZXQgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLl9hcGkudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICAvLyBtb3VzZU1vZGXnu5/kuIDlnKhtb3VzZWRvd27kuovku7bph4zliKTmlq1cclxuICAgICAgICB0aGlzLl96ci5vbihcIm1vdXNlZG93blwiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1vdXNlTW9kZSA9PT0gJ2RyYWctc2VsZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgaWYgKChlLnRhcmdldCAmJiBlLnRhcmdldC5tb2RlbCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoZS50YXJnZXQgJiYgZS50YXJnZXQubGluZVR5cGUgJiYgZS50YXJnZXQucGFyZW50KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChlLnRhcmdldCAmJiBlLnRhcmdldC5jb25uZWN0b3IgaW5zdGFuY2VvZiBDb25uZWN0b3IpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGUudGFyZ2V0ICYmIGUudGFyZ2V0IGluc3RhbmNlb2YgZ3JhcGhpYy5DaXJjbGUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGUudGFyZ2V0ICYmIGUudGFyZ2V0Lm5hbWUgPT09IFwiR1JPVVBfUkVDVF9OQU1FXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVDb25uZWN0b3JQb2ludCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZUNvbm5lY3RvckNvbnRyb2woKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVPcGVyYXRpb25Ob2RlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ1NlbGVjdChlLnRhcmdldCwgZS5vZmZzZXRYLCBlLm9mZnNldFkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1vdXNlTW9kZSA9PT0gJ2RyYWctbW92ZScpIHtcclxuICAgICAgICAgICAgICAgIGlmICgoZS50YXJnZXQgJiYgZS50YXJnZXQubW9kZWwpIHx8IChlLnRhcmdldCAmJiBlLnRhcmdldC5saW5lVHlwZSAmJiBlLnRhcmdldC5wYXJlbnQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGUudGFyZ2V0ICYmIGUudGFyZ2V0LmNvbm5lY3RvciBpbnN0YW5jZW9mIENvbm5lY3RvcikgfHwgKGUudGFyZ2V0ICYmIGUudGFyZ2V0IGluc3RhbmNlb2YgZ3JhcGhpY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuQ2lyY2xlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JvdXBEcmFnSGFuZGxlcihlLm9mZnNldFgsIGUub2Zmc2V0WSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICB0aGlzLm9uKCdjb25Qb2ludHNHcm91cDpjbGljaycsIGZ1bmN0aW9uIChhcmd1bWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmxpbmVPcGVyYXRpb25NYW5hZ2VyLmJpbmRPcGVyYXRpb24oYXJndW1lbnQubGluZU5vZGUpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgIHpyVXRpbC5lYWNoKE1PVVNFX0VWRU5UX05BTUVTLCBmdW5jdGlvbiAoZXZlTmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLl96ci5vbihldmVOYW1lLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gZXZlTmFtZTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy50YXJnZXQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBpLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH0sIHRoaXMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLnNldFJvYW0gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl96ci5vZmYoXCJtb3VzZXdoZWVsXCIpOy8v56aB5q2i55So5oi357yp5pS+55S75biDXHJcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuenJTY2FsZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLmFkZEdyb3VwTW9kZWwgPSBmdW5jdGlvbiAoZ3JvdXBOb2RlKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIGdyb3VwTm9kZS5lYWNoQ2hpbGQoZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUubW9kZWwpIHsgXHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEdyb3VwTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm1vZGVsICYmICFub2RlLm1vZGVsLm9wdGlvbi5jaGlsZHMgJiYgbm9kZS5jaGlsZHJlbigpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlLm1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSBpbnN0YW5jZW9mIEdyb3VwTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZS5tb2RlbC5vcHRpb24uY2hpbGRzICYmIGNoaWxkTm9kZS5jaGlsZHJlbigpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYWRkR3JvdXBNb2RlbChub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHMucHVzaChjaGlsZE5vZGUubW9kZWwub3B0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm1vZGVsLm9wdGlvbi5jaGlsZHMgPSBjaGlsZHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHRvSnNvblxyXG4gICAgICog5a+85Ye6anNvblxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBqc29u5a+56LGhXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8udG9Kc29uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYWRkR3JvdXBNb2RlbCh0aGlzLmdyb3VwKTtcclxuICAgICAgICByZXR1cm4gRmxvd1V0aWwudG9Kc29uKHRoaXMubW9kZWwsIHRoaXMuZ3JvdXApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBmcm9tSnNvblxyXG4gICAgICog5a+85YWlanNvblxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBqc29u5a+56LGhXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzTm9Db3VudCDmmK/lkKbpnIDopoFzdGVw6K6h5pWw77yM6buY6K6k5piv6ZyA6KaB6K6h5pWwXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZnJvbUpzb24gPSBmdW5jdGlvbiAoanNvbiwgaXNOb0NvdW50KSB7XHJcbiAgICAgICAgdGhpcy5jbGVhcih0cnVlKTtcclxuICAgICAgICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwoanNvbik7XHJcbiAgICAgICAgdGhpcy5zZXRCYWNrZ3JvdW5kKG1vZGVsLmdldChDb25zdGFudHMuQkFDS0dST1VORCkpO1xyXG4gICAgICAgIHZhciBsYXlvdXRSb290Tm9kZSA9IFtdO1xyXG4gICAgICAgIEZsb3dVdGlsLmZyb21Kc29uKHRoaXMsIHRoaXMuZ3JvdXAsIG1vZGVsLmdldChDb25zdGFudHMuQ0hJTERTKSwgZmFsc2UsIGxheW91dFJvb3ROb2RlLCBpc05vQ291bnQpO1xyXG4gICAgICAgIC8vIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0Um9vdE5vZGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAvLyAgICAgdGhpcy5sYXlvdXROb2RlKFwidHJlZVwiLCB7XHJcbiAgICAgICAgLy8gICAgICAgICBcIm5vZGVcIjogbGF5b3V0Um9vdE5vZGVbaV0sXHJcbiAgICAgICAgLy8gICAgICAgICBcInR5cGVcIjogbGF5b3V0Um9vdE5vZGVbaV0udHJlZVR5cGVcclxuICAgICAgICAvLyAgICAgfSk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5re75Yqg6IqC54K55oiW57q/5q615Yiw55S75biDIOWQjGFkZOaWueazlVxyXG4gICAgICogQG1ldGhvZCBhZGROb2RlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBjcmVhdGVOb2Rl5oiWY3JlYXRlTGlua+i/lOWbnueahOWvueixoVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25dIOWPguaVsOWvueixoVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9uLnRyaWdnZXJdIOaYr+WQpuinpuWPkSBiZWZvcmVDcmVhdGXkuovku7ZcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IOi/lOWbnua3u+WKoOaIkOWKn+eahOiKgueCuSDvvIzlpoLooqvnlKjmiLflj5bmtojkuYvnsbvliJkg6L+U5ZuebnVsbFxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIOa3u+WKoOiKgueCueaIlue6v+auteWIsOeUu+W4gyDlkIxhZGROb2Rl5pa55rOVXHJcbiAgICAgKiBAbWV0aG9kIGFkZFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgY3JlYXRlTm9kZeaIlmNyZWF0ZUxpbmvov5Tlm57nmoTlr7nosaFcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uXSDlj4LmlbDlr7nosaFcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNOb0NvdW50IOaYr+WQpumcgOimgXN0ZXDorqHmlbDvvIzpu5jorqTmmK/pnIDopoHorqHmlbBcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbi50cmlnZ2VyXSDmmK/lkKbop6blj5EgYmVmb3JlQ3JlYXRl5LqL5Lu2XHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSDov5Tlm57mt7vliqDmiJDlip/nmoToioLngrkg77yM5aaC6KKr55So5oi35Y+W5raI5LmL57G75YiZIOi/lOWbnm51bGxcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5hZGQgPSBmaXNoVG9wb1Byb3RvLmFkZE5vZGUgPSBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucywgaXNOb0NvdW50KSB7XHJcbiAgICAgICAgaWYgKCFub2RlKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgaWYob3B0LnRyaWdnZXIgIT09ZmFsc2UgJiYgKCF0aGlzLl90cmlnZ2VyKCdiZWZvcmVDcmVhdGUnLCB7dGFyZ2V0Om5vZGV9KSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQ29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQ29ubmVjdG9yQXR0ckV2ZW50KG5vZGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChGbG93LmlzR3JvdXBOb2RlKG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLndpbGxSZW5kZXIodGhpcy5fYXBpKTtcclxuICAgICAgICAgICAgICAgIHZhciBncm91cE9wdGlvbnMgPSBub2RlLm1vZGVsLmdldChDb25zdGFudHMuT1BUSU9OUyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBPcHRpb25zLm1lcmdlZEltYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwUmVwbGFjZUltYWdlID0gbmV3IGZsb3dOb2RlLkltYWdlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBncm91cE9wdGlvbnMubWVyZ2VkSW1hZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBncm91cE9wdGlvbnMuc3R5bGUudGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRQb3NpdGlvbjogJ2JvdHRvbSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFstNTAwMCwgLTUwMDBdXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnKGdyb3VwUmVwbGFjZUltYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLl9yZWxhdGlvbkltYWdlID0gZ3JvdXBSZXBsYWNlSW1hZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQoZ3JvdXBSZXBsYWNlSW1hZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cFJlcGxhY2VJbWFnZS5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgMzAwKTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLm9uKCdkYmxjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tZXJnZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy/pgY3ljobnu4TkuK3miYDmnInoioLngrlcclxuICAgICAgICAgICAgICAgIG5vZGUuZWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRHcm91cE5vZGUobm9kZSxjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmFkZE5vZGVBdHRyRXZlbnQobm9kZSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3RyaWdnZXIoXCJjcmVhdGVcIiwge3RhcmdldDpub2RlfSk7XHJcblxyXG4gICAgICAgIGlmIChub2RlLmhvdmVyU3R5bGUpIHtcclxuICAgICAgICAgICAgZ3JhcGhpYy5zZXRIb3ZlclN0eWxlKG5vZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5ncm91cC5hZGQobm9kZSk7XHJcbiAgICAgICAgaWYgKG5vZGUucmVsYXRpdmUpIHsgIC8v5b+F6aG75Zyo5Yqg5YWl55S75biD5ZCO5omn6KGMXHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVJlbGF0aXZlUG9zdGlvbihub2RlKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZS5ob3ZlckFuaW1hdGlvbiAmJiB0aGlzLm9wdGlvbnMuaXNBbmltYXRpb25FbmFibGVkKSB7XHJcbiAgICAgICAgICAgIGZsb3dOb2RlLmFkZEhvdmVyQW5pbWF0aW9uKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNOb0NvdW50ICE9IHRydWUpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGVwQ291bnRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uX2FkZEdyb3VwTm9kZSA9IGZ1bmN0aW9uKGdyb3VwTm9kZSwgY2hpbGQpe1xyXG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIENvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLmFkZENvbm5lY3RvckF0dHJFdmVudChjaGlsZCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5hZGROb2RlQXR0ckV2ZW50KGNoaWxkLCBncm91cE5vZGUub3B0aW9ucy5jaGlsZERyYWdnYWJsZSk7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGNoaWxkLnNlbGVjdGFibGUpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5zZWxlY3RhYmxlID0gZmFsc2U7ICAvL+e7hOWGhem7mOiupOS4jeWPr+mAieS4rVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5yZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlUmVsYXRpdmVQb3N0aW9uKGNoaWxkKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5ob3ZlclN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljLnNldEhvdmVyU3R5bGUoY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3RyaWdnZXIoXCJjcmVhdGVcIiwge3RhcmdldDpjaGlsZH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWcqOmTvui3r+i/nue6v+S4iua3u+WKoOaWh+acrFxyXG4gICAgICogQG1ldGhvZCBhZGRUZXh0T25DaGFpblxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxpbmUg6ZO+6Lev6L+e57q/5a+56LGhXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3RleHRdIOaVsOe7hOexu+Wei++8jOihqOekuuWkmuS4quaWh+acrOeahOaVsOaNruOAguaVsOe7hOWFg+e0oOWPr+S7peS4uuWtl+espuS4su+8jOihqOekuuavj+S4quaWh+acrOeahOWQjeWtl++8m+S5n+WPr+S7peaYr+S4quWvueixoe+8jOWvueixoeS4reW/hemhu+aMh+WumnRleHTlsZ7mgKfvvIzlhbblgLzkuLrmlofmnKznmoTlkI3lrZdcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IOi/lOWbniDpk77ot6/ov57nur/lr7nosaFcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5hZGRUZXh0T25DaGFpbiA9IGZ1bmN0aW9uIChsaW5lLCB0ZXh0KSB7XHJcbiAgICAgICAgaWYgKGxpbmUub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PT0gQ29ubmVjdG9yLlRZUEVfQ0hBSU4pIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZW1vdmVMaW5lKGxpbmUsIHRoaXMuX2dldFBhcmVudFpyKGxpbmUpKTtcclxuICAgICAgICAgICAgbGluZS5vcHRpb25zLnRleHQudGV4dC5wdXNoKHRleHQpO1xyXG4gICAgICAgICAgICBsaW5lLm9wdGlvbnMudGV4dENvbnRleHRNZW51ID0gbGluZS5vcHQudGV4dENvbnRleHRNZW51OyAgIC8v5LiN54S25bem6ZSu6I+c5Y2V5rKh5pyJ5LqG77yB77yB77yBXHJcbiAgICAgICAgICAgIHZhciBzbGluayA9IG5ldyBmbG93TGluay5DaGFpbihsaW5lLnN0YXJ0Tm9kZSwgbGluZS5lbmROb2RlLCBsaW5lLm9wdGlvbnMpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZChzbGluayk7XHJcbiAgICAgICAgICAgIHJldHVybiBzbGluaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlnKjpk77ot6/ov57nur/kuIrliKDpmaTmjIflrprmlofmnKxcclxuICAgICAqIEBtZXRob2QgZGVsVGV4dE9uQ2hhaW5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0eHRPYmog5paH5pys5a+56LGhXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSDov5Tlm54g6ZO+6Lev6L+e57q/5a+56LGhXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZGVsVGV4dE9uQ2hhaW4gPSBmdW5jdGlvbiAodHh0T2JqKSB7XHJcbiAgICAgICAgdmFyIGlkID0gdHh0T2JqLmlkLCBsaW5lID0gdHh0T2JqLnBhcmVudCwgcG9zO1xyXG4gICAgICAgIGlmIChsaW5lLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT09IENvbm5lY3Rvci5UWVBFX0NIQUlOICYmIHpyVXRpbC5pc0FycmF5KGxpbmUub3B0aW9ucy50ZXh0LnRleHQpKSB7XHJcbiAgICAgICAgICAgIGxpbmUub3B0aW9ucy50ZXh0LnRleHQuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHYudGV4dElkID09PSBpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsaW5lLm9wdGlvbnMudGV4dC50ZXh0LnNwbGljZShwb3MsIDEpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZW1vdmVMaW5lKGxpbmUsIHRoaXMuX2dldFBhcmVudFpyKGxpbmUpKTtcclxuICAgICAgICAgICAgbGluZS5vcHRpb25zLnRleHRDb250ZXh0TWVudSA9IGxpbmUub3B0LnRleHRDb250ZXh0TWVudTsgICAvL+S4jeeEtuW3pumUruiPnOWNleayoeacieS6hu+8ge+8ge+8gVxyXG4gICAgICAgICAgICB2YXIgc2xpbmsgPSBuZXcgZmxvd0xpbmsuQ2hhaW4obGluZS5zdGFydE5vZGUsIGxpbmUuZW5kTm9kZSwgbGluZS5vcHRpb25zKTtcclxuICAgICAgICAgICAgdGhpcy5hZGQoc2xpbmspO1xyXG4gICAgICAgICAgICByZXR1cm4gc2xpbms7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDlnKjpk77ot6/ov57nur/kuIrkv67mlLnmjIflrprmlofmnKxcclxuICAgICAqIEBtZXRob2QgZGVsVGV4dE9uQ2hhaW5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0eHRPYmog5paH5pys5a+56LGhXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSDkv67mlLnnmoTmlofmnKxcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IOi/lOWbniDpk77ot6/ov57nur/lr7nosaFcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5tb2RpZnlUZXh0T25DaGFpbiA9IGZ1bmN0aW9uICh0eHRPYmosIG5hbWUpIHtcclxuICAgICAgICB2YXIgaWQgPSB0eHRPYmouaWQsIGxpbmUgPSB0eHRPYmoucGFyZW50O1xyXG4gICAgICAgIGlmIChsaW5lLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT09IENvbm5lY3Rvci5UWVBFX0NIQUlOICYmIHpyVXRpbC5pc0FycmF5KGxpbmUub3B0aW9ucy50ZXh0LnRleHQpKSB7XHJcbiAgICAgICAgICAgIGxpbmUub3B0aW9ucy50ZXh0LnRleHQuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHYudGV4dElkID09PSBpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHYudGV4dCA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0eHRPYmouc2V0U3R5bGUoXCJ0ZXh0XCIsIG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICog5pi+56S66ZqQ6JeP5oyH5a6a6IqC54K555qE6L+e57q/XHJcbiAgICAgKiBAbWV0aG9kIHRvZ2dsZUFsbENvbk5vZGVMaW5lXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSDoioLngrnlr7nosaFcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIOaYvuekuui/mOaYr+makOiXjyBbaGlkZXxzaG93XVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLnRvZ2dsZUFsbENvbk5vZGVMaW5lID0gZnVuY3Rpb24gKG5vZGUsIHR5cGUpIHtcclxuICAgICAgICB2YXIgYWxsTGluZSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9ycztcclxuICAgICAgICBpZiAoenJVdGlsLmlzQXJyYXkoYWxsTGluZSkpIHtcclxuICAgICAgICAgICAgYWxsTGluZS5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGluZS5zdGFydE5vZGUuaWQgPT09IG5vZGUuaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlID09PSAnaGlkZScgPyBsaW5lLmhpZGUoKSA6IGxpbmUuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZmlzaFRvcG9Qcm90by5hZGRDb25uZWN0b3JBdHRyRXZlbnQgPSBmdW5jdGlvbiAoY29ubmVjdG9yKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjaGFpbkxpbmUgPSBudWxsO1xyXG4gICAgICAgIGlmIChjb25uZWN0b3Iub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PT0gQ29ubmVjdG9yLlRZUEVfQ0hBSU4pIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuZ2V0VHdvTm9kZUlkKGNvbm5lY3Rvci5zdGFydE5vZGUsIGNvbm5lY3Rvci5lbmROb2RlLCBjb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHZhciBjb25zID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0b3JNYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIHZhciBvcmlnblRleHQgPSBbXS5jb25jYXQoY29ubmVjdG9yLm9wdGlvbnMudGV4dC50ZXh0KTtcclxuICAgICAgICAgICAgaWYgKGNvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29ucy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PT0gQ29ubmVjdG9yLlRZUEVfQ0hBSU4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ25UZXh0ID0gb3JpZ25UZXh0LmNvbmNhdCh2Lm9wdGlvbnMudGV4dC50ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5MaW5lID0gdjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvL+WmguaenOW3suWtmOWcqOmTvui3r1xyXG4gICAgICAgIGlmIChjaGFpbkxpbmUpIHtcclxuICAgICAgICAgICAgY29ubmVjdG9yLm9wdGlvbnMudGV4dC50ZXh0ID0gb3JpZ25UZXh0O1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlbW92ZUxpbmUoY2hhaW5MaW5lLCB0aGlzLl9nZXRQYXJlbnRacihjaGFpbkxpbmUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29ubmVjdG9yLm9wdGlvbnMuaXNFZGl0ID0gISF0aGlzLm9wdGlvbnMubGlua01vZGlmeTtcclxuICAgICAgICBjb25uZWN0b3Iub24oXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvckZvcmJpZEVkaXQoIXRoaXMub3B0aW9ucy5saW5rTW9kaWZ5KTtcclxuICAgICAgICAgICAgdGhpcy5pc05vZGUgPSBmYWxzZTtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuYWRkKGNvbm5lY3Rvcik7XHJcbiAgICAgICAgLy/mlK/mjIHlj4zlh7vnvJbovpFcclxuICAgICAgICBjb25uZWN0b3Iub24oXCJkYmxjbGlja1wiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnRleHQudGV4dEVkaXRhYmxlID09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGF0Lm9wdGlvbnMudGV4dEVkaXRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5jb25uZWN0b3JFZGl0KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50ZXh0LnRleHRFZGl0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdG9yRWRpdCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uYWRkTm9kZUF0dHJFdmVudCA9IGZ1bmN0aW9uIChub2RlLCBjaGlsZERyYWdnYWJsZSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBpZiAoY2hpbGREcmFnZ2FibGUpIHtcclxuICAgICAgICAgICAgdGhpcy5kcmFnKG5vZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbm9kZS5hdHRyKFwib3BlcmF0aW9uSWNvbnNcIiwgbm9kZS5tb2RlbC5nZXQoJ29wdGlvbnMub3BlcmF0aW9uSWNvbnMnKSk7XHJcblxyXG4gICAgICAgIC8v5L6m5ZCs6IqC54K555qEY2xpY2sgZGJsY2xpY2vkuovku7bvvIzpgInkuK3vvIzlubbmtL7lj5Hlh7rljrtcclxuICAgICAgICBub2RlLm9uKCdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2VOb2RlID0gdGhpcztcclxuICAgICAgICAgICAgdGhhdC5ub2RlQ2xpY2tIYW5kbGVyKHRhcmdlTm9kZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGV2ZW50O1xyXG4gICAgICAgICAgICBwYXJhbXMudHlwZSA9ICdjbGljayc7XHJcbiAgICAgICAgICAgIHBhcmFtcy50YXJnZXQgPSB0YXJnZU5vZGU7XHJcbiAgICAgICAgICAgIHRoYXQuX2FwaS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgLy8g5Yik5pat5LiA5LiL5piv5ZCm5piv57uE5YaF5oiQ57uE55qE54K55Ye75LqL5Lu277yM5aaC5p6c5piv55qE6K+d77yM6YKj57uE5Lmf5Lmf5rS+5Y+R5LiA5LiLXHJcbiAgICAgICAgICAgIGlmIChGbG93LmlzSW5Hcm91cCh0YXJnZU5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHRhcmdlTm9kZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudE5vZGUuY2hpbGREcmFnZ2FibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLnRyaWdnZXIoJ2NsaWNrJywge2V2ZW50OmV2ZW50LCB0eXBlOidjbGljaycsdGFyZ2V0OnBhcmVudE5vZGV9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG5vZGUub24oJ2RibGNsaWNrJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdmFyIHRhcmdlTm9kZSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICghdGFyZ2VOb2RlLnN0eWxlIHx8ICh0eXBlb2YgdGFyZ2VOb2RlLnN0eWxlLnRleHRFZGl0YWJsZSA9PSBcInVuZGVmaW5lZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoYXQub3B0aW9ucy50ZXh0RWRpdGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0Lm5vZGVFZGl0KHRhcmdlTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2VOb2RlLnN0eWxlLnRleHRFZGl0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQubm9kZUVkaXQodGFyZ2VOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgIHBhcmFtcy50eXBlID0gJ2RibGNsaWNrJztcclxuICAgICAgICAgICAgcGFyYW1zLnRhcmdldCA9IHRhcmdlTm9kZTtcclxuICAgICAgICAgICAgdGhhdC5fYXBpLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcblxyXG4gICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWxsTm9kZXMucHVzaChub2RlKTtcclxuICAgIH1cclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLl9oYW5kbGVSZWxhdGl2ZVBvc3Rpb24gPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudEVsID0gbm9kZS5wYXJlbnQ7XHJcbiAgICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSBwYXJlbnRFbCA9PT0gdGhpcy5ncm91cFxyXG4gICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOnRoaXMuX2FwaS5nZXRXaWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OnRoaXMuX2FwaS5nZXRIZWlnaHQoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6cGFyZW50RWwuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6cGFyZW50RWwuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBsYXlvdXQucG9zaXRpb25FbGVtZW50KG5vZGUsIG5vZGUucmVsYXRpdmUsIGNvbnRhaW5lckluZm8sIG5vZGUucmVsYXRpdmUucGFkZGluZywge2JvdW5kaW5nTW9kZTpub2RlLnJlbGF0aXZlLmJvdW5kaW5nfHwnYWxsJ30pO1xyXG4gICAgfVxyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uX2dldFBhcmVudFpyID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgIHZhciBwYXJlbnRaciA9IG51bGw7XHJcbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgcGFyZW50WnIgPSBub2RlLnBhcmVudDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJlbnRaciA9IHRoaXMuZ3JvdXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJlbnRacjtcclxuICAgIH1cclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLl9yZW1vdmVPcGVyYXRpb25Ob2RlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3BlcmF0aW9uTm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwLnJlbW92ZSh0aGlzLm9wZXJhdGlvbk5vZGUpO1xyXG4gICAgICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUuY2xlYW51cCgpO1xyXG4gICAgICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOa4heepuuW9k+WJjeWunuS+i++8jOS8muenu+mZpOWunuS+i+S4reaJgOacieeahOiKgueCueS4jue6v1xyXG4gICAgICogQG1ldGhvZCBjbGVhclxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmNsZWFyID0gZnVuY3Rpb24gKGlzTm9Db3VudCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50WnIgPSB0aGlzLl9nZXRQYXJlbnRacih0aGlzLmFsbE5vZGVzW2ldKTtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5kZWxldGVTZWxlY3RDb24odGhpcy5hbGxOb2Rlc1tpXSwgcGFyZW50WnIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9yTWFwLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5hbGxOb2RlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMub3BlcmF0aW9uTm9kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZHJhZ1NlbGVjdFJlY3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWROb2RlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuaGlkZUNvbm5lY3RvclBvaW50KCk7XHJcbiAgICAgICAgdGhpcy5oaWRlQ29ubmVjdG9yQ29udHJvbCgpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9ycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3pyLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XHJcbiAgICAgICAgdGhpcy5ncm91cC5pc0JnID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl96ci5hZGQodGhpcy5ncm91cCk7XHJcbiAgICAgICAgaWYgKGlzTm9Db3VudCAhPSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RlcENvdW50ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu66L+e57q/55qE5bCP5Zu+5qCH5pON5L2cXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IOWwj+Wbvuagh+eahOWQjeensFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMg5bCP5Zu+5qCH55qE55u45YWz5Y+C5pWwXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaWNvbl0g5bCP5Zu+5qCH6Lev5b6EXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubGluZU5vZGVdIOe6v+auteWunuS+i1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdIOeCueWHu+WQjueahOWbnuiwg1xyXG4gICAgICpcclxuICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAqXHJcbiAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgIHRoaXMuZmlzaFRvcG8uYWRkSWNvbihcImljb24xXCIsIHtcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIGljb246IFwiaHR0cHM6Ly9zczAuYmRzdGF0aWMuY29tLzVhVjFianFoX1EyM29kQ2Yvc3RhdGljL3N1cGVybWFuL2ltZy9sb2dvX3RvcF9jYTc5YTE0Ni5wbmdcIixcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIGxpbmVOb2RlOiBsaW5lTm9kZSxcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KEpTT04uc3RyaW5naWZ5KGV2ZW50LmRhdGEpKVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAqICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uYWRkTGluZUljb24gPSBmaXNoVG9wb1Byb3RvLmFkZEljb24gPSBmdW5jdGlvbiAoa2V5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5saW5lT3BlcmF0aW9uTWFuYWdlci5hZGRJY29uKGtleSwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu66L+e57q/55qE6buY6K6k5Yig6Zmk5pON5L2cXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGxpbmVOb2RlIOe6v1xyXG4gICAgICpcclxuICAgICAqICAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgKlxyXG4gICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICogICAgICBmaXNoVG9wby5saW5lRGVmYXVsdEljb24obGluZU5vZGUpO1xyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmxpbmVEZWZhdWx0SWNvbiA9IGZ1bmN0aW9uIChsaW5lTm9kZSkge1xyXG4gICAgICAgIHRoaXMuYWRkTGluZURlbGV0ZUljb24obGluZU5vZGUpO1xyXG4gICAgICAgIHRoaXMuYWRkTGluZUNoYW5nZUljb24obGluZU5vZGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uui/nue6v+eahOm7mOiupOWIoOmZpOaTjeS9nFxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBsaW5lTm9kZSDnur9cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10g6L+e57q/5pON5L2c55qE6YCJ6aG5XHJcbiAgICAgKlxyXG4gICAgICogICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAqXHJcbiAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgKiAgICAgIGZpc2hUb3BvLmFkZExpbmVDaGFuZ2VJY29uKGxpbmVOb2RlKTtcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5hZGRMaW5lRGVsZXRlSWNvbiA9IGZ1bmN0aW9uIChsaW5lTm9kZSxvcHRpb25zKSB7XHJcbiAgICAgICAgLy/liJvlu7rliKDpmaRcclxuICAgICAgICB0aGlzLmxpbmVPcGVyYXRpb25NYW5hZ2VyLmFkZERlbGV0ZUljb24obGluZU5vZGUsb3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu66L+e57q/55qE6buY6K6k5YiH5o2i57G75Z6L5pON5L2cXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGxpbmVOb2RlIOe6v1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSDov57nur/mk43kvZznmoTpgInpoblcclxuICAgICAqXHJcbiAgICAgKiAgKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICpcclxuICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAqICAgICAgZmlzaFRvcG8uYWRkTGluZUNoYW5nZUljb24obGluZU5vZGUpO1xyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmFkZExpbmVDaGFuZ2VJY29uID0gZnVuY3Rpb24gKGxpbmVOb2RlLG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmxpbmVPcGVyYXRpb25NYW5hZ2VyLmFkZENoYW5nZUxpbmVUeXBlSWNvbihsaW5lTm9kZSxvcHRpb25zKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlj5jmm7TlvZPliY3nur/nmoTnsbvlnovvvIzlpoLmnpzkuI3kvKDliJnmjInpobrluo/lj5bkuIvkuIDkuKrnsbvlnovjgILlhYjliKDpmaTljp/mnaXnmoTnur/mrrUg5YaN5aKe5Yqg5LiA56eN57G75Z6L55qE57q/5q61XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZVR5cGUg5qyy5Y+Y5pu057q/55qE57G75Z6LXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uY2hhbmdlU2VsZWN0Q29ubmVjdG9yVHlwZSA9IGZ1bmN0aW9uKGxpbmVUeXBlKSB7XHJcbiAgICAgICAgdmFyIG5leHRMaW5lVHlwZSA9IGxpbmVUeXBlO1xyXG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zZWxDb25uZWN0b3I7XHJcbiAgICAgICAgdmFyIG9yaWdpbkxpbmVUeXBlID0gbGluZS5vcHRpb25zLnN0eWxlLmxpbmVUeXBlO1xyXG4gICAgICAgIGlmIChuZXh0TGluZVR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKG5leHRMaW5lVHlwZSA9PSBvcmlnaW5MaW5lVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGFyckxpbmVUeXBlID0gW0Nvbm5lY3Rvci5UWVBFX1NUUkFJR0hULCBDb25uZWN0b3IuVFlQRV9KQUdHRUQsIENvbm5lY3Rvci5UWVBFX0NVUlZFXTtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0genJVdGlsLmluZGV4T2YoYXJyTGluZVR5cGUsIG9yaWdpbkxpbmVUeXBlKTtcclxuICAgICAgICAgICAgbmV4dExpbmVUeXBlID0gYXJyTGluZVR5cGVbKGluZGV4ICsgMSkgJSBhcnJMaW5lVHlwZS5sZW5ndGhdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy90aGlzLnJlbW92ZShsaW5lLCB7dHJpZ2dlcjpmYWxzZX0pOyDov5nmoLfkvJrliKDpmaRpY29uc1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuZGVsZXRlTGluZSh0aGlzLl9nZXRQYXJlbnRacihsaW5lKSk7XHJcbiAgICAgICAgdGhpcy5saW5lT3BlcmF0aW9uTWFuYWdlci5oaWRlQWxsTGluZU9wZXJhdGlvbigpO1xyXG5cclxuICAgICAgICB6clV0aWwubWVyZ2UobGluZS5vcHRpb25zLCB7IGRvY2tlcnM6IFtdIH0sIHRydWUpO1xyXG4gICAgICAgIHpyVXRpbC5tZXJnZShsaW5lLm9wdGlvbnMuc3R5bGUsIHsgbGluZVR5cGU6IG5leHRMaW5lVHlwZSB9LCB0cnVlKTtcclxuICAgICAgICB2YXIgbmV4dExpbmUgPSB0aGlzLmNyZWF0ZUNvbm5lY3RvckJ5Tm9kZXMobGluZS5zdGFydE5vZGUsIGxpbmUuZW5kTm9kZSwgbGluZS5vcHRpb25zLCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKG5leHRMaW5lKSB7XHJcbiAgICAgICAgICAgIG5leHRMaW5lLmljb25zID0gbGluZS5pY29ucztcclxuICAgICAgICAgICAgbmV4dExpbmUub24oJ0Nvbm5lY3RvcjpjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGluZU9wZXJhdGlvbk1hbmFnZXIuYmluZE9wZXJhdGlvbihuZXh0TGluZSk7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOagueaNrnBvaW505Yib5bu66IqC54K55LiK55qE6L+e5o6l54K5XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnQgeO+8jHnlnZDmoIcgIHt4OngsIHk6eX1cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwb3MgeO+8jHnlnZDmoIcgW3JpZ2h0fGxlZnR8dG9wfGJvdHRvbV1cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lVHlwZSB477yMeeWdkOaghyBbc3RyYWlnaHR8amFnZ2VkfGN1cnZlXVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmNyZWF0ZUNvbm5lY3RvclBvaW50ID0gZnVuY3Rpb24ocG9pbnQsIHBvcywgbGluZVR5cGUpIHtcclxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwb2ludEluc3RhbmNlID0gbmV3IGdyYXBoaWMuQ2lyY2xlKHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIGN4OiBwb2ludC54LFxyXG4gICAgICAgICAgICAgICAgY3k6IHBvaW50LnksXHJcbiAgICAgICAgICAgICAgICByOiA0XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnI0ZGRkYzMycsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6JyMwMDAwMDAnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHogOiA0LFxyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGxpbmVUeXBlOiBsaW5lVHlwZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHBvaW50SW5zdGFuY2UudHlwZSA9ICdDb25uZWN0UG9pbnQnO1xyXG4gICAgICAgIHBvaW50SW5zdGFuY2UucG9zID0gcG9zOyAgICAgICAgICAgICAgICAvL+iusOW9leaYr+iKgueCueS4iuWTquS4quS9jee9rueahOi/nuaOpeeCuVxyXG4gICAgICAgIHZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFsnZHJhZ3N0YXJ0JywgJ2RyYWcnLCAnZHJhZ2VuZCddO1xyXG4gICAgICAgIHpyVXRpbC5lYWNoKE1PVVNFX0VWRU5UX05BTUVTLCBmdW5jdGlvbihldmVOYW1lKSB7XHJcbiAgICAgICAgICAgIHBvaW50SW5zdGFuY2Uub24oZXZlTmFtZSwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gXCJDb25uZWN0UG9pbnQ6XCIgKyBldmVOYW1lO1xyXG4gICAgICAgICAgICAgICAgbWUuZ3JvdXAudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5ncm91cC5hZGQocG9pbnRJbnN0YW5jZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog6ZqQ6JeP6IqC54K55LiK55qE6L+e5o6l54K5XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uaGlkZUNvbm5lY3RvclBvaW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAuY2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICh2LnR5cGUgPT09ICdDb25uZWN0UG9pbnQnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Lmdyb3VwLnJlbW92ZSh2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdGhpcy5ncm91cC5vZmYoXCJDb25uZWN0UG9pbnQ6ZHJhZ3N0YXJ0XCIpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAub2ZmKFwiQ29ubmVjdFBvaW50OmRyYWdcIik7XHJcbiAgICAgICAgdGhpcy5ncm91cC5vZmYoXCJDb25uZWN0UG9pbnQ6ZHJhZ2VuZFwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiDmoLnmja7oioLngrnmlbDnu4TliqjmgIHliJvlu7rov57mjqXngrlcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBsaW5lVHlwZSDpnIDopoHlsZXnpLrov57mjqXngrnnmoToioLngrnmlbDnu4RcclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gbGluZVR5cGUg6L+e57q/55qE57q/5q6157G75Z6LIFtzdHJhaWdodHxqYWdnZWR8Y3VydmVdXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZmlsdGVyQ29ubmVjdFBvaW50ID0gZnVuY3Rpb24odGFyZ2V0Tm9kZXMsIGxpbmVUeXBlKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBncm91cE5vZGVzID0gW107IC8vIOiusOW9lee7hOWGheiKgueCuVxyXG4gICAgICAgIHZhciBvdXRzaWRlTm9kZXMgPSBbXTsgLy8g6K6w5b2V57uE5aSW6IqC54K5XHJcbiAgICAgICAgdmFyIG5vZGVzID0gW107XHJcbiAgICAgICAgaWYgKHRhcmdldE5vZGVzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgdGFyZ2V0Tm9kZXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoRmxvdy5pc0dyb3VwTm9kZShpdGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBOb2RlcyA9IGdyb3VwTm9kZXMuY29uY2F0KGl0ZW0uY2hpbGRyZW4oKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHNpZGVOb2Rlcy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8g5q+U6L6D57uE5YaF5aSW6IqC54K577yM6L+H5ruk57uE5YaF6IqC54K5XHJcbiAgICAgICAgICAgIG91dHNpZGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIGlmICghZ3JvdXBOb2Rlcy5pbmNsdWRlcyhpdGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGVzID0gdGFyZ2V0Tm9kZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICB2YXIgcmVjdCA9IHV0aWwuZ2V0UmVjdChpdGVtKTtcclxuICAgICAgICAgICAgdmFyIGNvbm5lY3RvclBvaW50ID0gdXRpbC5nZXRDb25uZWN0b3JQb2ludHMocmVjdCwgaXRlbSk7XHJcbiAgICAgICAgICAgIHRoYXQuY3JlYXRlQ29ubmVjdG9yUG9pbnQoY29ubmVjdG9yUG9pbnQubGVmdCwgXCJsZWZ0XCIsIGxpbmVUeXBlKTtcclxuICAgICAgICAgICAgdGhhdC5jcmVhdGVDb25uZWN0b3JQb2ludChjb25uZWN0b3JQb2ludC5yaWdodCwgXCJyaWdodFwiLCBsaW5lVHlwZSk7XHJcbiAgICAgICAgICAgIHRoYXQuY3JlYXRlQ29ubmVjdG9yUG9pbnQoY29ubmVjdG9yUG9pbnQudG9wLCBcInRvcFwiLCBsaW5lVHlwZSk7XHJcbiAgICAgICAgICAgIHRoYXQuY3JlYXRlQ29ubmVjdG9yUG9pbnQoY29ubmVjdG9yUG9pbnQuYm90dG9tLCBcImJvdHRvbVwiLCBsaW5lVHlwZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlnKjoioLngrnkuIrmmL7npLrov57mjqXngrlcclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gbGluZVR5cGUg6L+e57q/55qE57q/5q6157G75Z6LIFtzdHJhaWdodHxqYWdnZWR8Y3VydmVdXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIOi/nue6v+eahOe6v+auteWxnuaAp1xyXG4gICAgICpcclxuICAgICAqICAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgKlxyXG4gICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICogICAgICAgJCgnLmJ0bi1jb25uZWN0LWphZ2dlZCcpLmNsaWNrKGZ1bmN0aW9uKGUpIHtcclxuICAgICAqICAgICAgICAgICBmaXNoVG9wby5zaG93Q29ubmVjdG9yUG9pbnQoXCJqYWdnZWRcIiwge1xyXG4gICAgICogICAgICAgICAgICAgICBzeW1ib2w6IHtcclxuICAgICAqICAgICAgICAgICAgICAgICAgIC8vIOeureWktOminOiJslxyXG4gICAgICogICAgICAgICAgICAgICAgICAgY29sb3I6IFwiI0JCQkJCQlwiXHJcbiAgICAgKiAgICAgICAgICAgICAgIH0sXHJcbiAgICAgKiAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAvLyDnur/mnaHpopzoibJcclxuICAgICAqICAgICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjQkJCQkJCXCIsXHJcbiAgICAgKiAgICAgICAgICAgICAgIH1cclxuICAgICAqICAgICAgICAgICB9KTtcclxuICAgICAqICAgICAgIH0pO1xyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLnNob3dDb25uZWN0b3JQb2ludCA9IGZ1bmN0aW9uKGxpbmVUeXBlLCBsaW5lT3B0LCBpZkN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuaGlkZUNvbm5lY3RvclBvaW50KCk7XHJcbiAgICAgICAgaWYgKGxpbmVPcHQpIHtcclxuICAgICAgICAgICAgdGhpcy5saW5lT3B0ID0gbGluZU9wdDsgIC8v57yT5a2Y57q/5q6155qE6YWN572u5L+h5oGvXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaWZDdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICBpZkN1cnJlbnROb2RlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0YXJnZXROb2RlcyA9IGlmQ3VycmVudE5vZGUgPyBbdGhhdC5zZWxlY3RlZE5vZGVdIDogdGhhdC5hbGxOb2RlcztcclxuXHJcbiAgICAgICAgaWYgKCFpZkN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgIC8vIOaJgOacieiKgueCuei/nuaOpeeCueWxleekuuWJje+8jOmmluWFiOa4hemZpOeUu+W4g+S4iueahOahhumAiWRyYWdTZWxlY3RcclxuICAgICAgICAgICAgdGhhdC5fcmVtb3ZlT3BlcmF0aW9uTm9kZSgpO1xyXG4gICAgICAgICAgICB0aGF0Ll9yZWxlYXNlU2VsZWN0Tm9kZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g6K6p5omA5pyJ55S75biD5Lit55qE6IqC54K5L+W9k+WJjeiKgueCueaYvuekuui/nuaOpeeCuVxyXG4gICAgICAgIHRoaXMuZmlsdGVyQ29ubmVjdFBvaW50KHRhcmdldE5vZGVzLCBsaW5lVHlwZSk7XHJcblxyXG4gICAgICAgIC8vIOagueaNrui/nue6v+eCueafpeaJvuiKgueCuSjogIPomZHkvJjljJYg5Yib5bu66L+e5o6l54K555qE5pe25YCZIOWwseaKiui/nuaOpeeCueS4jm5vZGXov5vooYznu5HlrprvvIzlsLHkuI3nlKjov5nkuKrlpI3mnYLnmoTorqHnrpfkuoYpXHJcbiAgICAgICAgZnVuY3Rpb24gZmluZENvbm5lY3Rvck5vZGUoeCwgeSwgb2Zmc2V0LCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUsIGVuZFBvcyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoYXQuYWxsTm9kZXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHV0aWwuZ2V0UmVjdChpdGVtKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb25uZWN0b3JQb2ludCA9IHV0aWwuZ2V0Q29ubmVjdG9yUG9pbnRzKHJlY3QsIGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtwb3NdLnggLSB4KSA8PSBvZmZzZXQgJiYgTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbcG9zXS55IC0geSkgPD0gb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1wibGVmdFwiXS54IC0geCkgPD0gb2Zmc2V0ICYmIE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1wibGVmdFwiXS55IC0geSkgPD0gb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvcyA9IFwibGVmdFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1widG9wXCJdLnggLSB4KSA8PSBvZmZzZXQgJiYgTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbXCJ0b3BcIl0ueSAtIHkpIDw9IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRQb3MgPSBcInRvcFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1wicmlnaHRcIl0ueCAtIHgpIDw9IG9mZnNldCAmJiBNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcInJpZ2h0XCJdLnkgLSB5KSA8PSBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kUG9zID0gXCJyaWdodFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1wiYm90dG9tXCJdLnggLSB4KSA8PSBvZmZzZXQgJiYgTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbXCJib3R0b21cIl0ueSAtIHkpIDw9IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRQb3MgPSBcImJvdHRvbVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgbm9kZTogbm9kZSxcclxuICAgICAgICAgICAgICAgIGVuZFBvczogZW5kUG9zXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ3JvdXAub24oXCJDb25uZWN0UG9pbnQ6ZHJhZ3N0YXJ0XCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgLy8g5aaC5p6c5piv5b2T5YmN6IqC54K55pi+56S66L+e5o6l54K577yM6ZyA6KaB5Zyo5ouW5Yqo5Ymq5aS05pe26K6p55S75biD5Lit55qE5YW25LuW6IqC54K55pi+56S66L+e5o6l54K5XHJcbiAgICAgICAgICAgIGlmIChpZkN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmZpbHRlckNvbm5lY3RQb2ludCh0aGF0LmFsbE5vZGVzLCBsaW5lVHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHggPSAoZS5ldmVudC5vZmZzZXRYIC0gdGhhdC5ncm91cC5wb3NpdGlvblswXSkgLyB0aGF0Lm5vd1pvb207XHJcbiAgICAgICAgICAgIHZhciB5ID0gKGUuZXZlbnQub2Zmc2V0WSAtIHRoYXQuZ3JvdXAucG9zaXRpb25bMV0pIC8gdGhhdC5ub3dab29tO1xyXG4gICAgICAgICAgICB2YXIgYXJyb3cgPSBlLmV2ZW50LnRhcmdldDtcclxuICAgICAgICAgICAgdGhhdC5zdGFydFBvcyA9IGFycm93LnBvcztcclxuICAgICAgICAgICAgdGhhdC5zZWxlY3RDb25uTm9kZSA9IGZpbmRDb25uZWN0b3JOb2RlKGFycm93LnNoYXBlLmN4LCBhcnJvdy5zaGFwZS5jeSwgMCwgdGhhdC5zdGFydFBvcykubm9kZTtcclxuICAgICAgICAgICAgYXJyb3cuaGlkZSgpO1xyXG4gICAgICAgICAgICB0aGF0LmxpbmVPcGVyYXRpb25NYW5hZ2VyLmhpZGVBbGxMaW5lT3BlcmF0aW9uKCk7XHJcbiAgICAgICAgICAgIHRoYXQucmV2ZXJzZUNvbm5lY3QgPSBmYWxzZTsgICAvL+aYr+WQpuWPjeWQkei/nue6v+eahOagh+ivhlxyXG4gICAgICAgICAgICB0aGF0Lm9yaWdpbk5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQoeCwgeSk7XHJcbiAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodi5lbmROb2RlLmlkID09PSB0aGF0LnNlbGVjdENvbm5Ob2RlLmlkICYmIHRoYXQuc3RhcnRQb3MgPT09IHYub3B0aW9ucy5wb3NpdGlvbi5lbmRQb3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLmRlbGV0ZUJ5TGluZSh2LCB0aGF0Lmdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdENvbm5Ob2RlID0gdi5zdGFydE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zdGFydFBvcyA9IHYub3B0aW9ucy5wb3NpdGlvbi5zdGFydFBvcztcclxuICAgICAgICAgICAgICAgICAgICB0aGF0Lm9yaWdpbk5vZGUgPSB2LmVuZE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5vcmlnaW5Qb3MgPSB2Lm9wdGlvbnMucG9zaXRpb24uZW5kUG9zO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2LnN0YXJ0Tm9kZS5pZCA9PT0gdGhhdC5zZWxlY3RDb25uTm9kZS5pZCAmJiB0aGF0LnN0YXJ0UG9zID09PSB2Lm9wdGlvbnMucG9zaXRpb24uc3RhcnRQb3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLmRlbGV0ZUJ5TGluZSh2LCB0aGF0Lmdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnJldmVyc2VDb25uZWN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdENvbm5Ob2RlID0gdi5lbmROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZW5kUG9zID0gdi5vcHRpb25zLnBvc2l0aW9uLmVuZFBvcztcclxuICAgICAgICAgICAgICAgICAgICB0aGF0Lm9yaWdpbk5vZGUgPSB2LnN0YXJ0Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0Lm9yaWdpblBvcyA9IHYub3B0aW9ucy5wb3NpdGlvbi5zdGFydFBvcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgdmFyIGNvbm5lY3RvcjtcclxuICAgICAgICAgICAgaWYgKHRoYXQucmV2ZXJzZUNvbm5lY3QpIHtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3RvciA9IHRoYXQuY29ubmVjdGlvbk1hbmFnZXIubWFuYWdlUmV2ZXJzZVRlbXBDb25uZWN0b3IocG9pbnQsIHRoYXQuc2VsZWN0Q29ubk5vZGUsIGFycm93LmxpbmVUeXBlLCB0aGF0LmVuZFBvcyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3IgPSB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLm1hbmFnZVRlbXBDb25uZWN0b3IodGhhdC5zZWxlY3RDb25uTm9kZSwgcG9pbnQsIGFycm93LmxpbmVUeXBlLCB0aGF0LnN0YXJ0UG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGF0Lmdyb3VwLmFkZChjb25uZWN0b3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAub24oXCJDb25uZWN0UG9pbnQ6ZHJhZ1wiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gKGUuZXZlbnQub2Zmc2V0WCAtIHRoYXQuZ3JvdXAucG9zaXRpb25bMF0pIC8gdGhhdC5ub3dab29tO1xyXG4gICAgICAgICAgICB2YXIgeSA9IChlLmV2ZW50Lm9mZnNldFkgLSB0aGF0Lmdyb3VwLnBvc2l0aW9uWzFdKSAvIHRoYXQubm93Wm9vbTtcclxuICAgICAgICAgICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xyXG4gICAgICAgICAgICB2YXIgYXJyb3cgPSBlLmV2ZW50LnRhcmdldDtcclxuICAgICAgICAgICAgaWYgKHRoYXQucmV2ZXJzZUNvbm5lY3QpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIubWFuYWdlUmV2ZXJzZVRlbXBDb25uZWN0b3IocG9pbnQsIHRoYXQuc2VsZWN0Q29ubk5vZGUsIGFycm93LmxpbmVUeXBlLCB0aGF0LmVuZFBvcyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLm1hbmFnZVRlbXBDb25uZWN0b3IodGhhdC5zZWxlY3RDb25uTm9kZSwgcG9pbnQsIGFycm93LmxpbmVUeXBlLCB0aGF0LnN0YXJ0UG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGF0Lmdyb3VwLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHYudHlwZSA9PT0gJ0Nvbm5lY3RQb2ludCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2LmF0dHIoe3N0eWxlOntmaWxsOiBcIiNGRkZGMzNcIn0sc2NhbGU6WzEsMV0sb3JpZ2luOlt2LnNoYXBlLmN4LHYuc2hhcGUuY3ldfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHYuc2hhcGUuY3ggLSB4KSA8PSAxMCAmJiBNYXRoLmFicyh2LnNoYXBlLmN5IC0geSkgPD0gMTApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IGZpbmRDb25uZWN0b3JOb2RlKHgsIHksIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQucmV2ZXJzZUNvbm5lY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIubWFuYWdlUmV2ZXJzZVRlbXBDb25uZWN0b3IocG9pbnQsIHRoYXQuc2VsZWN0Q29ubk5vZGUsIGFycm93LmxpbmVUeXBlLCB0aGF0LmVuZFBvcywgcmVzLmVuZFBvcywgcmVzLm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5tYW5hZ2VUZW1wQ29ubmVjdG9yKHRoYXQuc2VsZWN0Q29ubk5vZGUsIHBvaW50LCBhcnJvdy5saW5lVHlwZSwgdGhhdC5zdGFydFBvcywgcmVzLmVuZFBvcywgcmVzLm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYuYXR0cih7c3R5bGU6e2ZpbGw6IFwiI2ZmMDAwMFwifSxzY2FsZTpbMS41LDEuNV0sb3JpZ2luOlt2LnNoYXBlLmN4LHYuc2hhcGUuY3ldfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAub24oXCJDb25uZWN0UG9pbnQ6ZHJhZ2VuZFwiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gKGUuZXZlbnQub2Zmc2V0WCAtIHRoYXQuZ3JvdXAucG9zaXRpb25bMF0pIC8gdGhhdC5ub3dab29tO1xyXG4gICAgICAgICAgICB2YXIgeSA9IChlLmV2ZW50Lm9mZnNldFkgLSB0aGF0Lmdyb3VwLnBvc2l0aW9uWzFdKSAvIHRoYXQubm93Wm9vbTtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IGZpbmRDb25uZWN0b3JOb2RlKHgsIHksIDEwKTtcclxuICAgICAgICAgICAgdmFyIHRhcmdldE5vZGUgPSByZXMubm9kZTtcclxuICAgICAgICAgICAgdmFyIGVuZFBvcyA9IHJlcy5lbmRQb3MgfHwgJ2xlZnQnO1xyXG4gICAgICAgICAgICB2YXIgYXJyb3cgPSBlLmV2ZW50LnRhcmdldDtcclxuICAgICAgICAgICAgLy/liKDpmaTkuLTml7bnur9cclxuICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5yZW1vdmVUZW1wQ29ubmVjdG9yKHRoYXQuZ3JvdXApO1xyXG5cclxuICAgICAgICAgICAgLy8yLuWmguaenOaJvuWIsOebruagh+e7k+eCuSDliJnnlLvnur9cclxuICAgICAgICAgICAgaWYgKHRhcmdldE5vZGUgJiYgKHRoYXQuc2VsZWN0Q29ubk5vZGUuaWQgIT09IHRhcmdldE5vZGUuaWQpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXIgY29ubmVjdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZVR5cGU6IGFycm93LmxpbmVUeXBlXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFBvczogdGhhdC5yZXZlcnNlQ29ubmVjdCA/IGVuZFBvcyA6IHRoYXQuc3RhcnRQb3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvczogdGhhdC5yZXZlcnNlQ29ubmVjdCA/IHRoYXQuZW5kUG9zIDogZW5kUG9zXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGZpbmFsT3B0ID0gdXRpbC5tZXJnZU9wdChjb25uZWN0T3B0aW9ucywgdGhhdC5saW5lT3B0LCB0cnVlLCAncG9zaXRpb24nKTtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHRoYXQucmV2ZXJzZUNvbm5lY3QgPyB0YXJnZXROb2RlIDogdGhhdC5zZWxlY3RDb25uTm9kZTtcclxuICAgICAgICAgICAgICAgIHZhciBlbmQgPSB0aGF0LnJldmVyc2VDb25uZWN0ID8gdGhhdC5zZWxlY3RDb25uTm9kZSA6IHRhcmdldE5vZGU7XHJcbiAgICAgICAgICAgICAgICAvL+WmguaenOacieWOn+Wni+i/nue6v+WtmOWcqO+8jOWImeimgeaatOmcsuWHuuWOu+OAglxyXG4gICAgICAgICAgICAgICAgaWYgKHRoYXQub3JpZ2luTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbi5zdGFydE5vZGUgPSB0aGF0LnJldmVyc2VDb25uZWN0ID8gdGhhdC5vcmlnaW5Ob2RlIDogdGhhdC5zZWxlY3RDb25uTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW4uZW5kTm9kZSA9IHRoYXQucmV2ZXJzZUNvbm5lY3QgPyB0aGF0LnNlbGVjdENvbm5Ob2RlIDogdGhhdC5vcmlnaW5Ob2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbi5vcHRpb25zID0gdXRpbC5tZXJnZU9wdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lVHlwZTogYXJyb3cubGluZVR5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zOiB0aGF0LnJldmVyc2VDb25uZWN0ID8gdGhhdC5vcmlnaW5Qb3MgOiB0aGF0LnN0YXJ0UG9zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kUG9zOiB0aGF0LnJldmVyc2VDb25uZWN0ID8gdGhhdC5lbmRQb3MgOiB0aGF0Lm9yaWdpblBvc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhhdC5saW5lT3B0LCB0cnVlLCAncG9zaXRpb24nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKCF0aGF0Ll90cmlnZ2VyKCdiZWZvcmVDcmVhdGUnLCB7dGFyZ2V0OiBzdGFydCwgZW5kTm9kZTogZW5kLCBjb25uZWN0T3B0aW9uczogZmluYWxPcHQsIG9yaWdpbjogb3JpZ2lufSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGF0LmNyZWF0ZUNvbm5lY3RvckJ5Tm9kZXMoc3RhcnQsIGVuZCwgZmluYWxPcHQpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5oaWRlQ29ubmVjdG9yUG9pbnQoKTsgICAgICAvL+makOiXj+aJgOacieiKgueCueS4iueahOi/nuaOpeeCuVxyXG4gICAgICAgICAgICAgICAgLy8g6Kem5Y+Rc2VsZWN0Q29ubk5vZGXngrnlh7tcclxuICAgICAgICAgICAgICAgIC8vIHRoYXQubm9kZUNsaWNrSGFuZGxlcih0aGF0LnNlbGVjdENvbm5Ob2RlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFycm93LnNob3coKTtcclxuICAgICAgICAgICAgICAgIGFycm93LnBvc2l0aW9uID0gWzAsIDBdO1xyXG4gICAgICAgICAgICAgICAgLy/ov5jljp/miYDmnInov57mjqXngrnnmoTpopzoibJcclxuICAgICAgICAgICAgICAgIHRoYXQuZ3JvdXAuY2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYudHlwZSA9PT0gJ0Nvbm5lY3RQb2ludCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdi5hdHRyKHtzdHlsZTp7ZmlsbDogXCIjRkZGRjMzXCJ9LHNjYWxlOlsxLDFdLG9yaWdpbjpbdi5zaGFwZS5jeCx2LnNoYXBlLmN5XX0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmaXNoVG9wb1Byb3RvLmNyZWF0ZUxpbmVDb25uZWN0b3JQb2ludCA9IGZ1bmN0aW9uKHBvaW50LCBwb3MsIGxpbmVUeXBlKSB7XHJcbiAgICAgICAgdmFyIHBvaW50SW5zdGFuY2UgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgY3g6IHBvaW50LngsXHJcbiAgICAgICAgICAgICAgICBjeTogcG9pbnQueSxcclxuICAgICAgICAgICAgICAgIHI6IDRcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjRkZGRjMzJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTonIzAwMDAwMCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgeiA6IDQsXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgbGluZVR5cGU6IGxpbmVUeXBlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcG9pbnRJbnN0YW5jZS50eXBlID0gJ0Nvbm5lY3RQb2ludCc7XHJcbiAgICAgICAgcG9pbnRJbnN0YW5jZS5wb3MgPSBwb3M7ICAgICAgICAgICAgICAgIC8v6K6w5b2V5piv6IqC54K55LiK5ZOq5Liq5L2N572u55qE6L+e5o6l54K5XHJcbiAgICAgICAgdGhpcy5ncm91cC5hZGQocG9pbnRJbnN0YW5jZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZmlzaFRvcG9Qcm90by5nZXRSb3RhdGVkQ29ybmVyQ3Vyc29yID0gZnVuY3Rpb24obm9kZSwgcG9zKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciByb3RhdGlvbiA9IG5vZGUucm90YXRpb247XHJcbiAgICAgICAgaWYgKHBvcyA9PT0gJ210cicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoYXQuY3Vyc29yTWFwW3Bvc107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChNYXRoLmFicyhyb3RhdGlvbikgPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IC1yb3RhdGlvbiAvIChNYXRoLlBJLzE4MCk7XHJcbiAgICAgICAgICAgIHZhciBuID0gTWF0aC5yb3VuZCgoYW5nbGUgJSAzNjApIC8gNDUpO1xyXG4gICAgICAgICAgICBpZiAobiA8IDApIHtcclxuICAgICAgICAgICAgICAgIG4gKz0gODsgLy8gZnVsbCBjaXJjbGUgYWhlYWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuICs9IHRoYXQuY3Vyc29yT2Zmc2V0W3Bvc107XHJcbiAgICAgICAgICAgIG4gJT0gODtcclxuICAgICAgICAgICAgcmV0dXJuIHRoYXQuY3Vyc29yTWFwc1tuXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoYXQuY3Vyc29yTWFwW3Bvc107XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog5qC55o2ucG9pbnTliJvlu7roioLngrnkuIrnmoTmjqfliLbngrlcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludCB477yMeeWdkOaghyAge3g6eCwgeTp5fVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBvcyB477yMeeWdkOaghyBbdGx8dGN8dHJ8Ymx8YnJ8bXRyXSAodG9wLWxlZnQsIHRvcC1jZW50ZXIsIHRvcC1yaWdodCwgYm90dG9tLWxlZnQsIGJvdHRvbS1yaWdodCwgbWlkZGxlLXRvcC1yb3RhdGUpXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbm9kZUlkIOWIm+W7uuaOp+WItueCueaXtuS8oOWFpeW9k+WJjeiKgueCueeahGlk77yM5a6M5oiQ6IqC54K55LiO5o6n5Yi254K555qE57uR5a6aXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uY3JlYXRlQ29ubmVjdG9yQ29udHJvbCA9IGZ1bmN0aW9uKHBvaW50LCBwb3MsIG5vZGUpIHtcclxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwb3NBcnIgPSBwb3Muc3BsaXQoJywnKTtcclxuICAgICAgICBpZiAocG9zQXJyLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRyb2xDdXJzb3IgPSBtZS5nZXRSb3RhdGVkQ29ybmVyQ3Vyc29yKG5vZGUsIHBvcyk7XHJcbiAgICAgICAgICAgIHZhciBwb2ludEluc3RhbmNlID0gbmV3IGdyYXBoaWMuUmVjdCh7XHJcbiAgICAgICAgICAgICAgICBzaGFwZTp7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogcG9pbnQueCAtIDQsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogcG9pbnQueSAtIDQsXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiA4XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICBmaWxsOiAnI2ZmZmZmZicsXHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOicjMDAwMDAwJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHo6IDQsXHJcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogbm9kZS5yb3RhdGlvbixcclxuICAgICAgICAgICAgICAgIG9yaWdpbjogW3BvaW50LngsIHBvaW50LnldLFxyXG4gICAgICAgICAgICAgICAgY3Vyc29yOiBjb250cm9sQ3Vyc29yLFxyXG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBwb2ludEluc3RhbmNlLnR5cGUgPSAnQ29ubmVjdENvbnRyb2wnO1xyXG4gICAgICAgICAgICBwb2ludEluc3RhbmNlLnBvcyA9IHBvczsvLyDorrDlvZXmmK/oioLngrnkuIrlk6rkuKrkvY3nva7nmoTov57mjqXngrlcclxuICAgICAgICAgICAgdmFyIE1PVVNFX0VWRU5UX05BTUVTID0gWydkcmFnc3RhcnQnLCAnZHJhZycsICdkcmFnZW5kJ107XHJcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKE1PVVNFX0VWRU5UX05BTUVTLCBmdW5jdGlvbihldmVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludEluc3RhbmNlLm9uKGV2ZU5hbWUsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IFwiQ29ubmVjdENvbnRyb2w6XCIgKyBldmVOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ub2RlSWQgPSBub2RlLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5jdXJzb3IgPSBjb250cm9sQ3Vyc29yO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lLmdyb3VwLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKHBvaW50SW5zdGFuY2UpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIOaXi+i9rOeCueS4juiKgueCueS5i+mXtOmcgOimgei/nue6v1xyXG4gICAgICAgICAgICB2YXIgbGluZSA9IG5ldyBncmFwaGljLkxpbmUoe1xyXG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB4MTogcG9pbnQudG9wLngsXHJcbiAgICAgICAgICAgICAgICAgICAgeTE6IHBvaW50LnRvcC55LFxyXG4gICAgICAgICAgICAgICAgICAgIHgyOiBwb2ludC5ib3R0b20ueCxcclxuICAgICAgICAgICAgICAgICAgICB5MjogcG9pbnQuYm90dG9tLnlcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHo6IDEsXHJcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxpbmUudHlwZSA9ICdDb25uZWN0Q29udHJvbExpbmUnO1xyXG4gICAgICAgICAgICBsaW5lLm5vZGVJZCA9IG5vZGUuaWQ7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKGxpbmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgcmV0dXJuQ29ubmVjdG9yQ29udHJvbFBhcmFtXHJcbiAgICAgKiDov5Tlm57ml4vovazngrnlkoznvKnmlL7ngrnmjqfliLblj4LmlbBcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0g5b2T5YmN6IqC54K55a+56LGhXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8ucmV0dXJuQ29ubmVjdG9yQ29udHJvbFBhcmFtID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgIHZhciBzY2FsZUZsYWcgPSB0eXBlb2Ygbm9kZS5zY2FsZWFibGUgPT09ICdib29sZWFuJyA/IG5vZGUuc2NhbGVhYmxlIDogdGhpcy5vcHRpb25zLnNjYWxlYWJsZTtcclxuICAgICAgICB2YXIgcm90YXRlRmxhZyA9IHR5cGVvZiBub2RlLnJvdGF0YWJsZSA9PT0gJ2Jvb2xlYW4nID8gbm9kZS5yb3RhdGFibGUgOiB0aGlzLm9wdGlvbnMucm90YXRhYmxlO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNjYWxlYWJsZTogc2NhbGVGbGFnLFxyXG4gICAgICAgICAgICByb3RhdGFibGU6IHJvdGF0ZUZsYWdcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog6ZqQ6JeP6IqC54K55LiK55qE5o6n5Yi254K5XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uaGlkZUNvbm5lY3RvckNvbnRyb2wgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHR5cGVzID0gWydDb25uZWN0Q29udHJvbCcsICdDb25uZWN0Q29udHJvbExpbmUnXTtcclxuICAgICAgICB0aGlzLmdyb3VwLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBpZiAodHlwZXMuaW5jbHVkZXModi50eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5ncm91cC5yZW1vdmUodik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIHRoaXMuZ3JvdXAub2ZmKFwiQ29ubmVjdENvbnRyb2w6ZHJhZ3N0YXJ0XCIpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAub2ZmKFwiQ29ubmVjdENvbnRyb2w6ZHJhZ1wiKTtcclxuICAgICAgICB0aGlzLmdyb3VwLm9mZihcIkNvbm5lY3RDb250cm9sOmRyYWdlbmRcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlnKjoioLngrnkuIrmmL7npLrmjqfliLbngrlcclxuICAgICAqXHJcbiAgICAgKiAgKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICpcclxuICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAqICAgICAgZmlzaFRvcG8uc2hvd0Nvbm5lY3RvckNvbnRyb2woKTtcclxuICAgICovXHJcbiAgIGZpc2hUb3BvUHJvdG8uc2hvd0Nvbm5lY3RvckNvbnRyb2wgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHRoaXMuaGlkZUNvbm5lY3RvckNvbnRyb2woKTtcclxuICAgIC8vIOiuqeW9k+WJjeiKgueCueaYvuekuuaOp+WItueCuVxyXG4gICAgdmFyIHJlY3QgPSB1dGlsLmdldFJlY3QodGhpcy5zZWxlY3RlZE5vZGUpO1xyXG4gICAgdmFyIGNvbm5lY3RvclBvaW50ID0gdXRpbC5nZXRDb25uZWN0b3JDb250cm9scyhyZWN0LCB0aGlzLnNlbGVjdGVkTm9kZSk7XHJcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5yZXR1cm5Db25uZWN0b3JDb250cm9sUGFyYW0odGhpcy5zZWxlY3RlZE5vZGUpO1xyXG4gICAgaWYgKHBhcmFtcy5zY2FsZWFibGUpIHtcclxuICAgICAgICB0aGF0LmNyZWF0ZUNvbm5lY3RvckNvbnRyb2woY29ubmVjdG9yUG9pbnQudGwsIFwidGxcIiwgdGhpcy5zZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgIHRoYXQuY3JlYXRlQ29ubmVjdG9yQ29udHJvbChjb25uZWN0b3JQb2ludC50ciwgXCJ0clwiLCB0aGlzLnNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgdGhhdC5jcmVhdGVDb25uZWN0b3JDb250cm9sKGNvbm5lY3RvclBvaW50LmJsLCBcImJsXCIsIHRoaXMuc2VsZWN0ZWROb2RlKTtcclxuICAgICAgICB0aGF0LmNyZWF0ZUNvbm5lY3RvckNvbnRyb2woY29ubmVjdG9yUG9pbnQuYnIsIFwiYnJcIiwgdGhpcy5zZWxlY3RlZE5vZGUpO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhcmFtcy5yb3RhdGFibGUpIHtcclxuICAgICAgICB0aGF0LmNyZWF0ZUNvbm5lY3RvckNvbnRyb2woY29ubmVjdG9yUG9pbnQubXRyLCBcIm10clwiLCB0aGlzLnNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgdGhhdC5jcmVhdGVDb25uZWN0b3JDb250cm9sKHsgdG9wOiBjb25uZWN0b3JQb2ludC5tdHIsIGJvdHRvbTogY29ubmVjdG9yUG9pbnQudGMgfSwgXCJtdHIsdGNcIiwgdGhpcy5zZWxlY3RlZE5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGZpbmRDb250cm9sTm9kZSAoaWQpIHtcclxuICAgICAgICB2YXIgbm9kZSA9IG51bGw7XHJcbiAgICAgICAgdGhhdC5ncm91cC5jaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICBpZiAoaXRlbS5pZCA9PT0gaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZ3JvdXAub24oXCJDb25uZWN0Q29udHJvbDpkcmFnc3RhcnRcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIC8vIOmmluWFiOa4hemZpOWFtuS7luaJgOacieiKgueCueeahOaOp+WItueCueWSjOi/nuaOpeeCuVxyXG4gICAgICAgIHZhciBjdXJzb3IgPSBlLmV2ZW50LnRhcmdldC5jdXJzb3I7XHJcbiAgICAgICAgdmFyIHBvcyA9IGUuZXZlbnQudGFyZ2V0LnBvcztcclxuICAgICAgICB2YXIgcG9zTWFwID0ge1xyXG4gICAgICAgICAgICAndGwnOiAnYnInLFxyXG4gICAgICAgICAgICAndHInOiAnYmwnLFxyXG4gICAgICAgICAgICAnYmwnOiAndHInLFxyXG4gICAgICAgICAgICAnYnInOiAndGwnXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGF0LnNlbGVjdENvbm5Ob2RlID0gZmluZENvbnRyb2xOb2RlKGUubm9kZUlkKTtcclxuICAgICAgICBpZiAoY3Vyc29yICYmIHBvcyAhPT0gJ210cicpIHtcclxuICAgICAgICAgICAgdmFyIG9yaWdpbk5vZGUgPSB0aGF0Lmdyb3VwLmNoaWxkcmVuKCkuZmluZChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucG9zID09PSBwb3NNYXBbcG9zXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHRoYXQuZ3JvdXAuY2hpbGRyZW4oKS5maW5kKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5wb3MgPT09IHBvcztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0aGF0LnNlbGVjdENvbm5Ob2RlLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgICAgICB0aGF0Lm9wcG9zaXRlU2hhcGUgPSB6clV0aWwuY2xvbmUob3JpZ2luTm9kZS5zaGFwZSk7XHJcbiAgICAgICAgICAgIHRoYXQuY3VycmVudFNoYXBlID0genJVdGlsLmNsb25lKGN1cnJlbnROb2RlLnNoYXBlKTtcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSB6clV0aWwuY2xvbmUodXRpbC5nZXRSZWN0KHRoYXQuc2VsZWN0Q29ubk5vZGUsIHRydWUpKTtcclxuICAgICAgICAgICAgdmFyIGRpYWdvbmFsID0gTWF0aC5zcXJ0KE1hdGgucG93KHJlY3Qud2lkdGgsIDIpICsgTWF0aC5wb3cocmVjdC5oZWlnaHQsIDIpKTsvLyDlr7nop5Lnur/plb/luqZcclxuICAgICAgICAgICAgdGhhdC5kaWFnb25hbCA9IGRpYWdvbmFsO1xyXG4gICAgICAgICAgICB0aGF0Lm9yaWdpblJlY3QgPSB6clV0aWwuY2xvbmUocmVjdCk7XHJcbiAgICAgICAgICAgIHRoYXQuaWZQb2ludENlbnRlciA9IGJvdW5kaW5nUmVjdC54IDwgLTE7IC8vIOWIpOaWreS4reW/g+eCueaYr+WQpuWcqOiKgueCueS4reW/gyjljp/lvaLlnKjkuK3lv4PvvIznn6nlvaLlnKjlt6bkuIrop5IpXHJcbiAgICAgICAgICAgIC8vIOenu+mZpG5vZGXpq5jkuq5cclxuICAgICAgICAgICAgdGhhdC5zZWxlY3RDb25uTm9kZS5zZWxlY3RTdHlsZSAmJiB0aGF0Ll9hcGkuZ2V0WnIoKS5yZW1vdmVIb3Zlcih0aGF0LnNlbGVjdENvbm5Ob2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHRoaXMuZ3JvdXAub24oXCJDb25uZWN0Q29udHJvbDpkcmFnXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICB2YXIgY3Vyc29yID0gZS5ldmVudC50YXJnZXQuY3Vyc29yO1xyXG4gICAgICAgIHZhciB0YXJnZXRQb3MgPSBlLmV2ZW50LnRhcmdldC5wb3M7XHJcbiAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gdGhhdC5zZWxlY3RDb25uTm9kZTtcclxuICAgICAgICB2YXIgeCA9IChlLmV2ZW50Lm9mZnNldFggLSB0aGF0Lmdyb3VwLnBvc2l0aW9uWzBdKSAvIHRoYXQubm93Wm9vbTtcclxuICAgICAgICB2YXIgeSA9IChlLmV2ZW50Lm9mZnNldFkgLSB0aGF0Lmdyb3VwLnBvc2l0aW9uWzFdKSAvIHRoYXQubm93Wm9vbTtcclxuICAgICAgICB2YXIgcmVjdCA9IHV0aWwuZ2V0UmVjdChjdXJyZW50Tm9kZSwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKHRhcmdldFBvcyA9PT0gJ210cicpIHtcclxuICAgICAgICAgICAgLy8g5peL6L2sXHJcbiAgICAgICAgICAgIHZhciByX3ggPSB4IC0gY3VycmVudE5vZGUucG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgIHZhciByX3kgPSB5IC0gY3VycmVudE5vZGUucG9zaXRpb25bMV07XHJcbiAgICAgICAgICAgIHZhciBvcmlnaW5zID0ge1xyXG4gICAgICAgICAgICAgICAgeDogcmVjdC54IC0gY3VycmVudE5vZGUucG9zaXRpb25bMF0sXHJcbiAgICAgICAgICAgICAgICB5OiByZWN0LnkgLSBjdXJyZW50Tm9kZS5wb3NpdGlvblsxXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByb3RhdGlvbiA9IE1hdGguYXRhbjIocl95LCByX3gpO1xyXG4gICAgICAgICAgICB0aGF0LnNlbGVjdGVkTm9kZS5hdHRyKHtcclxuICAgICAgICAgICAgICAgICdvcmlnaW4nOiBbb3JpZ2lucy54LCBvcmlnaW5zLnldLFxyXG4gICAgICAgICAgICAgICAgJ3JvdGF0aW9uJzogLXJvdGF0aW9uXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgY29ubmVjdG9yUG9pbnQgPSB1dGlsLmdldENvbm5lY3RvclBvaW50cyhyZWN0LCB0aGF0LnNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgICAgIHZhciBjb250cm9sUG9pbnQgPSB1dGlsLmdldENvbm5lY3RvckNvbnRyb2xzKHJlY3QsIHRoYXQuc2VsZWN0ZWROb2RlKTtcclxuICAgICAgICAgICAgLy8g6IqC54K56L+e57q/54K577yM5o6n5Yi254K55L2N572u5pu05pawXHJcbiAgICAgICAgICAgIHRoYXQuZ3JvdXAuY2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gaXRlbS5wb3M7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAnQ29ubmVjdENvbnRyb2wnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA9PT0gJ210cicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hdHRyKCdwb3NpdGlvbicsIFswLCAwXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYXR0cigncm90YXRpb24nLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRTaGFwZSh7IHg6IGNvbnRyb2xQb2ludFtwb3NdLnggLSA0LCB5OiBjb250cm9sUG9pbnRbcG9zXS55IC0gNCB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JpZ2luJzogW2l0ZW0uc2hhcGUueCArIDQsIGl0ZW0uc2hhcGUueSArIDRdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAncm90YXRpb24nOiAtcm90YXRpb25cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSAnQ29ubmVjdENvbnRyb2xMaW5lJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0U2hhcGUoeyB4MTogY29udHJvbFBvaW50Lm10ci54LCB4MjogY29udHJvbFBvaW50LnRjLngsIHkxOiBjb250cm9sUG9pbnQubXRyLnksIHkyOiBjb250cm9sUG9pbnQudGMueSB9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSAnQ29ubmVjdFBvaW50Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0U2hhcGUoeyBjeDogY29ubmVjdG9yUG9pbnRbcG9zXS54LCBjeTogY29ubmVjdG9yUG9pbnRbcG9zXS55IH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyDnvKnmlL4o57yp5pS+54K56ZyA6KaB57uT5ZCI5peL6L2s6KeS5bqm6K6h566XKVxyXG4gICAgICAgICAgICB2YXIgcmF0aW8gPSAxLFxyXG4gICAgICAgICAgICAgICAgY2VudGVyID0gW10sXHJcbiAgICAgICAgICAgICAgICBjZW50ZXJQb2ludCA9IHt9LFxyXG4gICAgICAgICAgICAgICAgd2lkdGgwLCBoZWlnaHQwO1xyXG4gICAgICAgICAgICB2YXIgY3Vyc29yc1kgPSBbJ24tcmVzaXplJywgJ3MtcmVzaXplJ107XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbk9yZyA9IHtcclxuICAgICAgICAgICAgICAgICd0bCc6ICdicicsXHJcbiAgICAgICAgICAgICAgICAndHInOiAnYmwnLFxyXG4gICAgICAgICAgICAgICAgJ2JsJzogJ3RyJyxcclxuICAgICAgICAgICAgICAgICdicic6ICd0bCdcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHNjYWxlTm9kZXMgPSB0aGF0Lmdyb3VwLmNoaWxkcmVuKCkuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSAnQ29ubmVjdENvbnRyb2wnICYmIG5vZGUucG9zICE9PSAnbXRyJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRDb250cm9sTm9kZSA9IHNjYWxlTm9kZXMuZmluZChmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5wb3MgPT09IHRhcmdldFBvcztcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoeCA8PSA4KSB7XHJcbiAgICAgICAgICAgICAgICB4ID0gODtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoeSA8PSA4KSB7XHJcbiAgICAgICAgICAgICAgICB5ID0gODtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGN1cnNvcnNZLmluY2x1ZGVzKGN1cnNvcikpIHtcclxuICAgICAgICAgICAgICAgIC8vIOiOt+WPlnnovbTmr5TkvovljbPlj69cclxuICAgICAgICAgICAgICAgIHZhciBzdGFydFkgPSBjdXJyZW50Q29udHJvbE5vZGUuc2hhcGUueSArIDQ7XHJcbiAgICAgICAgICAgICAgICByYXRpbyA9IHRoYXQuY3VycmVudFNoYXBlLnkgPj0gdGhhdC5vcHBvc2l0ZVNoYXBlLnkgPyAoKHkgLSB0aGF0Lm9wcG9zaXRlU2hhcGUueSAtIDQpIC8gKHN0YXJ0WSAtIHRoYXQub3Bwb3NpdGVTaGFwZS55KSkgOiAoKHRoYXQub3Bwb3NpdGVTaGFwZS55ICsgNCAtIHkpIC8gKHRoYXQub3Bwb3NpdGVTaGFwZS55IC0gc3RhcnRZKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyDojrflj5Z46L205q+U5L6L5Y2z5Y+vXHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRYID0gY3VycmVudENvbnRyb2xOb2RlLnNoYXBlLnggKyA0O1xyXG4gICAgICAgICAgICAgICAgcmF0aW8gPSB0aGF0LmN1cnJlbnRTaGFwZS54ID49IHRoYXQub3Bwb3NpdGVTaGFwZS54ID8gKCh4IC0gdGhhdC5vcHBvc2l0ZVNoYXBlLnggLSA0KSAvIChzdGFydFggLSB0aGF0Lm9wcG9zaXRlU2hhcGUueCkpIDogKCh0aGF0Lm9wcG9zaXRlU2hhcGUueCArIDQgLSB4KSAvICh0aGF0Lm9wcG9zaXRlU2hhcGUueCAtIHN0YXJ0WCkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCEvXlswLTldKy4/WzAtOV0qLy50ZXN0KHJhdGlvKSkge1xyXG4gICAgICAgICAgICAgICAgcmF0aW8gPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLnVwZGF0ZVNoYXBlKHJhdGlvKTtcclxuXHJcbiAgICAgICAgICAgIHZhciByZWN0U2NhbGUgPSB1dGlsLmdldFJlY3QoY3VycmVudE5vZGUsIHRydWUpO1xyXG4gICAgICAgICAgICBjZW50ZXJQb2ludCA9IHRoYXQuaWZQb2ludENlbnRlciA/IHsgeDogdGhhdC5vcmlnaW5SZWN0LngsIHk6IHRoYXQub3JpZ2luUmVjdC55IH0gOiB7IHg6IHRoYXQub3JpZ2luUmVjdC5ib3VuZGluZ1JlY3QueCwgeTogdGhhdC5vcmlnaW5SZWN0LmJvdW5kaW5nUmVjdC55IH07XHJcbiAgICAgICAgICAgIHZhciBkaWFnb25hbE5ldyA9IE1hdGguc3FydChNYXRoLnBvdyhyZWN0U2NhbGUud2lkdGgsIDIpICsgTWF0aC5wb3cocmVjdFNjYWxlLmhlaWdodCwgMikpOy8vIOWvueinkue6v+mVv+W6plxyXG4gICAgICAgICAgICBzd2l0Y2ggKGN1cnNvcikge1xyXG4gICAgICAgICAgICAgICAgLy8g5LiKLOW3puS4ilxyXG4gICAgICAgICAgICAgICAgY2FzZSAnbi1yZXNpemUnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnbnctcmVzaXplJzpcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDAgPSAodGhhdC5vcHBvc2l0ZVNoYXBlLnggKyA0IC0gY2VudGVyUG9pbnQueCkgKiBkaWFnb25hbE5ldyAvIHRoYXQuZGlhZ29uYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0MCA9ICh0aGF0Lm9wcG9zaXRlU2hhcGUueSArIDQgLSBjZW50ZXJQb2ludC55KSAqIGRpYWdvbmFsTmV3IC8gdGhhdC5kaWFnb25hbDtcclxuICAgICAgICAgICAgICAgICAgICBjZW50ZXIucHVzaCh0aGF0Lm9wcG9zaXRlU2hhcGUueCAtIHdpZHRoMCArIDQsIHRoYXQub3Bwb3NpdGVTaGFwZS55IC0gaGVpZ2h0MCArIDQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgLy8g5Y+zLOWPs+S4ilxyXG4gICAgICAgICAgICAgICAgY2FzZSAnZS1yZXNpemUnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnbmUtcmVzaXplJzpcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDAgPSAoY2VudGVyUG9pbnQueCAtIHRoYXQub3Bwb3NpdGVTaGFwZS54IC0gNCkgKiBkaWFnb25hbE5ldyAvIHRoYXQuZGlhZ29uYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0MCA9ICh0aGF0Lm9wcG9zaXRlU2hhcGUueSArIDQgLSBjZW50ZXJQb2ludC55KSAqIGRpYWdvbmFsTmV3IC8gdGhhdC5kaWFnb25hbDtcclxuICAgICAgICAgICAgICAgICAgICBjZW50ZXIucHVzaCh0aGF0Lm9wcG9zaXRlU2hhcGUueCArIHdpZHRoMCArIDQsIHRoYXQub3Bwb3NpdGVTaGFwZS55IC0gaGVpZ2h0MCArIDQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgLy8g5LiL77yM5Y+z5LiLXHJcbiAgICAgICAgICAgICAgICBjYXNlICdzLXJlc2l6ZSc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzZS1yZXNpemUnOlxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoMCA9IChjZW50ZXJQb2ludC54IC0gdGhhdC5vcHBvc2l0ZVNoYXBlLnggLSA0KSAqIGRpYWdvbmFsTmV3IC8gdGhhdC5kaWFnb25hbDtcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQwID0gKGNlbnRlclBvaW50LnkgLSB0aGF0Lm9wcG9zaXRlU2hhcGUueSAtIDQpICogZGlhZ29uYWxOZXcgLyB0aGF0LmRpYWdvbmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbnRlci5wdXNoKHRoYXQub3Bwb3NpdGVTaGFwZS54ICsgd2lkdGgwICsgNCwgdGhhdC5vcHBvc2l0ZVNoYXBlLnkgKyBoZWlnaHQwICsgNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAvLyDlt6Ys5bem5LiLXHJcbiAgICAgICAgICAgICAgICBjYXNlICd3LXJlc2l6ZSc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzdy1yZXNpemUnOlxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoMCA9ICh0aGF0Lm9wcG9zaXRlU2hhcGUueCArIDQgLSBjZW50ZXJQb2ludC54KSAqIGRpYWdvbmFsTmV3IC8gdGhhdC5kaWFnb25hbDtcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQwID0gKGNlbnRlclBvaW50LnkgLSB0aGF0Lm9wcG9zaXRlU2hhcGUueSAtIDQpICogZGlhZ29uYWxOZXcgLyB0aGF0LmRpYWdvbmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbnRlci5wdXNoKHRoYXQub3Bwb3NpdGVTaGFwZS54IC0gd2lkdGgwICsgNCwgdGhhdC5vcHBvc2l0ZVNoYXBlLnkgKyBoZWlnaHQwICsgNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgb3JpZ2luU2NhbGUgPSB7XHJcbiAgICAgICAgICAgICAgICB4OiByZWN0U2NhbGUueCAtIGNlbnRlclswXSxcclxuICAgICAgICAgICAgICAgIHk6IHJlY3RTY2FsZS55IC0gY2VudGVyWzFdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudE5vZGUuYXR0cih7XHJcbiAgICAgICAgICAgICAgICAncG9zaXRpb24nOiBjZW50ZXIsXHJcbiAgICAgICAgICAgICAgICAnb3JpZ2luJzogW29yaWdpblNjYWxlLngsIG9yaWdpblNjYWxlLnldXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8g5q2k5pe26IqC54K55YyF5Zu055uS6ZyA6KaB6YeN5paw6K6h566XXHJcbiAgICAgICAgICAgIHZhciByZWN0Tm93ID0gdXRpbC5nZXRSZWN0KGN1cnJlbnROb2RlLCB0cnVlKTtcclxuICAgICAgICAgICAgdmFyIGNvbm5lY3RvclBvaW50U2NhbGUgPSB1dGlsLmdldENvbm5lY3RvclBvaW50cyhyZWN0Tm93LCBjdXJyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgIHZhciBjb250cm9sUG9pbnRTY2FsZSA9IHV0aWwuZ2V0Q29ubmVjdG9yQ29udHJvbHMocmVjdE5vdywgY3VycmVudE5vZGUpO1xyXG4gICAgICAgICAgICB0aGF0Lmdyb3VwLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gaXRlbS5wb3M7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zID09PSB0YXJnZXRQb3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLmF0dHIoJ3Bvc2l0aW9uJywgWzAsIDBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdDb25uZWN0Q29udHJvbCcgJiYgcG9zICE9PSBwb3NpdGlvbk9yZ1t0YXJnZXRQb3NdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRTaGFwZSh7IHg6IGNvbnRyb2xQb2ludFNjYWxlW3Bvc10ueCAtIDQsIHk6IGNvbnRyb2xQb2ludFNjYWxlW3Bvc10ueSAtIDQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5hdHRyKCdvcmlnaW4nLCBbY29udHJvbFBvaW50U2NhbGVbcG9zXS54LCBjb250cm9sUG9pbnRTY2FsZVtwb3NdLnldKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSAnQ29ubmVjdENvbnRyb2xMaW5lJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0U2hhcGUoeyB4MTogY29udHJvbFBvaW50U2NhbGUubXRyLngsIHgyOiBjb250cm9sUG9pbnRTY2FsZS50Yy54LCB5MTogY29udHJvbFBvaW50U2NhbGUubXRyLnksIHkyOiBjb250cm9sUG9pbnRTY2FsZS50Yy55IH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSAnQ29ubmVjdFBvaW50Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0U2hhcGUoeyBjeDogY29ubmVjdG9yUG9pbnRTY2FsZVtwb3NdLngsIGN5OiBjb25uZWN0b3JQb2ludFNjYWxlW3Bvc10ueSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoYXQub3BlcmF0aW9uTm9kZS5yZWZyZXNoUG9zdGlvbih0aGF0LnNlbGVjdGVkTm9kZSwgdXRpbC5nZXRSZWN0KHRoYXQuc2VsZWN0ZWROb2RlKSk7XHJcbiAgICAgICAgLy8gMS41IOWIt+aWsOi/nue6v1xyXG4gICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIucmVmcmVzaExpbmVCeU5vZGUodGhhdC5zZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgIC8vIDEuNiDlpoLmnpzmmK/nu4TnmoTor50s6ZyA6KaB5oqK57uE5YaF5omA5pyJ57uT5p6c6YO95Yi35paw5LiA5LiL57q/XHJcbiAgICAgICAgaWYgKEZsb3cuaXNHcm91cE5vZGUodGhhdC5zZWxlY3RlZE5vZGUpKSB7XHJcbiAgICAgICAgICAgIHRoYXQuc2VsZWN0ZWROb2RlLmVhY2goZnVuY3Rpb24oY2hpbGROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLnJlZnJlc2hMaW5lQnlOb2RlKGNoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9KTtcclxuICAgIHRoaXMuZ3JvdXAub24oXCJDb25uZWN0Q29udHJvbDpkcmFnZW5kXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAvLyDmm7TmlrDoioLngrlwb3NpdGlvblxyXG4gICAgICAgIHZhciBub2RlID0gdGhhdC5zZWxlY3RDb25uTm9kZTtcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBub2RlLnBvc2l0aW9uO1xyXG4gICAgICAgIHZhciBvcmlnaW4gPSBub2RlLm9yaWdpbjtcclxuICAgICAgICAvLyBwb3NpdGlvbiBvcmlnaW7lj5bmlbRcclxuICAgICAgICB0aGF0LnNlbGVjdENvbm5Ob2RlLmF0dHIoJ3Bvc2l0aW9uJywgW3BhcnNlSW50KHBvc2l0aW9uWzBdLCAxMCksIHBhcnNlSW50KHBvc2l0aW9uWzFdLCAxMCldKTtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcmlnaW4pKSB7XHJcbiAgICAgICAgICAgIHRoYXQuc2VsZWN0Q29ubk5vZGUuYXR0cignb3JpZ2luJywgW3BhcnNlSW50KG9yaWdpblswXSwgMTApLCBwYXJzZUludChvcmlnaW5bMV0sIDEwKV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBub2RlLnVwZGF0ZVNoYXBlKDEsIHRydWUpO1xyXG4gICAgICAgIGlmIChub2RlLm1vZGVsKSB7XHJcbiAgICAgICAgICAgIC8vIOabtOaWsG1vZGVs77yM5pSv5oyB5bqP5YiX5YyWL+WPjeW6j+WIl+WMllxyXG4gICAgICAgICAgICBub2RlLm1vZGVsLnNldChcIm9wdGlvbnMucm90YXRpb25cIiwgbm9kZS5yb3RhdGlvbik7XHJcbiAgICAgICAgICAgIG5vZGUubW9kZWwuc2V0KFwib3B0aW9ucy5vcmlnaW5cIiwgbm9kZS5vcmlnaW4pO1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSBub2RlLm1vZGVsLm9wdGlvbi5lbGVtZW50VHlwZTtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnRUeXBlID09PSAnSW1hZ2UnKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLm1vZGVsLnNldChcIm9wdGlvbnMuc3R5bGVcIiwgbm9kZS5zdHlsZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLm1vZGVsLnNldChcIm9wdGlvbnMuc2hhcGVcIiwgbm9kZS5zaGFwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMS40IOinpuWPkeeCueWHu1xyXG4gICAgICAgIHRoYXQubm9kZUNsaWNrSGFuZGxlcihub2RlKTtcclxuICAgICAgICB0aGF0LnN0ZXBDb3VudGVyKCk7XHJcbiAgICAgICAgdGhhdC5vcHBvc2l0ZVNoYXBlID0gbnVsbDtcclxuICAgICAgICB0aGF0LmN1cnJlbnRTaGFwZSA9IG51bGw7XHJcbiAgICAgICAgdGhhdC5kaWFnb25hbCA9IG51bGw7XHJcbiAgICAgICAgdGhhdC5vcmlnaW5SZWN0ID0gbnVsbDtcclxuICAgICAgICB0aGF0LmlmUG9pbnRDZW50ZXIgPSBudWxsO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLmluaXRPcGVyYXRpb25Ob2RlID0gZnVuY3Rpb24gKG5vZGUsIGlmQ3VycmVudE5vZGUpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCFpZkN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgIGlmQ3VycmVudE5vZGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlID0gbmV3IE9wZXJhdGlvbk5vZGUobm9kZSwgdGhpcy5ncm91cCwgdGhpcy5fYXBpKTtcclxuICAgICAgICAvLyDmoLnmja7ov57nur/ngrnmn6Xmib7oioLngrko6ICD6JmR5LyY5YyWIOWIm+W7uui/nuaOpeeCueeahOaXtuWAmSDlsLHmiorov57mjqXngrnkuI5ub2Rl6L+b6KGM57uR5a6a77yM5bCx5LiN55So6L+Z5Liq5aSN5p2C55qE6K6h566X5LqGKVxyXG4gICAgICAgIGZ1bmN0aW9uIGZpbmRDb25uZWN0b3JOb2RlKHgsIHksIG9mZnNldCwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlLCBlbmRQb3MgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGF0LmFsbE5vZGVzLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB1dGlsLmdldFJlY3QoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29ubmVjdG9yUG9pbnQgPSB1dGlsLmdldENvbm5lY3RvclBvaW50cyhyZWN0LCBpdGVtKTtcclxuICAgICAgICAgICAgICAgIGlmIChwb3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbcG9zXS54IC0geCkgPD0gb2Zmc2V0ICYmIE1hdGguYWJzKGNvbm5lY3RvclBvaW50W3Bvc10ueSAtIHkpIDw9IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcImxlZnRcIl0ueCAtIHgpIDw9IG9mZnNldCAmJiBNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcImxlZnRcIl0ueSAtIHkpIDw9IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRQb3MgPSBcImxlZnRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcInRvcFwiXS54IC0geCkgPD0gb2Zmc2V0ICYmIE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1widG9wXCJdLnkgLSB5KSA8PSBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kUG9zID0gXCJ0b3BcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcInJpZ2h0XCJdLnggLSB4KSA8PSBvZmZzZXQgJiYgTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbXCJyaWdodFwiXS55IC0geSkgPD0gb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvcyA9IFwicmlnaHRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcImJvdHRvbVwiXS54IC0geCkgPD0gb2Zmc2V0ICYmIE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1wiYm90dG9tXCJdLnkgLSB5KSA8PSBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kUG9zID0gXCJib3R0b21cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUsXHJcbiAgICAgICAgICAgICAgICBlbmRQb3M6IGVuZFBvc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUub24oT3BlcmF0aW9uTm9kZS5BUlJPV19EUkFHU1RBUlQsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZUNvbm5lY3RvclBvaW50KCk7XHJcbiAgICAgICAgICAgIHRoYXQuZmlsdGVyQ29ubmVjdFBvaW50KHRoYXQuYWxsTm9kZXMsIGUuZXZlbnQudGFyZ2V0LmxpbmVUeXBlKTtcclxuICAgICAgICAgICAgdmFyIHggPSAoZS5ldmVudC5vZmZzZXRYIC0gdGhpcy5ncm91cC5wb3NpdGlvblswXSkgLyB0aGlzLm5vd1pvb207XHJcbiAgICAgICAgICAgIHZhciB5ID0gKGUuZXZlbnQub2Zmc2V0WSAtIHRoaXMuZ3JvdXAucG9zaXRpb25bMV0pIC8gdGhpcy5ub3dab29tO1xyXG4gICAgICAgICAgICBpZiAoZS5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVPcHQgPSBlLmRhdGE7ICAvL+e8k+WtmOe6v+auteeahOmFjee9ruS/oeaBr1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8v5ouW5ou95byA5aeL5YWI5oqKIOeureWktOWbvuaghyDnu5npmpDol49cclxuICAgICAgICAgICAgdmFyIGFycm93ID0gZS5ldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgIGFycm93LmhpZGUoKTtcclxuICAgICAgICAgICAgdmFyIHJFbmRQb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcclxuICAgICAgICAgICAgdmFyIGNvbm5lY3RvciA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIubWFuYWdlVGVtcENvbm5lY3Rvcih0aGlzLnNlbGVjdGVkTm9kZSwgckVuZFBvaW50LFxyXG4gICAgICAgICAgICAgICAgYXJyb3cubGluZVR5cGUpO1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChjb25uZWN0b3IpO1xyXG4gICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgLy8g5L6m5ZCsIOeureWktCDmi5bmi73kuovku7ZcclxuICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUub24oT3BlcmF0aW9uTm9kZS5BUlJPV19EUkFHLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB2YXIgeCA9IChlLmV2ZW50Lm9mZnNldFggLSB0aGlzLmdyb3VwLnBvc2l0aW9uWzBdKSAvIHRoaXMubm93Wm9vbTtcclxuICAgICAgICAgICAgdmFyIHkgPSAoZS5ldmVudC5vZmZzZXRZIC0gdGhpcy5ncm91cC5wb3NpdGlvblsxXSkgLyB0aGlzLm5vd1pvb207XHJcbiAgICAgICAgICAgIHZhciBhcnJvdyA9IGUuZXZlbnQudGFyZ2V0O1xyXG4gICAgICAgICAgICB2YXIgckVuZFBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm1hbmFnZVRlbXBDb25uZWN0b3IodGhpcy5zZWxlY3RlZE5vZGUsIHJFbmRQb2ludCwgYXJyb3cubGluZVR5cGUpO1xyXG4gICAgICAgICAgICB0aGF0Lmdyb3VwLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHYudHlwZSA9PT0gJ0Nvbm5lY3RQb2ludCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2LmF0dHIoe3N0eWxlOntmaWxsOiBcIiNGRkZGMzNcIn0sc2NhbGU6WzEsMV0sb3JpZ2luOlt2LnNoYXBlLmN4LHYuc2hhcGUuY3ldfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHYuc2hhcGUuY3ggLSB4KSA8PSAxMCAmJiBNYXRoLmFicyh2LnNoYXBlLmN5IC0geSkgPD0gMTApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IGZpbmRDb25uZWN0b3JOb2RlKHgsIHksIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5tYW5hZ2VUZW1wQ29ubmVjdG9yKHRoYXQuc2VsZWN0ZWROb2RlLCByRW5kUG9pbnQsIGFycm93LmxpbmVUeXBlLCAncmlnaHQnLCByZXMuZW5kUG9zLCByZXMubm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYuYXR0cih7c3R5bGU6e2ZpbGw6IFwiI2ZmMDAwMFwifSxzY2FsZTpbMS41LDEuNV0sb3JpZ2luOlt2LnNoYXBlLmN4LHYuc2hhcGUuY3ldfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgLy/kvqblkKwg566t5aS0IOaLluaLvee7k+adn+S6i+S7tiDnlLvnur9cclxuICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUub24oT3BlcmF0aW9uTm9kZS5BUlJPV19EUkFHRU5ELCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciB4ID0gKGUuZXZlbnQub2Zmc2V0WCAtIHRoYXQuZ3JvdXAucG9zaXRpb25bMF0pIC8gdGhhdC5ub3dab29tO1xyXG4gICAgICAgICAgICB2YXIgeSA9IChlLmV2ZW50Lm9mZnNldFkgLSB0aGF0Lmdyb3VwLnBvc2l0aW9uWzFdKSAvIHRoYXQubm93Wm9vbTtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IGZpbmRDb25uZWN0b3JOb2RlKHgsIHksIDEwKTtcclxuICAgICAgICAgICAgdmFyIHRhcmdldE5vZGUgPSByZXMubm9kZTtcclxuICAgICAgICAgICAgdmFyIGVuZFBvcyA9IHJlcy5lbmRQb3MgfHwgJ2xlZnQnO1xyXG4gICAgICAgICAgICB2YXIgYXJyb3cgPSBlLmV2ZW50LnRhcmdldDtcclxuICAgICAgICAgICAgLy/mi5bmi73nu5PmnZ/lhYjmioog566t5aS05Zu+5qCHIOe7meaYvuekulxyXG4gICAgICAgICAgICBhcnJvdy5zaG93KCk7XHJcbiAgICAgICAgICAgIC8v5Yig6Zmk5Li05pe257q/XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVtb3ZlVGVtcENvbm5lY3Rvcih0aGlzLmdyb3VwKTtcclxuXHJcbiAgICAgICAgICAgIC8vMS7lpoLmnpzmmK/lrZDoioLngrkg5YaFIOiKgueCueaLluaLvSDliJkg5aKe5Yqg5o6S6Zmk5a2Q6IqC54K555qE5Y+C5pWwXHJcbiAgICAgICAgICAgIC8vIHRhcmdldE5vZGUgPSBmaW5kSG92ZXIodGhpcy5hbGxOb2RlcywgeCwgeSk7XHJcblxyXG4gICAgICAgICAgICAvLzIu5aaC5p6c5om+5Yiw55uu5qCH57uT54K5IOWImeeUu+e6v1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0Tm9kZSAmJiAodGhpcy5zZWxlY3RlZE5vZGUgIT0gdGFyZ2V0Tm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhciBjb25uZWN0T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lVHlwZTogYXJyb3cubGluZVR5cGVcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zOiAncmlnaHQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRQb3M6IGVuZFBvc1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBmaW5hbE9wdCA9IHV0aWwubWVyZ2VPcHQoY29ubmVjdE9wdGlvbnMsIHRoYXQubGluZU9wdCwgdHJ1ZSwgJ3Bvc2l0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGF0LnNlbGVjdGVkTm9kZTtcclxuICAgICAgICAgICAgICAgIHZhciBlbmQgPSB0YXJnZXROb2RlO1xyXG4gICAgICAgICAgICAgICAgLy/lpoLmnpzmnInljp/lp4vov57nur/lrZjlnKjvvIzliJnopoHmmrTpnLLlh7rljrvjgIJcclxuICAgICAgICAgICAgICAgIGlmICh0aGF0Lm9yaWdpbk5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW4uc3RhcnROb2RlID0gdGhhdC5zZWxlY3RlZE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luLmVuZE5vZGUgPSB0aGF0Lm9yaWdpbk5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luLm9wdGlvbnMgPSB1dGlsLm1lcmdlT3B0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVUeXBlOiBhcnJvdy5saW5lVHlwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRQb3M6IHRoYXQuc3RhcnRQb3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRQb3M6IHRoYXQub3JpZ2luUG9zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LCB0aGF0LmxpbmVPcHQsIHRydWUsICdwb3NpdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuX3RyaWdnZXIoJ2JlZm9yZUNyZWF0ZScsIHt0YXJnZXQ6dGhpcy5zZWxlY3RlZE5vZGUsZW5kTm9kZTp0YXJnZXROb2RlLGNvbm5lY3RPcHRpb25zOmNvbm5lY3RPcHRpb25zLCBvcmlnaW46IHt9fSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoYXQuY3JlYXRlQ29ubmVjdG9yQnlOb2RlcyhzdGFydCwgZW5kLCBmaW5hbE9wdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhhdC5oaWRlQ29ubmVjdG9yUG9pbnQoKTtcclxuICAgICAgICAgICAgLy8g6L+e57q/5oiQ5YqfL+Wksei0pe+8jOW9k+WJjeiKgueCueS+neeEtuaYr+mAieS4reeKtuaAge+8jOmcgOimgemHjeaWsOiuoeeul+iZmue6v+WSjOWbvuagh+S9jee9rlxyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoYXQuc2VsZWN0ZWROb2RlO1xyXG4gICAgICAgICAgICB2YXIgc2hhcGVSZWN0ID0gdXRpbC5nZXRSZWN0KG5vZGUsIHRydWUpO1xyXG4gICAgICAgICAgICAvLyDmmL7npLrlvZPliY3oioLngrnnmoTov57mjqXngrlcclxuICAgICAgICAgICAgdGhhdC5zaG93Q29ubmVjdG9yUG9pbnQoJ2phZ2dlZCcsIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoYXQub3BlcmF0aW9uTm9kZS5yZWZyZXNoUG9zdGlvbihub2RlLCBzaGFwZVJlY3QpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgIC8v5Yig6Zmk5oyJ6ZKu54K55Ye75LqL5Lu2XHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlLm9uKE9wZXJhdGlvbk5vZGUuREVMRVRFX0NMSUNLLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZSh0aGlzLnNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLmdyb3VwLmFkZCh0aGlzLm9wZXJhdGlvbk5vZGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLnJlbW92ZVNlbGVjdGVkTm9kZXMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWROb2Rlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQucmVtb3ZlTm9kZShpdGVtLCB7fSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHRoYXQuc2VsZWN0ZWROb2Rlcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zdGVwQ291bnRlcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGVzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdFJlY3Qub2ZmKFwibW91c2Vkb3duXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwLnJlbW92ZSh0aGlzLmRyYWdTZWxlY3RSZWN0KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoYXQuc2VsZWN0ZWROb2RlKSB7XHJcbiAgICAgICAgICAgIHRoYXQucmVtb3ZlTm9kZSh0aGF0LnNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgICAgIC8vIDEuIOmakOiXj+i/nue6v+eCuVxyXG4gICAgICAgICAgICB0aGlzLmhpZGVDb25uZWN0b3JQb2ludCgpO1xyXG4gICAgICAgICAgICAvLyAyLiDpmpDol4/mjqfliLbngrlcclxuICAgICAgICAgICAgdGhpcy5oaWRlQ29ubmVjdG9yQ29udHJvbCgpO1xyXG4gICAgICAgICAgICAvLyAzLiDpmpDol4/mk43kvZxub2RlXHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZU9wZXJhdGlvbk5vZGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uZmluZE5vZGVDaGlsZElkcyA9IGZ1bmN0aW9uIChub2RlLCBjaGlsZElkcykge1xyXG4gICAgICAgIGNoaWxkSWRzLnB1c2gobm9kZS5pZCk7XHJcbiAgICAgICAgbm9kZS5jaGlsZHJlbigpLmZpbHRlcihmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5hbGxOb2Rlcy5maW5kSW5kZXgoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmlkID09PSB2LmlkXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcG9zICE9PSAtMVxyXG4gICAgICAgIH0uYmluZCh0aGlzKSkuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7XHJcbiAgICAgICAgICAgIGlmIChGbG93LmlzR3JvdXBOb2RlKHN1YikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmluZE5vZGVDaGlsZElkcyhzdWIsIGNoaWxkSWRzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkSWRzLnB1c2goc3ViLmlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnp7vpmaTlnLrmma/kuK3nmoTmn5DkuKroioLngrnmiJbogIXnur/mrrUs5ZCMcmVtb3ZlTm9kZVxyXG4gICAgICogQG1ldGhvZCByZW1vdmVcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gbm9kZSBvciBsaW5rIOW+heWIoOmZpOeahOiKgueCueaIluiAhee6v+autVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSDlj4LmlbBcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJpZ2dlcj10cnVlXSDmmK/lkKbop6blj5HliKDpmaTkuovku7ZcclxuICAgICAqXHJcbiAgICAgKiAgKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICpcclxuICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAqICAgICAgZmlzaFRvcG8ucmVtb3ZlKHBlb3BsZU5vZGUpO1xyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnp7vpmaTlnLrmma/kuK3nmoTmn5DkuKroioLngrnmiJbogIXnur/mrrUs5ZCMcmVtb3ZlXHJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZU5vZGVcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gbm9kZSBvciBsaW5rIOW+heWIoOmZpOeahOiKgueCueaIluiAhee6v+autVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSDlj4LmlbBcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJpZ2dlcj10cnVlXSDmmK/lkKbop6blj5HliKDpmaTkuovku7ZcclxuICAgICAqXHJcbiAgICAgKiAgKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICpcclxuICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAqICAgICAgZmlzaFRvcG8ucmVtb3ZlTm9kZShwZW9wbGVOb2RlKTtcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5yZW1vdmUgPSBmaXNoVG9wb1Byb3RvLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiAoZGVsTm9kZSwgb3B0aW9ucywgaXNOb0NvdW50KSB7XHJcbiAgICAgICAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgaWYob3B0LnRyaWdnZXIgIT09ZmFsc2UgJiYgKCF0aGlzLl90cmlnZ2VyKCdiZWZvcmVEZWxldGUnLCB7dGFyZ2V0OmRlbE5vZGV9KSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGFyZW50WnIgPSB0aGlzLl9nZXRQYXJlbnRacihkZWxOb2RlKTtcclxuICAgICAgICBpZiAoZGVsTm9kZSBpbnN0YW5jZW9mIENvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICAvLyAxLjEg5Yig6Zmk57q/5q615LiK55qE5pON5L2c5Zu+5qCHXHJcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGRlbE5vZGUuaWNvbnMsIGZ1bmN0aW9uKGxpbmVPcGVyYXRpb25JY29uKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRaci5yZW1vdmUobGluZU9wZXJhdGlvbkljb24pO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAvLyAxLjIg5Yig6Zmk5b2T5YmN6YCJ5Lit57q/5q61XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuZGVsZXRlQnlMaW5lKGRlbE5vZGUscGFyZW50WnIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vMi4xIOWIoOmZpOiKgueCuVxyXG4gICAgICAgICAgICBwYXJlbnRaci5yZW1vdmUoZGVsTm9kZSk7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZElkcyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoRmxvdy5pc0dyb3VwTm9kZShkZWxOb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maW5kTm9kZUNoaWxkSWRzKGRlbE5vZGUsIGNoaWxkSWRzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkSWRzLnB1c2goZGVsTm9kZS5pZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8yLuS7jmFsbE5vZGVz5pWw57uE5Lit5Yig6ZmkXHJcbiAgICAgICAgICAgIHRoaXMuYWxsTm9kZXMgPSB0aGlzLmFsbE5vZGVzLmZpbHRlcihmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkSWRzLmluZGV4T2Yodi5pZCkgPT09IC0xXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLzIuMyDliKDpmaTlkozoioLngrnnm7jlhbPogZTnmoTnur/mrrVcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5kZWxldGVTZWxlY3RDb24oZGVsTm9kZSwgdGhpcy5ncm91cCk7XHJcbiAgICAgICAgICAgIC8vMi40IOWIoOmZpOiKgueCueaTjeS9nFxyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVPcGVyYXRpb25Ob2RlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLzMuIOa4heepuui/nuaOpee6v+S4iueahOiwg+aVtOS9jee9ruaMiemSrlxyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY2xlYXJTZWxlY3RDb24oKTtcclxuICAgICAgICAvLzQuIOa4heepuui/nuaOpee6v+S4iueahOaTjeS9nOaMiemSrlxyXG4gICAgICAgIHRoaXMubGluZU9wZXJhdGlvbk1hbmFnZXIuaGlkZUFsbExpbmVPcGVyYXRpb24oKTtcclxuICAgICAgICBpZiAoaXNOb0NvdW50ICE9IHRydWUpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGVwQ291bnRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLzQuIOa0vuWPkeWIoOmZpOS6i+S7tlxyXG4gICAgICAgICB0aGlzLl90cmlnZ2VyKFwiZGVsZXRlXCIsIHt0YXJnZXQ6ZGVsTm9kZX0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOmAieS4reWcuuaZr+S4reeahOafkOS4quiKgueCuSzlubbkuJTop6blj5FzZWxlY3ROb2Rl5LqL5Lu2XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSDlvoXpgInkuK3nmoToioLngrnlr7nosaFcclxuICAgICAqIEBzaW5jZSBWMi4zLjBcclxuICAgICAqICAqKuS9v+eUqOiMg+S+i++8mioqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZmlzaFRvcG8uc2VsZWN0Tm9kZShub2RlKTtcclxuICAgICAqL1xyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uc2VsZWN0Tm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLm5vZGVDbGlja0hhbmRsZXIobm9kZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoXCJzZWxlY3ROb2RlXCIsIHt0YXJnZXQ6bm9kZX0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja7oioLngrnliJvlu7rov57nur9cclxuICAgICAqIEBtZXRob2QgY3JlYXRlQ29ubmVjdG9yQnlOb2Rlc1xyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzdGFydE5vZGUg5byA5aeL6IqC54K5XHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGVuZE5vZGUgICDnu5PmnZ/oioLngrlcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyDnur/mrrXpgInpobkg5Y+C6KeBe0BsaW5rIGZpc2hUb3BvRmxvdy5saW5rI2NvbnN0cnVjdG9yIOaehOmAoOWHveaVsG9wdGlvbnPlj4LmlbB9XHJcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSB0cmlnZ2VyIOaYr+WQpuinpuWPkWNyZWF0ZeS6i+S7tu+8jOm7mOiupOaYr+inpuWPkWNyZWF0ZeS6i+S7tu+8jOiuvue9ruS4umZhbHNl5YiZ5LiN6Kem5Y+RXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uY3JlYXRlQ29ubmVjdG9yQnlOb2RlcyA9IGZ1bmN0aW9uIChzdGFydE5vZGUsIGVuZE5vZGUsIG9wdGlvbnMsIHRyaWdnZXIpIHtcclxuICAgICAgICB2YXIgbGlua1R5cGUgPSBvcHRpb25zLnN0eWxlLmxpbmVUeXBlIHx8IENvbm5lY3Rvci5UWVBFX1NUUkFJR0hUO1xyXG4gICAgICAgIGlmICghZmxvd0xpbmtbbGlua1R5cGVdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgTGluayA9IGZsb3dMaW5rW2xpbmtUeXBlXTtcclxuICAgICAgICB2YXIgY29ubmVjdG9yID0gbmV3IExpbmsoc3RhcnROb2RlLCBlbmROb2RlLCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmFkZChjb25uZWN0b3IpO1xyXG5cclxuICAgICAgICBpZiAoc3RhcnROb2RlLnBhcmVudCAmJiBlbmROb2RlLnBhcmVudCAmJiBzdGFydE5vZGUucGFyZW50PT1lbmROb2RlLnBhcmVudCApIHtcclxuICAgICAgICAgICAgZW5kTm9kZS5wYXJlbnQuYWRkKGNvbm5lY3Rvcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQoY29ubmVjdG9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbm5lY3Rvci5vbihcIm1vdXNlZG93blwiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvckZvcmJpZEVkaXQoKTtcclxuICAgICAgICAgICAgdGhpcy5pc05vZGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5zaG93Q29ubmVjdG9yUG9pbnQoZS50YXJnZXQuc3R5bGUubGluZVR5cGUpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgY29ubmVjdG9yLm9uKFwiZGJsY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRleHRFZGl0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JFZGl0KHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICBpZiAodHJpZ2dlciAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcihcImNyZWF0ZVwiLCB7IHRhcmdldDogY29ubmVjdG9yIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0ZXBDb3VudGVyKCk7XHJcbiAgICAgICAgcmV0dXJuIGNvbm5lY3RvcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog5rS+5Y+R5Yib5bu65a6M5oiQ5LqL5Lu2ICDov5Tlm55mYWxlc+WImeWPlua2iFxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLl90cmlnZ2VyID0gZnVuY3Rpb24odHlwZSwgZXZlbnQsIGRhdGEpIHtcclxuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLm9wdGlvbnNbdHlwZV07XHJcblxyXG4gICAgICAgIGlmIChkYXRhID09PSB2b2lkIDApIGRhdGEgPSB7fTtcclxuICAgICAgICBpZiAoZXZlbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgZXZlbnQgPSB7dHlwZTp0eXBlLCB0YXJnZXQ6dGhpc31cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBldmVudC50eXBlID0gdHlwZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnQuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5fYXBpLnRyaWdnZXIoZXZlbnQudHlwZSwgZXZlbnQpO1xyXG4gICAgICAgIHJldHVybiAhKHpyVXRpbC5pc0Z1bmN0aW9uKGNhbGxiYWNrKSAmJiBjYWxsYmFjay5hcHBseSh0aGlzLCBbZXZlbnRdLmNvbmNhdChkYXRhKSkgPT09IGZhbHNlKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZmlzaFRvcG9Qcm90by5ub2RlQ2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICB2YXIgaWZTaG93UG9pbnQgPSBub2RlLnR5cGUgIT09ICdkcmFnU2VsZWN0JztcclxuICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQudHlwZSA9PT0gXCJkcmFnU2VsZWN0XCIpIHtcclxuICAgICAgICAgICAgaWZTaG93UG9pbnQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMS4g6ZqQ6JeP6L+e57q/54K5XHJcbiAgICAgICAgdGhpcy5oaWRlQ29ubmVjdG9yUG9pbnQoKTtcclxuICAgICAgICAvLyAyLiDpmpDol4/mjqfliLbngrlcclxuICAgICAgICB0aGlzLmhpZGVDb25uZWN0b3JDb250cm9sKCk7XHJcbiAgICAgICAgLy8gMy4g6ZqQ6JeP5pON5L2cbm9kZVxyXG4gICAgICAgIHRoaXMuX3JlbW92ZU9wZXJhdGlvbk5vZGUoKTtcclxuICAgICAgICAvLyDpvKDmoIfngrnkuIsg5bCG5pON5L2c5qGGIOenu+WIsOWvueW6lOeahOiKgueCueS4ilxyXG4gICAgICAgIGlmIChub2RlLnNlbGVjdGFibGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGlmIChGbG93LmlzSW5Hcm91cChub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gbm9kZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXAuc2VsZWN0YWJsZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBncm91cDsgICAvLyDlpoLmnpzmnInnu4TnmoTor53vvIzlsLHpkojlr7nnu4Tov5vooYzlpITnkIZcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGUgPSBub2RlO1xyXG4gICAgICAgIHZhciBzaGFwZVJlY3QgPSB1dGlsLmdldFJlY3Qobm9kZSx0cnVlKTtcclxuICAgICAgICBpZiAoIXRoaXMub3BlcmF0aW9uTm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLmluaXRPcGVyYXRpb25Ob2RlKG5vZGUsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaWZTaG93UG9pbnQpIHtcclxuICAgICAgICAgICAgLy8g5pi+56S65b2T5YmN6IqC54K555qE6L+e5o6l54K5XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd0Nvbm5lY3RvclBvaW50KCdqYWdnZWQnLCB1bmRlZmluZWQsIHRydWUpO1xyXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5yZXR1cm5Db25uZWN0b3JDb250cm9sUGFyYW0obm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChwYXJhbXMuc2NhbGVhYmxlIHx8IHBhcmFtcy5yb3RhdGFibGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIOaYvuekuuW9k+WJjeiKgueCueeahOaOp+WItueCuVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93Q29ubmVjdG9yQ29udHJvbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOWcqOWtmOWcqOWtkOa1geeoi+eahOaDheWGteS4iyDpnIDopoHmiopub2Rl5Lmf5Lyg6YCS5LiA5LiLXHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlLnJlZnJlc2hQb3N0aW9uKG5vZGUsIHNoYXBlUmVjdCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOiKgueCueeahOenu+WKqOaTjeS9nCwg5Li65L2V6KaB6Ieq5bex5a6e546w5ouW5Yqo77yfenJlZG5lciBHcm91cOS4jeaUr+aMgeaLluWKqO+8jOWPquiDveiHquW3seWunueOsFxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmRyYWcgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpczsgLy8genJlbmRlcuS4reeahOS4gOS4qmJ1ZyBldmVudC50YXJnZXTkuI3kvJrluKZncm91cCDlj6rog73nlKh0aGF0IOS4jeiDveeUqGJpbmQodGhpcylcclxuICAgICAgICBub2RlLm9uKFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSB0aGlzO1xyXG4gICAgICAgICAgICAvL+WmguaenOWKoOS6huWxnuaApyBkcmFnZ2FibGU6ZmFsc2XmiJbogIXmi5bmi73moYbpgInph4wg5YiZ5LiN5Y+v5Lul5ouW5YqoXHJcbiAgICAgICAgICAgIGlmIChkcmFnZ2luZ1RhcmdldC5pc2RyYWdnYWJsZSA9PSBmYWxzZSB8fCAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQudHlwZSA9PT0gXCJkcmFnU2VsZWN0XCIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhhdC5fbm9kZURyYWdIYW5kbGVyKGRyYWdnaW5nVGFyZ2V0LCBldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcclxuICAgICAgICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgZmlzaFRvcG9Qcm90by5fbm9kZURyYWdIYW5kbGVyID0gZnVuY3Rpb24gKG5vZGUsIHgsIHkpIHtcclxuICAgICAgICB2YXIgaXNNb3ZlID0gMDtcclxuICAgICAgICB2YXIgdHMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBub3dHcm91cFBvc2l0aW9uID0gbm9kZS5wb3NpdGlvbjtcclxuICAgICAgICB2YXIgZ3JvdXBQb3NpdGlvblggPSBub2RlLnBvc2l0aW9uWzBdO1xyXG4gICAgICAgIHZhciBncm91cFBvc2l0aW9uWSA9IG5vZGUucG9zaXRpb25bMV07XHJcbiAgICAgICAgbm9kZS5fc3RhcnRYID0geDtcclxuICAgICAgICBub2RlLl9zdGFydFkgPSB5O1xyXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiZHJhZ1NlbGVjdFwiKSB7XHJcbiAgICAgICAgICAgIHZhciBhbGxMaW5lcyA9IHRoaXMuZ3JvdXAuY2hpbGRyZW4oKS5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2Lm1vZGVsICYmIHYubW9kZWwub3B0aW9uLmVsZW1lbnRUeXBlID09PSBcImNvbm5lY3Rpb25cIjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBub2RlcyA9IHRoaXMuZHJhZ1NlbGVjdFJlY3QuY2hpbGRyZW4oKS5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2Lm5hbWUgIT09IFwiR1JPVVBfUkVDVF9OQU1FXCIgJiYgdi5tb2RlbCAmJiB2Lm1vZGVsLm9wdGlvbi5lbGVtZW50VHlwZSAhPT0gXCJjb25uZWN0aW9uXCI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgbGluZXMgPSB0aGlzLmRyYWdTZWxlY3RSZWN0LmNoaWxkcmVuKCkuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5uYW1lICE9PSBcIkdST1VQX1JFQ1RfTkFNRVwiICYmIHYubW9kZWwgJiYgdi5tb2RlbC5vcHRpb24uZWxlbWVudFR5cGUgPT09IFwiY29ubmVjdGlvblwiO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgYWxsTGluZXMuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IG5vZGVzLmZpbmQoZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmlkID09PSB2LnN0YXJ0Tm9kZS5pZFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kTm9kZSA9IG5vZGVzLmZpbmQoZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmlkID09PSB2LmVuZE5vZGUuaWRcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlmRXhpc3QgPSBsaW5lcy5maW5kSW5kZXgoZnVuY3Rpb24obGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lLmlkID09PSB2LmlkXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmICgoc3RhcnROb2RlIHx8IGVuZE5vZGUpICYmIGlmRXhpc3QgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHMuY29ubmVjdGlvbk1hbmFnZXIucmVtb3ZlTGluZSh2LCB0cy5fZ2V0UGFyZW50WnIodikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZS50cmlnZ2VyKFwiZHJhZ3N0YXJ0XCIpO1xyXG4gICAgICAgIC8vIDHjgIHkvqblkKznp7vliqjkuovku7ZcclxuXHJcbiAgICAgICAgdmFyIG1vdmVIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciBzWCA9IChldmVudC5vZmZzZXRYIC0gbm9kZS5fc3RhcnRYKSAvICh0aGlzLm5vd1pvb20pO1xyXG4gICAgICAgICAgICB2YXIgc1kgPSAoZXZlbnQub2Zmc2V0WSAtIG5vZGUuX3N0YXJ0WSkgLyAodGhpcy5ub3dab29tKTtcclxuXHJcbiAgICAgICAgICAgIGlmICgoc1ggIT0gMCkgfHwgKHNZICE9IDApKSB7XHJcbiAgICAgICAgICAgICAgICBpc01vdmUgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5vZGUudHJpZ2dlcihcImRyYWdcIik7XHJcbiAgICAgICAgICAgIC8vIDEuMeWkhOeQhue7hOWGheeahOaDheWGte+8iOWmguaenOiKgueCueaLluWKqO+8jOe7hOS5n+i3n+edgOWPmO+8iVxyXG4gICAgICAgICAgICBpZiAoRmxvdy5pc0luR3JvdXAobm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIC8v5pS+5YWlbm9kZeeOsOacieaVsOWAvO+8jOeUqOS6jumHjee7mGdyb3VwXHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZU1lc3NhZ2UgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IEZsb3cuaXNHcm91cE5vZGUobm9kZSkgPyBub2RlLm9wdGlvbnMuc2hhcGUud2lkdGggOiAobm9kZS5zaGFwZSA/IG5vZGUuc2hhcGUud2lkdGggOiBub2RlLnN0eWxlLndpZHRoKSxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IEZsb3cuaXNHcm91cE5vZGUobm9kZSkgPyBub2RlLm9wdGlvbnMuc2hhcGUuaGVpZ2h0IDogKG5vZGUuc2hhcGUgPyBub2RlLnNoYXBlLmhlaWdodCA6IG5vZGUuc3R5bGUuaGVpZ2h0KSxcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogbm9kZS5wb3NpdGlvbixcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlUG9zaXRpb246IFtncm91cFBvc2l0aW9uWCwgZ3JvdXBQb3NpdGlvblldLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vdmVYOiBzWCxcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlWTogc1ksXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogbm9kZSxcclxuICAgICAgICAgICAgICAgICAgICBpc01vdmU6IGlzTW92ZVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Lm1vZGlmeUdyb3VwUmVjdChub2RlTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbm93R3JvdXBQb3NpdGlvblswXSA9IGdyb3VwUG9zaXRpb25YICsgc1g7XHJcbiAgICAgICAgICAgIG5vd0dyb3VwUG9zaXRpb25bMV0gPSBncm91cFBvc2l0aW9uWSArIHNZO1xyXG4gICAgICAgICAgICBub2RlLmF0dHIoXCJwb3NpdGlvblwiLCBub3dHcm91cFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgLy8gMS4yIOWkhOeQhuWRiuitpueahOaDheWGtSDvvIjlkYrorabpmo/nnYDoioLngrnnp7vliqjvvIlcclxuICAgICAgICAgICAgaWYgKG5vZGUuYWxhcm0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdBbGFybVBvc2l0aW9uID0gW25vd0dyb3VwUG9zaXRpb25bMF0gKyBub2RlLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC0gKG5vZGUuYWxhcm1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC0gNiksIG5vd0dyb3VwUG9zaXRpb25bMV0gLSBub2RlLmFsYXJtLmdldEJvdW5kaW5nUmVjdCgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmhlaWdodCAtIDNcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICBub2RlLmFsYXJtLmF0dHIoXCJwb3NpdGlvblwiLCBuZXdBbGFybVBvc2l0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAxLjQg6Kem5Y+R54K55Ye7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZUNsaWNrSGFuZGxlcihub2RlKTtcclxuICAgICAgICAgICAgLy8gMS41IOWIt+aWsOi/nue6v1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlZnJlc2hMaW5lQnlOb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICAvLyAxLjYg5aaC5p6c5piv57uE55qE6K+dLOmcgOimgeaKiue7hOWGheaJgOaciee7k+aenOmDveWIt+aWsOS4gOS4i+e6v1xyXG4gICAgICAgICAgICBpZiAoRmxvdy5pc0dyb3VwTm9kZShub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5lYWNoKGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVmcmVzaExpbmVCeU5vZGUoY2hpbGROb2RlKTtcclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFGbG93LmlzSW5Hcm91cChub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5pc1Bvc0luR3JvdXAodGhpcy5hbGxOb2Rlcywgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuYWxsTm9kZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEZsb3cuaXNHcm91cE5vZGUoaXRlbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwICYmIGl0ZW0uaWQgPT09IGdyb3VwLmlkICYmIGl0ZW0uaWQgIT09IG5vZGUuaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY2hpbGRyZW4oKS5maW5kKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYubmFtZSA9PT0gXCJHUk9VUF9SRUNUX05BTUVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuYXR0cihcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBcIiNiNmUzZjVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL+aBouWkjWdyb3Vw55qE6IOM5pmv6ImyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNoaWxkcmVuKCkuZmluZChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2Lm5hbWUgPT09IFwiR1JPVVBfUkVDVF9OQU1FXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmF0dHIoXCJzdHlsZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogXCJyZ2JhKDAsMCwwLDApXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3pyLm9uKCdtb3VzZW1vdmUnLCBtb3ZlSGFuZGxlcik7XHJcblxyXG5cclxuXHJcbiAgICAgICAgLy8yLiDmi5bmi73nu5PmnZ9cclxuICAgICAgICB2YXIgZW5kRHJhZ0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLm1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLm1vZGVsLnNldChcIm9wdGlvbnMucG9zaXRpb25cIiwgRmxvd1V0aWwudHJ1bmNQb3NpdGlvbihub2RlLnBvc2l0aW9uKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3pyLm9mZignbW91c2Vtb3ZlJywgbW92ZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl96ci5vZmYoJ21vdXNldXAnLCBlbmREcmFnSGFuZGxlcik7XHJcbiAgICAgICAgICAgIHRoaXMuX3pyLm9mZihcImdsb2JhbG91dFwiLCBlbmREcmFnSGFuZGxlcik7XHJcblxyXG4gICAgICAgICAgICAvLzIuMSDnvKnlvq7lm75cclxuICAgICAgICAgICAgaWYgKGlzTW92ZSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyKFwiZHJvcERyYWdcIiwge3RhcmdldDpub2RlfSk7XHJcbiAgICAgICAgICAgICAgICBub2RlLnRyaWdnZXIoXCJkcmFnZW5kXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZWFnbGVFeWUgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3BlbkVhZ2xlRXllKHRoaXMuZWFnbGVFeWVOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghRmxvdy5pc0luR3JvdXAobm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmlzUG9zSW5Hcm91cCh0aGlzLmFsbE5vZGVzLCBub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuYWxsTm9kZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoRmxvdy5pc0dyb3VwTm9kZShpdGVtKSAmJiBpdGVtLmlkID09PSBncm91cC5pZCAmJiBpdGVtLmlkICE9PSBub2RlLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudFpyID0gdGhpcy5fZ2V0UGFyZW50WnIobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50WnIucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYWRkKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlWCA9IEZsb3cuaXNHcm91cE5vZGUobm9kZSkgPyBub2RlLnBvc2l0aW9uWzBdICsgbm9kZS5vcHRpb25zLnNoYXBlLnggOiBub2RlLnBvc2l0aW9uWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlWSA9IEZsb3cuaXNHcm91cE5vZGUobm9kZSkgPyBub2RlLnBvc2l0aW9uWzFdICsgbm9kZS5vcHRpb25zLnNoYXBlLnkgOiBub2RlLnBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cFggPSB0aGlzLnBhcmVudFgoZ3JvdXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cFkgPSB0aGlzLnBhcmVudFkoZ3JvdXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXR0cihcInBvc2l0aW9uXCIsIFtub2RlWCAtIGdyb3VwWCArIGl0ZW0ub3B0aW9ucy5zaGFwZS54LCBub2RlWSAtIGdyb3VwWSArIGl0ZW0ub3B0aW9ucy5zaGFwZS55XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jaGlsZHJlbigpLmZpbmQoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYubmFtZSA9PT0gXCJHUk9VUF9SRUNUX05BTUVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmF0dHIoXCJzdHlsZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IFwicmdiYSgwLDAsMCwwKVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0ZXBDb3VudGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fenIub24oJ21vdXNldXAnLCBlbmREcmFnSGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5fenIub24oJ2dsb2JhbG91dCcsIGVuZERyYWdIYW5kbGVyKTtcclxuICAgIH1cclxuICAgIGZpc2hUb3BvUHJvdG8ucGFyZW50WCA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgaWYgKG5vZGUucGFyZW50ICYmIEZsb3cuaXNHcm91cE5vZGUobm9kZS5wYXJlbnQpICYmIHRoaXMuZ3JvdXAuaWQgIT09IG5vZGUucGFyZW50LmlkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzBdICsgbm9kZS5vcHRpb25zLnNoYXBlLnggKyB0aGlzLnBhcmVudFgobm9kZS5wYXJlbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzBdICsgbm9kZS5vcHRpb25zLnNoYXBlLng7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8ucGFyZW50WSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgaWYgKG5vZGUucGFyZW50ICYmIEZsb3cuaXNHcm91cE5vZGUobm9kZS5wYXJlbnQpICYmIHRoaXMuZ3JvdXAuaWQgIT09IG5vZGUucGFyZW50LmlkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzFdICsgbm9kZS5vcHRpb25zLnNoYXBlLnkgKyB0aGlzLnBhcmVudFkobm9kZS5wYXJlbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzFdICsgbm9kZS5vcHRpb25zLnNoYXBlLnk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uaXNQb3NJbkdyb3VwID0gZnVuY3Rpb24gKGFsbE5vZGVzLCBub2RlKSB7XHJcbiAgICAgICAgaWYgKGFsbE5vZGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IG51bGw7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IGFsbE5vZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKEZsb3cuaXNHcm91cE5vZGUoZ3JvdXApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwV2lkdGggPSBncm91cC5vcHRpb25zLnNoYXBlLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cEhlaWdodCA9IGdyb3VwLm9wdGlvbnMuc2hhcGUuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cFggPSB0aGlzLnBhcmVudFgoZ3JvdXApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cFkgPSB0aGlzLnBhcmVudFkoZ3JvdXApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gdXRpbC5nZXRSZWN0KG5vZGUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlV2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlSGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVYID0gcmVjdC54IC0gbm9kZVdpZHRoLzI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVZID0gcmVjdC55IC0gbm9kZUhlaWdodC8yO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlWCA+PSBncm91cFggJiYgbm9kZVkgPj0gZ3JvdXBZICYmIG5vZGVYK25vZGVXaWR0aCA8PSBncm91cFgrZ3JvdXBXaWR0aCAmJiBub2RlWStub2RlSGVpZ2h0IDw9IGdyb3VwWStncm91cEhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBncm91cC5jaGlsZHJlbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ViID0gdGhpcy5pc1Bvc0luR3JvdXAoY2hpbGRyZW4sIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBzdWIgPyBzdWIgOiBncm91cDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu66IqC54K5XHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZU5vZGVcclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZSDnsbvlnosgZWcuICdSZWN0J+OAgSdDaXJjbGUn44CBJ0ltYWdlJ+OAgSdHcm91cCfjgIEnVGV4dCfnrYlcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0IOiKgueCuemAiemhuSDor6bop4F7QGxpbmsgZmlzaFRvcG9GbG93Lm5vZGUgQ29uZmlnIG9wdGlvbnN9XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdXNlckRhdGEg55So5oi35Lyg6YCS55qE5Lia5Yqh5pWw5o2uXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IOWIm+W7uueahOiKgueCueWvueixoVxyXG4gICAgICpcclxuICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAqXHJcbiAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgKiAgICAgIHZhciByZWN0ID0gdGhpcy5maXNoVG9wby5jcmVhdGVOb2RlKFwiUmVjdFwiLCB7IC8v55+p5b2iXHJcbiAgICAgKiAgICAgICAgICBzaGFwZToge1xyXG4gICAgICogICAgICAgICAgICAgIHdpZHRoOiAxMDAsXHJcbiAgICAgKiAgICAgICAgICAgICAgaGVpZ2h0OiA2MCxcclxuICAgICAqICAgICAgICAgIH0sXHJcbiAgICAgKiAgICAgICAgICBzdHlsZToge1xyXG4gICAgICogICAgICAgICAgICAgIHRleHQ6IFwi5Z+65pys55+p5b2iXCIsXHJcbiAgICAgKiAgICAgICAgICAgICAgZmlsbDogXCIjMTY3Q0ZGXCIsXHJcbiAgICAgKiAgICAgICAgICAgICAgc3Ryb2tlOiBcInJnYigyNTUsMjU1LDI1NSlcIixcclxuICAgICAqICAgICAgICAgICAgICB0ZXh0Rm9udDogJzE0cHggTWljcm9zb2Z0IFlhSGVpJ1xyXG4gICAgICogICAgICAgICAgfSxcclxuICAgICAqICAgICAgICAgIHBvc2l0aW9uOiBbMTgwLCAxMDBdLFxyXG4gICAgICogICAgICAgICAgb3BlcmF0aW9uSWNvbnM6IFt7IG5hbWU6ICdERUwnIH0sXHJcbiAgICAgKiAgICAgICAgICAgICAgeyBuYW1lOiAnU1RSQUlHSFQnIH0sXHJcbiAgICAgKiAgICAgICAgICAgICAgeyBuYW1lOiAnSkFHR0VEJyB9LFxyXG4gICAgICogICAgICAgICAgICAgIHsgbmFtZTogJ0NVUlZFJyB9LFxyXG4gICAgICogICAgICAgICAgICAgIHtcclxuICAgICAqICAgICAgICAgICAgICAgICAgbmFtZTogXCJjdXN0b20xXCIsXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgIGljb25QYXRoOiBcImltZy9ob3N0LnBuZ1wiLFxyXG4gICAgICogICAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oZSkgeyBhbGVydChlLmRhdGEubmFtZSArIFwiIGNsaWNrZWRcIikgfSAgLy9lLm5vZGXmmK/lvZPliY3nmoToioLngrlcclxuICAgICAqICAgICAgICAgICAgICB9XHJcbiAgICAgKiAgICAgICAgICBdXHJcbiAgICAgKiAgICAgIH0pO1xyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmNyZWF0ZU5vZGUgPSBmaXNoVG9wb1Byb3RvLmNyZWF0Tm9kZSA9IGZ1bmN0aW9uICh0eXBlLCBvcHQsIHVzZXJEYXRhKSB7XHJcbiAgICAgICAgaWYgKCFmbG93Tm9kZVt0eXBlXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIFNoYXBlID0gZmxvd05vZGVbdHlwZV07XHJcbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgU2hhcGUob3B0KTtcclxuXHJcbiAgICAgICAgRmxvdy5zZXRVc2VyRGF0YShub2RlLCB1c2VyRGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5qC55o2ubmFtZeiOt+WPluiKgueCuVxyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIOWcqOWIm+W7uuiKgueCueS4rSAgbmFtZeWxnuaAp+iuvue9rueahOWAvFxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgIG5hbWXlr7nlupTnmoToioLngrlcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5jaGlsZE9mTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIGFyclJlc3VsdCA9IFtdO1xyXG4gICAgICAgIHZhciBjaGlsZHJlbk5vZGUgPSB0aGlzLmFsbE5vZGVzO1xyXG4gICAgICAgIHZhciBjaGlsZHJlbkxpbmUgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvcnM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbk5vZGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkcmVuTm9kZVtpXS5tb2RlbC5nZXQoXCJvcHRpb25zLm5hbWVcIikgJiYgY2hpbGRyZW5Ob2RlW2ldLm1vZGVsLmdldChcIm9wdGlvbnMubmFtZVwiKSA9PVxyXG4gICAgICAgICAgICAgICAgbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgYXJyUmVzdWx0LnB1c2goY2hpbGRyZW5Ob2RlW2ldKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZHJlbk5vZGVbaV0ubW9kZWwuZ2V0KFwidXNlckRhdGEubmFtZVwiKSA9PSBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJSZXN1bHQucHVzaChjaGlsZHJlbk5vZGVbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hpbGRyZW5MaW5lLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbkxpbmVbal0ubW9kZWwuZ2V0KFwib3B0aW9ucy5uYW1lXCIpICYmIGNoaWxkcmVuTGluZVtqXS5tb2RlbC5nZXQoXCJvcHRpb25zLm5hbWVcIikgPT1cclxuICAgICAgICAgICAgICAgIG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGFyclJlc3VsdC5wdXNoKGNoaWxkcmVuTGluZVtqXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5MaW5lW2pdLm1vZGVsLmdldChcInVzZXJEYXRhLm5hbWVcIikgPT0gbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgYXJyUmVzdWx0LnB1c2goY2hpbGRyZW5MaW5lW2pdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXJyUmVzdWx0Lmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyclJlc3VsdDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyUmVzdWx0WzBdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmn6Xmib7lnLrmma/kuK3nmoTlr7nosaEgICDkvovlpoI6IHjlnZDmoIflpKfkuo4xMDDnmoToioLngrkgZmluZEVsZW1lbnRzKGZ1bmN0aW9uKG5vZGUpeyByZXR1cm4gbm9kZS5wb3NpdGlvblswXSA+IDEwMDsgfSk7XHJcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2IgICAgICDlm57osIPlh73mlbAg5Y+C5pWw5Li66YGN5Y6G55qE6IqC54K5XHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgY29udGV4dCDlm57osIPlh73mlbDmiafooYznmoTkuIrkuIvmlodcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAg6L+U5Zue5p+l5om+5Yiw55qE5a+56LGhXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZmluZEVsZW1lbnRzID0gZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuTm9kZSA9IHRoaXMuYWxsTm9kZXM7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuTGluZSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9ycztcclxuICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbk5vZGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5Ob2RlW2ldO1xyXG4gICAgICAgICAgICBpZiAoY2IuY2FsbChjb250ZXh0LCBjaGlsZCwgaSkpIHtcclxuICAgICAgICAgICAgICAgIGFyci5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoaWxkcmVuTGluZS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRMID0gY2hpbGRyZW5MaW5lW2pdO1xyXG4gICAgICAgICAgICBpZiAoY2IuY2FsbChjb250ZXh0LCBjaGlsZEwsIGopKSB7XHJcbiAgICAgICAgICAgICAgICBhcnIucHVzaChjaGlsZEwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5qC55o2u6IqC54K55p+l5om+6L+e57q/ICAg5L6L5aaCOiDpu5jorqTmn6Xmib7lvIDlp4voioLngrnnmoTov57nur8gZmluZENvbm5lY3RvcnNCeU5vZGUobm9kZSk7XHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgbm9kZSAgICDoioLngrlcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gICBvcHRpb25zIOaYr+WQpuafpeaJvuW8gOWni+iKgueCuVxyXG4gICAgICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAg6L+U5Zue5p+l5om+5Yiw55qE5a+56LGhXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZmluZENvbm5lY3RvcnNCeU5vZGUgPSBmdW5jdGlvbiAobm9kZSxvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIHZhciBhcnIgPSBbXTtcclxuICAgICAgICAvLyBEZWZhdWx0IHZhbHVlXHJcbiAgICAgICAgenJVdGlsLmRlZmF1bHRzKG9wdHMsIHtcclxuICAgICAgICAgICAgc3RhcnROb2RlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuTGluZSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9ycztcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoaWxkcmVuTGluZS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRMID0gY2hpbGRyZW5MaW5lW2pdO1xyXG4gICAgICAgICAgICBpZiAob3B0cy5zdGFydE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGlmKGNoaWxkTC5zdGFydE5vZGUuaWQgPT09IG5vZGUuaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChjaGlsZEwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYoY2hpbGRMLmVuZE5vZGUuaWQgPT09IG5vZGUuaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChjaGlsZEwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6+572u6IOM5pmv6ImyICDmiJYg6IOM5pmv5Zu+54mHXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW1hZ2VVcmwg6IOM5pmv6ImyICDmiJYg6IOM5pmv5Zu+54mHIGVnLiAnaW1nL2JnLmpwZyfvvIzkuLrigJhncmlkTGluZeKAmeaXtue9keagvOiDjOaZr1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlzUmVwZWF0IOaYr+WQpumHjeWkjeiDjOaZryAg5aaC5p6c6YeN5aSN55qE6K+d77yM5bCG5L2/55SoY3Nz55qEcmVwZWF0IOWboOS4umNhbnZhc+S4jeaUr+aMgXJlcGVhdFxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLnNldEJhY2tncm91bmQgPSBmdW5jdGlvbiAoaW1hZ2VVcmwsIGlzUmVwZWF0KSB7XHJcbiAgICAgICAgaWYgKGltYWdlVXJsICYmIGltYWdlVXJsLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoQ29uc3RhbnRzLkJBQ0tHUk9VTkQsIGltYWdlVXJsKTtcclxuICAgICAgICAgICAgaWYgKGltYWdlVXJsLnN1YnN0cigwLCAxKSA9PSBcIiNcIiB8fCBpbWFnZVVybC5zdWJzdHIoMCwgNCkgPT0gXCJyZ2JhXCIpIHsgLy/lpoLmnpzmmK/popzoibLliJvlu7pyZWN05Li66IOM5pmvXHJcbiAgICAgICAgICAgICAgICBpZiAoIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb20uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gaW1hZ2VVcmw7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZVNoYXBlID0gbmV3IHRoaXMuU2hhcGUuUmVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5fenIuZ2V0V2lkdGgoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5fenIuZ2V0SGVpZ2h0KClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGltYWdlVXJsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB6OiAtMVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3pyLmFkZChpbWFnZVNoYXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW1hZ2VVcmwgPT0gXCJncmlkTGluZVwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWRMaW5lR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkTGluZSgwLjIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fenIuYWRkKHRoaXMuZ3JpZExpbmVHcm91cCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQgfHwgaXNSZXBlYXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb20uc3R5bGUuYmFja2dyb3VuZEltYWdlID0gXCJ1cmwoXCIgKyBpbWFnZVVybCArIFwiKVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvbS5zdHlsZS5iYWNrZ3JvdW5kUmVwZWF0ID0gXCJyZXBlYXRcIjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlU2hhcGUxID0gbmV3IHRoaXMuU2hhcGUuSW1hZ2UoeyAvL+WmguaenOaYr+WbvueJh+WIm+W7umltYWdl5Li66IOM5pmvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbMCwgMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlOiBbMSwgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZVVybCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLl96ci5nZXRXaWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLl96ci5nZXRIZWlnaHQoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3I6ICdkZWZhdWx0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgejogLTFcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl96ci5hZGQoaW1hZ2VTaGFwZTEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvL+iDjOaZr+e9keagvOe6v1xyXG4gICAgZmlzaFRvcG9Qcm90by5ncmlkTGluZSA9IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcbiAgICAgICAgdmFyIHBpeGVsID0gMTA7XHJcbiAgICAgICAgdmFyIHdpZHRoTGVuID0gcGFyc2VJbnQodGhpcy5nZXRXaWR0aCgpIC8gcGl4ZWwpO1xyXG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDw9IHdpZHRoTGVuOyB4KyspIHtcclxuICAgICAgICAgICAgdmFyIGxpbmVYID0gbmV3IGdyYXBoaWMuTGluZSh7XHJcbiAgICAgICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHgxOiB4ICogcGl4ZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgeTE6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgeDI6IHggKiBwaXhlbCxcclxuICAgICAgICAgICAgICAgICAgICB5MjogdGhpcy5nZXRIZWlnaHQoKVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZURhc2g6IFsxXSxcclxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiBvcGFjaXR5XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgejogMCxcclxuICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjdXJzb3I6ICdkZWZhdWx0J1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5ncmlkTGluZUdyb3VwLmFkZChsaW5lWCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaGVpZ2h0TGVuID0gcGFyc2VJbnQodGhpcy5nZXRIZWlnaHQoKSAvIHBpeGVsLCBwaXhlbCk7XHJcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPD0gaGVpZ2h0TGVuOyB5KyspIHtcclxuICAgICAgICAgICAgdmFyIGxpbmVZID0gbmV3IGdyYXBoaWMuTGluZSh7XHJcbiAgICAgICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHgxOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHkxOiB5ICogcGl4ZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgeDI6IHRoaXMuZ2V0V2lkdGgoKSxcclxuICAgICAgICAgICAgICAgICAgICB5MjogeSAqIHBpeGVsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lRGFzaDogWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHlcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB6OiAwLFxyXG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmdyaWRMaW5lR3JvdXAuYWRkKGxpbmVZKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu657q/5q61XHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZUxpbmtcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc3RhcnROb2RlIOW8gOWni+iKgueCuVxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBlbmROb2RlICAg57uT5p2f6IqC54K5XHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMg57q/5q616YCJ6aG5XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc3R5bGVdIOiKgueCueeahOagt+W8j1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN0eWxlLmxpbmVXaWR0aD0xXSDnur/mrrXnmoTlrr3luqZcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zdHlsZS5saW5lVHlwZT0nc3RyYWlnaHQnXSDnur/mrrXnmoTnsbvlnosgZWcuICdzdHJhaWdodCcsICdqYWdnZWQnLCdjdXJ2ZSdcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zdHlsZS5zdHJva2U9XCIjMDAwMDAwXCJdIOe6v+auteeahOminOiJsuWAvCBlZy4gJyMxNTdjZmYnICAncmdiKDEyMiwxMjIsMTIyKSdcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5zdHlsZS5saW5lRGFzaF0g6Jma57q/55qE6Ze06ZqUIGVnLiBbMywzXVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnN5bWJvbF0g57q/5q6155qE566t5aS0XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3ltYm9sLnR5cGU9J2Fycm93J10g57q/5q6155qE566t5aS055qE57G75Z6LIOWPr+mAieWAvOS4uu+8miAnY2lyY2xlJywgJ3JlY3QnLCAncm91bmRSZWN0JywgJ3RyaWFuZ2xlJywgJ2RpYW1vbmQnLCAncGluJywgJ2Fycm93J1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN5bWJvbC5zaXplPTEwXSDnur/mrrXnmoTnrq3lpLTnmoTlsLrlr7hcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zeW1ib2wuY29sb3I9JyMwMDAwMDAnXSDnur/mrrXnmoTnrq3lpLTnmoTpopzoibJcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zeW1ib2wuel0gW+eureWktOeahOWxgue6p++8jOi2iuWkp+i2iuWcqOWJjemdouaYvuekul1cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50ZXh0XSDnur/mrrXkuIrnmoTmloflrZdcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50ZXh0LnRleHRdIOe6v+auteS4iueahOaWh+Wtl+WGheWuuVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRleHQuY29sb3JdIOe6v+auteS4iueahOaWh+Wtl+minOiJslxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRleHQudGV4dFBvc10g5paH5a2X5L2N572u5Y+v6YCJ5YC8ICdzdGFydCcsJ2NlbnRlcicsJ2VuZCcs6buY6K6k5YC85Li6Y2VudGVyXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcnxBcnJheX0gW29wdGlvbnMudGV4dC5vZmZzZXRdIOaWh+Wtl+S9jee9ruWBj+enu+mHjyzkuLpudW1iZXLliJnmmK945YGP56e7IGFycmF55YiZ5Li6W3gseV1cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NdIOS/neeVmSDor7fkvb/nlKhvcHRpb25zLnBvc2l0aW9uLmRpcmVjdGlvbiDmjIflrprnur/mrrXotbflp4vkuI7nu4jmraIg5Zyo6IqC54K555qE5LuA5LmI5L2N572uIOm7mOiupOWAvOS4uidsZWZ0LHJpZ2h0JyAg5Y+v5Y+W5YC85Zub5Liq5pa55ZCRdG9wLGJvdHRvbSxsZWZ0LHJpZ2h0IOaWueWQkeWPr+WKoOWBj+enu+mHj+WmguWmgiBcImxlZnQrMTAsdG9wXCJcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbl0g5oyH5a6a57q/5q615L2N572uXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucG9zaXRpb24uZGlyZWN0aW9uXSDmjIflrprnur/mrrXotbflp4vkuI7nu4jmraIg5Zyo6IqC54K555qE5LuA5LmI5L2N572uIOm7mOiupOWAvOS4uidsZWZ0LHJpZ2h0JyAg5Y+v5Y+W5YC85Zub5Liq5pa55ZCRdG9wLGJvdHRvbSxsZWZ0LHJpZ2h0IOaWueWQkeWPr+WKoOWBj+enu+mHj+WmguWmgiBcImxlZnQrMTAsdG9wXCJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wb3NpdGlvbi5zdGFydE9mZnNldF0g57q/5q615byA5aeL5L2N572u55qE5YGP56e7XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucG9zaXRpb24uZW5kT2Zmc2V0XSDnur/mrrXnu5PmnZ/kvY3nva7nmoTlgY/np7tcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbi5lc2NhcGVEaXN0YW5jZV0g5oyH5a6a57q/5q6156ys5LiA5p2h5oqY57q/55qE6ZW/5bqm77yM5pyA5ZCO5LiA5p2h5oqY57q/55qE6ZW/5bqm77yM6buY6K6k5YC85Li6WzMwLCAzMF1cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbi5wb2ludHNdIOS4jeS9v+eUqOiHquWKqOiuoeeulyDmjIflrprov57nur/nmoTmipjngrnkvY3nva7mlbDnu4TvvIzpppblsL7lj6/ku6Xkvb/nlKhsZWZ0LHJpZ2h0LHRvcCxib3R0b21cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5lZmZlY3RdIOe6v+S4iuWKqOaAgeaViOaenFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmVmZmVjdC5zaG93XSDmmK/lkKbmmL7npLrnrq3lpLTliqjmlYhcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5lZmZlY3QucGVyaW9kXSDliqjmlYjnp7vliqjpgJ/luqZcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b0NoYW5nZVBvc2l0aW9uXSDov57nur/nmoTov57mjqXngrnpmo9ub2Rl56e75Yqo6Ieq5Yqo5YiH5o2i5L2N572u77yM6buY6K6k5Li6Zmxhc2VcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy56XSBb6L+e57q/55qE5bGC57qn77yM6LaK5aSn6LaK5Zyo5YmN6Z2i5pi+56S6XVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVzZXJEYXRhIOeUqOaIt+S8oOmAkueahOS4muWKoeaVsOaNrlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSDliJvlu7rnmoTnur/mrrXlr7nosaFcclxuICAgICAqXHJcbiAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgKlxyXG4gICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICogICAgICB2YXIgbGluayA9IG1lLmZpc2hUb3BvLmNyZWF0ZUxpbmsoc3RhcnROb2RlLCBlbmROb2RlLCB7XHJcbiAgICAgKiAgICAgICAgICAgICAgc3ltYm9sOiB7IHR5cGU6ICdhcnJvdycsIHNpemU6IDEwLCBjb2xvcjogXCJyZ2IoMCwyMDAsMjU1KVwiIH0sIC8v566t5aS0ICDlj6/pgInlgLzkuLrvvJogJ2NpcmNsZScsICdyZWN0JywgJ3JvdW5kUmVjdCcsICd0cmlhbmdsZScsICdkaWFtb25kJywgJ3BpbicsICdhcnJvdydcclxuICAgICAqICAgICAgICAgICAgICBzdHlsZTogeyBsaW5lV2lkdGg6IDMsIHN0cm9rZTogXCJyZ2IoMCwyMDAsMjU1KVwiLCBsaW5lRGFzaDogWzMsM10sIGxpbmVUeXBlOiBcImphZ2dlZFwiICB9LCAvL+agt+W8j1xyXG4gICAgICogICAgICAgICAgICAgIHRleHQ6IHtcclxuICAgICAqICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcclxuICAgICAqICAgICAgICAgICAgICAgICAgY29sb3I6ICcjZmZmZmZmJyxcclxuICAgICAqICAgICAgICAgICAgICAgICAgdGV4dFBvczp0ZXh0UG9zLC8v5paH5a2X5L2N572u5Y+v6YCJ5YC8ICdzdGFydCcsJ2NlbnRlcicsJ2VuZCcs6buY6K6k5YC85Li6Y2VudGVyXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgIHhPZmZzZXQ6MTAsIC8v5paH5a2X5L2N572ueOWBj+enu+mHj1xyXG4gICAgICogICAgICAgICAgICAgIH0sXHJcbiAgICAgKiAgICAgICAgICAgICAgcG9zOidyaWdodCxsZWZ0JyxcclxuICAgICAqICAgICAgICAgICAgICBlZmZlY3Q6IHtcclxuICAgICAqICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSwvL+aYr+WQpuaYvuekuueureWktOWKqOaViFxyXG4gICAgICogICAgICAgICAgICAgICAgICBwZXJpb2Q6IDYsLy/nrq3lpLTpgJ/luqZcclxuICAgICAqICAgICAgICAgICAgICB9LFxyXG4gICAgICogICAgICAgICAgICAgIHBvc2l0aW9uOntcclxuICAgICAqICAgICAgICAgICAgICAgICAgICBlc2NhcGVEaXN0YW5jZTpbNTAsMzBdLCAgLy/nrKzkuIDmnaHmipjnur/nmoTplb/luqbvvIzmnIDlkI7kuIDmnaHmipjnur/nmoTplb/luqZcclxuICAgICAqICAgICAgICAgICAgICAgICAgICBwb2ludHM6W1wieDEseTFcIixcIngyLHkyXCJdICDkuI3kvb/nlKjoh6rliqjorqHnrpcg5oyH5a6a6L+e57q/55qE5L2N572u5pWw57uEXHJcbiAgICAgKiAgICAgICAgICAgICAgfSxcclxuICAgICAqICAgICAgICAgICAgICB6OiAwXHJcbiAgICAgKiAgICAgICAgICB9KTtcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5jcmVhdGVMaW5rID0gZmlzaFRvcG9Qcm90by5jcmVhdExpbmsgPSBmdW5jdGlvbiAoc3RhcnROb2RlLCBlbmROb2RlLCBvcHRpb25zLCB1c2VyRGF0YSkge1xyXG4gICAgICAgIHZhciBsaW5rVHlwZSA9IENvbm5lY3Rvci5UWVBFX1NUUkFJR0hUO1xyXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc3R5bGUgJiYgb3B0aW9ucy5zdHlsZS5saW5lVHlwZSkge1xyXG4gICAgICAgICAgICBsaW5rVHlwZSA9IG9wdGlvbnMuc3R5bGUubGluZVR5cGVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghZmxvd0xpbmtbbGlua1R5cGVdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgTGluayA9IGZsb3dMaW5rW2xpbmtUeXBlXTtcclxuICAgICAgICB2YXIgY29ubmVjdG9yID0gbmV3IExpbmsoc3RhcnROb2RlLCBlbmROb2RlLCBvcHRpb25zKTtcclxuICAgICAgICBpZiAodXNlckRhdGEpIHtcclxuICAgICAgICAgICAgY29ubmVjdG9yLm1vZGVsLnNldChDb25zdGFudHMuVVNFUkRBVEEsIHpyVXRpbC5jbG9uZSh1c2VyRGF0YSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbm5lY3RvcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja7oioLngrnliLfmlrDoioLngrnmiYDov57nmoTnur/vvIjph43mlrDorqHnrpfnur/nmoTkvY3nva7vvIlcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gbm9kZSBb6IqC54K5XVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLnJlZnJlc2hMaW5lQnlOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlZnJlc2hMaW5lQnlOb2RlKG5vZGUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog57q/5LiK5paH5a2X57yW6L6RXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uY29ubmVjdG9yRWRpdCA9IGZ1bmN0aW9uICh0aGlzQ29ubmVjdG9yKSB7XHJcbiAgICAgICAgdmFyIGxpbmVUZXh0ID0gdGhpc0Nvbm5lY3Rvci5jaGlsZE9mTmFtZSgnbGluZVRleHQnKTtcclxuICAgICAgICBpZiAoIWxpbmVUZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRleHRhcmVhID0gdGhpcy5jcmVhdGVUZXh0QXJlYSgpO1xyXG4gICAgICAgIHZhciB0ZXh0UmVjdCA9IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdChsaW5lVGV4dC5zdHlsZS50ZXh0LCBsaW5lVGV4dC5zdHlsZS50ZXh0Rm9udCk7XHJcbiAgICAgICAgdmFyIG1heFdpZHRoID0gMS4yICogdXRpbC5nZXRSZWN0KGxpbmVUZXh0KS53aWR0aCAqIHRoaXMubm93Wm9vbSArIDEwO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLndpZHRoID0gMS4yICogdXRpbC5nZXRSZWN0KGxpbmVUZXh0KS53aWR0aCAqIHRoaXMubm93Wm9vbSArIFwicHhcIjtcclxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSAoMiAqIHRleHRSZWN0LmhlaWdodCB8fCAxMikgKiB0aGlzLm5vd1pvb20gKyBcInB4XCI7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUuYm9yZGVyID0gXCIxcHggZGFzaGVkICMyZTJlMmVcIjtcclxuICAgICAgICB0ZXh0YXJlYS5pbm5lckhUTUwgPSBsaW5lVGV4dC5zdHlsZS50ZXh0O1xyXG4gICAgICAgIHRoaXNDb25uZWN0b3Iuc2V0U3R5bGUoe1xyXG4gICAgICAgICAgICB0ZXh0OiB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIHRoaXMuX2RvbS5hcHBlbmRDaGlsZCh0ZXh0YXJlYSk7XHJcbiAgICAgICAgdGhpcy5fZG9tLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLmxpbmVIZWlnaHQgPSAoMS4yICogdGV4dFJlY3QubGluZUhlaWdodCB8fCAxMikgKyBcInB4XCI7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUudG9wID0gKGxpbmVUZXh0LnBvc2l0aW9uWzFdIC0gdGV4dFJlY3QuaGVpZ2h0KSAqIHRoaXMubm93Wm9vbSArIHRoaXMuZ3JvdXBcclxuICAgICAgICAgICAgLnBvc2l0aW9uWzFdICsgXCJweFwiO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLmxlZnQgPSAobGluZVRleHQucG9zaXRpb25bMF0gLSAwLjU1ICogdGV4dFJlY3Qud2lkdGgpICogdGhpcy5ub3dab29tICtcclxuICAgICAgICAgICAgdGhpcy5ncm91cC5wb3NpdGlvblswXSArIFwicHhcIjtcclxuICAgICAgICB0ZXh0YXJlYS5mb2N1cygpO1xyXG4gICAgICAgIHRleHRhcmVhLnNlbGVjdCgpO1xyXG4gICAgICAgIHRoaXMuX3RleHRhcmVhUmVzaXplKHRleHRSZWN0LCB0ZXh0YXJlYSwgbWF4V2lkdGgpO1xyXG4gICAgICAgIHRleHRhcmVhLm9ua2V5dXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRleHRhcmVhLnN0eWxlLndpZHRoID0gdGV4dFJlY3Qud2lkdGggPCA2MCA/IFwiODBweFwiIDogdGV4dGFyZWEuc3R5bGUud2lkdGg7XHJcbiAgICAgICAgICAgIHRleHRhcmVhLnN0eWxlLmhlaWdodCA9IHRleHRhcmVhLnNjcm9sbEhlaWdodCArICdweCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRleHRhcmVhLm9uZm9jdXNvdXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXNDb25uZWN0b3Iuc2V0U3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgdGV4dDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHRhcmVhLnZhbHVlIHx8IFwiXCJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgdGV4dGFyZWEucmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOiKgueCueS4iuaWh+Wtl+e8lui+kVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLm5vZGVFZGl0ID0gZnVuY3Rpb24gKHRoaXNOb2RlKSB7XHJcbiAgICAgICAgdmFyIE1BWFdJRFRIX01VTFRJUExFX1RPUF9CT1RUT00gPSAzLjM7IC8vdGV4dOacgOWkp+WuveW6puS4juiKgueCueWuveW6pueahOezu+aVsO+8jOWcqHRvcC9ib3R0b23kvY3nva5cclxuICAgICAgICB2YXIgaXNOb3RTZXRUZXh0ID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHRleHRhcmVhID0gdGhpcy5jcmVhdGVUZXh0QXJlYSgpO1xyXG4gICAgICAgIHZhciBub2RlVGV4dCA9IHpyVXRpbC5jbG9uZSh0aGlzTm9kZS5zdHlsZS50ZXh0KTtcclxuICAgICAgICB2YXIgdGV4dFJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3Qobm9kZVRleHQsIHRoaXNOb2RlLnN0eWxlLnRleHRGb250KTtcclxuICAgICAgICB2YXIgdGV4dGFyZWFXaWR0aCA9IHRleHRSZWN0LndpZHRoIDwgMjUgPyAoMS4yICogdGV4dFJlY3Qud2lkdGggKiB0aGlzLm5vd1pvb20gKyAxMCkgOiAzNjtcclxuICAgICAgICB2YXIgdGV4dGFyZWFIZWlnaHQgPSAoMiAqIHRleHRSZWN0LmhlaWdodCB8fCAyNCkgKiB0aGlzLm5vd1pvb207XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUud2lkdGggPSB0ZXh0YXJlYVdpZHRoICsgJ3B4JztcclxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSB0ZXh0YXJlYUhlaWdodCArIFwicHhcIjtcclxuICAgICAgICB2YXIgbm9kZVJlY3QgPSB1dGlsLmdldFJlY3QodGhpc05vZGUpO1xyXG4gICAgICAgIHZhciBtYXhXaWR0aCA9IDEuMiAqIG5vZGVSZWN0LndpZHRoICogdGhpcy5ub3dab29tO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLmxpbmVIZWlnaHQgPSAoMS4yICogdGV4dFJlY3QubGluZUhlaWdodCB8fCAxNC40KSArIFwicHhcIjtcclxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5ib3JkZXIgPSBcIjFweCBkYXNoZWQgIzJlMmUyZVwiO1xyXG4gICAgICAgIHRleHRhcmVhLmlubmVySFRNTCA9IHRoaXNOb2RlLnN0eWxlLnRleHQ7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aCArICdweCc7XHJcbiAgICAgICAgdGhpcy5zZXRTdHlsZSh0aGlzTm9kZSwge3RleHQ6IFwiXCJ9KTsgIC8v5YWI5oqK6IqC54K55paH5pys57uZ5riF56m677yM5ZCm5YiZ5Yig6Zmk5paH5pys5qGG5Lit5paH5a2X55qE5pe25YCZ77yM5Lya5pi+56S65Ye65p2lXHJcbiAgICAgICAgdGhpcy5fZG9tLmFwcGVuZENoaWxkKHRleHRhcmVhKTtcclxuICAgICAgICB0aGlzLl9kb20uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XHJcbiAgICAgICAgdmFyIG9mZmVzdEkgPSAxO1xyXG4gICAgICAgIGlmICh0aGlzTm9kZS5zdHlsZS50ZXh0QWxpZ24gPT0gXCJsZWZ0XCIpIHtcclxuICAgICAgICAgICAgb2ZmZXN0SSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzTm9kZS5zdHlsZS50ZXh0QWxpZ24gPT0gXCJyaWdodFwiKSB7XHJcbiAgICAgICAgICAgIG9mZmVzdEkgPSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb2ZmZXN0UCA9IDA7XHJcbiAgICAgICAgaWYgKHRoaXNOb2RlLnN0eWxlLnRleHRQb3NpdGlvbiAmJiB0aGlzTm9kZS5zdHlsZS50ZXh0UG9zaXRpb24gPT0gXCJib3R0b21cIikge1xyXG4gICAgICAgICAgICBvZmZlc3RQID0gMTtcclxuICAgICAgICAgICAgbWF4V2lkdGggPSBNQVhXSURUSF9NVUxUSVBMRV9UT1BfQk9UVE9NICogbm9kZVJlY3Qud2lkdGggKiB0aGlzLm5vd1pvb207XHJcbiAgICAgICAgICAgIHRleHRhcmVhLnN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGggKyBcInB4XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzTm9kZS5zdHlsZS50ZXh0UG9zaXRpb24gJiYgdGhpc05vZGUuc3R5bGUudGV4dFBvc2l0aW9uID09IFwidG9wXCIpIHtcclxuICAgICAgICAgICAgb2ZmZXN0UCA9IC0xO1xyXG4gICAgICAgICAgICBtYXhXaWR0aCA9IE1BWFdJRFRIX01VTFRJUExFX1RPUF9CT1RUT00gKiBub2RlUmVjdC53aWR0aCAqIHRoaXMubm93Wm9vbTtcclxuICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aCArIFwicHhcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUudG9wID0gKG5vZGVSZWN0LnkgLSB0ZXh0YXJlYUhlaWdodCAvIDIgKyBvZmZlc3RQICogKG5vZGVSZWN0LmhlaWdodCAtIHRleHRSZWN0LmhlaWdodCAvXHJcbiAgICAgICAgICAgIDIpKSAqIHRoaXMubm93Wm9vbSArIHRoaXMuZ3JvdXAucG9zaXRpb25bMV0gKyBcInB4XCI7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUubGVmdCA9IChub2RlUmVjdC54IC0gb2ZmZXN0SSAqIHRleHRhcmVhV2lkdGggLyAyKSAqIHRoaXMubm93Wm9vbSArXHJcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAucG9zaXRpb25bMF0gKyBcInB4XCI7XHJcbiAgICAgICAgdGV4dGFyZWEuZm9jdXMoKTtcclxuICAgICAgICB0ZXh0YXJlYS5zZWxlY3QoKTtcclxuICAgICAgICB0ZXh0YXJlYS5vbmtleXVwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IGtleUNvZGUuRVNDQVBFKSB7XHJcbiAgICAgICAgICAgICAgICBpc05vdFNldFRleHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGV4dGFyZWEuYmx1cigpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRleHRSZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KHRleHRhcmVhLnZhbHVlLCB0aGlzTm9kZS5zdHlsZS50ZXh0Rm9udCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0YXJlYVJlc2l6ZSh0ZXh0UmVjdCwgdGV4dGFyZWEsIG1heFdpZHRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICAgICAgdGV4dGFyZWEub25ibHVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNOb3RTZXRUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuaGFuZGxlV3JhcCh0ZXh0YXJlYS52YWx1ZSwgdGV4dGFyZWEuc3R5bGUubWF4V2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdHlsZSh0aGlzTm9kZSwge3RleHQ6IHRleHR9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3R5bGUodGhpc05vZGUsIHt0ZXh0OiBub2RlVGV4dH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRleHRhcmVhLnJlbW92ZSgpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog5Yib5bu65paH5pys5Z+fXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uY3JlYXRlVGV4dEFyZWEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRleHRhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLnBhZGRpbmcgPSBcIjZweFwiO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLnJlc2l6ZSA9IFwibm9uZVwiO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLndoaXRlU3BhY2UgPSBcInByZVwiO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLmxpbmVIZWlnaHQgPSBcIjEyNSVcIjtcclxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUuYm9yZGVyID0gXCIwXCI7XHJcbiAgICAgICAgdGV4dGFyZWEuc3BlbGxjaGVjayA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0ZXh0YXJlYTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog5aSE55CGdGV4dGFyZWHoh6rliqjmjaLooYxcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5oYW5kbGVXcmFwID0gZnVuY3Rpb24gKHZhbHVlLCB3aWR0aCkge1xyXG4gICAgICAgIHZhciBzcGFuTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xyXG4gICAgICAgIHNwYW5Ob2RlLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG4gICAgICAgIHNwYW5Ob2RlLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcclxuICAgICAgICBzcGFuTm9kZS5zdHlsZS5ib3JkZXIgPSBcIjBcIjtcclxuICAgICAgICBzcGFuTm9kZS5zdHlsZS5wYWRkaW5nID0gXCIwXCI7XHJcbiAgICAgICAgc3Bhbk5vZGUuc3R5bGUubGVmdCA9IFwiMFwiO1xyXG4gICAgICAgIHNwYW5Ob2RlLnN0eWxlLnRvcCA9IFwiMFwiO1xyXG4gICAgICAgIHRoaXMuX2RvbS5hcHBlbmRDaGlsZChzcGFuTm9kZSk7XHJcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB2YWx1ZS5zcGxpdChcIlxcblwiKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgICBjb250ZW50LmZvckVhY2goZnVuY3Rpb24odmFsLCBpKXtcclxuICAgICAgICAgICAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmICh2YWxMZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy9yZXN1bHQgKz0gXCJcXG5cIjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcmUgPSBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubmVyVmFsLCB0ZW1wV2lkdGgsIGNvbldpZHRoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5uZXJJID0gMDsgaW5uZXJJIDwgdmFsTGVuZ3RoOyBpbm5lckkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlubmVyVmFsID0gdmFsLmNoYXJBdChpbm5lckkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNwYW5Ob2RlLmlubmVySFRNTCA9IHNwYW5Ob2RlLmlubmVySFRNTCArIGlubmVyVmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBXaWR0aCA9IHNwYW5Ob2RlLmNsaWVudFdpZHRoOyAvL+iOt+WPlua3u+WKoOWtl+espuWQjumakOiXj+Wfn+eahOWuveW6plxyXG4gICAgICAgICAgICAgICAgICAgIGNvbldpZHRoID0gTnVtYmVyKHdpZHRoLnN1YnN0cmluZygwLCB3aWR0aC5sZW5ndGggLSAyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBXaWR0aCA+IGNvbldpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBwcmU7IC8v5aaC5p6c6L+95Yqg5a2X56ym5ZCO6ZqQ6JeP5Z+f5a695bqm5aSn5LqOVGV4dEFyZWHlrr3luqbvvIzliJnooajmmI7or6XlrZfnrKbkuLrkuIvkuIDooYzlrZfnrKbvvIxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW5Ob2RlLmlubmVySFRNTCA9IGlubmVyVmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmUgPSBpbm5lclZhbDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlubmVySSA9PSB2YWxMZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBwcmUgKyBpbm5lclZhbDsgLy/mnIDlkI7kuIDkuKrlrZfnrKZcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBjb250ZW50Lmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcblwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW5Ob2RlLmlubmVySFRNTCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZSA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlICs9IGlubmVyVmFsOyAvL+S+neasoei/veWKoOWIsHByZeWPmOmHj+S4rVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9kb20ucmVtb3ZlQ2hpbGQoc3Bhbk5vZGUpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOaWh+acrOWfn+iHqumAguW6lOmrmOWuvVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLl90ZXh0YXJlYVJlc2l6ZSA9IGZ1bmN0aW9uICh0ZXh0UmVjdCwgdGV4dGFyZWEsIHdpZHRoKSB7XHJcbiAgICAgICAgdmFyIG1pbldpZHRoID0gMDtcclxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS53aWR0aCA9IDA7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUud2lkdGggPSAoMS4yICogdGV4dFJlY3Qud2lkdGgpICogdGhpcy5ub3dab29tICsgXCJweFwiO1xyXG4gICAgICAgIGlmICh3aWR0aCA8IDYwKSB7XHJcbiAgICAgICAgICAgIG1pbldpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWluV2lkdGggPSA4MFxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGV4dFJlY3Qud2lkdGggPD0gbWluV2lkdGgpIHtcclxuICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUud2lkdGggPSBtaW5XaWR0aCArIFwicHhcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gXCIwcHhcIjtcclxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSB0ZXh0YXJlYS5zY3JvbGxIZWlnaHQgKyAncHgnO1xyXG4gICAgICAgIGlmICh0ZXh0YXJlYS5zY3JvbGxIZWlnaHQgPD0gMCkge1xyXG4gICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSBcIjEycHhcIjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHNldFN0eWxlXHJcbiAgICAgKiDoioLngrnmm7TmlLlzdHlsZemHjOeahOWxnuaAp1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUg6IqC54K5c3R5bGXph4znmoTmn5DkuKrlsZ7mgKflkI3np7BcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcg6IqC54K5c3R5bGXph4znmoTmn5DkuKrlsZ7mgKflkI3np7Dlr7nlupTnmoTlgLxcclxuICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAqXHJcbiAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgKiAgICAgICAgICAvL+iKgueCueiuvue9ruaWh+Wtl1xyXG4gICAgICogICAgICAgICBmaXNodG9wby5zZXRTdHlsZShub2RlLHt0ZXh0Olwi5L6L5a2QXCJ9KTtcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5zZXRTdHlsZSA9IGZ1bmN0aW9uIChub2RlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgbm9kZS5zZXRTdHlsZShvcHRpb25zKTtcclxuICAgICAgICB6clV0aWwubWVyZ2Uobm9kZS5tb2RlbC5nZXQoXCJvcHRpb25zLnN0eWxlXCIpLCBvcHRpb25zLCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2Qgc2V0U2hhcGVcclxuICAgICAqIOiKgueCueabtOaUuXNoYXBl6YeM55qE5bGe5oCnXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSDoioLngrlzaGFwZemHjOeahOafkOS4quWxnuaAp+WQjeensFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyDoioLngrlzaGFwZemHjOeahOafkOS4quWxnuaAp+WQjeensOWvueW6lOeahOWAvFxyXG4gICAgICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICpcclxuICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAqICAgICAgICAgIC8v55+p5b2i6IqC54K56K6+572u5a69XHJcbiAgICAgKiAgICAgICAgIGZpc2h0b3BvLnNldFNoYXBlKG5vZGUse3dpZHRoOjEwMH0pO1xyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLnNldFNoYXBlID0gZnVuY3Rpb24gKG5vZGUsIG9wdGlvbnMpIHtcclxuICAgICAgICBub2RlLnNldFNoYXBlKG9wdGlvbnMpO1xyXG4gICAgICAgIGlmIChub2RlLm1vZGVsKSB7XHJcbiAgICAgICAgICAgIHpyVXRpbC5tZXJnZShub2RlLm1vZGVsLmdldChcIm9wdGlvbnMuc2hhcGVcIiksIG9wdGlvbnMsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uuiKgueCueS4iumdoueahOitpuWRilxyXG4gICAgICogQG1ldGhvZCBjcmVhdGVBbGFybVxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBub2RlIOiKgueCuVxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHQgIOmAiemhueWAvFxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0LnRleHRdIOitpuWRiueahOaWh+Wtl1xyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0LnRleHRGb250XSDorablkYrnmoTmloflrZfnmoTlrZfkvZNcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdC50ZXh0RmlsbF0g6K2m5ZGK55qE5paH5a2X55qE6aKc6ImyXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHQudGV4dEJhY2tncm91bmRdIOitpuWRiueahOiDjOaZr+eahOminOiJslxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSDov5Tlm57oioLngrnkuIrnmoTorablkYpcclxuICAgICAqXHJcbiAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgKlxyXG4gICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICogICAgICAgICAgdGhpcy5maXNoVG9wby5jcmVhdGVBbGFybShzMSx7XHJcbiAgICAgKiAgICAgICAgICB0ZXh0OlwiMiBXXCIsXHJcbiAgICAgKiAgICAgICAgICB0ZXh0Rm9udDpcIjRweCBNaWNyb3NvZnQgWWFIZWlcIixcclxuICAgICAqICAgICAgICAgIHRleHRGaWxsOlwiI0ZGRkZGRlwiLFxyXG4gICAgICogICAgICAgICAgdGV4dEJhY2tncm91bmQ6XCJyZ2JhKDI1NSwwLDAsMC42KVwiXHJcbiAgICAgKiAgICAgIH0pOy8v5Yib5bu65bCP5Zu+54mH5ZKM6IqC54K557uR5a6aXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uY3JlYXRlQWxhcm0gPSBmaXNoVG9wb1Byb3RvLmNyZWF0QWxhcm0gPSBmdW5jdGlvbiAobm9kZSwgb3B0KSB7XHJcbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5jcmVhdGVOb2RlKFwiR3JvdXBcIiwge1xyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJ3JnYmEoMCwwLDAsMCknLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAncmdiYSgwLDAsMCwwKSdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGdyb3VwLmlzZHJhZ2dhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLmNyZWF0ZU5vZGUoXCJUZXh0XCIsIHsgLy/mloflrZdcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IG9wdC50ZXh0LFxyXG4gICAgICAgICAgICAgICAgdGV4dEZvbnQ6IG9wdC50ZXh0Rm9udCxcclxuICAgICAgICAgICAgICAgIGZpbGw6IG9wdC50ZXh0RmlsbCxcclxuICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogXCJ0b3BcIiAvL+WeguebtOWvuem9kCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBbMiwgMF0sXHJcbiAgICAgICAgICAgIHo6IDJcclxuICAgICAgICB9KTtcclxuICAgICAgICB0ZXh0LmlzZHJhZ2dhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgZ3JvdXAuYWRkKHRleHQpO1xyXG4gICAgICAgIGlmIChGbG93LmlzSW5Hcm91cChub2RlKSkge1xyXG4gICAgICAgICAgICBub2RlLnBhcmVudC5hZGQoZ3JvdXApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKGdyb3VwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGdyb3VwV2lkdGggPSBncm91cC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCArIDI7XHJcbiAgICAgICAgdmFyIGdyb3VwSGVpZ2h0ID0gZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0ICsgNjtcclxuICAgICAgICB2YXIgcG9pbnRzID0gW1xyXG4gICAgICAgICAgICBbMCwgMF0sXHJcbiAgICAgICAgICAgIFtncm91cFdpZHRoLCAwXSxcclxuICAgICAgICAgICAgW2dyb3VwV2lkdGgsIGdyb3VwSGVpZ2h0XSxcclxuICAgICAgICAgICAgW2dyb3VwV2lkdGggLSAzLCBncm91cEhlaWdodF0sXHJcbiAgICAgICAgICAgIFtncm91cFdpZHRoIC0gNiwgZ3JvdXBIZWlnaHQgKyAzXSxcclxuICAgICAgICAgICAgW2dyb3VwV2lkdGggLSA5LCBncm91cEhlaWdodF0sXHJcbiAgICAgICAgICAgIFswLCBncm91cEhlaWdodF0sXHJcbiAgICAgICAgICAgIFswLCAwXVxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdmFyIFBvbHlsaW5lID0gdGhpcy5jcmVhdGVOb2RlKFwiUG9seWxpbmVcIiwge1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHNcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IG9wdC50ZXh0QmFja2dyb3VuZCxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogb3B0LnRleHRCYWNrZ3JvdW5kXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICB6OiAxXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgUG9seWxpbmUuaXNkcmFnZ2FibGUgPSBmYWxzZTtcclxuICAgICAgICBncm91cC5hZGQoUG9seWxpbmUpO1xyXG4gICAgICAgIHZhciBncm91cFBvc2l0aW9uID0gW25vZGUucG9zaXRpb25bMF0gKyBub2RlLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC0gKGdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC1cclxuICAgICAgICAgICAgNiksIG5vZGUucG9zaXRpb25bMV0gLSBncm91cC5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLSAzXTtcclxuICAgICAgICBncm91cC5hdHRyKFwicG9zaXRpb25cIiwgZ3JvdXBQb3NpdGlvbik7XHJcbiAgICAgICAgbm9kZS5hbGFybSA9IGdyb3VwO1xyXG4gICAgICAgIC8v6K6+572u5qih5Z6LIOe7mWpzb27luo/liJfljJbnlKhcclxuICAgICAgICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwoe30pO1xyXG4gICAgICAgIG1vZGVsLnNldChDb25zdGFudHMuRUxFTUVOVF9UWVBFLCBDb25zdGFudHMuQUxBUk0pO1xyXG4gICAgICAgIG1vZGVsLnNldChDb25zdGFudHMuT1BUSU9OUywgenJVdGlsLmNsb25lKG9wdCkpO1xyXG4gICAgICAgIG1vZGVsLnNldChDb25zdGFudHMuUkVMQVRJT05JRCwgbm9kZS5tb2RlbC5nZXQoQ29uc3RhbnRzLklEKSk7XHJcbiAgICAgICAgZ3JvdXAubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICByZXR1cm4gZ3JvdXA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOi/lOWbnuW9k+WJjeeUu+W4g+eahOaVsOaNrlxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLnRvRGF0YVVSTCA9IGZ1bmN0aW9uIChvcHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIEZsb3dVdGlsLnRvRGF0YVVSTCh0aGlzLl96ciwgb3B0cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uX3JlbGVhc2VTZWxlY3ROb2RlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRyYWdTZWxlY3RSZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlcyA9IHRoaXMuZHJhZ1NlbGVjdFJlY3QuY2hpbGRyZW4oKS5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2Lm5hbWUgIT09IFwiR1JPVVBfUkVDVF9OQU1FXCI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXBOb2Rlc0lkcyA9IHRoaXMuZ3JvdXAuY2hpbGRyZW4oKVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2Lm5hbWUgIT09IFwiR1JPVVBfUkVDVF9OQU1FXCI7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYuaWRcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRYID0gdGhpcy5kcmFnU2VsZWN0UmVjdC5wb3NpdGlvblswXTtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0WSA9IHRoaXMuZHJhZ1NlbGVjdFJlY3QucG9zaXRpb25bMV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZVggPSBGbG93LmlzR3JvdXBOb2RlKGl0ZW0pID8gaXRlbS5wb3NpdGlvblswXSArIGl0ZW0ub3B0aW9ucy5zaGFwZS54IDogaXRlbS5wb3NpdGlvblswXTtcclxuICAgICAgICAgICAgICAgIHZhciBub2RlWSA9IEZsb3cuaXNHcm91cE5vZGUoaXRlbSkgPyBpdGVtLnBvc2l0aW9uWzFdICsgaXRlbS5vcHRpb25zLnNoYXBlLnkgOiBpdGVtLnBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnU2VsZWN0UmVjdC5yZW1vdmUoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAvLyBncm91cOWGheS4jeWtmOWcqGRyYWdTZWxlY3RSZWN06IqC54K55pa55Y+v5re75YqgXHJcbiAgICAgICAgICAgICAgICBpZiAoIWdyb3VwTm9kZXNJZHMuaW5jbHVkZXMoaXRlbS5pZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChpdGVtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpdGVtLm1vZGVsLm9wdGlvbi5lbGVtZW50VHlwZSAhPT0gXCJjb25uZWN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLmF0dHIoXCJwb3NpdGlvblwiLCBbbm9kZVgrc3RhcnRYLCBub2RlWStzdGFydFldKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlZnJlc2hMaW5lQnlOb2RlKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdFJlY3Qub2ZmKFwibW91c2Vkb3duXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwLnJlbW92ZSh0aGlzLmRyYWdTZWxlY3RSZWN0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZmlzaFRvcG9Qcm90by5fZHJhZ1NlbGVjdCA9IGZ1bmN0aW9uIChub2RlLCB4LCB5KSB7XHJcbiAgICAgICAgdmFyIGNhbnZhc09mZnNldFggPSB0aGlzLmdyb3VwLnBvc2l0aW9uWzBdO1xyXG4gICAgICAgIHZhciBjYW52YXNPZmZzZXRZID0gdGhpcy5ncm91cC5wb3NpdGlvblsxXTtcclxuICAgICAgICB0aGlzLl9yZWxlYXNlU2VsZWN0Tm9kZSgpOyAgLy/ov5jljp/pgInkuK3nmoToioLngrlcclxuICAgICAgICB0aGlzLmRyYWdTZWxlY3RSZWN0ID0gbmV3IEdyb3VwTm9kZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOnsgd2lkdGg6IDAsIGhlaWdodDogMH0sXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOlsoeC1jYW52YXNPZmZzZXRYKS90aGlzLm5vd1pvb20sICh5LWNhbnZhc09mZnNldFkpL3RoaXMubm93Wm9vbV0sXHJcbiAgICAgICAgICAgIGNoaWxkRHJhZ2dhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGxpbmVEYXNoOlsyLDJdLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogXCJyZ2JhKDIzOSwyMjIsMjIxLDAuNylcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJyNkZGQnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRyYWdTZWxlY3RSZWN0LnR5cGUgPSBcImRyYWdTZWxlY3RcIjtcclxuICAgICAgICB0aGlzLmdyb3VwLmFkZCh0aGlzLmRyYWdTZWxlY3RSZWN0KTtcclxuICAgICAgICB0aGlzLmRyYWcodGhpcy5kcmFnU2VsZWN0UmVjdCk7XHJcblxyXG4gICAgICAgIHZhciBtb3ZlSGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgcG9zWCA9IHggPD0gZXZlbnQub2Zmc2V0WCA/IHggOiBldmVudC5vZmZzZXRYO1xyXG4gICAgICAgICAgICB2YXIgcG9zWSA9IHkgPD0gZXZlbnQub2Zmc2V0WSA/IHkgOiBldmVudC5vZmZzZXRZO1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBNYXRoLmFicyhldmVudC5vZmZzZXRYIC0geCk7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBNYXRoLmFicyhldmVudC5vZmZzZXRZIC0geSk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdFJlY3Quc2hhcGUgPSB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgvdGhpcy5ub3dab29tLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQvdGhpcy5ub3dab29tXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kcmFnU2VsZWN0UmVjdC5zZXRQcm9wZXJ0aWVzKHtzaGFwZToge3dpZHRoOndpZHRoL3RoaXMubm93Wm9vbSwgaGVpZ2h0OiBoZWlnaHQvdGhpcy5ub3dab29tfSwgcG9zaXRpb246IFsocG9zWC1jYW52YXNPZmZzZXRYKS90aGlzLm5vd1pvb20sIChwb3NZLWNhbnZhc09mZnNldFkpL3RoaXMubm93Wm9vbV19KTtcclxuICAgICAgICB9LmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fenIub24oJ21vdXNlbW92ZScsIG1vdmVIYW5kbGVyKTtcclxuXHJcbiAgICAgICAgdmFyIGVuZERyYWdIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3pyLm9mZignbW91c2Vtb3ZlJywgbW92ZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl96ci5vZmYoJ21vdXNldXAnLCBlbmREcmFnSGFuZGxlcik7XHJcbiAgICAgICAgICAgIHRoaXMuX3pyLm9mZihcImdsb2JhbG91dFwiLCBlbmREcmFnSGFuZGxlcik7XHJcblxyXG4gICAgICAgICAgICB2YXIgdHMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyb3VwLmNoaWxkcmVuKCkuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5pZCAhPT0gdHMuZHJhZ1NlbGVjdFJlY3QuaWQgJiYgdi5tb2RlbCAmJiB2Lm1vZGVsLm9wdGlvbi5lbGVtZW50VHlwZSAhPT0gXCJjb25uZWN0aW9uXCI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgYWxsTGluZXMgPSB0aGlzLmdyb3VwLmNoaWxkcmVuKCkuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5tb2RlbCAmJiB2Lm1vZGVsLm9wdGlvbi5lbGVtZW50VHlwZSA9PT0gXCJjb25uZWN0aW9uXCI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRYID0gdGhpcy5kcmFnU2VsZWN0UmVjdC5wb3NpdGlvblswXTtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0WSA9IHRoaXMuZHJhZ1NlbGVjdFJlY3QucG9zaXRpb25bMV07XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZHJhZ1NlbGVjdFJlY3Qub3B0aW9ucy5zaGFwZS53aWR0aDtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZHJhZ1NlbGVjdFJlY3Qub3B0aW9ucy5zaGFwZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBjbnQgPSAwO1xyXG4gICAgICAgICAgICBhbGxOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHV0aWwuZ2V0UmVjdChpdGVtLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHZhciBub2RlV2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVIZWlnaHQgPSByZWN0LmhlaWdodDtcclxuICAgICAgICAgICAgICAgIHZhciBub2RlWCA9IHJlY3QueCAtIG5vZGVXaWR0aC8yO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVZID0gcmVjdC55IC0gbm9kZUhlaWdodC8yO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVYID49IHN0YXJ0WCAmJiBub2RlWSA+PSBzdGFydFkgJiYgbm9kZVgrbm9kZVdpZHRoIDw9IHN0YXJ0WCt3aWR0aCAmJiBub2RlWStub2RlSGVpZ2h0IDw9IHN0YXJ0WStoZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cy5ncm91cC5yZW1vdmUoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHMuZHJhZ1NlbGVjdFJlY3QuYWRkKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRzLnNlbGVjdGVkTm9kZXMucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLmF0dHIoXCJwb3NpdGlvblwiLCBbaXRlbS5wb3NpdGlvblswXS1zdGFydFgsIGl0ZW0ucG9zaXRpb25bMV0tc3RhcnRZXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY250Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBhbGxMaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnROb2RlID0gdHMuZHJhZ1NlbGVjdFJlY3QuY2hpbGRyZW4oKS5maW5kKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYuaWQgPT09IGl0ZW0uc3RhcnROb2RlLmlkO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kTm9kZSA9IHRzLmRyYWdTZWxlY3RSZWN0LmNoaWxkcmVuKCkuZmluZChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2LmlkID09PSBpdGVtLmVuZE5vZGUuaWQ7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGFydE5vZGUgJiYgZW5kTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRzLmdyb3VwLnJlbW92ZShpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICB0cy5kcmFnU2VsZWN0UmVjdC5hZGQoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHMuc2VsZWN0ZWROb2Rlcy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlZnJlc2hMaW5lQnlOb2RlKGl0ZW0uc3RhcnROb2RlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnROb2RlIHx8IGVuZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDliKDpmaTpgInmoYblpJbnmoToioLngrnkuI7lhoXoioLngrnpl7TnmoTov57nur9cclxuICAgICAgICAgICAgICAgICAgICB0cy5ncm91cC5yZW1vdmUoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoIWNudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnU2VsZWN0UmVjdC5vZmYoXCJtb3VzZWRvd25cIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLnJlbW92ZSh0aGlzLmRyYWdTZWxlY3RSZWN0KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdFJlY3QuY2hpbGRPZk5hbWUoXCJHUk9VUF9SRUNUX05BTUVcIikuYXR0cihcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBcInJnYmEoMCwwLDAsMClcIlxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kcmFnU2VsZWN0UmVjdC5tb2RlbC5zZXQoXCJvcHRpb25zLnBvc2l0aW9uXCIsIEZsb3dVdGlsLnRydW5jUG9zaXRpb24odGhpcy5kcmFnU2VsZWN0UmVjdC5wb3NpdGlvbikpO1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdTZWxlY3RSZWN0Lm1vZGVsLnNldChcIm9wdGlvbnMuc2hhcGVcIiwgdGhpcy5kcmFnU2VsZWN0UmVjdC5zaGFwZSk7XHJcbiAgICAgICAgICAgIC8vIHRoaXMuc3RlcENvdW50ZXIoKTtcclxuICAgICAgICB9LmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fenIub24oJ21vdXNldXAnLCBlbmREcmFnSGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5fenIub24oXCJnbG9iYWxvdXRcIiwgZW5kRHJhZ0hhbmRsZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uX2dyb3VwRHJhZ0hhbmRsZXIgPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgIC8vIGZsb3fkuK3mnIDlpJblsYLnmoRncm91cOenu+WKqOaTjeS9nFxyXG4gICAgICAgIHZhciBub3dHcm91cFBvc2l0aW9uID0gdGhpcy5ncm91cC5wb3NpdGlvbjtcclxuICAgICAgICB2YXIgZ3JvdXBQb3NpdGlvblggPSB0aGlzLmdyb3VwLnBvc2l0aW9uWzBdO1xyXG4gICAgICAgIHZhciBncm91cFBvc2l0aW9uWSA9IHRoaXMuZ3JvdXAucG9zaXRpb25bMV07XHJcblxyXG4gICAgICAgIHZhciBtb3ZlSGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoICogdGhpcy5ub3dab29tO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5ncm91cC5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgKiB0aGlzLm5vd1pvb207XHJcbiAgICAgICAgICAgIHZhciBneCA9IHRoaXMuZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCkueCAqIHRoaXMubm93Wm9vbTtcclxuICAgICAgICAgICAgdmFyIGd5ID0gdGhpcy5ncm91cC5nZXRCb3VuZGluZ1JlY3QoKS55ICogdGhpcy5ub3dab29tO1xyXG4gICAgICAgICAgICB2YXIgbWluID0gWzEwIC0gKHdpZHRoICsgZ3gpLCAxMCAtIChoZWlnaHQgKyBneSldO1xyXG4gICAgICAgICAgICB2YXIgbWF4ID0gWyh0aGlzLl96ci5nZXRXaWR0aCgpIC0gZ3gpIC0gMTAsICh0aGlzLl96ci5nZXRIZWlnaHQoKSAtIGd5KSAtIDEwXTtcclxuICAgICAgICAgICAgdmFyIHNYID0gZXZlbnQub2Zmc2V0WCAtIHg7XHJcbiAgICAgICAgICAgIHZhciBzWSA9IGV2ZW50Lm9mZnNldFkgLSB5O1xyXG4gICAgICAgICAgICBub3dHcm91cFBvc2l0aW9uWzBdID0gZ3JvdXBQb3NpdGlvblggKyBzWDtcclxuICAgICAgICAgICAgbm93R3JvdXBQb3NpdGlvblsxXSA9IGdyb3VwUG9zaXRpb25ZICsgc1k7XHJcbiAgICAgICAgICAgIGlmIChub3dHcm91cFBvc2l0aW9uWzBdID4gbWF4WzBdIHx8IG5vd0dyb3VwUG9zaXRpb25bMV0gPiBtYXhbMV0gfHwgbm93R3JvdXBQb3NpdGlvblswXSA8XHJcbiAgICAgICAgICAgICAgICBtaW5bMF0gfHwgbm93R3JvdXBQb3NpdGlvblsxXSA8IG1pblsxXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cC5hdHRyKFwicG9zaXRpb25cIiwgbm93R3JvdXBQb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lYWdsZUV5ZSA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5pbWFwLnVwZGF0YVNlbGVjdGlvblBvc2l0aW9uKG5vd0dyb3VwUG9zaXRpb24sIHRoaXMubm93Wm9vbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fenIub24oJ21vdXNlbW92ZScsIG1vdmVIYW5kbGVyKTtcclxuXHJcbiAgICAgICAgdmFyIGVuZERyYWdIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl96ci5vZmYoJ21vdXNlbW92ZScsIG1vdmVIYW5kbGVyKTtcclxuICAgICAgICAgICAgdGhpcy5fenIub2ZmKCdtb3VzZXVwJywgZW5kRHJhZ0hhbmRsZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl96ci5vZmYoXCJnbG9iYWxvdXRcIiwgZW5kRHJhZ0hhbmRsZXIpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLl96ci5vbignbW91c2V1cCcsIGVuZERyYWdIYW5kbGVyKTtcclxuICAgICAgICB0aGlzLl96ci5vbihcImdsb2JhbG91dFwiLCBlbmREcmFnSGFuZGxlcik7XHJcbiAgICB9O1xyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uaW5pdFNjYWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBncm91cE1heFdpZHRoID0gdGhpcy5ncm91cC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aDtcclxuICAgICAgICB2YXIgZ3JvdXBNYXhIZWlnaHQgPSB0aGlzLmdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodDtcclxuICAgICAgICB2YXIgcmFuZ2VXaWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcclxuICAgICAgICB2YXIgcmFuZ2VIZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xyXG4gICAgICAgIHZhciBpbml0UmF0aW8gPSAxLFxyXG4gICAgICAgICAgICBwb3MgPSBbXTtcclxuICAgICAgICBpZiAoZ3JvdXBNYXhXaWR0aCAvIGdyb3VwTWF4SGVpZ2h0ID4gcmFuZ2VXaWR0aCAvIHJhbmdlSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGlmIChncm91cE1heFdpZHRoID4gcmFuZ2VXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgaW5pdFJhdGlvID0gcmFuZ2VXaWR0aCAvIGdyb3VwTWF4V2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZ3JvdXBNYXhIZWlnaHQgPiByYW5nZUhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgaW5pdFJhdGlvID0gcmFuZ2VIZWlnaHQgLyBncm91cE1heEhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBwb3NbMF0gPSBNYXRoLmFicyh0aGlzLmdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLngpICogaW5pdFJhdGlvO1xyXG4gICAgICAgIHBvc1sxXSA9IE1hdGguYWJzKHRoaXMuZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCkueSkgKiBpbml0UmF0aW87XHJcbiAgICAgICAgdGhpcy5ncm91cC5hdHRyKFwicG9zaXRpb25cIiwgW3Bvc1swXSwgcG9zWzFdXSk7XHJcbiAgICAgICAgdGhpcy5ncm91cC5hdHRyKFwic2NhbGVcIiwgW2luaXRSYXRpbywgaW5pdFJhdGlvXSk7XHJcbiAgICAgICAgdGhpcy5pbml0U2NhbGVSYXRpbyA9IGluaXRSYXRpbztcclxuICAgICAgICB2YXIgZGlzdGFuY2UgPSBbcG9zWzBdLCBwb3NbMV0sIHRoaXMuaW5pdFNjYWxlUmF0aW8sIGdyb3VwTWF4V2lkdGgsIGdyb3VwTWF4SGVpZ2h0XTtcclxuICAgICAgICByZXR1cm4gZGlzdGFuY2U7XHJcbiAgICB9O1xyXG5cclxuXHQvKipcclxuXHQgKiDnlLvluIPlhYPntKDlnKjmsLTlubPmlrnlkJHlkozlnoLnm7TmlrnlkJHlsYXkuK1cclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gYm91bmRQb3Mg5YW25Lit6ZyA5Lyg5YWl55qE5bGe5oCn5YiG5Yir5Li6bWluWCxtaW5ZLG1heFgsbWF4WeWMheWbtOeUu+W4g+S4iuaJgOacieiKgueCueeahOacgOWwj+i+ueahhueahOacgOWwj+eahHjlnZDmoIfjgIF55Z2Q5qCH44CB5pyA5aSn55qEeOWdkOagh+OAgXnlnZDmoIdcclxuXHQgKi9cclxuXHRmaXNoVG9wb1Byb3RvLnpyQ2VudGVyID0gZnVuY3Rpb24gKGJvdW5kUG9zKSB7XHJcbiAgICAgICAgdmFyIGJvdW5kT2JqO1xyXG4gICAgICAgIHZhciBub3dHcm91cFBvc2l0aW9uID0gdGhpcy5ncm91cC5wb3NpdGlvbjtcclxuICAgICAgICBpZiAoenJVdGlsLmlzQXJyYXkoYm91bmRQb3MpKSB7XHJcbiAgICAgICAgICAgIGJvdW5kT2JqID0genJVdGlsLmV4dGVuZCh7fSwge21pblg6IGJvdW5kUG9zWzBdLCBtaW5ZOiBib3VuZFBvc1sxXSwgbWF4WDogYm91bmRQb3NbMl0sIG1heFk6IGJvdW5kUG9zWzNdfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYm91bmRPYmogPSB6clV0aWwuZXh0ZW5kKHt9LCBib3VuZFBvcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vd0dyb3VwUG9zaXRpb25bMF0gPSB0aGlzLl96ci5kb20ub2Zmc2V0V2lkdGgvMiAtIChib3VuZE9iai5taW5YICsgKChib3VuZE9iai5tYXhYIC0gYm91bmRPYmoubWluWCkvMikpO1xyXG4gICAgICAgIG5vd0dyb3VwUG9zaXRpb25bMV0gPSB0aGlzLl96ci5kb20ub2Zmc2V0SGVpZ2h0LzIgLSAoYm91bmRPYmoubWluWSArICgoYm91bmRPYmoubWF4WSAtIGJvdW5kT2JqLm1pblkpLzIpKTtcclxuICAgICAgICB0aGlzLmdyb3VwLmF0dHIoXCJwb3NpdGlvblwiLCBub3dHcm91cFBvc2l0aW9uKTtcclxuICAgIH07XHJcblxyXG4gICAgZmlzaFRvcG9Qcm90by5zdGVwQ291bnRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuc3RlcEpzb24uc3BsaWNlKHRoaXMuc3RlcCwgdGhpcy5zdGVwSnNvbi5sZW5ndGggLSAodGhpcy5zdGVwKSk7XHJcbiAgICAgICAgdGhpcy5zdGVwICs9IDE7XHJcbiAgICAgICAgdmFyIGpzb24gPSB0aGlzLnRvSnNvbigpO1xyXG4gICAgICAgIHRoaXMuc3RlcEpzb24ucHVzaChKU09OLnN0cmluZ2lmeShqc29uKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5pS+5aSn5oiW6ICF57yp5bCPXHJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd8TnVtYmVyfSB0eXBlIOW9k+S4uuWtl+espuS4suaXtiBcImVubGFyZ2VcIuaUvuWkpyAgXCJuYXJyb3dpbmdcIue8qeWwjyAg5b2T5Li65pWw5YC85pe2IOe8qeaUvueahOavlOS+iyAg5bu66K6uMC4zLTEuN1xyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLnpyU2NhbGUgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgICAgIHZhciB6b29tRGVsdGEgPSAwO1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PSBcIm5hcnJvd2luZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICB6b29tRGVsdGEgPSAtMC4wNztcclxuICAgICAgICAgICAgICAgIHRoaXMuem9vbSh6b29tRGVsdGEsIHRoaXMuX3pyLmdldFdpZHRoKCkgLyAyLCB0aGlzLl96ci5nZXRIZWlnaHQoKSAvIDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09IFwiZW5sYXJnZVwiKSB7XHJcbiAgICAgICAgICAgICAgICB6b29tRGVsdGEgPSAwLjA3O1xyXG4gICAgICAgICAgICAgICAgdGhpcy56b29tKHpvb21EZWx0YSwgdGhpcy5fenIuZ2V0V2lkdGgoKSAvIDIsIHRoaXMuX3pyLmdldEhlaWdodCgpIC8gMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc05hTih0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuZ3JvdXA7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHpvb21TY2FsZSA9IHR5cGUgLyB0YXJnZXQuc2NhbGVbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fem9vbSA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3dab29tID0gdHlwZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNjYWxlKHRoaXMuX3pyLmdldFdpZHRoKCkgLyAyLCB0aGlzLl96ci5nZXRIZWlnaHQoKSAvIDIsem9vbVNjYWxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3pyLm9uKCdtb3VzZXdoZWVsJywgenJVdGlsLmJpbmQoZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50VG9vbC5zdG9wKGUuZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHpvb21EZWx0YSA9IGUud2hlZWxEZWx0YSA+IDAgPyAwLjA3IDogLTAuMDc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnpvb20oem9vbURlbHRhLCB0aGlzLl96ci5nZXRXaWR0aCgpIC8gMiwgdGhpcy5fenIuZ2V0SGVpZ2h0KCkgLyAyKTtcclxuICAgICAgICAgICAgfSwgdGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLnpvb20gPSBmdW5jdGlvbiAoem9vbURlbHRhLCB6b29tWCwgem9vbVkpIHtcclxuICAgICAgICBpZiAodGhpcy5jYW5TY2FsZSA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmdyb3VwO1xyXG4gICAgICAgIGlmICh0YXJnZXQpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBuZXdab29tID0gdGhpcy5fem9vbSA9IHRoaXMuX3pvb20gfHwgMTtcclxuICAgICAgICAgICAgbmV3Wm9vbSArPSB6b29tRGVsdGE7XHJcblxyXG4gICAgICAgICAgICBuZXdab29tID0gTnVtYmVyKG5ld1pvb20udG9GaXhlZCgyKSk7XHJcbiAgICAgICAgICAgIHZhciB6b29tU2NhbGUgPSBuZXdab29tIC8gdGhpcy5fem9vbTtcclxuICAgICAgICAgICAgaWYgKG5ld1pvb20gPiB0aGlzLm9wdGlvbnMubWF4U2NhbGUgfHwgbmV3Wm9vbSA8IHRoaXMub3B0aW9ucy5taW5TY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3pvb20gPSBuZXdab29tO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ub3dab29tID0gbmV3Wm9vbTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2V0U2NhbGUoem9vbVgsIHpvb21ZLCB6b29tU2NhbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLnNldFNjYWxlID0gZnVuY3Rpb24gKHpvb21YLCB6b29tWSwgem9vbVNjYWxlKSB7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuZ3JvdXA7XHJcbiAgICAgICAgdmFyIHBvcyA9IHRhcmdldC5wb3NpdGlvbjtcclxuICAgICAgICB2YXIgc2NhbGUgPSB0YXJnZXQuc2NhbGU7XHJcbiAgICAgICAgLy8gS2VlcCB0aGUgbW91c2UgY2VudGVyIHdoZW4gc2NhbGluZ1xyXG4gICAgICAgIHBvc1swXSAtPSAoem9vbVggLSBwb3NbMF0pICogKHpvb21TY2FsZSAtIDEpO1xyXG4gICAgICAgIHBvc1sxXSAtPSAoem9vbVkgLSBwb3NbMV0pICogKHpvb21TY2FsZSAtIDEpO1xyXG4gICAgICAgIHNjYWxlWzBdICo9IHpvb21TY2FsZTtcclxuICAgICAgICBzY2FsZVsxXSAqPSB6b29tU2NhbGU7XHJcbiAgICAgICAgdGFyZ2V0LmF0dHIoXCJwb3NpdGlvblwiLCBbcG9zWzBdLCBwb3NbMV1dKTtcclxuICAgICAgICB0YXJnZXQuYXR0cihcInNjYWxlXCIsIFtzY2FsZVswXSwgc2NhbGVbMV1dKTtcclxuICAgICAgICBpZiAodGhpcy5lYWdsZUV5ZSA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWluaW1hcC51cGRhdGFTZWxlY3Rpb24ocG9zWzBdLCBwb3NbMV0sIHpvb21TY2FsZSwgdGhpcy5ub3dab29tKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6bmw55y85Zu+XHJcbiAgICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWFnbGVFeWVOb2RlIOaYvuekuum5sOecvOWbvueahGRpduWFg+e0oFxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLm9wZW5FYWdsZUV5ZSA9IGZ1bmN0aW9uIChlYWdsZUV5ZU5vZGUpIHtcclxuICAgICAgICB0aGlzLmVhZ2xlRXllID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmVhZ2xlRXllTm9kZSA9IGVhZ2xlRXllTm9kZTtcclxuICAgICAgICB2YXIgZ3JvdXBQb3NpdGlvbiA9IHpyVXRpbC5jbG9uZSh0aGlzLmdyb3VwLnBvc2l0aW9uKTtcclxuICAgICAgICB2YXIgZ3JvdXBTY2FsZSA9IHpyVXRpbC5jbG9uZSh0aGlzLmdyb3VwLnNjYWxlKTtcclxuICAgICAgICB0aGlzLmdyb3VwLmF0dHIoXCJwb3NpdGlvblwiLCBbMCwgMF0pO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAuYXR0cihcInNjYWxlXCIsIFsxLCAxXSk7XHJcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gdGhpcy5pbml0U2NhbGUoKTtcclxuICAgICAgICB2YXIgaW1nU3JjID0gdGhpcy50b0RhdGFVUkwoKTtcclxuICAgICAgICB0aGlzLmdyb3VwLmF0dHIoXCJwb3NpdGlvblwiLCBncm91cFBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLmdyb3VwLmF0dHIoXCJzY2FsZVwiLCBncm91cFNjYWxlKTtcclxuICAgICAgICBpZiAodGhpcy5taW5pbWFwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWluaW1hcC51cGRhdGFNYXAoaW1nU3JjLCB0aGlzLmdyb3VwLmdldEJvdW5kaW5nUmVjdCgpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1pbmltYXAgPSBuZXcgTWluaW1hcCh0aGlzLCB0aGlzLmdyb3VwLnBvc2l0aW9uLCB0aGlzLmdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLFxyXG4gICAgICAgICAgICAgICAgZWFnbGVFeWVOb2RlLCBkaXN0YW5jZSwgaW1nU3JjKTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCh6clV0aWwuYmluZChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5FYWdsZUV5ZSh0aGlzLmVhZ2xlRXllTm9kZSlcclxuICAgICAgICAgICAgfSwgdGhpcyksIDEwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5taW5pbWFwLnNlbGVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFydFggPSBlLmNsaWVudFg7XHJcbiAgICAgICAgICAgIHZhciBzdGFydFkgPSBlLmNsaWVudFk7XHJcbiAgICAgICAgICAgIHZhciBtaW5pbWFwTGVmdCA9IE51bWJlcih0aGlzLm1pbmltYXAuc2VsZWN0aW9uLnN0eWxlLmxlZnQuc3Vic3RyaW5nKDAsIHRoaXMubWluaW1hcC5zZWxlY3Rpb25cclxuICAgICAgICAgICAgICAgIC5zdHlsZS5sZWZ0Lmxlbmd0aCAtIDIpKTtcclxuICAgICAgICAgICAgdmFyIG1pbmltYXBUb3AgPSBOdW1iZXIodGhpcy5taW5pbWFwLnNlbGVjdGlvbi5zdHlsZS50b3Auc3Vic3RyaW5nKDAsIHRoaXMubWluaW1hcC5zZWxlY3Rpb25cclxuICAgICAgICAgICAgICAgIC5zdHlsZS50b3AubGVuZ3RoIC0gMikpO1xyXG4gICAgICAgICAgICB2YXIgZWFnbGVFeWVNb3ZlID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRYID0gZS5jbGllbnRYIC0gc3RhcnRYO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFkgPSBlLmNsaWVudFkgLSBzdGFydFk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pbmltYXAuc2VsZWN0aW9uLnN0eWxlLmxlZnQgPSBtaW5pbWFwTGVmdCArIG9mZnNldFggKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pbmltYXAuc2VsZWN0aW9uLnN0eWxlLnRvcCA9IG1pbmltYXBUb3AgKyBvZmZzZXRZICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5taW5pbWFwLnVwZGF0YUdyb3VwUG9zaXRpb24odGhpcy5ncm91cCwgdGhpcy5ub3dab29tKTtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5taW5pbWFwLnNlbGVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGVhZ2xlRXllTW92ZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZWFnbGVFeWVVcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWluaW1hcC5zZWxlY3Rpb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBlYWdsZUV5ZU1vdmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5taW5pbWFwLnNlbGVjdGlvbi5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBlYWdsZUV5ZVVwKTtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLm1pbmltYXAuc2VsZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGVhZ2xlRXllVXApO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja7oioLngrnkvY3nva7lj5jljJbmm7TmlrDnu4TovrnmoYbnmoTlpKflsI9cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIOiKgueCuVxyXG4gICAgICogQHNpbmNlIFYyLjMuMFxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLnJlZnJlc2hHcm91cEJ5Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7Ly8jMTgxXHJcbiAgICAgICAgaWYgKEZsb3cuaXNJbkdyb3VwKG5vZGUpKSB7XHJcbiAgICAgICAgICAgIC8v5pS+5YWlbm9kZeeOsOacieaVsOWAvO+8jOeUqOS6jumHjee7mGdyb3VwXHJcbiAgICAgICAgICAgIHZhciBub2RlTWVzc2FnZSA9IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBub2RlLnNoYXBlLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBub2RlLnNoYXBlLmhlaWdodCxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBub2RlLnBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgaXNNb3ZlOiAwLFxyXG4gICAgICAgICAgICAgICAgbm9kZTogbm9kZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBub2RlLnBhcmVudC5tb2RpZnlHcm91cFJlY3Qobm9kZU1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlZnJlc2hMaW5lQnlOb2RlKG5vZGUpO1xyXG4gICAgICAgIGlmIChGbG93LmlzR3JvdXBOb2RlKG5vZGUpKSB7XHJcbiAgICAgICAgICAgIG5vZGUuZWFjaChmdW5jdGlvbiAoY2hpbGROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlZnJlc2hMaW5lQnlOb2RlKGNoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB6clV0aWwubWl4aW4oRmlzaFRvcG9GbG93LCBFdmVudGZ1bCk7XHJcblxyXG4gICAgLy8gLS0tLS0tLS0t5a+55aSW5pq06ZyyZmlzaFRvcG9GbG93LS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICB2YXIgaWRCYXNlID0gbmV3IERhdGUoKSAtIDA7XHJcbiAgICB2YXIgaW5zdGFuY2VzID0ge307XHJcbiAgICB2YXIgRE9NX0FUVFJJQlVURV9LRVkgPSAnX2Zpc2hUb3BvRmxvd19pbnN0YW5jZV8nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZmlzaFRvcG9GbG935YWo5bGA5a+56LGh77yM5aaC5p6c5pivYW1k5pa55byP5Yqg6L2977yM5YiZ55u05o6l6L+U5ZueXHJcbiAgICAgKiBAY2xhc3MgZmlzaFRvcG9GbG93XHJcbiAgICAgKiBAc2luZ2xldG9uXHJcbiAgICAgKlxyXG4gICAgICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICpcclxuICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAqICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gICAgICovXHJcbiAgICB2YXIgZmlzaFRvcG9GbG93ID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOeJiOacrOWPt1xyXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmVyc2lvbjogJzMuMC4wJyxcclxuICAgICAgICBkZXBlbmRlbmNpZXM6IHtcclxuICAgICAgICAgICAgenJlbmRlcjogJzMuNi4zJ1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJ3lp4vljJZkb23lhYPntKDkuLogZmxvd+WvueixoVxyXG4gICAgICogQG1lbWJlciBmaXNoVG9wb0Zsb3dcclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbSAg5LiA5LiqZGl25YWD57SgXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAg5Lyg6YCS55qE6YCJ6aG55Y+C5pWwXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXI9J2NhbnZhcyddICdjYW52YXMnIG9yICdzdmcnIG9yICd2bWwnXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuZGV2aWNlUGl4ZWxSYXRpbz0xXSByZXRpbmEg5bGP5bmV5LyY5YyWXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmxpbmtNb2RpZnk9ZmFsc2VdIOaYr+WQpuWFgeiuuOiwg+aVtOe6v+autVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy50ZXh0RWRpdGFibGU9ZmFsc2VdIOaYr+WQpuWFgeiuuOWPjOWHu+iKgueCuee8lui+keaWh+Wtl1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5tb3VzZU1vZGU9J2RlZmF1bHQnXSDorr7nva7pvKDmoIflnKjnlLvluIPkuIrnmoTmk43kvZzmqKHlvI/vvIzpu5jorqTkuLonZGVmYXVsdCfvvJrml6Dku7vkvZXmk43kvZzvvIzorr7kuLonZHJhZy1tb3ZlJ++8muW5s+enu+a8q+a4uO+8jOiuvuS4uidkcmFnLXNlbGVjdCfvvJrmoYbpgInoioLngrlcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMucm9hbT10cnVlXSDmmK/lkKblvIDlkK/pvKDmoIfnvKnmlL7jgILpu5jorqTlvIDlkK/vvIzorr7kuLpmYWxzZeihqOekuuWFs+mXree8qeaUvuWKn+iDveOAglxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLnRvb2x0aXBdIHRvb2x0aXDphY3nva7poblcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMudG9vbHRpcC5zaG93XSB0b29sdGlw6YWN572u6aG5OuaOp+WItnRvb2x0aXDmmK/lkKbmmL7npLpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaXNBbmltYXRpb25FbmFibGVkPXRydWVdIOaYr+WQpuW8gOWQr+WKqOeUuyzpu5jorqTkuLp0cnVlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNjYWxlYWJsZT1mYWxzZV0g5piv5ZCm5YWB6K6457yp5pS+LOm7mOiupOS4umZhbHNlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnJvdGF0YWJsZT1mYWxzZV0g5piv5ZCm5YWB6K645peL6L2sLOm7mOiupOS4umZhbHNlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5iZWZvcmVEZWxldGVdIOWIoOmZpOiKgueCueaIlui+uee6vyDkuYvliY3nmoTlm57osIPvvIzlpoLmnpzov5Tlm55mYWxzZeWImeS4jei/m+ihjOWQjue7reeahOWIoOmZpOaTjeS9nFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLmJlZm9yZUNyZWF0ZV0g5Yib5bu66IqC54K55oiW6L6557q/IOS5i+WJjeeahOWbnuiwg++8jOWmguaenOi/lOWbnmZhbHNl5YiZ5LiN6L+b6KGM5ZCO57ut55qE5Yig6Zmk5pON5L2cXHJcbiAgICAgKiBAcmV0dXJuIHtmaXNoLnRvcG8uRmlzaFRvcG9GbG93fVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb0Zsb3cuaW5pdCA9IGZ1bmN0aW9uIChkb20sIG9wdHMpIHtcclxuICAgICAgICBpZiAoIWRvbSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luaXRpYWxpemUgZmFpbGVkOiBpbnZhbGlkIGRvbS4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xyXG4gICAgICAgIC8vIERlZmF1bHQgdmFsdWVcclxuICAgICAgICB6clV0aWwuZGVmYXVsdHMob3B0cywge1xyXG4gICAgICAgICAgICB0eXBlOiBcImZsb3dcIixcclxuICAgICAgICAgICAgbGlua01vZGlmeTogZmFsc2UsXHJcbiAgICAgICAgICAgIHRleHRFZGl0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHJvYW06IHRydWUsXHJcbiAgICAgICAgICAgIG1vdXNlTW9kZTogJ2RlZmF1bHQnLFxyXG4gICAgICAgICAgICB0b29sdGlwOiB7XHJcbiAgICAgICAgICAgICAgICBzaG93OnRydWVcclxuICAgICAgICAgICAgfSwgIC8v6KaG55uWdG9vbHRpcE1vZGVsXHJcbiAgICAgICAgICAgIGlzQW5pbWF0aW9uRW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICAgICAgc2NhbGVhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgcm90YXRhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgYmVmb3JlRGVsZXRlOiBudWxsLCAgLy8g5Yig6Zmk5LmL5YmN55qE5LqL5Lu2XHJcbiAgICAgICAgICAgIGJlZm9yZUNyZWF0ZTpudWxsLCAgIC8v5Yib5bu66IqC54K55oiW6L+e57q/5LmL5YmN55qE5LqL5Lu2XHJcbiAgICAgICAgICAgIG1heFNjYWxlOiAxLjcsICAgICAgIC8v55S75biD5pS+5aSn55qE5pyA5aSn5q+U5L6LXHJcbiAgICAgICAgICAgIG1pblNjYWxlOiAwLjMgICAgICAgIC8v55S75biD57yp5bCP55qE5pyA5bCP5q+U5L6LXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciBmaXNoVG9wb0Zsb3cgPSBuZXcgRmlzaFRvcG9GbG93KGRvbSwgb3B0cyk7XHJcbiAgICAgICAgZmlzaFRvcG9GbG93LmluaXQoKTtcclxuICAgICAgICBmaXNoVG9wb0Zsb3cuRmxvdyA9IEZsb3c7XHJcbiAgICAgICAgZmlzaFRvcG9GbG93LmlkID0gJ2Z0XycgKyBpZEJhc2UrKztcclxuICAgICAgICBpbnN0YW5jZXNbZmlzaFRvcG9GbG93LmlkXSA9IGZpc2hUb3BvRmxvdztcclxuXHJcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZSAmJiBkb20uc2V0QXR0cmlidXRlKERPTV9BVFRSSUJVVEVfS0VZLCBmaXNoVG9wb0Zsb3cuaWQpO1xyXG5cclxuICAgICAgICByZXR1cm4gZmlzaFRvcG9GbG93O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5YgZG9tIOWuueWZqOS4iueahOWunuS+i+OAglxyXG4gICAgICogQG1lbWJlciBmaXNoVG9wb0Zsb3dcclxuICAgICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBkb20g5LiA5LiqZGl25YWD57SgXHJcbiAgICAgKiBAcmV0dXJuIHtmaXNoLnRvcG8uRmlzaFRvcG9GbG93fVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb0Zsb3cuZ2V0SW5zdGFuY2VCeURvbSA9IGZ1bmN0aW9uIChkb20pIHtcclxuICAgICAgICB2YXIga2V5ID0gZG9tLmdldEF0dHJpYnV0ZShET01fQVRUUklCVVRFX0tFWSk7XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlc1trZXldO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOmUgOavgeWunuS+i++8jOWunuS+i+mUgOavgeWQjuaXoOazleWGjeiiq+S9v+eUqOOAglxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIgZmlzaFRvcG9GbG93XHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R8c3RyaW5nfSBjaGFydCBmaXNoVG9wb0JwbW7lrp7kvosg5oiWIGZpc2hUb3BvQnBtbueahGlkXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvRmxvdy5kaXNwb3NlID0gZnVuY3Rpb24gKGNoYXJ0KSB7XHJcbiAgICAgICAgdmFyIHRvcG87XHJcbiAgICAgICAgaWYgKHpyVXRpbC5pc0RvbShjaGFydCkpIHtcclxuICAgICAgICAgICAgdG9wbyA9IGZpc2hUb3BvRmxvdy5nZXRJbnN0YW5jZUJ5RG9tKGNoYXJ0KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjaGFydCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdG9wbyA9IGluc3RhbmNlc1tjaGFydF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgodG9wbyBpbnN0YW5jZW9mIGZpc2hUb3BvRmxvdykgJiYgIXRvcG8uaXNEaXNwb3NlZCgpKSB7XHJcbiAgICAgICAgICAgIHRvcG8uZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy/mmrTpnLLlh7rljrvnmoTnsbtcclxuICAgIGZpc2hUb3BvRmxvdy5ncmFwaGljID0gZ3JhcGhpYztcclxuICAgIGZpc2hUb3BvRmxvdy5ub2RlID0gRmxvd1V0aWwucmVnaXN0ZXJGbG93Tm9kZShmbG93Tm9kZSk7XHJcbiAgICBmaXNoVG9wb0Zsb3cubGluayA9IGZsb3dMaW5rO1xyXG5cclxuICAgIGZpc2hUb3BvRmxvdy5sYXlvdXQgPSBsYXlvdXQ7XHJcbiAgICBmaXNoVG9wb0Zsb3cuRmxvdyA9IEZsb3c7XHJcbiAgICBmaXNoVG9wb0Zsb3cuY29uc3RhbnRzID0gQ29uc3RhbnRzO1xyXG4gICAgZmlzaFRvcG9GbG93LnV0aWwgPSB1dGlsO1xyXG4gICAgZmlzaFRvcG9GbG93LnV0aWxbJ2luaXRJbWFnZVBvb2wnXSA9IEltYWdlUG9vbC5pbml0SW1hZ2VQb29sO1xyXG4gICAgenJVdGlsLmVhY2goW1xyXG4gICAgICAgICAgICAnbWFwJywgJ2VhY2gnLCAnZmlsdGVyJywgJ2luZGV4T2YnLCAnaW5oZXJpdHMnLFxyXG4gICAgICAgICAgICAncmVkdWNlJywgJ2ZpbHRlcicsICdiaW5kJywgJ2N1cnJ5JywgJ2lzQXJyYXknLFxyXG4gICAgICAgICAgICAnaXNTdHJpbmcnLCAnaXNPYmplY3QnLCAnaXNGdW5jdGlvbicsICdleHRlbmQnLFxyXG4gICAgICAgICAgICAnbWVyZ2UnLCBcIm1lcmdlQWxsXCJcclxuICAgICAgICBdLFxyXG4gICAgICAgIGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIGZpc2hUb3BvRmxvdy51dGlsW25hbWVdID0genJVdGlsW25hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmaXNoVG9wb0Zsb3c7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9GaXNoVG9wb0Zsb3cuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbiAgICAvL3BvbHlmaWxsIGJpbmRcclxuICAgIGlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcclxuICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKG9UaGlzKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjbG9zZXN0IHRoaW5nIHBvc3NpYmxlIHRvIHRoZSBFQ01BU2NyaXB0IDUgaW50ZXJuYWwgSXNDYWxsYWJsZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgYUFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxyXG4gICAgICAgICAgICAgICAgZlRvQmluZCA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBmTk9QID0gZnVuY3Rpb24oKSB7fSxcclxuICAgICAgICAgICAgICAgIGZCb3VuZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmVG9CaW5kLmFwcGx5KHRoaXMgaW5zdGFuY2VvZiBmTk9QICYmIG9UaGlzID8gdGhpcyA6IG9UaGlzIHx8IHdpbmRvdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYUFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBmTk9QLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xyXG4gICAgICAgICAgICBmQm91bmQucHJvdG90eXBlID0gbmV3IGZOT1AoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmQm91bmQ7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvL3BvbHlmaWxsIHJlbW92ZVxyXG4gICAgaWYgKCEoJ3JlbW92ZScgaW4gRWxlbWVudC5wcm90b3R5cGUpKSB7XHJcbiAgICAgICAgRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKSB7XHJcbiAgICBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoID0gZnVuY3Rpb24oc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xyXG4gICAgICAgIHZhciBzdWJqZWN0U3RyaW5nID0gdGhpcy50b1N0cmluZygpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgcG9zaXRpb24gIT09ICdudW1iZXInIHx8ICFpc0Zpbml0ZShwb3NpdGlvbikgfHwgTWF0aC5mbG9vcihwb3NpdGlvbikgIT09IHBvc2l0aW9uIHx8IHBvc2l0aW9uID4gc3ViamVjdFN0cmluZy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcG9zaXRpb24gPSBzdWJqZWN0U3RyaW5nLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcG9zaXRpb24gLT0gc2VhcmNoU3RyaW5nLmxlbmd0aDtcclxuICAgICAgICB2YXIgbGFzdEluZGV4ID0gc3ViamVjdFN0cmluZy5pbmRleE9mKHNlYXJjaFN0cmluZywgcG9zaXRpb24pO1xyXG4gICAgICAgIHJldHVybiBsYXN0SW5kZXggIT09IC0xICYmIGxhc3RJbmRleCA9PT0gcG9zaXRpb247XHJcbiAgICB9O1xyXG4gICAgfVxyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3BvbHlmaWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxyXG5cclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuXHJcbiAgICB2YXIgcGF0aFRvb2wgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi90b29sL3BhdGgnKTtcclxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XHJcbiAgICB2YXIgUGF0aCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aCcpO1xyXG4gICAgdmFyIGNvbG9yVG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3Rvb2wvY29sb3InKTtcclxuICAgIHZhciBtYXRyaXggPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL21hdHJpeCcpO1xyXG4gICAgdmFyIHZlY3RvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yJyk7XHJcbiAgICB2YXIgR3JhZGllbnQgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL0dyYWRpZW50Jyk7XHJcbiAgICB2YXIgRHJhZ2dhYmxlID0gcmVxdWlyZSgnenJlbmRlci9saWIvbWl4aW4vRHJhZ2dhYmxlJyk7XHJcblxyXG4gICAgdmFyIGdyYXBoaWMgPSB7fTtcclxuICAgIGdyYXBoaWMuVXRpbCA9IHpyVXRpbDtcclxuICAgIGdyYXBoaWMuR3JvdXAgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXAnKTtcclxuXHJcbiAgICBncmFwaGljLkltYWdlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9JbWFnZScpO1xyXG5cclxuICAgIGdyYXBoaWMuVGV4dCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvVGV4dCcpO1xyXG5cclxuICAgIGdyYXBoaWMudGV4dENvbnRhaW4gPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb250YWluL3RleHQnKTtcclxuXHJcbiAgICBncmFwaGljLkNpcmNsZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQ2lyY2xlJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5TZWN0b3IgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1NlY3RvcicpO1xyXG5cclxuICAgIGdyYXBoaWMuUmluZyA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmluZycpO1xyXG5cclxuICAgIGdyYXBoaWMuUG9seWdvbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWdvbicpO1xyXG5cclxuICAgIGdyYXBoaWMuUG9seWxpbmUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlsaW5lJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5SZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SZWN0Jyk7XHJcblxyXG4gICAgZ3JhcGhpYy5MaW5lID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9MaW5lJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5CZXppZXJDdXJ2ZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmUnKTtcclxuXHJcbiAgICBncmFwaGljLkFyYyA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQXJjJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5MaW5lYXJHcmFkaWVudCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQnKTtcclxuXHJcbiAgICBncmFwaGljLlJhZGlhbEdyYWRpZW50ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9SYWRpYWxHcmFkaWVudCcpO1xyXG5cclxuICAgIGdyYXBoaWMuQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QnKTtcclxuICAgIGdyYXBoaWMuU3RhdGVzID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvU3RhdGVzLmpzXCIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRlbmQgc2hhcGUgd2l0aCBwYXJhbWV0ZXJzXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuZXh0ZW5kU2hhcGUgPSBmdW5jdGlvbiAob3B0cykge1xyXG4gICAgICAgIHJldHVybiBQYXRoLmV4dGVuZChvcHRzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRlbmQgcGF0aFxyXG4gICAgICovXHJcbiAgICBncmFwaGljLmV4dGVuZFBhdGggPSBmdW5jdGlvbiAocGF0aERhdGEsIG9wdHMpIHtcclxuICAgICAgICByZXR1cm4gcGF0aFRvb2wuZXh0ZW5kRnJvbVN0cmluZyhwYXRoRGF0YSwgb3B0cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgcGF0aCBlbGVtZW50IGZyb20gcGF0aCBkYXRhIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhEYXRhXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH0gcmVjdFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYXlvdXQ9Y292ZXJdICdjZW50ZXInIG9yICdjb3ZlcidcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5tYWtlUGF0aCA9IGZ1bmN0aW9uIChwYXRoRGF0YSwgb3B0cywgcmVjdCwgbGF5b3V0KSB7XHJcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoVG9vbC5jcmVhdGVGcm9tU3RyaW5nKHBhdGhEYXRhLCBvcHRzKTtcclxuICAgICAgICBEcmFnZ2FibGUuY2FsbChwYXRoKTtcclxuICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICBpZiAocmVjdCkge1xyXG4gICAgICAgICAgICB2YXIgYXNwZWN0ID0gYm91bmRpbmdSZWN0LndpZHRoIC8gYm91bmRpbmdSZWN0LmhlaWdodDtcclxuXHJcbiAgICAgICAgICAgIGlmIChsYXlvdXQgPT09ICdjZW50ZXInKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgcmVjdCB0byBjZW50ZXIsIGtlZXAgd2lkdGggLyBoZWlnaHQgcmF0aW8uXHJcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSByZWN0LmhlaWdodCAqIGFzcGVjdDtcclxuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAod2lkdGggPD0gcmVjdC53aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGN4ID0gcmVjdC54ICsgcmVjdC53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3kgPSByZWN0LnkgKyByZWN0LmhlaWdodCAvIDI7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVjdC54ID0gY3ggLSB3aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICByZWN0LnkgPSBjeSAtIGhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgICAgICByZWN0LndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICAgICAgICByZWN0LmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5yZXNpemVQYXRoKHBhdGgsIHJlY3QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgenJVdGlsLmluaGVyaXRzKHBhdGgsIERyYWdnYWJsZSk7XHJcbiAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICB9O1xyXG5cclxuICAgIGdyYXBoaWMubWVyZ2VQYXRoID0gcGF0aFRvb2wubWVyZ2VQYXRoO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzaXplIGEgcGF0aCB0byBmaXQgdGhlIHJlY3RcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRofSBwYXRoXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdFxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnJlc2l6ZVBhdGggPSBmdW5jdGlvbiAocGF0aCwgcmVjdCkge1xyXG4gICAgICAgIGlmICghcGF0aC5hcHBseVRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcGF0aFJlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xyXG5cclxuICAgICAgICB2YXIgbSA9IHBhdGhSZWN0LmNhbGN1bGF0ZVRyYW5zZm9ybShyZWN0KTtcclxuXHJcbiAgICAgICAgcGF0aC5hcHBseVRyYW5zZm9ybShtKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWIgcGl4ZWwgb3B0aW1pemUgbGluZSBmb3IgY2FudmFzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnNoYXBlXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS54MV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueTFdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLngyXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS55Ml1cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc3R5bGVdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnN0eWxlLmxpbmVXaWR0aF1cclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gTW9kaWZpZWQgcGFyYW1cclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplTGluZSA9IGZ1bmN0aW9uIChwYXJhbSkge1xyXG4gICAgICAgIHZhciBzdWJQaXhlbE9wdGltaXplID0gZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplO1xyXG4gICAgICAgIHZhciBzaGFwZSA9IHBhcmFtLnNoYXBlO1xyXG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBwYXJhbS5zdHlsZS5saW5lV2lkdGg7XHJcblxyXG4gICAgICAgIGlmIChyb3VuZChzaGFwZS54MSAqIDIpID09PSByb3VuZChzaGFwZS54MiAqIDIpKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLngxID0gc2hhcGUueDIgPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLngxLCBsaW5lV2lkdGgsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocm91bmQoc2hhcGUueTEgKiAyKSA9PT0gcm91bmQoc2hhcGUueTIgKiAyKSkge1xyXG4gICAgICAgICAgICBzaGFwZS55MSA9IHNoYXBlLnkyID0gc3ViUGl4ZWxPcHRpbWl6ZShzaGFwZS55MSwgbGluZVdpZHRoLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YiBwaXhlbCBvcHRpbWl6ZSByZWN0IGZvciBjYW52YXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc2hhcGVdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnhdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnldXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLndpZHRoXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS5oZWlnaHRdXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnN0eWxlXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zdHlsZS5saW5lV2lkdGhdXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE1vZGlmaWVkIHBhcmFtXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZVJlY3QgPSBmdW5jdGlvbiAocGFyYW0pIHtcclxuICAgICAgICB2YXIgc3ViUGl4ZWxPcHRpbWl6ZSA9IGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZTtcclxuICAgICAgICB2YXIgc2hhcGUgPSBwYXJhbS5zaGFwZTtcclxuICAgICAgICB2YXIgbGluZVdpZHRoID0gcGFyYW0uc3R5bGUubGluZVdpZHRoO1xyXG4gICAgICAgIHZhciBvcmlnaW5YID0gc2hhcGUueDtcclxuICAgICAgICB2YXIgb3JpZ2luWSA9IHNoYXBlLnk7XHJcbiAgICAgICAgdmFyIG9yaWdpbldpZHRoID0gc2hhcGUud2lkdGg7XHJcbiAgICAgICAgdmFyIG9yaWdpbkhlaWdodCA9IHNoYXBlLmhlaWdodDtcclxuICAgICAgICBzaGFwZS54ID0gc3ViUGl4ZWxPcHRpbWl6ZShzaGFwZS54LCBsaW5lV2lkdGgsIHRydWUpO1xyXG4gICAgICAgIHNoYXBlLnkgPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLnksIGxpbmVXaWR0aCwgdHJ1ZSk7XHJcbiAgICAgICAgc2hhcGUud2lkdGggPSBNYXRoLm1heChcclxuICAgICAgICAgICAgc3ViUGl4ZWxPcHRpbWl6ZShvcmlnaW5YICsgb3JpZ2luV2lkdGgsIGxpbmVXaWR0aCwgZmFsc2UpIC0gc2hhcGUueCxcclxuICAgICAgICAgICAgb3JpZ2luV2lkdGggPT09IDAgPyAwIDogMVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgc2hhcGUuaGVpZ2h0ID0gTWF0aC5tYXgoXHJcbiAgICAgICAgICAgIHN1YlBpeGVsT3B0aW1pemUob3JpZ2luWSArIG9yaWdpbkhlaWdodCwgbGluZVdpZHRoLCBmYWxzZSkgLSBzaGFwZS55LFxyXG4gICAgICAgICAgICBvcmlnaW5IZWlnaHQgPT09IDAgPyAwIDogMVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YiBwaXhlbCBvcHRpbWl6ZSBmb3IgY2FudmFzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIENvb3JkaW5hdGUsIHN1Y2ggYXMgeCwgeVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVXaWR0aCBTaG91bGQgYmUgbm9ubmVnYXRpdmUgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHBvc2l0aXZlT3JOZWdhdGl2ZSBEZWZhdWx0IGZhbHNlIChuZWdhdGl2ZSkuXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE9wdGltaXplZCBwb3NpdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBsaW5lV2lkdGgsIHBvc2l0aXZlT3JOZWdhdGl2ZSkge1xyXG4gICAgICAgIC8vIEFzc3VyZSB0aGF0IChwb3NpdGlvbiArIGxpbmVXaWR0aCAvIDIpIGlzIG5lYXIgaW50ZWdlciBlZGdlLFxyXG4gICAgICAgIC8vIG90aGVyd2lzZSBsaW5lIHdpbGwgYmUgZnV6enkgaW4gY2FudmFzLlxyXG4gICAgICAgIHZhciBkb3VibGVkUG9zaXRpb24gPSByb3VuZChwb3NpdGlvbiAqIDIpO1xyXG4gICAgICAgIHJldHVybiAoZG91YmxlZFBvc2l0aW9uICsgcm91bmQobGluZVdpZHRoKSkgJSAyID09PSAwXHJcbiAgICAgICAgICAgID8gZG91YmxlZFBvc2l0aW9uIC8gMlxyXG4gICAgICAgICAgICA6IChkb3VibGVkUG9zaXRpb24gKyAocG9zaXRpdmVPck5lZ2F0aXZlID8gMSA6IC0xKSkgLyAyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGRvU2luZ2xlRW50ZXJIb3ZlcihlbCkge1xyXG4gICAgICAgIGlmIChlbC5fX2lzSG92ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWwuX19ob3ZlclN0bERpcnR5KSB7XHJcbiAgICAgICAgICAgIHZhciBzdHJva2UgPSBlbC5zdHlsZS5zdHJva2U7XHJcbiAgICAgICAgICAgIHZhciBmaWxsID0gZWwuc3R5bGUuZmlsbDtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBob3ZlclN0eWxlIG9uIG1vdXNlb3ZlclxyXG4gICAgICAgICAgICB2YXIgaG92ZXJTdHlsZSA9IGVsLl9faG92ZXJTdGw7XHJcbiAgICAgICAgICAgIHZhciBsaWZ0ID0gY29sb3JUb29sLmxpZnQ7XHJcbiAgICAgICAgICAgIGhvdmVyU3R5bGUuZmlsbCA9IGhvdmVyU3R5bGUuZmlsbFxyXG4gICAgICAgICAgICAgICAgfHwgKGZpbGwgJiYgKGZpbGwgaW5zdGFuY2VvZiBHcmFkaWVudCA/IGZpbGwgOiBsaWZ0KGZpbGwsIC0wLjEpKSk7XHJcbiAgICAgICAgICAgIGhvdmVyU3R5bGUuc3Ryb2tlID0gaG92ZXJTdHlsZS5zdHJva2VcclxuICAgICAgICAgICAgICAgIHx8IChzdHJva2UgJiYgKHN0cm9rZSBpbnN0YW5jZW9mIEdyYWRpZW50ID8gc3Ryb2tlIDogbGlmdChzdHJva2UsIC0wLjEpKSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbm9ybWFsU3R5bGUgPSB7fTtcclxuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBob3ZlclN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaG92ZXJTdHlsZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbFN0eWxlW25hbWVdID0gZWwuc3R5bGVbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGVsLl9fbm9ybWFsU3RsID0gbm9ybWFsU3R5bGU7XHJcblxyXG4gICAgICAgICAgICBlbC5fX2hvdmVyU3RsRGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWwuc2V0U3R5bGUoZWwuX19ob3ZlclN0bCk7XHJcbiAgICAgICAgZWwuejIgKz0gMTtcclxuXHJcbiAgICAgICAgZWwuX19pc0hvdmVyID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkb1NpbmdsZUxlYXZlSG92ZXIoZWwpIHtcclxuICAgICAgICBpZiAoIWVsLl9faXNIb3Zlcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbm9ybWFsU3RsID0gZWwuX19ub3JtYWxTdGw7XHJcbiAgICAgICAgbm9ybWFsU3RsICYmIGVsLnNldFN0eWxlKG5vcm1hbFN0bCk7XHJcbiAgICAgICAgZWwuejIgLT0gMTtcclxuXHJcbiAgICAgICAgZWwuX19pc0hvdmVyID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZG9FbnRlckhvdmVyKGVsKSB7XHJcbiAgICAgICAgKGVsLnR5cGUgPT09ICdncm91cCcgfHwgZWwudHlwZSA9PT0gJ0dyb3VwTm9kZScpXHJcbiAgICAgICAgICAgID8gZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvU2luZ2xlRW50ZXJIb3ZlcihjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIDogZG9TaW5nbGVFbnRlckhvdmVyKGVsKTtcclxuICAgIH1cclxuICAgIGdyYXBoaWMuZG9FbnRlckhvdmVyID0gZG9FbnRlckhvdmVyO1xyXG4gICAgZnVuY3Rpb24gZG9MZWF2ZUhvdmVyKGVsKSB7XHJcbiAgICAgICAgZWwudHlwZSA9PT0gJ2dyb3VwJ1xyXG4gICAgICAgICAgICA/IGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09ICdncm91cCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb1NpbmdsZUxlYXZlSG92ZXIoY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICA6IGRvU2luZ2xlTGVhdmVIb3ZlcihlbCk7XHJcbiAgICB9XHJcbiAgICBncmFwaGljLmRvTGVhdmVIb3ZlciA9IGRvTGVhdmVIb3ZlcjtcclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHNldEVsZW1lbnRIb3ZlclN0bChlbCwgaG92ZXJTdGwpIHtcclxuICAgICAgICAvLyBJZiBlbGVtZW50IGhhcyBzZXBjaWZpZWQgaG92ZXJTdHlsZSwgdGhlbiB1c2UgaXQgaW5zdGVhZCBvZiBnaXZlbiBob3ZlclN0eWxlXHJcbiAgICAgICAgLy8gT2Z0ZW4gdXNlZCB3aGVuIGl0ZW0gZ3JvdXAgaGFzIGEgbGFiZWwgZWxlbWVudCBhbmQgaXQncyBob3ZlclN0eWxlIGlzIGRpZmZlcmVudFxyXG4gICAgICAgIGVsLl9faG92ZXJTdGwgPSBlbC5ob3ZlclN0eWxlIHx8IGhvdmVyU3RsIHx8IHt9O1xyXG4gICAgICAgIGVsLl9faG92ZXJTdGxEaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBncmFwaGljLnNldEVsZW1lbnRIb3ZlclN0bCA9IHNldEVsZW1lbnRIb3ZlclN0bDtcclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG9uRWxlbWVudE1vdXNlT3ZlcigpIHtcclxuICAgICAgICAvLyBPbmx5IGlmIGVsZW1lbnQgaXMgbm90IGluIGVtcGhhc2lzIHN0YXR1c1xyXG4gICAgICAgICF0aGlzLl9faXNFbXBoYXNpcyAmJiBkb0VudGVySG92ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25FbGVtZW50TW91c2VPdXQoKSB7XHJcbiAgICAgICAgLy8gT25seSBpZiBlbGVtZW50IGlzIG5vdCBpbiBlbXBoYXNpcyBzdGF0dXNcclxuICAgICAgICAhdGhpcy5fX2lzRW1waGFzaXMgJiYgZG9MZWF2ZUhvdmVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGVudGVyRW1waGFzaXMoKSB7XHJcbiAgICAgICAgdGhpcy5fX2lzRW1waGFzaXMgPSB0cnVlO1xyXG4gICAgICAgIGRvRW50ZXJIb3Zlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBsZWF2ZUVtcGhhc2lzKCkge1xyXG4gICAgICAgIHRoaXMuX19pc0VtcGhhc2lzID0gZmFsc2U7XHJcbiAgICAgICAgZG9MZWF2ZUhvdmVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGhvdmVyIHN0eWxlIG9mIGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbaG92ZXJTdHlsZV1cclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5zZXRIb3ZlclN0eWxlID0gZnVuY3Rpb24gKGVsLCBob3ZlclN0eWxlKSB7XHJcbiAgICAgICAgZWwudHlwZSA9PT0gJ2dyb3VwJ1xyXG4gICAgICAgICAgICA/IGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09ICdncm91cCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50SG92ZXJTdGwoY2hpbGQsIGhvdmVyU3R5bGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICA6IHNldEVsZW1lbnRIb3ZlclN0bChlbCwgaG92ZXJTdHlsZSk7XHJcbiAgICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIGJvdW5kIGhhbmRsZXJzXHJcbiAgICAgICAgZWwub24oJ21vdXNlb3ZlcicsIG9uRWxlbWVudE1vdXNlT3ZlcilcclxuICAgICAgICAgIC5vbignbW91c2VvdXQnLCBvbkVsZW1lbnRNb3VzZU91dCk7XHJcblxyXG4gICAgICAgIC8vIEVtcGhhc2lzLCBub3JtYWwgY2FuIGJlIHRyaWdnZXJlZCBtYW51YWxseVxyXG4gICAgICAgIGVsLm9uKCdlbXBoYXNpcycsIGVudGVyRW1waGFzaXMpXHJcbiAgICAgICAgICAub24oJ25vcm1hbCcsIGxlYXZlRW1waGFzaXMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBncmFwaGljLnNldE5vcm1hbFN0eWxlID0gZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoZWwuX19ub3JtYWxTdGwpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwuX19ub3JtYWxTdGwuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5fX25vcm1hbFN0bFtuYW1lXSA9IG9wdGlvbnNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRleHQgb3B0aW9uIGluIHRoZSBzdHlsZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRleHRTdHlsZVxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gbGFiZWxNb2RlbFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuc2V0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0U3R5bGUsIGxhYmVsTW9kZWwsIGNvbG9yKSB7XHJcbiAgICAgICAgdmFyIGxhYmVsUG9zaXRpb24gPSBsYWJlbE1vZGVsLmdldFNoYWxsb3coJ3Bvc2l0aW9uJykgfHwgJ2luc2lkZSc7XHJcbiAgICAgICAgdmFyIGxhYmVsQ29sb3IgPSBsYWJlbFBvc2l0aW9uLmluZGV4T2YoJ2luc2lkZScpID49IDAgPyAnd2hpdGUnIDogY29sb3I7XHJcbiAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gbGFiZWxNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XHJcbiAgICAgICAgenJVdGlsLmV4dGVuZCh0ZXh0U3R5bGUsIHtcclxuICAgICAgICAgICAgdGV4dERpc3RhbmNlOiBsYWJlbE1vZGVsLmdldFNoYWxsb3coJ2Rpc3RhbmNlJykgfHwgNSxcclxuICAgICAgICAgICAgdGV4dEZvbnQ6IHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKSxcclxuICAgICAgICAgICAgdGV4dFBvc2l0aW9uOiBsYWJlbFBvc2l0aW9uLFxyXG4gICAgICAgICAgICB0ZXh0RmlsbDogdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCkgfHwgbGFiZWxDb2xvclxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBhbmltYXRlT3JTZXRQcm9wcyhpc1VwZGF0ZSwgZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGNiKSB7XHJcbiAgICAgICAgdmFyIHBvc3RmaXggPSBpc1VwZGF0ZSA/ICdVcGRhdGUnIDogJyc7XHJcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gYW5pbWF0YWJsZU1vZGVsXHJcbiAgICAgICAgICAgICYmIGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KCdhbmltYXRpb25EdXJhdGlvbicgKyBwb3N0Zml4KTtcclxuICAgICAgICB2YXIgYW5pbWF0aW9uRWFzaW5nID0gYW5pbWF0YWJsZU1vZGVsXHJcbiAgICAgICAgICAgICYmIGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KCdhbmltYXRpb25FYXNpbmcnICsgcG9zdGZpeCk7XHJcblxyXG4gICAgICAgIGFuaW1hdGFibGVNb2RlbCAmJiBhbmltYXRhYmxlTW9kZWwuZ2V0U2hhbGxvdygnYW5pbWF0aW9uJylcclxuICAgICAgICAgICAgPyBlbC5hbmltYXRlVG8ocHJvcHMsIGR1cmF0aW9uLCBhbmltYXRpb25FYXNpbmcsIGNiKVxyXG4gICAgICAgICAgICA6IChlbC5hdHRyKHByb3BzKSwgY2IgJiYgY2IoKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBncmFwaGljIGVsZW1lbnQgcHJvcGVydGllcyB3aXRoIG9yIHdpdGhvdXQgYW5pbWF0aW9uIGFjY29yZGluZyB0byB0aGUgY29uZmlndXJhdGlvbiBpbiBzZXJpZXNcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xyXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW2FuaW1hdGFibGVNb2RlbF1cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMudXBkYXRlUHJvcHMgPSB6clV0aWwuY3VycnkoYW5pbWF0ZU9yU2V0UHJvcHMsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdCBncmFwaGljIGVsZW1lbnQgcHJvcGVydGllcyB3aXRoIG9yIHdpdGhvdXQgYW5pbWF0aW9uIGFjY29yZGluZyB0byB0aGUgY29uZmlndXJhdGlvbiBpbiBzZXJpZXNcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xyXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW2FuaW1hdGFibGVNb2RlbF1cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuaW5pdFByb3BzID0genJVdGlsLmN1cnJ5KGFuaW1hdGVPclNldFByb3BzLCBmYWxzZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdHJhbnNmb3JtIG1hdHJpeCBvZiB0YXJnZXQgKHBhcmFtIHRhcmdldCksXHJcbiAgICAgKiBpbiBjb29yZGluYXRlIG9mIGl0cyBhbmNlc3RvciAocGFyYW0gYW5jZXN0b3IpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfSB0YXJnZXRcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZX0gYW5jZXN0b3JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5nZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodGFyZ2V0LCBhbmNlc3Rvcikge1xyXG4gICAgICAgIHZhciBtYXQgPSBtYXRyaXguaWRlbnRpdHkoW10pO1xyXG5cclxuICAgICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldCAhPT0gYW5jZXN0b3IpIHtcclxuICAgICAgICAgICAgbWF0cml4Lm11bChtYXQsIHRhcmdldC5nZXRMb2NhbFRyYW5zZm9ybSgpLCBtYXQpO1xyXG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG1hdDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSB0cmFuc2Zvcm0gdG8gYW4gdmVydGV4LlxyXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmVydGV4IFt4LCB5XVxyXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdHJhbnNmb3JtIFRyYW5zZm9ybSBtYXRyaXg6IGxpa2UgWzEsIDAsIDAsIDEsIDAsIDBdXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpbnZlcnQgV2hldGhlciB1c2UgaW52ZXJ0IG1hdHJpeC5cclxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBbeCwgeV1cclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5hcHBseVRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2ZXJ0ZXgsIHRyYW5zZm9ybSwgaW52ZXJ0KSB7XHJcbiAgICAgICAgaWYgKGludmVydCkge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBtYXRyaXguaW52ZXJ0KFtdLCB0cmFuc2Zvcm0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmVjdG9yLmFwcGx5VHJhbnNmb3JtKFtdLCB2ZXJ0ZXgsIHRyYW5zZm9ybSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvbiAnbGVmdCcgJ3JpZ2h0JyAndG9wJyAnYm90dG9tJ1xyXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdHJhbnNmb3JtIFRyYW5zZm9ybSBtYXRyaXg6IGxpa2UgWzEsIDAsIDAsIDEsIDAsIDBdXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpbnZlcnQgV2hldGhlciB1c2UgaW52ZXJ0IG1hdHJpeC5cclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVHJhbnNmb3JtZWQgZGlyZWN0aW9uLiAnbGVmdCcgJ3JpZ2h0JyAndG9wJyAnYm90dG9tJ1xyXG4gICAgICovXHJcbiAgICBncmFwaGljLnRyYW5zZm9ybURpcmVjdGlvbiA9IGZ1bmN0aW9uIChkaXJlY3Rpb24sIHRyYW5zZm9ybSwgaW52ZXJ0KSB7XHJcblxyXG4gICAgICAgIC8vIFBpY2sgYSBiYXNlLCBlbnN1cmUgdGhhdCB0cmFuc2Zvcm0gcmVzdWx0IHdpbGwgbm90IGJlICgwLCAwKS5cclxuICAgICAgICB2YXIgaEJhc2UgPSAodHJhbnNmb3JtWzRdID09PSAwIHx8IHRyYW5zZm9ybVs1XSA9PT0gMCB8fCB0cmFuc2Zvcm1bMF0gPT09IDApXHJcbiAgICAgICAgICAgID8gMSA6IE1hdGguYWJzKDIgKiB0cmFuc2Zvcm1bNF0gLyB0cmFuc2Zvcm1bMF0pO1xyXG4gICAgICAgIHZhciB2QmFzZSA9ICh0cmFuc2Zvcm1bNF0gPT09IDAgfHwgdHJhbnNmb3JtWzVdID09PSAwIHx8IHRyYW5zZm9ybVsyXSA9PT0gMClcclxuICAgICAgICAgICAgPyAxIDogTWF0aC5hYnMoMiAqIHRyYW5zZm9ybVs0XSAvIHRyYW5zZm9ybVsyXSk7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0ZXggPSBbXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ2xlZnQnID8gLWhCYXNlIDogZGlyZWN0aW9uID09PSAncmlnaHQnID8gaEJhc2UgOiAwLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb24gPT09ICd0b3AnID8gLXZCYXNlIDogZGlyZWN0aW9uID09PSAnYm90dG9tJyA/IHZCYXNlIDogMFxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIHZlcnRleCA9IGdyYXBoaWMuYXBwbHlUcmFuc2Zvcm0odmVydGV4LCB0cmFuc2Zvcm0sIGludmVydCk7XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyh2ZXJ0ZXhbMF0pID4gTWF0aC5hYnModmVydGV4WzFdKVxyXG4gICAgICAgICAgICA/ICh2ZXJ0ZXhbMF0gPiAwID8gJ3JpZ2h0JyA6ICdsZWZ0JylcclxuICAgICAgICAgICAgOiAodmVydGV4WzFdID4gMCA/ICdib3R0b20nIDogJ3RvcCcpO1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdyYXBoaWM7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL3V0aWxcbiAqL1xuLy8g55So5LqO5aSE55CGbWVyZ2Xml7bml6Dms5XpgY3ljoZEYXRl562J5a+56LGh55qE6Zeu6aKYXG52YXIgQlVJTFRJTl9PQkpFQ1QgPSB7XG4gICdbb2JqZWN0IEZ1bmN0aW9uXSc6IDEsXG4gICdbb2JqZWN0IFJlZ0V4cF0nOiAxLFxuICAnW29iamVjdCBEYXRlXSc6IDEsXG4gICdbb2JqZWN0IEVycm9yXSc6IDEsXG4gICdbb2JqZWN0IENhbnZhc0dyYWRpZW50XSc6IDEsXG4gICdbb2JqZWN0IENhbnZhc1BhdHRlcm5dJzogMSxcbiAgLy8gRm9yIG5vZGUtY2FudmFzXG4gICdbb2JqZWN0IEltYWdlXSc6IDEsXG4gICdbb2JqZWN0IENhbnZhc10nOiAxXG59O1xudmFyIFRZUEVEX0FSUkFZID0ge1xuICAnW29iamVjdCBJbnQ4QXJyYXldJzogMSxcbiAgJ1tvYmplY3QgVWludDhBcnJheV0nOiAxLFxuICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nOiAxLFxuICAnW29iamVjdCBJbnQxNkFycmF5XSc6IDEsXG4gICdbb2JqZWN0IFVpbnQxNkFycmF5XSc6IDEsXG4gICdbb2JqZWN0IEludDMyQXJyYXldJzogMSxcbiAgJ1tvYmplY3QgVWludDMyQXJyYXldJzogMSxcbiAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XSc6IDEsXG4gICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nOiAxXG59O1xudmFyIG9ialRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIG5hdGl2ZUZvckVhY2ggPSBhcnJheVByb3RvLmZvckVhY2g7XG52YXIgbmF0aXZlRmlsdGVyID0gYXJyYXlQcm90by5maWx0ZXI7XG52YXIgbmF0aXZlU2xpY2UgPSBhcnJheVByb3RvLnNsaWNlO1xudmFyIG5hdGl2ZU1hcCA9IGFycmF5UHJvdG8ubWFwO1xudmFyIG5hdGl2ZVJlZHVjZSA9IGFycmF5UHJvdG8ucmVkdWNlOyAvLyBBdm9pZCBhc3NpZ24gdG8gYW4gZXhwb3J0ZWQgdmFyaWFibGUsIGZvciB0cmFuc2Zvcm1pbmcgdG8gY2pzLlxuXG52YXIgbWV0aG9kcyA9IHt9O1xuXG5mdW5jdGlvbiAkb3ZlcnJpZGUobmFtZSwgZm4pIHtcbiAgbWV0aG9kc1tuYW1lXSA9IGZuO1xufVxuLyoqXG4gKiBUaG9zZSBkYXRhIHR5cGVzIGNhbiBiZSBjbG9uZWQ6XG4gKiAgICAgUGxhaW4gb2JqZWN0LCBBcnJheSwgVHlwZWRBcnJheSwgbnVtYmVyLCBzdHJpbmcsIG51bGwsIHVuZGVmaW5lZC5cbiAqIFRob3NlIGRhdGEgdHlwZXMgd2lsbCBiZSBhc3NnaW5lZCB1c2luZyB0aGUgb3JnaW5hbCBkYXRhOlxuICogICAgIEJVSUxUSU5fT0JKRUNUXG4gKiBJbnN0YW5jZSBvZiB1c2VyIGRlZmluZWQgY2xhc3Mgd2lsbCBiZSBjbG9uZWQgdG8gYSBwbGFpbiBvYmplY3QsIHdpdGhvdXRcbiAqIHByb3BlcnRpZXMgaW4gcHJvdG90eXBlLlxuICogT3RoZXIgZGF0YSB0eXBlcyBpcyBub3Qgc3VwcG9ydGVkIChub3Qgc3VyZSB3aGF0IHdpbGwgaGFwcGVuKS5cbiAqXG4gKiBDYXV0aW9uOiBkbyBub3Qgc3VwcG9ydCBjbG9uZSBEYXRlLCBmb3IgcGVyZm9ybWFuY2UgY29uc2lkZXJhdGlvbi5cbiAqIChUaGVyZSBtaWdodCBiZSBhIGxhcmdlIG51bWJlciBvZiBkYXRlIGluIGBzZXJpZXMuZGF0YWApLlxuICogU28gZGF0ZSBzaG91bGQgbm90IGJlIG1vZGlmaWVkIGluIGFuZCBvdXQgb2YgZWNoYXJ0cy5cbiAqXG4gKiBAcGFyYW0geyp9IHNvdXJjZVxuICogQHJldHVybiB7Kn0gbmV3XG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZShzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsIHx8IHR5cGVvZiBzb3VyY2UgIT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHNvdXJjZTtcbiAgdmFyIHR5cGVTdHIgPSBvYmpUb1N0cmluZy5jYWxsKHNvdXJjZSk7XG5cbiAgaWYgKHR5cGVTdHIgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByZXN1bHQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IGNsb25lKHNvdXJjZVtpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKFRZUEVEX0FSUkFZW3R5cGVTdHJdKSB7XG4gICAgdmFyIEN0b3IgPSBzb3VyY2UuY29uc3RydWN0b3I7XG5cbiAgICBpZiAoc291cmNlLmNvbnN0cnVjdG9yLmZyb20pIHtcbiAgICAgIHJlc3VsdCA9IEN0b3IuZnJvbShzb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBuZXcgQ3Rvcihzb3VyY2UubGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByZXN1bHRbaV0gPSBjbG9uZShzb3VyY2VbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICghQlVJTFRJTl9PQkpFQ1RbdHlwZVN0cl0gJiYgIWlzUHJpbWl0aXZlKHNvdXJjZSkgJiYgIWlzRG9tKHNvdXJjZSkpIHtcbiAgICByZXN1bHQgPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGNsb25lKHNvdXJjZVtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0geyp9IHRhcmdldFxuICogQHBhcmFtIHsqfSBzb3VyY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJ3cml0ZT1mYWxzZV1cbiAqL1xuXG5cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlLCBvdmVyd3JpdGUpIHtcbiAgLy8gV2Ugc2hvdWxkIGVzY2Fwc2UgdGhhdCBzb3VyY2UgaXMgc3RyaW5nXG4gIC8vIGFuZCBlbnRlciBmb3IgLi4uIGluIC4uLlxuICBpZiAoIWlzT2JqZWN0KHNvdXJjZSkgfHwgIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICByZXR1cm4gb3ZlcndyaXRlID8gY2xvbmUoc291cmNlKSA6IHRhcmdldDtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHZhciB0YXJnZXRQcm9wID0gdGFyZ2V0W2tleV07XG4gICAgICB2YXIgc291cmNlUHJvcCA9IHNvdXJjZVtrZXldO1xuXG4gICAgICBpZiAoaXNPYmplY3Qoc291cmNlUHJvcCkgJiYgaXNPYmplY3QodGFyZ2V0UHJvcCkgJiYgIWlzQXJyYXkoc291cmNlUHJvcCkgJiYgIWlzQXJyYXkodGFyZ2V0UHJvcCkgJiYgIWlzRG9tKHNvdXJjZVByb3ApICYmICFpc0RvbSh0YXJnZXRQcm9wKSAmJiAhaXNCdWlsdEluT2JqZWN0KHNvdXJjZVByb3ApICYmICFpc0J1aWx0SW5PYmplY3QodGFyZ2V0UHJvcCkgJiYgIWlzUHJpbWl0aXZlKHNvdXJjZVByb3ApICYmICFpc1ByaW1pdGl2ZSh0YXJnZXRQcm9wKSkge1xuICAgICAgICAvLyDlpoLmnpzpnIDopoHpgJLlvZLopobnm5bvvIzlsLHpgJLlvZLosIPnlKhtZXJnZVxuICAgICAgICBtZXJnZSh0YXJnZXRQcm9wLCBzb3VyY2VQcm9wLCBvdmVyd3JpdGUpO1xuICAgICAgfSBlbHNlIGlmIChvdmVyd3JpdGUgfHwgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICAvLyDlkKbliJnlj6rlpITnkIZvdmVyd3JpdGXkuLp0cnVl77yM5oiW6ICF5Zyo55uu5qCH5a+56LGh5Lit5rKh5pyJ5q2k5bGe5oCn55qE5oOF5Ya1XG4gICAgICAgIC8vIE5PVEXvvIzlnKggdGFyZ2V0W2tleV0g5LiN5a2Y5Zyo55qE5pe25YCZ5Lmf5piv55u05o6l6KaG55uWXG4gICAgICAgIHRhcmdldFtrZXldID0gY2xvbmUoc291cmNlW2tleV0sIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldEFuZFNvdXJjZXMgVGhlIGZpcnN0IGl0ZW0gaXMgdGFyZ2V0LCBhbmQgdGhlIHJlc3RzIGFyZSBzb3VyY2UuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVyd3JpdGU9ZmFsc2VdXG4gKiBAcmV0dXJuIHsqfSB0YXJnZXRcbiAqL1xuXG5cbmZ1bmN0aW9uIG1lcmdlQWxsKHRhcmdldEFuZFNvdXJjZXMsIG92ZXJ3cml0ZSkge1xuICB2YXIgcmVzdWx0ID0gdGFyZ2V0QW5kU291cmNlc1swXTtcblxuICBmb3IgKHZhciBpID0gMSwgbGVuID0gdGFyZ2V0QW5kU291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc3VsdCA9IG1lcmdlKHJlc3VsdCwgdGFyZ2V0QW5kU291cmNlc1tpXSwgb3ZlcndyaXRlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gKiBAcGFyYW0geyp9IHNvdXJjZVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICovXG5cblxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuICogQHBhcmFtIHsqfSB0YXJnZXRcbiAqIEBwYXJhbSB7Kn0gc291cmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVybGF5PWZhbHNlXVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICovXG5cblxuZnVuY3Rpb24gZGVmYXVsdHModGFyZ2V0LCBzb3VyY2UsIG92ZXJsYXkpIHtcbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAob3ZlcmxheSA/IHNvdXJjZVtrZXldICE9IG51bGwgOiB0YXJnZXRba2V5XSA9PSBudWxsKSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgY3JlYXRlQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbWV0aG9kcy5jcmVhdGVDYW52YXMoKTtcbn07XG5cbm1ldGhvZHMuY3JlYXRlQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG59OyAvLyBGSVhNRVxuXG5cbnZhciBfY3R4O1xuXG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICBpZiAoIV9jdHgpIHtcbiAgICAvLyBVc2UgdXRpbC5jcmVhdGVDYW52YXMgaW5zdGVhZCBvZiBjcmVhdGVDYW52YXNcbiAgICAvLyBiZWNhdXNlIGNyZWF0ZUNhbnZhcyBtYXkgYmUgb3ZlcndyaXR0ZW4gaW4gZGlmZmVyZW50IGVudmlyb25tZW50XG4gICAgX2N0eCA9IGNyZWF0ZUNhbnZhcygpLmdldENvbnRleHQoJzJkJyk7XG4gIH1cblxuICByZXR1cm4gX2N0eDtcbn1cbi8qKlxuICog5p+l6K+i5pWw57uE5Lit5YWD57Sg55qEaW5kZXhcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gIGlmIChhcnJheSkge1xuICAgIGlmIChhcnJheS5pbmRleE9mKSB7XG4gICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZih2YWx1ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cbi8qKlxuICog5p6E6YCg57G757un5om/5YWz57O7XG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xhenog5rqQ57G7XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlQ2xhenog5Z+657G7XG4gKi9cblxuXG5mdW5jdGlvbiBpbmhlcml0cyhjbGF6eiwgYmFzZUNsYXp6KSB7XG4gIHZhciBjbGF6elByb3RvdHlwZSA9IGNsYXp6LnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBGKCkge31cblxuICBGLnByb3RvdHlwZSA9IGJhc2VDbGF6ei5wcm90b3R5cGU7XG4gIGNsYXp6LnByb3RvdHlwZSA9IG5ldyBGKCk7XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBjbGF6elByb3RvdHlwZSkge1xuICAgIGNsYXp6LnByb3RvdHlwZVtwcm9wXSA9IGNsYXp6UHJvdG90eXBlW3Byb3BdO1xuICB9XG5cbiAgY2xhenoucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY2xheno7XG4gIGNsYXp6LnN1cGVyQ2xhc3MgPSBiYXNlQ2xheno7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBzb3JjZVxuICogQHBhcmFtIHtib29sZWFufSBvdmVybGF5XG4gKi9cblxuXG5mdW5jdGlvbiBtaXhpbih0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSkge1xuICB0YXJnZXQgPSAncHJvdG90eXBlJyBpbiB0YXJnZXQgPyB0YXJnZXQucHJvdG90eXBlIDogdGFyZ2V0O1xuICBzb3VyY2UgPSAncHJvdG90eXBlJyBpbiBzb3VyY2UgPyBzb3VyY2UucHJvdG90eXBlIDogc291cmNlO1xuICBkZWZhdWx0cyh0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSk7XG59XG4vKipcbiAqIENvbnNpZGVyIHR5cGVkIGFycmF5LlxuICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBkYXRhXG4gKi9cblxuXG5mdW5jdGlvbiBpc0FycmF5TGlrZShkYXRhKSB7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0eXBlb2YgZGF0YS5sZW5ndGggPT0gJ251bWJlcic7XG59XG4vKipcbiAqIOaVsOe7hOaIluWvueixoemBjeWOhlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKi9cblxuXG5mdW5jdGlvbiBlYWNoKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChvYmouZm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgIG9iai5mb3JFYWNoKGNiLCBjb250ZXh0KTtcbiAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiDmlbDnu4TmmKDlsIRcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmZ1bmN0aW9uIG1hcChvYmosIGNiLCBjb250ZXh0KSB7XG4gIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAob2JqLm1hcCAmJiBvYmoubWFwID09PSBuYXRpdmVNYXApIHtcbiAgICByZXR1cm4gb2JqLm1hcChjYiwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2goY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtBcnJheX0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtPYmplY3R9IFttZW1vXVxuICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cblxuZnVuY3Rpb24gcmVkdWNlKG9iaiwgY2IsIG1lbW8sIGNvbnRleHQpIHtcbiAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChvYmoucmVkdWNlICYmIG9iai5yZWR1Y2UgPT09IG5hdGl2ZVJlZHVjZSkge1xuICAgIHJldHVybiBvYmoucmVkdWNlKGNiLCBtZW1vLCBjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBtZW1vID0gY2IuY2FsbChjb250ZXh0LCBtZW1vLCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW87XG4gIH1cbn1cbi8qKlxuICog5pWw57uE6L+H5rukXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuXG5mdW5jdGlvbiBmaWx0ZXIob2JqLCBjYiwgY29udGV4dCkge1xuICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG9iai5maWx0ZXIgJiYgb2JqLmZpbHRlciA9PT0gbmF0aXZlRmlsdGVyKSB7XG4gICAgcmV0dXJuIG9iai5maWx0ZXIoY2IsIGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSkge1xuICAgICAgICByZXN1bHQucHVzaChvYmpbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbi8qKlxuICog5pWw57uE6aG55p+l5om+XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICogQHJldHVybiB7Kn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbmQob2JqLCBjYiwgY29udGV4dCkge1xuICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSkge1xuICAgICAgcmV0dXJuIG9ialtpXTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICogQHBhcmFtIHsqfSBjb250ZXh0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGJpbmQoZnVuYywgY29udGV4dCkge1xuICB2YXIgYXJncyA9IG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgfTtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuXG5mdW5jdGlvbiBjdXJyeShmdW5jKSB7XG4gIHZhciBhcmdzID0gbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MuY29uY2F0KG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICB9O1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAhIXZhbHVlICYmIHR5cGUgPT0gJ29iamVjdCc7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0J1aWx0SW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuICEhQlVJTFRJTl9PQkpFQ1Rbb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSldO1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNEb20odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUub3duZXJEb2N1bWVudCA9PT0gJ29iamVjdCc7XG59XG4vKipcbiAqIFdoZXRoZXIgaXMgZXhhY3RseSBOYU4uIE5vdGljZSBpc05hTignYScpIHJldHVybnMgdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBlcU5hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuLyoqXG4gKiBJZiB2YWx1ZTEgaXMgbm90IG51bGwsIHRoZW4gcmV0dXJuIHZhbHVlMSwgb3RoZXJ3aXNlIGp1ZGdldCByZXN0IG9mIHZhbHVlcy5cbiAqIExvdyBwZXJmb3JtYW5jZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEByZXR1cm4geyp9IEZpbmFsIHZhbHVlXG4gKi9cblxuXG5mdW5jdGlvbiByZXRyaWV2ZSh2YWx1ZXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChhcmd1bWVudHNbaV0gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0cmlldmUyKHZhbHVlMCwgdmFsdWUxKSB7XG4gIHJldHVybiB2YWx1ZTAgIT0gbnVsbCA/IHZhbHVlMCA6IHZhbHVlMTtcbn1cblxuZnVuY3Rpb24gcmV0cmlldmUzKHZhbHVlMCwgdmFsdWUxLCB2YWx1ZTIpIHtcbiAgcmV0dXJuIHZhbHVlMCAhPSBudWxsID8gdmFsdWUwIDogdmFsdWUxICE9IG51bGwgPyB2YWx1ZTEgOiB2YWx1ZTI7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRJbmRleFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuXG5mdW5jdGlvbiBzbGljZSgpIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLmNhbGwuYXBwbHkobmF0aXZlU2xpY2UsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIE5vcm1hbGl6ZSBjc3MgbGlrZWQgYXJyYXkgY29uZmlndXJhdGlvblxuICogZS5nLlxuICogIDMgPT4gWzMsIDMsIDMsIDNdXG4gKiAgWzQsIDJdID0+IFs0LCAyLCA0LCAyXVxuICogIFs0LCAzLCAyXSA9PiBbNCwgMywgMiwgM11cbiAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSB2YWxcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplQ3NzQXJyYXkodmFsKSB7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBbdmFsLCB2YWwsIHZhbCwgdmFsXTtcbiAgfVxuXG4gIHZhciBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gIGlmIChsZW4gPT09IDIpIHtcbiAgICAvLyB2ZXJ0aWNhbCB8IGhvcml6b250YWxcbiAgICByZXR1cm4gW3ZhbFswXSwgdmFsWzFdLCB2YWxbMF0sIHZhbFsxXV07XG4gIH0gZWxzZSBpZiAobGVuID09PSAzKSB7XG4gICAgLy8gdG9wIHwgaG9yaXpvbnRhbCB8IGJvdHRvbVxuICAgIHJldHVybiBbdmFsWzBdLCB2YWxbMV0sIHZhbFsyXSwgdmFsWzFdXTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZGl0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICovXG5cblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG52YXIgcHJpbWl0aXZlS2V5ID0gJ19fZWNfcHJpbWl0aXZlX18nO1xuLyoqXG4gKiBTZXQgYW4gb2JqZWN0IGFzIHByaW1pdGl2ZSB0byBiZSBpZ25vcmVkIHRyYXZlcnNpbmcgY2hpbGRyZW4gaW4gY2xvbmUgb3IgbWVyZ2VcbiAqL1xuXG5mdW5jdGlvbiBzZXRBc1ByaW1pdGl2ZShvYmopIHtcbiAgb2JqW3ByaW1pdGl2ZUtleV0gPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShvYmopIHtcbiAgcmV0dXJuIG9ialtwcmltaXRpdmVLZXldO1xufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT25seSBhcHBseSBgb3duUHJvcGVydHlgLlxuICovXG5cblxuZnVuY3Rpb24gSGFzaE1hcChvYmopIHtcbiAgb2JqICYmIGVhY2gob2JqLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICB9LCB0aGlzKTtcbn0gLy8gQWRkIHByZWZpeCB0byBhdm9pZCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUuXG5cblxudmFyIEhBU0hfTUFQX1BSRUZJWCA9ICdfZWNfJztcbnZhciBIQVNIX01BUF9QUkVGSVhfTEVOR1RIID0gNDtcbkhhc2hNYXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogSGFzaE1hcCxcbiAgLy8gRG8gbm90IHByb3ZpZGUgYGhhc2AgbWV0aG9kIHRvIGF2b2lkIGRlZmluaW5nIHdoYXQgaXMgYGhhc2AuXG4gIC8vIChXZSB1c3VhbGx5IHRyZWF0IGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXMgdGhlIHNhbWUsIGRpZmZlcmVudFxuICAvLyBmcm9tIEVTNiBNYXApLlxuICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpc1tIQVNIX01BUF9QUkVGSVggKyBrZXldO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdGhpc1tIQVNIX01BUF9QUkVGSVggKyBrZXldID0gdmFsdWU7IC8vIENvbXBhcmluZyB3aXRoIGludm9jYXRpb24gY2hhaW5pbmcsIGByZXR1cm4gdmFsdWVgIGlzIG1vcmUgY29tbW9ubHlcbiAgICAvLyB1c2VkIGluIHRoaXMgY2FzZTogYHZhciBzb21lVmFsID0gbWFwLnNldCgnYScsIGdlblZhbCgpKTtgXG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIC8vIEFsdGhvdWdoIHV0aWwuZWFjaCBjYW4gYmUgcGVyZm9ybWVkIG9uIHRoaXMgaGFzaE1hcCBkaXJlY3RseSwgdXNlclxuICAvLyBzaG91bGQgbm90IHVzZSB0aGUgZXhwb3NlZCBrZXlzLCB3aG8gYXJlIHByZWZpeGVkLlxuICBlYWNoOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0ICE9PSB2b2lkIDAgJiYgKGNiID0gYmluZChjYiwgY29udGV4dCkpO1xuXG4gICAgZm9yICh2YXIgcHJlZml4ZWRLZXkgaW4gdGhpcykge1xuICAgICAgdGhpcy5oYXNPd25Qcm9wZXJ0eShwcmVmaXhlZEtleSkgJiYgY2IodGhpc1twcmVmaXhlZEtleV0sIHByZWZpeGVkS2V5LnNsaWNlKEhBU0hfTUFQX1BSRUZJWF9MRU5HVEgpKTtcbiAgICB9XG4gIH0sXG4gIC8vIERvIG5vdCB1c2UgdGhpcyBtZXRob2QgaWYgcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLlxuICByZW1vdmVLZXk6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBkZWxldGUgdGhpc1tIQVNIX01BUF9QUkVGSVggKyBrZXldO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVIYXNoTWFwKG9iaikge1xuICByZXR1cm4gbmV3IEhhc2hNYXAob2JqKTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmV4cG9ydHMuJG92ZXJyaWRlID0gJG92ZXJyaWRlO1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuZXhwb3J0cy5tZXJnZUFsbCA9IG1lcmdlQWxsO1xuZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7XG5leHBvcnRzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG5leHBvcnRzLmNyZWF0ZUNhbnZhcyA9IGNyZWF0ZUNhbnZhcztcbmV4cG9ydHMuZ2V0Q29udGV4dCA9IGdldENvbnRleHQ7XG5leHBvcnRzLmluZGV4T2YgPSBpbmRleE9mO1xuZXhwb3J0cy5pbmhlcml0cyA9IGluaGVyaXRzO1xuZXhwb3J0cy5taXhpbiA9IG1peGluO1xuZXhwb3J0cy5pc0FycmF5TGlrZSA9IGlzQXJyYXlMaWtlO1xuZXhwb3J0cy5lYWNoID0gZWFjaDtcbmV4cG9ydHMubWFwID0gbWFwO1xuZXhwb3J0cy5yZWR1Y2UgPSByZWR1Y2U7XG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcbmV4cG9ydHMuZmluZCA9IGZpbmQ7XG5leHBvcnRzLmJpbmQgPSBiaW5kO1xuZXhwb3J0cy5jdXJyeSA9IGN1cnJ5O1xuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5leHBvcnRzLmlzQnVpbHRJbk9iamVjdCA9IGlzQnVpbHRJbk9iamVjdDtcbmV4cG9ydHMuaXNEb20gPSBpc0RvbTtcbmV4cG9ydHMuZXFOYU4gPSBlcU5hTjtcbmV4cG9ydHMucmV0cmlldmUgPSByZXRyaWV2ZTtcbmV4cG9ydHMucmV0cmlldmUyID0gcmV0cmlldmUyO1xuZXhwb3J0cy5yZXRyaWV2ZTMgPSByZXRyaWV2ZTM7XG5leHBvcnRzLnNsaWNlID0gc2xpY2U7XG5leHBvcnRzLm5vcm1hbGl6ZUNzc0FycmF5ID0gbm9ybWFsaXplQ3NzQXJyYXk7XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbmV4cG9ydHMuc2V0QXNQcmltaXRpdmUgPSBzZXRBc1ByaW1pdGl2ZTtcbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcbmV4cG9ydHMuY3JlYXRlSGFzaE1hcCA9IGNyZWF0ZUhhc2hNYXA7XG5leHBvcnRzLm5vb3AgPSBub29wO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL3V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9QYXRoXCIpO1xuXG52YXIgUGF0aFByb3h5ID0gcmVxdWlyZShcIi4uL2NvcmUvUGF0aFByb3h5XCIpO1xuXG52YXIgdHJhbnNmb3JtUGF0aCA9IHJlcXVpcmUoXCIuL3RyYW5zZm9ybVBhdGhcIik7XG5cbi8vIGNvbW1hbmQgY2hhcnNcbnZhciBjYyA9IFsnbScsICdNJywgJ2wnLCAnTCcsICd2JywgJ1YnLCAnaCcsICdIJywgJ3onLCAnWicsICdjJywgJ0MnLCAncScsICdRJywgJ3QnLCAnVCcsICdzJywgJ1MnLCAnYScsICdBJ107XG52YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgbWF0aFNpbiA9IE1hdGguc2luO1xudmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcbnZhciBQSSA9IE1hdGguUEk7XG5cbnZhciB2TWFnID0gZnVuY3Rpb24gKHYpIHtcbiAgcmV0dXJuIE1hdGguc3FydCh2WzBdICogdlswXSArIHZbMV0gKiB2WzFdKTtcbn07XG5cbnZhciB2UmF0aW8gPSBmdW5jdGlvbiAodSwgdikge1xuICByZXR1cm4gKHVbMF0gKiB2WzBdICsgdVsxXSAqIHZbMV0pIC8gKHZNYWcodSkgKiB2TWFnKHYpKTtcbn07XG5cbnZhciB2QW5nbGUgPSBmdW5jdGlvbiAodSwgdikge1xuICByZXR1cm4gKHVbMF0gKiB2WzFdIDwgdVsxXSAqIHZbMF0gPyAtMSA6IDEpICogTWF0aC5hY29zKHZSYXRpbyh1LCB2KSk7XG59O1xuXG5mdW5jdGlvbiBwcm9jZXNzQXJjKHgxLCB5MSwgeDIsIHkyLCBmYSwgZnMsIHJ4LCByeSwgcHNpRGVnLCBjbWQsIHBhdGgpIHtcbiAgdmFyIHBzaSA9IHBzaURlZyAqIChQSSAvIDE4MC4wKTtcbiAgdmFyIHhwID0gbWF0aENvcyhwc2kpICogKHgxIC0geDIpIC8gMi4wICsgbWF0aFNpbihwc2kpICogKHkxIC0geTIpIC8gMi4wO1xuICB2YXIgeXAgPSAtMSAqIG1hdGhTaW4ocHNpKSAqICh4MSAtIHgyKSAvIDIuMCArIG1hdGhDb3MocHNpKSAqICh5MSAtIHkyKSAvIDIuMDtcbiAgdmFyIGxhbWJkYSA9IHhwICogeHAgLyAocnggKiByeCkgKyB5cCAqIHlwIC8gKHJ5ICogcnkpO1xuXG4gIGlmIChsYW1iZGEgPiAxKSB7XG4gICAgcnggKj0gbWF0aFNxcnQobGFtYmRhKTtcbiAgICByeSAqPSBtYXRoU3FydChsYW1iZGEpO1xuICB9XG5cbiAgdmFyIGYgPSAoZmEgPT09IGZzID8gLTEgOiAxKSAqIG1hdGhTcXJ0KChyeCAqIHJ4ICogKHJ5ICogcnkpIC0gcnggKiByeCAqICh5cCAqIHlwKSAtIHJ5ICogcnkgKiAoeHAgKiB4cCkpIC8gKHJ4ICogcnggKiAoeXAgKiB5cCkgKyByeSAqIHJ5ICogKHhwICogeHApKSkgfHwgMDtcbiAgdmFyIGN4cCA9IGYgKiByeCAqIHlwIC8gcnk7XG4gIHZhciBjeXAgPSBmICogLXJ5ICogeHAgLyByeDtcbiAgdmFyIGN4ID0gKHgxICsgeDIpIC8gMi4wICsgbWF0aENvcyhwc2kpICogY3hwIC0gbWF0aFNpbihwc2kpICogY3lwO1xuICB2YXIgY3kgPSAoeTEgKyB5MikgLyAyLjAgKyBtYXRoU2luKHBzaSkgKiBjeHAgKyBtYXRoQ29zKHBzaSkgKiBjeXA7XG4gIHZhciB0aGV0YSA9IHZBbmdsZShbMSwgMF0sIFsoeHAgLSBjeHApIC8gcngsICh5cCAtIGN5cCkgLyByeV0pO1xuICB2YXIgdSA9IFsoeHAgLSBjeHApIC8gcngsICh5cCAtIGN5cCkgLyByeV07XG4gIHZhciB2ID0gWygtMSAqIHhwIC0gY3hwKSAvIHJ4LCAoLTEgKiB5cCAtIGN5cCkgLyByeV07XG4gIHZhciBkVGhldGEgPSB2QW5nbGUodSwgdik7XG5cbiAgaWYgKHZSYXRpbyh1LCB2KSA8PSAtMSkge1xuICAgIGRUaGV0YSA9IFBJO1xuICB9XG5cbiAgaWYgKHZSYXRpbyh1LCB2KSA+PSAxKSB7XG4gICAgZFRoZXRhID0gMDtcbiAgfVxuXG4gIGlmIChmcyA9PT0gMCAmJiBkVGhldGEgPiAwKSB7XG4gICAgZFRoZXRhID0gZFRoZXRhIC0gMiAqIFBJO1xuICB9XG5cbiAgaWYgKGZzID09PSAxICYmIGRUaGV0YSA8IDApIHtcbiAgICBkVGhldGEgPSBkVGhldGEgKyAyICogUEk7XG4gIH1cblxuICBwYXRoLmFkZERhdGEoY21kLCBjeCwgY3ksIHJ4LCByeSwgdGhldGEsIGRUaGV0YSwgcHNpLCBmcyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGhQcm94eUZyb21TdHJpbmcoZGF0YSkge1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm4gW107XG4gIH0gLy8gY29tbWFuZCBzdHJpbmdcblxuXG4gIHZhciBjcyA9IGRhdGEucmVwbGFjZSgvLS9nLCAnIC0nKS5yZXBsYWNlKC8gIC9nLCAnICcpLnJlcGxhY2UoLyAvZywgJywnKS5yZXBsYWNlKC8sLC9nLCAnLCcpO1xuICB2YXIgbjsgLy8gY3JlYXRlIHBpcGVzIHNvIHRoYXQgd2UgY2FuIHNwbGl0IHRoZSBkYXRhXG5cbiAgZm9yIChuID0gMDsgbiA8IGNjLmxlbmd0aDsgbisrKSB7XG4gICAgY3MgPSBjcy5yZXBsYWNlKG5ldyBSZWdFeHAoY2Nbbl0sICdnJyksICd8JyArIGNjW25dKTtcbiAgfSAvLyBjcmVhdGUgYXJyYXlcblxuXG4gIHZhciBhcnIgPSBjcy5zcGxpdCgnfCcpOyAvLyBpbml0IGNvbnRleHQgcG9pbnRcblxuICB2YXIgY3B4ID0gMDtcbiAgdmFyIGNweSA9IDA7XG4gIHZhciBwYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICB2YXIgQ01EID0gUGF0aFByb3h5LkNNRDtcbiAgdmFyIHByZXZDbWQ7XG5cbiAgZm9yIChuID0gMTsgbiA8IGFyci5sZW5ndGg7IG4rKykge1xuICAgIHZhciBzdHIgPSBhcnJbbl07XG4gICAgdmFyIGMgPSBzdHIuY2hhckF0KDApO1xuICAgIHZhciBvZmYgPSAwO1xuICAgIHZhciBwID0gc3RyLnNsaWNlKDEpLnJlcGxhY2UoL2UsLS9nLCAnZS0nKS5zcGxpdCgnLCcpO1xuICAgIHZhciBjbWQ7XG5cbiAgICBpZiAocC5sZW5ndGggPiAwICYmIHBbMF0gPT09ICcnKSB7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwW2ldID0gcGFyc2VGbG9hdChwW2ldKTtcbiAgICB9XG5cbiAgICB3aGlsZSAob2ZmIDwgcC5sZW5ndGggJiYgIWlzTmFOKHBbb2ZmXSkpIHtcbiAgICAgIGlmIChpc05hTihwWzBdKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGN0bFB0eDtcbiAgICAgIHZhciBjdGxQdHk7XG4gICAgICB2YXIgcng7XG4gICAgICB2YXIgcnk7XG4gICAgICB2YXIgcHNpO1xuICAgICAgdmFyIGZhO1xuICAgICAgdmFyIGZzO1xuICAgICAgdmFyIHgxID0gY3B4O1xuICAgICAgdmFyIHkxID0gY3B5OyAvLyBjb252ZXJ0IGwsIEgsIGgsIFYsIGFuZCB2IHRvIExcblxuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5NO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBjID0gJ2wnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5NO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBjID0gJ0wnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10pO1xuICAgICAgICAgIGNweCA9IHBbb2ZmIC0gMl07XG4gICAgICAgICAgY3B5ID0gcFtvZmYgLSAxXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICBjbWQgPSBDTUQuQztcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBwW29mZisrXSArIGNweCwgcFtvZmYrK10gKyBjcHksIHBbb2ZmKytdICsgY3B4LCBwW29mZisrXSArIGNweSwgcFtvZmYrK10gKyBjcHgsIHBbb2ZmKytdICsgY3B5KTtcbiAgICAgICAgICBjcHggKz0gcFtvZmYgLSAyXTtcbiAgICAgICAgICBjcHkgKz0gcFtvZmYgLSAxXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcblxuICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuQykge1xuICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgIHgxID0gcFtvZmYrK107XG4gICAgICAgICAgeTEgPSBwW29mZisrXTtcbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG5cbiAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELkMpIHtcbiAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjbWQgPSBDTUQuQztcbiAgICAgICAgICB4MSA9IGNweCArIHBbb2ZmKytdO1xuICAgICAgICAgIHkxID0gY3B5ICsgcFtvZmYrK107XG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgeDEgPSBwW29mZisrXTtcbiAgICAgICAgICB5MSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5RO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHgxLCB5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgIHgxID0gcFtvZmYrK10gKyBjcHg7XG4gICAgICAgICAgeTEgPSBwW29mZisrXSArIGNweTtcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5RO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHgxLCB5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuXG4gICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5RKSB7XG4gICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3RsUHR4LCBjdGxQdHksIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcblxuICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuUSkge1xuICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3RsUHR4LCBjdGxQdHksIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICByeCA9IHBbb2ZmKytdO1xuICAgICAgICAgIHJ5ID0gcFtvZmYrK107XG4gICAgICAgICAgcHNpID0gcFtvZmYrK107XG4gICAgICAgICAgZmEgPSBwW29mZisrXTtcbiAgICAgICAgICBmcyA9IHBbb2ZmKytdO1xuICAgICAgICAgIHgxID0gY3B4LCB5MSA9IGNweTtcbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuQTtcbiAgICAgICAgICBwcm9jZXNzQXJjKHgxLCB5MSwgY3B4LCBjcHksIGZhLCBmcywgcngsIHJ5LCBwc2ksIGNtZCwgcGF0aCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgcnggPSBwW29mZisrXTtcbiAgICAgICAgICByeSA9IHBbb2ZmKytdO1xuICAgICAgICAgIHBzaSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGZhID0gcFtvZmYrK107XG4gICAgICAgICAgZnMgPSBwW29mZisrXTtcbiAgICAgICAgICB4MSA9IGNweCwgeTEgPSBjcHk7XG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuQTtcbiAgICAgICAgICBwcm9jZXNzQXJjKHgxLCB5MSwgY3B4LCBjcHksIGZhLCBmcywgcngsIHJ5LCBwc2ksIGNtZCwgcGF0aCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGMgPT09ICd6JyB8fCBjID09PSAnWicpIHtcbiAgICAgIGNtZCA9IENNRC5aO1xuICAgICAgcGF0aC5hZGREYXRhKGNtZCk7XG4gICAgfVxuXG4gICAgcHJldkNtZCA9IGNtZDtcbiAgfVxuXG4gIHBhdGgudG9TdGF0aWMoKTtcbiAgcmV0dXJuIHBhdGg7XG59IC8vIFRPRE8gT3B0aW1pemUgZG91YmxlIG1lbW9yeSBjb3N0IHByb2JsZW1cblxuXG5mdW5jdGlvbiBjcmVhdGVQYXRoT3B0aW9ucyhzdHIsIG9wdHMpIHtcbiAgdmFyIHBhdGhQcm94eSA9IGNyZWF0ZVBhdGhQcm94eUZyb21TdHJpbmcoc3RyKTtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgb3B0cy5idWlsZFBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmIChwYXRoLnNldERhdGEpIHtcbiAgICAgIHBhdGguc2V0RGF0YShwYXRoUHJveHkuZGF0YSk7IC8vIFN2ZyBhbmQgdm1sIHJlbmRlcmVyIGRvbid0IGhhdmUgY29udGV4dFxuXG4gICAgICB2YXIgY3R4ID0gcGF0aC5nZXRDb250ZXh0KCk7XG5cbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgcGF0aC5yZWJ1aWxkUGF0aChjdHgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY3R4ID0gcGF0aDtcbiAgICAgIHBhdGhQcm94eS5yZWJ1aWxkUGF0aChjdHgpO1xuICAgIH1cbiAgfTtcblxuICBvcHRzLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKG0pIHtcbiAgICB0cmFuc2Zvcm1QYXRoKHBhdGhQcm94eSwgbSk7XG4gICAgdGhpcy5kaXJ0eSh0cnVlKTtcbiAgfTtcblxuICByZXR1cm4gb3B0cztcbn1cbi8qKlxuICogQ3JlYXRlIGEgUGF0aCBvYmplY3QgZnJvbSBwYXRoIHN0cmluZyBkYXRhXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRGF0YVxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRzIE90aGVyIG9wdGlvbnNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUZyb21TdHJpbmcoc3RyLCBvcHRzKSB7XG4gIHJldHVybiBuZXcgUGF0aChjcmVhdGVQYXRoT3B0aW9ucyhzdHIsIG9wdHMpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgUGF0aCBjbGFzcyBmcm9tIHBhdGggc3RyaW5nIGRhdGFcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgT3RoZXIgb3B0aW9uc1xuICovXG5cblxuZnVuY3Rpb24gZXh0ZW5kRnJvbVN0cmluZyhzdHIsIG9wdHMpIHtcbiAgcmV0dXJuIFBhdGguZXh0ZW5kKGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykpO1xufVxuLyoqXG4gKiBNZXJnZSBtdWx0aXBsZSBwYXRoc1xuICovXG4vLyBUT0RPIEFwcGx5IHRyYW5zZm9ybVxuLy8gVE9ETyBzdHJva2UgZGFzaFxuLy8gVE9ETyBPcHRpbWl6ZSBkb3VibGUgbWVtb3J5IGNvc3QgcHJvYmxlbVxuXG5cbmZ1bmN0aW9uIG1lcmdlUGF0aChwYXRoRWxzLCBvcHRzKSB7XG4gIHZhciBwYXRoTGlzdCA9IFtdO1xuICB2YXIgbGVuID0gcGF0aEVscy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwYXRoRWwgPSBwYXRoRWxzW2ldO1xuXG4gICAgaWYgKCFwYXRoRWwucGF0aCkge1xuICAgICAgcGF0aEVsLmNyZWF0ZVBhdGhQcm94eSgpO1xuICAgIH1cblxuICAgIGlmIChwYXRoRWwuX19kaXJ0eVBhdGgpIHtcbiAgICAgIHBhdGhFbC5idWlsZFBhdGgocGF0aEVsLnBhdGgsIHBhdGhFbC5zaGFwZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcGF0aExpc3QucHVzaChwYXRoRWwucGF0aCk7XG4gIH1cblxuICB2YXIgcGF0aEJ1bmRsZSA9IG5ldyBQYXRoKG9wdHMpOyAvLyBOZWVkIHBhdGggcHJveHkuXG5cbiAgcGF0aEJ1bmRsZS5jcmVhdGVQYXRoUHJveHkoKTtcblxuICBwYXRoQnVuZGxlLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgcGF0aC5hcHBlbmRQYXRoKHBhdGhMaXN0KTsgLy8gU3ZnIGFuZCB2bWwgcmVuZGVyZXIgZG9uJ3QgaGF2ZSBjb250ZXh0XG5cbiAgICB2YXIgY3R4ID0gcGF0aC5nZXRDb250ZXh0KCk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBwYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBwYXRoQnVuZGxlO1xufVxuXG5leHBvcnRzLmNyZWF0ZUZyb21TdHJpbmcgPSBjcmVhdGVGcm9tU3RyaW5nO1xuZXhwb3J0cy5leHRlbmRGcm9tU3RyaW5nID0gZXh0ZW5kRnJvbVN0cmluZztcbmV4cG9ydHMubWVyZ2VQYXRoID0gbWVyZ2VQYXRoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi90b29sL3BhdGguanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZShcIi4vRGlzcGxheWFibGVcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgUGF0aFByb3h5ID0gcmVxdWlyZShcIi4uL2NvcmUvUGF0aFByb3h5XCIpO1xuXG52YXIgcGF0aENvbnRhaW4gPSByZXF1aXJlKFwiLi4vY29udGFpbi9wYXRoXCIpO1xuXG52YXIgUGF0dGVybiA9IHJlcXVpcmUoXCIuL1BhdHRlcm5cIik7XG5cbnZhciBnZXRDYW52YXNQYXR0ZXJuID0gUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybjtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBwYXRoUHJveHlGb3JEcmF3ID0gbmV3IFBhdGhQcm94eSh0cnVlKTtcbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aFxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5cbmZ1bmN0aW9uIFBhdGgob3B0cykge1xuICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG5cbiAgdGhpcy5wYXRoID0gbnVsbDtcbn1cblxuUGF0aC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQYXRoLFxuICB0eXBlOiAncGF0aCcsXG4gIF9fZGlydHlQYXRoOiB0cnVlLFxuICBzdHJva2VDb250YWluVGhyZXNob2xkOiA1LFxuICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgcGF0aCA9IHRoaXMucGF0aCB8fCBwYXRoUHJveHlGb3JEcmF3O1xuICAgIHZhciBoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKTtcbiAgICB2YXIgaGFzRmlsbCA9IHN0eWxlLmhhc0ZpbGwoKTtcbiAgICB2YXIgZmlsbCA9IHN0eWxlLmZpbGw7XG4gICAgdmFyIHN0cm9rZSA9IHN0eWxlLnN0cm9rZTtcbiAgICB2YXIgaGFzRmlsbEdyYWRpZW50ID0gaGFzRmlsbCAmJiAhIWZpbGwuY29sb3JTdG9wcztcbiAgICB2YXIgaGFzU3Ryb2tlR3JhZGllbnQgPSBoYXNTdHJva2UgJiYgISFzdHJva2UuY29sb3JTdG9wcztcbiAgICB2YXIgaGFzRmlsbFBhdHRlcm4gPSBoYXNGaWxsICYmICEhZmlsbC5pbWFnZTtcbiAgICB2YXIgaGFzU3Ryb2tlUGF0dGVybiA9IGhhc1N0cm9rZSAmJiAhIXN0cm9rZS5pbWFnZTtcbiAgICBzdHlsZS5iaW5kKGN0eCwgdGhpcywgcHJldkVsKTtcbiAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuXG4gICAgaWYgKHRoaXMuX19kaXJ0eSkge1xuICAgICAgdmFyIHJlY3Q7IC8vIFVwZGF0ZSBncmFkaWVudCBiZWNhdXNlIGJvdW5kaW5nIHJlY3QgbWF5IGNoYW5nZWRcblxuICAgICAgaWYgKGhhc0ZpbGxHcmFkaWVudCkge1xuICAgICAgICByZWN0ID0gcmVjdCB8fCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICB0aGlzLl9maWxsR3JhZGllbnQgPSBzdHlsZS5nZXRHcmFkaWVudChjdHgsIGZpbGwsIHJlY3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzU3Ryb2tlR3JhZGllbnQpIHtcbiAgICAgICAgcmVjdCA9IHJlY3QgfHwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgdGhpcy5fc3Ryb2tlR3JhZGllbnQgPSBzdHlsZS5nZXRHcmFkaWVudChjdHgsIHN0cm9rZSwgcmVjdCk7XG4gICAgICB9XG4gICAgfSAvLyBVc2UgdGhlIGdyYWRpZW50IG9yIHBhdHRlcm5cblxuXG4gICAgaWYgKGhhc0ZpbGxHcmFkaWVudCkge1xuICAgICAgLy8gUEVORElORyBJZiBtYXkgaGF2ZSBhZmZlY3QgdGhlIHN0YXRlXG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5fZmlsbEdyYWRpZW50O1xuICAgIH0gZWxzZSBpZiAoaGFzRmlsbFBhdHRlcm4pIHtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBnZXRDYW52YXNQYXR0ZXJuLmNhbGwoZmlsbCwgY3R4KTtcbiAgICB9XG5cbiAgICBpZiAoaGFzU3Ryb2tlR3JhZGllbnQpIHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuX3N0cm9rZUdyYWRpZW50O1xuICAgIH0gZWxzZSBpZiAoaGFzU3Ryb2tlUGF0dGVybikge1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZ2V0Q2FudmFzUGF0dGVybi5jYWxsKHN0cm9rZSwgY3R4KTtcbiAgICB9XG5cbiAgICB2YXIgbGluZURhc2ggPSBzdHlsZS5saW5lRGFzaDtcbiAgICB2YXIgbGluZURhc2hPZmZzZXQgPSBzdHlsZS5saW5lRGFzaE9mZnNldDtcbiAgICB2YXIgY3R4TGluZURhc2ggPSAhIWN0eC5zZXRMaW5lRGFzaDsgLy8gVXBkYXRlIHBhdGggc3gsIHN5XG5cbiAgICB2YXIgc2NhbGUgPSB0aGlzLmdldEdsb2JhbFNjYWxlKCk7XG4gICAgcGF0aC5zZXRTY2FsZShzY2FsZVswXSwgc2NhbGVbMV0pOyAvLyBQcm94eSBjb250ZXh0XG4gICAgLy8gUmVidWlsZCBwYXRoIGluIGZvbGxvd2luZyAyIGNhc2VzXG4gICAgLy8gMS4gUGF0aCBpcyBkaXJ0eVxuICAgIC8vIDIuIFBhdGggbmVlZHMgamF2YXNjcmlwdCBpbXBsZW1lbnRlZCBsaW5lRGFzaCBzdHJva2luZy5cbiAgICAvLyAgICBJbiB0aGlzIGNhc2UsIGxpbmVEYXNoIGluZm9ybWF0aW9uIHdpbGwgbm90IGJlIHNhdmVkIGluIFBhdGhQcm94eVxuXG4gICAgaWYgKHRoaXMuX19kaXJ0eVBhdGggfHwgbGluZURhc2ggJiYgIWN0eExpbmVEYXNoICYmIGhhc1N0cm9rZSkge1xuICAgICAgcGF0aC5iZWdpblBhdGgoY3R4KTsgLy8gU2V0dGluZyBsaW5lIGRhc2ggYmVmb3JlIGJ1aWxkIHBhdGhcblxuICAgICAgaWYgKGxpbmVEYXNoICYmICFjdHhMaW5lRGFzaCkge1xuICAgICAgICBwYXRoLnNldExpbmVEYXNoKGxpbmVEYXNoKTtcbiAgICAgICAgcGF0aC5zZXRMaW5lRGFzaE9mZnNldChsaW5lRGFzaE9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnVpbGRQYXRoKHBhdGgsIHRoaXMuc2hhcGUsIGZhbHNlKTsgLy8gQ2xlYXIgcGF0aCBkaXJ0eSBmbGFnXG5cbiAgICAgIGlmICh0aGlzLnBhdGgpIHtcbiAgICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXBsYXkgcGF0aCBidWlsZGluZ1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5wYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgfVxuXG4gICAgaGFzRmlsbCAmJiBwYXRoLmZpbGwoY3R4KTtcblxuICAgIGlmIChsaW5lRGFzaCAmJiBjdHhMaW5lRGFzaCkge1xuICAgICAgY3R4LnNldExpbmVEYXNoKGxpbmVEYXNoKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xuICAgIH1cblxuICAgIGhhc1N0cm9rZSAmJiBwYXRoLnN0cm9rZShjdHgpO1xuXG4gICAgaWYgKGxpbmVEYXNoICYmIGN0eExpbmVEYXNoKSB7XG4gICAgICAvLyBQRU5ESU5HXG4gICAgICAvLyBSZW1vdmUgbGluZURhc2hcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7IC8vIERyYXcgcmVjdCB0ZXh0XG5cbiAgICBpZiAoc3R5bGUudGV4dCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmRyYXdSZWN0VGV4dChjdHgsIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgIH1cbiAgfSxcbiAgLy8gV2hlbiBidW5kbGluZyBwYXRoLCBzb21lIHNoYXBlIG1heSBkZWNpZGUgaWYgdXNlIG1vdmVUbyB0byBiZWdpbiBhIG5ldyBzdWJwYXRoIG9yIGNsb3NlUGF0aFxuICAvLyBMaWtlIGluIGNpcmNsZVxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlQ2ZnLCBpbkJ1bmRsZSkge30sXG4gIGNyZWF0ZVBhdGhQcm94eTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucGF0aCA9IG5ldyBQYXRoUHJveHkoKTtcbiAgfSxcbiAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlY3QgPSB0aGlzLl9yZWN0O1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgdmFyIG5lZWRzVXBkYXRlUmVjdCA9ICFyZWN0O1xuXG4gICAgaWYgKG5lZWRzVXBkYXRlUmVjdCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG5cbiAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAvLyBDcmVhdGUgcGF0aCBvbiBkZW1hbmQuXG4gICAgICAgIHBhdGggPSB0aGlzLnBhdGggPSBuZXcgUGF0aFByb3h5KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9fZGlydHlQYXRoKSB7XG4gICAgICAgIHBhdGguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuYnVpbGRQYXRoKHBhdGgsIHRoaXMuc2hhcGUsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVjdCA9IHJlY3Q7XG5cbiAgICBpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgIC8vIE5lZWRzIHVwZGF0ZSByZWN0IHdpdGggc3Ryb2tlIGxpbmVXaWR0aCB3aGVuXG4gICAgICAvLyAxLiBFbGVtZW50IGNoYW5nZXMgc2NhbGUgb3IgbGluZVdpZHRoXG4gICAgICAvLyAyLiBTaGFwZSBpcyBjaGFuZ2VkXG4gICAgICB2YXIgcmVjdFdpdGhTdHJva2UgPSB0aGlzLl9yZWN0V2l0aFN0cm9rZSB8fCAodGhpcy5fcmVjdFdpdGhTdHJva2UgPSByZWN0LmNsb25lKCkpO1xuXG4gICAgICBpZiAodGhpcy5fX2RpcnR5IHx8IG5lZWRzVXBkYXRlUmVjdCkge1xuICAgICAgICByZWN0V2l0aFN0cm9rZS5jb3B5KHJlY3QpOyAvLyBGSVhNRSBNdXN0IGFmdGVyIHVwZGF0ZVRyYW5zZm9ybVxuXG4gICAgICAgIHZhciB3ID0gc3R5bGUubGluZVdpZHRoOyAvLyBQRU5ESU5HLCBNaW4gbGluZSB3aWR0aCBpcyBuZWVkZWQgd2hlbiBsaW5lIGlzIGhvcml6b250YWwgb3IgdmVydGljYWxcblxuICAgICAgICB2YXIgbGluZVNjYWxlID0gc3R5bGUuc3Ryb2tlTm9TY2FsZSA/IHRoaXMuZ2V0TGluZVNjYWxlKCkgOiAxOyAvLyBPbmx5IGFkZCBleHRyYSBob3ZlciBsaW5lV2lkdGggd2hlbiB0aGVyZSBhcmUgbm8gZmlsbFxuXG4gICAgICAgIGlmICghc3R5bGUuaGFzRmlsbCgpKSB7XG4gICAgICAgICAgdyA9IE1hdGgubWF4KHcsIHRoaXMuc3Ryb2tlQ29udGFpblRocmVzaG9sZCB8fCA0KTtcbiAgICAgICAgfSAvLyBDb25zaWRlciBsaW5lIHdpZHRoXG4gICAgICAgIC8vIExpbmUgc2NhbGUgY2FuJ3QgYmUgMDtcblxuXG4gICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLndpZHRoICs9IHcgLyBsaW5lU2NhbGU7XG4gICAgICAgICAgcmVjdFdpdGhTdHJva2UuaGVpZ2h0ICs9IHcgLyBsaW5lU2NhbGU7XG4gICAgICAgICAgcmVjdFdpdGhTdHJva2UueCAtPSB3IC8gbGluZVNjYWxlIC8gMjtcbiAgICAgICAgICByZWN0V2l0aFN0cm9rZS55IC09IHcgLyBsaW5lU2NhbGUgLyAyO1xuICAgICAgICB9XG4gICAgICB9IC8vIFJldHVybiByZWN0IHdpdGggc3Ryb2tlXG5cblxuICAgICAgcmV0dXJuIHJlY3RXaXRoU3Ryb2tlO1xuICAgIH1cblxuICAgIHJldHVybiByZWN0O1xuICB9LFxuICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHZhciBsb2NhbFBvcyA9IHRoaXMudHJhbnNmb3JtQ29vcmRUb0xvY2FsKHgsIHkpO1xuICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHggPSBsb2NhbFBvc1swXTtcbiAgICB5ID0gbG9jYWxQb3NbMV07XG5cbiAgICBpZiAocmVjdC5jb250YWluKHgsIHkpKSB7XG4gICAgICB2YXIgcGF0aERhdGEgPSB0aGlzLnBhdGguZGF0YTtcblxuICAgICAgaWYgKHN0eWxlLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICAgIHZhciBsaW5lU2NhbGUgPSBzdHlsZS5zdHJva2VOb1NjYWxlID8gdGhpcy5nZXRMaW5lU2NhbGUoKSA6IDE7IC8vIExpbmUgc2NhbGUgY2FuJ3QgYmUgMDtcblxuICAgICAgICBpZiAobGluZVNjYWxlID4gMWUtMTApIHtcbiAgICAgICAgICAvLyBPbmx5IGFkZCBleHRyYSBob3ZlciBsaW5lV2lkdGggd2hlbiB0aGVyZSBhcmUgbm8gZmlsbFxuICAgICAgICAgIGlmICghc3R5bGUuaGFzRmlsbCgpKSB7XG4gICAgICAgICAgICBsaW5lV2lkdGggPSBNYXRoLm1heChsaW5lV2lkdGgsIHRoaXMuc3Ryb2tlQ29udGFpblRocmVzaG9sZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhdGhDb250YWluLmNvbnRhaW5TdHJva2UocGF0aERhdGEsIGxpbmVXaWR0aCAvIGxpbmVTY2FsZSwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3R5bGUuaGFzRmlsbCgpKSB7XG4gICAgICAgIHJldHVybiBwYXRoQ29udGFpbi5jb250YWluKHBhdGhEYXRhLCB4LCB5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGRpcnR5UGF0aFxuICAgKi9cbiAgZGlydHk6IGZ1bmN0aW9uIChkaXJ0eVBhdGgpIHtcbiAgICBpZiAoZGlydHlQYXRoID09IG51bGwpIHtcbiAgICAgIGRpcnR5UGF0aCA9IHRydWU7XG4gICAgfSAvLyBPbmx5IG1hcmsgZGlydHksIG5vdCBtYXJrIGNsZWFuXG5cblxuICAgIGlmIChkaXJ0eVBhdGgpIHtcbiAgICAgIHRoaXMuX19kaXJ0eVBhdGggPSBkaXJ0eVBhdGg7XG4gICAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpOyAvLyBVc2VkIGFzIGEgY2xpcHBpbmcgcGF0aFxuXG4gICAgaWYgKHRoaXMuX19jbGlwVGFyZ2V0KSB7XG4gICAgICB0aGlzLl9fY2xpcFRhcmdldC5kaXJ0eSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWxpYXMgZm9yIGFuaW1hdGUoJ3NoYXBlJylcbiAgICogQHBhcmFtIHtib29sZWFufSBsb29wXG4gICAqL1xuICBhbmltYXRlU2hhcGU6IGZ1bmN0aW9uIChsb29wKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSgnc2hhcGUnLCBsb29wKTtcbiAgfSxcbiAgLy8gT3ZlcndyaXRlIGF0dHJLVlxuICBhdHRyS1Y6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgLy8gRklYTUVcbiAgICBpZiAoa2V5ID09PSAnc2hhcGUnKSB7XG4gICAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgICAgIHRoaXMuX19kaXJ0eVBhdGggPSB0cnVlO1xuICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIERpc3BsYXlhYmxlLnByb3RvdHlwZS5hdHRyS1YuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIHNldFNoYXBlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7IC8vIFBhdGggZnJvbSBzdHJpbmcgbWF5IG5vdCBoYXZlIHNoYXBlXG5cbiAgICBpZiAoc2hhcGUpIHtcbiAgICAgIGlmICh6clV0aWwuaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGtleSkge1xuICAgICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHNoYXBlW25hbWVdID0ga2V5W25hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2hhcGVba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRpcnR5KHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBnZXRMaW5lU2NhbGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtOyAvLyBHZXQgdGhlIGxpbmUgc2NhbGUuXG4gICAgLy8gRGV0ZXJtaW5hbnQgb2YgYG1gIG1lYW5zIGhvdyBtdWNoIHRoZSBhcmVhIGlzIGVubGFyZ2VkIGJ5IHRoZVxuICAgIC8vIHRyYW5zZm9ybWF0aW9uLiBTbyBpdHMgc3F1YXJlIHJvb3QgY2FuIGJlIHVzZWQgYXMgYSBzY2FsZSBmYWN0b3JcbiAgICAvLyBmb3Igd2lkdGguXG5cbiAgICByZXR1cm4gbSAmJiBhYnMobVswXSAtIDEpID4gMWUtMTAgJiYgYWJzKG1bM10gLSAxKSA+IDFlLTEwID8gTWF0aC5zcXJ0KGFicyhtWzBdICogbVszXSAtIG1bMl0gKiBtWzFdKSkgOiAxO1xuICB9XG59O1xuLyoqXG4gKiDmianlsZXkuIDkuKogUGF0aCBlbGVtZW50LCDmr5TlpoLmmJ/lvaLvvIzlnIbnrYnjgIJcbiAqIEV4dGVuZCBhIHBhdGggZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcHMudHlwZSBQYXRoIHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByb3BzLmluaXQgSW5pdGlhbGl6ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvcHMuYnVpbGRQYXRoIE92ZXJ3cml0ZSBidWlsZFBhdGggbWV0aG9kXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzLnN0eWxlXSBFeHRlbmRlZCBkZWZhdWx0IHN0eWxlIGNvbmZpZ1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5zaGFwZV0gRXh0ZW5kZWQgZGVmYXVsdCBzaGFwZSBjb25maWdcbiAqL1xuXG5QYXRoLmV4dGVuZCA9IGZ1bmN0aW9uIChkZWZhdWx0cykge1xuICB2YXIgU3ViID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICBQYXRoLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICBpZiAoZGVmYXVsdHMuc3R5bGUpIHtcbiAgICAgIC8vIEV4dGVuZCBkZWZhdWx0IHN0eWxlXG4gICAgICB0aGlzLnN0eWxlLmV4dGVuZEZyb20oZGVmYXVsdHMuc3R5bGUsIGZhbHNlKTtcbiAgICB9IC8vIEV4dGVuZCBkZWZhdWx0IHNoYXBlXG5cblxuICAgIHZhciBkZWZhdWx0U2hhcGUgPSBkZWZhdWx0cy5zaGFwZTtcblxuICAgIGlmIChkZWZhdWx0U2hhcGUpIHtcbiAgICAgIHRoaXMuc2hhcGUgPSB0aGlzLnNoYXBlIHx8IHt9O1xuICAgICAgdmFyIHRoaXNTaGFwZSA9IHRoaXMuc2hhcGU7XG5cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdFNoYXBlKSB7XG4gICAgICAgIGlmICghdGhpc1NoYXBlLmhhc093blByb3BlcnR5KG5hbWUpICYmIGRlZmF1bHRTaGFwZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHRoaXNTaGFwZVtuYW1lXSA9IGRlZmF1bHRTaGFwZVtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGRlZmF1bHRzLmluaXQgJiYgZGVmYXVsdHMuaW5pdC5jYWxsKHRoaXMsIG9wdHMpO1xuICB9O1xuXG4gIHpyVXRpbC5pbmhlcml0cyhTdWIsIFBhdGgpOyAvLyBGSVhNRSDkuI3og70gZXh0ZW5kIHBvc2l0aW9uLCByb3RhdGlvbiDnrYnlvJXnlKjlr7nosaFcblxuICBmb3IgKHZhciBuYW1lIGluIGRlZmF1bHRzKSB7XG4gICAgLy8gRXh0ZW5kaW5nIHByb3RvdHlwZSB2YWx1ZXMgYW5kIG1ldGhvZHNcbiAgICBpZiAobmFtZSAhPT0gJ3N0eWxlJyAmJiBuYW1lICE9PSAnc2hhcGUnKSB7XG4gICAgICBTdWIucHJvdG90eXBlW25hbWVdID0gZGVmYXVsdHNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFN1Yjtcbn07XG5cbnpyVXRpbC5pbmhlcml0cyhQYXRoLCBEaXNwbGF5YWJsZSk7XG52YXIgX2RlZmF1bHQgPSBQYXRoO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9QYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgU3R5bGUgPSByZXF1aXJlKFwiLi9TdHlsZVwiKTtcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKFwiLi4vRWxlbWVudFwiKTtcblxudmFyIFJlY3RUZXh0ID0gcmVxdWlyZShcIi4vbWl4aW4vUmVjdFRleHRcIik7XG5cbi8qKlxuICog5Y+v57uY5Yi255qE5Zu+5b2i5Z+657G7XG4gKiBCYXNlIGNsYXNzIG9mIGFsbCBkaXNwbGF5YWJsZSBncmFwaGljIG9iamVjdHNcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKi9cblxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvRWxlbWVudFxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9taXhpbi9SZWN0VGV4dFxuICovXG5mdW5jdGlvbiBEaXNwbGF5YWJsZShvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBFbGVtZW50LmNhbGwodGhpcywgb3B0cyk7IC8vIEV4dGVuZCBwcm9wZXJ0aWVzXG5cbiAgZm9yICh2YXIgbmFtZSBpbiBvcHRzKSB7XG4gICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgbmFtZSAhPT0gJ3N0eWxlJykge1xuICAgICAgdGhpc1tuYW1lXSA9IG9wdHNbbmFtZV07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9TdHlsZX1cbiAgICovXG5cblxuICB0aGlzLnN0eWxlID0gbmV3IFN0eWxlKG9wdHMuc3R5bGUsIHRoaXMpO1xuICB0aGlzLl9yZWN0ID0gbnVsbDsgLy8gU2hhcGVzIGZvciBjYXNjYWRlIGNsaXBwaW5nLlxuXG4gIHRoaXMuX19jbGlwUGF0aHMgPSBbXTsgLy8gRklYTUUgU3RhdGVmdWwgbXVzdCBiZSBtaXhpbmVkIGFmdGVyIHN0eWxlIGlzIHNldHRlZFxuICAvLyBTdGF0ZWZ1bC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG5EaXNwbGF5YWJsZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBEaXNwbGF5YWJsZSxcbiAgdHlwZTogJ2Rpc3BsYXlhYmxlJyxcblxuICAvKipcbiAgICogRGlzcGxheWFibGUg5piv5ZCm5Li66ISP77yMUGFpbnRlciDkuK3kvJrmoLnmja7or6XmoIforrDliKTmlq3mmK/lkKbpnIDopoHmmK/lkKbpnIDopoHph43mlrDnu5jliLZcbiAgICogRGlydHkgZmxhZy4gRnJvbSB3aGljaCBwYWludGVyIHdpbGwgZGV0ZXJtaW5lIGlmIHRoaXMgZGlzcGxheWFibGUgb2JqZWN0IG5lZWRzIGJydXNoXG4gICAqIEBuYW1lIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjX19kaXJ0eVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIF9fZGlydHk6IHRydWUsXG5cbiAgLyoqXG4gICAqIOWbvuW9ouaYr+WQpuWPr+inge+8jOS4unRydWXml7bkuI3nu5jliLblm77lvaLvvIzkvYbmmK/ku43og73op6blj5HpvKDmoIfkuovku7ZcbiAgICogSWYgaWdub3JlIGRyYXdpbmcgb2YgdGhlIGRpc3BsYXlhYmxlIG9iamVjdC4gTW91c2UgZXZlbnQgd2lsbCBzdGlsbCBiZSB0cmlnZ2VyZWRcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjaW52aXNpYmxlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgaW52aXNpYmxlOiBmYWxzZSxcblxuICAvKipcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjelxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICB6OiAwLFxuXG4gIC8qKlxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIHoyOiAwLFxuXG4gIC8qKlxuICAgKiB65bGCbGV2ZWzvvIzlhrPlrprnu5jnlLvlnKjlk6rlsYJjYW52YXPkuK1cbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjemxldmVsXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIHpsZXZlbDogMCxcblxuICAvKipcbiAgICog5piv5ZCm5Y+v5ouW5ou9XG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2RyYWdnYWJsZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRyYWdnYWJsZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIOaYr+WQpuato+WcqOaLluaLvVxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNkcmFnZ2FibGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkcmFnZ2luZzogZmFsc2UsXG5cbiAgLyoqXG4gICAqIOaYr+WQpuebuOW6lOm8oOagh+S6i+S7tlxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNzaWxlbnRcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBJZiBlbmFibGUgY3VsbGluZ1xuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGN1bGxpbmc6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBNb3VzZSBjdXJzb3Igd2hlbiBob3ZlcmVkXG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2N1cnNvclxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgY3Vyc29yOiAncG9pbnRlcicsXG5cbiAgLyoqXG4gICAqIElmIGhvdmVyIGFyZWEgaXMgYm91bmRpbmcgcmVjdFxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNyZWN0SG92ZXJcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHJlY3RIb3ZlcjogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgZWxlbWVudCBwcm9ncmVzc2l2ZWx5IHdoZW4gdGhlIHZhbHVlID49IDAsXG4gICAqIHVzZWZ1bGwgZm9yIGxhcmdlIGRhdGEuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBwcm9ncmVzc2l2ZTogLTEsXG4gIGJlZm9yZUJydXNoOiBmdW5jdGlvbiAoY3R4KSB7fSxcbiAgYWZ0ZXJCcnVzaDogZnVuY3Rpb24gKGN0eCkge30sXG5cbiAgLyoqXG4gICAqIOWbvuW9oue7mOWItuaWueazlVxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqL1xuICAvLyBJbnRlcmZhY2VcbiAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge30sXG5cbiAgLyoqXG4gICAqIOiOt+WPluacgOWwj+WMheWbtOebklxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICovXG4gIC8vIEludGVyZmFjZVxuICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIC8qKlxuICAgKiDliKTmlq3lnZDmoIcgeCwgeSDmmK/lkKblnKjlm77lvaLkuIpcbiAgICogSWYgZGlzcGxheWFibGUgZWxlbWVudCBjb250YWluIGNvb3JkIHgsIHlcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgY29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5yZWN0Q29udGFpbih4LCB5KTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAqL1xuICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgY2IuY2FsbChjb250ZXh0LCB0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICog5Yik5pat5Z2Q5qCHIHgsIHkg5piv5ZCm5Zyo5Zu+5b2i55qE5YyF5Zu055uS5LiKXG4gICAqIElmIGJvdW5kaW5nIHJlY3Qgb2YgZWxlbWVudCBjb250YWluIGNvb3JkIHgsIHlcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgcmVjdENvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIGNvb3JkID0gdGhpcy50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHJldHVybiByZWN0LmNvbnRhaW4oY29vcmRbMF0sIGNvb3JkWzFdKTtcbiAgfSxcblxuICAvKipcbiAgICog5qCH6K6w5Zu+5b2i5YWD57Sg5Li66ISP77yM5bm25LiU5Zyo5LiL5LiA5bin6YeN57uYXG4gICAqIE1hcmsgZGlzcGxheWFibGUgZWxlbWVudCBkaXJ0eSBhbmQgcmVmcmVzaCBuZXh0IGZyYW1lXG4gICAqL1xuICBkaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fcmVjdCA9IG51bGw7XG4gICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWbvuW9ouaYr+WQpuS8muinpuWPkeS6i+S7tlxuICAgKiBJZiBkaXNwbGF5YWJsZSBvYmplY3QgYmluZGVkIGFueSBldmVudFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgLy8gVE9ETywg6YCa6L+HIGJpbmQg57uR5a6a55qE5LqL5Lu2XG4gIC8vIGlzU2lsZW50OiBmdW5jdGlvbiAoKSB7XG4gIC8vICAgICByZXR1cm4gIShcbiAgLy8gICAgICAgICB0aGlzLmhvdmVyYWJsZSB8fCB0aGlzLmRyYWdnYWJsZVxuICAvLyAgICAgICAgIHx8IHRoaXMub25tb3VzZW1vdmUgfHwgdGhpcy5vbm1vdXNlb3ZlciB8fCB0aGlzLm9ubW91c2VvdXRcbiAgLy8gICAgICAgICB8fCB0aGlzLm9ubW91c2Vkb3duIHx8IHRoaXMub25tb3VzZXVwIHx8IHRoaXMub25jbGlja1xuICAvLyAgICAgICAgIHx8IHRoaXMub25kcmFnZW50ZXIgfHwgdGhpcy5vbmRyYWdvdmVyIHx8IHRoaXMub25kcmFnbGVhdmVcbiAgLy8gICAgICAgICB8fCB0aGlzLm9uZHJvcFxuICAvLyAgICAgKTtcbiAgLy8gfSxcblxuICAvKipcbiAgICogQWxpYXMgZm9yIGFuaW1hdGUoJ3N0eWxlJylcbiAgICogQHBhcmFtIHtib29sZWFufSBsb29wXG4gICAqL1xuICBhbmltYXRlU3R5bGU6IGZ1bmN0aW9uIChsb29wKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSgnc3R5bGUnLCBsb29wKTtcbiAgfSxcbiAgYXR0cktWOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgIT09ICdzdHlsZScpIHtcbiAgICAgIEVsZW1lbnQucHJvdG90eXBlLmF0dHJLVi5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0eWxlLnNldCh2YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICBzZXRTdHlsZTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLnN0eWxlLnNldChrZXksIHZhbHVlKTtcbiAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogVXNlIGdpdmVuIHN0eWxlIG9iamVjdFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9ialxuICAgKi9cbiAgdXNlU3R5bGU6IGZ1bmN0aW9uIChvYmopIHtcbiAgICB0aGlzLnN0eWxlID0gbmV3IFN0eWxlKG9iaiwgdGhpcyk7XG4gICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG56clV0aWwuaW5oZXJpdHMoRGlzcGxheWFibGUsIEVsZW1lbnQpO1xuenJVdGlsLm1peGluKERpc3BsYXlhYmxlLCBSZWN0VGV4dCk7IC8vIHpyVXRpbC5taXhpbihEaXNwbGF5YWJsZSwgU3RhdGVmdWwpO1xuXG52YXIgX2RlZmF1bHQgPSBEaXNwbGF5YWJsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvRGlzcGxheWFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNUWUxFX0NPTU1PTl9QUk9QUyA9IFtbJ3NoYWRvd0JsdXInLCAwXSwgWydzaGFkb3dPZmZzZXRYJywgMF0sIFsnc2hhZG93T2Zmc2V0WScsIDBdLCBbJ3NoYWRvd0NvbG9yJywgJyMwMDAnXSwgWydsaW5lQ2FwJywgJ2J1dHQnXSwgWydsaW5lSm9pbicsICdtaXRlciddLCBbJ21pdGVyTGltaXQnLCAxMF1dOyAvLyB2YXIgU0hBRE9XX1BST1BTID0gU1RZTEVfQ09NTU9OX1BST1BTLnNsaWNlKDAsIDQpO1xuLy8gdmFyIExJTkVfUFJPUFMgPSBTVFlMRV9DT01NT05fUFJPUFMuc2xpY2UoNCk7XG5cbnZhciBTdHlsZSA9IGZ1bmN0aW9uIChvcHRzLCBob3N0KSB7XG4gIHRoaXMuZXh0ZW5kRnJvbShvcHRzLCBmYWxzZSk7XG4gIHRoaXMuaG9zdCA9IGhvc3Q7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVMaW5lYXJHcmFkaWVudChjdHgsIG9iaiwgcmVjdCkge1xuICB2YXIgeCA9IG9iai54ID09IG51bGwgPyAwIDogb2JqLng7XG4gIHZhciB4MiA9IG9iai54MiA9PSBudWxsID8gMSA6IG9iai54MjtcbiAgdmFyIHkgPSBvYmoueSA9PSBudWxsID8gMCA6IG9iai55O1xuICB2YXIgeTIgPSBvYmoueTIgPT0gbnVsbCA/IDAgOiBvYmoueTI7XG5cbiAgaWYgKCFvYmouZ2xvYmFsKSB7XG4gICAgeCA9IHggKiByZWN0LndpZHRoICsgcmVjdC54O1xuICAgIHgyID0geDIgKiByZWN0LndpZHRoICsgcmVjdC54O1xuICAgIHkgPSB5ICogcmVjdC5oZWlnaHQgKyByZWN0Lnk7XG4gICAgeTIgPSB5MiAqIHJlY3QuaGVpZ2h0ICsgcmVjdC55O1xuICB9XG5cbiAgdmFyIGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgsIHksIHgyLCB5Mik7XG4gIHJldHVybiBjYW52YXNHcmFkaWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmFkaWFsR3JhZGllbnQoY3R4LCBvYmosIHJlY3QpIHtcbiAgdmFyIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICB2YXIgbWluID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG4gIHZhciB4ID0gb2JqLnggPT0gbnVsbCA/IDAuNSA6IG9iai54O1xuICB2YXIgeSA9IG9iai55ID09IG51bGwgPyAwLjUgOiBvYmoueTtcbiAgdmFyIHIgPSBvYmouciA9PSBudWxsID8gMC41IDogb2JqLnI7XG5cbiAgaWYgKCFvYmouZ2xvYmFsKSB7XG4gICAgeCA9IHggKiB3aWR0aCArIHJlY3QueDtcbiAgICB5ID0geSAqIGhlaWdodCArIHJlY3QueTtcbiAgICByID0gciAqIG1pbjtcbiAgfVxuXG4gIHZhciBjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh4LCB5LCAwLCB4LCB5LCByKTtcbiAgcmV0dXJuIGNhbnZhc0dyYWRpZW50O1xufVxuXG5TdHlsZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBTdHlsZSxcblxuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGV9XG4gICAqL1xuICBob3N0OiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZmlsbDogJyMwMDAnLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3Ryb2tlOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgb3BhY2l0eTogMSxcblxuICAvKipcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgbGluZURhc2g6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBsaW5lRGFzaE9mZnNldDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHNoYWRvd0JsdXI6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzaGFkb3dPZmZzZXRYOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc2hhZG93T2Zmc2V0WTogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGxpbmVXaWR0aDogMSxcblxuICAvKipcbiAgICogSWYgc3Ryb2tlIGlnbm9yZSBzY2FsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHN0cm9rZU5vU2NhbGU6IGZhbHNlLFxuICAvLyBCb3VuZGluZyByZWN0IHRleHQgY29uZmlndXJhdGlvblxuICAvLyBOb3QgYWZmZWN0ZWQgYnkgZWxlbWVudCB0cmFuc2Zvcm1cblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIElmIGBmb250U2l6ZWAgb3IgYGZvbnRGYW1pbHlgIGV4aXN0cywgYGZvbnRgIHdpbGwgYmUgcmVzZXQgYnlcbiAgICogYGZvbnRTaXplYCwgYGZvbnRTdHlsZWAsIGBmb250V2VpZ2h0YCwgYGZvbnRGYW1pbHlgLlxuICAgKiBTbyBkbyBub3QgdmlzaXQgaXQgZGlyZWN0bHkgaW4gdXBwZXIgYXBwbGljYXRpb24gKGxpa2UgZWNoYXJ0cyksXG4gICAqIGJ1dCB1c2UgYGNvbnRhaW4vdGV4dCNtYWtlRm9udGAgaW5zdGVhZC5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGZvbnQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIFRoZSBzYW1lIGFzIGZvbnQuIFVzZSBmb250IHBsZWFzZS5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRGb250OiBudWxsLFxuXG4gIC8qKlxuICAgKiBJdCBoZWxwcyBtZXJnaW5nIHJlc3BlY3RpdmVseSwgcmF0aGVyIHRoYW4gcGFyc2luZyBhbiBlbnRpcmUgZm9udCBzdHJpbmcuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBmb250U3R5bGU6IG51bGwsXG5cbiAgLyoqXG4gICAqIEl0IGhlbHBzIG1lcmdpbmcgcmVzcGVjdGl2ZWx5LCByYXRoZXIgdGhhbiBwYXJzaW5nIGFuIGVudGlyZSBmb250IHN0cmluZy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGZvbnRXZWlnaHQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIEl0IGhlbHBzIG1lcmdpbmcgcmVzcGVjdGl2ZWx5LCByYXRoZXIgdGhhbiBwYXJzaW5nIGFuIGVudGlyZSBmb250IHN0cmluZy5cbiAgICogU2hvdWxkIGJlIDEyIGJ1dCBub3QgJzEycHgnLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZm9udFNpemU6IG51bGwsXG5cbiAgLyoqXG4gICAqIEl0IGhlbHBzIG1lcmdpbmcgcmVzcGVjdGl2ZWx5LCByYXRoZXIgdGhhbiBwYXJzaW5nIGFuIGVudGlyZSBmb250IHN0cmluZy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGZvbnRGYW1pbHk6IG51bGwsXG5cbiAgLyoqXG4gICAqIFJlc2VydmVkIGZvciBzcGVjaWFsIGZ1bmN0aW5hbGl0eSwgbGlrZSAnaHInLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dFRhZzogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRGaWxsOiAnIzAwMCcsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0U3Ryb2tlOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dFdpZHRoOiBudWxsLFxuXG4gIC8qKlxuICAgKiBPbmx5IGZvciB0ZXh0QmFja2dyb3VuZC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRIZWlnaHQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIHRleHRTdHJva2UgbWF5IGJlIHNldCBhcyBzb21lIGNvbG9yIGFzIGEgZGVmYXVsdFxuICAgKiB2YWx1ZSBpbiB1cHBlciBhcHBsaWNhaW9uLCB3aGVyZSB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgKiBvZiB0ZXh0U3Ryb2tlV2lkdGggc2hvdWxkIGJlIDAgdG8gbWFrZSBzdXJlIHRoYXRcbiAgICogdXNlciBjYW4gY2hvb3NlIHRvIGRvIG5vdCB1c2UgdGV4dCBzdHJva2UuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0U3Ryb2tlV2lkdGg6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0TGluZUhlaWdodDogbnVsbCxcblxuICAvKipcbiAgICogJ2luc2lkZScsICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXG4gICAqIFt4LCB5XVxuICAgKiBCYXNlZCBvbiB4LCB5IG9mIHJlY3QuXG4gICAqIEB0eXBlIHtzdHJpbmd8QXJyYXkuPG51bWJlcj59XG4gICAqIEBkZWZhdWx0ICdpbnNpZGUnXG4gICAqL1xuICB0ZXh0UG9zaXRpb246ICdpbnNpZGUnLFxuXG4gIC8qKlxuICAgKiBJZiBub3Qgc3BlY2lmaWVkLCB1c2UgdGhlIGJvdW5kaW5nUmVjdCBvZiBhIGBkaXNwbGF5YWJsZWAuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB0ZXh0UmVjdDogbnVsbCxcblxuICAvKipcbiAgICogW3gsIHldXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIHRleHRPZmZzZXQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0QWxpZ246IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0VmVydGljYWxBbGlnbjogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHREaXN0YW5jZTogNSxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRTaGFkb3dDb2xvcjogJ3RyYW5zcGFyZW50JyxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRTaGFkb3dCbHVyOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dFNoYWRvd09mZnNldFg6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0U2hhZG93T2Zmc2V0WTogMCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRCb3hTaGFkb3dDb2xvcjogJ3RyYW5zcGFyZW50JyxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRCb3hTaGFkb3dCbHVyOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dEJveFNoYWRvd09mZnNldFg6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0Qm94U2hhZG93T2Zmc2V0WTogMCxcblxuICAvKipcbiAgICogV2hldGhlciB0cmFuc2Zvcm0gdGV4dC5cbiAgICogT25seSB1c2VmdWwgaW4gUGF0aCBhbmQgSW1hZ2UgZWxlbWVudFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRyYW5zZm9ybVRleHQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBUZXh0IHJvdGF0ZSBhcm91bmQgcG9zaXRpb24gb2YgUGF0aCBvciBJbWFnZVxuICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50IGFuZCB0cmFuc2Zvcm1UZXh0IGlzIGZhbHNlLlxuICAgKi9cbiAgdGV4dFJvdGF0aW9uOiAwLFxuXG4gIC8qKlxuICAgKiBUZXh0IG9yaWdpbiBvZiB0ZXh0IHJvdGF0aW9uLCBsaWtlIFsxMCwgNDBdLlxuICAgKiBCYXNlZCBvbiB4LCB5IG9mIHJlY3QuXG4gICAqIFVzZWZ1bCBpbiBsYWJlbCByb3RhdGlvbiBvZiBjaXJjdWxhciBzeW1ib2wuXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgb3JpZ2luIGlzIHRleHRQb3NpdGlvbi5cbiAgICogQ2FuIGJlICdjZW50ZXInLlxuICAgKiBAdHlwZSB7c3RyaW5nfEFycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgdGV4dE9yaWdpbjogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRCYWNrZ3JvdW5kQ29sb3I6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0Qm9yZGVyQ29sb3I6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0Qm9yZGVyV2lkdGg6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0Qm9yZGVyUmFkaXVzOiAwLFxuXG4gIC8qKlxuICAgKiBDYW4gYmUgYDJgIG9yIGBbMiwgNF1gIG9yIGBbMiwgMywgNCwgNV1gXG4gICAqIEB0eXBlIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICB0ZXh0UGFkZGluZzogbnVsbCxcblxuICAvKipcbiAgICogVGV4dCBzdHlsZXMgZm9yIHJpY2ggdGV4dC5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHJpY2g6IG51bGwsXG5cbiAgLyoqXG4gICAqIHtvdXRlcldpZHRoLCBvdXRlckhlaWdodCwgZWxsaXBzaXMsIHBsYWNlaG9sZGVyfVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdHJ1bmNhdGU6IG51bGwsXG5cbiAgLyoqXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBibGVuZDogbnVsbCxcblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKi9cbiAgYmluZDogZnVuY3Rpb24gKGN0eCwgZWwsIHByZXZFbCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXM7XG4gICAgdmFyIHByZXZTdHlsZSA9IHByZXZFbCAmJiBwcmV2RWwuc3R5bGU7XG4gICAgdmFyIGZpcnN0RHJhdyA9ICFwcmV2U3R5bGU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFNUWUxFX0NPTU1PTl9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBTVFlMRV9DT01NT05fUFJPUFNbaV07XG4gICAgICB2YXIgc3R5bGVOYW1lID0gcHJvcFswXTtcblxuICAgICAgaWYgKGZpcnN0RHJhdyB8fCBzdHlsZVtzdHlsZU5hbWVdICE9PSBwcmV2U3R5bGVbc3R5bGVOYW1lXSkge1xuICAgICAgICAvLyBGSVhNRSBJbnZhbGlkIHByb3BlcnR5IHZhbHVlIHdpbGwgY2F1c2Ugc3R5bGUgbGVhayBmcm9tIHByZXZpb3VzIGVsZW1lbnQuXG4gICAgICAgIGN0eFtzdHlsZU5hbWVdID0gc3R5bGVbc3R5bGVOYW1lXSB8fCBwcm9wWzFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmaXJzdERyYXcgfHwgc3R5bGUuZmlsbCAhPT0gcHJldlN0eWxlLmZpbGwpIHtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBzdHlsZS5maWxsO1xuICAgIH1cblxuICAgIGlmIChmaXJzdERyYXcgfHwgc3R5bGUuc3Ryb2tlICE9PSBwcmV2U3R5bGUuc3Ryb2tlKSB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5zdHJva2U7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0RHJhdyB8fCBzdHlsZS5vcGFjaXR5ICE9PSBwcmV2U3R5bGUub3BhY2l0eSkge1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3R5bGUub3BhY2l0eSA9PSBudWxsID8gMSA6IHN0eWxlLm9wYWNpdHk7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0RHJhdyB8fCBzdHlsZS5ibGVuZCAhPT0gcHJldlN0eWxlLmJsZW5kKSB7XG4gICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gc3R5bGUuYmxlbmQgfHwgJ3NvdXJjZS1vdmVyJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNTdHJva2UoKSkge1xuICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGggLyAodGhpcy5zdHJva2VOb1NjYWxlICYmIGVsICYmIGVsLmdldExpbmVTY2FsZSA/IGVsLmdldExpbmVTY2FsZSgpIDogMSk7XG4gICAgfVxuICB9LFxuICBoYXNGaWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZpbGwgPSB0aGlzLmZpbGw7XG4gICAgcmV0dXJuIGZpbGwgIT0gbnVsbCAmJiBmaWxsICE9PSAnbm9uZSc7XG4gIH0sXG4gIGhhc1N0cm9rZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHJva2UgPSB0aGlzLnN0cm9rZTtcbiAgICByZXR1cm4gc3Ryb2tlICE9IG51bGwgJiYgc3Ryb2tlICE9PSAnbm9uZScgJiYgdGhpcy5saW5lV2lkdGggPiAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHRlbmQgZnJvbSBvdGhlciBzdHlsZVxuICAgKiBAcGFyYW0ge3pyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gb3RoZXJTdHlsZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJ3cml0ZSB0cnVlOiBvdmVyd3JpcnRlIGFueSB3YXkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlOiBvdmVyd3JpdGUgb25seSB3aGVuICF0YXJnZXQuaGFzT3duUHJvcGVydHlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJzOiBvdmVyd3JpdGUgd2hlbiBwcm9wZXJ0eSBpcyBub3QgbnVsbC91bmRlZmluZWQuXG4gICAqL1xuICBleHRlbmRGcm9tOiBmdW5jdGlvbiAob3RoZXJTdHlsZSwgb3ZlcndyaXRlKSB7XG4gICAgaWYgKG90aGVyU3R5bGUpIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gb3RoZXJTdHlsZSkge1xuICAgICAgICBpZiAob3RoZXJTdHlsZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAob3ZlcndyaXRlID09PSB0cnVlIHx8IChvdmVyd3JpdGUgPT09IGZhbHNlID8gIXRoaXMuaGFzT3duUHJvcGVydHkobmFtZSkgOiBvdGhlclN0eWxlW25hbWVdICE9IG51bGwpKSkge1xuICAgICAgICAgIHRoaXNbbmFtZV0gPSBvdGhlclN0eWxlW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBCYXRjaCBzZXR0aW5nIHN0eWxlIHdpdGggYSBnaXZlbiBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBvYmpcbiAgICogQHBhcmFtIHsqfSBbb2JqXVxuICAgKi9cbiAgc2V0OiBmdW5jdGlvbiAob2JqLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpc1tvYmpdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXh0ZW5kRnJvbShvYmosIHRydWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2xvbmVcbiAgICogQHJldHVybiB7enJlbmRlci9ncmFwaGljL1N0eWxlfSBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZXdTdHlsZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgbmV3U3R5bGUuZXh0ZW5kRnJvbSh0aGlzLCB0cnVlKTtcbiAgICByZXR1cm4gbmV3U3R5bGU7XG4gIH0sXG4gIGdldEdyYWRpZW50OiBmdW5jdGlvbiAoY3R4LCBvYmosIHJlY3QpIHtcbiAgICB2YXIgbWV0aG9kID0gb2JqLnR5cGUgPT09ICdyYWRpYWwnID8gY3JlYXRlUmFkaWFsR3JhZGllbnQgOiBjcmVhdGVMaW5lYXJHcmFkaWVudDtcbiAgICB2YXIgY2FudmFzR3JhZGllbnQgPSBtZXRob2QoY3R4LCBvYmosIHJlY3QpO1xuICAgIHZhciBjb2xvclN0b3BzID0gb2JqLmNvbG9yU3RvcHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yU3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhbnZhc0dyYWRpZW50LmFkZENvbG9yU3RvcChjb2xvclN0b3BzW2ldLm9mZnNldCwgY29sb3JTdG9wc1tpXS5jb2xvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbnZhc0dyYWRpZW50O1xuICB9XG59O1xudmFyIHN0eWxlUHJvdG8gPSBTdHlsZS5wcm90b3R5cGU7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgU1RZTEVfQ09NTU9OX1BST1BTLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBwcm9wID0gU1RZTEVfQ09NTU9OX1BST1BTW2ldO1xuXG4gIGlmICghKHByb3BbMF0gaW4gc3R5bGVQcm90bykpIHtcbiAgICBzdHlsZVByb3RvW3Byb3BbMF1dID0gcHJvcFsxXTtcbiAgfVxufSAvLyBQcm92aWRlIGZvciBvdGhlcnNcblxuXG5TdHlsZS5nZXRHcmFkaWVudCA9IHN0eWxlUHJvdG8uZ2V0R3JhZGllbnQ7XG52YXIgX2RlZmF1bHQgPSBTdHlsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvU3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGd1aWQgPSByZXF1aXJlKFwiLi9jb3JlL2d1aWRcIik7XG5cbnZhciBFdmVudGZ1bCA9IHJlcXVpcmUoXCIuL21peGluL0V2ZW50ZnVsXCIpO1xuXG52YXIgVHJhbnNmb3JtYWJsZSA9IHJlcXVpcmUoXCIuL21peGluL1RyYW5zZm9ybWFibGVcIik7XG5cbnZhciBBbmltYXRhYmxlID0gcmVxdWlyZShcIi4vbWl4aW4vQW5pbWF0YWJsZVwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvRWxlbWVudFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vQW5pbWF0YWJsZX1cbiAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfVxuICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsfVxuICovXG52YXIgRWxlbWVudCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICBUcmFuc2Zvcm1hYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gIEV2ZW50ZnVsLmNhbGwodGhpcywgb3B0cyk7XG4gIEFuaW1hdGFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbiAgLyoqXG4gICAqIOeUu+W4g+WFg+e0oElEXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuXG4gIHRoaXMuaWQgPSBvcHRzLmlkIHx8IGd1aWQoKTtcbn07XG5cbkVsZW1lbnQucHJvdG90eXBlID0ge1xuICAvKipcbiAgICog5YWD57Sg57G75Z6LXG4gICAqIEVsZW1lbnQgdHlwZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdHlwZTogJ2VsZW1lbnQnLFxuXG4gIC8qKlxuICAgKiDlhYPntKDlkI3lrZdcbiAgICogRWxlbWVudCBuYW1lXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBuYW1lOiAnJyxcblxuICAvKipcbiAgICogWlJlbmRlciDlrp7kvovlr7nosaHvvIzkvJrlnKggZWxlbWVudCDmt7vliqDliLAgenJlbmRlciDlrp7kvovkuK3lkI7oh6rliqjotYvlgLxcbiAgICogWlJlbmRlciBpbnN0YW5jZSB3aWxsIGJlIGFzc2lnbmVkIHdoZW4gZWxlbWVudCBpcyBhc3NvY2lhdGVkIHdpdGggenJlbmRlclxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvRWxlbWVudCNfX3pyXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICAgKi9cbiAgX196cjogbnVsbCxcblxuICAvKipcbiAgICog5Zu+5b2i5piv5ZCm5b+955Wl77yM5Li6dHJ1ZeaXtuW/veeVpeWbvuW9oueahOe7mOWItuS7peWPiuS6i+S7tuinpuWPkVxuICAgKiBJZiBpZ25vcmUgZHJhd2luZyBhbmQgZXZlbnRzIG9mIHRoZSBlbGVtZW50IG9iamVjdFxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvRWxlbWVudCNpZ25vcmVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBpZ25vcmU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiDnlKjkuo7oo4HliarnmoTot6/lvoQoc2hhcGUp77yM5omA5pyJIEdyb3VwIOWGheeahOi3r+W+hOWcqOe7mOWItuaXtumDveS8muiiq+i/meS4qui3r+W+hOijgeWJqlxuICAgKiDor6Xot6/lvoTkvJrnu6fmib/ooqvoo4Hlh4/lr7nosaHnmoTlj5jmjaJcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH1cbiAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yZGNvbnRleHQvI2NsaXBwaW5nLXJlZ2lvblxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIGNsaXBQYXRoOiBudWxsLFxuXG4gIC8qKlxuICAgKiBEcmlmdCBlbGVtZW50XG4gICAqIEBwYXJhbSAge251bWJlcn0gZHggZHggb24gdGhlIGdsb2JhbCBzcGFjZVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR5IGR5IG9uIHRoZSBnbG9iYWwgc3BhY2VcbiAgICovXG4gIGRyaWZ0OiBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gICAgc3dpdGNoICh0aGlzLmRyYWdnYWJsZSkge1xuICAgICAgY2FzZSAnaG9yaXpvbnRhbCc6XG4gICAgICAgIGR5ID0gMDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgICAgZHggPSAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gICAgaWYgKCFtKSB7XG4gICAgICBtID0gdGhpcy50cmFuc2Zvcm0gPSBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgfVxuXG4gICAgbVs0XSArPSBkeDtcbiAgICBtWzVdICs9IGR5O1xuICAgIHRoaXMuZGVjb21wb3NlVHJhbnNmb3JtKCk7XG4gICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhvb2sgYmVmb3JlIHVwZGF0ZVxuICAgKi9cbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiAoKSB7fSxcblxuICAvKipcbiAgICogSG9vayBhZnRlciB1cGRhdGVcbiAgICovXG4gIGFmdGVyVXBkYXRlOiBmdW5jdGlvbiAoKSB7fSxcblxuICAvKipcbiAgICogVXBkYXRlIGVhY2ggZnJhbWVcbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgKi9cbiAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge30sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5ID09PSAncG9zaXRpb24nIHx8IGtleSA9PT0gJ3NjYWxlJyB8fCBrZXkgPT09ICdvcmlnaW4nKSB7XG4gICAgICAvLyBDb3B5IHRoZSBhcnJheVxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzW2tleV07XG5cbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICB0YXJnZXQgPSB0aGlzW2tleV0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldFswXSA9IHZhbHVlWzBdO1xuICAgICAgICB0YXJnZXRbMV0gPSB2YWx1ZVsxXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBlbGVtZW50XG4gICAqL1xuICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pZ25vcmUgPSB0cnVlO1xuICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBlbGVtZW50XG4gICAqL1xuICBzaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pZ25vcmUgPSBmYWxzZTtcbiAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBrZXlcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgYXR0cjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuYXR0cktWKGtleSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoenJVdGlsLmlzT2JqZWN0KGtleSkpIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICB0aGlzLmF0dHJLVihuYW1lLCBrZXlbbmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRofSBjbGlwUGF0aFxuICAgKi9cbiAgc2V0Q2xpcFBhdGg6IGZ1bmN0aW9uIChjbGlwUGF0aCkge1xuICAgIHZhciB6ciA9IHRoaXMuX196cjtcblxuICAgIGlmICh6cikge1xuICAgICAgY2xpcFBhdGguYWRkU2VsZlRvWnIoenIpO1xuICAgIH0gLy8gUmVtb3ZlIHByZXZpb3VzIGNsaXAgcGF0aFxuXG5cbiAgICBpZiAodGhpcy5jbGlwUGF0aCAmJiB0aGlzLmNsaXBQYXRoICE9PSBjbGlwUGF0aCkge1xuICAgICAgdGhpcy5yZW1vdmVDbGlwUGF0aCgpO1xuICAgIH1cblxuICAgIHRoaXMuY2xpcFBhdGggPSBjbGlwUGF0aDtcbiAgICBjbGlwUGF0aC5fX3pyID0genI7XG4gICAgY2xpcFBhdGguX19jbGlwVGFyZ2V0ID0gdGhpcztcbiAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICovXG4gIHJlbW92ZUNsaXBQYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNsaXBQYXRoID0gdGhpcy5jbGlwUGF0aDtcblxuICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgaWYgKGNsaXBQYXRoLl9fenIpIHtcbiAgICAgICAgY2xpcFBhdGgucmVtb3ZlU2VsZkZyb21acihjbGlwUGF0aC5fX3pyKTtcbiAgICAgIH1cblxuICAgICAgY2xpcFBhdGguX196ciA9IG51bGw7XG4gICAgICBjbGlwUGF0aC5fX2NsaXBUYXJnZXQgPSBudWxsO1xuICAgICAgdGhpcy5jbGlwUGF0aCA9IG51bGw7XG4gICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBzZWxmIGZyb20genJlbmRlciBpbnN0YW5jZS5cbiAgICogTm90IHJlY3Vyc2l2ZWx5IGJlY2F1c2UgaXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gZWxlbWVudCBhZGRlZCB0byBzdG9yYWdlLlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9IHpyXG4gICAqL1xuICBhZGRTZWxmVG9acjogZnVuY3Rpb24gKHpyKSB7XG4gICAgdGhpcy5fX3pyID0genI7IC8vIOa3u+WKoOWKqOeUu1xuXG4gICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuXG4gICAgaWYgKGFuaW1hdG9ycykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgenIuYW5pbWF0aW9uLmFkZEFuaW1hdG9yKGFuaW1hdG9yc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgIHRoaXMuY2xpcFBhdGguYWRkU2VsZlRvWnIoenIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIHNlbGYgZnJvbSB6cmVuZGVyIGluc3RhbmNlLlxuICAgKiBOb3QgcmVjdXJzaXZlbHkgYmVjYXVzZSBpdCB3aWxsIGJlIGludm9rZWQgd2hlbiBlbGVtZW50IGFkZGVkIHRvIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn0genJcbiAgICovXG4gIHJlbW92ZVNlbGZGcm9tWnI6IGZ1bmN0aW9uICh6cikge1xuICAgIHRoaXMuX196ciA9IG51bGw7IC8vIOenu+mZpOWKqOeUu1xuXG4gICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuXG4gICAgaWYgKGFuaW1hdG9ycykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgenIuYW5pbWF0aW9uLnJlbW92ZUFuaW1hdG9yKGFuaW1hdG9yc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgIHRoaXMuY2xpcFBhdGgucmVtb3ZlU2VsZkZyb21acih6cik7XG4gICAgfVxuICB9XG59O1xuenJVdGlsLm1peGluKEVsZW1lbnQsIEFuaW1hdGFibGUpO1xuenJVdGlsLm1peGluKEVsZW1lbnQsIFRyYW5zZm9ybWFibGUpO1xuenJVdGlsLm1peGluKEVsZW1lbnQsIEV2ZW50ZnVsKTtcbnZhciBfZGVmYXVsdCA9IEVsZW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9FbGVtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIHpyZW5kZXI6IOeUn+aIkOWUr+S4gGlkXG4gKlxuICogQGF1dGhvciBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG52YXIgaWRTdGFydCA9IDB4MDkwNztcblxuZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gIHJldHVybiBpZFN0YXJ0Kys7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvZ3VpZC5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiDkuovku7bmianlsZVcbiAqIEBtb2R1bGUgenJlbmRlci9taXhpbi9FdmVudGZ1bFxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xudmFyIGFycnlTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbi8qKlxuICog5LqL5Lu25YiG5Y+R5ZmoXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbnZhciBFdmVudGZ1bCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fJGhhbmRsZXJzID0ge307XG59O1xuXG5FdmVudGZ1bC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBFdmVudGZ1bCxcblxuICAvKipcbiAgICog5Y2V5qyh6Kem5Y+R57uR5a6a77yMdHJpZ2dlcuWQjumUgOavgVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQg5LqL5Lu25ZCNXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5ZON5bqU5Ye95pWwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAqL1xuICBvbmU6IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlciwgY29udGV4dCkge1xuICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcblxuICAgIGlmICghaGFuZGxlciB8fCAhZXZlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICghX2hbZXZlbnRdKSB7XG4gICAgICBfaFtldmVudF0gPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9oW2V2ZW50XS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKF9oW2V2ZW50XVtpXS5oID09PSBoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9oW2V2ZW50XS5wdXNoKHtcbiAgICAgIGg6IGhhbmRsZXIsXG4gICAgICBvbmU6IHRydWUsXG4gICAgICBjdHg6IGNvbnRleHQgfHwgdGhpc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOe7keWumuS6i+S7tlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQg5LqL5Lu25ZCNXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5LqL5Lu25aSE55CG5Ye95pWwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAgICovXG4gIG9uOiBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG5cbiAgICBpZiAoIWhhbmRsZXIgfHwgIWV2ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoIV9oW2V2ZW50XSkge1xuICAgICAgX2hbZXZlbnRdID0gW107XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfaFtldmVudF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChfaFtldmVudF1baV0uaCA9PT0gaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfaFtldmVudF0ucHVzaCh7XG4gICAgICBoOiBoYW5kbGVyLFxuICAgICAgb25lOiBmYWxzZSxcbiAgICAgIGN0eDogY29udGV4dCB8fCB0aGlzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5piv5ZCm57uR5a6a5LqG5LqL5Lu2XG4gICAqIEBwYXJhbSAge3N0cmluZ30gIGV2ZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc1NpbGVudDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuICAgIHJldHVybiBfaFtldmVudF0gJiYgX2hbZXZlbnRdLmxlbmd0aDtcbiAgfSxcblxuICAvKipcbiAgICog6Kej57uR5LqL5Lu2XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCDkuovku7blkI1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgKi9cbiAgb2ZmOiBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG5cbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICB0aGlzLl8kaGFuZGxlcnMgPSB7fTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBpZiAoX2hbZXZlbnRdKSB7XG4gICAgICAgIHZhciBuZXdMaXN0ID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBfaFtldmVudF0ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKF9oW2V2ZW50XVtpXVsnaCddICE9IGhhbmRsZXIpIHtcbiAgICAgICAgICAgIG5ld0xpc3QucHVzaChfaFtldmVudF1baV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9oW2V2ZW50XSA9IG5ld0xpc3Q7XG4gICAgICB9XG5cbiAgICAgIGlmIChfaFtldmVudF0gJiYgX2hbZXZlbnRdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgX2hbZXZlbnRdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgX2hbZXZlbnRdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDkuovku7bliIblj5FcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LXG4gICAqL1xuICB0cmlnZ2VyOiBmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmICh0aGlzLl8kaGFuZGxlcnNbdHlwZV0pIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIGFyZ0xlbiA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgICBpZiAoYXJnTGVuID4gMykge1xuICAgICAgICBhcmdzID0gYXJyeVNsaWNlLmNhbGwoYXJncywgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVyc1t0eXBlXTtcbiAgICAgIHZhciBsZW4gPSBfaC5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAvLyBPcHRpbWl6ZSBhZHZpc2UgZnJvbSBiYWNrYm9uZVxuICAgICAgICBzd2l0Y2ggKGFyZ0xlbikge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChfaFtpXVsnY3R4J10pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChfaFtpXVsnY3R4J10sIGFyZ3NbMV0pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChfaFtpXVsnY3R4J10sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBoYXZlIG1vcmUgdGhhbiAyIGdpdmVuIGFyZ3VtZW50c1xuICAgICAgICAgICAgX2hbaV1bJ2gnXS5hcHBseShfaFtpXVsnY3R4J10sIGFyZ3MpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfaFtpXVsnb25lJ10pIHtcbiAgICAgICAgICBfaC5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICBsZW4tLTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5bim5pyJY29udGV4dOeahOS6i+S7tuWIhuWPkSwg5pyA5ZCO5LiA5Liq5Y+C5pWw5piv5LqL5Lu25Zue6LCD55qEY29udGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcbiAgICovXG4gIHRyaWdnZXJXaXRoQ29udGV4dDogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAodGhpcy5fJGhhbmRsZXJzW3R5cGVdKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBhcmdMZW4gPSBhcmdzLmxlbmd0aDtcblxuICAgICAgaWYgKGFyZ0xlbiA+IDQpIHtcbiAgICAgICAgYXJncyA9IGFycnlTbGljZS5jYWxsKGFyZ3MsIDEsIGFyZ3MubGVuZ3RoIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdHggPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnNbdHlwZV07XG4gICAgICB2YXIgbGVuID0gX2gubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgLy8gT3B0aW1pemUgYWR2aXNlIGZyb20gYmFja2JvbmVcbiAgICAgICAgc3dpdGNoIChhcmdMZW4pIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoY3R4KTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoY3R4LCBhcmdzWzFdKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoY3R4LCBhcmdzWzFdLCBhcmdzWzJdKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gaGF2ZSBtb3JlIHRoYW4gMiBnaXZlbiBhcmd1bWVudHNcbiAgICAgICAgICAgIF9oW2ldWydoJ10uYXBwbHkoY3R4LCBhcmdzKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2hbaV1bJ29uZSddKSB7XG4gICAgICAgICAgX2guc3BsaWNlKGksIDEpO1xuXG4gICAgICAgICAgbGVuLS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07IC8vIOWvueixoeWPr+S7pemAmui/hyBvbnh4eHgg57uR5a6a5LqL5Lu2XG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uY2xpY2tcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlb3ZlclxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2VvdXRcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlbW92ZVxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2V3aGVlbFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2Vkb3duXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZXVwXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnc3RhcnRcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdlbmRcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdlbnRlclxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ2xlYXZlXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnb3ZlclxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJvcFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbnZhciBfZGVmYXVsdCA9IEV2ZW50ZnVsO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWwuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBtYXRyaXggPSByZXF1aXJlKFwiLi4vY29yZS9tYXRyaXhcIik7XG5cbnZhciB2ZWN0b3IgPSByZXF1aXJlKFwiLi4vY29yZS92ZWN0b3JcIik7XG5cbi8qKlxuICog5o+Q5L6b5Y+Y5o2i5omp5bGVXG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbnZhciBtSWRlbnRpdHkgPSBtYXRyaXguaWRlbnRpdHk7XG52YXIgRVBTSUxPTiA9IDVlLTU7XG5cbmZ1bmN0aW9uIGlzTm90QXJvdW5kWmVybyh2YWwpIHtcbiAgcmV0dXJuIHZhbCA+IEVQU0lMT04gfHwgdmFsIDwgLUVQU0lMT047XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5cbnZhciBUcmFuc2Zvcm1hYmxlID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307IC8vIElmIHRoZXJlIGFyZSBubyBnaXZlbiBwb3NpdGlvbiwgcm90YXRpb24sIHNjYWxlXG5cbiAgaWYgKCFvcHRzLnBvc2l0aW9uKSB7XG4gICAgLyoqXG4gICAgICog5bmz56e7XG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAqIEBkZWZhdWx0IFswLCAwXVxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb24gPSBbMCwgMF07XG4gIH1cblxuICBpZiAob3B0cy5yb3RhdGlvbiA9PSBudWxsKSB7XG4gICAgLyoqXG4gICAgICog5peL6L2sXG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnJvdGF0aW9uID0gMDtcbiAgfVxuXG4gIGlmICghb3B0cy5zY2FsZSkge1xuICAgIC8qKlxuICAgICAqIOe8qeaUvlxuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAZGVmYXVsdCBbMSwgMV1cbiAgICAgKi9cbiAgICB0aGlzLnNjYWxlID0gWzEsIDFdO1xuICB9XG4gIC8qKlxuICAgKiDml4vovazlkoznvKnmlL7nmoTljp/ngrlcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqL1xuXG5cbiAgdGhpcy5vcmlnaW4gPSB0aGlzLm9yaWdpbiB8fCBudWxsO1xufTtcblxudmFyIHRyYW5zZm9ybWFibGVQcm90byA9IFRyYW5zZm9ybWFibGUucHJvdG90eXBlO1xudHJhbnNmb3JtYWJsZVByb3RvLnRyYW5zZm9ybSA9IG51bGw7XG4vKipcbiAqIOWIpOaWreaYr+WQpumcgOimgeacieWdkOagh+WPmOaNolxuICog5aaC5p6c5pyJ5Z2Q5qCH5Y+Y5o2iLCDliJnku45wb3NpdGlvbiwgcm90YXRpb24sIHNjYWxl5Lul5Y+K54i26IqC54K555qEdHJhbnNmb3Jt6K6h566X5Ye66Ieq6Lqr55qEdHJhbnNmb3Jt55+p6Zi1XG4gKi9cblxudHJhbnNmb3JtYWJsZVByb3RvLm5lZWRMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzTm90QXJvdW5kWmVybyh0aGlzLnJvdGF0aW9uKSB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5wb3NpdGlvblswXSkgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMucG9zaXRpb25bMV0pIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnNjYWxlWzBdIC0gMSkgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMuc2NhbGVbMV0gLSAxKTtcbn07XG5cbnRyYW5zZm9ybWFibGVQcm90by51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgdmFyIHBhcmVudEhhc1RyYW5zZm9ybSA9IHBhcmVudCAmJiBwYXJlbnQudHJhbnNmb3JtO1xuICB2YXIgbmVlZExvY2FsVHJhbnNmb3JtID0gdGhpcy5uZWVkTG9jYWxUcmFuc2Zvcm0oKTtcbiAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcblxuICBpZiAoIShuZWVkTG9jYWxUcmFuc2Zvcm0gfHwgcGFyZW50SGFzVHJhbnNmb3JtKSkge1xuICAgIG0gJiYgbUlkZW50aXR5KG0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG0gPSBtIHx8IG1hdHJpeC5jcmVhdGUoKTtcblxuICBpZiAobmVlZExvY2FsVHJhbnNmb3JtKSB7XG4gICAgdGhpcy5nZXRMb2NhbFRyYW5zZm9ybShtKTtcbiAgfSBlbHNlIHtcbiAgICBtSWRlbnRpdHkobSk7XG4gIH0gLy8g5bqU55So54i26IqC54K55Y+Y5o2iXG5cblxuICBpZiAocGFyZW50SGFzVHJhbnNmb3JtKSB7XG4gICAgaWYgKG5lZWRMb2NhbFRyYW5zZm9ybSkge1xuICAgICAgbWF0cml4Lm11bChtLCBwYXJlbnQudHJhbnNmb3JtLCBtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0cml4LmNvcHkobSwgcGFyZW50LnRyYW5zZm9ybSk7XG4gICAgfVxuICB9IC8vIOS/neWtmOi/meS4quWPmOaNouefqemYtVxuXG5cbiAgdGhpcy50cmFuc2Zvcm0gPSBtO1xuICB0aGlzLmludlRyYW5zZm9ybSA9IHRoaXMuaW52VHJhbnNmb3JtIHx8IG1hdHJpeC5jcmVhdGUoKTtcbiAgbWF0cml4LmludmVydCh0aGlzLmludlRyYW5zZm9ybSwgbSk7XG59O1xuXG50cmFuc2Zvcm1hYmxlUHJvdG8uZ2V0TG9jYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiAobSkge1xuICByZXR1cm4gVHJhbnNmb3JtYWJsZS5nZXRMb2NhbFRyYW5zZm9ybSh0aGlzLCBtKTtcbn07XG4vKipcbiAqIOWwhuiHquW3seeahHRyYW5zZm9ybeW6lOeUqOWIsGNvbnRleHTkuIpcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAqL1xuXG5cbnRyYW5zZm9ybWFibGVQcm90by5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoY3R4KSB7XG4gIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gIHZhciBkcHIgPSBjdHguZHByIHx8IDE7XG5cbiAgaWYgKG0pIHtcbiAgICBjdHguc2V0VHJhbnNmb3JtKGRwciAqIG1bMF0sIGRwciAqIG1bMV0sIGRwciAqIG1bMl0sIGRwciAqIG1bM10sIGRwciAqIG1bNF0sIGRwciAqIG1bNV0pO1xuICB9IGVsc2Uge1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oZHByLCAwLCAwLCBkcHIsIDAsIDApO1xuICB9XG59O1xuXG50cmFuc2Zvcm1hYmxlUHJvdG8ucmVzdG9yZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgdmFyIGRwciA9IGN0eC5kcHIgfHwgMTtcbiAgY3R4LnNldFRyYW5zZm9ybShkcHIsIDAsIDAsIGRwciwgMCwgMCk7XG59O1xuXG52YXIgdG1wVHJhbnNmb3JtID0gW107XG4vKipcbiAqIOWIhuino2B0cmFuc2Zvcm1g55+p6Zi15YiwYHBvc2l0aW9uYCwgYHJvdGF0aW9uYCwgYHNjYWxlYFxuICovXG5cbnRyYW5zZm9ybWFibGVQcm90by5kZWNvbXBvc2VUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy50cmFuc2Zvcm0pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgaWYgKHBhcmVudCAmJiBwYXJlbnQudHJhbnNmb3JtKSB7XG4gICAgLy8gR2V0IGxvY2FsIHRyYW5zZm9ybSBhbmQgZGVjb21wb3NlIHRoZW0gdG8gcG9zaXRpb24sIHNjYWxlLCByb3RhdGlvblxuICAgIG1hdHJpeC5tdWwodG1wVHJhbnNmb3JtLCBwYXJlbnQuaW52VHJhbnNmb3JtLCBtKTtcbiAgICBtID0gdG1wVHJhbnNmb3JtO1xuICB9XG5cbiAgdmFyIHN4ID0gbVswXSAqIG1bMF0gKyBtWzFdICogbVsxXTtcbiAgdmFyIHN5ID0gbVsyXSAqIG1bMl0gKyBtWzNdICogbVszXTtcbiAgdmFyIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcblxuICBpZiAoaXNOb3RBcm91bmRaZXJvKHN4IC0gMSkpIHtcbiAgICBzeCA9IE1hdGguc3FydChzeCk7XG4gIH1cblxuICBpZiAoaXNOb3RBcm91bmRaZXJvKHN5IC0gMSkpIHtcbiAgICBzeSA9IE1hdGguc3FydChzeSk7XG4gIH1cblxuICBpZiAobVswXSA8IDApIHtcbiAgICBzeCA9IC1zeDtcbiAgfVxuXG4gIGlmIChtWzNdIDwgMCkge1xuICAgIHN5ID0gLXN5O1xuICB9XG5cbiAgcG9zaXRpb25bMF0gPSBtWzRdO1xuICBwb3NpdGlvblsxXSA9IG1bNV07XG4gIHNjYWxlWzBdID0gc3g7XG4gIHNjYWxlWzFdID0gc3k7XG4gIHRoaXMucm90YXRpb24gPSBNYXRoLmF0YW4yKC1tWzFdIC8gc3ksIG1bMF0gLyBzeCk7XG59O1xuLyoqXG4gKiBHZXQgZ2xvYmFsIHNjYWxlXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAqL1xuXG5cbnRyYW5zZm9ybWFibGVQcm90by5nZXRHbG9iYWxTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcblxuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gWzEsIDFdO1xuICB9XG5cbiAgdmFyIHN4ID0gTWF0aC5zcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0pO1xuICB2YXIgc3kgPSBNYXRoLnNxcnQobVsyXSAqIG1bMl0gKyBtWzNdICogbVszXSk7XG5cbiAgaWYgKG1bMF0gPCAwKSB7XG4gICAgc3ggPSAtc3g7XG4gIH1cblxuICBpZiAobVszXSA8IDApIHtcbiAgICBzeSA9IC1zeTtcbiAgfVxuXG4gIHJldHVybiBbc3gsIHN5XTtcbn07XG4vKipcbiAqIOWPmOaNouWdkOagh+S9jee9ruWIsCBzaGFwZSDnmoTlsYDpg6jlnZDmoIfnqbrpl7RcbiAqIEBtZXRob2RcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gKi9cblxuXG50cmFuc2Zvcm1hYmxlUHJvdG8udHJhbnNmb3JtQ29vcmRUb0xvY2FsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgdmFyIHYyID0gW3gsIHldO1xuICB2YXIgaW52VHJhbnNmb3JtID0gdGhpcy5pbnZUcmFuc2Zvcm07XG5cbiAgaWYgKGludlRyYW5zZm9ybSkge1xuICAgIHZlY3Rvci5hcHBseVRyYW5zZm9ybSh2MiwgdjIsIGludlRyYW5zZm9ybSk7XG4gIH1cblxuICByZXR1cm4gdjI7XG59O1xuLyoqXG4gKiDlj5jmjaLlsYDpg6jlnZDmoIfkvY3nva7liLDlhajlsYDlnZDmoIfnqbrpl7RcbiAqIEBtZXRob2RcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gKi9cblxuXG50cmFuc2Zvcm1hYmxlUHJvdG8udHJhbnNmb3JtQ29vcmRUb0dsb2JhbCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gIHZhciB2MiA9IFt4LCB5XTtcbiAgdmFyIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gIGlmICh0cmFuc2Zvcm0pIHtcbiAgICB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0odjIsIHYyLCB0cmFuc2Zvcm0pO1xuICB9XG5cbiAgcmV0dXJuIHYyO1xufTtcbi8qKlxuICogQHN0YXRpY1xuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdGFyZ2V0Lm9yaWdpblxuICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldC5yb3RhdGlvblxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdGFyZ2V0LnBvc2l0aW9uXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbbV1cbiAqL1xuXG5cblRyYW5zZm9ybWFibGUuZ2V0TG9jYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodGFyZ2V0LCBtKSB7XG4gIG0gPSBtIHx8IFtdO1xuICBtSWRlbnRpdHkobSk7XG4gIHZhciBvcmlnaW4gPSB0YXJnZXQub3JpZ2luO1xuICB2YXIgc2NhbGUgPSB0YXJnZXQuc2NhbGUgfHwgWzEsIDFdO1xuICB2YXIgcm90YXRpb24gPSB0YXJnZXQucm90YXRpb24gfHwgMDtcbiAgdmFyIHBvc2l0aW9uID0gdGFyZ2V0LnBvc2l0aW9uIHx8IFswLCAwXTtcblxuICBpZiAob3JpZ2luKSB7XG4gICAgLy8gVHJhbnNsYXRlIHRvIG9yaWdpblxuICAgIG1bNF0gLT0gb3JpZ2luWzBdO1xuICAgIG1bNV0gLT0gb3JpZ2luWzFdO1xuICB9XG5cbiAgbWF0cml4LnNjYWxlKG0sIG0sIHNjYWxlKTtcblxuICBpZiAocm90YXRpb24pIHtcbiAgICBtYXRyaXgucm90YXRlKG0sIG0sIHJvdGF0aW9uKTtcbiAgfVxuXG4gIGlmIChvcmlnaW4pIHtcbiAgICAvLyBUcmFuc2xhdGUgYmFjayBmcm9tIG9yaWdpblxuICAgIG1bNF0gKz0gb3JpZ2luWzBdO1xuICAgIG1bNV0gKz0gb3JpZ2luWzFdO1xuICB9XG5cbiAgbVs0XSArPSBwb3NpdGlvblswXTtcbiAgbVs1XSArPSBwb3NpdGlvblsxXTtcbiAgcmV0dXJuIG07XG59O1xuXG52YXIgX2RlZmF1bHQgPSBUcmFuc2Zvcm1hYmxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvbWl4aW4vVHJhbnNmb3JtYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiAzeDLnn6npmLXmk43kvZznsbtcbiAqIEBleHBvcnRzIHpyZW5kZXIvdG9vbC9tYXRyaXhcbiAqL1xudmFyIEFycmF5Q3RvciA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gQXJyYXkgOiBGbG9hdDMyQXJyYXk7XG4vKipcbiAqIOWIm+W7uuS4gOS4quWNleS9jeefqemYtVxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBBcnJheUN0b3IoNik7XG4gIGlkZW50aXR5KG91dCk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOiuvue9ruefqemYteS4uuWNleS9jeefqemYtVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICovXG5cblxuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWkjeWItuefqemYtVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkob3V0LCBtKSB7XG4gIG91dFswXSA9IG1bMF07XG4gIG91dFsxXSA9IG1bMV07XG4gIG91dFsyXSA9IG1bMl07XG4gIG91dFszXSA9IG1bM107XG4gIG91dFs0XSA9IG1bNF07XG4gIG91dFs1XSA9IG1bNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOefqemYteebuOS5mFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG0xXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gbTJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bChvdXQsIG0xLCBtMikge1xuICAvLyBDb25zaWRlciBtYXRyaXgubXVsKG0sIG0yLCBtKTtcbiAgLy8gd2hlcmUgb3V0IGlzIHRoZSBzYW1lIGFzIG0yLlxuICAvLyBTbyB1c2UgdGVtcCB2YXJpYWJsZSB0byBlc2NhcGUgZXJyb3IuXG4gIHZhciBvdXQwID0gbTFbMF0gKiBtMlswXSArIG0xWzJdICogbTJbMV07XG4gIHZhciBvdXQxID0gbTFbMV0gKiBtMlswXSArIG0xWzNdICogbTJbMV07XG4gIHZhciBvdXQyID0gbTFbMF0gKiBtMlsyXSArIG0xWzJdICogbTJbM107XG4gIHZhciBvdXQzID0gbTFbMV0gKiBtMlsyXSArIG0xWzNdICogbTJbM107XG4gIHZhciBvdXQ0ID0gbTFbMF0gKiBtMls0XSArIG0xWzJdICogbTJbNV0gKyBtMVs0XTtcbiAgdmFyIG91dDUgPSBtMVsxXSAqIG0yWzRdICsgbTFbM10gKiBtMls1XSArIG0xWzVdO1xuICBvdXRbMF0gPSBvdXQwO1xuICBvdXRbMV0gPSBvdXQxO1xuICBvdXRbMl0gPSBvdXQyO1xuICBvdXRbM10gPSBvdXQzO1xuICBvdXRbNF0gPSBvdXQ0O1xuICBvdXRbNV0gPSBvdXQ1O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlubPnp7vlj5jmjaJcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gdlxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgdlswXTtcbiAgb3V0WzVdID0gYVs1XSArIHZbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOaXi+i9rOWPmOaNolxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICB2YXIgYWEgPSBhWzBdO1xuICB2YXIgYWMgPSBhWzJdO1xuICB2YXIgYXR4ID0gYVs0XTtcbiAgdmFyIGFiID0gYVsxXTtcbiAgdmFyIGFkID0gYVszXTtcbiAgdmFyIGF0eSA9IGFbNV07XG4gIHZhciBzdCA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjdCA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGFhICogY3QgKyBhYiAqIHN0O1xuICBvdXRbMV0gPSAtYWEgKiBzdCArIGFiICogY3Q7XG4gIG91dFsyXSA9IGFjICogY3QgKyBhZCAqIHN0O1xuICBvdXRbM10gPSAtYWMgKiBzdCArIGN0ICogYWQ7XG4gIG91dFs0XSA9IGN0ICogYXR4ICsgc3QgKiBhdHk7XG4gIG91dFs1XSA9IGN0ICogYXR5IC0gc3QgKiBhdHg7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOe8qeaUvuWPmOaNolxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSB2XG4gKi9cblxuXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgdmFyIHZ4ID0gdlswXTtcbiAgdmFyIHZ5ID0gdlsxXTtcbiAgb3V0WzBdID0gYVswXSAqIHZ4O1xuICBvdXRbMV0gPSBhWzFdICogdnk7XG4gIG91dFsyXSA9IGFbMl0gKiB2eDtcbiAgb3V0WzNdID0gYVszXSAqIHZ5O1xuICBvdXRbNF0gPSBhWzRdICogdng7XG4gIG91dFs1XSA9IGFbNV0gKiB2eTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5rGC6YCG55+p6Zi1XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICovXG5cblxuZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgYWEgPSBhWzBdO1xuICB2YXIgYWMgPSBhWzJdO1xuICB2YXIgYXR4ID0gYVs0XTtcbiAgdmFyIGFiID0gYVsxXTtcbiAgdmFyIGFkID0gYVszXTtcbiAgdmFyIGF0eSA9IGFbNV07XG4gIHZhciBkZXQgPSBhYSAqIGFkIC0gYWIgKiBhYztcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSBhZCAqIGRldDtcbiAgb3V0WzFdID0gLWFiICogZGV0O1xuICBvdXRbMl0gPSAtYWMgKiBkZXQ7XG4gIG91dFszXSA9IGFhICogZGV0O1xuICBvdXRbNF0gPSAoYWMgKiBhdHkgLSBhZCAqIGF0eCkgKiBkZXQ7XG4gIG91dFs1XSA9IChhYiAqIGF0eCAtIGFhICogYXR5KSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cblxuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuZXhwb3J0cy5tdWwgPSBtdWw7XG5leHBvcnRzLnRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbmV4cG9ydHMucm90YXRlID0gcm90YXRlO1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQXJyYXlDdG9yID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyBBcnJheSA6IEZsb2F0MzJBcnJheTtcbi8qKlxuICog5Yib5bu65LiA5Liq5ZCR6YePXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXVxuICogQHJldHVybiB7VmVjdG9yMn1cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGUoeCwgeSkge1xuICB2YXIgb3V0ID0gbmV3IEFycmF5Q3RvcigyKTtcblxuICBpZiAoeCA9PSBudWxsKSB7XG4gICAgeCA9IDA7XG4gIH1cblxuICBpZiAoeSA9PSBudWxsKSB7XG4gICAgeSA9IDA7XG4gIH1cblxuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlpI3liLblkJHph4/mlbDmja5cbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5KG91dCwgdikge1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSB2WzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlhYvpmobkuIDkuKrlkJHph49cbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICogQHJldHVybiB7VmVjdG9yMn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lKHYpIHtcbiAgdmFyIG91dCA9IG5ldyBBcnJheUN0b3IoMik7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IHZbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOiuvue9ruWQkemHj+eahOS4pOS4qumhuVxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICogQHJldHVybiB7VmVjdG9yMn0g57uT5p6cXG4gKi9cblxuXG5mdW5jdGlvbiBzZXQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGE7XG4gIG91dFsxXSA9IGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+ebuOWKoFxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZChvdXQsIHYxLCB2Mikge1xuICBvdXRbMF0gPSB2MVswXSArIHYyWzBdO1xuICBvdXRbMV0gPSB2MVsxXSArIHYyWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlkJHph4/nvKnmlL7lkI7nm7jliqBcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICovXG5cblxuZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCB2MSwgdjIsIGEpIHtcbiAgb3V0WzBdID0gdjFbMF0gKyB2MlswXSAqIGE7XG4gIG91dFsxXSA9IHYxWzFdICsgdjJbMV0gKiBhO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlkJHph4/nm7jlh49cbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKi9cblxuXG5mdW5jdGlvbiBzdWIob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gdjFbMF0gLSB2MlswXTtcbiAgb3V0WzFdID0gdjFbMV0gLSB2MlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP6ZW/5bqmXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGxlbih2KSB7XG4gIHJldHVybiBNYXRoLnNxcnQobGVuU3F1YXJlKHYpKTtcbn1cblxudmFyIGxlbmd0aCA9IGxlbjsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbi8qKlxuICog5ZCR6YeP6ZW/5bqm5bmz5pa5XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5mdW5jdGlvbiBsZW5TcXVhcmUodikge1xuICByZXR1cm4gdlswXSAqIHZbMF0gKyB2WzFdICogdlsxXTtcbn1cblxudmFyIGxlbmd0aFNxdWFyZSA9IGxlblNxdWFyZTtcbi8qKlxuICog5ZCR6YeP5LmY5rOVXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICovXG5cbmZ1bmN0aW9uIG11bChvdXQsIHYxLCB2Mikge1xuICBvdXRbMF0gPSB2MVswXSAqIHYyWzBdO1xuICBvdXRbMV0gPSB2MVsxXSAqIHYyWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlkJHph4/pmaTms5VcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKi9cblxuXG5mdW5jdGlvbiBkaXYob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gdjFbMF0gLyB2MlswXTtcbiAgb3V0WzFdID0gdjFbMV0gLyB2MlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP54K55LmYXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBkb3QodjEsIHYyKSB7XG4gIHJldHVybiB2MVswXSAqIHYyWzBdICsgdjFbMV0gKiB2MlsxXTtcbn1cbi8qKlxuICog5ZCR6YeP57yp5pS+XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcGFyYW0ge251bWJlcn0gc1xuICovXG5cblxuZnVuY3Rpb24gc2NhbGUob3V0LCB2LCBzKSB7XG4gIG91dFswXSA9IHZbMF0gKiBzO1xuICBvdXRbMV0gPSB2WzFdICogcztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP5b2S5LiA5YyWXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemUob3V0LCB2KSB7XG4gIHZhciBkID0gbGVuKHYpO1xuXG4gIGlmIChkID09PSAwKSB7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IHZbMF0gLyBkO1xuICAgIG91dFsxXSA9IHZbMV0gLyBkO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog6K6h566X5ZCR6YeP6Ze06Led56a7XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBkaXN0YW5jZSh2MSwgdjIpIHtcbiAgcmV0dXJuIE1hdGguc3FydCgodjFbMF0gLSB2MlswXSkgKiAodjFbMF0gLSB2MlswXSkgKyAodjFbMV0gLSB2MlsxXSkgKiAodjFbMV0gLSB2MlsxXSkpO1xufVxuXG52YXIgZGlzdCA9IGRpc3RhbmNlO1xuLyoqXG4gKiDlkJHph4/ot53nprvlubPmlrlcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5mdW5jdGlvbiBkaXN0YW5jZVNxdWFyZSh2MSwgdjIpIHtcbiAgcmV0dXJuICh2MVswXSAtIHYyWzBdKSAqICh2MVswXSAtIHYyWzBdKSArICh2MVsxXSAtIHYyWzFdKSAqICh2MVsxXSAtIHYyWzFdKTtcbn1cblxudmFyIGRpc3RTcXVhcmUgPSBkaXN0YW5jZVNxdWFyZTtcbi8qKlxuICog5rGC6LSf5ZCR6YePXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKi9cblxuZnVuY3Rpb24gbmVnYXRlKG91dCwgdikge1xuICBvdXRbMF0gPSAtdlswXTtcbiAgb3V0WzFdID0gLXZbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOaPkuWAvOS4pOS4queCuVxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKi9cblxuXG5mdW5jdGlvbiBsZXJwKG91dCwgdjEsIHYyLCB0KSB7XG4gIG91dFswXSA9IHYxWzBdICsgdCAqICh2MlswXSAtIHYxWzBdKTtcbiAgb3V0WzFdID0gdjFbMV0gKyB0ICogKHYyWzFdIC0gdjFbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDnn6npmLXlt6bkuZjlkJHph49cbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqIEBwYXJhbSB7VmVjdG9yMn0gbVxuICovXG5cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm0ob3V0LCB2LCBtKSB7XG4gIHZhciB4ID0gdlswXTtcbiAgdmFyIHkgPSB2WzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOaxguS4pOS4quWQkemHj+acgOWwj+WAvFxuICogQHBhcmFtICB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0gIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtICB7VmVjdG9yMn0gdjJcbiAqL1xuXG5cbmZ1bmN0aW9uIG1pbihvdXQsIHYxLCB2Mikge1xuICBvdXRbMF0gPSBNYXRoLm1pbih2MVswXSwgdjJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbih2MVsxXSwgdjJbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDmsYLkuKTkuKrlkJHph4/mnIDlpKflgLxcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtICB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYyXG4gKi9cblxuXG5mdW5jdGlvbiBtYXgob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgodjFbMF0sIHYyWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgodjFbMV0sIHYyWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5zZXQgPSBzZXQ7XG5leHBvcnRzLmFkZCA9IGFkZDtcbmV4cG9ydHMuc2NhbGVBbmRBZGQgPSBzY2FsZUFuZEFkZDtcbmV4cG9ydHMuc3ViID0gc3ViO1xuZXhwb3J0cy5sZW4gPSBsZW47XG5leHBvcnRzLmxlbmd0aCA9IGxlbmd0aDtcbmV4cG9ydHMubGVuU3F1YXJlID0gbGVuU3F1YXJlO1xuZXhwb3J0cy5sZW5ndGhTcXVhcmUgPSBsZW5ndGhTcXVhcmU7XG5leHBvcnRzLm11bCA9IG11bDtcbmV4cG9ydHMuZGl2ID0gZGl2O1xuZXhwb3J0cy5kb3QgPSBkb3Q7XG5leHBvcnRzLnNjYWxlID0gc2NhbGU7XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbmV4cG9ydHMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbmV4cG9ydHMuZGlzdCA9IGRpc3Q7XG5leHBvcnRzLmRpc3RhbmNlU3F1YXJlID0gZGlzdGFuY2VTcXVhcmU7XG5leHBvcnRzLmRpc3RTcXVhcmUgPSBkaXN0U3F1YXJlO1xuZXhwb3J0cy5uZWdhdGUgPSBuZWdhdGU7XG5leHBvcnRzLmxlcnAgPSBsZXJwO1xuZXhwb3J0cy5hcHBseVRyYW5zZm9ybSA9IGFwcGx5VHJhbnNmb3JtO1xuZXhwb3J0cy5taW4gPSBtaW47XG5leHBvcnRzLm1heCA9IG1heDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29yZS92ZWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBbmltYXRvciA9IHJlcXVpcmUoXCIuLi9hbmltYXRpb24vQW5pbWF0b3JcIik7XG5cbnZhciBsb2cgPSByZXF1aXJlKFwiLi4vY29yZS9sb2dcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBpc1N0cmluZyA9IF91dGlsLmlzU3RyaW5nO1xudmFyIGlzRnVuY3Rpb24gPSBfdXRpbC5pc0Z1bmN0aW9uO1xudmFyIGlzT2JqZWN0ID0gX3V0aWwuaXNPYmplY3Q7XG52YXIgaXNBcnJheUxpa2UgPSBfdXRpbC5pc0FycmF5TGlrZTtcbnZhciBpbmRleE9mID0gX3V0aWwuaW5kZXhPZjtcblxuLyoqXG4gKiBAYWxpYXMgbW9kdWU6enJlbmRlci9taXhpbi9BbmltYXRhYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEFuaW1hdGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcj59XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgdGhpcy5hbmltYXRvcnMgPSBbXTtcbn07XG5cbkFuaW1hdGFibGUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQW5pbWF0YWJsZSxcblxuICAvKipcbiAgICog5Yqo55S7XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGZldGNoIHZhbHVlIGZyb20gb2JqZWN0LCBsaWtlICdhLmIuYycuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2xvb3BdIFdoZXRoZXIgdG8gbG9vcCBhbmltYXRpb24uXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICogQGV4YW1wbGU6XG4gICAqICAgICBlbC5hbmltYXRlKCdzdHlsZScsIGZhbHNlKVxuICAgKiAgICAgICAgIC53aGVuKDEwMDAsIHt4OiAxMH0gKVxuICAgKiAgICAgICAgIC5kb25lKGZ1bmN0aW9uKCl7IC8vIEFuaW1hdGlvbiBkb25lIH0pXG4gICAqICAgICAgICAgLnN0YXJ0KClcbiAgICovXG4gIGFuaW1hdGU6IGZ1bmN0aW9uIChwYXRoLCBsb29wKSB7XG4gICAgdmFyIHRhcmdldDtcbiAgICB2YXIgYW5pbWF0aW5nU2hhcGUgPSBmYWxzZTtcbiAgICB2YXIgZWwgPSB0aGlzO1xuICAgIHZhciB6ciA9IHRoaXMuX196cjtcblxuICAgIGlmIChwYXRoKSB7XG4gICAgICB2YXIgcGF0aFNwbGl0dGVkID0gcGF0aC5zcGxpdCgnLicpO1xuICAgICAgdmFyIHByb3AgPSBlbDsgLy8gSWYgYW5pbWF0aW5nIHNoYXBlXG5cbiAgICAgIGFuaW1hdGluZ1NoYXBlID0gcGF0aFNwbGl0dGVkWzBdID09PSAnc2hhcGUnO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGhTcGxpdHRlZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKCFwcm9wKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wID0gcHJvcFtwYXRoU3BsaXR0ZWRbaV1dO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcCkge1xuICAgICAgICB0YXJnZXQgPSBwcm9wO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQgPSBlbDtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgbG9nKCdQcm9wZXJ0eSBcIicgKyBwYXRoICsgJ1wiIGlzIG5vdCBleGlzdGVkIGluIGVsZW1lbnQgJyArIGVsLmlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYW5pbWF0b3JzID0gZWwuYW5pbWF0b3JzO1xuICAgIHZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcih0YXJnZXQsIGxvb3ApO1xuICAgIGFuaW1hdG9yLmR1cmluZyhmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBlbC5kaXJ0eShhbmltYXRpbmdTaGFwZSk7XG4gICAgfSkuZG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBGSVhNRSBBbmltYXRvciB3aWxsIG5vdCBiZSByZW1vdmVkIGlmIHVzZSBgQW5pbWF0b3Ijc3RvcGAgdG8gc3RvcCBhbmltYXRpb25cbiAgICAgIGFuaW1hdG9ycy5zcGxpY2UoaW5kZXhPZihhbmltYXRvcnMsIGFuaW1hdG9yKSwgMSk7XG4gICAgfSk7XG4gICAgYW5pbWF0b3JzLnB1c2goYW5pbWF0b3IpOyAvLyBJZiBhbmltYXRlIGFmdGVyIGFkZGVkIHRvIHRoZSB6cmVuZGVyXG5cbiAgICBpZiAoenIpIHtcbiAgICAgIHpyLmFuaW1hdGlvbi5hZGRBbmltYXRvcihhbmltYXRvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuaW1hdG9yO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlgZzmraLliqjnlLtcbiAgICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkVG9MYXN0IElmIG1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgKi9cbiAgc3RvcEFuaW1hdGlvbjogZnVuY3Rpb24gKGZvcndhcmRUb0xhc3QpIHtcbiAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnM7XG4gICAgdmFyIGxlbiA9IGFuaW1hdG9ycy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhbmltYXRvcnNbaV0uc3RvcChmb3J3YXJkVG9MYXN0KTtcbiAgICB9XG5cbiAgICBhbmltYXRvcnMubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQ2F1dGlvbjogdGhpcyBtZXRob2Qgd2lsbCBzdG9wIHByZXZpb3VzIGFuaW1hdGlvbi5cbiAgICogU28gZG8gbm90IHVzZSB0aGlzIG1ldGhvZCB0byBvbmUgZWxlbWVudCB0d2ljZSBiZWZvcmVcbiAgICogYW5pbWF0aW9uIHN0YXJ0cywgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWU9NTAwXSBUaW1lIGluIG1zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZWFzaW5nPSdsaW5lYXInXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5PTBdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZvcmNlQW5pbWF0ZV0gUHJldmVudCBzdG9wIGFuaW1hdGlvbiBhbmQgY2FsbGJhY2tcbiAgICogICAgICAgIGltbWVkaWVudGx5IHdoZW4gdGFyZ2V0IHZhbHVlcyBhcmUgdGhlIHNhbWUgYXMgY3VycmVudCB2YWx1ZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAvLyBBbmltYXRlIHBvc2l0aW9uXG4gICAqICBlbC5hbmltYXRlVG8oe1xuICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgKiAgfSwgZnVuY3Rpb24gKCkgeyAvLyBkb25lIH0pXG4gICAqXG4gICAqICAvLyBBbmltYXRlIHNoYXBlLCBzdHlsZSBhbmQgcG9zaXRpb24gaW4gMTAwbXMsIGRlbGF5ZWQgMTAwbXMsIHdpdGggY3ViaWNPdXQgZWFzaW5nXG4gICAqICBlbC5hbmltYXRlVG8oe1xuICAgKiAgICAgIHNoYXBlOiB7XG4gICAqICAgICAgICAgIHdpZHRoOiA1MDBcbiAgICogICAgICB9LFxuICAgKiAgICAgIHN0eWxlOiB7XG4gICAqICAgICAgICAgIGZpbGw6ICdyZWQnXG4gICAqICAgICAgfVxuICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgKiAgfSwgMTAwLCAxMDAsICdjdWJpY091dCcsIGZ1bmN0aW9uICgpIHsgLy8gZG9uZSB9KVxuICAgKi9cbiAgLy8gVE9ETyBSZXR1cm4gYW5pbWF0aW9uIGtleVxuICBhbmltYXRlVG86IGZ1bmN0aW9uICh0YXJnZXQsIHRpbWUsIGRlbGF5LCBlYXNpbmcsIGNhbGxiYWNrLCBmb3JjZUFuaW1hdGUpIHtcbiAgICAvLyBhbmltYXRlVG8odGFyZ2V0LCB0aW1lLCBlYXNpbmcsIGNhbGxiYWNrKTtcbiAgICBpZiAoaXNTdHJpbmcoZGVsYXkpKSB7XG4gICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgIGVhc2luZyA9IGRlbGF5O1xuICAgICAgZGVsYXkgPSAwO1xuICAgIH0gLy8gYW5pbWF0ZVRvKHRhcmdldCwgdGltZSwgZGVsYXksIGNhbGxiYWNrKTtcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVhc2luZykpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgICAgIGVhc2luZyA9ICdsaW5lYXInO1xuICAgICAgICBkZWxheSA9IDA7XG4gICAgICB9IC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGNhbGxiYWNrKTtcbiAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oZGVsYXkpKSB7XG4gICAgICAgICAgY2FsbGJhY2sgPSBkZWxheTtcbiAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgIH0gLy8gYW5pbWF0ZVRvKHRhcmdldCwgY2FsbGJhY2spXG4gICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24odGltZSkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdGltZTtcbiAgICAgICAgICAgIHRpbWUgPSA1MDA7XG4gICAgICAgICAgfSAvLyBhbmltYXRlVG8odGFyZ2V0KVxuICAgICAgICAgIGVsc2UgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgICAgIHRpbWUgPSA1MDA7XG4gICAgICAgICAgICB9IC8vIFN0b3AgYWxsIHByZXZpb3VzIGFuaW1hdGlvbnNcblxuXG4gICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG5cbiAgICB0aGlzLl9hbmltYXRlVG9TaGFsbG93KCcnLCB0aGlzLCB0YXJnZXQsIHRpbWUsIGRlbGF5KTsgLy8gQW5pbWF0b3JzIG1heSBiZSByZW1vdmVkIGltbWVkaWF0ZWx5IGFmdGVyIHN0YXJ0XG4gICAgLy8gaWYgdGhlcmUgaXMgbm90aGluZyB0byBhbmltYXRlXG5cblxuICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycy5zbGljZSgpO1xuICAgIHZhciBjb3VudCA9IGFuaW1hdG9ycy5sZW5ndGg7XG5cbiAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgY291bnQtLTtcblxuICAgICAgaWYgKCFjb3VudCkge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0gLy8gTm8gYW5pbWF0b3JzLiBUaGlzIHNob3VsZCBiZSBjaGVja2VkIGJlZm9yZSBhbmltYXRvcnNbaV0uc3RhcnQoKSxcbiAgICAvLyBiZWNhdXNlICdkb25lJyBtYXkgYmUgZXhlY3V0ZWQgaW1tZWRpYXRlbHkgaWYgbm8gbmVlZCB0byBhbmltYXRlLlxuXG5cbiAgICBpZiAoIWNvdW50KSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgIH0gLy8gU3RhcnQgYWZ0ZXIgYWxsIGFuaW1hdG9ycyBjcmVhdGVkXG4gICAgLy8gSW5jYXNlIGFueSBhbmltYXRvciBpcyBkb25lIGltbWVkaWF0ZWx5IHdoZW4gYWxsIGFuaW1hdGlvbiBwcm9wZXJ0aWVzIGFyZSBub3QgY2hhbmdlZFxuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgYW5pbWF0b3JzW2ldLmRvbmUoZG9uZSkuc3RhcnQoZWFzaW5nLCBmb3JjZUFuaW1hdGUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGg9JydcbiAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZT10aGlzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lPTUwMF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gQW5pbWF0ZSBwb3NpdGlvblxuICAgKiAgZWwuX2FuaW1hdGVUb1NoYWxsb3coe1xuICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgKiAgfSlcbiAgICpcbiAgICogIC8vIEFuaW1hdGUgc2hhcGUsIHN0eWxlIGFuZCBwb3NpdGlvbiBpbiAxMDBtcywgZGVsYXllZCAxMDBtc1xuICAgKiAgZWwuX2FuaW1hdGVUb1NoYWxsb3coe1xuICAgKiAgICAgIHNoYXBlOiB7XG4gICAqICAgICAgICAgIHdpZHRoOiA1MDBcbiAgICogICAgICB9LFxuICAgKiAgICAgIHN0eWxlOiB7XG4gICAqICAgICAgICAgIGZpbGw6ICdyZWQnXG4gICAqICAgICAgfVxuICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgKiAgfSwgMTAwLCAxMDApXG4gICAqL1xuICBfYW5pbWF0ZVRvU2hhbGxvdzogZnVuY3Rpb24gKHBhdGgsIHNvdXJjZSwgdGFyZ2V0LCB0aW1lLCBkZWxheSkge1xuICAgIHZhciBvYmpTaGFsbG93ID0ge307XG4gICAgdmFyIHByb3BlcnR5Q291bnQgPSAwO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiB0YXJnZXQpIHtcbiAgICAgIGlmICghdGFyZ2V0Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc291cmNlW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHRhcmdldFtuYW1lXSkgJiYgIWlzQXJyYXlMaWtlKHRhcmdldFtuYW1lXSkpIHtcbiAgICAgICAgICB0aGlzLl9hbmltYXRlVG9TaGFsbG93KHBhdGggPyBwYXRoICsgJy4nICsgbmFtZSA6IG5hbWUsIHNvdXJjZVtuYW1lXSwgdGFyZ2V0W25hbWVdLCB0aW1lLCBkZWxheSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqU2hhbGxvd1tuYW1lXSA9IHRhcmdldFtuYW1lXTtcbiAgICAgICAgICBwcm9wZXJ0eUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0W25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgLy8gQXR0ciBkaXJlY3RseSBpZiBub3QgaGFzIHByb3BlcnR5XG4gICAgICAgIC8vIEZJWE1FLCBpZiBzb21lIHByb3BlcnR5IG5vdCBuZWVkZWQgZm9yIGVsZW1lbnQgP1xuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICB0aGlzLmF0dHIobmFtZSwgdGFyZ2V0W25hbWVdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTaGFwZSBvciBzdHlsZVxuICAgICAgICAgIHZhciBwcm9wcyA9IHt9O1xuICAgICAgICAgIHByb3BzW3BhdGhdID0ge307XG4gICAgICAgICAgcHJvcHNbcGF0aF1bbmFtZV0gPSB0YXJnZXRbbmFtZV07XG4gICAgICAgICAgdGhpcy5hdHRyKHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9wZXJ0eUNvdW50ID4gMCkge1xuICAgICAgdGhpcy5hbmltYXRlKHBhdGgsIGZhbHNlKS53aGVuKHRpbWUgPT0gbnVsbCA/IDUwMCA6IHRpbWUsIG9ialNoYWxsb3cpLmRlbGF5KGRlbGF5IHx8IDApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gQW5pbWF0YWJsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL21peGluL0FuaW1hdGFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGlwID0gcmVxdWlyZShcIi4vQ2xpcFwiKTtcblxudmFyIGNvbG9yID0gcmVxdWlyZShcIi4uL3Rvb2wvY29sb3JcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBpc0FycmF5TGlrZSA9IF91dGlsLmlzQXJyYXlMaWtlO1xuXG4vKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9hbmltYXRpb24vQW5pbWF0b3JcbiAqL1xudmFyIGFycmF5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXR0ZXIodGFyZ2V0LCBrZXkpIHtcbiAgcmV0dXJuIHRhcmdldFtrZXldO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0U2V0dGVyKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICB0YXJnZXRba2V5XSA9IHZhbHVlO1xufVxuLyoqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGludGVycG9sYXRlTnVtYmVyKHAwLCBwMSwgcGVyY2VudCkge1xuICByZXR1cm4gKHAxIC0gcDApICogcGVyY2VudCArIHAwO1xufVxuLyoqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHAwXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGludGVycG9sYXRlU3RyaW5nKHAwLCBwMSwgcGVyY2VudCkge1xuICByZXR1cm4gcGVyY2VudCA+IDAuNSA/IHAxIDogcDA7XG59XG4vKipcbiAqIEBwYXJhbSAge0FycmF5fSBwMFxuICogQHBhcmFtICB7QXJyYXl9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge251bWJlcn0gYXJyRGltXG4gKi9cblxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUFycmF5KHAwLCBwMSwgcGVyY2VudCwgb3V0LCBhcnJEaW0pIHtcbiAgdmFyIGxlbiA9IHAwLmxlbmd0aDtcblxuICBpZiAoYXJyRGltID09IDEpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBvdXRbaV0gPSBpbnRlcnBvbGF0ZU51bWJlcihwMFtpXSwgcDFbaV0sIHBlcmNlbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuMiA9IGxlbiAmJiBwMFswXS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICBvdXRbaV1bal0gPSBpbnRlcnBvbGF0ZU51bWJlcihwMFtpXVtqXSwgcDFbaV1bal0sIHBlcmNlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyBhcnIwIGlzIHNvdXJjZSBhcnJheSwgYXJyMSBpcyB0YXJnZXQgYXJyYXkuXG4vLyBEbyBzb21lIHByZXByb2Nlc3MgdG8gYXZvaWQgZXJyb3IgaGFwcGVuZWQgd2hlbiBpbnRlcnBvbGF0aW5nIGZyb20gYXJyMCB0byBhcnIxXG5cblxuZnVuY3Rpb24gZmlsbEFycihhcnIwLCBhcnIxLCBhcnJEaW0pIHtcbiAgdmFyIGFycjBMZW4gPSBhcnIwLmxlbmd0aDtcbiAgdmFyIGFycjFMZW4gPSBhcnIxLmxlbmd0aDtcblxuICBpZiAoYXJyMExlbiAhPT0gYXJyMUxlbikge1xuICAgIC8vIEZJWE1FIE5vdCB3b3JrIGZvciBUeXBlZEFycmF5XG4gICAgdmFyIGlzUHJldmlvdXNMYXJnZXIgPSBhcnIwTGVuID4gYXJyMUxlbjtcblxuICAgIGlmIChpc1ByZXZpb3VzTGFyZ2VyKSB7XG4gICAgICAvLyBDdXQgdGhlIHByZXZpb3VzXG4gICAgICBhcnIwLmxlbmd0aCA9IGFycjFMZW47XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbGwgdGhlIHByZXZpb3VzXG4gICAgICBmb3IgKHZhciBpID0gYXJyMExlbjsgaSA8IGFycjFMZW47IGkrKykge1xuICAgICAgICBhcnIwLnB1c2goYXJyRGltID09PSAxID8gYXJyMVtpXSA6IGFycmF5U2xpY2UuY2FsbChhcnIxW2ldKSk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEhhbmRsaW5nIE5hTiB2YWx1ZVxuXG5cbiAgdmFyIGxlbjIgPSBhcnIwWzBdICYmIGFycjBbMF0ubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyMC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJEaW0gPT09IDEpIHtcbiAgICAgIGlmIChpc05hTihhcnIwW2ldKSkge1xuICAgICAgICBhcnIwW2ldID0gYXJyMVtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgaWYgKGlzTmFOKGFycjBbaV1bal0pKSB7XG4gICAgICAgICAgYXJyMFtpXVtqXSA9IGFycjFbaV1bal07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtICB7QXJyYXl9IGFycjBcbiAqIEBwYXJhbSAge0FycmF5fSBhcnIxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFyckRpbVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzQXJyYXlTYW1lKGFycjAsIGFycjEsIGFyckRpbSkge1xuICBpZiAoYXJyMCA9PT0gYXJyMSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGxlbiA9IGFycjAubGVuZ3RoO1xuXG4gIGlmIChsZW4gIT09IGFycjEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGFyckRpbSA9PT0gMSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChhcnIwW2ldICE9PSBhcnIxW2ldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbjIgPSBhcnIwWzBdLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgIGlmIChhcnIwW2ldW2pdICE9PSBhcnIxW2ldW2pdKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIENhdG11bGwgUm9tIGludGVycG9sYXRlIGFycmF5XG4gKiBAcGFyYW0gIHtBcnJheX0gcDBcbiAqIEBwYXJhbSAge0FycmF5fSBwMVxuICogQHBhcmFtICB7QXJyYXl9IHAyXG4gKiBAcGFyYW0gIHtBcnJheX0gcDNcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7bnVtYmVyfSB0MlxuICogQHBhcmFtICB7bnVtYmVyfSB0M1xuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNhdG11bGxSb21JbnRlcnBvbGF0ZUFycmF5KHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMsIG91dCwgYXJyRGltKSB7XG4gIHZhciBsZW4gPSBwMC5sZW5ndGg7XG5cbiAgaWYgKGFyckRpbSA9PSAxKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgb3V0W2ldID0gY2F0bXVsbFJvbUludGVycG9sYXRlKHAwW2ldLCBwMVtpXSwgcDJbaV0sIHAzW2ldLCB0LCB0MiwgdDMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuMiA9IHAwWzBdLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgIG91dFtpXVtqXSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZShwMFtpXVtqXSwgcDFbaV1bal0sIHAyW2ldW2pdLCBwM1tpXVtqXSwgdCwgdDIsIHQzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQ2F0bXVsbCBSb20gaW50ZXJwb2xhdGUgbnVtYmVyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge251bWJlcn0gdDJcbiAqIEBwYXJhbSAge251bWJlcn0gdDNcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNhdG11bGxSb21JbnRlcnBvbGF0ZShwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzKSB7XG4gIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNTtcbiAgdmFyIHYxID0gKHAzIC0gcDEpICogMC41O1xuICByZXR1cm4gKDIgKiAocDEgLSBwMikgKyB2MCArIHYxKSAqIHQzICsgKC0zICogKHAxIC0gcDIpIC0gMiAqIHYwIC0gdjEpICogdDIgKyB2MCAqIHQgKyBwMTtcbn1cblxuZnVuY3Rpb24gY2xvbmVWYWx1ZSh2YWx1ZSkge1xuICBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aDtcblxuICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZVswXSkpIHtcbiAgICAgIHZhciByZXQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByZXQucHVzaChhcnJheVNsaWNlLmNhbGwodmFsdWVbaV0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlTbGljZS5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcmdiYTJTdHJpbmcocmdiYSkge1xuICByZ2JhWzBdID0gTWF0aC5mbG9vcihyZ2JhWzBdKTtcbiAgcmdiYVsxXSA9IE1hdGguZmxvb3IocmdiYVsxXSk7XG4gIHJnYmFbMl0gPSBNYXRoLmZsb29yKHJnYmFbMl0pO1xuICByZXR1cm4gJ3JnYmEoJyArIHJnYmEuam9pbignLCcpICsgJyknO1xufVxuXG5mdW5jdGlvbiBnZXRBcnJheURpbShrZXlmcmFtZXMpIHtcbiAgdmFyIGxhc3RWYWx1ZSA9IGtleWZyYW1lc1trZXlmcmFtZXMubGVuZ3RoIC0gMV0udmFsdWU7XG4gIHJldHVybiBpc0FycmF5TGlrZShsYXN0VmFsdWUgJiYgbGFzdFZhbHVlWzBdKSA/IDIgOiAxO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFja0NsaXAoYW5pbWF0b3IsIGVhc2luZywgb25lVHJhY2tEb25lLCBrZXlmcmFtZXMsIHByb3BOYW1lLCBmb3JjZUFuaW1hdGUpIHtcbiAgdmFyIGdldHRlciA9IGFuaW1hdG9yLl9nZXR0ZXI7XG4gIHZhciBzZXR0ZXIgPSBhbmltYXRvci5fc2V0dGVyO1xuICB2YXIgdXNlU3BsaW5lID0gZWFzaW5nID09PSAnc3BsaW5lJztcbiAgdmFyIHRyYWNrTGVuID0ga2V5ZnJhbWVzLmxlbmd0aDtcblxuICBpZiAoIXRyYWNrTGVuKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIEd1ZXNzIGRhdGEgdHlwZVxuXG5cbiAgdmFyIGZpcnN0VmFsID0ga2V5ZnJhbWVzWzBdLnZhbHVlO1xuICB2YXIgaXNWYWx1ZUFycmF5ID0gaXNBcnJheUxpa2UoZmlyc3RWYWwpO1xuICB2YXIgaXNWYWx1ZUNvbG9yID0gZmFsc2U7XG4gIHZhciBpc1ZhbHVlU3RyaW5nID0gZmFsc2U7IC8vIEZvciB2ZXJ0aWNlcyBtb3JwaGluZ1xuXG4gIHZhciBhcnJEaW0gPSBpc1ZhbHVlQXJyYXkgPyBnZXRBcnJheURpbShrZXlmcmFtZXMpIDogMDtcbiAgdmFyIHRyYWNrTWF4VGltZTsgLy8gU29ydCBrZXlmcmFtZSBhcyBhc2NlbmRpbmdcblxuICBrZXlmcmFtZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLnRpbWUgLSBiLnRpbWU7XG4gIH0pO1xuICB0cmFja01heFRpbWUgPSBrZXlmcmFtZXNbdHJhY2tMZW4gLSAxXS50aW1lOyAvLyBQZXJjZW50cyBvZiBlYWNoIGtleWZyYW1lXG5cbiAgdmFyIGtmUGVyY2VudHMgPSBbXTsgLy8gVmFsdWUgb2YgZWFjaCBrZXlmcmFtZVxuXG4gIHZhciBrZlZhbHVlcyA9IFtdO1xuICB2YXIgcHJldlZhbHVlID0ga2V5ZnJhbWVzWzBdLnZhbHVlO1xuICB2YXIgaXNBbGxWYWx1ZUVxdWFsID0gdHJ1ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGVuOyBpKyspIHtcbiAgICBrZlBlcmNlbnRzLnB1c2goa2V5ZnJhbWVzW2ldLnRpbWUgLyB0cmFja01heFRpbWUpOyAvLyBBc3N1bWUgdmFsdWUgaXMgYSBjb2xvciB3aGVuIGl0IGlzIGEgc3RyaW5nXG5cbiAgICB2YXIgdmFsdWUgPSBrZXlmcmFtZXNbaV0udmFsdWU7IC8vIENoZWNrIGlmIHZhbHVlIGlzIGVxdWFsLCBkZWVwIGNoZWNrIGlmIHZhbHVlIGlzIGFycmF5XG5cbiAgICBpZiAoIShpc1ZhbHVlQXJyYXkgJiYgaXNBcnJheVNhbWUodmFsdWUsIHByZXZWYWx1ZSwgYXJyRGltKSB8fCAhaXNWYWx1ZUFycmF5ICYmIHZhbHVlID09PSBwcmV2VmFsdWUpKSB7XG4gICAgICBpc0FsbFZhbHVlRXF1YWwgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBwcmV2VmFsdWUgPSB2YWx1ZTsgLy8gVHJ5IGNvbnZlcnRpbmcgYSBzdHJpbmcgdG8gYSBjb2xvciBhcnJheVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgdmFyIGNvbG9yQXJyYXkgPSBjb2xvci5wYXJzZSh2YWx1ZSk7XG5cbiAgICAgIGlmIChjb2xvckFycmF5KSB7XG4gICAgICAgIHZhbHVlID0gY29sb3JBcnJheTtcbiAgICAgICAgaXNWYWx1ZUNvbG9yID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzVmFsdWVTdHJpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGtmVmFsdWVzLnB1c2godmFsdWUpO1xuICB9XG5cbiAgaWYgKCFmb3JjZUFuaW1hdGUgJiYgaXNBbGxWYWx1ZUVxdWFsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxhc3RWYWx1ZSA9IGtmVmFsdWVzW3RyYWNrTGVuIC0gMV07IC8vIFBvbHlmaWxsIGFycmF5IGFuZCBOYU4gdmFsdWVcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGVuIC0gMTsgaSsrKSB7XG4gICAgaWYgKGlzVmFsdWVBcnJheSkge1xuICAgICAgZmlsbEFycihrZlZhbHVlc1tpXSwgbGFzdFZhbHVlLCBhcnJEaW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNOYU4oa2ZWYWx1ZXNbaV0pICYmICFpc05hTihsYXN0VmFsdWUpICYmICFpc1ZhbHVlU3RyaW5nICYmICFpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAga2ZWYWx1ZXNbaV0gPSBsYXN0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNWYWx1ZUFycmF5ICYmIGZpbGxBcnIoZ2V0dGVyKGFuaW1hdG9yLl90YXJnZXQsIHByb3BOYW1lKSwgbGFzdFZhbHVlLCBhcnJEaW0pOyAvLyBDYWNoZSB0aGUga2V5IG9mIGxhc3QgZnJhbWUgdG8gc3BlZWQgdXAgd2hlblxuICAvLyBhbmltYXRpb24gcGxheWJhY2sgaXMgc2VxdWVuY3lcblxuICB2YXIgbGFzdEZyYW1lID0gMDtcbiAgdmFyIGxhc3RGcmFtZVBlcmNlbnQgPSAwO1xuICB2YXIgc3RhcnQ7XG4gIHZhciB3O1xuICB2YXIgcDA7XG4gIHZhciBwMTtcbiAgdmFyIHAyO1xuICB2YXIgcDM7XG5cbiAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgIHZhciByZ2JhID0gWzAsIDAsIDAsIDBdO1xuICB9XG5cbiAgdmFyIG9uZnJhbWUgPSBmdW5jdGlvbiAodGFyZ2V0LCBwZXJjZW50KSB7XG4gICAgLy8gRmluZCB0aGUgcmFuZ2Uga2V5ZnJhbWVzXG4gICAgLy8ga2YxLS0tLS1rZjItLS0tLS0tLS1jdXJyZW50LS0tLS0tLS1rZjNcbiAgICAvLyBmaW5kIGtmMiBhbmQga2YzIGFuZCBkbyBpbnRlcnBvbGF0aW9uXG4gICAgdmFyIGZyYW1lOyAvLyBJbiB0aGUgZWFzaW5nIGZ1bmN0aW9uIGxpa2UgZWxhc3RpY091dCwgcGVyY2VudCBtYXkgbGVzcyB0aGFuIDBcblxuICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgZnJhbWUgPSAwO1xuICAgIH0gZWxzZSBpZiAocGVyY2VudCA8IGxhc3RGcmFtZVBlcmNlbnQpIHtcbiAgICAgIC8vIFN0YXJ0IGZyb20gbmV4dCBrZXlcbiAgICAgIC8vIFBFTkRJTkcgc3RhcnQgZnJvbSBsYXN0RnJhbWUgP1xuICAgICAgc3RhcnQgPSBNYXRoLm1pbihsYXN0RnJhbWUgKyAxLCB0cmFja0xlbiAtIDEpO1xuXG4gICAgICBmb3IgKGZyYW1lID0gc3RhcnQ7IGZyYW1lID49IDA7IGZyYW1lLS0pIHtcbiAgICAgICAgaWYgKGtmUGVyY2VudHNbZnJhbWVdIDw9IHBlcmNlbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAvLyBQRU5ESU5HIHJlYWxseSBuZWVkIHRvIGRvIHRoaXMgP1xuXG5cbiAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUsIHRyYWNrTGVuIC0gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoZnJhbWUgPSBsYXN0RnJhbWU7IGZyYW1lIDwgdHJhY2tMZW47IGZyYW1lKyspIHtcbiAgICAgICAgaWYgKGtmUGVyY2VudHNbZnJhbWVdID4gcGVyY2VudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUgLSAxLCB0cmFja0xlbiAtIDIpO1xuICAgIH1cblxuICAgIGxhc3RGcmFtZSA9IGZyYW1lO1xuICAgIGxhc3RGcmFtZVBlcmNlbnQgPSBwZXJjZW50O1xuICAgIHZhciByYW5nZSA9IGtmUGVyY2VudHNbZnJhbWUgKyAxXSAtIGtmUGVyY2VudHNbZnJhbWVdO1xuXG4gICAgaWYgKHJhbmdlID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHcgPSAocGVyY2VudCAtIGtmUGVyY2VudHNbZnJhbWVdKSAvIHJhbmdlO1xuICAgIH1cblxuICAgIGlmICh1c2VTcGxpbmUpIHtcbiAgICAgIHAxID0ga2ZWYWx1ZXNbZnJhbWVdO1xuICAgICAgcDAgPSBrZlZhbHVlc1tmcmFtZSA9PT0gMCA/IGZyYW1lIDogZnJhbWUgLSAxXTtcbiAgICAgIHAyID0ga2ZWYWx1ZXNbZnJhbWUgPiB0cmFja0xlbiAtIDIgPyB0cmFja0xlbiAtIDEgOiBmcmFtZSArIDFdO1xuICAgICAgcDMgPSBrZlZhbHVlc1tmcmFtZSA+IHRyYWNrTGVuIC0gMyA/IHRyYWNrTGVuIC0gMSA6IGZyYW1lICsgMl07XG5cbiAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgY2F0bXVsbFJvbUludGVycG9sYXRlQXJyYXkocDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHcsIGdldHRlcih0YXJnZXQsIHByb3BOYW1lKSwgYXJyRGltKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICBpZiAoaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgICAgdmFsdWUgPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShwMCwgcDEsIHAyLCBwMywgdywgdyAqIHcsIHcgKiB3ICogdywgcmdiYSwgMSk7XG4gICAgICAgICAgdmFsdWUgPSByZ2JhMlN0cmluZyhyZ2JhKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ZhbHVlU3RyaW5nKSB7XG4gICAgICAgICAgLy8gU3RyaW5nIGlzIHN0ZXAoMC41KVxuICAgICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZVN0cmluZyhwMSwgcDIsIHcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gY2F0bXVsbFJvbUludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB3LCB3ICogdywgdyAqIHcgKiB3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldHRlcih0YXJnZXQsIHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVBcnJheShrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcsIGdldHRlcih0YXJnZXQsIHByb3BOYW1lKSwgYXJyRGltKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICBpZiAoaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgICAgaW50ZXJwb2xhdGVBcnJheShrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcsIHJnYmEsIDEpO1xuICAgICAgICAgIHZhbHVlID0gcmdiYTJTdHJpbmcocmdiYSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNWYWx1ZVN0cmluZykge1xuICAgICAgICAgIC8vIFN0cmluZyBpcyBzdGVwKDAuNSlcbiAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVTdHJpbmcoa2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGludGVycG9sYXRlTnVtYmVyKGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgY2xpcCA9IG5ldyBDbGlwKHtcbiAgICB0YXJnZXQ6IGFuaW1hdG9yLl90YXJnZXQsXG4gICAgbGlmZTogdHJhY2tNYXhUaW1lLFxuICAgIGxvb3A6IGFuaW1hdG9yLl9sb29wLFxuICAgIGRlbGF5OiBhbmltYXRvci5fZGVsYXksXG4gICAgb25mcmFtZTogb25mcmFtZSxcbiAgICBvbmRlc3Ryb3k6IG9uZVRyYWNrRG9uZVxuICB9KTtcblxuICBpZiAoZWFzaW5nICYmIGVhc2luZyAhPT0gJ3NwbGluZScpIHtcbiAgICBjbGlwLmVhc2luZyA9IGVhc2luZztcbiAgfVxuXG4gIHJldHVybiBjbGlwO1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXJcbiAqL1xuXG5cbnZhciBBbmltYXRvciA9IGZ1bmN0aW9uICh0YXJnZXQsIGxvb3AsIGdldHRlciwgc2V0dGVyKSB7XG4gIHRoaXMuX3RyYWNrcyA9IHt9O1xuICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gIHRoaXMuX2xvb3AgPSBsb29wIHx8IGZhbHNlO1xuICB0aGlzLl9nZXR0ZXIgPSBnZXR0ZXIgfHwgZGVmYXVsdEdldHRlcjtcbiAgdGhpcy5fc2V0dGVyID0gc2V0dGVyIHx8IGRlZmF1bHRTZXR0ZXI7XG4gIHRoaXMuX2NsaXBDb3VudCA9IDA7XG4gIHRoaXMuX2RlbGF5ID0gMDtcbiAgdGhpcy5fZG9uZUxpc3QgPSBbXTtcbiAgdGhpcy5fb25mcmFtZUxpc3QgPSBbXTtcbiAgdGhpcy5fY2xpcExpc3QgPSBbXTtcbn07XG5cbkFuaW1hdG9yLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIOiuvue9ruWKqOeUu+WFs+mUruW4p1xuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRpbWUg5YWz6ZSu5bin5pe26Ze077yM5Y2V5L2N5pivbXNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwcm9wcyDlhbPplK7luKfnmoTlsZ7mgKflgLzvvIxrZXktdmFsdWXooajnpLpcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKi9cbiAgd2hlbjogZnVuY3Rpb24gKHRpbWVcbiAgLyogbXMgKi9cbiAgLCBwcm9wcykge1xuICAgIHZhciB0cmFja3MgPSB0aGlzLl90cmFja3M7XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wcykge1xuICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghdHJhY2tzW3Byb3BOYW1lXSkge1xuICAgICAgICB0cmFja3NbcHJvcE5hbWVdID0gW107IC8vIEludmFsaWQgdmFsdWVcblxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9nZXR0ZXIodGhpcy5fdGFyZ2V0LCBwcm9wTmFtZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAvLyB6ckxvZygnSW52YWxpZCBwcm9wZXJ0eSAnICsgcHJvcE5hbWUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIElmIHRpbWUgaXMgMFxuICAgICAgICAvLyAgVGhlbiBwcm9wcyBpcyBnaXZlbiBpbml0aWFsaXplIHZhbHVlXG4gICAgICAgIC8vIEVsc2VcbiAgICAgICAgLy8gIEluaXRpYWxpemUgdmFsdWUgZnJvbSBjdXJyZW50IHByb3AgdmFsdWVcblxuXG4gICAgICAgIGlmICh0aW1lICE9PSAwKSB7XG4gICAgICAgICAgdHJhY2tzW3Byb3BOYW1lXS5wdXNoKHtcbiAgICAgICAgICAgIHRpbWU6IDAsXG4gICAgICAgICAgICB2YWx1ZTogY2xvbmVWYWx1ZSh2YWx1ZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0cmFja3NbcHJvcE5hbWVdLnB1c2goe1xuICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICB2YWx1ZTogcHJvcHNbcHJvcE5hbWVdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5Yqo55S75q+P5LiA5bin55qE5Zue6LCD5Ye95pWwXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAqL1xuICBkdXJpbmc6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMuX29uZnJhbWVMaXN0LnB1c2goY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jbGlwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fY2xpcExpc3RbaV0ucGF1c2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICB9LFxuICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NsaXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9jbGlwTGlzdFtpXS5yZXN1bWUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgfSxcbiAgaXNQYXVzZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9wYXVzZWQ7XG4gIH0sXG4gIF9kb25lQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBDbGVhciBhbGwgdHJhY2tzXG4gICAgdGhpcy5fdHJhY2tzID0ge307IC8vIENsZWFyIGFsbCBjbGlwc1xuXG4gICAgdGhpcy5fY2xpcExpc3QubGVuZ3RoID0gMDtcbiAgICB2YXIgZG9uZUxpc3QgPSB0aGlzLl9kb25lTGlzdDtcbiAgICB2YXIgbGVuID0gZG9uZUxpc3QubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZG9uZUxpc3RbaV0uY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOW8gOWni+aJp+ihjOWKqOeUu1xuICAgKiBAcGFyYW0gIHtzdHJpbmd8RnVuY3Rpb259IFtlYXNpbmddXG4gICAqICAgICAgICAg5Yqo55S757yT5Yqo5Ye95pWw77yM6K+m6KeBe0BsaW5rIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9lYXNpbmd9XG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGZvcmNlQW5pbWF0ZVxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAqL1xuICBzdGFydDogZnVuY3Rpb24gKGVhc2luZywgZm9yY2VBbmltYXRlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjbGlwQ291bnQgPSAwO1xuXG4gICAgdmFyIG9uZVRyYWNrRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNsaXBDb3VudC0tO1xuXG4gICAgICBpZiAoIWNsaXBDb3VudCkge1xuICAgICAgICBzZWxmLl9kb25lQ2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGxhc3RDbGlwO1xuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdGhpcy5fdHJhY2tzKSB7XG4gICAgICBpZiAoIXRoaXMuX3RyYWNrcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjbGlwID0gY3JlYXRlVHJhY2tDbGlwKHRoaXMsIGVhc2luZywgb25lVHJhY2tEb25lLCB0aGlzLl90cmFja3NbcHJvcE5hbWVdLCBwcm9wTmFtZSwgZm9yY2VBbmltYXRlKTtcblxuICAgICAgaWYgKGNsaXApIHtcbiAgICAgICAgdGhpcy5fY2xpcExpc3QucHVzaChjbGlwKTtcblxuICAgICAgICBjbGlwQ291bnQrKzsgLy8gSWYgc3RhcnQgYWZ0ZXIgYWRkZWQgdG8gYW5pbWF0aW9uXG5cbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5hbmltYXRpb24uYWRkQ2xpcChjbGlwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RDbGlwID0gY2xpcDtcbiAgICAgIH1cbiAgICB9IC8vIEFkZCBkdXJpbmcgY2FsbGJhY2sgb24gdGhlIGxhc3QgY2xpcFxuXG5cbiAgICBpZiAobGFzdENsaXApIHtcbiAgICAgIHZhciBvbGRPbkZyYW1lID0gbGFzdENsaXAub25mcmFtZTtcblxuICAgICAgbGFzdENsaXAub25mcmFtZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHBlcmNlbnQpIHtcbiAgICAgICAgb2xkT25GcmFtZSh0YXJnZXQsIHBlcmNlbnQpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5fb25mcmFtZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzZWxmLl9vbmZyYW1lTGlzdFtpXSh0YXJnZXQsIHBlcmNlbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gLy8gVGhpcyBvcHRpbWl6YXRpb24gd2lsbCBoZWxwIHRoZSBjYXNlIHRoYXQgaW4gdGhlIHVwcGVyIGFwcGxpY2F0aW9uXG4gICAgLy8gdGhlIHZpZXcgbWF5IGJlIHJlZnJlc2hlZCBmcmVxdWVudGx5LCB3aGVyZSBhbmltYXRpb24gd2lsbCBiZVxuICAgIC8vIGNhbGxlZCByZXBlYXRseSBidXQgbm90aGluZyBjaGFuZ2VkLlxuXG5cbiAgICBpZiAoIWNsaXBDb3VudCkge1xuICAgICAgdGhpcy5fZG9uZUNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWBnOatouWKqOeUu1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcndhcmRUb0xhc3QgSWYgbW92ZSB0byBsYXN0IGZyYW1lIGJlZm9yZSBzdG9wXG4gICAqL1xuICBzdG9wOiBmdW5jdGlvbiAoZm9yd2FyZFRvTGFzdCkge1xuICAgIHZhciBjbGlwTGlzdCA9IHRoaXMuX2NsaXBMaXN0O1xuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjbGlwID0gY2xpcExpc3RbaV07XG5cbiAgICAgIGlmIChmb3J3YXJkVG9MYXN0KSB7XG4gICAgICAgIC8vIE1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgICAgICBjbGlwLm9uZnJhbWUodGhpcy5fdGFyZ2V0LCAxKTtcbiAgICAgIH1cblxuICAgICAgYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5yZW1vdmVDbGlwKGNsaXApO1xuICAgIH1cblxuICAgIGNsaXBMaXN0Lmxlbmd0aCA9IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOiuvue9ruWKqOeUu+W7tui/n+W8gOWni+eahOaXtumXtFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRpbWUg5Y2V5L2NbXNcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKi9cbiAgZGVsYXk6IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgdGhpcy5fZGVsYXkgPSB0aW1lO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqDliqjnlLvnu5PmnZ/nmoTlm57osINcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICovXG4gIGRvbmU6IGZ1bmN0aW9uIChjYikge1xuICAgIGlmIChjYikge1xuICAgICAgdGhpcy5fZG9uZUxpc3QucHVzaChjYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcD59XG4gICAqL1xuICBnZXRDbGlwczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jbGlwTGlzdDtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IEFuaW1hdG9yO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZWFzaW5nRnVuY3MgPSByZXF1aXJlKFwiLi9lYXNpbmdcIik7XG5cbi8qKlxuICog5Yqo55S75Li75o6n5Yi25ZmoXG4gKiBAY29uZmlnIHRhcmdldCDliqjnlLvlr7nosaHvvIzlj6/ku6XmmK/mlbDnu4TvvIzlpoLmnpzmmK/mlbDnu4TnmoTor53kvJrmibnph4/liIblj5FvbmZyYW1l562J5LqL5Lu2XG4gKiBAY29uZmlnIGxpZmUoMTAwMCkg5Yqo55S75pe26ZW/XG4gKiBAY29uZmlnIGRlbGF5KDApIOWKqOeUu+W7tui/n+aXtumXtFxuICogQGNvbmZpZyBsb29wKHRydWUpXG4gKiBAY29uZmlnIGdhcCgwKSDlvqrnjq/nmoTpl7TpmpTml7bpl7RcbiAqIEBjb25maWcgb25mcmFtZVxuICogQGNvbmZpZyBlYXNpbmcob3B0aW9uYWwpXG4gKiBAY29uZmlnIG9uZGVzdHJveShvcHRpb25hbClcbiAqIEBjb25maWcgb25yZXN0YXJ0KG9wdGlvbmFsKVxuICpcbiAqIFRPRE8gcGF1c2VcbiAqL1xuZnVuY3Rpb24gQ2xpcChvcHRpb25zKSB7XG4gIHRoaXMuX3RhcmdldCA9IG9wdGlvbnMudGFyZ2V0OyAvLyDnlJ/lkb3lkajmnJ9cblxuICB0aGlzLl9saWZlID0gb3B0aW9ucy5saWZlIHx8IDEwMDA7IC8vIOW7tuaXtlxuXG4gIHRoaXMuX2RlbGF5ID0gb3B0aW9ucy5kZWxheSB8fCAwOyAvLyDlvIDlp4vml7bpl7RcbiAgLy8gdGhpcy5fc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyB0aGlzLl9kZWxheTsvLyDljZXkvY3mr6vnp5JcblxuICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlOyAvLyDmmK/lkKblvqrnjq9cblxuICB0aGlzLmxvb3AgPSBvcHRpb25zLmxvb3AgPT0gbnVsbCA/IGZhbHNlIDogb3B0aW9ucy5sb29wO1xuICB0aGlzLmdhcCA9IG9wdGlvbnMuZ2FwIHx8IDA7XG4gIHRoaXMuZWFzaW5nID0gb3B0aW9ucy5lYXNpbmcgfHwgJ0xpbmVhcic7XG4gIHRoaXMub25mcmFtZSA9IG9wdGlvbnMub25mcmFtZTtcbiAgdGhpcy5vbmRlc3Ryb3kgPSBvcHRpb25zLm9uZGVzdHJveTtcbiAgdGhpcy5vbnJlc3RhcnQgPSBvcHRpb25zLm9ucmVzdGFydDtcbiAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG4gIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xufVxuXG5DbGlwLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IENsaXAsXG4gIHN0ZXA6IGZ1bmN0aW9uIChnbG9iYWxUaW1lLCBkZWx0YVRpbWUpIHtcbiAgICAvLyBTZXQgc3RhcnRUaW1lIG9uIGZpcnN0IHN0ZXAsIG9yIF9zdGFydFRpbWUgbWF5IGhhcyBtaWxsZXNlY29uZHMgZGlmZmVyZW50IGJldHdlZW4gY2xpcHNcbiAgICAvLyBQRU5ESU5HXG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgdGhpcy5fc3RhcnRUaW1lID0gZ2xvYmFsVGltZSArIHRoaXMuX2RlbGF5O1xuICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wYXVzZWQpIHtcbiAgICAgIHRoaXMuX3BhdXNlZFRpbWUgKz0gZGVsdGFUaW1lO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwZXJjZW50ID0gKGdsb2JhbFRpbWUgLSB0aGlzLl9zdGFydFRpbWUgLSB0aGlzLl9wYXVzZWRUaW1lKSAvIHRoaXMuX2xpZmU7IC8vIOi/mOayoeW8gOWni1xuXG4gICAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGVyY2VudCA9IE1hdGgubWluKHBlcmNlbnQsIDEpO1xuICAgIHZhciBlYXNpbmcgPSB0aGlzLmVhc2luZztcbiAgICB2YXIgZWFzaW5nRnVuYyA9IHR5cGVvZiBlYXNpbmcgPT0gJ3N0cmluZycgPyBlYXNpbmdGdW5jc1tlYXNpbmddIDogZWFzaW5nO1xuICAgIHZhciBzY2hlZHVsZSA9IHR5cGVvZiBlYXNpbmdGdW5jID09PSAnZnVuY3Rpb24nID8gZWFzaW5nRnVuYyhwZXJjZW50KSA6IHBlcmNlbnQ7XG4gICAgdGhpcy5maXJlKCdmcmFtZScsIHNjaGVkdWxlKTsgLy8g57uT5p2fXG5cbiAgICBpZiAocGVyY2VudCA9PSAxKSB7XG4gICAgICBpZiAodGhpcy5sb29wKSB7XG4gICAgICAgIHRoaXMucmVzdGFydChnbG9iYWxUaW1lKTsgLy8g6YeN5paw5byA5aeL5ZGo5pyfXG4gICAgICAgIC8vIOaKm+WHuuiAjOS4jeaYr+ebtOaOpeiwg+eUqOS6i+S7tuebtOWIsCBzdGFnZS51cGRhdGUg5ZCO5YaN57uf5LiA6LCD55So6L+Z5Lqb5LqL5Lu2XG5cbiAgICAgICAgcmV0dXJuICdyZXN0YXJ0JztcbiAgICAgIH0gLy8g5Yqo55S75a6M5oiQ5bCG6L+Z5Liq5o6n5Yi25Zmo5qCH6K+G5Li65b6F5Yig6ZmkXG4gICAgICAvLyDlnKhBbmltYXRpb24udXBkYXRl5Lit6L+b6KGM5om56YeP5Yig6ZmkXG5cblxuICAgICAgdGhpcy5fbmVlZHNSZW1vdmUgPSB0cnVlO1xuICAgICAgcmV0dXJuICdkZXN0cm95JztcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgcmVzdGFydDogZnVuY3Rpb24gKGdsb2JhbFRpbWUpIHtcbiAgICB2YXIgcmVtYWluZGVyID0gKGdsb2JhbFRpbWUgLSB0aGlzLl9zdGFydFRpbWUgLSB0aGlzLl9wYXVzZWRUaW1lKSAlIHRoaXMuX2xpZmU7XG4gICAgdGhpcy5fc3RhcnRUaW1lID0gZ2xvYmFsVGltZSAtIHJlbWFpbmRlciArIHRoaXMuZ2FwO1xuICAgIHRoaXMuX3BhdXNlZFRpbWUgPSAwO1xuICAgIHRoaXMuX25lZWRzUmVtb3ZlID0gZmFsc2U7XG4gIH0sXG4gIGZpcmU6IGZ1bmN0aW9uIChldmVudFR5cGUsIGFyZykge1xuICAgIGV2ZW50VHlwZSA9ICdvbicgKyBldmVudFR5cGU7XG5cbiAgICBpZiAodGhpc1tldmVudFR5cGVdKSB7XG4gICAgICB0aGlzW2V2ZW50VHlwZV0odGhpcy5fdGFyZ2V0LCBhcmcpO1xuICAgIH1cbiAgfSxcbiAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICB9LFxuICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IENsaXA7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQ2xpcC5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiDnvJPliqjku6PnoIHmnaXoh6ogaHR0cHM6Ly9naXRodWIuY29tL3NvbGUvdHdlZW4uanMvYmxvYi9tYXN0ZXIvc3JjL1R3ZWVuLmpzXG4gKiBAc2VlIGh0dHA6Ly9zb2xlLmdpdGh1Yi5pby90d2Vlbi5qcy9leGFtcGxlcy8wM19ncmFwaHMuaHRtbFxuICogQGV4cG9ydHMgenJlbmRlci9hbmltYXRpb24vZWFzaW5nXG4gKi9cbnZhciBlYXNpbmcgPSB7XG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBsaW5lYXI6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGs7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1YWRyYXRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrICogaztcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVhZHJhdGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrICogKDIgLSBrKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVhZHJhdGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrO1xuICAgIH1cblxuICAgIHJldHVybiAtMC41ICogKC0tayAqIChrIC0gMikgLSAxKTtcbiAgfSxcbiAgLy8g5LiJ5qyh5pa555qE57yT5Yqo77yIdF4z77yJXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGN1YmljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgKiBrICogaztcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY3ViaWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIC0tayAqIGsgKiBrICsgMTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY3ViaWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrO1xuICAgIH1cblxuICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayArIDIpO1xuICB9LFxuICAvLyDlm5vmrKHmlrnnmoTnvJPliqjvvIh0XjTvvIlcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVhcnRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrICogayAqIGsgKiBrO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWFydGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAxIC0gLS1rICogayAqIGsgKiBrO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWFydGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGs7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0wLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgLSAyKTtcbiAgfSxcbiAgLy8g5LqU5qyh5pa555qE57yT5Yqo77yIdF4177yJXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1aW50aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayAqIGsgKiBrICogayAqIGs7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1aW50aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIC0tayAqIGsgKiBrICogayAqIGsgKyAxO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWludGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGsgKiBrO1xuICAgIH1cblxuICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgKiBrICsgMik7XG4gIH0sXG4gIC8vIOato+W8puabsue6v+eahOe8k+WKqO+8iHNpbih0Ke+8iVxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBzaW51c29pZGFsSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLmNvcyhrICogTWF0aC5QSSAvIDIpO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBzaW51c29pZGFsT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBNYXRoLnNpbihrICogTWF0aC5QSSAvIDIpO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBzaW51c29pZGFsSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKTtcbiAgfSxcbiAgLy8g5oyH5pWw5puy57q/55qE57yT5Yqo77yIMl5077yJXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGV4cG9uZW50aWFsSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgPT09IDAgPyAwIDogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBleHBvbmVudGlhbE91dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayA9PT0gMSA/IDEgOiAxIC0gTWF0aC5wb3coMiwgLTEwICogayk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGV4cG9uZW50aWFsSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKGsgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChrID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuICAgIH1cblxuICAgIHJldHVybiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqIChrIC0gMSkpICsgMik7XG4gIH0sXG4gIC8vIOWchuW9ouabsue6v+eahOe8k+WKqO+8iHNxcnQoMS10XjIp77yJXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGNpcmN1bGFySW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIGsgKiBrKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY2lyY3VsYXJPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgxIC0gLS1rICogayk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGNpcmN1bGFySW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSBrICogaykgLSAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKGsgLT0gMikgKiBrKSArIDEpO1xuICB9LFxuICAvLyDliJvlu7rnsbvkvLzkuo7lvLnnsKflnKjlgZzmraLliY3mnaXlm57mjK/ojaHnmoTliqjnlLtcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgZWxhc3RpY0luOiBmdW5jdGlvbiAoaykge1xuICAgIHZhciBzO1xuICAgIHZhciBhID0gMC4xO1xuICAgIHZhciBwID0gMC40O1xuXG4gICAgaWYgKGsgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChrID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgIGEgPSAxO1xuICAgICAgcyA9IHAgLyA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgIH1cblxuICAgIHJldHVybiAtKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBlbGFzdGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHZhciBzO1xuICAgIHZhciBhID0gMC4xO1xuICAgIHZhciBwID0gMC40O1xuXG4gICAgaWYgKGsgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChrID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgIGEgPSAxO1xuICAgICAgcyA9IHAgLyA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgIH1cblxuICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogaykgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICsgMTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgZWxhc3RpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHZhciBzO1xuICAgIHZhciBhID0gMC4xO1xuICAgIHZhciBwID0gMC40O1xuXG4gICAgaWYgKGsgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChrID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgIGEgPSAxO1xuICAgICAgcyA9IHAgLyA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgIH1cblxuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAtMC41ICogKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuICAgIH1cblxuICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogKGsgLT0gMSkpICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSAqIDAuNSArIDE7XG4gIH0sXG4gIC8vIOWcqOafkOS4gOWKqOeUu+W8gOWni+ayv+aMh+ekuueahOi3r+W+hOi/m+ihjOWKqOeUu+WkhOeQhuWJjeeojeeojeaUtuWbnuivpeWKqOeUu+eahOenu+WKqFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBiYWNrSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiBrICogayAqICgocyArIDEpICogayAtIHMpO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBiYWNrT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHZhciBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gLS1rICogayAqICgocyArIDEpICogayArIHMpICsgMTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgYmFja0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHZhciBzID0gMS43MDE1OCAqIDEuNTI1O1xuXG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIChrICogayAqICgocyArIDEpICogayAtIHMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqICgocyArIDEpICogayArIHMpICsgMik7XG4gIH0sXG4gIC8vIOWIm+W7uuW8uei3s+aViOaenFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBib3VuY2VJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gMSAtIGVhc2luZy5ib3VuY2VPdXQoMSAtIGspO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBib3VuY2VPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKGsgPCAxIC8gMi43NSkge1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIGsgKiBrO1xuICAgIH0gZWxzZSBpZiAoayA8IDIgLyAyLjc1KSB7XG4gICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gMS41IC8gMi43NSkgKiBrICsgMC43NTtcbiAgICB9IGVsc2UgaWYgKGsgPCAyLjUgLyAyLjc1KSB7XG4gICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gMi4yNSAvIDIuNzUpICogayArIDAuOTM3NTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09IDIuNjI1IC8gMi43NSkgKiBrICsgMC45ODQzNzU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBib3VuY2VJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoayA8IDAuNSkge1xuICAgICAgcmV0dXJuIGVhc2luZy5ib3VuY2VJbihrICogMikgKiAwLjU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVhc2luZy5ib3VuY2VPdXQoayAqIDIgLSAxKSAqIDAuNSArIDAuNTtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IGVhc2luZztcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9lYXNpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBMUlUgPSByZXF1aXJlKFwiLi4vY29yZS9MUlVcIik7XG5cbnZhciBrQ1NTQ29sb3JUYWJsZSA9IHtcbiAgJ3RyYW5zcGFyZW50JzogWzAsIDAsIDAsIDBdLFxuICAnYWxpY2VibHVlJzogWzI0MCwgMjQ4LCAyNTUsIDFdLFxuICAnYW50aXF1ZXdoaXRlJzogWzI1MCwgMjM1LCAyMTUsIDFdLFxuICAnYXF1YSc6IFswLCAyNTUsIDI1NSwgMV0sXG4gICdhcXVhbWFyaW5lJzogWzEyNywgMjU1LCAyMTIsIDFdLFxuICAnYXp1cmUnOiBbMjQwLCAyNTUsIDI1NSwgMV0sXG4gICdiZWlnZSc6IFsyNDUsIDI0NSwgMjIwLCAxXSxcbiAgJ2Jpc3F1ZSc6IFsyNTUsIDIyOCwgMTk2LCAxXSxcbiAgJ2JsYWNrJzogWzAsIDAsIDAsIDFdLFxuICAnYmxhbmNoZWRhbG1vbmQnOiBbMjU1LCAyMzUsIDIwNSwgMV0sXG4gICdibHVlJzogWzAsIDAsIDI1NSwgMV0sXG4gICdibHVldmlvbGV0JzogWzEzOCwgNDMsIDIyNiwgMV0sXG4gICdicm93bic6IFsxNjUsIDQyLCA0MiwgMV0sXG4gICdidXJseXdvb2QnOiBbMjIyLCAxODQsIDEzNSwgMV0sXG4gICdjYWRldGJsdWUnOiBbOTUsIDE1OCwgMTYwLCAxXSxcbiAgJ2NoYXJ0cmV1c2UnOiBbMTI3LCAyNTUsIDAsIDFdLFxuICAnY2hvY29sYXRlJzogWzIxMCwgMTA1LCAzMCwgMV0sXG4gICdjb3JhbCc6IFsyNTUsIDEyNywgODAsIDFdLFxuICAnY29ybmZsb3dlcmJsdWUnOiBbMTAwLCAxNDksIDIzNywgMV0sXG4gICdjb3Juc2lsayc6IFsyNTUsIDI0OCwgMjIwLCAxXSxcbiAgJ2NyaW1zb24nOiBbMjIwLCAyMCwgNjAsIDFdLFxuICAnY3lhbic6IFswLCAyNTUsIDI1NSwgMV0sXG4gICdkYXJrYmx1ZSc6IFswLCAwLCAxMzksIDFdLFxuICAnZGFya2N5YW4nOiBbMCwgMTM5LCAxMzksIDFdLFxuICAnZGFya2dvbGRlbnJvZCc6IFsxODQsIDEzNCwgMTEsIDFdLFxuICAnZGFya2dyYXknOiBbMTY5LCAxNjksIDE2OSwgMV0sXG4gICdkYXJrZ3JlZW4nOiBbMCwgMTAwLCAwLCAxXSxcbiAgJ2RhcmtncmV5JzogWzE2OSwgMTY5LCAxNjksIDFdLFxuICAnZGFya2toYWtpJzogWzE4OSwgMTgzLCAxMDcsIDFdLFxuICAnZGFya21hZ2VudGEnOiBbMTM5LCAwLCAxMzksIDFdLFxuICAnZGFya29saXZlZ3JlZW4nOiBbODUsIDEwNywgNDcsIDFdLFxuICAnZGFya29yYW5nZSc6IFsyNTUsIDE0MCwgMCwgMV0sXG4gICdkYXJrb3JjaGlkJzogWzE1MywgNTAsIDIwNCwgMV0sXG4gICdkYXJrcmVkJzogWzEzOSwgMCwgMCwgMV0sXG4gICdkYXJrc2FsbW9uJzogWzIzMywgMTUwLCAxMjIsIDFdLFxuICAnZGFya3NlYWdyZWVuJzogWzE0MywgMTg4LCAxNDMsIDFdLFxuICAnZGFya3NsYXRlYmx1ZSc6IFs3MiwgNjEsIDEzOSwgMV0sXG4gICdkYXJrc2xhdGVncmF5JzogWzQ3LCA3OSwgNzksIDFdLFxuICAnZGFya3NsYXRlZ3JleSc6IFs0NywgNzksIDc5LCAxXSxcbiAgJ2Rhcmt0dXJxdW9pc2UnOiBbMCwgMjA2LCAyMDksIDFdLFxuICAnZGFya3Zpb2xldCc6IFsxNDgsIDAsIDIxMSwgMV0sXG4gICdkZWVwcGluayc6IFsyNTUsIDIwLCAxNDcsIDFdLFxuICAnZGVlcHNreWJsdWUnOiBbMCwgMTkxLCAyNTUsIDFdLFxuICAnZGltZ3JheSc6IFsxMDUsIDEwNSwgMTA1LCAxXSxcbiAgJ2RpbWdyZXknOiBbMTA1LCAxMDUsIDEwNSwgMV0sXG4gICdkb2RnZXJibHVlJzogWzMwLCAxNDQsIDI1NSwgMV0sXG4gICdmaXJlYnJpY2snOiBbMTc4LCAzNCwgMzQsIDFdLFxuICAnZmxvcmFsd2hpdGUnOiBbMjU1LCAyNTAsIDI0MCwgMV0sXG4gICdmb3Jlc3RncmVlbic6IFszNCwgMTM5LCAzNCwgMV0sXG4gICdmdWNoc2lhJzogWzI1NSwgMCwgMjU1LCAxXSxcbiAgJ2dhaW5zYm9ybyc6IFsyMjAsIDIyMCwgMjIwLCAxXSxcbiAgJ2dob3N0d2hpdGUnOiBbMjQ4LCAyNDgsIDI1NSwgMV0sXG4gICdnb2xkJzogWzI1NSwgMjE1LCAwLCAxXSxcbiAgJ2dvbGRlbnJvZCc6IFsyMTgsIDE2NSwgMzIsIDFdLFxuICAnZ3JheSc6IFsxMjgsIDEyOCwgMTI4LCAxXSxcbiAgJ2dyZWVuJzogWzAsIDEyOCwgMCwgMV0sXG4gICdncmVlbnllbGxvdyc6IFsxNzMsIDI1NSwgNDcsIDFdLFxuICAnZ3JleSc6IFsxMjgsIDEyOCwgMTI4LCAxXSxcbiAgJ2hvbmV5ZGV3JzogWzI0MCwgMjU1LCAyNDAsIDFdLFxuICAnaG90cGluayc6IFsyNTUsIDEwNSwgMTgwLCAxXSxcbiAgJ2luZGlhbnJlZCc6IFsyMDUsIDkyLCA5MiwgMV0sXG4gICdpbmRpZ28nOiBbNzUsIDAsIDEzMCwgMV0sXG4gICdpdm9yeSc6IFsyNTUsIDI1NSwgMjQwLCAxXSxcbiAgJ2toYWtpJzogWzI0MCwgMjMwLCAxNDAsIDFdLFxuICAnbGF2ZW5kZXInOiBbMjMwLCAyMzAsIDI1MCwgMV0sXG4gICdsYXZlbmRlcmJsdXNoJzogWzI1NSwgMjQwLCAyNDUsIDFdLFxuICAnbGF3bmdyZWVuJzogWzEyNCwgMjUyLCAwLCAxXSxcbiAgJ2xlbW9uY2hpZmZvbic6IFsyNTUsIDI1MCwgMjA1LCAxXSxcbiAgJ2xpZ2h0Ymx1ZSc6IFsxNzMsIDIxNiwgMjMwLCAxXSxcbiAgJ2xpZ2h0Y29yYWwnOiBbMjQwLCAxMjgsIDEyOCwgMV0sXG4gICdsaWdodGN5YW4nOiBbMjI0LCAyNTUsIDI1NSwgMV0sXG4gICdsaWdodGdvbGRlbnJvZHllbGxvdyc6IFsyNTAsIDI1MCwgMjEwLCAxXSxcbiAgJ2xpZ2h0Z3JheSc6IFsyMTEsIDIxMSwgMjExLCAxXSxcbiAgJ2xpZ2h0Z3JlZW4nOiBbMTQ0LCAyMzgsIDE0NCwgMV0sXG4gICdsaWdodGdyZXknOiBbMjExLCAyMTEsIDIxMSwgMV0sXG4gICdsaWdodHBpbmsnOiBbMjU1LCAxODIsIDE5MywgMV0sXG4gICdsaWdodHNhbG1vbic6IFsyNTUsIDE2MCwgMTIyLCAxXSxcbiAgJ2xpZ2h0c2VhZ3JlZW4nOiBbMzIsIDE3OCwgMTcwLCAxXSxcbiAgJ2xpZ2h0c2t5Ymx1ZSc6IFsxMzUsIDIwNiwgMjUwLCAxXSxcbiAgJ2xpZ2h0c2xhdGVncmF5JzogWzExOSwgMTM2LCAxNTMsIDFdLFxuICAnbGlnaHRzbGF0ZWdyZXknOiBbMTE5LCAxMzYsIDE1MywgMV0sXG4gICdsaWdodHN0ZWVsYmx1ZSc6IFsxNzYsIDE5NiwgMjIyLCAxXSxcbiAgJ2xpZ2h0eWVsbG93JzogWzI1NSwgMjU1LCAyMjQsIDFdLFxuICAnbGltZSc6IFswLCAyNTUsIDAsIDFdLFxuICAnbGltZWdyZWVuJzogWzUwLCAyMDUsIDUwLCAxXSxcbiAgJ2xpbmVuJzogWzI1MCwgMjQwLCAyMzAsIDFdLFxuICAnbWFnZW50YSc6IFsyNTUsIDAsIDI1NSwgMV0sXG4gICdtYXJvb24nOiBbMTI4LCAwLCAwLCAxXSxcbiAgJ21lZGl1bWFxdWFtYXJpbmUnOiBbMTAyLCAyMDUsIDE3MCwgMV0sXG4gICdtZWRpdW1ibHVlJzogWzAsIDAsIDIwNSwgMV0sXG4gICdtZWRpdW1vcmNoaWQnOiBbMTg2LCA4NSwgMjExLCAxXSxcbiAgJ21lZGl1bXB1cnBsZSc6IFsxNDcsIDExMiwgMjE5LCAxXSxcbiAgJ21lZGl1bXNlYWdyZWVuJzogWzYwLCAxNzksIDExMywgMV0sXG4gICdtZWRpdW1zbGF0ZWJsdWUnOiBbMTIzLCAxMDQsIDIzOCwgMV0sXG4gICdtZWRpdW1zcHJpbmdncmVlbic6IFswLCAyNTAsIDE1NCwgMV0sXG4gICdtZWRpdW10dXJxdW9pc2UnOiBbNzIsIDIwOSwgMjA0LCAxXSxcbiAgJ21lZGl1bXZpb2xldHJlZCc6IFsxOTksIDIxLCAxMzMsIDFdLFxuICAnbWlkbmlnaHRibHVlJzogWzI1LCAyNSwgMTEyLCAxXSxcbiAgJ21pbnRjcmVhbSc6IFsyNDUsIDI1NSwgMjUwLCAxXSxcbiAgJ21pc3R5cm9zZSc6IFsyNTUsIDIyOCwgMjI1LCAxXSxcbiAgJ21vY2Nhc2luJzogWzI1NSwgMjI4LCAxODEsIDFdLFxuICAnbmF2YWpvd2hpdGUnOiBbMjU1LCAyMjIsIDE3MywgMV0sXG4gICduYXZ5JzogWzAsIDAsIDEyOCwgMV0sXG4gICdvbGRsYWNlJzogWzI1MywgMjQ1LCAyMzAsIDFdLFxuICAnb2xpdmUnOiBbMTI4LCAxMjgsIDAsIDFdLFxuICAnb2xpdmVkcmFiJzogWzEwNywgMTQyLCAzNSwgMV0sXG4gICdvcmFuZ2UnOiBbMjU1LCAxNjUsIDAsIDFdLFxuICAnb3JhbmdlcmVkJzogWzI1NSwgNjksIDAsIDFdLFxuICAnb3JjaGlkJzogWzIxOCwgMTEyLCAyMTQsIDFdLFxuICAncGFsZWdvbGRlbnJvZCc6IFsyMzgsIDIzMiwgMTcwLCAxXSxcbiAgJ3BhbGVncmVlbic6IFsxNTIsIDI1MSwgMTUyLCAxXSxcbiAgJ3BhbGV0dXJxdW9pc2UnOiBbMTc1LCAyMzgsIDIzOCwgMV0sXG4gICdwYWxldmlvbGV0cmVkJzogWzIxOSwgMTEyLCAxNDcsIDFdLFxuICAncGFwYXlhd2hpcCc6IFsyNTUsIDIzOSwgMjEzLCAxXSxcbiAgJ3BlYWNocHVmZic6IFsyNTUsIDIxOCwgMTg1LCAxXSxcbiAgJ3BlcnUnOiBbMjA1LCAxMzMsIDYzLCAxXSxcbiAgJ3BpbmsnOiBbMjU1LCAxOTIsIDIwMywgMV0sXG4gICdwbHVtJzogWzIyMSwgMTYwLCAyMjEsIDFdLFxuICAncG93ZGVyYmx1ZSc6IFsxNzYsIDIyNCwgMjMwLCAxXSxcbiAgJ3B1cnBsZSc6IFsxMjgsIDAsIDEyOCwgMV0sXG4gICdyZWQnOiBbMjU1LCAwLCAwLCAxXSxcbiAgJ3Jvc3licm93bic6IFsxODgsIDE0MywgMTQzLCAxXSxcbiAgJ3JveWFsYmx1ZSc6IFs2NSwgMTA1LCAyMjUsIDFdLFxuICAnc2FkZGxlYnJvd24nOiBbMTM5LCA2OSwgMTksIDFdLFxuICAnc2FsbW9uJzogWzI1MCwgMTI4LCAxMTQsIDFdLFxuICAnc2FuZHlicm93bic6IFsyNDQsIDE2NCwgOTYsIDFdLFxuICAnc2VhZ3JlZW4nOiBbNDYsIDEzOSwgODcsIDFdLFxuICAnc2Vhc2hlbGwnOiBbMjU1LCAyNDUsIDIzOCwgMV0sXG4gICdzaWVubmEnOiBbMTYwLCA4MiwgNDUsIDFdLFxuICAnc2lsdmVyJzogWzE5MiwgMTkyLCAxOTIsIDFdLFxuICAnc2t5Ymx1ZSc6IFsxMzUsIDIwNiwgMjM1LCAxXSxcbiAgJ3NsYXRlYmx1ZSc6IFsxMDYsIDkwLCAyMDUsIDFdLFxuICAnc2xhdGVncmF5JzogWzExMiwgMTI4LCAxNDQsIDFdLFxuICAnc2xhdGVncmV5JzogWzExMiwgMTI4LCAxNDQsIDFdLFxuICAnc25vdyc6IFsyNTUsIDI1MCwgMjUwLCAxXSxcbiAgJ3NwcmluZ2dyZWVuJzogWzAsIDI1NSwgMTI3LCAxXSxcbiAgJ3N0ZWVsYmx1ZSc6IFs3MCwgMTMwLCAxODAsIDFdLFxuICAndGFuJzogWzIxMCwgMTgwLCAxNDAsIDFdLFxuICAndGVhbCc6IFswLCAxMjgsIDEyOCwgMV0sXG4gICd0aGlzdGxlJzogWzIxNiwgMTkxLCAyMTYsIDFdLFxuICAndG9tYXRvJzogWzI1NSwgOTksIDcxLCAxXSxcbiAgJ3R1cnF1b2lzZSc6IFs2NCwgMjI0LCAyMDgsIDFdLFxuICAndmlvbGV0JzogWzIzOCwgMTMwLCAyMzgsIDFdLFxuICAnd2hlYXQnOiBbMjQ1LCAyMjIsIDE3OSwgMV0sXG4gICd3aGl0ZSc6IFsyNTUsIDI1NSwgMjU1LCAxXSxcbiAgJ3doaXRlc21va2UnOiBbMjQ1LCAyNDUsIDI0NSwgMV0sXG4gICd5ZWxsb3cnOiBbMjU1LCAyNTUsIDAsIDFdLFxuICAneWVsbG93Z3JlZW4nOiBbMTU0LCAyMDUsIDUwLCAxXVxufTtcblxuZnVuY3Rpb24gY2xhbXBDc3NCeXRlKGkpIHtcbiAgLy8gQ2xhbXAgdG8gaW50ZWdlciAwIC4uIDI1NS5cbiAgaSA9IE1hdGgucm91bmQoaSk7IC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxuXG4gIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMjU1ID8gMjU1IDogaTtcbn1cblxuZnVuY3Rpb24gY2xhbXBDc3NBbmdsZShpKSB7XG4gIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAzNjAuXG4gIGkgPSBNYXRoLnJvdW5kKGkpOyAvLyBTZWVtcyB0byBiZSB3aGF0IENocm9tZSBkb2VzICh2cyB0cnVuY2F0aW9uKS5cblxuICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDM2MCA/IDM2MCA6IGk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wQ3NzRmxvYXQoZikge1xuICAvLyBDbGFtcCB0byBmbG9hdCAwLjAgLi4gMS4wLlxuICByZXR1cm4gZiA8IDAgPyAwIDogZiA+IDEgPyAxIDogZjtcbn1cblxuZnVuY3Rpb24gcGFyc2VDc3NJbnQoc3RyKSB7XG4gIC8vIGludCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyLmxlbmd0aCAmJiBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgcmV0dXJuIGNsYW1wQ3NzQnl0ZShwYXJzZUZsb2F0KHN0cikgLyAxMDAgKiAyNTUpO1xuICB9XG5cbiAgcmV0dXJuIGNsYW1wQ3NzQnl0ZShwYXJzZUludChzdHIsIDEwKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ3NzRmxvYXQoc3RyKSB7XG4gIC8vIGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gIGlmIChzdHIubGVuZ3RoICYmIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09PSAnJScpIHtcbiAgICByZXR1cm4gY2xhbXBDc3NGbG9hdChwYXJzZUZsb2F0KHN0cikgLyAxMDApO1xuICB9XG5cbiAgcmV0dXJuIGNsYW1wQ3NzRmxvYXQocGFyc2VGbG9hdChzdHIpKTtcbn1cblxuZnVuY3Rpb24gY3NzSHVlVG9SZ2IobTEsIG0yLCBoKSB7XG4gIGlmIChoIDwgMCkge1xuICAgIGggKz0gMTtcbiAgfSBlbHNlIGlmIChoID4gMSkge1xuICAgIGggLT0gMTtcbiAgfVxuXG4gIGlmIChoICogNiA8IDEpIHtcbiAgICByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiBoICogNjtcbiAgfVxuXG4gIGlmIChoICogMiA8IDEpIHtcbiAgICByZXR1cm4gbTI7XG4gIH1cblxuICBpZiAoaCAqIDMgPCAyKSB7XG4gICAgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDIgLyAzIC0gaCkgKiA2O1xuICB9XG5cbiAgcmV0dXJuIG0xO1xufVxuXG5mdW5jdGlvbiBsZXJwTnVtYmVyKGEsIGIsIHApIHtcbiAgcmV0dXJuIGEgKyAoYiAtIGEpICogcDtcbn1cblxuZnVuY3Rpb24gc2V0UmdiYShvdXQsIHIsIGcsIGIsIGEpIHtcbiAgb3V0WzBdID0gcjtcbiAgb3V0WzFdID0gZztcbiAgb3V0WzJdID0gYjtcbiAgb3V0WzNdID0gYTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gY29weVJnYmEob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbnZhciBjb2xvckNhY2hlID0gbmV3IExSVSgyMCk7XG52YXIgbGFzdFJlbW92ZWRBcnIgPSBudWxsO1xuXG5mdW5jdGlvbiBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKSB7XG4gIC8vIFJldXNlIHJlbW92ZWQgYXJyYXlcbiAgaWYgKGxhc3RSZW1vdmVkQXJyKSB7XG4gICAgY29weVJnYmEobGFzdFJlbW92ZWRBcnIsIHJnYmFBcnIpO1xuICB9XG5cbiAgbGFzdFJlbW92ZWRBcnIgPSBjb2xvckNhY2hlLnB1dChjb2xvclN0ciwgbGFzdFJlbW92ZWRBcnIgfHwgcmdiYUFyci5zbGljZSgpKTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yU3RyXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBvdXRcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlKGNvbG9yU3RyLCByZ2JhQXJyKSB7XG4gIGlmICghY29sb3JTdHIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZ2JhQXJyID0gcmdiYUFyciB8fCBbXTtcbiAgdmFyIGNhY2hlZCA9IGNvbG9yQ2FjaGUuZ2V0KGNvbG9yU3RyKTtcblxuICBpZiAoY2FjaGVkKSB7XG4gICAgcmV0dXJuIGNvcHlSZ2JhKHJnYmFBcnIsIGNhY2hlZCk7XG4gIH0gLy8gY29sb3JTdHIgbWF5IGJlIG5vdCBzdHJpbmdcblxuXG4gIGNvbG9yU3RyID0gY29sb3JTdHIgKyAnJzsgLy8gUmVtb3ZlIGFsbCB3aGl0ZXNwYWNlLCBub3QgY29tcGxpYW50LCBidXQgc2hvdWxkIGp1c3QgYmUgbW9yZSBhY2NlcHRpbmcuXG5cbiAgdmFyIHN0ciA9IGNvbG9yU3RyLnJlcGxhY2UoLyAvZywgJycpLnRvTG93ZXJDYXNlKCk7IC8vIENvbG9yIGtleXdvcmRzIChhbmQgdHJhbnNwYXJlbnQpIGxvb2t1cC5cblxuICBpZiAoc3RyIGluIGtDU1NDb2xvclRhYmxlKSB7XG4gICAgY29weVJnYmEocmdiYUFyciwga0NTU0NvbG9yVGFibGVbc3RyXSk7XG4gICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgcmV0dXJuIHJnYmFBcnI7XG4gIH0gLy8gI2FiYyBhbmQgI2FiYzEyMyBzeW50YXguXG5cblxuICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDQpIHtcbiAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG5cbiAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmYpKSB7XG4gICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgIHJldHVybjsgLy8gQ292ZXJzIE5hTi5cbiAgICAgIH1cblxuICAgICAgc2V0UmdiYShyZ2JhQXJyLCAoaXYgJiAweGYwMCkgPj4gNCB8IChpdiAmIDB4ZjAwKSA+PiA4LCBpdiAmIDB4ZjAgfCAoaXYgJiAweGYwKSA+PiA0LCBpdiAmIDB4ZiB8IChpdiAmIDB4ZikgPDwgNCwgMSk7XG4gICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgIHJldHVybiByZ2JhQXJyO1xuICAgIH0gZWxzZSBpZiAoc3RyLmxlbmd0aCA9PT0gNykge1xuICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cblxuICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZmZmZikpIHtcbiAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgcmV0dXJuOyAvLyBDb3ZlcnMgTmFOLlxuICAgICAgfVxuXG4gICAgICBzZXRSZ2JhKHJnYmFBcnIsIChpdiAmIDB4ZmYwMDAwKSA+PiAxNiwgKGl2ICYgMHhmZjAwKSA+PiA4LCBpdiAmIDB4ZmYsIDEpO1xuICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICByZXR1cm4gcmdiYUFycjtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb3AgPSBzdHIuaW5kZXhPZignKCcpLFxuICAgICAgZXAgPSBzdHIuaW5kZXhPZignKScpO1xuXG4gIGlmIChvcCAhPT0gLTEgJiYgZXAgKyAxID09PSBzdHIubGVuZ3RoKSB7XG4gICAgdmFyIGZuYW1lID0gc3RyLnN1YnN0cigwLCBvcCk7XG4gICAgdmFyIHBhcmFtcyA9IHN0ci5zdWJzdHIob3AgKyAxLCBlcCAtIChvcCArIDEpKS5zcGxpdCgnLCcpO1xuICAgIHZhciBhbHBoYSA9IDE7IC8vIFRvIGFsbG93IGNhc2UgZmFsbHRocm91Z2guXG5cbiAgICBzd2l0Y2ggKGZuYW1lKSB7XG4gICAgICBjYXNlICdyZ2JhJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGFscGhhID0gcGFyc2VDc3NGbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAvLyBGYWxsIHRocm91Z2guXG5cbiAgICAgIGNhc2UgJ3JnYic6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIHBhcnNlQ3NzSW50KHBhcmFtc1swXSksIHBhcnNlQ3NzSW50KHBhcmFtc1sxXSksIHBhcnNlQ3NzSW50KHBhcmFtc1syXSksIGFscGhhKTtcbiAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgIHJldHVybiByZ2JhQXJyO1xuXG4gICAgICBjYXNlICdoc2xhJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtc1szXSA9IHBhcnNlQ3NzRmxvYXQocGFyYW1zWzNdKTtcbiAgICAgICAgaHNsYTJyZ2JhKHBhcmFtcywgcmdiYUFycik7XG4gICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICByZXR1cm4gcmdiYUFycjtcblxuICAgICAgY2FzZSAnaHNsJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGhzbGEycmdiYShwYXJhbXMsIHJnYmFBcnIpO1xuICAgICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICByZXR1cm47XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGhzbGFcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHJnYmFcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSByZ2JhXG4gKi9cblxuXG5mdW5jdGlvbiBoc2xhMnJnYmEoaHNsYSwgcmdiYSkge1xuICB2YXIgaCA9IChwYXJzZUZsb2F0KGhzbGFbMF0pICUgMzYwICsgMzYwKSAlIDM2MCAvIDM2MDsgLy8gMCAuLiAxXG4gIC8vIE5PVEUoZGVhbm0pOiBBY2NvcmRpbmcgdG8gdGhlIENTUyBzcGVjIHMvbCBzaG91bGQgb25seSBiZVxuICAvLyBwZXJjZW50YWdlcywgYnV0IHdlIGRvbid0IGJvdGhlciBhbmQgbGV0IGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG5cbiAgdmFyIHMgPSBwYXJzZUNzc0Zsb2F0KGhzbGFbMV0pO1xuICB2YXIgbCA9IHBhcnNlQ3NzRmxvYXQoaHNsYVsyXSk7XG4gIHZhciBtMiA9IGwgPD0gMC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuICB2YXIgbTEgPSBsICogMiAtIG0yO1xuICByZ2JhID0gcmdiYSB8fCBbXTtcbiAgc2V0UmdiYShyZ2JhLCBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoICsgMSAvIDMpICogMjU1KSwgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCkgKiAyNTUpLCBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoIC0gMSAvIDMpICogMjU1KSwgMSk7XG5cbiAgaWYgKGhzbGEubGVuZ3RoID09PSA0KSB7XG4gICAgcmdiYVszXSA9IGhzbGFbM107XG4gIH1cblxuICByZXR1cm4gcmdiYTtcbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcmdiYVxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IGhzbGFcbiAqL1xuXG5cbmZ1bmN0aW9uIHJnYmEyaHNsYShyZ2JhKSB7XG4gIGlmICghcmdiYSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBSR0IgZnJvbSAwIHRvIDI1NVxuXG5cbiAgdmFyIFIgPSByZ2JhWzBdIC8gMjU1O1xuICB2YXIgRyA9IHJnYmFbMV0gLyAyNTU7XG4gIHZhciBCID0gcmdiYVsyXSAvIDI1NTtcbiAgdmFyIHZNaW4gPSBNYXRoLm1pbihSLCBHLCBCKTsgLy8gTWluLiB2YWx1ZSBvZiBSR0JcblxuICB2YXIgdk1heCA9IE1hdGgubWF4KFIsIEcsIEIpOyAvLyBNYXguIHZhbHVlIG9mIFJHQlxuXG4gIHZhciBkZWx0YSA9IHZNYXggLSB2TWluOyAvLyBEZWx0YSBSR0IgdmFsdWVcblxuICB2YXIgTCA9ICh2TWF4ICsgdk1pbikgLyAyO1xuICB2YXIgSDtcbiAgdmFyIFM7IC8vIEhTTCByZXN1bHRzIGZyb20gMCB0byAxXG5cbiAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgSCA9IDA7XG4gICAgUyA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaWYgKEwgPCAwLjUpIHtcbiAgICAgIFMgPSBkZWx0YSAvICh2TWF4ICsgdk1pbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFMgPSBkZWx0YSAvICgyIC0gdk1heCAtIHZNaW4pO1xuICAgIH1cblxuICAgIHZhciBkZWx0YVIgPSAoKHZNYXggLSBSKSAvIDYgKyBkZWx0YSAvIDIpIC8gZGVsdGE7XG4gICAgdmFyIGRlbHRhRyA9ICgodk1heCAtIEcpIC8gNiArIGRlbHRhIC8gMikgLyBkZWx0YTtcbiAgICB2YXIgZGVsdGFCID0gKCh2TWF4IC0gQikgLyA2ICsgZGVsdGEgLyAyKSAvIGRlbHRhO1xuXG4gICAgaWYgKFIgPT09IHZNYXgpIHtcbiAgICAgIEggPSBkZWx0YUIgLSBkZWx0YUc7XG4gICAgfSBlbHNlIGlmIChHID09PSB2TWF4KSB7XG4gICAgICBIID0gMSAvIDMgKyBkZWx0YVIgLSBkZWx0YUI7XG4gICAgfSBlbHNlIGlmIChCID09PSB2TWF4KSB7XG4gICAgICBIID0gMiAvIDMgKyBkZWx0YUcgLSBkZWx0YVI7XG4gICAgfVxuXG4gICAgaWYgKEggPCAwKSB7XG4gICAgICBIICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKEggPiAxKSB7XG4gICAgICBIIC09IDE7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhzbGEgPSBbSCAqIDM2MCwgUywgTF07XG5cbiAgaWYgKHJnYmFbM10gIT0gbnVsbCkge1xuICAgIGhzbGEucHVzaChyZ2JhWzNdKTtcbiAgfVxuXG4gIHJldHVybiBoc2xhO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFxuICogQHJldHVybiB7c3RyaW5nfVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5cbmZ1bmN0aW9uIGxpZnQoY29sb3IsIGxldmVsKSB7XG4gIHZhciBjb2xvckFyciA9IHBhcnNlKGNvbG9yKTtcblxuICBpZiAoY29sb3JBcnIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgaWYgKGxldmVsIDwgMCkge1xuICAgICAgICBjb2xvckFycltpXSA9IGNvbG9yQXJyW2ldICogKDEgLSBsZXZlbCkgfCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sb3JBcnJbaV0gPSAoMjU1IC0gY29sb3JBcnJbaV0pICogbGV2ZWwgKyBjb2xvckFycltpXSB8IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvckFyciwgY29sb3JBcnIubGVuZ3RoID09PSA0ID8gJ3JnYmEnIDogJ3JnYicpO1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICogQHJldHVybiB7c3RyaW5nfVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvSGV4KGNvbG9yKSB7XG4gIHZhciBjb2xvckFyciA9IHBhcnNlKGNvbG9yKTtcblxuICBpZiAoY29sb3JBcnIpIHtcbiAgICByZXR1cm4gKCgxIDw8IDI0KSArIChjb2xvckFyclswXSA8PCAxNikgKyAoY29sb3JBcnJbMV0gPDwgOCkgKyArY29sb3JBcnJbMl0pLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbiAgfVxufVxuLyoqXG4gKiBNYXAgdmFsdWUgdG8gY29sb3IuIEZhc3RlciB0aGFuIGxlcnAgbWV0aG9kcyBiZWNhdXNlIGNvbG9yIGlzIHJlcHJlc2VudGVkIGJ5IHJnYmEgYXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcn0gbm9ybWFsaXplZFZhbHVlIEEgZmxvYXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBjb2xvcnMgTGlzdCBvZiByZ2JhIGNvbG9yIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbb3V0XSBNYXBwZWQgZ2JhIGNvbG9yIGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gd2lsbCBiZSBudWxsL3VuZGVmaW5lZCBpZiBpbnB1dCBpbGxlZ2FsLlxuICovXG5cblxuZnVuY3Rpb24gZmFzdExlcnAobm9ybWFsaXplZFZhbHVlLCBjb2xvcnMsIG91dCkge1xuICBpZiAoIShjb2xvcnMgJiYgY29sb3JzLmxlbmd0aCkgfHwgIShub3JtYWxpemVkVmFsdWUgPj0gMCAmJiBub3JtYWxpemVkVmFsdWUgPD0gMSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvdXQgPSBvdXQgfHwgW107XG4gIHZhciB2YWx1ZSA9IG5vcm1hbGl6ZWRWYWx1ZSAqIChjb2xvcnMubGVuZ3RoIC0gMSk7XG4gIHZhciBsZWZ0SW5kZXggPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgdmFyIHJpZ2h0SW5kZXggPSBNYXRoLmNlaWwodmFsdWUpO1xuICB2YXIgbGVmdENvbG9yID0gY29sb3JzW2xlZnRJbmRleF07XG4gIHZhciByaWdodENvbG9yID0gY29sb3JzW3JpZ2h0SW5kZXhdO1xuICB2YXIgZHYgPSB2YWx1ZSAtIGxlZnRJbmRleDtcbiAgb3V0WzBdID0gY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzBdLCByaWdodENvbG9yWzBdLCBkdikpO1xuICBvdXRbMV0gPSBjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMV0sIHJpZ2h0Q29sb3JbMV0sIGR2KSk7XG4gIG91dFsyXSA9IGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclsyXSwgcmlnaHRDb2xvclsyXSwgZHYpKTtcbiAgb3V0WzNdID0gY2xhbXBDc3NGbG9hdChsZXJwTnVtYmVyKGxlZnRDb2xvclszXSwgcmlnaHRDb2xvclszXSwgZHYpKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuXG5cbnZhciBmYXN0TWFwVG9Db2xvciA9IGZhc3RMZXJwO1xuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbm9ybWFsaXplZFZhbHVlIEEgZmxvYXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY29sb3JzIENvbG9yIGxpc3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBmdWxsT3V0cHV0IERlZmF1bHQgZmFsc2UuXG4gKiBAcmV0dXJuIHsoc3RyaW5nfE9iamVjdCl9IFJlc3VsdCBjb2xvci4gSWYgZnVsbE91dHB1dCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtjb2xvcjogLi4uLCBsZWZ0SW5kZXg6IC4uLiwgcmlnaHRJbmRleDogLi4uLCB2YWx1ZTogLi4ufSxcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuZnVuY3Rpb24gbGVycChub3JtYWxpemVkVmFsdWUsIGNvbG9ycywgZnVsbE91dHB1dCkge1xuICBpZiAoIShjb2xvcnMgJiYgY29sb3JzLmxlbmd0aCkgfHwgIShub3JtYWxpemVkVmFsdWUgPj0gMCAmJiBub3JtYWxpemVkVmFsdWUgPD0gMSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdmFsdWUgPSBub3JtYWxpemVkVmFsdWUgKiAoY29sb3JzLmxlbmd0aCAtIDEpO1xuICB2YXIgbGVmdEluZGV4ID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gIHZhciByaWdodEluZGV4ID0gTWF0aC5jZWlsKHZhbHVlKTtcbiAgdmFyIGxlZnRDb2xvciA9IHBhcnNlKGNvbG9yc1tsZWZ0SW5kZXhdKTtcbiAgdmFyIHJpZ2h0Q29sb3IgPSBwYXJzZShjb2xvcnNbcmlnaHRJbmRleF0pO1xuICB2YXIgZHYgPSB2YWx1ZSAtIGxlZnRJbmRleDtcbiAgdmFyIGNvbG9yID0gc3RyaW5naWZ5KFtjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMF0sIHJpZ2h0Q29sb3JbMF0sIGR2KSksIGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclsxXSwgcmlnaHRDb2xvclsxXSwgZHYpKSwgY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzJdLCByaWdodENvbG9yWzJdLCBkdikpLCBjbGFtcENzc0Zsb2F0KGxlcnBOdW1iZXIobGVmdENvbG9yWzNdLCByaWdodENvbG9yWzNdLCBkdikpXSwgJ3JnYmEnKTtcbiAgcmV0dXJuIGZ1bGxPdXRwdXQgPyB7XG4gICAgY29sb3I6IGNvbG9yLFxuICAgIGxlZnRJbmRleDogbGVmdEluZGV4LFxuICAgIHJpZ2h0SW5kZXg6IHJpZ2h0SW5kZXgsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH0gOiBjb2xvcjtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuXG5cbnZhciBtYXBUb0NvbG9yID0gbGVycDtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gKiBAcGFyYW0ge251bWJlcj19IGggMCB+IDM2MCwgaWdub3JlIHdoZW4gbnVsbC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gcyAwIH4gMSwgaWdub3JlIHdoZW4gbnVsbC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gbCAwIH4gMSwgaWdub3JlIHdoZW4gbnVsbC5cbiAqIEByZXR1cm4ge3N0cmluZ30gQ29sb3Igc3RyaW5nIGluIHJnYmEgZm9ybWF0LlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5mdW5jdGlvbiBtb2RpZnlIU0woY29sb3IsIGgsIHMsIGwpIHtcbiAgY29sb3IgPSBwYXJzZShjb2xvcik7XG5cbiAgaWYgKGNvbG9yKSB7XG4gICAgY29sb3IgPSByZ2JhMmhzbGEoY29sb3IpO1xuICAgIGggIT0gbnVsbCAmJiAoY29sb3JbMF0gPSBjbGFtcENzc0FuZ2xlKGgpKTtcbiAgICBzICE9IG51bGwgJiYgKGNvbG9yWzFdID0gcGFyc2VDc3NGbG9hdChzKSk7XG4gICAgbCAhPSBudWxsICYmIChjb2xvclsyXSA9IHBhcnNlQ3NzRmxvYXQobCkpO1xuICAgIHJldHVybiBzdHJpbmdpZnkoaHNsYTJyZ2JhKGNvbG9yKSwgJ3JnYmEnKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAqIEBwYXJhbSB7bnVtYmVyPX0gYWxwaGEgMCB+IDFcbiAqIEByZXR1cm4ge3N0cmluZ30gQ29sb3Igc3RyaW5nIGluIHJnYmEgZm9ybWF0LlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5cbmZ1bmN0aW9uIG1vZGlmeUFscGhhKGNvbG9yLCBhbHBoYSkge1xuICBjb2xvciA9IHBhcnNlKGNvbG9yKTtcblxuICBpZiAoY29sb3IgJiYgYWxwaGEgIT0gbnVsbCkge1xuICAgIGNvbG9yWzNdID0gY2xhbXBDc3NGbG9hdChhbHBoYSk7XG4gICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvciwgJ3JnYmEnKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhcnJDb2xvciBsaWtlIFsxMiwzMyw0NCwwLjRdXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAncmdiYScsICdoc3ZhJywgLi4uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJlc3VsdCBjb2xvci4gKElmIGlucHV0IGlsbGVnYWwsIHJldHVybiB1bmRlZmluZWQpLlxuICovXG5cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFyckNvbG9yLCB0eXBlKSB7XG4gIGlmICghYXJyQ29sb3IgfHwgIWFyckNvbG9yLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb2xvclN0ciA9IGFyckNvbG9yWzBdICsgJywnICsgYXJyQ29sb3JbMV0gKyAnLCcgKyBhcnJDb2xvclsyXTtcblxuICBpZiAodHlwZSA9PT0gJ3JnYmEnIHx8IHR5cGUgPT09ICdoc3ZhJyB8fCB0eXBlID09PSAnaHNsYScpIHtcbiAgICBjb2xvclN0ciArPSAnLCcgKyBhcnJDb2xvclszXTtcbiAgfVxuXG4gIHJldHVybiB0eXBlICsgJygnICsgY29sb3JTdHIgKyAnKSc7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMubGlmdCA9IGxpZnQ7XG5leHBvcnRzLnRvSGV4ID0gdG9IZXg7XG5leHBvcnRzLmZhc3RMZXJwID0gZmFzdExlcnA7XG5leHBvcnRzLmZhc3RNYXBUb0NvbG9yID0gZmFzdE1hcFRvQ29sb3I7XG5leHBvcnRzLmxlcnAgPSBsZXJwO1xuZXhwb3J0cy5tYXBUb0NvbG9yID0gbWFwVG9Db2xvcjtcbmV4cG9ydHMubW9kaWZ5SFNMID0gbW9kaWZ5SFNMO1xuZXhwb3J0cy5tb2RpZnlBbHBoYSA9IG1vZGlmeUFscGhhO1xuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL3Rvb2wvY29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFNpbXBsZSBMUlUgY2FjaGUgdXNlIGRvdWJseSBsaW5rZWQgbGlzdFxuLy8gQG1vZHVsZSB6cmVuZGVyL2NvcmUvTFJVXG5cbi8qKlxuICogU2ltcGxlIGRvdWJsZSBsaW5rZWQgbGlzdC4gQ29tcGFyZWQgd2l0aCBhcnJheSwgaXQgaGFzIE8oMSkgcmVtb3ZlIG9wZXJhdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTGlua2VkTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICovXG4gIHRoaXMuaGVhZCA9IG51bGw7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAqL1xuXG4gIHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMuX2xlbiA9IDA7XG59O1xuXG52YXIgbGlua2VkTGlzdFByb3RvID0gTGlua2VkTGlzdC5wcm90b3R5cGU7XG4vKipcbiAqIEluc2VydCBhIG5ldyB2YWx1ZSBhdCB0aGUgdGFpbFxuICogQHBhcmFtICB7fSB2YWxcbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICovXG5cbmxpbmtlZExpc3RQcm90by5pbnNlcnQgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHZhciBlbnRyeSA9IG5ldyBFbnRyeSh2YWwpO1xuICB0aGlzLmluc2VydEVudHJ5KGVudHJ5KTtcbiAgcmV0dXJuIGVudHJ5O1xufTtcbi8qKlxuICogSW5zZXJ0IGFuIGVudHJ5IGF0IHRoZSB0YWlsXG4gKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX0gZW50cnlcbiAqL1xuXG5cbmxpbmtlZExpc3RQcm90by5pbnNlcnRFbnRyeSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IGVudHJ5O1xuICB9IGVsc2Uge1xuICAgIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7XG4gICAgZW50cnkucHJldiA9IHRoaXMudGFpbDtcbiAgICBlbnRyeS5uZXh0ID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgfVxuXG4gIHRoaXMuX2xlbisrO1xufTtcbi8qKlxuICogUmVtb3ZlIGVudHJ5LlxuICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9IGVudHJ5XG4gKi9cblxuXG5saW5rZWRMaXN0UHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gIHZhciBwcmV2ID0gZW50cnkucHJldjtcbiAgdmFyIG5leHQgPSBlbnRyeS5uZXh0O1xuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgfSBlbHNlIHtcbiAgICAvLyBJcyBoZWFkXG4gICAgdGhpcy5oZWFkID0gbmV4dDtcbiAgfVxuXG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5wcmV2ID0gcHJldjtcbiAgfSBlbHNlIHtcbiAgICAvLyBJcyB0YWlsXG4gICAgdGhpcy50YWlsID0gcHJldjtcbiAgfVxuXG4gIGVudHJ5Lm5leHQgPSBlbnRyeS5wcmV2ID0gbnVsbDtcbiAgdGhpcy5fbGVuLS07XG59O1xuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5saW5rZWRMaXN0UHJvdG8ubGVuID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fbGVuO1xufTtcbi8qKlxuICogQ2xlYXIgbGlzdFxuICovXG5cblxubGlua2VkTGlzdFByb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICB0aGlzLl9sZW4gPSAwO1xufTtcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge30gdmFsXG4gKi9cblxuXG52YXIgRW50cnkgPSBmdW5jdGlvbiAodmFsKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7fVxuICAgKi9cbiAgdGhpcy52YWx1ZSA9IHZhbDtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICovXG5cbiAgdGhpcy5uZXh0O1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgKi9cblxuICB0aGlzLnByZXY7XG59O1xuLyoqXG4gKiBMUlUgQ2FjaGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2NvcmUvTFJVXG4gKi9cblxuXG52YXIgTFJVID0gZnVuY3Rpb24gKG1heFNpemUpIHtcbiAgdGhpcy5fbGlzdCA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gIHRoaXMuX21hcCA9IHt9O1xuICB0aGlzLl9tYXhTaXplID0gbWF4U2l6ZSB8fCAxMDtcbiAgdGhpcy5fbGFzdFJlbW92ZWRFbnRyeSA9IG51bGw7XG59O1xuXG52YXIgTFJVUHJvdG8gPSBMUlUucHJvdG90eXBlO1xuLyoqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGtleVxuICogQHBhcmFtICB7fSB2YWx1ZVxuICogQHJldHVybiB7fSBSZW1vdmVkIHZhbHVlXG4gKi9cblxuTFJVUHJvdG8ucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdmFyIGxpc3QgPSB0aGlzLl9saXN0O1xuICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuICB2YXIgcmVtb3ZlZCA9IG51bGw7XG5cbiAgaWYgKG1hcFtrZXldID09IG51bGwpIHtcbiAgICB2YXIgbGVuID0gbGlzdC5sZW4oKTsgLy8gUmV1c2UgbGFzdCByZW1vdmVkIGVudHJ5XG5cbiAgICB2YXIgZW50cnkgPSB0aGlzLl9sYXN0UmVtb3ZlZEVudHJ5O1xuXG4gICAgaWYgKGxlbiA+PSB0aGlzLl9tYXhTaXplICYmIGxlbiA+IDApIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZFxuICAgICAgdmFyIGxlYXN0VXNlZEVudHJ5ID0gbGlzdC5oZWFkO1xuICAgICAgbGlzdC5yZW1vdmUobGVhc3RVc2VkRW50cnkpO1xuICAgICAgZGVsZXRlIG1hcFtsZWFzdFVzZWRFbnRyeS5rZXldO1xuICAgICAgcmVtb3ZlZCA9IGxlYXN0VXNlZEVudHJ5LnZhbHVlO1xuICAgICAgdGhpcy5fbGFzdFJlbW92ZWRFbnRyeSA9IGxlYXN0VXNlZEVudHJ5O1xuICAgIH1cblxuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkudmFsdWUgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50cnkgPSBuZXcgRW50cnkodmFsdWUpO1xuICAgIH1cblxuICAgIGVudHJ5LmtleSA9IGtleTtcbiAgICBsaXN0Lmluc2VydEVudHJ5KGVudHJ5KTtcbiAgICBtYXBba2V5XSA9IGVudHJ5O1xuICB9XG5cbiAgcmV0dXJuIHJlbW92ZWQ7XG59O1xuLyoqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGtleVxuICogQHJldHVybiB7fVxuICovXG5cblxuTFJVUHJvdG8uZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICB2YXIgZW50cnkgPSB0aGlzLl9tYXBba2V5XTtcbiAgdmFyIGxpc3QgPSB0aGlzLl9saXN0O1xuXG4gIGlmIChlbnRyeSAhPSBudWxsKSB7XG4gICAgLy8gUHV0IHRoZSBsYXRlc3QgdXNlZCBlbnRyeSBpbiB0aGUgdGFpbFxuICAgIGlmIChlbnRyeSAhPT0gbGlzdC50YWlsKSB7XG4gICAgICBsaXN0LnJlbW92ZShlbnRyeSk7XG4gICAgICBsaXN0Lmluc2VydEVudHJ5KGVudHJ5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gIH1cbn07XG4vKipcbiAqIENsZWFyIHRoZSBjYWNoZVxuICovXG5cblxuTFJVUHJvdG8uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2xpc3QuY2xlYXIoKTtcblxuICB0aGlzLl9tYXAgPSB7fTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IExSVTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvTFJVLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi9jb25maWdcIik7XG5cbnZhciBkZWJ1Z01vZGUgPSBfY29uZmlnLmRlYnVnTW9kZTtcblxudmFyIGxvZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG5pZiAoZGVidWdNb2RlID09PSAxKSB7XG4gIGxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBrIGluIGFyZ3VtZW50cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGFyZ3VtZW50c1trXSk7XG4gICAgfVxuICB9O1xufSBlbHNlIGlmIChkZWJ1Z01vZGUgPiAxKSB7XG4gIGxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBrIGluIGFyZ3VtZW50cykge1xuICAgICAgY29uc29sZS5sb2coYXJndW1lbnRzW2tdKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBfZGVmYXVsdCA9IGxvZztcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvbG9nLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZHByID0gMTsgLy8gSWYgaW4gYnJvd3NlciBlbnZpcm9ubWVudFxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZHByID0gTWF0aC5tYXgod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSwgMSk7XG59XG4vKipcbiAqIGNvbmZpZ+m7mOiupOmFjee9rumhuVxuICogQGV4cG9ydHMgenJlbmRlci9jb25maWdcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICogZGVidWfml6Xlv5fpgInpobnvvJpjYXRjaEJydXNoRXhjZXB0aW9u5Li6dHJ1ZeS4i+acieaViFxuICogMCA6IOS4jeeUn+aIkGRlYnVn5pWw5o2u77yM5Y+R5biD55SoXG4gKiAxIDog5byC5bi45oqb5Ye677yM6LCD6K+V55SoXG4gKiAyIDog5o6n5Yi25Y+w6L6T5Ye677yM6LCD6K+V55SoXG4gKi9cblxuXG52YXIgZGVidWdNb2RlID0gMDsgLy8gcmV0aW5hIOWxj+W5leS8mOWMllxuXG52YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IGRwcjtcbmV4cG9ydHMuZGVidWdNb2RlID0gZGVidWdNb2RlO1xuZXhwb3J0cy5kZXZpY2VQaXhlbFJhdGlvID0gZGV2aWNlUGl4ZWxSYXRpbztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29uZmlnLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdGV4dEhlbHBlciA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvdGV4dFwiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL0JvdW5kaW5nUmVjdFwiKTtcblxuLyoqXG4gKiBNaXhpbiBmb3IgZHJhd2luZyB0ZXh0IGluIGEgZWxlbWVudCBib3VuZGluZyByZWN0XG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vUmVjdFRleHRcbiAqL1xudmFyIHRtcFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KCk7XG5cbnZhciBSZWN0VGV4dCA9IGZ1bmN0aW9uICgpIHt9O1xuXG5SZWN0VGV4dC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBSZWN0VGV4dCxcblxuICAvKipcbiAgICogRHJhdyB0ZXh0IGluIGEgcmVjdCB3aXRoIHNwZWNpZmllZCBwb3NpdGlvbi5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtICB7T2JqZWN0fSByZWN0IERpc3BsYXlhYmxlIHJlY3RcbiAgICovXG4gIGRyYXdSZWN0VGV4dDogZnVuY3Rpb24gKGN0eCwgcmVjdCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgcmVjdCA9IHN0eWxlLnRleHRSZWN0IHx8IHJlY3Q7IC8vIE9wdGltaXplLCBhdm9pZCBub3JtYWxpemUgZXZlcnkgdGltZS5cblxuICAgIHRoaXMuX19kaXJ0eSAmJiB0ZXh0SGVscGVyLm5vcm1hbGl6ZVRleHRTdHlsZShzdHlsZSwgdHJ1ZSk7XG4gICAgdmFyIHRleHQgPSBzdHlsZS50ZXh0OyAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuXG4gICAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcblxuICAgIGlmICghdGV4dEhlbHBlci5uZWVkRHJhd1RleHQodGV4dCwgc3R5bGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGSVhNRVxuXG5cbiAgICBjdHguc2F2ZSgpOyAvLyBUcmFuc2Zvcm0gcmVjdCB0byB2aWV3IHNwYWNlXG5cbiAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgICBpZiAoIXN0eWxlLnRyYW5zZm9ybVRleHQpIHtcbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdG1wUmVjdC5jb3B5KHJlY3QpO1xuICAgICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgIHJlY3QgPSB0bXBSZWN0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuICAgIH0gLy8gdHJhbnNmb3JtVGV4dCBhbmQgdGV4dFJvdGF0aW9uIGNhbiBub3QgYmUgdXNlZCBhdCB0aGUgc2FtZSB0aW1lLlxuXG5cbiAgICB0ZXh0SGVscGVyLnJlbmRlclRleHQodGhpcywgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IFJlY3RUZXh0O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9taXhpbi9SZWN0VGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF91dGlsID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvdXRpbFwiKTtcblxudmFyIHJldHJpZXZlMiA9IF91dGlsLnJldHJpZXZlMjtcbnZhciByZXRyaWV2ZTMgPSBfdXRpbC5yZXRyaWV2ZTM7XG52YXIgZWFjaCA9IF91dGlsLmVhY2g7XG52YXIgbm9ybWFsaXplQ3NzQXJyYXkgPSBfdXRpbC5ub3JtYWxpemVDc3NBcnJheTtcbnZhciBpc1N0cmluZyA9IF91dGlsLmlzU3RyaW5nO1xudmFyIGlzT2JqZWN0ID0gX3V0aWwuaXNPYmplY3Q7XG5cbnZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoXCIuLi8uLi9jb250YWluL3RleHRcIik7XG5cbnZhciByb3VuZFJlY3RIZWxwZXIgPSByZXF1aXJlKFwiLi9yb3VuZFJlY3RcIik7XG5cbnZhciBpbWFnZUhlbHBlciA9IHJlcXVpcmUoXCIuL2ltYWdlXCIpO1xuXG4vLyBUT0RPOiBIYXZlIG5vdCBzdXBwb3J0ICdzdGFydCcsICdlbmQnIHlldC5cbnZhciBWQUxJRF9URVhUX0FMSUdOID0ge1xuICBsZWZ0OiAxLFxuICByaWdodDogMSxcbiAgY2VudGVyOiAxXG59O1xudmFyIFZBTElEX1RFWFRfVkVSVElDQUxfQUxJR04gPSB7XG4gIHRvcDogMSxcbiAgYm90dG9tOiAxLFxuICBtaWRkbGU6IDFcbn07XG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gc3R5bGVcbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IFRoZSBpbnB1dCBzdHlsZS5cbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVUZXh0U3R5bGUoc3R5bGUpIHtcbiAgbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xuICBlYWNoKHN0eWxlLnJpY2gsIG5vcm1hbGl6ZVN0eWxlKTtcbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZShzdHlsZSkge1xuICBpZiAoc3R5bGUpIHtcbiAgICBzdHlsZS5mb250ID0gdGV4dENvbnRhaW4ubWFrZUZvbnQoc3R5bGUpO1xuICAgIHZhciB0ZXh0QWxpZ24gPSBzdHlsZS50ZXh0QWxpZ247XG4gICAgdGV4dEFsaWduID09PSAnbWlkZGxlJyAmJiAodGV4dEFsaWduID0gJ2NlbnRlcicpO1xuICAgIHN0eWxlLnRleHRBbGlnbiA9IHRleHRBbGlnbiA9PSBudWxsIHx8IFZBTElEX1RFWFRfQUxJR05bdGV4dEFsaWduXSA/IHRleHRBbGlnbiA6ICdsZWZ0JzsgLy8gQ29tcGF0aWJsZSB3aXRoIHRleHRCYXNlbGluZS5cblxuICAgIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduIHx8IHN0eWxlLnRleHRCYXNlbGluZTtcbiAgICB0ZXh0VmVydGljYWxBbGlnbiA9PT0gJ2NlbnRlcicgJiYgKHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZScpO1xuICAgIHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduID0gdGV4dFZlcnRpY2FsQWxpZ24gPT0gbnVsbCB8fCBWQUxJRF9URVhUX1ZFUlRJQ0FMX0FMSUdOW3RleHRWZXJ0aWNhbEFsaWduXSA/IHRleHRWZXJ0aWNhbEFsaWduIDogJ3RvcCc7XG4gICAgdmFyIHRleHRQYWRkaW5nID0gc3R5bGUudGV4dFBhZGRpbmc7XG5cbiAgICBpZiAodGV4dFBhZGRpbmcpIHtcbiAgICAgIHN0eWxlLnRleHRQYWRkaW5nID0gbm9ybWFsaXplQ3NzQXJyYXkoc3R5bGUudGV4dFBhZGRpbmcpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfSBzdHlsZVxuICogQHBhcmFtIHtPYmplY3R8Ym9vbGVhbn0gW3JlY3RdIHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuICogICAgICAgICAgICAgICAgICBJZiBzZXQgZmFsc2UsIHJlY3QgdGV4dCBpcyBub3QgdXNlZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlbmRlclRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0KSB7XG4gIHN0eWxlLnJpY2ggPyByZW5kZXJSaWNoVGV4dChob3N0RWwsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QpIDogcmVuZGVyUGxhaW5UZXh0KGhvc3RFbCwgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclBsYWluVGV4dChob3N0RWwsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QpIHtcbiAgdmFyIGZvbnQgPSBzZXRDdHgoY3R4LCAnZm9udCcsIHN0eWxlLmZvbnQgfHwgdGV4dENvbnRhaW4uREVGQVVMVF9GT05UKTtcbiAgdmFyIHRleHRQYWRkaW5nID0gc3R5bGUudGV4dFBhZGRpbmc7XG4gIHZhciBjb250ZW50QmxvY2sgPSBob3N0RWwuX190ZXh0Q290ZW50QmxvY2s7XG5cbiAgaWYgKCFjb250ZW50QmxvY2sgfHwgaG9zdEVsLl9fZGlydHkpIHtcbiAgICBjb250ZW50QmxvY2sgPSBob3N0RWwuX190ZXh0Q290ZW50QmxvY2sgPSB0ZXh0Q29udGFpbi5wYXJzZVBsYWluVGV4dCh0ZXh0LCBmb250LCB0ZXh0UGFkZGluZywgc3R5bGUudHJ1bmNhdGUpO1xuICB9XG5cbiAgdmFyIG91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLm91dGVySGVpZ2h0O1xuICB2YXIgdGV4dExpbmVzID0gY29udGVudEJsb2NrLmxpbmVzO1xuICB2YXIgbGluZUhlaWdodCA9IGNvbnRlbnRCbG9jay5saW5lSGVpZ2h0O1xuICB2YXIgYm94UG9zID0gZ2V0Qm94UG9zaXRpb24ob3V0ZXJIZWlnaHQsIHN0eWxlLCByZWN0KTtcbiAgdmFyIGJhc2VYID0gYm94UG9zLmJhc2VYO1xuICB2YXIgYmFzZVkgPSBib3hQb3MuYmFzZVk7XG4gIHZhciB0ZXh0QWxpZ24gPSBib3hQb3MudGV4dEFsaWduO1xuICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSBib3hQb3MudGV4dFZlcnRpY2FsQWxpZ247IC8vIE9yaWdpbiBvZiB0ZXh0Um90YXRpb24gc2hvdWxkIGJlIHRoZSBiYXNlIHBvaW50IG9mIHRleHQgZHJhd2luZy5cblxuICBhcHBseVRleHRSb3RhdGlvbihjdHgsIHN0eWxlLCByZWN0LCBiYXNlWCwgYmFzZVkpO1xuICB2YXIgYm94WSA9IHRleHRDb250YWluLmFkanVzdFRleHRZKGJhc2VZLCBvdXRlckhlaWdodCwgdGV4dFZlcnRpY2FsQWxpZ24pO1xuICB2YXIgdGV4dFggPSBiYXNlWDtcbiAgdmFyIHRleHRZID0gYm94WTtcbiAgdmFyIG5lZWREcmF3QmcgPSBuZWVkRHJhd0JhY2tncm91bmQoc3R5bGUpO1xuXG4gIGlmIChuZWVkRHJhd0JnIHx8IHRleHRQYWRkaW5nKSB7XG4gICAgLy8gQ29uc2lkZXIgcGVyZm9ybWFuY2UsIGRvIG5vdCBjYWxsIGdldFRleHRXaWR0aCB1dGlsIG5lY2Vzc2FyeS5cbiAgICB2YXIgdGV4dFdpZHRoID0gdGV4dENvbnRhaW4uZ2V0V2lkdGgodGV4dCwgZm9udCk7XG4gICAgdmFyIG91dGVyV2lkdGggPSB0ZXh0V2lkdGg7XG4gICAgdGV4dFBhZGRpbmcgJiYgKG91dGVyV2lkdGggKz0gdGV4dFBhZGRpbmdbMV0gKyB0ZXh0UGFkZGluZ1szXSk7XG4gICAgdmFyIGJveFggPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0WChiYXNlWCwgb3V0ZXJXaWR0aCwgdGV4dEFsaWduKTtcbiAgICBuZWVkRHJhd0JnICYmIGRyYXdCYWNrZ3JvdW5kKGhvc3RFbCwgY3R4LCBzdHlsZSwgYm94WCwgYm94WSwgb3V0ZXJXaWR0aCwgb3V0ZXJIZWlnaHQpO1xuXG4gICAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgICB0ZXh0WCA9IGdldFRleHRYRm9yUGFkZGluZyhiYXNlWCwgdGV4dEFsaWduLCB0ZXh0UGFkZGluZyk7XG4gICAgICB0ZXh0WSArPSB0ZXh0UGFkZGluZ1swXTtcbiAgICB9XG4gIH1cblxuICBzZXRDdHgoY3R4LCAndGV4dEFsaWduJywgdGV4dEFsaWduIHx8ICdsZWZ0Jyk7IC8vIEZvcmNlIGJhc2VsaW5lIHRvIGJlIFwibWlkZGxlXCIuIE90aGVyd2lzZSwgaWYgdXNpbmcgXCJ0b3BcIiwgdGhlXG4gIC8vIHRleHQgd2lsbCBvZmZzZXQgZG93bndhcmQgYSBsaXR0bGUgYml0IGluIGZvbnQgXCJNaWNyb3NvZnQgWWFIZWlcIi5cblxuICBzZXRDdHgoY3R4LCAndGV4dEJhc2VsaW5lJywgJ21pZGRsZScpOyAvLyBBbHdheXMgc2V0IHNoYWRvd0JsdXIgYW5kIHNoYWRvd09mZnNldCB0byBhdm9pZCBsZWFrIGZyb20gZGlzcGxheWFibGUuXG5cbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0JsdXInLCBzdHlsZS50ZXh0U2hhZG93Qmx1ciB8fCAwKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0NvbG9yJywgc3R5bGUudGV4dFNoYWRvd0NvbG9yIHx8ICd0cmFuc3BhcmVudCcpO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WCcsIHN0eWxlLnRleHRTaGFkb3dPZmZzZXRYIHx8IDApO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WScsIHN0eWxlLnRleHRTaGFkb3dPZmZzZXRZIHx8IDApOyAvLyBgdGV4dEJhc2VsaW5lYCBpcyBzZXQgYXMgJ21pZGRsZScuXG5cbiAgdGV4dFkgKz0gbGluZUhlaWdodCAvIDI7XG4gIHZhciB0ZXh0U3Ryb2tlV2lkdGggPSBzdHlsZS50ZXh0U3Ryb2tlV2lkdGg7XG4gIHZhciB0ZXh0U3Ryb2tlID0gZ2V0U3Ryb2tlKHN0eWxlLnRleHRTdHJva2UsIHRleHRTdHJva2VXaWR0aCk7XG4gIHZhciB0ZXh0RmlsbCA9IGdldEZpbGwoc3R5bGUudGV4dEZpbGwpO1xuXG4gIGlmICh0ZXh0U3Ryb2tlKSB7XG4gICAgc2V0Q3R4KGN0eCwgJ2xpbmVXaWR0aCcsIHRleHRTdHJva2VXaWR0aCk7XG4gICAgc2V0Q3R4KGN0eCwgJ3N0cm9rZVN0eWxlJywgdGV4dFN0cm9rZSk7XG4gIH1cblxuICBpZiAodGV4dEZpbGwpIHtcbiAgICBzZXRDdHgoY3R4LCAnZmlsbFN0eWxlJywgdGV4dEZpbGwpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBGaWxsIGFmdGVyIHN0cm9rZSBzbyB0aGUgb3V0bGluZSB3aWxsIG5vdCBjb3ZlciB0aGUgbWFpbiBwYXJ0LlxuICAgIHRleHRTdHJva2UgJiYgY3R4LnN0cm9rZVRleHQodGV4dExpbmVzW2ldLCB0ZXh0WCwgdGV4dFkpO1xuICAgIHRleHRGaWxsICYmIGN0eC5maWxsVGV4dCh0ZXh0TGluZXNbaV0sIHRleHRYLCB0ZXh0WSk7XG4gICAgdGV4dFkgKz0gbGluZUhlaWdodDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJSaWNoVGV4dChob3N0RWwsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QpIHtcbiAgdmFyIGNvbnRlbnRCbG9jayA9IGhvc3RFbC5fX3RleHRDb3RlbnRCbG9jaztcblxuICBpZiAoIWNvbnRlbnRCbG9jayB8fCBob3N0RWwuX19kaXJ0eSkge1xuICAgIGNvbnRlbnRCbG9jayA9IGhvc3RFbC5fX3RleHRDb3RlbnRCbG9jayA9IHRleHRDb250YWluLnBhcnNlUmljaFRleHQodGV4dCwgc3R5bGUpO1xuICB9XG5cbiAgZHJhd1JpY2hUZXh0KGhvc3RFbCwgY3R4LCBjb250ZW50QmxvY2ssIHN0eWxlLCByZWN0KTtcbn1cblxuZnVuY3Rpb24gZHJhd1JpY2hUZXh0KGhvc3RFbCwgY3R4LCBjb250ZW50QmxvY2ssIHN0eWxlLCByZWN0KSB7XG4gIHZhciBjb250ZW50V2lkdGggPSBjb250ZW50QmxvY2sud2lkdGg7XG4gIHZhciBvdXRlcldpZHRoID0gY29udGVudEJsb2NrLm91dGVyV2lkdGg7XG4gIHZhciBvdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5vdXRlckhlaWdodDtcbiAgdmFyIHRleHRQYWRkaW5nID0gc3R5bGUudGV4dFBhZGRpbmc7XG4gIHZhciBib3hQb3MgPSBnZXRCb3hQb3NpdGlvbihvdXRlckhlaWdodCwgc3R5bGUsIHJlY3QpO1xuICB2YXIgYmFzZVggPSBib3hQb3MuYmFzZVg7XG4gIHZhciBiYXNlWSA9IGJveFBvcy5iYXNlWTtcbiAgdmFyIHRleHRBbGlnbiA9IGJveFBvcy50ZXh0QWxpZ247XG4gIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IGJveFBvcy50ZXh0VmVydGljYWxBbGlnbjsgLy8gT3JpZ2luIG9mIHRleHRSb3RhdGlvbiBzaG91bGQgYmUgdGhlIGJhc2UgcG9pbnQgb2YgdGV4dCBkcmF3aW5nLlxuXG4gIGFwcGx5VGV4dFJvdGF0aW9uKGN0eCwgc3R5bGUsIHJlY3QsIGJhc2VYLCBiYXNlWSk7XG4gIHZhciBib3hYID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFgoYmFzZVgsIG91dGVyV2lkdGgsIHRleHRBbGlnbik7XG4gIHZhciBib3hZID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFkoYmFzZVksIG91dGVySGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbik7XG4gIHZhciB4TGVmdCA9IGJveFg7XG4gIHZhciBsaW5lVG9wID0gYm94WTtcblxuICBpZiAodGV4dFBhZGRpbmcpIHtcbiAgICB4TGVmdCArPSB0ZXh0UGFkZGluZ1szXTtcbiAgICBsaW5lVG9wICs9IHRleHRQYWRkaW5nWzBdO1xuICB9XG5cbiAgdmFyIHhSaWdodCA9IHhMZWZ0ICsgY29udGVudFdpZHRoO1xuICBuZWVkRHJhd0JhY2tncm91bmQoc3R5bGUpICYmIGRyYXdCYWNrZ3JvdW5kKGhvc3RFbCwgY3R4LCBzdHlsZSwgYm94WCwgYm94WSwgb3V0ZXJXaWR0aCwgb3V0ZXJIZWlnaHQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudEJsb2NrLmxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxpbmUgPSBjb250ZW50QmxvY2subGluZXNbaV07XG4gICAgdmFyIHRva2VucyA9IGxpbmUudG9rZW5zO1xuICAgIHZhciB0b2tlbkNvdW50ID0gdG9rZW5zLmxlbmd0aDtcbiAgICB2YXIgbGluZUhlaWdodCA9IGxpbmUubGluZUhlaWdodDtcbiAgICB2YXIgdXNlZFdpZHRoID0gbGluZS53aWR0aDtcbiAgICB2YXIgbGVmdEluZGV4ID0gMDtcbiAgICB2YXIgbGluZVhMZWZ0ID0geExlZnQ7XG4gICAgdmFyIGxpbmVYUmlnaHQgPSB4UmlnaHQ7XG4gICAgdmFyIHJpZ2h0SW5kZXggPSB0b2tlbkNvdW50IC0gMTtcbiAgICB2YXIgdG9rZW47XG5cbiAgICB3aGlsZSAobGVmdEluZGV4IDwgdG9rZW5Db3VudCAmJiAodG9rZW4gPSB0b2tlbnNbbGVmdEluZGV4XSwgIXRva2VuLnRleHRBbGlnbiB8fCB0b2tlbi50ZXh0QWxpZ24gPT09ICdsZWZ0JykpIHtcbiAgICAgIHBsYWNlVG9rZW4oaG9zdEVsLCBjdHgsIHRva2VuLCBzdHlsZSwgbGluZUhlaWdodCwgbGluZVRvcCwgbGluZVhMZWZ0LCAnbGVmdCcpO1xuICAgICAgdXNlZFdpZHRoIC09IHRva2VuLndpZHRoO1xuICAgICAgbGluZVhMZWZ0ICs9IHRva2VuLndpZHRoO1xuICAgICAgbGVmdEluZGV4Kys7XG4gICAgfVxuXG4gICAgd2hpbGUgKHJpZ2h0SW5kZXggPj0gMCAmJiAodG9rZW4gPSB0b2tlbnNbcmlnaHRJbmRleF0sIHRva2VuLnRleHRBbGlnbiA9PT0gJ3JpZ2h0JykpIHtcbiAgICAgIHBsYWNlVG9rZW4oaG9zdEVsLCBjdHgsIHRva2VuLCBzdHlsZSwgbGluZUhlaWdodCwgbGluZVRvcCwgbGluZVhSaWdodCwgJ3JpZ2h0Jyk7XG4gICAgICB1c2VkV2lkdGggLT0gdG9rZW4ud2lkdGg7XG4gICAgICBsaW5lWFJpZ2h0IC09IHRva2VuLndpZHRoO1xuICAgICAgcmlnaHRJbmRleC0tO1xuICAgIH0gLy8gVGhlIG90aGVyIHRva2VucyBhcmUgcGxhY2VkIGFzIHRleHRBbGlnbiAnY2VudGVyJyBpZiB0aGVyZSBpcyBlbm91Z2ggc3BhY2UuXG5cblxuICAgIGxpbmVYTGVmdCArPSAoY29udGVudFdpZHRoIC0gKGxpbmVYTGVmdCAtIHhMZWZ0KSAtICh4UmlnaHQgLSBsaW5lWFJpZ2h0KSAtIHVzZWRXaWR0aCkgLyAyO1xuXG4gICAgd2hpbGUgKGxlZnRJbmRleCA8PSByaWdodEluZGV4KSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tsZWZ0SW5kZXhdOyAvLyBDb25zaWRlciB3aWR0aCBzcGVjaWZpZWQgYnkgdXNlciwgdXNlICdjZW50ZXInIHJhdGhlciB0aGFuICdsZWZ0Jy5cblxuICAgICAgcGxhY2VUb2tlbihob3N0RWwsIGN0eCwgdG9rZW4sIHN0eWxlLCBsaW5lSGVpZ2h0LCBsaW5lVG9wLCBsaW5lWExlZnQgKyB0b2tlbi53aWR0aCAvIDIsICdjZW50ZXInKTtcbiAgICAgIGxpbmVYTGVmdCArPSB0b2tlbi53aWR0aDtcbiAgICAgIGxlZnRJbmRleCsrO1xuICAgIH1cblxuICAgIGxpbmVUb3AgKz0gbGluZUhlaWdodDtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRleHRSb3RhdGlvbihjdHgsIHN0eWxlLCByZWN0LCB4LCB5KSB7XG4gIC8vIHRleHRSb3RhdGlvbiBvbmx5IGFwcGx5IGluIFJlY3RUZXh0LlxuICBpZiAocmVjdCAmJiBzdHlsZS50ZXh0Um90YXRpb24pIHtcbiAgICB2YXIgb3JpZ2luID0gc3R5bGUudGV4dE9yaWdpbjtcblxuICAgIGlmIChvcmlnaW4gPT09ICdjZW50ZXInKSB7XG4gICAgICB4ID0gcmVjdC53aWR0aCAvIDIgKyByZWN0Lng7XG4gICAgICB5ID0gcmVjdC5oZWlnaHQgLyAyICsgcmVjdC55O1xuICAgIH0gZWxzZSBpZiAob3JpZ2luKSB7XG4gICAgICB4ID0gb3JpZ2luWzBdICsgcmVjdC54O1xuICAgICAgeSA9IG9yaWdpblsxXSArIHJlY3QueTtcbiAgICB9XG5cbiAgICBjdHgudHJhbnNsYXRlKHgsIHkpOyAvLyBQb3NpdGl2ZTogYW50aWNsb2Nrd2lzZVxuXG4gICAgY3R4LnJvdGF0ZSgtc3R5bGUudGV4dFJvdGF0aW9uKTtcbiAgICBjdHgudHJhbnNsYXRlKC14LCAteSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGxhY2VUb2tlbihob3N0RWwsIGN0eCwgdG9rZW4sIHN0eWxlLCBsaW5lSGVpZ2h0LCBsaW5lVG9wLCB4LCB0ZXh0QWxpZ24pIHtcbiAgdmFyIHRva2VuU3R5bGUgPSBzdHlsZS5yaWNoW3Rva2VuLnN0eWxlTmFtZV0gfHwge307IC8vICdjdHgudGV4dEJhc2VsaW5lJyBpcyBhbHdheXMgc2V0IGFzICdtaWRkbGUnLCBmb3Igc2FrZSBvZlxuICAvLyB0aGUgYmlhcyBvZiBcIk1pY3Jvc29mdCBZYUhlaVwiLlxuXG4gIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IHRva2VuLnRleHRWZXJ0aWNhbEFsaWduO1xuICB2YXIgeSA9IGxpbmVUb3AgKyBsaW5lSGVpZ2h0IC8gMjtcblxuICBpZiAodGV4dFZlcnRpY2FsQWxpZ24gPT09ICd0b3AnKSB7XG4gICAgeSA9IGxpbmVUb3AgKyB0b2tlbi5oZWlnaHQgLyAyO1xuICB9IGVsc2UgaWYgKHRleHRWZXJ0aWNhbEFsaWduID09PSAnYm90dG9tJykge1xuICAgIHkgPSBsaW5lVG9wICsgbGluZUhlaWdodCAtIHRva2VuLmhlaWdodCAvIDI7XG4gIH1cblxuICAhdG9rZW4uaXNMaW5lSG9sZGVyICYmIG5lZWREcmF3QmFja2dyb3VuZCh0b2tlblN0eWxlKSAmJiBkcmF3QmFja2dyb3VuZChob3N0RWwsIGN0eCwgdG9rZW5TdHlsZSwgdGV4dEFsaWduID09PSAncmlnaHQnID8geCAtIHRva2VuLndpZHRoIDogdGV4dEFsaWduID09PSAnY2VudGVyJyA/IHggLSB0b2tlbi53aWR0aCAvIDIgOiB4LCB5IC0gdG9rZW4uaGVpZ2h0IC8gMiwgdG9rZW4ud2lkdGgsIHRva2VuLmhlaWdodCk7XG4gIHZhciB0ZXh0UGFkZGluZyA9IHRva2VuLnRleHRQYWRkaW5nO1xuXG4gIGlmICh0ZXh0UGFkZGluZykge1xuICAgIHggPSBnZXRUZXh0WEZvclBhZGRpbmcoeCwgdGV4dEFsaWduLCB0ZXh0UGFkZGluZyk7XG4gICAgeSAtPSB0b2tlbi5oZWlnaHQgLyAyIC0gdGV4dFBhZGRpbmdbMl0gLSB0b2tlbi50ZXh0SGVpZ2h0IC8gMjtcbiAgfVxuXG4gIHNldEN0eChjdHgsICdzaGFkb3dCbHVyJywgcmV0cmlldmUzKHRva2VuU3R5bGUudGV4dFNoYWRvd0JsdXIsIHN0eWxlLnRleHRTaGFkb3dCbHVyLCAwKSk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dDb2xvcicsIHRva2VuU3R5bGUudGV4dFNoYWRvd0NvbG9yIHx8IHN0eWxlLnRleHRTaGFkb3dDb2xvciB8fCAndHJhbnNwYXJlbnQnKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFgnLCByZXRyaWV2ZTModG9rZW5TdHlsZS50ZXh0U2hhZG93T2Zmc2V0WCwgc3R5bGUudGV4dFNoYWRvd09mZnNldFgsIDApKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFknLCByZXRyaWV2ZTModG9rZW5TdHlsZS50ZXh0U2hhZG93T2Zmc2V0WSwgc3R5bGUudGV4dFNoYWRvd09mZnNldFksIDApKTtcbiAgc2V0Q3R4KGN0eCwgJ3RleHRBbGlnbicsIHRleHRBbGlnbik7IC8vIEZvcmNlIGJhc2VsaW5lIHRvIGJlIFwibWlkZGxlXCIuIE90aGVyd2lzZSwgaWYgdXNpbmcgXCJ0b3BcIiwgdGhlXG4gIC8vIHRleHQgd2lsbCBvZmZzZXQgZG93bndhcmQgYSBsaXR0bGUgYml0IGluIGZvbnQgXCJNaWNyb3NvZnQgWWFIZWlcIi5cblxuICBzZXRDdHgoY3R4LCAndGV4dEJhc2VsaW5lJywgJ21pZGRsZScpO1xuICBzZXRDdHgoY3R4LCAnZm9udCcsIHRva2VuLmZvbnQgfHwgdGV4dENvbnRhaW4uREVGQVVMVF9GT05UKTtcbiAgdmFyIHRleHRTdHJva2UgPSBnZXRTdHJva2UodG9rZW5TdHlsZS50ZXh0U3Ryb2tlIHx8IHN0eWxlLnRleHRTdHJva2UsIHRleHRTdHJva2VXaWR0aCk7XG4gIHZhciB0ZXh0RmlsbCA9IGdldEZpbGwodG9rZW5TdHlsZS50ZXh0RmlsbCB8fCBzdHlsZS50ZXh0RmlsbCk7XG4gIHZhciB0ZXh0U3Ryb2tlV2lkdGggPSByZXRyaWV2ZTIodG9rZW5TdHlsZS50ZXh0U3Ryb2tlV2lkdGgsIHN0eWxlLnRleHRTdHJva2VXaWR0aCk7IC8vIEZpbGwgYWZ0ZXIgc3Ryb2tlIHNvIHRoZSBvdXRsaW5lIHdpbGwgbm90IGNvdmVyIHRoZSBtYWluIHBhcnQuXG5cbiAgaWYgKHRleHRTdHJva2UpIHtcbiAgICBzZXRDdHgoY3R4LCAnbGluZVdpZHRoJywgdGV4dFN0cm9rZVdpZHRoKTtcbiAgICBzZXRDdHgoY3R4LCAnc3Ryb2tlU3R5bGUnLCB0ZXh0U3Ryb2tlKTtcbiAgICBjdHguc3Ryb2tlVGV4dCh0b2tlbi50ZXh0LCB4LCB5KTtcbiAgfVxuXG4gIGlmICh0ZXh0RmlsbCkge1xuICAgIHNldEN0eChjdHgsICdmaWxsU3R5bGUnLCB0ZXh0RmlsbCk7XG4gICAgY3R4LmZpbGxUZXh0KHRva2VuLnRleHQsIHgsIHkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5lZWREcmF3QmFja2dyb3VuZChzdHlsZSkge1xuICByZXR1cm4gc3R5bGUudGV4dEJhY2tncm91bmRDb2xvciB8fCBzdHlsZS50ZXh0Qm9yZGVyV2lkdGggJiYgc3R5bGUudGV4dEJvcmRlckNvbG9yO1xufSAvLyBzdHlsZToge3RleHRCYWNrZ3JvdW5kQ29sb3IsIHRleHRCb3JkZXJXaWR0aCwgdGV4dEJvcmRlckNvbG9yLCB0ZXh0Qm9yZGVyUmFkaXVzfVxuLy8gc2hhcGU6IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuXG5cbmZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kKGhvc3RFbCwgY3R4LCBzdHlsZSwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgdGV4dEJhY2tncm91bmRDb2xvciA9IHN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3I7XG4gIHZhciB0ZXh0Qm9yZGVyV2lkdGggPSBzdHlsZS50ZXh0Qm9yZGVyV2lkdGg7XG4gIHZhciB0ZXh0Qm9yZGVyQ29sb3IgPSBzdHlsZS50ZXh0Qm9yZGVyQ29sb3I7XG4gIHZhciBpc1BsYWluQmcgPSBpc1N0cmluZyh0ZXh0QmFja2dyb3VuZENvbG9yKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0JsdXInLCBzdHlsZS50ZXh0Qm94U2hhZG93Qmx1ciB8fCAwKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0NvbG9yJywgc3R5bGUudGV4dEJveFNoYWRvd0NvbG9yIHx8ICd0cmFuc3BhcmVudCcpO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WCcsIHN0eWxlLnRleHRCb3hTaGFkb3dPZmZzZXRYIHx8IDApO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WScsIHN0eWxlLnRleHRCb3hTaGFkb3dPZmZzZXRZIHx8IDApO1xuXG4gIGlmIChpc1BsYWluQmcgfHwgdGV4dEJvcmRlcldpZHRoICYmIHRleHRCb3JkZXJDb2xvcikge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICB2YXIgdGV4dEJvcmRlclJhZGl1cyA9IHN0eWxlLnRleHRCb3JkZXJSYWRpdXM7XG5cbiAgICBpZiAoIXRleHRCb3JkZXJSYWRpdXMpIHtcbiAgICAgIGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb3VuZFJlY3RIZWxwZXIuYnVpbGRQYXRoKGN0eCwge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICByOiB0ZXh0Qm9yZGVyUmFkaXVzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gIH1cblxuICBpZiAoaXNQbGFpbkJnKSB7XG4gICAgc2V0Q3R4KGN0eCwgJ2ZpbGxTdHlsZScsIHRleHRCYWNrZ3JvdW5kQ29sb3IpO1xuICAgIGN0eC5maWxsKCk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodGV4dEJhY2tncm91bmRDb2xvcikpIHtcbiAgICB2YXIgaW1hZ2UgPSB0ZXh0QmFja2dyb3VuZENvbG9yLmltYWdlO1xuICAgIGltYWdlID0gaW1hZ2VIZWxwZXIuY3JlYXRlT3JVcGRhdGVJbWFnZShpbWFnZSwgbnVsbCwgaG9zdEVsLCBvbkJnSW1hZ2VMb2FkZWQsIHRleHRCYWNrZ3JvdW5kQ29sb3IpO1xuXG4gICAgaWYgKGltYWdlICYmIGltYWdlSGVscGVyLmlzSW1hZ2VSZWFkeShpbWFnZSkpIHtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0ZXh0Qm9yZGVyV2lkdGggJiYgdGV4dEJvcmRlckNvbG9yKSB7XG4gICAgc2V0Q3R4KGN0eCwgJ2xpbmVXaWR0aCcsIHRleHRCb3JkZXJXaWR0aCk7XG4gICAgc2V0Q3R4KGN0eCwgJ3N0cm9rZVN0eWxlJywgdGV4dEJvcmRlckNvbG9yKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25CZ0ltYWdlTG9hZGVkKGltYWdlLCB0ZXh0QmFja2dyb3VuZENvbG9yKSB7XG4gIC8vIFJlcGxhY2UgaW1hZ2UsIHNvIHRoYXQgYGNvbnRhaW4vdGV4dC5qcyNwYXJzZVJpY2hUZXh0YFxuICAvLyB3aWxsIGdldCBjb3JyZWN0IHJlc3VsdCBpbiBuZXh0IHRpY2suXG4gIHRleHRCYWNrZ3JvdW5kQ29sb3IuaW1hZ2UgPSBpbWFnZTtcbn1cblxuZnVuY3Rpb24gZ2V0Qm94UG9zaXRpb24oYmxvY2tIZWlodCwgc3R5bGUsIHJlY3QpIHtcbiAgdmFyIGJhc2VYID0gc3R5bGUueCB8fCAwO1xuICB2YXIgYmFzZVkgPSBzdHlsZS55IHx8IDA7XG4gIHZhciB0ZXh0QWxpZ24gPSBzdHlsZS50ZXh0QWxpZ247XG4gIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduOyAvLyBUZXh0IHBvc2l0aW9uIHJlcHJlc2VudGVkIGJ5IGNvb3JkXG5cbiAgaWYgKHJlY3QpIHtcbiAgICB2YXIgdGV4dFBvc2l0aW9uID0gc3R5bGUudGV4dFBvc2l0aW9uO1xuXG4gICAgaWYgKHRleHRQb3NpdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAvLyBQZXJjZW50XG4gICAgICBiYXNlWCA9IHJlY3QueCArIHBhcnNlUGVyY2VudCh0ZXh0UG9zaXRpb25bMF0sIHJlY3Qud2lkdGgpO1xuICAgICAgYmFzZVkgPSByZWN0LnkgKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzFdLCByZWN0LmhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXMgPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0UG9zaXRpb25PblJlY3QodGV4dFBvc2l0aW9uLCByZWN0LCBzdHlsZS50ZXh0RGlzdGFuY2UpO1xuICAgICAgYmFzZVggPSByZXMueDtcbiAgICAgIGJhc2VZID0gcmVzLnk7IC8vIERlZmF1bHQgYWxpZ24gYW5kIGJhc2VsaW5lIHdoZW4gaGFzIHRleHRQb3NpdGlvblxuXG4gICAgICB0ZXh0QWxpZ24gPSB0ZXh0QWxpZ24gfHwgcmVzLnRleHRBbGlnbjtcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gdGV4dFZlcnRpY2FsQWxpZ24gfHwgcmVzLnRleHRWZXJ0aWNhbEFsaWduO1xuICAgIH0gLy8gdGV4dE9mZnNldCBpcyBvbmx5IHN1cHBvcnQgaW4gUmVjdFRleHQsIG90aGVyd2lzZVxuICAgIC8vIHdlIGhhdmUgdG8gYWRqdXN0IGJvdW5kaW5nUmVjdCBmb3IgdGV4dE9mZnNldC5cblxuXG4gICAgdmFyIHRleHRPZmZzZXQgPSBzdHlsZS50ZXh0T2Zmc2V0O1xuXG4gICAgaWYgKHRleHRPZmZzZXQpIHtcbiAgICAgIGJhc2VYICs9IHRleHRPZmZzZXRbMF07XG4gICAgICBiYXNlWSArPSB0ZXh0T2Zmc2V0WzFdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmFzZVg6IGJhc2VYLFxuICAgIGJhc2VZOiBiYXNlWSxcbiAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICB0ZXh0VmVydGljYWxBbGlnbjogdGV4dFZlcnRpY2FsQWxpZ25cbiAgfTtcbn1cblxuZnVuY3Rpb24gc2V0Q3R4KGN0eCwgcHJvcCwgdmFsdWUpIHtcbiAgLy8gRklYTUUgPz8/IHBlcmZvcm1hbmNlIHRyeVxuICAvLyBpZiAoY3R4Ll9fY3VycmVudFZhbHVlc1twcm9wXSAhPT0gdmFsdWUpIHtcbiAgLy8gY3R4W3Byb3BdID0gY3R4Ll9fY3VycmVudFZhbHVlc1twcm9wXSA9IHZhbHVlO1xuICBjdHhbcHJvcF0gPSB2YWx1ZTsgLy8gfVxuXG4gIHJldHVybiBjdHhbcHJvcF07XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3Ryb2tlXSBJZiBzcGVjaWZpZWQsIGRvIG5vdCBjaGVjayBzdHlsZS50ZXh0U3Ryb2tlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtsaW5lV2lkdGhdIElmIHNwZWNpZmllZCwgZG8gbm90IGNoZWNrIHN0eWxlLnRleHRTdHJva2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3R5bGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFN0cm9rZShzdHJva2UsIGxpbmVXaWR0aCkge1xuICByZXR1cm4gc3Ryb2tlID09IG51bGwgfHwgbGluZVdpZHRoIDw9IDAgfHwgc3Ryb2tlID09PSAndHJhbnNwYXJlbnQnIHx8IHN0cm9rZSA9PT0gJ25vbmUnID8gbnVsbCAvLyBUT0RPIHBhdHRlcm4gYW5kIGdyYWRpZW50P1xuICA6IHN0cm9rZS5pbWFnZSB8fCBzdHJva2UuY29sb3JTdG9wcyA/ICcjMDAwJyA6IHN0cm9rZTtcbn1cblxuZnVuY3Rpb24gZ2V0RmlsbChmaWxsKSB7XG4gIHJldHVybiBmaWxsID09IG51bGwgfHwgZmlsbCA9PT0gJ25vbmUnID8gbnVsbCAvLyBUT0RPIHBhdHRlcm4gYW5kIGdyYWRpZW50P1xuICA6IGZpbGwuaW1hZ2UgfHwgZmlsbC5jb2xvclN0b3BzID8gJyMwMDAnIDogZmlsbDtcbn1cblxuZnVuY3Rpb24gcGFyc2VQZXJjZW50KHZhbHVlLCBtYXhWYWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGlmICh2YWx1ZS5sYXN0SW5kZXhPZignJScpID49IDApIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIG1heFZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dFhGb3JQYWRkaW5nKHgsIHRleHRBbGlnbiwgdGV4dFBhZGRpbmcpIHtcbiAgcmV0dXJuIHRleHRBbGlnbiA9PT0gJ3JpZ2h0JyA/IHggLSB0ZXh0UGFkZGluZ1sxXSA6IHRleHRBbGlnbiA9PT0gJ2NlbnRlcicgPyB4ICsgdGV4dFBhZGRpbmdbM10gLyAyIC0gdGV4dFBhZGRpbmdbMV0gLyAyIDogeCArIHRleHRQYWRkaW5nWzNdO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9TdHlsZX0gc3R5bGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBuZWVkRHJhd1RleHQodGV4dCwgc3R5bGUpIHtcbiAgcmV0dXJuIHRleHQgIT0gbnVsbCAmJiAodGV4dCB8fCBzdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yIHx8IHN0eWxlLnRleHRCb3JkZXJXaWR0aCAmJiBzdHlsZS50ZXh0Qm9yZGVyQ29sb3IgfHwgc3R5bGUudGV4dFBhZGRpbmcpO1xufVxuXG5leHBvcnRzLm5vcm1hbGl6ZVRleHRTdHlsZSA9IG5vcm1hbGl6ZVRleHRTdHlsZTtcbmV4cG9ydHMucmVuZGVyVGV4dCA9IHJlbmRlclRleHQ7XG5leHBvcnRzLmdldFN0cm9rZSA9IGdldFN0cm9rZTtcbmV4cG9ydHMuZ2V0RmlsbCA9IGdldEZpbGw7XG5leHBvcnRzLm5lZWREcmF3VGV4dCA9IG5lZWREcmF3VGV4dDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvdGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuLi9jb3JlL0JvdW5kaW5nUmVjdFwiKTtcblxudmFyIGltYWdlSGVscGVyID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvaGVscGVyL2ltYWdlXCIpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgZ2V0Q29udGV4dCA9IF91dGlsLmdldENvbnRleHQ7XG52YXIgZXh0ZW5kID0gX3V0aWwuZXh0ZW5kO1xudmFyIHJldHJpZXZlMiA9IF91dGlsLnJldHJpZXZlMjtcbnZhciByZXRyaWV2ZTMgPSBfdXRpbC5yZXRyaWV2ZTM7XG52YXIgdGV4dFdpZHRoQ2FjaGUgPSB7fTtcbnZhciB0ZXh0V2lkdGhDYWNoZUNvdW50ZXIgPSAwO1xudmFyIFRFWFRfQ0FDSEVfTUFYID0gNTAwMDtcbnZhciBTVFlMRV9SRUcgPSAvXFx7KFthLXpBLVowLTlfXSspXFx8KFtefV0qKVxcfS9nO1xudmFyIERFRkFVTFRfRk9OVCA9ICcxMnB4IHNhbnMtc2VyaWYnOyAvLyBBdm9pZCBhc3NpZ24gdG8gYW4gZXhwb3J0ZWQgdmFyaWFibGUsIGZvciB0cmFuc2Zvcm1pbmcgdG8gY2pzLlxuXG52YXIgbWV0aG9kcyA9IHt9O1xuXG5mdW5jdGlvbiAkb3ZlcnJpZGUobmFtZSwgZm4pIHtcbiAgbWV0aG9kc1tuYW1lXSA9IGZuO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnRcbiAqIEByZXR1cm4ge251bWJlcn0gd2lkdGhcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFdpZHRoKHRleHQsIGZvbnQpIHtcbiAgZm9udCA9IGZvbnQgfHwgREVGQVVMVF9GT05UO1xuICB2YXIga2V5ID0gdGV4dCArICc6JyArIGZvbnQ7XG5cbiAgaWYgKHRleHRXaWR0aENhY2hlW2tleV0pIHtcbiAgICByZXR1cm4gdGV4dFdpZHRoQ2FjaGVba2V5XTtcbiAgfVxuXG4gIHZhciB0ZXh0TGluZXMgPSAodGV4dCArICcnKS5zcGxpdCgnXFxuJyk7XG4gIHZhciB3aWR0aCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0ZXh0TGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgLy8gdGV4dENvbnRhaW4ubWVhc3VyZVRleHQgbWF5IGJlIG92ZXJyaWRlZCBpbiBTVkcgb3IgVk1MXG4gICAgd2lkdGggPSBNYXRoLm1heChtZWFzdXJlVGV4dCh0ZXh0TGluZXNbaV0sIGZvbnQpLndpZHRoLCB3aWR0aCk7XG4gIH1cblxuICBpZiAodGV4dFdpZHRoQ2FjaGVDb3VudGVyID4gVEVYVF9DQUNIRV9NQVgpIHtcbiAgICB0ZXh0V2lkdGhDYWNoZUNvdW50ZXIgPSAwO1xuICAgIHRleHRXaWR0aENhY2hlID0ge307XG4gIH1cblxuICB0ZXh0V2lkdGhDYWNoZUNvdW50ZXIrKztcbiAgdGV4dFdpZHRoQ2FjaGVba2V5XSA9IHdpZHRoO1xuICByZXR1cm4gd2lkdGg7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0QWxpZ249J2xlZnQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0VmVydGljYWxBbGlnbj0ndG9wJ11cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFt0ZXh0UGFkZGluZ11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmljaF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbdHJ1bmNhdGVdXG4gKiBAcmV0dXJuIHtPYmplY3R9IHt4LCB5LCB3aWR0aCwgaGVpZ2h0LCBsaW5lSGVpZ2h0fVxuICovXG5cblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdSZWN0KHRleHQsIGZvbnQsIHRleHRBbGlnbiwgdGV4dFZlcnRpY2FsQWxpZ24sIHRleHRQYWRkaW5nLCByaWNoLCB0cnVuY2F0ZSkge1xuICByZXR1cm4gcmljaCA/IGdldFJpY2hUZXh0UmVjdCh0ZXh0LCBmb250LCB0ZXh0QWxpZ24sIHRleHRWZXJ0aWNhbEFsaWduLCB0ZXh0UGFkZGluZywgcmljaCwgdHJ1bmNhdGUpIDogZ2V0UGxhaW5UZXh0UmVjdCh0ZXh0LCBmb250LCB0ZXh0QWxpZ24sIHRleHRWZXJ0aWNhbEFsaWduLCB0ZXh0UGFkZGluZywgdHJ1bmNhdGUpO1xufVxuXG5mdW5jdGlvbiBnZXRQbGFpblRleHRSZWN0KHRleHQsIGZvbnQsIHRleHRBbGlnbiwgdGV4dFZlcnRpY2FsQWxpZ24sIHRleHRQYWRkaW5nLCB0cnVuY2F0ZSkge1xuICB2YXIgY29udGVudEJsb2NrID0gcGFyc2VQbGFpblRleHQodGV4dCwgZm9udCwgdGV4dFBhZGRpbmcsIHRydW5jYXRlKTtcbiAgdmFyIG91dGVyV2lkdGggPSBnZXRXaWR0aCh0ZXh0LCBmb250KTtcblxuICBpZiAodGV4dFBhZGRpbmcpIHtcbiAgICBvdXRlcldpZHRoICs9IHRleHRQYWRkaW5nWzFdICsgdGV4dFBhZGRpbmdbM107XG4gIH1cblxuICB2YXIgb3V0ZXJIZWlnaHQgPSBjb250ZW50QmxvY2sub3V0ZXJIZWlnaHQ7XG4gIHZhciB4ID0gYWRqdXN0VGV4dFgoMCwgb3V0ZXJXaWR0aCwgdGV4dEFsaWduKTtcbiAgdmFyIHkgPSBhZGp1c3RUZXh0WSgwLCBvdXRlckhlaWdodCwgdGV4dFZlcnRpY2FsQWxpZ24pO1xuICB2YXIgcmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoeCwgeSwgb3V0ZXJXaWR0aCwgb3V0ZXJIZWlnaHQpO1xuICByZWN0LmxpbmVIZWlnaHQgPSBjb250ZW50QmxvY2subGluZUhlaWdodDtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldFJpY2hUZXh0UmVjdCh0ZXh0LCBmb250LCB0ZXh0QWxpZ24sIHRleHRWZXJ0aWNhbEFsaWduLCB0ZXh0UGFkZGluZywgcmljaCwgdHJ1bmNhdGUpIHtcbiAgdmFyIGNvbnRlbnRCbG9jayA9IHBhcnNlUmljaFRleHQodGV4dCwge1xuICAgIHJpY2g6IHJpY2gsXG4gICAgdHJ1bmNhdGU6IHRydW5jYXRlLFxuICAgIGZvbnQ6IGZvbnQsXG4gICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgdGV4dFBhZGRpbmc6IHRleHRQYWRkaW5nXG4gIH0pO1xuICB2YXIgb3V0ZXJXaWR0aCA9IGNvbnRlbnRCbG9jay5vdXRlcldpZHRoO1xuICB2YXIgb3V0ZXJIZWlnaHQgPSBjb250ZW50QmxvY2sub3V0ZXJIZWlnaHQ7XG4gIHZhciB4ID0gYWRqdXN0VGV4dFgoMCwgb3V0ZXJXaWR0aCwgdGV4dEFsaWduKTtcbiAgdmFyIHkgPSBhZGp1c3RUZXh0WSgwLCBvdXRlckhlaWdodCwgdGV4dFZlcnRpY2FsQWxpZ24pO1xuICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdCh4LCB5LCBvdXRlcldpZHRoLCBvdXRlckhlaWdodCk7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdGV4dEFsaWduPSdsZWZ0J11cbiAqIEByZXR1cm4ge251bWJlcn0gQWRqdXN0ZWQgeC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGFkanVzdFRleHRYKHgsIHdpZHRoLCB0ZXh0QWxpZ24pIHtcbiAgLy8gRklYTUUgUmlnaHQgdG8gbGVmdCBsYW5ndWFnZVxuICBpZiAodGV4dEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3aWR0aDtcbiAgfSBlbHNlIGlmICh0ZXh0QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeCAtPSB3aWR0aCAvIDI7XG4gIH1cblxuICByZXR1cm4geDtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdGV4dFZlcnRpY2FsQWxpZ249J3RvcCddXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFkanVzdGVkIHkuXG4gKi9cblxuXG5mdW5jdGlvbiBhZGp1c3RUZXh0WSh5LCBoZWlnaHQsIHRleHRWZXJ0aWNhbEFsaWduKSB7XG4gIGlmICh0ZXh0VmVydGljYWxBbGlnbiA9PT0gJ21pZGRsZScpIHtcbiAgICB5IC09IGhlaWdodCAvIDI7XG4gIH0gZWxzZSBpZiAodGV4dFZlcnRpY2FsQWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgeSAtPSBoZWlnaHQ7XG4gIH1cblxuICByZXR1cm4geTtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdGlybmd9IHRleHRQb3NpdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHJlY3Qge3gsIHksIHdpZHRoLCBoZWlnaHR9XG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2VcbiAqIEByZXR1cm4ge09iamVjdH0ge3gsIHksIHRleHRBbGlnbiwgdGV4dFZlcnRpY2FsQWxpZ259XG4gKi9cblxuXG5mdW5jdGlvbiBhZGp1c3RUZXh0UG9zaXRpb25PblJlY3QodGV4dFBvc2l0aW9uLCByZWN0LCBkaXN0YW5jZSkge1xuICB2YXIgeCA9IHJlY3QueDtcbiAgdmFyIHkgPSByZWN0Lnk7XG4gIHZhciBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgdmFyIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICB2YXIgdGV4dEFsaWduID0gJ2xlZnQnO1xuICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSAndG9wJztcblxuICBzd2l0Y2ggKHRleHRQb3NpdGlvbikge1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgeCAtPSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdyaWdodCc6XG4gICAgICB4ICs9IGRpc3RhbmNlICsgd2lkdGg7XG4gICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0b3AnOlxuICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICB5IC09IGRpc3RhbmNlO1xuICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICB5ICs9IGhlaWdodCArIGRpc3RhbmNlO1xuICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZSc6XG4gICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlTGVmdCc6XG4gICAgICB4ICs9IGRpc3RhbmNlO1xuICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlUmlnaHQnOlxuICAgICAgeCArPSB3aWR0aCAtIGRpc3RhbmNlO1xuICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZVRvcCc6XG4gICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgIHkgKz0gZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlQm90dG9tJzpcbiAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgeSArPSBoZWlnaHQgLSBkaXN0YW5jZTtcbiAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlVG9wTGVmdCc6XG4gICAgICB4ICs9IGRpc3RhbmNlO1xuICAgICAgeSArPSBkaXN0YW5jZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlVG9wUmlnaHQnOlxuICAgICAgeCArPSB3aWR0aCAtIGRpc3RhbmNlO1xuICAgICAgeSArPSBkaXN0YW5jZTtcbiAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZUJvdHRvbUxlZnQnOlxuICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gaGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVCb3R0b21SaWdodCc6XG4gICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGhlaWdodCAtIGRpc3RhbmNlO1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogeCxcbiAgICB5OiB5LFxuICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgIHRleHRWZXJ0aWNhbEFsaWduOiB0ZXh0VmVydGljYWxBbGlnblxuICB9O1xufVxuLyoqXG4gKiBTaG93IGVsbGlwc2lzIGlmIG92ZXJmbG93LlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSAge3N0cmluZ30gdGV4dFxuICogQHBhcmFtICB7c3RyaW5nfSBjb250YWluZXJXaWR0aFxuICogQHBhcmFtICB7c3RyaW5nfSBmb250XG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtlbGxpcHNpcz0nLi4uJ11cbiAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLm1heEl0ZXJhdGlvbnM9M11cbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMubWluQ2hhcj0wXSBJZiB0cnVuY2F0ZSByZXN1bHQgYXJlIGxlc3NcbiAqICAgICAgICAgICAgICAgICAgdGhlbiBtaW5DaGFyLCBlbGxpcHNpcyB3aWxsIG5vdCBzaG93LCB3aGljaCBpc1xuICogICAgICAgICAgICAgICAgICBiZXR0ZXIgZm9yIHVzZXIgaGludCBpbiBzb21lIGNhc2VzLlxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5wbGFjZWhvbGRlcj0nJ10gV2hlbiBhbGwgdHJ1bmNhdGVkLCB1c2UgdGhlIHBsYWNlaG9sZGVyLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gdHJ1bmNhdGVUZXh0KHRleHQsIGNvbnRhaW5lcldpZHRoLCBmb250LCBlbGxpcHNpcywgb3B0aW9ucykge1xuICBpZiAoIWNvbnRhaW5lcldpZHRoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIHRleHRMaW5lcyA9ICh0ZXh0ICsgJycpLnNwbGl0KCdcXG4nKTtcbiAgb3B0aW9ucyA9IHByZXBhcmVUcnVuY2F0ZU9wdGlvbnMoY29udGFpbmVyV2lkdGgsIGZvbnQsIGVsbGlwc2lzLCBvcHRpb25zKTsgLy8gRklYTUVcbiAgLy8gSXQgaXMgbm90IGFwcHJvcHJpYXRlIHRoYXQgZXZlcnkgbGluZSBoYXMgJy4uLicgd2hlbiB0cnVuY2F0ZSBtdWx0aXBsZSBsaW5lcy5cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdGV4dExpbmVzW2ldID0gdHJ1bmNhdGVTaW5nbGVMaW5lKHRleHRMaW5lc1tpXSwgb3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gdGV4dExpbmVzLmpvaW4oJ1xcbicpO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlVHJ1bmNhdGVPcHRpb25zKGNvbnRhaW5lcldpZHRoLCBmb250LCBlbGxpcHNpcywgb3B0aW9ucykge1xuICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgb3B0aW9ucy5mb250ID0gZm9udDtcbiAgdmFyIGVsbGlwc2lzID0gcmV0cmlldmUyKGVsbGlwc2lzLCAnLi4uJyk7XG4gIG9wdGlvbnMubWF4SXRlcmF0aW9ucyA9IHJldHJpZXZlMihvcHRpb25zLm1heEl0ZXJhdGlvbnMsIDIpO1xuICB2YXIgbWluQ2hhciA9IG9wdGlvbnMubWluQ2hhciA9IHJldHJpZXZlMihvcHRpb25zLm1pbkNoYXIsIDApOyAvLyBGSVhNRVxuICAvLyBPdGhlciBsYW5ndWFnZXM/XG5cbiAgb3B0aW9ucy5jbkNoYXJXaWR0aCA9IGdldFdpZHRoKCflm70nLCBmb250KTsgLy8gRklYTUVcbiAgLy8gQ29uc2lkZXIgcHJvcG9ydGlvbmFsIGZvbnQ/XG5cbiAgdmFyIGFzY0NoYXJXaWR0aCA9IG9wdGlvbnMuYXNjQ2hhcldpZHRoID0gZ2V0V2lkdGgoJ2EnLCBmb250KTtcbiAgb3B0aW9ucy5wbGFjZWhvbGRlciA9IHJldHJpZXZlMihvcHRpb25zLnBsYWNlaG9sZGVyLCAnJyk7IC8vIEV4YW1wbGUgMTogbWluQ2hhcjogMywgdGV4dDogJ2FzZGZ6eGN2JywgdHJ1bmNhdGUgcmVzdWx0OiAnYXNkZicsIGJ1dCBub3Q6ICdhLi4uJy5cbiAgLy8gRXhhbXBsZSAyOiBtaW5DaGFyOiAzLCB0ZXh0OiAn57u05bqmJywgdHJ1bmNhdGUgcmVzdWx0OiAn57u0JywgYnV0IG5vdDogJy4uLicuXG5cbiAgdmFyIGNvbnRlbnRXaWR0aCA9IGNvbnRhaW5lcldpZHRoID0gTWF0aC5tYXgoMCwgY29udGFpbmVyV2lkdGggLSAxKTsgLy8gUmVzZXJ2ZSBzb21lIGdhcC5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbkNoYXIgJiYgY29udGVudFdpZHRoID49IGFzY0NoYXJXaWR0aDsgaSsrKSB7XG4gICAgY29udGVudFdpZHRoIC09IGFzY0NoYXJXaWR0aDtcbiAgfVxuXG4gIHZhciBlbGxpcHNpc1dpZHRoID0gZ2V0V2lkdGgoZWxsaXBzaXMpO1xuXG4gIGlmIChlbGxpcHNpc1dpZHRoID4gY29udGVudFdpZHRoKSB7XG4gICAgZWxsaXBzaXMgPSAnJztcbiAgICBlbGxpcHNpc1dpZHRoID0gMDtcbiAgfVxuXG4gIGNvbnRlbnRXaWR0aCA9IGNvbnRhaW5lcldpZHRoIC0gZWxsaXBzaXNXaWR0aDtcbiAgb3B0aW9ucy5lbGxpcHNpcyA9IGVsbGlwc2lzO1xuICBvcHRpb25zLmVsbGlwc2lzV2lkdGggPSBlbGxpcHNpc1dpZHRoO1xuICBvcHRpb25zLmNvbnRlbnRXaWR0aCA9IGNvbnRlbnRXaWR0aDtcbiAgb3B0aW9ucy5jb250YWluZXJXaWR0aCA9IGNvbnRhaW5lcldpZHRoO1xuICByZXR1cm4gb3B0aW9ucztcbn1cblxuZnVuY3Rpb24gdHJ1bmNhdGVTaW5nbGVMaW5lKHRleHRMaW5lLCBvcHRpb25zKSB7XG4gIHZhciBjb250YWluZXJXaWR0aCA9IG9wdGlvbnMuY29udGFpbmVyV2lkdGg7XG4gIHZhciBmb250ID0gb3B0aW9ucy5mb250O1xuICB2YXIgY29udGVudFdpZHRoID0gb3B0aW9ucy5jb250ZW50V2lkdGg7XG5cbiAgaWYgKCFjb250YWluZXJXaWR0aCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciBsaW5lV2lkdGggPSBnZXRXaWR0aCh0ZXh0TGluZSwgZm9udCk7XG5cbiAgaWYgKGxpbmVXaWR0aCA8PSBjb250YWluZXJXaWR0aCkge1xuICAgIHJldHVybiB0ZXh0TGluZTtcbiAgfVxuXG4gIGZvciAodmFyIGogPSAwOzsgaisrKSB7XG4gICAgaWYgKGxpbmVXaWR0aCA8PSBjb250ZW50V2lkdGggfHwgaiA+PSBvcHRpb25zLm1heEl0ZXJhdGlvbnMpIHtcbiAgICAgIHRleHRMaW5lICs9IG9wdGlvbnMuZWxsaXBzaXM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgc3ViTGVuZ3RoID0gaiA9PT0gMCA/IGVzdGltYXRlTGVuZ3RoKHRleHRMaW5lLCBjb250ZW50V2lkdGgsIG9wdGlvbnMuYXNjQ2hhcldpZHRoLCBvcHRpb25zLmNuQ2hhcldpZHRoKSA6IGxpbmVXaWR0aCA+IDAgPyBNYXRoLmZsb29yKHRleHRMaW5lLmxlbmd0aCAqIGNvbnRlbnRXaWR0aCAvIGxpbmVXaWR0aCkgOiAwO1xuICAgIHRleHRMaW5lID0gdGV4dExpbmUuc3Vic3RyKDAsIHN1Ykxlbmd0aCk7XG4gICAgbGluZVdpZHRoID0gZ2V0V2lkdGgodGV4dExpbmUsIGZvbnQpO1xuICB9XG5cbiAgaWYgKHRleHRMaW5lID09PSAnJykge1xuICAgIHRleHRMaW5lID0gb3B0aW9ucy5wbGFjZWhvbGRlcjtcbiAgfVxuXG4gIHJldHVybiB0ZXh0TGluZTtcbn1cblxuZnVuY3Rpb24gZXN0aW1hdGVMZW5ndGgodGV4dCwgY29udGVudFdpZHRoLCBhc2NDaGFyV2lkdGgsIGNuQ2hhcldpZHRoKSB7XG4gIHZhciB3aWR0aCA9IDA7XG4gIHZhciBpID0gMDtcblxuICBmb3IgKHZhciBsZW4gPSB0ZXh0Lmxlbmd0aDsgaSA8IGxlbiAmJiB3aWR0aCA8IGNvbnRlbnRXaWR0aDsgaSsrKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgIHdpZHRoICs9IDAgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gMTI3ID8gYXNjQ2hhcldpZHRoIDogY25DaGFyV2lkdGg7XG4gIH1cblxuICByZXR1cm4gaTtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IGZvbnRcbiAqIEByZXR1cm4ge251bWJlcn0gbGluZSBoZWlnaHRcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldExpbmVIZWlnaHQoZm9udCkge1xuICAvLyBGSVhNRSBBIHJvdWdoIGFwcHJvYWNoLlxuICByZXR1cm4gZ2V0V2lkdGgoJ+WbvScsIGZvbnQpO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnRcbiAqIEByZXR1cm4ge09iamVjdH0gd2lkdGhcbiAqL1xuXG5cbmZ1bmN0aW9uIG1lYXN1cmVUZXh0KHRleHQsIGZvbnQpIHtcbiAgcmV0dXJuIG1ldGhvZHMubWVhc3VyZVRleHQodGV4dCwgZm9udCk7XG59IC8vIEF2b2lkIGFzc2lnbiB0byBhbiBleHBvcnRlZCB2YXJpYWJsZSwgZm9yIHRyYW5zZm9ybWluZyB0byBjanMuXG5cblxubWV0aG9kcy5tZWFzdXJlVGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBmb250KSB7XG4gIHZhciBjdHggPSBnZXRDb250ZXh0KCk7XG4gIGN0eC5mb250ID0gZm9udCB8fCBERUZBVUxUX0ZPTlQ7XG4gIHJldHVybiBjdHgubWVhc3VyZVRleHQodGV4dCk7XG59O1xuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbdHJ1bmNhdGVdXG4gKiBAcmV0dXJuIHtPYmplY3R9IGJsb2NrOiB7bGluZUhlaWdodCwgbGluZXMsIGhlaWdodCwgb3V0ZXJIZWlnaHR9XG4gKiAgTm90aWNlOiBmb3IgcGVyZm9ybWFuY2UsIGRvIG5vdCBjYWxjdWxhdGUgb3V0ZXJXaWR0aCB1dGlsIG5lZWRlZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlUGxhaW5UZXh0KHRleHQsIGZvbnQsIHBhZGRpbmcsIHRydW5jYXRlKSB7XG4gIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG4gIHZhciBsaW5lSGVpZ2h0ID0gZ2V0TGluZUhlaWdodChmb250KTtcbiAgdmFyIGxpbmVzID0gdGV4dCA/IHRleHQuc3BsaXQoJ1xcbicpIDogW107XG4gIHZhciBoZWlnaHQgPSBsaW5lcy5sZW5ndGggKiBsaW5lSGVpZ2h0O1xuICB2YXIgb3V0ZXJIZWlnaHQgPSBoZWlnaHQ7XG5cbiAgaWYgKHBhZGRpbmcpIHtcbiAgICBvdXRlckhlaWdodCArPSBwYWRkaW5nWzBdICsgcGFkZGluZ1syXTtcbiAgfVxuXG4gIGlmICh0ZXh0ICYmIHRydW5jYXRlKSB7XG4gICAgdmFyIHRydW5jT3V0ZXJIZWlnaHQgPSB0cnVuY2F0ZS5vdXRlckhlaWdodDtcbiAgICB2YXIgdHJ1bmNPdXRlcldpZHRoID0gdHJ1bmNhdGUub3V0ZXJXaWR0aDtcblxuICAgIGlmICh0cnVuY091dGVySGVpZ2h0ICE9IG51bGwgJiYgb3V0ZXJIZWlnaHQgPiB0cnVuY091dGVySGVpZ2h0KSB7XG4gICAgICB0ZXh0ID0gJyc7XG4gICAgICBsaW5lcyA9IFtdO1xuICAgIH0gZWxzZSBpZiAodHJ1bmNPdXRlcldpZHRoICE9IG51bGwpIHtcbiAgICAgIHZhciBvcHRpb25zID0gcHJlcGFyZVRydW5jYXRlT3B0aW9ucyh0cnVuY091dGVyV2lkdGggLSAocGFkZGluZyA/IHBhZGRpbmdbMV0gKyBwYWRkaW5nWzNdIDogMCksIGZvbnQsIHRydW5jYXRlLmVsbGlwc2lzLCB7XG4gICAgICAgIG1pbkNoYXI6IHRydW5jYXRlLm1pbkNoYXIsXG4gICAgICAgIHBsYWNlaG9sZGVyOiB0cnVuY2F0ZS5wbGFjZWhvbGRlclxuICAgICAgfSk7IC8vIEZJWE1FXG4gICAgICAvLyBJdCBpcyBub3QgYXBwcm9wcmlhdGUgdGhhdCBldmVyeSBsaW5lIGhhcyAnLi4uJyB3aGVuIHRydW5jYXRlIG11bHRpcGxlIGxpbmVzLlxuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGluZXNbaV0gPSB0cnVuY2F0ZVNpbmdsZUxpbmUobGluZXNbaV0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGluZXM6IGxpbmVzLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIG91dGVySGVpZ2h0OiBvdXRlckhlaWdodCxcbiAgICBsaW5lSGVpZ2h0OiBsaW5lSGVpZ2h0XG4gIH07XG59XG4vKipcbiAqIEZvciBleGFtcGxlOiAnc29tZSB0ZXh0IHthfHNvbWUgdGV4dH1vdGhlciB0ZXh0e2J8c29tZSB0ZXh0fXh4eHtjfH14eHgnXG4gKiBBbHNvIGNvbnNpZGVyICdiYmJie2F8eHh4XFxuenp6fXh4eHhcXG5hYWFhJy5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gKiBAcmV0dXJuIHtPYmplY3R9IGJsb2NrXG4gKiB7XG4gKiAgICAgIHdpZHRoLFxuICogICAgICBoZWlnaHQsXG4gKiAgICAgIGxpbmVzOiBbe1xuICogICAgICAgICAgbGluZUhlaWdodCxcbiAqICAgICAgICAgIHdpZHRoLFxuICogICAgICAgICAgdG9rZW5zOiBbW3tcbiAqICAgICAgICAgICAgICBzdHlsZU5hbWUsXG4gKiAgICAgICAgICAgICAgdGV4dCxcbiAqICAgICAgICAgICAgICB3aWR0aCwgICAgICAvLyBpbmNsdWRlIHRleHRQYWRkaW5nXG4gKiAgICAgICAgICAgICAgaGVpZ2h0LCAgICAgLy8gaW5jbHVkZSB0ZXh0UGFkZGluZ1xuICogICAgICAgICAgICAgIHRleHRXaWR0aCwgLy8gcHVyZSB0ZXh0IHdpZHRoXG4gKiAgICAgICAgICAgICAgdGV4dEhlaWdodCwgLy8gcHVyZSB0ZXh0IGhlaWdodFxuICogICAgICAgICAgICAgIGxpbmVIZWloZ3QsXG4gKiAgICAgICAgICAgICAgZm9udCxcbiAqICAgICAgICAgICAgICB0ZXh0QWxpZ24sXG4gKiAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ25cbiAqICAgICAgICAgIH1dLCBbLi4uXSwgLi4uXVxuICogICAgICB9LCAuLi5dXG4gKiB9XG4gKiBJZiBzdHlsZU5hbWUgaXMgdW5kZWZpbmVkLCBpdCBpcyBwbGFpbiB0ZXh0LlxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VSaWNoVGV4dCh0ZXh0LCBzdHlsZSkge1xuICB2YXIgY29udGVudEJsb2NrID0ge1xuICAgIGxpbmVzOiBbXSxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfTtcbiAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcblxuICBpZiAoIXRleHQpIHtcbiAgICByZXR1cm4gY29udGVudEJsb2NrO1xuICB9XG5cbiAgdmFyIGxhc3RJbmRleCA9IFNUWUxFX1JFRy5sYXN0SW5kZXggPSAwO1xuICB2YXIgcmVzdWx0O1xuXG4gIHdoaWxlICgocmVzdWx0ID0gU1RZTEVfUkVHLmV4ZWModGV4dCkpICE9IG51bGwpIHtcbiAgICB2YXIgbWF0Y2hlZEluZGV4ID0gcmVzdWx0LmluZGV4O1xuXG4gICAgaWYgKG1hdGNoZWRJbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgcHVzaFRva2Vucyhjb250ZW50QmxvY2ssIHRleHQuc3Vic3RyaW5nKGxhc3RJbmRleCwgbWF0Y2hlZEluZGV4KSk7XG4gICAgfVxuXG4gICAgcHVzaFRva2Vucyhjb250ZW50QmxvY2ssIHJlc3VsdFsyXSwgcmVzdWx0WzFdKTtcbiAgICBsYXN0SW5kZXggPSBTVFlMRV9SRUcubGFzdEluZGV4O1xuICB9XG5cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgcHVzaFRva2Vucyhjb250ZW50QmxvY2ssIHRleHQuc3Vic3RyaW5nKGxhc3RJbmRleCwgdGV4dC5sZW5ndGgpKTtcbiAgfVxuXG4gIHZhciBsaW5lcyA9IGNvbnRlbnRCbG9jay5saW5lcztcbiAgdmFyIGNvbnRlbnRIZWlnaHQgPSAwO1xuICB2YXIgY29udGVudFdpZHRoID0gMDsgLy8gRm9yIGB0ZXh0V2lkdGg6IDEwMCVgXG5cbiAgdmFyIHBlbmRpbmdMaXN0ID0gW107XG4gIHZhciBzdGxQYWRkaW5nID0gc3R5bGUudGV4dFBhZGRpbmc7XG4gIHZhciB0cnVuY2F0ZSA9IHN0eWxlLnRydW5jYXRlO1xuICB2YXIgdHJ1bmNhdGVXaWR0aCA9IHRydW5jYXRlICYmIHRydW5jYXRlLm91dGVyV2lkdGg7XG4gIHZhciB0cnVuY2F0ZUhlaWdodCA9IHRydW5jYXRlICYmIHRydW5jYXRlLm91dGVySGVpZ2h0O1xuXG4gIGlmIChzdGxQYWRkaW5nKSB7XG4gICAgdHJ1bmNhdGVXaWR0aCAhPSBudWxsICYmICh0cnVuY2F0ZVdpZHRoIC09IHN0bFBhZGRpbmdbMV0gKyBzdGxQYWRkaW5nWzNdKTtcbiAgICB0cnVuY2F0ZUhlaWdodCAhPSBudWxsICYmICh0cnVuY2F0ZUhlaWdodCAtPSBzdGxQYWRkaW5nWzBdICsgc3RsUGFkZGluZ1syXSk7XG4gIH0gLy8gQ2FsY3VsYXRlIGxheW91dCBpbmZvIG9mIHRva2Vucy5cblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgIHZhciBsaW5lSGVpZ2h0ID0gMDtcbiAgICB2YXIgbGluZVdpZHRoID0gMDtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZS50b2tlbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IGxpbmUudG9rZW5zW2pdO1xuICAgICAgdmFyIHRva2VuU3R5bGUgPSB0b2tlbi5zdHlsZU5hbWUgJiYgc3R5bGUucmljaFt0b2tlbi5zdHlsZU5hbWVdIHx8IHt9OyAvLyB0ZXh0UGFkZGluZyBzaG91bGQgbm90IGluaGVyaXQgZnJvbSBzdHlsZS5cblxuICAgICAgdmFyIHRleHRQYWRkaW5nID0gdG9rZW4udGV4dFBhZGRpbmcgPSB0b2tlblN0eWxlLnRleHRQYWRkaW5nOyAvLyB0ZXh0Rm9udCBoYXMgYmVlbiBhc2lnbmVkIHRvIGZvbnQgYnkgYG5vcm1hbGl6ZVN0eWxlYC5cblxuICAgICAgdmFyIGZvbnQgPSB0b2tlbi5mb250ID0gdG9rZW5TdHlsZS5mb250IHx8IHN0eWxlLmZvbnQ7IC8vIHRleHRIZWlnaHQgY2FuIGJlIHVzZWQgd2hlbiB0ZXh0VmVydGljYWxBbGlnbiBpcyBzcGVjaWZpZWQgaW4gdG9rZW4uXG5cbiAgICAgIHZhciB0b2tlbkhlaWdodCA9IHRva2VuLnRleHRIZWlnaHQgPSByZXRyaWV2ZTIoIC8vIHRleHRIZWlnaHQgc2hvdWxkIG5vdCBiZSBpbmhlcml0ZWQsIGNvbnNpZGVyIGl0IGNhbiBiZSBzcGVjaWZpZWRcbiAgICAgIC8vIGFzIGJveCBoZWlnaHQgb2YgdGhlIGJsb2NrLlxuICAgICAgdG9rZW5TdHlsZS50ZXh0SGVpZ2h0LCBnZXRMaW5lSGVpZ2h0KGZvbnQpKTtcbiAgICAgIHRleHRQYWRkaW5nICYmICh0b2tlbkhlaWdodCArPSB0ZXh0UGFkZGluZ1swXSArIHRleHRQYWRkaW5nWzJdKTtcbiAgICAgIHRva2VuLmhlaWdodCA9IHRva2VuSGVpZ2h0O1xuICAgICAgdG9rZW4ubGluZUhlaWdodCA9IHJldHJpZXZlMyh0b2tlblN0eWxlLnRleHRMaW5lSGVpZ2h0LCBzdHlsZS50ZXh0TGluZUhlaWdodCwgdG9rZW5IZWlnaHQpO1xuICAgICAgdG9rZW4udGV4dEFsaWduID0gdG9rZW5TdHlsZSAmJiB0b2tlblN0eWxlLnRleHRBbGlnbiB8fCBzdHlsZS50ZXh0QWxpZ247XG4gICAgICB0b2tlbi50ZXh0VmVydGljYWxBbGlnbiA9IHRva2VuU3R5bGUgJiYgdG9rZW5TdHlsZS50ZXh0VmVydGljYWxBbGlnbiB8fCAnbWlkZGxlJztcblxuICAgICAgaWYgKHRydW5jYXRlSGVpZ2h0ICE9IG51bGwgJiYgY29udGVudEhlaWdodCArIHRva2VuLmxpbmVIZWlnaHQgPiB0cnVuY2F0ZUhlaWdodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmVzOiBbXSxcbiAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdG9rZW4udGV4dFdpZHRoID0gZ2V0V2lkdGgodG9rZW4udGV4dCwgZm9udCk7XG4gICAgICB2YXIgdG9rZW5XaWR0aCA9IHRva2VuU3R5bGUudGV4dFdpZHRoO1xuICAgICAgdmFyIHRva2VuV2lkdGhOb3RTcGVjaWZpZWQgPSB0b2tlbldpZHRoID09IG51bGwgfHwgdG9rZW5XaWR0aCA9PT0gJ2F1dG8nOyAvLyBQZXJjZW50IHdpZHRoLCBjYW4gYmUgYDEwMCVgLCBjYW4gYmUgdXNlZCBpbiBkcmF3aW5nIHNlcGFyYXRlXG4gICAgICAvLyBsaW5lIHdoZW4gYm94IHdpZHRoIGlzIG5lZWRlZCB0byBiZSBhdXRvLlxuXG4gICAgICBpZiAodHlwZW9mIHRva2VuV2lkdGggPT09ICdzdHJpbmcnICYmIHRva2VuV2lkdGguY2hhckF0KHRva2VuV2lkdGgubGVuZ3RoIC0gMSkgPT09ICclJykge1xuICAgICAgICB0b2tlbi5wZXJjZW50V2lkdGggPSB0b2tlbldpZHRoO1xuICAgICAgICBwZW5kaW5nTGlzdC5wdXNoKHRva2VuKTtcbiAgICAgICAgdG9rZW5XaWR0aCA9IDA7IC8vIERvIG5vdCB0cnVuY2F0ZSBpbiB0aGlzIGNhc2UsIGJlY2F1c2UgdGhlcmUgaXMgbm8gdXNlciBjYXNlXG4gICAgICAgIC8vIGFuZCBpdCBpcyB0b28gY29tcGxpY2F0ZWQuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodG9rZW5XaWR0aE5vdFNwZWNpZmllZCkge1xuICAgICAgICAgIHRva2VuV2lkdGggPSB0b2tlbi50ZXh0V2lkdGg7IC8vIEZJWE1FOiBJZiBpbWFnZSBpcyBub3QgbG9hZGVkIGFuZCB0ZXh0V2lkdGggaXMgbm90IHNwZWNpZmllZCwgY2FsbGluZ1xuICAgICAgICAgIC8vIGBnZXRCb3VuZGluZ1JlY3QoKWAgd2lsbCBub3QgZ2V0IGNvcnJlY3QgcmVzdWx0LlxuXG4gICAgICAgICAgdmFyIHRleHRCYWNrZ3JvdW5kQ29sb3IgPSB0b2tlblN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgdmFyIGJnSW1nID0gdGV4dEJhY2tncm91bmRDb2xvciAmJiB0ZXh0QmFja2dyb3VuZENvbG9yLmltYWdlOyAvLyBVc2UgY2FzZXM6XG4gICAgICAgICAgLy8gKDEpIElmIGltYWdlIGlzIG5vdCBsb2FkZWQsIGl0IHdpbGwgYmUgbG9hZGVkIGF0IHJlbmRlciBwaGFzZSBhbmQgY2FsbFxuICAgICAgICAgIC8vIGBkaXJ0eSgpYCBhbmQgYHRleHRCYWNrZ3JvdW5kQ29sb3IuaW1hZ2VgIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgbG9hZGVkXG4gICAgICAgICAgLy8gaW1hZ2UsIGFuZCB0aGVuIHRoZSByaWdodCBzaXplIHdpbGwgYmUgY2FsY3VsYXRlZCBoZXJlIGF0IHRoZSBuZXh0IHRpY2suXG4gICAgICAgICAgLy8gU2VlIGBncmFwaGljL2hlbHBlci90ZXh0LmpzYC5cbiAgICAgICAgICAvLyAoMikgSWYgaW1hZ2UgbG9hZGVkLCBhbmQgYHRleHRCYWNrZ3JvdW5kQ29sb3IuaW1hZ2VgIGlzIGltYWdlIHNyYyBzdHJpbmcsXG4gICAgICAgICAgLy8gdXNlIGBpbWFnZUhlbHBlci5maW5kRXhpc3RJbWFnZWAgdG8gZmluZCBjYWNoZWQgaW1hZ2UuXG4gICAgICAgICAgLy8gYGltYWdlSGVscGVyLmZpbmRFeGlzdEltYWdlYCB3aWxsIGFsd2F5cyBiZSBjYWxsZWQgaGVyZSBiZWZvcmVcbiAgICAgICAgICAvLyBgaW1hZ2VIZWxwZXIuY3JlYXRlT3JVcGRhdGVJbWFnZWAgaW4gYGdyYXBoaWMvaGVscGVyL3RleHQuanMjcmVuZGVyUmljaFRleHRgXG4gICAgICAgICAgLy8gd2hpY2ggZW5zdXJlcyB0aGF0IGltYWdlIHdpbGwgbm90IGJlIHJlbmRlcmVkIGJlZm9yZSBjb3JyZWN0IHNpemUgY2FsY3VhbHRlZC5cblxuICAgICAgICAgIGlmIChiZ0ltZykge1xuICAgICAgICAgICAgYmdJbWcgPSBpbWFnZUhlbHBlci5maW5kRXhpc3RJbWFnZShiZ0ltZyk7XG5cbiAgICAgICAgICAgIGlmIChpbWFnZUhlbHBlci5pc0ltYWdlUmVhZHkoYmdJbWcpKSB7XG4gICAgICAgICAgICAgIHRva2VuV2lkdGggPSBNYXRoLm1heCh0b2tlbldpZHRoLCBiZ0ltZy53aWR0aCAqIHRva2VuSGVpZ2h0IC8gYmdJbWcuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFkZGluZ1cgPSB0ZXh0UGFkZGluZyA/IHRleHRQYWRkaW5nWzFdICsgdGV4dFBhZGRpbmdbM10gOiAwO1xuICAgICAgICB0b2tlbldpZHRoICs9IHBhZGRpbmdXO1xuICAgICAgICB2YXIgcmVtaWFuVHJ1bmNXaWR0aCA9IHRydW5jYXRlV2lkdGggIT0gbnVsbCA/IHRydW5jYXRlV2lkdGggLSBsaW5lV2lkdGggOiBudWxsO1xuXG4gICAgICAgIGlmIChyZW1pYW5UcnVuY1dpZHRoICE9IG51bGwgJiYgcmVtaWFuVHJ1bmNXaWR0aCA8IHRva2VuV2lkdGgpIHtcbiAgICAgICAgICBpZiAoIXRva2VuV2lkdGhOb3RTcGVjaWZpZWQgfHwgcmVtaWFuVHJ1bmNXaWR0aCA8IHBhZGRpbmdXKSB7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gJyc7XG4gICAgICAgICAgICB0b2tlbi50ZXh0V2lkdGggPSB0b2tlbldpZHRoID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9rZW4udGV4dCA9IHRydW5jYXRlVGV4dCh0b2tlbi50ZXh0LCByZW1pYW5UcnVuY1dpZHRoIC0gcGFkZGluZ1csIGZvbnQsIHRydW5jYXRlLmVsbGlwc2lzLCB7XG4gICAgICAgICAgICAgIG1pbkNoYXI6IHRydW5jYXRlLm1pbkNoYXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdG9rZW4udGV4dFdpZHRoID0gZ2V0V2lkdGgodG9rZW4udGV4dCwgZm9udCk7XG4gICAgICAgICAgICB0b2tlbldpZHRoID0gdG9rZW4udGV4dFdpZHRoICsgcGFkZGluZ1c7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpbmVXaWR0aCArPSB0b2tlbi53aWR0aCA9IHRva2VuV2lkdGg7XG4gICAgICB0b2tlblN0eWxlICYmIChsaW5lSGVpZ2h0ID0gTWF0aC5tYXgobGluZUhlaWdodCwgdG9rZW4ubGluZUhlaWdodCkpO1xuICAgIH1cblxuICAgIGxpbmUud2lkdGggPSBsaW5lV2lkdGg7XG4gICAgbGluZS5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICBjb250ZW50SGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgY29udGVudFdpZHRoID0gTWF0aC5tYXgoY29udGVudFdpZHRoLCBsaW5lV2lkdGgpO1xuICB9XG5cbiAgY29udGVudEJsb2NrLm91dGVyV2lkdGggPSBjb250ZW50QmxvY2sud2lkdGggPSByZXRyaWV2ZTIoc3R5bGUudGV4dFdpZHRoLCBjb250ZW50V2lkdGgpO1xuICBjb250ZW50QmxvY2sub3V0ZXJIZWlnaHQgPSBjb250ZW50QmxvY2suaGVpZ2h0ID0gcmV0cmlldmUyKHN0eWxlLnRleHRIZWlnaHQsIGNvbnRlbnRIZWlnaHQpO1xuXG4gIGlmIChzdGxQYWRkaW5nKSB7XG4gICAgY29udGVudEJsb2NrLm91dGVyV2lkdGggKz0gc3RsUGFkZGluZ1sxXSArIHN0bFBhZGRpbmdbM107XG4gICAgY29udGVudEJsb2NrLm91dGVySGVpZ2h0ICs9IHN0bFBhZGRpbmdbMF0gKyBzdGxQYWRkaW5nWzJdO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwZW5kaW5nTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IHBlbmRpbmdMaXN0W2ldO1xuICAgIHZhciBwZXJjZW50V2lkdGggPSB0b2tlbi5wZXJjZW50V2lkdGg7IC8vIFNob3VsZCBub3QgYmFzZSBvbiBvdXRlcldpZHRoLCBiZWNhdXNlIHRva2VuIGNhbiBub3QgYmUgcGxhY2VkIG91dCBvZiBwYWRkaW5nLlxuXG4gICAgdG9rZW4ud2lkdGggPSBwYXJzZUludChwZXJjZW50V2lkdGgsIDEwKSAvIDEwMCAqIGNvbnRlbnRXaWR0aDtcbiAgfVxuXG4gIHJldHVybiBjb250ZW50QmxvY2s7XG59XG5cbmZ1bmN0aW9uIHB1c2hUb2tlbnMoYmxvY2ssIHN0ciwgc3R5bGVOYW1lKSB7XG4gIHZhciBpc0VtcHR5U3RyID0gc3RyID09PSAnJztcbiAgdmFyIHN0cnMgPSBzdHIuc3BsaXQoJ1xcbicpO1xuICB2YXIgbGluZXMgPSBibG9jay5saW5lcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdGV4dCA9IHN0cnNbaV07XG4gICAgdmFyIHRva2VuID0ge1xuICAgICAgc3R5bGVOYW1lOiBzdHlsZU5hbWUsXG4gICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgaXNMaW5lSG9sZGVyOiAhdGV4dCAmJiAhaXNFbXB0eVN0clxuICAgIH07IC8vIFRoZSBmaXJzdCB0b2tlbiBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIGxhc3QgbGluZS5cblxuICAgIGlmICghaSkge1xuICAgICAgdmFyIHRva2VucyA9IChsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSB8fCAobGluZXNbMF0gPSB7XG4gICAgICAgIHRva2VuczogW11cbiAgICAgIH0pKS50b2tlbnM7IC8vIENvbnNpZGVyIGNhc2VzOlxuICAgICAgLy8gKDEpICcnLnNwbGl0KCdcXG4nKSA9PiBbJycsICdcXG4nLCAnJ10sIHRoZSAnJyBhdCB0aGUgZmlyc3QgaXRlbVxuICAgICAgLy8gKHdoaWNoIGlzIGEgcGxhY2Vob2xkZXIpIHNob3VsZCBiZSByZXBsYWNlZCBieSBuZXcgdG9rZW4uXG4gICAgICAvLyAoMikgQSBpbWFnZSBiYWNrYWdlLCB3aGVyZSB0b2tlbiBsaWtlcyB7YXx9LlxuICAgICAgLy8gKDMpIEEgcmVkdW5kYW50ICcnIHdpbGwgYWZmZWN0IHRleHRBbGlnbiBpbiBsaW5lLlxuICAgICAgLy8gKDQpIHRva2VucyB3aXRoIHRoZSBzYW1lIHRwbE5hbWUgc2hvdWxkIG5vdCBiZSBtZXJnZWQsIGJlY2F1c2VcbiAgICAgIC8vIHRoZXkgc2hvdWxkIGJlIGRpc3BsYXllZCBpbiBkaWZmZXJlbnQgYm94ICh3aXRoIGJvcmRlciBhbmQgcGFkZGluZykuXG5cbiAgICAgIHZhciB0b2tlbnNMZW4gPSB0b2tlbnMubGVuZ3RoO1xuICAgICAgdG9rZW5zTGVuID09PSAxICYmIHRva2Vuc1swXS5pc0xpbmVIb2xkZXIgPyB0b2tlbnNbMF0gPSB0b2tlbiA6IC8vIENvbnNpZGVyIHRleHQgaXMgJycsIG9ubHkgaW5zZXJ0IHdoZW4gaXQgaXMgdGhlIFwibGluZUhvbGRlclwiIG9yXG4gICAgICAvLyBcImVtcHR5U3RyXCIuIE90aGVyd2lzZSBhIHJlZHVuZGFudCAnJyB3aWxsIGFmZmVjdCB0ZXh0QWxpZ24gaW4gbGluZS5cbiAgICAgICh0ZXh0IHx8ICF0b2tlbnNMZW4gfHwgaXNFbXB0eVN0cikgJiYgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgIH0gLy8gT3RoZXIgdG9rZW5zIGFsd2F5cyBzdGFydCBhIG5ldyBsaW5lLlxuICAgIGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyAnJywgaW5zZXJ0IGl0IGFzIGEgcGxhY2Vob2xkZXIuXG4gICAgICAgIGxpbmVzLnB1c2goe1xuICAgICAgICAgIHRva2VuczogW3Rva2VuXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlRm9udChzdHlsZSkge1xuICAvLyBGSVhNRSBpbiBub2RlLWNhbnZhcyBmb250V2VpZ2h0IGlzIGJlZm9yZSBmb250U3R5bGVcbiAgLy8gVXNlIGBmb250U2l6ZWAgYGZvbnRGYW1pbHlgIHRvIGNoZWNrIHdoZXRoZXIgZm9udCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkLlxuICByZXR1cm4gKHN0eWxlLmZvbnRTaXplIHx8IHN0eWxlLmZvbnRGYW1pbHkpICYmIFtzdHlsZS5mb250U3R5bGUsIHN0eWxlLmZvbnRXZWlnaHQsIChzdHlsZS5mb250U2l6ZSB8fCAxMikgKyAncHgnLCAvLyBJZiBmb250IHByb3BlcnRpZXMgYXJlIGRlZmluZWQsIGBmb250RmFtaWx5YCBzaG91bGQgbm90IGJlIGlnbm9yZWQuXG4gIHN0eWxlLmZvbnRGYW1pbHkgfHwgJ3NhbnMtc2VyaWYnXS5qb2luKCcgJykgfHwgc3R5bGUudGV4dEZvbnQgfHwgc3R5bGUuZm9udDtcbn1cblxuZXhwb3J0cy5ERUZBVUxUX0ZPTlQgPSBERUZBVUxUX0ZPTlQ7XG5leHBvcnRzLiRvdmVycmlkZSA9ICRvdmVycmlkZTtcbmV4cG9ydHMuZ2V0V2lkdGggPSBnZXRXaWR0aDtcbmV4cG9ydHMuZ2V0Qm91bmRpbmdSZWN0ID0gZ2V0Qm91bmRpbmdSZWN0O1xuZXhwb3J0cy5hZGp1c3RUZXh0WCA9IGFkanVzdFRleHRYO1xuZXhwb3J0cy5hZGp1c3RUZXh0WSA9IGFkanVzdFRleHRZO1xuZXhwb3J0cy5hZGp1c3RUZXh0UG9zaXRpb25PblJlY3QgPSBhZGp1c3RUZXh0UG9zaXRpb25PblJlY3Q7XG5leHBvcnRzLnRydW5jYXRlVGV4dCA9IHRydW5jYXRlVGV4dDtcbmV4cG9ydHMuZ2V0TGluZUhlaWdodCA9IGdldExpbmVIZWlnaHQ7XG5leHBvcnRzLm1lYXN1cmVUZXh0ID0gbWVhc3VyZVRleHQ7XG5leHBvcnRzLnBhcnNlUGxhaW5UZXh0ID0gcGFyc2VQbGFpblRleHQ7XG5leHBvcnRzLnBhcnNlUmljaFRleHQgPSBwYXJzZVJpY2hUZXh0O1xuZXhwb3J0cy5tYWtlRm9udCA9IG1ha2VGb250O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb250YWluL3RleHQuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB2ZWMyID0gcmVxdWlyZShcIi4vdmVjdG9yXCIpO1xuXG52YXIgbWF0cml4ID0gcmVxdWlyZShcIi4vbWF0cml4XCIpO1xuXG4vKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdFxuICovXG52YXIgdjJBcHBseVRyYW5zZm9ybSA9IHZlYzIuYXBwbHlUcmFuc2Zvcm07XG52YXIgbWF0aE1pbiA9IE1hdGgubWluO1xudmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbi8qKlxuICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0XG4gKi9cblxuZnVuY3Rpb24gQm91bmRpbmdSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgaWYgKHdpZHRoIDwgMCkge1xuICAgIHggPSB4ICsgd2lkdGg7XG4gICAgd2lkdGggPSAtd2lkdGg7XG4gIH1cblxuICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgIHkgPSB5ICsgaGVpZ2h0O1xuICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG5cbiAgdGhpcy54ID0geDtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMueSA9IHk7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLndpZHRoID0gd2lkdGg7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbn1cblxuQm91bmRpbmdSZWN0LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEJvdW5kaW5nUmVjdCxcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdH0gb3RoZXJcbiAgICovXG4gIHVuaW9uOiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICB2YXIgeCA9IG1hdGhNaW4ob3RoZXIueCwgdGhpcy54KTtcbiAgICB2YXIgeSA9IG1hdGhNaW4ob3RoZXIueSwgdGhpcy55KTtcbiAgICB0aGlzLndpZHRoID0gbWF0aE1heChvdGhlci54ICsgb3RoZXIud2lkdGgsIHRoaXMueCArIHRoaXMud2lkdGgpIC0geDtcbiAgICB0aGlzLmhlaWdodCA9IG1hdGhNYXgob3RoZXIueSArIG90aGVyLmhlaWdodCwgdGhpcy55ICsgdGhpcy5oZWlnaHQpIC0geTtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1cbiAgICogQG1ldGhvZHNcbiAgICovXG4gIGFwcGx5VHJhbnNmb3JtOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGx0ID0gW107XG4gICAgdmFyIHJiID0gW107XG4gICAgdmFyIGxiID0gW107XG4gICAgdmFyIHJ0ID0gW107XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtKSB7XG4gICAgICAvLyBJbiBjYXNlIHVzYWdlIGxpa2UgdGhpc1xuICAgICAgLy8gZWwuZ2V0Qm91bmRpbmdSZWN0KCkuYXBwbHlUcmFuc2Zvcm0oZWwudHJhbnNmb3JtKVxuICAgICAgLy8gQW5kIGVsZW1lbnQgaGFzIG5vIHRyYW5zZm9ybVxuICAgICAgaWYgKCFtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbHRbMF0gPSBsYlswXSA9IHRoaXMueDtcbiAgICAgIGx0WzFdID0gcnRbMV0gPSB0aGlzLnk7XG4gICAgICByYlswXSA9IHJ0WzBdID0gdGhpcy54ICsgdGhpcy53aWR0aDtcbiAgICAgIHJiWzFdID0gbGJbMV0gPSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbiAgICAgIHYyQXBwbHlUcmFuc2Zvcm0obHQsIGx0LCBtKTtcbiAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocmIsIHJiLCBtKTtcbiAgICAgIHYyQXBwbHlUcmFuc2Zvcm0obGIsIGxiLCBtKTtcbiAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocnQsIHJ0LCBtKTtcbiAgICAgIHRoaXMueCA9IG1hdGhNaW4obHRbMF0sIHJiWzBdLCBsYlswXSwgcnRbMF0pO1xuICAgICAgdGhpcy55ID0gbWF0aE1pbihsdFsxXSwgcmJbMV0sIGxiWzFdLCBydFsxXSk7XG4gICAgICB2YXIgbWF4WCA9IG1hdGhNYXgobHRbMF0sIHJiWzBdLCBsYlswXSwgcnRbMF0pO1xuICAgICAgdmFyIG1heFkgPSBtYXRoTWF4KGx0WzFdLCByYlsxXSwgbGJbMV0sIHJ0WzFdKTtcbiAgICAgIHRoaXMud2lkdGggPSBtYXhYIC0gdGhpcy54O1xuICAgICAgdGhpcy5oZWlnaHQgPSBtYXhZIC0gdGhpcy55O1xuICAgIH07XG4gIH0oKSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIG1hdHJpeCBvZiB0cmFuc2Zvcm1pbmcgZnJvbSBzZWxmIHRvIHRhcmdldCByZWN0XG4gICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSBiXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgY2FsY3VsYXRlVHJhbnNmb3JtOiBmdW5jdGlvbiAoYikge1xuICAgIHZhciBhID0gdGhpcztcbiAgICB2YXIgc3ggPSBiLndpZHRoIC8gYS53aWR0aDtcbiAgICB2YXIgc3kgPSBiLmhlaWdodCAvIGEuaGVpZ2h0O1xuICAgIHZhciBtID0gbWF0cml4LmNyZWF0ZSgpOyAvLyDnn6npmLXlj7PkuZhcblxuICAgIG1hdHJpeC50cmFuc2xhdGUobSwgbSwgWy1hLngsIC1hLnldKTtcbiAgICBtYXRyaXguc2NhbGUobSwgbSwgW3N4LCBzeV0pO1xuICAgIG1hdHJpeC50cmFuc2xhdGUobSwgbSwgW2IueCwgYi55XSk7XG4gICAgcmV0dXJuIG07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7KG1vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0fE9iamVjdCl9IGJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGludGVyc2VjdDogZnVuY3Rpb24gKGIpIHtcbiAgICBpZiAoIWIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIShiIGluc3RhbmNlb2YgQm91bmRpbmdSZWN0KSkge1xuICAgICAgLy8gTm9ybWFsaXplIG5lZ2F0aXZlIHdpZHRoL2hlaWdodC5cbiAgICAgIGIgPSBCb3VuZGluZ1JlY3QuY3JlYXRlKGIpO1xuICAgIH1cblxuICAgIHZhciBhID0gdGhpcztcbiAgICB2YXIgYXgwID0gYS54O1xuICAgIHZhciBheDEgPSBhLnggKyBhLndpZHRoO1xuICAgIHZhciBheTAgPSBhLnk7XG4gICAgdmFyIGF5MSA9IGEueSArIGEuaGVpZ2h0O1xuICAgIHZhciBieDAgPSBiLng7XG4gICAgdmFyIGJ4MSA9IGIueCArIGIud2lkdGg7XG4gICAgdmFyIGJ5MCA9IGIueTtcbiAgICB2YXIgYnkxID0gYi55ICsgYi5oZWlnaHQ7XG4gICAgcmV0dXJuICEoYXgxIDwgYngwIHx8IGJ4MSA8IGF4MCB8fCBheTEgPCBieTAgfHwgYnkxIDwgYXkwKTtcbiAgfSxcbiAgY29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgcmVjdCA9IHRoaXM7XG4gICAgcmV0dXJuIHggPj0gcmVjdC54ICYmIHggPD0gcmVjdC54ICsgcmVjdC53aWR0aCAmJiB5ID49IHJlY3QueSAmJiB5IDw9IHJlY3QueSArIHJlY3QuaGVpZ2h0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICovXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgfSxcblxuICAvKipcbiAgICogQ29weSBmcm9tIGFub3RoZXIgcmVjdFxuICAgKi9cbiAgY29weTogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgdGhpcy54ID0gb3RoZXIueDtcbiAgICB0aGlzLnkgPSBvdGhlci55O1xuICAgIHRoaXMud2lkdGggPSBvdGhlci53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IG90aGVyLmhlaWdodDtcbiAgfSxcbiAgcGxhaW46IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdGhpcy54LFxuICAgICAgeTogdGhpcy55LFxuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgfTtcbiAgfVxufTtcbi8qKlxuICogQHBhcmFtIHtPYmplY3R8bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9IHJlY3RcbiAqIEBwYXJhbSB7bnVtYmVyfSByZWN0LnhcbiAqIEBwYXJhbSB7bnVtYmVyfSByZWN0LnlcbiAqIEBwYXJhbSB7bnVtYmVyfSByZWN0LndpZHRoXG4gKiBAcGFyYW0ge251bWJlcn0gcmVjdC5oZWlnaHRcbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICovXG5cbkJvdW5kaW5nUmVjdC5jcmVhdGUgPSBmdW5jdGlvbiAocmVjdCkge1xuICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdChyZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xufTtcblxudmFyIF9kZWZhdWx0ID0gQm91bmRpbmdSZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBMUlUgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9MUlVcIik7XG5cbnZhciBnbG9iYWxJbWFnZUNhY2hlID0gbmV3IExSVSg1MCk7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBuZXdJbWFnZU9yU3JjXG4gKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fENhbnZhc30gaW1hZ2VcbiAqL1xuXG5mdW5jdGlvbiBmaW5kRXhpc3RJbWFnZShuZXdJbWFnZU9yU3JjKSB7XG4gIGlmICh0eXBlb2YgbmV3SW1hZ2VPclNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgY2FjaGVkSW1nT2JqID0gZ2xvYmFsSW1hZ2VDYWNoZS5nZXQobmV3SW1hZ2VPclNyYyk7XG4gICAgcmV0dXJuIGNhY2hlZEltZ09iaiAmJiBjYWNoZWRJbWdPYmouaW1hZ2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ld0ltYWdlT3JTcmM7XG4gIH1cbn1cbi8qKlxuICogQ2F1dGlvbjogVXNlciBzaG91bGQgY2FjaGUgbG9hZGVkIGltYWdlcywgYnV0IG5vdCBqdXN0IGNvdW50IG9uIExSVS5cbiAqIENvbnNpZGVyIGlmIHJlcXVpcmVkIGltYWdlcyBtb3JlIHRoYW4gTFJVIHNpemUsIHdpbGwgZGVhZCBsb29wIG9jY3VyP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBuZXdJbWFnZU9yU3JjXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBpbWFnZSBFeGlzdGVudCBpbWFnZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gW2hvc3RFbF0gRm9yIGNhbGxpbmcgYGRpcnR5YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gcGFyYW1zOiAoaW1hZ2UsIGNiUGF5bG9hZClcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY2JQYXlsb2FkXSBQYXlsb2FkIG9uIGNiIGNhbGxpbmcuXG4gKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fENhbnZhc30gaW1hZ2VcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlSW1hZ2UobmV3SW1hZ2VPclNyYywgaW1hZ2UsIGhvc3RFbCwgY2IsIGNiUGF5bG9hZCkge1xuICBpZiAoIW5ld0ltYWdlT3JTcmMpIHtcbiAgICByZXR1cm4gaW1hZ2U7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5ld0ltYWdlT3JTcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSW1hZ2Ugc2hvdWxkIG5vdCBiZSBsb2FkZWQgcmVwZWF0bHkuXG4gICAgaWYgKGltYWdlICYmIGltYWdlLl9fenJJbWFnZVNyYyA9PT0gbmV3SW1hZ2VPclNyYyB8fCAhaG9zdEVsKSB7XG4gICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfSAvLyBPbmx5IHdoZW4gdGhlcmUgaXMgbm8gZXhpc3RlbnQgaW1hZ2Ugb3IgZXhpc3RlbnQgaW1hZ2Ugc3JjXG4gICAgLy8gaXMgZGlmZmVyZW50LCB0aGlzIG1ldGhvZCBpcyByZXNwb25zaWJsZSBmb3IgbG9hZC5cblxuXG4gICAgdmFyIGNhY2hlZEltZ09iaiA9IGdsb2JhbEltYWdlQ2FjaGUuZ2V0KG5ld0ltYWdlT3JTcmMpO1xuICAgIHZhciBwZW5kaW5nV3JhcCA9IHtcbiAgICAgIGhvc3RFbDogaG9zdEVsLFxuICAgICAgY2I6IGNiLFxuICAgICAgY2JQYXlsb2FkOiBjYlBheWxvYWRcbiAgICB9O1xuXG4gICAgaWYgKGNhY2hlZEltZ09iaikge1xuICAgICAgaW1hZ2UgPSBjYWNoZWRJbWdPYmouaW1hZ2U7XG4gICAgICAhaXNJbWFnZVJlYWR5KGltYWdlKSAmJiBjYWNoZWRJbWdPYmoucGVuZGluZy5wdXNoKHBlbmRpbmdXcmFwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgIWltYWdlICYmIChpbWFnZSA9IG5ldyBJbWFnZSgpKTtcbiAgICAgIGltYWdlLm9ubG9hZCA9IGltYWdlT25Mb2FkO1xuICAgICAgZ2xvYmFsSW1hZ2VDYWNoZS5wdXQobmV3SW1hZ2VPclNyYywgaW1hZ2UuX19jYWNoZWRJbWdPYmogPSB7XG4gICAgICAgIGltYWdlOiBpbWFnZSxcbiAgICAgICAgcGVuZGluZzogW3BlbmRpbmdXcmFwXVxuICAgICAgfSk7XG4gICAgICBpbWFnZS5zcmMgPSBpbWFnZS5fX3pySW1hZ2VTcmMgPSBuZXdJbWFnZU9yU3JjO1xuICAgIH1cblxuICAgIHJldHVybiBpbWFnZTtcbiAgfSAvLyBuZXdJbWFnZU9yU3JjIGlzIGFuIEhUTUxJbWFnZUVsZW1lbnQgb3IgSFRNTENhbnZhc0VsZW1lbnQgb3IgQ2FudmFzXG4gIGVsc2Uge1xuICAgICAgcmV0dXJuIG5ld0ltYWdlT3JTcmM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbWFnZU9uTG9hZCgpIHtcbiAgdmFyIGNhY2hlZEltZ09iaiA9IHRoaXMuX19jYWNoZWRJbWdPYmo7XG4gIHRoaXMub25sb2FkID0gdGhpcy5fX2NhY2hlZEltZ09iaiA9IG51bGw7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZWRJbWdPYmoucGVuZGluZy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwZW5kaW5nV3JhcCA9IGNhY2hlZEltZ09iai5wZW5kaW5nW2ldO1xuICAgIHZhciBjYiA9IHBlbmRpbmdXcmFwLmNiO1xuICAgIGNiICYmIGNiKHRoaXMsIHBlbmRpbmdXcmFwLmNiUGF5bG9hZCk7XG4gICAgcGVuZGluZ1dyYXAuaG9zdEVsLmRpcnR5KCk7XG4gIH1cblxuICBjYWNoZWRJbWdPYmoucGVuZGluZy5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBpc0ltYWdlUmVhZHkoaW1hZ2UpIHtcbiAgcmV0dXJuIGltYWdlICYmIGltYWdlLndpZHRoICYmIGltYWdlLmhlaWdodDtcbn1cblxuZXhwb3J0cy5maW5kRXhpc3RJbWFnZSA9IGZpbmRFeGlzdEltYWdlO1xuZXhwb3J0cy5jcmVhdGVPclVwZGF0ZUltYWdlID0gY3JlYXRlT3JVcGRhdGVJbWFnZTtcbmV4cG9ydHMuaXNJbWFnZVJlYWR5ID0gaXNJbWFnZVJlYWR5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9pbWFnZS5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gYnVpbGRQYXRoKGN0eCwgc2hhcGUpIHtcbiAgdmFyIHggPSBzaGFwZS54O1xuICB2YXIgeSA9IHNoYXBlLnk7XG4gIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xuICB2YXIgciA9IHNoYXBlLnI7XG4gIHZhciByMTtcbiAgdmFyIHIyO1xuICB2YXIgcjM7XG4gIHZhciByNDsgLy8gQ29udmVydCB3aWR0aCBhbmQgaGVpZ2h0IHRvIHBvc2l0aXZlIGZvciBiZXR0ZXIgYm9yZGVyUmFkaXVzXG5cbiAgaWYgKHdpZHRoIDwgMCkge1xuICAgIHggPSB4ICsgd2lkdGg7XG4gICAgd2lkdGggPSAtd2lkdGg7XG4gIH1cblxuICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgIHkgPSB5ICsgaGVpZ2h0O1xuICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gIH1cblxuICBpZiAodHlwZW9mIHIgPT09ICdudW1iZXInKSB7XG4gICAgcjEgPSByMiA9IHIzID0gcjQgPSByO1xuICB9IGVsc2UgaWYgKHIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGlmIChyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcjEgPSByMiA9IHIzID0gcjQgPSByWzBdO1xuICAgIH0gZWxzZSBpZiAoci5sZW5ndGggPT09IDIpIHtcbiAgICAgIHIxID0gcjMgPSByWzBdO1xuICAgICAgcjIgPSByNCA9IHJbMV07XG4gICAgfSBlbHNlIGlmIChyLmxlbmd0aCA9PT0gMykge1xuICAgICAgcjEgPSByWzBdO1xuICAgICAgcjIgPSByNCA9IHJbMV07XG4gICAgICByMyA9IHJbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHIxID0gclswXTtcbiAgICAgIHIyID0gclsxXTtcbiAgICAgIHIzID0gclsyXTtcbiAgICAgIHI0ID0gclszXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcjEgPSByMiA9IHIzID0gcjQgPSAwO1xuICB9XG5cbiAgdmFyIHRvdGFsO1xuXG4gIGlmIChyMSArIHIyID4gd2lkdGgpIHtcbiAgICB0b3RhbCA9IHIxICsgcjI7XG4gICAgcjEgKj0gd2lkdGggLyB0b3RhbDtcbiAgICByMiAqPSB3aWR0aCAvIHRvdGFsO1xuICB9XG5cbiAgaWYgKHIzICsgcjQgPiB3aWR0aCkge1xuICAgIHRvdGFsID0gcjMgKyByNDtcbiAgICByMyAqPSB3aWR0aCAvIHRvdGFsO1xuICAgIHI0ICo9IHdpZHRoIC8gdG90YWw7XG4gIH1cblxuICBpZiAocjIgKyByMyA+IGhlaWdodCkge1xuICAgIHRvdGFsID0gcjIgKyByMztcbiAgICByMiAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgICByMyAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgfVxuXG4gIGlmIChyMSArIHI0ID4gaGVpZ2h0KSB7XG4gICAgdG90YWwgPSByMSArIHI0O1xuICAgIHIxICo9IGhlaWdodCAvIHRvdGFsO1xuICAgIHI0ICo9IGhlaWdodCAvIHRvdGFsO1xuICB9XG5cbiAgY3R4Lm1vdmVUbyh4ICsgcjEsIHkpO1xuICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHIyLCB5KTtcbiAgcjIgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByMik7XG4gIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcjMpO1xuICByMyAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHIzLCB5ICsgaGVpZ2h0KTtcbiAgY3R4LmxpbmVUbyh4ICsgcjQsIHkgKyBoZWlnaHQpO1xuICByNCAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcjQpO1xuICBjdHgubGluZVRvKHgsIHkgKyByMSk7XG4gIHIxICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByMSwgeSk7XG59XG5cbmV4cG9ydHMuYnVpbGRQYXRoID0gYnVpbGRQYXRoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9yb3VuZFJlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjdXJ2ZSA9IHJlcXVpcmUoXCIuL2N1cnZlXCIpO1xuXG52YXIgdmVjMiA9IHJlcXVpcmUoXCIuL3ZlY3RvclwiKTtcblxudmFyIGJib3ggPSByZXF1aXJlKFwiLi9iYm94XCIpO1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4vQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi9jb25maWdcIik7XG5cbnZhciBkcHIgPSBfY29uZmlnLmRldmljZVBpeGVsUmF0aW87XG5cbi8qKlxuICogUGF0aCDku6PnkIbvvIzlj6/ku6XlnKhgYnVpbGRQYXRoYOS4reeUqOS6juabv+S7o2BjdHhgLCDkvJrkv53lrZjmr4/kuKpwYXRo5pON5L2c55qE5ZG95Luk5YiwcGF0aENvbW1hbmRz5bGe5oCn5LitXG4gKiDlj6/ku6XnlKjkuo4gaXNJbnNpZGVQYXRoIOWIpOaWreS7peWPiuiOt+WPlmJvdW5kaW5nUmVjdFxuICpcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL1BhdGhQcm94eVxuICogQGF1dGhvciBZaSBTaGVuIChodHRwOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuLy8gVE9ETyBnZXRUb3RhbExlbmd0aCwgZ2V0UG9pbnRBdExlbmd0aFxudmFyIENNRCA9IHtcbiAgTTogMSxcbiAgTDogMixcbiAgQzogMyxcbiAgUTogNCxcbiAgQTogNSxcbiAgWjogNixcbiAgLy8gUmVjdFxuICBSOiA3XG59OyAvLyB2YXIgQ01EX01FTV9TSVpFID0ge1xuLy8gICAgIE06IDMsXG4vLyAgICAgTDogMyxcbi8vICAgICBDOiA3LFxuLy8gICAgIFE6IDUsXG4vLyAgICAgQTogOSxcbi8vICAgICBSOiA1LFxuLy8gICAgIFo6IDFcbi8vIH07XG5cbnZhciBtaW4gPSBbXTtcbnZhciBtYXggPSBbXTtcbnZhciBtaW4yID0gW107XG52YXIgbWF4MiA9IFtdO1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG52YXIgbWF0aENvcyA9IE1hdGguY29zO1xudmFyIG1hdGhTaW4gPSBNYXRoLnNpbjtcbnZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbnZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG52YXIgaGFzVHlwZWRBcnJheSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT0gJ3VuZGVmaW5lZCc7XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxudmFyIFBhdGhQcm94eSA9IGZ1bmN0aW9uIChub3RTYXZlRGF0YSkge1xuICB0aGlzLl9zYXZlRGF0YSA9ICEobm90U2F2ZURhdGEgfHwgZmFsc2UpO1xuXG4gIGlmICh0aGlzLl9zYXZlRGF0YSkge1xuICAgIC8qKlxuICAgICAqIFBhdGggZGF0YS4gU3RvcmVkIGFzIGZsYXQgYXJyYXlcbiAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAgICovXG4gICAgdGhpcy5kYXRhID0gW107XG4gIH1cblxuICB0aGlzLl9jdHggPSBudWxsO1xufTtcbi8qKlxuICog5b+r6YCf6K6h566XUGF0aOWMheWbtOebku+8iOW5tuS4jeaYr+acgOWwj+WMheWbtOebku+8iVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cblxuUGF0aFByb3h5LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFBhdGhQcm94eSxcbiAgX3hpOiAwLFxuICBfeWk6IDAsXG4gIF94MDogMCxcbiAgX3kwOiAwLFxuICAvLyBVbml0IHgsIFVuaXQgeS4gUHJvdmlkZSBmb3IgYXZvaWRpbmcgZHJhd2luZyB0aGF0IHRvbyBzaG9ydCBsaW5lIHNlZ21lbnRcbiAgX3V4OiAwLFxuICBfdXk6IDAsXG4gIF9sZW46IDAsXG4gIF9saW5lRGFzaDogbnVsbCxcbiAgX2Rhc2hPZmZzZXQ6IDAsXG4gIF9kYXNoSWR4OiAwLFxuICBfZGFzaFN1bTogMCxcblxuICAvKipcbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICBzZXRTY2FsZTogZnVuY3Rpb24gKHN4LCBzeSkge1xuICAgIHRoaXMuX3V4ID0gbWF0aEFicygxIC8gZHByIC8gc3gpIHx8IDA7XG4gICAgdGhpcy5fdXkgPSBtYXRoQWJzKDEgLyBkcHIgLyBzeSkgfHwgMDtcbiAgfSxcbiAgZ2V0Q29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jdHg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgYmVnaW5QYXRoOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgdGhpcy5fY3R4ID0gY3R4O1xuICAgIGN0eCAmJiBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4ICYmICh0aGlzLmRwciA9IGN0eC5kcHIpOyAvLyBSZXNldFxuXG4gICAgaWYgKHRoaXMuX3NhdmVEYXRhKSB7XG4gICAgICB0aGlzLl9sZW4gPSAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9saW5lRGFzaCkge1xuICAgICAgdGhpcy5fbGluZURhc2ggPSBudWxsO1xuICAgICAgdGhpcy5fZGFzaE9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBtb3ZlVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdGhpcy5hZGREYXRhKENNRC5NLCB4LCB5KTtcbiAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4Lm1vdmVUbyh4LCB5KTsgLy8geDAsIHkwLCB4aSwgeWkg5piv6K6w5b2V5ZyoIF9kYXNoZWRYWFhYVG8g5pa55rOV5Lit5L2/55SoXG4gICAgLy8geGksIHlpIOiusOW9leW9k+WJjeeCuSwgeDAsIHkwIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5Zue5Yiw6LW35aeL54K544CCXG4gICAgLy8g5pyJ5Y+v6IO95ZyoIGJlZ2luUGF0aCDkuYvlkI7nm7TmjqXosIPnlKggbGluZVRv77yM6L+Z5pe25YCZIHgwLCB5MCDpnIDopoFcbiAgICAvLyDlnKggbGluZVRvIOaWueazleS4reiusOW9le+8jOi/memHjOWFiOS4jeiAg+iZkei/meenjeaDheWGte+8jGRhc2hlZCBsaW5lIOS5n+WPquWcqCBJRTEwLSDkuK3kuI3mlK/mjIFcblxuICAgIHRoaXMuX3gwID0geDtcbiAgICB0aGlzLl95MCA9IHk7XG4gICAgdGhpcy5feGkgPSB4O1xuICAgIHRoaXMuX3lpID0geTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGxpbmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgZXhjZWVkVW5pdCA9IG1hdGhBYnMoeCAtIHRoaXMuX3hpKSA+IHRoaXMuX3V4IHx8IG1hdGhBYnMoeSAtIHRoaXMuX3lpKSA+IHRoaXMuX3V5IC8vIEZvcmNlIGRyYXcgdGhlIGZpcnN0IHNlZ21lbnRcbiAgICB8fCB0aGlzLl9sZW4gPCA1O1xuICAgIHRoaXMuYWRkRGF0YShDTUQuTCwgeCwgeSk7XG5cbiAgICBpZiAodGhpcy5fY3R4ICYmIGV4Y2VlZFVuaXQpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkTGluZVRvKHgsIHkpIDogdGhpcy5fY3R4LmxpbmVUbyh4LCB5KTtcbiAgICB9XG5cbiAgICBpZiAoZXhjZWVkVW5pdCkge1xuICAgICAgdGhpcy5feGkgPSB4O1xuICAgICAgdGhpcy5feWkgPSB5O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxXG4gICAqIEBwYXJhbSAge251bWJlcn0geTFcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyXG4gICAqIEBwYXJhbSAge251bWJlcn0geDNcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5M1xuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGJlemllckN1cnZlVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgdGhpcy5hZGREYXRhKENNRC5DLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcblxuICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkQmV6aWVyVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MykgOiB0aGlzLl9jdHguYmV6aWVyQ3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICB9XG5cbiAgICB0aGlzLl94aSA9IHgzO1xuICAgIHRoaXMuX3lpID0geTM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0geDFcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyXG4gICAqIEBwYXJhbSAge251bWJlcn0geTJcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB0aGlzLmFkZERhdGEoQ01ELlEsIHgxLCB5MSwgeDIsIHkyKTtcblxuICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkUXVhZHJhdGljVG8oeDEsIHkxLCB4MiwgeTIpIDogdGhpcy5fY3R4LnF1YWRyYXRpY0N1cnZlVG8oeDEsIHkxLCB4MiwgeTIpO1xuICAgIH1cblxuICAgIHRoaXMuX3hpID0geDI7XG4gICAgdGhpcy5feWkgPSB5MjtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7bnVtYmVyfSBjeFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGN5XG4gICAqIEBwYXJhbSAge251bWJlcn0gclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHN0YXJ0QW5nbGVcbiAgICogQHBhcmFtICB7bnVtYmVyfSBlbmRBbmdsZVxuICAgKiBAcGFyYW0gIHtib29sZWFufSBhbnRpY2xvY2t3aXNlXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgYXJjOiBmdW5jdGlvbiAoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuICAgIHRoaXMuYWRkRGF0YShDTUQuQSwgY3gsIGN5LCByLCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUsIDAsIGFudGljbG9ja3dpc2UgPyAwIDogMSk7XG4gICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5hcmMoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSk7XG4gICAgdGhpcy5feGkgPSBtYXRoQ29zKGVuZEFuZ2xlKSAqIHIgKyBjeDtcbiAgICB0aGlzLl95aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogciArIGN4O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBUT0RPXG4gIGFyY1RvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgIHRoaXMuX2N0eC5hcmNUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gVE9ET1xuICByZWN0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuICAgIHRoaXMuX2N0eCAmJiB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICB0aGlzLmFkZERhdGEoQ01ELlIsIHgsIHksIHcsIGgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGNsb3NlUGF0aDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWRkRGF0YShDTUQuWik7XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICB2YXIgeDAgPSB0aGlzLl94MDtcbiAgICB2YXIgeTAgPSB0aGlzLl95MDtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpICYmIHRoaXMuX2Rhc2hlZExpbmVUbyh4MCwgeTApO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3hpID0geDA7XG4gICAgdGhpcy5feWkgPSB5MDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQ29udGV4dCDku47lpJbpg6jkvKDlhaXvvIzlm6DkuLrmnInlj6/og73mmK8gcmVidWlsZFBhdGgg5a6M5LmL5ZCO5YaNIGZpbGzjgIJcbiAgICogc3Ryb2tlIOWQjOagt1xuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgZmlsbDogZnVuY3Rpb24gKGN0eCkge1xuICAgIGN0eCAmJiBjdHguZmlsbCgpO1xuICAgIHRoaXMudG9TdGF0aWMoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIHN0cm9rZTogZnVuY3Rpb24gKGN0eCkge1xuICAgIGN0eCAmJiBjdHguc3Ryb2tlKCk7XG4gICAgdGhpcy50b1N0YXRpYygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlv4XpobvlnKjlhbblroPnu5jliLblkb3ku6TliY3osIPnlKhcbiAgICogTXVzdCBiZSBpbnZva2VkIGJlZm9yZSBhbGwgb3RoZXIgcGF0aCBkcmF3aW5nIG1ldGhvZHNcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBzZXRMaW5lRGFzaDogZnVuY3Rpb24gKGxpbmVEYXNoKSB7XG4gICAgaWYgKGxpbmVEYXNoIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHRoaXMuX2xpbmVEYXNoID0gbGluZURhc2g7XG4gICAgICB0aGlzLl9kYXNoSWR4ID0gMDtcbiAgICAgIHZhciBsaW5lRGFzaFN1bSA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZURhc2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGluZURhc2hTdW0gKz0gbGluZURhc2hbaV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Rhc2hTdW0gPSBsaW5lRGFzaFN1bTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5b+F6aG75Zyo5YW25a6D57uY5Yi25ZG95Luk5YmN6LCD55SoXG4gICAqIE11c3QgYmUgaW52b2tlZCBiZWZvcmUgYWxsIG90aGVyIHBhdGggZHJhd2luZyBtZXRob2RzXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgc2V0TGluZURhc2hPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbjtcbiAgfSxcblxuICAvKipcbiAgICog55u05o6l6K6+572uIFBhdGgg5pWw5o2uXG4gICAqL1xuICBzZXREYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBsZW4gPSBkYXRhLmxlbmd0aDtcblxuICAgIGlmICghKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEubGVuZ3RoID09IGxlbikgJiYgaGFzVHlwZWRBcnJheSkge1xuICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShsZW4pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRoaXMuZGF0YVtpXSA9IGRhdGFbaV07XG4gICAgfVxuXG4gICAgdGhpcy5fbGVuID0gbGVuO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqDlrZDot6/lvoRcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eXxBcnJheS48bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHk+fSBwYXRoXG4gICAqL1xuICBhcHBlbmRQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmICghKHBhdGggaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIHBhdGggPSBbcGF0aF07XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IHBhdGgubGVuZ3RoO1xuICAgIHZhciBhcHBlbmRTaXplID0gMDtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fbGVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXBwZW5kU2l6ZSArPSBwYXRoW2ldLmxlbigpO1xuICAgIH1cblxuICAgIGlmIChoYXNUeXBlZEFycmF5ICYmIHRoaXMuZGF0YSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xuICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShvZmZzZXQgKyBhcHBlbmRTaXplKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgYXBwZW5kUGF0aERhdGEgPSBwYXRoW2ldLmRhdGE7XG5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYXBwZW5kUGF0aERhdGEubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdGhpcy5kYXRhW29mZnNldCsrXSA9IGFwcGVuZFBhdGhEYXRhW2tdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2xlbiA9IG9mZnNldDtcbiAgfSxcblxuICAvKipcbiAgICog5aGr5YWFIFBhdGgg5pWw5o2u44CCXG4gICAqIOWwvemHj+WkjeeUqOiAjOS4jeeUs+aYjuaWsOeahOaVsOe7hOOAguWkp+mDqOWIhuWbvuW9oumHjee7mOeahOaMh+S7pOaVsOaNrumVv+W6pumDveaYr+S4jeWPmOeahOOAglxuICAgKi9cbiAgYWRkRGF0YTogZnVuY3Rpb24gKGNtZCkge1xuICAgIGlmICghdGhpcy5fc2F2ZURhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcblxuICAgIGlmICh0aGlzLl9sZW4gKyBhcmd1bWVudHMubGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vIOWboOS4uuS5i+WJjeeahOaVsOe7hOW3sue7j+i9rOaNouaIkOmdmeaAgeeahCBGbG9hdDMyQXJyYXlcbiAgICAgIC8vIOaJgOS7peS4jeWkn+eUqOaXtumcgOimgeaJqeWxleS4gOS4quaWsOeahOWKqOaAgeaVsOe7hFxuICAgICAgdGhpcy5fZXhwYW5kRGF0YSgpO1xuXG4gICAgICBkYXRhID0gdGhpcy5kYXRhO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhW3RoaXMuX2xlbisrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcmV2Q21kID0gY21kO1xuICB9LFxuICBfZXhwYW5kRGF0YTogZnVuY3Rpb24gKCkge1xuICAgIC8vIE9ubHkgaWYgZGF0YSBpcyBGbG9hdDMyQXJyYXlcbiAgICBpZiAoISh0aGlzLmRhdGEgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIHZhciBuZXdEYXRhID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGVuOyBpKyspIHtcbiAgICAgICAgbmV3RGF0YVtpXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kYXRhID0gbmV3RGF0YTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIG5lZWRzIGpzIGltcGxlbWVudGVkIGRhc2hlZCBsaW5lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbmVlZHNEYXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpbmVEYXNoO1xuICB9LFxuICBfZGFzaGVkTGluZVRvOiBmdW5jdGlvbiAoeDEsIHkxKSB7XG4gICAgdmFyIGRhc2hTdW0gPSB0aGlzLl9kYXNoU3VtO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLl9kYXNoT2Zmc2V0O1xuICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuX2xpbmVEYXNoO1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgdmFyIHgwID0gdGhpcy5feGk7XG4gICAgdmFyIHkwID0gdGhpcy5feWk7XG4gICAgdmFyIGR4ID0geDEgLSB4MDtcbiAgICB2YXIgZHkgPSB5MSAtIHkwO1xuICAgIHZhciBkaXN0ID0gbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIHZhciB4ID0geDA7XG4gICAgdmFyIHkgPSB5MDtcbiAgICB2YXIgZGFzaDtcbiAgICB2YXIgbkRhc2ggPSBsaW5lRGFzaC5sZW5ndGg7XG4gICAgdmFyIGlkeDtcbiAgICBkeCAvPSBkaXN0O1xuICAgIGR5IC89IGRpc3Q7XG5cbiAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgLy8gQ29udmVydCB0byBwb3NpdGl2ZSBvZmZzZXRcbiAgICAgIG9mZnNldCA9IGRhc2hTdW0gKyBvZmZzZXQ7XG4gICAgfVxuXG4gICAgb2Zmc2V0ICU9IGRhc2hTdW07XG4gICAgeCAtPSBvZmZzZXQgKiBkeDtcbiAgICB5IC09IG9mZnNldCAqIGR5O1xuXG4gICAgd2hpbGUgKGR4ID4gMCAmJiB4IDw9IHgxIHx8IGR4IDwgMCAmJiB4ID49IHgxIHx8IGR4ID09IDAgJiYgKGR5ID4gMCAmJiB5IDw9IHkxIHx8IGR5IDwgMCAmJiB5ID49IHkxKSkge1xuICAgICAgaWR4ID0gdGhpcy5fZGFzaElkeDtcbiAgICAgIGRhc2ggPSBsaW5lRGFzaFtpZHhdO1xuICAgICAgeCArPSBkeCAqIGRhc2g7XG4gICAgICB5ICs9IGR5ICogZGFzaDtcbiAgICAgIHRoaXMuX2Rhc2hJZHggPSAoaWR4ICsgMSkgJSBuRGFzaDsgLy8gU2tpcCBwb3NpdGl2ZSBvZmZzZXRcblxuICAgICAgaWYgKGR4ID4gMCAmJiB4IDwgeDAgfHwgZHggPCAwICYmIHggPiB4MCB8fCBkeSA+IDAgJiYgeSA8IHkwIHx8IGR5IDwgMCAmJiB5ID4geTApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGN0eFtpZHggJSAyID8gJ21vdmVUbycgOiAnbGluZVRvJ10oZHggPj0gMCA/IG1hdGhNaW4oeCwgeDEpIDogbWF0aE1heCh4LCB4MSksIGR5ID49IDAgPyBtYXRoTWluKHksIHkxKSA6IG1hdGhNYXgoeSwgeTEpKTtcbiAgICB9IC8vIE9mZnNldCBmb3IgbmV4dCBsaW5lVG9cblxuXG4gICAgZHggPSB4IC0geDE7XG4gICAgZHkgPSB5IC0geTE7XG4gICAgdGhpcy5fZGFzaE9mZnNldCA9IC1tYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIH0sXG4gIC8vIE5vdCBhY2N1cmF0ZSBkYXNoZWQgbGluZSB0b1xuICBfZGFzaGVkQmV6aWVyVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgdmFyIGRhc2hTdW0gPSB0aGlzLl9kYXNoU3VtO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLl9kYXNoT2Zmc2V0O1xuICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuX2xpbmVEYXNoO1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgdmFyIHgwID0gdGhpcy5feGk7XG4gICAgdmFyIHkwID0gdGhpcy5feWk7XG4gICAgdmFyIHQ7XG4gICAgdmFyIGR4O1xuICAgIHZhciBkeTtcbiAgICB2YXIgY3ViaWNBdCA9IGN1cnZlLmN1YmljQXQ7XG4gICAgdmFyIGJlemllckxlbiA9IDA7XG4gICAgdmFyIGlkeCA9IHRoaXMuX2Rhc2hJZHg7XG4gICAgdmFyIG5EYXNoID0gbGluZURhc2gubGVuZ3RoO1xuICAgIHZhciB4O1xuICAgIHZhciB5O1xuICAgIHZhciB0bXBMZW4gPSAwO1xuXG4gICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgIC8vIENvbnZlcnQgdG8gcG9zaXRpdmUgb2Zmc2V0XG4gICAgICBvZmZzZXQgPSBkYXNoU3VtICsgb2Zmc2V0O1xuICAgIH1cblxuICAgIG9mZnNldCAlPSBkYXNoU3VtOyAvLyBCZXppZXIgYXBwcm94IGxlbmd0aFxuXG4gICAgZm9yICh0ID0gMDsgdCA8IDE7IHQgKz0gMC4xKSB7XG4gICAgICBkeCA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQgKyAwLjEpIC0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICBkeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQgKyAwLjEpIC0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCk7XG4gICAgICBiZXppZXJMZW4gKz0gbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH0gLy8gRmluZCBpZHggYWZ0ZXIgYWRkIG9mZnNldFxuXG5cbiAgICBmb3IgKDsgaWR4IDwgbkRhc2g7IGlkeCsrKSB7XG4gICAgICB0bXBMZW4gKz0gbGluZURhc2hbaWR4XTtcblxuICAgICAgaWYgKHRtcExlbiA+IG9mZnNldCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0ID0gKHRtcExlbiAtIG9mZnNldCkgLyBiZXppZXJMZW47XG5cbiAgICB3aGlsZSAodCA8PSAxKSB7XG4gICAgICB4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICB5ID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCk7IC8vIFVzZSBsaW5lIHRvIGFwcHJveGltYXRlIGRhc2hlZCBiZXppZXJcbiAgICAgIC8vIEJhZCByZXN1bHQgaWYgZGFzaCBpcyBsb25nXG5cbiAgICAgIGlkeCAlIDIgPyBjdHgubW92ZVRvKHgsIHkpIDogY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIHQgKz0gbGluZURhc2hbaWR4XSAvIGJlemllckxlbjtcbiAgICAgIGlkeCA9IChpZHggKyAxKSAlIG5EYXNoO1xuICAgIH0gLy8gRmluaXNoIHRoZSBsYXN0IHNlZ21lbnQgYW5kIGNhbGN1bGF0ZSB0aGUgbmV3IG9mZnNldFxuXG5cbiAgICBpZHggJSAyICE9PSAwICYmIGN0eC5saW5lVG8oeDMsIHkzKTtcbiAgICBkeCA9IHgzIC0geDtcbiAgICBkeSA9IHkzIC0geTtcbiAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gLW1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgfSxcbiAgX2Rhc2hlZFF1YWRyYXRpY1RvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAvLyBDb252ZXJ0IHF1YWRyYXRpYyB0byBjdWJpYyB1c2luZyBkZWdyZWUgZWxldmF0aW9uXG4gICAgdmFyIHgzID0geDI7XG4gICAgdmFyIHkzID0geTI7XG4gICAgeDIgPSAoeDIgKyAyICogeDEpIC8gMztcbiAgICB5MiA9ICh5MiArIDIgKiB5MSkgLyAzO1xuICAgIHgxID0gKHRoaXMuX3hpICsgMiAqIHgxKSAvIDM7XG4gICAgeTEgPSAodGhpcy5feWkgKyAyICogeTEpIC8gMztcblxuICAgIHRoaXMuX2Rhc2hlZEJlemllclRvKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDovazmiJDpnZnmgIHnmoQgRmxvYXQzMkFycmF5IOWHj+WwkeWghuWGheWtmOWNoOeUqFxuICAgKiBDb252ZXJ0IGR5bmFtaWMgYXJyYXkgdG8gc3RhdGljIEZsb2F0MzJBcnJheVxuICAgKi9cbiAgdG9TdGF0aWM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcblxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGRhdGEubGVuZ3RoID0gdGhpcy5fbGVuO1xuXG4gICAgICBpZiAoaGFzVHlwZWRBcnJheSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAqL1xuICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICBtaW5bMF0gPSBtaW5bMV0gPSBtaW4yWzBdID0gbWluMlsxXSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgbWF4WzBdID0gbWF4WzFdID0gbWF4MlswXSA9IG1heDJbMV0gPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgeGkgPSAwO1xuICAgIHZhciB5aSA9IDA7XG4gICAgdmFyIHgwID0gMDtcbiAgICB2YXIgeTAgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICAgIHZhciBjbWQgPSBkYXRhW2krK107XG5cbiAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgICAgLy8g5YiZIHByZXZpb3VzIHBvaW50IOWQjOe7mOWItuWRveS7pOeahOesrOS4gOS4qiBwb2ludFxuICAgICAgICAvL1xuICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgICB4aSA9IGRhdGFbaV07XG4gICAgICAgIHlpID0gZGF0YVtpICsgMV07XG4gICAgICAgIHgwID0geGk7XG4gICAgICAgIHkwID0geWk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgLy8gbW92ZVRvIOWRveS7pOmHjeaWsOWIm+W7uuS4gOS4quaWsOeahCBzdWJwYXRoLCDlubbkuJTmm7TmlrDmlrDnmoTotbfngrlcbiAgICAgICAgICAvLyDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeS9v+eUqFxuICAgICAgICAgIHgwID0gZGF0YVtpKytdO1xuICAgICAgICAgIHkwID0gZGF0YVtpKytdO1xuICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICBtaW4yWzBdID0geDA7XG4gICAgICAgICAgbWluMlsxXSA9IHkwO1xuICAgICAgICAgIG1heDJbMF0gPSB4MDtcbiAgICAgICAgICBtYXgyWzFdID0geTA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgICBiYm94LmZyb21MaW5lKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIG1pbjIsIG1heDIpO1xuICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgYmJveC5mcm9tQ3ViaWMoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgIGJib3guZnJvbVF1YWRyYXRpYyh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICAvLyBUT0RPIEFyYyDliKTmlq3nmoTlvIDplIDmr5TovoPlpKdcbiAgICAgICAgICB2YXIgY3ggPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciByeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgcnkgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIGVuZEFuZ2xlID0gZGF0YVtpKytdICsgc3RhcnRBbmdsZTsgLy8gVE9ETyBBcmMg5peL6L2sXG5cbiAgICAgICAgICB2YXIgcHNpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciBhbnRpY2xvY2t3aXNlID0gMSAtIGRhdGFbaSsrXTtcblxuICAgICAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgIC8vIOebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG4gICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICAgIHgwID0gbWF0aENvcyhzdGFydEFuZ2xlKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICB5MCA9IG1hdGhTaW4oc3RhcnRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJib3guZnJvbUFyYyhjeCwgY3ksIHJ4LCByeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIG1pbjIsIG1heDIpO1xuICAgICAgICAgIHhpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgIHlpID0gbWF0aFNpbihlbmRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgeDAgPSB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5MCA9IHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciB3aWR0aCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgaGVpZ2h0ID0gZGF0YVtpKytdOyAvLyBVc2UgZnJvbUxpbmVcblxuICAgICAgICAgIGJib3guZnJvbUxpbmUoeDAsIHkwLCB4MCArIHdpZHRoLCB5MCArIGhlaWdodCwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIFVuaW9uXG5cblxuICAgICAgdmVjMi5taW4obWluLCBtaW4sIG1pbjIpO1xuICAgICAgdmVjMi5tYXgobWF4LCBtYXgsIG1heDIpO1xuICAgIH0gLy8gTm8gZGF0YVxuXG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgbWluWzBdID0gbWluWzFdID0gbWF4WzBdID0gbWF4WzFdID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdChtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWJ1aWxkIHBhdGggZnJvbSBjdXJyZW50IGRhdGFcbiAgICogUmVidWlsZCBwYXRoIHdpbGwgbm90IGNvbnNpZGVyIGphdmFzY3JpcHQgaW1wbGVtZW50ZWQgbGluZSBkYXNoLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqL1xuICByZWJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciBkID0gdGhpcy5kYXRhO1xuICAgIHZhciB4MCwgeTA7XG4gICAgdmFyIHhpLCB5aTtcbiAgICB2YXIgeCwgeTtcbiAgICB2YXIgdXggPSB0aGlzLl91eDtcbiAgICB2YXIgdXkgPSB0aGlzLl91eTtcbiAgICB2YXIgbGVuID0gdGhpcy5fbGVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICB2YXIgY21kID0gZFtpKytdO1xuXG4gICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgIC8vIOWmguaenOesrOS4gOS4quWRveS7pOaYryBMLCBDLCBRXG4gICAgICAgIC8vIOWImSBwcmV2aW91cyBwb2ludCDlkIznu5jliLblkb3ku6TnmoTnrKzkuIDkuKogcG9pbnRcbiAgICAgICAgLy9cbiAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk5Li6IEFyYyDnmoTmg4XlhrXkuIvkvJrlnKjlkI7pnaLnibnmrorlpITnkIZcbiAgICAgICAgeGkgPSBkW2ldO1xuICAgICAgICB5aSA9IGRbaSArIDFdO1xuICAgICAgICB4MCA9IHhpO1xuICAgICAgICB5MCA9IHlpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICBjYXNlIENNRC5NOlxuICAgICAgICAgIHgwID0geGkgPSBkW2krK107XG4gICAgICAgICAgeTAgPSB5aSA9IGRbaSsrXTtcbiAgICAgICAgICBjdHgubW92ZVRvKHhpLCB5aSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgICB4ID0gZFtpKytdO1xuICAgICAgICAgIHkgPSBkW2krK107IC8vIE5vdCBkcmF3IHRvbyBzbWFsbCBzZWcgYmV0d2VlblxuXG4gICAgICAgICAgaWYgKG1hdGhBYnMoeCAtIHhpKSA+IHV4IHx8IG1hdGhBYnMoeSAtIHlpKSA+IHV5IHx8IGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICB4aSA9IHg7XG4gICAgICAgICAgICB5aSA9IHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuQzpcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICB4aSA9IGRbaSAtIDJdO1xuICAgICAgICAgIHlpID0gZFtpIC0gMV07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10pO1xuICAgICAgICAgIHhpID0gZFtpIC0gMl07XG4gICAgICAgICAgeWkgPSBkW2kgLSAxXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5BOlxuICAgICAgICAgIHZhciBjeCA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgY3kgPSBkW2krK107XG4gICAgICAgICAgdmFyIHJ4ID0gZFtpKytdO1xuICAgICAgICAgIHZhciByeSA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgdGhldGEgPSBkW2krK107XG4gICAgICAgICAgdmFyIGRUaGV0YSA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgcHNpID0gZFtpKytdO1xuICAgICAgICAgIHZhciBmcyA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgciA9IHJ4ID4gcnkgPyByeCA6IHJ5O1xuICAgICAgICAgIHZhciBzY2FsZVggPSByeCA+IHJ5ID8gMSA6IHJ4IC8gcnk7XG4gICAgICAgICAgdmFyIHNjYWxlWSA9IHJ4ID4gcnkgPyByeSAvIHJ4IDogMTtcbiAgICAgICAgICB2YXIgaXNFbGxpcHNlID0gTWF0aC5hYnMocnggLSByeSkgPiAxZS0zO1xuICAgICAgICAgIHZhciBlbmRBbmdsZSA9IHRoZXRhICsgZFRoZXRhO1xuXG4gICAgICAgICAgaWYgKGlzRWxsaXBzZSkge1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjeCwgY3kpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShwc2kpO1xuICAgICAgICAgICAgY3R4LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgICAgIGN0eC5hcmMoMCwgMCwgciwgdGhldGEsIGVuZEFuZ2xlLCAxIC0gZnMpO1xuICAgICAgICAgICAgY3R4LnNjYWxlKDEgLyBzY2FsZVgsIDEgLyBzY2FsZVkpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZSgtcHNpKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLWN4LCAtY3kpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguYXJjKGN4LCBjeSwgciwgdGhldGEsIGVuZEFuZ2xlLCAxIC0gZnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgIC8vIOebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG4gICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICAgIHgwID0gbWF0aENvcyh0aGV0YSkgKiByeCArIGN4O1xuICAgICAgICAgICAgeTAgPSBtYXRoU2luKHRoZXRhKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeGkgPSBtYXRoQ29zKGVuZEFuZ2xlKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgeWkgPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICB4MCA9IHhpID0gZFtpXTtcbiAgICAgICAgICB5MCA9IHlpID0gZFtpICsgMV07XG4gICAgICAgICAgY3R4LnJlY3QoZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5aOlxuICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgIHlpID0geTA7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuUGF0aFByb3h5LkNNRCA9IENNRDtcbnZhciBfZGVmYXVsdCA9IFBhdGhQcm94eTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvUGF0aFByb3h5LmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuL3ZlY3RvclwiKTtcblxudmFyIHYyQ3JlYXRlID0gX3ZlY3Rvci5jcmVhdGU7XG52YXIgdjJEaXN0U3F1YXJlID0gX3ZlY3Rvci5kaXN0U3F1YXJlO1xuXG4vKipcbiAqIOabsue6v+i+heWKqeaooeWdl1xuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbnZhciBtYXRoUG93ID0gTWF0aC5wb3c7XG52YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgRVBTSUxPTiA9IDFlLTg7XG52YXIgRVBTSUxPTl9OVU1FUklDID0gMWUtNDtcbnZhciBUSFJFRV9TUVJUID0gbWF0aFNxcnQoMyk7XG52YXIgT05FX1RISVJEID0gMSAvIDM7IC8vIOS4tOaXtuWPmOmHj1xuXG52YXIgX3YwID0gdjJDcmVhdGUoKTtcblxudmFyIF92MSA9IHYyQ3JlYXRlKCk7XG5cbnZhciBfdjIgPSB2MkNyZWF0ZSgpO1xuXG5mdW5jdGlvbiBpc0Fyb3VuZFplcm8odmFsKSB7XG4gIHJldHVybiB2YWwgPiAtRVBTSUxPTiAmJiB2YWwgPCBFUFNJTE9OO1xufVxuXG5mdW5jdGlvbiBpc05vdEFyb3VuZFplcm8odmFsKSB7XG4gIHJldHVybiB2YWwgPiBFUFNJTE9OIHx8IHZhbCA8IC1FUFNJTE9OO1xufVxuLyoqXG4gKiDorqHnrpfkuInmrKHotJ3loZ7lsJTlgLxcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGN1YmljQXQocDAsIHAxLCBwMiwgcDMsIHQpIHtcbiAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgcmV0dXJuIG9uZXQgKiBvbmV0ICogKG9uZXQgKiBwMCArIDMgKiB0ICogcDEpICsgdCAqIHQgKiAodCAqIHAzICsgMyAqIG9uZXQgKiBwMik7XG59XG4vKipcbiAqIOiuoeeul+S4ieasoei0neWhnuWwlOWvvOaVsOWAvFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gY3ViaWNEZXJpdmF0aXZlQXQocDAsIHAxLCBwMiwgcDMsIHQpIHtcbiAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgcmV0dXJuIDMgKiAoKChwMSAtIHAwKSAqIG9uZXQgKyAyICogKHAyIC0gcDEpICogdCkgKiBvbmV0ICsgKHAzIC0gcDIpICogdCAqIHQpO1xufVxuLyoqXG4gKiDorqHnrpfkuInmrKHotJ3loZ7lsJTmlrnnqIvmoLnvvIzkvb/nlKjnm5vph5HlhazlvI9cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHZhbFxuICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IHJvb3RzXG4gKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOagueaVsOebrlxuICovXG5cblxuZnVuY3Rpb24gY3ViaWNSb290QXQocDAsIHAxLCBwMiwgcDMsIHZhbCwgcm9vdHMpIHtcbiAgLy8gRXZhbHVhdGUgcm9vdHMgb2YgY3ViaWMgZnVuY3Rpb25zXG4gIHZhciBhID0gcDMgKyAzICogKHAxIC0gcDIpIC0gcDA7XG4gIHZhciBiID0gMyAqIChwMiAtIHAxICogMiArIHAwKTtcbiAgdmFyIGMgPSAzICogKHAxIC0gcDApO1xuICB2YXIgZCA9IHAwIC0gdmFsO1xuICB2YXIgQSA9IGIgKiBiIC0gMyAqIGEgKiBjO1xuICB2YXIgQiA9IGIgKiBjIC0gOSAqIGEgKiBkO1xuICB2YXIgQyA9IGMgKiBjIC0gMyAqIGIgKiBkO1xuICB2YXIgbiA9IDA7XG5cbiAgaWYgKGlzQXJvdW5kWmVybyhBKSAmJiBpc0Fyb3VuZFplcm8oQikpIHtcbiAgICBpZiAoaXNBcm91bmRaZXJvKGIpKSB7XG4gICAgICByb290c1swXSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0MSA9IC1jIC8gYjsgLy90MSwgdDIsIHQzLCBiIGlzIG5vdCB6ZXJvXG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlzYyA9IEIgKiBCIC0gNCAqIEEgKiBDO1xuXG4gICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgdmFyIEsgPSBCIC8gQTtcbiAgICAgIHZhciB0MSA9IC1iIC8gYSArIEs7IC8vIHQxLCBhIGlzIG5vdCB6ZXJvXG5cbiAgICAgIHZhciB0MiA9IC1LIC8gMjsgLy8gdDIsIHQzXG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgfVxuXG4gICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRpc2MgPiAwKSB7XG4gICAgICB2YXIgZGlzY1NxcnQgPSBtYXRoU3FydChkaXNjKTtcbiAgICAgIHZhciBZMSA9IEEgKiBiICsgMS41ICogYSAqICgtQiArIGRpc2NTcXJ0KTtcbiAgICAgIHZhciBZMiA9IEEgKiBiICsgMS41ICogYSAqICgtQiAtIGRpc2NTcXJ0KTtcblxuICAgICAgaWYgKFkxIDwgMCkge1xuICAgICAgICBZMSA9IC1tYXRoUG93KC1ZMSwgT05FX1RISVJEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFkxID0gbWF0aFBvdyhZMSwgT05FX1RISVJEKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFkyIDwgMCkge1xuICAgICAgICBZMiA9IC1tYXRoUG93KC1ZMiwgT05FX1RISVJEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFkyID0gbWF0aFBvdyhZMiwgT05FX1RISVJEKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHQxID0gKC1iIC0gKFkxICsgWTIpKSAvICgzICogYSk7XG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgVCA9ICgyICogQSAqIGIgLSAzICogYSAqIEIpIC8gKDIgKiBtYXRoU3FydChBICogQSAqIEEpKTtcbiAgICAgIHZhciB0aGV0YSA9IE1hdGguYWNvcyhUKSAvIDM7XG4gICAgICB2YXIgQVNxcnQgPSBtYXRoU3FydChBKTtcbiAgICAgIHZhciB0bXAgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICB2YXIgdDEgPSAoLWIgLSAyICogQVNxcnQgKiB0bXApIC8gKDMgKiBhKTtcbiAgICAgIHZhciB0MiA9ICgtYiArIEFTcXJ0ICogKHRtcCArIFRIUkVFX1NRUlQgKiBNYXRoLnNpbih0aGV0YSkpKSAvICgzICogYSk7XG4gICAgICB2YXIgdDMgPSAoLWIgKyBBU3FydCAqICh0bXAgLSBUSFJFRV9TUVJUICogTWF0aC5zaW4odGhldGEpKSkgLyAoMyAqIGEpO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cblxuICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0MyA+PSAwICYmIHQzIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuO1xufVxuLyoqXG4gKiDorqHnrpfkuInmrKHotJ3loZ7lsJTmlrnnqIvmnoHpmZDlgLznmoTkvY3nva5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gZXh0cmVtYVxuICogQHJldHVybiB7bnVtYmVyfSDmnInmlYjmlbDnm65cbiAqL1xuXG5cbmZ1bmN0aW9uIGN1YmljRXh0cmVtYShwMCwgcDEsIHAyLCBwMywgZXh0cmVtYSkge1xuICB2YXIgYiA9IDYgKiBwMiAtIDEyICogcDEgKyA2ICogcDA7XG4gIHZhciBhID0gOSAqIHAxICsgMyAqIHAzIC0gMyAqIHAwIC0gOSAqIHAyO1xuICB2YXIgYyA9IDMgKiBwMSAtIDMgKiBwMDtcbiAgdmFyIG4gPSAwO1xuXG4gIGlmIChpc0Fyb3VuZFplcm8oYSkpIHtcbiAgICBpZiAoaXNOb3RBcm91bmRaZXJvKGIpKSB7XG4gICAgICB2YXIgdDEgPSAtYyAvIGI7XG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgZXh0cmVtYVtuKytdID0gdDE7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBkaXNjID0gYiAqIGIgLSA0ICogYSAqIGM7XG5cbiAgICBpZiAoaXNBcm91bmRaZXJvKGRpc2MpKSB7XG4gICAgICBleHRyZW1hWzBdID0gLWIgLyAoMiAqIGEpO1xuICAgIH0gZWxzZSBpZiAoZGlzYyA+IDApIHtcbiAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgdmFyIHQxID0gKC1iICsgZGlzY1NxcnQpIC8gKDIgKiBhKTtcbiAgICAgIHZhciB0MiA9ICgtYiAtIGRpc2NTcXJ0KSAvICgyICogYSk7XG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgZXh0cmVtYVtuKytdID0gdDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgZXh0cmVtYVtuKytdID0gdDI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG47XG59XG4vKipcbiAqIOe7huWIhuS4ieasoei0neWhnuWwlOabsue6v1xuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IG91dFxuICovXG5cblxuZnVuY3Rpb24gY3ViaWNTdWJkaXZpZGUocDAsIHAxLCBwMiwgcDMsIHQsIG91dCkge1xuICB2YXIgcDAxID0gKHAxIC0gcDApICogdCArIHAwO1xuICB2YXIgcDEyID0gKHAyIC0gcDEpICogdCArIHAxO1xuICB2YXIgcDIzID0gKHAzIC0gcDIpICogdCArIHAyO1xuICB2YXIgcDAxMiA9IChwMTIgLSBwMDEpICogdCArIHAwMTtcbiAgdmFyIHAxMjMgPSAocDIzIC0gcDEyKSAqIHQgKyBwMTI7XG4gIHZhciBwMDEyMyA9IChwMTIzIC0gcDAxMikgKiB0ICsgcDAxMjsgLy8gU2VnMFxuXG4gIG91dFswXSA9IHAwO1xuICBvdXRbMV0gPSBwMDE7XG4gIG91dFsyXSA9IHAwMTI7XG4gIG91dFszXSA9IHAwMTIzOyAvLyBTZWcxXG5cbiAgb3V0WzRdID0gcDAxMjM7XG4gIG91dFs1XSA9IHAxMjM7XG4gIG91dFs2XSA9IHAyMztcbiAgb3V0WzddID0gcDM7XG59XG4vKipcbiAqIOaKleWwhOeCueWIsOS4ieasoei0neWhnuWwlOabsue6v+S4iu+8jOi/lOWbnuaKleWwhOi3neemu+OAglxuICog5oqV5bCE54K55pyJ5Y+v6IO95Lya5pyJ5LiA5Liq5oiW6ICF5aSa5Liq77yM6L+Z6YeM5Y+q6L+U5Zue5YW25Lit6Led56a75pyA55+t55qE5LiA5Liq44CCXG4gKiBAcGFyYW0ge251bWJlcn0geDBcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gKiBAcGFyYW0ge251bWJlcn0geTFcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gKiBAcGFyYW0ge251bWJlcn0geDNcbiAqIEBwYXJhbSB7bnVtYmVyfSB5M1xuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbb3V0XSDmipXlsITngrlcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGN1YmljUHJvamVjdFBvaW50KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeCwgeSwgb3V0KSB7XG4gIC8vIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby8jcHJvamVjdGlvbnNcbiAgdmFyIHQ7XG4gIHZhciBpbnRlcnZhbCA9IDAuMDA1O1xuICB2YXIgZCA9IEluZmluaXR5O1xuICB2YXIgcHJldjtcbiAgdmFyIG5leHQ7XG4gIHZhciBkMTtcbiAgdmFyIGQyO1xuICBfdjBbMF0gPSB4O1xuICBfdjBbMV0gPSB5OyAvLyDlhYjnspfnlaXkvLDorqHkuIDkuIvlj6/og73nmoTmnIDlsI/ot53nprvnmoQgdCDlgLxcbiAgLy8gUEVORElOR1xuXG4gIGZvciAodmFyIF90ID0gMDsgX3QgPCAxOyBfdCArPSAwLjA1KSB7XG4gICAgX3YxWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgX3QpO1xuICAgIF92MVsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIF90KTtcbiAgICBkMSA9IHYyRGlzdFNxdWFyZShfdjAsIF92MSk7XG5cbiAgICBpZiAoZDEgPCBkKSB7XG4gICAgICB0ID0gX3Q7XG4gICAgICBkID0gZDE7XG4gICAgfVxuICB9XG5cbiAgZCA9IEluZmluaXR5OyAvLyBBdCBtb3N0IDMyIGl0ZXJhdGlvblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIGlmIChpbnRlcnZhbCA8IEVQU0lMT05fTlVNRVJJQykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcHJldiA9IHQgLSBpbnRlcnZhbDtcbiAgICBuZXh0ID0gdCArIGludGVydmFsOyAvLyB0IC0gaW50ZXJ2YWxcblxuICAgIF92MVswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHByZXYpO1xuICAgIF92MVsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHByZXYpO1xuICAgIGQxID0gdjJEaXN0U3F1YXJlKF92MSwgX3YwKTtcblxuICAgIGlmIChwcmV2ID49IDAgJiYgZDEgPCBkKSB7XG4gICAgICB0ID0gcHJldjtcbiAgICAgIGQgPSBkMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdCArIGludGVydmFsXG4gICAgICBfdjJbMF0gPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCBuZXh0KTtcbiAgICAgIF92MlsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIG5leHQpO1xuICAgICAgZDIgPSB2MkRpc3RTcXVhcmUoX3YyLCBfdjApO1xuXG4gICAgICBpZiAobmV4dCA8PSAxICYmIGQyIDwgZCkge1xuICAgICAgICB0ID0gbmV4dDtcbiAgICAgICAgZCA9IGQyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJ2YWwgKj0gMC41O1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyB0XG5cblxuICBpZiAob3V0KSB7XG4gICAgb3V0WzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgb3V0WzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCk7XG4gIH0gLy8gY29uc29sZS5sb2coaW50ZXJ2YWwsIGkpO1xuXG5cbiAgcmV0dXJuIG1hdGhTcXJ0KGQpO1xufVxuLyoqXG4gKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTlgLxcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljQXQocDAsIHAxLCBwMiwgdCkge1xuICB2YXIgb25ldCA9IDEgLSB0O1xuICByZXR1cm4gb25ldCAqIChvbmV0ICogcDAgKyAyICogdCAqIHAxKSArIHQgKiB0ICogcDI7XG59XG4vKipcbiAqIOiuoeeul+S6jOasoeaWuei0neWhnuWwlOWvvOaVsOWAvFxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBxdWFkcmF0aWNEZXJpdmF0aXZlQXQocDAsIHAxLCBwMiwgdCkge1xuICByZXR1cm4gMiAqICgoMSAtIHQpICogKHAxIC0gcDApICsgdCAqIChwMiAtIHAxKSk7XG59XG4vKipcbiAqIOiuoeeul+S6jOasoeaWuei0neWhnuWwlOaWueeoi+aguVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gcm9vdHNcbiAqIEByZXR1cm4ge251bWJlcn0g5pyJ5pWI5qC55pWw55uuXG4gKi9cblxuXG5mdW5jdGlvbiBxdWFkcmF0aWNSb290QXQocDAsIHAxLCBwMiwgdmFsLCByb290cykge1xuICB2YXIgYSA9IHAwIC0gMiAqIHAxICsgcDI7XG4gIHZhciBiID0gMiAqIChwMSAtIHAwKTtcbiAgdmFyIGMgPSBwMCAtIHZhbDtcbiAgdmFyIG4gPSAwO1xuXG4gIGlmIChpc0Fyb3VuZFplcm8oYSkpIHtcbiAgICBpZiAoaXNOb3RBcm91bmRaZXJvKGIpKSB7XG4gICAgICB2YXIgdDEgPSAtYyAvIGI7XG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuXG4gICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgdmFyIHQxID0gLWIgLyAoMiAqIGEpO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRpc2MgPiAwKSB7XG4gICAgICB2YXIgZGlzY1NxcnQgPSBtYXRoU3FydChkaXNjKTtcbiAgICAgIHZhciB0MSA9ICgtYiArIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICB2YXIgdDIgPSAoLWIgLSBkaXNjU3FydCkgLyAoMiAqIGEpO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cblxuICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG47XG59XG4vKipcbiAqIOiuoeeul+S6jOasoei0neWhnuWwlOaWueeoi+aegemZkOWAvFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIHF1YWRyYXRpY0V4dHJlbXVtKHAwLCBwMSwgcDIpIHtcbiAgdmFyIGRpdmlkZXIgPSBwMCArIHAyIC0gMiAqIHAxO1xuXG4gIGlmIChkaXZpZGVyID09PSAwKSB7XG4gICAgLy8gcDEgaXMgY2VudGVyIG9mIHAwIGFuZCBwMlxuICAgIHJldHVybiAwLjU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChwMCAtIHAxKSAvIGRpdmlkZXI7XG4gIH1cbn1cbi8qKlxuICog57uG5YiG5LqM5qyh6LSd5aGe5bCU5puy57q/XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBxdWFkcmF0aWNTdWJkaXZpZGUocDAsIHAxLCBwMiwgdCwgb3V0KSB7XG4gIHZhciBwMDEgPSAocDEgLSBwMCkgKiB0ICsgcDA7XG4gIHZhciBwMTIgPSAocDIgLSBwMSkgKiB0ICsgcDE7XG4gIHZhciBwMDEyID0gKHAxMiAtIHAwMSkgKiB0ICsgcDAxOyAvLyBTZWcwXG5cbiAgb3V0WzBdID0gcDA7XG4gIG91dFsxXSA9IHAwMTtcbiAgb3V0WzJdID0gcDAxMjsgLy8gU2VnMVxuXG4gIG91dFszXSA9IHAwMTI7XG4gIG91dFs0XSA9IHAxMjtcbiAgb3V0WzVdID0gcDI7XG59XG4vKipcbiAqIOaKleWwhOeCueWIsOS6jOasoei0neWhnuWwlOabsue6v+S4iu+8jOi/lOWbnuaKleWwhOi3neemu+OAglxuICog5oqV5bCE54K55pyJ5Y+v6IO95Lya5pyJ5LiA5Liq5oiW6ICF5aSa5Liq77yM6L+Z6YeM5Y+q6L+U5Zue5YW25Lit6Led56a75pyA55+t55qE5LiA5Liq44CCXG4gKiBAcGFyYW0ge251bWJlcn0geDBcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gKiBAcGFyYW0ge251bWJlcn0geTFcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG91dCDmipXlsITngrlcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIHF1YWRyYXRpY1Byb2plY3RQb2ludCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4LCB5LCBvdXQpIHtcbiAgLy8gaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvLyNwcm9qZWN0aW9uc1xuICB2YXIgdDtcbiAgdmFyIGludGVydmFsID0gMC4wMDU7XG4gIHZhciBkID0gSW5maW5pdHk7XG4gIF92MFswXSA9IHg7XG4gIF92MFsxXSA9IHk7IC8vIOWFiOeyl+eVpeS8sOiuoeS4gOS4i+WPr+iDveeahOacgOWwj+i3neemu+eahCB0IOWAvFxuICAvLyBQRU5ESU5HXG5cbiAgZm9yICh2YXIgX3QgPSAwOyBfdCA8IDE7IF90ICs9IDAuMDUpIHtcbiAgICBfdjFbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCBfdCk7XG4gICAgX3YxWzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgX3QpO1xuICAgIHZhciBkMSA9IHYyRGlzdFNxdWFyZShfdjAsIF92MSk7XG5cbiAgICBpZiAoZDEgPCBkKSB7XG4gICAgICB0ID0gX3Q7XG4gICAgICBkID0gZDE7XG4gICAgfVxuICB9XG5cbiAgZCA9IEluZmluaXR5OyAvLyBBdCBtb3N0IDMyIGl0ZXJhdGlvblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIGlmIChpbnRlcnZhbCA8IEVQU0lMT05fTlVNRVJJQykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHByZXYgPSB0IC0gaW50ZXJ2YWw7XG4gICAgdmFyIG5leHQgPSB0ICsgaW50ZXJ2YWw7IC8vIHQgLSBpbnRlcnZhbFxuXG4gICAgX3YxWzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgcHJldik7XG4gICAgX3YxWzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgcHJldik7XG4gICAgdmFyIGQxID0gdjJEaXN0U3F1YXJlKF92MSwgX3YwKTtcblxuICAgIGlmIChwcmV2ID49IDAgJiYgZDEgPCBkKSB7XG4gICAgICB0ID0gcHJldjtcbiAgICAgIGQgPSBkMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdCArIGludGVydmFsXG4gICAgICBfdjJbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCBuZXh0KTtcbiAgICAgIF92MlsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIG5leHQpO1xuICAgICAgdmFyIGQyID0gdjJEaXN0U3F1YXJlKF92MiwgX3YwKTtcblxuICAgICAgaWYgKG5leHQgPD0gMSAmJiBkMiA8IGQpIHtcbiAgICAgICAgdCA9IG5leHQ7XG4gICAgICAgIGQgPSBkMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVydmFsICo9IDAuNTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gdFxuXG5cbiAgaWYgKG91dCkge1xuICAgIG91dFswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHQpO1xuICAgIG91dFsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHQpO1xuICB9IC8vIGNvbnNvbGUubG9nKGludGVydmFsLCBpKTtcblxuXG4gIHJldHVybiBtYXRoU3FydChkKTtcbn1cblxuZXhwb3J0cy5jdWJpY0F0ID0gY3ViaWNBdDtcbmV4cG9ydHMuY3ViaWNEZXJpdmF0aXZlQXQgPSBjdWJpY0Rlcml2YXRpdmVBdDtcbmV4cG9ydHMuY3ViaWNSb290QXQgPSBjdWJpY1Jvb3RBdDtcbmV4cG9ydHMuY3ViaWNFeHRyZW1hID0gY3ViaWNFeHRyZW1hO1xuZXhwb3J0cy5jdWJpY1N1YmRpdmlkZSA9IGN1YmljU3ViZGl2aWRlO1xuZXhwb3J0cy5jdWJpY1Byb2plY3RQb2ludCA9IGN1YmljUHJvamVjdFBvaW50O1xuZXhwb3J0cy5xdWFkcmF0aWNBdCA9IHF1YWRyYXRpY0F0O1xuZXhwb3J0cy5xdWFkcmF0aWNEZXJpdmF0aXZlQXQgPSBxdWFkcmF0aWNEZXJpdmF0aXZlQXQ7XG5leHBvcnRzLnF1YWRyYXRpY1Jvb3RBdCA9IHF1YWRyYXRpY1Jvb3RBdDtcbmV4cG9ydHMucXVhZHJhdGljRXh0cmVtdW0gPSBxdWFkcmF0aWNFeHRyZW11bTtcbmV4cG9ydHMucXVhZHJhdGljU3ViZGl2aWRlID0gcXVhZHJhdGljU3ViZGl2aWRlO1xuZXhwb3J0cy5xdWFkcmF0aWNQcm9qZWN0UG9pbnQgPSBxdWFkcmF0aWNQcm9qZWN0UG9pbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvY3VydmUuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB2ZWMyID0gcmVxdWlyZShcIi4vdmVjdG9yXCIpO1xuXG52YXIgY3VydmUgPSByZXF1aXJlKFwiLi9jdXJ2ZVwiKTtcblxuLyoqXG4gKiBAYXV0aG9yIFlpIFNoZW4oaHR0cHM6Ly9naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbnZhciBtYXRoTWluID0gTWF0aC5taW47XG52YXIgbWF0aE1heCA9IE1hdGgubWF4O1xudmFyIG1hdGhTaW4gPSBNYXRoLnNpbjtcbnZhciBtYXRoQ29zID0gTWF0aC5jb3M7XG52YXIgUEkyID0gTWF0aC5QSSAqIDI7XG52YXIgc3RhcnQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGVuZCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgZXh0cmVtaXR5ID0gdmVjMi5jcmVhdGUoKTtcbi8qKlxuICog5LuO6aG254K55pWw57uE5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvYmJveFxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBwb2ludHMg6aG254K55pWw57uEXG4gKiBAcGFyYW0ge251bWJlcn0gbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gKi9cblxuZnVuY3Rpb24gZnJvbVBvaW50cyhwb2ludHMsIG1pbiwgbWF4KSB7XG4gIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHAgPSBwb2ludHNbMF07XG4gIHZhciBsZWZ0ID0gcFswXTtcbiAgdmFyIHJpZ2h0ID0gcFswXTtcbiAgdmFyIHRvcCA9IHBbMV07XG4gIHZhciBib3R0b20gPSBwWzFdO1xuICB2YXIgaTtcblxuICBmb3IgKGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgcCA9IHBvaW50c1tpXTtcbiAgICBsZWZ0ID0gbWF0aE1pbihsZWZ0LCBwWzBdKTtcbiAgICByaWdodCA9IG1hdGhNYXgocmlnaHQsIHBbMF0pO1xuICAgIHRvcCA9IG1hdGhNaW4odG9wLCBwWzFdKTtcbiAgICBib3R0b20gPSBtYXRoTWF4KGJvdHRvbSwgcFsxXSk7XG4gIH1cblxuICBtaW5bMF0gPSBsZWZ0O1xuICBtaW5bMV0gPSB0b3A7XG4gIG1heFswXSA9IHJpZ2h0O1xuICBtYXhbMV0gPSBib3R0b207XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21MaW5lKHgwLCB5MCwgeDEsIHkxLCBtaW4sIG1heCkge1xuICBtaW5bMF0gPSBtYXRoTWluKHgwLCB4MSk7XG4gIG1pblsxXSA9IG1hdGhNaW4oeTAsIHkxKTtcbiAgbWF4WzBdID0gbWF0aE1heCh4MCwgeDEpO1xuICBtYXhbMV0gPSBtYXRoTWF4KHkwLCB5MSk7XG59XG5cbnZhciB4RGltID0gW107XG52YXIgeURpbSA9IFtdO1xuLyoqXG4gKiDku47kuInpmLbotJ3loZ7lsJTmm7Lnur8ocDAsIHAxLCBwMiwgcDMp5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gKiBAcGFyYW0ge251bWJlcn0geTBcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge251bWJlcn0geDJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gKiBAcGFyYW0ge251bWJlcn0geTNcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gKi9cblxuZnVuY3Rpb24gZnJvbUN1YmljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgbWluLCBtYXgpIHtcbiAgdmFyIGN1YmljRXh0cmVtYSA9IGN1cnZlLmN1YmljRXh0cmVtYTtcbiAgdmFyIGN1YmljQXQgPSBjdXJ2ZS5jdWJpY0F0O1xuICB2YXIgaTtcbiAgdmFyIG4gPSBjdWJpY0V4dHJlbWEoeDAsIHgxLCB4MiwgeDMsIHhEaW0pO1xuICBtaW5bMF0gPSBJbmZpbml0eTtcbiAgbWluWzFdID0gSW5maW5pdHk7XG4gIG1heFswXSA9IC1JbmZpbml0eTtcbiAgbWF4WzFdID0gLUluZmluaXR5O1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICB2YXIgeCA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHhEaW1baV0pO1xuICAgIG1pblswXSA9IG1hdGhNaW4oeCwgbWluWzBdKTtcbiAgICBtYXhbMF0gPSBtYXRoTWF4KHgsIG1heFswXSk7XG4gIH1cblxuICBuID0gY3ViaWNFeHRyZW1hKHkwLCB5MSwgeTIsIHkzLCB5RGltKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgdmFyIHkgPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB5RGltW2ldKTtcbiAgICBtaW5bMV0gPSBtYXRoTWluKHksIG1pblsxXSk7XG4gICAgbWF4WzFdID0gbWF0aE1heCh5LCBtYXhbMV0pO1xuICB9XG5cbiAgbWluWzBdID0gbWF0aE1pbih4MCwgbWluWzBdKTtcbiAgbWF4WzBdID0gbWF0aE1heCh4MCwgbWF4WzBdKTtcbiAgbWluWzBdID0gbWF0aE1pbih4MywgbWluWzBdKTtcbiAgbWF4WzBdID0gbWF0aE1heCh4MywgbWF4WzBdKTtcbiAgbWluWzFdID0gbWF0aE1pbih5MCwgbWluWzFdKTtcbiAgbWF4WzFdID0gbWF0aE1heCh5MCwgbWF4WzFdKTtcbiAgbWluWzFdID0gbWF0aE1pbih5MywgbWluWzFdKTtcbiAgbWF4WzFdID0gbWF0aE1heCh5MywgbWF4WzFdKTtcbn1cbi8qKlxuICog5LuO5LqM6Zi26LSd5aGe5bCU5puy57q/KHAwLCBwMSwgcDIp5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gKiBAcGFyYW0ge251bWJlcn0geTBcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge251bWJlcn0geDJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21RdWFkcmF0aWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgbWluLCBtYXgpIHtcbiAgdmFyIHF1YWRyYXRpY0V4dHJlbXVtID0gY3VydmUucXVhZHJhdGljRXh0cmVtdW07XG4gIHZhciBxdWFkcmF0aWNBdCA9IGN1cnZlLnF1YWRyYXRpY0F0OyAvLyBGaW5kIGV4dHJlbWl0aWVzLCB3aGVyZSBkZXJpdmF0aXZlIGluIHggZGltIG9yIHkgZGltIGlzIHplcm9cblxuICB2YXIgdHggPSBtYXRoTWF4KG1hdGhNaW4ocXVhZHJhdGljRXh0cmVtdW0oeDAsIHgxLCB4MiksIDEpLCAwKTtcbiAgdmFyIHR5ID0gbWF0aE1heChtYXRoTWluKHF1YWRyYXRpY0V4dHJlbXVtKHkwLCB5MSwgeTIpLCAxKSwgMCk7XG4gIHZhciB4ID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgdHgpO1xuICB2YXIgeSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHR5KTtcbiAgbWluWzBdID0gbWF0aE1pbih4MCwgeDIsIHgpO1xuICBtaW5bMV0gPSBtYXRoTWluKHkwLCB5MiwgeSk7XG4gIG1heFswXSA9IG1hdGhNYXgoeDAsIHgyLCB4KTtcbiAgbWF4WzFdID0gbWF0aE1heCh5MCwgeTIsIHkpO1xufVxuLyoqXG4gKiDku47lnIblvKfkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEBwYXJhbSB7bnVtYmVyfSByeFxuICogQHBhcmFtIHtudW1iZXJ9IHJ5XG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRBbmdsZVxuICogQHBhcmFtIHtudW1iZXJ9IGVuZEFuZ2xlXG4gKiBAcGFyYW0ge251bWJlcn0gYW50aWNsb2Nrd2lzZVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21BcmMoeCwgeSwgcngsIHJ5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSwgbWluLCBtYXgpIHtcbiAgdmFyIHZlYzJNaW4gPSB2ZWMyLm1pbjtcbiAgdmFyIHZlYzJNYXggPSB2ZWMyLm1heDtcbiAgdmFyIGRpZmYgPSBNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpO1xuXG4gIGlmIChkaWZmICUgUEkyIDwgMWUtNCAmJiBkaWZmID4gMWUtNCkge1xuICAgIC8vIElzIGEgY2lyY2xlXG4gICAgbWluWzBdID0geCAtIHJ4O1xuICAgIG1pblsxXSA9IHkgLSByeTtcbiAgICBtYXhbMF0gPSB4ICsgcng7XG4gICAgbWF4WzFdID0geSArIHJ5O1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0YXJ0WzBdID0gbWF0aENvcyhzdGFydEFuZ2xlKSAqIHJ4ICsgeDtcbiAgc3RhcnRbMV0gPSBtYXRoU2luKHN0YXJ0QW5nbGUpICogcnkgKyB5O1xuICBlbmRbMF0gPSBtYXRoQ29zKGVuZEFuZ2xlKSAqIHJ4ICsgeDtcbiAgZW5kWzFdID0gbWF0aFNpbihlbmRBbmdsZSkgKiByeSArIHk7XG4gIHZlYzJNaW4obWluLCBzdGFydCwgZW5kKTtcbiAgdmVjMk1heChtYXgsIHN0YXJ0LCBlbmQpOyAvLyBUaHJlc2ggdG8gWzAsIE1hdGguUEkgKiAyXVxuXG4gIHN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlICUgUEkyO1xuXG4gIGlmIChzdGFydEFuZ2xlIDwgMCkge1xuICAgIHN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlICsgUEkyO1xuICB9XG5cbiAgZW5kQW5nbGUgPSBlbmRBbmdsZSAlIFBJMjtcblxuICBpZiAoZW5kQW5nbGUgPCAwKSB7XG4gICAgZW5kQW5nbGUgPSBlbmRBbmdsZSArIFBJMjtcbiAgfVxuXG4gIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUgJiYgIWFudGljbG9ja3dpc2UpIHtcbiAgICBlbmRBbmdsZSArPSBQSTI7XG4gIH0gZWxzZSBpZiAoc3RhcnRBbmdsZSA8IGVuZEFuZ2xlICYmIGFudGljbG9ja3dpc2UpIHtcbiAgICBzdGFydEFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIGlmIChhbnRpY2xvY2t3aXNlKSB7XG4gICAgdmFyIHRtcCA9IGVuZEFuZ2xlO1xuICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZTtcbiAgICBzdGFydEFuZ2xlID0gdG1wO1xuICB9IC8vIHZhciBudW1iZXIgPSAwO1xuICAvLyB2YXIgc3RlcCA9IChhbnRpY2xvY2t3aXNlID8gLU1hdGguUEkgOiBNYXRoLlBJKSAvIDI7XG5cblxuICBmb3IgKHZhciBhbmdsZSA9IDA7IGFuZ2xlIDwgZW5kQW5nbGU7IGFuZ2xlICs9IE1hdGguUEkgLyAyKSB7XG4gICAgaWYgKGFuZ2xlID4gc3RhcnRBbmdsZSkge1xuICAgICAgZXh0cmVtaXR5WzBdID0gbWF0aENvcyhhbmdsZSkgKiByeCArIHg7XG4gICAgICBleHRyZW1pdHlbMV0gPSBtYXRoU2luKGFuZ2xlKSAqIHJ5ICsgeTtcbiAgICAgIHZlYzJNaW4obWluLCBleHRyZW1pdHksIG1pbik7XG4gICAgICB2ZWMyTWF4KG1heCwgZXh0cmVtaXR5LCBtYXgpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLmZyb21Qb2ludHMgPSBmcm9tUG9pbnRzO1xuZXhwb3J0cy5mcm9tTGluZSA9IGZyb21MaW5lO1xuZXhwb3J0cy5mcm9tQ3ViaWMgPSBmcm9tQ3ViaWM7XG5leHBvcnRzLmZyb21RdWFkcmF0aWMgPSBmcm9tUXVhZHJhdGljO1xuZXhwb3J0cy5mcm9tQXJjID0gZnJvbUFyYztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29yZS9iYm94LmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF0aFByb3h5ID0gcmVxdWlyZShcIi4uL2NvcmUvUGF0aFByb3h5XCIpO1xuXG52YXIgbGluZSA9IHJlcXVpcmUoXCIuL2xpbmVcIik7XG5cbnZhciBjdWJpYyA9IHJlcXVpcmUoXCIuL2N1YmljXCIpO1xuXG52YXIgcXVhZHJhdGljID0gcmVxdWlyZShcIi4vcXVhZHJhdGljXCIpO1xuXG52YXIgYXJjID0gcmVxdWlyZShcIi4vYXJjXCIpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgbm9ybWFsaXplUmFkaWFuID0gX3V0aWwubm9ybWFsaXplUmFkaWFuO1xuXG52YXIgY3VydmUgPSByZXF1aXJlKFwiLi4vY29yZS9jdXJ2ZVwiKTtcblxudmFyIHdpbmRpbmdMaW5lID0gcmVxdWlyZShcIi4vd2luZGluZ0xpbmVcIik7XG5cbnZhciBDTUQgPSBQYXRoUHJveHkuQ01EO1xudmFyIFBJMiA9IE1hdGguUEkgKiAyO1xudmFyIEVQU0lMT04gPSAxZS00O1xuXG5mdW5jdGlvbiBpc0Fyb3VuZEVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8IEVQU0lMT047XG59IC8vIOS4tOaXtuaVsOe7hFxuXG5cbnZhciByb290cyA9IFstMSwgLTEsIC0xXTtcbnZhciBleHRyZW1hID0gWy0xLCAtMV07XG5cbmZ1bmN0aW9uIHN3YXBFeHRyZW1hKCkge1xuICB2YXIgdG1wID0gZXh0cmVtYVswXTtcbiAgZXh0cmVtYVswXSA9IGV4dHJlbWFbMV07XG4gIGV4dHJlbWFbMV0gPSB0bXA7XG59XG5cbmZ1bmN0aW9uIHdpbmRpbmdDdWJpYyh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHgsIHkpIHtcbiAgLy8gUXVpY2sgcmVqZWN0XG4gIGlmICh5ID4geTAgJiYgeSA+IHkxICYmIHkgPiB5MiAmJiB5ID4geTMgfHwgeSA8IHkwICYmIHkgPCB5MSAmJiB5IDwgeTIgJiYgeSA8IHkzKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgblJvb3RzID0gY3VydmUuY3ViaWNSb290QXQoeTAsIHkxLCB5MiwgeTMsIHksIHJvb3RzKTtcblxuICBpZiAoblJvb3RzID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHcgPSAwO1xuICAgIHZhciBuRXh0cmVtYSA9IC0xO1xuICAgIHZhciB5MF8sIHkxXztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblJvb3RzOyBpKyspIHtcbiAgICAgIHZhciB0ID0gcm9vdHNbaV07IC8vIEF2b2lkIHdpbmRpbmcgZXJyb3Igd2hlbiBpbnRlcnNlY3Rpb24gcG9pbnQgaXMgdGhlIGNvbm5lY3QgcG9pbnQgb2YgdHdvIGxpbmUgb2YgcG9seWdvblxuXG4gICAgICB2YXIgdW5pdCA9IHQgPT09IDAgfHwgdCA9PT0gMSA/IDAuNSA6IDE7XG4gICAgICB2YXIgeF8gPSBjdXJ2ZS5jdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcblxuICAgICAgaWYgKHhfIDwgeCkge1xuICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChuRXh0cmVtYSA8IDApIHtcbiAgICAgICAgbkV4dHJlbWEgPSBjdXJ2ZS5jdWJpY0V4dHJlbWEoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWEpO1xuXG4gICAgICAgIGlmIChleHRyZW1hWzFdIDwgZXh0cmVtYVswXSAmJiBuRXh0cmVtYSA+IDEpIHtcbiAgICAgICAgICBzd2FwRXh0cmVtYSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgeTBfID0gY3VydmUuY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgZXh0cmVtYVswXSk7XG5cbiAgICAgICAgaWYgKG5FeHRyZW1hID4gMSkge1xuICAgICAgICAgIHkxXyA9IGN1cnZlLmN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWFbMV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuRXh0cmVtYSA9PSAyKSB7XG4gICAgICAgIC8vIOWIhuaIkOS4ieauteWNleiwg+WHveaVsFxuICAgICAgICBpZiAodCA8IGV4dHJlbWFbMF0pIHtcbiAgICAgICAgICB3ICs9IHkwXyA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9IGVsc2UgaWYgKHQgPCBleHRyZW1hWzFdKSB7XG4gICAgICAgICAgdyArPSB5MV8gPCB5MF8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdyArPSB5MyA8IHkxXyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8g5YiG5oiQ5Lik5q615Y2V6LCD5Ye95pWwXG4gICAgICAgIGlmICh0IDwgZXh0cmVtYVswXSkge1xuICAgICAgICAgIHcgKz0geTBfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdyArPSB5MyA8IHkwXyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB3O1xuICB9XG59XG5cbmZ1bmN0aW9uIHdpbmRpbmdRdWFkcmF0aWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICAvLyBRdWljayByZWplY3RcbiAgaWYgKHkgPiB5MCAmJiB5ID4geTEgJiYgeSA+IHkyIHx8IHkgPCB5MCAmJiB5IDwgeTEgJiYgeSA8IHkyKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgblJvb3RzID0gY3VydmUucXVhZHJhdGljUm9vdEF0KHkwLCB5MSwgeTIsIHksIHJvb3RzKTtcblxuICBpZiAoblJvb3RzID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHQgPSBjdXJ2ZS5xdWFkcmF0aWNFeHRyZW11bSh5MCwgeTEsIHkyKTtcblxuICAgIGlmICh0ID49IDAgJiYgdCA8PSAxKSB7XG4gICAgICB2YXIgdyA9IDA7XG4gICAgICB2YXIgeV8gPSBjdXJ2ZS5xdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCB0KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUm9vdHM7IGkrKykge1xuICAgICAgICAvLyBSZW1vdmUgb25lIGVuZHBvaW50LlxuICAgICAgICB2YXIgdW5pdCA9IHJvb3RzW2ldID09PSAwIHx8IHJvb3RzW2ldID09PSAxID8gMC41IDogMTtcbiAgICAgICAgdmFyIHhfID0gY3VydmUucXVhZHJhdGljQXQoeDAsIHgxLCB4Miwgcm9vdHNbaV0pO1xuXG4gICAgICAgIGlmICh4XyA8IHgpIHtcbiAgICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyb290c1tpXSA8IHQpIHtcbiAgICAgICAgICB3ICs9IHlfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdyArPSB5MiA8IHlfID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1vdmUgb25lIGVuZHBvaW50LlxuICAgICAgdmFyIHVuaXQgPSByb290c1swXSA9PT0gMCB8fCByb290c1swXSA9PT0gMSA/IDAuNSA6IDE7XG4gICAgICB2YXIgeF8gPSBjdXJ2ZS5xdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCByb290c1swXSk7XG5cbiAgICAgIGlmICh4XyA8IHgpIHtcbiAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geTIgPCB5MCA/IHVuaXQgOiAtdW5pdDtcbiAgICB9XG4gIH1cbn0gLy8gVE9ET1xuLy8gQXJjIOaXi+i9rFxuXG5cbmZ1bmN0aW9uIHdpbmRpbmdBcmMoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSwgeCwgeSkge1xuICB5IC09IGN5O1xuXG4gIGlmICh5ID4gciB8fCB5IDwgLXIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciB0bXAgPSBNYXRoLnNxcnQociAqIHIgLSB5ICogeSk7XG4gIHJvb3RzWzBdID0gLXRtcDtcbiAgcm9vdHNbMV0gPSB0bXA7XG4gIHZhciBkaWZmID0gTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKTtcblxuICBpZiAoZGlmZiA8IDFlLTQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChkaWZmICUgUEkyIDwgMWUtNCkge1xuICAgIC8vIElzIGEgY2lyY2xlXG4gICAgc3RhcnRBbmdsZSA9IDA7XG4gICAgZW5kQW5nbGUgPSBQSTI7XG4gICAgdmFyIGRpciA9IGFudGljbG9ja3dpc2UgPyAxIDogLTE7XG5cbiAgICBpZiAoeCA+PSByb290c1swXSArIGN4ICYmIHggPD0gcm9vdHNbMV0gKyBjeCkge1xuICAgICAgcmV0dXJuIGRpcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG5cbiAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbih0bXApO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oc3RhcnRBbmdsZSk7XG4gICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICB9XG5cbiAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIHZhciB3ID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgIHZhciB4XyA9IHJvb3RzW2ldO1xuXG4gICAgaWYgKHhfICsgY3ggPiB4KSB7XG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHksIHhfKTtcbiAgICAgIHZhciBkaXIgPSBhbnRpY2xvY2t3aXNlID8gMSA6IC0xO1xuXG4gICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgIGFuZ2xlID0gUEkyICsgYW5nbGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlIHx8IGFuZ2xlICsgUEkyID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgKyBQSTIgPD0gZW5kQW5nbGUpIHtcbiAgICAgICAgaWYgKGFuZ2xlID4gTWF0aC5QSSAvIDIgJiYgYW5nbGUgPCBNYXRoLlBJICogMS41KSB7XG4gICAgICAgICAgZGlyID0gLWRpcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHcgKz0gZGlyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3O1xufVxuXG5mdW5jdGlvbiBjb250YWluUGF0aChkYXRhLCBsaW5lV2lkdGgsIGlzU3Ryb2tlLCB4LCB5KSB7XG4gIHZhciB3ID0gMDtcbiAgdmFyIHhpID0gMDtcbiAgdmFyIHlpID0gMDtcbiAgdmFyIHgwID0gMDtcbiAgdmFyIHkwID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgIHZhciBjbWQgPSBkYXRhW2krK107IC8vIEJlZ2luIGEgbmV3IHN1YnBhdGhcblxuICAgIGlmIChjbWQgPT09IENNRC5NICYmIGkgPiAxKSB7XG4gICAgICAvLyBDbG9zZSBwcmV2aW91cyBzdWJwYXRoXG4gICAgICBpZiAoIWlzU3Ryb2tlKSB7XG4gICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MCwgeTAsIHgsIHkpO1xuICAgICAgfSAvLyDlpoLmnpzooqvku7vkvZXkuIDkuKogc3VicGF0aCDljIXlkKtcbiAgICAgIC8vIGlmICh3ICE9PSAwKSB7XG4gICAgICAvLyAgICAgcmV0dXJuIHRydWU7XG4gICAgICAvLyB9XG5cbiAgICB9XG5cbiAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAvLyDlpoLmnpznrKzkuIDkuKrlkb3ku6TmmK8gTCwgQywgUVxuICAgICAgLy8g5YiZIHByZXZpb3VzIHBvaW50IOWQjOe7mOWItuWRveS7pOeahOesrOS4gOS4qiBwb2ludFxuICAgICAgLy9cbiAgICAgIC8vIOesrOS4gOS4quWRveS7pOS4uiBBcmMg55qE5oOF5Ya15LiL5Lya5Zyo5ZCO6Z2i54m55q6K5aSE55CGXG4gICAgICB4aSA9IGRhdGFbaV07XG4gICAgICB5aSA9IGRhdGFbaSArIDFdO1xuICAgICAgeDAgPSB4aTtcbiAgICAgIHkwID0geWk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChjbWQpIHtcbiAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgIC8vIG1vdmVUbyDlkb3ku6Tph43mlrDliJvlu7rkuIDkuKrmlrDnmoQgc3VicGF0aCwg5bm25LiU5pu05paw5paw55qE6LW354K5XG4gICAgICAgIC8vIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5L2/55SoXG4gICAgICAgIHgwID0gZGF0YVtpKytdO1xuICAgICAgICB5MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChsaW5lLmNvbnRhaW5TdHJva2UoeGksIHlpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5PVEUg5Zyo56ys5LiA5Liq5ZG95Luk5Li6IEwsIEMsIFEg55qE5pe25YCZ5Lya6K6h566X5Ye6IE5hTlxuICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgeCwgeSkgfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChjdWJpYy5jb250YWluU3Ryb2tlKHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0gd2luZGluZ0N1YmljKHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgeCwgeSkgfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELlE6XG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChxdWFkcmF0aWMuY29udGFpblN0cm9rZSh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0gd2luZGluZ1F1YWRyYXRpYyh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgeCwgeSkgfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgIC8vIFRPRE8gQXJjIOWIpOaWreeahOW8gOmUgOavlOi+g+Wkp1xuICAgICAgICB2YXIgY3ggPSBkYXRhW2krK107XG4gICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHJ4ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgcnkgPSBkYXRhW2krK107XG4gICAgICAgIHZhciB0aGV0YSA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIGRUaGV0YSA9IGRhdGFbaSsrXTsgLy8gVE9ETyBBcmMg5peL6L2sXG5cbiAgICAgICAgdmFyIHBzaSA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIGFudGljbG9ja3dpc2UgPSAxIC0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgeDEgPSBNYXRoLmNvcyh0aGV0YSkgKiByeCArIGN4O1xuICAgICAgICB2YXIgeTEgPSBNYXRoLnNpbih0aGV0YSkgKiByeSArIGN5OyAvLyDkuI3mmK/nm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuXG4gICAgICAgIGlmIChpID4gMSkge1xuICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MSwgeTEsIHgsIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOi1t+eCuei/mOacquWumuS5iVxuICAgICAgICAgIHgwID0geDE7XG4gICAgICAgICAgeTAgPSB5MTtcbiAgICAgICAgfSAvLyB6ciDkvb/nlKhzY2FsZeadpeaooeaLn+akreWchiwg6L+Z6YeM5Lmf5a+5eOWBmuS4gOWumueahOe8qeaUvlxuXG5cbiAgICAgICAgdmFyIF94ID0gKHggLSBjeCkgKiByeSAvIHJ4ICsgY3g7XG5cbiAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgaWYgKGFyYy5jb250YWluU3Ryb2tlKGN4LCBjeSwgcnksIHRoZXRhLCB0aGV0YSArIGRUaGV0YSwgYW50aWNsb2Nrd2lzZSwgbGluZVdpZHRoLCBfeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHdpbmRpbmdBcmMoY3gsIGN5LCByeSwgdGhldGEsIHRoZXRhICsgZFRoZXRhLCBhbnRpY2xvY2t3aXNlLCBfeCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IE1hdGguY29zKHRoZXRhICsgZFRoZXRhKSAqIHJ4ICsgY3g7XG4gICAgICAgIHlpID0gTWF0aC5zaW4odGhldGEgKyBkVGhldGEpICogcnkgKyBjeTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgIHgwID0geGkgPSBkYXRhW2krK107XG4gICAgICAgIHkwID0geWkgPSBkYXRhW2krK107XG4gICAgICAgIHZhciB3aWR0aCA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIGhlaWdodCA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHgxID0geDAgKyB3aWR0aDtcbiAgICAgICAgdmFyIHkxID0geTAgKyBoZWlnaHQ7XG5cbiAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgaWYgKGxpbmUuY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MCwgbGluZVdpZHRoLCB4LCB5KSB8fCBsaW5lLmNvbnRhaW5TdHJva2UoeDEsIHkwLCB4MSwgeTEsIGxpbmVXaWR0aCwgeCwgeSkgfHwgbGluZS5jb250YWluU3Ryb2tlKHgxLCB5MSwgeDAsIHkxLCBsaW5lV2lkdGgsIHgsIHkpIHx8IGxpbmUuY29udGFpblN0cm9rZSh4MCwgeTEsIHgwLCB5MCwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEZJWE1FIENsb2Nrd2lzZSA/XG4gICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4MSwgeTAsIHgxLCB5MSwgeCwgeSk7XG4gICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4MCwgeTEsIHgwLCB5MCwgeCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgaWYgKGxpbmUuY29udGFpblN0cm9rZSh4aSwgeWksIHgwLCB5MCwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENsb3NlIGEgc3VicGF0aFxuICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MCwgeTAsIHgsIHkpOyAvLyDlpoLmnpzooqvku7vkvZXkuIDkuKogc3VicGF0aCDljIXlkKtcbiAgICAgICAgICAvLyBGSVhNRSBzdWJwYXRocyBtYXkgb3ZlcmxhcFxuICAgICAgICAgIC8vIGlmICh3ICE9PSAwKSB7XG4gICAgICAgICAgLy8gICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHhpID0geDA7XG4gICAgICAgIHlpID0geTA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaXNTdHJva2UgJiYgIWlzQXJvdW5kRXF1YWwoeWksIHkwKSkge1xuICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MCwgeTAsIHgsIHkpIHx8IDA7XG4gIH1cblxuICByZXR1cm4gdyAhPT0gMDtcbn1cblxuZnVuY3Rpb24gY29udGFpbihwYXRoRGF0YSwgeCwgeSkge1xuICByZXR1cm4gY29udGFpblBhdGgocGF0aERhdGEsIDAsIGZhbHNlLCB4LCB5KTtcbn1cblxuZnVuY3Rpb24gY29udGFpblN0cm9rZShwYXRoRGF0YSwgbGluZVdpZHRoLCB4LCB5KSB7XG4gIHJldHVybiBjb250YWluUGF0aChwYXRoRGF0YSwgbGluZVdpZHRoLCB0cnVlLCB4LCB5KTtcbn1cblxuZXhwb3J0cy5jb250YWluID0gY29udGFpbjtcbmV4cG9ydHMuY29udGFpblN0cm9rZSA9IGNvbnRhaW5TdHJva2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vcGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiDnur/mrrXljIXlkKvliKTmlq1cbiAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBsaW5lV2lkdGhcbiAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5TdHJva2UoeDAsIHkwLCB4MSwgeTEsIGxpbmVXaWR0aCwgeCwgeSkge1xuICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIF9sID0gbGluZVdpZHRoO1xuICB2YXIgX2EgPSAwO1xuICB2YXIgX2IgPSB4MDsgLy8gUXVpY2sgcmVqZWN0XG5cbiAgaWYgKHkgPiB5MCArIF9sICYmIHkgPiB5MSArIF9sIHx8IHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sIHx8IHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sIHx8IHggPCB4MCAtIF9sICYmIHggPCB4MSAtIF9sKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHgwICE9PSB4MSkge1xuICAgIF9hID0gKHkwIC0geTEpIC8gKHgwIC0geDEpO1xuICAgIF9iID0gKHgwICogeTEgLSB4MSAqIHkwKSAvICh4MCAtIHgxKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoeCAtIHgwKSA8PSBfbCAvIDI7XG4gIH1cblxuICB2YXIgdG1wID0gX2EgKiB4IC0geSArIF9iO1xuXG4gIHZhciBfcyA9IHRtcCAqIHRtcCAvIChfYSAqIF9hICsgMSk7XG5cbiAgcmV0dXJuIF9zIDw9IF9sIC8gMiAqIF9sIC8gMjtcbn1cblxuZXhwb3J0cy5jb250YWluU3Ryb2tlID0gY29udGFpblN0cm9rZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29udGFpbi9saW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY3VydmUgPSByZXF1aXJlKFwiLi4vY29yZS9jdXJ2ZVwiKTtcblxuLyoqXG4gKiDkuInmrKHotJ3loZ7lsJTmm7Lnur/mj4/ovrnljIXlkKvliKTmlq1cbiAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MlxuICogQHBhcmFtICB7bnVtYmVyfSAgeTJcbiAqIEBwYXJhbSAge251bWJlcn0gIHgzXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5M1xuICogQHBhcmFtICB7bnVtYmVyfSAgbGluZVdpZHRoXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb250YWluU3Ryb2tlKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgbGluZVdpZHRoLCB4LCB5KSB7XG4gIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgX2wgPSBsaW5lV2lkdGg7IC8vIFF1aWNrIHJlamVjdFxuXG4gIGlmICh5ID4geTAgKyBfbCAmJiB5ID4geTEgKyBfbCAmJiB5ID4geTIgKyBfbCAmJiB5ID4geTMgKyBfbCB8fCB5IDwgeTAgLSBfbCAmJiB5IDwgeTEgLSBfbCAmJiB5IDwgeTIgLSBfbCAmJiB5IDwgeTMgLSBfbCB8fCB4ID4geDAgKyBfbCAmJiB4ID4geDEgKyBfbCAmJiB4ID4geDIgKyBfbCAmJiB4ID4geDMgKyBfbCB8fCB4IDwgeDAgLSBfbCAmJiB4IDwgeDEgLSBfbCAmJiB4IDwgeDIgLSBfbCAmJiB4IDwgeDMgLSBfbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBkID0gY3VydmUuY3ViaWNQcm9qZWN0UG9pbnQoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4LCB5LCBudWxsKTtcbiAgcmV0dXJuIGQgPD0gX2wgLyAyO1xufVxuXG5leHBvcnRzLmNvbnRhaW5TdHJva2UgPSBjb250YWluU3Ryb2tlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb250YWluL2N1YmljLmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX2N1cnZlID0gcmVxdWlyZShcIi4uL2NvcmUvY3VydmVcIik7XG5cbnZhciBxdWFkcmF0aWNQcm9qZWN0UG9pbnQgPSBfY3VydmUucXVhZHJhdGljUHJvamVjdFBvaW50O1xuXG4vKipcbiAqIOS6jOasoei0neWhnuWwlOabsue6v+aPj+i+ueWMheWQq+WIpOaWrVxuICogQHBhcmFtICB7bnVtYmVyfSAgeDBcbiAqIEBwYXJhbSAge251bWJlcn0gIHkwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MVxuICogQHBhcmFtICB7bnVtYmVyfSAgeTFcbiAqIEBwYXJhbSAge251bWJlcn0gIHgyXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MlxuICogQHBhcmFtICB7bnVtYmVyfSAgbGluZVdpZHRoXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb250YWluU3Ryb2tlKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIGxpbmVXaWR0aCwgeCwgeSkge1xuICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIF9sID0gbGluZVdpZHRoOyAvLyBRdWljayByZWplY3RcblxuICBpZiAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wgJiYgeSA+IHkyICsgX2wgfHwgeSA8IHkwIC0gX2wgJiYgeSA8IHkxIC0gX2wgJiYgeSA8IHkyIC0gX2wgfHwgeCA+IHgwICsgX2wgJiYgeCA+IHgxICsgX2wgJiYgeCA+IHgyICsgX2wgfHwgeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wgJiYgeCA8IHgyIC0gX2wpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZCA9IHF1YWRyYXRpY1Byb2plY3RQb2ludCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4LCB5LCBudWxsKTtcbiAgcmV0dXJuIGQgPD0gX2wgLyAyO1xufVxuXG5leHBvcnRzLmNvbnRhaW5TdHJva2UgPSBjb250YWluU3Ryb2tlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb250YWluL3F1YWRyYXRpYy5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF91dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIG5vcm1hbGl6ZVJhZGlhbiA9IF91dGlsLm5vcm1hbGl6ZVJhZGlhbjtcbnZhciBQSTIgPSBNYXRoLlBJICogMjtcbi8qKlxuICog5ZyG5byn5o+P6L655YyF5ZCr5Yik5patXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBjeFxuICogQHBhcmFtICB7bnVtYmVyfSAgY3lcbiAqIEBwYXJhbSAge251bWJlcn0gIHJcbiAqIEBwYXJhbSAge251bWJlcn0gIHN0YXJ0QW5nbGVcbiAqIEBwYXJhbSAge251bWJlcn0gIGVuZEFuZ2xlXG4gKiBAcGFyYW0gIHtib29sZWFufSAgYW50aWNsb2Nrd2lzZVxuICogQHBhcmFtICB7bnVtYmVyfSBsaW5lV2lkdGhcbiAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gY29udGFpblN0cm9rZShjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBfbCA9IGxpbmVXaWR0aDtcbiAgeCAtPSBjeDtcbiAgeSAtPSBjeTtcbiAgdmFyIGQgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cbiAgaWYgKGQgLSBfbCA+IHIgfHwgZCArIF9sIDwgcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpICUgUEkyIDwgMWUtNCkge1xuICAgIC8vIElzIGEgY2lyY2xlXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgIHZhciB0bXAgPSBzdGFydEFuZ2xlO1xuICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHRtcCk7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihzdGFydEFuZ2xlKTtcbiAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gIH1cblxuICBpZiAoc3RhcnRBbmdsZSA+IGVuZEFuZ2xlKSB7XG4gICAgZW5kQW5nbGUgKz0gUEkyO1xuICB9XG5cbiAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih5LCB4KTtcblxuICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgYW5nbGUgKz0gUEkyO1xuICB9XG5cbiAgcmV0dXJuIGFuZ2xlID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgPD0gZW5kQW5nbGUgfHwgYW5nbGUgKyBQSTIgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSArIFBJMiA8PSBlbmRBbmdsZTtcbn1cblxuZXhwb3J0cy5jb250YWluU3Ryb2tlID0gY29udGFpblN0cm9rZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29udGFpbi9hcmMuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQSTIgPSBNYXRoLlBJICogMjtcblxuZnVuY3Rpb24gbm9ybWFsaXplUmFkaWFuKGFuZ2xlKSB7XG4gIGFuZ2xlICU9IFBJMjtcblxuICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgYW5nbGUgKz0gUEkyO1xuICB9XG5cbiAgcmV0dXJuIGFuZ2xlO1xufVxuXG5leHBvcnRzLm5vcm1hbGl6ZVJhZGlhbiA9IG5vcm1hbGl6ZVJhZGlhbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29udGFpbi91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiB3aW5kaW5nTGluZSh4MCwgeTAsIHgxLCB5MSwgeCwgeSkge1xuICBpZiAoeSA+IHkwICYmIHkgPiB5MSB8fCB5IDwgeTAgJiYgeSA8IHkxKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gLy8gSWdub3JlIGhvcml6b250YWwgbGluZVxuXG5cbiAgaWYgKHkxID09PSB5MCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIGRpciA9IHkxIDwgeTAgPyAxIDogLTE7XG4gIHZhciB0ID0gKHkgLSB5MCkgLyAoeTEgLSB5MCk7IC8vIEF2b2lkIHdpbmRpbmcgZXJyb3Igd2hlbiBpbnRlcnNlY3Rpb24gcG9pbnQgaXMgdGhlIGNvbm5lY3QgcG9pbnQgb2YgdHdvIGxpbmUgb2YgcG9seWdvblxuXG4gIGlmICh0ID09PSAxIHx8IHQgPT09IDApIHtcbiAgICBkaXIgPSB5MSA8IHkwID8gMC41IDogLTAuNTtcbiAgfVxuXG4gIHZhciB4XyA9IHQgKiAoeDEgLSB4MCkgKyB4MDtcbiAgcmV0dXJuIHhfID4geCA/IGRpciA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2luZGluZ0xpbmU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vd2luZGluZ0xpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXR0ZXJuID0gZnVuY3Rpb24gKGltYWdlLCByZXBlYXQpIHtcbiAgLy8gU2hvdWxkIGRvIG5vdGhpbmcgbW9yZSBpbiB0aGlzIGNvbnN0cnVjdG9yLiBCZWNhdXNlIGdyYWRpZW50IGNhbiBiZVxuICAvLyBkZWNsYXJkIGJ5IGBjb2xvcjoge2ltYWdlOiAuLi59YCwgd2hlcmUgdGhpcyBjb25zdHJ1Y3RvciB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgdGhpcy5yZXBlYXQgPSByZXBlYXQ7IC8vIENhbiBiZSBjbG9uZWRcblxuICB0aGlzLnR5cGUgPSAncGF0dGVybic7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS5nZXRDYW52YXNQYXR0ZXJuID0gZnVuY3Rpb24gKGN0eCkge1xuICByZXR1cm4gY3R4LmNyZWF0ZVBhdHRlcm4odGhpcy5pbWFnZSwgdGhpcy5yZXBlYXQgfHwgJ3JlcGVhdCcpO1xufTtcblxudmFyIF9kZWZhdWx0ID0gUGF0dGVybjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0dGVybi5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdGhQcm94eSA9IHJlcXVpcmUoXCIuLi9jb3JlL1BhdGhQcm94eVwiKTtcblxudmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciB2MkFwcGx5VHJhbnNmb3JtID0gX3ZlY3Rvci5hcHBseVRyYW5zZm9ybTtcbnZhciBDTUQgPSBQYXRoUHJveHkuQ01EO1xudmFyIHBvaW50cyA9IFtbXSwgW10sIFtdXTtcbnZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbnZhciBtYXRoQXRhbjIgPSBNYXRoLmF0YW4yO1xuXG5mdW5jdGlvbiBfZGVmYXVsdChwYXRoLCBtKSB7XG4gIHZhciBkYXRhID0gcGF0aC5kYXRhO1xuICB2YXIgY21kO1xuICB2YXIgblBvaW50O1xuICB2YXIgaTtcbiAgdmFyIGo7XG4gIHZhciBrO1xuICB2YXIgcDtcbiAgdmFyIE0gPSBDTUQuTTtcbiAgdmFyIEMgPSBDTUQuQztcbiAgdmFyIEwgPSBDTUQuTDtcbiAgdmFyIFIgPSBDTUQuUjtcbiAgdmFyIEEgPSBDTUQuQTtcbiAgdmFyIFEgPSBDTUQuUTtcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgIGNtZCA9IGRhdGFbaSsrXTtcbiAgICBqID0gaTtcbiAgICBuUG9pbnQgPSAwO1xuXG4gICAgc3dpdGNoIChjbWQpIHtcbiAgICAgIGNhc2UgTTpcbiAgICAgICAgblBvaW50ID0gMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTDpcbiAgICAgICAgblBvaW50ID0gMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQzpcbiAgICAgICAgblBvaW50ID0gMztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUTpcbiAgICAgICAgblBvaW50ID0gMjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQTpcbiAgICAgICAgdmFyIHggPSBtWzRdO1xuICAgICAgICB2YXIgeSA9IG1bNV07XG4gICAgICAgIHZhciBzeCA9IG1hdGhTcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0pO1xuICAgICAgICB2YXIgc3kgPSBtYXRoU3FydChtWzJdICogbVsyXSArIG1bM10gKiBtWzNdKTtcbiAgICAgICAgdmFyIGFuZ2xlID0gbWF0aEF0YW4yKC1tWzFdIC8gc3ksIG1bMF0gLyBzeCk7IC8vIGN4XG5cbiAgICAgICAgZGF0YVtpXSAqPSBzeDtcbiAgICAgICAgZGF0YVtpKytdICs9IHg7IC8vIGN5XG5cbiAgICAgICAgZGF0YVtpXSAqPSBzeTtcbiAgICAgICAgZGF0YVtpKytdICs9IHk7IC8vIFNjYWxlIHJ4IGFuZCByeVxuICAgICAgICAvLyBGSVhNRSBBc3N1bWUgcHNpIGlzIDAgaGVyZVxuXG4gICAgICAgIGRhdGFbaSsrXSAqPSBzeDtcbiAgICAgICAgZGF0YVtpKytdICo9IHN5OyAvLyBTdGFydCBhbmdsZVxuXG4gICAgICAgIGRhdGFbaSsrXSArPSBhbmdsZTsgLy8gZW5kIGFuZ2xlXG5cbiAgICAgICAgZGF0YVtpKytdICs9IGFuZ2xlOyAvLyBGSVhNRSBwc2lcblxuICAgICAgICBpICs9IDI7XG4gICAgICAgIGogPSBpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBSOlxuICAgICAgICAvLyB4MCwgeTBcbiAgICAgICAgcFswXSA9IGRhdGFbaSsrXTtcbiAgICAgICAgcFsxXSA9IGRhdGFbaSsrXTtcbiAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTtcbiAgICAgICAgZGF0YVtqKytdID0gcFswXTtcbiAgICAgICAgZGF0YVtqKytdID0gcFsxXTsgLy8geDEsIHkxXG5cbiAgICAgICAgcFswXSArPSBkYXRhW2krK107XG4gICAgICAgIHBbMV0gKz0gZGF0YVtpKytdO1xuICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pO1xuICAgICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgICBkYXRhW2orK10gPSBwWzFdO1xuICAgIH1cblxuICAgIGZvciAoayA9IDA7IGsgPCBuUG9pbnQ7IGsrKykge1xuICAgICAgdmFyIHAgPSBwb2ludHNba107XG4gICAgICBwWzBdID0gZGF0YVtpKytdO1xuICAgICAgcFsxXSA9IGRhdGFbaSsrXTtcbiAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7IC8vIFdyaXRlIGJhY2tcblxuICAgICAgZGF0YVtqKytdID0gcFswXTtcbiAgICAgIGRhdGFbaisrXSA9IHBbMV07XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL3Rvb2wvdHJhbnNmb3JtUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBjb2xvclN0b3BzXG4gKi9cbnZhciBHcmFkaWVudCA9IGZ1bmN0aW9uIChjb2xvclN0b3BzKSB7XG4gIHRoaXMuY29sb3JTdG9wcyA9IGNvbG9yU3RvcHMgfHwgW107XG59O1xuXG5HcmFkaWVudC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBHcmFkaWVudCxcbiAgYWRkQ29sb3JTdG9wOiBmdW5jdGlvbiAob2Zmc2V0LCBjb2xvcikge1xuICAgIHRoaXMuY29sb3JTdG9wcy5wdXNoKHtcbiAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgY29sb3I6IGNvbG9yXG4gICAgfSk7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBHcmFkaWVudDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvR3JhZGllbnQuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFRPRE8gRHJhZ2dhYmxlIGZvciBncm91cFxuLy8gRklYTUUgRHJhZ2dhYmxlIG9uIGVsZW1lbnQgd2hpY2ggaGFzIHBhcmVudCByb3RhdGlvbiBvciBzY2FsZVxuZnVuY3Rpb24gRHJhZ2dhYmxlKCkge1xuICB0aGlzLm9uKCdtb3VzZWRvd24nLCB0aGlzLl9kcmFnU3RhcnQsIHRoaXMpO1xuICB0aGlzLm9uKCdtb3VzZW1vdmUnLCB0aGlzLl9kcmFnLCB0aGlzKTtcbiAgdGhpcy5vbignbW91c2V1cCcsIHRoaXMuX2RyYWdFbmQsIHRoaXMpO1xuICB0aGlzLm9uKCdnbG9iYWxvdXQnLCB0aGlzLl9kcmFnRW5kLCB0aGlzKTsgLy8gdGhpcy5fZHJvcFRhcmdldCA9IG51bGw7XG4gIC8vIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gbnVsbDtcbiAgLy8gdGhpcy5feCA9IDA7XG4gIC8vIHRoaXMuX3kgPSAwO1xufVxuXG5EcmFnZ2FibGUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRHJhZ2dhYmxlLFxuICBfZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBkcmFnZ2luZ1RhcmdldCA9IGUudGFyZ2V0O1xuXG4gICAgaWYgKGRyYWdnaW5nVGFyZ2V0ICYmIGRyYWdnaW5nVGFyZ2V0LmRyYWdnYWJsZSkge1xuICAgICAgdGhpcy5fZHJhZ2dpbmdUYXJnZXQgPSBkcmFnZ2luZ1RhcmdldDtcbiAgICAgIGRyYWdnaW5nVGFyZ2V0LmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3ggPSBlLm9mZnNldFg7XG4gICAgICB0aGlzLl95ID0gZS5vZmZzZXRZO1xuICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShkcmFnZ2luZ1RhcmdldCwgZSksICdkcmFnc3RhcnQnLCBlLmV2ZW50KTtcbiAgICB9XG4gIH0sXG4gIF9kcmFnOiBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBkcmFnZ2luZ1RhcmdldCA9IHRoaXMuX2RyYWdnaW5nVGFyZ2V0O1xuXG4gICAgaWYgKGRyYWdnaW5nVGFyZ2V0KSB7XG4gICAgICB2YXIgeCA9IGUub2Zmc2V0WDtcbiAgICAgIHZhciB5ID0gZS5vZmZzZXRZO1xuICAgICAgdmFyIGR4ID0geCAtIHRoaXMuX3g7XG4gICAgICB2YXIgZHkgPSB5IC0gdGhpcy5feTtcbiAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgdGhpcy5feSA9IHk7XG4gICAgICBkcmFnZ2luZ1RhcmdldC5kcmlmdChkeCwgZHksIGUpO1xuICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShkcmFnZ2luZ1RhcmdldCwgZSksICdkcmFnJywgZS5ldmVudCk7XG4gICAgICB2YXIgZHJvcFRhcmdldCA9IHRoaXMuZmluZEhvdmVyKHgsIHksIGRyYWdnaW5nVGFyZ2V0KS50YXJnZXQ7XG4gICAgICB2YXIgbGFzdERyb3BUYXJnZXQgPSB0aGlzLl9kcm9wVGFyZ2V0O1xuICAgICAgdGhpcy5fZHJvcFRhcmdldCA9IGRyb3BUYXJnZXQ7XG5cbiAgICAgIGlmIChkcmFnZ2luZ1RhcmdldCAhPT0gZHJvcFRhcmdldCkge1xuICAgICAgICBpZiAobGFzdERyb3BUYXJnZXQgJiYgZHJvcFRhcmdldCAhPT0gbGFzdERyb3BUYXJnZXQpIHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKGxhc3REcm9wVGFyZ2V0LCBlKSwgJ2RyYWdsZWF2ZScsIGUuZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRyb3BUYXJnZXQgJiYgZHJvcFRhcmdldCAhPT0gbGFzdERyb3BUYXJnZXQpIHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKGRyb3BUYXJnZXQsIGUpLCAnZHJhZ2VudGVyJywgZS5ldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIF9kcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBkcmFnZ2luZ1RhcmdldCA9IHRoaXMuX2RyYWdnaW5nVGFyZ2V0O1xuXG4gICAgaWYgKGRyYWdnaW5nVGFyZ2V0KSB7XG4gICAgICBkcmFnZ2luZ1RhcmdldC5kcmFnZ2luZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0oZHJhZ2dpbmdUYXJnZXQsIGUpLCAnZHJhZ2VuZCcsIGUuZXZlbnQpO1xuXG4gICAgaWYgKHRoaXMuX2Ryb3BUYXJnZXQpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0odGhpcy5fZHJvcFRhcmdldCwgZSksICdkcm9wJywgZS5ldmVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZHJhZ2dpbmdUYXJnZXQgPSBudWxsO1xuICAgIHRoaXMuX2Ryb3BUYXJnZXQgPSBudWxsO1xuICB9XG59O1xuXG5mdW5jdGlvbiBwYXJhbSh0YXJnZXQsIGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICB0b3BUYXJnZXQ6IGUgJiYgZS50b3BUYXJnZXRcbiAgfTtcbn1cblxudmFyIF9kZWZhdWx0ID0gRHJhZ2dhYmxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvbWl4aW4vRHJhZ2dhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKFwiLi4vRWxlbWVudFwiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuLi9jb3JlL0JvdW5kaW5nUmVjdFwiKTtcblxuLyoqXG4gKiBHcm91cOaYr+S4gOS4quWuueWZqO+8jOWPr+S7peaPkuWFpeWtkOiKgueCue+8jEdyb3Vw55qE5Y+Y5o2i5Lmf5Lya6KKr5bqU55So5Yiw5a2Q6IqC54K55LiKXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9Hcm91cFxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgR3JvdXAgPSByZXF1aXJlKCd6cmVuZGVyL2NvbnRhaW5lci9Hcm91cCcpO1xuICogICAgIHZhciBDaXJjbGUgPSByZXF1aXJlKCd6cmVuZGVyL2dyYXBoaWMvc2hhcGUvQ2lyY2xlJyk7XG4gKiAgICAgdmFyIGcgPSBuZXcgR3JvdXAoKTtcbiAqICAgICBnLnBvc2l0aW9uWzBdID0gMTAwO1xuICogICAgIGcucG9zaXRpb25bMV0gPSAxMDA7XG4gKiAgICAgZy5hZGQobmV3IENpcmNsZSh7XG4gKiAgICAgICAgIHN0eWxlOiB7XG4gKiAgICAgICAgICAgICB4OiAxMDAsXG4gKiAgICAgICAgICAgICB5OiAxMDAsXG4gKiAgICAgICAgICAgICByOiAyMCxcbiAqICAgICAgICAgfVxuICogICAgIH0pKTtcbiAqICAgICB6ci5hZGQoZyk7XG4gKi9cblxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9Hcm91cFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bFxuICovXG52YXIgR3JvdXAgPSBmdW5jdGlvbiAob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgRWxlbWVudC5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIGZvciAodmFyIGtleSBpbiBvcHRzKSB7XG4gICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdGhpc1trZXldID0gb3B0c1trZXldO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2NoaWxkcmVuID0gW107XG4gIHRoaXMuX19zdG9yYWdlID0gbnVsbDtcbiAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcbn07XG5cbkdyb3VwLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEdyb3VwLFxuICBpc0dyb3VwOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdHlwZTogJ2dyb3VwJyxcblxuICAvKipcbiAgICog5omA5pyJ5a2Q5a2Z5YWD57Sg5piv5ZCm5ZON5bqU6byg5qCH5LqL5Lu2XG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9jb250YWluZXIvR3JvdXAjc2lsZW50XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL0VsZW1lbnQ+fVxuICAgKi9cbiAgY2hpbGRyZW46IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4uc2xpY2UoKTtcbiAgfSxcblxuICAvKipcbiAgICog6I635Y+W5oyH5a6aIGluZGV4IOeahOWEv+WtkOiKgueCuVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGlkeFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9FbGVtZW50fVxuICAgKi9cbiAgY2hpbGRBdDogZnVuY3Rpb24gKGlkeCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbltpZHhdO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bmjIflrprlkI3lrZfnmoTlhL/lrZDoioLngrlcbiAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gICAqL1xuICBjaGlsZE9mTmFtZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjaGlsZHJlbltpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbltpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGNoaWxkQ291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqDlrZDoioLngrnliLDmnIDlkI5cbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBjaGlsZFxuICAgKi9cbiAgYWRkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgJiYgY2hpbGQgIT09IHRoaXMgJiYgY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XG4gICAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKGNoaWxkKTtcblxuICAgICAgdGhpcy5fZG9BZGQoY2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqDlrZDoioLngrnlnKggbmV4dFNpYmxpbmcg5LmL5YmNXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gY2hpbGRcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBuZXh0U2libGluZ1xuICAgKi9cbiAgYWRkQmVmb3JlOiBmdW5jdGlvbiAoY2hpbGQsIG5leHRTaWJsaW5nKSB7XG4gICAgaWYgKGNoaWxkICYmIGNoaWxkICE9PSB0aGlzICYmIGNoaWxkLnBhcmVudCAhPT0gdGhpcyAmJiBuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5wYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgdmFyIGlkeCA9IGNoaWxkcmVuLmluZGV4T2YobmV4dFNpYmxpbmcpO1xuXG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGlkeCwgMCwgY2hpbGQpO1xuXG4gICAgICAgIHRoaXMuX2RvQWRkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgX2RvQWRkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQucGFyZW50KSB7XG4gICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlKGNoaWxkKTtcbiAgICB9XG5cbiAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgIHZhciBzdG9yYWdlID0gdGhpcy5fX3N0b3JhZ2U7XG4gICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuXG4gICAgaWYgKHN0b3JhZ2UgJiYgc3RvcmFnZSAhPT0gY2hpbGQuX19zdG9yYWdlKSB7XG4gICAgICBzdG9yYWdlLmFkZFRvU3RvcmFnZShjaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgIGNoaWxkLmFkZENoaWxkcmVuVG9TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHpyICYmIHpyLnJlZnJlc2goKTtcbiAgfSxcblxuICAvKipcbiAgICog56e76Zmk5a2Q6IqC54K5XG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gY2hpbGRcbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgIHZhciBzdG9yYWdlID0gdGhpcy5fX3N0b3JhZ2U7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgdmFyIGlkeCA9IHpyVXRpbC5pbmRleE9mKGNoaWxkcmVuLCBjaGlsZCk7XG5cbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY2hpbGRyZW4uc3BsaWNlKGlkeCwgMSk7XG4gICAgY2hpbGQucGFyZW50ID0gbnVsbDtcblxuICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICBzdG9yYWdlLmRlbEZyb21TdG9yYWdlKGNoaWxkKTtcblxuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB6ciAmJiB6ci5yZWZyZXNoKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOenu+mZpOaJgOacieWtkOiKgueCuVxuICAgKi9cbiAgcmVtb3ZlQWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICB2YXIgY2hpbGQ7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICAgIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgIH1cblxuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOmBjeWOhuaJgOacieWtkOiKgueCuVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICovXG4gIGVhY2hDaGlsZDogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGNiLmNhbGwoY29udGV4dCwgY2hpbGQsIGkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7HluqbkvJjlhYjpgY3ljobmiYDmnInlrZDlrZnoioLngrlcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAqL1xuICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICBjYi5jYWxsKGNvbnRleHQsIGNoaWxkKTtcblxuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgICAgY2hpbGQudHJhdmVyc2UoY2IsIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRDaGlsZHJlblRvU3RvcmFnZTogZnVuY3Rpb24gKHN0b3JhZ2UpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgIHN0b3JhZ2UuYWRkVG9TdG9yYWdlKGNoaWxkKTtcblxuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgY2hpbGQuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBkZWxDaGlsZHJlbkZyb21TdG9yYWdlOiBmdW5jdGlvbiAoc3RvcmFnZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuICAgICAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZShjaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgIGNoaWxkLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBkaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgKi9cbiAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoaW5jbHVkZUNoaWxkcmVuKSB7XG4gICAgLy8gVE9ETyBDYWNoaW5nXG4gICAgdmFyIHJlY3QgPSBudWxsO1xuICAgIHZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKTtcbiAgICB2YXIgY2hpbGRyZW4gPSBpbmNsdWRlQ2hpbGRyZW4gfHwgdGhpcy5fY2hpbGRyZW47XG4gICAgdmFyIHRtcE1hdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChjaGlsZC5pZ25vcmUgfHwgY2hpbGQuaW52aXNpYmxlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGRSZWN0ID0gY2hpbGQuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICB2YXIgdHJhbnNmb3JtID0gY2hpbGQuZ2V0TG9jYWxUcmFuc2Zvcm0odG1wTWF0KTsgLy8gVE9ET1xuICAgICAgLy8gVGhlIGJvdW5kaW5nUmVjdCBjYWNsdWF0ZWQgYnkgdHJhbnNmb3JtaW5nIG9yaWdpbmFsXG4gICAgICAvLyByZWN0IG1heSBiZSBiaWdnZXIgdGhhbiB0aGUgYWN0dWFsIGJ1bmRpbmdSZWN0IHdoZW4gcm90YXRpb25cbiAgICAgIC8vIGlzIHVzZWQuIChDb25zaWRlciBhIGNpcmNsZSByb3RhdGVkIGFnaW5zdCBpdHMgY2VudGVyLCB3aGVyZVxuICAgICAgLy8gdGhlIGFjdHVhbCBib3VuZGluZ1JlY3Qgc2hvdWxkIGJlIHRoZSBzYW1lIGFzIHRoYXQgbm90IGJlXG4gICAgICAvLyByb3RhdGVkLikgQnV0IHdlIGNhbiBub3QgZmluZCBiZXR0ZXIgYXBwcm9hY2ggdG8gY2FsY3VsYXRlXG4gICAgICAvLyBhY3R1YWwgYm91bmRpbmdSZWN0IHlldCwgY29uc2lkZXJpbmcgcGVyZm9ybWFuY2UuXG5cbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdG1wUmVjdC5jb3B5KGNoaWxkUmVjdCk7XG4gICAgICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgICAgcmVjdCA9IHJlY3QgfHwgdG1wUmVjdC5jbG9uZSgpO1xuICAgICAgICByZWN0LnVuaW9uKHRtcFJlY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjdCA9IHJlY3QgfHwgY2hpbGRSZWN0LmNsb25lKCk7XG4gICAgICAgIHJlY3QudW5pb24oY2hpbGRSZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVjdCB8fCB0bXBSZWN0O1xuICB9XG59O1xuenJVdGlsLmluaGVyaXRzKEdyb3VwLCBFbGVtZW50KTtcbnZhciBfZGVmYXVsdCA9IEdyb3VwO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKFwiLi9EaXNwbGF5YWJsZVwiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuLi9jb3JlL0JvdW5kaW5nUmVjdFwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBpbWFnZUhlbHBlciA9IHJlcXVpcmUoXCIuL2hlbHBlci9pbWFnZVwiKTtcblxuLyoqXG4gKiBAYWxpYXMgenJlbmRlci9ncmFwaGljL0ltYWdlXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbmZ1bmN0aW9uIFpJbWFnZShvcHRzKSB7XG4gIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG59XG5cblpJbWFnZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBaSW1hZ2UsXG4gIHR5cGU6ICdpbWFnZScsXG4gIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHZhciBzcmMgPSBzdHlsZS5pbWFnZTsgLy8gTXVzdCBiaW5kIGVhY2ggdGltZVxuXG4gICAgc3R5bGUuYmluZChjdHgsIHRoaXMsIHByZXZFbCk7XG4gICAgdmFyIGltYWdlID0gdGhpcy5faW1hZ2UgPSBpbWFnZUhlbHBlci5jcmVhdGVPclVwZGF0ZUltYWdlKHNyYywgdGhpcy5faW1hZ2UsIHRoaXMsIHRoaXMub25sb2FkKTtcblxuICAgIGlmICghaW1hZ2UgfHwgIWltYWdlSGVscGVyLmlzSW1hZ2VSZWFkeShpbWFnZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIOWbvueJh+W3sue7j+WKoOi9veWujOaIkFxuICAgIC8vIGlmIChpbWFnZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09ICdJTUcnKSB7XG4gICAgLy8gICAgIGlmICghaW1hZ2UuY29tcGxldGUpIHtcbiAgICAvLyAgICAgICAgIHJldHVybjtcbiAgICAvLyAgICAgfVxuICAgIC8vIH1cbiAgICAvLyBFbHNlIGlzIGNhbnZhc1xuXG5cbiAgICB2YXIgeCA9IHN0eWxlLnggfHwgMDtcbiAgICB2YXIgeSA9IHN0eWxlLnkgfHwgMDtcbiAgICB2YXIgd2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gc3R5bGUuaGVpZ2h0O1xuICAgIHZhciBhc3BlY3QgPSBpbWFnZS53aWR0aCAvIGltYWdlLmhlaWdodDtcblxuICAgIGlmICh3aWR0aCA9PSBudWxsICYmIGhlaWdodCAhPSBudWxsKSB7XG4gICAgICAvLyBLZWVwIGltYWdlL2hlaWdodCByYXRpb1xuICAgICAgd2lkdGggPSBoZWlnaHQgKiBhc3BlY3Q7XG4gICAgfSBlbHNlIGlmIChoZWlnaHQgPT0gbnVsbCAmJiB3aWR0aCAhPSBudWxsKSB7XG4gICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdDtcbiAgICB9IGVsc2UgaWYgKHdpZHRoID09IG51bGwgJiYgaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgIHdpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgfSAvLyDorr7nva50cmFuc2Zvcm1cblxuXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcblxuICAgIGlmIChzdHlsZS5zV2lkdGggJiYgc3R5bGUuc0hlaWdodCkge1xuICAgICAgdmFyIHN4ID0gc3R5bGUuc3ggfHwgMDtcbiAgICAgIHZhciBzeSA9IHN0eWxlLnN5IHx8IDA7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBzeCwgc3ksIHN0eWxlLnNXaWR0aCwgc3R5bGUuc0hlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIGlmIChzdHlsZS5zeCAmJiBzdHlsZS5zeSkge1xuICAgICAgdmFyIHN4ID0gc3R5bGUuc3g7XG4gICAgICB2YXIgc3kgPSBzdHlsZS5zeTtcbiAgICAgIHZhciBzV2lkdGggPSB3aWR0aCAtIHN4O1xuICAgICAgdmFyIHNIZWlnaHQgPSBoZWlnaHQgLSBzeTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIHN4LCBzeSwgc1dpZHRoLCBzSGVpZ2h0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7IC8vIERyYXcgcmVjdCB0ZXh0XG5cbiAgICBpZiAoc3R5bGUudGV4dCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmRyYXdSZWN0VGV4dChjdHgsIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgIH1cbiAgfSxcbiAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcblxuICAgIGlmICghdGhpcy5fcmVjdCkge1xuICAgICAgdGhpcy5fcmVjdCA9IG5ldyBCb3VuZGluZ1JlY3Qoc3R5bGUueCB8fCAwLCBzdHlsZS55IHx8IDAsIHN0eWxlLndpZHRoIHx8IDAsIHN0eWxlLmhlaWdodCB8fCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgfVxufTtcbnpyVXRpbC5pbmhlcml0cyhaSW1hZ2UsIERpc3BsYXlhYmxlKTtcbnZhciBfZGVmYXVsdCA9IFpJbWFnZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEaXNwbGF5YWJsZSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlhYmxlXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIHRleHRDb250YWluID0gcmVxdWlyZShcIi4uL2NvbnRhaW4vdGV4dFwiKTtcblxudmFyIHRleHRIZWxwZXIgPSByZXF1aXJlKFwiLi9oZWxwZXIvdGV4dFwiKTtcblxuLyoqXG4gKiBAYWxpYXMgenJlbmRlci9ncmFwaGljL1RleHRcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xudmFyIFRleHQgPSBmdW5jdGlvbiAob3B0cykge1xuICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgRGlzcGxheWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbn07XG5cblRleHQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVGV4dCxcbiAgdHlwZTogJ3RleHQnLFxuICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTsgLy8gT3B0aW1pemUsIGF2b2lkIG5vcm1hbGl6ZSBldmVyeSB0aW1lLlxuXG4gICAgdGhpcy5fX2RpcnR5ICYmIHRleHRIZWxwZXIubm9ybWFsaXplVGV4dFN0eWxlKHN0eWxlLCB0cnVlKTsgLy8gVXNlIHByb3BzIHdpdGggcHJlZml4ICd0ZXh0Jy5cblxuICAgIHN0eWxlLmZpbGwgPSBzdHlsZS5zdHJva2UgPSBzdHlsZS5zaGFkb3dCbHVyID0gc3R5bGUuc2hhZG93Q29sb3IgPSBzdHlsZS5zaGFkb3dPZmZzZXRYID0gc3R5bGUuc2hhZG93T2Zmc2V0WSA9IG51bGw7XG4gICAgdmFyIHRleHQgPSBzdHlsZS50ZXh0OyAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuXG4gICAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTsgLy8gQWx3YXlzIGJpbmQgc3R5bGVcblxuICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuXG4gICAgaWYgKCF0ZXh0SGVscGVyLm5lZWREcmF3VGV4dCh0ZXh0LCBzdHlsZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuICAgIHRleHRIZWxwZXIucmVuZGVyVGV4dCh0aGlzLCBjdHgsIHRleHQsIHN0eWxlKTtcbiAgICB0aGlzLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTtcbiAgfSxcbiAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTsgLy8gT3B0aW1pemUsIGF2b2lkIG5vcm1hbGl6ZSBldmVyeSB0aW1lLlxuXG4gICAgdGhpcy5fX2RpcnR5ICYmIHRleHRIZWxwZXIubm9ybWFsaXplVGV4dFN0eWxlKHN0eWxlLCB0cnVlKTtcblxuICAgIGlmICghdGhpcy5fcmVjdCkge1xuICAgICAgdmFyIHRleHQgPSBzdHlsZS50ZXh0O1xuICAgICAgdGV4dCAhPSBudWxsID8gdGV4dCArPSAnJyA6IHRleHQgPSAnJztcbiAgICAgIHZhciByZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KHN0eWxlLnRleHQgKyAnJywgc3R5bGUuZm9udCwgc3R5bGUudGV4dEFsaWduLCBzdHlsZS50ZXh0VmVydGljYWxBbGlnbiwgc3R5bGUudGV4dFBhZGRpbmcsIHN0eWxlLnJpY2gpO1xuICAgICAgcmVjdC54ICs9IHN0eWxlLnggfHwgMDtcbiAgICAgIHJlY3QueSArPSBzdHlsZS55IHx8IDA7XG5cbiAgICAgIGlmICh0ZXh0SGVscGVyLmdldFN0cm9rZShzdHlsZS50ZXh0U3Ryb2tlLCBzdHlsZS50ZXh0U3Ryb2tlV2lkdGgpKSB7XG4gICAgICAgIHZhciB3ID0gc3R5bGUudGV4dFN0cm9rZVdpZHRoO1xuICAgICAgICByZWN0LnggLT0gdyAvIDI7XG4gICAgICAgIHJlY3QueSAtPSB3IC8gMjtcbiAgICAgICAgcmVjdC53aWR0aCArPSB3O1xuICAgICAgICByZWN0LmhlaWdodCArPSB3O1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZWN0ID0gcmVjdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgfVxufTtcbnpyVXRpbC5pbmhlcml0cyhUZXh0LCBEaXNwbGF5YWJsZSk7XG52YXIgX2RlZmF1bHQgPSBUZXh0O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9UZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG4vKipcbiAqIOWchuW9olxuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL0NpcmNsZVxuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdjaXJjbGUnLFxuICBzaGFwZToge1xuICAgIGN4OiAwLFxuICAgIGN5OiAwLFxuICAgIHI6IDBcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSwgaW5CdW5kbGUpIHtcbiAgICAvLyBCZXR0ZXIgc3Ryb2tpbmcgaW4gU2hhcGVCdW5kbGVcbiAgICAvLyBBbHdheXMgZG8gaXQgbWF5IGhhdmUgcGVyZm9ybWVuY2UgaXNzdWUgKCBmaWxsIG1heSBiZSAyeCBtb3JlIGNvc3QpXG4gICAgaWYgKGluQnVuZGxlKSB7XG4gICAgICBjdHgubW92ZVRvKHNoYXBlLmN4ICsgc2hhcGUuciwgc2hhcGUuY3kpO1xuICAgIH0gLy8gZWxzZSB7XG4gICAgLy8gICAgIGlmIChjdHguYWxsb2NhdGUgJiYgIWN0eC5kYXRhLmxlbmd0aCkge1xuICAgIC8vICAgICAgICAgY3R4LmFsbG9jYXRlKGN0eC5DTURfTUVNX1NJWkUuQSk7XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG4gICAgLy8gQmV0dGVyIHN0cm9raW5nIGluIFNoYXBlQnVuZGxlXG4gICAgLy8gY3R4Lm1vdmVUbyhzaGFwZS5jeCArIHNoYXBlLnIsIHNoYXBlLmN5KTtcblxuXG4gICAgY3R4LmFyYyhzaGFwZS5jeCwgc2hhcGUuY3ksIHNoYXBlLnIsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQ2lyY2xlLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG52YXIgZml4Q2xpcFdpdGhTaGFkb3cgPSByZXF1aXJlKFwiLi4vaGVscGVyL2ZpeENsaXBXaXRoU2hhZG93XCIpO1xuXG4vKipcbiAqIOaJh+W9olxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvU2VjdG9yXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ3NlY3RvcicsXG4gIHNoYXBlOiB7XG4gICAgY3g6IDAsXG4gICAgY3k6IDAsXG4gICAgcjA6IDAsXG4gICAgcjogMCxcbiAgICBzdGFydEFuZ2xlOiAwLFxuICAgIGVuZEFuZ2xlOiBNYXRoLlBJICogMixcbiAgICBjbG9ja3dpc2U6IHRydWVcbiAgfSxcbiAgYnJ1c2g6IGZpeENsaXBXaXRoU2hhZG93KFBhdGgucHJvdG90eXBlLmJydXNoKSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICB2YXIgcjAgPSBNYXRoLm1heChzaGFwZS5yMCB8fCAwLCAwKTtcbiAgICB2YXIgciA9IE1hdGgubWF4KHNoYXBlLnIsIDApO1xuICAgIHZhciBzdGFydEFuZ2xlID0gc2hhcGUuc3RhcnRBbmdsZTtcbiAgICB2YXIgZW5kQW5nbGUgPSBzaGFwZS5lbmRBbmdsZTtcbiAgICB2YXIgY2xvY2t3aXNlID0gc2hhcGUuY2xvY2t3aXNlO1xuICAgIHZhciB1bml0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgIHZhciB1bml0WSA9IE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuICAgIGN0eC5tb3ZlVG8odW5pdFggKiByMCArIHgsIHVuaXRZICogcjAgKyB5KTtcbiAgICBjdHgubGluZVRvKHVuaXRYICogciArIHgsIHVuaXRZICogciArIHkpO1xuICAgIGN0eC5hcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsICFjbG9ja3dpc2UpO1xuICAgIGN0eC5saW5lVG8oTWF0aC5jb3MoZW5kQW5nbGUpICogcjAgKyB4LCBNYXRoLnNpbihlbmRBbmdsZSkgKiByMCArIHkpO1xuXG4gICAgaWYgKHIwICE9PSAwKSB7XG4gICAgICBjdHguYXJjKHgsIHksIHIwLCBlbmRBbmdsZSwgc3RhcnRBbmdsZSwgY2xvY2t3aXNlKTtcbiAgICB9XG5cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1NlY3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGVudiA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL2VudlwiKTtcblxuLy8gRml4IHdlaXJkIGJ1ZyBpbiBzb21lIHZlcnNpb24gb2YgSUUxMSAobGlrZSAxMS4wLjk2MDAuMTc4KiopLFxuLy8gd2hlcmUgZXhjZXB0aW9uIFwidW5leHBlY3RlZCBjYWxsIHRvIG1ldGhvZCBvciBwcm9wZXJ0eSBhY2Nlc3NcIlxuLy8gbWlnaHQgYmUgdGhyb3duIHdoZW4gY2FsbGluZyBjdHguZmlsbCBvciBjdHguc3Ryb2tlIGFmdGVyIGEgcGF0aFxuLy8gd2hvc2UgYXJlYSBzaXplIGlzIHplcm8gaXMgZHJhd24gYW5kIGN0eC5jbGlwKCkgaXMgY2FsbGVkIGFuZFxuLy8gc2hhZG93Qmx1ciBpcyBzZXQuIFNlZSAjNDU3MiwgIzMxMTIsICM1Nzc3LlxuLy8gKGUuZy4sXG4vLyAgY3R4Lm1vdmVUbygxMCwgMTApO1xuLy8gIGN0eC5saW5lVG8oMjAsIDEwKTtcbi8vICBjdHguY2xvc2VQYXRoKCk7XG4vLyAgY3R4LmNsaXAoKTtcbi8vICBjdHguc2hhZG93Qmx1ciA9IDEwO1xuLy8gIC4uLlxuLy8gIGN0eC5maWxsKCk7XG4vLyApXG52YXIgc2hhZG93VGVtcCA9IFtbJ3NoYWRvd0JsdXInLCAwXSwgWydzaGFkb3dDb2xvcicsICcjMDAwJ10sIFsnc2hhZG93T2Zmc2V0WCcsIDBdLCBbJ3NoYWRvd09mZnNldFknLCAwXV07XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KG9yaWduYWxCcnVzaCkge1xuICAvLyB2ZXJzaW9uIHN0cmluZyBjYW4gYmU6ICcxMS4wJ1xuICByZXR1cm4gZW52LmJyb3dzZXIuaWUgJiYgZW52LmJyb3dzZXIudmVyc2lvbiA+PSAxMSA/IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2xpcFBhdGhzID0gdGhpcy5fX2NsaXBQYXRocztcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHZhciBtb2RpZmllZDtcblxuICAgIGlmIChjbGlwUGF0aHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcFBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjbGlwUGF0aCA9IGNsaXBQYXRoc1tpXTtcbiAgICAgICAgdmFyIHNoYXBlID0gY2xpcFBhdGggJiYgY2xpcFBhdGguc2hhcGU7XG4gICAgICAgIHZhciB0eXBlID0gY2xpcFBhdGggJiYgY2xpcFBhdGgudHlwZTtcblxuICAgICAgICBpZiAoc2hhcGUgJiYgKHR5cGUgPT09ICdzZWN0b3InICYmIHNoYXBlLnN0YXJ0QW5nbGUgPT09IHNoYXBlLmVuZEFuZ2xlIHx8IHR5cGUgPT09ICdyZWN0JyAmJiAoIXNoYXBlLndpZHRoIHx8ICFzaGFwZS5oZWlnaHQpKSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2hhZG93VGVtcC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgLy8gSXQgaXMgc2F2ZSB0byBwdXQgc2hhZG93VGVtcCBzdGF0aWMsIGJlY2F1c2Ugc2hhZG93VGVtcFxuICAgICAgICAgICAgLy8gd2lsbCBiZSBhbGwgbW9kaWZpZWQgZWFjaCBpdGVtIGJydXNoIGNhbGxlZC5cbiAgICAgICAgICAgIHNoYWRvd1RlbXBbal1bMl0gPSBzdHlsZVtzaGFkb3dUZW1wW2pdWzBdXTtcbiAgICAgICAgICAgIHN0eWxlW3NoYWRvd1RlbXBbal1bMF1dID0gc2hhZG93VGVtcFtqXVsxXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBvcmlnbmFsQnJ1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzaGFkb3dUZW1wLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHN0eWxlW3NoYWRvd1RlbXBbal1bMF1dID0gc2hhZG93VGVtcFtqXVsyXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gOiBvcmlnbmFsQnJ1c2g7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL2ZpeENsaXBXaXRoU2hhZG93LmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGVjaGFydHPorr7lpIfnjq/looPor4bliKtcbiAqXG4gKiBAZGVzYyBlY2hhcnRz5Z+65LqOQ2FudmFz77yM57qvSmF2YXNjcmlwdOWbvuihqOW6k++8jOaPkOS+m+ebtOingu+8jOeUn+WKqO+8jOWPr+S6pOS6ku+8jOWPr+S4quaAp+WMluWumuWItueahOaVsOaNrue7n+iuoeWbvuihqOOAglxuICogQGF1dGhvciBmaXJlZGVbZmlyZWRlQGZpcmVkZS51c11cbiAqIEBkZXNjIHRoYW5rcyB6ZXB0by5cbiAqL1xudmFyIGVudiA9IHt9O1xuXG5pZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gSW4gbm9kZVxuICBlbnYgPSB7XG4gICAgYnJvd3Nlcjoge30sXG4gICAgb3M6IHt9LFxuICAgIG5vZGU6IHRydWUsXG4gICAgLy8gQXNzdW1lIGNhbnZhcyBpcyBzdXBwb3J0ZWRcbiAgICBjYW52YXNTdXBwb3J0ZWQ6IHRydWUsXG4gICAgc3ZnU3VwcG9ydGVkOiB0cnVlXG4gIH07XG59IGVsc2Uge1xuICBlbnYgPSBkZXRlY3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59XG5cbnZhciBfZGVmYXVsdCA9IGVudjsgLy8gWmVwdG8uanNcbi8vIChjKSAyMDEwLTIwMTMgVGhvbWFzIEZ1Y2hzXG4vLyBaZXB0by5qcyBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuZnVuY3Rpb24gZGV0ZWN0KHVhKSB7XG4gIHZhciBvcyA9IHt9O1xuICB2YXIgYnJvd3NlciA9IHt9OyAvLyB2YXIgd2Via2l0ID0gdWEubWF0Y2goL1dlYltrS11pdFtcXC9dezAsMX0oW1xcZC5dKykvKTtcbiAgLy8gdmFyIGFuZHJvaWQgPSB1YS5tYXRjaCgvKEFuZHJvaWQpOz9bXFxzXFwvXSsoW1xcZC5dKyk/Lyk7XG4gIC8vIHZhciBpcGFkID0gdWEubWF0Y2goLyhpUGFkKS4qT1NcXHMoW1xcZF9dKykvKTtcbiAgLy8gdmFyIGlwb2QgPSB1YS5tYXRjaCgvKGlQb2QpKC4qT1NcXHMoW1xcZF9dKykpPy8pO1xuICAvLyB2YXIgaXBob25lID0gIWlwYWQgJiYgdWEubWF0Y2goLyhpUGhvbmVcXHNPUylcXHMoW1xcZF9dKykvKTtcbiAgLy8gdmFyIHdlYm9zID0gdWEubWF0Y2goLyh3ZWJPU3xocHdPUylbXFxzXFwvXShbXFxkLl0rKS8pO1xuICAvLyB2YXIgdG91Y2hwYWQgPSB3ZWJvcyAmJiB1YS5tYXRjaCgvVG91Y2hQYWQvKTtcbiAgLy8gdmFyIGtpbmRsZSA9IHVhLm1hdGNoKC9LaW5kbGVcXC8oW1xcZC5dKykvKTtcbiAgLy8gdmFyIHNpbGsgPSB1YS5tYXRjaCgvU2lsa1xcLyhbXFxkLl9dKykvKTtcbiAgLy8gdmFyIGJsYWNrYmVycnkgPSB1YS5tYXRjaCgvKEJsYWNrQmVycnkpLipWZXJzaW9uXFwvKFtcXGQuXSspLyk7XG4gIC8vIHZhciBiYjEwID0gdWEubWF0Y2goLyhCQjEwKS4qVmVyc2lvblxcLyhbXFxkLl0rKS8pO1xuICAvLyB2YXIgcmltdGFibGV0b3MgPSB1YS5tYXRjaCgvKFJJTVxcc1RhYmxldFxcc09TKVxccyhbXFxkLl0rKS8pO1xuICAvLyB2YXIgcGxheWJvb2sgPSB1YS5tYXRjaCgvUGxheUJvb2svKTtcbiAgLy8gdmFyIGNocm9tZSA9IHVhLm1hdGNoKC9DaHJvbWVcXC8oW1xcZC5dKykvKSB8fCB1YS5tYXRjaCgvQ3JpT1NcXC8oW1xcZC5dKykvKTtcblxuICB2YXIgZmlyZWZveCA9IHVhLm1hdGNoKC9GaXJlZm94XFwvKFtcXGQuXSspLyk7IC8vIHZhciBzYWZhcmkgPSB3ZWJraXQgJiYgdWEubWF0Y2goL01vYmlsZVxcLy8pICYmICFjaHJvbWU7XG4gIC8vIHZhciB3ZWJ2aWV3ID0gdWEubWF0Y2goLyhpUGhvbmV8aVBvZHxpUGFkKS4qQXBwbGVXZWJLaXQoPyEuKlNhZmFyaSkvKSAmJiAhY2hyb21lO1xuXG4gIHZhciBpZSA9IHVhLm1hdGNoKC9NU0lFXFxzKFtcXGQuXSspLykgLy8gSUUgMTEgVHJpZGVudC83LjA7IHJ2OjExLjBcbiAgfHwgdWEubWF0Y2goL1RyaWRlbnRcXC8uKz9ydjooKFtcXGQuXSspKS8pO1xuICB2YXIgZWRnZSA9IHVhLm1hdGNoKC9FZGdlXFwvKFtcXGQuXSspLyk7IC8vIElFIDEyIGFuZCAxMitcblxuICB2YXIgd2VDaGF0ID0gL21pY3JvbWVzc2VuZ2VyL2kudGVzdCh1YSk7IC8vIFRvZG86IGNsZWFuIHRoaXMgdXAgd2l0aCBhIGJldHRlciBPUy9icm93c2VyIHNlcGVyYXRpb246XG4gIC8vIC0gZGlzY2VybiAobW9yZSkgYmV0d2VlbiBtdWx0aXBsZSBicm93c2VycyBvbiBhbmRyb2lkXG4gIC8vIC0gZGVjaWRlIGlmIGtpbmRsZSBmaXJlIGluIHNpbGsgbW9kZSBpcyBhbmRyb2lkIG9yIG5vdFxuICAvLyAtIEZpcmVmb3ggb24gQW5kcm9pZCBkb2Vzbid0IHNwZWNpZnkgdGhlIEFuZHJvaWQgdmVyc2lvblxuICAvLyAtIHBvc3NpYmx5IGRldmlkZSBpbiBvcywgZGV2aWNlIGFuZCBicm93c2VyIGhhc2hlc1xuICAvLyBpZiAoYnJvd3Nlci53ZWJraXQgPSAhIXdlYmtpdCkgYnJvd3Nlci52ZXJzaW9uID0gd2Via2l0WzFdO1xuICAvLyBpZiAoYW5kcm9pZCkgb3MuYW5kcm9pZCA9IHRydWUsIG9zLnZlcnNpb24gPSBhbmRyb2lkWzJdO1xuICAvLyBpZiAoaXBob25lICYmICFpcG9kKSBvcy5pb3MgPSBvcy5pcGhvbmUgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBob25lWzJdLnJlcGxhY2UoL18vZywgJy4nKTtcbiAgLy8gaWYgKGlwYWQpIG9zLmlvcyA9IG9zLmlwYWQgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBhZFsyXS5yZXBsYWNlKC9fL2csICcuJyk7XG4gIC8vIGlmIChpcG9kKSBvcy5pb3MgPSBvcy5pcG9kID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwb2RbM10gPyBpcG9kWzNdLnJlcGxhY2UoL18vZywgJy4nKSA6IG51bGw7XG4gIC8vIGlmICh3ZWJvcykgb3Mud2Vib3MgPSB0cnVlLCBvcy52ZXJzaW9uID0gd2Vib3NbMl07XG4gIC8vIGlmICh0b3VjaHBhZCkgb3MudG91Y2hwYWQgPSB0cnVlO1xuICAvLyBpZiAoYmxhY2tiZXJyeSkgb3MuYmxhY2tiZXJyeSA9IHRydWUsIG9zLnZlcnNpb24gPSBibGFja2JlcnJ5WzJdO1xuICAvLyBpZiAoYmIxMCkgb3MuYmIxMCA9IHRydWUsIG9zLnZlcnNpb24gPSBiYjEwWzJdO1xuICAvLyBpZiAocmltdGFibGV0b3MpIG9zLnJpbXRhYmxldG9zID0gdHJ1ZSwgb3MudmVyc2lvbiA9IHJpbXRhYmxldG9zWzJdO1xuICAvLyBpZiAocGxheWJvb2spIGJyb3dzZXIucGxheWJvb2sgPSB0cnVlO1xuICAvLyBpZiAoa2luZGxlKSBvcy5raW5kbGUgPSB0cnVlLCBvcy52ZXJzaW9uID0ga2luZGxlWzFdO1xuICAvLyBpZiAoc2lsaykgYnJvd3Nlci5zaWxrID0gdHJ1ZSwgYnJvd3Nlci52ZXJzaW9uID0gc2lsa1sxXTtcbiAgLy8gaWYgKCFzaWxrICYmIG9zLmFuZHJvaWQgJiYgdWEubWF0Y2goL0tpbmRsZSBGaXJlLykpIGJyb3dzZXIuc2lsayA9IHRydWU7XG4gIC8vIGlmIChjaHJvbWUpIGJyb3dzZXIuY2hyb21lID0gdHJ1ZSwgYnJvd3Nlci52ZXJzaW9uID0gY2hyb21lWzFdO1xuXG4gIGlmIChmaXJlZm94KSB7XG4gICAgYnJvd3Nlci5maXJlZm94ID0gdHJ1ZTtcbiAgICBicm93c2VyLnZlcnNpb24gPSBmaXJlZm94WzFdO1xuICB9IC8vIGlmIChzYWZhcmkgJiYgKHVhLm1hdGNoKC9TYWZhcmkvKSB8fCAhIW9zLmlvcykpIGJyb3dzZXIuc2FmYXJpID0gdHJ1ZTtcbiAgLy8gaWYgKHdlYnZpZXcpIGJyb3dzZXIud2VidmlldyA9IHRydWU7XG5cblxuICBpZiAoaWUpIHtcbiAgICBicm93c2VyLmllID0gdHJ1ZTtcbiAgICBicm93c2VyLnZlcnNpb24gPSBpZVsxXTtcbiAgfVxuXG4gIGlmIChlZGdlKSB7XG4gICAgYnJvd3Nlci5lZGdlID0gdHJ1ZTtcbiAgICBicm93c2VyLnZlcnNpb24gPSBlZGdlWzFdO1xuICB9IC8vIEl0IGlzIGRpZmZpY3VsdCB0byBkZXRlY3QgV2VDaGF0IGluIFdpbiBQaG9uZSBwcmVjaXNlbHksIGJlY2F1c2UgdWEgY2FuXG4gIC8vIG5vdCBiZSBzZXQgb24gd2luIHBob25lLiBTbyB3ZSBkbyBub3QgY29uc2lkZXIgV2luIFBob25lLlxuXG5cbiAgaWYgKHdlQ2hhdCkge1xuICAgIGJyb3dzZXIud2VDaGF0ID0gdHJ1ZTtcbiAgfSAvLyBvcy50YWJsZXQgPSAhIShpcGFkIHx8IHBsYXlib29rIHx8IChhbmRyb2lkICYmICF1YS5tYXRjaCgvTW9iaWxlLykpIHx8XG4gIC8vICAgICAoZmlyZWZveCAmJiB1YS5tYXRjaCgvVGFibGV0LykpIHx8IChpZSAmJiAhdWEubWF0Y2goL1Bob25lLykgJiYgdWEubWF0Y2goL1RvdWNoLykpKTtcbiAgLy8gb3MucGhvbmUgID0gISEoIW9zLnRhYmxldCAmJiAhb3MuaXBvZCAmJiAoYW5kcm9pZCB8fCBpcGhvbmUgfHwgd2Vib3MgfHxcbiAgLy8gICAgIChjaHJvbWUgJiYgdWEubWF0Y2goL0FuZHJvaWQvKSkgfHwgKGNocm9tZSAmJiB1YS5tYXRjaCgvQ3JpT1NcXC8oW1xcZC5dKykvKSkgfHxcbiAgLy8gICAgIChmaXJlZm94ICYmIHVhLm1hdGNoKC9Nb2JpbGUvKSkgfHwgKGllICYmIHVhLm1hdGNoKC9Ub3VjaC8pKSkpO1xuXG5cbiAgcmV0dXJuIHtcbiAgICBicm93c2VyOiBicm93c2VyLFxuICAgIG9zOiBvcyxcbiAgICBub2RlOiBmYWxzZSxcbiAgICAvLyDljp/nlJ9jYW52YXPmlK/mjIHvvIzmlLnmnoHnq6/ngrnkuoZcbiAgICAvLyBjYW52YXNTdXBwb3J0ZWQgOiAhKGJyb3dzZXIuaWUgJiYgcGFyc2VGbG9hdChicm93c2VyLnZlcnNpb24pIDwgOSlcbiAgICBjYW52YXNTdXBwb3J0ZWQ6ICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCxcbiAgICBzdmdTdXBwb3J0ZWQ6IHR5cGVvZiBTVkdSZWN0ICE9PSAndW5kZWZpbmVkJyxcbiAgICAvLyBAc2VlIDxodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ4MTcwMjkvd2hhdHMtdGhlLWJlc3Qtd2F5LXRvLWRldGVjdC1hLXRvdWNoLXNjcmVlbi1kZXZpY2UtdXNpbmctamF2YXNjcmlwdD5cbiAgICAvLyB3b3JrcyBvbiBtb3N0IGJyb3dzZXJzXG4gICAgLy8gSUUxMC8xMSBkb2VzIG5vdCBzdXBwb3J0IHRvdWNoIGV2ZW50LCBhbmQgTVMgRWRnZSBzdXBwb3J0cyB0aGVtIGJ1dCBub3QgYnlcbiAgICAvLyBkZWZhdWx0LCBzbyB3ZSBkb250IGNoZWNrIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyBmb3IgdGhlbSBoZXJlLlxuICAgIHRvdWNoRXZlbnRzU3VwcG9ydGVkOiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgJiYgIWJyb3dzZXIuaWUgJiYgIWJyb3dzZXIuZWRnZSxcbiAgICAvLyA8aHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9cG9pbnRlciUyMGV2ZW50Pi5cbiAgICBwb2ludGVyRXZlbnRzU3VwcG9ydGVkOiAnb25wb2ludGVyZG93bicgaW4gd2luZG93IC8vIEZpcmVmb3ggc3VwcG9ydHMgcG9pbnRlciBidXQgbm90IGJ5IGRlZmF1bHQsIG9ubHkgTVMgYnJvd3NlcnMgYXJlIHJlbGlhYmxlIG9uIHBvaW50ZXJcbiAgICAvLyBldmVudHMgY3VycmVudGx5LiBTbyB3ZSBkb250IHVzZSB0aGF0IG9uIG90aGVyIGJyb3dzZXJzIHVubGVzcyB0ZXN0ZWQgc3VmZmljaWVudGx5LlxuICAgIC8vIEFsdGhvdWdoIElFIDEwIHN1cHBvcnRzIHBvaW50ZXIgZXZlbnQsIGl0IHVzZSBvbGQgc3R5bGUgYW5kIGlzIGRpZmZlcmVudCBmcm9tIHRoZVxuICAgIC8vIHN0YW5kYXJkLiBTbyB3ZSBleGNsdWRlIHRoYXQuIChJRSAxMCBpcyBoYXJkbHkgdXNlZCBvbiB0b3VjaCBkZXZpY2UpXG4gICAgJiYgKGJyb3dzZXIuZWRnZSB8fCBicm93c2VyLmllICYmIGJyb3dzZXIudmVyc2lvbiA+PSAxMSlcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29yZS9lbnYuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbi8qKlxuICog5ZyG546vXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9SaW5nXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ3JpbmcnLFxuICBzaGFwZToge1xuICAgIGN4OiAwLFxuICAgIGN5OiAwLFxuICAgIHI6IDAsXG4gICAgcjA6IDBcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICB2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG4gICAgY3R4Lm1vdmVUbyh4ICsgc2hhcGUuciwgeSk7XG4gICAgY3R4LmFyYyh4LCB5LCBzaGFwZS5yLCAwLCBQSTIsIGZhbHNlKTtcbiAgICBjdHgubW92ZVRvKHggKyBzaGFwZS5yMCwgeSk7XG4gICAgY3R4LmFyYyh4LCB5LCBzaGFwZS5yMCwgMCwgUEkyLCB0cnVlKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmluZy5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxudmFyIHBvbHlIZWxwZXIgPSByZXF1aXJlKFwiLi4vaGVscGVyL3BvbHlcIik7XG5cbi8qKlxuICog5aSa6L655b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvUG9seWdvblxuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdwb2x5Z29uJyxcbiAgc2hhcGU6IHtcbiAgICBwb2ludHM6IG51bGwsXG4gICAgc21vb3RoOiBmYWxzZSxcbiAgICBzbW9vdGhDb25zdHJhaW50OiBudWxsXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICBwb2x5SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlLCB0cnVlKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWdvbi5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHNtb290aFNwbGluZSA9IHJlcXVpcmUoXCIuL3Ntb290aFNwbGluZVwiKTtcblxudmFyIHNtb290aEJlemllciA9IHJlcXVpcmUoXCIuL3Ntb290aEJlemllclwiKTtcblxuZnVuY3Rpb24gYnVpbGRQYXRoKGN0eCwgc2hhcGUsIGNsb3NlUGF0aCkge1xuICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuICB2YXIgc21vb3RoID0gc2hhcGUuc21vb3RoO1xuXG4gIGlmIChwb2ludHMgJiYgcG9pbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgaWYgKHNtb290aCAmJiBzbW9vdGggIT09ICdzcGxpbmUnKSB7XG4gICAgICB2YXIgY29udHJvbFBvaW50cyA9IHNtb290aEJlemllcihwb2ludHMsIHNtb290aCwgY2xvc2VQYXRoLCBzaGFwZS5zbW9vdGhDb25zdHJhaW50KTtcbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0pO1xuICAgICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgKGNsb3NlUGF0aCA/IGxlbiA6IGxlbiAtIDEpOyBpKyspIHtcbiAgICAgICAgdmFyIGNwMSA9IGNvbnRyb2xQb2ludHNbaSAqIDJdO1xuICAgICAgICB2YXIgY3AyID0gY29udHJvbFBvaW50c1tpICogMiArIDFdO1xuICAgICAgICB2YXIgcCA9IHBvaW50c1soaSArIDEpICUgbGVuXTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3AxWzBdLCBjcDFbMV0sIGNwMlswXSwgY3AyWzFdLCBwWzBdLCBwWzFdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNtb290aCA9PT0gJ3NwbGluZScpIHtcbiAgICAgICAgcG9pbnRzID0gc21vb3RoU3BsaW5lKHBvaW50cywgY2xvc2VQYXRoKTtcbiAgICAgIH1cblxuICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF1bMF0sIHBvaW50c1swXVsxXSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjdHgubGluZVRvKHBvaW50c1tpXVswXSwgcG9pbnRzW2ldWzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbG9zZVBhdGggJiYgY3R4LmNsb3NlUGF0aCgpO1xuICB9XG59XG5cbmV4cG9ydHMuYnVpbGRQYXRoID0gYnVpbGRQYXRoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9wb2x5LmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIHYyRGlzdGFuY2UgPSBfdmVjdG9yLmRpc3RhbmNlO1xuXG4vKipcbiAqIENhdG11bGwtUm9tIHNwbGluZSDmj5LlgLzmipjnur9cbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS91dGlsL3Ntb290aFNwbGluZVxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKiAgICAgICAgIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vKipcbiAqIEBpbm5lclxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzKSB7XG4gIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNTtcbiAgdmFyIHYxID0gKHAzIC0gcDEpICogMC41O1xuICByZXR1cm4gKDIgKiAocDEgLSBwMikgKyB2MCArIHYxKSAqIHQzICsgKC0zICogKHAxIC0gcDIpIC0gMiAqIHYwIC0gdjEpICogdDIgKyB2MCAqIHQgKyBwMTtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoU3BsaW5lXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludHMg57q/5q616aG254K55pWw57uEXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG9vcFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuXG5mdW5jdGlvbiBfZGVmYXVsdChwb2ludHMsIGlzTG9vcCkge1xuICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgdmFyIHJldCA9IFtdO1xuICB2YXIgZGlzdGFuY2UgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICBkaXN0YW5jZSArPSB2MkRpc3RhbmNlKHBvaW50c1tpIC0gMV0sIHBvaW50c1tpXSk7XG4gIH1cblxuICB2YXIgc2VncyA9IGRpc3RhbmNlIC8gMjtcbiAgc2VncyA9IHNlZ3MgPCBsZW4gPyBsZW4gOiBzZWdzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnczsgaSsrKSB7XG4gICAgdmFyIHBvcyA9IGkgLyAoc2VncyAtIDEpICogKGlzTG9vcCA/IGxlbiA6IGxlbiAtIDEpO1xuICAgIHZhciBpZHggPSBNYXRoLmZsb29yKHBvcyk7XG4gICAgdmFyIHcgPSBwb3MgLSBpZHg7XG4gICAgdmFyIHAwO1xuICAgIHZhciBwMSA9IHBvaW50c1tpZHggJSBsZW5dO1xuICAgIHZhciBwMjtcbiAgICB2YXIgcDM7XG5cbiAgICBpZiAoIWlzTG9vcCkge1xuICAgICAgcDAgPSBwb2ludHNbaWR4ID09PSAwID8gaWR4IDogaWR4IC0gMV07XG4gICAgICBwMiA9IHBvaW50c1tpZHggPiBsZW4gLSAyID8gbGVuIC0gMSA6IGlkeCArIDFdO1xuICAgICAgcDMgPSBwb2ludHNbaWR4ID4gbGVuIC0gMyA/IGxlbiAtIDEgOiBpZHggKyAyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcDAgPSBwb2ludHNbKGlkeCAtIDEgKyBsZW4pICUgbGVuXTtcbiAgICAgIHAyID0gcG9pbnRzWyhpZHggKyAxKSAlIGxlbl07XG4gICAgICBwMyA9IHBvaW50c1soaWR4ICsgMikgJSBsZW5dO1xuICAgIH1cblxuICAgIHZhciB3MiA9IHcgKiB3O1xuICAgIHZhciB3MyA9IHcgKiB3MjtcbiAgICByZXQucHVzaChbaW50ZXJwb2xhdGUocDBbMF0sIHAxWzBdLCBwMlswXSwgcDNbMF0sIHcsIHcyLCB3MyksIGludGVycG9sYXRlKHAwWzFdLCBwMVsxXSwgcDJbMV0sIHAzWzFdLCB3LCB3MiwgdzMpXSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhTcGxpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgdjJNaW4gPSBfdmVjdG9yLm1pbjtcbnZhciB2Mk1heCA9IF92ZWN0b3IubWF4O1xudmFyIHYyU2NhbGUgPSBfdmVjdG9yLnNjYWxlO1xudmFyIHYyRGlzdGFuY2UgPSBfdmVjdG9yLmRpc3RhbmNlO1xudmFyIHYyQWRkID0gX3ZlY3Rvci5hZGQ7XG52YXIgdjJDbG9uZSA9IF92ZWN0b3IuY2xvbmU7XG52YXIgdjJTdWIgPSBfdmVjdG9yLnN1YjtcblxuLyoqXG4gKiDotJ3loZ7lsJTlubPmu5Hmm7Lnur9cbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS91dGlsL3Ntb290aEJlemllclxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKiAgICAgICAgIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vKipcbiAqIOi0neWhnuWwlOW5s+a7keabsue6v1xuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoQmV6aWVyXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludHMg57q/5q616aG254K55pWw57uEXG4gKiBAcGFyYW0ge251bWJlcn0gc21vb3RoIOW5s+a7keetiee6pywgMC0xXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG9vcFxuICogQHBhcmFtIHtBcnJheX0gY29uc3RyYWludCDlsIborqHnrpflh7rmnaXnmoTmjqfliLbngrnnuqbmnZ/lnKjkuIDkuKrljIXlm7Tnm5LlhoVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAg5q+U5aaCIFtbMCwgMF0sIFsxMDAsIDEwMF1dLCDov5nkuKrljIXlm7Tnm5LkvJrkuI5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAg5pW05Liq5oqY57q/55qE5YyF5Zu055uS5YGa5LiA5Liq5bm26ZuG55So5p2l57qm5p2f5o6n5Yi254K544CCXG4gKiBAcGFyYW0ge0FycmF5fSDorqHnrpflh7rmnaXnmoTmjqfliLbngrnmlbDnu4RcbiAqL1xuZnVuY3Rpb24gX2RlZmF1bHQocG9pbnRzLCBzbW9vdGgsIGlzTG9vcCwgY29uc3RyYWludCkge1xuICB2YXIgY3BzID0gW107XG4gIHZhciB2ID0gW107XG4gIHZhciB2MSA9IFtdO1xuICB2YXIgdjIgPSBbXTtcbiAgdmFyIHByZXZQb2ludDtcbiAgdmFyIG5leHRQb2ludDtcbiAgdmFyIG1pbiwgbWF4O1xuXG4gIGlmIChjb25zdHJhaW50KSB7XG4gICAgbWluID0gW0luZmluaXR5LCBJbmZpbml0eV07XG4gICAgbWF4ID0gWy1JbmZpbml0eSwgLUluZmluaXR5XTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHYyTWluKG1pbiwgbWluLCBwb2ludHNbaV0pO1xuICAgICAgdjJNYXgobWF4LCBtYXgsIHBvaW50c1tpXSk7XG4gICAgfSAvLyDkuI7mjIflrprnmoTljIXlm7Tnm5LlgZrlubbpm4ZcblxuXG4gICAgdjJNaW4obWluLCBtaW4sIGNvbnN0cmFpbnRbMF0pO1xuICAgIHYyTWF4KG1heCwgbWF4LCBjb25zdHJhaW50WzFdKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV07XG5cbiAgICBpZiAoaXNMb29wKSB7XG4gICAgICBwcmV2UG9pbnQgPSBwb2ludHNbaSA/IGkgLSAxIDogbGVuIC0gMV07XG4gICAgICBuZXh0UG9pbnQgPSBwb2ludHNbKGkgKyAxKSAlIGxlbl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgY3BzLnB1c2godjJDbG9uZShwb2ludHNbaV0pKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2UG9pbnQgPSBwb2ludHNbaSAtIDFdO1xuICAgICAgICBuZXh0UG9pbnQgPSBwb2ludHNbaSArIDFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHYyU3ViKHYsIG5leHRQb2ludCwgcHJldlBvaW50KTsgLy8gdXNlIGRlZ3JlZSB0byBzY2FsZSB0aGUgaGFuZGxlIGxlbmd0aFxuXG4gICAgdjJTY2FsZSh2LCB2LCBzbW9vdGgpO1xuICAgIHZhciBkMCA9IHYyRGlzdGFuY2UocG9pbnQsIHByZXZQb2ludCk7XG4gICAgdmFyIGQxID0gdjJEaXN0YW5jZShwb2ludCwgbmV4dFBvaW50KTtcbiAgICB2YXIgc3VtID0gZDAgKyBkMTtcblxuICAgIGlmIChzdW0gIT09IDApIHtcbiAgICAgIGQwIC89IHN1bTtcbiAgICAgIGQxIC89IHN1bTtcbiAgICB9XG5cbiAgICB2MlNjYWxlKHYxLCB2LCAtZDApO1xuICAgIHYyU2NhbGUodjIsIHYsIGQxKTtcbiAgICB2YXIgY3AwID0gdjJBZGQoW10sIHBvaW50LCB2MSk7XG4gICAgdmFyIGNwMSA9IHYyQWRkKFtdLCBwb2ludCwgdjIpO1xuXG4gICAgaWYgKGNvbnN0cmFpbnQpIHtcbiAgICAgIHYyTWF4KGNwMCwgY3AwLCBtaW4pO1xuICAgICAgdjJNaW4oY3AwLCBjcDAsIG1heCk7XG4gICAgICB2Mk1heChjcDEsIGNwMSwgbWluKTtcbiAgICAgIHYyTWluKGNwMSwgY3AxLCBtYXgpO1xuICAgIH1cblxuICAgIGNwcy5wdXNoKGNwMCk7XG4gICAgY3BzLnB1c2goY3AxKTtcbiAgfVxuXG4gIGlmIChpc0xvb3ApIHtcbiAgICBjcHMucHVzaChjcHMuc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gY3BzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhCZXppZXIuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbnZhciBwb2x5SGVscGVyID0gcmVxdWlyZShcIi4uL2hlbHBlci9wb2x5XCIpO1xuXG4vKipcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1BvbHlsaW5lXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ3BvbHlsaW5lJyxcbiAgc2hhcGU6IHtcbiAgICBwb2ludHM6IG51bGwsXG4gICAgc21vb3RoOiBmYWxzZSxcbiAgICBzbW9vdGhDb25zdHJhaW50OiBudWxsXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgZmlsbDogbnVsbFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgcG9seUhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSwgZmFsc2UpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZS5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxudmFyIHJvdW5kUmVjdEhlbHBlciA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvcm91bmRSZWN0XCIpO1xuXG4vKipcbiAqIOefqeW9olxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUmVjdFxuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdyZWN0JyxcbiAgc2hhcGU6IHtcbiAgICAvLyDlt6bkuIrjgIHlj7PkuIrjgIHlj7PkuIvjgIHlt6bkuIvop5LnmoTljYrlvoTkvp3mrKHkuLpyMeOAgXIy44CBcjPjgIFyNFxuICAgIC8vIHLnvKnlhpnkuLoxICAgICAgICAg55u45b2T5LqOIFsxLCAxLCAxLCAxXVxuICAgIC8vIHLnvKnlhpnkuLpbMV0gICAgICAg55u45b2T5LqOIFsxLCAxLCAxLCAxXVxuICAgIC8vIHLnvKnlhpnkuLpbMSwgMl0gICAg55u45b2T5LqOIFsxLCAyLCAxLCAyXVxuICAgIC8vIHLnvKnlhpnkuLpbMSwgMiwgM10g55u45b2T5LqOIFsxLCAyLCAzLCAyXVxuICAgIHI6IDAsXG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHggPSBzaGFwZS54O1xuICAgIHZhciB5ID0gc2hhcGUueTtcbiAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xuXG4gICAgaWYgKCFzaGFwZS5yKSB7XG4gICAgICBjdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm91bmRSZWN0SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlKTtcbiAgICB9XG5cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgcmV0dXJuO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG4vKipcbiAqIOebtOe6v1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvTGluZVxuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdsaW5lJyxcbiAgc2hhcGU6IHtcbiAgICAvLyBTdGFydCBwb2ludFxuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIC8vIEVuZCBwb2ludFxuICAgIHgyOiAwLFxuICAgIHkyOiAwLFxuICAgIHBlcmNlbnQ6IDFcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICBzdHJva2U6ICcjMDAwJyxcbiAgICBmaWxsOiBudWxsXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgeDEgPSBzaGFwZS54MTtcbiAgICB2YXIgeTEgPSBzaGFwZS55MTtcbiAgICB2YXIgeDIgPSBzaGFwZS54MjtcbiAgICB2YXIgeTIgPSBzaGFwZS55MjtcbiAgICB2YXIgcGVyY2VudCA9IHNoYXBlLnBlcmNlbnQ7XG5cbiAgICBpZiAocGVyY2VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcblxuICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgeDIgPSB4MSAqICgxIC0gcGVyY2VudCkgKyB4MiAqIHBlcmNlbnQ7XG4gICAgICB5MiA9IHkxICogKDEgLSBwZXJjZW50KSArIHkyICogcGVyY2VudDtcbiAgICB9XG5cbiAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBwb2ludCBhdCBwZXJjZW50XG4gICAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIHBvaW50QXQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcbiAgICByZXR1cm4gW3NoYXBlLngxICogKDEgLSBwKSArIHNoYXBlLngyICogcCwgc2hhcGUueTEgKiAoMSAtIHApICsgc2hhcGUueTIgKiBwXTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxudmFyIHZlYzIgPSByZXF1aXJlKFwiLi4vLi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciBfY3VydmUgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9jdXJ2ZVwiKTtcblxudmFyIHF1YWRyYXRpY1N1YmRpdmlkZSA9IF9jdXJ2ZS5xdWFkcmF0aWNTdWJkaXZpZGU7XG52YXIgY3ViaWNTdWJkaXZpZGUgPSBfY3VydmUuY3ViaWNTdWJkaXZpZGU7XG52YXIgcXVhZHJhdGljQXQgPSBfY3VydmUucXVhZHJhdGljQXQ7XG52YXIgY3ViaWNBdCA9IF9jdXJ2ZS5jdWJpY0F0O1xudmFyIHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA9IF9jdXJ2ZS5xdWFkcmF0aWNEZXJpdmF0aXZlQXQ7XG52YXIgY3ViaWNEZXJpdmF0aXZlQXQgPSBfY3VydmUuY3ViaWNEZXJpdmF0aXZlQXQ7XG5cbi8qKlxuICog6LSd5aGe5bCU5puy57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvQmV6aWVyQ3VydmVcbiAqL1xudmFyIG91dCA9IFtdO1xuXG5mdW5jdGlvbiBzb21lVmVjdG9yQXQoc2hhcGUsIHQsIGlzVGFuZ2VudCkge1xuICB2YXIgY3B4MiA9IHNoYXBlLmNweDI7XG4gIHZhciBjcHkyID0gc2hhcGUuY3B5MjtcblxuICBpZiAoY3B4MiA9PT0gbnVsbCB8fCBjcHkyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFsoaXNUYW5nZW50ID8gY3ViaWNEZXJpdmF0aXZlQXQgOiBjdWJpY0F0KShzaGFwZS54MSwgc2hhcGUuY3B4MSwgc2hhcGUuY3B4Miwgc2hhcGUueDIsIHQpLCAoaXNUYW5nZW50ID8gY3ViaWNEZXJpdmF0aXZlQXQgOiBjdWJpY0F0KShzaGFwZS55MSwgc2hhcGUuY3B5MSwgc2hhcGUuY3B5Miwgc2hhcGUueTIsIHQpXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gWyhpc1RhbmdlbnQgPyBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgOiBxdWFkcmF0aWNBdCkoc2hhcGUueDEsIHNoYXBlLmNweDEsIHNoYXBlLngyLCB0KSwgKGlzVGFuZ2VudCA/IHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA6IHF1YWRyYXRpY0F0KShzaGFwZS55MSwgc2hhcGUuY3B5MSwgc2hhcGUueTIsIHQpXTtcbiAgfVxufVxuXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdiZXppZXItY3VydmUnLFxuICBzaGFwZToge1xuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIHgyOiAwLFxuICAgIHkyOiAwLFxuICAgIGNweDE6IDAsXG4gICAgY3B5MTogMCxcbiAgICAvLyBjcHgyOiAwLFxuICAgIC8vIGNweTI6IDBcbiAgICAvLyBDdXJ2ZSBzaG93IHBlcmNlbnQsIGZvciBhbmltYXRpbmdcbiAgICBwZXJjZW50OiAxXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgZmlsbDogbnVsbFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHgxID0gc2hhcGUueDE7XG4gICAgdmFyIHkxID0gc2hhcGUueTE7XG4gICAgdmFyIHgyID0gc2hhcGUueDI7XG4gICAgdmFyIHkyID0gc2hhcGUueTI7XG4gICAgdmFyIGNweDEgPSBzaGFwZS5jcHgxO1xuICAgIHZhciBjcHkxID0gc2hhcGUuY3B5MTtcbiAgICB2YXIgY3B4MiA9IHNoYXBlLmNweDI7XG4gICAgdmFyIGNweTIgPSBzaGFwZS5jcHkyO1xuICAgIHZhciBwZXJjZW50ID0gc2hhcGUucGVyY2VudDtcblxuICAgIGlmIChwZXJjZW50ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuXG4gICAgaWYgKGNweDIgPT0gbnVsbCB8fCBjcHkyID09IG51bGwpIHtcbiAgICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGUoeDEsIGNweDEsIHgyLCBwZXJjZW50LCBvdXQpO1xuICAgICAgICBjcHgxID0gb3V0WzFdO1xuICAgICAgICB4MiA9IG91dFsyXTtcbiAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlKHkxLCBjcHkxLCB5MiwgcGVyY2VudCwgb3V0KTtcbiAgICAgICAgY3B5MSA9IG91dFsxXTtcbiAgICAgICAgeTIgPSBvdXRbMl07XG4gICAgICB9XG5cbiAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNweDEsIGNweTEsIHgyLCB5Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgICBjdWJpY1N1YmRpdmlkZSh4MSwgY3B4MSwgY3B4MiwgeDIsIHBlcmNlbnQsIG91dCk7XG4gICAgICAgIGNweDEgPSBvdXRbMV07XG4gICAgICAgIGNweDIgPSBvdXRbMl07XG4gICAgICAgIHgyID0gb3V0WzNdO1xuICAgICAgICBjdWJpY1N1YmRpdmlkZSh5MSwgY3B5MSwgY3B5MiwgeTIsIHBlcmNlbnQsIG91dCk7XG4gICAgICAgIGNweTEgPSBvdXRbMV07XG4gICAgICAgIGNweTIgPSBvdXRbMl07XG4gICAgICAgIHkyID0gb3V0WzNdO1xuICAgICAgfVxuXG4gICAgICBjdHguYmV6aWVyQ3VydmVUbyhjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLCB4MiwgeTIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogR2V0IHBvaW50IGF0IHBlcmNlbnRcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgcG9pbnRBdDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gc29tZVZlY3RvckF0KHRoaXMuc2hhcGUsIHQsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRhbmdlbnQgYXQgcGVyY2VudFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICB0YW5nZW50QXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIHAgPSBzb21lVmVjdG9yQXQodGhpcy5zaGFwZSwgdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHZlYzIubm9ybWFsaXplKHAsIHApO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZS5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxuLyoqXG4gKiDlnIblvKdcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL0FyY1xuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdhcmMnLFxuICBzaGFwZToge1xuICAgIGN4OiAwLFxuICAgIGN5OiAwLFxuICAgIHI6IDAsXG4gICAgc3RhcnRBbmdsZTogMCxcbiAgICBlbmRBbmdsZTogTWF0aC5QSSAqIDIsXG4gICAgY2xvY2t3aXNlOiB0cnVlXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgZmlsbDogbnVsbFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHggPSBzaGFwZS5jeDtcbiAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgIHZhciByID0gTWF0aC5tYXgoc2hhcGUuciwgMCk7XG4gICAgdmFyIHN0YXJ0QW5nbGUgPSBzaGFwZS5zdGFydEFuZ2xlO1xuICAgIHZhciBlbmRBbmdsZSA9IHNoYXBlLmVuZEFuZ2xlO1xuICAgIHZhciBjbG9ja3dpc2UgPSBzaGFwZS5jbG9ja3dpc2U7XG4gICAgdmFyIHVuaXRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgdmFyIHVuaXRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgY3R4Lm1vdmVUbyh1bml0WCAqIHIgKyB4LCB1bml0WSAqIHIgKyB5KTtcbiAgICBjdHguYXJjKHgsIHksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCAhY2xvY2t3aXNlKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQXJjLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIEdyYWRpZW50ID0gcmVxdWlyZShcIi4vR3JhZGllbnRcIik7XG5cbi8qKlxuICogeCwgeSwgeDIsIHkyIGFyZSBhbGwgcGVyY2VudCBmcm9tIDAgdG8gMVxuICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeDI9MV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeTI9MF1cbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGNvbG9yU3RvcHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2dsb2JhbENvb3JkPWZhbHNlXVxuICovXG52YXIgTGluZWFyR3JhZGllbnQgPSBmdW5jdGlvbiAoeCwgeSwgeDIsIHkyLCBjb2xvclN0b3BzLCBnbG9iYWxDb29yZCkge1xuICAvLyBTaG91bGQgZG8gbm90aGluZyBtb3JlIGluIHRoaXMgY29uc3RydWN0b3IuIEJlY2F1c2UgZ3JhZGllbnQgY2FuIGJlXG4gIC8vIGRlY2xhcmQgYnkgYGNvbG9yOiB7dHlwZTogJ2xpbmVhcicsIGNvbG9yU3RvcHM6IC4uLn1gLCB3aGVyZVxuICAvLyB0aGlzIGNvbnN0cnVjdG9yIHdpbGwgbm90IGJlIGNhbGxlZC5cbiAgdGhpcy54ID0geCA9PSBudWxsID8gMCA6IHg7XG4gIHRoaXMueSA9IHkgPT0gbnVsbCA/IDAgOiB5O1xuICB0aGlzLngyID0geDIgPT0gbnVsbCA/IDEgOiB4MjtcbiAgdGhpcy55MiA9IHkyID09IG51bGwgPyAwIDogeTI7IC8vIENhbiBiZSBjbG9uZWRcblxuICB0aGlzLnR5cGUgPSAnbGluZWFyJzsgLy8gSWYgdXNlIGdsb2JhbCBjb29yZFxuXG4gIHRoaXMuZ2xvYmFsID0gZ2xvYmFsQ29vcmQgfHwgZmFsc2U7XG4gIEdyYWRpZW50LmNhbGwodGhpcywgY29sb3JTdG9wcyk7XG59O1xuXG5MaW5lYXJHcmFkaWVudC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBMaW5lYXJHcmFkaWVudFxufTtcbnpyVXRpbC5pbmhlcml0cyhMaW5lYXJHcmFkaWVudCwgR3JhZGllbnQpO1xudmFyIF9kZWZhdWx0ID0gTGluZWFyR3JhZGllbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0xpbmVhckdyYWRpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIEdyYWRpZW50ID0gcmVxdWlyZShcIi4vR3JhZGllbnRcIik7XG5cbi8qKlxuICogeCwgeSwgciBhcmUgYWxsIHBlcmNlbnQgZnJvbSAwIHRvIDFcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wLjVdXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MC41XVxuICogQHBhcmFtIHtudW1iZXJ9IFtyPTAuNV1cbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFtjb2xvclN0b3BzXVxuICogQHBhcmFtIHtib29sZWFufSBbZ2xvYmFsQ29vcmQ9ZmFsc2VdXG4gKi9cbnZhciBSYWRpYWxHcmFkaWVudCA9IGZ1bmN0aW9uICh4LCB5LCByLCBjb2xvclN0b3BzLCBnbG9iYWxDb29yZCkge1xuICAvLyBTaG91bGQgZG8gbm90aGluZyBtb3JlIGluIHRoaXMgY29uc3RydWN0b3IuIEJlY2F1c2UgZ3JhZGllbnQgY2FuIGJlXG4gIC8vIGRlY2xhcmQgYnkgYGNvbG9yOiB7dHlwZTogJ3JhZGlhbCcsIGNvbG9yU3RvcHM6IC4uLn1gLCB3aGVyZVxuICAvLyB0aGlzIGNvbnN0cnVjdG9yIHdpbGwgbm90IGJlIGNhbGxlZC5cbiAgdGhpcy54ID0geCA9PSBudWxsID8gMC41IDogeDtcbiAgdGhpcy55ID0geSA9PSBudWxsID8gMC41IDogeTtcbiAgdGhpcy5yID0gciA9PSBudWxsID8gMC41IDogcjsgLy8gQ2FuIGJlIGNsb25lZFxuXG4gIHRoaXMudHlwZSA9ICdyYWRpYWwnOyAvLyBJZiB1c2UgZ2xvYmFsIGNvb3JkXG5cbiAgdGhpcy5nbG9iYWwgPSBnbG9iYWxDb29yZCB8fCBmYWxzZTtcbiAgR3JhZGllbnQuY2FsbCh0aGlzLCBjb2xvclN0b3BzKTtcbn07XG5cblJhZGlhbEdyYWRpZW50LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFJhZGlhbEdyYWRpZW50XG59O1xuenJVdGlsLmluaGVyaXRzKFJhZGlhbEdyYWRpZW50LCBHcmFkaWVudCk7XG52YXIgX2RlZmF1bHQgPSBSYWRpYWxHcmFkaWVudDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUmFkaWFsR3JhZGllbnQuanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgU3R5bGUgPSByZXF1aXJlKFwiLi9TdHlsZVwiKTtcblxudmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciB2ZWMyQ29weSA9IF92ZWN0b3IuY29weTtcblxuLyoqXG4gKiBTdGF0ZXMgbWFjaGluZSBmb3IgbWFuYWdpbmcgZ3JhcGhpYyBzdGF0ZXNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IElHcmFwaGljU3RhdGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbemxldmVsXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6XVxuICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPn0ge3Bvc2l0aW9ufVxuICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPnxudW1iZXJ9IHtyb3RhdGlvbn1cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj59IHtzY2FsZX1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBzdHlsZVxuICpcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG9uZW50ZXJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG9ubGVhdmVcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG9udHJhbnNpdGlvblxuICogQHByb3BlcnR5IHtBcnJheS48SUdyYXBoaWNTdGF0ZVRyYW5zaXRpb258c3RyaW5nPn0gdHJhbnNpdGlvblxuICogICAgICAgICAgIFRyYW5zaXRpb24gb2JqZWN0IG9yIGEgc3RyaW5nIGRlc2NyaXB0b3IgbGlrZSAnKiAzMCAwIExpbmVhcidcbiAqL1xudmFyIHRyYW5zaXRpb25Qcm9wZXJ0aWVzID0gWydwb3NpdGlvbicsICdyb3RhdGlvbicsICdzY2FsZScsICdzdHlsZScsICdzaGFwZSddO1xuLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9TdGF0ZXN+VHJhbnNpdGlvbk9iamVjdFxuICovXG5cbnZhciBUcmFuc2l0aW9uT2JqZWN0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5fZnJvbVN0cihvcHRzKTtcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgb3B0cy5wcm9wZXJ0eSAmJiAodGhpcy5wcm9wZXJ0eSA9IG9wdHMucHJvcGVydHkpO1xuICAgIG9wdHMuZHVyYXRpb24gIT0gbnVsbCAmJiAodGhpcy5kdXJhdGlvbiA9IG9wdHMuZHVyYXRpb24pO1xuICAgIG9wdHMuZWFzaW5nICYmICh0aGlzLmVhc2luZyA9IG9wdHMuZWFzaW5nKTtcbiAgICBvcHRzLmRlbGF5ICYmICh0aGlzLmRlbGF5ID0gb3B0cy5kZWxheSk7XG4gIH1cblxuICBpZiAodGhpcy5wcm9wZXJ0eSAhPT0gJyonKSB7XG4gICAgdGhpcy5wcm9wZXJ0eSA9IHRoaXMucHJvcGVydHkuc3BsaXQoJywnKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnByb3BlcnR5ID0gdHJhbnNpdGlvblByb3BlcnRpZXM7XG4gIH1cbn07XG5cblRyYW5zaXRpb25PYmplY3QucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVHJhbnNpdGlvbk9iamVjdCxcblxuICAvKipcbiAgICogTGlzdCBvZiBhbGwgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzLiBTcGxpdHRlZCBieSBjb21tYS4gTXVzdCBub3QgaGF2ZSBzcGFjZXMgaW4gdGhlIHN0cmluZy5cbiAgICogZS5nLiAncG9zaXRpb24sc3R5bGUuY29sb3InLiAnKicgd2lsbCBtYXRjaCBhbGwgdGhlIHZhbGlkIHByb3BlcnRpZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICpcbiAgICovXG4gIHByb3BlcnR5OiAnKicsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICdMaW5lYXInXG4gICAqL1xuICBlYXNpbmc6ICdMaW5lYXInLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAnbnVtYmVyJ1xuICAgKi9cbiAgZHVyYXRpb246IDUwMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGRlbGF5OiAwLFxuICBfZnJvbVN0cjogZnVuY3Rpb24gKHN0cikge1xuICAgIHZhciBhcnIgPSBzdHIuc3BsaXQoL1xccysvZyk7XG4gICAgdGhpcy5wcm9wZXJ0eSA9IGFyclswXTtcbiAgICB0aGlzLmR1cmF0aW9uID0gK2FyclsxXTtcbiAgICB0aGlzLmRlbGF5ID0gK2FyclsyXTtcbiAgICB0aGlzLmVhc2luZyA9IGFyclszXTtcbiAgfVxufTtcbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3RhdGVzXG4gKi9cblxudmFyIEdyYXBoaWNTdGF0ZXMgPSBmdW5jdGlvbiAob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdGhpcy5fc3RhdGVzID0ge307XG4gIC8qKlxuICAgKiBUYXJnZXQgZWxlbWVudFxuICAgKiBAdHlwZSB7enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlfHpyZW5kZXIvY29udGFpbmVyL0dyb3VwfVxuICAgKi9cblxuICB0aGlzLl9lbCA9IG9wdHMuZWw7XG4gIHRoaXMuX3N1YlN0YXRlcyA9IFtdO1xuICB0aGlzLl90cmFuc2l0aW9uQW5pbWF0b3JzID0gW107XG5cbiAgaWYgKG9wdHMuaW5pdGlhbFN0YXRlKSB7XG4gICAgdGhpcy5faW5pdGlhbFN0YXRlID0gb3B0cy5pbml0aWFsU3RhdGU7XG4gIH1cblxuICB2YXIgb3B0c1N0YXRlcyA9IG9wdHMuc3RhdGVzO1xuXG4gIGlmIChvcHRzU3RhdGVzKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBvcHRzU3RhdGVzKSB7XG4gICAgICBpZiAob3B0c1N0YXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBvcHRzU3RhdGVzW25hbWVdO1xuXG4gICAgICAgIHRoaXMuX2FkZFN0YXRlKG5hbWUsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLnNldFN0YXRlKHRoaXMuX2luaXRpYWxTdGF0ZSk7XG59O1xuXG5HcmFwaGljU3RhdGVzLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEdyYXBoaWNTdGF0ZXMsXG5cbiAgLyoqXG4gICAqIEFsbCBvdGhlciBzdGF0ZSB3aWxsIGJlIGV4dGVuZGVkIGZyb20gaW5pdGlhbCBzdGF0ZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRpYWxTdGF0ZTogJ25vcm1hbCcsXG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgc3RhdGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jdXJyZW50U3RhdGU6ICcnLFxuICBlbDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9lbDtcbiAgfSxcbiAgX2FkZFN0YXRlOiBmdW5jdGlvbiAobmFtZSwgc3RhdGUpIHtcbiAgICB0aGlzLl9zdGF0ZXNbbmFtZV0gPSBzdGF0ZTtcblxuICAgIGlmIChzdGF0ZS50cmFuc2l0aW9uKSB7XG4gICAgICBzdGF0ZS50cmFuc2l0aW9uID0gbmV3IFRyYW5zaXRpb25PYmplY3Qoc3RhdGUudHJhbnNpdGlvbik7XG4gICAgfSAvLyBFeHRlbmQgZnJvbSBpbml0aWFsIHN0YXRlXG5cblxuICAgIGlmIChuYW1lICE9PSB0aGlzLl9pbml0aWFsU3RhdGUpIHtcbiAgICAgIHRoaXMuX2V4dGVuZEZyb21Jbml0aWFsKHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVsID0gdGhpcy5fZWw7IC8vIHNldFN0YXRlIOeahOaXtuWAmeiHquW4pueahCBzdHlsZSDlkowgc2hhcGUg6YO95Lya6KKr55u05o6l6KaG55uWXG4gICAgICAvLyDmiYDku6Xov5novrnlhYjmioroh6rluKbnmoQgc3R5bGUg5ZKMIHNoYXBlIOaJqeWxleWIsOWIneWni+eKtuaAgeS4rVxuXG4gICAgICB6clV0aWwubWVyZ2Uoc3RhdGUuc3R5bGUsIGVsLnN0eWxlLCBmYWxzZSwgZmFsc2UpO1xuXG4gICAgICBpZiAoc3RhdGUuc2hhcGUpIHtcbiAgICAgICAgenJVdGlsLm1lcmdlKHN0YXRlLnNoYXBlLCBlbC5zaGFwZSwgZmFsc2UsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuc2hhcGUgPSB6clV0aWwuY2xvbmUoZWwuc2hhcGUsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMuX3N0YXRlcykge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdGhpcy5fZXh0ZW5kRnJvbUluaXRpYWwodGhpcy5fc3RhdGVzW25hbWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2V4dGVuZEZyb21Jbml0aWFsOiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gdGhpcy5fc3RhdGVzW3RoaXMuX2luaXRpYWxTdGF0ZV07XG5cbiAgICBpZiAoaW5pdGlhbFN0YXRlICYmIHN0YXRlICE9PSBpbml0aWFsU3RhdGUpIHtcbiAgICAgIHpyVXRpbC5tZXJnZShzdGF0ZSwgaW5pdGlhbFN0YXRlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICB9LFxuICBzZXRTdGF0ZTogZnVuY3Rpb24gKG5hbWUsIHNpbGVudCkge1xuICAgIGlmIChuYW1lID09PSB0aGlzLl9jdXJyZW50U3RhdGUgJiYgIXRoaXMudHJhbnNpdGluZygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGVzW25hbWVdO1xuXG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICB0aGlzLl9zdG9wVHJhbnNpdGlvbigpO1xuXG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICB2YXIgcHJldlN0YXRlID0gdGhpcy5fc3RhdGVzW3RoaXMuX2N1cnJlbnRTdGF0ZV07XG5cbiAgICAgICAgaWYgKHByZXZTdGF0ZSkge1xuICAgICAgICAgIHByZXZTdGF0ZS5vbmxlYXZlICYmIHByZXZTdGF0ZS5vbmxlYXZlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5vbmVudGVyICYmIHN0YXRlLm9uZW50ZXIuY2FsbCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY3VycmVudFN0YXRlID0gbmFtZTtcblxuICAgICAgaWYgKHRoaXMuX2VsKSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXMuX2VsOyAvLyBTZXR0aW5nIGF0dHJpYnV0ZXNcblxuICAgICAgICBpZiAoc3RhdGUuemxldmVsICE9IG51bGwpIHtcbiAgICAgICAgICBlbC56bGV2ZWwgPSBzdGF0ZS56bGV2ZWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUueiAhPSBudWxsKSB7XG4gICAgICAgICAgZWwueiA9IHN0YXRlLno7XG4gICAgICAgIH0gLy8gU1JUXG5cblxuICAgICAgICBzdGF0ZS5wb3NpdGlvbiAmJiB2ZWMyQ29weShlbC5wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBzdGF0ZS5zY2FsZSAmJiB2ZWMyQ29weShlbC5zY2FsZSwgc3RhdGUuc2NhbGUpO1xuXG4gICAgICAgIGlmIChzdGF0ZS5yb3RhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgZWwucm90YXRpb24gPSBzdGF0ZS5yb3RhdGlvbjtcbiAgICAgICAgfSAvLyBTdHlsZVxuXG5cbiAgICAgICAgaWYgKHN0YXRlLnN0eWxlKSB7XG4gICAgICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IHRoaXMuX3N0YXRlc1t0aGlzLl9pbml0aWFsU3RhdGVdO1xuICAgICAgICAgIGVsLnN0eWxlID0gbmV3IFN0eWxlKCk7XG5cbiAgICAgICAgICBpZiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS5leHRlbmRGcm9tKGluaXRpYWxTdGF0ZS5zdHlsZSwgZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICggLy8gTm90IGluaXRpYWwgc3RhdGVcbiAgICAgICAgICBuYW1lICE9IHRoaXMuX2luaXRpYWxTdGF0ZSAvLyBOb3QgY29waWVkIGZyb20gaW5pdGlhbCBzdGF0ZSBpbiBfZXh0ZW5kRnJvbUluaXRpYWwgbWV0aG9kXG4gICAgICAgICAgJiYgaW5pdGlhbFN0YXRlLnN0eWxlICE9PSBzdGF0ZS5zdHlsZSkge1xuICAgICAgICAgICAgZWwuc3R5bGUuZXh0ZW5kRnJvbShzdGF0ZS5zdHlsZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLnNoYXBlKSB7XG4gICAgICAgICAgZWwuc2hhcGUgPSB6clV0aWwuY2xvbmUoc3RhdGUuc2hhcGUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwuZGlydHkoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3N1YlN0YXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fc3ViU3RhdGVzLnNldFN0YXRlKG5hbWUpO1xuICAgIH1cbiAgfSxcbiAgZ2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFN0YXRlO1xuICB9LFxuICB0cmFuc2l0aW9uU3RhdGU6IGZ1bmN0aW9uICh0YXJnZXQsIGRvbmUpIHtcbiAgICBpZiAodGFyZ2V0ID09PSB0aGlzLl9jdXJyZW50U3RhdGUgJiYgIXRoaXMudHJhbnNpdGluZygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGVzW3RhcmdldF07XG4gICAgdmFyIHN0eWxlU2hhcGVSZWcgPSAvJFtzdHlsZXxzaGFwZV1cXC4vO1xuICAgIHZhciBzZWxmID0gdGhpczsgLy8gQW5pbWF0aW9uIOWOu+mHjVxuXG4gICAgdmFyIHByb3BQYXRoTWFwID0ge307XG5cbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIHNlbGYuX3N0b3BUcmFuc2l0aW9uKCk7XG5cbiAgICAgIHZhciBlbCA9IHNlbGYuX2VsO1xuXG4gICAgICBpZiAoc3RhdGUudHJhbnNpdGlvbiAmJiBlbCAmJiBlbC5fX3pyKSB7XG4gICAgICAgIC8vIEVsIGNhbiBiZSBhbmltYXRlZFxuICAgICAgICB2YXIgdHJhbnNpdGlvbkNmZyA9IHN0YXRlLnRyYW5zaXRpb247XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHRyYW5zaXRpb25DZmcucHJvcGVydHk7XG4gICAgICAgIHZhciBhbmltYXRpbmdDb3VudCA9IDA7XG5cbiAgICAgICAgdmFyIGFuaW1hdGlvbkRvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYW5pbWF0aW5nQ291bnQtLTtcblxuICAgICAgICAgIGlmIChhbmltYXRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgc2VsZi5zZXRTdGF0ZSh0YXJnZXQpO1xuICAgICAgICAgICAgZG9uZSAmJiBkb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eVtpXTsgLy8gQW5pbWF0aW5nIGFsbCB0aGUgcHJvcGVydGllcyBpbiBzdHlsZSBvciBzaGFwZVxuXG4gICAgICAgICAgaWYgKHByb3BOYW1lID09PSAnc3R5bGUnIHx8IHByb3BOYW1lID09PSAnc2hhcGUnKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGVbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzdGF0ZVtwcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlW3Byb3BOYW1lXS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IHByb3BOYW1lICsgJy4nICsga2V5O1xuXG4gICAgICAgICAgICAgICAgaWYgKHByb3BQYXRoTWFwW3BhdGhdKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwcm9wUGF0aE1hcFtwYXRoXSA9IDE7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW5nQ291bnQgKz0gc2VsZi5fYW5pbVByb3Aoc3RhdGUsIHByb3BOYW1lLCBrZXksIHRyYW5zaXRpb25DZmcsIGFuaW1hdGlvbkRvbmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcm9wUGF0aE1hcFtwcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb3BQYXRoTWFwW3Byb3BOYW1lXSA9IDE7IC8vIEFuaW1hdGluZyBwYXJ0aWN1bGFyIHByb3BlcnR5IGluIHN0eWxlIG9yIHN0eWxlXG5cbiAgICAgICAgICAgIGlmIChwcm9wTmFtZS5tYXRjaChzdHlsZVNoYXBlUmVnKSkge1xuICAgICAgICAgICAgICAvLyByZW1vdmUgJ3N0eWxlLicsICdzaGFwZS4nIHByZWZpeFxuICAgICAgICAgICAgICB2YXIgc3ViUHJvcCA9IHByb3BOYW1lLnNsaWNlKDAsIDUpO1xuICAgICAgICAgICAgICBwcm9wTmFtZSA9IHByb3BOYW1lLnNsaWNlKDYpO1xuICAgICAgICAgICAgICBhbmltYXRpbmdDb3VudCArPSBzZWxmLl9hbmltUHJvcChzdGF0ZSwgc3ViUHJvcCwgcHJvcE5hbWUsIHRyYW5zaXRpb25DZmcsIGFuaW1hdGlvbkRvbmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYW5pbWF0aW5nQ291bnQgKz0gc2VsZi5fYW5pbVByb3Aoc3RhdGUsICcnLCBwcm9wTmFtZSwgdHJhbnNpdGlvbkNmZywgYW5pbWF0aW9uRG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIE5vIHRyYW5zaXRpb24gcHJvcGVydGllc1xuXG5cbiAgICAgICAgaWYgKGFuaW1hdGluZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgc2VsZi5zZXRTdGF0ZSh0YXJnZXQpO1xuICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNldFN0YXRlKHRhcmdldCk7XG4gICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzdWJTdGF0ZXMgPSBzZWxmLl9zdWJTdGF0ZXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YlN0YXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgc3ViU3RhdGVzLnRyYW5zaXRpb25TdGF0ZSh0YXJnZXQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRG8gdHJhbnNpdGlvbiBhbmltYXRpb24gb2YgcGFydGljdWxhciBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN1YlByb3BLZXlcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNpdGlvbkNmZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYW5pbVByb3A6IGZ1bmN0aW9uIChzdGF0ZSwgc3ViUHJvcEtleSwga2V5LCB0cmFuc2l0aW9uQ2ZnLCBkb25lKSB7XG4gICAgdmFyIGVsID0gdGhpcy5fZWw7XG4gICAgdmFyIHN0YXRlT2JqID0gc3ViUHJvcEtleSA/IHN0YXRlW3N1YlByb3BLZXldIDogc3RhdGU7XG4gICAgdmFyIGVsT2JqID0gc3ViUHJvcEtleSA/IGVsW3N1YlByb3BLZXldIDogZWw7XG4gICAgdmFyIGF2YWlsYWJsZVByb3AgPSBzdGF0ZU9iaiAmJiBrZXkgaW4gc3RhdGVPYmogJiYgZWxPYmogJiYga2V5IGluIGVsT2JqO1xuICAgIHZhciB0cmFuc2l0aW9uQW5pbWF0b3JzID0gdGhpcy5fdHJhbnNpdGlvbkFuaW1hdG9ycztcblxuICAgIGlmIChhdmFpbGFibGVQcm9wKSB7XG4gICAgICB2YXIgb2JqID0ge307XG5cbiAgICAgIGlmIChzdGF0ZU9ialtrZXldID09PSBlbE9ialtrZXldKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBvYmpba2V5XSA9IHN0YXRlT2JqW2tleV07XG4gICAgICB2YXIgYW5pbWF0b3IgPSBlbC5hbmltYXRlKHN1YlByb3BLZXkpLndoZW4odHJhbnNpdGlvbkNmZy5kdXJhdGlvbiwgb2JqKS5kZWxheSh0cmFuc2l0aW9uQ2ZnLmRlYWx5KS5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkeCA9IHpyVXRpbC5pbmRleE9mKHRyYW5zaXRpb25BbmltYXRvcnMsIDEpO1xuXG4gICAgICAgIGlmIChpZHggPiAwKSB7XG4gICAgICAgICAgdHJhbnNpdGlvbkFuaW1hdG9ycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pLnN0YXJ0KHRyYW5zaXRpb25DZmcuZWFzaW5nKTtcbiAgICAgIHRyYW5zaXRpb25BbmltYXRvcnMucHVzaChhbmltYXRvcik7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgX3N0b3BUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRyYW5zaXRpb25BbmltYXRvcnMgPSB0aGlzLl90cmFuc2l0aW9uQW5pbWF0b3JzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2l0aW9uQW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0cmFuc2l0aW9uQW5pbWF0b3JzW2ldLnN0b3AoKTtcbiAgICB9XG5cbiAgICB0cmFuc2l0aW9uQW5pbWF0b3JzLmxlbmd0aCA9IDA7XG4gIH0sXG4gIHRyYW5zaXRpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNpdGlvbkFuaW1hdG9ycy5sZW5ndGggPiAwO1xuICB9LFxuICBhZGRTdWJTdGF0ZXM6IGZ1bmN0aW9uIChzdGF0ZXMpIHtcbiAgICB0aGlzLl9zdWJTdGF0ZXMucHVzaChzdGF0ZXMpO1xuICB9LFxuICByZW1vdmVTdWJTdGF0ZXM6IGZ1bmN0aW9uIChzdGF0ZXMpIHtcbiAgICB2YXIgaWR4ID0genJVdGlsLmluZGV4T2YodGhpcy5fc3ViU3RhdGVzLCBzdGF0ZXMpO1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICB0aGlzLl9zdWJTdGF0ZXMuc3BsaWNlKHN0YXRlcywgMSk7XG4gICAgfVxuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gR3JhcGhpY1N0YXRlcztcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvU3RhdGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qcycpO1xyXG4gICAgZnVuY3Rpb24gTWluaW1hcChiaWdDYW52YXMsZ3JvdXBQb3NpdGlvbiwgZ3JvdXAsZWFnbGVFeWVOb2RlLGRpc3RhbmNlLGltZ1NyYykge1xyXG5cclxuICAgICAgICB0aGlzLmJpZ0NhbnZhcyA9IGJpZ0NhbnZhcztcclxuICAgICAgICB0aGlzLmVhZ2xlRXllTm9kZSA9IGVhZ2xlRXllTm9kZTtcclxuICAgICAgICB0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XHJcbiAgICAgICAgdGhpcy5pbWdTcmMgPSBpbWdTcmM7XHJcbiAgICAgICAgdGhpcy5yYXRpbztcclxuICAgICAgICB0aGlzLmdyb3VwUmF0aW87XHJcbiAgICAgICAgdGhpcy5ncm91cCA9IGdyb3VwO1xyXG4gICAgICAgIHRoaXMuaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcclxuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBQb3NpdGlvbiA9IHpyVXRpbC5jbG9uZShncm91cFBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLnNlbGVjdFBvc2l0aW9uID0gWzAsMF07XHJcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBNaW5pbWFwLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhhdC5yYXRpbyA9IDAuMTI7XHJcbiAgICAgICAgdmFyIGVhZ2xlRXllTm9kZVdpZHRoID0gdGhhdC5ncm91cC53aWR0aCAgKiB0aGF0LnJhdGlvO1xyXG4gICAgICAgIHZhciBlYWdsZUV5ZU5vZGVIZWlnaHQgPSB0aGF0Lmdyb3VwLmhlaWdodCAgKiB0aGF0LnJhdGlvO1xyXG4gICAgICAgIHRoYXQuZWFnbGVFeWVOb2RlLnN0eWxlLndpZHRoID0gZWFnbGVFeWVOb2RlV2lkdGgrXCJweFwiO1xyXG4gICAgICAgIHRoYXQuZWFnbGVFeWVOb2RlLnN0eWxlLmhlaWdodCA9IGVhZ2xlRXllTm9kZUhlaWdodCtcInB4XCI7XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuc3R5bGUubWFyZ2luVG9wID0gLWVhZ2xlRXllTm9kZUhlaWdodCtcInB4XCI7XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuc3R5bGUubWFyZ2luTGVmdCA9IHRoYXQuYmlnQ2FudmFzLmdldFdpZHRoKCktZWFnbGVFeWVOb2RlV2lkdGgrXCJweFwiO1xyXG4gICAgICAgIHRoYXQuZWFnbGVFeWVOb2RlLnN0eWxlLnBvc2l0aW9uPVwicmVsYXRpdmVcIjtcclxuICAgICAgICB0aGF0LmVhZ2xlRXllTm9kZS5zdHlsZS5iYWNrZ3JvdW5kID0gXCJ1cmwoXCIrdGhhdC5pbWdTcmMrXCIpIG5vLXJlcGVhdFwiO1xyXG4gICAgICAgIHRoYXQuZWFnbGVFeWVOb2RlLnN0eWxlLmJhY2tncm91bmRTaXplID0gZWFnbGVFeWVOb2RlV2lkdGgvKHRoYXQuZ3JvdXAud2lkdGgqdGhhdC5kaXN0YW5jZVsyXS90aGF0LmJpZ0NhbnZhcy5nZXRXaWR0aCgpKStcInB4XCI7XHJcbiAgICAgICAgdGhhdC5iYWNrZ3JvdW5kU2l6ZSA9IHpyVXRpbC5jbG9uZSh0aGF0LmVhZ2xlRXllTm9kZS5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSk7XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuaW5uZXJIVE1MID0gXCJcIjtcclxuICAgICAgICB0aGF0LnNlbGVjdGlvbi5zdHlsZS5ib3JkZXIgPSBcIjFweCBzb2xpZCAjZmYwMDAwXCI7XHJcbiAgICAgICAgdGhhdC5zZWxlY3Rpb24uc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCI7XHJcbiAgICAgICAgdGhhdC5zZWxlY3Rpb24uc3R5bGUud2lkdGggPSB0aGF0LmJpZ0NhbnZhcy5nZXRXaWR0aCgpL3RoYXQuZ3JvdXAud2lkdGgqZWFnbGVFeWVOb2RlV2lkdGgrXCJweFwiO1xyXG4gICAgICAgIHRoYXQuc2VsZWN0aW9uLnN0eWxlLmhlaWdodCA9IHRoYXQuYmlnQ2FudmFzLmdldEhlaWdodCgpL3RoYXQuZ3JvdXAuaGVpZ2h0KmVhZ2xlRXllTm9kZUhlaWdodCtcInB4XCI7XHJcbiAgICAgICAgdGhhdC5zZWxlY3RXaWR0aCA9IHRoYXQuc2VsZWN0aW9uLnN0eWxlLndpZHRoO1xyXG4gICAgICAgIHRoYXQuc2VsZWN0SGVpZ2h0ID0gdGhhdC5zZWxlY3Rpb24uc3R5bGUuaGVpZ2h0O1xyXG4gICAgICAgIHRoYXQuc2VsZWN0aW9uLnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIjtcclxuICAgICAgICB0aGF0LnNlbGVjdGlvbi5zdHlsZS50b3AgPSAwK1wicHhcIjtcclxuICAgICAgICB0aGF0LnNlbGVjdGlvbi5zdHlsZS5sZWZ0ID0gMCtcInB4XCI7XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuYXBwZW5kQ2hpbGQodGhpcy5zZWxlY3Rpb24pO1xyXG4gICAgfTtcclxuICAgIE1pbmltYXAucHJvdG90eXBlLnVwZGF0YVNlbGVjdGlvbiA9IGZ1bmN0aW9uKG9mZmVjdExlZnQsb2ZmZWN0VG9wLHpvb21TY2FsZSxub3dab29tKXtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhhdC56b29tU2NhbGUgPSB6b29tU2NhbGU7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uc3R5bGUud2lkdGggPSB0aGlzLnNlbGVjdGlvbi5zdHlsZS53aWR0aC5yZXBsYWNlKFwicHhcIixcIlwiKS96b29tU2NhbGUrXCJweFwiO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnN0eWxlLmhlaWdodCA9IHRoaXMuc2VsZWN0aW9uLnN0eWxlLmhlaWdodC5yZXBsYWNlKFwicHhcIixcIlwiKS96b29tU2NhbGUrXCJweFwiO1xyXG4gICAgICAgIHRoYXQuc2VsZWN0UG9zaXRpb25bMF0gPSB6clV0aWwuY2xvbmUob2ZmZWN0TGVmdCkqdGhhdC5yYXRpby9ub3dab29tO1xyXG4gICAgICAgIHRoYXQuc2VsZWN0UG9zaXRpb25bMV0gPSB6clV0aWwuY2xvbmUob2ZmZWN0VG9wKSp0aGF0LnJhdGlvL25vd1pvb207XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uc3R5bGUubGVmdCA9IC10aGF0LnNlbGVjdFBvc2l0aW9uWzBdK1wicHhcIjtcclxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zdHlsZS50b3AgPSAtdGhhdC5zZWxlY3RQb3NpdGlvblsxXStcInB4XCI7XHJcbiAgICB9O1xyXG4gICAgTWluaW1hcC5wcm90b3R5cGUudXBkYXRhTWFwID0gZnVuY3Rpb24oaW1nU3JjLG5ld0dyb3VwKXtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gXCJ1cmwoXCIraW1nU3JjK1wiKVwiO1xyXG4gICAgICAgIHZhciBlYWdsZUV5ZU5vZGVXaWR0aCA9IG5ld0dyb3VwLndpZHRoICAqIHRoYXQucmF0aW87XHJcbiAgICAgICAgdmFyIGVhZ2xlRXllTm9kZUhlaWdodCA9IG5ld0dyb3VwLmhlaWdodCAgKiB0aGF0LnJhdGlvO1xyXG4gICAgICAgIHRoYXQuZWFnbGVFeWVOb2RlLnN0eWxlLndpZHRoID0gZWFnbGVFeWVOb2RlV2lkdGgrXCJweFwiO1xyXG4gICAgICAgIHRoYXQuZWFnbGVFeWVOb2RlLnN0eWxlLmhlaWdodCA9IGVhZ2xlRXllTm9kZUhlaWdodCtcInB4XCI7XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuc3R5bGUubWFyZ2luVG9wID0gLWVhZ2xlRXllTm9kZUhlaWdodCtcInB4XCI7XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuc3R5bGUubWFyZ2luTGVmdCA9IHRoYXQuYmlnQ2FudmFzLmdldFdpZHRoKCktZWFnbGVFeWVOb2RlV2lkdGgrXCJweFwiO1xyXG4gICAgfTtcclxuICAgIE1pbmltYXAucHJvdG90eXBlLnVwZGF0YVNlbGVjdGlvblBvc2l0aW9uID0gZnVuY3Rpb24obm93R3JvdXBQb3NpdGlvbixub3dab29tKXtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhhdC5zZWxlY3RQb3NpdGlvblswXSA9IHpyVXRpbC5jbG9uZShub3dHcm91cFBvc2l0aW9uWzBdKSp0aGF0LnJhdGlvL25vd1pvb207XHJcbiAgICAgICAgdGhhdC5zZWxlY3RQb3NpdGlvblsxXSA9IHpyVXRpbC5jbG9uZShub3dHcm91cFBvc2l0aW9uWzFdKSp0aGF0LnJhdGlvL25vd1pvb207XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uc3R5bGUubGVmdCA9IC10aGF0LnNlbGVjdFBvc2l0aW9uWzBdK1wicHhcIjtcclxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zdHlsZS50b3AgPSAtdGhhdC5zZWxlY3RQb3NpdGlvblsxXStcInB4XCI7XHJcbiAgICB9O1xyXG4gICAgTWluaW1hcC5wcm90b3R5cGUudXBkYXRhR3JvdXBQb3NpdGlvbiA9IGZ1bmN0aW9uKGdyb3VwLG5vd1pvb20pe1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgcG9zaXRpb25YID0gLU51bWJlcih0aGF0LnNlbGVjdGlvbi5zdHlsZS5sZWZ0LnN1YnN0cmluZygwLHRoYXQuc2VsZWN0aW9uLnN0eWxlLmxlZnQubGVuZ3RoLTIpKS90aGF0LnJhdGlvKm5vd1pvb207XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uWSA9IC1OdW1iZXIodGhhdC5zZWxlY3Rpb24uc3R5bGUudG9wLnN1YnN0cmluZygwLHRoYXQuc2VsZWN0aW9uLnN0eWxlLnRvcC5sZW5ndGgtMikpL3RoYXQucmF0aW8qbm93Wm9vbTtcclxuICAgICAgICBncm91cC5hdHRyKFwicG9zaXRpb25cIixbcG9zaXRpb25YLHBvc2l0aW9uWV0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1pbmltYXA7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWluaW1hcC5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOW3peWFt+aWueazleexu1xyXG4gKiBAYXV0aG9yIHdhbmcueGlhb2h1XHJcbiAqL1xyXG5cclxuICAgIHZhciBQb2ludCA9IHJlcXVpcmUoXCIuL1BvaW50LmpzXCIpO1xyXG4gICAgdmFyIExpbmUgPSByZXF1aXJlKFwiLi9MaW5lU3RydWN0LmpzXCIpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0Jyk7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICAvKipcclxuICAgICAqIOaehOmAoOexu+e7p+aJv+WFs+ezu1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNsYXp6IOa6kOexu1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZUNsYXp6IOWfuuexu1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpbmhlcml0cyhjbGF6eiwgYmFzZUNsYXp6KSB7XHJcbiAgICAgICAgdmFyIGNsYXp6UHJvdG90eXBlID0gY2xhenoucHJvdG90eXBlO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBGKCkge31cclxuICAgICAgICBGLnByb3RvdHlwZSA9IGJhc2VDbGF6ei5wcm90b3R5cGU7XHJcbiAgICAgICAgY2xhenoucHJvdG90eXBlID0gbmV3IEYoKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBjbGF6elByb3RvdHlwZSkge1xyXG4gICAgICAgICAgICBjbGF6ei5wcm90b3R5cGVbcHJvcF0gPSBjbGF6elByb3RvdHlwZVtwcm9wXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xhenoucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY2xheno7XHJcbiAgICAgICAgY2xhenouc3VwZXJDbGFzcyA9IGJhc2VDbGF6ejtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRVVUlEKCkge1xyXG4gICAgICAgIHZhciBjaGFycyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicuc3BsaXQoJycpLFxyXG4gICAgICAgICAgICB1dWlkID0gbmV3IEFycmF5KDM2KSxcclxuICAgICAgICAgICAgcm5kID0gMCxcclxuICAgICAgICAgICAgcjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM2OyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGkgPT0gOCB8fCBpID09IDEzIHx8IGkgPT0gMTggfHwgaSA9PSAyMykge1xyXG4gICAgICAgICAgICAgICAgdXVpZFtpXSA9ICctJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpID09IDE0KSB7XHJcbiAgICAgICAgICAgICAgICB1dWlkW2ldID0gJzQnO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJuZCA8PSAweDAyKSBybmQgPSAweDIwMDAwMDAgKyAoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMCkgfCAwO1xyXG4gICAgICAgICAgICAgICAgciA9IHJuZCAmIDB4ZjtcclxuICAgICAgICAgICAgICAgIHJuZCA9IHJuZCA+PiA0O1xyXG4gICAgICAgICAgICAgICAgdXVpZFtpXSA9IGNoYXJzWyhpID09IDE5KSA/IChyICYgMHgzKSB8IDB4OCA6IHJdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcInNpZC1cIiArIHV1aWQuam9pbignJyk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6h566X5Lik54K55LmL6Ze055qE6Led56a7XHJcbiAgICAgKkBwYXJhbSB7UG9pbnR9IHAxIC0gZmlyc3Qge1BvaW50fVxyXG4gICAgICpAcGFyYW0ge1BvaW50fSBwMiAtIHNlY29uZCB7UG9pbnR9XHJcbiAgICAgKkByZXR1cm4ge051bWJlcn0gLSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aG9zZSAyIHBvaW50cy4gSXQgaXMgYWx3YXlzIHBvc2l0aXZlLlxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gZGlzdGFuY2UocDEsIHAyKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwMS54IC0gcDIueCwgMikgKyBNYXRoLnBvdyhwMS55IC0gcDIueSwgMikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6L+U5Zue5LiA5p2h5oqY57q/IOacgOmVv+eahOS4pOS4queCuVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBwb2ludHMgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRNYXhMaW5lTGVuZ3RoKHBvaW50cykge1xyXG4gICAgICAgIHZhciBtID0gZGlzdGFuY2UocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbcG9pbnRzWzBdLCBwb2ludHNbMV1dO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKG0gPCBkaXN0YW5jZShwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pKSB7XHJcbiAgICAgICAgICAgICAgICBtID0gZGlzdGFuY2UocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3BvaW50c1tpXSwgcG9pbnRzW2kgKyAxXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqUmV0dXJucyB0aGUgbGVuZ3RoIG9mIGEgUG9seWxpbmUgdGhhdCB3b3VsZCBiZSBjcmVhdGVkIHdpdGggYSBzZXQgb2YgcG9pbnRzXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHYgLSBhbiB7QXJyYXl9IG9mIHtQb2ludHN9XHJcbiAgICAgKkByZXR1cm4ge051bWJlcn0gLSBhIHBvc2l0aXZlIG51bWJlciBlcXVhbCB3aXRoIHRvdGFsIGxlbmd0aCovXHJcbiAgICBmdW5jdGlvbiBnZXRQb2x5bGluZUxlbmd0aCh2KSB7XHJcbiAgICAgICAgdmFyIGwgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgbCArPSBkaXN0YW5jZSh2W2ldLCB2W2kgKyAxXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqUmV0dXJucyB0aGUgbWF4IG9mIGEgdmVjdG9yXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHYgLSB2ZWN0b3Igb2Yge051bWJlcn1zXHJcbiAgICAgKkByZXR1cm4ge051bWJlcn0gLSB0aGUgbWF4aW11bSBudW1iZXIgZnJvbSB0aGUgdmVjdG9yIG9yIE5hTiBpZiB2ZWN0b3IgaXMgZW1wdHlcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIG1heCh2KSB7XHJcbiAgICAgICAgaWYgKHYubGVuZ2h0ID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbSA9IHZbMF07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG0gPCB2W2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IHZbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqUmV0dXJucyB0aGUgbWluIG9mIGEgdmVjdG9yXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHYgLSB2ZWN0b3Igb2Yge051bWJlcn1zXHJcbiAgICAgKkByZXR1cm4ge051bWJlcn0gLSB0aGUgbWluaW11bSBudW1iZXIgZnJvbSB0aGUgdmVjdG9yIG9yIE5hTiBpZiB2ZWN0b3IgaXMgZW1wdHlcclxuICAgICAqQGF1dGhvciBhbGV4QHNjcmlwdG9pZC5jb21cclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIG1pbih2KSB7XHJcbiAgICAgICAgaWYgKHYubGVuZ2h0ID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbSA9IHZbMF07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG0gPiB2W2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IHZbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIpOaWrSDngrnmlbDnu4Qg5piv5ZCm5q2j5Lqk55u057q/6Lev5b6EXHJcbiAgICAgKlRlc3RzIGlmIGEgdmVjdG9yIG9mIHBvaW50cyBpcyBhbiBvcnRob2dvbmFsIHBhdGggKG1vdmluZyBpbiBtdWx0aXBsZXMgb2YgOTAgZGVncmVlcylcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIGFuIHtBcnJheX0gb2Yge1BvaW50fXNcclxuICAgICAqQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlmIHBhdGggaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gb3J0aG9nb25hbFBhdGgodikge1xyXG4gICAgICAgIGlmICh2Lmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodltpXS54ICE9IHZbaSArIDFdLnggJiYgdltpXS55ICE9IHZbaSArIDFdLnkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICpUZXN0IHRvIHNlZSBpZiAyIHtMaW5lfXMgaW50ZXJzZWN0cy4gVGhleSBhcmUgY29uc2lkZXJlZCBmaW5pdGUgc2VnbWVudHNcclxuICAgICAqYW5kIG5vdCB0aGUgaW5maW5pdGUgbGluZXMgZnJvbSBnZW9tZXRyeVxyXG4gICAgICpAcGFyYW0ge0xpbmV9IGwxIC0gZmlzdCBsaW5lL3NlZ21lbnRcclxuICAgICAqQHBhcmFtIHtMaW5lfSBsMiAtIGxhc3QgbGluZS9zZWdtZW50XHJcbiAgICAgKkByZXR1cm4ge0Jvb2xlYW59IHRydWUgLSBpZiB0aGUgbGluZXMgaW50ZXJzZWN0IG9yIGZhbHNlIGlmIG5vdFxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gbGluZUludGVyc2VjdHNMaW5lKGwxLCBsMikge1xyXG4gICAgICAgIC8vIGNoZWNrIGZvciB0d28gdmVydGljYWwgbGluZXNcclxuICAgICAgICBpZiAobDEuc3RhcnRQb2ludC54ID09IGwxLmVuZFBvaW50LnggJiYgbDIuc3RhcnRQb2ludC54ID09IGwyLmVuZFBvaW50LngpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGwxLnN0YXJ0UG9pbnQueCA9PSBsMi5zdGFydFBvaW50LnggPyAvLyBpZiAnaW5maW5pdGUgJ2xpbmVzIGRvIGNvaW5jaWRlLFxyXG4gICAgICAgICAgICAgICAgLy8gdGhlbiBjaGVjayBzZWdtZW50IGJvdW5kcyBmb3Igb3ZlcmxhcHBpbmdcclxuICAgICAgICAgICAgICAgIGwxLmNvbnRhaW5zKGwyLnN0YXJ0UG9pbnQueCwgbDIuc3RhcnRQb2ludC55KSB8fFxyXG4gICAgICAgICAgICAgICAgbDEuY29udGFpbnMobDIuZW5kUG9pbnQueCwgbDIuZW5kUG9pbnQueSkgOlxyXG4gICAgICAgICAgICAgICAgLy8gbGluZXMgYXJlIHBhcmFsZWxcclxuICAgICAgICAgICAgICAgIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiBvbmUgbGluZSBpcyB2ZXJ0aWNhbCwgYW5kIGFub3RoZXIgbGluZSBpcyBub3QgdmVydGljYWxcclxuICAgICAgICBlbHNlIGlmIChsMS5zdGFydFBvaW50LnggPT0gbDEuZW5kUG9pbnQueCB8fCBsMi5zdGFydFBvaW50LnggPT0gbDIuZW5kUG9pbnQueCkge1xyXG4gICAgICAgICAgICAvLyBsZXQgYXNzdW1lIGwyIGlzIHZlcnRpY2FsLCBvdGhlcndpc2UgZXhjaGFuZ2UgdGhlbVxyXG4gICAgICAgICAgICBpZiAobDEuc3RhcnRQb2ludC54ID09IGwxLmVuZFBvaW50LngpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsID0gbDE7XHJcbiAgICAgICAgICAgICAgICBsMSA9IGwyO1xyXG4gICAgICAgICAgICAgICAgbDIgPSBsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGZpbmRpbmcgaW50ZXJzZWN0aW9uIG9mICdpbmZpbml0ZScgbGluZXNcclxuICAgICAgICAgICAgLy8gZXF1YXRpb24gb2YgdGhlIGZpcnN0IGxpbmUgaXMgeSA9IGF4ICsgYiwgc2Vjb25kOiB4ID0gY1xyXG4gICAgICAgICAgICB2YXIgYSA9IChsMS5lbmRQb2ludC55IC0gbDEuc3RhcnRQb2ludC55KSAvIChsMS5lbmRQb2ludC54IC0gbDEuc3RhcnRQb2ludC54KTtcclxuICAgICAgICAgICAgdmFyIGIgPSBsMS5zdGFydFBvaW50LnkgLSBhICogbDEuc3RhcnRQb2ludC54O1xyXG4gICAgICAgICAgICB2YXIgeDAgPSBsMi5zdGFydFBvaW50Lng7XHJcbiAgICAgICAgICAgIHZhciB5MCA9IGEgKiB4MCArIGI7XHJcbiAgICAgICAgICAgIHJldHVybiBsMS5jb250YWlucyh4MCwgeTApICYmIGwyLmNvbnRhaW5zKHgwLCB5MCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjaGVjayBub3JtYWwgY2FzZSAtIGJvdGggbGluZXMgYXJlIG5vdCB2ZXJ0aWNhbFxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvL2xpbmUgZXF1YXRpb24gaXMgOiB5ID0gYSp4ICsgYiwgYiA9IHkgLSBhICogeFxyXG4gICAgICAgICAgICB2YXIgYTEgPSAobDEuZW5kUG9pbnQueSAtIGwxLnN0YXJ0UG9pbnQueSkgLyAobDEuZW5kUG9pbnQueCAtIGwxLnN0YXJ0UG9pbnQueCk7XHJcbiAgICAgICAgICAgIHZhciBiMSA9IGwxLnN0YXJ0UG9pbnQueSAtIGExICogbDEuc3RhcnRQb2ludC54O1xyXG5cclxuICAgICAgICAgICAgdmFyIGEyID0gKGwyLmVuZFBvaW50LnkgLSBsMi5zdGFydFBvaW50LnkpIC8gKGwyLmVuZFBvaW50LnggLSBsMi5zdGFydFBvaW50LngpO1xyXG4gICAgICAgICAgICB2YXIgYjIgPSBsMi5zdGFydFBvaW50LnkgLSBhMiAqIGwyLnN0YXJ0UG9pbnQueDtcclxuXHJcbiAgICAgICAgICAgIGlmIChhMSA9PSBhMikgeyAvL3BhcmFsZWwgbGluZXNcclxuICAgICAgICAgICAgICAgIHJldHVybiBiMSA9PSBiMiA/XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGNvaW5jaWRlIGxpbmVzLCBjaGVjayBmb3Igc2VnbWVudCBib3VuZHMgb3ZlcmxhcHBpbmdcclxuICAgICAgICAgICAgICAgICAgICBsMS5jb250YWlucyhsMi5zdGFydFBvaW50LngsIGwyLnN0YXJ0UG9pbnQueSkgfHwgbDEuY29udGFpbnMobDIuZW5kUG9pbnQueCwgbDIuZW5kUG9pbnQueSkgOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBjb2luY2lkZSBwYXJhbGVsIGxpbmVzIGhhdmUgbm8gY2hhbmNlIHRvIGludGVyc2VjdFxyXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlO1xyXG4gICAgICAgICAgICB9IGVsc2UgeyAvL3VzdWFsIGNhc2UgLSBub24gcGFyYWxlbCwgdGhlICdpbmZpbml0ZScgbGluZXMgaW50ZXJzZWN0cy4uLndlIG9ubHkgbmVlZCB0byBrbm93IGlmIGluc2lkZSB0aGUgc2VnbWVudFxyXG5cclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBpZiBvbmUgb2YgdGhlIGxpbmVzIGFyZSB2ZXJ0aWNhbCwgdGhlbiB4MCBpcyBlcXVhbCB0byB0aGVpciB4LFxyXG4gICAgICAgICAgICAgICAgICogb3RoZXJ3aXNlOlxyXG4gICAgICAgICAgICAgICAgICogeTEgPSBhMSAqIHggKyBiMVxyXG4gICAgICAgICAgICAgICAgICogeTIgPSBhMiAqIHggKyBiMlxyXG4gICAgICAgICAgICAgICAgICogPT4geDAgPSAoYjIgLSBiMSkgLyAoYTEgLSBhMilcclxuICAgICAgICAgICAgICAgICAqID0+IHkwID0gYTEgKiB4MCArIGIxXHJcbiAgICAgICAgICAgICAgICAgKiovXHJcbiAgICAgICAgICAgICAgICB4MCA9IChiMiAtIGIxKSAvIChhMSAtIGEyKTtcclxuICAgICAgICAgICAgICAgIHkwID0gYTEgKiB4MCArIGIxO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGwxLmNvbnRhaW5zKHgwLCB5MCkgJiYgbDIuY29udGFpbnMoeDAsIHkwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlRlc3RzIGlmIGEgYSBwb2x5bGluZSBkZWZpbmVkIGJ5IGEgc2V0IG9mIHBvaW50cyBpbnRlcnNlY3RzIGEgcmVjdGFuZ2xlXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHBvaW50cyAtIGFuZCB7QXJyYXl9IG9mIHtQb2ludH1zXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IGJvdW5kcyAtIHRoZSBib3VuZHMgb2YgdGhlIHJlY3RhbmdsZSBkZWZpbmVkIGJ5ICh4MSwgeTEsIHgyLCB5MilcclxuICAgICAqQHBhcmFtIHtCb29sZWFufSBjbG9zZWRQb2x5bGluZSAtIGluY2FzZSBwb2x5bGluZSBpcyBjbG9zZWQgZmlndXJlIHRoZW4gdHJ1ZSwgZWxzZSBmYWxzZVxyXG4gICAgICpcclxuICAgICAqQHJldHVybiB0cnVlIC0gaWYgbGluZSBpbnRlcnNlY3RzIHRoZSByZWN0YW5nbGUsIGZhbHNlIC0gaWYgbm90XHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBwb2x5bGluZUludGVyc2VjdHNSZWN0YW5nbGUocG9pbnRzLCBib3VuZHMsIGNsb3NlZFBvbHlsaW5lKSB7XHJcblxyXG5cclxuICAgICAgICAvL2dldCB0aGUgNCBsaW5lcy9zZWdtZW50cyByZXByZXNlbnRlZCBieSB0aGUgYm91bmRzXHJcbiAgICAgICAgdmFyIGxpbmVzID0gW107XHJcbiAgICAgICAgbGluZXMucHVzaChuZXcgTGluZShuZXcgUG9pbnQoYm91bmRzWzBdLCBib3VuZHNbMV0pLCBuZXcgUG9pbnQoYm91bmRzWzJdLCBib3VuZHNbMV0pKSk7XHJcbiAgICAgICAgbGluZXMucHVzaChuZXcgTGluZShuZXcgUG9pbnQoYm91bmRzWzJdLCBib3VuZHNbMV0pLCBuZXcgUG9pbnQoYm91bmRzWzJdLCBib3VuZHNbM10pKSk7XHJcbiAgICAgICAgbGluZXMucHVzaChuZXcgTGluZShuZXcgUG9pbnQoYm91bmRzWzJdLCBib3VuZHNbM10pLCBuZXcgUG9pbnQoYm91bmRzWzBdLCBib3VuZHNbM10pKSk7XHJcbiAgICAgICAgbGluZXMucHVzaChuZXcgTGluZShuZXcgUG9pbnQoYm91bmRzWzBdLCBib3VuZHNbM10pLCBuZXcgUG9pbnQoYm91bmRzWzBdLCBib3VuZHNbMV0pKSk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcG9pbnRzLmxlbmd0aCAtIDE7IGsrKykge1xyXG4gICAgICAgICAgICAvL2NyZWF0ZSBhIGxpbmUgb3V0IG9mIGVhY2ggMiBjb25zZWN1dGl2ZSBwb2ludHNcclxuICAgICAgICAgICAgdmFyIHRlbXBMaW5lID0gbmV3IExpbmUocG9pbnRzW2tdLCBwb2ludHNbayArIDFdKTtcclxuXHJcbiAgICAgICAgICAgIC8vc2VlIGlmIHRoYXQgbGluZSBpbnRlcnNlY3QgYW55IG9mIHRoZSBsaW5lIG9uIGJvdW5kcyBib3JkZXJcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVJbnRlcnNlY3RzTGluZSh0ZW1wTGluZSwgbGluZXNbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY2hlY2sgdGhlIGNsb3NlZCBmaWd1cmUgLSB0aGF0IGlzIGxhc3QgcG9pbnQgY29ubmVjdGVkIHRvIHRoZSBmaXJzdFxyXG4gICAgICAgIGlmIChjbG9zZWRQb2x5bGluZSkge1xyXG4gICAgICAgICAgICAvL2NyZWF0ZSBhIGxpbmUgb3V0IG9mIGVhY2ggMiBjb25zZWN1dGl2ZSBwb2ludHNcclxuICAgICAgICAgICAgdmFyIHRlbXBMaW5lMSA9IG5ldyBMaW5lKHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0sIHBvaW50c1swXSk7XHJcblxyXG4gICAgICAgICAgICAvL3NlZSBpZiB0aGF0IGxpbmUgaW50ZXJzZWN0IGFueSBvZiB0aGUgbGluZSBvbiBib3VuZHMgYm9yZGVyXHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChsaW5lSW50ZXJzZWN0c0xpbmUodGVtcExpbmUxLCBsaW5lc1tqXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6h566X6Lev5b6E55qE5YiG5pWwXHJcbiAgICAgKiBTY29yZSBhIG9ydG9nb25hbCBwYXRoIG1hZGUgb3V0IG9mIFBvaW50c1xyXG4gICAgICpJdGVyYXRlcyBvdmVyIGEgc2V0IG9mIHBvaW50cyAobWluaW11bSAzKVxyXG4gICAgICpGb3IgZWFjaCAzIHBvaW50cyAoaSwgaSsxLCBpKzIpIDpcclxuICAgICAqICAtIGlmIHRoZSAzcmQgb25lIGlzIGFmdGVyIHRoZSAybmQgb24gdGhlIHNhbWUgbGluZSB3ZSBhZGQgKzFcclxuICAgICAqICAtIGlmIHRoZSAzcmQgaXMgdXAgb3IgZG93biByZWxhdGVkIHRvIHRoZSAybmQgd2UgZG8gbm90IGRvIGFueXRoaW5nICswXHJcbiAgICAgKiAgLSBpZiB0aGUgM3JkIGdvZXMgYmFjayB3ZSBpbWVkaWF0ZWxseSByZXR1cm4gLTFcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIGFuIGFycmF5IG9mIHtQb2ludH1zXHJcbiAgICAgKkByZXR1cm4ge051bWJlcn0gLSAtMSBpZiB0aGUgcGF0aCBpcyB3cm9uZyAoZ29lcyBiYWNrKSBvciBzb21ldGhpbmcgPj0gMCBpZiBpcyBmaW5lXHJcbiAgICAgKiAgVGhlIGJpZ2dlciB0aGUgbnVtYmVyIHRoZSBzbW9vdGggdGhlIHBhdGggaXNcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIHNjb3JlUGF0aCh2KSB7XHJcbiAgICAgICAgaWYgKHYubGVuZ3RoIDw9IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNjb3JlID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHYubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh2W2kgLSAxXS54ID09IHZbaV0ueCAmJiB2W2ldLnggPT0gdltpICsgMV0ueCkgeyAvL29uIHRoZSBzYW1lIHZlcnRpY2FsXHJcbiAgICAgICAgICAgICAgICBpZiAoc2lnbnVtKHZbaSArIDFdLnkgLSB2W2ldLnkpID09IHNpZ251bSh2W2ldLnkgLSB2W2kgLSAxXS55KSkgeyAvL3NhbWUgZGlyZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcmUrKztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vZ29pbmcgYmFjayAtIG5vIGdvb2RcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodltpIC0gMV0ueSA9PSB2W2ldLnkgJiYgdltpXS55ID09IHZbaSArIDFdLnkpIHsgLy9vbiB0aGUgc2FtZSBob3Jpem9udGFsXHJcbiAgICAgICAgICAgICAgICBpZiAoc2lnbnVtKHZbaSArIDFdLnggLSB2W2ldLngpID09IHNpZ251bSh2W2ldLnggLSB2W2kgLSAxXS54KSkgeyAvL3NhbWUgZGlyZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcmUrKztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vZ29pbmcgYmFjayAtIG5vIGdvb2RcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vbm90IG9uIHNhbWUgdmVydGljYWwgbm9yIGhvcml6b250YWxcclxuICAgICAgICAgICAgICAgIHNjb3JlLS07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzY29yZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOi/lOWbnuaVsOWtl+espuWPt++8iCsgLSlcclxuICAgICAqIFJldHVybnMgdGhlIHNpZ24gb2YgYSBudW1iZXJcclxuICAgICAqQHBhcmFtIHtOdW1iZXJ9IHggLSB0aGUgbnVtYmVyXHJcbiAgICAgKkByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKkBzZWUgPGEgaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2lnbl9mdW5jdGlvblwiPmh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2lnbl9mdW5jdGlvbjwvYT5cclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIHNpZ251bSh4KSB7XHJcbiAgICAgICAgaWYgKHggPiAwKVxyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICBlbHNlIGlmICh4IDwgMClcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliKTmlq0g54K55pWw57uEIOaYr+S4jeaYr+acieaViOi3r+W+hO+8iOayoeacieWbnui3r++8iVxyXG4gICAgICpUZXN0cyBpZiBhIHZlY3RvciBvZiBwb2ludHMgaXMgYSB2YWxpZCBwYXRoIChub3QgZ29pbmcgYmFjaylcclxuICAgICAqVGhlcmUgYXJlIGEgZmV3IHByb2JsZW1zIGhlcmUuIElmIHlvdSBoYXZlIHAxLCBwMiwgcDMgYW5kIHA0IGFuZCBwMiA9IHAzIHlvdSBuZWVkIHRvIGlnbm9yZSB0aGF0XHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHYgLSBhbiB7QXJyYXl9IG9mIHtQb2ludH1zXHJcbiAgICAgKkByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiBwYXRoIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIGZvcndhcmRQYXRoKHYpIHtcclxuICAgICAgICBpZiAodi5sZW5ndGggPD0gMikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGggLSAyOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHZbaV0ueCA9PSB2W2kgKyAxXS54ICYmIHZbaSArIDFdLnggPT0gdltpICsgMl0ueCkgeyAvL29uIHRoZSBzYW1lIHZlcnRpY2FsXHJcbiAgICAgICAgICAgICAgICBpZiAoc2lnbnVtKHZbaSArIDFdLnkgLSB2W2ldLnkpICE9IDApIHsgLy90ZXN0IG9ubHkgd2UgaGF2ZSBhIHByb2dyZXNzaW5nIHBhdGhcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnbnVtKHZbaSArIDFdLnkgLSB2W2ldLnkpID09IC0xICogc2lnbnVtKHZbaSArIDJdLnkgLSB2W2kgKyAxXS55KSkgeyAvL2dvaW5nIGJhY2sgKGlnbm9yZSB6ZXJvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZbaV0ueSA9PSB2W2kgKyAxXS55ICYmIHZbaSArIDFdLnkgPT0gdltpICsgMl0ueSkgeyAvL29uIHRoZSBzYW1lIGhvcml6b250YWxcclxuICAgICAgICAgICAgICAgIGlmIChzaWdudW0odltpICsgMV0ueCAtIHZbaV0ueCkgIT0gMCkgeyAvL3Rlc3Qgb25seSB3ZSBoYXZlIGEgcHJvZ3Jlc3NpbmcgcGF0aFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWdudW0odltpICsgMV0ueCAtIHZbaV0ueCkgPT0gLTEgKiBzaWdudW0odltpICsgMl0ueCAtIHZbaSArIDFdLngpKSB7IC8vZ29pbmcgYmFjayAoaWdub3JlIHplcm8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5bCGW3g6MCx5OjBd6L2s5YyW5Li6WzAsIDBdICDnu5l6cmVuZGVy5L2/55SoXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHBvaW50cyBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGlzUmV2ZXJ0IFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdHJhc2xhdGVQb2ludHMocG9pbnRzLCBpc1JldmVydCkge1xyXG4gICAgICAgIHZhciBuZXdQb2ludHMgPSBbXTtcclxuICAgICAgICBpZiAoaXNSZXZlcnQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcclxuICAgICAgICAgICAgICAgIG5ld1BvaW50cy5wdXNoKG5ldyBQb2ludChwb2ludFswXSwgcG9pbnRbMV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3UG9pbnRzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9pbnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQxID0gcG9pbnRzW2pdO1xyXG4gICAgICAgICAgICAgICAgbmV3UG9pbnRzLnB1c2goW3BvaW50MS54LCBwb2ludDEueV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdQb2ludHM7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcm90YXRpb25NYXRyaXgoYW5nbGUpIHtcclxuICAgICAgICB2YXIgbVJldHVybiA9IFtcclxuICAgICAgICAgICAgW01hdGguY29zKGFuZ2xlKSwgLU1hdGguc2luKGFuZ2xlKSwgMF0sXHJcbiAgICAgICAgICAgIFtNYXRoLnNpbihhbmdsZSksIE1hdGguY29zKGFuZ2xlKSwgMF0sXHJcbiAgICAgICAgICAgIFswLCAwLCAxXVxyXG4gICAgICAgIF07XHJcbiAgICAgICAgcmV0dXJuIG1SZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdHJhbnNsYXRpb25NYXRyaXgoZHgsIGR5KSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgWzEsIDAsIGR4XSxcclxuICAgICAgICAgICAgWzAsIDEsIGR5XSxcclxuICAgICAgICAgICAgWzAsIDAsIDFdXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzY2FsZU1hdHJpeChzeCwgc3kpIHtcclxuICAgICAgICBpZiAoc3kgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzeSA9IHN4O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBbc3gsIDAsIDBdLFxyXG4gICAgICAgICAgICBbMCwgc3ksIDBdLFxyXG4gICAgICAgICAgICBbMCwgMCwgMV1cclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBJdCB3aWxsIHJldHVybiB0aGUgZW5kIHBvaW50IG9mIGEgbGluZSBvbiBhIGdpdmVuIGFuZ2xlIChjbG9ja3dpc2UpLlxyXG4gICAgICogQHBhcmFtIHtQb2ludH0gc3RhcnRQb2ludCAtIHRoZSBzdGFydCBvZiB0aGUgbGluZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIHRoZSBsZW5ndGggb2YgdGhlIGxpbmVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSAtIHRoZSBhbmdsZSBvZiB0aGUgbGluZSBpbiByYWRpYW5zXHJcbiAgICAgKiBAcmV0dXJuIHtQb2ludH0gLSB0aGUgZW5kUG9pbnQgb2YgdGhlIGxpbmVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0RW5kUG9pbnQoc3RhcnRQb2ludCwgbGVuZ3RoLCBhbmdsZSkge1xyXG4gICAgICAgIHZhciBlbmRQb2ludCA9IHN0YXJ0UG9pbnQuY2xvbmUoKTtcclxuICAgICAgICBlbmRQb2ludC50cmFuc2Zvcm0odHJhbnNsYXRpb25NYXRyaXgoLXN0YXJ0UG9pbnQueCwgLXN0YXJ0UG9pbnQueSkpO1xyXG4gICAgICAgIGVuZFBvaW50LnkgLT0gbGVuZ3RoO1xyXG4gICAgICAgIGVuZFBvaW50LnRyYW5zZm9ybShyb3RhdGlvbk1hdHJpeChhbmdsZSkpO1xyXG4gICAgICAgIGVuZFBvaW50LnRyYW5zZm9ybSh0cmFuc2xhdGlvbk1hdHJpeChzdGFydFBvaW50LngsIHN0YXJ0UG9pbnQueSkpO1xyXG4gICAgICAgIHJldHVybiBlbmRQb2ludDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluiOt+WPluS4pOS4quWbvuW9oueahOWklumdouWbm+S4qui/nuaOpeeCuVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSByZWN0IFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbm9kZSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRDb25uZWN0b3JQb2ludHMocmVjdCwgbm9kZSkge1xyXG4gICAgICAgIG5vZGUgPSBub2RlIHx8IHt9O1xyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB6clV0aWwuY2xvbmUocmVjdC5ib3VuZGluZ1JlY3QgfHwgcmVjdCk7XHJcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gbm9kZS5yb3RhdGlvbjtcclxuICAgICAgICB2YXIgcG9pbnRzID0ge1xyXG4gICAgICAgICAgICBsZWZ0OiBuZXcgUG9pbnQoYm91bmRpbmdSZWN0LngsIGJvdW5kaW5nUmVjdC55ICsgYm91bmRpbmdSZWN0LmhlaWdodCAvIDIpLCAvL+efqeW9oiDlt6bkuK3nmoTkvY3nva5cclxuICAgICAgICAgICAgdG9wOiBuZXcgUG9pbnQoYm91bmRpbmdSZWN0LnggKyBib3VuZGluZ1JlY3Qud2lkdGggLyAyLCBib3VuZGluZ1JlY3QueSksIC8v55+p5b2iIOS4iuS4reeahOS9jee9rlxyXG4gICAgICAgICAgICByaWdodDogbmV3IFBvaW50KGJvdW5kaW5nUmVjdC54ICsgYm91bmRpbmdSZWN0LndpZHRoLCBib3VuZGluZ1JlY3QueSArIGJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyKSwgLy/nn6nlvaIg5Y+z5Lit55qE5L2N572uXHJcbiAgICAgICAgICAgIGJvdHRvbTogbmV3IFBvaW50KGJvdW5kaW5nUmVjdC54ICsgYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgYm91bmRpbmdSZWN0LnkgKyBib3VuZGluZ1JlY3QuaGVpZ2h0KSwgLy/nn6nlvaIg5LiL5Lit55qE5L2N572uXHJcbiAgICAgICAgICAgIGNlbnRlcjogbmV3IFBvaW50KGJvdW5kaW5nUmVjdC54ICsgYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgYm91bmRpbmdSZWN0LnkgKyBib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMikgLy/kuK3pl7TkvY3nva5cclxuXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoT2JqZWN0LmtleXMobm9kZSkubGVuZ3RoID4gMCAmJiBNYXRoLmFicyhyb3RhdGlvbikgPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciByZWN0TmV3ID0gcmVjdC5ib3VuZGluZ1JlY3QgPyByZWN0IDogZ2V0UmVjdChub2RlKTtcclxuICAgICAgICAgICAgdmFyIGNlbnRlciA9IHsgeDogcmVjdE5ldy54LCB5OiByZWN0TmV3LnkgfTsgLy8g5Lit5b+D54K5XHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHBvaW50cykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBvaW50c1trZXldO1xyXG4gICAgICAgICAgICAgICAgdmFyIHgwID0gY2VudGVyLnggLSB2YWx1ZS54O1xyXG4gICAgICAgICAgICAgICAgdmFyIHkwID0gY2VudGVyLnkgLSB2YWx1ZS55O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKC1yb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoLXJvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbl9uX3ggPSBjZW50ZXIueCAtICh4MCAqIGNvcyAtIHkwICogc2luKTtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbl9uX3kgPSBjZW50ZXIueSAtICh4MCAqIHNpbiArIHkwICogY29zKTtcclxuICAgICAgICAgICAgICAgIHBvaW50c1trZXldLnggPSBwb3NpdGlvbl9uX3g7XHJcbiAgICAgICAgICAgICAgICBwb2ludHNba2V5XS55ID0gcG9zaXRpb25fbl95O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBvaW50cztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluiKgueCueWklumdouWbm+S4quaOp+WItueCueWSjOaXi+i9rOeCuVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBub2RlIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldENvbm5lY3RvckNvbnRyb2xzKHJlY3QsIG5vZGUpIHtcclxuICAgICAgICBub2RlID0gbm9kZSB8fCB7fTtcclxuICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0genJVdGlsLmNsb25lKHJlY3QuYm91bmRpbmdSZWN0KTtcclxuICAgICAgICB2YXIgcm90YXRpb24gPSBub2RlLnJvdGF0aW9uO1xyXG4gICAgICAgIHZhciBjb250cm9scyA9IHtcclxuICAgICAgICAgICAgdGw6IG5ldyBQb2ludChib3VuZGluZ1JlY3QueCwgYm91bmRpbmdSZWN0LnkpLCAvL+efqeW9oiDlt6bkuIrop5LkvY3nva5cclxuICAgICAgICAgICAgdGM6IG5ldyBQb2ludChib3VuZGluZ1JlY3QueCArIGJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIGJvdW5kaW5nUmVjdC55IC0gNCksIC8v55+p5b2iIOS4iuS4reS9jee9rlxyXG4gICAgICAgICAgICB0cjogbmV3IFBvaW50KGJvdW5kaW5nUmVjdC54ICsgYm91bmRpbmdSZWN0LndpZHRoLCBib3VuZGluZ1JlY3QueSksIC8v55+p5b2iIOWPs+S4iuinkuS9jee9rlxyXG4gICAgICAgICAgICBibDogbmV3IFBvaW50KGJvdW5kaW5nUmVjdC54LCBib3VuZGluZ1JlY3QueSArIGJvdW5kaW5nUmVjdC5oZWlnaHQpLCAvL+efqeW9oiDlt6bkuIvop5JcclxuICAgICAgICAgICAgYnI6IG5ldyBQb2ludChib3VuZGluZ1JlY3QueCArIGJvdW5kaW5nUmVjdC53aWR0aCwgYm91bmRpbmdSZWN0LnkgKyBib3VuZGluZ1JlY3QuaGVpZ2h0KSwgLy/nn6nlvaIg5Y+z5LiL6KeS5L2N572uXHJcbiAgICAgICAgICAgIG10cjogbmV3IFBvaW50KGJvdW5kaW5nUmVjdC54ICsgYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgYm91bmRpbmdSZWN0LnkgLSAyMCkgLy8g5peL6L2s54K55L2N572uXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoT2JqZWN0LmtleXMobm9kZSkubGVuZ3RoID4gMCAmJiBNYXRoLmFicyhyb3RhdGlvbikgPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciByZWN0TmV3ID0gcmVjdDtcclxuICAgICAgICAgICAgdmFyIGNlbnRlciA9IHsgeDogcmVjdE5ldy54LCB5OiByZWN0TmV3LnkgfTsgLy8g5Lit5b+D54K5XHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvbnRyb2xzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY29udHJvbHNba2V5XTtcclxuICAgICAgICAgICAgICAgIHZhciB4MCA9IGNlbnRlci54IC0gdmFsdWUueDtcclxuICAgICAgICAgICAgICAgIHZhciB5MCA9IGNlbnRlci55IC0gdmFsdWUueTtcclxuICAgICAgICAgICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbigtcm90YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKC1yb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25fbl94ID0gY2VudGVyLnggLSAoeDAgKiBjb3MgLSB5MCAqIHNpbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25fbl95ID0gY2VudGVyLnkgLSAoeDAgKiBzaW4gKyB5MCAqIGNvcyk7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sc1trZXldLnggPSBwb3NpdGlvbl9uX3g7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sc1trZXldLnkgPSBwb3NpdGlvbl9uX3k7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29udHJvbHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja7kuK3lv4Pngrnlkozml4vovazlvKfluqbvvIzorqHnrpfml4vovazlkI7nmoTngrnlnZDmoIdcclxuICAgICAqIEBwYXJhbSAge1tvYmplY3R8YXJyYXldfSBwb2ludHMgW+WOn+WdkOagh11cclxuICAgICAqIEBwYXJhbSAge1tvYmplY3RdfSAgICAgICBjZW50ZXIgW+S4reW/g+eCuV1cclxuICAgICAqIEBwYXJhbSAge1tudW1iZXJdfSAgICAgICByb3RhdGlvbiBb5peL6L2s5byn5bqmXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlUG9pbnRzKHBvaW50cywgY2VudGVyLCByb3RhdGlvbikge1xyXG4gICAgICAgIHZhciB4ID0gQXJyYXkuaXNBcnJheShwb2ludHMpID8gcG9pbnRzWzBdIDogcG9pbnRzLng7XHJcbiAgICAgICAgdmFyIHkgPSBBcnJheS5pc0FycmF5KHBvaW50cykgPyBwb2ludHNbMV0gOiBwb2ludHMueTtcclxuICAgICAgICB2YXIgeDAgPSBjZW50ZXIueCAtIHg7XHJcbiAgICAgICAgdmFyIHkwID0gY2VudGVyLnkgLSB5O1xyXG4gICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbigtcm90YXRpb24pO1xyXG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcygtcm90YXRpb24pO1xyXG4gICAgICAgIHZhciBwb3NpdGlvbl9uX3ggPSBjZW50ZXIueCAtICh4MCAqIGNvcyAtIHkwICogc2luKTtcclxuICAgICAgICB2YXIgcG9zaXRpb25fbl95ID0gY2VudGVyLnkgLSAoeDAgKiBzaW4gKyB5MCAqIGNvcyk7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocG9pbnRzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW3Bvc2l0aW9uX25feCwgcG9zaXRpb25fbl95XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogcG9zaXRpb25fbl94LFxyXG4gICAgICAgICAgICB5OiBwb3NpdGlvbl9uX3lcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bojrflj5bkuKTkuKrlm77lvaLnmoTlpJbpnaLlm5vkuKrov57mjqXngrlcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbm9kZSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRTb2x0UG9pbnRzKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAvL3RvcFxyXG4gICAgICAgICAgICBbTWF0aC5yb3VuZChub2RlLmdldFJlY3QoKS53aWR0aCAvIDMgLzEwKSoxMCwgMCBdLFxyXG4gICAgICAgICAgICBbTWF0aC5yb3VuZCgyKm5vZGUuZ2V0UmVjdCgpLndpZHRoIC8gMyAvMTApKjEwLCAwIF0sXHJcbiAgICAgICAgICAgIC8vcmlnaHRcclxuICAgICAgICAgICAgW25vZGUuZ2V0UmVjdCgpLndpZHRoLCBNYXRoLnJvdW5kKG5vZGUuZ2V0UmVjdCgpLmhlaWdodCAvIDMgLzEwKSoxMCBdLFxyXG4gICAgICAgICAgICBbbm9kZS5nZXRSZWN0KCkud2lkdGgsIE1hdGgucm91bmQoMipub2RlLmdldFJlY3QoKS5oZWlnaHQgLyAzIC8xMCkqMTAgXSxcclxuICAgICAgICAgICAgLy9ib3R0b21cclxuICAgICAgICAgICAgW01hdGgucm91bmQobm9kZS5nZXRSZWN0KCkud2lkdGggLyAzIC8xMCkqMTAsIG5vZGUuZ2V0UmVjdCgpLmhlaWdodCBdLFxyXG4gICAgICAgICAgICBbTWF0aC5yb3VuZCgyKm5vZGUuZ2V0UmVjdCgpLndpZHRoIC8gMyAvMTApKjEwLCBub2RlLmdldFJlY3QoKS5oZWlnaHQgXSxcclxuICAgICAgICAgICAgLy9sZWZ0XHJcbiAgICAgICAgICAgIFswLCBNYXRoLnJvdW5kKG5vZGUuZ2V0UmVjdCgpLmhlaWdodCAvIDMgLzEwKSoxMCBdLFxyXG4gICAgICAgICAgICBbMCwgTWF0aC5yb3VuZCgyKm5vZGUuZ2V0UmVjdCgpLmhlaWdodCAvIDMgLzEwKSoxMCBdXHJcblxyXG4gICAgICAgIF1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiuoeeulyBwMSBwMuS4pOeCueaJgOi/nuaOpeeahOebtOe6v+eahOinkuW6plxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBwMSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHAyIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0YW5nZW50Um90YXRpb24ocDEsIHAyKSB7XHJcbiAgICAgICAgcmV0dXJuIC1NYXRoLlBJIC8gMiAtIE1hdGguYXRhbjIoXHJcbiAgICAgICAgICAgIHAyLnkgLSBwMS55LCBwMi54IC0gcDEueFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliKTmlq0z54K55piv5ZCm5Zyo5LiA5p2h55u057q/5LiKXHJcbiAgICAgKiBUZXN0cyBpZiAzIHBvaW50cyBhcmUgY29saW5pYXIgd2l0aCBtYXRyaXggZGV0ZXJtaW5hbnRzLlxyXG4gICAgICogSWYgdGhlIGRldGVybWluYXQgb2YgbWF0cml4XHJcbiAgICAgKiAvICAgICAgICAgXFxcclxuICAgICAqIHwgeDEgeTEgMSB8XHJcbiAgICAgKiB8IHgyIHkyIDEgfFxyXG4gICAgICogfCB4MyB5MyAxIHxcclxuICAgICAqIFxcICAgICAgICAgL1xyXG4gICAgICogaXMgemVybyBpdCBtZWFucyB0aGF0IHRoZSBwb2ludHMgYXJlIGNvbGluZWFyXHJcbiAgICAgKkBwYXJhbSB7UG9pbnR9IHAxIC0gZmlyc3QgcG9pbnRcclxuICAgICAqQHBhcmFtIHtQb2ludH0gcDIgLSBzZWNvbmQgcG9pbnRcclxuICAgICAqQHBhcmFtIHtQb2ludH0gcDMgLSB0aGlyZCBwb2ludFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByZWNpc3Npb25cclxuICAgICAqQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlmIGNvbGluaWFyIGFuZCBmYWxzZSBpZiBub3RcclxuICAgICAqQGF1dGhvciBBbGV4XHJcbiAgICAgKkBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EZXRlcm1pbmFudFxyXG4gICAgICpAc2VlIGh0dHBzOi8vcGVvcGxlLnJpY2hsYW5kLmVkdS9qYW1lcy9sZWN0dXJlL20xMTYvbWF0cmljZXMvYXBwbGljYXRpb25zLmh0bWxcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIGNvbGxpbmVhcml0eShwMSwgcDIsIHAzLCBwcmVjaXNzaW9uKSB7XHJcbiAgICAgICAgdmFyIGRldGVybWluYW50ID0gKHAxLnggKiBwMi55ICsgcDEueSAqIHAzLnggKyBwMi54ICogcDMueSkgLSAocDIueSAqIHAzLnggKyBwMS55ICogcDIueCArIHAxLnggKiBwMy55KTtcclxuXHJcbiAgICAgICAgaWYgKHByZWNpc3Npb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKGRldGVybWluYW50KSA8PSBwcmVjaXNzaW9uO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZXRlcm1pbmFudCA9PT0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Zub6IiN5LqU5YWlIOS/neWtmGRlY2ltYWxz55qE5bCP5pWwXHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBlbmhhbmNlZFJvdW5kKG51bWJlciwgZGVjaW1hbHMpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIgKiBNYXRoLnBvdygxMCwgZGVjaW1hbHMpKSAvIE1hdGgucG93KDEwLCBkZWNpbWFscyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bkuKTngrnkuYvpl7TnmoTplb/luqZcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIGdldExlbmd0aChzdGFydFBvaW50LCBlbmRQb2ludCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coc3RhcnRQb2ludC54IC0gZW5kUG9pbnQueCwgMikgKyBNYXRoLnBvdyhzdGFydFBvaW50LnkgLSBlbmRQb2ludC55LCAyKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bop5LluqZcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gY2VudGVyUG9pbnQgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gb3V0c2lkZVBvaW50IFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gcm91bmQgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0QW5nbGUoY2VudGVyUG9pbnQsIG91dHNpZGVQb2ludCwgcm91bmQpIHtcclxuICAgICAgICBjZW50ZXJQb2ludC54ID0gZW5oYW5jZWRSb3VuZChjZW50ZXJQb2ludC54LCA1KTtcclxuICAgICAgICBjZW50ZXJQb2ludC55ID0gZW5oYW5jZWRSb3VuZChjZW50ZXJQb2ludC55LCA1KTtcclxuICAgICAgICBvdXRzaWRlUG9pbnQueCA9IGVuaGFuY2VkUm91bmQob3V0c2lkZVBvaW50LngsIDUpO1xyXG4gICAgICAgIG91dHNpZGVQb2ludC55ID0gZW5oYW5jZWRSb3VuZChvdXRzaWRlUG9pbnQueSwgNSk7XHJcbiAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuKChvdXRzaWRlUG9pbnQueCAtIGNlbnRlclBvaW50LngpIC8gKG91dHNpZGVQb2ludC55IC0gY2VudGVyUG9pbnQueSkpO1xyXG4gICAgICAgIGFuZ2xlID0gLWFuZ2xlO1xyXG5cclxuICAgICAgICAvL2VuZEFuZ2xlKz05MDtcclxuICAgICAgICBpZiAob3V0c2lkZVBvaW50LnggPj0gY2VudGVyUG9pbnQueCAmJiBvdXRzaWRlUG9pbnQueSA+PSBjZW50ZXJQb2ludC55KSB7XHJcbiAgICAgICAgICAgIGFuZ2xlICs9IE1hdGguUEk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChvdXRzaWRlUG9pbnQueCA8PSBjZW50ZXJQb2ludC54ICYmIG91dHNpZGVQb2ludC55ID49IGNlbnRlclBvaW50LnkpIHtcclxuICAgICAgICAgICAgYW5nbGUgKz0gTWF0aC5QSTtcclxuICAgICAgICB9IGVsc2UgaWYgKG91dHNpZGVQb2ludC54IDw9IGNlbnRlclBvaW50LnggJiYgb3V0c2lkZVBvaW50LnkgPD0gY2VudGVyUG9pbnQueSkge1xyXG4gICAgICAgICAgICBhbmdsZSArPSBNYXRoLlBJICogMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGFuZ2xlID49IE1hdGguUEkgKiAyKSB7XHJcbiAgICAgICAgICAgIGFuZ2xlIC09IE1hdGguUEkgKiAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNOYU4oYW5nbGUpKSB7IC8vTmFuXHJcbiAgICAgICAgICAgIGFuZ2xlID0gMDsgLy93ZSBhcmUgYXQgY2VudGVyIHBvaW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocm91bmQpIHtcclxuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLnJvdW5kKGFuZ2xlIC8gcm91bmQpICogcm91bmRcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFuZ2xlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFJlY3Qobm9kZSwgaXNDYWxjUGFyZW50KSB7XHJcbiAgICAgICAgdmFyIGNsaXBQYXRoID0gbm9kZS5jbGlwUGF0aDtcclxuICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gbm9kZS5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAvLyDoioLngrnoo4HliarlkI7vvIzku6Xoo4HliaroioLngrnljIXlm7Tnm5LkuLrlh4ZcclxuICAgICAgICBpZiAoY2xpcFBhdGgpIHtcclxuICAgICAgICAgICAgYm91bmRpbmdSZWN0ID0gY2xpcFBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5Yib5bu65pyA5bCP5YyF5Zu055uS6Jma57q/XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgIHBvaW50c1swXSA9IFstYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgLWJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuICAgICAgICBwb2ludHNbMV0gPSBbYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgLWJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuICAgICAgICBwb2ludHNbMl0gPSBbYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgYm91bmRpbmdSZWN0LmhlaWdodCAvIDJdO1xyXG4gICAgICAgIHBvaW50c1szXSA9IFstYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgYm91bmRpbmdSZWN0LmhlaWdodCAvIDJdO1xyXG4gICAgICAgIHBvaW50c1s0XSA9IFstYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgLWJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuXHJcbiAgICAgICAgdmFyIHBvc2l0aW9uWCA9IG5vZGUucG9zaXRpb25bMF07XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uWSA9IG5vZGUucG9zaXRpb25bMV07XHJcbiAgICAgICAgLy/ov5nph4zopoHlvqrnjq/liKTmlq3kuIDmioog5pyJ5rKh5pyJ54i26IqC54K5IOW5tuS4lOeItuiKgueCueS4jeaYr+agueiKgueCuSDnhLblkI7ov5vooYznm7jliqBcclxuICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQudHlwZSA9PT0gXCJHcm91cE5vZGVcIiAmJiBpc0NhbGNQYXJlbnQpIHtcclxuICAgICAgICAgICAgcG9zaXRpb25YID0gcG9zaXRpb25YICsgbm9kZS5wYXJlbnQucG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgIHBvc2l0aW9uWSA9IHBvc2l0aW9uWSArIG5vZGUucGFyZW50LnBvc2l0aW9uWzFdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGJvdW5kUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoXHJcbiAgICAgICAgICAgICAgICBOdW1iZXIocG9zaXRpb25YICsgYm91bmRpbmdSZWN0LngpLCAgIC8v5rOoOiDlm6Dkuovku7bkuLrlnIblvaIgIOaJgOS7pSB4IHkg5Li65ZyG5b+D55qE5L2N572uICDljIXlm7Tnn6nlvaLopoHlh4/ljrvlrr3luqbkuIDljYpcclxuICAgICAgICAgICAgICAgIE51bWJlcihwb3NpdGlvblkgKyBib3VuZGluZ1JlY3QueSksXHJcbiAgICAgICAgICAgICAgICBOdW1iZXIoYm91bmRpbmdSZWN0LndpZHRoKSxcclxuICAgICAgICAgICAgICAgIE51bWJlcihib3VuZGluZ1JlY3QuaGVpZ2h0KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIC8v5Lit5b+D54K5XHJcbiAgICAgICAgdmFyIGN4ID0gTnVtYmVyKHBvc2l0aW9uWCkgKyBOdW1iZXIoYm91bmRpbmdSZWN0LndpZHRoKSAvIDIgKyBOdW1iZXIoYm91bmRpbmdSZWN0LngpO1xyXG4gICAgICAgIHZhciBjeSA9IE51bWJlcihwb3NpdGlvblkpICsgTnVtYmVyKGJvdW5kaW5nUmVjdC5oZWlnaHQpIC8gMiArIE51bWJlcihib3VuZGluZ1JlY3QueSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogTnVtYmVyKGN4KSxcclxuICAgICAgICAgICAgeTogTnVtYmVyKGN5KSxcclxuICAgICAgICAgICAgd2lkdGg6IE51bWJlcihib3VuZGluZ1JlY3Qud2lkdGgpLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IE51bWJlcihib3VuZGluZ1JlY3QuaGVpZ2h0KSxcclxuICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXHJcbiAgICAgICAgICAgIGJvdW5kaW5nUmVjdDogYm91bmRSZWN0XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgU3RhY2tlZE1hcCA9IHtcclxuICAgICAgICBjcmVhdGVOZXc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyS2V5ID0gdGhpcy5nZXQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBhcnJLZXkucHVzaCh2YWx1ZSlcclxuXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gc3RhY2tbaV0ua2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2tbaV0udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy/lpoLmnpzmsqHmnInmib7liLDnmoTor53vvIzliJnliJvlu7rkuIDkuKrmlrDnmoTmlbDnu4RcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAga2V5czogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChzdGFja1tpXS5rZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0b3A6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gc3RhY2tbaV0ua2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrLnNwbGljZShpZHgsIDEpWzBdO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZUl0ZW06IGZ1bmN0aW9uKGtleSwgaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJLZXkgPSB0aGlzLmdldChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHpyVXRpbC5pbmRleE9mKGFycktleSwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyS2V5LnNwbGljZShpbmRleCwgMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZVRvcDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrLnNwbGljZShzdGFjay5sZW5ndGggLSAxLCAxKVswXTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFjay5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnNwbGljZSgwLCBzdGFjay5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcmFuZG9tQ29sb3IoKSB7XHJcbiAgICAgICAgdmFyIGFyckhleCA9IFtcIjBcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIiwgXCI4XCIsIFwiOVwiLCBcImFcIiwgXCJiXCIsIFwiY1wiLCBcImRcIl0sXHJcbiAgICAgICAgICAgIHN0ckhleCA9IFwiI1wiLFxyXG4gICAgICAgICAgICBpbmRleDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkrKykge1xyXG4gICAgICAgICAgICBpbmRleCA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDE1KTtcclxuICAgICAgICAgICAgc3RySGV4ICs9IGFyckhleFtpbmRleF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHJIZXg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbGxpbmVhclJlZHVjdGlvbiAodikge1xyXG4gICAgICAgIHZhciByID0gW107XHJcblxyXG4gICAgICAgIGlmKHYubGVuZ3RoIDwgMyl7XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5jbG9uZUFycmF5KHYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgci5wdXNoKCB2WzBdLmNsb25lKCkgKTtcclxuICAgICAgICBmb3IodmFyIGk9MTsgaSA8IHYubGVuZ3RoLTE7IGkrKyl7XHJcbiAgICAgICAgICAgIGlmKCAodltpLTFdLnggPT0gdltpXS54ICYmIHZbaV0ueCA9PSB2W2krMV0ueCkgIHx8ICAodltpLTFdLnkgPT0gdltpXS55ICYmIHZbaV0ueSA9PSB2W2krMV0ueSkgKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgci5wdXNoKCB2W2ldLmNsb25lKCkgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByLnB1c2goIHZbdi5sZW5ndGgtMV0uY2xvbmUoKSApO1xyXG5cclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBCeSBkZWZhdWx0LCBVbmRlcnNjb3JlIHVzZXMgRVJCLXN0eWxlIHRlbXBsYXRlIGRlbGltaXRlcnMsIGNoYW5nZSB0aGVcclxuICAgIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cclxuICAgIHZhciB0ZW1wbGF0ZVNldHRpbmdzID0ge1xyXG4gICAgICAgIGV2YWx1YXRlOiAvPCUoW1xcc1xcU10rPyklPi9nLFxyXG4gICAgICAgIGludGVycG9sYXRlOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcclxuICAgICAgICBlc2NhcGU6IC88JS0oW1xcc1xcU10rPyklPi9nXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFdoZW4gY3VzdG9taXppbmcgYHRlbXBsYXRlU2V0dGluZ3NgLCBpZiB5b3UgZG9uJ3Qgd2FudCB0byBkZWZpbmUgYW5cclxuICAgIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcclxuICAgIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxyXG4gICAgdmFyIG5vTWF0Y2ggPSAvKC4pXi87XHJcblxyXG4gICAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcclxuICAgIC8vIHN0cmluZyBsaXRlcmFsLlxyXG4gICAgdmFyIGVzY2FwZXMgPSB7XHJcbiAgICAgICAgXCInXCI6IFwiJ1wiLFxyXG4gICAgICAgICdcXFxcJzogJ1xcXFwnLFxyXG4gICAgICAgICdcXHInOiAncicsXHJcbiAgICAgICAgJ1xcbic6ICduJyxcclxuICAgICAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXHJcbiAgICAgICAgJ1xcdTIwMjknOiAndTIwMjknXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xyXG5cclxuICAgIHZhciBlc2NhcGVDaGFyID0gZnVuY3Rpb24obWF0Y2gpIHtcclxuICAgICAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXHJcbiAgICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXHJcbiAgICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cclxuICAgIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cclxuICAgIGZ1bmN0aW9uIHRlbXBsYXRlKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xyXG4gICAgICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XHJcbiAgICAgICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcclxuICAgICAgICBzZXR0aW5ncyA9IHpyVXRpbC5kZWZhdWx0cyhzZXR0aW5ncywgdGVtcGxhdGVTZXR0aW5ncywgdHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxyXG4gICAgICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcclxuICAgICAgICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXHJcbiAgICAgICAgICAgIChzZXR0aW5ncy5pbnRlcnBvbGF0ZSB8fCBub01hdGNoKS5zb3VyY2UsXHJcbiAgICAgICAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcclxuICAgICAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XHJcblxyXG4gICAgICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXHJcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuICAgICAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcclxuICAgICAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcclxuICAgICAgICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShlc2NhcGVyLCBlc2NhcGVDaGFyKTtcclxuICAgICAgICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBpZiAoZXNjYXBlKSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChldmFsdWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2ZmZXN0LlxyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcclxuXHJcbiAgICAgICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cclxuICAgICAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xyXG5cclxuICAgICAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXHJcbiAgICAgICAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXHJcbiAgICAgICAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciByZW5kZXIgPSBuZXcgRnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicsIHNvdXJjZSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBlLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlci5jYWxsKHRoaXMsIGRhdGEpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cclxuICAgICAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcclxuICAgICAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XHJcbiAgICAgICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBpZiAoenJVdGlsLmlzQXJyYXlMaWtlKG9iaikgJiYgKHpyVXRpbC5pc0FycmF5KG9iaikgfHwgenJVdGlsLmlzU3RyaW5nKG9iaikpKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1lcmdlT3B0KHRhcmdldCwgc291cmNlLCBvdmVyd3JpdGUsIGV4Y2x1ZGUpIHtcclxuICAgICAgICAvLyBXZSBzaG91bGQgZXNjYXBzZSB0aGF0IHNvdXJjZSBpcyBzdHJpbmdcclxuICAgICAgICAvLyBhbmQgZW50ZXIgZm9yIC4uLiBpbiAuLi5cclxuICAgICAgICBpZiAoIXpyVXRpbC5pc09iamVjdChzb3VyY2UpIHx8ICF6clV0aWwuaXNPYmplY3QodGFyZ2V0KSkge1xyXG4gICAgICAgICAgcmV0dXJuIG92ZXJ3cml0ZSA/IHpyVXRpbC5jbG9uZShzb3VyY2UpIDogdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xyXG4gICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRQcm9wID0gdGFyZ2V0W2tleV07XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2VQcm9wID0gc291cmNlW2tleV07XHJcblxyXG4gICAgICAgICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KHNvdXJjZVByb3ApICYmIHpyVXRpbC5pc09iamVjdCh0YXJnZXRQcm9wKSAmJiAhenJVdGlsLmlzQXJyYXkoc291cmNlUHJvcCkgJiYgIXpyVXRpbC5pc0FycmF5KHRhcmdldFByb3ApICYmICF6clV0aWwuaXNEb20oc291cmNlUHJvcCkgJiYgIXpyVXRpbC5pc0RvbSh0YXJnZXRQcm9wKSAmJiAhenJVdGlsLmlzQnVpbHRJbk9iamVjdChzb3VyY2VQcm9wKSAmJiAhenJVdGlsLmlzQnVpbHRJbk9iamVjdCh0YXJnZXRQcm9wKSAmJiAhenJVdGlsLmlzUHJpbWl0aXZlKHNvdXJjZVByb3ApICYmICF6clV0aWwuaXNQcmltaXRpdmUodGFyZ2V0UHJvcCkpIHtcclxuICAgICAgICAgICAgICAvLyDlpoLmnpzpnIDopoHpgJLlvZLopobnm5bvvIzlsLHpgJLlvZLosIPnlKhtZXJnZVxyXG4gICAgICAgICAgICAgIG1lcmdlT3B0KHRhcmdldFByb3AsIHNvdXJjZVByb3AsIG92ZXJ3cml0ZSwgZXhjbHVkZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3ZlcndyaXRlIHx8ICEoa2V5IGluIHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAvLyDlkKbliJnlj6rlpITnkIZvdmVyd3JpdGXkuLp0cnVl77yM5oiW6ICF5Zyo55uu5qCH5a+56LGh5Lit5rKh5pyJ5q2k5bGe5oCn55qE5oOF5Ya1XHJcbiAgICAgICAgICAgICAgLy8gTk9URe+8jOWcqCB0YXJnZXRba2V5XSDkuI3lrZjlnKjnmoTml7blgJnkuZ/mmK/nm7TmjqXopobnm5ZcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09IGV4Y2x1ZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHpyVXRpbC5jbG9uZShzb3VyY2Vba2V5XSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIENsYXNzKCkge31cclxuICAgIENsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uKHByb3RvKSB7XHJcbiAgICAgICAgdmFyIGJhc2UgPSBmdW5jdGlvbigpIHt9LFxyXG4gICAgICAgICAgICBtZW1iZXIsXHJcbiAgICAgICAgICAgIHRoYXQgPSB0aGlzLFxyXG4gICAgICAgICAgICBzdWJjbGFzcyA9IHByb3RvICYmIHByb3RvLmluaXQgPyBwcm90by5pbml0IDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmbjtcclxuXHJcbiAgICAgICAgYmFzZS5wcm90b3R5cGUgPSB0aGF0LnByb3RvdHlwZTtcclxuICAgICAgICBmbiA9IHN1YmNsYXNzLmZuID0gc3ViY2xhc3MucHJvdG90eXBlID0gbmV3IGJhc2UoKTtcclxuXHJcbiAgICAgICAgZm9yIChtZW1iZXIgaW4gcHJvdG8pIHtcclxuICAgICAgICAgICAgaWYgKHByb3RvW21lbWJlcl0gIT0gbnVsbCAmJiBwcm90b1ttZW1iZXJdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1lcmdlIG9iamVjdCBtZW1iZXJzXHJcbiAgICAgICAgICAgICAgICBmblttZW1iZXJdID0genJVdGlsLm1lcmdlQWxsKFt7fSwgYmFzZS5wcm90b3R5cGVbbWVtYmVyXSwgcHJvdG9bbWVtYmVyXV0sdHJ1ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmblttZW1iZXJdID0gcHJvdG9bbWVtYmVyXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm4uY29uc3RydWN0b3IgPSBzdWJjbGFzcztcclxuICAgICAgICBzdWJjbGFzcy5leHRlbmQgPSB0aGF0LmV4dGVuZDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN1YmNsYXNzO1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgICAgICBpbmhlcml0czogaW5oZXJpdHMsXHJcbiAgICAgICAgZ2V0VVVJRDogZ2V0VVVJRCxcclxuICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXHJcbiAgICAgICAgZ2V0UG9seWxpbmVMZW5ndGg6IGdldFBvbHlsaW5lTGVuZ3RoLFxyXG4gICAgICAgIG1heDogbWF4LFxyXG4gICAgICAgIG1pbjogbWluLFxyXG4gICAgICAgIGlzRW1wdHk6IGlzRW1wdHksXHJcbiAgICAgICAgbWVyZ2VPcHQ6IG1lcmdlT3B0LFxyXG4gICAgICAgIG9ydGhvZ29uYWxQYXRoOiBvcnRob2dvbmFsUGF0aCxcclxuICAgICAgICBwb2x5bGluZUludGVyc2VjdHNSZWN0YW5nbGU6IHBvbHlsaW5lSW50ZXJzZWN0c1JlY3RhbmdsZSxcclxuICAgICAgICBzY29yZVBhdGg6IHNjb3JlUGF0aCxcclxuICAgICAgICBmb3J3YXJkUGF0aDogZm9yd2FyZFBhdGgsXHJcbiAgICAgICAgdHJhc2xhdGVQb2ludHM6IHRyYXNsYXRlUG9pbnRzLFxyXG4gICAgICAgIGdldEVuZFBvaW50OiBnZXRFbmRQb2ludCxcclxuICAgICAgICBnZXRDb25uZWN0b3JQb2ludHM6IGdldENvbm5lY3RvclBvaW50cyxcclxuICAgICAgICBnZXRDb25uZWN0b3JDb250cm9sczogZ2V0Q29ubmVjdG9yQ29udHJvbHMsXHJcbiAgICAgICAgY2FsY3VsYXRlUG9pbnRzOiBjYWxjdWxhdGVQb2ludHMsXHJcbiAgICAgICAgdGFuZ2VudFJvdGF0aW9uOiB0YW5nZW50Um90YXRpb24sXHJcbiAgICAgICAgY29sbGluZWFyaXR5OiBjb2xsaW5lYXJpdHksXHJcbiAgICAgICAgdHJhbnNsYXRpb25NYXRyaXg6IHRyYW5zbGF0aW9uTWF0cml4LFxyXG4gICAgICAgIHNjYWxlTWF0cml4OiBzY2FsZU1hdHJpeCxcclxuICAgICAgICByb3VuZDogZW5oYW5jZWRSb3VuZCxcclxuICAgICAgICBnZXRMZW5ndGg6IGdldExlbmd0aCxcclxuICAgICAgICBnZXRBbmdsZTogZ2V0QW5nbGUsXHJcbiAgICAgICAgZ2V0UmVjdDogZ2V0UmVjdCxcclxuICAgICAgICBTdGFja2VkTWFwOiBTdGFja2VkTWFwLFxyXG4gICAgICAgIGdldE1heExpbmVMZW5ndGg6IGdldE1heExpbmVMZW5ndGgsXHJcbiAgICAgICAgcmFuZG9tQ29sb3I6IHJhbmRvbUNvbG9yLFxyXG4gICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcclxuICAgICAgICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXHJcbiAgICAgICAgZ2V0U29sdFBvaW50czpnZXRTb2x0UG9pbnRzLFxyXG4gICAgICAgIGNvbGxpbmVhclJlZHVjdGlvbjogY29sbGluZWFyUmVkdWN0aW9uLFxyXG4gICAgICAgIENsYXNzOkNsYXNzXHJcbiAgICB9O1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUG9pbnRcclxuICAgICAgKlxyXG4gICAgICAqXHJcbiAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICogQHRoaXMge1BvaW50fVxyXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUgb2YgcG9pbnQuXHJcbiAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29vcmRpbmF0ZSBvZiBwb2ludC5cclxuICAgICAgKiBOb3RlOiBFdmVuIGlmIGl0IGlzIG5hbWVkIFBvaW50IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIG5hbWVkIERvdCBhcyBEb3QgaXMgY2xvc2VyXHJcbiAgICAgICogdGhlbiBQb2ludCBmcm9tIG1hdGggcGVyc3BlY3RpdmUuXHJcbiAgICAgICoqL1xyXG4gICAgZnVuY3Rpb24gUG9pbnQoeCwgeSl7XHJcbiAgICAgICAgLyoqVGhlIHggY29vcmRpbmF0ZSBvZiBwb2ludCovXHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuXHJcbiAgICAgICAgLyoqVGhlIHkgY29vcmRpbmF0ZSBvZiBwb2ludCovXHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKkNyZWF0ZXMgYSB7UG9pbnR9IG91dCBvZiBKU09OIHBhcnNlZCBvYmplY3RcclxuICAgICAqQHBhcmFtIHtKU09OT2JqZWN0fSBvIC0gdGhlIEpTT04gcGFyc2VkIG9iamVjdFxyXG4gICAgICpAcmV0dXJuIHtQb2ludH0gYSBuZXdseSBjb25zdHJ1Y3RlZCBQb2ludFxyXG4gICAgICoqL1xyXG4gICAgUG9pbnQubG9hZCA9IGZ1bmN0aW9uKG8pe1xyXG4gICAgICAgIHZhciBuZXdQb2ludCA9IG5ldyBQb2ludChOdW1iZXIoby54KSwgTnVtYmVyKG8ueSkpO1xyXG4gICAgICAgIHJldHVybiBuZXdQb2ludDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKkNyZWF0ZXMgYW4gYXJyYXkgb2YgcG9pbnRzIGZyb20gYW4gYXJyYXkgb2Yge0pTT05PYmplY3R9c1xyXG4gICAgICpAcGFyYW0ge0FycmF5fSB2IC0gdGhlIGFycmF5IG9mIEpTT05PYmplY3RzXHJcbiAgICAgKkByZXR1cm4gYW4ge0FycmF5fSBvZiB7UG9pbnR9c1xyXG4gICAgICoqL1xyXG4gICAgUG9pbnQubG9hZEFycmF5ID0gZnVuY3Rpb24odil7XHJcbiAgICAgICAgdmFyIG5ld1BvaW50cyA9IFtdO1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPCB2Lmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgbmV3UG9pbnRzLnB1c2goUG9pbnQubG9hZCh2W2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdQb2ludHM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipDbG9uZXMgYW4gYXJyYXkgb2YgcG9pbnRzXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHYgLSB0aGUgYXJyYXkgb2Yge1BvaW50fXNcclxuICAgICAqQHJldHVybiBhbiB7QXJyYXl9IG9mIHtQb2ludH1zXHJcbiAgICAgKiovXHJcbiAgICBQb2ludC5jbG9uZUFycmF5ID0gZnVuY3Rpb24odil7XHJcbiAgICAgICAgdmFyIG5ld1BvaW50cyA9IFtdO1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPCB2Lmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgbmV3UG9pbnRzLnB1c2godltpXS5jbG9uZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld1BvaW50cztcclxuICAgIH07XHJcblxyXG4gICAgUG9pbnQucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yIDogUG9pbnQsXHJcblxyXG4gICAgICAgIHRyYW5zZm9ybTpmdW5jdGlvbihtYXRyaXgpe1xyXG4gICAgICAgICAgICB2YXIgb2xkWCA9IHRoaXMueDtcclxuICAgICAgICAgICAgdmFyIG9sZFkgPSB0aGlzLnk7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IG1hdHJpeFswXVswXSAqIG9sZFggKyBtYXRyaXhbMF1bMV0gKiBvbGRZICsgbWF0cml4WzBdWzJdO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBtYXRyaXhbMV1bMF0gKiBvbGRYICsgbWF0cml4WzFdWzFdICogb2xkWSArIG1hdHJpeFsxXVsyXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipUZXN0cyBpZiB0aGlzIHBvaW50IGlzIHNpbWlsYXIgdG8gb3RoZXIgcG9pbnRcclxuICAgICAgICAgKkBwYXJhbSB7UG9pbnR9IGFub3RoZXJQb2ludCAtIHRoZSBvdGhlciBwb2ludFxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBlcXVhbHM6ZnVuY3Rpb24oYW5vdGhlclBvaW50KXtcclxuICAgICAgICAgICAgaWYoISAoYW5vdGhlclBvaW50IGluc3RhbmNlb2YgUG9pbnQpICl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnggPT0gYW5vdGhlclBvaW50LngpXHJcbiAgICAgICAgICAgICYmICh0aGlzLnkgPT0gYW5vdGhlclBvaW50LnkpXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqQ2xvbmUgY3VycmVudCBQb2ludFxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIG5ld1BvaW50ID0gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1BvaW50O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFkZDogZnVuY3Rpb24ocG9pbnQpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gdGhpcy54ICsgcG9pbnQueDtcclxuICAgICAgICAgICAgdGhpcy55ID0gdGhpcy55ICsgcG9pbnQueTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqVGVzdHMgdG8gc2VlIGlmIGEgcG9pbnQgKHgsIHkpIGlzIHdpdGhpbiBhIHJhbmdlIG9mIGN1cnJlbnQgUG9pbnRcclxuICAgICAgICAgKkBwYXJhbSB7TnVtZXJpY30geCAtIHRoZSB4IGNvb3JkaW5hdGUgb2YgdGVzdGVkIHBvaW50XHJcbiAgICAgICAgICpAcGFyYW0ge051bWVyaWN9IHkgLSB0aGUgeCBjb29yZGluYXRlIG9mIHRlc3RlZCBwb2ludFxyXG4gICAgICAgICAqQHBhcmFtIHtOdW1lcmljfSByYWRpdXMgLSB0aGUgcmFkaXVzIG9mIHRoZSB2aWNpbml0eVxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBuZWFyOmZ1bmN0aW9uKHgsIHksIHJhZGl1cyl7XHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLnggLSB4LCAyKSArIE1hdGgucG93KHRoaXMueSAtIHksIDIpKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoZGlzdGFuY2UgPD0gcmFkaXVzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjb250YWluczogZnVuY3Rpb24oeCx5KXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCA9PSB4ICYmIHRoaXMueSA9PSB5O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHRvU3RyaW5nOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHJldHVybiAnWycgKyB0aGlzLnggKyAnLCcgKyB0aGlzLnkgKyAnXSc7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0UG9pbnRzOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHJldHVybiBbdGhpc107XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9Qb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBhIExpbmUuIEEgTGluZSBpcyBhY3R1YWxseSBhIHNlZ21lbnQgYW5kIG5vdCBhIHB1cmVcclxuICAgICAgKiBnZW9tZXRyaWNhbCBMaW5lXHJcbiAgICAgICpcclxuICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgKiBAdGhpcyB7TGluZX1cclxuICAgICAgKiBAcGFyYW0ge1BvaW50fSBzdGFydFBvaW50IC0gc3RhcnRpbmcgcG9pbnQgb2YgdGhlIGxpbmVcclxuICAgICAgKiBAcGFyYW0ge1BvaW50fSBlbmRQb2ludCAtIHRoZSBlbmRpbmcgcG9pbnQgb2YgdGhlIGxpbmVcclxuICAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBMaW5lKHN0YXJ0UG9pbnQsIGVuZFBvaW50KXtcclxuICAgICAgICAvKipTdGFydGluZyB7QGxpbmsgUG9pbnR9IG9mIHRoZSBsaW5lKi9cclxuICAgICAgICB0aGlzLnN0YXJ0UG9pbnQgPSBzdGFydFBvaW50O1xyXG5cclxuICAgICAgICAvKipFbmRpbmcge0BsaW5rIFBvaW50fSBvZiB0aGUgbGluZSovXHJcbiAgICAgICAgdGhpcy5lbmRQb2ludCA9IGVuZFBvaW50O1xyXG5cclxuICAgICAgICAvKipTZXJpYWxpemF0aW9uIHR5cGUqL1xyXG4gICAgICAgIHRoaXMub1R5cGUgPSAnTGluZSc7IC8vb2JqZWN0IHR5cGUgdXNlZCBmb3IgSlNPTiBkZXNlcmlhbGl6YXRpb25cclxuICAgIH1cclxuXHJcbiAgICAvKipDcmVhdGVzIGEge0xpbmV9IG91dCBvZiBKU09OIHBhcnNlZCBvYmplY3RcclxuICAgICAqQHBhcmFtIHtKU09OT2JqZWN0fSBvIC0gdGhlIEpTT04gcGFyc2VkIG9iamVjdFxyXG4gICAgICpAcmV0dXJuIHtMaW5lfSBhIG5ld2x5IGNvbnN0cnVjdGVkIExpbmVcclxuICAgICAqKi9cclxuICAgIExpbmUubG9hZCA9IGZ1bmN0aW9uKG8pe1xyXG4gICAgICAgIHZhciBuZXdMaW5lID0gbmV3IExpbmUoXHJcbiAgICAgICAgICAgIFBvaW50LmxvYWQoby5zdGFydFBvaW50KSxcclxuICAgICAgICAgICAgUG9pbnQubG9hZChvLmVuZFBvaW50KVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXdMaW5lO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaW5lLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb250cnVjdG9yOiBMaW5lLFxyXG5cclxuXHJcblxyXG4gICAgICAgIGNsb25lOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHZhciByZXQgPSBuZXcgTGluZSh0aGlzLnN0YXJ0UG9pbnQuY2xvbmUoKSwgdGhpcy5lbmRQb2ludC5jbG9uZSgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBlcXVhbHM6ZnVuY3Rpb24oYW5vdGhlckxpbmUpe1xyXG4gICAgICAgICAgICBpZighYW5vdGhlckxpbmUgaW5zdGFuY2VvZiBMaW5lKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydFBvaW50LmVxdWFscyhhbm90aGVyTGluZS5zdGFydFBvaW50KVxyXG4gICAgICAgICAgICAmJiB0aGlzLmVuZFBvaW50LmVxdWFscyhhbm90aGVyTGluZS5lbmRQb2ludClcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKiogVGVzdHMgdG8gc2VlIGlmIGEgcG9pbnQgYmVsb25ncyB0byB0aGlzIGxpbmUgKG5vdCBhcyBpbmZpbml0ZSBsaW5lIGJ1dCBtb3JlIGxpa2UgYSBzZWdtZW50KVxyXG4gICAgICAgICAqIEFsZ29yaXRobTogQ29tcHV0ZSBsaW5lJ3MgZXF1YXRpb24gYW5kIHNlZSBpZiAoeCwgeSkgdmVyaWZpZXMgaXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHggLSB0aGUgWCBjb29yZGluYXRlc1xyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gdGhlIFkgY29vcmRpbmF0ZXNcclxuICAgICAgICAgKiovXHJcbiAgICAgICAgY29udGFpbnM6IGZ1bmN0aW9uKHgsIHkpe1xyXG4gICAgICAgICAgICAvLyBpZiB0aGUgcG9pbnQgaXMgaW5zaWRlIHJlY3RhbmdsZSBib3VuZHMgb2YgdGhlIHNlZ21lbnRcclxuICAgICAgICAgICAgaWYgKE1hdGgubWluKHRoaXMuc3RhcnRQb2ludC54LCB0aGlzLmVuZFBvaW50LngpIDw9IHhcclxuICAgICAgICAgICAgICAgICYmIHggPD0gTWF0aC5tYXgodGhpcy5zdGFydFBvaW50LngsIHRoaXMuZW5kUG9pbnQueClcclxuICAgICAgICAgICAgICAgICYmIE1hdGgubWluKHRoaXMuc3RhcnRQb2ludC55LCB0aGlzLmVuZFBvaW50LnkpIDw9IHlcclxuICAgICAgICAgICAgICAgICYmIHkgPD0gTWF0aC5tYXgodGhpcy5zdGFydFBvaW50LnksIHRoaXMuZW5kUG9pbnQueSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgdmVydGljYWwgbGluZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRQb2ludC54ID09IHRoaXMuZW5kUG9pbnQueCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4ID09IHRoaXMuc3RhcnRQb2ludC54O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gdXN1YWwgKG5vdCB2ZXJ0aWNhbCkgbGluZSBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgeSA9IGEgKiB4ICsgYlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gKHRoaXMuZW5kUG9pbnQueSAtIHRoaXMuc3RhcnRQb2ludC55KSAvICh0aGlzLmVuZFBvaW50LnggLSB0aGlzLnN0YXJ0UG9pbnQueCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSB0aGlzLnN0YXJ0UG9pbnQueSAtIGEgKiB0aGlzLnN0YXJ0UG9pbnQueDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geSA9PSBhICogeCArIGI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqU2VlIGlmIHdlIGFyZSBuZWFyIGEge0xpbmV9IGJ5IGEgY2VydGFpbiByYWRpdXMgKGFsc28gaW5jbHVkZXMgdGhlIGV4dHJlbWl0aWVzIGludG8gY29tcHV0YXRpb24pXHJcbiAgICAgICAgICpAcGFyYW0ge051bWJlcn0geCAtIHRoZSB4IGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICpAcGFyYW0ge051bWJlcn0geSAtIHRoZSB5IGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICpAcGFyYW0ge051bWJlcn0gcmFkaXVzIC0gdGhlIHJhZGl1cyB0byBzZWFyY2ggZm9yXHJcbiAgICAgICAgICpAc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlzdGFuY2VfZnJvbV9hX3BvaW50X3RvX2FfbGluZVxyXG4gICAgICAgICAqQHNlZSBcIk1hdGhlbWF0aWNzIGZvciBDb21wdXRlciBHcmFwaGljcywgMm5kIEVkLiwgYnkgSm9obiBWaWNlLCBwYWdlIDIyN1wiXHJcbiAgICAgICAgICoqL1xyXG4gICAgICAgIG5lYXI6ZnVuY3Rpb24oeCx5LHJhZGl1cyl7XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLmVuZFBvaW50LnggPT09IHRoaXMuc3RhcnRQb2ludC54KXsgLy9WZXJ0aWNhbCBsaW5lLCBzbyB0aGUgdmljaW5pdHkgYXJlYSBpcyBhIHJlY3RhbmdsZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICggKHRoaXMuc3RhcnRQb2ludC55LXJhZGl1czw9eSAmJiB0aGlzLmVuZFBvaW50LnkrcmFkaXVzPj15KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAodGhpcy5lbmRQb2ludC55LXJhZGl1czw9eSAmJiB0aGlzLnN0YXJ0UG9pbnQueStyYWRpdXM+PXkpKVxyXG4gICAgICAgICAgICAgICAgJiYgeCA+IHRoaXMuc3RhcnRQb2ludC54IC0gcmFkaXVzICYmIHggPCB0aGlzLnN0YXJ0UG9pbnQueCArIHJhZGl1cyA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMuc3RhcnRQb2ludC55ID09PSB0aGlzLmVuZFBvaW50LnkpeyAvL0hvcml6b250YWwgbGluZSwgc28gdGhlIHZpY2luaXR5IGFyZWEgaXMgYSByZWN0YW5nbGVcclxuICAgICAgICAgICAgICAgIHJldHVybiAoICh0aGlzLnN0YXJ0UG9pbnQueCAtIHJhZGl1czw9eCAmJiB0aGlzLmVuZFBvaW50LngrcmFkaXVzPj14KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAodGhpcy5lbmRQb2ludC54LXJhZGl1czw9eCAmJiB0aGlzLnN0YXJ0UG9pbnQueCtyYWRpdXM+PXgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiB5PnRoaXMuc3RhcnRQb2ludC55LXJhZGl1cyAmJiB5PHRoaXMuc3RhcnRQb2ludC55K3JhZGl1cyA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgc3RhcnRYID0gTWF0aC5taW4odGhpcy5lbmRQb2ludC54LHRoaXMuc3RhcnRQb2ludC54KTtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0WSA9IE1hdGgubWluKHRoaXMuZW5kUG9pbnQueSx0aGlzLnN0YXJ0UG9pbnQueSk7XHJcbiAgICAgICAgICAgIHZhciBlbmRYID0gTWF0aC5tYXgodGhpcy5lbmRQb2ludC54LHRoaXMuc3RhcnRQb2ludC54KTtcclxuICAgICAgICAgICAgdmFyIGVuZFkgPSBNYXRoLm1heCh0aGlzLmVuZFBvaW50LnksdGhpcy5zdGFydFBvaW50LnkpO1xyXG5cclxuICAgICAgICAgICAgLypXZSB3aWxsIGNvbXB1dGUgdGhlIGRpc3RhbmNlIGZyb20gcG9pbnQgdG8gdGhlIGxpbmVcclxuICAgICAgICAgICAgICogYnkgdXNpbmcgdGhlIGFsZ29yaXRobSBmcm9tXHJcbiAgICAgICAgICAgICAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlzdGFuY2VfZnJvbV9hX3BvaW50X3RvX2FfbGluZVxyXG4gICAgICAgICAgICAgKiAqL1xyXG5cclxuICAgICAgICAgICAgLy9GaXJzdCB3ZSBuZWVkIHRvIGZpbmQgYSxiLGMgb2YgdGhlIGxpbmUgZXF1YXRpb24gYXggKyBieSArIGMgPSAwXHJcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5lbmRQb2ludC55IC0gdGhpcy5zdGFydFBvaW50Lnk7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5zdGFydFBvaW50LnggLSB0aGlzLmVuZFBvaW50Lng7XHJcbiAgICAgICAgICAgIHZhciBjID0gLSh0aGlzLnN0YXJ0UG9pbnQueCAqIHRoaXMuZW5kUG9pbnQueSAtIHRoaXMuZW5kUG9pbnQueCAqIHRoaXMuc3RhcnRQb2ludC55KTtcclxuXHJcbiAgICAgICAgICAgIC8vU2Vjb25kbHkgd2UgZ2V0IHRoZSBkaXN0YW5jZSBcIk1hdGhlbWF0aWNzIGZvciBDb21wdXRlciBHcmFwaGljcywgMm5kIEVkLiwgYnkgSm9obiBWaWNlLCBwYWdlIDIyN1wiXHJcbiAgICAgICAgICAgIHZhciBkID0gTWF0aC5hYnMoIChhKnggKyBiKnkgKyBjKSAvIE1hdGguc3FydChNYXRoLnBvdyhhLDIpICsgTWF0aC5wb3coYiwyKSkgKTtcclxuXHJcbiAgICAgICAgICAgIC8vVGhpcmRseSB3ZSBnZXQgY29vcmRpbmF0ZXMgb2YgY2xvc2VzdCBsaW5lJ3MgcG9pbnQgdG8gdGFyZ2V0IHBvaW50XHJcbiAgICAgICAgICAgIC8vaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9mcm9tX2FfcG9pbnRfdG9fYV9saW5lI0NhcnRlc2lhbl9jb29yZGluYXRlc1xyXG4gICAgICAgICAgICB2YXIgY2xvc2VzdFggPSAoYiAqIChiKnggLSBhKnkpIC0gYSpjKSAvICggTWF0aC5wb3coYSwyKSArIE1hdGgucG93KGIsMikgKTtcclxuICAgICAgICAgICAgdmFyIGNsb3Nlc3RZID0gKGEgKiAoLWIqeCArIGEqeSkgLSBiKmMpIC8gKCBNYXRoLnBvdyhhLDIpICsgTWF0aC5wb3coYiwyKSApO1xyXG5cclxuICAgICAgICAgICAgdmFyIHIgPSAoIGQgPD0gcmFkaXVzICYmIGVuZFg+PWNsb3Nlc3RYICYmIGNsb3Nlc3RYPj1zdGFydFggJiYgZW5kWT49Y2xvc2VzdFkgJiYgY2xvc2VzdFk+PXN0YXJ0WSApIC8vdGhlIHByb2plY3Rpb24gb2YgdGhlIHBvaW50IGZhbGxzIElOU0lERSBvZiB0aGUgc2VnbWVudFxyXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5zdGFydFBvaW50Lm5lYXIoeCx5LHJhZGl1cykgfHwgdGhpcy5lbmRQb2ludC5uZWFyKHgseSxyYWRpdXMpOyAvL3RoZSBwcm9qZWN0aW9uIG9mIHRoZSBwb2ludCBmYWxscyBPVVRTSURFIG9mIHRoZSBzZWdtZW50XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gIHI7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKndlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IGFycmF5IGVhY2ggdGltZSwgb3Igd2Ugd2lsbCBhZmZlY3QgdGhlIGFjdHVhbCBzaGFwZSovXHJcbiAgICAgICAgZ2V0UG9pbnRzOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2godGhpcy5zdGFydFBvaW50KTtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2godGhpcy5lbmRQb2ludCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqUmV0dXJuIHRoZSB7UG9pbnR9IGNvcnJlc3BvbmRpbmcgdGhlIHQgY2VydGFpbiB0IHZhbHVlXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHQgdGhlIHZhbHVlIG9mIHBhcmFtZXRlciB0LCB3aGVyZSB0IGluIFswLDFdLCB0IGlzIGxpa2UgYSBwZXJjZW50Ki9cclxuICAgICAgICBnZXRQb2ludDogZnVuY3Rpb24odCl7XHJcbiAgICAgICAgICAgIHZhciBYcCA9IHQgKiAodGhpcy5lbmRQb2ludC54IC0gdGhpcy5zdGFydFBvaW50LngpICsgdGhpcy5zdGFydFBvaW50Lng7XHJcbiAgICAgICAgICAgIHZhciBZcCA9IHQgKiAodGhpcy5lbmRQb2ludC55IC0gdGhpcy5zdGFydFBvaW50LnkpICsgdGhpcy5zdGFydFBvaW50Lnk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFhwLCBZcCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gLyoqXHJcbiAgICAgICAgLy8gICogUmV0dXJucyB0aGUgbWlkZGxlIG9mIHRoZSBsaW5lXHJcbiAgICAgICAgLy8gICogQHJldHVybiB7UG9pbnR9IHRoZSBtaWRkbGUgcG9pbnRcclxuICAgICAgICAvLyAgKiAqL1xyXG4gICAgICAgIC8vIGdldE1pZGRsZSA6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgLy8gICAgIHJldHVybiBVdGlsLmdldE1pZGRsZSh0aGlzLnN0YXJ0UG9pbnQsIHRoaXMuZW5kUG9pbnQpO1xyXG4gICAgICAgIC8vIH0sXHJcblxyXG5cclxuICAgICAgICAvLyBnZXRMZW5ndGggOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIC8vICAgICByZXR1cm4gVXRpbC5nZXRMZW5ndGgodGhpcy5zdGFydFBvaW50LCB0aGlzLmVuZFBvaW50KTtcclxuICAgICAgICAvLyB9LFxyXG5cclxuICAgICAgICAvLyAvKipcclxuICAgICAgICAvLyAgKkdldCBib3VuZHMgZm9yIHRoaXMgbGluZVxyXG4gICAgICAgIC8vICAqQGF1dGhvciBBbGV4IEdoZW9yZ2hpdSA8YWxleEBzY3JpcHRvaWQuY29tPlxyXG4gICAgICAgIC8vICAqKi9cclxuICAgICAgICAvLyBnZXRCb3VuZHM6ZnVuY3Rpb24oKXtcclxuICAgICAgICAvLyAgICAgcmV0dXJuIFV0aWwuZ2V0Qm91bmRzKHRoaXMuZ2V0UG9pbnRzKCkpO1xyXG4gICAgICAgIC8vIH0sXHJcblxyXG4gICAgICAgIC8qKlN0cmluZyByZXByZXNlbnRhdGlvbiovXHJcbiAgICAgICAgdG9TdHJpbmc6ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgcmV0dXJuICdsaW5lKCcgKyB0aGlzLnN0YXJ0UG9pbnQgKyAnLCcgKyB0aGlzLmVuZFBvaW50ICsgJyknO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IExpbmU7XHJcblxyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL0xpbmVTdHJ1Y3QuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxyXG5cclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuXHJcbiAgICB2YXIgYXBpTGlzdCA9IFtcclxuICAgICAgICAnZ2V0RG9tJywgJ2dldFpyJywgJ2dldFdpZHRoJywgJ2dldEhlaWdodCcsICdkaXNwYXRjaEFjdGlvbicsXHJcbiAgICAgICAgJ29uJywgJ29mZicsICd0cmlnZ2VyJywgJ2dldERhdGFVUkwnLCAnZ2V0Q29ubmVjdGVkRGF0YVVSTCcsICdnZXRNb2RlbCcsICdnZXRPcHRpb24nLFxyXG4gICAgICAgIFwicmVtb3ZlXCIsIFwiX2dldFBhcmVudFpyXCIsIFwiY2hhbmdlU2VsZWN0Q29ubmVjdG9yVHlwZVwiLFwiX2FkZEdyb3VwTm9kZVwiXHJcbiAgICBdO1xyXG5cclxuICAgIGZ1bmN0aW9uIEV4dGVuc2lvbkFQSShpbnN0YW5jZSkge1xyXG4gICAgICAgIHpyVXRpbC5lYWNoKGFwaUxpc3QsIGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB6clV0aWwuYmluZChpbnN0YW5jZVtuYW1lXSwgaW5zdGFuY2UpO1xyXG4gICAgICAgIH0sIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gRXh0ZW5zaW9uQVBJO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL0V4dGVuc2lvbkFwaS5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGd1aWQgPSByZXF1aXJlKFwiLi9jb3JlL2d1aWRcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwiLi9jb3JlL2VudlwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxudmFyIEhhbmRsZXIgPSByZXF1aXJlKFwiLi9IYW5kbGVyXCIpO1xuXG52YXIgU3RvcmFnZSA9IHJlcXVpcmUoXCIuL1N0b3JhZ2VcIik7XG5cbnZhciBQYWludGVyID0gcmVxdWlyZShcIi4vUGFpbnRlclwiKTtcblxudmFyIEFuaW1hdGlvbiA9IHJlcXVpcmUoXCIuL2FuaW1hdGlvbi9BbmltYXRpb25cIik7XG5cbnZhciBIYW5kbGVyUHJveHkgPSByZXF1aXJlKFwiLi9kb20vSGFuZGxlclByb3h5XCIpO1xuXG4vKiFcbiogWlJlbmRlciwgYSBoaWdoIHBlcmZvcm1hbmNlIDJkIGRyYXdpbmcgbGlicmFyeS5cbipcbiogQ29weXJpZ2h0IChjKSAyMDEzLCBCYWlkdSBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIExJQ0VOU0VcbiogaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS96cmVuZGVyL2Jsb2IvbWFzdGVyL0xJQ0VOU0UudHh0XG4qL1xudmFyIHVzZVZNTCA9ICFlbnYuY2FudmFzU3VwcG9ydGVkO1xudmFyIHBhaW50ZXJDdG9ycyA9IHtcbiAgY2FudmFzOiBQYWludGVyXG59O1xudmFyIGluc3RhbmNlcyA9IHt9OyAvLyBaUmVuZGVy5a6e5L6LbWFw57Si5byVXG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuXG52YXIgdmVyc2lvbiA9ICczLjcuNCc7XG4vKipcbiAqIEluaXRpYWxpemluZyBhIHpyZW5kZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5yZW5kZXJlcj0nY2FudmFzJ10gJ2NhbnZhcycgb3IgJ3N2ZydcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvXVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRzLmhlaWdodF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICovXG5cbmZ1bmN0aW9uIGluaXQoZG9tLCBvcHRzKSB7XG4gIHZhciB6ciA9IG5ldyBaUmVuZGVyKGd1aWQoKSwgZG9tLCBvcHRzKTtcbiAgaW5zdGFuY2VzW3pyLmlkXSA9IHpyO1xuICByZXR1cm4genI7XG59XG4vKipcbiAqIERpc3Bvc2UgenJlbmRlciBpbnN0YW5jZVxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICovXG5cblxuZnVuY3Rpb24gZGlzcG9zZSh6cikge1xuICBpZiAoenIpIHtcbiAgICB6ci5kaXNwb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIga2V5IGluIGluc3RhbmNlcykge1xuICAgICAgaWYgKGluc3RhbmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGluc3RhbmNlc1trZXldLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnN0YW5jZXMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuLyoqXG4gKiBHZXQgenJlbmRlciBpbnN0YW5jZSBieSBpZFxuICogQHBhcmFtIHtzdHJpbmd9IGlkIHpyZW5kZXIgaW5zdGFuY2UgaWRcbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRJbnN0YW5jZShpZCkge1xuICByZXR1cm4gaW5zdGFuY2VzW2lkXTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJQYWludGVyKG5hbWUsIEN0b3IpIHtcbiAgcGFpbnRlckN0b3JzW25hbWVdID0gQ3Rvcjtcbn1cblxuZnVuY3Rpb24gZGVsSW5zdGFuY2UoaWQpIHtcbiAgZGVsZXRlIGluc3RhbmNlc1tpZF07XG59XG4vKipcbiAqIEBtb2R1bGUgenJlbmRlci9aUmVuZGVyXG4gKi9cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9aUmVuZGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5yZW5kZXJlcj0nY2FudmFzJ10gJ2NhbnZhcycgb3IgJ3N2ZydcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICovXG5cblxudmFyIFpSZW5kZXIgPSBmdW5jdGlvbiAoaWQsIGRvbSwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgLyoqXG4gICAqIEB0eXBlIHtIVE1MRG9tRWxlbWVudH1cbiAgICovXG5cbiAgdGhpcy5kb20gPSBkb207XG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cblxuICB0aGlzLmlkID0gaWQ7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHN0b3JhZ2UgPSBuZXcgU3RvcmFnZSgpO1xuICB2YXIgcmVuZGVyZXJUeXBlID0gb3B0cy5yZW5kZXJlcjsgLy8gVE9ETyBXZWJHTFxuXG4gIGlmICh1c2VWTUwpIHtcbiAgICBpZiAoIXBhaW50ZXJDdG9ycy52bWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gcmVxdWlyZSBcXCd6cmVuZGVyL3ZtbC92bWxcXCcgdG8gc3VwcG9ydCBJRTgnKTtcbiAgICB9XG5cbiAgICByZW5kZXJlclR5cGUgPSAndm1sJztcbiAgfSBlbHNlIGlmICghcmVuZGVyZXJUeXBlIHx8ICFwYWludGVyQ3RvcnNbcmVuZGVyZXJUeXBlXSkge1xuICAgIHJlbmRlcmVyVHlwZSA9ICdjYW52YXMnO1xuICB9XG5cbiAgdmFyIHBhaW50ZXIgPSBuZXcgcGFpbnRlckN0b3JzW3JlbmRlcmVyVHlwZV0oZG9tLCBzdG9yYWdlLCBvcHRzKTtcbiAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcbiAgdmFyIGhhbmRlclByb3h5ID0gIWVudi5ub2RlID8gbmV3IEhhbmRsZXJQcm94eShwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpKSA6IG51bGw7XG4gIHRoaXMuaGFuZGxlciA9IG5ldyBIYW5kbGVyKHN0b3JhZ2UsIHBhaW50ZXIsIGhhbmRlclByb3h5LCBwYWludGVyLnJvb3QpO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb259XG4gICAqL1xuXG4gIHRoaXMuYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbih7XG4gICAgc3RhZ2U6IHtcbiAgICAgIHVwZGF0ZTogenJVdGlsLmJpbmQodGhpcy5mbHVzaCwgdGhpcylcbiAgICB9XG4gIH0pO1xuICB0aGlzLmFuaW1hdGlvbi5zdGFydCgpO1xuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX25lZWRzUmVmcmVzaDsgLy8g5L+u5pS5IHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UsIOavj+asoeWIoOmZpOWFg+e0oOS5i+WJjeWIoOmZpOWKqOeUu1xuICAvLyBGSVhNRSDmnInngrl1Z2x5XG5cbiAgdmFyIG9sZERlbEZyb21TdG9yYWdlID0gc3RvcmFnZS5kZWxGcm9tU3RvcmFnZTtcbiAgdmFyIG9sZEFkZFRvU3RvcmFnZSA9IHN0b3JhZ2UuYWRkVG9TdG9yYWdlO1xuXG4gIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICBvbGREZWxGcm9tU3RvcmFnZS5jYWxsKHN0b3JhZ2UsIGVsKTtcbiAgICBlbCAmJiBlbC5yZW1vdmVTZWxmRnJvbVpyKHNlbGYpO1xuICB9O1xuXG4gIHN0b3JhZ2UuYWRkVG9TdG9yYWdlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgb2xkQWRkVG9TdG9yYWdlLmNhbGwoc3RvcmFnZSwgZWwpO1xuICAgIGVsLmFkZFNlbGZUb1pyKHNlbGYpO1xuICB9O1xufTtcblxuWlJlbmRlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBaUmVuZGVyLFxuXG4gIC8qKlxuICAgKiDojrflj5blrp7kvovllK/kuIDmoIfor4ZcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0SWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pZDtcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5YWD57SgXG4gICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAqL1xuICBhZGQ6IGZ1bmN0aW9uIChlbCkge1xuICAgIHRoaXMuc3RvcmFnZS5hZGRSb290KGVsKTtcbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiDliKDpmaTlhYPntKBcbiAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgdGhpcy5zdG9yYWdlLmRlbFJvb3QoZWwpO1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoYW5nZSBjb25maWd1cmF0aW9uIG9mIGxheWVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6TGV2ZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5jbGVhckNvbG9yPTBdIENsZWFyIGNvbG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLm1vdGlvbkJsdXI9ZmFsc2VdIElmIGVuYWJsZSBtb3Rpb24gYmx1clxuICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5sYXN0RnJhbWVBbHBoYT0wLjddIE1vdGlvbiBibHVyIGZhY3Rvci4gTGFyZ2VyIHZhbHVlIGNhdXNlIGxvbmdlciB0cmFpbGVyXG4gICovXG4gIGNvbmZpZ0xheWVyOiBmdW5jdGlvbiAoekxldmVsLCBjb25maWcpIHtcbiAgICB0aGlzLnBhaW50ZXIuY29uZmlnTGF5ZXIoekxldmVsLCBjb25maWcpO1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgdGhlIGNhbnZhcyBpbW1lZGlhdGVseVxuICAgKi9cbiAgcmVmcmVzaEltbWVkaWF0ZWx5OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gdmFyIHN0YXJ0ID0gbmV3IERhdGUoKTtcbiAgICAvLyBDbGVhciBuZWVkc1JlZnJlc2ggYWhlYWQgdG8gYXZvaWQgc29tZXRoaW5nIHdyb25nIGhhcHBlbnMgaW4gcmVmcmVzaFxuICAgIC8vIE9yIGl0IHdpbGwgY2F1c2UgenJlbmRlciByZWZyZXNoZXMgYWdhaW4gYW5kIGFnYWluLlxuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IGZhbHNlO1xuICAgIHRoaXMucGFpbnRlci5yZWZyZXNoKCk7XG4gICAgLyoqXG4gICAgICogQXZvaWQgdHJpZ2dlciB6ci5yZWZyZXNoIGluIEVsZW1lbnQjYmVmb3JlVXBkYXRlIGhvb2tcbiAgICAgKi9cblxuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IGZhbHNlOyAvLyB2YXIgZW5kID0gbmV3IERhdGUoKTtcbiAgICAvLyB2YXIgbG9nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvZycpO1xuICAgIC8vIGlmIChsb2cpIHtcbiAgICAvLyAgICAgbG9nLmlubmVySFRNTCA9IGxvZy5pbm5lckhUTUwgKyAnPGJyPicgKyAoZW5kIC0gc3RhcnQpO1xuICAgIC8vIH1cbiAgfSxcblxuICAvKipcbiAgICogTWFyayBhbmQgcmVwYWludCB0aGUgY2FudmFzIGluIHRoZSBuZXh0IGZyYW1lIG9mIGJyb3dzZXJcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFsbCByZWZyZXNoXG4gICAqL1xuICBmbHVzaDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9uZWVkc1JlZnJlc2gpIHtcbiAgICAgIHRoaXMucmVmcmVzaEltbWVkaWF0ZWx5KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyKSB7XG4gICAgICB0aGlzLnJlZnJlc2hIb3ZlckltbWVkaWF0ZWx5KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgZWxlbWVudCB0byBob3ZlciBsYXllclxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICovXG4gIGFkZEhvdmVyOiBmdW5jdGlvbiAoZWwsIHN0eWxlKSB7XG4gICAgaWYgKHRoaXMucGFpbnRlci5hZGRIb3Zlcikge1xuICAgICAgdGhpcy5wYWludGVyLmFkZEhvdmVyKGVsLCBzdHlsZSk7XG4gICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWRkIGVsZW1lbnQgZnJvbSBob3ZlciBsYXllclxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKi9cbiAgcmVtb3ZlSG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmICh0aGlzLnBhaW50ZXIucmVtb3ZlSG92ZXIpIHtcbiAgICAgIHRoaXMucGFpbnRlci5yZW1vdmVIb3ZlcihlbCk7XG4gICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2xlYXIgYWxsIGhvdmVyIGVsZW1lbnRzIGluIGhvdmVyIGxheWVyXG4gICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAqL1xuICBjbGVhckhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucGFpbnRlci5jbGVhckhvdmVyKSB7XG4gICAgICB0aGlzLnBhaW50ZXIuY2xlYXJIb3ZlcigpO1xuICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZnJlc2ggaG92ZXIgaW4gbmV4dCBmcmFtZVxuICAgKi9cbiAgcmVmcmVzaEhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fbmVlZHNSZWZyZXNoSG92ZXIgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIGhvdmVyIGltbWVkaWF0ZWx5XG4gICAqL1xuICByZWZyZXNoSG92ZXJJbW1lZGlhdGVseTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyID0gZmFsc2U7XG4gICAgdGhpcy5wYWludGVyLnJlZnJlc2hIb3ZlciAmJiB0aGlzLnBhaW50ZXIucmVmcmVzaEhvdmVyKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2l6ZSB0aGUgY2FudmFzLlxuICAgKiBTaG91bGQgYmUgaW52b2tlZCB3aGVuIGNvbnRhaW5lciBzaXplIGlzIGNoYW5nZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgKi9cbiAgcmVzaXplOiBmdW5jdGlvbiAob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHRoaXMucGFpbnRlci5yZXNpemUob3B0cy53aWR0aCwgb3B0cy5oZWlnaHQpO1xuICAgIHRoaXMuaGFuZGxlci5yZXNpemUoKTtcbiAgfSxcblxuICAvKipcbiAgICogU3RvcCBhbmQgY2xlYXIgYWxsIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxuICAgKi9cbiAgY2xlYXJBbmltYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFuaW1hdGlvbi5jbGVhcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgY29udGFpbmVyIHdpZHRoXG4gICAqL1xuICBnZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0V2lkdGgoKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGNvbnRhaW5lciBoZWlnaHRcbiAgICovXG4gIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0SGVpZ2h0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4cG9ydCB0aGUgY2FudmFzIGFzIEJhc2U2NCBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtiYWNrZ3JvdW5kQ29sb3I9JyNmZmYnXVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEJhc2U2NCBVUkxcbiAgICovXG4gIC8vIHRvRGF0YVVSTDogZnVuY3Rpb24odHlwZSwgYmFja2dyb3VuZENvbG9yKSB7XG4gIC8vICAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldFJlbmRlcmVkQ2FudmFzKHtcbiAgLy8gICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvclxuICAvLyAgICAgfSkudG9EYXRhVVJMKHR5cGUpO1xuICAvLyB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0aW5nIGEgcGF0aCB0byBpbWFnZS5cbiAgICogSXQgaGFzIG11Y2ggYmV0dGVyIHBlcmZvcm1hbmNlIG9mIGRyYXdpbmcgaW1hZ2UgcmF0aGVyIHRoYW4gZHJhd2luZyBhIHZlY3RvciBwYXRoLlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH0gZVxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgKi9cbiAgcGF0aFRvSW1hZ2U6IGZ1bmN0aW9uIChlLCBkcHIpIHtcbiAgICByZXR1cm4gdGhpcy5wYWludGVyLnBhdGhUb0ltYWdlKGUsIGRwcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCBkZWZhdWx0IGN1cnNvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvclN0eWxlPSdkZWZhdWx0J10g5L6L5aaCIGNyb3NzaGFpclxuICAgKi9cbiAgc2V0Q3Vyc29yU3R5bGU6IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgIHRoaXMuaGFuZGxlci5zZXRDdXJzb3JTdHlsZShjdXJzb3JTdHlsZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmQgaG92ZXJlZCBlbGVtZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge09iamVjdH0ge3RhcmdldCwgdG9wVGFyZ2V0fVxuICAgKi9cbiAgZmluZEhvdmVyOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZmluZEhvdmVyKHgsIHkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBCaW5kIGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudEhhbmRsZXIgSGFuZGxlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIENvbnRleHQgb2JqZWN0XG4gICAqL1xuICBvbjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgdGhpcy5oYW5kbGVyLm9uKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogVW5iaW5kIGV2ZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXZlbnRIYW5kbGVyXSBIYW5kbGVyIGZ1bmN0aW9uXG4gICAqL1xuICBvZmY6IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50SGFuZGxlcikge1xuICAgIHRoaXMuaGFuZGxlci5vZmYoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGV2ZW50IG1hbnVhbGx5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge2V2ZW50PX0gZXZlbnQgRXZlbnQgb2JqZWN0XG4gICAqL1xuICB0cmlnZ2VyOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudCkge1xuICAgIHRoaXMuaGFuZGxlci50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgb2JqZWN0cyBhbmQgdGhlIGNhbnZhcy5cbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdG9yYWdlLmRlbFJvb3QoKTtcbiAgICB0aGlzLnBhaW50ZXIuY2xlYXIoKTtcbiAgfSxcblxuICAvKipcbiAgICogRGlzcG9zZSBzZWxmLlxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYW5pbWF0aW9uLnN0b3AoKTtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5zdG9yYWdlLmRpc3Bvc2UoKTtcbiAgICB0aGlzLnBhaW50ZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuaGFuZGxlci5kaXNwb3NlKCk7XG4gICAgdGhpcy5hbmltYXRpb24gPSB0aGlzLnN0b3JhZ2UgPSB0aGlzLnBhaW50ZXIgPSB0aGlzLmhhbmRsZXIgPSBudWxsO1xuICAgIGRlbEluc3RhbmNlKHRoaXMuaWQpO1xuICB9XG59O1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5leHBvcnRzLmRpc3Bvc2UgPSBkaXNwb3NlO1xuZXhwb3J0cy5nZXRJbnN0YW5jZSA9IGdldEluc3RhbmNlO1xuZXhwb3J0cy5yZWdpc3RlclBhaW50ZXIgPSByZWdpc3RlclBhaW50ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL3pyZW5kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB1dGlsID0gcmVxdWlyZShcIi4vY29yZS91dGlsXCIpO1xuXG52YXIgdmVjMiA9IHJlcXVpcmUoXCIuL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgRHJhZ2dhYmxlID0gcmVxdWlyZShcIi4vbWl4aW4vRHJhZ2dhYmxlXCIpO1xuXG52YXIgRXZlbnRmdWwgPSByZXF1aXJlKFwiLi9taXhpbi9FdmVudGZ1bFwiKTtcblxuLyoqXG4gKiBIYW5kbGVyXG4gKiBAbW9kdWxlIHpyZW5kZXIvSGFuZGxlclxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKiAgICAgICAgIHBpc3NhbmcgKHNoZW55aS45MTRAZ21haWwuY29tKVxuICovXG52YXIgU0lMRU5UID0gJ3NpbGVudCc7XG5cbmZ1bmN0aW9uIG1ha2VFdmVudFBhY2tldChldmVUeXBlLCB0YXJnZXRJbmZvLCBldmVudCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGV2ZVR5cGUsXG4gICAgZXZlbnQ6IGV2ZW50LFxuICAgIC8vIHRhcmdldCBjYW4gb25seSBiZSBhbiBlbGVtZW50IHRoYXQgaXMgbm90IHNpbGVudC5cbiAgICB0YXJnZXQ6IHRhcmdldEluZm8udGFyZ2V0LFxuICAgIC8vIHRvcFRhcmdldCBjYW4gYmUgYSBzaWxlbnQgZWxlbWVudC5cbiAgICB0b3BUYXJnZXQ6IHRhcmdldEluZm8udG9wVGFyZ2V0LFxuICAgIGNhbmNlbEJ1YmJsZTogZmFsc2UsXG4gICAgb2Zmc2V0WDogZXZlbnQuenJYLFxuICAgIG9mZnNldFk6IGV2ZW50LnpyWSxcbiAgICBnZXN0dXJlRXZlbnQ6IGV2ZW50Lmdlc3R1cmVFdmVudCxcbiAgICBwaW5jaFg6IGV2ZW50LnBpbmNoWCxcbiAgICBwaW5jaFk6IGV2ZW50LnBpbmNoWSxcbiAgICBwaW5jaFNjYWxlOiBldmVudC5waW5jaFNjYWxlLFxuICAgIHdoZWVsRGVsdGE6IGV2ZW50LnpyRGVsdGEsXG4gICAgenJCeVRvdWNoOiBldmVudC56ckJ5VG91Y2gsXG4gICAgd2hpY2g6IGV2ZW50LndoaWNoXG4gIH07XG59XG5cbmZ1bmN0aW9uIEVtcHR5UHJveHkoKSB7fVxuXG5FbXB0eVByb3h5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge307XG5cbnZhciBoYW5kbGVyTmFtZXMgPSBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNld2hlZWwnLCAnbW91c2VvdXQnLCAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ2NvbnRleHRtZW51J107XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9IYW5kbGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2UgU3RvcmFnZSBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvUGFpbnRlcn0gcGFpbnRlciBQYWludGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9kb20vSGFuZGxlclByb3h5fSBwcm94eSBIYW5kbGVyUHJveHkgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYWludGVyUm9vdCBwYWludGVyLnJvb3QgKG5vdCBwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpKS5cbiAqL1xuXG52YXIgSGFuZGxlciA9IGZ1bmN0aW9uIChzdG9yYWdlLCBwYWludGVyLCBwcm94eSwgcGFpbnRlclJvb3QpIHtcbiAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcbiAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcbiAgdGhpcy5wYWludGVyUm9vdCA9IHBhaW50ZXJSb290O1xuICBwcm94eSA9IHByb3h5IHx8IG5ldyBFbXB0eVByb3h5KCk7XG4gIC8qKlxuICAgKiBQcm94eSBvZiBldmVudC4gY2FuIGJlIERvbSwgV2ViR0xTdXJmYWNlLCBldGMuXG4gICAqL1xuXG4gIHRoaXMucHJveHkgPSBwcm94eTsgLy8gQXR0YWNoIGhhbmRsZXJcblxuICBwcm94eS5oYW5kbGVyID0gdGhpcztcbiAgLyoqXG4gICAqIHt0YXJnZXQsIHRvcFRhcmdldCwgeCwgeX1cbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbiAgdGhpcy5faG92ZXJlZCA9IHt9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0RhdGV9XG4gICAqL1xuXG4gIHRoaXMuX2xhc3RUb3VjaE1vbWVudDtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuX2xhc3RYO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5fbGFzdFk7XG4gIERyYWdnYWJsZS5jYWxsKHRoaXMpO1xuICB1dGlsLmVhY2goaGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHByb3h5Lm9uICYmIHByb3h5Lm9uKG5hbWUsIHRoaXNbbmFtZV0sIHRoaXMpO1xuICB9LCB0aGlzKTtcbn07XG5cbkhhbmRsZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogSGFuZGxlcixcbiAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgeCA9IGV2ZW50LnpyWDtcbiAgICB2YXIgeSA9IGV2ZW50LnpyWTtcbiAgICB2YXIgbGFzdEhvdmVyZWQgPSB0aGlzLl9ob3ZlcmVkO1xuICAgIHZhciBsYXN0SG92ZXJlZFRhcmdldCA9IGxhc3RIb3ZlcmVkLnRhcmdldDsgLy8gSWYgbGFzdEhvdmVyZWRUYXJnZXQgaXMgcmVtb3ZlZCBmcm9tIHpyIChkZXRlY3RlZCBieSAnX196cicpIGJ5IHNvbWUgQVBJIGNhbGxcbiAgICAvLyAobGlrZSAnc2V0T3B0aW9uJyBvciAnZGlzcGF0Y2hBY3Rpb24nKSBpbiBldmVudCBoYW5kbGVycywgd2Ugc2hvdWxkIGZpbmRcbiAgICAvLyBsYXN0SG92ZXJlZCBhZ2FpbiBoZXJlLiBPdGhlcndpc2UgJ21vdXNlb3V0JyBjYW4gbm90IGJlIHRyaWdnZXJlZCBub3JtYWxseS5cbiAgICAvLyBTZWUgIzYxOTguXG5cbiAgICBpZiAobGFzdEhvdmVyZWRUYXJnZXQgJiYgIWxhc3RIb3ZlcmVkVGFyZ2V0Ll9fenIpIHtcbiAgICAgIGxhc3RIb3ZlcmVkID0gdGhpcy5maW5kSG92ZXIobGFzdEhvdmVyZWQueCwgbGFzdEhvdmVyZWQueSk7XG4gICAgICBsYXN0SG92ZXJlZFRhcmdldCA9IGxhc3RIb3ZlcmVkLnRhcmdldDtcbiAgICB9XG5cbiAgICB2YXIgaG92ZXJlZCA9IHRoaXMuX2hvdmVyZWQgPSB0aGlzLmZpbmRIb3Zlcih4LCB5KTtcbiAgICB2YXIgaG92ZXJlZFRhcmdldCA9IGhvdmVyZWQudGFyZ2V0O1xuICAgIHZhciBwcm94eSA9IHRoaXMucHJveHk7XG4gICAgcHJveHkuc2V0Q3Vyc29yICYmIHByb3h5LnNldEN1cnNvcihob3ZlcmVkVGFyZ2V0ID8gaG92ZXJlZFRhcmdldC5jdXJzb3IgOiAnZGVmYXVsdCcpOyAvLyBNb3VzZSBvdXQgb24gcHJldmlvdXMgaG92ZXJlZCBlbGVtZW50XG5cbiAgICBpZiAobGFzdEhvdmVyZWRUYXJnZXQgJiYgaG92ZXJlZFRhcmdldCAhPT0gbGFzdEhvdmVyZWRUYXJnZXQpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQobGFzdEhvdmVyZWQsICdtb3VzZW91dCcsIGV2ZW50KTtcbiAgICB9IC8vIE1vdXNlIG1vdmluZyBvbiBvbmUgZWxlbWVudFxuXG5cbiAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsICdtb3VzZW1vdmUnLCBldmVudCk7IC8vIE1vdXNlIG92ZXIgb24gYSBuZXcgZWxlbWVudFxuXG4gICAgaWYgKGhvdmVyZWRUYXJnZXQgJiYgaG92ZXJlZFRhcmdldCAhPT0gbGFzdEhvdmVyZWRUYXJnZXQpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQoaG92ZXJlZCwgJ21vdXNlb3ZlcicsIGV2ZW50KTtcbiAgICB9XG4gIH0sXG4gIG1vdXNlb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHRoaXMuX2hvdmVyZWQsICdtb3VzZW91dCcsIGV2ZW50KTsgLy8gVGhlcmUgbWlnaHQgYmUgc29tZSBkb21zIGNyZWF0ZWQgYnkgdXBwZXIgbGF5ZXIgYXBwbGljYXRpb25cbiAgICAvLyBhdCB0aGUgc2FtZSBsZXZlbCBvZiBwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpIChlLmcuLCB0b29sdGlwXG4gICAgLy8gZG9tIGNyZWF0ZWQgYnkgZWNoYXJ0cyksIHdoZXJlICdnbG9iYWxvdXQnIGV2ZW50IHNob3VsZCBub3RcbiAgICAvLyBiZSB0cmlnZ2VyZWQgd2hlbiBtb3VzZSBlbnRlcnMgdGhlc2UgZG9tcy4gKEJ1dCAnbW91c2VvdXQnXG4gICAgLy8gc2hvdWxkIGJlIHRyaWdnZXJlZCBhdCB0aGUgb3JpZ2luYWwgaG92ZXJlZCBlbGVtZW50IGFzIHVzdWFsKS5cblxuICAgIHZhciBlbGVtZW50ID0gZXZlbnQudG9FbGVtZW50IHx8IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgdmFyIGlubmVyRG9tO1xuXG4gICAgZG8ge1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnQgJiYgZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIH0gd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSAhPSA5ICYmICEoaW5uZXJEb20gPSBlbGVtZW50ID09PSB0aGlzLnBhaW50ZXJSb290KSk7XG5cbiAgICAhaW5uZXJEb20gJiYgdGhpcy50cmlnZ2VyKCdnbG9iYWxvdXQnLCB7XG4gICAgICBldmVudDogZXZlbnRcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVzaXplXG4gICAqL1xuICByZXNpemU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuX2hvdmVyZWQgPSB7fTtcbiAgfSxcblxuICAvKipcbiAgICogRGlzcGF0Y2ggZXZlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge2V2ZW50PX0gZXZlbnRBcmdzXG4gICAqL1xuICBkaXNwYXRjaDogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRBcmdzKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB0aGlzW2V2ZW50TmFtZV07XG4gICAgaGFuZGxlciAmJiBoYW5kbGVyLmNhbGwodGhpcywgZXZlbnRBcmdzKTtcbiAgfSxcblxuICAvKipcbiAgICogRGlzcG9zZVxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucHJveHkuZGlzcG9zZSgpO1xuICAgIHRoaXMuc3RvcmFnZSA9IHRoaXMucHJveHkgPSB0aGlzLnBhaW50ZXIgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiDorr7nva7pu5jorqTnmoRjdXJzb3Igc3R5bGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JTdHlsZT0nZGVmYXVsdCddIOS+i+WmgiBjcm9zc2hhaXJcbiAgICovXG4gIHNldEN1cnNvclN0eWxlOiBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgICB2YXIgcHJveHkgPSB0aGlzLnByb3h5O1xuICAgIHByb3h5LnNldEN1cnNvciAmJiBwcm94eS5zZXRDdXJzb3IoY3Vyc29yU3R5bGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDkuovku7bliIblj5Hku6PnkIZcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldEluZm8ge3RhcmdldCwgdG9wVGFyZ2V0fSDnm67moIflm77lvaLlhYPntKBcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSDkuovku7blkI3np7BcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tuWvueixoVxuICAgKi9cbiAgZGlzcGF0Y2hUb0VsZW1lbnQ6IGZ1bmN0aW9uICh0YXJnZXRJbmZvLCBldmVudE5hbWUsIGV2ZW50KSB7XG4gICAgdGFyZ2V0SW5mbyA9IHRhcmdldEluZm8gfHwge307XG4gICAgdmFyIGVsID0gdGFyZ2V0SW5mby50YXJnZXQ7XG5cbiAgICBpZiAoZWwgJiYgZWwuc2lsZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50SGFuZGxlciA9ICdvbicgKyBldmVudE5hbWU7XG4gICAgdmFyIGV2ZW50UGFja2V0ID0gbWFrZUV2ZW50UGFja2V0KGV2ZW50TmFtZSwgdGFyZ2V0SW5mbywgZXZlbnQpO1xuXG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICBlbFtldmVudEhhbmRsZXJdICYmIChldmVudFBhY2tldC5jYW5jZWxCdWJibGUgPSBlbFtldmVudEhhbmRsZXJdLmNhbGwoZWwsIGV2ZW50UGFja2V0KSk7XG4gICAgICBlbC50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRQYWNrZXQpO1xuICAgICAgZWwgPSBlbC5wYXJlbnQ7XG5cbiAgICAgIGlmIChldmVudFBhY2tldC5jYW5jZWxCdWJibGUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFldmVudFBhY2tldC5jYW5jZWxCdWJibGUpIHtcbiAgICAgIC8vIOWGkuazoeWIsOmhtue6pyB6cmVuZGVyIOWvueixoVxuICAgICAgdGhpcy50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRQYWNrZXQpOyAvLyDliIblj5Hkuovku7bliLDnlKjmiLfoh6rlrprkuYnlsYJcbiAgICAgIC8vIOeUqOaIt+acieWPr+iDveWcqOWFqOWxgCBjbGljayDkuovku7bkuK0gZGlzcG9zZe+8jOaJgOS7pemcgOimgeWIpOaWreS4iyBwYWludGVyIOaYr+WQpuWtmOWcqFxuXG4gICAgICB0aGlzLnBhaW50ZXIgJiYgdGhpcy5wYWludGVyLmVhY2hPdGhlckxheWVyKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICBpZiAodHlwZW9mIGxheWVyW2V2ZW50SGFuZGxlcl0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGxheWVyW2V2ZW50SGFuZGxlcl0uY2FsbChsYXllciwgZXZlbnRQYWNrZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxheWVyLnRyaWdnZXIpIHtcbiAgICAgICAgICBsYXllci50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRQYWNrZXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZX0gZXhjbHVkZVxuICAgKiBAcmV0dXJuIHttb2RlbDp6cmVuZGVyL0VsZW1lbnR9XG4gICAqIEBtZXRob2RcbiAgICovXG4gIGZpbmRIb3ZlcjogZnVuY3Rpb24gKHgsIHksIGV4Y2x1ZGUpIHtcbiAgICB2YXIgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpO1xuICAgIHZhciBvdXQgPSB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGhvdmVyQ2hlY2tSZXN1bHQ7XG5cbiAgICAgIGlmIChsaXN0W2ldICE9PSBleGNsdWRlIC8vIGdldERpc3BsYXlMaXN0IG1heSBpbmNsdWRlIGlnbm9yZWQgaXRlbSBpbiBWTUwgbW9kZVxuICAgICAgJiYgIWxpc3RbaV0uaWdub3JlICYmIChob3ZlckNoZWNrUmVzdWx0ID0gaXNIb3ZlcihsaXN0W2ldLCB4LCB5KSkpIHtcbiAgICAgICAgIW91dC50b3BUYXJnZXQgJiYgKG91dC50b3BUYXJnZXQgPSBsaXN0W2ldKTtcblxuICAgICAgICBpZiAoaG92ZXJDaGVja1Jlc3VsdCAhPT0gU0lMRU5UKSB7XG4gICAgICAgICAgb3V0LnRhcmdldCA9IGxpc3RbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG59OyAvLyBDb21tb24gaGFuZGxlcnNcblxudXRpbC5lYWNoKFsnY2xpY2snLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnbW91c2V3aGVlbCcsICdkYmxjbGljaycsICdjb250ZXh0bWVudSddLCBmdW5jdGlvbiAobmFtZSkge1xuICBIYW5kbGVyLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIEZpbmQgaG92ZXIgYWdhaW4gdG8gYXZvaWQgY2xpY2sgZXZlbnQgaXMgZGlzcGF0Y2hlZCBtYW51YWxseS4gT3IgY2xpY2sgaXMgdHJpZ2dlcmVkIHdpdGhvdXQgbW91c2VvdmVyXG4gICAgdmFyIGhvdmVyZWQgPSB0aGlzLmZpbmRIb3ZlcihldmVudC56clgsIGV2ZW50LnpyWSk7XG4gICAgdmFyIGhvdmVyZWRUYXJnZXQgPSBob3ZlcmVkLnRhcmdldDtcblxuICAgIGlmIChuYW1lID09PSAnbW91c2Vkb3duJykge1xuICAgICAgdGhpcy5fZG93bkVsID0gaG92ZXJlZFRhcmdldDtcbiAgICAgIHRoaXMuX2Rvd25Qb2ludCA9IFtldmVudC56clgsIGV2ZW50LnpyWV07IC8vIEluIGNhc2UgY2xpY2sgdHJpZ2dlcmVkIGJlZm9yZSBtb3VzZXVwXG5cbiAgICAgIHRoaXMuX3VwRWwgPSBob3ZlcmVkVGFyZ2V0O1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ21vc3VldXAnKSB7XG4gICAgICB0aGlzLl91cEVsID0gaG92ZXJlZFRhcmdldDtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgIGlmICh0aGlzLl9kb3duRWwgIT09IHRoaXMuX3VwRWwgLy8gT3JpZ2luYWwgY2xpY2sgZXZlbnQgaXMgdHJpZ2dlcmVkIG9uIHRoZSB3aG9sZSBjYW52YXMgZWxlbWVudCxcbiAgICAgIC8vIGluY2x1ZGluZyB0aGUgY2FzZSB0aGF0IGBtb3VzZWRvd25gIC0gYG1vdXNlbW92ZWAgLSBgbW91c2V1cGAsXG4gICAgICAvLyB3aGljaCBzaG91bGQgYmUgZmlsdGVyZWQsIG90aGVyd2lzZSBpdCB3aWxsIGJyaW5nIHRyb3VibGUgdG9cbiAgICAgIC8vIHBhbiBhbmQgem9vbS5cbiAgICAgIHx8ICF0aGlzLl9kb3duUG9pbnQgLy8gQXJiaXRyYXJ5IHZhbHVlXG4gICAgICB8fCB2ZWMyLmRpc3QodGhpcy5fZG93blBvaW50LCBbZXZlbnQuenJYLCBldmVudC56clldKSA+IDQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kb3duUG9pbnQgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQoaG92ZXJlZCwgbmFtZSwgZXZlbnQpO1xuICB9O1xufSk7XG5cbmZ1bmN0aW9uIGlzSG92ZXIoZGlzcGxheWFibGUsIHgsIHkpIHtcbiAgaWYgKGRpc3BsYXlhYmxlW2Rpc3BsYXlhYmxlLnJlY3RIb3ZlciA/ICdyZWN0Q29udGFpbicgOiAnY29udGFpbiddKHgsIHkpKSB7XG4gICAgdmFyIGVsID0gZGlzcGxheWFibGU7XG4gICAgdmFyIGlzU2lsZW50O1xuXG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICAvLyBJZiBjbGlwcGVkIGJ5IGFuY2VzdG9yLlxuICAgICAgLy8gRklYTUU6IElmIGNsaXBQYXRoIGhhcyBuZWl0aGVyIHN0cm9rZSBub3IgZmlsbCxcbiAgICAgIC8vIGVsLmNsaXBQYXRoLmNvbnRhaW4oeCwgeSkgd2lsbCBhbHdheXMgcmV0dXJuIGZhbHNlLlxuICAgICAgaWYgKGVsLmNsaXBQYXRoICYmICFlbC5jbGlwUGF0aC5jb250YWluKHgsIHkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsLnNpbGVudCkge1xuICAgICAgICBpc1NpbGVudCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGVsID0gZWwucGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBpc1NpbGVudCA/IFNJTEVOVCA6IHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnV0aWwubWl4aW4oSGFuZGxlciwgRXZlbnRmdWwpO1xudXRpbC5taXhpbihIYW5kbGVyLCBEcmFnZ2FibGUpO1xudmFyIF9kZWZhdWx0ID0gSGFuZGxlcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL0hhbmRsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB1dGlsID0gcmVxdWlyZShcIi4vY29yZS91dGlsXCIpO1xuXG52YXIgZW52ID0gcmVxdWlyZShcIi4vY29yZS9lbnZcIik7XG5cbnZhciBHcm91cCA9IHJlcXVpcmUoXCIuL2NvbnRhaW5lci9Hcm91cFwiKTtcblxudmFyIHRpbXNvcnQgPSByZXF1aXJlKFwiLi9jb3JlL3RpbXNvcnRcIik7XG5cbi8qKlxuICogU3RvcmFnZeWGheWuueS7k+W6k+aooeWdl1xuICogQG1vZHVsZSB6cmVuZGVyL1N0b3JhZ2VcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogQGF1dGhvciBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZy8pXG4gKi9cbi8vIFVzZSB0aW1zb3J0IGJlY2F1c2UgaW4gbW9zdCBjYXNlIGVsZW1lbnRzIGFyZSBwYXJ0aWFsbHkgc29ydGVkXG4vLyBodHRwczovL2pzZmlkZGxlLm5ldC9waXNzYW5nL2pyNHg3bWRtLzgvXG5mdW5jdGlvbiBzaGFwZUNvbXBhcmVGdW5jKGEsIGIpIHtcbiAgaWYgKGEuemxldmVsID09PSBiLnpsZXZlbCkge1xuICAgIGlmIChhLnogPT09IGIueikge1xuICAgICAgLy8gaWYgKGEuejIgPT09IGIuejIpIHtcbiAgICAgIC8vICAgICAvLyBGSVhNRSBTbG93IGhhcyByZW5kZXJpZHggY29tcGFyZVxuICAgICAgLy8gICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjA4ODM0MjEvc29ydGluZy1pbi1qYXZhc2NyaXB0LXNob3VsZC1ldmVyeS1jb21wYXJlLWZ1bmN0aW9uLWhhdmUtYS1yZXR1cm4tMC1zdGF0ZW1lbnRcbiAgICAgIC8vICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdjgvdjgvYmxvYi80N2NjZTU0NGEzMWVkNTU3N2ZmZTI5NjNmNjdhY2I0MTQ0ZWUwMjMyL3NyYy9qcy9hcnJheS5qcyNMMTAxMlxuICAgICAgLy8gICAgIHJldHVybiBhLl9fcmVuZGVyaWR4IC0gYi5fX3JlbmRlcmlkeDtcbiAgICAgIC8vIH1cbiAgICAgIHJldHVybiBhLnoyIC0gYi56MjtcbiAgICB9XG5cbiAgICByZXR1cm4gYS56IC0gYi56O1xuICB9XG5cbiAgcmV0dXJuIGEuemxldmVsIC0gYi56bGV2ZWw7XG59XG4vKipcbiAqIOWGheWuueS7k+W6kyAoTSlcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9TdG9yYWdlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5cbnZhciBTdG9yYWdlID0gZnVuY3Rpb24gKCkge1xuICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgdGhpcy5fcm9vdHMgPSBbXTtcbiAgdGhpcy5fZGlzcGxheUxpc3QgPSBbXTtcbiAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xufTtcblxuU3RvcmFnZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBTdG9yYWdlLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICpcbiAgICovXG4gIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Jvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9yb290c1tpXS50cmF2ZXJzZShjYiwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDov5Tlm57miYDmnInlm77lvaLnmoTnu5jliLbpmJ/liJdcbiAgICogQHBhcmFtIHtib29sZWFufSBbdXBkYXRlPWZhbHNlXSDmmK/lkKblnKjov5Tlm57liY3mm7TmlrDor6XmlbDnu4RcbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUlnbm9yZT1mYWxzZV0g5piv5ZCm5YyF5ZCrIGlnbm9yZSDnmoTmlbDnu4QsIOWcqCB1cGRhdGUg5Li6IHRydWUg55qE5pe25YCZ5pyJ5pWIXG4gICAqXG4gICAqIOivpuingXtAbGluayBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5TGlzdH1cbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGU+fVxuICAgKi9cbiAgZ2V0RGlzcGxheUxpc3Q6IGZ1bmN0aW9uICh1cGRhdGUsIGluY2x1ZGVJZ25vcmUpIHtcbiAgICBpbmNsdWRlSWdub3JlID0gaW5jbHVkZUlnbm9yZSB8fCBmYWxzZTtcblxuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlRGlzcGxheUxpc3QoaW5jbHVkZUlnbm9yZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2Rpc3BsYXlMaXN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiDmm7TmlrDlm77lvaLnmoTnu5jliLbpmJ/liJfjgIJcbiAgICog5q+P5qyh57uY5Yi25YmN6YO95Lya6LCD55So77yM6K+l5pa55rOV5Lya5YWI5rex5bqm5LyY5YWI6YGN5Y6G5pW05Liq5qCR77yM5pu05paw5omA5pyJR3JvdXDlkoxTaGFwZeeahOWPmOaNouW5tuS4lOaKiuaJgOacieWPr+ingeeahFNoYXBl5L+d5a2Y5Yiw5pWw57uE5Lit77yMXG4gICAqIOacgOWQjuagueaNrue7mOWItueahOS8mOWFiOe6p++8iHpsZXZlbCA+IHogPiDmj5LlhaXpobrluo/vvInmjpLluo/lvpfliLDnu5jliLbpmJ/liJdcbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUlnbm9yZT1mYWxzZV0g5piv5ZCm5YyF5ZCrIGlnbm9yZSDnmoTmlbDnu4RcbiAgICovXG4gIHVwZGF0ZURpc3BsYXlMaXN0OiBmdW5jdGlvbiAoaW5jbHVkZUlnbm9yZSkge1xuICAgIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcbiAgICB2YXIgcm9vdHMgPSB0aGlzLl9yb290cztcbiAgICB2YXIgZGlzcGxheUxpc3QgPSB0aGlzLl9kaXNwbGF5TGlzdDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByb290cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGhpcy5fdXBkYXRlQW5kQWRkRGlzcGxheWFibGUocm9vdHNbaV0sIG51bGwsIGluY2x1ZGVJZ25vcmUpO1xuICAgIH1cblxuICAgIGRpc3BsYXlMaXN0Lmxlbmd0aCA9IHRoaXMuX2Rpc3BsYXlMaXN0TGVuOyAvLyBmb3IgKHZhciBpID0gMCwgbGVuID0gZGlzcGxheUxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAvLyAgICAgZGlzcGxheUxpc3RbaV0uX19yZW5kZXJpZHggPSBpO1xuICAgIC8vIH1cbiAgICAvLyBkaXNwbGF5TGlzdC5zb3J0KHNoYXBlQ29tcGFyZUZ1bmMpO1xuXG4gICAgZW52LmNhbnZhc1N1cHBvcnRlZCAmJiB0aW1zb3J0KGRpc3BsYXlMaXN0LCBzaGFwZUNvbXBhcmVGdW5jKTtcbiAgfSxcbiAgX3VwZGF0ZUFuZEFkZERpc3BsYXlhYmxlOiBmdW5jdGlvbiAoZWwsIGNsaXBQYXRocywgaW5jbHVkZUlnbm9yZSkge1xuICAgIGlmIChlbC5pZ25vcmUgJiYgIWluY2x1ZGVJZ25vcmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbC5iZWZvcmVVcGRhdGUoKTtcblxuICAgIGlmIChlbC5fX2RpcnR5KSB7XG4gICAgICBlbC51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBlbC5hZnRlclVwZGF0ZSgpO1xuICAgIHZhciB1c2VyU2V0Q2xpcFBhdGggPSBlbC5jbGlwUGF0aDtcblxuICAgIGlmICh1c2VyU2V0Q2xpcFBhdGgpIHtcbiAgICAgIC8vIEZJWE1FIOaViOeOh+W9seWTjVxuICAgICAgaWYgKGNsaXBQYXRocykge1xuICAgICAgICBjbGlwUGF0aHMgPSBjbGlwUGF0aHMuc2xpY2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsaXBQYXRocyA9IFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VycmVudENsaXBQYXRoID0gdXNlclNldENsaXBQYXRoO1xuICAgICAgdmFyIHBhcmVudENsaXBQYXRoID0gZWw7IC8vIFJlY3Vyc2l2ZWx5IGFkZCBjbGlwIHBhdGhcblxuICAgICAgd2hpbGUgKGN1cnJlbnRDbGlwUGF0aCkge1xuICAgICAgICAvLyBjbGlwUGF0aCDnmoTlj5jmjaLmmK/ln7rkuo7kvb/nlKjov5nkuKogY2xpcFBhdGgg55qE5YWD57SgXG4gICAgICAgIGN1cnJlbnRDbGlwUGF0aC5wYXJlbnQgPSBwYXJlbnRDbGlwUGF0aDtcbiAgICAgICAgY3VycmVudENsaXBQYXRoLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICBjbGlwUGF0aHMucHVzaChjdXJyZW50Q2xpcFBhdGgpO1xuICAgICAgICBwYXJlbnRDbGlwUGF0aCA9IGN1cnJlbnRDbGlwUGF0aDtcbiAgICAgICAgY3VycmVudENsaXBQYXRoID0gY3VycmVudENsaXBQYXRoLmNsaXBQYXRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbC5pc0dyb3VwKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBlbC5fY2hpbGRyZW47XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07IC8vIEZvcmNlIHRvIG1hcmsgYXMgZGlydHkgaWYgZ3JvdXAgaXMgZGlydHlcbiAgICAgICAgLy8gRklYTUUgX19kaXJ0eVBhdGggP1xuXG4gICAgICAgIGlmIChlbC5fX2RpcnR5KSB7XG4gICAgICAgICAgY2hpbGQuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVBbmRBZGREaXNwbGF5YWJsZShjaGlsZCwgY2xpcFBhdGhzLCBpbmNsdWRlSWdub3JlKTtcbiAgICAgIH0gLy8gTWFyayBncm91cCBjbGVhbiBoZXJlXG5cblxuICAgICAgZWwuX19kaXJ0eSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5fX2NsaXBQYXRocyA9IGNsaXBQYXRocztcbiAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0W3RoaXMuX2Rpc3BsYXlMaXN0TGVuKytdID0gZWw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqDlm77lvaIoU2hhcGUp5oiW6ICF57uEKEdyb3VwKeWIsOagueiKgueCuVxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAqL1xuICBhZGRSb290OiBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoZWwuX19zdG9yYWdlID09PSB0aGlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgIGVsLmFkZENoaWxkcmVuVG9TdG9yYWdlKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMuYWRkVG9TdG9yYWdlKGVsKTtcblxuICAgIHRoaXMuX3Jvb3RzLnB1c2goZWwpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDliKDpmaTmjIflrprnmoTlm77lvaIoU2hhcGUp5oiW6ICF57uEKEdyb3VwKVxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gW2VsXSDlpoLmnpzkuLrnqbrmuIXnqbrmlbTkuKpTdG9yYWdlXG4gICAqL1xuICBkZWxSb290OiBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoZWwgPT0gbnVsbCkge1xuICAgICAgLy8g5LiN5oyH5a6aZWzmuIXnqbpcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLl9yb290c1tpXTtcblxuICAgICAgICBpZiAocm9vdCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgcm9vdC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Jvb3RzID0gW107XG4gICAgICB0aGlzLl9kaXNwbGF5TGlzdCA9IFtdO1xuICAgICAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmRlbFJvb3QoZWxbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGlkeCA9IHV0aWwuaW5kZXhPZih0aGlzLl9yb290cywgZWwpO1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICB0aGlzLmRlbEZyb21TdG9yYWdlKGVsKTtcblxuICAgICAgdGhpcy5fcm9vdHMuc3BsaWNlKGlkeCwgMSk7XG5cbiAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgIGVsLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2UodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBhZGRUb1N0b3JhZ2U6IGZ1bmN0aW9uIChlbCkge1xuICAgIGVsLl9fc3RvcmFnZSA9IHRoaXM7XG4gICAgZWwuZGlydHkoZmFsc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBkZWxGcm9tU3RvcmFnZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5fX3N0b3JhZ2UgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmuIXnqbrlubbkuJTph4rmlL5TdG9yYWdlXG4gICAqL1xuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVuZGVyTGlzdCA9IHRoaXMuX3Jvb3RzID0gbnVsbDtcbiAgfSxcbiAgZGlzcGxheWFibGVTb3J0RnVuYzogc2hhcGVDb21wYXJlRnVuY1xufTtcbnZhciBfZGVmYXVsdCA9IFN0b3JhZ2U7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9TdG9yYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbXppY2NhcmQvbm9kZS10aW1zb3J0XG52YXIgREVGQVVMVF9NSU5fTUVSR0UgPSAzMjtcbnZhciBERUZBVUxUX01JTl9HQUxMT1BJTkcgPSA3O1xudmFyIERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIID0gMjU2O1xuXG5mdW5jdGlvbiBtaW5SdW5MZW5ndGgobikge1xuICB2YXIgciA9IDA7XG5cbiAgd2hpbGUgKG4gPj0gREVGQVVMVF9NSU5fTUVSR0UpIHtcbiAgICByIHw9IG4gJiAxO1xuICAgIG4gPj49IDE7XG4gIH1cblxuICByZXR1cm4gbiArIHI7XG59XG5cbmZ1bmN0aW9uIG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSkge1xuICB2YXIgcnVuSGkgPSBsbyArIDE7XG5cbiAgaWYgKHJ1bkhpID09PSBoaSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgaWYgKGNvbXBhcmUoYXJyYXlbcnVuSGkrK10sIGFycmF5W2xvXSkgPCAwKSB7XG4gICAgd2hpbGUgKHJ1bkhpIDwgaGkgJiYgY29tcGFyZShhcnJheVtydW5IaV0sIGFycmF5W3J1bkhpIC0gMV0pIDwgMCkge1xuICAgICAgcnVuSGkrKztcbiAgICB9XG5cbiAgICByZXZlcnNlUnVuKGFycmF5LCBsbywgcnVuSGkpO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChydW5IaSA8IGhpICYmIGNvbXBhcmUoYXJyYXlbcnVuSGldLCBhcnJheVtydW5IaSAtIDFdKSA+PSAwKSB7XG4gICAgICBydW5IaSsrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBydW5IaSAtIGxvO1xufVxuXG5mdW5jdGlvbiByZXZlcnNlUnVuKGFycmF5LCBsbywgaGkpIHtcbiAgaGktLTtcblxuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIHZhciB0ID0gYXJyYXlbbG9dO1xuICAgIGFycmF5W2xvKytdID0gYXJyYXlbaGldO1xuICAgIGFycmF5W2hpLS1dID0gdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgaGksIHN0YXJ0LCBjb21wYXJlKSB7XG4gIGlmIChzdGFydCA9PT0gbG8pIHtcbiAgICBzdGFydCsrO1xuICB9XG5cbiAgZm9yICg7IHN0YXJ0IDwgaGk7IHN0YXJ0KyspIHtcbiAgICB2YXIgcGl2b3QgPSBhcnJheVtzdGFydF07XG4gICAgdmFyIGxlZnQgPSBsbztcbiAgICB2YXIgcmlnaHQgPSBzdGFydDtcbiAgICB2YXIgbWlkO1xuXG4gICAgd2hpbGUgKGxlZnQgPCByaWdodCkge1xuICAgICAgbWlkID0gbGVmdCArIHJpZ2h0ID4+PiAxO1xuXG4gICAgICBpZiAoY29tcGFyZShwaXZvdCwgYXJyYXlbbWlkXSkgPCAwKSB7XG4gICAgICAgIHJpZ2h0ID0gbWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCA9IG1pZCArIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG4gPSBzdGFydCAtIGxlZnQ7XG5cbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgYXJyYXlbbGVmdCArIDNdID0gYXJyYXlbbGVmdCArIDJdO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIGFycmF5W2xlZnQgKyAyXSA9IGFycmF5W2xlZnQgKyAxXTtcblxuICAgICAgY2FzZSAxOlxuICAgICAgICBhcnJheVtsZWZ0ICsgMV0gPSBhcnJheVtsZWZ0XTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAgIGFycmF5W2xlZnQgKyBuXSA9IGFycmF5W2xlZnQgKyBuIC0gMV07XG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBhcnJheVtsZWZ0XSA9IHBpdm90O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdhbGxvcExlZnQodmFsdWUsIGFycmF5LCBzdGFydCwgbGVuZ3RoLCBoaW50LCBjb21wYXJlKSB7XG4gIHZhciBsYXN0T2Zmc2V0ID0gMDtcbiAgdmFyIG1heE9mZnNldCA9IDA7XG4gIHZhciBvZmZzZXQgPSAxO1xuXG4gIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnRdKSA+IDApIHtcbiAgICBtYXhPZmZzZXQgPSBsZW5ndGggLSBoaW50O1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgKyBvZmZzZXRdKSA+IDApIHtcbiAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgfVxuXG4gICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgIG9mZnNldCArPSBoaW50O1xuICB9IGVsc2Uge1xuICAgIG1heE9mZnNldCA9IGhpbnQgKyAxO1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgLSBvZmZzZXRdKSA8PSAwKSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgIH1cblxuICAgIHZhciB0bXAgPSBsYXN0T2Zmc2V0O1xuICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGhpbnQgLSB0bXA7XG4gIH1cblxuICBsYXN0T2Zmc2V0Kys7XG5cbiAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICB2YXIgbSA9IGxhc3RPZmZzZXQgKyAob2Zmc2V0IC0gbGFzdE9mZnNldCA+Pj4gMSk7XG5cbiAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBtXSkgPiAwKSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gbSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCA9IG07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gZ2FsbG9wUmlnaHQodmFsdWUsIGFycmF5LCBzdGFydCwgbGVuZ3RoLCBoaW50LCBjb21wYXJlKSB7XG4gIHZhciBsYXN0T2Zmc2V0ID0gMDtcbiAgdmFyIG1heE9mZnNldCA9IDA7XG4gIHZhciBvZmZzZXQgPSAxO1xuXG4gIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnRdKSA8IDApIHtcbiAgICBtYXhPZmZzZXQgPSBoaW50ICsgMTtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50IC0gb2Zmc2V0XSkgPCAwKSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgIH1cblxuICAgIHZhciB0bXAgPSBsYXN0T2Zmc2V0O1xuICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGhpbnQgLSB0bXA7XG4gIH0gZWxzZSB7XG4gICAgbWF4T2Zmc2V0ID0gbGVuZ3RoIC0gaGludDtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50ICsgb2Zmc2V0XSkgPj0gMCkge1xuICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICB9XG5cbiAgICBsYXN0T2Zmc2V0ICs9IGhpbnQ7XG4gICAgb2Zmc2V0ICs9IGhpbnQ7XG4gIH1cblxuICBsYXN0T2Zmc2V0Kys7XG5cbiAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICB2YXIgbSA9IGxhc3RPZmZzZXQgKyAob2Zmc2V0IC0gbGFzdE9mZnNldCA+Pj4gMSk7XG5cbiAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBtXSkgPCAwKSB7XG4gICAgICBvZmZzZXQgPSBtO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gbSArIDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gVGltU29ydChhcnJheSwgY29tcGFyZSkge1xuICB2YXIgbWluR2FsbG9wID0gREVGQVVMVF9NSU5fR0FMTE9QSU5HO1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIHRtcFN0b3JhZ2VMZW5ndGggPSBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSDtcbiAgdmFyIHN0YWNrTGVuZ3RoID0gMDtcbiAgdmFyIHJ1blN0YXJ0O1xuICB2YXIgcnVuTGVuZ3RoO1xuICB2YXIgc3RhY2tTaXplID0gMDtcbiAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPCAyICogREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEgpIHtcbiAgICB0bXBTdG9yYWdlTGVuZ3RoID0gbGVuZ3RoID4+PiAxO1xuICB9XG5cbiAgdmFyIHRtcCA9IFtdO1xuICBzdGFja0xlbmd0aCA9IGxlbmd0aCA8IDEyMCA/IDUgOiBsZW5ndGggPCAxNTQyID8gMTAgOiBsZW5ndGggPCAxMTkxNTEgPyAxOSA6IDQwO1xuICBydW5TdGFydCA9IFtdO1xuICBydW5MZW5ndGggPSBbXTtcblxuICBmdW5jdGlvbiBwdXNoUnVuKF9ydW5TdGFydCwgX3J1bkxlbmd0aCkge1xuICAgIHJ1blN0YXJ0W3N0YWNrU2l6ZV0gPSBfcnVuU3RhcnQ7XG4gICAgcnVuTGVuZ3RoW3N0YWNrU2l6ZV0gPSBfcnVuTGVuZ3RoO1xuICAgIHN0YWNrU2l6ZSArPSAxO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VSdW5zKCkge1xuICAgIHdoaWxlIChzdGFja1NpemUgPiAxKSB7XG4gICAgICB2YXIgbiA9IHN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgIGlmIChuID49IDEgJiYgcnVuTGVuZ3RoW24gLSAxXSA8PSBydW5MZW5ndGhbbl0gKyBydW5MZW5ndGhbbiArIDFdIHx8IG4gPj0gMiAmJiBydW5MZW5ndGhbbiAtIDJdIDw9IHJ1bkxlbmd0aFtuXSArIHJ1bkxlbmd0aFtuIC0gMV0pIHtcbiAgICAgICAgaWYgKHJ1bkxlbmd0aFtuIC0gMV0gPCBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJ1bkxlbmd0aFtuXSA+IHJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG1lcmdlQXQobik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZm9yY2VNZXJnZVJ1bnMoKSB7XG4gICAgd2hpbGUgKHN0YWNrU2l6ZSA+IDEpIHtcbiAgICAgIHZhciBuID0gc3RhY2tTaXplIC0gMjtcblxuICAgICAgaWYgKG4gPiAwICYmIHJ1bkxlbmd0aFtuIC0gMV0gPCBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgIG4tLTtcbiAgICAgIH1cblxuICAgICAgbWVyZ2VBdChuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUF0KGkpIHtcbiAgICB2YXIgc3RhcnQxID0gcnVuU3RhcnRbaV07XG4gICAgdmFyIGxlbmd0aDEgPSBydW5MZW5ndGhbaV07XG4gICAgdmFyIHN0YXJ0MiA9IHJ1blN0YXJ0W2kgKyAxXTtcbiAgICB2YXIgbGVuZ3RoMiA9IHJ1bkxlbmd0aFtpICsgMV07XG4gICAgcnVuTGVuZ3RoW2ldID0gbGVuZ3RoMSArIGxlbmd0aDI7XG5cbiAgICBpZiAoaSA9PT0gc3RhY2tTaXplIC0gMykge1xuICAgICAgcnVuU3RhcnRbaSArIDFdID0gcnVuU3RhcnRbaSArIDJdO1xuICAgICAgcnVuTGVuZ3RoW2kgKyAxXSA9IHJ1bkxlbmd0aFtpICsgMl07XG4gICAgfVxuXG4gICAgc3RhY2tTaXplLS07XG4gICAgdmFyIGsgPSBnYWxsb3BSaWdodChhcnJheVtzdGFydDJdLCBhcnJheSwgc3RhcnQxLCBsZW5ndGgxLCAwLCBjb21wYXJlKTtcbiAgICBzdGFydDEgKz0gaztcbiAgICBsZW5ndGgxIC09IGs7XG5cbiAgICBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxlbmd0aDIgPSBnYWxsb3BMZWZ0KGFycmF5W3N0YXJ0MSArIGxlbmd0aDEgLSAxXSwgYXJyYXksIHN0YXJ0MiwgbGVuZ3RoMiwgbGVuZ3RoMiAtIDEsIGNvbXBhcmUpO1xuXG4gICAgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoMSA8PSBsZW5ndGgyKSB7XG4gICAgICBtZXJnZUxvdyhzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlSGlnaChzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VMb3coc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpIHtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICB0bXBbaV0gPSBhcnJheVtzdGFydDEgKyBpXTtcbiAgICB9XG5cbiAgICB2YXIgY3Vyc29yMSA9IDA7XG4gICAgdmFyIGN1cnNvcjIgPSBzdGFydDI7XG4gICAgdmFyIGRlc3QgPSBzdGFydDE7XG4gICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG5cbiAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoMSA9PT0gMSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICB9XG5cbiAgICAgIGFycmF5W2Rlc3QgKyBsZW5ndGgyXSA9IHRtcFtjdXJzb3IxXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX21pbkdhbGxvcCA9IG1pbkdhbGxvcDtcbiAgICB2YXIgY291bnQxLCBjb3VudDIsIGV4aXQ7XG5cbiAgICB3aGlsZSAoMSkge1xuICAgICAgY291bnQxID0gMDtcbiAgICAgIGNvdW50MiA9IDA7XG4gICAgICBleGl0ID0gZmFsc2U7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyYXlbY3Vyc29yMl0sIHRtcFtjdXJzb3IxXSkgPCAwKSB7XG4gICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG4gICAgICAgICAgY291bnQyKys7XG4gICAgICAgICAgY291bnQxID0gMDtcblxuICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSB0bXBbY3Vyc29yMSsrXTtcbiAgICAgICAgICBjb3VudDErKztcbiAgICAgICAgICBjb3VudDIgPSAwO1xuXG4gICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKChjb3VudDEgfCBjb3VudDIpIDwgX21pbkdhbGxvcCk7XG5cbiAgICAgIGlmIChleGl0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkbyB7XG4gICAgICAgIGNvdW50MSA9IGdhbGxvcFJpZ2h0KGFycmF5W2N1cnNvcjJdLCB0bXAsIGN1cnNvcjEsIGxlbmd0aDEsIDAsIGNvbXBhcmUpO1xuXG4gICAgICAgIGlmIChjb3VudDEgIT09IDApIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQxOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVzdCArPSBjb3VudDE7XG4gICAgICAgICAgY3Vyc29yMSArPSBjb3VudDE7XG4gICAgICAgICAgbGVuZ3RoMSAtPSBjb3VudDE7XG5cbiAgICAgICAgICBpZiAobGVuZ3RoMSA8PSAxKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuXG4gICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvdW50MiA9IGdhbGxvcExlZnQodG1wW2N1cnNvcjFdLCBhcnJheSwgY3Vyc29yMiwgbGVuZ3RoMiwgMCwgY29tcGFyZSk7XG5cbiAgICAgICAgaWYgKGNvdW50MiAhPT0gMCkge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDI7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlc3QgKz0gY291bnQyO1xuICAgICAgICAgIGN1cnNvcjIgKz0gY291bnQyO1xuICAgICAgICAgIGxlbmd0aDIgLT0gY291bnQyO1xuXG4gICAgICAgICAgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlbZGVzdCsrXSA9IHRtcFtjdXJzb3IxKytdO1xuXG4gICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIF9taW5HYWxsb3AtLTtcbiAgICAgIH0gd2hpbGUgKGNvdW50MSA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcgfHwgY291bnQyID49IERFRkFVTFRfTUlOX0dBTExPUElORyk7XG5cbiAgICAgIGlmIChleGl0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoX21pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgX21pbkdhbGxvcCA9IDA7XG4gICAgICB9XG5cbiAgICAgIF9taW5HYWxsb3AgKz0gMjtcbiAgICB9XG5cbiAgICBtaW5HYWxsb3AgPSBfbWluR2FsbG9wO1xuICAgIG1pbkdhbGxvcCA8IDEgJiYgKG1pbkdhbGxvcCA9IDEpO1xuXG4gICAgaWYgKGxlbmd0aDEgPT09IDEpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgfVxuXG4gICAgICBhcnJheVtkZXN0ICsgbGVuZ3RoMl0gPSB0bXBbY3Vyc29yMV07XG4gICAgfSBlbHNlIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTsgLy8gdGhyb3cgbmV3IEVycm9yKCdtZXJnZUxvdyBwcmVjb25kaXRpb25zIHdlcmUgbm90IHJlc3BlY3RlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VIaWdoKHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKSB7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgdG1wW2ldID0gYXJyYXlbc3RhcnQyICsgaV07XG4gICAgfVxuXG4gICAgdmFyIGN1cnNvcjEgPSBzdGFydDEgKyBsZW5ndGgxIC0gMTtcbiAgICB2YXIgY3Vyc29yMiA9IGxlbmd0aDIgLSAxO1xuICAgIHZhciBkZXN0ID0gc3RhcnQyICsgbGVuZ3RoMiAtIDE7XG4gICAgdmFyIGN1c3RvbUN1cnNvciA9IDA7XG4gICAgdmFyIGN1c3RvbURlc3QgPSAwO1xuICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuXG4gICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV0gPSB0bXBbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoMiA9PT0gMSkge1xuICAgICAgZGVzdCAtPSBsZW5ndGgxO1xuICAgICAgY3Vyc29yMSAtPSBsZW5ndGgxO1xuICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgIGZvciAoaSA9IGxlbmd0aDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgIH1cblxuICAgICAgYXJyYXlbZGVzdF0gPSB0bXBbY3Vyc29yMl07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9taW5HYWxsb3AgPSBtaW5HYWxsb3A7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIGNvdW50MSA9IDA7XG4gICAgICB2YXIgY291bnQyID0gMDtcbiAgICAgIHZhciBleGl0ID0gZmFsc2U7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGNvbXBhcmUodG1wW2N1cnNvcjJdLCBhcnJheVtjdXJzb3IxXSkgPCAwKSB7XG4gICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG4gICAgICAgICAgY291bnQxKys7XG4gICAgICAgICAgY291bnQyID0gMDtcblxuICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSB0bXBbY3Vyc29yMi0tXTtcbiAgICAgICAgICBjb3VudDIrKztcbiAgICAgICAgICBjb3VudDEgPSAwO1xuXG4gICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKChjb3VudDEgfCBjb3VudDIpIDwgX21pbkdhbGxvcCk7XG5cbiAgICAgIGlmIChleGl0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkbyB7XG4gICAgICAgIGNvdW50MSA9IGxlbmd0aDEgLSBnYWxsb3BSaWdodCh0bXBbY3Vyc29yMl0sIGFycmF5LCBzdGFydDEsIGxlbmd0aDEsIGxlbmd0aDEgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICBpZiAoY291bnQxICE9PSAwKSB7XG4gICAgICAgICAgZGVzdCAtPSBjb3VudDE7XG4gICAgICAgICAgY3Vyc29yMSAtPSBjb3VudDE7XG4gICAgICAgICAgbGVuZ3RoMSAtPSBjb3VudDE7XG4gICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjEgKyAxO1xuXG4gICAgICAgICAgZm9yIChpID0gY291bnQxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5W2Rlc3QtLV0gPSB0bXBbY3Vyc29yMi0tXTtcblxuICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjb3VudDIgPSBsZW5ndGgyIC0gZ2FsbG9wTGVmdChhcnJheVtjdXJzb3IxXSwgdG1wLCAwLCBsZW5ndGgyLCBsZW5ndGgyIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgaWYgKGNvdW50MiAhPT0gMCkge1xuICAgICAgICAgIGRlc3QgLT0gY291bnQyO1xuICAgICAgICAgIGN1cnNvcjIgLT0gY291bnQyO1xuICAgICAgICAgIGxlbmd0aDIgLT0gY291bnQyO1xuICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IyICsgMTtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDI7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gdG1wW2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsZW5ndGgyIDw9IDEpIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG5cbiAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgX21pbkdhbGxvcC0tO1xuICAgICAgfSB3aGlsZSAoY291bnQxID49IERFRkFVTFRfTUlOX0dBTExPUElORyB8fCBjb3VudDIgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HKTtcblxuICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChfbWluR2FsbG9wIDwgMCkge1xuICAgICAgICBfbWluR2FsbG9wID0gMDtcbiAgICAgIH1cblxuICAgICAgX21pbkdhbGxvcCArPSAyO1xuICAgIH1cblxuICAgIG1pbkdhbGxvcCA9IF9taW5HYWxsb3A7XG5cbiAgICBpZiAobWluR2FsbG9wIDwgMSkge1xuICAgICAgbWluR2FsbG9wID0gMTtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoMiA9PT0gMSkge1xuICAgICAgZGVzdCAtPSBsZW5ndGgxO1xuICAgICAgY3Vyc29yMSAtPSBsZW5ndGgxO1xuICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgIGZvciAoaSA9IGxlbmd0aDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgIH1cblxuICAgICAgYXJyYXlbZGVzdF0gPSB0bXBbY3Vyc29yMl07XG4gICAgfSBlbHNlIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTsgLy8gdGhyb3cgbmV3IEVycm9yKCdtZXJnZUhpZ2ggcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV0gPSB0bXBbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5tZXJnZVJ1bnMgPSBtZXJnZVJ1bnM7XG4gIHRoaXMuZm9yY2VNZXJnZVJ1bnMgPSBmb3JjZU1lcmdlUnVucztcbiAgdGhpcy5wdXNoUnVuID0gcHVzaFJ1bjtcbn1cblxuZnVuY3Rpb24gc29ydChhcnJheSwgY29tcGFyZSwgbG8sIGhpKSB7XG4gIGlmICghbG8pIHtcbiAgICBsbyA9IDA7XG4gIH1cblxuICBpZiAoIWhpKSB7XG4gICAgaGkgPSBhcnJheS5sZW5ndGg7XG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gaGkgLSBsbztcblxuICBpZiAocmVtYWluaW5nIDwgMikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBydW5MZW5ndGggPSAwO1xuXG4gIGlmIChyZW1haW5pbmcgPCBERUZBVUxUX01JTl9NRVJHRSkge1xuICAgIHJ1bkxlbmd0aCA9IG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSk7XG4gICAgYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGhpLCBsbyArIHJ1bkxlbmd0aCwgY29tcGFyZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRzID0gbmV3IFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpO1xuICB2YXIgbWluUnVuID0gbWluUnVuTGVuZ3RoKHJlbWFpbmluZyk7XG5cbiAgZG8ge1xuICAgIHJ1bkxlbmd0aCA9IG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSk7XG5cbiAgICBpZiAocnVuTGVuZ3RoIDwgbWluUnVuKSB7XG4gICAgICB2YXIgZm9yY2UgPSByZW1haW5pbmc7XG5cbiAgICAgIGlmIChmb3JjZSA+IG1pblJ1bikge1xuICAgICAgICBmb3JjZSA9IG1pblJ1bjtcbiAgICAgIH1cblxuICAgICAgYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGxvICsgZm9yY2UsIGxvICsgcnVuTGVuZ3RoLCBjb21wYXJlKTtcbiAgICAgIHJ1bkxlbmd0aCA9IGZvcmNlO1xuICAgIH1cblxuICAgIHRzLnB1c2hSdW4obG8sIHJ1bkxlbmd0aCk7XG4gICAgdHMubWVyZ2VSdW5zKCk7XG4gICAgcmVtYWluaW5nIC09IHJ1bkxlbmd0aDtcbiAgICBsbyArPSBydW5MZW5ndGg7XG4gIH0gd2hpbGUgKHJlbWFpbmluZyAhPT0gMCk7XG5cbiAgdHMuZm9yY2VNZXJnZVJ1bnMoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzb3J0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL3RpbXNvcnQuanNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuXG52YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IF9jb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbnZhciBsb2cgPSByZXF1aXJlKFwiLi9jb3JlL2xvZ1wiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgdGltc29ydCA9IHJlcXVpcmUoXCIuL2NvcmUvdGltc29ydFwiKTtcblxudmFyIExheWVyID0gcmVxdWlyZShcIi4vTGF5ZXJcIik7XG5cbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1aXJlKFwiLi9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIpO1xuXG52YXIgSW1hZ2UgPSByZXF1aXJlKFwiLi9ncmFwaGljL0ltYWdlXCIpO1xuXG4vKipcbiAqIERlZmF1bHQgY2FudmFzIHBhaW50ZXJcbiAqIEBtb2R1bGUgenJlbmRlci9QYWludGVyXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqICAgICAgICAgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG4vLyBQRU5ESUdOXG4vLyBMYXllciBleGNlZWRzIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgbWF5IGhhdmUgc29tZSBwcm9ibGVtIHdoZW4gZmx1c2ggZGlyZWN0bHkgc2Vjb25kIHRpbWUuXG4vL1xuLy8gTWF4aW11bSBwcm9ncmVzc2l2ZSBsYXllci4gV2hlbiBleGNlZWRpbmcgdGhpcyBudW1iZXIuIEFsbCBlbGVtZW50cyB3aWxsIGJlIGRyYXdlZCBpbiB0aGUgbGFzdCBsYXllci5cbnZhciBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSID0gNTtcblxuZnVuY3Rpb24gcGFyc2VJbnQxMCh2YWwpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApO1xufVxuXG5mdW5jdGlvbiBpc0xheWVyVmFsaWQobGF5ZXIpIHtcbiAgaWYgKCFsYXllcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChsYXllci5fX2J1aWx0aW5fXykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBsYXllci5yZXNpemUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGxheWVyLnJlZnJlc2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcHJlUHJvY2Vzc0xheWVyKGxheWVyKSB7XG4gIGxheWVyLl9fdW51c2VkQ291bnQrKztcbn1cblxuZnVuY3Rpb24gcG9zdFByb2Nlc3NMYXllcihsYXllcikge1xuICBpZiAobGF5ZXIuX191bnVzZWRDb3VudCA9PSAxKSB7XG4gICAgbGF5ZXIuY2xlYXIoKTtcbiAgfVxufVxuXG52YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG52YXIgdmlld1JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuXG5mdW5jdGlvbiBpc0Rpc3BsYXlhYmxlQ3VsbGVkKGVsLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHRtcFJlY3QuY29weShlbC5nZXRCb3VuZGluZ1JlY3QoKSk7XG5cbiAgaWYgKGVsLnRyYW5zZm9ybSkge1xuICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0oZWwudHJhbnNmb3JtKTtcbiAgfVxuXG4gIHZpZXdSZWN0LndpZHRoID0gd2lkdGg7XG4gIHZpZXdSZWN0LmhlaWdodCA9IGhlaWdodDtcbiAgcmV0dXJuICF0bXBSZWN0LmludGVyc2VjdCh2aWV3UmVjdCk7XG59XG5cbmZ1bmN0aW9uIGlzQ2xpcFBhdGhDaGFuZ2VkKGNsaXBQYXRocywgcHJldkNsaXBQYXRocykge1xuICBpZiAoY2xpcFBhdGhzID09IHByZXZDbGlwUGF0aHMpIHtcbiAgICAvLyBDYW4gYm90aCBiZSBudWxsIG9yIHVuZGVmaW5lZFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghY2xpcFBhdGhzIHx8ICFwcmV2Q2xpcFBhdGhzIHx8IGNsaXBQYXRocy5sZW5ndGggIT09IHByZXZDbGlwUGF0aHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjbGlwUGF0aHNbaV0gIT09IHByZXZDbGlwUGF0aHNbaV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkb0NsaXAoY2xpcFBhdGhzLCBjdHgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2xpcFBhdGggPSBjbGlwUGF0aHNbaV07XG4gICAgY2xpcFBhdGguc2V0VHJhbnNmb3JtKGN0eCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGNsaXBQYXRoLmJ1aWxkUGF0aChjdHgsIGNsaXBQYXRoLnNoYXBlKTtcbiAgICBjdHguY2xpcCgpOyAvLyBUcmFuc2Zvcm0gYmFja1xuXG4gICAgY2xpcFBhdGgucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3Qod2lkdGgsIGhlaWdodCkge1xuICB2YXIgZG9tUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOyAvLyBkb21Sb290Lm9uc2VsZWN0c3RhcnQgPSByZXR1cm5GYWxzZTsgLy8g6YG/5YWN6aG16Z2i6YCJ5Lit55qE5bC05bCsXG5cbiAgZG9tUm9vdC5zdHlsZS5jc3NUZXh0ID0gWydwb3NpdGlvbjpyZWxhdGl2ZScsICdvdmVyZmxvdzpoaWRkZW4nLCAnd2lkdGg6JyArIHdpZHRoICsgJ3B4JywgJ2hlaWdodDonICsgaGVpZ2h0ICsgJ3B4JywgJ3BhZGRpbmc6MCcsICdtYXJnaW46MCcsICdib3JkZXItd2lkdGg6MCddLmpvaW4oJzsnKSArICc7JztcbiAgcmV0dXJuIGRvbVJvb3Q7XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9QYWludGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJvb3Qg57uY5Zu+5a655ZmoXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cblxuXG52YXIgUGFpbnRlciA9IGZ1bmN0aW9uIChyb290LCBzdG9yYWdlLCBvcHRzKSB7XG4gIHRoaXMudHlwZSA9ICdjYW52YXMnOyAvLyBJbiBub2RlIGVudmlyb25tZW50IHVzaW5nIG5vZGUtY2FudmFzXG5cbiAgdmFyIHNpbmdsZUNhbnZhcyA9ICFyb290Lm5vZGVOYW1lIC8vIEluIG5vZGUgP1xuICB8fCByb290Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdDQU5WQVMnO1xuICB0aGlzLl9vcHRzID0gb3B0cyA9IHV0aWwuZXh0ZW5kKHt9LCBvcHRzIHx8IHt9KTtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuZHByID0gb3B0cy5kZXZpY2VQaXhlbFJhdGlvIHx8IGRldmljZVBpeGVsUmF0aW87XG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fc2luZ2xlQ2FudmFzID0gc2luZ2xlQ2FudmFzO1xuICAvKipcbiAgICog57uY5Zu+5a655ZmoXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICovXG5cbiAgdGhpcy5yb290ID0gcm9vdDtcbiAgdmFyIHJvb3RTdHlsZSA9IHJvb3Quc3R5bGU7XG5cbiAgaWYgKHJvb3RTdHlsZSkge1xuICAgIHJvb3RTdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAndHJhbnNwYXJlbnQnO1xuICAgIHJvb3RTdHlsZVsnLXdlYmtpdC11c2VyLXNlbGVjdCddID0gcm9vdFN0eWxlWyd1c2VyLXNlbGVjdCddID0gcm9vdFN0eWxlWyctd2Via2l0LXRvdWNoLWNhbGxvdXQnXSA9ICdub25lJztcbiAgICByb290LmlubmVySFRNTCA9ICcnO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX1cbiAgICovXG5cblxuICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAvKipcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3QgPSBbXTtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnpyZW5kZXIvTGF5ZXI+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzID0ge307XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIE9iamVjdD59XG4gICAqIEB0eXBlIHtwcml2YXRlfVxuICAgKi9cblxuICB0aGlzLl9sYXllckNvbmZpZyA9IHt9O1xuXG4gIGlmICghc2luZ2xlQ2FudmFzKSB7XG4gICAgdGhpcy5fd2lkdGggPSB0aGlzLl9nZXRTaXplKDApO1xuICAgIHRoaXMuX2hlaWdodCA9IHRoaXMuX2dldFNpemUoMSk7XG4gICAgdmFyIGRvbVJvb3QgPSB0aGlzLl9kb21Sb290ID0gY3JlYXRlUm9vdCh0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICByb290LmFwcGVuZENoaWxkKGRvbVJvb3QpO1xuICB9IGVsc2Uge1xuICAgIGlmIChvcHRzLndpZHRoICE9IG51bGwpIHtcbiAgICAgIHJvb3Qud2lkdGggPSBvcHRzLndpZHRoO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICByb290LmhlaWdodCA9IG9wdHMuaGVpZ2h0O1xuICAgIH0gLy8gVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0IGRpcmVjdGx5XG5cblxuICAgIHZhciB3aWR0aCA9IHJvb3Qud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHJvb3QuaGVpZ2h0O1xuICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0OyAvLyBDcmVhdGUgbGF5ZXIgaWYgb25seSBvbmUgZ2l2ZW4gY2FudmFzXG4gICAgLy8gRGV2aWNlIHBpeGVsIHJhdGlvIGlzIGZpeGVkIHRvIDEgYmVjYXVzZSBnaXZlbiBjYW52YXMgaGFzIGl0cyBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodFxuXG4gICAgdmFyIG1haW5MYXllciA9IG5ldyBMYXllcihyb290LCB0aGlzLCAxKTtcbiAgICBtYWluTGF5ZXIuaW5pdENvbnRleHQoKTsgLy8gRklYTUUgVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgLy8gbWFpbkxheWVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGxheWVyc1swXSA9IG1haW5MYXllcjtcbiAgICB6bGV2ZWxMaXN0LnB1c2goMCk7XG4gICAgdGhpcy5fZG9tUm9vdCA9IHJvb3Q7XG4gIH0gLy8gTGF5ZXJzIGZvciBwcm9ncmVzc2l2ZSByZW5kZXJpbmdcblxuXG4gIHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzID0gW107XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvTGF5ZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2hvdmVybGF5ZXI7XG4gIHRoaXMuX2hvdmVyRWxlbWVudHMgPSBbXTtcbn07XG5cblBhaW50ZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUGFpbnRlcixcbiAgZ2V0VHlwZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnY2FudmFzJztcbiAgfSxcblxuICAvKipcbiAgICogSWYgcGFpbnRlciB1c2UgYSBzaW5nbGUgY2FudmFzXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc1NpbmdsZUNhbnZhczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zaW5nbGVDYW52YXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxEaXZFbGVtZW50fVxuICAgKi9cbiAgZ2V0Vmlld3BvcnRSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RvbVJvb3Q7XG4gIH0sXG4gIGdldFZpZXdwb3J0Um9vdE9mZnNldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciB2aWV3cG9ydFJvb3QgPSB0aGlzLmdldFZpZXdwb3J0Um9vdCgpO1xuXG4gICAgaWYgKHZpZXdwb3J0Um9vdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0TGVmdDogdmlld3BvcnRSb290Lm9mZnNldExlZnQgfHwgMCxcbiAgICAgICAgb2Zmc2V0VG9wOiB2aWV3cG9ydFJvb3Qub2Zmc2V0VG9wIHx8IDBcbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDliLfmlrBcbiAgICogQHBhcmFtIHtib29sZWFufSBbcGFpbnRBbGw9ZmFsc2VdIOW8uuWItue7mOWItuaJgOaciWRpc3BsYXlhYmxlXG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiAocGFpbnRBbGwpIHtcbiAgICB2YXIgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlKTtcbiAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG5cbiAgICB0aGlzLl9wYWludExpc3QobGlzdCwgcGFpbnRBbGwpOyAvLyBQYWludCBjdXN0dW0gbGF5ZXJzXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuXG4gICAgICBpZiAoIWxheWVyLl9fYnVpbHRpbl9fICYmIGxheWVyLnJlZnJlc2gpIHtcbiAgICAgICAgbGF5ZXIucmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG5cbiAgICBpZiAodGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9zdGFydFByb2dlc3NpdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkSG92ZXI6IGZ1bmN0aW9uIChlbCwgaG92ZXJTdHlsZSkge1xuICAgIGlmIChlbC5fX2hvdmVyTWlyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsTWlycm9yID0gbmV3IGVsLmNvbnN0cnVjdG9yKHtcbiAgICAgIHN0eWxlOiBlbC5zdHlsZSxcbiAgICAgIHNoYXBlOiBlbC5zaGFwZVxuICAgIH0pO1xuICAgIGVsTWlycm9yLl9fZnJvbSA9IGVsO1xuICAgIGVsLl9faG92ZXJNaXIgPSBlbE1pcnJvcjtcbiAgICBlbE1pcnJvci5zZXRTdHlsZShob3ZlclN0eWxlKTtcblxuICAgIHRoaXMuX2hvdmVyRWxlbWVudHMucHVzaChlbE1pcnJvcik7XG4gIH0sXG4gIHJlbW92ZUhvdmVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICB2YXIgZWxNaXJyb3IgPSBlbC5fX2hvdmVyTWlyO1xuICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcbiAgICB2YXIgaWR4ID0gdXRpbC5pbmRleE9mKGhvdmVyRWxlbWVudHMsIGVsTWlycm9yKTtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgaG92ZXJFbGVtZW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG5cbiAgICBlbC5fX2hvdmVyTWlyID0gbnVsbDtcbiAgfSxcbiAgY2xlYXJIb3ZlcjogZnVuY3Rpb24gKGVsKSB7XG4gICAgdmFyIGhvdmVyRWxlbWVudHMgPSB0aGlzLl9ob3ZlckVsZW1lbnRzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3ZlckVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZnJvbSA9IGhvdmVyRWxlbWVudHNbaV0uX19mcm9tO1xuXG4gICAgICBpZiAoZnJvbSkge1xuICAgICAgICBmcm9tLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhvdmVyRWxlbWVudHMubGVuZ3RoID0gMDtcbiAgfSxcbiAgcmVmcmVzaEhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhvdmVyRWxlbWVudHMgPSB0aGlzLl9ob3ZlckVsZW1lbnRzO1xuICAgIHZhciBsZW4gPSBob3ZlckVsZW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaG92ZXJMYXllciA9IHRoaXMuX2hvdmVybGF5ZXI7XG4gICAgaG92ZXJMYXllciAmJiBob3ZlckxheWVyLmNsZWFyKCk7XG5cbiAgICBpZiAoIWxlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRpbXNvcnQoaG92ZXJFbGVtZW50cywgdGhpcy5zdG9yYWdlLmRpc3BsYXlhYmxlU29ydEZ1bmMpOyAvLyBVc2UgYSBleHRyZWFtIGxhcmdlIHpsZXZlbFxuICAgIC8vIEZJWE1FP1xuXG4gICAgaWYgKCFob3ZlckxheWVyKSB7XG4gICAgICBob3ZlckxheWVyID0gdGhpcy5faG92ZXJsYXllciA9IHRoaXMuZ2V0TGF5ZXIoMWU1KTtcbiAgICB9XG5cbiAgICB2YXIgc2NvcGUgPSB7fTtcbiAgICBob3ZlckxheWVyLmN0eC5zYXZlKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgIHZhciBlbCA9IGhvdmVyRWxlbWVudHNbaV07XG4gICAgICB2YXIgb3JpZ2luYWxFbCA9IGVsLl9fZnJvbTsgLy8gT3JpZ2luYWwgZWwgaXMgcmVtb3ZlZFxuICAgICAgLy8gUEVORElOR1xuXG4gICAgICBpZiAoIShvcmlnaW5hbEVsICYmIG9yaWdpbmFsRWwuX196cikpIHtcbiAgICAgICAgaG92ZXJFbGVtZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIG9yaWdpbmFsRWwuX19ob3Zlck1pciA9IG51bGw7XG4gICAgICAgIGxlbi0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaSsrOyAvLyBVc2UgdHJhbnNmb3JtXG4gICAgICAvLyBGSVhNRSBzdHlsZSBhbmQgc2hhcGUgP1xuXG4gICAgICBpZiAoIW9yaWdpbmFsRWwuaW52aXNpYmxlKSB7XG4gICAgICAgIGVsLnRyYW5zZm9ybSA9IG9yaWdpbmFsRWwudHJhbnNmb3JtO1xuICAgICAgICBlbC5pbnZUcmFuc2Zvcm0gPSBvcmlnaW5hbEVsLmludlRyYW5zZm9ybTtcbiAgICAgICAgZWwuX19jbGlwUGF0aHMgPSBvcmlnaW5hbEVsLl9fY2xpcFBhdGhzOyAvLyBlbC5cblxuICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGhvdmVyTGF5ZXIsIHRydWUsIHNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBob3ZlckxheWVyLmN0eC5yZXN0b3JlKCk7XG4gIH0sXG4gIF9zdGFydFByb2dlc3NpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoIXNlbGYuX2Z1cnRoZXJQcm9ncmVzc2l2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVXNlIGEgdG9rZW4gdG8gc3RvcCBwcm9ncmVzcyBzdGVwcyB0cmlnZ2VyZWQgYnlcbiAgICAvLyBwcmV2aW91cyB6ci5yZWZyZXNoIGNhbGxpbmcuXG5cblxuICAgIHZhciB0b2tlbiA9IHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSArbmV3IERhdGUoKTtcbiAgICBzZWxmLl9wcm9ncmVzcysrO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcblxuICAgIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgICAvLyBJbiBjYXNlIHJlZnJlc2hlZCBvciBkaXNwb3NlZFxuICAgICAgaWYgKHRva2VuID09PSBzZWxmLl9wcm9ncmVzc2l2ZVRva2VuICYmIHNlbGYuc3RvcmFnZSkge1xuICAgICAgICBzZWxmLl9kb1BhaW50TGlzdChzZWxmLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKSk7XG5cbiAgICAgICAgaWYgKHNlbGYuX2Z1cnRoZXJQcm9ncmVzc2l2ZSkge1xuICAgICAgICAgIHNlbGYuX3Byb2dyZXNzKys7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2NsZWFyUHJvZ3Jlc3NpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZVRva2VuID0gLTE7XG4gICAgdGhpcy5fcHJvZ3Jlc3MgPSAwO1xuICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICBsYXllci5fX2RpcnR5ICYmIGxheWVyLmNsZWFyKCk7XG4gICAgfSk7XG4gIH0sXG4gIF9wYWludExpc3Q6IGZ1bmN0aW9uIChsaXN0LCBwYWludEFsbCkge1xuICAgIGlmIChwYWludEFsbCA9PSBudWxsKSB7XG4gICAgICBwYWludEFsbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUxheWVyU3RhdHVzKGxpc3QpO1xuXG4gICAgdGhpcy5fY2xlYXJQcm9ncmVzc2l2ZSgpO1xuXG4gICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKHByZVByb2Nlc3NMYXllcik7XG5cbiAgICB0aGlzLl9kb1BhaW50TGlzdChsaXN0LCBwYWludEFsbCk7XG5cbiAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIocG9zdFByb2Nlc3NMYXllcik7XG4gIH0sXG4gIF9kb1BhaW50TGlzdDogZnVuY3Rpb24gKGxpc3QsIHBhaW50QWxsKSB7XG4gICAgdmFyIGN1cnJlbnRMYXllcjtcbiAgICB2YXIgY3VycmVudFpMZXZlbDtcbiAgICB2YXIgY3R4OyAvLyB2YXIgaW52VHJhbnNmb3JtID0gW107XG5cbiAgICB2YXIgc2NvcGU7XG4gICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJJZHggPSAwO1xuICAgIHZhciBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcjtcbiAgICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgIHZhciBsYXllclByb2dyZXNzO1xuICAgIHZhciBmcmFtZSA9IHRoaXMuX3Byb2dyZXNzO1xuXG4gICAgZnVuY3Rpb24gZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGxheWVyKSB7XG4gICAgICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICBjdHguc2hhZG93Qmx1ciA9IDA7IC8vIEF2b2lkIGxheWVyIGRvbid0IGNsZWFyIGluIG5leHQgcHJvZ3Jlc3NpdmUgZnJhbWVcblxuICAgICAgY3VycmVudExheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UobGF5ZXIuZG9tLCAwLCAwLCB3aWR0aCAqIGRwciwgaGVpZ2h0ICogZHByKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgIHZhciBlbFpMZXZlbCA9IHRoaXMuX3NpbmdsZUNhbnZhcyA/IDAgOiBlbC56bGV2ZWw7XG4gICAgICB2YXIgZWxGcmFtZSA9IGVsLl9fZnJhbWU7IC8vIEZsdXNoIGF0IGN1cnJlbnQgY29udGV4dFxuICAgICAgLy8gUEVORElOR1xuXG4gICAgICBpZiAoZWxGcmFtZSA8IDAgJiYgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKTtcbiAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgfSAvLyBDaGFuZ2UgZHJhdyBsYXllclxuXG5cbiAgICAgIGlmIChjdXJyZW50WkxldmVsICE9PSBlbFpMZXZlbCkge1xuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfSAvLyBSZXNldCBzY29wZVxuXG5cbiAgICAgICAgc2NvcGUgPSB7fTsgLy8gT25seSAwIHpsZXZlbCBpZiBvbmx5IGhhcyBvbmUgY2FudmFzXG5cbiAgICAgICAgY3VycmVudFpMZXZlbCA9IGVsWkxldmVsO1xuICAgICAgICBjdXJyZW50TGF5ZXIgPSB0aGlzLmdldExheWVyKGN1cnJlbnRaTGV2ZWwpO1xuXG4gICAgICAgIGlmICghY3VycmVudExheWVyLl9fYnVpbHRpbl9fKSB7XG4gICAgICAgICAgbG9nKCdaTGV2ZWwgJyArIGN1cnJlbnRaTGV2ZWwgKyAnIGhhcyBiZWVuIHVzZWQgYnkgdW5rb3duIGxheWVyICcgKyBjdXJyZW50TGF5ZXIuaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4ID0gY3VycmVudExheWVyLmN0eDtcbiAgICAgICAgY3R4LnNhdmUoKTsgLy8gUmVzZXQgdGhlIGNvdW50XG5cbiAgICAgICAgY3VycmVudExheWVyLl9fdW51c2VkQ291bnQgPSAwO1xuXG4gICAgICAgIGlmIChjdXJyZW50TGF5ZXIuX19kaXJ0eSB8fCBwYWludEFsbCkge1xuICAgICAgICAgIGN1cnJlbnRMYXllci5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghKGN1cnJlbnRMYXllci5fX2RpcnR5IHx8IHBhaW50QWxsKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsRnJhbWUgPj0gMCkge1xuICAgICAgICAvLyBQcm9ncmVzc2l2ZSBsYXllciBjaGFuZ2VkXG4gICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzW01hdGgubWluKHByb2dyZXNzaXZlTGF5ZXJJZHgrKywgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiAtIDEpXTtcbiAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5jdHguc2F2ZSgpO1xuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLnJlbmRlclNjb3BlID0ge307XG5cbiAgICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgJiYgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19wcm9ncmVzcyA+IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIC8vIGZsdXNoUHJvZ3Jlc3NpdmVMYXllcihjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcik7XG4gICAgICAgICAgICAvLyBRdWljayBqdW1wIGFsbCBwcm9ncmVzc2l2ZSBlbGVtZW50c1xuICAgICAgICAgICAgLy8gQWxsIHByb2dyZXNzaXZlIGVsZW1lbnQgYXJlIG5vdCBkaXJ0eSwganVtcCBvdmVyIGFuZCBmbHVzaCBkaXJlY3RseVxuICAgICAgICAgICAgaSA9IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgLSAxOyAvLyBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IG51bGw7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxheWVyUHJvZ3Jlc3MgPSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzO1xuXG4gICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5KSB7XG4gICAgICAgICAgICAvLyBLZWVwIHJlbmRlcmluZ1xuICAgICAgICAgICAgZnJhbWUgPSBsYXllclByb2dyZXNzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3MgPSBmcmFtZSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxGcmFtZSA9PT0gZnJhbWUpIHtcbiAgICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLCB0cnVlLCBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5yZW5kZXJTY29wZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgY3VycmVudExheWVyLCBwYWludEFsbCwgc2NvcGUpO1xuICAgICAgfVxuXG4gICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICBmbHVzaFByb2dyZXNzaXZlTGF5ZXIoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpO1xuICAgIH0gLy8gUmVzdG9yZSB0aGUgbGFzdExheWVyIGN0eFxuXG5cbiAgICBjdHggJiYgY3R4LnJlc3RvcmUoKTsgLy8gSWYgc3RpbGwgaGFzIGNsaXBwaW5nIHN0YXRlXG4gICAgLy8gaWYgKHNjb3BlLnByZXZFbENsaXBQYXRocykge1xuICAgIC8vICAgICBjdHgucmVzdG9yZSgpO1xuICAgIC8vIH1cblxuICAgIHRoaXMuX2Z1cnRoZXJQcm9ncmVzc2l2ZSA9IGZhbHNlO1xuICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICBpZiAobGF5ZXIuX19tYXhQcm9ncmVzcyA+PSBsYXllci5fX3Byb2dyZXNzKSB7XG4gICAgICAgIHRoaXMuX2Z1cnRoZXJQcm9ncmVzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH0sXG4gIF9kb1BhaW50RWw6IGZ1bmN0aW9uIChlbCwgY3VycmVudExheWVyLCBmb3JjZVBhaW50LCBzY29wZSkge1xuICAgIHZhciBjdHggPSBjdXJyZW50TGF5ZXIuY3R4O1xuICAgIHZhciBtID0gZWwudHJhbnNmb3JtO1xuXG4gICAgaWYgKChjdXJyZW50TGF5ZXIuX19kaXJ0eSB8fCBmb3JjZVBhaW50KSAmJiAvLyBJZ25vcmUgaW52aXNpYmxlIGVsZW1lbnRcbiAgICAhZWwuaW52aXNpYmxlIC8vIElnbm9yZSB0cmFuc3BhcmVudCBlbGVtZW50XG4gICAgJiYgZWwuc3R5bGUub3BhY2l0eSAhPT0gMCAvLyBJZ25vcmUgc2NhbGUgMCBlbGVtZW50LCBpbiBzb21lIGVudmlyb25tZW50IGxpa2Ugbm9kZS1jYW52YXNcbiAgICAvLyBEcmF3IGEgc2NhbGUgMCBlbGVtZW50IGNhbiBjYXVzZSBhbGwgZm9sbG93aW5nIGRyYXcgd3JvbmdcbiAgICAvLyBBbmQgc2V0VHJhbnNmb3JtIHdpdGggc2NhbGUgMCB3aWxsIGNhdXNlIHNldCBiYWNrIHRyYW5zZm9ybSBmYWlsZWQuXG4gICAgJiYgIShtICYmICFtWzBdICYmICFtWzNdKSAvLyBJZ25vcmUgY3VsbGVkIGVsZW1lbnRcbiAgICAmJiAhKGVsLmN1bGxpbmcgJiYgaXNEaXNwbGF5YWJsZUN1bGxlZChlbCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCkpKSB7XG4gICAgICB2YXIgY2xpcFBhdGhzID0gZWwuX19jbGlwUGF0aHM7IC8vIE9wdGltaXplIHdoZW4gY2xpcHBpbmcgb24gZ3JvdXAgd2l0aCBzZXZlcmFsIGVsZW1lbnRzXG5cbiAgICAgIGlmIChzY29wZS5wcmV2Q2xpcExheWVyICE9PSBjdXJyZW50TGF5ZXIgfHwgaXNDbGlwUGF0aENoYW5nZWQoY2xpcFBhdGhzLCBzY29wZS5wcmV2RWxDbGlwUGF0aHMpKSB7XG4gICAgICAgIC8vIElmIGhhcyBwcmV2aW91cyBjbGlwcGluZyBzdGF0ZSwgcmVzdG9yZSBmcm9tIGl0XG4gICAgICAgIGlmIChzY29wZS5wcmV2RWxDbGlwUGF0aHMpIHtcbiAgICAgICAgICBzY29wZS5wcmV2Q2xpcExheWVyLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgc2NvcGUucHJldkNsaXBMYXllciA9IHNjb3BlLnByZXZFbENsaXBQYXRocyA9IG51bGw7IC8vIFJlc2V0IHByZXZFbCBzaW5jZSBjb250ZXh0IGhhcyBiZWVuIHJlc3RvcmVkXG5cbiAgICAgICAgICBzY29wZS5wcmV2RWwgPSBudWxsO1xuICAgICAgICB9IC8vIE5ldyBjbGlwcGluZyBzdGF0ZVxuXG5cbiAgICAgICAgaWYgKGNsaXBQYXRocykge1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgZG9DbGlwKGNsaXBQYXRocywgY3R4KTtcbiAgICAgICAgICBzY29wZS5wcmV2Q2xpcExheWVyID0gY3VycmVudExheWVyO1xuICAgICAgICAgIHNjb3BlLnByZXZFbENsaXBQYXRocyA9IGNsaXBQYXRocztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbC5iZWZvcmVCcnVzaCAmJiBlbC5iZWZvcmVCcnVzaChjdHgpO1xuICAgICAgZWwuYnJ1c2goY3R4LCBzY29wZS5wcmV2RWwgfHwgbnVsbCk7XG4gICAgICBzY29wZS5wcmV2RWwgPSBlbDtcbiAgICAgIGVsLmFmdGVyQnJ1c2ggJiYgZWwuYWZ0ZXJCcnVzaChjdHgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog6I635Y+WIHpsZXZlbCDmiYDlnKjlsYLvvIzlpoLmnpzkuI3lrZjlnKjliJnkvJrliJvlu7rkuIDkuKrmlrDnmoTlsYJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHpsZXZlbFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9MYXllcn1cbiAgICovXG4gIGdldExheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgaWYgKHRoaXMuX3NpbmdsZUNhbnZhcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1swXTtcbiAgICB9XG5cbiAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcblxuICAgIGlmICghbGF5ZXIpIHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBsYXllclxuICAgICAgbGF5ZXIgPSBuZXcgTGF5ZXIoJ3pyXycgKyB6bGV2ZWwsIHRoaXMsIHRoaXMuZHByKTtcbiAgICAgIGxheWVyLl9fYnVpbHRpbl9fID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMuX2xheWVyQ29uZmlnW3psZXZlbF0pIHtcbiAgICAgICAgdXRpbC5tZXJnZShsYXllciwgdGhpcy5fbGF5ZXJDb25maWdbemxldmVsXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5zZXJ0TGF5ZXIoemxldmVsLCBsYXllcik7IC8vIENvbnRleHQgaXMgY3JlYXRlZCBhZnRlciBkb20gaW5zZXJ0ZWQgdG8gZG9jdW1lbnRcbiAgICAgIC8vIE9yIGV4Y2FudmFzIHdpbGwgZ2V0IDBweCBjbGllbnRXaWR0aCBhbmQgY2xpZW50SGVpZ2h0XG5cbiAgICAgIGxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxheWVyO1xuICB9LFxuICBpbnNlcnRMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgbGF5ZXIpIHtcbiAgICB2YXIgbGF5ZXJzTWFwID0gdGhpcy5fbGF5ZXJzO1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgbGVuID0gemxldmVsTGlzdC5sZW5ndGg7XG4gICAgdmFyIHByZXZMYXllciA9IG51bGw7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3Q7XG5cbiAgICBpZiAobGF5ZXJzTWFwW3psZXZlbF0pIHtcbiAgICAgIGxvZygnWkxldmVsICcgKyB6bGV2ZWwgKyAnIGhhcyBiZWVuIHVzZWQgYWxyZWFkeScpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ2hlY2sgaWYgaXMgYSB2YWxpZCBsYXllclxuXG5cbiAgICBpZiAoIWlzTGF5ZXJWYWxpZChsYXllcikpIHtcbiAgICAgIGxvZygnTGF5ZXIgb2YgemxldmVsICcgKyB6bGV2ZWwgKyAnIGlzIG5vdCB2YWxpZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsZW4gPiAwICYmIHpsZXZlbCA+IHpsZXZlbExpc3RbMF0pIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKHpsZXZlbExpc3RbaV0gPCB6bGV2ZWwgJiYgemxldmVsTGlzdFtpICsgMV0gPiB6bGV2ZWwpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcmV2TGF5ZXIgPSBsYXllcnNNYXBbemxldmVsTGlzdFtpXV07XG4gICAgfVxuXG4gICAgemxldmVsTGlzdC5zcGxpY2UoaSArIDEsIDAsIHpsZXZlbCk7XG4gICAgbGF5ZXJzTWFwW3psZXZlbF0gPSBsYXllcjsgLy8gVml0dWFsIGxheWVyIHdpbGwgbm90IGRpcmVjdGx5IHNob3cgb24gdGhlIHNjcmVlbi5cbiAgICAvLyAoSXQgY2FuIGJlIGEgV2ViR0wgbGF5ZXIgYW5kIGFzc2lnbmVkIHRvIGEgWkltYWdlIGVsZW1lbnQpXG4gICAgLy8gQnV0IGl0IHN0aWxsIHVuZGVyIG1hbmFnZW1lbnQgb2YgenJlbmRlci5cblxuICAgIGlmICghbGF5ZXIudmlydHVhbCkge1xuICAgICAgaWYgKHByZXZMYXllcikge1xuICAgICAgICB2YXIgcHJldkRvbSA9IHByZXZMYXllci5kb207XG5cbiAgICAgICAgaWYgKHByZXZEb20ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICBkb21Sb290Lmluc2VydEJlZm9yZShsYXllci5kb20sIHByZXZEb20ubmV4dFNpYmxpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbVJvb3QuYXBwZW5kQ2hpbGQobGF5ZXIuZG9tKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRvbVJvb3QuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGRvbVJvb3QuaW5zZXJ0QmVmb3JlKGxheWVyLmRvbSwgZG9tUm9vdC5maXJzdENoaWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb21Sb290LmFwcGVuZENoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8vIEl0ZXJhdGUgZWFjaCBsYXllclxuICBlYWNoTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgejtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW3pdLCB6KTtcbiAgICB9XG4gIH0sXG4gIC8vIEl0ZXJhdGUgZWFjaCBidWlsZGluIGxheWVyXG4gIGVhY2hCdWlsdGluTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgbGF5ZXI7XG4gICAgdmFyIHo7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICBsYXllciA9IHRoaXMuX2xheWVyc1t6XTtcblxuICAgICAgaWYgKGxheWVyLl9fYnVpbHRpbl9fKSB7XG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgbGF5ZXIsIHopO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gSXRlcmF0ZSBlYWNoIG90aGVyIGxheWVyIGV4Y2VwdCBidWlsZGluIGxheWVyXG4gIGVhY2hPdGhlckxheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgdmFyIGxheWVyO1xuICAgIHZhciB6O1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG5cbiAgICAgIGlmICghbGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCBsYXllciwgeik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bmiYDmnInlt7LliJvlu7rnmoTlsYJcbiAgICogQHBhcmFtIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvTGF5ZXI+fSBbcHJldkxheWVyXVxuICAgKi9cbiAgZ2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xheWVycztcbiAgfSxcbiAgX3VwZGF0ZUxheWVyU3RhdHVzOiBmdW5jdGlvbiAobGlzdCkge1xuICAgIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJzID0gdGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnM7XG4gICAgdmFyIGVsQ291bnRzTGFzdEZyYW1lID0ge307XG4gICAgdmFyIHByb2dyZXNzaXZlRWxDb3VudHNMYXN0RnJhbWUgPSB7fTtcbiAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICBlbENvdW50c0xhc3RGcmFtZVt6XSA9IGxheWVyLmVsQ291bnQ7XG4gICAgICBsYXllci5lbENvdW50ID0gMDtcbiAgICAgIGxheWVyLl9fZGlydHkgPSBmYWxzZTtcbiAgICB9KTtcbiAgICB1dGlsLmVhY2gocHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllciwgaWR4KSB7XG4gICAgICBwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lW2lkeF0gPSBsYXllci5lbENvdW50O1xuICAgICAgbGF5ZXIuZWxDb3VudCA9IDA7XG4gICAgICBsYXllci5fX2RpcnR5ID0gZmFsc2U7XG4gICAgfSk7XG4gICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJDb3VudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyO1xuICAgIHZhciBsYXN0UHJvZ3Jlc3NpdmVLZXk7XG4gICAgdmFyIGZyYW1lQ291bnQgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgIHZhciB6bGV2ZWwgPSB0aGlzLl9zaW5nbGVDYW52YXMgPyAwIDogZWwuemxldmVsO1xuICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW3psZXZlbF07XG4gICAgICB2YXIgZWxQcm9ncmVzcyA9IGVsLnByb2dyZXNzaXZlO1xuXG4gICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuZWxDb3VudCsrO1xuICAgICAgICBsYXllci5fX2RpcnR5ID0gbGF5ZXIuX19kaXJ0eSB8fCBlbC5fX2RpcnR5O1xuICAgICAgfSAvLy8vLy8vIFVwZGF0ZSBwcm9ncmVzc2l2ZVxuXG5cbiAgICAgIGlmIChlbFByb2dyZXNzID49IDApIHtcbiAgICAgICAgLy8gRml4IHdyb25nIHByb2dyZXNzaXZlIHNlcXVlbmNlIHByb2JsZW0uXG4gICAgICAgIGlmIChsYXN0UHJvZ3Jlc3NpdmVLZXkgIT09IGVsUHJvZ3Jlc3MpIHtcbiAgICAgICAgICBsYXN0UHJvZ3Jlc3NpdmVLZXkgPSBlbFByb2dyZXNzO1xuICAgICAgICAgIGZyYW1lQ291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbEZyYW1lID0gZWwuX19mcmFtZSA9IGZyYW1lQ291bnQgLSAxO1xuXG4gICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICB2YXIgaWR4ID0gTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllckNvdW50LCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSIC0gMSk7XG4gICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBwcm9ncmVzc2l2ZUxheWVyc1tpZHhdO1xuXG4gICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBwcm9ncmVzc2l2ZUxheWVyc1tpZHhdID0gbmV3IExheWVyKCdwcm9ncmVzc2l2ZScsIHRoaXMsIHRoaXMuZHByKTtcbiAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5ID0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19kaXJ0eSB8fCBlbC5fX2RpcnR5O1xuICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5lbENvdW50Kys7XG4gICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPSBNYXRoLm1heChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzLCBlbEZyYW1lKTtcblxuICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcyA+PSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzKSB7XG4gICAgICAgICAgLy8gU2hvdWxkIGtlZXAgcmVuZGVyaW5nIHRoaXMgIGxheWVyIGJlY2F1c2UgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nIGlzIG5vdCBmaW5pc2hlZCB5ZXRcbiAgICAgICAgICBsYXllci5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuX19mcmFtZSA9IC0xO1xuXG4gICAgICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgPSBpO1xuICAgICAgICAgIHByb2dyZXNzaXZlTGF5ZXJDb3VudCsrO1xuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgcHJvZ3Jlc3NpdmVMYXllckNvdW50Kys7XG4gICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nID0gaTtcbiAgICB9IC8vIOWxguS4reeahOWFg+e0oOaVsOmHj+acieWPkeeUn+WPmOWMllxuXG5cbiAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICBpZiAoZWxDb3VudHNMYXN0RnJhbWVbel0gIT09IGxheWVyLmVsQ291bnQpIHtcbiAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcHJvZ3Jlc3NpdmVMYXllcnMubGVuZ3RoID0gTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllckNvdW50LCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSKTtcbiAgICB1dGlsLmVhY2gocHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllciwgaWR4KSB7XG4gICAgICBpZiAocHJvZ3Jlc3NpdmVFbENvdW50c0xhc3RGcmFtZVtpZHhdICE9PSBsYXllci5lbENvdW50KSB7XG4gICAgICAgIGVsLl9fZGlydHkgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobGF5ZXIuX19kaXJ0eSkge1xuICAgICAgICBsYXllci5fX3Byb2dyZXNzID0gMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICog5riF6ZmkaG92ZXLlsYLlpJbmiYDmnInlhoXlrrlcbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKHRoaXMuX2NsZWFyTGF5ZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfY2xlYXJMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgbGF5ZXIuY2xlYXIoKTtcbiAgfSxcblxuICAvKipcbiAgICog5L+u5pS55oyH5a6aemxldmVs55qE57uY5Yi25Y+C5pWwXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6bGV2ZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyDphY3nva7lr7nosaFcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuY2xlYXJDb2xvcj0wXSDmr4/mrKHmuIXnqbrnlLvluIPnmoTpopzoibJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcubW90aW9uQmx1cj1mYWxzZV0g5piv5ZCm5byA5ZCv5Yqo5oCB5qih57OKXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLmxhc3RGcmFtZUFscGhhPTAuN11cbiAgICogICAgICAgICAgICAgICAgIOWcqOW8gOWQr+WKqOaAgeaooeeziueahOaXtuWAmeS9v+eUqO+8jOS4juS4iuS4gOW4p+a3t+WQiOeahGFscGhh5YC877yM5YC86LaK5aSn5bC+6L+56LaK5piO5pi+XG4gICAqL1xuICBjb25maWdMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgdmFyIGxheWVyQ29uZmlnID0gdGhpcy5fbGF5ZXJDb25maWc7XG5cbiAgICAgIGlmICghbGF5ZXJDb25maWdbemxldmVsXSkge1xuICAgICAgICBsYXllckNvbmZpZ1t6bGV2ZWxdID0gY29uZmlnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbC5tZXJnZShsYXllckNvbmZpZ1t6bGV2ZWxdLCBjb25maWcsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcblxuICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgIHV0aWwubWVyZ2UobGF5ZXIsIGxheWVyQ29uZmlnW3psZXZlbF0sIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5oyH5a6a5bGCXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWwg5bGC5omA5Zyo55qEemxldmVsXG4gICAqL1xuICBkZWxMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgIHZhciBsYXllciA9IGxheWVyc1t6bGV2ZWxdO1xuXG4gICAgaWYgKCFsYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxheWVyLmRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxheWVyLmRvbSk7XG4gICAgZGVsZXRlIGxheWVyc1t6bGV2ZWxdO1xuICAgIHpsZXZlbExpc3Quc3BsaWNlKHV0aWwuaW5kZXhPZih6bGV2ZWxMaXN0LCB6bGV2ZWwpLCAxKTtcbiAgfSxcblxuICAvKipcbiAgICog5Yy65Z+f5aSn5bCP5Y+Y5YyW5ZCO6YeN57uYXG4gICAqL1xuICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIGRvbVJvb3QgPSB0aGlzLl9kb21Sb290OyAvLyBGSVhNRSBXaHkgP1xuXG4gICAgZG9tUm9vdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBTYXZlIGlucHV0IHcvaFxuXG4gICAgdmFyIG9wdHMgPSB0aGlzLl9vcHRzO1xuICAgIHdpZHRoICE9IG51bGwgJiYgKG9wdHMud2lkdGggPSB3aWR0aCk7XG4gICAgaGVpZ2h0ICE9IG51bGwgJiYgKG9wdHMuaGVpZ2h0ID0gaGVpZ2h0KTtcbiAgICB3aWR0aCA9IHRoaXMuX2dldFNpemUoMCk7XG4gICAgaGVpZ2h0ID0gdGhpcy5fZ2V0U2l6ZSgxKTtcbiAgICBkb21Sb290LnN0eWxlLmRpc3BsYXkgPSAnJzsgLy8g5LyY5YyW5rKh5pyJ5a6e6ZmF5pS55Y+Y55qEcmVzaXplXG5cbiAgICBpZiAodGhpcy5fd2lkdGggIT0gd2lkdGggfHwgaGVpZ2h0ICE9IHRoaXMuX2hlaWdodCkge1xuICAgICAgZG9tUm9vdC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgIGRvbVJvb3Quc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXllcnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgdGhpcy5fbGF5ZXJzW2lkXS5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdXRpbC5lYWNoKHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJlZnJlc2godHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa4hemZpOWNleeLrOeahOS4gOS4quWxglxuICAgKiBAcGFyYW0ge251bWJlcn0gemxldmVsXG4gICAqL1xuICBjbGVhckxheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3psZXZlbF07XG5cbiAgICBpZiAobGF5ZXIpIHtcbiAgICAgIGxheWVyLmNsZWFyKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDph4rmlL5cbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJvb3QuaW5uZXJIVE1MID0gJyc7XG4gICAgdGhpcy5yb290ID0gdGhpcy5zdG9yYWdlID0gdGhpcy5fZG9tUm9vdCA9IHRoaXMuX2xheWVycyA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBjYW52YXMgd2hpY2ggaGFzIGFsbCB0aGluZyByZW5kZXJlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFja2dyb3VuZENvbG9yXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMucGl4ZWxSYXRpb11cbiAgICovXG4gIGdldFJlbmRlcmVkQ2FudmFzOiBmdW5jdGlvbiAob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgaWYgKHRoaXMuX3NpbmdsZUNhbnZhcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1swXS5kb207XG4gICAgfVxuXG4gICAgdmFyIGltYWdlTGF5ZXIgPSBuZXcgTGF5ZXIoJ2ltYWdlJywgdGhpcywgb3B0cy5waXhlbFJhdGlvIHx8IHRoaXMuZHByKTtcbiAgICBpbWFnZUxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgaW1hZ2VMYXllci5jbGVhckNvbG9yID0gb3B0cy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgaW1hZ2VMYXllci5jbGVhcigpO1xuICAgIHZhciBkaXNwbGF5TGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlKTtcbiAgICB2YXIgc2NvcGUgPSB7fTtcbiAgICB2YXIgemxldmVsO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGZpbmRBbmREcmF3T3RoZXJMYXllcihzbWFsbGVyLCBsYXJnZXIpIHtcbiAgICAgIHZhciB6bGV2ZWxMaXN0ID0gc2VsZi5femxldmVsTGlzdDtcblxuICAgICAgaWYgKHNtYWxsZXIgPT0gbnVsbCkge1xuICAgICAgICBzbWFsbGVyID0gLUluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICB2YXIgaW50ZXJtZWRpYXRlTGF5ZXI7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICAgIHZhciBsYXllciA9IHNlbGYuX2xheWVyc1t6XTtcblxuICAgICAgICBpZiAoIWxheWVyLl9fYnVpbHRpbl9fICYmIHogPiBzbWFsbGVyICYmIHogPCBsYXJnZXIpIHtcbiAgICAgICAgICBpbnRlcm1lZGlhdGVMYXllciA9IGxheWVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnRlcm1lZGlhdGVMYXllciAmJiBpbnRlcm1lZGlhdGVMYXllci5yZW5kZXJUb0NhbnZhcykge1xuICAgICAgICBpbWFnZUxheWVyLmN0eC5zYXZlKCk7XG4gICAgICAgIGludGVybWVkaWF0ZUxheWVyLnJlbmRlclRvQ2FudmFzKGltYWdlTGF5ZXIuY3R4KTtcbiAgICAgICAgaW1hZ2VMYXllci5jdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGxheUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbCA9IGRpc3BsYXlMaXN0W2ldO1xuXG4gICAgICBpZiAoZWwuemxldmVsICE9PSB6bGV2ZWwpIHtcbiAgICAgICAgZmluZEFuZERyYXdPdGhlckxheWVyKHpsZXZlbCwgZWwuemxldmVsKTtcbiAgICAgICAgemxldmVsID0gZWwuemxldmVsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGltYWdlTGF5ZXIsIHRydWUsIHNjb3BlKTtcbiAgICB9XG5cbiAgICBmaW5kQW5kRHJhd090aGVyTGF5ZXIoemxldmVsLCBJbmZpbml0eSk7XG4gICAgcmV0dXJuIGltYWdlTGF5ZXIuZG9tO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bnu5jlm77ljLrln5/lrr3luqZcbiAgICovXG4gIGdldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bnu5jlm77ljLrln5/pq5jluqZcbiAgICovXG4gIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH0sXG4gIF9nZXRTaXplOiBmdW5jdGlvbiAod2hJZHgpIHtcbiAgICB2YXIgb3B0cyA9IHRoaXMuX29wdHM7XG4gICAgdmFyIHdoID0gWyd3aWR0aCcsICdoZWlnaHQnXVt3aElkeF07XG4gICAgdmFyIGN3aCA9IFsnY2xpZW50V2lkdGgnLCAnY2xpZW50SGVpZ2h0J11bd2hJZHhdO1xuICAgIHZhciBwbHQgPSBbJ3BhZGRpbmdMZWZ0JywgJ3BhZGRpbmdUb3AnXVt3aElkeF07XG4gICAgdmFyIHByYiA9IFsncGFkZGluZ1JpZ2h0JywgJ3BhZGRpbmdCb3R0b20nXVt3aElkeF07XG5cbiAgICBpZiAob3B0c1t3aF0gIT0gbnVsbCAmJiBvcHRzW3doXSAhPT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChvcHRzW3doXSk7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7IC8vIElFOCBkb2VzIG5vdCBzdXBwb3J0IGdldENvbXB1dGVkU3R5bGUsIGJ1dCBpdCB1c2UgVk1MLlxuXG4gICAgdmFyIHN0bCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUocm9vdCk7XG4gICAgcmV0dXJuIChyb290W2N3aF0gfHwgcGFyc2VJbnQxMChzdGxbd2hdKSB8fCBwYXJzZUludDEwKHJvb3Quc3R5bGVbd2hdKSkgLSAocGFyc2VJbnQxMChzdGxbcGx0XSkgfHwgMCkgLSAocGFyc2VJbnQxMChzdGxbcHJiXSkgfHwgMCkgfCAwO1xuICB9LFxuICBwYXRoVG9JbWFnZTogZnVuY3Rpb24gKHBhdGgsIGRwcikge1xuICAgIGRwciA9IGRwciB8fCB0aGlzLmRwcjtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgc3R5bGUgPSBwYXRoLnN0eWxlO1xuICAgIHZhciBzaGFkb3dCbHVyU2l6ZSA9IHN0eWxlLnNoYWRvd0JsdXI7XG4gICAgdmFyIHNoYWRvd09mZnNldFggPSBzdHlsZS5zaGFkb3dPZmZzZXRYO1xuICAgIHZhciBzaGFkb3dPZmZzZXRZID0gc3R5bGUuc2hhZG93T2Zmc2V0WTtcbiAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUuaGFzU3Ryb2tlKCkgPyBzdHlsZS5saW5lV2lkdGggOiAwO1xuICAgIHZhciBsZWZ0TWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgLXNoYWRvd09mZnNldFggKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgdmFyIHJpZ2h0TWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgc2hhZG93T2Zmc2V0WCArIHNoYWRvd0JsdXJTaXplKTtcbiAgICB2YXIgdG9wTWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgLXNoYWRvd09mZnNldFkgKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgdmFyIGJvdHRvbU1hcmdpbiA9IE1hdGgubWF4KGxpbmVXaWR0aCAvIDIsIHNoYWRvd09mZnNldFkgKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgdmFyIHdpZHRoID0gcmVjdC53aWR0aCArIGxlZnRNYXJnaW4gKyByaWdodE1hcmdpbjtcbiAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgKyB0b3BNYXJnaW4gKyBib3R0b21NYXJnaW47XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcbiAgICBjdHguc2NhbGUoZHByLCBkcHIpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgY3R4LmRwciA9IGRwcjtcbiAgICB2YXIgcGF0aFRyYW5zZm9ybSA9IHtcbiAgICAgIHBvc2l0aW9uOiBwYXRoLnBvc2l0aW9uLFxuICAgICAgcm90YXRpb246IHBhdGgucm90YXRpb24sXG4gICAgICBzY2FsZTogcGF0aC5zY2FsZVxuICAgIH07XG4gICAgcGF0aC5wb3NpdGlvbiA9IFtsZWZ0TWFyZ2luIC0gcmVjdC54LCB0b3BNYXJnaW4gLSByZWN0LnldO1xuICAgIHBhdGgucm90YXRpb24gPSAwO1xuICAgIHBhdGguc2NhbGUgPSBbMSwgMV07XG4gICAgcGF0aC51cGRhdGVUcmFuc2Zvcm0oKTtcblxuICAgIGlmIChwYXRoKSB7XG4gICAgICBwYXRoLmJydXNoKGN0eCk7XG4gICAgfVxuXG4gICAgdmFyIEltYWdlU2hhcGUgPSBJbWFnZTtcbiAgICB2YXIgaW1nU2hhcGUgPSBuZXcgSW1hZ2VTaGFwZSh7XG4gICAgICBzdHlsZToge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICBpbWFnZTogY2FudmFzXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocGF0aFRyYW5zZm9ybS5wb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICBpbWdTaGFwZS5wb3NpdGlvbiA9IHBhdGgucG9zaXRpb24gPSBwYXRoVHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgIH1cblxuICAgIGlmIChwYXRoVHJhbnNmb3JtLnJvdGF0aW9uICE9IG51bGwpIHtcbiAgICAgIGltZ1NoYXBlLnJvdGF0aW9uID0gcGF0aC5yb3RhdGlvbiA9IHBhdGhUcmFuc2Zvcm0ucm90YXRpb247XG4gICAgfVxuXG4gICAgaWYgKHBhdGhUcmFuc2Zvcm0uc2NhbGUgIT0gbnVsbCkge1xuICAgICAgaW1nU2hhcGUuc2NhbGUgPSBwYXRoLnNjYWxlID0gcGF0aFRyYW5zZm9ybS5zY2FsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW1nU2hhcGU7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBQYWludGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvUGFpbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbnZhciBfY29uZmlnID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuXG52YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IF9jb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcblxudmFyIFN0eWxlID0gcmVxdWlyZShcIi4vZ3JhcGhpYy9TdHlsZVwiKTtcblxudmFyIFBhdHRlcm4gPSByZXF1aXJlKFwiLi9ncmFwaGljL1BhdHRlcm5cIik7XG5cbi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL0xheWVyXG4gKiBAYXV0aG9yIHBpc3NhbmcoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiDliJvlu7pkb21cbiAqXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBkb20gaWQg5b6F55SoXG4gKiBAcGFyYW0ge1BhaW50ZXJ9IHBhaW50ZXIgcGFpbnRlciBpbnN0YW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlclxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRG9tKGlkLCBwYWludGVyLCBkcHIpIHtcbiAgdmFyIG5ld0RvbSA9IHV0aWwuY3JlYXRlQ2FudmFzKCk7XG4gIHZhciB3aWR0aCA9IHBhaW50ZXIuZ2V0V2lkdGgoKTtcbiAgdmFyIGhlaWdodCA9IHBhaW50ZXIuZ2V0SGVpZ2h0KCk7XG4gIHZhciBuZXdEb21TdHlsZSA9IG5ld0RvbS5zdHlsZTsgLy8g5rKhYXBwZW5k5ZGi77yM6K+35Y6f6LCF5oiR6L+Z5qC35YaZ77yM5riF5pmwflxuXG4gIG5ld0RvbVN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgbmV3RG9tU3R5bGUubGVmdCA9IDA7XG4gIG5ld0RvbVN0eWxlLnRvcCA9IDA7XG4gIG5ld0RvbVN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICBuZXdEb21TdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICBuZXdEb20ud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgbmV3RG9tLmhlaWdodCA9IGhlaWdodCAqIGRwcjsgLy8gaWTkuI3kvZzkuLrntKLlvJXnlKjvvIzpgb/lhY3lj6/og73pgKDmiJDnmoTph43lkI3vvIzlrprkuYnkuLrnp4HmnInlsZ7mgKdcblxuICBuZXdEb20uc2V0QXR0cmlidXRlKCdkYXRhLXpyLWRvbS1pZCcsIGlkKTtcbiAgcmV0dXJuIG5ld0RvbTtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL0xheWVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9QYWludGVyfSBwYWludGVyXG4gKiBAcGFyYW0ge251bWJlcn0gW2Rwcl1cbiAqL1xuXG5cbnZhciBMYXllciA9IGZ1bmN0aW9uIChpZCwgcGFpbnRlciwgZHByKSB7XG4gIHZhciBkb207XG4gIGRwciA9IGRwciB8fCBkZXZpY2VQaXhlbFJhdGlvO1xuXG4gIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgZG9tID0gY3JlYXRlRG9tKGlkLCBwYWludGVyLCBkcHIpO1xuICB9IC8vIE5vdCB1c2luZyBpc0RvbSBiZWNhdXNlIGluIG5vZGUgaXQgd2lsbCByZXR1cm4gZmFsc2VcbiAgZWxzZSBpZiAodXRpbC5pc09iamVjdChpZCkpIHtcbiAgICAgIGRvbSA9IGlkO1xuICAgICAgaWQgPSBkb20uaWQ7XG4gICAgfVxuXG4gIHRoaXMuaWQgPSBpZDtcbiAgdGhpcy5kb20gPSBkb207XG4gIHZhciBkb21TdHlsZSA9IGRvbS5zdHlsZTtcblxuICBpZiAoZG9tU3R5bGUpIHtcbiAgICAvLyBOb3QgaW4gbm9kZVxuICAgIGRvbS5vbnNlbGVjdHN0YXJ0ID0gcmV0dXJuRmFsc2U7IC8vIOmBv+WFjemhtemdoumAieS4reeahOWwtOWwrFxuXG4gICAgZG9tU3R5bGVbJy13ZWJraXQtdXNlci1zZWxlY3QnXSA9ICdub25lJztcbiAgICBkb21TdHlsZVsndXNlci1zZWxlY3QnXSA9ICdub25lJztcbiAgICBkb21TdHlsZVsnLXdlYmtpdC10b3VjaC1jYWxsb3V0J10gPSAnbm9uZSc7XG4gICAgZG9tU3R5bGVbJy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvciddID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgIGRvbVN0eWxlWydwYWRkaW5nJ10gPSAwO1xuICAgIGRvbVN0eWxlWydtYXJnaW4nXSA9IDA7XG4gICAgZG9tU3R5bGVbJ2JvcmRlci13aWR0aCddID0gMDtcbiAgfVxuXG4gIHRoaXMuZG9tQmFjayA9IG51bGw7XG4gIHRoaXMuY3R4QmFjayA9IG51bGw7XG4gIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG4gIHRoaXMuY29uZmlnID0gbnVsbDsgLy8gQ29uZmlnc1xuXG4gIC8qKlxuICAgKiDmr4/mrKHmuIXnqbrnlLvluIPnmoTpopzoibJcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cblxuICB0aGlzLmNsZWFyQ29sb3IgPSAwO1xuICAvKipcbiAgICog5piv5ZCm5byA5ZCv5Yqo5oCB5qih57OKXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cblxuICB0aGlzLm1vdGlvbkJsdXIgPSBmYWxzZTtcbiAgLyoqXG4gICAqIOWcqOW8gOWQr+WKqOaAgeaooeeziueahOaXtuWAmeS9v+eUqO+8jOS4juS4iuS4gOW4p+a3t+WQiOeahGFscGhh5YC877yM5YC86LaK5aSn5bC+6L+56LaK5piO5pi+XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDAuN1xuICAgKi9cblxuICB0aGlzLmxhc3RGcmFtZUFscGhhID0gMC43O1xuICAvKipcbiAgICogTGF5ZXIgZHByXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuZHByID0gZHByO1xufTtcblxuTGF5ZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTGF5ZXIsXG4gIGVsQ291bnQ6IDAsXG4gIF9fZGlydHk6IHRydWUsXG4gIGluaXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jdHggPSB0aGlzLmRvbS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMuY3R4Ll9fY3VycmVudFZhbHVlcyA9IHt9O1xuICAgIHRoaXMuY3R4LmRwciA9IHRoaXMuZHByO1xuICB9LFxuICBjcmVhdGVCYWNrQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRwciA9IHRoaXMuZHByO1xuICAgIHRoaXMuZG9tQmFjayA9IGNyZWF0ZURvbSgnYmFjay0nICsgdGhpcy5pZCwgdGhpcy5wYWludGVyLCBkcHIpO1xuICAgIHRoaXMuY3R4QmFjayA9IHRoaXMuZG9tQmFjay5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMuY3R4QmFjay5fX2N1cnJlbnRWYWx1ZXMgPSB7fTtcblxuICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgdGhpcy5jdHhCYWNrLnNjYWxlKGRwciwgZHByKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0gd2lkdGhcbiAgICogQHBhcmFtICB7bnVtYmVyfSBoZWlnaHRcbiAgICovXG4gIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgZHByID0gdGhpcy5kcHI7XG4gICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgIHZhciBkb21TdHlsZSA9IGRvbS5zdHlsZTtcbiAgICB2YXIgZG9tQmFjayA9IHRoaXMuZG9tQmFjaztcbiAgICBkb21TdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICBkb21TdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIGRvbS53aWR0aCA9IHdpZHRoICogZHByO1xuICAgIGRvbS5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG5cbiAgICBpZiAoZG9tQmFjaykge1xuICAgICAgZG9tQmFjay53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgZG9tQmFjay5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG5cbiAgICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgICB0aGlzLmN0eEJhY2suc2NhbGUoZHByLCBkcHIpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5riF56m66K+l5bGC55S75biDXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXJBbGwgQ2xlYXIgYWxsIHdpdGggb3V0IG1vdGlvbiBibHVyXG4gICAqL1xuICBjbGVhcjogZnVuY3Rpb24gKGNsZWFyQWxsKSB7XG4gICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICB2YXIgd2lkdGggPSBkb20ud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IGRvbS5oZWlnaHQ7XG4gICAgdmFyIGNsZWFyQ29sb3IgPSB0aGlzLmNsZWFyQ29sb3I7XG4gICAgdmFyIGhhdmVNb3Rpb25CTHVyID0gdGhpcy5tb3Rpb25CbHVyICYmICFjbGVhckFsbDtcbiAgICB2YXIgbGFzdEZyYW1lQWxwaGEgPSB0aGlzLmxhc3RGcmFtZUFscGhhO1xuICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgIGlmIChoYXZlTW90aW9uQkx1cikge1xuICAgICAgaWYgKCF0aGlzLmRvbUJhY2spIHtcbiAgICAgICAgdGhpcy5jcmVhdGVCYWNrQnVmZmVyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4QmFjay5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG4gICAgICB0aGlzLmN0eEJhY2suZHJhd0ltYWdlKGRvbSwgMCwgMCwgd2lkdGggLyBkcHIsIGhlaWdodCAvIGRwcik7XG4gICAgfVxuXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGlmIChjbGVhckNvbG9yKSB7XG4gICAgICB2YXIgY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuOyAvLyBHcmFkaWVudFxuXG4gICAgICBpZiAoY2xlYXJDb2xvci5jb2xvclN0b3BzKSB7XG4gICAgICAgIC8vIENhY2hlIGNhbnZhcyBncmFkaWVudFxuICAgICAgICBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gPSBjbGVhckNvbG9yLl9fY2FudmFzR3JhZGllbnQgfHwgU3R5bGUuZ2V0R3JhZGllbnQoY3R4LCBjbGVhckNvbG9yLCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgY2xlYXJDb2xvci5fX2NhbnZhc0dyYWRpZW50ID0gY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuO1xuICAgICAgfSAvLyBQYXR0ZXJuXG4gICAgICBlbHNlIGlmIChjbGVhckNvbG9yLmltYWdlKSB7XG4gICAgICAgICAgY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuID0gUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybi5jYWxsKGNsZWFyQ29sb3IsIGN0eCk7XG4gICAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gfHwgY2xlYXJDb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgaWYgKGhhdmVNb3Rpb25CTHVyKSB7XG4gICAgICB2YXIgZG9tQmFjayA9IHRoaXMuZG9tQmFjaztcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBsYXN0RnJhbWVBbHBoYTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoZG9tQmFjaywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IExheWVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvTGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfZGVmYXVsdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lY29tZmUvenJlbmRlci9pc3N1ZXMvMTg5I2lzc3VlY29tbWVudC0yMjQ5MTk4MDlcbndpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSAmJiB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSkgfHwgZnVuY3Rpb24gKGZ1bmMpIHtcbiAgc2V0VGltZW91dChmdW5jLCAxNik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBfZXZlbnQgPSByZXF1aXJlKFwiLi4vY29yZS9ldmVudFwiKTtcblxudmFyIERpc3BhdGNoZXIgPSBfZXZlbnQuRGlzcGF0Y2hlcjtcblxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJlcXVpcmUoXCIuL3JlcXVlc3RBbmltYXRpb25GcmFtZVwiKTtcblxudmFyIEFuaW1hdG9yID0gcmVxdWlyZShcIi4vQW5pbWF0b3JcIik7XG5cbi8qKlxuICog5Yqo55S75Li757G7LCDosIPluqblkoznrqHnkIbmiYDmnInliqjnlLvmjqfliLblmahcbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvblxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG4vLyBUT0RPIEFkZGl0aXZlIGFuaW1hdGlvblxuLy8gaHR0cDovL2lvc290ZXJpYy5jb20vYWRkaXRpdmUtYW5pbWF0aW9ucy1hbmltYXRld2l0aGR1cmF0aW9uLWluLWlvcy04L1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3ZpZGVvcy93d2RjMjAxNC8jMjM2XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSVpSZW5kZXJTdGFnZVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdXBkYXRlXG4gKi9cblxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbmZyYW1lXVxuICogQHBhcmFtIHtJWlJlbmRlclN0YWdlfSBbb3B0aW9ucy5zdGFnZV1cbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oKTtcbiAqICAgICB2YXIgb2JqID0ge1xuICogICAgICAgICB4OiAxMDAsXG4gKiAgICAgICAgIHk6IDEwMFxuICogICAgIH07XG4gKiAgICAgYW5pbWF0aW9uLmFuaW1hdGUobm9kZS5wb3NpdGlvbilcbiAqICAgICAgICAgLndoZW4oMTAwMCwge1xuICogICAgICAgICAgICAgeDogNTAwLFxuICogICAgICAgICAgICAgeTogNTAwXG4gKiAgICAgICAgIH0pXG4gKiAgICAgICAgIC53aGVuKDIwMDAsIHtcbiAqICAgICAgICAgICAgIHg6IDEwMCxcbiAqICAgICAgICAgICAgIHk6IDEwMFxuICogICAgICAgICB9KVxuICogICAgICAgICAuc3RhcnQoJ3NwbGluZScpO1xuICovXG52YXIgQW5pbWF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuc3RhZ2UgPSBvcHRpb25zLnN0YWdlIHx8IHt9O1xuXG4gIHRoaXMub25mcmFtZSA9IG9wdGlvbnMub25mcmFtZSB8fCBmdW5jdGlvbiAoKSB7fTsgLy8gcHJpdmF0ZSBwcm9wZXJ0aWVzXG5cblxuICB0aGlzLl9jbGlwcyA9IFtdO1xuICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gIHRoaXMuX3RpbWU7XG4gIHRoaXMuX3BhdXNlZFRpbWU7XG4gIHRoaXMuX3BhdXNlU3RhcnQ7XG4gIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICBEaXNwYXRjaGVyLmNhbGwodGhpcyk7XG59O1xuXG5BbmltYXRpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQW5pbWF0aW9uLFxuXG4gIC8qKlxuICAgKiDmt7vliqAgY2xpcFxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwfSBjbGlwXG4gICAqL1xuICBhZGRDbGlwOiBmdW5jdGlvbiAoY2xpcCkge1xuICAgIHRoaXMuX2NsaXBzLnB1c2goY2xpcCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoCBhbmltYXRvclxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn0gYW5pbWF0b3JcbiAgICovXG4gIGFkZEFuaW1hdG9yOiBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICBhbmltYXRvci5hbmltYXRpb24gPSB0aGlzO1xuICAgIHZhciBjbGlwcyA9IGFuaW1hdG9yLmdldENsaXBzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmFkZENsaXAoY2xpcHNbaV0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5Yqo55S754mH5q61XG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0NsaXB9IGNsaXBcbiAgICovXG4gIHJlbW92ZUNsaXA6IGZ1bmN0aW9uIChjbGlwKSB7XG4gICAgdmFyIGlkeCA9IHV0aWwuaW5kZXhPZih0aGlzLl9jbGlwcywgY2xpcCk7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIHRoaXMuX2NsaXBzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5Yqo55S754mH5q61XG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfSBhbmltYXRvclxuICAgKi9cbiAgcmVtb3ZlQW5pbWF0b3I6IGZ1bmN0aW9uIChhbmltYXRvcikge1xuICAgIHZhciBjbGlwcyA9IGFuaW1hdG9yLmdldENsaXBzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnJlbW92ZUNsaXAoY2xpcHNbaV0pO1xuICAgIH1cblxuICAgIGFuaW1hdG9yLmFuaW1hdGlvbiA9IG51bGw7XG4gIH0sXG4gIF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5fcGF1c2VkVGltZTtcblxuICAgIHZhciBkZWx0YSA9IHRpbWUgLSB0aGlzLl90aW1lO1xuICAgIHZhciBjbGlwcyA9IHRoaXMuX2NsaXBzO1xuICAgIHZhciBsZW4gPSBjbGlwcy5sZW5ndGg7XG4gICAgdmFyIGRlZmVycmVkRXZlbnRzID0gW107XG4gICAgdmFyIGRlZmVycmVkQ2xpcHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjbGlwID0gY2xpcHNbaV07XG4gICAgICB2YXIgZSA9IGNsaXAuc3RlcCh0aW1lLCBkZWx0YSk7IC8vIFRocm93IG91dCB0aGUgZXZlbnRzIG5lZWQgdG8gYmUgY2FsbGVkIGFmdGVyXG4gICAgICAvLyBzdGFnZS51cGRhdGUsIGxpa2UgZGVzdHJveVxuXG4gICAgICBpZiAoZSkge1xuICAgICAgICBkZWZlcnJlZEV2ZW50cy5wdXNoKGUpO1xuICAgICAgICBkZWZlcnJlZENsaXBzLnB1c2goY2xpcCk7XG4gICAgICB9XG4gICAgfSAvLyBSZW1vdmUgdGhlIGZpbmlzaGVkIGNsaXBcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICBpZiAoY2xpcHNbaV0uX25lZWRzUmVtb3ZlKSB7XG4gICAgICAgIGNsaXBzW2ldID0gY2xpcHNbbGVuIC0gMV07XG4gICAgICAgIGNsaXBzLnBvcCgpO1xuICAgICAgICBsZW4tLTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZW4gPSBkZWZlcnJlZEV2ZW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZWZlcnJlZENsaXBzW2ldLmZpcmUoZGVmZXJyZWRFdmVudHNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuICAgIHRoaXMub25mcmFtZShkZWx0YSk7XG4gICAgdGhpcy50cmlnZ2VyKCdmcmFtZScsIGRlbHRhKTtcblxuICAgIGlmICh0aGlzLnN0YWdlLnVwZGF0ZSkge1xuICAgICAgdGhpcy5zdGFnZS51cGRhdGUoKTtcbiAgICB9XG4gIH0sXG4gIF9zdGFydExvb3A6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG5cbiAgICBmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgaWYgKHNlbGYuX3J1bm5pbmcpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICAhc2VsZi5fcGF1c2VkICYmIHNlbGYuX3VwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgfSxcblxuICAvKipcbiAgICog5byA5aeL6L+Q6KGM5Yqo55S7XG4gICAqL1xuICBzdGFydDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB0aGlzLl9wYXVzZWRUaW1lID0gMDtcblxuICAgIHRoaXMuX3N0YXJ0TG9vcCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlgZzmraLov5DooYzliqjnlLtcbiAgICovXG4gIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBhdXNlXG4gICAqL1xuICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fcGF1c2VkKSB7XG4gICAgICB0aGlzLl9wYXVzZVN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVzdW1lXG4gICAqL1xuICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgICB0aGlzLl9wYXVzZWRUaW1lICs9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5fcGF1c2VTdGFydDtcbiAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5riF6Zmk5omA5pyJ5Yqo55S754mH5q61XG4gICAqL1xuICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NsaXBzID0gW107XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWvueS4gOS4quebruagh+WIm+W7uuS4gOS4qmFuaW1hdG9y5a+56LGh77yM5Y+v5Lul5oyH5a6a55uu5qCH5Lit55qE5bGe5oCn5L2/55So5Yqo55S7XG4gICAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5sb29wPWZhbHNlXSDmmK/lkKblvqrnjq/mkq3mlL7liqjnlLtcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IFtvcHRpb25zLmdldHRlcj1udWxsXVxuICAgKiAgICAgICAgIOWmguaenOaMh+WummdldHRlcuWHveaVsO+8jOS8mumAmui/h2dldHRlcuWHveaVsOWPluWxnuaAp+WAvFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW29wdGlvbnMuc2V0dGVyPW51bGxdXG4gICAqICAgICAgICAg5aaC5p6c5oyH5a6ac2V0dGVy5Ye95pWw77yM5Lya6YCa6L+Hc2V0dGVy5Ye95pWw6K6+572u5bGe5oCn5YC8XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25+QW5pbWF0b3J9XG4gICAqL1xuICAvLyBUT0RPIEdhcFxuICBhbmltYXRlOiBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKHRhcmdldCwgb3B0aW9ucy5sb29wLCBvcHRpb25zLmdldHRlciwgb3B0aW9ucy5zZXR0ZXIpO1xuICAgIHRoaXMuYWRkQW5pbWF0b3IoYW5pbWF0b3IpO1xuICAgIHJldHVybiBhbmltYXRvcjtcbiAgfVxufTtcbnV0aWwubWl4aW4oQW5pbWF0aW9uLCBEaXNwYXRjaGVyKTtcbnZhciBfZGVmYXVsdCA9IEFuaW1hdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFdmVudGZ1bCA9IHJlcXVpcmUoXCIuLi9taXhpbi9FdmVudGZ1bFwiKTtcblxuZXhwb3J0cy5EaXNwYXRjaGVyID0gRXZlbnRmdWw7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwiLi9lbnZcIik7XG5cbi8qKlxuICog5LqL5Lu26L6F5Yqp57G7XG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9ldmVudFxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKi9cbnZhciBpc0RvbUxldmVsMiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICEhd2luZG93LmFkZEV2ZW50TGlzdGVuZXI7XG52YXIgTU9VU0VfRVZFTlRfUkVHID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svO1xuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWwpIHtcbiAgLy8gQmxhY2tCZXJyeSA1LCBpT1MgMyAob3JpZ2luYWwgaVBob25lKSBkb24ndCBoYXZlIGdldEJvdW5kaW5nUmVjdFxuICByZXR1cm4gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID8gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiB7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDBcbiAgfTtcbn0gLy8gYGNhbGN1bGF0ZWAgaXMgb3B0aW9uYWwsIGRlZmF1bHQgZmFsc2VcblxuXG5mdW5jdGlvbiBjbGllbnRUb0xvY2FsKGVsLCBlLCBvdXQsIGNhbGN1bGF0ZSkge1xuICBvdXQgPSBvdXQgfHwge307IC8vIEFjY29yZGluZyB0byB0aGUgVzNDIFdvcmtpbmcgRHJhZnQsIG9mZnNldFggYW5kIG9mZnNldFkgc2hvdWxkIGJlIHJlbGF0aXZlXG4gIC8vIHRvIHRoZSBwYWRkaW5nIGVkZ2Ugb2YgdGhlIHRhcmdldCBlbGVtZW50LiBUaGUgb25seSBicm93c2VyIHVzaW5nIHRoaXMgY29udmVudGlvblxuICAvLyBpcyBJRS4gV2Via2l0IHVzZXMgdGhlIGJvcmRlciBlZGdlLCBPcGVyYSB1c2VzIHRoZSBjb250ZW50IGVkZ2UsIGFuZCBGaXJlRm94IGRvZXNcbiAgLy8gbm90IHN1cHBvcnQgdGhlIHByb3BlcnRpZXMuXG4gIC8vIChzZWUgaHR0cDovL3d3dy5qYWNrbG1vb3JlLmNvbS9ub3Rlcy9tb3VzZS1wb3NpdGlvbi8pXG4gIC8vIEluIHpyIHBhaW50ZXIuZG9tLCBwYWRkaW5nIGVkZ2UgZXF1YWxzIHRvIGJvcmRlciBlZGdlLlxuICAvLyBGSVhNRVxuICAvLyBXaGVuIG1vdXNlbW92ZSBldmVudCB0cmlnZ2VyZWQgb24gZWMgdG9vbHRpcCwgdGFyZ2V0IGlzIG5vdCB6ciBwYWludGVyLmRvbSwgYW5kXG4gIC8vIG9mZnNldFgvWSBpcyByZWxhdGl2ZSB0byBlLnRhcmdldCwgd2hlcmUgdGhlIGNhbGN1bGF0aW9uIG9mIHpyWC9ZIHZpYSBvZmZzZXRYL1lcbiAgLy8gaXMgdG9vIGNvbXBsZXguIFNvIGNzcy10cmFuc2Zyb20gZG9udCBzdXBwb3J0IGluIHRoaXMgY2FzZSB0ZW1wb3JhcmlseS5cblxuICBpZiAoY2FsY3VsYXRlIHx8ICFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgZGVmYXVsdEdldFpyWFkoZWwsIGUsIG91dCk7XG4gIH0gLy8gQ2F1dGlvbjogSW4gRmlyZUZveCwgbGF5ZXJYL2xheWVyWSBNb3VzZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgY2xvc2VzdCBwb3NpdGlvbmVkXG4gIC8vIGFuY2VzdG9yIGVsZW1lbnQsIHNvIHdlIHNob3VsZCBtYWtlIHN1cmUgZWwgaXMgcG9zaXRpb25lZCAoZS5nLiwgbm90IHBvc2l0aW9uOnN0YXRpYykuXG4gIC8vIEJUVzEsIFdlYmtpdCBkb24ndCByZXR1cm4gdGhlIHNhbWUgcmVzdWx0cyBhcyBGRiBpbiBub24tc2ltcGxlIGNhc2VzIChsaWtlIGFkZFxuICAvLyB6b29tLWZhY3Rvciwgb3ZlcmZsb3cgLyBvcGFjaXR5IGxheWVycywgdHJhbnNmb3JtcyAuLi4pXG4gIC8vIEJUVzIsIChldi5vZmZzZXRZIHx8IGV2LnBhZ2VZIC0gJChldi50YXJnZXQpLm9mZnNldCgpLnRvcCkgaXMgbm90IGNvcnJlY3QgaW4gcHJlc2VydmUtM2QuXG4gIC8vIDxodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvODUyMyNjb21tZW50OjE0PlxuICAvLyBCVFczLCBJbiBmZiwgb2Zmc2V0WC9vZmZzZXRZIGlzIGFsd2F5cyAwLlxuICBlbHNlIGlmIChlbnYuYnJvd3Nlci5maXJlZm94ICYmIGUubGF5ZXJYICE9IG51bGwgJiYgZS5sYXllclggIT09IGUub2Zmc2V0WCkge1xuICAgICAgb3V0LnpyWCA9IGUubGF5ZXJYO1xuICAgICAgb3V0LnpyWSA9IGUubGF5ZXJZO1xuICAgIH0gLy8gRm9yIElFNissIGNocm9tZSwgc2FmYXJpLCBvcGVyYS4gKFdoZW4gd2lsbCBmZiBzdXBwb3J0IG9mZnNldFg/KVxuICAgIGVsc2UgaWYgKGUub2Zmc2V0WCAhPSBudWxsKSB7XG4gICAgICAgIG91dC56clggPSBlLm9mZnNldFg7XG4gICAgICAgIG91dC56clkgPSBlLm9mZnNldFk7XG4gICAgICB9IC8vIEZvciBzb21lIG90aGVyIGRldmljZSwgZS5nLiwgSU9TIHNhZmFyaS5cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlZmF1bHRHZXRaclhZKGVsLCBlLCBvdXQpO1xuICAgICAgICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEdldFpyWFkoZWwsIGUsIG91dCkge1xuICAvLyBUaGlzIHdlbGwta25vd24gbWV0aG9kIGJlbG93IGRvZXMgbm90IHN1cHBvcnQgY3NzIHRyYW5zZm9ybS5cbiAgdmFyIGJveCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbCk7XG4gIG91dC56clggPSBlLmNsaWVudFggLSBib3gubGVmdDtcbiAgb3V0LnpyWSA9IGUuY2xpZW50WSAtIGJveC50b3A7XG59XG4vKipcbiAqIOWmguaenOWtmOWcqOesrOS4ieaWueW1jOWFpeeahOS4gOS6m2RvbeinpuWPkeeahOS6i+S7tu+8jOaIlnRvdWNo5LqL5Lu277yM6ZyA6KaB6L2s5o2i5LiA5LiL5LqL5Lu25Z2Q5qCHLlxuICogYGNhbGN1bGF0ZWAgaXMgb3B0aW9uYWwsIGRlZmF1bHQgZmFsc2UuXG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudChlbCwgZSwgY2FsY3VsYXRlKSB7XG4gIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcblxuICBpZiAoZS56clggIT0gbnVsbCkge1xuICAgIHJldHVybiBlO1xuICB9XG5cbiAgdmFyIGV2ZW50VHlwZSA9IGUudHlwZTtcbiAgdmFyIGlzVG91Y2ggPSBldmVudFR5cGUgJiYgZXZlbnRUeXBlLmluZGV4T2YoJ3RvdWNoJykgPj0gMDtcblxuICBpZiAoIWlzVG91Y2gpIHtcbiAgICBjbGllbnRUb0xvY2FsKGVsLCBlLCBlLCBjYWxjdWxhdGUpO1xuICAgIGUuenJEZWx0YSA9IGUud2hlZWxEZWx0YSA/IGUud2hlZWxEZWx0YSAvIDEyMCA6IC0oZS5kZXRhaWwgfHwgMCkgLyAzO1xuICB9IGVsc2Uge1xuICAgIHZhciB0b3VjaCA9IGV2ZW50VHlwZSAhPSAndG91Y2hlbmQnID8gZS50YXJnZXRUb3VjaGVzWzBdIDogZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICB0b3VjaCAmJiBjbGllbnRUb0xvY2FsKGVsLCB0b3VjaCwgZSwgY2FsY3VsYXRlKTtcbiAgfSAvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0OyBvdGhlcndpc2U6IDA7XG4gIC8vIFNlZSBqUXVlcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvbWFzdGVyL3NyYy9ldmVudC5qc1xuICAvLyBJZiBlLndoaWNoIGhhcyBiZWVuIGRlZmluZWQsIGlmIG1heSBiZSByZWFkb25seSxcbiAgLy8gc2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC93aGljaFxuXG5cbiAgdmFyIGJ1dHRvbiA9IGUuYnV0dG9uO1xuXG4gIGlmIChlLndoaWNoID09IG51bGwgJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgTU9VU0VfRVZFTlRfUkVHLnRlc3QoZS50eXBlKSkge1xuICAgIGUud2hpY2ggPSBidXR0b24gJiAxID8gMSA6IGJ1dHRvbiAmIDIgPyAzIDogYnV0dG9uICYgNCA/IDIgOiAwO1xuICB9XG5cbiAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGhhbmRsZXIpIHtcbiAgaWYgKGlzRG9tTGV2ZWwyKSB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5hdHRhY2hFdmVudCgnb24nICsgbmFtZSwgaGFuZGxlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaGFuZGxlcikge1xuICBpZiAoaXNEb21MZXZlbDIpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICB9IGVsc2Uge1xuICAgIGVsLmRldGFjaEV2ZW50KCdvbicgKyBuYW1lLCBoYW5kbGVyKTtcbiAgfVxufVxuLyoqXG4gKiBwcmV2ZW50RGVmYXVsdCBhbmQgc3RvcFByb3BhZ2F0aW9uLlxuICogTm90aWNlOiBkbyBub3QgZG8gdGhhdCBpbiB6cmVuZGVyLiBVcHBlciBhcHBsaWNhdGlvblxuICogZG8gdGhhdCBpZiBuZWNlc3NhcnkuXG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvZXZlbnRcbiAqIEBtZXRob2RcbiAqIEBwYXJhbSB7RXZlbnR9IGUgOiBldmVudOWvueixoVxuICovXG5cblxudmFyIHN0b3AgPSBpc0RvbUxldmVsMiA/IGZ1bmN0aW9uIChlKSB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbiAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xufSA6IGZ1bmN0aW9uIChlKSB7XG4gIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xufTtcblxuZnVuY3Rpb24gbm90TGVmdE1vdXNlKGUpIHtcbiAgLy8gSWYgZS53aGljaCBpcyB1bmRlZmluZWQsIGNvbnNpZGVyZWQgYXMgbGVmdCBtb3VzZSBldmVudC5cbiAgcmV0dXJuIGUud2hpY2ggPiAxO1xufSAvLyDlgZrlkJHkuIrlhbzlrrlcblxuXG5leHBvcnRzLmNsaWVudFRvTG9jYWwgPSBjbGllbnRUb0xvY2FsO1xuZXhwb3J0cy5ub3JtYWxpemVFdmVudCA9IG5vcm1hbGl6ZUV2ZW50O1xuZXhwb3J0cy5hZGRFdmVudExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcjtcbmV4cG9ydHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG5leHBvcnRzLnN0b3AgPSBzdG9wO1xuZXhwb3J0cy5ub3RMZWZ0TW91c2UgPSBub3RMZWZ0TW91c2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvZXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfZXZlbnQgPSByZXF1aXJlKFwiLi4vY29yZS9ldmVudFwiKTtcblxudmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBfZXZlbnQuYWRkRXZlbnRMaXN0ZW5lcjtcbnZhciByZW1vdmVFdmVudExpc3RlbmVyID0gX2V2ZW50LnJlbW92ZUV2ZW50TGlzdGVuZXI7XG52YXIgbm9ybWFsaXplRXZlbnQgPSBfZXZlbnQubm9ybWFsaXplRXZlbnQ7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgRXZlbnRmdWwgPSByZXF1aXJlKFwiLi4vbWl4aW4vRXZlbnRmdWxcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwiLi4vY29yZS9lbnZcIik7XG5cbnZhciBHZXN0dXJlTWdyID0gcmVxdWlyZShcIi4uL2NvcmUvR2VzdHVyZU1nclwiKTtcblxudmFyIFRPVUNIX0NMSUNLX0RFTEFZID0gMzAwO1xudmFyIG1vdXNlSGFuZGxlck5hbWVzID0gWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZXdoZWVsJywgJ21vdXNlb3V0JywgJ21vdXNldXAnLCAnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdjb250ZXh0bWVudSddO1xudmFyIHRvdWNoSGFuZGxlck5hbWVzID0gWyd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJywgJ3RvdWNobW92ZSddO1xudmFyIHBvaW50ZXJFdmVudE5hbWVzID0ge1xuICBwb2ludGVyZG93bjogMSxcbiAgcG9pbnRlcnVwOiAxLFxuICBwb2ludGVybW92ZTogMSxcbiAgcG9pbnRlcm91dDogMVxufTtcbnZhciBwb2ludGVySGFuZGxlck5hbWVzID0genJVdGlsLm1hcChtb3VzZUhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIG5tID0gbmFtZS5yZXBsYWNlKCdtb3VzZScsICdwb2ludGVyJyk7XG4gIHJldHVybiBwb2ludGVyRXZlbnROYW1lc1tubV0gPyBubSA6IG5hbWU7XG59KTtcblxuZnVuY3Rpb24gZXZlbnROYW1lRml4KG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUgPT09ICdtb3VzZXdoZWVsJyAmJiBlbnYuYnJvd3Nlci5maXJlZm94ID8gJ0RPTU1vdXNlU2Nyb2xsJyA6IG5hbWU7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NHZXN0dXJlKHByb3h5LCBldmVudCwgc3RhZ2UpIHtcbiAgdmFyIGdlc3R1cmVNZ3IgPSBwcm94eS5fZ2VzdHVyZU1ncjtcbiAgc3RhZ2UgPT09ICdzdGFydCcgJiYgZ2VzdHVyZU1nci5jbGVhcigpO1xuICB2YXIgZ2VzdHVyZUluZm8gPSBnZXN0dXJlTWdyLnJlY29nbml6ZShldmVudCwgcHJveHkuaGFuZGxlci5maW5kSG92ZXIoZXZlbnQuenJYLCBldmVudC56clksIG51bGwpLnRhcmdldCwgcHJveHkuZG9tKTtcbiAgc3RhZ2UgPT09ICdlbmQnICYmIGdlc3R1cmVNZ3IuY2xlYXIoKTsgLy8gRG8gbm90IGRvIGFueSBwcmV2ZW50RGVmYXVsdCBoZXJlLiBVcHBlciBhcHBsaWNhdGlvbiBkbyB0aGF0IGlmIG5lY2Vzc2FyeS5cblxuICBpZiAoZ2VzdHVyZUluZm8pIHtcbiAgICB2YXIgdHlwZSA9IGdlc3R1cmVJbmZvLnR5cGU7XG4gICAgZXZlbnQuZ2VzdHVyZUV2ZW50ID0gdHlwZTtcbiAgICBwcm94eS5oYW5kbGVyLmRpc3BhdGNoVG9FbGVtZW50KHtcbiAgICAgIHRhcmdldDogZ2VzdHVyZUluZm8udGFyZ2V0XG4gICAgfSwgdHlwZSwgZ2VzdHVyZUluZm8uZXZlbnQpO1xuICB9XG59IC8vIGZ1bmN0aW9uIG9uTVNHZXN0dXJlQ2hhbmdlKHByb3h5LCBldmVudCkge1xuLy8gICAgIGlmIChldmVudC50cmFuc2xhdGlvblggfHwgZXZlbnQudHJhbnNsYXRpb25ZKSB7XG4vLyAgICAgICAgIC8vIG1vdXNlbW92ZSBpcyBjYXJyaWVkIGJ5IE1TR2VzdHVyZSB0byByZWR1Y2UgdGhlIHNlbnNpdGl2aXR5LlxuLy8gICAgICAgICBwcm94eS5oYW5kbGVyLmRpc3BhdGNoVG9FbGVtZW50KGV2ZW50LnRhcmdldCwgJ21vdXNlbW92ZScsIGV2ZW50KTtcbi8vICAgICB9XG4vLyAgICAgaWYgKGV2ZW50LnNjYWxlICE9PSAxKSB7XG4vLyAgICAgICAgIGV2ZW50LnBpbmNoWCA9IGV2ZW50Lm9mZnNldFg7XG4vLyAgICAgICAgIGV2ZW50LnBpbmNoWSA9IGV2ZW50Lm9mZnNldFk7XG4vLyAgICAgICAgIGV2ZW50LnBpbmNoU2NhbGUgPSBldmVudC5zY2FsZTtcbi8vICAgICAgICAgcHJveHkuaGFuZGxlci5kaXNwYXRjaFRvRWxlbWVudChldmVudC50YXJnZXQsICdwaW5jaCcsIGV2ZW50KTtcbi8vICAgICB9XG4vLyB9XG5cbi8qKlxuICogUHJldmVudCBtb3VzZSBldmVudCBmcm9tIGJlaW5nIGRpc3BhdGNoZWQgYWZ0ZXIgVG91Y2ggRXZlbnRzIGFjdGlvblxuICogQHNlZSA8aHR0cHM6Ly9naXRodWIuY29tL2RlbHRha29zaC9oYW5kanMvYmxvYi9tYXN0ZXIvc3JjL2hhbmQuYmFzZS5qcz5cbiAqIDEuIE1vYmlsZSBicm93c2VycyBkaXNwYXRjaCBtb3VzZSBldmVudHMgMzAwbXMgYWZ0ZXIgdG91Y2hlbmQuXG4gKiAyLiBDaHJvbWUgZm9yIEFuZHJvaWQgZGlzcGF0Y2ggbW91c2Vkb3duIGZvciBsb25nLXRvdWNoIGFib3V0IDY1MG1zXG4gKiBSZXN1bHQ6IEJsb2NraW5nIE1vdXNlIEV2ZW50cyBmb3IgNzAwbXMuXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRUb3VjaFRpbWVyKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLl90b3VjaGluZyA9IHRydWU7XG4gIGNsZWFyVGltZW91dChpbnN0YW5jZS5fdG91Y2hUaW1lcik7XG4gIGluc3RhbmNlLl90b3VjaFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaW5zdGFuY2UuX3RvdWNoaW5nID0gZmFsc2U7XG4gIH0sIDcwMCk7XG59XG5cbnZhciBkb21IYW5kbGVycyA9IHtcbiAgLyoqXG4gICAqIE1vdXNlIG1vdmUgaGFuZGxlclxuICAgKiBAaW5uZXJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICovXG4gIG1vdXNlbW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuICAgIHRoaXMudHJpZ2dlcignbW91c2Vtb3ZlJywgZXZlbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3VzZSBvdXQgaGFuZGxlclxuICAgKiBAaW5uZXJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICovXG4gIG1vdXNlb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgdmFyIGVsZW1lbnQgPSBldmVudC50b0VsZW1lbnQgfHwgZXZlbnQucmVsYXRlZFRhcmdldDtcblxuICAgIGlmIChlbGVtZW50ICE9IHRoaXMuZG9tKSB7XG4gICAgICB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlICE9IDkpIHtcbiAgICAgICAgLy8g5b+955Wl5YyF5ZCr5Zyocm9vdOS4reeahGRvbeW8lei1t+eahG1vdXNlT3V0XG4gICAgICAgIGlmIChlbGVtZW50ID09PSB0aGlzLmRvbSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50cmlnZ2VyKCdtb3VzZW91dCcsIGV2ZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogVG91Y2jlvIDlp4vlk43lupTlh73mlbBcbiAgICogQGlubmVyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqL1xuICB0b3VjaHN0YXJ0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBEZWZhdWx0IG1vdXNlIGJlaGF2aW91ciBzaG91bGQgbm90IGJlIGRpc2FibGVkIGhlcmUuXG4gICAgLy8gRm9yIGV4YW1wbGUsIHBhZ2UgbWF5IG5lZWRzIHRvIGJlIHNsaWRlZC5cbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7IC8vIE1hcmsgdG91Y2gsIHdoaWNoIGlzIHVzZWZ1bCBpbiBkaXN0aW5ndWlzaCB0b3VjaCBhbmRcbiAgICAvLyBtb3VzZSBldmVudCBpbiB1cHBlciBhcHBsaWNhdG9pbi5cblxuICAgIGV2ZW50LnpyQnlUb3VjaCA9IHRydWU7XG4gICAgdGhpcy5fbGFzdFRvdWNoTW9tZW50ID0gbmV3IERhdGUoKTtcbiAgICBwcm9jZXNzR2VzdHVyZSh0aGlzLCBldmVudCwgJ3N0YXJ0Jyk7IC8vIEluIHRvdWNoIGRldmljZSwgdHJpZ2dlciBgbW91c2Vtb3ZlYChgbW91c2VvdmVyYCkgc2hvdWxkXG4gICAgLy8gYmUgdHJpZ2dlcmVkLCBhbmQgbXVzdCBiZWZvcmUgYG1vdXNlZG93bmAgdHJpZ2dlcmVkLlxuXG4gICAgZG9tSGFuZGxlcnMubW91c2Vtb3ZlLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIGRvbUhhbmRsZXJzLm1vdXNlZG93bi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUb3VjaOenu+WKqOWTjeW6lOWHveaVsFxuICAgKiBAaW5uZXJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICovXG4gIHRvdWNobW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpOyAvLyBNYXJrIHRvdWNoLCB3aGljaCBpcyB1c2VmdWwgaW4gZGlzdGluZ3Vpc2ggdG91Y2ggYW5kXG4gICAgLy8gbW91c2UgZXZlbnQgaW4gdXBwZXIgYXBwbGljYXRvaW4uXG5cbiAgICBldmVudC56ckJ5VG91Y2ggPSB0cnVlO1xuICAgIHByb2Nlc3NHZXN0dXJlKHRoaXMsIGV2ZW50LCAnY2hhbmdlJyk7IC8vIE1vdXNlIG1vdmUgc2hvdWxkIGFsd2F5cyBiZSB0cmlnZ2VyZWQgbm8gbWF0dGVyIHdoZXRoZXJcbiAgICAvLyB0aGVyZSBpcyBnZXN0cnVlIGV2ZW50LCBiZWNhdXNlIG1vdXNlIG1vdmUgYW5kIHBpbmNoIG1heVxuICAgIC8vIGJlIHVzZWQgYXQgdGhlIHNhbWUgdGltZS5cblxuICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUb3VjaOe7k+adn+WTjeW6lOWHveaVsFxuICAgKiBAaW5uZXJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICovXG4gIHRvdWNoZW5kOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7IC8vIE1hcmsgdG91Y2gsIHdoaWNoIGlzIHVzZWZ1bCBpbiBkaXN0aW5ndWlzaCB0b3VjaCBhbmRcbiAgICAvLyBtb3VzZSBldmVudCBpbiB1cHBlciBhcHBsaWNhdG9pbi5cblxuICAgIGV2ZW50LnpyQnlUb3VjaCA9IHRydWU7XG4gICAgcHJvY2Vzc0dlc3R1cmUodGhpcywgZXZlbnQsICdlbmQnKTtcbiAgICBkb21IYW5kbGVycy5tb3VzZXVwLmNhbGwodGhpcywgZXZlbnQpOyAvLyBEbyBub3QgdHJpZ2dlciBgbW91c2VvdXRgIGhlcmUsIGluIHNwaXRlIG9mIGBtb3VzZW1vdmVgKGBtb3VzZW92ZXJgKSBpc1xuICAgIC8vIHRyaWdnZXJlZCBpbiBgdG91Y2hzdGFydGAuIFRoaXMgc2VlbXMgdG8gYmUgaWxsb2dpY2FsLCBidXQgYnkgdGhpcyBtZWNoYW5pc20sXG4gICAgLy8gd2UgY2FuIGNvbnZlbmllbnRseSBpbXBsZW1lbnQgXCJob3ZlciBzdHlsZVwiIGluIGJvdGggUEMgYW5kIHRvdWNoIGRldmljZSBqdXN0XG4gICAgLy8gYnkgbGlzdGVuaW5nIHRvIGBtb3VzZW92ZXJgIHRvIGFkZCBcImhvdmVyIHN0eWxlXCIgYW5kIGxpc3RlbmluZyB0byBgbW91c2VvdXRgXG4gICAgLy8gdG8gcmVtb3ZlIFwiaG92ZXIgc3R5bGVcIiBvbiBhbiBlbGVtZW50LCB3aXRob3V0IGFueSBhZGRpdGlvbmFsIGNvZGUgZm9yXG4gICAgLy8gY29tcGF0aWJpbGl0eS4gKGBtb3VzZW91dGAgd2lsbCBub3QgYmUgdHJpZ2dlcmVkIGluIGB0b3VjaGVuZGAsIHNvIFwiaG92ZXJcbiAgICAvLyBzdHlsZVwiIHdpbGwgcmVtYWluIGZvciB1c2VyIHZpZXcpXG4gICAgLy8gY2xpY2sgZXZlbnQgc2hvdWxkIGFsd2F5cyBiZSB0cmlnZ2VyZWQgbm8gbWF0dGVyIHdoZXRoZXJcbiAgICAvLyB0aGVyZSBpcyBnZXN0cnVlIGV2ZW50LiBTeXN0ZW0gY2xpY2sgY2FuIG5vdCBiZSBwcmV2ZW50ZWQuXG5cbiAgICBpZiAoK25ldyBEYXRlKCkgLSB0aGlzLl9sYXN0VG91Y2hNb21lbnQgPCBUT1VDSF9DTElDS19ERUxBWSkge1xuICAgICAgZG9tSGFuZGxlcnMuY2xpY2suY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuXG4gICAgc2V0VG91Y2hUaW1lcih0aGlzKTtcbiAgfSxcbiAgcG9pbnRlcmRvd246IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGRvbUhhbmRsZXJzLm1vdXNlZG93bi5jYWxsKHRoaXMsIGV2ZW50KTsgLy8gaWYgKHVzZU1TR3Vlc3R1cmUodGhpcywgZXZlbnQpKSB7XG4gICAgLy8gICAgIHRoaXMuX21zR2VzdHVyZS5hZGRQb2ludGVyKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgLy8gfVxuICB9LFxuICBwb2ludGVybW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gRklYTUVcbiAgICAvLyBwb2ludGVybW92ZSBpcyBzbyBzZW5zaXRpdmUgdGhhdCBpdCBhbHdheXMgdHJpZ2dlcmVkIHdoZW5cbiAgICAvLyB0YXAoY2xpY2spIG9uIHRvdWNoIHNjcmVlbiwgd2hpY2ggYWZmZWN0IHNvbWUganVkZ2VtZW50IGluXG4gICAgLy8gdXBwZXIgYXBwbGljYXRpb24uIFNvLCB3ZSBkb250IHN1cHBvcnQgbW91c2Vtb3ZlIG9uIE1TIHRvdWNoXG4gICAgLy8gZGV2aWNlIHlldC5cbiAgICBpZiAoIWlzUG9pbnRlckZyb21Ub3VjaChldmVudCkpIHtcbiAgICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH0sXG4gIHBvaW50ZXJ1cDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZG9tSGFuZGxlcnMubW91c2V1cC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgfSxcbiAgcG9pbnRlcm91dDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gcG9pbnRlcm91dCB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIHRhcCBvbiB0b3VjaCBzY3JlZW5cbiAgICAvLyAoSUUxMSsvRWRnZSBvbiBNUyBTdXJmYWNlKSBhZnRlciBjbGljayBldmVudCB0cmlnZ2VyZWQsXG4gICAgLy8gd2hpY2ggaXMgaW5jb25zaXN0ZW50IHdpdGggdGhlIG1vdXNvdXQgYmVoYXZpb3Igd2UgZGVmaW5lZFxuICAgIC8vIGluIHRvdWNoZW5kLiBTbyB3ZSB1bmlmeSB0aGVtLlxuICAgIC8vIChjaGVjayBkb21IYW5kbGVycy50b3VjaGVuZCBmb3IgZGV0YWlsZWQgZXhwbGFuYXRpb24pXG4gICAgaWYgKCFpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpKSB7XG4gICAgICBkb21IYW5kbGVycy5tb3VzZW91dC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzUG9pbnRlckZyb21Ub3VjaChldmVudCkge1xuICB2YXIgcG9pbnRlclR5cGUgPSBldmVudC5wb2ludGVyVHlwZTtcbiAgcmV0dXJuIHBvaW50ZXJUeXBlID09PSAncGVuJyB8fCBwb2ludGVyVHlwZSA9PT0gJ3RvdWNoJztcbn0gLy8gZnVuY3Rpb24gdXNlTVNHdWVzdHVyZShoYW5kbGVyUHJveHksIGV2ZW50KSB7XG4vLyAgICAgcmV0dXJuIGlzUG9pbnRlckZyb21Ub3VjaChldmVudCkgJiYgISFoYW5kbGVyUHJveHkuX21zR2VzdHVyZTtcbi8vIH1cbi8vIENvbW1vbiBoYW5kbGVyc1xuXG5cbnpyVXRpbC5lYWNoKFsnY2xpY2snLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnbW91c2V3aGVlbCcsICdkYmxjbGljaycsICdjb250ZXh0bWVudSddLCBmdW5jdGlvbiAobmFtZSkge1xuICBkb21IYW5kbGVyc1tuYW1lXSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcbiAgICB0aGlzLnRyaWdnZXIobmFtZSwgZXZlbnQpO1xuICB9O1xufSk7XG4vKipcbiAqIOS4uuaOp+WItuexu+WunuS+i+WIneWni+WMlmRvbSDkuovku7blpITnkIblh73mlbBcbiAqXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvSGFuZGxlcn0gaW5zdGFuY2Ug5o6n5Yi257G75a6e5L6LXG4gKi9cblxuZnVuY3Rpb24gaW5pdERvbUhhbmRsZXIoaW5zdGFuY2UpIHtcbiAgenJVdGlsLmVhY2godG91Y2hIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaW5zdGFuY2UuX2hhbmRsZXJzW25hbWVdID0genJVdGlsLmJpbmQoZG9tSGFuZGxlcnNbbmFtZV0sIGluc3RhbmNlKTtcbiAgfSk7XG4gIHpyVXRpbC5lYWNoKHBvaW50ZXJIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaW5zdGFuY2UuX2hhbmRsZXJzW25hbWVdID0genJVdGlsLmJpbmQoZG9tSGFuZGxlcnNbbmFtZV0sIGluc3RhbmNlKTtcbiAgfSk7XG4gIHpyVXRpbC5lYWNoKG1vdXNlSGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSA9IG1ha2VNb3VzZUhhbmRsZXIoZG9tSGFuZGxlcnNbbmFtZV0sIGluc3RhbmNlKTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gbWFrZU1vdXNlSGFuZGxlcihmbiwgaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGluc3RhbmNlLl90b3VjaGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbi5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIEhhbmRsZXJEb21Qcm94eShkb20pIHtcbiAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcbiAgdGhpcy5kb20gPSBkb207XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG5cbiAgdGhpcy5fdG91Y2hpbmcgPSBmYWxzZTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuX3RvdWNoVGltZXI7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9HZXN0dXJlTWdyfVxuICAgKi9cblxuICB0aGlzLl9nZXN0dXJlTWdyID0gbmV3IEdlc3R1cmVNZ3IoKTtcbiAgdGhpcy5faGFuZGxlcnMgPSB7fTtcbiAgaW5pdERvbUhhbmRsZXIodGhpcyk7XG5cbiAgaWYgKGVudi5wb2ludGVyRXZlbnRzU3VwcG9ydGVkKSB7XG4gICAgLy8gT25seSBJRTExKy9FZGdlXG4gICAgLy8gMS4gT24gZGV2aWNlcyB0aGF0IGJvdGggZW5hYmxlIHRvdWNoIGFuZCBtb3VzZSAoZS5nLiwgTVMgU3VyZmFjZSBhbmQgbGVub3ZvIFgyNDApLFxuICAgIC8vIElFMTErL0VkZ2UgZG8gbm90IHRyaWdnZXIgdG91Y2ggZXZlbnQsIGJ1dCB0cmlnZ2VyIHBvaW50ZXIgZXZlbnQgYW5kIG1vdXNlIGV2ZW50XG4gICAgLy8gYXQgdGhlIHNhbWUgdGltZS5cbiAgICAvLyAyLiBPbiBNUyBTdXJmYWNlLCBpdCBwcm9iYWJsZWx5IG9ubHkgdHJpZ2dlciBtb3VzZWRvd24gYnV0IG5vIG1vdXNldXAgd2hlbiB0YXAgb25cbiAgICAvLyBzY3JlZW4sIHdoaWNoIGRvIG5vdCBvY2N1cnMgaW4gcG9pbnRlciBldmVudC5cbiAgICAvLyBTbyB3ZSB1c2UgcG9pbnRlciBldmVudCB0byBib3RoIGRldGVjdCB0b3VjaCBnZXN0dXJlIGFuZCBtb3VzZSBiZWhhdmlvci5cbiAgICBtb3VudEhhbmRsZXJzKHBvaW50ZXJIYW5kbGVyTmFtZXMsIHRoaXMpOyAvLyBGSVhNRVxuICAgIC8vIE5vdGU6IE1TIEdlc3R1cmUgcmVxdWlyZSBDU1MgdG91Y2gtYWN0aW9uIHNldC4gQnV0IHRvdWNoLWFjdGlvbiBpcyBub3QgcmVsaWFibGUsXG4gICAgLy8gd2hpY2ggZG9lcyBub3QgcHJldmVudCBkZWZ1YXVsdCBiZWhhdmlvciBvY2Nhc2lvbmFsbHkgKHdoaWNoIG1heSBjYXVzZSB2aWV3IHBvcnRcbiAgICAvLyB6b29tZWQgaW4gYnV0IHVzZSBjYW4gbm90IHpvb20gaXQgYmFjaykuIEFuZCBldmVudC5wcmV2ZW50RGVmYXVsdCgpIGRvZXMgbm90IHdvcmsuXG4gICAgLy8gU28gd2UgaGF2ZSB0byBub3QgdG8gdXNlIE1TR2VzdHVyZSBhbmQgbm90IHRvIHN1cHBvcnQgdG91Y2htb3ZlIGFuZCBwaW5jaCBvbiBNU1xuICAgIC8vIHRvdWNoIHNjcmVlbi4gQW5kIHdlIG9ubHkgc3VwcG9ydCBjbGljayBiZWhhdmlvciBvbiBNUyB0b3VjaCBzY3JlZW4gbm93LlxuICAgIC8vIE1TIEdlc3R1cmUgRXZlbnQgaXMgb25seSBzdXBwb3J0ZWQgb24gSUUxMSsvRWRnZSBhbmQgb24gV2luZG93cyA4Ky5cbiAgICAvLyBXZSBkb250IHN1cHBvcnQgdG91Y2ggb24gSUUgb24gd2luNy5cbiAgICAvLyBTZWUgPGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZG40MzMyNDModj12cy44NSkuYXNweD5cbiAgICAvLyBpZiAodHlwZW9mIE1TR2VzdHVyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vICAgICAodGhpcy5fbXNHZXN0dXJlID0gbmV3IE1TR2VzdHVyZSgpKS50YXJnZXQgPSBkb207IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIC8vICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcignTVNHZXN0dXJlQ2hhbmdlJywgb25NU0dlc3R1cmVDaGFuZ2UpO1xuICAgIC8vIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZW52LnRvdWNoRXZlbnRzU3VwcG9ydGVkKSB7XG4gICAgICBtb3VudEhhbmRsZXJzKHRvdWNoSGFuZGxlck5hbWVzLCB0aGlzKTsgLy8gSGFuZGxlciBvZiAnbW91c2VvdXQnIGV2ZW50IGlzIG5lZWRlZCBpbiB0b3VjaCBtb2RlLCB3aGljaCB3aWxsIGJlIG1vdW50ZWQgYmVsb3cuXG4gICAgICAvLyBhZGRFdmVudExpc3RlbmVyKHJvb3QsICdtb3VzZW91dCcsIHRoaXMuX21vdXNlb3V0SGFuZGxlcik7XG4gICAgfSAvLyAxLiBDb25zaWRlcmluZyBzb21lIGRldmljZXMgdGhhdCBib3RoIGVuYWJsZSB0b3VjaCBhbmQgbW91c2UgZXZlbnQgKGxpa2Ugb24gTVMgU3VyZmFjZVxuICAgIC8vIGFuZCBsZW5vdm8gWDI0MCwgQHNlZSAjMjM1MCksIHdlIG1ha2UgbW91c2UgZXZlbnQgYmUgYWx3YXlzIGxpc3RlbmVkLCBvdGhlcndpc2VcbiAgICAvLyBtb3VzZSBldmVudCBjYW4gbm90IGJlIGhhbmRsZSBpbiB0aG9zZSBkZXZpY2VzLlxuICAgIC8vIDIuIE9uIE1TIFN1cmZhY2UsIENocm9tZSB3aWxsIHRyaWdnZXIgYm90aCB0b3VjaCBldmVudCBhbmQgbW91c2UgZXZlbnQuIEhvdyB0byBwcmV2ZW50XG4gICAgLy8gbW91c2VldmVudCBhZnRlciB0b3VjaCBldmVudCB0cmlnZ2VyZWQsIHNlZSBgc2V0VG91Y2hUaW1lcmAuXG5cblxuICAgIG1vdW50SGFuZGxlcnMobW91c2VIYW5kbGVyTmFtZXMsIHRoaXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91bnRIYW5kbGVycyhoYW5kbGVyTmFtZXMsIGluc3RhbmNlKSB7XG4gICAgenJVdGlsLmVhY2goaGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihkb20sIGV2ZW50TmFtZUZpeChuYW1lKSwgaW5zdGFuY2UuX2hhbmRsZXJzW25hbWVdKTtcbiAgICB9LCBpbnN0YW5jZSk7XG4gIH1cbn1cblxudmFyIGhhbmRsZXJEb21Qcm94eVByb3RvID0gSGFuZGxlckRvbVByb3h5LnByb3RvdHlwZTtcblxuaGFuZGxlckRvbVByb3h5UHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhhbmRsZXJOYW1lcyA9IG1vdXNlSGFuZGxlck5hbWVzLmNvbmNhdCh0b3VjaEhhbmRsZXJOYW1lcyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IGhhbmRsZXJOYW1lc1tpXTtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuZG9tLCBldmVudE5hbWVGaXgobmFtZSksIHRoaXMuX2hhbmRsZXJzW25hbWVdKTtcbiAgfVxufTtcblxuaGFuZGxlckRvbVByb3h5UHJvdG8uc2V0Q3Vyc29yID0gZnVuY3Rpb24gKGN1cnNvclN0eWxlKSB7XG4gIHRoaXMuZG9tLnN0eWxlLmN1cnNvciA9IGN1cnNvclN0eWxlIHx8ICdkZWZhdWx0Jztcbn07XG5cbnpyVXRpbC5taXhpbihIYW5kbGVyRG9tUHJveHksIEV2ZW50ZnVsKTtcbnZhciBfZGVmYXVsdCA9IEhhbmRsZXJEb21Qcm94eTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2RvbS9IYW5kbGVyUHJveHkuanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBldmVudFV0aWwgPSByZXF1aXJlKFwiLi9ldmVudFwiKTtcblxuLyoqXG4gKiBPbmx5IGltcGxlbWVudHMgbmVlZGVkIGdlc3R1cmVzIGZvciBtb2JpbGUuXG4gKi9cbnZhciBHZXN0dXJlTWdyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgKi9cbiAgdGhpcy5fdHJhY2sgPSBbXTtcbn07XG5cbkdlc3R1cmVNZ3IucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogR2VzdHVyZU1ncixcbiAgcmVjb2duaXplOiBmdW5jdGlvbiAoZXZlbnQsIHRhcmdldCwgcm9vdCkge1xuICAgIHRoaXMuX2RvVHJhY2soZXZlbnQsIHRhcmdldCwgcm9vdCk7XG5cbiAgICByZXR1cm4gdGhpcy5fcmVjb2duaXplKGV2ZW50KTtcbiAgfSxcbiAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl90cmFjay5sZW5ndGggPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfZG9UcmFjazogZnVuY3Rpb24gKGV2ZW50LCB0YXJnZXQsIHJvb3QpIHtcbiAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LnRvdWNoZXM7XG5cbiAgICBpZiAoIXRvdWNoZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdHJhY2tJdGVtID0ge1xuICAgICAgcG9pbnRzOiBbXSxcbiAgICAgIHRvdWNoZXM6IFtdLFxuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBldmVudDogZXZlbnRcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRvdWNoZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciB0b3VjaCA9IHRvdWNoZXNbaV07XG4gICAgICB2YXIgcG9zID0gZXZlbnRVdGlsLmNsaWVudFRvTG9jYWwocm9vdCwgdG91Y2gsIHt9KTtcbiAgICAgIHRyYWNrSXRlbS5wb2ludHMucHVzaChbcG9zLnpyWCwgcG9zLnpyWV0pO1xuICAgICAgdHJhY2tJdGVtLnRvdWNoZXMucHVzaCh0b3VjaCk7XG4gICAgfVxuXG4gICAgdGhpcy5fdHJhY2sucHVzaCh0cmFja0l0ZW0pO1xuICB9LFxuICBfcmVjb2duaXplOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcmVjb2duaXplcnMpIHtcbiAgICAgIGlmIChyZWNvZ25pemVycy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgIHZhciBnZXN0dXJlSW5mbyA9IHJlY29nbml6ZXJzW2V2ZW50TmFtZV0odGhpcy5fdHJhY2ssIGV2ZW50KTtcblxuICAgICAgICBpZiAoZ2VzdHVyZUluZm8pIHtcbiAgICAgICAgICByZXR1cm4gZ2VzdHVyZUluZm87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRpc3QocG9pbnRQYWlyKSB7XG4gIHZhciBkeCA9IHBvaW50UGFpclsxXVswXSAtIHBvaW50UGFpclswXVswXTtcbiAgdmFyIGR5ID0gcG9pbnRQYWlyWzFdWzFdIC0gcG9pbnRQYWlyWzBdWzFdO1xuICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbn1cblxuZnVuY3Rpb24gY2VudGVyKHBvaW50UGFpcikge1xuICByZXR1cm4gWyhwb2ludFBhaXJbMF1bMF0gKyBwb2ludFBhaXJbMV1bMF0pIC8gMiwgKHBvaW50UGFpclswXVsxXSArIHBvaW50UGFpclsxXVsxXSkgLyAyXTtcbn1cblxudmFyIHJlY29nbml6ZXJzID0ge1xuICBwaW5jaDogZnVuY3Rpb24gKHRyYWNrLCBldmVudCkge1xuICAgIHZhciB0cmFja0xlbiA9IHRyYWNrLmxlbmd0aDtcblxuICAgIGlmICghdHJhY2tMZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGluY2hFbmQgPSAodHJhY2tbdHJhY2tMZW4gLSAxXSB8fCB7fSkucG9pbnRzO1xuICAgIHZhciBwaW5jaFByZSA9ICh0cmFja1t0cmFja0xlbiAtIDJdIHx8IHt9KS5wb2ludHMgfHwgcGluY2hFbmQ7XG5cbiAgICBpZiAocGluY2hQcmUgJiYgcGluY2hQcmUubGVuZ3RoID4gMSAmJiBwaW5jaEVuZCAmJiBwaW5jaEVuZC5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgcGluY2hTY2FsZSA9IGRpc3QocGluY2hFbmQpIC8gZGlzdChwaW5jaFByZSk7XG4gICAgICAhaXNGaW5pdGUocGluY2hTY2FsZSkgJiYgKHBpbmNoU2NhbGUgPSAxKTtcbiAgICAgIGV2ZW50LnBpbmNoU2NhbGUgPSBwaW5jaFNjYWxlO1xuICAgICAgdmFyIHBpbmNoQ2VudGVyID0gY2VudGVyKHBpbmNoRW5kKTtcbiAgICAgIGV2ZW50LnBpbmNoWCA9IHBpbmNoQ2VudGVyWzBdO1xuICAgICAgZXZlbnQucGluY2hZID0gcGluY2hDZW50ZXJbMV07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAncGluY2gnLFxuICAgICAgICB0YXJnZXQ6IHRyYWNrWzBdLnRhcmdldCxcbiAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICB9O1xuICAgIH1cbiAgfSAvLyBPbmx5IHBpbmNoIGN1cnJlbnRseS5cblxufTtcbnZhciBfZGVmYXVsdCA9IEdlc3R1cmVNZ3I7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL0dlc3R1cmVNZ3IuanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDpgInkuK3oioLngrnlkI7vvIzlh7rnjrDnmoTmk43kvZzmoYblj4rmjInpkq5cclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcbiAgICB2YXIgTm9kZSA9IHJlcXVpcmUoXCIuLi9Ob2RlXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC5qc1wiKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgQ29ubmVjdG9yID0gcmVxdWlyZShcIi4uL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9lbnYnKTtcclxuICAgIHZhciBpY29uID0gcmVxdWlyZSgnLi9JY29uT3BlcmF0aW9uJyk7XHJcbiAgICB2YXIgc3ltYm9sVXRpbCA9IHJlcXVpcmUoJy4uL3NoYXBlcy9TeW1ib2wnKTtcclxuICAgIGZ1bmN0aW9uIE9wZXJhdGlvbk5vZGUobm9kZSwgenIsIGFwaSxmb3JiaWRFZGl0KSB7XHJcbiAgICAgICAgTm9kZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XHJcbiAgICAgICAgdGhpcy56ciA9IHpyO1xyXG4gICAgICAgIHRoaXMuZm9yYmlkRWRpdCA9IGZvcmJpZEVkaXQ7XHJcbiAgICAgICAgdGhpcy5fYXBpID0gYXBpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy/kuovku7ZcclxuICAgIE9wZXJhdGlvbk5vZGUuQVJST1dfRFJBR0VORCA9IFwiT3BlcmF0aW9uTm9kZTpkcmFnZW5kQXJyb3dcIjtcclxuICAgIE9wZXJhdGlvbk5vZGUuQVJST1dfRFJBRyA9IFwiT3BlcmF0aW9uTm9kZTpkcmFnQXJyb3dcIjtcclxuICAgIE9wZXJhdGlvbk5vZGUuQVJST1dfRFJBR1NUQVJUID0gXCJPcGVyYXRpb25Ob2RlOmRyYWdzdGFydEFycm93XCI7XHJcbiAgICBPcGVyYXRpb25Ob2RlLkRFTEVURV9DTElDSyA9IFwiT3BlcmF0aW9uTm9kZTpkZWxldGVDbGlja1wiO1xyXG4gICAgT3BlcmF0aW9uTm9kZS5ERUwgPSBcIkRFTFwiO1xyXG4gICAgT3BlcmF0aW9uTm9kZS5DT01NRU5UX0NMSUNLID0gXCJPcGVyYXRpb25Ob2RlOmNvbW1lbnRDbGlja1wiO1xyXG4gICAgT3BlcmF0aW9uTm9kZS5DT01NRU5UID0gXCJDT01NRU5UXCI7XHJcbiAgICAgICAgLy/lhoXnva7mk43kvZzlm77moIfnmoTlm77lg49cclxuICAgIE9wZXJhdGlvbk5vZGUub3BpY29ucyA9IHtcclxuICAgICAgICBTVFJBSUdIVDogaWNvbi5TVFJBSUdIVF9TVkcsXHJcbiAgICAgICAgSkFHR0VEOiBpY29uLkpBR0dFRF9TVkcsXHJcbiAgICAgICAgQ1VSVkU6IGljb24uQ1VSVkVfU1ZHLFxyXG4gICAgICAgIERFTDogaWNvbi5ERUxfU1ZHLFxyXG4gICAgICAgIENPTU1FTlQ6IGljb24uQ09NTUVOVF9TVkdcclxuICAgIH07XHJcblxyXG4gICAgT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJCYXNlKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmZvcmJpZEVkaXQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJPdGhlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUucmVuZGVyQmFzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuY3JlYXRlT3BlcmF0aW9uKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIE9wZXJhdGlvbk5vZGUucHJvdG90eXBlLmNyZWF0ZU9wZXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGlmU2hvd05vZGVPcGVyYXRpb25JY29ucyA9IHRoaXMubm9kZS5vcGVyYXRpb25JY29ucztcclxuICAgICAgICBpZiAodGhpcy5ub2RlLnBhcmVudCAmJiB0aGlzLm5vZGUucGFyZW50LnR5cGUgPT09ICdkcmFnU2VsZWN0Jykge1xyXG4gICAgICAgICAgICBpZlNob3dOb2RlT3BlcmF0aW9uSWNvbnMgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vZGUuc2VsZWN0U3R5bGUpIHtcclxuICAgICAgICAgICAgdGhpcy52aXJ0dWFsUmVjdCA9IG5ldyBncmFwaGljLlBvbHlsaW5lKHsgc3R5bGU6IHsgbGluZURhc2g6IFsyXSB9IH0pO1xyXG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxSZWN0LmlzU2VsZkNvbXB1dGVQb3MgPSB0cnVlOyAgLy8g6Ieq5bex6K6h566X5L2N572uXHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHRoaXMudmlydHVhbFJlY3QpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICBpZiAodGhpcy5ub2RlLnR5cGUgPT09ICdaUGF0aCcpIHsgIC8vYWRkSG92ZXLpnIDopoHku47lroPoh6rouqvnmoTmnoTpgKDlh73mlbDkuK3liJvlu7rjgIIxLlBhaW50ZXLkuK1hZGRIb3Zlcua6kOeggeaYr+agueaNrnNoYXBl5LiOc3R5bGXliJvlu7ogMi5wYXRo5Lit55qE5p6E6YCg5Ye95pWw5piv6L+U5Zue5Y+m5LiA5Liq5YWD57SgXHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGUuX3pDbG9uZVN0eWxlID0gdGhpcy5ub2RlLnN0eWxlLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgdGhpcy5ub2RlLnNldFN0eWxlKHRoaXMubm9kZS5zZWxlY3RTdHlsZSk7XHJcbiAgICAgICAgICAgICB9IGVsc2UgaWYodGhpcy5ub2RlLnNldE9yQ2FuY2VsU2VsZWN0U3R5bGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZS5zZXRPckNhbmNlbFNlbGVjdFN0eWxlKHRydWUpO1xyXG4gICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwaS5nZXRacigpLmFkZEhvdmVyKHRoaXMubm9kZSwgdGhpcy5ub2RlLnNlbGVjdFN0eWxlKTtcclxuICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaWZTaG93Tm9kZU9wZXJhdGlvbkljb25zKSB7XHJcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHRoaXMubm9kZS5vcGVyYXRpb25JY29ucywgZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgLy/mo4Dmn6XmmK/lkKbmmK/lhoXnva7lm77moIdcclxuICAgICAgICAgICAgICAgIHZhciBvcEljb25JbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3BlcmF0aW9uSWNvbiA9IE9wZXJhdGlvbk5vZGUub3BpY29uc1tpdGVtLm5hbWUudG9VcHBlckNhc2UoKSArIFwiXCJdXHJcbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uSWNvbikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mb3JiaWRFZGl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uaGlkZGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ubmFtZSA9PSBPcGVyYXRpb25Ob2RlLkRFTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+Weg+WcvuahtlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZSA9IGdyYXBoaWMubWFrZVBhdGgob3BlcmF0aW9uSWNvbiwgeyBzdHlsZTogeyBmaWxsOiAnI2FhYWFhYycgfSx6Om1lLm5vZGUueisxLHJlY3RIb3ZlcjogdHJ1ZSB9LCB7IHg6IDAsIHk6IDAsIHdpZHRoOiAxMCwgaGVpZ2h0OiAxNSB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0uY2FsbGJhY2spe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2Uub24oXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5kYXRhID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLm5vZGUgPSBtZS5ub2RlOyAgLy8g5bCG5omA6ZmE55qE6IqC54K55Lmf5Lyg6YCS5Ye65Y67XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jYWxsYmFjayhlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMudGFyZ2V0ID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IE9wZXJhdGlvbk5vZGUuREVMRVRFX0NMSUNLO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5uYW1lID09IE9wZXJhdGlvbk5vZGUuQ09NTUVOVCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHsgeDogMCwgeTogMCwgd2lkdGg6IDE2LCBoZWlnaHQ6IDE2IH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wSWNvbkluc3RhbmNlID0gZ3JhcGhpYy5tYWtlUGF0aChvcGVyYXRpb25JY29uLCB7IHN0eWxlOiB7IGZpbGw6ICcjYWFhYWFjJyB9LCB6Om1lLm5vZGUueisyLCByZWN0SG92ZXI6IHRydWUgfSwgcmVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wSWNvbkluc3RhbmNlLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy50YXJnZXQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBPcGVyYXRpb25Ob2RlLkNPTU1FTlRfQ0xJQ0s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdE90aGVyID0geyB4OiAwLCB5OiAwLCB3aWR0aDogMTUsIGhlaWdodDogMTUgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2UgPSBncmFwaGljLm1ha2VQYXRoKG9wZXJhdGlvbkljb24sIHsgc3R5bGU6IHsgZmlsbDogJyNhYWFhYWMnIH0sZHJhZ2dhYmxlOnRydWUsejptZS5ub2RlLnorMixsaW5lVHlwZTogQ29ubmVjdG9yW1wiVFlQRV9cIiArIGl0ZW0ubmFtZS50b1VwcGVyQ2FzZSgpXSxyZWN0SG92ZXI6IHRydWUgfSwgcmVjdE90aGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE1PVVNFX0VWRU5UX05BTUVTID0gWydkcmFnc3RhcnQnLCAnZHJhZycsICdkcmFnZW5kJ107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKE1PVVNFX0VWRU5UX05BTUVTLCBmdW5jdGlvbihldmVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZS5vbihldmVOYW1lLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmRhdGEgPSBpdGVtLm9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IFwiT3BlcmF0aW9uTm9kZTpcIiArIGV2ZU5hbWUgKyBcIkFycm93XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZSA9IHN5bWJvbFV0aWwuY3JlYXRlU3ltYm9sKGl0ZW0uaWNvblBhdGgsIDAsIDAsIGl0ZW0ud2lkdGggfHwgMTUsIGl0ZW0uaGVpZ2h0IHx8IDE1LCBtZS5ub2RlLnorMSwgaXRlbS5jb2xvcnx8JyMwMDAnKTtcclxuICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5kYXRhID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5ub2RlID0gbWUubm9kZTsgIC8vIOWwhuaJgOmZhOeahOiKgueCueS5n+S8oOmAkuWHuuWOu1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5jYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jYWxsYmFjayhlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW0gPSB7ZXZlbnQ6ZSwgdHlwZTpcIk9wZXJhdGlvbk5vZGU6XCIgKyBpdGVtLm5hbWUgKyBcIkNsaWNrXCJ9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5fYXBpLnRyaWdnZXIocGFyYW0udHlwZSwgcGFyYW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2UubmFtZSA9IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgICAgIG1lLmFkZChvcEljb25JbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUucmVmcmVzaFBvc3Rpb24gPSBmdW5jdGlvbihub2RlLCBub2RlUmVjdCkge1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICB2YXIgcmJQb2ludCA9IHpyVXRpbC5jbG9uZShub2RlUmVjdC5wb2ludHNbMl0pOyAvL+WPluWPs+S4i+inkuWdkOagh1xyXG4gICAgICAgIHZhciByb3RhdGlvbiA9IG5vZGUucm90YXRpb247XHJcbiAgICAgICAgdmFyIGFuZ2xlID0gcm90YXRpb24gLyAoTWF0aC5QSS8xODApO1xyXG4gICAgICAgIGlmIChNYXRoLmFicyhyb3RhdGlvbikgPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBjb25uZWN0b3JDb250cm9scyA9IFV0aWwuZ2V0Q29ubmVjdG9yQ29udHJvbHMobm9kZVJlY3QsIG5vZGUpO1xyXG4gICAgICAgICAgICB2YXIgYnJDb250cm9sID0gY29ubmVjdG9yQ29udHJvbHMuYnI7XHJcbiAgICAgICAgICAgIHJiUG9pbnQgPSBbYnJDb250cm9sLnggLSBub2RlUmVjdC54LCAgYnJDb250cm9sLnkgLSBub2RlUmVjdC55XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8xLuWumuS9jeiZmuahhlxyXG4gICAgICAgIGlmICh0aGlzLnZpcnR1YWxSZWN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlydHVhbFJlY3Quc2V0U2hhcGUoeyBwb2ludHM6IG5vZGVSZWN0LnBvaW50cyB9KTtcclxuICAgICAgICAgICAgdGhpcy52aXJ0dWFsUmVjdC5hdHRyKCdyb3RhdGlvbicsIHJvdGF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8yLuWumuS9jeavj+S4quWwj+Wbvuagh1xyXG4gICAgICAgIHRoaXMuZWFjaENoaWxkKGZ1bmN0aW9uKG5vZGVJdGVtKSB7XHJcbiAgICAgICAgICAgIGlmICghbm9kZUl0ZW0uaXNTZWxmQ29tcHV0ZVBvcykge1xyXG4gICAgICAgICAgICAgICAgLy8gOHB45piv56ys5LiA5Liq5pON5L2c5oyJ6ZKu5Zu+5qCH55qE6Led56a7IOmdoOWkqui/keS4jeWlveeciyAgICAyMHB45piv5q+P5Liq5Zu+5qCH55qE6Ze06ZqUICAxMHB45piv5Zu+5qCH5ZCR5YGP55qE6Led56a7XHJcbiAgICAgICAgICAgICAgICBub2RlSXRlbS5hdHRyKFwicG9zaXRpb25cIiwgW2FuZ2xlID49IDAgPyByYlBvaW50WzBdICsgOCArIChpKysgKiAyMCkgOiByYlBvaW50WzBdIC0gMjAgLSAoaSsrICogMjApLCByYlBvaW50WzFdIC0gMTBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnJlZnJlc2hQb3NpdGlvbk90aGVyKG5vZGUsbm9kZVJlY3QpO1xyXG4gICAgfTtcclxuXHJcbiAgICBPcGVyYXRpb25Ob2RlLnByb3RvdHlwZS5yZW5kZXJPdGhlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8v55WZ57uZ5omp5bGV5L2/55SoXHJcbiAgICB9O1xyXG4gICAgT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUucmVmcmVzaFBvc2l0aW9uT3RoZXIgPSBmdW5jdGlvbihub2RlLG5vZGVSZWN0KSB7XHJcbiAgICAgICAgLy/nlZnnu5nmianlsZXkvb/nlKhcclxuICAgICAgICAvLzMu5a6a5L2N5pW05Liqb3BlcmF0aW9uTm9kZVxyXG4gICAgICAgIGlmICgobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQuaXNCZyAmJiBub2RlLnBhcmVudC5pc0JnID09IHRydWUpIHx8IChub2RlLnBhcmVudC50eXBlID09PSBcIkdyb3VwTm9kZVwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLmF0dHIoXCJwb3NpdGlvblwiLCBbbm9kZVJlY3QueCwgbm9kZVJlY3QueV0pXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIG5vZGVTaGFwZVggPSBub2RlLnNoYXBlPyBub2RlLnNoYXBlLng6MDtcclxuICAgICAgICAgICAgdmFyIG5vZGVTYWhwZVkgPSBub2RlLnNoYXBlPyBub2RlLnNoYXBlLnk6MDtcclxuICAgICAgICAgICAgdGhpcy5hdHRyKFwicG9zaXRpb25cIiwgW25vZGVSZWN0LnggKyBub2RlLnBhcmVudC5wb3NpdGlvblswXStub2RlU2hhcGVYLCBub2RlUmVjdC55ICsgbm9kZS5wYXJlbnQucG9zaXRpb25bMV0rbm9kZVNhaHBlWV0pXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBPcGVyYXRpb25Ob2RlLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYodGhpcy5ub2RlLnNlbGVjdFN0eWxlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGUudHlwZSA9PT0gJ1pQYXRoJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlLnNldFN0eWxlKHRoaXMubm9kZS5fekNsb25lU3R5bGUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYodGhpcy5ub2RlLnNldE9yQ2FuY2VsU2VsZWN0U3R5bGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZS5zZXRPckNhbmNlbFNlbGVjdFN0eWxlKGZhbHNlKTtcclxuICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcGkuZ2V0WnIoKS5yZW1vdmVIb3Zlcih0aGlzLm5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgenJVdGlsLmluaGVyaXRzKE9wZXJhdGlvbk5vZGUsIE5vZGUpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBPcGVyYXRpb25Ob2RlO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvT3BlcmF0aW9uTm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4vZ3JhcGhpYycpO1xyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsLmpzXCIpXHJcbiAgICAvL+WIm+W7uk5vZGXnsbsg5omA5pyJ5b2i54q26YO957un5om/Tm9kZSAg5YyF5ousZnJvbUpTT04gdG9KU09OXHJcbiAgICBmdW5jdGlvbiBOb2RlKCkge1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2VJZCA9IHV0aWwuZ2V0VVVJRCgpOyAvLyDnlJ/miJDoioLngrlJRFxyXG4gICAgICAgIGdyYXBoaWMuR3JvdXAuY2FsbCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOeUseeItuexu+WunueOsFxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIE5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnlLHniLbnsbvlrp7njrBcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0ganNvbiBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBOb2RlLnByb3RvdHlwZS5nZXRSZWN0ID0gZnVuY3Rpb24oanNvbikge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBkcmF3VGV4dFxyXG4gICAgICogQGRlc2NyaXB0aW9uIOeUu+S4gOS4quaWh+acrFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxyXG4gICAgICovXHJcbiAgICBOb2RlLnByb3RvdHlwZS5kcmF3VGV4dCA9IGZ1bmN0aW9uKG5hbWUsIGNvbG9yLCBwb3NpdGlvbikge1xyXG4gICAgICAgIHZhciB0ZXh0TmFtZSA9IHRoaXMuYnBtbkluZm8ubmFtZSwgeCwgeTtcclxuICAgICAgICBpZihuYW1lICE9IG51bGwpe1xyXG4gICAgICAgICAgICB0ZXh0TmFtZSA9IG5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0ZXh0ID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0TmFtZSxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvciA/IGNvbG9yIDogdGhpcy5vcHRpb25zLnRleHQuY29sb3IsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogJzEycHggTWljcm9zb2Z0IFlhSGVpJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6bGV2ZWw6IDIwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy/mloflrZfnu5jliLbnmoTkvY3nva4gXHJcbiAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA/IHBvc2l0aW9uIDogJ2luaXQnO1xyXG4gICAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcclxuICAgICAgICAgICAgLy/oioLngrnkuIvmlrnlsYXkuK3kvY3nva5cclxuICAgICAgICAgICAgY2FzZSAnaW5pdCc6IFxyXG4gICAgICAgICAgICAgICAgLy94ID0g5Lit5b+D54K5LnggLSDotbflp4vkvY3nva4ueCAtIOaWh+Wtl+WuveW6pueahOS4gOWNilxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMuZ2V0UmVjdCgpLnggLSB0aGlzLnBvc2l0aW9uWzBdIC0gdGV4dC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICAvL3kgPSDkuK3lv4PngrkueSAtIOi1t+Wni+S9jee9ri55ICsg5YGP56e75YC877yINu+8iVxyXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuZ2V0UmVjdCgpLnkgLSB0aGlzLnBvc2l0aW9uWzFdICsgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLyAyICsgNjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAvL+iKgueCueWGhemDqOWxheS4reS9jee9rlxyXG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMuZ2V0UmVjdCgpLnggLSB0aGlzLnBvc2l0aW9uWzBdIC0gdGV4dC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5nZXRSZWN0KCkueSAtIHRoaXMucG9zaXRpb25bMV0gLSA2O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIC8v6IqC54K55YaF6YOo5bGF5bem5L2N572uXHJcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOiBcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzLmdldFJlY3QoKS54IC0gdGhpcy5wb3NpdGlvblswXSAtIHRleHQuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggKyA2O1xyXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuZ2V0UmVjdCgpLnkgLSB0aGlzLnBvc2l0aW9uWzFdIC0gNjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OiBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGV4dC5hdHRyKFwic3R5bGVcIiwgeyB4OiB4LCB5OiB5IH0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRleHQ6IHRleHQsXHJcbiAgICAgICAgICAgIHJlY3Q6IHRleHQuZ2V0Qm91bmRpbmdSZWN0KClcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogcmVmcmVzaFRleHRcclxuICAgICAqIEBkZXNjcmlwdGlvbiDliLfmlrDmlofmnKxcclxuICAgICAqL1xyXG4gICAgTm9kZS5wcm90b3R5cGUucmVmcmVzaFRleHQgPSBmdW5jdGlvbihwb3MpIHtcclxuICAgICAgICB2YXIgdGV4dCA9IHRoaXMuY2hpbGRPZk5hbWUoXCJUaXRsZVwiKSwgeCwgeTtcclxuICAgICAgICBwb3MgPSBwb3MgPyBwb3MgOiAnaW5pdCc7XHJcbiAgICAgICAgc3dpdGNoIChwb3MpIHtcclxuICAgICAgICAgICAgY2FzZSAnaW5pdCc6IFxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMuZ2V0UmVjdCgpLnggLSB0aGlzLnBvc2l0aW9uWzBdIC0gdGV4dC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5nZXRSZWN0KCkueSAtIHRoaXMucG9zaXRpb25bMV0gKyB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCAvIDIgKyA2O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XHJcbiAgICAgICAgICAgICAgICB4ID0gdGhpcy5nZXRSZWN0KCkueCAtIHRoaXMucG9zaXRpb25bMF0gLSB0ZXh0LmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHkgPSB0aGlzLmdldFJlY3QoKS55IC0gdGhpcy5wb3NpdGlvblsxXSAtIDY7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICAgICAgICB4ID0gMjtcclxuICAgICAgICAgICAgICAgIHkgPSB0aGlzLmdldFJlY3QoKS55IC0gdGhpcy5wb3NpdGlvblsxXSAtIDY7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDogYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRleHQuYXR0cihcInN0eWxlXCIsIHsgeDogeCwgeTogeSB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOeUseeItuexu+WunueOsFxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIE5vZGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge307XHJcblxyXG4gICAgZ3JhcGhpYy5VdGlsLmluaGVyaXRzKE5vZGUsIGdyYXBoaWMuR3JvdXApO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBOb2RlO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDov57mjqXnur9cclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcbiAgICB2YXIgVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsLmpzXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvcicpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBOb2RlID0gcmVxdWlyZShcIi4uL05vZGUuanNcIik7XHJcbiAgICB2YXIgc3ltYm9sVXRpbCA9IHJlcXVpcmUoXCIuL1N5bWJvbC5qc1wiKTtcclxuICAgIHZhciBIYW5kbGUgPSByZXF1aXJlKFwiLi9IYW5kbGUuanNcIik7XHJcbiAgICB2YXIgRWZmZWN0TGluZSA9IHJlcXVpcmUoXCIuL0VmZmVjdExpbmUuanNcIik7XHJcbiAgICB2YXIgQ29ubmVjdGlvblBvaW50ID0gcmVxdWlyZShcIi4vQ29ubmVjdGlvblBvaW50LmpzXCIpO1xyXG4gICAgdmFyIFBvaW50ID0gcmVxdWlyZShcIi4uL1BvaW50LmpzXCIpO1xyXG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZShcIi4uL21vZGVsLmpzXCIpO1xyXG5cclxuICAgIENvbm5lY3Rvci5UWVBFX1NUUkFJR0hUID0gJ3N0cmFpZ2h0JztcclxuICAgIENvbm5lY3Rvci5UWVBFX0pBR0dFRCA9ICdqYWdnZWQnO1xyXG4gICAgQ29ubmVjdG9yLlRZUEVfQ1VSVkUgPSAnY3VydmUnO1xyXG4gICAgQ29ubmVjdG9yLlRZUEVfQ0hBSU4gPSAnY2hhaW4nO1xyXG4gICAgQ29ubmVjdG9yLlJBRElVUyA9IDM7XHJcbiAgICBDb25uZWN0b3IuU1RBUlRfTk9ERSA9IFwic3RhcnROb2RlXCI7XHJcbiAgICBDb25uZWN0b3IuRU5EX05PREUgPSBcImVuZE5vZGVcIjtcclxuICAgIENvbm5lY3Rvci5MRUZUID0gXCJsZWZ0XCI7XHJcbiAgICBDb25uZWN0b3IuUklHSFQgPSBcInJpZ2h0XCI7XHJcbiAgICBDb25uZWN0b3IuVE9QID0gXCJ0b3BcIjtcclxuICAgIENvbm5lY3Rvci5CT1RUT00gPSBcImJvdHRvbVwiO1xyXG4gICAgQ29ubmVjdG9yLkJPVFRPTSA9IFwiYm90dG9tXCI7XHJcbiAgICBDb25uZWN0b3IuU0VQRVJBVE9SID0gXCItXCI7XHJcbiAgICBDb25uZWN0b3IuTk9STUFMX0NPTE9SID0gXCIjMDAwXCI7XHJcbiAgICBDb25uZWN0b3IuU0VMRUNURURfQ09MT1IgPSAnIzc0QjdFMCc7XHJcbiAgICAvKipcclxuICAgICAqIOaehOmAoOWHveaVsFxyXG4gICAgICogQHBhcmFtIHtbdHlwZV19IG9wdGlvbnMgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBDb25uZWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIE5vZGUuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLm9wdCA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgaWYgKHRoaXMub3B0Lm1vZGVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VJZCA9IHRoaXMub3B0Lm1vZGVsLmdldChcInJlc291cmNlSWRcIik7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSB0aGlzLm9wdC5tb2RlbDtcclxuICAgICAgICAgICAgdGhpcy5vcHQgPSB0aGlzLm9wdC5tb2RlbC5vcHRpb247XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZUlkID0gVXRpbC5nZXRVVUlEKCk7IC8vIOeUn+aIkOiKgueCuUlEXHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSBuZXcgTW9kZWwoe30pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIHN5bWJvbDogeyB0eXBlOiBcImFycm93XCIsIHNpemU6IDEwLCBjb2xvcjogQ29ubmVjdG9yLk5PUk1BTF9DT0xPUiwgYm90aDpmYWxzZSwgb2Zmc2V0OjAgfSwgLy/nrq3lpLQgIOWPr+mAieWAvOS4uu+8miAnY2lyY2xlJywgJ3JlY3QnLCAncm91bmRSZWN0JywgJ3RyaWFuZ2xlJywgJ2RpYW1vbmQnLCAncGluJywgJ2Fycm93J1xyXG4gICAgICAgICAgICBzdHlsZTogeyBsaW5lV2lkdGg6IDEsIHN0cm9rZTogQ29ubmVjdG9yLk5PUk1BTF9DT0xPUiwgbGluZVR5cGU6IENvbm5lY3Rvci5UWVBFX1NUUkFJR0hUIH0sIC8v5qC35byPXHJcbiAgICAgICAgICAgIGhvdmVyU3R5bGU6IHsgbGluZVdpZHRoOiAyLCBzdHJva2U6IENvbm5lY3Rvci5TRUxFQ1RFRF9DT0xPUiB9LCAvL+enu+S4iuWOu+eahOagt+W8j1xyXG4gICAgICAgICAgICBhcnJvd0hvdmVyU3R5bGU6IHsgZmlsbDogQ29ubmVjdG9yLlNFTEVDVEVEX0NPTE9SfSxcclxuICAgICAgICAgICAgc2hhcGU6IHsgcG9pbnRzOiBudWxsLCBzbW9vdGg6IGZhbHNlLCBzbW9vdGhDb25zdHJhaW50OiBudWxsIH0sIC8v5b2i54q2XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHN0YXJ0UG9zOm51bGwsIGVuZFBvczpudWxsLCAgLy/mjIflrprnur/mrrXotbflp4vkuI7nu4jmraIg5Zyo6IqC54K555qE5LuA5LmI5L2N572uIOm7mOiupOWAvOS4uidsZWZ0LHJpZ2h0JyAg5Y+v5Y+W5YC85Zub5Liq5pa55ZCRdG9wLGJvdHRvbSxsZWZ0LHJpZ2h0IOaWueWQkeWPr+WKoOWBj+enu+mHj+WmguWmgiBcImxlZnQrMTAsdG9wXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQ6WzAsMF0sICAvLyDotbflp4vnur/mrrXnprvoioLngrnnmoTlgY/np7tcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kT2Zmc2V0OlswLDBdLCAgICAvLyDnu4jmraLnur/mrrXnprvoioLngrnnmoTlgY/np7tcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlRGlzdGFuY2U6WzMwLDMwXSwgLy8g56ys5LiA5p2h5oqY57q/55qE6ZW/5bqm77yM5pyA5ZCO5LiA5p2h5oqY57q/55qE6ZW/5bqmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czpudWxsICAgIC8v5LiN5L2/55So6Ieq5Yqo6K6h566XIOaMh+Wumui/nue6v+eahOaKmOeCueS9jee9ruaVsOe7hO+8jOmmluWwvuWPr+S7peS9v+eUqGxlZnQscmlnaHQsdG9wLGJvdHRvbVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGF1dG9DaGFuZ2VQb3NpdGlvbjogZmFsc2UsXHJcbiAgICAgICAgICAgIHRleHRDb250ZXh0TWVudTogbnVsbCxcclxuICAgICAgICAgICAgaXNFZGl0OiB0cnVlLCAvL+aYr+WQpuWPr+e8lui+kVxyXG4gICAgICAgICAgICB0ZXh0OiB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBudWxsLFxyXG4gICAgICAgICAgICAgICAgdGV4dEZpbGw6ICcjMDAwMDAwJywgLy8g5paH5pys6aKc6ImyXHJcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogJzEycHggTWljcm9zb2Z0IFlhSGVpJyxcclxuICAgICAgICAgICAgICAgIHRleHRQb3M6ICdjZW50ZXInLFxyXG4gICAgICAgICAgICAgICAgdGV4dFJvdGF0ZWFibGU6IHRydWVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejogMFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gVXRpbC5tZXJnZU9wdChkZWZhdWx0T3B0aW9ucywgdGhpcy5vcHQsIHRydWUsICd0ZXh0Q29udGV4dE1lbnUnKTtcclxuICAgICAgICB0aGlzLmhhbmRsZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmNvblBvaW50c0dyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcclxuICAgICAgICB0aGlzLnN0YXJ0Tm9kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbmROb2RlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxpbmUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBDdXJ2ZSA9IG5ldyBncmFwaGljLkdyb3VwKCk7XHJcbiAgICAgICAgdGhpcy5pY29ucyA9IFtdOyAvLyDnlKjkuo7lrZjlgqjnur/mrrXkuIrpnaLnmoTmk43kvZzlm77moIdcclxuICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOmHjeaWsOeUu+e6v++8jOWmguaenOS8oOepuuWImeagueaNrnR1cm5pbmdQb2ludHMg6YeN5paw55S757q/XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHBvaW50cyBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKGFyclBvaW50cykge1xyXG4gICAgICAgIGlmIChhcnJQb2ludHMpIHtcclxuICAgICAgICAgICAgdGhpcy50dXJuaW5nUG9pbnRzID0gYXJyUG9pbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+Wwhlt4OjAseTowXei9rOWMluS4ulswLCAwXSAg57uZenJlbmRlcuS9v+eUqFxyXG4gICAgICAgIHZhciBwb2ludHMgPSBVdGlsLnRyYXNsYXRlUG9pbnRzKHRoaXMudHVybmluZ1BvaW50cyk7XHJcblxyXG4gICAgICAgIGlmICgodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NVUlZFKSAmJiAocG9pbnRzLmxlbmd0aCA+IDIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5Q3VydmUodGhpcy50dXJuaW5nUG9pbnRzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxpbmUuYXR0cignc2hhcGUnLCB7IHBvaW50czogcG9pbnRzIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxpbmVUZXh0ID0gdGhpcy5jaGlsZE9mTmFtZSgnbGluZVRleHQnKTtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGxpbmVUZXh0QXJyID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DSEFJTiAmJiB6clV0aWwuaXNBcnJheSh0aGlzLm9wdGlvbnMudGV4dC50ZXh0KSkge1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMudGV4dC50ZXh0LmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcclxuICAgICAgICAgICAgICAgIGxpbmVUZXh0QXJyLnB1c2goc2VsZi5jaGlsZE9mTmFtZSgnbGluZVRleHQtJytpKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIWxpbmVUZXh0ICYmIHRoaXMub3B0aW9ucy50ZXh0LnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLmRyYXdUZXh0KFwibGluZVRleHRcIiwgdGhpcy5vcHRpb25zLnRleHQudGV4dCwgMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHRleHQudGV4dCk7XHJcbiAgICAgICAgICAgIGxpbmVUZXh0ID0gdGhpcy5jaGlsZE9mTmFtZSgnbGluZVRleHQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxpbmVUZXh0QXJyLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIGNudCA9IGxpbmVUZXh0QXJyLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gdGhpcy50dXJuaW5nUG9pbnRzWzFdLnggLSB0aGlzLnR1cm5pbmdQb2ludHNbMF0ueCxcclxuICAgICAgICAgICAgICAgIGdhcCA9IHBhcnNlSW50KGRpc3RhbmNlL2NudCksXHJcbiAgICAgICAgICAgICAgICBwb3MgPSAtKGdhcCkgKiBwYXJzZUludChjbnQvMik7XHJcblxyXG4gICAgICAgICAgICBsaW5lVGV4dEFyci5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dFBvaW50ID0gc2VsZi5nZXRUZXh0UG9zdGlvbihzZWxmLm9wdGlvbnMudGV4dCksIHdheSA9ICcnO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciByYXRlID0gc2VsZi5nZXRUZXh0Um90YXRpb24odGV4dFBvaW50KTtcclxuICAgICAgICAgICAgICAgIGlmIChyYXRlID09PSAtMCB8fCByYXRlID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmF0ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHdheSA9IHJhdGUgPiAwID8gJ3BsdXMnIDogJ21pbnVzJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJhdGUgPSBNYXRoLmFicyhyYXRlKTtcclxuICAgICAgICAgICAgICAgIHZhciBkZWcgPSAoMTgwKnJhdGUpL01hdGguUEk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm90YXRpb24gPSBudWxsLCBsZW5ndGggPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdi5zZXRTdHlsZShcInRleHRcIiwgenJVdGlsLmlzU3RyaW5nKHNlbGYub3B0aW9ucy50ZXh0LnRleHRbaV0pID8gc2VsZi5vcHRpb25zLnRleHQudGV4dFtpXSA6IHNlbGYub3B0aW9ucy50ZXh0LnRleHRbaV0udGV4dCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHdheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uID0gZGVnID4gOTAgPyAoKGRlZy00NSkqTWF0aC5QSSkvMTgwIDogKCg0NStkZWcpKk1hdGguUEkpLzE4MDtcclxuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbiA9IHdheSA9PT0gJ21pbnVzJyA/IC0ocm90YXRpb24pIDogcm90YXRpb247XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uID0gKDQ1Kk1hdGguUEkpLzE4MFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdi5hdHRyKCdyb3RhdGlvbicsIHJvdGF0aW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZGVnID09PSA5MCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRQb2ludFsxXSAtPSBwb3M7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRQb2ludFswXSArPSBwb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhdGUgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gTWF0aC50YW4oZGVnKk1hdGguUEkvMTgwKSpwb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0UG9pbnRbMV0gLT0gd2F5ID09PSAncGx1cycgPyBsZW5ndGggOiAtKGxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0UG9pbnRbMV0gKz0gd2F5ID09PSAncGx1cycgPyAtKGxlbmd0aCkgOiAobGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2LmF0dHIoXCJwb3NpdGlvblwiLCB0ZXh0UG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgcG9zICs9IGdhcDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsaW5lVGV4dCkge1xyXG4gICAgICAgICAgICBsaW5lVGV4dC5zZXRTdHlsZShcInRleHRcIiwgdGhpcy5vcHRpb25zLnRleHQudGV4dCk7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0UG9pbnQgPSB0aGlzLmdldFRleHRQb3N0aW9uKHRoaXMub3B0aW9ucy50ZXh0KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9TVFJBSUdIVCAmJiB0aGlzLm9wdGlvbnMudGV4dC50ZXh0Um90YXRlYWJsZSkgeyAvLyMxODdcclxuICAgICAgICAgICAgICAgIGxpbmVUZXh0LmF0dHIoJ3JvdGF0aW9uJywgdGhpcy5nZXRUZXh0Um90YXRpb24odGV4dFBvaW50KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGluZVRleHQuYXR0cihcInBvc2l0aW9uXCIsIHRleHRQb2ludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVmcmVzaEZyb21Ub1N5bWJvbChwb2ludHMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5riy5p+TXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgLy8xLuWIm+W7uueureWktFxyXG4gICAgICAgIHRoaXMucmVuZGVyRnJvbVRvU3ltYm9sKCk7XHJcblxyXG4gICAgICAgIC8vMi7liJvlu7rnur9cclxuICAgICAgICB0aGlzLmN1cnZlTGluZSA9IG5ldyBncmFwaGljLkJlemllckN1cnZlKHtcclxuICAgICAgICAgICAgLy9wb3NpdGlvbjogdGhpcy5vcHRpb25zLnBvc2l0aW9uLFxyXG4gICAgICAgICAgICBzdHlsZTogdGhpcy5vcHRpb25zLnN0eWxlLFxyXG4gICAgICAgICAgICB6OiB0aGlzLm9wdGlvbnMuelxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBDdXJ2ZS5hZGQodGhpcy5jdXJ2ZUxpbmUpO1xyXG4gICAgICAgIHRoaXMuYWRkKHRoaXMuZ3JvdXBDdXJ2ZSk7XHJcbiAgICAgICAgdGhpcy5hZGQodGhpcy5jb25Qb2ludHNHcm91cCk7XHJcblxyXG4gICAgICAgIHRoaXMucG9seUxpbmUgPSBuZXcgZ3JhcGhpYy5Qb2x5bGluZSh7XHJcbiAgICAgICAgICAgIC8vcG9zaXRpb246IHRoaXMub3B0aW9ucy5wb3NpdGlvbixcclxuICAgICAgICAgICAgc2hhcGU6IHRoaXMub3B0aW9ucy5zaGFwZSxcclxuICAgICAgICAgICAgc3R5bGU6IHRoaXMub3B0aW9ucy5zdHlsZSxcclxuICAgICAgICAgICAgejogdGhpcy5vcHRpb25zLnpcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZCh0aGlzLnBvbHlMaW5lKTtcclxuXHJcbiAgICAgICAgaWYgKCh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGluZSA9IHRoaXMuZ3JvdXBDdXJ2ZTtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVIb3ZlclN0eWxlKHRoaXMuY3VydmVMaW5lKTtcclxuICAgICAgICAgICAgdGhpcy5wb2x5TGluZS5oaWRlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5saW5lID0gdGhpcy5wb2x5TGluZTtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVIb3ZlclN0eWxlKHRoaXMucG9seUxpbmUpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnZlTGluZS5oaWRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLzMu5L6m5ZCs57q/5LqL5Lu2XHJcbiAgICAgICAgdmFyIE1PVVNFX0VWRU5UX05BTUVTID0gWydkYmxjbGljaycsICdjbGljayddOyAvLydjbGljaycsICdkYmxjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnXHJcbiAgICAgICAgenJVdGlsLmVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uKGV2ZU5hbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5saW5lLm9uKGV2ZU5hbWUsIHpyVXRpbC5iaW5kKGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IFwiQ29ubmVjdG9yOlwiICsgZXZlTmFtZTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy50YXJnZXQgPSB0aGF0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdHlsZSh7Y29sb3I6Q29ubmVjdG9yLlNFTEVDVEVEX0NPTE9SfSx0cnVlKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaXNFZGl0ID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pc0VkaXQgJiYgdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVBbGxjb25uZWN0aW9uUG9pbnQoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFuZGxlcy5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGFwZVNldEhhbmRsZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSwgdGhpcykpO1xyXG4gICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICAvLzQu5Yib5bu657q/5LiK5paH5pysXHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50ZXh0LnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIHRleHQgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoenJVdGlsLmlzQXJyYXkodGhpcy5vcHRpb25zLnRleHQudGV4dCkgJiYgdGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NIQUlOKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGV4dC50ZXh0LmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IHRoYXQuZHJhd1RleHQoXCJsaW5lVGV4dC1cIitpLCB2LCAwLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoenJVdGlsLmlzU3RyaW5nKHYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnRleHQgPSB2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmoudGV4dElkID0gY29udGVudC50ZXh0LmlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm9wdGlvbnMudGV4dC50ZXh0W2ldID0gb2JqO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQub3B0aW9ucy50ZXh0LnRleHRbaV0udGV4dElkID0gY29udGVudC50ZXh0LmlkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmFkZChjb250ZW50LnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNvbnRlbnQgJiYgdGhhdC5vcHQudGV4dENvbnRleHRNZW51KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0Q29udGV4dE1lbnUgPSB0aGF0Lm9wdC50ZXh0Q29udGV4dE1lbnU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQudGV4dC5vbihcImNvbnRleHRtZW51XCIsZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRDb250ZXh0TWVudS5idWlsZE1lbnUoZS5ldmVudCx0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRleHQgPSB0aGlzLmRyYXdUZXh0KFwibGluZVRleHRcIiwgdGhpcy5vcHRpb25zLnRleHQudGV4dCwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZCh0ZXh0LnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHRleHQgJiYgdGhpcy5vcHQudGV4dENvbnRleHRNZW51KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dENvbnRleHRNZW51ID0gdGhpcy5vcHQudGV4dENvbnRleHRNZW51O1xyXG4gICAgICAgICAgICAgICAgdGV4dC50ZXh0Lm9uKFwiY29udGV4dG1lbnVcIixmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGUuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dENvbnRleHRNZW51LmJ1aWxkTWVudShlLmV2ZW50LHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5yZW5kZXJGcm9tVG9TeW1ib2wgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHN5bWJvbFRvID0gdGhpcy5jcmVhdGVTeW1ib2woJ3RvU3ltYm9sJywgdGhpcy5vcHRpb25zKTsgLy9hcnJvdyx0cmlhbmdsZVxyXG4gICAgICAgIGlmIChzeW1ib2xUbykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZChzeW1ib2xUbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5aaC5p6c5Y+M5ZCR566t5aS0IOWImeWGjeWIm+W7uummlueureWktFxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3ltYm9sLmJvdGgpIHtcclxuICAgICAgICAgICAgdmFyIHN5bWJvbEZyb20gPSB0aGlzLmNyZWF0ZVN5bWJvbCgnZnJvbVN5bWJvbCcsIHRoaXMub3B0aW9ucyk7IC8vYXJyb3csdHJpYW5nbGVcclxuICAgICAgICAgICAgaWYgKHN5bWJvbEZyb20pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHN5bWJvbEZyb20pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUucmVmcmVzaEZyb21Ub1N5bWJvbCA9IGZ1bmN0aW9uKHBvaW50cykge1xyXG4gICAgICAgIHZhciBzeW1ib2xUbyA9IHRoaXMuY2hpbGRPZk5hbWUoJ3RvU3ltYm9sJyk7XHJcbiAgICAgICAgdmFyIHN5bWJvbEZyb20gPSB0aGlzLmNoaWxkT2ZOYW1lKCdmcm9tU3ltYm9sJyk7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gW10sIG9mZnNldCA9IHRoaXMub3B0aW9ucy5zeW1ib2wub2Zmc2V0O1xyXG4gICAgICAgIGlmIChzeW1ib2xUbykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVmZmVjdCAmJiB0aGlzLm9wdGlvbnMuZWZmZWN0LnNob3cpIHtcclxuICAgICAgICAgICAgICAgIG5ldyBFZmZlY3RMaW5lKHN5bWJvbFRvLCB0aGlzLm9wdGlvbnMsIHRoaXMuZ3JvdXBDdXJ2ZSwgdGhpcy5wb2x5TGluZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlICE9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHZlYzIuZGlzdGFuY2UocG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8PSBkaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHZlYzIubGVycChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtdLCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0IC8gZGlzdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xUby5hdHRyKCdwb3NpdGlvbicsIHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFRvLmF0dHIoJ3JvdGF0aW9uJywgVXRpbC50YW5nZW50Um90YXRpb24odGhpcy50dXJuaW5nUG9pbnRzW3RoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAyXSwgdGhpcy50dXJuaW5nUG9pbnRzW3RoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAxXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc3ltYm9sRnJvbSkge1xyXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHBvaW50c1swXTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSAhPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZUZyb20gPSB2ZWMyLmRpc3RhbmNlKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcclxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPD0gZGlzdGFuY2VGcm9tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB2ZWMyLmxlcnAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtdLCBwb2ludHNbMF0sIHBvaW50c1sxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0IC8gZGlzdGFuY2VGcm9tKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBwb2ludHNbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3ltYm9sRnJvbS5hdHRyKCdwb3NpdGlvbicsIHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgc3ltYm9sRnJvbS5hdHRyKCdyb3RhdGlvbicsIFV0aWwudGFuZ2VudFJvdGF0aW9uKHRoaXMudHVybmluZ1BvaW50c1sxXSwgdGhpcy50dXJuaW5nUG9pbnRzWzBdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva5zdHlsZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMg5qC35byP5a+56LGhXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG5vdFNhdmVNb2RlbCDorr7nva7moLflvI/mmK/lkKbkv53lrZjliLDmqKHlnovkuK0s6buY6K6k5pivZmFsc2VcclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uKG9wdGlvbnMsbm90U2F2ZU1vZGVsKSB7XHJcbiAgICAgICAgdmFyIHN5bWJvbFRvID0gbnVsbDtcclxuICAgICAgICBpZiAob3B0aW9ucy5jb2xvcikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NVUlZFKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUuZWFjaENoaWxkKGZ1bmN0aW9uKGN1cnZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VydmUuYXR0cihcInN0eWxlXCIsIHsgc3Ryb2tlOiBvcHRpb25zLmNvbG9yIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUoY3VydmUsIHsgc3Ryb2tlOiBvcHRpb25zLmNvbG9yIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvbHlMaW5lLmF0dHIoXCJzdHlsZVwiLCB7IHN0cm9rZTogb3B0aW9ucy5jb2xvciB9KTtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUodGhpcy5wb2x5TGluZSwgeyBzdHJva2U6IG9wdGlvbnMuY29sb3IgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3ltYm9sVG8gPSB0aGlzLmNoaWxkT2ZOYW1lKCd0b1N5bWJvbCcpO1xyXG4gICAgICAgICAgICBpZiAoc3ltYm9sVG8pIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFRvLmF0dHIoXCJzdHlsZVwiLCB7IGZpbGw6IG9wdGlvbnMuY29sb3IgfSk7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljLnNldE5vcm1hbFN0eWxlKHN5bWJvbFRvLCB7IGZpbGw6IG9wdGlvbnMuY29sb3IgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIW5vdFNhdmVNb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnN0eWxlLnN0cm9rZSA9IG9wdGlvbnMuY29sb3I7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMuc3R5bGUuc3Ryb2tlXCIsIG9wdGlvbnMuY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJvcHRpb25zLnN5bWJvbC5jb2xvclwiLCBvcHRpb25zLmNvbG9yKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zeW1ib2wuY29sb3IgPSBvcHRpb25zLmNvbG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy50ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBsaW5lVGV4dCA9IHRoaXMuY2hpbGRPZk5hbWUoJ2xpbmVUZXh0Jyk7XHJcbiAgICAgICAgICAgIC8v5byA5aeL5rKh5pyJ5Yib5bu65paH5pys77yM5ZCO5p2l5Lyg6L+b5p2ldGV4dOS6hu+8jOmcgOimgeWFiOWIm+W7uuaWh+acrFxyXG4gICAgICAgICAgICBpZiAoIWxpbmVUZXh0ICYmIG9wdGlvbnMudGV4dC50ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuZHJhd1RleHQoXCJsaW5lVGV4dFwiLCBvcHRpb25zLnRleHQudGV4dCwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZCh0ZXh0LnRleHQpO1xyXG4gICAgICAgICAgICAgICAgbGluZVRleHQgPSB0aGlzLmNoaWxkT2ZOYW1lKCdsaW5lVGV4dCcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50ZXh0LnRleHQgfHwgb3B0aW9ucy50ZXh0LnRleHQgPT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgbGluZVRleHQuc2V0U3R5bGUoXCJ0ZXh0XCIsIG9wdGlvbnMudGV4dC50ZXh0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50ZXh0LnRleHQgPSBvcHRpb25zLnRleHQudGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdGV4dFBvaW50ID0gdGhpcy5nZXRUZXh0UG9zdGlvbihvcHRpb25zLnRleHQpO1xyXG4gICAgICAgICAgICBsaW5lVGV4dC5hdHRyKFwicG9zaXRpb25cIiwgdGV4dFBvaW50KTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGV4dC50ZXh0UG9zKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGV4dC50ZXh0UG9zID0gb3B0aW9ucy50ZXh0LnRleHRQb3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGV4dC5vZmZzZXQpIHsgLy8jMTg3XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGV4dC5vZmZzZXQgPSBvcHRpb25zLnRleHQub2Zmc2V0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50ZXh0LmNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lVGV4dC5hdHRyKFwic3R5bGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRGaWxsOiBvcHRpb25zLnRleHQuY29sb3JcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRleHQudGV4dEZpbGwgPSBvcHRpb25zLnRleHQuY29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRleHQudGV4dEZvbnQpIHtcclxuICAgICAgICAgICAgICAgIGxpbmVUZXh0LmF0dHIoXCJzdHlsZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEZvbnQ6b3B0aW9ucy50ZXh0LnRleHRGb250XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50ZXh0LnRleHRGb250ID0gb3B0aW9ucy50ZXh0LnRleHRGb250O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50ZXh0LnRleHRGaWxsKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lVGV4dC5hdHRyKFwic3R5bGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRGaWxsOiBvcHRpb25zLnRleHQudGV4dEZpbGxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRleHQudGV4dEZpbGwgPSBvcHRpb25zLnRleHQudGV4dEZpbGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJvcHRpb25zLnRleHRcIiwgb3B0aW9ucy50ZXh0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnN5bWJvbCkge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zeW1ib2wudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnN5bWJvbC50eXBlID0gb3B0aW9ucy5zeW1ib2wudHlwZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2V0KFwib3B0aW9ucy5zeW1ib2wudHlwZVwiLCBvcHRpb25zLnN5bWJvbC50eXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zeW1ib2wuc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnN5bWJvbC5zaXplID0gb3B0aW9ucy5zeW1ib2wuc2l6ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2V0KFwib3B0aW9ucy5zeW1ib2wuc2l6ZVwiLCBvcHRpb25zLnN5bWJvbC5zaXplKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zeW1ib2wuY29sb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zeW1ib2wuY29sb3IgPSBvcHRpb25zLnN5bWJvbC5jb2xvcjtcclxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2V0KFwib3B0aW9ucy5zeW1ib2wuY29sb3JcIiwgb3B0aW9ucy5zeW1ib2wuY29sb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN5bWJvbC56KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3ltYm9sLnogPSBvcHRpb25zLnN5bWJvbC56O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJvcHRpb25zLnN5bWJvbC56XCIsIG9wdGlvbnMuc3ltYm9sLnopO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzeW1ib2xUbyA9IHRoaXMuY2hpbGRPZk5hbWUoJ3RvU3ltYm9sJyk7XHJcbiAgICAgICAgICAgIGlmIChzeW1ib2xUbykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoc3ltYm9sVG8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzeW1ib2wgPSB0aGlzLmNyZWF0ZVN5bWJvbChcInRvU3ltYm9sXCIsIHRoaXMubW9kZWwuZ2V0KFwib3B0aW9uc1wiKSlcclxuICAgICAgICAgICAgaWYgKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoc3ltYm9sKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W57q/5q6155qE5L2N572uXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHRleHQge3RleHQ6JycsIGNvbG9yOicnLCB0ZXh0UG9zOicnfVxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgIHt4LHl9XHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0VGV4dFBvc3Rpb24gPSBmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICAgICAgdmFyIHRleHRQb3N0aW9uID0gW107XHJcbiAgICAgICAgdmFyIHRleHRXaWR0aCA9IGdyYXBoaWMudGV4dENvbnRhaW4uZ2V0V2lkdGgodGV4dC50ZXh0LCB0ZXh0LnRleHRGb250KTtcclxuICAgICAgICBpZiAodGV4dCAmJiB0ZXh0LnRleHRQb3MpIHtcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRleHQub2Zmc2V0IHx8IDA7XHJcbiAgICAgICAgICAgIHZhciBhcnJPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkob2Zmc2V0KSkge1xyXG4gICAgICAgICAgICAgICAgYXJyT2Zmc2V0ID0gW29mZnNldCwgMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRleHQudGV4dFBvcyA9PSAnc3RhcnQnKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0UG9zdGlvbiA9IFt0aGlzLnR1cm5pbmdQb2ludHNbMF0ueCArIGFyck9mZnNldFswXSwgdGhpcy50dXJuaW5nUG9pbnRzWzBdLnkgKyBhcnJPZmZzZXRbMV1dO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRleHQudGV4dFBvcyA9PSAnZW5kJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IFV0aWwuZ2V0TWF4TGluZUxlbmd0aChbdGhpcy50dXJuaW5nUG9pbnRzW3RoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAyXSwgdGhpcy50dXJuaW5nUG9pbnRzW3RoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAxXV0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gVXRpbC5nZXRBbmdsZShwb2ludHNbMF0sIHBvaW50c1sxXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gVXRpbC5kaXN0YW5jZShwb2ludHNbMF0sIHBvaW50c1sxXSkgLSB0ZXh0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3UG9pbnQgPSBVdGlsLmdldEVuZFBvaW50KHBvaW50c1swXSwgbGVuZ3RoLCBhbmdsZSk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0UG9zdGlvbiA9IFtuZXdQb2ludC54ICsgYXJyT2Zmc2V0WzBdLCBuZXdQb2ludC55ICsgYXJyT2Zmc2V0WzFdXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBtaWRQb2ludCA9IHRoaXMubWlkZGxlKHRleHQpO1xyXG4gICAgICAgICAgICAgICAgdGV4dFBvc3Rpb24gPSBbbWlkUG9pbnRbMF0gKyBhcnJPZmZzZXRbMF0sIG1pZFBvaW50WzFdICsgYXJyT2Zmc2V0WzFdXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMubWlkZGxlKHRleHQpO1xyXG4gICAgICAgICAgICB0ZXh0UG9zdGlvbiA9IFtwb3NpdGlvblswXSAtIHRleHRXaWR0aCAvIDIsIHBvc2l0aW9uWzFdXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0UG9zdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bnur/mrrXnmoTml4vovazop5LluqZcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gdGV4dFBvc3Rpb24ge3gseX1cclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAg6KeS5bqm5YC8XHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0VGV4dFJvdGF0aW9uID0gZnVuY3Rpb24odGV4dFBvc3Rpb24pIHtcclxuICAgICAgICAvL+iuoeeul+WHuuaegeWdkOagh+eahOinkuW6plxyXG4gICAgICAgIHZhciBwb2ludHMgPSBVdGlsLmdldE1heExpbmVMZW5ndGgodGhpcy50dXJuaW5nUG9pbnRzKTtcclxuICAgICAgICB2YXIgYW5nbGUgPSAtTWF0aC5hdGFuMihwb2ludHNbMV0ueSAtIHRleHRQb3N0aW9uWzFdLCBwb2ludHNbMV0ueCAtIHRleHRQb3N0aW9uWzBdKTsgLy8sTWF0aC5QSS8yXHJcbiAgICAgICAgcmV0dXJuIGFuZ2xlO1xyXG4gICAgfTtcclxuXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLmNyZWF0ZUhvdmVyU3R5bGUgPSBmdW5jdGlvbihlbCkge1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaG92ZXJTdHlsZSkge1xyXG4gICAgICAgICAgICBncmFwaGljLnNldEVsZW1lbnRIb3ZlclN0bChlbCwgdGhpcy5vcHRpb25zLmhvdmVyU3R5bGUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHN5bWJvbFRvID0gdGhpcy5jaGlsZE9mTmFtZSgndG9TeW1ib2wnKTtcclxuICAgICAgICAgICAgaWYgKHN5bWJvbFRvKSB7IGdyYXBoaWMuc2V0RWxlbWVudEhvdmVyU3RsKHN5bWJvbFRvLCB0aGlzLm9wdGlvbnMuYXJyb3dIb3ZlclN0eWxlKTsgfVxyXG5cclxuICAgICAgICAgICAgZWwub24oJ21vdXNlb3ZlcicsIHpyVXRpbC5iaW5kKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMuZG9FbnRlckhvdmVyKGVsKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3ltYm9sVG8pIHsgZ3JhcGhpYy5kb0VudGVySG92ZXIoc3ltYm9sVG8pOyB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBDdXJ2ZS5lYWNoQ2hpbGQoZnVuY3Rpb24obGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljLmRvRW50ZXJIb3ZlcihsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIHpyVXRpbC5iaW5kKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMuZG9MZWF2ZUhvdmVyKGVsKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3ltYm9sVG8pIHsgZ3JhcGhpYy5kb0xlYXZlSG92ZXIoc3ltYm9sVG8pOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncm91cEN1cnZlLmVhY2hDaGlsZChmdW5jdGlvbihsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoaWMuZG9MZWF2ZUhvdmVyKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSwgdGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uk5vZGXnmoTov57mjqXngrlcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuY3JlYXRlQWxsY29ubmVjdGlvblBvaW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRDcmVhdGUodGhpcywgdGhpcy50dXJuaW5nUG9pbnRzWzBdLmNsb25lKCksIENvbm5lY3Rpb25Qb2ludC5UWVBFX0NPTk5FQ1RPUik7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRDcmVhdGUodGhpcywgdGhpcy50dXJuaW5nUG9pbnRzW3RoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAxXS5jbG9uZSgpLCBDb25uZWN0aW9uUG9pbnQuVFlQRV9DT05ORUNUT1IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uui/nuaOpeeCuVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gc2hhcGUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBwb2ludCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHR5cGUgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLmNvbm5lY3Rpb25Qb2ludENyZWF0ZSA9IGZ1bmN0aW9uKHNoYXBlLCBwb2ludCwgdHlwZSkge1xyXG4gICAgICAgIHZhciBjb25Qb2ludCA9IG5ldyBDb25uZWN0aW9uUG9pbnQodGhpcywgcG9pbnQsIHR5cGUsIHRoaXMub3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5jb25Qb2ludHNHcm91cC5hZGQoY29uUG9pbnQuc2hhcGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOa4heepuuaOp+WItueCuVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuY2xlYXJIYW5kbGVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmhhbmRsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUodGhpcy5oYW5kbGVzW2ldLmhhbmRsZVNoYXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oYW5kbGVzID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuY29uUG9pbnRzR3JvdXApIHtcclxuICAgICAgICAgICAgdGhpcy5jb25Qb2ludHNHcm91cC5yZW1vdmVBbGwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/mgaLlpI3ljp/mnaXnmoTpopzoibJcclxuICAgICAgICB0aGlzLnNldFN0eWxlKHtjb2xvcjp0aGlzLm9wdGlvbnMuc3R5bGUuc3Ryb2tlfSx0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7rmi4bnur8g57q/5pat55qE5o6n5Yi254K5XHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5zaGFwZVNldEhhbmRsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aCAtIDI7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgaDtcclxuICAgICAgICAgICAgdmFyIHgsIHk7XHJcbiAgICAgICAgICAgIC8v5piv5ZCm5Zyo5LiA5p2h57q/5LiKXHJcbiAgICAgICAgICAgIHZhciBpc0NvbGxpbmVhaXR5Rmlyc3QgPSBVdGlsLmNvbGxpbmVhcml0eSh0aGlzLnR1cm5pbmdQb2ludHNbaSAtIDFdLCB0aGlzLnR1cm5pbmdQb2ludHNbaV0sIHRoaXMudHVybmluZ1BvaW50c1tpICsgMV0pO1xyXG4gICAgICAgICAgICB2YXIgaXNDb2xsaW5lYWl0eVNlY29uZCA9IFV0aWwuY29sbGluZWFyaXR5KHRoaXMudHVybmluZ1BvaW50c1tpXSwgdGhpcy50dXJuaW5nUG9pbnRzW2kgKyAxXSwgdGhpcy50dXJuaW5nUG9pbnRzW2kgKyAyXSk7XHJcbiAgICAgICAgICAgIGlmICgoIWlzQ29sbGluZWFpdHlGaXJzdCAmJiAoIWlzQ29sbGluZWFpdHlTZWNvbmQgfHwgdGhpcy50dXJuaW5nUG9pbnRzW2kgKyAxXS5lcXVhbHModGhpcy50dXJuaW5nUG9pbnRzW2kgKyAyXSkpKSB8fCAoKCFpc0NvbGxpbmVhaXR5Rmlyc3QgfHwgdGhpcy50dXJuaW5nUG9pbnRzW2kgLSAxXS5lcXVhbHModGhpcy50dXJuaW5nUG9pbnRzW2ldKSkgJiYgIWlzQ29sbGluZWFpdHlTZWNvbmQpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHVybmluZ1BvaW50c1tpXS54ID09PSB0aGlzLnR1cm5pbmdQb2ludHNbaSArIDFdLngpIHsgLy9zYW1lIHZlcnRpY2FsXHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IHRoaXMudHVybmluZ1BvaW50c1tpXS54O1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSAodGhpcy50dXJuaW5nUG9pbnRzW2ldLnkgKyB0aGlzLnR1cm5pbmdQb2ludHNbaSArIDFdLnkpIC8gMjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaCA9IG5ldyBIYW5kbGUoJ2gnLCB4LCB5LCB0aGlzKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnR1cm5pbmdQb2ludHNbaV0ueSA9PT0gdGhpcy50dXJuaW5nUG9pbnRzW2kgKyAxXS55KSB7IC8vIHNhbWUgaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICAgICAgICAgIHggPSAodGhpcy50dXJuaW5nUG9pbnRzW2ldLnggKyB0aGlzLnR1cm5pbmdQb2ludHNbaSArIDFdLngpIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gdGhpcy50dXJuaW5nUG9pbnRzW2ldLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgaCA9IG5ldyBIYW5kbGUoJ3YnLCB4LCB5LCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoaC5oYW5kbGVTaGFwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVzLnB1c2goaCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7rnrq3lpLRcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbmFtZSAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG9wdGlvbnMgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5jcmVhdGVTeW1ib2wgPSBmdW5jdGlvbihuYW1lLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHN5bWJvbFR5cGUgPSBvcHRpb25zLnN5bWJvbC50eXBlO1xyXG4gICAgICAgIHZhciBzeW1ib2xTaXplID0gb3B0aW9ucy5zeW1ib2wuc2l6ZTtcclxuICAgICAgICBpZiAoc3ltYm9sVHlwZSA9PT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkoc3ltYm9sU2l6ZSkpIHtcclxuICAgICAgICAgICAgc3ltYm9sU2l6ZSA9IFtzeW1ib2xTaXplLCBzeW1ib2xTaXplXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzeW1ib2xaSW5kZXggPSBvcHRpb25zLno7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnN5bWJvbC56KSB7IHN5bWJvbFpJbmRleCA9IG9wdGlvbnMuc3ltYm9sLnogfVxyXG5cclxuICAgICAgICB2YXIgc3ltYm9sUGF0aCA9IHN5bWJvbFV0aWwuY3JlYXRlU3ltYm9sKFxyXG4gICAgICAgICAgICBzeW1ib2xUeXBlLCAtc3ltYm9sU2l6ZVswXSAvIDIsIC1zeW1ib2xTaXplWzFdIC8gMixcclxuICAgICAgICAgICAgc3ltYm9sU2l6ZVswXSwgc3ltYm9sU2l6ZVsxXSwgc3ltYm9sWkluZGV4LCBvcHRpb25zLnN5bWJvbC5jb2xvclxyXG4gICAgICAgICk7XHJcbiAgICAgICAgc3ltYm9sUGF0aC5uYW1lID0gbmFtZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN5bWJvbFBhdGg7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog57uY5Yi257q/5q615LiK55qE5paH5pysXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGNvbnRlbnQgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBuYW1lIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0geCAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHkgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBjb2xvciAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZHJhd1RleHQgPSBmdW5jdGlvbihuYW1lLCBjb250ZW50LCB4LCB5LCBjb2xvcikge1xyXG4gICAgICAgIHZhciBvcHQgPSB6clV0aWwuaXNTdHJpbmcoY29udGVudCkgPyB7dGV4dDpjb250ZW50LCB4OngsIHk6eSwgZmlsbDpjb2xvcn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogenJVdGlsLmRlZmF1bHRzKHt4OngsIHk6eSwgZmlsbDpjb2xvcn0sIGNvbnRlbnQsIHRydWUpO1xyXG5cclxuICAgICAgICB2YXIgdGV4dFN0eWxlID0genJVdGlsLmRlZmF1bHRzKHpyVXRpbC5jbG9uZSh0aGlzLm9wdGlvbnMudGV4dCksIG9wdCwgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIHRleHQgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcclxuICAgICAgICAgICAgc3R5bGU6IHRleHRTdHlsZSxcclxuICAgICAgICAgICAgemxldmVsOiAyMCxcclxuICAgICAgICAgICAgbmFtZSA6IG5hbWVcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxyXG4gICAgICAgICAgICByZWN0OiB0ZXh0LmdldEJvdW5kaW5nUmVjdCgpXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bnur/mrrXnmoTkuK3pl7TlgLxcclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gdGV4dFxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLm1pZGRsZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX1NUUkFJR0hUIHx8IHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DSEFJTikge1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gVXRpbC5nZXRNYXhMaW5lTGVuZ3RoKHRoaXMudHVybmluZ1BvaW50cyk7XHJcbiAgICAgICAgICAgIC8v5aaC5p6c5piv5rGC57q/5q615LiK55qE5paH5a2X55qE5Lit6Ze05YC8XHJcbiAgICAgICAgICAgIC8vIGlmKHRleHQpIHtcclxuICAgICAgICAgICAgLy8gICAgIC8v5Y+W5Ye65a2X55qE6ZW/5bqm77yM6K6h566X6KeS5bqm77yMXHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgdGV4dFdpZHRoID0gZ3JhcGhpYy50ZXh0Q29udGFpbi5nZXRXaWR0aCh0ZXh0LnRleHQsIHRleHQudGV4dEZvbnQpO1xyXG4gICAgICAgICAgICAvLyAgICAgdmFyIGFuZ2xlID0gVXRpbC5nZXRBbmdsZShwb2ludHNbMF0scG9pbnRzWzFdKTtcclxuICAgICAgICAgICAgLy8gICAgIHZhciBsZW5ndGggPSAgVXRpbC5kaXN0YW5jZShwb2ludHNbMF0scG9pbnRzWzFdKS8yIC0gdGV4dFdpZHRoLzI7XHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgbmV3UG9pbnQgPSBVdGlsLmdldEVuZFBvaW50KHBvaW50c1swXSwgbGVuZ3RoLCBhbmdsZSk7XHJcbiAgICAgICAgICAgIC8vICAgICByZXR1cm4gW25ld1BvaW50LngsIG5ld1BvaW50LnldO1xyXG4gICAgICAgICAgICAvLyB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyAgICAgdmFyIG1pZGRsZVggPSAocG9pbnRzWzBdLnggKyBwb2ludHNbMV0ueCkvMjtcclxuICAgICAgICAgICAgLy8gICAgIHZhciBtaWRkbGVZID0gKHBvaW50c1swXS55ICsgcG9pbnRzWzFdLnkpIC8yO1xyXG4gICAgICAgICAgICAvLyAgICAgcmV0dXJuIFttaWRkbGVYLCBtaWRkbGVZXTtcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICB2YXIgbWlkZGxlWCA9IChwb2ludHNbMF0ueCArIHBvaW50c1sxXS54KSAvIDI7XHJcbiAgICAgICAgICAgIHZhciBtaWRkbGVZID0gKHBvaW50c1swXS55ICsgcG9pbnRzWzFdLnkpIC8gMjtcclxuICAgICAgICAgICAgcmV0dXJuIFttaWRkbGVYLCBtaWRkbGVZXTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9KQUdHRUQpIHtcclxuXHJcbiAgICAgICAgICAgIC8vZmluZCB0b3RhbCBkaXN0YW5jZVxyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSB0aGlzLmdldExlbmd0aCgpO1xyXG5cclxuICAgICAgICAgICAgLy9maW5kIGJldHdlZW4gd2hhdCB0dXJuaW5nIHBvaW50cyB0aGUgaGFsZiBkaXN0YW5jZSBpc1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcclxuICAgICAgICAgICAgdmFyIGVsbGFwc2VkRGlzdGFuY2UgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIHZhciBzZWdtZW50ID0gVXRpbC5nZXRMZW5ndGgodGhpcy50dXJuaW5nUG9pbnRzW2ldLCB0aGlzLnR1cm5pbmdQb2ludHNbaSArIDFdKTtcclxuICAgICAgICAgICAgICAgIGlmIChlbGxhcHNlZERpc3RhbmNlICsgc2VnbWVudCA8IGRpc3RhbmNlIC8gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsbGFwc2VkRGlzdGFuY2UgKz0gc2VnbWVudDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vd2UgaGF2ZSB0aGUgbWlkZGxlIGRpc3RhbmNlIHNvbWV3aGVyZSBiZXR3ZWVuIGkobmRleCkgYW5kIGkobmRleCkrMVxyXG4gICAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtaXNzaW5nRGlzdGFuY2UgPSBkaXN0YW5jZSAvIDIgLSBlbGxhcHNlZERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKFV0aWwucm91bmQodGhpcy50dXJuaW5nUG9pbnRzW2luZGV4XS54LCAzKSA9PSBVdGlsLnJvdW5kKHRoaXMudHVybmluZ1BvaW50c1tpbmRleCArIDFdLngsIDMpKSB7IC8vdmVydGljYWwgc2VnbWVudCAoc2FtZSB4KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdGhpcy50dXJuaW5nUG9pbnRzW2luZGV4XS54LCBNYXRoLm1pbih0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXhdLnksIHRoaXMudHVybmluZ1BvaW50c1tpbmRleCArIDFdLnkpICsgbWlzc2luZ0Rpc3RhbmNlXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVXRpbC5yb3VuZCh0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXhdLnksIDMpID09IFV0aWwucm91bmQodGhpcy50dXJuaW5nUG9pbnRzW2luZGV4ICsgMV0ueSwgMykpIHsgLy9ob3Jpem9udGFsIHNlZ21lbnQgKHNhbWUgeSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW01hdGgubWluKHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueCwgdGhpcy50dXJuaW5nUG9pbnRzW2luZGV4ICsgMV0ueCkgKyBtaXNzaW5nRGlzdGFuY2UsIHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb25uZWN0b3I6bWlkZGxlKCkgLSB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW4gXCIgKyB0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXhdICsgXCIgXCIgKyB0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXggKyAxXSArIFwiIG5yIG9mIHBvaW50cyBcIiArIHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NVUlZFKSB7XHJcbiAgICAgICAgICAgIHZhciB0ID0gMC41O1xyXG4gICAgICAgICAgICB2YXIgbCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgd2Fsa2VkID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAod2Fsa2VkICsgVXRpbC5kaXN0YW5jZSh0aGlzLnR1cm5pbmdQb2ludHNbal0sIHRoaXMudHVybmluZ1BvaW50c1tqICsgMV0pID4gbCAqIHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB3YWxrZWQgKz0gVXRpbC5kaXN0YW5jZSh0aGlzLnR1cm5pbmdQb2ludHNbal0sIHRoaXMudHVybmluZ1BvaW50c1tqICsgMV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdCA9IGwgKiB0IC0gd2Fsa2VkO1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudFNlZ21lbnRMZW5ndGggPSBVdGlsLmRpc3RhbmNlKHRoaXMudHVybmluZ1BvaW50c1tqXSwgdGhpcy50dXJuaW5nUG9pbnRzW2ogKyAxXSk7XHJcblxyXG4gICAgICAgICAgICAvL2ZpbmQgdGhlIHBvc2l0aW9uL3JhdGlvbiBvZiB0aGUgbWlkZGxlIG9mIFBvbHlsaW5lIG9uIGN1cnJlbnQgc2VnbWVudFxyXG4gICAgICAgICAgICB2YXIgc2VnbWVudFBlcmNlbnQgPSByZXN0IC8gY3VycmVudFNlZ21lbnRMZW5ndGg7XHJcblxyXG4gICAgICAgICAgICB2YXIgWHAgPSBzZWdtZW50UGVyY2VudCAqICh0aGlzLnR1cm5pbmdQb2ludHNbaiArIDFdLnggLSB0aGlzLnR1cm5pbmdQb2ludHNbal0ueCkgKyB0aGlzLnR1cm5pbmdQb2ludHNbal0ueDtcclxuICAgICAgICAgICAgdmFyIFlwID0gc2VnbWVudFBlcmNlbnQgKiAodGhpcy50dXJuaW5nUG9pbnRzW2ogKyAxXS55IC0gdGhpcy50dXJuaW5nUG9pbnRzW2pdLnkpICsgdGhpcy50dXJuaW5nUG9pbnRzW2pdLnk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gW1hwLCBZcF07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZmluZCB0b3RhbCBkaXN0YW5jZVxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy9maW5kIHRvdGFsIGRpc3RhbmNlXHJcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgZGlzdGFuY2UgKz0gVXRpbC5nZXRMZW5ndGgodGhpcy50dXJuaW5nUG9pbnRzW2ldLCB0aGlzLnR1cm5pbmdQb2ludHNbaSArIDFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOi9rEpTT07lr7nosaEgYnBtbuS9v+eUqFxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwicmVzb3VyY2VJZFwiLCB0aGlzLnJlc291cmNlSWQpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwicHJvcGVydGllcy50eXBlXCIsIDE0KTtcclxuXHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIiwgdGhpcy5wb3NpdGlvblswXSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIiwgdGhpcy5wb3NpdGlvblsxXSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMubG93ZXJSaWdodC54XCIsIHBhcnNlSW50KHRoaXMucG9zaXRpb25bMF0gKyB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoKSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMubG93ZXJSaWdodC55XCIsIHBhcnNlSW50KHRoaXMucG9zaXRpb25bMV0gKyB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCkpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwic3R5bGUuc1Bvc1wiLCB0aGlzLm9wdGlvbnMucG9zaXRpb24uc3RhcnRQb3MpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwic3R5bGUuZVBvc1wiLCB0aGlzLm9wdGlvbnMucG9zaXRpb24uZW5kUG9zKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInN0eWxlLmxpbmVEYXNoXCIsIHRoaXMub3B0aW9ucy5zdHlsZS5saW5lRGFzaCk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJzdHlsZS5zdHJva2VcIiwgdGhpcy5vcHRpb25zLnN0eWxlLnN0cm9rZSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJzeW1ib2wudHlwZVwiLCB0aGlzLm9wdGlvbnMuc3ltYm9sLnR5cGUpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiZG9ja2Vyc1wiLCB0aGlzLnR1cm5pbmdQb2ludHMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm9wdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZWZyZXNoTW9kZWwgIGZsb3flvZPluo/liJfljJbnmoTml7blgJnosIPnlKgg5pu05paw57q/5q6155qE5L2N572uIOWPiue6v+S4iueahGljb25zXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5yZWZyZXNoTW9kZWwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnNcIiwgenJVdGlsLmNsb25lKHRoaXMub3B0aW9ucykpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwib3B0aW9ucy5kb2NrZXJzXCIsIHRoaXMudHVybmluZ1BvaW50cyk7XHJcbiAgICAgICAgdmFyIGljb25zID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmljb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBpY29uTm9kZSA9IHRoaXMuaWNvbnNbaV07XHJcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSBbaWNvbk5vZGUua2V5LCB7XHJcbiAgICAgICAgICAgICAgICBpY29uOiBpY29uTm9kZS5zdHlsZS5pbWFnZSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBpY29uTm9kZS5zdHlsZS53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogaWNvbk5vZGUuc3R5bGUuaGVpZ2h0XHJcbiAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICBpY29ucy5wdXNoKG9wdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiaWNvbnNcIiwgaWNvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOiwg+aVtOabsue6v+eahOW9oueKtlxyXG4gICAgICogQHBhcmFtICB7YXJyYXl9IHBvaW50cyDngrnmlbDnu4RcclxuICAgICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUubW9kaWZ5Q3VydmUgPSBmdW5jdGlvbihwb2ludHMpIHtcclxuICAgICAgICB2YXIgc29sID0gdGhpcy5nZXRDdXJ2ZVBvaW50KHBvaW50cyk7XHJcblxyXG4gICAgICAgIC8vIDEuIOWmguaenOabsue6v+eahOaVsOmHjyDmr5TmlbDph4/nmoTkuK3mlbDph4/opoHlsJEg5YiZ5Yig6Zmk5aSa5L2Z55qE57q/5q61XHJcbiAgICAgICAgdmFyIHdpbGxEZWxDdXJ2ZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBqID0gc29sLmxlbmd0aCwgY250Q3VydmUgPSB0aGlzLmdyb3VwQ3VydmUuY2hpbGRDb3VudCgpOyBqIDwgY250Q3VydmU7IGorKykge1xyXG4gICAgICAgICAgICB3aWxsRGVsQ3VydmVzLnB1c2godGhpcy5ncm91cEN1cnZlLmNoaWxkQXQoaikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB6clV0aWwuZWFjaCh3aWxsRGVsQ3VydmVzLCBmdW5jdGlvbihjdXJ2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUucmVtb3ZlKGN1cnZlKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAvLyAyLiDpgY3ljobmm7Lnur8gICDlpoLmnpzlrZjlnKjliJnnm7TmjqXorr7nva7lvaLnirbvvIzlkKbliJnliJvlu7pcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvbC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgbGluZSA9IHRoaXMuZ3JvdXBDdXJ2ZS5jaGlsZEF0KGkpO1xyXG4gICAgICAgICAgICBpZiAobGluZSkge1xyXG4gICAgICAgICAgICAgICAgbGluZS5hdHRyKCdzaGFwZScsIHNvbFtpXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VyZSA9IG5ldyBncmFwaGljLkJlemllckN1cnZlKHtcclxuICAgICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9uOiB0aGlzLm9wdGlvbnMucG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHRoaXMub3B0aW9ucy5zdHlsZSxcclxuICAgICAgICAgICAgICAgICAgICBzaGFwZTogc29sW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgIHo6IHRoaXMub3B0aW9ucy56XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBDdXJ2ZS5hZGQoY3VyZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUhvdmVyU3R5bGUoY3VyZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNruS8oOWFpeeahOeCueaVsOe7hOiuoeeul+absue6v+eahOeCuVxyXG4gICAgICogQHBhcmFtICB7YXJyYXl9IFAg54K55pWw57uEXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICDmm7Lnur/nmoTngrnmlbDnu4RcclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5nZXRDdXJ2ZVBvaW50ID0gZnVuY3Rpb24oUCkge1xyXG4gICAgICAgIHZhciBuID0gUC5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHNvbCA9IFtdO1xyXG4gICAgICAgIGlmIChuID09PSAzKSB7XHJcbiAgICAgICAgICAgIHNvbC5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHgxOiBQWzBdLngsXHJcbiAgICAgICAgICAgICAgICB5MTogUFswXS55LFxyXG4gICAgICAgICAgICAgICAgY3B4MTogUFsxXS54LFxyXG4gICAgICAgICAgICAgICAgY3B5MTogUFsxXS55LFxyXG4gICAgICAgICAgICAgICAgeDI6IFBbMl0ueCxcclxuICAgICAgICAgICAgICAgIHkyOiBQWzJdLnlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzb2w7XHJcbiAgICAgICAgfSBlbHNlIGlmIChuID09PSA0KSB7XHJcbiAgICAgICAgICAgIHNvbC5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHgxOiBQWzBdLngsXHJcbiAgICAgICAgICAgICAgICB5MTogUFswXS55LFxyXG4gICAgICAgICAgICAgICAgY3B4MTogUFsxXS54LFxyXG4gICAgICAgICAgICAgICAgY3B5MTogUFsxXS55LFxyXG4gICAgICAgICAgICAgICAgY3B4MjogUFsyXS54LFxyXG4gICAgICAgICAgICAgICAgY3B5MjogUFsyXS55LFxyXG4gICAgICAgICAgICAgICAgeDI6IFBbM10ueCxcclxuICAgICAgICAgICAgICAgIHkyOiBQWzNdLnlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzb2w7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqQ29tcHV0ZXMgdGhlIHN1bSBiZXR3ZWVuIHR3byBwb2ludFxyXG4gICAgICAgICAqQHBhcmFtIHAxIC0ge1BvaW50fVxyXG4gICAgICAgICAqQHBhcmFtIHAyIC0ge1BvaW50fVxyXG4gICAgICAgICAqQHJldHVybiB7UG9pbnR9IHRoZSBzdW0gb2YgaW5pdGlhbCBwb2ludHNcclxuICAgICAgICAgKiovXHJcbiAgICAgICAgZnVuY3Rpb24gc3VtKHAxLCBwMikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHAxLnggKyBwMi54LCBwMS55ICsgcDIueSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqQ29tcHV0ZXMgdGhlIGRpdmlzaW9uIG9mIGEge1BvaW50fSBieSBhIG51bWJlclxyXG4gICAgICAgICAqQHBhcmFtIHAgLSB7UG9pbnR9XHJcbiAgICAgICAgICpAcGFyYW0gbnIgLSB7TnVtYmVyfVxyXG4gICAgICAgICAqQHJldHVybiB7UG9pbnR9XHJcbiAgICAgICAgICoqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGRpdmlkZShwLCBucikge1xyXG4gICAgICAgICAgICBpZiAobnIgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJEaXZpc2lvbiBieSB6ZXJvIG5vdCBhbGxvd2VkICh5ZXQgOikgXCIgKyB0aGlzLmNhbGxlZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHAueCAvIG5yLCBwLnkgLyBucik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipDb21wdXRlcyB0aGUgbXVsdGlwbGljYXRpb24gb2YgYSB7UG9pbnR9IGJ5IGEgbnVtYmVyXHJcbiAgICAgICAgICpAcGFyYW0gcCAtIHtQb2ludH1cclxuICAgICAgICAgKkBwYXJhbSBuciAtIHtOdW1iZXJ9XHJcbiAgICAgICAgICpAcmV0dXJuIHtQb2ludH1cclxuICAgICAgICAgKiovXHJcbiAgICAgICAgZnVuY3Rpb24gbXVsdGlwbHkocCwgbnIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwLnggKiBuciwgcC55ICogbnIpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKkkgZG8gbm90IGdldCB3aHkgZmlyc3QgNCBtdXN0IGJlIDAgYW5kIGxhc3QgMyBvZiBzYW1lIHZhbHVlLi4uLi5cclxuICAgICAgICAgKmJ1dCBvdGhlcndpc2Ugd2Ugd2lsbCBnZXQgZGl2aXNpb24gYnkgemVyb1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBrID0gWzAsIDAsIDBdO1xyXG5cclxuICAgICAgICB2YXIgajtcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDw9IG4gLSAzOyBqKyspIHtcclxuICAgICAgICAgICAgay5wdXNoKGopO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgay5wdXNoKG4gLSAzLCBuIC0gMyk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbiAtIDM7IGkrKykge1xyXG4gICAgICAgICAgICAvL3ExIC0gY29tcHV0ZSBzdGFydCBwb2ludFxyXG4gICAgICAgICAgICB2YXIgcTEgPSBkaXZpZGUoc3VtKG11bHRpcGx5KFBbaV0sIGtbaSArIDRdIC0ga1tpICsgMl0pLCBtdWx0aXBseShQW2kgKyAxXSwga1tpICsgMl0gLSBrW2kgKyAxXSkpLCBrW2kgKyA0XSAtIGtbaSArIDFdKTtcclxuXHJcbiAgICAgICAgICAgIC8vcTAgLSBjb21wdXRlIDFzdCBjb250cm9sbCBwb2ludFxyXG4gICAgICAgICAgICB2YXIgcV8wMSA9IChrW2kgKyAzXSAtIGtbaSArIDJdKSAvIChrW2kgKyAzXSAtIGtbaSArIDFdKTtcclxuICAgICAgICAgICAgdmFyIHFfMDIgPSBkaXZpZGUoc3VtKG11bHRpcGx5KFBbaSAtIDFdLCBrW2kgKyAzXSAtIGtbaSArIDJdKSwgbXVsdGlwbHkoUFtpXSwga1tpICsgMl0gLSBrW2ldKSksIGtbaSArIDNdIC0ga1tpXSk7XHJcbiAgICAgICAgICAgIHZhciBxXzAzID0gbXVsdGlwbHkocTEsIChrW2kgKyAyXSAtIGtbaSArIDFdKSAvIChrW2kgKyAzXSAtIGtbaSArIDFdKSk7XHJcbiAgICAgICAgICAgIHZhciBxMCA9IHN1bShtdWx0aXBseShxXzAyLCBxXzAxKSwgcV8wMyk7XHJcblxyXG4gICAgICAgICAgICAvL3EyIC0gY29tcHV0ZSAybmQgY29udHJvbGwgcG9pbnRcclxuICAgICAgICAgICAgdmFyIHEyID0gZGl2aWRlKHN1bShtdWx0aXBseShQW2ldLCBrW2kgKyA0XSAtIGtbaSArIDNdKSwgbXVsdGlwbHkoUFtpICsgMV0sIGtbaSArIDNdIC0ga1tpICsgMV0pKSwga1tpICsgNF0gLSBrW2kgKyAxXSk7XHJcblxyXG4gICAgICAgICAgICAvL3EzIC0gY29tcHV0ZSBlbmQgcG9pbnRcclxuICAgICAgICAgICAgdmFyIHFfMzEgPSAoa1tpICsgM10gLSBrW2kgKyAyXSkgLyAoa1tpICsgNF0gLSBrW2kgKyAyXSk7XHJcbiAgICAgICAgICAgIHZhciBxXzMyID0gZGl2aWRlKHN1bShtdWx0aXBseShQW2kgKyAxXSwga1tpICsgNV0gLSBrW2kgKyAzXSksIG11bHRpcGx5KFBbaSArIDJdLCBrW2kgKyAzXSAtIGtbaSArIDJdKSksIGtbaSArIDVdIC0ga1tpICsgMl0pO1xyXG4gICAgICAgICAgICB2YXIgcV8zMyA9IG11bHRpcGx5KHEyLCAoa1tpICsgNF0gLSBrW2kgKyAzXSkgLyAoa1tpICsgNF0gLSBrW2kgKyAyXSkpO1xyXG4gICAgICAgICAgICB2YXIgcTMgPSBzdW0obXVsdGlwbHkocV8zMiwgcV8zMSksIHFfMzMpO1xyXG5cclxuICAgICAgICAgICAgLy9zdG9yZSBzb2x1dGlvblxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICBzb2wucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB4MTogcTAueCxcclxuICAgICAgICAgICAgICAgIHkxOiBxMC55LFxyXG4gICAgICAgICAgICAgICAgY3B4MTogcTEueCxcclxuICAgICAgICAgICAgICAgIGNweTE6IHExLnksXHJcbiAgICAgICAgICAgICAgICBjcHgyOiBxMi54LFxyXG4gICAgICAgICAgICAgICAgY3B5MjogcTIueSxcclxuICAgICAgICAgICAgICAgIHgyOiBxMy54LFxyXG4gICAgICAgICAgICAgICAgeTI6IHEzLnlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc29sO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgVXRpbC5pbmhlcml0cyhDb25uZWN0b3IsIE5vZGUpO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQ29ubmVjdG9yO1xyXG5cclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBTeW1ib2wgZmFjdG9yeVxyXG5cclxuXHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uL2dyYXBoaWMnKTtcclxuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlhbmdsZSBzaGFwZVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBUcmlhbmdsZSA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xyXG4gICAgICAgIHR5cGU6ICd0cmlhbmdsZScsXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChwYXRoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgY3ggPSBzaGFwZS5jeDtcclxuICAgICAgICAgICAgdmFyIGN5ID0gc2hhcGUuY3k7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoIC8gMjtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgIHBhdGgubW92ZVRvKGN4LCBjeSAtIGhlaWdodCk7XHJcbiAgICAgICAgICAgIHBhdGgubGluZVRvKGN4ICsgd2lkdGgsIGN5ICsgaGVpZ2h0KTtcclxuICAgICAgICAgICAgcGF0aC5saW5lVG8oY3ggLSB3aWR0aCwgY3kgKyBoZWlnaHQpO1xyXG4gICAgICAgICAgICBwYXRoLmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEaWFtb25kIHNoYXBlXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIERpYW1vbmQgPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcclxuICAgICAgICB0eXBlOiAnZGlhbW9uZCcsXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChwYXRoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgY3ggPSBzaGFwZS5jeDtcclxuICAgICAgICAgICAgdmFyIGN5ID0gc2hhcGUuY3k7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoIC8gMjtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgIHBhdGgubW92ZVRvKGN4LCBjeSAtIGhlaWdodCk7XHJcbiAgICAgICAgICAgIHBhdGgubGluZVRvKGN4ICsgd2lkdGgsIGN5KTtcclxuICAgICAgICAgICAgcGF0aC5saW5lVG8oY3gsIGN5ICsgaGVpZ2h0KTtcclxuICAgICAgICAgICAgcGF0aC5saW5lVG8oY3ggLSB3aWR0aCwgY3kpO1xyXG4gICAgICAgICAgICBwYXRoLmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGluIHNoYXBlXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFBpbiA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xyXG4gICAgICAgIHR5cGU6ICdwaW4nLFxyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIC8vIHgsIHkgb24gdGhlIGN1c3BcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUueDtcclxuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS55O1xyXG4gICAgICAgICAgICB2YXIgdyA9IHNoYXBlLndpZHRoIC8gNSAqIDM7XHJcbiAgICAgICAgICAgIC8vIEhlaWdodCBtdXN0IGJlIGxhcmdlciB0aGFuIHdpZHRoXHJcbiAgICAgICAgICAgIHZhciBoID0gTWF0aC5tYXgodywgc2hhcGUuaGVpZ2h0KTtcclxuICAgICAgICAgICAgdmFyIHIgPSB3IC8gMjtcclxuXHJcbiAgICAgICAgICAgIC8vIERpc3Qgb24geSB3aXRoIHRhbmdlbnQgcG9pbnQgYW5kIGNpcmNsZSBjZW50ZXJcclxuICAgICAgICAgICAgdmFyIGR5ID0gciAqIHIgLyAoaCAtIHIpO1xyXG4gICAgICAgICAgICB2YXIgY3kgPSB5IC0gaCArIHIgKyBkeTtcclxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hc2luKGR5IC8gcik7XHJcbiAgICAgICAgICAgIC8vIERpc3Qgb24geCB3aXRoIHRhbmdlbnQgcG9pbnQgYW5kIGNpcmNsZSBjZW50ZXJcclxuICAgICAgICAgICAgdmFyIGR4ID0gTWF0aC5jb3MoYW5nbGUpICogcjtcclxuXHJcbiAgICAgICAgICAgIHZhciB0YW5YID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgICAgICAgICB2YXIgdGFuWSA9IE1hdGguY29zKGFuZ2xlKTtcclxuXHJcbiAgICAgICAgICAgIHBhdGguYXJjKFxyXG4gICAgICAgICAgICAgICAgeCwgY3ksIHIsXHJcbiAgICAgICAgICAgICAgICBNYXRoLlBJIC0gYW5nbGUsXHJcbiAgICAgICAgICAgICAgICBNYXRoLlBJICogMiArIGFuZ2xlXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY3BMZW4gPSByICogMC42O1xyXG4gICAgICAgICAgICB2YXIgY3BMZW4yID0gciAqIDAuNztcclxuICAgICAgICAgICAgcGF0aC5iZXppZXJDdXJ2ZVRvKFxyXG4gICAgICAgICAgICAgICAgeCArIGR4IC0gdGFuWCAqIGNwTGVuLCBjeSArIGR5ICsgdGFuWSAqIGNwTGVuLFxyXG4gICAgICAgICAgICAgICAgeCwgeSAtIGNwTGVuMixcclxuICAgICAgICAgICAgICAgIHgsIHlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgcGF0aC5iZXppZXJDdXJ2ZVRvKFxyXG4gICAgICAgICAgICAgICAgeCwgeSAtIGNwTGVuMixcclxuICAgICAgICAgICAgICAgIHggLSBkeCArIHRhblggKiBjcExlbiwgY3kgKyBkeSArIHRhblkgKiBjcExlbixcclxuICAgICAgICAgICAgICAgIHggLSBkeCwgY3kgKyBkeVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBwYXRoLmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJyb3cgc2hhcGVcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgQXJyb3cgPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcclxuXHJcbiAgICAgICAgdHlwZTogJ2Fycm93JyxcclxuXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGg7XHJcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUueDtcclxuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS55O1xyXG4gICAgICAgICAgICB2YXIgZHggPSB3aWR0aCAvIDMgKiAyO1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBkeCwgeSArIGhlaWdodCk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSArIGhlaWdodCAvIDQgKiAzKTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4IC0gZHgsIHkgKyBoZWlnaHQpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgb2YgcGF0aCBjb250cnVjdG9yc1xyXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBtb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGg+fVxyXG4gICAgICovXHJcbiAgICB2YXIgc3ltYm9sQ3RvcnMgPSB7XHJcbiAgICAgICAgbGluZTogZ3JhcGhpYy5MaW5lLFxyXG5cclxuICAgICAgICByZWN0OiBncmFwaGljLlJlY3QsXHJcblxyXG4gICAgICAgIHJvdW5kUmVjdDogZ3JhcGhpYy5SZWN0LFxyXG5cclxuICAgICAgICBzcXVhcmU6IGdyYXBoaWMuUmVjdCxcclxuXHJcbiAgICAgICAgY2lyY2xlOiBncmFwaGljLkNpcmNsZSxcclxuXHJcbiAgICAgICAgZGlhbW9uZDogRGlhbW9uZCxcclxuXHJcbiAgICAgICAgcGluOiBQaW4sXHJcblxyXG4gICAgICAgIGFycm93OiBBcnJvdyxcclxuXHJcbiAgICAgICAgdHJpYW5nbGU6IFRyaWFuZ2xlXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBzeW1ib2xTaGFwZU1ha2VycyA9IHtcclxuXHJcbiAgICAgICAgbGluZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIC8vIEZJWE1FXHJcbiAgICAgICAgICAgIHNoYXBlLngxID0geDtcclxuICAgICAgICAgICAgc2hhcGUueTEgPSB5ICsgaCAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLngyID0geCArIHc7XHJcbiAgICAgICAgICAgIHNoYXBlLnkyID0geSArIGggLyAyO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS54ID0geDtcclxuICAgICAgICAgICAgc2hhcGUueSA9IHk7XHJcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcclxuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByb3VuZFJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS54ID0geDtcclxuICAgICAgICAgICAgc2hhcGUueSA9IHk7XHJcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcclxuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcclxuICAgICAgICAgICAgc2hhcGUuciA9IE1hdGgubWluKHcsIGgpIC8gNDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzcXVhcmU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKHcsIGgpO1xyXG4gICAgICAgICAgICBzaGFwZS54ID0geDtcclxuICAgICAgICAgICAgc2hhcGUueSA9IHk7XHJcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gc2l6ZTtcclxuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gc2l6ZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjaXJjbGU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICAvLyBQdXQgY2lyY2xlIGluIHRoZSBjZW50ZXIgb2Ygc3F1YXJlXHJcbiAgICAgICAgICAgIHNoYXBlLmN4ID0geCArIHcgLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS5jeSA9IHkgKyBoIC8gMjtcclxuICAgICAgICAgICAgc2hhcGUuciA9IE1hdGgubWluKHcsIGgpIC8gMjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBkaWFtb25kOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgc2hhcGUuY3ggPSB4ICsgdyAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLmN5ID0geSArIGggLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XHJcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcGluOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgc2hhcGUueCA9IHggKyB3IC8gMjtcclxuICAgICAgICAgICAgc2hhcGUueSA9IHkgKyBoIC8gMjtcclxuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xyXG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFycm93OiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgc2hhcGUueCA9IHggKyB3IC8gMjtcclxuICAgICAgICAgICAgc2hhcGUueSA9IHkgKyBoIC8gMjtcclxuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xyXG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHRyaWFuZ2xlOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgc2hhcGUuY3ggPSB4ICsgdyAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLmN5ID0geSArIGggLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XHJcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgc3ltYm9sQnVpbGRQcm94aWVzID0ge307XHJcbiAgICBmb3IgKHZhciBuYW1lIGluIHN5bWJvbEN0b3JzKSB7XHJcbiAgICAgICAgc3ltYm9sQnVpbGRQcm94aWVzW25hbWVdID0gbmV3IHN5bWJvbEN0b3JzW25hbWVdKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIFN5bWJvbCA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xyXG5cclxuICAgICAgICB0eXBlOiAnc3ltYm9sJyxcclxuXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgc3ltYm9sVHlwZTogJycsXHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBiZWZvcmVCcnVzaDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xyXG4gICAgICAgICAgICAvLyBGSVhNRVxyXG4gICAgICAgICAgICBpZiAoc2hhcGUuc3ltYm9sVHlwZSA9PT0gJ3BpbicgJiYgc3R5bGUudGV4dFBvc2l0aW9uID09PSAnaW5zaWRlJykge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUudGV4dFBvc2l0aW9uID0gWyc1MCUnLCAnNDAlJ107XHJcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICAgICAgICAgIHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBzeW1ib2xUeXBlID0gc2hhcGUuc3ltYm9sVHlwZTtcclxuICAgICAgICAgICAgdmFyIHByb3h5U3ltYm9sID0gc3ltYm9sQnVpbGRQcm94aWVzW3N5bWJvbFR5cGVdO1xyXG4gICAgICAgICAgICBpZiAoc2hhcGUuc3ltYm9sVHlwZSAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByb3h5U3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCByZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sVHlwZSA9ICdyZWN0JztcclxuICAgICAgICAgICAgICAgICAgICBwcm94eVN5bWJvbCA9IHN5bWJvbEJ1aWxkUHJveGllc1tzeW1ib2xUeXBlXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN5bWJvbFNoYXBlTWFrZXJzW3N5bWJvbFR5cGVdKFxyXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlLngsIHNoYXBlLnksIHNoYXBlLndpZHRoLCBzaGFwZS5oZWlnaHQsIHByb3h5U3ltYm9sLnNoYXBlXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgcHJveHlTeW1ib2wuYnVpbGRQYXRoKGN0eCwgcHJveHlTeW1ib2wuc2hhcGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gUHJvdmlkZSBzZXRDb2xvciBoZWxwZXIgbWV0aG9kIHRvIGF2b2lkIGRldGVybWluZSBpZiBzZXQgdGhlIGZpbGwgb3Igc3Ryb2tlIG91dHNpZGVcclxuICAgIHZhciBzeW1ib2xQYXRoU2V0Q29sb3IgPSBmdW5jdGlvbiAoY29sb3IpIHtcclxuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAnaW1hZ2UnKSB7XHJcbiAgICAgICAgICAgIHZhciBzeW1ib2xTdHlsZSA9IHRoaXMuc3R5bGU7XHJcbiAgICAgICAgICAgIHZhciBzeW1ib2xTaGFwZSA9IHRoaXMuc2hhcGU7XHJcbiAgICAgICAgICAgIGlmIChzeW1ib2xTaGFwZSAmJiBzeW1ib2xTaGFwZS5zeW1ib2xUeXBlID09PSAnbGluZScpIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFN0eWxlLnN0cm9rZSA9IGNvbG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX19pc0VtcHR5QnJ1c2gpIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFN0eWxlLnN0cm9rZSA9IGNvbG9yO1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuZmlsbCA9ICcjZmZmJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEZJWE1FIOWIpOaWreWbvuW9oum7mOiupOaYr+Whq+WFhei/mOaYr+aPj+i+ue+8jOS9v+eUqCBvbmx5U3Ryb2tlID9cclxuICAgICAgICAgICAgICAgIHN5bWJvbFN0eWxlLmZpbGwgJiYgKHN5bWJvbFN0eWxlLmZpbGwgPSBjb2xvcik7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xTdHlsZS5zdHJva2UgJiYgKHN5bWJvbFN0eWxlLnN0cm9rZSA9IGNvbG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmRpcnR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgc3ltYm9sVXRpbCA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGUgYSBzeW1ib2wgZWxlbWVudCB3aXRoIGdpdmVuIHN5bWJvbCBjb25maWd1cmF0aW9uOiBzaGFwZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgY29sb3JcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sVHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gd1xyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBjcmVhdGVTeW1ib2w6IGZ1bmN0aW9uIChzeW1ib2xUeXBlLCB4LCB5LCB3LCBoLCB6LCBjb2xvcikge1xyXG4gICAgICAgICAgICB2YXIgaXNFbXB0eSA9IHN5bWJvbFR5cGUuaW5kZXhPZignZW1wdHknKSA9PT0gMDtcclxuICAgICAgICAgICAgaWYgKGlzRW1wdHkpIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFR5cGUgPSBzeW1ib2xUeXBlLnN1YnN0cig1LCAxKS50b0xvd2VyQ2FzZSgpICsgc3ltYm9sVHlwZS5zdWJzdHIoNik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHN5bWJvbFBhdGg7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3ltYm9sVHlwZS5pbmRleE9mKCdpbWFnZTovLycpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xQYXRoID0gbmV3IGdyYXBoaWMuSW1hZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBzeW1ib2xUeXBlLnNsaWNlKDgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB6OiB6XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzeW1ib2xUeXBlLmluZGV4T2YoJ3BhdGg6Ly8nKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sUGF0aCA9IGdyYXBoaWMubWFrZVBhdGgoc3ltYm9sVHlwZS5zbGljZSg3KSwge3o6IHosIHJlY3RIb3ZlcjogdHJ1ZX0sIG5ldyBCb3VuZGluZ1JlY3QoeCwgeSwgdywgaCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sUGF0aCA9IG5ldyBTeW1ib2woe1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbFR5cGU6IHN5bWJvbFR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHo6IHpcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzeW1ib2xQYXRoLl9faXNFbXB0eUJydXNoID0gaXNFbXB0eTtcclxuXHJcbiAgICAgICAgICAgIHN5bWJvbFBhdGguc2V0Q29sb3IgPSBzeW1ib2xQYXRoU2V0Q29sb3I7XHJcblxyXG4gICAgICAgICAgICBzeW1ib2xQYXRoLnNldENvbG9yKGNvbG9yKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xQYXRoO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzeW1ib2xVdGlsO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9TeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDnlLvlj6Xmn4RcclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC5qc1wiKTtcclxuICAgIGZ1bmN0aW9uIEhhbmRsZSh0eXBlLCB4LCB5LCBjb25uZWN0b3Ipe1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcblxyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuY29ubmVjdG9yID0gY29ubmVjdG9yO1xyXG5cclxuICAgICAgICB0aGlzLmhhbmRsZVNoYXBlID0gbmV3IGdyYXBoaWMuQ2lyY2xlKHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIGN4OiB4LFxyXG4gICAgICAgICAgICAgICAgY3k6IHksXHJcbiAgICAgICAgICAgICAgICByOiBIYW5kbGUuUkFESVVTXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogXCJyZ2IoMCwyNTUsMClcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTpcInJnYigwLDAsMClcIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6IDogY29ubmVjdG9yLm9wdGlvbnMueiArIDIsICAvL+iKgueCuVrkuLoxIOe6v+auteS4ujA7XHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTp0cnVlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGlzLmhhbmRsZVNoYXBlLm9uKFwiZHJhZ1wiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHRoYXQuYWN0aW9uQ29ubmVjdG9yKGUub2Zmc2V0WCxlLm9mZnNldFkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgLy8gcmV0dXJuIHRoaXMuY2lyY2xlO1xyXG4gICAgfVxyXG5cclxuICAgIEhhbmRsZS5SQURJVVMgPSA0O1xyXG5cclxuICAgIEhhbmRsZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yIDogSGFuZGxlLFxyXG5cclxuICAgICAgICBlcXVhbHMgOiBmdW5jdGlvbihhbm90aGVySGFuZGxlKXtcclxuICAgICAgICAgICAgaWYoIWFub3RoZXJIYW5kbGUgaW5zdGFuY2VvZiBIYW5kbGUpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IGFub3RoZXJIYW5kbGUudHlwZVxyXG4gICAgICAgICAgICAmJiB0aGlzLnggPT0gYW5vdGhlckhhbmRsZS54XHJcbiAgICAgICAgICAgICYmIHRoaXMueSA9PSBhbm90aGVySGFuZGxlLnlcclxuICAgICAgICAgICAgJiYgdGhpcy52aXNpYmxlID09IGFub3RoZXJIYW5kbGUudmlzaWJsZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDnp7vliqjlj6Xmn4RcclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5ld1ggW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbmV3WSBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKi9cclxuICAgICAgICBhY3Rpb25Db25uZWN0b3I6IGZ1bmN0aW9uKG5ld1gsIG5ld1kpe1xyXG4gICAgICAgICAgICBzd2l0Y2godGhpcy50eXBlKXtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAvLyDmib7lh7rkuKTkuKrovazmipjngrnvvIjlj6/np7vliqjlj6Xmn4TlnKjov5nkuKTkuKrovazmipjngrnkuK3pl7TvvIlcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50cy5sZW5ndGgtMTsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpLTFdLnkgPT0gdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS55XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLnkgPT0gdGhpcy55XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBNYXRoLm1pbih0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLngsIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaS0xXS54KSA8PSB0aGlzLnhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIE1hdGgubWF4KHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueCwgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpLTFdLngpID49IHRoaXMueClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YVkgPSBuZXdZIC0gdGhpcy55O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2xhdGlvbk1hdHJpeCA9IFV0aWwudHJhbnNsYXRpb25NYXRyaXgoMCwgZGVsdGFZKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpbmRleC0xXS50cmFuc2Zvcm0odHJhbnNsYXRpb25NYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaW5kZXhdLnRyYW5zZm9ybSh0cmFuc2xhdGlvbk1hdHJpeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueSA9IG5ld1k7ICAvL+WwhuWPpeafhOaWsOeahOS9jee9rui1i+WAvOe7mXlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnaCc6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOaJvuWHuuS4pOS4qui9rOaKmOeCue+8iOWPr+enu+WKqOWPpeafhOWcqOi/meS4pOS4qui9rOaKmOeCueS4remXtO+8iVxyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzLmxlbmd0aC0xOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ktMV0ueCA9PSB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLnhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueCA9PSB0aGlzLnhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIE1hdGgubWluKHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueSwgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpLTFdLnkpIDw9IHRoaXMueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgTWF0aC5tYXgodGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS55LCB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ktMV0ueSkgPj0gdGhpcy55KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YVggPSBuZXdYLXRoaXMueDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRpb25NYXRyaXggPSBVdGlsLnRyYW5zbGF0aW9uTWF0cml4KGRlbHRhWCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpbmRleC0xXS50cmFuc2Zvcm0odHJhbnNsYXRpb25NYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaW5kZXhdLnRyYW5zZm9ybSh0cmFuc2xhdGlvbk1hdHJpeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueCA9IG5ld1g7IC8v5bCG5Y+l5p+E5paw55qE5L2N572u6LWL5YC857uZeFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIC8vLiB0aGlzLnNoYXBlLnVwZGF0ZU1pZGRsZVRleHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBIYW5kbGU7XHJcblxyXG5cclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvSGFuZGxlLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog6L+e57q/5Yqo5oCB5pWI5p6cXHJcbiAqIEBhdXRob3IgbWlhby5jdW56aGlcclxuICovXHJcblxyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvcicpO1xyXG4gICAgdmFyIGN1cnZlVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvY3VydmUnKTtcclxuICAgIHZhciBzeW1ib2xVdGlsID0gcmVxdWlyZSgnLi9TeW1ib2wuanMnKTtcclxuXHJcbiAgICBmdW5jdGlvbiBFZmZlY3RMaW5lKHN5bWJvbCwgb3B0aW9ucywgZ3JvdXBDdXJ2ZSwgcG9seUxpbmUpIHtcclxuICAgICAgICB0aGlzLl9sYXN0RnJhbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZVBlcmNlbnQgPSAwO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBDdXJ2ZSA9IGdyb3VwQ3VydmU7XHJcbiAgICAgICAgdGhpcy5pbml0U3ltYm9sKG9wdGlvbnMsIHBvbHlMaW5lKTtcclxuICAgIH1cclxuICAgIHZhciBFZmZlY3RMaW5lUHJvdG8gPSBFZmZlY3RMaW5lLnByb3RvdHlwZTtcclxuXHJcbiAgICBFZmZlY3RMaW5lUHJvdG8uaW5pdFN5bWJvbCA9IGZ1bmN0aW9uKG9wdGlvbnMsIHBvbHlMaW5lKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLnoyID0gMTAwO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLmN1bGxpbmcgPSB0cnVlO1xyXG4gICAgICAgIHZhciBwZXJpb2QgPSBvcHRpb25zLmVmZmVjdC5wZXJpb2QgKiAxMDAwO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9fdCA9IDA7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuc3RvcEFuaW1hdGlvbigpO1xyXG4gICAgICAgIGlmICgob3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBcImN1cnZlXCIpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdyb3VwQ3VydmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgIHBlcmlvZCA9IHBlcmlvZCAvIHRoaXMuZ3JvdXBDdXJ2ZS5fY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cEN1cnZlQW5pbWF0ZSh0aGlzLmdyb3VwQ3VydmUuX2NoaWxkcmVuWzBdLCBpLCBwZXJpb2QpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ltYm9sLmFuaW1hdGUoJycsIHRydWUpXHJcbiAgICAgICAgICAgICAgICAud2hlbihwZXJpb2QsIHtcclxuICAgICAgICAgICAgICAgICAgICBfX3Q6IDFcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuZGVsYXkoMClcclxuICAgICAgICAgICAgICAgIC5kdXJpbmcoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51cGRhdGVTeW1ib2xQb3NpdGlvblBvbHlsaW5lKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0QW5pbWF0aW9uUG9pbnRzUG9seWxpbmUocG9seUxpbmUuc2hhcGUucG9pbnRzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBFZmZlY3RMaW5lUHJvdG8uZ3JvdXBDdXJ2ZUFuaW1hdGUgPSBmdW5jdGlvbihjdXJ2ZUxpbmUsIGksIHBlcmlvZCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBpZiAoY3VydmVMaW5lID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjdXJ2ZUxpbmUgPSB0aGlzLmdyb3VwQ3VydmUuX2NoaWxkcmVuWzBdO1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBvaW50cztcclxuICAgICAgICB2YXIgcG9zID0gY3VydmVMaW5lLnNoYXBlO1xyXG4gICAgICAgIHBvaW50cyA9IFtcclxuICAgICAgICAgICAgW3Bvcy54MSwgcG9zLnkxXSxcclxuICAgICAgICAgICAgW3Bvcy54MiwgcG9zLnkyXSxcclxuICAgICAgICAgICAgW3Bvcy5jcHgxLCBwb3MuY3B5MV0sXHJcbiAgICAgICAgICAgIFtwb3MuY3B4MiwgcG9zLmNweTJdXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLnNldEFuaW1hdGlvblBvaW50c0JlemllckN1cnZlKHBvaW50cyk7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuYW5pbWF0ZSgnJylcclxuICAgICAgICAgICAgLndoZW4ocGVyaW9kLCB7XHJcbiAgICAgICAgICAgICAgICBfX3Q6IDFcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmRlbGF5KDApXHJcbiAgICAgICAgICAgIC5kdXJpbmcoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZVN5bWJvbFBvc2l0aW9uQmV6aWVyQ3VydmUoKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmRvbmUoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnN5bWJvbC5fX3QgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5ncm91cEN1cnZlQW5pbWF0ZSh0aGF0Lmdyb3VwQ3VydmUuX2NoaWxkcmVuW2kgKyAxXSwgaSArIDEsIHBlcmlvZCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdGFydCgpO1xyXG5cclxuICAgIH07XHJcblxyXG5cclxuICAgIEVmZmVjdExpbmVQcm90by5zZXRBbmltYXRpb25Qb2ludHNCZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uKHBvaW50cykge1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9fcDEgPSBwb2ludHNbMF07XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuX19wMiA9IHBvaW50c1sxXTtcclxuICAgICAgICB0aGlzLnN5bWJvbC5fX2NwMSA9IHBvaW50c1syXSB8fCBbXHJcbiAgICAgICAgICAgIChwb2ludHNbMF1bMF0gKyBwb2ludHNbMV1bMF0pIC8gMixcclxuICAgICAgICAgICAgKHBvaW50c1swXVsxXSArIHBvaW50c1sxXVsxXSkgLyAyXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLnN5bWJvbC5fX2NwMiA9IHBvaW50c1szXTtcclxuICAgIH07XHJcblxyXG4gICAgRWZmZWN0TGluZVByb3RvLnVwZGF0ZVN5bWJvbFBvc2l0aW9uQmV6aWVyQ3VydmUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcDEgPSB0aGlzLnN5bWJvbC5fX3AxO1xyXG4gICAgICAgIHZhciBwMiA9IHRoaXMuc3ltYm9sLl9fcDI7XHJcbiAgICAgICAgdmFyIGNwMSA9IHRoaXMuc3ltYm9sLl9fY3AxO1xyXG4gICAgICAgIHZhciBjcDIgPSB0aGlzLnN5bWJvbC5fX2NwMjtcclxuICAgICAgICB2YXIgdCA9IHRoaXMuc3ltYm9sLl9fdDtcclxuICAgICAgICB2YXIgcG9zID0gdGhpcy5zeW1ib2wucG9zaXRpb247XHJcbiAgICAgICAgdmFyIHR4LCB0eTtcclxuICAgICAgICBpZiAoY3AyWzBdICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2YXIgY3ViaWNBdCA9IGN1cnZlVXRpbC5jdWJpY0F0O1xyXG4gICAgICAgICAgICB2YXIgY3ViaWNEZXJpdmF0aXZlQXQgPSBjdXJ2ZVV0aWwuY3ViaWNEZXJpdmF0aXZlQXQ7XHJcbiAgICAgICAgICAgIHBvc1swXSA9IGN1YmljQXQocDFbMF0sIGNwMVswXSwgY3AyWzBdLCBwMlswXSwgdCk7XHJcbiAgICAgICAgICAgIHBvc1sxXSA9IGN1YmljQXQocDFbMV0sIGNwMVsxXSwgY3AyWzFdLCBwMlsxXSwgdCk7XHJcbiAgICAgICAgICAgIC8vIFRhbmdlbnRcclxuICAgICAgICAgICAgdHggPSBjdWJpY0Rlcml2YXRpdmVBdChwMVswXSwgY3AxWzBdLCBjcDJbMF0sIHAyWzBdLCB0KTtcclxuICAgICAgICAgICAgdHkgPSBjdWJpY0Rlcml2YXRpdmVBdChwMVsxXSwgY3AxWzFdLCBjcDJbMV0sIHAyWzFdLCB0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcXVhZHJhdGljQXQgPSBjdXJ2ZVV0aWwucXVhZHJhdGljQXQ7XHJcbiAgICAgICAgICAgIHZhciBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgPSBjdXJ2ZVV0aWwucXVhZHJhdGljRGVyaXZhdGl2ZUF0O1xyXG4gICAgICAgICAgICBwb3NbMF0gPSBxdWFkcmF0aWNBdChwMVswXSwgY3AxWzBdLCBwMlswXSwgdCk7XHJcbiAgICAgICAgICAgIHBvc1sxXSA9IHF1YWRyYXRpY0F0KHAxWzFdLCBjcDFbMV0sIHAyWzFdLCB0KTtcclxuICAgICAgICAgICAgLy8gVGFuZ2VudFxyXG4gICAgICAgICAgICB0eCA9IHF1YWRyYXRpY0Rlcml2YXRpdmVBdChwMVswXSwgY3AxWzBdLCBwMlswXSwgdCk7XHJcbiAgICAgICAgICAgIHR5ID0gcXVhZHJhdGljRGVyaXZhdGl2ZUF0KHAxWzFdLCBjcDFbMV0sIHAyWzFdLCB0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zeW1ib2wucm90YXRpb24gPSAtTWF0aC5hdGFuMih0eSwgdHgpIC0gTWF0aC5QSSAvIDI7XHJcblxyXG4gICAgICAgIHRoaXMuc3ltYm9sLmlnbm9yZSA9IGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBFZmZlY3RMaW5lUHJvdG8uc2V0QW5pbWF0aW9uUG9pbnRzUG9seWxpbmUgPSBmdW5jdGlvbihwb2ludHMpIHtcclxuICAgICAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XHJcbiAgICAgICAgdmFyIGFjY0xlbkFyciA9IFswXTtcclxuICAgICAgICB2YXIgbGVuID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcDEgPSBwb2ludHNbaSAtIDFdO1xyXG4gICAgICAgICAgICB2YXIgcDIgPSBwb2ludHNbaV07XHJcbiAgICAgICAgICAgIGxlbiArPSB2ZWMyLmRpc3QocDEsIHAyKTtcclxuICAgICAgICAgICAgYWNjTGVuQXJyLnB1c2gobGVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFjY0xlbkFyci5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBhY2NMZW5BcnJbal0gLz0gbGVuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9vZmZzZXRzID0gYWNjTGVuQXJyO1xyXG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IGxlbjtcclxuICAgICAgICB0aGlzLnN5bWJvbC5fbGFzdEZyYW1lID0gMDtcclxuICAgICAgICB0aGlzLnN5bWJvbC5fX2xhc3RGcmFtZVBlcmNlbnQgPSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBFZmZlY3RMaW5lUHJvdG8udXBkYXRlU3ltYm9sUG9zaXRpb25Qb2x5bGluZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0ID0gdGhpcy5zeW1ib2wuX190O1xyXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLl9wb2ludHM7XHJcbiAgICAgICAgdmFyIG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xyXG4gICAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAoIW9mZnNldHMpIHtcclxuICAgICAgICAgICAgLy8gSGFzIGxlbmd0aCAwXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsYXN0RnJhbWUgPSB0aGlzLl9sYXN0RnJhbWU7XHJcbiAgICAgICAgdmFyIGZyYW1lO1xyXG5cclxuICAgICAgICBpZiAodCA8IHRoaXMuX2xhc3RGcmFtZVBlcmNlbnQpIHtcclxuICAgICAgICAgICAgLy8gU3RhcnQgZnJvbSB0aGUgbmV4dCBmcmFtZVxyXG4gICAgICAgICAgICAvLyBQRU5ESU5HIHN0YXJ0IGZyb20gbGFzdEZyYW1lID9cclxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5taW4obGFzdEZyYW1lICsgMSwgbGVuIC0gMSk7XHJcbiAgICAgICAgICAgIGZvciAoZnJhbWUgPSBzdGFydDsgZnJhbWUgPj0gMDsgZnJhbWUtLSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldHNbZnJhbWVdIDw9IHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBQRU5ESU5HIHJlYWxseSBuZWVkIHRvIGRvIHRoaXMgP1xyXG4gICAgICAgICAgICBmcmFtZSA9IE1hdGgubWluKGZyYW1lLCBsZW4gLSAyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBmcmFtZSA9IGxhc3RGcmFtZTsgZnJhbWUgPCBsZW47IGZyYW1lKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXRzW2ZyYW1lXSA+IHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmcmFtZSA9IE1hdGgubWluKGZyYW1lIC0gMSwgbGVuIC0gMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZlYzIubGVycChcclxuICAgICAgICAgICAgdGhpcy5zeW1ib2wucG9zaXRpb24sIHBvaW50c1tmcmFtZV0sIHBvaW50c1tmcmFtZSArIDFdLFxyXG4gICAgICAgICAgICAodCAtIG9mZnNldHNbZnJhbWVdKSAvIChvZmZzZXRzW2ZyYW1lICsgMV0gLSBvZmZzZXRzW2ZyYW1lXSlcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICB0aGlzLl9sYXN0RnJhbWUgPSBmcmFtZTtcclxuICAgICAgICB0aGlzLl9sYXN0RnJhbWVQZXJjZW50ID0gdDtcclxuICAgICAgICB2YXIgYW5nbGUgPSAtTWF0aC5hdGFuMihwb2ludHNbZnJhbWUgKyAxXVsxXSAtIHBvaW50c1tmcmFtZV1bMV0sIHBvaW50c1tmcmFtZSArIDFdWzBdIC0gcG9pbnRzW2ZyYW1lXVswXSk7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wucm90YXRpb24gPSBhbmdsZSAtIE1hdGguUEkgLyAyO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLmlnbm9yZSA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gRWZmZWN0TGluZTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvRWZmZWN0TGluZS5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOaOp+WItueCuVxyXG4gKiBAYXV0aG9yIHdhbmcueGlhb2h1XHJcbiAqL1xyXG5cclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uL2dyYXBoaWMuanNcIik7XHJcbiAgICBmdW5jdGlvbiBDb25uZWN0aW9uUG9pbnQoY29ubmVjdG9yLCBwb2ludCwgdHlwZSwgb3B0aW9ucyl7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0b3IgPSBjb25uZWN0b3I7XHJcblxyXG4gICAgICAgIHRoaXMucG9pbnQgPSBwb2ludC5jbG9uZSgpO1xyXG5cclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG5cclxuICAgICAgICB0aGlzLmNvbG9yID0gQ29ubmVjdGlvblBvaW50Lk5PUk1BTF9DT0xPUjtcclxuXHJcbiAgICAgICAgdGhpcy5vVHlwZSA9ICdDb25uZWN0aW9uUG9pbnQnO1xyXG5cclxuICAgICAgICB0aGlzLnNoYXBlID0gbmV3IGdyYXBoaWMuQ2lyY2xlKHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIGN4OiB0aGlzLnBvaW50LngsXHJcbiAgICAgICAgICAgICAgICBjeTogdGhpcy5wb2ludC55LFxyXG4gICAgICAgICAgICAgICAgcjogQ29ubmVjdGlvblBvaW50LlJBRElVU1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IHRoaXMuY29sb3IsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6JyMwMDAwMDAnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHogOiBvcHRpb25zLnogKyAyICAvL+iKgueCuVrkuLoxIOe6v+auteS4ujA7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zaGFwZS50eXBlID0gIHRoaXMudHlwZTtcclxuXHJcbiAgICAgICAgdGhpcy5zaGFwZS5jb25uZWN0b3IgPSBjb25uZWN0b3I7XHJcbiAgICAgICAgLy9yZXR1cm4gdGhpcy5jaXJjbGU7XHJcbiAgICB9XHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50Lk5PUk1BTF9DT0xPUiA9IFwiI0ZGRkYzM1wiOyAvL3llbGxvdy5cclxuXHJcbiAgICBDb25uZWN0aW9uUG9pbnQuT1ZFUl9DT0xPUiA9IFwiI0ZGOTkwMFwiOyAvL29yYW5nZVxyXG5cclxuICAgIENvbm5lY3Rpb25Qb2ludC5DT05ORUNURURfQ09MT1IgPSBcIiNmZjAwMDBcIjsgLy9yZWRcclxuXHJcbiAgICBDb25uZWN0aW9uUG9pbnQuUkFESVVTID0gNDtcclxuXHJcbiAgICBDb25uZWN0aW9uUG9pbnQuVFlQRV9GSUdVUkUgPSAnZmlndXJlJztcclxuXHJcbiAgICBDb25uZWN0aW9uUG9pbnQuVFlQRV9DT05ORUNUT1IgPSAnY29ubmVjdG9yJztcclxuXHJcbiAgICBDb25uZWN0aW9uUG9pbnQucHJvdG90eXBlID0ge1xyXG5cclxuICAgICAgICBjb25zdHJ1Y3RvciA6IENvbm5lY3Rpb25Qb2ludCxcclxuXHJcbiAgICAgICAgZXF1YWxzIDogZnVuY3Rpb24oYW5vdGhlckNvbm5lY3Rpb25Qb2ludCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvaW50LmVxdWFscyhhbm90aGVyQ29ubmVjdGlvblBvaW50LnBvaW50KVxyXG4gICAgICAgICAgICAmJiB0aGlzLmNvbm5lY3RvciA9PSBhbm90aGVyQ29ubmVjdGlvblBvaW50LmNvbm5lY3RvclxyXG4gICAgICAgICAgICAmJiB0aGlzLnR5cGUgPT0gYW5vdGhlckNvbm5lY3Rpb25Qb2ludC50eXBlXHJcbiAgICAgICAgICAgICYmIHRoaXMuY29sb3IgPT0gYW5vdGhlckNvbm5lY3Rpb25Qb2ludC5jb2xvclxyXG4gICAgICAgICAgICAmJiB0aGlzLnJhZGl1cyA9PSBhbm90aGVyQ29ubmVjdGlvblBvaW50LnJhZGl1cztcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH07XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25Qb2ludDtcclxuXHJcblxyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0aW9uUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDoioLngrnnrYnnmoTmqKHlnotcclxuICog6YeM6Z2i5a2Y55qE5pWw5o2u55So5p2l5aSE55CG5bqP5YiX5YyW5ZKM5Y+N5bqP5YiX5YyWXHJcbiAqIEBjbGFzcyBmaXNoLnRvcG8ubW9kZWxcclxuICovXHJcblxyXG5cclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBjbGF6elV0aWwgPSByZXF1aXJlKCcuL2NsYXp6Jyk7XHJcblxyXG4gICAgZnVuY3Rpb24gTW9kZWwob3B0aW9uLCBwYXJlbnRNb2RlbCwgIGV4dHJhT3B0KSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRNb2RlbCA9IHBhcmVudE1vZGVsO1xyXG4gICAgICAgIHRoaXMub3B0aW9uID0gb3B0aW9uO1xyXG5cclxuICAgICAgICAvLyBTaW1wbGUgb3B0aW1pemF0aW9uXHJcbiAgICAgICAgaWYgKHRoaXMuaW5pdCkge1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQob3B0aW9uLCBwYXJlbnRNb2RlbCwgIGV4dHJhT3B0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIE1vZGVsLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3I6IE1vZGVsLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNb2RlbCDnmoTliJ3lp4vljJblh73mlbBcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBpbml0OiBmdW5jdGlvbiAob3B0aW9uKSB7XHJcbiAgICAgICAgICAgIHpyVXRpbC5tZXJnZShvcHRpb24sIHRoaXMuZ2V0RGVmYXVsdE9wdGlvbigpKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXREZWZhdWx0T3B0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eSgnX19kZWZhdWx0T3B0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvcHRMaXN0ID0gW107XHJcbiAgICAgICAgICAgICAgICB2YXIgQ2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKENsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdCA9IENsYXNzLnByb3RvdHlwZS5kZWZhdWx0T3B0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdCAmJiBvcHRMaXN0LnB1c2gob3B0KTtcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IENsYXNzLnN1cGVyQ2xhc3M7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRPcHRpb24gPSB7fTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBvcHRMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdE9wdGlvbiA9IHpyVXRpbC5tZXJnZShkZWZhdWx0T3B0aW9uLCBvcHRMaXN0W2ldLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX19kZWZhdWx0T3B0aW9uID0gZGVmYXVsdE9wdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RlZmF1bHRPcHRpb247XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICB6clV0aWwubWVyZ2UodGhpcy5vcHRpb24sIG9wdGlvbiwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635Y+WbW9kZWznmoTmn5DkuKrlsZ7mgKfnmoTlgLxcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBtb2RlbOS4reeahOWxnuaAp1xyXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ31cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgICAgICBub2RlLm1vZGVsLmdldChcIm9wdGlvbnMudGV4dFwiKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChwYXRoLCBpZ25vcmVQYXJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKCFwYXRoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb247XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBvYmogPSB0aGlzLm9wdGlvbjtcclxuICAgICAgICAgICAgdmFyIHBhcmVudE1vZGVsID0gdGhpcy5wYXJlbnRNb2RlbDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBvYmogY291bGQgYmUgbnVtYmVyL3N0cmluZy8uLi4gKGxpa2UgMClcclxuICAgICAgICAgICAgICAgIG9iaiA9IChvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpID8gb2JqW3BhdGhbaV1dIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChvYmogPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvYmogPT0gbnVsbCAmJiBwYXJlbnRNb2RlbCAmJiAhaWdub3JlUGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBvYmogPSBwYXJlbnRNb2RlbC5nZXQocGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDorr7nva5tb2RlbOeahOafkOS4quWxnuaAp+eahOWAvFxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIG1vZGVs5Lit55qE5bGe5oCnXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIOaJgOmcgOimgeiuvue9rueahOWAvFxyXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ31cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgICAgICBub2RlLm1vZGVsLnNldChcIm9wdGlvbnMudGV4dFwiLFwi5L6L5a2QXCIpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHBhdGgsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBvYmogPSB0aGlzLm9wdGlvbjtcclxuXHJcbiAgICAgICAgICAgIGlmIChwYXRoLmluZGV4T2YoXCIuXCIpID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBvYmpbcGF0aF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaWVsZEFycmF5ICA9IHBhdGguc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgICAgIHZhciBuID0gZmllbGRBcnJheS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFJlZiA9IG9iajtcclxuICAgICAgICAgICAgICAgIHZhciBmaWVsZE5hbWU7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lID0gZmllbGRBcnJheVtpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZihjdXJyZW50UmVmW2ZpZWxkTmFtZV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVmW2ZpZWxkTmFtZV0gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlZiA9IGN1cnJlbnRSZWZbZmllbGROYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZpZWxkTmFtZSA9IGZpZWxkQXJyYXlbbi0xXTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSZWZbZmllbGROYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRTaGFsbG93OiBmdW5jdGlvbiAoa2V5LCBpZ25vcmVQYXJlbnQpIHtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xyXG4gICAgICAgICAgICB2YXIgdmFsID0gb3B0aW9uICYmIG9wdGlvbltrZXldO1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50TW9kZWwgPSB0aGlzLnBhcmVudE1vZGVsO1xyXG4gICAgICAgICAgICBpZiAodmFsID09IG51bGwgJiYgcGFyZW50TW9kZWwgJiYgIWlnbm9yZVBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gcGFyZW50TW9kZWwuZ2V0U2hhbGxvdyhrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRNb2RlbDogZnVuY3Rpb24gKHBhdGgsIHBhcmVudE1vZGVsKSB7XHJcbiAgICAgICAgICAgIHZhciBvYmogPSB0aGlzLmdldChwYXRoLCB0cnVlKTtcclxuICAgICAgICAgICAgdmFyIHRoaXNQYXJlbnRNb2RlbCA9IHRoaXMucGFyZW50TW9kZWw7XHJcbiAgICAgICAgICAgIHZhciBtb2RlbCA9IG5ldyBNb2RlbChcclxuICAgICAgICAgICAgICAgIG9iaiwgcGFyZW50TW9kZWwgfHwgKHRoaXNQYXJlbnRNb2RlbCAmJiB0aGlzUGFyZW50TW9kZWwuZ2V0TW9kZWwocGF0aCkpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHJldHVybiBtb2RlbDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKua4heepum1vZGVs55qEb3B0aW9uXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbiA9PSBudWxsO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlc3RvcmVEYXRhOiBmdW5jdGlvbiAoKSB7fSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgQ3RvciA9IHRoaXMuY29uc3RydWN0b3I7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ3Rvcih6clV0aWwuY2xvbmUodGhpcy5vcHRpb24pKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEVuYWJsZSBNb2RlbC5leHRlbmQuXHJcbiAgICBjbGF6elV0aWwuZW5hYmxlQ2xhc3NFeHRlbmQoTW9kZWwpO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gTW9kZWw7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG5cclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuXHJcbiAgICB2YXIgY2xhenogPSB7fTtcclxuXHJcbiAgICB2YXIgVFlQRV9ERUxJTUlURVIgPSAnLic7XHJcbiAgICB2YXIgSVNfQ09OVEFJTkVSID0gJ19fX0ZUX19DT01QT05FTlRfX0NPTlRBSU5FUl9fXyc7XHJcbiAgICAvKipcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgdmFyIHBhcnNlQ2xhc3NUeXBlID0gY2xhenoucGFyc2VDbGFzc1R5cGUgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgIHZhciByZXQgPSB7bWFpbjogJycsIHN1YjogJyd9O1xyXG4gICAgICAgIGlmIChjb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSBjb21wb25lbnRUeXBlLnNwbGl0KFRZUEVfREVMSU1JVEVSKTtcclxuICAgICAgICAgICAgcmV0Lm1haW4gPSBjb21wb25lbnRUeXBlWzBdIHx8ICcnO1xyXG4gICAgICAgICAgICByZXQuc3ViID0gY29tcG9uZW50VHlwZVsxXSB8fCAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwdWJsaWMgIOebuOavlCDnm7TmjqXnlKh6clV0aWwuaW5oZXJpdHMg5aW95aSE5pivICDlj6/ku6Xnm7TmjqXosIPnlKjniLbnsbvnmoTmnoTpgKDlh73mlbBcclxuICAgICAqL1xyXG4gICAgY2xhenouZW5hYmxlQ2xhc3NFeHRlbmQgPSBmdW5jdGlvbiAoUm9vdENsYXNzLCBwcmVDb25zdHJ1Y3QpIHtcclxuICAgICAgICBSb290Q2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3RvKSB7XHJcbiAgICAgICAgICAgIHZhciBFeHRlbmRlZENsYXNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcHJlQ29uc3RydWN0ICYmIHByZUNvbnN0cnVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgUm9vdENsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB6clV0aWwuZXh0ZW5kKEV4dGVuZGVkQ2xhc3MucHJvdG90eXBlLCBwcm90byk7XHJcblxyXG4gICAgICAgICAgICBFeHRlbmRlZENsYXNzLmV4dGVuZCA9IHRoaXMuZXh0ZW5kO1xyXG4gICAgICAgICAgICBFeHRlbmRlZENsYXNzLnN1cGVyQ2FsbCA9IHN1cGVyQ2FsbDtcclxuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5zdXBlckFwcGx5ID0gc3VwZXJBcHBseTtcclxuICAgICAgICAgICAgenJVdGlsLmluaGVyaXRzKEV4dGVuZGVkQ2xhc3MsIHRoaXMpO1xyXG4gICAgICAgICAgICBFeHRlbmRlZENsYXNzLnN1cGVyQ2xhc3MgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIEV4dGVuZGVkQ2xhc3M7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gc3VwZXJDYWxsIHNob3VsZCBoYXZlIGNsYXNzIGluZm8sIHdoaWNoIGNhbiBub3QgYmUgZmV0Y2ggZnJvbSAndGhpcycuXHJcbiAgICAvLyBDb25zaWRlciB0aGlzIGNhc2U6XHJcbiAgICAvLyBjbGFzcyBBIGhhcyBtZXRob2QgZixcclxuICAgIC8vIGNsYXNzIEIgaW5oZXJpdHMgY2xhc3MgQSwgb3ZlcnJpZGVzIG1ldGhvZCBmLCBmIGNhbGwgc3VwZXJBcHBseSgnZicpLFxyXG4gICAgLy8gY2xhc3MgQyBpbmhlcml0cyBjbGFzcyBCLCBkbyBub3Qgb3ZlcnJpZGVzIG1ldGhvZCBmLFxyXG4gICAgLy8gdGhlbiB3aGVuIG1ldGhvZCBvZiBjbGFzcyBDIGlzIGNhbGxlZCwgZGVhZCBsb29wIG9jY3VyZWQuXHJcbiAgICBmdW5jdGlvbiBzdXBlckNhbGwoY29udGV4dCwgbWV0aG9kTmFtZSkge1xyXG4gICAgICAgIHZhciBhcmdzID0genJVdGlsLnNsaWNlKGFyZ3VtZW50cywgMik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXJDbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV0uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3VwZXJBcHBseShjb250ZXh0LCBtZXRob2ROYW1lLCBhcmdzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXJDbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV0uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW50aXR5XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZWdpc3RlcldoZW5FeHRlbmRdXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGNsYXp6LmVuYWJsZUNsYXNzTWFuYWdlbWVudCA9IGZ1bmN0aW9uIChlbnRpdHksIG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29tcG9uZW50IG1vZGVsIGNsYXNzZXNcclxuICAgICAgICAgKiBrZXk6IGNvbXBvbmVudFR5cGUsXHJcbiAgICAgICAgICogdmFsdWU6XHJcbiAgICAgICAgICogICAgIGNvbXBvbmVudENsYXNzLCB3aGVuIGNvbXBvbmVudFR5cGUgaXMgJ3h4eCdcclxuICAgICAgICAgKiAgICAgb3IgT2JqZWN0LjxzdWJLZXksIGNvbXBvbmVudENsYXNzPiwgd2hlbiBjb21wb25lbnRUeXBlIGlzICd4eHgueXknXHJcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgc3RvcmFnZSA9IHt9O1xyXG5cclxuICAgICAgICBlbnRpdHkucmVnaXN0ZXJDbGFzcyA9IGZ1bmN0aW9uIChDbGF6eiwgY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50VHlwZS5zdWIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v5bey57uP5rOo5YaM6L+H5LqG77yM55u05o6l6L+U5ZueXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dID0gQ2xheno7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb21wb25lbnRUeXBlLnN1YiAhPT0gSVNfQ09OVEFJTkVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IG1ha2VDb250YWluZXIoY29tcG9uZW50VHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyW2NvbXBvbmVudFR5cGUuc3ViXSA9IENsYXp6O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBDbGF6ejtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBlbnRpdHkuZ2V0Q2xhc3MgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZU1haW4sIHN1YlR5cGUsIHRocm93V2hlbk5vdEZvdW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBDbGF6eiA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZU1haW5dO1xyXG5cclxuICAgICAgICAgICAgaWYgKENsYXp6ICYmIENsYXp6W0lTX0NPTlRBSU5FUl0pIHtcclxuICAgICAgICAgICAgICAgIENsYXp6ID0gc3ViVHlwZSA/IENsYXp6W3N1YlR5cGVdIDogbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRocm93V2hlbk5vdEZvdW5kICYmICFDbGF6eikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgICdDb21wb25lbnQgJyArIGNvbXBvbmVudFR5cGVNYWluICsgJy4nICsgKHN1YlR5cGUgfHwgJycpICsgJyBub3QgZXhpc3RzLiBMb2FkIGl0IGZpcnN0LidcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBDbGF6ejtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBlbnRpdHkuZ2V0Q2xhc3Nlc0J5TWFpblR5cGUgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgIHZhciBvYmogPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl07XHJcblxyXG4gICAgICAgICAgICBpZiAob2JqICYmIG9ialtJU19DT05UQUlORVJdKSB7XHJcbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChvYmosIGZ1bmN0aW9uIChvLCB0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSAhPT0gSVNfQ09OVEFJTkVSICYmIHJlc3VsdC5wdXNoKG8pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvYmopO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGVudGl0eS5oYXNDbGFzcyA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIC8vIEp1c3QgY29uc2lkZXIgY29tcG9uZW50VHlwZS5tYWluLlxyXG4gICAgICAgICAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XHJcbiAgICAgICAgICAgIHJldHVybiAhIXN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gTGlrZSBbJ2FhJywgJ2JiJ10sIGJ1dCBjYW4gbm90IGJlIFsnYWEueHgnXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVudGl0eS5nZXRBbGxDbGFzc01haW5UeXBlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHR5cGVzID0gW107XHJcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHN0b3JhZ2UsIGZ1bmN0aW9uIChvYmosIHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2godHlwZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgYSBtYWluIHR5cGUgaXMgY29udGFpbmVyIGFuZCBoYXMgc3ViIHR5cGVzXHJcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSAgY29tcG9uZW50VHlwZVxyXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZW50aXR5Lmhhc1N1YlR5cGVzID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIG9ialtJU19DT05UQUlORVJdO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGVudGl0eS5wYXJzZUNsYXNzVHlwZSA9IHBhcnNlQ2xhc3NUeXBlO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBtYWtlQ29udGFpbmVyKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcclxuICAgICAgICAgICAgaWYgKCFjb250YWluZXIgfHwgIWNvbnRhaW5lcltJU19DT05UQUlORVJdKSB7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl0gPSB7fTtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcltJU19DT05UQUlORVJdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMucmVnaXN0ZXJXaGVuRXh0ZW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbEV4dGVuZCA9IGVudGl0eS5leHRlbmQ7XHJcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbEV4dGVuZCkge1xyXG4gICAgICAgICAgICAgICAgZW50aXR5LmV4dGVuZCA9IGZ1bmN0aW9uIChwcm90bykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBFeHRlbmRlZENsYXNzID0gb3JpZ2luYWxFeHRlbmQuY2FsbCh0aGlzLCBwcm90byk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVudGl0eS5yZWdpc3RlckNsYXNzKEV4dGVuZGVkQ2xhc3MsIHByb3RvLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGVudGl0eTtcclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjbGF6ejtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9jbGF6ei5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOaTjeS9nOWbvuagh+exu1xyXG4gKiBAYXV0aG9yIHdhbmcueGlhb2h1XHJcbiAqL1xyXG5cclxuXHJcbiAgICB2YXIgSWNvbk9wZXJhdGlvbiA9IHtcclxuICAgICAgICBTVFJBSUdIVF9TVkc6ICdNOTM3LjM1Mzg0NiA3MjQuNjc2OTIzQzg4Mi4yMTUzODUgNjY5LjUzODQ2MiA3OTUuNTY5MjMxIDY2MS42NjE1MzggNzMyLjU1Mzg0NiA3MDEuMDQ2MTU0TDM2Mi4zMzg0NjIgMzMwLjgzMDc2OUM0MDEuNzIzMDc3IDI2Ny44MTUzODUgMzkzLjg0NjE1NCAxODEuMTY5MjMxIDMzOC43MDc2OTIgMTI2LjAzMDc2OSAyNjcuODE1Mzg1IDU1LjEzODQ2MiAxNjUuNDE1Mzg1IDU1LjEzODQ2MiA5NC41MjMwNzcgMTI2LjAzMDc2OSAyMy42MzA3NjkgMTk2LjkyMzA3NyAyMy42MzA3NjkgMjk5LjMyMzA3NyA5NC41MjMwNzcgMzcwLjIxNTM4NSAxNDkuNjYxNTM4IDQyNS4zNTM4NDYgMjM2LjMwNzY5MiA0MzMuMjMwNzY5IDI5OS4zMjMwNzcgMzkzLjg0NjE1NEw2NjkuNTM4NDYyIDc2NC4wNjE1MzhDNjMwLjE1Mzg0NiA4MjcuMDc2OTIzIDYzOC4wMzA3NjkgOTEzLjcyMzA3NyA2OTMuMTY5MjMxIDk2OC44NjE1MzggNzY0LjA2MTUzOCAxMDM5Ljc1Mzg0NiA4NjYuNDYxNTM4IDEwMzkuNzUzODQ2IDkzNy4zNTM4NDYgOTY4Ljg2MTUzOCAxMDAwLjM2OTIzMSA4OTcuOTY5MjMxIDEwMDAuMzY5MjMxIDc5NS41NjkyMzEgOTM3LjM1Mzg0NiA3MjQuNjc2OTIzTDkzNy4zNTM4NDYgNzI0LjY3NjkyM1pNMjc1LjY5MjMwOCAzMDcuMkMyNDQuMTg0NjE1IDMzOC43MDc2OTIgMTg5LjA0NjE1NCAzMzguNzA3NjkyIDE1Ny41Mzg0NjIgMzA3LjIgMTI2LjAzMDc2OSAyNzUuNjkyMzA4IDEyNi4wMzA3NjkgMjIwLjU1Mzg0NiAxNTcuNTM4NDYyIDE4OS4wNDYxNTQgMTg5LjA0NjE1NCAxNTcuNTM4NDYyIDI0NC4xODQ2MTUgMTU3LjUzODQ2MiAyNzUuNjkyMzA4IDE4OS4wNDYxNTQgMzA3LjIgMjIwLjU1Mzg0NiAzMDcuMiAyNjcuODE1Mzg1IDI3NS42OTIzMDggMzA3LjJMMjc1LjY5MjMwOCAzMDcuMlpNODc0LjMzODQ2MiA5MTMuNzIzMDc3Qzg0Mi44MzA3NjkgOTQ1LjIzMDc2OSA3ODcuNjkyMzA4IDk0NS4yMzA3NjkgNzU2LjE4NDYxNSA5MTMuNzIzMDc3IDcyNC42NzY5MjMgODgyLjIxNTM4NSA3MjQuNjc2OTIzIDgyNy4wNzY5MjMgNzU2LjE4NDYxNSA3OTUuNTY5MjMxIDc4Ny42OTIzMDggNzY0LjA2MTUzOCA4NDIuODMwNzY5IDc2NC4wNjE1MzggODc0LjMzODQ2MiA3OTUuNTY5MjMxIDkwNS44NDYxNTQgODI3LjA3NjkyMyA5MDUuODQ2MTU0IDg3NC4zMzg0NjIgODc0LjMzODQ2MiA5MTMuNzIzMDc3TDg3NC4zMzg0NjIgOTEzLjcyMzA3N1onLFxyXG4gICAgICAgIEpBR0dFRF9TVkc6ICdNMjA0LjggODE5LjJsLTUxLjItMTAyLjQgMjA0LjgtMzA3LjIgNTEuMiAxMDIuNC0yMDQuOCAzMDcuMnpNNDA5LjYgNTEybDUxLjItMTAyLjQgMTUzLjYgMjA0LjgtNTEuMiAxMDIuNC0xNTMuNi0yMDQuOHpNODE5LjIgMjA0LjhsNTEuMiAxMDIuNC0yMDQuOCA0MDkuNi01MS4yLTEwMi40IDIwNC44LTQwOS42eiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE0xNTMuNiA3MTYuOGMtODcuMDQgMC0xNTMuNiA2Ni41Ni0xNTMuNiAxNTMuNnM2Ni41NiAxNTMuNiAxNTMuNiAxNTMuNiAxNTMuNi02Ni41NiAxNTMuNi0xNTMuNi02Ni41Ni0xNTMuNi0xNTMuNi0xNTMuNnogbTUxLjIgMjA0LjhIMTAyLjR2LTEwMi40aDEwMi40djEwMi40ek00MDkuNiAyMDQuOEMzMjIuNTYgMjA0LjggMjU2IDI3MS4zNiAyNTYgMzU4LjRzNjYuNTYgMTUzLjYgMTUzLjYgMTUzLjYgMTUzLjYtNjYuNTYgMTUzLjYtMTUzLjYtNjYuNTYtMTUzLjYtMTUzLjYtMTUzLjZ6IG01MS4yIDIwNC44SDM1OC40VjMwNy4yaDEwMi40djEwMi40ek02MTQuNCA2MTQuNGMtODcuMDQgMC0xNTMuNiA2Ni41Ni0xNTMuNiAxNTMuNnM2Ni41NiAxNTMuNiAxNTMuNiAxNTMuNiAxNTMuNi02Ni41NiAxNTMuNi0xNTMuNi02Ni41Ni0xNTMuNi0xNTMuNi0xNTMuNnogbTUxLjIgMjA0LjhoLTEwMi40di0xMDIuNGgxMDIuNHYxMDIuNHpNODcwLjQgMGMtODcuMDQgMC0xNTMuNiA2Ni41Ni0xNTMuNiAxNTMuNnM2Ni41NiAxNTMuNiAxNTMuNiAxNTMuNiAxNTMuNi02Ni41NiAxNTMuNi0xNTMuNi02Ni41Ni0xNTMuNi0xNTMuNi0xNTMuNnogbTUxLjIgMjA0LjhoLTEwMi40VjEwMi40aDEwMi40djEwMi40eicsXHJcbiAgICAgICAgQ1VSVkVfU1ZHOiAnTTEwMTQuMjg1MDM5IDgyNC4wMjQyMzRsLTE0NS4xNjg0MjgtMTQ0LjM3MjA1Yy0xMi45Njk1OTMtMTIuODU1ODI1LTM3LjU0MzU1OS0xNC41MDU0NjYtNDQuNTk3MTk3IDIuMzMyMjUyLTEuODc3MTc4IDQuNTUwNzM0LTIuMjc1MzY3IDE3LjE3OTAyMi0yLjI3NTM2OCAxNy4xNzkwMjJ2OTcuNTU2MzY5SDMzMC45MzUzODNhMTE4LjMxOTA5NSAxMTguMzE5MDk1IDAgMCAxLTExOC41NDY2MzItMTE3LjkyMDkwNUExMTguMzE5MDk1IDExOC4zMTkwOTUgMCAwIDEgMzMwLjk5MjI2NyA1NjAuODc4MDE2aDQ0NS41MTY4OTljMTIxLjU2MTQ5MyAwIDIyMC40MjYxOTgtOTguMzUyNzQ3IDIyMC40MjYxOTgtMjE5LjIzMTYzcy05OC44NjQ3MDUtMjE5LjE3NDc0Ni0yMjAuNDI2MTk4LTIxOS4xNzQ3NDZIMzQwLjQ5MTkyNUExNzQuMjM2MjQ0IDE3NC4yMzYyNDQgMCAwIDAgMTc0LjEwNTY5OCAwIDE3My43ODExNyAxNzMuNzgxMTcgMCAwIDAgMC4wNDAxMDcgMTczLjA5ODU2YTE3My43ODExNyAxNzMuNzgxMTcgMCAwIDAgMTc0LjA2NTU5MSAxNzMuMDk4NTYgMTc0LjIzNjI0NCAxNzQuMjM2MjQ0IDAgMCAwIDE2Ni4zODYyMjctMTIyLjQ3MTYzOWg0MzYuMDE3MjQxYzY1LjQxNjgwNyAwIDExOC42MDM1MTYgNTIuOTAyMjg4IDExOC42MDM1MTUgMTE3LjkyMDkwNUExMTguMzE5MDk1IDExOC4zMTkwOTUgMCAwIDEgNzc2LjUwOTE2NiA0NTkuNjI0MTc2SDMzMC45OTIyNjdjLTEyMS41MDQ2MDkgMC0yMjAuMzY5MzE0IDk4LjM1Mjc0Ny0yMjAuMzY5MzE0IDIxOS4yMzE2M3M5OC44NjQ3MDUgMjE5LjE3NDc0NiAyMjAuMzY5MzE0IDIxOS4xNzQ3NDZoNDkxLjE5NDg5NXY5Mi41NTA1NjFzMCAxNC4yMjEwNDUgMi4zMzIyNTIgMTkuNzk1Njk1YzcuMDUzNjM4IDE2Ljg5NDYwMiAzMS42Mjc2MDQgMTcuNTc3MjEyIDQ0LjU5NzE5NyA0LjY2NDUwMmwxNDUuMTExNTQzLTE0NC4zMTUxNjVhMzIuODc5MDU2IDMyLjg3OTA1NiAwIDAgMCAwLTQ2LjY0NTAyN3pNMTc0LjEwNTY5OCAyNDQuOTQzMjhjLTM5LjgxODkyNiAwLTcyLjI0MjkwOS0zMi4yNTMzMy03Mi4yNDI5MDktNzEuODQ0NzJzMzIuNDIzOTgzLTcxLjc4NzgzNSA3Mi4yNDI5MDktNzEuNzg3ODM1YzM5LjgxODkyNiAwIDcyLjE4NjAyNSAzMi4xOTY0NDYgNzIuMTg2MDI1IDcxLjc4NzgzNSAwIDM5LjU5MTM4OS0zMi40MjM5ODMgNzEuNzg3ODM1LTcyLjI0MjkwOSA3MS43ODc4MzZ6JyxcclxuICAgICAgICBERUxfU1ZHOiAnTTk4MC45OTIgMjU2aC04NC45OTJ2NjgzLjAwOGMwIDQ3LjEwNC0zNy44ODggODQuOTkyLTg0Ljk5MiA4NC45OTJIMjEyLjk5MmMtNDcuMTA0IDAtODQuOTkyLTM3Ljg4OC04NC45OTItODQuOTkyVjI1Nkg0My4wMDhDMTkuNDU2IDI1NiAwIDIzNi41NDQgMCAyMTIuOTkyYzAtMjMuNTUyIDE5LjQ1Ni00My4wMDggNDMuMDA4LTQzLjAwOEgyNTZWODQuOTkyQzI1NiAzNy44ODggMjkzLjg4OCAwIDM0MC45OTIgMGgzNDAuOTkyQzczMC4xMTIgMCA3NjggMzcuODg4IDc2OCA4NC45OTJ2ODQuOTkyaDIxNC4wMTZjMjMuNTUyIDAgNDMuMDA4IDE5LjQ1NiA0My4wMDggNDMuMDA4LTEuMDI0IDIzLjU1Mi0yMC40OCA0My4wMDgtNDQuMDMyIDQzLjAwOHpNNjgzLjAwOCA4NC45OTJIMzQwLjk5MnY4NC45OTJoMzQwLjk5MlY4NC45OTJ6TTIxMi45OTIgOTM5LjAwOGg1OTYuOTkyVjI1NkgyMTIuOTkydjY4My4wMDh6IG0xNzEuMDA4LTQ3MC4wMTZ2MjU2YzAgMjMuNTUyLTE5LjQ1NiA0My4wMDgtNDMuMDA4IDQzLjAwOC0yMy41NTIgMC00My4wMDgtMTkuNDU2LTQzLjAwOC00My4wMDh2LTI1NmMwLTIzLjU1MiAxOS40NTYtNDMuMDA4IDQzLjAwOC00My4wMDggMjMuNTUyIDEuMDI0IDQzLjAwOCAxOS40NTYgNDMuMDA4IDQzLjAwOHpNNTEyIDQyNy4wMDhjMjMuNTUyIDAgNDMuMDA4IDE5LjQ1NiA0My4wMDggNDMuMDA4djI1NmMwIDIzLjU1Mi0xOS40NTYgNDMuMDA4LTQzLjAwOCA0My4wMDgtMjMuNTUyIDAtNDMuMDA4LTE5LjQ1Ni00My4wMDgtNDMuMDA4di0yNTZjMC0yNC41NzYgMTkuNDU2LTQzLjAwOCA0My4wMDgtNDMuMDA4eiBtMTcxLjAwOCAwYzIzLjU1MiAwIDQzLjAwOCAxOS40NTYgNDMuMDA4IDQzLjAwOHYyNTZjMCAyMy41NTItMTkuNDU2IDQzLjAwOC00My4wMDggNDMuMDA4LTIzLjU1MiAwLTQzLjAwOC0xOS40NTYtNDMuMDA4LTQzLjAwOHYtMjU2YzAtMjQuNTc2IDE5LjQ1Ni00My4wMDggNDMuMDA4LTQzLjAwOHonLFxyXG4gICAgICAgIENPTU1FTlRfU1ZHOiAnTTIwOS45MiAxNTIuMDY0bDU3Mi40MTYgMS41MzZjMTIuOCAwIDIzLjA0IDEwLjI0IDIzLjA0IDIzLjA0djIzNy41NjhjMCAxMi44IDEwLjI0IDIzLjA0IDIzLjA0IDIzLjA0czIzLjA0LTEwLjI0IDIzLjA0LTIzLjA0VjEyNS40NGMwLTEyLjgtMTAuMjQtMjMuMDQtMjMuMDQtMjMuMDRIMTU4LjcyYy0xMi44IDAtMjMuMDQgMTAuMjQtMjMuMDQgMjMuMDR2NzczLjEyYzAgMTIuOCAxMC4yNCAyMy4wNCAyMy4wNCAyMy4wNGgyMzYuMDMyYzEyLjggMCAyMy4wNC0xMC4yNCAyMy4wNC0yMy4wNHMtMTAuMjQtMjIuNTI4LTIyLjUyOC0yMy4wNGwtMTg1Ljg1Ni0xLjUzNmMtMTIuOCAwLTIyLjUyOC0xMC4yNC0yMi41MjgtMjMuMDRWMTc0LjU5MmMwLTEyLjI4OCAxMC4yNC0yMi41MjggMjMuMDQtMjIuNTI4eiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTTI2OC44IDU3MC4zNjhoMTU5LjIzMmMxMy4zMTIgMCAyNC4wNjQgMTAuNzUyIDI0LjU3NiAyNC4wNjR2Mi41NmMwIDEzLjMxMi0xMC43NTIgMjQuNTc2LTI0LjU3NiAyNC41NzZIMjY4LjhjLTEzLjMxMiAwLTI0LjA2NC0xMC43NTItMjQuNTc2LTI0LjA2NHYtMi41NmMwLjUxMi0xMy4zMTIgMTEuMjY0LTI0LjU3NiAyNC41NzYtMjQuNTc2eiBtMC0zMTIuMzJoNDQxLjM0NGMxMy4zMTIgMCAyNC41NzYgMTAuNzUyIDI0LjU3NiAyNC41NzZ2Mi41NmMwIDEzLjMxMi0xMC43NTIgMjQuNTc2LTI0LjU3NiAyNC41NzZIMjY4LjhjLTEzLjMxMiAwLTI0LjU3Ni0xMC43NTItMjQuNTc2LTI0LjU3NnYtMi41NmMwLjUxMi0xMy4zMTIgMTEuMjY0LTI0LjU3NiAyNC41NzYtMjQuNTc2eiBtMC41MTIgMTU1LjY0OGgyNjkuMzEyYzEzLjMxMiAwIDI0LjU3NiAxMC43NTIgMjQuNTc2IDI0LjA2NHYyLjU2YzAgMTMuMzEyLTEwLjc1MiAyNC41NzYtMjQuNTc2IDI0LjU3NkgyNjkuMzEyYy0xMy4zMTIgMC0yNC41NzYtMTAuNzUyLTI0LjU3Ni0yNC4wNjR2LTIuNTZjMC0xMy44MjQgMTAuNzUyLTI0LjU3NiAyNC41NzYtMjQuNTc2eiBtNDcxLjA0IDEzLjMxMmwtMjQ2Ljc4NCAzMzkuNDU2Yy0xLjUzNiAyLjU2LTIuNTYgNS42MzItMi41NiA4LjcwNGwtMS41MzYgMTMyLjA5NmMwIDkuNzI4IDkuNzI4IDE2Ljg5NiAxOC45NDQgMTQuMzM2bDEyMi44OC0zNy44ODhjMy4wNzItMS4wMjQgNS42MzItMy4wNzIgNy42OC01LjYzMmwyNDYuNzg0LTMzOC45NDRjNC42MDgtNi4xNDQgMy41ODQtMTUuMzYtMi41Ni0xOS45NjhsLTEyMS4zNDQtOTQuNzJjLTcuMTY4LTUuNjMyLTE2Ljg5Ni00LjA5Ni0yMS41MDQgMi41NnogbTIzLjA0IDY3LjU4NGw1MS4yIDM5LjkzNmMyLjA0OCAxLjUzNiAyLjU2IDUuMTIgMS4wMjQgNy4xNjhsLTI2LjExMiAzNS44NGMtMS41MzYgMi41Ni01LjEyIDMuMDcyLTcuNjggMS4wMjRsLTUxLjcxMi0zOC45MTJjLTIuMDQ4LTEuNTM2LTIuNTYtNC42MDgtMS4wMjQtNy4xNjhsMjYuNjI0LTM3LjM3NmMyLjA0OC0xLjUzNiA1LjYzMi0yLjA0OCA3LjY4LTAuNTEyeiBtLTE2NS44ODggMzQxLjUwNGwtMzUuMzI4IDEwLjc1MmMtOS4yMTYgMy4wNzItMTguOTQ0LTQuMDk2LTE4Ljk0NC0xMy44MjRsMC41MTItNDAuOTZjMC0zLjA3MiAxLjAyNC02LjE0NCAyLjU2LTguNzA0bDEzNy4yMTYtMTg3LjkwNGMxLjUzNi0yLjU2IDUuMTItMi41NiA3LjE2OC0xLjAyNGw1MS4yIDM4LjRjMi41NiAyLjA0OCAzLjA3MiA1LjEyIDEuMDI0IDcuNjhsLTEzNy43MjggMTg5Ljk1MmMtMi4wNDggMi41Ni00LjYwOCA0LjYwOC03LjY4IDUuNjMyeicsXHJcbiAgICAgICAgQ0hBTkdFX0xJTkVfVFlQRV9TVkc6ICdNMTAwOCAzMzUuMiAxMDA4IDMzNS4ybC0xNjAgMTQ0IDAgMGMtOC44IDgtMjAgMTIuOC0zMiAxMi44LTI2LjQgMC00OC0yMS42LTQ4LTQ4IDAtMTQuNCA2LjQtMjYuNCAxNi0zNS4ybDAgMCA2Ny4yLTYwTDU2MCAzNDguOGMwIDAgMCAwIDAgMEw0NjQgMzQ4LjhsMCAwTDM1MiAzNDguOCA0OCAzNDguOGMtMjYuNCAwLTQ4LTIxLjYtNDgtNDggMC0yNi40IDIxLjYtNDggNDgtNDhsMTI0LjggMCAwIDBMNDE2IDI1Mi44bDAgMCAyMDggMCAwIDAgMjI3LjIgMEw3ODQgMTkybDAgMGMtOS42LTguOC0xNi0yMS42LTE2LTM1LjIgMC0yNi40IDIxLjYtNDggNDgtNDggMTIgMCAyMy4yIDQuOCAzMiAxMi44bDAgMCAxNjAgMTQ0IDAgMGM5LjYgOC44IDE2IDIxLjYgMTYgMzUuMkMxMDI0IDMxNC40IDEwMTcuNiAzMjYuNCAxMDA4IDMzNS4yek0xNiA2ODAuOCAxNiA2ODAuOGwxNjAtMTQ0IDAgMGM4LjgtOCAyMC0xMi44IDMyLTEyLjggMjYuNCAwIDQ4IDIxLjYgNDggNDggMCAxNC40LTYuNCAyNi40LTE2IDM1LjJsMCAwLTY3LjIgNjBMNDAwIDY2Ny4ybDAgMCAyMDggMCAwIDAgMjQzLjIgMCAwIDBMOTc2IDY2Ny4yYzI2LjQgMCA0OCAyMS42IDQ4IDQ4IDAgMjYuNC0yMS42IDQ4LTQ4IDQ4TDY3MiA3NjMuMiA1NjAgNzYzLjJjMCAwIDAgMCAwIDBMNDY0IDc2My4ybDAgMEwxNzIuOCA3NjMuMiAyNDAgODI0bDAgMGM5LjYgOC44IDE2IDIxLjYgMTYgMzUuMiAwIDI2LjQtMjEuNiA0OC00OCA0OC0xMiAwLTIzLjItNC44LTMyLTEyLjhsMCAwTDE2IDc1MmwwIDBjLTkuNi04LjgtMTYtMjEuNi0xNi0zNS4yQzAgNzAxLjYgNi40IDY4OS42IDE2IDY4MC44eidcclxuICAgIH1cclxuICAgIG1vZHVsZS5leHBvcnRzID0gSWNvbk9wZXJhdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvSWNvbk9wZXJhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIGZsb3fov57nur/nrqHnkIbnsbtcclxuICogQGF1dGhvciBtaWFvLmN1bnpoaVxyXG4gKi9cclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgQ29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvQ29ubmVjdGlvbk1hbmFnZXIuanNcIik7XHJcbiAgICB2YXIgQ29ubmVjdG9yID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG4gICAgdmFyIFV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvdXRpbCcpO1xyXG4gICAgdmFyIFBvaW50ID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9Qb2ludC5qc1wiKTtcclxuICAgIHZhciBDb25zdGFudHMgPSByZXF1aXJlKFwiLi4vdXRpbC9GbG93Q29uc3RhbnRzLmpzXCIpO1xyXG5cclxuICAgIGZ1bmN0aW9uIEZsb3dDb25uZWN0aW9uTWFuYWdlcihhcGkpIHtcclxuICAgICAgICBDb25uZWN0aW9uTWFuYWdlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuYnVuZGxlT2Zmc2V0ID0gMzA7IC8v5aSa57q/5q6155qE5YGP56e7XHJcbiAgICAgICAgdGhpcy5idW5kbGVHYXAgPSAyMDsgLy8g5aSa57q/5q6155qE6Ze06ZqUXHJcbiAgICAgICAgdGhpcy5jb25uZWN0b3JNYXAgPSBVdGlsLlN0YWNrZWRNYXAuY3JlYXRlTmV3KCk7IC8v5a2Y5pS+5aSa57q/5q61XHJcbiAgICAgICAgdGhpcy5fYXBpID0gYXBpO1xyXG4gICAgfVxyXG5cclxuICAgIEZsb3dDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oY29ubmVjdG9yKSB7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0b3JzLnB1c2goY29ubmVjdG9yKTtcclxuICAgICAgICAvLzEu5aSE55CG5LqL5Lu2XHJcbiAgICAgICAgdGhpcy5oYW5kbGVDb25uZWN0b3JFdmVudChjb25uZWN0b3IpO1xyXG4gICAgICAgIC8vMi7liKTmlq3mmK/lkKbkuKToioLngrnnm7jogZRcclxuICAgICAgICBpZihjb25uZWN0b3Iuc3RhcnROb2RlICYmIGNvbm5lY3Rvci5lbmROb2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLmdldFR3b05vZGVJZChjb25uZWN0b3Iuc3RhcnROb2RlLCBjb25uZWN0b3IuZW5kTm9kZSwgY29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rvck1hcC5hZGQoa2V5LCBjb25uZWN0b3IpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVDb25uZWN0b3JTaHJpbmsoY29ubmVjdG9yKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYnVuZGxlT2Zmc2V0ID0gY29ubmVjdG9yLm9wdGlvbnMuYnVuZGxlT2Zmc2V0IHx8IHRoaXMuYnVuZGxlT2Zmc2V0O1xyXG4gICAgICAgICAgICB0aGlzLmJ1bmRsZUdhcCA9IGNvbm5lY3Rvci5vcHRpb25zLmJ1bmRsZUdhcCB8fCB0aGlzLmJ1bmRsZUdhcDtcclxuICAgICAgICAgICAgLy8yLiDojrflj5bov5nkuKprZXnlr7nlupTnmoTnur/mrrXmlbDnu4RcclxuICAgICAgICAgICAgdmFyIGFyckNvbnMgPSB0aGlzLmNvbm5lY3Rvck1hcC5nZXQoa2V5KTtcclxuICAgICAgICAgICAgaWYgKGFyckNvbnMubGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgICAgICAgIC8v5Lik5Liq6IqC54K55Y+q5pyJ5LiA5Liq6L+e57q/55qE5oOF5Ya1XHJcbiAgICAgICAgICAgICAgICAvL+WIpOaWreS4gOS4iyBtb2RlbOmHjOacieayoeaciWRvY2tlcnPvvIzlpoLmnpzmnInliJnosIPnlKjmnoTpgKBwb2ludOaVsOe7hCAg5oiW6ICF6LCD55SocmVmcmVzaENvbm5lY3Rvcuiuoeeul+WmguS9leeUu+e6v1xyXG4gICAgICAgICAgICAgICAgdmFyIGRvY2tlcnMgPSBjb25uZWN0b3Iub3B0aW9ucy5kb2NrZXJzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRvY2tlcnMgJiYgZG9ja2Vycy5sZW5ndGggPj0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IFBvaW50LmxvYWRBcnJheShkb2NrZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3IucmVmcmVzaChwb2ludHMpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb24ucG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcnJTdGFydEVuZFBvaW50ID0gdGhpcy5nZXRTdGFydEVuZFBvaW50KGNvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IGNvbm5lY3Rvci5vcHRpb25zLnBvc2l0aW9uLnBvaW50cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnVuc2hpZnQoYXJyU3RhcnRFbmRQb2ludFswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGFyclN0YXJ0RW5kUG9pbnRbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3IucmVmcmVzaChwb2ludHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaENvbm5lY3RvcihhcnJDb25zWzBdLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJyQ29ucy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAvL+S4pOS4quiKgueCueacieWkmuS4qui/nue6v+eahOaDheWGtVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoQ29ucyhhcnJDb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8v5aSE55CG5rKh5pyJIOi1t+Wni+iKgueCueS4jue7iOatouiKgueCueaXtueahOi/nue6v1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNvbm5lY3RvclBvaW50cyhjb25uZWN0b3IpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLzMu6K6+572u5qih5Z6LXHJcbiAgICAgICAgdGhpcy5oYW5kbGVDb25uZWN0b3JNb2RlbChjb25uZWN0b3IpO1xyXG4gICAgICAgIHJldHVybiBjb25uZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5oYW5kbGVDb25uZWN0b3JFdmVudCA9IGZ1bmN0aW9uKGNvbm5lY3Rvcikge1xyXG4gICAgICAgIGlmIChjb25uZWN0b3IuY29uUG9pbnRzR3JvdXApIHtcclxuICAgICAgICAgICAgY29ubmVjdG9yLmNvblBvaW50c0dyb3VwLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyclNwbGl0ID0gZS50YXJnZXQudHlwZS5zcGxpdChDb25uZWN0b3IuU0VQRVJBVE9SKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb25uZWN0b3IgPSBlLnRhcmdldC5jb25uZWN0b3I7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJyU3BsaXRbMF0gPT09IENvbm5lY3Rvci5TVEFSVF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb24uc3RhcnRQb3MgPSBhcnJTcGxpdFsxXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJyU3BsaXRbMF0gPT09IENvbm5lY3Rvci5FTkRfTk9ERSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5vcHRpb25zLnBvc2l0aW9uLmVuZFBvcyA9IGFyclNwbGl0WzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoQ29ubmVjdG9yKGNvbm5lY3RvciwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBcImNvblBvaW50c0dyb3VwOmNsaWNrXCI7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMubGluZU5vZGUgPSB0aGlzLnNlbENvbm5lY3RvcjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwaS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFsnY2xpY2snLCAnZGJsY2xpY2snXTtcclxuICAgICAgICB6clV0aWwuZWFjaChNT1VTRV9FVkVOVF9OQU1FUywgZnVuY3Rpb24oZXZlTmFtZSkge1xyXG4gICAgICAgICAgICBjb25uZWN0b3Iub24oXCJDb25uZWN0b3I6XCIgKyBldmVOYW1lLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBlLnRhcmdldDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbENvbm5lY3RvciAhPT0gc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbENvbm5lY3RvciAmJiB0aGlzLnJlZnJlc2hDb25uZWN0b3IodGhpcy5zZWxDb25uZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsQ29ubmVjdG9yID0gc2VsZWN0ZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBldmVOYW1lO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnRhcmdldCA9IHRoaXMuc2VsQ29ubmVjdG9yO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBpLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuXHJcbiAgICBGbG93Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmhhbmRsZUNvbm5lY3Rvck1vZGVsID0gZnVuY3Rpb24oY29ubmVjdG9yKSB7XHJcbiAgICAgICAgY29ubmVjdG9yLm1vZGVsLnNldChDb25zdGFudHMuRUxFTUVOVF9UWVBFLCBDb25zdGFudHMuQ09OTkVDVElPTik7XHJcbiAgICAgICAgaWYoY29ubmVjdG9yLnN0YXJ0Tm9kZSAmJiBjb25uZWN0b3IuZW5kTm9kZSkge1xyXG4gICAgICAgICAgICBjb25uZWN0b3IubW9kZWwuc2V0KENvbnN0YW50cy5TVEFSVF9JRCwgY29ubmVjdG9yLnN0YXJ0Tm9kZS5pZCk7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rvci5tb2RlbC5zZXQoQ29uc3RhbnRzLkVORF9JRCwgY29ubmVjdG9yLmVuZE5vZGUuaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25uZWN0b3IubW9kZWwuc2V0KENvbnN0YW50cy5PUFRJT05TLCB6clV0aWwuY2xvbmUoY29ubmVjdG9yLm9wdGlvbnMpKTtcclxuICAgIH1cclxuXHJcbiAgICBGbG93Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmhhbmRsZUNvbm5lY3RvclNocmluayA9IGZ1bmN0aW9uKGNvbm5lY3Rvcikge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAvL+WPjOWHu+aUtue0p+S4uuS4gOadoee6v1xyXG4gICAgICAgIGNvbm5lY3Rvci5saW5lLm9uKFwiZGJsY2xpY2tcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmIChjb25uZWN0b3Iub3B0aW9ucy5pc1NocmluayA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb24gPSB0aGlzLnBhcmVudDtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IGNvbi5zdGFydE5vZGU7XHJcbiAgICAgICAgICAgIHZhciBlbmROb2RlID0gY29uLmVuZE5vZGU7XHJcbiAgICAgICAgICAgIC8vMS7ojrflj5bmiYDmnInnmoTnur/mrrVcclxuICAgICAgICAgICAgdmFyIGtleSA9IHRoYXQuZ2V0VHdvTm9kZUlkKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgY29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb24pO1xyXG4gICAgICAgICAgICB2YXIgY29ucyA9IHRoYXQuY29ubmVjdG9yTWFwLmdldChrZXkpO1xyXG4gICAgICAgICAgICBpZiAoY29ucy5sZW5ndGggPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8yLuWIpOaWree6v+aYr+WQpuWkhOS6jumakOiXj+eKtuaAgVxyXG4gICAgICAgICAgICAvLzIu5bCG6Zmk5Lit6Ze055qE5LiA5p2h57q/6L+b6KGM6ZqQ6JePXHJcbiAgICAgICAgICAgIHZhciBoYWxmID0gcGFyc2VJbnQoY29ucy5sZW5ndGggLyAyKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSAhPSAoaGFsZikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uc1tpXS5pZ25vcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc1tpXS5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc1tpXS5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvL+WkhOeQhuayoeaciSDotbflp4voioLngrnkuI7nu4jmraLoioLngrnml7bnmoTov57nur9cclxuICAgIEZsb3dDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuaGFuZGxlQ29ubmVjdG9yUG9pbnRzID0gZnVuY3Rpb24oY29ubmVjdG9yKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBjb25uZWN0b3Iub3B0aW9ucztcclxuICAgICAgICB2YXIgZG9ja2VycyA9IGNvbm5lY3Rvci5vcHRpb25zLmRvY2tlcnM7XHJcbiAgICAgICAgaWYgKGRvY2tlcnMgJiYgZG9ja2Vycy5sZW5ndGggPj0gMikge1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gUG9pbnQubG9hZEFycmF5KGRvY2tlcnMpO1xyXG4gICAgICAgICAgICBjb25uZWN0b3IucmVmcmVzaChwb2ludHMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uICYmIG9wdGlvbnMucG9zaXRpb24ucG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb1BvaW50cyA9IG9wdGlvbnMucG9zaXRpb24ucG9pbnRzO1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yLnJlZnJlc2gob1BvaW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRUd29Ob2RlSWQgPSBmdW5jdGlvbihzdGFydE5vZGUsIGVuZE5vZGUsIHBvcykge1xyXG4gICAgICAgIHJldHVybiBzdGFydE5vZGUuaWQgKyAnLScgKyBwb3Muc3RhcnRQb3MgKyBcIixcIiArIGVuZE5vZGUuaWQgKyAnLScgKyBwb3MuZW5kUG9zO1xyXG4gICAgfVxyXG4gICAgLy/lpITnkIblpJrmnaHnur/mrrVcclxuICAgIEZsb3dDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVmcmVzaENvbnMgPSBmdW5jdGlvbihhcnJDb25zKSB7XHJcbiAgICAgICAgLy/lpoLmnpzmmK/mipjnur/nmoTor51cclxuICAgICAgICBpZiAoYXJyQ29uc1swXS5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0pBR0dFRCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyckNvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaENvbm5lY3RvcihhcnJDb25zW2ldLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaENvbnNTdHJhaWdodChhcnJDb25zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy/lpITnkIblpJrmnaHnur/mrrUo55u057q/KVxyXG4gICAgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZWZyZXNoQ29uc1N0cmFpZ2h0ID0gZnVuY3Rpb24oYXJyQ29ucykge1xyXG4gICAgICAgIHZhciBoYWxmID0gcGFyc2VJbnQoYXJyQ29ucy5sZW5ndGggLyAyKTtcclxuICAgICAgICB2YXIgYXJyQ29ubmVjdFJlc3VsdCA9IFtdXHJcblxyXG4gICAgICAgIHZhciBzdGFydE5vZGUgPSBhcnJDb25zWzBdLnN0YXJ0Tm9kZTtcclxuICAgICAgICB2YXIgZW5kTm9kZSA9IGFyckNvbnNbMF0uZW5kTm9kZTtcclxuICAgICAgICB2YXIgc1JlY3QgPSBVdGlsLmdldFJlY3Qoc3RhcnROb2RlKTtcclxuICAgICAgICB2YXIgZVJlY3QgPSBVdGlsLmdldFJlY3QoZW5kTm9kZSkuYm91bmRpbmdSZWN0O1xyXG4gICAgICAgIHZhciBzQ29ubmVjdG9yUG9pbnQgPSBVdGlsLmdldENvbm5lY3RvclBvaW50cyhzUmVjdCwgc3RhcnROb2RlKTtcclxuICAgICAgICB2YXIgZUNvbm5lY3RvclBvaW50ID0gVXRpbC5nZXRDb25uZWN0b3JQb2ludHMoZVJlY3QsIGVuZE5vZGUpO1xyXG4gICAgICAgIC8v5Yik5pat5aaC5p6c5rKh5pyJ5oyH5a6a5L2N572u55qE6K+dLCDliKTmlq3lvIDlp4voioLngrnlnKjnu5PmnZ/nu5Pmnpzlt6bovrnliJnph4fnlKggcmlnaHQtbGVmdCDlkKbliJnph4fnlKhsZWZ0LXJpZ2h0XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gYXJyQ29uc1swXS5vcHRpb25zLnBvc2l0aW9uO1xyXG4gICAgICAgIGlmICghcG9zaXRpb24uc3RhcnRQb3MgfHwgIXBvc2l0aW9uLmVuZFBvcykge1xyXG4gICAgICAgICAgICBpZiAoc1JlY3QueCA8IGVSZWN0LngpIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnN0YXJ0UG9zID0gXCJyaWdodFwiO1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24uZW5kUG9zID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5zdGFydFBvcyA9IFwibGVmdFwiO1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24uZW5kUG9zID0gXCJyaWdodFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc3RhcnRQb2ludCA9IHNDb25uZWN0b3JQb2ludFtwb3NpdGlvbi5zdGFydFBvc107XHJcbiAgICAgICAgdmFyIGVuZFBvaW50ID0gZUNvbm5lY3RvclBvaW50W3Bvc2l0aW9uLmVuZFBvc107XHJcbiAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihlbmRQb2ludC55IC0gc3RhcnRQb2ludC55LCBlbmRQb2ludC54IC0gc3RhcnRQb2ludC54KTtcclxuICAgICAgICB2YXIgcG9pbnRzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGhhbGY7IGkgPj0gMTsgaS0tKSB7XHJcbiAgICAgICAgICAgIHBvaW50cyA9IFtdOyAvL3ZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2goc3RhcnRQb2ludCk7IC8vXHJcbiAgICAgICAgICAgIC8vIHBvaW50cy5wdXNoKG5ldyBQb2ludChzdGFydFBvaW50LnggKyBidW5kbGVPZmZzZXQgLCBzdGFydFBvaW50LnkgKyBpICogYnVuZGxlR2FwKSk7XHJcbiAgICAgICAgICAgIC8vIHBvaW50cy5wdXNoKG5ldyBQb2ludChlbmRQb2ludC54IC0gYnVuZGxlT2Zmc2V0ICwgc3RhcnRQb2ludC55ICsgaSAqIGJ1bmRsZUdhcCkpOyAvL3N0YXJ0UG9pbnQueCArIGJ1bmRsZU9mZnNldFxyXG4gICAgICAgICAgICB2YXIgc2Vjb25kUG9pbnQgPSBzdGFydFBvaW50LmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICAvL3NlY29uZFBvaW50LnggPSAgc2Vjb25kUG9pbnQueCArIHRoaXMuYnVuZGxlT2Zmc2V0O1xyXG4gICAgICAgICAgICBzZWNvbmRQb2ludC50cmFuc2Zvcm0oVXRpbC50cmFuc2xhdGlvbk1hdHJpeCgwLCB0aGlzLmJ1bmRsZUdhcCAqIGkpKTtcclxuICAgICAgICAgICAgLy9zZWNvbmRQb2ludCA9IHRoaXMuYm91bmRPZmZzZXRYWShzZWNvbmRQb2ludCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8v55u06KeS5Z2Q5qCHIHgsIOWSjCB5LCDorqHnrpflh7rmnoHlnZDmoIdcclxuXHJcblxyXG4gICAgICAgICAgICAvL+S7juaegeWdkOagh+iuoeeul+WHuuebtOinkuWdkOagh1xyXG4gICAgICAgICAgICBzZWNvbmRQb2ludC54ID0gc2Vjb25kUG9pbnQueCArIHRoaXMuYnVuZGxlT2Zmc2V0ICogTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgICAgICBzZWNvbmRQb2ludC55ID0gc2Vjb25kUG9pbnQueSArIHRoaXMuYnVuZGxlT2Zmc2V0ICogTWF0aC5zaW4oYW5nbGUpO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAvL3NlY29uZFBvaW50LnRyYW5zZm9ybShVdGlsLnNjYWxlTWF0cml4KDAuNSkpO1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaChzZWNvbmRQb2ludCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdGhpcmRQb2ludCA9IGVuZFBvaW50LmNsb25lKCk7XHJcbiAgICAgICAgICAgIC8vdGhpcmRQb2ludC54ID0gIHRoaXJkUG9pbnQueCAtIHRoaXMuYnVuZGxlT2Zmc2V0O1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICB0aGlyZFBvaW50LnRyYW5zZm9ybShVdGlsLnRyYW5zbGF0aW9uTWF0cml4KDAsIHRoaXMuYnVuZGxlR2FwICogaSkpO1xyXG4gICAgICAgICAgICAvL3RoaXJkUG9pbnQgPSB0aGlzLmJvdW5kT2Zmc2V0WFkodGhpcmRQb2ludCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAvL3NlY29uZFBvaW50LnRyYW5zZm9ybShVdGlsLnNjYWxlTWF0cml4KDAuNSkpO1xyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvL+ebtOinkuWdkOaghyB4LCDlkowgeSwg6K6h566X5Ye65p6B5Z2Q5qCHXHJcblxyXG4gICAgICAgICAgICAvL+S7juaegeWdkOagh+iuoeeul+WHuuebtOinkuWdkOagh1xyXG4gICAgICAgICAgICB0aGlyZFBvaW50LnggPSB0aGlyZFBvaW50LnggLSB0aGlzLmJ1bmRsZU9mZnNldCAqIE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgICAgICAgdGhpcmRQb2ludC55ID0gdGhpcmRQb2ludC55IC0gdGhpcy5idW5kbGVPZmZzZXQgKiBNYXRoLnNpbihhbmdsZSk7XHJcblxyXG4gICAgICAgICAgICBwb2ludHMucHVzaCh0aGlyZFBvaW50KTtcclxuXHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGVuZFBvaW50KTtcclxuICAgICAgICAgICAgYXJyQ29ubmVjdFJlc3VsdC5wdXNoKHBvaW50cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhcnJDb25uZWN0UmVzdWx0LnB1c2goW3N0YXJ0UG9pbnQsIGVuZFBvaW50XSk7XHJcblxyXG4gICAgICAgIHZhciB1cEhhbGYgPSBNYXRoLmNlaWwoYXJyQ29ucy5sZW5ndGggLyAyKTtcclxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgdXBIYWxmOyBpKyspIHtcclxuICAgICAgICAgICAgcG9pbnRzID0gW107IC8vdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaChzdGFydFBvaW50KTtcclxuICAgICAgICAgICAgdmFyIHNlY1BvaW50ID0gc3RhcnRQb2ludC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAvL3NlY1BvaW50LnggPSAgc2VjUG9pbnQueCArIHRoaXMuYnVuZGxlT2Zmc2V0O1xyXG4gICAgICAgICAgICBzZWNQb2ludC50cmFuc2Zvcm0oVXRpbC50cmFuc2xhdGlvbk1hdHJpeCgwLCAtdGhpcy5idW5kbGVHYXAgKiBpKSk7XHJcbiAgICAgICAgICAgIHNlY1BvaW50LnggPSBzZWNQb2ludC54ICsgdGhpcy5idW5kbGVPZmZzZXQgKiBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICAgICAgICAgIHNlY1BvaW50LnkgPSBzZWNQb2ludC55ICsgdGhpcy5idW5kbGVPZmZzZXQgKiBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHNlY1BvaW50KTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0aGRQb2ludCA9IGVuZFBvaW50LmNsb25lKCk7XHJcbiAgICAgICAgICAgIC8vdGhkUG9pbnQueCA9ICB0aGRQb2ludC54IC0gdGhpcy5idW5kbGVPZmZzZXQ7XHJcbiAgICAgICAgICAgIHRoZFBvaW50LnRyYW5zZm9ybShVdGlsLnRyYW5zbGF0aW9uTWF0cml4KDAsIC10aGlzLmJ1bmRsZUdhcCAqIGkpKTtcclxuICAgICAgICAgICAgLy/ku47mnoHlnZDmoIforqHnrpflh7rnm7Top5LlnZDmoIdcclxuICAgICAgICAgICAgdGhkUG9pbnQueCA9IHRoZFBvaW50LnggLSB0aGlzLmJ1bmRsZU9mZnNldCAqIE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgICAgICAgdGhkUG9pbnQueSA9IHRoZFBvaW50LnkgLSB0aGlzLmJ1bmRsZU9mZnNldCAqIE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICAgICAgLy9zZWNvbmRQb2ludC50cmFuc2Zvcm0oVXRpbC5zY2FsZU1hdHJpeCgwLjUpKTtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2godGhkUG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgcG9pbnRzLnB1c2goZW5kUG9pbnQpO1xyXG4gICAgICAgICAgICBhcnJDb25uZWN0UmVzdWx0LnB1c2gocG9pbnRzKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyQ29ubmVjdFJlc3VsdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBhcnJDb25zW2ldLnJlZnJlc2goYXJyQ29ubmVjdFJlc3VsdFtpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBGbG93Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmJvdW5kT2Zmc2V0WFkgPSBmdW5jdGlvbihwb2ludCwgaXNQb3NpdGl2ZSkge1xyXG4gICAgICAgIHZhciByZXN1bHRQb2ludCA9IHBvaW50LmNsb25lKCk7XHJcbiAgICAgICAgLy/nm7Top5LlnZDmoIcgeCwg5ZKMIHksIOiuoeeul+WHuuaegeWdkOagh1xyXG4gICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIocmVzdWx0UG9pbnQueSwgcmVzdWx0UG9pbnQueCk7XHJcbiAgICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoTWF0aC5wb3cocmVzdWx0UG9pbnQueCwgMikgKyBNYXRoLnBvdyhyZXN1bHRQb2ludC55LCAyKSk7XHJcbiAgICAgICAgaWYgKGlzUG9zaXRpdmUpIHtcclxuICAgICAgICAgICAgciA9IHIgKyB0aGlzLmJ1bmRsZU9mZnNldDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByID0gciAtIHRoaXMuYnVuZGxlT2Zmc2V0O1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8v5LuO5p6B5Z2Q5qCH6K6h566X5Ye655u06KeS5Z2Q5qCHXHJcbiAgICAgICAgcmVzdWx0UG9pbnQueCA9IHIgKiBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICAgICAgcmVzdWx0UG9pbnQueSA9IHIgKiBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdFBvaW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6+572u57q/5q6155qE5qih5Z6L5pWw5o2uICAo57G75Z6LIOaWh+WtlylcclxuICAgICAqIEBwYXJhbSB7W3R5cGVdfSBjb25uZWN0b3IgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtIHtbdHlwZV19IG9wdGlvbiAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIEZsb3dDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0TW9kZWwgPSBmdW5jdGlvbihjb25uZWN0b3IsIG9wdGlvbikge1xyXG4gICAgICAgIHZhciBvcmlnaW5MaW5lVHlwZSA9IGNvbm5lY3Rvci5tb2RlbC5nZXQoXCJzdHlsZS5saW5lVHlwZVwiKTtcclxuICAgICAgICBjb25uZWN0b3IubW9kZWwubWVyZ2VPcHRpb24ob3B0aW9uKTtcclxuICAgICAgICB6clV0aWwubWVyZ2UoY29ubmVjdG9yLm1vZGVsLmdldChcIm9wdGlvbnNcIiksIG9wdGlvbiwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKG9yaWdpbkxpbmVUeXBlICE9PSBvcHRpb24uc3R5bGUubGluZVR5cGUpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoQ29ubmVjdG9yKGNvbm5lY3RvciwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yig6Zmk5oyH5a6a55qE57q/XHJcbiAgICAgKiBAcGFyYW0gY29ubmVjdG9yIOassuWIoOmZpOeahOi/nue6v1xyXG4gICAgICogQHBhcmFtIF96ciB6clxyXG4gICAgICovXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZGVsZXRlQnlMaW5lID0gZnVuY3Rpb24gKGNvbm5lY3RvcixfenIpIHtcclxuICAgICAgICAvLzEu5bCG57q/IOaJgOiBlOeahHN0YXJ0Tm9kZeeahG91dGdvaW5n5pWw5o2u5Yig6ZmkXHJcbiAgICAgICAgaWYoY29ubmVjdG9yLnN0YXJ0Tm9kZSl7XHJcbiAgICAgICAgICAgIHZhciBzdGFydE5vZGVPdXRnb2luZyA9IGNvbm5lY3Rvci5zdGFydE5vZGUubW9kZWwuZ2V0KFwib3V0Z29pbmdcIik7XHJcbiAgICAgICAgICAgIGluZGV4ID0genJVdGlsLmluZGV4T2Yoc3RhcnROb2RlT3V0Z29pbmcsIGNvbm5lY3Rvci5yZXNvdXJjZUlkKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydE5vZGVPdXRnb2luZy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0b3JNYXApIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLmdldFR3b05vZGVJZChjb25uZWN0b3Iuc3RhcnROb2RlLCBjb25uZWN0b3IuZW5kTm9kZSwgY29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JNYXAucmVtb3ZlSXRlbShrZXksIGNvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLzIu5LuOX3py5LiK5Yig6ZmkXHJcbiAgICAgICAgX3pyLnJlbW92ZShjb25uZWN0b3IpO1xyXG5cclxuXHJcbiAgICAgICAgLy8zLuS7jue6v+aVsOaNruS4reWIoOmZpFxyXG4gICAgICAgIHZhciBpbmRleCA9IHpyVXRpbC5pbmRleE9mKHRoaXMuY29ubmVjdG9ycywgY29ubmVjdG9yKTtcclxuICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNlbENvbm5lY3RvciA9PT0gY29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsQ29ubmVjdG9yID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOWIt+aWsOi/nuaOpee6v1xyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBub2RlIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIEZsb3dDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVmcmVzaExpbmVCeU5vZGUgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgLy8g5Yik5pat6L+Z5Liq6IqC54K55piv5ZCm5pyJ5aSa5p2h57q/5q61XHJcbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLmNvbm5lY3Rvck1hcC5rZXlzKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICBpZiAoa2V5LmluZGV4T2Yobm9kZS5pZCkgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcnJDb25zID0gdGhpcy5jb25uZWN0b3JNYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50TGluZVBvcyhhcnJDb25zKVxyXG4gICAgICAgICAgICAgICAgaWYgKGFyckNvbnMubGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL+S4pOS4quiKgueCueWPquacieS4gOS4qui/nue6v+eahOaDheWGtVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaENvbm5lY3RvcihhcnJDb25zWzBdLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJyQ29ucy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy/kuKTkuKroioLngrnmnInlpJrkuKrov57nur/nmoTmg4XlhrVcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hDb25zKGFyckNvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yi35paw6L+e5o6l57q/XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5vZGUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS50b2dnbGVMaW5lQnlOb2RlID0gZnVuY3Rpb24obm9kZSwgaXNTaG93KSB7XHJcbiAgICAgICAgLy8g5Yik5pat6L+Z5Liq6IqC54K55piv5ZCm5pyJ5aSa5p2h57q/5q61XHJcbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLmNvbm5lY3Rvck1hcC5rZXlzKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICBpZiAoa2V5LmluZGV4T2Yobm9kZS5pZCkgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcnJDb25zID0gdGhpcy5jb25uZWN0b3JNYXAuZ2V0KGtleSk7XHJcblxyXG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2goYXJyQ29ucywgZnVuY3Rpb24oY29ubmVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGlzU2hvdykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLnNob3coKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDph43mlrDosIPmlbTnur/nmoTkvY3nva5cclxuICAgICAqL1xyXG4gICAgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb3VudExpbmVQb3MgPSBmdW5jdGlvbihhcnJDb25zKSB7XHJcbiAgICAgICAgenJVdGlsLmVhY2goYXJyQ29ucywgZnVuY3Rpb24oY29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gY29ubmVjdG9yLm9wdGlvbnM7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmF1dG9DaGFuZ2VQb3NpdGlvbiA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc1JlY3QgPSBVdGlsLmdldFJlY3QoY29ubmVjdG9yLnN0YXJ0Tm9kZSkuYm91bmRpbmdSZWN0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGVSZWN0ID0gVXRpbC5nZXRSZWN0KGNvbm5lY3Rvci5lbmROb2RlKS5ib3VuZGluZ1JlY3Q7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRQb3MgPSBvcHRpb25zLnBvc2l0aW9uLnN0YXJ0UG9zO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZFBvcyA9IG9wdGlvbnMucG9zaXRpb24uZW5kUG9zO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0UG9zTm93ID0gdGhpcy5wb3NJc0NoYW5nZShzdGFydFBvcywgc1JlY3QsIGVSZWN0LCBcInN0YXJ0Tm9kZVwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBlbmRQb3NOb3cgPSB0aGlzLnBvc0lzQ2hhbmdlKGVuZFBvcywgc1JlY3QsIGVSZWN0LCBcImVuZE5vZGVcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRQb3MgIT0gc3RhcnRQb3NOb3cgfHwgZW5kUG9zICE9IGVuZFBvc05vdykge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucG9zaXRpb24uc3RhcnRQb3MgPSBzdGFydFBvc05vdztcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uLmVuZFBvcyA9IGVuZFBvc05vdztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5wb3NJc0NoYW5nZSA9IGZ1bmN0aW9uKHBvcywgc1JlY3QsIGVSZWN0LCBub2RlVHlwZSkge1xyXG4gICAgICAgIHZhciBuZXdQb3NcclxuICAgICAgICBpZiAocG9zLmluZGV4T2YoXCJ0b3BcIikgIT0gLTEgfHwgcG9zLmluZGV4T2YoXCJib3R0b21cIikgIT0gLTEpIHtcclxuICAgICAgICAgICAgaWYgKHNSZWN0LnkgKyBzUmVjdC5oZWlnaHQgPCBlUmVjdC55KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT0gXCJzdGFydE5vZGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BvcyA9IHBvcy5yZXBsYWNlKC8odG9wfGJvdHRvbSkvZywgXCJib3R0b21cIik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BvcyA9IHBvcy5yZXBsYWNlKC8odG9wfGJvdHRvbSkvZywgXCJ0b3BcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZVJlY3QueSArIGVSZWN0LmhlaWdodCA8IHNSZWN0LnkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PSBcImVuZE5vZGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BvcyA9IHBvcy5yZXBsYWNlKC8odG9wfGJvdHRvbSkvZywgXCJib3R0b21cIik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BvcyA9IHBvcy5yZXBsYWNlKC8odG9wfGJvdHRvbSkvZywgXCJ0b3BcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc1JlY3QueCArIHNSZWN0LndpZHRoIDwgZVJlY3QueCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVUeXBlID09IFwic3RhcnROb2RlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdQb3MgPSBwb3MucmVwbGFjZSgvKHRvcHxib3R0b20pL2csIFwicmlnaHRcIik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BvcyA9IHBvcy5yZXBsYWNlKC8odG9wfGJvdHRvbSkvZywgXCJsZWZ0XCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVSZWN0LnggKyBlUmVjdC53aWR0aCA8IHNSZWN0LngpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PSBcImVuZE5vZGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BvcyA9IHBvcy5yZXBsYWNlKC8odG9wfGJvdHRvbSkvZywgXCJyaWdodFwiKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UG9zID0gcG9zLnJlcGxhY2UoLyh0b3B8Ym90dG9tKS9nLCBcImxlZnRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld1BvcyA9IHBvcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAocG9zLmluZGV4T2YoXCJsZWZ0XCIpICE9IC0xIHx8IHBvcy5pbmRleE9mKFwicmlnaHRcIikgIT0gLTEpIHtcclxuICAgICAgICAgICAgaWYgKHNSZWN0LnggKyBzUmVjdC53aWR0aCA8IGVSZWN0LngpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PSBcInN0YXJ0Tm9kZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UG9zID0gcG9zLnJlcGxhY2UoLyhyaWdodHxsZWZ0KS9nLCBcInJpZ2h0XCIpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdQb3MgPSBwb3MucmVwbGFjZSgvKHJpZ2h0fGxlZnQpL2csIFwibGVmdFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChlUmVjdC54ICsgZVJlY3Qud2lkdGggPCBzUmVjdC54KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT0gXCJlbmROb2RlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdQb3MgPSBwb3MucmVwbGFjZSgvKHJpZ2h0fGxlZnQpL2csIFwicmlnaHRcIik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BvcyA9IHBvcy5yZXBsYWNlKC8ocmlnaHR8bGVmdCkvZywgXCJsZWZ0XCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNSZWN0LnkgKyBzUmVjdC5oZWlnaHQgPCBlUmVjdC55KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT0gXCJzdGFydE5vZGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BvcyA9IHBvcy5yZXBsYWNlKC8ocmlnaHR8bGVmdCkvZywgXCJib3R0b21cIik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BvcyA9IHBvcy5yZXBsYWNlKC8ocmlnaHR8bGVmdCkvZywgXCJ0b3BcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZVJlY3QueSArIGVSZWN0LmhlaWdodCA8IHNSZWN0LnkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PSBcImVuZE5vZGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BvcyA9IHBvcy5yZXBsYWNlKC8ocmlnaHR8bGVmdCkvZywgXCJib3R0b21cIik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BvcyA9IHBvcy5yZXBsYWNlKC8ocmlnaHR8bGVmdCkvZywgXCJ0b3BcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdQb3MgPSBwb3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuZXdQb3MgPSBwb3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdQb3M7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHpyVXRpbC5pbmhlcml0cyhGbG93Q29ubmVjdGlvbk1hbmFnZXIsIENvbm5lY3Rpb25NYW5hZ2VyKTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL21hbmFnZXIvRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog6L+e57q/566h55CG57G7XHJcbiAqIEBhdXRob3Igd2FuZy54aWFvaHVcclxuICovXHJcblxyXG4gICAgdmFyIFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XHJcbiAgICB2YXIgUG9pbnQgPSByZXF1aXJlKFwiLi4vUG9pbnQuanNcIik7XHJcbiAgICB2YXIgQ29ubmVjdG9yID0gcmVxdWlyZShcIi4uL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcbiAgICB2YXIgTG9nID0gcmVxdWlyZShcIi4uL0xvZy5qc1wiKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuXHJcbiAgICBmdW5jdGlvbiBDb25uZWN0aW9uTWFuYWdlcigpIHtcclxuICAgICAgICB0aGlzLmNvbm5lY3RvcnMgPSBbXTsgLy/lvZPliY3nlLvluIPmiYDmnInnmoTnur/mrrVcclxuICAgICAgICB0aGlzLnNlbENvbm5lY3RvciA9IG51bGw7IC8v5b2T5YmN6YCJ5Lit55qE57q/5q61XHJcbiAgICAgICAgdGhpcy50ZW1wQ29ubmVjdG9yID0gbnVsbDsgLy/kuLTml7bnur/mrrVcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiuvue9rue6v+eahOS4jeWPr+e8lui+kVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBmb3JiaWRFZGl0IFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0b3JGb3JiaWRFZGl0ID0gZnVuY3Rpb24gKGZvcmJpZEVkaXQpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29ubmVjdG9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvcnNbaV0ub3B0aW9ucy5pc0VkaXQgPSAhZm9yYmlkRWRpdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5riF56m66L+e5o6l57q/5LiK55qE6LCD5pW05L2N572u5oyJ6ZKuXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNsZWFyU2VsZWN0Q29uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlbENvbm5lY3RvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaENvbm5lY3Rvcih0aGlzLnNlbENvbm5lY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDliKDpmaTlkozoioLngrnnm7jlhbPogZTnmoTov57mjqXnur9cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZGVsZXRlU2VsZWN0Q29uID0gZnVuY3Rpb24gKG5vZGUsIF96cikge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb25uZWN0b3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RvcnNbaV0uc3RhcnROb2RlID09IG5vZGUgfHwgdGhpcy5jb25uZWN0b3JzW2ldLmVuZE5vZGUgPT0gbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgLy8xLuWwhue6vyDmiYDogZTnmoRzdGFydE5vZGXnmoRvdXRnb2luZ+aVsOaNruWIoOmZpFxyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZU91dGdvaW5nID0gdGhpcy5jb25uZWN0b3JzW2ldLnN0YXJ0Tm9kZS5tb2RlbC5nZXQoXCJvdXRnb2luZ1wiKTtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHpyVXRpbC5pbmRleE9mKHN0YXJ0Tm9kZU91dGdvaW5nLCB0aGlzLmNvbm5lY3RvcnNbaV0ucmVzb3VyY2VJZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE5vZGVPdXRnb2luZy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8yLuS7jl96cuS4iuWIoOmZpFxyXG4gICAgICAgICAgICAgICAgX3pyLnJlbW92ZSh0aGlzLmNvbm5lY3RvcnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsQ29ubmVjdG9yID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVMaW5lID0gZnVuY3Rpb24gKGxpbmUsIHpyKSB7XHJcbiAgICAgICAgdGhpcy5zZWxDb25uZWN0b3IgPSBsaW5lO1xyXG4gICAgICAgIHRoaXMuZGVsZXRlTGluZSh6cik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOWIoOmZpOmAieWumueahOe6v1xyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5kZWxldGVMaW5lID0gZnVuY3Rpb24gKF96cikge1xyXG4gICAgICAgIC8vMS7lsIbnur8g5omA6IGU55qEc3RhcnROb2Rl55qEb3V0Z29pbmfmlbDmja7liKDpmaRcclxuICAgICAgICBpZih0aGlzLnNlbENvbm5lY3Rvci5zdGFydE5vZGUpe1xyXG4gICAgICAgICAgICB2YXIgc3RhcnROb2RlT3V0Z29pbmcgPSB0aGlzLnNlbENvbm5lY3Rvci5zdGFydE5vZGUubW9kZWwuZ2V0KFwib3V0Z29pbmdcIik7XHJcbiAgICAgICAgICAgIGluZGV4ID0genJVdGlsLmluZGV4T2Yoc3RhcnROb2RlT3V0Z29pbmcsIHRoaXMuc2VsQ29ubmVjdG9yLnJlc291cmNlSWQpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZU91dGdvaW5nLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rvck1hcCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0VHdvTm9kZUlkKHRoaXMuc2VsQ29ubmVjdG9yLnN0YXJ0Tm9kZSwgdGhpcy5zZWxDb25uZWN0b3IuZW5kTm9kZSwgdGhpcy5zZWxDb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvck1hcC5yZW1vdmVJdGVtKGtleSwgdGhpcy5zZWxDb25uZWN0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy8yLuS7jl96cuS4iuWIoOmZpFxyXG4gICAgICAgIF96ci5yZW1vdmUodGhpcy5zZWxDb25uZWN0b3IpO1xyXG5cclxuXHJcbiAgICAgICAgLy8zLuS7jue6v+aVsOaNruS4reWIoOmZpFxyXG4gICAgICAgIHZhciBpbmRleCA9IHpyVXRpbC5pbmRleE9mKHRoaXMuY29ubmVjdG9ycywgdGhpcy5zZWxDb25uZWN0b3IpO1xyXG4gICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZWxDb25uZWN0b3IgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6YeN5paw55S757q/XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGNvbm5lY3RvciAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGZvcmNlXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZWZyZXNoQ29ubmVjdG9yID0gZnVuY3Rpb24gKGNvbm5lY3RvciwgZm9yY2UpIHtcclxuICAgICAgICAvLyDlj6rmnInpnIDopoHlvLrliLbliLfmlrAgIOaIluiAhSDov57nur/kuLrnqbrvvIg8Minml7Yg5omN6L+b6KGM6YeN5paw6K6h566X6YeN57uYXHJcbiAgICAgICAgaWYgKGZvcmNlIHx8ICghY29ubmVjdG9yLnR1cm5pbmdQb2ludHMpIHx8IChjb25uZWN0b3IudHVybmluZ1BvaW50cy5sZW5ndGggPCAyKSkge1xyXG4gICAgICAgICAgICBpZiAoY29ubmVjdG9yLm1vZGVsICYmIGNvbm5lY3Rvci5tb2RlbC5nZXQoXCJzdHlsZS5saW5lVHlwZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPSBjb25uZWN0b3IubW9kZWwuZ2V0KFwic3R5bGUubGluZVR5cGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGFyclN0YXJ0RW5kUG9pbnQgPSB0aGlzLmdldFN0YXJ0RW5kUG9pbnQoY29ubmVjdG9yKTtcclxuICAgICAgICAgICAgdmFyIGVzY2FwZURpc3RhbmNlID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGNvbm5lY3Rvci5vcHRpb25zLnBvc2l0aW9uICYmIGNvbm5lY3Rvci5vcHRpb25zLnBvc2l0aW9uLmVzY2FwZURpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBlc2NhcGVEaXN0YW5jZSA9IGNvbm5lY3Rvci5vcHRpb25zLnBvc2l0aW9uLmVzY2FwZURpc3RhbmNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzb2x1dGlvbnMgPSB0aGlzLmNvbm5lY3RvcjJQb2ludHMoY29ubmVjdG9yLm9wdGlvbnMuc3R5bGUubGluZVR5cGUsIGFyclN0YXJ0RW5kUG9pbnRbMF0sXHJcbiAgICAgICAgICAgICAgICBhcnJTdGFydEVuZFBvaW50WzFdLFxyXG4gICAgICAgICAgICAgICAgYXJyU3RhcnRFbmRQb2ludFsyXSwgYXJyU3RhcnRFbmRQb2ludFszXSwgZXNjYXBlRGlzdGFuY2UpOyAvLyBUWVBFX1NUUkFJR0hUIFRZUEVfSkFHR0VEXHJcblxyXG4gICAgICAgICAgICBjb25uZWN0b3IucmVmcmVzaChzb2x1dGlvbnNbMF1bMl0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29ubmVjdG9yLmNsZWFySGFuZGxlcygpOyAvL+a4heepumhhbmRsZVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0U3RhcnRFbmRQb2ludCA9IGZ1bmN0aW9uIChjb25uZWN0b3IpIHtcclxuICAgICAgICB2YXIgc3RhcnROb2RlID0gY29ubmVjdG9yLnN0YXJ0Tm9kZTtcclxuICAgICAgICB2YXIgZW5kTm9kZSA9IGNvbm5lY3Rvci5lbmROb2RlO1xyXG4gICAgICAgIHZhciBpc05vdEluU2FtZUdyb3VwID0gdHJ1ZTtcclxuICAgICAgICBpc05vdEluU2FtZUdyb3VwID0gc3RhcnROb2RlLnBhcmVudCAhPT0gZW5kTm9kZS5wYXJlbnQ7XHJcblxyXG4gICAgICAgIHZhciBzUmVjdCA9IHN0YXJ0Tm9kZS5nZXRSZWN0ID8gc3RhcnROb2RlLmdldFJlY3QoKS5ib3VuZGluZ1JlY3QgOiBVdGlsLmdldFJlY3Qoc3RhcnROb2RlLCBpc05vdEluU2FtZUdyb3VwKS5ib3VuZGluZ1JlY3Q7XHJcbiAgICAgICAgdmFyIHNCb3VuZHMgPSBbTnVtYmVyKHNSZWN0LngpLCBOdW1iZXIoc1JlY3QueSksIE51bWJlcihzUmVjdC54KSArIE51bWJlcihzUmVjdC53aWR0aCksIE51bWJlcihcclxuICAgICAgICAgICAgc1JlY3QueSkgKyBOdW1iZXIoc1JlY3QuaGVpZ2h0KV07XHJcblxyXG4gICAgICAgIHZhciBlUmVjdCA9IGVuZE5vZGUuZ2V0UmVjdCA/IGVuZE5vZGUuZ2V0UmVjdCgpLmJvdW5kaW5nUmVjdCA6IFV0aWwuZ2V0UmVjdChlbmROb2RlLCBpc05vdEluU2FtZUdyb3VwKS5ib3VuZGluZ1JlY3Q7XHJcbiAgICAgICAgdmFyIGVCb3VuZHMgPSBbTnVtYmVyKGVSZWN0LngpLCBOdW1iZXIoZVJlY3QueSksIE51bWJlcihlUmVjdC54KSArIE51bWJlcihlUmVjdC53aWR0aCksIE51bWJlcihcclxuICAgICAgICAgICAgZVJlY3QueSkgKyBOdW1iZXIoZVJlY3QuaGVpZ2h0KV07XHJcblxyXG5cclxuICAgICAgICB2YXIgc0Nvbm5lY3RvclBvaW50ID0gVXRpbC5nZXRDb25uZWN0b3JQb2ludHMoc1JlY3QsIHN0YXJ0Tm9kZSk7XHJcbiAgICAgICAgdmFyIGVDb25uZWN0b3JQb2ludCA9IFV0aWwuZ2V0Q29ubmVjdG9yUG9pbnRzKGVSZWN0LCBlbmROb2RlKTtcclxuXHJcbiAgICAgICAgLy/liKTmlq3lpoLmnpzmsqHmnInmjIflrprkvY3nva7nmoTor50sIOWIpOaWreW8gOWni+iKgueCueWcqOe7k+adn+e7k+aenOW3pui+ueWImemHh+eUqCByaWdodC1sZWZ0IOWQpuWImemHh+eUqGxlZnQtcmlnaHRcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBjb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbjtcclxuICAgICAgICBpZiAocG9zaXRpb24uZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3NBcnIgPSBwb3NpdGlvbi5kaXJlY3Rpb24uc3BsaXQoJywnKTtcclxuICAgICAgICAgICAgcG9zaXRpb24uc3RhcnRQb3MgPSBwb3NBcnJbMF07XHJcbiAgICAgICAgICAgIHBvc2l0aW9uLmVuZFBvcyA9IHBvc0FyclsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFwb3NpdGlvbi5zdGFydFBvcyB8fCAhcG9zaXRpb24uZW5kUG9zKSB7XHJcbiAgICAgICAgICAgIGlmIChzUmVjdC54IDwgZVJlY3QueCkge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24uc3RhcnRQb3MgPSBcInJpZ2h0XCI7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5lbmRQb3MgPSBcImxlZnRcIjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnN0YXJ0UG9zID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5lbmRQb3MgPSBcInJpZ2h0XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0YXJ0UG9pbnQgPSB0aGlzLmNhbGNQb2ludEV4cHJlc3Npb24ocG9zaXRpb24uc3RhcnRQb3MsIHNDb25uZWN0b3JQb2ludCk7XHJcbiAgICAgICAgdmFyIGVuZFBvaW50ID0gdGhpcy5jYWxjUG9pbnRFeHByZXNzaW9uKHBvc2l0aW9uLmVuZFBvcywgZUNvbm5lY3RvclBvaW50KTtcclxuICAgICAgICBzdGFydFBvaW50LmFkZChuZXcgUG9pbnQocG9zaXRpb24uc3RhcnRPZmZzZXRbMF0sIHBvc2l0aW9uLnN0YXJ0T2Zmc2V0WzFdKSk7XHJcbiAgICAgICAgZW5kUG9pbnQuYWRkKG5ldyBQb2ludChwb3NpdGlvbi5lbmRPZmZzZXRbMF0sIHBvc2l0aW9uLmVuZE9mZnNldFsxXSkpO1xyXG4gICAgICAgIHJldHVybiBbc3RhcnRQb2ludCwgZW5kUG9pbnQsIHNCb3VuZHMsIGVCb3VuZHNdO1xyXG4gICAgfVxyXG5cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jYWxjUG9pbnRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHBvcywgcG9pbnQpIHtcclxuICAgICAgICB2YXIgdmFyaWFibGUgPSB7XHJcbiAgICAgICAgICAgIHRvcDogcG9pbnQudG9wLngsXHJcbiAgICAgICAgICAgIGxlZnQ6IHBvaW50LmxlZnQueSxcclxuICAgICAgICAgICAgcmlnaHQ6IHBvaW50LnJpZ2h0LnksXHJcbiAgICAgICAgICAgIGJvdHRvbTogcG9pbnQuYm90dG9tLngsXHJcbiAgICAgICAgICAgIGNlbnRlcjogcG9pbnQuY2VudGVyLnhcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IFwiPCUgcHJpbnQoXCIgKyBwb3MgKyBcIikgJT5cIjtcclxuICAgICAgICB2YXIgdmFsID0gcGFyc2VJbnQoVXRpbC50ZW1wbGF0ZShleHByZXNzaW9uKSh2YXJpYWJsZSkpO1xyXG4gICAgICAgIGlmIChwb3MuaW5kZXhPZihcInRvcFwiKSAhPSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHZhbCwgcG9pbnQudG9wLnkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocG9zLmluZGV4T2YoXCJsZWZ0XCIpICE9IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQocG9pbnQubGVmdC54LCB2YWwpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocG9zLmluZGV4T2YoXCJyaWdodFwiKSAhPSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHBvaW50LnJpZ2h0LngsIHZhbCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwb3MuaW5kZXhPZihcImJvdHRvbVwiKSAhPSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHZhbCwgcG9pbnQuYm90dG9tLnkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocG9zLmluZGV4T2YoXCJjZW50ZXJcIikgIT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh2YWwsIHBvaW50LmJvdHRvbS55KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwb3Plj4LmlbDplJnor69cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu65oiW5L+u5pS55Li05pe257q/XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHN0YXJ0Tm9kZSAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHJFbmRQb2ludCAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGxpbmVUeXBlICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHN0YXJ0UG9zICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5tYW5hZ2VUZW1wQ29ubmVjdG9yID0gZnVuY3Rpb24gKHN0YXJ0Tm9kZSwgckVuZFBvaW50LCBsaW5lVHlwZSwgc3RhcnRQb3MsIGVuZFBvcywgZW5kTm9kZSkge1xyXG4gICAgICAgIHZhciBlUmVjdCA9IG51bGw7XHJcbiAgICAgICAgdmFyIGVCb3VuZHMgPSBudWxsO1xyXG4gICAgICAgIHZhciBzUmVjdCA9IHN0YXJ0Tm9kZS5nZXRSZWN0ID8gc3RhcnROb2RlLmdldFJlY3QoKS5ib3VuZGluZ1JlY3QgOiBVdGlsLmdldFJlY3Qoc3RhcnROb2RlLCB0cnVlKS5ib3VuZGluZ1JlY3Q7XHJcbiAgICAgICAgdmFyIHNCb3VuZHMgPSBbTnVtYmVyKHNSZWN0LngpLCBOdW1iZXIoc1JlY3QueSksIE51bWJlcihzUmVjdC54KSArIE51bWJlcihzUmVjdC53aWR0aCksIE51bWJlcihcclxuICAgICAgICAgICAgc1JlY3QueSkgKyBOdW1iZXIoc1JlY3QuaGVpZ2h0KV07XHJcblxyXG4gICAgICAgIHZhciBzQ29ubmVjdG9yUG9pbnQgPSBVdGlsLmdldENvbm5lY3RvclBvaW50cyhzUmVjdCwgc3RhcnROb2RlKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLnRlbXBDb25uZWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy50ZW1wQ29ubmVjdG9yID0gbmV3IENvbm5lY3Rvcih7XHJcbiAgICAgICAgICAgICAgICBpc0VkaXQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lVHlwZTogbGluZVR5cGVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY29ubmVjdG9yID0gdGhpcy50ZW1wQ29ubmVjdG9yO1xyXG4gICAgICAgIC8v5Yik5pat5aaC5p6c5rKh5pyJ5oyH5a6a5L2N572u55qE6K+dLCDliKTmlq3lvIDlp4voioLngrnlnKjnu5PmnZ/nu5Pmnpzlt6bovrnliJnph4fnlKggcmlnaHQtbGVmdCDlkKbliJnph4fnlKhsZWZ0LXJpZ2h0XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gY29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb247XHJcbiAgICAgICAgcG9zaXRpb24uc3RhcnRQb3MgPSBzdGFydFBvcyA/IHN0YXJ0UG9zIDogKHNSZWN0LnggPCByRW5kUG9pbnQueCA/IFwicmlnaHRcIiA6IFwibGVmdFwiKTtcclxuICAgICAgICBwb3NpdGlvbi5lbmRQb3MgPSBlbmRQb3MgPyBlbmRQb3MgOiAoc1JlY3QueCA8IHJFbmRQb2ludC54ID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpO1xyXG5cclxuICAgICAgICBjb25uZWN0b3Iub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9IGxpbmVUeXBlO1xyXG4gICAgICAgIGlmIChlbmROb2RlKSB7XHJcbiAgICAgICAgICAgIGVSZWN0ID0gZW5kTm9kZS5nZXRSZWN0ID8gZW5kTm9kZS5nZXRSZWN0KCkuYm91bmRpbmdSZWN0IDogVXRpbC5nZXRSZWN0KGVuZE5vZGUsIHRydWUpLmJvdW5kaW5nUmVjdDtcclxuICAgICAgICAgICAgZUJvdW5kcyA9IFtOdW1iZXIoZVJlY3QueCksIE51bWJlcihlUmVjdC55KSwgTnVtYmVyKGVSZWN0LngpICsgTnVtYmVyKGVSZWN0LndpZHRoKSwgTnVtYmVyKFxyXG4gICAgICAgICAgICAgICAgZVJlY3QueSkgKyBOdW1iZXIoZVJlY3QuaGVpZ2h0KV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzb2x1dGlvbnMgPSB0aGlzLmNvbm5lY3RvcjJQb2ludHMobGluZVR5cGUsIHNDb25uZWN0b3JQb2ludFtwb3NpdGlvbi5zdGFydFBvc10sIHJFbmRQb2ludCxcclxuICAgICAgICAgICAgc0JvdW5kcywgZUJvdW5kcyk7IC8vIFRZUEVfU1RSQUlHSFQgVFlQRV9KQUdHRURcclxuXHJcbiAgICAgICAgY29ubmVjdG9yLnJlZnJlc2goc29sdXRpb25zWzBdWzJdKTtcclxuICAgICAgICByZXR1cm4gY29ubmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu65oiW5L+u5pS55Li05pe25Y+N6L2s57q/XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHN0YXJ0UG9pbnQgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZW5kTm9kZSAgICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBsaW5lVHlwZSAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGVuZFBvcyAgICAgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUubWFuYWdlUmV2ZXJzZVRlbXBDb25uZWN0b3IgPSBmdW5jdGlvbiAoc3RhcnRQb2ludCwgZW5kTm9kZSwgbGluZVR5cGUsIGVuZFBvcywgc3RhcnRQb3MsIHN0YXJ0Tm9kZSkge1xyXG4gICAgICAgIHZhciBzUmVjdCA9IG51bGw7XHJcbiAgICAgICAgdmFyIHNCb3VuZHMgPSBudWxsO1xyXG4gICAgICAgIHZhciBlUmVjdCA9IGVuZE5vZGUuZ2V0UmVjdCA/IGVuZE5vZGUuZ2V0UmVjdCgpLmJvdW5kaW5nUmVjdCA6IFV0aWwuZ2V0UmVjdChlbmROb2RlLCB0cnVlKS5ib3VuZGluZ1JlY3Q7XHJcbiAgICAgICAgdmFyIGVCb3VuZHMgPSBbTnVtYmVyKGVSZWN0LngpLCBOdW1iZXIoZVJlY3QueSksIE51bWJlcihlUmVjdC54KSArIE51bWJlcihlUmVjdC53aWR0aCksIE51bWJlcihlUmVjdC55KSArIE51bWJlcihlUmVjdC5oZWlnaHQpXTtcclxuICAgICAgICB2YXIgZUNvbm5lY3RvclBvaW50ID0gVXRpbC5nZXRDb25uZWN0b3JQb2ludHMoZVJlY3QsIGVuZE5vZGUpO1xyXG4gICAgICAgIGlmICghdGhpcy50ZW1wQ29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGVtcENvbm5lY3RvciA9IG5ldyBDb25uZWN0b3Ioe1xyXG4gICAgICAgICAgICAgICAgaXNFZGl0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZVR5cGU6IGxpbmVUeXBlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29ubmVjdG9yID0gdGhpcy50ZW1wQ29ubmVjdG9yO1xyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGNvbm5lY3Rvci5vcHRpb25zLnBvc2l0aW9uO1xyXG4gICAgICAgIHBvc2l0aW9uLmVuZFBvcyA9IGVuZFBvcyA/IGVuZFBvcyA6IChlUmVjdC54IDwgc3RhcnRQb2ludC54ID8gXCJyaWdodFwiIDogXCJsZWZ0XCIpO1xyXG4gICAgICAgIHBvc2l0aW9uLnN0YXJ0UG9zID0gc3RhcnRQb3MgPyBzdGFydFBvcyA6IChlUmVjdC54IDwgc3RhcnRQb2ludC54ID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpO1xyXG5cclxuICAgICAgICBjb25uZWN0b3Iub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9IGxpbmVUeXBlO1xyXG4gICAgICAgIGlmIChzdGFydE5vZGUpIHtcclxuICAgICAgICAgICAgc1JlY3QgPSBzdGFydE5vZGUuZ2V0UmVjdCA/IHN0YXJ0Tm9kZS5nZXRSZWN0KCkuYm91bmRpbmdSZWN0IDogVXRpbC5nZXRSZWN0KHN0YXJ0Tm9kZSwgdHJ1ZSkuYm91bmRpbmdSZWN0O1xyXG4gICAgICAgICAgICBzQm91bmRzID0gW051bWJlcihzUmVjdC54KSwgTnVtYmVyKHNSZWN0LnkpLCBOdW1iZXIoc1JlY3QueCkgKyBOdW1iZXIoc1JlY3Qud2lkdGgpLCBOdW1iZXIoXHJcbiAgICAgICAgICAgIHNSZWN0LnkpICsgTnVtYmVyKHNSZWN0LmhlaWdodCldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc29sdXRpb25zID0gdGhpcy5jb25uZWN0b3IyUG9pbnRzKGxpbmVUeXBlLCBzdGFydFBvaW50LCBlQ29ubmVjdG9yUG9pbnRbcG9zaXRpb24uZW5kUG9zXSxcclxuICAgICAgICAgICAgc0JvdW5kcywgZUJvdW5kcyk7IC8vIFRZUEVfU1RSQUlHSFQgVFlQRV9KQUdHRURcclxuXHJcbiAgICAgICAgY29ubmVjdG9yLnJlZnJlc2goc29sdXRpb25zWzBdWzJdKTtcclxuICAgICAgICByZXR1cm4gY29ubmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yig6Zmk5Li05pe257q/XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHpyICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlbW92ZVRlbXBDb25uZWN0b3IgPSBmdW5jdGlvbiAoenIpIHtcclxuICAgICAgICBpZiAodGhpcy50ZW1wQ29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHpyLnJlbW92ZSh0aGlzLnRlbXBDb25uZWN0b3IpO1xyXG4gICAgICAgICAgICB0aGlzLnRlbXBDb25uZWN0b3IgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnrpflh7og5Lik5Liq6IqC54K5IOaMh+WumuS4pOS4queCueWmguS9leiBlOe6v1xyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSB0eXBlICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gc3RhcnRQb2ludCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGVuZFBvaW50ICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBzQm91bmRzICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZUJvdW5kcyAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdG9yMlBvaW50cyA9IGZ1bmN0aW9uICh0eXBlLCBzdGFydFBvaW50LCBlbmRQb2ludCwgc0JvdW5kcywgZUJvdW5kcyxcclxuICAgICAgICBlc2NhcGVEaXN0YW5jZSkge1xyXG4gICAgICAgIHZhciBmaWd1cmVFc2NhcGVEaXN0YW5jZSA9IFszMCwgMzBdO1xyXG4gICAgICAgIGlmIChlc2NhcGVEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KGVzY2FwZURpc3RhbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgZmlndXJlRXNjYXBlRGlzdGFuY2UgPSBbZXNjYXBlRGlzdGFuY2UsIGVzY2FwZURpc3RhbmNlXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZpZ3VyZUVzY2FwZURpc3RhbmNlID0gZXNjYXBlRGlzdGFuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIExvZy5ncm91cChcImNvbm5lY3Rpb25NYW5hZ2VyOiBjb25uZWN0b3IyUG9pbnRzXCIpO1xyXG5cclxuXHJcbiAgICAgICAgTG9nLmluZm8oXCJDb25uZWN0aW9uTWFuYWdlcjogY29ubmVjdG9yMlBvaW50cyAoXCIgKyB0eXBlICsgXCIsIFwiICsgc3RhcnRQb2ludCArIFwiLCBcIiArIGVuZFBvaW50ICtcclxuICAgICAgICAgICAgXCIsIFwiICsgc0JvdW5kcyArIFwiLCBcIiArIGVCb3VuZHMgKyAnKScpO1xyXG4gICAgICAgIHZhciBzb2x1dGlvbnMgPSBbXTtcclxuXHJcblxyXG5cclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBDb25uZWN0b3IuVFlQRV9DSEFJTjpcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29ubmVjdG9yLlRZUEVfU1RSQUlHSFQ6IC8v55u057q/XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gW3N0YXJ0UG9pbnQuY2xvbmUoKSwgZW5kUG9pbnQuY2xvbmUoKV07XHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3N0cmFpZ2h0JywgJ3N0cmFpZ2h0JywgcG9pbnRzXSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29ubmVjdG9yLlRZUEVfQ1VSVkU6IC8v5puy57q/XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbm5lY3Rvci5UWVBFX0pBR0dFRDogLy/mipjnur9cclxuICAgICAgICAgICAgICAgIHZhciBzdGFydEV4aXRQb2ludCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kRXhpdFBvaW50ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2ZpbmQgc3RhcnQgZXhpdCBwb2ludCAg5a+75om+5byA5aeL5Ye65Y+jXHJcbiAgICAgICAgICAgICAgICBpZiAoc0JvdW5kcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvdGVudGlhbEV4aXRzID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbEV4aXRzLnB1c2gobmV3IFBvaW50KHN0YXJ0UG9pbnQueCwgc0JvdW5kc1sxXSAtIGZpZ3VyZUVzY2FwZURpc3RhbmNlWzBdKSk7IC8vbm9ydGgg5YyXXHJcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsRXhpdHMucHVzaChuZXcgUG9pbnQoc0JvdW5kc1syXSArIGZpZ3VyZUVzY2FwZURpc3RhbmNlWzBdLCBzdGFydFBvaW50LnkpKTsgLy9lYXN0ICDkuJxcclxuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxFeGl0cy5wdXNoKG5ldyBQb2ludChzdGFydFBvaW50LngsIHNCb3VuZHNbM10gKyBmaWd1cmVFc2NhcGVEaXN0YW5jZVswXSkpOyAvL3NvdXRoICDljZdcclxuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxFeGl0cy5wdXNoKG5ldyBQb2ludChzQm91bmRzWzBdIC0gZmlndXJlRXNjYXBlRGlzdGFuY2VbMF0sIHN0YXJ0UG9pbnQueSkpOyAvL3dlc3QgIOilv1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3BpY2sgY2xvc2VzdCBleGl0IHBvaW50ICDlr7vmib7kuI4gc3RhcnRQb2ludCDmnIDpnaDov5HnmoTlh7rlj6PngrlcclxuICAgICAgICAgICAgICAgICAgICBzdGFydEV4aXRQb2ludCA9IHBvdGVudGlhbEV4aXRzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG90ZW50aWFsRXhpdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFV0aWwuZGlzdGFuY2Uoc3RhcnRQb2ludCwgcG90ZW50aWFsRXhpdHNbaV0pIDwgVXRpbC5kaXN0YW5jZShzdGFydFBvaW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RXhpdFBvaW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRFeGl0UG9pbnQgPSBwb3RlbnRpYWxFeGl0c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9maW5kIGVuZCBleGl0IHBvaW50ICDlr7vmib7nu5PmnZ/lh7rlj6NcclxuICAgICAgICAgICAgICAgIGlmIChlQm91bmRzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG90ZW50aWFsRXhpdHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsRXhpdHMucHVzaChuZXcgUG9pbnQoZW5kUG9pbnQueCwgZUJvdW5kc1sxXSAtIGZpZ3VyZUVzY2FwZURpc3RhbmNlWzFdKSk7IC8vbm9ydGhcclxuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxFeGl0cy5wdXNoKG5ldyBQb2ludChlQm91bmRzWzJdICsgZmlndXJlRXNjYXBlRGlzdGFuY2VbMV0sIGVuZFBvaW50LnkpKTsgLy9lYXN0XHJcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsRXhpdHMucHVzaChuZXcgUG9pbnQoZW5kUG9pbnQueCwgZUJvdW5kc1szXSArIGZpZ3VyZUVzY2FwZURpc3RhbmNlWzFdKSk7IC8vc291dGhcclxuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxFeGl0cy5wdXNoKG5ldyBQb2ludChlQm91bmRzWzBdIC0gZmlndXJlRXNjYXBlRGlzdGFuY2VbMV0sIGVuZFBvaW50LnkpKTsgLy93ZXN0XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcGljayBjbG9zZXN0IGV4aXQgcG9pbnQgIOWvu+aJvuS4jiBlbmRQb2ludCDmnIDpnaDov5HnmoTlh7rlj6PngrlcclxuICAgICAgICAgICAgICAgICAgICBlbmRFeGl0UG9pbnQgPSBwb3RlbnRpYWxFeGl0c1swXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvdGVudGlhbEV4aXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChVdGlsLmRpc3RhbmNlKGVuZFBvaW50LCBwb3RlbnRpYWxFeGl0c1tpXSkgPCBVdGlsLmRpc3RhbmNlKGVuZFBvaW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZEV4aXRQb2ludCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZEV4aXRQb2ludCA9IHBvdGVudGlhbEV4aXRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vQmFzaWMgc29sdXRpb24g5pyA5Z+65pys55qE6Kej5Yaz5pa55qGIICAg5Li65YW25LuW6Kej5Yaz5pa55qGI5YGa5YeG5aSHXHJcbiAgICAgICAgICAgICAgICB2YXIgcyA9IFtzdGFydFBvaW50XTtcclxuICAgICAgICAgICAgICAgIHZhciBnYXBJbmRleCA9IDA7IC8vdGhlIGluZGV4IG9mIHRoZSBnYXAgKHdoZXJlIGRvIHdlIG5lZWQgdG8gaW5zZXJ0IG5ldyBwb2ludHMpIERPIE5PVCBDSEFOR0UgSVRcclxuICAgICAgICAgICAgICAgIGlmIChzdGFydEV4aXRQb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHMucHVzaChzdGFydEV4aXRQb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FwSW5kZXggPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGVuZEV4aXRQb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHMucHVzaChlbmRFeGl0UG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcy5wdXNoKGVuZFBvaW50KTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vU08gLSBubyBhZGRpdGlvbmFsIHBvaW50cyAgICAgUzAg6Kej5Yaz5pa55qGIIOS4jea3u+WKoOS7u+S9leeCuSAg5Z+65pys5LiN5Lya6KKr6YeH55SoXHJcbiAgICAgICAgICAgICAgICB2YXIgczAgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMCcsICdzMCcsIHMwXSk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL1MxICAgUzEg6Kej5Yaz5pa55qGIICDlj6rmnInkuIDkuKrmipjngrlcclxuICAgICAgICAgICAgICAgIHZhciBzMSA9IFBvaW50LmNsb25lQXJyYXkocyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9maXJzdCB2YXJpYW50ICAg56ys5LiA5Liq5Y+Y5L2TIHMxIHMxXzHmlrnmoYggIOaKmOe6v+eCueWcqCBzdGFydEV4aXRQb2ludOeahFgg5LiOIGVuZEV4aXRQb2ludOeahCBZ5L2N572uXHJcbiAgICAgICAgICAgICAgICB2YXIgczFfMSA9IFBvaW50LmNsb25lQXJyYXkoczEpO1xyXG4gICAgICAgICAgICAgICAgczFfMS5zcGxpY2UoZ2FwSW5kZXggKyAxLCAwLCBuZXcgUG9pbnQoczFfMVtnYXBJbmRleF0ueCwgczFfMVtnYXBJbmRleCArIDFdLnkpKTtcclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnczEnLCAnczFfMScsIHMxXzFdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL3NlY29uZCB2YXJpYW50ICDnrKzkuozlj5jkvZMgczEgczEtMuaWueahiCAg5oqY57q/54K55ZyoIGVuZEV4aXRQb2ludOeahFgg5LiOICBzdGFydEV4aXRQb2ludOeahFnkvY3nva5cclxuICAgICAgICAgICAgICAgIHZhciBzMV8yID0gUG9pbnQuY2xvbmVBcnJheShzMSk7XHJcbiAgICAgICAgICAgICAgICBzMV8yLnNwbGljZShnYXBJbmRleCArIDEsIDAsIG5ldyBQb2ludChzMV8yW2dhcEluZGV4ICsgMV0ueCwgczFfMltnYXBJbmRleF0ueSkpO1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMScsICdzMV8yJywgczFfMl0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL1MyICBTMiDop6PlhrPmlrnmoYggIOa3u+WKoOS4pOS4quaKmOeCuVxyXG5cclxuICAgICAgICAgICAgICAgIC8vVmFyaWFudCBJICAgczJfMeaWueahiFxyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzEgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzFfMSA9IG5ldyBQb2ludCgoczJfMVtnYXBJbmRleF0ueCArIHMyXzFbZ2FwSW5kZXggKyAxXS54KSAvIDIsIHMyXzFbZ2FwSW5kZXhdLnkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzFfMiA9IG5ldyBQb2ludCgoczJfMVtnYXBJbmRleF0ueCArIHMyXzFbZ2FwSW5kZXggKyAxXS54KSAvIDIsIHMyXzFbZ2FwSW5kZXggKyAxXS55KTtcclxuICAgICAgICAgICAgICAgIHMyXzEuc3BsaWNlKGdhcEluZGV4ICsgMSwgMCwgczJfMV8xLCBzMl8xXzIpO1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMicsICdzMl8xJywgczJfMV0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL1ZhcmlhbnQgSUkgIHMyXzHmlrnmoYggIDHmipjnur/ngrkgeDogc3RhcnRFeGl0UG9pbnTnmoRYIOS9jee9riB5OiBzdGFydEV4aXRQb2ludOeahHkrZW5kRXhpdFBvaW5055qEeS8yXHJcbiAgICAgICAgICAgICAgICAvLzHmipjnur/ngrkgeDplbmRFeGl0UG9pbnTnmoR4ICB5OnN0YXJ0RXhpdFBvaW5055qEeStlbmRFeGl0UG9pbnTnmoR5LzJcclxuICAgICAgICAgICAgICAgIHZhciBzMl8yID0gUG9pbnQuY2xvbmVBcnJheShzKTtcclxuICAgICAgICAgICAgICAgIHZhciBzMl8yXzEgPSBuZXcgUG9pbnQoczJfMltnYXBJbmRleF0ueCwgKHMyXzJbZ2FwSW5kZXhdLnkgKyBzMl8yW2dhcEluZGV4ICsgMV0ueSkgLyAyKTtcclxuICAgICAgICAgICAgICAgIHZhciBzMl8yXzIgPSBuZXcgUG9pbnQoczJfMltnYXBJbmRleCArIDFdLngsIChzMl8yW2dhcEluZGV4XS55ICsgczJfMltnYXBJbmRleCArIDFdLnkpIC8gMik7XHJcbiAgICAgICAgICAgICAgICBzMl8yLnNwbGljZShnYXBJbmRleCArIDEsIDAsIHMyXzJfMSwgczJfMl8yKTtcclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnczInLCAnczJfMicsIHMyXzJdKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9WYXJpYW50IElJSVxyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzMgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG4gICAgICAgICAgICAgICAgLy9maW5kIHRoZSBhbW91bnQgKHN0b3JlZCBpbiBkZWx0YSkgb2YgcGl4ZWxzIHdlIG5lZWQgdG8gbW92ZSByaWdodCBzbyBubyBpbnRlcnNlY3Rpb24gd2l0aCBhIGZpZ3VyZSB3aWxsIGJlIHByZXNlbnRcclxuICAgICAgICAgICAgICAgIC8vIVNlZTogIC9kb2N1bWVudHMvc3BlY3MvY29ubmVjdGVkX2ZpZ3VyZXNfZGVsdGFzLmpwZyBmaWxlXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGVhc3RFeGl0cyA9IFtzMl8zW2dhcEluZGV4XS54ICsgMjAsIHMyXzNbZ2FwSW5kZXggKyAxXS54ICsgMjBdOyAvL2FkZCBwb2ludHMgWCBjb29yZGluYXRlcyB0byBiZSBhYmxlIHRvIGdlbmVyYXRlIFZhcmlhbnQgSUlJIGV2ZW4gaW4gdGhlIGFic2VuY2Ugb2YgZmlndXJlcyA6cFxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWFzdEV4aXRzLnB1c2goc0JvdW5kc1syXSArIDIwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZUJvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVhc3RFeGl0cy5wdXNoKGVCb3VuZHNbMl0gKyAyMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGVhc3RFeGl0ID0gVXRpbC5tYXgoZWFzdEV4aXRzKTtcclxuICAgICAgICAgICAgICAgIHZhciBzMl8zXzEgPSBuZXcgUG9pbnQoZWFzdEV4aXQsIHMyXzNbZ2FwSW5kZXhdLnkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzNfMiA9IG5ldyBQb2ludChlYXN0RXhpdCwgczJfM1tnYXBJbmRleCArIDFdLnkpO1xyXG4gICAgICAgICAgICAgICAgczJfMy5zcGxpY2UoZ2FwSW5kZXggKyAxLCAwLCBzMl8zXzEsIHMyXzNfMik7XHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MyJywgJ3MyXzMnLCBzMl8zXSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vVmFyaWFudCBJViAgczJfNOaWueahiFxyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzQgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG4gICAgICAgICAgICAgICAgLy9maW5kIHRoZSBhbW91bnQgKHN0b3JlZCBpbiBkZWx0YSkgb2YgcGl4ZWxzIHdlIG5lZWQgdG8gbW92ZSB1cCBzbyBubyBpbnRlcnNlY3Rpb24gd2l0aCBhIGZpZ3VyZSB3aWxsIGJlIHByZXNlbnRcclxuICAgICAgICAgICAgICAgIC8vIVNlZTogIC9kb2N1bWVudHMvc3BlY3MvY29ubmVjdGVkX2ZpZ3VyZXNfZGVsdGFzLmpwZyBmaWxlXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG5vcnRoRXhpdHMgPSBbczJfNFtnYXBJbmRleF0ueSAtIDIwLCBzMl80W2dhcEluZGV4ICsgMV0ueSAtIDIwXTsgLy9hZGQgcG9pbnRzIHkgY29vcmRpbmF0ZXMgdG8gYmUgYWJsZSB0byBnZW5lcmF0ZSBWYXJpYW50IElJSSBldmVuIGluIHRoZSBhYnNlbmNlIG9mIGZpZ3VyZXMgOnBcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc0JvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vcnRoRXhpdHMucHVzaChzQm91bmRzWzFdIC0gMjApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ydGhFeGl0cy5wdXNoKGVCb3VuZHNbMV0gLSAyMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG5vcnRoRXhpdCA9IFV0aWwubWluKG5vcnRoRXhpdHMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzRfMSA9IG5ldyBQb2ludChzMl80W2dhcEluZGV4XS54LCBub3J0aEV4aXQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzRfMiA9IG5ldyBQb2ludChzMl80W2dhcEluZGV4ICsgMV0ueCwgbm9ydGhFeGl0KTtcclxuICAgICAgICAgICAgICAgIHMyXzQuc3BsaWNlKGdhcEluZGV4ICsgMSwgMCwgczJfNF8xLCBzMl80XzIpO1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMicsICdzMl80JywgczJfNF0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL1ZhcmlhbnQgVlxyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzUgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG4gICAgICAgICAgICAgICAgLy9maW5kIHRoZSBhbW91bnQgKHN0b3JlZCBpbiBkZWx0YSkgb2YgcGl4ZWxzIHdlIG5lZWQgdG8gbW92ZSBsZWZ0IHNvIG5vIGludGVyc2VjdGlvbiB3aXRoIGEgZmlndXJlIHdpbGwgYmUgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgLy8hU2VlOiAgL2RvY3VtZW50cy9zcGVjcy9jb25uZWN0ZWRfZmlndXJlc19kZWx0YXMuanBnIGZpbGVcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgd2VzdEV4aXRzID0gW3MyXzVbZ2FwSW5kZXhdLnggLSAyMCwgczJfNVtnYXBJbmRleCArIDFdLnggLSAyMF07IC8vYWRkIHBvaW50cyB4IGNvb3JkaW5hdGVzIHRvIGJlIGFibGUgdG8gZ2VuZXJhdGUgVmFyaWFudCBJSUkgZXZlbiBpbiB0aGUgYWJzZW5jZSBvZiBmaWd1cmVzIDpwXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB3ZXN0RXhpdHMucHVzaChzQm91bmRzWzBdIC0gMjApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2VzdEV4aXRzLnB1c2goZUJvdW5kc1swXSAtIDIwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgd2VzdEV4aXQgPSBVdGlsLm1pbih3ZXN0RXhpdHMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzVfMSA9IG5ldyBQb2ludCh3ZXN0RXhpdCwgczJfNVtnYXBJbmRleF0ueSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgczJfNV8yID0gbmV3IFBvaW50KHdlc3RFeGl0LCBzMl81W2dhcEluZGV4ICsgMV0ueSk7XHJcbiAgICAgICAgICAgICAgICBzMl81LnNwbGljZShnYXBJbmRleCArIDEsIDAsIHMyXzVfMSwgczJfNV8yKTtcclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnczInLCAnczJfNScsIHMyXzVdKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9WYXJpYW50IFZJXHJcbiAgICAgICAgICAgICAgICB2YXIgczJfNiA9IFBvaW50LmNsb25lQXJyYXkocyk7XHJcbiAgICAgICAgICAgICAgICAvL2ZpbmQgdGhlIGFtb3VudCAoc3RvcmVkIGluIGRlbHRhKSBvZiBwaXhlbHMgd2UgbmVlZCB0byBtb3ZlIGRvd24gc28gbm8gaW50ZXJzZWN0aW9uIHdpdGggYSBmaWd1cmUgd2lsbCBiZSBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICAvLyFTZWU6ICAvZG9jdW1lbnRzL3NwZWNzL2Nvbm5lY3RlZF9maWd1cmVzX2RlbHRhcy5qcGcgZmlsZVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBzb3V0aEV4aXRzID0gW3MyXzZbZ2FwSW5kZXhdLnkgKyAyMCwgczJfNltnYXBJbmRleCArIDFdLnkgKyAyMF07IC8vYWRkIHBvaW50cyB5IGNvb3JkaW5hdGVzIHRvIGJlIGFibGUgdG8gZ2VuZXJhdGUgVmFyaWFudCBJSUkgZXZlbiBpbiB0aGUgYWJzZW5jZSBvZiBmaWd1cmVzIDpwXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzb3V0aEV4aXRzLnB1c2goc0JvdW5kc1szXSArIDIwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZUJvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNvdXRoRXhpdHMucHVzaChlQm91bmRzWzNdICsgMjApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBzb3V0aEV4aXQgPSBVdGlsLm1heChzb3V0aEV4aXRzKTtcclxuICAgICAgICAgICAgICAgIHZhciBzMl82XzEgPSBuZXcgUG9pbnQoczJfNltnYXBJbmRleF0ueCwgc291dGhFeGl0KTtcclxuICAgICAgICAgICAgICAgIHZhciBzMl82XzIgPSBuZXcgUG9pbnQoczJfNltnYXBJbmRleCArIDFdLngsIHNvdXRoRXhpdCk7XHJcbiAgICAgICAgICAgICAgICBzMl82LnNwbGljZShnYXBJbmRleCArIDEsIDAsIHMyXzZfMSwgczJfNl8yKTtcclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnczInLCAnczJfNicsIHMyXzZdKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vRklMVEVSIHNvbHV0aW9uc1xyXG5cclxuICAgICAgICAgICAgICAgIC8qQWxnb3JpdGhtXHJcbiAgICAgICAgICAgICAgICAgKiAwLiBzb2x1dGlvbnMgYXJlIG9yZGVyZWQgZnJvbSBtaW5pbW11biBuciBvZiBwb2ludHMgdG8gbWF4aW11bSA+OilcclxuICAgICAgICAgICAgICAgICAqIDEuIHJlbW92ZSBhbGwgc29sdXRpb25zIHRoYXQgYXJlIG5vdCBvcnRob2dvbmFsIChtYWlubHkgczAgc29sdXRpb24pXHJcbiAgICAgICAgICAgICAgICAgKiAyLiByZW1vdmUgYWxsIHNvbHV0aW9ucyB0aGF0IGdvIGJhY2t3YXJkICh3ZSB3aWxsIG5vdCBuZWVkIHRoZW0gZXZlcilcclxuICAgICAgICAgICAgICAgICAqIDMuIHJlbW92ZSBhbGwgc29sdXRpb25zIHdpdGggaW50ZXJzZWN0aW9uc1xyXG4gICAgICAgICAgICAgICAgICogNC4gcGljayBmaXJzdCBjbGFzcyBvZiBzb2x1dGlvbnMgd2l0aCBzYW1lIG5yIG9mIHBvaW50cyAoZXg6IDIpXHJcbiAgICAgICAgICAgICAgICAgKiA1LiBwaWNrIHRoZSBmaXJzdCBzb2x1dGlvbiB3aXRoIDkwIGRlZ3JlZSBhbmdsZXMgKGxlc3MgdHVybmFyb3VuZHMpXHJcbiAgICAgICAgICAgICAgICAgKiAobm90IGludGVyZXN0ZXRlZCkgc29ydCBieSBsZW5ndGggOnBcclxuICAgICAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgICAgIC8vMS4gZmlsdGVyIG5vbiBvcnRvZ29uYWwgc29sdXRpb25zIOWIoOmZpOS4jeaYr+ato+S6pOebtOe6v+eahOaWueahiFxyXG4gICAgICAgICAgICAgICAgTG9nLmluZm8oXCJGaWx0ZXIgb3J0aG9nb25hbCBzb2x1dGlvbnMuIEluaXRpYWwgbnVtYmVyIG9mIHNvbHV0aW9ucyA9IFwiICsgc29sdXRpb25zLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3J0aG9nb25hbFNvbHV0aW9uID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHNvbHV0aW9ucy5sZW5ndGg7IGwrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzb2x1dGlvbiA9IHNvbHV0aW9uc1tsXVsyXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbC5vcnRob2dvbmFsUGF0aChzb2x1dGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3J0aG9nb25hbFNvbHV0aW9uLnB1c2goc29sdXRpb25zW2xdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMgPSBvcnRob2dvbmFsU29sdXRpb247XHJcbiAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIlxcblxcdE9ydGhvZ29uYWxTb2x1dGlvbnMgPSBcIiArIHNvbHV0aW9ucy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vMi4gZmlsdGVyIGJhY2t3YXJkIHNvbHV0aW9ucyAg6L+H5rukIOWAkumAgOeahOaWueahiFxyXG4gICAgICAgICAgICAgICAgLy9kbyBub3QgYWxsb3cgc3RhcnQgYW5kIGVuZCBwb2ludHMgdG8gY29pbmNpZGUgLSBpZ25vcmUgdGhlbVxyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0UG9pbnQuZXF1YWxzKGVuZFBvaW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIExvZy5pbmZvKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlN0YXJ0IGFuZCBlbmQgcG9pbnQgY29pbmNpZGUuLi5za2lwIGJhY2t3YXJkIHNvbHV0aW9uLiBJIHRoaW5rIHdlIHdpbGwganVzdCBmYWxsIG9uIHMwIDopXCJcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIkZpbHRlciBiYWNrd2FyZCBzb2x1dGlvbnMuIEluaXRpYWwgbnVtYmVyIG9mIHNvbHV0aW9ucyA9IFwiICsgc29sdXRpb25zLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvcndhcmRTb2x1dGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgc29sdXRpb25zLmxlbmd0aDsgbCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb2x1dGlvbiA9IHNvbHV0aW9uc1tsXVsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFV0aWwuZm9yd2FyZFBhdGgoc29sdXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3J3YXJkU29sdXRpb25zLnB1c2goc29sdXRpb25zW2xdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSB0ZW1wICsgXCJcXG5cXHRcIiArIHNvbHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNvbHV0aW9ucyA9IGZvcndhcmRTb2x1dGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nLmluZm8oXCJcXG5cXHQgRm9yd2FyZFNvbHV0aW9ucyA9IFwiICsgc29sdXRpb25zLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvbHV0aW9ucy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIkRpc2NhcmRlZCBzb2x1dGlvbnM6IFwiICsgdGVtcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLzMuIEZpbHRlciBub24gaW50ZXJzZWN0aW5nIHNvbHV0aW9ucyAg5Y676Zmk5rKh5pyJ5Lqk6ZuGKCnnmoTmlrnmoYhcclxuICAgICAgICAgICAgICAgIExvZy5pbmZvKFwiRmlsdGVyIG5vbiBpbnRlcnNlY3Rpbmcgc29sdXRpb25zLiBJbml0aWFsIG51bWJlciBvZiBzb2x1dGlvbnMgPSBcIiArIHNvbHV0aW9ucy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vbkludGVyc2VjdGlvblNvbHV0aW9ucyA9IFtdXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHNvbHV0aW9ucy5sZW5ndGg7IGwrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzb2x1dGlvbiA9IHNvbHV0aW9uc1tsXVsyXTtcclxuICAgICAgICAgICAgICAgICAgICAvL0xvZy5pbmZvKFwiU29sdXRpb24gaWQ9IFwiICsgc29sdXRpb25zW2xdWzFdICsgJyBuciBwb2ludHMgPSAnICsgc29sdXRpb24ubGVuZ3RoICsgXCIsIHBvaW50cyA9IFwiICsgc29sdXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnRlcnNlY3QgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlubmVyTGluZXMgPSBzb2x1dGlvbi5zbGljZSgpOyAvL2p1c3QgYSBzaGFsbG93IGNvcHlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLypJZiBhbnkgYm91bmRzIGp1c3QgdHJpbSB0aGUgc29sdXRpb24uIFNvIHdlIGF2b2lkIHRoZSBzdHJhbmdlIGNhc2Ugd2hlbiBhIGNvbm5lY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgKnN0YXJ0ZXMgZnJvbSBhIHBvaW50IG9uIGEgZmlndXJlIGFuZCBlbmRzIGluc2lkZSBvZiB0aGUgc2FtZSBmaWd1cmUsIGJ1dCBub3Qgb24gYSBjb25uZWN0aW9uIHBvaW50Ki9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZUJvdW5kcyB8fCBzQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaTBubmVyTGluZXMgPSBpbm5lckxpbmVzLnNsaWNlKDAsIGlubmVyTGluZXMubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyTGluZXMgPSBpbm5lckxpbmVzLnNsaWNlKDEsIGlubmVyTGluZXMubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vTG9nLmluZm8oXCJcXHQgZUJvdW5kcyBwcmVzZW50LGlubmVyTGluZXMgbnIuIHBvaW50cyA9IFwiICsgaW5uZXJMaW5lcy5sZW5ndGggKyBcIiwgcG9pbnRzID0gXCIgKyBpbm5lckxpbmVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9ub3cgdGVzdCBmb3IgaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0ID0gaW50ZXJzZWN0IHx8IFV0aWwucG9seWxpbmVJbnRlcnNlY3RzUmVjdGFuZ2xlKGlubmVyTGluZXMsIHNCb3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZUJvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3QgPSBpbnRlcnNlY3QgfHwgVXRpbC5wb2x5bGluZUludGVyc2VjdHNSZWN0YW5nbGUoaW5uZXJMaW5lcywgZUJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWludGVyc2VjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub25JbnRlcnNlY3Rpb25Tb2x1dGlvbnMucHVzaChzb2x1dGlvbnNbbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL0lmIGFsbCBzb2x1dGlvbnMgaW50ZXJzZWN0IHRoYW4gdGhpcyBpcyBkZXN0aW55ICA6KSBhbmQganVzdCBpZ25vcmUgdGhlIGludGVyc2VjdGlvbiBmaWx0ZXJcclxuICAgICAgICAgICAgICAgIGlmIChub25JbnRlcnNlY3Rpb25Tb2x1dGlvbnMubGVuZ3RoICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3JlYXNpZ24gdG8gc29sdXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb25zID0gbm9uSW50ZXJzZWN0aW9uU29sdXRpb25zO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIExvZy5pbmZvKFwiXFxuXFx0IG5vbkludGVyc2VjdGlvblNvbHV0aW9ucyA9IFwiICsgc29sdXRpb25zLmxlbmd0aCk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vNC4gZ2V0IGZpcnN0IGNsYXNzIG9mIHNvbHV0aW9ucyB3aXRoIHNhbWUgbnIgb2YgcG9pbnRzIOmAieaLqeS4juesrOS4gOS4quaWueahiOeCueaVsOS4gOagt+WkmueahOaWueahiO+8iOWboOS4uuesrOS4gOS4quaWueahiOeCueaVsOacgOWwke+8iVxyXG4gICAgICAgICAgICAgICAgTG9nLmluZm8oXCJHZXQgZmlyc3QgY2xhc3Mgb2Ygc29sdXRpb25zIHdpdGggc2FtZSBuciBvZiBwb2ludHNcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoc29sdXRpb25zLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nLmluZm8oXCJUaGlzIGlzIG5vdCBwb3NzaWJsZVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RTb2x1dGlvbiA9IHNvbHV0aW9uc1swXVsyXTsgLy9waWNrIGZpcnN0IHNvbHV0aW9uXHJcbiAgICAgICAgICAgICAgICB2YXIgbnJPZlBvaW50cyA9IGZpcnN0U29sdXRpb24ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNhbWVOclBvaW50c1NvbHV0aW9uID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBzb2x1dGlvbnMubGVuZ3RoOyBsKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc29sdXRpb24gPSBzb2x1dGlvbnNbbF1bMl07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvbHV0aW9uLmxlbmd0aCA9PSBuck9mUG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbWVOclBvaW50c1NvbHV0aW9uLnB1c2goc29sdXRpb25zW2xdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zID0gc2FtZU5yUG9pbnRzU29sdXRpb247XHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLyo1LiAg6K6h566X6Lev5b6E5YiG5pWwIO+8jOWPluacgOWIhuaVsOmrmOeahFxyXG4gICAgICAgICAgICAgICAgIFBpY2sgdGhlIGZpcnN0IHNvbHV0aW9uIHdpdGggOTAgZGVncmVlIGFuZ2xlcyAobGVzcyB0dXJuYXJvdW5kcylcclxuICAgICAgICAgICAgICAgICAqaW4gY2FzZSB3ZSBoYXZlIG1vcmUgdGhhbiBvbmUgc29sdXRpb24gaW4gb3VyIGNsYXNzXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIExvZy5pbmZvKFwicGljayB0aGUgZmlyc3Qgc29sdXRpb24gd2l0aCA5MCBkZWdyZWUgYW5nbGVzIChsZXNzIHR1cm5hcm91bmRzKVwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBzb2xJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHNvbHV0aW9ucy5sZW5ndGg7IGwrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzb2x1dGlvbiA9IHNvbHV0aW9uc1tsXVsyXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbC5zY29yZVBhdGgoc29sdXRpb25zW3NvbEluZGV4XVsyXSkgPCBVdGlsLnNjb3JlUGF0aChzb2x1dGlvbnNbbF1bMl0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvbEluZGV4ID0gbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMgPSBbc29sdXRpb25zW3NvbEluZGV4XV07XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9TTU9PVEhJTkcgY3VydmVcclxuICAgICAgICBpZiAodHlwZSA9PT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUpIHtcclxuICAgICAgICAgICAgdGhpcy5zbW9vdGhDdXJ2ZShzb2x1dGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL0VORCBTTU9PVEhJTkcgY3VydmVcclxuXHJcbiAgICAgICAgTG9nLmdyb3VwRW5kKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBzb2x1dGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNtb290aEN1cnZlID0gZnVuY3Rpb24gKHNvbHV0aW9ucykge1xyXG4gICAgICAgIHZhciBvcHRpb24gPSAzO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKG9wdGlvbikge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAvL2RvIG5vdGhpbmdcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAxOiAvL2FkZCBpbnRlcm1lZGlhdGUgcG9pbnRzXHJcbiAgICAgICAgICAgICAgICAvL0FkZCB0aGUgbWlkZGxlIHBvaW50IGZvciBzdGFydCBhbmQgZW5kIHNlZ21lbnQgc28gdGhhdCB3ZSBcImZvcmNlXCIgdGhlXHJcbiAgICAgICAgICAgICAgICAvL2N1cnZlIHRvIGJvdGggY29tZSBcInBlcnBlbmRpY3VsYXJcIiBvbiBib3VuZHMgYW5kIGFsc28gbWFrZSB0aGUgY3VydmVcclxuICAgICAgICAgICAgICAgIC8vXCJmbGVlXCIgbW9yZSBmcm9tIGJvdW5kcyAob24gZXhpdClcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgc29sdXRpb25zLmxlbmd0aDsgcysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvbFR1cm5pbmdQb2ludHMgPSBzb2x1dGlvbnNbc11bMl07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZmlyc3Qgc2VnbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhMSA9IHNvbFR1cm5pbmdQb2ludHNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEyID0gc29sVHVybmluZ1BvaW50c1sxXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRNaWRkbGVQb2ludCA9IFV0aWwuZ2V0TWlkZGxlKGExLCBhMik7XHJcbiAgICAgICAgICAgICAgICAgICAgc29sVHVybmluZ1BvaW50cy5zcGxpY2UoMSwgMCwgc3RhcnRNaWRkbGVQb2ludCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vbGFzdCBzZWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEzID0gc29sVHVybmluZ1BvaW50c1tzb2xUdXJuaW5nUG9pbnRzLmxlbmd0aCAtIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhNCA9IHNvbFR1cm5pbmdQb2ludHNbc29sVHVybmluZ1BvaW50cy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kTWlkZGxlUG9pbnQgPSBVdGlsLmdldE1pZGRsZShhMywgYTQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNvbFR1cm5pbmdQb2ludHMuc3BsaWNlKHNvbFR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMSwgMCwgZW5kTWlkZGxlUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIDI6IC8vcmVtb3ZlIHBvaW50c1xyXG5cclxuICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKHNvbHV0aW9ucywgZnVuY3Rpb24oc29sdXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc29sVHlwZSA9IHNvbHV0aW9uWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb2xUeXBlID09ICdzMScgfHwgc29sVHlwZSA9PSAnczInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb2xUdXJuaW5nUG9pbnRzID0gc29sdXRpb25bMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvbFR1cm5pbmdQb2ludHMuc3BsaWNlKDEsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb2xUdXJuaW5nUG9pbnRzLnNwbGljZShzb2xUdXJuaW5nUG9pbnRzLmxlbmd0aCAtIDIsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAvKnJlbW92ZSBjb2xpbmVhciBwb2ludCBmb3IgczEgYXMgaXQgc2VlbXMgdGhhdCBtb3JlIGNvbGluZWFyIHBvaW50cyBkbyBub3QgbG9vayBnb29kXHJcbiAgICAgICAgICAgICAgICAgKiBvbiBvcmdhbmljIHNvbHV0aW9ucyA+OkQqL1xyXG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2goc29sdXRpb25zLCBmdW5jdGlvbihzb2x1dGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzb2xUeXBlID0gc29sdXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvbFR5cGUgPT0gJ3MxJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc29sVHVybmluZ1BvaW50cyA9IHNvbHV0aW9uWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVkdWNlZFNvbHV0aW9uID0gVXRpbC5jb2xsaW5lYXJSZWR1Y3Rpb24oc29sVHVybmluZ1BvaW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvbHV0aW9uWzJdID0gcmVkdWNlZFNvbHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfSAvL2VuZCBzd2l0Y2hcclxuXHJcbiAgICB9XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uTWFuYWdlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvQ29ubmVjdGlvbk1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDml6Xlv5fnsbtcclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcblxyXG4gICAgdmFyIExvZyAgPSB7XHJcbiAgICAgICAgTE9HX0xFVkVMX05PTkUgIDogMCxcclxuXHJcbiAgICAgICAgTE9HX0xFVkVMX0RFQlVHIDogMSxcclxuXHJcbiAgICAgICAgTE9HX0xFVkVMX0lORk8gOiAyLFxyXG5cclxuICAgICAgICBMT0dfTEVWRUxfRVJST1IgOiAzLFxyXG5cclxuICAgICAgICBsZXZlbCA6IHRoaXMuTE9HX0xFVkVMX0VSUk9SLFxyXG4gICAgICAgIFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogVGhlIGxlc3MgaW1wb3J0YW50IG9mIGFsbCBtZXNzYWdlc1xyXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgLSB0aGUgbWVzc2FnZSB0byBiZSBsb2dnZWRcclxuICAgICAgICAqKi9cclxuICAgICAgICBkZWJ1ZzogZnVuY3Rpb24gKG1lc3NhZ2Upe1xyXG4gICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5sZXZlbCA8PSB0aGlzLkxPR19MRVZFTF9ERUJVRyl7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pbiBGRiBpcyBkZWJ1Z1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBjb25zb2xlLmRlYnVnID09ICdmdW5jdGlvbicpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNley8vVE9ETzogaW4gSUUgaXMgbG9nXHJcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAqIFRoZSBjb21tb25seSB1c2VkIGxvZyBtZXNzYWdlXHJcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSAtIHRoZSBtZXNzYWdlIHRvIGJlIGxvZ2dlZFxyXG4gICAgICAgICoqL1xyXG4gICAgICAgIGluZm8gOiBmdW5jdGlvbiAobWVzc2FnZSl7XHJcbiAgICAgICAgICAgIGlmKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyl7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmxldmVsIDw9IHRoaXMuTE9HX0xFVkVMX0lORk8pe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogVGhlIHdvcnNlIGtpbmQgb2YgbWVzc2FnZS4gVXN1YWxseSBhIGNyYXNoXHJcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSAtIHRoZSBtZXNzYWdlIHRvIGJlIGxvZ2dlZFxyXG4gICAgICAgICoqL1xyXG4gICAgICAgIGVycm9yIDogZnVuY3Rpb24gKG1lc3NhZ2Upe1xyXG4gICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5sZXZlbCA8PSB0aGlzLkxPR19MRVZFTF9FUlJPUil7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqU3RhcnQgZ3JvdXBpbmcgdGhlIGxvZyBtZXNzYWdlc1xyXG4gICAgICAgICAqQHBhcmFtIHtTdHJpbmd9IHRpdGxlIC0gdGhlIHRpdGxlIG9mIHRoZSBncm91cFxyXG4gICAgICAgICAqQHNlZSA8YSBocmVmPVwiaHR0cDovL2dldGZpcmVidWcuY29tL2xvZ2dpbmdcIj5odHRwOi8vZ2V0ZmlyZWJ1Zy5jb20vbG9nZ2luZzwvYT5cclxuICAgICAgICAgKiovXHJcbiAgICAgICAgZ3JvdXAgOiBmdW5jdGlvbih0aXRsZSl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMubGV2ZWwgPD0gdGhpcy5MT0dfTEVWRUxfSU5GTyl7IC8vaWdub3JlIGdyb3VwIGlmIGxldmVsIG5vdCBkZWJ1ZyBvciBpbmZvXHJcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpeyAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqSWYgd2UgZG8gbm90IHRlc3QgZm9yIGdyb3VwKCkgZnVuY3Rpb24geW91IHdpbGwgZ2V0IGFuIGVycm9yIGluIE9wZXJhXHJcbiAgICAgICAgICAgICAgICAgICAgICphcyBPcGVyYSBoYXMgaXQncyBvd24gY29uc29sZS4uLndoaWNoIGRvZXMgbm90IGhhdmUgYSBncm91cCgpIGZ1bmN0aW9uKi9cclxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZS5ncm91cCA9PT0gJ2Z1bmN0aW9uJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXAodGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKkVuZHMgY3VycmVudCBtZXNzYWdlIGdyb3VwaW5nKi9cclxuICAgICAgICBncm91cEVuZCA6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMubGV2ZWwgPD0gdGhpcy5MT0dfTEVWRUxfSU5GTyl7IC8vaWdub3JlIGdyb3VwIGlmIGxldmVsIG5vdCBkZWJ1ZyBvciBpbmZvXHJcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKklmIHdlIGRvIG5vdCB0ZXN0IGZvciBncm91cEVuZCgpIGZ1bmN0aW9uIHlvdSB3aWxsIGdldCBhbiBlcnJvciBpbiBPcGVyYVxyXG4gICAgICAgICAgICAgICAgICAgICAqYXMgT3BlcmEgaGFzIGl0J3Mgb3duIGNvbnNvbGUuLi53aGljaCBkb2VzIG5vdCBoYXZlIGEgZ3JvdXAoKSBmdW5jdGlvbiovXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGNvbnNvbGUuZ3JvdXBFbmQgPT09ICdmdW5jdGlvbicpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy9Mb2cubGV2ZWwgPSBMb2cuTE9HX0xFVkVMX0RFQlVHOyBcclxuICAgIExvZy5sZXZlbCA9IExvZy5MT0dfTEVWRUxfRVJST1I7IFxyXG4gICAgLy9Mb2cubGV2ZWwgPSBMb2cuTE9HX0xFVkVMX0VSUk9SO1xyXG4gICAgLy9Mb2cubGV2ZWwgPSBMb2cuTE9HX0xFVkVMX05PTkU7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IExvZztcclxuICAgIFxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvTG9nLmpzXG4vLyBtb2R1bGUgaWQgPSA5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog5bi46YeP5a6a5LmJXHJcbiAqL1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IFx0e1xyXG5cdFx0RUxFTUVOVF9UWVBFOiBcImVsZW1lbnRUeXBlXCIsXHJcblx0XHRNT0RFOiBcIm1vZGVcIixcclxuXHRcdEJBQ0tHUk9VTkQ6IFwiYmFja2dyb3VkXCIsXHJcblx0XHRPUFRJT05TOiBcIm9wdGlvbnNcIixcclxuXHRcdFVTRVJEQVRBOiBcInVzZXJEYXRhXCIsXHJcblx0XHRJRDogXCJpZFwiLFxyXG5cdFx0U1RBUlRfSUQ6IFwic3RhcnROb2RlSWRcIixcclxuXHRcdEVORF9JRDogXCJlbmROb2RlSWRcIixcclxuXHRcdEFMQVJNOiBcIkFsYXJtXCIsXHJcblx0XHRSRUxBVElPTklEOlwicmVsYXRpb25JZFwiLFxyXG5cdFx0UkVMQVRJT05fSU1BR0U6XCJyZWxhdGlvbkltYWdlXCIsXHJcblx0XHRHUk9VUDogXCJHcm91cFwiLFxyXG5cdFx0R1JPVVBfTk9ERTpcIkdyb3VwTm9kZVwiLFxyXG5cdFx0Q09OTkVDVElPTjogXCJjb25uZWN0aW9uXCIsXHJcblx0XHRDSElMRFM6IFwiY2hpbGRzXCIsXHJcblx0XHRUUkVFX1JPT1Q6IFwidHJlZVJvb3RcIixcclxuXHRcdERPQ0tFUlM6XCJvcHRpb25zLmRvY2tlcnNcIixcclxuXHRcdFNUWUxFX0xJTkVUWVBFOlwic3R5bGUubGluZVR5cGVcIixcclxuXHRcdExJTkVPUEVSQVRJT05JQ09OOlwiTGluZU9wZXJhdGlvbkljb25cIixcclxuXHRcdERFTDpcIkRFTFwiLFxyXG5cdFx0TElOSzpcInN0cmFpZ2h0XCIsXHJcblx0XHRGT0xEOlwiamFnZ2VkXCIsXHJcblx0XHRDVVJWRTpcImN1cnZlXCJcclxuXHR9O1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL3V0aWwvRmxvd0NvbnN0YW50cy5qc1xuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEZsb3flt6XlhbfnsbtcclxuICogQGF1dGhvciB3YW5nLnhpYW9odTlcclxuICovXHJcblxyXG4gICAgdmFyIENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL0Zsb3dDb25zdGFudHMuanNcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgR3JvdXBOb2RlID0gcmVxdWlyZShcIi4uL25vZGUvR3JvdXBOb2RlLmpzXCIpO1xyXG4gICAgdmFyIFJlY3QgPSByZXF1aXJlKFwiLi4vbm9kZS9SZWN0LmpzXCIpO1xyXG4gICAgdmFyIENpcmNsZSA9IHJlcXVpcmUoXCIuLi9ub2RlL0NpcmNsZS5qc1wiKTtcclxuICAgIHZhciBJbWFnZSA9IHJlcXVpcmUoXCIuLi9ub2RlL0ltYWdlLmpzXCIpO1xyXG4gICAgdmFyIFRleHQgPSByZXF1aXJlKFwiLi4vbm9kZS9UZXh0LmpzXCIpO1xyXG4gICAgdmFyIFNlY3RvciA9IHJlcXVpcmUoXCIuLi9ub2RlL1NlY3Rvci5qc1wiKTtcclxuICAgIHZhciBSaW5nID0gcmVxdWlyZShcIi4uL25vZGUvUmluZy5qc1wiKTtcclxuICAgIHZhciBFbGxpcHNlID0gcmVxdWlyZShcIi4uL25vZGUvRWxsaXBzZS5qc1wiKTtcclxuICAgIHZhciBIZWFydCA9IHJlcXVpcmUoXCIuLi9ub2RlL0hlYXJ0LmpzXCIpO1xyXG4gICAgdmFyIERyb3BsZXQgPSByZXF1aXJlKFwiLi4vbm9kZS9Ecm9wbGV0LmpzXCIpO1xyXG4gICAgdmFyIFJvc2UgPSByZXF1aXJlKFwiLi4vbm9kZS9Sb3NlLmpzXCIpO1xyXG4gICAgdmFyIElzb2dvbiA9IHJlcXVpcmUoXCIuLi9ub2RlL0lzb2dvbi5qc1wiKTtcclxuICAgIHZhciBQb2x5Z29uID0gcmVxdWlyZShcIi4uL25vZGUvUG9seWdvbi5qc1wiKTtcclxuICAgIHZhciBMaW5lID0gcmVxdWlyZShcIi4uL25vZGUvTGluZS5qc1wiKTtcclxuICAgIHZhciBQb2x5bGluZSA9IHJlcXVpcmUoXCIuLi9ub2RlL1BvbHlsaW5lLmpzXCIpO1xyXG4gICAgdmFyIEJlemllckN1cnZlID0gcmVxdWlyZShcIi4uL25vZGUvQmV6aWVyQ3VydmUuanNcIik7XHJcbiAgICB2YXIgQXJjID0gcmVxdWlyZShcIi4uL25vZGUvQXJjLmpzXCIpO1xyXG4gICAgdmFyIFN0YXIgPSByZXF1aXJlKFwiLi4vbm9kZS9TdGFyLmpzXCIpO1xyXG4gICAgdmFyIFRyb2Nob2lkID0gcmVxdWlyZShcIi4uL25vZGUvVHJvY2hvaWQuanNcIik7XHJcbiAgICB2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9ub2RlL1BhdGguanNcIik7XHJcbiAgICB2YXIgSWNvbkJ1dHRvbiA9IHJlcXVpcmUoXCIuLi9ub2RlL0ljb25CdXR0b25cIik7XHJcbiAgICB2YXIgQ29ubmVjdG9yID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG4gICAgdmFyIGZsb3dMaW5rID0gcmVxdWlyZShcIi4uL2xpbmsvZmxvd0xpbmtcIik7XHJcbiAgICAvKipcclxuICAgICAqIOagueaNrue7k+eCueaVsOe7hCDlr7zlh7pKU09O5qC85byP55qE5pWw5o2uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gbW9kZWwg5oC755qE5qih5Z6LXHJcbiAgICAgKiBAcmV0dXJuIHtKU09OfSBKU09O5qC85byP55qE5pWw5o2uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRvSnNvbihtb2RlbCwgZ3JvdXApIHtcclxuICAgICAgICB2YXIganNvbkFyciA9IFtdO1xyXG4gICAgICAgIGdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5tb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgLy/lpoLmnpzmmK/nu4TnmoTor51cclxuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgR3JvdXBOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkQXJyID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlLm1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlIGluc3RhbmNlb2YgQ29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlLnJlZnJlc2hNb2RlbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUubW9kZWwuc2V0KFwib3B0aW9ucy5wb3NpdGlvblwiLCBjaGlsZE5vZGUucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRBcnIucHVzaChjaGlsZE5vZGUubW9kZWwub3B0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUubW9kZWwuc2V0KENvbnN0YW50cy5DSElMRFMsIGNoaWxkQXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQ29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZWZyZXNoTW9kZWwoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGpzb25BcnIucHVzaChub2RlLm1vZGVsLm9wdGlvbik7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgbW9kZWwuc2V0KENvbnN0YW50cy5DSElMRFMsIGpzb25BcnIpO1xyXG4gICAgICAgIHJldHVybiBtb2RlbC5vcHRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja4gSlNPTiDnlJ/miJDoioLngrlcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZmlzaFRvcG9mbG93IFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0ganNvbiAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNOb0NvdW50IOaYr+WQpumcgOimgXN0ZXDorqHmlbDvvIzpu5jorqTmmK/pnIDopoHorqHmlbBcclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZnJvbUpzb24oZmlzaFRvcG9mbG93LCBncm91cCwgY2hpbGRTaGFwZXMsIGlzQ2hpbGQsIGxheW91dFJvb3ROb2RlLCBpc05vQ291bnQpIHtcclxuICAgICAgICB2YXIgY29ubmVjdG9ycyA9IFtdO1xyXG4gICAgICAgIC8vIDEu5YWI5Yib5bu66IqC54K5ICDpgY3ljoblvaLnirYg6I635Y+W5qih5Z6LXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZFNoYXBlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBjaGlsZFNoYXBlc1tpXTtcclxuICAgICAgICAgICAgaWYgKHNoYXBlLmVsZW1lbnRUeXBlID09PSBDb25zdGFudHMuQ09OTkVDVElPTikge1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9ycy5wdXNoKHNoYXBlKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZS5lbGVtZW50VHlwZSA9PT0gQ29uc3RhbnRzLkFMQVJNKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVsYXRpb25Ob2RlID0gZmluZE5vZGVCeUlkKGZpc2hUb3BvZmxvdy5hbGxOb2Rlcywgc2hhcGUucmVsYXRpb25JZCk7XHJcbiAgICAgICAgICAgICAgICBmaXNoVG9wb2Zsb3cuY3JlYXRlQWxhcm0ocmVsYXRpb25Ob2RlLCBzaGFwZS5vcHRpb25zKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICgoc2hhcGUuZWxlbWVudFR5cGUgPT09IENvbnN0YW50cy5HUk9VUF9OT0RFKSB8fCAoc2hhcGUuZWxlbWVudFR5cGUgPT09IENvbnN0YW50cy5HUk9VUCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIOino+WGs+WPjeW6j+WIl+e7hO+8jOe7hOi/nue6v+aXoOazleWMuemFjee7hOmXrumimFxyXG4gICAgICAgICAgICAgICAgLy8gc2hhcGUub3B0aW9ucy5pZCA9IHNoYXBlLmlkO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNyZWF0ZWRHcm91cCA9IGZpc2hUb3BvZmxvdy5jcmVhdGVOb2RlKENvbnN0YW50cy5HUk9VUCwgc2hhcGUub3B0aW9ucywgc2hhcGUudXNlckRhdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlLmNoaWxkcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyb21Kc29uKGZpc2hUb3BvZmxvdywgY3JlYXRlZEdyb3VwLCBzaGFwZS5jaGlsZHMsIHRydWUsIGxheW91dFJvb3ROb2RlLCBpc05vQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIOWIpOaWree7hOiKgueCueaYr+WQpuacieeItuiKgueCuVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzQ2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBncm91cC5hZGQoY3JlYXRlZEdyb3VwKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlzaFRvcG9mbG93LmFkZE5vZGUoY3JlYXRlZEdyb3VwLCB7fSwgaXNOb0NvdW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8g5qC55o2ub3B0aW9uc+WIm+W7uuiKgueCuVxyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb2Zsb3cuY3JlYXRlTm9kZShzaGFwZS5lbGVtZW50VHlwZSwgc2hhcGUub3B0aW9ucywgc2hhcGUudXNlckRhdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQ2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBncm91cC5hZGQobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpc2hUb3BvZmxvdy5hZGROb2RlKG5vZGUsIHt9LCBpc05vQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZS5vcHRpb25zLmxheW91dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaGFwZS5vcHRpb25zLmxheW91dC5sYXlvdXQgPT09IENvbnN0YW50cy5UUkVFX1JPT1QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVGb3JMYXlvdXQgPSBmaW5kTm9kZUJ5SWQoZmlzaFRvcG9mbG93LmFsbE5vZGVzLCBzaGFwZS5pZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0Um9vdE5vZGUucHVzaChub2RlRm9yTGF5b3V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGZpc2hUb3BvLmxheW91dE5vZGUoXCJ0cmVlXCIse1wibm9kZVwiOm5vZGV9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAyLiDlho3liJvlu7rnur9cclxuICAgICAgICB6clV0aWwuZWFjaChjb25uZWN0b3JzLCBmdW5jdGlvbiAobGluZSkge1xyXG4gICAgICAgICAgICB2YXIgc3RhcnROb2RlID0gZmluZE5vZGVCeUlkKGZpc2hUb3BvZmxvdy5hbGxOb2RlcywgbGluZS5zdGFydE5vZGVJZCk7XHJcbiAgICAgICAgICAgIHZhciBlbmROb2RlID0gZmluZE5vZGVCeUlkKGZpc2hUb3BvZmxvdy5hbGxOb2RlcywgbGluZS5lbmROb2RlSWQpO1xyXG4gICAgICAgICAgICBpZiAoc3RhcnROb2RlICYmIGVuZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsaW5rID0gZmlzaFRvcG9mbG93LmNyZWF0ZUxpbmsoc3RhcnROb2RlLCBlbmROb2RlLCBsaW5lLm9wdGlvbnMsIGxpbmUudXNlckRhdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQ2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBncm91cC5hZGQobGluayk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpc2hUb3BvZmxvdy5hZGROb2RlKGxpbmssIHt9LCBpc05vQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHZhciB0aGlzTGluayA9IGZsb3dMaW5rLkxpbmsuY3JlYXRlQnlQb2ludChsaW5lLm9wdGlvbnMsbGluZS51c2VyRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmFkZCh0aGlzTGluayk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpc2hUb3BvZmxvdy5hZGROb2RlKHRoaXNMaW5rLCB7fSwgaXNOb0NvdW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja5pZOWcqGdyb3Vw5Lit5p+l5om+LCAg5Zug57uE5YaF5a2Q6IqC54K55LmL6Ze055qE6L+e57q/LOWcqGdyb3Vw5Lit5p+l5om+5LiN5YiwLOaJgOS7peimgeWcqGFsbE5vZGVz6YeM6Z2i5Y+WXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGdyb3VwICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5vZGVJZCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZpbmROb2RlQnlJZChhbGxOb2Rlcywgbm9kZUlkKSB7XHJcbiAgICAgICAgdmFyIHJldE5vZGUgPSBudWxsO1xyXG4gICAgICAgIGFsbE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT09IG5vZGVJZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0Tm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmV0Tm9kZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBjYW52YXMgd2hpY2ggaGFzIGFsbCB0aGluZyByZW5kZXJlZFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iYWNrZ3JvdW5kQ29sb3JdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldFJlbmRlcmVkQ2FudmFzKHpyLCBvcHRzKSB7XHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XHJcbiAgICAgICAgb3B0cy5waXhlbFJhdGlvID0gb3B0cy5waXhlbFJhdGlvIHx8IDE7XHJcbiAgICAgICAgb3B0cy5iYWNrZ3JvdW5kQ29sb3IgPSBvcHRzLmJhY2tncm91bmRDb2xvciB8fFxyXG4gICAgICAgICAgICBcIiNGRkZGRkZcIjtcclxuICAgICAgICB2YXIgbGlzdCA9IHpyLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKTtcclxuICAgICAgICAvLyBTdG9wIGFuaW1hdGlvbnNcclxuICAgICAgICB6clV0aWwuZWFjaChsaXN0LCBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgICAgdmFyIGFuaW1hdG9ycyA9IGVsLmFuaW1hdG9ycztcclxuICAgICAgICAgICAgdmFyIGxlbiA9IGFuaW1hdG9ycy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGFuaW1hdG9yc1tpXS5zdG9wKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB6ci5wYWludGVyLmdldFJlbmRlcmVkQ2FudmFzKG9wdHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRvRGF0YVVSTCh6ciwgb3B0cykge1xyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xyXG4gICAgICAgIHZhciB1cmwgPSBnZXRSZW5kZXJlZENhbnZhcyh6ciwgb3B0cykudG9EYXRhVVJMKFxyXG4gICAgICAgICAgICAnaW1hZ2UvJyArIChvcHRzICYmIG9wdHMudHlwZSB8fCAncG5nJylcclxuICAgICAgICApO1xyXG4gICAgICAgIHZhciBsaXN0ID0genIuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpO1xyXG4gICAgICAgIC8vIFN0YXJ0IGFuaW1hdGlvbnNcclxuICAgICAgICB6clV0aWwuZWFjaChsaXN0LCBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgICAgdmFyIGFuaW1hdG9ycyA9IGVsLmFuaW1hdG9ycztcclxuICAgICAgICAgICAgdmFyIGxlbiA9IGFuaW1hdG9ycy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGFuaW1hdG9yc1tpXS5zdGFydCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHVybDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0cnVuY1Bvc2l0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgdmFyIHggPSBwYXJzZUludChwb3NpdGlvblswXSwgMTApO1xyXG4gICAgICAgIHZhciB5ID0gcGFyc2VJbnQocG9zaXRpb25bMV0sIDEwKTtcclxuICAgICAgICBpZiAoeCA8IDApIHtcclxuICAgICAgICAgICAgeCA9IDBcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHkgPCAwKSB7XHJcbiAgICAgICAgICAgIHkgPSAwXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbeCwgeV07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJGbG93Tm9kZShmbG93Tm9kZSkge1xyXG4gICAgICAgIHZhciBub2RlQ3RvcnMgPSB7XHJcbiAgICAgICAgICAgIFJlY3Q6IFJlY3QsXHJcbiAgICAgICAgICAgIENpcmNsZTogQ2lyY2xlLFxyXG4gICAgICAgICAgICBJbWFnZTogSW1hZ2UsXHJcbiAgICAgICAgICAgIFRleHQ6IFRleHQsXHJcbiAgICAgICAgICAgIFNlY3RvcjogU2VjdG9yLFxyXG4gICAgICAgICAgICBSaW5nOiBSaW5nLFxyXG4gICAgICAgICAgICBFbGxpcHNlOiBFbGxpcHNlLFxyXG4gICAgICAgICAgICBIZWFydDogSGVhcnQsXHJcbiAgICAgICAgICAgIERyb3BsZXQ6IERyb3BsZXQsXHJcbiAgICAgICAgICAgIFJvc2U6IFJvc2UsXHJcbiAgICAgICAgICAgIElzb2dvbjogSXNvZ29uLFxyXG4gICAgICAgICAgICBQb2x5Z29uOiBQb2x5Z29uLFxyXG4gICAgICAgICAgICBMaW5lOiBMaW5lLFxyXG4gICAgICAgICAgICBQb2x5bGluZTogUG9seWxpbmUsXHJcbiAgICAgICAgICAgIEJlemllckN1cnZlOiBCZXppZXJDdXJ2ZSxcclxuICAgICAgICAgICAgQXJjOiBBcmMsXHJcbiAgICAgICAgICAgIFN0YXI6IFN0YXIsXHJcbiAgICAgICAgICAgIFRyb2Nob2lkOiBUcm9jaG9pZCxcclxuICAgICAgICAgICAgUGF0aDogUGF0aCxcclxuICAgICAgICAgICAgR3JvdXA6IEdyb3VwTm9kZSxcclxuICAgICAgICAgICAgSWNvbkJ1dHRvbjogSWNvbkJ1dHRvblxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIG5vZGVDdG9ycykge1xyXG4gICAgICAgICAgICBmbG93Tm9kZVtuYW1lXSA9IG5vZGVDdG9yc1tuYW1lXVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmxvd05vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3JtYWxpemUgY3NzIGxpa2VkIGFycmF5IGNvbmZpZ3VyYXRpb25cclxuICAgICAqIGUuZy5cclxuICAgICAqICAzID0+IFszLCAzLCAzLCAzXVxyXG4gICAgICogIFs0LCAyXSA9PiBbNCwgMiwgNCwgMl1cclxuICAgICAqICBbNCwgMywgMl0gPT4gWzQsIDMsIDIsIDNdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gdmFsXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUNzc0FycmF5KHZhbCkge1xyXG4gICAgICAgIHZhciBsZW4gPSB2YWwubGVuZ3RoO1xyXG4gICAgICAgIGlmICh0eXBlb2YgKHZhbCkgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbdmFsLCB2YWwsIHZhbCwgdmFsXTtcclxuICAgICAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xyXG4gICAgICAgICAgICAvLyB2ZXJ0aWNhbCB8IGhvcml6b250YWxcclxuICAgICAgICAgICAgcmV0dXJuIFt2YWxbMF0sIHZhbFsxXSwgdmFsWzBdLCB2YWxbMV1dO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobGVuID09PSAzKSB7XHJcbiAgICAgICAgICAgIC8vIHRvcCB8IGhvcml6b250YWwgfCBib3R0b21cclxuICAgICAgICAgICAgcmV0dXJuIFt2YWxbMF0sIHZhbFsxXSwgdmFsWzJdLCB2YWxbMV1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF90cmltKHN0cikge1xyXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFxzKyQvLCAnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VQZXJjZW50KHBlcmNlbnQsIGFsbCkge1xyXG4gICAgICAgIHN3aXRjaCAocGVyY2VudCkge1xyXG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxyXG4gICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxyXG4gICAgICAgICAgICAgICAgcGVyY2VudCA9ICc1MCUnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICBjYXNlICd0b3AnOlxyXG4gICAgICAgICAgICAgICAgcGVyY2VudCA9ICcwJSc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgICAgICAgICAgcGVyY2VudCA9ICcxMDAlJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHBlcmNlbnQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGlmIChfdHJpbShwZXJjZW50KS5tYXRjaCgvJSQvKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocGVyY2VudCkgLyAxMDAgKiBhbGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHBlcmNlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHBlcmNlbnQgPT0gbnVsbCA/IE5hTiA6ICtwZXJjZW50O1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1cHBlckNhc2VGaXJzdD1mYWxzZV1cclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gc3RyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHN0ciwgdXBwZXJDYXNlRmlyc3QpIHtcclxuICAgICAgICBzdHIgPSAoc3RyIHx8ICcnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0oLikvZywgZnVuY3Rpb24gKG1hdGNoLCBncm91cDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdyb3VwMS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAodXBwZXJDYXNlRmlyc3QgJiYgc3RyKSB7XHJcbiAgICAgICAgICAgIHN0ciA9IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuYWJsZSBwcm9wZXJ0eSBzdG9yYWdlIHRvIGFueSBob3N0IG9iamVjdC5cclxuICAgICAqIE5vdGljZTogU2VyaWFsaXphdGlvbiBpcyBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICpcclxuICAgICAqIEZvciBleGFtcGxlOlxyXG4gICAgICogdmFyIGdldCA9IG1vZGVsVWl0bC5tYWtlR2V0dGVyKCk7XHJcbiAgICAgKlxyXG4gICAgICogZnVuY3Rpb24gc29tZShob3N0T2JqKSB7XHJcbiAgICAgKiAgICAgIGdldChob3N0T2JqKS5fc29tZVByb3BlcnR5ID0gMTIxMjtcclxuICAgICAqICAgICAgLi4uXHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XHJcbiAgICAgKi9cclxuICAgIHZhciBtYWtlR2V0dGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSAnXFwwX190b3BvX3Byb3BfZ2V0dGVyXycgKyBpbmRleCsrO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGhvc3RPYmopIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBob3N0T2JqW2tleV0gfHwgKGhvc3RPYmpba2V5XSA9IHt9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgfSkoKTtcclxuICAgIHZhciBlbmNvZGVIVE1MID0gZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgIHJldHVybiBTdHJpbmcoc291cmNlKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvJy9nLCAnJiMzOTsnKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIFRQTF9WQVJfQUxJQVMgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnXTtcclxuXHJcbiAgICB2YXIgd3JhcFZhciA9IGZ1bmN0aW9uICh2YXJOYW1lLCBzZXJpZXNJZHgpIHtcclxuICAgICAgICByZXR1cm4gJ3snICsgdmFyTmFtZSArIChzZXJpZXNJZHggPT0gbnVsbCA/ICcnIDogc2VyaWVzSWR4KSArICd9JztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRlbXBsYXRlIGZvcm1hdHRlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRwbFxyXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0PnxPYmplY3R9IHBhcmFtc0xpc3RcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuY29kZT1mYWxzZV1cclxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0VHBsKHRwbCwgcGFyYW1zTGlzdCwgZW5jb2RlKSB7XHJcbiAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShwYXJhbXNMaXN0KSkge1xyXG4gICAgICAgICAgICBwYXJhbXNMaXN0ID0gW3BhcmFtc0xpc3RdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2VyaWVzTGVuID0gcGFyYW1zTGlzdC5sZW5ndGg7XHJcbiAgICAgICAgaWYgKCFzZXJpZXNMZW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyICR2YXJzID0gcGFyYW1zTGlzdFswXS4kdmFycyB8fCBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR2YXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBhbGlhcyA9IFRQTF9WQVJfQUxJQVNbaV07XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSB3cmFwVmFyKGFsaWFzLCAwKTtcclxuICAgICAgICAgICAgdHBsID0gdHBsLnJlcGxhY2Uod3JhcFZhcihhbGlhcyksIGVuY29kZSA/IGVuY29kZUhUTUwodmFsKSA6IHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIHNlcmllc0lkeCA9IDA7IHNlcmllc0lkeCA8IHNlcmllc0xlbjsgc2VyaWVzSWR4KyspIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCAkdmFycy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IHBhcmFtc0xpc3Rbc2VyaWVzSWR4XVskdmFyc1trXV07XHJcbiAgICAgICAgICAgICAgICB0cGwgPSB0cGwucmVwbGFjZShcclxuICAgICAgICAgICAgICAgICAgICB3cmFwVmFyKFRQTF9WQVJfQUxJQVNba10sIHNlcmllc0lkeCksXHJcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlID8gZW5jb2RlSFRNTChyZXQpIDogcmV0XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHBsO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgICAgICB0b0pzb246IHRvSnNvbixcclxuICAgICAgICBmcm9tSnNvbjogZnJvbUpzb24sXHJcbiAgICAgICAgdG9EYXRhVVJMOiB0b0RhdGFVUkwsXHJcbiAgICAgICAgdHJ1bmNQb3NpdGlvbjogdHJ1bmNQb3NpdGlvbixcclxuICAgICAgICByZWdpc3RlckZsb3dOb2RlOiByZWdpc3RlckZsb3dOb2RlLFxyXG4gICAgICAgIG5vcm1hbGl6ZUNzc0FycmF5OiBub3JtYWxpemVDc3NBcnJheSxcclxuICAgICAgICBwYXJzZVBlcmNlbnQ6IHBhcnNlUGVyY2VudCxcclxuICAgICAgICB0b0NhbWVsQ2FzZTogdG9DYW1lbENhc2UsXHJcbiAgICAgICAgbWFrZUdldHRlcjogbWFrZUdldHRlcixcclxuICAgICAgICBmb3JtYXRUcGw6IGZvcm1hdFRwbCxcclxuICAgICAgICBmaW5kTm9kZUJ5SWQ6IGZpbmROb2RlQnlJZFxyXG4gICAgfTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL3V0aWwvRmxvd1V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDnu4TvvIwg57uE5Lit5YWD57Sg55qE5Z2Q5qCH6YO95piv55u45a+55LqO6L+Z5Liq57uE55qEPGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93Lm5vZGUuR3JvdXBOb2RlXHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIHZhciBncm91cDEgPSBuZXcgbm9kZS5Hcm91cCh7XHJcbiAqICAgICAgICAgICBwb3NpdGlvbjpbNjAsNTBdXHJcbiAqICAgICAgIH0pO1xyXG4gKlxyXG4gKiAgICAgICB2YXIgcmVjdDEgPSBuZXcgbm9kZS5SZWN0KHtcclxuICogICAgICAgICAgIHNoYXBlOnt3aWR0aDoxMjAsaGVpZ2h0OjMwfSxcclxuICogICAgICAgICAgIHN0eWxlOnt0ZXh0Olwi5qCH6aKYXCIsIGZpbGw6XCIjRkZCOTBGXCIsc3Ryb2tlOlwiI2JiYmJiYlwifSxcclxuICogICAgICAgICAgIHBvc2l0aW9uOlswLDBdLFxyXG4gKiAgICAgICAgICAgc2VsZWN0YWJsZTpmYWxzZVxyXG4gKiAgICAgICB9KTtcclxuICpcclxuICogICAgICAgdmFyIHJlY3QyID0gbmV3IG5vZGUuUmVjdCh7XHJcbiAqICAgICAgICAgICBzaGFwZTp7d2lkdGg6MTIwLGhlaWdodDo2MH0sXHJcbiAqICAgICAgICAgICBzdHlsZTp7dGV4dDpcIuWGheWuuVwiLCBmaWxsOlwiI0ZGRkZGRlwiLHN0cm9rZTpcIiNiYmJiYmJcIn0sXHJcbiAqICAgICAgICAgICBwb3NpdGlvbjpbMCwzMF0sXHJcbiAqICAgICAgICAgICBzZWxlY3RhYmxlOmZhbHNlXHJcbiAqICAgICAgIH0pO1xyXG4gKlxyXG4gKiAgICAgICBncm91cDEuYWRkKHJlY3QxKTtcclxuICogICAgICAgZ3JvdXAxLmFkZChyZWN0Mik7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChncm91cDEpO1xyXG4gKi9cclxuXHJcblxyXG5cclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qcycpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvdXRpbC5qc1wiKTtcclxuICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcbiAgICB2YXIgZmxvd05vZGUgPXJlcXVpcmUoJy4vZmxvd05vZGUnKTtcclxuXHJcbiAgICBmdW5jdGlvbiBHcm91cE5vZGUob3B0cykge1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBmbG93Tm9kZS5nZW5Nb2RlbChcIkdyb3VwTm9kZVwiLCBvcHRzKTtcclxuICAgICAgICBncmFwaGljLkdyb3VwLmNhbGwodGhpcywgb3B0cyk7XHJcblxyXG4gICAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiA1LFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1LFxyXG4gICAgICAgICAgICAgICAgcjogNVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJ3JnYmEoMCwwLDAsMCknLC8vJyNmOWY5ZjknLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAncmdiYSgwLDAsMCwwKScvLycjYmJiYmJiJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogWzAsIDBdXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdHMsIHRydWUpO1xyXG4gICAgICAgIC8v5Ye95pWw5peg5rOVY2xvbmUg5Y6f5Z6LY2xvbmXkuI3kuIpcclxuICAgICAgICB0aGlzLm9wdGlvbnMubGF5b3V0ID0gb3B0cy5sYXlvdXQ7XHJcbiAgICAgICAgdGhpcy5tYXggPSBbMTAyNCwgOTYwXTtcclxuICAgICAgICB0aGlzLnJlbmRlcih0aGlzLm9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgR3JvdXBOb2RlLlJFQ1RfTkFNRSA9IFwiR1JPVVBfUkVDVF9OQU1FXCI7XHJcbiAgICBHcm91cE5vZGUucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBHcm91cE5vZGUsXHJcbiAgICAgICAgdHlwZTogXCJHcm91cE5vZGVcIixcclxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChtb2RlbCkge1xyXG4gICAgICAgICAgICB2YXIgcmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xyXG4gICAgICAgICAgICAgICAgc2hhcGU6IG1vZGVsLnNoYXBlLFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IG1vZGVsLnN0eWxlLFxyXG4gICAgICAgICAgICAgICAgLy9zaWxlbnQ6dHJ1ZSwgLy/liqDkuIrlkI4g5ouW5YqoIOe7hOS4reayoeacieWtkOWFg+e0oOeahOWcsOaWuSDml6Dms5XmiYvliqjkuoZcclxuICAgICAgICAgICAgICAgIHo6IDFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJlY3QubmFtZSA9IEdyb3VwTm9kZS5SRUNUX05BTUU7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHJlY3QpO1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gbW9kZWwucG9zaXRpb247XHJcbiAgICAgICAgICAgIHRoaXMubWVyZ2VkSW1hZ2UgPSBtb2RlbC5tZXJnZWRJbWFnZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlY3RDb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICB2YXIgcmVjdCA9IHV0aWwuZ2V0UmVjdCh0aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlY3QuYm91bmRpbmdSZWN0LmNvbnRhaW4oeCwgeSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYWRkOiBmdW5jdGlvbihjaGlsZCkge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQgJiYgY2hpbGQgIT09IHRoaXMgJiYgY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RvQWRkKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9hcGkgJiYgdGhpcy5fYXBpLl9hZGRHcm91cE5vZGUodGhpcyxjaGlsZCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDpgY3ljobnu4TkuK3mr4/kuIDkuKrlrZDoioLngrlcclxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2Ig5Zue6LCD5Ye95pWwY2JcclxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGNvbnRleHQgICDkuIrkuIvmlodjb250ZXh0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZWFjaDogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5uYW1lICE9IEdyb3VwTm9kZS5SRUNUX05BTUUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGNoaWxkLCBpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIOiuvue9riBncm91cOS4reahhuW9ouWkp+Wwj+S4uiBncm91cOeahOWMheWbtOWSjFxyXG4gICAgICAgIHdpbGxSZW5kZXI6ZnVuY3Rpb24gKGFwaSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxheW91dCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRMYXlvdXQodGhpcy5vcHRpb25zLmxheW91dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zZXRQcm9wZXJ0aWVzKHtcclxuICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fYXBpID0gYXBpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldExheW91dDogZnVuY3Rpb24oTGF5b3V0KSB7XHJcbiAgICAgICAgICAgIExheW91dC5ydW4odGhpcyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0UmVjdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAgICAgdmFyIGNsaXBQYXRoID0gdGhpcy5jbGlwUGF0aDtcclxuICAgICAgICAgICAgLy8g6IqC54K56KOB5Ymq5ZCO77yM5Lul6KOB5Ymq6IqC54K55YyF5Zu055uS5Li65YeGXHJcbiAgICAgICAgICAgIGlmIChjbGlwUGF0aCkge1xyXG4gICAgICAgICAgICAgICAgYm91bmRpbmdSZWN0ID0gY2xpcFBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy/liJvlu7rmnIDlsI/ljIXlm7Tnm5LomZrnur9cclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICBwb2ludHNbMF0gPSBbLWJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIC1ib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMl07XHJcbiAgICAgICAgICAgIHBvaW50c1sxXSA9IFtib3VuZGluZ1JlY3Qud2lkdGggLyAyLCAtYm91bmRpbmdSZWN0LmhlaWdodCAvIDJdO1xyXG4gICAgICAgICAgICBwb2ludHNbMl0gPSBbYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgYm91bmRpbmdSZWN0LmhlaWdodCAvIDJdO1xyXG4gICAgICAgICAgICBwb2ludHNbM10gPSBbLWJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIGJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuICAgICAgICAgICAgcG9pbnRzWzRdID0gWy1ib3VuZGluZ1JlY3Qud2lkdGggLyAyLCAtYm91bmRpbmdSZWN0LmhlaWdodCAvIDJdO1xyXG5cclxuICAgICAgICAgICAgdmFyIGJvdW5kUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QodGhpcy5wb3NpdGlvblswXSxcclxuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMV0sXHJcbiAgICAgICAgICAgICAgICBib3VuZGluZ1JlY3Qud2lkdGgsIGJvdW5kaW5nUmVjdC5oZWlnaHQpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgeDogdGhpcy5wb3NpdGlvblswXSArIGJvdW5kaW5nUmVjdC53aWR0aCAvIDIsXHJcbiAgICAgICAgICAgICAgICB5OiB0aGlzLnBvc2l0aW9uWzFdICsgYm91bmRpbmdSZWN0LmhlaWdodCAvIDIsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogYm91bmRpbmdSZWN0LndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBib3VuZGluZ1JlY3QuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXHJcbiAgICAgICAgICAgICAgICBib3VuZGluZ1JlY3Q6IGJvdW5kUmVjdFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5ouW5ou957uE5YaF6IqC54K555qE5pe25YCZ77yM5Yqo5oCB5pu05pS56IOM5pmvcmVjdOeahOWkp+Wwj1xyXG4gICAgICAgICAqIEBwYXJhbSBub2RlTWVzc2FnZSDmi5bmi73nmoTnu4TlhoXoioLngrnnmoTkv6Hmga9cclxuICAgICAgICAgKi9cclxuICAgICAgICBtb2RpZnlHcm91cFJlY3Q6IGZ1bmN0aW9uIChub2RlTWVzc2FnZSkge1xyXG4gICAgICAgICAgICAvLzEu6YeN572u6IOM5pmvcmVjdCDnmoTplb/lrr1cclxuICAgICAgICAgICAgdmFyIG1pbkxlbmd0aCA9IHRoaXMub3B0aW9ucy5zaGFwZS5yO1xyXG4gICAgICAgICAgICB0aGlzLnNldFByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogbWluTGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogbWluTGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIHI6IG1pbkxlbmd0aFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5jaGlsZE9mTmFtZShHcm91cE5vZGUuUkVDVF9OQU1FKTtcclxuICAgICAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGJvdW5kaW5nUmVjdC53aWR0aDtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGJvdW5kaW5nUmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciByeCA9IHJlY3QucG9zaXRpb25bMF0sLy9yZWN0LnNoYXBlLngsXHJcbiAgICAgICAgICAgICAgICByeSA9IHJlY3QucG9zaXRpb25bMV07Ly9yZWN0LnNoYXBlLnk7XHJcbiAgICAgICAgICAgIC8vMi7lj5Zncm91cOS4reaJgOacieiKgueCueacgOmdoOS4iui+ueWSjOacgOmrmOW3pui+ueeahOWAvO+8jOS4jeWMheaLrOiDjOaZr3JlY3TnmoTlgLxcclxuICAgICAgICAgICAgdmFyIG1pblggPSB0aGlzLl9jaGlsZHJlblsxXS5wb3NpdGlvblswXSxcclxuICAgICAgICAgICAgICAgIG1pblkgPSB0aGlzLl9jaGlsZHJlblsxXS5wb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgdmFyIG1heFggPSB0aGlzLl9jaGlsZHJlblsxXS5wb3NpdGlvblswXSxcclxuICAgICAgICAgICAgICAgIG1heFkgPSB0aGlzLl9jaGlsZHJlblsxXS5wb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgdmFyIG5vd05vZGVQb3NpdGlvbiA9IHpyVXRpbC5jbG9uZShub2RlTWVzc2FnZS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaGlsZHJlbltpXSBpbnN0YW5jZW9mIENvbm5lY3RvciB8fCB0aGlzLl9jaGlsZHJlbltpXS5pc0ljb24gPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWluWCA+IHRoaXMuX2NoaWxkcmVuW2ldLnBvc2l0aW9uWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblggPSB0aGlzLl9jaGlsZHJlbltpXS5wb3NpdGlvblswXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heFggPCB0aGlzLl9jaGlsZHJlbltpXS5wb3NpdGlvblswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhYID0gdGhpcy5fY2hpbGRyZW5baV0ucG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5ZID4gdGhpcy5fY2hpbGRyZW5baV0ucG9zaXRpb25bMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluWSA9IHRoaXMuX2NoaWxkcmVuW2ldLnBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF4WSA8IHRoaXMuX2NoaWxkcmVuW2ldLnBvc2l0aW9uWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFkgPSB0aGlzLl9jaGlsZHJlbltpXS5wb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIDMuIOWuveW6puWkp+S6juacgOWkp+WuveW6plxyXG4gICAgICAgICAgICBpZiAod2lkdGggPiB0aGlzLm1heFswXSkge1xyXG4gICAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLm1heFswXSAtIDI7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZU1lc3NhZ2UucG9zaXRpb25bMF0gPiBtaW5YKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm93Tm9kZVBvc2l0aW9uWzBdID0gbWluWCArIHRoaXMubWF4WzBdIC0gbm9kZU1lc3NhZ2Uud2lkdGg7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vd05vZGVQb3NpdGlvblswXSA9IG1heFggLSB0aGlzLm1heFswXSArIG5vZGVNZXNzYWdlLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy/np7vliqjoioLngrnmlLnlj5hncm91cOS4reiDjOaZr3JlY3TnmoR45L2N572u77yM5LiN6LaF6L+H5pyA5bCP55qE5YC8XHJcbiAgICAgICAgICAgICAgICByeCA9IHJlY3QucG9zaXRpb25bMF0gKyBub2RlTWVzc2FnZS5wb3NpdGlvblswXTtcclxuICAgICAgICAgICAgICAgIGlmIChyeCA+IG1pblgpIHtcclxuICAgICAgICAgICAgICAgICAgICByeCA9IG1pblg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZU1lc3NhZ2UuaXNNb3ZlKSB7IC8vZHJhZ1xyXG4gICAgICAgICAgICAgICAgICAgIG5vd05vZGVQb3NpdGlvblswXSA9IG5vZGVNZXNzYWdlLm1vdmVQb3NpdGlvblswXSArIG5vZGVNZXNzYWdlLm1vdmVYO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBub3dOb2RlUG9zaXRpb25bMF0gPSBub2RlTWVzc2FnZS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChub2RlTWVzc2FnZS5wb3NpdGlvblswXSA+IG1pblgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm93Tm9kZVBvc2l0aW9uWzBdID4gbWluWCArIHRoaXMubWF4WzBdIC0gbm9kZU1lc3NhZ2Uud2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm93Tm9kZVBvc2l0aW9uWzBdID0gbWluWCArIHRoaXMubWF4WzBdIC0gbm9kZU1lc3NhZ2Uud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm93Tm9kZVBvc2l0aW9uWzBdIDwgbWF4WCAtIHRoaXMubWF4WzBdICsgbm9kZU1lc3NhZ2Uud2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm93Tm9kZVBvc2l0aW9uWzBdID0gbWF4WCAtIHRoaXMubWF4WzBdICsgbm9kZU1lc3NhZ2Uud2lkdGhcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGhlaWdodCA+IHRoaXMubWF4WzFdKSB7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLm1heFsxXSAtIDI7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZU1lc3NhZ2UucG9zaXRpb25bMV0gPiBtaW5ZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm93Tm9kZVBvc2l0aW9uWzFdID0gbWluWSArIHRoaXMubWF4WzFdIC0gbm9kZU1lc3NhZ2UuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBub3dOb2RlUG9zaXRpb25bMV0gPSBtYXhZIC0gdGhpcy5tYXhbMV0gKyBub2RlTWVzc2FnZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL+enu+WKqOiKgueCueaUueWPmGdyb3Vw5Lit6IOM5pmvcmVjdOeahHnkvY3nva7vvIzkuI3otoXov4fmnIDlsI/nmoTlgLxcclxuICAgICAgICAgICAgICAgIHJ5ID0gcmVjdC5wb3NpdGlvblsxXSArIChub2RlTWVzc2FnZS5wb3NpdGlvblsxXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocnkgPiBtaW5ZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnkgPSBtaW5ZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVNZXNzYWdlLmlzTW92ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vd05vZGVQb3NpdGlvblsxXSA9IG5vZGVNZXNzYWdlLm1vdmVQb3NpdGlvblsxXSArIG5vZGVNZXNzYWdlLm1vdmVZO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBub3dOb2RlUG9zaXRpb25bMV0gPSBub2RlTWVzc2FnZS5wb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChub2RlTWVzc2FnZS5wb3NpdGlvblsxXSA+IG1pblkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm93Tm9kZVBvc2l0aW9uWzFdID4gbWluWSArIHRoaXMubWF4WzFdIC0gbm9kZU1lc3NhZ2UuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vd05vZGVQb3NpdGlvblsxXSA9IG1pblkgKyB0aGlzLm1heFsxXSAtIG5vZGVNZXNzYWdlLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub3dOb2RlUG9zaXRpb25bMV0gPCBtYXhZIC0gdGhpcy5tYXhbMV0gKyBub2RlTWVzc2FnZS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm93Tm9kZVBvc2l0aW9uWzFdID0gbWF4WSAtIHRoaXMubWF4WzFdICsgbm9kZU1lc3NhZ2UuaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChub2RlTWVzc2FnZS5ub2RlLmFsYXJtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3QWxhcm1Qb3NpdGlvbiA9IFtub3dOb2RlUG9zaXRpb25bMF0gKyBub2RlTWVzc2FnZS5ub2RlLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC0gKG5vZGVNZXNzYWdlLm5vZGUuYWxhcm1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC0gNiksIG5vd05vZGVQb3NpdGlvblsxXSAtIG5vZGVNZXNzYWdlLm5vZGUuYWxhcm0uZ2V0Qm91bmRpbmdSZWN0KClcclxuICAgICAgICAgICAgICAgICAgICAuaGVpZ2h0IC0gM1xyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIG5vZGVNZXNzYWdlLm5vZGUuYWxhcm0uYXR0cihcInBvc2l0aW9uXCIsIG5ld0FsYXJtUG9zaXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8v5pS55Y+Y6IOM5pmvcmVjdOeahOmVv+WuveWSjOS9jee9rlxyXG4gICAgICAgICAgICB0aGlzLnNldFByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgeDogcngsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogcnlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldFByb3BlcnRpZXM6IGZ1bmN0aW9uIChvcHQpIHtcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNoaWxkT2ZOYW1lKEdyb3VwTm9kZS5SRUNUX05BTUUpO1xyXG4gICAgICAgICAgICByZWN0LnNldFNoYXBlKG9wdC5zaGFwZSk7XHJcbiAgICAgICAgICAgLy8gcmVjdC5hdHRyKFwic3R5bGVcIiwgb3B0LnN0eWxlKTtcclxuICAgICAgICAgICAgdGhpcy5hdHRyKCdwb3NpdGlvbicsIG9wdC5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgLy8gdGhpcy5hdHRyKFwic2hhcGVcIiwgb3B0LnNoYXBlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBtZXJnZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICAvL+S/neeVmWdyb3Vw55qE5Yid5aeL5L2N572uXHJcbiAgICAgICAgICAgIHZhciBncm91cFBvc2l0aW9uID0genJVdGlsLmNsb25lKHRoaXMucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAvL+e7meWwj+WbvueJh+iuvue9ruWxnuaAp++8jOmakOiXj2dyb3VwXHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuX3JlbGF0aW9uSW1hZ2UuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLl9yZWxhdGlvbkltYWdlLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodDtcclxuICAgICAgICAgICAgLy/orqHnrpflkIjlubblkI7nmoTlsI/lm77niYfnmoRwb3NpdGlvblxyXG4gICAgICAgICAgICB2YXIgcmVsYXRpb25JbWFnZVBvc2l0aW9uID0gW3RoaXMucG9zaXRpb25bMF0gKyB0aGlzLmNoaWxkT2ZOYW1lKEdyb3VwTm9kZS5SRUNUX05BTUUpLnNoYXBlLnggKyAodGhpcy5nZXRCb3VuZGluZ1JlY3QoKVxyXG4gICAgICAgICAgICAgICAgICAgIC53aWR0aCAvIDIgLSB3aWR0aCAvIDIpLCB0aGlzLnBvc2l0aW9uWzFdICsgdGhpcy5jaGlsZE9mTmFtZShHcm91cE5vZGUuUkVDVF9OQU1FKS5zaGFwZS55ICtcclxuICAgICAgICAgICAgICAgICh0aGlzLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCAvIDIgLSBoZWlnaHQgLyAyKVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAvL+WwhuWwj+WbvueJh+eahOS9jee9ruS/neeVmeS4i+adpVxyXG4gICAgICAgICAgICB2YXIgY2xvbmVJbWFnZVBvc2l0aW9uID0genJVdGlsLmNsb25lKHJlbGF0aW9uSW1hZ2VQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbGF0aW9uSW1hZ2UuYXR0cihcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgICAgIGltYWdlOiB0aGlzLm1lcmdlZEltYWdlLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbGF0aW9uSW1hZ2UuYXR0cihcInBvc2l0aW9uXCIsIHJlbGF0aW9uSW1hZ2VQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGlmICh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWxhdGlvbkltYWdlLnNob3coKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy/lj4zlh7vlm77niYfmlL7lh7rnu4RcclxuICAgICAgICAgICAgdGhpcy5fcmVsYXRpb25JbWFnZS5vbihcImRibGNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8v6K6+572u57uE55qE5L2N572u5qC55o2u5bCP5Zu+54mH55qE5YGP56e76YeP5p2l6K6h566XXHJcbiAgICAgICAgICAgICAgICB0aGF0LmF0dHIoJ3Bvc2l0aW9uJyxbZ3JvdXBQb3NpdGlvblswXSArICh0aGlzLnBvc2l0aW9uWzBdIC1jbG9uZUltYWdlUG9zaXRpb25bMF0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zaXRpb25bMV0gKyAodGhpcy5wb3NpdGlvblsxXSAtIGNsb25lSW1hZ2VQb3NpdGlvblsxXSldKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5zaG93KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVsYXRpb25JbWFnZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZVNoYXBlOiBmdW5jdGlvbiAocmF0aW8sIGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgdmFyIHNjYWxlUmF0aW8gPSBOdW1iZXIocmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLm9wdGlvbnMuc2hhcGU7XHJcbiAgICAgICAgICAgIHZhciBuZXdXID0gTnVtYmVyKHNoYXBlLndpZHRoICogc2NhbGVSYXRpbyk7XHJcbiAgICAgICAgICAgIHZhciBuZXdIID0gTnVtYmVyKG5ld1cgKiBzaGFwZS5oZWlnaHQgLyBzaGFwZS53aWR0aCk7XHJcbiAgICAgICAgICAgIGlmIChpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdXID0gcGFyc2VJbnQobmV3VywgMTApO1xyXG4gICAgICAgICAgICAgICAgbmV3SCA9IHBhcnNlSW50KG5ld0gsIDEwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDmjInmr5TkvovnvKnmlL5cclxuICAgICAgICAgICAgdGhpcy5zZXRQcm9wZXJ0aWVzKHtcclxuICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG5ld1csXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBuZXdIXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyDmm7TmlrDnu4TlhoXoioLngrlcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24odikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdi5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIGlmICh2Lm5hbWUgIT09IEdyb3VwTm9kZS5SRUNUX05BTUUgJiYgISh2IGluc3RhbmNlb2YgQ29ubmVjdG9yKSAmJiB2LnR5cGUgIT09ICdaUGF0aCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDmr4/kuKroioLngrnnmoRwb3NpdGlvbuabtOaWsFxyXG4gICAgICAgICAgICAgICAgICAgIHYudXBkYXRlU2hhcGUocmF0aW8sIGlmUGFyc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHYuYXR0cigncG9zaXRpb24nLCBbcG9zaXRpb25bMF0gKiBzY2FsZVJhdGlvLCBwb3NpdGlvblsxXSAqIHNjYWxlUmF0aW9dKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodi50eXBlID09PSAnWlBhdGgnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB2LnJlY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdC5oZWlnaHQgPSByZWN0LmhlaWdodCAqIHNjYWxlUmF0aW87XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdC53aWR0aCA9IHJlY3Qud2lkdGggKiBzY2FsZVJhdGlvO1xyXG4gICAgICAgICAgICAgICAgICAgIHYuYXR0cih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbcG9zaXRpb25bMF0gKiBzY2FsZVJhdGlvLCBwb3NpdGlvblsxXSAqIHNjYWxlUmF0aW9dLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0OiByZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB6clV0aWwuaW5oZXJpdHMoR3JvdXBOb2RlLCBncmFwaGljLkdyb3VwKTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gR3JvdXBOb2RlO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgYWRkXHJcbiAqIOWwhuiKgueCueWKoOWFpeWIsOi/meS4que7hOS4reacgOWQjlxyXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZSDmrLLmt7vliqDliLDnu4TnmoToioLngrlcclxuICovXHJcbi8qKlxyXG4gKiBAbWV0aG9kIHJlbW92ZUFsbFxyXG4gKiDnp7vpmaTmiYDmnInlrZDoioLngrlcclxuICovXHJcblxyXG4vKipcclxuICogQG1ldGhvZCByZW1vdmVcclxuICog56e76Zmk5omA5pyJ5a2Q6IqC54K5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGlsZCDlrZDoioLngrlcclxuICovXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGNoaWxkT2ZOYW1lXHJcbiAqIOiOt+WPluaMh+WumuWQjeWtl+eahOWEv+WtkOiKgueCuVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IOiKgueCuVxyXG4gKi9cclxuLyoqXHJcbiAqIEBtZXRob2QgdHJhdmVyc2VcclxuICog5rex5bqm5LyY5YWI6YGN5Y6G5omA5pyJ5a2Q5a2Z6IqC54K577yIZWFjaOWPqumBjeWOhuWtkOiKgueCue+8iVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IOiKgueCuVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2ZnIHtTdHJpbmd9IG1lcmdlZEltYWdlPScnICDmjqfliLblvZPlj4zlh7vml7Yg57uE5Y+v5Lul57yp5bCP5Li65oyH5a6a55qE5Zu+5b2i44CCXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjZmcge0Jvb2xlYW59IGNoaWxkRHJhZ2dhYmxlPWZhbHNlICDmjqfliLbnu4TlhoXmiJDlkZjmmK/lkKblj6/ku6Xmi5bliqhcclxuICovXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9Hcm91cE5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxyXG4gKiBmaXNoVG9wb0Zsb3fnmoRub2Rl5a+56LGh77yM5qGG5p625o+Q5L6b55qE6IqC54K56YO95pS+5Zyo6L+Z5Liq5a+56LGh5LiL44CC6YCa6L+HZXh0ZW5k5pa55rOV5Yib5bu66Ieq5a6a5LmJ6IqC54K5PGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93Lm5vZGVcclxuICogQGFic3RyYWN0XHJcbiAqXHJcbiAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICpcclxuICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gICAgKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAgICAqICAgICAgdmFyIERpYW1vbmQgPSBub2RlLmV4dGVuZCh7XHJcbiAgICAqICAgICAgICAgIHR5cGU6ICdEaWFtb25kJyxcclxuICAgICogICAgICAgICAgc2hhcGU6IHtcclxuICAgICogICAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgKiAgICAgICAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAqICAgICAgICAgIH0sXHJcbiAgICAqICAgICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XHJcbiAgICAqICAgICAgICAgICAgICB2YXIgY3ggPSAwO1xyXG4gICAgKiAgICAgICAgICAgICAgdmFyIGN5ID0gMDtcclxuICAgICogICAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoIC8gMjtcclxuICAgICogICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQgLyAyO1xyXG4gICAgKiAgICAgICAgICAgICAgcGF0aC5tb3ZlVG8oY3gsIGN5IC0gaGVpZ2h0KTtcclxuICAgICogICAgICAgICAgICAgIHBhdGgubGluZVRvKGN4ICsgd2lkdGgsIGN5KTtcclxuICAgICogICAgICAgICAgICAgIHBhdGgubGluZVRvKGN4LCBjeSArIGhlaWdodCk7XHJcbiAgICAqICAgICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCAtIHdpZHRoLCBjeSk7XHJcbiAgICAqICAgICAgICAgICAgICBwYXRoLmNsb3NlUGF0aCgpO1xyXG4gICAgKiAgICAgICAgICB9XHJcbiAgICAqICAgICAgfSk7XHJcbiAgICAqICAgICAgICB2YXIgZGlhbW9kID0gbmV3IERpYW1vbmQoe1xyXG4gICAgKiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAqICAgICAgICAgICAgICAgIHdpZHRoOjUwLFxyXG4gICAgKiAgICAgICAgICAgICAgICBoZWlnaHQ6NTBcclxuICAgICogICAgICAgICAgICB9LFxyXG4gICAgKiAgICAgICAgICAgIHBvc2l0aW9uOls2MCw2MF1cclxuICAgICogICAgICAgIH0pXHJcbiAgICAqICAgICAgICBmaXNoVG9wby5hZGQoZGlhbW9kKTtcclxuICovXHJcblxyXG4gICAgdmFyIFBhdGggPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL1BhdGgnKTtcclxuICAgIHZhciBDb25zdGFudHMgPSByZXF1aXJlKFwiLi4vdXRpbC9GbG93Q29uc3RhbnRzLmpzXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL21vZGVsLmpzXCIpO1xyXG4gICAgdmFyIGZsb3dOb2RlID0ge307XHJcbiAgICAvKipcclxuICAgICAqIOaehOmAoOaooeWei1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZmxvd05vZGUuZ2VuTW9kZWwgPSBmdW5jdGlvbiAodHlwZSwgb3B0cykge1xyXG4gICAgICAgIHZhciBtb2RlbCA9IG5ldyBNb2RlbCh7fSk7XHJcbiAgICAgICAgLy8g5rKh5pyJaWTnmoTml7blgJnvvIznvLrlsJHnu5nkuIDkuKpVVUlE44CC5Yib5bu66IqC54K55oiW6ICF5Y+N5bqP5YiX5YyW55qE5pe25YCZIOiKgueCueeahElE5Y+W55qE5pivb3B0cy5pZFxyXG5cdFx0aWYgKCFvcHRzLmlkKSB7XHJcblx0XHRcdG9wdHMuaWQgPSB1dGlsLmdldFVVSUQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdHMuc3R5bGUgJiYgb3B0cy5zdHlsZS50ZXh0TGluZUhlaWdodCAhPT0gMCAmJiAhb3B0cy5zdHlsZS5yaWNoKSB7IC8vIzE3MFxyXG4gICAgICAgICAgICBvcHRzLnN0eWxlLnJpY2ggPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbW9kZWwuc2V0KENvbnN0YW50cy5FTEVNRU5UX1RZUEUsIHR5cGUpO1xyXG4gICAgICAgIC8vIOmYsuatoiBuZXcgZWwuY29uc3RydWN0b3IoeyBzdHlsZTogZWwuc3R5bGUsc2hhcGU6IGVsLnNoYXBlIH0pOyB6clV0aWwuY2xvbmXmiqXplJlcclxuICAgICAgICBpZiAob3B0cy5zdHlsZSAmJiBvcHRzLnN0eWxlLmhvc3QpIHtcclxuICAgICAgICAgICAgZGVsZXRlIG9wdHMuc3R5bGUuaG9zdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbW9kZWwuc2V0KENvbnN0YW50cy5PUFRJT05TLCB6clV0aWwuY2xvbmUob3B0cykpO1xyXG4gICAgICAgIGlmIChcImRyYWdnYWJsZVwiIGluIG9wdHMpIHtcclxuICAgICAgICAgICAgb3B0cy5pc2RyYWdnYWJsZSA9IG9wdHMuZHJhZ2dhYmxlO1xyXG4gICAgICAgICAgICBkZWxldGUgb3B0cy5kcmFnZ2FibGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb3B0cy56KSB7XHJcbiAgICAgICAgICAgIG9wdHMueiA9IDE7IC8v6IqC54K56buY6K6k5Li6Me+8jOe6v+autTA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChvcHRzLmhvdmVyQW5pbWF0aW9uKSkge1xyXG4gICAgICAgICAgICBvcHRzLmhvdmVyQW5pbWF0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChvcHRzLnNlbGVjdGFibGUpKSB7XHJcbiAgICAgICAgICAgIG9wdHMuc2VsZWN0YWJsZSA9IHRydWU7ICAvL+m7mOiupOWPr+S7pemAieS4rVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbW9kZWw7XHJcbiAgICB9XHJcblxyXG4gICAgZmxvd05vZGUuYWRkSG92ZXJBbmltYXRpb24gPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgdmFyIHNjYWxlID0genJVdGlsLmNsb25lKG5vZGUuc2NhbGUpIHx8IFsxLDFdO1xyXG4gICAgICAgIHZhciBvbkVtcGhhc2lzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZVRvKHtcclxuICAgICAgICAgICAgICAgIHNjYWxlOiBbc2NhbGVbMF0gKiAxLjEsIHNjYWxlWzFdICogMS4xXVxyXG4gICAgICAgICAgICB9LCA0MDAsICdlbGFzdGljT3V0Jyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgb25Ob3JtYWwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5hbmltYXRlVG8oe1xyXG4gICAgICAgICAgICAgICAgc2NhbGU6IHNjYWxlXHJcbiAgICAgICAgICAgIH0sIDQwMCwgJ2VsYXN0aWNPdXQnKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIG5vZGUub24oJ21vdXNlb3ZlcicsIG9uRW1waGFzaXMpXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBvbk5vcm1hbClcclxuICAgICAgICAgICAgLm9uKCdlbXBoYXNpcycsIG9uRW1waGFzaXMpXHJcbiAgICAgICAgICAgIC5vbignbm9ybWFsJywgb25Ob3JtYWwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBleHRlbmRcclxuICAgICAqIOaJqeWxleS4gOS4qiDoh6rlrprkuYnoioLngrksIOavlOWmgumSu+efs+W9ouetieOAglxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcHMudHlwZSDoh6rlrprkuYnnu5PoioLnmoTlkI3np7AgUGF0aCB0eXBlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcHMuaW5pdF0g5Yid5aeL5YyWIEluaXRpYWxpemVcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByb3BzLmJ1aWxkUGF0aCDov5vooYzmnoTlu7roioLngrkgT3ZlcndyaXRlIGJ1aWxkUGF0aCBtZXRob2RcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMuc3R5bGVdIOe8uuecgeagt+W8jyBFeHRlbmRlZCBkZWZhdWx0IHN0eWxlIGNvbmZpZ1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5zaGFwZV0g57y655yB6IqC54K55Y+C5pWwIEV4dGVuZGVkIGRlZmF1bHQgc2hhcGUgY29uZmlnXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBmbG93Tm9kZS5leHRlbmQgPSBmdW5jdGlvbiAoZGVmYXVsdHMpIHtcclxuICAgICAgICB2YXIgU3ViID0gZnVuY3Rpb24gKG9wdHMpIHtcclxuICAgICAgICAgICAgdGhpcy5tb2RlbCA9IGZsb3dOb2RlLmdlbk1vZGVsKGRlZmF1bHRzLnR5cGUsIG9wdHMpO1xyXG4gICAgICAgICAgICBQYXRoLmNhbGwodGhpcywgb3B0cyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVmYXVsdHMuc3R5bGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIEV4dGVuZCBkZWZhdWx0IHN0eWxlXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlLmV4dGVuZEZyb20oZGVmYXVsdHMuc3R5bGUsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRXh0ZW5kIGRlZmF1bHQgc2hhcGVcclxuICAgICAgICAgICAgdmFyIGRlZmF1bHRTaGFwZSA9IGRlZmF1bHRzLnNoYXBlO1xyXG4gICAgICAgICAgICBpZiAoZGVmYXVsdFNoYXBlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoYXBlID0gdGhpcy5zaGFwZSB8fCB7fTtcclxuICAgICAgICAgICAgICAgIHZhciB0aGlzU2hhcGUgPSB0aGlzLnNoYXBlO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0U2hhcGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzU2hhcGUuaGFzT3duUHJvcGVydHkobmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgZGVmYXVsdFNoYXBlLmhhc093blByb3BlcnR5KG5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNTaGFwZVtuYW1lXSA9IGRlZmF1bHRTaGFwZVtuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGRlZmF1bHRzLmluaXQgJiYgZGVmYXVsdHMuaW5pdC5jYWxsKHRoaXMsIG9wdHMpO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB6clV0aWwuaW5oZXJpdHMoU3ViLCBQYXRoKTtcclxuXHJcbiAgICAgICAgLy8gRklYTUUg5LiN6IO9IGV4dGVuZCBwb3NpdGlvbiwgcm90YXRpb24g562J5byV55So5a+56LGhXHJcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0cykge1xyXG4gICAgICAgICAgICAvLyBFeHRlbmRpbmcgcHJvdG90eXBlIHZhbHVlcyBhbmQgbWV0aG9kc1xyXG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gJ3N0eWxlJyAmJiBuYW1lICE9PSAnc2hhcGUnKSB7XHJcbiAgICAgICAgICAgICAgICBTdWIucHJvdG90eXBlW25hbWVdID0gZGVmYXVsdHNbbmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g6YeN5YaZc2V0U3R5bGVcclxuICAgICAgICBTdWIucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlLnNldChrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XHJcbiAgICAgICAgICAgIHpyVXRpbC5tZXJnZSh0aGlzLm1vZGVsLmdldChcIm9wdGlvbnMuc3R5bGVcIiksIGtleSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFN1YjtcclxuICAgIH07XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZsb3dOb2RlO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAY2ZnIHtBcnJheX0gcG9zaXRpb24g6IqC54K555qE5L2N572uLOe7n+S4gOS9v+eUqHBvc2l0aW9u6L+b6KGM5a6a5L2NW3gseV0gZWcuIFsxMDAsMTAwXVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2ZnIHtPYmplY3R9IHN0eWxlIOagt+W8j+WPguaVsFxyXG4gKiBAY2ZnIHtzdHJpbmd9IHN0eWxlLmZpbGw9IzAwMCDloavlhYXoibIgZWcuIzVDOUFEMyB8IHJnYigwLDIwMCwyNTUpIHwgcmdiYSgwLDIwMCwyNTUsMC42KSB8IHJlZCB8IGdyYWRpZW50IOazqO+8muWNleeLrOaWh+Wtl+S9v+eUqHRleHRGaWxsXHJcbiAqIEBjZmcge3N0cmluZ30gc3R5bGUuc3Ryb2tlPW51bGwg56yU55S76aKc6ImyIGVnLiM1QzlBRDMgfCByZ2IoMCwyMDAsMjU1KSB8IHJnYmEoMCwyMDAsMjU1LDAuNikgfCByZWQgfCBncmFkaWVudCDms6jvvJrljZXni6zmloflrZfkvb/nlKh0ZXh0U3Rva2VcclxuICogQGNmZyB7bnVtYmVyfSBzdHlsZS5saW5lV2lkdGg9MSDnrJTnlLvlrr3luqZcclxuICogQGNmZyB7QXJyYXl9IHN0eWxlLmxpbmVEYXNoPW51bGwg56yU55S755qE6Jma57q/6Ze06ZqU77yM5Y+C5pWw5Li65Lqk5pu/57uY5Yi257q/5q615ZKM6Ze06Led6ZW/5bqm55qE5pWw5a2XIOWPguingVtsaW5lRGFzaE9mZnNldF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCkgZWcuIGxpbmVEYXNoOls2LDEwXVxyXG4gKiBAY2ZnIHtudW1iZXJ9IHN0eWxlLmxpbmVEYXNoT2Zmc2V0PTAgIOeslOeUu+eahOiZmue6v+WBj+enu+mHjyDlj4Lop4FbbGluZURhc2hPZmZzZXRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvbGluZURhc2hPZmZzZXQpXHJcbiAqIEBjZmcge3N0cmluZ30gc3R5bGUudGV4dD1cIlwiIOiKgueCueS4iuaYvuekuueahOaWh+acrCzlj6/ku6Xkvb/nlKggXFxuIOadpeaNouihjFxyXG4gKiBAY2ZnIHtzdHJpbmd9IHN0eWxlLnRleHRGb250PScxMnB4IHNhbnMtc2VyaWYnIOWtl+S9k+Wkp+Wwj+OAgeWtl+S9k+exu+Wei+OAgeeyl+e7huOAgeWtl+S9k+agt+W8j+OAguagvOW8j+WPguingVtjc3MgZm9udF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZvbnQpIGVnLnRleHRGb250OiAnaXRhbGljIGJvbGRlciAxNHB4IE1pY3Jvc29mdCBZYUhlaSdcclxuICogQGNmZyB7c3RyaW5nfSBzdHlsZS5mb250U3R5bGU9bnVsbCDlrZfkvZPmoLflvI9cclxuICogQGNmZyB7c3RyaW5nfSBzdHlsZS5mb250V2VpZ2h0PSMwMDAg5a2X5L2T57KX57uGXHJcbiAqIEBjZmcge251bWJlcn0gc3R5bGUuZm9udFNpemU9bnVsbCDlrZfkvZPlpKflsI9cclxuICogQGNmZyB7c3RyaW5nfSBzdHlsZS5mb250RmFtaWx5PW51bGwg5a2X5L2T57G75Z6LXHJcbiAqIEBjZmcge3N0cmluZ30gc3R5bGUudGV4dEZpbGw9IzAwMCDoioLngrnkuIrmlofmnKznmoTloavlhYXoibIgZWcuIzVDOUFEMyB8IHJnYigwLDIwMCwyNTUpIHwgcmdiYSgwLDIwMCwyNTUsMC42KSB8IHJlZFxyXG4gKiBAY2ZnIHtzdHJpbmd9IHN0eWxlLnRleHRTdG9rZT1udWxsIOiKgueCueS4iuaWh+acrOeahOaPj+i+ueiJsiBlZy4jNUM5QUQzIHwgcmdiKDAsMjAwLDI1NSkgfCByZ2JhKDAsMjAwLDI1NSwwLjYpIHwgcmVkXHJcbiAqIEBjZmcge3N0cmluZ3xBcnJheX0gc3R5bGUudGV4dFBvc2l0aW9uPVwiXCIg5paH5pys5Zyo6IqC54K55Lit55qE5L2N572ubGVmdHxyaWdodHx0b3B8Ym90dG9tfGluc2lkZXxpbnNpZGVMZWZ0fGluc2lkZVJpZ2h0fGluc2lkZVRvcHxpbnNpZGVCb3R0b218aW5zaWRlVG9wTGVmdHxpbnNpZGVUb3BSaWdodHxpbnNpZGVCb3R0b21MZWZ0fGluc2lkZUJvdHRvbVJpZ2h0fFt4LHldfFslLCVdXHJcbiAqIEBjZmcge3N0cmluZ30gc3R5bGUudGV4dEJhc2VsaW5lPVwiYWxwaGFiZXRpY1wiIOW9k+WJjeaWh+acrOWfuue6v+eahOWxnuaApyBcInRvcFwiIHx8IFwiaGFuZ2luZ1wiIHx8IFwibWlkZGxlXCIgfHwgXCJhbHBoYWJldGljXCIgfHwgXCJpZGVvZ3JhcGhpY1wiIHx8IFwiYm90dG9tXCIg5Y+C6KeBW2NzcyBmb250XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3RleHRCYXNlbGluZSlcclxuICogQGNmZyB7QXJyYXl9IHN0eWxlLnRleHRPZmZzZXQ9bnVsbCDmlofmnKzlnKjoioLngrnnmoTlgY/np7vlgLxbeCx5XSBlZy4gWzEwLDEwXVxyXG4gKiBAY2ZnIHtzdHJpbmd9IHN0eWxlLnRleHRBbGlnbj1cIlwiIOaWh+acrOWcqOiKgueCueS4reeahOWvuem9kOaWueW8jyBsZWZ0IHwgY2VudGVyIHwgcmlnaHRcclxuICogQGNmZyB7c3RyaW5nfSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbj1udWxsIOaWh+acrOWcqOiKgueCueS4reeahOWeguebtOWvuem9kOaWueW8jyB0b3AgfCBtaWRkbGUgfCBib3R0b21cclxuICogQGNmZyB7bnVtYmVyfSBzdHlsZS50ZXh0RGlzdGFuY2U9NSDmloflrZfnmoTnm7jlr7l0ZXh0UG9z55qE5YGP56e76YePIGVnLiB0ZXh0UG9zaXRpb249J2xlZnQnIHRleHREaXN0YW5jZT01IOWImeaWh+Wtl+eahHjlnZDmoIfnmoTlgLzkuLogKGxlZnTnmoTlnZDmoId45YC8KSAtNVxyXG4gKiBAY2ZnIHtzdHJpbmd9IHN0eWxlLnRleHRTaGFkb3dDb2xvcj0ndHJhbnNwYXJlbnQnIOaWh+Wtl+mYtOW9seminOiJslxyXG4gKiBAY2ZnIHtudW1iZXJ9IHN0eWxlLnRleHRTaGFkb3dCbHVyPTAg5paH5pys6Zi05b2x5a695bqmIOWPguingVtzaGFkb3dCbHVyXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NoYWRvd0JsdXIpXHJcbiAqIEBjZmcge251bWJlcn0gc3R5bGUudGV4dFNoYWRvd09mZnNldFg9MCDmlofmnKzpmLTlvbEgWCDmlrnlkJHlgY/np7sg5Y+C6KeBc2hhZG93T2Zmc2V0WFtodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NoYWRvd09mZnNldFhdXHJcbiAqIEBjZmcge251bWJlcn0gc3R5bGUudGV4dFNoYWRvd09mZnNldFk9MCDmlofmnKzpmLTlvbEgWSDmlrnlkJHlgY/np7sg5Y+C6KeBc2hhZG93T2Zmc2V0WVtodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NoYWRvd09mZnNldFldXHJcbiAqIEBjZmcge251bWJlcn0gc3R5bGUudGV4dFJvdGF0aW9uPTAg5paH5pys5peL6L2s55qE6KeS5bqmXHJcbiAqIEBjZmcge251bWJlcn0gc3R5bGUudGV4dEJvcmRlcldpZHRoPTAg5paH5a2X5o+P6L655a695bqmXHJcbiAqIEBjZmcge3N0cmluZ30gc3R5bGUudGV4dEJvcmRlckNvbG9yPW51bGwg5paH5a2X5o+P6L656aKc6ImyXHJcbiAqIEBjZmcge251bWJlcn0gc3R5bGUudGV4dEJvcmRlclJhZGl1cz0wIOaWh+Wtl+aPj+i+ueWNiuW+hFxyXG4gKiBAY2ZnIHtzdHJpbmd8T2JqZWN0fSBzdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yPW51bGwg5paH5a2X6IOM5pmvKOminOiJsuaIluWbvueJhykgZWcuICcjMzMzJyB8IHtpbWFnZTonLi9hc3NldC9pbWcvY2x1bmQucG5nJ31cclxuICogQGNmZyB7bnVtYmVyfEFycmF5fSBzdHlsZS50ZXh0UGFkZGluZz1udWxsIOaWh+Wtl3BhZGRpbmcgIGVnLiBgMmAgb3IgYFsyLCA0XWAgb3IgYFsyLCAzLCA0LCA1XWBcclxuICogQGNmZyB7T2JqZWN0fSBzdHlsZS5yaWNoPW51bGwg5a+M5paH5pys5qC35byP5bGe5oCnXHJcbiAqIEBjZmcge251bWJlcn0gc3R5bGUudGV4dExpbmVIZWlnaHQ9MCDmloflrZfnmoTooYzpq5hcclxuICogQGNmZyB7bnVtYmVyfSBzdHlsZS5vcGFjaXR5PTEg5Zu+5b2i6YCP5piO5bqm44CC5pSv5oyB5LuOIDAg5YiwIDEg55qE5pWw5a2X77yM5Li6IDAg5pe25LiN57uY5Yi26K+l5Zu+5b2i44CCXHJcbiAqIEBjZmcge251bWJlcn0gc3R5bGUuc2hhZG93Qmx1cj0wIOmYtOW9seWuveW6piDlj4Lop4Fbc2hhZG93Qmx1cl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zaGFkb3dCbHVyKVxyXG4gKiBAY2ZnIHtudW1iZXJ9IHN0eWxlLnNoYWRvd09mZnNldFg9MCDpmLTlvbEgWCDmlrnlkJHlgY/np7sg5Y+C6KeBc2hhZG93T2Zmc2V0WFtodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NoYWRvd09mZnNldFhdXHJcbiAqIEBjZmcge251bWJlcn0gc3R5bGUuc2hhZG93T2Zmc2V0WT0wIOmYtOW9sSBZIOaWueWQkeWBj+enuyDlj4Lop4FzaGFkb3dPZmZzZXRZW2h0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2hhZG93T2Zmc2V0WV1cclxuICogQGNmZyB7c3RyaW5nfSBzdHlsZS5zaGFkb3dDb2xvcj0nIzAwMCcg6Zi05b2x6aKc6ImyIGVnLiM1QzlBRDMgfCByZ2IoMCwyMDAsMjU1KSB8IHJnYmEoMCwyMDAsMjU1LDAuNikgfCByZWQg5Y+C6KeBW3NoYWRvd0NvbG9yXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NoYWRvd0NvbG9yKVxyXG4gKiBAY2ZnIHtzdHJpbmd9IHN0eWxlLmltYWdlPVwiXCIg5Zu+54mH55qE6Lev5b6EIOeUqOS6jkltYWdlXHJcbiAqIEBjZmcge251bWJlcn0gc3R5bGUud2lkdGgg5Zu+54mH55qE5a695bqmIOeUqOS6jkltYWdlXHJcbiAqIEBjZmcge251bWJlcn0gc3R5bGUuaGVpZ2h0IOWbvueJh+eahOmrmOW6piDnlKjkuo5JbWFnZVxyXG4gKi9cclxuXHJcbiAvKipcclxuICogQGNmZyB7T2JqZWN0fSBob3ZlclN0eWxlIGhvdmVy5qC35byPLCDlj4LmlbDop4FzdHlsZVxyXG4gICovXHJcbiAvKipcclxuICogQGNmZyB7T2JqZWN0fSBzZWxlY3RTdHlsZSDpgInkuK3oioLngrnnmoTmoLflvI8sIOWPguaVsOingXN0eWxlOyAg6buY6K6k5piv5LiA5Liq6Jma55qE6L655qGGOyAg6K6+5Li656m65a+56LGh5YiZ5LiN5pi+56S66YCJ5Lit6L655qGGO1xyXG4qL1xyXG4vKipcclxuICogQGNmZyB7Qm9vbGVhbn0gZHJhZ2dhYmxlPXRydWUg5piv5ZCm5Y+v5Lul6KKr5ouW5ou944CCXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjZmcge0Jvb2xlYW59IGlnbm9yZT1mYWxzZSDmmK/lkKbpmpDol4/nirbmgIHvvIjlj6ror7vvvInvvIxmYXNsZTrpmpDol48sdHJ1ZTrkuI3pmpDol49cclxuICovXHJcblxyXG4vKipcclxuICogQGNmZyB7Qm9vbGVhbn0gc2VsZWN0YWJsZT10cnVlIOiKgueCueaYr+WQpuWPr+mAieS4re+8jOm7mOiupOaYr3RydWVcclxuICovXHJcblxyXG4vKipcclxuICogQGNmZyB7U3RyaW5nfSBpZCDkuLrkuobpgb/lhY3ph43lpI3vvIznm67liY3nlLHns7vnu5/oh6rliqjnlJ/miJDvvIzlpoLmnpzkuI3pnIDopoHnlKjlj6/ku6Xlv73nlaXjgILlu7rorq7kvb/nlKhubWFlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqICBAY2ZnIHtCb29sZWFufSBob3ZlckFuaW1hdGlvbj1mYWxzZSDmmK/lkKblvIDlkK8gaG92ZXIg5Zyo6IqC54K55LiK55qE5o+Q56S65Yqo55S75pWI5p6c44CC77yM6buY6K6k5pivZmFsc2VcclxuICovXHJcblxyXG4vKipcclxuICogQGNmZyB7U3RyaW5nfSBuYW1lIOaMh+WumuiKgueCueeahG5hbWUsIOWPr+S7peS9v+eUqGNoaWxkT2ZOYW1l562J5Ye95pWw5qC55o2ubmFtZeafpeaJvuiKgueCuVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2ZnIHtTdHJpbmd9IHRvb2x0aXAg6IqC54K555qEdG9vbHRpcCDlhoXlrrnlj6/ku6XljIXmi6xIVE1M5qCH562+XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjZmcge09iamVjdH0gcmVsYXRpdmUgcmVsYXRpdmXmj4/ov7DmgI7kuYjmoLnmja7niLblhYPntKDov5vooYzlrprkvY3vvIzorr7nva7kuoZyZWxhdGl2ZeWxnuaApyDlsLHkuI3pnIDopoHorr7nva5wb3NpdGlvbuOAguaUr+aMge+8mmxlZnTjgIFyaWdodOOAgXRvcOOAgWJvdHRvbVxyXG4gKiBAY2ZnIHtOdW1iZXJ8U3RyaW5nfSByZWxhdGl2ZS5sZWZ0ICDot53nprvniLblhYPntKDlt6bovrnnmoTkvY3nva7jgILlgLznmoTnsbvlnovlj6/ku6XmmK/vvJoxLm51bWJlcu+8muihqOekuuWDj+e0oOWAvO+8mzIu55m+5YiG5q+U5YC877ya5aaCICczMyUn77yM55So54i25YWD57Sg55qE6auY5ZKM5q2k55m+5YiG5q+U6K6h566X5Ye65pyA57uI5YC844CCMy4nY2VudGVyJ++8muihqOekuuiHquWKqOWxheS4reOAgjQubGVmdCDlkowgcmlnaHQg5Y+q5pyJ5LiA5Liq5Y+v5Lul55Sf5pWI44CCXHJcbiAqIEBjZmcge051bWJlcnxTdHJpbmd9IHJlbGF0aXZlLnJpZ2h0ICDot53nprvniLblhYPntKDlj7PovrnnmoTkvY3nva7jgILlgLznmoTnsbvlnovlj6/ku6XmmK/vvJoxLm51bWJlcu+8muihqOekuuWDj+e0oOWAvO+8mzIu55m+5YiG5q+U5YC877ya5aaCICczMyUn77yM55So54i25YWD57Sg55qE6auY5ZKM5q2k55m+5YiG5q+U6K6h566X5Ye65pyA57uI5YC844CCMy4nY2VudGVyJ++8muihqOekuuiHquWKqOWxheS4reOAgjQubGVmdCDlkowgcmlnaHQg5Y+q5pyJ5LiA5Liq5Y+v5Lul55Sf5pWI44CCXHJcbiAqIEBjZmcge051bWJlcnxTdHJpbmd9IHJlbGF0aXZlLnRvcCAg6Led56a754i25YWD57Sg6aG26YOo55qE5L2N572u44CC5YC855qE57G75Z6L5Y+v5Lul5piv77yaMS5udW1iZXLvvJrooajnpLrlg4/ntKDlgLzvvJsyLueZvuWIhuavlOWAvO+8muWmgiAnMzMlJ++8jOeUqOeItuWFg+e0oOeahOmrmOWSjOatpOeZvuWIhuavlOiuoeeul+WHuuacgOe7iOWAvOOAgjMuJ2NlbnRlcifvvJrooajnpLroh6rliqjlsYXkuK3jgII0LnRvcCDlkowgYm90dG9tIOWPquacieS4gOS4quWPr+S7peeUn+aViOOAglxyXG4gKiBAY2ZnIHtOdW1iZXJ8U3RyaW5nfSByZWxhdGl2ZS5ib3R0b20gIOi3neemu+eItuWFg+e0oOW6lemDqOeahOS9jee9ruOAguWAvOeahOexu+Wei+WPr+S7peaYr++8mjEubnVtYmVy77ya6KGo56S65YOP57Sg5YC877ybMi7nmb7liIbmr5TlgLzvvJrlpoIgJzMzJSfvvIznlKjniLblhYPntKDnmoTpq5jlkozmraTnmb7liIbmr5TorqHnrpflh7rmnIDnu4jlgLzjgIIzLidjZW50ZXIn77ya6KGo56S66Ieq5Yqo5bGF5Lit44CCNC50b3Ag5ZKMIGJvdHRvbSDlj6rmnInkuIDkuKrlj6/ku6XnlJ/mlYjjgIJcclxuICogQGNmZyB7U3RyaW5nfSBbYm91bmRpbmc9J2FsbCddIOWGs+WumuatpOWbvuW9ouWFg+e0oOWcqOWumuS9jeaXtu+8jOWvueiHqui6q+eahOWMheWbtOebkuiuoeeul+aWueW8j+OAgiAxLidhbGwn77ya77yI6buY6K6k77yJIOihqOekuueUqOiHqui6q+S7peWPiuWtkOiKgueCueaVtOS9k+eahOe7j+i/hyB0cmFuc2Zvcm0g5ZCO55qE5YyF5Zu055uS6L+b6KGM5a6a5L2N44CCIOi/meenjeaWueW8j+aYk+S6juS9v+aVtOS9k+mDvemZkOWItuWcqOeItuWFg+e0oOiMg+WbtOS4reOAgjIuJ3JhdyfvvJog6KGo56S65LuF5LuF55So6Ieq6Lqr77yI5LiN5YyF5ous5a2Q6IqC54K577yJ55qE5rKh57uP6L+HIHRyYW5mb3JtIOeahOWMheWbtOebkui/m+ihjOWumuS9jeOAgiDov5nnp43mlrnlvI/mmJPkuo7lhoXlrrnotoXlh7rniLblhYPntKDojIPlm7TnmoTlrprkvY3mlrnlvI/jgIJcclxuICovXHJcblxyXG4vKipcclxuICogQGNmZyB7QXJyYXl9IHNjYWxlIOiKgueCueeahOe8qeaUvuWboOWtkCwgW3gseV0g5rC05bmz5LiO5Z6C55u05pa55ZCR55qEIGVnLiBbMSwxXVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2ZnIHtudW1iZXJ9IHJvdGF0aW9uIOiKgueCueeahOaXi+i9rOWboOWtkCwg5Y2V5L2N5piv6KeS5bqmIGVnLiAwLjUqIE1hdGguUElcclxuICovXHJcblxyXG4vKipcclxuICogQGNmZyB7QXJyYXl9IG9yaWdpbiDml4vovazlkoznvKnmlL7nmoTljp/ngrksIFt4LHldIGVnLiBbNzUsNzVdXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjZmcge251bWJlcn0gej0wICB65pa55ZCR55qE6auY5bqm77yM5Yaz5a6a5bGC5Y+g5YWz57O744CC57G75Ly8Y3NzIHpJbmRleFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2ZnIHtudW1iZXJ9IHpsZXZlbD0wICDlhrPlrprmraTlhYPntKDnu5jliLblnKjlk6rkuKogY2FudmFzIOWxguS4reOAguazqOaEj++8jOi2iuWkmiBjYW52YXMg5bGC5Lya5Y2g55So6LaK5aSa6LWE5rqQ44CCXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjZmcge0Jvb2xlYW59IHNpbGVudD1mYWxzZSAg5piv5ZCm5LiN5ZON5bqU6byg5qCH5Lul5Y+K6Kem5pG45LqL5Lu244CCXHJcbiAqL1xyXG4vKipcclxuICogQGNmZyB7Qm9vbGVhbn0gaW52aXNpYmxlPWZhbHNlICDoioLngrnmmK/lkKblj6/op4HjgIJcclxuICovXHJcblxyXG4vKipcclxuICogQGNmZyB7T2JqZWN0fSBwYXJlbnQgIOiKgueCueeahOeItuWFg+e0oFxyXG4gKi9cclxuLyoqXHJcbiAqIEBjZmcge09iamVjdH0gb3BlcmF0aW9uSWNvbnMgIOiKgueCueaTjeS9nOS4uumAieS4reeahOiKgueCue+8jOaPkOS+m+m7mOiupOaTjeS9nOaIlueUqOaIt+iHquWumuS5ieaTjeS9nOOAglxyXG4gKiBAY2ZnIHtTdHJpbmd9IG9wZXJhdGlvbkljb25zLm5hbWUg6K6+572u6IqC54K55ZCN56ew77yM5Y+v6YCJ5YC85pyJY29uc3RhbnRzLkRFTCjliKDpmaQp77yMY29uc3RhbnRzLkxJTkvvvIjnm7Tnur/vvInvvIxjb25zdGFudHMuRk9MRO+8iOaKmOe6v++8ie+8jGNvbnN0YW50cy5DVVJWRSjmm7Lnur8p77yM5Lul5Y+K6Ieq5a6a5LmJ5ZCN56ewXHJcbiAqIEBjZmcge1N0cmluZ30gb3BlcmF0aW9uSWNvbnMuaWNvblBhdGgg6K6+572u6Ieq5a6a5LmJ6IqC54K55Zu+5qCH6Lev5b6EXHJcbiAqIEBjZmcge0Z1bmN0aW9ufSBvcGVyYXRpb25JY29ucy5jYWxsYmFjayDorr7nva7oioLngrnooqvngrnlh7vvvIhjbGlja++8ieeahOWbnuiwg+WHveaVsFxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIGltYWdlMSA9IG5ldyBub2RlLkltYWdlKHtcclxuICogICAgICAgICAgIHN0eWxlOiB7XHJcbiAqICAgICAgICAgICAgICAgaW1hZ2U6IFwiaW1nL2ltZy1jaWMvaWNvbi1zZW5kLXNtcy5zdmdcIixcclxuICogICAgICAgICAgICAgICB3aWR0aDoxMjAsXHJcbiAqICAgICAgICAgICAgICAgaGVpZ2h0OjcwLFxyXG4gKiAgICAgICAgICAgICAgIHRleHQ6XCLmk43kvZw657q/5q61XCIsXHJcbiAqICAgICAgICAgICAgICAgdGV4dFBvc2l0aW9uOlwiaW5zaWRlQm90dG9tXCJcclxuICogICAgICAgICAgIH0sXHJcbiAqICAgICAgICAgICBwb3NpdGlvbjpbNjAsNjBdLFxyXG4gKiAgICAgICAgICAgb3BlcmF0aW9uSWNvbnM6IFtcclxuICogICAgICAgICAgICAgICB7IG5hbWU6IGNvbnN0YW50cy5MSU5LfSAsXHJcbiAqICAgICAgICAgICAgICAgeyBuYW1lOiBjb25zdGFudHMuRk9MRCB9LFxyXG4gKiAgICAgICAgICAgICAgIHsgbmFtZTogY29uc3RhbnRzLkNVUlZFIH1cclxuICogICAgICAgICAgIF1cclxuICogICAgICAgfSk7XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBzdGF0ZXNcclxuICog55So5LqO6K6+572u6IqC54K555qE54q25oCBXHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gbW9kZWxcclxuICog6IqC54K555qE5qih5Z6L77yM55So5LqO5a2Y5YKo5bqP5YiX5YyW5pWw5o2uIOS7peWPiueUqOaIt+iHquWumuS5ieaVsOaNrlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGF0dHJcclxuICog6K6+572u6IqC54K55bGe5oCnXHJcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0ga2V5IOiuvue9rueahOWxnuaAp+OAguWPr+S7peaYryBzdHJpbmcg57G75Z6L55qE5bGe5oCn5ZCN56ew77yM5oiW6ICFIE9iamVjdCDnsbvlnovnmoTlsZ7mgKflj4rlhbblgLxcclxuICogQHBhcmFtIHsqfSDlsZ7mgKflgLxcclxuICogKirkvb/nlKjojIPkvosqKlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBub2RlLmF0dHIoJ3Bvc2l0aW9uJywgWzEwMCwgMjAwXSk7XHJcbiAqIG5vZGUuYXR0cih7XHJcbiAqICAgICBzdHlsZToge1xyXG4gKiAgICAgICAgIGZpbGw6ICdyZWQnXHJcbiAqICAgICB9LFxyXG4gKiAgICAgc2hhcGU6IHtcclxuICogICAgICAgICB4OiAxMDBcclxuICogICAgIH1cclxuICogfSk7XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgc2V0U3R5bGVcclxuICog5Yib5bu66IqC54K55ZCO77yM6K6+572u6IqC54K555qE5qC35byP77yIc3R5bGXlsZ7mgKfvvIlcclxuICogQHBhcmFtIHtTdHJpbmd9IGtleSDplK7lkI1cclxuICogQHBhcmFtIHsqfSB2YWx1ZSDplK7lgLxcclxuICogQHJldHVybiB7T2JqZWN0fSDov5Tlm57oioLngrnlr7nosaHoh6rouqtcclxuICovXHJcblxyXG4vKipcclxuICogQG1ldGhvZCBzZXRTaGFwZVxyXG4gKiDliJvlu7roioLngrnlkI7vvIzorr7nva7oioLngrnnmoTlvaLnirbvvIhzaGFwZeWxnuaAp++8iVxyXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IOmUruWQjVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIOmUruWAvFxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IOi/lOWbnuiKgueCueWvueixoeiHqui6q1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGhpZGVcclxuICog6ZqQ6JeP6IqC54K5XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgc2hvd1xyXG4gKiDmmL7npLroioLngrlcclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgb25cclxuICog57uR5a6a5LqL5Lu2XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCDkuovku7blkI1cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDkuovku7blpITnkIblh73mlbBcclxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSDkuIrkuIvmlodcclxuICovXHJcblxyXG4vKipcclxuICogQG1ldGhvZCBvZmZcclxuICog6Kej57uR5LqL5Lu2XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCDkuovku7blkI1cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDkuovku7blpITnkIblh73mlbBcclxuICovXHJcblxyXG4vKipcclxuICogQG1ldGhvZCBvbmVcclxuICog5Y2V5qyh6Kem5Y+R57uR5a6aLHRyaWdnZXLlkI7plIDmr4FcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOS6i+S7tuWkhOeQhuWHveaVsFxyXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIOS4iuS4i+aWh1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIHRyaWdnZXJcclxuICog5LqL5Lu25YiG5Y+RXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGlzU2lsZW50XHJcbiAqIOaYr+WQpue7keWumuS6huS6i+S7tlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQg5LqL5Lu25ZCNXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgYW5pbWF0ZVxyXG4gKiDliqjnlLtcclxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGgg6ZyA6KaB5re75Yqg5Yqo55S755qE5bGe5oCn6I635Y+W6Lev5b6E77yM5Y+v5Lul6YCa6L+HYS5iLmPmnaXojrflj5bmt7HlsYLnmoTlsZ7mgKdcclxuICogQHBhcmFtIHtCb29sZWFufSBbbG9vcF0g5Yqo55S75piv5ZCm5b6q546vXHJcbiAqIEByZXR1cm4ge09iamVjdH0g6L+U5ZueQW5pbWF0b3Llr7nosaFcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgZWwuYW5pbWF0ZSgnc3R5bGUnLCBmYWxzZSlcclxuICogICAgICAgICAud2hlbigxMDAwLCB7eDogMTB9IClcclxuICogICAgICAgICAuZG9uZShmdW5jdGlvbigpeyAvLyBBbmltYXRpb24gZG9uZSB9KVxyXG4gKiAgICAgICAgIC5zdGFydCgpXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgc3RvcEFuaW1hdGlvblxyXG4gKiDlgZzmraLliqjnlLtcclxuICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkVG9MYXN0IOaYr+WQpuWcqOWBnOatouWJjeenu+WKqOWIsOacgOWQjuS4gOW4p1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGFuaW1hdGVUb1xyXG4gKiDku47kuIDliqjlsZ7mgKfov4fmuKHliLDlj6bkuIDnp43lsZ7mgKfnmoTliqjnlLtcclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCDnm67liY3lsZ7mgKdcclxuICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lPTUwMF0g5Yqo55S75pe26Ze0IOWNleS9jW1zXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZWFzaW5nPSdsaW5lYXInXSDliqjnlLvlh73mlbAg5Y+C6KeBW+e8k+WKqOekuuS+i10oaHR0cDovL2VjaGFydHMuYmFpZHUuY29tL2dhbGxlcnkvZWRpdG9yLmh0bWw/Yz1saW5lLWVhc2luZylcclxuICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXSDlu7bml7bml7bpl7RcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSDliqjnlLvnu5PmnZ/lm57osINcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgICAgIC8vIEFuaW1hdGUgcG9zaXRpb25cclxuICogICAgICAgICAgZWwuYW5pbWF0ZVRvKHtcclxuICogICAgICAgICAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxyXG4gKiAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IC8vIGRvbmUgfSlcclxuICpcclxuICogICAgICAgICAgLy8gQW5pbWF0ZSBzaGFwZSwgc3R5bGUgYW5kIHBvc2l0aW9uIGluIDEwMG1zLCBkZWxheWVkIDEwMG1zLCB3aXRoIGN1YmljT3V0IGVhc2luZ1xyXG4gKiAgICAgICAgICBlbC5hbmltYXRlVG8oe1xyXG4gKiAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICogICAgICAgICAgICAgICAgICB3aWR0aDogNTAwXHJcbiAqICAgICAgICAgICAgICB9LFxyXG4gKiAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICogICAgICAgICAgICAgICAgICBmaWxsOiAncmVkJ1xyXG4gKiAgICAgICAgICAgICAgfVxyXG4gKiAgICAgICAgICAgICAgcG9zaXRpb246IFsxMCwgMTBdXHJcbiAqICAgICAgICAgIH0sIDEwMCwgMTAwLCAnY3ViaWNPdXQnLCBmdW5jdGlvbiAoKSB7IC8vIGRvbmUgfSlcclxuICovXHJcblxyXG4vKipcclxuICogQGV2ZW50IGNsaWNrXHJcbiAqIOWNleWHu+S6i+S7tlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YXJnZXQg55uu5qCH5a+56LGhXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5ldmVudCDlrp7pmYXnmoTmtY/op4jlmajkuovku7blr7nosaFcclxuICogPHByZT5cclxuICogbm9kZS5vbignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xyXG4gKiAgIC8vZG8gc29tZXRoaW5nXHJcbiAqIH0pXHJcbiAqIDwvcHJlPlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgZGJsY2xpY2tcclxuICog5b2T5Y+M5Ye75YWD57Sg5pe277yM5Lya5Y+R55SfIGRibGNsaWNrIOS6i+S7tuOAglxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YXJnZXQg55uu5qCH5a+56LGhXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5ldmVudCDlrp7pmYXnmoTmtY/op4jlmajkuovku7blr7nosaFcclxuICogPHByZT5cclxuICogbm9kZS5vbignZGJsY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xyXG4gKiAgIC8vZG8gc29tZXRoaW5nXHJcbiAqIH0pXHJcbiAqIDwvcHJlPlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgbW91c2VvdmVyXHJcbiAqIOW9k+m8oOagh+aMh+mSiOS9jeS6juWFg+e0oOS4iuaWueaXtu+8jOS8muWPkeeUnyBtb3VzZW92ZXIg5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhcmdldCDnm67moIflr7nosaFcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmV2ZW50IOWunumZheeahOa1j+iniOWZqOS6i+S7tuWvueixoVxyXG4gKiA8cHJlPlxyXG4gKiBub2RlLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihldmVudCkge1xyXG4gKiAgIC8vZG8gc29tZXRoaW5nXHJcbiAqIH0pXHJcbiAqIDwvcHJlPlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgbW91c2VvdXRcclxuICog5b2T6byg5qCH5oyH6ZKI5LuO5YWD57Sg5LiK56e75byA5pe277yM5Y+R55SfIG1vdXNlb3V0IOS6i+S7tuOAglxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YXJnZXQg55uu5qCH5a+56LGhXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5ldmVudCDlrp7pmYXnmoTmtY/op4jlmajkuovku7blr7nosaFcclxuICogPHByZT5cclxuICogbm9kZS5vbignbW91c2VvdXQnLCBmdW5jdGlvbihldmVudCkge1xyXG4gKiAgIC8vZG8gc29tZXRoaW5nXHJcbiAqIH0pXHJcbiAqIDwvcHJlPlxyXG4gKi9cclxuXHJcblxyXG4vKipcclxuICogQGV2ZW50IG1vdXNlbW92ZVxyXG4gKiDlvZPpvKDmoIfmjIfpkojlnKjmjIflrprnmoTlhYPntKDkuK3np7vliqjml7bvvIzlsLHkvJrlj5HnlJ8gbW91c2Vtb3ZlIOS6i+S7tlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YXJnZXQg55uu5qCH5a+56LGhXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5ldmVudCDlrp7pmYXnmoTmtY/op4jlmajkuovku7blr7nosaFcclxuICogPHByZT5cclxuICogbm9kZS5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICogICAvL2RvIHNvbWV0aGluZ1xyXG4gKiB9KVxyXG4gKiA8L3ByZT5cclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBldmVudCBtb3VzZXdoZWVsXHJcbiAqIOW9k+eUqOaIt+WcqOaMh+WumueahOWFg+e0oOaXtua7muWKqOm8oOagh+a7kei9ruaXtizlsLHkvJrlj5HnlJ8gbW91c2V3aGVlbOS6i+S7tlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YXJnZXQg55uu5qCH5a+56LGhXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5ldmVudCDlrp7pmYXnmoTmtY/op4jlmajkuovku7blr7nosaFcclxuICogPHByZT5cclxuICogbm9kZS5vbignbW91c2V3aGVlbCcsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAqICAgLy9kbyBzb21ldGhpbmdcclxuICogfSlcclxuICogPC9wcmU+XHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgbW91c2Vkb3duXHJcbiAqIOW9k+m8oOagh+aMh+mSiOenu+WKqOWIsOWFg+e0oOS4iuaWue+8jOW5tuaMieS4i+m8oOagh+aMiemUruaXtu+8jOS8muWPkeeUnyBtb3VzZWRvd24g5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhcmdldCDnm67moIflr7nosaFcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmV2ZW50IOWunumZheeahOa1j+iniOWZqOS6i+S7tuWvueixoVxyXG4gKiA8cHJlPlxyXG4gKiBub2RlLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbihldmVudCkge1xyXG4gKiAgIC8vZG8gc29tZXRoaW5nXHJcbiAqIH0pXHJcbiAqIDwvcHJlPlxyXG4gKi9cclxuXHJcblxyXG4vKipcclxuICogQGV2ZW50IG1vdXNldXBcclxuICog5b2T5Zyo5YWD57Sg5LiK5pS+5p2+6byg5qCH5oyJ6ZKu5pe277yM5Lya5Y+R55SfIG1vdXNldXAg5LqL5Lu244CCXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhcmdldCDnm67moIflr7nosaFcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmV2ZW50IOWunumZheeahOa1j+iniOWZqOS6i+S7tuWvueixoVxyXG4gKiA8cHJlPlxyXG4gKiBub2RlLm9uKCdtb3VzZXVwJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICogICAvL2RvIHNvbWV0aGluZ1xyXG4gKiB9KVxyXG4gKiA8L3ByZT5cclxuICovXHJcblxyXG4vKipcclxuICogQGV2ZW50IGNvbnRleHRtZW51XHJcbiAqIOW9k+WcqOWFg+e0oOS4iueCueWHu+m8oOagh+WPs+mUruaXtu+8jOS8muWPkeeUnyBjb250ZXh0bWVudSDkuovku7bjgIJcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudGFyZ2V0IOebruagh+WvueixoVxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZXZlbnQg5a6e6ZmF55qE5rWP6KeI5Zmo5LqL5Lu25a+56LGh77yM5aaC5p6c5oOz6Zi75q2i6buY6K6k55qE5rWP6KeI5Zmo5Y+z6ZSu6I+c5Y2V6K+35L2/55SoIGV2ZW50LmV2ZW50LnByZXZlbnREZWZhdWx0KCk7IGV2ZW50LmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICogPHByZT5cclxuICogbm9kZS5vbignY29udGV4dG1lbnUnLCBmdW5jdGlvbihldmVudCkge1xyXG4gKiAgIC8vZG8gc29tZXRoaW5nXHJcbiAqIH0pXHJcbiAqIDwvcHJlPlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgZHJhZ3N0YXJ0XHJcbiAqIOW9k+W8gOWni+aLluWKqOiKgueCueeahOaXtuWAme+8jOS8muWPkeeUnyBkcmFnc3RhcnQg5LqL5Lu244CCXHJcbiAqXHJcbiAqIDxwcmU+XHJcbiAqIG5vZGUub24oJ2RyYWdzdGFydCcsIGZ1bmN0aW9uKGUpIHtcclxuICogICAvL2RvIHNvbWV0aGluZ1xyXG4gKiB9KVxyXG4gKiA8L3ByZT5cclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBldmVudCBkcmFnXHJcbiAqIOW9k+aLluWKqOiKgueCueeahOaXtuWAme+8jOS8muWPkeeUnyBkcmFnIOS6i+S7tuOAglxyXG4gKlxyXG4gKiA8cHJlPlxyXG4gKiBub2RlLm9uKCdkcmFnJywgZnVuY3Rpb24oZSkge1xyXG4gKiAgIC8vZG8gc29tZXRoaW5nXHJcbiAqIH0pXHJcbiAqIDwvcHJlPlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgZHJhZ2VuZFxyXG4gKiDlvZPmi5bliqjoioLngrnnu5PmnZ/nmoTml7blgJnvvIzkvJrlj5HnlJ8gZHJhZ2VuZCDkuovku7bjgIJcclxuICpcclxuICogPHByZT5cclxuICogbm9kZS5vbignZHJhZ2VuZCcsIGZ1bmN0aW9uKGUpIHtcclxuICogICAvL2RvIHNvbWV0aGluZ1xyXG4gKiB9KVxyXG4gKiA8L3ByZT5cclxuICovXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL2Zsb3dOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog55+p5b2iPGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93Lm5vZGUuUmVjdFxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gKiAgICAgICB2YXIgcmVjdCA9IG5ldyBub2RlLlJlY3Qoe1xyXG4gKiAgICAgICAgICAgc2hhcGU6e3dpZHRoOjEwMCxoZWlnaHQ6NjB9LFxyXG4gKiAgICAgICAgICAgcG9zaXRpb246WzIwLDIwXVxyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgZmlzaFRvcG8uYWRkKHJlY3QpO1xyXG4gKi9cclxuXHJcbiAgICB2YXIgcm91bmRSZWN0SGVscGVyID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcm91bmRSZWN0Jyk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Zsb3dOb2RlJykuZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgdHlwZTogJ1JlY3QnLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gc2hhcGUg5b2i54q25Y+C5pWwXHJcbiAgICAgICAgICogQGNmZyB7QXJyYXl9IHNoYXBlLnBvaW50cz1udWxsIOaLhue6v+eCueeahOWdkOaghyDlj6/ku6Xku45BSeS4reiOt+WPluOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcnxTdHJpbmd8Qm9vbGVhbn0gW3NoYXBlLnNtb290aD1mYWxzZV0g5piv5ZCm5bmz5ruR5puy57q/5pi+56S644CC5aaC5p6c5Li6IG51bWJlcu+8muihqOekuui0neWhnuWwlCAoYmV6aWVyKSDlt67lgLzlubPmu5HvvIxzbW9vdGgg5oyH5a6a5LqG5bmz5ruR562J57qn77yM6IyD5Zu0IFswLCAxXTvlpoLmnpzkuLogJ3NwbGluZSfvvJrooajnpLogQ2F0bXVsbC1Sb20gc3BsaW5lIOW3ruWAvOW5s+a7kVxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUuc21vb3RoQ29uc3RyYWludD1udWxsIOaYr+WQpuWwhuW5s+a7keabsue6v+e6puadn+WcqOWMheWbtOebkuS4reOAgnNtb290aCDkuLogbnVtYmVy77yIYmV6aWVy77yJ5pe255Sf5pWIXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgLy8g5bem5LiK44CB5Y+z5LiK44CB5Y+z5LiL44CB5bem5LiL6KeS55qE5Y2K5b6E5L6d5qyh5Li6cjHjgIFyMuOAgXIz44CBcjRcclxuICAgICAgICAgICAgLy8gcue8qeWGmeS4ujEgICAgICAgICDnm7jlvZPkuo4gWzEsIDEsIDEsIDFdXHJcbiAgICAgICAgICAgIC8vIHLnvKnlhpnkuLpbMV0gICAgICAg55u45b2T5LqOIFsxLCAxLCAxLCAxXVxyXG4gICAgICAgICAgICAvLyBy57yp5YaZ5Li6WzEsIDJdICAgIOebuOW9k+S6jiBbMSwgMiwgMSwgMl1cclxuICAgICAgICAgICAgLy8gcue8qeWGmeS4ulsxLCAyLCAzXSDnm7jlvZPkuo4gWzEsIDIsIDMsIDJdXHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgIHI6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiA1MCxcclxuICAgICAgICAgICAgaGVpZ2h0OiA1MFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHggPSAwO1xyXG4gICAgICAgICAgICB2YXIgeSA9IDA7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xyXG4gICAgICAgICAgICBpZiAoIXNoYXBlLnIpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcm91bmRSZWN0SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1cGRhdGVTaGFwZTogZnVuY3Rpb24gKHJhdGlvLCBpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZVJhdGlvID0gTnVtYmVyKHJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcclxuICAgICAgICAgICAgdmFyIG5ld1cgPSBOdW1iZXIoc2hhcGUud2lkdGggKiBzY2FsZVJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIG5ld0ggPSBOdW1iZXIobmV3VyAqIHNoYXBlLmhlaWdodCAvIHNoYXBlLndpZHRoKTtcclxuICAgICAgICAgICAgaWYgKGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgICAgIG5ld1cgPSBwYXJzZUludChuZXdXLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBuZXdIID0gcGFyc2VJbnQobmV3SCwgMTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOaMieavlOS+i+e8qeaUvlxyXG4gICAgICAgICAgICB0aGlzLnNldFNoYXBlKHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBuZXdXLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBuZXdIXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1JlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxyXG4gKiDlnIblvaI8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubm9kZS5DaXJjbGVcclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93Lm5vZGVcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgIHZhciBub2RlID0gZmlzaFRvcG9GbG93Lm5vZGU7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSwge3JvYW06ZmFsc2V9KTtcclxuICogICAgICAgdmFyIGNpcmNsZSA9IG5ldyBub2RlLkNpcmNsZSh7XHJcbiAqICAgICAgICAgICBzaGFwZTp7cjoyNH0sXHJcbiAqICAgICAgICAgICBwb3NpdGlvbjpbNjAsNjBdXHJcbiAqICAgICAgIH0pO1xyXG4gKiAgICAgICBmaXNoVG9wby5hZGQoY2lyY2xlKTtcclxuICovXHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Zsb3dOb2RlJykuZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgdHlwZTogJ0NpcmNsZScsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBzaGFwZSDlvaLnirblj4LmlbBcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLnI9MjAg5Y2K5b6E44CCXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgcjogMjBcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBidWlsZFBhdGggOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSwgaW5CdW5kbGUpIHtcclxuICAgICAgICAgICAgLy8gQmV0dGVyIHN0cm9raW5nIGluIFNoYXBlQnVuZGxlXHJcbiAgICAgICAgICAgIC8vIEFsd2F5cyBkbyBpdCBtYXkgaGF2ZSBwZXJmb3JtZW5jZSBpc3N1ZSAoIGZpbGwgbWF5IGJlIDJ4IG1vcmUgY29zdClcclxuICAgICAgICAgICAgaWYgKGluQnVuZGxlKSB7XHJcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHNoYXBlLnIsIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEJldHRlciBzdHJva2luZyBpbiBTaGFwZUJ1bmRsZVxyXG4gICAgICAgICAgICAvLyBjdHgubW92ZVRvKHNoYXBlLmN4ICsgc2hhcGUuciwgc2hhcGUuY3kpO1xyXG4gICAgICAgICAgICBjdHguYXJjKDAsIDAsIHNoYXBlLnIsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZVNoYXBlOiBmdW5jdGlvbiAocmF0aW8sIGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgdmFyIHNjYWxlUmF0aW8gPSBOdW1iZXIocmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xyXG4gICAgICAgICAgICB2YXIgbmV3UiA9IE51bWJlcihzaGFwZS5yICogc2NhbGVSYXRpbyk7XHJcbiAgICAgICAgICAgIGlmIChpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdSID0gcGFyc2VJbnQobmV3UiwgMTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOaMieavlOS+i+e8qeaUvlxyXG4gICAgICAgICAgICB0aGlzLnNldFNoYXBlKHtcclxuICAgICAgICAgICAgICAgIHI6IG5ld1JcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBleHRlbmRcclxuICogQGhpZGVcclxuICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvQ2lyY2xlLmpzXG4vLyBtb2R1bGUgaWQgPSA5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog5Zu+54mH6IqC54K5PGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93Lm5vZGUuSW1hZ2VcclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93Lm5vZGVcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgIHZhciBub2RlID0gZmlzaFRvcG9GbG93Lm5vZGU7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSwge3JvYW06ZmFsc2V9KTtcclxuICogICAgICAgdmFyIGltYWdlID0gbmV3IG5vZGUuSW1hZ2Uoe1xyXG4gKiAgICAgICAgICAgc3R5bGU6IHtcclxuICogICAgICAgICAgICAgICBpbWFnZTogXCIuLi8uLi9leGFtcGxlcy9mbG93L2ltZy9pbWctY2ljL3N0YXJ0LnN2Z1wiLFxyXG4gKiAgICAgICAgICAgICAgIHdpZHRoOjEyMCxcclxuICogICAgICAgICAgICAgICBoZWlnaHQ6NzAsXHJcbiAqICAgICAgICAgICAgICAgdGV4dDpcIkV2ZW50IE5hbWVcIlxyXG4gKiAgICAgICAgICAgfSxcclxuICogICAgICAgICAgIHBvc2l0aW9uOls2MCw2MF1cclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChpbWFnZSk7XHJcbiAqL1xyXG5cclxuXHJcbiAgICB2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL0Rpc3BsYXlhYmxlJyk7XHJcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QnKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBmbG93Tm9kZSA9IHJlcXVpcmUoJy4vZmxvd05vZGUnKTtcclxuICAgIHZhciBMUlUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0xSVScpO1xyXG4gICAgdmFyIGdsb2JhbEltYWdlQ2FjaGUgPSBuZXcgTFJVKDUwKTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gWkltYWdlKG9wdHMpIHtcclxuICAgICAgICB0aGlzLm1vZGVsID0gZmxvd05vZGUuZ2VuTW9kZWwoXCJJbWFnZVwiLCBvcHRzKTtcclxuICAgICAgICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xyXG5cclxuICAgICAgICBpZiAod2luZG93LmpRdWVyeSkgeyAgIC8v5Yik5patalF1ZXJ55piv5ZCm5a2Y5ZyoXHJcbiAgICAgICAgICAgIHRoaXMucmVzdWx0RGVmZXJyZCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHRoaXMucmVzdWx0RGVmZXJyZC5wcm9taXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIFpJbWFnZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBaSW1hZ2UsXHJcblxyXG4gICAgICAgIHR5cGU6ICdJbWFnZScsXHJcblxyXG4gICAgICAgIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHtcclxuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcclxuICAgICAgICAgICAgdmFyIHNyYyA9IHN0eWxlLmltYWdlO1xyXG4gICAgICAgICAgICB2YXIgaW1hZ2U7XHJcblxyXG4gICAgICAgICAgICAvLyBNdXN0IGJpbmQgZWFjaCB0aW1lXHJcbiAgICAgICAgICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xyXG4gICAgICAgICAgICAvLyBzdHlsZS5pbWFnZSBpcyBhIHVybCBzdHJpbmdcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBpbWFnZSA9IHRoaXMuX2ltYWdlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGltYWdlICYmIGltYWdlLnNyYyAhPT0gc3JjKSB7IC8vIzE3MVxyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBzdHlsZS5pbWFnZSBpcyBhbiBIVE1MSW1hZ2VFbGVtZW50IG9yIEhUTUxDYW52YXNFbGVtZW50IG9yIENhbnZhc1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGltYWdlID0gc3JjO1xyXG4gICAgICAgICAgICAgICAgaW1hZ2UuaXNMb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEZJWE1FIENhc2UgY3JlYXRlIG1hbnkgaW1hZ2VzIHdpdGggc3JjXHJcbiAgICAgICAgICAgIGlmICghaW1hZ2UgJiYgc3JjKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUcnkgZ2V0IGZyb20gZ2xvYmFsIGltYWdlIGNhY2hlXHJcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkSW1nT2JqID0gZ2xvYmFsSW1hZ2VDYWNoZS5nZXQoc3JjKTtcclxuICAgICAgICAgICAgICAgIGlmICghY2FjaGVkSW1nT2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGltYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZS5pc0xvYWRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UuaXNMb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5vbmxvYWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhY2hlZEltZ09iai5wZW5kaW5nLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWRJbWdPYmoucGVuZGluZ1tpXS5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZWRJbWdPYmogPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZzogW3RoaXNdXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZS5zcmMgPSBzcmM7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsSW1hZ2VDYWNoZS5wdXQoc3JjLCBjYWNoZWRJbWdPYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlID0gaW1hZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2UgPSBjYWNoZWRJbWdPYmouaW1hZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW1hZ2UgPSBpbWFnZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJbWFnZSBpcyBub3QgY29tcGxldGUgZmluaXNoLCBhZGQgdG8gcGVuZGluZyBsaXN0ICDlpoLmnpzkvb/nlKjnmoRzdmflm77niYcsIElFMTHkuIvlsLHnrpfliqDovb3miJDlip9pbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h05Lmf6YO95piv5Li6MFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoIWltYWdlLndpZHRoIHx8ICFpbWFnZS5oZWlnaHQpICYmICghaW1hZ2Uuc3JjLmVuZHNXaXRoKFwic3ZnXCIpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWRJbWdPYmoucGVuZGluZy5wdXNoKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgIC8vIOWbvueJh+W3sue7j+WKoOi9veWujOaIkFxyXG4gICAgICAgICAgICAgICAgLy8gaWYgKGltYWdlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT0gJ0lNRycpIHtcclxuICAgICAgICAgICAgICAgIC8vICAgICBpZiAoIWltYWdlLmNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgICAgICAvLyBFbHNlIGlzIGNhbnZhc1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB4ID0gc3R5bGUueCB8fCAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSBzdHlsZS55IHx8IDA7XHJcbiAgICAgICAgICAgICAgICAvLyDlpoLmnpzkvb/nlKjnmoRzdmflm77niYcsIElFMTHkuIvlsLHnrpfliqDovb3miJDlip9pbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h05Lmf6YO95piv5Li6MFxyXG4gICAgICAgICAgICAgICAgLy/mraTlpITlpoLkuI3ms6jph4osIOS8muWvvOiHtElFMTHkuItzdmflm77niYfml6Dms5Xkvb/nlKhcclxuICAgICAgICAgICAgICAgIC8vIOWbvueJh+WKoOi9veWksei0pVxyXG4gICAgICAgICAgICAgICAgLy8gaWYgKCFpbWFnZS53aWR0aCB8fCAhaW1hZ2UuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpbWFnZS5pc0xvYWRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cualF1ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0RGVmZXJyZC5yZWplY3QoaW1hZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gc3R5bGUud2lkdGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc3R5bGUuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGFzcGVjdCA9IGltYWdlLndpZHRoIC8gaW1hZ2UuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoID09IG51bGwgJiYgaGVpZ2h0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIGltYWdlL2hlaWdodCByYXRpb1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGVpZ2h0ID09IG51bGwgJiYgd2lkdGggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAod2lkdGggPT0gbnVsbCAmJiBoZWlnaHQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gaW1hZ2Uud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIOiuvue9rnRyYW5zZm9ybVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuc1dpZHRoICYmIHN0eWxlLnNIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ggPSBzdHlsZS5zeCB8fCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzeSA9IHN0eWxlLnN5IHx8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN4LCBzeSwgc3R5bGUuc1dpZHRoLCBzdHlsZS5zSGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4LCB5LCB3aWR0aCwgaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0eWxlLnN4ICYmIHN0eWxlLnN5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN4MiA9IHN0eWxlLnN4O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzeTIgPSBzdHlsZS5zeTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc1dpZHRoID0gd2lkdGggLSBzeDI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNIZWlnaHQgPSBoZWlnaHQgLSBzeTI7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN4Miwgc3kyLCBzV2lkdGgsIHNIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsIHksIHdpZHRoLCBoZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyDlpoLmnpzmsqHorr7nva7lrr3lkozpq5jnmoTor53oh6rliqjmoLnmja7lm77niYflrr3pq5jorr7nva5cclxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS53aWR0aCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5oZWlnaHQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEcmF3IHJlY3QgdGV4dFxyXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KGN0eCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LmpRdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0RGVmZXJyZC5yZXNvbHZlKGltYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xyXG4gICAgICAgICAgICBpZiAoISB0aGlzLl9yZWN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWN0ID0gbmV3IEJvdW5kaW5nUmVjdChcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZS54IHx8IDAsIHN0eWxlLnkgfHwgMCwgc3R5bGUud2lkdGggfHwgMCwgc3R5bGUuaGVpZ2h0IHx8IDBcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY3Q7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1cGRhdGVTaGFwZTogZnVuY3Rpb24gKHJhdGlvLCBpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZVJhdGlvID0gTnVtYmVyKHJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcclxuICAgICAgICAgICAgdmFyIG5ld1cgPSBOdW1iZXIoc3R5bGUud2lkdGggKiBzY2FsZVJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIG5ld0ggPSBOdW1iZXIobmV3VyAqIHN0eWxlLmhlaWdodCAvIHN0eWxlLndpZHRoKTtcclxuICAgICAgICAgICAgaWYgKGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgICAgIG5ld1cgPSBwYXJzZUludChuZXdXLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBuZXdIID0gcGFyc2VJbnQobmV3SCwgMTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOaMieavlOS+i+e8qeaUvlxyXG4gICAgICAgICAgICB0aGlzLnNldFN0eWxlKHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBuZXdXLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBuZXdIXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgenJVdGlsLmluaGVyaXRzKFpJbWFnZSwgRGlzcGxheWFibGUpO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gWkltYWdlO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0ltYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSA5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog5paH5pysPGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93Lm5vZGUuVGV4dFxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpKTtcclxuICogICAgICAgdmFyIHRleHQgPSBuZXcgbm9kZS5UZXh0KHtcclxuICogICAgICAgICAgIHN0eWxlOnt0ZXh0Olwi5paH5pys5Lmf5Y+v5Lul5L2c5Li654us56uL55qE6IqC54K56L+b6KGM5ouW5ou9XCIsZmlsbDpcIiNmZjAwMDBcIiwgdGV4dEZvbnQ6XCIxNnB4IE1pY3Jvc29mdCBZYUhlaVwifSxcclxuICogICAgICAgICAgIHBvc2l0aW9uOls2MCw2MF1cclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZCh0ZXh0KTtcclxuICovXHJcblxyXG4gICAgdmFyIFRleHQgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL1RleHQnKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBmbG93Tm9kZSA9IHJlcXVpcmUoJy4vZmxvd05vZGUnKTtcclxuICAgIGZ1bmN0aW9uIFpUZXh0KG9wdHMpIHtcclxuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIHN0eWxlOnt0ZXh0QmFzZWxpbmU6XCJ0b3BcIn0gICAvLyDpu5jorqTlgLwgIOi/meagt+mAieS4reaXtueahOahhuaJjeato+ehrlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdHMsIHRydWUpO1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBmbG93Tm9kZS5nZW5Nb2RlbChcIlRleHRcIiwgb3B0aW9ucyk7XHJcbiAgICAgICAgVGV4dC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIFpUZXh0LnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogWlRleHQsXHJcblxyXG4gICAgICAgIHR5cGU6ICdUZXh0JyxcclxuXHJcbiAgICAgICAgdXBkYXRlU2hhcGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgenJVdGlsLmluaGVyaXRzKFpUZXh0LCBUZXh0KTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gWlRleHQ7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBleHRlbmRcclxuICogQGhpZGVcclxuICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvVGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMTAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDmiYflvaI8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubm9kZS5TZWN0b3JcclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93Lm5vZGVcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgIHZhciBub2RlID0gZmlzaFRvcG9GbG93Lm5vZGU7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSk7XHJcbiAqICAgICAgIHZhciBzZWN0b3IgPSBuZXcgbm9kZS5TZWN0b3Ioe1xyXG4gKiAgICAgICAgICAgc2hhcGU6IHtyOjMwLCBzdGFydEFuZ2xlOjAsIGVuZEFuZ2xlOk1hdGguUEkgKiAwLjV9LCAvLyBzdGFydEFuZ2xlXFxlbmRBbmdsZeaYr+W8p+W6puWNleS9jVxyXG4gKiAgICAgICAgICAgcG9zaXRpb246WzYwLDYwXVxyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgZmlzaFRvcG8uYWRkKHNlY3Rvcik7XHJcbiAqL1xyXG5cclxuICAgIHZhciBlbnYgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2VudicpO1xyXG4gICAgdmFyIFBhdGggPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL1BhdGgnKTtcclxuXHJcbiAgICB2YXIgc2hhZG93VGVtcCA9IFtcclxuICAgICAgICBbJ3NoYWRvd0JsdXInLCAwXSxcclxuICAgICAgICBbJ3NoYWRvd0NvbG9yJywgJyMwMDAnXSxcclxuICAgICAgICBbJ3NoYWRvd09mZnNldFgnLCAwXSxcclxuICAgICAgICBbJ3NoYWRvd09mZnNldFknLCAwXVxyXG4gICAgXTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mbG93Tm9kZScpLmV4dGVuZCh7XHJcblxyXG4gICAgICAgIHR5cGU6ICdTZWN0b3InLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gc2hhcGUg5b2i54q25Y+C5pWwXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5yPTAg5aSW5Y2K5b6E44CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5yMD0wIOWGheWNiuW+hOOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUuc3RhcnRBbmdsZT0wIOW8gOWni+W8p+W6puOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUuZW5kQW5nbGU9TWF0aC5QSSAqIDIgIOe7k+adn+W8p+W6puOAglxyXG4gICAgICAgICAqIEBjZmcge0Jvb2xlYW59IHNoYXBlLmNsb2Nrd2lzZT10cnVlIOaYr+WQpumhuuaXtumSiOOAglxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIGN4OiAwLFxyXG5cclxuICAgICAgICAgICAgY3k6IDAsXHJcblxyXG4gICAgICAgICAgICByMDogMCxcclxuXHJcbiAgICAgICAgICAgIHI6IDAsXHJcblxyXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiAwLFxyXG5cclxuICAgICAgICAgICAgZW5kQW5nbGU6IE1hdGguUEkgKiAyLFxyXG5cclxuICAgICAgICAgICAgY2xvY2t3aXNlOiB0cnVlXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnJ1c2g6IChlbnYuYnJvd3Nlci5pZSAmJiBlbnYuYnJvd3Nlci52ZXJzaW9uID49IDExKSAvLyB2ZXJzaW9uOiAnMTEuMCdcclxuICAgICAgICAgICAgLy8gRml4IHdlaXJkIGJ1ZyBpbiBzb21lIHZlcnNpb24gb2YgSUUxMSAobGlrZSAxMS4wLjk2MDAuMTc4MDEpLFxyXG4gICAgICAgICAgICAvLyB3aGVyZSBleGNlcHRpb24gXCJ1bmV4cGVjdGVkIGNhbGwgdG8gbWV0aG9kIG9yIHByb3BlcnR5IGFjY2Vzc1wiXHJcbiAgICAgICAgICAgIC8vIG1pZ2h0IGJlIHRocm93biB3aGVuIGNhbGxpbmcgY3R4LmZpbGwgYWZ0ZXIgYSBwYXRoIHdob3NlIGFyZWEgc2l6ZVxyXG4gICAgICAgICAgICAvLyBpcyB6ZXJvIGlzIGRyYXduIGFuZCBjdHguY2xpcCgpIGlzIGNhbGxlZCBhbmQgc2hhZG93Qmx1ciBpcyBzZXQuXHJcbiAgICAgICAgICAgIC8vIChlLmcuLFxyXG4gICAgICAgICAgICAvLyAgY3R4Lm1vdmVUbygxMCwgMTApO1xyXG4gICAgICAgICAgICAvLyAgY3R4LmxpbmVUbygyMCwgMTApO1xyXG4gICAgICAgICAgICAvLyAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICAvLyAgY3R4LmNsaXAoKTtcclxuICAgICAgICAgICAgLy8gIGN0eC5zaGFkb3dCbHVyID0gMTA7XHJcbiAgICAgICAgICAgIC8vICAuLi5cclxuICAgICAgICAgICAgLy8gIGN0eC5maWxsKCk7XHJcbiAgICAgICAgICAgIC8vIClcclxuICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xpcFBhdGhzID0gdGhpcy5fX2NsaXBQYXRocztcclxuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgbW9kaWZpZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNsaXBQYXRocykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcFBhdGhzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IGNsaXBQYXRoc1tpXSAmJiBjbGlwUGF0aHNbaV0uc2hhcGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5zdGFydEFuZ2xlID09PSBzaGFwZS5lbmRBbmdsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzaGFkb3dUZW1wLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93VGVtcFtqXVsyXSA9IHN0eWxlW3NoYWRvd1RlbXBbal1bMF1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlW3NoYWRvd1RlbXBbal1bMF1dID0gc2hhZG93VGVtcFtqXVsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIFBhdGgucHJvdG90eXBlLmJydXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzaGFkb3dUZW1wLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlW3NoYWRvd1RlbXBba11bMF1dID0gc2hhZG93VGVtcFtrXVsyXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiBQYXRoLnByb3RvdHlwZS5icnVzaCxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS5jeDtcclxuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS5jeTtcclxuICAgICAgICAgICAgdmFyIHIwID0gTWF0aC5tYXgoc2hhcGUucjAgfHwgMCwgMCk7XHJcbiAgICAgICAgICAgIHZhciByID0gTWF0aC5tYXgoc2hhcGUuciwgMCk7XHJcbiAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gc2hhcGUuc3RhcnRBbmdsZTtcclxuICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gc2hhcGUuZW5kQW5nbGU7XHJcbiAgICAgICAgICAgIHZhciBjbG9ja3dpc2UgPSBzaGFwZS5jbG9ja3dpc2U7XHJcblxyXG4gICAgICAgICAgICB2YXIgdW5pdFggPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcclxuICAgICAgICAgICAgdmFyIHVuaXRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XHJcblxyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHVuaXRYICogcjAgKyB4LCB1bml0WSAqIHIwICsgeSk7XHJcblxyXG4gICAgICAgICAgICBjdHgubGluZVRvKHVuaXRYICogciArIHgsIHVuaXRZICogciArIHkpO1xyXG5cclxuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgIWNsb2Nrd2lzZSk7XHJcblxyXG4gICAgICAgICAgICBjdHgubGluZVRvKFxyXG4gICAgICAgICAgICAgICAgTWF0aC5jb3MoZW5kQW5nbGUpICogcjAgKyB4LFxyXG4gICAgICAgICAgICAgICAgTWF0aC5zaW4oZW5kQW5nbGUpICogcjAgKyB5XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBpZiAocjAgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgcjAsIGVuZEFuZ2xlLCBzdGFydEFuZ2xlLCBjbG9ja3dpc2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1cGRhdGVTaGFwZTogZnVuY3Rpb24gKHJhdGlvLCBpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZVJhdGlvID0gTnVtYmVyKHJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcclxuICAgICAgICAgICAgdmFyIG5ld1IgPSBOdW1iZXIoc2hhcGUuciAqIHNjYWxlUmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgbmV3UjAgPSBOdW1iZXIoc2hhcGUucjAgKiBzY2FsZVJhdGlvKTtcclxuICAgICAgICAgICAgaWYgKGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgICAgIG5ld1IgPSBwYXJzZUludChuZXdSLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBuZXdSMCA9IHBhcnNlSW50KG5ld1IwLCAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8g5oyJ5q+U5L6L57yp5pS+XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U2hhcGUoe1xyXG4gICAgICAgICAgICAgICAgcjogbmV3UixcclxuICAgICAgICAgICAgICAgIHIwOiBuZXdSMFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9TZWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog546v5b2iPGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93Lm5vZGUuUmluZ1xyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpKTtcclxuICogICAgICAgdmFyIHJpbmcgPSBuZXcgbm9kZS5SaW5nKHtcclxuICogICAgICAgICAgIHNoYXBlOiB7cjozMCwgIHIwOjEwfSwgIC8vIHIwIOWGheWNiuW+hFxyXG4gKiAgICAgICAgICAgcG9zaXRpb246WzYwLDYwXVxyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgZmlzaFRvcG8uYWRkKHJpbmcpO1xyXG4gKi9cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmxvd05vZGUnKS5leHRlbmQoe1xyXG5cclxuICAgICAgICAgdHlwZTogJ1JpbmcnLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gc2hhcGUg5b2i54q25Y+C5pWwXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5yPTAg5aSW5Y2K5b6E44CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5yMD0wIOWGheWNiuW+hOOAglxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIGN4OiAwLFxyXG4gICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgcjogMCxcclxuICAgICAgICAgICAgcjA6IDBcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUuY3g7XHJcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUuY3k7XHJcbiAgICAgICAgICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgc2hhcGUuciwgeSk7XHJcbiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgc2hhcGUuciwgMCwgUEkyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIHNoYXBlLnIwLCB5KTtcclxuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCBzaGFwZS5yMCwgMCwgUEkyLCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZVNoYXBlOiBmdW5jdGlvbiAocmF0aW8sIGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgdmFyIHNjYWxlUmF0aW8gPSBOdW1iZXIocmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xyXG4gICAgICAgICAgICB2YXIgbmV3UiA9IE51bWJlcihzaGFwZS5yICogc2NhbGVSYXRpbyk7XHJcbiAgICAgICAgICAgIHZhciBuZXdSMCA9IE51bWJlcihzaGFwZS5yMCAqIHNjYWxlUmF0aW8pO1xyXG4gICAgICAgICAgICBpZiAoaWZQYXJzZSkge1xyXG4gICAgICAgICAgICAgICAgbmV3UiA9IHBhcnNlSW50KG5ld1IsIDEwKTtcclxuICAgICAgICAgICAgICAgIG5ld1IwID0gcGFyc2VJbnQobmV3UjAsIDEwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDmjInmr5TkvovnvKnmlL5cclxuICAgICAgICAgICAgdGhpcy5zZXRTaGFwZSh7XHJcbiAgICAgICAgICAgICAgICByOiBuZXdSLFxyXG4gICAgICAgICAgICAgICAgcjA6IG5ld1IwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1JpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDEwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vKipcclxuICog5qSt5ZyGPGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93Lm5vZGUuRHJvcGxldFxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gKiAgICAgICB2YXIgZWxsaXBzZSA9IG5ldyBub2RlLkVsbGlwc2Uoe1xyXG4gKiAgICAgICAgICAgc2hhcGU6IHtyeDo3MCwgIHJ5OjMwfSwgIC8vIHJ4OuakreWchuaoquWNiui9tOmVvyByeTrmpK3lnIbnurXljYrovbTplb9cclxuICogICAgICAgICAgIHBvc2l0aW9uOls2MCw2MF1cclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChlbGxpcHNlKTtcclxuICovXHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Zsb3dOb2RlJykuZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgdHlwZTogJ0VsbGlwc2UnLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gc2hhcGUg5b2i54q25Y+C5pWwXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5yeD0wIOakreWchuaoquWNiui9tOmVv1xyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUucnk9MCDmpK3lnIbnurXljYrovbTplb9cclxuICAgICAgICAgKi9cclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICByeDogMCwgcnk6IDBcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBrID0gMC41NTIyODQ4O1xyXG4gICAgICAgICAgICB2YXIgeCA9IDA7XHJcbiAgICAgICAgICAgIHZhciB5ID0gMDtcclxuICAgICAgICAgICAgdmFyIGEgPSBzaGFwZS5yeDtcclxuICAgICAgICAgICAgdmFyIGIgPSBzaGFwZS5yeTtcclxuICAgICAgICAgICAgdmFyIG94ID0gYSAqIGs7IC8vIOawtOW5s+aOp+WItueCueWBj+enu+mHj1xyXG4gICAgICAgICAgICB2YXIgb3kgPSBiICogazsgLy8g5Z6C55u05o6n5Yi254K55YGP56e76YePXHJcbiAgICAgICAgICAgIC8vIOS7juakreWchueahOW3puerr+eCueW8gOWni+mhuuaXtumSiOe7mOWItuWbm+adoeS4ieasoei0neWhnuWwlOabsue6v1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHggLSBhLCB5KTtcclxuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oeCAtIGEsIHkgLSBveSwgeCAtIG94LCB5IC0gYiwgeCwgeSAtIGIpO1xyXG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4ICsgb3gsIHkgLSBiLCB4ICsgYSwgeSAtIG95LCB4ICsgYSwgeSk7XHJcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyBhLCB5ICsgb3ksIHggKyBveCwgeSArIGIsIHgsIHkgKyBiKTtcclxuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oeCAtIG94LCB5ICsgYiwgeCAtIGEsIHkgKyBveSwgeCAtIGEsIHkpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1cGRhdGVTaGFwZTogZnVuY3Rpb24gKHJhdGlvLCBpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZVJhdGlvID0gTnVtYmVyKHJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcclxuICAgICAgICAgICAgdmFyIG5ld1J4ID0gTnVtYmVyKHNoYXBlLnJ4ICogc2NhbGVSYXRpbyk7XHJcbiAgICAgICAgICAgIHZhciBuZXdSeSA9IE51bWJlcihuZXdSeCAqIHNoYXBlLnJ5IC8gc2hhcGUucngpO1xyXG4gICAgICAgICAgICBpZiAoaWZQYXJzZSkge1xyXG4gICAgICAgICAgICAgICAgbmV3UnggPSBwYXJzZUludChuZXdSeCwgMTApO1xyXG4gICAgICAgICAgICAgICAgbmV3UnkgPSBwYXJzZUludChuZXdSeSwgMTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOaMieavlOS+i+e8qeaUvlxyXG4gICAgICAgICAgICB0aGlzLnNldFNoYXBlKHtcclxuICAgICAgICAgICAgICAgIHJ4OiBuZXdSeCxcclxuICAgICAgICAgICAgICAgIHJ5OiBuZXdSeVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9FbGxpcHNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOW/g+W9ojxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5ub2RlLkhlYXJ0XHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIHZhciBoZWFydCAgPSBuZXcgbm9kZS5IZWFydCh7XHJcbiAqICAgICAgICAgICBzaGFwZToge3dpZHRoOjQwLCAgaGVpZ2h0OjUwfSxcclxuICogICAgICAgICAgIHBvc2l0aW9uOls2MCw2MF1cclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChoZWFydCApO1xyXG4gKi9cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmxvd05vZGUnKS5leHRlbmQoe1xyXG5cclxuICAgICAgICB0eXBlOiAnSGVhcnQnLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gc2hhcGUg5b2i54q25Y+C5pWwXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5jeD0wIOS4reW/g+WcqOeItuiKgueCueWdkOagh+ezu++8iOS7peeItuiKgueCueW3puS4iuinkuS4uuWOn+eCue+8ieS4reeahOaoquWdkOagh+WAvOOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUuY3k9MCDkuK3lv4PlnKjniLboioLngrnlnZDmoIfns7vvvIjku6XniLboioLngrnlt6bkuIrop5LkuLrljp/ngrnvvInkuK3nmoTnurXlnZDmoIflgLzjgIJcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLndpZHRoPTAg5a695bqm44CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5oZWlnaHQ9MCDpq5jluqbjgIJcclxuICAgICAgICAgKi9cclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgY3k6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUuY3g7XHJcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUuY3k7XHJcbiAgICAgICAgICAgIHZhciBhID0gc2hhcGUud2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBiID0gc2hhcGUuaGVpZ2h0O1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xyXG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcclxuICAgICAgICAgICAgICAgIHggKyBhIC8gMiwgeSAtIGIgKiAyIC8gMyxcclxuICAgICAgICAgICAgICAgIHggKyBhICogMiwgeSArIGIgLyAzLFxyXG4gICAgICAgICAgICAgICAgeCwgeSArIGJcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oXHJcbiAgICAgICAgICAgICAgICB4IC0gYSAqICAyLCB5ICsgYiAvIDMsXHJcbiAgICAgICAgICAgICAgICB4IC0gYSAvIDIsIHkgLSBiICogMiAvIDMsXHJcbiAgICAgICAgICAgICAgICB4LCB5XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1cGRhdGVTaGFwZTogZnVuY3Rpb24gKHJhdGlvLCBpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZVJhdGlvID0gTnVtYmVyKHJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcclxuICAgICAgICAgICAgdmFyIG5ld1dpZHRoID0gTnVtYmVyKHNoYXBlLndpZHRoICogc2NhbGVSYXRpbyk7XHJcbiAgICAgICAgICAgIHZhciBuZXdIZWlnaHQgPSBOdW1iZXIobmV3V2lkdGggKiBzaGFwZS5oZWlnaHQgLyBzaGFwZS53aWR0aCk7XHJcbiAgICAgICAgICAgIGlmIChpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdXaWR0aCA9IHBhcnNlSW50KG5ld1dpZHRoLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBuZXdIZWlnaHQgPSBwYXJzZUludChuZXdIZWlnaHQsIDEwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDmjInmr5TkvovnvKnmlL5cclxuICAgICAgICAgICAgdGhpcy5zZXRTaGFwZSh7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogbmV3V2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG5ld0hlaWdodFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9IZWFydC5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxyXG4gKiDmsLTmu7TlvaI8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubm9kZS5Ecm9wbGV0XHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIHZhciBkcm9wbGV0ID0gbmV3IG5vZGUuRHJvcGxldCh7XHJcbiAqICAgICAgICAgICBzaGFwZToge3dpZHRoOjEwLCAgaGVpZ2h0OjMwfSxcclxuICogICAgICAgICAgIHBvc2l0aW9uOls2MCw2MF1cclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChkcm9wbGV0KTtcclxuICovXHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Zsb3dOb2RlJykuZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgdHlwZTogJ0Ryb3BsZXQnLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gc2hhcGUg5b2i54q25Y+C5pWwXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS53aWR0aD0wIOWuveW6puOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUuaGVpZ2h0PTAg6auY5bqm44CCXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgY3g6IDAsIGN5OiAwLFxyXG4gICAgICAgICAgICB3aWR0aDogMCwgaGVpZ2h0OiAwXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoIDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS5jeDtcclxuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS5jeTtcclxuICAgICAgICAgICAgdmFyIGEgPSBzaGFwZS53aWR0aDtcclxuICAgICAgICAgICAgdmFyIGIgPSBzaGFwZS5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkgKyBhKTtcclxuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oXHJcbiAgICAgICAgICAgICAgICB4ICsgYSxcclxuICAgICAgICAgICAgICAgIHkgKyBhLFxyXG4gICAgICAgICAgICAgICAgeCArIGEgKiAzIC8gMixcclxuICAgICAgICAgICAgICAgIHkgLSBhIC8gMyxcclxuICAgICAgICAgICAgICAgIHgsXHJcbiAgICAgICAgICAgICAgICB5IC0gYlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcclxuICAgICAgICAgICAgICAgIHggLSBhICogMyAvIDIsXHJcbiAgICAgICAgICAgICAgICB5IC0gYSAvIDMsXHJcbiAgICAgICAgICAgICAgICB4IC0gYSxcclxuICAgICAgICAgICAgICAgIHkgKyBhLFxyXG4gICAgICAgICAgICAgICAgeCxcclxuICAgICAgICAgICAgICAgIHkgKyBhXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZVNoYXBlOiBmdW5jdGlvbiAocmF0aW8sIGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgdmFyIHNjYWxlUmF0aW8gPSBOdW1iZXIocmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xyXG4gICAgICAgICAgICB2YXIgbmV3V2lkdGggPSBOdW1iZXIoc2hhcGUud2lkdGggKiBzY2FsZVJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIG5ld0hlaWdodCA9IE51bWJlcihuZXdXaWR0aCAqIHNoYXBlLmhlaWdodCAvIHNoYXBlLndpZHRoKTtcclxuICAgICAgICAgICAgaWYgKGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgICAgIG5ld1dpZHRoID0gcGFyc2VJbnQobmV3V2lkdGgsIDEwKTtcclxuICAgICAgICAgICAgICAgIG5ld0hlaWdodCA9IHBhcnNlSW50KG5ld0hlaWdodCwgMTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOaMieavlOS+i+e8qeaUvlxyXG4gICAgICAgICAgICB0aGlzLnNldFNoYXBlKHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBuZXdXaWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogbmV3SGVpZ2h0XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0Ryb3BsZXQuanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog546r55Gw5b2iPGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93Lm5vZGUuUm9zZVxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpKTtcclxuICogICAgICAgdmFyIHJvc2UgPSBuZXcgbm9kZS5Sb3NlKHtcclxuICogICAgICAgICAgIHNoYXBlOiB7cjpbMzVdLCBrOjcsIG46NH0sXHJcbiAqICAgICAgICAgICBwb3NpdGlvbjpbNjAsNjBdXHJcbiAqICAgICAgIH0pO1xyXG4gKiAgICAgICBmaXNoVG9wby5hZGQocm9zZSk7XHJcbiAqL1xyXG5cclxuICAgIHZhciBzaW4gPSBNYXRoLnNpbjtcclxuICAgIHZhciBjb3MgPSBNYXRoLmNvcztcclxuICAgIHZhciByYWRpYW4gPSBNYXRoLlBJIC8gMTgwO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Zsb3dOb2RlJykuZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgdHlwZTogJ1Jvc2UnLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gc2hhcGUg5b2i54q25Y+C5pWwXHJcbiAgICAgICAgICogQGNmZyB7QXJyYXl9IHNoYXBlLnI9W11cclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLms9MFxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUubj0xXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICByOiBbXSxcclxuICAgICAgICAgICAgazogMCxcclxuICAgICAgICAgICAgbjogMVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxyXG4gICAgICAgICAgICBmaWxsOiBudWxsLFxyXG4gICAgICAgICAgICBsaW5lV2lkdGg6IDJcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciB4O1xyXG4gICAgICAgICAgICB2YXIgeTtcclxuICAgICAgICAgICAgdmFyIFIgPSBzaGFwZS5yO1xyXG4gICAgICAgICAgICB2YXIgcjtcclxuICAgICAgICAgICAgdmFyIGsgPSBzaGFwZS5rO1xyXG4gICAgICAgICAgICB2YXIgbiA9IHNoYXBlLm47XHJcblxyXG4gICAgICAgICAgICB2YXIgeDAgPSBzaGFwZS5jeDtcclxuICAgICAgICAgICAgdmFyIHkwID0gc2hhcGUuY3k7XHJcblxyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHgwLCB5MCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gUi5sZW5ndGg7IGkgPCBsZW4gOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHIgPSBSW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDw9IDM2MCAqIG47IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSByXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHNpbihrIC8gbiAqIGogJSAzNjAgKiByYWRpYW4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGNvcyhqICogcmFkaWFuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKyB4MDtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBzaW4oayAvIG4gKiBqICUgMzYwICogcmFkaWFuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBzaW4oaiAqIHJhZGlhbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICsgeTA7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdXBkYXRlU2hhcGU6IGZ1bmN0aW9uIChyYXRpbywgaWZQYXJzZSkge1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVSYXRpbyA9IE51bWJlcihyYXRpbyk7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XHJcbiAgICAgICAgICAgIHZhciBuZXdSID0gW107XHJcbiAgICAgICAgICAgIHNoYXBlLnIuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgbmV3Ui5wdXNoKE51bWJlcih2ICogc2NhbGVSYXRpbykpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaWZQYXJzZSkge1xyXG4gICAgICAgICAgICAgICAgbmV3Ui5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdiA9IHBhcnNlSW50KHYsIDEwKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOaMieavlOS+i+e8qeaUvlxyXG4gICAgICAgICAgICB0aGlzLnNldFNoYXBlKHtcclxuICAgICAgICAgICAgICAgIHI6IG5ld1JcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBleHRlbmRcclxuICogQGhpZGVcclxuICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvUm9zZS5qc1xuLy8gbW9kdWxlIGlkID0gMTA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDmraPlpJrovrnlvaI8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubm9kZS5Jc29nb25cclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93Lm5vZGVcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgIHZhciBub2RlID0gZmlzaFRvcG9GbG93Lm5vZGU7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSwge3JvYW06ZmFsc2V9KTtcclxuICogICAgICAgdmFyIGlzb2dvbiA9IG5ldyBub2RlLklzb2dvbih7XHJcbiAqICAgICAgICAgICBzaGFwZToge3I6NDAsICBuOjl9LCAgLy8gcuWNiuW+hCBu5Yeg5Liq6L65XHJcbiAqICAgICAgICAgICBwb3NpdGlvbjpbNjAsNTBdXHJcbiAqICAgICAgIH0pO1xyXG4gKiAgICAgICBmaXNoVG9wby5hZGQoaXNvZ29uKTtcclxuICovXHJcblxyXG4gICAgdmFyIFBJID0gTWF0aC5QSTtcclxuICAgIHZhciBzaW4gPSBNYXRoLnNpbjtcclxuICAgIHZhciBjb3MgPSBNYXRoLmNvcztcclxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mbG93Tm9kZScpLmV4dGVuZCh7XHJcblxyXG4gICAgICAgIHR5cGU6ICdJc29nb24nLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gc2hhcGUg5b2i54q25Y+C5pWwXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5yPTAg5Y2K5b6EXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5uPTAg5Yeg5Liq6L65XHJcbiAgICAgICAgICovXHJcbiAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICB4OiAwLCB5OiAwLFxyXG4gICAgICAgICAgICByOiAwLCBuOiAwXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgbiA9IHNoYXBlLm47XHJcbiAgICAgICAgICAgIGlmICghbiB8fCBuIDwgMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLng7XHJcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUueTtcclxuICAgICAgICAgICAgdmFyIHIgPSBzaGFwZS5yO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRTdGVwID0gMiAqIFBJIC8gbjtcclxuICAgICAgICAgICAgdmFyIGRlZyA9IC1QSSAvIDI7XHJcblxyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyByICogY29zKGRlZyksIHkgKyByICogc2luKGRlZykpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZW5kID0gbiAtIDE7IGkgPCBlbmQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZGVnICs9IGRTdGVwO1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgciAqIGNvcyhkZWcpLCB5ICsgciAqIHNpbihkZWcpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdXBkYXRlU2hhcGU6IGZ1bmN0aW9uIChyYXRpbywgaWZQYXJzZSkge1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVSYXRpbyA9IE51bWJlcihyYXRpbyk7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XHJcbiAgICAgICAgICAgIHZhciBuZXdSID0gTnVtYmVyKHNoYXBlLnIgKiBzY2FsZVJhdGlvKTtcclxuICAgICAgICAgICAgaWYgKGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgICAgIG5ld1IgPSBwYXJzZUludChuZXdSLCAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8g5oyJ5q+U5L6L57yp5pS+XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U2hhcGUoe1xyXG4gICAgICAgICAgICAgICAgcjogbmV3UlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9Jc29nb24uanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog5aSa6L655b2iPGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93Lm5vZGUuUG9seWdvblxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gKiAgICAgICB2YXIgcG9seWdvbiA9IG5ldyBub2RlLlBvbHlnb24oe1xyXG4gKiAgICAgICAgICAgc2hhcGU6IHtwb2ludHM6W1s4NS4yNzUsMF0sIFsxMDAsMjUuNDFdLCBbODUuMjc1LDUwLjgyMV0sIFsxNC4xMzgsNTAuODIxXSwgWzAsMjUuNDFdLCBbMTQuMTM4LDBdXX0sICAvLyBy5Y2K5b6EIG7lh6DkuKrovrlcclxuICogICAgICAgICAgIHBvc2l0aW9uOls2MCw2MF1cclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChwb2x5Z29uKTtcclxuICovXHJcblxyXG4gICAgdmFyIHBvbHlIZWxwZXIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9wb2x5Jyk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Zsb3dOb2RlJykuZXh0ZW5kKHtcclxuXHJcbiAgICAgICB0eXBlOiAnUG9seWdvbicsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBzaGFwZSDlvaLnirblj4LmlbBcclxuICAgICAgICAgKiBAY2ZnIHtBcnJheX0gc2hhcGUucG9pbnRzPW51bGwg5aSa6L655b2i54K555qE5Z2Q5qCHIOWPr+S7peS7jkFJ5Lit6I635Y+W44CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfFN0cmluZ3xCb29sZWFufSBbc2hhcGUuc21vb3RoPWZhbHNlXSDmmK/lkKblubPmu5Hmm7Lnur/mmL7npLrjgILlpoLmnpzkuLogbnVtYmVy77ya6KGo56S66LSd5aGe5bCUIChiZXppZXIpIOW3ruWAvOW5s+a7ke+8jHNtb290aCDmjIflrprkuoblubPmu5HnrYnnuqfvvIzojIPlm7QgWzAsIDFdO+WmguaenOS4uiAnc3BsaW5lJ++8muihqOekuiBDYXRtdWxsLVJvbSBzcGxpbmUg5beu5YC85bmz5ruRXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5zbW9vdGhDb25zdHJhaW50PW51bGwg5piv5ZCm5bCG5bmz5ruR5puy57q/57qm5p2f5Zyo5YyF5Zu055uS5Lit44CCc21vb3RoIOS4uiBudW1iZXLvvIhiZXppZXLvvInml7bnlJ/mlYhcclxuICAgICAgICAgKi9cclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICBwb2ludHM6IG51bGwsXHJcblxyXG4gICAgICAgICAgICBzbW9vdGg6IGZhbHNlLFxyXG5cclxuICAgICAgICAgICAgc21vb3RoQ29uc3RyYWludDogbnVsbFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgcG9seUhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1cGRhdGVTaGFwZTogZnVuY3Rpb24gKHJhdGlvLCBpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZVJhdGlvID0gTnVtYmVyKHJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcclxuICAgICAgICAgICAgdmFyIHBvaW50c05ldyA9IFtdO1xyXG4gICAgICAgICAgICBzaGFwZS5wb2ludHMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludHNOZXcucHVzaChbTnVtYmVyKGl0ZW1bMF0gKiBzY2FsZVJhdGlvKSwgTnVtYmVyKGl0ZW1bMV0gKiBzY2FsZVJhdGlvKV0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgICAgIHBvaW50c05ldy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtWzBdID0gcGFyc2VJbnQoaXRlbVswXSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bMV0gPSBwYXJzZUludChpdGVtWzFdLCAxMCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDmjInmr5TkvovnvKnmlL5cclxuICAgICAgICAgICAgdGhpcy5zZXRTaGFwZSh7XHJcbiAgICAgICAgICAgICAgICBwb2ludHM6IHBvaW50c05ld1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9Qb2x5Z29uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOebtOe6vzxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5ub2RlLkxpbmVcclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93Lm5vZGVcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgIHZhciBub2RlID0gZmlzaFRvcG9GbG93Lm5vZGU7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSwge3JvYW06ZmFsc2V9KTtcclxuICogICAgICAgdmFyIGxpbmUgPSBuZXcgbm9kZS5MaW5lKHtcclxuICogICAgICAgICAgIHNoYXBlOiB7eDE6NjAsICB5MTo2MCwgeDI6MTAwLCB5MjoxMDB9LCAgLy8geCDotbfngrkgeee7iOeCuVxyXG4gKiAgICAgICAgICAgc3R5bGU6IHtsaW5lV2lkdGg6M31cclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChsaW5lKTtcclxuICovXHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Zsb3dOb2RlJykuZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgdHlwZTogJ0xpbmUnLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gc2hhcGUg5b2i54q25Y+C5pWwXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS54MT0wIOi1t+Wni+eCueeahOaoquWdkOagh+WAvOOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUueTE9MCDotbflp4vngrnnmoTnurXlnZDmoIflgLzjgIJcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLngyPTAg57uI5q2i54K555qE5qiq5Z2Q5qCH5YC844CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS55Mj0wIOe7iOatoueCueeahOe6teWdkOagh+WAvOOAglxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIC8vIFN0YXJ0IHBvaW50XHJcbiAgICAgICAgICAgIHgxOiAwLFxyXG4gICAgICAgICAgICB5MTogMCxcclxuICAgICAgICAgICAgLy8gRW5kIHBvaW50XHJcbiAgICAgICAgICAgIHgyOiAwLFxyXG4gICAgICAgICAgICB5MjogMCxcclxuXHJcbiAgICAgICAgICAgIHBlcmNlbnQ6IDFcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwJyxcclxuICAgICAgICAgICAgZmlsbDogbnVsbFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHgxID0gc2hhcGUueDE7XHJcbiAgICAgICAgICAgIHZhciB5MSA9IHNoYXBlLnkxO1xyXG4gICAgICAgICAgICB2YXIgeDIgPSBzaGFwZS54MjtcclxuICAgICAgICAgICAgdmFyIHkyID0gc2hhcGUueTI7XHJcbiAgICAgICAgICAgIHZhciBwZXJjZW50ID0gc2hhcGUucGVyY2VudDtcclxuXHJcbiAgICAgICAgICAgIGlmIChwZXJjZW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMSkge1xyXG4gICAgICAgICAgICAgICAgeDIgPSB4MSAqICgxIC0gcGVyY2VudCkgKyB4MiAqIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICB5MiA9IHkxICogKDEgLSBwZXJjZW50KSArIHkyICogcGVyY2VudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHgubGluZVRvKHgyLCB5Mik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHBvaW50IGF0IHBlcmNlbnRcclxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcclxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBwb2ludEF0OiBmdW5jdGlvbiAocCkge1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgc2hhcGUueDEgKiAoMSAtIHApICsgc2hhcGUueDIgKiBwLFxyXG4gICAgICAgICAgICAgICAgc2hhcGUueTEgKiAoMSAtIHApICsgc2hhcGUueTIgKiBwXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1cGRhdGVTaGFwZTogZnVuY3Rpb24gKHJhdGlvLCBpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZVJhdGlvID0gTnVtYmVyKHJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcclxuICAgICAgICAgICAgdmFyIG5ld1gxID0gTnVtYmVyKHNoYXBlLngxICogc2NhbGVSYXRpbyk7XHJcbiAgICAgICAgICAgIHZhciBuZXdYMiA9IE51bWJlcihzaGFwZS54MiAqIHNjYWxlUmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgbmV3WTEgPSBOdW1iZXIoc2hhcGUueTEgKiBzY2FsZVJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIG5ld1kyID0gTnVtYmVyKHNoYXBlLnkyICogc2NhbGVSYXRpbyk7XHJcbiAgICAgICAgICAgIGlmIChpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdYMSA9IHBhcnNlSW50KG5ld1gxLCAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8g5oyJ5q+U5L6L57yp5pS+XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U2hhcGUoe1xyXG4gICAgICAgICAgICAgICAgeDE6IG5ld1gxLFxyXG4gICAgICAgICAgICAgICAgeTE6IG5ld1kxLFxyXG4gICAgICAgICAgICAgICAgeDI6IG5ld1gyLFxyXG4gICAgICAgICAgICAgICAgeTI6IG5ld1kyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0xpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDEwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vKipcclxuICog5ouG57q/PGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93Lm5vZGUuUG9seWxpbmVcclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93Lm5vZGVcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgIHZhciBub2RlID0gZmlzaFRvcG9GbG93Lm5vZGU7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSwge3JvYW06ZmFsc2V9KTtcclxuICogICAgICAgdmFyIHBvbHlsaW5lID0gbmV3IG5vZGUuUG9seWxpbmUoe1xyXG4gKiAgICAgICAgICAgc2hhcGU6IHtwb2ludHM6W1s1NywxMzhdLFs5NSwxODRdLFsxMTUsMTY2XSxbMTUxLDE4NF0gXX1cclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChwb2x5bGluZSk7XHJcbiAqL1xyXG5cclxuICAgIHZhciBwb2x5SGVscGVyID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcG9seScpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Zsb3dOb2RlJykuZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgdHlwZTogJ1BvbHlsaW5lJyxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IHNoYXBlIOW9oueKtuWPguaVsFxyXG4gICAgICAgICAqIEBjZmcge0FycmF5fSBzaGFwZS5wb2ludHM9bnVsbCDmi4bnur/ngrnnmoTlnZDmoIcg5Y+v5Lul5LuOQUnkuK3ojrflj5bjgIJcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ8U3RyaW5nfEJvb2xlYW59IFtzaGFwZS5zbW9vdGg9ZmFsc2VdIOaYr+WQpuW5s+a7keabsue6v+aYvuekuuOAguWmguaenOS4uiBudW1iZXLvvJrooajnpLrotJ3loZ7lsJQgKGJlemllcikg5beu5YC85bmz5ruR77yMc21vb3RoIOaMh+WumuS6huW5s+a7keetiee6p++8jOiMg+WbtCBbMCwgMV075aaC5p6c5Li6ICdzcGxpbmUn77ya6KGo56S6IENhdG11bGwtUm9tIHNwbGluZSDlt67lgLzlubPmu5FcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLnNtb290aENvbnN0cmFpbnQ9bnVsbCDmmK/lkKblsIblubPmu5Hmm7Lnur/nuqbmnZ/lnKjljIXlm7Tnm5LkuK3jgIJzbW9vdGgg5Li6IG51bWJlcu+8iGJlemllcu+8ieaXtueUn+aViFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIHBvaW50czogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIHNtb290aDogZmFsc2UsXHJcblxyXG4gICAgICAgICAgICBzbW9vdGhDb25zdHJhaW50OiBudWxsXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXHJcblxyXG4gICAgICAgICAgICBmaWxsOiBudWxsXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xyXG4gICAgICAgICAgICBwb2x5SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlLCBmYWxzZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1cGRhdGVTaGFwZTogZnVuY3Rpb24gKHJhdGlvLCBpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZVJhdGlvID0gTnVtYmVyKHJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcclxuICAgICAgICAgICAgdmFyIHBvaW50c05ldyA9IFtdO1xyXG4gICAgICAgICAgICBzaGFwZS5wb2ludHMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludHNOZXcucHVzaChbTnVtYmVyKGl0ZW1bMF0gKiBzY2FsZVJhdGlvKSwgTnVtYmVyKGl0ZW1bMV0gKiBzY2FsZVJhdGlvKV0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgICAgIHBvaW50c05ldy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtWzBdID0gcGFyc2VJbnQoaXRlbVswXSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bMV0gPSBwYXJzZUludChpdGVtWzFdLCAxMCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDmjInmr5TkvovnvKnmlL5cclxuICAgICAgICAgICAgdGhpcy5zZXRTaGFwZSh7XHJcbiAgICAgICAgICAgICAgICBwb2ludHM6IHBvaW50c05ld1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9Qb2x5bGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxyXG4gKiDotJ3loZ7lsJTmm7Lnur88YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubm9kZS5CZXppZXJDdXJ2ZVxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gKiAgICAgICB2YXIgYmV6aWVyQ3VydmUgPSBuZXcgbm9kZS5CZXppZXJDdXJ2ZSh7XHJcbiAqICAgICAgICAgICBzaGFwZToge3gxOjAsIHkxOjEwMCwgY3B4MTowLCBjcHkxOjAsIGNweDI6MCwgY3B5MjowLCB4MjoxMDAsIHkyOjB9LFxyXG4gKiAgICAgICAgICAgcG9zaXRpb246IFs2MCwgNjBdXHJcbiAqICAgICAgIH0pO1xyXG4gKiAgICAgICBmaXNoVG9wby5hZGQoYmV6aWVyQ3VydmUpO1xyXG4gKi9cclxuXHJcblxyXG4gICAgdmFyIGN1cnZlVG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvY3VydmUnKTtcclxuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS92ZWN0b3InKTtcclxuICAgIHZhciBxdWFkcmF0aWNTdWJkaXZpZGUgPSBjdXJ2ZVRvb2wucXVhZHJhdGljU3ViZGl2aWRlO1xyXG4gICAgdmFyIGN1YmljU3ViZGl2aWRlID0gY3VydmVUb29sLmN1YmljU3ViZGl2aWRlO1xyXG4gICAgdmFyIHF1YWRyYXRpY0F0ID0gY3VydmVUb29sLnF1YWRyYXRpY0F0O1xyXG4gICAgdmFyIGN1YmljQXQgPSBjdXJ2ZVRvb2wuY3ViaWNBdDtcclxuICAgIHZhciBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgPSBjdXJ2ZVRvb2wucXVhZHJhdGljRGVyaXZhdGl2ZUF0O1xyXG4gICAgdmFyIGN1YmljRGVyaXZhdGl2ZUF0ID0gY3VydmVUb29sLmN1YmljRGVyaXZhdGl2ZUF0O1xyXG5cclxuICAgIHZhciBvdXQgPSBbXTtcclxuXHJcbiAgICBmdW5jdGlvbiBzb21lVmVjdG9yQXQoc2hhcGUsIHQsIGlzVGFuZ2VudCkge1xyXG4gICAgICAgIHZhciBjcHgyID0gc2hhcGUuY3B4MjtcclxuICAgICAgICB2YXIgY3B5MiA9IHNoYXBlLmNweTI7XHJcbiAgICAgICAgaWYgKGNweDIgPT09IG51bGwgfHwgY3B5MiA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgKGlzVGFuZ2VudCA/IGN1YmljRGVyaXZhdGl2ZUF0IDogY3ViaWNBdCkoc2hhcGUueDEsIHNoYXBlLmNweDEsIHNoYXBlLmNweDIsIHNoYXBlLngyLCB0KSxcclxuICAgICAgICAgICAgICAgIChpc1RhbmdlbnQgPyBjdWJpY0Rlcml2YXRpdmVBdCA6IGN1YmljQXQpKHNoYXBlLnkxLCBzaGFwZS5jcHkxLCBzaGFwZS5jcHkyLCBzaGFwZS55MiwgdClcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAoaXNUYW5nZW50ID8gcXVhZHJhdGljRGVyaXZhdGl2ZUF0IDogcXVhZHJhdGljQXQpKHNoYXBlLngxLCBzaGFwZS5jcHgxLCBzaGFwZS54MiwgdCksXHJcbiAgICAgICAgICAgICAgICAoaXNUYW5nZW50ID8gcXVhZHJhdGljRGVyaXZhdGl2ZUF0IDogcXVhZHJhdGljQXQpKHNoYXBlLnkxLCBzaGFwZS5jcHkxLCBzaGFwZS55MiwgdClcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmxvd05vZGUnKS5leHRlbmQoe1xyXG5cclxuICAgICAgICB0eXBlOiAnQmV6aWVyQ3VydmUnLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gc2hhcGUg5b2i54q25Y+C5pWwXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS54MT0wIOi1t+Wni+eCueeahOaoquWdkOagh+WAvOOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUueTE9MCDotbflp4vngrnnmoTnurXlnZDmoIflgLzjgIJcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLngyPTAg57uI5q2i54K555qE5qiq5Z2Q5qCH5YC844CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS55Mj0wIOe7iOatoueCueeahOe6teWdkOagh+WAvOOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUuY3B4MT0wIOaOp+WItueCueeahOaoquWdkOagh+WAvOOAglxyXG4gICAgICAgICAqIEBjZmcge0Jvb2xlYW59IHNoYXBlLmNweDI9MCDmjqfliLbngrnnmoTnurXlnZDmoIflgLzjgIJcclxuICAgICAgICAgKi9cclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICB4MTogMCxcclxuICAgICAgICAgICAgeTE6IDAsXHJcbiAgICAgICAgICAgIHgyOiAwLFxyXG4gICAgICAgICAgICB5MjogMCxcclxuICAgICAgICAgICAgY3B4MTogMCxcclxuICAgICAgICAgICAgY3B5MTogMCxcclxuXHJcbiAgICAgICAgICAgIC8vIEN1cnZlIHNob3cgcGVyY2VudCwgZm9yIGFuaW1hdGluZ1xyXG4gICAgICAgICAgICBwZXJjZW50OiAxXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXHJcbiAgICAgICAgICAgIGZpbGw6IG51bGxcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciB4MSA9IHNoYXBlLngxO1xyXG4gICAgICAgICAgICB2YXIgeTEgPSBzaGFwZS55MTtcclxuICAgICAgICAgICAgdmFyIHgyID0gc2hhcGUueDI7XHJcbiAgICAgICAgICAgIHZhciB5MiA9IHNoYXBlLnkyO1xyXG4gICAgICAgICAgICB2YXIgY3B4MSA9IHNoYXBlLmNweDE7XHJcbiAgICAgICAgICAgIHZhciBjcHkxID0gc2hhcGUuY3B5MTtcclxuICAgICAgICAgICAgdmFyIGNweDIgPSBzaGFwZS5jcHgyO1xyXG4gICAgICAgICAgICB2YXIgY3B5MiA9IHNoYXBlLmNweTI7XHJcbiAgICAgICAgICAgIHZhciBwZXJjZW50ID0gc2hhcGUucGVyY2VudDtcclxuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNweDIgPT0gbnVsbCB8fCBjcHkyID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1YWRyYXRpY1N1YmRpdmlkZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDEsIGNweDEsIHgyLCBwZXJjZW50LCBvdXRcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNweDEgPSBvdXRbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgeDIgPSBvdXRbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5MSwgY3B5MSwgeTIsIHBlcmNlbnQsIG91dFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3B5MSA9IG91dFsxXTtcclxuICAgICAgICAgICAgICAgICAgICB5MiA9IG91dFsyXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhcclxuICAgICAgICAgICAgICAgICAgICBjcHgxLCBjcHkxLFxyXG4gICAgICAgICAgICAgICAgICAgIHgyLCB5MlxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1YmljU3ViZGl2aWRlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4MSwgY3B4MSwgY3B4MiwgeDIsIHBlcmNlbnQsIG91dFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3B4MSA9IG91dFsxXTtcclxuICAgICAgICAgICAgICAgICAgICBjcHgyID0gb3V0WzJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHgyID0gb3V0WzNdO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1YmljU3ViZGl2aWRlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5MSwgY3B5MSwgY3B5MiwgeTIsIHBlcmNlbnQsIG91dFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3B5MSA9IG91dFsxXTtcclxuICAgICAgICAgICAgICAgICAgICBjcHkyID0gb3V0WzJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHkyID0gb3V0WzNdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oXHJcbiAgICAgICAgICAgICAgICAgICAgY3B4MSwgY3B5MSxcclxuICAgICAgICAgICAgICAgICAgICBjcHgyLCBjcHkyLFxyXG4gICAgICAgICAgICAgICAgICAgIHgyLCB5MlxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBwb2ludCBhdCBwZXJjZW50XHJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB0XHJcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcG9pbnRBdDogZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNvbWVWZWN0b3JBdCh0aGlzLnNoYXBlLCB0LCBmYWxzZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRhbmdlbnQgYXQgcGVyY2VudFxyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxyXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRhbmdlbnRBdDogZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICAgICAgdmFyIHAgPSBzb21lVmVjdG9yQXQodGhpcy5zaGFwZSwgdCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB2ZWMyLm5vcm1hbGl6ZShwLCBwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZVNoYXBlOiBmdW5jdGlvbiAocmF0aW8sIGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgdmFyIHNjYWxlUmF0aW8gPSBOdW1iZXIocmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzTmV3ID0ge307XHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNoYXBlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNoYXBlW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAncGVyY2VudCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHNOZXdba2V5XSA9IE51bWJlcih2YWx1ZSAqIHNjYWxlUmF0aW8pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHNOZXdba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHBvaW50c05ldykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHNOZXdba2V5XSA9IHBhcnNlSW50KHBvaW50c05ld1trZXldLCAxMCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDmjInmr5TkvovnvKnmlL5cclxuICAgICAgICAgICAgdGhpcy5zZXRTaGFwZShwb2ludHNOZXcpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0JlemllckN1cnZlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXHJcbiAqIOWchuW8pzxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5ub2RlLkFyY1xyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gKiAgICAgICB2YXIgYXJjID0gbmV3IG5vZGUuQXJjKHtcclxuICogICAgICAgICAgIHNoYXBlOiB7cjo1MCwgc3RhcnRBbmdsZTowLCBlbmRBbmdsZToxLjIqTWF0aC5QSX0sXHJcbiAqICAgICAgICAgICBwb3NpdGlvbjogWzYwLCA2MF1cclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChhcmMpO1xyXG4gKi9cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmxvd05vZGUnKS5leHRlbmQoe1xyXG5cclxuICAgICAgICB0eXBlOiAnQXJjJyxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IHNoYXBlIOW9oueKtuWPguaVsFxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUucj0wIOWNiuW+hOOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUuc3RhcnRBbmdsZT0wIOW8gOWni+W8p+W6puOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUuZW5kQW5nbGU9TWF0aC5QSSAqIDIgIOe7k+adn+W8p+W6puOAglxyXG4gICAgICAgICAqIEBjZmcge0Jvb2xlYW59IHNoYXBlLmNsb2Nrd2lzZT10cnVlIOaYr+WQpumhuuaXtumSiOOAglxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIGN4OiAwLFxyXG4gICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgcjogMCxcclxuICAgICAgICAgICAgc3RhcnRBbmdsZTogMCxcclxuICAgICAgICAgICAgZW5kQW5nbGU6IE1hdGguUEkgKiAyLFxyXG4gICAgICAgICAgICBjbG9ja3dpc2U6IHRydWVcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzdHlsZToge1xyXG5cclxuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXHJcblxyXG4gICAgICAgICAgICBmaWxsOiBudWxsXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS5jeDtcclxuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS5jeTtcclxuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLm1heChzaGFwZS5yLCAwKTtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBzaGFwZS5zdGFydEFuZ2xlO1xyXG4gICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBzaGFwZS5lbmRBbmdsZTtcclxuICAgICAgICAgICAgdmFyIGNsb2Nrd2lzZSA9IHNoYXBlLmNsb2Nrd2lzZTtcclxuXHJcbiAgICAgICAgICAgIHZhciB1bml0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xyXG4gICAgICAgICAgICB2YXIgdW5pdFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcclxuXHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8odW5pdFggKiByICsgeCwgdW5pdFkgKiByICsgeSk7XHJcbiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsICFjbG9ja3dpc2UpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdXBkYXRlU2hhcGU6IGZ1bmN0aW9uIChyYXRpbywgaWZQYXJzZSkge1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVSYXRpbyA9IE51bWJlcihyYXRpbyk7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XHJcbiAgICAgICAgICAgIHZhciBuZXdSID0gTnVtYmVyKHNoYXBlLnIgKiBzY2FsZVJhdGlvKTtcclxuICAgICAgICAgICAgaWYgKGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgICAgIG5ld1IgPSBwYXJzZUludChuZXdSLCAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8g5oyJ5q+U5L6L57yp5pS+XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U2hhcGUoe1xyXG4gICAgICAgICAgICAgICAgcjogbmV3UlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9BcmMuanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vKipcclxuICog5pif5b2iPGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93Lm5vZGUuU3RhclxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpKTtcclxuICogICAgICAgdmFyIHN0YXIgPSBuZXcgbm9kZS5TdGFyKHtcclxuICogICAgICAgICAgIHNoYXBlOiB7bjo3LCByOjMwfSwgIC8vcuWNiuW+hCBu5Yeg5Liq6KeSXHJcbiAqICAgICAgICAgICBwb3NpdGlvbjpbNjAsNjBdXHJcbiAqICAgICAgIH0pO1xyXG4gKiAgICAgICBmaXNoVG9wby5hZGQoc3Rhcik7XHJcbiAqL1xyXG5cclxuICAgIHZhciBQSSA9IE1hdGguUEk7XHJcblxyXG4gICAgdmFyIGNvcyA9IE1hdGguY29zO1xyXG4gICAgdmFyIHNpbiA9IE1hdGguc2luO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Zsb3dOb2RlJykuZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgdHlwZTogJ1N0YXInLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gc2hhcGUg5b2i54q25Y+C5pWwXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5uPTMg5Yeg5Liq6KeS44CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5yPTAg5aSW5Y2K5b6E44CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5yMD0wIOWGheWNiuW+hOOAglxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIGN4OiAwLFxyXG4gICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgbjogMyxcclxuICAgICAgICAgICAgcjA6IG51bGwsXHJcbiAgICAgICAgICAgIHI6IDBcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbiA9IHNoYXBlLm47XHJcbiAgICAgICAgICAgIGlmICghbiB8fCBuIDwgMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLmN4O1xyXG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLmN5O1xyXG4gICAgICAgICAgICB2YXIgciA9IHNoYXBlLnI7XHJcbiAgICAgICAgICAgIHZhciByMCA9IHNoYXBlLnIwO1xyXG5cclxuICAgICAgICAgICAgLy8g5aaC5p6c5pyq5oyH5a6a5YaF6YOo6aG254K55aSW5o6l5ZyG5Y2K5b6E77yM5YiZ6Ieq5Yqo6K6h566XXHJcbiAgICAgICAgICAgIGlmIChyMCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByMCA9IG4gPiA0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g55u46ZqU55qE5aSW6YOo6aG254K555qE6L+e57q/55qE5Lqk54K577yMXHJcbiAgICAgICAgICAgICAgICAgICAgLy8g6KKr5Y+W5Li65YaF6YOo5Lqk54K577yM5Lul5q2k6K6h566XcjBcclxuICAgICAgICAgICAgICAgICAgICA/IHIgKiBjb3MoMiAqIFBJIC8gbikgLyBjb3MoUEkgLyBuKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIOS6jOS4ieWbm+inkuaYn+eahOeJueauiuWkhOeQhlxyXG4gICAgICAgICAgICAgICAgICAgIDogciAvIDM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkU3RlcCA9IFBJIC8gbjtcclxuICAgICAgICAgICAgdmFyIGRlZyA9IC1QSSAvIDI7XHJcbiAgICAgICAgICAgIHZhciB4U3RhcnQgPSB4ICsgciAqIGNvcyhkZWcpO1xyXG4gICAgICAgICAgICB2YXIgeVN0YXJ0ID0geSArIHIgKiBzaW4oZGVnKTtcclxuICAgICAgICAgICAgZGVnICs9IGRTdGVwO1xyXG5cclxuICAgICAgICAgICAgLy8g6K6w5b2V6L6555WM54K577yM55So5LqO5Yik5pataW5zaWRlXHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeFN0YXJ0LCB5U3RhcnQpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZW5kID0gbiAqIDIgLSAxLCByaTsgaSA8IGVuZDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICByaSA9IGkgJSAyID09PSAwID8gcjAgOiByO1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgcmkgKiBjb3MoZGVnKSwgeSArIHJpICogc2luKGRlZykpO1xyXG4gICAgICAgICAgICAgICAgZGVnICs9IGRTdGVwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1cGRhdGVTaGFwZTogZnVuY3Rpb24gKHJhdGlvLCBpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZVJhdGlvID0gTnVtYmVyKHJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcclxuICAgICAgICAgICAgdmFyIG5ld1IgPSBOdW1iZXIoc2hhcGUuciAqIHNjYWxlUmF0aW8pO1xyXG4gICAgICAgICAgICBpZiAoaWZQYXJzZSkge1xyXG4gICAgICAgICAgICAgICAgbmV3UiA9IHBhcnNlSW50KG5ld1IsIDEwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDmjInmr5TkvovnvKnmlL5cclxuICAgICAgICAgICAgdGhpcy5zZXRTaGFwZSh7XHJcbiAgICAgICAgICAgICAgICByOiBuZXdSXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1N0YXIuanNcbi8vIG1vZHVsZSBpZCA9IDExM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vKipcclxuICog5peL6L2u5puy57q/PGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93Lm5vZGUuVHJvY2hvaWRcclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93Lm5vZGVcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgIHZhciBub2RlID0gZmlzaFRvcG9GbG93Lm5vZGU7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSk7XHJcbiAqICAgICAgIHZhciB0cm9jaG9pZCA9IG5ldyBub2RlLlRyb2Nob2lkKHtcclxuICogICAgICAgICAgIHNoYXBlOiB7cjo1MCwgcjA6MzUsIGQ6MzAsIGxvY2F0aW9uOm51bGx9LCAgLy9y5Y2K5b6EIG7lh6DkuKrop5JcclxuICogICAgICAgICAgIHBvc2l0aW9uOls2MCw2MF0sXHJcbiAqICAgICAgICAgICB0b29sdGlwOiBcIuaXi+i9ruabsue6v1wiXHJcbiAqICAgICAgIH0pO1xyXG4gKiAgICAgICBmaXNoVG9wby5hZGQodHJvY2hvaWQpO1xyXG4gKi9cclxuXHJcblxyXG4gICAgdmFyIGNvcyA9IE1hdGguY29zO1xyXG4gICAgdmFyIHNpbiA9IE1hdGguc2luO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Zsb3dOb2RlJykuZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgdHlwZTogJ1Ryb2Nob2lkJyxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IHNoYXBlIOW9oueKtuWPguaVsFxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUucj0wIOWkluWNiuW+hOOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUucjA9MCDlhoXljYrlvoTjgIJcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLmQ9MFxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUubG9jYXRpb249J291dCdcclxuICAgICAgICAgKi9cclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgY3k6IDAsXHJcbiAgICAgICAgICAgIHI6IDAsXHJcbiAgICAgICAgICAgIHIwOiAwLFxyXG4gICAgICAgICAgICBkOiAwLFxyXG4gICAgICAgICAgICBsb2NhdGlvbjogJ291dCdcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwJyxcclxuXHJcbiAgICAgICAgICAgIGZpbGw6IG51bGxcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciB4MTtcclxuICAgICAgICAgICAgdmFyIHkxO1xyXG4gICAgICAgICAgICB2YXIgeDI7XHJcbiAgICAgICAgICAgIHZhciB5MjtcclxuICAgICAgICAgICAgdmFyIFIgPSBzaGFwZS5yO1xyXG4gICAgICAgICAgICB2YXIgciA9IHNoYXBlLnIwO1xyXG4gICAgICAgICAgICB2YXIgZCA9IHNoYXBlLmQ7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXRYID0gc2hhcGUuY3g7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXRZID0gc2hhcGUuY3k7XHJcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IHNoYXBlLmxvY2F0aW9uID09ICdvdXQnID8gMSA6IC0xO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNoYXBlLmxvY2F0aW9uICYmIFIgPD0gcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbnVtID0gMDtcclxuICAgICAgICAgICAgdmFyIGkgPSAxO1xyXG4gICAgICAgICAgICB2YXIgdGhldGE7XHJcblxyXG4gICAgICAgICAgICB4MSA9IChSICsgZGVsdGEgKiByKSAqIGNvcygwKVxyXG4gICAgICAgICAgICAgICAgLSBkZWx0YSAqIGQgKiBjb3MoMCkgKyBvZmZzZXRYO1xyXG4gICAgICAgICAgICB5MSA9IChSICsgZGVsdGEgKiByKSAqIHNpbigwKVxyXG4gICAgICAgICAgICAgICAgLSBkICogc2luKDApICsgb2Zmc2V0WTtcclxuXHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcclxuXHJcbiAgICAgICAgICAgIC8vIOiuoeeul+e7k+adn+aXtueahGlcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgbnVtKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUgKChyICogbnVtKSAlIChSICsgZGVsdGEgKiByKSAhPT0gMCk7XHJcblxyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICB0aGV0YSA9IE1hdGguUEkgLyAxODAgKiBpO1xyXG4gICAgICAgICAgICAgICAgeDIgPSAoUiArIGRlbHRhICogcikgKiBjb3ModGhldGEpXHJcbiAgICAgICAgICAgICAgICAgICAgIC0gZGVsdGEgKiBkICogY29zKChSIC8gciArICBkZWx0YSkgKiB0aGV0YSlcclxuICAgICAgICAgICAgICAgICAgICAgKyBvZmZzZXRYO1xyXG4gICAgICAgICAgICAgICAgeTIgPSAoUiArIGRlbHRhICogcikgKiBzaW4odGhldGEpXHJcbiAgICAgICAgICAgICAgICAgICAgIC0gZCAqIHNpbigoUiAvIHIgKyBkZWx0YSkgKiB0aGV0YSlcclxuICAgICAgICAgICAgICAgICAgICAgKyBvZmZzZXRZO1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlIChpIDw9IChyICogbnVtKSAvIChSICsgZGVsdGEgKiByKSAqIDM2MCk7XHJcblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdXBkYXRlU2hhcGU6IGZ1bmN0aW9uIChyYXRpbywgaWZQYXJzZSkge1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVSYXRpbyA9IE51bWJlcihyYXRpbyk7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XHJcbiAgICAgICAgICAgIHZhciBuZXdSID0gTnVtYmVyKHNoYXBlLnIgKiBzY2FsZVJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIG5ld1IwID0gTnVtYmVyKHNoYXBlLnIwICogc2NhbGVSYXRpbyk7XHJcbiAgICAgICAgICAgIHZhciBuZXdEID0gTnVtYmVyKHNoYXBlLmQgKiBzY2FsZVJhdGlvKTtcclxuICAgICAgICAgICAgbmV3UiA9IHBhcnNlSW50KG5ld1IsIDEwKTtcclxuICAgICAgICAgICAgbmV3UjAgPSBwYXJzZUludChuZXdSMCwgMTApO1xyXG4gICAgICAgICAgICBuZXdEID0gcGFyc2VJbnQobmV3RCwgMTApO1xyXG4gICAgICAgICAgICAvLyDmjInmr5TkvovnvKnmlL5cclxuICAgICAgICAgICAgdGhpcy5zZXRTaGFwZSh7XHJcbiAgICAgICAgICAgICAgICByOiBuZXdSLFxyXG4gICAgICAgICAgICAgICAgcjA6IG5ld1IwLFxyXG4gICAgICAgICAgICAgICAgZDogbmV3RFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9Ucm9jaG9pZC5qc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDot6/lvoQ8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubm9kZS5QYXRoXHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIHZhciBwYXRoID0gbmV3IG5vZGUuUGF0aCh7XHJcbiAqICAgICAgICAgICBwYXRoRGF0YTogJ005IDBsOCA4LTE3IDE3IDcgNyAxNy0xNyA4IDh2LTIzaC0yM3onLFxyXG4gKiAgICAgICAgICAgcmVjdDoge3g6MCx5OjAsd2lkdGg6MzAsaGVpZ2h0OjMwfSxcclxuICogICAgICAgICAgIHBvc2l0aW9uOiBbNjAsNjBdXHJcbiAqICAgICAgIH0pO1xyXG4gKiAgICAgICBmaXNoVG9wby5hZGQocGF0aCk7XHJcbiAqL1xyXG5cclxuICAgIHZhciBwYXRoVG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3Rvb2wvcGF0aCcpO1xyXG4gICAgdmFyIERyYWdnYWJsZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL21peGluL0RyYWdnYWJsZScpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGZsb3dOb2RlID0gcmVxdWlyZSgnLi9mbG93Tm9kZScpO1xyXG5cclxuICAgIGZ1bmN0aW9uIFpQYXRoKG9wdHMpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IG9wdGlvbnMg5Y+C5pWwXHJcbiAgICAgICAgICogQGNmZyB7U3RyaW5nfSBvcHRpb25zLnBhdGhEYXRhIHBhdGjmlbDmja7jgIJcclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IG9wdGlvbnMucmVjdCDlm77lvaLnmoTlpKflsI/jgIJcclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IG9wdGlvbnMucmVjdC53aWR0aCDlm77lvaLnmoTlrr3luqbjgIJcclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IG9wdGlvbnMucmVjdC5oZWlnaHQg5Zu+5b2i55qE6auY5bqm44CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBbb3B0aW9ucy5sYXlvdXQ9bnVsbF0g6buY6K6k5Li6bnVsbCAg5LuF5pSv5oyBXCJjZW50ZXJcIlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBzdHlsZTp7IGZpbGw6ICdub25lJyxzdHJva2U6ICcjMmMyYzJjJ30sXHJcbiAgICAgICAgICAgIHJlY3Q6e3g6MCx5OjAsd2lkdGg6MCxoZWlnaHQ6MH0sXHJcbiAgICAgICAgICAgIHJlY3RIb3ZlcjogdHJ1ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHBhdGhEYXRhID0gb3B0cy5wYXRoRGF0YTtcclxuICAgICAgICB2YXIgbW9kZWwgPSBmbG93Tm9kZS5nZW5Nb2RlbChcIlBhdGhcIiwgb3B0cyk7XHJcbiAgICAgICAgZGVsZXRlIG9wdHMucGF0aERhdGE7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0genJVdGlsLm1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRzLCB0cnVlKTtcclxuICAgICAgICB2YXIgcGF0aCA9IHBhdGhUb29sLmNyZWF0ZUZyb21TdHJpbmcocGF0aERhdGEsIHRoaXMub3B0aW9ucyk7XHJcbiAgICAgICAgcGF0aC5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgIERyYWdnYWJsZS5jYWxsKHBhdGgpO1xyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5vcHRpb25zLnJlY3Q7XHJcbiAgICAgICAgdmFyIGxheW91dCA9IG9wdHMubGF5b3V0O1xyXG4gICAgICAgIGlmIChyZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBhc3BlY3QgPSBib3VuZGluZ1JlY3Qud2lkdGggLyBib3VuZGluZ1JlY3QuaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGxheW91dCA9PT0gJ2NlbnRlcicpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNldCByZWN0IHRvIGNlbnRlciwga2VlcCB3aWR0aCAvIGhlaWdodCByYXRpby5cclxuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHJlY3QuaGVpZ2h0ICogYXNwZWN0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodDtcclxuICAgICAgICAgICAgICAgIGlmICh3aWR0aCA8PSByZWN0LndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY3ggPSByZWN0LnggKyByZWN0LndpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHZhciBjeSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMjtcclxuXHJcbiAgICAgICAgICAgICAgICByZWN0LnggPSBjeCAtIHdpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHJlY3QueSA9IGN5IC0gaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgICAgIHJlY3Qud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgICAgIHJlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVBhdGgocGF0aCwgcmVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhdGgudHlwZSA9ICdaUGF0aCc7XHJcbiAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICB9XHJcblxyXG4gICAgWlBhdGgucHJvdG90eXBlID0ge1xyXG5cclxuICAgICAgICBjb25zdHJ1Y3RvcjogWlBhdGgsXHJcblxyXG4gICAgICAgIHR5cGU6ICdaUGF0aCcsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzaXplIGEgcGF0aCB0byBmaXQgdGhlIHJlY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICByZXNpemVQYXRoOiBmdW5jdGlvbiAocGF0aCwgcmVjdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwYXRoLmFwcGx5VHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwYXRoUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG0gPSBwYXRoUmVjdC5jYWxjdWxhdGVUcmFuc2Zvcm0ocmVjdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcGF0aC5hcHBseVRyYW5zZm9ybShtKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZVNoYXBlOiBmdW5jdGlvbiAocmF0aW8sIGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgdmFyIHNjYWxlUmF0aW8gPSBOdW1iZXIocmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMucmVjdDtcclxuICAgICAgICAgICAgdmFyIG5ld1cgPSBOdW1iZXIocmVjdC53aWR0aCAqIHNjYWxlUmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgbmV3SCA9IE51bWJlcihuZXdXICogcmVjdC5oZWlnaHQgLyByZWN0LndpZHRoKTtcclxuICAgICAgICAgICAgaWYgKGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgICAgIG5ld1cgPSBwYXJzZUludChuZXdXLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBuZXdIID0gcGFyc2VJbnQobmV3SCwgMTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlY3Qud2lkdGggPSBuZXdXO1xyXG4gICAgICAgICAgICByZWN0LmhlaWdodCA9IG5ld0g7XHJcbiAgICAgICAgICAgIC8vIOaMieavlOS+i+e8qeaUvlxyXG4gICAgICAgICAgICB0aGlzLmF0dHIoJ3JlY3QnLCByZWN0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB6clV0aWwuaW5oZXJpdHMoWlBhdGgsIERyYWdnYWJsZSk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFpQYXRoO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9QYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOWbvuW9ouaMiemSrjxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5ub2RlLkljb25CdXR0b25cclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93Lm5vZGVcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgIHZhciBub2RlID0gZmlzaFRvcG9GbG93Lm5vZGU7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSwge3JvYW06ZmFsc2V9KTtcclxuICogICAgICAgdmFyIGljb25CdXR0b24gICA9IG5ldyBub2RlLkljb25CdXR0b24oe1xyXG4gKiAgICAgICAgICB0aXRsZTonSWNvbkJ1dHRvbicsXHJcbiAqICAgICAgICAgIGljb246J3BhdGg6Ly9NNDMyLjQ1LDU5NS40NDRjMCwyLjE3Ny00LjY2MSw2LjgyLTExLjMwNSw2LjgyYy02LjQ3NSwwLTExLjMwNi00LjU2Ny0xMS4zMDYtNi44MnM0Ljg1Mi02LjgxMiwxMS4zMDYtNi44MTJDNDI3Ljg0MSw1ODguNjMyLDQzMi40NTIsNTkzLjE5MSw0MzIuNDUsNTk1LjQ0NEw0MzIuNDUsNTk1LjQ0NHogTTQyMS4xNTUsNTg5Ljg3NmMtMy4wMDksMC01LjQ0OCwyLjQ5NS01LjQ0OCw1LjU3MnMyLjQzOSw1LjU3Miw1LjQ0OCw1LjU3MmMzLjAxLDAsNS40NDktMi40OTUsNS40NDktNS41NzJDNDI2LjYwNCw1OTIuMzcxLDQyNC4xNjUsNTg5Ljg3Niw0MjEuMTU1LDU4OS44NzZMNDIxLjE1NSw1ODkuODc2eiBNNDIxLjE0Niw1OTEuODkxYy0xLjkxNiwwLTMuNDcsMS41ODktMy40NywzLjU0OWMwLDEuOTU5LDEuNTU0LDMuNTQ4LDMuNDcsMy41NDhzMy40NjktMS41ODksMy40NjktMy41NDhDNDI0LjYxNCw1OTMuNDc5LDQyMy4wNjIsNTkxLjg5MSw0MjEuMTQ2LDU5MS44OTFMNDIxLjE0Niw1OTEuODkxek00MjEuMTQ2LDU5MS44OTEnLFxyXG4gKiAgICAgICAgICBpdGVtU2l6ZTo1MCxcclxuICogICAgICAgICAgcG9zaXRpb246WzYwLDYwXVxyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgZmlzaFRvcG8uYWRkKGljb25CdXR0b24pO1xyXG4gKi9cclxuXHJcblxyXG5cclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIGZsb3dOb2RlID0gcmVxdWlyZSgnLi9mbG93Tm9kZScpO1xyXG5cclxuICAgIGZ1bmN0aW9uIEljb25CdXR0b24ob3B0cykge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IG9wdGlvbnMg5p6E6YCg5Y+C5pWwXHJcbiAgICAgICAgICogQGNmZyB7U3RyaW5nfSBvcHRpb25zLnRpdGxlPVwiXCIg6byg5qCH56e75LiK5Y675pi+56S655qE5paH5a2XXHJcbiAgICAgICAgICogQGNmZyB7U3RyaW5nfSBvcHRpb25zLmljb249XCJcIiBJY29uIOeahCBwYXRoIOWtl+espuS4su+8jOaUr+aMgeS9v+eUqOiHquWumuS5ieeahCBzdmcgcGF0aCDkvZzkuLogaWNvbu+8jOagvOW8j+WPguingSBbU1ZHIFBhdGhEYXRhXShodHRwczovL3d3dy53My5vcmcvVFIvU1ZHL3BhdGhzLmh0bWwjUGF0aERhdGEp44CC5Y+v5Lul5LuOIEFkb2JlIElsbHVzdHJhdG9yIOetieW3peWFt+e8lui+keWvvOWHuuOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gb3B0aW9ucy5pdGVtU2l6ZT0xNSAgaWNvbiDnmoTlpKflsI9cclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IG9wdGlvbnMuaWNvblN0eWxlICDlm77moIfmoLflvI9cclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IG9wdGlvbnMuaWNvblN0eWxlLm5vcm1hbCDmraPluLjnmoTmoLflvI9cclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IG9wdGlvbnMuaWNvblN0eWxlLm5vcm1hbC5zdHJva2U9JyM2NjYnIOato+W4uOeahOagt+W8j++8iOaPj+i+ueiJsu+8iVxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gb3B0aW9ucy5pY29uU3R5bGUubm9ybWFsLmZpbGw9J25vbmUnIOato+W4uOeahOagt+W8j++8iOWhq+WFheiJsu+8iVxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gb3B0aW9ucy5pY29uU3R5bGUuZW1waGFzaXMg6auY5Lqu54q25oCB5LiL55qE5qC35byPXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBvcHRpb25zLmljb25TdHlsZS5lbXBoYXNpcy5zdHJva2U9JyM2NjYnIOmrmOS6rueKtuaAgeS4i+eahOagt+W8j++8iOaPj+i+ueiJsu+8iVxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gb3B0aW9ucy5pY29uU3R5bGUuZW1waGFzaXMuZmlsbD0nbm9uZScg6auY5Lqu54q25oCB5LiL55qE5qC35byP77yI5aGr5YWF6Imy77yJXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnI2NjYycsXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTpmYWxzZSxcclxuICAgICAgICAgICAgc2VsZWN0YWJsZTpmYWxzZSxcclxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGl0ZW1TaXplOiAxNSxcclxuICAgICAgICAgICAgc2hvd1RpdGxlOiB0cnVlLFxyXG4gICAgICAgICAgICBpY29uOlwiXCIsICAvL0ljb24g55qEIHBhdGgg5a2X56ym5Liy77yM5pSv5oyB5L2/55So6Ieq5a6a5LmJ55qEIHN2ZyBwYXRoIOS9nOS4uiBpY29u77yM5qC85byP5Y+C6KeBIFNWRyBQYXRoRGF0YeOAguWPr+S7peS7jiBBZG9iZSBJbGx1c3RyYXRvciDnrYnlt6XlhbfnvJbovpHlr7zlh7rjgIJcclxuICAgICAgICAgICAgaWNvblN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBub3JtYWw6IHtcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICcjNjY2JyxcclxuICAgICAgICAgICAgICAgICAgICBmaWxsOiAnbm9uZSdcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbXBoYXNpczoge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogJyMzRTk4YzUnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHpyVXRpbC5tZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0cywgdHJ1ZSk7XHJcblxyXG4gICAgICAgIHRoaXMubW9kZWwgPSBmbG93Tm9kZS5nZW5Nb2RlbChcIkljb25CdXR0b25cIiwgdGhpcy5vcHRpb25zKTtcclxuICAgICAgICBncmFwaGljLkdyb3VwLmNhbGwodGhpcywgdGhpcy5vcHRpb25zKTtcclxuICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgfVxyXG4gICAgSWNvbkJ1dHRvbi5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IEljb25CdXR0b24sXHJcbiAgICAgICAgdHlwZTogXCJJY29uQnV0dG9uXCIsXHJcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBub3JtYWxTdHlsZSA9IHRoaXMub3B0aW9ucy5pY29uU3R5bGUubm9ybWFsO1xyXG4gICAgICAgICAgICB2YXIgaG92ZXJTdHlsZSA9IHRoaXMub3B0aW9ucy5pY29uU3R5bGUuZW1waGFzaXM7XHJcbiAgICAgICAgICAgIHZhciBpdGVtU2l6ZSA9IHRoaXMub3B0aW9ucy5pdGVtU2l6ZTtcclxuICAgICAgICAgICAgdmFyIGljb24gPSB0aGlzLm9wdGlvbnMuaWNvbjtcclxuICAgICAgICAgICAgdmFyIHN0eWxlID0ge1xyXG4gICAgICAgICAgICAgICAgeDogLWl0ZW1TaXplIC8gMixcclxuICAgICAgICAgICAgICAgIHk6IC1pdGVtU2l6ZSAvIDIsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogaXRlbVNpemUsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGl0ZW1TaXplXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBwYXRoID0gaWNvbi5pbmRleE9mKCdpbWFnZTovLycpID09PSAwID9cclxuICAgICAgICAgICAgICAgIChcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZS5pbWFnZSA9IGljb24uc2xpY2UoOCksXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IGdyYXBoaWMuSW1hZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogc3R5bGVcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgKSA6XHJcbiAgICAgICAgICAgICAgICBncmFwaGljLm1ha2VQYXRoKFxyXG4gICAgICAgICAgICAgICAgICAgIGljb24ucmVwbGFjZSgncGF0aDovLycsICcnKSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogbm9ybWFsU3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdmVyU3R5bGU6IGhvdmVyU3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RIb3ZlcjogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgJ2NlbnRlcidcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBncmFwaGljLnNldEhvdmVyU3R5bGUocGF0aCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNob3dUaXRsZSkge1xyXG4gICAgICAgICAgICAgICAgcGF0aC5fX3RpdGxlID0gdGhpcy5vcHRpb25zLnRpdGxlO1xyXG4gICAgICAgICAgICAgICAgcGF0aC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG91bGQgbm90IHJldXNlIGFib3ZlIGhvdmVyU3R5bGUsIHdoaWNoIG1pZ2h0IGJlIG1vZGlmaWVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLnNldFN0eWxlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMub3B0aW9ucy50aXRsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRQb3NpdGlvbjogaG92ZXJTdHlsZS50ZXh0UG9zaXRpb24gfHwgJ2JvdHRvbScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0RmlsbDogaG92ZXJTdHlsZS5maWxsIHx8IGhvdmVyU3R5bGUuc3Ryb2tlIHx8ICcjMDAwJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogaG92ZXJTdHlsZS50ZXh0QWxpZ24gfHwgJ2NlbnRlcidcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguc2V0U3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEZpbGw6IG51bGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHBhdGgudHJpZ2dlcignbm9ybWFsJyk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB6clV0aWwuaW5oZXJpdHMoSWNvbkJ1dHRvbiwgZ3JhcGhpYy5Hcm91cCk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEljb25CdXR0b247XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBleHRlbmRcclxuICogQGhpZGVcclxuICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvSWNvbkJ1dHRvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxyXG4gKiBmaXNoVG9wb0Zsb3fnmoRsaW5r5a+56LGh77yM5qGG5p625o+Q5L6b55qE6L+e57q/6YO95pS+5Zyo6L+Z5Liq5a+56LGh5LiL44CCXHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubGlua1xyXG4gKiBAYWJzdHJhY3RcclxuICovXHJcblxyXG4gICAgdmFyIExpbmsgPSByZXF1aXJlKCcuL0xpbmsnKTtcclxuICAgIHZhciBGb2xkID0gcmVxdWlyZSgnLi9Gb2xkJyk7XHJcbiAgICB2YXIgQ3VydmUgPSByZXF1aXJlKCcuL0N1cnZlJyk7XHJcbiAgICB2YXIgQ2hhaW4gPSByZXF1aXJlKCcuL0NoYWluJyk7XHJcbiAgICB2YXIgQ29ubmVjdG9yID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG4gICAgdmFyIGZsb3dMaW5rID0ge307XHJcbiAgICBmbG93TGluay5MaW5rID0gZmxvd0xpbmtbQ29ubmVjdG9yLlRZUEVfU1RSQUlHSFRdID0gTGluaztcclxuICAgIGZsb3dMaW5rLkZvbGQgPSBmbG93TGlua1tDb25uZWN0b3IuVFlQRV9KQUdHRURdID0gRm9sZDtcclxuICAgIGZsb3dMaW5rLkN1cnZlID0gZmxvd0xpbmtbQ29ubmVjdG9yLlRZUEVfQ1VSVkVdID0gQ3VydmU7XHJcbiAgICBmbG93TGluay5DaGFpbiA9IGZsb3dMaW5rW0Nvbm5lY3Rvci5UWVBFX0NIQUlOXSA9IENoYWluO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmbG93TGluaztcclxuXHJcblxyXG4vKipcclxuICogQG1ldGhvZCBjb25zdHJ1Y3RvclxyXG4gKiDov57nur/nmoTmnoTpgKDlh73mlbBcclxuICogQHBhcmFtICB7T2JqZWN0fSBzdGFydE5vZGUg5byA5aeL6IqC54K5XHJcbiAqIEBwYXJhbSAge09iamVjdH0gZW5kTm9kZSAgIOe7k+adn+iKgueCuVxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMg57q/5q616YCJ6aG5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5zdHlsZV0g6IqC54K555qE5qC35byPXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zdHlsZS5saW5lV2lkdGg9MV0g57q/5q6155qE5a695bqmXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zdHlsZS5saW5lVHlwZT0nc3RyYWlnaHQnXSDnur/mrrXnmoTnsbvlnosgZWcuICdzdHJhaWdodCcsICdqYWdnZWQnLCdjdXJ2ZSdcclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN0eWxlLnN0cm9rZT1cIiMwMDAwMDBcIl0g57q/5q6155qE6aKc6Imy5YC8IGVnLiAnIzE1N2NmZicgICdyZ2IoMTIyLDEyMiwxMjIpJ1xyXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMuc3R5bGUubGluZURhc2hdIOiZmue6v+eahOmXtOmalCBlZy4gWzMsM11cclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnN5bWJvbF0g57q/5q6155qE566t5aS0XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zeW1ib2wudHlwZT0nYXJyb3cnXSDnur/mrrXnmoTnrq3lpLTnmoTnsbvlnosg5Y+v6YCJ5YC85Li677yaICdjaXJjbGUnLCAncmVjdCcsICdyb3VuZFJlY3QnLCAndHJpYW5nbGUnLCAnZGlhbW9uZCcsICdwaW4nLCAnYXJyb3cnXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zeW1ib2wuc2l6ZT0xMF0g57q/5q6155qE566t5aS055qE5bC65a+4XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zeW1ib2wuY29sb3I9JyMwMDAwMDAnXSDnur/mrrXnmoTnrq3lpLTnmoTpopzoibJcclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN5bWJvbC56XSBb566t5aS055qE5bGC57qn77yM6LaK5aSn6LaK5Zyo5YmN6Z2i5pi+56S6XVxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN5bWJvbC5ib3RoXSBb5oyH5a6a5piv5ZCm5Zyo6L+e57q/55qE6aaW5LiO5bC+6YO955S7566t5aS0IOm7mOiupOaYr2ZhbHNlXVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3ltYm9sLm9mZnNldF0g6K6+572u566t5aS05Zyo6L+e57q/5LiK55qE5YGP56e76YeP77yM6buY6K6k5pivMO+8m+atpOWxnuaAp+WPqumSiOWvueebtOe6v+WSjOaKmOe6v+exu+Wei+acieaViO+8jOWmguaenOaYr+aKmOe6v++8jG9mZnNldOacgOWkp+WAvOS4jeiDvei2hei/h29wdGlvbnMuYnVuZGxlT2Zmc2V0KOm7mOiupOaYrzMwKeiuvue9rueahOWAvCBzaW5jZSBWMi4zLjBcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnRleHRdIOe6v+auteS4iueahOaWh+Wtl1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGV4dC50ZXh0XSDnur/mrrXkuIrnmoTmloflrZflhoXlrrlcclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRleHQuY29sb3JdIOe6v+auteS4iueahOaWh+Wtl+minOiJslxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGV4dC50ZXh0Rm9udF0g57q/5q615LiK55qE5paH5a2X5a2X5L2TXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50ZXh0LnRleHRQb3NdIOaWh+Wtl+S9jee9ruWPr+mAieWAvCAnc3RhcnQnLCdjZW50ZXInLCdlbmQnLOm7mOiupOWAvOS4umNlbnRlclxyXG4gKiBAcGFyYW0ge051bWJlcnxBcnJheX0gW29wdGlvbnMudGV4dC5vZmZzZXRdIOaWh+Wtl+S9jee9ruWBj+enu+mHjyzkuLpudW1iZXLliJnmmK945YGP56e7IGFycmF55YiZ5Li6W3gseV1cclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50ZXh0LnRleHRSb3RhdGVhYmxlXSDmloflrZfpmo/nur/mrrXml4vovawsIOm7mOiupOWAvOS4unRydWVcclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc10g5L+d55WZIOivt+S9v+eUqG9wdGlvbnMucG9zaXRpb24uZGlyZWN0aW9uIOaMh+Wumue6v+autei1t+Wni+S4jue7iOatoiDlnKjoioLngrnnmoTku4DkuYjkvY3nva4g6buY6K6k5YC85Li6J2xlZnQscmlnaHQnICDlj6/lj5blgLzlm5vkuKrmlrnlkJF0b3AsYm90dG9tLGxlZnQscmlnaHQg5pa55ZCR5Y+v5Yqg5YGP56e76YeP5aaC5aaCIFwibGVmdCsxMCx0b3BcIlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb25dIOaMh+Wumue6v+auteS9jee9rlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucG9zaXRpb24uZGlyZWN0aW9uXSDmjIflrprnur/mrrXotbflp4vkuI7nu4jmraIg5Zyo6IqC54K555qE5LuA5LmI5L2N572uIOm7mOiupOWAvOS4uidsZWZ0LHJpZ2h0JyAg5Y+v5Y+W5YC85Zub5Liq5pa55ZCRdG9wLGJvdHRvbSxsZWZ0LHJpZ2h0IOaWueWQkeWPr+WKoOWBj+enu+mHj+WmguWmgiBcImxlZnQrMTAsdG9wXCJcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBvc2l0aW9uLnN0YXJ0T2Zmc2V0XSDnur/mrrXlvIDlp4vkvY3nva7nmoTlgY/np7tcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBvc2l0aW9uLmVuZE9mZnNldF0g57q/5q6157uT5p2f5L2N572u55qE5YGP56e7XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbi5lc2NhcGVEaXN0YW5jZV0g5oyH5a6a57q/5q6156ys5LiA5p2h5oqY57q/55qE6ZW/5bqm77yM5pyA5ZCO5LiA5p2h5oqY57q/55qE6ZW/5bqm77yM6buY6K6k5YC85Li6WzMwLCAzMF1cclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uLnBvaW50c10g5LiN5L2/55So6Ieq5Yqo6K6h566XIOaMh+Wumui/nue6v+eahOaKmOeCueS9jee9ruaVsOe7hO+8jOmmluWwvuWPr+S7peS9v+eUqGxlZnQscmlnaHQsdG9wLGJvdHRvbVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZWZmZWN0XSDnur/kuIrliqjmgIHmlYjmnpxcclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmVmZmVjdC5zaG93XSDmmK/lkKbmmL7npLrnrq3lpLTliqjmlYhcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmVmZmVjdC5wZXJpb2RdIOWKqOaViOenu+WKqOmAn+W6plxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9DaGFuZ2VQb3NpdGlvbl0g6L+e57q/55qE6L+e5o6l54K56ZqPbm9kZeenu+WKqOiHquWKqOWIh+aNouS9jee9ru+8jOm7mOiupOS4umZsYXNlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy56XSDov57nur/nmoTlsYLnuqfvvIzotorlpKfotorlnKjliY3pnaLmmL7npLpcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJ1bmRsZU9mZnNldD0zMF0g5ouG57q/5ouQ6KeS5aSE55qE6ZW/5bqmKOeUqOS6jui/nue6v+e7hClcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJ1bmRsZUdhcD0yMF0g5aSa57q/5q6155qE6Ze06ZqUKOeUqOS6jui/nue6v+e7hClcclxuICogQHJldHVybiB7T2JqZWN0fSDov5Tlm57liJvlu7rmiJDlip/nmoTov57nur/lr7nosaFcclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgc2V0U3R5bGVcclxuICog5Yib5bu66L+e57q/5ZCO77yM6K6+572u6L+e57q/55qE5qC35byPXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIOWvueW6lOWIm+W7uuiKgueCue+8jOS8oOmAkueahG9wdGlvbnPlj4LmlbBcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnRleHRdIOi/nue6v+aWh+Wtl+eahOagt+W8j1xyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc3ltYm9sXSDov57nur/nrq3lpLTnmoTmoLflvI9cclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNvbG9yXSDov57nur/nmoTpopzoibJcclxuICovXHJcbi8qKlxyXG4gKiBAbWV0aG9kIG9uXHJcbiAqIOe7keWumuS6i+S7tlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQg5LqL5Lu25ZCNXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5LqL5Lu25aSE55CG5Ye95pWwXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0g5LiK5LiL5paHXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgb2ZmXHJcbiAqIOino+e7keS6i+S7tlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQg5LqL5Lu25ZCNXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5LqL5Lu25aSE55CG5Ye95pWwXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgb25lXHJcbiAqIOWNleasoeinpuWPkee7keWumix0cmlnZ2Vy5ZCO6ZSA5q+BXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCDkuovku7blkI1cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDkuovku7blpITnkIblh73mlbBcclxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSDkuIrkuIvmlodcclxuICovXHJcblxyXG4vKipcclxuICogQG1ldGhvZCB0cmlnZ2VyXHJcbiAqIOS6i+S7tuWIhuWPkVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcclxuICovXHJcbi8qKlxyXG4gKiBAZXZlbnQgY2xpY2tcclxuICog5Y2V5Ye75LqL5Lu2XHJcbiAqXHJcbiAqIDxwcmU+XHJcbiAqIGZsaW5rLm9uKCdDb25uZWN0b3I6Y2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAqICAgLy9kbyBzb21ldGhpbmdcclxuICogfSlcclxuICogPC9wcmU+XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBldmVudCBkYmxjbGlja1xyXG4gKiDlvZPlj4zlh7vlhYPntKDml7bvvIzkvJrlj5HnlJ8gZGJsY2xpY2sg5LqL5Lu244CCXHJcbiAqXHJcbiAqIDxwcmU+XHJcbiAqIGZsaW5rLm9uKCdDb25uZWN0b3I6ZGJsY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAqICAgLy9kbyBzb21ldGhpbmdcclxuICogfSlcclxuICogPC9wcmU+XHJcbiAqL1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGluay9mbG93TGluay5qc1xuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDnm7Tnur88YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubGluay5MaW5rXHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5saW5rXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgbGluayA9IGZpc2hUb3BvRmxvdy5saW5rO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIC8v6IqC54K5XHJcbiAqICAgICAgIGZ1bmN0aW9uIG5ld05vZGUoeCwgeSwgdywgaCkge1xyXG4gKiAgICAgICAgICAgdmFyIHJlY3QgPSBuZXcgbm9kZS5SZWN0KHtcclxuICogICAgICAgICAgICAgICBzaGFwZToge3dpZHRoOiB3LGhlaWdodDogaH0sXHJcbiAqICAgICAgICAgICAgICAgcG9zaXRpb246IFt4LCB5XSxcclxuICogICAgICAgICAgICAgICBzdHlsZToge2ZpbGw6IFwiIzE2N0NGRlwifVxyXG4gKiAgICAgICAgICAgfSk7XHJcbiAqICAgICAgICAgICBmaXNoVG9wby5hZGQocmVjdCk7XHJcbiAqICAgICAgICAgICByZXR1cm4gcmVjdDtcclxuICogICAgICAgfVxyXG4gKiAgICAgICAvL+eugOWNlei/nue6v1xyXG4gKiAgICAgICBmdW5jdGlvbiBuZXdMaW5rKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgdGV4dCwgZGFzaGVkUGF0dGVybikge1xyXG4gKiAgICAgICAgICAgdmFyIHNsaW5rID0gbmV3IGxpbmsuTGluayhzdGFydE5vZGUsIGVuZE5vZGUsIHtcclxuICogICAgICAgICAgICAgICBzdHlsZToge2xpbmVEYXNoOiBbZGFzaGVkUGF0dGVybl19LFxyXG4gKiAgICAgICAgICAgICAgIHRleHQ6IHt0ZXh0OiB0ZXh0fVxyXG4gKiAgICAgICAgICAgfSlcclxuICogICAgICAgICAgIGZpc2hUb3BvLmFkZChzbGluayk7XHJcbiAqICAgICAgICAgICByZXR1cm4gc2xpbms7XHJcbiAqICAgICAgIH1cclxuICogICAgICAgdmFyIGZyb20gPSBuZXdOb2RlKDEwMCwgNjAsIDMwLCAzMCk7XHJcbiAqICAgICAgIHZhciB0byA9IG5ld05vZGUoMzAwLCA2MCwgMzAsIDMwKTtcclxuICogICAgICAgbmV3TGluayhmcm9tLCB0bywgJ+iZmue6v+W4pueureWktCcsIDUpO1xyXG4gKi9cclxuXHJcbiAgICB2YXIgQ29ubmVjdG9yID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG4gICAgdmFyIEZsb3cgPSByZXF1aXJlKFwiLi4vRmxvd1wiKTtcclxuXHJcbiAgICBmdW5jdGlvbiBMaW5rKHN0YXJ0Tm9kZSxlbmROb2RlLG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgb3B0ID0gRmxvdy50cmFuc2xhdGVMaW5rT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICAvL+m7mOiupOWwseaYr+ebtOe6v1xyXG4gICAgICAgIHZhciBjb25uZWN0b3IgPSBuZXcgQ29ubmVjdG9yKG9wdCk7XHJcbiAgICAgICAgY29ubmVjdG9yLnN0YXJ0Tm9kZSA9IHN0YXJ0Tm9kZTtcclxuICAgICAgICBjb25uZWN0b3IuZW5kTm9kZSA9IGVuZE5vZGU7XHJcblxyXG4gICAgICAgIHJldHVybiBjb25uZWN0b3I7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgY3JlYXRlQnlQb2ludFxyXG4gICAgICog55So5oi35oyH5a6a6L+e57q/55qE54K577yM5p2l6L+b6KGM55S757q/XHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMg57q/5q616YCJ6aG5XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc3R5bGVdIOiKgueCueeahOagt+W8j1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN0eWxlLmxpbmVXaWR0aD0xXSDnur/mrrXnmoTlrr3luqZcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zdHlsZS5saW5lVHlwZT0nc3RyYWlnaHQnXSDnur/mrrXnmoTnsbvlnosgZWcuICdzdHJhaWdodCcsICdqYWdnZWQnLCdjdXJ2ZSdcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zdHlsZS5zdHJva2U9XCIjMDAwMDAwXCJdIOe6v+auteeahOminOiJsuWAvCBlZy4gJyMxNTdjZmYnICAncmdiKDEyMiwxMjIsMTIyKSdcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5zdHlsZS5saW5lRGFzaF0g6Jma57q/55qE6Ze06ZqUIGVnLiBbMywzXVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnN5bWJvbF0g57q/5q6155qE566t5aS0XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3ltYm9sLnR5cGU9J2Fycm93J10g57q/5q6155qE566t5aS055qE57G75Z6LIOWPr+mAieWAvOS4uu+8miAnY2lyY2xlJywgJ3JlY3QnLCAncm91bmRSZWN0JywgJ3RyaWFuZ2xlJywgJ2RpYW1vbmQnLCAncGluJywgJ2Fycm93J1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN5bWJvbC5zaXplPTEwXSDnur/mrrXnmoTnrq3lpLTnmoTlsLrlr7hcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zeW1ib2wuY29sb3I9JyMwMDAwMDAnXSDnur/mrrXnmoTnrq3lpLTnmoTpopzoibJcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zeW1ib2wuel0gW+eureWktOeahOWxgue6p++8jOi2iuWkp+i2iuWcqOWJjemdouaYvuekul1cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3ltYm9sLmJvdGhdIFvmjIflrprmmK/lkKblnKjov57nur/nmoTpppbkuI7lsL7pg73nlLvnrq3lpLQg6buY6K6k5pivZmFsc2VdXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3ltYm9sLm9mZnNldF0g6K6+572u566t5aS05Zyo6L+e57q/5LiK55qE5YGP56e76YeP77yM6buY6K6k5pivMCBzaW5jZSBWMi4zLjBcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50ZXh0XSDnur/mrrXkuIrnmoTmloflrZdcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50ZXh0LnRleHRdIOe6v+auteS4iueahOaWh+Wtl+WGheWuuVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRleHQudGV4dEZpbGxdIOe6v+auteS4iueahOaWh+Wtl+minOiJslxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRleHQudGV4dFBvc10g5paH5a2X5L2N572u5Y+v6YCJ5YC8ICdzdGFydCcsJ2NlbnRlcicsJ2VuZCcs6buY6K6k5YC85Li6Y2VudGVyXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcnxBcnJheX0gW29wdGlvbnMudGV4dC5vZmZzZXRdIOaWh+Wtl+S9jee9ruWBj+enu+mHjyzkuLpudW1iZXLliJnmmK945YGP56e7IGFycmF55YiZ5Li6W3gseV1cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGV4dC50ZXh0Um90YXRlYWJsZV0g5paH5a2X6ZqP57q/5q615peL6L2sLCDpu5jorqTlgLzkuLp0cnVlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zXSDkv53nlZkg6K+35L2/55Sob3B0aW9ucy5wb3NpdGlvbi5kaXJlY3Rpb24g5oyH5a6a57q/5q616LW35aeL5LiO57uI5q2iIOWcqOiKgueCueeahOS7gOS5iOS9jee9riDpu5jorqTlgLzkuLonbGVmdCxyaWdodCcgIOWPr+WPluWAvOWbm+S4quaWueWQkXRvcCxib3R0b20sbGVmdCxyaWdodCDmlrnlkJHlj6/liqDlgY/np7vph4/lpoLlpoIgXCJsZWZ0KzEwLHRvcFwiXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb25dIOaMh+Wumue6v+auteS9jee9rlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBvc2l0aW9uLmRpcmVjdGlvbl0g5oyH5a6a57q/5q616LW35aeL5LiO57uI5q2iIOWcqOiKgueCueeahOS7gOS5iOS9jee9riDpu5jorqTlgLzkuLonbGVmdCxyaWdodCcgIOWPr+WPluWAvOWbm+S4quaWueWQkXRvcCxib3R0b20sbGVmdCxyaWdodCDmlrnlkJHlj6/liqDlgY/np7vph4/lpoLlpoIgXCJsZWZ0KzEwLHRvcFwiXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucG9zaXRpb24uc3RhcnRPZmZzZXRdIOe6v+auteW8gOWni+S9jee9rueahOWBj+enu1t4LHldICAgZWcuIHN0YXJ0T2Zmc2V0OlswLDEwXSDlnKh45LiK5YGP56e7MCB55LiK5YGP56e7MTBcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wb3NpdGlvbi5lbmRPZmZzZXRdIOe6v+autee7k+adn+S9jee9rueahOWBj+enu1t4LHldICAgZWcuIHN0YXJ0T2Zmc2V0OlswLDEwXSDlnKh45LiK5YGP56e7MCB55LiK5YGP56e7MTBcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbi5lc2NhcGVEaXN0YW5jZV0g5oyH5a6a57q/5q6156ys5LiA5p2h5oqY57q/55qE6ZW/5bqm77yM5pyA5ZCO5LiA5p2h5oqY57q/55qE6ZW/5bqm77yM6buY6K6k5YC85Li6WzMwLCAzMF1cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbi5wb2ludHNdIOS4jeS9v+eUqOiHquWKqOiuoeeulyDmjIflrprov57nur/nmoTmipjngrnkvY3nva7mlbDnu4TvvIzpppblsL7lj6/ku6Xkvb/nlKhsZWZ0LHJpZ2h0LHRvcCxib3R0b21cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5lZmZlY3RdIOe6v+S4iuWKqOaAgeaViOaenFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmVmZmVjdC5zaG93XSDmmK/lkKbmmL7npLrnrq3lpLTliqjmlYhcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5lZmZlY3QucGVyaW9kXSDliqjmlYjnp7vliqjpgJ/luqZcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b0NoYW5nZVBvc2l0aW9uXSDov57nur/nmoTov57mjqXngrnpmo9ub2Rl56e75Yqo6Ieq5Yqo5YiH5o2i5L2N572u77yM6buY6K6k5Li6Zmxhc2VcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy56XSDov57nur/nmoTlsYLnuqfvvIzotorlpKfotorlnKjliY3pnaLmmL7npLpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5idW5kbGVPZmZzZXQ9MzBdIOaLhue6v+aLkOinkuWkhOeahOmVv+W6pijnlKjkuo7ov57nur/nu4QpXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYnVuZGxlR2FwPTIwXSDlpJrnur/mrrXnmoTpl7TpmpQo55So5LqO6L+e57q/57uEKVxyXG4gICAgICovXHJcbiAgICBMaW5rLmNyZWF0ZUJ5UG9pbnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIG9wdCA9IEZsb3cudHJhbnNsYXRlTGlua09wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgLy/pu5jorqTlsLHmmK/nm7Tnur9cclxuICAgICAgICB2YXIgY29ubmVjdG9yID0gbmV3IENvbm5lY3RvcihvcHQpO1xyXG4gICAgICAgIHJldHVybiBjb25uZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMaW5rO1xyXG5cclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9saW5rL0xpbmsuanNcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogRmxvd+mdmeaAgeaWueazleexu1xyXG4gKiBAY2xhc3MgZmlzaC50b3BvLkZpc2hUb3BvRmxvdy5GbG93XHJcbiAqL1xyXG5cclxuXHJcbiAgICB2YXIgQ29uc3RhbnRzID0gcmVxdWlyZShcIi4vdXRpbC9GbG93Q29uc3RhbnRzLmpzXCIpO1xyXG4gICAgdmFyIEdyb3VwTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvR3JvdXBOb2RlLmpzXCIpO1xyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcbiAgICB2YXIgRmxvdyA9IHtcclxuICAgICAgICBGTE9XX1RZUEU6IFwiZWxlbWVudFR5cGVcIixcclxuICAgICAgICBMSU5LOiBcImNvbm5lY3Rpb25cIixcclxuICAgICAgICBSRUNUOiBcIlJlY3RcIixcclxuICAgICAgICBHcm91cDogJ0dyb3VwJyxcclxuICAgICAgICBJTUFHRTogJ0ltYWdlJyxcclxuICAgICAgICBURVhUOiAnVGV4dCcsXHJcbiAgICAgICAgQ0lSQ0xFOiAnQ2lyY2xlJyxcclxuICAgICAgICBTRUNUT1I6ICdTZWN0b3InLFxyXG4gICAgICAgIFJJTkc6ICdSaW5nJyxcclxuICAgICAgICBQT0xZR09OOiAnUG9seWdvbicsXHJcbiAgICAgICAgUE9MWUxJTkU6ICdQb2x5bGluZScsXHJcbiAgICAgICAgTElORTogJ0xpbmUnLFxyXG4gICAgICAgIEJFWklFUkNVUlZFOiAnQmV6aWVyY3VydmUnLFxyXG4gICAgICAgIEFSQzogJ0FyYycsXHJcbiAgICAgICAgU0NFTkU6J3NjZW5lJyxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1ldGhvZCBzZXRVc2VyRGF0YVxyXG4gICAgICAgICAqIOiuvue9rueUqOaIt+aVsOaNrlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIOmcgOimgeiuvue9ruaVsOaNrueahOiKgueCuVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmog5pWw5o2uXHJcbiAgICAgICAgICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICAgICAqICAgICAgLy/orr7nva7oh6rlrprkuYnmlbDmja5cclxuICAgICAgICAgKiAgICAgIHRoaXMuZmlzaFRvcG8uRmxvdy5zZXRVc2VyRGF0YShyZWN0LCB7IGN1c3RvbU9iajogXCJyZWN0XCIgfSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0VXNlckRhdGE6IGZ1bmN0aW9uKG5vZGUsIG9iaikge1xyXG4gICAgICAgICAgICBub2RlLm1vZGVsLnNldChDb25zdGFudHMuVVNFUkRBVEEsIG9iaik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5borr7nva7nmoTnlKjmiLfmlbDmja5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSDpnIDopoHojrflj5bmlbDmja7nmoToioLngrlcclxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAg5pWw5o2uXHJcbiAgICAgICAgICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICAgICAqICAgICAgLy/ojrflj5boh6rlrprkuYnmlbDmja5cclxuICAgICAgICAgKiAgICAgIHRoaXMuZmlzaFRvcG8uRmxvdy5nZXRVc2VyRGF0YShyZWN0KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRVc2VyRGF0YTogZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgdXNlckRhdGEgPSBub2RlLm1vZGVsLmdldChDb25zdGFudHMuVVNFUkRBVEEpO1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZCh1c2VyRGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIHVzZXJEYXRhID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVzZXJEYXRhO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5Yik5pat5piv5ZCm5piv6L+e57q/XHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsIOWvueixoeeahG1vZGVsXHJcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICDmmK8g5ZCmXHJcbiAgICAgICAgICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICAgICAqICAgICAgLy/liKTmlq3mmK/lkKbmmK/ov57nur9cclxuICAgICAgICAgKiAgICAgIHZhciBub2RlTW9kZWwgPSBlLnRhcmdldC5tb2RlbDtcclxuICAgICAgICAgKiAgICAgIGlmICh0aGlzLmZpc2hUb3BvLkZsb3cuaXNMaW5rKG5vZGVNb2RlbCkpIHsgcmV0dXJuIHRydWU7fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzTGluazogZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gbW9kZWwuZ2V0KEZsb3cuRkxPV19UWVBFKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRUeXBlID09IEZsb3cuTElOSztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOWIpOaWreaYr+WQpuaYr+iKgueCuVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCDlr7nosaHnmoRtb2RlbFxyXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAg5pivIOWQplxyXG4gICAgICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgIC8v5Yik5pat5piv5ZCm5piv6IqC54K5XHJcbiAgICAgICAgICogICAgICB2YXIgbm9kZU1vZGVsID0gZS50YXJnZXQubW9kZWw7XHJcbiAgICAgICAgICogICAgICBpZiAodGhpcy5maXNoVG9wby5GbG93LmlzTm9kZShub2RlTW9kZWwpKSB7IHJldHVybiB0cnVlO31cclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgaXNOb2RlOiBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSBtb2RlbC5nZXQoRmxvdy5GTE9XX1RZUEUpO1xyXG4gICAgICAgICAgICB2YXIgaXNOb2RlO1xyXG4gICAgICAgICAgICBpZihlbGVtZW50VHlwZSAhPSAgRmxvdy5MSU5LICYmIGVsZW1lbnRUeXBlICE9ICBGbG93LlNDRU5FKXtcclxuICAgICAgICAgICAgICAgIGlzTm9kZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgaXNOb2RlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGlzTm9kZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpc0luR3JvdXA6IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50IGluc3RhbmNlb2YgR3JvdXBOb2RlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGlzR3JvdXBOb2RlOiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgR3JvdXBOb2RlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOWIpOaWreiKgueCueaYr+WQpuaYr+efqeW9ouiKgueCuVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCDoioLngrnnmoRtb2RlbFxyXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAg5pivIOWQplxyXG4gICAgICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgIC8v5Yik5pat5piv5ZCm5piv55+p5b2i6IqC54K5XHJcbiAgICAgICAgICogICAgICB2YXIgbm9kZU1vZGVsID0gZS50YXJnZXQubW9kZWw7XHJcbiAgICAgICAgICogICAgICBpZiAodGhpcy5maXNoVG9wby5GbG93LmlzUmVjdChub2RlTW9kZWwpKSB7IHJldHVybiB0cnVlO31cclxuICAgICAgICAgKi9cclxuICAgICAgICBpc1JlY3Q6IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50VHlwZSA9IG1vZGVsLmdldChGbG93LkZMT1dfVFlQRSk7XHJcbiAgICAgICAgICAgIHJldHVybiAgZWxlbWVudFR5cGUgPT0gRmxvdy5SRUNUO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5Yik5pat6IqC54K55piv5ZCm5piv5Zu+54mH6IqC54K5XHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsIOiKgueCueeahG1vZGVsXHJcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICDmmK8g5ZCmXHJcbiAgICAgICAgICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICAgICAqICAgICAgLy/liKTmlq3mmK/lkKbmmK/lm77niYfoioLngrlcclxuICAgICAgICAgKiAgICAgIHZhciBub2RlTW9kZWwgPSBlLnRhcmdldC5tb2RlbDtcclxuICAgICAgICAgKiAgICAgIGlmICh0aGlzLmZpc2hUb3BvLkZsb3cuaXNJbWFnZShub2RlTW9kZWwpKSB7IHJldHVybiB0cnVlO31cclxuICAgICAgICAgKi9cclxuICAgICAgICBpc0ltYWdlOiBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSBtb2RlbC5nZXQoRmxvdy5GTE9XX1RZUEUpO1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudFR5cGUgPT0gRmxvdy5JTUFHRTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOWIpOaWreiKgueCueaYr+WQpuaYr+aWh+Wtl+iKgueCuVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCDoioLngrnnmoRtb2RlbFxyXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAg5pivIOWQplxyXG4gICAgICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgIC8v5Yik5pat5piv5ZCm5piv5paH5a2X6IqC54K5XHJcbiAgICAgICAgICogICAgICB2YXIgbm9kZU1vZGVsID0gZS50YXJnZXQubW9kZWw7XHJcbiAgICAgICAgICogICAgICBpZiAodGhpcy5maXNoVG9wby5GbG93LmlzVGV4dChub2RlTW9kZWwpKSB7IHJldHVybiB0cnVlO31cclxuICAgICAgICAgKi9cclxuICAgICAgICBpc1RleHQ6IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50VHlwZSA9IG1vZGVsLmdldChGbG93LkZMT1dfVFlQRSk7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50VHlwZSA9PSBGbG93LlRFWFQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDliKTmlq3oioLngrnmmK/lkKbmmK/lnIblvaLoioLngrlcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWwg6IqC54K555qEbW9kZWxcclxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgIOaYryDlkKZcclxuICAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgICAvL+WIpOaWreaYr+WQpuaYr+WchuW9ouiKgueCuVxyXG4gICAgICAgICAqICAgICAgdmFyIG5vZGVNb2RlbCA9IGUudGFyZ2V0Lm1vZGVsO1xyXG4gICAgICAgICAqICAgICAgaWYgKHRoaXMuZmlzaFRvcG8uRmxvdy5pc0NpcmNsZShub2RlTW9kZWwpKSB7IHJldHVybiB0cnVlO31cclxuICAgICAgICAgKi9cclxuICAgICAgICBpc0NpcmNsZTogZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gbW9kZWwuZ2V0KEZsb3cuRkxPV19UWVBFKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRUeXBlID09IEZsb3cuQ0lSQ0xFO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635Y+W6IqC54K555qE57G75Z6LXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsIOiKgueCueeahG1vZGVsXHJcbiAgICAgICAgICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICAgICAqICAgICAgLy/ojrflj5boioLngrnnsbvlnotcclxuICAgICAgICAgKiAgICAgIHZhciBub2RlTW9kZWwgPSBlLnRhcmdldC5tb2RlbDtcclxuICAgICAgICAgKiAgICAgIHJldHVybiB0aGlzLmZpc2hUb3BvLkZsb3cuZ2V0VHlwZShub2RlTW9kZWwpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFR5cGU6IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50VHlwZSA9IG1vZGVsLmdldChGbG93LkZMT1dfVFlQRSk7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50VHlwZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRyYW5zbGF0ZUxpbmtPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wb3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyUG9zID0gb3B0aW9ucy5wb3Muc3BsaXQoXCIsXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnJQb3MubGVuZ3RoID49IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLnBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wb3NpdGlvbi5zdGFydFBvcyA9IGFyclBvc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wb3NpdGlvbi5lbmRQb3MgPSBhcnJQb3NbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGV4dCAmJiBvcHRpb25zLnRleHQuY29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnRleHQudGV4dEZpbGwgPSBvcHRpb25zLnRleHQuY29sb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEZsb3c7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvRmxvdy5qc1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDmipjnur88YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubGluay5Gb2xkXHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5saW5rXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgbGluayA9IGZpc2hUb3BvRmxvdy5saW5rO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIC8v6IqC54K5XHJcbiAqICAgICAgIGZ1bmN0aW9uIG5ld05vZGUoeCwgeSwgdywgaCkge1xyXG4gKiAgICAgICAgICAgdmFyIHJlY3QgPSBuZXcgbm9kZS5SZWN0KHtcclxuICogICAgICAgICAgICAgICBzaGFwZToge3dpZHRoOiB3LGhlaWdodDogaH0sXHJcbiAqICAgICAgICAgICAgICAgcG9zaXRpb246IFt4LCB5XSxcclxuICogICAgICAgICAgICAgICBzdHlsZToge2ZpbGw6IFwiIzE2N0NGRlwifVxyXG4gKiAgICAgICAgICAgfSk7XHJcbiAqICAgICAgICAgICBmaXNoVG9wby5hZGQocmVjdCk7XHJcbiAqICAgICAgICAgICByZXR1cm4gcmVjdDtcclxuICogICAgICAgfVxyXG4gKiAgICAgICAvL+aKmOe6v1xyXG4gKiAgICAgICBmdW5jdGlvbiBuZXdGb2xkTGluayhzdGFydE5vZGUsIGVuZE5vZGUsIHRleHQsIGRpcmVjdGlvbiwgZGFzaGVkUGF0dGVybikge1xyXG4gKiAgICAgICAgICAgdmFyIGZsaW5rID0gbmV3IGxpbmsuRm9sZChzdGFydE5vZGUsIGVuZE5vZGUsIHtcclxuICogICAgICAgICAgICAgICBzdHlsZToge2xpbmVEYXNoOiBbZGFzaGVkUGF0dGVybl19LFxyXG4gKiAgICAgICAgICAgICAgIHRleHQ6IHt0ZXh0OiB0ZXh0fSxcclxuICogICAgICAgICAgICAgICBwb3M6IGRpcmVjdGlvblxyXG4gKiAgICAgICAgICAgfSlcclxuICogICAgICAgICAgIGZpc2hUb3BvLmFkZChmbGluayk7XHJcbiAqICAgICAgICAgICByZXR1cm4gZmxpbms7XHJcbiAqICAgICAgIH1cclxuICogICAgICAgdmFyIGZyb20gPSBuZXdOb2RlKDEwMCwgNDAsIDMwLCAzMCk7XHJcbiAqICAgICAgIHZhciB0byA9IG5ld05vZGUoMzAwLCA4MCwgMzAsIDMwKTtcclxuICogICAgICAgbmV3Rm9sZExpbmsoZnJvbSwgdG8sICfmipjnur8nKTtcclxuICovXHJcblxyXG4gICAgdmFyIENvbm5lY3RvciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rvci5qc1wiKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBGbG93ID0gcmVxdWlyZShcIi4uL0Zsb3dcIik7XHJcblxyXG4gICAgZnVuY3Rpb24gRm9sZChzdGFydE5vZGUsZW5kTm9kZSxvcHRpb25zKSB7XHJcbiAgICAgICAgLy/mipjnur9cclxuICAgICAgICB2YXIgb3B0ID0genJVdGlsLm1lcmdlKHtzdHlsZTp7bGluZVR5cGU6IENvbm5lY3Rvci5UWVBFX0pBR0dFRH19LCBvcHRpb25zLCB0cnVlKTtcclxuICAgICAgICBvcHQgPSBGbG93LnRyYW5zbGF0ZUxpbmtPcHRpb25zKG9wdCk7XHJcbiAgICAgICAgdmFyIGNvbm5lY3RvciA9IG5ldyBDb25uZWN0b3Iob3B0KTtcclxuICAgICAgICBjb25uZWN0b3Iuc3RhcnROb2RlID0gc3RhcnROb2RlO1xyXG4gICAgICAgIGNvbm5lY3Rvci5lbmROb2RlID0gZW5kTm9kZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbm5lY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgY3JlYXRlQnlQb2ludFxyXG4gICAgICog55So5oi35oyH5a6a6L+e57q/55qE54K577yM5p2l6L+b6KGM55S757q/XHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMg57q/5q616YCJ6aG5XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc3R5bGVdIOiKgueCueeahOagt+W8j1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN0eWxlLmxpbmVXaWR0aD0xXSDnur/mrrXnmoTlrr3luqZcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zdHlsZS5saW5lVHlwZT0nc3RyYWlnaHQnXSDnur/mrrXnmoTnsbvlnosgZWcuICdzdHJhaWdodCcsICdqYWdnZWQnLCdjdXJ2ZSdcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zdHlsZS5zdHJva2U9XCIjMDAwMDAwXCJdIOe6v+auteeahOminOiJsuWAvCBlZy4gJyMxNTdjZmYnICAncmdiKDEyMiwxMjIsMTIyKSdcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5zdHlsZS5saW5lRGFzaF0g6Jma57q/55qE6Ze06ZqUIGVnLiBbMywzXVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnN5bWJvbF0g57q/5q6155qE566t5aS0XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3ltYm9sLnR5cGU9J2Fycm93J10g57q/5q6155qE566t5aS055qE57G75Z6LIOWPr+mAieWAvOS4uu+8miAnY2lyY2xlJywgJ3JlY3QnLCAncm91bmRSZWN0JywgJ3RyaWFuZ2xlJywgJ2RpYW1vbmQnLCAncGluJywgJ2Fycm93J1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN5bWJvbC5zaXplPTEwXSDnur/mrrXnmoTnrq3lpLTnmoTlsLrlr7hcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zeW1ib2wuY29sb3I9JyMwMDAwMDAnXSDnur/mrrXnmoTnrq3lpLTnmoTpopzoibJcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zeW1ib2wuel0gW+eureWktOeahOWxgue6p++8jOi2iuWkp+i2iuWcqOWJjemdouaYvuekul1cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3ltYm9sLmJvdGhdIFvmjIflrprmmK/lkKblnKjov57nur/nmoTpppbkuI7lsL7pg73nlLvnrq3lpLQg6buY6K6k5pivZmFsc2VdXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3ltYm9sLm9mZnNldF0g6K6+572u566t5aS05Zyo6L+e57q/5LiK55qE5YGP56e76YeP77yM6buY6K6k5pivMO+8m29mZnNldOacgOWkp+WAvOS4jeiDvei2hei/h29wdGlvbnMuYnVuZGxlT2Zmc2V0KOm7mOiupDMwKSDorr7nva7nmoTlgLwgc2luY2UgVjIuMy4wXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudGV4dF0g57q/5q615LiK55qE5paH5a2XXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGV4dC50ZXh0XSDnur/mrrXkuIrnmoTmloflrZflhoXlrrlcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50ZXh0LmNvbG9yXSDnur/mrrXkuIrnmoTmloflrZfpopzoibJcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50ZXh0LnRleHRQb3NdIOaWh+Wtl+S9jee9ruWPr+mAieWAvCAnc3RhcnQnLCdjZW50ZXInLCdlbmQnLOm7mOiupOWAvOS4umNlbnRlclxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8QXJyYXl9IFtvcHRpb25zLnRleHQub2Zmc2V0XSDmloflrZfkvY3nva7lgY/np7vph48s5Li6bnVtYmVy5YiZ5piveOWBj+enuyBhcnJheeWImeS4ult4LHldXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zXSDkv53nlZkg6K+35L2/55Sob3B0aW9ucy5wb3NpdGlvbi5kaXJlY3Rpb24g5oyH5a6a57q/5q616LW35aeL5LiO57uI5q2iIOWcqOiKgueCueeahOS7gOS5iOS9jee9riDpu5jorqTlgLzkuLonbGVmdCxyaWdodCcgIOWPr+WPluWAvOWbm+S4quaWueWQkXRvcCxib3R0b20sbGVmdCxyaWdodCDmlrnlkJHlj6/liqDlgY/np7vph4/lpoLlpoIgXCJsZWZ0KzEwLHRvcFwiXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb25dIOaMh+Wumue6v+auteS9jee9rlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBvc2l0aW9uLmRpcmVjdGlvbl0g5oyH5a6a57q/5q616LW35aeL5LiO57uI5q2iIOWcqOiKgueCueeahOS7gOS5iOS9jee9riDpu5jorqTlgLzkuLonbGVmdCxyaWdodCcgIOWPr+WPluWAvOWbm+S4quaWueWQkXRvcCxib3R0b20sbGVmdCxyaWdodCDmlrnlkJHlj6/liqDlgY/np7vph4/lpoLlpoIgXCJsZWZ0KzEwLHRvcFwiXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucG9zaXRpb24uc3RhcnRPZmZzZXRdIOe6v+auteW8gOWni+S9jee9rueahOWBj+enu1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBvc2l0aW9uLmVuZE9mZnNldF0g57q/5q6157uT5p2f5L2N572u55qE5YGP56e7XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb24uZXNjYXBlRGlzdGFuY2VdIOaMh+Wumue6v+auteesrOS4gOadoeaKmOe6v+eahOmVv+W6pu+8jOacgOWQjuS4gOadoeaKmOe6v+eahOmVv+W6pu+8jOm7mOiupOWAvOS4ulszMCwgMzBdXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb24ucG9pbnRzXSDkuI3kvb/nlKjoh6rliqjorqHnrpcg5oyH5a6a6L+e57q/55qE5oqY54K55L2N572u5pWw57uE77yM6aaW5bC+5Y+v5Lul5L2/55SobGVmdCxyaWdodCx0b3AsYm90dG9tXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZWZmZWN0XSDnur/kuIrliqjmgIHmlYjmnpxcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5lZmZlY3Quc2hvd10g5piv5ZCm5pi+56S6566t5aS05Yqo5pWIXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZWZmZWN0LnBlcmlvZF0g5Yqo5pWI56e75Yqo6YCf5bqmXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9DaGFuZ2VQb3NpdGlvbl0g6L+e57q/55qE6L+e5o6l54K56ZqPbm9kZeenu+WKqOiHquWKqOWIh+aNouS9jee9ru+8jOm7mOiupOS4umZsYXNlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuel0g6L+e57q/55qE5bGC57qn77yM6LaK5aSn6LaK5Zyo5YmN6Z2i5pi+56S6XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYnVuZGxlT2Zmc2V0PTMwXSDmi4bnur/mi5Dop5LlpITnmoTplb/luqYo55So5LqO6L+e57q/57uEKVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJ1bmRsZUdhcD0yMF0g5aSa57q/5q6155qE6Ze06ZqUKOeUqOS6jui/nue6v+e7hClcclxuICAgICAqL1xyXG4gICAgRm9sZC5jcmVhdGVCeVBvaW50ID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBvcHQgPSB6clV0aWwubWVyZ2Uoe3N0eWxlOntsaW5lVHlwZTogQ29ubmVjdG9yLlRZUEVfSkFHR0VEfX0sIG9wdGlvbnMsIHRydWUpO1xyXG4gICAgICAgIG9wdCA9IEZsb3cudHJhbnNsYXRlTGlua09wdGlvbnMob3B0KTtcclxuICAgICAgICB2YXIgY29ubmVjdG9yID0gbmV3IENvbm5lY3RvcihvcHQpO1xyXG4gICAgICAgIHJldHVybiBjb25uZWN0b3I7XHJcbiAgICB9XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEZvbGQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9saW5rL0ZvbGQuanNcbi8vIG1vZHVsZSBpZCA9IDEyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog5puy57q/PGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93LmxpbmsuQ3VydmVcclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93LmxpbmtcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgIHZhciBub2RlID0gZmlzaFRvcG9GbG93Lm5vZGU7XHJcbiAqICAgICAgIHZhciBsaW5rID0gZmlzaFRvcG9GbG93Lmxpbms7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSwge3JvYW06ZmFsc2V9KTtcclxuICogICAgICAgLy/oioLngrlcclxuICogICAgICAgZnVuY3Rpb24gbmV3Tm9kZSh4LCB5LCB3LCBoKSB7XHJcbiAqICAgICAgICAgICB2YXIgcmVjdCA9IG5ldyBub2RlLlJlY3Qoe1xyXG4gKiAgICAgICAgICAgICAgIHNoYXBlOiB7d2lkdGg6IHcsaGVpZ2h0OiBofSxcclxuICogICAgICAgICAgICAgICBwb3NpdGlvbjogW3gsIHldLFxyXG4gKiAgICAgICAgICAgICAgIHN0eWxlOiB7ZmlsbDogXCIjMTY3Q0ZGXCJ9XHJcbiAqICAgICAgICAgICB9KTtcclxuICogICAgICAgICAgIGZpc2hUb3BvLmFkZChyZWN0KTtcclxuICogICAgICAgICAgIHJldHVybiByZWN0O1xyXG4gKiAgICAgICB9XHJcbiAqICAgICAgIC8v5puy57q/XHJcbiAqICAgICAgIGZ1bmN0aW9uIG5ld0N1cnZlTGluayhzdGFydE5vZGUsIGVuZE5vZGUsIHRleHQsIGRpcmVjdGlvbiwgZGFzaGVkUGF0dGVybikge1xyXG4gKiAgICAgICAgICAgdmFyIGNsaW5rID0gbmV3IGxpbmsuQ3VydmUoc3RhcnROb2RlLCBlbmROb2RlLCB7XHJcbiAqICAgICAgICAgICAgICAgc3R5bGU6IHtsaW5lRGFzaDogW2Rhc2hlZFBhdHRlcm5dfSxcclxuICogICAgICAgICAgICAgICB0ZXh0OiB7dGV4dDogdGV4dH0sXHJcbiAqICAgICAgICAgICAgICAgcG9zOiBkaXJlY3Rpb25cclxuICogICAgICAgICAgIH0pXHJcbiAqICAgICAgICAgICBmaXNoVG9wby5hZGQoY2xpbmspO1xyXG4gKiAgICAgICAgICAgcmV0dXJuIGNsaW5rO1xyXG4gKiAgICAgICB9XHJcbiAqICAgICAgIHZhciBmcm9tID0gbmV3Tm9kZSgxMDAsIDQwLCAzMCwgMzApO1xyXG4gKiAgICAgICB2YXIgdG8gPSBuZXdOb2RlKDMwMCwgODAsIDMwLCAzMCk7XHJcbiAqICAgICAgIG5ld0N1cnZlTGluayhmcm9tLCB0bywgJ+absue6vycpO1xyXG4gKi9cclxuXHJcbiAgICB2YXIgQ29ubmVjdG9yID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIEZsb3cgPSByZXF1aXJlKFwiLi4vRmxvd1wiKTtcclxuICAgIGZ1bmN0aW9uIEN1cnZlKHN0YXJ0Tm9kZSxlbmROb2RlLG9wdGlvbnMpIHtcclxuICAgICAgICAvL+absue6v1xyXG4gICAgICAgIHZhciBvcHQgPSB6clV0aWwubWVyZ2Uoe3N0eWxlOntsaW5lVHlwZTogQ29ubmVjdG9yLlRZUEVfQ1VSVkV9fSwgb3B0aW9ucywgdHJ1ZSk7XHJcbiAgICAgICAgb3B0ID0gRmxvdy50cmFuc2xhdGVMaW5rT3B0aW9ucyhvcHQpO1xyXG5cclxuICAgICAgICB2YXIgY29ubmVjdG9yID0gbmV3IENvbm5lY3RvcihvcHQpO1xyXG4gICAgICAgIGNvbm5lY3Rvci5zdGFydE5vZGUgPSBzdGFydE5vZGU7XHJcbiAgICAgICAgY29ubmVjdG9yLmVuZE5vZGUgPSBlbmROb2RlO1xyXG5cclxuICAgICAgICByZXR1cm4gY29ubmVjdG9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZUJ5UG9pbnRcclxuICAgICAqIOeUqOaIt+aMh+Wumui/nue6v+eahOeCue+8jOadpei/m+ihjOeUu+e6v1xyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIOe6v+autemAiemhuVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnN0eWxlXSDoioLngrnnmoTmoLflvI9cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zdHlsZS5saW5lV2lkdGg9MV0g57q/5q6155qE5a695bqmXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3R5bGUubGluZVR5cGU9J3N0cmFpZ2h0J10g57q/5q6155qE57G75Z6LIGVnLiAnc3RyYWlnaHQnLCAnamFnZ2VkJywnY3VydmUnXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3R5bGUuc3Ryb2tlPVwiIzAwMDAwMFwiXSDnur/mrrXnmoTpopzoibLlgLwgZWcuICcjMTU3Y2ZmJyAgJ3JnYigxMjIsMTIyLDEyMiknXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMuc3R5bGUubGluZURhc2hdIOiZmue6v+eahOmXtOmalCBlZy4gWzMsM11cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5zeW1ib2xdIOe6v+auteeahOeureWktFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN5bWJvbC50eXBlPSdhcnJvdyddIOe6v+auteeahOeureWktOeahOexu+WeiyDlj6/pgInlgLzkuLrvvJogJ2NpcmNsZScsICdyZWN0JywgJ3JvdW5kUmVjdCcsICd0cmlhbmdsZScsICdkaWFtb25kJywgJ3BpbicsICdhcnJvdydcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zeW1ib2wuc2l6ZT0xMF0g57q/5q6155qE566t5aS055qE5bC65a+4XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3ltYm9sLmNvbG9yPScjMDAwMDAwJ10g57q/5q6155qE566t5aS055qE6aKc6ImyXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3ltYm9sLnpdIFvnrq3lpLTnmoTlsYLnuqfvvIzotorlpKfotorlnKjliY3pnaLmmL7npLpdXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN5bWJvbC5ib3RoXSBb5oyH5a6a5piv5ZCm5Zyo6L+e57q/55qE6aaW5LiO5bC+6YO955S7566t5aS0IOm7mOiupOaYr2ZhbHNlXVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnRleHRdIOe6v+auteS4iueahOaWh+Wtl1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRleHQudGV4dF0g57q/5q615LiK55qE5paH5a2X5YaF5a65XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGV4dC5jb2xvcl0g57q/5q615LiK55qE5paH5a2X6aKc6ImyXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGV4dC50ZXh0UG9zXSDmloflrZfkvY3nva7lj6/pgInlgLwgJ3N0YXJ0JywnY2VudGVyJywnZW5kJyzpu5jorqTlgLzkuLpjZW50ZXJcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfEFycmF5fSBbb3B0aW9ucy50ZXh0Lm9mZnNldF0g5paH5a2X5L2N572u5YGP56e76YePLOS4um51bWJlcuWImeaYr3jlgY/np7sgYXJyYXnliJnkuLpbeCx5XVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc10g5L+d55WZIOivt+S9v+eUqG9wdGlvbnMucG9zaXRpb24uZGlyZWN0aW9uIOaMh+Wumue6v+autei1t+Wni+S4jue7iOatoiDlnKjoioLngrnnmoTku4DkuYjkvY3nva4g6buY6K6k5YC85Li6J2xlZnQscmlnaHQnICDlj6/lj5blgLzlm5vkuKrmlrnlkJF0b3AsYm90dG9tLGxlZnQscmlnaHQg5pa55ZCR5Y+v5Yqg5YGP56e76YeP5aaC5aaCIFwibGVmdCsxMCx0b3BcIlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uXSDmjIflrprnur/mrrXkvY3nva5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wb3NpdGlvbi5kaXJlY3Rpb25dIOaMh+Wumue6v+autei1t+Wni+S4jue7iOatoiDlnKjoioLngrnnmoTku4DkuYjkvY3nva4g6buY6K6k5YC85Li6J2xlZnQscmlnaHQnICDlj6/lj5blgLzlm5vkuKrmlrnlkJF0b3AsYm90dG9tLGxlZnQscmlnaHQg5pa55ZCR5Y+v5Yqg5YGP56e76YeP5aaC5aaCIFwibGVmdCsxMCx0b3BcIlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBvc2l0aW9uLnN0YXJ0T2Zmc2V0XSDnur/mrrXlvIDlp4vkvY3nva7nmoTlgY/np7tcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wb3NpdGlvbi5lbmRPZmZzZXRdIOe6v+autee7k+adn+S9jee9rueahOWBj+enu1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uLmVzY2FwZURpc3RhbmNlXSDmjIflrprnur/mrrXnrKzkuIDmnaHmipjnur/nmoTplb/luqbvvIzmnIDlkI7kuIDmnaHmipjnur/nmoTplb/luqbvvIzpu5jorqTlgLzkuLpbMzAsIDMwXVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uLnBvaW50c10g5LiN5L2/55So6Ieq5Yqo6K6h566XIOaMh+Wumui/nue6v+eahOaKmOeCueS9jee9ruaVsOe7hO+8jOmmluWwvuWPr+S7peS9v+eUqGxlZnQscmlnaHQsdG9wLGJvdHRvbVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmVmZmVjdF0g57q/5LiK5Yqo5oCB5pWI5p6cXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZWZmZWN0LnNob3ddIOaYr+WQpuaYvuekuueureWktOWKqOaViFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmVmZmVjdC5wZXJpb2RdIOWKqOaViOenu+WKqOmAn+W6plxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvQ2hhbmdlUG9zaXRpb25dIOi/nue6v+eahOi/nuaOpeeCuemaj25vZGXnp7vliqjoh6rliqjliIfmjaLkvY3nva7vvIzpu5jorqTkuLpmbGFzZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnpdIOi/nue6v+eahOWxgue6p++8jOi2iuWkp+i2iuWcqOWJjemdouaYvuekulxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJ1bmRsZU9mZnNldD0zMF0g5ouG57q/5ouQ6KeS5aSE55qE6ZW/5bqmKOeUqOS6jui/nue6v+e7hClcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5idW5kbGVHYXA9MjBdIOWkmue6v+auteeahOmXtOmalCjnlKjkuo7ov57nur/nu4QpXHJcbiAgICAgKi9cclxuICAgIEN1cnZlLmNyZWF0ZUJ5UG9pbnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIG9wdCA9IHpyVXRpbC5tZXJnZSh7c3R5bGU6e2xpbmVUeXBlOiBDb25uZWN0b3IuVFlQRV9DVVJWRX19LCBvcHRpb25zLCB0cnVlKTtcclxuICAgICAgICBvcHQgPSBGbG93LnRyYW5zbGF0ZUxpbmtPcHRpb25zKG9wdCk7XHJcbiAgICAgICAgdmFyIGNvbm5lY3RvciA9IG5ldyBDb25uZWN0b3Iob3B0KTtcclxuICAgICAgICByZXR1cm4gY29ubmVjdG9yO1xyXG4gICAgfVxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDdXJ2ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL2xpbmsvQ3VydmUuanNcbi8vIG1vZHVsZSBpZCA9IDEyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog6ZO+6LevIOaUr+aMgee6v+S4iuWkmuaWh+acrOWxleekuu+8jCDmnIDlpKfnmoTkuI3lkIzmmK90ZXh0LnRleHTlr7nosaHkuLrmlbDnu4TnsbvlnovvvIzooajnpLrlpJrkuKrmlofmnKznmoTmlbDmja7jgILmlbDnu4TlhYPntKDlj6/ku6XkuLrlrZfnrKbkuLLvvIzooajnpLrmr4/kuKrmlofmnKznmoTlkI3lrZfvvJvkuZ/lj6/ku6XmmK/kuKrlr7nosaHvvIzlr7nosaHkuK3lv4XpobvmjIflrpp0ZXh05bGe5oCn77yM5YW25YC85Li65paH5pys55qE5ZCN5a2X77yM5YW25L2Z5bGe5oCn5YiZ5Li65Lia5Yqh5L6n6Ieq5a6a5LmJ55qEPGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93LmxpbmsuQ2hhaW5cclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93LmxpbmtcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgIHZhciBub2RlID0gZmlzaFRvcG9GbG93Lm5vZGU7XHJcbiAqICAgICAgIHZhciBsaW5rID0gZmlzaFRvcG9GbG93Lmxpbms7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSwge3JvYW06ZmFsc2V9KTtcclxuICogICAgICAgLy/oioLngrlcclxuICogICAgICAgZnVuY3Rpb24gbmV3Tm9kZSh4LCB5LCB3LCBoKSB7XHJcbiAqICAgICAgICAgICB2YXIgcmVjdCA9IG5ldyBub2RlLlJlY3Qoe1xyXG4gKiAgICAgICAgICAgICAgIHNoYXBlOiB7d2lkdGg6IHcsaGVpZ2h0OiBofSxcclxuICogICAgICAgICAgICAgICBwb3NpdGlvbjogW3gsIHldLFxyXG4gKiAgICAgICAgICAgICAgIHN0eWxlOiB7ZmlsbDogXCIjMTY3Q0ZGXCJ9XHJcbiAqICAgICAgICAgICB9KTtcclxuICogICAgICAgICAgIGZpc2hUb3BvLmFkZChyZWN0KTtcclxuICogICAgICAgICAgIHJldHVybiByZWN0O1xyXG4gKiAgICAgICB9XHJcbiAqICAgICAgIC8v6IqC54K56Ze06ZO+6LevXHJcbiAqICAgICAgIGZ1bmN0aW9uIG5ld0NoYWluKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgdGV4dCwgZGFzaGVkUGF0dGVybikge1xyXG4gKiAgICAgICAgICAgdmFyIHNsaW5rID0gbmV3IGxpbmsuQ2hhaW4oc3RhcnROb2RlLCBlbmROb2RlLCB7XHJcbiAqICAgICAgICAgICAgICAgc3R5bGU6IHtsaW5lRGFzaDogW2Rhc2hlZFBhdHRlcm5dfSxcclxuICogICAgICAgICAgICAgICB0ZXh0OiB7dGV4dDogdGV4dH1cclxuICogICAgICAgICAgIH0pXHJcbiAqICAgICAgICAgICBmaXNoVG9wby5hZGQoc2xpbmspO1xyXG4gKiAgICAgICAgICAgcmV0dXJuIHNsaW5rO1xyXG4gKiAgICAgICB9XHJcbiAqICAgICAgIHZhciBmcm9tID0gbmV3Tm9kZSgxMDAsIDYwLCAzMCwgMzApO1xyXG4gKiAgICAgICB2YXIgdG8gPSBuZXdOb2RlKDMwMCwgNjAsIDMwLCAzMCk7XHJcbiAqICAgICAgIG5ld0NoYWluKGZyb20sIHRvLCBbe3RleHQ6ICflgL7mlpzmlofmnKwxJywgbGlua0lkOiAxMDB9LCB7dGV4dDogJ+WAvuaWnOaWh+acrDInLCBsaW5rSWQ6IDExMX0sIHt0ZXh0OiAn5YC+5pac5paH5pysMycsIGxpbmtJZDogMTEyfV0sIDUpO1xyXG4gKi9cclxuXHJcbiAgICB2YXIgQ29ubmVjdG9yID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG4gICAgdmFyIEZsb3cgPSByZXF1aXJlKFwiLi4vRmxvd1wiKTtcclxuXHJcbiAgICBmdW5jdGlvbiBDaGFpbihzdGFydE5vZGUsZW5kTm9kZSxvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9IENvbm5lY3Rvci5UWVBFX0NIQUlOXHJcbiAgICAgICAgdmFyIG9wdCA9IEZsb3cudHJhbnNsYXRlTGlua09wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgdmFyIGNvbm5lY3RvciA9IG5ldyBDb25uZWN0b3Iob3B0KTtcclxuICAgICAgICBjb25uZWN0b3Iuc3RhcnROb2RlID0gc3RhcnROb2RlO1xyXG4gICAgICAgIGNvbm5lY3Rvci5lbmROb2RlID0gZW5kTm9kZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbm5lY3RvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBjcmVhdGVCeVBvaW50XHJcbiAgICAgKiDnlKjmiLfmjIflrprov57nur/nmoTngrnvvIzmnaXov5vooYznlLvnur9cclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyDnur/mrrXpgInpoblcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5zdHlsZV0g6IqC54K555qE5qC35byPXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3R5bGUubGluZVdpZHRoPTFdIOe6v+auteeahOWuveW6plxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN0eWxlLmxpbmVUeXBlPSdzdHJhaWdodCddIOe6v+auteeahOexu+WeiyBlZy4gJ3N0cmFpZ2h0JywgJ2phZ2dlZCcsJ2N1cnZlJ1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN0eWxlLnN0cm9rZT1cIiMwMDAwMDBcIl0g57q/5q6155qE6aKc6Imy5YC8IGVnLiAnIzE1N2NmZicgICdyZ2IoMTIyLDEyMiwxMjIpJ1xyXG4gICAgICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLnN0eWxlLmxpbmVEYXNoXSDomZrnur/nmoTpl7TpmpQgZWcuIFszLDNdXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc3ltYm9sXSDnur/mrrXnmoTnrq3lpLRcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zeW1ib2wudHlwZT0nYXJyb3cnXSDnur/mrrXnmoTnrq3lpLTnmoTnsbvlnosg5Y+v6YCJ5YC85Li677yaICdjaXJjbGUnLCAncmVjdCcsICdyb3VuZFJlY3QnLCAndHJpYW5nbGUnLCAnZGlhbW9uZCcsICdwaW4nLCAnYXJyb3cnXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3ltYm9sLnNpemU9MTBdIOe6v+auteeahOeureWktOeahOWwuuWvuFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN5bWJvbC5jb2xvcj0nIzAwMDAwMCddIOe6v+auteeahOeureWktOeahOminOiJslxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN5bWJvbC56XSBb566t5aS055qE5bGC57qn77yM6LaK5aSn6LaK5Zyo5YmN6Z2i5pi+56S6XVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zeW1ib2wuYm90aF0gW+aMh+WumuaYr+WQpuWcqOi/nue6v+eahOmmluS4juWwvumDveeUu+eureWktCDpu5jorqTmmK9mYWxzZV1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zeW1ib2wub2Zmc2V0XSDorr7nva7nrq3lpLTlnKjov57nur/kuIrnmoTlgY/np7vph4/vvIzpu5jorqTmmK8wIHNpbmNlIFYyLjMuMFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnRleHRdIOe6v+auteS4iueahOaWh+Wtl1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnRleHQudGV4dF0g5Li65pWw57uE57G75Z6L77yM6KGo56S65aSa5Liq5paH5pys55qE5pWw5o2u44CC5pWw57uE5YWD57Sg5Y+v5Lul5Li65a2X56ym5Liy77yM6KGo56S65q+P5Liq5paH5pys55qE5ZCN5a2X77yb5Lmf5Y+v5Lul5piv5Liq5a+56LGh77yM5a+56LGh5Lit5b+F6aG75oyH5a6adGV4dOWxnuaAp++8jOWFtuWAvOS4uuaWh+acrOeahOWQjeWtl++8jOWFtuS9meWxnuaAp+WImeS4uuS4muWKoeS+p+iHquWumuS5ieeahFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRleHQuY29sb3JdIOe6v+auteS4iueahOaWh+Wtl+minOiJslxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRleHQudGV4dFBvc10g5paH5a2X5L2N572u5Y+v6YCJ5YC8ICdzdGFydCcsJ2NlbnRlcicsJ2VuZCcs6buY6K6k5YC85Li6Y2VudGVyXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcnxBcnJheX0gW29wdGlvbnMudGV4dC5vZmZzZXRdIOaWh+Wtl+S9jee9ruWBj+enu+mHjyzkuLpudW1iZXLliJnmmK945YGP56e7IGFycmF55YiZ5Li6W3gseV1cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NdIOS/neeVmSDor7fkvb/nlKhvcHRpb25zLnBvc2l0aW9uLmRpcmVjdGlvbiDmjIflrprnur/mrrXotbflp4vkuI7nu4jmraIg5Zyo6IqC54K555qE5LuA5LmI5L2N572uIOm7mOiupOWAvOS4uidsZWZ0LHJpZ2h0JyAg5Y+v5Y+W5YC85Zub5Liq5pa55ZCRdG9wLGJvdHRvbSxsZWZ0LHJpZ2h0IOaWueWQkeWPr+WKoOWBj+enu+mHj+WmguWmgiBcImxlZnQrMTAsdG9wXCJcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbl0g5oyH5a6a57q/5q615L2N572uXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucG9zaXRpb24uZGlyZWN0aW9uXSDmjIflrprnur/mrrXotbflp4vkuI7nu4jmraIg5Zyo6IqC54K555qE5LuA5LmI5L2N572uIOm7mOiupOWAvOS4uidsZWZ0LHJpZ2h0JyAg5Y+v5Y+W5YC85Zub5Liq5pa55ZCRdG9wLGJvdHRvbSxsZWZ0LHJpZ2h0IOaWueWQkeWPr+WKoOWBj+enu+mHj+WmguWmgiBcImxlZnQrMTAsdG9wXCJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wb3NpdGlvbi5zdGFydE9mZnNldF0g57q/5q615byA5aeL5L2N572u55qE5YGP56e7W3gseV0gICBlZy4gc3RhcnRPZmZzZXQ6WzAsMTBdIOWcqHjkuIrlgY/np7swIHnkuIrlgY/np7sxMFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBvc2l0aW9uLmVuZE9mZnNldF0g57q/5q6157uT5p2f5L2N572u55qE5YGP56e7W3gseV0gICBlZy4gc3RhcnRPZmZzZXQ6WzAsMTBdIOWcqHjkuIrlgY/np7swIHnkuIrlgY/np7sxMFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uLmVzY2FwZURpc3RhbmNlXSDmjIflrprnur/mrrXnrKzkuIDmnaHmipjnur/nmoTplb/luqbvvIzmnIDlkI7kuIDmnaHmipjnur/nmoTplb/luqbvvIzpu5jorqTlgLzkuLpbMzAsIDMwXVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uLnBvaW50c10g5LiN5L2/55So6Ieq5Yqo6K6h566XIOaMh+Wumui/nue6v+eahOaKmOeCueS9jee9ruaVsOe7hO+8jOmmluWwvuWPr+S7peS9v+eUqGxlZnQscmlnaHQsdG9wLGJvdHRvbVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmVmZmVjdF0g57q/5LiK5Yqo5oCB5pWI5p6cXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZWZmZWN0LnNob3ddIOaYr+WQpuaYvuekuueureWktOWKqOaViFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmVmZmVjdC5wZXJpb2RdIOWKqOaViOenu+WKqOmAn+W6plxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvQ2hhbmdlUG9zaXRpb25dIOi/nue6v+eahOi/nuaOpeeCuemaj25vZGXnp7vliqjoh6rliqjliIfmjaLkvY3nva7vvIzpu5jorqTkuLpmbGFzZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnpdIOi/nue6v+eahOWxgue6p++8jOi2iuWkp+i2iuWcqOWJjemdouaYvuekulxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJ1bmRsZU9mZnNldD0zMF0g5ouG57q/5ouQ6KeS5aSE55qE6ZW/5bqmKOeUqOS6jui/nue6v+e7hClcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5idW5kbGVHYXA9MjBdIOWkmue6v+auteeahOmXtOmalCjnlKjkuo7ov57nur/nu4QpXHJcbiAgICAgKi9cclxuICAgIENoYWluLmNyZWF0ZUJ5UG9pbnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIG9wdCA9IEZsb3cudHJhbnNsYXRlTGlua09wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgdmFyIGNvbm5lY3RvciA9IG5ldyBDb25uZWN0b3Iob3B0KTtcclxuICAgICAgICByZXR1cm4gY29ubmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQ2hhaW47XHJcblxyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL2xpbmsvQ2hhaW4uanNcbi8vIG1vZHVsZSBpZCA9IDEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog6L+e57q/5pON5L2c57G7XHJcbiAqIEBhdXRob3IgbWlhby5jdW56aGlcclxuICovXHJcblxyXG4gICAgdmFyIHN5bWJvbFV0aWwgPSByZXF1aXJlKCcuLi9zaGFwZXMvU3ltYm9sJyk7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgaWNvbiA9IHJlcXVpcmUoJy4vSWNvbk9wZXJhdGlvbicpO1xyXG4gICAgZnVuY3Rpb24gTGluZU9wZXJhdGlvbk1hbmFnZXIoY29ubmVjdGlvbk1hbmFnZXIsIGFwaSkge1xyXG4gICAgICAgIHRoaXMubGluZU9wZXJhdGlvbnMgPSBbXSxcclxuICAgICAgICB0aGlzLmlzRWRpdCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IGNvbm5lY3Rpb25NYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMuX2FwaSA9IGFwaTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqICB0aGlzLmxpbmVPcGVyYXRpb25NYW5hZ2VyLmFkZEljb24oa2V5LCBvcHRpb25zKTtcclxuICAgICAqL1xyXG4gICAgTGluZU9wZXJhdGlvbk1hbmFnZXIucHJvdG90eXBlLmFkZEljb24gPSBmdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcclxuICAgICAgICAvL+WIpOaWreaYr+Wwj+Wbvuagh+WQpuWtmOWcqCDvvIzlrZjlnKjliJnnm7TmjqXov5Tlm55cclxuICAgICAgICB2YXIgbGluZU9wZXJhdGlvbkljb24gPSB6clV0aWwuZmluZChvcHRpb25zLmxpbmVOb2RlLmljb25zLCBmdW5jdGlvbihpY29uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpY29uLmtleSA9PT0ga2V5O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAobGluZU9wZXJhdGlvbkljb24pIHtcclxuICAgICAgICAgICAgdGhpcy5iaW5kT3BlcmF0aW9uKG9wdGlvbnMubGluZU5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbGluZU9wZXJhdGlvbiA9IHRoaXMuY3JlYXRPcGVyYXRpb24oa2V5LCBvcHRpb25zKTtcclxuICAgICAgICAgICAgdGhpcy5fYXBpLl9nZXRQYXJlbnRacigpLmFkZChsaW5lT3BlcmF0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5iaW5kT3BlcmF0aW9uKG9wdGlvbnMubGluZU5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbGluZU9wZXJhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIExpbmVPcGVyYXRpb25NYW5hZ2VyLnByb3RvdHlwZS5jcmVhdE9wZXJhdGlvbiA9IGZ1bmN0aW9uKGtleSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBsaW5lT3BlcmF0aW9uID0gc3ltYm9sVXRpbC5jcmVhdGVTeW1ib2wob3B0aW9ucy5pY29uUGF0aCwgMCwgMCwgb3B0aW9ucy53aWR0aCB8fCAxNSwgb3B0aW9ucy5oZWlnaHQgfHwgMTUsIDAsIG9wdGlvbnMuY29sb3J8fCcjYWFhYWFjJyk7XHJcbiAgICAgICAgbGluZU9wZXJhdGlvbi5rZXkgPSBrZXk7XHJcbiAgICAgICAgbGluZU9wZXJhdGlvbi5fd2lkdGggPSAgb3B0aW9ucy53aWR0aCB8fCAxNTsgIC8vIHBhdGjmg4XlhrXkuIvml6Dms5XorqHnrpdcclxuICAgICAgICBsaW5lT3BlcmF0aW9uLl9pc0xpbmVPcGVyYXRpb25JY29uID0gdHJ1ZTtcclxuICAgICAgICBsaW5lT3BlcmF0aW9uLmhpZGUoKTtcclxuICAgICAgICBvcHRpb25zLmxpbmVOb2RlLmljb25zLnB1c2gobGluZU9wZXJhdGlvbik7XHJcbiAgICAgICAgdGhpcy5saW5lT3BlcmF0aW9ucy5wdXNoKGxpbmVPcGVyYXRpb24pO1xyXG5cclxuICAgICAgICAvL+Wwj+WbvuaghyDngrnlh7vkuovku7YgIOWmguaenOacieWbnuiwg+WImeiwg+eUqOWbnuiwg++8jOWQpuWImea0vuWPkeS6i+S7tlxyXG4gICAgICAgIGxpbmVPcGVyYXRpb24ub24oXCJjbGlja1wiLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YSA9IG9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICBldmVudC5saW5lTm9kZSA9IG9wdGlvbnMubGluZU5vZGU7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKGV2ZW50KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGV2ZW50O1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBcImNsaWNrXCI7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMuZWxlbWVudFR5cGUgPSBcIkxpbmVPcGVyYXRpb25JY29uXCI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcGkudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgcmV0dXJuIGxpbmVPcGVyYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorqHnrpflsI/lm77moIfnmoTkvY3nva7vvIzlubbmmL7npLpcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gY29ubmVjdG9yIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgTGluZU9wZXJhdGlvbk1hbmFnZXIucHJvdG90eXBlLmJpbmRPcGVyYXRpb24gPSBmdW5jdGlvbihjb25uZWN0b3IpIHtcclxuICAgICAgICBmdW5jdGlvbiBwYXJlbnRYKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50Lm5vZGVUeXBlID09IFwiU3ViUHJvY2Vzc1wiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5wb3NpdGlvblswXSArIHBhcmVudFgobm9kZS5wYXJlbnQpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5wb3NpdGlvblswXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgZnVuY3Rpb24gcGFyZW50WShub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC5ub2RlVHlwZSA9PSBcIlN1YlByb2Nlc3NcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucG9zaXRpb25bMV0gKyBwYXJlbnRZKG5vZGUucGFyZW50KVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucG9zaXRpb25bMV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaXNFZGl0ID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBvaW50UG9zaXRpb24gPSBjb25uZWN0b3IubWlkZGxlKCksIHBvc1gsIHBvc1k7XHJcbiAgICAgICAgaWYgKGNvbm5lY3Rvci5wYXJlbnQgJiYgY29ubmVjdG9yLnBhcmVudC5ub2RlVHlwZSA9PSBcIlN1YlByb2Nlc3NcIikge1xyXG4gICAgICAgICAgICBwb3NYID0gcG9pbnRQb3NpdGlvblswXSArIHBhcmVudFgoY29ubmVjdG9yLnBhcmVudCk7XHJcbiAgICAgICAgICAgIHBvc1kgPSBwb2ludFBvc2l0aW9uWzFdICsgcGFyZW50WShjb25uZWN0b3IucGFyZW50KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwb3NYID0gcG9pbnRQb3NpdGlvblswXTtcclxuICAgICAgICAgICAgcG9zWSA9IHBvaW50UG9zaXRpb25bMV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYXJyTGVuZ3RoID0genJVdGlsLm1hcChjb25uZWN0b3IuaWNvbnMsIGZ1bmN0aW9uKGljb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGljb24uX3dpZHRoO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2YXIgdG90YWxMZW5ndGggPSB6clV0aWwucmVkdWNlKGFyckxlbmd0aCwgZnVuY3Rpb24ocHJldmlvdXNWYWx1ZSxjdXJyZW50VmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzVmFsdWUgKyBjdXJyZW50VmFsdWUgKyAxMDtcclxuICAgICAgICB9LCAwICk7XHJcblxyXG4gICAgICAgIHpyVXRpbC5lYWNoKGNvbm5lY3Rvci5pY29ucywgZnVuY3Rpb24oaWNvbiwgaW5kZXgpIHtcclxuICAgICAgICAgICAgdmFyIGNvbm5lY3RvclBvc2l0aW9uID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBpbmRleDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3JQb3NpdGlvbiArPSBhcnJMZW5ndGhba10gKyAxMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpY29uLmF0dHIoXCJwb3NpdGlvblwiLCBbcG9zWCArIGNvbm5lY3RvclBvc2l0aW9uIC0gdG90YWxMZW5ndGggLyAyLCBwb3NZICsgNV0pO1xyXG4gICAgICAgICAgICBpY29uLnNob3coKTtcclxuICAgICAgICAgICAgaWNvbi5hdHRhY2hMaW5lID0gY29ubmVjdG9yO1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgTGluZU9wZXJhdGlvbk1hbmFnZXIucHJvdG90eXBlLmhpZGVBbGxMaW5lT3BlcmF0aW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgenJVdGlsLmVhY2godGhpcy5saW5lT3BlcmF0aW9ucywgZnVuY3Rpb24obGluZU9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICBsaW5lT3BlcmF0aW9uLmhpZGUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBMaW5lT3BlcmF0aW9uTWFuYWdlci5wcm90b3R5cGUuYWRkRGVsZXRlSWNvbiA9IGZ1bmN0aW9uKGxpbmVOb2RlLG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHpyVXRpbC5kZWZhdWx0cyh7XHJcbiAgICAgICAgICAgIGljb25QYXRoOiAncGF0aDovLycgKyBpY29uLkRFTF9TVkcsXHJcbiAgICAgICAgICAgIHdpZHRoOiAxMixcclxuICAgICAgICAgICAgaGVpZ2h0OiAxNCxcclxuICAgICAgICAgICAgbGluZU5vZGU6IGxpbmVOb2RlLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBpLnJlbW92ZShlLnRhcmdldC5hdHRhY2hMaW5lKTsvL3RoaXMuY29ubmVjdGlvbk1hbmFnZXIuc2VsQ29ubmVjdG9yKTtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICAgICAgfSwgb3B0aW9ucyx0cnVlKTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRJY29uKFwiZGVsZXRlXCIsIG9wdHMpO1xyXG4gICAgfVxyXG5cclxuICAgIExpbmVPcGVyYXRpb25NYW5hZ2VyLnByb3RvdHlwZS5hZGRDaGFuZ2VMaW5lVHlwZUljb24gPSBmdW5jdGlvbihsaW5lTm9kZSxvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSB6clV0aWwuZGVmYXVsdHMoe1xyXG4gICAgICAgICAgICBpY29uUGF0aDogJ3BhdGg6Ly8nICsgaWNvbi5DSEFOR0VfTElORV9UWVBFX1NWRyxcclxuICAgICAgICAgICAgd2lkdGg6IDE1LFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDE1LFxyXG4gICAgICAgICAgICBsaW5lTm9kZTogbGluZU5vZGUsXHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcGkuY2hhbmdlU2VsZWN0Q29ubmVjdG9yVHlwZSgpO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcylcclxuICAgICAgICB9LCBvcHRpb25zLHRydWUpO1xyXG5cclxuICAgICAgICB0aGlzLmFkZEljb24oXCJjaGFuZ2VcIiwgb3B0cylcclxuICAgIH1cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IExpbmVPcGVyYXRpb25NYW5hZ2VyO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvTGluZU9wZXJhdGlvbk1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vKipcclxuICogZmlzaFRvcG9GbG9355qEbGF5b3V05a+56LGh77yM5qGG5p625o+Q5L6b55qE5biD5bGA6YO95pS+5Zyo6L+Z5Liq5a+56LGh5LiL44CC6YCa6L+HYWRkQ3VzdG9tTGF5b3V05pa55rOV5re75Yqg6Ieq5a6a5LmJ5biD5bGAXHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubGF5b3V0XHJcbiAqIEBhYnN0cmFjdFxyXG4gKi9cclxuXHJcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QnKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBmbG93VXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL0Zsb3dVdGlsXCIpO1xyXG4gICAgdmFyIEhMYXlvdXQgPSByZXF1aXJlKCcuL0hMYXlvdXQnKTtcclxuICAgIHZhciBWTGF5b3V0ID0gcmVxdWlyZSgnLi9WTGF5b3V0Jyk7XHJcbiAgICB2YXIgVHJlZUxheW91dCA9IHJlcXVpcmUoJy4vVHJlZUxheW91dCcpO1xyXG4gICAgdmFyIEZvcmNlTGF5b3V0ID0gcmVxdWlyZSgnLi9Gb3JjZUxheW91dCcpO1xyXG4gICAgdmFyIHBhcnNlUGVyY2VudCA9IGZsb3dVdGlsLnBhcnNlUGVyY2VudDtcclxuICAgIHZhciBUcmVlID0gcmVxdWlyZSgnLi4vZGF0YS9UcmVlJyk7XHJcbiAgICB2YXIgbGF5b3V0ID0ge307XHJcbiAgICBsYXlvdXQuSExheW91dCA9IEhMYXlvdXQ7XHJcbiAgICBsYXlvdXQuVkxheW91dCA9IFZMYXlvdXQ7XHJcbiAgICBsYXlvdXQuVHJlZUxheW91dCA9IFRyZWVMYXlvdXQ7XHJcbiAgICBsYXlvdXQuRm9yY2VMYXlvdXQgPSBGb3JjZUxheW91dDtcclxuICAgIGxheW91dC5UcmVlID0gVHJlZVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBhZGRDdXN0b21MYXlvdXRcclxuICAgICAqIOa3u+WKoOiHquWumuS5ieW4g+WxgOexu1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGN1c3RvbUxheW91dCDoh6rlrprkuYnluIPlsYDnmoTnsbtcclxuICAgICAqL1xyXG4gICAgbGF5b3V0LmFkZEN1c3RvbUxheW91dCA9IGZ1bmN0aW9uKGN1c3RvbUxheW91dCkge1xyXG4gICAgICAgIGxheW91dC5jdXN0b21MYXlvdXQgPSBjdXN0b21MYXlvdXQ7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGxheW91dC5nZXRMYXlvdXRSZWN0ID0gZnVuY3Rpb24gKHBvc2l0aW9uSW5mbywgY29udGFpbmVyUmVjdCwgbWFyZ2luKSB7XHJcbiAgICAgICAgbWFyZ2luID0gZmxvd1V0aWwubm9ybWFsaXplQ3NzQXJyYXkobWFyZ2luIHx8IDApO1xyXG5cclxuICAgICAgICB2YXIgY29udGFpbmVyV2lkdGggPSBjb250YWluZXJSZWN0LndpZHRoO1xyXG4gICAgICAgIHZhciBjb250YWluZXJIZWlnaHQgPSBjb250YWluZXJSZWN0LmhlaWdodDtcclxuXHJcbiAgICAgICAgdmFyIGxlZnQgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLmxlZnQsIGNvbnRhaW5lcldpZHRoKTtcclxuICAgICAgICB2YXIgdG9wID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby50b3AsIGNvbnRhaW5lckhlaWdodCk7XHJcbiAgICAgICAgdmFyIHJpZ2h0ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby5yaWdodCwgY29udGFpbmVyV2lkdGgpO1xyXG4gICAgICAgIHZhciBib3R0b20gPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLmJvdHRvbSwgY29udGFpbmVySGVpZ2h0KTtcclxuICAgICAgICB2YXIgd2lkdGggPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLndpZHRoLCBjb250YWluZXJXaWR0aCk7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8uaGVpZ2h0LCBjb250YWluZXJIZWlnaHQpO1xyXG5cclxuICAgICAgICB2YXIgdmVydGljYWxNYXJnaW4gPSBtYXJnaW5bMl0gKyBtYXJnaW5bMF07XHJcbiAgICAgICAgdmFyIGhvcml6b250YWxNYXJnaW4gPSBtYXJnaW5bMV0gKyBtYXJnaW5bM107XHJcbiAgICAgICAgdmFyIGFzcGVjdCA9IHBvc2l0aW9uSW5mby5hc3BlY3Q7XHJcblxyXG4gICAgICAgIC8vIElmIHdpZHRoIGlzIG5vdCBzcGVjaWZpZWQsIGNhbGN1bGF0ZSB3aWR0aCBmcm9tIGxlZnQgYW5kIHJpZ2h0XHJcbiAgICAgICAgaWYgKGlzTmFOKHdpZHRoKSkge1xyXG4gICAgICAgICAgICB3aWR0aCA9IGNvbnRhaW5lcldpZHRoIC0gcmlnaHQgLSBob3Jpem9udGFsTWFyZ2luIC0gbGVmdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzTmFOKGhlaWdodCkpIHtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0IC0gYm90dG9tIC0gdmVydGljYWxNYXJnaW4gLSB0b3A7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBub3QgZ2l2ZW5cclxuICAgICAgICAvLyAxLiBHcmFwaCBzaG91bGQgbm90IGV4Y2VlZHMgdGhlIGNvbnRhaW5lclxyXG4gICAgICAgIC8vIDIuIEFzcGVjdCBtdXN0IGJlIGtlZXBlZFxyXG4gICAgICAgIC8vIDMuIEdyYXBoIHNob3VsZCB0YWtlIHRoZSBzcGFjZSBhcyBtb3JlIGFzIHBvc3NpYmxlXHJcbiAgICAgICAgaWYgKGlzTmFOKHdpZHRoKSAmJiBpc05hTihoZWlnaHQpKSB7XHJcbiAgICAgICAgICAgIGlmIChhc3BlY3QgPiBjb250YWluZXJXaWR0aCAvIGNvbnRhaW5lckhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgd2lkdGggPSBjb250YWluZXJXaWR0aCAqIDAuODtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IGNvbnRhaW5lckhlaWdodCAqIDAuODtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGFzcGVjdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB3aWR0aCBvciBoZWlnaHQgd2l0aCBnaXZlbiBhc3BlY3RcclxuICAgICAgICAgICAgaWYgKGlzTmFOKHdpZHRoKSkge1xyXG4gICAgICAgICAgICAgICAgd2lkdGggPSBhc3BlY3QgKiBoZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzTmFOKGhlaWdodCkpIHtcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiBsZWZ0IGlzIG5vdCBzcGVjaWZpZWQsIGNhbGN1bGF0ZSBsZWZ0IGZyb20gcmlnaHQgYW5kIHdpZHRoXHJcbiAgICAgICAgaWYgKGlzTmFOKGxlZnQpKSB7XHJcbiAgICAgICAgICAgIGxlZnQgPSBjb250YWluZXJXaWR0aCAtIHJpZ2h0IC0gd2lkdGggLSBob3Jpem9udGFsTWFyZ2luO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNOYU4odG9wKSkge1xyXG4gICAgICAgICAgICB0b3AgPSBjb250YWluZXJIZWlnaHQgLSBib3R0b20gLSBoZWlnaHQgLSB2ZXJ0aWNhbE1hcmdpbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFsaWduIGxlZnQgYW5kIHRvcFxyXG4gICAgICAgIHN3aXRjaCAocG9zaXRpb25JbmZvLmxlZnQgfHwgcG9zaXRpb25JbmZvLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gY29udGFpbmVyV2lkdGggLyAyIC0gd2lkdGggLyAyIC0gbWFyZ2luWzNdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgICAgICAgIGxlZnQgPSBjb250YWluZXJXaWR0aCAtIHdpZHRoIC0gaG9yaXpvbnRhbE1hcmdpbjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uSW5mby50b3AgfHwgcG9zaXRpb25JbmZvLmJvdHRvbSkge1xyXG4gICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxyXG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxyXG4gICAgICAgICAgICAgICAgdG9wID0gY29udGFpbmVySGVpZ2h0IC8gMiAtIGhlaWdodCAvIDIgLSBtYXJnaW5bMF07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcclxuICAgICAgICAgICAgICAgIHRvcCA9IGNvbnRhaW5lckhlaWdodCAtIGhlaWdodCAtIHZlcnRpY2FsTWFyZ2luO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHNvbWV0aGluZyBpcyB3cm9uZyBhbmQgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IGFyZSBjYWxjdWxhdGVkIGFzIE5hTlxyXG4gICAgICAgIGxlZnQgPSBsZWZ0IHx8IDA7XHJcbiAgICAgICAgdG9wID0gdG9wIHx8IDA7XHJcbiAgICAgICAgaWYgKGlzTmFOKHdpZHRoKSkge1xyXG4gICAgICAgICAgICAvLyBXaWR0aCBtYXkgYmUgTmFOIGlmIG9ubHkgb25lIHZhbHVlIGlzIGdpdmVuIGV4Y2VwdCB3aWR0aFxyXG4gICAgICAgICAgICB3aWR0aCA9IGNvbnRhaW5lcldpZHRoIC0gbGVmdCAtIChyaWdodCB8fCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzTmFOKGhlaWdodCkpIHtcclxuICAgICAgICAgICAgLy8gSGVpZ2h0IG1heSBiZSBOYU4gaWYgb25seSBvbmUgdmFsdWUgaXMgZ2l2ZW4gZXhjZXB0IGhlaWdodFxyXG4gICAgICAgICAgICBoZWlnaHQgPSBjb250YWluZXJIZWlnaHQgLSB0b3AgLSAoYm90dG9tIHx8IDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KGxlZnQgKyBtYXJnaW5bM10sIHRvcCArIG1hcmdpblswXSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgcmVjdC5tYXJnaW4gPSBtYXJnaW47XHJcbiAgICAgICAgcmV0dXJuIHJlY3Q7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBsYXlvdXQucG9zaXRpb25FbGVtZW50ID0gZnVuY3Rpb24gKGVsLCBwb3NpdGlvbkluZm8sIGNvbnRhaW5lclJlY3QsIG1hcmdpbiwgb3B0KSB7XHJcbiAgICAgICAgdmFyIGggPSAhb3B0IHx8ICFvcHQuaHYgfHwgb3B0Lmh2WzBdO1xyXG4gICAgICAgIHZhciB2ID0gIW9wdCB8fCAhb3B0Lmh2IHx8IG9wdC5odlsxXTtcclxuICAgICAgICB2YXIgYm91bmRpbmdNb2RlID0gb3B0ICYmIG9wdC5ib3VuZGluZ01vZGUgfHwgJ2FsbCc7XHJcblxyXG4gICAgICAgIGlmICghaCAmJiAhdikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVjdDtcclxuICAgICAgICBpZiAoYm91bmRpbmdNb2RlID09PSAncmF3Jykge1xyXG4gICAgICAgICAgICByZWN0ID0gKGVsLnR5cGUgPT09ICdncm91cCcgfHwgZWwudHlwZSA9PT0gJ0dyb3VwTm9kZScpXHJcbiAgICAgICAgICAgICAgICA/IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgK3Bvc2l0aW9uSW5mby53aWR0aCB8fCAwLCArcG9zaXRpb25JbmZvLmhlaWdodCB8fCAwKVxyXG4gICAgICAgICAgICAgICAgOiBlbC5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlY3QgPSBlbC5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAgICAgaWYgKGVsLm5lZWRMb2NhbFRyYW5zZm9ybSgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gZWwuZ2V0TG9jYWxUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgICAgIC8vIE5vdGljZTogcmF3IHJlY3QgbWF5IGJlIGlubmVyIG9iamVjdCBvZiBlbCxcclxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIHNob3VsZCBub3QgYmUgbW9kaWZpZWQuXHJcbiAgICAgICAgICAgICAgICByZWN0ID0gcmVjdC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgcmVjdC5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwb3NpdGlvbkluZm8gPSBsYXlvdXQuZ2V0TGF5b3V0UmVjdChcclxuICAgICAgICAgICAgenJVdGlsLmRlZmF1bHRzKFxyXG4gICAgICAgICAgICAgICAge3dpZHRoOiByZWN0LndpZHRoLCBoZWlnaHQ6IHJlY3QuaGVpZ2h0fSxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uSW5mb1xyXG4gICAgICAgICAgICApLFxyXG4gICAgICAgICAgICBjb250YWluZXJSZWN0LFxyXG4gICAgICAgICAgICBtYXJnaW5cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBCZWNhdXNlICd0cmFubGF0ZScgaXMgdGhlIGxhc3Qgc3RlcCBpbiB0cmFuc2Zvcm1cclxuICAgICAgICAvLyAoc2VlIHpyZW5kZXIvY29yZS9UcmFuc2Zvcm1hYmxlI2dldExvY2FsVHJhbnNmcm9tKSxcclxuICAgICAgICAvLyB3ZSBjYW4ganVzdCBvbmx5IG1vZGlmeSBlbC5wb3NpdGlvbiB0byBnZXQgZmluYWwgcmVzdWx0LlxyXG4gICAgICAgIHZhciBlbFBvcyA9IGVsLnBvc2l0aW9uO1xyXG4gICAgICAgIHZhciBkeCA9IGggPyBwb3NpdGlvbkluZm8ueCAtIHJlY3QueCA6IDA7XHJcbiAgICAgICAgdmFyIGR5ID0gdiA/IHBvc2l0aW9uSW5mby55IC0gcmVjdC55IDogMDtcclxuXHJcbiAgICAgICAgZWwuYXR0cigncG9zaXRpb24nLCBib3VuZGluZ01vZGUgPT09ICdyYXcnID8gW2R4LCBkeV0gOiBbZWxQb3NbMF0gKyBkeCwgZWxQb3NbMV0gKyBkeV0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBsYXlvdXQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9sYXlvdXQvbGF5b3V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOawtOW5s+W4g+WxgDxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5sYXlvdXQuSExheW91dFxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubGF5b3V0XHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgbGF5b3V0ID0gZmlzaFRvcG9GbG93LmxheW91dDtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gKiAgICAgICBmdW5jdGlvbiBuZXdOb2RlKGdyb3VwLHRleHQpIHtcclxuICogICAgICAgICAgIHZhciByZWN0ID0gbmV3IG5vZGUuUmVjdCh7XHJcbiAqICAgICAgICAgICAgICAgICAgIHNoYXBlOnt3aWR0aDoyNSxoZWlnaHQ6MjV9LFxyXG4gKiAgICAgICAgICAgICAgICAgICBzdHlsZToge3RleHQ6dGV4dCxmaWxsOiBcIiMxNjdDRkZcIn1cclxuICogICAgICAgICAgICAgICB9KTtcclxuICogICAgICAgICAgIGdyb3VwLmFkZChyZWN0KTtcclxuICogICAgICAgICAgIHJldHVybiByZWN0O1xyXG4gKiAgICAgICB9XHJcbiAqICAgICAgIHZhciBoR3JvdXAgPSAgbmV3IG5vZGUuR3JvdXAoe1xyXG4gKiAgICAgICAgICAgc3R5bGU6IHtcclxuICogICAgICAgICAgICAgICB0ZXh0OiBcIuawtOW5s+W4g+WxgFwiLFxyXG4gKiAgICAgICAgICAgICAgIHRleHRQb3NpdGlvbjpcImJvdHRvbVwiXHJcbiAqICAgICAgICAgICB9LFxyXG4gKiAgICAgICAgICAgcG9zaXRpb246WzUwLDUwXSxcclxuICogICAgICAgICAgIGxheW91dCA6IG5ldyBsYXlvdXQuSExheW91dCh7Z2FwOjEwfSlcclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIG5ld05vZGUoaEdyb3VwLCBcIkFfMVwiKVxyXG4gKiAgICAgICBuZXdOb2RlKGhHcm91cCwgXCJBXzJcIik7XHJcbiAqICAgICAgIG5ld05vZGUoaEdyb3VwLCBcIkFfM1wiKTtcclxuICogICAgICAgbmV3Tm9kZShoR3JvdXAsIFwiQV80XCIpO1xyXG4gKiAgICAgICBuZXdOb2RlKGhHcm91cCwgXCJBXzVcIik7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChoR3JvdXApO1xyXG4gKi9cclxuXHJcbiAgICAgICAgICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgICAgICAgICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEhMYXlvdXQob3B0cykge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IGdhcCDoioLngrnkuYvpl7TnmoTpl7TpmpRcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IG1heEhlaWdodD1JbmZpbml0eSDnu4TmnIDlpKfnmoTlrr3luqbvvIzlpoLmnpzotoXov4fkvJrmjaLooYxcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGdhcDogNSxcclxuICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aDogSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdHMsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHJ1blxyXG4gICAgICAgICAgICAgKiDov5vooYzlnoLnm7TluIPlsYDvvIzkuIDoiKzkuI3pnIDopoHosIPnlKjvvIznm7TmjqXlsIbluIPlsYDnsbsg6LWL5YC857uZ57uEbGF5b3V0IOWxnuaAp+WNs+WPr1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZ3JvdXAg6ZyA6KaB6L+b6KGM5Z6C55u05biD5bGA55qE57uEXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBITGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbihncm91cCkgIHtcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50TGluZU1heFNpemUgPSAwO1xyXG4gICAgICAgICAgICAgICAgZ3JvdXAuZWFjaChmdW5jdGlvbiAoY2hpbGQsIGlkeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIENvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBjaGlsZC5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGNoaWxkLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0Q2hpbGQgPSBncm91cC5jaGlsZEF0KGlkeCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0Q2hpbGRSZWN0ID0gbmV4dENoaWxkICYmIG5leHRDaGlsZC5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3ZlWCA9IHJlY3Qud2lkdGggKyAobmV4dENoaWxkUmVjdCA/ICgtbmV4dENoaWxkUmVjdC54ICsgcmVjdC54KSA6IDApO1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRYID0geCArIG1vdmVYO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdyYXAgd2hlbiB3aWR0aCBleGNlZWRzIG1heFdpZHRoIG9yIG1lZXQgYSBgbmV3bGluZWAgZ3JvdXBcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFggPiB0aGlzLm9wdGlvbnMubWF4V2lkdGggfHwgY2hpbGQubmV3bGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFggPSBtb3ZlWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBjdXJyZW50TGluZU1heFNpemUgKyBwYXJzZUludCh0aGlzLm9wdGlvbnMuZ2FwLDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudExpbmVNYXhTaXplID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudExpbmVNYXhTaXplID0gTWF0aC5tYXgoY3VycmVudExpbmVNYXhTaXplLCByZWN0LmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQubmV3bGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblswXSA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25bMV0gPSB5O1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSBuZXh0WCArIHRoaXMub3B0aW9ucy5nYXA7XHJcbiAgICAgICAgICAgICAgICB9LHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBITGF5b3V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBITGF5b3V0O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgYWRkQ3VzdG9tTGF5b3V0XHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9sYXlvdXQvSExheW91dC5qc1xuLy8gbW9kdWxlIGlkID0gMTI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDlnoLnm7TluIPlsYA8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubGF5b3V0LlZMYXlvdXRcclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93LmxheW91dFxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGxheW91dCA9IGZpc2hUb3BvRmxvdy5sYXlvdXQ7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSwge3JvYW06ZmFsc2V9KTtcclxuICogICAgICAgZnVuY3Rpb24gbmV3Tm9kZShncm91cCx0ZXh0KSB7XHJcbiAqICAgICAgICAgICB2YXIgcmVjdCA9IG5ldyBub2RlLlJlY3Qoe1xyXG4gKiAgICAgICAgICAgICAgICAgICBzaGFwZTp7d2lkdGg6MjUsaGVpZ2h0OjI1fSxcclxuICogICAgICAgICAgICAgICAgICAgc3R5bGU6IHt0ZXh0OnRleHQsZmlsbDogXCIjMTY3Q0ZGXCJ9XHJcbiAqICAgICAgICAgICAgICAgfSk7XHJcbiAqICAgICAgICAgICBncm91cC5hZGQocmVjdCk7XHJcbiAqICAgICAgICAgICByZXR1cm4gcmVjdDtcclxuICogICAgICAgfVxyXG4gKiAgICAgICB2YXIgdkdyb3VwID0gIG5ldyBub2RlLkdyb3VwKHtcclxuICogICAgICAgICAgIHN0eWxlOiB7XHJcbiAqICAgICAgICAgICAgICAgdGV4dDogXCLlnoLnm7TluIPlsYBcIixcclxuICogICAgICAgICAgICAgICB0ZXh0UG9zaXRpb246XCJib3R0b21cIlxyXG4gKiAgICAgICAgICAgfSxcclxuICogICAgICAgICAgIHBvc2l0aW9uOls2MCw2MF0sXHJcbiAqICAgICAgICAgICBsYXlvdXQgOiBuZXcgbGF5b3V0LlZMYXlvdXQoe2dhcDoxMH0pXHJcbiAqICAgICAgIH0pO1xyXG4qXHJcbiAqICAgICAgIG5ld05vZGUodkdyb3VwLCBcIkFfMVwiKVxyXG4gKiAgICAgICBuZXdOb2RlKHZHcm91cCwgXCJBXzJcIik7XHJcbiAqICAgICAgIG5ld05vZGUodkdyb3VwLCBcIkFfM1wiKTtcclxuICogICAgICAgbmV3Tm9kZSh2R3JvdXAsIFwiQV80XCIpO1xyXG4gKiAgICAgICBuZXdOb2RlKHZHcm91cCwgXCJBXzVcIik7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZCh2R3JvdXApO1xyXG4gKi9cclxuXHJcbiAgICAgICAgICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgICAgICAgICAgdmFyIENvbm5lY3RvciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rvci5qc1wiKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVkxheW91dChvcHRzKSB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEBjZmcge051bWJlcn0gZ2FwIOiKgueCueS5i+mXtOeahOmXtOmalFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEBjZmcge051bWJlcn0gbWF4SGVpZ2h0PUluZmluaXR5IOe7hOacgOWkp+eahOmrmOW6pu+8jOWmguaenOi2hei/h+S8muaNouihjFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FwOiA1LFxyXG4gICAgICAgICAgICAgICAgICAgIG1heEhlaWdodDogSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdHMsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG1ldGhvZCBydW5cclxuICAgICAgICAgICAgICog6L+b6KGM5Z6C55u05biD5bGA77yM5LiA6Iis5LiN6ZyA6KaB6LCD55So77yM55u05o6l5bCG5biD5bGA57G7IOi1i+WAvOe7mee7hGxheW91dCDlsZ7mgKfljbPlj69cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGdyb3VwIOmcgOimgei/m+ihjOWeguebtOW4g+WxgOeahOe7hFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVkxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oZ3JvdXApICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudExpbmVNYXhTaXplID0gMDtcclxuICAgICAgICAgICAgICAgIGdyb3VwLmVhY2goZnVuY3Rpb24gKGNoaWxkLCBpZHgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBDb25uZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gY2hpbGQucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBjaGlsZC5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dENoaWxkID0gZ3JvdXAuY2hpbGRBdChpZHggKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dENoaWxkUmVjdCA9IG5leHRDaGlsZCAmJiBuZXh0Q2hpbGQuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbW92ZVkgPSByZWN0LmhlaWdodCArIChuZXh0Q2hpbGRSZWN0ID8gKC1uZXh0Q2hpbGRSZWN0LnkgKyByZWN0LnkpIDogMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFkgPSB5ICsgbW92ZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV3JhcCB3aGVuIHdpZHRoIGV4Y2VlZHMgbWF4SGVpZ2h0IG9yIG1lZXQgYSBgbmV3bGluZWAgZ3JvdXBcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFkgPiB0aGlzLm9wdGlvbnMubWF4SGVpZ2h0IHx8IGNoaWxkLm5ld2xpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBjdXJyZW50TGluZU1heFNpemUgKyBwYXJzZUludCh0aGlzLm9wdGlvbnMuZ2FwLDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRZID0gbW92ZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGluZU1heFNpemUgPSBNYXRoLm1heChjdXJyZW50TGluZU1heFNpemUsIHJlY3Qud2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLm5ld2xpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25bMF0gPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uWzFdID0geTtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gbmV4dFkgKyB0aGlzLm9wdGlvbnMuZ2FwO1xyXG4gICAgICAgICAgICAgICAgfSx0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVkxheW91dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gVkxheW91dDtcclxuXHJcblxyXG4vKipcclxuICogQG1ldGhvZCBhZGRDdXN0b21MYXlvdXRcclxuICogQGhpZGVcclxuICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL2xheW91dC9WTGF5b3V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOagkeW4g+WxgDxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5sYXlvdXQuVHJlZUxheW91dFxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubGF5b3V0XHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgbGF5b3V0ID0gZmlzaFRvcG9GbG93LmxheW91dDtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpKTtcclxuICogICAgICAgZnVuY3Rpb24gbmV3Tm9kZShkYXRhKSB7XHJcbiAqICAgICAgICAgICB2YXIgY2lyY2xlID0gbmV3IG5vZGUuQ2lyY2xlKHtcclxuICogICAgICAgICAgICAgICBzaGFwZTogeyByOiAxNSB9LFxyXG4gKiAgICAgICAgICAgICAgIHN0eWxlOiB7IGZpbGw6IFwiIzQ4ODNiNFwiIH0sXHJcbiAqICAgICAgICAgICAgICAgbmFtZTogZGF0YS5uYW1lXHJcbiAqICAgICAgICAgICB9KTtcclxuICogICAgICAgICAgIHJldHVybiBjaXJjbGU7XHJcbiAqICAgICAgIH1cclxuICogICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAqICAgICAgICAgICBjcmVhdGVOb2RlRnVuY3Rpb246IG5ld05vZGUsXHJcbiAqICAgICAgICAgICBkYXRhOlt7XHJcbiAqICAgICAgICAgICAgICAgbmFtZTogJ+agueiKgueCuScsXHJcbiAqICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcclxuICogICAgICAgICAgICAgICAgICAgeyAgIG5hbWU6ICfoioLngrkxJyxcclxuICogICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICflj7blrZDoioLngrkxJ30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICflj7blrZDoioLngrkyJ30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICflj7blrZDoioLngrkzJ30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICflj7blrZDoioLngrk0J30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICflj7blrZDoioLngrk1J30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICflj7blrZDoioLngrk2J31cclxuICogICAgICAgICAgICAgICAgICAgICAgIF1cclxuICogICAgICAgICAgICAgICAgICAgfSxcclxuICogICAgICAgICAgICAgICAgICAgeyAgIG5hbWU6ICfoioLngrkyJyxcclxuICogICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICflj7blrZDoioLngrk3J30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICflj7blrZDoioLngrk4J31dXHJcbiAqICAgICAgICAgICAgICAgICAgIH0sXHJcbiAqICAgICAgICAgICAgICAgICAgIHsgICBuYW1lOiAn6IqC54K5MycsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAn5Y+25a2Q6IqC54K5OSd9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAn5Y+25a2Q6IqC54K5MTAnfSxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ+WPtuWtkOiKgueCuTExJ30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICflj7blrZDoioLngrkxMid9XHJcbiAqICAgICAgICAgICAgICAgICAgICAgICBdXHJcbiAqICAgICAgICAgICAgICAgICAgIH1cclxuICogICAgICAgICAgICAgICBdXHJcbiAqICAgICAgICAgICB9XVxyXG4gKiAgICAgICB9XHJcbipcclxuICogICAgICAgdmFyIHRyZWVMYXlvdXQgPSBuZXcgbGF5b3V0LlRyZWVMYXlvdXQoe1xyXG4gKiAgICAgICAgICAgZmlzaFRvcG86ZmlzaFRvcG8sXHJcbiAqICAgICAgICAgICByb290TG9jYXRpb246e3g6J2NlbnRlcicsIHk6NTB9LFxyXG4gKiAgICAgICAgICAgbm9kZVBhZGRpbmc6MVxyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgdHJlZUxheW91dC5kb0xheW91dChvcHRpb25zKTtcclxuICovXHJcblxyXG4gICAgICAgICAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICAgICAgICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xyXG4gICAgICAgICAgICB2YXIgZmxvd1V0aWwgPSByZXF1aXJlKCcuLi91dGlsL0Zsb3dVdGlsJyk7XHJcbiAgICAgICAgICAgIHZhciBwYXJzZVBlcmNlbnQgPSBmbG93VXRpbC5wYXJzZVBlcmNlbnQ7XHJcbiAgICAgICAgICAgIHZhciBUcmVlRGF0YSA9IHJlcXVpcmUoJy4uL2RhdGEvVHJlZScpOyAgLy8g5pWw5o2u5L6d6LWWXHJcbiAgICAgICAgICAgIHZhciBUcmVlSGVscGVyID0gcmVxdWlyZShcIi4vdHJlZUhlbHBlclwiKTsgLy8g5biD5bGA5L6d6LWWXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFRyZWVMYXlvdXQob3B0cykge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IGZpc2hUb3BvIGZpc2hUb3Bv5a6e5L6LXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQGNmZyB7T2JqZWN0fSByb290TG9jYXRpb24g5qC56IqC54K55Z2Q5qCH77yM5pSv5oyB57ud5a+55YC877yIcHjvvInjgIHlrZfnrKblkoznmb7liIbmr5QgJ2NlbnRlcicgfCAnbGVmdCcgfCAncmlnaHQnIHwgJ3glJyB8IG51bWJlclxyXG4gICAgICAgICAgICAgICAgICogQGNmZyB7TnVtYmVyfFN0cmluZ30gcm9vdExvY2F0aW9uLnggIOagueiKgueCueaoquWdkOagh++8jOaUr+aMgee7neWvueWAvO+8iHB477yJ44CB5a2X56ym5ZKM55m+5YiG5q+UICdjZW50ZXInIHwgJ2xlZnQnIHwgJ3JpZ2h0JyB8ICd4JScgfCBudW1iZXJcclxuICAgICAgICAgICAgICAgICAqIEBjZmcge051bWJlcnxTdHJpbmd9IHJvb3RMb2NhdGlvbi55ICDmoLnoioLngrnnurXlnZDmoIfvvIzmlK/mjIHnu53lr7nlgLzvvIhweO+8ieOAgeWtl+espuWSjOeZvuWIhuavlCAnY2VudGVyJyB8ICdsZWZ0JyB8ICdyaWdodCcgfCAneCUnIHwgbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQGNmZyB7TnVtYmVyfSBsYXllclBhZGRpbmc9MTAwIOWxgumXtOi3nSzpu5jorqQ6MTAwXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQGNmZyB7TnVtYmVyfSBub2RlUGFkZGluZz0zMCDoioLngrnpl7Tot50s6buY6K6kOjMwXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICpAY2ZnIHtTdHJpbmd9IGRpcmVjdGlvbiDmoJHnmoTmlrnlkJHlj6/pgInvvJondmVydGljYWwnIHwgJ2hvcml6b250YWwnICzpu5jorqQ6dmVydGljYWxcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IGxpbmVTdHlsZSDov57nur/nmoTmoLflvI8gIOWPguingXtAbGluayBmaXNoVG9wb0Zsb3cubGluayNjb25zdHJ1Y3RvciDmnoTpgKDlh73mlbBvcHRpb25z5Y+C5pWwfVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZW50Oid2ZXJ0aWNhbCcsICAvLyB2ZXJ0aWNhbCxob3Jpem9udGFsXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZVBhZGRpbmc6MzAsIC8v6IqC54K56Ze06LedXHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJQYWRkaW5nOjEwMCwgIC8v5bGC6Ze06LedXHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdExvY2F0aW9uOiB7eDoxMDAsIHk6MjMwfSwgLy8g5qC56IqC54K55Z2Q5qCH77yM5pSv5oyB57ud5a+55YC877yIcHjvvInjgIHlrZfnrKblkoznmb7liIbmr5RcclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRlVGltZSA6IDUwMCxcclxuICAgICAgICAgICAgICAgICAgICBsaW5lU3R5bGU6IHtwb3M6J2JvdHRvbSx0b3AnLCBzeW1ib2w6e3R5cGU6J25vbmUnfX1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5vcmllbnQgPT09ICdob3Jpem9udGFsJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zLmxpbmVTdHlsZS5wb3MgPSAncmlnaHQsbGVmdCc7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0genJVdGlsLmRlZmF1bHRzKGRlZmF1bHRPcHRpb25zLCBvcHRzLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZVBhZGRpbmcgPSB0aGlzLm9wdGlvbnMubm9kZVBhZGRpbmc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxheWVyUGFkZGluZyA9IHRoaXMub3B0aW9ucy5sYXllclBhZGRpbmc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpc2hUb3BvID0gdGhpcy5vcHRpb25zLmZpc2hUb3BvO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJPZmZzZXRzID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hpZGVOb2RlcyA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG1ldGhvZCBsYXlvdXRCeVJvb3ROb2RlXHJcbiAgICAgICAgICAgICAqIOagueaNruagueiKgueCueWPiui/nue6v+eahOWFs+ezuyDvvIznlJ/miJDmoJFcclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJvb3ROb2RlIOagkeeahOagueiKgueCuVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGJvdW5kaW5nYm94IOWMheWbtOWSjFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVHJlZUxheW91dC5wcm90b3R5cGUubGF5b3V0QnlSb290Tm9kZSA9IGZ1bmN0aW9uKHJvb3ROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29ubmVjdG9ycyA9IHRoaXMuZmlzaFRvcG8uY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9yczsgIC8v5omA5pyJ57q/5q6155qE5pWw57uEXHJcbiAgICAgICAgICAgICAgICAvL+mAkuW9kueUn+aIkOagkeWei+aVsOaNrue7k+aehFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdHJhdmVyc2VOb2RlKHBhcmVudE5vZGUsIHRyZWVEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuRGF0YSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbk5vZGUgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAvLzEu5qC55o2u6L+e57q/77yM5om+5Ye66LW35aeL6IqC54K555qE5omA5pyJ5a2Q6IqC54K5XHJcbiAgICAgICAgICAgICAgICAgICAgenJVdGlsLmVhY2goY29ubmVjdG9ycywgZnVuY3Rpb24oY29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNvbm5lY3Rvci5zdGFydE5vZGUgPT09IHBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFjb25uZWN0b3IuZW5kTm9kZS5leGNsdWRlKSB7ICAgLy/lpoLmnpzmmK/mjpLmlqXnmoToioLngrnliJnkuI3liqDlhaVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbk5vZGUucHVzaChjb25uZWN0b3IuZW5kTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW5Ob2RlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8yLumBjeWOhuWtkOiKgueCuVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChjaGlsZHJlbk5vZGUsIGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZURhdGEgPSB7bmFtZTogbm9kZS5pZCwgbm9kZTpub2RlfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbkRhdGEucHVzaChub2RlRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VOb2RlKG5vZGUsIG5vZGVEYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8zLuWwhuWtkOiKgueCueaUvuWFpWNoaWxkcmVu5LitXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuRGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVEYXRhLmNoaWxkcmVuID0gY2hpbGRyZW5EYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByb290VHJlZURhdGEgPSB7bmFtZTogcm9vdE5vZGUuaWQsIG5vZGU6cm9vdE5vZGV9O1xyXG4gICAgICAgICAgICAgICAgdHJhdmVyc2VOb2RlKHJvb3ROb2RlLHJvb3RUcmVlRGF0YSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb0xheW91dCh7ZGF0YTpbcm9vdFRyZWVEYXRhXX0sIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG1ldGhvZCBkb0xheW91dFxyXG4gICAgICAgICAgICAgKiDmoLnmja7kvKDov4fmnaXmoJHlnovnu5PmnoTmlbDmja7ov5vooYzmoJHluIPlsYBcclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRyZWVEYXRhIOagkeW9ouaVsOaNrlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmVlRGF0YS5jcmVhdGVOb2RlRnVuY3Rpb249bnVsbCDliJvlu7roioLngrnnmoTlh73mlbAg5Lya5oqKZGF0YeS4reeahOaVsOaNriDkvKDpgJLov4fljrsgIOWmguaenOayoeaciem7mOiupOWwseaYr+WIm+W7uuWchuW9olxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJlZURhdGEuZGF0YSDliJvlu7rmoJHluIPlsYDmlbDmja7vvIjlv4XpobvljIXmi6xuYW1l5bGe5oCn77yJXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNOb3RCdWlsZExpbms9dHJ1ZSDpu5jorqTmmK/oh6rliqjliJvlu7rov57nur/vvIzkvKB0cnVl5YiZ5LiN5Lya6Ieq5Yqo5Yib5bu66L+e57q/XHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gYm91bmRpbmdib3gg5YyF5Zu05ZKMXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUcmVlTGF5b3V0LnByb3RvdHlwZS5kb0xheW91dCA9IGZ1bmN0aW9uKHRyZWVEYXRhLCBpc05vdEJ1aWxkTGluaykgIHtcclxuICAgICAgICAgICAgICAgIHZhciByb290RGF0YSA9IHRyZWVEYXRhLmRhdGFbMF07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVEYXRhID0gdHJlZURhdGE7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy50cmVlID0gVHJlZURhdGEuZnJvbU9wdGlvbkRhdGEocm9vdERhdGEubmFtZSwgcm9vdERhdGEuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmVlLnJvb3QuZGF0YSA9IHJvb3REYXRhO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9idWlsZE5vZGUodHJlZURhdGEpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8v5qC55o2ucm9vdOWdkOaghyDmlrnlkJEg5a+55q+P5Liq6IqC54K555qE5Z2Q5qCH6L+b6KGM5pig5bCEXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRUcmVlU2hhcGUoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnVpbGRBbGxMaW5rKGlzTm90QnVpbGRMaW5rKTtcclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9idWlsZEFsbExpbmtcclxuICAgICAgICAgICAgICog6YCS5b2S55S75Ye66L+e5o6l57q/IOS4juiuvue9ruiKgueCueWdkOagh1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgIFRyZWVMYXlvdXQucHJvdG90eXBlLl9idWlsZEFsbExpbmsgPSBmdW5jdGlvbiAoaXNOb3RCdWlsZExpbmspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJlZS50cmF2ZXJzZShmdW5jdGlvbih0cmVlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8v55S76L+e5o6l57q/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyZWVOb2RlLmNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgIWlzTm90QnVpbGRMaW5rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1aWxkTGlua0J5UGFyZW50KHRyZWVOb2RlLCB0aGlzLnRyZWVEYXRhLmNyZWF0ZUxpbmtGdW5jdGlvbilcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpc2hUb3BvLmNvbm5lY3Rpb25NYW5hZ2VyLnJlZnJlc2hMaW5lQnlOb2RlKHRyZWVOb2RlLmRhdGEubm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSx0aGlzKVxyXG4gICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGdldEJvdW5kaW5nUmVjdFxyXG4gICAgICAgICAgICAgKiDorqHnrpflh7rmoJHnmoTljIXlm7TlkoxcclxuICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBib3VuZGluZ2JveCDljIXlm7TlkoxcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRyZWVMYXlvdXQucHJvdG90eXBlLmdldEJvdW5kaW5nUmVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmVlLnRyYXZlcnNlKGZ1bmN0aW9uKHRyZWVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkUmVjdCA9IEJvdW5kaW5nUmVjdC5jcmVhdGUoe3g6dHJlZU5vZGUubGF5b3V0LnBvc2l0aW9uWzBdLCB5OnRyZWVOb2RlLmxheW91dC5wb3NpdGlvblsxXSwgd2lkdGg6dHJlZU5vZGUubGF5b3V0LndpZHRoLCBoZWlnaHQ6IHRyZWVOb2RlLmxheW91dC5oZWlnaHR9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY3QpIHJlY3QgPSBjaGlsZFJlY3QuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZWN0LnVuaW9uKGNoaWxkUmVjdCk7XHJcbiAgICAgICAgICAgICAgICB9LHRoaXMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICBUcmVlTGF5b3V0LnByb3RvdHlwZS5fc2V0VHJlZVNoYXBlID0gZnVuY3Rpb24oZG9uZUNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5pbWF0ZUNvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciB0cmVlSGVscGVyID0gbmV3IFRyZWVIZWxwZXIoXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlUGFkZGluZzogdGhpcy5ub2RlUGFkZGluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJQYWRkaW5nOiB0aGlzLmxheWVyUGFkZGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMudHJlZS50cmF2ZXJzZShmdW5jdGlvbih0cmVlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHpyVXRpbC5pbmRleE9mKHRoaXMuX2hpZGVOb2RlcywgdHJlZU5vZGUpID09IC0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHRyZWVOb2RlLmRhdGEubm9kZS5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZU5vZGUubGF5b3V0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRyZWVOb2RlLmRhdGEubm9kZS5fd2lkdGggfHwgYm91bmRpbmdSZWN0LndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0cmVlTm9kZS5kYXRhLm5vZGUuX2hlaWdodCB8fCBib3VuZGluZ1JlY3QuaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfSx0aGlzKTtcclxuICAgICAgICAgICAgICAgIHRyZWVIZWxwZXIuX2hpZGVOb2RlcyA9IHRoaXMuX2hpZGVOb2RlcztcclxuICAgICAgICAgICAgICAgIHRyZWVIZWxwZXIucnVuKHRoaXMudHJlZSk7XHJcbiAgICAgICAgICAgICAgICAvLyDmoJHnmoTmlrnlkJFcclxuICAgICAgICAgICAgICAgIHZhciBvcmllbnQgPSB0aGlzLm9wdGlvbnMub3JpZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvb3RYID0gdGhpcy5vcHRpb25zLnJvb3RMb2NhdGlvbi54O1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvb3RZID0gdGhpcy5vcHRpb25zLnJvb3RMb2NhdGlvbi55O1xyXG4gICAgICAgICAgICAgICAgdmFyIHpyV2lkdGggPSB0aGlzLmZpc2hUb3BvLmdldFdpZHRoKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgenJIZWlnaHQgPSB0aGlzLmZpc2hUb3BvLmdldEhlaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJvb3RYID09PSAnY2VudGVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RYID0genJXaWR0aCAqIDAuNTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RYID0gcGFyc2VQZXJjZW50KHJvb3RYLCB6cldpZHRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyb290WSA9PT0gJ2NlbnRlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICByb290WSA9IHpySGVpZ2h0ICogMC41O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdFkgPSBwYXJzZVBlcmNlbnQocm9vdFksIHpySGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJvb3RZID0gcGFyc2VQZXJjZW50KHJvb3RZLCB6ckhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAvLyDmsLTlubPmoJFcclxuICAgICAgICAgICAgICAgIGlmIChvcmllbnQgPT09ICdob3Jpem9udGFsJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RYID0gaXNOYU4ocm9vdFgpID8gMTAgOiByb290WDtcclxuICAgICAgICAgICAgICAgICAgICByb290WSA9IGlzTmFOKHJvb3RZKSA/IHpySGVpZ2h0ICogMC41IDogcm9vdFk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyDnurXlkJHmoJFcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RYID0gaXNOYU4ocm9vdFgpID8genJXaWR0aCAqIDAuNSA6IHJvb3RYO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RZID0gaXNOYU4ocm9vdFkpID8gMTAgOiByb290WTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHRyZWUgbGF5b3V06Ieq5Yqo566X5Ye65p2l55qEcm9vdOeahOWdkOagh1xyXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpblJvb3RYID0gdGhpcy50cmVlLnJvb3QubGF5b3V0LnBvc2l0aW9uWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0cmVlTm9kZUNvdW50ID0gdHJlZUhlbHBlci5jb3VudCh0aGlzLnRyZWUpIC0gdGhpcy5faGlkZU5vZGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy50cmVlLnRyYXZlcnNlKFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh0cmVlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHpyVXRpbC5pbmRleE9mKHRoaXMuX2hpZGVOb2RlcywgdHJlZU5vZGUpID09IC0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmllbnQgPT09ICd2ZXJ0aWNhbCcgJiYgdGhpcy5vcHRpb25zLmRpcmVjdGlvbiA9PT0gJ2ludmVyc2UnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHRyZWVOb2RlLmxheW91dC5wb3NpdGlvblswXSAtIG9yaWdpblJvb3RYICsgcm9vdFg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHJvb3RZIC0gdHJlZU5vZGUubGF5b3V0LnBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3JpZW50ID09PSAndmVydGljYWwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHRyZWVOb2RlLmxheW91dC5wb3NpdGlvblswXSAtIG9yaWdpblJvb3RYICsgcm9vdFg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHRyZWVOb2RlLmxheW91dC5wb3NpdGlvblsxXSArIHJvb3RZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3JpZW50ID09PSAnaG9yaXpvbnRhbCcgJiYgdGhpcy5vcHRpb25zLmRpcmVjdGlvbiA9PT0gJ2ludmVyc2UnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHRyZWVOb2RlLmxheW91dC5wb3NpdGlvblswXSAtIG9yaWdpblJvb3RYICsgcm9vdFk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHJvb3RYIC0gdHJlZU5vZGUubGF5b3V0LnBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3JpZW50ID09PSAnaG9yaXpvbnRhbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gdHJlZU5vZGUubGF5b3V0LnBvc2l0aW9uWzBdIC0gb3JpZ2luUm9vdFggKyByb290WTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gdHJlZU5vZGUubGF5b3V0LnBvc2l0aW9uWzFdICsgcm9vdFg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlTm9kZS5sYXlvdXQuX194ID0geDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVOb2RlLmxheW91dC5fX3kgPSB5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHkgPCBtaW5ZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluWSA9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy50cmVlLnRyYXZlcnNlKGZ1bmN0aW9uICh0cmVlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHpyVXRpbC5pbmRleE9mKHRoaXMuX2hpZGVOb2RlcywgdHJlZU5vZGUpID09IC0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pblkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlTm9kZS5sYXlvdXQucG9zaXRpb25bMF0gPSB0cmVlTm9kZS5sYXlvdXQuX194O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZU5vZGUubGF5b3V0LnBvc2l0aW9uWzFdID0gdHJlZU5vZGUubGF5b3V0Ll9feTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlTm9kZS5sYXlvdXQucG9zaXRpb25bMF0gPSB0cmVlTm9kZS5sYXlvdXQuX194O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZU5vZGUubGF5b3V0LnBvc2l0aW9uWzFdID0gdHJlZU5vZGUubGF5b3V0Ll9feSAtIG1pblk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVOb2RlLmRhdGEubm9kZS5hbmltYXRlVG8oe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFt0cmVlTm9kZS5sYXlvdXQucG9zaXRpb25bMF0sIHRyZWVOb2RlLmxheW91dC5wb3NpdGlvblsxXV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zLmFuaW1hdGVUaW1lLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2FuaW1hdGVDb3VudCA9PT0gdHJlZU5vZGVDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmVDYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+iKgueCueacieWtqeWtkOaJjeaYvuekuiDmlLbnvKnmjInpkq5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5faGlkZU5vZGVzLmxlbmd0aCA9PSAwKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmVlTm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwICYmIHRyZWVOb2RlLmRhdGEubm9kZS5fdG9nZ2xlU2hyaW5rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZU5vZGUuZGF0YS5ub2RlLl90b2dnbGVTaHJpbmsodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfSx0aGlzKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBUcmVlTGF5b3V0LnByb3RvdHlwZS5fYnVpbGROb2RlID0gZnVuY3Rpb24odHJlZURhdGEpIHtcclxuICAgICAgICAgICAgICAgIGlmKCF0cmVlRGF0YS5jcmVhdGVOb2RlRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmVlRGF0YS5jcmVhdGVOb2RlRnVuY3Rpb24gPSB0aGlzLl9kZWZhdWx0Q3JlYXRlTm9kZUZ1bmN0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy/liKTmlq3kuIDkuIvmmK/lkKbmnIlub2RlIOWmguaenOayoeacieWImeiHquW3seWIm+W7ulxyXG4gICAgICAgICAgICAgICAgdGhpcy50cmVlLnRyYXZlcnNlKGZ1bmN0aW9uKHRyZWVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIXRyZWVOb2RlLmRhdGEubm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3JlYXRlTm9kZUZ1bmN0aW9uID0gdHJlZU5vZGUuZGF0YS5jcmVhdGVOb2RlRnVuY3Rpb24gfHwgdHJlZURhdGEuY3JlYXRlTm9kZUZ1bmN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGNyZWF0ZU5vZGVGdW5jdGlvbih0cmVlTm9kZS5kYXRhLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5fY2hpbGRTaG93ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXNoVG9wby5hZGQobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVOb2RlLmRhdGEubm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSx0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVHJlZUxheW91dC5wcm90b3R5cGUuX2RlZmF1bHRDcmVhdGVOb2RlRnVuY3Rpb24gPSBmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2lyY2xlID0gdGhpcy5maXNoVG9wby5jcmVhdGVOb2RlKFwiQ2lyY2xlXCIse1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7IHI6IDE1IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHsgZmlsbDogXCIjNDg4M2I0XCIgfSxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBpdGVtLmxhYmxlIHx8IGl0ZW0ubmFtZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2lyY2xlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBUcmVlTGF5b3V0LnByb3RvdHlwZS5fYnVpbGRMaW5rQnlQYXJlbnQgPSBmdW5jdGlvbiAocGFyZW50VHJlZU5vZGUsIGNyZWF0ZUxpbmtGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGNoaWxkTGVuZ3RoID0gcGFyZW50VHJlZU5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgY2hpbGRMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1aWxkTGluayhwYXJlbnRUcmVlTm9kZSwgcGFyZW50VHJlZU5vZGUuY2hpbGRyZW5baV0sIGNyZWF0ZUxpbmtGdW5jdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAgICAgVHJlZUxheW91dC5wcm90b3R5cGUuX2J1aWxkTGluayA9IGZ1bmN0aW9uIChzdGFydFRyZWVOb2RlLCBlbmRUcmVlTm9kZSwgY3JlYXRlTGlua0Z1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbm5lY3RvciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IHN0YXJ0VHJlZU5vZGUuZGF0YS5ub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmROb2RlID0gZW5kVHJlZU5vZGUuZGF0YS5ub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNyZWF0ZUxpbmtGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1PYmogPSAgZW5kVHJlZU5vZGUuZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1PYmouc3RhcnROb2RlID0gc3RhcnROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbU9iai5lbmROb2RlID0gZW5kTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9yID0gY3JlYXRlTGlua0Z1bmN0aW9uKHBhcmFtT2JqKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlua1N0eWxlID0gdGhpcy5vcHRpb25zLmxpbmVTdHlsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZFRyZWVOb2RlLmRhdGEubGluZVN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rU3R5bGUgPSB6clV0aWwubWVyZ2UoenJVdGlsLmNsb25lKGxpbmtTdHlsZSksIGVuZFRyZWVOb2RlLmRhdGEubGluZVN0eWxlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3IgPSB0aGlzLmZpc2hUb3BvLmNyZWF0ZUxpbmsoc3RhcnROb2RlLGVuZE5vZGUsbGlua1N0eWxlKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpc2hUb3BvLmFkZChjb25uZWN0b3IpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBtZXRob2QgYWRkQ2hpbGRcclxuICAgICAgICAgICAgICog5Zyo5oyH5a6adG9wb+iKgueCueS4i+aWsOWinuS4gOS4quWtkOiKgueCuVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJlZU5vZGUg6KaB5aKe5Yqg5a2Q6IqC54K555qEdG9wb+iKgueCuVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSDmlrDlop7lrZDoioLngrnnmoTmlbDmja5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sg5aKe5Yqg5a6M5a2Q6IqC54K55LmL5ZCO6Kem5Y+R55qE5Zue6LCD5Ye95pWwXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0g5paw5aKe5Yqg55qE5a2Q6IqC54K5XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUcmVlTGF5b3V0LnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uICh0cmVlTm9kZSwgZGF0YSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdUcmVlTm9kZSA9IChuZXcgVHJlZURhdGEoZGF0YS5uYW1lKSkucm9vdDtcclxuICAgICAgICAgICAgICAgIG5ld1RyZWVOb2RlLmRhdGEgPSBkYXRhO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy50cmVlRGF0YS5jcmVhdGVOb2RlRnVuY3Rpb24obmV3VHJlZU5vZGUuZGF0YSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICBub2RlLl9jaGlsZFNob3cgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyZWVOb2RlLmNoaWxkcmVuLmxlbmd0aCA+PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hdHRyKCdwb3NpdGlvbicsIHpyVXRpbC5jbG9uZSh0cmVlTm9kZS5jaGlsZHJlblt0cmVlTm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXS5sYXlvdXQucG9zaXRpb24pKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hdHRyKCdwb3NpdGlvbicsIHpyVXRpbC5jbG9uZSh0cmVlTm9kZS5sYXlvdXQucG9zaXRpb24pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpc2hUb3BvLmFkZChub2RlKTtcclxuICAgICAgICAgICAgICAgIG5ld1RyZWVOb2RlLmRhdGEubm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9idWlsZExpbmsodHJlZU5vZGUsIG5ld1RyZWVOb2RlLCB0aGlzLnRyZWVEYXRhLmNyZWF0ZUxpbmtGdW5jdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyksIHRoaXMub3B0aW9ucy5hbmltYXRlVGltZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdHJlZU5vZGUuYWRkKG5ld1RyZWVOb2RlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaFBvc2l0aW9uQW5kTGluZShjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHRvZ2dsZUNoaWxkXHJcbiAgICAgICAgICAgICAqIOWxleekuuaIluiAhemakOiXj+mAieS4rXRvcG/oioLngrnkuIvnmoTlrZDoioLngrnku6Xlj4rkuI7lrZDoioLngrnkuYvpl7TnmoTov57nur9cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUg5qCR6IqC54K5XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUcmVlTGF5b3V0LnByb3RvdHlwZS50b2dnbGVDaGlsZCA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9nZ2xlVHJlZU5vZGUgPSB0aGlzLmZpbmRUcmVlTm9kZUJ5Tm9kZShub2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLl9jaGlsZFNob3cpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2dnbGVUcmVlTm9kZS50cmF2ZXJzZShmdW5jdGlvbiAodHJlZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyZWVOb2RlLmRhdGEubm9kZSAhPT0gbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZU5vZGUuZGF0YS5ub2RlLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHpyVXRpbC5pbmRleE9mKHRoaXMuX2hpZGVOb2RlcywgdHJlZU5vZGUpID09IC0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWRlTm9kZXMucHVzaCh0cmVlTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpc2hUb3BvLmNvbm5lY3Rpb25NYW5hZ2VyLnRvZ2dsZUxpbmVCeU5vZGUodHJlZU5vZGUuZGF0YS5ub2RlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJlZU5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVOb2RlLmRhdGEubm9kZS5fY2hpbGRTaG93ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZU5vZGUuZGF0YS5ub2RlLl90b2dnbGVTaHJpbmsgJiYgdHJlZU5vZGUuZGF0YS5ub2RlLl90b2dnbGVTaHJpbmsoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSx0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLl9jaGlsZFNob3cgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLl90b2dnbGVTaHJpbmsgJiYgbm9kZS5fdG9nZ2xlU2hyaW5rKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hQb3NpdGlvbkFuZExpbmUoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlVHJlZU5vZGUudHJhdmVyc2UoZnVuY3Rpb24gKHRyZWVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmVlTm9kZS5kYXRhLm5vZGUgIT09IG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVOb2RlLmRhdGEubm9kZS5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWRlTm9kZXMuc3BsaWNlKHpyVXRpbC5pbmRleE9mKHRoaXMuX2hpZGVOb2RlcywgdHJlZU5vZGUpLDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXNoVG9wby5jb25uZWN0aW9uTWFuYWdlci50b2dnbGVMaW5lQnlOb2RlKHRyZWVOb2RlLmRhdGEubm9kZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJlZU5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVOb2RlLmRhdGEubm9kZS5fY2hpbGRTaG93ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlTm9kZS5kYXRhLm5vZGUuX3RvZ2dsZVNocmluayAmJiB0cmVlTm9kZS5kYXRhLm5vZGUuX3RvZ2dsZVNocmluayh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fY2hpbGRTaG93ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLl90b2dnbGVTaHJpbmsgJiYgbm9kZS5fdG9nZ2xlU2hyaW5rKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaFBvc2l0aW9uQW5kTGluZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBtZXRob2QgZmluZFRyZWVOb2RlQnlOb2RlXHJcbiAgICAgICAgICAgICAqIOagueaNrnRvcG/oioLngrnmib7liLDmoJHnmoToioLngrlcclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdG9wb+iKgueCuVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVHJlZUxheW91dC5wcm90b3R5cGUuZmluZFRyZWVOb2RlQnlOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXR1cm5UcmVlTm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWUudHJhdmVyc2UoZnVuY3Rpb24gKHRyZWVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyZWVOb2RlLmRhdGEubm9kZSA9PT0gbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5UcmVlTm9kZSA9IHRyZWVOb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblRyZWVOb2RlO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBtZXRob2QgcmVtb3ZlTm9kZVxyXG4gICAgICAgICAgICAgKiDliKDpmaTpgInkuK10b3Bv6IqC54K5XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRvcG/oioLngrlcclxuICAgICAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0g5Yig6Zmk5piv5ZCm5oiQ5YqfXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUcmVlTGF5b3V0LnByb3RvdHlwZS5yZW1vdmVOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0cmVlTm9kZSA9IHRoaXMuZmluZFRyZWVOb2RlQnlOb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFRyZWVOb2RlID0gdHJlZU5vZGUucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRUcmVlTm9kZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLy/pgY3ljoYgdG9wb+S4reWIoOmZpOiHquW3seWPiuWtqeWtkOiKgueCuVxyXG4gICAgICAgICAgICAgICAgdHJlZU5vZGUudHJhdmVyc2UoZnVuY3Rpb24gKGVhY2hUcmVlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlzaFRvcG8ucmVtb3ZlKGVhY2hUcmVlTm9kZS5kYXRhLm5vZGUpOyAvL+WIoOmZpOiKgueCuVxyXG4gICAgICAgICAgICAgICAgfSx0aGlzKVxyXG5cclxuICAgICAgICAgICAgICAgIHBhcmVudFRyZWVOb2RlLnJlbW92ZSh0cmVlTm9kZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy/liKTmlq3kuIDkuIvniLboioLngrnmmK/kuI3mmK/msqHmnInkuoYs5aaC5p6c5rKh5pyJ55qE6K+dLOimgeaKiue6v+S4jist5Y+357uZ6ZqQ6JeP5o6JXHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJlZU5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJlZU5vZGUuZGF0YS5ub2RlLl9oaWRlVG9nZ2xlICYmIHBhcmVudFRyZWVOb2RlLmRhdGEubm9kZS5faGlkZVRvZ2dsZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8v6YeN5paw55Sf5oiQ5pWw5o2uXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hQb3NpdGlvbkFuZExpbmUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBtZXRob2QgcmVtb3ZlQ2hpbGRyZW5cclxuICAgICAgICAgICAgICog5Yig6Zmk6YCJ5LitdG9wb+iKgueCueS4i+eahOaJgOacieWtkOiKgueCuVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0b3Bv6IqC54K5XHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IOWIoOmZpOaYr+WQpuaIkOWKn1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVHJlZUxheW91dC5wcm90b3R5cGUucmVtb3ZlQ2hpbGRyZW4gPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyZWVOb2RlID0gdGhpcy5maW5kVHJlZU5vZGVCeU5vZGUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAvL+mBjeWOhiB0b3Bv5Lit5Yig6Zmk5a2p5a2Q6IqC54K5XHJcbiAgICAgICAgICAgICAgICB0cmVlTm9kZS50cmF2ZXJzZShmdW5jdGlvbiAoZWFjaFRyZWVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVhY2hUcmVlTm9kZSAhPT0gdHJlZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXNoVG9wby5yZW1vdmUoZWFjaFRyZWVOb2RlLmRhdGEubm9kZSk7IC8v5Yig6Zmk6IqC54K5XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSx0aGlzKVxyXG5cclxuICAgICAgICAgICAgICAgIHRyZWVOb2RlLnJlbW92ZUFsbENoaWxkcmVuKCk7XHJcbiAgICAgICAgICAgICAgICBub2RlLl9oaWRlVG9nZ2xlICYmIG5vZGUuX2hpZGVUb2dnbGUoKTsgLy90aGlzLl9oaWRlUGF0aChub2RlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL+mHjeaWsOeUn+aIkOaVsOaNrlxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoUG9zaXRpb25BbmRMaW5lKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHJlZnJlc2hQb3NpdGlvbkFuZExpbmVcclxuICAgICAgICAgICAgICog5Yi35paw5b2T5YmN5qCR5biD5bGA5Lit5omA5pyJ6IqC54K555qE5L2N572u5ZKM6IqC54K55LmL6Ze055qE6L+e57q/XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIOWIt+aWsOS5i+WQjuaJgOinpuWPkeeahOWbnuiwg+WHveaVsFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVHJlZUxheW91dC5wcm90b3R5cGUucmVmcmVzaFBvc2l0aW9uQW5kTGluZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmVlLnJvb3QudXBkYXRlRGVwdGhBbmRIZWlnaHQoMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRUcmVlU2hhcGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZS50cmF2ZXJzZShmdW5jdGlvbiAoZWFjaFRyZWVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlzaFRvcG8uY29ubmVjdGlvbk1hbmFnZXIucmVmcmVzaExpbmVCeU5vZGUoZWFjaFRyZWVOb2RlLmRhdGEubm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGNoYW5nZVBvc2l0aW9uXHJcbiAgICAgICAgICAgICAqIOabtOaUueW9k+WJjXRvcG/oioLngrnlnKjlhbblhYTlvJ/oioLngrnkuK3nmoTkvY3nva5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUg5qCR6IqC54K5XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24g6IqC54K556e75Yqo55qE5pa55ZCR77yMbmV4dOihqOekuuW+gOS4i+enu+WKqO+8jHByZXbooajnpLrlvoDkuIrnp7vliqhcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRyZWVMYXlvdXQucHJvdG90eXBlLmNoYW5nZVBvc2l0aW9uID0gZnVuY3Rpb24gKG5vZGUsIGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIHZhciBub3dJbmRleCA9IHpyVXRpbC5pbmRleE9mKHBhcmVudE5vZGUuY2hpbGRyZW4sIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldEluZGV4O1xyXG4gICAgICAgICAgICAgICAgaWYoZGlyZWN0aW9uID09IFwibmV4dFwiKXtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRJbmRleCA9IG5vd0luZGV4ICsgMTtcclxuICAgICAgICAgICAgICAgIH1lbHNlIGlmKGRpcmVjdGlvbiA9PSBcInByZXZcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SW5kZXggPSBub3dJbmRleCAtIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IHBhcmVudE5vZGUuY2hpbGRyZW5bdGFyZ2V0SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYodGFyZ2V0Tm9kZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSB0YXJnZXROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuY2hpbGRyZW5bdGFyZ2V0SW5kZXhdID0gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmNoaWxkcmVuW25vd0luZGV4XSA9IHN0b3JhZ2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hQb3NpdGlvbkFuZExpbmUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlzaFRvcG8udHJpZ2dlcigndHJlZUxheW91dDpjaGFuZ2VQb3NpdGlvbicse1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGU6bm9kZSxcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlOnBhcmVudE5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZTp0YXJnZXROb2RlXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gVHJlZUxheW91dDtcclxuXHJcblxyXG4vKipcclxuICogQG1ldGhvZCBhZGRDdXN0b21MYXlvdXRcclxuICogQGhpZGVcclxuICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL2xheW91dC9UcmVlTGF5b3V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAY29uc3RydWN0b3IgVHJlZU5vZGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBOb2RlIElEXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFRyZWVOb2RlKGlkLCBkYXRhKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6IqC54K555qE5rex5bqmXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRlcHRoID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDku6XlvZPliY3oioLngrnkuLrmoLnoioLngrnnmoTlrZDmoJHnmoTpq5jluqZcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDlrZDoioLngrnliJfooahcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPFRyZWVOb2RlPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0eXBlIHtUcmVlTm9kZX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOWtmOWCqOeahOeUqOaIt+aVsOaNrlxyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YSB8fCBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5re75Yqg5a2Q6IqC54K5XHJcbiAgICAgKiBAcGFyYW0ge1RyZWVOb2RlfSBjaGlsZFxyXG4gICAgICovXHJcbiAgICBUcmVlTm9kZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcclxuICAgICAgICBpZiAoY2hpbGQucGFyZW50ID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xyXG4gICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog56e76Zmk5a2Q6IqC54K5XHJcbiAgICAgKiBAcGFyYW0ge1RyZWVOb2RlfSBjaGlsZFxyXG4gICAgICovXHJcbiAgICBUcmVlTm9kZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcclxuICAgICAgICB2YXIgaWR4ID0genJVdGlsLmluZGV4T2YoY2hpbGRyZW4sIGNoaWxkKTtcclxuICAgICAgICBpZiAoaWR4ID49IDApIHtcclxuICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAgVHJlZU5vZGUucHJvdG90eXBlLnJlbW92ZUFsbENoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xyXG4gICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcclxuICAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuICAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDpgY3ljoblvZPliY3oioLngrnlj4rlhbbmiYDmnInlrZDoioLngrlcclxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSAgIFtjb250ZXh0XVxyXG4gICAgICovXHJcbiAgICBUcmVlTm9kZS5wcm90b3R5cGUudHJhdmVyc2UgPSBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcclxuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS50cmF2ZXJzZShjYiwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOmBjeWOhuiKguWJjeiKgueCueWPiuaJgOacieWtkOiKgueCueeahOaVsOmHj1xyXG4gICAgICovXHJcbiAgICBUcmVlTm9kZS5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLnRyYXZlcnNlKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY291bnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmm7TmlrDlvZPliY3moJHlj4rmiYDmnInlrZDmoJHnmoTpq5jluqblkozmt7HluqZcclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gZGVwdGhcclxuICAgICAqL1xyXG4gICAgVHJlZU5vZGUucHJvdG90eXBlLnVwZGF0ZURlcHRoQW5kSGVpZ2h0ID0gZnVuY3Rpb24gKGRlcHRoKSB7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IDA7XHJcbiAgICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBjaGlsZC51cGRhdGVEZXB0aEFuZEhlaWdodChkZXB0aCArIDEpO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQuaGVpZ2h0ID4gaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBjaGlsZC5oZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKyAxO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gaWRcclxuICAgICAqIEByZXR1cm4gVHJlZU5vZGVcclxuICAgICAqL1xyXG4gICAgVHJlZU5vZGUucHJvdG90eXBlLmdldE5vZGVCeUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaWQgPT09IGlkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMuY2hpbGRyZW5baV0uZ2V0Tm9kZUJ5SWQoaWQpO1xyXG4gICAgICAgICAgICBpZiAocmVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2RhdGEvVHJlZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFRyZWUoaWQpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAdHlwZSB7VHJlZU5vZGV9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yb290ID0gbmV3IFRyZWVOb2RlKGlkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOmBjeWOhuagkeeahOaJgOacieWtkOiKgueCuSjmt7HluqbkvJjlhYjpgY3ljoYpXHJcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gICBbY29udGV4dF1cclxuICAgICAqL1xyXG4gICAgVHJlZS5wcm90b3R5cGUudHJhdmVyc2UgPSBmdW5jdGlvbihjYiwgY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMucm9vdC50cmF2ZXJzZShjYiwgY29udGV4dCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog55Sf5oiQ5a2Q5qCRXHJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkIOWtkOagkeagueiKgueCuSBpZFxyXG4gICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvZGF0YS9UcmVlfVxyXG4gICAgICovXHJcbiAgICBUcmVlLnByb3RvdHlwZS5nZXRTdWJUcmVlID0gZnVuY3Rpb24oaWQpIHtcclxuICAgICAgICB2YXIgcm9vdCA9IHRoaXMuZ2V0Tm9kZUJ5SWQoaWQpO1xyXG4gICAgICAgIGlmIChyb290KSB7XHJcbiAgICAgICAgICAgIHZhciB0cmVlID0gbmV3IFRyZWUocm9vdC5pZCk7XHJcbiAgICAgICAgICAgIHRyZWUucm9vdCA9IHJvb3Q7XHJcbiAgICAgICAgICAgIHJldHVybiB0cmVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkXHJcbiAgICAgKiBAcmV0dXJuIFRyZWVOb2RlXHJcbiAgICAgKi9cclxuICAgIFRyZWUucHJvdG90eXBlLmdldE5vZGVCeUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5nZXROb2RlQnlJZChpZCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOS7jiBvcHRpb24g6YeM55qEIGRhdGEg5pWw5o2u5p6E5bu65qCRXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGRhdGFcclxuICAgICAqIEByZXR1cm4gVHJlZVxyXG4gICAgICovXHJcbiAgICBUcmVlLmZyb21PcHRpb25EYXRhID0gZnVuY3Rpb24gKGlkLCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIHRyZWUgPSBuZXcgVHJlZShpZCk7XHJcbiAgICAgICAgdmFyIHJvb3ROb2RlID0gdHJlZS5yb290O1xyXG4gICAgICAgIC8vIFJvb3Qgbm9kZVxyXG4gICAgICAgIHJvb3ROb2RlLmRhdGEgPSB7XHJcbiAgICAgICAgICAgIG5hbWU6IGlkLFxyXG4gICAgICAgICAgICBjaGlsZHJlbjogZGF0YVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkSGllcmFyY2h5KGRhdGFOb2RlLCBwYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gbmV3IFRyZWVOb2RlKGRhdGFOb2RlLm5hbWUsIGRhdGFOb2RlKTtcclxuICAgICAgICAgICAgcGFyZW50Tm9kZS5hZGQobm9kZSk7XHJcbiAgICAgICAgICAgIC8vIOmBjeWOhua3u+WKoOWtkOiKgueCuVxyXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBkYXRhTm9kZS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRIaWVyYXJjaHkoY2hpbGRyZW5baV0sIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYnVpbGRIaWVyYXJjaHkoZGF0YVtpXSwgcm9vdE5vZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJlZS5yb290LnVwZGF0ZURlcHRoQW5kSGVpZ2h0KDApO1xyXG5cclxuICAgICAgICByZXR1cm4gdHJlZTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIFRyZWUuZnJvbURhdGFTb3VyY2UgPSBmdW5jdGlvbiAoZGF0YVNvdXJjZSwgcm9vdEl0ZW0pIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gX2ZpbmRDaGlsZEl0ZW0obm9kZU5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5maWx0ZXIoZGF0YVNvdXJjZS5saW5rLGZ1bmN0aW9uKGl0ZW0pe1xyXG4gICAgICAgICAgICAgICAgaWYoaXRlbS5mcm9tID09PSBub2RlTmFtZSAmJiAhaXRlbS5wb3MpIHsgIC8vIOaVsOaNruS4reaciXBvc+WxnuaAp+eahOS4jeaYr+WtkOiKgueCuVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiBidWlsZEhpZXJhcmNoeShyb290KSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZEl0ZW0gPSBfZmluZENoaWxkSXRlbShyb290LmlkKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZEl0ZW0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gY2hpbGRJdGVtW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkVHJlZU5vZGUgPSB0cmVlTm9kZXNNYXBbaXRlbS50b107XHJcbiAgICAgICAgICAgICAgICByb290LmNoaWxkcmVuLnB1c2goY2hpbGRUcmVlTm9kZSk7XHJcbiAgICAgICAgICAgICAgICBidWlsZEhpZXJhcmNoeShjaGlsZFRyZWVOb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRyZWVOb2Rlc01hcCA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVNvdXJjZS5ub2RlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gZGF0YVNvdXJjZS5ub2RlW2ldO1xyXG4gICAgICAgICAgICB2YXIgdHJlZU5vZGUgPSBuZXcgVHJlZU5vZGUobm9kZS5uYW1lLG5vZGUpO1xyXG4gICAgICAgICAgICB0cmVlTm9kZXNNYXBbbm9kZS5uYW1lXSA9IHRyZWVOb2RlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRyZWUgPSBuZXcgVHJlZShyb290SXRlbS5uYW1lKTtcclxuICAgICAgICB2YXIgcm9vdE5vZGUgPSB0cmVlLnJvb3Q7XHJcbiAgICAgICAgLy8gUm9vdCBub2RlXHJcbiAgICAgICAgcm9vdE5vZGUuZGF0YSA9IHJvb3RJdGVtO1xyXG5cclxuXHJcbiAgICAgICAgYnVpbGRIaWVyYXJjaHkodHJlZS5yb290KTtcclxuICAgICAgICB0cmVlLnJvb3QudXBkYXRlRGVwdGhBbmRIZWlnaHQoMCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0cmVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRyZWU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9kYXRhL1RyZWUuanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS92ZWN0b3InKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuXHJcbiAgICBmdW5jdGlvbiBUcmVlSGVscGVyKG9wdHMpIHtcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcclxuXHJcbiAgICAgICAgdGhpcy5ub2RlUGFkZGluZyA9IG9wdHMubm9kZVBhZGRpbmcgfHwgMzA7XHJcblxyXG4gICAgICAgIHRoaXMubGF5ZXJQYWRkaW5nID0gb3B0cy5sYXllclBhZGRpbmcgfHwgMTAwO1xyXG5cclxuICAgICAgICB0aGlzLl9sYXllck9mZnNldHMgPSBbXTtcclxuXHJcbiAgICAgICAgdGhpcy5fbGF5ZXJzID0gW107XHJcblxyXG4gICAgICAgIHRoaXMuX2hpZGVOb2RlcyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIFRyZWVIZWxwZXIucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKHRyZWUpIHtcclxuICAgICAgICB2YXIgY291bnQgPSAwO1xyXG4gICAgICAgIHRyZWUudHJhdmVyc2UoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb3VudDtcclxuICAgIH1cclxuXHJcbiAgICBUcmVlSGVscGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAodHJlZSkge1xyXG4gICAgICAgIHRoaXMuX2xheWVyT2Zmc2V0cy5sZW5ndGggPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5yb290LmhlaWdodCArIDE7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLl9sYXllck9mZnNldHNbaV0gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXllcnNbaV0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlTm9kZVhQb3NpdGlvbih0cmVlLnJvb3QpO1xyXG4gICAgICAgIHZhciByb290ID0gdHJlZS5yb290O1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZU5vZGVZUG9zaXRpb24ocm9vdCwgMCwgcm9vdC5sYXlvdXQuaGVpZ2h0KTtcclxuICAgIH07XHJcblxyXG4gICAgVHJlZUhlbHBlci5wcm90b3R5cGUuX3VwZGF0ZU5vZGVYUG9zaXRpb24gPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHZhciBtaW5YID0gSW5maW5pdHk7XHJcbiAgICAgICAgdmFyIG1heFggPSAtSW5maW5pdHk7XHJcbiAgICAgICAgbm9kZS5sYXlvdXQucG9zaXRpb24gPSBub2RlLmxheW91dC5wb3NpdGlvbiB8fCB2ZWMyLmNyZWF0ZSgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBpZih6clV0aWwuaW5kZXhPZih0aGlzLl9oaWRlTm9kZXMsIGNoaWxkKSA9PSAtMSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVOb2RlWFBvc2l0aW9uKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gY2hpbGQubGF5b3V0LnBvc2l0aW9uWzBdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHggPCBtaW5YKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluWCA9IHg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoeCA+IG1heFgpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXhYID0geDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwICYmICh6clV0aWwuaW5kZXhPZih0aGlzLl9oaWRlTm9kZXMsIG5vZGUuY2hpbGRyZW5bMF0pID09IC0xKSkge1xyXG4gICAgICAgICAgICBub2RlLmxheW91dC5wb3NpdGlvblswXSA9IChtaW5YICsgbWF4WCkgLyAyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGUubGF5b3V0LnBvc2l0aW9uWzBdID0gMDtcclxuICAgICAgICAgICAgbm9kZS5oZWlnaHQgPSAwOyAgIC8vIOmakOiXj+iKgueCueeahCDmt7Hluqborr7kuLowXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvZmYgPSB0aGlzLl9sYXllck9mZnNldHNbbm9kZS5kZXB0aF0gfHwgMDtcclxuICAgICAgICBpZiAob2ZmID4gbm9kZS5sYXlvdXQucG9zaXRpb25bMF0pIHtcclxuICAgICAgICAgICAgdmFyIHNoaWZ0ID0gb2ZmIC0gbm9kZS5sYXlvdXQucG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgIHRoaXMuX3NoaWZ0U3VidHJlZShub2RlLCBzaGlmdCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBub2RlLmRlcHRoICsgMTsgaiA8IG5vZGUuaGVpZ2h0ICsgbm9kZS5kZXB0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllck9mZnNldHNbal0gKz0gc2hpZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbGF5ZXJPZmZzZXRzW25vZGUuZGVwdGhdID0gbm9kZS5sYXlvdXQucG9zaXRpb25bMF0gKyBub2RlLmxheW91dC53aWR0aCArIHRoaXMubm9kZVBhZGRpbmc7XHJcblxyXG4gICAgICAgIGlmKHpyVXRpbC5pbmRleE9mKHRoaXMuX2xheWVyc1tub2RlLmRlcHRoXSwgbm9kZSkgPT0gLTEpe1xyXG4gICAgICAgICAgICB0aGlzLl9sYXllcnNbbm9kZS5kZXB0aF0ucHVzaChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIFRyZWVIZWxwZXIucHJvdG90eXBlLl9zaGlmdFN1YnRyZWUgPSBmdW5jdGlvbiAocm9vdCwgb2Zmc2V0KSB7XHJcbiAgICAgICAgcm9vdC5sYXlvdXQucG9zaXRpb25bMF0gKz0gb2Zmc2V0O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZih6clV0aWwuaW5kZXhPZih0aGlzLl9oaWRlTm9kZXMscm9vdC5jaGlsZHJlbltpXSkgPT0gLTEpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hpZnRTdWJ0cmVlKHJvb3QuY2hpbGRyZW5baV0sIG9mZnNldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIFRyZWVIZWxwZXIucHJvdG90eXBlLl91cGRhdGVOb2RlWVBvc2l0aW9uID0gZnVuY3Rpb24gKG5vZGUsIHksIHByZXZMYXllckhlaWdodCkge1xyXG4gICAgICAgIGlmKHpyVXRpbC5pbmRleE9mKHRoaXMuX2hpZGVOb2Rlcyxub2RlKSA9PSAtMSl7XHJcbiAgICAgICAgICAgIG5vZGUubGF5b3V0LnBvc2l0aW9uWzFdID0geTtcclxuICAgICAgICAgICAgdmFyIGxheWVySGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsYXllckhlaWdodCA9IE1hdGgubWF4KG5vZGUuY2hpbGRyZW5baV0ubGF5b3V0LmhlaWdodCwgbGF5ZXJIZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBsYXllclBhZGRpbmcgPSB0aGlzLmxheWVyUGFkZGluZztcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiAobGF5ZXJQYWRkaW5nKSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgbGF5ZXJQYWRkaW5nID0gbGF5ZXJQYWRkaW5nKG5vZGUuZGVwdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTm9kZVlQb3NpdGlvbihub2RlLmNoaWxkcmVuW2pdLCB5ICsgbGF5ZXJQYWRkaW5nICsgcHJldkxheWVySGVpZ2h0LCBsYXllckhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gVHJlZUhlbHBlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL2xheW91dC90cmVlSGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOWKm+WvvOWQkeW4g+WxgDxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5sYXlvdXQuRm9yY2VMYXlvdXRcclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93LmxheW91dFxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGxheW91dCA9IGZpc2hUb3BvRmxvdy5sYXlvdXQ7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSwge3JvYW06ZmFsc2V9KTtcclxuICogICAgICAgZnVuY3Rpb24gbmV3Tm9kZShkYXRhKSB7XHJcbiAqICAgICAgICAgICB2YXIgY2lyY2xlID0gbmV3IG5vZGUuQ2lyY2xlKHtcclxuICogICAgICAgICAgICAgICBzaGFwZTogeyByOiAxNSB9LFxyXG4gKiAgICAgICAgICAgICAgIHN0eWxlOiB7IGZpbGw6IFwiIzQ4ODNiNFwiIH0sXHJcbiAqICAgICAgICAgICAgICAgbmFtZTogZGF0YS5uYW1lXHJcbiAqICAgICAgICAgICB9KTtcclxuICogICAgICAgICAgIHJldHVybiBjaXJjbGU7XHJcbiAqICAgICAgIH1cclxuICogICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAqICAgICAgICAgICBjcmVhdGVOb2RlRnVuY3Rpb246IG5ld05vZGUsXHJcbiAqICAgICAgICAgICBkYXRhOlt7bm9kZXM6W1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAn6IqC54K5MSd9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAn6IqC54K5Mid9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAn6IqC54K5Myd9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAn6IqC54K5NCd9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAn6IqC54K5NSd9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAn6IqC54K5Nid9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAn6IqC54K5Nyd9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAn6IqC54K5OCd9XHJcbiAqICAgICAgICAgICAgICAgICAgICAgICBdLFxyXG4gKiAgICAgICAgICAgICAgICAgICBsaW5rczpbXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge3NvdXJjZTon6IqC54K5MScsIHRhcmdldDon6IqC54K5Mid9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzb3VyY2U6J+iKgueCuTInLCB0YXJnZXQ6J+iKgueCuTMnfSxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7c291cmNlOifoioLngrkzJywgdGFyZ2V0OifoioLngrk0J30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge3NvdXJjZTon6IqC54K5NCcsIHRhcmdldDon6IqC54K5NSd9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzb3VyY2U6J+iKgueCuTUnLCB0YXJnZXQ6J+iKgueCuTYnfSxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7c291cmNlOifoioLngrk2JywgdGFyZ2V0OifoioLngrk3J30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge3NvdXJjZTon6IqC54K5NycsIHRhcmdldDon6IqC54K5OCd9XHJcbiAqICAgICAgICAgICAgICAgICAgICAgICBdXHJcbiAqICAgICAgICAgICB9XVxyXG4gKiAgICAgICB9XHJcbiAqICAgICAgIHZhciBmb3JjZUxheW91dCA9IG5ldyBsYXlvdXQuRm9yY2VMYXlvdXQoe1xyXG4gKiAgICAgICAgICBmaXNoVG9wbzpmaXNoVG9wbyxcclxuICogICAgICAgICAgIHJlcHVsc2lvbjogMjAwXHJcbiAqICAgICAgIH0pO1xyXG4gKiAgICAgICBmb3JjZUxheW91dC5kb0xheW91dChvcHRpb25zKTtcclxuICovXHJcblxyXG5cclxuXHJcbiAgICB2YXIgZm9yY2VIZWxwZXIgPSByZXF1aXJlKCcuL2ZvcmNlSGVscGVyJyk7XHJcbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yJyk7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICBmdW5jdGlvbiBGb3JjZUxheW91dChvcHRzKSB7XHJcbiAgICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gZmlzaFRvcG8gZmlzaFRvcG/lrp7kvotcclxuICAgICAgICAgKi9cclxuICAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBbcmVwdWxzaW9uPTEwMF0g6IqC54K55LmL6Ze055qE5pal5Yqb5Zug5a2Q44CC6K+l5YC86LaK5aSn6IqC54K55LmL6Ze055qE5pal5Yqb6LaK5aSn77yM5Lik5Liq6IqC54K56Ze055qE6Led56a75Lmf5Lya6LaK6L+c77yM6buY6K6k5Li6MTAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gW2dyYXZpdHk9MC4xXSDoioLngrnlj5fliLDnmoTlkJHkuK3lv4PnmoTlvJXlipvlm6DlrZDjgILor6XlgLzotorlpKfoioLngrnotorlvoDkuK3lv4PngrnpnaDmi6LjgILpu5jorqTkuLowLjFcclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IFtlZGdlTGVuZ3RoPTMwXSDovrnnmoTkuKTkuKroioLngrnkuYvpl7TnmoTot53nprvvvIzov5nkuKrot53nprvkuZ/kvJrlj5cgcmVwdWxzaW9u5b2x5ZON44CCIOm7mOiupOS4ujMwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7Qm9vbGVhbn0gW29uY2U9dHJ1ZV0g5piv5ZCm5Y+q6L+b6KGM5biD5bGA5LiA5qyh44CCPGJyLz5cclxuICAgICAgICAgKiDlpoLmnpzorr7nva7kuLpmYWxzZe+8jOWcqOW4g+WxgOe7k+adn+S7peWQju+8jOWGjeaLluaLveiKgueCue+8jOiKgueCueeahOWumuS9jeS8muiuvue9ruS4umZpeGVk77yM6YeK5pS+6KKr5ouW5ou955qE6IqC54K577yM6IqC54K55Lya5Zue5Yiw5Y6f5p2l55qE5L2N572uLCDlr7zoh7Tph43mlrDluIPlsYDvvIzlkIzmoLfkvJrlho3mrKHop6blj5Fmb3JjZUxheW91dEVuZOS6i+S7tuOAglxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gW3JlY3RdIOW4g+WxgOaYvuekuuiMg+WbtFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBbcmVjdC54XSDluIPlsYDmmL7npLrojIPlm7R45Z2Q5qCHXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBbcmVjdC55XSDluIPlsYDmmL7npLrojIPlm7R55Z2Q5qCHXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBbcmVjdC53aWR0aF0g5biD5bGA5pi+56S65a695bqmXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBbcmVjdC5oZWlnaHRdIOW4g+WxgOaYvuekuumrmOW6plxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge0Jvb2xlYW59IFtsYXlvdXRBbmltYXRpb249dHJ1ZV0g5piv5ZCm5pi+56S65biD5bGA5Yqo55S7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBbbGluZVN0eWxlXSDov57nur/nmoTmoLflvI8gIOWPguingXtAbGluayBmaXNoVG9wb0Zsb3cubGluayNjb25zdHJ1Y3RvciDmnoTpgKDlh73mlbBvcHRpb25z5Y+C5pWwfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZmlzaFRvcG8gPSBvcHRzLmZpc2hUb3BvO1xyXG4gICAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgcmVwdWxzaW9uOiAxMDAsICAvL+iKgueCueS5i+mXtOeahOaWpeWKm+WboOWtkOOAguivpeWAvOi2iuWkp+iKgueCueS5i+mXtOeahOaWpeWKm+i2iuWkp++8jOS4pOS4quiKgueCuemXtOeahOi3neemu+S5n+S8mui2iui/nO+8jOm7mOiupOS4ujEwMFxyXG4gICAgICAgICAgICBncmF2aXR5OiAwLjEsIC8v6IqC54K55Y+X5Yiw55qE5ZCR5Lit5b+D55qE5byV5Yqb5Zug5a2Q44CC6K+l5YC86LaK5aSn6IqC54K56LaK5b6A5Lit5b+D54K56Z2g5oui44CC6buY6K6k5Li6MC4xXHJcbiAgICAgICAgICAgIGVkZ2VMZW5ndGg6IDMwLCAvLyDovrnnmoTkuKTkuKroioLngrnkuYvpl7TnmoTot53nprvvvIzov5nkuKrot53nprvkuZ/kvJrlj5cgcmVwdWxzaW9u44CCIOm7mOiupOS4ujMwXHJcbiAgICAgICAgICAgIG9uY2U6dHJ1ZSxcclxuICAgICAgICAgICAgbGF5b3V0QW5pbWF0aW9uOnRydWUsXHJcbiAgICAgICAgICAgIHJlY3Q6IHt4OjAsIHk6MCwgd2lkdGg6dGhpcy5maXNoVG9wby5nZXRXaWR0aCgpICxoZWlnaHQ6dGhpcy5maXNoVG9wby5nZXRIZWlnaHQoKX0sXHJcbiAgICAgICAgICAgIGxpbmVTdHlsZToge3N5bWJvbDp7dHlwZTonbm9uZSd9fSxcclxuICAgICAgICAgICAgcHJlc2VydmVkUG9pbnRzOiB7fVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHpyVXRpbC5kZWZhdWx0cyhkZWZhdWx0T3B0aW9ucywgb3B0cywgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGRvTGF5b3V0XHJcbiAgICAgKiDmoLnmja5mb3JjZURhdGHov5vooYzlipvlr7zlkJHluIPlsYBcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmb3JjZURhdGEg5Yqb5a+85ZCR5pWw5o2uXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmb3JjZURhdGEuY3JlYXRlTm9kZUZ1bmN0aW9uPW51bGwg5Yib5bu66IqC54K555qE5Ye95pWwIOS8muaKimRhdGHkuK1ub2Rlc+eahOaVsOaNriDkvKDpgJLov4fljrsgIOWmguaenOayoeaciem7mOiupOWwseaYr+WIm+W7uuWchuW9olxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm9yY2VEYXRhLmNyZWF0ZUxpbmtGdW5jdGlvbj1udWxsIOWIm+W7uue6v+auteWHveaVsO+8jOWPguaVsOaYr2RhdGEubGlua3PmlbDmja7vvIzlpoLmnpzmsqHmnInpu5jorqTliJvlu7rnm7Tnur8gc2luY2UgVjIuMy4wXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZm9yY2VEYXRhLmRhdGEg5Yib5bu65Yqb5a+85ZCR5biD5bGA5pWw5o2uXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZm9yY2VEYXRhLmRhdGEubm9kZXMg5Yib5bu65Yqb5a+85ZCR5biD5bGA6IqC54K555qE5a+56LGh5pWw5o2u77yI5b+F6aG75YyF5ousbmFtZeWxnuaAp++8iVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZvcmNlRGF0YS5kYXRhLmxpbmtzIOWIm+W7uuWKm+WvvOWQkeW4g+WxgOi/nue6v+eahOWvueixoeaVsOaNru+8iOW/hemhu+WMheaLrG5hbWXlsZ7mgKfvvIlcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIEZvcmNlTGF5b3V0LnByb3RvdHlwZS5kb0xheW91dCA9IGZ1bmN0aW9uKGZvcmNlRGF0YSkge1xyXG4gICAgICAgICB2YXIgcm9vdERhdGEgPSBmb3JjZURhdGEuZGF0YVswXTtcclxuICAgICAgICAgdGhpcy5hbGxOb2RlcyA9IHRoaXMuX2J1aWxkTm9kZShyb290RGF0YS5ub2RlcywgZm9yY2VEYXRhLmNyZWF0ZU5vZGVGdW5jdGlvbik7XHJcbiAgICAgICAgIHRoaXMuYWxsTGlua3MgPSB0aGlzLl9idWlsZExpbmtzKHJvb3REYXRhLmxpbmtzLCBmb3JjZURhdGEuY3JlYXRlTGlua0Z1bmN0aW9uKTtcclxuICAgICAgICAgdGhpcy5fZm9yY2VJbnMoKTtcclxuXHJcbiAgICAgICAgIHRoaXMuX3N0YXJ0Rm9yY2VMYXlvdXRJdGVyYXRpb24oKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBhdXRvTGF5b3V0XHJcbiAgICAgKiDmoLnmja7lt7LmnInoioLngrnov5vooYzlipvlr7zlkJHluIPlsYBcclxuICAgICAqIEBzaW5jZSBWMi4zLjBcclxuICAgICAqL1xyXG4gICAgRm9yY2VMYXlvdXQucHJvdG90eXBlLmF1dG9MYXlvdXQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmFsbE5vZGVzID0gdGhpcy5maXNoVG9wby5hbGxOb2RlcztcclxuICAgICAgICB0aGlzLmFsbExpbmtzID0gdGhpcy5maXNoVG9wby5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0b3JzO1xyXG4gICAgICAgIHRoaXMuX2ZvcmNlSW5zKCk7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRGb3JjZUxheW91dEl0ZXJhdGlvbigpO1xyXG4gICAgfVxyXG5cclxuICAgIEZvcmNlTGF5b3V0LnByb3RvdHlwZS5fYnVpbGROb2RlID0gZnVuY3Rpb24oZGF0YXMsIGNyZWF0ZU5vZGVGdW5jdGlvbikge1xyXG4gICAgICAgIGlmKCFmaXNoLmlzRnVuY3Rpb24oY3JlYXRlTm9kZUZ1bmN0aW9uKSkge1xyXG4gICAgICAgICAgICBjcmVhdGVOb2RlRnVuY3Rpb24gPSB0aGlzLl9kZWZhdWx0Q3JlYXRlTm9kZUZ1bmN0aW9uLmJpbmQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhbGxOb2RlcyA9IFtdO1xyXG4gICAgICAgIC8v5Yik5pat5LiA5LiL5piv5ZCm5pyJbm9kZSDlpoLmnpzmsqHmnInliJnoh6rlt7HliJvlu7pcclxuICAgICAgICB6clV0aWwuZWFjaChkYXRhcywgIGZ1bmN0aW9uKGl0ZW0saWR4KSB7XHJcbiAgICAgICAgICAgIGlmKCFpdGVtLm5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjcmVhdGVOb2RlID0gaXRlbS5jcmVhdGVOb2RlRnVuY3Rpb24gfHwgY3JlYXRlTm9kZUZ1bmN0aW9uO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBjcmVhdGVOb2RlKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maXNoVG9wby5hZGQobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGROb2RlRXZlbnQobm9kZSxpZHgpO1xyXG4gICAgICAgICAgICAgICAgYWxsTm9kZXMucHVzaChub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sdGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIGFsbE5vZGVzO1xyXG4gICAgfVxyXG5cclxuICAgIEZvcmNlTGF5b3V0LnByb3RvdHlwZS5fYWRkTm9kZUV2ZW50ID0gZnVuY3Rpb24obm9kZSxpZHgpIHtcclxuICAgICAgICBpZighdGhpcy5vcHRpb25zLm9uY2UpIHtcclxuICAgICAgICAgICAgbm9kZS5vbignZHJhZycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmZvcmNlTGF5b3V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZvcmNlTGF5b3V0Lndhcm1VcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLl9sYXlvdXRpbmcgJiYgdGhpcy5fc3RhcnRGb3JjZUxheW91dEl0ZXJhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5mb3JjZUxheW91dC5zZXRGaXhlZChpZHgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LHRoaXMpLm9uKCdkcmFnZW5kJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZm9yY2VMYXlvdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZm9yY2VMYXlvdXQuc2V0VW5maXhlZChpZHgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LHRoaXMpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIEZvcmNlTGF5b3V0LnByb3RvdHlwZS5fZGVmYXVsdENyZWF0ZU5vZGVGdW5jdGlvbiA9IGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICB2YXIgY2lyY2xlID0gdGhpcy5maXNoVG9wby5jcmVhdGVOb2RlKFwiQ2lyY2xlXCIse1xyXG4gICAgICAgICAgICBzaGFwZTogeyByOiAxNSB9LFxyXG4gICAgICAgICAgICBzdHlsZTogeyBmaWxsOiBcIiM0ODgzYjRcIiB9LFxyXG4gICAgICAgICAgICBuYW1lOiBpdGVtLmxhYmxlIHx8IGl0ZW0ubmFtZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjaXJjbGU7XHJcbiAgICB9XHJcblxyXG4gICAgRm9yY2VMYXlvdXQucHJvdG90eXBlLl9idWlsZExpbmtzID0gZnVuY3Rpb24obGlua3MsY3JlYXRlTGlua0Z1bmN0aW9uKSB7XHJcbiAgICAgICAgdmFyIGFsbExpbmtzID0gW107XHJcblxyXG4gICAgICAgIHpyVXRpbC5lYWNoKGxpbmtzLCBmdW5jdGlvbihsaW5rKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFydE5vZGUgPSB0aGlzLmZpc2hUb3BvLmNoaWxkT2ZOYW1lKGxpbmsuc291cmNlKTtcclxuICAgICAgICAgICAgdmFyIGVuZE5vZGUgPSB0aGlzLmZpc2hUb3BvLmNoaWxkT2ZOYW1lKGxpbmsudGFyZ2V0KTtcclxuICAgICAgICAgICAgaWYoc3RhcnROb2RlICYmIGVuZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICB2YXIgY29ubmVjdG9yID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmKGNyZWF0ZUxpbmtGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbU9iaiA9IGxpbms7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1PYmouc3RhcnROb2RlID0gc3RhcnROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtT2JqLmVuZE5vZGUgPSBlbmROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3RvciA9IGNyZWF0ZUxpbmtGdW5jdGlvbihwYXJhbU9iaik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5rU3R5bGUgPSB0aGlzLm9wdGlvbnMubGluZVN0eWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5rLnN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtTdHlsZSA9IHpyVXRpbC5tZXJnZSh6clV0aWwuY2xvbmUobGlua1N0eWxlKSwgbGluay5zdHlsZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3RvciA9IHRoaXMuZmlzaFRvcG8uY3JlYXRlTGluayhzdGFydE5vZGUsZW5kTm9kZSxsaW5rU3R5bGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5maXNoVG9wby5hZGQoY29ubmVjdG9yKTtcclxuICAgICAgICAgICAgICAgIGFsbExpbmtzLnB1c2goY29ubmVjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sdGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIGFsbExpbmtzO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBGb3JjZUxheW91dC5wcm90b3R5cGUuX2ZvcmNlSW5zID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLm9wdGlvbnMucmVjdDtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByZXNlcnZlZFBvaW50cyA9IHRoaXMub3B0aW9ucy5wcmVzZXJ2ZWRQb2ludHM7XHJcbiAgICAgICAgdmFyIG5vZGVzID0genJVdGlsLm1hcCh0aGlzLmFsbE5vZGVzLCBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciByZXAgPSB0aGlzLm9wdGlvbnMucmVwdWxzaW9uOyBub2RlLncgPSByZXA7IG5vZGUucmVwID0gcmVwOyBub2RlLnAgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdzogcmVwLFxyXG4gICAgICAgICAgICAgICAgcmVwOiByZXAsXHJcbiAgICAgICAgICAgICAgICBwOiBudWxsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSx0aGlzKTtcclxuICAgICAgICBpZiAocHJlc2VydmVkUG9pbnRzKSB7XHJcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHRoaXMuYWxsTm9kZXMsIGZ1bmN0aW9uKG5vZGUsaWR4KSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmF0dHIoXCJwb3NpdGlvblwiLCBwcmVzZXJ2ZWRQb2ludHNbaWR4XSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHpyVXRpbC5lYWNoKHRoaXMuYWxsTGlua3MsIGZ1bmN0aW9uKGxpbmspIHtcclxuICAgICAgICAgICAgbGluay5uMSA9IGxpbmsuc3RhcnROb2RlLFxyXG4gICAgICAgICAgICBsaW5rLm4yID0gbGluay5lbmROb2RlLFxyXG4gICAgICAgICAgICBsaW5rLmQgPSB0aGlzLm9wdGlvbnMuZWRnZUxlbmd0aDtcclxuICAgICAgICAgICAgbGluay5jdXJ2ZW5lc3MgPSAwO1xyXG4gICAgICAgIH0sdGhpcylcclxuXHJcbiAgICAgICAgdmFyIGZvcmNlSW5zdGFuY2UgPSBmb3JjZUhlbHBlcih0aGlzLmFsbE5vZGVzLCB0aGlzLmFsbExpbmtzLCB7XHJcbiAgICAgICAgICAgIHJlY3Q6IHJlY3QsXHJcbiAgICAgICAgICAgIGdyYXZpdHk6IHRoaXMub3B0aW9ucy5ncmF2aXR5XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIG9sZFN0ZXAgPSBmb3JjZUluc3RhbmNlLnN0ZXA7XHJcbiAgICAgICAgZm9yY2VJbnN0YW5jZS5zdGVwID0gZnVuY3Rpb24oY2IpIHtcclxuICAgICAgICAgICAgenJVdGlsLmVhY2godGhpcy5hbGxOb2RlcywgZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzLmZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5jb3B5KG5vZGVzLnAsIG5vZGVzLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIG9sZFN0ZXAoZnVuY3Rpb24oYWxsTm9kZXMsIGFsbExpbmtzLCBzdG9wcGVkKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFsbE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxsTm9kZXNbaV0uZml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsTm9kZXNbaV0uYXR0cihcInBvc2l0aW9uXCIsIGFsbE5vZGVzW2ldLnApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwcmVzZXJ2ZWRQb2ludHNbaV0gPSBhbGxOb2Rlc1tpXS5wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKGFsbExpbmtzLCBmdW5jdGlvbihjb25uZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmZpc2hUb3BvLmNvbm5lY3Rpb25NYW5hZ2VyLnJlZnJlc2hDb25uZWN0b3IoY29ubmVjdG9yLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAgICAgY2IgJiYgY2Ioc3RvcHBlZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5vcHRpb25zLmZvcmNlTGF5b3V0ID0gZm9yY2VJbnN0YW5jZTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMucHJlc2VydmVkUG9pbnRzID0gcHJlc2VydmVkUG9pbnRzO1xyXG4gICAgICAgIC8vIFN0ZXAgdG8gZ2V0IHRoZSBsYXlvdXRcclxuICAgICAgICBmb3JjZUluc3RhbmNlLnN0ZXAoKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgRm9yY2VMYXlvdXQucHJvdG90eXBlLl9zdGFydEZvcmNlTGF5b3V0SXRlcmF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgbGF5b3V0QW5pbWF0aW9uID0gdGhpcy5vcHRpb25zLmxheW91dEFuaW1hdGlvbjtcclxuICAgICAgICAoZnVuY3Rpb24gc3RlcCgpIHtcclxuICAgICAgICAgICAgc2VsZi5vcHRpb25zLmZvcmNlTGF5b3V0LnN0ZXAoZnVuY3Rpb24gKHN0b3BwZWQpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuX2xheW91dGluZyA9ICFzdG9wcGVkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX2xheW91dGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXlvdXRBbmltYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fbGF5b3V0VGltZW91dCA9IHNldFRpbWVvdXQoc3RlcCwgMTYpXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmlzaFRvcG8udHJpZ2dlcihcImZvcmNlTGF5b3V0RW5kXCIpOyAgLy/mtL7lj5HluIPlsYDnu5PmnZ/kuovku7ZcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KSgpO1xyXG4gICAgfTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gRm9yY2VMYXlvdXQ7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBhZGRDdXN0b21MYXlvdXRcclxuICogQGhpZGVcclxuICovXHJcblxyXG4vKipcclxuICogQGV2ZW50IGZvcmNlTGF5b3V0RW5kXHJcbiAqIOW4g+WxgOe7k+adn+S6i+S7tlxyXG4gKlxyXG4gKiA8cHJlPlxyXG4gKiBmaXNodG9wby5vbignZm9yY2VMYXlvdXRFbmQnLCBmdW5jdGlvbihlKSB7XHJcbiAqICAgLy9kbyBzb21ldGhpbmdcclxuICogfSlcclxuICogPC9wcmU+XHJcbiAqL1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGF5b3V0L0ZvcmNlTGF5b3V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcblxyXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvcicpO1xyXG4gICAgdmFyIHNjYWxlQW5kQWRkID0gdmVjMi5zY2FsZUFuZEFkZDtcclxuXHJcbiAgICAvLyBmdW5jdGlvbiBhZGphY2VudE5vZGUobiwgZSkge1xyXG4gICAgLy8gICAgIHJldHVybiBlLm4xID09PSBuID8gZS5uMiA6IGUubjE7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobm9kZXMsIGVkZ2VzLCBvcHRzKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSBvcHRzLnJlY3Q7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIGNlbnRlciA9IFtyZWN0LnggKyB3aWR0aCAvIDIsIHJlY3QueSArIGhlaWdodCAvIDJdO1xyXG4gICAgICAgIC8vIHZhciBzY2FsZSA9IG9wdHMuc2NhbGUgfHwgMTtcclxuICAgICAgICB2YXIgZ3Jhdml0eSA9IG9wdHMuZ3Jhdml0eSA9PSBudWxsID8gMC4xIDogb3B0cy5ncmF2aXR5O1xyXG5cclxuICAgICAgICAvLyBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgLy8gICAgIHZhciBlID0gZWRnZXNbaV07XHJcbiAgICAgICAgLy8gICAgIHZhciBuMSA9IGUubjE7XHJcbiAgICAgICAgLy8gICAgIHZhciBuMiA9IGUubjI7XHJcbiAgICAgICAgLy8gICAgIG4xLmVkZ2VzID0gbjEuZWRnZXMgfHwgW107XHJcbiAgICAgICAgLy8gICAgIG4yLmVkZ2VzID0gbjIuZWRnZXMgfHwgW107XHJcbiAgICAgICAgLy8gICAgIG4xLmVkZ2VzLnB1c2goZSk7XHJcbiAgICAgICAgLy8gICAgIG4yLmVkZ2VzLnB1c2goZSk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIEluaXQgcG9zaXRpb25cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgIGlmICghbi5wKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHBvc2l0aW9uIGZyb20gZmlyc3QgYWRqZWNlbnQgbm9kZSB3aXRoIGRlZmluZWQgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgIC8vIE9yIHVzZSBhIHJhbmRvbSBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgLy8gRnJvbSBkM1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgKG4uZWRnZXMpIHtcclxuICAgICAgICAgICAgICAgIC8vICAgICB2YXIgaiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIHdoaWxlICgrK2ogPCBuLmVkZ2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICB2YXIgZSA9IG4uZWRnZXNbal07XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHZhciBvdGhlciA9IGFkamFjZW50Tm9kZShuLCBlKTtcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgaWYgKG90aGVyLnApIHtcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIG4ucCA9IHZlYzIuY2xvbmUob3RoZXIucCk7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgIC8vIGlmICghbi5wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbi5wID0gdmVjMi5jcmVhdGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoICogKE1hdGgucmFuZG9tKCkgLSAwLjUpICsgY2VudGVyWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKyBjZW50ZXJbMV1cclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4ucHAgPSB2ZWMyLmNsb25lKG4ucCk7XHJcbiAgICAgICAgICAgIG4uZWRnZXMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRm9ybXVsYSBpbiAnR3JhcGggRHJhd2luZyBieSBGb3JjZS1kaXJlY3RlZCBQbGFjZW1lbnQnXHJcbiAgICAgICAgLy8gdmFyIGsgPSBzY2FsZSAqIE1hdGguc3FydCh3aWR0aCAqIGhlaWdodCAvIG5vZGVzLmxlbmd0aCk7XHJcbiAgICAgICAgLy8gdmFyIGsyID0gayAqIGs7XHJcblxyXG4gICAgICAgIHZhciBmcmljdGlvbiA9IDAuNjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgd2FybVVwOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBmcmljdGlvbiA9IDAuNTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHNldEZpeGVkOiBmdW5jdGlvbiAoaWR4KSB7XHJcbiAgICAgICAgICAgICAgICBub2Rlc1tpZHhdLmZpeGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHNldFVuZml4ZWQ6IGZ1bmN0aW9uIChpZHgpIHtcclxuICAgICAgICAgICAgICAgIG5vZGVzW2lkeF0uZml4ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHN0ZXA6IGZ1bmN0aW9uIChjYikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHYxMiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5MZW4gPSBub2Rlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBlZGdlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbjEgPSBlLm4xO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuMiA9IGUubjI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZlYzIuc3ViKHYxMiwgbjIucCwgbjEucCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSB2ZWMyLmxlbih2MTIpIC0gZS5kO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3ID0gbjIudyAvIChuMS53ICsgbjIudyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUodjEyLCB2MTIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAhbjEuZml4ZWQgJiYgc2NhbGVBbmRBZGQobjEucCwgbjEucCwgdjEyLCB3ICogZCAqIGZyaWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAhbjIuZml4ZWQgJiYgc2NhbGVBbmRBZGQobjIucCwgbjIucCwgdjEyLCAtKDEgLSB3KSAqIGQgKiBmcmljdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBHcmF2aXR5XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5MZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuLmZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuc3ViKHYxMiwgY2VudGVyLCBuLnApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2YXIgZCA9IHZlYzIubGVuKHYxMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZlYzIuc2NhbGUodjEyLCB2MTIsIDEgLyBkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyIGdyYXZpdHlGYWN0b3IgPSBncmF2aXR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLnNjYWxlQW5kQWRkKG4ucCwgbi5wLCB2MTIsIGdyYXZpdHkgKiBmcmljdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlcHVsc2l2ZVxyXG4gICAgICAgICAgICAgICAgLy8gUEVORElOR1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuTGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbjEgPSBub2Rlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBuTGVuOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4yID0gbm9kZXNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuc3ViKHYxMiwgbjIucCwgbjEucCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gdmVjMi5sZW4odjEyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJhbmRvbSByZXB1bHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLnNldCh2MTIsIE1hdGgucmFuZG9tKCkgLSAwLjUsIE1hdGgucmFuZG9tKCkgLSAwLjUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcEZhY3QgPSAobjEucmVwICsgbjIucmVwKSAvIGQgLyBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAhbjEuZml4ZWQgJiYgc2NhbGVBbmRBZGQobjEucHAsIG4xLnBwLCB2MTIsIHJlcEZhY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAhbjIuZml4ZWQgJiYgc2NhbGVBbmRBZGQobjIucHAsIG4yLnBwLCB2MTIsIC1yZXBGYWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuTGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbi5maXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLnN1Yih2LCBuLnAsIG4ucHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLnNjYWxlQW5kQWRkKG4ucCwgbi5wLCB2LCBmcmljdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY29weShuLnBwLCBuLnApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmcmljdGlvbiA9IGZyaWN0aW9uICogMC45OTI7XHJcblxyXG4gICAgICAgICAgICAgICAgY2IgJiYgY2Iobm9kZXMsIGVkZ2VzLCBmcmljdGlvbiA8IDAuMDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9sYXlvdXQvZm9yY2VIZWxwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog5bel5YW357G7XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cudXRpbFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGluaXRJbWFnZVBvb2xcclxuICog5Yid5aeL5YyW5Zu+54mH5rGgICDnlKjkuo7lr7nlm77niYfliqDovb3ov5vooYznrqHnkIZcclxuICogQHBhcmFtIHtudW1iZXJ9IG1heCDmnIDlpKfov57mjqXmlbDjgILmlbDlgLzjgIJcclxuICogQHJldHVybnMge3tsb2FkOiBGdW5jdGlvbiwgaW5mbzogRnVuY3Rpb259fVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICAgICAgICB2YXIgaW1hZ2Vwb29sID0gZmlzaFRvcG9GbG93LnV0aWwuaW5pdEltYWdlUG9vbCgxMDApO1xyXG4gICAgICAgIGltYWdlcG9vbC5sb2FkKGdyYXlBcnJheSwge1xyXG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihpbWdzKSB7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uY2U6IHRydWVcclxuICAgICAgICB9KTtcclxuICovXHJcblxyXG4vKipcclxuICogQG1ldGhvZCBpbmhlcml0c1xyXG4gKiDmnoTpgKDnsbvnu6fmib/lhbPns7tcclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xhenog5rqQ57G7XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VDbGF6eiDln7rnsbtcclxuICovXHJcblxyXG5cclxuICAgIHZhciBlbXB0eUZuID0gZnVuY3Rpb24oKSB7fTtcclxuICAgIC8v5Yid5aeL6buY6K6k6YWN572uXHJcbiAgICB2YXIgY29uZmlnX2RlZmF1bHQgPSB7XHJcbiAgICAgICAgLy/nur/nqIvmsaBcIue6v+eoi1wi5pWw6YePXHJcbiAgICAgICAgdGhyZWFkOiA1LFxyXG4gICAgICAgIC8v5Zu+54mH5Yqg6L295aSx6LSl6YeN6K+V5qyh5pWwXHJcbiAgICAgICAgLy/ph43or5Uy5qyh77yM5Yqg5LiK5Y6f5pyJ55qE5LiA5qyh77yM5oC75YWx5pivM+asoVxyXG4gICAgICAgIFwidHJpZXNcIjogMlxyXG4gICAgfTtcclxuICAgIC8v5bel5YW3XHJcbiAgICB2YXIgX2hlbHBlcnMgPSB7XHJcbiAgICAgICAgLy/orr7nva5kb23lsZ7mgKdcclxuICAgICAgICBzZXRBdHRyOiAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgLy/liKTmlq3mtY/op4jlmajmmK/lkKbmlK/mjIFIVE1MNSBkYXRhc2V0XHJcbiAgICAgICAgICAgIGlmIChpbWcuZGF0YXNldCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRvbSwgbmFtZSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb20uZGF0YXNldFtuYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZG9tLCBuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoXCJkYXRhLVwiICsgbmFtZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCkpLFxyXG4gICAgICAgIC8v6I635Y+WZG9t5bGe5oCnXHJcbiAgICAgICAgZ2V0QXR0cjogKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgICAgIC8v5Yik5pat5rWP6KeI5Zmo5piv5ZCm5pSv5oyBSFRNTDUgZGF0YXNldFxyXG4gICAgICAgICAgICBpZiAoaW1nLmRhdGFzZXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihkb20sIG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZighZG9tLmRhdGFzZXRbbmFtZV0pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9tLmdldEF0dHJpYnV0ZShcImRhdGEtXCIgKyBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvbS5kYXRhc2V0W25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZG9tLCBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvbS5nZXRBdHRyaWJ1dGUoXCJkYXRhLVwiICsgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpKVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5p6E6YCg5pa55rOVXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIG1heCDmnIDlpKfov57mjqXmlbDjgILmlbDlgLzjgIJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gSW1hZ2VQb29sKG1heCkge1xyXG4gICAgICAgIC8v5pyA5aSn5bm25Y+R5pWw6YePXHJcbiAgICAgICAgdGhpcy5tYXggPSBtYXggfHwgY29uZmlnX2RlZmF1bHQudGhyZWFkO1xyXG4gICAgICAgIHRoaXMubGlua0hlYWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGlua05vZGUgPSBudWxsO1xyXG4gICAgICAgIC8v5Yqg6L295rGgXHJcbiAgICAgICAgLy9be2ltZzogZG9tLGZyZWU6IHRydWUsIG5vZGU6IG5vZGV9XVxyXG4gICAgICAgIC8vbm9kZVxyXG4gICAgICAgIC8ve3NyYzogXCJcIiwgb3B0aW9uczoge3N1Y2Nlc3M6IFwiZm5cIixlcnJvcjogXCJmblwiLCBvbmNlOiB0cnVlfSwgdHJpZXM6IDB9XHJcbiAgICAgICAgdGhpcy5wb29sID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOWIneWni+WMllxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgSW1hZ2VQb29sLnByb3RvdHlwZS5pbml0UG9vbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBpLCBpbWcsIG9iaiwgX3M7XHJcbiAgICAgICAgX3MgPSB0aGlzO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLm1heDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG9iaiA9IHt9O1xyXG4gICAgICAgICAgICBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgX2hlbHBlcnMuc2V0QXR0cihpbWcsIFwiaWRcIiwgaSk7XHJcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIC8v5Zue6LCDXHJcbiAgICAgICAgICAgICAgICBfcy5ub3RpY2UoX3MuZ2V0Tm9kZSh0aGlzKSwgXCJzdWNjZXNzXCIsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgLy/lpITnkIbku7vliqFcclxuICAgICAgICAgICAgICAgIF9zLmV4ZWN1dGVMaW5rKHRoaXMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBfcy5nZXROb2RlKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgLy/liKTmlq3lsJ3or5XmrKHmlbBcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLnRyaWVzIDwgY29uZmlnX2RlZmF1bHQudHJpZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnRyaWVzID0gbm9kZS50cmllcysxO1xyXG4gICAgICAgICAgICAgICAgICAgIC8v5YaN5qyh6L+95Yqg5Yiw5Lu75Yqh6ZO+6KGo5pyr5bC+XHJcbiAgICAgICAgICAgICAgICAgICAgX3MuYXBwZW5kTm9kZShfcy5jcmVhdGVOb2RlKG5vZGUuc3JjLCBub2RlLm9wdGlvbnMsIG5vZGUubm90aWNlLCBub2RlLmdyb3VwLCBub2RlLnRyaWVzKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZXJyb3Llm57osINcclxuICAgICAgICAgICAgICAgICAgICAvL25vZGUub3B0aW9ucy5lcnJvci5jYWxsKG51bGwsIHRoaXMuc3JjKTtcclxuICAgICAgICAgICAgICAgICAgICBfcy5ub3RpY2Uobm9kZSwgXCJlcnJvclwiLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8v5aSE55CG5Lu75YqhXHJcbiAgICAgICAgICAgICAgICBfcy5leGVjdXRlTGluayh0aGlzKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgb2JqLmltZyA9IGltZztcclxuICAgICAgICAgICAgb2JqLmZyZWUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnBvb2wucHVzaChvYmopO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWbnuiwg+WwgeijhVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSBub2RlIOiKgueCueOAguWvueixoeOAglxyXG4gICAgICogQHBhcmFtIHN0YXR1cyDnirbmgIHjgILlrZfnrKbkuLLjgILlj6/pgInlgLzvvJpzdWNjZXNzKOaIkOWKnyl8ZXJyb3Io5aSx6LSlKVxyXG4gICAgICogQHBhcmFtIGltZyDlm77niYfjgIJcclxuICAgICAqL1xyXG4gICAgSW1hZ2VQb29sLnByb3RvdHlwZS5ub3RpY2UgPSBmdW5jdGlvbihub2RlLCBzdGF0dXMsIGltZykge1xyXG4gICAgICAgIG5vZGUubm90aWNlKHN0YXR1cywgaW1nKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWkhOeQhumTvuihqOS7u+WKoVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSBkb20g5Zu+5YOPZG9t5a+56LGh44CC5a+56LGh44CCXHJcbiAgICAgKi9cclxuICAgIEltYWdlUG9vbC5wcm90b3R5cGUuZXhlY3V0ZUxpbmsgPSBmdW5jdGlvbihkb20pIHtcclxuICAgICAgICAvL+WIpOaWremTvuihqOaYr+WQpuWtmOWcqOiKgueCuVxyXG4gICAgICAgIGlmICh0aGlzLmxpbmtIZWFkKSB7XHJcbiAgICAgICAgICAgIC8v5Yqg6L295LiL5LiA5Liq5Zu+54mHXHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3JjKGRvbSwgdGhpcy5saW5rSGVhZCk7XHJcbiAgICAgICAgICAgIC8v5Y676Zmk6ZO+6KGo5aS0XHJcbiAgICAgICAgICAgIHRoaXMuc2hpZnROb2RlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy/orr7nva7oh6rouqvnirbmgIHkuLrnqbrpl7JcclxuICAgICAgICAgICAgdGhpcy5zdGF0dXMoZG9tLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bnqbrpl7JcIue6v+eoi1wiXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBJbWFnZVBvb2wucHJvdG90eXBlLmdldEZyZWUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgbGVuZ3RoLCBpO1xyXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHRoaXMucG9vbC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wb29sW2ldLmZyZWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBvb2xbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDlsIHoo4VzcmPlsZ7mgKforr7nva5cclxuICAgICAqIOWboOS4uuaUueWPmHNyY+WxnuaAp+ebuOW9k+S6juWKoOi9veWbvueJh++8jOaJgOS7peaKiuaTjeS9nOWwgeijhei1t+adpVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSBkb20g5Zu+5YOPZG9t5a+56LGh44CC5a+56LGh44CCXHJcbiAgICAgKiBAcGFyYW0gbm9kZSDoioLngrnjgILlr7nosaHjgIJcclxuICAgICAqL1xyXG4gICAgSW1hZ2VQb29sLnByb3RvdHlwZS5zZXRTcmMgPSBmdW5jdGlvbihkb20sIG5vZGUpIHtcclxuICAgICAgICAvL+iuvue9ruaxoOS4reeahFwi57q/56iLXCLkuLrpnZ7nqbrpl7LnirbmgIFcclxuICAgICAgICB0aGlzLnN0YXR1cyhkb20sIGZhbHNlKTtcclxuICAgICAgICAvL+WFs+iBlOiKgueCuVxyXG4gICAgICAgIHRoaXMuc2V0Tm9kZShkb20sIG5vZGUpO1xyXG4gICAgICAgIC8v5Yqg6L295Zu+54mHXHJcbiAgICAgICAgZG9tLnNyYyA9IG5vZGUuc3JjO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5pu05paw5rGg5Lit55qEXCLnur/nqItcIueKtuaAgVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSBkb20g5Zu+5YOPZG9t5a+56LGh44CC5a+56LGh44CCXHJcbiAgICAgKiBAcGFyYW0gc3RhdHVzIOeKtuaAgeOAguW4g+WwlOOAguWPr+mAieWAvO+8mnRydWUo56m66ZeyKXxmYWxzZSjpnZ7nqbrpl7IpXHJcbiAgICAgKi9cclxuICAgIEltYWdlUG9vbC5wcm90b3R5cGUuc3RhdHVzID0gZnVuY3Rpb24oZG9tLCBzdGF0dXMpIHtcclxuICAgICAgICB2YXIgaWQgPSBfaGVscGVycy5nZXRBdHRyKGRvbSwgXCJpZFwiKTtcclxuICAgICAgICBpZihpZCl7XHJcbiAgICAgICAgICAgIHRoaXMucG9vbFtpZF0uZnJlZSA9IHN0YXR1cztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8v56m66Zey54q25oCB77yM5riF6Zmk5YWz6IGU55qE6IqC54K5XHJcbiAgICAgICAgaWYgKHN0YXR1cykge1xyXG4gICAgICAgICAgICB0aGlzLnBvb2xbaWRdLm5vZGUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOabtOaWsOaxoOS4reeahFwi57q/56iLXCLnmoTlhbPogZToioLngrlcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gZG9tIOWbvuWDj2RvbeWvueixoeOAguWvueixoeOAglxyXG4gICAgICogQHBhcmFtIG5vZGUg6IqC54K544CC5a+56LGh44CCXHJcbiAgICAgKi9cclxuICAgIEltYWdlUG9vbC5wcm90b3R5cGUuc2V0Tm9kZSA9IGZ1bmN0aW9uKGRvbSwgbm9kZSkge1xyXG4gICAgICAgIHZhciBpZCA9IF9oZWxwZXJzLmdldEF0dHIoZG9tLCBcImlkXCIpO1xyXG4gICAgICAgIGlmKGlkKXtcclxuICAgICAgICAgICAgdGhpcy5wb29sW2lkXS5ub2RlID0gbm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9vbFtpZF0ubm9kZSA9PT0gbm9kZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W5rGg5Lit55qEXCLnur/nqItcIueahOWFs+iBlOiKgueCuVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSBkb20g5Zu+5YOPZG9t5a+56LGh44CC5a+56LGh44CCXHJcbiAgICAgKi9cclxuICAgIEltYWdlUG9vbC5wcm90b3R5cGUuZ2V0Tm9kZSA9IGZ1bmN0aW9uKGRvbSkge1xyXG4gICAgICAgIHZhciBpZCA9IF9oZWxwZXJzLmdldEF0dHIoZG9tLCBcImlkXCIpO1xyXG4gICAgICAgIGlmKGlkKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9vbFtpZF0ubm9kZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5a+55aSW5o6l5Y+j77yM5Yqg6L295Zu+54mHXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHNyYyDlj6/ku6XmmK9zcmPlrZfnrKbkuLLvvIzkuZ/lj6/ku6XmmK9zcmPlrZfnrKbkuLLmlbDnu4TjgIJcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIOeUqOaIt+iHquWumuS5ieWPguaVsOOAguWMheWQq++8mnN1Y2Nlc3Plm57osIPjgIFlcnJvcuWbnuiwg+OAgW9uY2XmoIfor4bjgIJcclxuICAgICAqL1xyXG4gICAgSW1hZ2VQb29sLnByb3RvdHlwZS5fbG9hZCA9IGZ1bmN0aW9uKHNyYywgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBzcmNzID0gW10sXHJcbiAgICAgICAgICAgIGZyZWUgPSBudWxsLFxyXG4gICAgICAgICAgICBsZW5ndGggPSAwLFxyXG4gICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgLy/lj6rliJ3lp4vljJbkuIDmrKHlm57osIPnrZbnlaVcclxuICAgICAgICAgICAgbm90aWNlID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzdGF0dXMsIGltZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IHRoaXMuZ3JvdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gdGhpcy5vcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+iusOW9lVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnW3N0YXR1c10ucHVzaChpbWcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+WIpOaWreaUuee7hOaYr+WQpuWFqOmDqOWkhOeQhuWujOaIkFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZy5zdWNjZXNzLmxlbmd0aCArIGcuZXJyb3IubGVuZ3RoID09PSBnLmNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL+W8guatpVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy/lrp7pmYXkuIrmmK/kvZzkuLrlj6bkuIDkuKrku7vliqHljZXni6zmiafooYzvvIzpmLLmraLlm57osIPlh73mlbDmiafooYzml7bpl7Tov4fplb/lvbHlk43lm77niYfliqDovb3pgJ/luqZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby5zdWNjZXNzLmNhbGwobnVsbCwgZy5zdWNjZXNzLCBnLmVycm9yLCBnLmNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXR1cywgaW1nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gdGhpcy5vcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+ebtOaOpeWbnuiwg1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb1tzdGF0dXNdLmNhbGwobnVsbCwgaW1nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSgpKSxcclxuICAgICAgICAgICAgZ3JvdXAgPSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudDogMCxcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IFtdLFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IFtdXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG5vZGUgPSBudWxsO1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcyB8fCBlbXB0eUZuO1xyXG4gICAgICAgIG9wdGlvbnMuZXJyb3IgPSBvcHRpb25zLmVycm9yIHx8IGVtcHR5Rm47XHJcbiAgICAgICAgc3JjcyA9IHNyY3MuY29uY2F0KHNyYyk7XHJcbiAgICAgICAgLy/orr7nva7nu4TlhYPntKDkuKrmlbBcclxuICAgICAgICBncm91cC5jb3VudCA9IHNyY3MubGVuZ3RoO1xyXG4gICAgICAgIC8v6YGN5Y6G6ZyA6KaB5Yqg6L2955qE5Zu+54mHXHJcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc3Jjcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvL+WIm+W7uuiKgueCuVxyXG4gICAgICAgICAgICBub2RlID0gdGhpcy5jcmVhdGVOb2RlKHNyY3NbaV0sIG9wdGlvbnMsIG5vdGljZSwgZ3JvdXApO1xyXG4gICAgICAgICAgICAvL+WIpOaWree6v+eoi+axoOaYr+WQpuacieepuumXslxyXG4gICAgICAgICAgICBmcmVlID0gdGhpcy5nZXRGcmVlKCk7XHJcbiAgICAgICAgICAgIGlmIChmcmVlKSB7XHJcbiAgICAgICAgICAgICAgICAvL+acieepuumXsu+8jOWImeeri+WNs+WKoOi9veWbvueJh1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTcmMoZnJlZS5pbWcsIG5vZGUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy/msqHmnInnqbrpl7LvvIzlsIbku7vliqHmt7vliqDliLDpk77ooahcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kTm9kZShub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluWGhemDqOeKtuaAgeS/oeaBr1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIEltYWdlUG9vbC5wcm90b3R5cGUuX2luZm8gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgaW5mbyA9IHt9LFxyXG4gICAgICAgICAgICBsZW5ndGggPSAwLFxyXG4gICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgbm9kZSA9IG51bGw7XHJcbiAgICAgICAgLy/nur/nqItcclxuICAgICAgICBpbmZvLnRocmVhZCA9IHt9O1xyXG4gICAgICAgIC8v57q/56iL5oC75pWw6YePXHJcbiAgICAgICAgaW5mby50aHJlYWQuY291bnQgPSB0aGlzLnBvb2wubGVuZ3RoO1xyXG4gICAgICAgIC8v56m66Zey57q/56iL5pWw6YePXHJcbiAgICAgICAgaW5mby50aHJlYWQuZnJlZSA9IDA7XHJcbiAgICAgICAgLy/ku7vliqFcclxuICAgICAgICBpbmZvLnRhc2sgPSB7fTtcclxuICAgICAgICAvL+W+heWkhOeQhuS7u+WKoeaVsOmHj1xyXG4gICAgICAgIGluZm8udGFzay5jb3VudCA9IDA7XHJcbiAgICAgICAgLy/ojrflj5bnqbrpl7JcIue6v+eoi1wi5pWw6YePXHJcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gdGhpcy5wb29sLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvb2xbaV0uZnJlZSkge1xyXG4gICAgICAgICAgICAgICAgaW5mby50aHJlYWQuZnJlZSA9IGluZm8udGhyZWFkLmZyZWUgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v6I635Y+W5Lu75Yqh5pWw6YePKOS7u+WKoemTvumVv+W6pilcclxuICAgICAgICBub2RlID0gdGhpcy5saW5rSGVhZDtcclxuICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICBpbmZvLnRhc2suY291bnQgPSBpbmZvLnRhc2suY291bnQgKyAxO1xyXG4gICAgICAgICAgICB3aGlsZSAobm9kZS5uZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBpbmZvLnRhc2suY291bnQgPSBpbmZvLnRhc2suY291bnQgKyAxO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW5mbztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7roioLngrlcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gc3JjIOWbvueJh+i3r+W+hOOAguWtl+espuS4suOAglxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMg55So5oi36Ieq5a6a5LmJ5Y+C5pWw44CC5YyF5ZCr77yac3VjY2Vzc+Wbnuiwg+OAgWVycm9y5Zue6LCD44CBb25jZeagh+ivhuOAglxyXG4gICAgICogQHBhcmFtIG5vdGljZSDlm57osIPnrZbnlaXjgIIg5Ye95pWw44CCXHJcbiAgICAgKiBAcGFyYW0gZ3JvdXAg57uE5L+h5oGv44CC5a+56LGh44CCe2NvdW50OiAwLCBzdWNjZXNzOiBbXSwgZXJyb3I6IFtdfVxyXG4gICAgICogQHBhcmFtIHRyIOWHuumUmemHjeivleasoeaVsOOAguaVsOWAvOOAgum7mOiupOS4ujDjgIJcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIEltYWdlUG9vbC5wcm90b3R5cGUuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uKHNyYywgb3B0aW9ucywgbm90aWNlLCBncm91cCwgdHIpIHtcclxuICAgICAgICB2YXIgbm9kZSA9IHt9O1xyXG4gICAgICAgIG5vZGUuc3JjID0gc3JjO1xyXG4gICAgICAgIG5vZGUub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgbm9kZS5ub3RpY2UgPSBub3RpY2U7XHJcbiAgICAgICAgbm9kZS5ncm91cCA9IGdyb3VwO1xyXG4gICAgICAgIG5vZGUudHJpZXMgPSB0ciB8fCAwO1xyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5ZCR5Lu75Yqh6ZO+6KGo5pyr5bC+6L+95Yqg6IqC54K5XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIG5vZGUg6IqC54K544CC5a+56LGh44CCXHJcbiAgICAgKi9cclxuICAgIEltYWdlUG9vbC5wcm90b3R5cGUuYXBwZW5kTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAvL+WIpOaWremTvuihqOaYr+WQpuS4uuepulxyXG4gICAgICAgIGlmICghdGhpcy5saW5rSGVhZCkge1xyXG4gICAgICAgICAgICB0aGlzLmxpbmtIZWFkID0gbm9kZTtcclxuICAgICAgICAgICAgdGhpcy5saW5rTm9kZSA9IG5vZGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5saW5rTm9kZS5uZXh0ID0gbm9kZTtcclxuICAgICAgICAgICAgdGhpcy5saW5rTm9kZSA9IG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Yig6Zmk6ZO+6KGo5aS0XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBJbWFnZVBvb2wucHJvdG90eXBlLnNoaWZ0Tm9kZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8v5Yik5pat6ZO+6KGo5piv5ZCm5a2Y5Zyo6IqC54K5XHJcbiAgICAgICAgaWYgKHRoaXMubGlua0hlYWQpIHtcclxuICAgICAgICAgICAgLy/kv67mlLnpk77ooajlpLRcclxuICAgICAgICAgICAgdGhpcy5saW5rSGVhZCA9IHRoaXMubGlua0hlYWQubmV4dCB8fCBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWIneWni+WMluWbvueJh+axoFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCDmnIDlpKfov57mjqXmlbDjgILmlbDlgLzjgIJcclxuICAgICAqIEByZXR1cm5zIHt7bG9hZDogRnVuY3Rpb24sIGluZm86IEZ1bmN0aW9ufX1cclxuICAgICAqL1xyXG4gICAgdmFyIGluaXRJbWFnZVBvb2wgPSBmdW5jdGlvbihtYXgpIHtcclxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgSW1hZ2VQb29sKG1heCk7XHJcbiAgICAgICAgaW5zdGFuY2UuaW5pdFBvb2woKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICog5Yqg6L295Zu+54mHXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBzcmMg5Y+v5Lul5pivc3Jj5a2X56ym5Liy77yM5Lmf5Y+v5Lul5pivc3Jj5a2X56ym5Liy5pWw57uE44CCXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIOeUqOaIt+iHquWumuS5ieWPguaVsOOAguWMheWQq++8mnN1Y2Nlc3Plm57osIPjgIFlcnJvcuWbnuiwg+OAgW9uY2XmoIfor4bjgIJcclxuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuc3VjY2Vzc10gc3VjY2Vzc+Wbnuiwg1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5lcnJvcl0gZXJyb3Llm57osINcclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5vbmNlXSDmmK/lkKblhajpg6jliqDovb3lrozmr5XlkI7vvIzkuIDmrKHlm57osINcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGxvYWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuX2xvYWQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiDojrflj5blhoXpg6jnirbmgIHkv6Hmga9cclxuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGluZm86IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlLl9pbmZvLmNhbGwoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7IGluaXRJbWFnZVBvb2w6IGluaXRJbWFnZVBvb2wgfVxyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL0ltYWdlUG9vbC5qc1xuLy8gbW9kdWxlIGlkID0gMTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG4gICAgdmFyIFRvb2x0aXBDb250ZW50ID0gcmVxdWlyZSgnLi9Ub29sdGlwQ29udGVudCcpO1xyXG4gICAgdmFyIGdsb2JhbExpc3RlbmVyID0gcmVxdWlyZSgnLi9nbG9iYWxMaXN0ZW5lcicpO1xyXG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL21vZGVsJyk7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9lbnYnKTtcclxuICAgIHZhciBmbG93VXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvRmxvd1V0aWwnKTtcclxuICAgIHZhciBsYXlvdXQgPSByZXF1aXJlKFwiLi4vbGF5b3V0L2xheW91dFwiKTtcclxuICAgIGZ1bmN0aW9uIFRvb2x0aXBWaWV3KHRvb2x0aXBNb2RlbCwgYXBpKSB7XHJcbiAgICAgICAgdGhpcy5fdG9vbHRpcENvbnRlbnQgPSBuZXcgVG9vbHRpcENvbnRlbnQoYXBpLmdldERvbSgpLGFwaSk7XHJcbiAgICAgICAgdGhpcy5fYXBpID0gYXBpO1xyXG4gICAgICAgIHRoaXMuX3Rvb2x0aXBNb2RlbCA9IHRvb2x0aXBNb2RlbDtcclxuICAgICAgICB0aGlzLl9hbHdheXNTaG93Q29udGVudCA9IHRvb2x0aXBNb2RlbC5nZXQoJ2Fsd2F5c1Nob3dDb250ZW50Jyk7XHJcbiAgICAgICAgdGhpcy5faW5pdEdsb2FibExpc3RlbmVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgVG9vbHRpcFZpZXcucHJvdG90eXBlLl9pbml0R2xvYWJsTGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdHJpZ2dlck9uID0gdGhpcy5fdG9vbHRpcE1vZGVsLmdldCgndHJpZ2dlck9uJyk7XHJcbiAgICAgICAgLy8g5b2T5pyJICdjbGljaycgfCAnbW91c2Vtb3ZlJyB8ICdub25lJyDkuovku7bml7bop6blj5Hlm57osINcclxuICAgICAgICBnbG9iYWxMaXN0ZW5lci5yZWdpc3RlcihcclxuICAgICAgICAgICAgJ2l0ZW1Ub29sdGlwJyxcclxuICAgICAgICAgICAgdGhpcy5fYXBpLFxyXG4gICAgICAgICAgICBmdW5jdGlvbihjdXJyVHJpZ2dlciwgZSwgZGlzcGF0Y2hBY3Rpb24pe1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyaWdnZXJPbiAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyaWdnZXJPbi5pbmRleE9mKGN1cnJUcmlnZ2VyKSA+PSAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90cnlTaG93KGUsIGRpc3BhdGNoQWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VyclRyaWdnZXIgPT09ICdsZWF2ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlkZShkaXNwYXRjaEFjdGlvbilcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgICAgIClcclxuICAgIH07XHJcblxyXG4gICAgVG9vbHRpcFZpZXcucHJvdG90eXBlLl90cnlTaG93ID0gZnVuY3Rpb24oZSwgZGlzcGF0Y2hBY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIGVsID0gZS50YXJnZXQ7XHJcbiAgICAgICAgICAgIHZhciB0b29sdGlwTW9kZWwgPSB0aGlzLl90b29sdGlwTW9kZWw7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRvb2x0aXBNb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTYXZlIG1vdXNlIHgsIG1vdXNlIHkuIFNvIHdlIGNhbiB0cnkgdG8ga2VlcCBzaG93aW5nIHRoZSB0aXAgaWYgY2hhcnQgaXMgcmVmcmVzaGVkXHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RYID0gZS5vZmZzZXRYO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0WSA9IGUub2Zmc2V0WTtcclxuXHJcbiAgICAgICAgICAgIGlmIChlbCAmJiBlbC50b29sdGlwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG93Q29tcG9uZW50SXRlbVRvb2x0aXAoZSwgZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGlkZShkaXNwYXRjaEFjdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgIFRvb2x0aXBWaWV3LnByb3RvdHlwZS5faGlkZSA9IGZ1bmN0aW9uKGRpc3BhdGNoQWN0aW9uKSB7XHJcbiAgICAgICAgICAgIC8vIERvIG5vdCBkaXJlY3RseSBoaWRlTGF0ZXIgaGVyZSwgYmVjYXVzZSB0aGlzIGJlaGF2aW9yIG1heSBiZSBwcmV2ZW50ZWRcclxuICAgICAgICAgICAgLy8gaW4gZGlzcGF0Y2hBY3Rpb24gd2hlbiBzaG93VGlwIGlzIGRpc3BhdGNoZWQuXHJcblxyXG4gICAgICAgICAgICAvLyBGSVhNRVxyXG4gICAgICAgICAgICAvLyBkdXBsaWNhdGVkIGhpZGVUaXAgaWYgbWFudWFsbHlIaWRlVGlwIGlzIGNhbGxlZCBmcm9tIGRpc3BhdGNoQWN0aW9uLlxyXG4gICAgICAgICAgICB0aGlzLl9sYXN0RGF0YUJ5Q29vcmRTeXMgPSBudWxsO1xyXG4gICAgICAgICAgICBkaXNwYXRjaEFjdGlvbih7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGlkZVRpcCcsXHJcbiAgICAgICAgICAgICAgICBmcm9tOiB0aGlzLnVpZFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5tYW51YWxseUhpZGVUaXAoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgIFRvb2x0aXBWaWV3LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoZW52Lm5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwQ29udGVudC5oaWRlKCk7XHJcbiAgICAgICAgICAgIGdsb2JhbExpc3RlbmVyLnVucmVnaXN0ZXIoJ2l0ZW1Ub29sdGlwJywgdGhpcy5fYXBpKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBUb29sdGlwVmlldy5wcm90b3R5cGUubWFudWFsbHlIaWRlVGlwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdG9vbHRpcENvbnRlbnQgPSB0aGlzLl90b29sdGlwQ29udGVudDtcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fYWx3YXlzU2hvd0NvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHRvb2x0aXBDb250ZW50LmhpZGVMYXRlcih0aGlzLl90b29sdGlwTW9kZWwuZ2V0KCdoaWRlRGVsYXknKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RYID0gdGhpcy5fbGFzdFkgPSBudWxsO1xyXG5cclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICBUb29sdGlwVmlldy5wcm90b3R5cGUuX3Nob3dDb21wb25lbnRJdGVtVG9vbHRpcCA9IGZ1bmN0aW9uIChlLCBlbCkge1xyXG4gICAgICAgICAgICB2YXIgdG9vbHRpcE9wdCA9IGVsLnRvb2x0aXA7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9vbHRpcE9wdCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gdG9vbHRpcE9wdDtcclxuICAgICAgICAgICAgICAgIHRvb2x0aXBPcHQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogY29udGVudCxcclxuICAgICAgICAgICAgICAgICAgICAvLyBGaXhlZCBmb3JtYXR0ZXJcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGNvbnRlbnRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHN1YlRvb2x0aXBNb2RlbCA9IG5ldyBNb2RlbCh0b29sdGlwT3B0LCB0aGlzLl90b29sdGlwTW9kZWwpO1xyXG4gICAgICAgICAgICB2YXIgZGVmYXVsdEh0bWwgPSBzdWJUb29sdGlwTW9kZWwuZ2V0KCdjb250ZW50Jyk7XHJcbiAgICAgICAgICAgIHZhciBhc3luY1RpY2tldCA9IE1hdGgucmFuZG9tKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBEbyBub3QgY2hlY2sgd2hldGhlciBgdHJpZ2dlcmAgaXMgJ25vbmUnIGhlcmUsIGJlY2F1c2UgYHRyaWdnZXJgXHJcbiAgICAgICAgICAgIC8vIG9ubHkgd29ya3Mgb24gY29vcmlkaW5hdGUgc3lzdGVtLiBJbiBmYWN0LCB3ZSBoYXZlIG5vdCBmb3VuZCBjYXNlXHJcbiAgICAgICAgICAgIC8vIHRoYXQgcmVxdWlyZXMgc2V0dGluZyBgdHJpZ2dlcmAgbm90aGluZyBvbiBjb21wb25lbnQgeWV0LlxyXG5cclxuICAgICAgICAgICAgdGhpcy5fc2hvd09yTW92ZShzdWJUb29sdGlwTW9kZWwsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dUb29sdGlwQ29udGVudChcclxuICAgICAgICAgICAgICAgICAgICBzdWJUb29sdGlwTW9kZWwsIGRlZmF1bHRIdG1sLCBzdWJUb29sdGlwTW9kZWwuZ2V0KCdmb3JtYXR0ZXJQYXJhbXMnKSB8fCB7fSxcclxuICAgICAgICAgICAgICAgICAgICBhc3luY1RpY2tldCwgZS5vZmZzZXRYLCBlLm9mZnNldFksIGUucG9zaXRpb24sIGVsXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICBUb29sdGlwVmlldy5wcm90b3R5cGUuX3Nob3dPck1vdmUgPSBmdW5jdGlvbiAodG9vbHRpcE1vZGVsLCBjYikge1xyXG4gICAgICAgICAgICAvLyBzaG93RGVsYXkgaXMgdXNlZCBpbiB0aGlzIGNhc2U6IHRvb2x0aXAuZW50ZXJhYmxlIGlzIHNldFxyXG4gICAgICAgICAgICAvLyBhcyB0cnVlLiBVc2VyIGludGVudCB0byBtb3ZlIG1vdXNlIGludG8gdG9vbHRpcCBhbmQgY2xpY2tcclxuICAgICAgICAgICAgLy8gc29tZXRoaW5nLiBgc2hvd0RlbGF5YCBtYWtlcyBpdCBlYXN5ZXIgdG8gZW50ZXIgdGhlIGNvbnRlbnRcclxuICAgICAgICAgICAgLy8gYnV0IHRvb2x0aXAgZG8gbm90IG1vdmUgaW1tZWRpYXRlbHkuXHJcbiAgICAgICAgICAgIHZhciBkZWxheSA9IHRvb2x0aXBNb2RlbC5nZXQoJ3Nob3dEZWxheScpO1xyXG4gICAgICAgICAgICBjYiA9IHpyVXRpbC5iaW5kKGNiLCB0aGlzKTtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Nob3dUaW1vdXQpO1xyXG4gICAgICAgICAgICBkZWxheSA+IDBcclxuICAgICAgICAgICAgICAgID8gKHRoaXMuX3Nob3dUaW1vdXQgPSBzZXRUaW1lb3V0KGNiLCBkZWxheSkpXHJcbiAgICAgICAgICAgICAgICA6IGNiKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgVG9vbHRpcFZpZXcucHJvdG90eXBlLl9zaG93VG9vbHRpcENvbnRlbnQgPSBmdW5jdGlvbiAodG9vbHRpcE1vZGVsLCBkZWZhdWx0SHRtbCwgcGFyYW1zLCBhc3luY1RpY2tldCwgeCwgeSwgcG9zaXRpb25FeHByLCBlbCkge1xyXG4gICAgICAgICAgICAvLyBSZXNldCB0aWNrZXRcclxuICAgICAgICAgICAgdGhpcy5fdGlja2V0ID0gJyc7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRvb2x0aXBNb2RlbC5nZXQoJ3Nob3dDb250ZW50JykgfHwgIXRvb2x0aXBNb2RlbC5nZXQoJ3Nob3cnKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgdG9vbHRpcENvbnRlbnQgPSB0aGlzLl90b29sdGlwQ29udGVudDtcclxuXHJcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZXIgPSB0b29sdGlwTW9kZWwuZ2V0KCdmb3JtYXR0ZXInKTtcclxuICAgICAgICAgICAgcG9zaXRpb25FeHByID0gcG9zaXRpb25FeHByIHx8IHRvb2x0aXBNb2RlbC5nZXQoJ3Bvc2l0aW9uJyk7XHJcbiAgICAgICAgICAgIHZhciBodG1sID0gZGVmYXVsdEh0bWw7XHJcblxyXG4gICAgICAgICAgICBpZiAoZm9ybWF0dGVyICYmIHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBodG1sID0gZmxvd1V0aWwuZm9ybWF0VHBsKGZvcm1hdHRlciwgcGFyYW1zLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoY2JUaWNrZXQsIGh0bWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2JUaWNrZXQgPT09IHRoaXMuX3RpY2tldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwQ29udGVudC5zZXRDb250ZW50KGh0bWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXBNb2RlbCwgcG9zaXRpb25FeHByLCB4LCB5LCB0b29sdGlwQ29udGVudCwgcGFyYW1zLCBlbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RpY2tldCA9IGFzeW5jVGlja2V0O1xyXG4gICAgICAgICAgICAgICAgaHRtbCA9IGZvcm1hdHRlcihwYXJhbXMsIGFzeW5jVGlja2V0LCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRvb2x0aXBDb250ZW50LnNldENvbnRlbnQoaHRtbCk7XHJcbiAgICAgICAgICAgIHRvb2x0aXBDb250ZW50LnNob3codG9vbHRpcE1vZGVsKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKFxyXG4gICAgICAgICAgICAgICAgdG9vbHRpcE1vZGVsLCBwb3NpdGlvbkV4cHIsIHgsIHksIHRvb2x0aXBDb250ZW50LCBwYXJhbXMsIGVsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfEZ1bmN0aW9ufEFycmF5LjxudW1iZXI+fSBwb3NpdGlvbkV4cHJcclxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggTW91c2UgeFxyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geSBNb3VzZSB5XHJcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gY29uZmluZSBXaGV0aGVyIGNvbmZpbmUgdG9vbHRpcCBjb250ZW50IGluIHZpZXcgcmVjdC5cclxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R8PEFycmF5LjxPYmplY3Q+fSBwYXJhbXNcclxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxyXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXHJcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVG9vbHRpcFZpZXcucHJvdG90eXBlLl91cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIHBvc2l0aW9uRXhwciwgeCwgeSwgY29udGVudCwgcGFyYW1zLCBlbCkge1xyXG4gICAgICAgICAgICB2YXIgdmlld1dpZHRoID0gdGhpcy5fYXBpLmdldFdpZHRoKCk7XHJcbiAgICAgICAgICAgIHZhciB2aWV3SGVpZ2h0ID0gdGhpcy5fYXBpLmdldEhlaWdodCgpO1xyXG4gICAgICAgICAgICBwb3NpdGlvbkV4cHIgPSBwb3NpdGlvbkV4cHIgfHwgdG9vbHRpcE1vZGVsLmdldCgncG9zaXRpb24nKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjb250ZW50U2l6ZSA9IGNvbnRlbnQuZ2V0U2l6ZSgpO1xyXG4gICAgICAgICAgICB2YXIgYWxpZ24gPSB0b29sdGlwTW9kZWwuZ2V0KCdhbGlnbicpO1xyXG4gICAgICAgICAgICB2YXIgdkFsaWduID0gdG9vbHRpcE1vZGVsLmdldCgndmVydGljYWxBbGlnbicpO1xyXG4gICAgICAgICAgICB2YXIgcmVjdCA9IGVsICYmIGVsLmdldEJvdW5kaW5nUmVjdCgpLmNsb25lKCk7XHJcbiAgICAgICAgICAgIGVsICYmIHJlY3QuYXBwbHlUcmFuc2Zvcm0oZWwudHJhbnNmb3JtKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcG9zaXRpb25FeHByID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDYWxsYmFjayBvZiBwb3NpdGlvbiBjYW4gYmUgYW4gYXJyYXkgb3IgYSBzdHJpbmcgc3BlY2lmeSB0aGUgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uRXhwciA9IHBvc2l0aW9uRXhwcihbeCwgeV0sIHBhcmFtcywgY29udGVudC5lbCwgcmVjdCwge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdTaXplOiBbdmlld1dpZHRoLCB2aWV3SGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50U2l6ZTogY29udGVudFNpemUuc2xpY2UoKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh6clV0aWwuaXNBcnJheShwb3NpdGlvbkV4cHIpKSB7XHJcbiAgICAgICAgICAgICAgICB4ID0gZmxvd1V0aWwucGFyc2VQZXJjZW50KHBvc2l0aW9uRXhwclswXSwgdmlld1dpZHRoKTtcclxuICAgICAgICAgICAgICAgIHkgPSBmbG93VXRpbC5wYXJzZVBlcmNlbnQocG9zaXRpb25FeHByWzFdLCB2aWV3SGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh6clV0aWwuaXNPYmplY3QocG9zaXRpb25FeHByKSkge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25FeHByLndpZHRoID0gY29udGVudFNpemVbMF07XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkV4cHIuaGVpZ2h0ID0gY29udGVudFNpemVbMV07XHJcbiAgICAgICAgICAgICAgICB2YXIgbGF5b3V0UmVjdCA9IGxheW91dC5nZXRMYXlvdXRSZWN0KFxyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uRXhwciwge3dpZHRoOiB2aWV3V2lkdGgsIGhlaWdodDogdmlld0hlaWdodH1cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB4ID0gbGF5b3V0UmVjdC54O1xyXG4gICAgICAgICAgICAgICAgeSA9IGxheW91dFJlY3QueTtcclxuICAgICAgICAgICAgICAgIGFsaWduID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIC8vIFdoZW4gcG9zaXRpb25FeHByIGlzIGxlZnQvdG9wL3JpZ2h0L2JvdHRvbSxcclxuICAgICAgICAgICAgICAgIC8vIGFsaWduIGFuZCB2ZXJ0aWNhbEFsaWduIHdpbGwgbm90IHdvcmsuXHJcbiAgICAgICAgICAgICAgICB2QWxpZ24gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNwZWNpZnkgdG9vbHRpcCBwb3NpdGlvbiBieSBzdHJpbmcgJ3RvcCcgJ2JvdHRvbScgJ2xlZnQnICdyaWdodCcgYXJvdW5kIGdyYXBoaWMgZWxlbWVudFxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcG9zaXRpb25FeHByID09PSAnc3RyaW5nJyAmJiBlbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IGNhbGNUb29sdGlwUG9zaXRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25FeHByLCByZWN0LCBjb250ZW50U2l6ZVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIHggPSBwb3NbMF07XHJcbiAgICAgICAgICAgICAgICB5ID0gcG9zWzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvczEgPSByZWZpeFRvb2x0aXBQb3NpdGlvbihcclxuICAgICAgICAgICAgICAgICAgICB4LCB5LCBjb250ZW50LmVsLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQsIGFsaWduID8gMCA6IDIwLCB2QWxpZ24gPyAwIDogMjBcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB4ID0gcG9zMVswXTtcclxuICAgICAgICAgICAgICAgIHkgPSBwb3MxWzFdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBhbGlnbiAmJiAoeCAtPSBpc0NlbnRlckFsaWduKGFsaWduKSA/IGNvbnRlbnRTaXplWzBdIC8gMiA6IGFsaWduID09PSAncmlnaHQnID8gY29udGVudFNpemVbMF0gOiAwKTtcclxuICAgICAgICAgICAgdkFsaWduICYmICh5IC09IGlzQ2VudGVyQWxpZ24odkFsaWduKSA/IGNvbnRlbnRTaXplWzFdIC8gMiA6IHZBbGlnbiA9PT0gJ2JvdHRvbScgPyBjb250ZW50U2l6ZVsxXSA6IDApO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRvb2x0aXBNb2RlbC5nZXQoJ2NvbmZpbmUnKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvczIgPSBjb25maW5lVG9vbHRpcFBvc2l0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgIHgsIHksIGNvbnRlbnQuZWwsIHZpZXdXaWR0aCwgdmlld0hlaWdodFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIHggPSBwb3MyWzBdO1xyXG4gICAgICAgICAgICAgICAgeSA9IHBvczJbMV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnRlbnQubW92ZVRvKHgsIHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjYWxjVG9vbHRpcFBvc2l0aW9uKHBvc2l0aW9uLCByZWN0LCBjb250ZW50U2l6ZSkge1xyXG4gICAgICAgIHZhciBkb21XaWR0aCA9IGNvbnRlbnRTaXplWzBdO1xyXG4gICAgICAgIHZhciBkb21IZWlnaHQgPSBjb250ZW50U2l6ZVsxXTtcclxuICAgICAgICB2YXIgZ2FwID0gNTtcclxuICAgICAgICB2YXIgeCA9IDA7XHJcbiAgICAgICAgdmFyIHkgPSAwO1xyXG4gICAgICAgIHZhciByZWN0V2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgICAgIHZhciByZWN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgc3dpdGNoIChwb3NpdGlvbikge1xyXG4gICAgICAgICAgICBjYXNlICdpbnNpZGUnOlxyXG4gICAgICAgICAgICAgICAgeCA9IHJlY3QueCArIHJlY3RXaWR0aCAvIDIgLSBkb21XaWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICB5ID0gcmVjdC55ICsgcmVjdEhlaWdodCAvIDIgLSBkb21IZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgICAgICAgICB4ID0gcmVjdC54ICsgcmVjdFdpZHRoIC8gMiAtIGRvbVdpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHkgPSByZWN0LnkgLSBkb21IZWlnaHQgLSBnYXA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcclxuICAgICAgICAgICAgICAgIHggPSByZWN0LnggKyByZWN0V2lkdGggLyAyIC0gZG9tV2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgeSA9IHJlY3QueSArIHJlY3RIZWlnaHQgKyBnYXA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICAgICAgICB4ID0gcmVjdC54IC0gZG9tV2lkdGggLSBnYXA7XHJcbiAgICAgICAgICAgICAgICB5ID0gcmVjdC55ICsgcmVjdEhlaWdodCAvIDIgLSBkb21IZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgICAgICAgIHggPSByZWN0LnggKyByZWN0V2lkdGggKyBnYXA7XHJcbiAgICAgICAgICAgICAgICB5ID0gcmVjdC55ICsgcmVjdEhlaWdodCAvIDIgLSBkb21IZWlnaHQgLyAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW3gsIHldO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVmaXhUb29sdGlwUG9zaXRpb24oeCwgeSwgZWwsIHZpZXdXaWR0aCwgdmlld0hlaWdodCwgZ2FwSCwgZ2FwVikge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IGVsLmNsaWVudFdpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBlbC5jbGllbnRIZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmICh4ICsgd2lkdGggKyBnYXBIID4gdmlld1dpZHRoKSB7XHJcbiAgICAgICAgICAgIHggLT0gd2lkdGggKyBnYXBIO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgeCArPSBnYXBIO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeSArIGhlaWdodCArIGdhcFYgPiB2aWV3SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHkgLT0gaGVpZ2h0ICsgZ2FwVjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHkgKz0gZ2FwVjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0NlbnRlckFsaWduKGFsaWduKSB7XHJcbiAgICAgICAgcmV0dXJuIGFsaWduID09PSAnY2VudGVyJyB8fCBhbGlnbiA9PT0gJ21pZGRsZSc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29uZmluZVRvb2x0aXBQb3NpdGlvbih4LCB5LCBlbCwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0KSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gZWwuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcclxuXHJcbiAgICAgICAgeCA9IE1hdGgubWluKHggKyB3aWR0aCwgdmlld1dpZHRoKSAtIHdpZHRoO1xyXG4gICAgICAgIHkgPSBNYXRoLm1pbih5ICsgaGVpZ2h0LCB2aWV3SGVpZ2h0KSAtIGhlaWdodDtcclxuICAgICAgICB4ID0gTWF0aC5tYXgoeCwgMCk7XHJcbiAgICAgICAgeSA9IE1hdGgubWF4KHksIDApO1xyXG5cclxuICAgICAgICByZXR1cm4gW3gsIHldO1xyXG4gICAgfVxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUb29sdGlwVmlldztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL3Rvb2x0aXAvVG9vbHRpcFZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDEzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciB6ckNvbG9yID0gcmVxdWlyZSgnenJlbmRlci9saWIvdG9vbC9jb2xvcicpO1xyXG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZW52Jyk7XHJcbiAgICB2YXIgZXZlbnRVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9ldmVudCcpO1xyXG4gICAgdmFyIGZsb3dVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9GbG93VXRpbCcpO1xyXG4gICAgdmFyIHRvQ2FtZWxDYXNlID0gZmxvd1V0aWwudG9DYW1lbENhc2U7XHJcbiAgICB2YXIgbm9ybWFsaXplQ3NzQXJyYXkgPSBmbG93VXRpbC5ub3JtYWxpemVDc3NBcnJheTtcclxuICAgIHZhciBlYWNoID0genJVdGlsLmVhY2g7XHJcblxyXG5cclxuICAgIHZhciB2ZW5kb3JzID0gWycnLCAnLXdlYmtpdC0nLCAnLW1vei0nLCAnLW8tJ107XHJcblxyXG4gICAgdmFyIGdDc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO2Rpc3BsYXk6YmxvY2s7Ym9yZGVyLXN0eWxlOnNvbGlkO3doaXRlLXNwYWNlOm5vd3JhcDt6LWluZGV4Ojk5OTsnOy8vZmlzaCBwb3B1cCB6aW5kZXg6MTA1MFxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25cclxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhc3NlbWJsZVRyYW5zaXRpb24oZHVyYXRpb24pIHtcclxuICAgICAgICB2YXIgdHJhbnNpdGlvbkN1cnZlID0gJ2N1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKSc7XHJcbiAgICAgICAgdmFyIHRyYW5zaXRpb25UZXh0ID0gJ2xlZnQgJyArIGR1cmF0aW9uICsgJ3MgJyArIHRyYW5zaXRpb25DdXJ2ZSArICcsJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAndG9wICcgKyBkdXJhdGlvbiArICdzICcgKyB0cmFuc2l0aW9uQ3VydmU7XHJcbiAgICAgICAgcmV0dXJuIHpyVXRpbC5tYXAodmVuZG9ycywgZnVuY3Rpb24gKHZlbmRvclByZWZpeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmVuZG9yUHJlZml4ICsgJ3RyYW5zaXRpb246JyArIHRyYW5zaXRpb25UZXh0O1xyXG4gICAgICAgIH0pLmpvaW4oJzsnKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZXh0U3R5bGVcclxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhc3NlbWJsZUZvbnQodGV4dFN0eWxlTW9kZWwpIHtcclxuICAgICAgICB2YXIgY3NzVGV4dCA9IFtdO1xyXG5cclxuICAgICAgICB2YXIgZm9udFNpemUgPSB0ZXh0U3R5bGVNb2RlbC5nZXQoJ2ZvbnRTaXplJyk7XHJcbiAgICAgICAgdmFyIGNvbG9yID0gdGV4dFN0eWxlTW9kZWwuZ2V0KFwiY29sb3JcIik7XHJcblxyXG4gICAgICAgIGNvbG9yICYmIGNzc1RleHQucHVzaCgnY29sb3I6JyArIGNvbG9yKTtcclxuXHJcbiAgICAgICAgdmFyIGZvbnQgPSB0ZXh0U3R5bGVNb2RlbC5nZXQoXCJmb250XCIpO1xyXG4gICAgICAgIGZvbnQgJiYgY3NzVGV4dC5wdXNoKCdmb250OicgKyBmb250KTtcclxuXHJcbiAgICAgICAgZm9udFNpemUgJiZcclxuICAgICAgICAgICAgY3NzVGV4dC5wdXNoKCdsaW5lLWhlaWdodDonICsgTWF0aC5yb3VuZChmb250U2l6ZSAqIDMgLyAyKSArICdweCcpO1xyXG5cclxuICAgICAgICBlYWNoKFsnZGVjb3JhdGlvbicsICdhbGlnbiddLCBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgdmFsID0gdGV4dFN0eWxlTW9kZWwuZ2V0KG5hbWUpO1xyXG4gICAgICAgICAgICB2YWwgJiYgY3NzVGV4dC5wdXNoKCd0ZXh0LScgKyBuYW1lICsgJzonICsgdmFsKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNzc1RleHQuam9pbignOycpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdG9vbHRpcE1vZGVsXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXNzZW1ibGVDc3NUZXh0KHRvb2x0aXBNb2RlbCkge1xyXG5cclxuICAgICAgICB2YXIgY3NzVGV4dCA9IFtdO1xyXG5cclxuICAgICAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gdG9vbHRpcE1vZGVsLmdldCgndHJhbnNpdGlvbkR1cmF0aW9uJyk7XHJcbiAgICAgICAgdmFyIGJhY2tncm91bmRDb2xvciA9IHRvb2x0aXBNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpO1xyXG4gICAgICAgIHZhciB0ZXh0U3R5bGVNb2RlbCA9IHRvb2x0aXBNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XHJcbiAgICAgICAgdmFyIHBhZGRpbmcgPSB0b29sdGlwTW9kZWwuZ2V0KCdwYWRkaW5nJyk7XHJcblxyXG4gICAgICAgIC8vIEFuaW1hdGlvbiB0cmFuc2l0aW9uLiBEbyBub3QgYW5pbWF0ZSB3aGVuIHRyYW5zaXRpb25EdXJhdGlvbiBpcyAwLlxyXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbiAmJlxyXG4gICAgICAgICAgICBjc3NUZXh0LnB1c2goYXNzZW1ibGVUcmFuc2l0aW9uKHRyYW5zaXRpb25EdXJhdGlvbikpO1xyXG5cclxuICAgICAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChlbnYuY2FudmFzU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgICAgICBjc3NUZXh0LnB1c2goJ2JhY2tncm91bmQtQ29sb3I6JyArIGJhY2tncm91bmRDb2xvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmb3IgaWVcclxuICAgICAgICAgICAgICAgIGNzc1RleHQucHVzaChcclxuICAgICAgICAgICAgICAgICAgICAnYmFja2dyb3VuZC1Db2xvcjojJyArIHpyQ29sb3IudG9IZXgoYmFja2dyb3VuZENvbG9yKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGNzc1RleHQucHVzaCgnZmlsdGVyOmFscGhhKG9wYWNpdHk9NzApJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEJvcmRlciBzdHlsZVxyXG4gICAgICAgIGVhY2goWyd3aWR0aCcsICdjb2xvcicsICdyYWRpdXMnXSwgZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGJvcmRlck5hbWUgPSAnYm9yZGVyLScgKyBuYW1lO1xyXG4gICAgICAgICAgICB2YXIgY2FtZWxDYXNlID0gdG9DYW1lbENhc2UoYm9yZGVyTmFtZSk7XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSB0b29sdGlwTW9kZWwuZ2V0KGNhbWVsQ2FzZSk7XHJcbiAgICAgICAgICAgIHZhbCAhPSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICBjc3NUZXh0LnB1c2goYm9yZGVyTmFtZSArICc6JyArIHZhbCArIChuYW1lID09PSAnY29sb3InID8gJycgOiAncHgnKSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIFRleHQgc3R5bGVcclxuICAgICAgICBjc3NUZXh0LnB1c2goYXNzZW1ibGVGb250KHRleHRTdHlsZU1vZGVsKSk7XHJcblxyXG4gICAgICAgIC8vIFBhZGRpbmdcclxuICAgICAgICBpZiAocGFkZGluZyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNzc1RleHQucHVzaCgncGFkZGluZzonICsgbm9ybWFsaXplQ3NzQXJyYXkocGFkZGluZykuam9pbigncHggJykgKyAncHgnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjc3NUZXh0LmpvaW4oJzsnKSArICc7JztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gY29udGFpbmVyXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gYXBpXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFRvb2x0aXBDb250ZW50KGNvbnRhaW5lciwgYXBpKSB7XHJcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgdmFyIHpyID0gdGhpcy5fenIgPSBhcGkuZ2V0WnIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xyXG5cclxuICAgICAgICB0aGlzLl94ID0gYXBpLmdldFdpZHRoKCkgLyAyO1xyXG4gICAgICAgIHRoaXMuX3kgPSBhcGkuZ2V0SGVpZ2h0KCkgLyAyO1xyXG5cclxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xyXG5cclxuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XHJcblxyXG4gICAgICAgIHRoaXMuX3Nob3cgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9oaWRlVGltZW91dDtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIGVsLm9ubW91c2VlbnRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gY2xlYXIgdGhlIHRpbWVvdXQgaW4gaGlkZUxhdGVyIGFuZCBrZWVwIHNob3dpbmcgdG9vbHRpcFxyXG4gICAgICAgICAgICBpZiAoc2VsZi5fZW50ZXJhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoc2VsZi5faGlkZVRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fc2hvdyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZi5faW5Db250ZW50ID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGVsLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG4gICAgICAgICAgICBpZiAoIXNlbGYuX2VudGVyYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRyaWdnZXIgenJlbmRlciBldmVudCB0byBhdm9pZCBtb3VzZVxyXG4gICAgICAgICAgICAgICAgLy8gaW4gYW5kIG91dCBzaGFwZSB0b28gZnJlcXVlbnRseVxyXG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB6ci5oYW5kbGVyO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRVdGlsLm5vcm1hbGl6ZUV2ZW50KGNvbnRhaW5lciwgZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmRpc3BhdGNoKCdtb3VzZW1vdmUnLCBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZWwub25tb3VzZWxlYXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoc2VsZi5fZW50ZXJhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5fc2hvdykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaGlkZUxhdGVyKHNlbGYuX2hpZGVEZWxheSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZi5faW5Db250ZW50ID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIFRvb2x0aXBDb250ZW50LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3I6IFRvb2x0aXBDb250ZW50LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9lbnRlcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZSB3aGVuIHRvb2x0aXAgaXMgcmVuZGVyZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gRklYTUVcclxuICAgICAgICAgICAgLy8gTW92ZSB0aGlzIGxvZ2ljIHRvIGVjIG1haW4/XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XHJcbiAgICAgICAgICAgIHZhciBzdGwgPSBjb250YWluZXIuY3VycmVudFN0eWxlXHJcbiAgICAgICAgICAgICAgICB8fCBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIHZhciBkb21TdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcclxuICAgICAgICAgICAgaWYgKGRvbVN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHN0bC5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJykge1xyXG4gICAgICAgICAgICAgICAgZG9tU3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEhpZGUgdGhlIHRvb2x0aXBcclxuICAgICAgICAgICAgLy8gUEVORElOR1xyXG4gICAgICAgICAgICAvLyB0aGlzLmhpZGUoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzaG93OiBmdW5jdGlvbiAodG9vbHRpcE1vZGVsKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9oaWRlVGltZW91dCk7XHJcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XHJcblxyXG4gICAgICAgICAgICBlbC5zdHlsZS5jc3NUZXh0ID0gZ0Nzc1RleHQgKyBhc3NlbWJsZUNzc1RleHQodG9vbHRpcE1vZGVsKVxyXG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMTEyNTU4Ny9jc3MzLXRyYW5zaXRpb24tbm90LXdvcmtpbmctaW4tY2hyb21lLWFueW1vcmVcclxuICAgICAgICAgICAgICAgICsgJztsZWZ0OicgKyB0aGlzLl94ICsgJ3B4O3RvcDonICsgdGhpcy5feSArICdweDsnXHJcbiAgICAgICAgICAgICAgICArICh0b29sdGlwTW9kZWwuZ2V0KCdleHRyYUNzc1RleHQnKSB8fCAnJyk7XHJcblxyXG4gICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuaW5uZXJIVE1MID8gICdibG9jaycgOiAnbm9uZSc7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9zaG93ID0gdHJ1ZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXRDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLmlubmVySFRNTCA9IGNvbnRlbnQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0RW50ZXJhYmxlOiBmdW5jdGlvbiAoZW50ZXJhYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VudGVyYWJsZSA9IGVudGVyYWJsZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XHJcbiAgICAgICAgICAgIHJldHVybiBbZWwuY2xpZW50V2lkdGgsIGVsLmNsaWVudEhlaWdodF07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgbW92ZVRvOiBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICAvLyB4eSBzaG91bGQgYmUgYmFzZWQgb24gY2FudmFzIHJvb3QuIEJ1dCB0b29sdGlwQ29udGVudCBpc1xyXG4gICAgICAgICAgICAvLyB0aGUgc2libGluZyBvZiBjYW52YXMgcm9vdC4gU28gcGFkZGluZyBvZiBlYyBjb250YWluZXJcclxuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGNvbnNpZGVyZWQgaGVyZS5cclxuICAgICAgICAgICAgdmFyIHpyID0gdGhpcy5fenI7XHJcbiAgICAgICAgICAgIHZhciB2aWV3cG9ydFJvb3Q7XHJcbiAgICAgICAgICAgIGlmICh6ciAmJiB6ci5wYWludGVyICYmICh2aWV3cG9ydFJvb3QgPSB6ci5wYWludGVyLmdldFZpZXdwb3J0Um9vdCgpKSkge1xyXG4gICAgICAgICAgICAgICAgeCArPSB2aWV3cG9ydFJvb3Qub2Zmc2V0TGVmdCB8fCAwO1xyXG4gICAgICAgICAgICAgICAgeSArPSB2aWV3cG9ydFJvb3Qub2Zmc2V0VG9wIHx8IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuZWwuc3R5bGU7XHJcbiAgICAgICAgICAgIHN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcclxuICAgICAgICAgICAgc3R5bGUudG9wID0geSArICdweCc7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl94ID0geDtcclxuICAgICAgICAgICAgdGhpcy5feSA9IHk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaGlkZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nob3cgPSBmYWxzZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBoaWRlTGF0ZXI6IGZ1bmN0aW9uICh0aW1lKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zaG93ICYmICEodGhpcy5faW5Db250ZW50ICYmIHRoaXMuX2VudGVyYWJsZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlkZURlbGF5ID0gdGltZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgc2hvdyBmYWxzZSB0byBhdm9pZCBpbnZva2UgaGlkZUxhdGVyIG11dGlwbGUgdGltZXNcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaG93ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlkZVRpbWVvdXQgPSBzZXRUaW1lb3V0KHpyVXRpbC5iaW5kKHRoaXMuaGlkZSwgdGhpcyksIHRpbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpc1Nob3c6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3c7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRvb2x0aXBDb250ZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvdG9vbHRpcC9Ub29sdGlwQ29udGVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG5cclxuICAgIHZhciBlbnYgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2VudicpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdldCA9IHJlcXVpcmUoJy4uL3V0aWwvRmxvd1V0aWwnKS5tYWtlR2V0dGVyKCk7XHJcblxyXG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcclxuXHJcbiAgICB2YXIgZ2xvYmFsTGlzdGVuZXIgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBrZXkg5rOo5YaM55qE5a2X56ym5LiyXHJcbiAgICAgKiBAcGFyYW0gYXBpIEV4dGVuc2lvbkFQSVxyXG4gICAgICogQHBhcmFtIGhhbmRsZXIg5aSE55CG5Zue6LCDXHJcbiAgICAgKi9cclxuICAgIGdsb2JhbExpc3RlbmVyLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGtleSwgYXBpLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgaWYgKGVudi5ub2RlKSB7ICAgLy9ub2Rl546v5aKD5LiL5LiN5omn6KGMXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/liKTmlq16cmVuZGVy55qEIHJlY29yZHMgIOW5tuWIneWni+WMllxyXG4gICAgICAgIHZhciB6ciA9IGFwaS5nZXRacigpO1xyXG4gICAgICAgIGdldCh6cikucmVjb3JkcyB8fCAoZ2V0KHpyKS5yZWNvcmRzID0ge30pO1xyXG5cclxuICAgICAgICBpbml0R2xvYmFsTGlzdGVuZXJzKHpyLCBhcGkpO1xyXG5cclxuICAgICAgICAvL+WwhuWbnuiwg+WKoOWFpXJlY29yZFxyXG4gICAgICAgIHZhciByZWNvcmQgPSBnZXQoenIpLnJlY29yZHNba2V5XSB8fCAoZ2V0KHpyKS5yZWNvcmRzW2tleV0gPSB7fSk7XHJcbiAgICAgICAgcmVjb3JkLmhhbmRsZXIgPSBoYW5kbGVyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIneWni+WMluWFqOWxgOS+puWQrFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB6ciAgIHpyZW5kZXJcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcGkgIEV4dGVuc2lvbkFQSVxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaW5pdEdsb2JhbExpc3RlbmVycyh6ciwgYXBpKSB7XHJcbiAgICAgICAgaWYgKGdldCh6cikuaW5pdGlhbGl6ZWQpIHsgICAvL+mBv+WFjemHjeWkjeWIneWni+WMllxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnZXQoenIpLmluaXRpYWxpemVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy/kvqblkKzkuovku7ZcclxuICAgICAgICB1c2VIYW5kbGVyKCdjbGljaycsIHpyVXRpbC5jdXJyeShkb0VudGVyLCAnY2xpY2snKSk7XHJcbiAgICAgICAgdXNlSGFuZGxlcignbW91c2Vtb3ZlJywgenJVdGlsLmN1cnJ5KGRvRW50ZXIsICdtb3VzZW1vdmUnKSk7XHJcbiAgICAgICAgLy8gdXNlSGFuZGxlcignbW91c2VvdXQnLCBvbkxlYXZlKTtcclxuICAgICAgICB1c2VIYW5kbGVyKCdnbG9iYWxvdXQnLCBvbkxlYXZlKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdXNlSGFuZGxlcihldmVudFR5cGUsIGNiKSB7XHJcbiAgICAgICAgICAgIHpyLm9uKGV2ZW50VHlwZSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkaXMgPSBtYWtlRGlzcGF0Y2hBY3Rpb24oYXBpKTtcclxuICAgICAgICAgICAgICAgIC8v6YGN5Y6G5rOo5YaM55qEIOaJgOaciXJlY29yZHPvvIwg5bm26L+b6KGM6LCD55SoXHJcbiAgICAgICAgICAgICAgICBlYWNoKGdldCh6cikucmVjb3JkcywgZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCAmJiBjYihyZWNvcmQsIGUsIGRpcy5kaXNwYXRjaEFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaFRvb2x0aXBGaW5hbGx5KGRpcy5wZW5kaW5ncywgYXBpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoVG9vbHRpcEZpbmFsbHkocGVuZGluZ3MsIGFwaSkge1xyXG4gICAgICAgIHZhciBzaG93TGVuID0gcGVuZGluZ3Muc2hvd1RpcC5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGhpZGVMZW4gPSBwZW5kaW5ncy5oaWRlVGlwLmxlbmd0aDtcclxuXHJcbiAgICAgICAgdmFyIGFjdHVhbGx5UGF5bG9hZDtcclxuICAgICAgICBpZiAoc2hvd0xlbikge1xyXG4gICAgICAgICAgICBhY3R1YWxseVBheWxvYWQgPSBwZW5kaW5ncy5zaG93VGlwW3Nob3dMZW4gLSAxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGlkZUxlbikge1xyXG4gICAgICAgICAgICBhY3R1YWxseVBheWxvYWQgPSBwZW5kaW5ncy5oaWRlVGlwW2hpZGVMZW4gLSAxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFjdHVhbGx5UGF5bG9hZCkge1xyXG4gICAgICAgICAgICBhY3R1YWxseVBheWxvYWQuZGlzcGF0Y2hBY3Rpb24gPSBudWxsO1xyXG4gICAgICAgICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oYWN0dWFsbHlQYXlsb2FkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gb25MZWF2ZShyZWNvcmQsIGUsIGRpc3BhdGNoQWN0aW9uKSB7XHJcbiAgICAgICAgcmVjb3JkLmhhbmRsZXIoJ2xlYXZlJywgbnVsbCwgZGlzcGF0Y2hBY3Rpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRvRW50ZXIoY3VyclRyaWdnZXIsIHJlY29yZCwgZSwgZGlzcGF0Y2hBY3Rpb24pIHtcclxuICAgICAgICByZWNvcmQuaGFuZGxlcihjdXJyVHJpZ2dlciwgZSwgZGlzcGF0Y2hBY3Rpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5rS+5Y+RYWN0aW9uICAg6KGM5bCG5Y+R55Sf55qEXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHthbnl9IGFwaVxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbWFrZURpc3BhdGNoQWN0aW9uKGFwaSkge1xyXG4gICAgICAgIHZhciBwZW5kaW5ncyA9IHtcclxuICAgICAgICAgICAgc2hvd1RpcDogW10sXHJcbiAgICAgICAgICAgIGhpZGVUaXA6IFtdXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBGSVhNRVxyXG4gICAgICAgIC8vIGJldHRlciBhcHByb2FjaD9cclxuICAgICAgICAvLyAnc2hvd1RpcCcgYW5kICdoaWRlVGlwJyBjYW4gYmUgdHJpZ2dlcmVkIGJ5IGF4aXNQb2ludGVyIGFuZCB0b29sdGlwLFxyXG4gICAgICAgIC8vIHdoaWNoIG1heSBiZSBjb25mbGljdCwgKGF4aXNQb2ludGVyIGNhbGwgc2hvd1RpcCBidXQgdG9vbHRpcCBjYWxsIGhpZGVUaXApO1xyXG4gICAgICAgIC8vIFNvIHdlIGhhdmUgdG8gYWRkIFwiZmluYWwgc3RhZ2VcIiB0byBtZXJnZSB0aG9zZSBkaXNwYXRjaGVkIGFjdGlvbnMuXHJcbiAgICAgICAgdmFyIGRpc3BhdGNoQWN0aW9uID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcclxuICAgICAgICAgICAgdmFyIHBlbmRpbmdMaXN0ID0gcGVuZGluZ3NbcGF5bG9hZC50eXBlXTtcclxuICAgICAgICAgICAgaWYgKHBlbmRpbmdMaXN0KSB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nTGlzdC5wdXNoKHBheWxvYWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGF5bG9hZC5kaXNwYXRjaEFjdGlvbiA9IGRpc3BhdGNoQWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKHBheWxvYWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGlzcGF0Y2hBY3Rpb246IGRpc3BhdGNoQWN0aW9uLFxyXG4gICAgICAgICAgICBwZW5kaW5nczogcGVuZGluZ3NcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxyXG4gICAgICovXHJcbiAgICBnbG9iYWxMaXN0ZW5lci51bnJlZ2lzdGVyID0gZnVuY3Rpb24gKGtleSwgYXBpKSB7XHJcbiAgICAgICAgaWYgKGVudi5ub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHpyID0gYXBpLmdldFpyKCk7XHJcbiAgICAgICAgdmFyIHJlY29yZCA9IChnZXQoenIpLnJlY29yZHMgfHwge30pW2tleV07XHJcbiAgICAgICAgaWYgKHJlY29yZCkge1xyXG4gICAgICAgICAgICBnZXQoenIpLnJlY29yZHNba2V5XSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbExpc3RlbmVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvdG9vbHRpcC9nbG9iYWxMaXN0ZW5lci5qc1xuLy8gbW9kdWxlIGlkID0gMTM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG5cclxuICAgIHZhciBNb2RlbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9tb2RlbCcpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBNb2RlbC5leHRlbmQoe1xyXG5cclxuICAgICAgICB0eXBlOiAndG9vbHRpcCcsXHJcblxyXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcclxuICAgICAgICAgICAgemxldmVsOiAwLFxyXG5cclxuICAgICAgICAgICAgejogOCxcclxuXHJcbiAgICAgICAgICAgIHNob3c6IHRydWUsXHJcblxyXG4gICAgICAgICAgICAvLyB0b29sdGlw5Li75L2T5YaF5a65XHJcbiAgICAgICAgICAgIHNob3dDb250ZW50OiB0cnVlLFxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAvLyAnY2xpY2snIHwgJ21vdXNlbW92ZScgfCAnbm9uZSdcclxuICAgICAgICAgICAgdHJpZ2dlck9uOiAnbW91c2Vtb3ZlJyxcclxuXHJcbiAgICAgICAgICAgIGFsd2F5c1Nob3dDb250ZW50OiBmYWxzZSxcclxuXHJcbiAgICAgICAgICAgIGRpc3BsYXlNb2RlOiAnc2luZ2xlJywgLy8gJ3NpbmdsZScgfCAnbXVsdGlwbGVCeUNvb3JkU3lzJ1xyXG5cclxuICAgICAgICAgICAgLy8g5L2N572uIHtBcnJheX0gfCB7RnVuY3Rpb259XHJcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uOiBudWxsXHJcbiAgICAgICAgICAgIC8vIENvbnNpZGVyIHRyaWdnZXJlZCBmcm9tIGF4aXNQb2ludGVyIGhhbmRsZSwgdmVydGljYWxBbGlnbiBzaG91bGQgYmUgJ21pZGRsZSdcclxuICAgICAgICAgICAgLy8gYWxpZ246IG51bGwsXHJcbiAgICAgICAgICAgIC8vIHZlcnRpY2FsQWxpZ246IG51bGwsXHJcblxyXG4gICAgICAgICAgICAvLyDmmK/lkKbnuqbmnZ8gY29udGVudCDlnKggdmlld1JlY3Qg5Lit44CC6buY6K6kIGZhbHNlIOaYr+S4uuS6huWFvOWuueS7peWJjeeJiOacrOOAglxyXG4gICAgICAgICAgICBjb25maW5lOiBmYWxzZSxcclxuXHJcbiAgICAgICAgICAgIC8vIOWGheWuueagvOW8j+WZqO+8mntzdHJpbmd977yIVGVtcGxhdGXvvIkgwqYge0Z1bmN0aW9ufVxyXG4gICAgICAgICAgICAvLyBmb3JtYXR0ZXI6IG51bGxcclxuXHJcbiAgICAgICAgICAgIHNob3dEZWxheTogMCxcclxuXHJcbiAgICAgICAgICAgIC8vIOmakOiXj+W7tui/n++8jOWNleS9jW1zXHJcbiAgICAgICAgICAgIGhpZGVEZWxheTogMTAwLFxyXG5cclxuICAgICAgICAgICAgLy8g5Yqo55S75Y+Y5o2i5pe26Ze077yM5Y2V5L2Nc1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IDAuNCxcclxuXHJcbiAgICAgICAgICAgIGVudGVyYWJsZTogZmFsc2UsXHJcblxyXG4gICAgICAgICAgICAvLyDmj5DnpLrog4zmma/popzoibLvvIzpu5jorqTkuLrpgI/mmI7luqbkuLowLjfnmoTpu5HoibJcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSg1MCw1MCw1MCwwLjcpJyxcclxuXHJcbiAgICAgICAgICAgIC8vIOaPkOekuui+ueahhuminOiJslxyXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJyMzMzMnLFxyXG5cclxuICAgICAgICAgICAgLy8g5o+Q56S66L655qGG5ZyG6KeS77yM5Y2V5L2NcHjvvIzpu5jorqTkuLo0XHJcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogNCxcclxuXHJcbiAgICAgICAgICAgIC8vIOaPkOekuui+ueahhue6v+Wuve+8jOWNleS9jXB477yM6buY6K6k5Li6MO+8iOaXoOi+ueahhu+8iVxyXG4gICAgICAgICAgICBib3JkZXJXaWR0aDogMCxcclxuXHJcbiAgICAgICAgICAgIC8vIOaPkOekuuWGhei+uei3ne+8jOWNleS9jXB477yM6buY6K6k5ZCE5pa55ZCR5YaF6L656Led5Li6Ne+8jFxyXG4gICAgICAgICAgICAvLyDmjqXlj5fmlbDnu4TliIbliKvorr7lrprkuIrlj7PkuIvlt6bovrnot53vvIzlkIxjc3NcclxuICAgICAgICAgICAgcGFkZGluZzogNSxcclxuXHJcbiAgICAgICAgICAgIC8vIEV4dHJhIGNzcyB0ZXh0XHJcbiAgICAgICAgICAgIGV4dHJhQ3NzVGV4dDogJycsXHJcblxyXG4gICAgICAgICAgICB0ZXh0U3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGNvbG9yOiAnI2ZmZicsXHJcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMTRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvdG9vbHRpcC9Ub29sdGlwTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDEzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKFwiLi9ncmFwaGljXCIpO1xuXG52YXIgX3pyZW5kZXIgPSByZXF1aXJlKFwiLi4venJlbmRlclwiKTtcblxudmFyIHJlZ2lzdGVyUGFpbnRlciA9IF96cmVuZGVyLnJlZ2lzdGVyUGFpbnRlcjtcblxudmFyIFBhaW50ZXIgPSByZXF1aXJlKFwiLi9QYWludGVyXCIpO1xuXG5yZWdpc3RlclBhaW50ZXIoJ3ZtbCcsIFBhaW50ZXIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi92bWwvdm1sLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGVudiA9IHJlcXVpcmUoXCIuLi9jb3JlL2VudlwiKTtcblxudmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciBhcHBseVRyYW5zZm9ybSA9IF92ZWN0b3IuYXBwbHlUcmFuc2Zvcm07XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciBjb2xvclRvb2wgPSByZXF1aXJlKFwiLi4vdG9vbC9jb2xvclwiKTtcblxudmFyIHRleHRDb250YWluID0gcmVxdWlyZShcIi4uL2NvbnRhaW4vdGV4dFwiKTtcblxudmFyIHRleHRIZWxwZXIgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9oZWxwZXIvdGV4dFwiKTtcblxudmFyIFJlY3RUZXh0ID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvbWl4aW4vUmVjdFRleHRcIik7XG5cbnZhciBEaXNwbGF5YWJsZSA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL0Rpc3BsYXlhYmxlXCIpO1xuXG52YXIgWkltYWdlID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvSW1hZ2VcIik7XG5cbnZhciBUZXh0ID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvVGV4dFwiKTtcblxudmFyIFBhdGggPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9QYXRoXCIpO1xuXG52YXIgUGF0aFByb3h5ID0gcmVxdWlyZShcIi4uL2NvcmUvUGF0aFByb3h5XCIpO1xuXG52YXIgR3JhZGllbnQgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9HcmFkaWVudFwiKTtcblxudmFyIHZtbENvcmUgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9OT1RFLVZNTFxuLy8gVE9ETyBVc2UgcHJveHkgbGlrZSBzdmcgaW5zdGVhZCBvZiBvdmVyd3JpdGUgYnJ1c2ggbWV0aG9kc1xudmFyIENNRCA9IFBhdGhQcm94eS5DTUQ7XG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgY29zID0gTWF0aC5jb3M7XG52YXIgc2luID0gTWF0aC5zaW47XG52YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuXG5pZiAoIWVudi5jYW52YXNTdXBwb3J0ZWQpIHtcbiAgdmFyIGNvbW1hID0gJywnO1xuICB2YXIgaW1hZ2VUcmFuc2Zvcm1QcmVmaXggPSAncHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0JztcbiAgdmFyIFogPSAyMTYwMDtcbiAgdmFyIFoyID0gWiAvIDI7XG4gIHZhciBaTEVWRUxfQkFTRSA9IDEwMDAwMDtcbiAgdmFyIFpfQkFTRSA9IDEwMDA7XG5cbiAgdmFyIGluaXRSb290RWxTdHlsZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgIGVsLnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDowO3dpZHRoOjFweDtoZWlnaHQ6MXB4Oyc7XG4gICAgZWwuY29vcmRzaXplID0gWiArICcsJyArIFo7XG4gICAgZWwuY29vcmRvcmlnaW4gPSAnMCwwJztcbiAgfTtcblxuICB2YXIgZW5jb2RlSHRtbEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIFN0cmluZyhzKS5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbiAgfTtcblxuICB2YXIgcmdiMlN0ciA9IGZ1bmN0aW9uIChyLCBnLCBiKSB7XG4gICAgcmV0dXJuICdyZ2IoJyArIFtyLCBnLCBiXS5qb2luKCcsJykgKyAnKSc7XG4gIH07XG5cbiAgdmFyIGFwcGVuZCA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkICYmIHBhcmVudCAmJiBjaGlsZC5wYXJlbnROb2RlICE9PSBwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZW1vdmUgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCkge1xuICAgIGlmIChjaGlsZCAmJiBwYXJlbnQgJiYgY2hpbGQucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0WkluZGV4ID0gZnVuY3Rpb24gKHpsZXZlbCwgeiwgejIpIHtcbiAgICAvLyB6IOeahOWPluWAvOiMg+WbtOS4uiBbMCwgMTAwMF1cbiAgICByZXR1cm4gKHBhcnNlRmxvYXQoemxldmVsKSB8fCAwKSAqIFpMRVZFTF9CQVNFICsgKHBhcnNlRmxvYXQoeikgfHwgMCkgKiBaX0JBU0UgKyB6MjtcbiAgfTtcblxuICB2YXIgcGFyc2VQZXJjZW50ID0gZnVuY3Rpb24gKHZhbHVlLCBtYXhWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodmFsdWUubGFzdEluZGV4T2YoJyUnKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIG1heFZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIFBBVEhcbiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgdmFyIHNldENvbG9yQW5kT3BhY2l0eSA9IGZ1bmN0aW9uIChlbCwgY29sb3IsIG9wYWNpdHkpIHtcbiAgICB2YXIgY29sb3JBcnIgPSBjb2xvclRvb2wucGFyc2UoY29sb3IpO1xuICAgIG9wYWNpdHkgPSArb3BhY2l0eTtcblxuICAgIGlmIChpc05hTihvcGFjaXR5KSkge1xuICAgICAgb3BhY2l0eSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKGNvbG9yQXJyKSB7XG4gICAgICBlbC5jb2xvciA9IHJnYjJTdHIoY29sb3JBcnJbMF0sIGNvbG9yQXJyWzFdLCBjb2xvckFyclsyXSk7XG4gICAgICBlbC5vcGFjaXR5ID0gb3BhY2l0eSAqIGNvbG9yQXJyWzNdO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0Q29sb3JBbmRBbHBoYSA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIHZhciBjb2xvckFyciA9IGNvbG9yVG9vbC5wYXJzZShjb2xvcik7XG4gICAgcmV0dXJuIFtyZ2IyU3RyKGNvbG9yQXJyWzBdLCBjb2xvckFyclsxXSwgY29sb3JBcnJbMl0pLCBjb2xvckFyclszXV07XG4gIH07XG5cbiAgdmFyIHVwZGF0ZUZpbGxOb2RlID0gZnVuY3Rpb24gKGVsLCBzdHlsZSwgenJFbCkge1xuICAgIC8vIFRPRE8gcGF0dGVyblxuICAgIHZhciBmaWxsID0gc3R5bGUuZmlsbDtcblxuICAgIGlmIChmaWxsICE9IG51bGwpIHtcbiAgICAgIC8vIE1vZGlmaWVkIGZyb20gZXhjYW52YXNcbiAgICAgIGlmIChmaWxsIGluc3RhbmNlb2YgR3JhZGllbnQpIHtcbiAgICAgICAgdmFyIGdyYWRpZW50VHlwZTtcbiAgICAgICAgdmFyIGFuZ2xlID0gMDtcbiAgICAgICAgdmFyIGZvY3VzID0gWzAsIDBdOyAvLyBhZGRpdGlvbmFsIG9mZnNldFxuXG4gICAgICAgIHZhciBzaGlmdCA9IDA7IC8vIHNjYWxlIGZhY3RvciBmb3Igb2Zmc2V0XG5cbiAgICAgICAgdmFyIGV4cGFuc2lvbiA9IDE7XG4gICAgICAgIHZhciByZWN0ID0genJFbC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgdmFyIHJlY3RXaWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgIHZhciByZWN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgaWYgKGZpbGwudHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICBncmFkaWVudFR5cGUgPSAnZ3JhZGllbnQnO1xuICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSB6ckVsLnRyYW5zZm9ybTtcbiAgICAgICAgICB2YXIgcDAgPSBbZmlsbC54ICogcmVjdFdpZHRoLCBmaWxsLnkgKiByZWN0SGVpZ2h0XTtcbiAgICAgICAgICB2YXIgcDEgPSBbZmlsbC54MiAqIHJlY3RXaWR0aCwgZmlsbC55MiAqIHJlY3RIZWlnaHRdO1xuXG4gICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDAsIHAwLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDEsIHAxLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkeCA9IHAxWzBdIC0gcDBbMF07XG4gICAgICAgICAgdmFyIGR5ID0gcDFbMV0gLSBwMFsxXTtcbiAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIoZHgsIGR5KSAqIDE4MCAvIE1hdGguUEk7IC8vIFRoZSBhbmdsZSBzaG91bGQgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLlxuXG4gICAgICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgYW5nbGUgKz0gMzYwO1xuICAgICAgICAgIH0gLy8gVmVyeSBzbWFsbCBhbmdsZXMgcHJvZHVjZSBhbiB1bmV4cGVjdGVkIHJlc3VsdCBiZWNhdXNlIHRoZXkgYXJlXG4gICAgICAgICAgLy8gY29udmVydGVkIHRvIGEgc2NpZW50aWZpYyBub3RhdGlvbiBzdHJpbmcuXG5cblxuICAgICAgICAgIGlmIChhbmdsZSA8IDFlLTYpIHtcbiAgICAgICAgICAgIGFuZ2xlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ3JhZGllbnRUeXBlID0gJ2dyYWRpZW50cmFkaWFsJztcbiAgICAgICAgICB2YXIgcDAgPSBbZmlsbC54ICogcmVjdFdpZHRoLCBmaWxsLnkgKiByZWN0SGVpZ2h0XTtcbiAgICAgICAgICB2YXIgdHJhbnNmb3JtID0genJFbC50cmFuc2Zvcm07XG4gICAgICAgICAgdmFyIHNjYWxlID0genJFbC5zY2FsZTtcbiAgICAgICAgICB2YXIgd2lkdGggPSByZWN0V2lkdGg7XG4gICAgICAgICAgdmFyIGhlaWdodCA9IHJlY3RIZWlnaHQ7XG4gICAgICAgICAgZm9jdXMgPSBbLy8gUGVyY2VudCBpbiBib3VuZGluZyByZWN0XG4gICAgICAgICAgKHAwWzBdIC0gcmVjdC54KSAvIHdpZHRoLCAocDBbMV0gLSByZWN0LnkpIC8gaGVpZ2h0XTtcblxuICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAwLCBwMCwgdHJhbnNmb3JtKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aWR0aCAvPSBzY2FsZVswXSAqIFo7XG4gICAgICAgICAgaGVpZ2h0IC89IHNjYWxlWzFdICogWjtcbiAgICAgICAgICB2YXIgZGltZW5zaW9uID0gbWF0aE1heCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICBzaGlmdCA9IDIgKiAwIC8gZGltZW5zaW9uO1xuICAgICAgICAgIGV4cGFuc2lvbiA9IDIgKiBmaWxsLnIgLyBkaW1lbnNpb24gLSBzaGlmdDtcbiAgICAgICAgfSAvLyBXZSBuZWVkIHRvIHNvcnQgdGhlIGNvbG9yIHN0b3BzIGluIGFzY2VuZGluZyBvcmRlciBieSBvZmZzZXQsXG4gICAgICAgIC8vIG90aGVyd2lzZSBJRSB3b24ndCBpbnRlcnByZXQgaXQgY29ycmVjdGx5LlxuXG5cbiAgICAgICAgdmFyIHN0b3BzID0gZmlsbC5jb2xvclN0b3BzLnNsaWNlKCk7XG4gICAgICAgIHN0b3BzLnNvcnQoZnVuY3Rpb24gKGNzMSwgY3MyKSB7XG4gICAgICAgICAgcmV0dXJuIGNzMS5vZmZzZXQgLSBjczIub2Zmc2V0O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHN0b3BzLmxlbmd0aDsgLy8gQ29sb3IgYW5kIGFscGhhIGxpc3Qgb2YgZmlyc3QgYW5kIGxhc3Qgc3RvcFxuXG4gICAgICAgIHZhciBjb2xvckFuZEFscGhhTGlzdCA9IFtdO1xuICAgICAgICB2YXIgY29sb3JzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBzdG9wID0gc3RvcHNbaV07XG4gICAgICAgICAgdmFyIGNvbG9yQW5kQWxwaGEgPSBnZXRDb2xvckFuZEFscGhhKHN0b3AuY29sb3IpO1xuICAgICAgICAgIGNvbG9ycy5wdXNoKHN0b3Aub2Zmc2V0ICogZXhwYW5zaW9uICsgc2hpZnQgKyAnICcgKyBjb2xvckFuZEFscGhhWzBdKTtcblxuICAgICAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGNvbG9yQW5kQWxwaGFMaXN0LnB1c2goY29sb3JBbmRBbHBoYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgdmFyIGNvbG9yMSA9IGNvbG9yQW5kQWxwaGFMaXN0WzBdWzBdO1xuICAgICAgICAgIHZhciBjb2xvcjIgPSBjb2xvckFuZEFscGhhTGlzdFsxXVswXTtcbiAgICAgICAgICB2YXIgb3BhY2l0eTEgPSBjb2xvckFuZEFscGhhTGlzdFswXVsxXSAqIHN0eWxlLm9wYWNpdHk7XG4gICAgICAgICAgdmFyIG9wYWNpdHkyID0gY29sb3JBbmRBbHBoYUxpc3RbMV1bMV0gKiBzdHlsZS5vcGFjaXR5O1xuICAgICAgICAgIGVsLnR5cGUgPSBncmFkaWVudFR5cGU7XG4gICAgICAgICAgZWwubWV0aG9kID0gJ25vbmUnO1xuICAgICAgICAgIGVsLmZvY3VzID0gJzEwMCUnO1xuICAgICAgICAgIGVsLmFuZ2xlID0gYW5nbGU7XG4gICAgICAgICAgZWwuY29sb3IgPSBjb2xvcjE7XG4gICAgICAgICAgZWwuY29sb3IyID0gY29sb3IyO1xuICAgICAgICAgIGVsLmNvbG9ycyA9IGNvbG9ycy5qb2luKCcsJyk7IC8vIFdoZW4gY29sb3JzIGF0dHJpYnV0ZSBpcyB1c2VkLCB0aGUgbWVhbmluZ3Mgb2Ygb3BhY2l0eSBhbmQgbzpvcGFjaXR5MlxuICAgICAgICAgIC8vIGFyZSByZXZlcnNlZC5cblxuICAgICAgICAgIGVsLm9wYWNpdHkgPSBvcGFjaXR5MjsgLy8gRklYTUUgZ19vXzpvcGFjaXR5ID9cblxuICAgICAgICAgIGVsLm9wYWNpdHkyID0gb3BhY2l0eTE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ3JhZGllbnRUeXBlID09PSAncmFkaWFsJykge1xuICAgICAgICAgIGVsLmZvY3VzcG9zaXRpb24gPSBmb2N1cy5qb2luKCcsJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZJWE1FIENoYW5nZSBmcm9tIEdyYWRpZW50IGZpbGwgdG8gY29sb3IgZmlsbFxuICAgICAgICBzZXRDb2xvckFuZE9wYWNpdHkoZWwsIGZpbGwsIHN0eWxlLm9wYWNpdHkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgdXBkYXRlU3Ryb2tlTm9kZSA9IGZ1bmN0aW9uIChlbCwgc3R5bGUpIHtcbiAgICAvLyBpZiAoc3R5bGUubGluZUpvaW4gIT0gbnVsbCkge1xuICAgIC8vICAgICBlbC5qb2luc3R5bGUgPSBzdHlsZS5saW5lSm9pbjtcbiAgICAvLyB9XG4gICAgLy8gaWYgKHN0eWxlLm1pdGVyTGltaXQgIT0gbnVsbCkge1xuICAgIC8vICAgICBlbC5taXRlcmxpbWl0ID0gc3R5bGUubWl0ZXJMaW1pdCAqIFo7XG4gICAgLy8gfVxuICAgIC8vIGlmIChzdHlsZS5saW5lQ2FwICE9IG51bGwpIHtcbiAgICAvLyAgICAgZWwuZW5kY2FwID0gc3R5bGUubGluZUNhcDtcbiAgICAvLyB9XG4gICAgaWYgKHN0eWxlLmxpbmVEYXNoICE9IG51bGwpIHtcbiAgICAgIGVsLmRhc2hzdHlsZSA9IHN0eWxlLmxpbmVEYXNoLmpvaW4oJyAnKTtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUuc3Ryb2tlICE9IG51bGwgJiYgIShzdHlsZS5zdHJva2UgaW5zdGFuY2VvZiBHcmFkaWVudCkpIHtcbiAgICAgIHNldENvbG9yQW5kT3BhY2l0eShlbCwgc3R5bGUuc3Ryb2tlLCBzdHlsZS5vcGFjaXR5KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHVwZGF0ZUZpbGxBbmRTdHJva2UgPSBmdW5jdGlvbiAodm1sRWwsIHR5cGUsIHN0eWxlLCB6ckVsKSB7XG4gICAgdmFyIGlzRmlsbCA9IHR5cGUgPT0gJ2ZpbGwnO1xuICAgIHZhciBlbCA9IHZtbEVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKHR5cGUpWzBdOyAvLyBTdHJva2UgbXVzdCBoYXZlIGxpbmVXaWR0aFxuXG4gICAgaWYgKHN0eWxlW3R5cGVdICE9IG51bGwgJiYgc3R5bGVbdHlwZV0gIT09ICdub25lJyAmJiAoaXNGaWxsIHx8ICFpc0ZpbGwgJiYgc3R5bGUubGluZVdpZHRoKSkge1xuICAgICAgdm1sRWxbaXNGaWxsID8gJ2ZpbGxlZCcgOiAnc3Ryb2tlZCddID0gJ3RydWUnOyAvLyBGSVhNRSBSZW1vdmUgYmVmb3JlIHVwZGF0aW5nLCBvciBzZXQgYGNvbG9yc2Agd2lsbCB0aHJvdyBlcnJvclxuXG4gICAgICBpZiAoc3R5bGVbdHlwZV0gaW5zdGFuY2VvZiBHcmFkaWVudCkge1xuICAgICAgICByZW1vdmUodm1sRWwsIGVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlbCkge1xuICAgICAgICBlbCA9IHZtbENvcmUuY3JlYXRlTm9kZSh0eXBlKTtcbiAgICAgIH1cblxuICAgICAgaXNGaWxsID8gdXBkYXRlRmlsbE5vZGUoZWwsIHN0eWxlLCB6ckVsKSA6IHVwZGF0ZVN0cm9rZU5vZGUoZWwsIHN0eWxlKTtcbiAgICAgIGFwcGVuZCh2bWxFbCwgZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bWxFbFtpc0ZpbGwgPyAnZmlsbGVkJyA6ICdzdHJva2VkJ10gPSAnZmFsc2UnO1xuICAgICAgcmVtb3ZlKHZtbEVsLCBlbCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBwb2ludHMgPSBbW10sIFtdLCBbXV07XG5cbiAgdmFyIHBhdGhEYXRhVG9TdHJpbmcgPSBmdW5jdGlvbiAocGF0aCwgbSkge1xuICAgIHZhciBNID0gQ01ELk07XG4gICAgdmFyIEMgPSBDTUQuQztcbiAgICB2YXIgTCA9IENNRC5MO1xuICAgIHZhciBBID0gQ01ELkE7XG4gICAgdmFyIFEgPSBDTUQuUTtcbiAgICB2YXIgc3RyID0gW107XG4gICAgdmFyIG5Qb2ludDtcbiAgICB2YXIgY21kU3RyO1xuICAgIHZhciBjbWQ7XG4gICAgdmFyIGk7XG4gICAgdmFyIHhpO1xuICAgIHZhciB5aTtcbiAgICB2YXIgZGF0YSA9IHBhdGguZGF0YTtcbiAgICB2YXIgZGF0YUxlbmd0aCA9IHBhdGgubGVuKCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDspIHtcbiAgICAgIGNtZCA9IGRhdGFbaSsrXTtcbiAgICAgIGNtZFN0ciA9ICcnO1xuICAgICAgblBvaW50ID0gMDtcblxuICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgY2FzZSBNOlxuICAgICAgICAgIGNtZFN0ciA9ICcgbSAnO1xuICAgICAgICAgIG5Qb2ludCA9IDE7XG4gICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgcG9pbnRzWzBdWzBdID0geGk7XG4gICAgICAgICAgcG9pbnRzWzBdWzFdID0geWk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBMOlxuICAgICAgICAgIGNtZFN0ciA9ICcgbCAnO1xuICAgICAgICAgIG5Qb2ludCA9IDE7XG4gICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgcG9pbnRzWzBdWzBdID0geGk7XG4gICAgICAgICAgcG9pbnRzWzBdWzFdID0geWk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBROlxuICAgICAgICBjYXNlIEM6XG4gICAgICAgICAgY21kU3RyID0gJyBjICc7XG4gICAgICAgICAgblBvaW50ID0gMztcbiAgICAgICAgICB2YXIgeDEgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHkxID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciB4MiA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgeTIgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHgzO1xuICAgICAgICAgIHZhciB5MztcblxuICAgICAgICAgIGlmIChjbWQgPT09IFEpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgcXVhZHJhdGljIHRvIGN1YmljIHVzaW5nIGRlZ3JlZSBlbGV2YXRpb25cbiAgICAgICAgICAgIHgzID0geDI7XG4gICAgICAgICAgICB5MyA9IHkyO1xuICAgICAgICAgICAgeDIgPSAoeDIgKyAyICogeDEpIC8gMztcbiAgICAgICAgICAgIHkyID0gKHkyICsgMiAqIHkxKSAvIDM7XG4gICAgICAgICAgICB4MSA9ICh4aSArIDIgKiB4MSkgLyAzO1xuICAgICAgICAgICAgeTEgPSAoeWkgKyAyICogeTEpIC8gMztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeDMgPSBkYXRhW2krK107XG4gICAgICAgICAgICB5MyA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb2ludHNbMF1bMF0gPSB4MTtcbiAgICAgICAgICBwb2ludHNbMF1bMV0gPSB5MTtcbiAgICAgICAgICBwb2ludHNbMV1bMF0gPSB4MjtcbiAgICAgICAgICBwb2ludHNbMV1bMV0gPSB5MjtcbiAgICAgICAgICBwb2ludHNbMl1bMF0gPSB4MztcbiAgICAgICAgICBwb2ludHNbMl1bMV0gPSB5MztcbiAgICAgICAgICB4aSA9IHgzO1xuICAgICAgICAgIHlpID0geTM7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBBOlxuICAgICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgICB2YXIgeSA9IDA7XG4gICAgICAgICAgdmFyIHN4ID0gMTtcbiAgICAgICAgICB2YXIgc3kgPSAxO1xuICAgICAgICAgIHZhciBhbmdsZSA9IDA7XG5cbiAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgLy8gRXh0cmFjdCBTUlQgZnJvbSBtYXRyaXhcbiAgICAgICAgICAgIHggPSBtWzRdO1xuICAgICAgICAgICAgeSA9IG1bNV07XG4gICAgICAgICAgICBzeCA9IHNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gICAgICAgICAgICBzeSA9IHNxcnQobVsyXSAqIG1bMl0gKyBtWzNdICogbVszXSk7XG4gICAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIoLW1bMV0gLyBzeSwgbVswXSAvIHN4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY3ggPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciByeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgcnkgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBkYXRhW2krK10gKyBhbmdsZTtcbiAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBkYXRhW2krK10gKyBzdGFydEFuZ2xlICsgYW5nbGU7IC8vIEZJWE1FXG4gICAgICAgICAgLy8gdmFyIHBzaSA9IGRhdGFbaSsrXTtcblxuICAgICAgICAgIGkrKztcbiAgICAgICAgICB2YXIgY2xvY2t3aXNlID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciB4MCA9IGN4ICsgY29zKHN0YXJ0QW5nbGUpICogcng7XG4gICAgICAgICAgdmFyIHkwID0gY3kgKyBzaW4oc3RhcnRBbmdsZSkgKiByeTtcbiAgICAgICAgICB2YXIgeDEgPSBjeCArIGNvcyhlbmRBbmdsZSkgKiByeDtcbiAgICAgICAgICB2YXIgeTEgPSBjeSArIHNpbihlbmRBbmdsZSkgKiByeTtcbiAgICAgICAgICB2YXIgdHlwZSA9IGNsb2Nrd2lzZSA/ICcgd2EgJyA6ICcgYXQgJztcblxuICAgICAgICAgIGlmIChNYXRoLmFicyh4MCAtIHgxKSA8IDFlLTQpIHtcbiAgICAgICAgICAgIC8vIElFIHdvbid0IHJlbmRlciBhcmNoZXMgZHJhd24gY291bnRlciBjbG9ja3dpc2UgaWYgeDAgPT0geDEuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSA+IDFlLTIpIHtcbiAgICAgICAgICAgICAgLy8gT2Zmc2V0IHgwIGJ5IDEvODAgb2YgYSBwaXhlbC4gVXNlIHNvbWV0aGluZ1xuICAgICAgICAgICAgICAvLyB0aGF0IGNhbiBiZSByZXByZXNlbnRlZCBpbiBiaW5hcnlcbiAgICAgICAgICAgICAgaWYgKGNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgICAgIHgwICs9IDI3MCAvIFo7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEF2b2lkIGNhc2UgZHJhdyBmdWxsIGNpcmNsZVxuICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoeTAgLSBjeSkgPCAxZS00KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsb2Nrd2lzZSAmJiB4MCA8IGN4IHx8ICFjbG9ja3dpc2UgJiYgeDAgPiBjeCkge1xuICAgICAgICAgICAgICAgICAgeTEgLT0gMjcwIC8gWjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgeTEgKz0gMjcwIC8gWjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xvY2t3aXNlICYmIHkwIDwgY3kgfHwgIWNsb2Nrd2lzZSAmJiB5MCA+IGN5KSB7XG4gICAgICAgICAgICAgICAgeDEgKz0gMjcwIC8gWjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4MSAtPSAyNzAgLyBaO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RyLnB1c2godHlwZSwgcm91bmQoKChjeCAtIHJ4KSAqIHN4ICsgeCkgKiBaIC0gWjIpLCBjb21tYSwgcm91bmQoKChjeSAtIHJ5KSAqIHN5ICsgeSkgKiBaIC0gWjIpLCBjb21tYSwgcm91bmQoKChjeCArIHJ4KSAqIHN4ICsgeCkgKiBaIC0gWjIpLCBjb21tYSwgcm91bmQoKChjeSArIHJ5KSAqIHN5ICsgeSkgKiBaIC0gWjIpLCBjb21tYSwgcm91bmQoKHgwICogc3ggKyB4KSAqIFogLSBaMiksIGNvbW1hLCByb3VuZCgoeTAgKiBzeSArIHkpICogWiAtIFoyKSwgY29tbWEsIHJvdW5kKCh4MSAqIHN4ICsgeCkgKiBaIC0gWjIpLCBjb21tYSwgcm91bmQoKHkxICogc3kgKyB5KSAqIFogLSBaMikpO1xuICAgICAgICAgIHhpID0geDE7XG4gICAgICAgICAgeWkgPSB5MTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5SOlxuICAgICAgICAgIHZhciBwMCA9IHBvaW50c1swXTtcbiAgICAgICAgICB2YXIgcDEgPSBwb2ludHNbMV07IC8vIHgwLCB5MFxuXG4gICAgICAgICAgcDBbMF0gPSBkYXRhW2krK107XG4gICAgICAgICAgcDBbMV0gPSBkYXRhW2krK107IC8vIHgxLCB5MVxuXG4gICAgICAgICAgcDFbMF0gPSBwMFswXSArIGRhdGFbaSsrXTtcbiAgICAgICAgICBwMVsxXSA9IHAwWzFdICsgZGF0YVtpKytdO1xuXG4gICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAwLCBwMCwgbSk7XG4gICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMSwgcDEsIG0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHAwWzBdID0gcm91bmQocDBbMF0gKiBaIC0gWjIpO1xuICAgICAgICAgIHAxWzBdID0gcm91bmQocDFbMF0gKiBaIC0gWjIpO1xuICAgICAgICAgIHAwWzFdID0gcm91bmQocDBbMV0gKiBaIC0gWjIpO1xuICAgICAgICAgIHAxWzFdID0gcm91bmQocDFbMV0gKiBaIC0gWjIpO1xuICAgICAgICAgIHN0ci5wdXNoKCAvLyB4MCwgeTBcbiAgICAgICAgICAnIG0gJywgcDBbMF0sIGNvbW1hLCBwMFsxXSwgLy8geDEsIHkwXG4gICAgICAgICAgJyBsICcsIHAxWzBdLCBjb21tYSwgcDBbMV0sIC8vIHgxLCB5MVxuICAgICAgICAgICcgbCAnLCBwMVswXSwgY29tbWEsIHAxWzFdLCAvLyB4MCwgeTFcbiAgICAgICAgICAnIGwgJywgcDBbMF0sIGNvbW1hLCBwMVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICAvLyBGSVhNRSBVcGRhdGUgeGksIHlpXG4gICAgICAgICAgc3RyLnB1c2goJyB4ICcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoblBvaW50ID4gMCkge1xuICAgICAgICBzdHIucHVzaChjbWRTdHIpO1xuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgblBvaW50OyBrKyspIHtcbiAgICAgICAgICB2YXIgcCA9IHBvaW50c1trXTtcbiAgICAgICAgICBtICYmIGFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pOyAvLyDkuI0gcm91bmQg5Lya6Z2e5bi45oWiXG5cbiAgICAgICAgICBzdHIucHVzaChyb3VuZChwWzBdICogWiAtIFoyKSwgY29tbWEsIHJvdW5kKHBbMV0gKiBaIC0gWjIpLCBrIDwgblBvaW50IC0gMSA/IGNvbW1hIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ci5qb2luKCcnKTtcbiAgfTsgLy8gUmV3cml0ZSB0aGUgb3JpZ2luYWwgcGF0aCBtZXRob2RcblxuXG4gIFBhdGgucHJvdG90eXBlLmJydXNoVk1MID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHZhciB2bWxFbCA9IHRoaXMuX3ZtbEVsO1xuXG4gICAgaWYgKCF2bWxFbCkge1xuICAgICAgdm1sRWwgPSB2bWxDb3JlLmNyZWF0ZU5vZGUoJ3NoYXBlJyk7XG4gICAgICBpbml0Um9vdEVsU3R5bGUodm1sRWwpO1xuICAgICAgdGhpcy5fdm1sRWwgPSB2bWxFbDtcbiAgICB9XG5cbiAgICB1cGRhdGVGaWxsQW5kU3Ryb2tlKHZtbEVsLCAnZmlsbCcsIHN0eWxlLCB0aGlzKTtcbiAgICB1cGRhdGVGaWxsQW5kU3Ryb2tlKHZtbEVsLCAnc3Ryb2tlJywgc3R5bGUsIHRoaXMpO1xuICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgdmFyIG5lZWRUcmFuc2Zvcm0gPSBtICE9IG51bGw7XG4gICAgdmFyIHN0cm9rZUVsID0gdm1sRWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N0cm9rZScpWzBdO1xuXG4gICAgaWYgKHN0cm9rZUVsKSB7XG4gICAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoOyAvLyBHZXQgdGhlIGxpbmUgc2NhbGUuXG4gICAgICAvLyBEZXRlcm1pbmFudCBvZiB0aGlzLm1fIG1lYW5zIGhvdyBtdWNoIHRoZSBhcmVhIGlzIGVubGFyZ2VkIGJ5IHRoZVxuICAgICAgLy8gdHJhbnNmb3JtYXRpb24uIFNvIGl0cyBzcXVhcmUgcm9vdCBjYW4gYmUgdXNlZCBhcyBhIHNjYWxlIGZhY3RvclxuICAgICAgLy8gZm9yIHdpZHRoLlxuXG4gICAgICBpZiAobmVlZFRyYW5zZm9ybSAmJiAhc3R5bGUuc3Ryb2tlTm9TY2FsZSkge1xuICAgICAgICB2YXIgZGV0ID0gbVswXSAqIG1bM10gLSBtWzFdICogbVsyXTtcbiAgICAgICAgbGluZVdpZHRoICo9IHNxcnQoYWJzKGRldCkpO1xuICAgICAgfVxuXG4gICAgICBzdHJva2VFbC53ZWlnaHQgPSBsaW5lV2lkdGggKyAncHgnO1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gdGhpcy5wYXRoIHx8ICh0aGlzLnBhdGggPSBuZXcgUGF0aFByb3h5KCkpO1xuXG4gICAgaWYgKHRoaXMuX19kaXJ0eVBhdGgpIHtcbiAgICAgIHBhdGguYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLmJ1aWxkUGF0aChwYXRoLCB0aGlzLnNoYXBlKTtcbiAgICAgIHBhdGgudG9TdGF0aWMoKTtcbiAgICAgIHRoaXMuX19kaXJ0eVBhdGggPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2bWxFbC5wYXRoID0gcGF0aERhdGFUb1N0cmluZyhwYXRoLCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgdm1sRWwuc3R5bGUuekluZGV4ID0gZ2V0WkluZGV4KHRoaXMuemxldmVsLCB0aGlzLnosIHRoaXMuejIpOyAvLyBBcHBlbmQgdG8gcm9vdFxuXG4gICAgYXBwZW5kKHZtbFJvb3QsIHZtbEVsKTsgLy8gVGV4dFxuXG4gICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5kcmF3UmVjdFRleHQodm1sUm9vdCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gICAgfVxuICB9O1xuXG4gIFBhdGgucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICByZW1vdmUodm1sUm9vdCwgdGhpcy5fdm1sRWwpO1xuICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gIH07XG5cbiAgUGF0aC5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIGFwcGVuZCh2bWxSb290LCB0aGlzLl92bWxFbCk7XG4gICAgdGhpcy5hcHBlbmRSZWN0VGV4dCh2bWxSb290KTtcbiAgfTtcbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBJTUFHRVxuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICB2YXIgaXNJbWFnZSA9IGZ1bmN0aW9uIChpbWcpIHtcbiAgICAvLyBGSVhNRSBpbWcgaW5zdGFuY2VvZiBJbWFnZSDlpoLmnpwgaW1nIOaYr+S4gOS4quWtl+espuS4sueahOaXtuWAme+8jElFOCDkuIvkvJrmiqXplJlcbiAgICByZXR1cm4gdHlwZW9mIGltZyA9PT0gJ29iamVjdCcgJiYgaW1nLnRhZ05hbWUgJiYgaW1nLnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0lNRyc7IC8vIHJldHVybiBpbWcgaW5zdGFuY2VvZiBJbWFnZTtcbiAgfTsgLy8gUmV3cml0ZSB0aGUgb3JpZ2luYWwgcGF0aCBtZXRob2RcblxuXG4gIFpJbWFnZS5wcm90b3R5cGUuYnJ1c2hWTUwgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgdmFyIGltYWdlID0gc3R5bGUuaW1hZ2U7IC8vIEltYWdlIG9yaWdpbmFsIHdpZHRoLCBoZWlnaHRcblxuICAgIHZhciBvdztcbiAgICB2YXIgb2g7XG5cbiAgICBpZiAoaXNJbWFnZShpbWFnZSkpIHtcbiAgICAgIHZhciBzcmMgPSBpbWFnZS5zcmM7XG5cbiAgICAgIGlmIChzcmMgPT09IHRoaXMuX2ltYWdlU3JjKSB7XG4gICAgICAgIG93ID0gdGhpcy5faW1hZ2VXaWR0aDtcbiAgICAgICAgb2ggPSB0aGlzLl9pbWFnZUhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpbWFnZVJ1bnRpbWVTdHlsZSA9IGltYWdlLnJ1bnRpbWVTdHlsZTtcbiAgICAgICAgdmFyIG9sZFJ1bnRpbWVXaWR0aCA9IGltYWdlUnVudGltZVN0eWxlLndpZHRoO1xuICAgICAgICB2YXIgb2xkUnVudGltZUhlaWdodCA9IGltYWdlUnVudGltZVN0eWxlLmhlaWdodDtcbiAgICAgICAgaW1hZ2VSdW50aW1lU3R5bGUud2lkdGggPSAnYXV0byc7XG4gICAgICAgIGltYWdlUnVudGltZVN0eWxlLmhlaWdodCA9ICdhdXRvJzsgLy8gZ2V0IHRoZSBvcmlnaW5hbCBzaXplXG5cbiAgICAgICAgb3cgPSBpbWFnZS53aWR0aDtcbiAgICAgICAgb2ggPSBpbWFnZS5oZWlnaHQ7IC8vIGFuZCByZW1vdmUgb3ZlcmlkZXNcblxuICAgICAgICBpbWFnZVJ1bnRpbWVTdHlsZS53aWR0aCA9IG9sZFJ1bnRpbWVXaWR0aDtcbiAgICAgICAgaW1hZ2VSdW50aW1lU3R5bGUuaGVpZ2h0ID0gb2xkUnVudGltZUhlaWdodDsgLy8gQ2FjaGluZyBpbWFnZSBvcmlnaW5hbCB3aWR0aCwgaGVpZ2h0IGFuZCBzcmNcblxuICAgICAgICB0aGlzLl9pbWFnZVNyYyA9IHNyYztcbiAgICAgICAgdGhpcy5faW1hZ2VXaWR0aCA9IG93O1xuICAgICAgICB0aGlzLl9pbWFnZUhlaWdodCA9IG9oO1xuICAgICAgfVxuXG4gICAgICBpbWFnZSA9IHNyYztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGltYWdlID09PSB0aGlzLl9pbWFnZVNyYykge1xuICAgICAgICBvdyA9IHRoaXMuX2ltYWdlV2lkdGg7XG4gICAgICAgIG9oID0gdGhpcy5faW1hZ2VIZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpbWFnZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB4ID0gc3R5bGUueCB8fCAwO1xuICAgIHZhciB5ID0gc3R5bGUueSB8fCAwO1xuICAgIHZhciBkdyA9IHN0eWxlLndpZHRoO1xuICAgIHZhciBkaCA9IHN0eWxlLmhlaWdodDtcbiAgICB2YXIgc3cgPSBzdHlsZS5zV2lkdGg7XG4gICAgdmFyIHNoID0gc3R5bGUuc0hlaWdodDtcbiAgICB2YXIgc3ggPSBzdHlsZS5zeCB8fCAwO1xuICAgIHZhciBzeSA9IHN0eWxlLnN5IHx8IDA7XG4gICAgdmFyIGhhc0Nyb3AgPSBzdyAmJiBzaDtcbiAgICB2YXIgdm1sRWwgPSB0aGlzLl92bWxFbDtcblxuICAgIGlmICghdm1sRWwpIHtcbiAgICAgIC8vIEZJWE1FIOS9v+eUqCBncm91cCDlnKggbGVmdCwgdG9wIOmDveS4jeaYryAwIOeahOaXtuWAmeWwseaXoOazleaYvuekuuS6huOAglxuICAgICAgLy8gdm1sRWwgPSB2bWxDb3JlLmNyZWF0ZU5vZGUoJ2dyb3VwJyk7XG4gICAgICB2bWxFbCA9IHZtbENvcmUuZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgaW5pdFJvb3RFbFN0eWxlKHZtbEVsKTtcbiAgICAgIHRoaXMuX3ZtbEVsID0gdm1sRWw7XG4gICAgfVxuXG4gICAgdmFyIHZtbEVsU3R5bGUgPSB2bWxFbC5zdHlsZTtcbiAgICB2YXIgaGFzUm90YXRpb24gPSBmYWxzZTtcbiAgICB2YXIgbTtcbiAgICB2YXIgc2NhbGVYID0gMTtcbiAgICB2YXIgc2NhbGVZID0gMTtcblxuICAgIGlmICh0aGlzLnRyYW5zZm9ybSkge1xuICAgICAgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgc2NhbGVYID0gc3FydChtWzBdICogbVswXSArIG1bMV0gKiBtWzFdKTtcbiAgICAgIHNjYWxlWSA9IHNxcnQobVsyXSAqIG1bMl0gKyBtWzNdICogbVszXSk7XG4gICAgICBoYXNSb3RhdGlvbiA9IG1bMV0gfHwgbVsyXTtcbiAgICB9XG5cbiAgICBpZiAoaGFzUm90YXRpb24pIHtcbiAgICAgIC8vIElmIGZpbHRlcnMgYXJlIG5lY2Vzc2FyeSAocm90YXRpb24gZXhpc3RzKSwgY3JlYXRlIHRoZW1cbiAgICAgIC8vIGZpbHRlcnMgYXJlIGJvZy1zbG93LCBzbyBvbmx5IGNyZWF0ZSB0aGVtIGlmIGFiYnNvbHV0ZWx5IG5lY2Vzc2FyeVxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBjaGVjayBkb2Vzbid0IGFjY291bnQgZm9yIHNrZXdzICh3aGljaCBkb24ndCBleGlzdFxuICAgICAgLy8gaW4gdGhlIGNhbnZhcyBzcGVjICh5ZXQpIGFueXdheS5cbiAgICAgIC8vIEZyb20gZXhjYW52YXNcbiAgICAgIHZhciBwMCA9IFt4LCB5XTtcbiAgICAgIHZhciBwMSA9IFt4ICsgZHcsIHldO1xuICAgICAgdmFyIHAyID0gW3gsIHkgKyBkaF07XG4gICAgICB2YXIgcDMgPSBbeCArIGR3LCB5ICsgZGhdO1xuICAgICAgYXBwbHlUcmFuc2Zvcm0ocDAsIHAwLCBtKTtcbiAgICAgIGFwcGx5VHJhbnNmb3JtKHAxLCBwMSwgbSk7XG4gICAgICBhcHBseVRyYW5zZm9ybShwMiwgcDIsIG0pO1xuICAgICAgYXBwbHlUcmFuc2Zvcm0ocDMsIHAzLCBtKTtcbiAgICAgIHZhciBtYXhYID0gbWF0aE1heChwMFswXSwgcDFbMF0sIHAyWzBdLCBwM1swXSk7XG4gICAgICB2YXIgbWF4WSA9IG1hdGhNYXgocDBbMV0sIHAxWzFdLCBwMlsxXSwgcDNbMV0pO1xuICAgICAgdmFyIHRyYW5zZm9ybUZpbHRlciA9IFtdO1xuICAgICAgdHJhbnNmb3JtRmlsdGVyLnB1c2goJ00xMT0nLCBtWzBdIC8gc2NhbGVYLCBjb21tYSwgJ00xMj0nLCBtWzJdIC8gc2NhbGVZLCBjb21tYSwgJ00yMT0nLCBtWzFdIC8gc2NhbGVYLCBjb21tYSwgJ00yMj0nLCBtWzNdIC8gc2NhbGVZLCBjb21tYSwgJ0R4PScsIHJvdW5kKHggKiBzY2FsZVggKyBtWzRdKSwgY29tbWEsICdEeT0nLCByb3VuZCh5ICogc2NhbGVZICsgbVs1XSkpO1xuICAgICAgdm1sRWxTdHlsZS5wYWRkaW5nID0gJzAgJyArIHJvdW5kKG1heFgpICsgJ3B4ICcgKyByb3VuZChtYXhZKSArICdweCAwJzsgLy8gRklYTUUgRFhJbWFnZVRyYW5zZm9ybSDlnKggSUUxMSDnmoTlhbzlrrnmqKHlvI/kuIvkuI3otbfkvZznlKhcblxuICAgICAgdm1sRWxTdHlsZS5maWx0ZXIgPSBpbWFnZVRyYW5zZm9ybVByZWZpeCArICcuTWF0cml4KCcgKyB0cmFuc2Zvcm1GaWx0ZXIuam9pbignJykgKyAnLCBTaXppbmdNZXRob2Q9Y2xpcCknO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobSkge1xuICAgICAgICB4ID0geCAqIHNjYWxlWCArIG1bNF07XG4gICAgICAgIHkgPSB5ICogc2NhbGVZICsgbVs1XTtcbiAgICAgIH1cblxuICAgICAgdm1sRWxTdHlsZS5maWx0ZXIgPSAnJztcbiAgICAgIHZtbEVsU3R5bGUubGVmdCA9IHJvdW5kKHgpICsgJ3B4JztcbiAgICAgIHZtbEVsU3R5bGUudG9wID0gcm91bmQoeSkgKyAncHgnO1xuICAgIH1cblxuICAgIHZhciBpbWFnZUVsID0gdGhpcy5faW1hZ2VFbDtcbiAgICB2YXIgY3JvcEVsID0gdGhpcy5fY3JvcEVsO1xuXG4gICAgaWYgKCFpbWFnZUVsKSB7XG4gICAgICBpbWFnZUVsID0gdm1sQ29yZS5kb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLl9pbWFnZUVsID0gaW1hZ2VFbDtcbiAgICB9XG5cbiAgICB2YXIgaW1hZ2VFTFN0eWxlID0gaW1hZ2VFbC5zdHlsZTtcblxuICAgIGlmIChoYXNDcm9wKSB7XG4gICAgICAvLyBOZWVkcyBrbm93IGltYWdlIG9yaWdpbmFsIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgIGlmICghKG93ICYmIG9oKSkge1xuICAgICAgICB2YXIgdG1wSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHRtcEltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0bXBJbWFnZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgIG93ID0gdG1wSW1hZ2Uud2lkdGg7XG4gICAgICAgICAgb2ggPSB0bXBJbWFnZS5oZWlnaHQ7IC8vIEFkanVzdCBpbWFnZSB3aWR0aCBhbmQgaGVpZ2h0IHRvIGZpdCB0aGUgcmF0aW8gZGVzdGluYXRpb25TaXplIC8gc291cmNlU2l6ZVxuXG4gICAgICAgICAgaW1hZ2VFTFN0eWxlLndpZHRoID0gcm91bmQoc2NhbGVYICogb3cgKiBkdyAvIHN3KSArICdweCc7XG4gICAgICAgICAgaW1hZ2VFTFN0eWxlLmhlaWdodCA9IHJvdW5kKHNjYWxlWSAqIG9oICogZGggLyBzaCkgKyAncHgnOyAvLyBDYWNoaW5nIGltYWdlIG9yaWdpbmFsIHdpZHRoLCBoZWlnaHQgYW5kIHNyY1xuXG4gICAgICAgICAgc2VsZi5faW1hZ2VXaWR0aCA9IG93O1xuICAgICAgICAgIHNlbGYuX2ltYWdlSGVpZ2h0ID0gb2g7XG4gICAgICAgICAgc2VsZi5faW1hZ2VTcmMgPSBpbWFnZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0bXBJbWFnZS5zcmMgPSBpbWFnZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltYWdlRUxTdHlsZS53aWR0aCA9IHJvdW5kKHNjYWxlWCAqIG93ICogZHcgLyBzdykgKyAncHgnO1xuICAgICAgICBpbWFnZUVMU3R5bGUuaGVpZ2h0ID0gcm91bmQoc2NhbGVZICogb2ggKiBkaCAvIHNoKSArICdweCc7XG4gICAgICB9XG5cbiAgICAgIGlmICghY3JvcEVsKSB7XG4gICAgICAgIGNyb3BFbCA9IHZtbENvcmUuZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjcm9wRWwuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgdGhpcy5fY3JvcEVsID0gY3JvcEVsO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3JvcEVsU3R5bGUgPSBjcm9wRWwuc3R5bGU7XG4gICAgICBjcm9wRWxTdHlsZS53aWR0aCA9IHJvdW5kKChkdyArIHN4ICogZHcgLyBzdykgKiBzY2FsZVgpO1xuICAgICAgY3JvcEVsU3R5bGUuaGVpZ2h0ID0gcm91bmQoKGRoICsgc3kgKiBkaCAvIHNoKSAqIHNjYWxlWSk7XG4gICAgICBjcm9wRWxTdHlsZS5maWx0ZXIgPSBpbWFnZVRyYW5zZm9ybVByZWZpeCArICcuTWF0cml4KER4PScgKyAtc3ggKiBkdyAvIHN3ICogc2NhbGVYICsgJyxEeT0nICsgLXN5ICogZGggLyBzaCAqIHNjYWxlWSArICcpJztcblxuICAgICAgaWYgKCFjcm9wRWwucGFyZW50Tm9kZSkge1xuICAgICAgICB2bWxFbC5hcHBlbmRDaGlsZChjcm9wRWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW1hZ2VFbC5wYXJlbnROb2RlICE9IGNyb3BFbCkge1xuICAgICAgICBjcm9wRWwuYXBwZW5kQ2hpbGQoaW1hZ2VFbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGltYWdlRUxTdHlsZS53aWR0aCA9IHJvdW5kKHNjYWxlWCAqIGR3KSArICdweCc7XG4gICAgICBpbWFnZUVMU3R5bGUuaGVpZ2h0ID0gcm91bmQoc2NhbGVZICogZGgpICsgJ3B4JztcbiAgICAgIHZtbEVsLmFwcGVuZENoaWxkKGltYWdlRWwpO1xuXG4gICAgICBpZiAoY3JvcEVsICYmIGNyb3BFbC5wYXJlbnROb2RlKSB7XG4gICAgICAgIHZtbEVsLnJlbW92ZUNoaWxkKGNyb3BFbCk7XG4gICAgICAgIHRoaXMuX2Nyb3BFbCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZpbHRlclN0ciA9ICcnO1xuICAgIHZhciBhbHBoYSA9IHN0eWxlLm9wYWNpdHk7XG5cbiAgICBpZiAoYWxwaGEgPCAxKSB7XG4gICAgICBmaWx0ZXJTdHIgKz0gJy5BbHBoYShvcGFjaXR5PScgKyByb3VuZChhbHBoYSAqIDEwMCkgKyAnKSAnO1xuICAgIH1cblxuICAgIGZpbHRlclN0ciArPSBpbWFnZVRyYW5zZm9ybVByZWZpeCArICcuQWxwaGFJbWFnZUxvYWRlcihzcmM9JyArIGltYWdlICsgJywgU2l6aW5nTWV0aG9kPXNjYWxlKSc7XG4gICAgaW1hZ2VFTFN0eWxlLmZpbHRlciA9IGZpbHRlclN0cjtcbiAgICB2bWxFbC5zdHlsZS56SW5kZXggPSBnZXRaSW5kZXgodGhpcy56bGV2ZWwsIHRoaXMueiwgdGhpcy56Mik7IC8vIEFwcGVuZCB0byByb290XG5cbiAgICBhcHBlbmQodm1sUm9vdCwgdm1sRWwpOyAvLyBUZXh0XG5cbiAgICBpZiAoc3R5bGUudGV4dCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmRyYXdSZWN0VGV4dCh2bWxSb290LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICB9XG4gIH07XG5cbiAgWkltYWdlLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgcmVtb3ZlKHZtbFJvb3QsIHRoaXMuX3ZtbEVsKTtcbiAgICB0aGlzLl92bWxFbCA9IG51bGw7XG4gICAgdGhpcy5fY3JvcEVsID0gbnVsbDtcbiAgICB0aGlzLl9pbWFnZUVsID0gbnVsbDtcbiAgICB0aGlzLnJlbW92ZVJlY3RUZXh0KHZtbFJvb3QpO1xuICB9O1xuXG4gIFpJbWFnZS5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIGFwcGVuZCh2bWxSb290LCB0aGlzLl92bWxFbCk7XG4gICAgdGhpcy5hcHBlbmRSZWN0VGV4dCh2bWxSb290KTtcbiAgfTtcbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBURVhUXG4gICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gIHZhciBERUZBVUxUX1NUWUxFX05PUk1BTCA9ICdub3JtYWwnO1xuICB2YXIgZm9udFN0eWxlQ2FjaGUgPSB7fTtcbiAgdmFyIGZvbnRTdHlsZUNhY2hlQ291bnQgPSAwO1xuICB2YXIgTUFYX0ZPTlRfQ0FDSEVfU0laRSA9IDEwMDtcbiAgdmFyIGZvbnRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gIHZhciBnZXRGb250U3R5bGUgPSBmdW5jdGlvbiAoZm9udFN0cmluZykge1xuICAgIHZhciBmb250U3R5bGUgPSBmb250U3R5bGVDYWNoZVtmb250U3RyaW5nXTtcblxuICAgIGlmICghZm9udFN0eWxlKSB7XG4gICAgICAvLyBDbGVhciBjYWNoZVxuICAgICAgaWYgKGZvbnRTdHlsZUNhY2hlQ291bnQgPiBNQVhfRk9OVF9DQUNIRV9TSVpFKSB7XG4gICAgICAgIGZvbnRTdHlsZUNhY2hlQ291bnQgPSAwO1xuICAgICAgICBmb250U3R5bGVDYWNoZSA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgc3R5bGUgPSBmb250RWwuc3R5bGU7XG4gICAgICB2YXIgZm9udEZhbWlseTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgc3R5bGUuZm9udCA9IGZvbnRTdHJpbmc7XG4gICAgICAgIGZvbnRGYW1pbHkgPSBzdHlsZS5mb250RmFtaWx5LnNwbGl0KCcsJylbMF07XG4gICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICBmb250U3R5bGUgPSB7XG4gICAgICAgIHN0eWxlOiBzdHlsZS5mb250U3R5bGUgfHwgREVGQVVMVF9TVFlMRV9OT1JNQUwsXG4gICAgICAgIHZhcmlhbnQ6IHN0eWxlLmZvbnRWYXJpYW50IHx8IERFRkFVTFRfU1RZTEVfTk9STUFMLFxuICAgICAgICB3ZWlnaHQ6IHN0eWxlLmZvbnRXZWlnaHQgfHwgREVGQVVMVF9TVFlMRV9OT1JNQUwsXG4gICAgICAgIHNpemU6IHBhcnNlRmxvYXQoc3R5bGUuZm9udFNpemUgfHwgMTIpIHwgMCxcbiAgICAgICAgZmFtaWx5OiBmb250RmFtaWx5IHx8ICdNaWNyb3NvZnQgWWFIZWknXG4gICAgICB9O1xuICAgICAgZm9udFN0eWxlQ2FjaGVbZm9udFN0cmluZ10gPSBmb250U3R5bGU7XG4gICAgICBmb250U3R5bGVDYWNoZUNvdW50Kys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvbnRTdHlsZTtcbiAgfTtcblxuICB2YXIgdGV4dE1lYXN1cmVFbDsgLy8gT3ZlcndyaXRlIG1lYXN1cmUgdGV4dCBtZXRob2RcblxuICB0ZXh0Q29udGFpbi4kb3ZlcnJpZGUoJ21lYXN1cmVUZXh0JywgZnVuY3Rpb24gKHRleHQsIHRleHRGb250KSB7XG4gICAgdmFyIGRvYyA9IHZtbENvcmUuZG9jO1xuXG4gICAgaWYgKCF0ZXh0TWVhc3VyZUVsKSB7XG4gICAgICB0ZXh0TWVhc3VyZUVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGV4dE1lYXN1cmVFbC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO3RvcDotMjAwMDBweDtsZWZ0OjA7JyArICdwYWRkaW5nOjA7bWFyZ2luOjA7Ym9yZGVyOm5vbmU7d2hpdGUtc3BhY2U6cHJlOyc7XG4gICAgICB2bWxDb3JlLmRvYy5ib2R5LmFwcGVuZENoaWxkKHRleHRNZWFzdXJlRWwpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0ZXh0TWVhc3VyZUVsLnN0eWxlLmZvbnQgPSB0ZXh0Rm9udDtcbiAgICB9IGNhdGNoIChleCkgey8vIElnbm9yZSBmYWlsdXJlcyB0byBzZXQgdG8gaW52YWxpZCBmb250LlxuICAgIH1cblxuICAgIHRleHRNZWFzdXJlRWwuaW5uZXJIVE1MID0gJyc7IC8vIERvbid0IHVzZSBpbm5lckhUTUwgb3IgaW5uZXJUZXh0IGJlY2F1c2UgdGhleSBhbGxvdyBtYXJrdXAvd2hpdGVzcGFjZS5cblxuICAgIHRleHRNZWFzdXJlRWwuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKHRleHQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHRleHRNZWFzdXJlRWwub2Zmc2V0V2lkdGhcbiAgICB9O1xuICB9KTtcbiAgdmFyIHRtcFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KCk7XG5cbiAgdmFyIGRyYXdSZWN0VGV4dCA9IGZ1bmN0aW9uICh2bWxSb290LCByZWN0LCB0ZXh0UmVjdCwgZnJvbVRleHRFbCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7IC8vIE9wdGltaXplLCBhdm9pZCBub3JtYWxpemUgZXZlcnkgdGltZS5cblxuICAgIHRoaXMuX19kaXJ0eSAmJiB0ZXh0SGVscGVyLm5vcm1hbGl6ZVRleHRTdHlsZShzdHlsZSwgdHJ1ZSk7XG4gICAgdmFyIHRleHQgPSBzdHlsZS50ZXh0OyAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuXG4gICAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcblxuICAgIGlmICghdGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ29udmVydCByaWNoIHRleHQgdG8gcGxhaW4gdGV4dC4gUmljaCB0ZXh0IGlzIG5vdCBzdXBwb3J0ZWQgaW5cbiAgICAvLyBJRTgtLCBidXQgdGFncyBpbiByaWNoIHRleHQgdGVtcGxhdGUgd2lsbCBiZSByZW1vdmVkLlxuXG5cbiAgICBpZiAoc3R5bGUucmljaCkge1xuICAgICAgdmFyIGNvbnRlbnRCbG9jayA9IHRleHRDb250YWluLnBhcnNlUmljaFRleHQodGV4dCwgc3R5bGUpO1xuICAgICAgdGV4dCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRCbG9jay5saW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdG9rZW5zID0gY29udGVudEJsb2NrLmxpbmVzW2ldLnRva2VucztcbiAgICAgICAgdmFyIHRleHRMaW5lID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0b2tlbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB0ZXh0TGluZS5wdXNoKHRva2Vuc1tqXS50ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRleHQucHVzaCh0ZXh0TGluZS5qb2luKCcnKSk7XG4gICAgICB9XG5cbiAgICAgIHRleHQgPSB0ZXh0LmpvaW4oJ1xcbicpO1xuICAgIH1cblxuICAgIHZhciB4O1xuICAgIHZhciB5O1xuICAgIHZhciBhbGlnbiA9IHN0eWxlLnRleHRBbGlnbjtcbiAgICB2YXIgdmVydGljYWxBbGlnbiA9IHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduO1xuICAgIHZhciBmb250U3R5bGUgPSBnZXRGb250U3R5bGUoc3R5bGUuZm9udCk7IC8vIEZJWE1FIGVuY29kZUh0bWxBdHRyaWJ1dGUgP1xuXG4gICAgdmFyIGZvbnQgPSBmb250U3R5bGUuc3R5bGUgKyAnICcgKyBmb250U3R5bGUudmFyaWFudCArICcgJyArIGZvbnRTdHlsZS53ZWlnaHQgKyAnICcgKyBmb250U3R5bGUuc2l6ZSArICdweCBcIicgKyBmb250U3R5bGUuZmFtaWx5ICsgJ1wiJztcbiAgICB0ZXh0UmVjdCA9IHRleHRSZWN0IHx8IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdCh0ZXh0LCBmb250LCBhbGlnbiwgdmVydGljYWxBbGlnbik7IC8vIFRyYW5zZm9ybSByZWN0IHRvIHZpZXcgc3BhY2VcblxuICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07IC8vIElnbm9yZSB0cmFuc2Zvcm0gZm9yIHRleHQgaW4gb3RoZXIgZWxlbWVudFxuXG4gICAgaWYgKG0gJiYgIWZyb21UZXh0RWwpIHtcbiAgICAgIHRtcFJlY3QuY29weShyZWN0KTtcbiAgICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0obSk7XG4gICAgICByZWN0ID0gdG1wUmVjdDtcbiAgICB9XG5cbiAgICBpZiAoIWZyb21UZXh0RWwpIHtcbiAgICAgIHZhciB0ZXh0UG9zaXRpb24gPSBzdHlsZS50ZXh0UG9zaXRpb247XG4gICAgICB2YXIgZGlzdGFuY2UgPSBzdHlsZS50ZXh0RGlzdGFuY2U7IC8vIFRleHQgcG9zaXRpb24gcmVwcmVzZW50ZWQgYnkgY29vcmRcblxuICAgICAgaWYgKHRleHRQb3NpdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHggPSByZWN0LnggKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzBdLCByZWN0LndpZHRoKTtcbiAgICAgICAgeSA9IHJlY3QueSArIHBhcnNlUGVyY2VudCh0ZXh0UG9zaXRpb25bMV0sIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgYWxpZ24gPSBhbGlnbiB8fCAnbGVmdCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0KHRleHRQb3NpdGlvbiwgcmVjdCwgZGlzdGFuY2UpO1xuICAgICAgICB4ID0gcmVzLng7XG4gICAgICAgIHkgPSByZXMueTsgLy8gRGVmYXVsdCBhbGlnbiBhbmQgYmFzZWxpbmUgd2hlbiBoYXMgdGV4dFBvc2l0aW9uXG5cbiAgICAgICAgYWxpZ24gPSBhbGlnbiB8fCByZXMudGV4dEFsaWduO1xuICAgICAgICB2ZXJ0aWNhbEFsaWduID0gdmVydGljYWxBbGlnbiB8fCByZXMudGV4dFZlcnRpY2FsQWxpZ247XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSByZWN0Lng7XG4gICAgICB5ID0gcmVjdC55O1xuICAgIH1cblxuICAgIHggPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0WCh4LCB0ZXh0UmVjdC53aWR0aCwgYWxpZ24pO1xuICAgIHkgPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0WSh5LCB0ZXh0UmVjdC5oZWlnaHQsIHZlcnRpY2FsQWxpZ24pOyAvLyBGb3JjZSBiYXNlbGluZSAnbWlkZGxlJ1xuXG4gICAgeSArPSB0ZXh0UmVjdC5oZWlnaHQgLyAyOyAvLyB2YXIgZm9udFNpemUgPSBmb250U3R5bGUuc2l6ZTtcbiAgICAvLyAxLjc1IGlzIGFuIGFyYml0cmFyeSBudW1iZXIsIGFzIHRoZXJlIGlzIG5vIGluZm8gYWJvdXQgdGhlIHRleHQgYmFzZWxpbmVcbiAgICAvLyBzd2l0Y2ggKGJhc2VsaW5lKSB7XG4gICAgLy8gY2FzZSAnaGFuZ2luZyc6XG4gICAgLy8gY2FzZSAndG9wJzpcbiAgICAvLyAgICAgeSArPSBmb250U2l6ZSAvIDEuNzU7XG4gICAgLy8gICAgIGJyZWFrO1xuICAgIC8vICAgICBjYXNlICdtaWRkbGUnOlxuICAgIC8vICAgICAgICAgYnJlYWs7XG4gICAgLy8gICAgIGRlZmF1bHQ6XG4gICAgLy8gICAgIC8vIGNhc2UgbnVsbDpcbiAgICAvLyAgICAgLy8gY2FzZSAnYWxwaGFiZXRpYyc6XG4gICAgLy8gICAgIC8vIGNhc2UgJ2lkZW9ncmFwaGljJzpcbiAgICAvLyAgICAgLy8gY2FzZSAnYm90dG9tJzpcbiAgICAvLyAgICAgICAgIHkgLT0gZm9udFNpemUgLyAyLjI1O1xuICAgIC8vICAgICAgICAgYnJlYWs7XG4gICAgLy8gfVxuICAgIC8vIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAvLyAgICAgY2FzZSAnbGVmdCc6XG4gICAgLy8gICAgICAgICBicmVhaztcbiAgICAvLyAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAvLyAgICAgICAgIHggLT0gdGV4dFJlY3Qud2lkdGggLyAyO1xuICAgIC8vICAgICAgICAgYnJlYWs7XG4gICAgLy8gICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAvLyAgICAgICAgIHggLT0gdGV4dFJlY3Qud2lkdGg7XG4gICAgLy8gICAgICAgICBicmVhaztcbiAgICAvLyBjYXNlICdlbmQnOlxuICAgIC8vIGFsaWduID0gZWxlbWVudFN0eWxlLmRpcmVjdGlvbiA9PSAnbHRyJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgLy8gYnJlYWs7XG4gICAgLy8gY2FzZSAnc3RhcnQnOlxuICAgIC8vIGFsaWduID0gZWxlbWVudFN0eWxlLmRpcmVjdGlvbiA9PSAncnRsJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgLy8gYnJlYWs7XG4gICAgLy8gZGVmYXVsdDpcbiAgICAvLyAgICAgYWxpZ24gPSAnbGVmdCc7XG4gICAgLy8gfVxuXG4gICAgdmFyIGNyZWF0ZU5vZGUgPSB2bWxDb3JlLmNyZWF0ZU5vZGU7XG4gICAgdmFyIHRleHRWbWxFbCA9IHRoaXMuX3RleHRWbWxFbDtcbiAgICB2YXIgcGF0aEVsO1xuICAgIHZhciB0ZXh0UGF0aEVsO1xuICAgIHZhciBza2V3RWw7XG5cbiAgICBpZiAoIXRleHRWbWxFbCkge1xuICAgICAgdGV4dFZtbEVsID0gY3JlYXRlTm9kZSgnbGluZScpO1xuICAgICAgcGF0aEVsID0gY3JlYXRlTm9kZSgncGF0aCcpO1xuICAgICAgdGV4dFBhdGhFbCA9IGNyZWF0ZU5vZGUoJ3RleHRwYXRoJyk7XG4gICAgICBza2V3RWwgPSBjcmVhdGVOb2RlKCdza2V3Jyk7IC8vIEZJWE1FIFdoeSBoZXJlIGlzIG5vdCBjYW1tZWwgY2FzZVxuICAgICAgLy8gQWxpZ24gJ2NlbnRlcicgc2VlbXMgd3JvbmdcblxuICAgICAgdGV4dFBhdGhFbC5zdHlsZVsndi10ZXh0LWFsaWduJ10gPSAnbGVmdCc7XG4gICAgICBpbml0Um9vdEVsU3R5bGUodGV4dFZtbEVsKTtcbiAgICAgIHBhdGhFbC50ZXh0cGF0aG9rID0gdHJ1ZTtcbiAgICAgIHRleHRQYXRoRWwub24gPSB0cnVlO1xuICAgICAgdGV4dFZtbEVsLmZyb20gPSAnMCAwJztcbiAgICAgIHRleHRWbWxFbC50byA9ICcxMDAwIDAuMDUnO1xuICAgICAgYXBwZW5kKHRleHRWbWxFbCwgc2tld0VsKTtcbiAgICAgIGFwcGVuZCh0ZXh0Vm1sRWwsIHBhdGhFbCk7XG4gICAgICBhcHBlbmQodGV4dFZtbEVsLCB0ZXh0UGF0aEVsKTtcbiAgICAgIHRoaXMuX3RleHRWbWxFbCA9IHRleHRWbWxFbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8g6L+Z6YeM5piv5Zyo5YmN6Z2iIGFwcGVuZENoaWxkIOS/neivgemhuuW6j+eahOWJjeaPkOS4i1xuICAgICAgc2tld0VsID0gdGV4dFZtbEVsLmZpcnN0Q2hpbGQ7XG4gICAgICBwYXRoRWwgPSBza2V3RWwubmV4dFNpYmxpbmc7XG4gICAgICB0ZXh0UGF0aEVsID0gcGF0aEVsLm5leHRTaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjb29yZHMgPSBbeCwgeV07XG4gICAgdmFyIHRleHRWbWxFbFN0eWxlID0gdGV4dFZtbEVsLnN0eWxlOyAvLyBJZ25vcmUgdHJhbnNmb3JtIGZvciB0ZXh0IGluIG90aGVyIGVsZW1lbnRcblxuICAgIGlmIChtICYmIGZyb21UZXh0RWwpIHtcbiAgICAgIGFwcGx5VHJhbnNmb3JtKGNvb3JkcywgY29vcmRzLCBtKTtcbiAgICAgIHNrZXdFbC5vbiA9IHRydWU7XG4gICAgICBza2V3RWwubWF0cml4ID0gbVswXS50b0ZpeGVkKDMpICsgY29tbWEgKyBtWzJdLnRvRml4ZWQoMykgKyBjb21tYSArIG1bMV0udG9GaXhlZCgzKSArIGNvbW1hICsgbVszXS50b0ZpeGVkKDMpICsgJywwLDAnOyAvLyBUZXh0IHBvc2l0aW9uXG5cbiAgICAgIHNrZXdFbC5vZmZzZXQgPSAocm91bmQoY29vcmRzWzBdKSB8fCAwKSArICcsJyArIChyb3VuZChjb29yZHNbMV0pIHx8IDApOyAvLyBMZWZ0IHRvcCBwb2ludCBhcyBvcmlnaW5cblxuICAgICAgc2tld0VsLm9yaWdpbiA9ICcwIDAnO1xuICAgICAgdGV4dFZtbEVsU3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgdGV4dFZtbEVsU3R5bGUudG9wID0gJzBweCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNrZXdFbC5vbiA9IGZhbHNlO1xuICAgICAgdGV4dFZtbEVsU3R5bGUubGVmdCA9IHJvdW5kKHgpICsgJ3B4JztcbiAgICAgIHRleHRWbWxFbFN0eWxlLnRvcCA9IHJvdW5kKHkpICsgJ3B4JztcbiAgICB9XG5cbiAgICB0ZXh0UGF0aEVsLnN0cmluZyA9IGVuY29kZUh0bWxBdHRyaWJ1dGUodGV4dCk7IC8vIFRPRE9cblxuICAgIHRyeSB7XG4gICAgICB0ZXh0UGF0aEVsLnN0eWxlLmZvbnQgPSBmb250O1xuICAgIH0gLy8gRXJyb3IgZm9udCBmb3JtYXRcbiAgICBjYXRjaCAoZSkge31cblxuICAgIHVwZGF0ZUZpbGxBbmRTdHJva2UodGV4dFZtbEVsLCAnZmlsbCcsIHtcbiAgICAgIGZpbGw6IHN0eWxlLnRleHRGaWxsLFxuICAgICAgb3BhY2l0eTogc3R5bGUub3BhY2l0eVxuICAgIH0sIHRoaXMpO1xuICAgIHVwZGF0ZUZpbGxBbmRTdHJva2UodGV4dFZtbEVsLCAnc3Ryb2tlJywge1xuICAgICAgc3Ryb2tlOiBzdHlsZS50ZXh0U3Ryb2tlLFxuICAgICAgb3BhY2l0eTogc3R5bGUub3BhY2l0eSxcbiAgICAgIGxpbmVEYXNoOiBzdHlsZS5saW5lRGFzaFxuICAgIH0sIHRoaXMpO1xuICAgIHRleHRWbWxFbC5zdHlsZS56SW5kZXggPSBnZXRaSW5kZXgodGhpcy56bGV2ZWwsIHRoaXMueiwgdGhpcy56Mik7IC8vIEF0dGFjaGVkIHRvIHJvb3RcblxuICAgIGFwcGVuZCh2bWxSb290LCB0ZXh0Vm1sRWwpO1xuICB9O1xuXG4gIHZhciByZW1vdmVSZWN0VGV4dCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgcmVtb3ZlKHZtbFJvb3QsIHRoaXMuX3RleHRWbWxFbCk7XG4gICAgdGhpcy5fdGV4dFZtbEVsID0gbnVsbDtcbiAgfTtcblxuICB2YXIgYXBwZW5kUmVjdFRleHQgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIGFwcGVuZCh2bWxSb290LCB0aGlzLl90ZXh0Vm1sRWwpO1xuICB9O1xuXG4gIHZhciBsaXN0ID0gW1JlY3RUZXh0LCBEaXNwbGF5YWJsZSwgWkltYWdlLCBQYXRoLCBUZXh0XTsgLy8gSW4gY2FzZSBEaXNwbGF5YWJsZSBoYXMgYmVlbiBtaXhlZCBpbiBSZWN0VGV4dFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm90byA9IGxpc3RbaV0ucHJvdG90eXBlO1xuICAgIHByb3RvLmRyYXdSZWN0VGV4dCA9IGRyYXdSZWN0VGV4dDtcbiAgICBwcm90by5yZW1vdmVSZWN0VGV4dCA9IHJlbW92ZVJlY3RUZXh0O1xuICAgIHByb3RvLmFwcGVuZFJlY3RUZXh0ID0gYXBwZW5kUmVjdFRleHQ7XG4gIH1cblxuICBUZXh0LnByb3RvdHlwZS5icnVzaFZNTCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcblxuICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KHZtbFJvb3QsIHtcbiAgICAgICAgeDogc3R5bGUueCB8fCAwLFxuICAgICAgICB5OiBzdHlsZS55IHx8IDAsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH0sIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCksIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZVJlY3RUZXh0KHZtbFJvb3QpO1xuICAgIH1cbiAgfTtcblxuICBUZXh0LnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgdGhpcy5yZW1vdmVSZWN0VGV4dCh2bWxSb290KTtcbiAgfTtcblxuICBUZXh0LnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgdGhpcy5hcHBlbmRSZWN0VGV4dCh2bWxSb290KTtcbiAgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvdm1sL2dyYXBoaWMuanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZW52ID0gcmVxdWlyZShcIi4uL2NvcmUvZW52XCIpO1xuXG52YXIgdXJuID0gJ3VybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sJztcbnZhciB3aW4gPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3c7XG52YXIgdm1sSW5pdGVkID0gZmFsc2U7XG52YXIgZG9jID0gd2luICYmIHdpbi5kb2N1bWVudDtcblxuZnVuY3Rpb24gY3JlYXRlTm9kZSh0YWdOYW1lKSB7XG4gIHJldHVybiBkb0NyZWF0ZU5vZGUodGFnTmFtZSk7XG59IC8vIEF2b2lkIGFzc2lnbiB0byBhbiBleHBvcnRlZCB2YXJpYWJsZSwgZm9yIHRyYW5zZm9ybWluZyB0byBjanMuXG5cblxudmFyIGRvQ3JlYXRlTm9kZTtcblxuaWYgKGRvYyAmJiAhZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICB0cnkge1xuICAgICFkb2MubmFtZXNwYWNlcy56cnZtbCAmJiBkb2MubmFtZXNwYWNlcy5hZGQoJ3pydm1sJywgdXJuKTtcblxuICAgIGRvQ3JlYXRlTm9kZSA9IGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gZG9jLmNyZWF0ZUVsZW1lbnQoJzx6cnZtbDonICsgdGFnTmFtZSArICcgY2xhc3M9XCJ6cnZtbFwiPicpO1xuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkb0NyZWF0ZU5vZGUgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgICAgcmV0dXJuIGRvYy5jcmVhdGVFbGVtZW50KCc8JyArIHRhZ05hbWUgKyAnIHhtbG5zPVwiJyArIHVybiArICdcIiBjbGFzcz1cInpydm1sXCI+Jyk7XG4gICAgfTtcbiAgfVxufSAvLyBGcm9tIHJhcGhhZWxcblxuXG5mdW5jdGlvbiBpbml0Vk1MKCkge1xuICBpZiAodm1sSW5pdGVkIHx8ICFkb2MpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2bWxJbml0ZWQgPSB0cnVlO1xuICB2YXIgc3R5bGVTaGVldHMgPSBkb2Muc3R5bGVTaGVldHM7XG5cbiAgaWYgKHN0eWxlU2hlZXRzLmxlbmd0aCA8IDMxKSB7XG4gICAgZG9jLmNyZWF0ZVN0eWxlU2hlZXQoKS5hZGRSdWxlKCcuenJ2bWwnLCAnYmVoYXZpb3I6dXJsKCNkZWZhdWx0I1ZNTCknKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzExOTQlMjhWUy44NSUyOS5hc3B4XG4gICAgc3R5bGVTaGVldHNbMF0uYWRkUnVsZSgnLnpydm1sJywgJ2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpJyk7XG4gIH1cbn1cblxuZXhwb3J0cy5kb2MgPSBkb2M7XG5leHBvcnRzLmNyZWF0ZU5vZGUgPSBjcmVhdGVOb2RlO1xuZXhwb3J0cy5pbml0Vk1MID0gaW5pdFZNTDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvdm1sL2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgenJMb2cgPSByZXF1aXJlKFwiLi4vY29yZS9sb2dcIik7XG5cbnZhciB2bWxDb3JlID0gcmVxdWlyZShcIi4vY29yZVwiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIGVhY2ggPSBfdXRpbC5lYWNoO1xuXG4vKipcbiAqIFZNTCBQYWludGVyLlxuICpcbiAqIEBtb2R1bGUgenJlbmRlci92bWwvUGFpbnRlclxuICovXG5mdW5jdGlvbiBwYXJzZUludDEwKHZhbCkge1xuICByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCk7XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci92bWwvUGFpbnRlclxuICovXG5cblxuZnVuY3Rpb24gVk1MUGFpbnRlcihyb290LCBzdG9yYWdlKSB7XG4gIHZtbENvcmUuaW5pdFZNTCgpO1xuICB0aGlzLnJvb3QgPSByb290O1xuICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICB2YXIgdm1sVmlld3BvcnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIHZtbFJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdm1sVmlld3BvcnQuc3R5bGUuY3NzVGV4dCA9ICdkaXNwbGF5OmlubGluZS1ibG9jaztvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MzAwcHg7aGVpZ2h0OjE1MHB4Oyc7XG4gIHZtbFJvb3Quc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOjA7JztcbiAgcm9vdC5hcHBlbmRDaGlsZCh2bWxWaWV3cG9ydCk7XG4gIHRoaXMuX3ZtbFJvb3QgPSB2bWxSb290O1xuICB0aGlzLl92bWxWaWV3cG9ydCA9IHZtbFZpZXdwb3J0O1xuICB0aGlzLnJlc2l6ZSgpOyAvLyBNb2RpZnkgc3RvcmFnZVxuXG4gIHZhciBvbGREZWxGcm9tU3RvcmFnZSA9IHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2U7XG4gIHZhciBvbGRBZGRUb1N0b3JhZ2UgPSBzdG9yYWdlLmFkZFRvU3RvcmFnZTtcblxuICBzdG9yYWdlLmRlbEZyb21TdG9yYWdlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgb2xkRGVsRnJvbVN0b3JhZ2UuY2FsbChzdG9yYWdlLCBlbCk7XG5cbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLm9uUmVtb3ZlICYmIGVsLm9uUmVtb3ZlKHZtbFJvb3QpO1xuICAgIH1cbiAgfTtcblxuICBzdG9yYWdlLmFkZFRvU3RvcmFnZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgIC8vIERpc3BsYXlhYmxlIGFscmVhZHkgaGFzIGEgdm1sIG5vZGVcbiAgICBlbC5vbkFkZCAmJiBlbC5vbkFkZCh2bWxSb290KTtcbiAgICBvbGRBZGRUb1N0b3JhZ2UuY2FsbChzdG9yYWdlLCBlbCk7XG4gIH07XG5cbiAgdGhpcy5fZmlyc3RQYWludCA9IHRydWU7XG59XG5cblZNTFBhaW50ZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVk1MUGFpbnRlcixcbiAgZ2V0VHlwZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAndm1sJztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTERpdkVsZW1lbnR9XG4gICAqL1xuICBnZXRWaWV3cG9ydFJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdm1sVmlld3BvcnQ7XG4gIH0sXG4gIGdldFZpZXdwb3J0Um9vdE9mZnNldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciB2aWV3cG9ydFJvb3QgPSB0aGlzLmdldFZpZXdwb3J0Um9vdCgpO1xuXG4gICAgaWYgKHZpZXdwb3J0Um9vdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0TGVmdDogdmlld3BvcnRSb290Lm9mZnNldExlZnQgfHwgMCxcbiAgICAgICAgb2Zmc2V0VG9wOiB2aWV3cG9ydFJvb3Qub2Zmc2V0VG9wIHx8IDBcbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDliLfmlrBcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlLCB0cnVlKTtcblxuICAgIHRoaXMuX3BhaW50TGlzdChsaXN0KTtcbiAgfSxcbiAgX3BhaW50TGlzdDogZnVuY3Rpb24gKGxpc3QpIHtcbiAgICB2YXIgdm1sUm9vdCA9IHRoaXMuX3ZtbFJvb3Q7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbCA9IGxpc3RbaV07XG5cbiAgICAgIGlmIChlbC5pbnZpc2libGUgfHwgZWwuaWdub3JlKSB7XG4gICAgICAgIGlmICghZWwuX19hbHJlYWR5Tm90VmlzaWJsZSkge1xuICAgICAgICAgIGVsLm9uUmVtb3ZlKHZtbFJvb3QpO1xuICAgICAgICB9IC8vIFNldCBhcyBhbHJlYWR5IGludmlzaWJsZVxuXG5cbiAgICAgICAgZWwuX19hbHJlYWR5Tm90VmlzaWJsZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZWwuX19hbHJlYWR5Tm90VmlzaWJsZSkge1xuICAgICAgICAgIGVsLm9uQWRkKHZtbFJvb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwuX19hbHJlYWR5Tm90VmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChlbC5fX2RpcnR5KSB7XG4gICAgICAgICAgZWwuYmVmb3JlQnJ1c2ggJiYgZWwuYmVmb3JlQnJ1c2goKTtcbiAgICAgICAgICAoZWwuYnJ1c2hWTUwgfHwgZWwuYnJ1c2gpLmNhbGwoZWwsIHZtbFJvb3QpO1xuICAgICAgICAgIGVsLmFmdGVyQnJ1c2ggJiYgZWwuYWZ0ZXJCcnVzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVsLl9fZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZmlyc3RQYWludCkge1xuICAgICAgLy8gRGV0YWNoZWQgZnJvbSBkb2N1bWVudCBhdCBmaXJzdCB0aW1lXG4gICAgICAvLyB0byBhdm9pZCBwYWdlIHJlZnJlc2hpbmcgdG9vIG1hbnkgdGltZXNcbiAgICAgIC8vIEZJWE1FIOWmguaenOavj+asoemDveWFiCByZW1vdmVDaGlsZCDlj6/og73kvJrlr7zoh7TkuIDkupvloavlhYXlkozmj4/ovrnnmoTmlYjmnpzmlLnlj5hcbiAgICAgIHRoaXMuX3ZtbFZpZXdwb3J0LmFwcGVuZENoaWxkKHZtbFJvb3QpO1xuXG4gICAgICB0aGlzLl9maXJzdFBhaW50ID0gZmFsc2U7XG4gICAgfVxuICB9LFxuICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIHdpZHRoID0gd2lkdGggPT0gbnVsbCA/IHRoaXMuX2dldFdpZHRoKCkgOiB3aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gaGVpZ2h0ID09IG51bGwgPyB0aGlzLl9nZXRIZWlnaHQoKSA6IGhlaWdodDtcblxuICAgIGlmICh0aGlzLl93aWR0aCAhPSB3aWR0aCB8fCB0aGlzLl9oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdmFyIHZtbFZpZXdwb3J0U3R5bGUgPSB0aGlzLl92bWxWaWV3cG9ydC5zdHlsZTtcbiAgICAgIHZtbFZpZXdwb3J0U3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICB2bWxWaWV3cG9ydFN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgfVxuICB9LFxuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yb290LmlubmVySFRNTCA9ICcnO1xuICAgIHRoaXMuX3ZtbFJvb3QgPSB0aGlzLl92bWxWaWV3cG9ydCA9IHRoaXMuc3RvcmFnZSA9IG51bGw7XG4gIH0sXG4gIGdldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICB9LFxuICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICB9LFxuICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl92bWxWaWV3cG9ydCkge1xuICAgICAgdGhpcy5yb290LnJlbW92ZUNoaWxkKHRoaXMuX3ZtbFZpZXdwb3J0KTtcbiAgICB9XG4gIH0sXG4gIF9nZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgIHZhciByb290ID0gdGhpcy5yb290O1xuICAgIHZhciBzdGwgPSByb290LmN1cnJlbnRTdHlsZTtcbiAgICByZXR1cm4gKHJvb3QuY2xpZW50V2lkdGggfHwgcGFyc2VJbnQxMChzdGwud2lkdGgpKSAtIHBhcnNlSW50MTAoc3RsLnBhZGRpbmdMZWZ0KSAtIHBhcnNlSW50MTAoc3RsLnBhZGRpbmdSaWdodCkgfCAwO1xuICB9LFxuICBfZ2V0SGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgdmFyIHN0bCA9IHJvb3QuY3VycmVudFN0eWxlO1xuICAgIHJldHVybiAocm9vdC5jbGllbnRIZWlnaHQgfHwgcGFyc2VJbnQxMChzdGwuaGVpZ2h0KSkgLSBwYXJzZUludDEwKHN0bC5wYWRkaW5nVG9wKSAtIHBhcnNlSW50MTAoc3RsLnBhZGRpbmdCb3R0b20pIHwgMDtcbiAgfVxufTsgLy8gTm90IHN1cHBvcnRlZCBtZXRob2RzXG5cbmZ1bmN0aW9uIGNyZWF0ZU1ldGhvZE5vdFN1cHBvcnQobWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgenJMb2coJ0luIElFOC4wIFZNTCBtb2RlIHBhaW50ZXIgbm90IHN1cHBvcnQgbWV0aG9kIFwiJyArIG1ldGhvZCArICdcIicpO1xuICB9O1xufSAvLyBVbnN1cHBvcnRlZCBtZXRob2RzXG5cblxuZWFjaChbJ2dldExheWVyJywgJ2luc2VydExheWVyJywgJ2VhY2hMYXllcicsICdlYWNoQnVpbHRpbkxheWVyJywgJ2VhY2hPdGhlckxheWVyJywgJ2dldExheWVycycsICdtb2RMYXllcicsICdkZWxMYXllcicsICdjbGVhckxheWVyJywgJ3RvRGF0YVVSTCcsICdwYXRoVG9JbWFnZSddLCBmdW5jdGlvbiAobmFtZSkge1xuICBWTUxQYWludGVyLnByb3RvdHlwZVtuYW1lXSA9IGNyZWF0ZU1ldGhvZE5vdFN1cHBvcnQobmFtZSk7XG59KTtcbnZhciBfZGVmYXVsdCA9IFZNTFBhaW50ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi92bWwvUGFpbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=