{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","fish-topo-flow.js","webpack:/webpack/bootstrap 01e449601b00a4f733d2","webpack:///index.flow.js","webpack:///lib/fish-topo-flow/lib/FishTopoFlow.js","webpack:///lib/fish-topo-core/lib/polyfill.js","webpack:///lib/fish-topo-core/lib/graphic.js","webpack:///~/zrender/lib/core/util.js","webpack:///~/zrender/lib/tool/path.js","webpack:///~/zrender/lib/graphic/Path.js","webpack:///~/zrender/lib/graphic/Displayable.js","webpack:///~/zrender/lib/graphic/Style.js","webpack:///~/zrender/lib/Element.js","webpack:///~/zrender/lib/core/guid.js","webpack:///~/zrender/lib/mixin/Eventful.js","webpack:///~/zrender/lib/mixin/Transformable.js","webpack:///~/zrender/lib/core/matrix.js","webpack:///~/zrender/lib/core/vector.js","webpack:///~/zrender/lib/mixin/Animatable.js","webpack:///~/zrender/lib/animation/Animator.js","webpack:///~/zrender/lib/animation/Clip.js","webpack:///~/zrender/lib/animation/easing.js","webpack:///~/zrender/lib/tool/color.js","webpack:///~/zrender/lib/core/LRU.js","webpack:///~/zrender/lib/core/log.js","webpack:///~/zrender/lib/config.js","webpack:///~/zrender/lib/graphic/mixin/RectText.js","webpack:///~/zrender/lib/graphic/helper/text.js","webpack:///~/zrender/lib/contain/text.js","webpack:///~/zrender/lib/core/BoundingRect.js","webpack:///~/zrender/lib/graphic/helper/image.js","webpack:///~/zrender/lib/graphic/helper/roundRect.js","webpack:///~/zrender/lib/core/PathProxy.js","webpack:///~/zrender/lib/core/curve.js","webpack:///~/zrender/lib/core/bbox.js","webpack:///~/zrender/lib/contain/path.js","webpack:///~/zrender/lib/contain/line.js","webpack:///~/zrender/lib/contain/cubic.js","webpack:///~/zrender/lib/contain/quadratic.js","webpack:///~/zrender/lib/contain/arc.js","webpack:///~/zrender/lib/contain/util.js","webpack:///~/zrender/lib/contain/windingLine.js","webpack:///~/zrender/lib/graphic/Pattern.js","webpack:///~/zrender/lib/tool/transformPath.js","webpack:///~/zrender/lib/graphic/Gradient.js","webpack:///~/zrender/lib/mixin/Draggable.js","webpack:///~/zrender/lib/container/Group.js","webpack:///~/zrender/lib/graphic/Image.js","webpack:///~/zrender/lib/graphic/Text.js","webpack:///~/zrender/lib/graphic/shape/Circle.js","webpack:///~/zrender/lib/graphic/shape/Sector.js","webpack:///~/zrender/lib/graphic/helper/fixClipWithShadow.js","webpack:///~/zrender/lib/core/env.js","webpack:///~/zrender/lib/graphic/shape/Ring.js","webpack:///~/zrender/lib/graphic/shape/Polygon.js","webpack:///~/zrender/lib/graphic/helper/poly.js","webpack:///~/zrender/lib/graphic/helper/smoothSpline.js","webpack:///~/zrender/lib/graphic/helper/smoothBezier.js","webpack:///~/zrender/lib/graphic/shape/Polyline.js","webpack:///~/zrender/lib/graphic/shape/Rect.js","webpack:///~/zrender/lib/graphic/shape/Line.js","webpack:///~/zrender/lib/graphic/shape/BezierCurve.js","webpack:///~/zrender/lib/graphic/shape/Arc.js","webpack:///~/zrender/lib/graphic/LinearGradient.js","webpack:///~/zrender/lib/graphic/RadialGradient.js","webpack:///~/zrender/lib/graphic/States.js","webpack:///lib/fish-topo-core/lib/minimap.js","webpack:///lib/fish-topo-core/lib/util.js","webpack:///lib/fish-topo-core/lib/Point.js","webpack:///lib/fish-topo-core/lib/LineStruct.js","webpack:///lib/fish-topo-flow/lib/ExtensionApi.js","webpack:///~/zrender/lib/zrender.js","webpack:///~/zrender/lib/Handler.js","webpack:///~/zrender/lib/Storage.js","webpack:///~/zrender/lib/core/timsort.js","webpack:///~/zrender/lib/Painter.js","webpack:///~/zrender/lib/Layer.js","webpack:///~/zrender/lib/animation/requestAnimationFrame.js","webpack:///~/zrender/lib/animation/Animation.js","webpack:///~/zrender/lib/core/event.js","webpack:///~/zrender/lib/dom/HandlerProxy.js","webpack:///~/zrender/lib/core/GestureMgr.js","webpack:///lib/fish-topo-core/lib/manager/OperationNode.js","webpack:///lib/fish-topo-core/lib/Node.js","webpack:///lib/fish-topo-core/lib/shapes/Connector.js","webpack:///lib/fish-topo-core/lib/shapes/Symbol.js","webpack:///lib/fish-topo-core/lib/shapes/Handle.js","webpack:///lib/fish-topo-core/lib/shapes/EffectLine.js","webpack:///lib/fish-topo-core/lib/shapes/ConnectionPoint.js","webpack:///lib/fish-topo-core/lib/model.js","webpack:///lib/fish-topo-core/lib/clazz.js","webpack:///lib/fish-topo-core/lib/manager/IconOperation.js","webpack:///lib/fish-topo-flow/lib/manager/FlowConnectionManager.js","webpack:///lib/fish-topo-core/lib/manager/ConnectionManager.js","webpack:///lib/fish-topo-core/lib/Log.js","webpack:///lib/fish-topo-flow/lib/util/FlowConstants.js","webpack:///lib/fish-topo-flow/lib/util/FlowUtil.js","webpack:///lib/fish-topo-flow/lib/node/GroupNode.js","webpack:///lib/fish-topo-flow/lib/node/flowNode.js","webpack:///lib/fish-topo-flow/lib/node/Rect.js","webpack:///lib/fish-topo-flow/lib/node/Circle.js","webpack:///lib/fish-topo-flow/lib/node/Image.js","webpack:///lib/fish-topo-flow/lib/node/Text.js","webpack:///lib/fish-topo-flow/lib/node/Sector.js","webpack:///lib/fish-topo-flow/lib/node/Ring.js","webpack:///lib/fish-topo-flow/lib/node/Ellipse.js","webpack:///lib/fish-topo-flow/lib/node/Heart.js","webpack:///lib/fish-topo-flow/lib/node/Droplet.js","webpack:///lib/fish-topo-flow/lib/node/Rose.js","webpack:///lib/fish-topo-flow/lib/node/Isogon.js","webpack:///lib/fish-topo-flow/lib/node/Polygon.js","webpack:///lib/fish-topo-flow/lib/node/Line.js","webpack:///lib/fish-topo-flow/lib/node/Polyline.js","webpack:///lib/fish-topo-flow/lib/node/BezierCurve.js","webpack:///lib/fish-topo-flow/lib/node/Arc.js","webpack:///lib/fish-topo-flow/lib/node/Star.js","webpack:///lib/fish-topo-flow/lib/node/Trochoid.js","webpack:///lib/fish-topo-flow/lib/node/Path.js","webpack:///lib/fish-topo-flow/lib/node/IconButton.js","webpack:///lib/fish-topo-flow/lib/link/flowLink.js","webpack:///lib/fish-topo-flow/lib/link/Link.js","webpack:///lib/fish-topo-flow/lib/Flow.js","webpack:///lib/fish-topo-flow/lib/link/Fold.js","webpack:///lib/fish-topo-flow/lib/link/Curve.js","webpack:///lib/fish-topo-flow/lib/link/Chain.js","webpack:///lib/fish-topo-core/lib/manager/LineOperationManager.js","webpack:///lib/fish-topo-flow/lib/layout/layout.js","webpack:///lib/fish-topo-flow/lib/layout/HLayout.js","webpack:///lib/fish-topo-flow/lib/layout/VLayout.js","webpack:///lib/fish-topo-flow/lib/layout/TreeLayout.js","webpack:///lib/fish-topo-flow/lib/data/Tree.js","webpack:///lib/fish-topo-flow/lib/layout/treeHelper.js","webpack:///lib/fish-topo-flow/lib/layout/ForceLayout.js","webpack:///lib/fish-topo-flow/lib/layout/forceHelper.js","webpack:///lib/fish-topo-core/lib/ImagePool.js","webpack:///lib/fish-topo-flow/lib/tooltip/TooltipView.js","webpack:///lib/fish-topo-flow/lib/tooltip/TooltipContent.js","webpack:///lib/fish-topo-flow/lib/tooltip/globalListener.js","webpack:///lib/fish-topo-flow/lib/tooltip/TooltipModel.js","webpack:///~/zrender/lib/vml/vml.js","webpack:///~/zrender/lib/vml/graphic.js","webpack:///~/zrender/lib/vml/core.js","webpack:///~/zrender/lib/vml/Painter.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","FishTopoFlow","dom","opts","group","_dom","nowZoom","canScale","eagleEye","eagleEyeNode","initScaleRatio","operationNode","step","stepJson","selectedNode","allNodes","minimap","_api","ExtensionAPI","connectionManager","FlowConnectionManager","lineOperationManager","LineOperationManager","_zr","zrender","init","renderer","devicePixelRatio","_tooltipView","ToolTipView","TooltipModel","tooltip","Shape","graphic","lineOpt","selectedNodes","model","Model","set","Constants","ELEMENT_TYPE","MODE","options","cursorMap","tl","tr","bl","br","mtr","cursorMaps","cursorOffset","Eventful","Minimap","util","Point","zrUtil","OperationNode","FlowUtil","eventTool","Connector","Flow","flowNode","GroupNode","flowLink","layout","textContain","ImagePool","actions","keyCode","ENTER","ESCAPE","fishTopoProto","prototype","getDom","getZr","getWidth","getHeight","isDisposed","_disposed","dispose","instances","resize","dispatchAction","payload","type","option","key","value","arguments","length","clone","get","setRoam","MOUSE_EVENT_NAMES","window","Group","isBg","add","roam","zrScale","connectors","on","e","shape","target","isLink","connector","clearSelectCon","_isLineOperationIcon","hideAllLineOperation","bind","hideConnectorPoint","hideConnectorControl","_removeOperationNode","nodeTarget","isNode","params","event","trigger","mouseMode","lineType","parent","Circle","name","_dragSelect","offsetX","offsetY","_groupDragHandler","argument","bindOperation","lineNode","each","eveName","off","addGroupModel","groupNode","that","eachChild","node","childs","children","childNode","push","toJson","fromJson","json","isNoCount","clear","setBackground","BACKGROUND","layoutRootNode","CHILDS","addNode","opt","_trigger","addConnectorAttrEvent","isGroupNode","willRender","groupOptions","OPTIONS","mergedImage","groupReplaceImage","Image","style","image","text","textPosition","position","drag","_relationImage","setTimeout","hide","merged","child","_addGroupNode","addNodeAttrEvent","hoverStyle","setHoverStyle","relative","_handleRelativePostion","hoverAnimation","isAnimationEnabled","addHoverAnimation","stepCounter","childDraggable","isUndefined","selectable","addTextOnChain","line","TYPE_CHAIN","removeLine","_getParentZr","textContextMenu","slink","Chain","startNode","endNode","delTextOnChain","txtObj","pos","isArray","forEach","v","i","textId","splice","modifyTextOnChain","setStyle","toggleAllConNodeLine","allLine","show","chainLine","getTwoNodeId","cons","connectorMap","orignText","concat","isEdit","linkModify","connectorForbidEdit","textEditable","connectorEdit","attr","targeNode","nodeClickHandler","cancelBubble","isInGroup","parentNode","nodeEdit","parentEl","containerInfo","width","height","getBoundingRect","positionElement","padding","boundingMode","bounding","parentZr","remove","cleanup","deleteSelectCon","dragSelectRect","addLineIcon","addIcon","lineDefaultIcon","addLineDeleteIcon","addLineChangeIcon","addDeleteIcon","addChangeLineTypeIcon","changeSelectConnectorType","nextLineType","selConnector","originLineType","arrLineType","TYPE_STRAIGHT","TYPE_JAGGED","TYPE_CURVE","index","indexOf","deleteLine","merge","dockers","nextLine","createConnectorByNodes","icons","createConnectorPoint","point","me","pointInstance","cx","x","cy","y","r","fill","stroke","z","draggable","filterConnectPoint","targetNodes","groupNodes","outsideNodes","nodes","item","includes","rect","getRect","connectorPoint","getConnectorPoints","left","right","top","bottom","showConnectorPoint","ifCurrentNode","findConnectorNode","offset","endPos","Math","abs","_releaseSelectNode","arrow","startPos","selectConnNode","reverseConnect","originNode","deleteByLine","originPos","manageReverseTempConnector","manageTempConnector","scale","origin","res","targetNode","removeTempConnector","connectOptions","finalOpt","mergeOpt","start","end","createLineConnectorPoint","getRotatedCornerCursor","rotation","angle","PI","n","round","createConnectorControl","posArr","split","controlCursor","Rect","cursor","nodeId","Line","x1","y1","x2","y2","lineWidth","returnConnectorControlParam","scaleFlag","scaleable","rotateFlag","rotatable","types","showConnectorControl","findControlNode","getConnectorControls","tc","posMap","find","currentNode","boundingRect","oppositeShape","currentShape","diagonal","sqrt","pow","originRect","ifPointCenter","selectStyle","removeHover","targetPos","r_x","r_y","origins","atan2","controlPoint","setShape","width0","height0","ratio","center","centerPoint","cursorsY","positionOrg","scaleNodes","filter","currentControlNode","startY","startX","test","updateShape","rectScale","diagonalNew","originScale","rectNow","connectorPointScale","controlPointScale","refreshPostion","refreshLineByNode","parseInt","Array","elementType","initOperationNode","ARROW_DRAGSTART","data","rEndPoint","ARROW_DRAG","ARROW_DRAGEND","shapeRect","undefined","DELETE_CLICK","removeNode","removeSelectedNodes","findNodeChildIds","childIds","findIndex","sub","delNode","lineOperationIcon","selectNode","linkType","Link","callback","isFunction","apply","ifShowPoint","draggingTarget","isdraggable","_nodeDragHandler","isMove","ts","nowGroupPosition","groupPositionX","groupPositionY","_startX","_startY","allLines","lines","ifExist","moveHandler","sX","sY","nodeMessage","movePosition","moveX","moveY","modifyGroupRect","alarm","newAlarmPosition","isPosInGroup","endDragHandler","truncPosition","openEagleEye","nodeX","nodeY","groupX","parentX","groupY","parentY","groupWidth","groupHeight","nodeWidth","nodeHeight","createNode","creatNode","userData","setUserData","childOfName","arrResult","childrenNode","childrenLine","j","findElements","cb","context","arr","childL","findConnectorsByNode","defaults","imageUrl","isRepeat","substr","document","createElement","getContext","imageShape","backgroundColor","gridLineGroup","gridLine","backgroundImage","backgroundRepeat","imageShape1","opacity","pixel","widthLen","lineX","lineDash","heightLen","lineY","createLink","creatLink","USERDATA","thisConnector","lineText","textarea","createTextArea","textRect","textFont","maxWidth","border","innerHTML","appendChild","lineHeight","focus","select","_textareaResize","onkeyup","scrollHeight","onfocusout","thisNode","MAXWIDTH_MULTIPLE_TOP_BOTTOM","isNotSetText","nodeText","textareaWidth","textareaHeight","nodeRect","offestI","textAlign","offestP","blur","onblur","handleWrap","whiteSpace","overflow","spellcheck","spanNode","content","result","val","valLength","innerVal","tempWidth","conWidth","pre","innerI","charAt","clientWidth","Number","substring","removeChild","minWidth","createAlarm","creatAlarm","textFill","textBaseline","points","Polyline","textBackground","groupPosition","ALARM","RELATIONID","ID","toDataURL","groupNodesIds","map","canvasOffsetX","canvasOffsetY","posX","posY","setProperties","cnt","gx","gy","min","max","updataSelectionPosition","initScale","groupMaxWidth","groupMaxHeight","rangeWidth","rangeHeight","initRatio","distance","zrCenter","boundPos","boundObj","extend","minX","minY","maxX","maxY","offsetWidth","offsetHeight","JSON","stringify","zoomDelta","zoom","isNaN","zoomScale","_zoom","setScale","stop","wheelDelta","zoomX","zoomY","newZoom","toFixed","maxScale","minScale","updataSelection","groupScale","imgSrc","updataMap","selection","addEventListener","clientX","clientY","minimapLeft","minimapTop","eagleEyeMove","updataGroupPosition","eagleEyeUp","removeEventListener","refreshGroupByNode","mixin","idBase","Date","DOM_ATTRIBUTE_KEY","fishTopoFlow","version","dependencies","Error","beforeDelete","beforeCreate","setAttribute","getInstanceByDom","getAttribute","chart","topo","isDom","registerFlowNode","link","constants","initImagePool","Function","oThis","TypeError","aArgs","slice","fToBind","fNOP","fBound","Element","String","endsWith","searchString","subjectString","toString","isFinite","floor","lastIndex","doSingleEnterHover","el","__isHover","__hoverStlDirty","__hoverStl","lift","colorTool","Gradient","normalStyle","hasOwnProperty","__normalStl","z2","doSingleLeaveHover","normalStl","doEnterHover","traverse","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","animateOrSetProps","isUpdate","props","animatableModel","postfix","duration","getShallow","animationEasing","animateTo","pathTool","Path","matrix","vector","Draggable","Util","Text","Sector","Ring","Polygon","BezierCurve","Arc","LinearGradient","RadialGradient","BoundingRect","States","extendShape","extendPath","pathData","extendFromString","makePath","path","createFromString","aspect","resizePath","inherits","mergePath","applyTransform","pathRect","calculateTransform","subPixelOptimizeLine","param","subPixelOptimize","subPixelOptimizeRect","originX","originY","originWidth","originHeight","positiveOrNegative","doubledPosition","setNormalStyle","setText","textStyle","labelModel","color","labelPosition","labelColor","textStyleModel","getModel","textDistance","getFont","getTextColor","updateProps","curry","initProps","getTransform","ancestor","mat","identity","mul","getLocalTransform","vertex","transform","invert","transformDirection","direction","hBase","vBase","$override","fn","methods","source","typeStr","objToString","len","TYPED_ARRAY","Ctor","constructor","from","BUILTIN_OBJECT","isPrimitive","overwrite","isObject","targetProp","sourceProp","isBuiltInObject","mergeAll","targetAndSources","overlay","_ctx","createCanvas","array","clazz","baseClazz","F","clazzPrototype","prop","superClass","isArrayLike","obj","nativeForEach","nativeMap","reduce","memo","nativeReduce","nativeFilter","func","args","nativeSlice","isString","nodeType","ownerDocument","eqNaN","retrieve","values","retrieve2","value0","value1","retrieve3","value2","normalizeCssArray","assert","condition","message","setAsPrimitive","primitiveKey","HashMap","createHashMap","noop","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","[object Canvas]","[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]","Object","arrayProto","HASH_MAP_PREFIX","HASH_MAP_PREFIX_LENGTH","prefixedKey","removeKey","processArc","fa","fs","rx","ry","psiDeg","cmd","psi","xp","mathCos","mathSin","yp","lambda","mathSqrt","f","cxp","cyp","theta","vAngle","u","dTheta","vRatio","addData","createPathProxyFromString","cs","replace","cc","RegExp","prevCmd","cpx","cpy","PathProxy","CMD","str","shift","parseFloat","ctlPtx","ctlPty","L","M","C","Q","A","Z","toStatic","createPathOptions","pathProxy","buildPath","setData","ctx","rebuildPath","transformPath","dirty","pathEls","pathList","pathEl","createPathProxy","__dirtyPath","pathBundle","appendPath","sin","cos","vMag","acos","Displayable","pathContain","Pattern","getCanvasPattern","pathProxyForDraw","strokeContainThreshold","brush","prevEl","hasStroke","hasFill","hasFillGradient","colorStops","hasStrokeGradient","hasFillPattern","hasStrokePattern","setTransform","__dirty","_fillGradient","getGradient","_strokeGradient","fillStyle","strokeStyle","lineDashOffset","ctxLineDash","setLineDash","getGlobalScale","beginPath","setLineDashOffset","restoreTransform","drawRectText","shapeCfg","inBundle","_rect","needsUpdateRect","rectWithStroke","_rectWithStroke","copy","w","lineScale","strokeNoScale","getLineScale","contain","localPos","transformCoordToLocal","containStroke","dirtyPath","__zr","refresh","__clipTarget","animateShape","loop","animate","attrKV","Sub","extendFrom","defaultShape","thisShape","_default","Style","__clipPaths","RectText","invisible","zlevel","dragging","silent","culling","rectHover","progressive","beforeBrush","afterBrush","rectContain","coord","animateStyle","useStyle","createLinearGradient","global","canvasGradient","createRadialGradient","STYLE_COMMON_PROPS","host","shadowBlur","shadowOffsetX","shadowOffsetY","font","fontStyle","fontWeight","fontSize","fontFamily","textTag","textStroke","textWidth","textHeight","textStrokeWidth","textLineHeight","textOffset","textVerticalAlign","textShadowColor","textShadowBlur","textShadowOffsetX","textShadowOffsetY","textBoxShadowColor","textBoxShadowBlur","textBoxShadowOffsetX","textBoxShadowOffsetY","transformText","textRotation","textOrigin","textBackgroundColor","textBorderColor","textBorderWidth","textBorderRadius","textPadding","rich","truncate","blend","prevStyle","firstDraw","styleName","globalAlpha","globalCompositeOperation","otherStyle","newStyle","method","addColorStop","styleProto","guid","Transformable","Animatable","ignore","clipPath","drift","dx","dy","decomposeTransform","beforeUpdate","afterUpdate","update","updateTransform","setClipPath","zr","addSelfToZr","removeClipPath","removeSelfFromZr","animators","animation","addAnimator","removeAnimator","idStart","arrySlice","_$handlers","one","handler","_h","h","isSilent","newList","l","argLen","triggerWithContext","isNotAroundZero","EPSILON","mIdentity","transformableProto","needLocalTransform","parentHasTransform","create","invTransform","dpr","tmpTransform","sx","sy","v2","transformCoordToGlobal","rotate","out","ArrayCtor","m1","m2","out0","out1","out2","out3","out4","out5","translate","a","rad","aa","ac","atx","ab","ad","aty","st","ct","vx","vy","det","Float32Array","b","v1","scaleAndAdd","lenSquare","div","dot","s","normalize","d","distanceSquare","negate","lerp","t","lengthSquare","dist","distSquare","Animator","log","_util","animatingShape","pathSplitted","animator","during","done","stopAnimation","forwardToLast","time","delay","easing","forceAnimate","count","_animateToShallow","objShallow","propertyCount","when","defaultGetter","defaultSetter","interpolateNumber","p0","p1","percent","interpolateString","interpolateArray","arrDim","len2","fillArr","arr0","arr1","arr0Len","arr1Len","isPreviousLarger","arraySlice","isArraySame","catmullRomInterpolateArray","p2","p3","t2","t3","catmullRomInterpolate","v0","cloneValue","ret","rgba2String","rgba","join","getArrayDim","keyframes","lastValue","createTrackClip","oneTrackDone","propName","getter","_getter","setter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","sort","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","parse","_target","lastFrame","lastFramePercent","onframe","frame","range","clip","Clip","life","_loop","_delay","ondestroy","_tracks","_clipCount","_doneList","_onframeList","_clipList","tracks","pause","_paused","resume","isPaused","_doneCallback","doneList","lastClip","self","clipCount","addClip","oldOnFrame","clipList","removeClip","getClips","_life","_initialized","gap","onrestart","_pausedTime","easingFuncs","globalTime","deltaTime","_startTime","easingFunc","schedule","fire","restart","_needsRemove","remainder","eventType","arg","linear","k","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","sinusoidalOut","sinusoidalInOut","exponentialIn","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","asin","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","clampCssByte","clampCssAngle","clampCssFloat","parseCssInt","parseCssFloat","cssHueToRgb","lerpNumber","setRgba","g","copyRgba","putToCache","colorStr","rgbaArr","lastRemovedArr","colorCache","put","cached","toLowerCase","kCSSColorTable","op","ep","fname","alpha","pop","hsla2rgba","iv","hsla","rgba2hsla","H","S","R","G","B","vMin","vMax","delta","deltaR","deltaG","deltaB","level","colorArr","toHex","fastLerp","normalizedValue","colors","leftIndex","rightIndex","ceil","leftColor","rightColor","dv","fullOutput","modifyHSL","modifyAlpha","arrColor","LRU","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","fastMapToColor","mapToColor","LinkedList","head","tail","_len","linkedListProto","insert","entry","Entry","insertEntry","next","prev","maxSize","_list","_map","_maxSize","_lastRemovedEntry","LRUProto","list","removed","leastUsedEntry","_config","debugMode","console","textHelper","tmpRect","normalizeTextStyle","needDrawText","save","renderText","restore","normalizeStyle","makeFont","VALID_TEXT_ALIGN","VALID_TEXT_VERTICAL_ALIGN","hostEl","renderRichText","renderPlainText","setCtx","DEFAULT_FONT","contentBlock","__textCotentBlock","parsePlainText","outerHeight","textLines","boxPos","getBoxPosition","baseX","baseY","applyTextRotation","boxY","adjustTextY","textX","textY","needDrawBg","needDrawBackground","outerWidth","boxX","adjustTextX","drawBackground","getTextXForPadding","getStroke","getFill","strokeText","fillText","parseRichText","drawRichText","contentWidth","xLeft","lineTop","xRight","token","tokens","tokenCount","usedWidth","lineXLeft","lineXRight","placeToken","tokenStyle","isLineHolder","isPlainBg","roundRectHelper","closePath","imageHelper","createOrUpdateImage","onBgImageLoaded","isImageReady","drawImage","blockHeiht","parsePercent","adjustTextPositionOnRect","maxValue","lastIndexOf","middle","textWidthCache","measureText","textWidthCacheCounter","TEXT_CACHE_MAX","getRichTextRect","getPlainTextRect","halfHeight","truncateText","containerWidth","ellipsis","prepareTruncateOptions","truncateSingleLine","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","ellipsisWidth","textLine","subLength","estimateLength","charCode","charCodeAt","getLineHeight","truncOuterHeight","truncOuterWidth","STYLE_REG","exec","matchedIndex","pushTokens","contentHeight","pendingList","stlPadding","truncateWidth","truncateHeight","tokenHeight","tokenWidth","tokenWidthNotSpecified","percentWidth","bgImg","findExistImage","paddingW","remianTruncWidth","block","isEmptyStr","strs","tokensLen","vec2","v2ApplyTransform","mathMin","mathMax","union","other","lt","rb","lb","rt","intersect","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","plain","newImageOrSrc","cachedImgObj","globalImageCache","cbPayload","__zrImageSrc","pendingWrap","pending","onload","imageOnLoad","__cachedImgObj","src","r1","r2","r3","r4","total","moveTo","lineTo","quadraticCurveTo","curve","bbox","min2","max2","mathAbs","hasTypedArray","notSaveData","_saveData","_xi","_yi","_x0","_y0","_ux","_uy","_lineDash","_dashOffset","_dashIdx","_dashSum","exceedUnit","_needsDash","_dashedLineTo","bezierCurveTo","x3","y3","_dashedBezierTo","_dashedQuadraticTo","arc","startAngle","endAngle","anticlockwise","arcTo","radius","x0","y0","lineDashSum","appendSize","appendPathData","_expandData","_prevCmd","newData","dash","idx","dashSum","nDash","cubicAt","bezierLen","tmpLen","MAX_VALUE","xi","yi","fromLine","fromCubic","fromQuadratic","fromArc","ux","uy","scaleX","scaleY","isEllipse","isAroundZero","onet","cubicDerivativeAt","cubicRootAt","roots","t1","disc","K","discSqrt","Y1","Y2","mathPow","ONE_THIRD","T","ASqrt","tmp","THREE_SQRT","cubicExtrema","extrema","cubicSubdivide","p01","p12","p23","p012","p123","p0123","cubicProjectPoint","d1","d2","interval","Infinity","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","quadraticAt","quadraticDerivativeAt","quadraticRootAt","quadraticExtremum","divider","quadraticSubdivide","quadraticProjectPoint","_vector","v2Create","fromPoints","xDim","yDim","tx","ty","vec2Min","vec2Max","diff","PI2","extremity","isAroundEqual","swapExtrema","windingCubic","nRoots","y0_","y1_","nExtrema","unit","x_","windingQuadratic","y_","windingArc","dir","normalizeRadian","containPath","isStroke","windingLine","cubic","quadratic","_x","_l","_a","_b","_s","_curve","repeat","createPattern","nPoint","mathAtan2","_dragStart","_drag","_dragEnd","topTarget","_draggingTarget","_y","dispatchToElement","dropTarget","findHover","lastDropTarget","_dropTarget","_children","__storage","isGroup","childAt","childCount","_doAdd","addBefore","nextSibling","storage","addToStorage","addChildrenToStorage","delFromStorage","delChildrenFromStorage","removeAll","includeChildren","tmpMat","childRect","ZImage","_image","sWidth","sHeight","shadowColor","fixClipWithShadow","r0","clockwise","unitX","unitY","orignalBrush","env","browser","ie","modified","clipPaths","shadowTemp","detect","ua","os","firefox","match","edge","weChat","canvasSupported","svgSupported","SVGRect","touchEventsSupported","pointerEventsSupported","navigator","userAgent","polyHelper","smooth","smoothConstraint","controlPoints","smoothBezier","cp1","cp2","smoothSpline","interpolate","isLoop","v2Distance","segs","w2","w3","constraint","prevPoint","nextPoint","cps","v2Min","v2Max","v2Clone","v2Sub","v2Scale","d0","sum","cp0","v2Add","pointAt","someVectorAt","isTangent","cpx2","cpy2","cpx1","cpy1","tangentAt","globalCoord","vec2Copy","transitionProperties","TransitionObject","_fromStr","property","GraphicStates","_states","_el","_subStates","_transitionAnimators","initialState","_initialState","optsStates","states","state","_addState","setState","_currentState","transition","_extendFromInitial","transiting","_stopTransition","prevState","onleave","onenter","getState","transitionState","styleShapeReg","propPathMap","transitionCfg","animatingCount","animationDone","_animProp","subProp","subStates","subPropKey","stateObj","elObj","availableProp","transitionAnimators","dealy","addSubStates","removeSubStates","bigCanvas","groupRatio","img","selectPosition","render","eagleEyeNodeWidth","eagleEyeNodeHeight","marginTop","marginLeft","background","backgroundSize","selectWidth","selectHeight","offectLeft","offectTop","newGroup","positionX","positionY","getUUID","chars","uuid","rnd","random","getMaxLineLength","getPolylineLength","lenght","NaN","orthogonalPath","lineIntersectsLine","l1","l2","startPoint","endPoint","contains","a1","b1","a2","b2","polylineIntersectsRectangle","bounds","closedPolyline","tempLine","tempLine1","scorePath","score","signum","forwardPath","traslatePoints","isRevert","newPoints","point1","rotationMatrix","mReturn","translationMatrix","scaleMatrix","getEndPoint","keys","rectNew","position_n_x","position_n_y","controls","calculatePoints","getSoltPoints","tangentRotation","collinearity","precission","determinant","enhancedRound","number","decimals","getLength","getAngle","outsidePoint","atan","isCalcParent","boundRect","randomColor","arrHex","strHex","collinearReduction","cloneArray","template","settings","oldSettings","templateSettings","matcher","escape","noMatch","evaluate","escaper","escapeChar","variable","isEmpty","exclude","Class","StackedMap","createNew","stack","arrKey","removeItem","removeTop","escapes","'","\\","\r","\n"," "," ","proto","member","base","subclass","load","o","newPoint","loadArray","oldX","oldY","equals","anotherPoint","near","getPoints","oType","newLine","contructor","anotherLine","endX","endY","closestX","closestY","getPoint","Xp","Yp","instance","apiList","ZRender","getInstance","registerPainter","painterCtors","delInstance","Handler","Storage","Painter","Animation","HandlerProxy","useVML","canvas","rendererType","vml","painter","handerProxy","getViewportRoot","stage","flush","_needsRefresh","oldDelFromStorage","oldAddToStorage","getId","addRoot","delRoot","configLayer","zLevel","config","refreshImmediately","_needsRefreshHover","refreshHoverImmediately","addHover","refreshHover","clearHover","clearAnimation","pathToImage","setCursorStyle","cursorStyle","eventName","eventHandler","makeEventPacket","eveType","targetInfo","zrX","zrY","gestureEvent","pinchX","pinchY","pinchScale","zrDelta","zrByTouch","which","EmptyProxy","isHover","displayable","SILENT","handlerNames","proxy","painterRoot","_hovered","_lastTouchMoment","_lastX","_lastY","mousemove","lastHovered","lastHoveredTarget","hovered","hoveredTarget","setCursor","mouseout","innerDom","element","toElement","relatedTarget","dispatch","eventArgs","eventPacket","eachOtherLayer","layer","getDisplayList","hoverCheckResult","_downEl","_downPoint","_upEl","shapeCompareFunc","timsort","_roots","_displayList","_displayListLen","includeIgnore","updateDisplayList","displayList","_updateAndAddDisplayable","userSetClipPath","currentClipPath","parentClipPath","_renderList","displayableSortFunc","minRunLength","DEFAULT_MIN_MERGE","makeAscendingRun","lo","hi","compare","runHi","reverseRun","binaryInsertionSort","mid","pivot","gallopLeft","hint","lastOffset","maxOffset","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","length2","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","tmpStorageLength","DEFAULT_TMP_STORAGE_LENGTH","stackLength","remaining","minRun","force","parseInt10","isLayerValid","__builtin__","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","viewRect","isClipPathChanged","prevClipPaths","doClip","createRoot","domRoot","cssText","Layer","requestAnimationFrame","MAX_PROGRESSIVE_LAYER_NUMBER","singleCanvas","nodeName","toUpperCase","_opts","_singleCanvas","rootStyle","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","initContext","_domRoot","_getSize","_progressiveLayers","_hoverlayer","_hoverElements","getType","isSingleCanvas","getViewportRootOffset","viewportRoot","offsetLeft","offsetTop","paintAll","_paintList","_startProgessive","__hoverMir","elMirror","__from","hoverElements","hoverLayer","getLayer","scope","originalEl","_doPaintEl","_progressiveToken","_doPaintList","_furtherProgressive","_progress","_clearProgressive","_updateLayerStatus","eachBuiltinLayer","flushProgressiveLayer","currentLayer","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","elZLevel","elFrame","__frame","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","prevClipLayer","prevElClipPaths","insertLayer","layersMap","prevLayer","virtual","prevDom","insertBefore","firstChild","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","elCount","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","_clearLayer","layerConfig","delLayer","display","clearLayer","getRenderedCanvas","findAndDrawOtherLayer","smaller","larger","intermediateLayer","renderToCanvas","imageLayer","pixelRatio","clearColor","whIdx","wh","cwh","plt","prb","stl","defaultView","getComputedStyle","shadowBlurSize","leftMargin","rightMargin","topMargin","bottomMargin","clearRect","pathTransform","ImageShape","imgShape","returnFalse","createDom","newDom","newDomStyle","domStyle","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","__currentValues","createBackBuffer","clearAll","haveMotionBLur","clearColorGradientOrPattern","__canvasGradient","fillRect","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","_event","Dispatcher","_clips","_running","_time","_pauseStart","clips","_update","getTime","deferredEvents","deferredClips","_startLoop","getBoundingClientRect","clientToLocal","calculate","defaultGetZrXY","layerX","layerY","box","normalizeEvent","isTouch","touch","targetTouches","changedTouches","detail","button","MOUSE_EVENT_REG","isDomLevel2","attachEvent","detachEvent","notLeftMouse","preventDefault","stopPropagation","returnValue","eventNameFix","processGesture","gestureMgr","_gestureMgr","gestureInfo","recognize","setTouchTimer","_touching","clearTimeout","_touchTimer","isPointerFromTouch","pointerType","initDomHandler","makeMouseHandler","touchHandlerNames","_handlers","domHandlers","pointerHandlerNames","mouseHandlerNames","HandlerDomProxy","mountHandlers","GestureMgr","TOUCH_CLICK_DELAY","pointerEventNames","pointerdown","pointerup","pointermove","pointerout","nm","touchstart","mousedown","touchmove","touchend","mouseup","click","handlerDomProxyProto","pointPair","eventUtil","_track","_doTrack","_recognize","touches","trackItem","recognizers","pinch","track","pinchEnd","pinchPre","pinchCenter","api","forbidEdit","Node","icon","symbolUtil","DEL","COMMENT_CLICK","COMMENT","opicons","STRAIGHT","STRAIGHT_SVG","JAGGED","JAGGED_SVG","CURVE","CURVE_SVG","DEL_SVG","COMMENT_SVG","renderBase","renderOther","createOperation","ifShowNodeOperationIcons","operationIcons","_zCloneStyle","setOrCancelSelectStyle","virtualRect","isSelfComputePos","opIconInstance","operationIcon","hidden","rectOther","createSymbol","iconPath","rbPoint","connectorControls","brControl","nodeItem","refreshPositionOther","nodeShapeX","nodeSahpeY","resourceId","drawText","textName","bpmnInfo","refreshText","toJSON","defaultOptions","symbol","size","NORMAL_COLOR","both","SELECTED_COLOR","arrowHoverStyle","startOffset","endOffset","escapeDistance","autoChangePosition","textPos","textRotateable","handles","conPointsGroup","groupCurve","Handle","EffectLine","ConnectionPoint","RADIUS","START_NODE","END_NODE","LEFT","RIGHT","TOP","BOTTOM","SEPERATOR","arrPoints","turningPoints","modifyCurve","lineTextArr","textPoint","getTextPostion","way","rate","getTextRotation","deg","refreshFromToSymbol","renderFromToSymbol","curveLine","polyLine","createHoverStyle","createAllconnectionPoint","shapeSetHandle","buildMenu","symbolTo","symbolFrom","effect","distanceFrom","notSaveModel","textPostion","arrOffset","midPoint","connectionPointCreate","TYPE_CONNECTOR","conPoint","clearHandles","handleShape","isCollineaityFirst","isCollineaitySecond","symbolType","symbolSize","symbolZIndex","symbolPath","middleX","middleY","ellapsedDistance","segment","missingDistance","error","walked","rest","currentSegmentLength","segmentPercent","refreshModel","iconNode","sol","getCurvePoint","willDelCurves","cntCurve","cure","P","divide","nr","callee","multiply","q1","q_01","q_02","q_03","q0","q2","q_31","q_32","q_33","q3","Triangle","Diamond","Pin","tanX","tanY","cpLen","cpLen2","Arrow","symbolCtors","roundRect","square","circle","diamond","pin","triangle","symbolShapeMakers","symbolBuildProxies","Symbol","proxySymbol","symbolPathSetColor","symbolStyle","symbolShape","__isEmptyBrush","setColor","visible","actionConnector","anotherHandle","newX","newY","deltaY","deltaX","_lastFrame","_lastFramePercent","initSymbol","curveUtil","EffectLineProto","period","__t","groupCurveAnimate","updateSymbolPositionPolyline","setAnimationPointsPolyline","setAnimationPointsBezierCurve","updateSymbolPositionBezierCurve","__p1","__p2","__cp1","__cp2","_points","accLenArr","_offsets","_length","__lastFramePercent","offsets","OVER_COLOR","CONNECTED_COLOR","TYPE_FIGURE","anotherConnectionPoint","parentModel","extraOpt","clazzUtil","getDefaultOption","optList","defaultOption","__defaultOption","mergeOption","ignoreParent","fieldName","fieldArray","currentRef","thisParentModel","restoreData","enableClassExtend","superCall","methodName","superApply","TYPE_DELIMITER","IS_CONTAINER","parseClassType","componentType","main","RootClass","preConstruct","ExtendedClass","enableClassManagement","entity","makeContainer","container","registerClass","Clazz","getClass","componentTypeMain","subType","throwWhenNotFound","getClassesByMainType","hasClass","getAllClassMainTypes","hasSubTypes","registerWhenExtend","originalExtend","IconOperation","CHANGE_LINE_TYPE_SVG","ConnectionManager","bundleOffset","bundleGap","handleConnectorEvent","handleConnectorShrink","arrCons","arrStartEndPoint","getStartEndPoint","unshift","refreshConnector","refreshCons","handleConnectorPoints","handleConnectorModel","arrSplit","selected","CONNECTION","START_ID","END_ID","isShrink","con","half","oPoints","refreshConsStraight","arrConnectResult","sRect","eRect","sConnectorPoint","eConnectorPoint","secondPoint","thirdPoint","upHalf","secPoint","thdPoint","boundOffsetXY","isPositive","resultPoint","setModel","startNodeOutgoing","countLinePos","toggleLineByNode","isShow","connection","startPosNow","posIsChange","endPosNow","newPos","tempConnector","Log","solutions","connector2Points","isNotInSameGroup","sBounds","eBounds","calcPointExpression","expression","figureEscapeDistance","info","startExitPoint","endExitPoint","potentialExits","gapIndex","s0","s1","s1_1","s1_2","s2_1","s2_1_1","s2_1_2","s2_2","s2_2_1","s2_2_2","s2_3","eastExits","eastExit","s2_3_1","s2_3_2","s2_4","northExits","northExit","s2_4_1","s2_4_2","s2_5","westExits","westExit","s2_5_1","s2_5_2","s2_6","southExits","southExit","s2_6_1","s2_6_2","orthogonalSolution","solution","forwardSolutions","temp","nonIntersectionSolutions","innerLines","firstSolution","nrOfPoints","sameNrPointsSolution","solIndex","smoothCurve","groupEnd","solTurningPoints","startMiddlePoint","getMiddle","a3","a4","endMiddlePoint","solType","reducedSolution","LOG_LEVEL_NONE","LOG_LEVEL_DEBUG","LOG_LEVEL_INFO","LOG_LEVEL_ERROR","debug","title","RELATION_IMAGE","GROUP","GROUP_NODE","TREE_ROOT","DOCKERS","STYLE_LINETYPE","LINEOPERATIONICON","LINK","FOLD","jsonArr","childArr","fishTopoflow","childShapes","isChild","relationNode","findNodeById","relationId","createdGroup","nodeForLayout","startNodeId","endNodeId","thisLink","createByPoint","retNode","url","nodeCtors","Ellipse","Heart","Droplet","Rose","Isogon","Star","Trochoid","IconButton","_trim","all","toCamelCase","upperCaseFirst","group1","formatTpl","tpl","paramsList","encode","seriesLen","$vars","alias","TPL_VAR_ALIAS","wrapVar","encodeHTML","seriesIdx","makeGetter","hostObj","varName","genModel","RECT_NAME","setLayout","Layout","run","minLength","nowNodePosition","isIcon","relationImagePosition","cloneImagePosition","ifParse","scaleRatio","newW","newH","onEmphasis","onNormal","newR","jQuery","resultDeferrd","Deferred","promise","isLoaded","reject","sx2","sy2","resolve","ZText","newR0","ox","oy","newRx","newRy","newWidth","newHeight","radian","dStep","pointsNew","newX1","newX2","newY1","newY2","curveTool","xStart","yStart","ri","location","num","newD","ZPath","borderColor","borderWidth","itemSize","showTitle","iconStyle","normal","emphasis","__title","Fold","Curve","translateLinkOptions","FLOW_TYPE","RECT","IMAGE","TEXT","CIRCLE","SECTOR","RING","POLYGON","POLYLINE","LINE","BEZIERCURVE","ARC","SCENE","getUserData","isRect","isImage","isText","isCircle","arrPos","lineOperations","lineOperation","creatOperation","pointPosition","arrLength","totalLength","previousValue","currentValue","connectorPosition","attachLine","flowUtil","HLayout","VLayout","TreeLayout","ForceLayout","Tree","addCustomLayout","customLayout","getLayoutRect","positionInfo","containerRect","margin","containerHeight","verticalMargin","horizontalMargin","hv","elPos","currentLineMaxSize","nextX","nextChild","nextChildRect","newline","maxHeight","nextY","orient","nodePadding","layerPadding","rootLocation","animateTime","lineStyle","fishTopo","_layerOffsets","_hideNodes","TreeData","TreeHelper","layoutByRootNode","rootNode","traverseNode","treeData","childrenData","nodeData","rootTreeData","doLayout","isNotBuildLink","rootData","tree","fromOptionData","_buildNode","_setTreeShape","_buildAllLink","treeNode","_buildLinkByParent","createLinkFunction","doneCallback","animateCount","treeHelper","rootX","rootY","zrWidth","zrHeight","originRootX","treeNodeCount","__x","__y","_toggleShrink","createNodeFunction","_defaultCreateNodeFunction","_childShow","lable","parentTreeNode","childLength","_buildLink","startTreeNode","endTreeNode","paramObj","linkStyle","addChild","newTreeNode","refreshPositionAndLine","toggleChild","toggleTreeNode","findTreeNodeByNode","returnTreeNode","eachTreeNode","_hideToggle","removeChildren","removeAllChildren","updateDepthAndHeight","changePosition","targetIndex","nowIndex","TreeNode","depth","getNodeById","getSubTree","buildHierarchy","dataNode","fromDataSource","dataSource","rootItem","_findChildItem","childItem","childTreeNode","treeNodesMap","to","_updateNodeXPosition","_updateNodeYPosition","_shiftSubtree","prevLayerHeight","layerHeight","repulsion","gravity","edgeLength","once","layoutAnimation","preservedPoints","forceHelper","forceData","allLinks","_buildLinks","links","_forceIns","_startForceLayoutIteration","autoLayout","datas","fish","_addNodeEvent","forceLayout","warmUp","_layouting","setFixed","setUnfixed","rep","n1","n2","curveness","forceInstance","oldStep","fixed","stopped","_layoutTimeout","edges","pp","friction","v12","nLen","repFact","config_default","thread","linkHead","linkNode","pool","emptyFn","tries","_helpers","setAttr","dataset","getAttr","initPool","notice","getNode","executeLink","onerror","appendNode","free","status","setSrc","shiftNode","getFree","setNode","_load","srcs","success","_info","task","TooltipView","tooltipModel","_tooltipContent","TooltipContent","_tooltipModel","_alwaysShowContent","_initGloablListener","calcTooltipPosition","contentSize","domWidth","domHeight","rectWidth","rectHeight","refixTooltipPosition","viewWidth","viewHeight","gapH","gapV","clientHeight","isCenterAlign","align","confineTooltipPosition","globalListener","triggerOn","register","currTrigger","_tryShow","_hide","_showComponentItemTooltip","_lastDataByCoordSys","uid","manuallyHideTip","unregister","tooltipContent","hideLater","tooltipOpt","formatter","subTooltipModel","defaultHtml","asyncTicket","_showOrMove","_showTooltipContent","_showTimout","positionExpr","_ticket","html","cbTicket","setContent","_updatePosition","getSize","vAlign","viewSize","layoutRect","pos1","pos2","assembleTransition","transitionCurve","transitionText","vendors","vendorPrefix","assembleFont","assembleCssText","transitionDuration","zrColor","borderName","camelCase","_container","_show","_hideTimeout","onmouseenter","_enterable","_inContent","onmousemove","onmouseleave","_hideDelay","gCssText","currentStyle","setEnterable","enterable","initGlobalListeners","useHandler","dis","makeDispatchAction","records","record","dispatchTooltipFinally","pendings","initialized","doEnter","onLeave","actuallyPayload","showLen","showTip","hideLen","hideTip","showContent","alwaysShowContent","displayMode","confine","showDelay","hideDelay","borderRadius","extraCssText","_zrender","vmlCore","comma","imageTransformPrefix","Z2","ZLEVEL_BASE","Z_BASE","initRootElStyle","coordsize","coordorigin","encodeHtmlAttribute","rgb2Str","append","getZIndex","setColorAndOpacity","getColorAndAlpha","updateFillNode","zrEl","gradientType","expansion","dimension","stops","cs1","cs2","colorAndAlphaList","colorAndAlpha","color1","color2","opacity1","opacity2","focusposition","updateStrokeNode","dashstyle","updateFillAndStroke","vmlEl","isFill","getElementsByTagName","pathDataToString","cmdStr","dataLength","brushVML","vmlRoot","_vmlEl","needTransform","strokeEl","weight","zIndex","removeRectText","onRemove","onAdd","appendRectText","tagName","ow","oh","_imageSrc","_imageWidth","_imageHeight","imageRuntimeStyle","runtimeStyle","oldRuntimeWidth","oldRuntimeHeight","dw","dh","sw","sh","hasCrop","doc","vmlElStyle","hasRotation","transformFilter","imageEl","_imageEl","cropEl","_cropEl","imageELStyle","tmpImage","cropElStyle","filterStr","textMeasureEl","DEFAULT_STYLE_NORMAL","fontStyleCache","fontStyleCacheCount","MAX_FONT_CACHE_SIZE","fontEl","getFontStyle","fontString","variant","fontVariant","family","body","ex","createTextNode","fromTextEl","verticalAlign","textPathEl","skewEl","textVmlEl","_textVmlEl","textpathok","coords","textVmlElStyle","string","doCreateNode","initVML","vmlInited","styleSheets","createStyleSheet","addRule","urn","win","namespaces","zrvml","VMLPainter","vmlViewport","_vmlRoot","_vmlViewport","_firstPaint","createMethodNotSupport","zrLog","__alreadyNotVisible","_getWidth","_getHeight","vmlViewportStyle","paddingLeft","paddingRight","paddingTop","paddingBottom"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,SAAAA,OAAAC,IACAD,UAAAH,GACA,gBAAAC,SACAA,QAAA,aAAAD,IAEAD,EAAA,aAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAP,WACAS,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,EAAAA,EAAAD,QAAAM,GAGAL,EAAAS,QAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDgBM,SAAUL,EAAQD,EAASM,GAEhCL,EAAOD,QAAUM,EAAoB,IAKhC,SAAUL,EAAQD,EAASM,GE1DjCL,EAAAD,QAAAM,EAAA,GAEAA,EAAA,MFoEM,SAAUL,EAAQD,EAASM,GGqCjC,QAAAS,GAAAC,EAAAC,GACAb,KAAAK,GACAL,KAAAc,MAAA,KACAd,KAAAe,KAAAH,EACAZ,KAAAgB,QAAA,EACAhB,KAAAiB,UAAA,EACAjB,KAAAkB,UAAA,EACAlB,KAAAmB,aAAA,KACAnB,KAAAoB,eAAA,EACApB,KAAAqB,cAAA,KACArB,KAAAsB,KAAA,EACAtB,KAAAuB,YACAvB,KAAAwB,aAAA,KACAxB,KAAAyB,YACAzB,KAAA0B,QAAA,KACA1B,KAAA2B,KAAA,GAAAC,GAAA5B,MACAA,KAAA6B,kBAAA,GAAAC,GAAA9B,KAAA2B,MACA3B,KAAA+B,qBAAA,GAAAC,GAAAhC,KAAA6B,kBAAA7B,KAAA2B,MACA3B,KAAAiC,IAAAC,EAAAC,KAAAvB,GACAwB,SAAAvB,EAAAuB,UAAA,SACAC,iBAAAxB,EAAAwB,mBAEArC,KAAAsC,aAAA,GAAAC,GAAA,GAAAC,GAAA3B,EAAA4B,SAAAzC,KAAA2B,MACA3B,KAAA0C,MAAAC,EACA3C,KAAA4C,WACA5C,KAAA6C,iBACA7C,KAAA8C,MAAA,GAAAC,OACA/C,KAAA8C,MAAAE,IAAAC,EAAAC,aAAA,SACAlD,KAAA8C,MAAAE,IAAAC,EAAAE,KAAA,UACAnD,KAAAoD,QAAAvC,EACAb,KAAAqD,WACAC,GAAA,YACAC,GAAA,YACAC,GAAA,YACAC,GAAA,YACAC,IAAA,+iBAEA1D,KAAA2D,YACA,WACA,YACA,WACA,YACA,WACA,YACA,WACA,aAEA3D,KAAA4D,cACAL,GAAA,EACAE,GAAA,EACAD,GAAA,EACAF,GAAA,GAEAO,EAAAtD,KAAAP,MAjFAE,EAAA,EACA,IAAAyC,GAAAzC,EAAA,GACA4D,EAAA5D,EAAA,IACA6D,EAAA7D,EAAA,IACA8D,EAAA9D,EAAA,IACA0B,EAAA1B,EAAA,IACA2D,EAAA3D,EAAA,IACAgC,EAAAhC,EAAA,IACA+D,EAAA/D,EAAA,GACAgE,EAAAhE,EAAA,IACA4B,EAAA5B,EAAA,IACAiE,EAAAjE,EAAA,IACA+C,EAAA/C,EAAA,IACA6C,EAAA7C,EAAA,IACAkE,EAAAlE,EAAA,IACAmE,EAAAnE,EAAA,IACA8B,EAAA9B,EAAA,KACAoE,EAAApE,EAAA,KACAqE,EAAArE,EAAA,IACAsE,EAAAtE,EAAA,IACAuE,EAAAvE,EAAA,KACAwE,EAAAxE,EAAA,KACAyE,EAAAzE,EAAA,IACA0E,EAAA1E,EAAA,KACAqC,EAAArC,EAAA,KACAsC,EAAAtC,EAAA,KACA2E,KACAC,GAAmBC,MAAA,GAAAC,OAAA,IAyDnBC,EAAAtE,EAAAuE,SAMAD,GAAAE,OAAA,WACA,MAAAnF,MAAAe,MAMAkE,EAAAG,MAAA,WACA,MAAApF,MAAAiC,KAMAgD,EAAAI,SAAA,WACA,MAAArF,MAAAiC,IAAAoD,YAOAJ,EAAAK,UAAA,WACA,MAAAtF,MAAAiC,IAAAqD,aAQAL,EAAAM,WAAA,WACA,MAAAvF,MAAAwF,WAMAP,EAAAQ,QAAA,WACAzF,KAAAwF,WAAA,EAEAxF,KAAAiC,IAAAwD,UAEAC,EAAA1F,KAAAK,IAAA,MASA4E,EAAAU,OAAA,WACA3F,KAAAiC,IAAA0D,UAIAV,EAAAW,eAAA,SAAAC,IACAhB,EAAAgB,EAAAC,OAWAb,EAAAc,OAAA,SAAAC,EAAAC,GACA,GAAAnD,GAAA,GAAAC,GAAA/C,KAAAoD,QACA,OAAA,KAAA8C,UAAAC,OACAlC,EAAAmC,MAAApG,KAAAoD,SACS,IAAA8C,UAAAC,OACTrD,EAAAuD,IAAAL,GACS,IAAAE,UAAAC,QACT,SAAAH,GACAhG,KAAAsG,QAAAL,GAEAnD,EAAAE,IAAAgD,EAAAC,IAJS,QASThB,EAAA9C,KAAA,WACA,GAAAoE,GAAA,gBAAAC,SAAA,aAAA,YAAA,aAAA,YAAA,YAAA,UACAxG,MAAAc,MAAA,GAAA6B,GAAA8D,MACAzG,KAAAc,MAAAgC,MAAA9C,KAAA8C,MACA9C,KAAAc,MAAA4F,MAAA,EACA1G,KAAAiC,IAAA0E,IAAA3G,KAAAc,OAGAd,KAAAoD,QAAAwD,QAAA,GACA5G,KAAA6G,UAGA7G,KAAA6B,kBAAAiF,cAEA9G,KAAAiC,IAAA8E,GAAA,UAAA,SAAAC,GAIA,GAAAC,GAAAD,EAAAE,MACAD,IAAAA,EAAAnE,OAAAwB,EAAA6C,OAAAF,EAAAnE,QAGAmE,GAAAA,EAAAG,oBAAA/C,KAIArE,KAAA6B,kBAAAwF,iBAEAJ,GAAAA,EAAAK,sBAAA,GAAAL,EAAAK,sBAIAtH,KAAA+B,qBAAAwF,yBACSC,KAAAxH,OAETA,KAAAiC,IAAA8E,GAAA,QAAA,SAAAC,GAEA,GAAAE,GAAAF,EAAAE,WACApB,EAAAoB,EAAApB,IACA,IAAA,uBAAAA,GAAA,mBAAAA,EAAA,CACA9F,KAAAyH,qBACAzH,KAAA0H,uBACA1H,KAAA2H,sBACA,IACAV,GADAW,EAAAZ,EAAAE,MAKA,IAHAU,IACAX,EAAAW,EAAA9E,OAEA8E,GAAAX,GAAA3C,EAAA6C,OAAAF,IAAAW,GAAAX,GAAA3C,EAAAuD,OACAZ,GACA,OAGA,GAAAa,KACAA,GAAAC,MAAAf,EACAc,EAAAhC,KAAA,QACAgC,EAAAZ,OAAAlH,KACAA,KAAA2B,KAAAqG,QAAAF,EAAAhC,KAAAgC,IACSN,KAAAxH,OAGTA,KAAAiC,IAAA8E,GAAA,YAAA,SAAAC,GACA,GAAA,gBAAAhH,KAAAoD,QAAA6E,UAAA,CACA,GAAAjB,EAAAE,QAAAF,EAAAE,OAAApE,OACAkE,EAAAE,QAAAF,EAAAE,OAAAgB,UAAAlB,EAAAE,OAAAiB,QACAnB,EAAAE,QAAAF,EAAAE,OAAAE,oBAAA/C,IACA2C,EAAAE,QAAAF,EAAAE,iBAAAvE,GAAAyF,QACApB,EAAAE,QAAA,oBAAAF,EAAAE,OAAAmB,KACA,MAEArI,MAAAyH,qBACAzH,KAAA0H,uBACA1H,KAAA2H,uBACA3H,KAAAsI,YAAAtB,EAAAE,OAAAF,EAAAuB,QAAAvB,EAAAwB,SAIA,GAAA,cAAAxI,KAAAoD,QAAA6E,UAAA,CACA,GAAAjB,EAAAE,QAAAF,EAAAE,OAAApE,OAAAkE,EAAAE,QAAAF,EAAAE,OAAAgB,UAAAlB,EAAAE,OAAAiB,QACAnB,EAAAE,QAAAF,EAAAE,OAAAE,oBAAA/C,IAAA2C,EAAAE,QAAAF,EAAAE,iBAAAvE,GACAyF,OACA,MAEApI,MAAAyI,kBAAAzB,EAAAuB,QAAAvB,EAAAwB,WAGShB,KAAAxH,OAETA,KAAA+G,GAAA,uBAAA,SAAA2B,GACA1I,KAAA+B,qBAAA4G,cAAAD,EAAAE,WACSpB,KAAAxH,OAETiE,EAAA4E,KAAAtC,EAAA,SAAAuC,GACA9I,KAAAiC,IAAA8E,GAAA+B,EAAA,SAAA9B,GACA,GAAAc,KACAA,GAAAC,MAAAf,EACAc,EAAAhC,KAAAgD,EACAhB,EAAAZ,OAAAlH,KACAA,KAAA2B,KAAAqG,QAAAF,EAAAhC,KAAAgC,IACa9H,OACJA,OAGTiF,EAAAqB,QAAA,SAAAL,GACAjG,KAAAiC,IAAA8G,IAAA,cACA9C,KAAA,GACAjG,KAAA6G,WAIA5B,EAAA+D,cAAA,SAAAC,GACA,GAAAC,GAAAlJ,IACAiJ,GAAAE,UAAA,SAAAC,GACA,GAAAA,EAAAtG,OACAsG,YAAA5E,IACA4E,EAAAtG,QAAAsG,EAAAtG,MAAAiD,OAAAsD,QAAAD,EAAAE,WAAAnD,OAAA,EAAA,CACA,GAAAkD,KACAD,GAAAD,UAAA,SAAAI,GACAA,EAAAzG,QACAyG,YAAA/E,KACA+E,EAAAzG,MAAAiD,OAAAsD,QAAAE,EAAAD,WAAAnD,OAAA,GACA+C,EAAAF,cAAAI,GAGAC,EAAAG,KAAAD,EAAAzG,MAAAiD,QACAqD,EAAAtG,MAAAiD,OAAAsD,OAAAA,SAcApE,EAAAwE,OAAA,WAEA,MADAzJ,MAAAgJ,cAAAhJ,KAAAc,OACAqD,EAAAsF,OAAAzJ,KAAA8C,MAAA9C,KAAAc,QASAmE,EAAAyE,SAAA,SAAAC,EAAAC,GACA5J,KAAA6J,OAAA,EACA,IAAA/G,GAAA,GAAAC,GAAA4G,EACA3J,MAAA8J,cAAAhH,EAAAuD,IAAApD,EAAA8G,YACA,IAAAC,KACA7F,GAAAuF,SAAA1J,KAAAA,KAAAc,MAAAgC,EAAAuD,IAAApD,EAAAgH,SAAA,EAAAD,EAAAJ,IAyBA3E,EAAA0B,IAAA1B,EAAAiF,QAAA,SAAAd,EAAAhG,EAAAwG,GACA,IAAAR,EAAA,MAAA,KAEA,IAAAe,GAAA/G,KACA,IAAA+G,EAAAnC,WAAA,IAAAhI,KAAAoK,SAAA,gBAAoElD,OAAAkC,IACpE,MAAA,KAEA,IAAAA,YAAA/E,GACArE,KAAAqK,sBAAAjB,OACS,CACT,GAAA9E,EAAAgG,YAAAlB,GAAA,CACAA,EAAAmB,WAAAvK,KAAA2B,KACA,IAAA6I,GAAApB,EAAAtG,MAAAuD,IAAApD,EAAAwH,QACA,IAAAD,EAAAE,YAAA,CACA,GAAAC,GAAA,GAAApG,GAAAqG,OACAC,OACAC,MAAAN,EAAAE,YACAK,KAAAP,EAAAK,MAAAE,KACAC,aAAA,UAEAC,sBAEAjL,MAAAkL,KAAAP,GACAvB,EAAA+B,eAAAR,EACA3K,KAAAc,MAAA6F,IAAAgE,GACAS,WAAA,WACAT,EAAAU,QACqB,KACrBjC,EAAArC,GAAA,WAAA,WACAqC,EAAAkC,WAIAlC,EAAAP,KAAA,SAAA0C,GACAvL,KAAAwL,cAAApC,EAAAmC,IACiBvL,MAEjBA,KAAAyL,iBAAArC,GAAA,GAkBA,MAhBApJ,MAAAoK,SAAA,UAAiClD,OAAAkC,IAEjCA,EAAAsC,YACA/I,EAAAgJ,cAAAvC,GAGApJ,KAAAc,MAAA6F,IAAAyC,GACAA,EAAAwC,UACA5L,KAAA6L,uBAAAzC,GAEAA,EAAA0C,gBAAA9L,KAAAoD,QAAA2I,oBACAxH,EAAAyH,kBAAA5C,GAEA,GAAAQ,GACA5J,KAAAiM,cAEA7C,GAIAnE,EAAAuG,cAAA,SAAAvC,EAAAsC,GACAA,YAAAlH,GACArE,KAAAqK,sBAAAkB,IAEAvL,KAAAyL,iBAAAF,EAAAtC,EAAA7F,QAAA8I,gBACAnI,EAAAoI,YAAAZ,EAAAa,cACAb,EAAAa,YAAA,GAEAb,EAAAK,UACA5L,KAAA6L,uBAAAN,GAEAA,EAAAG,YACA/I,EAAAgJ,cAAAJ,IAGAvL,KAAAoK,SAAA,UAAiClD,OAAAqE,KAUjCtG,EAAAoH,eAAA,SAAAC,EAAAvB,GACA,GAAAuB,EAAAlJ,QAAAyH,MAAA3C,WAAA7D,EAAAkI,WAAA,CACAvM,KAAA6B,kBAAA2K,WAAAF,EAAAtM,KAAAyM,aAAAH,IACAA,EAAAlJ,QAAA2H,KAAAA,KAAAvB,KAAAuB,GACAuB,EAAAlJ,QAAAsJ,gBAAAJ,EAAAnC,IAAAuC,eACA,IAAAC,GAAA,GAAAlI,GAAAmI,MAAAN,EAAAO,UAAAP,EAAAQ,QAAAR,EAAAlJ,QAEA,OADApD,MAAA2G,IAAAgG,GACAA,IAUA1H,EAAA8H,eAAA,SAAAC,GACA,GAAAC,GAAA5M,EAAA2M,EAAA3M,GAAAiM,EAAAU,EAAA7E,MACA,IAAAmE,EAAAlJ,QAAAyH,MAAA3C,WAAA7D,EAAAkI,YAAAtI,EAAAiJ,QAAAZ,EAAAlJ,QAAA2H,KAAAA,MAAA,CACAuB,EAAAlJ,QAAA2H,KAAAA,KAAAoC,QAAA,SAAAC,EAAAC,GACAD,EAAAE,SAAAjN,IACA4M,EAAAI,KAGAf,EAAAlJ,QAAA2H,KAAAA,KAAAwC,OAAAN,EAAA,GAEAjN,KAAA6B,kBAAA2K,WAAAF,EAAAtM,KAAAyM,aAAAH,IACAA,EAAAlJ,QAAAsJ,gBAAAJ,EAAAnC,IAAAuC,eACA,IAAAC,GAAA,GAAAlI,GAAAmI,MAAAN,EAAAO,UAAAP,EAAAQ,QAAAR,EAAAlJ,QAEA,OADApD,MAAA2G,IAAAgG,GACAA,IAUA1H,EAAAuI,kBAAA,SAAAR,EAAA3E,GACA,GAAAhI,GAAA2M,EAAA3M,GAAAiM,EAAAU,EAAA7E,MACAmE,GAAAlJ,QAAAyH,MAAA3C,WAAA7D,EAAAkI,YAAAtI,EAAAiJ,QAAAZ,EAAAlJ,QAAA2H,KAAAA,QACAuB,EAAAlJ,QAAA2H,KAAAA,KAAAoC,QAAA,SAAAC,EAAAC,GACAD,EAAAE,SAAAjN,IACA+M,EAAArC,KAAA1C,KAGA2E,EAAAS,SAAA,OAAApF,KASApD,EAAAyI,qBAAA,SAAAtE,EAAAtD,GACA,GAAA6H,GAAA3N,KAAA6B,kBAAAiF,UACA7C,GAAAiJ,QAAAS,IACAA,EAAAR,QAAA,SAAAb,GACAA,EAAAO,UAAAxM,KAAA+I,EAAA/I,KACA,SAAAyF,EAAAwG,EAAAjB,OAAAiB,EAAAsB,WAMA3I,EAAAoF,sBAAA,SAAAjD,GACA,GAAA8B,GAAAlJ,KACA6N,EAAA,IACA,IAAAzG,EAAAhE,QAAAyH,MAAA3C,WAAA7D,EAAAkI,WAAA,CACA,GAAAvG,GAAAhG,KAAA6B,kBAAAiM,aAAA1G,EAAAyF,UAAAzF,EAAA0F,QAAA1F,EAAAhE,QAAA6H,UACA8C,EAAA/N,KAAA6B,kBAAAmM,aAAA3H,IAAAL,GACAiI,KAAAC,OAAA9G,EAAAhE,QAAA2H,KAAAA,KACAgD,GAAA5H,OAAA,GACA4H,EAAAZ,QAAA,SAAAC,GACAA,EAAAhK,QAAAyH,MAAA3C,WAAA7D,EAAAkI,aACA0B,EAAAA,EAAAC,OAAAd,EAAAhK,QAAA2H,KAAAA,MACA8C,EAAAT,KAMAS,IACAzG,EAAAhE,QAAA2H,KAAAA,KAAAkD,EACAjO,KAAA6B,kBAAA2K,WAAAqB,EAAA7N,KAAAyM,aAAAoB,KAEAzG,EAAAhE,QAAA+K,SAAAnO,KAAAoD,QAAAgL,WACAhH,EAAAL,GAAA,YAAA,WACA/G,KAAA6B,kBAAAwM,qBAAArO,KAAAoD,QAAAgL,YACApO,KAAA6H,QAAA,GACSL,KAAAxH,OACTA,KAAA6B,kBAAA8E,IAAAS,GAEAA,EAAAL,GAAA,WAAA,WACA,mBAAA/G,MAAAoD,QAAA2H,KAAAuD,aACApF,EAAA9F,QAAAkL,cACApF,EAAAqF,cAAAvO,MAGAA,KAAAoD,QAAA2H,KAAAuD,cACApF,EAAAqF,cAAAvO,SAMAiF,EAAAwG,iBAAA,SAAArC,EAAA8C,GACA,GAAAhD,GAAAlJ,IACAkM,IACAlM,KAAAkL,KAAA9B,GAGAA,EAAAoF,KAAA,iBAAApF,EAAAtG,MAAAuD,IAAA,2BAGA+C,EAAArC,GAAA,QAAA,SAAAgB,GACA,GAAA0G,GAAAzO,IACAkJ,GAAAwF,iBAAAD,EAEA,IAAA3G,KAQA,IAPAA,EAAAC,MAAAA,EACAD,EAAAhC,KAAA,QACAgC,EAAAZ,OAAAuH,EACAvF,EAAAvH,KAAAqG,QAAAF,EAAAhC,KAAAgC,GACAC,EAAA4G,cAAA,EAGArK,EAAAsK,UAAAH,GAAA,CACA,GAAAI,GAAAJ,EAAAtG,MACA0G,GAAA3C,gBACA2C,EAAA7G,QAAA,SAAiDD,MAAAA,EAAAjC,KAAA,QAAAoB,OAAA2H,OAIjDzF,EAAArC,GAAA,WAAA,SAAAC,GACA,GAAAyH,GAAAzO,IACAyO,GAAA5D,OAAA,mBAAA4D,GAAA5D,MAAAyD,aAKAG,EAAA5D,MAAAyD,cACApF,EAAA4F,SAAAL,GALAvF,EAAA9F,QAAAkL,cACApF,EAAA4F,SAAAL,EAOA,IAAA3G,KACAA,GAAAC,MAAAf,EACAc,EAAAhC,KAAA,WACAgC,EAAAZ,OAAAuH,EACAvF,EAAAvH,KAAAqG,QAAAF,EAAAhC,KAAAgC,GAEAd,EAAA2H,cAAA,IAGA3O,KAAAyB,SAAA+H,KAAAJ,IAGAnE,EAAA4G,uBAAA,SAAAzC,GACA,GAAA2F,GAAA3F,EAAAjB,OACA6G,EAAAD,IAAA/O,KAAAc,OAEAmO,MAAAjP,KAAA2B,KAAA0D,WACA6J,OAAAlP,KAAA2B,KAAA2D,cAGA2J,MAAAF,EAAAI,kBAAAF,MACAC,OAAAH,EAAAI,kBAAAD,OAEAxK,GAAA0K,gBAAAhG,EAAAA,EAAAwC,SAAAoD,EAAA5F,EAAAwC,SAAAyD,SAA2FC,aAAAlG,EAAAwC,SAAA2D,UAAA,SAG3FtK,EAAAwH,aAAA,SAAArD,GACA,GAAAoG,GAAA,IAMA,OAJAA,GADApG,GAAAA,EAAAjB,OACAiB,EAAAjB,OAEAnI,KAAAc,OAKAmE,EAAA0C,qBAAA,WACA3H,KAAAqB,gBACArB,KAAAc,MAAA2O,OAAAzP,KAAAqB,eACArB,KAAAqB,cAAAqO,UACA1P,KAAAqB,cAAA,OAQA4D,EAAA4E,MAAA,SAAAD,GACA,IAAA,GAAAyD,GAAA,EAAuBA,EAAArN,KAAAyB,SAAA0E,OAA0BkH,IAAA,CACjD,GAAAmC,GAAAxP,KAAAyM,aAAAzM,KAAAyB,SAAA4L,GACArN,MAAA6B,kBAAA8N,gBAAA3P,KAAAyB,SAAA4L,GAAAmC,GAEAxP,KAAA6B,kBAAAmM,aAAAnE,QACA7J,KAAAyB,YACAzB,KAAAqB,cAAA,KACArB,KAAAwB,aAAA,KACAxB,KAAA4P,eAAA,KACA5P,KAAA6C,iBACA7C,KAAAyH,qBACAzH,KAAA0H,uBACA1H,KAAA6B,kBAAAiF,cACA9G,KAAAiC,IAAA4H,QACA7J,KAAAc,MAAA,GAAA6B,GAAA8D,MACAzG,KAAAc,MAAA4F,MAAA,EACA1G,KAAAiC,IAAA0E,IAAA3G,KAAAc,OACA,GAAA8I,GACA5J,KAAAiM,eAuBAhH,EAAA4K,YAAA5K,EAAA6K,QAAA,SAAA9J,EAAA5C,GACApD,KAAA+B,qBAAA+N,QAAA9J,EAAA5C,IAYA6B,EAAA8K,gBAAA,SAAAnH,GACA5I,KAAAgQ,kBAAApH,GACA5I,KAAAiQ,kBAAArH,IAaA3D,EAAA+K,kBAAA,SAAApH,EAAAxF,GAEApD,KAAA+B,qBAAAmO,cAAAtH,EAAAxF,IAaA6B,EAAAgL,kBAAA,SAAArH,EAAAxF,GACApD,KAAA+B,qBAAAoO,sBAAAvH,EAAAxF,IAOA6B,EAAAmL,0BAAA,SAAAlI,GACA,GAAAmI,GAAAnI,EACAoE,EAAAtM,KAAA6B,kBAAAyO,aACAC,EAAAjE,EAAAlJ,QAAAyH,MAAA3C,QACA,IAAAmI,GACA,GAAAA,GAAAE,EACA,WAES,CACT,GAAAC,IAAAnM,EAAAoM,cAAApM,EAAAqM,YAAArM,EAAAsM,YACAC,EAAA3M,EAAA4M,QAAAL,EAAAD,EACAF,GAAAG,GAAAI,EAAA,GAAAJ,EAAArK,QAIAnG,KAAA6B,kBAAAiP,WAAA9Q,KAAAyM,aAAAH,IACAtM,KAAA+B,qBAAAwF,uBAEAtD,EAAA8M,MAAAzE,EAAAlJ,SAAoC4N,aAAc,GAClD/M,EAAA8M,MAAAzE,EAAAlJ,QAAAyH,OAA0C3C,SAAAmI,IAAyB,EACnE,IAAAY,GAAAjR,KAAAkR,uBAAA5E,EAAAO,UAAAP,EAAAQ,QAAAR,EAAAlJ,SAAA,EACA6N,KACAA,EAAAE,MAAA7E,EAAA6E,MACAF,EAAAlK,GAAA,kBAAA,WACA/G,KAAA+B,qBAAA4G,cAAAsI,IACazJ,KAAAxH,SAWbiF,EAAAmM,qBAAA,SAAAC,EAAApE,EAAA/E,GACA,GAAAoJ,GAAAtR,KACAuR,EAAA,GAAA5O,GAAAyF,QACAnB,OACAuK,GAAAH,EAAAI,EACAC,GAAAL,EAAAM,EACAC,EAAA,GAEA/G,OACAgH,KAAA,UACAC,OAAA,WAEAC,EAAA,EACAC,WAAA,EACA9J,SAAAA,GAEAqJ,GAAAzL,KAAA,eACAyL,EAAAtE,IAAAA,CACA,IAAA1G,IAAA,YAAA,OAAA,UACAtC,GAAA4E,KAAAtC,EAAA,SAAAuC,GACAyI,EAAAxK,GAAA+B,EAAA,SAAA9B,GACA,GAAAc,KACAA,GAAAC,MAAAf,EACAc,EAAAhC,KAAA,gBAAAgD,EACAwI,EAAAxQ,MAAAkH,QAAAF,EAAAhC,KAAAgC,OAGA9H,KAAAc,MAAA6F,IAAA4K,IAOAtM,EAAAwC,mBAAA,WACA,GAAAyB,GAAAlJ,IACAA,MAAAc,MAAAwI,WAAA6D,QAAA,SAAAC,GACA,iBAAAA,EAAAtH,MACAoD,EAAApI,MAAA2O,OAAArC,KAGApN,KAAAc,MAAAiI,IAAA,0BACA/I,KAAAc,MAAAiI,IAAA,qBACA/I,KAAAc,MAAAiI,IAAA,yBASA9D,EAAAgN,mBAAA,SAAAC,EAAAhK,GACA,GAAAgB,GAAAlJ,KACAmS,KACAC,KACAC,IACAH,GAAA/L,OAAA,GACA+L,EAAA/E,QAAA,SAAAmF,GACAhO,EAAAgG,YAAAgI,IACAD,EAAA7I,KAAA8I,GACAH,EAAAA,EAAAjE,OAAAoE,EAAAhJ,aAEA8I,EAAA5I,KAAA8I,KAIAF,EAAAjF,QAAA,SAAAmF,GACAH,EAAAI,SAAAD,IACAD,EAAA7I,KAAA8I,MAIAD,EAAAH,EAEAG,EAAAlF,QAAA,SAAAmF,GACA,GAAAE,GAAAzO,EAAA0O,QAAAH,GACAI,EAAA3O,EAAA4O,mBAAAH,EAAAF,EACApJ,GAAAkI,qBAAAsB,EAAAE,KAAA,OAAA1K,GACAgB,EAAAkI,qBAAAsB,EAAAG,MAAA,QAAA3K,GACAgB,EAAAkI,qBAAAsB,EAAAI,IAAA,MAAA5K,GACAgB,EAAAkI,qBAAAsB,EAAAK,OAAA,SAAA7K,MAyBAjD,EAAA+N,mBAAA,SAAA9K,EAAAtF,EAAAqQ,GAqBA,QAAAC,GAAAzB,EAAAE,EAAAwB,EAAAlG,GACA,GAAA7D,GAAAgK,EAAA,IAwBA,OAvBAlK,GAAAzH,SAAA0L,QAAA,SAAAmF,GACA,GAAAE,GAAAzO,EAAA0O,QAAAH,GACAI,EAAA3O,EAAA4O,mBAAAH,EAAAF,EACArF,GACAoG,KAAAC,IAAAZ,EAAAzF,GAAAwE,EAAAA,IAAA0B,GAAAE,KAAAC,IAAAZ,EAAAzF,GAAA0E,EAAAA,IAAAwB,IACA/J,EAAAkJ,GAGAe,KAAAC,IAAAZ,EAAA,KAAAjB,EAAAA,IAAA0B,GAAAE,KAAAC,IAAAZ,EAAA,KAAAf,EAAAA,IAAAwB,GACAC,EAAA,OACAhK,EAAAkJ,GACqBe,KAAAC,IAAAZ,EAAA,IAAAjB,EAAAA,IAAA0B,GAAAE,KAAAC,IAAAZ,EAAA,IAAAf,EAAAA,IAAAwB,GACrBC,EAAA,MACAhK,EAAAkJ,GACqBe,KAAAC,IAAAZ,EAAA,MAAAjB,EAAAA,IAAA0B,GAAAE,KAAAC,IAAAZ,EAAA,MAAAf,EAAAA,IAAAwB,GACrBC,EAAA,QACAhK,EAAAkJ,GACqBe,KAAAC,IAAAZ,EAAA,OAAAjB,EAAAA,IAAA0B,GAAAE,KAAAC,IAAAZ,EAAA,OAAAf,EAAAA,IAAAwB,IACrBC,EAAA,SACAhK,EAAAkJ,MAKAlJ,KAAAA,EACAgK,OAAAA,GA/CA,GAAAlK,GAAAlJ,IACAA,MAAAyH,qBACA7E,IACA5C,KAAA4C,QAAAA,GAEAqQ,IACAA,GAAA,EAEA,IAAAf,GAAAe,GAAA/J,EAAA1H,cAAA0H,EAAAzH,QAEAwR,KAEA/J,EAAAvB,uBACAuB,EAAAqK,sBAIAvT,KAAAiS,mBAAAC,EAAAhK,GAiCAlI,KAAAc,MAAAiG,GAAA,yBAAA,SAAAC,GAEAiM,GACA/J,EAAA+I,mBAAA/I,EAAAzH,SAAAyG,EAEA,IAAAuJ,IAAAzK,EAAAe,MAAAQ,QAAAW,EAAApI,MAAAmK,SAAA,IAAA/B,EAAAlI,QACA2Q,GAAA3K,EAAAe,MAAAS,QAAAU,EAAApI,MAAAmK,SAAA,IAAA/B,EAAAlI,QACAwS,EAAAxM,EAAAe,MAAAb,MACAgC,GAAAuK,SAAAD,EAAAvG,IACA/D,EAAAwK,eAAAR,EAAAM,EAAAvM,MAAAuK,GAAAgC,EAAAvM,MAAAyK,GAAA,EAAAxI,EAAAuK,UAAArK,KACAoK,EAAAnI,OACAnC,EAAAnH,qBAAAwF,uBACA2B,EAAAyK,gBAAA,EACAzK,EAAA0K,WAAA,IACA,IAAAvC,GAAA,GAAArN,GAAAyN,EAAAE,EACAzI,GAAArH,kBAAAiF,WAAAqG,QAAA,SAAAC,GACAA,EAAAN,QAAAzM,KAAA6I,EAAAwK,eAAArT,IAAA6I,EAAAuK,WAAArG,EAAAhK,QAAA6H,SAAAmI,QACAlK,EAAArH,kBAAAgS,aAAAzG,EAAAlE,EAAApI,OACAoI,EAAAwK,eAAAtG,EAAAP,UACA3D,EAAAuK,SAAArG,EAAAhK,QAAA6H,SAAAwI,SACAvK,EAAA0K,WAAAxG,EAAAN,QACA5D,EAAA4K,UAAA1G,EAAAhK,QAAA6H,SAAAmI,QACiBhG,EAAAP,UAAAxM,KAAA6I,EAAAwK,eAAArT,IAAA6I,EAAAuK,WAAArG,EAAAhK,QAAA6H,SAAAwI,WACjBvK,EAAArH,kBAAAgS,aAAAzG,EAAAlE,EAAApI,OACAoI,EAAAyK,gBAAA,EACAzK,EAAAwK,eAAAtG,EAAAN,QACA5D,EAAAkK,OAAAhG,EAAAhK,QAAA6H,SAAAmI,OACAlK,EAAA0K,WAAAxG,EAAAP,UACA3D,EAAA4K,UAAA1G,EAAAhK,QAAA6H,SAAAwI,WAGA,IAAArM,EAEAA,GADA8B,EAAAyK,eACAzK,EAAArH,kBAAAkS,2BAAA1C,EAAAnI,EAAAwK,eAAAF,EAAAtL,SAAAgB,EAAAkK,QAEAlK,EAAArH,kBAAAmS,oBAAA9K,EAAAwK,eAAArC,EAAAmC,EAAAtL,SAAAgB,EAAAuK,UAEAvK,EAAApI,MAAA6F,IAAAS,KAEApH,KAAAc,MAAAiG,GAAA,oBAAA,SAAAC,GACA,GAAAyK,IAAAzK,EAAAe,MAAAQ,QAAAW,EAAApI,MAAAmK,SAAA,IAAA/B,EAAAlI,QACA2Q,GAAA3K,EAAAe,MAAAS,QAAAU,EAAApI,MAAAmK,SAAA,IAAA/B,EAAAlI,QACAqQ,EAAA,GAAArN,GAAAyN,EAAAE,GACA6B,EAAAxM,EAAAe,MAAAb,MACAgC,GAAAyK,eACAzK,EAAArH,kBAAAkS,2BAAA1C,EAAAnI,EAAAwK,eAAAF,EAAAtL,SAAAgB,EAAAkK,QAEAlK,EAAArH,kBAAAmS,oBAAA9K,EAAAwK,eAAArC,EAAAmC,EAAAtL,SAAAgB,EAAAuK,UAEAvK,EAAApI,MAAAwI,WAAA6D,QAAA,SAAAC,GACA,GAAA,iBAAAA,EAAAtH,OACAsH,EAAAoB,MAA4B3D,OAAOgH,KAAA,WAAgBoC,OAAA,EAAA,GAAAC,QAAA9G,EAAAnG,MAAAuK,GAAApE,EAAAnG,MAAAyK,MACnD2B,KAAAC,IAAAlG,EAAAnG,MAAAuK,GAAAC,IAAA,IAAA4B,KAAAC,IAAAlG,EAAAnG,MAAAyK,GAAAC,IAAA,IAAA,CACA,GAAAwC,GAAAjB,EAAAzB,EAAAE,EAAA,GACAzI,GAAAyK,eACAzK,EAAArH,kBAAAkS,2BAAA1C,EAAAnI,EAAAwK,eAAAF,EAAAtL,SAAAgB,EAAAkK,OAAAe,EAAAf,OAAAe,EAAA/K,MAEAF,EAAArH,kBAAAmS,oBAAA9K,EAAAwK,eAAArC,EAAAmC,EAAAtL,SAAAgB,EAAAuK,SAAAU,EAAAf,OAAAe,EAAA/K,MAEAgE,EAAAoB,MAAgC3D,OAAOgH,KAAA,WAAgBoC,OAAA,IAAA,KAAAC,QAAA9G,EAAAnG,MAAAuK,GAAApE,EAAAnG,MAAAyK,WAKvD1R,KAAAc,MAAAiG,GAAA,uBAAA,SAAAC,GACA,GAAAyK,IAAAzK,EAAAe,MAAAQ,QAAAW,EAAApI,MAAAmK,SAAA,IAAA/B,EAAAlI,QACA2Q,GAAA3K,EAAAe,MAAAS,QAAAU,EAAApI,MAAAmK,SAAA,IAAA/B,EAAAlI,QACAmT,EAAAjB,EAAAzB,EAAAE,EAAA,IACAyC,EAAAD,EAAA/K,KACAgK,EAAAe,EAAAf,QAAA,OACAI,EAAAxM,EAAAe,MAAAb,MAKA,IAHAgC,EAAArH,kBAAAwS,oBAAAnL,EAAApI,OAGAsT,GAAAlL,EAAAwK,eAAArT,KAAA+T,EAAA/T,GAAA,CACA,GAAA6T,MACAI,GACAzJ,OACA3C,SAAAsL,EAAAtL,UAEA+C,UACAwI,SAAAvK,EAAAyK,eAAAP,EAAAlK,EAAAuK,SACAL,OAAAlK,EAAAyK,eAAAzK,EAAAkK,OAAAA,IAGAmB,EAAAxQ,EAAAyQ,SAAAF,EAAApL,EAAAtG,SAAA,EAAA,YACA6R,EAAAvL,EAAAyK,eAAAS,EAAAlL,EAAAwK,eACAgB,EAAAxL,EAAAyK,eAAAzK,EAAAwK,eAAAU,CAeA,IAbAlL,EAAA0K,aACAM,EAAArH,UAAA3D,EAAAyK,eAAAzK,EAAA0K,WAAA1K,EAAAwK,eACAQ,EAAApH,QAAA5D,EAAAyK,eAAAzK,EAAAwK,eAAAxK,EAAA0K,WACAM,EAAA9Q,QAAAW,EAAAyQ,UACA3J,OACA3C,SAAAsL,EAAAtL,UAEA+C,UACAwI,SAAAvK,EAAAyK,eAAAzK,EAAA4K,UAAA5K,EAAAuK,SACAL,OAAAlK,EAAAyK,eAAAzK,EAAAkK,OAAAlK,EAAA4K,YAEqB5K,EAAAtG,SAAA,EAAA,cAErBsG,EAAAkB,SAAA,gBAAmDlD,OAAAuN,EAAA3H,QAAA4H,EAAAJ,eAAAC,EAAAL,OAAAA,IACnD,OAAA,CAEAhL,GAAAgI,uBAAAuD,EAAAC,EAAAH,GACArL,EAAAzB,yBAIA+L,GAAA5F,OACA4F,EAAAvI,UAAA,EAAA,GAEA/B,EAAApI,MAAAwI,WAAA6D,QAAA,SAAAC,GACA,iBAAAA,EAAAtH,MACAsH,EAAAoB,MAAgC3D,OAAOgH,KAAA,WAAgBoC,OAAA,EAAA,GAAAC,QAAA9G,EAAAnG,MAAAuK,GAAApE,EAAAnG,MAAAyK,WAMvDzM,EAAA0P,yBAAA,SAAAtD,EAAApE,EAAA/E,GACA,GAAAqJ,GAAA,GAAA5O,GAAAyF,QACAnB,OACAuK,GAAAH,EAAAI,EACAC,GAAAL,EAAAM,EACAC,EAAA,GAEA/G,OACAgH,KAAA,UACAC,OAAA,WAEAC,EAAA,EACAC,WAAA,EACA9J,SAAAA,GAEAqJ,GAAAzL,KAAA,eACAyL,EAAAtE,IAAAA,EACAjN,KAAAc,MAAA6F,IAAA4K,IAGAtM,EAAA2P,uBAAA,SAAAxL,EAAA6D,GACA,GAAA/D,GAAAlJ,KACA6U,EAAAzL,EAAAyL,QACA,IAAA,QAAA5H,EACA,MAAA/D,GAAA7F,UAAA4J,EAEA,IAAAoG,KAAAC,IAAAuB,GAAA,EAAA,CACA,GAAAC,IAAAD,GAAAxB,KAAA0B,GAAA,KACAC,EAAA3B,KAAA4B,MAAAH,EAAA,IAAA,GAMA,OALAE,GAAA,IACAA,GAAA,GAEAA,GAAA9L,EAAAtF,aAAAqJ,GACA+H,GAAA,EACA9L,EAAAvF,WAAAqR,GAEA,MAAA9L,GAAA7F,UAAA4J,IAUAhI,EAAAiQ,uBAAA,SAAA7D,EAAApE,EAAA7D,GACA,GAAAkI,GAAAtR,KACAmV,EAAAlI,EAAAmI,MAAA,IACA,IAAAD,EAAAhP,OAAA,EAAA,CACA,GAAAkP,GAAA/D,EAAAsD,uBAAAxL,EAAA6D,GACAsE,EAAA,GAAA5O,GAAA2S,MACArO,OACAwK,EAAAJ,EAAAI,EAAA,EACAE,EAAAN,EAAAM,EAAA,EACA1C,MAAA,EACAC,OAAA,GAEArE,OACAgH,KAAA,UACAC,OAAA,WAEAC,EAAA,EACA8C,SAAAzL,EAAAyL,SACAX,QAAA7C,EAAAI,EAAAJ,EAAAM,GACA4D,OAAAF,EACArD,WAAA,GAEAT,GAAAzL,KAAA,iBACAyL,EAAAtE,IAAAA,CACA,IAAA1G,IAAA,YAAA,OAAA,UACAtC,GAAA4E,KAAAtC,EAAA,SAAAuC,GACAyI,EAAAxK,GAAA+B,EAAA,SAAA9B,GACA,GAAAc,KACAA,GAAAC,MAAAf,EACAc,EAAAhC,KAAA,kBAAAgD,EACAhB,EAAA0N,OAAApM,EAAA/I,GACAyH,EAAAyN,OAAAF,EACA/D,EAAAxQ,MAAAkH,QAAAF,EAAAhC,KAAAgC,OAGA9H,KAAAc,MAAA6F,IAAA4K,OACS,CAET,GAAAjF,GAAA,GAAA3J,GAAA8S,MACAxO,OACAyO,GAAArE,EAAAyB,IAAArB,EACAkE,GAAAtE,EAAAyB,IAAAnB,EACAiE,GAAAvE,EAAA0B,OAAAtB,EACAoE,GAAAxE,EAAA0B,OAAApB,GAEA9G,OACAiL,UAAA,GAEA/D,EAAA,EACAC,WAAA,EACAuD,OAAA,WAEAjJ,GAAAxG,KAAA,qBACAwG,EAAAkJ,OAAApM,EAAA/I,GACAL,KAAAc,MAAA6F,IAAA2F,KASArH,EAAA8Q,4BAAA,SAAA3M,GACA,GAAA4M,GAAA,iBAAA5M,GAAA6M,UAAA7M,EAAA6M,UAAAjW,KAAAoD,QAAA6S,UACAC,EAAA,iBAAA9M,GAAA+M,UAAA/M,EAAA+M,UAAAnW,KAAAoD,QAAA+S,SACA,QACAF,UAAAD,EACAG,UAAAD,IAQAjR,EAAAyC,qBAAA,WACA,GAAAwB,GAAAlJ,KACAoW,GAAA,iBAAA,qBACApW,MAAAc,MAAAwI,WAAA6D,QAAA,SAAAC,GACAgJ,EAAA7D,SAAAnF,EAAAtH,OACAoD,EAAApI,MAAA2O,OAAArC,KAGApN,KAAAc,MAAAiI,IAAA,4BACA/I,KAAAc,MAAAiI,IAAA,uBACA/I,KAAAc,MAAAiI,IAAA,2BAWA9D,EAAAoR,qBAAA,WAkBA,QAAAC,GAAAjW,GACA,GAAA+I,GAAA,IAMA,OALAF,GAAApI,MAAAwI,WAAA6D,QAAA,SAAAmF,GACAA,EAAAjS,KAAAA,IACA+I,EAAAkJ,KAGAlJ,EAxBA,GAAAF,GAAAlJ,IACAA,MAAA0H,sBAEA,IAAA8K,GAAAzO,EAAA0O,QAAAzS,KAAAwB,cACAkR,EAAA3O,EAAAwS,qBAAA/D,EAAAxS,KAAAwB,cACAsG,EAAA9H,KAAA+V,4BAAA/V,KAAAwB,aACAsG,GAAAmO,YACA/M,EAAAgM,uBAAAxC,EAAApP,GAAA,KAAAtD,KAAAwB,cACA0H,EAAAgM,uBAAAxC,EAAAnP,GAAA,KAAAvD,KAAAwB,cACA0H,EAAAgM,uBAAAxC,EAAAlP,GAAA,KAAAxD,KAAAwB,cACA0H,EAAAgM,uBAAAxC,EAAAjP,GAAA,KAAAzD,KAAAwB,eAEAsG,EAAAqO,YACAjN,EAAAgM,uBAAAxC,EAAAhP,IAAA,MAAA1D,KAAAwB,cACA0H,EAAAgM,wBAAqCpC,IAAAJ,EAAAhP,IAAAqP,OAAAL,EAAA8D,IAAqD,SAAAxW,KAAAwB,eAa1FxB,KAAAc,MAAAiG,GAAA,2BAAA,SAAAC,GAEA,GAAAuO,GAAAvO,EAAAe,MAAAb,OAAAqO,OACAtI,EAAAjG,EAAAe,MAAAb,OAAA+F,IACAwJ,GACAnT,GAAA,KACAC,GAAA,KACAC,GAAA,KACAC,GAAA,KAGA,IADAyF,EAAAwK,eAAA4C,EAAAtP,EAAAwO,QACAD,GAAA,QAAAtI,EAAA,CACA,GAAA2G,GAAA1K,EAAApI,MAAAwI,WAAAoN,KAAA,SAAAtN,GACA,MAAAA,GAAA6D,MAAAwJ,EAAAxJ,KAEA0J,EAAAzN,EAAApI,MAAAwI,WAAAoN,KAAA,SAAAtN,GACA,MAAAA,GAAA6D,MAAAA,IAEA2J,EAAA1N,EAAAwK,eAAAvE,iBACAjG,GAAA2N,cAAA5S,EAAAmC,MAAAwN,EAAA3M,OACAiC,EAAA4N,aAAA7S,EAAAmC,MAAAuQ,EAAA1P,MACA,IAAAuL,GAAAvO,EAAAmC,MAAArC,EAAA0O,QAAAvJ,EAAAwK,gBAAA,IACAqD,EAAA1D,KAAA2D,KAAA3D,KAAA4D,IAAAzE,EAAAvD,MAAA,GAAAoE,KAAA4D,IAAAzE,EAAAtD,OAAA,GACAhG,GAAA6N,SAAAA,EACA7N,EAAAgO,WAAAjT,EAAAmC,MAAAoM,GACAtJ,EAAAiO,cAAAP,EAAAnF,KAEAvI,EAAAwK,eAAA0D,aAAAlO,EAAAvH,KAAAyD,QAAAiS,YAAAnO,EAAAwK,mBAGA1T,KAAAc,MAAAiG,GAAA,sBAAA,SAAAC,GACA,GAAAuO,GAAAvO,EAAAe,MAAAb,OAAAqO,OACA+B,EAAAtQ,EAAAe,MAAAb,OAAA+F,IACA0J,EAAAzN,EAAAwK,eACAjC,GAAAzK,EAAAe,MAAAQ,QAAAW,EAAApI,MAAAmK,SAAA,IAAA/B,EAAAlI,QACA2Q,GAAA3K,EAAAe,MAAAS,QAAAU,EAAApI,MAAAmK,SAAA,IAAA/B,EAAAlI,QACAwR,EAAAzO,EAAA0O,QAAAkE,GAAA,EACA,IAAA,QAAAW,EAAA,CAEA,GAAAC,GAAA9F,EAAAkF,EAAA1L,SAAA,GACAuM,EAAA7F,EAAAgF,EAAA1L,SAAA,GACAwM,GACAhG,EAAAe,EAAAf,EAAAkF,EAAA1L,SAAA,GACA0G,EAAAa,EAAAb,EAAAgF,EAAA1L,SAAA,IAEA4J,EAAAxB,KAAAqE,MAAAF,EAAAD,EACArO,GAAA1H,aAAAgN,MACA0F,QAAAuD,EAAAhG,EAAAgG,EAAA9F,GACAkD,UAAAA,GAEA,IAAAnC,GAAA3O,EAAA4O,mBAAAH,EAAAtJ,EAAA1H,cACAmW,EAAA5T,EAAAwS,qBAAA/D,EAAAtJ,EAAA1H,aAEA0H,GAAApI,MAAAwI,WAAA6D,QAAA,SAAAmF,GACA,GAAArF,GAAAqF,EAAArF,GACA,oBAAAqF,EAAAxM,MACA,QAAAmH,IACAqF,EAAA9D,KAAA,YAAA,EAAA,IACA8D,EAAA9D,KAAA,WAAA,IAEA8D,EAAAsF,UAAmCnG,EAAAkG,EAAA1K,GAAAwE,EAAA,EAAAE,EAAAgG,EAAA1K,GAAA0E,EAAA,IACnCW,EAAA9D,MACA0F,QAAA5B,EAAArL,MAAAwK,EAAA,EAAAa,EAAArL,MAAA0K,EAAA,GACAkD,UAAAA,KAEiB,uBAAAvC,EAAAxM,KACjBwM,EAAAsF,UAAmClC,GAAAiC,EAAAjU,IAAA+N,EAAAmE,GAAA+B,EAAAnB,GAAA/E,EAAAkE,GAAAgC,EAAAjU,IAAAiO,EAAAkE,GAAA8B,EAAAnB,GAAA7E,IAClB,iBAAAW,EAAAxM,MACjBwM,EAAAsF,UAAmCpG,GAAAkB,EAAAzF,GAAAwE,EAAAC,GAAAgB,EAAAzF,GAAA0E,UAG1B,CAET,GAGAkG,GAAAC,EAHAC,EAAA,EACAC,KACAC,KAEAC,GAAA,WAAA,YACAC,GACA7U,GAAA,KACAC,GAAA,KACAC,GAAA,KACAC,GAAA,MAGA2U,EAAAlP,EAAApI,MAAAwI,WAAA+O,OAAA,SAAAjP,GACA,MAAA,mBAAAA,EAAAtD,MAAA,QAAAsD,EAAA6D,MAEAqL,EAAAF,EAAA1B,KAAA,SAAAtN,GACA,MAAAA,GAAA6D,MAAAqK,GAUA,IAPA7F,GAAA,IACAA,EAAA,GAEAE,GAAA,IACAA,EAAA,GAGAuG,EAAA3F,SAAAgD,GAAA,CAEA,GAAAgD,GAAAD,EAAArR,MAAA0K,EAAA,CACAoG,GAAA7O,EAAA4N,aAAAnF,GAAAzI,EAAA2N,cAAAlF,GAAAA,EAAAzI,EAAA2N,cAAAlF,EAAA,IAAA4G,EAAArP,EAAA2N,cAAAlF,IAAAzI,EAAA2N,cAAAlF,EAAA,EAAAA,IAAAzI,EAAA2N,cAAAlF,EAAA4G,OACa,CAEb,GAAAC,GAAAF,EAAArR,MAAAwK,EAAA,CACAsG,GAAA7O,EAAA4N,aAAArF,GAAAvI,EAAA2N,cAAApF,GAAAA,EAAAvI,EAAA2N,cAAApF,EAAA,IAAA+G,EAAAtP,EAAA2N,cAAApF,IAAAvI,EAAA2N,cAAApF,EAAA,EAAAA,IAAAvI,EAAA2N,cAAApF,EAAA+G,GAEA,kBAAAC,KAAAV,KACAA,EAAA,GAEApB,EAAA+B,YAAAX,EAEA,IAAAY,GAAA5U,EAAA0O,QAAAkE,GAAA,EACAsB,GAAA/O,EAAAiO,eAAgD1F,EAAAvI,EAAAgO,WAAAzF,EAAAE,EAAAzI,EAAAgO,WAAAvF,IAAiDF,EAAAvI,EAAAgO,WAAAN,aAAAnF,EAAAE,EAAAzI,EAAAgO,WAAAN,aAAAjF,EACjG,IAAAiH,GAAAvF,KAAA2D,KAAA3D,KAAA4D,IAAA0B,EAAA1J,MAAA,GAAAoE,KAAA4D,IAAA0B,EAAAzJ,OAAA,GACA,QAAAqG,GAEA,IAAA,WACA,IAAA,YACAsC,GAAA3O,EAAA2N,cAAApF,EAAA,EAAAwG,EAAAxG,GAAAmH,EAAA1P,EAAA6N,SACAe,GAAA5O,EAAA2N,cAAAlF,EAAA,EAAAsG,EAAAtG,GAAAiH,EAAA1P,EAAA6N,SACAiB,EAAAxO,KAAAN,EAAA2N,cAAApF,EAAAoG,EAAA,EAAA3O,EAAA2N,cAAAlF,EAAAmG,EAAA,EACA,MAEA,KAAA,WACA,IAAA,YACAD,GAAAI,EAAAxG,EAAAvI,EAAA2N,cAAApF,EAAA,GAAAmH,EAAA1P,EAAA6N,SACAe,GAAA5O,EAAA2N,cAAAlF,EAAA,EAAAsG,EAAAtG,GAAAiH,EAAA1P,EAAA6N,SACAiB,EAAAxO,KAAAN,EAAA2N,cAAApF,EAAAoG,EAAA,EAAA3O,EAAA2N,cAAAlF,EAAAmG,EAAA,EACA,MAEA,KAAA,WACA,IAAA,YACAD,GAAAI,EAAAxG,EAAAvI,EAAA2N,cAAApF,EAAA,GAAAmH,EAAA1P,EAAA6N,SACAe,GAAAG,EAAAtG,EAAAzI,EAAA2N,cAAAlF,EAAA,GAAAiH,EAAA1P,EAAA6N,SACAiB,EAAAxO,KAAAN,EAAA2N,cAAApF,EAAAoG,EAAA,EAAA3O,EAAA2N,cAAAlF,EAAAmG,EAAA,EACA,MAEA,KAAA,WACA,IAAA,YACAD,GAAA3O,EAAA2N,cAAApF,EAAA,EAAAwG,EAAAxG,GAAAmH,EAAA1P,EAAA6N,SACAe,GAAAG,EAAAtG,EAAAzI,EAAA2N,cAAAlF,EAAA,GAAAiH,EAAA1P,EAAA6N,SACAiB,EAAAxO,KAAAN,EAAA2N,cAAApF,EAAAoG,EAAA,EAAA3O,EAAA2N,cAAAlF,EAAAmG,EAAA,GAMA,GAAAe,IACApH,EAAAkH,EAAAlH,EAAAuG,EAAA,GACArG,EAAAgH,EAAAhH,EAAAqG,EAAA,GAEArB,GAAAnI,MACAvD,SAAA+M,EACA9D,QAAA2E,EAAApH,EAAAoH,EAAAlH,IAIA,IAAAmH,GAAA/U,EAAA0O,QAAAkE,GAAA,GACAoC,EAAAhV,EAAA4O,mBAAAmG,EAAAnC,GACAqC,EAAAjV,EAAAwS,qBAAAuC,EAAAnC,EACAzN,GAAApI,MAAAwI,WAAA6D,QAAA,SAAAmF,GACA,GAAArF,GAAAqF,EAAArF,GACAA,KAAAqK,GACAhF,EAAA9D,KAAA,YAAA,EAAA,IAEA,mBAAA8D,EAAAxM,MAAAmH,IAAAkL,EAAAb,IACAhF,EAAAsF,UAAmCnG,EAAAuH,EAAA/L,GAAAwE,EAAA,EAAAE,EAAAqH,EAAA/L,GAAA0E,EAAA,IACnCW,EAAA9D,KAAA,UAAAwK,EAAA/L,GAAAwE,EAAAuH,EAAA/L,GAAA0E,KACiB,uBAAAW,EAAAxM,KACjBwM,EAAAsF,UAAmClC,GAAAsD,EAAAtV,IAAA+N,EAAAmE,GAAAoD,EAAAxC,GAAA/E,EAAAkE,GAAAqD,EAAAtV,IAAAiO,EAAAkE,GAAAmD,EAAAxC,GAAA7E,IAElB,iBAAAW,EAAAxM,MACjBwM,EAAAsF,UAAmCpG,GAAAuH,EAAA9L,GAAAwE,EAAAC,GAAAqH,EAAA9L,GAAA0E,MAInCzI,EAAA7H,cAAA4X,eAAA/P,EAAA1H,aAAAuC,EAAA0O,QAAAvJ,EAAA1H,eAEA0H,EAAArH,kBAAAqX,kBAAAhQ,EAAA1H,cAEA8C,EAAAgG,YAAApB,EAAA1H,eACA0H,EAAA1H,aAAAqH,KAAA,SAAAU,GACAL,EAAArH,kBAAAqX,kBAAA3P,OAKAvJ,KAAAc,MAAAiG,GAAA,yBAAA,SAAAC,GAEA,GAAAoC,GAAAF,EAAAwK,eACAzI,EAAA7B,EAAA6B,SACAiJ,EAAA9K,EAAA8K,MAOA,IALAhL,EAAAwK,eAAAlF,KAAA,YAAA2K,SAAAlO,EAAA,GAAA,IAAAkO,SAAAlO,EAAA,GAAA,MACAmO,MAAAlM,QAAAgH,IACAhL,EAAAwK,eAAAlF,KAAA,UAAA2K,SAAAjF,EAAA,GAAA,IAAAiF,SAAAjF,EAAA,GAAA,MAEA9K,EAAAsP,YAAA,GAAA,GACAtP,EAAAtG,MAAA,CAEAsG,EAAAtG,MAAAE,IAAA,mBAAAoG,EAAAyL,UACAzL,EAAAtG,MAAAE,IAAA,iBAAAoG,EAAA8K,OACA,IAAAmF,GAAAjQ,EAAAtG,MAAAiD,OAAAsT,WACA,WAAAA,EACAjQ,EAAAtG,MAAAE,IAAA,gBAAAoG,EAAAyB,OAEAzB,EAAAtG,MAAAE,IAAA,gBAAAoG,EAAAnC,OAIAiC,EAAAwF,iBAAAtF,GACAF,EAAA+C,cACA/C,EAAA2N,cAAA,KACA3N,EAAA4N,aAAA,KACA5N,EAAA6N,SAAA,KACA7N,EAAAgO,WAAA,KACAhO,EAAAiO,cAAA,QAIAlS,EAAAqU,kBAAA,SAAAlQ,EAAA6J,GAOA,QAAAC,GAAAzB,EAAAE,EAAAwB,EAAAlG,GACA,GAAA7D,GAAAgK,EAAA,IAwBA,OAvBAlK,GAAAzH,SAAA0L,QAAA,SAAAmF,GACA,GAAAE,GAAAzO,EAAA0O,QAAAH,GACAI,EAAA3O,EAAA4O,mBAAAH,EAAAF,EACArF,GACAoG,KAAAC,IAAAZ,EAAAzF,GAAAwE,EAAAA,IAAA0B,GAAAE,KAAAC,IAAAZ,EAAAzF,GAAA0E,EAAAA,IAAAwB,IACA/J,EAAAkJ,GAGAe,KAAAC,IAAAZ,EAAA,KAAAjB,EAAAA,IAAA0B,GAAAE,KAAAC,IAAAZ,EAAA,KAAAf,EAAAA,IAAAwB,GACAC,EAAA,OACAhK,EAAAkJ,GACqBe,KAAAC,IAAAZ,EAAA,IAAAjB,EAAAA,IAAA0B,GAAAE,KAAAC,IAAAZ,EAAA,IAAAf,EAAAA,IAAAwB,GACrBC,EAAA,MACAhK,EAAAkJ,GACqBe,KAAAC,IAAAZ,EAAA,MAAAjB,EAAAA,IAAA0B,GAAAE,KAAAC,IAAAZ,EAAA,MAAAf,EAAAA,IAAAwB,GACrBC,EAAA,QACAhK,EAAAkJ,GACqBe,KAAAC,IAAAZ,EAAA,OAAAjB,EAAAA,IAAA0B,GAAAE,KAAAC,IAAAZ,EAAA,OAAAf,EAAAA,IAAAwB,IACrBC,EAAA,SACAhK,EAAAkJ,MAKAlJ,KAAAA,EACAgK,OAAAA,GAjCA,GAAAlK,GAAAlJ,IACAiT,KACAA,GAAA,GAEAjT,KAAAqB,cAAA,GAAA6C,GAAAkF,EAAApJ,KAAAc,MAAAd,KAAA2B,MAgCA3B,KAAAqB,cAAA0F,GAAA7C,EAAAqV,gBAAA,SAAAvS,GACAhH,KAAAyH,qBACAyB,EAAA+I,mBAAA/I,EAAAzH,SAAAuF,EAAAe,MAAAb,OAAAgB,SACA,IAAAuJ,IAAAzK,EAAAe,MAAAQ,QAAAvI,KAAAc,MAAAmK,SAAA,IAAAjL,KAAAgB,QACA2Q,GAAA3K,EAAAe,MAAAS,QAAAxI,KAAAc,MAAAmK,SAAA,IAAAjL,KAAAgB,OACAgG,GAAAwS,OACAxZ,KAAA4C,QAAAoE,EAAAwS,KAGA,IAAAhG,GAAAxM,EAAAe,MAAAb,MACAsM,GAAAnI,MACA,IAAAoO,GAAA,GAAAzV,GAAAyN,EAAAE,GACAvK,EAAApH,KAAA6B,kBAAAmS,oBAAAhU,KAAAwB,aAAAiY,EACAjG,EAAAtL,SACAlI,MAAAc,MAAA6F,IAAAS,GACAJ,EAAA2H,cAAA,GACSnH,KAAAxH,OAGTA,KAAAqB,cAAA0F,GAAA7C,EAAAwV,WAAA,SAAA1S,GACA,GAAAyK,IAAAzK,EAAAe,MAAAQ,QAAAvI,KAAAc,MAAAmK,SAAA,IAAAjL,KAAAgB,QACA2Q,GAAA3K,EAAAe,MAAAS,QAAAxI,KAAAc,MAAAmK,SAAA,IAAAjL,KAAAgB,QACAwS,EAAAxM,EAAAe,MAAAb,OACAuS,EAAA,GAAAzV,GAAAyN,EAAAE,EACA3R,MAAA6B,kBAAAmS,oBAAAhU,KAAAwB,aAAAiY,EAAAjG,EAAAtL,UACAgB,EAAApI,MAAAwI,WAAA6D,QAAA,SAAAC,GACA,GAAA,iBAAAA,EAAAtH,OACAsH,EAAAoB,MAA4B3D,OAAOgH,KAAA,WAAgBoC,OAAA,EAAA,GAAAC,QAAA9G,EAAAnG,MAAAuK,GAAApE,EAAAnG,MAAAyK,MACnD2B,KAAAC,IAAAlG,EAAAnG,MAAAuK,GAAAC,IAAA,IAAA4B,KAAAC,IAAAlG,EAAAnG,MAAAyK,GAAAC,IAAA,IAAA,CACA,GAAAwC,GAAAjB,EAAAzB,EAAAE,EAAA,GACAzI,GAAArH,kBAAAmS,oBAAA9K,EAAA1H,aAAAiY,EAAAjG,EAAAtL,SAAA,QAAAiM,EAAAf,OAAAe,EAAA/K,MACAgE,EAAAoB,MAAgC3D,OAAOgH,KAAA,WAAgBoC,OAAA,IAAA,KAAAC,QAAA9G,EAAAnG,MAAAuK,GAAApE,EAAAnG,MAAAyK,SAIvD1K,EAAA2H,cAAA,GACSnH,KAAAxH,OAGTA,KAAAqB,cAAA0F,GAAA7C,EAAAyV,cAAA,SAAA3S,GACAA,EAAA2H,cAAA,CACA,IAAA8C,IAAAzK,EAAAe,MAAAQ,QAAAW,EAAApI,MAAAmK,SAAA,IAAA/B,EAAAlI,QACA2Q,GAAA3K,EAAAe,MAAAS,QAAAU,EAAApI,MAAAmK,SAAA,IAAA/B,EAAAlI,QACAmT,EAAAjB,EAAAzB,EAAAE,EAAA,IACAyC,EAAAD,EAAA/K,KACAgK,EAAAe,EAAAf,QAAA,OACAI,EAAAxM,EAAAe,MAAAb,MAUA,IARAsM,EAAA5F,OAEA5N,KAAA6B,kBAAAwS,oBAAArU,KAAAc,OAMAsT,GAAApU,KAAAwB,cAAA4S,EAAA,CACA,GAAAF,MACAI,GACAzJ,OACA3C,SAAAsL,EAAAtL,UAEA+C,UACAwI,SAAA,QACAL,OAAAA,IAGAmB,EAAAxQ,EAAAyQ,SAAAF,EAAApL,EAAAtG,SAAA,EAAA,YACA6R,EAAAvL,EAAA1H,aACAkT,EAAAN,CAeA,IAbAlL,EAAA0K,aACAM,EAAArH,UAAA3D,EAAA1H,aACA0S,EAAApH,QAAA5D,EAAA0K,WACAM,EAAA9Q,QAAAW,EAAAyQ,UACA3J,OACA3C,SAAAsL,EAAAtL,UAEA+C,UACAwI,SAAAvK,EAAAuK,SACAL,OAAAlK,EAAA4K,YAEqB5K,EAAAtG,SAAA,EAAA,cAErB5C,KAAAoK,SAAA,gBAAmDlD,OAAAlH,KAAAwB,aAAAsL,QAAAsH,EAAAE,eAAAA,EAAAJ,YACnD,MAAA,KAEAhL,GAAAgI,uBAAAuD,EAAAC,EAAAH,GAEArL,EAAAzB,oBAEA,IAAA2B,GAAAF,EAAA1H,aACAoY,EAAA7V,EAAA0O,QAAArJ,GAAA,EAEAF,GAAA8J,mBAAA,SAAA6G,QAAA,GACA3Q,EAAA7H,cAAA4X,eAAA7P,EAAAwQ,IACSpS,KAAAxH,OAGTA,KAAAqB,cAAA0F,GAAA7C,EAAA4V,aAAA,WACA9Z,KAAA+Z,WAAA/Z,KAAAwB,eACSgG,KAAAxH,OACTA,KAAAc,MAAA6F,IAAA3G,KAAAqB,gBAGA4D,EAAA+U,oBAAA,WACA,GAAA9Q,GAAAlJ,IACAA,MAAA6C,cAAAsD,QACAnG,KAAA6C,cAAAsK,QAAA,SAAAmF,EAAA1B,GACA1H,EAAA6Q,WAAAzH,MAAwC,GACxC1B,IAAA1H,EAAArG,cAAAsD,OAAA,GACA+C,EAAA+C,gBAGAjM,KAAA6C,iBACA7C,KAAA4P,eAAA7G,IAAA,aACA/I,KAAAc,MAAA2O,OAAAzP,KAAA4P,iBACS1G,EAAA1H,eACT0H,EAAA6Q,WAAA7Q,EAAA1H,cAEAxB,KAAAyH,qBAEAzH,KAAA0H,uBAEA1H,KAAA2H,yBAIA1C,EAAAgV,iBAAA,SAAA7Q,EAAA8Q,GACAA,EAAA1Q,KAAAJ,EAAA/I,IACA+I,EAAAE,WAAA+O,OAAA,SAAAjL,GACA,GAAAH,GAAAjN,KAAAyB,SAAA0Y,UAAA,SAAA7H,GACA,MAAAA,GAAAjS,KAAA+M,EAAA/M,IAEA,OAAA4M,SACSzF,KAAAxH,OAAAmN,QAAA,SAAAiN,GACT9V,EAAAgG,YAAA8P,GACApa,KAAAia,iBAAAG,EAAAF,GAEAA,EAAA1Q,KAAA4Q,EAAA/Z,KAESmH,KAAAxH,QA4BTiF,EAAAwK,OAAAxK,EAAA8U,WAAA,SAAAM,EAAAjX,EAAAwG,GACA,GAAAO,GAAA/G,KACA,IAAA+G,EAAAnC,WAAA,GAAAhI,KAAAoK,SAAA,gBAAoElD,OAAAmT,IAApE,CAGA,GAAA7K,GAAAxP,KAAAyM,aAAA4N,EACA,IAAAA,YAAAhW,GAEAJ,EAAA4E,KAAAwR,EAAAlJ,MAAA,SAAAmJ,GACA9K,EAAAC,OAAA6K,KAGAta,KAAA6B,kBAAAgS,aAAAwG,EAAA7K,OACS,CAETA,EAAAC,OAAA4K,EACA,IAAAH,KACA5V,GAAAgG,YAAA+P,GACAra,KAAAia,iBAAAI,EAAAH,GAEAA,EAAA1Q,KAAA6Q,EAAAha,IAGAL,KAAAyB,SAAAzB,KAAAyB,SAAA4W,OAAA,SAAAjL,GACA,MAAA8M,GAAArJ,QAAAzD,EAAA/M,WAGAL,KAAA6B,kBAAA8N,gBAAA0K,EAAAra,KAAAc,OAEAd,KAAA2H,uBAIA3H,KAAA6B,kBAAAwF,iBAEArH,KAAA+B,qBAAAwF,uBACA,GAAAqC,GACA5J,KAAAiM,cAGAjM,KAAAoK,SAAA,UAAkClD,OAAAmT,MAYlCpV,EAAAsV,WAAA,SAAAnR,GACAA,IACApJ,KAAA0O,iBAAAtF,GACApJ,KAAAoK,SAAA,cAAyClD,OAAAkC,MAYzCnE,EAAAiM,uBAAA,SAAArE,EAAAC,EAAA1J,EAAA4E,GACA,GAAAwS,GAAApX,EAAAyH,MAAA3C,UAAA7D,EAAAoM,aACA,KAAAhM,EAAA+V,GACA,MAAA,KAEA,IAAAC,GAAAhW,EAAA+V,GACApT,EAAA,GAAAqT,GAAA5N,EAAAC,EAAA1J,EAuBA,OAtBApD,MAAA6B,kBAAA8E,IAAAS,GAEAyF,EAAA1E,QAAA2E,EAAA3E,QAAA0E,EAAA1E,QAAA2E,EAAA3E,OACA2E,EAAA3E,OAAAxB,IAAAS,GAEApH,KAAAc,MAAA6F,IAAAS,GAGAA,EAAAL,GAAA,YAAA,SAAAC,GACAhH,KAAA6B,kBAAAwM,sBACArO,KAAA6H,QAAA,EACA7H,KAAAgT,mBAAAhM,EAAAE,OAAA2D,MAAA3C,WACSV,KAAAxH,OACToH,EAAAL,GAAA,WAAA,WACA/G,KAAAoD,QAAAkL,cACAtO,KAAAuO,cAAAvO,OAESwH,KAAAxH,OACTgI,KAAA,GACAhI,KAAAoK,SAAA,UAAqClD,OAAAE,IAErCpH,KAAAiM,cACA7E,GAOAnC,EAAAmF,SAAA,SAAAtE,EAAAiC,EAAAyR,GACA,GAAAkB,GAAA1a,KAAAoD,QAAA0C,EAUA,OARA,UAAA0T,IAAAA,MACA,OAAAzR,EACAA,GAAqBjC,KAAAA,EAAAoB,OAAAlH,MAErB+H,EAAAjC,KAAAA,EAEAiC,EAAAyR,KAAAA,EACAxZ,KAAA2B,KAAAqG,QAAAD,EAAAjC,KAAAiC,KACA9D,EAAA0W,WAAAD,IAAAA,EAAAE,MAAA5a,MAAA+H,GAAAmG,OAAAsL,OAAA,IAIAvU,EAAAyJ,iBAAA,SAAAtF,GACA,GAAAyR,GAAA,eAAAzR,EAAAtD,IAWA,IAVAsD,EAAAjB,QAAA,eAAAiB,EAAAjB,OAAArC,OACA+U,GAAA,GAGA7a,KAAAyH,qBAEAzH,KAAA0H,uBAEA1H,KAAA2H,uBAEAyB,EAAAgD,cAAA,EAAA,CACA,IAAA9H,EAAAsK,UAAAxF,GAQA,MAPA,IAAAtI,GAAAsI,EAAAjB,MACA,IAAArH,EAAAsL,cAAA,EACA,MAEAhD,GAAAtI,EAOAd,KAAAwB,aAAA4H,CACA,IAAAwQ,GAAA7V,EAAA0O,QAAArJ,GAAA,EAIA,IAHApJ,KAAAqB,eACArB,KAAAsZ,kBAAAlQ,GAAA,GAEAyR,EAAA,CAEA7a,KAAAgT,mBAAA,SAAA6G,QAAA,EACA,IAAA/R,GAAA9H,KAAA+V,4BAAA3M,IACAtB,EAAAmO,WAAAnO,EAAAqO,YAEAnW,KAAAqW,uBAIArW,KAAAqB,cAAA4X,eAAA7P,EAAAwQ,IAOA3U,EAAAiG,KAAA,SAAA9B,GACA,GAAAF,GAAAlJ,IACAoJ,GAAArC,GAAA,YAAA,SAAAgB,GACA,GAAA+S,GAAA9a,IAEA,IAAA8a,EAAAC,aAAA/a,KAAAmI,QAAA,eAAAnI,KAAAmI,OAAArC,OAGAoD,EAAA8R,iBAAAF,EAAA/S,EAAAQ,QAAAR,EAAAS,SACAT,EAAA4G,cAAA,MAIA1J,EAAA+V,iBAAA,SAAA5R,EAAAqI,EAAAE,GACA,GAAAsJ,GAAA,EACAC,EAAAlb,KACAmb,EAAA/R,EAAA6B,SACAmQ,EAAAhS,EAAA6B,SAAA,GACAoQ,EAAAjS,EAAA6B,SAAA,EAGA,IAFA7B,EAAAkS,QAAA7J,EACArI,EAAAmS,QAAA5J,EACA,eAAAvI,EAAAtD,KAAA,CACA,GAAA0V,GAAAxb,KAAAc,MAAAwI,WAAA+O,OAAA,SAAAjL,GACA,MAAAA,GAAAtK,OAAA,eAAAsK,EAAAtK,MAAAiD,OAAAsT,cAEAhH,EAAArS,KAAA4P,eAAAtG,WAAA+O,OAAA,SAAAjL,GACA,MAAA,oBAAAA,EAAA/E,MAAA+E,EAAAtK,OAAA,eAAAsK,EAAAtK,MAAAiD,OAAAsT,cAEAoC,EAAAzb,KAAA4P,eAAAtG,WAAA+O,OAAA,SAAAjL,GACA,MAAA,oBAAAA,EAAA/E,MAAA+E,EAAAtK,OAAA,eAAAsK,EAAAtK,MAAAiD,OAAAsT,aAEAmC,GAAArO,QAAA,SAAAC,GACA,GAAAP,GAAAwF,EAAAqE,KAAA,SAAAtN,GACA,MAAAA,GAAA/I,KAAA+M,EAAAP,UAAAxM,KAEAyM,EAAAuF,EAAAqE,KAAA,SAAAtN,GACA,MAAAA,GAAA/I,KAAA+M,EAAAN,QAAAzM,KAEAqb,EAAAD,EAAAtB,UAAA,SAAA7N,GACA,MAAAA,GAAAjM,KAAA+M,EAAA/M,MAEAwM,GAAAC,IAAA4O,QACAR,EAAArZ,kBAAA2K,WAAAY,EAAA8N,EAAAzO,aAAAW,MAIAhE,EAAApB,QAAA,YAGA,IAAA2T,GAAA,SAAA5T,GACAA,EAAA4G,cAAA,CACA,IAAAiN,IAAA7T,EAAAQ,QAAAa,EAAAkS,SAAAtb,KAAA,QACA6b,GAAA9T,EAAAS,QAAAY,EAAAmS,SAAAvb,KAAA,OAOA,IALA,GAAA4b,GAAA,GAAAC,IACAZ,EAAA,GAEA7R,EAAApB,QAAA,QAEA1D,EAAAsK,UAAAxF,GAAA,CAEA,GAAA0S,IACA7M,MAAA3K,EAAAgG,YAAAlB,GAAAA,EAAAhG,QAAA6D,MAAAgI,MAAA7F,EAAAnC,MAAAmC,EAAAnC,MAAAgI,MAAA7F,EAAAyB,MAAAoE,MACAC,OAAA5K,EAAAgG,YAAAlB,GAAAA,EAAAhG,QAAA6D,MAAAiI,OAAA9F,EAAAnC,MAAAmC,EAAAnC,MAAAiI,OAAA9F,EAAAyB,MAAAqE,OACAjE,SAAA7B,EAAA6B,SACA8Q,cAAAX,EAAAC,GACAW,MAAAJ,EACAK,MAAAJ,EACAzS,KAAAA,EACA6R,OAAAA,EAEA7R,GAAAjB,OAAA+T,gBAAAJ,GAMA,GAJAX,EAAA,GAAAC,EAAAQ,EACAT,EAAA,GAAAE,EAAAQ,EACAzS,EAAAoF,KAAA,WAAA2M,GAEA/R,EAAA+S,MAAA,CACA,GAAAC,IAAAjB,EAAA,GAAA/R,EAAA+F,kBAAAF,OAAA7F,EAAA+S,MACAhN,kBAAAF,MAAA,GAAAkM,EAAA,GAAA/R,EAAA+S,MAAAhN,kBACAD,OAAA,EAEA9F,GAAA+S,MAAA3N,KAAA,WAAA4N,GAYA,GATApc,KAAA0O,iBAAAtF,GAEApJ,KAAA6B,kBAAAqX,kBAAA9P,GAEA9E,EAAAgG,YAAAlB,IACAA,EAAAP,KAAA,SAAAU,GACAvJ,KAAA6B,kBAAAqX,kBAAA3P,IACiB/B,KAAAxH,QAEjBsE,EAAAsK,UAAAxF,GAEA,IAAA,GADAtI,GAAAd,KAAAqc,aAAArc,KAAAyB,SAAA2H,GACAiE,EAAA,EAA+BA,EAAArN,KAAAyB,SAAA0E,OAA0BkH,IAAA,CACzD,GAAAiF,GAAAtS,KAAAyB,SAAA4L,EACA/I,GAAAgG,YAAAgI,KACAxR,GAAAwR,EAAAjS,KAAAS,EAAAT,IAAAiS,EAAAjS,KAAA+I,EAAA/I,GACAiS,EAAAhJ,WAAAoN,KAAA,SAAAtJ,GACA,MAAA,oBAAAA,EAAA/E,OAC6BmG,KAAA,SAC7BqD,KAAA,YAIAS,EAAAhJ,WAAAoN,KAAA,SAAAtJ,GACA,MAAA,oBAAAA,EAAA/E,OAC6BmG,KAAA,SAC7BqD,KAAA,qBAMSrK,KAAAxH,KACTA,MAAAiC,IAAA8E,GAAA,YAAA4U,EAKA,IAAAW,GAAA,WAUA,GATAlT,EAAAtG,OACAsG,EAAAtG,MAAAE,IAAA,mBAAAmB,EAAAoY,cAAAnT,EAAA6B,WAGAjL,KAAAiC,IAAA8G,IAAA,YAAA4S,GACA3b,KAAAiC,IAAA8G,IAAA,UAAAuT,GACAtc,KAAAiC,IAAA8G,IAAA,YAAAuT,GAGA,GAAArB,EAAA,CAMA,GALAjb,KAAAoK,SAAA,YAA2ClD,OAAAkC,IAC3CA,EAAApB,QAAA,WACA,GAAAhI,KAAAkB,UACAlB,KAAAwc,aAAAxc,KAAAmB,eAEAmD,EAAAsK,UAAAxF,GAAA,CACA,GAAAtI,GAAAd,KAAAqc,aAAArc,KAAAyB,SAAA2H,EACA,IAAAtI,EACA,IAAA,GAAAuM,GAAA,EAAuCA,EAAArN,KAAAyB,SAAA0E,OAA0BkH,IAAA,CACjE,GAAAiF,GAAAtS,KAAAyB,SAAA4L,EACA,IAAA/I,EAAAgG,YAAAgI,IAAAA,EAAAjS,KAAAS,EAAAT,IAAAiS,EAAAjS,KAAA+I,EAAA/I,GAAA,CACA,GAAAmP,GAAAxP,KAAAyM,aAAArD,EACAoG,GAAAC,OAAArG,GACAkJ,EAAA3L,IAAAyC,EACA,IAAAqT,GAAAnY,EAAAgG,YAAAlB,GAAAA,EAAA6B,SAAA,GAAA7B,EAAAhG,QAAA6D,MAAAwK,EAAArI,EAAA6B,SAAA,GACAyR,EAAApY,EAAAgG,YAAAlB,GAAAA,EAAA6B,SAAA,GAAA7B,EAAAhG,QAAA6D,MAAA0K,EAAAvI,EAAA6B,SAAA,GACA0R,EAAA3c,KAAA4c,QAAA9b,GACA+b,EAAA7c,KAAA8c,QAAAhc,EACAsI,GAAAoF,KAAA,YAAAiO,EAAAE,EAAArK,EAAAlP,QAAA6D,MAAAwK,EAAAiL,EAAAG,EAAAvK,EAAAlP,QAAA6D,MAAA0K,IACAW,EAAAhJ,WAAAoN,KAAA,SAAAtJ,GACA,MAAA,oBAAAA,EAAA/E,OACiCmG,KAAA,SACjCqD,KAAA,oBAMA7R,KAAAiM,gBAESzE,KAAAxH,KACTA,MAAAiC,IAAA8E,GAAA,UAAAuV,GACAtc,KAAAiC,IAAA8E,GAAA,YAAAuV,IAEArX,EAAA2X,QAAA,SAAAxT,GACA,MAAAA,GAAAjB,QAAA7D,EAAAgG,YAAAlB,EAAAjB,SAAAnI,KAAAc,MAAAT,KAAA+I,EAAAjB,OAAA9H,GACA+I,EAAA6B,SAAA,GAAA7B,EAAAhG,QAAA6D,MAAAwK,EAAAzR,KAAA4c,QAAAxT,EAAAjB,QAEAiB,EAAA6B,SAAA,GAAA7B,EAAAhG,QAAA6D,MAAAwK,GAIAxM,EAAA6X,QAAA,SAAA1T,GACA,MAAAA,GAAAjB,QAAA7D,EAAAgG,YAAAlB,EAAAjB,SAAAnI,KAAAc,MAAAT,KAAA+I,EAAAjB,OAAA9H,GACA+I,EAAA6B,SAAA,GAAA7B,EAAAhG,QAAA6D,MAAA0K,EAAA3R,KAAA8c,QAAA1T,EAAAjB,QAEAiB,EAAA6B,SAAA,GAAA7B,EAAAhG,QAAA6D,MAAA0K,GAIA1M,EAAAoX,aAAA,SAAA5a,EAAA2H,GACA,GAAA3H,EAAA0E,OAAA,EAAA,CAEA,IAAA,GADAgO,GAAA,KACA9G,EAAA,EAA2BA,EAAA5L,EAAA0E,OAAqBkH,IAAA,CAChD,GAAAvM,GAAAW,EAAA4L,EACA,IAAA/I,EAAAgG,YAAAxJ,GAAA,CACA,GAAAic,GAAAjc,EAAAsC,QAAA6D,MAAAgI,MACA+N,EAAAlc,EAAAsC,QAAA6D,MAAAiI,OACAyN,EAAA3c,KAAA4c,QAAA9b,GACA+b,EAAA7c,KAAA8c,QAAAhc,GACA0R,EAAAzO,EAAA0O,QAAArJ,GAAA,GACA6T,EAAAzK,EAAAvD,MACAiO,EAAA1K,EAAAtD,OACAuN,EAAAjK,EAAAf,EAAAwL,EAAA,EACAP,EAAAlK,EAAAb,EAAAuL,EAAA,CACA,IAAAT,GAAAE,GAAAD,GAAAG,GAAAJ,EAAAQ,GAAAN,EAAAI,GAAAL,EAAAQ,GAAAL,EAAAG,EAAA,CACA,GAAA1T,GAAAxI,EAAAwI,WACA8Q,EAAApa,KAAAqc,aAAA/S,EAAAF,EACA+K,GAAAiG,EAAAA,EAAAtZ,CACA,SAIA,MAAAqT,GAEA,MAAA;EAuCAlP,EAAAkY,WAAAlY,EAAAmY,UAAA,SAAAtX,EAAAqE,EAAAkT,GACA,IAAA9Y,EAAAuB,GACA,MAAA,KAEA,IAAApD,GAAA6B,EAAAuB,GACAsD,EAAA,GAAA1G,GAAAyH,EAGA,OADA7F,GAAAgZ,YAAAlU,EAAAiU,GACAjU,GAQAnE,EAAAsY,YAAA,SAAAlV,GAIA,IAAA,GAHAmV,MACAC,EAAAzd,KAAAyB,SACAic,EAAA1d,KAAA6B,kBAAAiF,WACAuG,EAAA,EAAuBA,EAAAoQ,EAAAtX,OAAyBkH,IAChDoQ,EAAApQ,GAAAvK,MAAAuD,IAAA,iBAAAoX,EAAApQ,GAAAvK,MAAAuD,IAAA,iBACAgC,EACAmV,EAAAhU,KAAAiU,EAAApQ,IACaoQ,EAAApQ,GAAAvK,MAAAuD,IAAA,kBAAAgC,GACbmV,EAAAhU,KAAAiU,EAAApQ,GAGA,KAAA,GAAAsQ,GAAA,EAAuBA,EAAAD,EAAAvX,OAAyBwX,IAChDD,EAAAC,GAAA7a,MAAAuD,IAAA,iBAAAqX,EAAAC,GAAA7a,MAAAuD,IAAA,iBACAgC,EACAmV,EAAAhU,KAAAkU,EAAAC,IACaD,EAAAC,GAAA7a,MAAAuD,IAAA,kBAAAgC,GACbmV,EAAAhU,KAAAkU,EAAAC,GAGA,OAAAH,GAAArX,OAAA,EACAqX,EAEAA,EAAA,IAUAvY,EAAA2Y,aAAA,SAAAC,EAAAC,GAIA,IAAA,GAHAL,GAAAzd,KAAAyB,SACAic,EAAA1d,KAAA6B,kBAAAiF,WACAiX,KACA1Q,EAAA,EAAuBA,EAAAoQ,EAAAtX,OAAyBkH,IAAA,CAChD,GAAA9B,GAAAkS,EAAApQ,EACAwQ,GAAAtd,KAAAud,EAAAvS,EAAA8B,IACA0Q,EAAAvU,KAAA+B,GAGA,IAAA,GAAAoS,GAAA,EAAuBA,EAAAD,EAAAvX,OAAyBwX,IAAA,CAChD,GAAAK,GAAAN,EAAAC,EACAE,GAAAtd,KAAAud,EAAAE,EAAAL,IACAI,EAAAvU,KAAAwU,GAGA,MAAAD,IASA9Y,EAAAgZ,qBAAA,SAAA7U,EAAAhG,GACA,GAAAvC,GAAAuC,MACA2a,IAEA9Z,GAAAia,SAAArd,GACAgM,WAAA,GAGA,KAAA,GADA6Q,GAAA1d,KAAA6B,kBAAAiF,WACA6W,EAAA,EAAuBA,EAAAD,EAAAvX,OAAyBwX,IAAA,CAChD,GAAAK,GAAAN,EAAAC,EACA9c,GAAAgM,UACAmR,EAAAnR,UAAAxM,KAAA+I,EAAA/I,IACA0d,EAAAvU,KAAAwU,GAGAA,EAAAlR,QAAAzM,KAAA+I,EAAA/I,IACA0d,EAAAvU,KAAAwU,GAIA,MAAAD,IAQA9Y,EAAA6E,cAAA,SAAAqU,EAAAC,GACA,GAAAD,GAAAA,EAAAhY,OAAA,EAEA,GADAnG,KAAA8C,MAAAE,IAAAC,EAAA8G,WAAAoU,GACA,KAAAA,EAAAE,OAAA,EAAA,IAAA,QAAAF,EAAAE,OAAA,EAAA,GACA,GAAAC,SAAAC,cAAA,UAAAC,WAEiB,CACjB,GAAAC,GAAA,GAAAze,MAAA0C,MAAA4S,MACArO,OACAgI,MAAAjP,KAAAiC,IAAAoD,WACA6J,OAAAlP,KAAAiC,IAAAqD,aAEAuF,OACAgH,KAAAsM,GAEA5I,OAAA,UACAxD,MAEA/R,MAAAiC,IAAA0E,IAAA8X,OAbAze,MAAAe,KAAA8J,MAAA6T,gBAAAP,MAgBa,IAAA,YAAAA,EACbne,KAAA2e,cAAA,GAAAhc,GAAA8D,MACAzG,KAAA4e,SAAA,IACA5e,KAAAiC,IAAA0E,IAAA3G,KAAA2e,mBAEA,KAAAL,SAAAC,cAAA,UAAAC,YAAAJ,EACApe,KAAAe,KAAA8J,MAAAgU,gBAAA,OAAAV,EAAA,IACAne,KAAAe,KAAA8J,MAAAiU,iBAAA,aACiB,CACjB,GAAAC,GAAA,GAAA/e,MAAA0C,MAAAkI,OACAK,UAAA,EAAA,GACAgJ,OAAA,EAAA,GACApJ,OACA4G,EAAA,EACAE,EAAA,EACA7G,MAAAqT,EACAlP,MAAAjP,KAAAiC,IAAAoD,WACA6J,OAAAlP,KAAAiC,IAAAqD,aAEAiQ,OAAA,UACAxD,MAEA/R,MAAAiC,IAAA0E,IAAAoY,KAOA9Z,EAAA2Z,SAAA,SAAAI,GAGA,IAAA,GAFAC,GAAA,GACAC,EAAA/F,SAAAnZ,KAAAqF,WAAA4Z,GACAxN,EAAA,EAAuBA,GAAAyN,EAAezN,IAAA,CACtC,GAAA0N,GAAA,GAAAxc,GAAA8S,MACAxO,OACAyO,GAAAjE,EAAAwN,EACAtJ,GAAA,EACAC,GAAAnE,EAAAwN,EACApJ,GAAA7V,KAAAsF,aAEAuF,OACAuU,UAAA,GACAJ,QAAAA,GAEAjN,EAAA,EACAC,WAAA,EACAuD,OAAA,WAEAvV,MAAA2e,cAAAhY,IAAAwY,GAIA,IAAA,GADAE,GAAAlG,SAAAnZ,KAAAsF,YAAA2Z,EAAAA,GACAtN,EAAA,EAAuBA,GAAA0N,EAAgB1N,IAAA,CACvC,GAAA2N,GAAA,GAAA3c,GAAA8S,MACAxO,OACAyO,GAAA,EACAC,GAAAhE,EAAAsN,EACArJ,GAAA5V,KAAAqF,WACAwQ,GAAAlE,EAAAsN,GAEApU,OACAuU,UAAA,GACAJ,QAAAA,GAEAjN,EAAA,EACAC,WAAA,EACAuD,OAAA,WAEAvV,MAAA2e,cAAAhY,IAAA2Y,KAgEAra,EAAAsa,WAAAta,EAAAua,UAAA,SAAA3S,EAAAC,EAAA1J,EAAAia,GACA,GAAA7C,GAAAnW,EAAAoM,aAKA,IAJArN,GAAAA,EAAAyH,OAAAzH,EAAAyH,MAAA3C,WACAsS,EAAApX,EAAAyH,MAAA3C,WAGAzD,EAAA+V,GACA,MAAA,KAEA,IAAAC,GAAAhW,EAAA+V,GACApT,EAAA,GAAAqT,GAAA5N,EAAAC,EAAA1J,EAKA,OAJAia,IACAjW,EAAAtE,MAAAE,IAAAC,EAAAwc,SAAAxb,EAAAmC,MAAAiX,IAGAjW,GAOAnC,EAAAiU,kBAAA,SAAA9P,GACApJ,KAAA6B,kBAAAqX,kBAAA9P,IAQAnE,EAAAsJ,cAAA,SAAAmR,GACA,GAAAC,GAAAD,EAAAnC,YAAA,WACA,IAAAoC,EAAA,CAGA,GAAAC,GAAA5f,KAAA6f,iBACAC,EAAAnb,EAAAwK,gBAAAwQ,EAAA9U,MAAAE,KAAA4U,EAAA9U,MAAAkV,UACAC,EAAA,IAAAjc,EAAA0O,QAAAkN,GAAA1Q,MAAAjP,KAAAgB,QAAA,EACA4e,GAAA/U,MAAAoE,MAAA,IAAAlL,EAAA0O,QAAAkN,GAAA1Q,MAAAjP,KAAAgB,QAAA,KACA4e,EAAA/U,MAAAqE,QAAA,EAAA4Q,EAAA5Q,QAAA,IAAAlP,KAAAgB,QAAA,KACA4e,EAAA/U,MAAAoV,OAAA,qBACAL,EAAAM,UAAAP,EAAA9U,MAAAE,KACA2U,EAAAjS,UACA1C,MACAA,KAAA,MAGA/K,KAAAe,KAAAof,YAAAP,GACA5f,KAAAe,KAAA8J,MAAAI,SAAA,WACA2U,EAAA/U,MAAAuV,YAAA,IAAAN,EAAAM,YAAA,IAAA,KACAR,EAAA/U,MAAAiI,KAAA6M,EAAA1U,SAAA,GAAA6U,EAAA5Q,QAAAlP,KAAAgB,QAAAhB,KAAAc,MACAmK,SAAA,GAAA,KACA2U,EAAA/U,MAAA+H,MAAA+M,EAAA1U,SAAA,GAAA,IAAA6U,EAAA7Q,OAAAjP,KAAAgB,QACAhB,KAAAc,MAAAmK,SAAA,GAAA,KACA2U,EAAAS,QACAT,EAAAU,SACAtgB,KAAAugB,gBAAAT,EAAAF,EAAAI,GACAJ,EAAAY,QAAA,WACAZ,EAAA/U,MAAAoE,MAAA6Q,EAAA7Q,MAAA,GAAA,OAAA2Q,EAAA/U,MAAAoE,MACA2Q,EAAA/U,MAAAqE,OAAA0Q,EAAAa,aAAA,MAEAb,EAAAc,WAAA,WACAhB,EAAAjS,UACA1C,MACAA,KAAA6U,EAAA3Z,OAAA,MAGA2Z,EAAAnQ,YAOAxK,EAAA6J,SAAA,SAAA6R,GACA,GAAAC,GAAA,IACAC,GAAA,EACAjB,EAAA5f,KAAA6f,iBACAiB,EAAA7c,EAAAmC,MAAAua,EAAA9V,MAAAE,MACA+U,EAAAnb,EAAAwK,gBAAA2R,EAAAH,EAAA9V,MAAAkV,UACAgB,EAAAjB,EAAA7Q,MAAA,GAAA,IAAA6Q,EAAA7Q,MAAAjP,KAAAgB,QAAA,GAAA,GACAggB,GAAA,EAAAlB,EAAA5Q,QAAA,IAAAlP,KAAAgB,OACA4e,GAAA/U,MAAAoE,MAAA8R,EAAA,KACAnB,EAAA/U,MAAAqE,OAAA8R,EAAA,IACA,IAAAC,GAAAld,EAAA0O,QAAAkO,GACAX,EAAA,IAAAiB,EAAAhS,MAAAjP,KAAAgB,OACA4e,GAAA/U,MAAAuV,YAAA,IAAAN,EAAAM,YAAA,MAAA,KACAR,EAAA/U,MAAAoV,OAAA,qBACAL,EAAAM,UAAAS,EAAA9V,MAAAE,KACA6U,EAAA/U,MAAAmV,SAAAA,EAAA,KACAhgB,KAAAyN,SAAAkT,GAAiC5V,KAAA,KACjC/K,KAAAe,KAAAof,YAAAP,GACA5f,KAAAe,KAAA8J,MAAAI,SAAA,UACA,IAAAiW,GAAA,CACA,SAAAP,EAAA9V,MAAAsW,YACAD,EAAA,GAEA,SAAAP,EAAA9V,MAAAsW,YACAD,EAAA,EAEA,IAAAE,GAAA,CACAT,GAAA9V,MAAAG,cAAA,UAAA2V,EAAA9V,MAAAG,eACAoW,EAAA,EACApB,EAAAY,EAAAK,EAAAhS,MAAAjP,KAAAgB,QACA4e,EAAA/U,MAAAmV,SAAAA,EAAA,MAEAW,EAAA9V,MAAAG,cAAA,OAAA2V,EAAA9V,MAAAG,eACAoW,KACApB,EAAAY,EAAAK,EAAAhS,MAAAjP,KAAAgB,QACA4e,EAAA/U,MAAAmV,SAAAA,EAAA,MAEAJ,EAAA/U,MAAAiI,KAAAmO,EAAAtP,EAAAqP,EAAA,EAAAI,GAAAH,EAAA/R,OAAA4Q,EAAA5Q,OACA,IAAAlP,KAAAgB,QAAAhB,KAAAc,MAAAmK,SAAA,GAAA,KACA2U,EAAA/U,MAAA+H,MAAAqO,EAAAxP,EAAAyP,EAAAH,EAAA,GAAA/gB,KAAAgB,QACAhB,KAAAc,MAAAmK,SAAA,GAAA,KACA2U,EAAAS,QACAT,EAAAU,SACAV,EAAAY,QAAA,WACA,GAAAzY,MAAAjD,SAAAA,EAAAE,OACA6b,GAAA,EACAjB,EAAAyB,WACa,CACb,GAAAvB,GAAAnb,EAAAwK,gBAAAyQ,EAAA3Z,MAAA0a,EAAA9V,MAAAkV,SACA/f,MAAAugB,gBAAAT,EAAAF,EAAAI,KAESxY,KAAAxH,MAET4f,EAAA0B,OAAA,WACA,GAAAT,EAIA7gB,KAAAyN,SAAAkT,GAAyC5V,KAAA+V,QAJzC,CACA,GAAA/V,GAAA/K,KAAAuhB,WAAA3B,EAAA3Z,MAAA2Z,EAAA/U,MAAAmV,SACAhgB,MAAAyN,SAAAkT,GAAyC5V,KAAAA,IAIzC6U,EAAAnQ,UACSjI,KAAAxH,OAOTiF,EAAA4a,eAAA,WACA,GAAAD,GAAAtB,SAAAC,cAAA,WASA,OARAqB,GAAA/U,MAAAI,SAAA,WACA2U,EAAA/U,MAAAwE,QAAA,MACAuQ,EAAA/U,MAAAlF,OAAA,OACAia,EAAA/U,MAAA2W,WAAA,MACA5B,EAAA/U,MAAAuV,WAAA,OACAR,EAAA/U,MAAA4W,SAAA,SACA7B,EAAA/U,MAAAoV,OAAA,IACAL,EAAA8B,YAAA,EACA9B,GAOA3a,EAAAsc,WAAA,SAAAtb,EAAAgJ,GACA,GAAA0S,GAAArD,SAAAC,cAAA,OACAoD,GAAA9W,MAAAI,SAAA,WACA0W,EAAA9W,MAAA4W,SAAA,SACAE,EAAA9W,MAAAoV,OAAA,IACA0B,EAAA9W,MAAAwE,QAAA,IACAsS,EAAA9W,MAAA+H,KAAA,IACA+O,EAAA9W,MAAAiI,IAAA,IACA9S,KAAAe,KAAAof,YAAAwB,EACA,IAAAC,GAAA3b,EAAAmP,MAAA,MACAyM,EAAA,EAiCA,OAhCAD,GAAAzU,QAAA,SAAA2U,EAAAzU,GACA,GAAA0U,GAAAD,EAAA3b,MACA,IAAA,GAAA4b,OAKA,KAAA,GADAC,GAAAC,EAAAC,EADAC,EAAA,GAEAC,EAAA,EAAoCA,EAAAL,EAAoBK,IACxDJ,EAAAF,EAAAO,OAAAD,GACAT,EAAAzB,UAAAyB,EAAAzB,UAAA8B,EACAC,EAAAN,EAAAW,YACAJ,EAAAK,OAAAtT,EAAAuT,UAAA,EAAAvT,EAAA9I,OAAA,IACA8b,EAAAC,GACAL,GAAAM,EACAN,GAAA,KACAF,EAAAzB,UAAA8B,EACAG,EAAAH,GACqBI,GAAAL,EAAA,GACrBF,GAAAM,EAAAH,EACA3U,EAAAuU,EAAAzb,OAAA,IACA0b,GAAA,MAEAF,EAAAzB,UAAA,GACAiC,EAAA,IAEAA,GAAAH,IAMAhiB,KAAAe,KAAA0hB,YAAAd,GACAE,GAOA5c,EAAAsb,gBAAA,SAAAT,EAAAF,EAAA3Q,GACA,GAAAyT,GAAA,CACA9C,GAAA/U,MAAAoE,MAAA,EACA2Q,EAAA/U,MAAAoE,MAAA,IAAA6Q,EAAA7Q,MAAAjP,KAAAgB,QAAA,KAEA0hB,EADAzT,EAAA,GACAA,EAEA,GAEA6Q,EAAA7Q,OAAAyT,IACA9C,EAAA/U,MAAAoE,MAAAyT,EAAA,MAEA9C,EAAA/U,MAAAqE,OAAA,MACA0Q,EAAA/U,MAAAqE,OAAA0Q,EAAAa,aAAA,KACAb,EAAAa,cAAA,IACAb,EAAA/U,MAAAqE,OAAA,SAeAjK,EAAAwI,SAAA,SAAArE,EAAAhG,GACAgG,EAAAqE,SAAArK,GACAa,EAAA8M,MAAA3H,EAAAtG,MAAAuD,IAAA,iBAAAjD,GAAA,IAcA6B,EAAA2S,SAAA,SAAAxO,EAAAhG,GACAgG,EAAAwO,SAAAxU,GACAgG,EAAAtG,OACAmB,EAAA8M,MAAA3H,EAAAtG,MAAAuD,IAAA,iBAAAjD,GAAA,IAyBA6B,EAAA0d,YAAA1d,EAAA2d,WAAA,SAAAxZ,EAAAe,GACA,GAAArJ,GAAAd,KAAAmd,WAAA,SACAtS,OACAgH,KAAA,gBACAC,OAAA,kBAGAhR,GAAAia,aAAA,CACA,IAAAhQ,GAAA/K,KAAAmd,WAAA,QACAtS,OACAE,KAAAZ,EAAAY,KACAgV,SAAA5V,EAAA4V,SACAlO,KAAA1H,EAAA0Y,SACAC,aAAA,OAEA1W,YAAA,EACAnB,UAAA,EAAA,GACA8G,EAAA,GAEAhH,GAAAgQ,aAAA,EACAja,EAAA6F,IAAAoE,GACAzG,EAAAsK,UAAAxF,GACAA,EAAAjB,OAAAxB,IAAA7F,GAEAd,KAAAc,MAAA6F,IAAA7F,EAEA,IAAAic,GAAAjc,EAAAqO,kBAAAF,MAAA,EACA+N,EAAAlc,EAAAqO,kBAAAD,OAAA,EACA6T,IACA,EAAA,IACAhG,EAAA,IACAA,EAAAC,IACAD,EAAA,EAAAC,IACAD,EAAA,EAAAC,EAAA,IACAD,EAAA,EAAAC,IACA,EAAAA,IACA,EAAA,IAEAgG,EAAAhjB,KAAAmd,WAAA,YACAlW,OACA8b,OAAAA,GAEAlY,OACAgH,KAAA1H,EAAA8Y,eACAnR,OAAA3H,EAAA8Y,gBAEA7W,YAAA,EACA2F,EAAA,GAEAiR,GAAAjI,aAAA,EACAja,EAAA6F,IAAAqc,EACA,IAAAE,IAAA9Z,EAAA6B,SAAA,GAAA7B,EAAA+F,kBAAAF,OAAAnO,EAAAqO,kBAAAF,MACA,GAAA7F,EAAA6B,SAAA,GAAAnK,EAAAqO,kBAAAD,OAAA,EACApO,GAAA0N,KAAA,WAAA0U,GACA9Z,EAAA+S,MAAArb,CAEA,IAAAgC,GAAA,GAAAC,MAKA,OAJAD,GAAAE,IAAAC,EAAAC,aAAAD,EAAAkgB,OACArgB,EAAAE,IAAAC,EAAAwH,QAAAxG,EAAAmC,MAAA+D,IACArH,EAAAE,IAAAC,EAAAmgB,WAAAha,EAAAtG,MAAAuD,IAAApD,EAAAogB,KACAviB,EAAAgC,MAAAA,EACAhC,GAOAmE,EAAAqe,UAAA,SAAAziB,GACA,MAAAsD,GAAAmf,UAAAtjB,KAAAiC,IAAApB,IAGAoE,EAAAsO,mBAAA,WACA,GAAAvT,KAAA4P,eAAA,CAaA,IAAA,GAZAyC,GAAArS,KAAA4P,eAAAtG,WAAA+O,OAAA,SAAAjL,GACA,MAAA,oBAAAA,EAAA/E,OAEAkb,EAAAvjB,KAAAc,MAAAwI,WACA+O,OAAA,SAAAjL,GACA,MAAA,oBAAAA,EAAA/E,OAEAmb,IAAA,SAAApW,GACA,MAAAA,GAAA/M,KAEAmY,EAAAxY,KAAA4P,eAAA3E,SAAA,GACAsN,EAAAvY,KAAA4P,eAAA3E,SAAA,GACAoC,EAAA,EAA2BA,EAAAgF,EAAAlM,OAAkBkH,IAAA,CAC7C,GAAAiF,GAAAD,EAAAhF,GACAoP,EAAAnY,EAAAgG,YAAAgI,GAAAA,EAAArH,SAAA,GAAAqH,EAAAlP,QAAA6D,MAAAwK,EAAAa,EAAArH,SAAA,GACAyR,EAAApY,EAAAgG,YAAAgI,GAAAA,EAAArH,SAAA,GAAAqH,EAAAlP,QAAA6D,MAAA0K,EAAAW,EAAArH,SAAA,EACAjL,MAAA4P,eAAAH,OAAA6C,GAEAiR,EAAAhR,SAAAD,EAAAjS,KACAL,KAAAc,MAAA6F,IAAA2L,GAEA,eAAAA,EAAAxP,MAAAiD,OAAAsT,cACA/G,EAAA9D,KAAA,YAAAiO,EAAAjE,EAAAkE,EAAAnE,IACAvY,KAAA6B,kBAAAqX,kBAAA5G,IAGAtS,KAAA4P,eAAA7G,IAAA,aACA/I,KAAAc,MAAA2O,OAAAzP,KAAA4P,kBAIA3K,EAAAqD,YAAA,SAAAc,EAAAqI,EAAAE,GACA,GAAA8R,GAAAzjB,KAAAc,MAAAmK,SAAA,GACAyY,EAAA1jB,KAAAc,MAAAmK,SAAA,EACAjL,MAAAuT,qBACAvT,KAAA4P,eAAA,GAAApL,IACAyC,OAAmBgI,MAAA,EAAAC,OAAA,GACnBjE,WAAAwG,EAAAgS,GAAAzjB,KAAAgB,SAAA2Q,EAAA+R,GAAA1jB,KAAAgB,SACAkL,gBAAA,EACArB,OACAuU,UAAA,EAAA,GACAvN,KAAA,wBACAC,OAAA,UAGA9R,KAAA4P,eAAA9J,KAAA,aACA9F,KAAAc,MAAA6F,IAAA3G,KAAA4P,gBACA5P,KAAAkL,KAAAlL,KAAA4P,eAEA,IAAA+L,GAAA,SAAA5T,GACA,GAAA4b,GAAAlS,GAAA1J,EAAAQ,QAAAkJ,EAAA1J,EAAAQ,QACAqb,EAAAjS,GAAA5J,EAAAS,QAAAmJ,EAAA5J,EAAAS,QACAyG,EAAAoE,KAAAC,IAAAvL,EAAAQ,QAAAkJ,GACAvC,EAAAmE,KAAAC,IAAAvL,EAAAS,QAAAmJ,EACA3R,MAAA4P,eAAA3I,OACAgI,MAAAA,EAAAjP,KAAAgB,QACAkO,OAAAA,EAAAlP,KAAAgB,SAEAhB,KAAA4P,eAAAiU,eAA+C5c,OAAQgI,MAAAA,EAAAjP,KAAAgB,QAAAkO,OAAAA,EAAAlP,KAAAgB,SAAsDiK,WAAA0Y,EAAAF,GAAAzjB,KAAAgB,SAAA4iB,EAAAF,GAAA1jB,KAAAgB,YACpGwG,KAAAxH,KACTA,MAAAiC,IAAA8E,GAAA,YAAA4U,EAEA,IAAAW,GAAA,SAAAvU,GACA/H,KAAAiC,IAAA8G,IAAA,YAAA4S,GACA3b,KAAAiC,IAAA8G,IAAA,UAAAuT,GACAtc,KAAAiC,IAAA8G,IAAA,YAAAuT,EAEA,IAAApB,GAAAlb,KACAyB,EAAAzB,KAAAc,MAAAwI,WAAA+O,OAAA,SAAAjL,GACA,MAAAA,GAAA/M,KAAA6a,EAAAtL,eAAAvP,IAAA+M,EAAAtK,OAAA,eAAAsK,EAAAtK,MAAAiD,OAAAsT,cAEAmC,EAAAxb,KAAAc,MAAAwI,WAAA+O,OAAA,SAAAjL,GACA,MAAAA,GAAAtK,OAAA,eAAAsK,EAAAtK,MAAAiD,OAAAsT,cAEAb,EAAAxY,KAAA4P,eAAA3E,SAAA,GACAsN,EAAAvY,KAAA4P,eAAA3E,SAAA,GACAgE,EAAAjP,KAAA4P,eAAAxM,QAAA6D,MAAAgI,MACAC,EAAAlP,KAAA4P,eAAAxM,QAAA6D,MAAAiI,OACA4U,EAAA,CACAriB,GAAA0L,QAAA,SAAAmF,GACA,GAAAE,GAAAzO,EAAA0O,QAAAH,GAAA,GACA2K,EAAAzK,EAAAvD,MACAiO,EAAA1K,EAAAtD,OACAuN,EAAAjK,EAAAf,EAAAwL,EAAA,EACAP,EAAAlK,EAAAb,EAAAuL,EAAA,CACAT,IAAAjE,GAAAkE,GAAAnE,GAAAkE,EAAAQ,GAAAzE,EAAAvJ,GAAAyN,EAAAQ,GAAA3E,EAAArJ,IACAgM,EAAApa,MAAA2O,OAAA6C,GACA4I,EAAAtL,eAAAjJ,IAAA2L,GACA4I,EAAArY,cAAA2G,KAAA8I,GACAA,EAAA9D,KAAA,YAAA8D,EAAArH,SAAA,GAAAuN,EAAAlG,EAAArH,SAAA,GAAAsN,IACAuL,OAGAtI,EAAArO,QAAA,SAAAmF,GACA,GAAAzF,GAAAqO,EAAAtL,eAAAtG,WAAAoN,KAAA,SAAAtJ,GACA,MAAAA,GAAA/M,KAAAiS,EAAAzF,UAAAxM,KAEAyM,EAAAoO,EAAAtL,eAAAtG,WAAAoN,KAAA,SAAAtJ,GACA,MAAAA,GAAA/M,KAAAiS,EAAAxF,QAAAzM,IAEAwM,IAAAC,GACAoO,EAAApa,MAAA2O,OAAA6C,GACA4I,EAAAtL,eAAAjJ,IAAA2L,GACA4I,EAAArY,cAAA2G,KAAA8I,GACA4I,EAAArZ,kBAAAqX,kBAAA5G,EAAAzF,aACiBA,GAAAC,IAEjBoO,EAAApa,MAAA2O,OAAA6C,KAGAwR,EAIA9jB,KAAA4P,eAAA2N,YAAA,mBAAA/O,KAAA,SACAqD,KAAA,mBAJA7R,KAAA4P,eAAA7G,IAAA,aACA/I,KAAAc,MAAA2O,OAAAzP,KAAA4P,iBAMA5P,KAAA4P,eAAA9M,MAAAE,IAAA,mBAAAmB,EAAAoY,cAAAvc,KAAA4P,eAAA3E,WACAjL,KAAA4P,eAAA9M,MAAAE,IAAA,gBAAAhD,KAAA4P,eAAA3I,QAESO,KAAAxH,KACTA,MAAAiC,IAAA8E,GAAA,UAAAuV,GACAtc,KAAAiC,IAAA8E,GAAA,YAAAuV,IAGArX,EAAAwD,kBAAA,SAAAgJ,EAAAE,GAEA,GAAAwJ,GAAAnb,KAAAc,MAAAmK,SACAmQ,EAAApb,KAAAc,MAAAmK,SAAA,GACAoQ,EAAArb,KAAAc,MAAAmK,SAAA,GAEA0Q,EAAA,SAAA5T,GACA,GAAAkH,GAAAjP,KAAAc,MAAAqO,kBAAAF,MAAAjP,KAAAgB,QACAkO,EAAAlP,KAAAc,MAAAqO,kBAAAD,OAAAlP,KAAAgB,QACA+iB,EAAA/jB,KAAAc,MAAAqO,kBAAAsC,EAAAzR,KAAAgB,QACAgjB,EAAAhkB,KAAAc,MAAAqO,kBAAAwC,EAAA3R,KAAAgB,QACAijB,GAAA,IAAAhV,EAAA8U,GAAA,IAAA7U,EAAA8U,IACAE,GAAAlkB,KAAAiC,IAAAoD,WAAA0e,EAAA,GAAA/jB,KAAAiC,IAAAqD,YAAA0e,EAAA,IACApI,EAAA7T,EAAAQ,QAAAkJ,EACAoK,EAAA9T,EAAAS,QAAAmJ,CACAwJ,GAAA,GAAAC,EAAAQ,EACAT,EAAA,GAAAE,EAAAQ,EACAV,EAAA,GAAA+I,EAAA,IAAA/I,EAAA,GAAA+I,EAAA,IAAA/I,EAAA,GACA8I,EAAA,IAAA9I,EAAA,GAAA8I,EAAA,KAGAjkB,KAAAc,MAAA0N,KAAA,WAAA2M,GACA,GAAAnb,KAAAkB,UACAlB,KAAA0B,QAAAyiB,wBAAAhJ,EAAAnb,KAAAgB,WAGSwG,KAAAxH,KACTA,MAAAiC,IAAA8E,GAAA,YAAA4U,EAEA,IAAAW,GAAA,WACAtc,KAAAiC,IAAA8G,IAAA,YAAA4S,GACA3b,KAAAiC,IAAA8G,IAAA,UAAAuT,GACAtc,KAAAiC,IAAA8G,IAAA,YAAAuT,IACS9U,KAAAxH,KACTA,MAAAiC,IAAA8E,GAAA,UAAAuV,GACAtc,KAAAiC,IAAA8E,GAAA,YAAAuV,IAGArX,EAAAmf,UAAA,WACA,GAAAC,GAAArkB,KAAAc,MAAAqO,kBAAAF,MACAqV,EAAAtkB,KAAAc,MAAAqO,kBAAAD,OACAqV,EAAAvkB,KAAAqF,WACAmf,EAAAxkB,KAAAsF,YACAmf,EAAA,EACAxX,IACAoX,GAAAC,EAAAC,EAAAC,EACAH,EAAAE,IACAE,EAAAF,EAAAF,GAGAC,EAAAE,IACAC,EAAAD,EAAAF,GAGArX,EAAA,GAAAoG,KAAAC,IAAAtT,KAAAc,MAAAqO,kBAAAsC,GAAAgT,EACAxX,EAAA,GAAAoG,KAAAC,IAAAtT,KAAAc,MAAAqO,kBAAAwC,GAAA8S,EACAzkB,KAAAc,MAAA0N,KAAA,YAAAvB,EAAA,GAAAA,EAAA,KACAjN,KAAAc,MAAA0N,KAAA,SAAAiW,EAAAA,IACAzkB,KAAAoB,eAAAqjB,CACA,IAAAC,IAAAzX,EAAA,GAAAA,EAAA,GAAAjN,KAAAoB,eAAAijB,EAAAC,EACA,OAAAI,IAOAzf,EAAA0f,SAAA,SAAAC,GACA,GAAAC,GACA1J,EAAAnb,KAAAc,MAAAmK,QAEA4Z,GADA5gB,EAAAiJ,QAAA0X,GACA3gB,EAAA6gB,WAA0CC,KAAAH,EAAA,GAAAI,KAAAJ,EAAA,GAAAK,KAAAL,EAAA,GAAAM,KAAAN,EAAA,KAE1C3gB,EAAA6gB,UAAuCF,GAEvCzJ,EAAA,GAAAnb,KAAAiC,IAAArB,IAAAukB,YAAA,GAAAN,EAAAE,MAAAF,EAAAI,KAAAJ,EAAAE,MAAA,GACA5J,EAAA,GAAAnb,KAAAiC,IAAArB,IAAAwkB,aAAA,GAAAP,EAAAG,MAAAH,EAAAK,KAAAL,EAAAG,MAAA,GACAhlB,KAAAc,MAAA0N,KAAA,WAAA2M,IAGAlW,EAAAgH,YAAA,WACAjM,KAAAuB,SAAAgM,OAAAvN,KAAAsB,KAAAtB,KAAAuB,SAAA4E,OAAAnG,KAAA,MACAA,KAAAsB,MAAA,CACA,IAAAqI,GAAA3J,KAAAyJ,QACAzJ,MAAAuB,SAAAiI,KAAA6b,KAAAC,UAAA3b,KAOA1E,EAAA4B,QAAA,SAAAf,GACA,GAAAA,EAAA,CACA,GAAAyf,GAAA,CASA,IARA,aAAAzf,IACAyf,OACAvlB,KAAAwlB,KAAAD,EAAAvlB,KAAAiC,IAAAoD,WAAA,EAAArF,KAAAiC,IAAAqD,YAAA,IAEA,WAAAQ,IACAyf,EAAA,IACAvlB,KAAAwlB,KAAAD,EAAAvlB,KAAAiC,IAAAoD,WAAA,EAAArF,KAAAiC,IAAAqD,YAAA,KAEAmgB,MAAA3f,GAAA,CACA,GAAAoB,GAAAlH,KAAAc,KACA,IAAAoG,EAAA,CACA,GAAAwe,GAAA5f,EAAAoB,EAAA+M,MAAA,EACAjU,MAAA2lB,MAAA7f,EACA9F,KAAAgB,QAAA8E,EACA9F,KAAA4lB,SAAA5lB,KAAAiC,IAAAoD,WAAA,EAAArF,KAAAiC,IAAAqD,YAAA,EAAAogB,SAIA1lB,MAAAiC,IAAA8E,GAAA,aAAA9C,EAAAuD,KAAA,SAAAR,GACA5C,EAAAyhB,KAAA7e,EAAAe,MACA,IAAAwd,GAAAve,EAAA8e,WAAA,EAAA,QACA9lB,MAAAwlB,KAAAD,EAAAvlB,KAAAiC,IAAAoD,WAAA,EAAArF,KAAAiC,IAAAqD,YAAA,IACatF,QAObiF,EAAAugB,KAAA,SAAAD,EAAAQ,EAAAC,GACA,GAAA,GAAAhmB,KAAAiB,SAAA,CAGA,GAAAiG,GAAAlH,KAAAc,KACA,IAAAoG,EAAA,CAEA,GAAA+e,GAAAjmB,KAAA2lB,MAAA3lB,KAAA2lB,OAAA,CACAM,IAAAV,EAEAU,EAAA1D,OAAA0D,EAAAC,QAAA,GACA,IAAAR,GAAAO,EAAAjmB,KAAA2lB,KACA,IAAAM,EAAAjmB,KAAAoD,QAAA+iB,UAAAF,EAAAjmB,KAAAoD,QAAAgjB,SACA,MAEApmB,MAAA2lB,MAAAM,EAEAjmB,KAAAgB,QAAAilB,EAEAjmB,KAAA4lB,SAAAG,EAAAC,EAAAN,MAOAzgB,EAAA2gB,SAAA,SAAAG,EAAAC,EAAAN,GACA,GAAAxe,GAAAlH,KAAAc,MACAmM,EAAA/F,EAAA+D,SACAgJ,EAAA/M,EAAA+M,KAEAhH,GAAA,KAAA8Y,EAAA9Y,EAAA,KAAAyY,EAAA,GACAzY,EAAA,KAAA+Y,EAAA/Y,EAAA,KAAAyY,EAAA,GACAzR,EAAA,IAAAyR,EACAzR,EAAA,IAAAyR,EACAxe,EAAAsH,KAAA,YAAAvB,EAAA,GAAAA,EAAA,KACA/F,EAAAsH,KAAA,SAAAyF,EAAA,GAAAA,EAAA,KACA,GAAAjU,KAAAkB,UACAlB,KAAA0B,QAAA2kB,gBAAApZ,EAAA,GAAAA,EAAA,GAAAyY,EAAA1lB,KAAAgB,UAQAiE,EAAAuX,aAAA,SAAArb,GACAnB,KAAAkB,UAAA,EACAlB,KAAAmB,aAAAA,CACA,IAAA+hB,GAAAjf,EAAAmC,MAAApG,KAAAc,MAAAmK,UACAqb,EAAAriB,EAAAmC,MAAApG,KAAAc,MAAAmT,MACAjU,MAAAc,MAAA0N,KAAA,YAAA,EAAA,IACAxO,KAAAc,MAAA0N,KAAA,SAAA,EAAA,GACA,IAAAkW,GAAA1kB,KAAAokB,YACAmC,EAAAvmB,KAAAsjB,WACAtjB,MAAAc,MAAA0N,KAAA,WAAA0U,GACAljB,KAAAc,MAAA0N,KAAA,QAAA8X,GACAtmB,KAAA0B,QACA1B,KAAA0B,QAAA8kB,UAAAD,EAAAvmB,KAAAc,MAAAqO,oBAEAnP,KAAA0B,QAAA,GAAAoC,GAAA9D,KAAAA,KAAAc,MAAAmK,SAAAjL,KAAAc,MAAAqO,kBACAhO,EAAAujB,EAAA6B,GACAnb,WAAAnH,EAAAuD,KAAA,WACAxH,KAAAwc,aAAAxc,KAAAmB,eACanB,MAAA,KAEbA,KAAA0B,QAAA+kB,UAAAC,iBAAA,YAAA,SAAA1f,GACA,GAAAwR,GAAAxR,EAAA2f,QACApO,EAAAvR,EAAA4f,QACAC,EAAAtE,OAAAviB,KAAA0B,QAAA+kB,UAAA5b,MAAA+H,KAAA4P,UAAA,EAAAxiB,KAAA0B,QAAA+kB,UACA5b,MAAA+H,KAAAzM,OAAA,IACA2gB,EAAAvE,OAAAviB,KAAA0B,QAAA+kB,UAAA5b,MAAAiI,IAAA0P,UAAA,EAAAxiB,KAAA0B,QAAA+kB,UACA5b,MAAAiI,IAAA3M,OAAA,IACA4gB,EAAA,SAAA/f,GACA,GAAAuB,GAAAvB,EAAA2f,QAAAnO,EACAhQ,EAAAxB,EAAA4f,QAAArO,CACAvY,MAAA0B,QAAA+kB,UAAA5b,MAAA+H,KAAAiU,EAAAte,EAAA,KACAvI,KAAA0B,QAAA+kB,UAAA5b,MAAAiI,IAAAgU,EAAAte,EAAA,KACAxI,KAAA0B,QAAAslB,oBAAAhnB,KAAAc,MAAAd,KAAAgB,UACawG,KAAAxH,KAEbA,MAAA0B,QAAA+kB,UAAAC,iBAAA,YAAAK,EAEA,IAAAE,GAAA,WACAjnB,KAAA0B,QAAA+kB,UAAAS,oBAAA,YAAAH,GACA/mB,KAAA0B,QAAA+kB,UAAAS,oBAAA,UAAAD,IACazf,KAAAxH,KACbA,MAAA0B,QAAA+kB,UAAAC,iBAAA,UAAAO,IACSzf,KAAAxH,QAQTiF,EAAAkiB,mBAAA,SAAA/d,GACA,GAAA9E,EAAAsK,UAAAxF,GAAA,CAEA,GAAA0S,IACA7M,MAAA7F,EAAAnC,MAAAgI,MACAC,OAAA9F,EAAAnC,MAAAiI,OACAjE,SAAA7B,EAAA6B,SACAgQ,OAAA,EACA7R,KAAAA,EAEAA,GAAAjB,OAAA+T,gBAAAJ,GAEA9b,KAAA6B,kBAAAqX,kBAAA9P,GACA9E,EAAAgG,YAAAlB,IACAA,EAAAP,KAAA,SAAAU,GACAvJ,KAAA6B,kBAAAqX,kBAAA3P,IACa/B,KAAAxH,QAIbiE,EAAAmjB,MAAAzmB,EAAAkD,EAGA,IAAAwjB,GAAA,GAAAC,MAAA,EACA5hB,KACA6hB,EAAA,0BAYAC,GAKAC,QAAA,QACAC,cACAxlB,QAAA,SAwBAslB,GAAArlB,KAAA,SAAAvB,EAAAC,GACA,IAAAD,EACA,KAAA,IAAA+mB,OAAA,kCAGA9mB,GAAAA,MAEAoD,EAAAia,SAAArd,GACAiF,KAAA,OACAsI,YAAA,EACAE,cAAA,EACA1H,MAAA,EACAqB,UAAA,UACAxF,SACAmL,MAAA,GAEA7B,oBAAA,EACAkK,WAAA,EACAE,WAAA,EACAyR,aAAA,KACAC,aAAA,KACA1B,SAAA,IACAC,SAAA,IAGA,IAAAoB,GAAA,GAAA7mB,GAAAC,EAAAC,EAQA,OAPA2mB,GAAArlB,OACAqlB,EAAAljB,KAAAA,EACAkjB,EAAAnnB,GAAA,MAAAgnB,IACA3hB,EAAA8hB,EAAAnnB,IAAAmnB,EAEA5mB,EAAAknB,cAAAlnB,EAAAknB,aAAAP,EAAAC,EAAAnnB,IAEAmnB,GAUAA,EAAAO,iBAAA,SAAAnnB,GACA,GAAAoF,GAAApF,EAAAonB,aAAAT,EACA,OAAA7hB,GAAAM,IASAwhB,EAAA/hB,QAAA,SAAAwiB,GACA,GAAAC,EACAjkB,GAAAkkB,MAAAF,GACAC,EAAAV,EAAAO,iBAAAE,GACS,gBAAAA,KACTC,EAAAxiB,EAAAuiB,IAEAC,YAAAV,KAAAU,EAAA3iB,cACA2iB,EAAAziB,WAKA+hB,EAAA7kB,QAAAA,EACA6kB,EAAApe,KAAAjF,EAAAikB,iBAAA7jB,GACAijB,EAAAa,KAAA5jB,EAEA+iB,EAAA9iB,OAAAA,EACA8iB,EAAAljB,KAAAA,EACAkjB,EAAAc,UAAArlB,EACAukB,EAAAzjB,KAAAA,EACAyjB,EAAAzjB,KAAA,cAAAa,EAAA2jB,cACAtkB,EAAA4E,MACA,MAAA,OAAA,SAAA,UAAA,WACA,SAAA,SAAA,OAAA,QAAA,UACA,WAAA,WAAA,aAAA,SACA,QAAA,YAEA,SAAAR,GACAmf,EAAAzjB,KAAAsE,GAAApE,EAAAoE,KAIAxI,EAAAD,QAAA4nB,GHgFM,SAAU3nB,EAAQD,GI/vGxB4oB,SAAAtjB,UAAAsC,OACAghB,SAAAtjB,UAAAsC,KAAA,SAAAihB,GACA,GAAA,kBAAAzoB,MAEA,KAAA,IAAA0oB,WAAA,uEAGA,IAAAC,GAAAvP,MAAAlU,UAAA0jB,MAAAroB,KAAA2F,UAAA,GACA2iB,EAAA7oB,KACA8oB,EAAA,aACAC,EAAA,WACA,MAAAF,GAAAjO,MAAA5a,eAAA8oB,IAAAL,EAAAzoB,KAAAyoB,GAAAjiB,OACAmiB,EAAAza,OAAAkL,MAAAlU,UAAA0jB,MAAAroB,KAAA2F,aAMA,OAHA4iB,GAAA5jB,UAAAlF,KAAAkF,UACA6jB,EAAA7jB,UAAA,GAAA4jB,GAEAC,IAKA,UAAAC,SAAA9jB,YACA8jB,QAAA9jB,UAAAuK,OAAA,WACAzP,KAAA6O,YACA7O,KAAA6O,WAAA4T,YAAAziB,QAKAipB,OAAA/jB,UAAAgkB,WACAD,OAAA/jB,UAAAgkB,SAAA,SAAAC,EAAAle,GACA,GAAAme,GAAAppB,KAAAqpB,YACA,gBAAApe,KAAAqe,SAAAre,IAAAoI,KAAAkW,MAAAte,KAAAA,GAAAA,EAAAme,EAAAjjB,UACA8E,EAAAme,EAAAjjB,QAEA8E,GAAAke,EAAAhjB,MACA,IAAAqjB,GAAAJ,EAAAvY,QAAAsY,EAAAle,EACA,OAAAue,SAAAA,IAAAve,KJ2wGM,SAAUpL,EAAQD,EAASM,GKpzGjC,YA2MA,SAAAupB,GAAAC,GACA,IAAAA,EAAAC,UAAA,CAGA,GAAAD,EAAAE,gBAAA,CACA,GAAA9X,GAAA4X,EAAA7e,MAAAiH,OACAD,EAAA6X,EAAA7e,MAAAgH,KAGAnG,EAAAge,EAAAG,WACAC,EAAAC,EAAAD,IACApe,GAAAmG,KAAAnG,EAAAmG,MACAA,IAAAA,YAAAmY,GAAAnY,EAAAiY,EAAAjY,QACAnG,EAAAoG,OAAApG,EAAAoG,QACAA,IAAAA,YAAAkY,GAAAlY,EAAAgY,EAAAhY,OAEA,IAAAmY,KACA,KAAA,GAAA5hB,KAAAqD,GACAA,EAAAwe,eAAA7hB,KACA4hB,EAAA5hB,GAAAqhB,EAAA7e,MAAAxC,GAIAqhB,GAAAS,YAAAF,EAEAP,EAAAE,iBAAA,EAEAF,EAAAjc,SAAAic,EAAAG,YACAH,EAAAU,IAAA,EAEAV,EAAAC,WAAA,GAMA,QAAAU,GAAAX,GACA,GAAAA,EAAAC,UAAA,CAIA,GAAAW,GAAAZ,EAAAS,WACAG,IAAAZ,EAAAjc,SAAA6c,GACAZ,EAAAU,IAAA,EAEAV,EAAAC,WAAA,GAMA,QAAAY,GAAAb,GACA,UAAAA,EAAA5jB,MAAA,cAAA4jB,EAAA5jB,KACA4jB,EAAAc,SAAA,SAAAjf,GACA,UAAAA,EAAAzF,MACA2jB,EAAAle,KAGAke,EAAAC,GAGA,QAAAe,GAAAf,GACA,UAAAA,EAAA5jB,KACA4jB,EAAAc,SAAA,SAAAjf,GACA,UAAAA,EAAAzF,MACAukB,EAAA9e,KAGA8e,EAAAX,GAMA,QAAAgB,GAAAhB,EAAAiB,GAGAjB,EAAAG,WAAAH,EAAAhe,YAAAif,MACAjB,EAAAE,iBAAA,EAMA,QAAAgB,MAEA5qB,KAAA6qB,cAAAN,EAAAvqB,MAMA,QAAA8qB,MAEA9qB,KAAA6qB,cAAAJ,EAAAzqB,MAMA,QAAA+qB,KACA/qB,KAAA6qB,cAAA,EACAN,EAAAvqB,MAMA,QAAAgrB,KACAhrB,KAAA6qB,cAAA,EACAJ,EAAAzqB,MAqDA,QAAAirB,GAAAC,EAAAxB,EAAAyB,EAAAC,EAAAvN,GACA,GAAAwN,GAAAH,EAAA,SAAA,GACAI,EAAAF,GACAA,EAAAG,WAAA,oBAAAF,GACAG,EAAAJ,GACAA,EAAAG,WAAA,kBAAAF,EAEAD,IAAAA,EAAAG,WAAA,aACA7B,EAAA+B,UAAAN,EAAAG,EAAAE,EAAA3N,IACA6L,EAAAlb,KAAA2c,GAAAtN,GAAAA,KApXA,GAAA5Z,GAAA/D,EAAA,GAEAwrB,EAAAxrB,EAAA,GACA+U,EAAA5B,KAAA4B,MACA0W,EAAAzrB,EAAA,GACA6pB,EAAA7pB,EAAA,IACA0rB,EAAA1rB,EAAA,IACA2rB,EAAA3rB,EAAA,IACA8pB,EAAA9pB,EAAA,IACA4rB,EAAA5rB,EAAA,IAEAyC,IACAA,GAAAopB,KAAA9nB,EACAtB,EAAA8D,MAAAvG,EAAA,IAEAyC,EAAAiI,MAAA1K,EAAA,IAEAyC,EAAAqpB,KAAA9rB,EAAA,IAEAyC,EAAAgC,YAAAzE,EAAA,IAEAyC,EAAAyF,OAAAlI,EAAA,IAEAyC,EAAAspB,OAAA/rB,EAAA,IAEAyC,EAAAupB,KAAAhsB,EAAA,IAEAyC,EAAAwpB,QAAAjsB,EAAA,IAEAyC,EAAAqgB,SAAA9iB,EAAA,IAEAyC,EAAA2S,KAAApV,EAAA,IAEAyC,EAAA8S,KAAAvV,EAAA,IAEAyC,EAAAypB,YAAAlsB,EAAA,IAEAyC,EAAA0pB,IAAAnsB,EAAA,IAEAyC,EAAA2pB,eAAApsB,EAAA,IAEAyC,EAAA4pB,eAAArsB,EAAA,IAEAyC,EAAA6pB,aAAAtsB,EAAA,IACAyC,EAAA8pB,OAAAvsB,EAAA,IAIAyC,EAAA+pB,YAAA,SAAA7rB,GACA,MAAA8qB,GAAA7G,OAAAjkB,IAMA8B,EAAAgqB,WAAA,SAAAC,EAAA/rB,GACA,MAAA6qB,GAAAmB,iBAAAD,EAAA/rB,IAUA8B,EAAAmqB,SAAA,SAAAF,EAAA/rB,EAAA2R,EAAA9N,GACA,GAAAqoB,GAAArB,EAAAsB,iBAAAJ,EAAA/rB,EACAirB,GAAAvrB,KAAAwsB,EACA,IAAAnW,GAAAmW,EAAA5d,iBACA,IAAAqD,EAAA,CACA,GAAAya,GAAArW,EAAA3H,MAAA2H,EAAA1H,MAEA,IAAA,WAAAxK,EAAA,CAEA,GACAwK,GADAD,EAAAuD,EAAAtD,OAAA+d,CAEAhe,IAAAuD,EAAAvD,MACAC,EAAAsD,EAAAtD,QAGAD,EAAAuD,EAAAvD,MACAC,EAAAD,EAAAge,EAEA,IAAAzb,GAAAgB,EAAAf,EAAAe,EAAAvD,MAAA,EACAyC,EAAAc,EAAAb,EAAAa,EAAAtD,OAAA,CAEAsD,GAAAf,EAAAD,EAAAvC,EAAA,EACAuD,EAAAb,EAAAD,EAAAxC,EAAA,EACAsD,EAAAvD,MAAAA,EACAuD,EAAAtD,OAAAA,EAGAlP,KAAAktB,WAAAH,EAAAva,GAIA,MADAvO,GAAAkpB,SAAAJ,EAAAjB,GACAiB,GAGApqB,EAAAyqB,UAAA1B,EAAA0B,UAOAzqB,EAAAuqB,WAAA,SAAAH,EAAAva,GACA,GAAAua,EAAAM,eAAA,CAIA,GAAAC,GAAAP,EAAA5d,kBAEA3O,EAAA8sB,EAAAC,mBAAA/a,EAEAua,GAAAM,eAAA7sB,KAgBAmC,EAAA6qB,qBAAA,SAAAC,GACA,GAAAC,GAAA/qB,EAAA+qB,iBACAzmB,EAAAwmB,EAAAxmB,MACA6O,EAAA2X,EAAA5iB,MAAAiL,SAQA,OANAb,GAAA,EAAAhO,EAAAyO,MAAAT,EAAA,EAAAhO,EAAA2O,MACA3O,EAAAyO,GAAAzO,EAAA2O,GAAA8X,EAAAzmB,EAAAyO,GAAAI,GAAA,IAEAb,EAAA,EAAAhO,EAAA0O,MAAAV,EAAA,EAAAhO,EAAA4O,MACA5O,EAAA0O,GAAA1O,EAAA4O,GAAA6X,EAAAzmB,EAAA0O,GAAAG,GAAA,IAEA2X,GAgBA9qB,EAAAgrB,qBAAA,SAAAF,GACA,GAAAC,GAAA/qB,EAAA+qB,iBACAzmB,EAAAwmB,EAAAxmB,MACA6O,EAAA2X,EAAA5iB,MAAAiL,UACA8X,EAAA3mB,EAAAwK,EACAoc,EAAA5mB,EAAA0K,EACAmc,EAAA7mB,EAAAgI,MACA8e,EAAA9mB,EAAAiI,MAWA,OAVAjI,GAAAwK,EAAAic,EAAAzmB,EAAAwK,EAAAqE,GAAA,GACA7O,EAAA0K,EAAA+b,EAAAzmB,EAAA0K,EAAAmE,GAAA,GACA7O,EAAAgI,MAAAoE,KAAA6Q,IACAwJ,EAAAE,EAAAE,EAAAhY,GAAA,GAAA7O,EAAAwK,EACA,IAAAqc,EAAA,EAAA,GAEA7mB,EAAAiI,OAAAmE,KAAA6Q,IACAwJ,EAAAG,EAAAE,EAAAjY,GAAA,GAAA7O,EAAA0K,EACA,IAAAoc,EAAA,EAAA,GAEAN,GAWA9qB,EAAA+qB,iBAAA,SAAAziB,EAAA6K,EAAAkY,GAGA,GAAAC,GAAAhZ,EAAA,EAAAhK,EACA,QAAAgjB,EAAAhZ,EAAAa,IAAA,IAAA,EACAmY,EAAA,GACAA,GAAAD,EAAA,OAAA,GAkEArrB,EAAA4nB,aAAAA,EAUA5nB,EAAA8nB,aAAAA,EAUA9nB,EAAA+nB,mBAAAA,EAsCA/nB,EAAAgJ,cAAA,SAAA+d,EAAAhe,GACA,UAAAge,EAAA5jB,KACA4jB,EAAAc,SAAA,SAAAjf,GACA,UAAAA,EAAAzF,MACA4kB,EAAAnf,EAAAG,KAGAgf,EAAAhB,EAAAhe,GAEAge,EAAA3iB,GAAA,YAAA6jB,GACA7jB,GAAA,WAAA+jB,GAGApB,EAAA3iB,GAAA,WAAAgkB,GACAhkB,GAAA,SAAAikB,IAGAroB,EAAAurB,eAAA,SAAAxE,EAAAtmB,GACA,GAAAsmB,EAAAS,YACA,IAAA,GAAA9hB,KAAAjF,GACAsmB,EAAAS,YAAAD,eAAA7hB,KACAqhB,EAAAS,YAAA9hB,GAAAjF,EAAAiF,KAYA1F,EAAAwrB,QAAA,SAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAAF,EAAA9C,WAAA,aAAA,SACAiD,EAAAD,EAAA1d,QAAA,WAAA,EAAA,QAAAyd,EACAG,EAAAJ,EAAAK,SAAA,YACAzqB,GAAA6gB,OAAAsJ,GACAO,aAAAN,EAAA9C,WAAA,aAAA,EACAxL,SAAA0O,EAAAG,UACA5jB,aAAAujB,EACA1L,SAAA4L,EAAAI,gBAAAL,KAsBA7rB,EAAAmsB,YAAA7qB,EAAA8qB,MAAA9D,GAAA,GASAtoB,EAAAqsB,UAAA/qB,EAAA8qB,MAAA9D,GAAA,GASAtoB,EAAAssB,aAAA,SAAA/nB,EAAAgoB,GAGA,IAFA,GAAAC,GAAAvD,EAAAwD,aAEAloB,GAAAA,IAAAgoB,GACAtD,EAAAyD,IAAAF,EAAAjoB,EAAAooB,oBAAAH,GACAjoB,EAAAA,EAAAiB,MAGA,OAAAgnB,IAUAxsB,EAAA0qB,eAAA,SAAAkC,EAAAC,EAAAC,GAIA,MAHAA,KACAD,EAAA5D,EAAA6D,UAAAD,IAEA3D,EAAAwB,kBAAAkC,EAAAC,IASA7sB,EAAA+sB,mBAAA,SAAAC,EAAAH,EAAAC,GAGA,GAAAG,GAAA,IAAAJ,EAAA,IAAA,IAAAA,EAAA,IAAA,IAAAA,EAAA,GACA,EAAAnc,KAAAC,IAAA,EAAAkc,EAAA,GAAAA,EAAA,IACAK,EAAA,IAAAL,EAAA,IAAA,IAAAA,EAAA,IAAA,IAAAA,EAAA,GACA,EAAAnc,KAAAC,IAAA,EAAAkc,EAAA,GAAAA,EAAA,IAEAD,GACA,SAAAI,GAAAC,EAAA,UAAAD,EAAAC,EAAA,EACA,QAAAD,GAAAE,EAAA,WAAAF,EAAAE,EAAA,EAKA,OAFAN,GAAA5sB,EAAA0qB,eAAAkC,EAAAC,EAAAC,GAEApc,KAAAC,IAAAic,EAAA,IAAAlc,KAAAC,IAAAic,EAAA,IACAA,EAAA,GAAA,EAAA,QAAA,OACAA,EAAA,GAAA,EAAA,SAAA,OAGA1vB,EAAAD,QAAA+C,GL4zGM,SAAU9C,EAAQD,GM7tHxB,QAAAkwB,GAAAznB,EAAA0nB,GACAC,EAAA3nB,GAAA0nB,EAoBA,QAAA3pB,GAAA6pB,GACA,GAAA,MAAAA,GAAA,gBAAAA,GACA,MAAAA,EAGA,IAAApO,GAAAoO,EACAC,EAAAC,EAAA5vB,KAAA0vB,EAEA,IAAA,mBAAAC,EAAA,CACArO,IAEA,KAAA,GAAAxU,GAAA,EAAA+iB,EAAAH,EAAA9pB,OAAwCkH,EAAA+iB,EAAS/iB,IACjDwU,EAAAxU,GAAAjH,EAAA6pB,EAAA5iB,QAEG,IAAAgjB,EAAAH,GAAA,CACH,GAAAI,GAAAL,EAAAM,WAEA,IAAAN,EAAAM,YAAAC,KACA3O,EAAAyO,EAAAE,KAAAP,OACK,CACLpO,EAAA,GAAAyO,GAAAL,EAAA9pB,OAEA,KAAA,GAAAkH,GAAA,EAAA+iB,EAAAH,EAAA9pB,OAA0CkH,EAAA+iB,EAAS/iB,IACnDwU,EAAAxU,GAAAjH,EAAA6pB,EAAA5iB,SAGG,KAAAojB,EAAAP,KAAAQ,EAAAT,KAAA9H,EAAA8H,GAAA,CACHpO,IAEA,KAAA,GAAA7b,KAAAiqB,GACAA,EAAA/F,eAAAlkB,KACA6b,EAAA7b,GAAAI,EAAA6pB,EAAAjqB,KAKA,MAAA6b,GAUA,QAAA9Q,GAAA7J,EAAA+oB,EAAAU,GAGA,IAAAC,EAAAX,KAAAW,EAAA1pB,GACA,MAAAypB,GAAAvqB,EAAA6pB,GAAA/oB,CAGA,KAAA,GAAAlB,KAAAiqB,GACA,GAAAA,EAAA/F,eAAAlkB,GAAA,CACA,GAAA6qB,GAAA3pB,EAAAlB,GACA8qB,EAAAb,EAAAjqB,IAEA4qB,EAAAE,KAAAF,EAAAC,IAAA3jB,EAAA4jB,IAAA5jB,EAAA2jB,IAAA1I,EAAA2I,IAAA3I,EAAA0I,IAAAE,EAAAD,IAAAC,EAAAF,IAAAH,EAAAI,IAAAJ,EAAAG,IAGOF,GAAA3qB,IAAAkB,KAGPA,EAAAlB,GAAAI,EAAA6pB,EAAAjqB,IAAA,IAJA+K,EAAA8f,EAAAC,EAAAH,GASA,MAAAzpB,GASA,QAAA8pB,GAAAC,EAAAN,GAGA,IAAA,GAFA9O,GAAAoP,EAAA,GAEA5jB,EAAA,EAAA+iB,EAAAa,EAAA9qB,OAAgDkH,EAAA+iB,EAAS/iB,IACzDwU,EAAA9Q,EAAA8Q,EAAAoP,EAAA5jB,GAAAsjB,EAGA,OAAA9O,GASA,QAAAiD,GAAA5d,EAAA+oB,GACA,IAAA,GAAAjqB,KAAAiqB,GACAA,EAAA/F,eAAAlkB,KACAkB,EAAAlB,GAAAiqB,EAAAjqB,GAIA,OAAAkB,GAUA,QAAAgX,GAAAhX,EAAA+oB,EAAAiB,GACA,IAAA,GAAAlrB,KAAAiqB,GACAA,EAAA/F,eAAAlkB,KAAAkrB,EAAA,MAAAjB,EAAAjqB,GAAA,MAAAkB,EAAAlB,MACAkB,EAAAlB,GAAAiqB,EAAAjqB,GAIA,OAAAkB,GAcA,QAAAsX,KAOA,MANA2S,KAGAA,EAAAC,IAAA5S,WAAA,OAGA2S,EAQA,QAAAtgB,GAAAwgB,EAAAprB,GACA,GAAAorB,EAAA,CACA,GAAAA,EAAAxgB,QACA,MAAAwgB,GAAAxgB,QAAA5K,EAGA,KAAA,GAAAoH,GAAA,EAAA+iB,EAAAiB,EAAAlrB,OAAuCkH,EAAA+iB,EAAS/iB,IAChD,GAAAgkB,EAAAhkB,KAAApH,EACA,MAAAoH,GAKA,SAWA,QAAA8f,GAAAmE,EAAAC,GAGA,QAAAC,MAFA,GAAAC,GAAAH,EAAApsB,SAIAssB,GAAAtsB,UAAAqsB,EAAArsB,UACAosB,EAAApsB,UAAA,GAAAssB,EAEA,KAAA,GAAAE,KAAAD,GACAH,EAAApsB,UAAAwsB,GAAAD,EAAAC,EAGAJ,GAAApsB,UAAAqrB,YAAAe,EACAA,EAAAK,WAAAJ,EAUA,QAAAnK,GAAAlgB,EAAA+oB,EAAAiB,GACAhqB,EAAA,aAAAA,GAAAA,EAAAhC,UAAAgC,EACA+oB,EAAA,aAAAA,GAAAA,EAAA/qB,UAAA+qB,EACA/R,EAAAhX,EAAA+oB,EAAAiB,GAQA,QAAAU,GAAApY,GACA,GAAAA,EAIA,MAAA,gBAAAA,IAIA,gBAAAA,GAAArT,OAWA,QAAA0C,GAAAgpB,EAAAhU,EAAAC,GACA,GAAA+T,GAAAhU,EAIA,GAAAgU,EAAA1kB,SAAA0kB,EAAA1kB,UAAA2kB,EACAD,EAAA1kB,QAAA0Q,EAAAC,OACG,IAAA+T,EAAA1rB,UAAA0rB,EAAA1rB,OACH,IAAA,GAAAkH,GAAA,EAAA+iB,EAAAyB,EAAA1rB,OAAqCkH,EAAA+iB,EAAS/iB,IAC9CwQ,EAAAtd,KAAAud,EAAA+T,EAAAxkB,GAAAA,EAAAwkB,OAGA,KAAA,GAAA7rB,KAAA6rB,GACAA,EAAA3H,eAAAlkB,IACA6X,EAAAtd,KAAAud,EAAA+T,EAAA7rB,GAAAA,EAAA6rB,GAeA,QAAArO,GAAAqO,EAAAhU,EAAAC,GACA,GAAA+T,GAAAhU,EAAA,CAIA,GAAAgU,EAAArO,KAAAqO,EAAArO,MAAAuO,EACA,MAAAF,GAAArO,IAAA3F,EAAAC,EAIA,KAAA,GAFA+D,MAEAxU,EAAA,EAAA+iB,EAAAyB,EAAA1rB,OAAqCkH,EAAA+iB,EAAS/iB,IAC9CwU,EAAArY,KAAAqU,EAAAtd,KAAAud,EAAA+T,EAAAxkB,GAAAA,EAAAwkB,GAGA,OAAAhQ,IAaA,QAAAmQ,GAAAH,EAAAhU,EAAAoU,EAAAnU,GACA,GAAA+T,GAAAhU,EAAA,CAIA,GAAAgU,EAAAG,QAAAH,EAAAG,SAAAE,EACA,MAAAL,GAAAG,OAAAnU,EAAAoU,EAAAnU,EAEA,KAAA,GAAAzQ,GAAA,EAAA+iB,EAAAyB,EAAA1rB,OAAqCkH,EAAA+iB,EAAS/iB,IAC9C4kB,EAAApU,EAAAtd,KAAAud,EAAAmU,EAAAJ,EAAAxkB,GAAAA,EAAAwkB,EAGA,OAAAI,IAaA,QAAA5Z,GAAAwZ,EAAAhU,EAAAC,GACA,GAAA+T,GAAAhU,EAAA,CAIA,GAAAgU,EAAAxZ,QAAAwZ,EAAAxZ,SAAA8Z,EACA,MAAAN,GAAAxZ,OAAAwF,EAAAC,EAIA,KAAA,GAFA+D,MAEAxU,EAAA,EAAA+iB,EAAAyB,EAAA1rB,OAAqCkH,EAAA+iB,EAAS/iB,IAC9CwQ,EAAAtd,KAAAud,EAAA+T,EAAAxkB,GAAAA,EAAAwkB,IACAhQ,EAAArY,KAAAqoB,EAAAxkB,GAIA,OAAAwU,IAaA,QAAAnL,GAAAmb,EAAAhU,EAAAC,GACA,GAAA+T,GAAAhU,EAIA,IAAA,GAAAxQ,GAAA,EAAA+iB,EAAAyB,EAAA1rB,OAAmCkH,EAAA+iB,EAAS/iB,IAC5C,GAAAwQ,EAAAtd,KAAAud,EAAA+T,EAAAxkB,GAAAA,EAAAwkB,GACA,MAAAA,GAAAxkB,GAYA,QAAA7F,GAAA4qB,EAAAtU,GACA,GAAAuU,GAAAC,EAAA/xB,KAAA2F,UAAA,EACA,OAAA,YACA,MAAAksB,GAAAxX,MAAAkD,EAAAuU,EAAAnkB,OAAAokB,EAAA/xB,KAAA2F,cAUA,QAAA6oB,GAAAqD,GACA,GAAAC,GAAAC,EAAA/xB,KAAA2F,UAAA,EACA,OAAA,YACA,MAAAksB,GAAAxX,MAAA5a,KAAAqyB,EAAAnkB,OAAAokB,EAAA/xB,KAAA2F,cAUA,QAAAgH,GAAAjH,GACA,MAAA,mBAAAkqB,EAAA5vB,KAAA0F,GASA,QAAA0U,GAAA1U,GACA,MAAA,kBAAAA,GASA,QAAAssB,GAAAtsB,GACA,MAAA,oBAAAkqB,EAAA5vB,KAAA0F,GASA,QAAA2qB,GAAA3qB,GAGA,GAAAH,SAAAG,EACA,OAAA,aAAAH,KAAAG,GAAA,UAAAH,EASA,QAAAirB,GAAA9qB,GACA,QAAAwqB,EAAAN,EAAA5vB,KAAA0F,IASA,QAAAkiB,GAAAliB,GACA,MAAA,gBAAAA,IAAA,gBAAAA,GAAAusB,UAAA,gBAAAvsB,GAAAwsB,cASA,QAAAC,GAAAzsB,GACA,MAAAA,KAAAA,EAUA,QAAA0sB,GAAAC,GACA,IAAA,GAAAvlB,GAAA,EAAA+iB,EAAAlqB,UAAAC,OAAyCkH,EAAA+iB,EAAS/iB,IAClD,GAAA,MAAAnH,UAAAmH,GACA,MAAAnH,WAAAmH,GAKA,QAAAwlB,GAAAC,EAAAC,GACA,MAAA,OAAAD,EAAAA,EAAAC,EAGA,QAAAC,GAAAF,EAAAC,EAAAE,GACA,MAAA,OAAAH,EAAAA,EAAA,MAAAC,EAAAA,EAAAE,EAWA,QAAArK,KACA,MAAAJ,UAAAjoB,KAAAqa,MAAA0X,EAAApsB,WAaA,QAAAgtB,GAAApR,GACA,GAAA,gBAAAA,GACA,OAAAA,EAAAA,EAAAA,EAAAA,EAGA,IAAAsO,GAAAtO,EAAA3b,MAEA,OAAA,KAAAiqB,GAEAtO,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACG,IAAAsO,GAEHtO,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAGAA,EASA,QAAAqR,GAAAC,EAAAC,GACA,IAAAD,EACA,KAAA,IAAAzL,OAAA0L,GASA,QAAAC,GAAAzB,GACAA,EAAA0B,IAAA,EAGA,QAAA7C,GAAAmB,GACA,MAAAA,GAAA0B,GAQA,QAAAC,GAAA3B,GACAA,GAAAhpB,EAAAgpB,EAAA,SAAA5rB,EAAAD,GACAhG,KAAAgD,IAAAgD,EAAAC,IACGjG,MAmCH,QAAAyzB,GAAA5B,GACA,MAAA,IAAA2B,GAAA3B,GAGA,QAAA6B,MA3nBA,GAAAjD,IACAkD,oBAAA,EACAC,kBAAA,EACAC,gBAAA,EACAC,iBAAA,EACAC,0BAAA,EACAC,yBAAA,EAEAC,iBAAA,EACAC,kBAAA,GAEA7D,GACA8D,qBAAA,EACAC,sBAAA,EACAC,6BAAA,EACAC,sBAAA,EACAC,uBAAA,EACAC,sBAAA,EACAC,uBAAA,EACAC,wBAAA,EACAC,wBAAA,GAEAxE,EAAAyE,OAAA1vB,UAAAmkB,SACAwL,EAAAzb,MAAAlU,UACA4sB,EAAA+C,EAAA1nB,QACAglB,EAAA0C,EAAAxc,OACAia,EAAAuC,EAAAjM,MACAmJ,EAAA8C,EAAArR,IACA0O,EAAA2C,EAAA7C,OAEAhC,KAgJAoB,EAAA,WACA,MAAApB,GAAAoB,eAGApB,GAAAoB,aAAA,WACA,MAAA9S,UAAAC,cAAA,UAIA,IAAA4S,GAwYAoC,EAAA,mBAyBAuB,EAAA,OACAC,EAAA,CACAvB,GAAAtuB,WACAqrB,YAAAiD,EAIAntB,IAAA,SAAAL,GACA,MAAAhG,MAAA80B,EAAA9uB,IAEAhD,IAAA,SAAAgD,EAAAC,GAIA,MAHAjG,MAAA80B,EAAA9uB,GAAAC,EAGAA,GAIA4C,KAAA,SAAAgV,EAAAC,GACA,SAAAA,IAAAD,EAAArW,EAAAqW,EAAAC,GAEA,KAAA,GAAAkX,KAAAh1B,MACAA,KAAAkqB,eAAA8K,IAAAnX,EAAA7d,KAAAg1B,GAAAA,EAAApM,MAAAmM,KAIAE,UAAA,SAAAjvB,SACAhG,MAAA80B,EAAA9uB,KAUApG,EAAAkwB,UAAAA,EACAlwB,EAAAwG,MAAAA,EACAxG,EAAAmR,MAAAA,EACAnR,EAAAoxB,SAAAA,EACApxB,EAAAklB,OAAAA,EACAllB,EAAAse,SAAAA,EACAte,EAAAwxB,aAAAA,EACAxxB,EAAA4e,WAAAA,EACA5e,EAAAiR,QAAAA,EACAjR,EAAAutB,SAAAA,EACAvtB,EAAAwnB,MAAAA,EACAxnB,EAAAgyB,YAAAA,EACAhyB,EAAAiJ,KAAAA,EACAjJ,EAAA4jB,IAAAA,EACA5jB,EAAAoyB,OAAAA,EACApyB,EAAAyY,OAAAA,EACAzY,EAAA8W,KAAAA,EACA9W,EAAA4H,KAAAA,EACA5H,EAAAmvB,MAAAA,EACAnvB,EAAAsN,QAAAA,EACAtN,EAAA+a,WAAAA,EACA/a,EAAA2yB,SAAAA,EACA3yB,EAAAgxB,SAAAA,EACAhxB,EAAAmxB,gBAAAA,EACAnxB,EAAAuoB,MAAAA,EACAvoB,EAAA8yB,MAAAA,EACA9yB,EAAA+yB,SAAAA,EACA/yB,EAAAizB,UAAAA,EACAjzB,EAAAozB,UAAAA,EACApzB,EAAAgpB,MAAAA,EACAhpB,EAAAszB,kBAAAA,EACAtzB,EAAAuzB,OAAAA,EACAvzB,EAAA0zB,eAAAA,EACA1zB,EAAA8wB,YAAAA,EACA9wB,EAAA6zB,cAAAA,EACA7zB,EAAA8zB,KAAAA,GNuwHM,SAAU7zB,EAAQD,EAASM,GOl5IjC,QAAAg1B,GAAAxf,EAAAC,EAAAC,EAAAC,EAAAsf,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAzI,GACA,GAAA0I,GAAAF,GAAAxgB,EAAA,KACA2gB,EAAAC,EAAAF,IAAA/f,EAAAE,GAAA,EAAAggB,EAAAH,IAAA9f,EAAAE,GAAA,EACAggB,KAAAD,EAAAH,IAAA/f,EAAAE,GAAA,EAAA+f,EAAAF,IAAA9f,EAAAE,GAAA,EACAigB,EAAAJ,EAAAA,GAAAL,EAAAA,GAAAQ,EAAAA,GAAAP,EAAAA,EAEAQ,GAAA,IACAT,GAAAU,EAAAD,GACAR,GAAAS,EAAAD,GAGA,IAAAE,IAAAb,IAAAC,KAAA,GAAAW,GAAAV,EAAAA,GAAAC,EAAAA,GAAAD,EAAAA,GAAAQ,EAAAA,GAAAP,EAAAA,GAAAI,EAAAA,KAAAL,EAAAA,GAAAQ,EAAAA,GAAAP,EAAAA,GAAAI,EAAAA,MAAA,EACAO,EAAAD,EAAAX,EAAAQ,EAAAP,EACAY,EAAAF,GAAAV,EAAAI,EAAAL,EACA7jB,GAAAkE,EAAAE,GAAA,EAAA+f,EAAAF,GAAAQ,EAAAL,EAAAH,GAAAS,EACAxkB,GAAAiE,EAAAE,GAAA,EAAA+f,EAAAH,GAAAQ,EAAAN,EAAAF,GAAAS,EACAC,EAAAC,GAAA,EAAA,KAAAV,EAAAO,GAAAZ,GAAAQ,EAAAK,GAAAZ,IACAe,IAAAX,EAAAO,GAAAZ,GAAAQ,EAAAK,GAAAZ,GACAloB,OAAAsoB,EAAAO,GAAAZ,MAAAQ,EAAAK,GAAAZ,GACAgB,EAAAF,EAAAC,EAAAjpB,EAEAmpB,GAAAF,EAAAjpB,SACAkpB,EAAAvhB,GAGAwhB,EAAAF,EAAAjpB,IAAA,IACAkpB,EAAA,GAGA,IAAAlB,GAAAkB,EAAA,IACAA,GAAA,EAAAvhB,GAGA,IAAAqgB,GAAAkB,EAAA,IACAA,GAAA,EAAAvhB,GAGAgY,EAAAyJ,QAAAhB,EAAAhkB,EAAAE,EAAA2jB,EAAAC,EAAAa,EAAAG,EAAAb,EAAAL,GAGA,QAAAqB,GAAAjd,GACA,IAAAA,EACA,QAIA,IACAxE,GADA0hB,EAAAld,EAAAmd,QAAA,KAAA,MAAAA,QAAA,MAAA,KAAAA,QAAA,KAAA,KAAAA,QAAA,MAAA,IAGA,KAAA3hB,EAAA,EAAaA,EAAA4hB,EAAAzwB,OAAe6O,IAC5B0hB,EAAAA,EAAAC,QAAA,GAAAE,QAAAD,EAAA5hB,GAAA,KAAA,IAAA4hB,EAAA5hB,GAIA,IAMA8hB,GANA/Y,EAAA2Y,EAAAthB,MAAA,KAEA2hB,EAAA,EACAC,EAAA,EACAjK,EAAA,GAAAkK,GACAC,EAAAD,EAAAC,GAGA,KAAAliB,EAAA,EAAaA,EAAA+I,EAAA5X,OAAgB6O,IAAA,CAC7B,GAIAwgB,GAJA2B,EAAApZ,EAAA/I,GACAvU,EAAA02B,EAAA9U,OAAA,GACAtZ,EAAA,EACArI,EAAAy2B,EAAAvO,MAAA,GAAA+N,QAAA,OAAA,MAAAvhB,MAAA,IAGA1U,GAAAyF,OAAA,GAAA,KAAAzF,EAAA,IACAA,EAAA02B,OAGA,KAAA,GAAA/pB,GAAA,EAAmBA,EAAA3M,EAAAyF,OAAckH,IACjC3M,EAAA2M,GAAAgqB,WAAA32B,EAAA2M,GAGA,MAAAtE,EAAArI,EAAAyF,SAAAsf,MAAA/kB,EAAAqI,MACA0c,MAAA/kB,EAAA,KADA,CAKA,GAAA42B,GACAC,EACAlC,EACAC,EACAG,EACAN,EACAC,EACA1f,EAAAqhB,EACAphB,EAAAqhB,CAEA,QAAAv2B,GACA,IAAA,IACAs2B,GAAAr2B,EAAAqI,KACAiuB,GAAAt2B,EAAAqI,KACAysB,EAAA0B,EAAAM,EACAzK,EAAAyJ,QAAAhB,EAAAuB,EAAAC,EACA,MAEA,KAAA,IACAD,EAAAr2B,EAAAqI,KACAiuB,EAAAt2B,EAAAqI,KACAysB,EAAA0B,EAAAM,EACAzK,EAAAyJ,QAAAhB,EAAAuB,EAAAC,EACA,MAEA,KAAA,IACAD,GAAAr2B,EAAAqI,KACAiuB,GAAAt2B,EAAAqI,KACAysB,EAAA0B,EAAAO,EACA1K,EAAAyJ,QAAAhB,EAAAuB,EAAAC,GACAv2B,EAAA,GACA,MAEA,KAAA,IACAs2B,EAAAr2B,EAAAqI,KACAiuB,EAAAt2B,EAAAqI,KACAysB,EAAA0B,EAAAO,EACA1K,EAAAyJ,QAAAhB,EAAAuB,EAAAC,GACAv2B,EAAA,GACA,MAEA,KAAA,IACAs2B,GAAAr2B,EAAAqI,KACAysB,EAAA0B,EAAAM,EACAzK,EAAAyJ,QAAAhB,EAAAuB,EAAAC,EACA,MAEA,KAAA,IACAD,EAAAr2B,EAAAqI,KACAysB,EAAA0B,EAAAM,EACAzK,EAAAyJ,QAAAhB,EAAAuB,EAAAC,EACA,MAEA,KAAA,IACAA,GAAAt2B,EAAAqI,KACAysB,EAAA0B,EAAAM,EACAzK,EAAAyJ,QAAAhB,EAAAuB,EAAAC,EACA,MAEA,KAAA,IACAA,EAAAt2B,EAAAqI,KACAysB,EAAA0B,EAAAM,EACAzK,EAAAyJ,QAAAhB,EAAAuB,EAAAC,EACA,MAEA,KAAA,IACAxB,EAAA0B,EAAAQ,EACA3K,EAAAyJ,QAAAhB,EAAA90B,EAAAqI,KAAArI,EAAAqI,KAAArI,EAAAqI,KAAArI,EAAAqI,KAAArI,EAAAqI,KAAArI,EAAAqI,MACAguB,EAAAr2B,EAAAqI,EAAA,GACAiuB,EAAAt2B,EAAAqI,EAAA,EACA,MAEA,KAAA,IACAysB,EAAA0B,EAAAQ,EACA3K,EAAAyJ,QAAAhB,EAAA90B,EAAAqI,KAAAguB,EAAAr2B,EAAAqI,KAAAiuB,EAAAt2B,EAAAqI,KAAAguB,EAAAr2B,EAAAqI,KAAAiuB,EAAAt2B,EAAAqI,KAAAguB,EAAAr2B,EAAAqI,KAAAiuB,GACAD,GAAAr2B,EAAAqI,EAAA,GACAiuB,GAAAt2B,EAAAqI,EAAA,EACA,MAEA,KAAA,IACAuuB,EAAAP,EACAQ,EAAAP,CACA,IAAA5G,GAAArD,EAAAqD,MACAxD,EAAAG,EAAAvT,IAEAsd,KAAAI,EAAAQ,IACAJ,GAAAP,EAAAnK,EAAAwD,EAAA,GACAmH,GAAAP,EAAApK,EAAAwD,EAAA,IAGAoF,EAAA0B,EAAAQ,EACAhiB,EAAAhV,EAAAqI,KACA4M,EAAAjV,EAAAqI,KACAguB,EAAAr2B,EAAAqI,KACAiuB,EAAAt2B,EAAAqI,KACAgkB,EAAAyJ,QAAAhB,EAAA8B,EAAAC,EAAA7hB,EAAAC,EAAAohB,EAAAC,EACA,MAEA,KAAA,IACAM,EAAAP,EACAQ,EAAAP,CACA,IAAA5G,GAAArD,EAAAqD,MACAxD,EAAAG,EAAAvT,IAEAsd,KAAAI,EAAAQ,IACAJ,GAAAP,EAAAnK,EAAAwD,EAAA,GACAmH,GAAAP,EAAApK,EAAAwD,EAAA,IAGAoF,EAAA0B,EAAAQ,EACAhiB,EAAAqhB,EAAAr2B,EAAAqI,KACA4M,EAAAqhB,EAAAt2B,EAAAqI,KACAguB,GAAAr2B,EAAAqI,KACAiuB,GAAAt2B,EAAAqI,KACAgkB,EAAAyJ,QAAAhB,EAAA8B,EAAAC,EAAA7hB,EAAAC,EAAAohB,EAAAC,EACA,MAEA,KAAA,IACAthB,EAAAhV,EAAAqI,KACA4M,EAAAjV,EAAAqI,KACAguB,EAAAr2B,EAAAqI,KACAiuB,EAAAt2B,EAAAqI,KACAysB,EAAA0B,EAAAS,EACA5K,EAAAyJ,QAAAhB,EAAA9f,EAAAC,EAAAohB,EAAAC,EACA,MAEA,KAAA,IACAthB,EAAAhV,EAAAqI,KAAAguB,EACAphB,EAAAjV,EAAAqI,KAAAiuB,EACAD,GAAAr2B,EAAAqI,KACAiuB,GAAAt2B,EAAAqI,KACAysB,EAAA0B,EAAAS,EACA5K,EAAAyJ,QAAAhB,EAAA9f,EAAAC,EAAAohB,EAAAC,EACA,MAEA,KAAA,IACAM,EAAAP,EACAQ,EAAAP,CACA,IAAA5G,GAAArD,EAAAqD,MACAxD,EAAAG,EAAAvT,IAEAsd,KAAAI,EAAAS,IACAL,GAAAP,EAAAnK,EAAAwD,EAAA,GACAmH,GAAAP,EAAApK,EAAAwD,EAAA,IAGA2G,EAAAr2B,EAAAqI,KACAiuB,EAAAt2B,EAAAqI,KACAysB,EAAA0B,EAAAS,EACA5K,EAAAyJ,QAAAhB,EAAA8B,EAAAC,EAAAR,EAAAC,EACA,MAEA,KAAA,IACAM,EAAAP,EACAQ,EAAAP,CACA,IAAA5G,GAAArD,EAAAqD,MACAxD,EAAAG,EAAAvT,IAEAsd,KAAAI,EAAAS,IACAL,GAAAP,EAAAnK,EAAAwD,EAAA,GACAmH,GAAAP,EAAApK,EAAAwD,EAAA,IAGA2G,GAAAr2B,EAAAqI,KACAiuB,GAAAt2B,EAAAqI,KACAysB,EAAA0B,EAAAS,EACA5K,EAAAyJ,QAAAhB,EAAA8B,EAAAC,EAAAR,EAAAC,EACA,MAEA,KAAA,IACA3B,EAAA30B,EAAAqI,KACAusB,EAAA50B,EAAAqI,KACA0sB,EAAA/0B,EAAAqI,KACAosB,EAAAz0B,EAAAqI,KACAqsB,EAAA10B,EAAAqI,KACA2M,EAAAqhB,EAAAphB,EAAAqhB,EACAD,EAAAr2B,EAAAqI,KACAiuB,EAAAt2B,EAAAqI,KACAysB,EAAA0B,EAAAU,EACA1C,EAAAxf,EAAAC,EAAAohB,EAAAC,EAAA7B,EAAAC,EAAAC,EAAAC,EAAAG,EAAAD,EAAAzI,EACA,MAEA,KAAA,IACAsI,EAAA30B,EAAAqI,KACAusB,EAAA50B,EAAAqI,KACA0sB,EAAA/0B,EAAAqI,KACAosB,EAAAz0B,EAAAqI,KACAqsB,EAAA10B,EAAAqI,KACA2M,EAAAqhB,EAAAphB,EAAAqhB,EACAD,GAAAr2B,EAAAqI,KACAiuB,GAAAt2B,EAAAqI,KACAysB,EAAA0B,EAAAU,EACA1C,EAAAxf,EAAAC,EAAAohB,EAAAC,EAAA7B,EAAAC,EAAAC,EAAAC,EAAAG,EAAAD,EAAAzI,IAKA,MAAAtsB,GAAA,MAAAA,IACA+0B,EAAA0B,EAAAW,EACA9K,EAAAyJ,QAAAhB,IAGAsB,EAAAtB,EAIA,MADAzI,GAAA+K,WACA/K,EAIA,QAAAgL,GAAAZ,EAAAt2B,GACA,GAAAm3B,GAAAvB,EAAAU,EAuBA,OAtBAt2B,GAAAA,MAEAA,EAAAo3B,UAAA,SAAAlL,GACA,GAAAA,EAAAmL,QAAA,CACAnL,EAAAmL,QAAAF,EAAAxe,KAEA,IAAA2e,GAAApL,EAAAvO,YAEA2Z,IACApL,EAAAqL,YAAAD,OAEK,CACL,GAAAA,GAAApL,CACAiL,GAAAI,YAAAD,KAIAt3B,EAAAwsB,eAAA,SAAA7sB,GACA63B,EAAAL,EAAAx3B,GACAR,KAAAs4B,OAAA,IAGAz3B,EASA,QAAAmsB,GAAAmK,EAAAt2B,GACA,MAAA,IAAA8qB,GAAAoM,EAAAZ,EAAAt2B,IASA,QAAAgsB,GAAAsK,EAAAt2B,GACA,MAAA8qB,GAAA7G,OAAAiT,EAAAZ,EAAAt2B,IAUA,QAAAusB,GAAAmL,EAAA13B,GAIA,IAAA,GAHA23B,MACApI,EAAAmI,EAAApyB,OAEAkH,EAAA,EAAiBA,EAAA+iB,EAAS/iB,IAAA,CAC1B,GAAAorB,GAAAF,EAAAlrB,EAEAorB,GAAA1L,MACA0L,EAAAC,kBAGAD,EAAAE,aACAF,EAAAR,UAAAQ,EAAA1L,KAAA0L,EAAAxxB,OAAA,GAGAuxB,EAAAhvB,KAAAivB,EAAA1L,MAGA,GAAA6L,GAAA,GAAAjN,GAAA9qB,EAcA,OAZA+3B,GAAAF,kBAEAE,EAAAX,UAAA,SAAAlL,GACAA,EAAA8L,WAAAL,EAEA,IAAAL,GAAApL,EAAAvO,YAEA2Z,IACApL,EAAAqL,YAAAD,IAIAS,EAnZA,GAAAjN,GAAAzrB,EAAA,GAEA+2B,EAAA/2B,EAAA,IAEAm4B,EAAAn4B,EAAA,IAGA02B,GAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,KACAb,EAAA1iB,KAAA2D,KACA4e,EAAAviB,KAAAylB,IACAnD,EAAAtiB,KAAA0lB,IACAhkB,EAAA1B,KAAA0B,GAEAikB,EAAA,SAAA5rB,GACA,MAAAiG,MAAA2D,KAAA5J,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,KAGAmpB,EAAA,SAAAF,EAAAjpB,GACA,OAAAipB,EAAA,GAAAjpB,EAAA,GAAAipB,EAAA,GAAAjpB,EAAA,KAAA4rB,EAAA3C,GAAA2C,EAAA5rB,KAGAgpB,EAAA,SAAAC,EAAAjpB,GACA,OAAAipB,EAAA,GAAAjpB,EAAA,GAAAipB,EAAA,GAAAjpB,EAAA,MAAA,GAAAiG,KAAA4lB,KAAA1C,EAAAF,EAAAjpB,IAgYAxN,GAAAotB,iBAAAA,EACAptB,EAAAitB,iBAAAA,EACAjtB,EAAAwtB,UAAAA,GPi7IM,SAAUvtB,EAAQD,EAASM,GQrzJjC,QAAAyrB,GAAA9qB,GACAq4B,EAAA34B,KAAAP,KAAAa,GAMAb,KAAA+sB,KAAA,KA3BA,GAAAmM,GAAAh5B,EAAA,GAEA+D,EAAA/D,EAAA,GAEA+2B,EAAA/2B,EAAA,IAEAi5B,EAAAj5B,EAAA,IAEAk5B,EAAAl5B,EAAA,IAEAm5B,EAAAD,EAAAl0B,UAAAm0B,iBACA/lB,EAAAD,KAAAC,IACAgmB,EAAA,GAAArC,KAAA,GAkBAtL,GAAAzmB,WACAqrB,YAAA5E,EACA7lB,KAAA,OACA6yB,aAAA,EACAY,uBAAA,EACAC,MAAA,SAAArB,EAAAsB,GACA,GAAA5uB,GAAA7K,KAAA6K,MACAkiB,EAAA/sB,KAAA+sB,MAAAuM,EACAI,EAAA7uB,EAAA6uB,YACAC,EAAA9uB,EAAA8uB,UACA9nB,EAAAhH,EAAAgH,KACAC,EAAAjH,EAAAiH,OACA8nB,EAAAD,KAAA9nB,EAAAgoB,WACAC,EAAAJ,KAAA5nB,EAAA+nB,WACAE,EAAAJ,KAAA9nB,EAAA/G,MACAkvB,EAAAN,KAAA5nB,EAAAhH,KAIA,IAHAD,EAAArD,KAAA2wB,EAAAn4B,KAAAy5B,GACAz5B,KAAAi6B,aAAA9B,GAEAn4B,KAAAk6B,QAAA,CACA,GAAA1nB,EAEAonB,KACApnB,EAAAA,GAAAxS,KAAAmP,kBACAnP,KAAAm6B,cAAAtvB,EAAAuvB,YAAAjC,EAAAtmB,EAAAW,IAGAsnB,IACAtnB,EAAAA,GAAAxS,KAAAmP,kBACAnP,KAAAq6B,gBAAAxvB,EAAAuvB,YAAAjC,EAAArmB,EAAAU,IAKAonB,EAEAzB,EAAAmC,UAAAt6B,KAAAm6B,cACKJ,IACL5B,EAAAmC,UAAAjB,EAAA94B,KAAAsR,EAAAsmB,IAGA2B,EACA3B,EAAAoC,YAAAv6B,KAAAq6B,gBACKL,IACL7B,EAAAoC,YAAAlB,EAAA94B,KAAAuR,EAAAqmB,GAGA,IAAA/Y,GAAAvU,EAAAuU,SACAob,EAAA3vB,EAAA2vB,eACAC,IAAAtC,EAAAuC,YAEAzmB,EAAAjU,KAAA26B,gBACA5N,GAAAnH,SAAA3R,EAAA,GAAAA,EAAA,IAMAjU,KAAA24B,aAAAvZ,IAAAqb,GAAAf,GACA3M,EAAA6N,UAAAzC,GAEA/Y,IAAAqb,IACA1N,EAAA2N,YAAAtb,GACA2N,EAAA8N,kBAAAL,IAGAx6B,KAAAi4B,UAAAlL,EAAA/sB,KAAAiH,OAAA,GAEAjH,KAAA+sB,OACA/sB,KAAA24B,aAAA,KAIAR,EAAAyC,YACA56B,KAAA+sB,KAAAqL,YAAAD,IAGAwB,GAAA5M,EAAAlb,KAAAsmB,GAEA/Y,GAAAqb,IACAtC,EAAAuC,YAAAtb,GACA+Y,EAAAqC,eAAAA,GAGAd,GAAA3M,EAAAjb,OAAAqmB,GAEA/Y,GAAAqb,GAGAtC,EAAAuC,gBAGA16B,KAAA86B,iBAAA3C,GAEA,MAAAttB,EAAAE,MACA/K,KAAA+6B,aAAA5C,EAAAn4B,KAAAmP,oBAKA8oB,UAAA,SAAAE,EAAA6C,EAAAC,KACAvC,gBAAA,WACA14B,KAAA+sB,KAAA,GAAAkK,IAEA9nB,gBAAA,WACA,GAAAqD,GAAAxS,KAAAk7B,MACArwB,EAAA7K,KAAA6K,MACAswB,GAAA3oB,CAEA,IAAA2oB,EAAA,CACA,GAAApO,GAAA/sB,KAAA+sB,IAEAA,KAEAA,EAAA/sB,KAAA+sB,KAAA,GAAAkK,IAGAj3B,KAAA24B,cACA5L,EAAA6N,YACA56B,KAAAi4B,UAAAlL,EAAA/sB,KAAAiH,OAAA,IAGAuL,EAAAua,EAAA5d,kBAKA,GAFAnP,KAAAk7B,MAAA1oB,EAEA3H,EAAA6uB,YAAA,CAIA,GAAA0B,GAAAp7B,KAAAq7B,kBAAAr7B,KAAAq7B,gBAAA7oB,EAAApM,QAEA,IAAApG,KAAAk6B,SAAAiB,EAAA,CACAC,EAAAE,KAAA9oB,EAEA,IAAA+oB,GAAA1wB,EAAAiL,UAEA0lB,EAAA3wB,EAAA4wB,cAAAz7B,KAAA07B,eAAA,CAEA7wB,GAAA8uB,YACA4B,EAAAloB,KAAA6Q,IAAAqX,EAAAv7B,KAAAu5B,wBAAA,IAKAiC,EAAA,QACAJ,EAAAnsB,OAAAssB,EAAAC,EACAJ,EAAAlsB,QAAAqsB,EAAAC,EACAJ,EAAA3pB,GAAA8pB,EAAAC,EAAA,EACAJ,EAAAzpB,GAAA4pB,EAAAC,EAAA,GAKA,MAAAJ,GAGA,MAAA5oB,IAEAmpB,QAAA,SAAAlqB,EAAAE,GACA,GAAAiqB,GAAA57B,KAAA67B,sBAAApqB,EAAAE,GACAa,EAAAxS,KAAAmP,kBACAtE,EAAA7K,KAAA6K,KAIA,IAHA4G,EAAAmqB,EAAA,GACAjqB,EAAAiqB,EAAA,GAEAppB,EAAAmpB,QAAAlqB,EAAAE,GAAA,CACA,GAAAib,GAAA5sB,KAAA+sB,KAAAvT,IAEA,IAAA3O,EAAA6uB,YAAA,CACA,GAAA5jB,GAAAjL,EAAAiL,UACA0lB,EAAA3wB,EAAA4wB,cAAAz7B,KAAA07B,eAAA,CAEA,IAAAF,EAAA,QAEA3wB,EAAA8uB,YACA7jB,EAAAzC,KAAA6Q,IAAApO,EAAA9V,KAAAu5B,yBAGAJ,EAAA2C,cAAAlP,EAAA9W,EAAA0lB,EAAA/pB,EAAAE,IACA,OAAA,EAKA,GAAA9G,EAAA8uB,UACA,MAAAR,GAAAwC,QAAA/O,EAAAnb,EAAAE,GAIA,OAAA,GAMA2mB,MAAA,SAAAyD,GACA,MAAAA,IACAA,GAAA,GAIAA,IACA/7B,KAAA24B,YAAAoD,EACA/7B,KAAAk7B,MAAA,MAGAl7B,KAAAk6B,SAAA,EACAl6B,KAAAg8B,MAAAh8B,KAAAg8B,KAAAC,UAEAj8B,KAAAk8B,cACAl8B,KAAAk8B,aAAA5D,SAQA6D,aAAA,SAAAC,GACA,MAAAp8B,MAAAq8B,QAAA,QAAAD,IAGAE,OAAA,SAAAt2B,EAAAC,GAEA,UAAAD,GACAhG,KAAA4X,SAAA3R,GACAjG,KAAA24B,aAAA,EACA34B,KAAAk7B,MAAA,MAEAhC,EAAAh0B,UAAAo3B,OAAA/7B,KAAAP,KAAAgG,EAAAC,IAQA2R,SAAA,SAAA5R,EAAAC,GACA,GAAAgB,GAAAjH,KAAAiH,KAEA,IAAAA,EAAA,CACA,GAAAhD,EAAA2sB,SAAA5qB,GACA,IAAA,GAAAqC,KAAArC,GACAA,EAAAkkB,eAAA7hB,KACApB,EAAAoB,GAAArC,EAAAqC,QAIApB,GAAAjB,GAAAC,CAGAjG,MAAAs4B,OAAA,GAGA,MAAAt4B,OAEA07B,aAAA,WACA,GAAAl7B,GAAAR,KAAAwvB,SAKA,OAAAhvB,IAAA8S,EAAA9S,EAAA,GAAA,GAAA,OAAA8S,EAAA9S,EAAA,GAAA,GAAA,MAAA6S,KAAA2D,KAAA1D,EAAA9S,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,KAAA,IAcAmrB,EAAA7G,OAAA,SAAA5G,GACA,GAAAqe,GAAA,SAAA17B,GACA8qB,EAAAprB,KAAAP,KAAAa,GAEAqd,EAAArT,OAEA7K,KAAA6K,MAAA2xB,WAAAte,EAAArT,OAAA,EAIA,IAAA4xB,GAAAve,EAAAjX,KAEA,IAAAw1B,EAAA,CACAz8B,KAAAiH,MAAAjH,KAAAiH,SACA,IAAAy1B,GAAA18B,KAAAiH,KAEA,KAAA,GAAAoB,KAAAo0B,IACAC,EAAAxS,eAAA7hB,IAAAo0B,EAAAvS,eAAA7hB,KACAq0B,EAAAr0B,GAAAo0B,EAAAp0B,IAKA6V,EAAA/b,MAAA+b,EAAA/b,KAAA5B,KAAAP,KAAAa,GAGAoD,GAAAkpB,SAAAoP,EAAA5Q,EAEA,KAAA,GAAAtjB,KAAA6V,GAEA,UAAA7V,GAAA,UAAAA,IACAk0B,EAAAr3B,UAAAmD,GAAA6V,EAAA7V,GAIA,OAAAk0B,IAGAt4B,EAAAkpB,SAAAxB,EAAAuN,EACA,IAAAyD,GAAAhR,CACA9rB,GAAAD,QAAA+8B,GR+0JM,SAAU98B,EAAQD,EAASM,GSxpKjC,QAAAg5B,GAAAr4B,GACAA,EAAAA,MACAmoB,EAAAzoB,KAAAP,KAAAa,EAEA,KAAA,GAAAwH,KAAAxH,GACAA,EAAAqpB,eAAA7hB,IAAA,UAAAA,IACArI,KAAAqI,GAAAxH,EAAAwH,GAQArI,MAAA6K,MAAA,GAAA+xB,GAAA/7B,EAAAgK,MAAA7K,MACAA,KAAAk7B,MAAA,KAEAl7B,KAAA68B,eApCA,GAAA54B,GAAA/D,EAAA,GAEA08B,EAAA18B,EAAA,GAEA8oB,EAAA9oB,EAAA,IAEA48B,EAAA58B,EAAA,GAkCAg5B,GAAAh0B,WACAqrB,YAAA2I,EACApzB,KAAA,cAQAo0B,SAAA,EASA6C,WAAA,EAOAhrB,EAAA,EAOAqY,GAAA,EAQA4S,OAAA,EAQAhrB,WAAA,EAQAirB,UAAA,EAQAC,QAAA,EAOAC,SAAA,EAOA5nB,OAAA,UAOA6nB,WAAA,EAOAC,eACAC,YAAA,SAAAnF,KACAoF,WAAA,SAAApF,KAOAqB,MAAA,SAAArB,EAAAsB,KAOAtqB,gBAAA,aASAwsB,QAAA,SAAAlqB,EAAAE,GACA,MAAA3R,MAAAw9B,YAAA/rB,EAAAE,IAOA6Y,SAAA,SAAA3M,EAAAC,GACAD,EAAAtd,KAAAud,EAAA9d,OAUAw9B,YAAA,SAAA/rB,EAAAE,GACA,GAAA8rB,GAAAz9B,KAAA67B,sBAAApqB,EAAAE,GACAa,EAAAxS,KAAAmP,iBACA,OAAAqD,GAAAmpB,QAAA8B,EAAA,GAAAA,EAAA,KAOAnF,MAAA,WACAt4B,KAAAk6B,SAAA,EACAl6B,KAAAk7B,MAAA,KACAl7B,KAAAg8B,MAAAh8B,KAAAg8B,KAAAC;EAuBAyB,aAAA,SAAAtB,GACA,MAAAp8B,MAAAq8B,QAAA,QAAAD,IAEAE,OAAA,SAAAt2B,EAAAC,GACA,UAAAD,EACAgjB,EAAA9jB,UAAAo3B,OAAA/7B,KAAAP,KAAAgG,EAAAC,GAEAjG,KAAA6K,MAAA7H,IAAAiD,IAQAwH,SAAA,SAAAzH,EAAAC,GAGA,MAFAjG,MAAA6K,MAAA7H,IAAAgD,EAAAC,GACAjG,KAAAs4B,OAAA,GACAt4B,MAOA29B,SAAA,SAAA9L,GAGA,MAFA7xB,MAAA6K,MAAA,GAAA+xB,GAAA/K,EAAA7xB,MACAA,KAAAs4B,OAAA,GACAt4B,OAGAiE,EAAAkpB,SAAA+L,EAAAlQ,GACA/kB,EAAAmjB,MAAA8R,EAAA4D,EAEA,IAAAH,GAAAzD,CACAr5B,GAAAD,QAAA+8B,GTirKM,SAAU98B,EAAQD,GUj6KxB,QAAAg+B,GAAAzF,EAAAtG,EAAArf,GACA,GAAAf,GAAA,MAAAogB,EAAApgB,EAAA,EAAAogB,EAAApgB,EACAmE,EAAA,MAAAic,EAAAjc,GAAA,EAAAic,EAAAjc,GACAjE,EAAA,MAAAkgB,EAAAlgB,EAAA,EAAAkgB,EAAAlgB,EACAkE,EAAA,MAAAgc,EAAAhc,GAAA,EAAAgc,EAAAhc,EAEAgc,GAAAgM,SACApsB,EAAAA,EAAAe,EAAAvD,MAAAuD,EAAAf,EACAmE,EAAAA,EAAApD,EAAAvD,MAAAuD,EAAAf,EACAE,EAAAA,EAAAa,EAAAtD,OAAAsD,EAAAb,EACAkE,EAAAA,EAAArD,EAAAtD,OAAAsD,EAAAb,EAGA,IAAAmsB,GAAA3F,EAAAyF,qBAAAnsB,EAAAE,EAAAiE,EAAAC,EACA,OAAAioB,GAGA,QAAAC,GAAA5F,EAAAtG,EAAArf,GACA,GAAAvD,GAAAuD,EAAAvD,MACAC,EAAAsD,EAAAtD,OACA+U,EAAA5Q,KAAA4Q,IAAAhV,EAAAC,GACAuC,EAAA,MAAAogB,EAAApgB,EAAA,GAAAogB,EAAApgB,EACAE,EAAA,MAAAkgB,EAAAlgB,EAAA,GAAAkgB,EAAAlgB,EACAC,EAAA,MAAAigB,EAAAjgB,EAAA,GAAAigB,EAAAjgB,CAEAigB,GAAAgM,SACApsB,EAAAA,EAAAxC,EAAAuD,EAAAf,EACAE,EAAAA,EAAAzC,EAAAsD,EAAAb,EACAC,GAAAqS,EAGA,IAAA6Z,GAAA3F,EAAA4F,qBAAAtsB,EAAAE,EAAA,EAAAF,EAAAE,EAAAC,EACA,OAAAksB,GAxCA,GAAAE,KAAA,aAAA,IAAA,gBAAA,IAAA,gBAAA,IAAA,cAAA,SAAA,UAAA,SAAA,WAAA,UAAA,aAAA,KAGApB,EAAA,SAAA/7B,EAAAo9B,GACAj+B,KAAAw8B,WAAA37B,GAAA,GACAb,KAAAi+B,KAAAA,EAsCArB,GAAA13B,WACAqrB,YAAAqM,EAKAqB,KAAA,KAKApsB,KAAA,OAKAC,OAAA,KAKAkN,QAAA,EAKAI,SAAA,KAKAob,eAAA,EAKA0D,WAAA,EAKAC,cAAA,EAKAC,cAAA,EAKAtoB,UAAA,EAMA2lB,eAAA,EAOA1wB,KAAA,KASAszB,KAAA,KAOAte,SAAA,KAMAue,UAAA,KAMAC,WAAA,KAOAC,SAAA,KAMAC,WAAA,KAMAC,QAAA,KAKA7b,SAAA,OAKA8b,WAAA,KAKAC,UAAA,KAMAC,WAAA,KASAC,gBAAA,EAKAC,eAAA,KASA/zB,aAAA,SAMA8U,SAAA,KAMAkf,WAAA,KAKA7d,UAAA,KAKA8d,kBAAA,KAKAtQ,aAAA,EAKAuQ,gBAAA,cAKAC,eAAA,EAKAC,kBAAA,EAKAC,kBAAA,EAKAC,mBAAA,cAKAC,kBAAA,EAKAC,qBAAA,EAKAC,qBAAA,EAOAC,eAAA,EAMAC,aAAA,EAUAC,WAAA,KAKAC,oBAAA,KAKAC,gBAAA,KAKAC,gBAAA,EAKAC,iBAAA,EAMAC,YAAA,KAMAC,KAAA,KAMAC,SAAA,KAMAC,MAAA,KAKA54B,KAAA,SAAA2wB,EAAAzO,EAAA+P,GAKA,IAAA,GAJA5uB,GAAA7K,KACAqgC,EAAA5G,GAAAA,EAAA5uB,MACAy1B,GAAAD,EAEAhzB,EAAA,EAAmBA,EAAA2wB,EAAA73B,OAA+BkH,IAAA,CAClD,GAAAqkB,GAAAsM,EAAA3wB,GACAkzB,EAAA7O,EAAA,IAEA4O,GAAAz1B,EAAA01B,KAAAF,EAAAE,MAEApI,EAAAoI,GAAA11B,EAAA01B,IAAA7O,EAAA,IAoBA,IAhBA4O,GAAAz1B,EAAAgH,OAAAwuB,EAAAxuB,QACAsmB,EAAAmC,UAAAzvB,EAAAgH,OAGAyuB,GAAAz1B,EAAAiH,SAAAuuB,EAAAvuB,UACAqmB,EAAAoC,YAAA1vB,EAAAiH,SAGAwuB,GAAAz1B,EAAAmU,UAAAqhB,EAAArhB,WACAmZ,EAAAqI,YAAA,MAAA31B,EAAAmU,QAAA,EAAAnU,EAAAmU,UAGAshB,GAAAz1B,EAAAu1B,QAAAC,EAAAD,SACAjI,EAAAsI,yBAAA51B,EAAAu1B,OAAA,eAGApgC,KAAA05B,YAAA,CACA,GAAA5jB,GAAAjL,EAAAiL,SACAqiB,GAAAriB,UAAAA,GAAA9V,KAAAy7B,eAAA/R,GAAAA,EAAAgS,aAAAhS,EAAAgS,eAAA,KAGA/B,QAAA,WACA,GAAA9nB,GAAA7R,KAAA6R,IACA,OAAA,OAAAA,GAAA,SAAAA,GAEA6nB,UAAA,WACA,GAAA5nB,GAAA9R,KAAA8R,MACA,OAAA,OAAAA,GAAA,SAAAA,GAAA9R,KAAA8V,UAAA,GAUA0mB,WAAA,SAAAkE,EAAA/P,GACA,GAAA+P,EACA,IAAA,GAAAr4B,KAAAq4B,IACAA,EAAAxW,eAAA7hB,IAAAsoB,KAAA,IAAAA,KAAA,EAAA3wB,KAAAkqB,eAAA7hB,GAAA,MAAAq4B,EAAAr4B,MACArI,KAAAqI,GAAAq4B,EAAAr4B,KAWArF,IAAA,SAAA6uB,EAAA5rB,GACA,gBAAA4rB,GACA7xB,KAAA6xB,GAAA5rB,EAEAjG,KAAAw8B,WAAA3K,GAAA,IAQAzrB,MAAA,WACA,GAAAu6B,GAAA,GAAA3gC,MAAAuwB,WAEA,OADAoQ,GAAAnE,WAAAx8B,MAAA,GACA2gC,GAEAvG,YAAA,SAAAjC,EAAAtG,EAAArf,GAKA,IAAA,GAJAouB,GAAA,WAAA/O,EAAA/rB,KAAAi4B,EAAAH,EACAE,EAAA8C,EAAAzI,EAAAtG,EAAArf,GACAqnB,EAAAhI,EAAAgI,WAEAxsB,EAAA,EAAmBA,EAAAwsB,EAAA1zB,OAAuBkH,IAC1CywB,EAAA+C,aAAAhH,EAAAxsB,GAAA8F,OAAA0mB,EAAAxsB,GAAAihB,MAGA,OAAAwP,IAKA,KAAA,GAFAgD,GAAAlE,EAAA13B,UAEAmI,EAAA,EAAeA,EAAA2wB,EAAA73B,OAA+BkH,IAAA,CAC9C,GAAAqkB,GAAAsM,EAAA3wB,EAEAqkB,GAAA,IAAAoP,KACAA,EAAApP,EAAA,IAAAA,EAAA,IAKAkL,EAAAxC,YAAA0G,EAAA1G,WACA,IAAAuC,GAAAC,CACA/8B,GAAAD,QAAA+8B,GV+6KM,SAAU98B,EAAQD,EAASM,GW72LjC,GAAA6gC,GAAA7gC,EAAA,IAEA2D,EAAA3D,EAAA,IAEA8gC,EAAA9gC,EAAA,IAEA+gC,EAAA/gC,EAAA,IAEA+D,EAAA/D,EAAA,GASA8oB,EAAA,SAAAnoB,GAEAmgC,EAAAzgC,KAAAP,KAAAa,GACAgD,EAAAtD,KAAAP,KAAAa,GACAogC,EAAA1gC,KAAAP,KAAAa,GAMAb,KAAAK,GAAAQ,EAAAR,IAAA0gC,IAGA/X,GAAA9jB,WAMAY,KAAA,UAOAuC,KAAA,GAQA2zB,KAAA,KASAkF,QAAA,EASAC,SAAA,KAOAC,MAAA,SAAAC,EAAAC,GACA,OAAAthC,KAAAgS,WACA,IAAA,aACAsvB,EAAA,CACA,MAEA,KAAA,WACAD,EAAA,EAIA,GAAA7gC,GAAAR,KAAAwvB,SAEAhvB,KACAA,EAAAR,KAAAwvB,WAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAGAhvB,EAAA,IAAA6gC,EACA7gC,EAAA,IAAA8gC,EACAthC,KAAAuhC,qBACAvhC,KAAAs4B,OAAA,IAMAkJ,aAAA,aAKAC,YAAA,aAKAC,OAAA,WACA1hC,KAAA2hC,mBAOAnX,SAAA,SAAA3M,EAAAC,KAKAwe,OAAA,SAAAt2B,EAAAC,GACA,GAAA,aAAAD,GAAA,UAAAA,GAAA,WAAAA,GAEA,GAAAC,EAAA,CACA,GAAAiB,GAAAlH,KAAAgG,EAEAkB,KACAA,EAAAlH,KAAAgG,OAGAkB,EAAA,GAAAjB,EAAA,GACAiB,EAAA,GAAAjB,EAAA,QAGAjG,MAAAgG,GAAAC,GAOAoF,KAAA,WACArL,KAAAkhC,QAAA,EACAlhC,KAAAg8B,MAAAh8B,KAAAg8B,KAAAC,WAMAruB,KAAA,WACA5N,KAAAkhC,QAAA,EACAlhC,KAAAg8B,MAAAh8B,KAAAg8B,KAAAC,WAOAztB,KAAA,SAAAxI,EAAAC,GACA,GAAA,gBAAAD,GACAhG,KAAAs8B,OAAAt2B,EAAAC,OACK,IAAAhC,EAAA2sB,SAAA5qB,GACL,IAAA,GAAAqC,KAAArC,GACAA,EAAAkkB,eAAA7hB,IACArI,KAAAs8B,OAAAj0B,EAAArC,EAAAqC,GAMA,OADArI,MAAAs4B,OAAA,GACAt4B,MAMA4hC,YAAA,SAAAT,GACA,GAAAU,GAAA7hC,KAAAg8B,IAEA6F,IACAV,EAAAW,YAAAD,GAIA7hC,KAAAmhC,UAAAnhC,KAAAmhC,WAAAA,GACAnhC,KAAA+hC,iBAGA/hC,KAAAmhC,SAAAA,EACAA,EAAAnF,KAAA6F,EACAV,EAAAjF,aAAAl8B,KACAA,KAAAs4B,OAAA,IAKAyJ,eAAA,WACA,GAAAZ,GAAAnhC,KAAAmhC,QAEAA,KACAA,EAAAnF,MACAmF,EAAAa,iBAAAb,EAAAnF,MAGAmF,EAAAnF,KAAA,KACAmF,EAAAjF,aAAA,KACAl8B,KAAAmhC,SAAA,KACAnhC,KAAAs4B,OAAA,KASAwJ,YAAA,SAAAD,GACA7hC,KAAAg8B,KAAA6F,CAEA,IAAAI,GAAAjiC,KAAAiiC,SAEA,IAAAA,EACA,IAAA,GAAA50B,GAAA,EAAqBA,EAAA40B,EAAA97B,OAAsBkH,IAC3Cw0B,EAAAK,UAAAC,YAAAF,EAAA50B,GAIArN,MAAAmhC,UACAnhC,KAAAmhC,SAAAW,YAAAD,IASAG,iBAAA,SAAAH,GACA7hC,KAAAg8B,KAAA,IAEA,IAAAiG,GAAAjiC,KAAAiiC,SAEA,IAAAA,EACA,IAAA,GAAA50B,GAAA,EAAqBA,EAAA40B,EAAA97B,OAAsBkH,IAC3Cw0B,EAAAK,UAAAE,eAAAH,EAAA50B,GAIArN,MAAAmhC,UACAnhC,KAAAmhC,SAAAa,iBAAAH,KAIA59B,EAAAmjB,MAAA4B,EAAAiY,GACAh9B,EAAAmjB,MAAA4B,EAAAgY,GACA/8B,EAAAmjB,MAAA4B,EAAAnlB,EACA,IAAA84B,GAAA3T,CACAnpB,GAAAD,QAAA+8B,GXm3LM,SAAU98B,EAAQD,GYlnMxB,QAAA+8B,KACA,MAAA0F,KAHA,GAAAA,GAAA,IAMAxiC,GAAAD,QAAA+8B,GZ+nMM,SAAU98B,EAAQD,GapoMxB,GAAA0iC,GAAAlpB,MAAAlU,UAAA0jB,MAOA/kB,EAAA,WACA7D,KAAAuiC,cAGA1+B,GAAAqB,WACAqrB,YAAA1sB,EASA2+B,IAAA,SAAAz6B,EAAA06B,EAAA3kB,GACA,GAAA4kB,GAAA1iC,KAAAuiC,UAEA,KAAAE,IAAA16B,EACA,MAAA/H,KAGA0iC,GAAA36B,KACA26B,EAAA36B,MAGA,KAAA,GAAAsF,GAAA,EAAmBA,EAAAq1B,EAAA36B,GAAA5B,OAAsBkH,IACzC,GAAAq1B,EAAA36B,GAAAsF,GAAAs1B,IAAAF,EACA,MAAAziC,KAUA,OANA0iC,GAAA36B,GAAAyB,MACAm5B,EAAAF,EACAD,KAAA,EACArK,IAAAra,GAAA9d,OAGAA,MASA+G,GAAA,SAAAgB,EAAA06B,EAAA3kB,GACA,GAAA4kB,GAAA1iC,KAAAuiC,UAEA,KAAAE,IAAA16B,EACA,MAAA/H,KAGA0iC,GAAA36B,KACA26B,EAAA36B,MAGA,KAAA,GAAAsF,GAAA,EAAmBA,EAAAq1B,EAAA36B,GAAA5B,OAAsBkH,IACzC,GAAAq1B,EAAA36B,GAAAsF,GAAAs1B,IAAAF,EACA,MAAAziC,KAUA,OANA0iC,GAAA36B,GAAAyB,MACAm5B,EAAAF,EACAD,KAAA,EACArK,IAAAra,GAAA9d,OAGAA,MAQA4iC,SAAA,SAAA76B,GACA,GAAA26B,GAAA1iC,KAAAuiC,UACA,OAAAG,GAAA36B,IAAA26B,EAAA36B,GAAA5B,QAQA4C,IAAA,SAAAhB,EAAA06B,GACA,GAAAC,GAAA1iC,KAAAuiC,UAEA,KAAAx6B,EAEA,MADA/H,MAAAuiC,cACAviC,IAGA,IAAAyiC,EAAA,CACA,GAAAC,EAAA36B,GAAA,CAGA,IAAA,GAFA86B,MAEAx1B,EAAA,EAAAy1B,EAAAJ,EAAA36B,GAAA5B,OAA6CkH,EAAAy1B,EAAOz1B,IACpDq1B,EAAA36B,GAAAsF,GAAA,GAAAo1B,GACAI,EAAAr5B,KAAAk5B,EAAA36B,GAAAsF,GAIAq1B,GAAA36B,GAAA86B,EAGAH,EAAA36B,IAAA,IAAA26B,EAAA36B,GAAA5B,cACAu8B,GAAA36B,cAGA26B,GAAA36B,EAGA,OAAA/H,OAQAgI,QAAA,SAAAlC,GACA,GAAA9F,KAAAuiC,WAAAz8B,GAAA,CACA,GAAAusB,GAAAnsB,UACA68B,EAAA1Q,EAAAlsB,MAEA48B,GAAA,IACA1Q,EAAAiQ,EAAA/hC,KAAA8xB,EAAA,GAMA,KAAA,GAHAqQ,GAAA1iC,KAAAuiC,WAAAz8B,GACAsqB,EAAAsS,EAAAv8B,OAEAkH,EAAA,EAAqBA,EAAA+iB,GAAS,CAE9B,OAAA2S,GACA,IAAA,GACAL,EAAAr1B,GAAA,EAAA9M,KAAAmiC,EAAAr1B,GAAA,IAEA,MAEA,KAAA,GACAq1B,EAAAr1B,GAAA,EAAA9M,KAAAmiC,EAAAr1B,GAAA,IAAAglB,EAAA,GAEA,MAEA,KAAA,GACAqQ,EAAAr1B,GAAA,EAAA9M,KAAAmiC,EAAAr1B,GAAA,IAAAglB,EAAA,GAAAA,EAAA,GAEA,MAEA,SAEAqQ,EAAAr1B,GAAA,EAAAuN,MAAA8nB,EAAAr1B,GAAA,IAAAglB,GAKAqQ,EAAAr1B,GAAA,KACAq1B,EAAAn1B,OAAAF,EAAA,GAEA+iB,KAEA/iB,KAKA,MAAArN,OAOAgjC,mBAAA,SAAAl9B,GACA,GAAA9F,KAAAuiC,WAAAz8B,GAAA,CACA,GAAAusB,GAAAnsB,UACA68B,EAAA1Q,EAAAlsB,MAEA48B,GAAA,IACA1Q,EAAAiQ,EAAA/hC,KAAA8xB,EAAA,EAAAA,EAAAlsB,OAAA,GAOA,KAAA,GAJAgyB,GAAA9F,EAAAA,EAAAlsB,OAAA,GACAu8B,EAAA1iC,KAAAuiC,WAAAz8B,GACAsqB,EAAAsS,EAAAv8B,OAEAkH,EAAA,EAAqBA,EAAA+iB,GAAS,CAE9B,OAAA2S,GACA,IAAA,GACAL,EAAAr1B,GAAA,EAAA9M,KAAA43B,EAEA,MAEA,KAAA,GACAuK,EAAAr1B,GAAA,EAAA9M,KAAA43B,EAAA9F,EAAA,GAEA,MAEA,KAAA,GACAqQ,EAAAr1B,GAAA,EAAA9M,KAAA43B,EAAA9F,EAAA,GAAAA,EAAA,GAEA,MAEA,SAEAqQ,EAAAr1B,GAAA,EAAAuN,MAAAud,EAAA9F,GAKAqQ,EAAAr1B,GAAA,KACAq1B,EAAAn1B,OAAAF,EAAA,GAEA+iB,KAEA/iB,KAKA,MAAArN,OAwFA,IAAA28B,GAAA94B,CACAhE,GAAAD,QAAA+8B,GbgpMM,SAAU98B,EAAQD,EAASM,Gc38MjC,QAAA+iC,GAAAnhB,GACA,MAAAA,GAAAohB,GAAAphB,GAAAohB,EAbA,GAAAtX,GAAA1rB,EAAA,IAEA2rB,EAAA3rB,EAAA,IAOAijC,EAAAvX,EAAAwD,SACA8T,EAAA,KAWAlC,EAAA,SAAAngC,GACAA,EAAAA,MAEAA,EAAAoK,WAMAjL,KAAAiL,UAAA,EAAA,IAGA,MAAApK,EAAAgU,WAMA7U,KAAA6U,SAAA,GAGAhU,EAAAoT,QAMAjU,KAAAiU,OAAA,EAAA,IASAjU,KAAAkU,OAAAlU,KAAAkU,QAAA,MAGAkvB,EAAApC,EAAA97B,SACAk+B,GAAA5T,UAAA,KAMA4T,EAAAC,mBAAA,WACA,MAAAJ,GAAAjjC,KAAA6U,WAAAouB,EAAAjjC,KAAAiL,SAAA,KAAAg4B,EAAAjjC,KAAAiL,SAAA,KAAAg4B,EAAAjjC,KAAAiU,MAAA,GAAA,IAAAgvB,EAAAjjC,KAAAiU,MAAA,GAAA,IAGAmvB,EAAAzB,gBAAA,WACA,GAAAx5B,GAAAnI,KAAAmI,OACAm7B,EAAAn7B,GAAAA,EAAAqnB,UACA6T,EAAArjC,KAAAqjC,qBACA7iC,EAAAR,KAAAwvB,SAEA,OAAA6T,IAAAC,GAKA9iC,EAAAA,GAAAorB,EAAA2X,SAEAF,EACArjC,KAAAsvB,kBAAA9uB,GAEA2iC,EAAA3iC,GAIA8iC,IACAD,EACAzX,EAAAyD,IAAA7uB,EAAA2H,EAAAqnB,UAAAhvB,GAEAorB,EAAA0P,KAAA96B,EAAA2H,EAAAqnB,YAKAxvB,KAAAwvB,UAAAhvB,EACAR,KAAAwjC,aAAAxjC,KAAAwjC,cAAA5X,EAAA2X,aACA3X,GAAA6D,OAAAzvB,KAAAwjC,aAAAhjC,SAxBAA,GAAA2iC,EAAA3iC,KA2BA4iC,EAAA9T,kBAAA,SAAA9uB,GACA,MAAAwgC,GAAA1R,kBAAAtvB,KAAAQ,IAQA4iC,EAAAnJ,aAAA,SAAA9B,GACA,GAAA33B,GAAAR,KAAAwvB,UACAiU,EAAAtL,EAAAsL,KAAA,CAEAjjC,GACA23B,EAAA8B,aAAAwJ,EAAAjjC,EAAA,GAAAijC,EAAAjjC,EAAA,GAAAijC,EAAAjjC,EAAA,GAAAijC,EAAAjjC,EAAA,GAAAijC,EAAAjjC,EAAA,GAAAijC,EAAAjjC,EAAA,IAEA23B,EAAA8B,aAAAwJ,EAAA,EAAA,EAAAA,EAAA,EAAA,IAIAL,EAAAtI,iBAAA,SAAA3C,GACA,GAAAsL,GAAAtL,EAAAsL,KAAA,CACAtL,GAAA8B,aAAAwJ,EAAA,EAAA,EAAAA,EAAA,EAAA,GAGA,IAAAC,KAKAN,GAAA7B,mBAAA,WACA,GAAAvhC,KAAAwvB,UAAA,CAIA,GAAArnB,GAAAnI,KAAAmI,OACA3H,EAAAR,KAAAwvB,SAEArnB,IAAAA,EAAAqnB,YAEA5D,EAAAyD,IAAAqU,EAAAv7B,EAAAq7B,aAAAhjC,GACAA,EAAAkjC,EAGA,IAAAC,GAAAnjC,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACAojC,EAAApjC,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACAyK,EAAAjL,KAAAiL,SACAgJ,EAAAjU,KAAAiU,KAEAgvB,GAAAU,EAAA,KACAA,EAAAtwB,KAAA2D,KAAA2sB,IAGAV,EAAAW,EAAA,KACAA,EAAAvwB,KAAA2D,KAAA4sB,IAGApjC,EAAA,GAAA,IACAmjC,GAAAA,GAGAnjC,EAAA,GAAA,IACAojC,GAAAA,GAGA34B,EAAA,GAAAzK,EAAA,GACAyK,EAAA,GAAAzK,EAAA,GACAyT,EAAA,GAAA0vB,EACA1vB,EAAA,GAAA2vB,EACA5jC,KAAA6U,SAAAxB,KAAAqE,OAAAlX,EAAA,GAAAojC,EAAApjC,EAAA,GAAAmjC,KAQAP,EAAAzI,eAAA,WACA,GAAAn6B,GAAAR,KAAAwvB,SAEA,KAAAhvB,EACA,OAAA,EAAA,EAGA,IAAAmjC,GAAAtwB,KAAA2D,KAAAxW,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACAojC,EAAAvwB,KAAA2D,KAAAxW,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAUA,OARAA,GAAA,GAAA,IACAmjC,GAAAA,GAGAnjC,EAAA,GAAA,IACAojC,GAAAA,IAGAD,EAAAC,IAWAR,EAAAvH,sBAAA,SAAApqB,EAAAE,GACA,GAAAkyB,IAAApyB,EAAAE,GACA6xB,EAAAxjC,KAAAwjC,YAMA,OAJAA,IACA3X,EAAAwB,eAAAwW,EAAAA,EAAAL,GAGAK,GAWAT,EAAAU,uBAAA,SAAAryB,EAAAE,GACA,GAAAkyB,IAAApyB,EAAAE,GACA6d,EAAAxvB,KAAAwvB,SAMA,OAJAA,IACA3D,EAAAwB,eAAAwW,EAAAA,EAAArU,GAGAqU,GAYA7C,EAAA1R,kBAAA,SAAApoB,EAAA1G,GACAA,EAAAA,MACA2iC,EAAA3iC,EACA,IAAA0T,GAAAhN,EAAAgN,OACAD,EAAA/M,EAAA+M,QAAA,EAAA,GACAY,EAAA3N,EAAA2N,UAAA,EACA5J,EAAA/D,EAAA+D,WAAA,EAAA,EAsBA,OApBAiJ,KAEA1T,EAAA,IAAA0T,EAAA,GACA1T,EAAA,IAAA0T,EAAA,IAGA0X,EAAA3X,MAAAzT,EAAAA,EAAAyT,GAEAY,GACA+W,EAAAmY,OAAAvjC,EAAAA,EAAAqU,GAGAX,IAEA1T,EAAA,IAAA0T,EAAA,GACA1T,EAAA,IAAA0T,EAAA,IAGA1T,EAAA,IAAAyK,EAAA,GACAzK,EAAA,IAAAyK,EAAA,GACAzK,EAGA,IAAAm8B,GAAAqE,CACAnhC,GAAAD,QAAA+8B,Gd69MM,SAAU98B,EAAQD,Ge7uNxB,QAAA2jC,KACA,GAAAS,GAAA,GAAAC,GAAA,EAEA,OADA7U,GAAA4U,GACAA,EAQA,QAAA5U,GAAA4U,GAOA,MANAA,GAAA,GAAA,EACAA,EAAA,GAAA,EACAA,EAAA,GAAA,EACAA,EAAA,GAAA,EACAA,EAAA,GAAA,EACAA,EAAA,GAAA,EACAA,EASA,QAAA1I,GAAA0I,EAAAxjC,GAOA,MANAwjC,GAAA,GAAAxjC,EAAA,GACAwjC,EAAA,GAAAxjC,EAAA,GACAwjC,EAAA,GAAAxjC,EAAA,GACAwjC,EAAA,GAAAxjC,EAAA,GACAwjC,EAAA,GAAAxjC,EAAA,GACAwjC,EAAA,GAAAxjC,EAAA,GACAwjC,EAUA,QAAA3U,GAAA2U,EAAAE,EAAAC,GAIA,GAAAC,GAAAF,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GACAE,EAAAH,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GACAG,EAAAJ,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GACAI,EAAAL,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GACAK,EAAAN,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,GACAO,EAAAP,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,EAOA,OANAF,GAAA,GAAAI,EACAJ,EAAA,GAAAK,EACAL,EAAA,GAAAM,EACAN,EAAA,GAAAO,EACAP,EAAA,GAAAQ,EACAR,EAAA,GAAAS,EACAT,EAUA,QAAAU,GAAAV,EAAAW,EAAAv3B,GAOA,MANA42B,GAAA,GAAAW,EAAA,GACAX,EAAA,GAAAW,EAAA,GACAX,EAAA,GAAAW,EAAA,GACAX,EAAA,GAAAW,EAAA,GACAX,EAAA,GAAAW,EAAA,GAAAv3B,EAAA,GACA42B,EAAA,GAAAW,EAAA,GAAAv3B,EAAA,GACA42B,EAUA,QAAAD,GAAAC,EAAAW,EAAAC,GACA,GAAAC,GAAAF,EAAA,GACAG,EAAAH,EAAA,GACAI,EAAAJ,EAAA,GACAK,EAAAL,EAAA,GACAM,EAAAN,EAAA,GACAO,EAAAP,EAAA,GACAQ,EAAA9xB,KAAAylB,IAAA8L,GACAQ,EAAA/xB,KAAA0lB,IAAA6L,EAOA,OANAZ,GAAA,GAAAa,EAAAO,EAAAJ,EAAAG,EACAnB,EAAA,IAAAa,EAAAM,EAAAH,EAAAI,EACApB,EAAA,GAAAc,EAAAM,EAAAH,EAAAE,EACAnB,EAAA,IAAAc,EAAAK,EAAAC,EAAAH,EACAjB,EAAA,GAAAoB,EAAAL,EAAAI,EAAAD,EACAlB,EAAA,GAAAoB,EAAAF,EAAAC,EAAAJ,EACAf,EAUA,QAAA/vB,GAAA+vB,EAAAW,EAAAv3B,GACA,GAAAi4B,GAAAj4B,EAAA,GACAk4B,EAAAl4B,EAAA,EAOA,OANA42B,GAAA,GAAAW,EAAA,GAAAU,EACArB,EAAA,GAAAW,EAAA,GAAAW,EACAtB,EAAA,GAAAW,EAAA,GAAAU,EACArB,EAAA,GAAAW,EAAA,GAAAW,EACAtB,EAAA,GAAAW,EAAA,GAAAU,EACArB,EAAA,GAAAW,EAAA,GAAAW,EACAtB,EASA,QAAAvU,GAAAuU,EAAAW,GACA,GAAAE,GAAAF,EAAA,GACAG,EAAAH,EAAA,GACAI,EAAAJ,EAAA,GACAK,EAAAL,EAAA,GACAM,EAAAN,EAAA,GACAO,EAAAP,EAAA,GACAY,EAAAV,EAAAI,EAAAD,EAAAF,CAEA,OAAAS,IAIAA,EAAA,EAAAA,EACAvB,EAAA,GAAAiB,EAAAM,EACAvB,EAAA,IAAAgB,EAAAO,EACAvB,EAAA,IAAAc,EAAAS,EACAvB,EAAA,GAAAa,EAAAU,EACAvB,EAAA,IAAAc,EAAAI,EAAAD,EAAAF,GAAAQ,EACAvB,EAAA,IAAAgB,EAAAD,EAAAF,EAAAK,GAAAK,EACAvB,GAVA,KAlJA,GAAAC,GAAA,mBAAAuB,cAAApsB,MAAAosB,YA+JA5lC,GAAA2jC,OAAAA,EACA3jC,EAAAwvB,SAAAA,EACAxvB,EAAA07B,KAAAA,EACA17B,EAAAyvB,IAAAA,EACAzvB,EAAA8kC,UAAAA,EACA9kC,EAAAmkC,OAAAA,EACAnkC,EAAAqU,MAAAA,EACArU,EAAA6vB,OAAAA,Gf6vNM,SAAU5vB,EAAQD,GgB/5NxB,QAAA2jC,GAAA9xB,EAAAE,GACA,GAAAqyB,GAAA,GAAAC,GAAA,EAYA,OAVA,OAAAxyB,IACAA,EAAA,GAGA,MAAAE,IACAA,EAAA,GAGAqyB,EAAA,GAAAvyB,EACAuyB,EAAA,GAAAryB,EACAqyB,EAUA,QAAA1I,GAAA0I,EAAA52B,GAGA,MAFA42B,GAAA,GAAA52B,EAAA,GACA42B,EAAA,GAAA52B,EAAA,GACA42B,EASA,QAAA59B,GAAAgH,GACA,GAAA42B,GAAA,GAAAC,GAAA,EAGA,OAFAD,GAAA,GAAA52B,EAAA,GACA42B,EAAA,GAAA52B,EAAA,GACA42B,EAWA,QAAAhhC,GAAAghC,EAAAW,EAAAc,GAGA,MAFAzB,GAAA,GAAAW,EACAX,EAAA,GAAAyB,EACAzB,EAUA,QAAAr9B,GAAAq9B,EAAA0B,EAAA7B,GAGA,MAFAG,GAAA,GAAA0B,EAAA,GAAA7B,EAAA,GACAG,EAAA,GAAA0B,EAAA,GAAA7B,EAAA,GACAG,EAWA,QAAA2B,GAAA3B,EAAA0B,EAAA7B,EAAAc,GAGA,MAFAX,GAAA,GAAA0B,EAAA,GAAA7B,EAAA,GAAAc,EACAX,EAAA,GAAA0B,EAAA,GAAA7B,EAAA,GAAAc,EACAX,EAUA,QAAA5pB,GAAA4pB,EAAA0B,EAAA7B,GAGA,MAFAG,GAAA,GAAA0B,EAAA,GAAA7B,EAAA,GACAG,EAAA,GAAA0B,EAAA,GAAA7B,EAAA,GACAG,EASA,QAAA5T,GAAAhjB,GACA,MAAAiG,MAAA2D,KAAA4uB,EAAAx4B,IAWA,QAAAw4B,GAAAx4B,GACA,MAAAA,GAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAWA,QAAAiiB,GAAA2U,EAAA0B,EAAA7B,GAGA,MAFAG,GAAA,GAAA0B,EAAA,GAAA7B,EAAA,GACAG,EAAA,GAAA0B,EAAA,GAAA7B,EAAA,GACAG,EAUA,QAAA6B,GAAA7B,EAAA0B,EAAA7B,GAGA,MAFAG,GAAA,GAAA0B,EAAA,GAAA7B,EAAA,GACAG,EAAA,GAAA0B,EAAA,GAAA7B,EAAA,GACAG,EAUA,QAAA8B,GAAAJ,EAAA7B,GACA,MAAA6B,GAAA,GAAA7B,EAAA,GAAA6B,EAAA,GAAA7B,EAAA,GAUA,QAAA5vB,GAAA+vB,EAAA52B,EAAA24B,GAGA,MAFA/B,GAAA,GAAA52B,EAAA,GAAA24B,EACA/B,EAAA,GAAA52B,EAAA,GAAA24B,EACA/B,EASA,QAAAgC,GAAAhC,EAAA52B,GACA,GAAA64B,GAAA7V,EAAAhjB,EAUA,OARA,KAAA64B,GACAjC,EAAA,GAAA,EACAA,EAAA,GAAA,IAEAA,EAAA,GAAA52B,EAAA,GAAA64B,EACAjC,EAAA,GAAA52B,EAAA,GAAA64B,GAGAjC,EAUA,QAAAtf,GAAAghB,EAAA7B,GACA,MAAAxwB,MAAA2D,MAAA0uB,EAAA,GAAA7B,EAAA,KAAA6B,EAAA,GAAA7B,EAAA,KAAA6B,EAAA,GAAA7B,EAAA,KAAA6B,EAAA,GAAA7B,EAAA,KAWA,QAAAqC,GAAAR,EAAA7B,GACA,OAAA6B,EAAA,GAAA7B,EAAA,KAAA6B,EAAA,GAAA7B,EAAA,KAAA6B,EAAA,GAAA7B,EAAA,KAAA6B,EAAA,GAAA7B,EAAA,IAUA,QAAAsC,GAAAnC,EAAA52B,GAGA,MAFA42B,GAAA,IAAA52B,EAAA,GACA42B,EAAA,IAAA52B,EAAA,GACA42B,EAWA,QAAAoC,GAAApC,EAAA0B,EAAA7B,EAAAwC,GAGA,MAFArC,GAAA,GAAA0B,EAAA,GAAAW,GAAAxC,EAAA,GAAA6B,EAAA,IACA1B,EAAA,GAAA0B,EAAA,GAAAW,GAAAxC,EAAA,GAAA6B,EAAA,IACA1B,EAUA,QAAA3W,GAAA2W,EAAA52B,EAAA5M,GACA,GAAAiR,GAAArE,EAAA,GACAuE,EAAAvE,EAAA,EAGA,OAFA42B,GAAA,GAAAxjC,EAAA,GAAAiR,EAAAjR,EAAA,GAAAmR,EAAAnR,EAAA,GACAwjC,EAAA,GAAAxjC,EAAA,GAAAiR,EAAAjR,EAAA,GAAAmR,EAAAnR,EAAA,GACAwjC,EAUA,QAAA/f,GAAA+f,EAAA0B,EAAA7B,GAGA,MAFAG,GAAA,GAAA3wB,KAAA4Q,IAAAyhB,EAAA,GAAA7B,EAAA,IACAG,EAAA,GAAA3wB,KAAA4Q,IAAAyhB,EAAA,GAAA7B,EAAA,IACAG,EAUA,QAAA9f,GAAA8f,EAAA0B,EAAA7B,GAGA,MAFAG,GAAA,GAAA3wB,KAAA6Q,IAAAwhB,EAAA,GAAA7B,EAAA,IACAG,EAAA,GAAA3wB,KAAA6Q,IAAAwhB,EAAA,GAAA7B,EAAA,IACAG,EA7RA,GAAAC,GAAA,mBAAAuB,cAAApsB,MAAAosB,aAkHAr/B,EAAAiqB,EAYAkW,EAAAV,EAkFAW,EAAA7hB,EAYA8hB,EAAAN,CAoEAtmC,GAAA2jC,OAAAA,EACA3jC,EAAA07B,KAAAA,EACA17B,EAAAwG,MAAAA,EACAxG,EAAAoD,IAAAA,EACApD,EAAA+G,IAAAA,EACA/G,EAAA+lC,YAAAA,EACA/lC,EAAAwa,IAAAA,EACAxa,EAAAwwB,IAAAA,EACAxwB,EAAAuG,OAAAA,EACAvG,EAAAgmC,UAAAA,EACAhmC,EAAA0mC,aAAAA,EACA1mC,EAAAyvB,IAAAA,EACAzvB,EAAAimC,IAAAA,EACAjmC,EAAAkmC,IAAAA,EACAlmC,EAAAqU,MAAAA,EACArU,EAAAomC,UAAAA,EACApmC,EAAA8kB,SAAAA,EACA9kB,EAAA2mC,KAAAA,EACA3mC,EAAAsmC,eAAAA,EACAtmC,EAAA4mC,WAAAA,EACA5mC,EAAAumC,OAAAA,EACAvmC,EAAAwmC,KAAAA,EACAxmC,EAAAytB,eAAAA,EACAztB,EAAAqkB,IAAAA,EACArkB,EAAAskB,IAAAA,GhB66NM,SAAUrkB,EAAQD,EAASM,GiBruOjC,GAAAumC,GAAAvmC,EAAA,IAEAwmC,EAAAxmC,EAAA,IAEAymC,EAAAzmC,EAAA,GAEAqyB,EAAAoU,EAAApU,SACA5X,EAAAgsB,EAAAhsB,WACAiW,EAAA+V,EAAA/V,SACAgB,EAAA+U,EAAA/U,YACA/gB,EAAA81B,EAAA91B,QAMAowB,EAAA,WAKAjhC,KAAAiiC,aAGAhB,GAAA/7B,WACAqrB,YAAA0Q,EAcA5E,QAAA,SAAAtP,EAAAqP,GACA,GAAAl1B,GACA0/B,GAAA,EACAld,EAAA1pB,KACA6hC,EAAA7hC,KAAAg8B,IAEA,IAAAjP,EAAA,CACA,GAAA8Z,GAAA9Z,EAAA3X,MAAA,KACAsc,EAAAhI,CAEAkd,GAAA,UAAAC,EAAA,EAEA,KAAA,GAAAx5B,GAAA,EAAAy1B,EAAA+D,EAAA1gC,OAA8CkH,EAAAy1B,EAAOz1B,IACrDqkB,IAIAA,EAAAA,EAAAmV,EAAAx5B,IAGAqkB,KACAxqB,EAAAwqB,OAGAxqB,GAAAwiB,CAGA,KAAAxiB,EAEA,WADAw/B,GAAA,aAAA3Z,EAAA,+BAAArD,EAAArpB,GAIA,IAAA4hC,GAAAvY,EAAAuY,UACA6E,EAAA,GAAAL,GAAAv/B,EAAAk1B,EAaA,OAZA0K,GAAAC,OAAA,SAAA7/B,GACAwiB,EAAA4O,MAAAsO,KACKI,KAAA,WAEL/E,EAAA10B,OAAAsD,EAAAoxB,EAAA6E,GAAA,KAEA7E,EAAAz4B,KAAAs9B,GAEAjF,GACAA,EAAAK,UAAAC,YAAA2E,GAGAA,GAOAG,cAAA,SAAAC,GAIA,IAAA,GAHAjF,GAAAjiC,KAAAiiC,UACA7R,EAAA6R,EAAA97B,OAEAkH,EAAA,EAAmBA,EAAA+iB,EAAS/iB,IAC5B40B,EAAA50B,GAAAwY,KAAAqhB,EAIA,OADAjF,GAAA97B,OAAA,EACAnG,MAiCAyrB,UAAA,SAAAvkB,EAAAigC,EAAAC,EAAAC,EAAA3sB,EAAA4sB,GAkCA,QAAAN,KACAO,IAEAA,GACA7sB,GAAAA,IApCA6X,EAAA6U,IACA1sB,EAAA2sB,EACAA,EAAAD,EACAA,EAAA,GAEAzsB,EAAA0sB,IACA3sB,EAAA2sB,EACAA,EAAA,SACAD,EAAA,GAEAzsB,EAAAysB,IACA1sB,EAAA0sB,EACAA,EAAA,GAEAzsB,EAAAwsB,IACAzsB,EAAAysB,EACAA,EAAA,KAEAA,IACAA,EAAA,KAIAnnC,KAAAinC,gBAEAjnC,KAAAwnC,kBAAA,GAAAxnC,KAAAkH,EAAAigC,EAAAC,EAIA,IAAAnF,GAAAjiC,KAAAiiC,UAAArZ,QACA2e,EAAAtF,EAAA97B,MAYAohC,IACA7sB,GAAAA,GAKA,KAAA,GAAArN,GAAA,EAAmBA,EAAA40B,EAAA97B,OAAsBkH,IACzC40B,EAAA50B,GAAA25B,KAAAA,GAAAvyB,MAAA4yB,EAAAC,IA6BAE,kBAAA,SAAAza,EAAAkD,EAAA/oB,EAAAigC,EAAAC,GACA,GAAAK,MACAC,EAAA,CAEA,KAAA,GAAAr/B,KAAAnB,GACA,GAAAA,EAAAgjB,eAAA7hB,GAIA,GAAA,MAAA4nB,EAAA5nB,GACAuoB,EAAA1pB,EAAAmB,MAAAupB,EAAA1qB,EAAAmB,IACArI,KAAAwnC,kBAAAza,EAAAA,EAAA,IAAA1kB,EAAAA,EAAA4nB,EAAA5nB,GAAAnB,EAAAmB,GAAA8+B,EAAAC,IAEAK,EAAAp/B,GAAAnB,EAAAmB,GACAq/B,SAEO,IAAA,MAAAxgC,EAAAmB,GAGP,GAAA0kB,EAES,CAET,GAAA5B,KACAA,GAAA4B,MACA5B,EAAA4B,GAAA1kB,GAAAnB,EAAAmB,GACArI,KAAAwO,KAAA2c,OANAnrB,MAAAwO,KAAAnG,EAAAnB,EAAAmB,GAeA,OAJAq/B,GAAA,GACA1nC,KAAAq8B,QAAAtP,GAAA,GAAA4a,KAAA,MAAAR,EAAA,IAAAA,EAAAM,GAAAL,MAAAA,GAAA,GAGApnC,MAGA,IAAA28B,GAAAsE,CACAphC,GAAAD,QAAA+8B,GjB2uOM,SAAU98B,EAAQD,EAASM,GkB39OjC,QAAA0nC,GAAA1gC,EAAAlB,GACA,MAAAkB,GAAAlB,GAGA,QAAA6hC,GAAA3gC,EAAAlB,EAAAC,GACAiB,EAAAlB,GAAAC,EAUA,QAAA6hC,GAAAC,EAAAC,EAAAC,GACA,OAAAD,EAAAD,GAAAE,EAAAF,EAUA,QAAAG,GAAAH,EAAAC,EAAAC,GACA,MAAAA,GAAA,GAAAD,EAAAD,EAWA,QAAAI,GAAAJ,EAAAC,EAAAC,EAAAjE,EAAAoE,GACA,GAAAhY,GAAA2X,EAAA5hC,MAEA,IAAA,GAAAiiC,EACA,IAAA,GAAA/6B,GAAA,EAAmBA,EAAA+iB,EAAS/iB,IAC5B22B,EAAA32B,GAAAy6B,EAAAC,EAAA16B,GAAA26B,EAAA36B,GAAA46B,OAKA,KAAA,GAFAI,GAAAjY,GAAA2X,EAAA,GAAA5hC,OAEAkH,EAAA,EAAmBA,EAAA+iB,EAAS/iB,IAC5B,IAAA,GAAAsQ,GAAA,EAAqBA,EAAA0qB,EAAU1qB,IAC/BqmB,EAAA32B,GAAAsQ,GAAAmqB,EAAAC,EAAA16B,GAAAsQ,GAAAqqB,EAAA36B,GAAAsQ,GAAAsqB,GAQA,QAAAK,GAAAC,EAAAC,EAAAJ,GACA,GAAAK,GAAAF,EAAApiC,OACAuiC,EAAAF,EAAAriC,MAEA,IAAAsiC,IAAAC,EAAA,CAEA,GAAAC,GAAAF,EAAAC,CAEA,IAAAC,EAEAJ,EAAApiC,OAAAuiC,MAGA,KAAA,GAAAr7B,GAAAo7B,EAA2Bp7B,EAAAq7B,EAAar7B,IACxCk7B,EAAA/+B,KAAA,IAAA4+B,EAAAI,EAAAn7B,GAAAu7B,EAAAroC,KAAAioC,EAAAn7B,KAQA,IAAA,GAFAg7B,GAAAE,EAAA,IAAAA,EAAA,GAAApiC,OAEAkH,EAAA,EAAiBA,EAAAk7B,EAAApiC,OAAiBkH,IAClC,GAAA,IAAA+6B,EACA3iB,MAAA8iB,EAAAl7B,MACAk7B,EAAAl7B,GAAAm7B,EAAAn7B,QAGA,KAAA,GAAAsQ,GAAA,EAAqBA,EAAA0qB,EAAU1qB,IAC/B8H,MAAA8iB,EAAAl7B,GAAAsQ,MACA4qB,EAAAl7B,GAAAsQ,GAAA6qB,EAAAn7B,GAAAsQ,IAcA,QAAAkrB,GAAAN,EAAAC,EAAAJ,GACA,GAAAG,IAAAC,EACA,OAAA,CAGA,IAAApY,GAAAmY,EAAApiC,MAEA,IAAAiqB,IAAAoY,EAAAriC,OACA,OAAA,CAGA,IAAA,IAAAiiC,GACA,IAAA,GAAA/6B,GAAA,EAAmBA,EAAA+iB,EAAS/iB,IAC5B,GAAAk7B,EAAAl7B,KAAAm7B,EAAAn7B,GACA,OAAA,MAMA,KAAA,GAFAg7B,GAAAE,EAAA,GAAApiC,OAEAkH,EAAA,EAAmBA,EAAA+iB,EAAS/iB,IAC5B,IAAA,GAAAsQ,GAAA,EAAqBA,EAAA0qB,EAAU1qB,IAC/B,GAAA4qB,EAAAl7B,GAAAsQ,KAAA6qB,EAAAn7B,GAAAsQ,GACA,OAAA,CAMA,QAAA,EAgBA,QAAAmrB,GAAAf,EAAAC,EAAAe,EAAAC,EAAA3C,EAAA4C,EAAAC,EAAAlF,EAAAoE,GACA,GAAAhY,GAAA2X,EAAA5hC,MAEA,IAAA,GAAAiiC,EACA,IAAA,GAAA/6B,GAAA,EAAmBA,EAAA+iB,EAAS/iB,IAC5B22B,EAAA32B,GAAA87B,EAAApB,EAAA16B,GAAA26B,EAAA36B,GAAA07B,EAAA17B,GAAA27B,EAAA37B,GAAAg5B,EAAA4C,EAAAC,OAKA,KAAA,GAFAb,GAAAN,EAAA,GAAA5hC,OAEAkH,EAAA,EAAmBA,EAAA+iB,EAAS/iB,IAC5B,IAAA,GAAAsQ,GAAA,EAAqBA,EAAA0qB,EAAU1qB,IAC/BqmB,EAAA32B,GAAAsQ,GAAAwrB,EAAApB,EAAA16B,GAAAsQ,GAAAqqB,EAAA36B,GAAAsQ,GAAAorB,EAAA17B,GAAAsQ,GAAAqrB,EAAA37B,GAAAsQ,GAAA0oB,EAAA4C,EAAAC,GAkBA,QAAAC,GAAApB,EAAAC,EAAAe,EAAAC,EAAA3C,EAAA4C,EAAAC,GACA,GAAAE,GAAA,IAAAL,EAAAhB,GACArC,EAAA,IAAAsD,EAAAhB,EACA,QAAA,GAAAA,EAAAe,GAAAK,EAAA1D,GAAAwD,OAAAlB,EAAAe,GAAA,EAAAK,EAAA1D,GAAAuD,EAAAG,EAAA/C,EAAA2B,EAGA,QAAAqB,GAAApjC,GACA,GAAA2rB,EAAA3rB,GAAA,CACA,GAAAmqB,GAAAnqB,EAAAE,MAEA,IAAAyrB,EAAA3rB,EAAA,IAAA,CAGA,IAAA,GAFAqjC,MAEAj8B,EAAA,EAAqBA,EAAA+iB,EAAS/iB,IAC9Bi8B,EAAA9/B,KAAAo/B,EAAAroC,KAAA0F,EAAAoH,IAGA,OAAAi8B,GAGA,MAAAV,GAAAroC,KAAA0F,GAGA,MAAAA,GAGA,QAAAsjC,GAAAC,GAIA,MAHAA,GAAA,GAAAn2B,KAAAkW,MAAAigB,EAAA,IACAA,EAAA,GAAAn2B,KAAAkW,MAAAigB,EAAA,IACAA,EAAA,GAAAn2B,KAAAkW,MAAAigB,EAAA,IACA,QAAAA,EAAAC,KAAA,KAAA,IAGA,QAAAC,GAAAC,GACA,GAAAC,GAAAD,EAAAA,EAAAxjC,OAAA,GAAAF,KACA,OAAA2rB,GAAAgY,GAAAA,EAAA,IAAA,EAAA,EAGA,QAAAC,GAAA/C,EAAAO,EAAAyC,EAAAH,EAAAI,EAAAzC,GACA,GAAA0C,GAAAlD,EAAAmD,QACAC,EAAApD,EAAAqD,QACAC,EAAA,WAAA/C,EACAgD,EAAAV,EAAAxjC,MAEA,IAAAkkC,EAAA,CAKA,GAMAC,GANAC,EAAAZ,EAAA,GAAA1jC,MACAukC,EAAA5Y,EAAA2Y,GACAE,GAAA,EACAC,GAAA,EAEAtC,EAAAoC,EAAAd,EAAAC,GAAA,CAGAA,GAAAgB,KAAA,SAAAhG,EAAAc,GACA,MAAAd,GAAAwC,KAAA1B,EAAA0B,OAEAmD,EAAAX,EAAAU,EAAA,GAAAlD,IAQA,KAAA,GANAyD,MAEAC,KACAC,EAAAnB,EAAA,GAAA1jC,MACA8kC,GAAA,EAEA19B,EAAA,EAAiBA,EAAAg9B,EAAch9B,IAAA,CAC/Bu9B,EAAAphC,KAAAmgC,EAAAt8B,GAAA85B,KAAAmD,EAEA,IAAArkC,GAAA0jC,EAAAt8B,GAAApH,KAQA,IANAukC,GAAA3B,EAAA5iC,EAAA6kC,EAAA1C,KAAAoC,GAAAvkC,IAAA6kC,IACAC,GAAA,GAGAD,EAAA7kC,EAEA,gBAAAA,GAAA,CACA,GAAA+kC,GAAA1c,EAAA2c,MAAAhlC,EAEA+kC,IACA/kC,EAAA+kC,EACAP,GAAA,GAEAC,GAAA,EAIAG,EAAArhC,KAAAvD,GAGA,GAAAqhC,IAAAyD,EAAA,CAMA,IAAA,GAFAnB,GAAAiB,EAAAR,EAAA,GAEAh9B,EAAA,EAAiBA,EAAAg9B,EAAA,EAAkBh9B,IACnCm9B,EACAlC,EAAAuC,EAAAx9B,GAAAu8B,EAAAxB,IAEA3iB,MAAAolB,EAAAx9B,KAAAoY,MAAAmkB,IAAAc,GAAAD,IACAI,EAAAx9B,GAAAu8B,EAKAY,IAAAlC,EAAA0B,EAAAlD,EAAAoE,QAAAnB,GAAAH,EAAAxB,EAGA,IAEA3zB,GACA8mB,EACAwM,EACAC,EACAe,EACAC,EAPAmC,EAAA,EACAC,EAAA,CAQA,IAAAX,EACA,GAAAjB,IAAA,EAAA,EAAA,EAAA,EAGA,IAAA6B,GAAA,SAAAnkC,EAAA+gC,GAIA,GAAAqD,EAEA,IAAArD,EAAA,EACAqD,EAAA,MACK,IAAArD,EAAAmD,EAAA,CAKL,IAFA32B,EAAApB,KAAA4Q,IAAAknB,EAAA,EAAAd,EAAA,GAEAiB,EAAA72B,EAAyB62B,GAAA,KACzBV,EAAAU,IAAArD,GADqCqD,KAOrCA,EAAAj4B,KAAA4Q,IAAAqnB,EAAAjB,EAAA,OACK,CACL,IAAAiB,EAAAH,EAA6BG,EAAAjB,KAC7BO,EAAAU,GAAArD,GAD+CqD,KAM/CA,EAAAj4B,KAAA4Q,IAAAqnB,EAAA,EAAAjB,EAAA,GAGAc,EAAAG,EACAF,EAAAnD,CACA,IAAAsD,GAAAX,EAAAU,EAAA,GAAAV,EAAAU,EAEA,IAAA,IAAAC,EAMA,GAHAhQ,GAAA0M,EAAA2C,EAAAU,IAAAC,EAGAnB,EAMA,GALApC,EAAA6C,EAAAS,GACAvD,EAAA8C,EAAA,IAAAS,EAAAA,EAAAA,EAAA,GACAvC,EAAA8B,EAAAS,EAAAjB,EAAA,EAAAA,EAAA,EAAAiB,EAAA,GACAtC,EAAA6B,EAAAS,EAAAjB,EAAA,EAAAA,EAAA,EAAAiB,EAAA,GAEAd,EACA1B,EAAAf,EAAAC,EAAAe,EAAAC,EAAAzN,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAAAyO,EAAA9iC,EAAA6iC,GAAA3B,OACO,CACP,GAAAniC,EAEA,IAAAwkC,EACAxkC,EAAA6iC,EAAAf,EAAAC,EAAAe,EAAAC,EAAAzN,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAAAiO,EAAA,GACAvjC,EAAAsjC,EAAAC,OACS,CAAA,GAAAkB,EAET,MAAAxC,GAAAF,EAAAe,EAAAxN,EAEAt1B,GAAAkjC,EAAApB,EAAAC,EAAAe,EAAAC,EAAAzN,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,GAGA2O,EAAAhjC,EAAA6iC,EAAA9jC,OAGA,IAAAukC,EACArC,EAAA0C,EAAAS,GAAAT,EAAAS,EAAA,GAAA/P,EAAAyO,EAAA9iC,EAAA6iC,GAAA3B,OACO,CACP,GAAAniC,EAEA,IAAAwkC,EACAtC,EAAA0C,EAAAS,GAAAT,EAAAS,EAAA,GAAA/P,EAAAiO,EAAA,GACAvjC,EAAAsjC,EAAAC,OACS,CAAA,GAAAkB,EAET,MAAAxC,GAAA2C,EAAAS,GAAAT,EAAAS,EAAA,GAAA/P,EAEAt1B,GAAA6hC,EAAA+C,EAAAS,GAAAT,EAAAS,EAAA,GAAA/P,GAGA2O,EAAAhjC,EAAA6iC,EAAA9jC,KAKAulC,EAAA,GAAAC,IACAvkC,OAAA4/B,EAAAoE,QACAQ,KAAApB,EACAlO,KAAA0K,EAAA6E,MACAvE,MAAAN,EAAA8E,OACAP,QAAAA,EACAQ,UAAA/B,GAOA,OAJAzC,IAAA,WAAAA,IACAmE,EAAAnE,OAAAA,GAGAmE,IA7ZA,GAAAC,GAAAvrC,EAAA,IAEAouB,EAAApuB,EAAA,IAEAymC,EAAAzmC,EAAA,GAEA0xB,EAAA+U,EAAA/U,YAKAgX,EAAAxvB,MAAAlU,UAAA0jB,MA8ZA6d,EAAA,SAAAv/B,EAAAk1B,EAAA4N,EAAAE,GACAlqC,KAAA8rC,WACA9rC,KAAAkrC,QAAAhkC,EACAlH,KAAA2rC,MAAAvP,IAAA,EACAp8B,KAAAiqC,QAAAD,GAAApC,EACA5nC,KAAAmqC,QAAAD,GAAArC,EACA7nC,KAAA+rC,WAAA,EACA/rC,KAAA4rC,OAAA,EACA5rC,KAAAgsC,aACAhsC,KAAAisC,gBACAjsC,KAAAksC,aAGAzF,GAAAvhC,WAOAyiC,KAAA,SAAAR,EAEAhc,GACA,GAAAghB,GAAAnsC,KAAA8rC,OAEA,KAAA,GAAA/B,KAAA5e,GACA,GAAAA,EAAAjB,eAAA6f,GAAA,CAIA,IAAAoC,EAAApC,GAAA,CACAoC,EAAApC,KAEA,IAAA9jC,GAAAjG,KAAAiqC,QAAAjqC,KAAAkrC,QAAAnB,EAEA,IAAA,MAAA9jC,EAEA,QAOA,KAAAkhC,GACAgF,EAAApC,GAAAvgC,MACA29B,KAAA,EACAlhC,MAAAojC,EAAApjC,KAKAkmC,EAAApC,GAAAvgC,MACA29B,KAAAA,EACAlhC,MAAAklB,EAAA4e,KAIA,MAAA/pC,OAQA+mC,OAAA,SAAArsB,GAGA,MAFA1a,MAAAisC,aAAAziC,KAAAkR,GAEA1a,MAEAosC,MAAA,WACA,IAAA,GAAA/+B,GAAA,EAAmBA,EAAArN,KAAAksC,UAAA/lC,OAA2BkH,IAC9CrN,KAAAksC,UAAA7+B,GAAA++B,OAGApsC,MAAAqsC,SAAA,GAEAC,OAAA,WACA,IAAA,GAAAj/B,GAAA,EAAmBA,EAAArN,KAAAksC,UAAA/lC,OAA2BkH,IAC9CrN,KAAAksC,UAAA7+B,GAAAi/B,QAGAtsC,MAAAqsC,SAAA,GAEAE,SAAA,WACA,QAAAvsC,KAAAqsC,SAEAG,cAAA,WAEAxsC,KAAA8rC,WAEA9rC,KAAAksC,UAAA/lC,OAAA,CAIA,KAAA,GAHAsmC,GAAAzsC,KAAAgsC,UACA5b,EAAAqc,EAAAtmC,OAEAkH,EAAA,EAAmBA,EAAA+iB,EAAS/iB,IAC5Bo/B,EAAAp/B,GAAA9M,KAAAP,OAWAyU,MAAA,SAAA4yB,EAAAC,GACA,GAWAoF,GAXAC,EAAA3sC,KACA4sC,EAAA,EAEA9C,EAAA,WACA8C,IAEAA,GACAD,EAAAH,gBAMA,KAAA,GAAAzC,KAAA/pC,MAAA8rC,QACA,GAAA9rC,KAAA8rC,QAAA5hB,eAAA6f,GAAA,CAIA,GAAAyB,GAAA3B,EAAA7pC,KAAAqnC,EAAAyC,EAAA9pC,KAAA8rC,QAAA/B,GAAAA,EAAAzC,EAEAkE,KACAxrC,KAAAksC,UAAA1iC,KAAAgiC,GAEAoB,IAEA5sC,KAAAkiC,WACAliC,KAAAkiC,UAAA2K,QAAArB,GAGAkB,EAAAlB,GAKA,GAAAkB,EAAA,CACA,GAAAI,GAAAJ,EAAArB,OAEAqB,GAAArB,QAAA,SAAAnkC,EAAA+gC,GACA6E,EAAA5lC,EAAA+gC,EAEA,KAAA,GAAA56B,GAAA,EAAuBA,EAAAs/B,EAAAV,aAAA9lC,OAA8BkH,IACrDs/B,EAAAV,aAAA5+B,GAAAnG,EAAA+gC,IAYA,MAJA2E,IACA5sC,KAAAwsC,gBAGAxsC,MAOA6lB,KAAA,SAAAqhB,GAIA,IAAA,GAHA6F,GAAA/sC,KAAAksC,UACAhK,EAAAliC,KAAAkiC,UAEA70B,EAAA,EAAmBA,EAAA0/B,EAAA5mC,OAAqBkH,IAAA,CACxC,GAAAm+B,GAAAuB,EAAA1/B,EAEA65B,IAEAsE,EAAAH,QAAArrC,KAAAkrC,QAAA,GAGAhJ,GAAAA,EAAA8K,WAAAxB,GAGAuB,EAAA5mC,OAAA,GAQAihC,MAAA,SAAAD,GAEA,MADAnnC,MAAA4rC,OAAAzE,EACAnnC,MAQAgnC,KAAA,SAAAnpB,GAKA,MAJAA,IACA7d,KAAAgsC,UAAAxiC,KAAAqU,GAGA7d,MAMAitC,SAAA,WACA,MAAAjtC,MAAAksC,WAGA,IAAAvP,GAAA8J,CACA5mC,GAAAD,QAAA+8B,GlB8+OM,SAAU98B,EAAQD,EAASM,GmBjmQjC,QAAAurC,GAAAroC,GACApD,KAAAkrC,QAAA9nC,EAAA8D,OAEAlH,KAAAktC,MAAA9pC,EAAAsoC,MAAA,IAEA1rC,KAAA4rC,OAAAxoC,EAAAgkC,OAAA,EAGApnC,KAAAmtC,cAAA,EAEAntC,KAAAo8B,KAAA,MAAAh5B,EAAAg5B,MAAAh5B,EAAAg5B,KACAp8B,KAAAotC,IAAAhqC,EAAAgqC,KAAA,EACAptC,KAAAqnC,OAAAjkC,EAAAikC,QAAA,SACArnC,KAAAqrC,QAAAjoC,EAAAioC,QACArrC,KAAA6rC,UAAAzoC,EAAAyoC,UACA7rC,KAAAqtC,UAAAjqC,EAAAiqC,UACArtC,KAAAstC,YAAA,EACAttC,KAAAqsC,SAAA,EAjCA,GAAAkB,GAAArtC,EAAA,GAoCAurC,GAAAvmC,WACAqrB,YAAAkb,EACAnqC,KAAA,SAAAksC,EAAAC,GAQA,GALAztC,KAAAmtC,eACAntC,KAAA0tC,WAAAF,EAAAxtC,KAAA4rC,OACA5rC,KAAAmtC,cAAA,GAGAntC,KAAAqsC,QAEA,YADArsC,KAAAstC,aAAAG,EAIA,IAAAxF,IAAAuF,EAAAxtC,KAAA0tC,WAAA1tC,KAAAstC,aAAAttC,KAAAktC,KAEA,MAAAjF,EAAA,GAAA,CAIAA,EAAA50B,KAAA4Q,IAAAgkB,EAAA,EACA,IAAAZ,GAAArnC,KAAAqnC,OACAsG,EAAA,gBAAAtG,GAAAkG,EAAAlG,GAAAA,EACAuG,EAAA,kBAAAD,GAAAA,EAAA1F,GAAAA,CAGA,OAFAjoC,MAAA6tC,KAAA,QAAAD,GAEA,GAAA3F,EACAjoC,KAAAo8B,MACAp8B,KAAA8tC,QAAAN,GAGA,YAKAxtC,KAAA+tC,cAAA,EACA,WAGA,OAEAD,QAAA,SAAAN,GACA,GAAAQ,IAAAR,EAAAxtC,KAAA0tC,WAAA1tC,KAAAstC,aAAAttC,KAAAktC,KACAltC,MAAA0tC,WAAAF,EAAAQ,EAAAhuC,KAAAotC,IACAptC,KAAAstC,YAAA,EACAttC,KAAA+tC,cAAA,GAEAF,KAAA,SAAAI,EAAAC,GACAD,EAAA,KAAAA,EAEAjuC,KAAAiuC,IACAjuC,KAAAiuC,GAAAjuC,KAAAkrC,QAAAgD,IAGA9B,MAAA,WACApsC,KAAAqsC,SAAA,GAEAC,OAAA,WACAtsC,KAAAqsC,SAAA,GAGA,IAAA1P,GAAA8O,CACA5rC,GAAAD,QAAA+8B,GnBunQM,SAAU98B,EAAQD,GoBttQxB,GAAAynC,IAKA8G,OAAA,SAAAC,GACA,MAAAA,IAOAC,YAAA,SAAAD,GACA,MAAAA,GAAAA,GAOAE,aAAA,SAAAF,GACA,MAAAA,IAAA,EAAAA,IAOAG,eAAA,SAAAH,GACA,OAAAA,GAAA,GAAA,EACA,GAAAA,EAAAA,SAGAA,GAAAA,EAAA,GAAA,IAQAI,QAAA,SAAAJ,GACA,MAAAA,GAAAA,EAAAA,GAOAK,SAAA,SAAAL,GACA,QAAAA,EAAAA,EAAAA,EAAA,GAOAM,WAAA,SAAAN,GACA,OAAAA,GAAA,GAAA,EACA,GAAAA,EAAAA,EAAAA,EAGA,KAAAA,GAAA,GAAAA,EAAAA,EAAA,IAQAO,UAAA,SAAAP,GACA,MAAAA,GAAAA,EAAAA,EAAAA,GAOAQ,WAAA,SAAAR,GACA,MAAA,MAAAA,EAAAA,EAAAA,EAAAA,GAOAS,aAAA,SAAAT,GACA,OAAAA,GAAA,GAAA,EACA,GAAAA,EAAAA,EAAAA,EAAAA,QAGAA,GAAA,GAAAA,EAAAA,EAAAA,EAAA,IAQAU,UAAA,SAAAV,GACA,MAAAA,GAAAA,EAAAA,EAAAA,EAAAA,GAOAW,WAAA,SAAAX,GACA,QAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAAA,GAOAY,aAAA,SAAAZ,GACA,OAAAA,GAAA,GAAA,EACA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAGA,KAAAA,GAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAA,IAQAa,aAAA,SAAAb,GACA,MAAA,GAAA/6B,KAAA0lB,IAAAqV,EAAA/6B,KAAA0B,GAAA,IAOAm6B,cAAA,SAAAd,GACA,MAAA/6B,MAAAylB,IAAAsV,EAAA/6B,KAAA0B,GAAA,IAOAo6B,gBAAA,SAAAf,GACA,MAAA,IAAA,EAAA/6B,KAAA0lB,IAAA1lB,KAAA0B,GAAAq5B,KAQAgB,cAAA,SAAAhB,GACA,MAAA,KAAAA,EAAA,EAAA/6B,KAAA4D,IAAA,KAAAm3B,EAAA,IAOAiB,eAAA,SAAAjB,GACA,MAAA,KAAAA,EAAA,EAAA,EAAA/6B,KAAA4D,IAAA,MAAAm3B,IAOAkB,iBAAA,SAAAlB,GACA,MAAA,KAAAA,EACA,EAGA,IAAAA,EACA,GAGAA,GAAA,GAAA,EACA,GAAA/6B,KAAA4D,IAAA,KAAAm3B,EAAA,GAGA,KAAA/6B,KAAA4D,IAAA,OAAAm3B,EAAA,IAAA,IAQAmB,WAAA,SAAAnB,GACA,MAAA,GAAA/6B,KAAA2D,KAAA,EAAAo3B,EAAAA,IAOAoB,YAAA,SAAApB,GACA,MAAA/6B,MAAA2D,KAAA,KAAAo3B,EAAAA,IAOAqB,cAAA,SAAArB,GACA,OAAAA,GAAA,GAAA,OACA/6B,KAAA2D,KAAA,EAAAo3B,EAAAA,GAAA,GAGA,IAAA/6B,KAAA2D,KAAA,GAAAo3B,GAAA,GAAAA,GAAA,IAQAsB,UAAA,SAAAtB,GACA,GAAArI,GACApB,EAAA,GACAjkC,EAAA,EAEA,OAAA,KAAA0tC,EACA,EAGA,IAAAA,EACA,IAGAzJ,GAAAA,EAAA,GACAA,EAAA,EACAoB,EAAArlC,EAAA,GAEAqlC,EAAArlC,EAAA2S,KAAAs8B,KAAA,EAAAhL,IAAA,EAAAtxB,KAAA0B,MAGA4vB,EAAAtxB,KAAA4D,IAAA,EAAA,IAAAm3B,GAAA,IAAA/6B,KAAAylB,KAAAsV,EAAArI,IAAA,EAAA1yB,KAAA0B,IAAArU,MAOAkvC,WAAA,SAAAxB,GACA,GAAArI,GACApB,EAAA,GACAjkC,EAAA,EAEA,OAAA,KAAA0tC,EACA,EAGA,IAAAA,EACA,IAGAzJ,GAAAA,EAAA,GACAA,EAAA,EACAoB,EAAArlC,EAAA,GAEAqlC,EAAArlC,EAAA2S,KAAAs8B,KAAA,EAAAhL,IAAA,EAAAtxB,KAAA0B,IAGA4vB,EAAAtxB,KAAA4D,IAAA,MAAAm3B,GAAA/6B,KAAAylB,KAAAsV,EAAArI,IAAA,EAAA1yB,KAAA0B,IAAArU,GAAA,IAOAmvC,aAAA,SAAAzB,GACA,GAAArI,GACApB,EAAA,GACAjkC,EAAA,EAEA,OAAA,KAAA0tC,EACA,EAGA,IAAAA,EACA,IAGAzJ,GAAAA,EAAA,GACAA,EAAA,EACAoB,EAAArlC,EAAA,GAEAqlC,EAAArlC,EAAA2S,KAAAs8B,KAAA,EAAAhL,IAAA,EAAAtxB,KAAA0B,KAGAq5B,GAAA,GAAA,OACAzJ,EAAAtxB,KAAA4D,IAAA,EAAA,IAAAm3B,GAAA,IAAA/6B,KAAAylB,KAAAsV,EAAArI,IAAA,EAAA1yB,KAAA0B,IAAArU,IAGAikC,EAAAtxB,KAAA4D,IAAA,OAAAm3B,GAAA,IAAA/6B,KAAAylB,KAAAsV,EAAArI,IAAA,EAAA1yB,KAAA0B,IAAArU,GAAA,GAAA,IAQAovC,OAAA,SAAA1B,GACA,GAAArI,GAAA,OACA,OAAAqI,GAAAA,IAAArI,EAAA,GAAAqI,EAAArI,IAOAgK,QAAA,SAAA3B,GACA,GAAArI,GAAA,OACA,SAAAqI,EAAAA,IAAArI,EAAA,GAAAqI,EAAArI,GAAA,GAOAiK,UAAA,SAAA5B,GACA,GAAArI,GAAA,SAEA,QAAAqI,GAAA,GAAA,EACA,IAAAA,EAAAA,IAAArI,EAAA,GAAAqI,EAAArI,IAGA,KAAAqI,GAAA,GAAAA,IAAArI,EAAA,GAAAqI,EAAArI,GAAA,IAQAkK,SAAA,SAAA7B,GACA,MAAA,GAAA/G,EAAA6I,UAAA,EAAA9B,IAOA8B,UAAA,SAAA9B,GACA,MAAAA,GAAA,EAAA,KACA,OAAAA,EAAAA,EACKA,EAAA,EAAA,KACL,QAAAA,GAAA,IAAA,MAAAA,EAAA,IACKA,EAAA,IAAA,KACL,QAAAA,GAAA,KAAA,MAAAA,EAAA,MAEA,QAAAA,GAAA,MAAA,MAAAA,EAAA,SAQA+B,YAAA,SAAA/B,GACA,MAAAA,GAAA,GACA,GAAA/G,EAAA4I,SAAA,EAAA7B,GAGA,GAAA/G,EAAA6I,UAAA,EAAA9B,EAAA,GAAA,KAGAzR,EAAA0K,CACAxnC,GAAAD,QAAA+8B,GpBiuQM,SAAU98B,EAAQD,EAASM,GqBj8QjC,QAAAkwC,GAAA/iC,GAIA,MAFAA,GAAAgG,KAAA4B,MAAA5H,GAEAA,EAAA,EAAA,EAAAA,EAAA,IAAA,IAAAA,EAGA,QAAAgjC,GAAAhjC,GAIA,MAFAA,GAAAgG,KAAA4B,MAAA5H,GAEAA,EAAA,EAAA,EAAAA,EAAA,IAAA,IAAAA,EAGA,QAAAijC,GAAAta,GAEA,MAAAA,GAAA,EAAA,EAAAA,EAAA,EAAA,EAAAA,EAGA,QAAAua,GAAApZ,GAEA,MACAiZ,GADAjZ,EAAAhxB,QAAA,MAAAgxB,EAAA9U,OAAA8U,EAAAhxB,OAAA,GACAkxB,WAAAF,GAAA,IAAA,IAGAhe,SAAAge,EAAA,KAGA,QAAAqZ,GAAArZ,GAEA,MACAmZ,GADAnZ,EAAAhxB,QAAA,MAAAgxB,EAAA9U,OAAA8U,EAAAhxB,OAAA,GACAkxB,WAAAF,GAAA,IAGAE,WAAAF,IAGA,QAAAsZ,GAAAvM,EAAAC,EAAAxB,GAOA,MANAA,GAAA,EACAA,GAAA,EACGA,EAAA,IACHA,GAAA,GAGA,EAAAA,EAAA,EACAuB,GAAAC,EAAAD,GAAAvB,EAAA,EAGA,EAAAA,EAAA,EACAwB,EAGA,EAAAxB,EAAA,EACAuB,GAAAC,EAAAD,IAAA,EAAA,EAAAvB,GAAA,EAGAuB,EAGA,QAAAwM,GAAA/L,EAAAc,EAAA/kC,GACA,MAAAikC,IAAAc,EAAAd,GAAAjkC,EAGA,QAAAiwC,GAAA3M,EAAApyB,EAAAg/B,EAAAnL,EAAAd,GAKA,MAJAX,GAAA,GAAApyB,EACAoyB,EAAA,GAAA4M,EACA5M,EAAA,GAAAyB,EACAzB,EAAA,GAAAW,EACAX,EAGA,QAAA6M,GAAA7M,EAAAW,GAKA,MAJAX,GAAA,GAAAW,EAAA,GACAX,EAAA,GAAAW,EAAA,GACAX,EAAA,GAAAW,EAAA,GACAX,EAAA,GAAAW,EAAA,GACAX,EAMA,QAAA8M,GAAAC,EAAAC,GAEAC,GACAJ,EAAAI,EAAAD,GAGAC,EAAAC,EAAAC,IAAAJ,EAAAE,GAAAD,EAAApoB,SAUA,QAAAqiB,GAAA8F,EAAAC,GACA,GAAAD,EAAA,CAIAC,EAAAA,KACA,IAAAI,GAAAF,EAAA7qC,IAAA0qC,EAEA,IAAAK,EACA,MAAAP,GAAAG,EAAAI,EAIAL,IAAA,EAEA,IAAA5Z,GAAA4Z,EAAApa,QAAA,KAAA,IAAA0a,aAEA,IAAAla,IAAAma,GAGA,MAFAT,GAAAG,EAAAM,EAAAna,IACA2Z,EAAAC,EAAAC,GACAA,CAIA,IAAA,MAAA7Z,EAAA9U,OAAA,GAAA,CA4BA,GAAAkvB,GAAApa,EAAAtmB,QAAA,KACA2gC,EAAAra,EAAAtmB,QAAA,IAEA,IAAA0gC,QAAAC,EAAA,IAAAra,EAAAhxB,OAAA,CACA,GAAAsrC,GAAAta,EAAA9Y,OAAA,EAAAkzB,GACAzpC,EAAAqvB,EAAA9Y,OAAAkzB,EAAA,EAAAC,GAAAD,EAAA,IAAAn8B,MAAA,KACAs8B,EAAA,CAEA,QAAAD,GACA,IAAA,OACA,GAAA,IAAA3pC,EAAA3B,OAEA,WADAwqC,GAAAK,EAAA,EAAA,EAAA,EAAA,EAIAU,GAAAlB,EAAA1oC,EAAA6pC,MAIA,KAAA,MACA,MAAA,KAAA7pC,EAAA3B,WACAwqC,GAAAK,EAAA,EAAA,EAAA,EAAA,IAIAL,EAAAK,EAAAT,EAAAzoC,EAAA,IAAAyoC,EAAAzoC,EAAA,IAAAyoC,EAAAzoC,EAAA,IAAA4pC,GACAZ,EAAAC,EAAAC,GACAA,EAEA,KAAA,OACA,MAAA,KAAAlpC,EAAA3B,WACAwqC,GAAAK,EAAA,EAAA,EAAA,EAAA,IAIAlpC,EAAA,GAAA0oC,EAAA1oC,EAAA,IACA8pC,EAAA9pC,EAAAkpC,GACAF,EAAAC,EAAAC,GACAA,EAEA,KAAA,MACA,MAAA,KAAAlpC,EAAA3B,WACAwqC,GAAAK,EAAA,EAAA,EAAA,EAAA,IAIAY,EAAA9pC,EAAAkpC,GACAF,EAAAC,EAAAC,GACAA,EAEA,SACA,QAIAL,EAAAK,EAAA,EAAA,EAAA,EAAA,OAnFA,CACA,GAAA,IAAA7Z,EAAAhxB,OAAA,CACA,GAAA0rC,GAAA14B,SAAAge,EAAA9Y,OAAA,GAAA,GAEA,OAAAwzB,IAAA,GAAAA,GAAA,MAKAlB,EAAAK,GAAA,KAAAa,IAAA,GAAA,KAAAA,IAAA,EAAA,IAAAA,GAAA,IAAAA,IAAA,EAAA,GAAAA,GAAA,GAAAA,IAAA,EAAA,GACAf,EAAAC,EAAAC,GACAA,OANAL,GAAAK,EAAA,EAAA,EAAA,EAAA,GAOK,GAAA,IAAA7Z,EAAAhxB,OAAA,CACL,GAAA0rC,GAAA14B,SAAAge,EAAA9Y,OAAA,GAAA,GAEA,OAAAwzB,IAAA,GAAAA,GAAA,UAKAlB,EAAAK,GAAA,SAAAa,IAAA,IAAA,MAAAA,IAAA,EAAA,IAAAA,EAAA,GACAf,EAAAC,EAAAC,GACAA,OANAL,GAAAK,EAAA,EAAA,EAAA,EAAA,MA6EA,QAAAY,GAAAE,EAAAtI,GACA,GAAA7G,IAAAtL,WAAAya,EAAA,IAAA,IAAA,KAAA,IAAA,IAIA/L,EAAAyK,EAAAsB,EAAA,IACAhP,EAAA0N,EAAAsB,EAAA,IACA3N,EAAArB,GAAA,GAAAA,GAAAiD,EAAA,GAAAjD,EAAAiD,EAAAjD,EAAAiD,EACA7B,EAAA,EAAApB,EAAAqB,CAQA,OAPAqF,GAAAA,MACAmH,EAAAnH,EAAA4G,EAAA,IAAAK,EAAAvM,EAAAC,EAAAxB,EAAA,EAAA,IAAAyN,EAAA,IAAAK,EAAAvM,EAAAC,EAAAxB,IAAAyN,EAAA,IAAAK,EAAAvM,EAAAC,EAAAxB,EAAA,EAAA,IAAA,GAEA,IAAAmP,EAAA3rC,SACAqjC,EAAA,GAAAsI,EAAA,IAGAtI,EAQA,QAAAuI,GAAAvI,GACA,GAAAA,EAAA,CAKA,GAUAwI,GACAC,EAXAC,EAAA1I,EAAA,GAAA,IACA2I,EAAA3I,EAAA,GAAA,IACA4I,EAAA5I,EAAA,GAAA,IACA6I,EAAAh/B,KAAA4Q,IAAAiuB,EAAAC,EAAAC,GAEAE,EAAAj/B,KAAA6Q,IAAAguB,EAAAC,EAAAC,GAEAG,EAAAD,EAAAD,EAEA7a,GAAA8a,EAAAD,GAAA,CAIA,IAAA,IAAAE,EACAP,EAAA,EACAC,EAAA,MACG,CAEHA,EADAza,EAAA,GACA+a,GAAAD,EAAAD,GAEAE,GAAA,EAAAD,EAAAD,EAGA,IAAAG,KAAAF,EAAAJ,GAAA,EAAAK,EAAA,GAAAA,EACAE,IAAAH,EAAAH,GAAA,EAAAI,EAAA,GAAAA,EACAG,IAAAJ,EAAAF,GAAA,EAAAG,EAAA,GAAAA,CAEAL,KAAAI,EACAN,EAAAU,EAAAD,EACKN,IAAAG,EACLN,EAAA,EAAA,EAAAQ,EAAAE,EACKN,IAAAE,IACLN,EAAA,EAAA,EAAAS,EAAAD,GAGAR,EAAA,IACAA,GAAA,GAGAA,EAAA,IACAA,GAAA,GAIA,GAAAF,IAAA,IAAAE,EAAAC,EAAAza,EAMA,OAJA,OAAAgS,EAAA,IACAsI,EAAAtoC,KAAAggC,EAAA,IAGAsI,GAUA,QAAAhoB,GAAAwE,EAAAqkB,GACA,GAAAC,GAAA3H,EAAA3c,EAEA,IAAAskB,EAAA,CACA,IAAA,GAAAvlC,GAAA,EAAmBA,EAAA,EAAOA,IAC1BslC,EAAA,EACAC,EAAAvlC,GAAAulC,EAAAvlC,IAAA,EAAAslC,GAAA,EAEAC,EAAAvlC,IAAA,IAAAulC,EAAAvlC,IAAAslC,EAAAC,EAAAvlC,GAAA,CAIA,OAAAiY,GAAAstB,EAAA,IAAAA,EAAAzsC,OAAA,OAAA,QAUA,QAAA0sC,GAAAvkB,GACA,GAAAskB,GAAA3H,EAAA3c,EAEA,IAAAskB,EACA,QAAA,GAAA,KAAAA,EAAA,IAAA,KAAAA,EAAA,IAAA,KAAAA,EAAA,IAAAvpB,SAAA,IAAAT,MAAA,GAYA,QAAAkqB,GAAAC,EAAAC,EAAAhP,GACA,GAAAgP,GAAAA,EAAA7sC,QAAA4sC,GAAA,GAAAA,GAAA,EAAA,CAIA/O,EAAAA,KACA,IAAA/9B,GAAA8sC,GAAAC,EAAA7sC,OAAA,GACA8sC,EAAA5/B,KAAAkW,MAAAtjB,GACAitC,EAAA7/B,KAAA8/B,KAAAltC,GACAmtC,EAAAJ,EAAAC,GACAI,EAAAL,EAAAE,GACAI,EAAArtC,EAAAgtC,CAKA,OAJAjP,GAAA,GAAAoM,EAAAM,EAAA0C,EAAA,GAAAC,EAAA,GAAAC,IACAtP,EAAA,GAAAoM,EAAAM,EAAA0C,EAAA,GAAAC,EAAA,GAAAC,IACAtP,EAAA,GAAAoM,EAAAM,EAAA0C,EAAA,GAAAC,EAAA,GAAAC,IACAtP,EAAA,GAAAsM,EAAAI,EAAA0C,EAAA,GAAAC,EAAA,GAAAC,IACAtP,GAiBA,QAAAoC,GAAA2M,EAAAC,EAAAO,GACA,GAAAP,GAAAA,EAAA7sC,QAAA4sC,GAAA,GAAAA,GAAA,EAAA,CAIA,GAAA9sC,GAAA8sC,GAAAC,EAAA7sC,OAAA,GACA8sC,EAAA5/B,KAAAkW,MAAAtjB,GACAitC,EAAA7/B,KAAA8/B,KAAAltC,GACAmtC,EAAAnI,EAAA+H,EAAAC,IACAI,EAAApI,EAAA+H,EAAAE,IACAI,EAAArtC,EAAAgtC,EACA3kB,EAAAhJ,GAAA8qB,EAAAM,EAAA0C,EAAA,GAAAC,EAAA,GAAAC,IAAAlD,EAAAM,EAAA0C,EAAA,GAAAC,EAAA,GAAAC,IAAAlD,EAAAM,EAAA0C,EAAA,GAAAC,EAAA,GAAAC,IAAAhD,EAAAI,EAAA0C,EAAA,GAAAC,EAAA,GAAAC,KAAA,OACA,OAAAC,IACAjlB,MAAAA,EACA2kB,UAAAA,EACAC,WAAAA,EACAjtC,MAAAA,GACGqoB,GAiBH,QAAAklB,GAAAllB,EAAAqU,EAAAoD,EAAAjD,GAGA,GAFAxU,EAAA2c,EAAA3c,GAOA,MAJAA,GAAAyjB,EAAAzjB,GACA,MAAAqU,IAAArU,EAAA,GAAA+hB,EAAA1N,IACA,MAAAoD,IAAAzX,EAAA,GAAAkiB,EAAAzK,IACA,MAAAjD,IAAAxU,EAAA,GAAAkiB,EAAA1N,IACAxd,EAAAssB,EAAAtjB,GAAA,QAWA,QAAAmlB,GAAAnlB,EAAAojB,GAGA,GAFApjB,EAAA2c,EAAA3c,GAEAA,GAAA,MAAAojB,EAEA,MADApjB,GAAA,GAAAgiB,EAAAoB,GACApsB,EAAAgJ,EAAA,QAUA,QAAAhJ,GAAAouB,EAAA5tC,GACA,GAAA4tC,GAAAA,EAAAvtC,OAAA,CAIA,GAAA4qC,GAAA2C,EAAA,GAAA,IAAAA,EAAA,GAAA,IAAAA,EAAA,EAMA,OAJA,SAAA5tC,GAAA,SAAAA,GAAA,SAAAA,IACAirC,GAAA,IAAA2C,EAAA,IAGA5tC,EAAA,IAAAirC,EAAA,KAhmBA,GAAA4C,GAAAzzC,EAAA,IAEAoxC,GACAsC,aAAA,EAAA,EAAA,EAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,cAAA,IAAA,IAAA,IAAA,GACAC,MAAA,EAAA,IAAA,IAAA,GACAC,YAAA,IAAA,IAAA,IAAA,GACAC,OAAA,IAAA,IAAA,IAAA,GACAC,OAAA,IAAA,IAAA,IAAA,GACAC,QAAA,IAAA,IAAA,IAAA,GACAC,OAAA,EAAA,EAAA,EAAA,GACAC,gBAAA,IAAA,IAAA,IAAA,GACAC,MAAA,EAAA,EAAA,IAAA,GACAC,YAAA,IAAA,GAAA,IAAA,GACAC,OAAA,IAAA,GAAA,GAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,WAAA,GAAA,IAAA,IAAA,GACAC,YAAA,IAAA,IAAA,EAAA,GACAC,WAAA,IAAA,IAAA,GAAA,GACAC,OAAA,IAAA,IAAA,GAAA,GACAC,gBAAA,IAAA,IAAA,IAAA,GACAC,UAAA,IAAA,IAAA,IAAA,GACAC,SAAA,IAAA,GAAA,GAAA,GACAC,MAAA,EAAA,IAAA,IAAA,GACAC,UAAA,EAAA,EAAA,IAAA,GACAC,UAAA,EAAA,IAAA,IAAA,GACAC,eAAA,IAAA,IAAA,GAAA,GACAC,UAAA,IAAA,IAAA,IAAA,GACAC,WAAA,EAAA,IAAA,EAAA,GACAC,UAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,aAAA,IAAA,EAAA,IAAA,GACAC,gBAAA,GAAA,IAAA,GAAA,GACAC,YAAA,IAAA,IAAA,EAAA,GACAC,YAAA,IAAA,GAAA,IAAA,GACAC,SAAA,IAAA,EAAA,EAAA,GACAC,YAAA,IAAA,IAAA,IAAA,GACAC,cAAA,IAAA,IAAA,IAAA,GACAC,eAAA,GAAA,GAAA,IAAA,GACAC,eAAA,GAAA,GAAA,GAAA,GACAC,eAAA,GAAA,GAAA,GAAA,GACAC,eAAA,EAAA,IAAA,IAAA,GACAC,YAAA,IAAA,EAAA,IAAA,GACAC,UAAA,IAAA,GAAA,IAAA,GACAC,aAAA,EAAA,IAAA,IAAA,GACAC,SAAA,IAAA,IAAA,IAAA,GACAC,SAAA,IAAA,IAAA,IAAA,GACAC,YAAA,GAAA,IAAA,IAAA,GACAC,WAAA,IAAA,GAAA,GAAA,GACAC,aAAA,IAAA,IAAA,IAAA,GACAC,aAAA,GAAA,IAAA,GAAA,GACAC,SAAA,IAAA,EAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,YAAA,IAAA,IAAA,IAAA,GACAC,MAAA,IAAA,IAAA,EAAA,GACAC,WAAA,IAAA,IAAA,GAAA,GACAC,MAAA,IAAA,IAAA,IAAA,GACAC,OAAA,EAAA,IAAA,EAAA,GACAC,aAAA,IAAA,IAAA,GAAA,GACAC,MAAA,IAAA,IAAA,IAAA,GACAC,UAAA,IAAA,IAAA,IAAA,GACAC,SAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,GAAA,GAAA,GACAC,QAAA,GAAA,EAAA,IAAA,GACAC,OAAA,IAAA,IAAA,IAAA,GACAC,OAAA,IAAA,IAAA,IAAA,GACAC,UAAA,IAAA,IAAA,IAAA,GACAC,eAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,EAAA,GACAC,cAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,YAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,sBAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,YAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,aAAA,IAAA,IAAA,IAAA,GACAC,eAAA,GAAA,IAAA,IAAA,GACAC,cAAA,IAAA,IAAA,IAAA,GACAC,gBAAA,IAAA,IAAA,IAAA,GACAC,gBAAA,IAAA,IAAA,IAAA,GACAC,gBAAA,IAAA,IAAA,IAAA,GACAC,aAAA,IAAA,IAAA,IAAA,GACAC,MAAA,EAAA,IAAA,EAAA,GACAC,WAAA,GAAA,IAAA,GAAA,GACAC,OAAA,IAAA,IAAA,IAAA,GACAC,SAAA,IAAA,EAAA,IAAA,GACAC,QAAA,IAAA,EAAA,EAAA,GACAC,kBAAA,IAAA,IAAA,IAAA,GACAC,YAAA,EAAA,EAAA,IAAA,GACAC,cAAA,IAAA,GAAA,IAAA,GACAC,cAAA,IAAA,IAAA,IAAA,GACAC,gBAAA,GAAA,IAAA,IAAA,GACAC,iBAAA,IAAA,IAAA,IAAA,GACAC,mBAAA,EAAA,IAAA,IAAA,GACAC,iBAAA,GAAA,IAAA,IAAA,GACAC,iBAAA,IAAA,GAAA,IAAA,GACAC,cAAA,GAAA,GAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,UAAA,IAAA,IAAA,IAAA,GACAC,aAAA,IAAA,IAAA,IAAA,GACAC,MAAA,EAAA,EAAA,IAAA,GACAC,SAAA,IAAA,IAAA,IAAA,GACAC,OAAA,IAAA,IAAA,EAAA,GACAC,WAAA,IAAA,IAAA,GAAA,GACAC,QAAA,IAAA,IAAA,EAAA,GACAC,WAAA,IAAA,GAAA,EAAA,GACAC,QAAA,IAAA,IAAA,IAAA,GACAC,eAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,eAAA,IAAA,IAAA,IAAA,GACAC,eAAA,IAAA,IAAA,IAAA,GACAC,YAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,MAAA,IAAA,IAAA,GAAA,GACAC,MAAA,IAAA,IAAA,IAAA,GACAC,MAAA,IAAA,IAAA,IAAA,GACAC,YAAA,IAAA,IAAA,IAAA,GACAC,QAAA,IAAA,EAAA,IAAA,GACAC,KAAA,IAAA,EAAA,EAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,WAAA,GAAA,IAAA,IAAA,GACAC,aAAA,IAAA,GAAA,GAAA,GACAC,QAAA,IAAA,IAAA,IAAA,GACAC,YAAA,IAAA,IAAA,GAAA,GACAC,UAAA,GAAA,IAAA,GAAA,GACAC,UAAA,IAAA,IAAA,IAAA,GACAC,QAAA,IAAA,GAAA,GAAA,GACAC,QAAA,IAAA,IAAA,IAAA,GACAC,SAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,GAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,MAAA,IAAA,IAAA,IAAA,GACAC,aAAA,EAAA,IAAA,IAAA,GACAC,WAAA,GAAA,IAAA,IAAA,GACAC,KAAA,IAAA,IAAA,IAAA,GACAC,MAAA,EAAA,IAAA,IAAA,GACAC,SAAA,IAAA,IAAA,IAAA,GACAC,QAAA,IAAA,GAAA,GAAA,GACAC,WAAA,GAAA,IAAA,IAAA,GACAC,QAAA,IAAA,IAAA,IAAA,GACAC,OAAA,IAAA,IAAA,IAAA,GACAC,OAAA,IAAA,IAAA,IAAA,GACAC,YAAA,IAAA,IAAA,IAAA,GACAC,QAAA,IAAA,IAAA,EAAA,GACAC,aAAA,IAAA,IAAA,GAAA,IAkFA7L,EAAA,GAAAyC,GAAA,IACA1C,EAAA,KA8RA+L,EAAAlK,EAkCAmK,EAAA7W,CA0DAxmC,GAAAqrC,MAAAA,EACArrC,EAAAkqB,KAAAA,EACAlqB,EAAAizC,MAAAA,EACAjzC,EAAAkzC,SAAAA,EACAlzC,EAAAo9C,eAAAA,EACAp9C,EAAAwmC,KAAAA,EACAxmC,EAAAq9C,WAAAA,EACAr9C,EAAA4zC,UAAAA,EACA5zC,EAAA6zC,YAAAA,EACA7zC,EAAA0lB,UAAAA,GrBgmRM,SAAUzlB,EAAQD,GsBrsSxB,GAAAs9C,GAAA,WAIAl9C,KAAAm9C,KAAA,KAKAn9C,KAAAo9C,KAAA,KACAp9C,KAAAq9C,KAAA,GAGAC,EAAAJ,EAAAh4C,SAOAo4C,GAAAC,OAAA,SAAAz7B,GACA,GAAA07B,GAAA,GAAAC,GAAA37B,EAEA,OADA9hB,MAAA09C,YAAAF,GACAA,GAQAF,EAAAI,YAAA,SAAAF,GACAx9C,KAAAm9C,MAGAn9C,KAAAo9C,KAAAO,KAAAH,EACAA,EAAAI,KAAA59C,KAAAo9C,KACAI,EAAAG,KAAA,KACA39C,KAAAo9C,KAAAI,GALAx9C,KAAAm9C,KAAAn9C,KAAAo9C,KAAAI,EAQAx9C,KAAAq9C,QAQAC,EAAA7tC,OAAA,SAAA+tC,GACA,GAAAI,GAAAJ,EAAAI,KACAD,EAAAH,EAAAG,IAEAC,GACAA,EAAAD,KAAAA,EAGA39C,KAAAm9C,KAAAQ,EAGAA,EACAA,EAAAC,KAAAA,EAGA59C,KAAAo9C,KAAAQ,EAGAJ,EAAAG,KAAAH,EAAAI,KAAA,KACA59C,KAAAq9C,QAOAC,EAAAltB,IAAA,WACA,MAAApwB,MAAAq9C,MAOAC,EAAAzzC,MAAA,WACA7J,KAAAm9C,KAAAn9C,KAAAo9C,KAAA,KACAp9C,KAAAq9C,KAAA,EAQA,IAAAI,GAAA,SAAA37B,GAIA9hB,KAAAiG,MAAA6b,EAKA9hB,KAAA29C,KAKA39C,KAAA49C,MASAjK,EAAA,SAAAkK,GACA79C,KAAA89C,MAAA,GAAAZ,GACAl9C,KAAA+9C,QACA/9C,KAAAg+C,SAAAH,GAAA,GACA79C,KAAAi+C,kBAAA,MAGAC,EAAAvK,EAAAzuC,SAOAg5C,GAAA/M,IAAA,SAAAnrC,EAAAC,GACA,GAAAk4C,GAAAn+C,KAAA89C,MACAt6B,EAAAxjB,KAAA+9C,KACAK,EAAA,IAEA,IAAA,MAAA56B,EAAAxd,GAAA,CACA,GAAAoqB,GAAA+tB,EAAA/tB,MAEAotB,EAAAx9C,KAAAi+C,iBAEA,IAAA7tB,GAAApwB,KAAAg+C,UAAA5tB,EAAA,EAAA,CAEA,GAAAiuB,GAAAF,EAAAhB,IACAgB,GAAA1uC,OAAA4uC,SACA76B,GAAA66B,EAAAr4C,KACAo4C,EAAAC,EAAAp4C,MACAjG,KAAAi+C,kBAAAI,EAGAb,EACAA,EAAAv3C,MAAAA,EAEAu3C,EAAA,GAAAC,GAAAx3C,GAGAu3C,EAAAx3C,IAAAA,EACAm4C,EAAAT,YAAAF,GACAh6B,EAAAxd,GAAAw3C,EAGA,MAAAY,IAQAF,EAAA73C,IAAA,SAAAL,GACA,GAAAw3C,GAAAx9C,KAAA+9C,KAAA/3C,GACAm4C,EAAAn+C,KAAA89C,KAEA,IAAA,MAAAN,EAOA,MALAA,KAAAW,EAAAf,OACAe,EAAA1uC,OAAA+tC,GACAW,EAAAT,YAAAF,IAGAA,EAAAv3C,OAQAi4C,EAAAr0C,MAAA,WACA7J,KAAA89C,MAAAj0C,QAEA7J,KAAA+9C,QAGA,IAAAphB,GAAAgX,CACA9zC,GAAAD,QAAA+8B,GtBktSM,SAAU98B,EAAQD,EAASM,GuB35SjC,GAAAo+C,GAAAp+C,EAAA,IAEAq+C,EAAAD,EAAAC,UAEA7X,EAAA,YAEA,KAAA6X,EACA7X,EAAA,WACA,IAAA,GAAA0H,KAAAloC,WACA,KAAA,IAAAyhB,OAAAzhB,UAAAkoC,KAGCmQ,EAAA,IACD7X,EAAA,WACA,IAAA,GAAA0H,KAAAloC,WACAs4C,QAAA9X,IAAAxgC,UAAAkoC,KAKA,IAAAzR,GAAA+J,CACA7mC,GAAAD,QAAA+8B,GvBi6SM,SAAU98B,EAAQD,GwBt7SxB,GAAA6jC,GAAA,CAEA,oBAAAj9B,UACAi9B,EAAApwB,KAAA6Q,IAAA1d,OAAAnE,kBAAA,EAAA,GAgBA,IAAAk8C,GAAA,EAEAl8C,EAAAohC,CACA7jC,GAAA2+C,UAAAA,EACA3+C,EAAAyC,iBAAAA,GxB47SM,SAAUxC,EAAQD,EAASM,GyBn9SjC,GAAAu+C,GAAAv+C,EAAA,IAEAssB,EAAAtsB,EAAA,IAMAw+C,EAAA,GAAAlyB,GAEAsQ,EAAA,YAEAA,GAAA53B,WACAqrB,YAAAuM,EAOA/B,aAAA,SAAA5C,EAAA3lB,GACA,GAAA3H,GAAA7K,KAAA6K,KACA2H,GAAA3H,EAAAiV,UAAAtN,EAEAxS,KAAAk6B,SAAAukB,EAAAE,mBAAA9zC,GAAA,EACA,IAAAE,GAAAF,EAAAE,IAIA,IAFA,MAAAA,IAAAA,GAAA,IAEA0zC,EAAAG,aAAA7zC,EAAAF,GAAA,CAKAstB,EAAA0mB,MAEA,IAAArvB,GAAAxvB,KAAAwvB,SAEA3kB,GAAA60B,cAOA1/B,KAAAi6B,aAAA9B,GANA3I,IACAkvB,EAAApjB,KAAA9oB,GACAksC,EAAArxB,eAAAmC,GACAhd,EAAAksC,GAOAD,EAAAK,WAAA9+C,KAAAm4B,EAAAptB,EAAAF,EAAA2H,GACA2lB,EAAA4mB,YAGA,IAAApiB,GAAAG,CACAj9B,GAAAD,QAAA+8B,GzBy9SM,SAAU98B,EAAQD,EAASM,G0Bh/SjC,QAAAy+C,GAAA9zC,GAGA,MAFAm0C,GAAAn0C,GACAhC,EAAAgC,EAAAq1B,KAAA8e,GACAn0C,EAGA,QAAAm0C,GAAAn0C,GACA,GAAAA,EAAA,CACAA,EAAAwzB,KAAA15B,EAAAs6C,SAAAp0C,EACA,IAAAsW,GAAAtW,EAAAsW,SACA,YAAAA,IAAAA,EAAA,UACAtW,EAAAsW,UAAA,MAAAA,GAAA+9B,EAAA/9B,GAAAA,EAAA,MAEA,IAAA8d,GAAAp0B,EAAAo0B,mBAAAp0B,EAAAiY,YACA,YAAAmc,IAAAA,EAAA,UACAp0B,EAAAo0B,kBAAA,MAAAA,GAAAkgB,EAAAlgB,GAAAA,EAAA,KACA,IAAAgB,GAAAp1B,EAAAo1B,WAEAA,KACAp1B,EAAAo1B,YAAA/M,EAAAroB,EAAAo1B,eAaA,QAAA6e,GAAAM,EAAAjnB,EAAAptB,EAAAF,EAAA2H,GACA3H,EAAAq1B,KAAAmf,EAAAD,EAAAjnB,EAAAptB,EAAAF,EAAA2H,GAAA8sC,EAAAF,EAAAjnB,EAAAptB,EAAAF,EAAA2H,GAGA,QAAA8sC,GAAAF,EAAAjnB,EAAAptB,EAAAF,EAAA2H,GACA,GAAA6rB,GAAAkhB,EAAApnB,EAAA,OAAAttB,EAAAwzB,MAAA15B,EAAA66C,cACAvf,EAAAp1B,EAAAo1B,YACAwf,EAAAL,EAAAM,iBAEAD,KAAAL,EAAAllB,UACAulB,EAAAL,EAAAM,kBAAA/6C,EAAAg7C,eAAA50C,EAAAszB,EAAA4B,EAAAp1B,EAAAs1B,UAGA,IAAAyf,GAAAH,EAAAG,YACAC,EAAAJ,EAAAhkC,MACA2E,EAAAq/B,EAAAr/B,WACA0/B,EAAAC,EAAAH,EAAA/0C,EAAA2H,GACAwtC,EAAAF,EAAAE,MACAC,EAAAH,EAAAG,MACA9+B,EAAA2+B,EAAA3+B,UACA8d,EAAA6gB,EAAA7gB,iBAEAihB,GAAA/nB,EAAAttB,EAAA2H,EAAAwtC,EAAAC,EACA,IAAAE,GAAAx7C,EAAAy7C,YAAAH,EAAAL,EAAA3gB,GACAohB,EAAAL,EACAM,EAAAH,EACAI,EAAAC,EAAA31C,EAEA,IAAA01C,GAAAtgB,EAAA,CAEA,GAAArB,GAAAj6B,EAAAU,SAAA0F,EAAAszB,GACAoiB,EAAA7hB,CACAqB,KAAAwgB,GAAAxgB,EAAA,GAAAA,EAAA,GACA,IAAAygB,GAAA/7C,EAAAg8C,YAAAX,EAAAS,EAAAt/B,EACAo/B,IAAAK,EAAAxB,EAAAjnB,EAAAttB,EAAA61C,EAAAP,EAAAM,EAAAb,GAEA3f,IACAogB,EAAAQ,EAAAb,EAAA7+B,EAAA8e,GACAqgB,GAAArgB,EAAA,IAIAsf,EAAApnB,EAAA,YAAAhX,GAAA,QAGAo+B,EAAApnB,EAAA,eAAA,UAEAonB,EAAApnB,EAAA,aAAAttB,EAAAs0B,gBAAA,GACAogB,EAAApnB,EAAA,cAAAttB,EAAAq0B,iBAAA,eACAqgB,EAAApnB,EAAA,gBAAAttB,EAAAu0B,mBAAA,GACAmgB,EAAApnB,EAAA,gBAAAttB,EAAAw0B,mBAAA,GAEAihB,GAAAlgC,EAAA,CACA,IAAA0e,GAAAj0B,EAAAi0B,gBACAH,EAAAmiB,EAAAj2C,EAAA8zB,WAAAG,GACAjc,EAAAk+B,EAAAl2C,EAAAgY,SAEA8b,KACA4gB,EAAApnB,EAAA,YAAA2G,GACAygB,EAAApnB,EAAA,cAAAwG,IAGA9b,GACA08B,EAAApnB,EAAA,YAAAtV,EAGA,KAAA,GAAAxV,GAAA,EAAiBA,EAAAwyC,EAAA15C,OAAsBkH,IAEvCsxB,GAAAxG,EAAA6oB,WAAAnB,EAAAxyC,GAAAgzC,EAAAC,GACAz9B,GAAAsV,EAAA8oB,SAAApB,EAAAxyC,GAAAgzC,EAAAC,GACAA,GAAAlgC,EAIA,QAAAi/B,GAAAD,EAAAjnB,EAAAptB,EAAAF,EAAA2H,GACA,GAAAitC,GAAAL,EAAAM,iBAEAD,KAAAL,EAAAllB,UACAulB,EAAAL,EAAAM,kBAAA/6C,EAAAu8C,cAAAn2C,EAAAF,IAGAs2C,EAAA/B,EAAAjnB,EAAAsnB,EAAA50C,EAAA2H,GAGA,QAAA2uC,GAAA/B,EAAAjnB,EAAAsnB,EAAA50C,EAAA2H,GACA,GAAA4uC,GAAA3B,EAAAxwC,MACAwxC,EAAAhB,EAAAgB,WACAb,EAAAH,EAAAG,YACA3f,EAAAp1B,EAAAo1B,YACA6f,EAAAC,EAAAH,EAAA/0C,EAAA2H,GACAwtC,EAAAF,EAAAE,MACAC,EAAAH,EAAAG,MACA9+B,EAAA2+B,EAAA3+B,UACA8d,EAAA6gB,EAAA7gB,iBAEAihB,GAAA/nB,EAAAttB,EAAA2H,EAAAwtC,EAAAC,EACA,IAAAS,GAAA/7C,EAAAg8C,YAAAX,EAAAS,EAAAt/B,GACAg/B,EAAAx7C,EAAAy7C,YAAAH,EAAAL,EAAA3gB,GACAoiB,EAAAX,EACAY,EAAAnB,CAEAlgB,KACAohB,GAAAphB,EAAA,GACAqhB,GAAArhB,EAAA,GAGA,IAAAshB,GAAAF,EAAAD,CACAZ,GAAA31C,IAAA+1C,EAAAxB,EAAAjnB,EAAAttB,EAAA61C,EAAAP,EAAAM,EAAAb,EAEA,KAAA,GAAAvyC,GAAA,EAAiBA,EAAAoyC,EAAAhkC,MAAAtV,OAA+BkH,IAAA,CAYhD,IAXA,GASAm0C,GATAl1C,EAAAmzC,EAAAhkC,MAAApO,GACAo0C,EAAAn1C,EAAAm1C,OACAC,EAAAD,EAAAt7C,OACAia,EAAA9T,EAAA8T,WACAuhC,EAAAr1C,EAAA2C,MACAgkC,EAAA,EACA2O,EAAAP,EACAQ,EAAAN,EACArO,EAAAwO,EAAA,EAGAzO,EAAAyO,IAAAF,EAAAC,EAAAxO,IAAAuO,EAAArgC,WAAA,SAAAqgC,EAAArgC,YACA2gC,EAAA1C,EAAAjnB,EAAAqpB,EAAA32C,EAAAuV,EAAAkhC,EAAAM,EAAA,QACAD,GAAAH,EAAAvyC,MACA2yC,GAAAJ,EAAAvyC,MACAgkC,GAGA,MAAAC,GAAA,IAAAsO,EAAAC,EAAAvO,GAAA,UAAAsO,EAAArgC,YACA2gC,EAAA1C,EAAAjnB,EAAAqpB,EAAA32C,EAAAuV,EAAAkhC,EAAAO,EAAA,SACAF,GAAAH,EAAAvyC,MACA4yC,GAAAL,EAAAvyC,MACAikC,GAMA,KAFA0O,IAAAR,GAAAQ,EAAAP,IAAAE,EAAAM,GAAAF,GAAA,EAEA1O,GAAAC,GACAsO,EAAAC,EAAAxO,GAEA6O,EAAA1C,EAAAjnB,EAAAqpB,EAAA32C,EAAAuV,EAAAkhC,EAAAM,EAAAJ,EAAAvyC,MAAA,EAAA,UACA2yC,GAAAJ,EAAAvyC,MACAgkC,GAGAqO,IAAAlhC,GAIA,QAAA8/B,GAAA/nB,EAAAttB,EAAA2H,EAAAf,EAAAE,GAEA,GAAAa,GAAA3H,EAAA80B,aAAA,CACA,GAAAzrB,GAAArJ,EAAA+0B,UAEA,YAAA1rB,GACAzC,EAAAe,EAAAvD,MAAA,EAAAuD,EAAAf,EACAE,EAAAa,EAAAtD,OAAA,EAAAsD,EAAAb,GACKuC,IACLzC,EAAAyC,EAAA,GAAA1B,EAAAf,EACAE,EAAAuC,EAAA,GAAA1B,EAAAb,GAGAwmB,EAAAuM,UAAAjzB,EAAAE,GAEAwmB,EAAA4L,QAAAl5B,EAAA80B,cACAxH,EAAAuM,WAAAjzB,GAAAE,IAIA,QAAAmwC,GAAA1C,EAAAjnB,EAAAqpB,EAAA32C,EAAAuV,EAAAkhC,EAAA7vC,EAAA0P,GACA,GAAA4gC,GAAAl3C,EAAAq1B,KAAAshB,EAAAjhB,eAGAtB,EAAAuiB,EAAAviB,kBACAttB,EAAA2vC,EAAAlhC,EAAA,CAEA,SAAA6e,EACAttB,EAAA2vC,EAAAE,EAAAtyC,OAAA,EACG,WAAA+vB,IACHttB,EAAA2vC,EAAAlhC,EAAAohC,EAAAtyC,OAAA,IAGAsyC,EAAAQ,cAAAxB,EAAAuB,IAAAnB,EAAAxB,EAAAjnB,EAAA4pB,EAAA,UAAA5gC,EAAA1P,EAAA+vC,EAAAvyC,MAAA,WAAAkS,EAAA1P,EAAA+vC,EAAAvyC,MAAA,EAAAwC,EAAAE,EAAA6vC,EAAAtyC,OAAA,EAAAsyC,EAAAvyC,MAAAuyC,EAAAtyC,OACA,IAAA+wB,GAAAuhB,EAAAvhB,WAEAA,KACAxuB,EAAAovC,EAAApvC,EAAA0P,EAAA8e,GACAtuB,GAAA6vC,EAAAtyC,OAAA,EAAA+wB,EAAA,GAAAuhB,EAAA3iB,WAAA,GAGA0gB,EAAApnB,EAAA,aAAAnF,EAAA+uB,EAAA5iB,eAAAt0B,EAAAs0B,eAAA,IACAogB,EAAApnB,EAAA,cAAA4pB,EAAA7iB,iBAAAr0B,EAAAq0B,iBAAA;AACAqgB,EAAApnB,EAAA,gBAAAnF,EAAA+uB,EAAA3iB,kBAAAv0B,EAAAu0B,kBAAA,IACAmgB,EAAApnB,EAAA,gBAAAnF,EAAA+uB,EAAA1iB,kBAAAx0B,EAAAw0B,kBAAA,IACAkgB,EAAApnB,EAAA,YAAAhX,GAGAo+B,EAAApnB,EAAA,eAAA,UACAonB,EAAApnB,EAAA,OAAAqpB,EAAAnjB,MAAA15B,EAAA66C,aACA,IAAA7gB,GAAAmiB,EAAAiB,EAAApjB,YAAA9zB,EAAA8zB,WAAAG,GACAjc,EAAAk+B,EAAAgB,EAAAl/B,UAAAhY,EAAAgY,UACAic,EAAAjM,EAAAkvB,EAAAjjB,gBAAAj0B,EAAAi0B,gBAEAH,KACA4gB,EAAApnB,EAAA,YAAA2G,GACAygB,EAAApnB,EAAA,cAAAwG,GACAxG,EAAA6oB,WAAAQ,EAAAz2C,KAAA0G,EAAAE,IAGAkR,IACA08B,EAAApnB,EAAA,YAAAtV,GACAsV,EAAA8oB,SAAAO,EAAAz2C,KAAA0G,EAAAE,IAIA,QAAA6uC,GAAA31C,GACA,MAAAA,GAAAg1B,qBAAAh1B,EAAAk1B,iBAAAl1B,EAAAi1B,gBAKA,QAAA8gB,GAAAxB,EAAAjnB,EAAAttB,EAAA4G,EAAAE,EAAA1C,EAAAC,GACA,GAAA2wB,GAAAh1B,EAAAg1B,oBACAE,EAAAl1B,EAAAk1B,gBACAD,EAAAj1B,EAAAi1B,gBACAmiB,EAAA1vB,EAAAsN,EAMA,IALA0f,EAAApnB,EAAA,aAAAttB,EAAA00B,mBAAA,GACAggB,EAAApnB,EAAA,cAAAttB,EAAAy0B,oBAAA,eACAigB,EAAApnB,EAAA,gBAAAttB,EAAA20B,sBAAA,GACA+f,EAAApnB,EAAA,gBAAAttB,EAAA40B,sBAAA,GAEAwiB,GAAAliB,GAAAD,EAAA,CACA3H,EAAAyC,WACA,IAAAoF,GAAAn1B,EAAAm1B,gBAEAA,GAGAkiB,EAAAjqB,UAAAE,GACA1mB,EAAAA,EACAE,EAAAA,EACA1C,MAAAA,EACAC,OAAAA,EACA0C,EAAAouB,IAPA7H,EAAA3lB,KAAAf,EAAAE,EAAA1C,EAAAC,GAWAipB,EAAAgqB,YAGA,GAAAF,EACA1C,EAAApnB,EAAA,YAAA0H,GACA1H,EAAAtmB,WACG,IAAA+e,EAAAiP,GAAA,CACH,GAAA/0B,GAAA+0B,EAAA/0B,KACAA,GAAAs3C,EAAAC,oBAAAv3C,EAAA,KAAAs0C,EAAAkD,EAAAziB,GAEA/0B,GAAAs3C,EAAAG,aAAAz3C,IACAqtB,EAAAqqB,UAAA13C,EAAA2G,EAAAE,EAAA1C,EAAAC,GAIA6wB,GAAAD,IACAyf,EAAApnB,EAAA,YAAA4H,GACAwf,EAAApnB,EAAA,cAAA2H,GACA3H,EAAArmB,UAIA,QAAAwwC,GAAAx3C,EAAA+0B,GAGAA,EAAA/0B,MAAAA,EAGA,QAAAi1C,GAAA0C,EAAA53C,EAAA2H,GACA,GAAAwtC,GAAAn1C,EAAA4G,GAAA,EACAwuC,EAAAp1C,EAAA8G,GAAA,EACAwP,EAAAtW,EAAAsW,UACA8d,EAAAp0B,EAAAo0B,iBAEA,IAAAzsB,EAAA,CACA,GAAAxH,GAAAH,EAAAG,YAEA,IAAAA,YAAAoO,OAEA4mC,EAAAxtC,EAAAf,EAAAixC,EAAA13C,EAAA,GAAAwH,EAAAvD,OACAgxC,EAAAztC,EAAAb,EAAA+wC,EAAA13C,EAAA,GAAAwH,EAAAtD,YACK,CACL,GAAAiF,GAAAxP,EAAAg+C,yBAAA33C,EAAAwH,EAAA3H,EAAA8jB,aACAqxB,GAAA7rC,EAAA1C,EACAwuC,EAAA9rC,EAAAxC,EAEAwP,EAAAA,GAAAhN,EAAAgN,UACA8d,EAAAA,GAAA9qB,EAAA8qB,kBAKA,GAAAD,GAAAn0B,EAAAm0B,UAEAA,KACAghB,GAAAhhB,EAAA,GACAihB,GAAAjhB,EAAA,IAIA,OACAghB,MAAAA,EACAC,MAAAA,EACA9+B,UAAAA,EACA8d,kBAAAA,GAIA,QAAAsgB,GAAApnB,EAAAzG,EAAAzrB,GAMA,MAFAkyB,GAAAzG,GAAAzrB,EAEAkyB,EAAAzG,GASA,QAAAovB,GAAAhvC,EAAAgE,GACA,MAAA,OAAAhE,GAAAgE,GAAA,GAAA,gBAAAhE,GAAA,SAAAA,EAAA,KACAA,EAAAhH,OAAAgH,EAAA+nB,WAAA,OAAA/nB,EAGA,QAAAivC,GAAAlvC,GACA,MAAA,OAAAA,GAAA,SAAAA,EAAA,KACAA,EAAA/G,OAAA+G,EAAAgoB,WAAA,OAAAhoB,EAGA,QAAA6wC,GAAAz8C,EAAA28C,GACA,MAAA,gBAAA38C,GACAA,EAAA48C,YAAA,MAAA,EACAxrB,WAAApxB,GAAA,IAAA28C,EAGAvrB,WAAApxB,GAGAA,EAGA,QAAA46C,GAAApvC,EAAA0P,EAAA8e,GACA,MAAA,UAAA9e,EAAA1P,EAAAwuB,EAAA,GAAA,WAAA9e,EAAA1P,EAAAwuB,EAAA,GAAA,EAAAA,EAAA,GAAA,EAAAxuB,EAAAwuB,EAAA,GASA,QAAA2e,GAAA7zC,EAAAF,GACA,MAAA,OAAAE,IAAAA,GAAAF,EAAAg1B,qBAAAh1B,EAAAk1B,iBAAAl1B,EAAAi1B,iBAAAj1B,EAAAo1B,aA3aA,GAAA0G,GAAAzmC,EAAA,GAEA2yB,EAAA8T,EAAA9T,UACAG,EAAA2T,EAAA3T,UACAnqB,EAAA89B,EAAA99B,KACAqqB,EAAAyT,EAAAzT,kBACAX,EAAAoU,EAAApU,SACA3B,EAAA+V,EAAA/V,SAEAjsB,EAAAzE,EAAA,IAEAgiD,EAAAhiD,EAAA,IAEAkiD,EAAAliD,EAAA,IAGAg/C,GACAtsC,KAAA,EACAC,MAAA,EACAmF,OAAA,GAEAmnC,GACArsC,IAAA,EACAC,OAAA,EACA+vC,OAAA,EAsZAljD,GAAA++C,mBAAAA,EACA/+C,EAAAk/C,WAAAA,EACAl/C,EAAAkhD,UAAAA,EACAlhD,EAAAmhD,QAAAA,EACAnhD,EAAAg/C,aAAAA,G1BqhTM,SAAU/+C,EAAQD,EAASM,G2Br7TjC,QAAA4vB,GAAAznB,EAAA0nB,GACAC,EAAA3nB,GAAA0nB,EAUA,QAAA1qB,GAAA0F,EAAAszB,GACAA,EAAAA,GAAAmhB,CACA,IAAAx5C,GAAA+E,EAAA,IAAAszB,CAEA,IAAA0kB,EAAA/8C,GACA,MAAA+8C,GAAA/8C,EAMA,KAAA,GAHA65C,IAAA90C,EAAA,IAAAqK,MAAA,MACAnG,EAAA,EAEA5B,EAAA,EAAAy1B,EAAA+c,EAAA15C,OAAuCkH,EAAAy1B,EAAOz1B,IAE9C4B,EAAAoE,KAAA6Q,IAAA8+B,EAAAnD,EAAAxyC,GAAAgxB,GAAApvB,MAAAA,EAUA,OAPAg0C,GAAAC,IACAD,EAAA,EACAF,MAGAE,IACAF,EAAA/8C,GAAAiJ,EACAA,EAeA,QAAAE,GAAApE,EAAAszB,EAAAld,EAAA8d,EAAAgB,EAAAC,EAAAC,GACA,MAAAD,GAAAijB,EAAAp4C,EAAAszB,EAAAld,EAAA8d,EAAAgB,EAAAC,EAAAC,GAAAijB,EAAAr4C,EAAAszB,EAAAld,EAAA8d,EAAAgB,EAAAE,GAGA,QAAAijB,GAAAr4C,EAAAszB,EAAAld,EAAA8d,EAAAgB,EAAAE,GACA,GAAAsf,GAAAE,EAAA50C,EAAAszB,EAAA4B,EAAAE,GACAsgB,EAAAp7C,EAAA0F,EAAAszB,EAEA4B,KACAwgB,GAAAxgB,EAAA,GAAAA,EAAA,GAGA,IAAA2f,GAAAH,EAAAG,YACAnuC,EAAAkvC,EAAA,EAAAF,EAAAt/B,GACAxP,EAAAyuC,EAAA,EAAAR,EAAA3gB,GACAzsB,EAAA,GAAAga,GAAA/a,EAAAE,EAAA8uC,EAAAb,EAEA,OADAptC,GAAA4N,WAAAq/B,EAAAr/B,WACA5N,EAGA,QAAA2wC,GAAAp4C,EAAAszB,EAAAld,EAAA8d,EAAAgB,EAAAC,EAAAC,GACA,GAAAsf,GAAAyB,EAAAn2C,GACAm1B,KAAAA,EACAC,SAAAA,EACA9B,KAAAA,EACAld,UAAAA,EACA8e,YAAAA,IAEAwgB,EAAAhB,EAAAgB,WACAb,EAAAH,EAAAG,YACAnuC,EAAAkvC,EAAA,EAAAF,EAAAt/B,GACAxP,EAAAyuC,EAAA,EAAAR,EAAA3gB,EACA,OAAA,IAAAzS,GAAA/a,EAAAE,EAAA8uC,EAAAb,GAWA,QAAAe,GAAAlvC,EAAAxC,EAAAkS,GAQA,MANA,UAAAA,EACA1P,GAAAxC,EACG,WAAAkS,IACH1P,GAAAxC,EAAA,GAGAwC,EAWA,QAAA2uC,GAAAzuC,EAAAzC,EAAA+vB,GAOA,MANA,WAAAA,EACAttB,GAAAzC,EAAA,EACG,WAAA+vB,IACHttB,GAAAzC,GAGAyC,EAWA,QAAAgxC,GAAA33C,EAAAwH,EAAAkS,GACA,GAAAjT,GAAAe,EAAAf,EACAE,EAAAa,EAAAb,EACAzC,EAAAsD,EAAAtD,OACAD,EAAAuD,EAAAvD,MACAo0C,EAAAn0C,EAAA,EACAiS,EAAA,OACA8d,EAAA,KAEA,QAAAj0B,GACA,IAAA,OACAyG,GAAAiT,EACA/S,GAAA0xC,EACAliC,EAAA,QACA8d,EAAA,QACA,MAEA,KAAA,QACAxtB,GAAAiT,EAAAzV,EACA0C,GAAA0xC,EACApkB,EAAA,QACA,MAEA,KAAA,MACAxtB,GAAAxC,EAAA,EACA0C,GAAA+S,EACAvD,EAAA,SACA8d,EAAA,QACA,MAEA,KAAA,SACAxtB,GAAAxC,EAAA,EACA0C,GAAAzC,EAAAwV,EACAvD,EAAA,QACA,MAEA,KAAA,SACA1P,GAAAxC,EAAA,EACA0C,GAAA0xC,EACAliC,EAAA,SACA8d,EAAA,QACA,MAEA,KAAA,aACAxtB,GAAAiT,EACA/S,GAAA0xC,EACApkB,EAAA,QACA,MAEA,KAAA,cACAxtB,GAAAxC,EAAAyV,EACA/S,GAAA0xC,EACAliC,EAAA,QACA8d,EAAA,QACA,MAEA,KAAA,YACAxtB,GAAAxC,EAAA,EACA0C,GAAA+S,EACAvD,EAAA,QACA,MAEA,KAAA,eACA1P,GAAAxC,EAAA,EACA0C,GAAAzC,EAAAwV,EACAvD,EAAA,SACA8d,EAAA,QACA,MAEA,KAAA,gBACAxtB,GAAAiT,EACA/S,GAAA+S,CACA,MAEA,KAAA,iBACAjT,GAAAxC,EAAAyV,EACA/S,GAAA+S,EACAvD,EAAA,OACA,MAEA,KAAA,mBACA1P,GAAAiT,EACA/S,GAAAzC,EAAAwV,EACAua,EAAA,QACA,MAEA,KAAA,oBACAxtB,GAAAxC,EAAAyV,EACA/S,GAAAzC,EAAAwV,EACAvD,EAAA,QACA8d,EAAA,SAIA,OACAxtB,EAAAA,EACAE,EAAAA,EACAwP,UAAAA,EACA8d,kBAAAA,GAqBA,QAAAqkB,GAAAv4C,EAAAw4C,EAAAllB,EAAAmlB,EAAApgD,GACA,IAAAmgD,EACA,MAAA,EAGA,IAAA1D,IAAA90C,EAAA,IAAAqK,MAAA,KACAhS,GAAAqgD,EAAAF,EAAAllB,EAAAmlB,EAAApgD,EAGA,KAAA,GAAAiK,GAAA,EAAA+iB,EAAAyvB,EAAA15C,OAAyCkH,EAAA+iB,EAAS/iB,IAClDwyC,EAAAxyC,GAAAq2C,EAAA7D,EAAAxyC,GAAAjK,EAGA,OAAAy8C,GAAApW,KAAA,MAGA,QAAAga,GAAAF,EAAAllB,EAAAmlB,EAAApgD,GACAA,EAAA0hB,KAAqB1hB,GACrBA,EAAAi7B,KAAAA,CACA,IAAAmlB,GAAA3wB,EAAA2wB,EAAA,MACApgD,GAAAugD,cAAA9wB,EAAAzvB,EAAAugD,cAAA,EACA,IAAAC,GAAAxgD,EAAAwgD,QAAA/wB,EAAAzvB,EAAAwgD,QAAA,EAGAxgD,GAAAygD,YAAAx+C,EAAA,IAAAg5B,EAGA,IAAAylB,GAAA1gD,EAAA0gD,aAAAz+C,EAAA,IAAAg5B,EACAj7B,GAAA2gD,YAAAlxB,EAAAzvB,EAAA2gD,YAAA,GAKA,KAAA,GAFA3C,GAAAmC,EAAAlwC,KAAA6Q,IAAA,EAAAq/B,EAAA,GAEAl2C,EAAA,EAAiBA,EAAAu2C,GAAAxC,GAAA0C,EAA6Cz2C,IAC9D+zC,GAAA0C,CAGA,IAAAE,GAAA3+C,EAAAm+C,EAYA,OAVAQ,GAAA5C,IACAoC,EAAA,GACAQ,EAAA,GAGA5C,EAAAmC,EAAAS,EACA5gD,EAAAogD,SAAAA,EACApgD,EAAA4gD,cAAAA,EACA5gD,EAAAg+C,aAAAA,EACAh+C,EAAAmgD,eAAAA,EACAngD,EAGA,QAAAsgD,GAAAO,EAAA7gD,GACA,GAAAmgD,GAAAngD,EAAAmgD,eACAllB,EAAAj7B,EAAAi7B,KACA+iB,EAAAh+C,EAAAg+C,YAEA,KAAAmC,EACA,MAAA,EAGA,IAAAztC,GAAAzQ,EAAA4+C,EAAA5lB,EAEA,IAAAvoB,GAAAytC,EACA,MAAAU,EAGA,KAAA,GAAAtmC,GAAA,GAAkBA,IAAA,CAClB,GAAA7H,GAAAsrC,GAAAzjC,GAAAva,EAAAugD,cAAA,CACAM,GAAA7gD,EAAAogD,QACA,OAGA,GAAAU,GAAA,IAAAvmC,EAAAwmC,EAAAF,EAAA7C,EAAAh+C,EAAA0gD,aAAA1gD,EAAAygD,aAAA/tC,EAAA,EAAAzC,KAAAkW,MAAA06B,EAAA99C,OAAAi7C,EAAAtrC,GAAA,CACAmuC,GAAAA,EAAA5lC,OAAA,EAAA6lC,GACApuC,EAAAzQ,EAAA4+C,EAAA5lB,GAOA,MAJA,KAAA4lB,IACAA,EAAA7gD,EAAA2gD,aAGAE,EAGA,QAAAE,GAAAp5C,EAAAq2C,EAAA0C,EAAAD,GAIA,IAAA,GAHA50C,GAAA,EACA5B,EAAA,EAEA+iB,EAAArlB,EAAA5E,OAA6BkH,EAAA+iB,GAAAnhB,EAAAmyC,EAAiC/zC,IAAA,CAC9D,GAAA+2C,GAAAr5C,EAAAs5C,WAAAh3C,EACA4B,IAAA,GAAAm1C,GAAAA,GAAA,IAAAN,EAAAD,EAGA,MAAAx2C,GASA,QAAAi3C,GAAAjmB,GAEA,MAAAh5B,GAAA,IAAAg5B,GAUA,QAAA2kB,GAAAj4C,EAAAszB,GACA,MAAArO,GAAAgzB,YAAAj4C,EAAAszB,GAmBA,QAAAshB,GAAA50C,EAAAszB,EAAAhvB,EAAA8wB,GACA,MAAAp1B,IAAAA,GAAA,GACA,IAAAqV,GAAAkkC,EAAAjmB,GACA5iB,EAAA1Q,EAAAA,EAAAqK,MAAA,SACAlG,EAAAuM,EAAAtV,OAAAia,EACAw/B,EAAA1wC,CAMA,IAJAG,IACAuwC,GAAAvwC,EAAA,GAAAA,EAAA,IAGAtE,GAAAo1B,EAAA,CACA,GAAAokB,GAAApkB,EAAAyf,YACA4E,EAAArkB,EAAAsgB,UAEA,IAAA,MAAA8D,GAAA3E,EAAA2E,EACAx5C,EAAA,GACA0Q,SACK,IAAA,MAAA+oC,EAOL,IAAA,GANAphD,GAAAqgD,EAAAe,GAAAn1C,EAAAA,EAAA,GAAAA,EAAA,GAAA,GAAAgvB,EAAA8B,EAAAqjB,UACAI,QAAAzjB,EAAAyjB,QACAG,YAAA5jB,EAAA4jB,cAIA12C,EAAA,EAAA+iB,EAAA3U,EAAAtV,OAAyCkH,EAAA+iB,EAAS/iB,IAClDoO,EAAApO,GAAAq2C,EAAAjoC,EAAApO,GAAAjK,GAKA,OACAqY,MAAAA,EACAvM,OAAAA,EACA0wC,YAAAA,EACAx/B,WAAAA,GAmCA,QAAA8gC,GAAAn2C,EAAAF,GACA,GAAA40C,IACAhkC,SACAxM,MAAA,EACAC,OAAA,EAIA,IAFA,MAAAnE,IAAAA,GAAA,KAEAA,EACA,MAAA00C,EAMA,KAHA,GACA59B,GADA2H,EAAAi7B,EAAAj7B,UAAA,EAGA,OAAA3H,EAAA4iC,EAAAC,KAAA35C,KAAA,CACA,GAAA45C,GAAA9iC,EAAAjR,KAEA+zC,GAAAn7B,GACAo7B,EAAAnF,EAAA10C,EAAAyX,UAAAgH,EAAAm7B,IAGAC,EAAAnF,EAAA59B,EAAA,GAAAA,EAAA,IACA2H,EAAAi7B,EAAAj7B,UAGAA,EAAAze,EAAA5E,QACAy+C,EAAAnF,EAAA10C,EAAAyX,UAAAgH,EAAAze,EAAA5E,QAGA,IAAAsV,GAAAgkC,EAAAhkC,MACAopC,EAAA,EACAzD,EAAA,EAEA0D,KACAC,EAAAl6C,EAAAo1B,YACAE,EAAAt1B,EAAAs1B,SACA6kB,EAAA7kB,GAAAA,EAAAsgB,WACAwE,EAAA9kB,GAAAA,EAAAyf,WAEAmF,KACA,MAAAC,IAAAA,GAAAD,EAAA,GAAAA,EAAA,IACA,MAAAE,IAAAA,GAAAF,EAAA,GAAAA,EAAA,IAIA,KAAA,GAAA13C,GAAA,EAAiBA,EAAAoO,EAAAtV,OAAkBkH,IAAA,CAKnC,IAAA,GAJAf,GAAAmP,EAAApO,GACA+S,EAAA,EACAtK,EAAA,EAEA6H,EAAA,EAAmBA,EAAArR,EAAAm1C,OAAAt7C,OAAwBwX,IAAA,CAC3C,GAAA6jC,GAAAl1C,EAAAm1C,OAAA9jC,GACAokC,EAAAP,EAAAjhB,WAAA11B,EAAAq1B,KAAAshB,EAAAjhB,eAEAN,EAAAuhB,EAAAvhB,YAAA8hB,EAAA9hB,YAEA5B,EAAAmjB,EAAAnjB,KAAA0jB,EAAA1jB,MAAAxzB,EAAAwzB,KAEA6mB,EAAA1D,EAAA3iB,WAAAhM,EAEAkvB,EAAAljB,WAAAylB,EAAAjmB,GAOA,IANA4B,IAAAilB,GAAAjlB,EAAA,GAAAA,EAAA,IACAuhB,EAAAtyC,OAAAg2C,EACA1D,EAAAphC,WAAA4S,EAAA+uB,EAAAhjB,eAAAl0B,EAAAk0B,eAAAmmB,GACA1D,EAAArgC,UAAA4gC,GAAAA,EAAA5gC,WAAAtW,EAAAsW,UACAqgC,EAAAviB,kBAAA8iB,GAAAA,EAAA9iB,mBAAA,SAEA,MAAAgmB,GAAAJ,EAAArD,EAAAphC,WAAA6kC,EACA,OACAxpC,SACAxM,MAAA,EACAC,OAAA,EAIAsyC,GAAA5iB,UAAAv5B,EAAAm8C,EAAAz2C,KAAAszB,EACA,IAAA8mB,GAAApD,EAAAnjB,UACAwmB,EAAA,MAAAD,GAAA,SAAAA,CAGA,IAAA,gBAAAA,IAAA,MAAAA,EAAA9iC,OAAA8iC,EAAAh/C,OAAA,GACAq7C,EAAA6D,aAAAF,EACAL,EAAAt7C,KAAAg4C,GACA2D,EAAA,MAEO,CACP,GAAAC,EAAA,CACAD,EAAA3D,EAAA5iB,SAGA,IAAAiB,GAAAkiB,EAAAliB,oBACAylB,EAAAzlB,GAAAA,EAAA/0B,KAWAw6C,KACAA,EAAAlD,EAAAmD,eAAAD,GAEAlD,EAAAG,aAAA+C,KACAH,EAAA9xC,KAAA6Q,IAAAihC,EAAAG,EAAAr2C,MAAAi2C,EAAAI,EAAAp2C,UAKA,GAAAs2C,GAAAvlB,EAAAA,EAAA,GAAAA,EAAA,GAAA,CACAklB,IAAAK,CACA,IAAAC,GAAA,MAAAT,EAAAA,EAAAlvC,EAAA,IAEA,OAAA2vC,GAAAA,EAAAN,KACAC,GAAAK,EAAAD,GACAhE,EAAAz2C,KAAA,GACAy2C,EAAA5iB,UAAAumB,EAAA,IAEA3D,EAAAz2C,KAAAu4C,EAAA9B,EAAAz2C,KAAA06C,EAAAD,EAAAnnB,EAAA8B,EAAAqjB,UACAI,QAAAzjB,EAAAyjB,UAEApC,EAAA5iB,UAAAv5B,EAAAm8C,EAAAz2C,KAAAszB,GACA8mB,EAAA3D,EAAA5iB,UAAA4mB,IAKA1vC,GAAA0rC,EAAAvyC,MAAAk2C,EACApD,IAAA3hC,EAAA/M,KAAA6Q,IAAA9D,EAAAohC,EAAAphC,aAGA9T,EAAA2C,MAAA6G,EACAxJ,EAAA8T,WAAAA,EACAykC,GAAAzkC,EACAghC,EAAA/tC,KAAA6Q,IAAAk9B,EAAAtrC,GAGA2pC,EAAAgB,WAAAhB,EAAAxwC,MAAA4jB,EAAAhoB,EAAA+zB,UAAAwiB,GACA3B,EAAAG,YAAAH,EAAAvwC,OAAA2jB,EAAAhoB,EAAAg0B,WAAAgmB,GAEAE,IACAtF,EAAAgB,YAAAsE,EAAA,GAAAA,EAAA,GACAtF,EAAAG,aAAAmF,EAAA,GAAAA,EAAA,GAGA,KAAA,GAAA13C,GAAA,EAAiBA,EAAAy3C,EAAA3+C,OAAwBkH,IAAA,CACzC,GAAAm0C,GAAAsD,EAAAz3C,GACAg4C,EAAA7D,EAAA6D,YAEA7D,GAAAvyC,MAAAkK,SAAAksC,EAAA,IAAA,IAAAjE,EAGA,MAAA3B,GAGA,QAAAmF,GAAAc,EAAAvuB,EAAAoJ,GAKA,IAAA,GAJAolB,GAAA,KAAAxuB,EACAyuB,EAAAzuB,EAAA/hB,MAAA,MACAqG,EAAAiqC,EAAAjqC,MAEApO,EAAA,EAAiBA,EAAAu4C,EAAAz/C,OAAiBkH,IAAA,CAClC,GAAAtC,GAAA66C,EAAAv4C,GACAm0C,GACAjhB,UAAAA,EACAx1B,KAAAA,EACAi3C,cAAAj3C,IAAA46C,EAGA,IAAAt4C,EAkBAoO,EAAAjS,MACAi4C,QAAAD,SAnBA,CACA,GAAAC,IAAAhmC,EAAAA,EAAAtV,OAAA,KAAAsV,EAAA,IACAgmC,aACOA,OAQPoE,EAAApE,EAAAt7C,MACA,KAAA0/C,GAAApE,EAAA,GAAAO,aAAAP,EAAA,GAAAD,GAEAz2C,IAAA86C,GAAAF,IAAAlE,EAAAj4C,KAAAg4C,KAWA,QAAAvC,GAAAp0C,GAGA,OAAAA,EAAA2zB,UAAA3zB,EAAA4zB,cAAA5zB,EAAAyzB,UAAAzzB,EAAA0zB,YAAA1zB,EAAA2zB,UAAA,IAAA,KACA3zB,EAAA4zB,YAAA,cAAAgL,KAAA,MAAA5+B,EAAAkV,UAAAlV,EAAAwzB,KA/pBA,GAAA7R,GAAAtsB,EAAA,IAEAkiD,EAAAliD,EAAA,IAEAymC,EAAAzmC,EAAA,GAEAse,EAAAmoB,EAAAnoB,WACAsG,EAAA6hB,EAAA7hB,OACA+N,EAAA8T,EAAA9T,UACAG,EAAA2T,EAAA3T,UACA+vB,KACAE,EAAA,EACAC,EAAA,IACAuB,EAAA,gCACAjF,EAAA,kBAEAxvB,IAkXAA,GAAAgzB,YAAA,SAAAj4C,EAAAszB,GACA,GAAAlG,GAAA3Z,GAEA,OADA2Z,GAAAkG,KAAAA,GAAAmhB,EACArnB,EAAA6qB,YAAAj4C,IA6RAnL,EAAA4/C,aAAAA,EACA5/C,EAAAkwB,UAAAA,EACAlwB,EAAAyF,SAAAA,EACAzF,EAAAuP,gBAAAA,EACAvP,EAAA+gD,YAAAA,EACA/gD,EAAAwgD,YAAAA,EACAxgD,EAAA+iD,yBAAAA,EACA/iD,EAAA0jD,aAAAA,EACA1jD,EAAA0kD,cAAAA,EACA1kD,EAAAojD,YAAAA,EACApjD,EAAA+/C,eAAAA,EACA//C,EAAAshD,cAAAA,EACAthD,EAAAq/C,SAAAA,G3B68TM,SAAUp/C,EAAQD,EAASM,G4B7mVjC,QAAAssB,GAAA/a,EAAAE,EAAA1C,EAAAC,GACAD,EAAA,IACAwC,GAAAxC,EACAA,GAAAA,GAGAC,EAAA,IACAyC,GAAAzC,EACAA,GAAAA,GAOAlP,KAAAyR,EAAAA,EAKAzR,KAAA2R,EAAAA,EAKA3R,KAAAiP,MAAAA,EAKAjP,KAAAkP,OAAAA,EA5CA,GAAA42C,GAAA5lD,EAAA,IAEA0rB,EAAA1rB,EAAA,IAKA6lD,EAAAD,EAAAz4B,eACA24B,EAAA3yC,KAAA4Q,IACAgiC,EAAA5yC,KAAA6Q,GAsCAsI,GAAAtnB,WACAqrB,YAAA/D,EAKA05B,MAAA,SAAAC,GACA,GAAA10C,GAAAu0C,EAAAG,EAAA10C,EAAAzR,KAAAyR,GACAE,EAAAq0C,EAAAG,EAAAx0C,EAAA3R,KAAA2R,EACA3R,MAAAiP,MAAAg3C,EAAAE,EAAA10C,EAAA00C,EAAAl3C,MAAAjP,KAAAyR,EAAAzR,KAAAiP,OAAAwC,EACAzR,KAAAkP,OAAA+2C,EAAAE,EAAAx0C,EAAAw0C,EAAAj3C,OAAAlP,KAAA2R,EAAA3R,KAAAkP,QAAAyC,EACA3R,KAAAyR,EAAAA,EACAzR,KAAA2R,EAAAA,GAOA0b,eAAA,WACA,GAAA+4B,MACAC,KACAC,KACAC,IACA,OAAA,UAAA/lD,GAIA,GAAAA,EAAA,CAIA4lD,EAAA,GAAAE,EAAA,GAAAtmD,KAAAyR,EACA20C,EAAA,GAAAG,EAAA,GAAAvmD,KAAA2R,EACA00C,EAAA,GAAAE,EAAA,GAAAvmD,KAAAyR,EAAAzR,KAAAiP,MACAo3C,EAAA,GAAAC,EAAA,GAAAtmD,KAAA2R,EAAA3R,KAAAkP,OACA62C,EAAAK,EAAAA,EAAA5lD,GACAulD,EAAAM,EAAAA,EAAA7lD,GACAulD,EAAAO,EAAAA,EAAA9lD,GACAulD,EAAAQ,EAAAA,EAAA/lD,GACAR,KAAAyR,EAAAu0C,EAAAI,EAAA,GAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,IACAvmD,KAAA2R,EAAAq0C,EAAAI,EAAA,GAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,GACA,IAAAthC,GAAAghC,EAAAG,EAAA,GAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,IACArhC,EAAA+gC,EAAAG,EAAA,GAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,GACAvmD,MAAAiP,MAAAgW,EAAAjlB,KAAAyR,EACAzR,KAAAkP,OAAAgW,EAAAllB,KAAA2R,OASA4b,mBAAA,SAAAkY,GACA,GAAAd,GAAA3kC,KACA2jC,EAAA8B,EAAAx2B,MAAA01B,EAAA11B,MACA20B,EAAA6B,EAAAv2B,OAAAy1B,EAAAz1B,OACA1O,EAAAorB,EAAA2X,QAKA,OAHA3X,GAAA8Y,UAAAlkC,EAAAA,IAAAmkC,EAAAlzB,GAAAkzB,EAAAhzB,IACAia,EAAA3X,MAAAzT,EAAAA,GAAAmjC,EAAAC,IACAhY,EAAA8Y,UAAAlkC,EAAAA,GAAAilC,EAAAh0B,EAAAg0B,EAAA9zB,IACAnR,GAOAgmD,UAAA,SAAA/gB,GACA,IAAAA,EACA,OAAA,CAGAA,aAAAjZ,KAEAiZ,EAAAjZ,EAAA+W,OAAAkC,GAGA,IAAAd,GAAA3kC,KACAymD,EAAA9hB,EAAAlzB,EACAi1C,EAAA/hB,EAAAlzB,EAAAkzB,EAAA11B,MACA03C,EAAAhiB,EAAAhzB,EACAi1C,EAAAjiB,EAAAhzB,EAAAgzB,EAAAz1B,OACA23C,EAAAphB,EAAAh0B,EACAq1C,EAAArhB,EAAAh0B,EAAAg0B,EAAAx2B,MACA83C,EAAAthB,EAAA9zB,EACAq1C,EAAAvhB,EAAA9zB,EAAA8zB,EAAAv2B,MACA,SAAAw3C,EAAAG,GAAAC,EAAAL,GAAAG,EAAAG,GAAAC,EAAAL,IAEAhrB,QAAA,SAAAlqB,EAAAE,GACA,GAAAa,GAAAxS,IACA,OAAAyR,IAAAe,EAAAf,GAAAA,GAAAe,EAAAf,EAAAe,EAAAvD,OAAA0C,GAAAa,EAAAb,GAAAA,GAAAa,EAAAb,EAAAa,EAAAtD,QAMA9I,MAAA,WACA,MAAA,IAAAomB,GAAAxsB,KAAAyR,EAAAzR,KAAA2R,EAAA3R,KAAAiP,MAAAjP,KAAAkP,SAMAosB,KAAA,SAAA6qB,GACAnmD,KAAAyR,EAAA00C,EAAA10C,EACAzR,KAAA2R,EAAAw0C,EAAAx0C,EACA3R,KAAAiP,MAAAk3C,EAAAl3C,MACAjP,KAAAkP,OAAAi3C,EAAAj3C,QAEA+3C,MAAA,WACA,OACAx1C,EAAAzR,KAAAyR,EACAE,EAAA3R,KAAA2R,EACA1C,MAAAjP,KAAAiP,MACAC,OAAAlP,KAAAkP,UAaAsd,EAAA+W,OAAA,SAAA/wB,GACA,MAAA,IAAAga,GAAAha,EAAAf,EAAAe,EAAAb,EAAAa,EAAAvD,MAAAuD,EAAAtD,QAGA,IAAAytB,GAAAnQ,CACA3sB,GAAAD,QAAA+8B,G5BioVM,SAAU98B,EAAQD,EAASM,G6B/yVjC,QAAAqlD,GAAA2B,GACA,GAAA,gBAAAA,GAAA,CACA,GAAAC,GAAAC,EAAA/gD,IAAA6gD,EACA,OAAAC,IAAAA,EAAAr8C,MAEA,MAAAo8C,GAgBA,QAAA7E,GAAA6E,EAAAp8C,EAAAs0C,EAAAvhC,EAAAwpC,GACA,GAAAH,EAEG,CAAA,GAAA,gBAAAA,GAAA,CAEH,GAAAp8C,GAAAA,EAAAw8C,eAAAJ,IAAA9H,EACA,MAAAt0C,EAKA,IAAAq8C,GAAAC,EAAA/gD,IAAA6gD,GACAK,GACAnI,OAAAA,EACAvhC,GAAAA,EACAwpC,UAAAA,EAgBA,OAbAF,IACAr8C,EAAAq8C,EAAAr8C,OACAy3C,EAAAz3C,IAAAq8C,EAAAK,QAAAh+C,KAAA+9C,MAEAz8C,IAAAA,EAAA,GAAAF,QACAE,EAAA28C,OAAAC,EACAN,EAAAjW,IAAA+V,EAAAp8C,EAAA68C,gBACA78C,MAAAA,EACA08C,SAAAD,KAEAz8C,EAAA88C,IAAA98C,EAAAw8C,aAAAJ,GAGAp8C,EAGA,MAAAo8C,GAhCA,MAAAp8C,GAoCA,QAAA48C,KACA,GAAAP,GAAAnnD,KAAA2nD,cACA3nD,MAAAynD,OAAAznD,KAAA2nD,eAAA,IAEA,KAAA,GAAAt6C,GAAA,EAAiBA,EAAA85C,EAAAK,QAAArhD,OAAiCkH,IAAA,CAClD,GAAAk6C,GAAAJ,EAAAK,QAAAn6C,GACAwQ,EAAA0pC,EAAA1pC,EACAA,IAAAA,EAAA7d,KAAAunD,EAAAF,WACAE,EAAAnI,OAAA9mB,QAGA6uB,EAAAK,QAAArhD,OAAA,EAGA,QAAAo8C,GAAAz3C,GACA,MAAAA,IAAAA,EAAAmE,OAAAnE,EAAAoE,OAlFA,GAAAykC,GAAAzzC,EAAA,IAEAknD,EAAA,GAAAzT,GAAA,GAmFA/zC,GAAA2lD,eAAAA,EACA3lD,EAAAyiD,oBAAAA,EACAziD,EAAA2iD,aAAAA,G7B6zVM,SAAU1iD,EAAQD,G8Bp5VxB,QAAAq4B,GAAAE,EAAAlxB,GACA,GAKA4gD,GACAC,EACAC,EACAC,EARAv2C,EAAAxK,EAAAwK,EACAE,EAAA1K,EAAA0K,EACA1C,EAAAhI,EAAAgI,MACAC,EAAAjI,EAAAiI,OACA0C,EAAA3K,EAAA2K,CAMA3C,GAAA,IACAwC,GAAAxC,EACAA,GAAAA,GAGAC,EAAA,IACAyC,GAAAzC,EACAA,GAAAA,GAGA,gBAAA0C,GACAi2C,EAAAC,EAAAC,EAAAC,EAAAp2C,EACGA,YAAAwH,OACH,IAAAxH,EAAAzL,OACA0hD,EAAAC,EAAAC,EAAAC,EAAAp2C,EAAA,GACK,IAAAA,EAAAzL,QACL0hD,EAAAE,EAAAn2C,EAAA,GACAk2C,EAAAE,EAAAp2C,EAAA,IACK,IAAAA,EAAAzL,QACL0hD,EAAAj2C,EAAA,GACAk2C,EAAAE,EAAAp2C,EAAA,GACAm2C,EAAAn2C,EAAA,KAEAi2C,EAAAj2C,EAAA,GACAk2C,EAAAl2C,EAAA,GACAm2C,EAAAn2C,EAAA,GACAo2C,EAAAp2C,EAAA,IAGAi2C,EAAAC,EAAAC,EAAAC,EAAA,CAGA,IAAAC,EAEAJ,GAAAC,EAAA74C,IACAg5C,EAAAJ,EAAAC,EACAD,GAAA54C,EAAAg5C,EACAH,GAAA74C,EAAAg5C,GAGAF,EAAAC,EAAA/4C,IACAg5C,EAAAF,EAAAC,EACAD,GAAA94C,EAAAg5C,EACAD,GAAA/4C,EAAAg5C,GAGAH,EAAAC,EAAA74C,IACA+4C,EAAAH,EAAAC,EACAD,GAAA54C,EAAA+4C,EACAF,GAAA74C,EAAA+4C,GAGAJ,EAAAG,EAAA94C,IACA+4C,EAAAJ,EAAAG,EACAH,GAAA34C,EAAA+4C,EACAD,GAAA94C,EAAA+4C,GAGA9vB,EAAA+vB,OAAAz2C,EAAAo2C,EAAAl2C,GACAwmB,EAAAgwB,OAAA12C,EAAAxC,EAAA64C,EAAAn2C,GACA,IAAAm2C,GAAA3vB,EAAAiwB,iBAAA32C,EAAAxC,EAAA0C,EAAAF,EAAAxC,EAAA0C,EAAAm2C,GACA3vB,EAAAgwB,OAAA12C,EAAAxC,EAAA0C,EAAAzC,EAAA64C,GACA,IAAAA,GAAA5vB,EAAAiwB,iBAAA32C,EAAAxC,EAAA0C,EAAAzC,EAAAuC,EAAAxC,EAAA84C,EAAAp2C,EAAAzC,GACAipB,EAAAgwB,OAAA12C,EAAAu2C,EAAAr2C,EAAAzC,GACA,IAAA84C,GAAA7vB,EAAAiwB,iBAAA32C,EAAAE,EAAAzC,EAAAuC,EAAAE,EAAAzC,EAAA84C,GACA7vB,EAAAgwB,OAAA12C,EAAAE,EAAAk2C,GACA,IAAAA,GAAA1vB,EAAAiwB,iBAAA32C,EAAAE,EAAAF,EAAAo2C,EAAAl2C,GAGA/R,EAAAq4B,UAAAA,G9B05VM,SAAUp4B,EAAQD,EAASM,G+B1+VjC,GAAAmoD,GAAAnoD,EAAA,IAEA4lD,EAAA5lD,EAAA,IAEAooD,EAAApoD,EAAA,IAEAssB,EAAAtsB,EAAA,IAEAo+C,EAAAp+C,EAAA,IAEAujC,EAAA6a,EAAAj8C,iBAUA60B,GACAO,EAAA,EACAD,EAAA,EACAE,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EAEAqa,EAAA,GAWAjuB,KACAC,KACAqkC,KACAC,KACAxC,EAAA3yC,KAAA4Q,IACAgiC,EAAA5yC,KAAA6Q,IACAyR,EAAAtiB,KAAA0lB,IACAnD,EAAAviB,KAAAylB,IACA/C,EAAA1iB,KAAA2D,KACAyxC,EAAAp1C,KAAAC,IACAo1C,EAAA,mBAAAljB,cAMAvO,EAAA,SAAA0xB,GACA3oD,KAAA4oD,WAAAD,EAEA3oD,KAAA4oD,YAKA5oD,KAAAwZ,SAGAxZ,KAAAmxB,KAAA,KAQA8F,GAAA/xB,WACAqrB,YAAA0G,EACA4xB,IAAA,EACAC,IAAA,EACAC,IAAA,EACAC,IAAA,EAEAC,IAAA,EACAC,IAAA,EACA7L,KAAA,EACA8L,UAAA,KACAC,YAAA,EACAC,SAAA,EACAC,SAAA,EAKA1jC,SAAA,SAAA+d,EAAAC,GACA5jC,KAAAipD,IAAAR,EAAA,EAAAhlB,EAAAE,IAAA,EACA3jC,KAAAkpD,IAAAT,EAAA,EAAAhlB,EAAAG,IAAA,GAEAplB,WAAA,WACA,MAAAxe,MAAAmxB,MAOAyJ,UAAA,SAAAzC,GAcA,MAbAn4B,MAAAmxB,KAAAgH,EACAA,GAAAA,EAAAyC,YACAzC,IAAAn4B,KAAAyjC,IAAAtL,EAAAsL,KAEAzjC,KAAA4oD,YACA5oD,KAAAq9C,KAAA,GAGAr9C,KAAAmpD,YACAnpD,KAAAmpD,UAAA,KACAnpD,KAAAopD,YAAA,GAGAppD,MAQAkoD,OAAA,SAAAz2C,EAAAE,GAWA,MAVA3R,MAAAw2B,QAAAU,EAAAO,EAAAhmB,EAAAE,GACA3R,KAAAmxB,MAAAnxB,KAAAmxB,KAAA+2B,OAAAz2C,EAAAE,GAKA3R,KAAA+oD,IAAAt3C,EACAzR,KAAAgpD,IAAAr3C,EACA3R,KAAA6oD,IAAAp3C,EACAzR,KAAA8oD,IAAAn3C,EACA3R,MAQAmoD,OAAA,SAAA12C,EAAAE,GACA,GAAA43C,GAAAd,EAAAh3C,EAAAzR,KAAA6oD,KAAA7oD,KAAAipD,KAAAR,EAAA92C,EAAA3R,KAAA8oD,KAAA9oD,KAAAkpD,KACAlpD,KAAAq9C,KAAA,CAYA,OAXAr9C,MAAAw2B,QAAAU,EAAAM,EAAA/lB,EAAAE,GAEA3R,KAAAmxB,MAAAo4B,IACAvpD,KAAAwpD,aAAAxpD,KAAAypD,cAAAh4C,EAAAE,GAAA3R,KAAAmxB,KAAAg3B,OAAA12C,EAAAE,IAGA43C,IACAvpD,KAAA6oD,IAAAp3C,EACAzR,KAAA8oD,IAAAn3C,GAGA3R,MAYA0pD,cAAA,SAAAh0C,EAAAC,EAAAC,EAAAC,EAAA8zC,EAAAC,GASA,MARA5pD,MAAAw2B,QAAAU,EAAAQ,EAAAhiB,EAAAC,EAAAC,EAAAC,EAAA8zC,EAAAC,GAEA5pD,KAAAmxB,OACAnxB,KAAAwpD,aAAAxpD,KAAA6pD,gBAAAn0C,EAAAC,EAAAC,EAAAC,EAAA8zC,EAAAC,GAAA5pD,KAAAmxB,KAAAu4B,cAAAh0C,EAAAC,EAAAC,EAAAC,EAAA8zC,EAAAC,IAGA5pD,KAAA6oD,IAAAc,EACA3pD,KAAA8oD,IAAAc,EACA5pD,MAUAooD,iBAAA,SAAA1yC,EAAAC,EAAAC,EAAAC,GASA,MARA7V,MAAAw2B,QAAAU,EAAAS,EAAAjiB,EAAAC,EAAAC,EAAAC,GAEA7V,KAAAmxB,OACAnxB,KAAAwpD,aAAAxpD,KAAA8pD,mBAAAp0C,EAAAC,EAAAC,EAAAC,GAAA7V,KAAAmxB,KAAAi3B,iBAAA1yC,EAAAC,EAAAC,EAAAC,IAGA7V,KAAA6oD,IAAAjzC,EACA5V,KAAA8oD,IAAAjzC,EACA7V,MAYA+pD,IAAA,SAAAv4C,EAAAE,EAAAE,EAAAo4C,EAAAC,EAAAC,GAKA,MAJAlqD,MAAAw2B,QAAAU,EAAAU,EAAApmB,EAAAE,EAAAE,EAAAA,EAAAo4C,EAAAC,EAAAD,EAAA,EAAAE,EAAA,EAAA,GACAlqD,KAAAmxB,MAAAnxB,KAAAmxB,KAAA44B,IAAAv4C,EAAAE,EAAAE,EAAAo4C,EAAAC,EAAAC,GACAlqD,KAAA6oD,IAAAlzB,EAAAs0B,GAAAr4C,EAAAJ,EACAxR,KAAA8oD,IAAAlzB,EAAAq0B,GAAAr4C,EAAAJ,EACAxR,MAGAmqD,MAAA,SAAAz0C,EAAAC,EAAAC,EAAAC,EAAAu0C,GAKA,MAJApqD,MAAAmxB,MACAnxB,KAAAmxB,KAAAg5B,MAAAz0C,EAAAC,EAAAC,EAAAC,EAAAu0C,GAGApqD,MAGAwS,KAAA,SAAAf,EAAAE,EAAA4pB,EAAAoH,GAGA,MAFA3iC,MAAAmxB,MAAAnxB,KAAAmxB,KAAA3e,KAAAf,EAAAE,EAAA4pB,EAAAoH,GACA3iC,KAAAw2B,QAAAU,EAAAgb,EAAAzgC,EAAAE,EAAA4pB,EAAAoH,GACA3iC,MAMAmiD,UAAA,WACAniD,KAAAw2B,QAAAU,EAAAW,EACA,IAAAM,GAAAn4B,KAAAmxB,KACAk5B,EAAArqD,KAAA+oD,IACAuB,EAAAtqD,KAAAgpD,GASA,OAPA7wB,KACAn4B,KAAAwpD,cAAAxpD,KAAAypD,cAAAY,EAAAC,GACAnyB,EAAAgqB,aAGAniD,KAAA6oD,IAAAwB,EACArqD,KAAA8oD,IAAAwB,EACAtqD,MASA6R,KAAA,SAAAsmB,GACAA,GAAAA,EAAAtmB,OACA7R,KAAA83B,YAOAhmB,OAAA,SAAAqmB,GACAA,GAAAA,EAAArmB,SACA9R,KAAA83B,YAQA4C,YAAA,SAAAtb,GACA,GAAAA,YAAAhG,OAAA,CACApZ,KAAAmpD,UAAA/pC,EACApf,KAAAqpD,SAAA,CAGA,KAAA,GAFAkB,GAAA,EAEAl9C,EAAA,EAAqBA,EAAA+R,EAAAjZ,OAAqBkH,IAC1Ck9C,GAAAnrC,EAAA/R,EAGArN,MAAAspD,SAAAiB,EAGA,MAAAvqD,OAQA66B,kBAAA,SAAA1nB,GAEA,MADAnT,MAAAopD,YAAAj2C,EACAnT,MAOAowB,IAAA,WACA,MAAApwB,MAAAq9C,MAMAnlB,QAAA,SAAA1e,GACA,GAAA4W,GAAA5W,EAAArT,MAEAnG,MAAAwZ,MAAAxZ,KAAAwZ,KAAArT,QAAAiqB,IAAAs4B,IACA1oD,KAAAwZ,KAAA,GAAAgsB,cAAApV,GAGA,KAAA,GAAA/iB,GAAA,EAAmBA,EAAA+iB,EAAS/iB,IAC5BrN,KAAAwZ,KAAAnM,GAAAmM,EAAAnM,EAGArN,MAAAq9C,KAAAjtB,GAOAyI,WAAA,SAAA9L,GACAA,YAAA3T,SACA2T,GAAAA,GAOA,KAAA,GAJAqD,GAAArD,EAAA5mB,OACAqkD,EAAA,EACAr3C,EAAAnT,KAAAq9C,KAEAhwC,EAAA,EAAmBA,EAAA+iB,EAAS/iB,IAC5Bm9C,GAAAz9B,EAAA1f,GAAA+iB,KAGAs4B,IAAA1oD,KAAAwZ,eAAAgsB,gBACAxlC,KAAAwZ,KAAA,GAAAgsB,cAAAryB,EAAAq3C,GAGA,KAAA,GAAAn9C,GAAA,EAAmBA,EAAA+iB,EAAS/iB,IAG5B,IAAA,GAFAo9C,GAAA19B,EAAA1f,GAAAmM,KAEA40B,EAAA,EAAqBA,EAAAqc,EAAAtkD,OAA2BioC,IAChDpuC,KAAAwZ,KAAArG,KAAAs3C,EAAArc,EAIApuC,MAAAq9C,KAAAlqC,GAOAqjB,QAAA,SAAAhB,GACA,GAAAx1B,KAAA4oD,UAAA,CAIA,GAAApvC,GAAAxZ,KAAAwZ,IAEAxZ,MAAAq9C,KAAAn3C,UAAAC,OAAAqT,EAAArT,SAGAnG,KAAA0qD,cAEAlxC,EAAAxZ,KAAAwZ,KAGA,KAAA,GAAAnM,GAAA,EAAmBA,EAAAnH,UAAAC,OAAsBkH,IACzCmM,EAAAxZ,KAAAq9C,QAAAn3C,UAAAmH,EAGArN,MAAA2qD,SAAAn1B,IAEAk1B,YAAA,WAEA,KAAA1qD,KAAAwZ,eAAAJ,QAAA,CAGA,IAAA,GAFAwxC,MAEAv9C,EAAA,EAAqBA,EAAArN,KAAAq9C,KAAehwC,IACpCu9C,EAAAv9C,GAAArN,KAAAwZ,KAAAnM,EAGArN,MAAAwZ,KAAAoxC,IASApB,WAAA,WACA,MAAAxpD,MAAAmpD,WAEAM,cAAA,SAAA/zC,EAAAC,GACA,GAWAk1C,GAEAC,EAbAC,EAAA/qD,KAAAspD,SACAn2C,EAAAnT,KAAAopD,YACAhqC,EAAApf,KAAAmpD,UACAhxB,EAAAn4B,KAAAmxB,KACAk5B,EAAArqD,KAAA6oD,IACAyB,EAAAtqD,KAAA8oD,IACAznB,EAAA3rB,EAAA20C,EACA/oB,EAAA3rB,EAAA20C,EACA/jB,EAAAxQ,EAAAsL,EAAAA,EAAAC,EAAAA,GACA7vB,EAAA44C,EACA14C,EAAA24C,EAEAU,EAAA5rC,EAAAjZ,MAcA,KAZAk7B,GAAAkF,EACAjF,GAAAiF,EAEApzB,EAAA,IAEAA,EAAA43C,EAAA53C,GAGAA,GAAA43C,EACAt5C,GAAA0B,EAAAkuB,EACA1vB,GAAAwB,EAAAmuB,EAEAD,EAAA,GAAA5vB,GAAAiE,GAAA2rB,EAAA,GAAA5vB,GAAAiE,GAAA,GAAA2rB,IAAAC,EAAA,GAAA3vB,GAAAgE,GAAA2rB,EAAA,GAAA3vB,GAAAgE,IACAm1C,EAAA9qD,KAAAqpD,SACAwB,EAAAzrC,EAAA0rC,GACAr5C,GAAA4vB,EAAAwpB,EACAl5C,GAAA2vB,EAAAupB,EACA7qD,KAAAqpD,UAAAyB,EAAA,GAAAE,EAEA3pB,EAAA,GAAA5vB,EAAA44C,GAAAhpB,EAAA,GAAA5vB,EAAA44C,GAAA/oB,EAAA,GAAA3vB,EAAA24C,GAAAhpB,EAAA,GAAA3vB,EAAA24C,GAIAnyB,EAAA2yB,EAAA,EAAA,SAAA,UAAAzpB,GAAA,EAAA2kB,EAAAv0C,EAAAiE,GAAAuwC,EAAAx0C,EAAAiE,GAAA4rB,GAAA,EAAA0kB,EAAAr0C,EAAAgE,GAAAswC,EAAAt0C,EAAAgE,GAIA0rB,GAAA5vB,EAAAiE,EACA4rB,EAAA3vB,EAAAgE,EACA3V,KAAAopD,aAAArzB,EAAAsL,EAAAA,EAAAC,EAAAA,IAGAuoB,gBAAA,SAAAn0C,EAAAC,EAAAC,EAAAC,EAAA8zC,EAAAC,GACA,GAMAvjB,GACAhF,EACAC,EAKA7vB,EACAE,EAdAo5C,EAAA/qD,KAAAspD,SACAn2C,EAAAnT,KAAAopD,YACAhqC,EAAApf,KAAAmpD,UACAhxB,EAAAn4B,KAAAmxB,KACAk5B,EAAArqD,KAAA6oD,IACAyB,EAAAtqD,KAAA8oD,IAIAmC,EAAA5C,EAAA4C,QACAC,EAAA,EACAJ,EAAA9qD,KAAAqpD,SACA2B,EAAA5rC,EAAAjZ,OAGAglD,EAAA,CASA,KAPAh4C,EAAA,IAEAA,EAAA43C,EAAA53C,GAGAA,GAAA43C,EAEA1kB,EAAA,EAAeA,EAAA,EAAOA,GAAA,GACtBhF,EAAA4pB,EAAAZ,EAAA30C,EAAAE,EAAA+zC,EAAAtjB,EAAA,IAAA4kB,EAAAZ,EAAA30C,EAAAE,EAAA+zC,EAAAtjB,GACA/E,EAAA2pB,EAAAX,EAAA30C,EAAAE,EAAA+zC,EAAAvjB,EAAA,IAAA4kB,EAAAX,EAAA30C,EAAAE,EAAA+zC,EAAAvjB,GACA6kB,GAAAn1B,EAAAsL,EAAAA,EAAAC,EAAAA,EAIA,MAAUwpB,EAAAE,IACVG,GAAA/rC,EAAA0rC,KAEAK,EAAAh4C,IAHuB23C,KAUvB,IAFAzkB,GAAA8kB,EAAAh4C,GAAA+3C,EAEA7kB,GAAA,GACA50B,EAAAw5C,EAAAZ,EAAA30C,EAAAE,EAAA+zC,EAAAtjB,GACA10B,EAAAs5C,EAAAX,EAAA30C,EAAAE,EAAA+zC,EAAAvjB,GAGAykB,EAAA,EAAA3yB,EAAA+vB,OAAAz2C,EAAAE,GAAAwmB,EAAAgwB,OAAA12C,EAAAE,GACA00B,GAAAjnB,EAAA0rC,GAAAI,EACAJ,GAAAA,EAAA,GAAAE,CAIAF,GAAA,IAAA,GAAA3yB,EAAAgwB,OAAAwB,EAAAC,GACAvoB,EAAAsoB,EAAAl4C,EACA6vB,EAAAsoB,EAAAj4C,EACA3R,KAAAopD,aAAArzB,EAAAsL,EAAAA,EAAAC,EAAAA,IAEAwoB,mBAAA,SAAAp0C,EAAAC,EAAAC,EAAAC,GAEA,GAAA8zC,GAAA/zC,EACAg0C,EAAA/zC,CACAD,IAAAA,EAAA,EAAAF,GAAA,EACAG,GAAAA,EAAA,EAAAF,GAAA,EACAD,GAAA1V,KAAA6oD,IAAA,EAAAnzC,GAAA,EACAC,GAAA3V,KAAA8oD,IAAA,EAAAnzC,GAAA,EAEA3V,KAAA6pD,gBAAAn0C,EAAAC,EAAAC,EAAAC,EAAA8zC,EAAAC,IAOA9xB,SAAA,WACA,GAAAte,GAAAxZ,KAAAwZ,IAEAA,aAAAJ,SACAI,EAAArT,OAAAnG,KAAAq9C,KAEAqL,IACA1oD,KAAAwZ,KAAA,GAAAgsB,cAAAhsB,MAQArK,gBAAA,WACA8U,EAAA,GAAAA,EAAA,GAAAskC,EAAA,GAAAA,EAAA,GAAAhmC,OAAA6oC,UACAlnC,EAAA,GAAAA,EAAA,GAAAskC,EAAA,GAAAA,EAAA,IAAAjmC,OAAA6oC,SAOA,KAAA,GANA5xC,GAAAxZ,KAAAwZ,KACA6xC,EAAA,EACAC,EAAA,EACAjB,EAAA,EACAC,EAAA,EAEAj9C,EAAA,EAAmBA,EAAAmM,EAAArT,QAAiB,CACpC,GAAAqvB,GAAAhc,EAAAnM,IAaA,QAXA,GAAAA,IAKAg+C,EAAA7xC,EAAAnM,GACAi+C,EAAA9xC,EAAAnM,EAAA,GACAg9C,EAAAgB,EACAf,EAAAgB,GAGA91B,GACA,IAAA0B,GAAAO,EAGA4yB,EAAA7wC,EAAAnM,KACAi9C,EAAA9wC,EAAAnM,KACAg+C,EAAAhB,EACAiB,EAAAhB,EACA/B,EAAA,GAAA8B,EACA9B,EAAA,GAAA+B,EACA9B,EAAA,GAAA6B,EACA7B,EAAA,GAAA8B,CACA,MAEA,KAAApzB,GAAAM,EACA8wB,EAAAiD,SAAAF,EAAAC,EAAA9xC,EAAAnM,GAAAmM,EAAAnM,EAAA,GAAAk7C,EAAAC,GACA6C,EAAA7xC,EAAAnM,KACAi+C,EAAA9xC,EAAAnM,IACA,MAEA,KAAA6pB,GAAAQ,EACA4wB,EAAAkD,UAAAH,EAAAC,EAAA9xC,EAAAnM,KAAAmM,EAAAnM,KAAAmM,EAAAnM,KAAAmM,EAAAnM,KAAAmM,EAAAnM,GAAAmM,EAAAnM,EAAA,GAAAk7C,EAAAC,GACA6C,EAAA7xC,EAAAnM,KACAi+C,EAAA9xC,EAAAnM,IACA,MAEA,KAAA6pB,GAAAS,EACA2wB,EAAAmD,cAAAJ,EAAAC,EAAA9xC,EAAAnM,KAAAmM,EAAAnM,KAAAmM,EAAAnM,GAAAmM,EAAAnM,EAAA,GAAAk7C,EAAAC,GACA6C,EAAA7xC,EAAAnM,KACAi+C,EAAA9xC,EAAAnM,IACA,MAEA,KAAA6pB,GAAAU,EAEA,GAAApmB,GAAAgI,EAAAnM,KACAqE,EAAA8H,EAAAnM,KACAgoB,EAAA7b,EAAAnM,KACAioB,EAAA9b,EAAAnM,KACA28C,EAAAxwC,EAAAnM,KACA48C,EAAAzwC,EAAAnM,KAAA28C,EAGAE,GADA1wC,EAAAnM,KACA,EAAAmM,EAAAnM,KAEA,IAAAA,IAGAg9C,EAAA10B,EAAAq0B,GAAA30B,EAAA7jB,EACA84C,EAAA10B,EAAAo0B,GAAA10B,EAAA5jB,GAGA42C,EAAAoD,QAAAl6C,EAAAE,EAAA2jB,EAAAC,EAAA00B,EAAAC,EAAAC,EAAA3B,EAAAC,GACA6C,EAAA11B,EAAAs0B,GAAA50B,EAAA7jB,EACA85C,EAAA11B,EAAAq0B,GAAA30B,EAAA5jB,CACA,MAEA,KAAAwlB,GAAAgb,EACAmY,EAAAgB,EAAA7xC,EAAAnM,KACAi9C,EAAAgB,EAAA9xC,EAAAnM,IACA,IAAA4B,GAAAuK,EAAAnM,KACA6B,EAAAsK,EAAAnM,IAEAi7C,GAAAiD,SAAAlB,EAAAC,EAAAD,EAAAp7C,EAAAq7C,EAAAp7C,EAAAq5C,EAAAC,EACA,MAEA,KAAAtxB,GAAAW,EACAwzB,EAAAhB,EACAiB,EAAAhB,EAKAxE,EAAA7hC,IAAAA,EAAAA,EAAAskC,GACAzC,EAAA5hC,IAAAA,EAAAA,EAAAskC,GAQA,MAJA,KAAAn7C,IACA4W,EAAA,GAAAA,EAAA,GAAAC,EAAA,GAAAA,EAAA,GAAA,GAGA,GAAAsI,GAAAvI,EAAA,GAAAA,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,KAQAmU,YAAA,SAAAD,GASA,IAAA,GAPAkyB,GAAAC,EACAe,EAAAC,EACA75C,EAAAE,EAHAs0B,EAAAjmC,KAAAwZ,KAIAmyC,EAAA3rD,KAAAipD,IACA2C,EAAA5rD,KAAAkpD,IACA94B,EAAApwB,KAAAq9C,KAEAhwC,EAAA,EAAmBA,EAAA+iB,GAAS,CAC5B,GAAAoF,GAAAyQ,EAAA54B,IAaA,QAXA,GAAAA,IAKAg+C,EAAAplB,EAAA54B,GACAi+C,EAAArlB,EAAA54B,EAAA,GACAg9C,EAAAgB,EACAf,EAAAgB,GAGA91B,GACA,IAAA0B,GAAAO,EACA4yB,EAAAgB,EAAAplB,EAAA54B,KACAi9C,EAAAgB,EAAArlB,EAAA54B,KACA8qB,EAAA+vB,OAAAmD,EAAAC,EACA,MAEA,KAAAp0B,GAAAM,EACA/lB,EAAAw0B,EAAA54B,KACAsE,EAAAs0B,EAAA54B,MAEAo7C,EAAAh3C,EAAA45C,GAAAM,GAAAlD,EAAA92C,EAAA25C,GAAAM,GAAAv+C,IAAA+iB,EAAA,KACA+H,EAAAgwB,OAAA12C,EAAAE,GACA05C,EAAA55C,EACA65C,EAAA35C,EAGA,MAEA,KAAAulB,GAAAQ,EACAS,EAAAuxB,cAAAzjB,EAAA54B,KAAA44B,EAAA54B,KAAA44B,EAAA54B,KAAA44B,EAAA54B,KAAA44B,EAAA54B,KAAA44B,EAAA54B,MACAg+C,EAAAplB,EAAA54B,EAAA,GACAi+C,EAAArlB,EAAA54B,EAAA,EACA,MAEA,KAAA6pB,GAAAS,EACAQ,EAAAiwB,iBAAAniB,EAAA54B,KAAA44B,EAAA54B,KAAA44B,EAAA54B,KAAA44B,EAAA54B,MACAg+C,EAAAplB,EAAA54B,EAAA,GACAi+C,EAAArlB,EAAA54B,EAAA,EACA,MAEA,KAAA6pB,GAAAU,EACA,GAAApmB,GAAAy0B,EAAA54B,KACAqE,EAAAu0B,EAAA54B,KACAgoB,EAAA4Q,EAAA54B,KACAioB,EAAA2Q,EAAA54B,KACA8oB,EAAA8P,EAAA54B,KACAipB,EAAA2P,EAAA54B,KACAooB,EAAAwQ,EAAA54B,KACA+nB,EAAA6Q,EAAA54B,KACAuE,EAAAyjB,EAAAC,EAAAD,EAAAC,EACAu2B,EAAAx2B,EAAAC,EAAA,EAAAD,EAAAC,EACAw2B,EAAAz2B,EAAAC,EAAAA,EAAAD,EAAA,EACA02B,EAAA14C,KAAAC,IAAA+hB,EAAAC,GAAA,KACA20B,EAAA9zB,EAAAG,CAEAy1B,IACA5zB,EAAAuM,UAAAlzB,EAAAE,GACAymB,EAAA4L,OAAAtO,GACA0C,EAAAlkB,MAAA43C,EAAAC,GACA3zB,EAAA4xB,IAAA,EAAA,EAAAn4C,EAAAukB,EAAA8zB,EAAA,EAAA70B,GACA+C,EAAAlkB,MAAA,EAAA43C,EAAA,EAAAC,GACA3zB,EAAA4L,QAAAtO,GACA0C,EAAAuM,WAAAlzB,GAAAE,IAEAymB,EAAA4xB,IAAAv4C,EAAAE,EAAAE,EAAAukB,EAAA8zB,EAAA,EAAA70B,GAGA,GAAA/nB,IAGAg9C,EAAA10B,EAAAQ,GAAAd,EAAA7jB,EACA84C,EAAA10B,EAAAO,GAAAb,EAAA5jB,GAGA25C,EAAA11B,EAAAs0B,GAAA50B,EAAA7jB,EACA85C,EAAA11B,EAAAq0B,GAAA30B,EAAA5jB,CACA,MAEA,KAAAwlB,GAAAgb,EACAmY,EAAAgB,EAAAplB,EAAA54B,GACAi9C,EAAAgB,EAAArlB,EAAA54B,EAAA,GACA8qB,EAAA3lB,KAAAyzB,EAAA54B,KAAA44B,EAAA54B,KAAA44B,EAAA54B,KAAA44B,EAAA54B,KACA,MAEA,KAAA6pB,GAAAW,EACAM,EAAAgqB,YACAkJ,EAAAhB,EACAiB,EAAAhB,MAKArzB,EAAAC,IAAAA,CACA,IAAAyF,GAAA1F,CACAp3B,GAAAD,QAAA+8B,G/Bg/VM,SAAU98B,EAAQD,EAASM,GgCntXjC,QAAA8rD,GAAAlqC,GACA,MAAAA,IAAAohB,GAAAphB,EAAAohB,EAGA,QAAAD,GAAAnhB,GACA,MAAAA,GAAAohB,GAAAphB,GAAAohB,EAcA,QAAA+nB,GAAAljB,EAAAC,EAAAe,EAAAC,EAAA3C,GACA,GAAA4lB,GAAA,EAAA5lB,CACA,OAAA4lB,GAAAA,GAAAA,EAAAlkB,EAAA,EAAA1B,EAAA2B,GAAA3B,EAAAA,GAAAA,EAAA2C,EAAA,EAAAijB,EAAAljB,GAcA,QAAAmjB,GAAAnkB,EAAAC,EAAAe,EAAAC,EAAA3C,GACA,GAAA4lB,GAAA,EAAA5lB,CACA,OAAA,MAAA2B,EAAAD,GAAAkkB,EAAA,GAAAljB,EAAAf,GAAA3B,GAAA4lB,GAAAjjB,EAAAD,GAAA1C,EAAAA,GAeA,QAAA8lB,GAAApkB,EAAAC,EAAAe,EAAAC,EAAAlnB,EAAAsqC,GAEA,GAAAznB,GAAAqE,EAAA,GAAAhB,EAAAe,GAAAhB,EACAtC,EAAA,GAAAsD,EAAA,EAAAf,EAAAD,GACAtnC,EAAA,GAAAunC,EAAAD,GACA9B,EAAA8B,EAAAjmB,EACA8V,EAAA6N,EAAAA,EAAA,EAAAd,EAAAlkC,EACA2xC,EAAA3M,EAAAhlC,EAAA,EAAAkkC,EAAAsB,EACAvO,EAAAj3B,EAAAA,EAAA,EAAAglC,EAAAQ,EACAjxB,EAAA,CAEA,IAAAg3C,EAAAp0B,IAAAo0B,EAAA5Z,GACA,GAAA4Z,EAAAvmB,GACA2mB,EAAA,GAAA,MACK,CACL,GAAAC,IAAA5rD,EAAAglC,CAEA4mB,IAAA,GAAAA,GAAA,IACAD,EAAAp3C,KAAAq3C,OAGG,CACH,GAAAC,GAAAla,EAAAA,EAAA,EAAAxa,EAAAF,CAEA,IAAAs0B,EAAAM,GAAA,CACA,GAAAC,GAAAna,EAAAxa,EACAy0B,GAAA5mB,EAAAd,EAAA4nB,EAEAtjB,GAAAsjB,EAAA,CAEAF,IAAA,GAAAA,GAAA,IACAD,EAAAp3C,KAAAq3C,GAGApjB,GAAA,GAAAA,GAAA,IACAmjB,EAAAp3C,KAAAi0B,OAEK,IAAAqjB,EAAA,EAAA,CACL,GAAAE,GAAAz2B,EAAAu2B,GACAG,EAAA70B,EAAA6N,EAAA,IAAAd,IAAAyN,EAAAoa,GACAE,EAAA90B,EAAA6N,EAAA,IAAAd,IAAAyN,EAAAoa,EAGAC,GADAA,EAAA,GACAE,GAAAF,EAAAG,GAEAD,EAAAF,EAAAG,GAIAF,EADAA,EAAA,GACAC,GAAAD,EAAAE,GAEAD,EAAAD,EAAAE,EAGA,IAAAP,KAAA5mB,GAAAgnB,EAAAC,KAAA,EAAA/nB,EAEA0nB,IAAA,GAAAA,GAAA,IACAD,EAAAp3C,KAAAq3C,OAEK,CACL,GAAAQ,IAAA,EAAAj1B,EAAA6N,EAAA,EAAAd,EAAAyN,IAAA,EAAArc,EAAA6B,EAAAA,EAAAA,IACAzB,EAAA9iB,KAAA4lB,KAAA4zB,GAAA,EACAC,EAAA/2B,EAAA6B,GACAm1B,EAAA15C,KAAA0lB,IAAA5C,GACAk2B,IAAA5mB,EAAA,EAAAqnB,EAAAC,IAAA,EAAApoB,GACAsE,IAAAxD,EAAAqnB,GAAAC,EAAAC,EAAA35C,KAAAylB,IAAA3C,MAAA,EAAAwO,GACAuE,IAAAzD,EAAAqnB,GAAAC,EAAAC,EAAA35C,KAAAylB,IAAA3C,MAAA,EAAAwO,EAEA0nB,IAAA,GAAAA,GAAA,IACAD,EAAAp3C,KAAAq3C,GAGApjB,GAAA,GAAAA,GAAA,IACAmjB,EAAAp3C,KAAAi0B,GAGAC,GAAA,GAAAA,GAAA,IACAkjB,EAAAp3C,KAAAk0B,IAKA,MAAAl0B,GAcA,QAAAi4C,GAAAllB,EAAAC,EAAAe,EAAAC,EAAAkkB,GACA,GAAAznB,GAAA,EAAAsD,EAAA,GAAAf,EAAA,EAAAD,EACApD,EAAA,EAAAqD,EAAA,EAAAgB,EAAA,EAAAjB,EAAA,EAAAgB,EACAtoC,EAAA,EAAAunC,EAAA,EAAAD,EACA/yB,EAAA,CAEA,IAAAg3C,EAAArnB,IACA,GAAA1B,EAAAwC,GAAA,CACA,GAAA4mB,IAAA5rD,EAAAglC,CAEA4mB,IAAA,GAAAA,GAAA,IACAa,EAAAl4C,KAAAq3C,QAGG,CACH,GAAAC,GAAA7mB,EAAAA,EAAA,EAAAd,EAAAlkC,CAEA,IAAAurD,EAAAM,GACAY,EAAA,IAAAznB,GAAA,EAAAd,OACK,IAAA2nB,EAAA,EAAA,CACL,GAAAE,GAAAz2B,EAAAu2B,GACAD,IAAA5mB,EAAA+mB,IAAA,EAAA7nB,GACAsE,IAAAxD,EAAA+mB,IAAA,EAAA7nB,EAEA0nB,IAAA,GAAAA,GAAA,IACAa,EAAAl4C,KAAAq3C,GAGApjB,GAAA,GAAAA,GAAA,IACAikB,EAAAl4C,KAAAi0B,IAKA,MAAAj0B,GAcA,QAAAm4C,GAAAplB,EAAAC,EAAAe,EAAAC,EAAA3C,EAAArC,GACA,GAAAopB,IAAAplB,EAAAD,GAAA1B,EAAA0B,EACAslB,GAAAtkB,EAAAf,GAAA3B,EAAA2B,EACAslB,GAAAtkB,EAAAD,GAAA1C,EAAA0C,EACAwkB,GAAAF,EAAAD,GAAA/mB,EAAA+mB,EACAI,GAAAF,EAAAD,GAAAhnB,EAAAgnB,EACAI,GAAAD,EAAAD,GAAAlnB,EAAAknB,CAEAvpB,GAAA,GAAA+D,EACA/D,EAAA,GAAAopB,EACAppB,EAAA,GAAAupB,EACAvpB,EAAA,GAAAypB,EAEAzpB,EAAA,GAAAypB,EACAzpB,EAAA,GAAAwpB,EACAxpB,EAAA,GAAAspB,EACAtpB,EAAA,GAAAgF,EAoBA,QAAA0kB,GAAArD,EAAAC,EAAA50C,EAAAC,EAAAC,EAAAC,EAAA8zC,EAAAC,EAAAn4C,EAAAE,EAAAqyB,GAEA,GAAAqC,GAGAuX,EACAD,EACAgQ,EACAC,EALAC,EAAA,KACA5nB,EAAA6nB,EAAAA,CAKAC,GAAA,GAAAt8C,EACAs8C,EAAA,GAAAp8C,CAGA,KAAA,GAAAq8C,GAAA,EAAkBA,EAAA,EAAQA,GAAA,IAC1BC,EAAA,GAAAhD,EAAAZ,EAAA30C,EAAAE,EAAA+zC,EAAAqE,GACAC,EAAA,GAAAhD,EAAAX,EAAA30C,EAAAE,EAAA+zC,EAAAoE,GACAL,EAAAO,EAAAH,EAAAE,GAEAN,EAAA1nB,IACAI,EAAA2nB,EACA/nB,EAAA0nB,EAIA1nB,GAAA6nB,EAAAA,CAEA,KAAA,GAAAzgD,GAAA,EAAiBA,EAAA,MACjBwgD,EAAAM,GADyB9gD,IAKzBuwC,EAAAvX,EAAAwnB,EACAlQ,EAAAtX,EAAAwnB,EAEAI,EAAA,GAAAhD,EAAAZ,EAAA30C,EAAAE,EAAA+zC,EAAA/L,GACAqQ,EAAA,GAAAhD,EAAAX,EAAA30C,EAAAE,EAAA+zC,EAAAhM,GACA+P,EAAAO,EAAAD,EAAAF,GAEAnQ,GAAA,GAAA+P,EAAA1nB,GACAI,EAAAuX,EACA3X,EAAA0nB,IAGAS,EAAA,GAAAnD,EAAAZ,EAAA30C,EAAAE,EAAA+zC,EAAAhM,GACAyQ,EAAA,GAAAnD,EAAAX,EAAA30C,EAAAE,EAAA+zC,EAAAjM,GACAiQ,EAAAM,EAAAE,EAAAL,GAEApQ,GAAA,GAAAiQ,EAAA3nB,GACAI,EAAAsX,EACA1X,EAAA2nB,GAEAC,GAAA,GAYA,OANA7pB,KACAA,EAAA,GAAAinB,EAAAZ,EAAA30C,EAAAE,EAAA+zC,EAAAtjB,GACArC,EAAA,GAAAinB,EAAAX,EAAA30C,EAAAE,EAAA+zC,EAAAvjB,IAIAtQ,EAAAkQ,GAYA,QAAAooB,GAAAtmB,EAAAC,EAAAe,EAAA1C,GACA,GAAA4lB,GAAA,EAAA5lB,CACA,OAAA4lB,IAAAA,EAAAlkB,EAAA,EAAA1B,EAAA2B,GAAA3B,EAAAA,EAAA0C,EAYA,QAAAulB,GAAAvmB,EAAAC,EAAAe,EAAA1C,GACA,MAAA,KAAA,EAAAA,IAAA2B,EAAAD,GAAA1B,GAAA0C,EAAAf,IAaA,QAAAumB,GAAAxmB,EAAAC,EAAAe,EAAAjnB,EAAAsqC,GACA,GAAAznB,GAAAoD,EAAA,EAAAC,EAAAe,EACAtD,EAAA,GAAAuC,EAAAD,GACAtnC,EAAAsnC,EAAAjmB,EACA9M,EAAA,CAEA,IAAAg3C,EAAArnB,IACA,GAAA1B,EAAAwC,GAAA,CACA,GAAA4mB,IAAA5rD,EAAAglC,CAEA4mB,IAAA,GAAAA,GAAA,IACAD,EAAAp3C,KAAAq3C,QAGG,CACH,GAAAC,GAAA7mB,EAAAA,EAAA,EAAAd,EAAAlkC,CAEA,IAAAurD,EAAAM,GAAA,CACA,GAAAD,IAAA5mB,GAAA,EAAAd,EAEA0nB,IAAA,GAAAA,GAAA,IACAD,EAAAp3C,KAAAq3C,OAEK,IAAAC,EAAA,EAAA,CACL,GAAAE,GAAAz2B,EAAAu2B,GACAD,IAAA5mB,EAAA+mB,IAAA,EAAA7nB,GACAsE,IAAAxD,EAAA+mB,IAAA,EAAA7nB,EAEA0nB,IAAA,GAAAA,GAAA,IACAD,EAAAp3C,KAAAq3C,GAGApjB,GAAA,GAAAA,GAAA,IACAmjB,EAAAp3C,KAAAi0B,IAKA,MAAAj0B,GAYA,QAAAw5C,GAAAzmB,EAAAC,EAAAe,GACA,GAAA0lB,GAAA1mB,EAAAgB,EAAA,EAAAf,CAEA,OAAA,KAAAymB,EAEA,IAEA1mB,EAAAC,GAAAymB,EAcA,QAAAC,GAAA3mB,EAAAC,EAAAe,EAAA1C,EAAArC,GACA,GAAAopB,IAAAplB,EAAAD,GAAA1B,EAAA0B,EACAslB,GAAAtkB,EAAAf,GAAA3B,EAAA2B,EACAulB,GAAAF,EAAAD,GAAA/mB,EAAA+mB,CAEAppB,GAAA,GAAA+D,EACA/D,EAAA,GAAAopB,EACAppB,EAAA,GAAAupB,EAEAvpB,EAAA,GAAAupB,EACAvpB,EAAA,GAAAqpB,EACArpB,EAAA,GAAA+E,EAkBA,QAAA4lB,GAAAtE,EAAAC,EAAA50C,EAAAC,EAAAC,EAAAC,EAAApE,EAAAE,EAAAqyB,GAEA,GAAAqC,GACAwnB,EAAA,KACA5nB,EAAA6nB,EAAAA,CACAC,GAAA,GAAAt8C,EACAs8C,EAAA,GAAAp8C,CAGA,KAAA,GAAAq8C,GAAA,EAAkBA,EAAA,EAAQA,GAAA,IAAA,CAC1BC,EAAA,GAAAI,EAAAhE,EAAA30C,EAAAE,EAAAo4C,GACAC,EAAA,GAAAI,EAAA/D,EAAA30C,EAAAE,EAAAm4C,EACA,IAAAL,GAAAO,EAAAH,EAAAE,EAEAN,GAAA1nB,IACAI,EAAA2nB,EACA/nB,EAAA0nB,GAIA1nB,EAAA6nB,EAAAA,CAEA,KAAA,GAAAzgD,GAAA,EAAiBA,EAAA,MACjBwgD,EAAAM,GADyB9gD,IAAA,CAKzB,GAAAuwC,GAAAvX,EAAAwnB,EACAlQ,EAAAtX,EAAAwnB,CAEAI,GAAA,GAAAI,EAAAhE,EAAA30C,EAAAE,EAAAgoC,GACAqQ,EAAA,GAAAI,EAAA/D,EAAA30C,EAAAE,EAAA+nC,EACA,IAAA+P,GAAAO,EAAAD,EAAAF,EAEA,IAAAnQ,GAAA,GAAA+P,EAAA1nB,EACAI,EAAAuX,EACA3X,EAAA0nB,MACK,CAELS,EAAA,GAAAC,EAAAhE,EAAA30C,EAAAE,EAAA+nC,GACAyQ,EAAA,GAAAC,EAAA/D,EAAA30C,EAAAE,EAAA8nC,EACA,IAAAiQ,GAAAM,EAAAE,EAAAL,EAEApQ,IAAA,GAAAiQ,EAAA3nB,GACAI,EAAAsX,EACA1X,EAAA2nB,GAEAC,GAAA,IAYA,MANA7pB,KACAA,EAAA,GAAAqqB,EAAAhE,EAAA30C,EAAAE,EAAAywB,GACArC,EAAA,GAAAqqB,EAAA/D,EAAA30C,EAAAE,EAAAwwB,IAIAtQ,EAAAkQ,GArgBA,GAAA2oB,GAAA1uD,EAAA,IAEA2uD,EAAAD,EAAArrB,OACA2qB,EAAAU,EAAApoB,WAOAmmB,EAAAt5C,KAAA4D,IACA8e,EAAA1iB,KAAA2D,KACAksB,EAAA,KACAirB,EAAA,KACAnB,EAAAj3B,EAAA,GACA62B,EAAA,EAAA,EAEAmB,EAAAc,IAEAZ,EAAAY,IAEAT,EAAAS,GAmfAjvD,GAAAqrD,QAAAA,EACArrD,EAAAssD,kBAAAA,EACAtsD,EAAAusD,YAAAA,EACAvsD,EAAAqtD,aAAAA,EACArtD,EAAAutD,eAAAA,EACAvtD,EAAA8tD,kBAAAA,EACA9tD,EAAAyuD,YAAAA,EACAzuD,EAAA0uD,sBAAAA,EACA1uD,EAAA2uD,gBAAAA,EACA3uD,EAAA4uD,kBAAAA,EACA5uD,EAAA8uD,mBAAAA,EACA9uD,EAAA+uD,sBAAAA,GhCgvXM,SAAU9uD,EAAQD,EAASM,GiC5uYjC,QAAA4uD,GAAA/rC,EAAAkB,EAAAC,GACA,GAAA,IAAAnB,EAAA5c,OAAA,CAIA,GAKAkH,GALA3M,EAAAqiB,EAAA,GACAnQ,EAAAlS,EAAA,GACAmS,EAAAnS,EAAA,GACAoS,EAAApS,EAAA,GACAqS,EAAArS,EAAA,EAGA,KAAA2M,EAAA,EAAaA,EAAA0V,EAAA5c,OAAmBkH,IAChC3M,EAAAqiB,EAAA1V,GACAuF,EAAAozC,EAAApzC,EAAAlS,EAAA,IACAmS,EAAAozC,EAAApzC,EAAAnS,EAAA,IACAoS,EAAAkzC,EAAAlzC,EAAApS,EAAA,IACAqS,EAAAkzC,EAAAlzC,EAAArS,EAAA,GAGAujB,GAAA,GAAArR,EACAqR,EAAA,GAAAnR,EACAoR,EAAA,GAAArR,EACAqR,EAAA,GAAAnR,GAaA,QAAAw4C,GAAAlB,EAAAC,EAAA50C,EAAAC,EAAAsO,EAAAC,GACAD,EAAA,GAAA+hC,EAAAqE,EAAA30C,GACAuO,EAAA,GAAA+hC,EAAAsE,EAAA30C,GACAuO,EAAA,GAAA+hC,EAAAoE,EAAA30C,GACAwO,EAAA,GAAA+hC,EAAAqE,EAAA30C,GAoBA,QAAA61C,GAAAnB,EAAAC,EAAA50C,EAAAC,EAAAC,EAAAC,EAAA8zC,EAAAC,EAAA3lC,EAAAC,GACA,GAEA7W,GAFA4/C,EAAA5E,EAAA4E,aACAhC,EAAA5C,EAAA4C,QAEAj2C,EAAAi4C,EAAA5C,EAAA30C,EAAAE,EAAA+zC,EAAAoF,EAMA,KALA9qC,EAAA,GAAA6pC,EAAAA,EACA7pC,EAAA,GAAA6pC,EAAAA,EACA5pC,EAAA,KAAA4pC,EAAAA,GACA5pC,EAAA,KAAA4pC,EAAAA,GAEAzgD,EAAA,EAAaA,EAAA2H,EAAO3H,IAAA,CACpB,GAAAoE,GAAAw5C,EAAAZ,EAAA30C,EAAAE,EAAA+zC,EAAAoF,EAAA1hD,GACA4W,GAAA,GAAA+hC,EAAAv0C,EAAAwS,EAAA,IACAC,EAAA,GAAA+hC,EAAAx0C,EAAAyS,EAAA,IAKA,IAFAlP,EAAAi4C,EAAA3C,EAAA30C,EAAAE,EAAA+zC,EAAAoF,GAEA3hD,EAAA,EAAaA,EAAA2H,EAAO3H,IAAA,CACpB,GAAAsE,GAAAs5C,EAAAX,EAAA30C,EAAAE,EAAA+zC,EAAAoF,EAAA3hD,GACA4W,GAAA,GAAA+hC,EAAAr0C,EAAAsS,EAAA,IACAC,EAAA,GAAA+hC,EAAAt0C,EAAAuS,EAAA,IAGAD,EAAA,GAAA+hC,EAAAqE,EAAApmC,EAAA,IACAC,EAAA,GAAA+hC,EAAAoE,EAAAnmC,EAAA,IACAD,EAAA,GAAA+hC,EAAA2D,EAAA1lC,EAAA,IACAC,EAAA,GAAA+hC,EAAA0D,EAAAzlC,EAAA,IACAD,EAAA,GAAA+hC,EAAAsE,EAAArmC,EAAA,IACAC,EAAA,GAAA+hC,EAAAqE,EAAApmC,EAAA,IACAD,EAAA,GAAA+hC,EAAA4D,EAAA3lC,EAAA,IACAC,EAAA,GAAA+hC,EAAA2D,EAAA1lC,EAAA,IAgBA,QAAAunC,GAAApB,EAAAC,EAAA50C,EAAAC,EAAAC,EAAAC,EAAAoO,EAAAC,GACA,GAAAsqC,GAAAnG,EAAAmG,kBACAH,EAAAhG,EAAAgG,YAEAY,EAAAhJ,EAAAD,EAAAwI,EAAAnE,EAAA30C,EAAAE,GAAA,GAAA,GACAs5C,EAAAjJ,EAAAD,EAAAwI,EAAAlE,EAAA30C,EAAAE,GAAA,GAAA,GACApE,EAAA48C,EAAAhE,EAAA30C,EAAAE,EAAAq5C,GACAt9C,EAAA08C,EAAA/D,EAAA30C,EAAAE,EAAAq5C,EACAjrC,GAAA,GAAA+hC,EAAAqE,EAAAz0C,EAAAnE,GACAwS,EAAA,GAAA+hC,EAAAsE,EAAAz0C,EAAAlE,GACAuS,EAAA,GAAA+hC,EAAAoE,EAAAz0C,EAAAnE,GACAyS,EAAA,GAAA+hC,EAAAqE,EAAAz0C,EAAAlE,GAkBA,QAAA+5C,GAAAj6C,EAAAE,EAAA0jB,EAAAC,EAAA00B,EAAAC,EAAAC,EAAAjmC,EAAAC,GACA,GAAAirC,GAAArJ,EAAA7hC,IACAmrC,EAAAtJ,EAAA5hC,IACAmrC,EAAAh8C,KAAAC,IAAA02C,EAAAC,EAEA,IAAAoF,EAAAC,EAAA,MAAAD,EAAA,KAMA,MAJAprC,GAAA,GAAAxS,EAAA4jB,EACApR,EAAA,GAAAtS,EAAA2jB,EACApR,EAAA,GAAAzS,EAAA4jB,OACAnR,EAAA,GAAAvS,EAAA2jB,EA6BA,IAzBA7gB,EAAA,GAAAkhB,EAAAq0B,GAAA30B,EAAA5jB,EACAgD,EAAA,GAAAmhB,EAAAo0B,GAAA10B,EAAA3jB,EACA+C,EAAA,GAAAihB,EAAAs0B,GAAA50B,EAAA5jB,EACAiD,EAAA,GAAAkhB,EAAAq0B,GAAA30B,EAAA3jB,EACAw9C,EAAAlrC,EAAAxP,EAAAC,GACA06C,EAAAlrC,EAAAzP,EAAAC,GAEAs1C,GAAAsF,EAEAtF,EAAA,IACAA,GAAAsF,GAGArF,GAAAqF,EAEArF,EAAA,IACAA,GAAAqF,GAGAtF,EAAAC,IAAAC,EACAD,GAAAqF,EACGtF,EAAAC,GAAAC,IACHF,GAAAsF,GAGApF,EAAA,CACA,GAAA6C,GAAA9C,CACAA,GAAAD,EACAA,EAAA+C,EAKA,IAAA,GAAAj4C,GAAA,EAAqBA,EAAAm1C,EAAkBn1C,GAAAzB,KAAA0B,GAAA,EACvCD,EAAAk1C,IACAuF,EAAA,GAAA55B,EAAA7gB,GAAAugB,EAAA5jB,EACA89C,EAAA,GAAA35B,EAAA9gB,GAAAwgB,EAAA3jB,EACAw9C,EAAAlrC,EAAAsrC,EAAAtrC,GACAmrC,EAAAlrC,EAAAqrC,EAAArrC,IAnNA,GAAA4hC,GAAA5lD,EAAA,IAEAmoD,EAAAnoD,EAAA,IAKA8lD,EAAA3yC,KAAA4Q,IACAgiC,EAAA5yC,KAAA6Q,IACA0R,EAAAviB,KAAAylB,IACAnD,EAAAtiB,KAAA0lB,IACAu2B,EAAA,EAAAj8C,KAAA0B,GACAN,EAAAqxC,EAAAviB,SACA7uB,EAAAoxC,EAAAviB,SACAgsB,EAAAzJ,EAAAviB,SAoDAwrB,KACAC,IAqJApvD,GAAAkvD,WAAAA,EACAlvD,EAAA2rD,SAAAA,EACA3rD,EAAA4rD,UAAAA,EACA5rD,EAAA6rD,cAAAA,EACA7rD,EAAA8rD,QAAAA,GjCywYM,SAAU7rD,EAAQD,EAASM,GkC/8YjC,QAAAsvD,GAAA7qB,EAAAc,GACA,MAAApyB,MAAAC,IAAAqxB,EAAAc,GAAAvC,EAOA,QAAAusB,KACA,GAAA1C,GAAAG,EAAA,EACAA,GAAA,GAAAA,EAAA,GACAA,EAAA,GAAAH,EAGA,QAAA2C,GAAArF,EAAAC,EAAA50C,EAAAC,EAAAC,EAAAC,EAAA8zC,EAAAC,EAAAn4C,EAAAE,GAEA,GAAAA,EAAA24C,GAAA34C,EAAAgE,GAAAhE,EAAAkE,GAAAlE,EAAAi4C,GAAAj4C,EAAA24C,GAAA34C,EAAAgE,GAAAhE,EAAAkE,GAAAlE,EAAAi4C,EACA,MAAA,EAGA,IAAA+F,GAAAtH,EAAA8D,YAAA7B,EAAA30C,EAAAE,EAAA+zC,EAAAj4C,EAAAy6C,EAEA,IAAA,IAAAuD,EACA,MAAA,EAMA,KAAA,GAFAC,GAAAC,EAFAt0B,EAAA,EACAu0B,KAGAziD,EAAA,EAAmBA,EAAAsiD,EAAYtiD,IAAA,CAC/B,GAAAg5B,GAAA+lB,EAAA/+C,GAEA0iD,EAAA,IAAA1pB,GAAA,IAAAA,EAAA,GAAA,EACA2pB,EAAA3H,EAAA4C,QAAAZ,EAAA30C,EAAAE,EAAA+zC,EAAAtjB,EAEA2pB,GAAAv+C,IAKAq+C,EAAA,IACAA,EAAAzH,EAAA4E,aAAA3C,EAAA30C,EAAAE,EAAA+zC,EAAAsD,GAEAA,EAAA,GAAAA,EAAA,IAAA4C,EAAA,GACAL,IAGAG,EAAAvH,EAAA4C,QAAAX,EAAA30C,EAAAE,EAAA+zC,EAAAsD,EAAA,IAEA4C,EAAA,IACAD,EAAAxH,EAAA4C,QAAAX,EAAA30C,EAAAE,EAAA+zC,EAAAsD,EAAA,MAOA3xB,GAHA,GAAAu0B,EAEAzpB,EAAA6mB,EAAA,GACA0C,EAAAtF,EAAAyF,GAAAA,EACS1pB,EAAA6mB,EAAA,GACT2C,EAAAD,EAAAG,GAAAA,EAEAnG,EAAAiG,EAAAE,GAAAA,EAIA1pB,EAAA6mB,EAAA,GACA0C,EAAAtF,EAAAyF,GAAAA,EAEAnG,EAAAgG,EAAAG,GAAAA,GAKA,MAAAx0B,GAIA,QAAA00B,GAAA5F,EAAAC,EAAA50C,EAAAC,EAAAC,EAAAC,EAAApE,EAAAE,GAEA,GAAAA,EAAA24C,GAAA34C,EAAAgE,GAAAhE,EAAAkE,GAAAlE,EAAA24C,GAAA34C,EAAAgE,GAAAhE,EAAAkE,EACA,MAAA,EAGA,IAAA85C,GAAAtH,EAAAkG,gBAAAjE,EAAA30C,EAAAE,EAAAlE,EAAAy6C,EAEA,IAAA,IAAAuD,EACA,MAAA,EAEA,IAAAtpB,GAAAgiB,EAAAmG,kBAAAlE,EAAA30C,EAAAE,EAEA,IAAAwwB,GAAA,GAAAA,GAAA,EAAA,CAIA,IAAA,GAHA9K,GAAA,EACA20B,EAAA7H,EAAAgG,YAAA/D,EAAA30C,EAAAE,EAAAwwB,GAEAh5B,EAAA,EAAqBA,EAAAsiD,EAAYtiD,IAAA,CAEjC,GAAA0iD,GAAA,IAAA3D,EAAA/+C,IAAA,IAAA++C,EAAA/+C,GAAA,GAAA,EACA2iD,EAAA3H,EAAAgG,YAAAhE,EAAA30C,EAAAE,EAAAw2C,EAAA/+C,GAEA2iD,GAAAv+C,IAMA8pB,GADA6wB,EAAA/+C,GAAAg5B,EACA6pB,EAAA5F,EAAAyF,GAAAA,EAEAl6C,EAAAq6C,EAAAH,GAAAA,GAIA,MAAAx0B,GAGA,GAAAw0B,GAAA,IAAA3D,EAAA,IAAA,IAAAA,EAAA,GAAA,GAAA,EACA4D,EAAA3H,EAAAgG,YAAAhE,EAAA30C,EAAAE,EAAAw2C,EAAA,GAEA,OAAA4D,GAAAv+C,EAEA,EAGAoE,EAAAy0C,EAAAyF,GAAAA,EAOA,QAAAI,GAAA3+C,EAAAE,EAAAE,EAAAo4C,EAAAC,EAAAC,EAAAz4C,EAAAE,GAGA,GAFAA,GAAAD,EAEAC,EAAAC,GAAAD,GAAAC,EACA,MAAA,EAGA,IAAAm7C,GAAA15C,KAAA2D,KAAApF,EAAAA,EAAAD,EAAAA,EACAy6C,GAAA,IAAAW,EACAX,EAAA,GAAAW,CACA,IAAAsC,GAAAh8C,KAAAC,IAAA02C,EAAAC,EAEA,IAAAoF,EAAA,KACA,MAAA,EAGA,IAAAA,EAAAC,EAAA,KAAA,CAEAtF,EAAA,EACAC,EAAAqF,CACA,IAAAc,GAAAlG,EAAA,IAEA,OAAAz4C,IAAA26C,EAAA,GAAA56C,GAAAC,GAAA26C,EAAA,GAAA56C,EACA4+C,EAEA,EAIA,GAAAlG,EAAA,CACA,GAAA6C,GAAA/C,CACAA,GAAAqG,EAAApG,GACAA,EAAAoG,EAAAtD,OAEA/C,GAAAqG,EAAArG,GACAC,EAAAoG,EAAApG,EAGAD,GAAAC,IACAA,GAAAqF,EAKA,KAAA,GAFA/zB,GAAA,EAEAluB,EAAA,EAAiBA,EAAA,EAAOA,IAAA,CACxB,GAAA2iD,GAAA5D,EAAA/+C,EAEA,IAAA2iD,EAAAx+C,EAAAC,EAAA,CACA,GAAAqD,GAAAzB,KAAAqE,MAAA/F,EAAAq+C,GACAI,EAAAlG,EAAA,IAEAp1C,GAAA,IACAA,EAAAw6C,EAAAx6C,IAGAA,GAAAk1C,GAAAl1C,GAAAm1C,GAAAn1C,EAAAw6C,GAAAtF,GAAAl1C,EAAAw6C,GAAArF,KACAn1C,EAAAzB,KAAA0B,GAAA,GAAAD,EAAA,IAAAzB,KAAA0B,KACAq7C,GAAAA,GAGA70B,GAAA60B,IAKA,MAAA70B,GAGA,QAAA+0B,GAAA92C,EAAA1D,EAAAy6C,EAAA9+C,EAAAE,GAOA,IAAA,GANA4pB,GAAA,EACA8vB,EAAA,EACAC,EAAA,EACAjB,EAAA,EACAC,EAAA,EAEAj9C,EAAA,EAAiBA,EAAAmM,EAAArT,QAAiB,CAClC,GAAAqvB,GAAAhc,EAAAnM,IAwBA,QAtBAmoB,IAAA0B,EAAAO,GAAApqB,EAAA,IAEAkjD,IACAh1B,GAAAi1B,EAAAnF,EAAAC,EAAAjB,EAAAC,EAAA74C,EAAAE,KAQA,GAAAtE,IAKAg+C,EAAA7xC,EAAAnM,GACAi+C,EAAA9xC,EAAAnM,EAAA,GACAg9C,EAAAgB,EACAf,EAAAgB,GAGA91B,GACA,IAAA0B,GAAAO,EAGA4yB,EAAA7wC,EAAAnM,KACAi9C,EAAA9wC,EAAAnM,KACAg+C,EAAAhB,EACAiB,EAAAhB,CACA,MAEA,KAAApzB,GAAAM,EACA,GAAA+4B,GACA,GAAAjkD,EAAAwvB,cAAAuvB,EAAAC,EAAA9xC,EAAAnM,GAAAmM,EAAAnM,EAAA,GAAAyI,EAAArE,EAAAE,GACA,OAAA,MAIA4pB,IAAAi1B,EAAAnF,EAAAC,EAAA9xC,EAAAnM,GAAAmM,EAAAnM,EAAA,GAAAoE,EAAAE,IAAA,CAGA05C,GAAA7xC,EAAAnM,KACAi+C,EAAA9xC,EAAAnM,IACA,MAEA,KAAA6pB,GAAAQ,EACA,GAAA64B,GACA,GAAAE,EAAA30B,cAAAuvB,EAAAC,EAAA9xC,EAAAnM,KAAAmM,EAAAnM,KAAAmM,EAAAnM,KAAAmM,EAAAnM,KAAAmM,EAAAnM,GAAAmM,EAAAnM,EAAA,GAAAyI,EAAArE,EAAAE,GACA,OAAA,MAGA4pB,IAAAm0B,EAAArE,EAAAC,EAAA9xC,EAAAnM,KAAAmM,EAAAnM,KAAAmM,EAAAnM,KAAAmM,EAAAnM,KAAAmM,EAAAnM,GAAAmM,EAAAnM,EAAA,GAAAoE,EAAAE,IAAA,CAGA05C,GAAA7xC,EAAAnM,KACAi+C,EAAA9xC,EAAAnM,IACA,MAEA,KAAA6pB,GAAAS,EACA,GAAA44B,GACA,GAAAG,EAAA50B,cAAAuvB,EAAAC,EAAA9xC,EAAAnM,KAAAmM,EAAAnM,KAAAmM,EAAAnM,GAAAmM,EAAAnM,EAAA,GAAAyI,EAAArE,EAAAE,GACA,OAAA,MAGA4pB,IAAA00B,EAAA5E,EAAAC,EAAA9xC,EAAAnM,KAAAmM,EAAAnM,KAAAmM,EAAAnM,GAAAmM,EAAAnM,EAAA,GAAAoE,EAAAE,IAAA,CAGA05C,GAAA7xC,EAAAnM,KACAi+C,EAAA9xC,EAAAnM,IACA,MAEA,KAAA6pB,GAAAU,EAEA,GAAApmB,GAAAgI,EAAAnM,KACAqE,EAAA8H,EAAAnM,KACAgoB,EAAA7b,EAAAnM,KACAioB,EAAA9b,EAAAnM,KACA8oB,EAAA3c,EAAAnM,KACAipB,EAAA9c,EAAAnM,KAGA68C,GADA1wC,EAAAnM,KACA,EAAAmM,EAAAnM,MACAqI,EAAArC,KAAA0lB,IAAA5C,GAAAd,EAAA7jB,EACAmE,EAAAtC,KAAAylB,IAAA3C,GAAAb,EAAA5jB,CAEArE,GAAA,EACAkuB,GAAAi1B,EAAAnF,EAAAC,EAAA51C,EAAAC,EAAAlE,EAAAE,IAGA04C,EAAA30C,EACA40C,EAAA30C,EAIA,IAAAg7C,IAAAl/C,EAAAD,GAAA8jB,EAAAD,EAAA7jB,CAEA,IAAA++C,GACA,GAAAxG,EAAAjuB,cAAAtqB,EAAAE,EAAA4jB,EAAAa,EAAAA,EAAAG,EAAA4zB,EAAAp0C,EAAA66C,EAAAh/C,GACA,OAAA,MAGA4pB,IAAA40B,EAAA3+C,EAAAE,EAAA4jB,EAAAa,EAAAA,EAAAG,EAAA4zB,EAAAyG,EAAAh/C,EAGA05C,GAAAh4C,KAAA0lB,IAAA5C,EAAAG,GAAAjB,EAAA7jB,EACA85C,EAAAj4C,KAAAylB,IAAA3C,EAAAG,GAAAhB,EAAA5jB,CACA,MAEA,KAAAwlB,GAAAgb,EACAmY,EAAAgB,EAAA7xC,EAAAnM,KACAi9C,EAAAgB,EAAA9xC,EAAAnM,IACA,IAAA4B,GAAAuK,EAAAnM,KACA6B,EAAAsK,EAAAnM,KACAqI,EAAA20C,EAAAp7C,EACA0G,EAAA20C,EAAAp7C,CAEA,IAAAqhD,GACA,GAAAjkD,EAAAwvB,cAAAuuB,EAAAC,EAAA50C,EAAA40C,EAAAx0C,EAAArE,EAAAE,IAAArF,EAAAwvB,cAAApmB,EAAA40C,EAAA50C,EAAAC,EAAAG,EAAArE,EAAAE,IAAArF,EAAAwvB,cAAApmB,EAAAC,EAAA00C,EAAA10C,EAAAG,EAAArE,EAAAE,IAAArF,EAAAwvB,cAAAuuB,EAAA10C,EAAA00C,EAAAC,EAAAx0C,EAAArE,EAAAE,GACA,OAAA,MAIA4pB,IAAAi1B,EAAA96C,EAAA40C,EAAA50C,EAAAC,EAAAlE,EAAAE,GACA4pB,GAAAi1B,EAAAnG,EAAA10C,EAAA00C,EAAAC,EAAA74C,EAAAE,EAGA,MAEA,KAAAulB,GAAAW,EACA,GAAA04B,GACA,GAAAjkD,EAAAwvB,cAAAuvB,EAAAC,EAAAjB,EAAAC,EAAAx0C,EAAArE,EAAAE,GACA,OAAA,MAIA4pB,IAAAi1B,EAAAnF,EAAAC,EAAAjB,EAAAC,EAAA74C,EAAAE,EAOA05C,GAAAhB,EACAiB,EAAAhB,GASA,MAJAiG,IAAAf,EAAAlE,EAAAhB,KACA/uB,GAAAi1B,EAAAnF,EAAAC,EAAAjB,EAAAC,EAAA74C,EAAAE,IAAA,GAGA,IAAA4pB,EAGA,QAAAI,GAAA/O,EAAAnb,EAAAE,GACA,MAAA2+C,GAAA1jC,EAAA,GAAA,EAAAnb,EAAAE,GAGA,QAAAmqB,GAAAlP,EAAA9W,EAAArE,EAAAE,GACA,MAAA2+C,GAAA1jC,EAAA9W,GAAA,EAAArE,EAAAE,GAtYA,GAAAslB,GAAA/2B,EAAA,IAEAoM,EAAApM,EAAA,IAEAuwD,EAAAvwD,EAAA,IAEAwwD,EAAAxwD,EAAA,IAEA6pD,EAAA7pD,EAAA,IAEAymC,EAAAzmC,EAAA,IAEAmwD,EAAA1pB,EAAA0pB,gBAEAhI,EAAAnoD,EAAA,IAEAswD,EAAAtwD,EAAA,IAEAg3B,EAAAD,EAAAC,IACAo4B,EAAA,EAAAj8C,KAAA0B,GACAmuB,EAAA,KAOAkpB,aACAc,SA6WAttD,GAAA+7B,QAAAA,EACA/7B,EAAAk8B,cAAAA,GlC2+YM,SAAUj8B,EAAQD,GmC12ZxB,QAAAk8B,GAAAuuB,EAAAC,EAAA50C,EAAAC,EAAAG,EAAArE,EAAAE,GACA,GAAA,IAAAmE,EACA,OAAA,CAGA,IAAA86C,GAAA96C,EACA+6C,EAAA,EACAC,EAAAzG,CAEA,IAAA14C,EAAA24C,EAAAsG,GAAAj/C,EAAAgE,EAAAi7C,GAAAj/C,EAAA24C,EAAAsG,GAAAj/C,EAAAgE,EAAAi7C,GAAAn/C,EAAA44C,EAAAuG,GAAAn/C,EAAAiE,EAAAk7C,GAAAn/C,EAAA44C,EAAAuG,GAAAn/C,EAAAiE,EAAAk7C,EACA,OAAA,CAGA,IAAAvG,IAAA30C,EAIA,MAAArC,MAAAC,IAAA7B,EAAA44C,IAAAuG,EAAA,CAHAC,IAAAvG,EAAA30C,IAAA00C,EAAA30C,GACAo7C,GAAAzG,EAAA10C,EAAAD,EAAA40C,IAAAD,EAAA30C,EAKA,IAAAq3C,GAAA8D,EAAAp/C,EAAAE,EAAAm/C,EAEAC,EAAAhE,EAAAA,GAAA8D,EAAAA,EAAA,EAEA,OAAAE,IAAAH,EAAA,EAAAA,EAAA,EAGAhxD,EAAAk8B,cAAAA,GnC23ZM,SAAUj8B,EAAQD,EAASM,GoCh5ZjC,QAAA47B,GAAAuuB,EAAAC,EAAA50C,EAAAC,EAAAC,EAAAC,EAAA8zC,EAAAC,EAAA9zC,EAAArE,EAAAE,GACA,GAAA,IAAAmE,EACA,OAAA,CAGA,IAAA86C,GAAA96C,CAEA,IAAAnE,EAAA24C,EAAAsG,GAAAj/C,EAAAgE,EAAAi7C,GAAAj/C,EAAAkE,EAAA+6C,GAAAj/C,EAAAi4C,EAAAgH,GAAAj/C,EAAA24C,EAAAsG,GAAAj/C,EAAAgE,EAAAi7C,GAAAj/C,EAAAkE,EAAA+6C,GAAAj/C,EAAAi4C,EAAAgH,GAAAn/C,EAAA44C,EAAAuG,GAAAn/C,EAAAiE,EAAAk7C,GAAAn/C,EAAAmE,EAAAg7C,GAAAn/C,EAAAk4C,EAAAiH,GAAAn/C,EAAA44C,EAAAuG,GAAAn/C,EAAAiE,EAAAk7C,GAAAn/C,EAAAmE,EAAAg7C,GAAAn/C,EAAAk4C,EAAAiH,EACA,OAAA,CAGA,IAAA3qB,GAAAoiB,EAAAqF,kBAAArD,EAAAC,EAAA50C,EAAAC,EAAAC,EAAAC,EAAA8zC,EAAAC,EAAAn4C,EAAAE,EAAA,KACA,OAAAs0B,IAAA2qB,EAAA,EA7BA,GAAAvI,GAAAnoD,EAAA,GAgCAN,GAAAk8B,cAAAA,GpCu6ZM,SAAUj8B,EAAQD,EAASM,GqCt7ZjC,QAAA47B,GAAAuuB,EAAAC,EAAA50C,EAAAC,EAAAC,EAAAC,EAAAC,EAAArE,EAAAE,GACA,GAAA,IAAAmE,EACA,OAAA,CAGA,IAAA86C,GAAA96C,CAEA,IAAAnE,EAAA24C,EAAAsG,GAAAj/C,EAAAgE,EAAAi7C,GAAAj/C,EAAAkE,EAAA+6C,GAAAj/C,EAAA24C,EAAAsG,GAAAj/C,EAAAgE,EAAAi7C,GAAAj/C,EAAAkE,EAAA+6C,GAAAn/C,EAAA44C,EAAAuG,GAAAn/C,EAAAiE,EAAAk7C,GAAAn/C,EAAAmE,EAAAg7C,GAAAn/C,EAAA44C,EAAAuG,GAAAn/C,EAAAiE,EAAAk7C,GAAAn/C,EAAAmE,EAAAg7C,EACA,OAAA,CAGA,IAAA3qB,GAAA0oB,EAAAtE,EAAAC,EAAA50C,EAAAC,EAAAC,EAAAC,EAAApE,EAAAE,EAAA,KACA,OAAAs0B,IAAA2qB,EAAA,EA7BA,GAAAI,GAAA9wD,EAAA,IAEAyuD,EAAAqC,EAAArC,qBA8BA/uD,GAAAk8B,cAAAA,GrC68ZM,SAAUj8B,EAAQD,EAASM,GsC39ZjC,QAAA47B,GAAAtqB,EAAAE,EAAAE,EAAAo4C,EAAAC,EAAAC,EAAAp0C,EAAArE,EAAAE,GACA,GAAA,IAAAmE,EACA,OAAA,CAGA,IAAA86C,GAAA96C,CACArE,IAAAD,EACAG,GAAAD,CACA,IAAAu0B,GAAA5yB,KAAA2D,KAAAvF,EAAAA,EAAAE,EAAAA,EAEA,IAAAs0B,EAAA2qB,EAAAh/C,GAAAq0B,EAAA2qB,EAAAh/C,EACA,OAAA,CAGA,IAAAyB,KAAAC,IAAA02C,EAAAC,GAAAqF,EAAA,KAEA,OAAA,CAGA,IAAApF,EAAA,CACA,GAAA6C,GAAA/C,CACAA,GAAAqG,EAAApG,GACAA,EAAAoG,EAAAtD,OAEA/C,GAAAqG,EAAArG,GACAC,EAAAoG,EAAApG,EAGAD,GAAAC,IACAA,GAAAqF,EAGA,IAAAx6C,GAAAzB,KAAAqE,MAAA/F,EAAAF,EAMA,OAJAqD,GAAA,IACAA,GAAAw6C,GAGAx6C,GAAAk1C,GAAAl1C,GAAAm1C,GAAAn1C,EAAAw6C,GAAAtF,GAAAl1C,EAAAw6C,GAAArF,EAxDA,GAAAtjB,GAAAzmC,EAAA,IAEAmwD,EAAA1pB,EAAA0pB,gBACAf,EAAA,EAAAj8C,KAAA0B,EAwDAnV,GAAAk8B,cAAAA,GtCm/ZM,SAAUj8B,EAAQD,GuC5iaxB,QAAAywD,GAAAv7C,GAOA,MANAA,IAAAw6C,EAEAx6C,EAAA,IACAA,GAAAw6C,GAGAx6C,EATA,GAAAw6C,GAAA,EAAAj8C,KAAA0B,EAYAnV,GAAAywD,gBAAAA,GvCojaM,SAAUxwD,EAAQD,GwChkaxB,QAAA4wD,GAAAnG,EAAAC,EAAA50C,EAAAC,EAAAlE,EAAAE,GACA,GAAAA,EAAA24C,GAAA34C,EAAAgE,GAAAhE,EAAA24C,GAAA34C,EAAAgE,EACA,MAAA,EAIA,IAAAA,IAAA20C,EACA,MAAA,EAGA,IAAA8F,GAAAz6C,EAAA20C,EAAA,KACAjkB,GAAA10B,EAAA24C,IAAA30C,EAAA20C,EAEA,KAAAjkB,GAAA,IAAAA,IACA+pB,EAAAz6C,EAAA20C,EAAA,OAGA,IAAA0F,GAAA3pB,GAAA3wB,EAAA20C,GAAAA,CACA,OAAA2F,GAAAv+C,EAAA2+C,EAAA,EAGAvwD,EAAAD,QAAA4wD,GxCskaM,SAAU3wD,EAAQD,GyC3laxB,GAAAw5B,GAAA,SAAAtuB,EAAAmmD,GAGAjxD,KAAA8K,MAAAA,EACA9K,KAAAixD,OAAAA,EAEAjxD,KAAA8F,KAAA,UAGAszB,GAAAl0B,UAAAm0B,iBAAA,SAAAlB,GACA,MAAAA,GAAA+4B,cAAAlxD,KAAA8K,MAAA9K,KAAAixD,QAAA,UAGA,IAAAt0B,GAAAvD,CACAv5B,GAAAD,QAAA+8B,GzCimaM,SAAU98B,EAAQD,EAASM,G0CrmajC,QAAAy8B,GAAA5P,EAAAvsB,GACA,GACAg1B,GACA27B,EACA9jD,EACAsQ,EACAywB,EACA1tC,EANA8Y,EAAAuT,EAAAvT,KAOAie,EAAAP,EAAAO,EACAC,EAAAR,EAAAQ,EACAF,EAAAN,EAAAM,EACA0a,EAAAhb,EAAAgb,EACAta,EAAAV,EAAAU,EACAD,EAAAT,EAAAS,CAEA,KAAAtqB,EAAA,EAAAsQ,EAAA,EAAoBtQ,EAAAmM,EAAArT,QAAiB,CAKrC,OAJAqvB,EAAAhc,EAAAnM,KACAsQ,EAAAtQ,EACA8jD,EAAA,EAEA37B,GACA,IAAAiC,GACA05B,EAAA,CACA,MAEA,KAAA35B,GACA25B,EAAA,CACA,MAEA,KAAAz5B,GACAy5B,EAAA,CACA,MAEA,KAAAx5B,GACAw5B,EAAA,CACA,MAEA,KAAAv5B,GACA,GAAAnmB,GAAAjR,EAAA,GACAmR,EAAAnR,EAAA,GACAmjC,EAAA5N,EAAAv1B,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACAojC,EAAA7N,EAAAv1B,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACAsU,EAAAs8C,GAAA5wD,EAAA,GAAAojC,EAAApjC,EAAA,GAAAmjC,EAEAnqB,GAAAnM,IAAAs2B,EACAnqB,EAAAnM,MAAAoE,EAEA+H,EAAAnM,IAAAu2B,EACApqB,EAAAnM,MAAAsE,EAGA6H,EAAAnM,MAAAs2B,EACAnqB,EAAAnM,MAAAu2B,EAEApqB,EAAAnM,MAAAyH,EAEA0E,EAAAnM,MAAAyH,EAEAzH,GAAA,EACAsQ,EAAAtQ,CACA,MAEA,KAAA6kC,GAEAxxC,EAAA,GAAA8Y,EAAAnM,KACA3M,EAAA,GAAA8Y,EAAAnM,KACA04C,EAAArlD,EAAAA,EAAAF,GACAgZ,EAAAmE,KAAAjd,EAAA,GACA8Y,EAAAmE,KAAAjd,EAAA,GAEAA,EAAA,IAAA8Y,EAAAnM,KACA3M,EAAA,IAAA8Y,EAAAnM,KACA04C,EAAArlD,EAAAA,EAAAF,GACAgZ,EAAAmE,KAAAjd,EAAA,GACA8Y,EAAAmE,KAAAjd,EAAA,GAGA,IAAA0tC,EAAA,EAAeA,EAAA+iB,EAAY/iB,IAAA,CAC3B,GAAA1tC,GAAAqiB,EAAAqrB,EACA1tC,GAAA,GAAA8Y,EAAAnM,KACA3M,EAAA,GAAA8Y,EAAAnM,KACA04C,EAAArlD,EAAAA,EAAAF,GAEAgZ,EAAAmE,KAAAjd,EAAA,GACA8Y,EAAAmE,KAAAjd,EAAA,KA9FA,GAAAu2B,GAAA/2B,EAAA,IAEA0uD,EAAA1uD,EAAA,IAEA6lD,EAAA6I,EAAAvhC,eACA6J,EAAAD,EAAAC,IACAnU,aACAgT,EAAA1iB,KAAA2D,KACAo6C,EAAA/9C,KAAAqE,KA2FA7X,GAAAD,QAAA+8B,G1CqnaM,SAAU98B,EAAQD,G2CrtaxB,GAAAoqB,GAAA,SAAA6P,GACA75B,KAAA65B,WAAAA,MAGA7P,GAAA9kB,WACAqrB,YAAAvG,EACA6W,aAAA,SAAA1tB,EAAAmb,GACAtuB,KAAA65B,WAAArwB,MACA2J,OAAAA,EACAmb,MAAAA,KAIA,IAAAqO,GAAA3S,CACAnqB,GAAAD,QAAA+8B,G3C8taM,SAAU98B,EAAQD,G4C7uaxB,QAAAksB,KACA9rB,KAAA+G,GAAA,YAAA/G,KAAAqxD,WAAArxD,MACAA,KAAA+G,GAAA,YAAA/G,KAAAsxD,MAAAtxD,MACAA,KAAA+G,GAAA,UAAA/G,KAAAuxD,SAAAvxD,MACAA,KAAA+G,GAAA,YAAA/G,KAAAuxD,SAAAvxD,MAgEA,QAAAytB,GAAAvmB,EAAAF,GACA,OACAE,OAAAA,EACAsqD,UAAAxqD,GAAAA,EAAAwqD,WA7DA1lC,EAAA5mB,WACAqrB,YAAAzE,EACAulC,WAAA,SAAArqD,GACA,GAAA8T,GAAA9T,EAAAE,MAEA4T,IAAAA,EAAA9I,YACAhS,KAAAyxD,gBAAA32C,EACAA,EAAAmiB,UAAA,EACAj9B,KAAA2wD,GAAA3pD,EAAAuB,QACAvI,KAAA0xD,GAAA1qD,EAAAwB,QACAxI,KAAA2xD,kBAAAlkC,EAAA3S,EAAA9T,GAAA,YAAAA,EAAAe,SAGAupD,MAAA,SAAAtqD,GACA,GAAA8T,GAAA9a,KAAAyxD,eAEA,IAAA32C,EAAA,CACA,GAAArJ,GAAAzK,EAAAuB,QACAoJ,EAAA3K,EAAAwB,QACA64B,EAAA5vB,EAAAzR,KAAA2wD,GACArvB,EAAA3vB,EAAA3R,KAAA0xD,EACA1xD,MAAA2wD,GAAAl/C,EACAzR,KAAA0xD,GAAA//C,EACAmJ,EAAAsmB,MAAAC,EAAAC,EAAAt6B,GACAhH,KAAA2xD,kBAAAlkC,EAAA3S,EAAA9T,GAAA,OAAAA,EAAAe,MACA,IAAA6pD,GAAA5xD,KAAA6xD,UAAApgD,EAAAE,EAAAmJ,GAAA5T,OACA4qD,EAAA9xD,KAAA+xD,WACA/xD,MAAA+xD,YAAAH,EAEA92C,IAAA82C,IACAE,GAAAF,IAAAE,GACA9xD,KAAA2xD,kBAAAlkC,EAAAqkC,EAAA9qD,GAAA,YAAAA,EAAAe,OAGA6pD,GAAAA,IAAAE,GACA9xD,KAAA2xD,kBAAAlkC,EAAAmkC,EAAA5qD,GAAA,YAAAA,EAAAe,UAKAwpD,SAAA,SAAAvqD,GACA,GAAA8T,GAAA9a,KAAAyxD,eAEA32C,KACAA,EAAAmiB,UAAA,GAGAj9B,KAAA2xD,kBAAAlkC,EAAA3S,EAAA9T,GAAA,UAAAA,EAAAe,OAEA/H,KAAA+xD,aACA/xD,KAAA2xD,kBAAAlkC,EAAAztB,KAAA+xD,YAAA/qD,GAAA,OAAAA,EAAAe,OAGA/H,KAAAyxD,gBAAA,KACAzxD,KAAA+xD,YAAA,MAWA,IAAAp1B,GAAA7Q,CACAjsB,GAAAD,QAAA+8B,G5CqvaM,SAAU98B,EAAQD,EAASM,G6Cn0ajC,GAAA+D,GAAA/D,EAAA,GAEA8oB,EAAA9oB,EAAA,IAEAssB,EAAAtsB,EAAA,IA2BAuG,EAAA,SAAA5F,GACAA,EAAAA,MACAmoB,EAAAzoB,KAAAP,KAAAa,EAEA,KAAA,GAAAmF,KAAAnF,GACAA,EAAAqpB,eAAAlkB,KACAhG,KAAAgG,GAAAnF,EAAAmF,GAIAhG,MAAAgyD,aACAhyD,KAAAiyD,UAAA,KACAjyD,KAAAk6B,SAAA,EAGAzzB,GAAAvB,WACAqrB,YAAA9pB,EACAyrD,SAAA,EAKApsD,KAAA,QAQAo3B,QAAA,EAKA5zB,SAAA,WACA,MAAAtJ,MAAAgyD,UAAAppC,SAQAupC,QAAA,SAAArH,GACA,MAAA9qD,MAAAgyD,UAAAlH,IAQAvtC,YAAA,SAAAlV,GAGA,IAAA,GAFAiB,GAAAtJ,KAAAgyD,UAEA3kD,EAAA,EAAmBA,EAAA/D,EAAAnD,OAAqBkH,IACxC,GAAA/D,EAAA+D,GAAAhF,OAAAA,EACA,MAAAiB,GAAA+D,IAQA+kD,WAAA,WACA,MAAApyD,MAAAgyD,UAAA7rD,QAOAQ,IAAA,SAAA4E,GAOA,MANAA,IAAAA,IAAAvL,MAAAuL,EAAApD,SAAAnI,OACAA,KAAAgyD,UAAAxoD,KAAA+B,GAEAvL,KAAAqyD,OAAA9mD,IAGAvL,MAQAsyD,UAAA,SAAA/mD,EAAAgnD,GACA,GAAAhnD,GAAAA,IAAAvL,MAAAuL,EAAApD,SAAAnI,MAAAuyD,GAAAA,EAAApqD,SAAAnI,KAAA,CACA,GAAAsJ,GAAAtJ,KAAAgyD,UACAlH,EAAAxhD,EAAAuH,QAAA0hD,EAEAzH,IAAA,IACAxhD,EAAAiE,OAAAu9C,EAAA,EAAAv/C,GAEAvL,KAAAqyD,OAAA9mD,IAIA,MAAAvL,OAEAqyD,OAAA,SAAA9mD,GACAA,EAAApD,QACAoD,EAAApD,OAAAsH,OAAAlE,GAGAA,EAAApD,OAAAnI,IACA,IAAAwyD,GAAAxyD,KAAAiyD,UACApwB,EAAA7hC,KAAAg8B,IAEAw2B,IAAAA,IAAAjnD,EAAA0mD,YACAO,EAAAC,aAAAlnD,GAEAA,YAAA9E,IACA8E,EAAAmnD,qBAAAF,IAIA3wB,GAAAA,EAAA5F,WAOAxsB,OAAA,SAAAlE,GACA,GAAAs2B,GAAA7hC,KAAAg8B,KACAw2B,EAAAxyD,KAAAiyD,UACA3oD,EAAAtJ,KAAAgyD,UACAlH,EAAA7mD,EAAA4M,QAAAvH,EAAAiC,EAEA,OAAAu/C,GAAA,EACA9qD,MAGAsJ,EAAAiE,OAAAu9C,EAAA,GACAv/C,EAAApD,OAAA,KAEAqqD,IACAA,EAAAG,eAAApnD,GAEAA,YAAA9E,IACA8E,EAAAqnD,uBAAAJ,IAIA3wB,GAAAA,EAAA5F,UACAj8B,OAMA6yD,UAAA,WACA,GAEAtnD,GACA8B,EAHA/D,EAAAtJ,KAAAgyD,UACAQ,EAAAxyD,KAAAiyD,SAIA,KAAA5kD,EAAA,EAAeA,EAAA/D,EAAAnD,OAAqBkH,IACpC9B,EAAAjC,EAAA+D,GAEAmlD,IACAA,EAAAG,eAAApnD,GAEAA,YAAA9E,IACA8E,EAAAqnD,uBAAAJ,IAIAjnD,EAAApD,OAAA,IAIA,OADAmB,GAAAnD,OAAA,EACAnG,MAQAmJ,UAAA,SAAA0U,EAAAC,GAGA,IAAA,GAFAxU,GAAAtJ,KAAAgyD,UAEA3kD,EAAA,EAAmBA,EAAA/D,EAAAnD,OAAqBkH,IAAA,CACxC,GAAA9B,GAAAjC,EAAA+D,EACAwQ,GAAAtd,KAAAud,EAAAvS,EAAA8B,GAGA,MAAArN,OAQAwqB,SAAA,SAAA3M,EAAAC,GACA,IAAA,GAAAzQ,GAAA,EAAmBA,EAAArN,KAAAgyD,UAAA7rD,OAA2BkH,IAAA,CAC9C,GAAA9B,GAAAvL,KAAAgyD,UAAA3kD,EACAwQ,GAAAtd,KAAAud,EAAAvS,GAEA,UAAAA,EAAAzF,MACAyF,EAAAif,SAAA3M,EAAAC,GAIA,MAAA9d,OAEA0yD,qBAAA,SAAAF,GACA,IAAA,GAAAnlD,GAAA,EAAmBA,EAAArN,KAAAgyD,UAAA7rD,OAA2BkH,IAAA,CAC9C,GAAA9B,GAAAvL,KAAAgyD,UAAA3kD,EACAmlD,GAAAC,aAAAlnD,GAEAA,YAAA9E,IACA8E,EAAAmnD,qBAAAF,KAIAI,uBAAA,SAAAJ,GACA,IAAA,GAAAnlD,GAAA,EAAmBA,EAAArN,KAAAgyD,UAAA7rD,OAA2BkH,IAAA,CAC9C,GAAA9B,GAAAvL,KAAAgyD,UAAA3kD,EACAmlD,GAAAG,eAAApnD,GAEAA,YAAA9E,IACA8E,EAAAqnD,uBAAAJ,KAIAl6B,MAAA,WAGA,MAFAt4B,MAAAk6B,SAAA,EACAl6B,KAAAg8B,MAAAh8B,KAAAg8B,KAAAC,UACAj8B,MAMAmP,gBAAA,SAAA2jD,GAOA,IAAA,GALAtgD,GAAA,KACAksC,EAAA,GAAAlyB,GAAA,EAAA,EAAA,EAAA,GACAljB,EAAAwpD,GAAA9yD,KAAAgyD,UACAe,KAEA1lD,EAAA,EAAmBA,EAAA/D,EAAAnD,OAAqBkH,IAAA,CACxC,GAAA9B,GAAAjC,EAAA+D,EAEA,KAAA9B,EAAA21B,SAAA31B,EAAAwxB,UAAA,CAIA,GAAAi2B,GAAAznD,EAAA4D,kBACAqgB,EAAAjkB,EAAA+jB,kBAAAyjC,EAQAvjC,IACAkvB,EAAApjB,KAAA03B,GACAtU,EAAArxB,eAAAmC,GACAhd,EAAAA,GAAAksC,EAAAt4C,QACAoM,EAAA0zC,MAAAxH,KAEAlsC,EAAAA,GAAAwgD,EAAA5sD,QACAoM,EAAA0zC,MAAA8M,KAIA,MAAAxgD,IAAAksC,IAGAz6C,EAAAkpB,SAAA1mB,EAAAuiB,EACA,IAAA2T,GAAAl2B,CACA5G,GAAAD,QAAA+8B,G7Cy0aM,SAAU98B,EAAQD,EAASM,G8ClnbjC,QAAA+yD,GAAApyD,GACAq4B,EAAA34B,KAAAP,KAAAa,GAfA,GAAAq4B,GAAAh5B,EAAA,GAEAssB,EAAAtsB,EAAA,IAEA+D,EAAA/D,EAAA,GAEAkiD,EAAAliD,EAAA,GAYA+yD,GAAA/tD,WACAqrB,YAAA0iC,EACAntD,KAAA,QACA0zB,MAAA,SAAArB,EAAAsB,GACA,GAAA5uB,GAAA7K,KAAA6K,MACA+8C,EAAA/8C,EAAAC,KAEAD,GAAArD,KAAA2wB,EAAAn4B,KAAAy5B,EACA,IAAA3uB,GAAA9K,KAAAkzD,OAAA9Q,EAAAC,oBAAAuF,EAAA5nD,KAAAkzD,OAAAlzD,KAAAA,KAAAynD,OAEA,IAAA38C,GAAAs3C,EAAAG,aAAAz3C,GAAA,CAWA,GAAA2G,GAAA5G,EAAA4G,GAAA,EACAE,EAAA9G,EAAA8G,GAAA,EACA1C,EAAApE,EAAAoE,MACAC,EAAArE,EAAAqE,OACA+d,EAAAniB,EAAAmE,MAAAnE,EAAAoE,MAeA,IAbA,MAAAD,GAAA,MAAAC,EAEAD,EAAAC,EAAA+d,EACK,MAAA/d,GAAA,MAAAD,EACLC,EAAAD,EAAAge,EACK,MAAAhe,GAAA,MAAAC,IACLD,EAAAnE,EAAAmE,MACAC,EAAApE,EAAAoE,QAIAlP,KAAAi6B,aAAA9B,GAEAttB,EAAAsoD,QAAAtoD,EAAAuoD,QAAA,CACA,GAAAzvB,GAAA94B,EAAA84B,IAAA,EACAC,EAAA/4B,EAAA+4B,IAAA,CACAzL,GAAAqqB,UAAA13C,EAAA64B,EAAAC,EAAA/4B,EAAAsoD,OAAAtoD,EAAAuoD,QAAA3hD,EAAAE,EAAA1C,EAAAC,OACK,IAAArE,EAAA84B,IAAA94B,EAAA+4B,GAAA,CACL,GAAAD,GAAA94B,EAAA84B,GACAC,EAAA/4B,EAAA+4B,GACAuvB,EAAAlkD,EAAA00B,EACAyvB,EAAAlkD,EAAA00B,CACAzL,GAAAqqB,UAAA13C,EAAA64B,EAAAC,EAAAuvB,EAAAC,EAAA3hD,EAAAE,EAAA1C,EAAAC,OAEAipB,GAAAqqB,UAAA13C,EAAA2G,EAAAE,EAAA1C,EAAAC,EAGAlP,MAAA86B,iBAAA3C,GAEA,MAAAttB,EAAAE,MACA/K,KAAA+6B,aAAA5C,EAAAn4B,KAAAmP,qBAGAA,gBAAA,WACA,GAAAtE,GAAA7K,KAAA6K,KAMA,OAJA7K,MAAAk7B,QACAl7B,KAAAk7B,MAAA,GAAA1O,GAAA3hB,EAAA4G,GAAA,EAAA5G,EAAA8G,GAAA,EAAA9G,EAAAoE,OAAA,EAAApE,EAAAqE,QAAA,IAGAlP,KAAAk7B,QAGAj3B,EAAAkpB,SAAA8lC,EAAA/5B,EACA,IAAAyD,GAAAs2B,CACApzD,GAAAD,QAAA+8B,G9CsobM,SAAU98B,EAAQD,EAASM,G+ChubjC,GAAAg5B,GAAAh5B,EAAA,GAEA+D,EAAA/D,EAAA,GAEAyE,EAAAzE,EAAA,IAEAu+C,EAAAv+C,EAAA,IAQA8rB,EAAA,SAAAnrB,GAEAq4B,EAAA34B,KAAAP,KAAAa,GAGAmrB,GAAA9mB,WACAqrB,YAAAvE,EACAlmB,KAAA,OACA0zB,MAAA,SAAArB,EAAAsB,GACA,GAAA5uB,GAAA7K,KAAA6K,KAEA7K,MAAAk6B,SAAAukB,EAAAE,mBAAA9zC,GAAA,GAEAA,EAAAgH,KAAAhH,EAAAiH,OAAAjH,EAAAqzB,WAAArzB,EAAAwoD,YAAAxoD,EAAAszB,cAAAtzB,EAAAuzB,cAAA,IACA,IAAArzB,GAAAF,EAAAE,IAEA,OAAAA,IAAAA,GAAA,IAEAF,EAAArD,KAAA2wB,EAAAn4B,KAAAy5B,GAEAglB,EAAAG,aAAA7zC,EAAAF,KAIA7K,KAAAi6B,aAAA9B,GACAsmB,EAAAK,WAAA9+C,KAAAm4B,EAAAptB,EAAAF,GACA7K,KAAA86B,iBAAA3C,KAEAhpB,gBAAA,WACA,GAAAtE,GAAA7K,KAAA6K,KAIA,IAFA7K,KAAAk6B,SAAAukB,EAAAE,mBAAA9zC,GAAA,IAEA7K,KAAAk7B,MAAA,CACA,GAAAnwB,GAAAF,EAAAE,IACA,OAAAA,EAAAA,GAAA,GAAAA,EAAA,EACA,IAAAyH,GAAA7N,EAAAwK,gBAAAtE,EAAAE,KAAA,GAAAF,EAAAwzB,KAAAxzB,EAAAsW,UAAAtW,EAAAo0B,kBAAAp0B,EAAAo1B,YAAAp1B,EAAAq1B,KAIA,IAHA1tB,EAAAf,GAAA5G,EAAA4G,GAAA,EACAe,EAAAb,GAAA9G,EAAA8G,GAAA,EAEA8sC,EAAAqC,UAAAj2C,EAAA8zB,WAAA9zB,EAAAi0B,iBAAA,CACA,GAAAvD,GAAA1wB,EAAAi0B,eACAtsB,GAAAf,GAAA8pB,EAAA,EACA/oB,EAAAb,GAAA4pB,EAAA,EACA/oB,EAAAvD,OAAAssB,EACA/oB,EAAAtD,QAAAqsB,EAGAv7B,KAAAk7B,MAAA1oB;CAGA,MAAAxS,MAAAk7B,QAGAj3B,EAAAkpB,SAAAnB,EAAAkN,EACA,IAAAyD,GAAA3Q,CACAnsB,GAAAD,QAAA+8B,G/CsubM,SAAU98B,EAAQD,EAASM,GgD5ybjC,GAAAyrB,GAAAzrB,EAAA,GAMAy8B,EAAAhR,EAAA7G,QACAhf,KAAA,SACAmB,OACAuK,GAAA,EACAE,GAAA,EACAE,EAAA,GAEAqmB,UAAA,SAAAE,EAAAlxB,EAAAg0B,GAGAA,GACA9C,EAAA+vB,OAAAjhD,EAAAuK,GAAAvK,EAAA2K,EAAA3K,EAAAyK,IAUAymB,EAAA4xB,IAAA9iD,EAAAuK,GAAAvK,EAAAyK,GAAAzK,EAAA2K,EAAA,EAAA,EAAAyB,KAAA0B,IAAA,KAIAlV,GAAAD,QAAA+8B,GhDkzbM,SAAU98B,EAAQD,EAASM,GiDj1bjC,GAAAyrB,GAAAzrB,EAAA,GAEAozD,EAAApzD,EAAA,IAMAy8B,EAAAhR,EAAA7G,QACAhf,KAAA,SACAmB,OACAuK,GAAA,EACAE,GAAA,EACA6hD,GAAA,EACA3hD,EAAA,EACAo4C,WAAA,EACAC,SAAA,EAAA52C,KAAA0B,GACAy+C,WAAA,GAEAh6B,MAAA85B,EAAA3nC,EAAAzmB,UAAAs0B,OACAvB,UAAA,SAAAE,EAAAlxB,GACA,GAAAwK,GAAAxK,EAAAuK,GACAG,EAAA1K,EAAAyK,GACA6hD,EAAAlgD,KAAA6Q,IAAAjd,EAAAssD,IAAA,EAAA,GACA3hD,EAAAyB,KAAA6Q,IAAAjd,EAAA2K,EAAA,GACAo4C,EAAA/iD,EAAA+iD,WACAC,EAAAhjD,EAAAgjD,SACAuJ,EAAAvsD,EAAAusD,UACAC,EAAApgD,KAAA0lB,IAAAixB,GACA0J,EAAArgD,KAAAylB,IAAAkxB,EACA7xB,GAAA+vB,OAAAuL,EAAAF,EAAA9hD,EAAAiiD,EAAAH,EAAA5hD,GACAwmB,EAAAgwB,OAAAsL,EAAA7hD,EAAAH,EAAAiiD,EAAA9hD,EAAAD,GACAwmB,EAAA4xB,IAAAt4C,EAAAE,EAAAC,EAAAo4C,EAAAC,GAAAuJ,GACAr7B,EAAAgwB,OAAA90C,KAAA0lB,IAAAkxB,GAAAsJ,EAAA9hD,EAAA4B,KAAAylB,IAAAmxB,GAAAsJ,EAAA5hD,GAEA,IAAA4hD,GACAp7B,EAAA4xB,IAAAt4C,EAAAE,EAAA4hD,EAAAtJ,EAAAD,EAAAwJ,GAGAr7B,EAAAgqB,cAIAtiD,GAAAD,QAAA+8B,GjDu1bM,SAAU98B,EAAQD,EAASM,GkDh3bjC,QAAAy8B,GAAAg3B,GAEA,MAAAC,GAAAC,QAAAC,IAAAF,EAAAC,QAAApsC,SAAA,GAAA,WACA,GAEAssC,GAFAC,EAAAh0D,KAAA68B,YACAhyB,EAAA7K,KAAA6K,KAGA,IAAAmpD,EACA,IAAA,GAAA3mD,GAAA,EAAqBA,EAAA2mD,EAAA7tD,OAAsBkH,IAAA,CAC3C,GAAA8zB,GAAA6yB,EAAA3mD,GACApG,EAAAk6B,GAAAA,EAAAl6B,MACAnB,EAAAq7B,GAAAA,EAAAr7B,IAEA,IAAAmB,IAAA,WAAAnB,GAAAmB,EAAA+iD,aAAA/iD,EAAAgjD,UAAA,SAAAnkD,KAAAmB,EAAAgI,QAAAhI,EAAAiI,SAAA,CACA,IAAA,GAAAyO,GAAA,EAAyBA,EAAAs2C,EAAA9tD,OAAuBwX,IAGhDs2C,EAAAt2C,GAAA,GAAA9S,EAAAopD,EAAAt2C,GAAA,IACA9S,EAAAopD,EAAAt2C,GAAA,IAAAs2C,EAAAt2C,GAAA,EAGAo2C,IAAA,CACA,QAOA,GAFAJ,EAAA/4C,MAAA5a,KAAAkG,WAEA6tD,EACA,IAAA,GAAAp2C,GAAA,EAAqBA,EAAAs2C,EAAA9tD,OAAuBwX,IAC5C9S,EAAAopD,EAAAt2C,GAAA,IAAAs2C,EAAAt2C,GAAA,IAGGg2C,EApDH,GAAAC,GAAA1zD,EAAA,IAgBA+zD,IAAA,aAAA,IAAA,cAAA,SAAA,gBAAA,IAAA,gBAAA,GAuCAp0D,GAAAD,QAAA+8B,GlDw4bM,SAAU98B,EAAQD,GmDp6bxB,QAAAs0D,GAAAC,GACA,GAAAC,MACAP,KAeAQ,EAAAF,EAAAG,MAAA,qBAGAR,EAAAK,EAAAG,MAAA,mBACAH,EAAAG,MAAA,6BACAC,EAAAJ,EAAAG,MAAA,kBAEAE,EAAA,kBAAA/7C,KAAA07C,EAiDA,OA5BAE,KACAR,EAAAQ,SAAA,EACAR,EAAApsC,QAAA4sC,EAAA,IAKAP,IACAD,EAAAC,IAAA,EACAD,EAAApsC,QAAAqsC,EAAA,IAGAS,IACAV,EAAAU,MAAA,EACAV,EAAApsC,QAAA8sC,EAAA,IAKAC,IACAX,EAAAW,QAAA,IASAX,QAAAA,EACAO,GAAAA,EACAhrD,MAAA,EAGAqrD,kBAAAn2C,SAAAC,cAAA,UAAAC,WACAk2C,aAAA,mBAAAC,SAKAC,qBAAA,gBAAApuD,UAAAqtD,EAAAC,KAAAD,EAAAU,KAEAM,uBAAA,iBAAAruD,UAIAqtD,EAAAU,MAAAV,EAAAC,IAAAD,EAAApsC,SAAA,KA/GA,GAAAmsC,KAIAA,GAFA,mBAAAkB,YAGAjB,WACAO,MACAhrD,MAAA,EAEAqrD,iBAAA,EACAC,cAAA,GAGAR,EAAAY,UAAAC,UAGA,IAAAp4B,GAAAi3B,CAmGA/zD,GAAAD,QAAA+8B,GnDq8bM,SAAU98B,EAAQD,EAASM,GoD/jcjC,GAAAyrB,GAAAzrB,EAAA,GAMAy8B,EAAAhR,EAAA7G,QACAhf,KAAA,OACAmB,OACAuK,GAAA,EACAE,GAAA,EACAE,EAAA,EACA2hD,GAAA,GAEAt7B,UAAA,SAAAE,EAAAlxB,GACA,GAAAwK,GAAAxK,EAAAuK,GACAG,EAAA1K,EAAAyK,GACA49C,EAAA,EAAAj8C,KAAA0B,EACAojB,GAAA+vB,OAAAz2C,EAAAxK,EAAA2K,EAAAD,GACAwmB,EAAA4xB,IAAAt4C,EAAAE,EAAA1K,EAAA2K,EAAA,EAAA09C,GAAA,GACAn3B,EAAA+vB,OAAAz2C,EAAAxK,EAAAssD,GAAA5hD,GACAwmB,EAAA4xB,IAAAt4C,EAAAE,EAAA1K,EAAAssD,GAAA,EAAAjE,GAAA,KAIAzvD,GAAAD,QAAA+8B,GpDqkcM,SAAU98B,EAAQD,EAASM,GqD9lcjC,GAAAyrB,GAAAzrB,EAAA,GAEA80D,EAAA90D,EAAA,IAMAy8B,EAAAhR,EAAA7G,QACAhf,KAAA,UACAmB,OACA8b,OAAA,KACAkyC,QAAA,EACAC,iBAAA,MAEAj9B,UAAA,SAAAE,EAAAlxB,GACA+tD,EAAA/8B,UAAAE,EAAAlxB,GAAA,KAIApH,GAAAD,QAAA+8B,GrDomcM,SAAU98B,EAAQD,EAASM,GsDpncjC,QAAA+3B,GAAAE,EAAAlxB,EAAAk7C,GACA,GAAAp/B,GAAA9b,EAAA8b,OACAkyC,EAAAhuD,EAAAguD,MAEA,IAAAlyC,GAAAA,EAAA5c,QAAA,EAAA,CACA,GAAA8uD,GAAA,WAAAA,EAAA,CACA,GAAAE,GAAAC,EAAAryC,EAAAkyC,EAAA9S,EAAAl7C,EAAAiuD,iBACA/8B,GAAA+vB,OAAAnlC,EAAA,GAAA,GAAAA,EAAA,GAAA,GAGA,KAAA,GAFAqN,GAAArN,EAAA5c,OAEAkH,EAAA,EAAqBA,GAAA80C,EAAA/xB,EAAAA,EAAA,GAAiC/iB,IAAA,CACtD,GAAAgoD,GAAAF,EAAA,EAAA9nD,GACAioD,EAAAH,EAAA,EAAA9nD,EAAA,GACA3M,EAAAqiB,GAAA1V,EAAA,GAAA+iB,EACA+H,GAAAuxB,cAAA2L,EAAA,GAAAA,EAAA,GAAAC,EAAA,GAAAA,EAAA,GAAA50D,EAAA,GAAAA,EAAA,SAEK,CACL,WAAAu0D,IACAlyC,EAAAwyC,EAAAxyC,EAAAo/B,IAGAhqB,EAAA+vB,OAAAnlC,EAAA,GAAA,GAAAA,EAAA,GAAA,GAEA,KAAA,GAAA1V,GAAA,EAAAy1B,EAAA/f,EAAA5c,OAAwCkH,EAAAy1B,EAAOz1B,IAC/C8qB,EAAAgwB,OAAAplC,EAAA1V,GAAA,GAAA0V,EAAA1V,GAAA,IAIA80C,GAAAhqB,EAAAgqB,aAhCA,GAAAoT,GAAAr1D,EAAA,IAEAk1D,EAAAl1D,EAAA,GAkCAN,GAAAq4B,UAAAA,GtD8ncM,SAAUp4B,EAAQD,EAASM,GuDnpcjC,QAAAs1D,GAAAztB,EAAAC,EAAAe,EAAAC,EAAA3C,EAAA4C,EAAAC,GACA,GAAAE,GAAA,IAAAL,EAAAhB,GACArC,EAAA,IAAAsD,EAAAhB,EACA,QAAA,GAAAA,EAAAe,GAAAK,EAAA1D,GAAAwD,OAAAlB,EAAAe,GAAA,EAAAK,EAAA1D,GAAAuD,EAAAG,EAAA/C,EAAA2B,EAUA,QAAArL,GAAA5Z,EAAA0yC,GAKA,IAAA,GAJArlC,GAAArN,EAAA5c,OACAmjC,KACA5kB,EAAA,EAEArX,EAAA,EAAiBA,EAAA+iB,EAAS/iB,IAC1BqX,GAAAgxC,EAAA3yC,EAAA1V,EAAA,GAAA0V,EAAA1V,GAGA,IAAAsoD,GAAAjxC,EAAA,CACAixC,GAAAA,EAAAvlC,EAAAA,EAAAulC,CAEA,KAAA,GAAAtoD,GAAA,EAAiBA,EAAAsoD,EAAUtoD,IAAA,CAC3B,GAGA06B,GAEAgB,EACAC,EANA/7B,EAAAI,GAAAsoD,EAAA,IAAAF,EAAArlC,EAAAA,EAAA,GACA06B,EAAAz3C,KAAAkW,MAAAtc,GACAsuB,EAAAtuB,EAAA69C,EAEA9iB,EAAAjlB,EAAA+nC,EAAA16B,EAIAqlC,IAKA1tB,EAAAhlB,GAAA+nC,EAAA,EAAA16B,GAAAA,GACA2Y,EAAAhmB,GAAA+nC,EAAA,GAAA16B,GACA4Y,EAAAjmB,GAAA+nC,EAAA,GAAA16B,KANA2X,EAAAhlB,EAAA,IAAA+nC,EAAAA,EAAAA,EAAA,GACA/hB,EAAAhmB,EAAA+nC,EAAA16B,EAAA,EAAAA,EAAA,EAAA06B,EAAA,GACA9hB,EAAAjmB,EAAA+nC,EAAA16B,EAAA,EAAAA,EAAA,EAAA06B,EAAA,GAOA,IAAA8K,GAAAr6B,EAAAA,EACAs6B,EAAAt6B,EAAAq6B,CACAtsB,GAAA9/B,MAAAgsD,EAAAztB,EAAA,GAAAC,EAAA,GAAAe,EAAA,GAAAC,EAAA,GAAAzN,EAAAq6B,EAAAC,GAAAL,EAAAztB,EAAA,GAAAC,EAAA,GAAAe,EAAA,GAAAC,EAAA,GAAAzN,EAAAq6B,EAAAC,KAGA,MAAAvsB,GAhEA,GAAAslB,GAAA1uD,EAAA,IAEAw1D,EAAA9G,EAAAlqC,QAiEA7kB,GAAAD,QAAA+8B,GvDwqcM,SAAU98B,EAAQD,EAASM,GwD9scjC,QAAAy8B,GAAA5Z,EAAAkyC,EAAAQ,EAAAK,GACA,GAIAC,GACAC,EACA/xC,EAAAC,EANA+xC,KACA7oD,KACAs4B,KACA7B,IAKA,IAAAiyB,EAAA,CACA7xC,GAAA6pC,EAAAA,EAAAA,EAAAA,GACA5pC,KAAA4pC,EAAAA,KAAAA,EAAAA,GAEA,KAAA,GAAAzgD,GAAA,EAAA+iB,EAAArN,EAAA5c,OAAwCkH,EAAA+iB,EAAS/iB,IACjD6oD,EAAAjyC,EAAAA,EAAAlB,EAAA1V,IACA8oD,EAAAjyC,EAAAA,EAAAnB,EAAA1V,GAIA6oD,GAAAjyC,EAAAA,EAAA6xC,EAAA,IACAK,EAAAjyC,EAAAA,EAAA4xC,EAAA,IAGA,IAAA,GAAAzoD,GAAA,EAAA+iB,EAAArN,EAAA5c,OAAsCkH,EAAA+iB,EAAS/iB,IAAA,CAC/C,GAAAgE,GAAA0R,EAAA1V,EAEA,IAAAooD,EACAM,EAAAhzC,EAAA1V,EAAAA,EAAA,EAAA+iB,EAAA,GACA4lC,EAAAjzC,GAAA1V,EAAA,GAAA+iB,OACK,CACL,GAAA,IAAA/iB,GAAAA,IAAA+iB,EAAA,EAAA,CACA6lC,EAAAzsD,KAAA4sD,EAAArzC,EAAA1V,IACA,UAEA0oD,EAAAhzC,EAAA1V,EAAA,GACA2oD,EAAAjzC,EAAA1V,EAAA,GAIAgpD,EAAAjpD,EAAA4oD,EAAAD,GAEAO,EAAAlpD,EAAAA,EAAA6nD,EACA,IAAAsB,GAAAb,EAAArkD,EAAA0kD,GACApI,EAAA+H,EAAArkD,EAAA2kD,GACAQ,EAAAD,EAAA5I,CAEA,KAAA6I,IACAD,GAAAC,EACA7I,GAAA6I,GAGAF,EAAA5wB,EAAAt4B,GAAAmpD,GACAD,EAAAzyB,EAAAz2B,EAAAugD,EACA,IAAA8I,GAAAC,KAAArlD,EAAAq0B,GACA2vB,EAAAqB,KAAArlD,EAAAwyB,EAEAiyB,KACAK,EAAAM,EAAAA,EAAAxyC,GACAiyC,EAAAO,EAAAA,EAAAvyC,GACAiyC,EAAAd,EAAAA,EAAApxC,GACAiyC,EAAAb,EAAAA,EAAAnxC,IAGA+xC,EAAAzsD,KAAAitD,GACAR,EAAAzsD,KAAA6rD,GAOA,MAJAI,IACAQ,EAAAzsD,KAAAysD,EAAA7+B,SAGA6+B,EApGA,GAAArH,GAAA1uD,EAAA,IAEAg2D,EAAAtH,EAAA3qC,IACAkyC,EAAAvH,EAAA1qC,IACAoyC,EAAA1H,EAAA36C,MACAyhD,EAAA9G,EAAAlqC,SACAgyC,EAAA9H,EAAAjoD,IACAyvD,EAAAxH,EAAAxoD,MACAiwD,EAAAzH,EAAAx0C,GA+FAva,GAAAD,QAAA+8B,GxDivcM,SAAU98B,EAAQD,EAASM,GyDx1cjC,GAAAyrB,GAAAzrB,EAAA,GAEA80D,EAAA90D,EAAA,IAKAy8B,EAAAhR,EAAA7G,QACAhf,KAAA,WACAmB,OACA8b,OAAA,KACAkyC,QAAA,EACAC,iBAAA,MAEArqD,OACAiH,OAAA,OACAD,KAAA,MAEAomB,UAAA,SAAAE,EAAAlxB,GACA+tD,EAAA/8B,UAAAE,EAAAlxB,GAAA,KAIApH,GAAAD,QAAA+8B,GzD81cM,SAAU98B,EAAQD,EAASM,G0Dr3cjC,GAAAyrB,GAAAzrB,EAAA,GAEAgiD,EAAAhiD,EAAA,IAMAy8B,EAAAhR,EAAA7G,QACAhf,KAAA,OACAmB,OAMA2K,EAAA,EACAH,EAAA,EACAE,EAAA,EACA1C,MAAA,EACAC,OAAA,GAEA+oB,UAAA,SAAAE,EAAAlxB,GACA,GAAAwK,GAAAxK,EAAAwK,EACAE,EAAA1K,EAAA0K,EACA1C,EAAAhI,EAAAgI,MACAC,EAAAjI,EAAAiI,MAEAjI,GAAA2K,EAGAswC,EAAAjqB,UAAAE,EAAAlxB,GAFAkxB,EAAA3lB,KAAAf,EAAAE,EAAA1C,EAAAC,GAKAipB,EAAAgqB,cAKAtiD,GAAAD,QAAA+8B,G1D23cM,SAAU98B,EAAQD,EAASM,G2Dl6cjC,GAAAyrB,GAAAzrB,EAAA,GAMAy8B,EAAAhR,EAAA7G,QACAhf,KAAA,OACAmB,OAEAyO,GAAA,EACAC,GAAA,EAEAC,GAAA,EACAC,GAAA,EACAoyB,QAAA,GAEAp9B,OACAiH,OAAA,OACAD,KAAA,MAEAomB,UAAA,SAAAE,EAAAlxB,GACA,GAAAyO,GAAAzO,EAAAyO,GACAC,EAAA1O,EAAA0O,GACAC,EAAA3O,EAAA2O,GACAC,EAAA5O,EAAA4O,GACAoyB,EAAAhhC,EAAAghC,OAEA,KAAAA,IAIA9P,EAAA+vB,OAAAxyC,EAAAC,GAEAsyB,EAAA,IACAryB,EAAAF,GAAA,EAAAuyB,GAAAryB,EAAAqyB,EACApyB,EAAAF,GAAA,EAAAsyB,GAAApyB,EAAAoyB,GAGA9P,EAAAgwB,OAAAvyC,EAAAC,KAQA8gD,QAAA,SAAAj2D,GACA,GAAAuG,GAAAjH,KAAAiH,KACA,QAAAA,EAAAyO,IAAA,EAAAhV,GAAAuG,EAAA2O,GAAAlV,EAAAuG,EAAA0O,IAAA,EAAAjV,GAAAuG,EAAA4O,GAAAnV,KAIAb,GAAAD,QAAA+8B,G3Dw6cM,SAAU98B,EAAQD,EAASM,G4D18cjC,QAAA02D,GAAA3vD,EAAAo/B,EAAAwwB,GACA,GAAAC,GAAA7vD,EAAA6vD,KACAC,EAAA9vD,EAAA8vD,IAEA,OAAA,QAAAD,GAAA,OAAAC,IACAF,EAAA3K,EAAAjB,GAAAhkD,EAAAyO,GAAAzO,EAAA+vD,KAAA/vD,EAAA6vD,KAAA7vD,EAAA2O,GAAAywB,IAAAwwB,EAAA3K,EAAAjB,GAAAhkD,EAAA0O,GAAA1O,EAAAgwD,KAAAhwD,EAAA8vD,KAAA9vD,EAAA4O,GAAAwwB,MAEAwwB,EAAAvI,EAAAD,GAAApnD,EAAAyO,GAAAzO,EAAA+vD,KAAA/vD,EAAA2O,GAAAywB,IAAAwwB,EAAAvI,EAAAD,GAAApnD,EAAA0O,GAAA1O,EAAAgwD,KAAAhwD,EAAA4O,GAAAwwB,IA1BA,GAAA1a,GAAAzrB,EAAA,GAEA4lD,EAAA5lD,EAAA,IAEA8wD,EAAA9wD,EAAA,IAEAwuD,EAAAsC,EAAAtC,mBACAvB,EAAA6D,EAAA7D,eACAkB,EAAA2C,EAAA3C,YACApD,EAAA+F,EAAA/F,QACAqD,EAAA0C,EAAA1C,sBACApC,EAAA8E,EAAA9E,kBAMAloB,KAaArH,EAAAhR,EAAA7G,QACAhf,KAAA,eACAmB,OACAyO,GAAA,EACAC,GAAA,EACAC,GAAA,EACAC,GAAA,EACAmhD,KAAA,EACAC,KAAA,EAIAhvB,QAAA,GAEAp9B,OACAiH,OAAA,OACAD,KAAA,MAEAomB,UAAA,SAAAE,EAAAlxB,GACA,GAAAyO,GAAAzO,EAAAyO,GACAC,EAAA1O,EAAA0O,GACAC,EAAA3O,EAAA2O,GACAC,EAAA5O,EAAA4O,GACAmhD,EAAA/vD,EAAA+vD,KACAC,EAAAhwD,EAAAgwD,KACAH,EAAA7vD,EAAA6vD,KACAC,EAAA9vD,EAAA8vD,KACA9uB,EAAAhhC,EAAAghC,OAEA,KAAAA,IAIA9P,EAAA+vB,OAAAxyC,EAAAC,GAEA,MAAAmhD,GAAA,MAAAC,GACA9uB,EAAA,IACAymB,EAAAh5C,EAAAshD,EAAAphD,EAAAqyB,EAAAjE,GACAgzB,EAAAhzB,EAAA,GACApuB,EAAAouB,EAAA,GACA0qB,EAAA/4C,EAAAshD,EAAAphD,EAAAoyB,EAAAjE,GACAizB,EAAAjzB,EAAA,GACAnuB,EAAAmuB,EAAA,IAGA7L,EAAAiwB,iBAAA4O,EAAAC,EAAArhD,EAAAC,KAEAoyB,EAAA,IACAklB,EAAAz3C,EAAAshD,EAAAF,EAAAlhD,EAAAqyB,EAAAjE,GACAgzB,EAAAhzB,EAAA,GACA8yB,EAAA9yB,EAAA,GACApuB,EAAAouB,EAAA,GACAmpB,EAAAx3C,EAAAshD,EAAAF,EAAAlhD,EAAAoyB,EAAAjE,GACAizB,EAAAjzB,EAAA,GACA+yB,EAAA/yB,EAAA,GACAnuB,EAAAmuB,EAAA,IAGA7L,EAAAuxB,cAAAsN,EAAAC,EAAAH,EAAAC,EAAAnhD,EAAAC,MASA8gD,QAAA,SAAAtwB,GACA,MAAAuwB,GAAA52D,KAAAiH,MAAAo/B,GAAA,IAQA6wB,UAAA,SAAA7wB,GACA,GAAA3lC,GAAAk2D,EAAA52D,KAAAiH,MAAAo/B,GAAA,EACA,OAAAyf,GAAA9f,UAAAtlC,EAAAA,KAIAb,GAAAD,QAAA+8B,G5Dm+cM,SAAU98B,EAAQD,EAASM,G6DnldjC,GAAAyrB,GAAAzrB,EAAA,GAMAy8B,EAAAhR,EAAA7G,QACAhf,KAAA,MACAmB,OACAuK,GAAA,EACAE,GAAA,EACAE,EAAA,EACAo4C,WAAA,EACAC,SAAA,EAAA52C,KAAA0B,GACAy+C,WAAA,GAEA3oD,OACAiH,OAAA,OACAD,KAAA,MAEAomB,UAAA,SAAAE,EAAAlxB,GACA,GAAAwK,GAAAxK,EAAAuK,GACAG,EAAA1K,EAAAyK,GACAE,EAAAyB,KAAA6Q,IAAAjd,EAAA2K,EAAA,GACAo4C,EAAA/iD,EAAA+iD,WACAC,EAAAhjD,EAAAgjD,SACAuJ,EAAAvsD,EAAAusD,UACAC,EAAApgD,KAAA0lB,IAAAixB,GACA0J,EAAArgD,KAAAylB,IAAAkxB,EACA7xB,GAAA+vB,OAAAuL,EAAA7hD,EAAAH,EAAAiiD,EAAA9hD,EAAAD,GACAwmB,EAAA4xB,IAAAt4C,EAAAE,EAAAC,EAAAo4C,EAAAC,GAAAuJ,KAIA3zD,GAAAD,QAAA+8B,G7DyldM,SAAU98B,EAAQD,EAASM,G8D3ndjC,GAAA+D,GAAA/D,EAAA,GAEA8pB,EAAA9pB,EAAA,IAWAosB,EAAA,SAAA7a,EAAAE,EAAAiE,EAAAC,EAAAgkB,EAAAs9B,GAIAn3D,KAAAyR,EAAA,MAAAA,EAAA,EAAAA,EACAzR,KAAA2R,EAAA,MAAAA,EAAA,EAAAA,EACA3R,KAAA4V,GAAA,MAAAA,EAAA,EAAAA,EACA5V,KAAA6V,GAAA,MAAAA,EAAA,EAAAA,EAEA7V,KAAA8F,KAAA,SAEA9F,KAAA69B,OAAAs5B,IAAA,EACAntC,EAAAzpB,KAAAP,KAAA65B,GAGAvN,GAAApnB,WACAqrB,YAAAjE,GAEAroB,EAAAkpB,SAAAb,EAAAtC,EACA,IAAA2S,GAAArQ,CACAzsB,GAAAD,QAAA+8B,G9DiodM,SAAU98B,EAAQD,EAASM,G+DlqdjC,GAAA+D,GAAA/D,EAAA,GAEA8pB,EAAA9pB,EAAA,IAUAqsB,EAAA,SAAA9a,EAAAE,EAAAC,EAAAioB,EAAAs9B,GAIAn3D,KAAAyR,EAAA,MAAAA,EAAA,GAAAA,EACAzR,KAAA2R,EAAA,MAAAA,EAAA,GAAAA,EACA3R,KAAA4R,EAAA,MAAAA,EAAA,GAAAA,EAEA5R,KAAA8F,KAAA,SAEA9F,KAAA69B,OAAAs5B,IAAA,EACAntC,EAAAzpB,KAAAP,KAAA65B,GAGAtN,GAAArnB,WACAqrB,YAAAhE,GAEAtoB,EAAAkpB,SAAAZ,EAAAvC,EACA,IAAA2S,GAAApQ,CACA1sB,GAAAD,QAAA+8B,G/DwqdM,SAAU98B,EAAQD,EAASM,GgEvsdjC,GAAA+D,GAAA/D,EAAA,GAEA08B,EAAA18B,EAAA,GAEA0uD,EAAA1uD,EAAA,IAEAk3D,EAAAxI,EAAAtzB,KAqBA+7B,GAAA,WAAA,WAAA,QAAA,QAAA,SAKAC,EAAA,SAAAz2D,GACA,gBAAAA,GACAb,KAAAu3D,SAAA12D,GACGA,IACHA,EAAA22D,WAAAx3D,KAAAw3D,SAAA32D,EAAA22D,UACA,MAAA32D,EAAAyqB,WAAAtrB,KAAAsrB,SAAAzqB,EAAAyqB,UACAzqB,EAAAwmC,SAAArnC,KAAAqnC,OAAAxmC,EAAAwmC,QACAxmC,EAAAumC,QAAApnC,KAAAonC,MAAAvmC,EAAAumC,QAGA,MAAApnC,KAAAw3D,SACAx3D,KAAAw3D,SAAAx3D,KAAAw3D,SAAApiD,MAAA,KAEApV,KAAAw3D,SAAAH,EAIAC,GAAApyD,WACAqrB,YAAA+mC,EAQAE,SAAA,IAMAnwB,OAAA,SAMA/b,SAAA,IAKA8b,MAAA,EACAmwB,SAAA,SAAApgC,GACA,GAAApZ,GAAAoZ,EAAA/hB,MAAA,OACApV,MAAAw3D,SAAAz5C,EAAA,GACA/d,KAAAsrB,UAAAvN,EAAA,GACA/d,KAAAonC,OAAArpB,EAAA,GACA/d,KAAAqnC,OAAAtpB,EAAA,IAOA,IAAA05C,GAAA,SAAA52D,GACAA,EAAAA,MACAb,KAAA03D,WAMA13D,KAAA23D,IAAA92D,EAAA6oB,GACA1pB,KAAA43D,cACA53D,KAAA63D,wBAEAh3D,EAAAi3D,eACA93D,KAAA+3D,cAAAl3D,EAAAi3D,aAGA,IAAAE,GAAAn3D,EAAAo3D,MAEA,IAAAD,EACA,IAAA,GAAA3vD,KAAA2vD,GACA,GAAAA,EAAA9tC,eAAA7hB,GAAA,CACA,GAAA6vD,GAAAF,EAAA3vD,EAEArI,MAAAm4D,UAAA9vD,EAAA6vD,GAKAl4D,KAAAo4D,SAAAp4D,KAAA+3D,eAGAN,GAAAvyD,WACAqrB,YAAAknC,EAOAM,cAAA,SAOAM,cAAA,GACA3uC,GAAA,WACA,MAAA1pB,MAAA23D,KAEAQ,UAAA,SAAA9vD,EAAA6vD,GAQA,GAPAl4D,KAAA03D,QAAArvD,GAAA6vD,EAEAA,EAAAI,aACAJ,EAAAI,WAAA,GAAAhB,GAAAY,EAAAI,aAIAjwD,IAAArI,KAAA+3D,cACA/3D,KAAAu4D,mBAAAL,OACK,CACL,GAAAxuC,GAAA1pB,KAAA23D,GAGA1zD,GAAA8M,MAAAmnD,EAAArtD,MAAA6e,EAAA7e,OAAA,GAAA,GAEAqtD,EAAAjxD,MACAhD,EAAA8M,MAAAmnD,EAAAjxD,MAAAyiB,EAAAziB,OAAA,GAAA,GAEAixD,EAAAjxD,MAAAhD,EAAAmC,MAAAsjB,EAAAziB,OAAA,EAGA,KAAA,GAAAoB,KAAArI,MAAA03D,QACA13D,KAAA03D,QAAAxtC,eAAA7hB,IACArI,KAAAu4D,mBAAAv4D,KAAA03D,QAAArvD,MAKAkwD,mBAAA,SAAAL,GACA,GAAAJ,GAAA93D,KAAA03D,QAAA13D,KAAA+3D,cAEAD,IAAAI,IAAAJ,GACA7zD,EAAA8M,MAAAmnD,EAAAJ,GAAA,GAAA,IAGAM,SAAA,SAAA/vD,EAAA60B,GACA,GAAA70B,IAAArI,KAAAq4D,eAAAr4D,KAAAw4D,aAAA,CAIA,GAAAN,GAAAl4D,KAAA03D,QAAArvD,EAEA,IAAA6vD,EAAA,CAGA,GAFAl4D,KAAAy4D,mBAEAv7B,EAAA,CACA,GAAAw7B,GAAA14D,KAAA03D,QAAA13D,KAAAq4D,cAEAK,IACAA,EAAAC,SAAAD,EAAAC,QAAAp4D,KAAAP,MAGAk4D,EAAAU,SAAAV,EAAAU,QAAAr4D,KAAAP,MAKA,GAFAA,KAAAq4D,cAAAhwD,EAEArI,KAAA23D,IAAA,CACA,GAAAjuC,GAAA1pB,KAAA23D,GAmBA,IAjBA,MAAAO,EAAAl7B,SACAtT,EAAAsT,OAAAk7B,EAAAl7B,QAGA,MAAAk7B,EAAAnmD,IACA2X,EAAA3X,EAAAmmD,EAAAnmD,GAIAmmD,EAAAjtD,UAAAmsD,EAAA1tC,EAAAze,SAAAitD,EAAAjtD,UACAitD,EAAAjkD,OAAAmjD,EAAA1tC,EAAAzV,MAAAikD,EAAAjkD,OAEA,MAAAikD,EAAArjD,WACA6U,EAAA7U,SAAAqjD,EAAArjD,UAIAqjD,EAAArtD,MAAA,CACA,GAAAitD,GAAA93D,KAAA03D,QAAA13D,KAAA+3D,cACAruC,GAAA7e,MAAA,GAAA+xB,GAEAk7B,GACApuC,EAAA7e,MAAA2xB,WAAAs7B,EAAAjtD,OAAA,GAIAxC,GAAArI,KAAA+3D,eACAD,EAAAjtD,QAAAqtD,EAAArtD,OACA6e,EAAA7e,MAAA2xB,WAAA07B,EAAArtD,OAAA,GAIAqtD,EAAAjxD,QACAyiB,EAAAziB,MAAAhD,EAAAmC,MAAA8xD,EAAAjxD,OAAA,IAGAyiB,EAAA4O,SAIA,IAAA,GAAAjrB,GAAA,EAAmBA,EAAArN,KAAA43D,WAAAzxD,OAA4BkH,IAC/CrN,KAAA43D,WAAAQ,SAAA/vD,KAGAwwD,SAAA,WACA,MAAA74D,MAAAq4D,eAEAS,gBAAA,SAAA5xD,EAAA8/B,GACA,GAAA9/B,IAAAlH,KAAAq4D,eAAAr4D,KAAAw4D,aAAA,CAIA,GAAAN,GAAAl4D,KAAA03D,QAAAxwD,GACA6xD,EAAA,mBACApsB,EAAA3sC,KAEAg5D,IAEA,IAAAd,EAAA,CACAvrB,EAAA8rB,iBAEA,IAAA/uC,GAAAijB,EAAAgrB,GAEA,IAAAO,EAAAI,YAAA5uC,GAAAA,EAAAsS,KAAA,CAeA,IAAA,GAbAi9B,GAAAf,EAAAI,WACAd,EAAAyB,EAAAzB,SACA0B,EAAA,EAEAC,EAAA,WACAD,IAEA,IAAAA,IACAvsB,EAAAyrB,SAAAlxD,GACA8/B,GAAAA,MAIA35B,EAAA,EAAuBA,EAAAmqD,EAAArxD,OAAqBkH,IAAA,CAC5C,GAAA08B,GAAAytB,EAAAnqD,EAEA,IAAA,UAAA08B,GAAA,UAAAA,GACA,GAAAmuB,EAAAnuB,GACA,IAAA,GAAA/jC,KAAAkyD,GAAAnuB,GACA,GAAAmuB,EAAAnuB,GAAA7f,eAAAlkB,GAAA,CAIA,GAAA+mB,GAAAgd,EAAA,IAAA/jC,CAEAgzD,GAAAjsC,KAIAisC,EAAAjsC,GAAA,EACAmsC,GAAAvsB,EAAAysB,UAAAlB,EAAAnuB,EAAA/jC,EAAAizD,EAAAE,SAGW,CACX,GAAAH,EAAAjvB,GACA,QAKA,IAFAivB,EAAAjvB,GAAA,EAEAA,EAAAuqB,MAAAyE,GAAA,CAEA,GAAAM,GAAAtvB,EAAAnhB,MAAA,EAAA,EACAmhB,GAAAA,EAAAnhB,MAAA,GACAswC,GAAAvsB,EAAAysB,UAAAlB,EAAAmB,EAAAtvB,EAAAkvB,EAAAE,OAEAD,IAAAvsB,EAAAysB,UAAAlB,EAAA,GAAAnuB,EAAAkvB,EAAAE,IAMA,IAAAD,IACAvsB,EAAAyrB,SAAAlxD,GACA8/B,GAAAA,SAGA2F,GAAAyrB,SAAAlxD,GACA8/B,GAAAA,IAMA,IAAA,GAFAsyB,GAAA3sB,EAAAirB,WAEAvqD,EAAA,EAAmBA,EAAAisD,EAAAnzD,OAAsBkH,IACzCisD,EAAAR,gBAAA5xD,KAaAkyD,UAAA,SAAAlB,EAAAqB,EAAAvzD,EAAAizD,EAAAjyB,GACA,GAAAtd,GAAA1pB,KAAA23D,IACA6B,EAAAD,EAAArB,EAAAqB,GAAArB,EACAuB,EAAAF,EAAA7vC,EAAA6vC,GAAA7vC,EACAgwC,EAAAF,GAAAxzD,IAAAwzD,IAAAC,GAAAzzD,IAAAyzD,GACAE,EAAA35D,KAAA63D,oBAEA,IAAA6B,EAAA,CACA,GAAA7nC,KAEA,IAAA2nC,EAAAxzD,KAAAyzD,EAAAzzD,GACA,MAAA,EAGA6rB,GAAA7rB,GAAAwzD,EAAAxzD,EACA,IAAA8gC,GAAApd,EAAA2S,QAAAk9B,GAAA5xB,KAAAsxB,EAAA3tC,SAAAuG,GAAAuV,MAAA6xB,EAAAW,OAAA5yB,KAAA,WACA,GAAA8jB,GAAA7mD,EAAA4M,QAAA8oD,EAAA,EAEA7O,GAAA,GACA6O,EAAApsD,OAAAu9C,EAAA,GAGA9jB,MACOvyB,MAAAwkD,EAAA5xB,OAEP,OADAsyB,GAAAnwD,KAAAs9B,GACA,EAGA,MAAA,IAEA2xB,gBAAA,WAGA,IAAA,GAFAkB,GAAA35D,KAAA63D,qBAEAxqD,EAAA,EAAmBA,EAAAssD,EAAAxzD,OAAgCkH,IACnDssD,EAAAtsD,GAAAwY,MAGA8zC,GAAAxzD,OAAA,GAEAqyD,WAAA,WACA,MAAAx4D,MAAA63D,qBAAA1xD,OAAA,GAEA0zD,aAAA,SAAA5B,GACAj4D,KAAA43D,WAAApuD,KAAAyuD,IAEA6B,gBAAA,SAAA7B,GACA,GAAAnN,GAAA7mD,EAAA4M,QAAA7Q,KAAA43D,WAAAK,EAEAnN,IAAA,GACA9qD,KAAA43D,WAAArqD,OAAA0qD,EAAA,IAIA,IAAAt7B,GAAA86B,CACA53D,GAAAD,QAAA+8B,GhE6sdM,SAAU98B,EAAQD,EAASM,GiEtlejC,QAAA4D,GAAAi2D,EAAA72C,EAAApiB,EAAAK,EAAAujB,EAAA6B,GAEAvmB,KAAA+5D,UAAAA,EACA/5D,KAAAmB,aAAAA,EACAnB,KAAA0kB,SAAAA,EACA1kB,KAAAumB,OAAAA,EACAvmB,KAAA+X,MACA/X,KAAAg6D,WACAh6D,KAAAc,MAAAA,EACAd,KAAAi6D,IAAA37C,SAAAC,cAAA,OACAve,KAAAymB,UAAAnI,SAAAC,cAAA,OACAve,KAAAkjB,cAAAjf,EAAAmC,MAAA8c,GACAljB,KAAAk6D,gBAAA,EAAA,GACAl6D,KAAAm6D,SAfA,GAAAl2D,GAAA/D,EAAA,EACAA,GAAA,GAiBA4D,GAAAoB,UAAAi1D,OAAA,WACA,GAAAjxD,GAAAlJ,IACAkJ,GAAA6O,MAAA,GACA,IAAAqiD,GAAAlxD,EAAApI,MAAAmO,MAAA/F,EAAA6O,MACAsiD,EAAAnxD,EAAApI,MAAAoO,OAAAhG,EAAA6O,KACA7O,GAAA/H,aAAA0J,MAAAoE,MAAAmrD,EAAA,KACAlxD,EAAA/H,aAAA0J,MAAAqE,OAAAmrD,EAAA,KACAnxD,EAAA/H,aAAA0J,MAAAyvD,WAAAD,EAAA,KACAnxD,EAAA/H,aAAA0J,MAAA0vD,WAAArxD,EAAA6wD,UAAA10D,WAAA+0D,EAAA,KACAlxD,EAAA/H,aAAA0J,MAAAI,SAAA,WACA/B,EAAA/H,aAAA0J,MAAA2vD,WAAA,OAAAtxD,EAAAqd,OAAA,cACArd,EAAA/H,aAAA0J,MAAA4vD,eAAAL,GAAAlxD,EAAApI,MAAAmO,MAAA/F,EAAAwb,SAAA,GAAAxb,EAAA6wD,UAAA10D,YAAA,KACA6D,EAAAuxD,eAAAx2D,EAAAmC,MAAA8C,EAAA/H,aAAA0J,MAAA4vD,gBACAvxD,EAAA/H,aAAA+e,UAAA,GACAhX,EAAAud,UAAA5b,MAAAoV,OAAA,oBACA/W,EAAAud,UAAA5b,MAAA0K,OAAA,UACArM,EAAAud,UAAA5b,MAAAoE,MAAA/F,EAAA6wD,UAAA10D,WAAA6D,EAAApI,MAAAmO,MAAAmrD,EAAA,KACAlxD,EAAAud,UAAA5b,MAAAqE,OAAAhG,EAAA6wD,UAAAz0D,YAAA4D,EAAApI,MAAAoO,OAAAmrD,EAAA,KACAnxD,EAAAwxD,YAAAxxD,EAAAud,UAAA5b,MAAAoE,MACA/F,EAAAyxD,aAAAzxD,EAAAud,UAAA5b,MAAAqE,OACAhG,EAAAud,UAAA5b,MAAAI,SAAA,WACA/B,EAAAud,UAAA5b,MAAAiI,IAAA,MACA5J,EAAAud,UAAA5b,MAAA+H,KAAA,MACA1J,EAAA/H,aAAAgf,YAAAngB,KAAAymB,YAEA3iB,EAAAoB,UAAAmhB,gBAAA,SAAAu0C,EAAAC,EAAAn1C,EAAA1kB,GACA,GAAAkI,GAAAlJ,IACAkJ,GAAAwc,UAAAA,EACA1lB,KAAAymB,UAAA5b,MAAAoE,MAAAjP,KAAAymB,UAAA5b,MAAAoE,MAAA0nB,QAAA,KAAA,IAAAjR,EAAA,KACA1lB,KAAAymB,UAAA5b,MAAAqE,OAAAlP,KAAAymB,UAAA5b,MAAAqE,OAAAynB,QAAA,KAAA,IAAAjR,EAAA,KACAxc,EAAAgxD,eAAA,GAAAj2D,EAAAmC,MAAAw0D,GAAA1xD,EAAA6O,MAAA/W,EACAkI,EAAAgxD,eAAA,GAAAj2D,EAAAmC,MAAAy0D,GAAA3xD,EAAA6O,MAAA/W,EACAhB,KAAAymB,UAAA5b,MAAA+H,MAAA1J,EAAAgxD,eAAA,GAAA,KACAl6D,KAAAymB,UAAA5b,MAAAiI,KAAA5J,EAAAgxD,eAAA,GAAA,MAEAp2D,EAAAoB,UAAAshB,UAAA,SAAAD,EAAAu0C,GACA,GAAA5xD,GAAAlJ,IACAkJ,GAAA/H,aAAA0J,MAAAgU,gBAAA,OAAA0H,EAAA,GACA,IAAA6zC,GAAAU,EAAA7rD,MAAA/F,EAAA6O,MACAsiD,EAAAS,EAAA5rD,OAAAhG,EAAA6O,KACA7O,GAAA/H,aAAA0J,MAAAoE,MAAAmrD,EAAA,KACAlxD,EAAA/H,aAAA0J,MAAAqE,OAAAmrD,EAAA,KACAnxD,EAAA/H,aAAA0J,MAAAyvD,WAAAD,EAAA,KACAnxD,EAAA/H,aAAA0J,MAAA0vD,WAAArxD,EAAA6wD,UAAA10D,WAAA+0D,EAAA,MAEAt2D,EAAAoB,UAAAif,wBAAA,SAAAhJ,EAAAna,GACA,GAAAkI,GAAAlJ,IACAkJ,GAAAgxD,eAAA,GAAAj2D,EAAAmC,MAAA+U,EAAA,IAAAjS,EAAA6O,MAAA/W,EACAkI,EAAAgxD,eAAA,GAAAj2D,EAAAmC,MAAA+U,EAAA,IAAAjS,EAAA6O,MAAA/W,EACAhB,KAAAymB,UAAA5b,MAAA+H,MAAA1J,EAAAgxD,eAAA,GAAA,KACAl6D,KAAAymB,UAAA5b,MAAAiI,KAAA5J,EAAAgxD,eAAA,GAAA,MAEAp2D,EAAAoB,UAAA8hB,oBAAA,SAAAlmB,EAAAE,GACA,GAAAkI,GAAAlJ,KACA+6D,GAAAx4C,OAAArZ,EAAAud,UAAA5b,MAAA+H,KAAA4P,UAAA,EAAAtZ,EAAAud,UAAA5b,MAAA+H,KAAAzM,OAAA,IAAA+C,EAAA6O,MAAA/W,EACAg6D,GAAAz4C,OAAArZ,EAAAud,UAAA5b,MAAAiI,IAAA0P,UAAA,EAAAtZ,EAAAud,UAAA5b,MAAAiI,IAAA3M,OAAA,IAAA+C,EAAA6O,MAAA/W,CACAF,GAAA0N,KAAA,YAAAusD,EAAAC,KAGAn7D,EAAAD,QAAAkE,GjEimeM,SAAUjE,EAAQD,EAASM,GkEhqejC,QAAAitB,GAAAmE,EAAAC,GAGA,QAAAC,MAFA,GAAAC,GAAAH,EAAApsB,SAGAssB,GAAAtsB,UAAAqsB,EAAArsB,UACAosB,EAAApsB,UAAA,GAAAssB,EAEA,KAAA,GAAAE,KAAAD,GACAH,EAAApsB,UAAAwsB,GAAAD,EAAAC,EAEAJ,GAAApsB,UAAAqrB,YAAAe,EACAA,EAAAK,WAAAJ,EAGA,QAAA0pC,KAKA,IAAA,GADArpD,GAHAspD,EAAA,iEAAA9lD,MAAA,IACA+lD,EAAA,GAAA/hD,OAAA,IACAgiD,EAAA,EAEA/tD,EAAA,EAAuBA,EAAA,GAAQA,IAC/B,GAAAA,GAAA,IAAAA,GAAA,IAAAA,GAAA,IAAAA,EACA8tD,EAAA9tD,GAAA,IACa,IAAAA,EACb8tD,EAAA9tD,GAAA,KAEA+tD,GAAA,IAAAA,EAAA,SAAA,SAAA/nD,KAAAgoD,SAAA,GACAzpD,EAAA,GAAAwpD,EACAA,IAAA,EACAD,EAAA9tD,GAAA6tD,EAAA,IAAA7tD,EAAA,EAAAuE,EAAA,EAAAA,GAGA,OAAA,OAAAupD,EAAA1xB,KAAA,IAUA,QAAA/kB,GAAAsjB,EAAAe,GACA,MAAA11B,MAAA2D,KAAA3D,KAAA4D,IAAA+wB,EAAAv2B,EAAAs3B,EAAAt3B,EAAA,GAAA4B,KAAA4D,IAAA+wB,EAAAr2B,EAAAo3B,EAAAp3B,EAAA,IAQA,QAAA2pD,GAAAv4C,GAGA,IAAA,GAFAviB,GAAAkkB,EAAA3B,EAAA,GAAAA,EAAA,IACAlB,GAAAkB,EAAA,GAAAA,EAAA,IACA1V,EAAA,EAAuBA,EAAA0V,EAAA5c,OAAA,EAAuBkH,IAE9C7M,EAAAkkB,EAAA3B,EAAA1V,GAAA0V,EAAA1V,EAAA,MACA7M,EAAAkkB,EAAA3B,EAAA1V,GAAA0V,EAAA1V,EAAA,IACAwU,GAAAkB,EAAA1V,GAAA0V,EAAA1V,EAAA,IAIA,OAAAwU,GAMA,QAAA05C,GAAAnuD,GAEA,IAAA,GADA01B,GAAA,EACAz1B,EAAA,EAAuBA,EAAAD,EAAAjH,OAAA,EAAkBkH,IACzCy1B,GAAApe,EAAAtX,EAAAC,GAAAD,EAAAC,EAAA,GAGA,OAAAy1B,GAQA,QAAA5e,GAAA9W,GACA,GAAA,GAAAA,EAAAouD,OACA,MAAAC,IAGA,KAAA,GADAj7D,GAAA4M,EAAA,GACAC,EAAA,EAA2BA,EAAAD,EAAAjH,OAAckH,IACzC7M,EAAA4M,EAAAC,KACA7M,EAAA4M,EAAAC,GAIA,OAAA7M,GAUA,QAAAyjB,GAAA7W,GACA,GAAA,GAAAA,EAAAouD,OACA,MAAAC,IAGA,KAAA,GADAj7D,GAAA4M,EAAA,GACAC,EAAA,EAA2BA,EAAAD,EAAAjH,OAAckH,IACzC7M,EAAA4M,EAAAC,KACA7M,EAAA4M,EAAAC,GAIA,OAAA7M,GAUA,QAAAk7D,GAAAtuD,GACA,GAAAA,EAAAjH,QAAA,EACA,OAAA,CAGA,KAAA,GAAAkH,GAAA,EAAuBA,EAAAD,EAAAjH,OAAA,EAAkBkH,IACzC,GAAAD,EAAAC,GAAAoE,GAAArE,EAAAC,EAAA,GAAAoE,GAAArE,EAAAC,GAAAsE,GAAAvE,EAAAC,EAAA,GAAAsE,EACA,OAAA,CAIA,QAAA,EAWA,QAAAgqD,GAAAC,EAAAC,GAEA,GAAAD,EAAAE,WAAArqD,GAAAmqD,EAAAG,SAAAtqD,GAAAoqD,EAAAC,WAAArqD,GAAAoqD,EAAAE,SAAAtqD,EACA,MAAAmqD,GAAAE,WAAArqD,GAAAoqD,EAAAC,WAAArqD,IAEAmqD,EAAAI,SAAAH,EAAAC,WAAArqD,EAAAoqD,EAAAC,WAAAnqD,IACAiqD,EAAAI,SAAAH,EAAAE,SAAAtqD,EAAAoqD,EAAAE,SAAApqD,GAKA,IAAAiqD,EAAAE,WAAArqD,GAAAmqD,EAAAG,SAAAtqD,GAAAoqD,EAAAC,WAAArqD,GAAAoqD,EAAAE,SAAAtqD,EAAA,CAEA,GAAAmqD,EAAAE,WAAArqD,GAAAmqD,EAAAG,SAAAtqD,EAAA,CACA,GAAAqxB,GAAA84B,CACAA,GAAAC,EACAA,EAAA/4B,EAIA,GAAA6B,IAAAi3B,EAAAG,SAAApqD,EAAAiqD,EAAAE,WAAAnqD,IAAAiqD,EAAAG,SAAAtqD,EAAAmqD,EAAAE,WAAArqD,GACAg0B,EAAAm2B,EAAAE,WAAAnqD,EAAAgzB,EAAAi3B,EAAAE,WAAArqD,EACA44C,EAAAwR,EAAAC,WAAArqD,EACA64C,EAAA3lB,EAAA0lB,EAAA5kB,CACA,OAAAm2B,GAAAI,SAAA3R,EAAAC,IAAAuR,EAAAG,SAAA3R,EAAAC,GAMA,GAAA2R,IAAAL,EAAAG,SAAApqD,EAAAiqD,EAAAE,WAAAnqD,IAAAiqD,EAAAG,SAAAtqD,EAAAmqD,EAAAE,WAAArqD,GACAyqD,EAAAN,EAAAE,WAAAnqD,EAAAsqD,EAAAL,EAAAE,WAAArqD,EAEA0qD,GAAAN,EAAAE,SAAApqD,EAAAkqD,EAAAC,WAAAnqD,IAAAkqD,EAAAE,SAAAtqD,EAAAoqD,EAAAC,WAAArqD,GACA2qD,EAAAP,EAAAC,WAAAnqD,EAAAwqD,EAAAN,EAAAC,WAAArqD,CAEA,OAAAwqD,IAAAE,EACAD,GAAAE,IAEAR,EAAAI,SAAAH,EAAAC,WAAArqD,EAAAoqD,EAAAC,WAAAnqD,IAAAiqD,EAAAI,SAAAH,EAAAE,SAAAtqD,EAAAoqD,EAAAE,SAAApqD,KAaA04C,GAAA+R,EAAAF,IAAAD,EAAAE,GACA7R,EAAA2R,EAAA5R,EAAA6R,EACAN,EAAAI,SAAA3R,EAAAC,IAAAuR,EAAAG,SAAA3R,EAAAC,IAcA,QAAA+R,GAAAt5C,EAAAu5C,EAAAC,GAIA,GAAA9gD,KACAA,GAAAjS,KAAA,GAAAiM,GAAA,GAAAzR,GAAAs4D,EAAA,GAAAA,EAAA,IAAA,GAAAt4D,GAAAs4D,EAAA,GAAAA,EAAA,MACA7gD,EAAAjS,KAAA,GAAAiM,GAAA,GAAAzR,GAAAs4D,EAAA,GAAAA,EAAA,IAAA,GAAAt4D,GAAAs4D,EAAA,GAAAA,EAAA,MACA7gD,EAAAjS,KAAA,GAAAiM,GAAA,GAAAzR,GAAAs4D,EAAA,GAAAA,EAAA,IAAA,GAAAt4D,GAAAs4D,EAAA,GAAAA,EAAA,MACA7gD,EAAAjS,KAAA,GAAAiM,GAAA,GAAAzR,GAAAs4D,EAAA,GAAAA,EAAA,IAAA,GAAAt4D,GAAAs4D,EAAA,GAAAA,EAAA,KAEA,KAAA,GAAAluB,GAAA,EAAuBA,EAAArrB,EAAA5c,OAAA,EAAuBioC,IAK9C,IAAA,GAHAouB,GAAA,GAAA/mD,GAAAsN,EAAAqrB,GAAArrB,EAAAqrB,EAAA,IAGA/gC,EAAA,EAA2BA,EAAAoO,EAAAtV,OAAkBkH,IAC7C,GAAAsuD,EAAAa,EAAA/gD,EAAApO,IACA,OAAA,CAMA,IAAAkvD,EAKA,IAAA,GAHAE,GAAA,GAAAhnD,GAAAsN,EAAAA,EAAA5c,OAAA,GAAA4c,EAAA,IAGApF,EAAA,EAA2BA,EAAAlC,EAAAtV,OAAkBwX,IAC7C,GAAAg+C,EAAAc,EAAAhhD,EAAAkC,IACA,OAAA,CAKA,QAAA,EAeA,QAAA++C,GAAAtvD,GACA,GAAAA,EAAAjH,QAAA,EACA,QAIA,KAAA,GADAw2D,GAAA,EACAtvD,EAAA,EAAuBA,EAAAD,EAAAjH,OAAA,EAAkBkH,IACzC,GAAAD,EAAAC,EAAA,GAAAoE,GAAArE,EAAAC,GAAAoE,GAAArE,EAAAC,GAAAoE,GAAArE,EAAAC,EAAA,GAAAoE,EAAA,CACA,GAAAmrD,EAAAxvD,EAAAC,EAAA,GAAAsE,EAAAvE,EAAAC,GAAAsE,IAAAirD,EAAAxvD,EAAAC,GAAAsE,EAAAvE,EAAAC,EAAA,GAAAsE,GAGA,QAFAgrD,SAIa,IAAAvvD,EAAAC,EAAA,GAAAsE,GAAAvE,EAAAC,GAAAsE,GAAAvE,EAAAC,GAAAsE,GAAAvE,EAAAC,EAAA,GAAAsE,EAAA,CACb,GAAAirD,EAAAxvD,EAAAC,EAAA,GAAAoE,EAAArE,EAAAC,GAAAoE,IAAAmrD,EAAAxvD,EAAAC,GAAAoE,EAAArE,EAAAC,EAAA,GAAAoE,GAGA,QAFAkrD,SAKAA,IAIA,OAAAA,GAUA,QAAAC,GAAAnrD,GACA,MAAAA,GAAA,EACA,EACAA,EAAA,KAGA,EAUA,QAAAorD,GAAAzvD,GACA,GAAAA,EAAAjH,QAAA,EACA,OAAA,CAGA,KAAA,GAAAkH,GAAA,EAAuBA,EAAAD,EAAAjH,OAAA,EAAkBkH,IACzC,GAAAD,EAAAC,GAAAoE,GAAArE,EAAAC,EAAA,GAAAoE,GAAArE,EAAAC,EAAA,GAAAoE,GAAArE,EAAAC,EAAA,GAAAoE,GACA,GAAA,GAAAmrD,EAAAxvD,EAAAC,EAAA,GAAAsE,EAAAvE,EAAAC,GAAAsE,IACAirD,EAAAxvD,EAAAC,EAAA,GAAAsE,EAAAvE,EAAAC,GAAAsE,OAAAirD,EAAAxvD,EAAAC,EAAA,GAAAsE,EAAAvE,EAAAC,EAAA,GAAAsE,GACA,OAAA,MAGa,IAAAvE,EAAAC,GAAAsE,GAAAvE,EAAAC,EAAA,GAAAsE,GAAAvE,EAAAC,EAAA,GAAAsE,GAAAvE,EAAAC,EAAA,GAAAsE,GACb,GAAAirD,EAAAxvD,EAAAC,EAAA,GAAAoE,EAAArE,EAAAC,GAAAoE,IACAmrD,EAAAxvD,EAAAC,EAAA,GAAAoE,EAAArE,EAAAC,GAAAoE,OAAAmrD,EAAAxvD,EAAAC,EAAA,GAAAoE,EAAArE,EAAAC,EAAA,GAAAoE,GACA,OAAA,CAMA,QAAA,EASA,QAAAqrD,GAAA/5C,EAAAg6C,GACA,GAAAC,KACA,IAAAD,EAAA,CACA,IAAA,GAAA1vD,GAAA,EAA2BA,EAAA0V,EAAA5c,OAAmBkH,IAAA,CAC9C,GAAAgE,GAAA0R,EAAA1V,EACA2vD,GAAAxzD,KAAA,GAAAxF,GAAAqN,EAAA,GAAAA,EAAA,KAEA,MAAA2rD,GAEA,IAAA,GAAAr/C,GAAA,EAA2BA,EAAAoF,EAAA5c,OAAmBwX,IAAA,CAC9C,GAAAs/C,GAAAl6C,EAAApF,EACAq/C,GAAAxzD,MAAAyzD,EAAAxrD,EAAAwrD,EAAAtrD,IAEA,MAAAqrD,GAMA,QAAAE,GAAApoD,GACA,GAAAqoD,KACA9pD,KAAA0lB,IAAAjkB,IAAAzB,KAAAylB,IAAAhkB,GAAA,IACAzB,KAAAylB,IAAAhkB,GAAAzB,KAAA0lB,IAAAjkB,GAAA,IACA,EAAA,EAAA,GAEA,OAAAqoD,GAGA,QAAAC,GAAA/7B,EAAAC,GACA,QACA,EAAA,EAAAD,IACA,EAAA,EAAAC,IACA,EAAA,EAAA,IAIA,QAAA+7B,GAAA15B,EAAAC,GAIA,MAHA,OAAAA,IACAA,EAAAD,KAGAA,EAAA,EAAA,IACA,EAAAC,EAAA,IACA,EAAA,EAAA,IAUA,QAAA05B,GAAAxB,EAAA31D,EAAA2O,GACA,GAAAinD,GAAAD,EAAA11D,OAKA,OAJA21D,GAAAvsC,UAAA4tC,GAAAtB,EAAArqD,GAAAqqD,EAAAnqD,IACAoqD,EAAApqD,GAAAxL,EACA41D,EAAAvsC,UAAA0tC,EAAApoD,IACAinD,EAAAvsC,UAAA4tC,EAAAtB,EAAArqD,EAAAqqD,EAAAnqD,IACAoqD,EASA,QAAAppD,GAAAH,EAAApJ,GACAA,EAAAA,KACA,IAAAwN,GAAA3S,EAAAmC,MAAAoM,EAAAoE,cAAApE,GACAqC,EAAAzL,EAAAyL,SACAkO,GACAnQ,KAAA,GAAA5O,GAAA4S,EAAAnF,EAAAmF,EAAAjF,EAAAiF,EAAA1H,OAAA,GACA4D,IAAA,GAAA9O,GAAA4S,EAAAnF,EAAAmF,EAAA3H,MAAA,EAAA2H,EAAAjF,GACAkB,MAAA,GAAA7O,GAAA4S,EAAAnF,EAAAmF,EAAA3H,MAAA2H,EAAAjF,EAAAiF,EAAA1H,OAAA,GACA6D,OAAA,GAAA/O,GAAA4S,EAAAnF,EAAAmF,EAAA3H,MAAA,EAAA2H,EAAAjF,EAAAiF,EAAA1H,QACA8I,OAAA,GAAAhU,GAAA4S,EAAAnF,EAAAmF,EAAA3H,MAAA,EAAA2H,EAAAjF,EAAAiF,EAAA1H,OAAA,GAGA,IAAA0lB,OAAA2oC,KAAAn0D,GAAAjD,OAAA,GAAAkN,KAAAC,IAAAuB,GAAA,EAAA,CACA,GAAA2oD,GAAAhrD,EAAAoE,aAAApE,EAAAC,EAAArJ,GACA4O,GAA0BvG,EAAA+rD,EAAA/rD,EAAAE,EAAA6rD,EAAA7rD,EAC1BijB,QAAA2oC,KAAAx6C,GAAA5V,QAAA,SAAAnH,GACA,GAAAC,GAAA8c,EAAA/c,GACAqkD,EAAAryC,EAAAvG,EAAAxL,EAAAwL,EACA64C,EAAAtyC,EAAArG,EAAA1L,EAAA0L,EACAmnB,EAAAzlB,KAAAylB,KAAAjkB,GACAkkB,EAAA1lB,KAAA0lB,KAAAlkB,GACA4oD,EAAAzlD,EAAAvG,GAAA44C,EAAAtxB,EAAAuxB,EAAAxxB,GACA4kC,EAAA1lD,EAAArG,GAAA04C,EAAAvxB,EAAAwxB,EAAAvxB,EACAhW,GAAA/c,GAAAyL,EAAAgsD,EACA16C,EAAA/c,GAAA2L,EAAA+rD,IAGA,MAAA36C,GAQA,QAAAxM,GAAA/D,EAAApJ,GACAA,EAAAA,KACA,IAAAwN,GAAA3S,EAAAmC,MAAAoM,EAAAoE,cACA/B,EAAAzL,EAAAyL,SACA8oD,GACAr6D,GAAA,GAAAU,GAAA4S,EAAAnF,EAAAmF,EAAAjF,GACA6E,GAAA,GAAAxS,GAAA4S,EAAAnF,EAAAmF,EAAA3H,MAAA,EAAA2H,EAAAjF,EAAA,GACApO,GAAA,GAAAS,GAAA4S,EAAAnF,EAAAmF,EAAA3H,MAAA2H,EAAAjF,GACAnO,GAAA,GAAAQ,GAAA4S,EAAAnF,EAAAmF,EAAAjF,EAAAiF,EAAA1H,QACAzL,GAAA,GAAAO,GAAA4S,EAAAnF,EAAAmF,EAAA3H,MAAA2H,EAAAjF,EAAAiF,EAAA1H,QACAxL,IAAA,GAAAM,GAAA4S,EAAAnF,EAAAmF,EAAA3H,MAAA,EAAA2H,EAAAjF,EAAA,IAEA,IAAAijB,OAAA2oC,KAAAn0D,GAAAjD,OAAA,GAAAkN,KAAAC,IAAAuB,GAAA,EAAA,CACA,GAAA2oD,GAAAhrD,EACAwF,GAA0BvG,EAAA+rD,EAAA/rD,EAAAE,EAAA6rD,EAAA7rD,EAC1BijB,QAAA2oC,KAAAI,GAAAxwD,QAAA,SAAAnH,GACA,GAAAC,GAAA03D,EAAA33D,GACAqkD,EAAAryC,EAAAvG,EAAAxL,EAAAwL,EACA64C,EAAAtyC,EAAArG,EAAA1L,EAAA0L,EACAmnB,EAAAzlB,KAAAylB,KAAAjkB,GACAkkB,EAAA1lB,KAAA0lB,KAAAlkB,GACA4oD,EAAAzlD,EAAAvG,GAAA44C,EAAAtxB,EAAAuxB,EAAAxxB,GACA4kC,EAAA1lD,EAAArG,GAAA04C,EAAAvxB,EAAAwxB,EAAAvxB,EACA4kC,GAAA33D,GAAAyL,EAAAgsD,EACAE,EAAA33D,GAAA2L,EAAA+rD,IAGA,MAAAC,GAUA,QAAAC,GAAA76C,EAAA/K,EAAAnD,GACA,GAAApD,GAAA2H,MAAAlM,QAAA6V,GAAAA,EAAA,GAAAA,EAAAtR,EACAE,EAAAyH,MAAAlM,QAAA6V,GAAAA,EAAA,GAAAA,EAAApR,EACA04C,EAAAryC,EAAAvG,EAAAA,EACA64C,EAAAtyC,EAAArG,EAAAA,EACAmnB,EAAAzlB,KAAAylB,KAAAjkB,GACAkkB,EAAA1lB,KAAA0lB,KAAAlkB,GACA4oD,EAAAzlD,EAAAvG,GAAA44C,EAAAtxB,EAAAuxB,EAAAxxB,GACA4kC,EAAA1lD,EAAArG,GAAA04C,EAAAvxB,EAAAwxB,EAAAvxB,EACA,OAAA3f,OAAAlM,QAAA6V,IACA06C,EAAAC,IAGAjsD,EAAAgsD,EACA9rD,EAAA+rD,GASA,QAAAG,GAAAz0D,GACA,QAEA,GAAAiK,KAAA4B,MAAA7L,EAAAqJ,UAAAxD,MAAA,EAAA,IAAA,IACA,GAAAoE,KAAA4B,MAAA,EAAA7L,EAAAqJ,UAAAxD,MAAA,EAAA,IAAA,IAEA7F,EAAAqJ,UAAAxD,MAAA,GAAAoE,KAAA4B,MAAA7L,EAAAqJ,UAAAvD,OAAA,EAAA,MACA9F,EAAAqJ,UAAAxD,MAAA,GAAAoE,KAAA4B,MAAA,EAAA7L,EAAAqJ,UAAAvD,OAAA,EAAA,MAEA,GAAAmE,KAAA4B,MAAA7L,EAAAqJ,UAAAxD,MAAA,EAAA,IAAA7F,EAAAqJ,UAAAvD,SACA,GAAAmE,KAAA4B,MAAA,EAAA7L,EAAAqJ,UAAAxD,MAAA,EAAA,IAAA7F,EAAAqJ,UAAAvD,SAEA,EAAA,GAAAmE,KAAA4B,MAAA7L,EAAAqJ,UAAAvD,OAAA,EAAA,MACA,EAAA,GAAAmE,KAAA4B,MAAA,EAAA7L,EAAAqJ,UAAAvD,OAAA,EAAA,MAWA,QAAA4uD,GAAA91B,EAAAe,GACA,OAAA11B,KAAA0B,GAAA,EAAA1B,KAAAqE,MACAqxB,EAAAp3B,EAAAq2B,EAAAr2B,EAAAo3B,EAAAt3B,EAAAu2B,EAAAv2B,GAuBA,QAAAssD,GAAA/1B,EAAAe,EAAAC,EAAAg1B,GACA,GAAAC,GAAAj2B,EAAAv2B,EAAAs3B,EAAAp3B,EAAAq2B,EAAAr2B,EAAAq3B,EAAAv3B,EAAAs3B,EAAAt3B,EAAAu3B,EAAAr3B,GAAAo3B,EAAAp3B,EAAAq3B,EAAAv3B,EAAAu2B,EAAAr2B,EAAAo3B,EAAAt3B,EAAAu2B,EAAAv2B,EAAAu3B,EAAAr3B,EAEA,OAAAqsD,GACA3qD,KAAAC,IAAA2qD,IAAAD,EAEA,IAAAC,EAQA,QAAAC,GAAAC,EAAAC,GACA,MAAA/qD,MAAA4B,MAAAkpD,EAAA9qD,KAAA4D,IAAA,GAAAmnD,IAAA/qD,KAAA4D,IAAA,GAAAmnD,GAMA,QAAAC,GAAAvC,EAAAC,GACA,MAAA1oD,MAAA2D,KAAA3D,KAAA4D,IAAA6kD,EAAArqD,EAAAsqD,EAAAtqD,EAAA,GAAA4B,KAAA4D,IAAA6kD,EAAAnqD,EAAAoqD,EAAApqD,EAAA,IAUA,QAAA2sD,GAAArmD,EAAAsmD,EAAAtpD,GACAgD,EAAAxG,EAAAysD,EAAAjmD,EAAAxG,EAAA,GACAwG,EAAAtG,EAAAusD,EAAAjmD,EAAAtG,EAAA,GACA4sD,EAAA9sD,EAAAysD,EAAAK,EAAA9sD,EAAA,GACA8sD,EAAA5sD,EAAAusD,EAAAK,EAAA5sD,EAAA,EACA,IAAAmD,GAAAzB,KAAAmrD,MAAAD,EAAA9sD,EAAAwG,EAAAxG,IAAA8sD,EAAA5sD,EAAAsG,EAAAtG,GAWA,KAVAmD,GAAAA,EAGAypD,EAAA9sD,GAAAwG,EAAAxG,GAAA8sD,EAAA5sD,GAAAsG,EAAAtG,EACAmD,GAAAzB,KAAA0B,GACSwpD,EAAA9sD,GAAAwG,EAAAxG,GAAA8sD,EAAA5sD,GAAAsG,EAAAtG,EACTmD,GAAAzB,KAAA0B,GACSwpD,EAAA9sD,GAAAwG,EAAAxG,GAAA8sD,EAAA5sD,GAAAsG,EAAAtG,IACTmD,GAAA,EAAAzB,KAAA0B,IAEAD,GAAA,EAAAzB,KAAA0B,IACAD,GAAA,EAAAzB,KAAA0B,EAQA,OANA0Q,OAAA3Q,KACAA,EAAA,GAEAG,IACAH,EAAAzB,KAAA4B,MAAAH,EAAAG,GAAAA,GAEAH,EAGA,QAAArC,GAAArJ,EAAAq1D,GACA,GAAAt9B,GAAA/3B,EAAA+3B,SACAvqB,EAAAxN,EAAA+F,iBAEAgyB,KACAvqB,EAAAuqB,EAAAhyB,kBAGA,IAAA4T,KACAA,GAAA,KAAAnM,EAAA3H,MAAA,GAAA2H,EAAA1H,OAAA,GACA6T,EAAA,IAAAnM,EAAA3H,MAAA,GAAA2H,EAAA1H,OAAA,GACA6T,EAAA,IAAAnM,EAAA3H,MAAA,EAAA2H,EAAA1H,OAAA,GACA6T,EAAA,KAAAnM,EAAA3H,MAAA,EAAA2H,EAAA1H,OAAA,GACA6T,EAAA,KAAAnM,EAAA3H,MAAA,GAAA2H,EAAA1H,OAAA,EAEA,IAAA6rD,GAAA3xD,EAAA6B,SAAA,GACA+vD,EAAA5xD,EAAA6B,SAAA,EAEA7B,GAAAjB,QAAA,cAAAiB,EAAAjB,OAAArC,MAAA24D,IACA1D,GAAA3xD,EAAAjB,OAAA8C,SAAA,GACA+vD,GAAA5xD,EAAAjB,OAAA8C,SAAA,GAGA,IAAAyzD,GAAA,GAAAlyC,GACAjK,OAAAw4C,EAAAnkD,EAAAnF,GACA8Q,OAAAy4C,EAAApkD,EAAAjF,GACA4Q,OAAA3L,EAAA3H,OACAsT,OAAA3L,EAAA1H,SAGAsC,EAAA+Q,OAAAw4C,GAAAx4C,OAAA3L,EAAA3H,OAAA,EAAAsT,OAAA3L,EAAAnF,GACAC,EAAA6Q,OAAAy4C,GAAAz4C,OAAA3L,EAAA1H,QAAA,EAAAqT,OAAA3L,EAAAjF,EACA,QACAF,EAAA8Q,OAAA/Q,GACAG,EAAA4Q,OAAA7Q,GACAzC,MAAAsT,OAAA3L,EAAA3H,OACAC,OAAAqT,OAAA3L,EAAA1H,QACA6T,OAAAA,EACAnM,aAAA8nD,GAgEA,QAAAC,KAIA,IAAA,GADA/tD,GAFAguD,GAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,KACAC,EAAA,IAEAxxD,EAAA,EAAuBA,EAAA,EAAOA,IAC9BuD,EAAAyC,KAAA4B,MAAA,GAAA5B,KAAAgoD,UACAwD,GAAAD,EAAAhuD,EAEA,OAAAiuD,GAGA,QAAA1yD,GAAA0lB,GACA,MAAA,UAAAA,EAGA,QAAAitC,GAAA1xD,GACA,GAAAwE,KAEA,IAAAxE,EAAAjH,OAAA,EACA,MAAAnC,GAAA+6D,WAAA3xD,EAGAwE,GAAApI,KAAA4D,EAAA,GAAAhH,QACA,KAAA,GAAAiH,GAAA,EAAoBA,EAAAD,EAAAjH,OAAA,EAAgBkH,IACpCD,EAAAC,EAAA,GAAAoE,GAAArE,EAAAC,GAAAoE,GAAArE,EAAAC,GAAAoE,GAAArE,EAAAC,EAAA,GAAAoE,GAAArE,EAAAC,EAAA,GAAAsE,GAAAvE,EAAAC,GAAAsE,GAAAvE,EAAAC,GAAAsE,GAAAvE,EAAAC,EAAA,GAAAsE,GAKAC,EAAApI,KAAA4D,EAAAC,GAAAjH,QAKA,OAFAwL,GAAApI,KAAA4D,EAAAA,EAAAjH,OAAA,GAAAC,SAEAwL,EAqCA,QAAAotD,GAAAj0D,EAAAk0D,EAAAC,IACAD,GAAAC,IAAAD,EAAAC,GACAD,EAAAA,MACAA,EAAAh7D,EAAAia,SAAA+gD,EAAAE,GAAA,EAGA,IAAAC,GAAAvoC,SACAooC,EAAAI,QAAAC,GAAArvC,QACAgvC,EAAAzJ,aAAA8J,GAAArvC,QACAgvC,EAAAM,UAAAD,GAAArvC,QACAwZ,KAAA,KAAA,KAAA,KAGA74B,EAAA,EACAqf,EAAA,QACAllB,GAAA4rB,QAAAyoC,EAAA,SAAA9K,EAAA+K,EAAA7J,EAAA+J,EAAApsD,GAaA,MAZA8c,IAAAllB,EAAA6d,MAAAhY,EAAAuC,GAAAwjB,QAAA6oC,EAAAC,GACA7uD,EAAAuC,EAAAmhD,EAAAnuD,OAEAk5D,EACApvC,GAAA,cAAAovC,EAAA,iCACa7J,EACbvlC,GAAA,cAAAulC,EAAA,uBACa+J,IACbtvC,GAAA,OAA6BsvC,EAAA,YAI7BjL,IAEArkC,GAAA,OAGAgvC,EAAAS,WAAAzvC,EAAA,mBAAwDA,EAAA,OAExDA,EAAA,4FAEAA,EAAA,eAEA,KACA,GAAAkqC,GAAA,GAAA3xC,UAAAy2C,EAAAS,UAAA,MAAAzvC,GACS,MAAAjpB,GAET,KADAA,GAAAipB,OAAAA,EACAjpB,EAGA,GAAAg4D,GAAA,SAAAxlD,GACA,MAAA2gD,GAAA55D,KAAAP,KAAAwZ,IAIA9Q,EAAAu2D,EAAAS,UAAA,KAGA,OAFAV,GAAA/uC,OAAA,YAAAvnB,EAAA,OAAsDunB,EAAA,IAEtD+uC,EAGA,QAAAW,GAAA9tC,GACA,MAAA,OAAAA,IACA5tB,EAAA2tB,YAAAC,KAAA5tB,EAAAiJ,QAAA2kB,IAAA5tB,EAAAsuB,SAAAV,IAAA,IAAAA,EAAA1rB,OAAA,QAEA,QAAAqO,GAAAtN,EAAA+oB,EAAAU,EAAAivC,GAGA,IAAA37D,EAAA2sB,SAAAX,KAAAhsB,EAAA2sB,SAAA1pB,GACA,MAAAypB,GAAA1sB,EAAAmC,MAAA6pB,GAAA/oB,CAGA,KAAA,GAAAlB,KAAAiqB,GACA,GAAAA,EAAA/F,eAAAlkB,GAAA,CACA,GAAA6qB,GAAA3pB,EAAAlB,GACA8qB,EAAAb,EAAAjqB,IAEA/B,EAAA2sB,SAAAE,KAAA7sB,EAAA2sB,SAAAC,IAAA5sB,EAAAiJ,QAAA4jB,IAAA7sB,EAAAiJ,QAAA2jB,IAAA5sB,EAAAkkB,MAAA2I,IAAA7sB,EAAAkkB,MAAA0I,IAAA5sB,EAAA8sB,gBAAAD,IAAA7sB,EAAA8sB,gBAAAF,IAAA5sB,EAAAysB,YAAAI,IAAA7sB,EAAAysB,YAAAG,IAGaF,GAAA3qB,IAAAkB,IAGblB,IAAA45D,IACA14D,EAAAlB,GAAA/B,EAAAmC,MAAA6pB,EAAAjqB,IAAA,IALAwO,EAAAqc,EAAAC,EAAAH,EAAAivC,GAUA,MAAA14D,GAEA,QAAA24D,MAr3BA,GAAA77D,GAAA9D,EAAA,IACAuV,EAAAvV,EAAA,IACAssB,EAAAtsB,EAAA,IACA+D,EAAA/D,EAAA,GAwpBA4/D,GACAC,UAAA,WACA,GAAAC,KAEA,QACAr5D,IAAA,SAAAX,EAAAC,GACA,GAAAg6D,GAAAjgE,KAAAqG,IAAAL,EACAi6D,GAAAz2D,KAAAvD,IAGAI,IAAA,SAAAL,GACA,IAAA,GAAAqH,GAAA,EAAmCA,EAAA2yD,EAAA75D,OAAkBkH,IACrD,GAAArH,GAAAg6D,EAAA3yD,GAAArH,IACA,MAAAg6D,GAAA3yD,GAAApH,KAIA,IAAAA,KAEA,OADA+5D,GAAAx2D,MAAgCxD,IAAAA,EAAAC,MAAAA,IAChCA,GAEAs3D,KAAA,WAEA,IAAA,GADAA,MACAlwD,EAAA,EAAmCA,EAAA2yD,EAAA75D,OAAkBkH,IACrDkwD,EAAA/zD,KAAAw2D,EAAA3yD,GAAArH,IAEA,OAAAu3D,IAEAzqD,IAAA,WACA,MAAAktD,GAAAA,EAAA75D,OAAA,IAEAsJ,OAAA,SAAAzJ,GAEA,IAAA,GADA8kD,MACAz9C,EAAA,EAAmCA,EAAA2yD,EAAA75D,OAAkBkH,IACrD,GAAArH,GAAAg6D,EAAA3yD,GAAArH,IAAA,CACA8kD,EAAAz9C,CACA,OAGA,MAAA2yD,GAAAzyD,OAAAu9C,EAAA,GAAA,IAEAoV,WAAA,SAAAl6D,EAAAsM,GACA,GAAA2tD,GAAAjgE,KAAAqG,IAAAL,GACA4K,EAAA3M,EAAA4M,QAAAovD,EAAA3tD,EACA2tD,GAAA1yD,OAAAqD,EAAA,IAGAuvD,UAAA,WACA,MAAAH,GAAAzyD,OAAAyyD,EAAA75D,OAAA,EAAA,GAAA,IAEAA,OAAA,WACA,MAAA65D,GAAA75D,QAEA0D,MAAA,WACAm2D,EAAAzyD,OAAA,EAAAyyD,EAAA75D,YA6CAg5D,GACAI,SAAA,kBACA/J,YAAA,mBACA6J,OAAA,oBAMAC,EAAA,OAIAc,GACAC,IAAA,IACAC,KAAA,KACAC,KAAA,IACAC,KAAA,IACAC,SAAA,QACAC,SAAA,SAGAlB,EAAA,4BAEAC,EAAA,SAAAnL,GACA,MAAA,KAAA8L,EAAA9L,GA+FAuL,GAAA/6C,OAAA,SAAA67C,GACA,GACAC,GAKA7wC,EANA8wC,EAAA,aAEA33D,EAAAlJ,KACA8gE,EAAAH,GAAAA,EAAAx+D,KAAAw+D,EAAAx+D,KAAA,WACA+G,EAAA0R,MAAA5a,KAAAkG,WAIA26D,GAAA37D,UAAAgE,EAAAhE,UACA6qB,EAAA+wC,EAAA/wC,GAAA+wC,EAAA57D,UAAA,GAAA27D,EAEA,KAAAD,IAAAD,GACA,MAAAA,EAAAC,IAAAD,EAAAC,GAAArwC,cAAAqE,OAEA7E,EAAA6wC,GAAA38D,EAAA+sB,aAAgD6vC,EAAA37D,UAAA07D,GAAAD,EAAAC,KAAA,GAEhD7wC,EAAA6wC,GAAAD,EAAAC,EAOA,OAHA7wC,GAAAQ,YAAAuwC,EACAA,EAAAh8C,OAAA5b,EAAA4b,OAEAg8C,GAGAjhE,EAAAD,SACAutB,SAAAA,EACA8tC,QAAAA,EACAv2C,SAAAA,EACA62C,kBAAAA,EACAr3C,IAAAA,EACAD,IAAAA,EACA07C,QAAAA,EACAnrD,SAAAA,EACAknD,eAAAA,EACAW,4BAAAA,EACAK,UAAAA,EACAG,YAAAA,EACAC,eAAAA,EACAQ,YAAAA,EACA3qD,mBAAAA,EACA4D,qBAAAA,EACAqnD,gBAAAA,EACAE,gBAAAA,EACAC,aAAAA,EACAX,kBAAAA,EACAC,YAAAA,EACApoD,MAAAipD,EACAG,UAAAA,EACAC,SAAAA,EACA7rD,QAAAA,EACAqtD,WAAAA,EACAxE,iBAAAA,EACAqD,YAAAA,EACAK,SAAAA,EACA7yD,YAAAA,EACA0xD,cAAAA,EACAiB,mBAAAA,EACAe,MAAAA,IlEwreM,SAAUhgE,EAAQD,GmElmgBxB,QAAAoE,GAAAyN,EAAAE,GAEA3R,KAAAyR,EAAAA,EAGAzR,KAAA2R,EAAAA,EASA3N,EAAA+8D,KAAA,SAAAC,GACA,GAAAC,GAAA,GAAAj9D,GAAAue,OAAAy+C,EAAAvvD,GAAA8Q,OAAAy+C,EAAArvD,GACA,OAAAsvD,IAQAj9D,EAAAk9D,UAAA,SAAA9zD,GAEA,IAAA,GADA4vD,MACA3vD,EAAA,EAAoBA,EAAAD,EAAAjH,OAAakH,IACjC2vD,EAAAxzD,KAAAxF,EAAA+8D,KAAA3zD,EAAAC,IAEA,OAAA2vD,IAQAh5D,EAAA+6D,WAAA,SAAA3xD,GAEA,IAAA,GADA4vD,MACA3vD,EAAA,EAAoBA,EAAAD,EAAAjH,OAAakH,IACjC2vD,EAAAxzD,KAAA4D,EAAAC,GAAAjH,QAEA,OAAA42D,IAGAh5D,EAAAkB,WACAqrB,YAAAvsB,EAEAwrB,UAAA,SAAA5D,GACA,GAAAu1C,GAAAnhE,KAAAyR,EACA2vD,EAAAphE,KAAA2R,CACA3R,MAAAyR,EAAAma,EAAA,GAAA,GAAAu1C,EAAAv1C,EAAA,GAAA,GAAAw1C,EAAAx1C,EAAA,GAAA,GACA5rB,KAAA2R,EAAAia,EAAA,GAAA,GAAAu1C,EAAAv1C,EAAA,GAAA,GAAAw1C,EAAAx1C,EAAA,GAAA,IAMAy1C,OAAA,SAAAC,GACA,MAAAA,aAAAt9D,KAGAhE,KAAAyR,GAAA6vD,EAAA7vD,GACAzR,KAAA2R,GAAA2vD,EAAA3vD,IAKAvL,MAAA,WACA,GAAA66D,GAAA,GAAAj9D,GAAAhE,KAAAyR,EAAAzR,KAAA2R,EACA,OAAAsvD,IAGAt6D,IAAA,SAAA0K,GAGA,MAFArR,MAAAyR,EAAAzR,KAAAyR,EAAAJ,EAAAI,EACAzR,KAAA2R,EAAA3R,KAAA2R,EAAAN,EAAAM,EACA3R,MAQAuhE,KAAA,SAAA9vD,EAAAE,EAAAy4C,GACA,GAAA1lC,GAAArR,KAAA2D,KAAA3D,KAAA4D,IAAAjX,KAAAyR,EAAAA,EAAA,GAAA4B,KAAA4D,IAAAjX,KAAA2R,EAAAA,EAAA,GAEA,OAAA+S,IAAA0lC,GAGA4R,SAAA,SAAAvqD,EAAAE,GACA,MAAA3R,MAAAyR,GAAAA,GAAAzR,KAAA2R,GAAAA,GAGA0X,SAAA,WACA,MAAA,IAAArpB,KAAAyR,EAAA,IAAAzR,KAAA2R,EAAA,KAGA6vD,UAAA,WACA,OAAAxhE,QAGAH,EAAAD,QAAAoE,GnEsngBM,SAAUnE,EAAQD,GoE9tgBxB,QAAA6V,GAAAqmD,EAAAC,GAEA/7D,KAAA87D,WAAAA,EAGA97D,KAAA+7D,SAAAA,EAGA/7D,KAAAyhE,MAAA,OAOAhsD,EAAAsrD,KAAA,SAAAC,GACA,GAAAU,GAAA,GAAAjsD,GACAzR,MAAA+8D,KAAAC,EAAAlF,YACA93D,MAAA+8D,KAAAC,EAAAjF,UAGA,OAAA2F,IAGAjsD,EAAAvQ,WACAy8D,WAAAlsD,EAIArP,MAAA,WACA,GAAAkjC,GAAA,GAAA7zB,GAAAzV,KAAA87D,WAAA11D,QAAApG,KAAA+7D,SAAA31D,QACA,OAAAkjC,IAGA+3B,OAAA,SAAAO,GACA,SAAAA,YAAAnsD,MAGAzV,KAAA87D,WAAAuF,OAAAO,EAAA9F,aACA97D,KAAA+7D,SAAAsF,OAAAO,EAAA7F,YAQAC,SAAA,SAAAvqD,EAAAE,GAEA,GAAA0B,KAAA4Q,IAAAjkB,KAAA87D,WAAArqD,EAAAzR,KAAA+7D,SAAAtqD,IAAAA,GACAA,GAAA4B,KAAA6Q,IAAAlkB,KAAA87D,WAAArqD,EAAAzR,KAAA+7D,SAAAtqD,IACA4B,KAAA4Q,IAAAjkB,KAAA87D,WAAAnqD,EAAA3R,KAAA+7D,SAAApqD,IAAAA,GACAA,GAAA0B,KAAA6Q,IAAAlkB,KAAA87D,WAAAnqD,EAAA3R,KAAA+7D,SAAApqD,GAAA,CAGA,GAAA3R,KAAA87D,WAAArqD,GAAAzR,KAAA+7D,SAAAtqD,EACA,MAAAA,IAAAzR,KAAA87D,WAAArqD,CAEA,IAAAkzB,IAAA3kC,KAAA+7D,SAAApqD,EAAA3R,KAAA87D,WAAAnqD,IAAA3R,KAAA+7D,SAAAtqD,EAAAzR,KAAA87D,WAAArqD,GACAg0B,EAAAzlC,KAAA87D,WAAAnqD,EAAAgzB,EAAA3kC,KAAA87D,WAAArqD,CACA,OAAAE,IAAAgzB,EAAAlzB,EAAAg0B,EAGA,OAAA,GAYA87B,KAAA,SAAA9vD,EAAAE,EAAAy4C,GAEA,GAAApqD,KAAA+7D,SAAAtqD,IAAAzR,KAAA87D,WAAArqD,EACA,OAAAzR,KAAA87D,WAAAnqD,EAAAy4C,GAAAz4C,GAAA3R,KAAA+7D,SAAApqD,EAAAy4C,GAAAz4C,GACA3R,KAAA+7D,SAAApqD,EAAAy4C,GAAAz4C,GAAA3R,KAAA87D,WAAAnqD,EAAAy4C,GAAAz4C,IACAF,EAAAzR,KAAA87D,WAAArqD,EAAA24C,GAAA34C,EAAAzR,KAAA87D,WAAArqD,EAAA24C,CAGA,IAAApqD,KAAA87D,WAAAnqD,IAAA3R,KAAA+7D,SAAApqD,EACA,OAAA3R,KAAA87D,WAAArqD,EAAA24C,GAAA34C,GAAAzR,KAAA+7D,SAAAtqD,EAAA24C,GAAA34C,GACAzR,KAAA+7D,SAAAtqD,EAAA24C,GAAA34C,GAAAzR,KAAA87D,WAAArqD,EAAA24C,GAAA34C,IACAE,EAAA3R,KAAA87D,WAAAnqD,EAAAy4C,GAAAz4C,EAAA3R,KAAA87D,WAAAnqD,EAAAy4C,CAIA,IAAA5xC,GAAAnF,KAAA4Q,IAAAjkB,KAAA+7D,SAAAtqD,EAAAzR,KAAA87D,WAAArqD,GACA8G,EAAAlF,KAAA4Q,IAAAjkB,KAAA+7D,SAAApqD,EAAA3R,KAAA87D,WAAAnqD,GACAkwD,EAAAxuD,KAAA6Q,IAAAlkB,KAAA+7D,SAAAtqD,EAAAzR,KAAA87D,WAAArqD,GACAqwD,EAAAzuD,KAAA6Q,IAAAlkB,KAAA+7D,SAAApqD,EAAA3R,KAAA87D,WAAAnqD,GAQAgzB,EAAA3kC,KAAA+7D,SAAApqD,EAAA3R,KAAA87D,WAAAnqD,EACA8zB,EAAAzlC,KAAA87D,WAAArqD,EAAAzR,KAAA+7D,SAAAtqD,EACAhR,IAAAT,KAAA87D,WAAArqD,EAAAzR,KAAA+7D,SAAApqD,EAAA3R,KAAA+7D,SAAAtqD,EAAAzR,KAAA87D,WAAAnqD,GAGAs0B,EAAA5yB,KAAAC,KAAAqxB,EAAAlzB,EAAAg0B,EAAA9zB,EAAAlR,GAAA4S,KAAA2D,KAAA3D,KAAA4D,IAAA0tB,EAAA,GAAAtxB,KAAA4D,IAAAwuB,EAAA,KAIAs8B,GAAAt8B,GAAAA,EAAAh0B,EAAAkzB,EAAAhzB,GAAAgzB,EAAAlkC,IAAA4S,KAAA4D,IAAA0tB,EAAA,GAAAtxB,KAAA4D,IAAAwuB,EAAA,IACAu8B,GAAAr9B,IAAAc,EAAAh0B,EAAAkzB,EAAAhzB,GAAA8zB,EAAAhlC,IAAA4S,KAAA4D,IAAA0tB,EAAA,GAAAtxB,KAAA4D,IAAAwuB,EAAA,IAEA7zB,EAAAq0B,GAAAmkB,GAAAyX,GAAAE,GAAAA,GAAAvpD,GAAAspD,GAAAE,GAAAA,GAAAzpD,GACAvY,KAAA87D,WAAAyF,KAAA9vD,EAAAE,EAAAy4C,IAAApqD,KAAA+7D,SAAAwF,KAAA9vD,EAAAE,EAAAy4C,EAEA,OAAAx4C,IAKA4vD,UAAA,WACA,GAAAz+C,KAGA,OAFAA,GAAAvZ,KAAAxJ,KAAA87D,YACA/4C,EAAAvZ,KAAAxJ,KAAA+7D,UACAh5C,GAKAk/C,SAAA,SAAA57B,GACA,GAAA67B,GAAA77B,GAAArmC,KAAA+7D,SAAAtqD,EAAAzR,KAAA87D,WAAArqD,GAAAzR,KAAA87D,WAAArqD,EACA0wD,EAAA97B,GAAArmC,KAAA+7D,SAAApqD,EAAA3R,KAAA87D,WAAAnqD,GAAA3R,KAAA87D,WAAAnqD,CAEA,OAAA,IAAA3N,OAAAk+D,EAAAC,IAyBA94C,SAAA,WACA,MAAA,QAAArpB,KAAA87D,WAAA,IAAA97D,KAAA+7D,SAAA,MAGAl8D,EAAAD,QAAA6V,GpEkvgBM,SAAU5V,EAAQD,EAASM,GqEh6gBjC,YAWA,SAAA0B,GAAAwgE,GACAn+D,EAAA4E,KAAAw5D,EAAA,SAAAh6D,GACArI,KAAAqI,GAAApE,EAAAuD,KAAA46D,EAAA/5D,GAAA+5D,IACSpiE,MAXT,GAAAiE,GAAA/D,EAAA,GAEAmiE,GACA,SAAA,QAAA,WAAA,YAAA,iBACA,KAAA,MAAA,UAAA,aAAA,sBAAA,WAAA,YACA,SAAA,eAAA,4BAAA,gBASAxiE,GAAAD,QAAAgC,GrEw6gBM,SAAU/B,EAAQD,EAASM,GsE14gBjC,QAAAiC,GAAAvB,EAAAC,GACA,GAAAghC,GAAA,GAAAygC,GAAAvhC,IAAAngC,EAAAC,EAEA,OADA6E,GAAAm8B,EAAAxhC,IAAAwhC,EACAA,EAQA,QAAAp8B,GAAAo8B,GACA,GAAAA,EACAA,EAAAp8B,cACG,CACH,IAAA,GAAAO,KAAAN,GACAA,EAAAwkB,eAAAlkB,IACAN,EAAAM,GAAAP,SAIAC,MAGA,MAAA1F,MASA,QAAAuiE,GAAAliE,GACA,MAAAqF,GAAArF,GAGA,QAAAmiE,GAAAn6D,EAAAioB,GACAmyC,EAAAp6D,GAAAioB,EAGA,QAAAoyC,GAAAriE,SACAqF,GAAArF,GAzFA,GAAA0gC,GAAA7gC,EAAA,IAEA0zD,EAAA1zD,EAAA,IAEA+D,EAAA/D,EAAA,GAEAyiE,EAAAziE,EAAA,IAEA0iE,EAAA1iE,EAAA,IAEA2iE,EAAA3iE,EAAA,IAEA4iE,EAAA5iE,EAAA,IAEA6iE,EAAA7iE,EAAA,IAWA8iE,GAAApP,EAAAa,gBACAgO,GACAQ,OAAAJ,GAEAn9D,KAMA+hB,EAAA,QAyEA66C,EAAA,SAAAjiE,EAAAO,EAAAC,GACAA,EAAAA,MAKAb,KAAAY,IAAAA,EAKAZ,KAAAK,GAAAA,CACA,IAAAssC,GAAA3sC,KACAwyD,EAAA,GAAAoQ,GACAM,EAAAriE,EAAAuB,QAEA,IAAA4gE,EAAA,CACA,IAAAP,EAAAU,IACA,KAAA,IAAAx7C,OAAA,uDAGAu7C,GAAA,UACGA,IAAAT,EAAAS,KACHA,EAAA,SAGA,IAAAE,GAAA,GAAAX,GAAAS,GAAAtiE,EAAA4xD,EAAA3xD,EACAb,MAAAwyD,QAAAA,EACAxyD,KAAAojE,QAAAA,CACA,IAAAC,GAAAzP,EAAAxqD,KAAA,KAAA,GAAA25D,GAAAK,EAAAE,kBACAtjE,MAAAyiC,QAAA,GAAAkgC,GAAAnQ,EAAA4Q,EAAAC,EAAAD,EAAA1jE,MAKAM,KAAAkiC,UAAA,GAAA4gC,IACAS,OACA7hC,OAAAz9B,EAAAuD,KAAAxH,KAAAwjE,MAAAxjE,SAGAA,KAAAkiC,UAAAztB,QAMAzU,KAAAyjE,aAGA,IAAAC,GAAAlR,EAAAG,eACAgR,EAAAnR,EAAAC,YAEAD,GAAAG,eAAA,SAAAjpC,GACAg6C,EAAAnjE,KAAAiyD,EAAA9oC,GACAA,GAAAA,EAAAsY,iBAAA2K,IAGA6lB,EAAAC,aAAA,SAAA/oC,GACAi6C,EAAApjE,KAAAiyD,EAAA9oC,GACAA,EAAAoY,YAAA6K,IAIA21B,GAAAp9D,WACAqrB,YAAA+xC,EAMAsB,MAAA,WACA,MAAA5jE,MAAAK,IAOAsG,IAAA,SAAA+iB,GACA1pB,KAAAwyD,QAAAqR,QAAAn6C,GACA1pB,KAAAyjE,eAAA,GAOAh0D,OAAA,SAAAia,GACA1pB,KAAAwyD,QAAAsR,QAAAp6C,GACA1pB,KAAAyjE,eAAA,GAWAM,YAAA,SAAAC,EAAAC,GACAjkE,KAAAojE,QAAAW,YAAAC,EAAAC,GACAjkE,KAAAyjE,eAAA,GAMAS,mBAAA,WAIAlkE,KAAAyjE,eAAA,EACAzjE,KAAAojE,QAAAnnC,UAKAj8B,KAAAyjE,eAAA,GAUAxnC,QAAA,WACAj8B,KAAAyjE,eAAA,GAMAD,MAAA,WACAxjE,KAAAyjE,eACAzjE,KAAAkkE,qBAGAlkE,KAAAmkE,oBACAnkE,KAAAokE,2BASAC,SAAA,SAAA36C,EAAA7e,GACA7K,KAAAojE,QAAAiB,WACArkE,KAAAojE,QAAAiB,SAAA36C,EAAA7e,GACA7K,KAAAskE,iBAQAjtD,YAAA,SAAAqS,GACA1pB,KAAAojE,QAAA/rD,cACArX,KAAAojE,QAAA/rD,YAAAqS,GACA1pB,KAAAskE,iBAQAC,WAAA,WACAvkE,KAAAojE,QAAAmB,aACAvkE,KAAAojE,QAAAmB,aACAvkE,KAAAskE,iBAOAA,aAAA,WACAtkE,KAAAmkE,oBAAA,GAMAC,wBAAA,WACApkE,KAAAmkE,oBAAA,EACAnkE,KAAAojE,QAAAkB,cAAAtkE,KAAAojE,QAAAkB,gBAUA3+D,OAAA,SAAA9E,GACAA,EAAAA,MACAb,KAAAojE,QAAAz9D,OAAA9E,EAAAoO,MAAApO,EAAAqO,QACAlP,KAAAyiC,QAAA98B,UAMA6+D,eAAA,WACAxkE,KAAAkiC,UAAAr4B,SAMAxE,SAAA,WACA,MAAArF,MAAAojE,QAAA/9D,YAMAC,UAAA,WACA,MAAAtF,MAAAojE,QAAA99D,aAsBAm/D,YAAA,SAAAz9D,EAAAy8B,GACA,MAAAzjC,MAAAojE,QAAAqB,YAAAz9D,EAAAy8B,IAOAihC,eAAA,SAAAC,GACA3kE,KAAAyiC,QAAAiiC,eAAAC,IASA9S,UAAA,SAAApgD,EAAAE,GACA,MAAA3R,MAAAyiC,QAAAovB,UAAApgD,EAAAE,IAUA5K,GAAA,SAAA69D,EAAAC,EAAA/mD,GACA9d,KAAAyiC,QAAA17B,GAAA69D,EAAAC,EAAA/mD,IAQA/U,IAAA,SAAA67D,EAAAC,GACA7kE,KAAAyiC,QAAA15B,IAAA67D,EAAAC,IASA78D,QAAA,SAAA48D,EAAA78D,GACA/H,KAAAyiC,QAAAz6B,QAAA48D,EAAA78D,IAMA8B,MAAA,WACA7J,KAAAwyD,QAAAsR,UACA9jE,KAAAojE,QAAAv5D,SAMApE,QAAA,WACAzF,KAAAkiC,UAAArc,OACA7lB,KAAA6J,QACA7J,KAAAwyD,QAAA/sD,UACAzF,KAAAojE,QAAA39D,UACAzF,KAAAyiC,QAAAh9B,UACAzF,KAAAkiC,UAAAliC,KAAAwyD,QAAAxyD,KAAAojE,QAAApjE,KAAAyiC,QAAA,KACAigC,EAAA1iE,KAAAK,MAGAT,EAAA6nB,QAAAA,EACA7nB,EAAAuC,KAAAA,EACAvC,EAAA6F,QAAAA,EACA7F,EAAA2iE,YAAAA,EACA3iE,EAAA4iE,gBAAAA,GtE+7gBM,SAAU3iE,EAAQD,EAASM,GuE91hBjC,QAAA4kE,GAAAC,EAAAC,EAAAj9D,GACA,OACAjC,KAAAi/D,EACAh9D,MAAAA,EAEAb,OAAA89D,EAAA99D,OAEAsqD,UAAAwT,EAAAxT,UACA7iD,cAAA,EACApG,QAAAR,EAAAk9D,IACAz8D,QAAAT,EAAAm9D,IACAC,aAAAp9D,EAAAo9D,aACAC,OAAAr9D,EAAAq9D,OACAC,OAAAt9D,EAAAs9D,OACAC,WAAAv9D,EAAAu9D,WACAx/C,WAAA/d,EAAAw9D,QACAC,UAAAz9D,EAAAy9D,UACAC,MAAA19D,EAAA09D,OAIA,QAAAC,MA6PA,QAAAC,GAAAC,EAAAn0D,EAAAE,GACA,GAAAi0D,EAAAA,EAAAxoC,UAAA,cAAA,WAAA3rB,EAAAE,GAAA,CAIA,IAHA,GACAixB,GADAlZ,EAAAk8C,EAGAl8C,GAAA,CAIA,GAAAA,EAAAyX,WAAAzX,EAAAyX,SAAAxF,QAAAlqB,EAAAE,GACA,OAAA,CAGA+X,GAAAwT,SACA0F,GAAA,GAGAlZ,EAAAA,EAAAvhB,OAGA,OAAAy6B,GAAAijC,EAGA,OAAA,EA1TA,GAAA9hE,GAAA7D,EAAA,GAEA4lD,EAAA5lD,EAAA,IAEA4rB,EAAA5rB,EAAA,IAEA2D,EAAA3D,EAAA,IASA2lE,EAAA,QAyBAH,GAAAxgE,UAAAO,QAAA,YAEA,IAAAqgE,IAAA,QAAA,WAAA,aAAA,WAAA,UAAA,YAAA,YAAA,eAWAnD,EAAA,SAAAnQ,EAAA4Q,EAAA2C,EAAAC,GACAniE,EAAAtD,KAAAP,MACAA,KAAAwyD,QAAAA,EACAxyD,KAAAojE,QAAAA,EACApjE,KAAAgmE,YAAAA,EACAD,EAAAA,GAAA,GAAAL,GAKA1lE,KAAA+lE,MAAAA,EAEAA,EAAAtjC,QAAAziC,KAOAA,KAAAimE,YAMAjmE,KAAAkmE,iBAMAlmE,KAAAmmE,OAMAnmE,KAAAomE,OACAt6C,EAAAvrB,KAAAP,MACA+D,EAAA8E,KAAAi9D,EAAA,SAAAz9D,GACA09D,EAAAh/D,IAAAg/D,EAAAh/D,GAAAsB,EAAArI,KAAAqI,GAAArI,OACGA,MAGH2iE,GAAAz9D,WACAqrB,YAAAoyC,EACA0D,UAAA,SAAAt+D,GACA,GAAA0J,GAAA1J,EAAAk9D,IACAtzD,EAAA5J,EAAAm9D,IACAoB,EAAAtmE,KAAAimE,SACAM,EAAAD,EAAAp/D,MAKAq/D,KAAAA,EAAAvqC,OACAsqC,EAAAtmE,KAAA6xD,UAAAyU,EAAA70D,EAAA60D,EAAA30D,GACA40D,EAAAD,EAAAp/D,OAGA,IAAAs/D,GAAAxmE,KAAAimE,SAAAjmE,KAAA6xD,UAAApgD,EAAAE,GACA80D,EAAAD,EAAAt/D,OACA6+D,EAAA/lE,KAAA+lE,KACAA,GAAAW,WAAAX,EAAAW,UAAAD,EAAAA,EAAAlxD,OAAA,WAEAgxD,GAAAE,IAAAF,GACAvmE,KAAA2xD,kBAAA2U,EAAA,WAAAv+D,GAIA/H,KAAA2xD,kBAAA6U,EAAA,YAAAz+D,GAEA0+D,GAAAA,IAAAF,GACAvmE,KAAA2xD,kBAAA6U,EAAA,YAAAz+D,IAGA4+D,SAAA,SAAA5+D,GACA/H,KAAA2xD,kBAAA3xD,KAAAimE,SAAA,WAAAl+D,EAMA,IACA6+D,GADAC,EAAA9+D,EAAA++D,WAAA/+D,EAAAg/D,aAGA,GACAF,GAAAA,GAAAA,EAAAh4D,iBACKg4D,GAAA,GAAAA,EAAAr0C,YAAAo0C,EAAAC,IAAA7mE,KAAAgmE,eAELY,GAAA5mE,KAAAgI,QAAA,aACAD,MAAAA,KAOApC,OAAA,SAAAoC,GACA/H,KAAAimE,aAQAe,SAAA,SAAApC,EAAAqC,GACA,GAAAxkC,GAAAziC,KAAA4kE,EACAniC,IAAAA,EAAAliC,KAAAP,KAAAinE,IAMAxhE,QAAA,WACAzF,KAAA+lE,MAAAtgE,UACAzF,KAAAwyD,QAAAxyD,KAAA+lE,MAAA/lE,KAAAojE,QAAA,MAOAsB,eAAA,SAAAC,GACA,GAAAoB,GAAA/lE,KAAA+lE,KACAA,GAAAW,WAAAX,EAAAW,UAAA/B,IAWAhT,kBAAA,SAAAqT,EAAAJ,EAAA78D,GACAi9D,EAAAA,KACA,IAAAt7C,GAAAs7C,EAAA99D,MAEA,KAAAwiB,IAAAA,EAAAwT,OAAA,CAOA,IAHA,GAAA2nC,GAAA,KAAAD,EACAsC,EAAApC,EAAAF,EAAAI,EAAAj9D,GAEA2hB,IACAA,EAAAm7C,KAAAqC,EAAAv4D,aAAA+a,EAAAm7C,GAAAtkE,KAAAmpB,EAAAw9C,IACAx9C,EAAA1hB,QAAA48D,EAAAsC,GACAx9C,EAAAA,EAAAvhB,QAEA++D,EAAAv4D,gBAKAu4D,EAAAv4D,eAEA3O,KAAAgI,QAAA48D,EAAAsC,GAGAlnE,KAAAojE,SAAApjE,KAAAojE,QAAA+D,eAAA,SAAAC,GACA,kBAAAA,GAAAvC,IACAuC,EAAAvC,GAAAtkE,KAAA6mE,EAAAF,GAGAE,EAAAp/D,SACAo/D,EAAAp/D,QAAA48D,EAAAsC,QAcArV,UAAA,SAAApgD,EAAAE,EAAAiuD,GAOA,IAAA,GANAzhB,GAAAn+C,KAAAwyD,QAAA6U,iBACArjC,GACAvyB,EAAAA,EACAE,EAAAA,GAGAtE,EAAA8wC,EAAAh4C,OAAA,EAAiCkH,GAAA,EAAQA,IAAA,CACzC,GAAAi6D,EAEA,IAAAnpB,EAAA9wC,KAAAuyD,IACAzhB,EAAA9wC,GAAA6zB,SAAAomC,EAAA3B,EAAAxnB,EAAA9wC,GAAAoE,EAAAE,OACAqyB,EAAAwtB,YAAAxtB,EAAAwtB,UAAArT,EAAA9wC,IAEAi6D,IAAAzB,GAAA,CACA7hC,EAAA98B,OAAAi3C,EAAA9wC,EACA,QAKA,MAAA22B,KAIAjgC,EAAA8E,MAAA,QAAA,YAAA,UAAA,aAAA,WAAA,eAAA,SAAAR,GACAs6D,EAAAz9D,UAAAmD,GAAA,SAAAN,GAEA,GAAAy+D,GAAAxmE,KAAA6xD,UAAA9pD,EAAAk9D,IAAAl9D,EAAAm9D,KACAuB,EAAAD,EAAAt/D,MAEA,IAAA,cAAAmB,EACArI,KAAAunE,QAAAd,EACAzmE,KAAAwnE,YAAAz/D,EAAAk9D,IAAAl9D,EAAAm9D,KAEAllE,KAAAynE,MAAAhB,MACK,IAAA,YAAAp+D,EACLrI,KAAAynE,MAAAhB,MACK,IAAA,UAAAp+D,EAAA,CACL,GAAArI,KAAAunE,UAAAvnE,KAAAynE,QAIAznE,KAAAwnE,YACA1hB,EAAAvf,KAAAvmC,KAAAwnE,YAAAz/D,EAAAk9D,IAAAl9D,EAAAm9D,MAAA,EACA,MAGAllE,MAAAwnE,WAAA,KAGAxnE,KAAA2xD,kBAAA6U,EAAAn+D,EAAAN,MA8BAhE,EAAAqjB,MAAAu7C,EAAA9+D,GACAE,EAAAqjB,MAAAu7C,EAAA72C,EACA,IAAA6Q,GAAAgmC,CACA9iE,GAAAD,QAAA+8B,GvEq3hBM,SAAU98B,EAAQD,EAASM,GwEpqiBjC,QAAAwnE,GAAA/iC,EAAAc,GACA,MAAAd,GAAA3H,SAAAyI,EAAAzI,OACA2H,EAAA5yB,IAAA0zB,EAAA1zB,EAOA4yB,EAAAva,GAAAqb,EAAArb,GAGAua,EAAA5yB,EAAA0zB,EAAA1zB,EAGA4yB,EAAA3H,OAAAyI,EAAAzI,OAhCA,GAAAj5B,GAAA7D,EAAA,GAEA0zD,EAAA1zD,EAAA,IAEAuG,EAAAvG,EAAA,IAEAynE,EAAAznE,EAAA,IAmCA0iE,EAAA,WAEA5iE,KAAA4nE,UACA5nE,KAAA6nE,gBACA7nE,KAAA8nE,gBAAA,EAGAlF,GAAA19D,WACAqrB,YAAAqyC,EAMAp4C,SAAA,SAAA3M,EAAAC,GACA,IAAA,GAAAzQ,GAAA,EAAmBA,EAAArN,KAAA4nE,OAAAzhE,OAAwBkH,IAC3CrN,KAAA4nE,OAAAv6D,GAAAmd,SAAA3M,EAAAC,IAYAupD,eAAA,SAAA3lC,EAAAqmC,GAOA,MANAA,GAAAA,IAAA,EAEArmC,GACA1hC,KAAAgoE,kBAAAD,GAGA/nE,KAAA6nE,cASAG,kBAAA,SAAAD,GACA/nE,KAAA8nE,gBAAA,CAIA,KAAA,GAHA1b,GAAApsD,KAAA4nE,OACAK,EAAAjoE,KAAA6nE,aAEAx6D,EAAA,EAAA+iB,EAAAg8B,EAAAjmD,OAAuCkH,EAAA+iB,EAAS/iB,IAChDrN,KAAAkoE,yBAAA9b,EAAA/+C,GAAA,KAAA06D,EAGAE,GAAA9hE,OAAAnG,KAAA8nE,gBAKAlU,EAAAa,iBAAAkT,EAAAM,EAAAP,IAEAQ,yBAAA,SAAAx+C,EAAAsqC,EAAA+T,GACA,IAAAr+C,EAAAwX,QAAA6mC,EAAA;AAIAr+C,EAAA8X,eAEA9X,EAAAwQ,SACAxQ,EAAAgY,SAGAhY,EAAA+X,aACA,IAAA0mC,GAAAz+C,EAAAyX,QAEA,IAAAgnC,EAAA,CAGAnU,EADAA,EACAA,EAAAprC,UAQA,KAHA,GAAAw/C,GAAAD,EACAE,EAAA3+C,EAEA0+C,GAEAA,EAAAjgE,OAAAkgE,EACAD,EAAAzmC,kBACAqyB,EAAAxqD,KAAA4+D,GACAC,EAAAD,EACAA,EAAAA,EAAAjnC,SAIA,GAAAzX,EAAAwoC,QAAA,CAGA,IAAA,GAFA5oD,GAAAogB,EAAAsoC,UAEA3kD,EAAA,EAAqBA,EAAA/D,EAAAnD,OAAqBkH,IAAA,CAC1C,GAAA9B,GAAAjC,EAAA+D,EAGAqc,GAAAwQ,UACA3uB,EAAA2uB,SAAA,GAGAl6B,KAAAkoE,yBAAA38D,EAAAyoD,EAAA+T,GAIAr+C,EAAAwQ,SAAA,MAEAxQ,GAAAmT,YAAAm3B,EACAh0D,KAAA6nE,aAAA7nE,KAAA8nE,mBAAAp+C,IAQAm6C,QAAA,SAAAn6C,GACAA,EAAAuoC,YAAAjyD,OAIA0pB,YAAAjjB,IACAijB,EAAAgpC,qBAAA1yD,MAGAA,KAAAyyD,aAAA/oC,GAEA1pB,KAAA4nE,OAAAp+D,KAAAkgB,KAOAo6C,QAAA,SAAAp6C,GACA,GAAA,MAAAA,EAAA,CAEA,IAAA,GAAArc,GAAA,EAAqBA,EAAArN,KAAA4nE,OAAAzhE,OAAwBkH,IAAA,CAC7C,GAAA3N,GAAAM,KAAA4nE,OAAAv6D,EAEA3N,aAAA+G,IACA/G,EAAAkzD,uBAAA5yD,MAOA,MAHAA,MAAA4nE,UACA5nE,KAAA6nE,qBACA7nE,KAAA8nE,gBAAA,GAIA,GAAAp+C,YAAAtQ,OACA,IAAA,GAAA/L,GAAA,EAAAy1B,EAAApZ,EAAAvjB,OAAoCkH,EAAAy1B,EAAOz1B,IAC3CrN,KAAA8jE,QAAAp6C,EAAArc,QAFA,CAQA,GAAAy9C,GAAA/mD,EAAA8M,QAAA7Q,KAAA4nE,OAAAl+C,EAEAohC,IAAA,IACA9qD,KAAA2yD,eAAAjpC,GAEA1pB,KAAA4nE,OAAAr6D,OAAAu9C,EAAA,GAEAphC,YAAAjjB,IACAijB,EAAAkpC,uBAAA5yD,SAIAyyD,aAAA,SAAA/oC,GAGA,MAFAA,GAAAuoC,UAAAjyD,KACA0pB,EAAA4O,OAAA,GACAt4B,MAEA2yD,eAAA,SAAAjpC,GAKA,MAJAA,KACAA,EAAAuoC,UAAA,MAGAjyD,MAMAyF,QAAA,WACAzF,KAAAsoE,YAAAtoE,KAAA4nE,OAAA,MAEAW,oBAAAb,EAEA,IAAA/qC,GAAAimC,CACA/iE,GAAAD,QAAA+8B,GxE2riBM,SAAU98B,EAAQD,GyEr6iBxB,QAAA4oE,GAAAxzD,GAGA,IAFA,GAAApD,GAAA,EAEAoD,GAAAyzD,GACA72D,GAAA,EAAAoD,EACAA,IAAA,CAGA,OAAAA,GAAApD,EAGA,QAAA82D,GAAAr3C,EAAAs3C,EAAAC,EAAAC,GACA,GAAAC,GAAAH,EAAA,CAEA,IAAAG,IAAAF,EACA,MAAA,EAGA,IAAAC,EAAAx3C,EAAAy3C,KAAAz3C,EAAAs3C,IAAA,EAAA,CACA,KAAAG,EAAAF,GAAAC,EAAAx3C,EAAAy3C,GAAAz3C,EAAAy3C,EAAA,IAAA,GACAA,GAGAC,GAAA13C,EAAAs3C,EAAAG,OAEA,MAAAA,EAAAF,GAAAC,EAAAx3C,EAAAy3C,GAAAz3C,EAAAy3C,EAAA,KAAA,GACAA,GAIA,OAAAA,GAAAH,EAGA,QAAAI,GAAA13C,EAAAs3C,EAAAC,GAGA,IAFAA,IAEAD,EAAAC,GAAA,CACA,GAAAviC,GAAAhV,EAAAs3C,EACAt3C,GAAAs3C,KAAAt3C,EAAAu3C,GACAv3C,EAAAu3C,KAAAviC,GAIA,QAAA2iC,GAAA33C,EAAAs3C,EAAAC,EAAAn0D,EAAAo0D,GAKA,IAJAp0D,IAAAk0D,GACAl0D,IAGQA,EAAAm0D,EAAYn0D,IAAA,CAMpB,IALA,GAGAw0D,GAHAC,EAAA73C,EAAA5c,GACA7B,EAAA+1D,EACA91D,EAAA4B,EAGA7B,EAAAC,GACAo2D,EAAAr2D,EAAAC,IAAA,EAEAg2D,EAAAK,EAAA73C,EAAA43C,IAAA,EACAp2D,EAAAo2D,EAEAr2D,EAAAq2D,EAAA,CAIA,IAAAj0D,GAAAP,EAAA7B,CAEA,QAAAoC,GACA,IAAA,GACAqc,EAAAze,EAAA,GAAAye,EAAAze,EAAA,EAEA,KAAA,GACAye,EAAAze,EAAA,GAAAye,EAAAze,EAAA,EAEA,KAAA,GACAye,EAAAze,EAAA,GAAAye,EAAAze,EACA,MAEA,SACA,KAAAoC,EAAA,GACAqc,EAAAze,EAAAoC,GAAAqc,EAAAze,EAAAoC,EAAA,GACAA,IAKAqc,EAAAze,GAAAs2D,GAIA,QAAAC,GAAAljE,EAAAorB,EAAA5c,EAAAtO,EAAAijE,EAAAP,GACA,GAAAQ,GAAA,EACAC,EAAA,EACAn2D,EAAA,CAEA,IAAA01D,EAAA5iE,EAAAorB,EAAA5c,EAAA20D,IAAA,EAAA,CAGA,IAFAE,EAAAnjE,EAAAijE,EAEAj2D,EAAAm2D,GAAAT,EAAA5iE,EAAAorB,EAAA5c,EAAA20D,EAAAj2D,IAAA,GACAk2D,EAAAl2D,EACAA,GAAAA,GAAA,GAAA,EAEAA,GAAA,IACAA,EAAAm2D,EAIAn2D,GAAAm2D,IACAn2D,EAAAm2D,GAGAD,GAAAD,EACAj2D,GAAAi2D,MACG,CAGH,IAFAE,EAAAF,EAAA,EAEAj2D,EAAAm2D,GAAAT,EAAA5iE,EAAAorB,EAAA5c,EAAA20D,EAAAj2D,KAAA,GACAk2D,EAAAl2D,EACAA,GAAAA,GAAA,GAAA,EAEAA,GAAA,IACAA,EAAAm2D,EAIAn2D,GAAAm2D,IACAn2D,EAAAm2D,EAGA,IAAAvc,GAAAsc,CACAA,GAAAD,EAAAj2D,EACAA,EAAAi2D,EAAArc,EAKA,IAFAsc,IAEAA,EAAAl2D,GAAA,CACA,GAAA3S,GAAA6oE,GAAAl2D,EAAAk2D,IAAA,EAEAR,GAAA5iE,EAAAorB,EAAA5c,EAAAjU,IAAA,EACA6oE,EAAA7oE,EAAA,EAEA2S,EAAA3S,EAIA,MAAA2S,GAGA,QAAAo2D,GAAAtjE,EAAAorB,EAAA5c,EAAAtO,EAAAijE,EAAAP,GACA,GAAAQ,GAAA,EACAC,EAAA,EACAn2D,EAAA,CAEA,IAAA01D,EAAA5iE,EAAAorB,EAAA5c,EAAA20D,IAAA,EAAA,CAGA,IAFAE,EAAAF,EAAA,EAEAj2D,EAAAm2D,GAAAT,EAAA5iE,EAAAorB,EAAA5c,EAAA20D,EAAAj2D,IAAA,GACAk2D,EAAAl2D,EACAA,GAAAA,GAAA,GAAA,EAEAA,GAAA,IACAA,EAAAm2D,EAIAn2D,GAAAm2D,IACAn2D,EAAAm2D,EAGA,IAAAvc,GAAAsc,CACAA,GAAAD,EAAAj2D,EACAA,EAAAi2D,EAAArc,MACG,CAGH,IAFAuc,EAAAnjE,EAAAijE,EAEAj2D,EAAAm2D,GAAAT,EAAA5iE,EAAAorB,EAAA5c,EAAA20D,EAAAj2D,KAAA,GACAk2D,EAAAl2D,EACAA,GAAAA,GAAA,GAAA,EAEAA,GAAA,IACAA,EAAAm2D,EAIAn2D,GAAAm2D,IACAn2D,EAAAm2D,GAGAD,GAAAD,EACAj2D,GAAAi2D,EAKA,IAFAC,IAEAA,EAAAl2D,GAAA,CACA,GAAA3S,GAAA6oE,GAAAl2D,EAAAk2D,IAAA,EAEAR,GAAA5iE,EAAAorB,EAAA5c,EAAAjU,IAAA,EACA2S,EAAA3S,EAEA6oE,EAAA7oE,EAAA,EAIA,MAAA2S,GAGA,QAAAq2D,GAAAn4C,EAAAw3C,GAmBA,QAAAY,GAAAC,EAAAC,GACAC,EAAAC,GAAAH,EACAI,EAAAD,GAAAF,EACAE,GAAA,EAGA,QAAAE,KACA,KAAAF,EAAA,GAAA,CACA,GAAA70D,GAAA60D,EAAA,CAEA,IAAA70D,GAAA,GAAA80D,EAAA90D,EAAA,IAAA80D,EAAA90D,GAAA80D,EAAA90D,EAAA,IAAAA,GAAA,GAAA80D,EAAA90D,EAAA,IAAA80D,EAAA90D,GAAA80D,EAAA90D,EAAA,GACA80D,EAAA90D,EAAA,GAAA80D,EAAA90D,EAAA,IACAA,QAEO,IAAA80D,EAAA90D,GAAA80D,EAAA90D,EAAA,GACP,KAGAg1D,GAAAh1D,IAIA,QAAAi1D,KACA,KAAAJ,EAAA,GAAA,CACA,GAAA70D,GAAA60D,EAAA,CAEA70D,GAAA,GAAA80D,EAAA90D,EAAA,GAAA80D,EAAA90D,EAAA,IACAA,IAGAg1D,EAAAh1D,IAIA,QAAAg1D,GAAA38D,GACA,GAAA68D,GAAAN,EAAAv8D,GACA88D,EAAAL,EAAAz8D,GACA+8D,EAAAR,EAAAv8D,EAAA,GACAg9D,EAAAP,EAAAz8D,EAAA,EACAy8D,GAAAz8D,GAAA88D,EAAAE,EAEAh9D,IAAAw8D,EAAA,IACAD,EAAAv8D,EAAA,GAAAu8D,EAAAv8D,EAAA,GACAy8D,EAAAz8D,EAAA,GAAAy8D,EAAAz8D,EAAA,IAGAw8D,GACA,IAAAz7B,GAAAm7B,EAAAl4C,EAAA+4C,GAAA/4C,EAAA64C,EAAAC,EAAA,EAAAtB,EACAqB,IAAA97B,EACA+7B,GAAA/7B,EAEA,IAAA+7B,IAIAE,EAAAlB,EAAA93C,EAAA64C,EAAAC,EAAA,GAAA94C,EAAA+4C,EAAAC,EAAAA,EAAA,EAAAxB,GAEA,IAAAwB,IAIAF,GAAAE,EACAC,EAAAJ,EAAAC,EAAAC,EAAAC,GAEAE,EAAAL,EAAAC,EAAAC,EAAAC,KAIA,QAAAC,GAAAJ,EAAAC,EAAAC,EAAAC,GACA,GAAAh9D,GAAA,CAEA,KAAAA,EAAA,EAAeA,EAAA88D,EAAa98D,IAC5B0/C,EAAA1/C,GAAAgkB,EAAA64C,EAAA78D,EAGA,IAAAm9D,GAAA,EACAC,EAAAL,EACAM,EAAAR,CAGA,IAFA74C,EAAAq5C,KAAAr5C,EAAAo5C,KAEA,MAAAJ,EAAA,CAQA,GAAA,IAAAF,EAAA,CACA,IAAA98D,EAAA,EAAiBA,EAAAg9D,EAAah9D,IAC9BgkB,EAAAq5C,EAAAr9D,GAAAgkB,EAAAo5C,EAAAp9D,EAIA,aADAgkB,EAAAq5C,EAAAL,GAAAtd,EAAAyd,IAOA,IAHA,GACAG,GAAAC,EAAAC,EADAC,EAAAC,IAGA,CACAJ,EAAA,EACAC,EAAA,EACAC,GAAA,CAEA,GACA,IAAAhC,EAAAx3C,EAAAo5C,GAAA1d,EAAAyd,IAAA,GAKA,GAJAn5C,EAAAq5C,KAAAr5C,EAAAo5C,KACAG,IACAD,EAAA,EAEA,MAAAN,EAAA,CACAQ,GAAA,CACA,YAOA,IAJAx5C,EAAAq5C,KAAA3d,EAAAyd,KACAG,IACAC,EAAA,EAEA,MAAAT,EAAA,CACAU,GAAA,CACA,cAGOF,EAAAC,GAAAE,EAEP,IAAAD,EACA,KAGA,GAAA,CAGA,GAFAF,EAAApB,EAAAl4C,EAAAo5C,GAAA1d,EAAAyd,EAAAL,EAAA,EAAAtB,GAEA,IAAA8B,EAAA,CACA,IAAAt9D,EAAA,EAAqBA,EAAAs9D,EAAYt9D,IACjCgkB,EAAAq5C,EAAAr9D,GAAA0/C,EAAAyd,EAAAn9D,EAOA,IAJAq9D,GAAAC,EACAH,GAAAG,EACAR,GAAAQ,EAEAR,GAAA,EAAA,CACAU,GAAA,CACA,QAMA,GAFAx5C,EAAAq5C,KAAAr5C,EAAAo5C,KAEA,MAAAJ,EAAA,CACAQ,GAAA,CACA,OAKA,GAFAD,EAAAzB,EAAApc,EAAAyd,GAAAn5C,EAAAo5C,EAAAJ,EAAA,EAAAxB,GAEA,IAAA+B,EAAA,CACA,IAAAv9D,EAAA,EAAqBA,EAAAu9D,EAAYv9D,IACjCgkB,EAAAq5C,EAAAr9D,GAAAgkB,EAAAo5C,EAAAp9D,EAOA,IAJAq9D,GAAAE,EACAH,GAAAG,EACAP,GAAAO,EAEA,IAAAP,EAAA,CACAQ,GAAA,CACA,QAMA,GAFAx5C,EAAAq5C,KAAA3d,EAAAyd,KAEA,MAAAL,EAAA,CACAU,GAAA,CACA,OAGAC,UACOH,GAAAK,GAAAJ,GAAAI,EAEP,IAAAH,EACA,KAGAC,GAAA,IACAA,EAAA,GAGAA,GAAA,EAMA,GAHAC,EAAAD,EACAC,EAAA,IAAAA,EAAA,GAEA,IAAAZ,EAAA,CACA,IAAA98D,EAAA,EAAiBA,EAAAg9D,EAAah9D,IAC9BgkB,EAAAq5C,EAAAr9D,GAAAgkB,EAAAo5C,EAAAp9D,EAGAgkB,GAAAq5C,EAAAL,GAAAtd,EAAAyd,OACK,CAAA,GAAA,IAAAL,EACL,KAAA,IAAAxiD,MAEA,KAAAta,EAAA,EAAiBA,EAAA88D,EAAa98D,IAC9BgkB,EAAAq5C,EAAAr9D,GAAA0/C,EAAAyd,EAAAn9D,QA9HA,KAAAA,EAAA,EAAiBA,EAAA88D,EAAa98D,IAC9BgkB,EAAAq5C,EAAAr9D,GAAA0/C,EAAAyd,EAAAn9D,GAkIA,QAAAk9D,GAAAL,EAAAC,EAAAC,EAAAC,GACA,GAAAh9D,GAAA,CAEA,KAAAA,EAAA,EAAeA,EAAAg9D,EAAah9D,IAC5B0/C,EAAA1/C,GAAAgkB,EAAA+4C,EAAA/8D,EAGA,IAAAm9D,GAAAN,EAAAC,EAAA,EACAM,EAAAJ,EAAA,EACAK,EAAAN,EAAAC,EAAA,EACAY,EAAA,EACAC,EAAA,CAGA,IAFA75C,EAAAq5C,KAAAr5C,EAAAm5C,KAEA,MAAAL,EAAA,CAUA,GAAA,IAAAE,EAAA,CAMA,IALAK,GAAAP,EACAK,GAAAL,EACAe,EAAAR,EAAA,EACAO,EAAAT,EAAA,EAEAn9D,EAAA88D,EAAA,EAA2B98D,GAAA,EAAQA,IACnCgkB,EAAA65C,EAAA79D,GAAAgkB,EAAA45C,EAAA59D,EAIA,aADAgkB,EAAAq5C,GAAA3d,EAAA0d,IAMA,IAFA,GAAAK,GAAAC,IAEA,CACA,GAAAJ,GAAA,EACAC,EAAA,EACAC,GAAA,CAEA,GACA,IAAAhC,EAAA9b,EAAA0d,GAAAp5C,EAAAm5C,IAAA,GAKA,GAJAn5C,EAAAq5C,KAAAr5C,EAAAm5C,KACAG,IACAC,EAAA,EAEA,MAAAT,EAAA,CACAU,GAAA,CACA,YAOA,IAJAx5C,EAAAq5C,KAAA3d,EAAA0d,KACAG,IACAD,EAAA,EAEA,MAAAN,EAAA,CACAQ,GAAA,CACA,cAGOF,EAAAC,GAAAE,EAEP,IAAAD,EACA,KAGA,GAAA,CAGA,GAFAF,EAAAR,EAAAZ,EAAAxc,EAAA0d,GAAAp5C,EAAA64C,EAAAC,EAAAA,EAAA,EAAAtB,GAEA,IAAA8B,EAAA,CAOA,IANAD,GAAAC,EACAH,GAAAG,EACAR,GAAAQ,EACAO,EAAAR,EAAA,EACAO,EAAAT,EAAA,EAEAn9D,EAAAs9D,EAAA,EAA8Bt9D,GAAA,EAAQA,IACtCgkB,EAAA65C,EAAA79D,GAAAgkB,EAAA45C,EAAA59D,EAGA,IAAA,IAAA88D,EAAA,CACAU,GAAA,CACA,QAMA,GAFAx5C,EAAAq5C,KAAA3d,EAAA0d,KAEA,MAAAJ,EAAA,CACAQ,GAAA,CACA,OAKA,GAFAD,EAAAP,EAAAlB,EAAA93C,EAAAm5C,GAAAzd,EAAA,EAAAsd,EAAAA,EAAA,EAAAxB,GAEA,IAAA+B,EAAA,CAOA,IANAF,GAAAE,EACAH,GAAAG,EACAP,GAAAO,EACAM,EAAAR,EAAA,EACAO,EAAAR,EAAA,EAEAp9D,EAAA,EAAqBA,EAAAu9D,EAAYv9D,IACjCgkB,EAAA65C,EAAA79D,GAAA0/C,EAAAke,EAAA59D,EAGA,IAAAg9D,GAAA,EAAA,CACAQ,GAAA,CACA,QAMA,GAFAx5C,EAAAq5C,KAAAr5C,EAAAm5C,KAEA,MAAAL,EAAA,CACAU,GAAA,CACA,OAGAC,UACOH,GAAAK,GAAAJ,GAAAI,EAEP,IAAAH,EACA,KAGAC,GAAA,IACAA,EAAA,GAGAA,GAAA,EASA,GANAC,EAAAD,EAEAC,EAAA,IACAA,EAAA,GAGA,IAAAV,EAAA,CAMA,IALAK,GAAAP,EACAK,GAAAL,EACAe,EAAAR,EAAA,EACAO,EAAAT,EAAA,EAEAn9D,EAAA88D,EAAA,EAA2B98D,GAAA,EAAQA,IACnCgkB,EAAA65C,EAAA79D,GAAAgkB,EAAA45C,EAAA59D,EAGAgkB,GAAAq5C,GAAA3d,EAAA0d,OACK,CAAA,GAAA,IAAAJ,EACL,KAAA,IAAA1iD,MAIA,KAFAsjD,EAAAP,GAAAL,EAAA,GAEAh9D,EAAA,EAAiBA,EAAAg9D,EAAah9D,IAC9BgkB,EAAA45C,EAAA59D,GAAA0/C,EAAA1/C,QAhJA,KAFA49D,EAAAP,GAAAL,EAAA,GAEAh9D,EAAA,EAAiBA,EAAAg9D,EAAah9D,IAC9BgkB,EAAA45C,EAAA59D,GAAA0/C,EAAA1/C,GAxPA,GAIAu8D,GACAE,EALAiB,EAAAC,EACA7kE,EAAA,EACAglE,EAAAC,EACAC,EAAA,EAGAxB,EAAA,CACA1jE,GAAAkrB,EAAAlrB,OAEAA,EAAA,EAAAilE,IACAD,EAAAhlE,IAAA,EAGA,IAAA4mD,KACAse,GAAAllE,EAAA,IAAA,EAAAA,EAAA,KAAA,GAAAA,EAAA,OAAA,GAAA,GACAyjE,KACAE,KA4XA9pE,KAAA+pE,UAAAA,EACA/pE,KAAAiqE,eAAAA,EACAjqE,KAAAypE,QAAAA,EAGA,QAAA9+B,GAAAtZ,EAAAw3C,EAAAF,EAAAC,GACAD,IACAA,EAAA,GAGAC,IACAA,EAAAv3C,EAAAlrB,OAGA,IAAAmlE,GAAA1C,EAAAD,CAEA,MAAA2C,EAAA,GAAA,CAIA,GAAAxB,GAAA,CAEA,IAAAwB,EAAA7C,EAGA,MAFAqB,GAAApB,EAAAr3C,EAAAs3C,EAAAC,EAAAC,OACAG,GAAA33C,EAAAs3C,EAAAC,EAAAD,EAAAmB,EAAAjB,EAIA,IAAA3tD,GAAA,GAAAsuD,GAAAn4C,EAAAw3C,GACA0C,EAAA/C,EAAA8C,EAEA,GAAA,CAGA,GAFAxB,EAAApB,EAAAr3C,EAAAs3C,EAAAC,EAAAC,GAEAiB,EAAAyB,EAAA,CACA,GAAAC,GAAAF,CAEAE,GAAAD,IACAC,EAAAD,GAGAvC,EAAA33C,EAAAs3C,EAAAA,EAAA6C,EAAA7C,EAAAmB,EAAAjB,GACAiB,EAAA0B,EAGAtwD,EAAAuuD,QAAAd,EAAAmB,GACA5uD,EAAA6uD,YACAuB,GAAAxB,EACAnB,GAAAmB,QACG,IAAAwB,EAEHpwD,GAAA+uD,kBAnpBA,GAAAxB,GAAA,GACAuC,EAAA,EACAI,EAAA,GAopBAvrE,GAAAD,QAAA+qC,GzEg7iBM,SAAU9qC,EAAQD,EAASM,G0ExikBjC,QAAAurE,GAAA3pD,GACA,MAAA3I,UAAA2I,EAAA,IAGA,QAAA4pD,GAAAtE,GACA,QAAAA,MAIAA,EAAAuE,aAIA,kBAAAvE,GAAAzhE,QAAA,kBAAAyhE,GAAAnrC,SAOA,QAAA2vC,GAAAxE,GACAA,EAAAyE,gBAGA,QAAAC,GAAA1E,GACA,GAAAA,EAAAyE,eACAzE,EAAAv9D,QAOA,QAAAkiE,GAAAriD,EAAAza,EAAAC,GASA,MARAwvC,GAAApjB,KAAA5R,EAAAva,mBAEAua,EAAA8F,WACAkvB,EAAArxB,eAAA3D,EAAA8F,WAGAw8C,EAAA/8D,MAAAA,EACA+8D,EAAA98D,OAAAA,GACAwvC,EAAA8H,UAAAwlB,GAGA,QAAAC,GAAAjY,EAAAkY,GACA,GAAAlY,GAAAkY,EAEA,OAAA,CAGA,KAAAlY,IAAAkY,GAAAlY,EAAA7tD,SAAA+lE,EAAA/lE,OACA,OAAA,CAGA,KAAA,GAAAkH,GAAA,EAAiBA,EAAA2mD,EAAA7tD,OAAsBkH,IACvC,GAAA2mD,EAAA3mD,KAAA6+D,EAAA7+D,GACA,OAAA,EAKA,QAAA8+D,GAAAnY,EAAA77B,GACA,IAAA,GAAA9qB,GAAA,EAAiBA,EAAA2mD,EAAA7tD,OAAsBkH,IAAA,CACvC,GAAA8zB,GAAA6yB,EAAA3mD,EACA8zB,GAAAlH,aAAA9B,GACAA,EAAAyC,YACAuG,EAAAlJ,UAAAE,EAAAgJ,EAAAl6B,OACAkxB,EAAAqT,OAEArK,EAAArG,iBAAA3C,IAIA,QAAAi0C,GAAAn9D,EAAAC,GACA,GAAAm9D,GAAA/tD,SAAAC,cAAA,MAGA,OADA8tD,GAAAxhE,MAAAyhE,SAAA,oBAAA,kBAAA,SAAAr9D,EAAA,KAAA,UAAAC,EAAA,KAAA,YAAA,WAAA,kBAAAu6B,KAAA,KAAyK,IACzK4iC,EA7GA,GAAA/tB,GAAAp+C,EAAA,IAEAmC,EAAAi8C,EAAAj8C,iBAEA0B,EAAA7D,EAAA,GAEAwmC,EAAAxmC,EAAA,IAEAssB,EAAAtsB,EAAA,IAEAynE,EAAAznE,EAAA,IAEAqsE,EAAArsE,EAAA,IAEAssE,EAAAtsE,EAAA,IAEA0K,EAAA1K,EAAA,IAaAusE,EAAA,EAgCA/tB,EAAA,GAAAlyB,GAAA,EAAA,EAAA,EAAA,GACAw/C,EAAA,GAAAx/C,GAAA,EAAA,EAAA,EAAA,GA0DAq2C,EAAA,SAAAnjE,EAAA8yD,EAAA3xD,GACAb,KAAA8F,KAAA,QAEA,IAAA4mE,IAAAhtE,EAAAitE,UACA,WAAAjtE,EAAAitE,SAAAC,aACA5sE,MAAA6sE,MAAAhsE,EAAAkD,EAAA+gB,UAAoCjkB,OAKpCb,KAAAyjC,IAAA5iC,EAAAwB,kBAAAA,EAMArC,KAAA8sE,cAAAJ,EAMA1sE,KAAAN,KAAAA,CACA,IAAAqtE,GAAArtE,EAAAmL,KAEAkiE,KACAA,EAAA,+BAAA,cACAA,EAAA,uBAAAA,EAAA,eAAAA,EAAA,yBAAA,OACArtE,EAAAwgB,UAAA,IAOAlgB,KAAAwyD,QAAAA,CAMA,IAAAwa,GAAAhtE,KAAAitE,eAMAC,EAAAltE,KAAAmtE,UAQA,IAFAntE,KAAAotE,gBAEAV,EAKG,CACH,MAAA7rE,EAAAoO,QACAvP,EAAAuP,MAAApO,EAAAoO,OAGA,MAAApO,EAAAqO,SACAxP,EAAAwP,OAAArO,EAAAqO,OAIA,IAAAD,GAAAvP,EAAAuP,MACAC,EAAAxP,EAAAwP,MACAlP,MAAAqtE,OAAAp+D,EACAjP,KAAAstE,QAAAp+D,CAGA,IAAAq+D,GAAA,GAAAhB,GAAA7sE,EAAAM,KAAA,EACAutE,GAAAC,cAGAN,EAAA,GAAAK,EACAP,EAAAxjE,KAAA,GACAxJ,KAAAytE,SAAA/tE,MA3BA,CACAM,KAAAqtE,OAAArtE,KAAA0tE,SAAA,GACA1tE,KAAAstE,QAAAttE,KAAA0tE,SAAA,EACA,IAAArB,GAAArsE,KAAAytE,SAAArB,EAAApsE,KAAAqtE,OAAArtE,KAAAstE,QACA5tE,GAAAygB,YAAAksD,GA2BArsE,KAAA2tE,sBAMA3tE,KAAA4tE,YACA5tE,KAAA6tE,kBAGAhL,GAAA39D,WACAqrB,YAAAsyC,EACAiL,QAAA,WACA,MAAA,UAOAC,eAAA,WACA,MAAA/tE,MAAA8sE,eAMAxJ,gBAAA,WACA,MAAAtjE,MAAAytE,UAEAO,sBAAA,WACA,GAAAC,GAAAjuE,KAAAsjE,iBAEA,IAAA2K,EACA,OACAC,WAAAD,EAAAC,YAAA,EACAC,UAAAF,EAAAE,WAAA,IASAlyC,QAAA,SAAAmyC,GACA,GAAAjwB,GAAAn+C,KAAAwyD,QAAA6U,gBAAA,GACA2F,EAAAhtE,KAAAitE,WAEAjtE,MAAAquE,WAAAlwB,EAAAiwB,EAGA,KAAA,GAAA/gE,GAAA,EAAmBA,EAAA2/D,EAAA7mE,OAAuBkH,IAAA,CAC1C,GAAA0E,GAAAi7D,EAAA3/D,GACA+5D,EAAApnE,KAAAmtE,QAAAp7D,IAEAq1D,EAAAuE,aAAAvE,EAAAnrC,SACAmrC,EAAAnrC,UAUA,MANAj8B,MAAAskE,eAEAtkE,KAAA2tE,mBAAAxnE,QACAnG,KAAAsuE,mBAGAtuE,MAEAqkE,SAAA,SAAA36C,EAAAhe,GACA,IAAAge,EAAA6kD,WAAA,CAIA,GAAAC,GAAA,GAAA9kD,GAAA6G,aACA1lB,MAAA6e,EAAA7e,MACA5D,MAAAyiB,EAAAziB,OAEAunE,GAAAC,OAAA/kD,EACAA,EAAA6kD,WAAAC,EACAA,EAAA/gE,SAAA/B,GAEA1L,KAAA6tE,eAAArkE,KAAAglE,KAEAn3D,YAAA,SAAAqS,GACA,GAAA8kD,GAAA9kD,EAAA6kD,WACAG,EAAA1uE,KAAA6tE,eACA/iB,EAAA/mD,EAAA8M,QAAA69D,EAAAF,EAEA1jB,IAAA,GACA4jB,EAAAnhE,OAAAu9C,EAAA,GAGAphC,EAAA6kD,WAAA,MAEAhK,WAAA,SAAA76C,GAGA,IAAA,GAFAglD,GAAA1uE,KAAA6tE,eAEAxgE,EAAA,EAAmBA,EAAAqhE,EAAAvoE,OAA0BkH,IAAA,CAC7C,GAAAmjB,GAAAk+C,EAAArhE,GAAAohE,MAEAj+C,KACAA,EAAA+9C,WAAA,MAIAG,EAAAvoE,OAAA,GAEAm+D,aAAA,WACA,GAAAoK,GAAA1uE,KAAA6tE,eACAz9C,EAAAs+C,EAAAvoE,OACAwoE,EAAA3uE,KAAA4tE,WAGA,IAFAe,GAAAA,EAAA9kE,QAEAumB,EAAA,CAIAu3C,EAAA+G,EAAA1uE,KAAAwyD,QAAA+V,qBAGAoG,IACAA,EAAA3uE,KAAA4tE,YAAA5tE,KAAA4uE,SAAA,KAGA,IAAAC,KACAF,GAAAx2C,IAAA0mB,MAEA,KAAA,GAAAxxC,GAAA,EAAmBA,EAAA+iB,GAAS,CAC5B,GAAA1G,GAAAglD,EAAArhE,GACAyhE,EAAAplD,EAAA+kD,MAGAK,IAAAA,EAAA9yC,MAOA3uB,IAGAyhE,EAAA/xC,YACArT,EAAA8F,UAAAs/C,EAAAt/C,UACA9F,EAAA8Z,aAAAsrC,EAAAtrC,aACA9Z,EAAAmT,YAAAiyC,EAAAjyC,YAEA78B,KAAA+uE,WAAArlD,EAAAilD,GAAA,EAAAE,MAdAH,EAAAnhE,OAAAF,EAAA,GACAyhE,EAAAP,WAAA,KACAn+C,KAgBAu+C,EAAAx2C,IAAA4mB,YAEAuvB,iBAAA,WAaA,QAAAhtE,KAEAkgD,IAAA7U,EAAAqiC,mBAAAriC,EAAA6lB,UACA7lB,EAAAsiC,aAAAtiC,EAAA6lB,QAAA6U,kBAEA16B,EAAAuiC,qBACAviC,EAAAwiC,YACA3C,EAAAlrE,IAEAqrC,EAAAqiC,sBArBA,GAAAriC,GAAA3sC,IAEA,IAAA2sC,EAAAuiC,oBAAA,CAMA,GAAA1tB,GAAA7U,EAAAqiC,mBAAA,GAAA1nD,KACAqlB,GAAAwiC,YACA3C,EAAAlrE,KAgBA8tE,kBAAA,WACApvE,KAAAgvE,qBACAhvE,KAAAmvE,UAAA,EACAprE,EAAA8E,KAAA7I,KAAA2tE,mBAAA,SAAAvG,GACAA,EAAAltC,SAAAktC,EAAAv9D,WAGAwkE,WAAA,SAAAlwB,EAAAiwB,GACA,MAAAA,IACAA,GAAA,GAGApuE,KAAAqvE,mBAAAlxB,GAEAn+C,KAAAovE,oBAEApvE,KAAAsvE,iBAAA1D,GAEA5rE,KAAAivE,aAAA9wB,EAAAiwB,GAEApuE,KAAAsvE,iBAAAxD,IAEAmD,aAAA,SAAA9wB,EAAAiwB,GAaA,QAAAmB,GAAAnI,GACA,GAAA3jC,GAAAtL,EAAAsL,KAAA,CACAtL,GAAA0mB,OACA1mB,EAAAqI,YAAA,EACArI,EAAA+F,WAAA,EAEAsxC,EAAAt1C,SAAA,EACA/B,EAAA8B,aAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA9B,EAAAqqB,UAAA4kB,EAAAxmE,IAAA,EAAA,EAAAqO,EAAAw0B,EAAAv0B,EAAAu0B,GACAtL,EAAA4mB,UAGA,IAAA,GAxBAywB,GACAC,EACAt3C,EAEA02C,EAEAa,EAGAC,EAJAC,EAAA,EAEA3gE,EAAAjP,KAAAqtE,OACAn+D,EAAAlP,KAAAstE,QAEAhiC,EAAAtrC,KAAAmvE,UAcA9hE,EAAA,EAAAy1B,EAAAqb,EAAAh4C,OAAoCkH,EAAAy1B,EAAOz1B,IAAA,CAC3C,GAAAqc,GAAAy0B,EAAA9wC,GACAwiE,EAAA7vE,KAAA8sE,cAAA,EAAApjD,EAAAsT,OACA8yC,EAAApmD,EAAAqmD,OAkCA,IA/BAD,EAAA,GAAAJ,IACAH,EAAAG,GACAA,EAAA,MAIAD,IAAAI,IACA13C,GACAA,EAAA4mB,UAIA8vB,KAEAY,EAAAI,EACAL,EAAAxvE,KAAA4uE,SAAAa,GAEAD,EAAA7D,aACAjlC,EAAA,UAAA+oC,EAAA,kCAAAD,EAAAnvE,IAGA83B,EAAAq3C,EAAAr3C,IACAA,EAAA0mB,OAEA2wB,EAAA3D,cAAA,GAEA2D,EAAAt1C,SAAAk0C,IACAoB,EAAA3lE,SAIA2lE,EAAAt1C,SAAAk0C,EAAA,CAIA,GAAA0B,GAAA,EAAA,CAEA,IAAAJ,EAAA,CAKA,GAJAA,EAAA1vE,KAAA2tE,mBAAAt6D,KAAA4Q,IAAA2rD,IAAAnD,EAAA,IACAiD,EAAAv3C,IAAA0mB,OACA6wB,EAAAM,eAEAN,GAAAA,EAAAO,WAAAP,EAAAQ,cAAA,CAIA7iE,EAAAqiE,EAAAS,iBAAA,CAEA,UAGAR,EAAAD,EAAAO,WAEAP,EAAAx1C,UAEAoR,EAAAqkC,GAGAD,EAAAO,WAAA3kC,EAAA,EAGAwkC,IAAAxkC,GACAtrC,KAAA+uE,WAAArlD,EAAAgmD,GAAA,EAAAA,EAAAM,iBAGAhwE,MAAA+uE,WAAArlD,EAAA8lD,EAAApB,EAAAS,EAGAnlD,GAAAwQ,SAAA,GAGAw1C,GACAH,EAAAG,GAIAv3C,GAAAA,EAAA4mB,UAKA/+C,KAAAkvE,qBAAA,EACAnrE,EAAA8E,KAAA7I,KAAA2tE,mBAAA,SAAAvG,GACAA,EAAA8I,eAAA9I,EAAA6I,aACAjwE,KAAAkvE,qBAAA,IAEKlvE,OAEL+uE,WAAA,SAAArlD,EAAA8lD,EAAAY,EAAAvB,GACA,GAAA12C,GAAAq3C,EAAAr3C,IACA33B,EAAAkpB,EAAA8F,SAEA,KAAAggD,EAAAt1C,SAAAk2C,KACA1mD,EAAAqT,WACA,IAAArT,EAAA7e,MAAAmU,WAGAxe,GAAAA,EAAA,IAAAA,EAAA,OACAkpB,EAAAyT,UAAA4uC,EAAAriD,EAAA1pB,KAAAqtE,OAAArtE,KAAAstE,UAAA,CACA,GAAAtZ,GAAAtqC,EAAAmT,aAEAgyC,EAAAwB,gBAAAb,GAAAvD,EAAAjY,EAAA6a,EAAAyB,oBAEAzB,EAAAyB,kBACAzB,EAAAwB,cAAAl4C,IAAA4mB,UACA8vB,EAAAwB,cAAAxB,EAAAyB,gBAAA,KAEAzB,EAAAp1C,OAAA,MAIAu6B,IACA77B,EAAA0mB,OACAstB,EAAAnY,EAAA77B,GACA02C,EAAAwB,cAAAb,EACAX,EAAAyB,gBAAAtc,IAIAtqC,EAAA4T,aAAA5T,EAAA4T,YAAAnF,GACAzO,EAAA8P,MAAArB,EAAA02C,EAAAp1C,QAAA,MACAo1C,EAAAp1C,OAAA/P,EACAA,EAAA6T,YAAA7T,EAAA6T,WAAApF,KASAy2C,SAAA,SAAA5xC,GACA,GAAAh9B,KAAA8sE,cACA,MAAA9sE,MAAAmtE,QAAA,EAGA,IAAA/F,GAAApnE,KAAAmtE,QAAAnwC,EAiBA,OAfAoqC,KAEAA,EAAA,GAAAmF,GAAA,MAAAvvC,EAAAh9B,KAAAA,KAAAyjC,KACA2jC,EAAAuE,aAAA,EAEA3rE,KAAAotE,aAAApwC,IACAj5B,EAAAgN,MAAAq2D,EAAApnE,KAAAotE,aAAApwC,IAAA,GAGAh9B,KAAAuwE,YAAAvzC,EAAAoqC,GAGAA,EAAAoG,eAGApG,GAEAmJ,YAAA,SAAAvzC,EAAAoqC,GACA,GAAAoJ,GAAAxwE,KAAAmtE,QACAH,EAAAhtE,KAAAitE,YACA78C,EAAA48C,EAAA7mE,OACAsqE,EAAA,KACApjE,KACAg/D,EAAArsE,KAAAytE,QAEA,IAAA+C,EAAAxzC,GAEA,WADA0J,GAAA,UAAA1J,EAAA,yBAKA,KAAA0uC,EAAAtE,GAEA,WADA1gC,GAAA,mBAAA1J,EAAA,gBAIA,IAAA5M,EAAA,GAAA4M,EAAAgwC,EAAA,GAAA,CACA,IAAA3/D,EAAA,EAAiBA,EAAA+iB,EAAA,KACjB48C,EAAA3/D,GAAA2vB,GAAAgwC,EAAA3/D,EAAA,GAAA2vB,GAD8B3vB,KAM9BojE,EAAAD,EAAAxD,EAAA3/D,IAQA,GALA2/D,EAAAz/D,OAAAF,EAAA,EAAA,EAAA2vB,GACAwzC,EAAAxzC,GAAAoqC,GAIAA,EAAAsJ,QACA,GAAAD,EAAA,CACA,GAAAE,GAAAF,EAAA7vE,GAEA+vE,GAAApe,YACA8Z,EAAAuE,aAAAxJ,EAAAxmE,IAAA+vE,EAAApe,aAEA8Z,EAAAlsD,YAAAinD,EAAAxmE,SAGAyrE,GAAAwE,WACAxE,EAAAuE,aAAAxJ,EAAAxmE,IAAAyrE,EAAAwE,YAEAxE,EAAAlsD,YAAAinD,EAAAxmE,MAMAkwE,UAAA,SAAAjzD,EAAAC,GACA,GACA/L,GACA1E,EAFA2/D,EAAAhtE,KAAAitE,WAIA,KAAA5/D,EAAA,EAAeA,EAAA2/D,EAAA7mE,OAAuBkH,IACtC0E,EAAAi7D,EAAA3/D,GACAwQ,EAAAtd,KAAAud,EAAA9d,KAAAmtE,QAAAp7D,GAAAA,IAIAu9D,iBAAA,SAAAzxD,EAAAC,GACA,GACAspD,GACAr1D,EACA1E,EAHA2/D,EAAAhtE,KAAAitE,WAKA,KAAA5/D,EAAA,EAAeA,EAAA2/D,EAAA7mE,OAAuBkH,IACtC0E,EAAAi7D,EAAA3/D,GACA+5D,EAAApnE,KAAAmtE,QAAAp7D,GAEAq1D,EAAAuE,aACA9tD,EAAAtd,KAAAud,EAAAspD,EAAAr1D,IAKAo1D,eAAA,SAAAtpD,EAAAC,GACA,GACAspD,GACAr1D,EACA1E,EAHA2/D,EAAAhtE,KAAAitE,WAKA,KAAA5/D,EAAA,EAAeA,EAAA2/D,EAAA7mE,OAAuBkH,IACtC0E,EAAAi7D,EAAA3/D,GACA+5D,EAAApnE,KAAAmtE,QAAAp7D,GAEAq1D,EAAAuE,aACA9tD,EAAAtd,KAAAud,EAAAspD,EAAAr1D,IASAg/D,UAAA,WACA,MAAA/wE,MAAAmtE,SAEAkC,mBAAA,SAAAlxB,GACA,GAAA+uB,GAAAltE,KAAAmtE,QACA6D,EAAAhxE,KAAA2tE,mBACAsD,KACAC,IACAlxE,MAAAsvE,iBAAA,SAAAlI,EAAAr1D,GACAk/D,EAAAl/D,GAAAq1D,EAAA+J,QACA/J,EAAA+J,QAAA,EACA/J,EAAAltC,SAAA,IAEAn2B,EAAA8E,KAAAmoE,EAAA,SAAA5J,EAAAtc,GACAomB,EAAApmB,GAAAsc,EAAA+J,QACA/J,EAAA+J,QAAA,EACA/J,EAAAltC,SAAA,GAOA,KAAA,GAJAw1C,GACA0B,EAFAC,EAAA,EAGAC,EAAA,EAEAjkE,EAAA,EAAAy1B,EAAAqb,EAAAh4C,OAAoCkH,EAAAy1B,EAAOz1B,IAAA,CAC3C,GAAAqc,GAAAy0B,EAAA9wC,GACA2vB,EAAAh9B,KAAA8sE,cAAA,EAAApjD,EAAAsT,OACAoqC,EAAA8F,EAAAlwC,GACAu0C,EAAA7nD,EAAA2T,WAQA,IANA+pC,IACAA,EAAA+J,UACA/J,EAAAltC,QAAAktC,EAAAltC,SAAAxQ,EAAAwQ,SAIAq3C,GAAA,EAAA,CAEAH,IAAAG,IACAH,EAAAG,EACAD,IAGA,IAAAxB,GAAApmD,EAAAqmD,QAAAuB,EAAA,CAEA,KAAA5B,EAAA,CACA,GAAA5kB,GAAAz3C,KAAA4Q,IAAAotD,EAAA5E,EAAA,EACAiD,GAAAsB,EAAAlmB,GAEA4kB,IACAA,EAAAsB,EAAAlmB,GAAA,GAAAyhB,GAAA,cAAAvsE,KAAAA,KAAAyjC,KACAisC,EAAAlC,eAGAkC,EAAAQ,cAAA,EAGAR,EAAAx1C,QAAAw1C,EAAAx1C,SAAAxQ,EAAAwQ,QACAw1C,EAAAyB,UACAzB,EAAAQ,cAAA78D,KAAA6Q,IAAAwrD,EAAAQ,cAAAJ,GAEAJ,EAAAQ,eAAAR,EAAAO,aAEA7I,EAAAltC,SAAA,OAGAxQ,GAAAqmD,WAEAL,IACAA,EAAAS,iBAAA9iE,EACAgkE,IACA3B,EAAA,MAKAA,IACA2B,IACA3B,EAAAS,iBAAA9iE,GAIArN,KAAAsvE,iBAAA,SAAAlI,EAAAr1D,GACAk/D,EAAAl/D,KAAAq1D,EAAA+J,UACA/J,EAAAltC,SAAA,KAGA82C,EAAA7qE,OAAAkN,KAAA4Q,IAAAotD,EAAA5E,GACA1oE,EAAA8E,KAAAmoE,EAAA,SAAA5J,EAAAtc,GACAomB,EAAApmB,KAAAsc,EAAA+J,UACAznD,EAAAwQ,SAAA,GAGAktC,EAAAltC,UACAktC,EAAA6I,WAAA,MAQApmE,MAAA,WAEA,MADA7J,MAAAsvE,iBAAAtvE,KAAAwxE,aACAxxE,MAEAwxE,YAAA,SAAApK,GACAA,EAAAv9D,SAaAk6D,YAAA,SAAA/mC,EAAAinC,GACA,GAAAA,EAAA,CACA,GAAAwN,GAAAzxE,KAAAotE,YAEAqE,GAAAz0C,GAGAj5B,EAAAgN,MAAA0gE,EAAAz0C,GAAAinC,GAAA,GAFAwN,EAAAz0C,GAAAinC,CAKA,IAAAmD,GAAApnE,KAAAmtE,QAAAnwC,EAEAoqC,IACArjE,EAAAgN,MAAAq2D,EAAAqK,EAAAz0C,IAAA,KASA00C,SAAA,SAAA10C,GACA,GAAAkwC,GAAAltE,KAAAmtE,QACAH,EAAAhtE,KAAAitE,YACA7F,EAAA8F,EAAAlwC,EAEAoqC,KAIAA,EAAAxmE,IAAAiO,WAAA4T,YAAA2kD,EAAAxmE,WACAssE,GAAAlwC,GACAgwC,EAAAz/D,OAAAxJ,EAAA8M,QAAAm8D,EAAAhwC,GAAA,KAMAr3B,OAAA,SAAAsJ,EAAAC,GACA,GAAAm9D,GAAArsE,KAAAytE,QAEApB,GAAAxhE,MAAA8mE,QAAA,MAEA,IAAA9wE,GAAAb,KAAA6sE,KAOA,IANA,MAAA59D,IAAApO,EAAAoO,MAAAA,GACA,MAAAC,IAAArO,EAAAqO,OAAAA,GACAD,EAAAjP,KAAA0tE,SAAA,GACAx+D,EAAAlP,KAAA0tE,SAAA,GACArB,EAAAxhE,MAAA8mE,QAAA,GAEA3xE,KAAAqtE,QAAAp+D,GAAAC,GAAAlP,KAAAstE,QAAA,CACAjB,EAAAxhE,MAAAoE,MAAAA,EAAA,KACAo9D,EAAAxhE,MAAAqE,OAAAA,EAAA,IAEA,KAAA,GAAA7O,KAAAL,MAAAmtE,QACAntE,KAAAmtE,QAAAjjD,eAAA7pB,IACAL,KAAAmtE,QAAA9sE,GAAAsF,OAAAsJ,EAAAC,EAIAnL,GAAA8E,KAAA7I,KAAA2tE,mBAAA,SAAAvG,GACAA,EAAAzhE,OAAAsJ,EAAAC,KAEAlP,KAAAi8B,SAAA,GAKA,MAFAj8B,MAAAqtE,OAAAp+D,EACAjP,KAAAstE,QAAAp+D,EACAlP,MAOA4xE,WAAA,SAAA50C,GACA,GAAAoqC,GAAApnE,KAAAmtE,QAAAnwC,EAEAoqC,IACAA,EAAAv9D,SAOApE,QAAA,WACAzF,KAAAN,KAAAwgB,UAAA,GACAlgB,KAAAN,KAAAM,KAAAwyD,QAAAxyD,KAAAytE,SAAAztE,KAAAmtE,QAAA,MASA0E,kBAAA,SAAAhxE,GAgBA,QAAAixE,GAAAC,EAAAC,GACA,GAAAhF,GAAArgC,EAAAsgC,WAEA,OAAA8E,IACAA,IAAAjkB,EAAAA,GAKA,KAAA,GAFAmkB,GAEA5kE,EAAA,EAAqBA,EAAA2/D,EAAA7mE,OAAuBkH,IAAA,CAC5C,GAAA0E,GAAAi7D,EAAA3/D,GACA+5D,EAAAz6B,EAAAwgC,QAAAp7D,EAEA,KAAAq1D,EAAAuE,aAAA55D,EAAAggE,GAAAhgE,EAAAigE,EAAA,CACAC,EAAA7K,CACA,QAIA6K,GAAAA,EAAAC,iBACAC,EAAAh6C,IAAA0mB,OACAozB,EAAAC,eAAAC,EAAAh6C,KACAg6C,EAAAh6C,IAAA4mB,WAnCA,GAFAl+C,EAAAA,MAEAb,KAAA8sE,cACA,MAAA9sE,MAAAmtE,QAAA,GAAAvsE,GAGA,IAAAuxE,GAAA,GAAA5F,GAAA,QAAAvsE,KAAAa,EAAAuxE,YAAApyE,KAAAyjC,IACA0uC,GAAA3E,cACA2E,EAAAE,WAAAxxE,EAAA6d,gBACAyzD,EAAAtoE,OAgCA,KAAA,GA7BAmzB,GAFAirC,EAAAjoE,KAAAwyD,QAAA6U,gBAAA,GACAwH,KAEAliC,EAAA3sC,KA4BAqN,EAAA,EAAmBA,EAAA46D,EAAA9hE,OAAwBkH,IAAA,CAC3C,GAAAqc,GAAAu+C,EAAA56D,EAEAqc,GAAAsT,SAAAA,IACA80C,EAAA90C,EAAAtT,EAAAsT,QACAA,EAAAtT,EAAAsT,QAGAh9B,KAAA+uE,WAAArlD,EAAAyoD,GAAA,EAAAtD,GAIA,MADAiD,GAAA90C,EAAA8wB,EAAAA,GACAqkB,EAAAvxE,KAMAyE,SAAA,WACA,MAAArF,MAAAqtE,QAMA/nE,UAAA,WACA,MAAAtF,MAAAstE,SAEAI,SAAA,SAAA4E,GACA,GAAAzxE,GAAAb,KAAA6sE,MACA0F,GAAA,QAAA,UAAAD,GACAE,GAAA,cAAA,gBAAAF,GACAG,GAAA,cAAA,cAAAH,GACAI,GAAA,eAAA,iBAAAJ,EAEA,IAAA,MAAAzxE,EAAA0xE,IAAA,SAAA1xE,EAAA0xE,GACA,MAAAl7C,YAAAx2B,EAAA0xE,GAGA,IAAA7yE,GAAAM,KAAAN,KAEAizE,EAAAr0D,SAAAs0D,YAAAC,iBAAAnzE,EACA,QAAAA,EAAA8yE,IAAA/G,EAAAkH,EAAAJ,KAAA9G,EAAA/rE,EAAAmL,MAAA0nE,MAAA9G,EAAAkH,EAAAF,KAAA,IAAAhH,EAAAkH,EAAAD,KAAA,GAAA,GAEAjO,YAAA,SAAA13C,EAAA0W,GACAA,EAAAA,GAAAzjC,KAAAyjC,GACA,IAAAw/B,GAAA3kD,SAAAC,cAAA,UACA4Z,EAAA8qC,EAAAzkD,WAAA,MACAhM,EAAAua,EAAA5d,kBACAtE,EAAAkiB,EAAAliB,MACAioE,EAAAjoE,EAAAqzB,WACAC,EAAAtzB,EAAAszB,cACAC,EAAAvzB,EAAAuzB,cACAtoB,EAAAjL,EAAA6uB,YAAA7uB,EAAAiL,UAAA,EACAi9D,EAAA1/D,KAAA6Q,IAAApO,EAAA,GAAAqoB,EAAA20C,GACAE,EAAA3/D,KAAA6Q,IAAApO,EAAA,EAAAqoB,EAAA20C,GACAG,EAAA5/D,KAAA6Q,IAAApO,EAAA,GAAAsoB,EAAA00C,GACAI,EAAA7/D,KAAA6Q,IAAApO,EAAA,EAAAsoB,EAAA00C,GACA7jE,EAAAuD,EAAAvD,MAAA8jE,EAAAC,EACA9jE,EAAAsD,EAAAtD,OAAA+jE,EAAAC,CACAjQ,GAAAh0D,MAAAA,EAAAw0B,EACAw/B,EAAA/zD,OAAAA,EAAAu0B,EACAtL,EAAAlkB,MAAAwvB,EAAAA,GACAtL,EAAAg7C,UAAA,EAAA,EAAAlkE,EAAAC,GACAipB,EAAAsL,IAAAA,CACA,IAAA2vC,IACAnoE,SAAA8hB,EAAA9hB,SACA4J,SAAAkY,EAAAlY,SACAZ,MAAA8Y,EAAA9Y,MAEA8Y,GAAA9hB,UAAA8nE,EAAAvgE,EAAAf,EAAAwhE,EAAAzgE,EAAAb,GACAob,EAAAlY,SAAA,EACAkY,EAAA9Y,OAAA,EAAA,GACA8Y,EAAA4U,kBAEA5U,GACAA,EAAAyM,MAAArB,EAGA,IAAAk7C,GAAAzoE,EACA0oE,EAAA,GAAAD,IACAxoE,OACA4G,EAAA,EACAE,EAAA,EACA7G,MAAAm4D,IAgBA,OAZA,OAAAmQ,EAAAnoE,WACAqoE,EAAAroE,SAAA8hB,EAAA9hB,SAAAmoE,EAAAnoE,UAGA,MAAAmoE,EAAAv+D,WACAy+D,EAAAz+D,SAAAkY,EAAAlY,SAAAu+D,EAAAv+D,UAGA,MAAAu+D,EAAAn/D,QACAq/D,EAAAr/D,MAAA8Y,EAAA9Y,MAAAm/D,EAAAn/D,OAGAq/D,GAGA,IAAA32C,GAAAkmC,CACAhjE,GAAAD,QAAA+8B,G1E6kkBM,SAAU98B,EAAQD,EAASM,G2EjmmBjC,QAAAqzE,KACA,OAAA,EAYA,QAAAC,GAAAnzE,EAAA+iE,EAAA3/B,GACA,GAAAgwC,GAAA1vE,EAAAqtB,eACAniB,EAAAm0D,EAAA/9D,WACA6J,EAAAk0D,EAAA99D,YACAouE,EAAAD,EAAA5oE,KAWA,OATA6oE,GAAAzoE,SAAA,WACAyoE,EAAA9gE,KAAA,EACA8gE,EAAA5gE,IAAA,EACA4gE,EAAAzkE,MAAAA,EAAA,KACAykE,EAAAxkE,OAAAA,EAAA,KACAukE,EAAAxkE,MAAAA,EAAAw0B,EACAgwC,EAAAvkE,OAAAA,EAAAu0B,EAEAgwC,EAAA3rD,aAAA,iBAAAznB,GACAozE,EA1CA,GAAA1vE,GAAA7D,EAAA,GAEAo+C,EAAAp+C,EAAA,IAEAmC,EAAAi8C,EAAAj8C,iBAEAu6B,EAAA18B,EAAA,GAEAk5B,EAAAl5B,EAAA,IA8CAqsE,EAAA,SAAAlsE,EAAA+iE,EAAA3/B,GACA,GAAA7iC,EACA6iC,GAAAA,GAAAphC,EAEA,gBAAAhC,GACAO,EAAA4yE,EAAAnzE,EAAA+iE,EAAA3/B,GAEA1/B,EAAA6sB,SAAAvwB,KACAO,EAAAP,EACAA,EAAAO,EAAAP,IAGAL,KAAAK,GAAAA,EACAL,KAAAY,IAAAA,CACA,IAAA+yE,GAAA/yE,EAAAiK,KAEA8oE,KAEA/yE,EAAAgzE,cAAAL,EAEAI,EAAA,uBAAA,OACAA,EAAA,eAAA,OACAA,EAAA,yBAAA,OACAA,EAAA,+BAAA,gBACAA,EAAA,QAAA,EACAA,EAAA,OAAA,EACAA,EAAA,gBAAA,GAGA3zE,KAAA6zE,QAAA,KACA7zE,KAAA8zE,QAAA,KACA9zE,KAAAojE,QAAAA,EACApjE,KAAAikE,OAAA,KAQAjkE,KAAAqyE,WAAA,EAOAryE,KAAA+zE,YAAA,EAOA/zE,KAAAg0E,eAAA,GAMAh0E,KAAAyjC,IAAAA,EAGA8oC,GAAArnE,WACAqrB,YAAAg8C,EACA4E,QAAA,EACAj3C,SAAA,EACAszC,YAAA,WACAxtE,KAAAm4B,IAAAn4B,KAAAY,IAAA4d,WAAA,MACAxe,KAAAm4B,IAAA87C,mBACAj0E,KAAAm4B,IAAAsL,IAAAzjC,KAAAyjC,KAEAywC,iBAAA,WACA,GAAAzwC,GAAAzjC,KAAAyjC,GACAzjC,MAAA6zE,QAAAL,EAAA,QAAAxzE,KAAAK,GAAAL,KAAAojE,QAAA3/B,GACAzjC,KAAA8zE,QAAA9zE,KAAA6zE,QAAAr1D,WAAA,MACAxe,KAAA8zE,QAAAG,mBAEA,GAAAxwC,GACAzjC,KAAA8zE,QAAA7/D,MAAAwvB,EAAAA,IAQA99B,OAAA,SAAAsJ,EAAAC,GACA,GAAAu0B,GAAAzjC,KAAAyjC,IACA7iC,EAAAZ,KAAAY,IACA+yE,EAAA/yE,EAAAiK,MACAgpE,EAAA7zE,KAAA6zE,OACAF,GAAA1kE,MAAAA,EAAA,KACA0kE,EAAAzkE,OAAAA,EAAA,KACAtO,EAAAqO,MAAAA,EAAAw0B,EACA7iC,EAAAsO,OAAAA,EAAAu0B,EAEAowC,IACAA,EAAA5kE,MAAAA,EAAAw0B,EACAowC,EAAA3kE,OAAAA,EAAAu0B,EAEA,GAAAA,GACAzjC,KAAA8zE,QAAA7/D,MAAAwvB,EAAAA,KASA55B,MAAA,SAAAsqE,GACA,GAAAvzE,GAAAZ,KAAAY,IACAu3B,EAAAn4B,KAAAm4B,IACAlpB,EAAArO,EAAAqO,MACAC,EAAAtO,EAAAsO,OACAmjE,EAAAryE,KAAAqyE,WACA+B,EAAAp0E,KAAA+zE,aAAAI,EACAH,EAAAh0E,KAAAg0E,eACAvwC,EAAAzjC,KAAAyjC,GAaA,IAXA2wC,IACAp0E,KAAA6zE,SACA7zE,KAAAk0E,mBAGAl0E,KAAA8zE,QAAArzC,yBAAA,OACAzgC,KAAA8zE,QAAAtxB,UAAA5hD,EAAA,EAAA,EAAAqO,EAAAw0B,EAAAv0B,EAAAu0B,IAGAtL,EAAAg7C,UAAA,EAAA,EAAAlkE,EAAAC,GAEAmjE,EAAA,CACA,GAAAgC,EAEAhC,GAAAx4C,YAEAw6C,EAAAhC,EAAAiC,kBAAA13C,EAAAxC,YAAAjC,EAAAk6C,GACA5gE,EAAA,EACAE,EAAA,EACA1C,MAAAA,EACAC,OAAAA,IAEAmjE,EAAAiC,iBAAAD,GAEAhC,EAAAvnE,QACAupE,EAAAj7C,EAAAl0B,UAAAm0B,iBAAA94B,KAAA8xE,EAAAl6C,IAGAA,EAAA0mB,OACA1mB,EAAAmC,UAAA+5C,GAAAhC,EACAl6C,EAAAo8C,SAAA,EAAA,EAAAtlE,EAAAC,GACAipB,EAAA4mB,UAGA,GAAAq1B,EAAA,CACA,GAAAP,GAAA7zE,KAAA6zE,OACA17C,GAAA0mB,OACA1mB,EAAAqI,YAAAwzC,EACA77C,EAAAqqB,UAAAqxB,EAAA,EAAA,EAAA5kE,EAAAC,GACAipB,EAAA4mB,YAIA,IAAApiB,GAAA4vC,CACA1sE,GAAAD,QAAA+8B,G3EqnmBM,SAAU98B,EAAQD,G4Eh1mBxB,GAAA+8B,GAAA,mBAAAn2B,UAAAA,OAAAgmE,uBAAAhmE,OAAAgmE,sBAAAhlE,KAAAhB,SACAA,OAAAguE,yBAAAhuE,OAAAguE,wBAAAhtE,KAAAhB,SAAAA,OAAAiuE,0BAAAjuE,OAAAkuE,8BAAA,SAAAtiD,GACAhnB,WAAAgnB,EAAA,IAGAvyB,GAAAD,QAAA+8B,G5Es1mBM,SAAU98B,EAAQD,EAASM,G6E31mBjC,GAAA6D,GAAA7D,EAAA,GAEAy0E,EAAAz0E,EAAA,IAEA00E,EAAAD,EAAAC,WAEApI,EAAAtsE,EAAA,IAEAumC,EAAAvmC,EAAA,IAwCA4iE,EAAA,SAAA1/D,GACAA,EAAAA,MACApD,KAAAujE,MAAAngE,EAAAmgE,UAEAvjE,KAAAqrC,QAAAjoC,EAAAioC,SAAA,aAGArrC,KAAA60E,UACA70E,KAAA80E,UAAA,EACA90E,KAAA+0E,MACA/0E,KAAAstC,YACAttC,KAAAg1E,YACAh1E,KAAAqsC,SAAA,EACAuoC,EAAAr0E,KAAAP,MAGA8iE,GAAA59D,WACAqrB,YAAAuyC,EAMAj2B,QAAA,SAAArB,GACAxrC,KAAA60E,OAAArrE,KAAAgiC,IAOArJ,YAAA,SAAA2E,GACAA,EAAA5E,UAAAliC,IAGA,KAAA,GAFAi1E,GAAAnuC,EAAAmG,WAEA5/B,EAAA,EAAmBA,EAAA4nE,EAAA9uE,OAAkBkH,IACrCrN,KAAA6sC,QAAAooC,EAAA5nE,KAQA2/B,WAAA,SAAAxB,GACA,GAAAsf,GAAA/mD,EAAA8M,QAAA7Q,KAAA60E,OAAArpC,EAEAsf,IAAA,GACA9qD,KAAA60E,OAAAtnE,OAAAu9C,EAAA,IAQA1oB,eAAA,SAAA0E,GAGA,IAAA,GAFAmuC,GAAAnuC,EAAAmG,WAEA5/B,EAAA,EAAmBA,EAAA4nE,EAAA9uE,OAAkBkH,IACrCrN,KAAAgtC,WAAAioC,EAAA5nE,GAGAy5B,GAAA5E,UAAA,MAEAgzC,QAAA,WASA,IAAA,GARA/tC,IAAA,GAAA7f,OAAA6tD,UAAAn1E,KAAAstC,YAEAiF,EAAApL,EAAAnnC,KAAA+0E,MACAE,EAAAj1E,KAAA60E,OACAzkD,EAAA6kD,EAAA9uE,OACAivE,KACAC,KAEAhoE,EAAA,EAAmBA,EAAA+iB,EAAS/iB,IAAA,CAC5B,GAAAm+B,GAAAypC,EAAA5nE,GACArG,EAAAwkC,EAAAlqC,KAAA6lC,EAAAoL,EAGAvrC,KACAouE,EAAA5rE,KAAAxC,GACAquE,EAAA7rE,KAAAgiC,IAKA,IAAA,GAAAn+B,GAAA,EAAmBA,EAAA+iB,GACnB6kD,EAAA5nE,GAAA0gC,cACAknC,EAAA5nE,GAAA4nE,EAAA7kD,EAAA,GACA6kD,EAAAtjC,MACAvhB,KAEA/iB,GAIA+iB,GAAAglD,EAAAjvE,MAEA,KAAA,GAAAkH,GAAA,EAAmBA,EAAA+iB,EAAS/iB,IAC5BgoE,EAAAhoE,GAAAwgC,KAAAunC,EAAA/nE,GAGArN,MAAA+0E,MAAA5tC,EACAnnC,KAAAqrC,QAAAkH,GACAvyC,KAAAgI,QAAA,QAAAuqC,GAEAvyC,KAAAujE,MAAA7hC,QACA1hC,KAAAujE,MAAA7hC,UAGA4zC,WAAA,WAIA,QAAAh0E,KACAqrC,EAAAmoC,WACAtI,EAAAlrE,IACAqrC,EAAAN,SAAAM,EAAAuoC,WANA,GAAAvoC,GAAA3sC,IACAA,MAAA80E,UAAA,EASAtI,EAAAlrE,IAMAmT,MAAA,WACAzU,KAAA+0E,OAAA,GAAAztD,OAAA6tD,UACAn1E,KAAAstC,YAAA,EAEAttC,KAAAs1E,cAMAzvD,KAAA,WACA7lB,KAAA80E,UAAA,GAMA1oC,MAAA,WACApsC,KAAAqsC,UACArsC,KAAAg1E,aAAA,GAAA1tD,OAAA6tD,UACAn1E,KAAAqsC,SAAA,IAOAC,OAAA,WACAtsC,KAAAqsC,UACArsC,KAAAstC,cAAA,GAAAhmB,OAAA6tD,UAAAn1E,KAAAg1E,YACAh1E,KAAAqsC,SAAA,IAOAxiC,MAAA,WACA7J,KAAA60E,WAeAx4C,QAAA,SAAAn1B,EAAA9D,GACAA,EAAAA,KACA,IAAA0jC,GAAA,GAAAL,GAAAv/B,EAAA9D,EAAAg5B,KAAAh5B,EAAA4mC,OAAA5mC,EAAA8mC,OAEA,OADAlqC,MAAAmiC,YAAA2E,GACAA,IAGA/iC,EAAAqjB,MAAA07C,EAAA8R,EACA,IAAAj4C,GAAAmmC,CACAjjE,GAAAD,QAAA+8B,G7Ei2mBM,SAAU98B,EAAQD,EAASM,G8EhknBjC,QAAAq1E,GAAA7rD,GAEA,MAAAA,GAAA6rD,sBAAA7rD,EAAA6rD,yBACA3iE,KAAA,EACAE,IAAA,GAKA,QAAA0iE,GAAA9rD,EAAA1iB,EAAAg9B,EAAAyxC,GAiCA,MAhCAzxC,GAAAA,MAWAyxC,IAAA7hB,EAAAa,gBACAihB,EAAAhsD,EAAA1iB,EAAAg9B,GAQA4vB,EAAAC,QAAAQ,SAAA,MAAArtD,EAAA2uE,QAAA3uE,EAAA2uE,SAAA3uE,EAAAuB,SACAy7B,EAAAihC,IAAAj+D,EAAA2uE,OACA3xC,EAAAkhC,IAAAl+D,EAAA4uE,QAEA,MAAA5uE,EAAAuB,SACAy7B,EAAAihC,IAAAj+D,EAAAuB,QACAy7B,EAAAkhC,IAAAl+D,EAAAwB,SAGAktE,EAAAhsD,EAAA1iB,EAAAg9B,GAGAA,EAGA,QAAA0xC,GAAAhsD,EAAA1iB,EAAAg9B,GAEA,GAAA6xC,GAAAN,EAAA7rD,EACAsa,GAAAihC,IAAAj+D,EAAA2f,QAAAkvD,EAAAjjE,KACAoxB,EAAAkhC,IAAAl+D,EAAA4f,QAAAivD,EAAA/iE,IAQA,QAAAgjE,GAAApsD,EAAA1iB,EAAAyuE,GAGA,GAFAzuE,EAAAA,GAAAR,OAAAuB,MAEA,MAAAf,EAAAi+D,IACA,MAAAj+D,EAGA,IAAAinC,GAAAjnC,EAAAlB,KACAiwE,EAAA9nC,GAAAA,EAAAp9B,QAAA,UAAA,CAEA,IAAAklE,EAGG,CACH,GAAAC,GAAA,YAAA/nC,EAAAjnC,EAAAivE,cAAA,GAAAjvE,EAAAkvE,eAAA,EACAF,IAAAR,EAAA9rD,EAAAssD,EAAAhvE,EAAAyuE,OAJAD,GAAA9rD,EAAA1iB,EAAAA,EAAAyuE,GACAzuE,EAAAu+D,QAAAv+D,EAAA8e,WAAA9e,EAAA8e,WAAA,MAAA9e,EAAAmvE,QAAA,GAAA,CAUA,IAAAC,GAAApvE,EAAAovE,MAMA,OAJA,OAAApvE,EAAAy+D,OAAA5rD,SAAAu8D,GAAAC,EAAA59D,KAAAzR,EAAAlB,QACAkB,EAAAy+D,MAAA,EAAA2Q,EAAA,EAAA,EAAAA,EAAA,EAAA,EAAAA,EAAA,EAAA,GAGApvE,EAGA,QAAA0f,GAAAgD,EAAArhB,EAAAo6B,GACA6zC,EACA5sD,EAAAhD,iBAAAre,EAAAo6B,GAEA/Y,EAAA6sD,YAAA,KAAAluE,EAAAo6B,GAIA,QAAAvb,GAAAwC,EAAArhB,EAAAo6B,GACA6zC,EACA5sD,EAAAxC,oBAAA7e,EAAAo6B,GAEA/Y,EAAA8sD,YAAA,KAAAnuE,EAAAo6B,GAuBA,QAAAg0C,GAAAzvE,GAEA,MAAAA,GAAAy+D,MAAA,EA3IA,GAAA5hE,GAAA3D,EAAA,GAEAN,GAAAg1E,WAAA/wE,CAEA,IAAA+vD,GAAA1zD,EAAA,IAOAo2E,EAAA,mBAAA9vE,WAAAA,OAAAkgB,iBACA2vD,EAAA,iDAoHAxwD,EAAAywD,EAAA,SAAAtvE,GACAA,EAAA0vE,iBACA1vE,EAAA2vE,kBACA3vE,EAAA2H,cAAA,GACC,SAAA3H,GACDA,EAAA4vE,aAAA,EACA5vE,EAAA2H,cAAA,EASA/O,GAAA41E,cAAAA,EACA51E,EAAAk2E,eAAAA,EACAl2E,EAAA8mB,iBAAAA,EACA9mB,EAAAsnB,oBAAAA,EACAtnB,EAAAimB,KAAAA,EACAjmB,EAAA62E,aAAAA,G9EolnBM,SAAU52E,EAAQD,EAASM,G+E5snBjC,QAAA22E,GAAAxuE,GACA,MAAA,eAAAA,GAAAurD,EAAAC,QAAAQ,QAAA,iBAAAhsD,EAGA,QAAAyuE,GAAA/Q,EAAAh+D,EAAAw7D,GACA,GAAAwT,GAAAhR,EAAAiR,WACA,WAAAzT,GAAAwT,EAAAltE,OACA,IAAAotE,GAAAF,EAAAG,UAAAnvE,EAAAg+D,EAAAtjC,QAAAovB,UAAA9pD,EAAAk9D,IAAAl9D,EAAAm9D,IAAA,MAAAh+D,OAAA6+D,EAAAnlE,IAGA,IAFA,QAAA2iE,GAAAwT,EAAAltE,QAEAotE,EAAA,CACA,GAAAnxE,GAAAmxE,EAAAnxE,IACAiC,GAAAo9D,aAAAr/D,EACAigE,EAAAtjC,QAAAkvB,mBACAzqD,OAAA+vE,EAAA/vE,QACKpB,EAAAmxE,EAAAlvE,QAwBL,QAAAovE,GAAA/U,GACAA,EAAAgV,WAAA,EACAC,aAAAjV,EAAAkV,aACAlV,EAAAkV,YAAAlsE,WAAA,WACAg3D,EAAAgV,WAAA,GACG,KAqIH,QAAAG,GAAAxvE,GACA,GAAAyvE,GAAAzvE,EAAAyvE,WACA,OAAA,QAAAA,GAAA,UAAAA,EAoBA,QAAAC,GAAArV,GAWA,QAAAsV,GAAA3nD,EAAAqyC,GACA,MAAA,YACA,IAAAA,EAAAgV,UAIA,MAAArnD,GAAAnV,MAAAwnD,EAAAl8D,YAhBAjC,EAAA4E,KAAA8uE,EAAA,SAAAtvE,GACA+5D,EAAAwV,UAAAvvE,GAAApE,EAAAuD,KAAAqwE,EAAAxvE,GAAA+5D,KAEAn+D,EAAA4E,KAAAivE,EAAA,SAAAzvE,GACA+5D,EAAAwV,UAAAvvE,GAAApE,EAAAuD,KAAAqwE,EAAAxvE,GAAA+5D,KAEAn+D,EAAA4E,KAAAkvE,EAAA,SAAA1vE,GACA+5D,EAAAwV,UAAAvvE,GAAAqvE,EAAAG,EAAAxvE,GAAA+5D,KAcA,QAAA4V,GAAAp3E,GA2DA,QAAAq3E,GAAAnS,EAAA1D,GACAn+D,EAAA4E,KAAAi9D,EAAA,SAAAz9D,GACAqe,EAAA9lB,EAAAi2E,EAAAxuE,GAAA+5D,EAAAwV,UAAAvvE,KACK+5D,GA7DLv+D,EAAAtD,KAAAP,MACAA,KAAAY,IAAAA,EAMAZ,KAAAo3E,WAAA,EAMAp3E,KAAAs3E,YAMAt3E,KAAAg3E,YAAA,GAAAkB,GACAl4E,KAAA43E,aACAH,EAAAz3E,MAEA4zD,EAAAiB,uBAQAojB,EAAAH,EAAA93E,OAcA4zD,EAAAgB,sBACAqjB,EAAAN,EAAA33E,MASAi4E,EAAAF,EAAA/3E,OAjTA,GAAA20E,GAAAz0E,EAAA,IAEAwmB,EAAAiuD,EAAAjuD,iBACAQ,EAAAytD,EAAAztD,oBACA4uD,EAAAnB,EAAAmB,eAEA7xE,EAAA/D,EAAA,GAEA2D,EAAA3D,EAAA,IAEA0zD,EAAA1zD,EAAA,IAEAg4E,EAAAh4E,EAAA,IAEAi4E,EAAA,IACAJ,GAAA,QAAA,WAAA,aAAA,WAAA,UAAA,YAAA,YAAA,eACAJ,GAAA,aAAA,WAAA,aACAS,GACAC,YAAA,EACAC,UAAA,EACAC,YAAA,EACAC,WAAA,GAEAV,EAAA7zE,EAAAuf,IAAAu0D,EAAA,SAAA1vE,GACA,GAAAowE,GAAApwE,EAAAsuB,QAAA,QAAA,UACA,OAAAyhD,GAAAK,GAAAA,EAAApwE,IAkDAwvE,GAMAxR,UAAA,SAAAt+D,GACAA,EAAA+tE,EAAA91E,KAAAY,IAAAmH,GACA/H,KAAAgI,QAAA,YAAAD,IAQA4+D,SAAA,SAAA5+D,GACAA,EAAA+tE,EAAA91E,KAAAY,IAAAmH,EACA,IAAA8+D,GAAA9+D,EAAA++D,WAAA/+D,EAAAg/D,aAEA,IAAAF,GAAA7mE,KAAAY,IACA,KAAAimE,GAAA,GAAAA,EAAAr0C,UAAA,CAEA,GAAAq0C,IAAA7mE,KAAAY,IACA,MAGAimE,GAAAA,EAAAh4D,WAIA7O,KAAAgI,QAAA,WAAAD,IAQA2wE,WAAA,SAAA3wE,GAGAA,EAAA+tE,EAAA91E,KAAAY,IAAAmH,GAGAA,EAAAy9D,WAAA,EACAxlE,KAAAkmE,iBAAA,GAAA5+C,MACAwvD,EAAA92E,KAAA+H,EAAA,SAGA8vE,EAAAxR,UAAA9lE,KAAAP,KAAA+H,GACA8vE,EAAAc,UAAAp4E,KAAAP,KAAA+H,GACAovE,EAAAn3E,OAQA44E,UAAA,SAAA7wE,GACAA,EAAA+tE,EAAA91E,KAAAY,IAAAmH,GAGAA,EAAAy9D,WAAA,EACAsR,EAAA92E,KAAA+H,EAAA,UAIA8vE,EAAAxR,UAAA9lE,KAAAP,KAAA+H,GACAovE,EAAAn3E,OAQA64E,SAAA,SAAA9wE,GACAA,EAAA+tE,EAAA91E,KAAAY,IAAAmH,GAGAA,EAAAy9D,WAAA,EACAsR,EAAA92E,KAAA+H,EAAA,OACA8vE,EAAAiB,QAAAv4E,KAAAP,KAAA+H,IAUA,GAAAuf,MAAAtnB,KAAAkmE,iBAAAiS,GACAN,EAAAkB,MAAAx4E,KAAAP,KAAA+H,GAGAovE,EAAAn3E,OAEAq4E,YAAA,SAAAtwE,GACA8vE,EAAAc,UAAAp4E,KAAAP,KAAA+H,IAIAwwE,YAAA,SAAAxwE,GAMAwvE,EAAAxvE,IACA8vE,EAAAxR,UAAA9lE,KAAAP,KAAA+H,IAGAuwE,UAAA,SAAAvwE,GACA8vE,EAAAiB,QAAAv4E,KAAAP,KAAA+H,IAEAywE,WAAA,SAAAzwE,GAMAwvE,EAAAxvE,IACA8vE,EAAAlR,SAAApmE,KAAAP,KAAA+H,IAcA9D,GAAA4E,MAAA,QAAA,YAAA,UAAA,aAAA,WAAA,eAAA,SAAAR,GACAwvE,EAAAxvE,GAAA,SAAAN,GACAA,EAAA+tE,EAAA91E,KAAAY,IAAAmH,GACA/H,KAAAgI,QAAAK,EAAAN,KAkGA,IAAAixE,GAAAhB,EAAA9yE,SAEA8zE,GAAAvzE,QAAA,WAGA,IAAA,GAFAqgE,GAAAiS,EAAA7pE,OAAAypE,GAEAtqE,EAAA,EAAiBA,EAAAy4D,EAAA3/D,OAAyBkH,IAAA,CAC1C,GAAAhF,GAAAy9D,EAAAz4D,EACA6Z,GAAAlnB,KAAAY,IAAAi2E,EAAAxuE,GAAArI,KAAA43E,UAAAvvE,MAIA2wE,EAAAtS,UAAA,SAAA/B,GACA3kE,KAAAY,IAAAiK,MAAA0K,OAAAovD,GAAA,WAGA1gE,EAAAmjB,MAAA4wD,EAAAn0E,EACA,IAAA84B,GAAAq7C,CACAn4E,GAAAD,QAAA+8B,G/E8unBM,SAAU98B,EAAQD,EAASM,GgF9/nBjC,QAAAqmC,GAAA0yC,GACA,GAAA53C,GAAA43C,EAAA,GAAA,GAAAA,EAAA,GAAA,GACA33C,EAAA23C,EAAA,GAAA,GAAAA,EAAA,GAAA,EACA,OAAA5lE,MAAA2D,KAAAqqB,EAAAA,EAAAC,EAAAA,GAGA,QAAAtpB,GAAAihE,GACA,QAAAA,EAAA,GAAA,GAAAA,EAAA,GAAA,IAAA,GAAAA,EAAA,GAAA,GAAAA,EAAA,GAAA,IAAA,GAnEA,GAAAC,GAAAh5E,EAAA,IAKAg4E,EAAA,WAKAl4E,KAAAm5E,UAGAjB,GAAAhzE,WACAqrB,YAAA2nD,EACAhB,UAAA,SAAAnvE,EAAAb,EAAAxH,GAGA,MAFAM,MAAAo5E,SAAArxE,EAAAb,EAAAxH,GAEAM,KAAAq5E,WAAAtxE,IAEA8B,MAAA,WAEA,MADA7J,MAAAm5E,OAAAhzE,OAAA,EACAnG,MAEAo5E,SAAA,SAAArxE,EAAAb,EAAAxH,GACA,GAAA45E,GAAAvxE,EAAAuxE,OAEA,IAAAA,EAAA,CAWA,IAAA,GAPAC,IACAx2D,UACAu2D,WACApyE,OAAAA,EACAa,MAAAA,GAGAsF,EAAA,EAAA+iB,EAAAkpD,EAAAnzE,OAAyCkH,EAAA+iB,EAAS/iB,IAAA,CAClD,GAAA2oE,GAAAsD,EAAAjsE,GACAJ,EAAAisE,EAAA1D,cAAA91E,EAAAs2E,KACAuD,GAAAx2D,OAAAvZ,MAAAyD,EAAAg4D,IAAAh4D,EAAAi4D,MACAqU,EAAAD,QAAA9vE,KAAAwsE,GAGAh2E,KAAAm5E,OAAA3vE,KAAA+vE,KAEAF,WAAA,SAAAtxE,GACA,IAAA,GAAA68D,KAAA4U,GACA,GAAAA,EAAAtvD,eAAA06C,GAAA,CACA,GAAAqS,GAAAuC,EAAA5U,GAAA5kE,KAAAm5E,OAAApxE,EAEA,IAAAkvE,EACA,MAAAA,KAiBA,IAAAuC,IACAC,MAAA,SAAAC,EAAA3xE,GACA,GAAAsiC,GAAAqvC,EAAAvzE,MAEA,IAAAkkC,EAAA,CAIA,GAAAsvC,IAAAD,EAAArvC,EAAA,QAA6CtnB,OAC7C62D,GAAAF,EAAArvC,EAAA,QAA6CtnB,QAAA42D,CAE7C,IAAAC,GAAAA,EAAAzzE,OAAA,GAAAwzE,GAAAA,EAAAxzE,OAAA,EAAA,CACA,GAAAm/D,GAAA/+B,EAAAozC,GAAApzC,EAAAqzC,IACAtwD,SAAAg8C,KAAAA,EAAA,GACAv9D,EAAAu9D,WAAAA,CACA,IAAAuU,GAAA7hE,EAAA2hE,EAGA,OAFA5xE,GAAAq9D,OAAAyU,EAAA,GACA9xE,EAAAs9D,OAAAwU,EAAA,IAEA/zE,KAAA,QACAoB,OAAAwyE,EAAA,GAAAxyE,OACAa,MAAAA,OAMA40B,EAAAu7C,CACAr4E,GAAAD,QAAA+8B,GhFgkoBM,SAAU98B,EAAQD,EAASM,GiFrpoBjC,QAAAgE,GAAAkF,EAAAy4B,EAAAi4C,EAAAC,GACAC,EAAAz5E,KAAAP,MACAA,KAAAoJ,KAAAA,EACApJ,KAAA6hC,GAAAA,EACA7hC,KAAA+5E,WAAAA,EACA/5E,KAAA2B,KAAAm4E,EACA95E,KAAAm6D,SAdA,GAAA6f,GAAA95E,EAAA,IACA+D,EAAA/D,EAAA,GACA6rB,EAAA7rB,EAAA,IACAyC,EAAAzC,EAAA,GACAmE,EAAAnE,EAAA,IAEA+5E,GADA/5E,EAAA,IACAA,EAAA,KACAg6E,EAAAh6E,EAAA,GAWAgE,GAAAyV,cAAA,6BACAzV,EAAAwV,WAAA,0BACAxV,EAAAqV,gBAAA,+BACArV,EAAA4V,aAAA,4BACA5V,EAAAi2E,IAAA,MACAj2E,EAAAk2E,cAAA,6BACAl2E,EAAAm2E,QAAA,UAEAn2E,EAAAo2E,SACAC,SAAAN,EAAAO,aACAC,OAAAR,EAAAS,WACAC,MAAAV,EAAAW,UACAT,IAAAF,EAAAY,QACAR,QAAAJ,EAAAa,aAGA52E,EAAAgB,UAAAi1D,OAAA,WACAn6D,KAAA+6E,aACA/6E,KAAA+5E,YACA/5E,KAAAg7E,eAIA92E,EAAAgB,UAAA61E,WAAA,WACA/6E,KAAAi7E,mBAGA/2E,EAAAgB,UAAA+1E,gBAAA,WACA,GAAA3pE,GAAAtR,KACAk7E,EAAAl7E,KAAAoJ,KAAA+xE,cACAn7E,MAAAoJ,KAAAjB,QAAA,eAAAnI,KAAAoJ,KAAAjB,OAAArC,OACAo1E,GAAA,GAEAl7E,KAAAoJ,KAAAgO,YAKA,UAAApX,KAAAoJ,KAAAtD,MACA9F,KAAAoJ,KAAAgyE,aAAAp7E,KAAAoJ,KAAAyB,MAAAzE,QACApG,KAAAoJ,KAAAqE,SAAAzN,KAAAoJ,KAAAgO,cACcpX,KAAAoJ,KAAAiyE,uBACdr7E,KAAAoJ,KAAAiyE,wBAAA,GAEAr7E,KAAA2B,KAAAyD,QAAAi/D,SAAArkE,KAAAoJ,KAAApJ,KAAAoJ,KAAAgO,cAVApX,KAAAs7E,YAAA,GAAA34E,GAAAqgB,UAAqDnY,OAASuU,UAAA,MAC9Dpf,KAAAs7E,YAAAC,kBAAA,EACAv7E,KAAA2G,IAAA3G,KAAAs7E,cAaAJ,GACAj3E,EAAA4E,KAAA7I,KAAAoJ,KAAA+xE,eAAA,SAAA7oE,GAEA,GAAAkpE,GAAA,KACAC,EAAAv3E,EAAAo2E,QAAAhoE,EAAAjK,KAAAukE,cAAA,GACA,IAAA6O,EAAA,CAEA,GAAAz7E,KAAA+5E,WACA,MAEA,IAAAznE,EAAAopE,OACA,MAEA,IAAAppE,EAAAjK,MAAAnE,EAAAi2E,IAEAqB,EAAA74E,EAAAmqB,SAAA2uD,GAA0E5wE,OAASgH,KAAA,WAAkBE,EAAAT,EAAAlI,KAAA2I,EAAA,EAAAqrB,WAAA,IAAmC3rB,EAAA,EAAAE,EAAA,EAAA1C,MAAA,GAAAC,OAAA,KAExIoD,EAAAoI,SACA8gE,EAAAz0E,GAAA,QAAA,SAAAC,GACAA,EAAAwS,KAAAlH,EACAtL,EAAAoC,KAAAkI,EAAAlI,KACAkJ,EAAAoI,UACApI,EAAAoI,SAAA1T,KAIAw0E,EAAAz0E,GAAA,QAAA,SAAAC,GACA,GAAAc,KACAA,GAAAC,MAAAf,EACAc,EAAAZ,OAAAlH,KACA8H,EAAAhC,KAAA5B,EAAA4V,aACAxI,EAAAtJ,QAAAF,EAAAhC,KAAAgC,SAGqB,IAAAwK,EAAAjK,MAAAnE,EAAAm2E,QAAA,CACrB,GAAA7nE,IAAoCf,EAAA,EAAAE,EAAA,EAAA1C,MAAA,GAAAC,OAAA,GACpCssE,GAAA74E,EAAAmqB,SAAA2uD,GAA0E5wE,OAASgH,KAAA,WAAkBE,EAAAT,EAAAlI,KAAA2I,EAAA,EAAAqrB,WAAA,GAAkC5qB,GACvIgpE,EAAAz0E,GAAA,QAAA,SAAAC,GACA,GAAAc,KACAA,GAAAC,MAAAf,EACAc,EAAAZ,OAAAlH,KACA8H,EAAAhC,KAAA5B,EAAAk2E,cACA9oE,EAAAtJ,QAAAF,EAAAhC,KAAAgC,SAEqB,CACrB,GAAA6zE,IAAyClqE,EAAA,EAAAE,EAAA,EAAA1C,MAAA,GAAAC,OAAA,GACzCssE,GAAA74E,EAAAmqB,SAAA2uD,GAA0E5wE,OAASgH,KAAA,WAAkBG,WAAA,EAAAD,EAAAT,EAAAlI,KAAA2I,EAAA,EAAA7J,SAAA7D,EAAA,QAAAiO,EAAAjK,KAAAukE,eAAAxvC,WAAA,GAAsGu+C,EAC3M,IAAAp1E,IAAA,YAAA,OAAA,UACAtC,GAAA4E,KAAAtC,EAAA,SAAAuC,GACA0yE,EAAAz0E,GAAA+B,EAAA,SAAA9B,GACA,GAAAc,KACAA,GAAAC,MAAAf,EACAc,EAAA0R,KAAAlH,EAAAlP,QACA0E,EAAAhC,KAAA,iBAAAgD,EAAA,QACAwI,EAAAtJ,QAAAF,EAAAhC,KAAAgC,YAMA0zE,GAAAtB,EAAA0B,aAAAtpE,EAAAupE,SAAA,EAAA,EAAAvpE,EAAArD,OAAA,GAAAqD,EAAApD,QAAA,GAAAoC,EAAAlI,KAAA2I,EAAA,EAAAO,EAAAgc,OAAA,QACAktD,EAAAz0E,GAAA,QAAA,SAAAC,GACAA,EAAAwS,KAAAlH,EACAtL,EAAAoC,KAAAkI,EAAAlI,KACAkJ,EAAAoI,UACApI,EAAAoI,SAAA1T,EAEA,IAAAymB,IAAqC1lB,MAAAf,EAAAlB,KAAA,iBAAAwM,EAAAjK,KAAA,QACrCiJ,GAAA3P,KAAAqG,QAAAylB,EAAA3nB,KAAA2nB,IAGA+tD,GAAAnzE,KAAAiK,EAAAjK,KACAiJ,EAAA3K,IAAA60E,MAKAt3E,EAAAgB,UAAA+T,eAAA,SAAA7P,EAAA6X,GACA,GAAA5T,GAAA,EACAyuE,EAAA73E,EAAAmC,MAAA6a,EAAA8B,OAAA,IACAlO,EAAAzL,EAAAyL,SACAC,EAAAD,GAAAxB,KAAA0B,GAAA,IACA,IAAA1B,KAAAC,IAAAuB,GAAA,EAAA,CACA,GAAAknE,GAAAhwD,EAAAxV,qBAAA0K,EAAA7X,GACA4yE,EAAAD,EAAAt4E,EACAq4E,IAAAE,EAAAvqE,EAAAwP,EAAAxP,EAAAuqE,EAAArqE,EAAAsP,EAAAtP,GAGA3R,KAAAs7E,cACAt7E,KAAAs7E,YAAA1jE,UAAuCmL,OAAA9B,EAAA8B,SACvC/iB,KAAAs7E,YAAA9sE,KAAA,WAAAqG,IAGA7U,KAAAmJ,UAAA,SAAA8yE,GACAA,EAAAV,kBAEAU,EAAAztE,KAAA,YAAAsG,GAAA,EAAAgnE,EAAA,GAAA,EAAA,GAAAzuE,IAAAyuE,EAAA,GAAA,GAAA,GAAAzuE,IAAAyuE,EAAA,GAAA,OAIA97E,KAAAk8E,qBAAA9yE,EAAA6X,IAGA/c,EAAAgB,UAAA81E,YAAA,aAGA92E,EAAAgB,UAAAg3E,qBAAA,SAAA9yE,EAAA6X,GAGA,GAAA7X,EAAAjB,QAAAiB,EAAAjB,OAAAzB,MAAA,GAAA0C,EAAAjB,OAAAzB,MAAA,cAAA0C,EAAAjB,OAAArC,KACA9F,KAAAwO,KAAA,YAAAyS,EAAAxP,EAAAwP,EAAAtP,QACS,CACT,GAAAwqE,GAAA/yE,EAAAnC,MAAAmC,EAAAnC,MAAAwK,EAAA,EACA2qE,EAAAhzE,EAAAnC,MAAAmC,EAAAnC,MAAA0K,EAAA,CACA3R,MAAAwO,KAAA,YAAAyS,EAAAxP,EAAArI,EAAAjB,OAAA8C,SAAA,GAAAkxE,EAAAl7D,EAAAtP,EAAAvI,EAAAjB,OAAA8C,SAAA,GAAAmxE,MAIAl4E,EAAAgB,UAAAwK,QAAA,WACA1P,KAAAoJ,KAAAgO,cACA,UAAApX,KAAAoJ,KAAAtD,KACA9F,KAAAoJ,KAAAqE,SAAAzN,KAAAoJ,KAAAgyE,cACap7E,KAAAoJ,KAAAiyE,uBACbr7E,KAAAoJ,KAAAiyE,wBAAA,GAEAr7E,KAAA2B,KAAAyD,QAAAiS,YAAArX,KAAAoJ,QAMAnF,EAAAkpB,SAAAjpB,EAAA81E,GACAn6E,EAAAD,QAAAsE,GjF0qoBM,SAAUrE,EAAQD,EAASM,GkFl3oBjC,QAAA85E,KACAh6E,KAAAq8E,WAAAt4E,EAAAk3D,UACAt4D,EAAA8D,MAAAlG,KAAAP,MALA,GAAA2C,GAAAzC,EAAA,GACA6D,EAAA7D,EAAA,GAWA85E,GAAA90E,UAAAi1D,OAAA,aAOA6f,EAAA90E,UAAAuN,QAAA,SAAA9I,KAQAqwE,EAAA90E,UAAAo3E,SAAA,SAAAj0E,EAAAimB,EAAArjB,GACA,GAAAwG,GAAAE,EAAA4qE,EAAAv8E,KAAAw8E,SAAAn0E,IACA,OAAAA,IACAk0E,EAAAl0E,EAEA,IAAA0C,GAAA,GAAApI,GAAAqpB,MACAnhB,OACAE,KAAAwxE,EACAjuD,MAAAA,EAAAA,EAAAtuB,KAAAoD,QAAA2H,KAAAujB,MACAvO,SAAA,wBAEAid,OAAA,IAIA,QADA/xB,EAAAA,EAAAA,EAAA,QAGA,IAAA,OAEAwG,EAAAzR,KAAAyS,UAAAhB,EAAAzR,KAAAiL,SAAA,GAAAF,EAAAoE,kBAAAF,MAAA,EAEA0C,EAAA3R,KAAAyS,UAAAd,EAAA3R,KAAAiL,SAAA,GAAAjL,KAAAmP,kBAAAD,OAAA,EAAA,CACA,MAEA,KAAA,SACAuC,EAAAzR,KAAAyS,UAAAhB,EAAAzR,KAAAiL,SAAA,GAAAF,EAAAoE,kBAAAF,MAAA,EACA0C,EAAA3R,KAAAyS,UAAAd,EAAA3R,KAAAiL,SAAA,GAAA,CACA,MAEA,KAAA,OACAwG,EAAAzR,KAAAyS,UAAAhB,EAAAzR,KAAAiL,SAAA,GAAAF,EAAAoE,kBAAAF,MAAA,EACA0C,EAAA3R,KAAAyS,UAAAd,EAAA3R,KAAAiL,SAAA,GAAA,EAKA,MADAF,GAAAyD,KAAA,SAA4BiD,EAAAA,EAAAE,EAAAA,KAE5B5G,KAAAA,EACAyH,KAAAzH,EAAAoE,oBAOA6qE,EAAA90E,UAAAu3E,YAAA,SAAAxvE,GACA,GAAAwE,GAAAE,EAAA5G,EAAA/K,KAAAud,YAAA,QAEA,QADAtQ,EAAAA,EAAAA,EAAA,QAEA,IAAA,OACAwE,EAAAzR,KAAAyS,UAAAhB,EAAAzR,KAAAiL,SAAA,GAAAF,EAAAoE,kBAAAF,MAAA,EACA0C,EAAA3R,KAAAyS,UAAAd,EAAA3R,KAAAiL,SAAA,GAAAjL,KAAAmP,kBAAAD,OAAA,EAAA,CACA,MACA,KAAA,SACAuC,EAAAzR,KAAAyS,UAAAhB,EAAAzR,KAAAiL,SAAA,GAAAF,EAAAoE,kBAAAF,MAAA,EACA0C,EAAA3R,KAAAyS,UAAAd,EAAA3R,KAAAiL,SAAA,GAAA,CACA,MACA,KAAA,OACAwG,EAAA,EACAE,EAAA3R,KAAAyS,UAAAd,EAAA3R,KAAAiL,SAAA,GAAA,EAIAF,EAAAyD,KAAA,SAA4BiD,EAAAA,EAAAE,EAAAA,KAM5BqoE,EAAA90E,UAAAw3E,OAAA,aAEA/5E,EAAAopB,KAAAoB,SAAA6sD,EAAAr3E,EAAA8D,OACA5G,EAAAD,QAAAo6E,GlF83oBM,SAAUn6E,EAAQD,EAASM,GmF97oBjC,QAAAmE,GAAAjB,GACA42E,EAAAz5E,KAAAP,MACAA,KAAAmK,IAAA/G,MACApD,KAAAmK,IAAArH,OACA9C,KAAAq8E,WAAAr8E,KAAAmK,IAAArH,MAAAuD,IAAA,cACArG,KAAA8C,MAAA9C,KAAAmK,IAAArH,MACA9C,KAAAmK,IAAAnK,KAAAmK,IAAArH,MAAAiD,SAEA/F,KAAAq8E,WAAAtwD,EAAAkvC,UACAj7D,KAAA8C,MAAA,GAAAC,OAEA,IAAA45E,IACAC,QAAqB92E,KAAA,QAAA+2E,KAAA,GAAAvuD,MAAAjqB,EAAAy4E,aAAAC,MAAA,EAAA5pE,OAAA,GACrBtI,OAAoBiL,UAAA,EAAAhE,OAAAzN,EAAAy4E,aAAA50E,SAAA7D,EAAAoM,eACpB/E,YAAyBoK,UAAA,EAAAhE,OAAAzN,EAAA24E,gBACzBC,iBAA8BprE,KAAAxN,EAAA24E,gBAC9B/1E,OAAoB8b,OAAA,KAAAkyC,QAAA,EAAAC,iBAAA,MACpBjqD,UAAuBwI,SAAA,KAAAL,OAAA,KACvB8pE,aAAA,EAAA,GACAC,WAAA,EAAA,GACAC,gBAAA,GAAA,IACAr6D,OAAA,MAEAs6D,oBAAA,EACA3wE,gBAAA,KACAyB,QAAA,EACApD,MACAA,KAAA,KACA8X,SAAA,UACA9C,SAAA,uBACAu9D,QAAA,SACAC,gBAAA,GAEAxrE,EAAA,EAGA/R,MAAAoD,QAAA2oB,EAAAvX,SAAAmoE,EAAA38E,KAAAmK,KAAA,EAAA,mBACAnK,KAAAw9E,WACAx9E,KAAAy9E,eAAA,GAAA96E,GAAA8D,MACAzG,KAAA6M,UAAA,KACA7M,KAAA8M,QAAA,KACA9M,KAAAsM,KAAA,KACAtM,KAAA09E,WAAA,GAAA/6E,GAAA8D,MACAzG,KAAAmR,SACAnR,KAAAm6D,SA3EA,GAAApuC,GAAA7rB,EAAA,IACA+D,EAAA/D,EAAA,GACA4lD,EAAA5lD,EAAA,IACAyC,EAAAzC,EAAA,GACA85E,EAAA95E,EAAA,IACAg6E,EAAAh6E,EAAA,IACAy9E,EAAAz9E,EAAA,IACA09E,EAAA19E,EAAA,IACA29E,EAAA39E,EAAA,IACA8D,EAAA9D,EAAA,IACA6C,EAAA7C,EAAA,GAEAmE,GAAAoM,cAAA,WACApM,EAAAqM,YAAA,SACArM,EAAAsM,WAAA,QACAtM,EAAAkI,WAAA,QACAlI,EAAAy5E,OAAA,EACAz5E,EAAA05E,WAAA,YACA15E,EAAA25E,SAAA,UACA35E,EAAA45E,KAAA,OACA55E,EAAA65E,MAAA,QACA75E,EAAA85E,IAAA,MACA95E,EAAA+5E,OAAA,SACA/5E,EAAA+5E,OAAA,SACA/5E,EAAAg6E,UAAA,IACAh6E,EAAAy4E,aAAA,OACAz4E,EAAA24E,eAAA,UA0DA34E,EAAAa,UAAA+2B,QAAA,SAAAqiD,GACAA,IACAt+E,KAAAu+E,cAAAD,EAGA,IAAAv7D,GAAAgJ,EAAA+wC,eAAA98D,KAAAu+E,cAEAv+E,MAAAoD,QAAAyH,MAAA3C,UAAA7D,EAAAsM,YAAAoS,EAAA5c,OAAA,EACAnG,KAAAw+E,YAAAx+E,KAAAu+E,eAEAv+E,KAAAsM,KAAAkC,KAAA,SAAqCuU,OAAAA,GAGrC,IAAApD,GAAA3f,KAAAud,YAAA,YACAovB,EAAA3sC,KAAAy+E,IACA,IAAAz+E,KAAAoD,QAAAyH,MAAA3C,UAAA7D,EAAAkI,YAAAtI,EAAAiJ,QAAAlN,KAAAoD,QAAA2H,KAAAA,MACA/K,KAAAoD,QAAA2H,KAAAA,KAAAoC,QAAA,SAAAC,EAAAC,GACAoxE,EAAAj1E,KAAAmjC,EAAApvB,YAAA,YAAAlQ,UAES,KAAAsS,GAAA3f,KAAAoD,QAAA2H,KAAAA,KAAA,CACT,GAAAA,GAAA/K,KAAAs8E,SAAA,WAAAt8E,KAAAoD,QAAA2H,KAAAA,KAAA,EAAA,EACA/K,MAAA2G,IAAAoE,EAAAA,MACA4U,EAAA3f,KAAAud,YAAA,YAEA,GAAAkhE,EAAAt4E,OAAA,EAAA,CACA,GAAA2d,GAAA26D,EAAAt4E,OACAue,EAAA1kB,KAAAu+E,cAAA,GAAA9sE,EAAAzR,KAAAu+E,cAAA,GAAA9sE,EACA27B,EAAAj0B,SAAAuL,EAAAZ,GACA7W,GAAA,EAAAkM,SAAA2K,EAAA,EAEA26D,GAAAtxE,QAAA,SAAAC,EAAAC,GACA,GAAAqxE,GAAA/xC,EAAAgyC,eAAAhyC,EAAAvpC,QAAA2H,MAAA6zE,EAAA,GAEAC,EAAAlyC,EAAAmyC,gBAAAJ,EACAG,SAAA,IAAAA,EACAA,EAAA,EAEAD,EAAAC,EAAA,EAAA,OAAA,QAEAA,EAAAxrE,KAAAC,IAAAurE,EACA,IAAAE,GAAA,IAAAF,EAAAxrE,KAAA0B,GACAF,EAAA,KAAA1O,EAAA,IACAiH,GAAAK,SAAA,OAAAxJ,EAAAsuB,SAAAoa,EAAAvpC,QAAA2H,KAAAA,KAAAsC,IAAAs/B,EAAAvpC,QAAA2H,KAAAA,KAAAsC,GAAAs/B,EAAAvpC,QAAA2H,KAAAA,KAAAsC,GAAAtC,MAEA6zE,GACA/pE,EAAAkqE,EAAA,IAAAA,EAAA,IAAA1rE,KAAA0B,GAAA,KAAA,GAAAgqE,GAAA1rE,KAAA0B,GAAA,IACAF,EAAA,UAAA+pE,GAAA,EAAA/pE,GAEAA,EAAA,GAAAxB,KAAA0B,GAAA,IAEA3H,EAAAoB,KAAA,WAAAqG,GAEA,KAAAkqE,EACAL,EAAA,IAAAzxE,GAEAyxE,EAAA,IAAAzxE,EACA,IAAA4xE,IACA14E,EAAAkN,KAAAgpC,IAAA0iC,EAAA1rE,KAAA0B,GAAA,KAAA9H,EACAA,EAAA,EACAyxE,EAAA,IAAA,SAAAE,EAAAz4E,GAAA,EAEAu4E,EAAA,IAAA,SAAAE,GAAA,EAAA,IAKAxxE,EAAAoB,KAAA,WAAAkwE,GACAzxE,GAAAmgC,IAGA,GAAAztB,EAAA,CACAA,EAAAlS,SAAA,OAAAzN,KAAAoD,QAAA2H,KAAAA,KACA,IAAA2zE,GAAA1+E,KAAA2+E,eAAA3+E,KAAAoD,QAAA2H,KACA/K,MAAAoD,QAAAyH,MAAA3C,UAAA7D,EAAAoM,eAAAzQ,KAAAoD,QAAA2H,KAAAwyE,gBACA59D,EAAAnR,KAAA,WAAAxO,KAAA8+E,gBAAAJ,IAEA/+D,EAAAnR,KAAA,WAAAkwE,GAEA1+E,KAAAg/E,oBAAAj8D,IAMA1e,EAAAa,UAAAi1D,OAAA,WACA,GAAAjxD,GAAAlJ,IAEAA,MAAAi/E,qBAGAj/E,KAAAk/E,UAAA,GAAAv8E,GAAAypB,aAEAvhB,MAAA7K,KAAAoD,QAAAyH,MACAkH,EAAA/R,KAAAoD,QAAA2O,IAEA/R,KAAA09E,WAAA/2E,IAAA3G,KAAAk/E,WACAl/E,KAAA2G,IAAA3G,KAAA09E,YACA19E,KAAA2G,IAAA3G,KAAAy9E,gBAEAz9E,KAAAm/E,SAAA,GAAAx8E,GAAAqgB,UAEA/b,MAAAjH,KAAAoD,QAAA6D;AACA4D,MAAA7K,KAAAoD,QAAAyH,MACAkH,EAAA/R,KAAAoD,QAAA2O,IAEA/R,KAAA2G,IAAA3G,KAAAm/E,UAEAn/E,KAAAoD,QAAAyH,MAAA3C,UAAA7D,EAAAsM,YACA3Q,KAAAsM,KAAAtM,KAAA09E,WACA19E,KAAAo/E,iBAAAp/E,KAAAk/E,WACAl/E,KAAAm/E,SAAA9zE,SAEArL,KAAAsM,KAAAtM,KAAAm/E,SACAn/E,KAAAo/E,iBAAAp/E,KAAAm/E,UACAn/E,KAAAk/E,UAAA7zE,OAIA,IAAA9E,IAAA,WAAA,QAwBA,IAvBAtC,EAAA4E,KAAAtC,EAAA,SAAAuC,GACA9I,KAAAsM,KAAAvF,GAAA+B,EAAA7E,EAAAuD,KAAA,SAAAR,GACAA,EAAA2H,cAAA,CACA,IAAA7G,KACAA,GAAAC,MAAAf,EACAc,EAAAhC,KAAA,aAAAgD,EACAhB,EAAAZ,OAAAgC,EACAlJ,KAAAgI,QAAAF,EAAAhC,KAAAgC,GACA9H,KAAAyN,UAA+B6gB,MAAAjqB,EAAA24E,iBAA+B,GAC9D,GAAAh9E,KAAAoD,QAAA+K,SAGAnO,KAAAoD,QAAA+K,QAAAnO,KAAAu+E,cAAAp4E,QAAA,GACAnG,KAAAq/E,2BAEAr/E,KAAAw9E,QAAAr3E,OAAA,GACAnG,KAAAs/E,mBAGat/E,QACJA,MAGTA,KAAAoD,QAAA2H,KAAAA,KAAA,CACA,GAAAA,GAAA,IA0BA,IAzBA9G,EAAAiJ,QAAAlN,KAAAoD,QAAA2H,KAAAA,OAAA/K,KAAAoD,QAAAyH,MAAA3C,UAAA7D,EAAAkI,WACAvM,KAAAoD,QAAA2H,KAAAA,KAAAoC,QAAA,SAAAC,EAAAC,GACA,GAAAuU,GAAA1Y,EAAAozE,SAAA,YAAAjvE,EAAAD,EAAA,EAAA,EACA,IAAAnJ,EAAAsuB,SAAAnlB,GAAA,CACA,GAAAykB,KACAA,GAAA9mB,KAAAqC,EACAykB,EAAAvkB,OAAAsU,EAAA7W,KAAA1K,GACA6I,EAAA9F,QAAA2H,KAAAA,KAAAsC,GAAAwkB,MAEA3oB,GAAA9F,QAAA2H,KAAAA,KAAAsC,GAAAC,OAAAsU,EAAA7W,KAAA1K,EAGA,IADA6I,EAAAvC,IAAAib,EAAA7W,MACA6W,GAAA1Y,EAAAiB,IAAAuC,gBAAA,CACA,GAAAA,GAAAxD,EAAAiB,IAAAuC,eACAkV,GAAA7W,KAAAhE,GAAA,cAAA,SAAAC,GACAA,EAAAe,MAAA2uE,iBACA1vE,EAAAe,MAAA4uE,kBACAjqE,EAAA6yE,UAAAv4E,EAAAe,MAAA/H,YAKA+K,EAAA/K,KAAAs8E,SAAA,WAAAt8E,KAAAoD,QAAA2H,KAAAA,KAAA,EAAA,GACA/K,KAAA2G,IAAAoE,EAAAA,OAEAA,GAAA/K,KAAAmK,IAAAuC,gBAAA,CACA,GAAAA,GAAA1M,KAAAmK,IAAAuC,eACA3B,GAAAA,KAAAhE,GAAA,cAAA,SAAAC,GACAA,EAAAe,MAAA2uE,iBACA1vE,EAAAe,MAAA4uE,kBACAjqE,EAAA6yE,UAAAv4E,EAAAe,MAAA/H,WAMAqE,EAAAa,UAAA+5E,mBAAA,SAAA77E,GACA,GAAAo8E,GAAAx/E,KAAA47E,aAAA,WAAA57E,KAAAoD,QAKA,IAJAo8E,GACAx/E,KAAA2G,IAAA64E,GAGAx/E,KAAAoD,QAAAw5E,OAAAG,KAAA,CACA,GAAA0C,GAAAz/E,KAAA47E,aAAA,aAAA57E,KAAAoD,QACAq8E,IACAz/E,KAAA2G,IAAA84E,KAKAp7E,EAAAa,UAAA85E,oBAAA,SAAAj8D,GACA,GAAAy8D,GAAAx/E,KAAAud,YAAA,YACAkiE,EAAAz/E,KAAAud,YAAA,cACAtS,KAAAkI,EAAAnT,KAAAoD,QAAAw5E,OAAAzpE,MACA,IAAAqsE,EACA,GAAAx/E,KAAAoD,QAAAs8E,QAAA1/E,KAAAoD,QAAAs8E,OAAA9xE,KACA,GAAAgwE,GAAA4B,EAAAx/E,KAAAoD,QAAApD,KAAA09E,WAAA19E,KAAAm/E,cACa,CAEb,GADAl0E,EAAA8X,EAAAA,EAAA5c,OAAA,GACAnG,KAAAoD,QAAAyH,MAAA3C,WAAA7D,EAAAsM,WAAA,CACA,GAAA+T,GAAAohC,EAAAphC,SAAA3B,EAAAA,EAAA5c,OAAA,GAAA4c,EAAAA,EAAA5c,OAAA,GAEA8E,GADAkI,GAAAuR,EACAohC,EAAA1f,QACArjB,EAAAA,EAAA5c,OAAA,GAAA4c,EAAAA,EAAA5c,OAAA,GACAgN,EAAAuR,GAEA3B,EAAAA,EAAA5c,OAAA,GAGAq5E,EAAAhxE,KAAA,WAAAvD,GACAu0E,EAAAhxE,KAAA,WAAAud,EAAA+xC,gBAAA99D,KAAAu+E,cAAAv+E,KAAAu+E,cAAAp4E,OAAA,GAAAnG,KAAAu+E,cAAAv+E,KAAAu+E,cAAAp4E,OAAA,KAIA,GAAAs5E,EAAA,CAEA,GADAx0E,EAAA8X,EAAA,GACA/iB,KAAAoD,QAAAyH,MAAA3C,WAAA7D,EAAAsM,WAAA,CACA,GAAAgvE,GAAA75B,EAAAphC,SAAA3B,EAAA,GAAAA,EAAA,GAEA9X,GADAkI,GAAAwsE,EACA75B,EAAA1f,QACArjB,EAAA,GAAAA,EAAA,GACA5P,EAAAwsE,GAEA58D,EAAA,GAGA08D,EAAAjxE,KAAA,WAAAvD,GACAw0E,EAAAjxE,KAAA,WAAAud,EAAA+xC,gBAAA99D,KAAAu+E,cAAA,GAAAv+E,KAAAu+E,cAAA,OAQAl6E,EAAAa,UAAAuI,SAAA,SAAArK,EAAAw8E,GACA,GAAAJ,GAAA,IAwBA,IAvBAp8E,EAAAkrB,QACAtuB,KAAAoD,QAAAyH,MAAA3C,UAAA7D,EAAAsM,WACA3Q,KAAA09E,WAAAv0E,UAAA,SAAAk/C,GACAA,EAAA75C,KAAA,SAAyCsD,OAAA1O,EAAAkrB,QACzC3rB,EAAAurB,eAAAm6B,GAAmDv2C,OAAA1O,EAAAkrB,WAGnDtuB,KAAAm/E,SAAA3wE,KAAA,SAA6CsD,OAAA1O,EAAAkrB,QAC7C3rB,EAAAurB,eAAAluB,KAAAm/E,UAAuDrtE,OAAA1O,EAAAkrB,SAEvDkxD,EAAAx/E,KAAAud,YAAA,YACAiiE,IACAA,EAAAhxE,KAAA,SAAwCqD,KAAAzO,EAAAkrB,QACxC3rB,EAAAurB,eAAAsxD,GAAkD3tE,KAAAzO,EAAAkrB,SAElDsxD,IACA5/E,KAAAoD,QAAAyH,MAAAiH,OAAA1O,EAAAkrB,MACAtuB,KAAA8C,MAAAE,IAAA,uBAAAI,EAAAkrB,OACAtuB,KAAA8C,MAAAE,IAAA,uBAAAI,EAAAkrB,OACAtuB,KAAAoD,QAAAw5E,OAAAtuD,MAAAlrB,EAAAkrB,QAIAlrB,EAAA2H,KAAA,CACA,GAAA4U,GAAA3f,KAAAud,YAAA,WAEA,KAAAoC,GAAAvc,EAAA2H,KAAAA,KAAA,CACA,GAAAA,GAAA/K,KAAAs8E,SAAA,WAAAl5E,EAAA2H,KAAAA,KAAA,EAAA,EACA/K,MAAA2G,IAAAoE,EAAAA,MACA4U,EAAA3f,KAAAud,YAAA,aAGAna,EAAA2H,KAAAA,MAAA,IAAA3H,EAAA2H,KAAAA,QACA4U,EAAAlS,SAAA,OAAArK,EAAA2H,KAAAA,MACA/K,KAAAoD,QAAA2H,KAAAA,KAAA3H,EAAA2H,KAAAA,KAEA,IAAA2zE,GAAA1+E,KAAA2+E,eAAAv7E,EAAA2H,KACA4U,GAAAnR,KAAA,WAAAkwE,GACAt7E,EAAA2H,KAAAuyE,UACAt9E,KAAAoD,QAAA2H,KAAAuyE,QAAAl6E,EAAA2H,KAAAuyE,SAEAl6E,EAAA2H,KAAAoI,SACAnT,KAAAoD,QAAA2H,KAAAoI,OAAA/P,EAAA2H,KAAAoI,QAGA/P,EAAA2H,KAAAujB,QACA3O,EAAAnR,KAAA,SACAqU,SAAAzf,EAAA2H,KAAAujB,QAEAtuB,KAAAoD,QAAA2H,KAAA8X,SAAAzf,EAAA2H,KAAAujB,OAGAlrB,EAAA2H,KAAAgV,WACAJ,EAAAnR,KAAA,SACAuR,SAAA3c,EAAA2H,KAAAgV,WAEA/f,KAAAoD,QAAA2H,KAAAgV,SAAA3c,EAAA2H,KAAAgV,UAGA3c,EAAA2H,KAAA8X,WACAlD,EAAAnR,KAAA,SACAqU,SAAAzf,EAAA2H,KAAA8X,WAEA7iB,KAAAoD,QAAA2H,KAAA8X,SAAAzf,EAAA2H,KAAA8X,UAEA7iB,KAAA8C,MAAAE,IAAA,eAAAI,EAAA2H,MAGA,GAAA3H,EAAAw5E,OAAA,CACAx5E,EAAAw5E,OAAA92E,OACA9F,KAAAoD,QAAAw5E,OAAA92E,KAAA1C,EAAAw5E,OAAA92E,KACA9F,KAAA8C,MAAAE,IAAA,sBAAAI,EAAAw5E,OAAA92E,OAEA1C,EAAAw5E,OAAAC,OACA78E,KAAAoD,QAAAw5E,OAAAC,KAAAz5E,EAAAw5E,OAAAC,KACA78E,KAAA8C,MAAAE,IAAA,sBAAAI,EAAAw5E,OAAAC,OAEAz5E,EAAAw5E,OAAAtuD,QACAtuB,KAAAoD,QAAAw5E,OAAAtuD,MAAAlrB,EAAAw5E,OAAAtuD,MACAtuB,KAAA8C,MAAAE,IAAA,uBAAAI,EAAAw5E,OAAAtuD,QAEAlrB,EAAAw5E,OAAA7qE,IACA/R,KAAAoD,QAAAw5E,OAAA7qE,EAAA3O,EAAAw5E,OAAA7qE,EACA/R,KAAA8C,MAAAE,IAAA,mBAAAI,EAAAw5E,OAAA7qE,IAGAytE,EAAAx/E,KAAAud,YAAA,YACAiiE,GACAx/E,KAAAyP,OAAA+vE,EAEA,IAAA5C,GAAA58E,KAAA47E,aAAA,WAAA57E,KAAA8C,MAAAuD,IAAA,WACAu2E,IACA58E,KAAA2G,IAAAi2E,GAEA58E,KAAAi8B,YASA53B,EAAAa,UAAAy5E,eAAA,SAAA5zE,GACA,GAAA80E,MACAjhD,EAAAj8B,EAAAgC,YAAAU,SAAA0F,EAAAA,KAAAA,EAAAgV,SACA,IAAAhV,GAAAA,EAAAuyE,QAAA,CACA,GAAAnqE,GAAApI,EAAAoI,QAAA,EACA2sE,EAAA3sE,CAIA,IAHAlP,EAAAiJ,QAAAiG,KACA2sE,GAAA3sE,EAAA,IAEA,SAAApI,EAAAuyE,QACAuC,GAAA7/E,KAAAu+E,cAAA,GAAA9sE,EAAAquE,EAAA,GAAA9/E,KAAAu+E,cAAA,GAAA5sE,EAAAmuE,EAAA,QACa,IAAA,OAAA/0E,EAAAuyE,QAAA,CACb,GAAAv6D,GAAAgJ,EAAAuvC,kBAAAt7D,KAAAu+E,cAAAv+E,KAAAu+E,cAAAp4E,OAAA,GAAAnG,KAAAu+E,cAAAv+E,KAAAu+E,cAAAp4E,OAAA,KACA2O,EAAAiX,EAAAuyC,SAAAv7C,EAAA,GAAAA,EAAA,IACA5c,EAAA4lB,EAAArH,SAAA3B,EAAA,GAAAA,EAAA,IAAA6b,EACAqiC,EAAAl1C,EAAAuxC,YAAAv6C,EAAA,GAAA5c,EAAA2O,EACA+qE,IAAA5e,EAAAxvD,EAAAquE,EAAA,GAAA7e,EAAAtvD,EAAAmuE,EAAA,QACa,CACb,GAAAC,GAAA//E,KAAA8iD,OAAA/3C,EACA80E,IAAAE,EAAA,GAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,SAES,CACT,GAAA70E,GAAAjL,KAAA8iD,OAAA/3C,EACA80E,IAAA50E,EAAA,GAAA2zB,EAAA,EAAA3zB,EAAA,IAGA,MAAA40E,IAQAx7E,EAAAa,UAAA45E,gBAAA,SAAAe,GAEA,GAAA98D,GAAAgJ,EAAAuvC,iBAAAt7D,KAAAu+E,eACAzpE,GAAAzB,KAAAqE,MAAAqL,EAAA,GAAApR,EAAAkuE,EAAA,GAAA98D,EAAA,GAAAtR,EAAAouE,EAAA,GACA,OAAA/qE,IAGAzQ,EAAAa,UAAAk6E,iBAAA,SAAA11D,GACA,GAAA1pB,KAAAoD,QAAAsI,WAAA,CACA/I,EAAA+nB,mBAAAhB,EAAA1pB,KAAAoD,QAAAsI,WAEA,IAAA8zE,GAAAx/E,KAAAud,YAAA,WACAiiE,IAA2B78E,EAAA+nB,mBAAA80D,EAAAx/E,KAAAoD,QAAA65E,iBAE3BvzD,EAAA3iB,GAAA,YAAA9C,EAAAuD,KAAA,WACA7E,EAAA4nB,aAAAb,GACA81D,GAAmC78E,EAAA4nB,aAAAi1D,GAEnCx/E,KAAA09E,WAAAv0E,UAAA,SAAAmD,GACA3J,EAAA4nB,aAAAje,MAEiBtM,OACjB+G,GAAA,WAAA9C,EAAAuD,KAAA,WACA7E,EAAA8nB,aAAAf,GACA81D,GAAmC78E,EAAA8nB,aAAA+0D,GACnCx/E,KAAA09E,WAAAv0E,UAAA,SAAAmD,GACA3J,EAAA8nB,aAAAne,MAEiBtM,SASjBqE,EAAAa,UAAAm6E,yBAAA,WACAr/E,KAAAggF,sBAAAhgF,KAAAA,KAAAu+E,cAAA,GAAAn4E,QAAAy3E,EAAAoC,gBACAjgF,KAAAggF,sBAAAhgF,KAAAA,KAAAu+E,cAAAv+E,KAAAu+E,cAAAp4E,OAAA,GAAAC,QAAAy3E,EAAAoC,iBAWA57E,EAAAa,UAAA86E,sBAAA,SAAA/4E,EAAAoK,EAAAvL,GACA,GAAAo6E,GAAA,GAAArC,GAAA79E,KAAAqR,EAAAvL,EAAA9F,KAAAoD,QACApD,MAAAy9E,eAAA92E,IAAAu5E,EAAAj5E,QAOA5C,EAAAa,UAAAi7E,aAAA,WACA,IAAA,GAAA9yE,GAAA,EAAuBA,EAAArN,KAAAw9E,QAAAr3E,OAAyBkH,IAChDrN,KAAAyP,OAAAzP,KAAAw9E,QAAAnwE,GAAA+yE,YAEApgF,MAAAw9E,WACAx9E,KAAAy9E,gBACAz9E,KAAAy9E,eAAA5qB,YAGA7yD,KAAAyN,UAAuB6gB,MAAAtuB,KAAAoD,QAAAyH,MAAAiH,SAAgC,IAOvDzN,EAAAa,UAAAo6E,eAAA,WACA,IAAA,GAAAjyE,GAAA,EAAuBA,EAAArN,KAAAu+E,cAAAp4E,OAAA,EAAmCkH,IAAA,CAC1D,GAAAs1B,GACAlxB,EAAAE,EAEA0uE,EAAAt0D,EAAAgyC,aAAA/9D,KAAAu+E,cAAAlxE,EAAA,GAAArN,KAAAu+E,cAAAlxE,GAAArN,KAAAu+E,cAAAlxE,EAAA,IACAizE,EAAAv0D,EAAAgyC,aAAA/9D,KAAAu+E,cAAAlxE,GAAArN,KAAAu+E,cAAAlxE,EAAA,GAAArN,KAAAu+E,cAAAlxE,EAAA,KACAgzE,GAAAC,IAAAtgF,KAAAu+E,cAAAlxE,EAAA,GAAAg0D,OAAArhE,KAAAu+E,cAAAlxE,EAAA,OAAAgzE,IAAArgF,KAAAu+E,cAAAlxE,EAAA,GAAAg0D,OAAArhE,KAAAu+E,cAAAlxE,KAAAizE,KAEAtgF,KAAAu+E,cAAAlxE,GAAAoE,IAAAzR,KAAAu+E,cAAAlxE,EAAA,GAAAoE,GACAA,EAAAzR,KAAAu+E,cAAAlxE,GAAAoE,EACAE,GAAA3R,KAAAu+E,cAAAlxE,GAAAsE,EAAA3R,KAAAu+E,cAAAlxE,EAAA,GAAAsE,GAAA,EAEAgxB,EAAA,GAAAg7C,GAAA,IAAAlsE,EAAAE,EAAA3R,OAGiBA,KAAAu+E,cAAAlxE,GAAAsE,IAAA3R,KAAAu+E,cAAAlxE,EAAA,GAAAsE,IACjBF,GAAAzR,KAAAu+E,cAAAlxE,GAAAoE,EAAAzR,KAAAu+E,cAAAlxE,EAAA,GAAAoE,GAAA,EACAE,EAAA3R,KAAAu+E,cAAAlxE,GAAAsE,EACAgxB,EAAA,GAAAg7C,GAAA,IAAAlsE,EAAAE,EAAA3R,OAEA2iC,IACA3iC,KAAA2G,IAAAg8B,EAAAy9C,aACApgF,KAAAw9E,QAAAh0E,KAAAm5B,OAcAt+B,EAAAa,UAAA02E,aAAA,SAAAvzE,EAAAjF,GACA,GAAAm9E,GAAAn9E,EAAAw5E,OAAA92E,KACA06E,EAAAp9E,EAAAw5E,OAAAC,IACA,IAAA,SAAA0D,EAAA,CAIAt8E,EAAAiJ,QAAAszE,KACAA,GAAAA,EAAAA,GAGA,IAAAC,GAAAr9E,EAAA2O,CAEA3O,GAAAw5E,OAAA7qE,IAA+B0uE,EAAAr9E,EAAAw5E,OAAA7qE,EAE/B,IAAA2uE,GAAAxG,EAAA0B,aACA2E,GAAAC,EAAA,GAAA,GAAAA,EAAA,GAAA,EACAA,EAAA,GAAAA,EAAA,GAAAC,EAAAr9E,EAAAw5E,OAAAtuD,MAIA,OAFAoyD,GAAAr4E,KAAAA,EAEAq4E,IAYAr8E,EAAAa,UAAAo3E,SAAA,SAAAj0E,EAAAuZ,EAAAnQ,EAAAE,EAAA2c,GACA,GAAAnkB,GAAAlG,EAAAsuB,SAAA3Q,IAA8C7W,KAAA6W,EAAAnQ,EAAAA,EAAAE,EAAAA,EAAAE,KAAAyc,GAC9CrqB,EAAAia,UAA8DzM,EAAAA,EAAAE,EAAAA,EAAAE,KAAAyc,GAAqB1M,GAAA,GAEnFwM,EAAAnqB,EAAAia,SAAAja,EAAAmC,MAAApG,KAAAoD,QAAA2H,MAAAZ,GAAA,GACAY,EAAA,GAAApI,GAAAqpB,MACAnhB,MAAAujB,EACA4O,OAAA,GACA30B,KAAAA,GAEA,QACA0C,KAAAA,EACAyH,KAAAzH,EAAAoE,oBAQA9K,EAAAa,UAAA49C,OAAA,WAEA,GAAA9iD,KAAAoD,QAAAyH,MAAA3C,UAAA7D,EAAAoM,eAAAzQ,KAAAoD,QAAAyH,MAAA3C,UAAA7D,EAAAkI,WAAA,CACA,GAAAwW,GAAAgJ,EAAAuvC,iBAAAt7D,KAAAu+E,eAcAoC,GAAA59D,EAAA,GAAAtR,EAAAsR,EAAA,GAAAtR,GAAA,EACAmvE,GAAA79D,EAAA,GAAApR,EAAAoR,EAAA,GAAApR,GAAA,CACA,QAAAgvE,EAAAC,GACS,GAAA5gF,KAAAoD,QAAAyH,MAAA3C,UAAA7D,EAAAqM,YAAA,CAQT,IAAA,GALAgU,GAAA1kB,KAAAq+D,YAGAztD,KACAiwE,EAAA,EACAxzE,EAAA,EAA2BA,EAAArN,KAAAu+E,cAAAp4E,OAAA,EAAmCkH,IAAA,CAC9DuD,EAAAvD,CACA,IAAAyzE,GAAA/0D,EAAAsyC,UAAAr+D,KAAAu+E,cAAAlxE,GAAArN,KAAAu+E,cAAAlxE,EAAA,GACA,MAAAwzE,EAAAC,EAAAp8D,EAAA,GAGA,KAFAm8D,IAAAC,EAOA,GAAAlwE,MAAA,CACA,GAAAmwE,GAAAr8D,EAAA,EAAAm8D,CACA,IAAA90D,EAAA9W,MAAAjV,KAAAu+E,cAAA3tE,GAAAa,EAAA,IAAAsa,EAAA9W,MAAAjV,KAAAu+E,cAAA3tE,EAAA,GAAAa,EAAA,GACA,OAAAzR,KAAAu+E,cAAA3tE,GAAAa,EAAA4B,KAAA4Q,IAAAjkB,KAAAu+E,cAAA3tE,GAAAe,EAAA3R,KAAAu+E,cAAA3tE,EAAA,GAAAe,GAAAovE,EACiB,IAAAh1D,EAAA9W,MAAAjV,KAAAu+E,cAAA3tE,GAAAe,EAAA,IAAAoa,EAAA9W,MAAAjV,KAAAu+E,cAAA3tE,EAAA,GAAAe,EAAA,GACjB,OAAA0B,KAAA4Q,IAAAjkB,KAAAu+E,cAAA3tE,GAAAa,EAAAzR,KAAAu+E,cAAA3tE,EAAA,GAAAa,GAAAsvE,EAAA/gF,KAAAu+E,cAAA3tE,GAAAe,EAEA6sC,SAAAwiC,MAAA,iDAAAhhF,KAAAu+E,cAAA3tE,GAAA,IAAA5Q,KAAAu+E,cAAA3tE,EAAA,GAAA,iBAAA5Q,KAAAu+E,cAAAp4E,aAIS,IAAAnG,KAAAoD,QAAAyH,MAAA3C,UAAA7D,EAAAsM,WAAA,CAKT,IAAA,GAJA01B,GAAA,GACAvD,EAAA9iC,KAAAq+D,YAEA4iB,EAAA,EACAtjE,EAAA,EAA2BA,EAAA3d,KAAAu+E,cAAAp4E,OAAA,KAC3B86E,EAAAl1D,EAAArH,SAAA1kB,KAAAu+E,cAAA5gE,GAAA3d,KAAAu+E,cAAA5gE,EAAA,IAAAmlB,EAAAuD,GAD8D1oB,IAK9DsjE,GAAAl1D,EAAArH,SAAA1kB,KAAAu+E,cAAA5gE,GAAA3d,KAAAu+E,cAAA5gE,EAAA,GAGA,IAAAujE,GAAAp+C,EAAAuD,EAAA46C,EACAE,EAAAp1D,EAAArH,SAAA1kB,KAAAu+E,cAAA5gE,GAAA3d,KAAAu+E,cAAA5gE,EAAA,IAGAyjE,EAAAF,EAAAC,EAEAjf,EAAAkf,GAAAphF,KAAAu+E,cAAA5gE,EAAA,GAAAlM,EAAAzR,KAAAu+E,cAAA5gE,GAAAlM,GAAAzR,KAAAu+E,cAAA5gE,GAAAlM,EACA0wD,EAAAif,GAAAphF,KAAAu+E,cAAA5gE,EAAA,GAAAhM,EAAA3R,KAAAu+E,cAAA5gE,GAAAhM,GAAA3R,KAAAu+E,cAAA5gE,GAAAhM,CAEA,QAAAuwD,EAAAC,GAIA,MAAA,OAOA99D,EAAAa,UAAAm5D,UAAA,WAGA,IAAA,GADA35C,GAAA,EACArX,EAAA,EAAuBA,EAAArN,KAAAu+E,cAAAp4E,OAAA,EAAmCkH,IAC1DqX,GAAAqH,EAAAsyC,UAAAr+D,KAAAu+E,cAAAlxE,GAAArN,KAAAu+E,cAAAlxE,EAAA,GAEA,OAAAqX,IAOArgB,EAAAa,UAAAw3E,OAAA,WAeA,MAbA18E,MAAA8C,MAAAE,IAAA,aAAAhD,KAAAq8E,YACAr8E,KAAA8C,MAAAE,IAAA,kBAAA,IAEAhD,KAAA8C,MAAAE,IAAA,qBAAAhD,KAAAiL,SAAA,IACAjL,KAAA8C,MAAAE,IAAA,qBAAAhD,KAAAiL,SAAA,IACAjL,KAAA8C,MAAAE,IAAA,sBAAAmW,SAAAnZ,KAAAiL,SAAA,GAAAjL,KAAAmP,kBAAAF,QACAjP,KAAA8C,MAAAE,IAAA,sBAAAmW,SAAAnZ,KAAAiL,SAAA,GAAAjL,KAAAmP,kBAAAD,SACAlP,KAAA8C,MAAAE,IAAA,aAAAhD,KAAAoD,QAAA6H,SAAAwI,UACAzT,KAAA8C,MAAAE,IAAA,aAAAhD,KAAAoD,QAAA6H,SAAAmI,QACApT,KAAA8C,MAAAE,IAAA,iBAAAhD,KAAAoD,QAAAyH,MAAAuU,UACApf,KAAA8C,MAAAE,IAAA,eAAAhD,KAAAoD,QAAAyH,MAAAiH,QACA9R,KAAA8C,MAAAE,IAAA,cAAAhD,KAAAoD,QAAAw5E,OAAA92E,MACA9F,KAAA8C,MAAAE,IAAA,UAAAhD,KAAAu+E,eACAv+E,KAAA8C,MAAAiD,QAOA1B,EAAAa,UAAAm8E,aAAA,WACArhF,KAAA8C,MAAAE,IAAA,UAAAiB,EAAAmC,MAAApG,KAAAoD,UACApD,KAAA8C,MAAAE,IAAA,kBAAAhD,KAAAu+E,cAEA,KAAA,GADAptE,MACA9D,EAAA,EAAuBA,EAAArN,KAAAmR,MAAAhL,OAAuBkH,IAAA,CAC9C,GAAAi0E,GAAAthF,KAAAmR,MAAA9D,GACAtH,GAAAu7E,EAAAt7E,KACAi0E,KAAAqH,EAAAz2E,MAAAC,MACAmE,MAAAqyE,EAAAz2E,MAAAoE,MACAC,OAAAoyE,EAAAz2E,MAAAqE,QAEAiC,GAAA3H,KAAAzD,GAEA/F,KAAA8C,MAAAE,IAAA,QAAAmO,IAQA9M,EAAAa,UAAAs5E,YAAA,SAAAz7D,GAKA,IAAA,GAJAw+D,GAAAvhF,KAAAwhF,cAAAz+D,GAGA0+D,KACA9jE,EAAA4jE,EAAAp7E,OAAAu7E,EAAA1hF,KAAA09E,WAAAtrB,aAAyEz0C,EAAA+jE,EAAc/jE,IACvF8jE,EAAAj4E,KAAAxJ,KAAA09E,WAAAvrB,QAAAx0C,GAEA1Z,GAAA4E,KAAA44E,EAAA,SAAAp5B,GACAroD,KAAA09E,WAAAjuE,OAAA44C,IACSroD,KAET,KAAA,GAAAqN,GAAA,EAAuBA,EAAAk0E,EAAAp7E,OAAgBkH,IAAA,CACvC,GAAAf,GAAAtM,KAAA09E,WAAAvrB,QAAA9kD,EACA,IAAAf,EACAA,EAAAkC,KAAA,QAAA+yE,EAAAl0E,QACa,CACb,GAAAs0E,GAAA,GAAAh/E,GAAAypB,aAEAvhB,MAAA7K,KAAAoD,QAAAyH,MACA5D,MAAAs6E,EAAAl0E,GACA0E,EAAA/R,KAAAoD,QAAA2O,GAEA/R,MAAA09E,WAAA/2E,IAAAg7E,GACA3hF,KAAAo/E,iBAAAuC,MAWAt9E,EAAAa,UAAAs8E,cAAA,SAAAI,GAiCA,QAAAprB,GAAAxuB,EAAAe,GACA,MAAA,IAAA/kC,GAAAgkC,EAAAv2B,EAAAs3B,EAAAt3B,EAAAu2B,EAAAr2B,EAAAo3B,EAAAp3B,GASA,QAAAkwE,GAAAnhF,EAAAohF,GACA,GAAA,GAAAA,EACA,KAAA,wCAAA9hF,KAAA+hF,MAEA,OAAA,IAAA/9E,GAAAtD,EAAA+Q,EAAAqwE,EAAAphF,EAAAiR,EAAAmwE,GAQA,QAAAE,GAAAthF,EAAAohF,GACA,MAAA,IAAA99E,GAAAtD,EAAA+Q,EAAAqwE,EAAAphF,EAAAiR,EAAAmwE,GAvDA,GAAA9sE,GAAA4sE,EAAAz7E,OACAo7E,IACA,IAAA,IAAAvsE,EASA,MARAusE,GAAA/3E,MACAkM,GAAAksE,EAAA,GAAAnwE,EACAkE,GAAAisE,EAAA,GAAAjwE,EACAqlD,KAAA4qB,EAAA,GAAAnwE,EACAwlD,KAAA2qB,EAAA,GAAAjwE,EACAiE,GAAAgsE,EAAA,GAAAnwE,EACAoE,GAAA+rE,EAAA,GAAAjwE,IAEA4vE,CACS,IAAA,IAAAvsE,EAWT,MAVAusE,GAAA/3E,MACAkM,GAAAksE,EAAA,GAAAnwE,EACAkE,GAAAisE,EAAA,GAAAjwE,EACAqlD,KAAA4qB,EAAA,GAAAnwE,EACAwlD,KAAA2qB,EAAA,GAAAjwE,EACAmlD,KAAA8qB,EAAA,GAAAnwE,EACAslD,KAAA6qB,EAAA,GAAAjwE,EACAiE,GAAAgsE,EAAA,GAAAnwE,EACAoE,GAAA+rE,EAAA,GAAAjwE,IAEA4vE,CA0CA,IAEA5jE,GAFAywB,GAAA,EAAA,EAAA,EAGA,KAAAzwB,EAAA,EAAmBA,GAAA3I,EAAA,EAAY2I,IAC/BywB,EAAA5kC,KAAAmU,EAGAywB,GAAA5kC,KAAAwL,EAAA,EAAAA,EAAA,EAIA,KAAA,GAAA3H,GAAA,EAAuBA,GAAA2H,EAAA,EAAY3H,IAAA,CAEnC,GAAA40E,GAAAJ,EAAArrB,EAAAwrB,EAAAJ,EAAAv0E,GAAA+gC,EAAA/gC,EAAA,GAAA+gC,EAAA/gC,EAAA,IAAA20E,EAAAJ,EAAAv0E,EAAA,GAAA+gC,EAAA/gC,EAAA,GAAA+gC,EAAA/gC,EAAA,KAAA+gC,EAAA/gC,EAAA,GAAA+gC,EAAA/gC,EAAA,IAGA60E,GAAA9zC,EAAA/gC,EAAA,GAAA+gC,EAAA/gC,EAAA,KAAA+gC,EAAA/gC,EAAA,GAAA+gC,EAAA/gC,EAAA,IACA80E,EAAAN,EAAArrB,EAAAwrB,EAAAJ,EAAAv0E,EAAA,GAAA+gC,EAAA/gC,EAAA,GAAA+gC,EAAA/gC,EAAA,IAAA20E,EAAAJ,EAAAv0E,GAAA+gC,EAAA/gC,EAAA,GAAA+gC,EAAA/gC,KAAA+gC,EAAA/gC,EAAA,GAAA+gC,EAAA/gC,IACA+0E,EAAAJ,EAAAC,GAAA7zC,EAAA/gC,EAAA,GAAA+gC,EAAA/gC,EAAA,KAAA+gC,EAAA/gC,EAAA,GAAA+gC,EAAA/gC,EAAA,KACAg1E,EAAA7rB,EAAAwrB,EAAAG,EAAAD,GAAAE,GAGAE,EAAAT,EAAArrB,EAAAwrB,EAAAJ,EAAAv0E,GAAA+gC,EAAA/gC,EAAA,GAAA+gC,EAAA/gC,EAAA,IAAA20E,EAAAJ,EAAAv0E,EAAA,GAAA+gC,EAAA/gC,EAAA,GAAA+gC,EAAA/gC,EAAA,KAAA+gC,EAAA/gC,EAAA,GAAA+gC,EAAA/gC,EAAA,IAGAk1E,GAAAn0C,EAAA/gC,EAAA,GAAA+gC,EAAA/gC,EAAA,KAAA+gC,EAAA/gC,EAAA,GAAA+gC,EAAA/gC,EAAA,IACAm1E,EAAAX,EAAArrB,EAAAwrB,EAAAJ,EAAAv0E,EAAA,GAAA+gC,EAAA/gC,EAAA,GAAA+gC,EAAA/gC,EAAA,IAAA20E,EAAAJ,EAAAv0E,EAAA,GAAA+gC,EAAA/gC,EAAA,GAAA+gC,EAAA/gC,EAAA,KAAA+gC,EAAA/gC,EAAA,GAAA+gC,EAAA/gC,EAAA,IACAo1E,EAAAT,EAAAM,GAAAl0C,EAAA/gC,EAAA,GAAA+gC,EAAA/gC,EAAA,KAAA+gC,EAAA/gC,EAAA,GAAA+gC,EAAA/gC,EAAA,KACAq1E,EAAAlsB,EAAAwrB,EAAAQ,EAAAD,GAAAE,EAIAlB,GAAA/3E,MACAkM,GAAA2sE,EAAA5wE,EACAkE,GAAA0sE,EAAA1wE,EACAqlD,KAAAirB,EAAAxwE,EACAwlD,KAAAgrB,EAAAtwE,EACAmlD,KAAAwrB,EAAA7wE,EACAslD,KAAAurB,EAAA3wE,EACAiE,GAAA8sE,EAAAjxE,EACAoE,GAAA6sE,EAAA/wE,IAIA,MAAA4vE,IAIAx1D,EAAAoB,SAAA9oB,EAAA21E,GAEAn6E,EAAAD,QAAAyE,GnF2+oBM,SAAUxE,EAAQD,EAASM,GoFr4qBjC,YAIA,IAAAyC,GAAAzC,EAAA,GACAssB,EAAAtsB,EAAA,IAKAyiF,EAAAhgF,EAAA+pB,aACA5mB,KAAA,WACAmB,OACAuK,GAAA,EACAE,GAAA,EACAzC,MAAA,EACAC,OAAA,GAEA+oB,UAAA,SAAAlL,EAAA9lB,GACA,GAAAuK,GAAAvK,EAAAuK,GACAE,EAAAzK,EAAAyK,GACAzC,EAAAhI,EAAAgI,MAAA,EACAC,EAAAjI,EAAAiI,OAAA,CACA6d,GAAAm7B,OAAA12C,EAAAE,EAAAxC,GACA6d,EAAAo7B,OAAA32C,EAAAvC,EAAAyC,EAAAxC,GACA6d,EAAAo7B,OAAA32C,EAAAvC,EAAAyC,EAAAxC,GACA6d,EAAAo1B,eAOAygC,EAAAjgF,EAAA+pB,aACA5mB,KAAA,UACAmB,OACAuK,GAAA,EACAE,GAAA,EACAzC,MAAA,EACAC,OAAA,GAEA+oB,UAAA,SAAAlL,EAAA9lB,GACA,GAAAuK,GAAAvK,EAAAuK,GACAE,EAAAzK,EAAAyK,GACAzC,EAAAhI,EAAAgI,MAAA,EACAC,EAAAjI,EAAAiI,OAAA,CACA6d,GAAAm7B,OAAA12C,EAAAE,EAAAxC,GACA6d,EAAAo7B,OAAA32C,EAAAvC,EAAAyC,GACAqb,EAAAo7B,OAAA32C,EAAAE,EAAAxC,GACA6d,EAAAo7B,OAAA32C,EAAAvC,EAAAyC,GACAqb,EAAAo1B,eAQA0gC,EAAAlgF,EAAA+pB,aACA5mB,KAAA,MACAmB,OAEAwK,EAAA,EACAE,EAAA,EACA1C,MAAA,EACAC,OAAA,GAGA+oB,UAAA,SAAAlL,EAAA9lB,GACA,GAAAwK,GAAAxK,EAAAwK,EACAE,EAAA1K,EAAA0K,EACA4pB,EAAAt0B,EAAAgI,MAAA,EAAA,EAEA0zB,EAAAtvB,KAAA6Q,IAAAqX,EAAAt0B,EAAAiI,QACA0C,EAAA2pB,EAAA,EAGA+F,EAAA1vB,EAAAA,GAAA+wB,EAAA/wB,GACAF,EAAAC,EAAAgxB,EAAA/wB,EAAA0vB,EACAxsB,EAAAzB,KAAAs8B,KAAArO,EAAA1vB,GAEAyvB,EAAAhuB,KAAA0lB,IAAAjkB,GAAAlD,EAEAkxE,EAAAzvE,KAAAylB,IAAAhkB,GACAiuE,EAAA1vE,KAAA0lB,IAAAjkB,EAEAiY,GAAAg9B,IACAt4C,EAAAC,EAAAE,EACAyB,KAAA0B,GAAAD,EACA,EAAAzB,KAAA0B,GAAAD,EAGA,IAAAkuE,GAAA,GAAApxE,EACAqxE,EAAA,GAAArxE,CACAmb,GAAA28B,cACAj4C,EAAA4vB,EAAAyhD,EAAAE,EAAAtxE,EAAA4vB,EAAAyhD,EAAAC,EACAvxE,EAAAE,EAAAsxE,EACAxxE,EAAAE,GAEAob,EAAA28B,cACAj4C,EAAAE,EAAAsxE,EACAxxE,EAAA4vB,EAAAyhD,EAAAE,EAAAtxE,EAAA4vB,EAAAyhD,EAAAC,EACAvxE,EAAA4vB,EAAA3vB,EAAA4vB,GAEAvU,EAAAo1B,eAQA+gC,EAAAvgF,EAAA+pB,aAEA5mB,KAAA,QAEAmB,OACAwK,EAAA,EACAE,EAAA,EACA1C,MAAA,EACAC,OAAA,GAGA+oB,UAAA,SAAAE,EAAAlxB,GACA,GAAAiI,GAAAjI,EAAAiI,OACAD,EAAAhI,EAAAgI,MACAwC,EAAAxK,EAAAwK,EACAE,EAAA1K,EAAA0K,EACA0vB,EAAApyB,EAAA,EAAA,CACAkpB,GAAA+vB,OAAAz2C,EAAAE,GACAwmB,EAAAgwB,OAAA12C,EAAA4vB,EAAA1vB,EAAAzC,GACAipB,EAAAgwB,OAAA12C,EAAAE,EAAAzC,EAAA,EAAA,GACAipB,EAAAgwB,OAAA12C,EAAA4vB,EAAA1vB,EAAAzC,GACAipB,EAAAgwB,OAAA12C,EAAAE,GACAwmB,EAAAgqB,eAQAghC,GACA72E,KAAA3J,EAAA8S,KAEAjD,KAAA7P,EAAA2S,KAEA8tE,UAAAzgF,EAAA2S,KAEA+tE,OAAA1gF,EAAA2S,KAEAguE,OAAA3gF,EAAAyF,OAEAm7E,QAAAX,EAEAY,IAAAX,EAEArvE,MAAA0vE,EAEAO,SAAAd,GAGAe,GAEAp3E,KAAA,SAAAmF,EAAAE,EAAA4pB,EAAAoH,EAAA17B,GAEAA,EAAAyO,GAAAjE,EACAxK,EAAA0O,GAAAhE,EAAAgxB,EAAA,EACA17B,EAAA2O,GAAAnE,EAAA8pB,EACAt0B,EAAA4O,GAAAlE,EAAAgxB,EAAA,GAGAnwB,KAAA,SAAAf,EAAAE,EAAA4pB,EAAAoH,EAAA17B,GACAA,EAAAwK,EAAAA,EACAxK,EAAA0K,EAAAA,EACA1K,EAAAgI,MAAAssB,EACAt0B,EAAAiI,OAAAyzB,GAGAygD,UAAA,SAAA3xE,EAAAE,EAAA4pB,EAAAoH,EAAA17B,GACAA,EAAAwK,EAAAA,EACAxK,EAAA0K,EAAAA,EACA1K,EAAAgI,MAAAssB,EACAt0B,EAAAiI,OAAAyzB,EACA17B,EAAA2K,EAAAyB,KAAA4Q,IAAAsX,EAAAoH,GAAA,GAGA0gD,OAAA,SAAA5xE,EAAAE,EAAA4pB,EAAAoH,EAAA17B,GACA,GAAA41E,GAAAxpE,KAAA4Q,IAAAsX,EAAAoH,EACA17B,GAAAwK,EAAAA,EACAxK,EAAA0K,EAAAA,EACA1K,EAAAgI,MAAA4tE,EACA51E,EAAAiI,OAAA2tE,GAGAyG,OAAA,SAAA7xE,EAAAE,EAAA4pB,EAAAoH,EAAA17B,GAEAA,EAAAuK,GAAAC,EAAA8pB,EAAA,EACAt0B,EAAAyK,GAAAC,EAAAgxB,EAAA,EACA17B,EAAA2K,EAAAyB,KAAA4Q,IAAAsX,EAAAoH,GAAA,GAGA4gD,QAAA,SAAA9xE,EAAAE,EAAA4pB,EAAAoH,EAAA17B,GACAA,EAAAuK,GAAAC,EAAA8pB,EAAA,EACAt0B,EAAAyK,GAAAC,EAAAgxB,EAAA,EACA17B,EAAAgI,MAAAssB,EACAt0B,EAAAiI,OAAAyzB,GAGA6gD,IAAA,SAAA/xE,EAAAE,EAAA4pB,EAAAoH,EAAA17B,GACAA,EAAAwK,EAAAA,EAAA8pB,EAAA,EACAt0B,EAAA0K,EAAAA,EAAAgxB,EAAA,EACA17B,EAAAgI,MAAAssB,EACAt0B,EAAAiI,OAAAyzB,GAGAnvB,MAAA,SAAA/B,EAAAE,EAAA4pB,EAAAoH,EAAA17B,GACAA,EAAAwK,EAAAA,EAAA8pB,EAAA,EACAt0B,EAAA0K,EAAAA,EAAAgxB,EAAA,EACA17B,EAAAgI,MAAAssB,EACAt0B,EAAAiI,OAAAyzB,GAGA8gD,SAAA,SAAAhyE,EAAAE,EAAA4pB,EAAAoH,EAAA17B,GACAA,EAAAuK,GAAAC,EAAA8pB,EAAA,EACAt0B,EAAAyK,GAAAC,EAAAgxB,EAAA,EACA17B,EAAAgI,MAAAssB,EACAt0B,EAAAiI,OAAAyzB,IAIAghD,IACA,KAAA,GAAAt7E,KAAA86E,GACAQ,EAAAt7E,GAAA,GAAA86E,GAAA96E,EAGA,IAAAu7E,GAAAjhF,EAAA+pB,aAEA5mB,KAAA,SAEAmB,OACAs5E,WAAA,GACA9uE,EAAA,EACAE,EAAA,EACA1C,MAAA,EACAC,OAAA,GAGAouB,YAAA,WACA,GAAAzyB,GAAA7K,KAAA6K,MACA5D,EAAAjH,KAAAiH,KAEA,SAAAA,EAAAs5E,YAAA,WAAA11E,EAAAG,eACAH,EAAAG,cAAA,MAAA,OACAH,EAAAsW,UAAA,SACAtW,EAAAo0B,kBAAA,WAIAhH,UAAA,SAAAE,EAAAlxB,GACA,GAAAs5E,GAAAt5E,EAAAs5E,WACAsD,EAAAF,EAAApD,EACA,UAAAt5E,EAAAs5E,aACAsD,IAEAtD,EAAA,OACAsD,EAAAF,EAAApD,IAEAmD,EAAAnD,GACAt5E,EAAAwK,EAAAxK,EAAA0K,EAAA1K,EAAAgI,MAAAhI,EAAAiI,OAAA20E,EAAA58E,OAEA48E,EAAA5rD,UAAAE,EAAA0rD,EAAA58E,WAMA68E,EAAA,SAAAx1D,GACA,GAAA,UAAAtuB,KAAA8F,KAAA,CACA,GAAAi+E,GAAA/jF,KAAA6K,MACAm5E,EAAAhkF,KAAAiH,KACA+8E,IAAA,SAAAA,EAAAzD,WACAwD,EAAAjyE,OAAAwc,EAEAtuB,KAAAikF,gBACAF,EAAAjyE,OAAAwc,EACAy1D,EAAAlyE,KAAA,SAIAkyE,EAAAlyE,OAAAkyE,EAAAlyE,KAAAyc,GACAy1D,EAAAjyE,SAAAiyE,EAAAjyE,OAAAwc,IAEAtuB,KAAAs4B,UAIA4hD,GAWA0B,aAAA,SAAA2E,EAAA9uE,EAAAE,EAAA4pB,EAAAoH,EAAA5wB,EAAAuc,GACA,GAAAqxC,GAAA,IAAA4gB,EAAA1vE,QAAA,QACA8uD,KACA4gB,EAAAA,EAAAliE,OAAA,EAAA,GAAAgzB,cAAAkvC,EAAAliE,OAAA,GAEA,IAAAqiE,EAoCA,OAjCAA,GADA,IAAAH,EAAA1vE,QAAA,YACA,GAAAlO,GAAAiI,OACAC,OACAC,MAAAy1E,EAAA33D,MAAA,GACAnX,EAAAA,EACAE,EAAAA,EACA1C,MAAAssB,EACArsB,OAAAyzB,GAEA5wB,EAAAA,IAGA,IAAAwuE,EAAA1vE,QAAA,WACAlO,EAAAmqB,SAAAyzD,EAAA33D,MAAA,IAAoE7W,EAAAA,EAAAqrB,WAAA,GAAsB,GAAA5Q,GAAA/a,EAAAE,EAAA4pB,EAAAoH,IAG1F,GAAAihD,IACA38E,OACAs5E,WAAAA,EACA9uE,EAAAA,EACAE,EAAAA,EACA1C,MAAAssB,EACArsB,OAAAyzB,GAEA5wB,EAAAA,IAIA2uE,EAAAuD,eAAAtkB,EAEA+gB,EAAAwD,SAAAJ,EAEApD,EAAAwD,SAAA51D,GAEAoyD,GAIA7gF,GAAAD,QAAAs6E,GpF64qBM,SAAUr6E,EAAQD,EAASM,GqFvurBjC,QAAAy9E,GAAA73E,EAAA2L,EAAAE,EAAAvK,GACApH,KAAA8F,KAAAA,EAEA9F,KAAAyR,EAAAA,EAEAzR,KAAA2R,EAAAA,EAEA3R,KAAAmkF,SAAA,EAEAnkF,KAAAoH,UAAAA,EAEApH,KAAAogF,YAAA,GAAAz9E,GAAAyF,QACAnB,OACAuK,GAAAC,EACAC,GAAAC,EACAC,EAAA+rE,EAAAG,QAGAjzE,OACAgH,KAAA,eACAC,OAAA,cAEAC,EAAA3K,EAAAhE,QAAA2O,EAAA,EACAC,WAAA,GAGA,IAAA9I,GAAAlJ,IACAA,MAAAogF,YAAAr5E,GAAA,OAAA,SAAAC,GACAkC,EAAAk7E,gBAAAp9E,EAAAuB,QAAAvB,EAAAwB,WA9BA,GAAA7F,GAAAzC,EAAA,GACA6rB,EAAA7rB,EAAA,GAkCAy9E,GAAAG,OAAA,EAEAH,EAAAz4E,WAEAqrB,YAAAotD,EAEAtc,OAAA,SAAAgjB,GACA,SAAAA,YAAA1G,MAIA39E,KAAA8F,MAAAu+E,EAAAv+E,MACA9F,KAAAyR,GAAA4yE,EAAA5yE,GACAzR,KAAA2R,GAAA0yE,EAAA1yE,GACA3R,KAAAmkF,SAAAE,EAAAF,UASAC,gBAAA,SAAAE,EAAAC,GACA,OAAAvkF,KAAA8F,MACA,IAAA,IAGA,IAAA,GAFA8K,GAEAvD,EAAA,EAAkCA,EAAArN,KAAAoH,UAAAm3E,cAAAp4E,OAAA,EAA2CkH,IAC7ErN,KAAAoH,UAAAm3E,cAAAlxE,EAAA,GAAAsE,GAAA3R,KAAAoH,UAAAm3E,cAAAlxE,GAAAsE,GACA3R,KAAAoH,UAAAm3E,cAAAlxE,GAAAsE,GAAA3R,KAAA2R,GACA0B,KAAA4Q,IAAAjkB,KAAAoH,UAAAm3E,cAAAlxE,GAAAoE,EAAAzR,KAAAoH,UAAAm3E,cAAAlxE,EAAA,GAAAoE,IAAAzR,KAAAyR,GACA4B,KAAA6Q,IAAAlkB,KAAAoH,UAAAm3E,cAAAlxE,GAAAoE,EAAAzR,KAAAoH,UAAAm3E,cAAAlxE,EAAA,GAAAoE,IAAAzR,KAAAyR,IAEAb,EAAAvD,EAGA,IAAAm3E,GAAAD,EAAAvkF,KAAA2R,EACAyrD,EAAArxC,EAAAqxC,kBAAA,EAAAonB,EAEAxkF,MAAAoH,UAAAm3E,cAAA3tE,EAAA,GAAA4e,UAAA4tC,GACAp9D,KAAAoH,UAAAm3E,cAAA3tE,GAAA4e,UAAA4tC,GACAp9D,KAAAoH,UAAA60B,UACAj8B,KAAA2R,EAAA4yE,CAEA,MAEA,KAAA,IAGA,IAAA,GAFA3zE,GAEAvD,EAAA,EAAkCA,EAAArN,KAAAoH,UAAAm3E,cAAAp4E,OAAA,EAA2CkH,IAC7ErN,KAAAoH,UAAAm3E,cAAAlxE,EAAA,GAAAoE,GAAAzR,KAAAoH,UAAAm3E,cAAAlxE,GAAAoE,GACAzR,KAAAoH,UAAAm3E,cAAAlxE,GAAAoE,GAAAzR,KAAAyR,GACA4B,KAAA4Q,IAAAjkB,KAAAoH,UAAAm3E,cAAAlxE,GAAAsE,EAAA3R,KAAAoH,UAAAm3E,cAAAlxE,EAAA,GAAAsE,IAAA3R,KAAA2R,GACA0B,KAAA6Q,IAAAlkB,KAAAoH,UAAAm3E,cAAAlxE,GAAAsE,EAAA3R,KAAAoH,UAAAm3E,cAAAlxE,EAAA,GAAAsE,IAAA3R,KAAA2R,IAEAf,EAAAvD,EAGA,IAAAo3E,GAAAH,EAAAtkF,KAAAyR,EACA2rD,EAAArxC,EAAAqxC,kBAAAqnB,EAAA,EACAzkF,MAAAoH,UAAAm3E,cAAA3tE,EAAA,GAAA4e,UAAA4tC,GACAp9D,KAAAoH,UAAAm3E,cAAA3tE,GAAA4e,UAAA4tC,GACAp9D,KAAAoH,UAAA60B,UACAj8B,KAAAyR,EAAA6yE,KAOAzkF,EAAAD,QAAA+9E,GrFwvrBM,SAAU99E,EAAQD,EAASM,GsF71rBjC,QAAA09E,GAAAhB,EAAAx5E,EAAAs6E,EAAAyB,GACAn/E,KAAA0kF,WAAA,EACA1kF,KAAA2kF,kBAAA,EACA3kF,KAAA48E,OAAAA,EACA58E,KAAA09E,WAAAA,EACA19E,KAAA4kF,WAAAxhF,EAAA+7E,GAVA,GACAr5B,IADA5lD,EAAA,GACAA,EAAA,KACA2kF,EAAA3kF,EAAA,IAUA4kF,GATA5kF,EAAA,IASA09E,EAAA14E,UAEA4/E,GAAAF,WAAA,SAAAxhF,EAAA+7E,GACA,GAAAj2E,GAAAlJ,IACAA,MAAA48E,OAAAxyD,GAAA,IACApqB,KAAA48E,OAAAz/C,SAAA,CACA,IAAA4nD,GAAA,IAAA3hF,EAAAs8E,OAAAqF,MAGA,IAFA/kF,KAAA48E,OAAAoI,IAAA,EACAhlF,KAAA48E,OAAA31C,gBACA,SAAA7jC,EAAAyH,MAAA3C,UACA,GAAAlI,KAAA09E,WAAA,CACA,GAAArwE,GAAA,CACA03E,IAAA/kF,KAAA09E,WAAA1rB,UAAA7rD,OACAnG,KAAAilF,kBAAAjlF,KAAA09E,WAAA1rB,UAAA,GAAA3kD,EAAA03E,QAIA/kF,MAAA48E,OAAAvgD,QAAA,IAAA,GACAsL,KAAAo9C,GACAC,IAAA,IAEA59C,MAAA,GACAL,OAAA,WACA79B,EAAAg8E,iCAEAzwE,QACAzU,KAAAmlF,2BAAAhG,EAAAl4E,MAAA8b,SAKA+hE,EAAAG,kBAAA,SAAA/F,EAAA7xE,EAAA03E,GACA,GAAA77E,GAAAlJ,IACA6Z,SAAAqlE,IACAA,EAAAl/E,KAAA09E,WAAA1rB,UAAA,GACA3kD,EAAA,EAEA,IAAA0V,GACA9V,EAAAiyE,EAAAj4E,KACA8b,KACA9V,EAAAyI,GAAAzI,EAAA0I,KACA1I,EAAA2I,GAAA3I,EAAA4I,KACA5I,EAAA+pD,KAAA/pD,EAAAgqD,OACAhqD,EAAA6pD,KAAA7pD,EAAA8pD,OAEA/2D,KAAAolF,8BAAAriE,GACA/iB,KAAA48E,OAAAvgD,QAAA,IACAsL,KAAAo9C,GACAC,IAAA,IAEA59C,MAAA,GACAL,OAAA,WACA79B,EAAAm8E,oCAEAr+C,KAAA,WACA99B,EAAA0zE,OAAAoI,IAAA,EACA97E,EAAA+7E,kBAAA/7E,EAAAw0E,WAAA1rB,UAAA3kD,EAAA,GAAAA,EAAA,EAAA03E,KAEAtwE,SAKAqwE,EAAAM,8BAAA,SAAAriE,GACA/iB,KAAA48E,OAAA0I,KAAAviE,EAAA,GACA/iB,KAAA48E,OAAA2I,KAAAxiE,EAAA,GACA/iB,KAAA48E,OAAA4I,MAAAziE,EAAA,MACAA,EAAA,GAAA,GAAAA,EAAA,GAAA,IAAA,GACAA,EAAA,GAAA,GAAAA,EAAA,GAAA,IAAA,GAEA/iB,KAAA48E,OAAA6I,MAAA1iE,EAAA,IAGA+hE,EAAAO,gCAAA,WACA,GAMAp2B,GAAAC,EANAlnB,EAAAhoC,KAAA48E,OAAA0I,KACAv8C,EAAA/oC,KAAA48E,OAAA2I,KACAlwB,EAAAr1D,KAAA48E,OAAA4I,MACAlwB,EAAAt1D,KAAA48E,OAAA6I,MACAp/C,EAAArmC,KAAA48E,OAAAoI,IACA/3E,EAAAjN,KAAA48E,OAAA3xE,QAEA,IAAA4O,QAAAy7C,EAAA,GAAA,CACA,GAAArK,GAAA45B,EAAA55B,QACAiB,EAAA24B,EAAA34B,iBACAj/C,GAAA,GAAAg+C,EAAAjjB,EAAA,GAAAqtB,EAAA,GAAAC,EAAA,GAAAvsB,EAAA,GAAA1C,GACAp5B,EAAA,GAAAg+C,EAAAjjB,EAAA,GAAAqtB,EAAA,GAAAC,EAAA,GAAAvsB,EAAA,GAAA1C,GAEA4oB,EAAA/C,EAAAlkB,EAAA,GAAAqtB,EAAA,GAAAC,EAAA,GAAAvsB,EAAA,GAAA1C,GACA6oB,EAAAhD,EAAAlkB,EAAA,GAAAqtB,EAAA,GAAAC,EAAA,GAAAvsB,EAAA,GAAA1C,OACS,CACT,GAAAgoB,GAAAw2B,EAAAx2B,YACAC,EAAAu2B,EAAAv2B,qBACArhD,GAAA,GAAAohD,EAAArmB,EAAA,GAAAqtB,EAAA,GAAAtsB,EAAA,GAAA1C,GACAp5B,EAAA,GAAAohD,EAAArmB,EAAA,GAAAqtB,EAAA,GAAAtsB,EAAA,GAAA1C,GAEA4oB,EAAAX,EAAAtmB,EAAA,GAAAqtB,EAAA,GAAAtsB,EAAA,GAAA1C,GACA6oB,EAAAZ,EAAAtmB,EAAA,GAAAqtB,EAAA,GAAAtsB,EAAA,GAAA1C,GAEArmC,KAAA48E,OAAA/nE,UAAAxB,KAAAqE,MAAAw3C,EAAAD,GAAA57C,KAAA0B,GAAA,EAEA/U,KAAA48E,OAAA17C,QAAA,GAGA4jD,EAAAK,2BAAA,SAAApiE,GACA/iB,KAAA0lF,QAAA3iE,CAGA,KAAA,GAFA4iE,IAAA,GACAv1D,EAAA,EACA/iB,EAAA,EAAuBA,EAAA0V,EAAA5c,OAAmBkH,IAAA,CAC1C,GAAA26B,GAAAjlB,EAAA1V,EAAA,GACA07B,EAAAhmB,EAAA1V,EACA+iB,IAAA01B,EAAAvf,KAAAyB,EAAAe,GACA48C,EAAAn8E,KAAA4mB,GAEA,GAAA,IAAAA,EAAA,CAIA,IAAA,GAAAzS,GAAA,EAAuBA,EAAAgoE,EAAAx/E,OAAsBwX,IAC7CgoE,EAAAhoE,IAAAyS,CAEApwB,MAAA4lF,SAAAD,EACA3lF,KAAA6lF,QAAAz1D,EACApwB,KAAA48E,OAAA8H,WAAA,EACA1kF,KAAA48E,OAAAkJ,mBAAA,IAGAhB,EAAAI,6BAAA,WACA,GAAA7+C,GAAArmC,KAAA48E,OAAAoI,IACAjiE,EAAA/iB,KAAA0lF,QACAK,EAAA/lF,KAAA4lF,SACAx1D,EAAArN,EAAA5c,MAEA,IAAA4/E,EAAA,CAKA,GACAz6C,GADAH,EAAAnrC,KAAA0kF,UAGA,IAAAr+C,EAAArmC,KAAA2kF,kBAAA,CAGA,GAAAlwE,GAAApB,KAAA4Q,IAAAknB,EAAA,EAAA/a,EAAA,EACA,KAAAkb,EAAA72B,EAA+B62B,GAAA,KAC/By6C,EAAAz6C,IAAAjF,GAD2CiF,KAM3CA,EAAAj4B,KAAA4Q,IAAAqnB,EAAAlb,EAAA,OACS,CACT,IAAA,GAAAkb,GAAAH,EAAuCG,EAAAlb,KACvC21D,EAAAz6C,GAAAjF,GADoDiF,KAKpDA,EAAAj4B,KAAA4Q,IAAAqnB,EAAA,EAAAlb,EAAA,GAEA01B,EAAA1f,KACApmC,KAAA48E,OAAA3xE,SAAA8X,EAAAuoB,GAAAvoB,EAAAuoB,EAAA,IACAjF,EAAA0/C,EAAAz6C,KAAAy6C,EAAAz6C,EAAA,GAAAy6C,EAAAz6C,KAGAtrC,KAAA0kF,WAAAp5C,EACAtrC,KAAA2kF,kBAAAt+C,CACA,IAAAvxB,IAAAzB,KAAAqE,MAAAqL,EAAAuoB,EAAA,GAAA,GAAAvoB,EAAAuoB,GAAA,GAAAvoB,EAAAuoB,EAAA,GAAA,GAAAvoB,EAAAuoB,GAAA,GACAtrC,MAAA48E,OAAA/nE,SAAAC,EAAAzB,KAAA0B,GAAA,EACA/U,KAAA48E,OAAA17C,QAAA,IAEArhC,EAAAD,QAAAg+E,GtF+2rBM,SAAU/9E,EAAQD,EAASM,GuFpisBjC,QAAA29E,GAAAz2E,EAAAiK,EAAAvL,EAAA1C,GACApD,KAAAoH,UAAAA,EAEApH,KAAAqR,MAAAA,EAAAjL,QAEApG,KAAA8F,KAAAA,EAEA9F,KAAAsuB,MAAAuvD,EAAAf,aAEA98E,KAAAyhE,MAAA,kBAEAzhE,KAAAiH,MAAA,GAAAtE,GAAAyF,QACAnB,OACAuK,GAAAxR,KAAAqR,MAAAI,EACAC,GAAA1R,KAAAqR,MAAAM,EACAC,EAAAisE,EAAAC,QAGAjzE,OACAgH,KAAA7R,KAAAsuB,MACAxc,OAAA,WAEAC,EAAA3O,EAAA2O,EAAA,IAEA/R,KAAAiH,MAAAnB,KAAA9F,KAAA8F,KAEA9F,KAAAiH,MAAAG,UAAAA,EA3BA,GAAAzE,GAAAzC,EAAA,EA+BA29E,GAAAf,aAAA,UAEAe,EAAAmI,WAAA,UAEAnI,EAAAoI,gBAAA,UAEApI,EAAAC,OAAA,EAEAD,EAAAqI,YAAA,SAEArI,EAAAoC,eAAA,YAEApC,EAAA34E,WAEAqrB,YAAAstD,EAEAxc,OAAA,SAAA8kB,GACA,MAAAnmF,MAAAqR,MAAAgwD,OAAA8kB,EAAA90E,QACArR,KAAAoH,WAAA++E,EAAA/+E,WACApH,KAAA8F,MAAAqgF,EAAArgF,MACA9F,KAAAsuB,OAAA63D,EAAA73D,OACAtuB,KAAAoqD,QAAA+7B,EAAA/7B,SAKAvqD,EAAAD,QAAAi+E,GvFojsBM,SAAUh+E,EAAQD,EAASM,GwFxmsBjC,QAAA6C,GAAAgD,EAAAqgF,EAAAC,GACArmF,KAAAomF,YAAAA,EACApmF,KAAA+F,OAAAA,EAGA/F,KAAAmC,OACA+D,UAAAC,QAAA,EACAnG,KAAAmC,KAAA4D,EAAAqgF,EAAAC,GAGArmF,KAAAmC,KAAAyY,MAAA5a,KAAAkG,YAbA,GAAAjC,GAAA/D,EAAA,GACAomF,EAAApmF,EAAA,GAiBA6C,GAAAmC,WAEAqrB,YAAAxtB,EAOAZ,KAAA,SAAA4D,GACA9B,EAAA8M,MAAAhL,EAAA/F,KAAAumF,qBAGAA,iBAAA,WACA,IAAAvmF,KAAAkqB,eAAA,mBAAA,CAGA,IAFA,GAAAs8D,MACA3mB,EAAA7/D,KAAAuwB,YACAsvC,GAAA,CACA,GAAA11D,GAAA01D,EAAA36D,UAAAuhF,aACAt8E,IAAAq8E,EAAAh9E,KAAAW,GACA01D,EAAAA,EAAAluC,WAIA,IAAA,GADA80D,MACAp5E,EAAAm5E,EAAArgF,OAAA,EAAgDkH,GAAA,EAAQA,IACxDo5E,EAAAxiF,EAAA8M,MAAA01E,EAAAD,EAAAn5E,IAAA,EAEArN,MAAA0mF,gBAAAD,EAEA,MAAAzmF,MAAA0mF,iBAMAC,YAAA,SAAA5gF,GACA9B,EAAA8M,MAAA/Q,KAAA+F,OAAAA,GAAA,IAaAM,IAAA,SAAA0mB,EAAA65D,GACA,IAAA75D,EACA,MAAA/sB,MAAA+F,MAGA,iBAAAgnB,KACAA,EAAAA,EAAA3X,MAAA,KAKA,KAAA,GAFAyc,GAAA7xB,KAAA+F,OACAqgF,EAAApmF,KAAAomF,YACA/4E,EAAA,EAA2BA,EAAA0f,EAAA5mB,SAE3B0rB,EAAAA,GAAA,gBAAAA,GAAAA,EAAA9E,EAAA1f,IAAA,KACA,MAAAwkB,GAH4CxkB,KAU5C,MAHA,OAAAwkB,GAAAu0D,IAAAQ,IACA/0D,EAAAu0D,EAAA//E,IAAA0mB,IAEA8E,GAcA7uB,IAAA,SAAA+pB,EAAA9mB,GACA,GAAA4rB,GAAA7xB,KAAA+F,MAEA,IAAAgnB,EAAAlc,QAAA,SACAghB,EAAA9E,GAAA9mB,MACa,CAMb,IAAA,GAFA4gF,GAHAC,EAAA/5D,EAAA3X,MAAA,KACAJ,EAAA8xE,EAAA3gF,OACA4gF,EAAAl1D,EAGAxkB,EAAA,EAA+BA,EAAA2H,EAAA,EAAW3H,IAC1Cw5E,EAAAC,EAAAz5E,GACA,MAAA05E,EAAAF,KACAE,EAAAF,OAEAE,EAAAA,EAAAF,EAEAA,GAAAC,EAAA9xE,EAAA,GACA+xE,EAAAF,GAAA5gF,IAOAslB,WAAA,SAAAvlB,EAAA4gF,GACA,GAAA7gF,GAAA/F,KAAA+F,OACA+b,EAAA/b,GAAAA,EAAAC,GACAogF,EAAApmF,KAAAomF,WAIA,OAHA,OAAAtkE,GAAAskE,IAAAQ,IACA9kE,EAAAskE,EAAA76D,WAAAvlB,IAEA8b,GAMA4M,SAAA,SAAA3B,EAAAq5D,GACA,GAAAv0D,GAAA7xB,KAAAqG,IAAA0mB,GAAA,GACAi6D,EAAAhnF,KAAAomF,YACAtjF,EAAA,GAAAC,GACA8uB,EAAAu0D,GAAAY,GAAAA,EAAAt4D,SAAA3B,GAEA,OAAAjqB,IAOA68D,QAAA,WACA,MAAA,OAAA3/D,KAAA+F,QAGAkhF,YAAA,aAKA7gF,MAAA,WACA,GAAAkqB,GAAAtwB,KAAAuwB,WACA,OAAA,IAAAD,GAAArsB,EAAAmC,MAAApG,KAAA+F,WAKAugF,EAAAY,kBAAAnkF,GAEAlD,EAAAD,QAAAmD,GxF0nsBM,SAAUlD,EAAQD,EAASM,GyF7vsBjC,QAAAinF,GAAArpE,EAAAspE,GACA,GAAA/0D,GAAApuB,EAAA2kB,MAAA1iB,UAAA,EACA,OAAAlG,MAAA2xB,WAAAzsB,UAAAkiF,GAAAxsE,MAAAkD,EAAAuU,GAGA,QAAAg1D,GAAAvpE,EAAAspE,EAAA/0D,GACA,MAAAryB,MAAA2xB,WAAAzsB,UAAAkiF,GAAAxsE,MAAAkD,EAAAuU,GApDA,GAAApuB,GAAA/D,EAAA,GAEAoxB,KAEAg2D,EAAA,IACAC,EAAA,iCAIAC,EAAAl2D,EAAAk2D,eAAA,SAAAC,GACA,GAAAn+C,IAAmBo+C,KAAA,GAAAttE,IAAA,GAMnB,OALAqtE,KACAA,EAAAA,EAAAryE,MAAAkyE,GACAh+C,EAAAo+C,KAAAD,EAAA,IAAA,GACAn+C,EAAAlvB,IAAAqtE,EAAA,IAAA,IAEAn+C,EAKAhY,GAAA41D,kBAAA,SAAAS,EAAAC,GACAD,EAAA7iE,OAAA,SAAA67C,GACA,GAAAknB,GAAA,WACAD,GAAAA,EAAAhtE,MAAA5a,KAAAkG,WACAyhF,EAAA/sE,MAAA5a,KAAAkG,WAWA,OARAjC,GAAA6gB,OAAA+iE,EAAA3iF,UAAAy7D,GAEAknB,EAAA/iE,OAAA9kB,KAAA8kB,OACA+iE,EAAAV,UAAAA,EACAU,EAAAR,WAAAA,EACApjF,EAAAkpB,SAAA06D,EAAA7nF,MACA6nF,EAAAl2D,WAAA3xB,KAEA6nF,IAyBAv2D,EAAAw2D,sBAAA,SAAAC,EAAA3kF,GAgGA,QAAA4kF,GAAAP,GACA,GAAAQ,GAAAz1B,EAAAi1B,EAAAC,KAKA,OAJAO,IAAAA,EAAAV,KACAU,EAAAz1B,EAAAi1B,EAAAC,SACAO,EAAAV,IAAA,GAEAU,EArGA7kF,EAAAA,KAUA,IAAAovD,KA8FA,IA5FAu1B,EAAAG,cAAA,SAAAC,EAAAV,GACA,GAAAA,EAGA,GAFAA,EAAAD,EAAAC,GAEAA,EAAArtE,KAOA,GAAAqtE,EAAArtE,MAAAmtE,EAAA,CACA,GAAAU,GAAAD,EAAAP,EACAQ,GAAAR,EAAArtE,KAAA+tE,OATA,CACA,GAAA31B,EAAAi1B,EAAAC,MAEA,MAEAl1B,GAAAi1B,EAAAC,MAAAS,EAOA,MAAAA,IAGAJ,EAAAK,SAAA,SAAAC,EAAAC,EAAAC,GACA,GAAAJ,GAAA31B,EAAA61B,EAMA,IAJAF,GAAAA,EAAAZ,KACAY,EAAAG,EAAAH,EAAAG,GAAA,MAGAC,IAAAJ,EACA,KAAA,IAAAxgE,OACA,aAAA0gE,EAAA,KAAAC,GAAA,IAAA,8BAIA,OAAAH,IAGAJ,EAAAS,qBAAA,SAAAf,GACAA,EAAAD,EAAAC,EAEA,IAAA5lE,MACAgQ,EAAA2gC,EAAAi1B,EAAAC,KAWA,OATA71D,IAAAA,EAAA01D,GACAtjF,EAAA4E,KAAAgpB,EAAA,SAAAmvC,EAAAl7D,GACAA,IAAAyhF,GAAA1lE,EAAArY,KAAAw3D,KAIAn/C,EAAArY,KAAAqoB,GAGAhQ,GAGAkmE,EAAAU,SAAA,SAAAhB,GAGA,MADAA,GAAAD,EAAAC,KACAj1B,EAAAi1B,EAAAC,OAMAK,EAAAW,qBAAA,WACA,GAAAtyE,KAIA,OAHAnS,GAAA4E,KAAA2pD,EAAA,SAAA3gC,EAAA/rB,GACAsQ,EAAA5M,KAAA1D,KAEAsQ,GAQA2xE,EAAAY,YAAA,SAAAlB,GACAA,EAAAD,EAAAC,EACA,IAAA51D,GAAA2gC,EAAAi1B,EAAAC,KACA,OAAA71D,IAAAA,EAAA01D,IAGAQ,EAAAP,eAAAA,EAWApkF,EAAAwlF,mBAAA,CACA,GAAAC,GAAAd,EAAAjjE,MACA+jE,KACAd,EAAAjjE,OAAA,SAAA67C,GACA,GAAAknB,GAAAgB,EAAAtoF,KAAAP,KAAA2gE,EACA,OAAAonB,GAAAG,cAAAL,EAAAlnB,EAAA76D,QAKA,MAAAiiF,IAGAloF,EAAAD,QAAA0xB,GzFqzsBM,SAAUzxB,EAAQD,G0Fp+sBxB,GAAAkpF,IACAtO,aAAA,srCACAE,WAAA,o0BACAE,UAAA,mrCACAC,QAAA,i9BACAC,YAAA,+tDACAiO,qBAAA,kzBAEAlpF,GAAAD,QAAAkpF,G1Fi/sBM,SAAUjpF,EAAQD,EAASM,G2Fn/sBjC,QAAA4B,GAAAg4E,GACAkP,EAAAzoF,KAAAP,MACAA,KAAAipF,aAAA,GACAjpF,KAAAkpF,UAAA,GACAlpF,KAAAgO,aAAA+d,EAAA+zC,WAAAC,YACA//D,KAAA2B,KAAAm4E,EAZA,GAAA71E,GAAA/D,EAAA,GACA8oF,EAAA9oF,EAAA,IACAmE,EAAAnE,EAAA,IACA6rB,EAAA7rB,EAAA,IACA8D,EAAA9D,EAAA,IACA+C,EAAA/C,EAAA,GAUA4B,GAAAoD,UAAAyB,IAAA,SAAAS,GAKA,GAJApH,KAAA8G,WAAA0C,KAAApC,GAEApH,KAAAmpF,qBAAA/hF,GAEAA,EAAAyF,WAAAzF,EAAA0F,QAAA,CACA,GAAA9G,GAAAhG,KAAA8N,aAAA1G,EAAAyF,UAAAzF,EAAA0F,QAAA1F,EAAAhE,QAAA6H,SACAjL,MAAAgO,aAAArH,IAAAX,EAAAoB,GAEApH,KAAAopF,sBAAAhiF,GAEApH,KAAAipF,aAAA7hF,EAAAhE,QAAA6lF,cAAAjpF,KAAAipF,aACAjpF,KAAAkpF,UAAA9hF,EAAAhE,QAAA8lF,WAAAlpF,KAAAkpF,SAEA,IAAAG,GAAArpF,KAAAgO,aAAA3H,IAAAL,EACA,IAAA,GAAAqjF,EAAAljF,OAAA,CAGA,GAAA6K,GAAA5J,EAAAhE,QAAA4N,QACA+R,IACA,IAAA/R,GAAAA,EAAA7K,QAAA,EACA4c,EAAA/e,EAAAk9D,UAAAlwD,GACA5J,EAAA60B,QAAAlZ,OAEA,IAAA3b,EAAAhE,QAAA6H,SAAA8X,OAAA,CACA,GAAAumE,GAAAtpF,KAAAupF,iBAAAniF,EACA2b,GAAA3b,EAAAhE,QAAA6H,SAAA8X,OACAA,EAAAymE,QAAAF,EAAA,IACAvmE,EAAAvZ,KAAA8/E,EAAA,IACAliF,EAAA60B,QAAAlZ,OAEA/iB,MAAAypF,iBAAAJ,EAAA,IAAA,OAGaA,GAAAljF,OAAA,GAEbnG,KAAA0pF,YAAAL,OAIArpF,MAAA2pF,sBAAAviF,EAKA,OADApH,MAAA4pF,qBAAAxiF,GACAA,GAGAtF,EAAAoD,UAAAikF,qBAAA,SAAA/hF,GACAA,EAAAq2E,gBACAr2E,EAAAq2E,eAAA12E,GAAA,QAAA,SAAAC,GACA,GAAA6iF,GAAA7iF,EAAAE,OAAApB,KAAAsP,MAAA/Q,EAAAg6E,WACAj3E,EAAAJ,EAAAE,OAAAE,SACAyiF,GAAA,KAAAxlF,EAAA05E,WACA32E,EAAAhE,QAAA6H,SAAAwI,SAAAo2E,EAAA,GACiBA,EAAA,KAAAxlF,EAAA25E,WACjB52E,EAAAhE,QAAA6H,SAAAmI,OAAAy2E,EAAA,IAEA7pF,KAAAypF,iBAAAriF,GAAA,GACAJ,EAAA2H,cAAA,CACA,IAAA7G,KACAA,GAAAC,MAAAf,EACAc,EAAAhC,KAAA,uBACAgC,EAAAc,SAAA5I,KAAAsQ,aACAtQ,KAAA2B,KAAAqG,QAAAF,EAAAhC,KAAAgC,IACaN,KAAAxH,MAIb,IAAAuG,IAAA,QAAA,WACAtC,GAAA4E,KAAAtC,EAAA,SAAAuC,GACA1B,EAAAL,GAAA,aAAA+B,EAAA,SAAA9B,GACA,GAAA8iF,GAAA9iF,EAAAE,MACAlH,MAAAsQ,eAAAw5E,IACA9pF,KAAAsQ,cAAAtQ,KAAAypF,iBAAAzpF,KAAAsQ,cACAtQ,KAAAsQ,aAAAw5E,GAEA9iF,EAAA2H,cAAA,CACA,IAAA7G,KACAA,GAAAC,MAAAf,EACAc,EAAAhC,KAAAgD,EACAhB,EAAAZ,OAAAlH,KAAAsQ,aACAtQ,KAAA2B,KAAAqG,QAAAF,EAAAhC,KAAAgC,IACaN,KAAAxH,QACJwH,KAAAxH,QAGT8B,EAAAoD,UAAA0kF,qBAAA,SAAAxiF,GACAA,EAAAtE,MAAAE,IAAAC,EAAAC,aAAAD,EAAA8mF,YACA3iF,EAAAyF,WAAAzF,EAAA0F,UACA1F,EAAAtE,MAAAE,IAAAC,EAAA+mF,SAAA5iF,EAAAyF,UAAAxM,IACA+G,EAAAtE,MAAAE,IAAAC,EAAAgnF,OAAA7iF,EAAA0F,QAAAzM,KAEA+G,EAAAtE,MAAAE,IAAAC,EAAAwH,QAAAxG,EAAAmC,MAAAgB,EAAAhE,WAGAtB,EAAAoD,UAAAkkF,sBAAA,SAAAhiF,GACA,GAAA8B,GAAAlJ,IAEAoH,GAAAkF,KAAAvF,GAAA,WAAA,WACA,GAAA,GAAAK,EAAAhE,QAAA8mF,SAAA,CAGA,GAAAC,GAAAnqF,KAAAmI,OACA0E,EAAAs9E,EAAAt9E,UACAC,EAAAq9E,EAAAr9E,QAEA9G,EAAAkD,EAAA4E,aAAAjB,EAAAC,EAAA1F,EAAAhE,QAAA6H,UACA8C,EAAA7E,EAAA8E,aAAA3H,IAAAL,EACA,IAAA,GAAA+H,EAAA5H,OAMA,IAAA,GADAikF,GAAAjxE,SAAApL,EAAA5H,OAAA,GACAkH,EAAA,EAA2BA,EAAAU,EAAA5H,OAAiBkH,IAC5CA,GAAA,IACAU,EAAAV,GAAA6zB,OACAnzB,EAAAV,GAAAO,OAEAG,EAAAV,GAAAhC,YAQAvJ,EAAAoD,UAAAykF,sBAAA,SAAAviF,GACA,GAAAhE,GAAAgE,EAAAhE,QACA4N,EAAA5J,EAAAhE,QAAA4N,OACA,IAAAA,GAAAA,EAAA7K,QAAA,EAAA,CACA,GAAA4c,GAAA/e,EAAAk9D,UAAAlwD,EACA5J,GAAA60B,QAAAlZ,OAEA,IAAA3f,EAAA6H,UAAA7H,EAAA6H,SAAA8X,OAAA,CACA,GAAAsnE,GAAAjnF,EAAA6H,SAAA8X,MACA3b,GAAA60B,QAAAouD,KAKAvoF,EAAAoD,UAAA4I,aAAA,SAAAjB,EAAAC,EAAAG,GACA,MAAAJ,GAAAxM,GAAA,IAAA4M,EAAAwG,SAAA,IAAA3G,EAAAzM,GAAA,IAAA4M,EAAAmG,QAGAtR,EAAAoD,UAAAwkF,YAAA,SAAAL,GAEA,GAAAA,EAAA,GAAAjmF,QAAAyH,MAAA3C,UAAA7D,EAAAqM,YACA,IAAA,GAAArD,GAAA,EAA2BA,EAAAg8E,EAAAljF,OAAoBkH,IAC/CrN,KAAAypF,iBAAAJ,EAAAh8E,IAAA,OAGArN,MAAAsqF,oBAAAjB;EAKAvnF,EAAAoD,UAAAolF,oBAAA,SAAAjB,GACA,GAAAe,GAAAjxE,SAAAkwE,EAAAljF,OAAA,GACAokF,KAEA19E,EAAAw8E,EAAA,GAAAx8E,UACAC,EAAAu8E,EAAA,GAAAv8E,QACA09E,EAAAz+D,EAAAtZ,QAAA5F,GACA49E,EAAA1+D,EAAAtZ,QAAA3F,GAAA8J,aACA8zE,EAAA3+D,EAAApZ,mBAAA63E,EAAA39E,GACA89E,EAAA5+D,EAAApZ,mBAAA83E,EAAA39E,GAEA7B,EAAAo+E,EAAA,GAAAjmF,QAAA6H,QACAA,GAAAwI,UAAAxI,EAAAmI,SACAo3E,EAAA/4E,EAAAg5E,EAAAh5E,GACAxG,EAAAwI,SAAA,QACAxI,EAAAmI,OAAA,SAEAnI,EAAAwI,SAAA,OACAxI,EAAAmI,OAAA,SAQA,KAAA,GAJA0oD,GAAA4uB,EAAAz/E,EAAAwI,UACAsoD,EAAA4uB,EAAA1/E,EAAAmI,QACA0B,EAAAzB,KAAAqE,MAAAqkD,EAAApqD,EAAAmqD,EAAAnqD,EAAAoqD,EAAAtqD,EAAAqqD,EAAArqD,GACAsR,KACA1V,EAAA+8E,EAA0B/8E,GAAA,EAAQA,IAAA,CAClC0V,KACAA,EAAAvZ,KAAAsyD,EAGA,IAAA8uB,GAAA9uB,EAAA11D,OAGAwkF,GAAAp7D,UAAAzD,EAAAqxC,kBAAA,EAAAp9D,KAAAkpF,UAAA77E,IAOAu9E,EAAAn5E,EAAAm5E,EAAAn5E,EAAAzR,KAAAipF,aAAA51E,KAAA0lB,IAAAjkB,GACA81E,EAAAj5E,EAAAi5E,EAAAj5E,EAAA3R,KAAAipF,aAAA51E,KAAAylB,IAAAhkB,GAKAiO,EAAAvZ,KAAAohF,EAEA,IAAAC,GAAA9uB,EAAA31D,OAKAykF,GAAAr7D,UAAAzD,EAAAqxC,kBAAA,EAAAp9D,KAAAkpF,UAAA77E,IAOAw9E,EAAAp5E,EAAAo5E,EAAAp5E,EAAAzR,KAAAipF,aAAA51E,KAAA0lB,IAAAjkB,GACA+1E,EAAAl5E,EAAAk5E,EAAAl5E,EAAA3R,KAAAipF,aAAA51E,KAAAylB,IAAAhkB,GAEAiO,EAAAvZ,KAAAqhF,GAEA9nE,EAAAvZ,KAAAuyD,GACAwuB,EAAA/gF,KAAAuZ,GAGAwnE,EAAA/gF,MAAAsyD,EAAAC,GAEA,IAAA+uB,GAAAz3E,KAAA8/B,KAAAk2C,EAAAljF,OAAA,EACA,KAAAkH,EAAA,EAAmBA,EAAAy9E,EAAYz9E,IAAA,CAC/B0V,KACAA,EAAAvZ,KAAAsyD,EACA,IAAAivB,GAAAjvB,EAAA11D,OAEA2kF,GAAAv7D,UAAAzD,EAAAqxC,kBAAA,GAAAp9D,KAAAkpF,UAAA77E,IACA09E,EAAAt5E,EAAAs5E,EAAAt5E,EAAAzR,KAAAipF,aAAA51E,KAAA0lB,IAAAjkB,GACAi2E,EAAAp5E,EAAAo5E,EAAAp5E,EAAA3R,KAAAipF,aAAA51E,KAAAylB,IAAAhkB,GACAiO,EAAAvZ,KAAAuhF,EAEA,IAAAC,GAAAjvB,EAAA31D,OAEA4kF,GAAAx7D,UAAAzD,EAAAqxC,kBAAA,GAAAp9D,KAAAkpF,UAAA77E,IAEA29E,EAAAv5E,EAAAu5E,EAAAv5E,EAAAzR,KAAAipF,aAAA51E,KAAA0lB,IAAAjkB,GACAk2E,EAAAr5E,EAAAq5E,EAAAr5E,EAAA3R,KAAAipF,aAAA51E,KAAAylB,IAAAhkB,GAEAiO,EAAAvZ,KAAAwhF,GAEAjoE,EAAAvZ,KAAAuyD,GACAwuB,EAAA/gF,KAAAuZ,GAIA,IAAA1V,EAAA,EAAmBA,EAAAk9E,EAAApkF,OAA6BkH,IAChDg8E,EAAAh8E,GAAA4uB,QAAAsuD,EAAAl9E,KAKAvL,EAAAoD,UAAA+lF,cAAA,SAAA55E,EAAA65E,GACA,GAAAC,GAAA95E,EAAAjL,QAEA0O,EAAAzB,KAAAqE,MAAAyzE,EAAAx5E,EAAAw5E,EAAA15E,GACAG,EAAAyB,KAAA2D,KAAA3D,KAAA4D,IAAAk0E,EAAA15E,EAAA,GAAA4B,KAAA4D,IAAAk0E,EAAAx5E,EAAA,GAWA,OAVAu5E,GACAt5E,GAAA5R,KAAAipF,aAEAr3E,GAAA5R,KAAAipF,aAKAkC,EAAA15E,EAAAG,EAAAyB,KAAA0lB,IAAAjkB,GACAq2E,EAAAx5E,EAAAC,EAAAyB,KAAAylB,IAAAhkB,GACAq2E,GAQArpF,EAAAoD,UAAAkmF,SAAA,SAAAhkF,EAAArB,GACA,GAAAwK,GAAAnJ,EAAAtE,MAAAuD,IAAA,iBACAe,GAAAtE,MAAA6jF,YAAA5gF,GACA9B,EAAA8M,MAAA3J,EAAAtE,MAAAuD,IAAA,WAAAN,GAAA,GACAwK,IAAAxK,EAAA8E,MAAA3C,UACAlI,KAAAypF,iBAAAriF,GAAA,IASA4hF,EAAA9jF,UAAA2O,aAAA,SAAAzM,EAAAnF,GAEA,GAAAmF,EAAAyF,UAAA,CACA,GAAAw+E,GAAAjkF,EAAAyF,UAAA/J,MAAAuD,IAAA,WAMA,IALAuK,EAAA3M,EAAA4M,QAAAw6E,EAAAjkF,EAAAi1E,YACAzrE,OACAy6E,EAAA99E,OAAAqD,EAAA,GAGA5Q,KAAAgO,aAAA,CACA,GAAAhI,GAAAhG,KAAA8N,aAAA1G,EAAAyF,UAAAzF,EAAA0F,QAAA1F,EAAAhE,QAAA6H,SACAjL,MAAAgO,aAAAkyD,WAAAl6D,EAAAoB,IAMAnF,EAAAwN,OAAArI,EAIA,IAAAwJ,GAAA3M,EAAA4M,QAAA7Q,KAAA8G,WAAAM,EACAwJ,QACA5Q,KAAA8G,WAAAyG,OAAAqD,EAAA,GAEA5Q,KAAAsQ,eAAAlJ,IACApH,KAAAsQ,aAAA,OAQAxO,EAAAoD,UAAAgU,kBAAA,SAAA9P,GAGA,IAAA,GADAm0D,GAAAv9D,KAAAgO,aAAAuvD,OACAlwD,EAAA,EAAuBA,EAAAkwD,EAAAp3D,OAAiBkH,IAAA,CACxC,GAAArH,GAAAu3D,EAAAlwD,EACA,IAAArH,EAAA6K,QAAAzH,EAAA/I,QAAA,CACA,GAAAgpF,GAAArpF,KAAAgO,aAAA3H,IAAAL,EACAhG,MAAAsrF,aAAAjC,GACA,GAAAA,EAAAljF,OAEAnG,KAAAypF,iBAAAJ,EAAA,IAAA,GACiBA,EAAAljF,OAAA,GAEjBnG,KAAA0pF,YAAAL,MAWAvnF,EAAAoD,UAAAqmF,iBAAA,SAAAniF,EAAAoiF,GAGA,IAAA,GADAjuB,GAAAv9D,KAAAgO,aAAAuvD,OACAlwD,EAAA,EAAuBA,EAAAkwD,EAAAp3D,OAAiBkH,IAAA,CACxC,GAAArH,GAAAu3D,EAAAlwD,EACA,IAAArH,EAAA6K,QAAAzH,EAAA/I,QAAA,CACA,GAAAgpF,GAAArpF,KAAAgO,aAAA3H,IAAAL,EAEA/B,GAAA4E,KAAAwgF,EAAA,SAAAoC,GACAD,EACAC,EAAA79E,OAEA69E,EAAApgF,YASAvJ,EAAAoD,UAAAomF,aAAA,SAAAjC,GACAplF,EAAA4E,KAAAwgF,EAAA,SAAAjiF,GACA,GAAAhE,GAAAgE,EAAAhE,OACA,IAAA,GAAAA,EAAAi6E,mBAAA,CACA,GAAAmN,GAAAz+D,EAAAtZ,QAAArL,EAAAyF,WAAA+J,aACA6zE,EAAA1+D,EAAAtZ,QAAArL,EAAA0F,SAAA8J,aACAnD,EAAArQ,EAAA6H,SAAAwI,SACAL,EAAAhQ,EAAA6H,SAAAmI,OACAs4E,EAAA1rF,KAAA2rF,YAAAl4E,EAAA+2E,EAAAC,EAAA,aACAmB,EAAA5rF,KAAA2rF,YAAAv4E,EAAAo3E,EAAAC,EAAA,UACAh3E,IAAAi4E,GAAAt4E,GAAAw4E,IACAxoF,EAAA6H,SAAAwI,SAAAi4E,EACAtoF,EAAA6H,SAAAmI,OAAAw4E,KAGS5rF,OAGT8B,EAAAoD,UAAAymF,YAAA,SAAA1+E,EAAAu9E,EAAAC,EAAAj4D,GACA,GAAAq5D,EA4DA,OAxDAA,GAHA5+E,EAAA4D,QAAA,YAAA5D,EAAA4D,QAAA,cACA25E,EAAA74E,EAAA64E,EAAAt7E,OAAAu7E,EAAA94E,EACA,aAAA6gB,EACAvlB,EAAA0pB,QAAA,gBAAA,UAEA1pB,EAAA0pB,QAAA,gBAAA,OAEa8zD,EAAA94E,EAAA84E,EAAAv7E,OAAAs7E,EAAA74E,EACb,WAAA6gB,EACAvlB,EAAA0pB,QAAA,gBAAA,UAEA1pB,EAAA0pB,QAAA,gBAAA,OAEa6zD,EAAA/4E,EAAA+4E,EAAAv7E,MAAAw7E,EAAAh5E,EACb,aAAA+gB,EACAvlB,EAAA0pB,QAAA,gBAAA,SAEA1pB,EAAA0pB,QAAA,gBAAA,QAEa8zD,EAAAh5E,EAAAg5E,EAAAx7E,MAAAu7E,EAAA/4E,EACb,WAAA+gB,EACAvlB,EAAA0pB,QAAA,gBAAA,SAEA1pB,EAAA0pB,QAAA,gBAAA,QAGA1pB,EAESA,EAAA4D,QAAA,aAAA5D,EAAA4D,QAAA,aACT25E,EAAA/4E,EAAA+4E,EAAAv7E,MAAAw7E,EAAAh5E,EACA,aAAA+gB,EACAvlB,EAAA0pB,QAAA,gBAAA,SAEA1pB,EAAA0pB,QAAA,gBAAA,QAEa8zD,EAAAh5E,EAAAg5E,EAAAx7E,MAAAu7E,EAAA/4E,EACb,WAAA+gB,EACAvlB,EAAA0pB,QAAA,gBAAA,SAEA1pB,EAAA0pB,QAAA,gBAAA,QAEa6zD,EAAA74E,EAAA64E,EAAAt7E,OAAAu7E,EAAA94E,EACb,aAAA6gB,EACAvlB,EAAA0pB,QAAA,gBAAA,UAEA1pB,EAAA0pB,QAAA,gBAAA,OAEa8zD,EAAA94E,EAAA84E,EAAAv7E,OAAAs7E,EAAA74E,EACb,WAAA6gB,EACAvlB,EAAA0pB,QAAA,gBAAA,UAEA1pB,EAAA0pB,QAAA,gBAAA,OAGA1pB,EAGAA,GAMAhJ,EAAAkpB,SAAArrB,EAAAknF,GACAnpF,EAAAD,QAAAkC,G3FugtBM,SAAUjC,EAAQD,EAASM,G4F79tBjC,QAAA8oF,KACAhpF,KAAA8G,cACA9G,KAAAsQ,aAAA,KACAtQ,KAAA8rF,cAAA,KATA,GAAA//D,GAAA7rB,EAAA,IACA8D,EAAA9D,EAAA,IACAmE,EAAAnE,EAAA,IACA6rF,EAAA7rF,EAAA,IACA+D,EAAA/D,EAAA,EAaA8oF,GAAA9jF,UAAAmJ,oBAAA,SAAA0rE,GACA,IAAA,GAAA1sE,GAAA,EAAuBA,EAAArN,KAAA8G,WAAAX,OAA4BkH,IACnDrN,KAAA8G,WAAAuG,GAAAjK,QAAA+K,QAAA4rE,GASAiP,EAAA9jF,UAAAmC,eAAA,WACA,MAAArH,KAAAsQ,cACAtQ,KAAAypF,iBAAAzpF,KAAAsQ,eAOA04E,EAAA9jF,UAAAyK,gBAAA,SAAAvG,EAAAnH,GACA,IAAA,GAAAoL,GAAA,EAAuBA,EAAArN,KAAA8G,WAAAX,OAA4BkH,IACnD,GAAArN,KAAA8G,WAAAuG,GAAAR,WAAAzD,GAAApJ,KAAA8G,WAAAuG,GAAAP,SAAA1D,EAAA,CAEA,GAAAiiF,GAAArrF,KAAA8G,WAAAuG,GAAAR,UAAA/J,MAAAuD,IAAA,YACAuK,EAAA3M,EAAA4M,QAAAw6E,EAAArrF,KAAA8G,WAAAuG,GAAAgvE,WACAzrE,QACAy6E,EAAA99E,OAAAqD,EAAA,GAGA3O,EAAAwN,OAAAzP,KAAA8G,WAAAuG,IACArN,KAAA8G,WAAAyG,OAAAF,EAAA,GACAA,IACArN,KAAAsQ,aAAA,OAIA04E,EAAA9jF,UAAAsH,WAAA,SAAAF,EAAAu1B,GACA7hC,KAAAsQ,aAAAhE,EACAtM,KAAA8Q,WAAA+wB,IAMAmnD,EAAA9jF,UAAA4L,WAAA,SAAA7O,GAEA,GAAAjC,KAAAsQ,aAAAzD,UAAA,CACA,GAAAw+E,GAAArrF,KAAAsQ,aAAAzD,UAAA/J,MAAAuD,IAAA,WAMA,IALAuK,EAAA3M,EAAA4M,QAAAw6E,EAAArrF,KAAAsQ,aAAA+rE,YACAzrE,OACAy6E,EAAA99E,OAAAqD,EAAA,GAGA5Q,KAAAgO,aAAA,CACA,GAAAhI,GAAAhG,KAAA8N,aAAA9N,KAAAsQ,aAAAzD,UAAA7M,KAAAsQ,aAAAxD,QAAA9M,KAAAsQ,aAAAlN,QAAA6H,SACAjL,MAAAgO,aAAAkyD,WAAAl6D,EAAAhG,KAAAsQ,eAMArO,EAAAwN,OAAAzP,KAAAsQ,aAIA,IAAAM,GAAA3M,EAAA4M,QAAA7Q,KAAA8G,WAAA9G,KAAAsQ,aACAM,QACA5Q,KAAA8G,WAAAyG,OAAAqD,EAAA,GAEA5Q,KAAAsQ,aAAA,MASA04E,EAAA9jF,UAAAukF,iBAAA,SAAAriF,EAAAokE,GAEA,GAAAA,IAAApkE,EAAAm3E,eAAAn3E,EAAAm3E,cAAAp4E,OAAA,EAAA,CACAiB,EAAAtE,OAAAsE,EAAAtE,MAAAuD,IAAA,oBACAe,EAAAhE,QAAAyH,MAAA3C,SAAAd,EAAAtE,MAAAuD,IAAA,kBAEA,IAAAijF,GAAAtpF,KAAAupF,iBAAAniF,GACAg2E,EAAA,IACAh2E,GAAAhE,QAAA6H,UAAA7D,EAAAhE,QAAA6H,SAAAmyE,iBACAA,EAAAh2E,EAAAhE,QAAA6H,SAAAmyE,eAEA,IAAA4O,GAAAhsF,KAAAisF,iBAAA7kF,EAAAhE,QAAAyH,MAAA3C,SAAAohF,EAAA,GACAA,EAAA,GACAA,EAAA,GAAAA,EAAA,GAAAlM,EAEAh2E,GAAA60B,QAAA+vD,EAAA,GAAA,IAGA5kF,EAAA+4E,gBAIA6I,EAAA9jF,UAAAqkF,iBAAA,SAAAniF,GACA,GAAAyF,GAAAzF,EAAAyF,UACAC,EAAA1F,EAAA0F,QACAo/E,GAAA,CACAA,GAAAr/E,EAAA1E,SAAA2E,EAAA3E,MAEA,IAAAqiF,GAAA39E,EAAA4F,QAAA5F,EAAA4F,UAAAmE,aAAAmV,EAAAtZ,QAAA5F,EAAAq/E,GAAAt1E,aACAu1E,GAAA5pE,OAAAioE,EAAA/4E,GAAA8Q,OAAAioE,EAAA74E,GAAA4Q,OAAAioE,EAAA/4E,GAAA8Q,OAAAioE,EAAAv7E,OAAAsT,OACAioE,EAAA74E,GAAA4Q,OAAAioE,EAAAt7E,SAEAu7E,EAAA39E,EAAA2F,QAAA3F,EAAA2F,UAAAmE,aAAAmV,EAAAtZ,QAAA3F,EAAAo/E,GAAAt1E,aACAw1E,GAAA7pE,OAAAkoE,EAAAh5E,GAAA8Q,OAAAkoE,EAAA94E,GAAA4Q,OAAAkoE,EAAAh5E,GAAA8Q,OAAAkoE,EAAAx7E,OAAAsT,OACAkoE,EAAA94E,GAAA4Q,OAAAkoE,EAAAv7E,SAGAw7E,EAAA3+D,EAAApZ,mBAAA63E,EAAA39E,GACA89E,EAAA5+D,EAAApZ,mBAAA83E,EAAA39E,GAGA7B,EAAA7D,EAAAhE,QAAA6H,QACA,IAAAA,EAAA0kB,UAAA,CACA,GAAAxa,GAAAlK,EAAA0kB,UAAAva,MAAA,IACAnK,GAAAwI,SAAA0B,EAAA,GACAlK,EAAAmI,OAAA+B,EAAA,GAEAlK,EAAAwI,UAAAxI,EAAAmI,SACAo3E,EAAA/4E,EAAAg5E,EAAAh5E,GACAxG,EAAAwI,SAAA,QACAxI,EAAAmI,OAAA,SAEAnI,EAAAwI,SAAA,OACAxI,EAAAmI,OAAA,SAGA,IAAA0oD,GAAA97D,KAAAqsF,oBAAAphF,EAAAwI,SAAAi3E,GACA3uB,EAAA/7D,KAAAqsF,oBAAAphF,EAAAmI,OAAAu3E,EAGA,OAFA7uB,GAAAn1D,IAAA,GAAA3C,GAAAiH,EAAAiyE,YAAA,GAAAjyE,EAAAiyE,YAAA,KACAnhB,EAAAp1D,IAAA,GAAA3C,GAAAiH,EAAAkyE,UAAA,GAAAlyE,EAAAkyE,UAAA,MACArhB,EAAAC,EAAAowB,EAAAC,IAGApD,EAAA9jF,UAAAmnF,oBAAA,SAAAp/E,EAAAoE,GACA,GAAAquD,IACA5sD,IAAAzB,EAAAyB,IAAArB,EACAmB,KAAAvB,EAAAuB,KAAAjB,EACAkB,MAAAxB,EAAAwB,MAAAlB,EACAoB,OAAA1B,EAAA0B,OAAAtB,EACAuG,OAAA3G,EAAA2G,OAAAvG,GAGA66E,EAAA,YAAAr/E,EAAA,OACA6U,EAAA3I,SAAA4S,EAAAizC,SAAAstB,GAAA5sB,GACA,IAAAzyD,EAAA4D,QAAA,WACA,MAAA,IAAA7M,GAAA8d,EAAAzQ,EAAAyB,IAAAnB,EACS,IAAA1E,EAAA4D,QAAA,YACT,MAAA,IAAA7M,GAAAqN,EAAAuB,KAAAnB,EAAAqQ,EACS,IAAA7U,EAAA4D,QAAA,aACT,MAAA,IAAA7M,GAAAqN,EAAAwB,MAAApB,EAAAqQ,EACS,IAAA7U,EAAA4D,QAAA,cACT,MAAA,IAAA7M,GAAA8d,EAAAzQ,EAAA0B,OAAApB,EACS,IAAA1E,EAAA4D,QAAA,cACT,MAAA,IAAA7M,GAAA8d,EAAAzQ,EAAA0B,OAAApB,EAEA,MAAA,IAAAgW,OAAA,YAYAqhE,EAAA9jF,UAAA8O,oBAAA,SAAAnH,EAAA4M,EAAAvR,EAAAuL,EAAAL,EAAAtG,GACA,GAAA29E,GAAA,KACA2B,EAAA,KACA5B,EAAA39E,EAAA4F,QAAA5F,EAAA4F,UAAAmE,aAAAmV,EAAAtZ,QAAA5F,GAAA,GAAA+J,aACAu1E,GAAA5pE,OAAAioE,EAAA/4E,GAAA8Q,OAAAioE,EAAA74E,GAAA4Q,OAAAioE,EAAA/4E,GAAA8Q,OAAAioE,EAAAv7E,OAAAsT,OACAioE,EAAA74E,GAAA4Q,OAAAioE,EAAAt7E,SAEAw7E,EAAA3+D,EAAApZ,mBAAA63E,EAAA39E,EAEA7M,MAAA8rF,gBACA9rF,KAAA8rF,cAAA,GAAAznF,IACA8J,QAAA,EACAtD,OACA3C,SAAAA,KAKA,IAAAd,GAAApH,KAAA8rF,cAEA7gF,EAAA7D,EAAAhE,QAAA6H,QACAA,GAAAwI,SAAAA,EAAAA,EAAA+2E,EAAA/4E,EAAAgI,EAAAhI,EAAA,QAAA,OACAxG,EAAAmI,OAAAA,EAAAA,EAAAo3E,EAAA/4E,EAAAgI,EAAAhI,EAAA,OAAA,QAEArK,EAAAhE,QAAAyH,MAAA3C,SAAAA,EACA4E,IACA29E,EAAA39E,EAAA2F,QAAA3F,EAAA2F,UAAAmE,aAAAmV,EAAAtZ,QAAA3F,GAAA,GAAA8J,aACAw1E,GAAA7pE,OAAAkoE,EAAAh5E,GAAA8Q,OAAAkoE,EAAA94E,GAAA4Q,OAAAkoE,EAAAh5E,GAAA8Q,OAAAkoE,EAAAx7E,OAAAsT,OACAkoE,EAAA94E,GAAA4Q,OAAAkoE,EAAAv7E,SAEA,IAAA88E,GAAAhsF,KAAAisF,iBAAA/jF,EAAAwiF,EAAAz/E,EAAAwI,UAAAgG,EACA0yE,EAAAC,EAGA,OADAhlF,GAAA60B,QAAA+vD,EAAA,GAAA,IACA5kF,GAWA4hF,EAAA9jF,UAAA6O,2BAAA,SAAA+nD,EAAAhvD,EAAA5E,EAAAkL,EAAAK,EAAA5G,GACA,GAAA29E,GAAA,KACA2B,EAAA,KACA1B,EAAA39E,EAAA2F,QAAA3F,EAAA2F,UAAAmE,aAAAmV,EAAAtZ,QAAA3F,GAAA,GAAA8J,aACAw1E,GAAA7pE,OAAAkoE,EAAAh5E,GAAA8Q,OAAAkoE,EAAA94E,GAAA4Q,OAAAkoE,EAAAh5E,GAAA8Q,OAAAkoE,EAAAx7E,OAAAsT,OAAAkoE,EAAA94E,GAAA4Q,OAAAkoE,EAAAv7E,SACAy7E,EAAA5+D,EAAApZ,mBAAA83E,EAAA39E,EACA9M,MAAA8rF,gBACA9rF,KAAA8rF,cAAA,GAAAznF,IACA8J,QAAA,EACAtD,OACA3C,SAAAA,KAIA,IAAAd,GAAApH,KAAA8rF,cACA7gF,EAAA7D,EAAAhE,QAAA6H,QACAA,GAAAmI,OAAAA,EAAAA,EAAAq3E,EAAAh5E,EAAAqqD,EAAArqD,EAAA,QAAA,OACAxG,EAAAwI,SAAAA,EAAAA,EAAAg3E,EAAAh5E,EAAAqqD,EAAArqD,EAAA,OAAA,QAEArK,EAAAhE,QAAAyH,MAAA3C,SAAAA,EACA2E,IACA29E,EAAA39E,EAAA4F,QAAA5F,EAAA4F,UAAAmE,aAAAmV,EAAAtZ,QAAA5F,GAAA,GAAA+J,aACAu1E,GAAA5pE,OAAAioE,EAAA/4E,GAAA8Q,OAAAioE,EAAA74E,GAAA4Q,OAAAioE,EAAA/4E,GAAA8Q,OAAAioE,EAAAv7E,OAAAsT,OACAioE,EAAA74E,GAAA4Q,OAAAioE,EAAAt7E,SAEA,IAAA88E,GAAAhsF,KAAAisF,iBAAA/jF,EAAA4zD,EAAA6uB,EAAA1/E,EAAAmI,QACA+4E,EAAAC,EAGA,OADAhlF,GAAA60B,QAAA+vD,EAAA,GAAA,IACA5kF,GAOA4hF,EAAA9jF,UAAAmP,oBAAA,SAAAwtB,GACA7hC,KAAA8rF,gBACAjqD,EAAApyB,OAAAzP,KAAA8rF,eACA9rF,KAAA8rF,cAAA,OAcA9C,EAAA9jF,UAAA+mF,iBAAA,SAAAnmF,EAAAg2D,EAAAC,EAAAowB,EAAAC,EACAhP,GACA,GAAAmP,IAAA,GAAA,GACAnP,KAIAmP,EAHAtoF,EAAAiJ,QAAAkwE,GAGAA,GAFAA,EAAAA,IAMA2O,EAAAjrF,MAAA,uCAGAirF,EAAAS,KAAA,wCAAA1mF,EAAA,KAAAg2D,EAAA,KAAAC,EACA,KAAAowB,EAAA,KAAAC,EAAA,IACA,IAAAJ,KAIA,QAAAlmF,GACA,IAAAzB,GAAAkI,WAEA,IAAAlI,GAAAoM,cACA,GAAAsS,IAAA+4C,EAAA11D,QAAA21D,EAAA31D,QACA4lF,GAAAxiF,MAAA,WAAA,WAAAuZ,GACA,MAEA,KAAA1e,GAAAsM,WAEA,IAAAtM,GAAAqM,YACA,GAAA+7E,GAAA,KACAC,EAAA,IAGA,IAAA,MAAAP,EAAA,CACA,GAAAQ,KAEAA,GAAAnjF,KAAA,GAAAxF,GAAA83D,EAAArqD,EAAA06E,EAAA,GAAAI,EAAA,KACAI,EAAAnjF,KAAA,GAAAxF,GAAAmoF,EAAA,GAAAI,EAAA,GAAAzwB,EAAAnqD,IACAg7E,EAAAnjF,KAAA,GAAAxF,GAAA83D,EAAArqD,EAAA06E,EAAA,GAAAI,EAAA,KACAI,EAAAnjF,KAAA,GAAAxF,GAAAmoF,EAAA,GAAAI,EAAA,GAAAzwB,EAAAnqD,IAGA86E,EAAAE,EAAA,EACA,KAAA,GAAAt/E,GAAA,EAAmCA,EAAAs/E,EAAAxmF,OAA2BkH,IAC9D0e,EAAArH,SAAAo3C,EAAA6wB,EAAAt/E,IAAA0e,EAAArH,SAAAo3C,EACA2wB,KACAA,EAAAE,EAAAt/E,IAOA,GAAA,MAAA++E,EAAA,CACA,GAAAO,KAEAA,GAAAnjF,KAAA,GAAAxF,GAAA+3D,EAAAtqD,EAAA26E,EAAA,GAAAG,EAAA,KACAI,EAAAnjF,KAAA,GAAAxF,GAAAooF,EAAA,GAAAG,EAAA,GAAAxwB,EAAApqD,IACAg7E,EAAAnjF,KAAA,GAAAxF,GAAA+3D,EAAAtqD,EAAA26E,EAAA,GAAAG,EAAA,KACAI,EAAAnjF,KAAA,GAAAxF,GAAAooF,EAAA,GAAAG,EAAA,GAAAxwB,EAAApqD,IAGA+6E,EAAAC,EAAA,EACA,KAAA,GAAAt/E,GAAA,EAAmCA,EAAAs/E,EAAAxmF,OAA2BkH,IAC9D0e,EAAArH,SAAAq3C,EAAA4wB,EAAAt/E,IAAA0e,EAAArH,SAAAq3C,EACA2wB,KACAA,EAAAC,EAAAt/E,IAMA,GAAA04B,IAAA+1B,GACA8wB,EAAA,CACAH,KACA1mD,EAAAv8B,KAAAijF,GACAG,EAAA,GAEAF,GACA3mD,EAAAv8B,KAAAkjF,GAEA3mD,EAAAv8B,KAAAuyD,EAKA,IAAA8wB,GAAA7oF,EAAA+6D,WAAAh5B,EACAimD,GAAAxiF,MAAA,KAAA,KAAAqjF,GAKA,IAAAC,GAAA9oF,EAAA+6D,WAAAh5B,GAGAgnD,EAAA/oF,EAAA+6D,WAAA+tB,EACAC,GAAAx/E,OAAAq/E,EAAA,EAAA,EAAA,GAAA5oF,GAAA+oF,EAAAH,GAAAn7E,EAAAs7E,EAAAH,EAAA,GAAAj7E,IACAq6E,EAAAxiF,MAAA,KAAA,OAAAujF,GAGA,IAAAC,GAAAhpF,EAAA+6D,WAAA+tB,EACAE,GAAAz/E,OAAAq/E,EAAA,EAAA,EAAA,GAAA5oF,GAAAgpF,EAAAJ,EAAA,GAAAn7E,EAAAu7E,EAAAJ,GAAAj7E,IACAq6E,EAAAxiF,MAAA,KAAA,OAAAwjF,GAMA,IAAAC,GAAAjpF,EAAA+6D,WAAAh5B,GACAmnD,EAAA,GAAAlpF,IAAAipF,EAAAL,GAAAn7E,EAAAw7E,EAAAL,EAAA,GAAAn7E,GAAA,EAAAw7E,EAAAL,GAAAj7E,GACAw7E,EAAA,GAAAnpF,IAAAipF,EAAAL,GAAAn7E,EAAAw7E,EAAAL,EAAA,GAAAn7E,GAAA,EAAAw7E,EAAAL,EAAA,GAAAj7E,EACAs7E,GAAA1/E,OAAAq/E,EAAA,EAAA,EAAAM,EAAAC,GACAnB,EAAAxiF,MAAA,KAAA,OAAAyjF,GAKA,IAAAG,GAAAppF,EAAA+6D,WAAAh5B,GACAsnD,EAAA,GAAArpF,GAAAopF,EAAAR,GAAAn7E,GAAA27E,EAAAR,GAAAj7E,EAAAy7E,EAAAR,EAAA,GAAAj7E,GAAA,GACA27E,EAAA,GAAAtpF,GAAAopF,EAAAR,EAAA,GAAAn7E,GAAA27E,EAAAR,GAAAj7E,EAAAy7E,EAAAR,EAAA,GAAAj7E,GAAA,EACAy7E,GAAA7/E,OAAAq/E,EAAA,EAAA,EAAAS,EAAAC,GACAtB,EAAAxiF,MAAA,KAAA,OAAA4jF,GAIA,IAAAG,GAAAvpF,EAAA+6D,WAAAh5B,GAIAynD,GAAAD,EAAAX,GAAAn7E,EAAA,GAAA87E,EAAAX,EAAA,GAAAn7E,EAAA,GAEA06E,IACAqB,EAAAhkF,KAAA2iF,EAAA,GAAA,IAGAC,GACAoB,EAAAhkF,KAAA4iF,EAAA,GAAA,GAGA,IAAAqB,GAAA1hE,EAAA7H,IAAAspE,GACAE,EAAA,GAAA1pF,GAAAypF,EAAAF,EAAAX,GAAAj7E,GACAg8E,EAAA,GAAA3pF,GAAAypF,EAAAF,EAAAX,EAAA,GAAAj7E,EACA47E,GAAAhgF,OAAAq/E,EAAA,EAAA,EAAAc,EAAAC,GACA3B,EAAAxiF,MAAA,KAAA,OAAA+jF,GAIA,IAAAK,GAAA5pF,EAAA+6D,WAAAh5B,GAIA8nD,GAAAD,EAAAhB,GAAAj7E,EAAA,GAAAi8E,EAAAhB,EAAA,GAAAj7E,EAAA,GAEAw6E,IACA0B,EAAArkF,KAAA2iF,EAAA,GAAA,IAGAC,GACAyB,EAAArkF,KAAA4iF,EAAA,GAAA,GAGA,IAAA0B,GAAA/hE,EAAA9H,IAAA4pE,GACAE,EAAA,GAAA/pF,GAAA4pF,EAAAhB,GAAAn7E,EAAAq8E,GACAE,EAAA,GAAAhqF,GAAA4pF,EAAAhB,EAAA,GAAAn7E,EAAAq8E,EACAF,GAAArgF,OAAAq/E,EAAA,EAAA,EAAAmB,EAAAC,GACAhC,EAAAxiF,MAAA,KAAA,OAAAokF,GAIA,IAAAK,GAAAjqF,EAAA+6D,WAAAh5B,GAIAmoD,GAAAD,EAAArB,GAAAn7E,EAAA,GAAAw8E,EAAArB,EAAA,GAAAn7E,EAAA,GAEA06E,IACA+B,EAAA1kF,KAAA2iF,EAAA,GAAA,IAGAC,GACA8B,EAAA1kF,KAAA4iF,EAAA,GAAA,GAGA,IAAA+B,GAAApiE,EAAA9H,IAAAiqE,GACAE,EAAA,GAAApqF,GAAAmqF,EAAAF,EAAArB,GAAAj7E,GACA08E,EAAA,GAAArqF,GAAAmqF,EAAAF,EAAArB,EAAA,GAAAj7E,EACAs8E,GAAA1gF,OAAAq/E,EAAA,EAAA,EAAAwB,EAAAC,GACArC,EAAAxiF,MAAA,KAAA,OAAAykF,GAIA,IAAAK,GAAAtqF,EAAA+6D,WAAAh5B,GAIAwoD,GAAAD,EAAA1B,GAAAj7E,EAAA,GAAA28E,EAAA1B,EAAA,GAAAj7E,EAAA,GAEAw6E,IACAoC,EAAA/kF,KAAA2iF,EAAA,GAAA,IAGAC,GACAmC,EAAA/kF,KAAA4iF,EAAA,GAAA,GAGA,IAAAoC,GAAAziE,EAAA7H,IAAAqqE,GACAE,EAAA,GAAAzqF,GAAAsqF,EAAA1B,GAAAn7E,EAAA+8E,GACAE,EAAA,GAAA1qF,GAAAsqF,EAAA1B,EAAA,GAAAn7E,EAAA+8E,EACAF,GAAA/gF,OAAAq/E,EAAA,EAAA,EAAA6B,EAAAC,GACA1C,EAAAxiF,MAAA,KAAA,OAAA8kF,IAiBAvC,EAAAS,KAAA,8DAAAR,EAAA7lF,OAEA,KAAA,GADAwoF,MACA7rD,EAAA,EAA+BA,EAAAkpD,EAAA7lF,OAAsB28B,IAAA,CACrD,GAAA8rD,GAAA5C,EAAAlpD,GAAA,EACA/W,GAAA2vC,eAAAkzB,IACAD,EAAAnlF,KAAAwiF,EAAAlpD,IAQA,GALAkpD,EAAA2C,EACA5C,EAAAS,KAAA,6BAAAR,EAAA7lF,QAIA21D,EAAAuF,OAAAtF,GACAgwB,EAAAS,KACA,iGAEiB,CACjBT,EAAAS,KAAA,4DAAAR,EAAA7lF,OAGA,KAAA,GAFA0oF,MACAC,GAAA,GACAhsD,EAAA,EAAmCA,EAAAkpD,EAAA7lF,OAAsB28B,IAAA,CACzD,GAAA8rD,GAAA5C,EAAAlpD,GAAA,EACA/W,GAAA8wC,YAAA+xB,GACAC,EAAArlF,KAAAwiF,EAAAlpD,IAEAgsD,GAAAA,GAAA,OAAAF,EAGA5C,EAAA6C,EACA9C,EAAAS,KAAA,2BAAAR,EAAA7lF,QACA,GAAA6lF,EAAA7lF,QACA4lF,EAAAS,KAAA,wBAAAsC,IAMA/C,EAAAS,KAAA,oEAAAR,EAAA7lF,OAEA,KAAA,GADA4oF,OACAjsD,EAAA,EAA+BA,EAAAkpD,EAAA7lF,OAAsB28B,IAAA,CACrD,GAAA8rD,GAAA5C,EAAAlpD,GAAA,GAEA0jB,IAAA,EAEAwoC,GAAAJ,EAAAhmE,SAIAwjE,GAAAD,KAEA6C,GAAAA,GAAApmE,MAAA,EAAAomE,GAAA7oF,OAAA,IAOAgmF,IACA3lC,GAAAA,IAAAz6B,EAAAswC,4BAAA2yB,GAAA7C,IAEAC,IACA5lC,GAAAA,IAAAz6B,EAAAswC,4BAAA2yB,GAAA5C,IAGA5lC,IACAuoC,GAAAvlF,KAAAwiF,EAAAlpD,IAKA,GAAAisD,GAAA5oF,SAEA6lF,EAAA+C,IAGAhD,EAAAS,KAAA,mCAAAR,EAAA7lF,QAIA4lF,EAAAS,KAAA,uDACA,GAAAR,EAAA7lF,QACA4lF,EAAAS,KAAA,uBAOA,KAAA,GAJAyC,IAAAjD,EAAA,GAAA,GACAkD,GAAAD,GAAA9oF,OACAgpF,MAEArsD,EAAA,EAA+BA,EAAAkpD,EAAA7lF,OAAsB28B,IAAA,CACrD,GAAA8rD,GAAA5C,EAAAlpD,GAAA,EACA8rD,GAAAzoF,QAAA+oF,IACAC,GAAA3lF,KAAAwiF,EAAAlpD,IAIAkpD,EAAAmD,GASApD,EAAAS,KAAA,mEAEA,KAAA,GADA4C,IAAA,EACAtsD,EAAA,EAA+BA,EAAAkpD,EAAA7lF,OAAsB28B,IAAA,CACrD,GAAA8rD,GAAA5C,EAAAlpD,GAAA,EACA/W,GAAA2wC,UAAAsvB,EAAAoD,IAAA,IAAArjE,EAAA2wC,UAAAsvB,EAAAlpD,GAAA,MACAssD,GAAAtsD,GAGAkpD,GAAAA,EAAAoD,KAcA,MAPAtpF,KAAAzB,EAAAsM,YACA3Q,KAAAqvF,YAAArD,GAIAD,EAAAuD,WAEAtD,GAGAhD,EAAA9jF,UAAAmqF,YAAA,SAAArD,GACA,GAAAjmF,GAAA,CAEA,QAAAA,GACA,IAAA,GAEA,KAEA,KAAA,GAIA,IAAA,GAAAggC,GAAA,EAA+BA,EAAAimD,EAAA7lF,OAAsB4/B,IAAA,CACrD,GAAAwpD,GAAAvD,EAAAjmD,GAAA,GAGAk2B,EAAAszB,EAAA,GACApzB,EAAAozB,EAAA,GACAC,EAAAzjE,EAAA0jE,UAAAxzB,EAAAE,EACAozB,GAAAhiF,OAAA,EAAA,EAAAiiF,EAGA,IAAAE,GAAAH,EAAAA,EAAAppF,OAAA,GACAwpF,EAAAJ,EAAAA,EAAAppF,OAAA,GACAypF,EAAA7jE,EAAA0jE,UAAAC,EAAAC,EACAJ,GAAAhiF,OAAAgiF,EAAAppF,OAAA,EAAA,EAAAypF,GAEA,KAEA,KAAA,GAEA3rF,EAAA4E,KAAAmjF,EAAA,SAAA4C,GACA,GAAAiB,GAAAjB,EAAA,EACA,IAAA,MAAAiB,GAAA,MAAAA,EAAA,CACA,GAAAN,GAAAX,EAAA,EACAW,GAAAhiF,OAAA,EAAA,GACAgiF,EAAAhiF,OAAAgiF,EAAAppF,OAAA,EAAA,KAGA,MAEA,KAAA,GAGAlC,EAAA4E,KAAAmjF,EAAA,SAAA4C,GACA,GAAAiB,GAAAjB,EAAA,EACA,IAAA,MAAAiB,EAAA,CACA,GAAAN,GAAAX,EAAA,GACAkB,EAAA/jE,EAAA+yC,mBAAAywB,EACAX,GAAA,GAAAkB,OAQAjwF,EAAAD,QAAAopF,G5F++tBM,SAAUnpF,EAAQD,G6FhrvBxB,GAAAmsF,IACAgE,eAAA,EAEAC,gBAAA,EAEAC,eAAA,EAEAC,gBAAA,EAEAv9C,MAAA3yC,KAAAkwF,gBAMAC,MAAA,SAAA98D,GACA,mBAAAmrB,UACAx+C,KAAA2yC,OAAA3yC,KAAAgwF,iBAGA,kBAAAxxC,SAAA2xC,OACA3xC,QAAA2xC,MAAA98D,IAcAm5D,KAAA,SAAAn5D,GACA,mBAAAmrB,UACAx+C,KAAA2yC,OAAA3yC,KAAAiwF,gBACAzxC,QAAAguC,KAAAn5D,IASA2tD,MAAA,SAAA3tD,GACA,mBAAAmrB,UACAx+C,KAAA2yC,OAAA3yC,KAAAkwF,iBACA1xC,QAAAwiC,MAAA3tD,IAUAvyB,MAAA,SAAAsvF,GACApwF,KAAA2yC,OAAA3yC,KAAAiwF,gBACA,mBAAAzxC,UAGA,kBAAAA,SAAA19C,OACA09C,QAAA19C,MAAAsvF,IAOAd,SAAA,WACAtvF,KAAA2yC,OAAA3yC,KAAAiwF,gBACA,mBAAAzxC,UAGA,kBAAAA,SAAA8wC,UACA9wC,QAAA8wC,YASAvD,GAAAp5C,MAAAo5C,EAAAmE,gBAGArwF,EAAAD,QAAAmsF,G7F8rvBM,SAAUlsF,EAAQD,G8F3xvBxBC,EAAAD,SACAsD,aAAA,cACAC,KAAA,OACA4G,WAAA,YACAU,QAAA,UACAgV,SAAA,WACA4D,GAAA,KACA2mE,SAAA,cACAC,OAAA,YACA9mE,MAAA,QACAC,WAAA,aACAitE,eAAA,gBACAC,MAAA,QACAC,WAAA,YACAxG,WAAA,aACA9/E,OAAA,SACAumF,UAAA,WACAC,QAAA,kBACAC,eAAA,iBACAC,kBAAA,oBACAxW,IAAA,MACAyW,KAAA,WACAC,KAAA,SACAlW,MAAA,U9FwyvBM,SAAU96E,EAAQD,EAASM,G+F/xvBjC,QAAAuJ,GAAA3G,EAAAhC,GACA,GAAAgwF,KA2BA,OA1BAhwF,GAAAqI,UAAA,SAAAC,GACA,GAAAA,EAAAtG,MAAA,CAEA,GAAAsG,YAAA5E,GAAA,CACA,GAAAusF,KACA3nF,GAAAD,UAAA,SAAAI,GACAA,EAAAzG,QACAyG,YAAAlF,GACAkF,EAAA83E,eAEA93E,EAAAzG,MAAAE,IAAA,mBAAAuG,EAAA0B,UAEA8lF,EAAAvnF,KAAAD,EAAAzG,MAAAiD,WAGAqD,EAAAtG,MAAAE,IAAAC,EAAAgH,OAAA8mF,GAEA3nF,YAAA/E,IACA+E,EAAAi4E,eAEAyP,EAAAtnF,KAAAJ,EAAAtG,MAAAiD,WAKAjD,EAAAE,IAAAC,EAAAgH,OAAA6mF,GACAhuF,EAAAiD,OAUA,QAAA2D,GAAAsnF,EAAAlwF,EAAAmwF,EAAAC,EAAAlnF,EAAAJ,GAGA,IAAA,GAFA9C,MAEAuG,EAAA,EAAuBA,EAAA4jF,EAAA9qF,OAAwBkH,IAAA,CAC/C,GAAApG,GAAAgqF,EAAA5jF,EACA,IAAApG,EAAAoS,cAAApW,EAAA8mF,WACAjjF,EAAA0C,KAAAvC,OACa,IAAAA,EAAAoS,cAAApW,EAAAkgB,MAAA,CACb,GAAAguE,GAAAC,EAAAJ,EAAAvvF,SAAAwF,EAAAoqF,WACAL,GAAAruE,YAAAwuE,EAAAlqF,EAAA7D,aACa,IAAA6D,EAAAoS,cAAApW,EAAAstF,YAAAtpF,EAAAoS,cAAApW,EAAAqtF,MAAA,CAGb,GAAAgB,GAAAN,EAAA7zE,WAAAla,EAAAqtF,MAAArpF,EAAA7D,QAAA6D,EAAAoW,SACApW,GAAAoC,QACAK,EAAAsnF,EAAAM,EAAArqF,EAAAoC,QAAA,EAAAW,EAAAJ,GAIAsnF,EACApwF,EAAA6F,IAAA2qF,GAEAN,EAAA9mF,QAAAonF,KAAyD1nF,OAI5C,CAEb,GAAAR,GAAA4nF,EAAA7zE,WAAAlW,EAAAoS,YAAApS,EAAA7D,QAAA6D,EAAAoW,SAOA,IANA6zE,EACApwF,EAAA6F,IAAAyC,GAEA4nF,EAAA9mF,QAAAd,KAAiDQ,GAGjD3C,EAAA7D,QAAAsB,QACAuC,EAAA7D,QAAAsB,OAAAA,SAAAzB,EAAAutF,UAAA,CACA,GAAAe,GAAAH,EAAAJ,EAAAvvF,SAAAwF,EAAA5G,GACA2J,GAAAR,KAAA+nF,KASAttF,EAAA4E,KAAA/B,EAAA,SAAAwF,GACA,GAAAO,GAAAukF,EAAAJ,EAAAvvF,SAAA6K,EAAAklF,aACA1kF,EAAAskF,EAAAJ,EAAAvvF,SAAA6K,EAAAmlF,UACA,IAAA5kF,GAAAC,EAAA,CACA,GAAAub,GAAA2oE,EAAAzxE,WAAA1S,EAAAC,EAAAR,EAAAlJ,QAAAkJ,EAAA+Q,SACA6zE,GACApwF,EAAA6F,IAAA0hB,GAEA2oE,EAAA9mF,QAAAme,KAAiDze,OAEpC,CACb,GAAA8nF,GAAAjtF,EAAAgW,KAAAk3E,cAAArlF,EAAAlJ,QAAAkJ,EAAA+Q,SACA6zE,GACApwF,EAAA6F,IAAA+qF,GAEAV,EAAA9mF,QAAAwnF,KAAqD9nF,MAYrD,QAAAwnF,GAAA3vF,EAAA+T,GACA,GAAAo8E,GAAA,IAMA,OALAnwF,GAAA0L,QAAA,SAAA/D,GACAA,EAAA/I,KAAAmV,IACAo8E,EAAAxoF,KAGAwoF,EAQA,QAAA/f,GAAAhwC,EAAAhhC,GACAA,EAAAA,MACAA,EAAAuxE,WAAAvxE,EAAAuxE,YAAA,EACAvxE,EAAA6d,gBAAA7d,EAAA6d,iBACA,SACA,IAAAy/B,GAAAtc,EAAA2wB,QAAA6U,gBASA,OAPApjE,GAAA4E,KAAAs1C,EAAA,SAAAz0B,GAGA,IAAA,GAFAuY,GAAAvY,EAAAuY,UACA7R,EAAA6R,EAAA97B,OACAkH,EAAA,EAA2BA,EAAA+iB,EAAS/iB,IACpC40B,EAAA50B,GAAAwY,MAAA,KAGAgc,EAAAuhC,QAAAyO,kBAAAhxE,GAGA,QAAAyiB,GAAAue,EAAAhhC,GACAA,EAAAA,KACA,IAAAgxF,GAAAhgB,EAAAhwC,EAAAhhC,GAAAyiB,UACA,UAAAziB,GAAAA,EAAAiF,MAAA,QAEAq4C,EAAAtc,EAAA2wB,QAAA6U,gBASA,OAPApjE,GAAA4E,KAAAs1C,EAAA,SAAAz0B,GAGA,IAAA,GAFAuY,GAAAvY,EAAAuY,UACA7R,EAAA6R,EAAA97B,OACAkH,EAAA,EAA2BA,EAAA+iB,EAAS/iB,IACpC40B,EAAA50B,GAAAoH,UAGAo9E,EAGA,QAAAt1E,GAAAtR,GACA,GAAAwG,GAAA0H,SAAAlO,EAAA,GAAA,IACA0G,EAAAwH,SAAAlO,EAAA,GAAA,GAOA,OANAwG,GAAA,IACAA,EAAA,GAEAE,EAAA,IACAA,EAAA,IAEAF,EAAAE,GAGA,QAAAyW,GAAA7jB,GACA,GAAAutF,IACAx8E,KAAAA,EACAlN,OAAAA,EACAwC,MAAAA,EACAohB,KAAAA,EACAC,OAAAA,EACAC,KAAAA,EACA6lE,QAAAA,EACAC,MAAAA,EACAC,QAAAA,EACAC,KAAAA,EACAC,OAAAA,EACAhmE,QAAAA,EACA1W,KAAAA,EACAuN,SAAAA,EACAoJ,YAAAA,EACAC,IAAAA,EACA+lE,KAAAA,EACAC,SAAAA,EACA1mE,KAAAA,EACAllB,MAAAjC,EACA8tF,WAAAA,EAEA,KAAA,GAAAjqF,KAAAypF,GACAvtF,EAAA8D,GAAAypF,EAAAzpF,EAEA,OAAA9D,GAWA,QAAA2uB,GAAApR,GACA,GAAAsO,GAAAtO,EAAA3b,MACA,OAAA,gBAAA,IACA2b,EAAAA,EAAAA,EAAAA,GACS,IAAAsO,GAETtO,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACS,IAAAsO,GAETtO,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAEAA,EAGA,QAAAywE,GAAAp7D,GACA,MAAAA,GAAAR,QAAA,OAAA,IAAAA,QAAA,OAAA,IAGA,QAAA+rB,GAAAza,EAAAuqD,GACA,OAAAvqD,GACA,IAAA,SACA,IAAA,SACAA,EAAA,KACA,MACA,KAAA,OACA,IAAA,MACAA,EAAA,IACA,MACA,KAAA,QACA,IAAA,SACAA,EAAA,OAGA,MAAA,gBAAAA,GACAsqD,EAAAtqD,GAAAqsB,MAAA,MACAj9B,WAAA4Q,GAAA,IAAAuqD,EAGAn7D,WAAA4Q,GAGA,MAAAA,EAAAwzB,KAAAxzB,EAUA,QAAAwqD,GAAAt7D,EAAAu7D,GASA,MARAv7D,IAAAA,GAAA,IAAAka,cAAA1a,QAAA,QAAA,SAAA29B,EAAAq+B,GACA,MAAAA,GAAA/lB,gBAGA8lB,GAAAv7D,IACAA,EAAAA,EAAA9U,OAAA,GAAAuqD,cAAAz1C,EAAAvO,MAAA,IAGAuO,EA8CA,QAAAy7D,GAAAC,EAAAC,EAAAC,GACA9uF,EAAAiJ,QAAA4lF,KACAA,GAAAA,GAEA,IAAAE,GAAAF,EAAA3sF,MACA,KAAA6sF,EACA,MAAA,EAIA,KAAA,GADAC,GAAAH,EAAA,GAAAG,UACA5lF,EAAA,EAAuBA,EAAA4lF,EAAA9sF,OAAkBkH,IAAA,CACzC,GAAA6lF,GAAAC,EAAA9lF,GACAyU,EAAAsxE,EAAAF,EAAA,EACAL,GAAAA,EAAAl8D,QAAAy8D,EAAAF,GAAAH,EAAAM,EAAAvxE,GAAAA,GAEA,IAAA,GAAAwxE,GAAA,EAA+BA,EAAAN,EAAuBM,IACtD,IAAA,GAAAllD,GAAA,EAA2BA,EAAA6kD,EAAA9sF,OAAkBioC,IAAA,CAC7C,GAAA9E,GAAAwpD,EAAAQ,GAAAL,EAAA7kD,GACAykD,GAAAA,EAAAl8D,QACAy8D,EAAAD,EAAA/kD,GAAAklD,GACAP,EAAAM,EAAA/pD,GAAAA,GAKA,MAAAupD,GArXA,GAAA5vF,GAAA/C,EAAA,IACA+D,EAAA/D,EAAA,GACAsE,EAAAtE,EAAA,IACAoV,EAAApV,EAAA,IACAkI,EAAAlI,EAAA,IACA0K,EAAA1K,EAAA,IACA8rB,EAAA9rB,EAAA,KACA+rB,EAAA/rB,EAAA,KACAgsB,EAAAhsB,EAAA,KACA6xF,EAAA7xF,EAAA,KACA8xF,EAAA9xF,EAAA,KACA+xF,EAAA/xF,EAAA,KACAgyF,EAAAhyF,EAAA,KACAiyF,EAAAjyF,EAAA,KACAisB,EAAAjsB,EAAA,KACAuV,EAAAvV,EAAA,KACA8iB,EAAA9iB,EAAA,KACAksB,EAAAlsB,EAAA,KACAmsB,EAAAnsB,EAAA,KACAkyF,EAAAlyF,EAAA,KACAmyF,EAAAnyF,EAAA,KACAyrB,EAAAzrB,EAAA,KACAoyF,EAAApyF,EAAA,KACAmE,EAAAnE,EAAA,IACAuE,EAAAvE,EAAA,KAsSAqzF,EAAA,WACA,GAAA3iF,GAAA,CACA,OAAA,YACA,GAAA5K,GAAA,wBAAA4K,GACA,OAAA,UAAA4iF,GACA,MAAAA,GAAAxtF,KAAAwtF,EAAAxtF,YAIAqtF,EAAA,SAAApjE,GACA,MAAAhH,QAAAgH,GACA0G,QAAA,KAAA,SACAA,QAAA,KAAA,QACAA,QAAA,KAAA,QACAA,QAAA,KAAA,UACAA,QAAA,KAAA,UAGAw8D,GAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,KAEAC,EAAA,SAAAK,EAAAH,GACA,MAAA,IAAiBG,GAAA,MAAAH,EAAA,GAAAA,GAAA,IAsCjBzzF,GAAAD,SACA6J,OAAAA,EACAC,SAAAA,EACA4Z,UAAAA,EACA/G,cAAAA,EACA6L,iBAAAA,EACA8K,kBAAAA,EACAwvB,aAAAA,EACA+vC,YAAAA,EACAc,WAAAA,EACAX,UAAAA,EACAxB,aAAAA,I/F20vBM,SAAUvxF,EAAQD,EAASM,GgG1qwBjC,QAAAsE,GAAA3D,GACAb,KAAA8C,MAAAyB,EAAAmvF,SAAA,YAAA7yF,GACA8B,EAAA8D,MAAAlG,KAAAP,KAAAa,EAEA,IAAA87E,IACA11E,OACAgI,MAAA,EACAC,OAAA,EACA0C,EAAA,GAEA/G,OACAgH,KAAA,gBACAC,OAAA,iBAEA7G,UAAA,EAAA,GAEAjL,MAAAoD,QAAAa,EAAA8M,MAAA4rE,EAAA97E,GAAA,GAEAb,KAAAoD,QAAAsB,OAAA7D,EAAA6D,OACA1E,KAAAkkB,KAAA,KAAA,KACAlkB,KAAAm6D,OAAAn6D,KAAAoD,SA3BA,GAAAa,GAAA/D,EAAA,GACAssB,EAAAtsB,EAAA,IACAyC,EAAAzC,EAAA,GACA6D,EAAA7D,EAAA,IACAmE,EAAAnE,EAAA,IACAqE,EAAArE,EAAA,GAwBAsE,GAAAmvF,UAAA,kBACAnvF,EAAAU,WACAqrB,YAAA/rB,EACAsB,KAAA,YACAq0D,OAAA,SAAAr3D,GACA,GAAA0P,GAAA,GAAA7P,GAAA2S,MACArO,MAAAnE,EAAAmE,MACA4D,MAAA/H,EAAA+H,MAEAkH,EAAA,GAEAS,GAAAnK,KAAA7D,EAAAmvF,UACA3zF,KAAA2G,IAAA6L,GACAxS,KAAAiL,SAAAnI,EAAAmI,SACAjL,KAAA0K,YAAA5H,EAAA4H,aAEA8yB,YAAA,SAAA/rB,EAAAE,GACA,GAAAa,GAAAzO,EAAA0O,QAAAzS,KACA,OAAAwS,GAAAoE,aAAA+kB,QAAAlqB,EAAAE,IAGAhL,IAAA,SAAA4E,GAMA,MALAA,IAAAA,IAAAvL,MAAAuL,EAAApD,SAAAnI,OACAA,KAAAgyD,UAAAxoD,KAAA+B,GACAvL,KAAAqyD,OAAA9mD,IAEAvL,KAAA2B,MAAA3B,KAAA2B,KAAA6J,cAAAxL,KAAAuL,GACAvL,MASA6I,KAAA,SAAAgV,EAAAC,GAEA,IAAA,GADAxU,GAAAtJ,KAAAgyD,UACA3kD,EAAA,EAA2BA,EAAA/D,EAAAnD,OAAqBkH,IAAA,CAChD,GAAA9B,GAAAjC,EAAA+D,EACA9B,GAAAlD,MAAA7D,EAAAmvF,WACA91E,EAAAtd,KAAAud,EAAAvS,EAAA8B,GAGA,MAAArN,OAGAuK,WAAA,SAAAuvE,GACA95E,KAAAoD,QAAAsB,QACA1E,KAAA4zF,UAAA5zF,KAAAoD,QAAAsB,QAEA1E,KAAA6jB,eACA5c,OACAgI,MAAAjP,KAAAmP,kBAAAF,MACAC,OAAAlP,KAAAmP,kBAAAD,UAGAlP,KAAA2B,KAAAm4E,GAGA8Z,UAAA,SAAAC,GACAA,EAAAC,IAAA9zF,OAGAyS,QAAA,WACA,GAAAmE,GAAA5W,KAAAmP,kBACAgyB,EAAAnhC,KAAAmhC,QAEAA,KACAvqB,EAAAuqB,EAAAhyB,kBAGA,IAAA4T,KACAA,GAAA,KAAAnM,EAAA3H,MAAA,GAAA2H,EAAA1H,OAAA,GACA6T,EAAA,IAAAnM,EAAA3H,MAAA,GAAA2H,EAAA1H,OAAA,GACA6T,EAAA,IAAAnM,EAAA3H,MAAA,EAAA2H,EAAA1H,OAAA,GACA6T,EAAA,KAAAnM,EAAA3H,MAAA,EAAA2H,EAAA1H,OAAA,GACA6T,EAAA,KAAAnM,EAAA3H,MAAA,GAAA2H,EAAA1H,OAAA,EAEA,IAAAwvD,GAAA,GAAAlyC,GAAAxsB,KAAAiL,SAAA,GACAjL,KAAAiL,SAAA,GACA2L,EAAA3H,MAAA2H,EAAA1H,OACA,QACAuC,EAAAzR,KAAAiL,SAAA,GAAA2L,EAAA3H,MAAA,EACA0C,EAAA3R,KAAAiL,SAAA,GAAA2L,EAAA1H,OAAA,EACAD,MAAA2H,EAAA3H,MACAC,OAAA0H,EAAA1H,OACA6T,OAAAA,EACAnM,aAAA8nD,IAOAxiD,gBAAA,SAAAJ,GAEA,GAAAi4E,GAAA/zF,KAAAoD,QAAA6D,MAAA2K,CACA5R,MAAA6jB,eACA5c,OACAgI,MAAA8kF,EACA7kF,OAAA6kF,EACAniF,EAAAmiF,IAgBA,KAAA,GAZAvhF,GAAAxS,KAAAud,YAAA/Y,EAAAmvF,WACA/8E,EAAA5W,KAAAmP,kBACAF,EAAA2H,EAAA3H,MACAC,EAAA0H,EAAA1H,OACAmmB,EAAA7iB,EAAAvH,SAAA,GACAqqB,EAAA9iB,EAAAvH,SAAA,GAEA8Z,EAAA/kB,KAAAgyD,UAAA,GAAA/mD,SAAA,GACA+Z,EAAAhlB,KAAAgyD,UAAA,GAAA/mD,SAAA,GACAga,EAAAjlB,KAAAgyD,UAAA,GAAA/mD,SAAA,GACAia,EAAAllB,KAAAgyD,UAAA,GAAA/mD,SAAA,GACA+oF,EAAA/vF,EAAAmC,MAAA0V,EAAA7Q,UACAoC,EAAA,EAA2BA,EAAArN,KAAAgyD,UAAA7rD,OAA2BkH,IACtDrN,KAAAgyD,UAAA3kD,YAAAhJ,IAAA,GAAArE,KAAAgyD,UAAA3kD,GAAA4mF,SAGAlvE,EAAA/kB,KAAAgyD,UAAA3kD,GAAApC,SAAA,KACA8Z,EAAA/kB,KAAAgyD,UAAA3kD,GAAApC,SAAA,IAEAga,EAAAjlB,KAAAgyD,UAAA3kD,GAAApC,SAAA,KACAga,EAAAjlB,KAAAgyD,UAAA3kD,GAAApC,SAAA,IAEA+Z,EAAAhlB,KAAAgyD,UAAA3kD,GAAApC,SAAA,KACA+Z,EAAAhlB,KAAAgyD,UAAA3kD,GAAApC,SAAA,IAEAia,EAAAllB,KAAAgyD,UAAA3kD,GAAApC,SAAA,KACAia,EAAAllB,KAAAgyD,UAAA3kD,GAAApC,SAAA,IA8DA,IAxDAgE,EAAAjP,KAAAkkB,IAAA,IACAjV,EAAAjP,KAAAkkB,IAAA,GAAA,EACApI,EAAA7Q,SAAA,GAAA8Z,EACAivE,EAAA,GAAAjvE,EAAA/kB,KAAAkkB,IAAA,GAAApI,EAAA7M,MAEA+kF,EAAA,GAAA/uE,EAAAjlB,KAAAkkB,IAAA,GAAApI,EAAA7M,QAIAomB,EAAA7iB,EAAAvH,SAAA,GAAA6Q,EAAA7Q,SAAA,GACAoqB,EAAAtQ,IACAsQ,EAAAtQ,GAEAjJ,EAAAb,OACA+4E,EAAA,GAAAl4E,EAAAC,aAAA,GAAAD,EAAAE,MAEAg4E,EAAA,GAAAl4E,EAAA7Q,SAEA6Q,EAAA7Q,SAAA,GAAA8Z,EACAivE,EAAA,GAAAjvE,EAAA/kB,KAAAkkB,IAAA,GAAApI,EAAA7M,QACA+kF,EAAA,GAAAjvE,EAAA/kB,KAAAkkB,IAAA,GAAApI,EAAA7M,OAGA+kF,EAAA,GAAA/uE,EAAAjlB,KAAAkkB,IAAA,GAAApI,EAAA7M,QACA+kF,EAAA,GAAA/uE,EAAAjlB,KAAAkkB,IAAA,GAAApI,EAAA7M,QAIAC,EAAAlP,KAAAkkB,IAAA,IACAhV,EAAAlP,KAAAkkB,IAAA,GAAA,EACApI,EAAA7Q,SAAA,GAAA+Z,EACAgvE,EAAA,GAAAhvE,EAAAhlB,KAAAkkB,IAAA,GAAApI,EAAA5M,OAEA8kF,EAAA,GAAA9uE,EAAAllB,KAAAkkB,IAAA,GAAApI,EAAA5M,SAIAomB,EAAA9iB,EAAAvH,SAAA,GAAA6Q,EAAA7Q,SAAA,GACAqqB,EAAAtQ,IACAsQ,EAAAtQ,GAEAlJ,EAAAb,OACA+4E,EAAA,GAAAl4E,EAAAC,aAAA,GAAAD,EAAAG,MAEA+3E,EAAA,GAAAl4E,EAAA7Q,SAAA,GAEA6Q,EAAA7Q,SAAA,GAAA+Z,EACAgvE,EAAA,GAAAhvE,EAAAhlB,KAAAkkB,IAAA,GAAApI,EAAA5M,SACA8kF,EAAA,GAAAhvE,EAAAhlB,KAAAkkB,IAAA,GAAApI,EAAA5M,QAGA8kF,EAAA,GAAA9uE,EAAAllB,KAAAkkB,IAAA,GAAApI,EAAA5M,SACA8kF,EAAA,GAAA9uE,EAAAllB,KAAAkkB,IAAA,GAAApI,EAAA5M,SAIA4M,EAAA1S,KAAA+S,MAAA,CACA,GAAAC,IAAA43E,EAAA,GAAAl4E,EAAA1S,KAAA+F,kBAAAF,OAAA6M,EAAA1S,KAAA+S,MACAhN,kBAAAF,MAAA,GAAA+kF,EAAA,GAAAl4E,EAAA1S,KAAA+S,MAAAhN,kBACAD,OAAA,EAEA4M,GAAA1S,KAAA+S,MAAA3N,KAAA,WAAA4N,GAGApc,KAAA6jB,eACA5c,OACAgI,MAAAA,EACAC,OAAAA,EACAuC,EAAA4jB,EACA1jB,EAAA2jB,MAMAzR,cAAA,SAAA1Z,GACA,GAAAqI,GAAAxS,KAAAud,YAAA/Y,EAAAmvF,UACAnhF,GAAAoF,SAAAzN,EAAAlD,OAEAjH,KAAAwO,KAAA,WAAArE,EAAAc,WAIAK,OAAA,WACA,GAAApC,GAAAlJ,KAEAkjB,EAAAjf,EAAAmC,MAAApG,KAAAiL,UAEAgE,EAAAjP,KAAAmL,eAAAgE,kBAAAF,MACAC,EAAAlP,KAAAmL,eAAAgE,kBAAAD,OAEAglF,GAAAl0F,KAAAiL,SAAA,GAAAjL,KAAAud,YAAA/Y,EAAAmvF,WAAA1sF,MAAAwK,GAAAzR,KAAAmP,kBACAF,MAAA,EAAAA,EAAA,GAAAjP,KAAAiL,SAAA,GAAAjL,KAAAud,YAAA/Y,EAAAmvF,WAAA1sF,MAAA0K,GACA3R,KAAAmP,kBAAAD,OAAA,EAAAA,EAAA,IAGAilF,EAAAlwF,EAAAmC,MAAA8tF,EAoBA,OAnBAl0F,MAAAmL,eAAAqD,KAAA,SACA1D,MAAA9K,KAAA0K,YACAuE,MAAAA,EACAC,OAAAA,IAEAlP,KAAAmL,eAAAqD,KAAA,WAAA0lF,GACAjlF,EAAA,GAAAC,EAAA,IACAlP,KAAAqL,OACArL,KAAAmL,eAAAyC,QAIA5N,KAAAmL,eAAApE,GAAA,WAAA,WAEAmC,EAAAsF,KAAA,YAAA0U,EAAA,IAAAljB,KAAAiL,SAAA,GAAAkpF,EAAA,IACAjxE,EAAA,IAAAljB,KAAAiL,SAAA,GAAAkpF,EAAA,MACAn0F,KAAAqL,OACAnC,EAAA0E,SAEA5N,KAAAmL,gBAEAuN,YAAA,SAAAX,EAAAq8E,GACA,GAAAC,GAAA9xE,OAAAxK,GACA9Q,EAAAjH,KAAAoD,QAAA6D,MACAqtF,EAAA/xE,OAAAtb,EAAAgI,MAAAolF,GACAE,EAAAhyE,OAAA+xE,EAAArtF,EAAAiI,OAAAjI,EAAAgI,MACAmlF,KACAE,EAAAn7E,SAAAm7E,EAAA,IACAC,EAAAp7E,SAAAo7E,EAAA,KAGAv0F,KAAA6jB,eACA5c,OACAgI,MAAAqlF,EACAplF,OAAAqlF,KAIAv0F,KAAAsJ,WAAA6D,QAAA,SAAAC,GACA,GAAAnC,GAAAmC,EAAAnC,QACA,IAAAmC,EAAA/E,OAAA7D,EAAAmvF,WAAAvmF,YAAA/I,IAAA,UAAA+I,EAAAtH,MAIiB,GAAA,UAAAsH,EAAAtH,KAAA,CACjB,GAAA0M,GAAApF,EAAAoF,IACAA,GAAAtD,OAAAsD,EAAAtD,OAAAmlF,EACA7hF,EAAAvD,MAAAuD,EAAAvD,MAAAolF,EACAjnF,EAAAoB,MACAvD,UAAAA,EAAA,GAAAopF,EAAAppF,EAAA,GAAAopF,GACA7hF,KAAAA,SARApF,GAAAsL,YAAAX,EAAAq8E,GACAhnF,EAAAoB,KAAA,YAAAvD,EAAA,GAAAopF,EAAAppF,EAAA,GAAAopF,QAcApwF,EAAAkpB,SAAA3oB,EAAA7B,EAAA8D,OACA5G,EAAAD,QAAA4E,GhGkwwBM,SAAU3E,EAAQD,EAASM,GiGvmxBjC,YAuCA,IAAAyrB,GAAAzrB,EAAA,GACA+C,EAAA/C,EAAA,IACA+D,EAAA/D,EAAA,GACA6D,EAAA7D,EAAA,IACA6C,EAAA7C,EAAA,IACAqE,IAKAA,GAAAmvF,SAAA,SAAA5tF,EAAAjF,GACA,GAAAiC,GAAA,GAAAC,MA6BA,OA3BAlC,GAAAR,KACAQ,EAAAR,GAAA0D,EAAAk3D,WAEAp6D,EAAAgK,OAAA,IAAAhK,EAAAgK,MAAAk0B,iBAAAl+B,EAAAgK,MAAAq1B,OACAr/B,EAAAgK,MAAAq1B,SAEAp9B,EAAAE,IAAAC,EAAAC,aAAA4C,GAEAjF,EAAAgK,OAAAhK,EAAAgK,MAAAozB,YACAp9B,GAAAgK,MAAAozB,KAEAn7B,EAAAE,IAAAC,EAAAwH,QAAAxG,EAAAmC,MAAAvF,IACA,aAAAA,KACAA,EAAAka,YAAAla,EAAAmR,gBACAnR,GAAAmR,WAEAnR,EAAAkR,IACAlR,EAAAkR,EAAA,GAGAhO,EAAAoI,YAAAtL,EAAAiL,kBACAjL,EAAAiL,gBAAA,GAGA/H,EAAAoI,YAAAtL,EAAAuL,cACAvL,EAAAuL,YAAA,GAEAtJ,GAGAyB,EAAAyH,kBAAA,SAAA5C,GACA,GAAA6K,GAAAhQ,EAAAmC,MAAAgD,EAAA6K,SAAA,EAAA,GACAugF,EAAA,WACAx0F,KAAAyrB,WACAxX,OAAA,IAAAA,EAAA,GAAA,IAAAA,EAAA,KACa,IAAA,eAEbwgF,EAAA,WACAz0F,KAAAyrB,WACAxX,MAAAA,GACa,IAAA,cAEb7K,GAAArC,GAAA,YAAAytF,GACAztF,GAAA,WAAA0tF,GACA1tF,GAAA,WAAAytF,GACAztF,GAAA,SAAA0tF,IAcAlwF,EAAAugB,OAAA,SAAA5G,GACA,GAAAqe,GAAA,SAAA17B,GACAb,KAAA8C,MAAAyB,EAAAmvF,SAAAx1E,EAAApY,KAAAjF,GACA8qB,EAAAprB,KAAAP,KAAAa,GAEAqd,EAAArT,OAEA7K,KAAA6K,MAAA2xB,WAAAte,EAAArT,OAAA,EAIA,IAAA4xB,GAAAve,EAAAjX,KACA,IAAAw1B,EAAA,CACAz8B,KAAAiH,MAAAjH,KAAAiH,SACA,IAAAy1B,GAAA18B,KAAAiH,KACA,KAAA,GAAAoB,KAAAo0B,IAEAC,EAAAxS,eAAA7hB,IACAo0B,EAAAvS,eAAA7hB,KAEAq0B,EAAAr0B,GAAAo0B,EAAAp0B,IAKA6V,EAAA/b,MAAA+b,EAAA/b,KAAA5B,KAAAP,KAAAa,GAIAoD,GAAAkpB,SAAAoP,EAAA5Q,EAGA,KAAA,GAAAtjB,KAAA6V,GAEA,UAAA7V,GAAA,UAAAA,IACAk0B,EAAAr3B,UAAAmD,GAAA6V,EAAA7V,GAWA,OAPAk0B,GAAAr3B,UAAAuI,SAAA,SAAAzH,EAAAC,GAIA,MAHAjG,MAAA6K,MAAA7H,IAAAgD,EAAAC,GACAjG,KAAAs4B,OAAA,GACAr0B,EAAA8M,MAAA/Q,KAAA8C,MAAAuD,IAAA,iBAAAL,GAAA,GACAhG,MAGAu8B,GAEA18B,EAAAD,QAAA2E,GjG2iyBM,SAAU1E,EAAQD,EAASM,GkGzryBjC,GAAAgiD,GAAAhiD,EAAA,GAEAL,GAAAD,QAAAM,EAAA,IAAA4kB,QAEAhf,KAAA,OAOAmB,OAMAwK,EAAA,EACAE,EAAA,EACAC,EAAA,EACA3C,MAAA,GACAC,OAAA,IAGA+oB,UAAA,SAAAE,EAAAlxB,GACA,GAAAwK,GAAA,EACAE,EAAA,EACA1C,EAAAhI,EAAAgI,MACAC,EAAAjI,EAAAiI,MACAjI,GAAA2K,EAIAswC,EAAAjqB,UAAAE,EAAAlxB,GAHAkxB,EAAA3lB,KAAAf,EAAAE,EAAA1C,EAAAC,GAKAipB,EAAAgqB,aAEAzpC,YAAA,SAAAX,EAAAq8E,GACA,GAAAC,GAAA9xE,OAAAxK,GACA9Q,EAAAjH,KAAAiH,MACAqtF,EAAA/xE,OAAAtb,EAAAgI,MAAAolF,GACAE,EAAAhyE,OAAA+xE,EAAArtF,EAAAiI,OAAAjI,EAAAgI,MACAmlF,KACAE,EAAAn7E,SAAAm7E,EAAA,IACAC,EAAAp7E,SAAAo7E,EAAA,KAGAv0F,KAAA4X,UACA3I,MAAAqlF,EACAplF,OAAAqlF,QlGwtyBM,SAAU10F,EAAQD,EAASM,GmG1xyBjC,YAkBAL,GAAAD,QAAAM,EAAA,IAAA4kB,QAEAhf,KAAA,SAKAmB,OACA2K,EAAA,IAGAqmB,UAAA,SAAAE,EAAAlxB,EAAAg0B,GAGAA,GACA9C,EAAA+vB,OAAAjhD,EAAA2K,EAAA,GAIAumB,EAAA4xB,IAAA,EAAA,EAAA9iD,EAAA2K,EAAA,EAAA,EAAAyB,KAAA0B,IAAA,IAEA2D,YAAA,SAAAX,EAAAq8E,GACA,GAAAC,GAAA9xE,OAAAxK,GACA9Q,EAAAjH,KAAAiH,MACAytF,EAAAnyE,OAAAtb,EAAA2K,EAAAyiF,EACAD,KACAM,EAAAv7E,SAAAu7E,EAAA,KAGA10F,KAAA4X,UACAhG,EAAA8iF,QnGwyyBM,SAAU70F,EAAQD,EAASM,GoGzzyBjC,QAAA+yD,GAAApyD,GACAb,KAAA8C,MAAAyB,EAAAmvF,SAAA,QAAA7yF,GACAq4B,EAAA34B,KAAAP,KAAAa,GAEA2F,OAAAmuF,SACA30F,KAAA40F,cAAAD,OAAAE,WACA70F,KAAA6hB,OAAA7hB,KAAA40F,cAAAE,WAdA,GAAA57D,GAAAh5B,EAAA,GACAssB,EAAAtsB,EAAA,IACA+D,EAAA/D,EAAA,GACAqE,EAAArE,EAAA,IACAyzC,EAAAzzC,EAAA,IACAknD,EAAA,GAAAzT,GAAA,GAaAsf,GAAA/tD,WAEAqrB,YAAA0iC,EAEAntD,KAAA,QAEA0zB,MAAA,SAAArB,EAAAsB,GACA,GAEA3uB,GAFAD,EAAA7K,KAAA6K,MACA+8C,EAAA/8C,EAAAC,KAkBA,IAdAD,EAAArD,KAAA2wB,EAAAn4B,KAAAy5B,GAEA,gBAAAmuB,IACA98C,EAAA9K,KAAAkzD,OACApoD,GAAAA,EAAA88C,MAAAA,IACA98C,EAAA,QAKAA,EAAA88C,EACA98C,EAAAiqF,UAAA,IAGAjqF,GAAA88C,EAAA,CAEA,GAAAT,GAAAC,EAAA/gD,IAAAuhD,EACA,KAAAT,EAkBA,MAhBAr8C,GAAA,GAAAF,OACAE,EAAAiqF,UAAA,EACAjqF,EAAA28C,OAAA,WACA38C,EAAAiqF,UAAA,EACAjqF,EAAA28C,OAAA,IACA,KAAA,GAAAp6C,GAAA,EAAuCA,EAAA85C,EAAAK,QAAArhD,OAAiCkH,IACxE85C,EAAAK,QAAAn6C,GAAAirB,SAGA6uB,GACAr8C,MAAAA,EACA08C,SAAAxnD,OAEA8K,EAAA88C,IAAAA,EACAR,EAAAjW,IAAAyW,EAAAT,QACAnnD,KAAAkzD,OAAApoD,EAOA,IAHAA,EAAAq8C,EAAAr8C,MACA9K,KAAAkzD,OAAApoD,IAEAA,EAAAmE,OAAAnE,EAAAoE,QAAApE,EAAA88C,IAAA1+B,SAAA,QAEA,WADAi+B,GAAAK,QAAAh+C,KAAAxJ,MAMA,GAAA8K,EAAA,CASA,GAAA2G,GAAA5G,EAAA4G,GAAA,EACAE,EAAA9G,EAAA8G,GAAA,CAOA,KAAA7G,EAAAiqF,SAIA,YAHAvuF,OAAAmuF,QACA30F,KAAA40F,cAAAI,OAAAlqF,GAKA,IAAAmE,GAAApE,EAAAoE,MACAC,EAAArE,EAAAqE,OACA+d,EAAAniB,EAAAmE,MAAAnE,EAAAoE,MAgBA,IAfA,MAAAD,GAAA,MAAAC,EAEAD,EAAAC,EAAA+d,EAEA,MAAA/d,GAAA,MAAAD,EACAC,EAAAD,EAAAge,EAEA,MAAAhe,GAAA,MAAAC,IACAD,EAAAnE,EAAAmE,MACAC,EAAApE,EAAAoE,QAIAlP,KAAAi6B,aAAA9B,GAEAttB,EAAAsoD,QAAAtoD,EAAAuoD,QAAA,CACA,GAAAzvB,GAAA94B,EAAA84B,IAAA,EACAC,EAAA/4B,EAAA+4B,IAAA,CACAzL,GAAAqqB,UACA13C,EACA64B,EAAAC,EAAA/4B,EAAAsoD,OAAAtoD,EAAAuoD,QACA3hD,EAAAE,EAAA1C,EAAAC,OAGA,IAAArE,EAAA84B,IAAA94B,EAAA+4B,GAAA,CACA,GAAAqxD,GAAApqF,EAAA84B,GACAuxD,EAAArqF,EAAA+4B,GACAuvB,EAAAlkD,EAAAgmF,EACA7hC,EAAAlkD,EAAAgmF,CACA/8D,GAAAqqB,UACA13C,EACAmqF,EAAAC,EAAA/hC,EAAAC,EACA3hD,EAAAE,EAAA1C,EAAAC,OAIAipB,GAAAqqB,UAAA13C,EAAA2G,EAAAE,EAAA1C,EAAAC,EAGA,OAAArE,EAAAoE,QACApE,EAAAoE,MAAAA,GAEA,MAAApE,EAAAqE,SACArE,EAAAqE,OAAAA,GAGAlP,KAAA86B,iBAAA3C,GAGA,MAAAttB,EAAAE,MACA/K,KAAA+6B,aAAA5C,EAAAn4B,KAAAmP,mBAEA3I,OAAAmuF,QACA30F,KAAA40F,cAAAO,QAAArqF,KAKAqE,gBAAA,WACA,GAAAtE,GAAA7K,KAAA6K,KAMA,OALA7K,MAAAk7B,QACAl7B,KAAAk7B,MAAA,GAAA1O,GACA3hB,EAAA4G,GAAA,EAAA5G,EAAA8G,GAAA,EAAA9G,EAAAoE,OAAA,EAAApE,EAAAqE,QAAA,IAGAlP,KAAAk7B,OAEAxiB,YAAA,SAAAX,EAAAq8E,GACA,GAAAC,GAAA9xE,OAAAxK,GACAlN,EAAA7K,KAAA6K,MACAypF,EAAA/xE,OAAA1X,EAAAoE,MAAAolF,GACAE,EAAAhyE,OAAA+xE,EAAAzpF,EAAAqE,OAAArE,EAAAoE,MACAmlF,KACAE,EAAAn7E,SAAAm7E,EAAA,IACAC,EAAAp7E,SAAAo7E,EAAA,KAGAv0F,KAAAyN,UACAwB,MAAAqlF,EACAplF,OAAAqlF,MAKAtwF,EAAAkpB,SAAA8lC,EAAA/5B,GAEAr5B,EAAAD,QAAAqzD,GpGm2yBM,SAAUpzD,EAAQD,EAASM,GqGrizBjC,QAAAk1F,GAAAv0F,GACA,GAAA87E,IACA9xE,OAAmBiY,aAAA,QAEnB1f,EAAAa,EAAA8M,MAAA4rE,EAAA97E,GAAA,EACAb,MAAA8C,MAAAyB,EAAAmvF,SAAA,OAAAtwF,GACA4oB,EAAAzrB,KAAAP,KAAAoD,GATA,GAAA4oB,GAAA9rB,EAAA,IACA+D,EAAA/D,EAAA,GACAqE,EAAArE,EAAA,GAUAk1F,GAAAlwF,WACAqrB,YAAA6kE,EAEAtvF,KAAA,OAEA4S,YAAA,cAIAzU,EAAAkpB,SAAAioE,EAAAppE,GACAnsB,EAAAD,QAAAw1F,GrGokzBM,SAAUv1F,EAAQD,EAASM,GsG1lzBjC,GAAA0zD,GAAA1zD,EAAA,IACAyrB,EAAAzrB,EAAA,GAEA+zD,IACA,aAAA,IACA,cAAA,SACA,gBAAA,IACA,gBAAA,GAEAp0D,GAAAD,QAAAM,EAAA,IAAA4kB,QAEAhf,KAAA,SASAmB,OACAuK,GAAA,EAEAE,GAAA,EAEA6hD,GAAA,EAEA3hD,EAAA,EAEAo4C,WAAA,EAEAC,SAAA,EAAA52C,KAAA0B,GAEAy+C,WAAA,GAGAh6B,MAAAo6B,EAAAC,QAAAC,IAAAF,EAAAC,QAAApsC,SAAA,GAcA,WACA,GAEAssC,GAFAC,EAAAh0D,KAAA68B,YACAhyB,EAAA7K,KAAA6K,KAGA,IAAAmpD,EACA,IAAA,GAAA3mD,GAAA,EAAmCA,EAAA2mD,EAAA7tD,OAAsBkH,IAAA,CACzD,GAAApG,GAAA+sD,EAAA3mD,IAAA2mD,EAAA3mD,GAAApG,KACA,IAAAA,GAAAA,EAAA+iD,aAAA/iD,EAAAgjD,SAAA,CACA,IAAA,GAAAtsC,GAAA,EAA2CA,EAAAs2C,EAAA9tD,OAAuBwX,IAClEs2C,EAAAt2C,GAAA,GAAA9S,EAAAopD,EAAAt2C,GAAA,IACA9S,EAAAopD,EAAAt2C,GAAA,IAAAs2C,EAAAt2C,GAAA,EAEAo2C,IAAA,CACA,QAOA,GAFApoC,EAAAzmB,UAAAs0B,MAAA5e,MAAA5a,KAAAkG,WAEA6tD,EACA,IAAA,GAAA3lB,GAAA,EAAmCA,EAAA6lB,EAAA9tD,OAAuBioC,IAC1DvjC,EAAAopD,EAAA7lB,GAAA,IAAA6lB,EAAA7lB,GAAA,IAIAziB,EAAAzmB,UAAAs0B,MAEAvB,UAAA,SAAAE,EAAAlxB,GAEA,GAAAwK,GAAAxK,EAAAuK,GACAG,EAAA1K,EAAAyK,GACA6hD,EAAAlgD,KAAA6Q,IAAAjd,EAAAssD,IAAA,EAAA,GACA3hD,EAAAyB,KAAA6Q,IAAAjd,EAAA2K,EAAA,GACAo4C,EAAA/iD,EAAA+iD,WACAC,EAAAhjD,EAAAgjD,SACAuJ,EAAAvsD,EAAAusD,UAEAC,EAAApgD,KAAA0lB,IAAAixB,GACA0J,EAAArgD,KAAAylB,IAAAkxB,EAEA7xB,GAAA+vB,OAAAuL,EAAAF,EAAA9hD,EAAAiiD,EAAAH,EAAA5hD,GAEAwmB,EAAAgwB,OAAAsL,EAAA7hD,EAAAH,EAAAiiD,EAAA9hD,EAAAD,GAEAwmB,EAAA4xB,IAAAt4C,EAAAE,EAAAC,EAAAo4C,EAAAC,GAAAuJ,GAEAr7B,EAAAgwB,OACA90C,KAAA0lB,IAAAkxB,GAAAsJ,EAAA9hD,EACA4B,KAAAylB,IAAAmxB,GAAAsJ,EAAA5hD,GAGA,IAAA4hD,GACAp7B,EAAA4xB,IAAAt4C,EAAAE,EAAA4hD,EAAAtJ,EAAAD,EAAAwJ,GAGAr7B,EAAAgqB,aAEAzpC,YAAA,SAAAX,EAAAq8E,GACA,GAAAC,GAAA9xE,OAAAxK,GACA9Q,EAAAjH,KAAAiH,MACAytF,EAAAnyE,OAAAtb,EAAA2K,EAAAyiF,GACAgB,EAAA9yE,OAAAtb,EAAAssD,GAAA8gC,EACAD,KACAM,EAAAv7E,SAAAu7E,EAAA,IACAW,EAAAl8E,SAAAk8E,EAAA,KAGAr1F,KAAA4X,UACAhG,EAAA8iF,EACAnhC,GAAA8hC,QtGynzBM,SAAUx1F,EAAQD,EAASM,GuGlvzBjCL,EAAAD,QAAAM,EAAA,IAAA4kB,QAEAhf,KAAA,OAMAmB,OACAuK,GAAA,EACAE,GAAA,EACAE,EAAA,EACA2hD,GAAA,GAGAt7B,UAAA,SAAAE,EAAAlxB,GACA,GAAAwK,GAAAxK,EAAAuK,GACAG,EAAA1K,EAAAyK,GACA49C,EAAA,EAAAj8C,KAAA0B,EACAojB,GAAA+vB,OAAAz2C,EAAAxK,EAAA2K,EAAAD,GACAwmB,EAAA4xB,IAAAt4C,EAAAE,EAAA1K,EAAA2K,EAAA,EAAA09C,GAAA,GACAn3B,EAAA+vB,OAAAz2C,EAAAxK,EAAAssD,GAAA5hD,GACAwmB,EAAA4xB,IAAAt4C,EAAAE,EAAA1K,EAAAssD,GAAA,EAAAjE,GAAA,IAEA52C,YAAA,SAAAX,EAAAq8E,GACA,GAAAC,GAAA9xE,OAAAxK,GACA9Q,EAAAjH,KAAAiH,MACAytF,EAAAnyE,OAAAtb,EAAA2K,EAAAyiF,GACAgB,EAAA9yE,OAAAtb,EAAAssD,GAAA8gC,EACAD,KACAM,EAAAv7E,SAAAu7E,EAAA,IACAW,EAAAl8E,SAAAk8E,EAAA,KAGAr1F,KAAA4X,UACAhG,EAAA8iF,EACAnhC,GAAA8hC,QvGixzBM,SAAUx1F,EAAQD,EAASM,GwGt0zBjC,YAkBAL,GAAAD,QAAAM,EAAA,IAAA4kB,QAEAhf,KAAA,UAMAmB,OACAouB,GAAA,EAAAC,GAAA,GAGA2C,UAAA,SAAAE,EAAAlxB,GACA,GAAAmnC,GAAA,SACA38B,EAAA,EACAE,EAAA,EACAgzB,EAAA19B,EAAAouB,GACAoQ,EAAAx+B,EAAAquB,GACAggE,EAAA3wD,EAAAyJ,EACAmnD,EAAA9vD,EAAA2I,CAEAjW,GAAA+vB,OAAAz2C,EAAAkzB,EAAAhzB,GACAwmB,EAAAuxB,cAAAj4C,EAAAkzB,EAAAhzB,EAAA4jF,EAAA9jF,EAAA6jF,EAAA3jF,EAAA8zB,EAAAh0B,EAAAE,EAAA8zB,GACAtN,EAAAuxB,cAAAj4C,EAAA6jF,EAAA3jF,EAAA8zB,EAAAh0B,EAAAkzB,EAAAhzB,EAAA4jF,EAAA9jF,EAAAkzB,EAAAhzB,GACAwmB,EAAAuxB,cAAAj4C,EAAAkzB,EAAAhzB,EAAA4jF,EAAA9jF,EAAA6jF,EAAA3jF,EAAA8zB,EAAAh0B,EAAAE,EAAA8zB,GACAtN,EAAAuxB,cAAAj4C,EAAA6jF,EAAA3jF,EAAA8zB,EAAAh0B,EAAAkzB,EAAAhzB,EAAA4jF,EAAA9jF,EAAAkzB,EAAAhzB,GACAwmB,EAAAgqB,aAEAzpC,YAAA,SAAAX,EAAAq8E,GACA,GAAAC,GAAA9xE,OAAAxK,GACA9Q,EAAAjH,KAAAiH,MACAuuF,EAAAjzE,OAAAtb,EAAAouB,GAAAg/D,GACAoB,EAAAlzE,OAAAizE,EAAAvuF,EAAAquB,GAAAruB,EAAAouB,GACA++D,KACAoB,EAAAr8E,SAAAq8E,EAAA,IACAC,EAAAt8E,SAAAs8E,EAAA,KAGAz1F,KAAA4X,UACAyd,GAAAmgE,EACAlgE,GAAAmgE,QxGo1zBM,SAAU51F,EAAQD,EAASM,GyG73zBjCL,EAAAD,QAAAM,EAAA,IAAA4kB,QAEAhf,KAAA,QAQAmB,OACAuK,GAAA,EACAE,GAAA,EACAzC,MAAA,EACAC,OAAA,GAGA+oB,UAAA,SAAAE,EAAAlxB,GACA,GAAAwK,GAAAxK,EAAAuK,GACAG,EAAA1K,EAAAyK,GACAizB,EAAA19B,EAAAgI,MACAw2B,EAAAx+B,EAAAiI,MACAipB,GAAA+vB,OAAAz2C,EAAAE,GACAwmB,EAAAuxB,cACAj4C,EAAAkzB,EAAA,EAAAhzB,EAAA,EAAA8zB,EAAA,EACAh0B,EAAA,EAAAkzB,EAAAhzB,EAAA8zB,EAAA,EACAh0B,EAAAE,EAAA8zB,GAEAtN,EAAAuxB,cACAj4C,EAAA,EAAAkzB,EAAAhzB,EAAA8zB,EAAA,EACAh0B,EAAAkzB,EAAA,EAAAhzB,EAAA,EAAA8zB,EAAA,EACAh0B,EAAAE,IAGA+G,YAAA,SAAAX,EAAAq8E,GACA,GAAAC,GAAA9xE,OAAAxK,GACA9Q,EAAAjH,KAAAiH,MACAyuF,EAAAnzE,OAAAtb,EAAAgI,MAAAolF,GACAsB,EAAApzE,OAAAmzE,EAAAzuF,EAAAiI,OAAAjI,EAAAgI,MACAmlF,KACAsB,EAAAv8E,SAAAu8E,EAAA,IACAC,EAAAx8E,SAAAw8E,EAAA,KAGA31F,KAAA4X,UACA3I,MAAAymF,EACAxmF,OAAAymF,QzG45zBM,SAAU91F,EAAQD,EAASM,G0G39zBjC,YAkBAL,GAAAD,QAAAM,EAAA,IAAA4kB,QAEAhf,KAAA,UAMAmB,OACAuK,GAAA,EAAAE,GAAA,EACAzC,MAAA,EAAAC,OAAA,GAGA+oB,UAAA,SAAAE,EAAAlxB,GACA,GAAAwK,GAAAxK,EAAAuK,GACAG,EAAA1K,EAAAyK,GACAizB,EAAA19B,EAAAgI,MACAw2B,EAAAx+B,EAAAiI,MAEAipB,GAAA+vB,OAAAz2C,EAAAE,EAAAgzB,GACAxM,EAAAuxB,cACAj4C,EAAAkzB,EACAhzB,EAAAgzB,EACAlzB,EAAA,EAAAkzB,EAAA,EACAhzB,EAAAgzB,EAAA,EACAlzB,EACAE,EAAA8zB,GAEAtN,EAAAuxB,cACAj4C,EAAA,EAAAkzB,EAAA,EACAhzB,EAAAgzB,EAAA,EACAlzB,EAAAkzB,EACAhzB,EAAAgzB,EACAlzB,EACAE,EAAAgzB,GAEAxM,EAAAgqB,aAEAzpC,YAAA,SAAAX,EAAAq8E,GACA,GAAAC,GAAA9xE,OAAAxK,GACA9Q,EAAAjH,KAAAiH,MACAyuF,EAAAnzE,OAAAtb,EAAAgI,MAAAolF,GACAsB,EAAApzE,OAAAmzE,EAAAzuF,EAAAiI,OAAAjI,EAAAgI,MACAmlF,KACAsB,EAAAv8E,SAAAu8E,EAAA,IACAC,EAAAx8E,SAAAw8E,EAAA,KAGA31F,KAAA4X,UACA3I,MAAAymF,EACAxmF,OAAAymF,Q1Gy+zBM,SAAU91F,EAAQD,EAASM,G2G5h0BjC,GAAA44B,GAAAzlB,KAAAylB,IACAC,EAAA1lB,KAAA0lB,IACA68D,EAAAviF,KAAA0B,GAAA,GACAlV,GAAAD,QAAAM,EAAA,IAAA4kB,QAEAhf,KAAA,OAOAmB,OACAuK,GAAA,EACAE,GAAA,EACAE,KACAw8B,EAAA,EACAp5B,EAAA,GAGAnK,OACAiH,OAAA,OACAD,KAAA,KACAiE,UAAA,GAGAmiB,UAAA,SAAAE,EAAAlxB,GACA,GAAAwK,GACAE,EAEAC,EADAsgC,EAAAjrC,EAAA2K,EAEAw8B,EAAAnnC,EAAAmnC,EACAp5B,EAAA/N,EAAA+N,EAEAq1C,EAAApjD,EAAAuK,GACA84C,EAAArjD,EAAAyK,EAEAymB,GAAA+vB,OAAAmC,EAAAC,EAEA,KAAA,GAAAj9C,GAAA,EAAA+iB,EAAA8hB,EAAA/rC,OAA2CkH,EAAA+iB,EAAU/iB,IAAA,CACrDuE,EAAAsgC,EAAA7kC,EAEA,KAAA,GAAAsQ,GAAA,EAA+BA,GAAA,IAAA3I,EAAc2I,IAC7ClM,EAAAG,EACAknB,EAAAsV,EAAAp5B,EAAA2I,EAAA,IAAAi4E,GACA78D,EAAApb,EAAAi4E,GACAvrC,EACA14C,EAAAC,EACAknB,EAAAsV,EAAAp5B,EAAA2I,EAAA,IAAAi4E,GACA98D,EAAAnb,EAAAi4E,GACAtrC,EACAnyB,EAAAgwB,OAAA12C,EAAAE,KAIA+G,YAAA,SAAAX,EAAAq8E,GACA,GAAAC,GAAA9xE,OAAAxK,GACA9Q,EAAAjH,KAAAiH,MACAytF,IACAztF,GAAA2K,EAAAzE,QAAA,SAAAC,GACAsnF,EAAAlrF,KAAA+Y,OAAAnV,EAAAinF,MAEAD,GACAM,EAAAvnF,QAAA,SAAAC,GACAA,EAAA+L,SAAA/L,EAAA,MAIApN,KAAA4X,UACAhG,EAAA8iF,Q3G2j0BM,SAAU70F,EAAQD,EAASM,G4Gho0BjC,GAAA6U,GAAA1B,KAAA0B,GACA+jB,EAAAzlB,KAAAylB,IACAC,EAAA1lB,KAAA0lB,GACAl5B,GAAAD,QAAAM,EAAA,IAAA4kB,QAEAhf,KAAA,SAMAmB,OACAwK,EAAA,EAAAE,EAAA,EACAC,EAAA,EAAAoD,EAAA,GAGAijB,UAAA,SAAAE,EAAAlxB,GACA,GAAA+N,GAAA/N,EAAA+N,CACA,IAAAA,KAAAA,EAAA,GAAA,CAIA,GAAAvD,GAAAxK,EAAAwK,EACAE,EAAA1K,EAAA0K,EACAC,EAAA3K,EAAA2K,EAEAikF,EAAA,EAAA9gF,EAAAC,EACA+pE,GAAAhqE,EAAA,CAEAojB,GAAA+vB,OAAAz2C,EAAAG,EAAAmnB,EAAAgmD,GAAAptE,EAAAC,EAAAknB,EAAAimD,GACA,KAAA,GAAA1xE,GAAA,EAAAqH,EAAAM,EAAA,EAAwC3H,EAAAqH,EAASrH,IACjD0xE,GAAA8W,EACA19D,EAAAgwB,OAAA12C,EAAAG,EAAAmnB,EAAAgmD,GAAAptE,EAAAC,EAAAknB,EAAAimD,GAGA5mD,GAAAgqB,cAIAzpC,YAAA,SAAAX,EAAAq8E,GACA,GAAAC,GAAA9xE,OAAAxK,GACA9Q,EAAAjH,KAAAiH,MACAytF,EAAAnyE,OAAAtb,EAAA2K,EAAAyiF,EACAD,KACAM,EAAAv7E,SAAAu7E,EAAA,KAGA10F,KAAA4X,UACAhG,EAAA8iF,Q5G+p0BM,SAAU70F,EAAQD,EAASM,G6G/s0BjC,GAAA80D,GAAA90D,EAAA,GAEAL,GAAAD,QAAAM,EAAA,IAAA4kB,QAEAhf,KAAA,UAOAmB,OACA8b,OAAA,KAEAkyC,QAAA,EAEAC,iBAAA,MAGAj9B,UAAA,SAAAE,EAAAlxB,GACA+tD,EAAA/8B,UAAAE,EAAAlxB,GAAA,IAEAyR,YAAA,SAAAX,EAAAq8E,GACA,GAAAC,GAAA9xE,OAAAxK,GACA9Q,EAAAjH,KAAAiH,MACA6uF,IACA7uF,GAAA8b,OAAA5V,QAAA,SAAAmF,GACAwjF,EAAAtsF,MAAA+Y,OAAAjQ,EAAA,GAAA+hF,GAAA9xE,OAAAjQ,EAAA,GAAA+hF,OAEAD,GACA0B,EAAA3oF,QAAA,SAAAmF,GACAA,EAAA,GAAA6G,SAAA7G,EAAA,GAAA,IACAA,EAAA,GAAA6G,SAAA7G,EAAA,GAAA,MAIAtS,KAAA4X,UACAmL,OAAA+yE,Q7G8u0BM,SAAUj2F,EAAQD,EAASM,G8Gnx0BjCL,EAAAD,QAAAM,EAAA,IAAA4kB,QAEAhf,KAAA,OAQAmB,OAEAyO,GAAA,EACAC,GAAA,EAEAC,GAAA,EACAC,GAAA,EAEAoyB,QAAA,GAGAp9B,OACAiH,OAAA,OACAD,KAAA,MAGAomB,UAAA,SAAAE,EAAAlxB,GACA,GAAAyO,GAAAzO,EAAAyO,GACAC,EAAA1O,EAAA0O,GACAC,EAAA3O,EAAA2O,GACAC,EAAA5O,EAAA4O,GACAoyB,EAAAhhC,EAAAghC,OAEA,KAAAA,IAIA9P,EAAA+vB,OAAAxyC,EAAAC,GAEAsyB,EAAA,IACAryB,EAAAF,GAAA,EAAAuyB,GAAAryB,EAAAqyB,EACApyB,EAAAF,GAAA,EAAAsyB,GAAApyB,EAAAoyB,GAEA9P,EAAAgwB,OAAAvyC,EAAAC,KAQA8gD,QAAA,SAAAj2D,GACA,GAAAuG,GAAAjH,KAAAiH,KACA,QACAA,EAAAyO,IAAA,EAAAhV,GAAAuG,EAAA2O,GAAAlV,EACAuG,EAAA0O,IAAA,EAAAjV,GAAAuG,EAAA4O,GAAAnV,IAGAgY,YAAA,SAAAX,EAAAq8E,GACA,GAAAC,GAAA9xE,OAAAxK,GACA9Q,EAAAjH,KAAAiH,MACA8uF,EAAAxzE,OAAAtb,EAAAyO,GAAA2+E,GACA2B,EAAAzzE,OAAAtb,EAAA2O,GAAAy+E,GACA4B,EAAA1zE,OAAAtb,EAAA0O,GAAA0+E,GACA6B,EAAA3zE,OAAAtb,EAAA4O,GAAAw+E,EACAD,KACA2B,EAAA58E,SAAA48E,EAAA,KAGA/1F,KAAA4X,UACAlC,GAAAqgF,EACApgF,GAAAsgF,EACArgF,GAAAogF,EACAngF,GAAAqgF,Q9Gkz0BM,SAAUr2F,EAAQD,EAASM,G+G540BjC,YAiBA,IAAA80D,GAAA90D,EAAA,GACAL,GAAAD,QAAAM,EAAA,IAAA4kB,QAEAhf,KAAA,WAOAmB,OACA8b,OAAA,KAEAkyC,QAAA,EAEAC,iBAAA,MAGArqD,OACAiH,OAAA,OAEAD,KAAA,MAGAomB,UAAA,SAAAE,EAAAlxB,GACA+tD,EAAA/8B,UAAAE,EAAAlxB,GAAA,IAEAyR,YAAA,SAAAX,EAAAq8E,GACA,GAAAC,GAAA9xE,OAAAxK,GACA9Q,EAAAjH,KAAAiH,MACA6uF,IACA7uF,GAAA8b,OAAA5V,QAAA,SAAAmF,GACAwjF,EAAAtsF,MAAA+Y,OAAAjQ,EAAA,GAAA+hF,GAAA9xE,OAAAjQ,EAAA,GAAA+hF,OAEAD,GACA0B,EAAA3oF,QAAA,SAAAmF,GACAA,EAAA,GAAA6G,SAAA7G,EAAA,GAAA,IACAA,EAAA,GAAA6G,SAAA7G,EAAA,GAAA,MAIAtS,KAAA4X,UACAmL,OAAA+yE,Q/G050BM,SAAUj2F,EAAQD,EAASM,GgHr90BjC,YA8BA,SAAA02D,GAAA3vD,EAAAo/B,EAAAwwB,GACA,GAAAC,GAAA7vD,EAAA6vD,KACAC,EAAA9vD,EAAA8vD,IACA,OAAA,QAAAD,GAAA,OAAAC,IAEAF,EAAA3K,EAAAjB,GAAAhkD,EAAAyO,GAAAzO,EAAA+vD,KAAA/vD,EAAA6vD,KAAA7vD,EAAA2O,GAAAywB,IACAwwB,EAAA3K,EAAAjB,GAAAhkD,EAAA0O,GAAA1O,EAAAgwD,KAAAhwD,EAAA8vD,KAAA9vD,EAAA4O,GAAAwwB,MAKAwwB,EAAAvI,EAAAD,GAAApnD,EAAAyO,GAAAzO,EAAA+vD,KAAA/vD,EAAA2O,GAAAywB,IACAwwB,EAAAvI,EAAAD,GAAApnD,EAAA0O,GAAA1O,EAAAgwD,KAAAhwD,EAAA4O,GAAAwwB,IAvBA,GAAA8vD,GAAAj2F,EAAA,IACA4lD,EAAA5lD,EAAA,IACAwuD,EAAAynC,EAAAznC,mBACAvB,EAAAgpC,EAAAhpC,eACAkB,EAAA8nC,EAAA9nC,YACApD,EAAAkrC,EAAAlrC,QACAqD,EAAA6nC,EAAA7nC,sBACApC,EAAAiqC,EAAAjqC,kBAEAloB,IAkBAnkC,GAAAD,QAAAM,EAAA,IAAA4kB,QAEAhf,KAAA,cAUAmB,OACAyO,GAAA,EACAC,GAAA,EACAC,GAAA,EACAC,GAAA,EACAmhD,KAAA,EACAC,KAAA,EAGAhvB,QAAA,GAGAp9B,OACAiH,OAAA,OACAD,KAAA,MAGAomB,UAAA,SAAAE,EAAAlxB,GACA,GAAAyO,GAAAzO,EAAAyO,GACAC,EAAA1O,EAAA0O,GACAC,EAAA3O,EAAA2O,GACAC,EAAA5O,EAAA4O,GACAmhD,EAAA/vD,EAAA+vD,KACAC,EAAAhwD,EAAAgwD,KACAH,EAAA7vD,EAAA6vD,KACAC,EAAA9vD,EAAA8vD,KACA9uB,EAAAhhC,EAAAghC,OACA,KAAAA,IAIA9P,EAAA+vB,OAAAxyC,EAAAC,GAEA,MAAAmhD,GAAA,MAAAC,GACA9uB,EAAA,IACAymB,EACAh5C,EAAAshD,EAAAphD,EAAAqyB,EAAAjE,GAEAgzB,EAAAhzB,EAAA,GACApuB,EAAAouB,EAAA,GACA0qB,EACA/4C,EAAAshD,EAAAphD,EAAAoyB,EAAAjE,GAEAizB,EAAAjzB,EAAA,GACAnuB,EAAAmuB,EAAA,IAGA7L,EAAAiwB,iBACA4O,EAAAC,EACArhD,EAAAC,KAIAoyB,EAAA,IACAklB,EACAz3C,EAAAshD,EAAAF,EAAAlhD,EAAAqyB,EAAAjE,GAEAgzB,EAAAhzB,EAAA,GACA8yB,EAAA9yB,EAAA,GACApuB,EAAAouB,EAAA,GACAmpB,EACAx3C,EAAAshD,EAAAF,EAAAlhD,EAAAoyB,EAAAjE,GAEAizB,EAAAjzB,EAAA,GACA+yB,EAAA/yB,EAAA,GACAnuB,EAAAmuB,EAAA,IAEA7L,EAAAuxB,cACAsN,EAAAC,EACAH,EAAAC,EACAnhD,EAAAC,MAUA8gD,QAAA,SAAAtwB,GACA,MAAAuwB,GAAA52D,KAAAiH,MAAAo/B,GAAA,IAQA6wB,UAAA,SAAA7wB,GACA,GAAA3lC,GAAAk2D,EAAA52D,KAAAiH,MAAAo/B,GAAA,EACA,OAAAyf,GAAA9f,UAAAtlC,EAAAA,IAEAgY,YAAA,SAAAX,EAAAq8E;AACA,GAAAC,GAAA9xE,OAAAxK,GACA9Q,EAAAjH,KAAAiH,MACA6uF,IACAlhE,QAAA2oC,KAAAt2D,GAAAkG,QAAA,SAAAnH,GACA,GAAAC,GAAAgB,EAAAjB,EACA,aAAAA,EACA8vF,EAAA9vF,GAAAuc,OAAAtc,EAAAouF,GAEAyB,EAAA9vF,GAAAC,IAGAmuF,GACAx/D,OAAA2oC,KAAAu4B,GAAA3oF,QAAA,SAAAnH,GACA8vF,EAAA9vF,GAAAmT,SAAA28E,EAAA9vF,GAAA,MAIAhG,KAAA4X,SAAAk+E,OhHk+0BM,SAAUj2F,EAAQD,EAASM,GiH3o1BjC,YAkBAL,GAAAD,QAAAM,EAAA,IAAA4kB,QAEAhf,KAAA,MAQAmB,OACAuK,GAAA,EACAE,GAAA,EACAE,EAAA,EACAo4C,WAAA,EACAC,SAAA,EAAA52C,KAAA0B,GACAy+C,WAAA,GAGA3oD,OAEAiH,OAAA,OAEAD,KAAA,MAGAomB,UAAA,SAAAE,EAAAlxB,GAEA,GAAAwK,GAAAxK,EAAAuK,GACAG,EAAA1K,EAAAyK,GACAE,EAAAyB,KAAA6Q,IAAAjd,EAAA2K,EAAA,GACAo4C,EAAA/iD,EAAA+iD,WACAC,EAAAhjD,EAAAgjD,SACAuJ,EAAAvsD,EAAAusD,UAEAC,EAAApgD,KAAA0lB,IAAAixB,GACA0J,EAAArgD,KAAAylB,IAAAkxB,EAEA7xB,GAAA+vB,OAAAuL,EAAA7hD,EAAAH,EAAAiiD,EAAA9hD,EAAAD,GACAwmB,EAAA4xB,IAAAt4C,EAAAE,EAAAC,EAAAo4C,EAAAC,GAAAuJ,IAEA96C,YAAA,SAAAX,EAAAq8E,GACA,GAAAC,GAAA9xE,OAAAxK,GACA9Q,EAAAjH,KAAAiH,MACAytF,EAAAnyE,OAAAtb,EAAA2K,EAAAyiF,EACAD,KACAM,EAAAv7E,SAAAu7E,EAAA,KAGA10F,KAAA4X,UACAhG,EAAA8iF,QjHyp1BM,SAAU70F,EAAQD,EAASM,GkH7t1BjC,YAkBA,IAAA6U,GAAA1B,KAAA0B,GAEAgkB,EAAA1lB,KAAA0lB,IACAD,EAAAzlB,KAAAylB,GACAj5B,GAAAD,QAAAM,EAAA,IAAA4kB,QAEAhf,KAAA,OAOAmB,OACAuK,GAAA,EACAE,GAAA,EACAsD,EAAA,EACAu+C,GAAA,KACA3hD,EAAA,GAGAqmB,UAAA,SAAAE,EAAAlxB,GAEA,GAAA+N,GAAA/N,EAAA+N,CACA,IAAAA,KAAAA,EAAA,GAAA,CAIA,GAAAvD,GAAAxK,EAAAuK,GACAG,EAAA1K,EAAAyK,GACAE,EAAA3K,EAAA2K,EACA2hD,EAAAtsD,EAAAssD,EAGA,OAAAA,IACAA,EAAAv+C,EAAA,EAGApD,EAAAmnB,EAAA,EAAAhkB,EAAAC,GAAA+jB,EAAAhkB,EAAAC,GAEApD,EAAA,EAGA,IAAAikF,GAAA9gF,EAAAC,EACA+pE,GAAAhqE,EAAA,EACAqhF,EAAA3kF,EAAAG,EAAAmnB,EAAAgmD,GACAsX,EAAA1kF,EAAAC,EAAAknB,EAAAimD,EACAA,IAAA8W,EAGA19D,EAAA+vB,OAAAkuC,EAAAC,EACA,KAAA,GAAAC,GAAAjpF,EAAA,EAAAqH,EAAA,EAAAM,EAAA,EAAgD3H,EAAAqH,EAASrH,IACzDipF,EAAAjpF,EAAA,IAAA,EAAAkmD,EAAA3hD,EACAumB,EAAAgwB,OAAA12C,EAAA6kF,EAAAv9D,EAAAgmD,GAAAptE,EAAA2kF,EAAAx9D,EAAAimD,IACAA,GAAA8W,CAGA19D,GAAAgqB,cAEAzpC,YAAA,SAAAX,EAAAq8E,GACA,GAAAC,GAAA9xE,OAAAxK,GACA9Q,EAAAjH,KAAAiH,MACAytF,EAAAnyE,OAAAtb,EAAA2K,EAAAyiF,EACAD,KACAM,EAAAv7E,SAAAu7E,EAAA,KAGA10F,KAAA4X,UACAhG,EAAA8iF,QlH2u1BM,SAAU70F,EAAQD,EAASM,GmHj01BjC,YAoBA,IAAA64B,GAAA1lB,KAAA0lB,IACAD,EAAAzlB,KAAAylB,GACAj5B,GAAAD,QAAAM,EAAA,IAAA4kB,QAEAhf,KAAA,WAQAmB,OACAuK,GAAA,EACAE,GAAA,EACAE,EAAA,EACA2hD,GAAA,EACAttB,EAAA,EACAswD,SAAA,OAGA1rF,OACAiH,OAAA,OAEAD,KAAA,MAGAomB,UAAA,SAAAE,EAAAlxB,GACA,GAAAyO,GACAC,EACAC,EACAC,EACAq8B,EAAAjrC,EAAA2K,EACAA,EAAA3K,EAAAssD,GACAttB,EAAAh/B,EAAAg/B,EACA19B,EAAAtB,EAAAuK,GACAhJ,EAAAvB,EAAAyK,GACA6gC,EAAA,OAAAtrC,EAAAsvF,SAAA,IAEA,MAAAtvF,EAAAsvF,UAAArkD,GAAAtgC,GAAA,CAIA,GAEAukB,GAFAqgE,EAAA,EACAnpF,EAAA,CAGAqI,IAAAw8B,EAAAK,EAAA3gC,GAAAmnB,EAAA,GACAwZ,EAAAtM,EAAAlN,EAAA,GAAAxwB,EACAoN,GAAAu8B,EAAAK,EAAA3gC,GAAAknB,EAAA,GACAmN,EAAAnN,EAAA,GAAAtwB,EAEA2vB,EAAA+vB,OAAAxyC,EAAAC,EAGA,GACA6gF,WAEA5kF,EAAA4kF,GAAAtkD,EAAAK,EAAA3gC,KAAA,EAEA,GACAukB,GAAA9iB,KAAA0B,GAAA,IAAA1H,EACAuI,GAAAs8B,EAAAK,EAAA3gC,GAAAmnB,EAAA5C,GACAoc,EAAAtM,EAAAlN,GAAAmZ,EAAAtgC,EAAA2gC,GAAApc,GACA5tB,EACAsN,GAAAq8B,EAAAK,EAAA3gC,GAAAknB,EAAA3C,GACA8P,EAAAnN,GAAAoZ,EAAAtgC,EAAA2gC,GAAApc,GACA3tB,EACA2vB,EAAAgwB,OAAAvyC,EAAAC,GACAxI,UAEAA,GAAAuE,EAAA4kF,GAAAtkD,EAAAK,EAAA3gC,GAAA,OAGA8G,YAAA,SAAAX,EAAAq8E,GACA,GAAAC,GAAA9xE,OAAAxK,GACA9Q,EAAAjH,KAAAiH,MACAytF,EAAAnyE,OAAAtb,EAAA2K,EAAAyiF,GACAgB,EAAA9yE,OAAAtb,EAAAssD,GAAA8gC,GACAoC,EAAAl0E,OAAAtb,EAAAg/B,EAAAouD,EACAK,GAAAv7E,SAAAu7E,EAAA,IACAW,EAAAl8E,SAAAk8E,EAAA,IACAoB,EAAAt9E,SAAAs9E,EAAA,IAEAz2F,KAAA4X,UACAhG,EAAA8iF,EACAnhC,GAAA8hC,EACApvD,EAAAwwD,QnH+01BM,SAAU52F,EAAQD,EAASM,GoHn61BjC,QAAAw2F,GAAA71F,GAUA,GAAA87E,IACA9xE,OAAmBgH,KAAA,OAAAC,OAAA,WACnBU,MAAkBf,EAAA,EAAAE,EAAA,EAAA1C,MAAA,EAAAC,OAAA,GAClBkuB,WAAA,GAGAxQ,EAAA/rB,EAAA+rB,SACA9pB,EAAAyB,EAAAmvF,SAAA,OAAA7yF,SACAA,GAAA+rB,SACA5sB,KAAAoD,QAAAa,EAAA8M,MAAA4rE,EAAA97E,GAAA,EACA,IAAAksB,GAAArB,EAAAsB,iBAAAJ,EAAA5sB,KAAAoD,QACA2pB,GAAAjqB,MAAAA,EACAgpB,EAAAvrB,KAAAwsB,EACA,IAAAnW,GAAAmW,EAAA5d,kBACAqD,EAAAxS,KAAAoD,QAAAoP,KACA9N,EAAA7D,EAAA6D,MACA,IAAA8N,EAAA,CACA,GAAAya,GAAArW,EAAA3H,MAAA2H,EAAA1H,MAEA,IAAA,WAAAxK,EAAA,CAEA,GACAwK,GADAD,EAAAuD,EAAAtD,OAAA+d,CAEAhe,IAAAuD,EAAAvD,MACAC,EAAAsD,EAAAtD,QAGAD,EAAAuD,EAAAvD,MACAC,EAAAD,EAAAge,EAEA,IAAAzb,GAAAgB,EAAAf,EAAAe,EAAAvD,MAAA,EACAyC,EAAAc,EAAAb,EAAAa,EAAAtD,OAAA,CAEAsD,GAAAf,EAAAD,EAAAvC,EAAA,EACAuD,EAAAb,EAAAD,EAAAxC,EAAA,EACAsD,EAAAvD,MAAAA,EACAuD,EAAAtD,OAAAA,EAGAlP,KAAAktB,WAAAH,EAAAva,GAGA,MADAua,GAAAjnB,KAAA,QACAinB,EAzDA,GAAArB,GAAAxrB,EAAA,GACA4rB,EAAA5rB,EAAA,IACA+D,EAAA/D,EAAA,GACAqE,EAAArE,EAAA,GAyDAw2F,GAAAxxF,WAEAqrB,YAAAmmE,EAEA5wF,KAAA,QAIAonB,WAAA,SAAAH,EAAAva,GACA,GAAAua,EAAAM,eAAA,CAIA,GAAAC,GAAAP,EAAA5d,kBAEA3O,EAAA8sB,EAAAC,mBAAA/a,EAEAua,GAAAM,eAAA7sB,KAEAkY,YAAA,SAAAX,EAAAq8E,GACA,GAAAC,GAAA9xE,OAAAxK,GACAvF,EAAAxS,KAAAwS,KACA8hF,EAAA/xE,OAAA/P,EAAAvD,MAAAolF,GACAE,EAAAhyE,OAAA+xE,EAAA9hF,EAAAtD,OAAAsD,EAAAvD,MACAmlF,KACAE,EAAAn7E,SAAAm7E,EAAA,IACAC,EAAAp7E,SAAAo7E,EAAA,KAEA/hF,EAAAvD,MAAAqlF,EACA9hF,EAAAtD,OAAAqlF,EAEAv0F,KAAAwO,KAAA,OAAAgE,KAGAvO,EAAAkpB,SAAAupE,EAAA5qE,GACAjsB,EAAAD,QAAA82F,GpHs81BM,SAAU72F,EAAQD,EAASM,GqH9h2BjC,QAAAoyF,GAAAzxF,GAeA,GAAA87E,IACAj+D,gBAAA,cACAi4E,YAAA,OACA3kF,WAAA,EACA5F,YAAA,EACAwqF,YAAA,EACAC,SAAA,GACAC,WAAA,EACA7c,KAAA,GACA8c,WACAC,QACAllF,OAAA,OACAD,KAAA,QAEAolF,UACAnlF,OAAA,YAIA9R,MAAAoD,QAAAa,EAAA8M,MAAA4rE,EAAA97E,GAAA,GAEAb,KAAA8C,MAAAyB,EAAAmvF,SAAA,aAAA1zF,KAAAoD,SACAT,EAAA8D,MAAAlG,KAAAP,KAAAA,KAAAoD,SACApD,KAAAm6D,SA1CA,GAAAl2D,GAAA/D,EAAA,GACAyC,EAAAzC,EAAA,GACAqE,EAAArE,EAAA,GA0CAoyF,GAAAptF,WACAqrB,YAAA+hE,EACAxsF,KAAA,aACAq0D,OAAA,WACA,GAAAlwC,GAAAjqB,KAAAoD,QAAA2zF,UAAAC,OACAtrF,EAAA1L,KAAAoD,QAAA2zF,UAAAE,SACAJ,EAAA72F,KAAAoD,QAAAyzF,SACA5c,EAAAj6E,KAAAoD,QAAA62E,KACApvE,GACA4G,GAAAolF,EAAA,EACAllF,GAAAklF,EAAA,EACA5nF,MAAA4nF,EACA3nF,OAAA2nF,GAEA9pE,EAAA,IAAAktD,EAAAppE,QAAA,aAEAhG,EAAAC,MAAAmvE,EAAArxD,MAAA,GACA,GAAAjmB,GAAAiI,OACAC,MAAAA,KAGAlI,EAAAmqB,SACAmtD,EAAAtjD,QAAA,UAAA,KACA9rB,MAAAof,EACAve,WAAAA,EACA0xB,WAAA,GAEAvyB,EACA,SAGAlI,GAAAgJ,cAAAohB,GAEA/sB,KAAAoD,QAAA0zF,YACA/pE,EAAAmqE,QAAAl3F,KAAAoD,QAAAgtF,MACArjE,EAAAhmB,GAAA,YAAA,WAEAgmB,EAAAtf,UACA1C,KAAA/K,KAAAoD,QAAAgtF,MACAplF,aAAAU,EAAAV,cAAA,SACA6X,SAAAnX,EAAAmG,MAAAnG,EAAAoG,QAAA,OACAqP,UAAAzV,EAAAyV,WAAA,YAEqB3Z,KAAAxH,OACrB+G,GAAA,WAAA,WACAgmB,EAAAtf,UACAoV,SAAA,UAKAkK,EAAA/kB,QAAA,UACAhI,KAAA2G,IAAAomB,KAIA9oB,EAAAkpB,SAAAmlE,EAAA3vF,EAAA8D,OACA5G,EAAAD,QAAA0yF,GrHkk2BM,SAAUzyF,EAAQD,EAASM,GsH5r2BjC,YAOA,IAAAua,GAAAva,EAAA,KACAi3F,EAAAj3F,EAAA,KACAk3F,EAAAl3F,EAAA,KACA0M,EAAA1M,EAAA,KACAmE,EAAAnE,EAAA,IACAuE,IACAA,GAAAgW,KAAAhW,EAAAJ,EAAAoM,eAAAgK,EACAhW,EAAA0yF,KAAA1yF,EAAAJ,EAAAqM,aAAAymF,EACA1yF,EAAA2yF,MAAA3yF,EAAAJ,EAAAsM,YAAAymF,EACA3yF,EAAAmI,MAAAnI,EAAAJ,EAAAkI,YAAAK,EACA/M,EAAAD,QAAA6E,GtHyy2BM,SAAU5E,EAAQD,EAASM,GuHpx2BjC,QAAAua,GAAA5N,EAAAC,EAAA1J,GACA,GAAA+G,GAAA7F,EAAA+yF,qBAAAj0F,GAEAgE,EAAA,GAAA/C,GAAA8F,EAIA,OAHA/C,GAAAyF,UAAAA,EACAzF,EAAA0F,QAAAA,EAEA1F,EAVA,GAAA/C,GAAAnE,EAAA,IACAoE,EAAApE,EAAA,IAgDAua,GAAAk3E,cAAA,SAAAvuF,GACA,GAAA+G,GAAA7F,EAAA+yF,qBAAAj0F,GAEAgE,EAAA,GAAA/C,GAAA8F,EACA,OAAA/C,IAGAvH,EAAAD,QAAA6a,GvHm02BM,SAAU5a,EAAQD,EAASM,GwHx52BjC,GAAA+C,GAAA/C,EAAA,IACAsE,EAAAtE,EAAA,IACA6D,EAAA7D,EAAA,IACAoE,GACAgzF,UAAA,cACA1G,KAAA,aACA2G,KAAA,OACA9wF,MAAA,QACA+wF,MAAA,QACAC,KAAA,OACAC,OAAA,SACAC,OAAA,SACAC,KAAA,OACAC,QAAA,UACAC,SAAA,WACAC,KAAA,OACAC,YAAA,cACAC,IAAA,MACAC,MAAA,QAaA56E,YAAA,SAAAlU,EAAAyoB,GACAzoB,EAAAtG,MAAAE,IAAAC,EAAAwc,SAAAoS,IAYAsmE,YAAA,SAAA/uF,GACA,GAAAiU,GAAAjU,EAAAtG,MAAAuD,IAAApD,EAAAwc,SAIA,OAHA1b,GAAAoI,YAAAkR,KACAA,MAEAA,GAaAlW,OAAA,SAAArE,GACA,GAAAuW,GAAAvW,EAAAuD,IAAA/B,EAAAgzF,UACA,OAAAj+E,IAAA/U,EAAAssF,MAcA/oF,OAAA,SAAA/E,GACA,GACA+E,GADAwR,EAAAvW,EAAAuD,IAAA/B,EAAAgzF,UAOA,OAJAzvF,GADAwR,GAAA/U,EAAAssF,MAAAv3E,GAAA/U,EAAA4zF,OAQAtpF,UAAA,SAAAxF,GACA,MAAAA,GAAAjB,QAAAiB,EAAAjB,iBAAA3D,IAGA8F,YAAA,SAAAlB,GACA,MAAAA,aAAA5E,IAcA4zF,OAAA,SAAAt1F,GACA,GAAAuW,GAAAvW,EAAAuD,IAAA/B,EAAAgzF,UACA,OAAAj+E,IAAA/U,EAAAizF,MAaAc,QAAA,SAAAv1F,GACA,GAAAuW,GAAAvW,EAAAuD,IAAA/B,EAAAgzF,UACA,OAAAj+E,IAAA/U,EAAAkzF,OAaAc,OAAA,SAAAx1F,GACA,GAAAuW,GAAAvW,EAAAuD,IAAA/B,EAAAgzF,UACA,OAAAj+E,IAAA/U,EAAAmzF,MAaAc,SAAA,SAAAz1F,GACA,GAAAuW,GAAAvW,EAAAuD,IAAA/B,EAAAgzF,UACA,OAAAj+E,IAAA/U,EAAAozF,QAYA5pB,QAAA,SAAAhrE,GACA,GAAAuW,GAAAvW,EAAAuD,IAAA/B,EAAAgzF,UACA,OAAAj+E,IAEAg+E,qBAAA,SAAAj0F,GACA,GAAAA,EAAA,CACA,GAAAA,EAAA6J,IAAA,CACA,GAAAurF,GAAAp1F,EAAA6J,IAAAmI,MAAA,IACAojF,GAAAryF,QAAA,IACA/C,EAAA6H,WACA7H,EAAA6H,aAEA7H,EAAA6H,SAAAwI,SAAA+kF,EAAA,GACAp1F,EAAA6H,SAAAmI,OAAAolF,EAAA,IAGAp1F,EAAA2H,MAAA3H,EAAA2H,KAAAujB,QACAlrB,EAAA2H,KAAA8X,SAAAzf,EAAA2H,KAAAujB,OAGA,MAAAlrB,IAIAvD,GAAAD,QAAA0E,GxHs62BM,SAAUzE,EAAQD,EAASM,GyHnk3BjC,QAAAi3F,GAAAtqF,EAAAC,EAAA1J,GAEA,GAAA+G,GAAAlG,EAAA8M,OAAgClG,OAAO3C,SAAA7D,EAAAqM,cAAiCtN,GAAA,EACxE+G,GAAA7F,EAAA+yF,qBAAAltF,EACA,IAAA/C,GAAA,GAAA/C,GAAA8F,EAIA,OAHA/C,GAAAyF,UAAAA,EACAzF,EAAA0F,QAAAA,EAEA1F,EAZA,GAAA/C,GAAAnE,EAAA,IACA+D,EAAA/D,EAAA,GACAoE,EAAApE,EAAA,IAiDAi3F,GAAAxF,cAAA,SAAAvuF,GACA,GAAA+G,GAAAlG,EAAA8M,OAAgClG,OAAO3C,SAAA7D,EAAAqM,cAAiCtN,GAAA,EACxE+G,GAAA7F,EAAA+yF,qBAAAltF,EACA,IAAA/C,GAAA,GAAA/C,GAAA8F,EACA,OAAA/C,IAEAvH,EAAAD,QAAAu3F,GzHkn3BM,SAAUt3F,EAAQD,EAASM,G0Hxq3BjC,QAAAk3F,GAAAvqF,EAAAC,EAAA1J,GAEA,GAAA+G,GAAAlG,EAAA8M,OAAgClG,OAAO3C,SAAA7D,EAAAsM,aAAgCvN,GAAA,EACvE+G,GAAA7F,EAAA+yF,qBAAAltF,EAEA,IAAA/C,GAAA,GAAA/C,GAAA8F,EAIA,OAHA/C,GAAAyF,UAAAA,EACAzF,EAAA0F,QAAAA,EAEA1F,EAZA,GAAA/C,GAAAnE,EAAA,IACA+D,EAAA/D,EAAA,GACAoE,EAAApE,EAAA,IA+CAk3F,GAAAzF,cAAA,SAAAvuF,GACA,GAAA+G,GAAAlG,EAAA8M,OAAgClG,OAAO3C,SAAA7D,EAAAsM,aAAgCvN,GAAA,EACvE+G,GAAA7F,EAAA+yF,qBAAAltF,EACA,IAAA/C,GAAA,GAAA/C,GAAA8F,EACA,OAAA/C,IAEAvH,EAAAD,QAAAw3F,G1Hst3BM,SAAUv3F,EAAQD,EAASM,G2H3w3BjC,QAAA0M,GAAAC,EAAAC,EAAA1J,GACAA,EAAAyH,MAAA3C,SAAA7D,EAAAkI,UACA,IAAApC,GAAA7F,EAAA+yF,qBAAAj0F,GACAgE,EAAA,GAAA/C,GAAA8F,EAIA,OAHA/C,GAAAyF,UAAAA,EACAzF,EAAA0F,QAAAA,EAEA1F,EAVA,GAAA/C,GAAAnE,EAAA,IACAoE,EAAApE,EAAA,IA+CA0M,GAAA+kF,cAAA,SAAAvuF,GACA,GAAA+G,GAAA7F,EAAA+yF,qBAAAj0F,GACAgE,EAAA,GAAA/C,GAAA8F,EACA,OAAA/C,IAGAvH,EAAAD,QAAAgN,G3H0z3BM,SAAU/M,EAAQD,EAASM,G4H343BjC,QAAA8B,GAAAH,EAAAi4E,GACA95E,KAAAy4F,kBACAz4F,KAAAmO,QAAA,EACAnO,KAAA6B,kBAAAA,EACA7B,KAAA2B,KAAAm4E,EAPA,GAAAI,GAAAh6E,EAAA,IACA+D,EAAA/D,EAAA,GACA+5E,EAAA/5E,EAAA,GAWA8B,GAAAkD,UAAA4K,QAAA,SAAA9J,EAAA5C,GAEA,GAAAkX,GAAArW,EAAAyS,KAAAtT,EAAAwF,SAAAuI,MAAA,SAAA8oE,GACA,MAAAA,GAAAj0E,MAAAA,GAGA,IAAAsU,EAEA,WADAta,MAAA2I,cAAAvF,EAAAwF,SAGA,IAAA8vF,GAAA14F,KAAA24F,eAAA3yF,EAAA5C,EAGA,OAFApD,MAAA2B,KAAA8K,eAAA9F,IAAA+xF,GACA14F,KAAA2I,cAAAvF,EAAAwF,UACA8vF,GAKA12F,EAAAkD,UAAAyzF,eAAA,SAAA3yF,EAAA5C,GACA,GAAAs1F,GAAAxe,EAAA0B,aAAAx4E,EAAAy4E,SAAA,EAAA,EAAAz4E,EAAA6L,OAAA,GAAA7L,EAAA8L,QAAA,GAAA,EAAA9L,EAAAkrB,OAAA,UAsBA,OArBAoqE,GAAA1yF,IAAAA,EACA0yF,EAAArrB,OAAAjqE,EAAA6L,OAAA,GACAypF,EAAApxF,sBAAA,EACAoxF,EAAArtF,OACAjI,EAAAwF,SAAAuI,MAAA3H,KAAAkvF,GACA14F,KAAAy4F,eAAAjvF,KAAAkvF,GAGAA,EAAA3xF,GAAA,QAAA,SAAAgB,GACA,GAAA3E,EAAAsX,SACA3S,EAAAyR,KAAApW,EACA2E,EAAAa,SAAAxF,EAAAwF,SACAxF,EAAAsX,SAAA3S,OACa,CACb,GAAAD,KACAA,GAAAC,MAAAA,EACAD,EAAAhC,KAAA,QACAgC,EAAAuR,YAAA,oBACArZ,KAAA2B,KAAAqG,QAAAF,EAAAhC,KAAAgC,KAESN,KAAAxH,OACT04F,GAQA12F,EAAAkD,UAAAyD,cAAA,SAAAvB,GACA,QAAAwV,GAAAxT,GACA,MAAAA,GAAAjB,QAAA,cAAAiB,EAAAjB,OAAAqqB,SACAppB,EAAA6B,SAAA,GAAA2R,EAAAxT,EAAAjB,QAEAiB,EAAA6B,SAAA,GAIA,QAAA6R,GAAA1T,GACA,MAAAA,GAAAjB,QAAA,cAAAiB,EAAAjB,OAAAqqB,SACAppB,EAAA6B,SAAA,GAAA6R,EAAA1T,EAAAjB,QAEAiB,EAAA6B,SAAA,GAIA,GAAA,GAAAjL,KAAAmO,OAAA,CAGA,GAAAwV,GAAAC,EAAAg1E,EAAAxxF,EAAA07C,QACA17C,GAAAe,QAAA,cAAAf,EAAAe,OAAAqqB,UACA7O,EAAAi1E,EAAA,GAAAh8E,EAAAxV,EAAAe,QACAyb,EAAAg1E,EAAA,GAAA97E,EAAA1V,EAAAe,UAEAwb,EAAAi1E,EAAA,GACAh1E,EAAAg1E,EAAA,GAGA,IAAAC,GAAA50F,EAAAuf,IAAApc,EAAA+J,MAAA,SAAA8oE,GACA,MAAAA,GAAA5M,SAGAyrB,EAAA70F,EAAA+tB,OAAA6mE,EAAA,SAAAE,EAAAC,GACA,MAAAD,GAAAC,EAAA,IACS,EAET/0F,GAAA4E,KAAAzB,EAAA+J,MAAA,SAAA8oE,EAAArpE,GAEA,IAAA,GADAqoF,GAAA,EACA7qD,EAAA,EAA2BA,EAAAx9B,EAAWw9B,IACtC6qD,GAAAJ,EAAAzqD,GAAA,EAEA6rC,GAAAzrE,KAAA,YAAAmV,EAAAs1E,EAAAH,EAAA,EAAAl1E,EAAA,IACAq2D,EAAArsE,OACAqsE,EAAAif,WAAA9xF,MAIApF,EAAAkD,UAAAqC,qBAAA,WACAtD,EAAA4E,KAAA7I,KAAAy4F,eAAA,SAAAC,GACAA,EAAArtF,UAIArJ,EAAAkD,UAAAgL,cAAA,SAAAtH,EAAAxF,GACA,GAAAvC,GAAAoD,EAAAia,UACA29D,SAAA,UAAA5B,EAAAY,QACA5rE,MAAA,GACAC,OAAA,GACAtG,SAAAA,EACA8R,SAAA,SAAA1T,GACAhH,KAAA2B,KAAA8N,OAAAzI,EAAAE,OAAAgyF,aACa1xF,KAAAxH,OACJoD,GAAA,EAETpD,MAAA8P,QAAA,SAAAjP,IAGAmB,EAAAkD,UAAAiL,sBAAA,SAAAvH,EAAAxF,GACA,GAAAvC,GAAAoD,EAAAia,UACA29D,SAAA,UAAA5B,EAAA8O,qBACA95E,MAAA,GACAC,OAAA,GACAtG,SAAAA,EACA8R,SAAA,WACA1a,KAAA2B,KAAAyO,6BACa5I,KAAAxH,OACJoD,GAAA,EAETpD,MAAA8P,QAAA,SAAAjP,IAGAhB,EAAAD,QAAAoC,G5H253BM,SAAUnC,EAAQD,EAASM,G6Hhj4BjC,YAOA,IAAAssB,GAAAtsB,EAAA,IACA+D,EAAA/D,EAAA,GACAi5F,EAAAj5F,EAAA,IACAk5F,EAAAl5F,EAAA,KACAm5F,EAAAn5F,EAAA,KACAo5F,EAAAp5F,EAAA,KACAq5F,EAAAr5F,EAAA,KACAwiD,EAAAy2C,EAAAz2C,aACA82C,EAAAt5F,EAAA,KACAwE,IACAA,GAAA00F,QAAAA,EACA10F,EAAA20F,QAAAA,EACA30F,EAAA40F,WAAAA,EACA50F,EAAA60F,YAAAA,EACA70F,EAAA80F,KAAAA,EAOA90F,EAAA+0F,gBAAA,SAAAC,GACAh1F,EAAAg1F,aAAAA,GAIAh1F,EAAAi1F,cAAA,SAAAC,EAAAC,EAAAC,GACAA,EAAAX,EAAAjmE,kBAAA4mE,GAAA,EAEA,IAAAv2C,GAAAs2C,EAAA5qF,MACA8qF,EAAAF,EAAA3qF,OAEA0D,EAAA8vC,EAAAk3C,EAAAhnF,KAAA2wC,GACAzwC,EAAA4vC,EAAAk3C,EAAA9mF,IAAAinF,GACAlnF,EAAA6vC,EAAAk3C,EAAA/mF,MAAA0wC,GACAxwC,EAAA2vC,EAAAk3C,EAAA7mF,OAAAgnF,GACA9qF,EAAAyzC,EAAAk3C,EAAA3qF,MAAAs0C,GACAr0C,EAAAwzC,EAAAk3C,EAAA1qF,OAAA6qF,GAEAC,EAAAF,EAAA,GAAAA,EAAA,GACAG,EAAAH,EAAA,GAAAA,EAAA,GACA7sE,EAAA2sE,EAAA3sE,MA0CA,QAvCAxH,MAAAxW,KACAA,EAAAs0C,EAAA1wC,EAAAonF,EAAArnF,GAEA6S,MAAAvW,KACAA,EAAA6qF,EAAAhnF,EAAAinF,EAAAlnF,GAOA2S,MAAAxW,IAAAwW,MAAAvW,KACA+d,EAAAs2B,EAAAw2C,EACA9qF,EAAA,GAAAs0C,EAGAr0C,EAAA,GAAA6qF,GAIA,MAAA9sE,IAEAxH,MAAAxW,KACAA,EAAAge,EAAA/d,GAEAuW,MAAAvW,KACAA,EAAAD,EAAAge,IAKAxH,MAAA7S,KACAA,EAAA2wC,EAAA1wC,EAAA5D,EAAAgrF,GAEAx0E,MAAA3S,KACAA,EAAAinF,EAAAhnF,EAAA7D,EAAA8qF,GAIAJ,EAAAhnF,MAAAgnF,EAAA/mF,OACA,IAAA,SACAD,EAAA2wC,EAAA,EAAAt0C,EAAA,EAAA6qF,EAAA,EACA,MACA,KAAA,QACAlnF,EAAA2wC,EAAAt0C,EAAAgrF,EAGA,OAAAL,EAAA9mF,KAAA8mF,EAAA7mF,QACA,IAAA,SACA,IAAA,SACAD,EAAAinF,EAAA,EAAA7qF,EAAA,EAAA4qF,EAAA,EACA,MACA,KAAA,SACAhnF,EAAAinF,EAAA7qF,EAAA8qF,EAIApnF,EAAAA,GAAA,EACAE,EAAAA,GAAA,EACA2S,MAAAxW,KAEAA,EAAAs0C,EAAA3wC,GAAAC,GAAA,IAEA4S,MAAAvW,KAEAA,EAAA6qF,EAAAjnF,GAAAC,GAAA,GAGA,IAAAP,GAAA,GAAAga,GAAA5Z,EAAAknF,EAAA,GAAAhnF,EAAAgnF,EAAA,GAAA7qF,EAAAC,EAEA,OADAsD,GAAAsnF,OAAAA,EACAtnF,GAIA9N,EAAA0K,gBAAA,SAAAsa,EAAAkwE,EAAAC,EAAAC,EAAA3vF,GACA,GAAAw4B,IAAAx4B,IAAAA,EAAA+vF,IAAA/vF,EAAA+vF,GAAA,GACA9sF,GAAAjD,IAAAA,EAAA+vF,IAAA/vF,EAAA+vF,GAAA,GACA5qF,EAAAnF,GAAAA,EAAAmF,cAAA,KAEA,IAAAqzB,GAAAv1B,EAAA,CAIA,GAAAoF,EACA,IAAA,QAAAlD,EACAkD,EAAA,UAAAkX,EAAA5jB,MAAA,cAAA4jB,EAAA5jB,KACA,GAAA0mB,GAAA,EAAA,GAAAotE,EAAA3qF,OAAA,GAAA2qF,EAAA1qF,QAAA,GACAwa,EAAAva,sBAIA,IADAqD,EAAAkX,EAAAva,kBACAua,EAAA2Z,qBAAA,CACA,GAAA7T,GAAA9F,EAAA4F,mBAGA9c,GAAAA,EAAApM,QACAoM,EAAA6a,eAAAmC,GAIAoqE,EAAAl1F,EAAAi1F,cACA11F,EAAAia,UACiBjP,MAAAuD,EAAAvD,MAAAC,OAAAsD,EAAAtD,QACjB0qF,GAEAC,EACAC,EAMA,IAAAK,GAAAzwE,EAAAze,SACAo2B,EAAAsB,EAAAi3D,EAAAnoF,EAAAe,EAAAf,EAAA,EACA6vB,EAAAl0B,EAAAwsF,EAAAjoF,EAAAa,EAAAb,EAAA,CAEA+X,GAAAlb,KAAA,WAAA,QAAAc,GAAA+xB,EAAAC,IAAA64D,EAAA,GAAA94D,EAAA84D,EAAA,GAAA74D,MAIAzhC,EAAAD,QAAA8E,G7Huj4BM,SAAU7E,EAAQD,EAASM,G8H7r4BjC,QAAAk5F,GAAAv4F,GAOA,GAAA87E,IACAvvC,IAAA,EACAptB,SAAA8tC,EAAAA,EAEA9tD,MAAAoD,QAAAa,EAAA8M,MAAA4rE,EAAA97E,GAAA,GAbA,GAAAoD,GAAA/D,EAAA,GACAmE,EAAAnE,EAAA,GAmBAk5F,GAAAl0F,UAAA4uF,IAAA,SAAAhzF,GACA,GAAA2Q,GAAA,EACAE,EAAA,EACAyoF,EAAA,CAiCA,OAhCAt5F,GAAA+H,KAAA,SAAA0C,EAAAu/C,GACA,KAAAv/C,YAAAlH,IAAA,CAIA,GAIAg2F,GAJApvF,EAAAM,EAAAN,SACAuH,EAAAjH,EAAA4D,kBACAmrF,EAAAx5F,EAAAqxD,QAAArH,EAAA,GACAyvC,EAAAD,GAAAA,EAAAnrF,kBAGA6M,EAAAxJ,EAAAvD,OAAAsrF,GAAAA,EAAA9oF,EAAAe,EAAAf,EAAA,EACA4oF,GAAA5oF,EAAAuK,EAEAq+E,EAAAr6F,KAAAoD,QAAA4c,UAAAzU,EAAAivF,SACA/oF,EAAA,EACA4oF,EAAAr+E,EACArK,GAAAyoF,EAAAjhF,SAAAnZ,KAAAoD,QAAAgqC,IAAA,IACAgtD,EAAA5nF,EAAAtD,QAEAkrF,EAAA/mF,KAAA6Q,IAAAk2E,EAAA5nF,EAAAtD,QAGA3D,EAAAivF,UAIAvvF,EAAA,GAAAwG,EACAxG,EAAA,GAAA0G,EACAF,EAAA4oF,EAAAr6F,KAAAoD,QAAAgqC,OACiBptC,MAEjBo5F,GAEAv5F,EAAAD,QAAAw5F,G9H6u4BM,SAAUv5F,EAAQD,EAASM,G+Hpy4BjC,QAAAm5F,GAAAx4F,GAOA,GAAA87E,IACAvvC,IAAA,EACAqtD,UAAA3sC,EAAAA,EAEA9tD,MAAAoD,QAAAa,EAAA8M,MAAA4rE,EAAA97E,GAAA,GAbA,GAAAoD,GAAA/D,EAAA,GACAmE,EAAAnE,EAAA,GAoBAm5F,GAAAn0F,UAAA4uF,IAAA,SAAAhzF,GACA,GAAA2Q,GAAA,EACAE,EAAA,EACAyoF,EAAA,CAkCA,OAjCAt5F,GAAA+H,KAAA,SAAA0C,EAAAu/C,GACA,KAAAv/C,YAAAlH,IAAA,CAIA,GAIAq2F,GAJAzvF,EAAAM,EAAAN,SACAuH,EAAAjH,EAAA4D,kBACAmrF,EAAAx5F,EAAAqxD,QAAArH,EAAA,GACAyvC,EAAAD,GAAAA,EAAAnrF,kBAGA8M,EAAAzJ,EAAAtD,QAAAqrF,GAAAA,EAAA5oF,EAAAa,EAAAb,EAAA,EACA+oF,GAAA/oF,EAAAsK,EAEAy+E,EAAA16F,KAAAoD,QAAAq3F,WAAAlvF,EAAAivF,SACA/oF,GAAA2oF,EAAAjhF,SAAAnZ,KAAAoD,QAAAgqC,IAAA,IACAz7B,EAAA,EACA+oF,EAAAz+E,EACAm+E,EAAA5nF,EAAAvD,OAGAmrF,EAAA/mF,KAAA6Q,IAAAk2E,EAAA5nF,EAAAvD,OAGA1D,EAAAivF,UAIAvvF,EAAA,GAAAwG,EACAxG,EAAA,GAAA0G,EACAA,EAAA+oF,EAAA16F,KAAAoD,QAAAgqC,OACiBptC,MAEjBq5F,GAEAx5F,EAAAD,QAAAy5F,G/Hs14BM,SAAUx5F,EAAQD,EAASM,GgIr34BjC,QAAAo5F,GAAAz4F,GAqBA,GAAA87E,IACAge,OAAA,WACAC,YAAA,GACAC,aAAA,IACAC,cAAmCrpF,EAAA,IAAAE,EAAA,KACnCopF,YAAA,IACAC,WAAgC/tF,IAAA,aAAA2vE,QAA0B92E,KAAA,SAE1D,gBAAAjF,EAAA85F,SACAhe,EAAAqe,UAAA/tF,IAAA,cAGAjN,KAAAoD,QAAAa,EAAAia,SAAAy+D,EAAA97E,GAAA,GACAb,KAAA46F,YAAA56F,KAAAoD,QAAAw3F,YACA56F,KAAA66F,aAAA76F,KAAAoD,QAAAy3F,aACA76F,KAAAi7F,SAAAj7F,KAAAoD,QAAA63F,SACAj7F,KAAAk7F,iBACAl7F,KAAAmtE,WACAntE,KAAAm7F,cA7CA,GAAAl3F,GAAA/D,EAAA,GACAssB,EAAAtsB,EAAA,IACAi5F,EAAAj5F,EAAA,IACAwiD,EAAAy2C,EAAAz2C,aACA04C,EAAAl7F,EAAA,KACAm7F,EAAAn7F,EAAA,IAiDAo5F,GAAAp0F,UAAAo2F,iBAAA,SAAAC,GAGA,QAAAC,GAAA3sF,EAAA4sF,GACA,GAAAC,MACAj+E,IAEAxZ,GAAA4E,KAAA/B,EAAA,SAAAM,GACAA,EAAAyF,YAAAgC,IACAzH,EAAA0F,QAAA8yD,SACAniD,EAAAjU,KAAApC,EAAA0F,YAKA2Q,EAAAtX,OAAA,GAEAlC,EAAA4E,KAAA4U,EAAA,SAAArU,GACA,GAAAuyF,IAA6CtzF,KAAAe,EAAA/I,GAAA+I,KAAAA,EAC7CsyF,GAAAlyF,KAAAmyF,GACAH,EAAApyF,EAAAuyF,KAIAD,EAAAv1F,OAAA,IACAs1F,EAAAnyF,SAAAoyF,GAxBA,GAAA50F,GAAA9G,KAAAi7F,SAAAp5F,kBAAAiF,WA2BA80F,GAAoCvzF,KAAAkzF,EAAAl7F,GAAA+I,KAAAmyF,EAEpC,OADAC,GAAAD,EAAAK,GACA57F,KAAA67F,UAAsCriF,MAAAoiF,KAAoB,IAY1DtC,EAAAp0F,UAAA22F,SAAA,SAAAJ,EAAAK,GACA,GAAAC,GAAAN,EAAAjiF,KAAA,EAcA,OAbAxZ,MAAAy7F,SAAAA,EAEAz7F,KAAAg8F,KAAAZ,EAAAa,eAAAF,EAAA1zF,KAAA0zF,EAAAzyF,UACAtJ,KAAAg8F,KAAAt8F,KAAA8Z,KAAAuiF,EAGA/7F,KAAAk8F,WAAAT,GAGAz7F,KAAAm8F,cAAA,WACAn8F,KAAAo8F,cAAAN,IACiBt0F,KAAAxH,OAEjBA,KAAAmP,mBAQAmqF,EAAAp0F,UAAAk3F,cAAA,SAAAN,GACA97F,KAAAg8F,KAAAxxE,SAAA,SAAA6xE,GAEAA,EAAA/yF,SAAAnD,OAAA,IAAA21F,EACA97F,KAAAs8F,mBAAAD,EAAAr8F,KAAAy7F,SAAAc,oBAEAv8F,KAAAi7F,SAAAp5F,kBAAAqX,kBAAAmjF,EAAA7iF,KAAApQ,OAEiBpJ,OASjBs5F,EAAAp0F,UAAAiK,gBAAA,WACA,GAAAqD,GAAA,IAMA,OALAxS,MAAAg8F,KAAAxxE,SAAA,SAAA6xE,GACA,GAAArpC,GAAAxmC,EAAA+W,QAAyD9xB,EAAA4qF,EAAA33F,OAAAuG,SAAA,GAAA0G,EAAA0qF,EAAA33F,OAAAuG,SAAA,GAAAgE,MAAAotF,EAAA33F,OAAAuK,MAAAC,OAAAmtF,EAAA33F,OAAAwK,QACzDsD,KAAAA,EAAAwgD,EAAA5sD,SACAoM,EAAA0zC,MAAA8M,IACiBhzD,MACjBwS,GAKA8mF,EAAAp0F,UAAAi3F,cAAA,SAAAK,GACA,GAAAC,GAAA,EACAC,EAAA,GAAArB,IAEAT,YAAA56F,KAAA46F,YACAC,aAAA76F,KAAA66F,cAKA76F,MAAAg8F,KAAAxxE,SAAA,SAAA6xE,GACA,GAAAp4F,EAAA4M,QAAA7Q,KAAAm7F,WAAAkB,OAAA,CACA,GAAAzlF,GAAAylF,EAAA7iF,KAAApQ,KAAA+F,iBACAktF,GAAA33F,QACAuK,MAAAotF,EAAA7iF,KAAApQ,KAAAikE,QAAAz2D,EAAA3H,MACAC,OAAAmtF,EAAA7iF,KAAApQ,KAAAkkE,SAAA12D,EAAA1H,UAIiBlP,MACjB08F,EAAAvB,WAAAn7F,KAAAm7F,WACAuB,EAAA5I,IAAA9zF,KAAAg8F,KAEA,IAAArB,GAAA36F,KAAAoD,QAAAu3F,OACAgC,EAAA38F,KAAAoD,QAAA03F,aAAArpF,EACAmrF,EAAA58F,KAAAoD,QAAA03F,aAAAnpF,EACAkrF,EAAA78F,KAAAi7F,SAAA51F,WACAy3F,EAAA98F,KAAAi7F,SAAA31F,WAEAq3F,GADA,WAAAA,EACA,GAAAE,EAGAn6C,EAAAi6C,EAAAE,GAGAD,EADA,WAAAA,EACA,GAAAE,EAGAp6C,EAAAk6C,EAAAE,GAEAF,EAAAl6C,EAAAk6C,EAAAE,GAEA,eAAAnC,GACAgC,EAAAl3E,MAAAk3E,GAAA,GAAAA,EACAC,EAAAn3E,MAAAm3E,GAAA,GAAAE,EAAAF,IAIAD,EAAAl3E,MAAAk3E,GAAA,GAAAE,EAAAF,EACAC,EAAAn3E,MAAAm3E,GAAA,GAAAA,EAGA,IAAAG,GAAA/8F,KAAAg8F,KAAAt8F,KAAAgF,OAAAuG,SAAA,GAEA+xF,EAAAN,EAAAn1D,MAAAvnC,KAAAg8F,MAAAh8F,KAAAm7F,WAAAh1F,OACA6e,EAAA8oC,EAAAA,CAEA9tD,MAAAg8F,KAAAxxE,SACA,SAAA6xE,GACA,GAAA5qF,GACAE,CACA1N,GAAA4M,QAAA7Q,KAAAm7F,WAAAkB,SACA,aAAA1B,GAAA,YAAA36F,KAAAoD,QAAAusB,WACAle,EAAA4qF,EAAA33F,OAAAuG,SAAA,GAAA8xF,EAAAJ,EACAhrF,EAAAirF,EAAAP,EAAA33F,OAAAuG,SAAA,IAEA,aAAA0vF,GACAlpF,EAAA4qF,EAAA33F,OAAAuG,SAAA,GAAA8xF,EAAAJ,EACAhrF,EAAA0qF,EAAA33F,OAAAuG,SAAA,GAAA2xF,GAEA,eAAAjC,GAAA,YAAA36F,KAAAoD,QAAAusB,WACAhe,EAAA0qF,EAAA33F,OAAAuG,SAAA,GAAA8xF,EAAAH,EACAnrF,EAAAkrF,EAAAN,EAAA33F,OAAAuG,SAAA,IAEA,eAAA0vF,IACAhpF,EAAA0qF,EAAA33F,OAAAuG,SAAA,GAAA8xF,EAAAH,EACAnrF,EAAA4qF,EAAA33F,OAAAuG,SAAA,GAAA0xF,GAEAN,EAAA33F,OAAAu4F,IAAAxrF,EACA4qF,EAAA33F,OAAAw4F,IAAAvrF,EACAA,EAAAqT,IACAA,EAAArT,KAIA3R,MAGAA,KAAAg8F,KAAAxxE,SAAA,SAAA6xE,GACAp4F,EAAA4M,QAAA7Q,KAAAm7F,WAAAkB,SACAr3E,EAAA,GACAq3E,EAAA33F,OAAAuG,SAAA,GAAAoxF,EAAA33F,OAAAu4F,IACAZ,EAAA33F,OAAAuG,SAAA,GAAAoxF,EAAA33F,OAAAw4F,MAEAb,EAAA33F,OAAAuG,SAAA,GAAAoxF,EAAA33F,OAAAu4F,IACAZ,EAAA33F,OAAAuG,SAAA,GAAAoxF,EAAA33F,OAAAw4F,IAAAl4E,GAGAq3E,EAAA7iF,KAAApQ,KAAAqiB,WACAxgB,UAAAoxF,EAAA33F,OAAAuG,SAAA,GAAAoxF,EAAA33F,OAAAuG,SAAA,KACyBjL,KAAAoD,QAAA23F,YAAA,aACzB0B,IAAAO,GACAR,KAEyBh1F,KAAAxH,OAEzB,GAAAA,KAAAm7F,WAAAh1F,QACAk2F,EAAA/yF,SAAAnD,OAAA,GAAAk2F,EAAA7iF,KAAApQ,KAAA+zF,eACAd,EAAA7iF,KAAApQ,KAAA+zF,eAAA,KAKiBn9F,OAGjBs5F,EAAAp0F,UAAAg3F,WAAA,SAAAT,GACAA,EAAA2B,qBACA3B,EAAA2B,mBAAAp9F,KAAAq9F,4BAGAr9F,KAAAg8F,KAAAxxE,SAAA,SAAA6xE,GACA,IAAAA,EAAA7iF,KAAApQ,KAAA,CACA,GAAAg0F,GAAAf,EAAA7iF,KAAA4jF,oBAAA3B,EAAA2B,mBACAh0F,EAAAg0F,EAAAf,EAAA7iF,KAAAxZ,KACAoJ,GAAAk0F,YAAA,EACAt9F,KAAAi7F,SAAAt0F,IAAAyC,GACAizF,EAAA7iF,KAAApQ,KAAAA,IAEiBpJ,OAGjBs5F,EAAAp0F,UAAAm4F,2BAAA,SAAA/qF,GACA,GAAAgxE,GAAAtjF,KAAAi7F,SAAA99E,WAAA,UACAlW,OAA4B2K,EAAA,IAC5B/G,OAA4BgH,KAAA,WAC5BxJ,KAAAiK,EAAAirF,OAAAjrF,EAAAjK,MAEA,OAAAi7E,IAGAgW,EAAAp0F,UAAAo3F,mBAAA,SAAAkB,EAAAjB,GACA,IAAA,GAAAlvF,GAAA,EAAAowF,EAAAD,EAAAl0F,SAAAnD,OAA6EkH,EAAAowF,EAAiBpwF,IAC9FrN,KAAA09F,WAAAF,EAAAA,EAAAl0F,SAAA+D,GAAAkvF,IAKAjD,EAAAp0F,UAAAw4F,WAAA,SAAAC,EAAAC,EAAArB,GACA,GAAAn1F,GAAA,KACAyF,EAAA8wF,EAAAnkF,KAAApQ,KACA0D,EAAA8wF,EAAApkF,KAAApQ,IACA,IAAAmzF,EAAA,CACA,GAAAsB,GAAAD,EAAApkF,IACAqkF,GAAAhxF,UAAAA,EACAgxF,EAAA/wF,QAAAA,EACA1F,EAAAm1F,EAAAsB,OACqB,CACrB,GAAAC,GAAA99F,KAAAoD,QAAA43F,SACA4C,GAAApkF,KAAAwhF,YACA8C,EAAA75F,EAAA8M,MAAA9M,EAAAmC,MAAA03F,GAAAF,EAAApkF,KAAAwhF,WAAA,IAEA5zF,EAAApH,KAAAi7F,SAAA17E,WAAA1S,EAAAC,EAAAgxF,GAEA99F,KAAAi7F,SAAAt0F,IAAAS,IAWAkyF,EAAAp0F,UAAA64F,SAAA,SAAA1B,EAAA7iF,EAAAkB,GACA,GAAAsjF,GAAA,GAAA5C,GAAA5hF,EAAAnR,MAAA3I,IACAs+F,GAAAxkF,KAAAA,CAEA,IAAApQ,GAAApJ,KAAAy7F,SAAA2B,mBAAAY,EAAAxkF,KAAAxZ,KAgBA,OAfAoJ,GAAAk0F,YAAA,EACAjB,EAAA/yF,SAAAnD,QAAA,EACAiD,EAAAoF,KAAA,WAAAvK,EAAAmC,MAAAi2F,EAAA/yF,SAAA+yF,EAAA/yF,SAAAnD,OAAA,GAAAzB,OAAAuG,WAEA7B,EAAAoF,KAAA,WAAAvK,EAAAmC,MAAAi2F,EAAA33F,OAAAuG,WAGAjL,KAAAi7F,SAAAt0F,IAAAyC,GACA40F,EAAAxkF,KAAApQ,KAAAA,EACAgC,WAAA,WACApL,KAAA09F,WAAArB,EAAA2B,EAAAh+F,KAAAy7F,SAAAc,qBACiB/0F,KAAAxH,MAAAA,KAAAoD,QAAA23F,aAEjBsB,EAAA11F,IAAAq3F,GACAh+F,KAAAi+F,uBAAAvjF,GACAtR,GAQAkwF,EAAAp0F,UAAAg5F,YAAA,SAAA90F,GACA,GAAA+0F,GAAAn+F,KAAAo+F,mBAAAh1F,EACAA,GAAAk0F,YACAa,EAAA3zE,SAAA,SAAA6xE,GACAA,EAAA7iF,KAAApQ,OAAAA,IACAizF,EAAA7iF,KAAApQ,KAAAiC,OACApH,EAAA4M,QAAA7Q,KAAAm7F,WAAAkB,QACAr8F,KAAAm7F,WAAA3xF,KAAA6yF,GAEAr8F,KAAAi7F,SAAAp5F,kBAAA0pF,iBAAA8Q,EAAA7iF,KAAApQ,MAAA,GACAizF,EAAA/yF,SAAAnD,OAAA,IACAk2F,EAAA7iF,KAAApQ,KAAAk0F,YAAA,EACAjB,EAAA7iF,KAAApQ,KAAA+zF,eAAAd,EAAA7iF,KAAApQ,KAAA+zF,eAAA,MAGqBn9F,MACrBoJ,EAAAk0F,YAAA,EACAl0F,EAAA+zF,eAAA/zF,EAAA+zF,eAAA,GACAn9F,KAAAi+F,2BAEAE,EAAA3zE,SAAA,SAAA6xE,GACAA,EAAA7iF,KAAApQ,OAAAA,IACAizF,EAAA7iF,KAAApQ,KAAAwE,OACA5N,KAAAm7F,WAAA5tF,OAAAtJ,EAAA4M,QAAA7Q,KAAAm7F,WAAAkB,GAAA,GACAr8F,KAAAi7F,SAAAp5F,kBAAA0pF,iBAAA8Q,EAAA7iF,KAAApQ,MAAA,GACAizF,EAAA/yF,SAAAnD,OAAA,IACAk2F,EAAA7iF,KAAApQ,KAAAk0F,YAAA,EACAjB,EAAA7iF,KAAApQ,KAAA+zF,eAAAd,EAAA7iF,KAAApQ,KAAA+zF,eAAA,MAGqBn9F,MACrBoJ,EAAAk0F,YAAA,EACAl0F,EAAA+zF,eAAA/zF,EAAA+zF,eAAA,GACAn9F,KAAAi+F,2BAUA3E,EAAAp0F,UAAAk5F,mBAAA,SAAAh1F,GACA,GAAAi1F,GAAA,IAMA,OALAr+F,MAAAg8F,KAAAxxE,SAAA,SAAA6xE,GACAA,EAAA7iF,KAAApQ,OAAAA,IACAi1F,EAAAhC,KAGAgC,GASA/E,EAAAp0F,UAAA6U,WAAA,SAAA3Q,GACA,GAAAizF,GAAAr8F,KAAAo+F,mBAAAh1F,GACAo0F,EAAAnB,EAAAl0F,MACA,SAAAq1F,IAEAnB,EAAA7xE,SAAA,SAAA8zE,GACAt+F,KAAAi7F,SAAAxrF,OAAA6uF,EAAA9kF,KAAApQ,OACiBpJ,MAEjBw9F,EAAA/tF,OAAA4sF,GAGA,IAAAmB,EAAAl0F,SAAAnD,QACAq3F,EAAAhkF,KAAApQ,KAAAm1F,aAAAf,EAAAhkF,KAAApQ,KAAAm1F,cAIAv+F,KAAAi+F,0BACA,IASA3E,EAAAp0F,UAAAs5F,eAAA,SAAAp1F,GACA,GAAAizF,GAAAr8F,KAAAo+F,mBAAAh1F,EAaA,OAXAizF,GAAA7xE,SAAA,SAAA8zE,GACAA,IAAAjC,GACAr8F,KAAAi7F,SAAAxrF,OAAA6uF,EAAA9kF,KAAApQ,OAEiBpJ,MAEjBq8F,EAAAoC,oBACAr1F,EAAAm1F,aAAAn1F,EAAAm1F,cAGAv+F,KAAAi+F,0BACA,GAQA3E,EAAAp0F,UAAA+4F,uBAAA,SAAAvjF,GACA1a,KAAAg8F,KAAAt8F,KAAAg/F,qBAAA,GACA1+F,KAAAm8F,cAAA,WACAn8F,KAAAg8F,KAAAxxE,SAAA,SAAA8zE,GACAt+F,KAAAi7F,SAAAp5F,kBAAAqX,kBAAAolF,EAAA9kF,KAAApQ,OACqBpJ,MACrB0a,GAAAA,KACiBlT,KAAAxH,QASjBs5F,EAAAp0F,UAAAy5F,eAAA,SAAAv1F,EAAAumB,GACA,GAEAivE,GAFA/vF,EAAAzF,EAAAjB,OACA02F,EAAA56F,EAAA4M,QAAAhC,EAAAvF,SAAAF,EAEA,SAAAumB,EACAivE,EAAAC,EAAA,EACiB,QAAAlvE,IACjBivE,EAAAC,EAAA,EAEA,IAAAzqF,GAAAvF,EAAAvF,SAAAs1F,EACA,IAAAxqF,EAAA,CACA,GAAAo+C,GAAAp+C,CACAvF,GAAAvF,SAAAs1F,GAAAx1F,EACAyF,EAAAvF,SAAAu1F,GAAArsC,EAEAxyD,KAAAi+F,yBACAj+F,KAAAi7F,SAAAjzF,QAAA,6BACAoB,KAAAA,EACAyF,WAAAA,EACAuF,WAAAA,KAIAvU,EAAAD,QAAA05F,GhIk84BM,SAAUz5F,EAAQD,EAASM,GiIv+5BjC,QAAA4+F,GAAAz+F,EAAAmZ,GAIAxZ,KAAAK,GAAAA,EAKAL,KAAA++F,MAAA,EAKA/+F,KAAAkP,OAAA,EAKAlP,KAAAsJ,YAKAtJ,KAAAmI,OAAA,KAMAnI,KAAAwZ,KAAAA,GAAA,KAqGA,QAAAggF,GAAAn5F,GAIAL,KAAAN,KAAA,GAAAo/F,GAAAz+F,GA9IA,GAAA4D,GAAA/D,EAAA,EA4CA4+F,GAAA55F,UAAAyB,IAAA,SAAA4E,GACA,GAAAjC,GAAAtJ,KAAAsJ,QACAiC,GAAApD,SAAAnI,OAIAsJ,EAAAE,KAAA+B,GACAA,EAAApD,OAAAnI,OAOA8+F,EAAA55F,UAAAuK,OAAA,SAAAlE,GACA,GAAAjC,GAAAtJ,KAAAsJ,SACAwhD,EAAA7mD,EAAA4M,QAAAvH,EAAAiC,EACAu/C,IAAA,IACAxhD,EAAAiE,OAAAu9C,EAAA,GACAv/C,EAAApD,OAAA,OAIA22F,EAAA55F,UAAAu5F,kBAAA,WAEA,IAAA,GADAn1F,GAAAtJ,KAAAsJ,SACA+D,EAAA,EAAwBA,EAAA/D,EAAAnD,OAAqBkH,IAAA,CAC7C,GAAA9B,GAAAjC,EAAA+D,EACA9B,GAAApD,OAAA,KAEAnI,KAAAsJ,aAQAw1F,EAAA55F,UAAAslB,SAAA,SAAA3M,EAAAC,GACAD,EAAAtd,KAAAud,EAAA9d,KAEA,KAAA,GAAAqN,GAAA,EAAuBA,EAAArN,KAAAsJ,SAAAnD,OAA0BkH,IACjDrN,KAAAsJ,SAAA+D,GAAAmd,SAAA3M,EAAAC,IAOAghF,EAAA55F,UAAAqiC,MAAA,WACA,GAAAA,GAAA,CAIA,OAHAvnC,MAAAwqB,SAAA,WACA+c,MAEAA,GAOAu3D,EAAA55F,UAAAw5F,qBAAA,SAAAK,GACA,GAAA7vF,GAAA,CACAlP,MAAA++F,MAAAA,CACA,KAAA,GAAA1xF,GAAA,EAAuBA,EAAArN,KAAAsJ,SAAAnD,OAA0BkH,IAAA,CACjD,GAAA9B,GAAAvL,KAAAsJ,SAAA+D,EACA9B,GAAAmzF,qBAAAK,EAAA,GACAxzF,EAAA2D,OAAAA,IACAA,EAAA3D,EAAA2D,QAGAlP,KAAAkP,OAAAA,EAAA,GAOA4vF,EAAA55F,UAAA85F,YAAA,SAAA3+F,GACA,GAAAL,KAAAK,KAAAA,EACA,MAAAL,KAEA,KAAA,GAAAqN,GAAA,EAAuBA,EAAArN,KAAAsJ,SAAAnD,OAA0BkH,IAAA,CACjD,GAAA8G,GAAAnU,KAAAsJ,SAAA+D,GAAA2xF,YAAA3+F,EACA,IAAA8T,EACA,MAAAA,KAsBAqlF,EAAAt0F,UAAAslB,SAAA,SAAA3M,EAAAC,GACA9d,KAAAN,KAAA8qB,SAAA3M,EAAAC,IAQA07E,EAAAt0F,UAAA+5F,WAAA,SAAA5+F,GACA,GAAAX,GAAAM,KAAAg/F,YAAA3+F,EACA,IAAAX,EAAA,CACA,GAAAs8F,GAAA,GAAAxC,GAAA95F,EAAAW,GAEA,OADA27F,GAAAt8F,KAAAA,EACAs8F,IAQAxC,EAAAt0F,UAAA85F,YAAA,SAAA3+F,GACA,MAAAL,MAAAN,KAAAs/F,YAAA3+F,IAUAm5F,EAAAyC,eAAA,SAAA57F,EAAAmZ,GASA,QAAA0lF,GAAAC,EAAAtwF,GACA,GAAAzF,GAAA,GAAA01F,GAAAK,EAAA92F,KAAA82F,EACAtwF,GAAAlI,IAAAyC,EAEA,IAAAE,GAAA61F,EAAA71F,QACA,IAAAA,EACA,IAAA,GAAA+D,GAAA,EAA+BA,EAAA/D,EAAAnD,OAAqBkH,IACpD6xF,EAAA51F,EAAA+D,GAAAjE,GAfA,GAAA4yF,GAAA,GAAAxC,GAAAn5F,GACAk7F,EAAAS,EAAAt8F,IAEA67F,GAAA/hF,MACAnR,KAAAhI,EACAiJ,SAAAkQ,EAeA,KAAA,GAAAnM,GAAA,EAAuBA,EAAAmM,EAAArT,OAAiBkH,IACxC6xF,EAAA1lF,EAAAnM,GAAAkuF,EAKA,OAFAS,GAAAt8F,KAAAg/F,qBAAA,GAEA1C,GAIAxC,EAAA4F,eAAA,SAAAC,EAAAC,GAEA,QAAAC,GAAA5yB,GACA,MAAA1oE,GAAAoU,OAAAgnF,EAAAh3E,KAAA,SAAA/V,GACA,GAAAA,EAAAke,OAAAm8C,IAAAr6D,EAAArF,IACA,MAAAqF,KAMA,QAAA4sF,GAAAx/F,GAEA,IAAA,GADA8/F,GAAAD,EAAA7/F,EAAAW,IACAgN,EAAA,EAA2BA,EAAAmyF,EAAAr5F,OAAsBkH,IAAA,CACjD,GAAAiF,GAAAktF,EAAAnyF,GACAoyF,EAAAC,EAAAptF,EAAAqtF,GACAjgG,GAAA4J,SAAAE,KAAAi2F,GACAP,EAAAO,IAKA,IAAA,GADAC,MACAryF,EAAA,EAAuBA,EAAAgyF,EAAAj2F,KAAAjD,OAA4BkH,IAAA,CACnD,GAAAjE,GAAAi2F,EAAAj2F,KAAAiE,GACAgvF,EAAA,GAAAyC,GAAA11F,EAAAf,KAAAe,EACAs2F,GAAAt2F,EAAAf,MAAAg0F,EAGA,GAAAL,GAAA,GAAAxC,GAAA8F,EAAAj3F,MACAkzF,EAAAS,EAAAt8F,IAQA,OANA67F,GAAA/hF,KAAA8lF,EAGAJ,EAAAlD,EAAAt8F,MACAs8F,EAAAt8F,KAAAg/F,qBAAA,GAEA1C,GAGAn8F,EAAAD,QAAA45F,GjIs/5BM,SAAU35F,EAAQD,EAASM,GkIjv6BjC,QAAAm7F,GAAAx6F,GACAA,EAAAA,MAEAb,KAAA46F,YAAA/5F,EAAA+5F,aAAA,GAEA56F,KAAA66F,aAAAh6F,EAAAg6F,cAAA,IAEA76F,KAAAk7F,iBAEAl7F,KAAAmtE,WAEAntE,KAAAm7F,cAdA,GAAAr1C,GAAA5lD,EAAA,IACA+D,EAAA/D,EAAA,EAgBAm7F,GAAAn2F,UAAAqiC,MAAA,SAAAy0D,GACA,GAAAz0D,GAAA,CAIA,OAHAy0D,GAAAxxE,SAAA,WACA+c,MAEAA,GAGA8zD,EAAAn2F,UAAA4uF,IAAA,SAAAkI,GACAh8F,KAAAk7F,cAAA/0F,OAAA,CACA,KAAA,GAAAkH,GAAA,EAAuBA,EAAA2uF,EAAAt8F,KAAAwP,OAAA,EAA0B7B,IACjDrN,KAAAk7F,cAAA7tF,GAAA,EACArN,KAAAmtE,QAAA9/D,KAEArN,MAAA4/F,qBAAA5D,EAAAt8F,KACA,IAAAA,GAAAs8F,EAAAt8F,IACAM,MAAA6/F,qBAAAngG,EAAA,EAAAA,EAAAgF,OAAAwK,SAGAmsF,EAAAn2F,UAAA06F,qBAAA,SAAAx2F,GACA,GAAA2b,GAAA+oC,EAAAA,EACA7oC,IAAA6oC,EAAAA,EACA1kD,GAAA1E,OAAAuG,SAAA7B,EAAA1E,OAAAuG,UAAA66C,EAAAviB,QACA,KAAA,GAAAl2B,GAAA,EAAuBA,EAAAjE,EAAAE,SAAAnD,OAA0BkH,IAAA,CACjD,GAAA9B,GAAAnC,EAAAE,SAAA+D,EACA,IAAApJ,EAAA4M,QAAA7Q,KAAAm7F,WAAA5vF,OAAA,CACAvL,KAAA4/F,qBAAAr0F,EACA,IAAAkG,GAAAlG,EAAA7G,OAAAuG,SAAA,EACAwG,GAAAsT,IACAA,EAAAtT,GAEAA,EAAAwT,IACAA,EAAAxT,IAIArI,EAAAE,SAAAnD,OAAA,GAAAlC,EAAA4M,QAAA7Q,KAAAm7F,WAAA/xF,EAAAE,SAAA,QACAF,EAAA1E,OAAAuG,SAAA,IAAA8Z,EAAAE,GAAA,GAEA7b,EAAA1E,OAAAuG,SAAA,GAAA,EACA7B,EAAA8F,OAAA,EAEA,IAAAnG,GAAA/I,KAAAk7F,cAAA9xF,EAAA21F,QAAA,CACA,IAAAh2F,EAAAK,EAAA1E,OAAAuG,SAAA,GAAA,CACA,GAAAmsB,GAAAruB,EAAAK,EAAA1E,OAAAuG,SAAA,EACAjL,MAAA8/F,cAAA12F,EAAAguB,EACA,KAAA,GAAAzZ,GAAAvU,EAAA21F,MAAA,EAAwCphF,EAAAvU,EAAA8F,OAAA9F,EAAA21F,MAA8BphF,IACtE3d,KAAAk7F,cAAAv9E,IAAAyZ,EAGAp3B,KAAAk7F,cAAA9xF,EAAA21F,OAAA31F,EAAA1E,OAAAuG,SAAA,GAAA7B,EAAA1E,OAAAuK,MAAAjP,KAAA46F,YAEA32F,EAAA4M,QAAA7Q,KAAAmtE,QAAA/jE,EAAA21F,OAAA31F,QACApJ,KAAAmtE,QAAA/jE,EAAA21F,OAAAv1F,KAAAJ,IAIAiyF,EAAAn2F,UAAA46F,cAAA,SAAApgG,EAAAyT,GACAzT,EAAAgF,OAAAuG,SAAA,IAAAkI,CACA,KAAA,GAAA9F,GAAA,EAAuBA,EAAA3N,EAAA4J,SAAAnD,OAA0BkH,IACjDpJ,EAAA4M,QAAA7Q,KAAAm7F,WAAAz7F,EAAA4J,SAAA+D,SACArN,KAAA8/F,cAAApgG,EAAA4J,SAAA+D,GAAA8F,IAKAkoF,EAAAn2F,UAAA26F,qBAAA,SAAAz2F,EAAAuI,EAAAouF,GACA,GAAA97F,EAAA4M,QAAA7Q,KAAAm7F,WAAA/xF,OAAA,CACAA,EAAA1E,OAAAuG,SAAA,GAAA0G,CAEA,KAAA,GADAquF,GAAA,EACA3yF,EAAA,EAA2BA,EAAAjE,EAAAE,SAAAnD,OAA0BkH,IACrD2yF,EAAA3sF,KAAA6Q,IAAA9a,EAAAE,SAAA+D,GAAA3I,OAAAwK,OAAA8wF,EAEA,IAAAnF,GAAA76F,KAAA66F,YACA,mBAAA,KACAA,EAAAA,EAAAzxF,EAAA21F,OAEA,KAAA,GAAAphF,GAAA,EAA2BA,EAAAvU,EAAAE,SAAAnD,OAA0BwX,IACrD3d,KAAA6/F,qBAAAz2F,EAAAE,SAAAqU,GAAAhM,EAAAkpF,EAAAkF,EAAAC,KAKAngG,EAAAD,QAAAy7F,GlI4v6BM,SAAUx7F,EAAQD,EAASM,GmI3y6BjC,QAAAq5F,GAAA14F,GA+BAb,KAAAi7F,SAAAp6F,EAAAo6F,QACA,IAAAte,IACAsjB,UAAA,IACAC,QAAA,GACAC,WAAA,GACAC,MAAA,EACAC,iBAAA,EACA7tF,MAAmBf,EAAA,EAAAE,EAAA,EAAA1C,MAAAjP,KAAAi7F,SAAA51F,WAAA6J,OAAAlP,KAAAi7F,SAAA31F,aACnB01F,WAAwBpe,QAAQ92E,KAAA,SAChCw6F,mBAGAtgG,MAAAoD,QAAAa,EAAAia,SAAAy+D,EAAA97E,GAAA,GA9CA,GAAA0/F,GAAArgG,EAAA,KACA4lD,EAAA5lD,EAAA,IACA+D,EAAA/D,EAAA,EA0DAq5F,GAAAr0F,UAAA22F,SAAA,SAAA2E,GACA,GAAAzE,GAAAyE,EAAAhnF,KAAA,EACAxZ,MAAAyB,SAAAzB,KAAAk8F,WAAAH,EAAA1pF,MAAAmuF,EAAApD,oBACAp9F,KAAAygG,SAAAzgG,KAAA0gG,YAAA3E,EAAA4E,MAAAH,EAAAjE,oBACAv8F,KAAA4gG,YAEA5gG,KAAA6gG,8BAOAtH,EAAAr0F,UAAA47F,WAAA,WACA9gG,KAAAyB,SAAAzB,KAAAi7F,SAAAx5F,SACAzB,KAAAygG,SAAAzgG,KAAAi7F,SAAAp5F,kBAAAiF,WACA9G,KAAA4gG,YACA5gG,KAAA6gG,8BAGAtH,EAAAr0F,UAAAg3F,WAAA,SAAA6E,EAAA3D,GACA4D,KAAArmF,WAAAyiF,KACAA,EAAAp9F,KAAAq9F,2BAAA71F,KAAAxH,MAEA,IAAAyB,KAWA,OATAwC,GAAA4E,KAAAk4F,EAAA,SAAAzuF,EAAAw4C,GACA,IAAAx4C,EAAAlJ,KAAA,CACA,GAAA+T,GAAA7K,EAAA8qF,oBAAAA,EACAh0F,EAAA+T,EAAA7K,EACAtS,MAAAi7F,SAAAt0F,IAAAyC,GACApJ,KAAAihG,cAAA73F,EAAA0hD,GACArpD,EAAA+H,KAAAJ,KAESpJ,MACTyB,GAGA83F,EAAAr0F,UAAA+7F,cAAA,SAAA73F,EAAA0hD,GACA9qD,KAAAoD,QAAAg9F,MACAh3F,EAAArC,GAAA,OAAA,WACA/G,KAAAoD,QAAA89F,cACAlhG,KAAAoD,QAAA89F,YAAAC,UACAnhG,KAAAohG,YAAAphG,KAAA6gG,6BACA7gG,KAAAoD,QAAA89F,YAAAG,SAAAv2C,KAEa9qD,MAAA+G,GAAA,UAAA,WACb/G,KAAAoD,QAAA89F,aACAlhG,KAAAoD,QAAA89F,YAAAI,WAAAx2C,IAEa9qD,OAIbu5F,EAAAr0F,UAAAm4F,2BAAA,SAAA/qF,GACA,GAAAgxE,GAAAtjF,KAAAi7F,SAAA99E,WAAA,UACAlW,OAAoB2K,EAAA,IACpB/G,OAAoBgH,KAAA,WACpBxJ,KAAAiK,EAAAirF,OAAAjrF,EAAAjK,MAEA,OAAAi7E,IAGAiW,EAAAr0F,UAAAw7F,YAAA,SAAAC,EAAApE,GACA,GAAAkE,KAuBA,OArBAx8F,GAAA4E,KAAA83F,EAAA,SAAAt4E,GACA,GAAAxb,GAAA7M,KAAAi7F,SAAA19E,YAAA8K,EAAA4H,QACAnjB,EAAA9M,KAAAi7F,SAAA19E,YAAA8K,EAAAnhB,OACA,IAAA2F,GAAAC,EAAA,CACA,GAAA1F,GAAA,IACA,IAAAm1F,EAAA,CACA,GAAAsB,GAAAx1E,CACAw1E,GAAAhxF,UAAAA,EACAgxF,EAAA/wF,QAAAA,EACA1F,EAAAm1F,EAAAsB,OACiB,CACjB,GAAAC,GAAA99F,KAAAoD,QAAA43F,SACA3yE,GAAAxd,QACAizF,EAAA75F,EAAA8M,MAAA9M,EAAAmC,MAAA03F,GAAAz1E,EAAAxd,OAAA,IAEAzD,EAAApH,KAAAi7F,SAAA17E,WAAA1S,EAAAC,EAAAgxF,GAEA99F,KAAAi7F,SAAAt0F,IAAAS,GACAq5F,EAAAj3F,KAAApC,KAESpH,MACTygG,GAIAlH,EAAAr0F,UAAA07F,UAAA,WACA,GAAApuF,GAAAxS,KAAAoD,QAAAoP,KACAm6B,EAAA3sC,KACAsgG,EAAAtgG,KAAAoD,QAAAk9F,gBACAjuF,EAAApO,EAAAuf,IAAAxjB,KAAAyB,SAAA,SAAA2H,GACA,GAAAm4F,GAAAvhG,KAAAoD,QAAA68F,SACA,OAD6C72F,GAAAmyB,EAAAgmE,EAAcn4F,EAAAm4F,IAAAA,EAAgBn4F,EAAA1I,EAAA,MAE3E66B,EAAAgmE,EACAA,IAAAA,EACA7gG,EAAA,OAESV,KACTsgG,IACAr8F,EAAA4E,KAAA7I,KAAAyB,SAAA,SAAA2H,EAAA0hD,GACA1hD,EAAAoF,KAAA,WAAA8xF,EAAAx1C,MAGA7mD,EAAA4E,KAAA7I,KAAAygG,SAAA,SAAAp4E,GACAA,EAAAm5E,GAAAn5E,EAAAxb,UACAwb,EAAAo5E,GAAAp5E,EAAAvb,QACAub,EAAA4d,EAAAjmC,KAAAoD,QAAA+8F,WACA93E,EAAAq5E,UAAA,GACS1hG,KAET,IAAA2hG,GAAApB,EAAAvgG,KAAAyB,SAAAzB,KAAAygG,UACAjuF,KAAAA,EACA0tF,QAAAlgG,KAAAoD,QAAA88F,UAEA0B,EAAAD,EAAArgG,IACAqgG,GAAArgG,KAAA,SAAAuc,GACA5Z,EAAA4E,KAAA7I,KAAAyB,SAAA,SAAA2H,GACAiJ,EAAAwvF,OACA/7C,EAAAxqB,KAAAjpB,EAAA3R,EAAA2R,EAAApH,YAIA22F,EAAA,SAAAngG,EAAAg/F,EAAAqB,GACA,IAAA,GAAAz0F,GAAA,EAAAy1B,EAAArhC,EAAA0E,OAAoDkH,EAAAy1B,EAAOz1B,IAC3D5L,EAAA4L,GAAAw0F,OACApgG,EAAA4L,GAAAmB,KAAA,WAAA/M,EAAA4L,GAAA3M,GAEA4/F,EAAAjzF,GAAA5L,EAAA4L,GAAA3M,CAGAuD,GAAA4E,KAAA43F,EAAA,SAAAr5F,GACAulC,EAAAsuD,SAAAp5F,kBAAA4nF,iBAAAriF,GAAA,KAGAyW,GAAAA,EAAAikF,MAGA9hG,KAAAoD,QAAA89F,YAAAS,EACA3hG,KAAAoD,QAAAk9F,gBAAAA,EAEAqB,EAAArgG,QAIAi4F,EAAAr0F,UAAA27F,2BAAA,WACA,GAAAl0D,GAAA3sC,KACAqgG,EAAArgG,KAAAoD,QAAAi9F,iBACA,QAAA/+F,KACAqrC,EAAAvpC,QAAA89F,YAAA5/F,KAAA,SAAAwgG,GACAn1D,EAAAy0D,YAAAU,EACAn1D,EAAAy0D,WACAf,EACA1zD,EAAAo1D,eAAA32F,WAAA9J,EAAA,IAEAA,IAGAqrC,EAAAsuD,SAAAjzF,QAAA,wBAKAnI,EAAAD,QAAA25F,GnIw36BM,SAAU15F,EAAQD,EAASM,GoI5o7BjC,GAAA4lD,GAAA5lD,EAAA,IACAylC,EAAAmgB,EAAAngB,WAMA9lC,GAAAD,QAAA,SAAAyS,EAAA2vF,EAAAnhG,GAkBA,IAAA,GAjBA2R,GAAA3R,EAAA2R,KACAvD,EAAAuD,EAAAvD,MACAC,EAAAsD,EAAAtD,OACA8I,GAAAxF,EAAAf,EAAAxC,EAAA,EAAAuD,EAAAb,EAAAzC,EAAA,GAEAgxF,EAAA,MAAAr/F,EAAAq/F,QAAA,GAAAr/F,EAAAq/F,QAYA7yF,EAAA,EAAuBA,EAAAgF,EAAAlM,OAAkBkH,IAAA,CACzC,GAAA2H,GAAA3C,EAAAhF,EACA2H,GAAAtU,IAgBAsU,EAAAtU,EAAAolD,EAAAviB,OACAt0B,GAAAoE,KAAAgoD,SAAA,IAAArjD,EAAA,GACA9I,GAAAmE,KAAAgoD,SAAA,IAAArjD,EAAA,KAIAhD,EAAAitF,GAAAn8C,EAAA1/C,MAAA4O,EAAAtU,GACAsU,EAAAgtF,MAAA,KAOA,GAAAE,GAAA,EAEA,QACAf,OAAA,WACAe,EAAA,IAGAb,SAAA,SAAAv2C,GACAz4C,EAAAy4C,GAAA+2C,OAAA,GAGAP,WAAA,SAAAx2C,GACAz4C,EAAAy4C,GAAA+2C,OAAA,GAGAvgG,KAAA,SAAAuc,GAGA,IAAA,GAFAskF,MACAC,EAAA/vF,EAAAlM,OACAkH,EAAA,EAA+BA,EAAA20F,EAAA77F,OAAkBkH,IAAA,CACjD,GAAArG,GAAAg7F,EAAA30F,GACAm0F,EAAAx6F,EAAAw6F,GACAC,EAAAz6F,EAAAy6F,EAEA37C,GAAA1rC,IAAA+nF,EAAAV,EAAA/gG,EAAA8gG,EAAA9gG,EACA,IAAAulC,GAAA6f,EAAA11B,IAAA+xE,GAAAn7F,EAAAi/B,EACA1K,EAAAkmE,EAAAlmE,GAAAimE,EAAAjmE,EAAAkmE,EAAAlmE,EACAuqB,GAAA9f,UAAAm8D,EAAAA,IAEAX,EAAAK,OAAAl8D,EAAA67D,EAAA9gG,EAAA8gG,EAAA9gG,EAAAyhG,EAAA5mE,EAAA0K,EAAAi8D,IACAT,EAAAI,OAAAl8D,EAAA87D,EAAA/gG,EAAA+gG,EAAA/gG,EAAAyhG,IAAA,EAAA5mE,GAAA0K,EAAAi8D,GAGA,IAAA,GAAA70F,GAAA,EAA+BA,EAAA+0F,EAAU/0F,IAAA,CACzC,GAAA2H,GAAA3C,EAAAhF,EACA2H,GAAA6sF,QACA/7C,EAAA1rC,IAAA+nF,EAAAnqF,EAAAhD,EAAAtU,GAIAolD,EAAAngB,YAAA3wB,EAAAtU,EAAAsU,EAAAtU,EAAAyhG,EAAAjC,EAAAgC,IAMA,IAAA,GAAA70F,GAAA,EAA+BA,EAAA+0F,EAAU/0F,IAEzC,IAAA,GADAm0F,GAAAnvF,EAAAhF,GACAsQ,EAAAtQ,EAAA,EAAuCsQ,EAAAykF,EAAUzkF,IAAA,CACjD,GAAA8jF,GAAApvF,EAAAsL,EACAmoC,GAAA1rC,IAAA+nF,EAAAV,EAAA/gG,EAAA8gG,EAAA9gG,EACA,IAAAulC,GAAA6f,EAAA11B,IAAA+xE,EACA,KAAAl8D,IAEA6f,EAAA9iD,IAAAm/F,EAAA9uF,KAAAgoD,SAAA,GAAAhoD,KAAAgoD,SAAA,IACAp1B,EAAA,EAEA,IAAAo8D,IAAAb,EAAAD,IAAAE,EAAAF,KAAAt7D,EAAAA,GACAu7D,EAAAK,OAAAl8D,EAAA67D,EAAAS,GAAAT,EAAAS,GAAAE,EAAAE,IACAZ,EAAAI,OAAAl8D,EAAA87D,EAAAQ,GAAAR,EAAAQ,GAAAE,GAAAE,GAIA,IAAA,GADAj1F,MACAC,EAAA,EAA+BA,EAAA+0F,EAAU/0F,IAAA,CACzC,GAAA2H,GAAA3C,EAAAhF,EACA2H,GAAA6sF,QACA/7C,EAAA1rC,IAAAhN,EAAA4H,EAAAtU,EAAAsU,EAAAitF,IACAn8C,EAAAngB,YAAA3wB,EAAAtU,EAAAsU,EAAAtU,EAAA0M,EAAA80F,GACAp8C,EAAAxqB,KAAAtmB,EAAAitF,GAAAjtF,EAAAtU,IAIAwhG,EAAA,KAAAA,EAEArkF,GAAAA,EAAAxL,EAAA2vF,EAAAE,EAAA,SpIyp7BM,SAAUriG,EAAQD,GqI3s7BxB,QAAAgF,GAAAsf,GAEAlkB,KAAAkkB,IAAAA,GAAAo+E,EAAAC,OACAviG,KAAAwiG,SAAA,KACAxiG,KAAAyiG,SAAA,KAKAziG,KAAA0iG,QA5DA,GAAAC,GAAA,aAEAL,GAEAC,OAAA,EAGAK,MAAA,GAGAC,GAEAC,QAAA,WACA,GAAA7oC,GAAA,GAAArvD,MAEA,OAAAqvD,GAAA8oC,QACA,SAAAniG,EAAAyH,EAAApC,GAEA,MADArF,GAAAmiG,QAAA16F,GAAApC,EACAA,GAGA,SAAArF,EAAAyH,EAAApC,GAEA,MADArF,GAAAknB,aAAA,QAAAzf,EAAApC,GACAA,MAKA+8F,QAAA,WACA,GAAA/oC,GAAA,GAAArvD,MAEA,OAAAqvD,GAAA8oC,QACA,SAAAniG,EAAAyH,GACA,MAAAzH,GAAAmiG,QAAA16F,GAGAzH,EAAAmiG,QAAA16F,GAFAzH,EAAAonB,aAAA,QAAA3f,IAMA,SAAAzH,EAAAyH,GACA,MAAAzH,GAAAonB,aAAA,QAAA3f,OAyBAzD,GAAAM,UAAA+9F,SAAA,WACA,GAAA51F,GAAA4sD,EAAApoC,EAAAk/B,CAEA,KADAA,EAAA/wD,KACAqN,EAAA,EAAmBA,EAAArN,KAAAkkB,IAAc7W,IACjCwkB,KACAooC,EAAA,GAAArvD,OACAi4F,EAAAC,QAAA7oC,EAAA,KAAA5sD,GACA4sD,EAAAxS,OAAA,WAEAsJ,EAAAmyC,OAAAnyC,EAAAoyC,QAAAnjG,MAAA,UAAAA,MAEA+wD,EAAAqyC,YAAApjG,OAEAi6D,EAAAopC,QAAA,WACA,GAAAj6F,GAAA2nD,EAAAoyC,QAAAnjG,KAEAoJ,GAAAw5F,MAAAN,EAAAM,OACAx5F,EAAAw5F,MAAAx5F,EAAAw5F,MAAA,EAEA7xC,EAAAuyC,WAAAvyC,EAAA5zC,WAAA/T,EAAAw+C,IAAAx+C,EAAAhG,QAAAgG,EAAA85F,OAAA95F,EAAAtI,MAAAsI,EAAAw5F,SAIA7xC,EAAAmyC,OAAA95F,EAAA,QAAApJ,MAGA+wD,EAAAqyC,YAAApjG,OAEA6xB,EAAAooC,IAAAA,EACApoC,EAAA0xE,MAAA,EACAvjG,KAAA0iG,KAAAl5F,KAAAqoB,IAUAjtB,EAAAM,UAAAg+F,OAAA,SAAA95F,EAAAo6F,EAAAvpC,GACA7wD,EAAA85F,OAAAM,EAAAvpC,IAOAr1D,EAAAM,UAAAk+F,YAAA,SAAAxiG,GAEAZ,KAAAwiG,UAEAxiG,KAAAyjG,OAAA7iG,EAAAZ,KAAAwiG,UAEAxiG,KAAA0jG,aAGA1jG,KAAAwjG,OAAA5iG,GAAA,IAOAgE,EAAAM,UAAAy+F,QAAA,WACA,GAAAx9F,GAAAkH,CACA,KAAAA,EAAA,EAAAlH,EAAAnG,KAAA0iG,KAAAv8F,OAA8CkH,EAAAlH,EAAYkH,IAC1D,GAAArN,KAAA0iG,KAAAr1F,GAAAk2F,KACA,MAAAvjG,MAAA0iG,KAAAr1F,EAGA,OAAA,OASAzI,EAAAM,UAAAu+F,OAAA,SAAA7iG,EAAAwI,GAEApJ,KAAAwjG,OAAA5iG,GAAA,GAEAZ,KAAA4jG,QAAAhjG,EAAAwI,GAEAxI,EAAAgnD,IAAAx+C,EAAAw+C,KAQAhjD,EAAAM,UAAAs+F,OAAA,SAAA5iG,EAAA4iG,GACA,GAAAnjG,GAAAwiG,EAAAG,QAAApiG,EAAA,KACAP,KACAL,KAAA0iG,KAAAriG,GAAAkjG,KAAAC,GAIAA,IACAxjG,KAAA0iG,KAAAriG,GAAA+I,KAAA,OASAxE,EAAAM,UAAA0+F,QAAA,SAAAhjG,EAAAwI,GACA,GAAA/I,GAAAwiG,EAAAG,QAAApiG,EAAA,KACA,IAAAP,EAEA,MADAL,MAAA0iG,KAAAriG,GAAA+I,KAAAA,EACApJ,KAAA0iG,KAAAriG,GAAA+I,OAAAA,GASAxE,EAAAM,UAAAi+F,QAAA,SAAAviG,GACA,GAAAP,GAAAwiG,EAAAG,QAAApiG,EAAA,KACA,IAAAP,EACA,MAAAL,MAAA0iG,KAAAriG,GAAA+I,MAUAxE,EAAAM,UAAA2+F,MAAA,SAAAj8C,EAAAxkD,GACA,GAAA0gG,MACAP,EAAA,KACAp9F,EAAA,EACAkH,EAAA,EAEA61F,EAAA,WACA,MAAA9/F,GAAAg9F,KACA,SAAAoD,EAAAvpC,GACA,GAAArpB,GAAA5wC,KAAAc,MACAkgE,EAAAhhE,KAAAoD,OAEAwtC,GAAA4yD,GAAAh6F,KAAAywD,GAEArpB,EAAAmzD,QAAA59F,OAAAyqC,EAAAowC,MAAA76E,SAAAyqC,EAAArJ,OAGAn8B,WAAA,WACA41D,EAAA+iC,QAAAxjG,KAAA,KAAAqwC,EAAAmzD,QAAAnzD,EAAAowC,MAAApwC,EAAArJ,QAC6B,IAI7B,SAAAi8D,EAAAvpC,GACA,GAAA+G,GAAAhhE,KAAAoD,OAEAgI,YAAA,WACA41D,EAAAwiC,GAAAjjG,KAAA,KAAA05D,IACyB,OAIzBn5D,GACAymC,MAAA,EACAw8D,WACA/iB,UAEA53E,EAAA,IAQA,KAPAhG,EAAAA,MACAA,EAAA2gG,QAAA3gG,EAAA2gG,SAAApB,EACAv/F,EAAA49E,MAAA59E,EAAA49E,OAAA2hB,EACAmB,EAAAA,EAAA51F,OAAA05C,GAEA9mD,EAAAymC,MAAAu8D,EAAA39F,OAEAkH,EAAA,EAAAlH,EAAA29F,EAAA39F,OAAyCkH,EAAAlH,EAAYkH,IAErDjE,EAAApJ,KAAAmd,WAAA2mF,EAAAz2F,GAAAjK,EAAA8/F,EAAApiG,GAEAyiG,EAAAvjG,KAAA2jG,UACAJ,EAEAvjG,KAAAyjG,OAAAF,EAAAtpC,IAAA7wD,GAGApJ,KAAAsjG,WAAAl6F,IASAxE,EAAAM,UAAA8+F,MAAA,WACA,GAAAxX,MACArmF,EAAA,EACAkH,EAAA,EACAjE,EAAA,IAYA,KAVAojF,EAAA+V,UAEA/V,EAAA+V,OAAAh7D,MAAAvnC,KAAA0iG,KAAAv8F,OAEAqmF,EAAA+V,OAAAgB,KAAA,EAEA/W,EAAAyX,QAEAzX,EAAAyX,KAAA18D,MAAA,EAEAl6B,EAAA,EAAAlH,EAAAnG,KAAA0iG,KAAAv8F,OAA8CkH,EAAAlH,EAAYkH,IAC1DrN,KAAA0iG,KAAAr1F,GAAAk2F,OACA/W,EAAA+V,OAAAgB,KAAA/W,EAAA+V,OAAAgB,KAAA,EAKA,IADAn6F,EAAApJ,KAAAwiG,SAGA,IADAhW,EAAAyX,KAAA18D,MAAAilD,EAAAyX,KAAA18D,MAAA,EACAn+B,EAAAu0C,MACA6uC,EAAAyX,KAAA18D,MAAAilD,EAAAyX,KAAA18D,MAAA,EACAn+B,EAAAA,EAAAu0C,IAGA,OAAA6uC,IAaA5nF,EAAAM,UAAAiY,WAAA,SAAAyqC,EAAAxkD,EAAA8/F,EAAApiG,EAAAyC,GACA,GAAA6F,KAMA,OALAA,GAAAw+C,IAAAA,EACAx+C,EAAAhG,QAAAA,EACAgG,EAAA85F,OAAAA,EACA95F,EAAAtI,MAAAA,EACAsI,EAAAw5F,MAAAr/F,GAAA,EACA6F,GAOAxE,EAAAM,UAAAo+F,WAAA,SAAAl6F,GAEApJ,KAAAwiG,UAIAxiG,KAAAyiG,SAAA9kD,KAAAv0C,EACApJ,KAAAyiG,SAAAr5F,IAJApJ,KAAAwiG,SAAAp5F,EACApJ,KAAAyiG,SAAAr5F,IAUAxE,EAAAM,UAAAw+F,UAAA,WAEA1jG,KAAAwiG,WAEAxiG,KAAAwiG,SAAAxiG,KAAAwiG,SAAA7kD,MAAA,MAQA,IAAAp1B,GAAA,SAAArE,GACA,GAAAk+C,GAAA,GAAAx9D,GAAAsf,EAEA,OADAk+C,GAAA6gC,YAUAliC,KAAA,WACAqB,EAAAyhC,MAAAjpF,MAAAwnD,EAAAl8D,YAMAsmF,KAAA,WACA,MAAApqB,GAAA4hC,MAAAzjG,KAAA6hE,KAKAviE,GAAAD,SAAsB2oB,cAAAA,IrIqy7BhB,SAAU1oB,EAAQD,EAASM,GsInr8BjC,QAAAgkG,GAAAC,EAAArqB,GACA95E,KAAAokG,gBAAA,GAAAC,GAAAvqB,EAAA30E,SAAA20E,GACA95E,KAAA2B,KAAAm4E,EACA95E,KAAAskG,cAAAH,EACAnkG,KAAAukG,mBAAAJ,EAAA99F,IAAA,qBACArG,KAAAwkG,sBAuOA,QAAAC,GAAAx5F,EAAAuH,EAAAkyF,GACA,GAAAC,GAAAD,EAAA,GACAE,EAAAF,EAAA,GACAt3D,EAAA,EACA37B,EAAA,EACAE,EAAA,EACAkzF,EAAAryF,EAAAvD,MACA61F,EAAAtyF,EAAAtD,MACA,QAAAjE,GACA,IAAA,SACAwG,EAAAe,EAAAf,EAAAozF,EAAA,EAAAF,EAAA,EACAhzF,EAAAa,EAAAb,EAAAmzF,EAAA,EAAAF,EAAA,CACA,MACA,KAAA,MACAnzF,EAAAe,EAAAf,EAAAozF,EAAA,EAAAF,EAAA,EACAhzF,EAAAa,EAAAb,EAAAizF,EAAAx3D,CACA,MACA,KAAA,SACA37B,EAAAe,EAAAf,EAAAozF,EAAA,EAAAF,EAAA,EACAhzF,EAAAa,EAAAb,EAAAmzF,EAAA13D,CACA,MACA,KAAA,OACA37B,EAAAe,EAAAf,EAAAkzF,EAAAv3D,EACAz7B,EAAAa,EAAAb,EAAAmzF,EAAA,EAAAF,EAAA,CACA,MACA,KAAA,QACAnzF,EAAAe,EAAAf,EAAAozF,EAAAz3D,EACAz7B,EAAAa,EAAAb,EAAAmzF,EAAA,EAAAF,EAAA,EAEA,OAAAnzF,EAAAE,GAEA,QAAAozF,GAAAtzF,EAAAE,EAAA+X,EAAAs7E,EAAAC,EAAAC,EAAAC,GACA,GAAAl2F,GAAAya,EAAApH,YACApT,EAAAwa,EAAA07E,YAcA,OAZA3zF,GAAAxC,EAAAi2F,EAAAF,EACAvzF,GAAAxC,EAAAi2F,EAGAzzF,GAAAyzF,EAEAvzF,EAAAzC,EAAAi2F,EAAAF,EACAtzF,GAAAzC,EAAAi2F,EAGAxzF,GAAAwzF,GAEA1zF,EAAAE,GAGA,QAAA0zF,GAAAC,GACA,MAAA,WAAAA,GAAA,WAAAA,EAGA,QAAAC,GAAA9zF,EAAAE,EAAA+X,EAAAs7E,EAAAC,GACA,GAAAh2F,GAAAya,EAAApH,YACApT,EAAAwa,EAAA07E,YAOA,OALA3zF,GAAA4B,KAAA4Q,IAAAxS,EAAAxC,EAAA+1F,GAAA/1F,EACA0C,EAAA0B,KAAA4Q,IAAAtS,EAAAzC,EAAA+1F,GAAA/1F,EACAuC,EAAA4B,KAAA6Q,IAAAzS,EAAA,GACAE,EAAA0B,KAAA6Q,IAAAvS,EAAA,IAEAF,EAAAE,GAlTA,GAAA0yF,GAAAnkG,EAAA,KACAslG,EAAAtlG,EAAA,KACA6C,EAAA7C,EAAA,IACA+D,EAAA/D,EAAA,GACA0zD,EAAA1zD,EAAA,IACAi5F,EAAAj5F,EAAA,IACAwE,EAAAxE,EAAA,IASAgkG,GAAAh/F,UAAAs/F,oBAAA,WACA,GAAAiB,GAAAzlG,KAAAskG,cAAAj+F,IAAA,YAEAm/F,GAAAE,SACA,cACA1lG,KAAA2B,KACA,SAAAgkG,EAAA3+F,EAAApB,GACA,SAAA6/F,IACAA,EAAA50F,QAAA80F,IAAA,EACA3lG,KAAA4lG,SAAA5+F,EAAApB,GAEA,UAAA+/F,GACA3lG,KAAA6lG,MAAAjgG,KAGa4B,KAAAxH,QAIbkkG,EAAAh/F,UAAA0gG,SAAA,SAAA5+F,EAAApB,GACA,GAAA8jB,GAAA1iB,EAAAE,OACAi9F,EAAAnkG,KAAAskG,aAEAH,KAKAnkG,KAAAmmE,OAAAn/D,EAAAuB,QACAvI,KAAAomE,OAAAp/D,EAAAwB,QAEAkhB,GAAAA,EAAAjnB,QACAzC,KAAA8lG,0BAAA9+F,EAAA0iB,GAGA1pB,KAAA6lG,MAAAjgG,KAIAs+F,EAAAh/F,UAAA2gG,MAAA,SAAAjgG,GAMA5F,KAAA+lG,oBAAA,KACAngG,GACAE,KAAA,UACA0qB,KAAAxwB,KAAAgmG,MAEAhmG,KAAAimG,mBAGA/B,EAAAh/F,UAAAO,QAAA,WACAmuD,EAAAxqD,OAGApJ,KAAAokG,gBAAA/4F,OACAm6F,EAAAU,WAAA,cAAAlmG,KAAA2B,QAGAuiG,EAAAh/F,UAAA+gG,gBAAA,WACA,GAAAE,GAAAnmG,KAAAokG,eAEApkG,MAAAukG,oBACA4B,EAAAC,UAAApmG,KAAAskG,cAAAj+F,IAAA,cAGArG,KAAAmmE,OAAAnmE,KAAAomE,OAAA,MAKA89B,EAAAh/F,UAAA4gG,0BAAA,SAAA9+F,EAAA0iB,GACA,GAAA28E,GAAA38E,EAAAjnB,OACA,IAAA,gBAAA4jG,GAAA,CACA,GAAAzkF,GAAAykF,CACAA,IACAzkF,QAAAA,EAEA0kF,UAAA1kF,GAGA,GAAA2kF,GAAA,GAAAxjG,GAAAsjG,EAAArmG,KAAAskG,eACAkC,EAAAD,EAAAlgG,IAAA,WACAogG,EAAApzF,KAAAgoD,QAMAr7D,MAAA0mG,YAAAH,EAAA,WACAvmG,KAAA2mG,oBACAJ,EAAAC,EAAAD,EAAAlgG,IAAA,uBACAogG,EAAAz/F,EAAAuB,QAAAvB,EAAAwB,QAAAxB,EAAAiE,SAAAye,MAOAw6E,EAAAh/F,UAAAwhG,YAAA,SAAAvC,EAAAtmF,GAKA,GAAAupB,GAAA+8D,EAAA99F,IAAA,YACAwX,GAAA5Z,EAAAuD,KAAAqW,EAAA7d,MACAq3E,aAAAr3E,KAAA4mG,aACAx/D,EAAA,EACApnC,KAAA4mG,YAAAx7F,WAAAyS,EAAAupB,GACAvpB,KAGAqmF,EAAAh/F,UAAAyhG,oBAAA,SAAAxC,EAAAqC,EAAA1+F,EAAA2+F,EAAAh1F,EAAAE,EAAAk1F,EAAAn9E,GAIA,GAFA1pB,KAAA8mG,QAAA,GAEA3C,EAAA99F,IAAA,gBAAA89F,EAAA99F,IAAA,QAAA,CAIA,GAAA8/F,GAAAnmG,KAAAokG,gBAEAkC,EAAAnC,EAAA99F,IAAA,YACAwgG,GAAAA,GAAA1C,EAAA99F,IAAA,WACA,IAAA0gG,GAAAP,CAEA,IAAAF,GAAA,gBAAAA,GACAS,EAAA5N,EAAAvG,UAAA0T,EAAAx+F,GAAA,OAEA,IAAA,kBAAAw+F,GAAA,CACA,GAAA5rF,GAAA,SAAAssF,EAAAD,GACAC,IAAAhnG,KAAA8mG,UACAX,EAAAc,WAAAF,GACA/mG,KAAAknG,gBACA/C,EAAA0C,EAAAp1F,EAAAE,EAAAw0F,EAAAr+F,EAAA4hB,KAGiBliB,KAAAxH,KACjBA,MAAA8mG,QAAAL,EACAM,EAAAT,EAAAx+F,EAAA2+F,EAAA/rF,GAGAyrF,EAAAc,WAAAF,GACAZ,EAAAv4F,KAAAu2F,GAEAnkG,KAAAknG,gBACA/C,EAAA0C,EAAAp1F,EAAAE,EAAAw0F,EAAAr+F,EAAA4hB,KAcAw6E,EAAAh/F,UAAAgiG,gBAAA,SAAA/C,EAAA0C,EAAAp1F,EAAAE,EAAAiQ,EAAA9Z,EAAA4hB,GACA,GAAAs7E,GAAAhlG,KAAA2B,KAAA0D,WACA4/F,EAAAjlG,KAAA2B,KAAA2D,WACAuhG,GAAAA,GAAA1C,EAAA99F,IAAA,WAEA,IAAAq+F,GAAA9iF,EAAAulF,UACA7B,EAAAnB,EAAA99F,IAAA,SACA+gG,EAAAjD,EAAA99F,IAAA,iBACAmM,EAAAkX,GAAAA,EAAAva,kBAAA/I,OAWA,IAVAsjB,GAAAlX,EAAA6a,eAAA3D,EAAA8F,WAEA,kBAAAq3E,KAEAA,EAAAA,GAAAp1F,EAAAE,GAAA7J,EAAA8Z,EAAA8H,GAAAlX,GACA60F,UAAArC,EAAAC,GACAP,YAAAA,EAAA97E,WAIA3kB,EAAAiJ,QAAA25F,GACAp1F,EAAA0nF,EAAAz2C,aAAAmkD,EAAA,GAAA7B,GACArzF,EAAAwnF,EAAAz2C,aAAAmkD,EAAA,GAAA5B,OAEA,IAAAhhG,EAAA2sB,SAAAi2E,GAAA,CACAA,EAAA53F,MAAAy1F,EAAA,GACAmC,EAAA33F,OAAAw1F,EAAA,EACA,IAAA4C,GAAA5iG,EAAAi1F,cACAkN,GAAmC53F,MAAA+1F,EAAA91F,OAAA+1F,GAEnCxzF,GAAA61F,EAAA71F,EACAE,EAAA21F,EAAA31F,EACA2zF,EAAA,KAGA8B,EAAA,SAGA,IAAA,gBAAAP,IAAAn9E,EAAA,CACA,GAAAzc,GAAAw3F,EACAoC,EAAAr0F,EAAAkyF,EAEAjzF,GAAAxE,EAAA,GACA0E,EAAA1E,EAAA,OAEA,CACA,GAAAs6F,GAAAxC,EACAtzF,EAAAE,EAAAiQ,EAAA8H,GAAAs7E,EAAAC,EAAAK,EAAA,EAAA,GAAA8B,EAAA,EAAA,GAEA31F,GAAA81F,EAAA,GACA51F,EAAA41F,EAAA,GAMA,GAHAjC,IAAA7zF,GAAA4zF,EAAAC,GAAAZ,EAAA,GAAA,EAAA,UAAAY,EAAAZ,EAAA,GAAA,GACA0C,IAAAz1F,GAAA0zF,EAAA+B,GAAA1C,EAAA,GAAA,EAAA,WAAA0C,EAAA1C,EAAA,GAAA,GAEAP,EAAA99F,IAAA,WAAA,CACA,GAAAmhG,GAAAjC,EACA9zF,EAAAE,EAAAiQ,EAAA8H,GAAAs7E,EAAAC,EAEAxzF,GAAA+1F,EAAA,GACA71F,EAAA61F,EAAA,GAGA5lF,EAAAsmC,OAAAz2C,EAAAE,IAoEA9R,EAAAD,QAAAskG,GtIks8BM,SAAUrkG,EAAQD,EAASM,GuIp+8BjC,QAAAunG,GAAAn8E,GACA,GAAAo8E,GAAA,iCACAC,EAAA,QAAAr8E,EAAA,KAAAo8E,EAAA,QACAp8E,EAAA,KAAAo8E,CACA,OAAAzjG,GAAAuf,IAAAokF,EAAA,SAAAC,GACA,MAAAA,GAAA,cAAAF,IACSl+D,KAAA,KAQT,QAAAq+D,GAAAr5E,GACA,GAAA69C,MAEA9tC,EAAA/P,EAAApoB,IAAA,YACAioB,EAAAG,EAAApoB,IAAA;AAEAioB,GAAAg+C,EAAA9iE,KAAA,SAAA8kB,EAEA,IAAA+P,GAAA5P,EAAApoB,IAAA,OAWA,OAVAg4B,IAAAiuC,EAAA9iE,KAAA,QAAA60B,GAEAG,GACA8tC,EAAA9iE,KAAA,eAAA6J,KAAA4B,MAAA,EAAAupB,EAAA,GAAA,MAEA31B,GAAA,aAAA,SAAA,SAAAR,GACA,GAAAyZ,GAAA2M,EAAApoB,IAAAgC,EACAyZ,IAAAwqD,EAAA9iE,KAAA,QAAAnB,EAAA,IAAAyZ,KAGAwqD,EAAA7iC,KAAA,KAOA,QAAAs+D,GAAA5D,GAEA,GAAA73B,MAEA07B,EAAA7D,EAAA99F,IAAA,sBACAqY,EAAAylF,EAAA99F,IAAA,mBACAooB,EAAA01E,EAAAz1E,SAAA,aACArf,EAAA80F,EAAA99F,IAAA,UAoCA,OAjCA2hG,IACA17B,EAAA9iE,KAAAi+F,EAAAO,IAEAtpF,IACAk1C,EAAAa,gBACA6X,EAAA9iE,KAAA,oBAAAkV,IAIA4tD,EAAA9iE,KACA,qBAAAy+F,EAAAp1D,MAAAn0B,IAEA4tD,EAAA9iE,KAAA,8BAKAX,GAAA,QAAA,QAAA,UAAA,SAAAR,GACA,GAAA6/F,GAAA,UAAA7/F,EACA8/F,EAAA1V,EAAAyV,GACApmF,EAAAqiF,EAAA99F,IAAA8hG,EACA,OAAArmF,GACAwqD,EAAA9iE,KAAA0+F,EAAA,IAAApmF,GAAA,UAAAzZ,EAAA,GAAA,SAIAikE,EAAA9iE,KAAAs+F,EAAAr5E,IAGA,MAAApf,GACAi9D,EAAA9iE,KAAA,WAAA0pB,EAAA7jB,GAAAo6B,KAAA,OAAA,MAGA6iC,EAAA7iC,KAAA,KAA8B,IAQ9B,QAAA46D,GAAApc,EAAAnO,GACA,GAAApwD,GAAApL,SAAAC,cAAA,OACAsjB,EAAA7hC,KAAAiC,IAAA63E,EAAA10E,OAEApF,MAAA0pB,GAAAA,EAEA1pB,KAAA2wD,GAAAmpB,EAAAz0E,WAAA,EACArF,KAAA0xD,GAAAooB,EAAAx0E,YAAA,EAEA2iF,EAAA9nE,YAAAuJ,GAEA1pB,KAAAooG,WAAAngB,EAEAjoF,KAAAqoG,OAAA,EAKAroG,KAAAsoG,YAEA,IAAA37D,GAAA3sC,IACA0pB,GAAA6+E,aAAA,WAEA57D,EAAA67D,aACAnxB,aAAA1qC,EAAA27D,cACA37D,EAAA07D,OAAA,GAEA17D,EAAA87D,YAAA,GAEA/+E,EAAAg/E,YAAA,SAAA1hG,GAEA,GADAA,EAAAA,GAAAR,OAAAuB,OACA4kC,EAAA67D,WAAA,CAGA,GAAA/lE,GAAAZ,EAAAY,OACAy2C,GAAApD,eAAAmS,EAAAjhF,GAAA,GACAy7B,EAAAukC,SAAA,YAAAhgE,KAGA0iB,EAAAi/E,aAAA,WACAh8D,EAAA67D,YACA77D,EAAA07D,OACA17D,EAAAy5D,UAAAz5D,EAAAi8D,YAGAj8D,EAAA87D,YAAA,GA1JA,GAAAxkG,GAAA/D,EAAA,GACA+nG,EAAA/nG,EAAA,IACA0zD,EAAA1zD,EAAA,IACAg5E,EAAAh5E,EAAA,IACAi5F,EAAAj5F,EAAA,IACAuyF,EAAA0G,EAAA1G,YACAv/D,EAAAimE,EAAAjmE,kBACArqB,EAAA5E,EAAA4E,KAGA++F,GAAA,GAAA,WAAA,QAAA,OAEAiB,EAAA,oFAiJAxE,GAAAn/F,WAEAqrB,YAAA8zE,EAMAmE,YAAA,EAKA9mE,OAAA,WAGA,GAAAumD,GAAAjoF,KAAAooG,WACAz1B,EAAAsV,EAAA6gB,cACAxqF,SAAAs0D,YAAAC,iBAAAoV,GACAtU,EAAAsU,EAAAp9E,KACA,cAAA8oE,EAAA1oE,UAAA,aAAA0nE,EAAA1nE,WACA0oE,EAAA1oE,SAAA,aAOA2C,KAAA,SAAAu2F,GACA9sB,aAAAr3E,KAAAsoG,aACA,IAAA5+E,GAAA1pB,KAAA0pB,EAEAA,GAAA7e,MAAAyhE,QAAAu8B,EAAAd,EAAA5D,GAEA,SAAoBnkG,KAAA2wD,GAAA,UAAuB3wD,KAAA0xD,GAAA,OAC3CyyC,EAAA99F,IAAA,iBAAA,IAEAqjB,EAAA7e,MAAA8mE,QAAAjoD,EAAAxJ,UAAA,QAAA,OAEAlgB,KAAAqoG,OAAA,GAGApB,WAAA,SAAArlF,GACA5hB,KAAA0pB,GAAAxJ,UAAA0B,GAGAmnF,aAAA,SAAAC,GACAhpG,KAAAwoG,WAAAQ,GAGA7B,QAAA,WACA,GAAAz9E,GAAA1pB,KAAA0pB,EACA,QAAAA,EAAApH,YAAAoH,EAAA07E,eAGAl9C,OAAA,SAAAz2C,EAAAE,GAIA,GACAs8D,GADApsC,EAAA7hC,KAAAiC,GAEA4/B,IAAAA,EAAAuhC,UAAA6K,EAAApsC,EAAAuhC,QAAAE,qBACA7xD,GAAAw8D,EAAAC,YAAA,EACAv8D,GAAAs8D,EAAAE,WAAA,EAGA,IAAAtjE,GAAA7K,KAAA0pB,GAAA7e,KACAA,GAAA+H,KAAAnB,EAAA,KACA5G,EAAAiI,IAAAnB,EAAA,KAEA3R,KAAA2wD,GAAAl/C,EACAzR,KAAA0xD,GAAA//C,GAGAtG,KAAA,WACArL,KAAA0pB,GAAA7e,MAAA8mE,QAAA,OACA3xE,KAAAqoG,OAAA,GAGAjC,UAAA,SAAAj/D,IACAnnC,KAAAqoG,OAAAroG,KAAAyoG,YAAAzoG,KAAAwoG,aACArhE,GACAnnC,KAAA4oG,WAAAzhE,EAEAnnC,KAAAqoG,OAAA,EACAroG,KAAAsoG,aAAAl9F,WAAAnH,EAAAuD,KAAAxH,KAAAqL,KAAArL,MAAAmnC,IAGAnnC,KAAAqL,SAKAmgF,OAAA,WACA,MAAAxrF,MAAAqoG,QAIAxoG,EAAAD,QAAAykG,GvI8/8BM,SAAUxkG,EAAQD,EAASM,GwIzt9BjC,QAAA+oG,GAAApnE,EAAAi4C,GAaA,QAAAovB,GAAAj7D,EAAApwB,GACAgkB,EAAA96B,GAAAknC,EAAA,SAAAjnC,GACA,GAAAmiG,GAAAC,EAAAtvB,EAEAjxE,GAAAxC,EAAAw7B,GAAAwnE,QAAA,SAAAC,GACAA,GAAAzrF,EAAAyrF,EAAAtiG,EAAAmiG,EAAAvjG,kBAGA2jG,EAAAJ,EAAAK,SAAA1vB,KApBAzzE,EAAAw7B,GAAA4nE,cAIApjG,EAAAw7B,GAAA4nE,aAAA,EAGAP,EAAA,QAAAjlG,EAAA8qB,MAAA26E,EAAA,UACAR,EAAA,YAAAjlG,EAAA8qB,MAAA26E,EAAA,cAEAR,EAAA,YAAAS,IAeA,QAAAJ,GAAAC,EAAA1vB,GACA,GAGA8vB,GAHAC,EAAAL,EAAAM,QAAA3jG,OACA4jG,EAAAP,EAAAQ,QAAA7jG,MAGA0jG,GACAD,EAAAJ,EAAAM,QAAAD,EAAA,GAEAE,IACAH,EAAAJ,EAAAQ,QAAAD,EAAA,IAEAH,IACAA,EAAAhkG,eAAA,KACAk0E,EAAAl0E,eAAAgkG,IAIA,QAAAD,GAAAL,EAAAtiG,EAAApB,GACA0jG,EAAA7mE,QAAA,QAAA,KAAA78B,GAGA,QAAA8jG,GAAA/D,EAAA2D,EAAAtiG,EAAApB,GACA0jG,EAAA7mE,QAAAkjE,EAAA3+F,EAAApB,GASA,QAAAwjG,GAAAtvB,GACA,GAAA0vB,IACAM,WACAE,YAOApkG,EAAA,SAAAC,GACA,GAAAi/C,GAAA0kD,EAAA3jG,EAAAC,KACAg/C,GACAA,EAAAt7C,KAAA3D,IAGAA,EAAAD,eAAAA,EACAk0E,EAAAl0E,eAAAC,IAIA,QACAD,eAAAA,EACA4jG,SAAAA,GAnHA,GAAA51C,GAAA1zD,EAAA,IACA+D,EAAA/D,EAAA,GACAmG,EAAAnG,EAAA,IAAAqzF,aAEA1qF,EAAA5E,EAAA4E,KAEA28F,IAOAA,GAAAE,SAAA,SAAA1/F,EAAA8zE,EAAAr3C,GACA,IAAAmxB,EAAAxqD,KAAA,CAIA,GAAAy4B,GAAAi4C,EAAA10E,OACAiB,GAAAw7B,GAAAwnE,UAAAhjG,EAAAw7B,GAAAwnE,YAEAJ,EAAApnE,EAAAi4C,EAGA,IAAAwvB,GAAAjjG,EAAAw7B,GAAAwnE,QAAArjG,KAAAK,EAAAw7B,GAAAwnE,QAAArjG,MACAsjG,GAAA7mE,QAAAA,IAkGA+iE,EAAAU,WAAA,SAAAlgG,EAAA8zE,GACA,IAAAlmB,EAAAxqD,KAAA,CAGA,GAAAy4B,GAAAi4C,EAAA10E,QACAkkG,GAAAjjG,EAAAw7B,GAAAwnE,aAA2CrjG,EAC3CsjG,KACAjjG,EAAAw7B,GAAAwnE,QAAArjG,GAAA,QAIAnG,EAAAD,QAAA4lG,GxIqw9BM,SAAU3lG,EAAQD,EAASM,GyI349BjC,GAAA6C,GAAA7C,EAAA,GACAL,GAAAD,QAAAmD,EAAA+hB,QAEAhf,KAAA,UAEA2gF,eACAzpD,OAAA,EAEAjrB,EAAA,EAEAnE,MAAA,EAGAq8F,aAAA,EAKAxE,UAAA,YAEAyE,mBAAA,EAEAC,YAAA,SASAC,SAAA,EAKAC,UAAA,EAGAC,UAAA,IAGAtC,mBAAA,GAEAgB,WAAA,EAGAtqF,gBAAA,qBAGAi4E,YAAA,OAGA4T,aAAA,EAGA3T,YAAA,EAIAvnF,QAAA,EAGAm7F,aAAA,GAEAp8E,WACAE,MAAA,OACAkQ,SAAA,QzIu59BM,SAAU3+B,EAAQD,EAASM,G0I599BjCA,EAAA,IAEA,IAAAuqG,GAAAvqG,EAAA,IAEAsiE,EAAAioC,EAAAjoC,gBAEAK,EAAA3iE,EAAA,IAEAsiE,GAAA,MAAAK,I1Ik+9BM,SAAUhjE,EAAQD,EAASM,G2I1+9BjC,GAAA0zD,GAAA1zD,EAAA,IAEA0uD,EAAA1uD,EAAA,IAEAmtB,EAAAuhC,EAAAvhC,eAEAb,EAAAtsB,EAAA,IAEA6pB,EAAA7pB,EAAA,IAEAyE,EAAAzE,EAAA,IAEAu+C,EAAAv+C,EAAA,IAEA48B,EAAA58B,EAAA,IAEAg5B,EAAAh5B,EAAA,GAEA+yD,EAAA/yD,EAAA,IAEA8rB,EAAA9rB,EAAA,IAEAyrB,EAAAzrB,EAAA,GAEA+2B,EAAA/2B,EAAA,IAEA8pB,EAAA9pB,EAAA,IAEAwqG,EAAAxqG,EAAA,KAIAg3B,EAAAD,EAAAC,IACAjiB,EAAA5B,KAAA4B,MACA+B,EAAA3D,KAAA2D,KACA1D,EAAAD,KAAAC,IACAylB,EAAA1lB,KAAA0lB,IACAD,EAAAzlB,KAAAylB,IACAmtB,EAAA5yC,KAAA6Q,GAEA,KAAA0vC,EAAAa,gBAAA,CACA,GAAAk2C,GAAA,IACAC,EAAA,oCACA/yE,EAAA,MACAgzE,EAAAhzE,EAAA,EACAizE,EAAA,IACAC,EAAA,IAEAC,EAAA,SAAAthF,GACAA,EAAA7e,MAAAyhE,QAAA,uDACA5iD,EAAAuhF,UAAApzE,EAAA,IAAAA,EACAnO,EAAAwhF,YAAA,OAGAC,EAAA,SAAAplE,GACA,MAAA9c,QAAA8c,GAAApP,QAAA,KAAA,SAAyCA,QAAA,KAAA,WAGzCy0E,EAAA,SAAAx5F,EAAAg/B,EAAAnL,GACA,MAAA,QAAA7zB,EAAAg/B,EAAAnL,GAAAgE,KAAA,KAAA,KAGA4hE,EAAA,SAAAljG,EAAAoD,GACAA,GAAApD,GAAAoD,EAAAsD,aAAA1G,GACAA,EAAAgY,YAAA5U,IAIAkE,EAAA,SAAAtH,EAAAoD,GACAA,GAAApD,GAAAoD,EAAAsD,aAAA1G,GACAA,EAAAsa,YAAAlX,IAIA+/F,EAAA,SAAAtuE,EAAAjrB,EAAAqY,GAEA,OAAAiN,WAAA2F,IAAA,GAAA8tE,GAAAzzE,WAAAtlB,IAAA,GAAAg5F,EAAA3gF,GAGAs4B,EAAA,SAAAz8C,EAAA28C,GACA,MAAA,gBAAA38C,GACAA,EAAA48C,YAAA,MAAA,EACAxrB,WAAApxB,GAAA,IAAA28C,EAGAvrB,WAAApxB,GAGAA,GAOAslG,EAAA,SAAA7hF,EAAA4E,EAAAtP,GACA,GAAA4zB,GAAA7oB,EAAAkhB,MAAA3c,EACAtP,IAAAA,EAEAyG,MAAAzG,KACAA,EAAA,GAGA4zB,IACAlpB,EAAA4E,MAAA88E,EAAAx4D,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACAlpB,EAAA1K,QAAAA,EAAA4zB,EAAA,KAIA44D,EAAA,SAAAl9E,GACA,GAAAskB,GAAA7oB,EAAAkhB,MAAA3c,EACA,QAAA88E,EAAAx4D,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAAAA,EAAA,KAGA64D,EAAA,SAAA/hF,EAAA7e,EAAA6gG,GAEA,GAAA75F,GAAAhH,EAAAgH,IAEA,IAAA,MAAAA,EAEA,GAAAA,YAAAmY,GAAA,CACA,GAAA2hF,GACA72F,EAAA,EACAuL,GAAA,EAAA,GAEA+W,EAAA,EAEAw0E,EAAA,EACAp5F,EAAAk5F,EAAAv8F,kBACA01F,EAAAryF,EAAAvD,MACA61F,EAAAtyF,EAAAtD,MAEA,IAAA,WAAA2C,EAAA/L,KAAA,CACA6lG,EAAA,UACA,IAAAn8E,GAAAk8E,EAAAl8E,UACAuY,GAAAl2B,EAAAJ,EAAAozF,EAAAhzF,EAAAF,EAAAmzF,GACA98D,GAAAn2B,EAAA+D,GAAAivF,EAAAhzF,EAAAgE,GAAAivF,EAEAt1E,KACAnC,EAAA0a,EAAAA,EAAAvY,GACAnC,EAAA2a,EAAAA,EAAAxY,GAGA,IAAA6R,GAAA2G,EAAA,GAAAD,EAAA,GACAzG,EAAA0G,EAAA,GAAAD,EAAA,EACAjzB,GAAA,IAAAzB,KAAAqE,MAAA2pB,EAAAC,GAAAjuB,KAAA0B,GAEAD,EAAA,IACAA,GAAA,KAKAA,EAAA,OACAA,EAAA,OAES,CACT62F,EAAA,gBACA,IAAA5jE,IAAAl2B,EAAAJ,EAAAozF,EAAAhzF,EAAAF,EAAAmzF,GACAt1E,EAAAk8E,EAAAl8E,UACAvb,EAAAy3F,EAAAz3F,MACAhF,EAAA41F,EACA31F,EAAA41F,CACAzkF,KACA0nB,EAAA,GAAAv1B,EAAAf,GAAAxC,GAAA84B,EAAA,GAAAv1B,EAAAb,GAAAzC,GAEAsgB,GACAnC,EAAA0a,EAAAA,EAAAvY,GAGAvgB,GAAAgF,EAAA,GAAA4jB,EACA3oB,GAAA+E,EAAA,GAAA4jB,CACA,IAAAg0E,GAAA5lD,EAAAh3C,EAAAC,EACAkoB,GAAA,EAAAy0E,EACAD,EAAA,EAAA/5F,EAAAD,EAAAi6F,EAAAz0E,EAKA,GAAA00E,GAAAj6F,EAAAgoB,WAAAjR,OACAkjF,GAAAnhE,KAAA,SAAAohE,EAAAC,GACA,MAAAD,GAAA54F,OAAA64F,EAAA74F,QAOA,KAAA,GALAhN,GAAA2lG,EAAA3lG,OAEA8lG,KACAj5D,KAEA3lC,EAAA,EAAuBA,EAAAlH,EAAYkH,IAAA,CACnC,GAAAwY,GAAAimF,EAAAz+F,GACA6+F,EAAAV,EAAA3lF,EAAAyI,MACA0kB,GAAAxpC,KAAAqc,EAAA1S,OAAAy4F,EAAAx0E,EAAA,IAAA80E,EAAA,IAEA,IAAA7+F,GAAAA,IAAAlH,EAAA,GACA8lG,EAAAziG,KAAA0iG,GAIA,GAAA/lG,GAAA,EAAA,CACA,GAAAgmG,GAAAF,EAAA,GAAA,GACAG,EAAAH,EAAA,GAAA,GACAI,EAAAJ,EAAA,GAAA,GAAAphG,EAAAmU,QACAstF,EAAAL,EAAA,GAAA,GAAAphG,EAAAmU,OACA0K,GAAA5jB,KAAA6lG,EACAjiF,EAAAkX,OAAA,OACAlX,EAAArJ,MAAA,OACAqJ,EAAA5U,MAAAA,EACA4U,EAAA4E,MAAA69E,EACAziF,EAAA0iF,OAAAA,EACA1iF,EAAAspB,OAAAA,EAAAvJ,KAAA,KAGA/f,EAAA1K,QAAAstF,EAEA5iF,EAAA4iF,SAAAD,EAGA,WAAAV,IACAjiF,EAAA6iF,cAAAlsF,EAAAopB,KAAA,UAIA8hE,GAAA7hF,EAAA7X,EAAAhH,EAAAmU,UAKAwtF,EAAA,SAAA9iF,EAAA7e,GAUA,MAAAA,EAAAuU,WACAsK,EAAA+iF,UAAA5hG,EAAAuU,SAAAqqB,KAAA,MAGA,MAAA5+B,EAAAiH,QAAAjH,EAAAiH,iBAAAkY,IACAuhF,EAAA7hF,EAAA7e,EAAAiH,OAAAjH,EAAAmU,UAIA0tF,EAAA,SAAAC,EAAA7mG,EAAA+E,EAAA6gG,GACA,GAAAkB,GAAA,QAAA9mG,EACA4jB,EAAAijF,EAAAE,qBAAA/mG,GAAA,EAEA,OAAA+E,EAAA/E,IAAA,SAAA+E,EAAA/E,KAAA8mG,IAAAA,GAAA/hG,EAAAiL,YACA62F,EAAAC,EAAA,SAAA,WAAA,OAEA/hG,EAAA/E,YAAAkkB,IACAva,EAAAk9F,EAAAjjF,GAGAA,IACAA,EAAAghF,EAAAvtF,WAAArX,IAGA8mG,EAAAnB,EAAA/hF,EAAA7e,EAAA6gG,GAAAc,EAAA9iF,EAAA7e,GACAwgG,EAAAsB,EAAAjjF,KAEAijF,EAAAC,EAAA,SAAA,WAAA,QACAn9F,EAAAk9F,EAAAjjF,KAIA3G,aAEA+pF,EAAA,SAAA//E,EAAAvsB,GACA,GAMA2wD,GACA47C,EACAv3E,EACAnoB,EACAg+C,EACAC,EAXA7zB,EAAAP,EAAAO,EACAC,EAAAR,EAAAQ,EACAF,EAAAN,EAAAM,EACAI,EAAAV,EAAAU,EACAD,EAAAT,EAAAS,EACAR,KAOA3d,EAAAuT,EAAAvT,KACAwzF,EAAAjgF,EAAAqD,KAEA,KAAA/iB,EAAA,EAAeA,EAAA2/F,GAAgB,CAK/B,OAJAx3E,EAAAhc,EAAAnM,KACA0/F,EAAA,GACA57C,EAAA,EAEA37B,GACA,IAAAiC,GACAs1E,EAAA,MACA57C,EAAA,EACA9F,EAAA7xC,EAAAnM,KACAi+C,EAAA9xC,EAAAnM,KACA0V,EAAA,GAAA,GAAAsoC,EACAtoC,EAAA,GAAA,GAAAuoC,CACA,MAEA,KAAA9zB,GACAu1E,EAAA,MACA57C,EAAA,EACA9F,EAAA7xC,EAAAnM,KACAi+C,EAAA9xC,EAAAnM,KACA0V,EAAA,GAAA,GAAAsoC,EACAtoC,EAAA,GAAA,GAAAuoC,CACA,MAEA,KAAA3zB,GACA,IAAAD,GACAq1E,EAAA,MACA57C,EAAA,CACA,IAIAxH,GACAC,EALAl0C,EAAA8D,EAAAnM,KACAsI,EAAA6D,EAAAnM,KACAuI,EAAA4D,EAAAnM,KACAwI,EAAA2D,EAAAnM,IAIAmoB,KAAAmC,GAEAgyB,EAAA/zC,EACAg0C,EAAA/zC,EACAD,GAAAA,EAAA,EAAAF,GAAA,EACAG,GAAAA,EAAA,EAAAF,GAAA,EACAD,GAAA21C,EAAA,EAAA31C,GAAA,EACAC,GAAA21C,EAAA,EAAA31C,GAAA,IAEAg0C,EAAAnwC,EAAAnM,KACAu8C,EAAApwC,EAAAnM,MAGA0V,EAAA,GAAA,GAAArN,EACAqN,EAAA,GAAA,GAAApN,EACAoN,EAAA,GAAA,GAAAnN,EACAmN,EAAA,GAAA,GAAAlN,EACAkN,EAAA,GAAA,GAAA4mC,EACA5mC,EAAA,GAAA,GAAA6mC,EACAyB,EAAA1B,EACA2B,EAAA1B,CACA,MAEA,KAAAhyB,GACA,GAAAnmB,GAAA,EACAE,EAAA,EACAgyB,EAAA,EACAC,EAAA,EACA9uB,EAAA,CAEAtU,KAEAiR,EAAAjR,EAAA,GACAmR,EAAAnR,EAAA,GACAmjC,EAAA3sB,EAAAxW,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACAojC,EAAA5sB,EAAAxW,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACAsU,EAAAzB,KAAAqE,OAAAlX,EAAA,GAAAojC,EAAApjC,EAAA,GAAAmjC,GAGA,IAAAnyB,GAAAgI,EAAAnM,KACAqE,EAAA8H,EAAAnM,KACAgoB,EAAA7b,EAAAnM,KACAioB,EAAA9b,EAAAnM,KACA28C,EAAAxwC,EAAAnM,KAAAyH,EACAm1C,EAAAzwC,EAAAnM,KAAA28C,EAAAl1C,CAGAzH,IACA,IAAAmmD,GAAAh6C,EAAAnM,KACAg9C,EAAA74C,EAAAunB,EAAAixB,GAAA30B,EACAi1B,EAAA54C,EAAAonB,EAAAkxB,GAAA10B,EACA5f,EAAAlE,EAAAunB,EAAAkxB,GAAA50B,EACA1f,EAAAjE,EAAAonB,EAAAmxB,GAAA30B,EACAxvB,EAAA0tD,EAAA,OAAA,MAEAngD,MAAAC,IAAA+2C,EAAA30C,GAAA,OAEArC,KAAAC,IAAA22C,EAAAD,GAAA,IAGAwJ,IACAnJ,GAAA,IAAAxyB,GAIAxkB,KAAAC,IAAAg3C,EAAA54C,GAAA,KACA8hD,GAAAnJ,EAAA74C,IAAAgiD,GAAAnJ,EAAA74C,EACAmE,GAAA,IAAAkiB,EAEAliB,GAAA,IAAAkiB,EAEe27B,GAAAlJ,EAAA54C,IAAA8hD,GAAAlJ,EAAA54C,EACfgE,GAAA,IAAAmiB,EAEAniB,GAAA,IAAAmiB,GAKAV,EAAA3tB,KAAA1D,EAAAmP,IAAAzD,EAAA6jB,GAAAsO,EAAAlyB,GAAAomB,EAAAgzE,GAAAF,EAAA11F,IAAAvD,EAAA4jB,GAAAsO,EAAAjyB,GAAAkmB,EAAAgzE,GAAAF,EAAA11F,IAAAzD,EAAA6jB,GAAAsO,EAAAlyB,GAAAomB,EAAAgzE,GAAAF,EAAA11F,IAAAvD,EAAA4jB,GAAAsO,EAAAjyB,GAAAkmB,EAAAgzE,GAAAF,EAAA11F,GAAAo1C,EAAA1mB,EAAAlyB,GAAAomB,EAAAgzE,GAAAF,EAAA11F,GAAAq1C,EAAA1mB,EAAAjyB,GAAAkmB,EAAAgzE,GAAAF,EAAA11F,GAAAS,EAAAiuB,EAAAlyB,GAAAomB,EAAAgzE,GAAAF,EAAA11F,GAAAU,EAAAiuB,EAAAjyB,GAAAkmB,EAAAgzE,IACAx/C,EAAA31C,EACA41C,EAAA31C,CACA,MAEA,KAAAuhB,GAAAgb,EACA,GAAAnK,GAAAhlB,EAAA,GACAilB,EAAAjlB,EAAA,EAEAglB,GAAA,GAAAvuB,EAAAnM,KACA06B,EAAA,GAAAvuB,EAAAnM,KAEA26B,EAAA,GAAAD,EAAA,GAAAvuB,EAAAnM,KACA26B,EAAA,GAAAD,EAAA,GAAAvuB,EAAAnM,KAEA7M,IACA6sB,EAAA0a,EAAAA,EAAAvnC,GACA6sB,EAAA2a,EAAAA,EAAAxnC,IAGAunC,EAAA,GAAA9yB,EAAA8yB,EAAA,GAAAlQ,EAAAgzE,GACA7iE,EAAA,GAAA/yB,EAAA+yB,EAAA,GAAAnQ,EAAAgzE,GACA9iE,EAAA,GAAA9yB,EAAA8yB,EAAA,GAAAlQ,EAAAgzE,GACA7iE,EAAA,GAAA/yB,EAAA+yB,EAAA,GAAAnQ,EAAAgzE,GACA1zE,EAAA3tB,KACA,MAAAu+B,EAAA,GAAA4iE,EAAA5iE,EAAA,GACA,MAAAC,EAAA,GAAA2iE,EAAA5iE,EAAA,GACA,MAAAC,EAAA,GAAA2iE,EAAA3iE,EAAA,GACA,MAAAD,EAAA,GAAA4iE,EAAA3iE,EAAA,GACA,MAEA,KAAA9Q,GAAAW,EAEAV,EAAA3tB,KAAA,OAGA,GAAA2nD,EAAA,EAAA,CACAh6B,EAAA3tB,KAAAujG,EAEA,KAAA,GAAA3+D,GAAA,EAAuBA,EAAA+iB,EAAY/iB,IAAA,CACnC,GAAA1tC,GAAAqiB,EAAAqrB,EACA5tC,IAAA6sB,EAAA3sB,EAAAA,EAAAF,GAEA22B,EAAA3tB,KAAAyL,EAAAvU,EAAA,GAAAm3B,EAAAgzE,GAAAF,EAAA11F,EAAAvU,EAAA,GAAAm3B,EAAAgzE,GAAAz8D,EAAA+iB,EAAA,EAAAw5C,EAAA,MAKA,MAAAxzE,GAAAsS,KAAA,IAIA9d,GAAAzmB,UAAA+nG,SAAA,SAAAC,GACA,GAAAriG,GAAA7K,KAAA6K,MACA8hG,EAAA3sG,KAAAmtG,MAEAR,KACAA,EAAAjC,EAAAvtF,WAAA,SACA6tF,EAAA2B,GACA3sG,KAAAmtG,OAAAR,GAGAD,EAAAC,EAAA,OAAA9hG,EAAA7K,MACA0sG,EAAAC,EAAA,SAAA9hG,EAAA7K,KACA,IAAAQ,GAAAR,KAAAwvB,UACA49E,EAAA,MAAA5sG,EACA6sG,EAAAV,EAAAE,qBAAA,UAAA,EAEA,IAAAQ,EAAA,CACA,GAAAv3F,GAAAjL,EAAAiL,SAKA,IAAAs3F,IAAAviG,EAAA4wB,cAAA,CACA,GAAA8J,GAAA/kC,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,EACAsV,IAAAkB,EAAA1D,EAAAiyB,IAGA8nE,EAAAC,OAAAx3F,EAAA,KAGA,GAAAiX,GAAA/sB,KAAA+sB,OAAA/sB,KAAA+sB,KAAA,GAAAkK,GAEAj3B,MAAA24B,cACA5L,EAAA6N,YACA56B,KAAAi4B,UAAAlL,EAAA/sB,KAAAiH,OACA8lB,EAAA+K,WACA93B,KAAA24B,aAAA,GAGAg0E,EAAA5/E,KAAA+/E,EAAA//E,EAAA/sB,KAAAwvB,WACAm9E,EAAA9hG,MAAA0iG,OAAAjC,EAAAtrG,KAAAg9B,OAAAh9B,KAAA+R,EAAA/R,KAAAoqB,IAEAihF,EAAA6B,EAAAP,GAEA,MAAA9hG,EAAAE,KACA/K,KAAA+6B,aAAAmyE,EAAAltG,KAAAmP,mBAEAnP,KAAAwtG,eAAAN,IAIAvhF,EAAAzmB,UAAAuoG,SAAA,SAAAP,GACAz9F,EAAAy9F,EAAAltG,KAAAmtG,QACAntG,KAAAwtG,eAAAN,IAGAvhF,EAAAzmB,UAAAwoG,MAAA,SAAAR,GACA7B,EAAA6B,EAAAltG,KAAAmtG,QACAntG,KAAA2tG,eAAAT,GAOA,IAAA7U,GAAA,SAAAp+B,GAEA,MAAA,gBAAAA,IAAAA,EAAA2zC,SAAA,QAAA3zC,EAAA2zC,QAAAhhC,cAIA3Z,GAAA/tD,UAAA+nG,SAAA,SAAAC,GACA,GAGAW,GACAC,EAJAjjG,EAAA7K,KAAA6K,MACAC,EAAAD,EAAAC,KAKA,IAAAutF,EAAAvtF,GAAA,CACA,GAAA88C,GAAA98C,EAAA88C,GAEA,IAAAA,IAAA5nD,KAAA+tG,UACAF,EAAA7tG,KAAAguG,YACAF,EAAA9tG,KAAAiuG,iBACO,CACP,GAAAC,GAAApjG,EAAAqjG,aACAC,EAAAF,EAAAj/F,MACAo/F,EAAAH,EAAAh/F,MACAg/F,GAAAj/F,MAAA,OACAi/F,EAAAh/F,OAAA,OAEA2+F,EAAA/iG,EAAAmE,MACA6+F,EAAAhjG,EAAAoE,OAEAg/F,EAAAj/F,MAAAm/F,EACAF,EAAAh/F,OAAAm/F,EAEAruG,KAAA+tG,UAAAnmD,EACA5nD,KAAAguG,YAAAH,EACA7tG,KAAAiuG,aAAAH,EAGAhjG,EAAA88C,MAEA98C,KAAA9K,KAAA+tG,YACAF,EAAA7tG,KAAAguG,YACAF,EAAA9tG,KAAAiuG,aAIA,IAAAnjG,EAAA,CAIA,GAAA2G,GAAA5G,EAAA4G,GAAA,EACAE,EAAA9G,EAAA8G,GAAA,EACA28F,EAAAzjG,EAAAoE,MACAs/F,EAAA1jG,EAAAqE,OACAs/F,EAAA3jG,EAAAsoD,OACAs7C,EAAA5jG,EAAAuoD,QACAzvB,EAAA94B,EAAA84B,IAAA,EACAC,EAAA/4B,EAAA+4B,IAAA,EACA8qE,EAAAF,GAAAC,EACA9B,EAAA3sG,KAAAmtG,MAEAR,KAGAA,EAAAjC,EAAAiE,IAAApwF,cAAA,OACAysF,EAAA2B,GACA3sG,KAAAmtG,OAAAR,EAGA,IAEAnsG,GAFAouG,EAAAjC,EAAA9hG,MACAgkG,GAAA,EAEAhjD,EAAA,EACAC,EAAA,CASA,IAPA9rD,KAAAwvB,YACAhvB,EAAAR,KAAAwvB,UACAq8B,EAAA70C,EAAAxW,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACAsrD,EAAA90C,EAAAxW,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACAquG,EAAAruG,EAAA,IAAAA,EAAA,IAGAquG,EAAA,CAMA,GAAA9mE,IAAAt2B,EAAAE,GACAq2B,GAAAv2B,EAAA68F,EAAA38F,GACAo3B,GAAAt3B,EAAAE,EAAA48F,GACAvlE,GAAAv3B,EAAA68F,EAAA38F,EAAA48F,EACAlhF,GAAA0a,EAAAA,EAAAvnC,GACA6sB,EAAA2a,EAAAA,EAAAxnC,GACA6sB,EAAA0b,EAAAA,EAAAvoC,GACA6sB,EAAA2b,EAAAA,EAAAxoC,EACA,IAAAykB,GAAAghC,EAAAle,EAAA,GAAAC,EAAA,GAAAe,EAAA,GAAAC,EAAA,IACA9jB,EAAA+gC,EAAAle,EAAA,GAAAC,EAAA,GAAAe,EAAA,GAAAC,EAAA,IACA8lE,IACAA,GAAAtlG,KAAA,OAAAhJ,EAAA,GAAAqrD,EAAA8+C,EAAA,OAAAnqG,EAAA,GAAAsrD,EAAA6+C,EAAA,OAAAnqG,EAAA,GAAAqrD,EAAA8+C,EAAA,OAAAnqG,EAAA,GAAAsrD,EAAA6+C,EAAA,MAAA11F,EAAAxD,EAAAo6C,EAAArrD,EAAA,IAAAmqG,EAAA,MAAA11F,EAAAtD,EAAAm6C,EAAAtrD,EAAA,KACAouG,EAAAv/F,QAAA,KAAA4F,EAAAgQ,GAAA,MAAAhQ,EAAAiQ,GAAA,OAEA0pF,EAAAv2F,OAAAuyF,EAAA,WAAAkE,EAAArlE,KAAA,IAAA,2BAEAjpC,KACAiR,EAAAA,EAAAo6C,EAAArrD,EAAA,GACAmR,EAAAA,EAAAm6C,EAAAtrD,EAAA,IAGAouG,EAAAv2F,OAAA,GACAu2F,EAAAh8F,KAAAqC,EAAAxD,GAAA,KACAm9F,EAAA97F,IAAAmC,EAAAtD,GAAA,IAGA,IAAAo9F,GAAA/uG,KAAAgvG,SACAC,EAAAjvG,KAAAkvG,OAEAH,KACAA,EAAArE,EAAAiE,IAAApwF,cAAA,OACAve,KAAAgvG,SAAAD,EAGA,IAAAI,GAAAJ,EAAAlkG,KAEA,IAAA6jG,EAAA,CAEA,GAAAb,GAAAC,EAmBAqB,EAAAlgG,MAAAgG,EAAA42C,EAAAgiD,EAAAS,EAAAE,GAAA,KACAW,EAAAjgG,OAAA+F,EAAA62C,EAAAgiD,EAAAS,EAAAE,GAAA,SApBA,CACA,GAAAW,GAAA,GAAAxkG,OACA+hC,EAAA3sC,IAEAovG,GAAA3nD,OAAA,WACA2nD,EAAA3nD,OAAA,KACAomD,EAAAuB,EAAAngG,MACA6+F,EAAAsB,EAAAlgG,OAEAigG,EAAAlgG,MAAAgG,EAAA42C,EAAAgiD,EAAAS,EAAAE,GAAA,KACAW,EAAAjgG,OAAA+F,EAAA62C,EAAAgiD,EAAAS,EAAAE,GAAA,KAEA9hE,EAAAqhE,YAAAH,EACAlhE,EAAAshE,aAAAH,EACAnhE,EAAAohE,UAAAjjG,GAGAskG,EAAAxnD,IAAA98C,EAMAmkG,IACAA,EAAAvE,EAAAiE,IAAApwF,cAAA,OACA0wF,EAAApkG,MAAA4W,SAAA,SACAzhB,KAAAkvG,QAAAD,EAGA,IAAAI,GAAAJ,EAAApkG,KACAwkG,GAAApgG,MAAAgG,GAAAq5F,EAAA3qE,EAAA2qE,EAAAE,GAAA3iD,GACAwjD,EAAAngG,OAAA+F,GAAAs5F,EAAA3qE,EAAA2qE,EAAAE,GAAA3iD,GACAujD,EAAAh3F,OAAAuyF,EAAA,eAAAjnE,EAAA2qE,EAAAE,EAAA3iD,EAAA,QAAAjoB,EAAA2qE,EAAAE,EAAA3iD,EAAA,IAEAmjD,EAAApgG,YACA89F,EAAAxsF,YAAA8uF,GAGAF,EAAAlgG,YAAAogG,GACAA,EAAA9uF,YAAA4uF,OAGAI,GAAAlgG,MAAAgG,EAAA42C,EAAAyiD,GAAA,KACAa,EAAAjgG,OAAA+F,EAAA62C,EAAAyiD,GAAA,KACA5B,EAAAxsF,YAAA4uF,GAEAE,GAAAA,EAAApgG,aACA89F,EAAAlqF,YAAAwsF,GACAjvG,KAAAkvG,QAAA,KAIA,IAAAI,GAAA,GACA59D,EAAA7mC,EAAAmU,OAEA0yB,GAAA,IACA49D,GAAA,kBAAAr6F,EAAA,IAAAy8B,GAAA,MAGA49D,GAAA1E,EAAA,yBAAA9/F,EAAA,wBACAqkG,EAAA92F,OAAAi3F,EACA3C,EAAA9hG,MAAA0iG,OAAAjC,EAAAtrG,KAAAg9B,OAAAh9B,KAAA+R,EAAA/R,KAAAoqB,IAEAihF,EAAA6B,EAAAP,GAEA,MAAA9hG,EAAAE,MACA/K,KAAA+6B,aAAAmyE,EAAAltG,KAAAmP,qBAIA8jD,EAAA/tD,UAAAuoG,SAAA,SAAAP,GACAz9F,EAAAy9F,EAAAltG,KAAAmtG,QACAntG,KAAAmtG,OAAA,KACAntG,KAAAkvG,QAAA,KACAlvG,KAAAgvG,SAAA,KACAhvG,KAAAwtG,eAAAN,IAGAj6C,EAAA/tD,UAAAwoG,MAAA,SAAAR,GACA7B,EAAA6B,EAAAltG,KAAAmtG,QACAntG,KAAA2tG,eAAAT,GAOA,IAsCAqC,GAtCAC,EAAA,SACAC,KACAC,EAAA,EACAC,EAAA,IACAC,EAAAtxF,SAAAC,cAAA,OAEAsxF,EAAA,SAAAC,GACA,GAAAxxE,GAAAmxE,EAAAK,EAEA,KAAAxxE,EAAA,CAEAoxE,EAAAC,IACAD,EAAA,EACAD,KAGA,IACAhxE,GADA5zB,EAAA+kG,EAAA/kG,KAGA,KACAA,EAAAwzB,KAAAyxE,EACArxE,EAAA5zB,EAAA4zB,WAAArpB,MAAA,KAAA,GACO,MAAApO,IAEPs3B,GACAzzB,MAAAA,EAAAyzB,WAAAkxE,EACAO,QAAAllG,EAAAmlG,aAAAR,EACAlC,OAAAziG,EAAA0zB,YAAAixE,EACA3yB,KAAA,EAAAxlD,WAAAxsB,EAAA2zB,UAAA,IACAyxE,OAAAxxE,GAAA,mBAEAgxE,EAAAK,GAAAxxE,EACAoxE,IAGA,MAAApxE,GAKA35B,GAAAmrB,UAAA,cAAA,SAAA/kB,EAAAgV,GACA,GAAA4uF,GAAAjE,EAAAiE,GAEAY,KACAA,EAAAZ,EAAApwF,cAAA,OACAgxF,EAAA1kG,MAAAyhE,QAAA,wFACAo+B,EAAAiE,IAAAuB,KAAA/vF,YAAAovF,GAGA,KACAA,EAAA1kG,MAAAwzB,KAAAte,EACK,MAAAowF,IAML,MAHAZ,GAAArvF,UAAA,GAEAqvF,EAAApvF,YAAAwuF,EAAAyB,eAAArlG,KAEAkE,MAAAsgG,EAAApqF,cAmMA,KAAA,GAhMAu5B,GAAA,GAAAlyB,GAEAuO,GAAA,SAAAmyE,EAAA16F,EAAAsN,EAAAuwF,GACA,GAAAxlG,GAAA7K,KAAA6K,KAEA7K,MAAAk6B,SAAAukB,EAAAE,mBAAA9zC,GAAA,EACA,IAAAE,GAAAF,EAAAE,IAIA,IAFA,MAAAA,IAAAA,GAAA,IAEAA,EAAA,CAMA,GAAAF,EAAAq1B,KAAA,CACA,GAAAuf,GAAA96C,EAAAu8C,cAAAn2C,EAAAF,EACAE,KAEA,KAAA,GAAAsC,GAAA,EAAqBA,EAAAoyC,EAAAhkC,MAAAtV,OAA+BkH,IAAA,CAIpD,IAAA,GAHAo0C,GAAAhC,EAAAhkC,MAAApO,GAAAo0C,OACAwC,KAEAtmC,EAAA,EAAuBA,EAAA8jC,EAAAt7C,OAAmBwX,IAC1CsmC,EAAAz6C,KAAAi4C,EAAA9jC,GAAA5S,KAGAA,GAAAvB,KAAAy6C,EAAAxa,KAAA,KAGA1+B,EAAAA,EAAA0+B,KAAA,MAGA,GAAAh4B,GACAE,EACA2zF,EAAAz6F,EAAAsW,UACAmvF,EAAAzlG,EAAAo0B,kBACAX,EAAAuxE,EAAAhlG,EAAAwzB,MAEAA,EAAAC,EAAAzzB,MAAA,IAAAyzB,EAAAyxE,QAAA,IAAAzxE,EAAAgvE,OAAA,IAAAhvE,EAAAu+C,KAAA,OAAAv+C,EAAA2xE,OAAA,GACAnwF,GAAAA,GAAAnb,EAAAwK,gBAAApE,EAAAszB,EAAAinE,EAAAgL,EAEA,IAAA9vG,GAAAR,KAAAwvB,SAQA,IANAhvB,IAAA6vG,IACA3xD,EAAApjB,KAAA9oB,GACAksC,EAAArxB,eAAA7sB,GACAgS,EAAAksC,GAGA2xD,EAiBA5+F,EAAAe,EAAAf,EACAE,EAAAa,EAAAb,MAlBA,CACA,GAAA3G,GAAAH,EAAAG,aACA0Z,EAAA7Z,EAAA8jB,YAEA,IAAA3jB,YAAAoO,OACA3H,EAAAe,EAAAf,EAAAixC,EAAA13C,EAAA,GAAAwH,EAAAvD,OACA0C,EAAAa,EAAAb,EAAA+wC,EAAA13C,EAAA,GAAAwH,EAAAtD,QACAo2F,EAAAA,GAAA,WACO,CACP,GAAAnxF,GAAAxP,EAAAg+C,yBAAA33C,EAAAwH,EAAAkS,EACAjT,GAAA0C,EAAA1C,EACAE,EAAAwC,EAAAxC,EAEA2zF,EAAAA,GAAAnxF,EAAAgN,UACAmvF,EAAAA,GAAAn8F,EAAA8qB,mBAOAxtB,EAAA9M,EAAAg8C,YAAAlvC,EAAAqO,EAAA7Q,MAAAq2F,GACA3zF,EAAAhN,EAAAy7C,YAAAzuC,EAAAmO,EAAA5Q,OAAAohG,GAEA3+F,GAAAmO,EAAA5Q,OAAA,CAoCA,IAEAupB,GACA83E,EACAC,EAJArzF,EAAAutF,EAAAvtF,WACAszF,EAAAzwG,KAAA0wG,UAKAD,IAmBAD,EAAAC,EAAA5/B,WACAp4C,EAAA+3E,EAAAj+C,YACAg+C,EAAA93E,EAAA85B,cApBAk+C,EAAAtzF,EAAA,QACAsb,EAAAtb,EAAA,QACAozF,EAAApzF,EAAA,YACAqzF,EAAArzF,EAAA,QAGAozF,EAAA1lG,MAAA,gBAAA,OACAmgG,EAAAyF,GACAh4E,EAAAk4E,YAAA,EACAJ,EAAAxpG,IAAA,EACA0pG,EAAAjgF,KAAA,MACAigF,EAAA9Q,GAAA,YACA0L,EAAAoF,EAAAD,GACAnF,EAAAoF,EAAAh4E,GACA4yE,EAAAoF,EAAAF,GACAvwG,KAAA0wG,WAAAD,EAQA,IAAAG,IAAAn/F,EAAAE,GACAk/F,EAAAJ,EAAA5lG,KAEArK,IAAA6vG,GACAhjF,EAAAujF,EAAAA,EAAApwG,GACAgwG,EAAAzpG,IAAA,EACAypG,EAAA5kF,OAAAprB,EAAA,GAAA0lB,QAAA,GAAAykF,EAAAnqG,EAAA,GAAA0lB,QAAA,GAAAykF,EAAAnqG,EAAA,GAAA0lB,QAAA,GAAAykF,EAAAnqG,EAAA,GAAA0lB,QAAA,GAAA,OAEAsqF,EAAAr9F,QAAA8B,EAAA27F,EAAA,KAAA,GAAA,KAAA37F,EAAA27F,EAAA,KAAA,GAEAJ,EAAAt8F,OAAA,MACA28F,EAAAj+F,KAAA,MACAi+F,EAAA/9F,IAAA,QAEA09F,EAAAzpG,IAAA,EACA8pG,EAAAj+F,KAAAqC,EAAAxD,GAAA,KACAo/F,EAAA/9F,IAAAmC,EAAAtD,GAAA,MAGA4+F,EAAAO,OAAA3F,EAAApgG,EAEA,KACAwlG,EAAA1lG,MAAAwzB,KAAAA,EAEA,MAAAr3B,IAEA0lG,EAAA+D,EAAA,QACA5+F,KAAAhH,EAAAgY,SACA7D,QAAAnU,EAAAmU,SACKhf,MACL0sG,EAAA+D,EAAA,UACA3+F,OAAAjH,EAAA8zB,WACA3f,QAAAnU,EAAAmU,QACAI,SAAAvU,EAAAuU,UACKpf,MACLywG,EAAA5lG,MAAA0iG,OAAAjC,EAAAtrG,KAAAg9B,OAAAh9B,KAAA+R,EAAA/R,KAAAoqB,IAEAihF,EAAA6B,EAAAuD,KAGAjD,GAAA,SAAAN,GACAz9F,EAAAy9F,EAAAltG,KAAA0wG,YACA1wG,KAAA0wG,WAAA,MAGA/C,GAAA,SAAAT,GACA7B,EAAA6B,EAAAltG,KAAA0wG,aAGAvyD,IAAArhB,EAAA5D,EAAA+5B,EAAAtnC,EAAAK,GAEA3e,GAAA,EAAiBA,GAAA8wC,GAAAh4C,OAAiBkH,KAAA,CAClC,GAAAszD,IAAAxiB,GAAA9wC,IAAAnI,SACAy7D,IAAA5lC,aAAAA,GACA4lC,GAAA6sC,eAAAA,GACA7sC,GAAAgtC,eAAAA,GAGA3hF,EAAA9mB,UAAA+nG,SAAA,SAAAC,GACA,GAAAriG,GAAA7K,KAAA6K,KAEA,OAAAA,EAAAE,KACA/K,KAAA+6B,aAAAmyE,GACAz7F,EAAA5G,EAAA4G,GAAA,EACAE,EAAA9G,EAAA8G,GAAA,EACA1C,MAAA,EACAC,OAAA,GACOlP,KAAAmP,mBAAA,GAEPnP,KAAAwtG,eAAAN,IAIAlhF,EAAA9mB,UAAAuoG,SAAA,SAAAP,GACAltG,KAAAwtG,eAAAN,IAGAlhF,EAAA9mB,UAAAwoG,MAAA,SAAAR,GACAltG,KAAA2tG,eAAAT,M3Ik/9BM,SAAUrtG,EAAQD,EAASM,G4I79/BjC,QAAAid,GAAAywF,GACA,MAAAmD,GAAAnD,GAqBA,QAAAoD,KACA,IAAAC,GAAAtC,EAAA,CAIAsC,GAAA,CACA,IAAAC,GAAAvC,EAAAuC,WAEAA,GAAA/qG,OAAA,GACAwoG,EAAAwC,mBAAAC,QAAA,SAAA,8BAGAF,EAAA,GAAAE,QAAA,SAAA,+BAzCA,GAYAL,GAZAn9C,EAAA1zD,EAAA,IAEAmxG,EAAA,gCACAC,EAAA,mBAAA9qG,QAAA,KAAAA,OACAyqG,GAAA,EACAtC,EAAA2C,GAAAA,EAAAhzF,QASA,IAAAqwF,IAAA/6C,EAAAa,gBACA,KACAk6C,EAAA4C,WAAAC,OAAA7C,EAAA4C,WAAA5qG,IAAA,QAAA0qG,GAEAN,EAAA,SAAAnD,GACA,MAAAe,GAAApwF,cAAA,UAAAqvF,EAAA,oBAEG,MAAA5mG,GACH+pG,EAAA,SAAAnD,GACA,MAAAe,GAAApwF,cAAA,IAAAqvF,EAAA,WAAAyD,EAAA,qBAsBAzxG,EAAA+uG,IAAAA,EACA/uG,EAAAud,WAAAA,EACAvd,EAAAoxG,QAAAA,G5I0+/BM,SAAUnxG,EAAQD,EAASM,G6I5ggCjC,QAAAurE,GAAA3pD,GACA,MAAA3I,UAAA2I,EAAA,IAOA,QAAA2vF,GAAA/xG,EAAA8yD,GACAk4C,EAAAsG,UACAhxG,KAAAN,KAAAA,EACAM,KAAAwyD,QAAAA,CACA,IAAAk/C,GAAApzF,SAAAC,cAAA,OACA2uF,EAAA5uF,SAAAC,cAAA,MACAmzF,GAAA7mG,MAAAyhE,QAAA,mFACA4gC,EAAAriG,MAAAyhE,QAAA,kCACA5sE,EAAAygB,YAAAuxF,GACA1xG,KAAA2xG,SAAAzE,EACAltG,KAAA4xG,aAAAF,EACA1xG,KAAA2F,QAEA,IAAA+9D,GAAAlR,EAAAG,eACAgR,EAAAnR,EAAAC,YAEAD,GAAAG,eAAA,SAAAjpC,GACAg6C,EAAAnjE,KAAAiyD,EAAA9oC,GAEAA,GACAA,EAAA+jF,UAAA/jF,EAAA+jF,SAAAP,IAIA16C,EAAAC,aAAA,SAAA/oC,GAEAA,EAAAgkF,OAAAhkF,EAAAgkF,MAAAR,GACAvpC,EAAApjE,KAAAiyD,EAAA9oC,IAGA1pB,KAAA6xG,aAAA,EAgHA,QAAAC,GAAAlxE,GACA,MAAA,YACAmxE,EAAA,iDAAAnxE,EAAA,MArKA,GAAAmxE,GAAA7xG,EAAA,IAEAwqG,EAAAxqG,EAAA,KAEAymC,EAAAzmC,EAAA,GAEA2I,EAAA89B,EAAA99B,IAgDA4oG,GAAAvsG,WACAqrB,YAAAkhF,EACA3jC,QAAA,WACA,MAAA,OAMAxK,gBAAA,WACA,MAAAtjE,MAAA4xG,cAEA5jC,sBAAA,WACA,GAAAC,GAAAjuE,KAAAsjE,iBAEA,IAAA2K,EACA,OACAC,WAAAD,EAAAC,YAAA,EACAC,UAAAF,EAAAE,WAAA,IAQAlyC,QAAA,WACA,GAAAkiB,GAAAn+C,KAAAwyD,QAAA6U,gBAAA,GAAA,EAEArnE,MAAAquE,WAAAlwB,IAEAkwB,WAAA,SAAAlwB,GAGA,IAAA,GAFA+uD,GAAAltG,KAAA2xG,SAEAtkG,EAAA,EAAmBA,EAAA8wC,EAAAh4C,OAAiBkH,IAAA,CACpC,GAAAqc,GAAAy0B,EAAA9wC,EAEAqc,GAAAqT,WAAArT,EAAAwX,QACAxX,EAAAsoF,qBACAtoF,EAAA+jF,SAAAP,GAIAxjF,EAAAsoF,qBAAA,IAEAtoF,EAAAsoF,qBACAtoF,EAAAgkF,MAAAR,GAGAxjF,EAAAsoF,qBAAA,EAEAtoF,EAAAwQ,UACAxQ,EAAA4T,aAAA5T,EAAA4T,eACA5T,EAAAujF,UAAAvjF,EAAA8P,OAAAj5B,KAAAmpB,EAAAwjF,GACAxjF,EAAA6T,YAAA7T,EAAA6T,eAIA7T,EAAAwQ,SAAA,EAGAl6B,KAAA6xG,cAIA7xG,KAAA4xG,aAAAzxF,YAAA+sF,GAEAltG,KAAA6xG,aAAA,IAGAlsG,OAAA,SAAAsJ,EAAAC,GACA,GAAAD,GAAA,MAAAA,EAAAjP,KAAAiyG,YAAAhjG,EACAC,EAAA,MAAAA,EAAAlP,KAAAkyG,aAAAhjG,CAEA,IAAAlP,KAAAqtE,QAAAp+D,GAAAjP,KAAAstE,SAAAp+D,EAAA,CACAlP,KAAAqtE,OAAAp+D,EACAjP,KAAAstE,QAAAp+D,CACA,IAAAijG,GAAAnyG,KAAA4xG,aAAA/mG,KACAsnG,GAAAljG,MAAAA,EAAA,KACAkjG,EAAAjjG,OAAAA,EAAA,OAGAzJ,QAAA,WACAzF,KAAAN,KAAAwgB,UAAA,GACAlgB,KAAA2xG,SAAA3xG,KAAA4xG,aAAA5xG,KAAAwyD,QAAA,MAEAntD,SAAA,WACA,MAAArF,MAAAqtE,QAEA/nE,UAAA,WACA,MAAAtF,MAAAstE,SAEAzjE,MAAA,WACA7J,KAAA4xG,cACA5xG,KAAAN,KAAA+iB,YAAAziB,KAAA4xG,eAGAK,UAAA,WACA,GAAAvyG,GAAAM,KAAAN,KACAizE,EAAAjzE,EAAAopG,YACA,QAAAppG,EAAA4iB,aAAAmpD,EAAAkH,EAAA1jE,QAAAw8D,EAAAkH,EAAAy/B,aAAA3mC,EAAAkH,EAAA0/B,cAAA,GAEAH,WAAA,WACA,GAAAxyG,GAAAM,KAAAN,KACAizE,EAAAjzE,EAAAopG,YACA,QAAAppG,EAAA0lG,cAAA35B,EAAAkH,EAAAzjE,SAAAu8D,EAAAkH,EAAA2/B,YAAA7mC,EAAAkH,EAAA4/B,eAAA,IAWA1pG,GAAA,WAAA,cAAA,YAAA,mBAAA,iBAAA,YAAA,WAAA,WAAA,aAAA,YAAA,eAAA,SAAAR,GACAopG,EAAAvsG,UAAAmD,GAAAypG,EAAAzpG,IAEA,IAAAs0B,GAAA80E,CACA5xG,GAAAD,QAAA+8B","file":"fish-topo-flow.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fishTopoFlow\"] = factory();\n\telse\n\t\troot[\"fishTopoFlow\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fishTopoFlow\"] = factory();\n\telse\n\t\troot[\"fishTopoFlow\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Export fishTopo as CommonJS module\r\n\t */\r\n\tmodule.exports = __webpack_require__(2);\r\n\t//兼容IE8 引入VML 如果不需要兼容IE8请删除\r\n\t__webpack_require__(137);\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * fishtopo流程实例\r\n\t * @class fish.topo.FishTopoFlow\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *      var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event click\r\n\t * 节点或者线段的click事件\r\n\t * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *          this.fishTopo.on(\"click\", function(event) {\r\n\t *              console.log(\"点击的是：\" + event.target.model.get('elementType'));\r\n\t *          });\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event dblclick\r\n\t * 节点或者线段的双击事件\r\n\t * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *          this.fishTopo.on(\"dblclick\", function(event) {\r\n\t *              console.log(\"双击的是：\" + event.target.model.get('elementType'));\r\n\t *          });\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event create\r\n\t * 节点与线段创建完毕的事件\r\n\t * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *          this.fishTopo.on(\"create\", function(e) {\r\n\t *               if (me.fishTopo.Flow.isLink(e.target.model)) {\r\n\t *                  console.log(\"线段创建完毕：\" + e.target.model);\r\n\t *               }\r\n\t *          });\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event delete\r\n\t * 节点与线段创建完毕的事件\r\n\t * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *          //节点删除完毕事件\r\n\t *          this.fishTopo.on(\"delete\", function(event) {\r\n\t *              console.log(\"删除的是：\" + event.target.model.get('elementType'));\r\n\t *          });\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event dropDrag\r\n\t * 节点移动完成的事件\r\n\t * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *          //节点移动结束事件\r\n\t            this.fishTopo.on(\"dropDrag\", function(event) {\r\n\t                console.log(\"移动的节点是：\"+event.target.model.get('elementType'));\r\n\t            });\r\n\t */\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t    __webpack_require__(3);\r\n\t    var graphic = __webpack_require__(4);\r\n\t    var Minimap = __webpack_require__(64);\r\n\t    var util = __webpack_require__(65);\r\n\t    var Point = __webpack_require__(66);\r\n\t    var ExtensionAPI = __webpack_require__(68);\r\n\t    var Eventful = __webpack_require__(12);\r\n\t    var zrender = __webpack_require__(69);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var OperationNode = __webpack_require__(80);\r\n\t    var FlowConnectionManager = __webpack_require__(90);\r\n\t    var FlowUtil = __webpack_require__(94);\r\n\t    var Constants = __webpack_require__(93);\r\n\t    var Model = __webpack_require__(87);\r\n\t    var eventTool = __webpack_require__(77);\r\n\t    var Connector = __webpack_require__(82);\r\n\t    var LineOperationManager = __webpack_require__(123);\r\n\t    var Flow = __webpack_require__(119);\r\n\t    var flowNode = __webpack_require__(96);\r\n\t    var GroupNode = __webpack_require__(95);\r\n\t    var flowLink = __webpack_require__(117);\r\n\t    var layout = __webpack_require__(124);\r\n\t    var textContain = __webpack_require__(26);\r\n\t    var ImagePool = __webpack_require__(132);\r\n\t    var ToolTipView = __webpack_require__(133);\r\n\t    var TooltipModel = __webpack_require__(136);\r\n\t    var actions = {};\r\n\t    var keyCode = {ENTER:13, ESCAPE:27}\r\n\t    function FishTopoFlow(dom, opts) {\r\n\t        this.id;\r\n\t        this.group = null;\r\n\t        this._dom = dom;\r\n\t        this.nowZoom = 1;\r\n\t        this.canScale = true;\r\n\t        this.eagleEye = false;\r\n\t        this.eagleEyeNode = null;\r\n\t        this.initScaleRatio = 1;\r\n\t        this.operationNode = null;\r\n\t        this.step = 0;//前进后退计步数\r\n\t        this.stepJson = [];//存放每步的json\r\n\t        this.selectedNode = null;\r\n\t        this.allNodes = [];\r\n\t        this.minimap = null;\r\n\t        this._api = new ExtensionAPI(this);\r\n\t        this.connectionManager = new FlowConnectionManager(this._api);\r\n\t        this.lineOperationManager = new LineOperationManager(this.connectionManager,this._api);\r\n\t        this._zr = zrender.init(dom, {\r\n\t            renderer: opts.renderer || 'canvas',\r\n\t            devicePixelRatio: opts.devicePixelRatio\r\n\t        });\r\n\t        this._tooltipView = new ToolTipView(new TooltipModel(opts.tooltip),this._api);\r\n\t        this.Shape = graphic;\r\n\t        this.lineOpt = {};  //初始的线段配置信息\r\n\t        this.selectedNodes = [];\r\n\t        this.model = new Model({});\r\n\t        this.model.set(Constants.ELEMENT_TYPE, \"scene\");\r\n\t        this.model.set(Constants.MODE, \"normal\");\r\n\t        this.options = opts;\r\n\t        this.cursorMap = {\r\n\t            tl: 'nw-resize',\r\n\t            tr: 'ne-resize',\r\n\t            bl: 'sw-resize',\r\n\t            br: 'se-resize',\r\n\t            mtr:'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAAYFBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD6T+iNAAAAH3RSTlMA7sUMoYXnEkYYzaaTjQiAQCweBcG7fvnULh2ZdjMy6Fzd7wAAALJJREFUGNN1kFkOwzAIBQHvW/Y6Sbfc/5Y1ltqoljIf2BohBA8qU096xeV5L/+uFH4SpsGAGSKmThCyMz64Ud38Te0meIpHcTP1ndTKvqzSUuQILFMQJAUwIngBLCd0UrJhSRGqzHHU3FcHBVMokqxS38YNGQLQbhmgZZ23sVEXnXVmS467Fq0892SSLaW5SHrN9rz9bXv9EHIB+E9pdMG7Ys48Z2cjxo7FL3k8kPIE13wAmEUIO2ML9YMAAAAASUVORK5CYII=) 10 10, auto'\r\n\t        }; // 节点控制点鼠标信息(上左，上右，下左，下右，旋转)\r\n\t        this.cursorMaps = [\r\n\t            'n-resize',\r\n\t            'ne-resize',\r\n\t            'e-resize',\r\n\t            'se-resize',\r\n\t            's-resize',\r\n\t            'sw-resize',\r\n\t            'w-resize',\r\n\t            'nw-resize'\r\n\t        ]\r\n\t        this.cursorOffset = {\r\n\t            tr: 1,\r\n\t            br: 3,\r\n\t            bl: 5,\r\n\t            tl: 7\r\n\t        }\r\n\t        Eventful.call(this);\r\n\t    }\r\n\t\r\n\t    var fishTopoProto = FishTopoFlow.prototype;\r\n\t\r\n\t    /**\r\n\t     * 获取 fishTopo 实例容器的 dom 节点\r\n\t     * @return {HTMLElement}\r\n\t     */\r\n\t    fishTopoProto.getDom = function () {\r\n\t        return this._dom;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto.getZr = function () {\r\n\t        return this._zr;\r\n\t    };\r\n\t    /**\r\n\t     * 获取 fishTopo 实例容器的宽度。\r\n\t     * @return {number}\r\n\t     */\r\n\t    fishTopoProto.getWidth = function () {\r\n\t        return this._zr.getWidth();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 获取 fishTopo 实例容器的高度。\r\n\t     * @return {number}\r\n\t     */\r\n\t    fishTopoProto.getHeight = function () {\r\n\t        return this._zr.getHeight();\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 当前实例是否已经被释放。\r\n\t     * @return {boolean}\r\n\t     */\r\n\t    fishTopoProto.isDisposed = function () {\r\n\t        return this._disposed;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 释放 当前实例\r\n\t     */\r\n\t    fishTopoProto.dispose = function () {\r\n\t        this._disposed = true;\r\n\t\r\n\t        this._zr.dispose();\r\n\t\r\n\t        instances[this.id] = null;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 调整尺寸  在窗口大小发生改变时需要手工调用\r\n\t     * @param {number} width 宽度\r\n\t     * @param {number} height 高度\r\n\t     */\r\n\t    fishTopoProto.resize = function () {\r\n\t        this._zr.resize();\r\n\t\r\n\t    };\r\n\t\r\n\t    fishTopoProto.dispatchAction = function (payload) {\r\n\t        if(!actions[payload.type]) {\r\n\t            return;\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @method option\r\n\t     * 修改画布的选项\r\n\t     * @param {String} key 键  如：roam linkModify  textEditable等\r\n\t     * @param {Boolean|String|Function} value 选项值\r\n\t     */\r\n\t    fishTopoProto.option = function(key,value) {\r\n\t        var model = new Model(this.options);\r\n\t        if (arguments.length === 0) {\r\n\t            return zrUtil.clone(this.options);\r\n\t        } else if (arguments.length === 1) {\r\n\t            return model.get(key);\r\n\t        } else if (arguments.length === 2) {\r\n\t            if (key === \"roam\") {\r\n\t                this.setRoam(value);\r\n\t            }\r\n\t            return model.set(key,value);\r\n\t        }\r\n\t    }\r\n\t\r\n\t\r\n\t    fishTopoProto.init = function () {\r\n\t        var MOUSE_EVENT_NAMES = 'ontouchstart' in window ? ['touchstart', 'touchmove', 'touchend'] : ['mousedown', 'mousemove', 'mouseup'];\r\n\t        this.group = new graphic.Group();\r\n\t        this.group.model = this.model;\r\n\t        this.group.isBg = true;\r\n\t        this._zr.add(this.group);\r\n\t\r\n\t        //是否允许鼠标滚轮放大缩小\r\n\t        if (this.options.roam === true) {\r\n\t            this.zrScale();\r\n\t        }\r\n\t\r\n\t        this.connectionManager.connectors = [];\r\n\t        //mouseup 会在各个node或线的click事件之点执行  在选中节点或线前 先清空选中效果\r\n\t        this._zr.on(\"mouseup\", function (e) { // clearSelect\r\n\t            // 1. 清空节点的选中效果\r\n\t            // this._removeOperationNode();\r\n\t            // 2. 点击的线 ，则直接返回\r\n\t            var shape = e.target;\r\n\t            if (shape && shape.model && Flow.isLink(shape.model)) {\r\n\t                return;\r\n\t            }\r\n\t            if (shape && shape.connector instanceof Connector) {\r\n\t                return;\r\n\t            }\r\n\t            // 3. 清空连接线\r\n\t            this.connectionManager.clearSelectCon();\r\n\t            // 4. 点击的是线上操作按钮，则直接返回\r\n\t            if (shape && shape._isLineOperationIcon && shape._isLineOperationIcon == true) {\r\n\t                return;\r\n\t            }\r\n\t            // 5.隐藏线上操作图标\r\n\t            this.lineOperationManager.hideAllLineOperation();\r\n\t        }.bind(this));\r\n\t\r\n\t        this._zr.on(\"click\", function (e) {\r\n\t            // 如果点击了控制点，则不会取消选中状态(控制点不在节点范围内)\r\n\t            var target = e.target || {};\r\n\t            var type = target.type;\r\n\t            if (type !== 'ConnectControlLine' && type !== 'ConnectControl') {\r\n\t                this.hideConnectorPoint();\r\n\t                this.hideConnectorControl();\r\n\t                this._removeOperationNode();\r\n\t                var nodeTarget = e.target;\r\n\t                var shape;\r\n\t                if (nodeTarget) {\r\n\t                    shape = nodeTarget.model;\r\n\t                }\r\n\t                if ((nodeTarget && shape && Flow.isLink(shape)) || (nodeTarget && shape && Flow.isNode(\r\n\t                        shape))) {\r\n\t                    return;\r\n\t                }\r\n\t            }\r\n\t            var params = {};\r\n\t            params.event = e;\r\n\t            params.type = \"click\";\r\n\t            params.target = this;\r\n\t            this._api.trigger(params.type, params);\r\n\t        }.bind(this));\r\n\t\r\n\t        // mouseMode统一在mousedown事件里判断\r\n\t        this._zr.on(\"mousedown\", function (e) {\r\n\t            if (this.options.mouseMode === 'drag-select') {\r\n\t                if ((e.target && e.target.model) ||\r\n\t                    (e.target && e.target.lineType && e.target.parent) ||\r\n\t                    (e.target && e.target.connector instanceof Connector) ||\r\n\t                    (e.target && e.target instanceof graphic.Circle) ||\r\n\t                    (e.target && e.target.name === \"GROUP_RECT_NAME\")) {\r\n\t                    return;\r\n\t                } else {\r\n\t                    this.hideConnectorPoint();\r\n\t                    this.hideConnectorControl();\r\n\t                    this._removeOperationNode();\r\n\t                    this._dragSelect(e.target, e.offsetX, e.offsetY);\r\n\t                }\r\n\t            }\r\n\t\r\n\t            if (this.options.mouseMode === 'drag-move') {\r\n\t                if ((e.target && e.target.model) || (e.target && e.target.lineType && e.target.parent) ||\r\n\t                    (e.target && e.target.connector instanceof Connector) || (e.target && e.target instanceof graphic\r\n\t                        .Circle)) {\r\n\t                    return;\r\n\t                } else {\r\n\t                    this._groupDragHandler(e.offsetX, e.offsetY);\r\n\t                }\r\n\t            }\r\n\t        }.bind(this));\r\n\t\r\n\t        this.on('conPointsGroup:click', function (argument) {\r\n\t            this.lineOperationManager.bindOperation(argument.lineNode);\r\n\t        }.bind(this));\r\n\t\r\n\t        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n\t            this._zr.on(eveName, function (e) {\r\n\t                var params = {};\r\n\t                params.event = e;\r\n\t                params.type = eveName;\r\n\t                params.target = this;\r\n\t                this._api.trigger(params.type, params);\r\n\t            }, this);\r\n\t        }, this);\r\n\t    };\r\n\t\r\n\t    fishTopoProto.setRoam = function (value) {\r\n\t        this._zr.off(\"mousewheel\");//禁止用户缩放画布\r\n\t        if (value === true) {\r\n\t            this.zrScale();\r\n\t        }\r\n\t    }\r\n\t\r\n\t    fishTopoProto.addGroupModel = function (groupNode) {\r\n\t        var that = this;\r\n\t        groupNode.eachChild(function (node) {\r\n\t            if (node.model) { \r\n\t                if (node instanceof GroupNode) {\r\n\t                    if (node.model && !node.model.option.childs && node.children().length > 0) {\r\n\t                        var childs = [];\r\n\t                        node.eachChild(function (childNode) {\r\n\t                            if (childNode.model) {\r\n\t                                if (childNode instanceof GroupNode) {\r\n\t                                    if (!childNode.model.option.childs && childNode.children().length > 0) {\r\n\t                                        that.addGroupModel(node);\r\n\t                                    }\r\n\t                                }\r\n\t                                childs.push(childNode.model.option);\r\n\t                                node.model.option.childs = childs;\r\n\t                            }\r\n\t                        })\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        });\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @method toJson\r\n\t     * 导出json\r\n\t     * @return {Object} json对象\r\n\t     */\r\n\t    fishTopoProto.toJson = function () {\r\n\t        this.addGroupModel(this.group);\r\n\t        return FlowUtil.toJson(this.model, this.group);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @method fromJson\r\n\t     * 导入json\r\n\t     * @param  {Object} json对象\r\n\t     * @param {Boolean} isNoCount 是否需要step计数，默认是需要计数\r\n\t     */\r\n\t    fishTopoProto.fromJson = function (json, isNoCount) {\r\n\t        this.clear(true);\r\n\t        var model = new Model(json);\r\n\t        this.setBackground(model.get(Constants.BACKGROUND));\r\n\t        var layoutRootNode = [];\r\n\t        FlowUtil.fromJson(this, this.group, model.get(Constants.CHILDS), false, layoutRootNode, isNoCount);\r\n\t        // for (var i = 0; i < layoutRootNode.length; i++) {\r\n\t        //     this.layoutNode(\"tree\", {\r\n\t        //         \"node\": layoutRootNode[i],\r\n\t        //         \"type\": layoutRootNode[i].treeType\r\n\t        //     });\r\n\t        // }\r\n\t    };\r\n\t    /**\r\n\t     * 添加节点或线段到画布 同add方法\r\n\t     * @method addNode\r\n\t     * @param {Object} node createNode或createLink返回的对象\r\n\t     * @param {Object} [option] 参数对象\r\n\t     * @param {Boolean} [option.trigger] 是否触发 beforeCreate事件\r\n\t     * @returns {Object} 返回添加成功的节点 ，如被用户取消之类则 返回null\r\n\t     */\r\n\t    /**\r\n\t     * 添加节点或线段到画布 同addNode方法\r\n\t     * @method add\r\n\t     * @param {Object} node createNode或createLink返回的对象\r\n\t     * @param {Object} [option] 参数对象\r\n\t     * @param {Boolean} isNoCount 是否需要step计数，默认是需要计数\r\n\t     * @param {Boolean} [option.trigger] 是否触发 beforeCreate事件\r\n\t     * @returns {Object} 返回添加成功的节点 ，如被用户取消之类则 返回null\r\n\t     */\r\n\t    fishTopoProto.add = fishTopoProto.addNode = function (node, options, isNoCount) {\r\n\t        if (!node) return null;\r\n\t\r\n\t        var opt = options || {};\r\n\t        if(opt.trigger !==false && (!this._trigger('beforeCreate', {target:node}))) {\r\n\t            return null;\r\n\t        }\r\n\t        if (node instanceof Connector) {\r\n\t            this.addConnectorAttrEvent(node);\r\n\t        } else {\r\n\t            if (Flow.isGroupNode(node)) {\r\n\t                node.willRender(this._api);\r\n\t                var groupOptions = node.model.get(Constants.OPTIONS);\r\n\t                if (groupOptions.mergedImage) {\r\n\t                    var groupReplaceImage = new flowNode.Image({\r\n\t                        style: {\r\n\t                            image: groupOptions.mergedImage,\r\n\t                            text: groupOptions.style.text,\r\n\t                            textPosition: 'bottom'\r\n\t                        },\r\n\t                        position: [-5000, -5000]\r\n\t                    });\r\n\t                    this.drag(groupReplaceImage);\r\n\t                    node._relationImage = groupReplaceImage;\r\n\t                    this.group.add(groupReplaceImage);\r\n\t                    setTimeout(function () {\r\n\t                        groupReplaceImage.hide();\r\n\t                    }, 300);\r\n\t                    node.on('dblclick', function () {\r\n\t                        node.merged();\r\n\t                    })\r\n\t                }\r\n\t                //遍历组中所有节点\r\n\t                node.each(function (child) {\r\n\t                    this._addGroupNode(node,child);\r\n\t                }, this);\r\n\t            }\r\n\t            this.addNodeAttrEvent(node, true);\r\n\t        }\r\n\t        this._trigger(\"create\", {target:node});\r\n\t\r\n\t        if (node.hoverStyle) {\r\n\t            graphic.setHoverStyle(node);\r\n\t        }\r\n\t\r\n\t        this.group.add(node);\r\n\t        if (node.relative) {  //必须在加入画布后执行\r\n\t            this._handleRelativePostion(node)\r\n\t        }\r\n\t        if (node.hoverAnimation && this.options.isAnimationEnabled) {\r\n\t            flowNode.addHoverAnimation(node);\r\n\t        }\r\n\t        if (isNoCount != true) {\r\n\t            this.stepCounter();\r\n\t        }\r\n\t        return node;\r\n\t    };\r\n\t\r\n\t\r\n\t    fishTopoProto._addGroupNode = function(groupNode, child){\r\n\t        if (child instanceof Connector) {\r\n\t            this.addConnectorAttrEvent(child);\r\n\t        } else {\r\n\t            this.addNodeAttrEvent(child, groupNode.options.childDraggable);\r\n\t            if (util.isUndefined(child.selectable)) {\r\n\t                child.selectable = false;  //组内默认不可选中\r\n\t            }\r\n\t            if (child.relative) {\r\n\t                this._handleRelativePostion(child)\r\n\t            }\r\n\t            if (child.hoverStyle) {\r\n\t                graphic.setHoverStyle(child);\r\n\t            }\r\n\t        }\r\n\t        this._trigger(\"create\", {target:child});\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 在链路连线上添加文本\r\n\t     * @method addTextOnChain\r\n\t     * @param {Object} line 链路连线对象\r\n\t     * @param {Object} [text] 数组类型，表示多个文本的数据。数组元素可以为字符串，表示每个文本的名字；也可以是个对象，对象中必须指定text属性，其值为文本的名字\r\n\t     * @returns {Object} 返回 链路连线对象\r\n\t     */\r\n\t    fishTopoProto.addTextOnChain = function (line, text) {\r\n\t        if (line.options.style.lineType === Connector.TYPE_CHAIN) {\r\n\t            this.connectionManager.removeLine(line, this._getParentZr(line));\r\n\t            line.options.text.text.push(text);\r\n\t            line.options.textContextMenu = line.opt.textContextMenu;   //不然左键菜单没有了！！！\r\n\t            var slink = new flowLink.Chain(line.startNode, line.endNode, line.options);\r\n\t            this.add(slink);\r\n\t            return slink;\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 在链路连线上删除指定文本\r\n\t     * @method delTextOnChain\r\n\t     * @param {Object} txtObj 文本对象\r\n\t     * @returns {Object} 返回 链路连线对象\r\n\t     */\r\n\t    fishTopoProto.delTextOnChain = function (txtObj) {\r\n\t        var id = txtObj.id, line = txtObj.parent, pos;\r\n\t        if (line.options.style.lineType === Connector.TYPE_CHAIN && zrUtil.isArray(line.options.text.text)) {\r\n\t            line.options.text.text.forEach(function (v, i) {\r\n\t                if (v.textId === id) {\r\n\t                    pos = i;\r\n\t                }\r\n\t            });\r\n\t            line.options.text.text.splice(pos, 1);\r\n\t\r\n\t            this.connectionManager.removeLine(line, this._getParentZr(line));\r\n\t            line.options.textContextMenu = line.opt.textContextMenu;   //不然左键菜单没有了！！！\r\n\t            var slink = new flowLink.Chain(line.startNode, line.endNode, line.options);\r\n\t            this.add(slink);\r\n\t            return slink;\r\n\t        }\r\n\t    }\r\n\t    /**\r\n\t     * 在链路连线上修改指定文本\r\n\t     * @method delTextOnChain\r\n\t     * @param {Object} txtObj 文本对象\r\n\t     * @param {String} name 修改的文本\r\n\t     * @returns {Object} 返回 链路连线对象\r\n\t     */\r\n\t    fishTopoProto.modifyTextOnChain = function (txtObj, name) {\r\n\t        var id = txtObj.id, line = txtObj.parent;\r\n\t        if (line.options.style.lineType === Connector.TYPE_CHAIN && zrUtil.isArray(line.options.text.text)) {\r\n\t            line.options.text.text.forEach(function (v, i) {\r\n\t                if (v.textId === id) {\r\n\t                    v.text = name;\r\n\t                }\r\n\t            });\r\n\t            txtObj.setStyle(\"text\", name);\r\n\t        }\r\n\t    }\r\n\t    /**\r\n\t     * 显示隐藏指定节点的连线\r\n\t     * @method toggleAllConNodeLine\r\n\t     * @param {Object} node 节点对象\r\n\t     * @param {String} type 显示还是隐藏 [hide|show]\r\n\t     */\r\n\t    fishTopoProto.toggleAllConNodeLine = function (node, type) {\r\n\t        var allLine = this.connectionManager.connectors;\r\n\t        if (zrUtil.isArray(allLine)) {\r\n\t            allLine.forEach(function (line) {\r\n\t                if (line.startNode.id === node.id) {\r\n\t                    type === 'hide' ? line.hide() : line.show();\r\n\t                }\r\n\t            })\r\n\t        }\r\n\t    };\r\n\t\r\n\t    fishTopoProto.addConnectorAttrEvent = function (connector) {\r\n\t        var that = this;\r\n\t        var chainLine = null;\r\n\t        if (connector.options.style.lineType === Connector.TYPE_CHAIN) {\r\n\t            var key = this.connectionManager.getTwoNodeId(connector.startNode, connector.endNode, connector.options.position);\r\n\t            var cons = this.connectionManager.connectorMap.get(key);\r\n\t            var orignText = [].concat(connector.options.text.text);\r\n\t            if (cons.length > 0) {\r\n\t                cons.forEach(function (v) {\r\n\t                    if (v.options.style.lineType === Connector.TYPE_CHAIN) {\r\n\t                        orignText = orignText.concat(v.options.text.text);\r\n\t                        chainLine = v;\r\n\t                    }\r\n\t                });\r\n\t            }\r\n\t        }\r\n\t        //如果已存在链路\r\n\t        if (chainLine) {\r\n\t            connector.options.text.text = orignText;\r\n\t            this.connectionManager.removeLine(chainLine, this._getParentZr(chainLine));\r\n\t        }\r\n\t        connector.options.isEdit = !!this.options.linkModify;\r\n\t        connector.on(\"mousedown\", function () {\r\n\t            this.connectionManager.connectorForbidEdit(!this.options.linkModify);\r\n\t            this.isNode = false;\r\n\t        }.bind(this));\r\n\t        this.connectionManager.add(connector);\r\n\t        //支持双击编辑\r\n\t        connector.on(\"dblclick\", function () {\r\n\t            if (typeof this.options.text.textEditable == \"undefined\") {\r\n\t                if (that.options.textEditable) {\r\n\t                    that.connectorEdit(this);\r\n\t                }\r\n\t            } else {\r\n\t                if (this.options.text.textEditable) {\r\n\t                    that.connectorEdit(this);\r\n\t                }\r\n\t            }\r\n\t        });\r\n\t    }\r\n\t\r\n\t    fishTopoProto.addNodeAttrEvent = function (node, childDraggable) {\r\n\t        var that = this;\r\n\t        if (childDraggable) {\r\n\t            this.drag(node);\r\n\t        }\r\n\t\r\n\t        node.attr(\"operationIcons\", node.model.get('options.operationIcons'));\r\n\t\r\n\t        //侦听节点的click dblclick事件，选中，并派发出去\r\n\t        node.on('click', function (event) {\r\n\t            var targeNode = this;\r\n\t            that.nodeClickHandler(targeNode);\r\n\t\r\n\t            var params = {};\r\n\t            params.event = event;\r\n\t            params.type = 'click';\r\n\t            params.target = targeNode;\r\n\t            that._api.trigger(params.type, params);\r\n\t            event.cancelBubble = true;\r\n\t\r\n\t            // 判断一下是否是组内成组的点击事件，如果是的话，那组也也派发一下\r\n\t            if (Flow.isInGroup(targeNode)) {\r\n\t                var parentNode = targeNode.parent;\r\n\t                if (!parentNode.childDraggable) {\r\n\t                    parentNode.trigger('click', {event:event, type:'click',target:parentNode});\r\n\t                }\r\n\t            }\r\n\t        });\r\n\t        node.on('dblclick', function (e) {\r\n\t            var targeNode = this;\r\n\t            if (!targeNode.style || (typeof targeNode.style.textEditable == \"undefined\")) {\r\n\t                if (that.options.textEditable) {\r\n\t                    that.nodeEdit(targeNode);\r\n\t                }\r\n\t            } else {\r\n\t                if (targeNode.style.textEditable) {\r\n\t                    that.nodeEdit(targeNode);\r\n\t                }\r\n\t            }\r\n\t            var params = {};\r\n\t            params.event = e;\r\n\t            params.type = 'dblclick';\r\n\t            params.target = targeNode;\r\n\t            that._api.trigger(params.type, params);\r\n\t\r\n\t            e.cancelBubble = true;\r\n\t        });\r\n\t\r\n\t        this.allNodes.push(node);\r\n\t    }\r\n\t\r\n\t    fishTopoProto._handleRelativePostion = function(node) {\r\n\t        var parentEl = node.parent;\r\n\t        var containerInfo = parentEl === this.group\r\n\t            ? {\r\n\t                width:this._api.getWidth(),\r\n\t                height:this._api.getHeight()\r\n\t            }\r\n\t            : {\r\n\t                width:parentEl.getBoundingRect().width,\r\n\t                height:parentEl.getBoundingRect().height\r\n\t            }\r\n\t        layout.positionElement(node, node.relative, containerInfo, node.relative.padding, {boundingMode:node.relative.bounding||'all'});\r\n\t    }\r\n\t\r\n\t    fishTopoProto._getParentZr = function(node) {\r\n\t        var parentZr = null;\r\n\t        if (node && node.parent) {\r\n\t            parentZr = node.parent;\r\n\t        } else {\r\n\t            parentZr = this.group;\r\n\t        }\r\n\t        return parentZr;\r\n\t    }\r\n\t\r\n\t    fishTopoProto._removeOperationNode = function() {\r\n\t        if (this.operationNode) {\r\n\t            this.group.remove(this.operationNode);\r\n\t            this.operationNode.cleanup();\r\n\t            this.operationNode = null;\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 清空当前实例，会移除实例中所有的节点与线\r\n\t     * @method clear\r\n\t     */\r\n\t    fishTopoProto.clear = function (isNoCount) {\r\n\t        for (var i = 0; i < this.allNodes.length; i++) {\r\n\t            var parentZr = this._getParentZr(this.allNodes[i]);\r\n\t            this.connectionManager.deleteSelectCon(this.allNodes[i], parentZr)\r\n\t        }\r\n\t        this.connectionManager.connectorMap.clear();\r\n\t        this.allNodes = [];\r\n\t        this.operationNode = null;\r\n\t        this.selectedNode = null;\r\n\t        this.dragSelectRect = null;\r\n\t        this.selectedNodes = [];\r\n\t        this.hideConnectorPoint();\r\n\t        this.hideConnectorControl();\r\n\t        this.connectionManager.connectors = [];\r\n\t        this._zr.clear();\r\n\t        this.group = new graphic.Group();\r\n\t        this.group.isBg = true;\r\n\t        this._zr.add(this.group);\r\n\t        if (isNoCount != true) {\r\n\t            this.stepCounter();\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建连线的小图标操作\r\n\t     * @param {string} key 小图标的名称\r\n\t     * @param {Object} options 小图标的相关参数\r\n\t     * @param {String} [options.icon] 小图标路径\r\n\t     * @param {Object} [options.lineNode] 线段实例\r\n\t     * @param {Function} [options.callback] 点击后的回调\r\n\t     *\r\n\t     * **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *                  this.fishTopo.addIcon(\"icon1\", {\r\n\t     *                      icon: \"https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo_top_ca79a146.png\",\r\n\t     *                      lineNode: lineNode,\r\n\t     *                      callback: function(event) {\r\n\t     *                          alert(JSON.stringify(event.data))\r\n\t     *                      },\r\n\t     *                  });\r\n\t     */\r\n\t    fishTopoProto.addLineIcon = fishTopoProto.addIcon = function (key, options) {\r\n\t        this.lineOperationManager.addIcon(key, options);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建连线的默认删除操作\r\n\t     * @param  {Object} lineNode 线\r\n\t     *\r\n\t     *  **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *      fishTopo.lineDefaultIcon(lineNode);\r\n\t     */\r\n\t    fishTopoProto.lineDefaultIcon = function (lineNode) {\r\n\t        this.addLineDeleteIcon(lineNode);\r\n\t        this.addLineChangeIcon(lineNode);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建连线的默认删除操作\r\n\t     * @param  {Object} lineNode 线\r\n\t     * @param {Object} [options] 连线操作的选项\r\n\t     *\r\n\t     *  **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *      fishTopo.addLineChangeIcon(lineNode);\r\n\t     */\r\n\t    fishTopoProto.addLineDeleteIcon = function (lineNode,options) {\r\n\t        //创建删除\r\n\t        this.lineOperationManager.addDeleteIcon(lineNode,options);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建连线的默认切换类型操作\r\n\t     * @param  {Object} lineNode 线\r\n\t     * @param {Object} [options] 连线操作的选项\r\n\t     *\r\n\t     *  **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *      fishTopo.addLineChangeIcon(lineNode);\r\n\t     */\r\n\t    fishTopoProto.addLineChangeIcon = function (lineNode,options) {\r\n\t        this.lineOperationManager.addChangeLineTypeIcon(lineNode,options);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 变更当前线的类型，如果不传则按顺序取下一个类型。先删除原来的线段 再增加一种类型的线段\r\n\t     * @param {String} lineType 欲变更线的类型\r\n\t     */\r\n\t    fishTopoProto.changeSelectConnectorType = function(lineType) {\r\n\t        var nextLineType = lineType;\r\n\t        var line = this.connectionManager.selConnector;\r\n\t        var originLineType = line.options.style.lineType;\r\n\t        if (nextLineType) {\r\n\t            if (nextLineType == originLineType) {\r\n\t                return;\r\n\t            }\r\n\t        } else {\r\n\t            var arrLineType = [Connector.TYPE_STRAIGHT, Connector.TYPE_JAGGED, Connector.TYPE_CURVE];\r\n\t            var index = zrUtil.indexOf(arrLineType, originLineType);\r\n\t            nextLineType = arrLineType[(index + 1) % arrLineType.length];\r\n\t        }\r\n\t\r\n\t        //this.remove(line, {trigger:false}); 这样会删除icons\r\n\t        this.connectionManager.deleteLine(this._getParentZr(line));\r\n\t        this.lineOperationManager.hideAllLineOperation();\r\n\t\r\n\t        zrUtil.merge(line.options, { dockers: [] }, true);\r\n\t        zrUtil.merge(line.options.style, { lineType: nextLineType }, true);\r\n\t        var nextLine = this.createConnectorByNodes(line.startNode, line.endNode, line.options, false);\r\n\t        if (nextLine) {\r\n\t            nextLine.icons = line.icons;\r\n\t            nextLine.on('Connector:click', function () {\r\n\t                this.lineOperationManager.bindOperation(nextLine);\r\n\t            }.bind(this));\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 根据point创建节点上的连接点\r\n\t     * @param {Object} point x，y坐标  {x:x, y:y}\r\n\t     * @param {String} pos x，y坐标 [right|left|top|bottom]\r\n\t     * @param {String} lineType x，y坐标 [straight|jagged|curve]\r\n\t     */\r\n\t    fishTopoProto.createConnectorPoint = function(point, pos, lineType) {\r\n\t        var me = this;\r\n\t        var pointInstance = new graphic.Circle({\r\n\t            shape: {\r\n\t                cx: point.x,\r\n\t                cy: point.y,\r\n\t                r: 4\r\n\t            },\r\n\t            style: {\r\n\t                fill: '#FFFF33',\r\n\t                stroke:'#000000'\r\n\t            },\r\n\t                        z : 4,\r\n\t            draggable: true,\r\n\t            lineType: lineType\r\n\t        });\r\n\t        pointInstance.type = 'ConnectPoint';\r\n\t        pointInstance.pos = pos;                //记录是节点上哪个位置的连接点\r\n\t        var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];\r\n\t        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n\t            pointInstance.on(eveName, function(e) {\r\n\t                var params = {};\r\n\t                params.event = e;\r\n\t                params.type = \"ConnectPoint:\" + eveName;\r\n\t                me.group.trigger(params.type, params);\r\n\t            });\r\n\t        });\r\n\t        this.group.add(pointInstance);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 隐藏节点上的连接点\r\n\t     */\r\n\t    fishTopoProto.hideConnectorPoint = function() {\r\n\t        var that = this;\r\n\t        this.group.children().forEach(function (v) {\r\n\t            if (v.type === 'ConnectPoint') {\r\n\t                that.group.remove(v);\r\n\t            }\r\n\t        })\r\n\t        this.group.off(\"ConnectPoint:dragstart\");\r\n\t        this.group.off(\"ConnectPoint:drag\");\r\n\t        this.group.off(\"ConnectPoint:dragend\");\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 根据节点数组动态创建连接点\r\n\t     * @param  {Array} lineType 需要展示连接点的节点数组\r\n\t     * @param  {String} lineType 连线的线段类型 [straight|jagged|curve]\r\n\t     */\r\n\t    fishTopoProto.filterConnectPoint = function(targetNodes, lineType) {\r\n\t        var that = this;\r\n\t        var groupNodes = []; // 记录组内节点\r\n\t        var outsideNodes = []; // 记录组外节点\r\n\t        var nodes = [];\r\n\t        if (targetNodes.length > 1) {\r\n\t            targetNodes.forEach(function(item) {\r\n\t                if (Flow.isGroupNode(item)) {\r\n\t                    nodes.push(item);\r\n\t                    groupNodes = groupNodes.concat(item.children());\r\n\t                } else {\r\n\t                    outsideNodes.push(item);\r\n\t                }\r\n\t            });\r\n\t            // 比较组内外节点，过滤组内节点\r\n\t            outsideNodes.forEach(function(item) {\r\n\t                if (!groupNodes.includes(item)) {\r\n\t                    nodes.push(item);\r\n\t                }\r\n\t            });\r\n\t        } else {\r\n\t            nodes = targetNodes;\r\n\t        }\r\n\t        nodes.forEach(function(item) {\r\n\t            var rect = util.getRect(item);\r\n\t            var connectorPoint = util.getConnectorPoints(rect, item);\r\n\t            that.createConnectorPoint(connectorPoint.left, \"left\", lineType);\r\n\t            that.createConnectorPoint(connectorPoint.right, \"right\", lineType);\r\n\t            that.createConnectorPoint(connectorPoint.top, \"top\", lineType);\r\n\t            that.createConnectorPoint(connectorPoint.bottom, \"bottom\", lineType);\r\n\t        });\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 在节点上显示连接点\r\n\t     * @param  {String} lineType 连线的线段类型 [straight|jagged|curve]\r\n\t     * @param {Object} [options] 连线的线段属性\r\n\t     *\r\n\t     *  **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *       $('.btn-connect-jagged').click(function(e) {\r\n\t     *           fishTopo.showConnectorPoint(\"jagged\", {\r\n\t     *               symbol: {\r\n\t     *                   // 箭头颜色\r\n\t     *                   color: \"#BBBBBB\"\r\n\t     *               },\r\n\t     *               style: {\r\n\t     *                   // 线条颜色\r\n\t     *                   stroke: \"#BBBBBB\",\r\n\t     *               }\r\n\t     *           });\r\n\t     *       });\r\n\t     */\r\n\t    fishTopoProto.showConnectorPoint = function(lineType, lineOpt, ifCurrentNode) {\r\n\t        var that = this;\r\n\t        this.hideConnectorPoint();\r\n\t        if (lineOpt) {\r\n\t            this.lineOpt = lineOpt;  //缓存线段的配置信息\r\n\t        }\r\n\t        if (!ifCurrentNode) {\r\n\t            ifCurrentNode = false;\r\n\t        }\r\n\t        var targetNodes = ifCurrentNode ? [that.selectedNode] : that.allNodes;\r\n\t\r\n\t        if (!ifCurrentNode) {\r\n\t            // 所有节点连接点展示前，首先清除画布上的框选dragSelect\r\n\t            that._removeOperationNode();\r\n\t            that._releaseSelectNode();\r\n\t        }\r\n\t\r\n\t        // 让所有画布中的节点/当前节点显示连接点\r\n\t        this.filterConnectPoint(targetNodes, lineType);\r\n\t\r\n\t        // 根据连线点查找节点(考虑优化 创建连接点的时候 就把连接点与node进行绑定，就不用这个复杂的计算了)\r\n\t        function findConnectorNode(x, y, offset, pos) {\r\n\t            var node, endPos = null;\r\n\t            that.allNodes.forEach(function(item) {\r\n\t                var rect = util.getRect(item);\r\n\t                var connectorPoint = util.getConnectorPoints(rect, item);\r\n\t                if (pos) {\r\n\t                    if (Math.abs(connectorPoint[pos].x - x) <= offset && Math.abs(connectorPoint[pos].y - y) <= offset) {\r\n\t                        node = item;\r\n\t                    }\r\n\t                } else {\r\n\t                    if (Math.abs(connectorPoint[\"left\"].x - x) <= offset && Math.abs(connectorPoint[\"left\"].y - y) <= offset) {\r\n\t                        endPos = \"left\";\r\n\t                        node = item;\r\n\t                    } else if (Math.abs(connectorPoint[\"top\"].x - x) <= offset && Math.abs(connectorPoint[\"top\"].y - y) <= offset) {\r\n\t                        endPos = \"top\";\r\n\t                        node = item;\r\n\t                    } else if (Math.abs(connectorPoint[\"right\"].x - x) <= offset && Math.abs(connectorPoint[\"right\"].y - y) <= offset) {\r\n\t                        endPos = \"right\";\r\n\t                        node = item;\r\n\t                    } else if (Math.abs(connectorPoint[\"bottom\"].x - x) <= offset && Math.abs(connectorPoint[\"bottom\"].y - y) <= offset) {\r\n\t                        endPos = \"bottom\";\r\n\t                        node = item;\r\n\t                    }\r\n\t                }\r\n\t            });\r\n\t            return {\r\n\t                node: node,\r\n\t                endPos: endPos\r\n\t            };\r\n\t        }\r\n\t        this.group.on(\"ConnectPoint:dragstart\", function(e) {\r\n\t            // 如果是当前节点显示连接点，需要在拖动剪头时让画布中的其他节点显示连接点\r\n\t            if (ifCurrentNode) {\r\n\t                that.filterConnectPoint(that.allNodes, lineType);\r\n\t            }\r\n\t            var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;\r\n\t            var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;\r\n\t            var arrow = e.event.target;\r\n\t            that.startPos = arrow.pos;\r\n\t            that.selectConnNode = findConnectorNode(arrow.shape.cx, arrow.shape.cy, 0, that.startPos).node;\r\n\t            arrow.hide();\r\n\t            that.lineOperationManager.hideAllLineOperation();\r\n\t            that.reverseConnect = false;   //是否反向连线的标识\r\n\t            that.originNode = null;\r\n\t            var point = new Point(x, y);\r\n\t            that.connectionManager.connectors.forEach(function (v) {\r\n\t                if (v.endNode.id === that.selectConnNode.id && that.startPos === v.options.position.endPos) {\r\n\t                    that.connectionManager.deleteByLine(v, that.group);\r\n\t                    that.selectConnNode = v.startNode;\r\n\t                    that.startPos = v.options.position.startPos;\r\n\t                    that.originNode = v.endNode;\r\n\t                    that.originPos = v.options.position.endPos;\r\n\t                } else if (v.startNode.id === that.selectConnNode.id && that.startPos === v.options.position.startPos) {\r\n\t                    that.connectionManager.deleteByLine(v, that.group);\r\n\t                    that.reverseConnect = true;\r\n\t                    that.selectConnNode = v.endNode;\r\n\t                    that.endPos = v.options.position.endPos;\r\n\t                    that.originNode = v.startNode;\r\n\t                    that.originPos = v.options.position.startPos;\r\n\t                }\r\n\t            })\r\n\t            var connector;\r\n\t            if (that.reverseConnect) {\r\n\t                connector = that.connectionManager.manageReverseTempConnector(point, that.selectConnNode, arrow.lineType, that.endPos);\r\n\t            } else {\r\n\t                connector = that.connectionManager.manageTempConnector(that.selectConnNode, point, arrow.lineType, that.startPos);\r\n\t            }\r\n\t            that.group.add(connector);\r\n\t        });\r\n\t        this.group.on(\"ConnectPoint:drag\", function(e) {\r\n\t            var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;\r\n\t            var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;\r\n\t            var point = new Point(x, y);\r\n\t            var arrow = e.event.target;\r\n\t            if (that.reverseConnect) {\r\n\t                that.connectionManager.manageReverseTempConnector(point, that.selectConnNode, arrow.lineType, that.endPos);\r\n\t            } else {\r\n\t                that.connectionManager.manageTempConnector(that.selectConnNode, point, arrow.lineType, that.startPos);\r\n\t            }\r\n\t            that.group.children().forEach(function (v) {\r\n\t                if (v.type === 'ConnectPoint') {\r\n\t                    v.attr({style:{fill: \"#FFFF33\"},scale:[1,1],origin:[v.shape.cx,v.shape.cy]});\r\n\t                    if (Math.abs(v.shape.cx - x) <= 10 && Math.abs(v.shape.cy - y) <= 10) {\r\n\t                        var res = findConnectorNode(x, y, 10);\r\n\t                        if (that.reverseConnect) {\r\n\t                            that.connectionManager.manageReverseTempConnector(point, that.selectConnNode, arrow.lineType, that.endPos, res.endPos, res.node);\r\n\t                        } else {\r\n\t                            that.connectionManager.manageTempConnector(that.selectConnNode, point, arrow.lineType, that.startPos, res.endPos, res.node);\r\n\t                        }\r\n\t                        v.attr({style:{fill: \"#ff0000\"},scale:[1.5,1.5],origin:[v.shape.cx,v.shape.cy]});\r\n\t                    }\r\n\t                }\r\n\t            })\r\n\t        });\r\n\t        this.group.on(\"ConnectPoint:dragend\", function(e) {\r\n\t            var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;\r\n\t            var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;\r\n\t            var res = findConnectorNode(x, y, 10);\r\n\t            var targetNode = res.node;\r\n\t            var endPos = res.endPos || 'left';\r\n\t            var arrow = e.event.target;\r\n\t            //删除临时线\r\n\t            that.connectionManager.removeTempConnector(that.group);\r\n\t\r\n\t            //2.如果找到目标结点 则画线\r\n\t            if (targetNode && (that.selectConnNode.id !== targetNode.id)) {\r\n\t                var origin = {};\r\n\t                var connectOptions = {\r\n\t                    style: {\r\n\t                        lineType: arrow.lineType\r\n\t                    },\r\n\t                    position: {\r\n\t                        startPos: that.reverseConnect ? endPos : that.startPos,\r\n\t                        endPos: that.reverseConnect ? that.endPos : endPos\r\n\t                    }\r\n\t                }\r\n\t                var finalOpt = util.mergeOpt(connectOptions, that.lineOpt, true, 'position');\r\n\t                var start = that.reverseConnect ? targetNode : that.selectConnNode;\r\n\t                var end = that.reverseConnect ? that.selectConnNode : targetNode;\r\n\t                //如果有原始连线存在，则要暴露出去。\r\n\t                if (that.originNode) {\r\n\t                    origin.startNode = that.reverseConnect ? that.originNode : that.selectConnNode;\r\n\t                    origin.endNode = that.reverseConnect ? that.selectConnNode : that.originNode;\r\n\t                    origin.options = util.mergeOpt({\r\n\t                        style: {\r\n\t                            lineType: arrow.lineType\r\n\t                        },\r\n\t                        position: {\r\n\t                            startPos: that.reverseConnect ? that.originPos : that.startPos,\r\n\t                            endPos: that.reverseConnect ? that.endPos : that.originPos\r\n\t                        }\r\n\t                    }, that.lineOpt, true, 'position');\r\n\t                }\r\n\t                if(!that._trigger('beforeCreate', {target: start, endNode: end, connectOptions: finalOpt, origin: origin})) {\r\n\t                    return false;\r\n\t                }\r\n\t                that.createConnectorByNodes(start, end, finalOpt);\r\n\t                that.hideConnectorPoint();      //隐藏所有节点上的连接点\r\n\t                // 触发selectConnNode点击\r\n\t                // that.nodeClickHandler(that.selectConnNode);\r\n\t            } else {\r\n\t                arrow.show();\r\n\t                arrow.position = [0, 0];\r\n\t                //还原所有连接点的颜色\r\n\t                that.group.children().forEach(function (v) {\r\n\t                    if (v.type === 'ConnectPoint') {\r\n\t                        v.attr({style:{fill: \"#FFFF33\"},scale:[1,1],origin:[v.shape.cx,v.shape.cy]});\r\n\t                    }\r\n\t                });\r\n\t            }\r\n\t        });\r\n\t    }\r\n\t    fishTopoProto.createLineConnectorPoint = function(point, pos, lineType) {\r\n\t        var pointInstance = new graphic.Circle({\r\n\t            shape: {\r\n\t                cx: point.x,\r\n\t                cy: point.y,\r\n\t                r: 4\r\n\t            },\r\n\t            style: {\r\n\t                fill: '#FFFF33',\r\n\t                stroke:'#000000'\r\n\t            },\r\n\t            z : 4,\r\n\t            draggable: true,\r\n\t            lineType: lineType\r\n\t        });\r\n\t        pointInstance.type = 'ConnectPoint';\r\n\t        pointInstance.pos = pos;                //记录是节点上哪个位置的连接点\r\n\t        this.group.add(pointInstance);\r\n\t    }\r\n\t\r\n\t    fishTopoProto.getRotatedCornerCursor = function(node, pos) {\r\n\t        var that = this;\r\n\t        var rotation = node.rotation;\r\n\t        if (pos === 'mtr') {\r\n\t            return that.cursorMap[pos];\r\n\t        }\r\n\t        if (Math.abs(rotation) > 0) {\r\n\t            var angle = -rotation / (Math.PI/180);\r\n\t            var n = Math.round((angle % 360) / 45);\r\n\t            if (n < 0) {\r\n\t                n += 8; // full circle ahead\r\n\t            }\r\n\t            n += that.cursorOffset[pos];\r\n\t            n %= 8;\r\n\t            return that.cursorMaps[n];\r\n\t        }\r\n\t        return that.cursorMap[pos];\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 根据point创建节点上的控制点\r\n\t     * @param {Object} point x，y坐标  {x:x, y:y}\r\n\t     * @param {String} pos x，y坐标 [tl|tc|tr|bl|br|mtr] (top-left, top-center, top-right, bottom-left, bottom-right, middle-top-rotate)\r\n\t     * @param {String} nodeId 创建控制点时传入当前节点的id，完成节点与控制点的绑定\r\n\t     */\r\n\t    fishTopoProto.createConnectorControl = function(point, pos, node) {\r\n\t        var me = this;\r\n\t        var posArr = pos.split(',');\r\n\t        if (posArr.length < 2) {\r\n\t            var controlCursor = me.getRotatedCornerCursor(node, pos);\r\n\t            var pointInstance = new graphic.Rect({\r\n\t                shape:{\r\n\t                    x: point.x - 4,\r\n\t                    y: point.y - 4,\r\n\t                    width: 8,\r\n\t                    height: 8\r\n\t                },\r\n\t                style: {\r\n\t                    fill: '#ffffff',\r\n\t                    stroke:'#000000'\r\n\t                },\r\n\t                z: 4,\r\n\t                rotation: node.rotation,\r\n\t                origin: [point.x, point.y],\r\n\t                cursor: controlCursor,\r\n\t                draggable: true\r\n\t            });\r\n\t            pointInstance.type = 'ConnectControl';\r\n\t            pointInstance.pos = pos;// 记录是节点上哪个位置的连接点\r\n\t            var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];\r\n\t            zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n\t                pointInstance.on(eveName, function(e) {\r\n\t                    var params = {};\r\n\t                    params.event = e;\r\n\t                    params.type = \"ConnectControl:\" + eveName;\r\n\t                    params.nodeId = node.id;\r\n\t                    params.cursor = controlCursor;\r\n\t                    me.group.trigger(params.type, params);\r\n\t                });\r\n\t            });\r\n\t            this.group.add(pointInstance);\r\n\t        } else {\r\n\t            // 旋转点与节点之间需要连线\r\n\t            var line = new graphic.Line({\r\n\t                shape: {\r\n\t                    x1: point.top.x,\r\n\t                    y1: point.top.y,\r\n\t                    x2: point.bottom.x,\r\n\t                    y2: point.bottom.y\r\n\t                },\r\n\t                style: {\r\n\t                    lineWidth: 1\r\n\t                },\r\n\t                z: 1,\r\n\t                draggable: false,\r\n\t                cursor: 'default'\r\n\t            });\r\n\t            line.type = 'ConnectControlLine';\r\n\t            line.nodeId = node.id;\r\n\t            this.group.add(line);\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @method returnConnectorControlParam\r\n\t     * 返回旋转点和缩放点控制参数\r\n\t     * @param  {Object} 当前节点对象\r\n\t     */\r\n\t    fishTopoProto.returnConnectorControlParam = function(node) {\r\n\t        var scaleFlag = typeof node.scaleable === 'boolean' ? node.scaleable : this.options.scaleable;\r\n\t        var rotateFlag = typeof node.rotatable === 'boolean' ? node.rotatable : this.options.rotatable;\r\n\t        return {\r\n\t            scaleable: scaleFlag,\r\n\t            rotatable: rotateFlag\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 隐藏节点上的控制点\r\n\t     */\r\n\t    fishTopoProto.hideConnectorControl = function() {\r\n\t        var that = this;\r\n\t        var types = ['ConnectControl', 'ConnectControlLine'];\r\n\t        this.group.children().forEach(function (v) {\r\n\t            if (types.includes(v.type)) {\r\n\t                that.group.remove(v);\r\n\t            }\r\n\t        })\r\n\t        this.group.off(\"ConnectControl:dragstart\");\r\n\t        this.group.off(\"ConnectControl:drag\");\r\n\t        this.group.off(\"ConnectControl:dragend\");\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 在节点上显示控制点\r\n\t     *\r\n\t     *  **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *      fishTopo.showConnectorControl();\r\n\t    */\r\n\t   fishTopoProto.showConnectorControl = function() {\r\n\t    var that = this;\r\n\t    this.hideConnectorControl();\r\n\t    // 让当前节点显示控制点\r\n\t    var rect = util.getRect(this.selectedNode);\r\n\t    var connectorPoint = util.getConnectorControls(rect, this.selectedNode);\r\n\t    var params = this.returnConnectorControlParam(this.selectedNode);\r\n\t    if (params.scaleable) {\r\n\t        that.createConnectorControl(connectorPoint.tl, \"tl\", this.selectedNode);\r\n\t        that.createConnectorControl(connectorPoint.tr, \"tr\", this.selectedNode);\r\n\t        that.createConnectorControl(connectorPoint.bl, \"bl\", this.selectedNode);\r\n\t        that.createConnectorControl(connectorPoint.br, \"br\", this.selectedNode);\r\n\t    }\r\n\t    if (params.rotatable) {\r\n\t        that.createConnectorControl(connectorPoint.mtr, \"mtr\", this.selectedNode);\r\n\t        that.createConnectorControl({ top: connectorPoint.mtr, bottom: connectorPoint.tc }, \"mtr,tc\", this.selectedNode);\r\n\t    }\r\n\t\r\n\t    function findControlNode (id) {\r\n\t        var node = null;\r\n\t        that.group.children().forEach(function(item) {\r\n\t            if (item.id === id) {\r\n\t                    node = item;\r\n\t            }\r\n\t        });\r\n\t        return node;\r\n\t    }\r\n\t\r\n\t    this.group.on(\"ConnectControl:dragstart\", function(e) {\r\n\t        // 首先清除其他所有节点的控制点和连接点\r\n\t        var cursor = e.event.target.cursor;\r\n\t        var pos = e.event.target.pos;\r\n\t        var posMap = {\r\n\t            'tl': 'br',\r\n\t            'tr': 'bl',\r\n\t            'bl': 'tr',\r\n\t            'br': 'tl'\r\n\t        };\r\n\t        that.selectConnNode = findControlNode(e.nodeId);\r\n\t        if (cursor && pos !== 'mtr') {\r\n\t            var originNode = that.group.children().find(function (node) {\r\n\t                return node.pos === posMap[pos];\r\n\t            });\r\n\t            var currentNode = that.group.children().find(function (node) {\r\n\t                return node.pos === pos;\r\n\t            });\r\n\t            var boundingRect = that.selectConnNode.getBoundingRect();\r\n\t            that.oppositeShape = zrUtil.clone(originNode.shape);\r\n\t            that.currentShape = zrUtil.clone(currentNode.shape);\r\n\t            var rect = zrUtil.clone(util.getRect(that.selectConnNode, true));\r\n\t            var diagonal = Math.sqrt(Math.pow(rect.width, 2) + Math.pow(rect.height, 2));// 对角线长度\r\n\t            that.diagonal = diagonal;\r\n\t            that.originRect = zrUtil.clone(rect);\r\n\t            that.ifPointCenter = boundingRect.x < -1; // 判断中心点是否在节点中心(原形在中心，矩形在左上角)\r\n\t            // 移除node高亮\r\n\t            that.selectConnNode.selectStyle && that._api.getZr().removeHover(that.selectConnNode);\r\n\t        }\r\n\t    });\r\n\t    this.group.on(\"ConnectControl:drag\", function(e) {\r\n\t        var cursor = e.event.target.cursor;\r\n\t        var targetPos = e.event.target.pos;\r\n\t        var currentNode = that.selectConnNode;\r\n\t        var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;\r\n\t        var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;\r\n\t        var rect = util.getRect(currentNode, true);\r\n\t        if (targetPos === 'mtr') {\r\n\t            // 旋转\r\n\t            var r_x = x - currentNode.position[0];\r\n\t            var r_y = y - currentNode.position[1];\r\n\t            var origins = {\r\n\t                x: rect.x - currentNode.position[0],\r\n\t                y: rect.y - currentNode.position[1]\r\n\t            }\r\n\t            var rotation = Math.atan2(r_y, r_x);\r\n\t            that.selectedNode.attr({\r\n\t                'origin': [origins.x, origins.y],\r\n\t                'rotation': -rotation\r\n\t            });\r\n\t            var connectorPoint = util.getConnectorPoints(rect, that.selectedNode);\r\n\t            var controlPoint = util.getConnectorControls(rect, that.selectedNode);\r\n\t            // 节点连线点，控制点位置更新\r\n\t            that.group.children().forEach(function (item) {\r\n\t                var pos = item.pos;\r\n\t                if (item.type === 'ConnectControl') {\r\n\t                    if (pos === 'mtr') {\r\n\t                        item.attr('position', [0, 0]);\r\n\t                        item.attr('rotation', 0);\r\n\t                    }\r\n\t                    item.setShape({ x: controlPoint[pos].x - 4, y: controlPoint[pos].y - 4 });\r\n\t                    item.attr({\r\n\t                        'origin': [item.shape.x + 4, item.shape.y + 4],\r\n\t                        'rotation': -rotation\r\n\t                    });\r\n\t                } else if (item.type === 'ConnectControlLine') {\r\n\t                    item.setShape({ x1: controlPoint.mtr.x, x2: controlPoint.tc.x, y1: controlPoint.mtr.y, y2: controlPoint.tc.y });\r\n\t                } else if (item.type === 'ConnectPoint') {\r\n\t                    item.setShape({ cx: connectorPoint[pos].x, cy: connectorPoint[pos].y });\r\n\t                }\r\n\t            });\r\n\t        } else {\r\n\t            // 缩放(缩放点需要结合旋转角度计算)\r\n\t            var ratio = 1,\r\n\t                center = [],\r\n\t                centerPoint = {},\r\n\t                width0, height0;\r\n\t            var cursorsY = ['n-resize', 's-resize'];\r\n\t            var positionOrg = {\r\n\t                'tl': 'br',\r\n\t                'tr': 'bl',\r\n\t                'bl': 'tr',\r\n\t                'br': 'tl'\r\n\t            }\r\n\t\r\n\t            var scaleNodes = that.group.children().filter(function (node) {\r\n\t                return node.type === 'ConnectControl' && node.pos !== 'mtr'\r\n\t            });\r\n\t            var currentControlNode = scaleNodes.find(function(node) {\r\n\t                return node.pos === targetPos;\r\n\t            });\r\n\t\r\n\t            if (x <= 8) {\r\n\t                x = 8;\r\n\t            }\r\n\t            if (y <= 8) {\r\n\t                y = 8;\r\n\t            }\r\n\t\r\n\t            if (cursorsY.includes(cursor)) {\r\n\t                // 获取y轴比例即可\r\n\t                var startY = currentControlNode.shape.y + 4;\r\n\t                ratio = that.currentShape.y >= that.oppositeShape.y ? ((y - that.oppositeShape.y - 4) / (startY - that.oppositeShape.y)) : ((that.oppositeShape.y + 4 - y) / (that.oppositeShape.y - startY));\r\n\t            } else {\r\n\t                // 获取x轴比例即可\r\n\t                var startX = currentControlNode.shape.x + 4;\r\n\t                ratio = that.currentShape.x >= that.oppositeShape.x ? ((x - that.oppositeShape.x - 4) / (startX - that.oppositeShape.x)) : ((that.oppositeShape.x + 4 - x) / (that.oppositeShape.x - startX))\r\n\t            }\r\n\t            if (!/^[0-9]+.?[0-9]*/.test(ratio)) {\r\n\t                ratio = 1;\r\n\t            }\r\n\t            currentNode.updateShape(ratio);\r\n\t\r\n\t            var rectScale = util.getRect(currentNode, true);\r\n\t            centerPoint = that.ifPointCenter ? { x: that.originRect.x, y: that.originRect.y } : { x: that.originRect.boundingRect.x, y: that.originRect.boundingRect.y };\r\n\t            var diagonalNew = Math.sqrt(Math.pow(rectScale.width, 2) + Math.pow(rectScale.height, 2));// 对角线长度\r\n\t            switch (cursor) {\r\n\t                // 上,左上\r\n\t                case 'n-resize':\r\n\t                case 'nw-resize':\r\n\t                    width0 = (that.oppositeShape.x + 4 - centerPoint.x) * diagonalNew / that.diagonal;\r\n\t                    height0 = (that.oppositeShape.y + 4 - centerPoint.y) * diagonalNew / that.diagonal;\r\n\t                    center.push(that.oppositeShape.x - width0 + 4, that.oppositeShape.y - height0 + 4);\r\n\t                    break;\r\n\t                // 右,右上\r\n\t                case 'e-resize':\r\n\t                case 'ne-resize':\r\n\t                    width0 = (centerPoint.x - that.oppositeShape.x - 4) * diagonalNew / that.diagonal;\r\n\t                    height0 = (that.oppositeShape.y + 4 - centerPoint.y) * diagonalNew / that.diagonal;\r\n\t                    center.push(that.oppositeShape.x + width0 + 4, that.oppositeShape.y - height0 + 4);\r\n\t                    break;\r\n\t                // 下，右下\r\n\t                case 's-resize':\r\n\t                case 'se-resize':\r\n\t                    width0 = (centerPoint.x - that.oppositeShape.x - 4) * diagonalNew / that.diagonal;\r\n\t                    height0 = (centerPoint.y - that.oppositeShape.y - 4) * diagonalNew / that.diagonal;\r\n\t                    center.push(that.oppositeShape.x + width0 + 4, that.oppositeShape.y + height0 + 4);\r\n\t                    break;\r\n\t                // 左,左下\r\n\t                case 'w-resize':\r\n\t                case 'sw-resize':\r\n\t                    width0 = (that.oppositeShape.x + 4 - centerPoint.x) * diagonalNew / that.diagonal;\r\n\t                    height0 = (centerPoint.y - that.oppositeShape.y - 4) * diagonalNew / that.diagonal;\r\n\t                    center.push(that.oppositeShape.x - width0 + 4, that.oppositeShape.y + height0 + 4);\r\n\t                    break;\r\n\t                default:\r\n\t                    break;\r\n\t            }\r\n\t\r\n\t            var originScale = {\r\n\t                x: rectScale.x - center[0],\r\n\t                y: rectScale.y - center[1]\r\n\t            }\r\n\t            currentNode.attr({\r\n\t                'position': center,\r\n\t                'origin': [originScale.x, originScale.y]\r\n\t            });\r\n\t\r\n\t            // 此时节点包围盒需要重新计算\r\n\t            var rectNow = util.getRect(currentNode, true);\r\n\t            var connectorPointScale = util.getConnectorPoints(rectNow, currentNode);\r\n\t            var controlPointScale = util.getConnectorControls(rectNow, currentNode);\r\n\t            that.group.children().forEach(function(item) {\r\n\t                var pos = item.pos;\r\n\t                if (pos === targetPos) {\r\n\t                    item.attr('position', [0, 0]);\r\n\t                }\r\n\t                if (item.type === 'ConnectControl' && pos !== positionOrg[targetPos]) {\r\n\t                    item.setShape({ x: controlPointScale[pos].x - 4, y: controlPointScale[pos].y - 4 });\r\n\t                    item.attr('origin', [controlPointScale[pos].x, controlPointScale[pos].y]);\r\n\t                } else if (item.type === 'ConnectControlLine') {\r\n\t                    item.setShape({ x1: controlPointScale.mtr.x, x2: controlPointScale.tc.x, y1: controlPointScale.mtr.y, y2: controlPointScale.tc.y });\r\n\t\r\n\t                } else if (item.type === 'ConnectPoint') {\r\n\t                    item.setShape({ cx: connectorPointScale[pos].x, cy: connectorPointScale[pos].y });\r\n\t                }\r\n\t            });\r\n\t        }\r\n\t        that.operationNode.refreshPostion(that.selectedNode, util.getRect(that.selectedNode));\r\n\t        // 1.5 刷新连线\r\n\t        that.connectionManager.refreshLineByNode(that.selectedNode);\r\n\t        // 1.6 如果是组的话,需要把组内所有结果都刷新一下线\r\n\t        if (Flow.isGroupNode(that.selectedNode)) {\r\n\t            that.selectedNode.each(function(childNode) {\r\n\t                that.connectionManager.refreshLineByNode(childNode);\r\n\t            });\r\n\t        }\r\n\t\r\n\t    });\r\n\t    this.group.on(\"ConnectControl:dragend\", function(e) {\r\n\t        // 更新节点position\r\n\t        var node = that.selectConnNode;\r\n\t        var position = node.position;\r\n\t        var origin = node.origin;\r\n\t        // position origin取整\r\n\t        that.selectConnNode.attr('position', [parseInt(position[0], 10), parseInt(position[1], 10)]);\r\n\t        if (Array.isArray(origin)) {\r\n\t            that.selectConnNode.attr('origin', [parseInt(origin[0], 10), parseInt(origin[1], 10)]);\r\n\t        }\r\n\t        node.updateShape(1, true);\r\n\t        if (node.model) {\r\n\t            // 更新model，支持序列化/反序列化\r\n\t            node.model.set(\"options.rotation\", node.rotation);\r\n\t            node.model.set(\"options.origin\", node.origin);\r\n\t            var elementType = node.model.option.elementType;\r\n\t            if (elementType === 'Image') {\r\n\t                node.model.set(\"options.style\", node.style);\r\n\t            } else {\r\n\t                node.model.set(\"options.shape\", node.shape);\r\n\t            }\r\n\t        }\r\n\t        // 1.4 触发点击\r\n\t        that.nodeClickHandler(node);\r\n\t        that.stepCounter();\r\n\t        that.oppositeShape = null;\r\n\t        that.currentShape = null;\r\n\t        that.diagonal = null;\r\n\t        that.originRect = null;\r\n\t        that.ifPointCenter = null;\r\n\t    });\r\n\t}\r\n\t\r\n\t    fishTopoProto.initOperationNode = function (node, ifCurrentNode) {\r\n\t        var that = this;\r\n\t        if (!ifCurrentNode) {\r\n\t            ifCurrentNode = false;\r\n\t        }\r\n\t        this.operationNode = new OperationNode(node, this.group, this._api);\r\n\t        // 根据连线点查找节点(考虑优化 创建连接点的时候 就把连接点与node进行绑定，就不用这个复杂的计算了)\r\n\t        function findConnectorNode(x, y, offset, pos) {\r\n\t            var node, endPos = null;\r\n\t            that.allNodes.forEach(function(item) {\r\n\t                var rect = util.getRect(item);\r\n\t                var connectorPoint = util.getConnectorPoints(rect, item);\r\n\t                if (pos) {\r\n\t                    if (Math.abs(connectorPoint[pos].x - x) <= offset && Math.abs(connectorPoint[pos].y - y) <= offset) {\r\n\t                        node = item;\r\n\t                    }\r\n\t                } else {\r\n\t                    if (Math.abs(connectorPoint[\"left\"].x - x) <= offset && Math.abs(connectorPoint[\"left\"].y - y) <= offset) {\r\n\t                        endPos = \"left\";\r\n\t                        node = item;\r\n\t                    } else if (Math.abs(connectorPoint[\"top\"].x - x) <= offset && Math.abs(connectorPoint[\"top\"].y - y) <= offset) {\r\n\t                        endPos = \"top\";\r\n\t                        node = item;\r\n\t                    } else if (Math.abs(connectorPoint[\"right\"].x - x) <= offset && Math.abs(connectorPoint[\"right\"].y - y) <= offset) {\r\n\t                        endPos = \"right\";\r\n\t                        node = item;\r\n\t                    } else if (Math.abs(connectorPoint[\"bottom\"].x - x) <= offset && Math.abs(connectorPoint[\"bottom\"].y - y) <= offset) {\r\n\t                        endPos = \"bottom\";\r\n\t                        node = item;\r\n\t                    }\r\n\t                }\r\n\t            });\r\n\t            return {\r\n\t                node: node,\r\n\t                endPos: endPos\r\n\t            };\r\n\t        }\r\n\t        this.operationNode.on(OperationNode.ARROW_DRAGSTART, function (e) {\r\n\t            this.hideConnectorPoint();\r\n\t            that.filterConnectPoint(that.allNodes, e.event.target.lineType);\r\n\t            var x = (e.event.offsetX - this.group.position[0]) / this.nowZoom;\r\n\t            var y = (e.event.offsetY - this.group.position[1]) / this.nowZoom;\r\n\t            if (e.data) {\r\n\t                this.lineOpt = e.data;  //缓存线段的配置信息\r\n\t            }\r\n\t            //拖拽开始先把 箭头图标 给隐藏\r\n\t            var arrow = e.event.target;\r\n\t            arrow.hide();\r\n\t            var rEndPoint = new Point(x, y);\r\n\t            var connector = this.connectionManager.manageTempConnector(this.selectedNode, rEndPoint,\r\n\t                arrow.lineType);\r\n\t            this.group.add(connector);\r\n\t            e.cancelBubble = true;\r\n\t        }.bind(this));\r\n\t\r\n\t        // 侦听 箭头 拖拽事件\r\n\t        this.operationNode.on(OperationNode.ARROW_DRAG, function (e) {\r\n\t            var x = (e.event.offsetX - this.group.position[0]) / this.nowZoom;\r\n\t            var y = (e.event.offsetY - this.group.position[1]) / this.nowZoom;\r\n\t            var arrow = e.event.target;\r\n\t            var rEndPoint = new Point(x, y);\r\n\t            this.connectionManager.manageTempConnector(this.selectedNode, rEndPoint, arrow.lineType);\r\n\t            that.group.children().forEach(function (v) {\r\n\t                if (v.type === 'ConnectPoint') {\r\n\t                    v.attr({style:{fill: \"#FFFF33\"},scale:[1,1],origin:[v.shape.cx,v.shape.cy]});\r\n\t                    if (Math.abs(v.shape.cx - x) <= 10 && Math.abs(v.shape.cy - y) <= 10) {\r\n\t                        var res = findConnectorNode(x, y, 10);\r\n\t                        that.connectionManager.manageTempConnector(that.selectedNode, rEndPoint, arrow.lineType, 'right', res.endPos, res.node);\r\n\t                        v.attr({style:{fill: \"#ff0000\"},scale:[1.5,1.5],origin:[v.shape.cx,v.shape.cy]});\r\n\t                    }\r\n\t                }\r\n\t            })\r\n\t            e.cancelBubble = true;\r\n\t        }.bind(this));\r\n\t\r\n\t        //侦听 箭头 拖拽结束事件 画线\r\n\t        this.operationNode.on(OperationNode.ARROW_DRAGEND, function (e) {\r\n\t            e.cancelBubble = true;\r\n\t            var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;\r\n\t            var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;\r\n\t            var res = findConnectorNode(x, y, 10);\r\n\t            var targetNode = res.node;\r\n\t            var endPos = res.endPos || 'left';\r\n\t            var arrow = e.event.target;\r\n\t            //拖拽结束先把 箭头图标 给显示\r\n\t            arrow.show();\r\n\t            //删除临时线\r\n\t            this.connectionManager.removeTempConnector(this.group);\r\n\t\r\n\t            //1.如果是子节点 内 节点拖拽 则 增加排除子节点的参数\r\n\t            // targetNode = findHover(this.allNodes, x, y);\r\n\t\r\n\t            //2.如果找到目标结点 则画线\r\n\t            if (targetNode && (this.selectedNode != targetNode)) {\r\n\t                var origin = {};\r\n\t                var connectOptions = {\r\n\t                    style: {\r\n\t                        lineType: arrow.lineType\r\n\t                    },\r\n\t                    position: {\r\n\t                        startPos: 'right',\r\n\t                        endPos: endPos\r\n\t                    }\r\n\t                }\r\n\t                var finalOpt = util.mergeOpt(connectOptions, that.lineOpt, true, 'position');\r\n\t                var start = that.selectedNode;\r\n\t                var end = targetNode;\r\n\t                //如果有原始连线存在，则要暴露出去。\r\n\t                if (that.originNode) {\r\n\t                    origin.startNode = that.selectedNode;\r\n\t                    origin.endNode = that.originNode;\r\n\t                    origin.options = util.mergeOpt({\r\n\t                        style: {\r\n\t                            lineType: arrow.lineType\r\n\t                        },\r\n\t                        position: {\r\n\t                            startPos: that.startPos,\r\n\t                            endPos: that.originPos\r\n\t                        }\r\n\t                    }, that.lineOpt, true, 'position');\r\n\t                }\r\n\t                if(!this._trigger('beforeCreate', {target:this.selectedNode,endNode:targetNode,connectOptions:connectOptions, origin: {}})) {\r\n\t                    return null;\r\n\t                }\r\n\t                that.createConnectorByNodes(start, end, finalOpt);\r\n\t            }\r\n\t            that.hideConnectorPoint();\r\n\t            // 连线成功/失败，当前节点依然是选中状态，需要重新计算虚线和图标位置\r\n\t            var node = that.selectedNode;\r\n\t            var shapeRect = util.getRect(node, true);\r\n\t            // 显示当前节点的连接点\r\n\t            that.showConnectorPoint('jagged', undefined, true);\r\n\t            that.operationNode.refreshPostion(node, shapeRect);\r\n\t        }.bind(this));\r\n\t\r\n\t        //删除按钮点击事件\r\n\t        this.operationNode.on(OperationNode.DELETE_CLICK, function () {\r\n\t            this.removeNode(this.selectedNode);\r\n\t        }.bind(this));\r\n\t        this.group.add(this.operationNode);\r\n\t    };\r\n\t\r\n\t    fishTopoProto.removeSelectedNodes = function() {\r\n\t        var that = this;\r\n\t        if (this.selectedNodes.length) {\r\n\t            this.selectedNodes.forEach(function(item, index) {\r\n\t                that.removeNode(item, {}, true);\r\n\t                if (index === that.selectedNodes.length - 1) {\r\n\t                    that.stepCounter();\r\n\t                }\r\n\t            });\r\n\t            this.selectedNodes = [];\r\n\t            this.dragSelectRect.off(\"mousedown\");\r\n\t            this.group.remove(this.dragSelectRect);\r\n\t        } else if (that.selectedNode) {\r\n\t            that.removeNode(that.selectedNode);\r\n\t            // 1. 隐藏连线点\r\n\t            this.hideConnectorPoint();\r\n\t            // 2. 隐藏控制点\r\n\t            this.hideConnectorControl();\r\n\t            // 3. 隐藏操作node\r\n\t            this._removeOperationNode();\r\n\t        }\r\n\t    };\r\n\t\r\n\t    fishTopoProto.findNodeChildIds = function (node, childIds) {\r\n\t        childIds.push(node.id);\r\n\t        node.children().filter(function (v) {\r\n\t            var pos = this.allNodes.findIndex(function (item) {\r\n\t                return item.id === v.id\r\n\t            });\r\n\t            return pos !== -1\r\n\t        }.bind(this)).forEach(function (sub) {\r\n\t            if (Flow.isGroupNode(sub)) {\r\n\t                this.findNodeChildIds(sub, childIds);\r\n\t            } else {\r\n\t                childIds.push(sub.id);\r\n\t            }\r\n\t        }.bind(this));\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 移除场景中的某个节点或者线段,同removeNode\r\n\t     * @method remove\r\n\t     * @param  {Object} node or link 待删除的节点或者线段\r\n\t     * @param {Object} [options] 参数\r\n\t     * @param {Boolean} [options.trigger=true] 是否触发删除事件\r\n\t     *\r\n\t     *  **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *      fishTopo.remove(peopleNode);\r\n\t     */\r\n\t\r\n\t    /**\r\n\t     * 移除场景中的某个节点或者线段,同remove\r\n\t     * @method removeNode\r\n\t     * @param  {Object} node or link 待删除的节点或者线段\r\n\t     * @param {Object} [options] 参数\r\n\t     * @param {Boolean} [options.trigger=true] 是否触发删除事件\r\n\t     *\r\n\t     *  **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *      fishTopo.removeNode(peopleNode);\r\n\t     */\r\n\t    fishTopoProto.remove = fishTopoProto.removeNode = function (delNode, options, isNoCount) {\r\n\t        var opt = options || {};\r\n\t        if(opt.trigger !==false && (!this._trigger('beforeDelete', {target:delNode}))) {\r\n\t            return;\r\n\t        }\r\n\t        var parentZr = this._getParentZr(delNode);\r\n\t        if (delNode instanceof Connector) {\r\n\t            // 1.1 删除线段上的操作图标\r\n\t            zrUtil.each(delNode.icons, function(lineOperationIcon) {\r\n\t                parentZr.remove(lineOperationIcon);\r\n\t            })\r\n\t            // 1.2 删除当前选中线段\r\n\t            this.connectionManager.deleteByLine(delNode,parentZr);\r\n\t        } else {\r\n\t            //2.1 删除节点\r\n\t            parentZr.remove(delNode);\r\n\t            var childIds = [];\r\n\t            if (Flow.isGroupNode(delNode)) {\r\n\t                this.findNodeChildIds(delNode, childIds);\r\n\t            } else {\r\n\t                childIds.push(delNode.id);\r\n\t            }\r\n\t            //2.从allNodes数组中删除\r\n\t            this.allNodes = this.allNodes.filter(function (v) {\r\n\t                return childIds.indexOf(v.id) === -1\r\n\t            });\r\n\t            //2.3 删除和节点相关联的线段\r\n\t            this.connectionManager.deleteSelectCon(delNode, this.group);\r\n\t            //2.4 删除节点操作\r\n\t            this._removeOperationNode();\r\n\t        }\r\n\t\r\n\t        //3. 清空连接线上的调整位置按钮\r\n\t        this.connectionManager.clearSelectCon();\r\n\t        //4. 清空连接线上的操作按钮\r\n\t        this.lineOperationManager.hideAllLineOperation();\r\n\t        if (isNoCount != true) {\r\n\t            this.stepCounter();\r\n\t        }\r\n\t        //4. 派发删除事件\r\n\t         this._trigger(\"delete\", {target:delNode});\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 选中场景中的某个节点,并且触发selectNode事件\r\n\t     * @param {Object} node 待选中的节点对象\r\n\t     * @since V2.3.0\r\n\t     *  **使用范例：**\r\n\t     * @example\r\n\t     * fishTopo.selectNode(node);\r\n\t     */\r\n\t\r\n\t    fishTopoProto.selectNode = function(node) {\r\n\t        if (node) {\r\n\t            this.nodeClickHandler(node);\r\n\t            this._trigger(\"selectNode\", {target:node});\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 根据节点创建连线\r\n\t     * @method createConnectorByNodes\r\n\t     * @param  {Object} startNode 开始节点\r\n\t     * @param  {Object} endNode   结束节点\r\n\t     * @param  {Object} options 线段选项 参见{@link fishTopoFlow.link#constructor 构造函数options参数}\r\n\t     * @param  {Boolean} trigger 是否触发create事件，默认是触发create事件，设置为false则不触发\r\n\t     */\r\n\t    fishTopoProto.createConnectorByNodes = function (startNode, endNode, options, trigger) {\r\n\t        var linkType = options.style.lineType || Connector.TYPE_STRAIGHT;\r\n\t        if (!flowLink[linkType]) {\r\n\t            return null;\r\n\t        }\r\n\t        var Link = flowLink[linkType];\r\n\t        var connector = new Link(startNode, endNode, options);\r\n\t        this.connectionManager.add(connector);\r\n\t\r\n\t        if (startNode.parent && endNode.parent && startNode.parent==endNode.parent ) {\r\n\t            endNode.parent.add(connector);\r\n\t        } else {\r\n\t            this.group.add(connector);\r\n\t        }\r\n\t\r\n\t        connector.on(\"mousedown\", function (e) {\r\n\t            this.connectionManager.connectorForbidEdit();\r\n\t            this.isNode = false;\r\n\t            this.showConnectorPoint(e.target.style.lineType);\r\n\t        }.bind(this));\r\n\t        connector.on(\"dblclick\", function () {\r\n\t            if (this.options.textEditable) {\r\n\t                this.connectorEdit(this);\r\n\t            }\r\n\t        }.bind(this));\r\n\t        if (trigger !== false) {\r\n\t            this._trigger(\"create\", { target: connector });\r\n\t        }\r\n\t        this.stepCounter();\r\n\t        return connector;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 派发创建完成事件  返回fales则取消\r\n\t     */\r\n\t    fishTopoProto._trigger = function(type, event, data) {\r\n\t        var callback = this.options[type];\r\n\t\r\n\t        if (data === void 0) data = {};\r\n\t        if (event === null) {\r\n\t            event = {type:type, target:this}\r\n\t        } else {\r\n\t            event.type = type;\r\n\t        }\r\n\t        event.data = data;\r\n\t        this._api.trigger(event.type, event);\r\n\t        return !(zrUtil.isFunction(callback) && callback.apply(this, [event].concat(data)) === false);\r\n\t    }\r\n\t\r\n\t\r\n\t    fishTopoProto.nodeClickHandler = function (node) {\r\n\t        var ifShowPoint = node.type !== 'dragSelect';\r\n\t        if (node.parent && node.parent.type === \"dragSelect\") {\r\n\t            ifShowPoint = false;\r\n\t        }\r\n\t        // 1. 隐藏连线点\r\n\t        this.hideConnectorPoint();\r\n\t        // 2. 隐藏控制点\r\n\t        this.hideConnectorControl();\r\n\t        // 3. 隐藏操作node\r\n\t        this._removeOperationNode();\r\n\t        // 鼠标点下 将操作框 移到对应的节点上\r\n\t        if (node.selectable === false) {\r\n\t            if (Flow.isInGroup(node)) {\r\n\t                var group = node.parent;\r\n\t                if (group.selectable === false) {\r\n\t                    return;\r\n\t                } else {\r\n\t                    node = group;   // 如果有组的话，就针对组进行处理\r\n\t                }\r\n\t            } else {\r\n\t                return;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        this.selectedNode = node;\r\n\t        var shapeRect = util.getRect(node,true);\r\n\t        if (!this.operationNode) {\r\n\t            this.initOperationNode(node, true);\r\n\t        }\r\n\t        if (ifShowPoint) {\r\n\t            // 显示当前节点的连接点\r\n\t            this.showConnectorPoint('jagged', undefined, true);\r\n\t            var params = this.returnConnectorControlParam(node);\r\n\t            if (params.scaleable || params.rotatable) {\r\n\t                // 显示当前节点的控制点\r\n\t                this.showConnectorControl();\r\n\t            }\r\n\t        }\r\n\t        // 在存在子流程的情况下 需要把node也传递一下\r\n\t        this.operationNode.refreshPostion(node, shapeRect);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 节点的移动操作, 为何要自己实现拖动？zredner Group不支持拖动，只能自己实现\r\n\t     */\r\n\t    fishTopoProto.drag = function (node) {\r\n\t        var that = this; // zrender中的一个bug event.target不会带group 只能用that 不能用bind(this)\r\n\t        node.on(\"mousedown\", function (event) {\r\n\t            var draggingTarget = this;\r\n\t            //如果加了属性 draggable:false或者拖拽框选里 则不可以拖动\r\n\t            if (draggingTarget.isdraggable == false || (this.parent && this.parent.type === \"dragSelect\")) {\r\n\t                return;\r\n\t            }\r\n\t            that._nodeDragHandler(draggingTarget, event.offsetX, event.offsetY);\r\n\t            event.cancelBubble = true;\r\n\t        });\r\n\t    };\r\n\t\r\n\t    fishTopoProto._nodeDragHandler = function (node, x, y) {\r\n\t        var isMove = 0;\r\n\t        var ts = this;\r\n\t        var nowGroupPosition = node.position;\r\n\t        var groupPositionX = node.position[0];\r\n\t        var groupPositionY = node.position[1];\r\n\t        node._startX = x;\r\n\t        node._startY = y;\r\n\t        if (node.type === \"dragSelect\") {\r\n\t            var allLines = this.group.children().filter(function (v) {\r\n\t                return v.model && v.model.option.elementType === \"connection\";\r\n\t            });\r\n\t            var nodes = this.dragSelectRect.children().filter(function (v) {\r\n\t                return v.name !== \"GROUP_RECT_NAME\" && v.model && v.model.option.elementType !== \"connection\";\r\n\t            });\r\n\t            var lines = this.dragSelectRect.children().filter(function (v) {\r\n\t                return v.name !== \"GROUP_RECT_NAME\" && v.model && v.model.option.elementType === \"connection\";\r\n\t            });\r\n\t            allLines.forEach(function (v) {\r\n\t                var startNode = nodes.find(function(node) {\r\n\t                    return node.id === v.startNode.id\r\n\t                });\r\n\t                var endNode = nodes.find(function(node) {\r\n\t                    return node.id === v.endNode.id\r\n\t                });\r\n\t                var ifExist = lines.findIndex(function(line) {\r\n\t                    return line.id === v.id\r\n\t                });\r\n\t                if ((startNode || endNode) && ifExist === -1) {\r\n\t                    ts.connectionManager.removeLine(v, ts._getParentZr(v));\r\n\t                }\r\n\t            });\r\n\t        }\r\n\t        node.trigger(\"dragstart\");\r\n\t        // 1、侦听移动事件\r\n\t\r\n\t        var moveHandler = function (event) {\r\n\t            event.cancelBubble = true;\r\n\t            var sX = (event.offsetX - node._startX) / (this.nowZoom);\r\n\t            var sY = (event.offsetY - node._startY) / (this.nowZoom);\r\n\t\r\n\t            if ((sX != 0) || (sY != 0)) {\r\n\t                isMove = 1;\r\n\t            }\r\n\t            node.trigger(\"drag\");\r\n\t            // 1.1处理组内的情况（如果节点拖动，组也跟着变）\r\n\t            if (Flow.isInGroup(node)) {\r\n\t                //放入node现有数值，用于重绘group\r\n\t                var nodeMessage = {\r\n\t                    width: Flow.isGroupNode(node) ? node.options.shape.width : (node.shape ? node.shape.width : node.style.width),\r\n\t                    height: Flow.isGroupNode(node) ? node.options.shape.height : (node.shape ? node.shape.height : node.style.height),\r\n\t                    position: node.position,\r\n\t                    movePosition: [groupPositionX, groupPositionY],\r\n\t                    moveX: sX,\r\n\t                    moveY: sY,\r\n\t                    node: node,\r\n\t                    isMove: isMove\r\n\t                };\r\n\t                node.parent.modifyGroupRect(nodeMessage);\r\n\t            }\r\n\t            nowGroupPosition[0] = groupPositionX + sX;\r\n\t            nowGroupPosition[1] = groupPositionY + sY;\r\n\t            node.attr(\"position\", nowGroupPosition);\r\n\t            // 1.2 处理告警的情况 （告警随着节点移动）\r\n\t            if (node.alarm) {\r\n\t                var newAlarmPosition = [nowGroupPosition[0] + node.getBoundingRect().width - (node.alarm\r\n\t                        .getBoundingRect().width - 6), nowGroupPosition[1] - node.alarm.getBoundingRect()\r\n\t                    .height - 3\r\n\t                ];\r\n\t                node.alarm.attr(\"position\", newAlarmPosition);\r\n\t            }\r\n\t            // 1.4 触发点击\r\n\t            this.nodeClickHandler(node);\r\n\t            // 1.5 刷新连线\r\n\t            this.connectionManager.refreshLineByNode(node);\r\n\t            // 1.6 如果是组的话,需要把组内所有结果都刷新一下线\r\n\t            if (Flow.isGroupNode(node)) {\r\n\t                node.each(function(childNode) {\r\n\t                    this.connectionManager.refreshLineByNode(childNode);\r\n\t                }.bind(this));\r\n\t            }\r\n\t            if (!Flow.isInGroup(node)) {\r\n\t                var group = this.isPosInGroup(this.allNodes, node);\r\n\t                for (var i = 0; i < this.allNodes.length; i++) {\r\n\t                    var item = this.allNodes[i];\r\n\t                    if (Flow.isGroupNode(item)) {\r\n\t                        if (group && item.id === group.id && item.id !== node.id) {\r\n\t                            item.children().find(function (v) {\r\n\t                                return v.name === \"GROUP_RECT_NAME\"\r\n\t                            }).attr(\"style\", {\r\n\t                                fill: \"#b6e3f5\"\r\n\t                            });\r\n\t                        } else {\r\n\t                            //恢复group的背景色\r\n\t                            item.children().find(function (v) {\r\n\t                                return v.name === \"GROUP_RECT_NAME\"\r\n\t                            }).attr(\"style\", {\r\n\t                                fill: \"rgba(0,0,0,0)\"\r\n\t                            });\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }.bind(this);\r\n\t        this._zr.on('mousemove', moveHandler);\r\n\t\r\n\t\r\n\t\r\n\t        //2. 拖拽结束\r\n\t        var endDragHandler = function () {\r\n\t            if (node.model) {\r\n\t                node.model.set(\"options.position\", FlowUtil.truncPosition(node.position));\r\n\t            }\r\n\t\r\n\t            this._zr.off('mousemove', moveHandler);\r\n\t            this._zr.off('mouseup', endDragHandler);\r\n\t            this._zr.off(\"globalout\", endDragHandler);\r\n\t\r\n\t            //2.1 缩微图\r\n\t            if (isMove == 1) {\r\n\t                this._trigger(\"dropDrag\", {target:node});\r\n\t                node.trigger(\"dragend\");\r\n\t                if (this.eagleEye == true) {\r\n\t                    this.openEagleEye(this.eagleEyeNode);\r\n\t                }\r\n\t                if (!Flow.isInGroup(node)) {\r\n\t                    var group = this.isPosInGroup(this.allNodes, node);\r\n\t                    if (group) {\r\n\t                        for (var i = 0; i < this.allNodes.length; i++) {\r\n\t                            var item = this.allNodes[i];\r\n\t                            if (Flow.isGroupNode(item) && item.id === group.id && item.id !== node.id) {\r\n\t                                var parentZr = this._getParentZr(node);\r\n\t                                parentZr.remove(node);\r\n\t                                item.add(node);\r\n\t                                var nodeX = Flow.isGroupNode(node) ? node.position[0] + node.options.shape.x : node.position[0];\r\n\t                                var nodeY = Flow.isGroupNode(node) ? node.position[1] + node.options.shape.y : node.position[1];\r\n\t                                var groupX = this.parentX(group);\r\n\t                                var groupY = this.parentY(group);\r\n\t                                node.attr(\"position\", [nodeX - groupX + item.options.shape.x, nodeY - groupY + item.options.shape.y]);\r\n\t                                item.children().find(function (v) {\r\n\t                                    return v.name === \"GROUP_RECT_NAME\"\r\n\t                                }).attr(\"style\", {\r\n\t                                    fill: \"rgba(0,0,0,0)\"\r\n\t                                });\r\n\t                            }\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t                this.stepCounter();\r\n\t            }\r\n\t        }.bind(this);\r\n\t        this._zr.on('mouseup', endDragHandler);\r\n\t        this._zr.on('globalout', endDragHandler);\r\n\t    }\r\n\t    fishTopoProto.parentX = function (node) {\r\n\t        if (node.parent && Flow.isGroupNode(node.parent) && this.group.id !== node.parent.id) {\r\n\t            return node.position[0] + node.options.shape.x + this.parentX(node.parent);\r\n\t        } else {\r\n\t            return node.position[0] + node.options.shape.x;\r\n\t        }\r\n\t    }\r\n\t\r\n\t    fishTopoProto.parentY = function (node) {\r\n\t        if (node.parent && Flow.isGroupNode(node.parent) && this.group.id !== node.parent.id) {\r\n\t            return node.position[1] + node.options.shape.y + this.parentY(node.parent);\r\n\t        } else {\r\n\t            return node.position[1] + node.options.shape.y;\r\n\t        }\r\n\t    }\r\n\t\r\n\t    fishTopoProto.isPosInGroup = function (allNodes, node) {\r\n\t        if (allNodes.length > 0) {\r\n\t            var res = null;\r\n\t            for (var i = 0; i < allNodes.length; i++) {\r\n\t                var group = allNodes[i];\r\n\t                if (Flow.isGroupNode(group)) {\r\n\t                    var groupWidth = group.options.shape.width;\r\n\t                    var groupHeight = group.options.shape.height;\r\n\t                    var groupX = this.parentX(group);\r\n\t                    var groupY = this.parentY(group);\r\n\t                    var rect = util.getRect(node, true);\r\n\t                    var nodeWidth = rect.width;\r\n\t                    var nodeHeight = rect.height;\r\n\t                    var nodeX = rect.x - nodeWidth/2;\r\n\t                    var nodeY = rect.y - nodeHeight/2;\r\n\t                    if (nodeX >= groupX && nodeY >= groupY && nodeX+nodeWidth <= groupX+groupWidth && nodeY+nodeHeight <= groupY+groupHeight) {\r\n\t                        var children = group.children();\r\n\t                        var sub = this.isPosInGroup(children, node);\r\n\t                        res = sub ? sub : group;\r\n\t                        break;\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t            return res;\r\n\t        }\r\n\t        return null\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 创建节点\r\n\t     * @method createNode\r\n\t     * @param  {String} type 类型 eg. 'Rect'、'Circle'、'Image'、'Group'、'Text'等\r\n\t     * @param  {Object} opt 节点选项 详见{@link fishTopoFlow.node Config options}\r\n\t     * @param {Object} userData 用户传递的业务数据\r\n\t     * @return {Object} 创建的节点对象\r\n\t     *\r\n\t     * **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *      var rect = this.fishTopo.createNode(\"Rect\", { //矩形\r\n\t     *          shape: {\r\n\t     *              width: 100,\r\n\t     *              height: 60,\r\n\t     *          },\r\n\t     *          style: {\r\n\t     *              text: \"基本矩形\",\r\n\t     *              fill: \"#167CFF\",\r\n\t     *              stroke: \"rgb(255,255,255)\",\r\n\t     *              textFont: '14px Microsoft YaHei'\r\n\t     *          },\r\n\t     *          position: [180, 100],\r\n\t     *          operationIcons: [{ name: 'DEL' },\r\n\t     *              { name: 'STRAIGHT' },\r\n\t     *              { name: 'JAGGED' },\r\n\t     *              { name: 'CURVE' },\r\n\t     *              {\r\n\t     *                  name: \"custom1\",\r\n\t     *                  iconPath: \"img/host.png\",\r\n\t     *                  callback: function(e) { alert(e.data.name + \" clicked\") }  //e.node是当前的节点\r\n\t     *              }\r\n\t     *          ]\r\n\t     *      });\r\n\t     */\r\n\t    fishTopoProto.createNode = fishTopoProto.creatNode = function (type, opt, userData) {\r\n\t        if (!flowNode[type]) {\r\n\t            return null;\r\n\t        }\r\n\t        var Shape = flowNode[type];\r\n\t        var node = new Shape(opt);\r\n\t\r\n\t        Flow.setUserData(node, userData);\r\n\t        return node;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 根据name获取节点\r\n\t     * @param  {String} name 在创建节点中  name属性设置的值\r\n\t     * @return {Object}      name对应的节点\r\n\t     */\r\n\t    fishTopoProto.childOfName = function (name) {\r\n\t        var arrResult = [];\r\n\t        var childrenNode = this.allNodes;\r\n\t        var childrenLine = this.connectionManager.connectors;\r\n\t        for (var i = 0; i < childrenNode.length; i++) {\r\n\t            if (childrenNode[i].model.get(\"options.name\") && childrenNode[i].model.get(\"options.name\") ==\r\n\t                name) {\r\n\t                arrResult.push(childrenNode[i]);\r\n\t            } else if (childrenNode[i].model.get(\"userData.name\") == name) {\r\n\t                arrResult.push(childrenNode[i]);\r\n\t            }\r\n\t        }\r\n\t        for (var j = 0; j < childrenLine.length; j++) {\r\n\t            if (childrenLine[j].model.get(\"options.name\") && childrenLine[j].model.get(\"options.name\") ==\r\n\t                name) {\r\n\t                arrResult.push(childrenLine[j]);\r\n\t            } else if (childrenLine[j].model.get(\"userData.name\") == name) {\r\n\t                arrResult.push(childrenLine[j]);\r\n\t            }\r\n\t        }\r\n\t        if (arrResult.length > 1) {\r\n\t            return arrResult;\r\n\t        } else {\r\n\t            return arrResult[0];\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 查找场景中的对象   例如: x坐标大于100的节点 findElements(function(node){ return node.position[0] > 100; });\r\n\t     * @param  {Function} cb      回调函数 参数为遍历的节点\r\n\t     * @param  {Object}   context 回调函数执行的上下文\r\n\t     * @return {Array}           返回查找到的对象\r\n\t     */\r\n\t    fishTopoProto.findElements = function (cb, context) {\r\n\t        var childrenNode = this.allNodes;\r\n\t        var childrenLine = this.connectionManager.connectors;\r\n\t        var arr = [];\r\n\t        for (var i = 0; i < childrenNode.length; i++) {\r\n\t            var child = childrenNode[i];\r\n\t            if (cb.call(context, child, i)) {\r\n\t                arr.push(child);\r\n\t            }\r\n\t        }\r\n\t        for (var j = 0; j < childrenLine.length; j++) {\r\n\t            var childL = childrenLine[j];\r\n\t            if (cb.call(context, childL, j)) {\r\n\t                arr.push(childL);\r\n\t            }\r\n\t        }\r\n\t        return arr;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 根据节点查找连线   例如: 默认查找开始节点的连线 findConnectorsByNode(node);\r\n\t     * @param  {Object}   node    节点\r\n\t     * @param  {Object}   options 是否查找开始节点\r\n\t     * @return {Array}            返回查找到的对象\r\n\t     */\r\n\t    fishTopoProto.findConnectorsByNode = function (node,options) {\r\n\t        var opts = options || {};\r\n\t        var arr = [];\r\n\t        // Default value\r\n\t        zrUtil.defaults(opts, {\r\n\t            startNode: true\r\n\t        });\r\n\t        var childrenLine = this.connectionManager.connectors;\r\n\t        for (var j = 0; j < childrenLine.length; j++) {\r\n\t            var childL = childrenLine[j];\r\n\t            if (opts.startNode) {\r\n\t                if(childL.startNode.id === node.id) {\r\n\t                    arr.push(childL);\r\n\t                }\r\n\t            } else {\r\n\t                if(childL.endNode.id === node.id) {\r\n\t                    arr.push(childL);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        return arr;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 设置背景色  或 背景图片\r\n\t     * @param {string} imageUrl 背景色  或 背景图片 eg. 'img/bg.jpg'，为‘gridLine’时网格背景\r\n\t     * @param {string} isRepeat 是否重复背景  如果重复的话，将使用css的repeat 因为canvas不支持repeat\r\n\t     */\r\n\t    fishTopoProto.setBackground = function (imageUrl, isRepeat) {\r\n\t        if (imageUrl && imageUrl.length > 0) {\r\n\t            this.model.set(Constants.BACKGROUND, imageUrl);\r\n\t            if (imageUrl.substr(0, 1) == \"#\" || imageUrl.substr(0, 4) == \"rgba\") { //如果是颜色创建rect为背景\r\n\t                if (!document.createElement('canvas').getContext) {\r\n\t                    this._dom.style.backgroundColor = imageUrl;\r\n\t                } else {\r\n\t                    var imageShape = new this.Shape.Rect({\r\n\t                        shape: {\r\n\t                            width: this._zr.getWidth(),\r\n\t                            height: this._zr.getHeight()\r\n\t                        },\r\n\t                        style: {\r\n\t                            fill: imageUrl\r\n\t                        },\r\n\t                        cursor: 'default',\r\n\t                        z: -1\r\n\t                    });\r\n\t                    this._zr.add(imageShape);\r\n\t                }\r\n\t\r\n\t            } else if (imageUrl == \"gridLine\") {\r\n\t                this.gridLineGroup = new graphic.Group();\r\n\t                this.gridLine(0.2);\r\n\t                this._zr.add(this.gridLineGroup);\r\n\t            } else {\r\n\t                if (!document.createElement('canvas').getContext || isRepeat) {\r\n\t                    this._dom.style.backgroundImage = \"url(\" + imageUrl + \")\";\r\n\t                    this._dom.style.backgroundRepeat = \"repeat\";\r\n\t                } else {\r\n\t                    var imageShape1 = new this.Shape.Image({ //如果是图片创建image为背景\r\n\t                        position: [0, 0],\r\n\t                        scale: [1, 1],\r\n\t                        style: {\r\n\t                            x: 0,\r\n\t                            y: 0,\r\n\t                            image: imageUrl,\r\n\t                            width: this._zr.getWidth(),\r\n\t                            height: this._zr.getHeight()\r\n\t                        },\r\n\t                        cursor: 'default',\r\n\t                        z: -1\r\n\t                    });\r\n\t                    this._zr.add(imageShape1);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    //背景网格线\r\n\t    fishTopoProto.gridLine = function (opacity) {\r\n\t        var pixel = 10;\r\n\t        var widthLen = parseInt(this.getWidth() / pixel);\r\n\t        for (var x = 0; x <= widthLen; x++) {\r\n\t            var lineX = new graphic.Line({\r\n\t                shape: {\r\n\t                    x1: x * pixel,\r\n\t                    y1: 0,\r\n\t                    x2: x * pixel,\r\n\t                    y2: this.getHeight()\r\n\t                },\r\n\t                style: {\r\n\t                    lineDash: [1],\r\n\t                    opacity: opacity\r\n\t                },\r\n\t                z: 0,\r\n\t                draggable: false,\r\n\t                cursor: 'default'\r\n\t            });\r\n\t            this.gridLineGroup.add(lineX);\r\n\t        }\r\n\t\r\n\t        var heightLen = parseInt(this.getHeight() / pixel, pixel);\r\n\t        for (var y = 0; y <= heightLen; y++) {\r\n\t            var lineY = new graphic.Line({\r\n\t                shape: {\r\n\t                    x1: 0,\r\n\t                    y1: y * pixel,\r\n\t                    x2: this.getWidth(),\r\n\t                    y2: y * pixel\r\n\t                },\r\n\t                style: {\r\n\t                    lineDash: [1],\r\n\t                    opacity: opacity\r\n\t                },\r\n\t                z: 0,\r\n\t                draggable: false,\r\n\t                cursor: 'default'\r\n\t            });\r\n\t            this.gridLineGroup.add(lineY);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建线段\r\n\t     * @method createLink\r\n\t     * @param  {Object} startNode 开始节点\r\n\t     * @param  {Object} endNode   结束节点\r\n\t     * @param  {Object} options 线段选项\r\n\t     * @param {Object} [options.style] 节点的样式\r\n\t     * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n\t     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n\t     * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n\t     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n\t     * @param {Object} [options.symbol] 线段的箭头\r\n\t     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n\t     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n\t     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n\t     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]\r\n\t     * @param {Object} [options.text] 线段上的文字\r\n\t     * @param {String} [options.text.text] 线段上的文字内容\r\n\t     * @param {String} [options.text.color] 线段上的文字颜色\r\n\t     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n\t     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]\r\n\t     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t     * @param {String} [options.position] 指定线段位置\r\n\t     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t     * @param {Object} [options.position.startOffset] 线段开始位置的偏移\r\n\t     * @param {Object} [options.position.endOffset] 线段结束位置的偏移\r\n\t     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]\r\n\t     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n\t     * @param {Object} [options.effect] 线上动态效果\r\n\t     * @param {String} [options.effect.show] 是否显示箭头动效\r\n\t     * @param {Number} [options.effect.period] 动效移动速度\r\n\t     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n\t     * @param {Number} [options.z] [连线的层级，越大越在前面显示]\r\n\t     * @param {Object} userData 用户传递的业务数据\r\n\t     * @return {Object} 创建的线段对象\r\n\t     *\r\n\t     * **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *      var link = me.fishTopo.createLink(startNode, endNode, {\r\n\t     *              symbol: { type: 'arrow', size: 10, color: \"rgb(0,200,255)\" }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n\t     *              style: { lineWidth: 3, stroke: \"rgb(0,200,255)\", lineDash: [3,3], lineType: \"jagged\"  }, //样式\r\n\t     *              text: {\r\n\t     *                  text: text,\r\n\t     *                  color: '#ffffff',\r\n\t     *                  textPos:textPos,//文字位置可选值 'start','center','end',默认值为center\r\n\t     *                  xOffset:10, //文字位置x偏移量\r\n\t     *              },\r\n\t     *              pos:'right,left',\r\n\t     *              effect: {\r\n\t     *                  show: true,//是否显示箭头动效\r\n\t     *                  period: 6,//箭头速度\r\n\t     *              },\r\n\t     *              position:{\r\n\t     *                    escapeDistance:[50,30],  //第一条折线的长度，最后一条折线的长度\r\n\t     *                    points:[\"x1,y1\",\"x2,y2\"]  不使用自动计算 指定连线的位置数组\r\n\t     *              },\r\n\t     *              z: 0\r\n\t     *          });\r\n\t     */\r\n\t    fishTopoProto.createLink = fishTopoProto.creatLink = function (startNode, endNode, options, userData) {\r\n\t        var linkType = Connector.TYPE_STRAIGHT;\r\n\t        if (options && options.style && options.style.lineType) {\r\n\t            linkType = options.style.lineType\r\n\t        }\r\n\t\r\n\t        if (!flowLink[linkType]) {\r\n\t            return null;\r\n\t        }\r\n\t        var Link = flowLink[linkType];\r\n\t        var connector = new Link(startNode, endNode, options);\r\n\t        if (userData) {\r\n\t            connector.model.set(Constants.USERDATA, zrUtil.clone(userData));\r\n\t        }\r\n\t\r\n\t        return connector;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 根据节点刷新节点所连的线（重新计算线的位置）\r\n\t     * @param  {Object} node [节点]\r\n\t     */\r\n\t    fishTopoProto.refreshLineByNode = function (node) {\r\n\t        this.connectionManager.refreshLineByNode(node);\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 线上文字编辑\r\n\t     */\r\n\t    fishTopoProto.connectorEdit = function (thisConnector) {\r\n\t        var lineText = thisConnector.childOfName('lineText');\r\n\t        if (!lineText) {\r\n\t            return;\r\n\t        }\r\n\t        var textarea = this.createTextArea();\r\n\t        var textRect = textContain.getBoundingRect(lineText.style.text, lineText.style.textFont);\r\n\t        var maxWidth = 1.2 * util.getRect(lineText).width * this.nowZoom + 10;\r\n\t        textarea.style.width = 1.2 * util.getRect(lineText).width * this.nowZoom + \"px\";\r\n\t        textarea.style.height = (2 * textRect.height || 12) * this.nowZoom + \"px\";\r\n\t        textarea.style.border = \"1px dashed #2e2e2e\";\r\n\t        textarea.innerHTML = lineText.style.text;\r\n\t        thisConnector.setStyle({\r\n\t            text: {\r\n\t                text: \"\"\r\n\t            }\r\n\t        })\r\n\t        this._dom.appendChild(textarea);\r\n\t        this._dom.style.position = \"relative\";\r\n\t        textarea.style.lineHeight = (1.2 * textRect.lineHeight || 12) + \"px\";\r\n\t        textarea.style.top = (lineText.position[1] - textRect.height) * this.nowZoom + this.group\r\n\t            .position[1] + \"px\";\r\n\t        textarea.style.left = (lineText.position[0] - 0.55 * textRect.width) * this.nowZoom +\r\n\t            this.group.position[0] + \"px\";\r\n\t        textarea.focus();\r\n\t        textarea.select();\r\n\t        this._textareaResize(textRect, textarea, maxWidth);\r\n\t        textarea.onkeyup = function () {\r\n\t            textarea.style.width = textRect.width < 60 ? \"80px\" : textarea.style.width;\r\n\t            textarea.style.height = textarea.scrollHeight + 'px';\r\n\t        }\r\n\t        textarea.onfocusout = function () {\r\n\t            thisConnector.setStyle({\r\n\t                text: {\r\n\t                    text: textarea.value || \"\"\r\n\t                }\r\n\t            })\r\n\t            textarea.remove();\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * @private\r\n\t     * 节点上文字编辑\r\n\t     */\r\n\t    fishTopoProto.nodeEdit = function (thisNode) {\r\n\t        var MAXWIDTH_MULTIPLE_TOP_BOTTOM = 3.3; //text最大宽度与节点宽度的系数，在top/bottom位置\r\n\t        var isNotSetText = false;\r\n\t        var textarea = this.createTextArea();\r\n\t        var nodeText = zrUtil.clone(thisNode.style.text);\r\n\t        var textRect = textContain.getBoundingRect(nodeText, thisNode.style.textFont);\r\n\t        var textareaWidth = textRect.width < 25 ? (1.2 * textRect.width * this.nowZoom + 10) : 36;\r\n\t        var textareaHeight = (2 * textRect.height || 24) * this.nowZoom;\r\n\t        textarea.style.width = textareaWidth + 'px';\r\n\t        textarea.style.height = textareaHeight + \"px\";\r\n\t        var nodeRect = util.getRect(thisNode);\r\n\t        var maxWidth = 1.2 * nodeRect.width * this.nowZoom;\r\n\t        textarea.style.lineHeight = (1.2 * textRect.lineHeight || 14.4) + \"px\";\r\n\t        textarea.style.border = \"1px dashed #2e2e2e\";\r\n\t        textarea.innerHTML = thisNode.style.text;\r\n\t        textarea.style.maxWidth = maxWidth + 'px';\r\n\t        this.setStyle(thisNode, {text: \"\"});  //先把节点文本给清空，否则删除文本框中文字的时候，会显示出来\r\n\t        this._dom.appendChild(textarea);\r\n\t        this._dom.style.position = \"relative\";\r\n\t        var offestI = 1;\r\n\t        if (thisNode.style.textAlign == \"left\") {\r\n\t            offestI = 0;\r\n\t        }\r\n\t        if (thisNode.style.textAlign == \"right\") {\r\n\t            offestI = 2;\r\n\t        }\r\n\t        var offestP = 0;\r\n\t        if (thisNode.style.textPosition && thisNode.style.textPosition == \"bottom\") {\r\n\t            offestP = 1;\r\n\t            maxWidth = MAXWIDTH_MULTIPLE_TOP_BOTTOM * nodeRect.width * this.nowZoom;\r\n\t            textarea.style.maxWidth = maxWidth + \"px\";\r\n\t        }\r\n\t        if (thisNode.style.textPosition && thisNode.style.textPosition == \"top\") {\r\n\t            offestP = -1;\r\n\t            maxWidth = MAXWIDTH_MULTIPLE_TOP_BOTTOM * nodeRect.width * this.nowZoom;\r\n\t            textarea.style.maxWidth = maxWidth + \"px\";\r\n\t        }\r\n\t        textarea.style.top = (nodeRect.y - textareaHeight / 2 + offestP * (nodeRect.height - textRect.height /\r\n\t            2)) * this.nowZoom + this.group.position[1] + \"px\";\r\n\t        textarea.style.left = (nodeRect.x - offestI * textareaWidth / 2) * this.nowZoom +\r\n\t            this.group.position[0] + \"px\";\r\n\t        textarea.focus();\r\n\t        textarea.select();\r\n\t        textarea.onkeyup = function() {\r\n\t            if (event.keyCode == keyCode.ESCAPE) {\r\n\t                isNotSetText = true;\r\n\t                textarea.blur();\r\n\t            } else {\r\n\t                var textRect = textContain.getBoundingRect(textarea.value, thisNode.style.textFont);\r\n\t                this._textareaResize(textRect, textarea, maxWidth);\r\n\t            }\r\n\t        }.bind(this);\r\n\t\r\n\t        textarea.onblur = function() {\r\n\t            if (!isNotSetText) {\r\n\t                var text = this.handleWrap(textarea.value, textarea.style.maxWidth);\r\n\t                this.setStyle(thisNode, {text: text});\r\n\t            } else {\r\n\t                this.setStyle(thisNode, {text: nodeText});\r\n\t            }\r\n\t            textarea.remove();\r\n\t        }.bind(this);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 创建文本域\r\n\t     */\r\n\t    fishTopoProto.createTextArea = function () {\r\n\t        var textarea = document.createElement(\"textarea\");\r\n\t        textarea.style.position = \"absolute\";\r\n\t        textarea.style.padding = \"6px\";\r\n\t        textarea.style.resize = \"none\";\r\n\t        textarea.style.whiteSpace = \"pre\";\r\n\t        textarea.style.lineHeight = \"125%\";\r\n\t        textarea.style.overflow = \"hidden\";\r\n\t        textarea.style.border = \"0\";\r\n\t        textarea.spellcheck = false;\r\n\t        return textarea;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 处理textarea自动换行\r\n\t     */\r\n\t    fishTopoProto.handleWrap = function (value, width) {\r\n\t        var spanNode = document.createElement(\"span\");\r\n\t        spanNode.style.position = \"absolute\";\r\n\t        spanNode.style.overflow = \"hidden\";\r\n\t        spanNode.style.border = \"0\";\r\n\t        spanNode.style.padding = \"0\";\r\n\t        spanNode.style.left = \"0\";\r\n\t        spanNode.style.top = \"0\";\r\n\t        this._dom.appendChild(spanNode);\r\n\t        var content = value.split(\"\\n\");\r\n\t        var result = \"\";\r\n\t        content.forEach(function(val, i){\r\n\t            var valLength = val.length;\r\n\t            if (valLength == 0) {\r\n\t                //result += \"\\n\";\r\n\t            } else {\r\n\t                var pre = \"\",\r\n\t                    innerVal, tempWidth, conWidth;\r\n\t                for (var innerI = 0; innerI < valLength; innerI++) {\r\n\t                    innerVal = val.charAt(innerI);\r\n\t                    spanNode.innerHTML = spanNode.innerHTML + innerVal;\r\n\t                    tempWidth = spanNode.clientWidth; //获取添加字符后隐藏域的宽度\r\n\t                    conWidth = Number(width.substring(0, width.length - 2));\r\n\t                    if (tempWidth > conWidth) {\r\n\t                        result += pre; //如果追加字符后隐藏域宽度大于TextArea宽度，则表明该字符为下一行字符，\r\n\t                        result += \"\\n\";\r\n\t                        spanNode.innerHTML = innerVal;\r\n\t                        pre = innerVal;\r\n\t                    } else if (innerI == valLength - 1) {\r\n\t                        result += pre + innerVal; //最后一个字符\r\n\t                        if (i < content.length - 1) {\r\n\t                            result += \"\\n\";\r\n\t                        }\r\n\t                        spanNode.innerHTML = \"\";\r\n\t                        pre = \"\";\r\n\t                    } else {\r\n\t                        pre += innerVal; //依次追加到pre变量中\r\n\t                    }\r\n\t\r\n\t                }\r\n\t            }\r\n\t        });\r\n\t        this._dom.removeChild(spanNode);\r\n\t        return result;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 文本域自适应高宽\r\n\t     */\r\n\t    fishTopoProto._textareaResize = function (textRect, textarea, width) {\r\n\t        var minWidth = 0;\r\n\t        textarea.style.width = 0;\r\n\t        textarea.style.width = (1.2 * textRect.width) * this.nowZoom + \"px\";\r\n\t        if (width < 60) {\r\n\t            minWidth = width;\r\n\t        } else {\r\n\t            minWidth = 80\r\n\t        }\r\n\t        if (textRect.width <= minWidth) {\r\n\t            textarea.style.width = minWidth + \"px\";\r\n\t        }\r\n\t        textarea.style.height = \"0px\";\r\n\t        textarea.style.height = textarea.scrollHeight + 'px';\r\n\t        if (textarea.scrollHeight <= 0) {\r\n\t            textarea.style.height = \"12px\";\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @method setStyle\r\n\t     * 节点更改style里的属性\r\n\t     * @param {String} name 节点style里的某个属性名称\r\n\t     * @param {String} string 节点style里的某个属性名称对应的值\r\n\t     * **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *          //节点设置文字\r\n\t     *         fishtopo.setStyle(node,{text:\"例子\"});\r\n\t     */\r\n\t    fishTopoProto.setStyle = function (node, options) {\r\n\t        node.setStyle(options);\r\n\t        zrUtil.merge(node.model.get(\"options.style\"), options, true);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @method setShape\r\n\t     * 节点更改shape里的属性\r\n\t     * @param {String} name 节点shape里的某个属性名称\r\n\t     * @param {String} string 节点shape里的某个属性名称对应的值\r\n\t     * **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *          //矩形节点设置宽\r\n\t     *         fishtopo.setShape(node,{width:100});\r\n\t     */\r\n\t    fishTopoProto.setShape = function (node, options) {\r\n\t        node.setShape(options);\r\n\t        if (node.model) {\r\n\t            zrUtil.merge(node.model.get(\"options.shape\"), options, true);\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 创建节点上面的警告\r\n\t     * @method createAlarm\r\n\t     * @param  {Object} node 节点\r\n\t     * @param  {Object} opt  选项值\r\n\t     * @param  {Object} [opt.text] 警告的文字\r\n\t     * @param  {Object} [opt.textFont] 警告的文字的字体\r\n\t     * @param  {Object} [opt.textFill] 警告的文字的颜色\r\n\t     * @param  {Object} [opt.textBackground] 警告的背景的颜色\r\n\t     * @return {Object} 返回节点上的警告\r\n\t     *\r\n\t     * **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *          this.fishTopo.createAlarm(s1,{\r\n\t     *          text:\"2 W\",\r\n\t     *          textFont:\"4px Microsoft YaHei\",\r\n\t     *          textFill:\"#FFFFFF\",\r\n\t     *          textBackground:\"rgba(255,0,0,0.6)\"\r\n\t     *      });//创建小图片和节点绑定\r\n\t     */\r\n\t    fishTopoProto.createAlarm = fishTopoProto.creatAlarm = function (node, opt) {\r\n\t        var group = this.createNode(\"Group\", {\r\n\t            style: {\r\n\t                fill: 'rgba(0,0,0,0)',\r\n\t                stroke: 'rgba(0,0,0,0)'\r\n\t            }\r\n\t        });\r\n\t        group.isdraggable = false;\r\n\t        var text = this.createNode(\"Text\", { //文字\r\n\t            style: {\r\n\t                text: opt.text,\r\n\t                textFont: opt.textFont,\r\n\t                fill: opt.textFill,\r\n\t                textBaseline: \"top\" //垂直对齐,\r\n\t            },\r\n\t            selectable: false,\r\n\t            position: [2, 0],\r\n\t            z: 2\r\n\t        });\r\n\t        text.isdraggable = false;\r\n\t        group.add(text);\r\n\t        if (Flow.isInGroup(node)) {\r\n\t            node.parent.add(group);\r\n\t        } else {\r\n\t            this.group.add(group);\r\n\t        }\r\n\t        var groupWidth = group.getBoundingRect().width + 2;\r\n\t        var groupHeight = group.getBoundingRect().height + 6;\r\n\t        var points = [\r\n\t            [0, 0],\r\n\t            [groupWidth, 0],\r\n\t            [groupWidth, groupHeight],\r\n\t            [groupWidth - 3, groupHeight],\r\n\t            [groupWidth - 6, groupHeight + 3],\r\n\t            [groupWidth - 9, groupHeight],\r\n\t            [0, groupHeight],\r\n\t            [0, 0]\r\n\t        ];\r\n\t        var Polyline = this.createNode(\"Polyline\", {\r\n\t            shape: {\r\n\t                points: points\r\n\t            },\r\n\t            style: {\r\n\t                fill: opt.textBackground,\r\n\t                stroke: opt.textBackground\r\n\t            },\r\n\t            selectable: false,\r\n\t            z: 1\r\n\t        });\r\n\t        Polyline.isdraggable = false;\r\n\t        group.add(Polyline);\r\n\t        var groupPosition = [node.position[0] + node.getBoundingRect().width - (group.getBoundingRect().width -\r\n\t            6), node.position[1] - group.getBoundingRect().height - 3];\r\n\t        group.attr(\"position\", groupPosition);\r\n\t        node.alarm = group;\r\n\t        //设置模型 给json序列化用\r\n\t        var model = new Model({});\r\n\t        model.set(Constants.ELEMENT_TYPE, Constants.ALARM);\r\n\t        model.set(Constants.OPTIONS, zrUtil.clone(opt));\r\n\t        model.set(Constants.RELATIONID, node.model.get(Constants.ID));\r\n\t        group.model = model;\r\n\t        return group;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 返回当前画布的数据\r\n\t     */\r\n\t    fishTopoProto.toDataURL = function (opts) {\r\n\t        return FlowUtil.toDataURL(this._zr, opts);\r\n\t    };\r\n\t\r\n\t    fishTopoProto._releaseSelectNode = function () {\r\n\t        if (this.dragSelectRect) {\r\n\t            var nodes = this.dragSelectRect.children().filter(function (v) {\r\n\t                return v.name !== \"GROUP_RECT_NAME\";\r\n\t            });\r\n\t            var groupNodesIds = this.group.children()\r\n\t                .filter(function (v) {\r\n\t                    return v.name !== \"GROUP_RECT_NAME\";\r\n\t                })\r\n\t                .map(function(v) {\r\n\t                    return v.id\r\n\t                });\r\n\t            var startX = this.dragSelectRect.position[0];\r\n\t            var startY = this.dragSelectRect.position[1];\r\n\t            for (var i = 0; i < nodes.length; i++) {\r\n\t                var item = nodes[i];\r\n\t                var nodeX = Flow.isGroupNode(item) ? item.position[0] + item.options.shape.x : item.position[0];\r\n\t                var nodeY = Flow.isGroupNode(item) ? item.position[1] + item.options.shape.y : item.position[1];\r\n\t                this.dragSelectRect.remove(item);\r\n\t                // group内不存在dragSelectRect节点方可添加\r\n\t                if (!groupNodesIds.includes(item.id)) {\r\n\t                    this.group.add(item);\r\n\t                }\r\n\t                if (item.model.option.elementType !== \"connection\") {\r\n\t                    item.attr(\"position\", [nodeX+startX, nodeY+startY]);\r\n\t                    this.connectionManager.refreshLineByNode(item);\r\n\t                }\r\n\t            }\r\n\t            this.dragSelectRect.off(\"mousedown\");\r\n\t            this.group.remove(this.dragSelectRect);\r\n\t        }\r\n\t    }\r\n\t\r\n\t    fishTopoProto._dragSelect = function (node, x, y) {\r\n\t        var canvasOffsetX = this.group.position[0];\r\n\t        var canvasOffsetY = this.group.position[1];\r\n\t        this._releaseSelectNode();  //还原选中的节点\r\n\t        this.dragSelectRect = new GroupNode({\r\n\t            shape:{ width: 0, height: 0},\r\n\t            position:[(x-canvasOffsetX)/this.nowZoom, (y-canvasOffsetY)/this.nowZoom],\r\n\t            childDraggable: false,\r\n\t            style: {\r\n\t                lineDash:[2,2],\r\n\t                fill: \"rgba(239,222,221,0.7)\",\r\n\t                stroke: '#ddd'\r\n\t            }\r\n\t        });\r\n\t        this.dragSelectRect.type = \"dragSelect\";\r\n\t        this.group.add(this.dragSelectRect);\r\n\t        this.drag(this.dragSelectRect);\r\n\t\r\n\t        var moveHandler = function (event) {\r\n\t            var posX = x <= event.offsetX ? x : event.offsetX;\r\n\t            var posY = y <= event.offsetY ? y : event.offsetY;\r\n\t            var width = Math.abs(event.offsetX - x);\r\n\t            var height = Math.abs(event.offsetY - y);\r\n\t            this.dragSelectRect.shape = {\r\n\t                width: width/this.nowZoom,\r\n\t                height: height/this.nowZoom\r\n\t            }\r\n\t            this.dragSelectRect.setProperties({shape: {width:width/this.nowZoom, height: height/this.nowZoom}, position: [(posX-canvasOffsetX)/this.nowZoom, (posY-canvasOffsetY)/this.nowZoom]});\r\n\t        }.bind(this);\r\n\t        this._zr.on('mousemove', moveHandler);\r\n\t\r\n\t        var endDragHandler = function (event) {\r\n\t            this._zr.off('mousemove', moveHandler);\r\n\t            this._zr.off('mouseup', endDragHandler);\r\n\t            this._zr.off(\"globalout\", endDragHandler);\r\n\t\r\n\t            var ts = this;\r\n\t            var allNodes = this.group.children().filter(function (v) {\r\n\t                return v.id !== ts.dragSelectRect.id && v.model && v.model.option.elementType !== \"connection\";\r\n\t            });\r\n\t            var allLines = this.group.children().filter(function (v) {\r\n\t                return v.model && v.model.option.elementType === \"connection\";\r\n\t            });\r\n\t            var startX = this.dragSelectRect.position[0];\r\n\t            var startY = this.dragSelectRect.position[1];\r\n\t            var width = this.dragSelectRect.options.shape.width;\r\n\t            var height = this.dragSelectRect.options.shape.height;\r\n\t            var cnt = 0;\r\n\t            allNodes.forEach(function (item) {\r\n\t                var rect = util.getRect(item, true);\r\n\t                var nodeWidth = rect.width;\r\n\t                var nodeHeight = rect.height;\r\n\t                var nodeX = rect.x - nodeWidth/2;\r\n\t                var nodeY = rect.y - nodeHeight/2;\r\n\t                if (nodeX >= startX && nodeY >= startY && nodeX+nodeWidth <= startX+width && nodeY+nodeHeight <= startY+height) {\r\n\t                    ts.group.remove(item);\r\n\t                    ts.dragSelectRect.add(item);\r\n\t                    ts.selectedNodes.push(item);\r\n\t                    item.attr(\"position\", [item.position[0]-startX, item.position[1]-startY]);\r\n\t                    cnt++;\r\n\t                }\r\n\t            });\r\n\t            allLines.forEach(function (item) {\r\n\t                var startNode = ts.dragSelectRect.children().find(function (v) {\r\n\t                    return v.id === item.startNode.id;\r\n\t                });\r\n\t                var endNode = ts.dragSelectRect.children().find(function (v) {\r\n\t                    return v.id === item.endNode.id;\r\n\t                });\r\n\t                if (startNode && endNode) {\r\n\t                    ts.group.remove(item);\r\n\t                    ts.dragSelectRect.add(item);\r\n\t                    ts.selectedNodes.push(item);\r\n\t                    ts.connectionManager.refreshLineByNode(item.startNode);\r\n\t                } else if (startNode || endNode) {\r\n\t                    // 删除选框外的节点与内节点间的连线\r\n\t                    ts.group.remove(item);\r\n\t                }\r\n\t            });\r\n\t            if (!cnt) {\r\n\t                this.dragSelectRect.off(\"mousedown\");\r\n\t                this.group.remove(this.dragSelectRect);\r\n\t            } else {\r\n\t                this.dragSelectRect.childOfName(\"GROUP_RECT_NAME\").attr(\"style\", {\r\n\t                    fill: \"rgba(0,0,0,0)\"\r\n\t                });\r\n\t            }\r\n\t            this.dragSelectRect.model.set(\"options.position\", FlowUtil.truncPosition(this.dragSelectRect.position));\r\n\t            this.dragSelectRect.model.set(\"options.shape\", this.dragSelectRect.shape);\r\n\t            // this.stepCounter();\r\n\t        }.bind(this);\r\n\t        this._zr.on('mouseup', endDragHandler);\r\n\t        this._zr.on(\"globalout\", endDragHandler);\r\n\t    }\r\n\t\r\n\t    fishTopoProto._groupDragHandler = function (x, y) {\r\n\t        // flow中最外层的group移动操作\r\n\t        var nowGroupPosition = this.group.position;\r\n\t        var groupPositionX = this.group.position[0];\r\n\t        var groupPositionY = this.group.position[1];\r\n\t\r\n\t        var moveHandler = function (event) {\r\n\t            var width = this.group.getBoundingRect().width * this.nowZoom;\r\n\t            var height = this.group.getBoundingRect().height * this.nowZoom;\r\n\t            var gx = this.group.getBoundingRect().x * this.nowZoom;\r\n\t            var gy = this.group.getBoundingRect().y * this.nowZoom;\r\n\t            var min = [10 - (width + gx), 10 - (height + gy)];\r\n\t            var max = [(this._zr.getWidth() - gx) - 10, (this._zr.getHeight() - gy) - 10];\r\n\t            var sX = event.offsetX - x;\r\n\t            var sY = event.offsetY - y;\r\n\t            nowGroupPosition[0] = groupPositionX + sX;\r\n\t            nowGroupPosition[1] = groupPositionY + sY;\r\n\t            if (nowGroupPosition[0] > max[0] || nowGroupPosition[1] > max[1] || nowGroupPosition[0] <\r\n\t                min[0] || nowGroupPosition[1] < min[1]) {\r\n\t                return;\r\n\t            } else {\r\n\t                this.group.attr(\"position\", nowGroupPosition);\r\n\t                if (this.eagleEye == true) {\r\n\t                    this.minimap.updataSelectionPosition(nowGroupPosition, this.nowZoom);\r\n\t                }\r\n\t            }\r\n\t        }.bind(this);\r\n\t        this._zr.on('mousemove', moveHandler);\r\n\t\r\n\t        var endDragHandler = function () {\r\n\t            this._zr.off('mousemove', moveHandler);\r\n\t            this._zr.off('mouseup', endDragHandler);\r\n\t            this._zr.off(\"globalout\", endDragHandler);\r\n\t        }.bind(this);\r\n\t        this._zr.on('mouseup', endDragHandler);\r\n\t        this._zr.on(\"globalout\", endDragHandler);\r\n\t    };\r\n\t\r\n\t    fishTopoProto.initScale = function () {\r\n\t        var groupMaxWidth = this.group.getBoundingRect().width;\r\n\t        var groupMaxHeight = this.group.getBoundingRect().height;\r\n\t        var rangeWidth = this.getWidth();\r\n\t        var rangeHeight = this.getHeight();\r\n\t        var initRatio = 1,\r\n\t            pos = [];\r\n\t        if (groupMaxWidth / groupMaxHeight > rangeWidth / rangeHeight) {\r\n\t            if (groupMaxWidth > rangeWidth) {\r\n\t                initRatio = rangeWidth / groupMaxWidth;\r\n\t            }\r\n\t        } else {\r\n\t            if (groupMaxHeight > rangeHeight) {\r\n\t                initRatio = rangeHeight / groupMaxHeight;\r\n\t            }\r\n\t        }\r\n\t        pos[0] = Math.abs(this.group.getBoundingRect().x) * initRatio;\r\n\t        pos[1] = Math.abs(this.group.getBoundingRect().y) * initRatio;\r\n\t        this.group.attr(\"position\", [pos[0], pos[1]]);\r\n\t        this.group.attr(\"scale\", [initRatio, initRatio]);\r\n\t        this.initScaleRatio = initRatio;\r\n\t        var distance = [pos[0], pos[1], this.initScaleRatio, groupMaxWidth, groupMaxHeight];\r\n\t        return distance;\r\n\t    };\r\n\t\r\n\t\t/**\r\n\t\t * 画布元素在水平方向和垂直方向居中\r\n\t     * @param  {Object} boundPos 其中需传入的属性分别为minX,minY,maxX,maxY包围画布上所有节点的最小边框的最小的x坐标、y坐标、最大的x坐标、y坐标\r\n\t\t */\r\n\t\tfishTopoProto.zrCenter = function (boundPos) {\r\n\t        var boundObj;\r\n\t        var nowGroupPosition = this.group.position;\r\n\t        if (zrUtil.isArray(boundPos)) {\r\n\t            boundObj = zrUtil.extend({}, {minX: boundPos[0], minY: boundPos[1], maxX: boundPos[2], maxY: boundPos[3]});\r\n\t        } else {\r\n\t            boundObj = zrUtil.extend({}, boundPos);\r\n\t        }\r\n\t        nowGroupPosition[0] = this._zr.dom.offsetWidth/2 - (boundObj.minX + ((boundObj.maxX - boundObj.minX)/2));\r\n\t        nowGroupPosition[1] = this._zr.dom.offsetHeight/2 - (boundObj.minY + ((boundObj.maxY - boundObj.minY)/2));\r\n\t        this.group.attr(\"position\", nowGroupPosition);\r\n\t    };\r\n\t\r\n\t    fishTopoProto.stepCounter = function() {\r\n\t        this.stepJson.splice(this.step, this.stepJson.length - (this.step));\r\n\t        this.step += 1;\r\n\t        var json = this.toJson();\r\n\t        this.stepJson.push(JSON.stringify(json));\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 放大或者缩小\r\n\t     * @param  {String|Number} type 当为字符串时 \"enlarge\"放大  \"narrowing\"缩小  当为数值时 缩放的比例  建议0.3-1.7\r\n\t     */\r\n\t    fishTopoProto.zrScale = function (type) {\r\n\t        if (type) {\r\n\t            var zoomDelta = 0;\r\n\t            if (type == \"narrowing\") {\r\n\t                zoomDelta = -0.07;\r\n\t                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n\t            }\r\n\t            if (type == \"enlarge\") {\r\n\t                zoomDelta = 0.07;\r\n\t                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n\t            }\r\n\t            if (!isNaN(type)) {\r\n\t                var target = this.group;\r\n\t                if (target) {\r\n\t                    var zoomScale = type / target.scale[0];\r\n\t                    this._zoom = type;\r\n\t                    this.nowZoom = type;\r\n\t                    this.setScale(this._zr.getWidth() / 2, this._zr.getHeight() / 2,zoomScale);\r\n\t                }\r\n\t            }\r\n\t        } else {\r\n\t            this._zr.on('mousewheel', zrUtil.bind(function (e) {\r\n\t                eventTool.stop(e.event);\r\n\t                var zoomDelta = e.wheelDelta > 0 ? 0.07 : -0.07;\r\n\t                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n\t            }, this));\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto.zoom = function (zoomDelta, zoomX, zoomY) {\r\n\t        if (this.canScale == false) {\r\n\t            return;\r\n\t        }\r\n\t        var target = this.group;\r\n\t        if (target) {\r\n\t\r\n\t            var newZoom = this._zoom = this._zoom || 1;\r\n\t            newZoom += zoomDelta;\r\n\t\r\n\t            newZoom = Number(newZoom.toFixed(2));\r\n\t            var zoomScale = newZoom / this._zoom;\r\n\t            if (newZoom > this.options.maxScale || newZoom < this.options.minScale) {\r\n\t                return;\r\n\t            }\r\n\t            this._zoom = newZoom;\r\n\t\r\n\t            this.nowZoom = newZoom;\r\n\t\r\n\t            this.setScale(zoomX, zoomY, zoomScale);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto.setScale = function (zoomX, zoomY, zoomScale) {\r\n\t        var target = this.group;\r\n\t        var pos = target.position;\r\n\t        var scale = target.scale;\r\n\t        // Keep the mouse center when scaling\r\n\t        pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);\r\n\t        pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);\r\n\t        scale[0] *= zoomScale;\r\n\t        scale[1] *= zoomScale;\r\n\t        target.attr(\"position\", [pos[0], pos[1]]);\r\n\t        target.attr(\"scale\", [scale[0], scale[1]]);\r\n\t        if (this.eagleEye == true) {\r\n\t            this.minimap.updataSelection(pos[0], pos[1], zoomScale, this.nowZoom);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 鹰眼图\r\n\t     * @param  {HTMLElement} eagleEyeNode 显示鹰眼图的div元素\r\n\t     */\r\n\t    fishTopoProto.openEagleEye = function (eagleEyeNode) {\r\n\t        this.eagleEye = true;\r\n\t        this.eagleEyeNode = eagleEyeNode;\r\n\t        var groupPosition = zrUtil.clone(this.group.position);\r\n\t        var groupScale = zrUtil.clone(this.group.scale);\r\n\t        this.group.attr(\"position\", [0, 0]);\r\n\t        this.group.attr(\"scale\", [1, 1]);\r\n\t        var distance = this.initScale();\r\n\t        var imgSrc = this.toDataURL();\r\n\t        this.group.attr(\"position\", groupPosition);\r\n\t        this.group.attr(\"scale\", groupScale);\r\n\t        if (this.minimap) {\r\n\t            this.minimap.updataMap(imgSrc, this.group.getBoundingRect());\r\n\t        } else {\r\n\t            this.minimap = new Minimap(this, this.group.position, this.group.getBoundingRect(),\r\n\t                eagleEyeNode, distance, imgSrc);\r\n\t            setTimeout(zrUtil.bind(function () {\r\n\t                this.openEagleEye(this.eagleEyeNode)\r\n\t            }, this), 10);\r\n\t        }\r\n\t        this.minimap.selection.addEventListener(\"mousedown\", function (e) {\r\n\t            var startX = e.clientX;\r\n\t            var startY = e.clientY;\r\n\t            var minimapLeft = Number(this.minimap.selection.style.left.substring(0, this.minimap.selection\r\n\t                .style.left.length - 2));\r\n\t            var minimapTop = Number(this.minimap.selection.style.top.substring(0, this.minimap.selection\r\n\t                .style.top.length - 2));\r\n\t            var eagleEyeMove = function (e) {\r\n\t                var offsetX = e.clientX - startX;\r\n\t                var offsetY = e.clientY - startY;\r\n\t                this.minimap.selection.style.left = minimapLeft + offsetX + \"px\";\r\n\t                this.minimap.selection.style.top = minimapTop + offsetY + \"px\";\r\n\t                this.minimap.updataGroupPosition(this.group, this.nowZoom);\r\n\t            }.bind(this);\r\n\t\r\n\t            this.minimap.selection.addEventListener(\"mousemove\", eagleEyeMove);\r\n\t\r\n\t            var eagleEyeUp = function () {\r\n\t                this.minimap.selection.removeEventListener(\"mousemove\", eagleEyeMove);\r\n\t                this.minimap.selection.removeEventListener(\"mouseup\", eagleEyeUp);\r\n\t            }.bind(this);\r\n\t            this.minimap.selection.addEventListener(\"mouseup\", eagleEyeUp);\r\n\t        }.bind(this))\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 根据节点位置变化更新组边框的大小\r\n\t     * @param {Object} node 节点\r\n\t     * @since V2.3.0\r\n\t     */\r\n\t    fishTopoProto.refreshGroupByNode = function (node) {//#181\r\n\t        if (Flow.isInGroup(node)) {\r\n\t            //放入node现有数值，用于重绘group\r\n\t            var nodeMessage = {\r\n\t                width: node.shape.width,\r\n\t                height: node.shape.height,\r\n\t                position: node.position,\r\n\t                isMove: 0,\r\n\t                node: node\r\n\t            };\r\n\t            node.parent.modifyGroupRect(nodeMessage);\r\n\t        }\r\n\t        this.connectionManager.refreshLineByNode(node);\r\n\t        if (Flow.isGroupNode(node)) {\r\n\t            node.each(function (childNode) {\r\n\t                this.connectionManager.refreshLineByNode(childNode);\r\n\t            }.bind(this));\r\n\t        }\r\n\t    };\r\n\t\r\n\t    zrUtil.mixin(FishTopoFlow, Eventful);\r\n\t\r\n\t    // ---------对外暴露fishTopoFlow------------------\r\n\t    var idBase = new Date() - 0;\r\n\t    var instances = {};\r\n\t    var DOM_ATTRIBUTE_KEY = '_fishTopoFlow_instance_';\r\n\t\r\n\t    /**\r\n\t     * fishTopoFlow全局对象，如果是amd方式加载，则直接返回\r\n\t     * @class fishTopoFlow\r\n\t     * @singleton\r\n\t     *\r\n\t     * **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *      var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t     */\r\n\t    var fishTopoFlow = {\r\n\t        /**\r\n\t         * 版本号\r\n\t         * @type {String}\r\n\t         */\r\n\t        version: '3.0.0',\r\n\t        dependencies: {\r\n\t            zrender: '3.6.3'\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 初始化dom元素为 flow对象\r\n\t     * @member fishTopoFlow\r\n\t     * @param {HTMLElement} dom  一个div元素\r\n\t     * @param {Object} opts  传递的选项参数\r\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg' or 'vml'\r\n\t     * @param {number} [opts.devicePixelRatio=1] retina 屏幕优化\r\n\t     * @param {boolean} [opts.linkModify=false] 是否允许调整线段\r\n\t     * @param {boolean} [opts.textEditable=false] 是否允许双击节点编辑文字\r\n\t     * @param {boolean} [opts.mouseMode='default'] 设置鼠标在画布上的操作模式，默认为'default'：无任何操作，设为'drag-move'：平移漫游，设为'drag-select'：框选节点\r\n\t     * @param {boolean} [opts.roam=true] 是否开启鼠标缩放。默认开启，设为false表示关闭缩放功能。\r\n\t     * @param {Object} [opts.tooltip] tooltip配置项\r\n\t     * @param {boolean} [opts.tooltip.show] tooltip配置项:控制tooltip是否显示\r\n\t     * @param {boolean} [opts.isAnimationEnabled=true] 是否开启动画,默认为true\r\n\t     * @param {boolean} [opts.scaleable=false] 是否允许缩放,默认为false\r\n\t     * @param {boolean} [opts.rotatable=false] 是否允许旋转,默认为false\r\n\t     * @param {Function} [opts.beforeDelete] 删除节点或边线 之前的回调，如果返回false则不进行后续的删除操作\r\n\t     * @param {Object} [opts.beforeCreate] 创建节点或边线 之前的回调，如果返回false则不进行后续的删除操作\r\n\t     * @return {fish.topo.FishTopoFlow}\r\n\t     */\r\n\t    fishTopoFlow.init = function (dom, opts) {\r\n\t        if (!dom) {\r\n\t            throw new Error('Initialize failed: invalid dom.');\r\n\t        }\r\n\t\r\n\t        opts = opts || {};\r\n\t        // Default value\r\n\t        zrUtil.defaults(opts, {\r\n\t            type: \"flow\",\r\n\t            linkModify: false,\r\n\t            textEditable: false,\r\n\t            roam: true,\r\n\t            mouseMode: 'default',\r\n\t            tooltip: {\r\n\t                show:true\r\n\t            },  //覆盖tooltipModel\r\n\t            isAnimationEnabled: true,\r\n\t            scaleable: false,\r\n\t            rotatable: false,\r\n\t            beforeDelete: null,  // 删除之前的事件\r\n\t            beforeCreate:null,   //创建节点或连线之前的事件\r\n\t            maxScale: 1.7,       //画布放大的最大比例\r\n\t            minScale: 0.3        //画布缩小的最小比例\r\n\t        });\r\n\t\r\n\t        var fishTopoFlow = new FishTopoFlow(dom, opts);\r\n\t        fishTopoFlow.init();\r\n\t        fishTopoFlow.Flow = Flow;\r\n\t        fishTopoFlow.id = 'ft_' + idBase++;\r\n\t        instances[fishTopoFlow.id] = fishTopoFlow;\r\n\t\r\n\t        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoFlow.id);\r\n\t\r\n\t        return fishTopoFlow;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 获取 dom 容器上的实例。\r\n\t     * @member fishTopoFlow\r\n\t     * @param  {HTMLElement} dom 一个div元素\r\n\t     * @return {fish.topo.FishTopoFlow}\r\n\t     */\r\n\t    fishTopoFlow.getInstanceByDom = function (dom) {\r\n\t        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\r\n\t        return instances[key];\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 销毁实例，实例销毁后无法再被使用。\r\n\t     *\r\n\t     * @member fishTopoFlow\r\n\t     * @param  {Object|string} chart fishTopoBpmn实例 或 fishTopoBpmn的id\r\n\t     */\r\n\t    fishTopoFlow.dispose = function (chart) {\r\n\t        var topo;\r\n\t        if (zrUtil.isDom(chart)) {\r\n\t            topo = fishTopoFlow.getInstanceByDom(chart);\r\n\t        } else if (typeof chart === 'string') {\r\n\t            topo = instances[chart];\r\n\t        }\r\n\t        if ((topo instanceof fishTopoFlow) && !topo.isDisposed()) {\r\n\t            topo.dispose();\r\n\t        }\r\n\t    };\r\n\t\r\n\t    //暴露出去的类\r\n\t    fishTopoFlow.graphic = graphic;\r\n\t    fishTopoFlow.node = FlowUtil.registerFlowNode(flowNode);\r\n\t    fishTopoFlow.link = flowLink;\r\n\t\r\n\t    fishTopoFlow.layout = layout;\r\n\t    fishTopoFlow.Flow = Flow;\r\n\t    fishTopoFlow.constants = Constants;\r\n\t    fishTopoFlow.util = util;\r\n\t    fishTopoFlow.util['initImagePool'] = ImagePool.initImagePool;\r\n\t    zrUtil.each([\r\n\t            'map', 'each', 'filter', 'indexOf', 'inherits',\r\n\t            'reduce', 'filter', 'bind', 'curry', 'isArray',\r\n\t            'isString', 'isObject', 'isFunction', 'extend',\r\n\t            'merge', \"mergeAll\"\r\n\t        ],\r\n\t        function (name) {\r\n\t            fishTopoFlow.util[name] = zrUtil[name];\r\n\t        }\r\n\t    );\r\n\t\r\n\t    module.exports = fishTopoFlow;\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n\t\r\n\t    //polyfill bind\r\n\t    if (!Function.prototype.bind) {\r\n\t        Function.prototype.bind = function(oThis) {\r\n\t            if (typeof this !== \"function\") {\r\n\t                // closest thing possible to the ECMAScript 5 internal IsCallable function\r\n\t                throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\r\n\t            }\r\n\t\r\n\t            var aArgs = Array.prototype.slice.call(arguments, 1),\r\n\t                fToBind = this,\r\n\t                fNOP = function() {},\r\n\t                fBound = function() {\r\n\t                    return fToBind.apply(this instanceof fNOP && oThis ? this : oThis || window,\r\n\t                        aArgs.concat(Array.prototype.slice.call(arguments)));\r\n\t                };\r\n\t\r\n\t            fNOP.prototype = this.prototype;\r\n\t            fBound.prototype = new fNOP();\r\n\t\r\n\t            return fBound;\r\n\t        };\r\n\t    }\r\n\t\r\n\t    //polyfill remove\r\n\t    if (!('remove' in Element.prototype)) {\r\n\t        Element.prototype.remove = function() {\r\n\t            if (this.parentNode) {\r\n\t                this.parentNode.removeChild(this);\r\n\t            }\r\n\t        };\r\n\t    }\r\n\t\r\n\t    if (!String.prototype.endsWith) {\r\n\t    String.prototype.endsWith = function(searchString, position) {\r\n\t        var subjectString = this.toString();\r\n\t        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {\r\n\t            position = subjectString.length;\r\n\t        }\r\n\t        position -= searchString.length;\r\n\t        var lastIndex = subjectString.indexOf(searchString, position);\r\n\t        return lastIndex !== -1 && lastIndex === position;\r\n\t    };\r\n\t    }\r\n\t\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t\r\n\t    var pathTool = __webpack_require__(6);\r\n\t    var round = Math.round;\r\n\t    var Path = __webpack_require__(7);\r\n\t    var colorTool = __webpack_require__(20);\r\n\t    var matrix = __webpack_require__(14);\r\n\t    var vector = __webpack_require__(15);\r\n\t    var Gradient = __webpack_require__(42);\r\n\t    var Draggable = __webpack_require__(43);\r\n\t\r\n\t    var graphic = {};\r\n\t    graphic.Util = zrUtil;\r\n\t    graphic.Group = __webpack_require__(44);\r\n\t\r\n\t    graphic.Image = __webpack_require__(45);\r\n\t\r\n\t    graphic.Text = __webpack_require__(46);\r\n\t\r\n\t    graphic.textContain = __webpack_require__(26);\r\n\t\r\n\t    graphic.Circle = __webpack_require__(47);\r\n\t\r\n\t    graphic.Sector = __webpack_require__(48);\r\n\t\r\n\t    graphic.Ring = __webpack_require__(51);\r\n\t\r\n\t    graphic.Polygon = __webpack_require__(52);\r\n\t\r\n\t    graphic.Polyline = __webpack_require__(56);\r\n\t\r\n\t    graphic.Rect = __webpack_require__(57);\r\n\t\r\n\t    graphic.Line = __webpack_require__(58);\r\n\t\r\n\t    graphic.BezierCurve = __webpack_require__(59);\r\n\t\r\n\t    graphic.Arc = __webpack_require__(60);\r\n\t\r\n\t    graphic.LinearGradient = __webpack_require__(61);\r\n\t\r\n\t    graphic.RadialGradient = __webpack_require__(62);\r\n\t\r\n\t    graphic.BoundingRect = __webpack_require__(27);\r\n\t    graphic.States = __webpack_require__(63);\r\n\t    /**\r\n\t     * Extend shape with parameters\r\n\t     */\r\n\t    graphic.extendShape = function (opts) {\r\n\t        return Path.extend(opts);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Extend path\r\n\t     */\r\n\t    graphic.extendPath = function (pathData, opts) {\r\n\t        return pathTool.extendFromString(pathData, opts);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Create a path element from path data string\r\n\t     * @param {string} pathData\r\n\t     * @param {Object} opts\r\n\t     * @param {module:zrender/core/BoundingRect} rect\r\n\t     * @param {string} [layout=cover] 'center' or 'cover'\r\n\t     */\r\n\t    graphic.makePath = function (pathData, opts, rect, layout) {\r\n\t        var path = pathTool.createFromString(pathData, opts);\r\n\t        Draggable.call(path);\r\n\t        var boundingRect = path.getBoundingRect();\r\n\t        if (rect) {\r\n\t            var aspect = boundingRect.width / boundingRect.height;\r\n\t\r\n\t            if (layout === 'center') {\r\n\t                // Set rect to center, keep width / height ratio.\r\n\t                var width = rect.height * aspect;\r\n\t                var height;\r\n\t                if (width <= rect.width) {\r\n\t                    height = rect.height;\r\n\t                }\r\n\t                else {\r\n\t                    width = rect.width;\r\n\t                    height = width / aspect;\r\n\t                }\r\n\t                var cx = rect.x + rect.width / 2;\r\n\t                var cy = rect.y + rect.height / 2;\r\n\t\r\n\t                rect.x = cx - width / 2;\r\n\t                rect.y = cy - height / 2;\r\n\t                rect.width = width;\r\n\t                rect.height = height;\r\n\t            }\r\n\t\r\n\t            this.resizePath(path, rect);\r\n\t        }\r\n\t\r\n\t        zrUtil.inherits(path, Draggable);\r\n\t        return path;\r\n\t    };\r\n\t\r\n\t    graphic.mergePath = pathTool.mergePath;\r\n\t\r\n\t    /**\r\n\t     * Resize a path to fit the rect\r\n\t     * @param {module:zrender/graphic/Path} path\r\n\t     * @param {Object} rect\r\n\t     */\r\n\t    graphic.resizePath = function (path, rect) {\r\n\t        if (!path.applyTransform) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var pathRect = path.getBoundingRect();\r\n\t\r\n\t        var m = pathRect.calculateTransform(rect);\r\n\t\r\n\t        path.applyTransform(m);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize line for canvas\r\n\t     *\r\n\t     * @param {Object} param\r\n\t     * @param {Object} [param.shape]\r\n\t     * @param {number} [param.shape.x1]\r\n\t     * @param {number} [param.shape.y1]\r\n\t     * @param {number} [param.shape.x2]\r\n\t     * @param {number} [param.shape.y2]\r\n\t     * @param {Object} [param.style]\r\n\t     * @param {number} [param.style.lineWidth]\r\n\t     * @return {Object} Modified param\r\n\t     */\r\n\t    graphic.subPixelOptimizeLine = function (param) {\r\n\t        var subPixelOptimize = graphic.subPixelOptimize;\r\n\t        var shape = param.shape;\r\n\t        var lineWidth = param.style.lineWidth;\r\n\t\r\n\t        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\r\n\t            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\r\n\t        }\r\n\t        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\r\n\t            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\r\n\t        }\r\n\t        return param;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize rect for canvas\r\n\t     *\r\n\t     * @param {Object} param\r\n\t     * @param {Object} [param.shape]\r\n\t     * @param {number} [param.shape.x]\r\n\t     * @param {number} [param.shape.y]\r\n\t     * @param {number} [param.shape.width]\r\n\t     * @param {number} [param.shape.height]\r\n\t     * @param {Object} [param.style]\r\n\t     * @param {number} [param.style.lineWidth]\r\n\t     * @return {Object} Modified param\r\n\t     */\r\n\t    graphic.subPixelOptimizeRect = function (param) {\r\n\t        var subPixelOptimize = graphic.subPixelOptimize;\r\n\t        var shape = param.shape;\r\n\t        var lineWidth = param.style.lineWidth;\r\n\t        var originX = shape.x;\r\n\t        var originY = shape.y;\r\n\t        var originWidth = shape.width;\r\n\t        var originHeight = shape.height;\r\n\t        shape.x = subPixelOptimize(shape.x, lineWidth, true);\r\n\t        shape.y = subPixelOptimize(shape.y, lineWidth, true);\r\n\t        shape.width = Math.max(\r\n\t            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\r\n\t            originWidth === 0 ? 0 : 1\r\n\t        );\r\n\t        shape.height = Math.max(\r\n\t            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\r\n\t            originHeight === 0 ? 0 : 1\r\n\t        );\r\n\t        return param;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize for canvas\r\n\t     *\r\n\t     * @param {number} position Coordinate, such as x, y\r\n\t     * @param {number} lineWidth Should be nonnegative integer.\r\n\t     * @param {boolean=} positiveOrNegative Default false (negative).\r\n\t     * @return {number} Optimized position.\r\n\t     */\r\n\t    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\r\n\t        // Assure that (position + lineWidth / 2) is near integer edge,\r\n\t        // otherwise line will be fuzzy in canvas.\r\n\t        var doubledPosition = round(position * 2);\r\n\t        return (doubledPosition + round(lineWidth)) % 2 === 0\r\n\t            ? doubledPosition / 2\r\n\t            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    function doSingleEnterHover(el) {\r\n\t        if (el.__isHover) {\r\n\t            return;\r\n\t        }\r\n\t        if (el.__hoverStlDirty) {\r\n\t            var stroke = el.style.stroke;\r\n\t            var fill = el.style.fill;\r\n\t\r\n\t            // Create hoverStyle on mouseover\r\n\t            var hoverStyle = el.__hoverStl;\r\n\t            var lift = colorTool.lift;\r\n\t            hoverStyle.fill = hoverStyle.fill\r\n\t                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));\r\n\t            hoverStyle.stroke = hoverStyle.stroke\r\n\t                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));\r\n\t\r\n\t            var normalStyle = {};\r\n\t            for (var name in hoverStyle) {\r\n\t                if (hoverStyle.hasOwnProperty(name)) {\r\n\t                    normalStyle[name] = el.style[name];\r\n\t                }\r\n\t            }\r\n\t\r\n\t            el.__normalStl = normalStyle;\r\n\t\r\n\t            el.__hoverStlDirty = false;\r\n\t        }\r\n\t        el.setStyle(el.__hoverStl);\r\n\t        el.z2 += 1;\r\n\t\r\n\t        el.__isHover = true;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function doSingleLeaveHover(el) {\r\n\t        if (!el.__isHover) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var normalStl = el.__normalStl;\r\n\t        normalStl && el.setStyle(normalStl);\r\n\t        el.z2 -= 1;\r\n\t\r\n\t        el.__isHover = false;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function doEnterHover(el) {\r\n\t        (el.type === 'group' || el.type === 'GroupNode')\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    doSingleEnterHover(child);\r\n\t                }\r\n\t            })\r\n\t            : doSingleEnterHover(el);\r\n\t    }\r\n\t    graphic.doEnterHover = doEnterHover;\r\n\t    function doLeaveHover(el) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    doSingleLeaveHover(child);\r\n\t                }\r\n\t            })\r\n\t            : doSingleLeaveHover(el);\r\n\t    }\r\n\t    graphic.doLeaveHover = doLeaveHover;\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function setElementHoverStl(el, hoverStl) {\r\n\t        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\r\n\t        // Often used when item group has a label element and it's hoverStyle is different\r\n\t        el.__hoverStl = el.hoverStyle || hoverStl || {};\r\n\t        el.__hoverStlDirty = true;\r\n\t    }\r\n\t    graphic.setElementHoverStl = setElementHoverStl;\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function onElementMouseOver() {\r\n\t        // Only if element is not in emphasis status\r\n\t        !this.__isEmphasis && doEnterHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function onElementMouseOut() {\r\n\t        // Only if element is not in emphasis status\r\n\t        !this.__isEmphasis && doLeaveHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function enterEmphasis() {\r\n\t        this.__isEmphasis = true;\r\n\t        doEnterHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function leaveEmphasis() {\r\n\t        this.__isEmphasis = false;\r\n\t        doLeaveHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Set hover style of element\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} [hoverStyle]\r\n\t     */\r\n\t    graphic.setHoverStyle = function (el, hoverStyle) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    setElementHoverStl(child, hoverStyle);\r\n\t                }\r\n\t            })\r\n\t            : setElementHoverStl(el, hoverStyle);\r\n\t        // Remove previous bound handlers\r\n\t        el.on('mouseover', onElementMouseOver)\r\n\t          .on('mouseout', onElementMouseOut);\r\n\t\r\n\t        // Emphasis, normal can be triggered manually\r\n\t        el.on('emphasis', enterEmphasis)\r\n\t          .on('normal', leaveEmphasis);\r\n\t    };\r\n\t\r\n\t    graphic.setNormalStyle = function(el, options) {\r\n\t        if (el.__normalStl) {\r\n\t            for (var name in options) {\r\n\t                if (el.__normalStl.hasOwnProperty(name)) {\r\n\t                    el.__normalStl[name] = options[name];\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Set text option in the style\r\n\t     * @param {Object} textStyle\r\n\t     * @param {module:echarts/model/Model} labelModel\r\n\t     * @param {string} color\r\n\t     */\r\n\t    graphic.setText = function (textStyle, labelModel, color) {\r\n\t        var labelPosition = labelModel.getShallow('position') || 'inside';\r\n\t        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\r\n\t        var textStyleModel = labelModel.getModel('textStyle');\r\n\t        zrUtil.extend(textStyle, {\r\n\t            textDistance: labelModel.getShallow('distance') || 5,\r\n\t            textFont: textStyleModel.getFont(),\r\n\t            textPosition: labelPosition,\r\n\t            textFill: textStyleModel.getTextColor() || labelColor\r\n\t        });\r\n\t    };\r\n\t\r\n\t    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {\r\n\t        var postfix = isUpdate ? 'Update' : '';\r\n\t        var duration = animatableModel\r\n\t            && animatableModel.getShallow('animationDuration' + postfix);\r\n\t        var animationEasing = animatableModel\r\n\t            && animatableModel.getShallow('animationEasing' + postfix);\r\n\t\r\n\t        animatableModel && animatableModel.getShallow('animation')\r\n\t            ? el.animateTo(props, duration, animationEasing, cb)\r\n\t            : (el.attr(props), cb && cb());\r\n\t    }\r\n\t    /**\r\n\t     * Update graphic element properties with or without animation according to the configuration in series\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} props\r\n\t     * @param {module:echarts/model/Model} [animatableModel]\r\n\t     * @param {Function} cb\r\n\t     */\r\n\t    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);\r\n\t\r\n\t    /**\r\n\t     * Init graphic element properties with or without animation according to the configuration in series\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} props\r\n\t     * @param {module:echarts/model/Model} [animatableModel]\r\n\t     * @param {Function} cb\r\n\t     */\r\n\t    graphic.initProps = zrUtil.curry(animateOrSetProps, false);\r\n\t\r\n\t    /**\r\n\t     * Get transform matrix of target (param target),\r\n\t     * in coordinate of its ancestor (param ancestor)\r\n\t     *\r\n\t     * @param {module:zrender/mixin/Transformable} target\r\n\t     * @param {module:zrender/mixin/Transformable} ancestor\r\n\t     */\r\n\t    graphic.getTransform = function (target, ancestor) {\r\n\t        var mat = matrix.identity([]);\r\n\t\r\n\t        while (target && target !== ancestor) {\r\n\t            matrix.mul(mat, target.getLocalTransform(), mat);\r\n\t            target = target.parent;\r\n\t        }\r\n\t\r\n\t        return mat;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Apply transform to an vertex.\r\n\t     * @param {Array.<number>} vertex [x, y]\r\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n\t     * @param {boolean=} invert Whether use invert matrix.\r\n\t     * @return {Array.<number>} [x, y]\r\n\t     */\r\n\t    graphic.applyTransform = function (vertex, transform, invert) {\r\n\t        if (invert) {\r\n\t            transform = matrix.invert([], transform);\r\n\t        }\r\n\t        return vector.applyTransform([], vertex, transform);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @param {string} direction 'left' 'right' 'top' 'bottom'\r\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n\t     * @param {boolean=} invert Whether use invert matrix.\r\n\t     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\r\n\t     */\r\n\t    graphic.transformDirection = function (direction, transform, invert) {\r\n\t\r\n\t        // Pick a base, ensure that transform result will not be (0, 0).\r\n\t        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\r\n\t            ? 1 : Math.abs(2 * transform[4] / transform[0]);\r\n\t        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\r\n\t            ? 1 : Math.abs(2 * transform[4] / transform[2]);\r\n\t\r\n\t        var vertex = [\r\n\t            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\r\n\t            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\r\n\t        ];\r\n\t\r\n\t        vertex = graphic.applyTransform(vertex, transform, invert);\r\n\t\r\n\t        return Math.abs(vertex[0]) > Math.abs(vertex[1])\r\n\t            ? (vertex[0] > 0 ? 'right' : 'left')\r\n\t            : (vertex[1] > 0 ? 'bottom' : 'top');\r\n\t    };\r\n\t\r\n\t    module.exports = graphic;\r\n\t\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * @module zrender/core/util\n\t */\n\t// 用于处理merge时无法遍历Date等对象的问题\n\tvar BUILTIN_OBJECT = {\n\t  '[object Function]': 1,\n\t  '[object RegExp]': 1,\n\t  '[object Date]': 1,\n\t  '[object Error]': 1,\n\t  '[object CanvasGradient]': 1,\n\t  '[object CanvasPattern]': 1,\n\t  // For node-canvas\n\t  '[object Image]': 1,\n\t  '[object Canvas]': 1\n\t};\n\tvar TYPED_ARRAY = {\n\t  '[object Int8Array]': 1,\n\t  '[object Uint8Array]': 1,\n\t  '[object Uint8ClampedArray]': 1,\n\t  '[object Int16Array]': 1,\n\t  '[object Uint16Array]': 1,\n\t  '[object Int32Array]': 1,\n\t  '[object Uint32Array]': 1,\n\t  '[object Float32Array]': 1,\n\t  '[object Float64Array]': 1\n\t};\n\tvar objToString = Object.prototype.toString;\n\tvar arrayProto = Array.prototype;\n\tvar nativeForEach = arrayProto.forEach;\n\tvar nativeFilter = arrayProto.filter;\n\tvar nativeSlice = arrayProto.slice;\n\tvar nativeMap = arrayProto.map;\n\tvar nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.\n\t\n\tvar methods = {};\n\t\n\tfunction $override(name, fn) {\n\t  methods[name] = fn;\n\t}\n\t/**\n\t * Those data types can be cloned:\n\t *     Plain object, Array, TypedArray, number, string, null, undefined.\n\t * Those data types will be assgined using the orginal data:\n\t *     BUILTIN_OBJECT\n\t * Instance of user defined class will be cloned to a plain object, without\n\t * properties in prototype.\n\t * Other data types is not supported (not sure what will happen).\n\t *\n\t * Caution: do not support clone Date, for performance consideration.\n\t * (There might be a large number of date in `series.data`).\n\t * So date should not be modified in and out of echarts.\n\t *\n\t * @param {*} source\n\t * @return {*} new\n\t */\n\t\n\t\n\tfunction clone(source) {\n\t  if (source == null || typeof source != 'object') {\n\t    return source;\n\t  }\n\t\n\t  var result = source;\n\t  var typeStr = objToString.call(source);\n\t\n\t  if (typeStr === '[object Array]') {\n\t    result = [];\n\t\n\t    for (var i = 0, len = source.length; i < len; i++) {\n\t      result[i] = clone(source[i]);\n\t    }\n\t  } else if (TYPED_ARRAY[typeStr]) {\n\t    var Ctor = source.constructor;\n\t\n\t    if (source.constructor.from) {\n\t      result = Ctor.from(source);\n\t    } else {\n\t      result = new Ctor(source.length);\n\t\n\t      for (var i = 0, len = source.length; i < len; i++) {\n\t        result[i] = clone(source[i]);\n\t      }\n\t    }\n\t  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n\t    result = {};\n\t\n\t    for (var key in source) {\n\t      if (source.hasOwnProperty(key)) {\n\t        result[key] = clone(source[key]);\n\t      }\n\t    }\n\t  }\n\t\n\t  return result;\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} target\n\t * @param {*} source\n\t * @param {boolean} [overwrite=false]\n\t */\n\t\n\t\n\tfunction merge(target, source, overwrite) {\n\t  // We should escapse that source is string\n\t  // and enter for ... in ...\n\t  if (!isObject(source) || !isObject(target)) {\n\t    return overwrite ? clone(source) : target;\n\t  }\n\t\n\t  for (var key in source) {\n\t    if (source.hasOwnProperty(key)) {\n\t      var targetProp = target[key];\n\t      var sourceProp = source[key];\n\t\n\t      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {\n\t        // 如果需要递归覆盖，就递归调用merge\n\t        merge(targetProp, sourceProp, overwrite);\n\t      } else if (overwrite || !(key in target)) {\n\t        // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n\t        // NOTE，在 target[key] 不存在的时候也是直接覆盖\n\t        target[key] = clone(source[key], true);\n\t      }\n\t    }\n\t  }\n\t\n\t  return target;\n\t}\n\t/**\n\t * @param {Array} targetAndSources The first item is target, and the rests are source.\n\t * @param {boolean} [overwrite=false]\n\t * @return {*} target\n\t */\n\t\n\t\n\tfunction mergeAll(targetAndSources, overwrite) {\n\t  var result = targetAndSources[0];\n\t\n\t  for (var i = 1, len = targetAndSources.length; i < len; i++) {\n\t    result = merge(result, targetAndSources[i], overwrite);\n\t  }\n\t\n\t  return result;\n\t}\n\t/**\n\t * @param {*} target\n\t * @param {*} source\n\t * @memberOf module:zrender/core/util\n\t */\n\t\n\t\n\tfunction extend(target, source) {\n\t  for (var key in source) {\n\t    if (source.hasOwnProperty(key)) {\n\t      target[key] = source[key];\n\t    }\n\t  }\n\t\n\t  return target;\n\t}\n\t/**\n\t * @param {*} target\n\t * @param {*} source\n\t * @param {boolean} [overlay=false]\n\t * @memberOf module:zrender/core/util\n\t */\n\t\n\t\n\tfunction defaults(target, source, overlay) {\n\t  for (var key in source) {\n\t    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {\n\t      target[key] = source[key];\n\t    }\n\t  }\n\t\n\t  return target;\n\t}\n\t\n\tvar createCanvas = function () {\n\t  return methods.createCanvas();\n\t};\n\t\n\tmethods.createCanvas = function () {\n\t  return document.createElement('canvas');\n\t}; // FIXME\n\t\n\t\n\tvar _ctx;\n\t\n\tfunction getContext() {\n\t  if (!_ctx) {\n\t    // Use util.createCanvas instead of createCanvas\n\t    // because createCanvas may be overwritten in different environment\n\t    _ctx = createCanvas().getContext('2d');\n\t  }\n\t\n\t  return _ctx;\n\t}\n\t/**\n\t * 查询数组中元素的index\n\t * @memberOf module:zrender/core/util\n\t */\n\t\n\t\n\tfunction indexOf(array, value) {\n\t  if (array) {\n\t    if (array.indexOf) {\n\t      return array.indexOf(value);\n\t    }\n\t\n\t    for (var i = 0, len = array.length; i < len; i++) {\n\t      if (array[i] === value) {\n\t        return i;\n\t      }\n\t    }\n\t  }\n\t\n\t  return -1;\n\t}\n\t/**\n\t * 构造类继承关系\n\t *\n\t * @memberOf module:zrender/core/util\n\t * @param {Function} clazz 源类\n\t * @param {Function} baseClazz 基类\n\t */\n\t\n\t\n\tfunction inherits(clazz, baseClazz) {\n\t  var clazzPrototype = clazz.prototype;\n\t\n\t  function F() {}\n\t\n\t  F.prototype = baseClazz.prototype;\n\t  clazz.prototype = new F();\n\t\n\t  for (var prop in clazzPrototype) {\n\t    clazz.prototype[prop] = clazzPrototype[prop];\n\t  }\n\t\n\t  clazz.prototype.constructor = clazz;\n\t  clazz.superClass = baseClazz;\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {Object|Function} target\n\t * @param {Object|Function} sorce\n\t * @param {boolean} overlay\n\t */\n\t\n\t\n\tfunction mixin(target, source, overlay) {\n\t  target = 'prototype' in target ? target.prototype : target;\n\t  source = 'prototype' in source ? source.prototype : source;\n\t  defaults(target, source, overlay);\n\t}\n\t/**\n\t * Consider typed array.\n\t * @param {Array|TypedArray} data\n\t */\n\t\n\t\n\tfunction isArrayLike(data) {\n\t  if (!data) {\n\t    return;\n\t  }\n\t\n\t  if (typeof data == 'string') {\n\t    return false;\n\t  }\n\t\n\t  return typeof data.length == 'number';\n\t}\n\t/**\n\t * 数组或对象遍历\n\t * @memberOf module:zrender/core/util\n\t * @param {Object|Array} obj\n\t * @param {Function} cb\n\t * @param {*} [context]\n\t */\n\t\n\t\n\tfunction each(obj, cb, context) {\n\t  if (!(obj && cb)) {\n\t    return;\n\t  }\n\t\n\t  if (obj.forEach && obj.forEach === nativeForEach) {\n\t    obj.forEach(cb, context);\n\t  } else if (obj.length === +obj.length) {\n\t    for (var i = 0, len = obj.length; i < len; i++) {\n\t      cb.call(context, obj[i], i, obj);\n\t    }\n\t  } else {\n\t    for (var key in obj) {\n\t      if (obj.hasOwnProperty(key)) {\n\t        cb.call(context, obj[key], key, obj);\n\t      }\n\t    }\n\t  }\n\t}\n\t/**\n\t * 数组映射\n\t * @memberOf module:zrender/core/util\n\t * @param {Array} obj\n\t * @param {Function} cb\n\t * @param {*} [context]\n\t * @return {Array}\n\t */\n\t\n\t\n\tfunction map(obj, cb, context) {\n\t  if (!(obj && cb)) {\n\t    return;\n\t  }\n\t\n\t  if (obj.map && obj.map === nativeMap) {\n\t    return obj.map(cb, context);\n\t  } else {\n\t    var result = [];\n\t\n\t    for (var i = 0, len = obj.length; i < len; i++) {\n\t      result.push(cb.call(context, obj[i], i, obj));\n\t    }\n\t\n\t    return result;\n\t  }\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {Array} obj\n\t * @param {Function} cb\n\t * @param {Object} [memo]\n\t * @param {*} [context]\n\t * @return {Array}\n\t */\n\t\n\t\n\tfunction reduce(obj, cb, memo, context) {\n\t  if (!(obj && cb)) {\n\t    return;\n\t  }\n\t\n\t  if (obj.reduce && obj.reduce === nativeReduce) {\n\t    return obj.reduce(cb, memo, context);\n\t  } else {\n\t    for (var i = 0, len = obj.length; i < len; i++) {\n\t      memo = cb.call(context, memo, obj[i], i, obj);\n\t    }\n\t\n\t    return memo;\n\t  }\n\t}\n\t/**\n\t * 数组过滤\n\t * @memberOf module:zrender/core/util\n\t * @param {Array} obj\n\t * @param {Function} cb\n\t * @param {*} [context]\n\t * @return {Array}\n\t */\n\t\n\t\n\tfunction filter(obj, cb, context) {\n\t  if (!(obj && cb)) {\n\t    return;\n\t  }\n\t\n\t  if (obj.filter && obj.filter === nativeFilter) {\n\t    return obj.filter(cb, context);\n\t  } else {\n\t    var result = [];\n\t\n\t    for (var i = 0, len = obj.length; i < len; i++) {\n\t      if (cb.call(context, obj[i], i, obj)) {\n\t        result.push(obj[i]);\n\t      }\n\t    }\n\t\n\t    return result;\n\t  }\n\t}\n\t/**\n\t * 数组项查找\n\t * @memberOf module:zrender/core/util\n\t * @param {Array} obj\n\t * @param {Function} cb\n\t * @param {*} [context]\n\t * @return {*}\n\t */\n\t\n\t\n\tfunction find(obj, cb, context) {\n\t  if (!(obj && cb)) {\n\t    return;\n\t  }\n\t\n\t  for (var i = 0, len = obj.length; i < len; i++) {\n\t    if (cb.call(context, obj[i], i, obj)) {\n\t      return obj[i];\n\t    }\n\t  }\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {Function} func\n\t * @param {*} context\n\t * @return {Function}\n\t */\n\t\n\t\n\tfunction bind(func, context) {\n\t  var args = nativeSlice.call(arguments, 2);\n\t  return function () {\n\t    return func.apply(context, args.concat(nativeSlice.call(arguments)));\n\t  };\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {Function} func\n\t * @return {Function}\n\t */\n\t\n\t\n\tfunction curry(func) {\n\t  var args = nativeSlice.call(arguments, 1);\n\t  return function () {\n\t    return func.apply(this, args.concat(nativeSlice.call(arguments)));\n\t  };\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isArray(value) {\n\t  return objToString.call(value) === '[object Array]';\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isFunction(value) {\n\t  return typeof value === 'function';\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isString(value) {\n\t  return objToString.call(value) === '[object String]';\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isObject(value) {\n\t  // Avoid a V8 JIT bug in Chrome 19-20.\n\t  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t  var type = typeof value;\n\t  return type === 'function' || !!value && type == 'object';\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isBuiltInObject(value) {\n\t  return !!BUILTIN_OBJECT[objToString.call(value)];\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isDom(value) {\n\t  return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';\n\t}\n\t/**\n\t * Whether is exactly NaN. Notice isNaN('a') returns true.\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction eqNaN(value) {\n\t  return value !== value;\n\t}\n\t/**\n\t * If value1 is not null, then return value1, otherwise judget rest of values.\n\t * Low performance.\n\t * @memberOf module:zrender/core/util\n\t * @return {*} Final value\n\t */\n\t\n\t\n\tfunction retrieve(values) {\n\t  for (var i = 0, len = arguments.length; i < len; i++) {\n\t    if (arguments[i] != null) {\n\t      return arguments[i];\n\t    }\n\t  }\n\t}\n\t\n\tfunction retrieve2(value0, value1) {\n\t  return value0 != null ? value0 : value1;\n\t}\n\t\n\tfunction retrieve3(value0, value1, value2) {\n\t  return value0 != null ? value0 : value1 != null ? value1 : value2;\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {Array} arr\n\t * @param {number} startIndex\n\t * @param {number} endIndex\n\t * @return {Array}\n\t */\n\t\n\t\n\tfunction slice() {\n\t  return Function.call.apply(nativeSlice, arguments);\n\t}\n\t/**\n\t * Normalize css liked array configuration\n\t * e.g.\n\t *  3 => [3, 3, 3, 3]\n\t *  [4, 2] => [4, 2, 4, 2]\n\t *  [4, 3, 2] => [4, 3, 2, 3]\n\t * @param {number|Array.<number>} val\n\t * @return {Array.<number>}\n\t */\n\t\n\t\n\tfunction normalizeCssArray(val) {\n\t  if (typeof val === 'number') {\n\t    return [val, val, val, val];\n\t  }\n\t\n\t  var len = val.length;\n\t\n\t  if (len === 2) {\n\t    // vertical | horizontal\n\t    return [val[0], val[1], val[0], val[1]];\n\t  } else if (len === 3) {\n\t    // top | horizontal | bottom\n\t    return [val[0], val[1], val[2], val[1]];\n\t  }\n\t\n\t  return val;\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {boolean} condition\n\t * @param {string} message\n\t */\n\t\n\t\n\tfunction assert(condition, message) {\n\t  if (!condition) {\n\t    throw new Error(message);\n\t  }\n\t}\n\t\n\tvar primitiveKey = '__ec_primitive__';\n\t/**\n\t * Set an object as primitive to be ignored traversing children in clone or merge\n\t */\n\t\n\tfunction setAsPrimitive(obj) {\n\t  obj[primitiveKey] = true;\n\t}\n\t\n\tfunction isPrimitive(obj) {\n\t  return obj[primitiveKey];\n\t}\n\t/**\n\t * @constructor\n\t * @param {Object} obj Only apply `ownProperty`.\n\t */\n\t\n\t\n\tfunction HashMap(obj) {\n\t  obj && each(obj, function (value, key) {\n\t    this.set(key, value);\n\t  }, this);\n\t} // Add prefix to avoid conflict with Object.prototype.\n\t\n\t\n\tvar HASH_MAP_PREFIX = '_ec_';\n\tvar HASH_MAP_PREFIX_LENGTH = 4;\n\tHashMap.prototype = {\n\t  constructor: HashMap,\n\t  // Do not provide `has` method to avoid defining what is `has`.\n\t  // (We usually treat `null` and `undefined` as the same, different\n\t  // from ES6 Map).\n\t  get: function (key) {\n\t    return this[HASH_MAP_PREFIX + key];\n\t  },\n\t  set: function (key, value) {\n\t    this[HASH_MAP_PREFIX + key] = value; // Comparing with invocation chaining, `return value` is more commonly\n\t    // used in this case: `var someVal = map.set('a', genVal());`\n\t\n\t    return value;\n\t  },\n\t  // Although util.each can be performed on this hashMap directly, user\n\t  // should not use the exposed keys, who are prefixed.\n\t  each: function (cb, context) {\n\t    context !== void 0 && (cb = bind(cb, context));\n\t\n\t    for (var prefixedKey in this) {\n\t      this.hasOwnProperty(prefixedKey) && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n\t    }\n\t  },\n\t  // Do not use this method if performance sensitive.\n\t  removeKey: function (key) {\n\t    delete this[HASH_MAP_PREFIX + key];\n\t  }\n\t};\n\t\n\tfunction createHashMap(obj) {\n\t  return new HashMap(obj);\n\t}\n\t\n\tfunction noop() {}\n\t\n\texports.$override = $override;\n\texports.clone = clone;\n\texports.merge = merge;\n\texports.mergeAll = mergeAll;\n\texports.extend = extend;\n\texports.defaults = defaults;\n\texports.createCanvas = createCanvas;\n\texports.getContext = getContext;\n\texports.indexOf = indexOf;\n\texports.inherits = inherits;\n\texports.mixin = mixin;\n\texports.isArrayLike = isArrayLike;\n\texports.each = each;\n\texports.map = map;\n\texports.reduce = reduce;\n\texports.filter = filter;\n\texports.find = find;\n\texports.bind = bind;\n\texports.curry = curry;\n\texports.isArray = isArray;\n\texports.isFunction = isFunction;\n\texports.isString = isString;\n\texports.isObject = isObject;\n\texports.isBuiltInObject = isBuiltInObject;\n\texports.isDom = isDom;\n\texports.eqNaN = eqNaN;\n\texports.retrieve = retrieve;\n\texports.retrieve2 = retrieve2;\n\texports.retrieve3 = retrieve3;\n\texports.slice = slice;\n\texports.normalizeCssArray = normalizeCssArray;\n\texports.assert = assert;\n\texports.setAsPrimitive = setAsPrimitive;\n\texports.isPrimitive = isPrimitive;\n\texports.createHashMap = createHashMap;\n\texports.noop = noop;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(7);\n\t\n\tvar PathProxy = __webpack_require__(30);\n\t\n\tvar transformPath = __webpack_require__(41);\n\t\n\t// command chars\n\tvar cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];\n\tvar mathSqrt = Math.sqrt;\n\tvar mathSin = Math.sin;\n\tvar mathCos = Math.cos;\n\tvar PI = Math.PI;\n\t\n\tvar vMag = function (v) {\n\t  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n\t};\n\t\n\tvar vRatio = function (u, v) {\n\t  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n\t};\n\t\n\tvar vAngle = function (u, v) {\n\t  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n\t};\n\t\n\tfunction processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n\t  var psi = psiDeg * (PI / 180.0);\n\t  var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;\n\t  var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;\n\t  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n\t\n\t  if (lambda > 1) {\n\t    rx *= mathSqrt(lambda);\n\t    ry *= mathSqrt(lambda);\n\t  }\n\t\n\t  var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;\n\t  var cxp = f * rx * yp / ry;\n\t  var cyp = f * -ry * xp / rx;\n\t  var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;\n\t  var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;\n\t  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);\n\t  var u = [(xp - cxp) / rx, (yp - cyp) / ry];\n\t  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\n\t  var dTheta = vAngle(u, v);\n\t\n\t  if (vRatio(u, v) <= -1) {\n\t    dTheta = PI;\n\t  }\n\t\n\t  if (vRatio(u, v) >= 1) {\n\t    dTheta = 0;\n\t  }\n\t\n\t  if (fs === 0 && dTheta > 0) {\n\t    dTheta = dTheta - 2 * PI;\n\t  }\n\t\n\t  if (fs === 1 && dTheta < 0) {\n\t    dTheta = dTheta + 2 * PI;\n\t  }\n\t\n\t  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n\t}\n\t\n\tfunction createPathProxyFromString(data) {\n\t  if (!data) {\n\t    return [];\n\t  } // command string\n\t\n\t\n\t  var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');\n\t  var n; // create pipes so that we can split the data\n\t\n\t  for (n = 0; n < cc.length; n++) {\n\t    cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n\t  } // create array\n\t\n\t\n\t  var arr = cs.split('|'); // init context point\n\t\n\t  var cpx = 0;\n\t  var cpy = 0;\n\t  var path = new PathProxy();\n\t  var CMD = PathProxy.CMD;\n\t  var prevCmd;\n\t\n\t  for (n = 1; n < arr.length; n++) {\n\t    var str = arr[n];\n\t    var c = str.charAt(0);\n\t    var off = 0;\n\t    var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n\t    var cmd;\n\t\n\t    if (p.length > 0 && p[0] === '') {\n\t      p.shift();\n\t    }\n\t\n\t    for (var i = 0; i < p.length; i++) {\n\t      p[i] = parseFloat(p[i]);\n\t    }\n\t\n\t    while (off < p.length && !isNaN(p[off])) {\n\t      if (isNaN(p[0])) {\n\t        break;\n\t      }\n\t\n\t      var ctlPtx;\n\t      var ctlPty;\n\t      var rx;\n\t      var ry;\n\t      var psi;\n\t      var fa;\n\t      var fs;\n\t      var x1 = cpx;\n\t      var y1 = cpy; // convert l, H, h, V, and v to L\n\t\n\t      switch (c) {\n\t        case 'l':\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'L':\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'm':\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          cmd = CMD.M;\n\t          path.addData(cmd, cpx, cpy);\n\t          c = 'l';\n\t          break;\n\t\n\t        case 'M':\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          cmd = CMD.M;\n\t          path.addData(cmd, cpx, cpy);\n\t          c = 'L';\n\t          break;\n\t\n\t        case 'h':\n\t          cpx += p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'H':\n\t          cpx = p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'v':\n\t          cpy += p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'V':\n\t          cpy = p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'C':\n\t          cmd = CMD.C;\n\t          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);\n\t          cpx = p[off - 2];\n\t          cpy = p[off - 1];\n\t          break;\n\t\n\t        case 'c':\n\t          cmd = CMD.C;\n\t          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);\n\t          cpx += p[off - 2];\n\t          cpy += p[off - 1];\n\t          break;\n\t\n\t        case 'S':\n\t          ctlPtx = cpx;\n\t          ctlPty = cpy;\n\t          var len = path.len();\n\t          var pathData = path.data;\n\t\n\t          if (prevCmd === CMD.C) {\n\t            ctlPtx += cpx - pathData[len - 4];\n\t            ctlPty += cpy - pathData[len - 3];\n\t          }\n\t\n\t          cmd = CMD.C;\n\t          x1 = p[off++];\n\t          y1 = p[off++];\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t          break;\n\t\n\t        case 's':\n\t          ctlPtx = cpx;\n\t          ctlPty = cpy;\n\t          var len = path.len();\n\t          var pathData = path.data;\n\t\n\t          if (prevCmd === CMD.C) {\n\t            ctlPtx += cpx - pathData[len - 4];\n\t            ctlPty += cpy - pathData[len - 3];\n\t          }\n\t\n\t          cmd = CMD.C;\n\t          x1 = cpx + p[off++];\n\t          y1 = cpy + p[off++];\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t          break;\n\t\n\t        case 'Q':\n\t          x1 = p[off++];\n\t          y1 = p[off++];\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          cmd = CMD.Q;\n\t          path.addData(cmd, x1, y1, cpx, cpy);\n\t          break;\n\t\n\t        case 'q':\n\t          x1 = p[off++] + cpx;\n\t          y1 = p[off++] + cpy;\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          cmd = CMD.Q;\n\t          path.addData(cmd, x1, y1, cpx, cpy);\n\t          break;\n\t\n\t        case 'T':\n\t          ctlPtx = cpx;\n\t          ctlPty = cpy;\n\t          var len = path.len();\n\t          var pathData = path.data;\n\t\n\t          if (prevCmd === CMD.Q) {\n\t            ctlPtx += cpx - pathData[len - 4];\n\t            ctlPty += cpy - pathData[len - 3];\n\t          }\n\t\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          cmd = CMD.Q;\n\t          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t          break;\n\t\n\t        case 't':\n\t          ctlPtx = cpx;\n\t          ctlPty = cpy;\n\t          var len = path.len();\n\t          var pathData = path.data;\n\t\n\t          if (prevCmd === CMD.Q) {\n\t            ctlPtx += cpx - pathData[len - 4];\n\t            ctlPty += cpy - pathData[len - 3];\n\t          }\n\t\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          cmd = CMD.Q;\n\t          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t          break;\n\t\n\t        case 'A':\n\t          rx = p[off++];\n\t          ry = p[off++];\n\t          psi = p[off++];\n\t          fa = p[off++];\n\t          fs = p[off++];\n\t          x1 = cpx, y1 = cpy;\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          cmd = CMD.A;\n\t          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n\t          break;\n\t\n\t        case 'a':\n\t          rx = p[off++];\n\t          ry = p[off++];\n\t          psi = p[off++];\n\t          fa = p[off++];\n\t          fs = p[off++];\n\t          x1 = cpx, y1 = cpy;\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          cmd = CMD.A;\n\t          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n\t          break;\n\t      }\n\t    }\n\t\n\t    if (c === 'z' || c === 'Z') {\n\t      cmd = CMD.Z;\n\t      path.addData(cmd);\n\t    }\n\t\n\t    prevCmd = cmd;\n\t  }\n\t\n\t  path.toStatic();\n\t  return path;\n\t} // TODO Optimize double memory cost problem\n\t\n\t\n\tfunction createPathOptions(str, opts) {\n\t  var pathProxy = createPathProxyFromString(str);\n\t  opts = opts || {};\n\t\n\t  opts.buildPath = function (path) {\n\t    if (path.setData) {\n\t      path.setData(pathProxy.data); // Svg and vml renderer don't have context\n\t\n\t      var ctx = path.getContext();\n\t\n\t      if (ctx) {\n\t        path.rebuildPath(ctx);\n\t      }\n\t    } else {\n\t      var ctx = path;\n\t      pathProxy.rebuildPath(ctx);\n\t    }\n\t  };\n\t\n\t  opts.applyTransform = function (m) {\n\t    transformPath(pathProxy, m);\n\t    this.dirty(true);\n\t  };\n\t\n\t  return opts;\n\t}\n\t/**\n\t * Create a Path object from path string data\n\t * http://www.w3.org/TR/SVG/paths.html#PathData\n\t * @param  {Object} opts Other options\n\t */\n\t\n\t\n\tfunction createFromString(str, opts) {\n\t  return new Path(createPathOptions(str, opts));\n\t}\n\t/**\n\t * Create a Path class from path string data\n\t * @param  {string} str\n\t * @param  {Object} opts Other options\n\t */\n\t\n\t\n\tfunction extendFromString(str, opts) {\n\t  return Path.extend(createPathOptions(str, opts));\n\t}\n\t/**\n\t * Merge multiple paths\n\t */\n\t// TODO Apply transform\n\t// TODO stroke dash\n\t// TODO Optimize double memory cost problem\n\t\n\t\n\tfunction mergePath(pathEls, opts) {\n\t  var pathList = [];\n\t  var len = pathEls.length;\n\t\n\t  for (var i = 0; i < len; i++) {\n\t    var pathEl = pathEls[i];\n\t\n\t    if (!pathEl.path) {\n\t      pathEl.createPathProxy();\n\t    }\n\t\n\t    if (pathEl.__dirtyPath) {\n\t      pathEl.buildPath(pathEl.path, pathEl.shape, true);\n\t    }\n\t\n\t    pathList.push(pathEl.path);\n\t  }\n\t\n\t  var pathBundle = new Path(opts); // Need path proxy.\n\t\n\t  pathBundle.createPathProxy();\n\t\n\t  pathBundle.buildPath = function (path) {\n\t    path.appendPath(pathList); // Svg and vml renderer don't have context\n\t\n\t    var ctx = path.getContext();\n\t\n\t    if (ctx) {\n\t      path.rebuildPath(ctx);\n\t    }\n\t  };\n\t\n\t  return pathBundle;\n\t}\n\t\n\texports.createFromString = createFromString;\n\texports.extendFromString = extendFromString;\n\texports.mergePath = mergePath;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Displayable = __webpack_require__(8);\n\t\n\tvar zrUtil = __webpack_require__(5);\n\t\n\tvar PathProxy = __webpack_require__(30);\n\t\n\tvar pathContain = __webpack_require__(33);\n\t\n\tvar Pattern = __webpack_require__(40);\n\t\n\tvar getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\tvar abs = Math.abs;\n\tvar pathProxyForDraw = new PathProxy(true);\n\t/**\n\t * @alias module:zrender/graphic/Path\n\t * @extends module:zrender/graphic/Displayable\n\t * @constructor\n\t * @param {Object} opts\n\t */\n\t\n\tfunction Path(opts) {\n\t  Displayable.call(this, opts);\n\t  /**\n\t   * @type {module:zrender/core/PathProxy}\n\t   * @readOnly\n\t   */\n\t\n\t  this.path = null;\n\t}\n\t\n\tPath.prototype = {\n\t  constructor: Path,\n\t  type: 'path',\n\t  __dirtyPath: true,\n\t  strokeContainThreshold: 5,\n\t  brush: function (ctx, prevEl) {\n\t    var style = this.style;\n\t    var path = this.path || pathProxyForDraw;\n\t    var hasStroke = style.hasStroke();\n\t    var hasFill = style.hasFill();\n\t    var fill = style.fill;\n\t    var stroke = style.stroke;\n\t    var hasFillGradient = hasFill && !!fill.colorStops;\n\t    var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n\t    var hasFillPattern = hasFill && !!fill.image;\n\t    var hasStrokePattern = hasStroke && !!stroke.image;\n\t    style.bind(ctx, this, prevEl);\n\t    this.setTransform(ctx);\n\t\n\t    if (this.__dirty) {\n\t      var rect; // Update gradient because bounding rect may changed\n\t\n\t      if (hasFillGradient) {\n\t        rect = rect || this.getBoundingRect();\n\t        this._fillGradient = style.getGradient(ctx, fill, rect);\n\t      }\n\t\n\t      if (hasStrokeGradient) {\n\t        rect = rect || this.getBoundingRect();\n\t        this._strokeGradient = style.getGradient(ctx, stroke, rect);\n\t      }\n\t    } // Use the gradient or pattern\n\t\n\t\n\t    if (hasFillGradient) {\n\t      // PENDING If may have affect the state\n\t      ctx.fillStyle = this._fillGradient;\n\t    } else if (hasFillPattern) {\n\t      ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n\t    }\n\t\n\t    if (hasStrokeGradient) {\n\t      ctx.strokeStyle = this._strokeGradient;\n\t    } else if (hasStrokePattern) {\n\t      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n\t    }\n\t\n\t    var lineDash = style.lineDash;\n\t    var lineDashOffset = style.lineDashOffset;\n\t    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy\n\t\n\t    var scale = this.getGlobalScale();\n\t    path.setScale(scale[0], scale[1]); // Proxy context\n\t    // Rebuild path in following 2 cases\n\t    // 1. Path is dirty\n\t    // 2. Path needs javascript implemented lineDash stroking.\n\t    //    In this case, lineDash information will not be saved in PathProxy\n\t\n\t    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n\t      path.beginPath(ctx); // Setting line dash before build path\n\t\n\t      if (lineDash && !ctxLineDash) {\n\t        path.setLineDash(lineDash);\n\t        path.setLineDashOffset(lineDashOffset);\n\t      }\n\t\n\t      this.buildPath(path, this.shape, false); // Clear path dirty flag\n\t\n\t      if (this.path) {\n\t        this.__dirtyPath = false;\n\t      }\n\t    } else {\n\t      // Replay path building\n\t      ctx.beginPath();\n\t      this.path.rebuildPath(ctx);\n\t    }\n\t\n\t    hasFill && path.fill(ctx);\n\t\n\t    if (lineDash && ctxLineDash) {\n\t      ctx.setLineDash(lineDash);\n\t      ctx.lineDashOffset = lineDashOffset;\n\t    }\n\t\n\t    hasStroke && path.stroke(ctx);\n\t\n\t    if (lineDash && ctxLineDash) {\n\t      // PENDING\n\t      // Remove lineDash\n\t      ctx.setLineDash([]);\n\t    }\n\t\n\t    this.restoreTransform(ctx); // Draw rect text\n\t\n\t    if (style.text != null) {\n\t      this.drawRectText(ctx, this.getBoundingRect());\n\t    }\n\t  },\n\t  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n\t  // Like in circle\n\t  buildPath: function (ctx, shapeCfg, inBundle) {},\n\t  createPathProxy: function () {\n\t    this.path = new PathProxy();\n\t  },\n\t  getBoundingRect: function () {\n\t    var rect = this._rect;\n\t    var style = this.style;\n\t    var needsUpdateRect = !rect;\n\t\n\t    if (needsUpdateRect) {\n\t      var path = this.path;\n\t\n\t      if (!path) {\n\t        // Create path on demand.\n\t        path = this.path = new PathProxy();\n\t      }\n\t\n\t      if (this.__dirtyPath) {\n\t        path.beginPath();\n\t        this.buildPath(path, this.shape, false);\n\t      }\n\t\n\t      rect = path.getBoundingRect();\n\t    }\n\t\n\t    this._rect = rect;\n\t\n\t    if (style.hasStroke()) {\n\t      // Needs update rect with stroke lineWidth when\n\t      // 1. Element changes scale or lineWidth\n\t      // 2. Shape is changed\n\t      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\t\n\t      if (this.__dirty || needsUpdateRect) {\n\t        rectWithStroke.copy(rect); // FIXME Must after updateTransform\n\t\n\t        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical\n\t\n\t        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill\n\t\n\t        if (!style.hasFill()) {\n\t          w = Math.max(w, this.strokeContainThreshold || 4);\n\t        } // Consider line width\n\t        // Line scale can't be 0;\n\t\n\t\n\t        if (lineScale > 1e-10) {\n\t          rectWithStroke.width += w / lineScale;\n\t          rectWithStroke.height += w / lineScale;\n\t          rectWithStroke.x -= w / lineScale / 2;\n\t          rectWithStroke.y -= w / lineScale / 2;\n\t        }\n\t      } // Return rect with stroke\n\t\n\t\n\t      return rectWithStroke;\n\t    }\n\t\n\t    return rect;\n\t  },\n\t  contain: function (x, y) {\n\t    var localPos = this.transformCoordToLocal(x, y);\n\t    var rect = this.getBoundingRect();\n\t    var style = this.style;\n\t    x = localPos[0];\n\t    y = localPos[1];\n\t\n\t    if (rect.contain(x, y)) {\n\t      var pathData = this.path.data;\n\t\n\t      if (style.hasStroke()) {\n\t        var lineWidth = style.lineWidth;\n\t        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;\n\t\n\t        if (lineScale > 1e-10) {\n\t          // Only add extra hover lineWidth when there are no fill\n\t          if (!style.hasFill()) {\n\t            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n\t          }\n\t\n\t          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n\t            return true;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (style.hasFill()) {\n\t        return pathContain.contain(pathData, x, y);\n\t      }\n\t    }\n\t\n\t    return false;\n\t  },\n\t\n\t  /**\n\t   * @param  {boolean} dirtyPath\n\t   */\n\t  dirty: function (dirtyPath) {\n\t    if (dirtyPath == null) {\n\t      dirtyPath = true;\n\t    } // Only mark dirty, not mark clean\n\t\n\t\n\t    if (dirtyPath) {\n\t      this.__dirtyPath = dirtyPath;\n\t      this._rect = null;\n\t    }\n\t\n\t    this.__dirty = true;\n\t    this.__zr && this.__zr.refresh(); // Used as a clipping path\n\t\n\t    if (this.__clipTarget) {\n\t      this.__clipTarget.dirty();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Alias for animate('shape')\n\t   * @param {boolean} loop\n\t   */\n\t  animateShape: function (loop) {\n\t    return this.animate('shape', loop);\n\t  },\n\t  // Overwrite attrKV\n\t  attrKV: function (key, value) {\n\t    // FIXME\n\t    if (key === 'shape') {\n\t      this.setShape(value);\n\t      this.__dirtyPath = true;\n\t      this._rect = null;\n\t    } else {\n\t      Displayable.prototype.attrKV.call(this, key, value);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @param {Object|string} key\n\t   * @param {*} value\n\t   */\n\t  setShape: function (key, value) {\n\t    var shape = this.shape; // Path from string may not have shape\n\t\n\t    if (shape) {\n\t      if (zrUtil.isObject(key)) {\n\t        for (var name in key) {\n\t          if (key.hasOwnProperty(name)) {\n\t            shape[name] = key[name];\n\t          }\n\t        }\n\t      } else {\n\t        shape[key] = value;\n\t      }\n\t\n\t      this.dirty(true);\n\t    }\n\t\n\t    return this;\n\t  },\n\t  getLineScale: function () {\n\t    var m = this.transform; // Get the line scale.\n\t    // Determinant of `m` means how much the area is enlarged by the\n\t    // transformation. So its square root can be used as a scale factor\n\t    // for width.\n\t\n\t    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n\t  }\n\t};\n\t/**\n\t * 扩展一个 Path element, 比如星形，圆等。\n\t * Extend a path element\n\t * @param {Object} props\n\t * @param {string} props.type Path type\n\t * @param {Function} props.init Initialize\n\t * @param {Function} props.buildPath Overwrite buildPath method\n\t * @param {Object} [props.style] Extended default style config\n\t * @param {Object} [props.shape] Extended default shape config\n\t */\n\t\n\tPath.extend = function (defaults) {\n\t  var Sub = function (opts) {\n\t    Path.call(this, opts);\n\t\n\t    if (defaults.style) {\n\t      // Extend default style\n\t      this.style.extendFrom(defaults.style, false);\n\t    } // Extend default shape\n\t\n\t\n\t    var defaultShape = defaults.shape;\n\t\n\t    if (defaultShape) {\n\t      this.shape = this.shape || {};\n\t      var thisShape = this.shape;\n\t\n\t      for (var name in defaultShape) {\n\t        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n\t          thisShape[name] = defaultShape[name];\n\t        }\n\t      }\n\t    }\n\t\n\t    defaults.init && defaults.init.call(this, opts);\n\t  };\n\t\n\t  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象\n\t\n\t  for (var name in defaults) {\n\t    // Extending prototype values and methods\n\t    if (name !== 'style' && name !== 'shape') {\n\t      Sub.prototype[name] = defaults[name];\n\t    }\n\t  }\n\t\n\t  return Sub;\n\t};\n\t\n\tzrUtil.inherits(Path, Displayable);\n\tvar _default = Path;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrUtil = __webpack_require__(5);\n\t\n\tvar Style = __webpack_require__(9);\n\t\n\tvar Element = __webpack_require__(10);\n\t\n\tvar RectText = __webpack_require__(24);\n\t\n\t/**\n\t * 可绘制的图形基类\n\t * Base class of all displayable graphic objects\n\t * @module zrender/graphic/Displayable\n\t */\n\t\n\t/**\n\t * @alias module:zrender/graphic/Displayable\n\t * @extends module:zrender/Element\n\t * @extends module:zrender/graphic/mixin/RectText\n\t */\n\tfunction Displayable(opts) {\n\t  opts = opts || {};\n\t  Element.call(this, opts); // Extend properties\n\t\n\t  for (var name in opts) {\n\t    if (opts.hasOwnProperty(name) && name !== 'style') {\n\t      this[name] = opts[name];\n\t    }\n\t  }\n\t  /**\n\t   * @type {module:zrender/graphic/Style}\n\t   */\n\t\n\t\n\t  this.style = new Style(opts.style, this);\n\t  this._rect = null; // Shapes for cascade clipping.\n\t\n\t  this.__clipPaths = []; // FIXME Stateful must be mixined after style is setted\n\t  // Stateful.call(this, opts);\n\t}\n\t\n\tDisplayable.prototype = {\n\t  constructor: Displayable,\n\t  type: 'displayable',\n\t\n\t  /**\n\t   * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制\n\t   * Dirty flag. From which painter will determine if this displayable object needs brush\n\t   * @name module:zrender/graphic/Displayable#__dirty\n\t   * @type {boolean}\n\t   */\n\t  __dirty: true,\n\t\n\t  /**\n\t   * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\n\t   * If ignore drawing of the displayable object. Mouse event will still be triggered\n\t   * @name module:/zrender/graphic/Displayable#invisible\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  invisible: false,\n\t\n\t  /**\n\t   * @name module:/zrender/graphic/Displayable#z\n\t   * @type {number}\n\t   * @default 0\n\t   */\n\t  z: 0,\n\t\n\t  /**\n\t   * @name module:/zrender/graphic/Displayable#z\n\t   * @type {number}\n\t   * @default 0\n\t   */\n\t  z2: 0,\n\t\n\t  /**\n\t   * z层level，决定绘画在哪层canvas中\n\t   * @name module:/zrender/graphic/Displayable#zlevel\n\t   * @type {number}\n\t   * @default 0\n\t   */\n\t  zlevel: 0,\n\t\n\t  /**\n\t   * 是否可拖拽\n\t   * @name module:/zrender/graphic/Displayable#draggable\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  draggable: false,\n\t\n\t  /**\n\t   * 是否正在拖拽\n\t   * @name module:/zrender/graphic/Displayable#draggable\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  dragging: false,\n\t\n\t  /**\n\t   * 是否相应鼠标事件\n\t   * @name module:/zrender/graphic/Displayable#silent\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  silent: false,\n\t\n\t  /**\n\t   * If enable culling\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  culling: false,\n\t\n\t  /**\n\t   * Mouse cursor when hovered\n\t   * @name module:/zrender/graphic/Displayable#cursor\n\t   * @type {string}\n\t   */\n\t  cursor: 'pointer',\n\t\n\t  /**\n\t   * If hover area is bounding rect\n\t   * @name module:/zrender/graphic/Displayable#rectHover\n\t   * @type {string}\n\t   */\n\t  rectHover: false,\n\t\n\t  /**\n\t   * Render the element progressively when the value >= 0,\n\t   * usefull for large data.\n\t   * @type {number}\n\t   */\n\t  progressive: -1,\n\t  beforeBrush: function (ctx) {},\n\t  afterBrush: function (ctx) {},\n\t\n\t  /**\n\t   * 图形绘制方法\n\t   * @param {CanvasRenderingContext2D} ctx\n\t   */\n\t  // Interface\n\t  brush: function (ctx, prevEl) {},\n\t\n\t  /**\n\t   * 获取最小包围盒\n\t   * @return {module:zrender/core/BoundingRect}\n\t   */\n\t  // Interface\n\t  getBoundingRect: function () {},\n\t\n\t  /**\n\t   * 判断坐标 x, y 是否在图形上\n\t   * If displayable element contain coord x, y\n\t   * @param  {number} x\n\t   * @param  {number} y\n\t   * @return {boolean}\n\t   */\n\t  contain: function (x, y) {\n\t    return this.rectContain(x, y);\n\t  },\n\t\n\t  /**\n\t   * @param  {Function} cb\n\t   * @param  {}   context\n\t   */\n\t  traverse: function (cb, context) {\n\t    cb.call(context, this);\n\t  },\n\t\n\t  /**\n\t   * 判断坐标 x, y 是否在图形的包围盒上\n\t   * If bounding rect of element contain coord x, y\n\t   * @param  {number} x\n\t   * @param  {number} y\n\t   * @return {boolean}\n\t   */\n\t  rectContain: function (x, y) {\n\t    var coord = this.transformCoordToLocal(x, y);\n\t    var rect = this.getBoundingRect();\n\t    return rect.contain(coord[0], coord[1]);\n\t  },\n\t\n\t  /**\n\t   * 标记图形元素为脏，并且在下一帧重绘\n\t   * Mark displayable element dirty and refresh next frame\n\t   */\n\t  dirty: function () {\n\t    this.__dirty = true;\n\t    this._rect = null;\n\t    this.__zr && this.__zr.refresh();\n\t  },\n\t\n\t  /**\n\t   * 图形是否会触发事件\n\t   * If displayable object binded any event\n\t   * @return {boolean}\n\t   */\n\t  // TODO, 通过 bind 绑定的事件\n\t  // isSilent: function () {\n\t  //     return !(\n\t  //         this.hoverable || this.draggable\n\t  //         || this.onmousemove || this.onmouseover || this.onmouseout\n\t  //         || this.onmousedown || this.onmouseup || this.onclick\n\t  //         || this.ondragenter || this.ondragover || this.ondragleave\n\t  //         || this.ondrop\n\t  //     );\n\t  // },\n\t\n\t  /**\n\t   * Alias for animate('style')\n\t   * @param {boolean} loop\n\t   */\n\t  animateStyle: function (loop) {\n\t    return this.animate('style', loop);\n\t  },\n\t  attrKV: function (key, value) {\n\t    if (key !== 'style') {\n\t      Element.prototype.attrKV.call(this, key, value);\n\t    } else {\n\t      this.style.set(value);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @param {Object|string} key\n\t   * @param {*} value\n\t   */\n\t  setStyle: function (key, value) {\n\t    this.style.set(key, value);\n\t    this.dirty(false);\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * Use given style object\n\t   * @param  {Object} obj\n\t   */\n\t  useStyle: function (obj) {\n\t    this.style = new Style(obj, this);\n\t    this.dirty(false);\n\t    return this;\n\t  }\n\t};\n\tzrUtil.inherits(Displayable, Element);\n\tzrUtil.mixin(Displayable, RectText); // zrUtil.mixin(Displayable, Stateful);\n\t\n\tvar _default = Displayable;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\n\tvar STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n\t// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\t\n\tvar Style = function (opts, host) {\n\t  this.extendFrom(opts, false);\n\t  this.host = host;\n\t};\n\t\n\tfunction createLinearGradient(ctx, obj, rect) {\n\t  var x = obj.x == null ? 0 : obj.x;\n\t  var x2 = obj.x2 == null ? 1 : obj.x2;\n\t  var y = obj.y == null ? 0 : obj.y;\n\t  var y2 = obj.y2 == null ? 0 : obj.y2;\n\t\n\t  if (!obj.global) {\n\t    x = x * rect.width + rect.x;\n\t    x2 = x2 * rect.width + rect.x;\n\t    y = y * rect.height + rect.y;\n\t    y2 = y2 * rect.height + rect.y;\n\t  }\n\t\n\t  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\t  return canvasGradient;\n\t}\n\t\n\tfunction createRadialGradient(ctx, obj, rect) {\n\t  var width = rect.width;\n\t  var height = rect.height;\n\t  var min = Math.min(width, height);\n\t  var x = obj.x == null ? 0.5 : obj.x;\n\t  var y = obj.y == null ? 0.5 : obj.y;\n\t  var r = obj.r == null ? 0.5 : obj.r;\n\t\n\t  if (!obj.global) {\n\t    x = x * width + rect.x;\n\t    y = y * height + rect.y;\n\t    r = r * min;\n\t  }\n\t\n\t  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\t  return canvasGradient;\n\t}\n\t\n\tStyle.prototype = {\n\t  constructor: Style,\n\t\n\t  /**\n\t   * @type {module:zrender/graphic/Displayable}\n\t   */\n\t  host: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  fill: '#000',\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  stroke: null,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  opacity: 1,\n\t\n\t  /**\n\t   * @type {Array.<number>}\n\t   */\n\t  lineDash: null,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  lineDashOffset: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  shadowBlur: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  shadowOffsetX: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  shadowOffsetY: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  lineWidth: 1,\n\t\n\t  /**\n\t   * If stroke ignore scale\n\t   * @type {Boolean}\n\t   */\n\t  strokeNoScale: false,\n\t  // Bounding rect text configuration\n\t  // Not affected by element transform\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  text: null,\n\t\n\t  /**\n\t   * If `fontSize` or `fontFamily` exists, `font` will be reset by\n\t   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.\n\t   * So do not visit it directly in upper application (like echarts),\n\t   * but use `contain/text#makeFont` instead.\n\t   * @type {string}\n\t   */\n\t  font: null,\n\t\n\t  /**\n\t   * The same as font. Use font please.\n\t   * @deprecated\n\t   * @type {string}\n\t   */\n\t  textFont: null,\n\t\n\t  /**\n\t   * It helps merging respectively, rather than parsing an entire font string.\n\t   * @type {string}\n\t   */\n\t  fontStyle: null,\n\t\n\t  /**\n\t   * It helps merging respectively, rather than parsing an entire font string.\n\t   * @type {string}\n\t   */\n\t  fontWeight: null,\n\t\n\t  /**\n\t   * It helps merging respectively, rather than parsing an entire font string.\n\t   * Should be 12 but not '12px'.\n\t   * @type {number}\n\t   */\n\t  fontSize: null,\n\t\n\t  /**\n\t   * It helps merging respectively, rather than parsing an entire font string.\n\t   * @type {string}\n\t   */\n\t  fontFamily: null,\n\t\n\t  /**\n\t   * Reserved for special functinality, like 'hr'.\n\t   * @type {string}\n\t   */\n\t  textTag: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textFill: '#000',\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textStroke: null,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textWidth: null,\n\t\n\t  /**\n\t   * Only for textBackground.\n\t   * @type {number}\n\t   */\n\t  textHeight: null,\n\t\n\t  /**\n\t   * textStroke may be set as some color as a default\n\t   * value in upper applicaion, where the default value\n\t   * of textStrokeWidth should be 0 to make sure that\n\t   * user can choose to do not use text stroke.\n\t   * @type {number}\n\t   */\n\t  textStrokeWidth: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textLineHeight: null,\n\t\n\t  /**\n\t   * 'inside', 'left', 'right', 'top', 'bottom'\n\t   * [x, y]\n\t   * Based on x, y of rect.\n\t   * @type {string|Array.<number>}\n\t   * @default 'inside'\n\t   */\n\t  textPosition: 'inside',\n\t\n\t  /**\n\t   * If not specified, use the boundingRect of a `displayable`.\n\t   * @type {Object}\n\t   */\n\t  textRect: null,\n\t\n\t  /**\n\t   * [x, y]\n\t   * @type {Array.<number>}\n\t   */\n\t  textOffset: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textAlign: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textVerticalAlign: null,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textDistance: 5,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textShadowColor: 'transparent',\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textShadowBlur: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textShadowOffsetX: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textShadowOffsetY: 0,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textBoxShadowColor: 'transparent',\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textBoxShadowBlur: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textBoxShadowOffsetX: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textBoxShadowOffsetY: 0,\n\t\n\t  /**\n\t   * Whether transform text.\n\t   * Only useful in Path and Image element\n\t   * @type {boolean}\n\t   */\n\t  transformText: false,\n\t\n\t  /**\n\t   * Text rotate around position of Path or Image\n\t   * Only useful in Path and Image element and transformText is false.\n\t   */\n\t  textRotation: 0,\n\t\n\t  /**\n\t   * Text origin of text rotation, like [10, 40].\n\t   * Based on x, y of rect.\n\t   * Useful in label rotation of circular symbol.\n\t   * By default, this origin is textPosition.\n\t   * Can be 'center'.\n\t   * @type {string|Array.<number>}\n\t   */\n\t  textOrigin: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textBackgroundColor: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textBorderColor: null,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textBorderWidth: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textBorderRadius: 0,\n\t\n\t  /**\n\t   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`\n\t   * @type {number|Array.<number>}\n\t   */\n\t  textPadding: null,\n\t\n\t  /**\n\t   * Text styles for rich text.\n\t   * @type {Object}\n\t   */\n\t  rich: null,\n\t\n\t  /**\n\t   * {outerWidth, outerHeight, ellipsis, placeholder}\n\t   * @type {Object}\n\t   */\n\t  truncate: null,\n\t\n\t  /**\n\t   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n\t   * @type {string}\n\t   */\n\t  blend: null,\n\t\n\t  /**\n\t   * @param {CanvasRenderingContext2D} ctx\n\t   */\n\t  bind: function (ctx, el, prevEl) {\n\t    var style = this;\n\t    var prevStyle = prevEl && prevEl.style;\n\t    var firstDraw = !prevStyle;\n\t\n\t    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t      var prop = STYLE_COMMON_PROPS[i];\n\t      var styleName = prop[0];\n\t\n\t      if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n\t        // FIXME Invalid property value will cause style leak from previous element.\n\t        ctx[styleName] = style[styleName] || prop[1];\n\t      }\n\t    }\n\t\n\t    if (firstDraw || style.fill !== prevStyle.fill) {\n\t      ctx.fillStyle = style.fill;\n\t    }\n\t\n\t    if (firstDraw || style.stroke !== prevStyle.stroke) {\n\t      ctx.strokeStyle = style.stroke;\n\t    }\n\t\n\t    if (firstDraw || style.opacity !== prevStyle.opacity) {\n\t      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n\t    }\n\t\n\t    if (firstDraw || style.blend !== prevStyle.blend) {\n\t      ctx.globalCompositeOperation = style.blend || 'source-over';\n\t    }\n\t\n\t    if (this.hasStroke()) {\n\t      var lineWidth = style.lineWidth;\n\t      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);\n\t    }\n\t  },\n\t  hasFill: function () {\n\t    var fill = this.fill;\n\t    return fill != null && fill !== 'none';\n\t  },\n\t  hasStroke: function () {\n\t    var stroke = this.stroke;\n\t    return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n\t  },\n\t\n\t  /**\n\t   * Extend from other style\n\t   * @param {zrender/graphic/Style} otherStyle\n\t   * @param {boolean} overwrite true: overwrirte any way.\n\t   *                            false: overwrite only when !target.hasOwnProperty\n\t   *                            others: overwrite when property is not null/undefined.\n\t   */\n\t  extendFrom: function (otherStyle, overwrite) {\n\t    if (otherStyle) {\n\t      for (var name in otherStyle) {\n\t        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {\n\t          this[name] = otherStyle[name];\n\t        }\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Batch setting style with a given object\n\t   * @param {Object|string} obj\n\t   * @param {*} [obj]\n\t   */\n\t  set: function (obj, value) {\n\t    if (typeof obj === 'string') {\n\t      this[obj] = value;\n\t    } else {\n\t      this.extendFrom(obj, true);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Clone\n\t   * @return {zrender/graphic/Style} [description]\n\t   */\n\t  clone: function () {\n\t    var newStyle = new this.constructor();\n\t    newStyle.extendFrom(this, true);\n\t    return newStyle;\n\t  },\n\t  getGradient: function (ctx, obj, rect) {\n\t    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n\t    var canvasGradient = method(ctx, obj, rect);\n\t    var colorStops = obj.colorStops;\n\t\n\t    for (var i = 0; i < colorStops.length; i++) {\n\t      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n\t    }\n\t\n\t    return canvasGradient;\n\t  }\n\t};\n\tvar styleProto = Style.prototype;\n\t\n\tfor (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t  var prop = STYLE_COMMON_PROPS[i];\n\t\n\t  if (!(prop[0] in styleProto)) {\n\t    styleProto[prop[0]] = prop[1];\n\t  }\n\t} // Provide for others\n\t\n\t\n\tStyle.getGradient = styleProto.getGradient;\n\tvar _default = Style;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar guid = __webpack_require__(11);\n\t\n\tvar Eventful = __webpack_require__(12);\n\t\n\tvar Transformable = __webpack_require__(13);\n\t\n\tvar Animatable = __webpack_require__(16);\n\t\n\tvar zrUtil = __webpack_require__(5);\n\t\n\t/**\n\t * @alias module:zrender/Element\n\t * @constructor\n\t * @extends {module:zrender/mixin/Animatable}\n\t * @extends {module:zrender/mixin/Transformable}\n\t * @extends {module:zrender/mixin/Eventful}\n\t */\n\tvar Element = function (opts) {\n\t  // jshint ignore:line\n\t  Transformable.call(this, opts);\n\t  Eventful.call(this, opts);\n\t  Animatable.call(this, opts);\n\t  /**\n\t   * 画布元素ID\n\t   * @type {string}\n\t   */\n\t\n\t  this.id = opts.id || guid();\n\t};\n\t\n\tElement.prototype = {\n\t  /**\n\t   * 元素类型\n\t   * Element type\n\t   * @type {string}\n\t   */\n\t  type: 'element',\n\t\n\t  /**\n\t   * 元素名字\n\t   * Element name\n\t   * @type {string}\n\t   */\n\t  name: '',\n\t\n\t  /**\n\t   * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n\t   * ZRender instance will be assigned when element is associated with zrender\n\t   * @name module:/zrender/Element#__zr\n\t   * @type {module:zrender/ZRender}\n\t   */\n\t  __zr: null,\n\t\n\t  /**\n\t   * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n\t   * If ignore drawing and events of the element object\n\t   * @name module:/zrender/Element#ignore\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  ignore: false,\n\t\n\t  /**\n\t   * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n\t   * 该路径会继承被裁减对象的变换\n\t   * @type {module:zrender/graphic/Path}\n\t   * @see http://www.w3.org/TR/2dcontext/#clipping-region\n\t   * @readOnly\n\t   */\n\t  clipPath: null,\n\t\n\t  /**\n\t   * Drift element\n\t   * @param  {number} dx dx on the global space\n\t   * @param  {number} dy dy on the global space\n\t   */\n\t  drift: function (dx, dy) {\n\t    switch (this.draggable) {\n\t      case 'horizontal':\n\t        dy = 0;\n\t        break;\n\t\n\t      case 'vertical':\n\t        dx = 0;\n\t        break;\n\t    }\n\t\n\t    var m = this.transform;\n\t\n\t    if (!m) {\n\t      m = this.transform = [1, 0, 0, 1, 0, 0];\n\t    }\n\t\n\t    m[4] += dx;\n\t    m[5] += dy;\n\t    this.decomposeTransform();\n\t    this.dirty(false);\n\t  },\n\t\n\t  /**\n\t   * Hook before update\n\t   */\n\t  beforeUpdate: function () {},\n\t\n\t  /**\n\t   * Hook after update\n\t   */\n\t  afterUpdate: function () {},\n\t\n\t  /**\n\t   * Update each frame\n\t   */\n\t  update: function () {\n\t    this.updateTransform();\n\t  },\n\t\n\t  /**\n\t   * @param  {Function} cb\n\t   * @param  {}   context\n\t   */\n\t  traverse: function (cb, context) {},\n\t\n\t  /**\n\t   * @protected\n\t   */\n\t  attrKV: function (key, value) {\n\t    if (key === 'position' || key === 'scale' || key === 'origin') {\n\t      // Copy the array\n\t      if (value) {\n\t        var target = this[key];\n\t\n\t        if (!target) {\n\t          target = this[key] = [];\n\t        }\n\t\n\t        target[0] = value[0];\n\t        target[1] = value[1];\n\t      }\n\t    } else {\n\t      this[key] = value;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Hide the element\n\t   */\n\t  hide: function () {\n\t    this.ignore = true;\n\t    this.__zr && this.__zr.refresh();\n\t  },\n\t\n\t  /**\n\t   * Show the element\n\t   */\n\t  show: function () {\n\t    this.ignore = false;\n\t    this.__zr && this.__zr.refresh();\n\t  },\n\t\n\t  /**\n\t   * @param {string|Object} key\n\t   * @param {*} value\n\t   */\n\t  attr: function (key, value) {\n\t    if (typeof key === 'string') {\n\t      this.attrKV(key, value);\n\t    } else if (zrUtil.isObject(key)) {\n\t      for (var name in key) {\n\t        if (key.hasOwnProperty(name)) {\n\t          this.attrKV(name, key[name]);\n\t        }\n\t      }\n\t    }\n\t\n\t    this.dirty(false);\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param {module:zrender/graphic/Path} clipPath\n\t   */\n\t  setClipPath: function (clipPath) {\n\t    var zr = this.__zr;\n\t\n\t    if (zr) {\n\t      clipPath.addSelfToZr(zr);\n\t    } // Remove previous clip path\n\t\n\t\n\t    if (this.clipPath && this.clipPath !== clipPath) {\n\t      this.removeClipPath();\n\t    }\n\t\n\t    this.clipPath = clipPath;\n\t    clipPath.__zr = zr;\n\t    clipPath.__clipTarget = this;\n\t    this.dirty(false);\n\t  },\n\t\n\t  /**\n\t   */\n\t  removeClipPath: function () {\n\t    var clipPath = this.clipPath;\n\t\n\t    if (clipPath) {\n\t      if (clipPath.__zr) {\n\t        clipPath.removeSelfFromZr(clipPath.__zr);\n\t      }\n\t\n\t      clipPath.__zr = null;\n\t      clipPath.__clipTarget = null;\n\t      this.clipPath = null;\n\t      this.dirty(false);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Add self from zrender instance.\n\t   * Not recursively because it will be invoked when element added to storage.\n\t   * @param {module:zrender/ZRender} zr\n\t   */\n\t  addSelfToZr: function (zr) {\n\t    this.__zr = zr; // 添加动画\n\t\n\t    var animators = this.animators;\n\t\n\t    if (animators) {\n\t      for (var i = 0; i < animators.length; i++) {\n\t        zr.animation.addAnimator(animators[i]);\n\t      }\n\t    }\n\t\n\t    if (this.clipPath) {\n\t      this.clipPath.addSelfToZr(zr);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Remove self from zrender instance.\n\t   * Not recursively because it will be invoked when element added to storage.\n\t   * @param {module:zrender/ZRender} zr\n\t   */\n\t  removeSelfFromZr: function (zr) {\n\t    this.__zr = null; // 移除动画\n\t\n\t    var animators = this.animators;\n\t\n\t    if (animators) {\n\t      for (var i = 0; i < animators.length; i++) {\n\t        zr.animation.removeAnimator(animators[i]);\n\t      }\n\t    }\n\t\n\t    if (this.clipPath) {\n\t      this.clipPath.removeSelfFromZr(zr);\n\t    }\n\t  }\n\t};\n\tzrUtil.mixin(Element, Animatable);\n\tzrUtil.mixin(Element, Transformable);\n\tzrUtil.mixin(Element, Eventful);\n\tvar _default = Element;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * zrender: 生成唯一id\n\t *\n\t * @author errorrik (errorrik@gmail.com)\n\t */\n\tvar idStart = 0x0907;\n\t\n\tfunction _default() {\n\t  return idStart++;\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * 事件扩展\n\t * @module zrender/mixin/Eventful\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\tvar arrySlice = Array.prototype.slice;\n\t/**\n\t * 事件分发器\n\t * @alias module:zrender/mixin/Eventful\n\t * @constructor\n\t */\n\t\n\tvar Eventful = function () {\n\t  this._$handlers = {};\n\t};\n\t\n\tEventful.prototype = {\n\t  constructor: Eventful,\n\t\n\t  /**\n\t   * 单次触发绑定，trigger后销毁\n\t   *\n\t   * @param {string} event 事件名\n\t   * @param {Function} handler 响应函数\n\t   * @param {Object} context\n\t   */\n\t  one: function (event, handler, context) {\n\t    var _h = this._$handlers;\n\t\n\t    if (!handler || !event) {\n\t      return this;\n\t    }\n\t\n\t    if (!_h[event]) {\n\t      _h[event] = [];\n\t    }\n\t\n\t    for (var i = 0; i < _h[event].length; i++) {\n\t      if (_h[event][i].h === handler) {\n\t        return this;\n\t      }\n\t    }\n\t\n\t    _h[event].push({\n\t      h: handler,\n\t      one: true,\n\t      ctx: context || this\n\t    });\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 绑定事件\n\t   * @param {string} event 事件名\n\t   * @param {Function} handler 事件处理函数\n\t   * @param {Object} [context]\n\t   */\n\t  on: function (event, handler, context) {\n\t    var _h = this._$handlers;\n\t\n\t    if (!handler || !event) {\n\t      return this;\n\t    }\n\t\n\t    if (!_h[event]) {\n\t      _h[event] = [];\n\t    }\n\t\n\t    for (var i = 0; i < _h[event].length; i++) {\n\t      if (_h[event][i].h === handler) {\n\t        return this;\n\t      }\n\t    }\n\t\n\t    _h[event].push({\n\t      h: handler,\n\t      one: false,\n\t      ctx: context || this\n\t    });\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 是否绑定了事件\n\t   * @param  {string}  event\n\t   * @return {boolean}\n\t   */\n\t  isSilent: function (event) {\n\t    var _h = this._$handlers;\n\t    return _h[event] && _h[event].length;\n\t  },\n\t\n\t  /**\n\t   * 解绑事件\n\t   * @param {string} event 事件名\n\t   * @param {Function} [handler] 事件处理函数\n\t   */\n\t  off: function (event, handler) {\n\t    var _h = this._$handlers;\n\t\n\t    if (!event) {\n\t      this._$handlers = {};\n\t      return this;\n\t    }\n\t\n\t    if (handler) {\n\t      if (_h[event]) {\n\t        var newList = [];\n\t\n\t        for (var i = 0, l = _h[event].length; i < l; i++) {\n\t          if (_h[event][i]['h'] != handler) {\n\t            newList.push(_h[event][i]);\n\t          }\n\t        }\n\t\n\t        _h[event] = newList;\n\t      }\n\t\n\t      if (_h[event] && _h[event].length === 0) {\n\t        delete _h[event];\n\t      }\n\t    } else {\n\t      delete _h[event];\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 事件分发\n\t   *\n\t   * @param {string} type 事件类型\n\t   */\n\t  trigger: function (type) {\n\t    if (this._$handlers[type]) {\n\t      var args = arguments;\n\t      var argLen = args.length;\n\t\n\t      if (argLen > 3) {\n\t        args = arrySlice.call(args, 1);\n\t      }\n\t\n\t      var _h = this._$handlers[type];\n\t      var len = _h.length;\n\t\n\t      for (var i = 0; i < len;) {\n\t        // Optimize advise from backbone\n\t        switch (argLen) {\n\t          case 1:\n\t            _h[i]['h'].call(_h[i]['ctx']);\n\t\n\t            break;\n\t\n\t          case 2:\n\t            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\t\n\t            break;\n\t\n\t          case 3:\n\t            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\t\n\t            break;\n\t\n\t          default:\n\t            // have more than 2 given arguments\n\t            _h[i]['h'].apply(_h[i]['ctx'], args);\n\t\n\t            break;\n\t        }\n\t\n\t        if (_h[i]['one']) {\n\t          _h.splice(i, 1);\n\t\n\t          len--;\n\t        } else {\n\t          i++;\n\t        }\n\t      }\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 带有context的事件分发, 最后一个参数是事件回调的context\n\t   * @param {string} type 事件类型\n\t   */\n\t  triggerWithContext: function (type) {\n\t    if (this._$handlers[type]) {\n\t      var args = arguments;\n\t      var argLen = args.length;\n\t\n\t      if (argLen > 4) {\n\t        args = arrySlice.call(args, 1, args.length - 1);\n\t      }\n\t\n\t      var ctx = args[args.length - 1];\n\t      var _h = this._$handlers[type];\n\t      var len = _h.length;\n\t\n\t      for (var i = 0; i < len;) {\n\t        // Optimize advise from backbone\n\t        switch (argLen) {\n\t          case 1:\n\t            _h[i]['h'].call(ctx);\n\t\n\t            break;\n\t\n\t          case 2:\n\t            _h[i]['h'].call(ctx, args[1]);\n\t\n\t            break;\n\t\n\t          case 3:\n\t            _h[i]['h'].call(ctx, args[1], args[2]);\n\t\n\t            break;\n\t\n\t          default:\n\t            // have more than 2 given arguments\n\t            _h[i]['h'].apply(ctx, args);\n\t\n\t            break;\n\t        }\n\t\n\t        if (_h[i]['one']) {\n\t          _h.splice(i, 1);\n\t\n\t          len--;\n\t        } else {\n\t          i++;\n\t        }\n\t      }\n\t    }\n\t\n\t    return this;\n\t  }\n\t}; // 对象可以通过 onxxxx 绑定事件\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onclick\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmouseover\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmouseout\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmousemove\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmousewheel\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmousedown\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmouseup\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondrag\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondragstart\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondragend\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondragenter\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondragleave\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondragover\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondrop\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\tvar _default = Eventful;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar matrix = __webpack_require__(14);\n\t\n\tvar vector = __webpack_require__(15);\n\t\n\t/**\n\t * 提供变换扩展\n\t * @module zrender/mixin/Transformable\n\t * @author pissang (https://www.github.com/pissang)\n\t */\n\tvar mIdentity = matrix.identity;\n\tvar EPSILON = 5e-5;\n\t\n\tfunction isNotAroundZero(val) {\n\t  return val > EPSILON || val < -EPSILON;\n\t}\n\t/**\n\t * @alias module:zrender/mixin/Transformable\n\t * @constructor\n\t */\n\t\n\t\n\tvar Transformable = function (opts) {\n\t  opts = opts || {}; // If there are no given position, rotation, scale\n\t\n\t  if (!opts.position) {\n\t    /**\n\t     * 平移\n\t     * @type {Array.<number>}\n\t     * @default [0, 0]\n\t     */\n\t    this.position = [0, 0];\n\t  }\n\t\n\t  if (opts.rotation == null) {\n\t    /**\n\t     * 旋转\n\t     * @type {Array.<number>}\n\t     * @default 0\n\t     */\n\t    this.rotation = 0;\n\t  }\n\t\n\t  if (!opts.scale) {\n\t    /**\n\t     * 缩放\n\t     * @type {Array.<number>}\n\t     * @default [1, 1]\n\t     */\n\t    this.scale = [1, 1];\n\t  }\n\t  /**\n\t   * 旋转和缩放的原点\n\t   * @type {Array.<number>}\n\t   * @default null\n\t   */\n\t\n\t\n\t  this.origin = this.origin || null;\n\t};\n\t\n\tvar transformableProto = Transformable.prototype;\n\ttransformableProto.transform = null;\n\t/**\n\t * 判断是否需要有坐标变换\n\t * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n\t */\n\t\n\ttransformableProto.needLocalTransform = function () {\n\t  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n\t};\n\t\n\ttransformableProto.updateTransform = function () {\n\t  var parent = this.parent;\n\t  var parentHasTransform = parent && parent.transform;\n\t  var needLocalTransform = this.needLocalTransform();\n\t  var m = this.transform;\n\t\n\t  if (!(needLocalTransform || parentHasTransform)) {\n\t    m && mIdentity(m);\n\t    return;\n\t  }\n\t\n\t  m = m || matrix.create();\n\t\n\t  if (needLocalTransform) {\n\t    this.getLocalTransform(m);\n\t  } else {\n\t    mIdentity(m);\n\t  } // 应用父节点变换\n\t\n\t\n\t  if (parentHasTransform) {\n\t    if (needLocalTransform) {\n\t      matrix.mul(m, parent.transform, m);\n\t    } else {\n\t      matrix.copy(m, parent.transform);\n\t    }\n\t  } // 保存这个变换矩阵\n\t\n\t\n\t  this.transform = m;\n\t  this.invTransform = this.invTransform || matrix.create();\n\t  matrix.invert(this.invTransform, m);\n\t};\n\t\n\ttransformableProto.getLocalTransform = function (m) {\n\t  return Transformable.getLocalTransform(this, m);\n\t};\n\t/**\n\t * 将自己的transform应用到context上\n\t * @param {CanvasRenderingContext2D} ctx\n\t */\n\t\n\t\n\ttransformableProto.setTransform = function (ctx) {\n\t  var m = this.transform;\n\t  var dpr = ctx.dpr || 1;\n\t\n\t  if (m) {\n\t    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n\t  } else {\n\t    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t  }\n\t};\n\t\n\ttransformableProto.restoreTransform = function (ctx) {\n\t  var dpr = ctx.dpr || 1;\n\t  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t};\n\t\n\tvar tmpTransform = [];\n\t/**\n\t * 分解`transform`矩阵到`position`, `rotation`, `scale`\n\t */\n\t\n\ttransformableProto.decomposeTransform = function () {\n\t  if (!this.transform) {\n\t    return;\n\t  }\n\t\n\t  var parent = this.parent;\n\t  var m = this.transform;\n\t\n\t  if (parent && parent.transform) {\n\t    // Get local transform and decompose them to position, scale, rotation\n\t    matrix.mul(tmpTransform, parent.invTransform, m);\n\t    m = tmpTransform;\n\t  }\n\t\n\t  var sx = m[0] * m[0] + m[1] * m[1];\n\t  var sy = m[2] * m[2] + m[3] * m[3];\n\t  var position = this.position;\n\t  var scale = this.scale;\n\t\n\t  if (isNotAroundZero(sx - 1)) {\n\t    sx = Math.sqrt(sx);\n\t  }\n\t\n\t  if (isNotAroundZero(sy - 1)) {\n\t    sy = Math.sqrt(sy);\n\t  }\n\t\n\t  if (m[0] < 0) {\n\t    sx = -sx;\n\t  }\n\t\n\t  if (m[3] < 0) {\n\t    sy = -sy;\n\t  }\n\t\n\t  position[0] = m[4];\n\t  position[1] = m[5];\n\t  scale[0] = sx;\n\t  scale[1] = sy;\n\t  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n\t};\n\t/**\n\t * Get global scale\n\t * @return {Array.<number>}\n\t */\n\t\n\t\n\ttransformableProto.getGlobalScale = function () {\n\t  var m = this.transform;\n\t\n\t  if (!m) {\n\t    return [1, 1];\n\t  }\n\t\n\t  var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n\t  var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\t\n\t  if (m[0] < 0) {\n\t    sx = -sx;\n\t  }\n\t\n\t  if (m[3] < 0) {\n\t    sy = -sy;\n\t  }\n\t\n\t  return [sx, sy];\n\t};\n\t/**\n\t * 变换坐标位置到 shape 的局部坐标空间\n\t * @method\n\t * @param {number} x\n\t * @param {number} y\n\t * @return {Array.<number>}\n\t */\n\t\n\t\n\ttransformableProto.transformCoordToLocal = function (x, y) {\n\t  var v2 = [x, y];\n\t  var invTransform = this.invTransform;\n\t\n\t  if (invTransform) {\n\t    vector.applyTransform(v2, v2, invTransform);\n\t  }\n\t\n\t  return v2;\n\t};\n\t/**\n\t * 变换局部坐标位置到全局坐标空间\n\t * @method\n\t * @param {number} x\n\t * @param {number} y\n\t * @return {Array.<number>}\n\t */\n\t\n\t\n\ttransformableProto.transformCoordToGlobal = function (x, y) {\n\t  var v2 = [x, y];\n\t  var transform = this.transform;\n\t\n\t  if (transform) {\n\t    vector.applyTransform(v2, v2, transform);\n\t  }\n\t\n\t  return v2;\n\t};\n\t/**\n\t * @static\n\t * @param {Object} target\n\t * @param {Array.<number>} target.origin\n\t * @param {number} target.rotation\n\t * @param {Array.<number>} target.position\n\t * @param {Array.<number>} [m]\n\t */\n\t\n\t\n\tTransformable.getLocalTransform = function (target, m) {\n\t  m = m || [];\n\t  mIdentity(m);\n\t  var origin = target.origin;\n\t  var scale = target.scale || [1, 1];\n\t  var rotation = target.rotation || 0;\n\t  var position = target.position || [0, 0];\n\t\n\t  if (origin) {\n\t    // Translate to origin\n\t    m[4] -= origin[0];\n\t    m[5] -= origin[1];\n\t  }\n\t\n\t  matrix.scale(m, m, scale);\n\t\n\t  if (rotation) {\n\t    matrix.rotate(m, m, rotation);\n\t  }\n\t\n\t  if (origin) {\n\t    // Translate back from origin\n\t    m[4] += origin[0];\n\t    m[5] += origin[1];\n\t  }\n\t\n\t  m[4] += position[0];\n\t  m[5] += position[1];\n\t  return m;\n\t};\n\t\n\tvar _default = Transformable;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * 3x2矩阵操作类\n\t * @exports zrender/tool/matrix\n\t */\n\tvar ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n\t/**\n\t * 创建一个单位矩阵\n\t * @return {Float32Array|Array.<number>}\n\t */\n\t\n\tfunction create() {\n\t  var out = new ArrayCtor(6);\n\t  identity(out);\n\t  return out;\n\t}\n\t/**\n\t * 设置矩阵为单位矩阵\n\t * @param {Float32Array|Array.<number>} out\n\t */\n\t\n\t\n\tfunction identity(out) {\n\t  out[0] = 1;\n\t  out[1] = 0;\n\t  out[2] = 0;\n\t  out[3] = 1;\n\t  out[4] = 0;\n\t  out[5] = 0;\n\t  return out;\n\t}\n\t/**\n\t * 复制矩阵\n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} m\n\t */\n\t\n\t\n\tfunction copy(out, m) {\n\t  out[0] = m[0];\n\t  out[1] = m[1];\n\t  out[2] = m[2];\n\t  out[3] = m[3];\n\t  out[4] = m[4];\n\t  out[5] = m[5];\n\t  return out;\n\t}\n\t/**\n\t * 矩阵相乘\n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} m1\n\t * @param {Float32Array|Array.<number>} m2\n\t */\n\t\n\t\n\tfunction mul(out, m1, m2) {\n\t  // Consider matrix.mul(m, m2, m);\n\t  // where out is the same as m2.\n\t  // So use temp variable to escape error.\n\t  var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n\t  var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n\t  var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n\t  var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n\t  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n\t  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n\t  out[0] = out0;\n\t  out[1] = out1;\n\t  out[2] = out2;\n\t  out[3] = out3;\n\t  out[4] = out4;\n\t  out[5] = out5;\n\t  return out;\n\t}\n\t/**\n\t * 平移变换\n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} a\n\t * @param {Float32Array|Array.<number>} v\n\t */\n\t\n\t\n\tfunction translate(out, a, v) {\n\t  out[0] = a[0];\n\t  out[1] = a[1];\n\t  out[2] = a[2];\n\t  out[3] = a[3];\n\t  out[4] = a[4] + v[0];\n\t  out[5] = a[5] + v[1];\n\t  return out;\n\t}\n\t/**\n\t * 旋转变换\n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} a\n\t * @param {number} rad\n\t */\n\t\n\t\n\tfunction rotate(out, a, rad) {\n\t  var aa = a[0];\n\t  var ac = a[2];\n\t  var atx = a[4];\n\t  var ab = a[1];\n\t  var ad = a[3];\n\t  var aty = a[5];\n\t  var st = Math.sin(rad);\n\t  var ct = Math.cos(rad);\n\t  out[0] = aa * ct + ab * st;\n\t  out[1] = -aa * st + ab * ct;\n\t  out[2] = ac * ct + ad * st;\n\t  out[3] = -ac * st + ct * ad;\n\t  out[4] = ct * atx + st * aty;\n\t  out[5] = ct * aty - st * atx;\n\t  return out;\n\t}\n\t/**\n\t * 缩放变换\n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} a\n\t * @param {Float32Array|Array.<number>} v\n\t */\n\t\n\t\n\tfunction scale(out, a, v) {\n\t  var vx = v[0];\n\t  var vy = v[1];\n\t  out[0] = a[0] * vx;\n\t  out[1] = a[1] * vy;\n\t  out[2] = a[2] * vx;\n\t  out[3] = a[3] * vy;\n\t  out[4] = a[4] * vx;\n\t  out[5] = a[5] * vy;\n\t  return out;\n\t}\n\t/**\n\t * 求逆矩阵\n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} a\n\t */\n\t\n\t\n\tfunction invert(out, a) {\n\t  var aa = a[0];\n\t  var ac = a[2];\n\t  var atx = a[4];\n\t  var ab = a[1];\n\t  var ad = a[3];\n\t  var aty = a[5];\n\t  var det = aa * ad - ab * ac;\n\t\n\t  if (!det) {\n\t    return null;\n\t  }\n\t\n\t  det = 1.0 / det;\n\t  out[0] = ad * det;\n\t  out[1] = -ab * det;\n\t  out[2] = -ac * det;\n\t  out[3] = aa * det;\n\t  out[4] = (ac * aty - ad * atx) * det;\n\t  out[5] = (ab * atx - aa * aty) * det;\n\t  return out;\n\t}\n\t\n\texports.create = create;\n\texports.identity = identity;\n\texports.copy = copy;\n\texports.mul = mul;\n\texports.translate = translate;\n\texports.rotate = rotate;\n\texports.scale = scale;\n\texports.invert = invert;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\n\tvar ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n\t/**\n\t * 创建一个向量\n\t * @param {number} [x=0]\n\t * @param {number} [y=0]\n\t * @return {Vector2}\n\t */\n\t\n\tfunction create(x, y) {\n\t  var out = new ArrayCtor(2);\n\t\n\t  if (x == null) {\n\t    x = 0;\n\t  }\n\t\n\t  if (y == null) {\n\t    y = 0;\n\t  }\n\t\n\t  out[0] = x;\n\t  out[1] = y;\n\t  return out;\n\t}\n\t/**\n\t * 复制向量数据\n\t * @param {Vector2} out\n\t * @param {Vector2} v\n\t * @return {Vector2}\n\t */\n\t\n\t\n\tfunction copy(out, v) {\n\t  out[0] = v[0];\n\t  out[1] = v[1];\n\t  return out;\n\t}\n\t/**\n\t * 克隆一个向量\n\t * @param {Vector2} v\n\t * @return {Vector2}\n\t */\n\t\n\t\n\tfunction clone(v) {\n\t  var out = new ArrayCtor(2);\n\t  out[0] = v[0];\n\t  out[1] = v[1];\n\t  return out;\n\t}\n\t/**\n\t * 设置向量的两个项\n\t * @param {Vector2} out\n\t * @param {number} a\n\t * @param {number} b\n\t * @return {Vector2} 结果\n\t */\n\t\n\t\n\tfunction set(out, a, b) {\n\t  out[0] = a;\n\t  out[1] = b;\n\t  return out;\n\t}\n\t/**\n\t * 向量相加\n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t */\n\t\n\t\n\tfunction add(out, v1, v2) {\n\t  out[0] = v1[0] + v2[0];\n\t  out[1] = v1[1] + v2[1];\n\t  return out;\n\t}\n\t/**\n\t * 向量缩放后相加\n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t * @param {number} a\n\t */\n\t\n\t\n\tfunction scaleAndAdd(out, v1, v2, a) {\n\t  out[0] = v1[0] + v2[0] * a;\n\t  out[1] = v1[1] + v2[1] * a;\n\t  return out;\n\t}\n\t/**\n\t * 向量相减\n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t */\n\t\n\t\n\tfunction sub(out, v1, v2) {\n\t  out[0] = v1[0] - v2[0];\n\t  out[1] = v1[1] - v2[1];\n\t  return out;\n\t}\n\t/**\n\t * 向量长度\n\t * @param {Vector2} v\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction len(v) {\n\t  return Math.sqrt(lenSquare(v));\n\t}\n\t\n\tvar length = len; // jshint ignore:line\n\t\n\t/**\n\t * 向量长度平方\n\t * @param {Vector2} v\n\t * @return {number}\n\t */\n\t\n\tfunction lenSquare(v) {\n\t  return v[0] * v[0] + v[1] * v[1];\n\t}\n\t\n\tvar lengthSquare = lenSquare;\n\t/**\n\t * 向量乘法\n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t */\n\t\n\tfunction mul(out, v1, v2) {\n\t  out[0] = v1[0] * v2[0];\n\t  out[1] = v1[1] * v2[1];\n\t  return out;\n\t}\n\t/**\n\t * 向量除法\n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t */\n\t\n\t\n\tfunction div(out, v1, v2) {\n\t  out[0] = v1[0] / v2[0];\n\t  out[1] = v1[1] / v2[1];\n\t  return out;\n\t}\n\t/**\n\t * 向量点乘\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction dot(v1, v2) {\n\t  return v1[0] * v2[0] + v1[1] * v2[1];\n\t}\n\t/**\n\t * 向量缩放\n\t * @param {Vector2} out\n\t * @param {Vector2} v\n\t * @param {number} s\n\t */\n\t\n\t\n\tfunction scale(out, v, s) {\n\t  out[0] = v[0] * s;\n\t  out[1] = v[1] * s;\n\t  return out;\n\t}\n\t/**\n\t * 向量归一化\n\t * @param {Vector2} out\n\t * @param {Vector2} v\n\t */\n\t\n\t\n\tfunction normalize(out, v) {\n\t  var d = len(v);\n\t\n\t  if (d === 0) {\n\t    out[0] = 0;\n\t    out[1] = 0;\n\t  } else {\n\t    out[0] = v[0] / d;\n\t    out[1] = v[1] / d;\n\t  }\n\t\n\t  return out;\n\t}\n\t/**\n\t * 计算向量间距离\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction distance(v1, v2) {\n\t  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));\n\t}\n\t\n\tvar dist = distance;\n\t/**\n\t * 向量距离平方\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t * @return {number}\n\t */\n\t\n\tfunction distanceSquare(v1, v2) {\n\t  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n\t}\n\t\n\tvar distSquare = distanceSquare;\n\t/**\n\t * 求负向量\n\t * @param {Vector2} out\n\t * @param {Vector2} v\n\t */\n\t\n\tfunction negate(out, v) {\n\t  out[0] = -v[0];\n\t  out[1] = -v[1];\n\t  return out;\n\t}\n\t/**\n\t * 插值两个点\n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t * @param {number} t\n\t */\n\t\n\t\n\tfunction lerp(out, v1, v2, t) {\n\t  out[0] = v1[0] + t * (v2[0] - v1[0]);\n\t  out[1] = v1[1] + t * (v2[1] - v1[1]);\n\t  return out;\n\t}\n\t/**\n\t * 矩阵左乘向量\n\t * @param {Vector2} out\n\t * @param {Vector2} v\n\t * @param {Vector2} m\n\t */\n\t\n\t\n\tfunction applyTransform(out, v, m) {\n\t  var x = v[0];\n\t  var y = v[1];\n\t  out[0] = m[0] * x + m[2] * y + m[4];\n\t  out[1] = m[1] * x + m[3] * y + m[5];\n\t  return out;\n\t}\n\t/**\n\t * 求两个向量最小值\n\t * @param  {Vector2} out\n\t * @param  {Vector2} v1\n\t * @param  {Vector2} v2\n\t */\n\t\n\t\n\tfunction min(out, v1, v2) {\n\t  out[0] = Math.min(v1[0], v2[0]);\n\t  out[1] = Math.min(v1[1], v2[1]);\n\t  return out;\n\t}\n\t/**\n\t * 求两个向量最大值\n\t * @param  {Vector2} out\n\t * @param  {Vector2} v1\n\t * @param  {Vector2} v2\n\t */\n\t\n\t\n\tfunction max(out, v1, v2) {\n\t  out[0] = Math.max(v1[0], v2[0]);\n\t  out[1] = Math.max(v1[1], v2[1]);\n\t  return out;\n\t}\n\t\n\texports.create = create;\n\texports.copy = copy;\n\texports.clone = clone;\n\texports.set = set;\n\texports.add = add;\n\texports.scaleAndAdd = scaleAndAdd;\n\texports.sub = sub;\n\texports.len = len;\n\texports.length = length;\n\texports.lenSquare = lenSquare;\n\texports.lengthSquare = lengthSquare;\n\texports.mul = mul;\n\texports.div = div;\n\texports.dot = dot;\n\texports.scale = scale;\n\texports.normalize = normalize;\n\texports.distance = distance;\n\texports.dist = dist;\n\texports.distanceSquare = distanceSquare;\n\texports.distSquare = distSquare;\n\texports.negate = negate;\n\texports.lerp = lerp;\n\texports.applyTransform = applyTransform;\n\texports.min = min;\n\texports.max = max;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Animator = __webpack_require__(17);\n\t\n\tvar log = __webpack_require__(22);\n\t\n\tvar _util = __webpack_require__(5);\n\t\n\tvar isString = _util.isString;\n\tvar isFunction = _util.isFunction;\n\tvar isObject = _util.isObject;\n\tvar isArrayLike = _util.isArrayLike;\n\tvar indexOf = _util.indexOf;\n\t\n\t/**\n\t * @alias modue:zrender/mixin/Animatable\n\t * @constructor\n\t */\n\tvar Animatable = function () {\n\t  /**\n\t   * @type {Array.<module:zrender/animation/Animator>}\n\t   * @readOnly\n\t   */\n\t  this.animators = [];\n\t};\n\t\n\tAnimatable.prototype = {\n\t  constructor: Animatable,\n\t\n\t  /**\n\t   * 动画\n\t   *\n\t   * @param {string} path The path to fetch value from object, like 'a.b.c'.\n\t   * @param {boolean} [loop] Whether to loop animation.\n\t   * @return {module:zrender/animation/Animator}\n\t   * @example:\n\t   *     el.animate('style', false)\n\t   *         .when(1000, {x: 10} )\n\t   *         .done(function(){ // Animation done })\n\t   *         .start()\n\t   */\n\t  animate: function (path, loop) {\n\t    var target;\n\t    var animatingShape = false;\n\t    var el = this;\n\t    var zr = this.__zr;\n\t\n\t    if (path) {\n\t      var pathSplitted = path.split('.');\n\t      var prop = el; // If animating shape\n\t\n\t      animatingShape = pathSplitted[0] === 'shape';\n\t\n\t      for (var i = 0, l = pathSplitted.length; i < l; i++) {\n\t        if (!prop) {\n\t          continue;\n\t        }\n\t\n\t        prop = prop[pathSplitted[i]];\n\t      }\n\t\n\t      if (prop) {\n\t        target = prop;\n\t      }\n\t    } else {\n\t      target = el;\n\t    }\n\t\n\t    if (!target) {\n\t      log('Property \"' + path + '\" is not existed in element ' + el.id);\n\t      return;\n\t    }\n\t\n\t    var animators = el.animators;\n\t    var animator = new Animator(target, loop);\n\t    animator.during(function (target) {\n\t      el.dirty(animatingShape);\n\t    }).done(function () {\n\t      // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n\t      animators.splice(indexOf(animators, animator), 1);\n\t    });\n\t    animators.push(animator); // If animate after added to the zrender\n\t\n\t    if (zr) {\n\t      zr.animation.addAnimator(animator);\n\t    }\n\t\n\t    return animator;\n\t  },\n\t\n\t  /**\n\t   * 停止动画\n\t   * @param {boolean} forwardToLast If move to last frame before stop\n\t   */\n\t  stopAnimation: function (forwardToLast) {\n\t    var animators = this.animators;\n\t    var len = animators.length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      animators[i].stop(forwardToLast);\n\t    }\n\t\n\t    animators.length = 0;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * Caution: this method will stop previous animation.\n\t   * So do not use this method to one element twice before\n\t   * animation starts, unless you know what you are doing.\n\t   * @param {Object} target\n\t   * @param {number} [time=500] Time in ms\n\t   * @param {string} [easing='linear']\n\t   * @param {number} [delay=0]\n\t   * @param {Function} [callback]\n\t   * @param {Function} [forceAnimate] Prevent stop animation and callback\n\t   *        immediently when target values are the same as current values.\n\t   *\n\t   * @example\n\t   *  // Animate position\n\t   *  el.animateTo({\n\t   *      position: [10, 10]\n\t   *  }, function () { // done })\n\t   *\n\t   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n\t   *  el.animateTo({\n\t   *      shape: {\n\t   *          width: 500\n\t   *      },\n\t   *      style: {\n\t   *          fill: 'red'\n\t   *      }\n\t   *      position: [10, 10]\n\t   *  }, 100, 100, 'cubicOut', function () { // done })\n\t   */\n\t  // TODO Return animation key\n\t  animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n\t    // animateTo(target, time, easing, callback);\n\t    if (isString(delay)) {\n\t      callback = easing;\n\t      easing = delay;\n\t      delay = 0;\n\t    } // animateTo(target, time, delay, callback);\n\t    else if (isFunction(easing)) {\n\t        callback = easing;\n\t        easing = 'linear';\n\t        delay = 0;\n\t      } // animateTo(target, time, callback);\n\t      else if (isFunction(delay)) {\n\t          callback = delay;\n\t          delay = 0;\n\t        } // animateTo(target, callback)\n\t        else if (isFunction(time)) {\n\t            callback = time;\n\t            time = 500;\n\t          } // animateTo(target)\n\t          else if (!time) {\n\t              time = 500;\n\t            } // Stop all previous animations\n\t\n\t\n\t    this.stopAnimation();\n\t\n\t    this._animateToShallow('', this, target, time, delay); // Animators may be removed immediately after start\n\t    // if there is nothing to animate\n\t\n\t\n\t    var animators = this.animators.slice();\n\t    var count = animators.length;\n\t\n\t    function done() {\n\t      count--;\n\t\n\t      if (!count) {\n\t        callback && callback();\n\t      }\n\t    } // No animators. This should be checked before animators[i].start(),\n\t    // because 'done' may be executed immediately if no need to animate.\n\t\n\t\n\t    if (!count) {\n\t      callback && callback();\n\t    } // Start after all animators created\n\t    // Incase any animator is done immediately when all animation properties are not changed\n\t\n\t\n\t    for (var i = 0; i < animators.length; i++) {\n\t      animators[i].done(done).start(easing, forceAnimate);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @private\n\t   * @param {string} path=''\n\t   * @param {Object} source=this\n\t   * @param {Object} target\n\t   * @param {number} [time=500]\n\t   * @param {number} [delay=0]\n\t   *\n\t   * @example\n\t   *  // Animate position\n\t   *  el._animateToShallow({\n\t   *      position: [10, 10]\n\t   *  })\n\t   *\n\t   *  // Animate shape, style and position in 100ms, delayed 100ms\n\t   *  el._animateToShallow({\n\t   *      shape: {\n\t   *          width: 500\n\t   *      },\n\t   *      style: {\n\t   *          fill: 'red'\n\t   *      }\n\t   *      position: [10, 10]\n\t   *  }, 100, 100)\n\t   */\n\t  _animateToShallow: function (path, source, target, time, delay) {\n\t    var objShallow = {};\n\t    var propertyCount = 0;\n\t\n\t    for (var name in target) {\n\t      if (!target.hasOwnProperty(name)) {\n\t        continue;\n\t      }\n\t\n\t      if (source[name] != null) {\n\t        if (isObject(target[name]) && !isArrayLike(target[name])) {\n\t          this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);\n\t        } else {\n\t          objShallow[name] = target[name];\n\t          propertyCount++;\n\t        }\n\t      } else if (target[name] != null) {\n\t        // Attr directly if not has property\n\t        // FIXME, if some property not needed for element ?\n\t        if (!path) {\n\t          this.attr(name, target[name]);\n\t        } else {\n\t          // Shape or style\n\t          var props = {};\n\t          props[path] = {};\n\t          props[path][name] = target[name];\n\t          this.attr(props);\n\t        }\n\t      }\n\t    }\n\t\n\t    if (propertyCount > 0) {\n\t      this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n\t    }\n\t\n\t    return this;\n\t  }\n\t};\n\tvar _default = Animatable;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Clip = __webpack_require__(18);\n\t\n\tvar color = __webpack_require__(20);\n\t\n\tvar _util = __webpack_require__(5);\n\t\n\tvar isArrayLike = _util.isArrayLike;\n\t\n\t/**\n\t * @module echarts/animation/Animator\n\t */\n\tvar arraySlice = Array.prototype.slice;\n\t\n\tfunction defaultGetter(target, key) {\n\t  return target[key];\n\t}\n\t\n\tfunction defaultSetter(target, key, value) {\n\t  target[key] = value;\n\t}\n\t/**\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} percent\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction interpolateNumber(p0, p1, percent) {\n\t  return (p1 - p0) * percent + p0;\n\t}\n\t/**\n\t * @param  {string} p0\n\t * @param  {string} p1\n\t * @param  {number} percent\n\t * @return {string}\n\t */\n\t\n\t\n\tfunction interpolateString(p0, p1, percent) {\n\t  return percent > 0.5 ? p1 : p0;\n\t}\n\t/**\n\t * @param  {Array} p0\n\t * @param  {Array} p1\n\t * @param  {number} percent\n\t * @param  {Array} out\n\t * @param  {number} arrDim\n\t */\n\t\n\t\n\tfunction interpolateArray(p0, p1, percent, out, arrDim) {\n\t  var len = p0.length;\n\t\n\t  if (arrDim == 1) {\n\t    for (var i = 0; i < len; i++) {\n\t      out[i] = interpolateNumber(p0[i], p1[i], percent);\n\t    }\n\t  } else {\n\t    var len2 = len && p0[0].length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      for (var j = 0; j < len2; j++) {\n\t        out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n\t      }\n\t    }\n\t  }\n\t} // arr0 is source array, arr1 is target array.\n\t// Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\t\n\t\n\tfunction fillArr(arr0, arr1, arrDim) {\n\t  var arr0Len = arr0.length;\n\t  var arr1Len = arr1.length;\n\t\n\t  if (arr0Len !== arr1Len) {\n\t    // FIXME Not work for TypedArray\n\t    var isPreviousLarger = arr0Len > arr1Len;\n\t\n\t    if (isPreviousLarger) {\n\t      // Cut the previous\n\t      arr0.length = arr1Len;\n\t    } else {\n\t      // Fill the previous\n\t      for (var i = arr0Len; i < arr1Len; i++) {\n\t        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n\t      }\n\t    }\n\t  } // Handling NaN value\n\t\n\t\n\t  var len2 = arr0[0] && arr0[0].length;\n\t\n\t  for (var i = 0; i < arr0.length; i++) {\n\t    if (arrDim === 1) {\n\t      if (isNaN(arr0[i])) {\n\t        arr0[i] = arr1[i];\n\t      }\n\t    } else {\n\t      for (var j = 0; j < len2; j++) {\n\t        if (isNaN(arr0[i][j])) {\n\t          arr0[i][j] = arr1[i][j];\n\t        }\n\t      }\n\t    }\n\t  }\n\t}\n\t/**\n\t * @param  {Array} arr0\n\t * @param  {Array} arr1\n\t * @param  {number} arrDim\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isArraySame(arr0, arr1, arrDim) {\n\t  if (arr0 === arr1) {\n\t    return true;\n\t  }\n\t\n\t  var len = arr0.length;\n\t\n\t  if (len !== arr1.length) {\n\t    return false;\n\t  }\n\t\n\t  if (arrDim === 1) {\n\t    for (var i = 0; i < len; i++) {\n\t      if (arr0[i] !== arr1[i]) {\n\t        return false;\n\t      }\n\t    }\n\t  } else {\n\t    var len2 = arr0[0].length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      for (var j = 0; j < len2; j++) {\n\t        if (arr0[i][j] !== arr1[i][j]) {\n\t          return false;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  return true;\n\t}\n\t/**\n\t * Catmull Rom interpolate array\n\t * @param  {Array} p0\n\t * @param  {Array} p1\n\t * @param  {Array} p2\n\t * @param  {Array} p3\n\t * @param  {number} t\n\t * @param  {number} t2\n\t * @param  {number} t3\n\t * @param  {Array} out\n\t * @param  {number} arrDim\n\t */\n\t\n\t\n\tfunction catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {\n\t  var len = p0.length;\n\t\n\t  if (arrDim == 1) {\n\t    for (var i = 0; i < len; i++) {\n\t      out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);\n\t    }\n\t  } else {\n\t    var len2 = p0[0].length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      for (var j = 0; j < len2; j++) {\n\t        out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);\n\t      }\n\t    }\n\t  }\n\t}\n\t/**\n\t * Catmull Rom interpolate number\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {number} t\n\t * @param  {number} t2\n\t * @param  {number} t3\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n\t  var v0 = (p2 - p0) * 0.5;\n\t  var v1 = (p3 - p1) * 0.5;\n\t  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n\t}\n\t\n\tfunction cloneValue(value) {\n\t  if (isArrayLike(value)) {\n\t    var len = value.length;\n\t\n\t    if (isArrayLike(value[0])) {\n\t      var ret = [];\n\t\n\t      for (var i = 0; i < len; i++) {\n\t        ret.push(arraySlice.call(value[i]));\n\t      }\n\t\n\t      return ret;\n\t    }\n\t\n\t    return arraySlice.call(value);\n\t  }\n\t\n\t  return value;\n\t}\n\t\n\tfunction rgba2String(rgba) {\n\t  rgba[0] = Math.floor(rgba[0]);\n\t  rgba[1] = Math.floor(rgba[1]);\n\t  rgba[2] = Math.floor(rgba[2]);\n\t  return 'rgba(' + rgba.join(',') + ')';\n\t}\n\t\n\tfunction getArrayDim(keyframes) {\n\t  var lastValue = keyframes[keyframes.length - 1].value;\n\t  return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n\t}\n\t\n\tfunction createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {\n\t  var getter = animator._getter;\n\t  var setter = animator._setter;\n\t  var useSpline = easing === 'spline';\n\t  var trackLen = keyframes.length;\n\t\n\t  if (!trackLen) {\n\t    return;\n\t  } // Guess data type\n\t\n\t\n\t  var firstVal = keyframes[0].value;\n\t  var isValueArray = isArrayLike(firstVal);\n\t  var isValueColor = false;\n\t  var isValueString = false; // For vertices morphing\n\t\n\t  var arrDim = isValueArray ? getArrayDim(keyframes) : 0;\n\t  var trackMaxTime; // Sort keyframe as ascending\n\t\n\t  keyframes.sort(function (a, b) {\n\t    return a.time - b.time;\n\t  });\n\t  trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe\n\t\n\t  var kfPercents = []; // Value of each keyframe\n\t\n\t  var kfValues = [];\n\t  var prevValue = keyframes[0].value;\n\t  var isAllValueEqual = true;\n\t\n\t  for (var i = 0; i < trackLen; i++) {\n\t    kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string\n\t\n\t    var value = keyframes[i].value; // Check if value is equal, deep check if value is array\n\t\n\t    if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {\n\t      isAllValueEqual = false;\n\t    }\n\t\n\t    prevValue = value; // Try converting a string to a color array\n\t\n\t    if (typeof value == 'string') {\n\t      var colorArray = color.parse(value);\n\t\n\t      if (colorArray) {\n\t        value = colorArray;\n\t        isValueColor = true;\n\t      } else {\n\t        isValueString = true;\n\t      }\n\t    }\n\t\n\t    kfValues.push(value);\n\t  }\n\t\n\t  if (!forceAnimate && isAllValueEqual) {\n\t    return;\n\t  }\n\t\n\t  var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value\n\t\n\t  for (var i = 0; i < trackLen - 1; i++) {\n\t    if (isValueArray) {\n\t      fillArr(kfValues[i], lastValue, arrDim);\n\t    } else {\n\t      if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n\t        kfValues[i] = lastValue;\n\t      }\n\t    }\n\t  }\n\t\n\t  isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when\n\t  // animation playback is sequency\n\t\n\t  var lastFrame = 0;\n\t  var lastFramePercent = 0;\n\t  var start;\n\t  var w;\n\t  var p0;\n\t  var p1;\n\t  var p2;\n\t  var p3;\n\t\n\t  if (isValueColor) {\n\t    var rgba = [0, 0, 0, 0];\n\t  }\n\t\n\t  var onframe = function (target, percent) {\n\t    // Find the range keyframes\n\t    // kf1-----kf2---------current--------kf3\n\t    // find kf2 and kf3 and do interpolation\n\t    var frame; // In the easing function like elasticOut, percent may less than 0\n\t\n\t    if (percent < 0) {\n\t      frame = 0;\n\t    } else if (percent < lastFramePercent) {\n\t      // Start from next key\n\t      // PENDING start from lastFrame ?\n\t      start = Math.min(lastFrame + 1, trackLen - 1);\n\t\n\t      for (frame = start; frame >= 0; frame--) {\n\t        if (kfPercents[frame] <= percent) {\n\t          break;\n\t        }\n\t      } // PENDING really need to do this ?\n\t\n\t\n\t      frame = Math.min(frame, trackLen - 2);\n\t    } else {\n\t      for (frame = lastFrame; frame < trackLen; frame++) {\n\t        if (kfPercents[frame] > percent) {\n\t          break;\n\t        }\n\t      }\n\t\n\t      frame = Math.min(frame - 1, trackLen - 2);\n\t    }\n\t\n\t    lastFrame = frame;\n\t    lastFramePercent = percent;\n\t    var range = kfPercents[frame + 1] - kfPercents[frame];\n\t\n\t    if (range === 0) {\n\t      return;\n\t    } else {\n\t      w = (percent - kfPercents[frame]) / range;\n\t    }\n\t\n\t    if (useSpline) {\n\t      p1 = kfValues[frame];\n\t      p0 = kfValues[frame === 0 ? frame : frame - 1];\n\t      p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n\t      p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\t\n\t      if (isValueArray) {\n\t        catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);\n\t      } else {\n\t        var value;\n\t\n\t        if (isValueColor) {\n\t          value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);\n\t          value = rgba2String(rgba);\n\t        } else if (isValueString) {\n\t          // String is step(0.5)\n\t          return interpolateString(p1, p2, w);\n\t        } else {\n\t          value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);\n\t        }\n\t\n\t        setter(target, propName, value);\n\t      }\n\t    } else {\n\t      if (isValueArray) {\n\t        interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);\n\t      } else {\n\t        var value;\n\t\n\t        if (isValueColor) {\n\t          interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);\n\t          value = rgba2String(rgba);\n\t        } else if (isValueString) {\n\t          // String is step(0.5)\n\t          return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n\t        } else {\n\t          value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n\t        }\n\t\n\t        setter(target, propName, value);\n\t      }\n\t    }\n\t  };\n\t\n\t  var clip = new Clip({\n\t    target: animator._target,\n\t    life: trackMaxTime,\n\t    loop: animator._loop,\n\t    delay: animator._delay,\n\t    onframe: onframe,\n\t    ondestroy: oneTrackDone\n\t  });\n\t\n\t  if (easing && easing !== 'spline') {\n\t    clip.easing = easing;\n\t  }\n\t\n\t  return clip;\n\t}\n\t/**\n\t * @alias module:zrender/animation/Animator\n\t * @constructor\n\t * @param {Object} target\n\t * @param {boolean} loop\n\t * @param {Function} getter\n\t * @param {Function} setter\n\t */\n\t\n\t\n\tvar Animator = function (target, loop, getter, setter) {\n\t  this._tracks = {};\n\t  this._target = target;\n\t  this._loop = loop || false;\n\t  this._getter = getter || defaultGetter;\n\t  this._setter = setter || defaultSetter;\n\t  this._clipCount = 0;\n\t  this._delay = 0;\n\t  this._doneList = [];\n\t  this._onframeList = [];\n\t  this._clipList = [];\n\t};\n\t\n\tAnimator.prototype = {\n\t  /**\n\t   * 设置动画关键帧\n\t   * @param  {number} time 关键帧时间，单位是ms\n\t   * @param  {Object} props 关键帧的属性值，key-value表示\n\t   * @return {module:zrender/animation/Animator}\n\t   */\n\t  when: function (time\n\t  /* ms */\n\t  , props) {\n\t    var tracks = this._tracks;\n\t\n\t    for (var propName in props) {\n\t      if (!props.hasOwnProperty(propName)) {\n\t        continue;\n\t      }\n\t\n\t      if (!tracks[propName]) {\n\t        tracks[propName] = []; // Invalid value\n\t\n\t        var value = this._getter(this._target, propName);\n\t\n\t        if (value == null) {\n\t          // zrLog('Invalid property ' + propName);\n\t          continue;\n\t        } // If time is 0\n\t        //  Then props is given initialize value\n\t        // Else\n\t        //  Initialize value from current prop value\n\t\n\t\n\t        if (time !== 0) {\n\t          tracks[propName].push({\n\t            time: 0,\n\t            value: cloneValue(value)\n\t          });\n\t        }\n\t      }\n\t\n\t      tracks[propName].push({\n\t        time: time,\n\t        value: props[propName]\n\t      });\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 添加动画每一帧的回调函数\n\t   * @param  {Function} callback\n\t   * @return {module:zrender/animation/Animator}\n\t   */\n\t  during: function (callback) {\n\t    this._onframeList.push(callback);\n\t\n\t    return this;\n\t  },\n\t  pause: function () {\n\t    for (var i = 0; i < this._clipList.length; i++) {\n\t      this._clipList[i].pause();\n\t    }\n\t\n\t    this._paused = true;\n\t  },\n\t  resume: function () {\n\t    for (var i = 0; i < this._clipList.length; i++) {\n\t      this._clipList[i].resume();\n\t    }\n\t\n\t    this._paused = false;\n\t  },\n\t  isPaused: function () {\n\t    return !!this._paused;\n\t  },\n\t  _doneCallback: function () {\n\t    // Clear all tracks\n\t    this._tracks = {}; // Clear all clips\n\t\n\t    this._clipList.length = 0;\n\t    var doneList = this._doneList;\n\t    var len = doneList.length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      doneList[i].call(this);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 开始执行动画\n\t   * @param  {string|Function} [easing]\n\t   *         动画缓动函数，详见{@link module:zrender/animation/easing}\n\t   * @param  {boolean} forceAnimate\n\t   * @return {module:zrender/animation/Animator}\n\t   */\n\t  start: function (easing, forceAnimate) {\n\t    var self = this;\n\t    var clipCount = 0;\n\t\n\t    var oneTrackDone = function () {\n\t      clipCount--;\n\t\n\t      if (!clipCount) {\n\t        self._doneCallback();\n\t      }\n\t    };\n\t\n\t    var lastClip;\n\t\n\t    for (var propName in this._tracks) {\n\t      if (!this._tracks.hasOwnProperty(propName)) {\n\t        continue;\n\t      }\n\t\n\t      var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);\n\t\n\t      if (clip) {\n\t        this._clipList.push(clip);\n\t\n\t        clipCount++; // If start after added to animation\n\t\n\t        if (this.animation) {\n\t          this.animation.addClip(clip);\n\t        }\n\t\n\t        lastClip = clip;\n\t      }\n\t    } // Add during callback on the last clip\n\t\n\t\n\t    if (lastClip) {\n\t      var oldOnFrame = lastClip.onframe;\n\t\n\t      lastClip.onframe = function (target, percent) {\n\t        oldOnFrame(target, percent);\n\t\n\t        for (var i = 0; i < self._onframeList.length; i++) {\n\t          self._onframeList[i](target, percent);\n\t        }\n\t      };\n\t    } // This optimization will help the case that in the upper application\n\t    // the view may be refreshed frequently, where animation will be\n\t    // called repeatly but nothing changed.\n\t\n\t\n\t    if (!clipCount) {\n\t      this._doneCallback();\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 停止动画\n\t   * @param {boolean} forwardToLast If move to last frame before stop\n\t   */\n\t  stop: function (forwardToLast) {\n\t    var clipList = this._clipList;\n\t    var animation = this.animation;\n\t\n\t    for (var i = 0; i < clipList.length; i++) {\n\t      var clip = clipList[i];\n\t\n\t      if (forwardToLast) {\n\t        // Move to last frame before stop\n\t        clip.onframe(this._target, 1);\n\t      }\n\t\n\t      animation && animation.removeClip(clip);\n\t    }\n\t\n\t    clipList.length = 0;\n\t  },\n\t\n\t  /**\n\t   * 设置动画延迟开始的时间\n\t   * @param  {number} time 单位ms\n\t   * @return {module:zrender/animation/Animator}\n\t   */\n\t  delay: function (time) {\n\t    this._delay = time;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 添加动画结束的回调\n\t   * @param  {Function} cb\n\t   * @return {module:zrender/animation/Animator}\n\t   */\n\t  done: function (cb) {\n\t    if (cb) {\n\t      this._doneList.push(cb);\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @return {Array.<module:zrender/animation/Clip>}\n\t   */\n\t  getClips: function () {\n\t    return this._clipList;\n\t  }\n\t};\n\tvar _default = Animator;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar easingFuncs = __webpack_require__(19);\n\t\n\t/**\n\t * 动画主控制器\n\t * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\n\t * @config life(1000) 动画时长\n\t * @config delay(0) 动画延迟时间\n\t * @config loop(true)\n\t * @config gap(0) 循环的间隔时间\n\t * @config onframe\n\t * @config easing(optional)\n\t * @config ondestroy(optional)\n\t * @config onrestart(optional)\n\t *\n\t * TODO pause\n\t */\n\tfunction Clip(options) {\n\t  this._target = options.target; // 生命周期\n\t\n\t  this._life = options.life || 1000; // 延时\n\t\n\t  this._delay = options.delay || 0; // 开始时间\n\t  // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n\t\n\t  this._initialized = false; // 是否循环\n\t\n\t  this.loop = options.loop == null ? false : options.loop;\n\t  this.gap = options.gap || 0;\n\t  this.easing = options.easing || 'Linear';\n\t  this.onframe = options.onframe;\n\t  this.ondestroy = options.ondestroy;\n\t  this.onrestart = options.onrestart;\n\t  this._pausedTime = 0;\n\t  this._paused = false;\n\t}\n\t\n\tClip.prototype = {\n\t  constructor: Clip,\n\t  step: function (globalTime, deltaTime) {\n\t    // Set startTime on first step, or _startTime may has milleseconds different between clips\n\t    // PENDING\n\t    if (!this._initialized) {\n\t      this._startTime = globalTime + this._delay;\n\t      this._initialized = true;\n\t    }\n\t\n\t    if (this._paused) {\n\t      this._pausedTime += deltaTime;\n\t      return;\n\t    }\n\t\n\t    var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // 还没开始\n\t\n\t    if (percent < 0) {\n\t      return;\n\t    }\n\t\n\t    percent = Math.min(percent, 1);\n\t    var easing = this.easing;\n\t    var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n\t    var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;\n\t    this.fire('frame', schedule); // 结束\n\t\n\t    if (percent == 1) {\n\t      if (this.loop) {\n\t        this.restart(globalTime); // 重新开始周期\n\t        // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n\t\n\t        return 'restart';\n\t      } // 动画完成将这个控制器标识为待删除\n\t      // 在Animation.update中进行批量删除\n\t\n\t\n\t      this._needsRemove = true;\n\t      return 'destroy';\n\t    }\n\t\n\t    return null;\n\t  },\n\t  restart: function (globalTime) {\n\t    var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n\t    this._startTime = globalTime - remainder + this.gap;\n\t    this._pausedTime = 0;\n\t    this._needsRemove = false;\n\t  },\n\t  fire: function (eventType, arg) {\n\t    eventType = 'on' + eventType;\n\t\n\t    if (this[eventType]) {\n\t      this[eventType](this._target, arg);\n\t    }\n\t  },\n\t  pause: function () {\n\t    this._paused = true;\n\t  },\n\t  resume: function () {\n\t    this._paused = false;\n\t  }\n\t};\n\tvar _default = Clip;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\n\t * @see http://sole.github.io/tween.js/examples/03_graphs.html\n\t * @exports zrender/animation/easing\n\t */\n\tvar easing = {\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  linear: function (k) {\n\t    return k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quadraticIn: function (k) {\n\t    return k * k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quadraticOut: function (k) {\n\t    return k * (2 - k);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quadraticInOut: function (k) {\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * k * k;\n\t    }\n\t\n\t    return -0.5 * (--k * (k - 2) - 1);\n\t  },\n\t  // 三次方的缓动（t^3）\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  cubicIn: function (k) {\n\t    return k * k * k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  cubicOut: function (k) {\n\t    return --k * k * k + 1;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  cubicInOut: function (k) {\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * k * k * k;\n\t    }\n\t\n\t    return 0.5 * ((k -= 2) * k * k + 2);\n\t  },\n\t  // 四次方的缓动（t^4）\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quarticIn: function (k) {\n\t    return k * k * k * k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quarticOut: function (k) {\n\t    return 1 - --k * k * k * k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quarticInOut: function (k) {\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * k * k * k * k;\n\t    }\n\t\n\t    return -0.5 * ((k -= 2) * k * k * k - 2);\n\t  },\n\t  // 五次方的缓动（t^5）\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quinticIn: function (k) {\n\t    return k * k * k * k * k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quinticOut: function (k) {\n\t    return --k * k * k * k * k + 1;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quinticInOut: function (k) {\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * k * k * k * k * k;\n\t    }\n\t\n\t    return 0.5 * ((k -= 2) * k * k * k * k + 2);\n\t  },\n\t  // 正弦曲线的缓动（sin(t)）\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  sinusoidalIn: function (k) {\n\t    return 1 - Math.cos(k * Math.PI / 2);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  sinusoidalOut: function (k) {\n\t    return Math.sin(k * Math.PI / 2);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  sinusoidalInOut: function (k) {\n\t    return 0.5 * (1 - Math.cos(Math.PI * k));\n\t  },\n\t  // 指数曲线的缓动（2^t）\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  exponentialIn: function (k) {\n\t    return k === 0 ? 0 : Math.pow(1024, k - 1);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  exponentialOut: function (k) {\n\t    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  exponentialInOut: function (k) {\n\t    if (k === 0) {\n\t      return 0;\n\t    }\n\t\n\t    if (k === 1) {\n\t      return 1;\n\t    }\n\t\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * Math.pow(1024, k - 1);\n\t    }\n\t\n\t    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n\t  },\n\t  // 圆形曲线的缓动（sqrt(1-t^2)）\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  circularIn: function (k) {\n\t    return 1 - Math.sqrt(1 - k * k);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  circularOut: function (k) {\n\t    return Math.sqrt(1 - --k * k);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  circularInOut: function (k) {\n\t    if ((k *= 2) < 1) {\n\t      return -0.5 * (Math.sqrt(1 - k * k) - 1);\n\t    }\n\t\n\t    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\t  },\n\t  // 创建类似于弹簧在停止前来回振荡的动画\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  elasticIn: function (k) {\n\t    var s;\n\t    var a = 0.1;\n\t    var p = 0.4;\n\t\n\t    if (k === 0) {\n\t      return 0;\n\t    }\n\t\n\t    if (k === 1) {\n\t      return 1;\n\t    }\n\t\n\t    if (!a || a < 1) {\n\t      a = 1;\n\t      s = p / 4;\n\t    } else {\n\t      s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t    }\n\t\n\t    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  elasticOut: function (k) {\n\t    var s;\n\t    var a = 0.1;\n\t    var p = 0.4;\n\t\n\t    if (k === 0) {\n\t      return 0;\n\t    }\n\t\n\t    if (k === 1) {\n\t      return 1;\n\t    }\n\t\n\t    if (!a || a < 1) {\n\t      a = 1;\n\t      s = p / 4;\n\t    } else {\n\t      s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t    }\n\t\n\t    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  elasticInOut: function (k) {\n\t    var s;\n\t    var a = 0.1;\n\t    var p = 0.4;\n\t\n\t    if (k === 0) {\n\t      return 0;\n\t    }\n\t\n\t    if (k === 1) {\n\t      return 1;\n\t    }\n\t\n\t    if (!a || a < 1) {\n\t      a = 1;\n\t      s = p / 4;\n\t    } else {\n\t      s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t    }\n\t\n\t    if ((k *= 2) < 1) {\n\t      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n\t    }\n\t\n\t    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t  },\n\t  // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  backIn: function (k) {\n\t    var s = 1.70158;\n\t    return k * k * ((s + 1) * k - s);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  backOut: function (k) {\n\t    var s = 1.70158;\n\t    return --k * k * ((s + 1) * k + s) + 1;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  backInOut: function (k) {\n\t    var s = 1.70158 * 1.525;\n\t\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * (k * k * ((s + 1) * k - s));\n\t    }\n\t\n\t    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\t  },\n\t  // 创建弹跳效果\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  bounceIn: function (k) {\n\t    return 1 - easing.bounceOut(1 - k);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  bounceOut: function (k) {\n\t    if (k < 1 / 2.75) {\n\t      return 7.5625 * k * k;\n\t    } else if (k < 2 / 2.75) {\n\t      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n\t    } else if (k < 2.5 / 2.75) {\n\t      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n\t    } else {\n\t      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n\t    }\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  bounceInOut: function (k) {\n\t    if (k < 0.5) {\n\t      return easing.bounceIn(k * 2) * 0.5;\n\t    }\n\t\n\t    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n\t  }\n\t};\n\tvar _default = easing;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar LRU = __webpack_require__(21);\n\t\n\tvar kCSSColorTable = {\n\t  'transparent': [0, 0, 0, 0],\n\t  'aliceblue': [240, 248, 255, 1],\n\t  'antiquewhite': [250, 235, 215, 1],\n\t  'aqua': [0, 255, 255, 1],\n\t  'aquamarine': [127, 255, 212, 1],\n\t  'azure': [240, 255, 255, 1],\n\t  'beige': [245, 245, 220, 1],\n\t  'bisque': [255, 228, 196, 1],\n\t  'black': [0, 0, 0, 1],\n\t  'blanchedalmond': [255, 235, 205, 1],\n\t  'blue': [0, 0, 255, 1],\n\t  'blueviolet': [138, 43, 226, 1],\n\t  'brown': [165, 42, 42, 1],\n\t  'burlywood': [222, 184, 135, 1],\n\t  'cadetblue': [95, 158, 160, 1],\n\t  'chartreuse': [127, 255, 0, 1],\n\t  'chocolate': [210, 105, 30, 1],\n\t  'coral': [255, 127, 80, 1],\n\t  'cornflowerblue': [100, 149, 237, 1],\n\t  'cornsilk': [255, 248, 220, 1],\n\t  'crimson': [220, 20, 60, 1],\n\t  'cyan': [0, 255, 255, 1],\n\t  'darkblue': [0, 0, 139, 1],\n\t  'darkcyan': [0, 139, 139, 1],\n\t  'darkgoldenrod': [184, 134, 11, 1],\n\t  'darkgray': [169, 169, 169, 1],\n\t  'darkgreen': [0, 100, 0, 1],\n\t  'darkgrey': [169, 169, 169, 1],\n\t  'darkkhaki': [189, 183, 107, 1],\n\t  'darkmagenta': [139, 0, 139, 1],\n\t  'darkolivegreen': [85, 107, 47, 1],\n\t  'darkorange': [255, 140, 0, 1],\n\t  'darkorchid': [153, 50, 204, 1],\n\t  'darkred': [139, 0, 0, 1],\n\t  'darksalmon': [233, 150, 122, 1],\n\t  'darkseagreen': [143, 188, 143, 1],\n\t  'darkslateblue': [72, 61, 139, 1],\n\t  'darkslategray': [47, 79, 79, 1],\n\t  'darkslategrey': [47, 79, 79, 1],\n\t  'darkturquoise': [0, 206, 209, 1],\n\t  'darkviolet': [148, 0, 211, 1],\n\t  'deeppink': [255, 20, 147, 1],\n\t  'deepskyblue': [0, 191, 255, 1],\n\t  'dimgray': [105, 105, 105, 1],\n\t  'dimgrey': [105, 105, 105, 1],\n\t  'dodgerblue': [30, 144, 255, 1],\n\t  'firebrick': [178, 34, 34, 1],\n\t  'floralwhite': [255, 250, 240, 1],\n\t  'forestgreen': [34, 139, 34, 1],\n\t  'fuchsia': [255, 0, 255, 1],\n\t  'gainsboro': [220, 220, 220, 1],\n\t  'ghostwhite': [248, 248, 255, 1],\n\t  'gold': [255, 215, 0, 1],\n\t  'goldenrod': [218, 165, 32, 1],\n\t  'gray': [128, 128, 128, 1],\n\t  'green': [0, 128, 0, 1],\n\t  'greenyellow': [173, 255, 47, 1],\n\t  'grey': [128, 128, 128, 1],\n\t  'honeydew': [240, 255, 240, 1],\n\t  'hotpink': [255, 105, 180, 1],\n\t  'indianred': [205, 92, 92, 1],\n\t  'indigo': [75, 0, 130, 1],\n\t  'ivory': [255, 255, 240, 1],\n\t  'khaki': [240, 230, 140, 1],\n\t  'lavender': [230, 230, 250, 1],\n\t  'lavenderblush': [255, 240, 245, 1],\n\t  'lawngreen': [124, 252, 0, 1],\n\t  'lemonchiffon': [255, 250, 205, 1],\n\t  'lightblue': [173, 216, 230, 1],\n\t  'lightcoral': [240, 128, 128, 1],\n\t  'lightcyan': [224, 255, 255, 1],\n\t  'lightgoldenrodyellow': [250, 250, 210, 1],\n\t  'lightgray': [211, 211, 211, 1],\n\t  'lightgreen': [144, 238, 144, 1],\n\t  'lightgrey': [211, 211, 211, 1],\n\t  'lightpink': [255, 182, 193, 1],\n\t  'lightsalmon': [255, 160, 122, 1],\n\t  'lightseagreen': [32, 178, 170, 1],\n\t  'lightskyblue': [135, 206, 250, 1],\n\t  'lightslategray': [119, 136, 153, 1],\n\t  'lightslategrey': [119, 136, 153, 1],\n\t  'lightsteelblue': [176, 196, 222, 1],\n\t  'lightyellow': [255, 255, 224, 1],\n\t  'lime': [0, 255, 0, 1],\n\t  'limegreen': [50, 205, 50, 1],\n\t  'linen': [250, 240, 230, 1],\n\t  'magenta': [255, 0, 255, 1],\n\t  'maroon': [128, 0, 0, 1],\n\t  'mediumaquamarine': [102, 205, 170, 1],\n\t  'mediumblue': [0, 0, 205, 1],\n\t  'mediumorchid': [186, 85, 211, 1],\n\t  'mediumpurple': [147, 112, 219, 1],\n\t  'mediumseagreen': [60, 179, 113, 1],\n\t  'mediumslateblue': [123, 104, 238, 1],\n\t  'mediumspringgreen': [0, 250, 154, 1],\n\t  'mediumturquoise': [72, 209, 204, 1],\n\t  'mediumvioletred': [199, 21, 133, 1],\n\t  'midnightblue': [25, 25, 112, 1],\n\t  'mintcream': [245, 255, 250, 1],\n\t  'mistyrose': [255, 228, 225, 1],\n\t  'moccasin': [255, 228, 181, 1],\n\t  'navajowhite': [255, 222, 173, 1],\n\t  'navy': [0, 0, 128, 1],\n\t  'oldlace': [253, 245, 230, 1],\n\t  'olive': [128, 128, 0, 1],\n\t  'olivedrab': [107, 142, 35, 1],\n\t  'orange': [255, 165, 0, 1],\n\t  'orangered': [255, 69, 0, 1],\n\t  'orchid': [218, 112, 214, 1],\n\t  'palegoldenrod': [238, 232, 170, 1],\n\t  'palegreen': [152, 251, 152, 1],\n\t  'paleturquoise': [175, 238, 238, 1],\n\t  'palevioletred': [219, 112, 147, 1],\n\t  'papayawhip': [255, 239, 213, 1],\n\t  'peachpuff': [255, 218, 185, 1],\n\t  'peru': [205, 133, 63, 1],\n\t  'pink': [255, 192, 203, 1],\n\t  'plum': [221, 160, 221, 1],\n\t  'powderblue': [176, 224, 230, 1],\n\t  'purple': [128, 0, 128, 1],\n\t  'red': [255, 0, 0, 1],\n\t  'rosybrown': [188, 143, 143, 1],\n\t  'royalblue': [65, 105, 225, 1],\n\t  'saddlebrown': [139, 69, 19, 1],\n\t  'salmon': [250, 128, 114, 1],\n\t  'sandybrown': [244, 164, 96, 1],\n\t  'seagreen': [46, 139, 87, 1],\n\t  'seashell': [255, 245, 238, 1],\n\t  'sienna': [160, 82, 45, 1],\n\t  'silver': [192, 192, 192, 1],\n\t  'skyblue': [135, 206, 235, 1],\n\t  'slateblue': [106, 90, 205, 1],\n\t  'slategray': [112, 128, 144, 1],\n\t  'slategrey': [112, 128, 144, 1],\n\t  'snow': [255, 250, 250, 1],\n\t  'springgreen': [0, 255, 127, 1],\n\t  'steelblue': [70, 130, 180, 1],\n\t  'tan': [210, 180, 140, 1],\n\t  'teal': [0, 128, 128, 1],\n\t  'thistle': [216, 191, 216, 1],\n\t  'tomato': [255, 99, 71, 1],\n\t  'turquoise': [64, 224, 208, 1],\n\t  'violet': [238, 130, 238, 1],\n\t  'wheat': [245, 222, 179, 1],\n\t  'white': [255, 255, 255, 1],\n\t  'whitesmoke': [245, 245, 245, 1],\n\t  'yellow': [255, 255, 0, 1],\n\t  'yellowgreen': [154, 205, 50, 1]\n\t};\n\t\n\tfunction clampCssByte(i) {\n\t  // Clamp to integer 0 .. 255.\n\t  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\t\n\t  return i < 0 ? 0 : i > 255 ? 255 : i;\n\t}\n\t\n\tfunction clampCssAngle(i) {\n\t  // Clamp to integer 0 .. 360.\n\t  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\t\n\t  return i < 0 ? 0 : i > 360 ? 360 : i;\n\t}\n\t\n\tfunction clampCssFloat(f) {\n\t  // Clamp to float 0.0 .. 1.0.\n\t  return f < 0 ? 0 : f > 1 ? 1 : f;\n\t}\n\t\n\tfunction parseCssInt(str) {\n\t  // int or percentage.\n\t  if (str.length && str.charAt(str.length - 1) === '%') {\n\t    return clampCssByte(parseFloat(str) / 100 * 255);\n\t  }\n\t\n\t  return clampCssByte(parseInt(str, 10));\n\t}\n\t\n\tfunction parseCssFloat(str) {\n\t  // float or percentage.\n\t  if (str.length && str.charAt(str.length - 1) === '%') {\n\t    return clampCssFloat(parseFloat(str) / 100);\n\t  }\n\t\n\t  return clampCssFloat(parseFloat(str));\n\t}\n\t\n\tfunction cssHueToRgb(m1, m2, h) {\n\t  if (h < 0) {\n\t    h += 1;\n\t  } else if (h > 1) {\n\t    h -= 1;\n\t  }\n\t\n\t  if (h * 6 < 1) {\n\t    return m1 + (m2 - m1) * h * 6;\n\t  }\n\t\n\t  if (h * 2 < 1) {\n\t    return m2;\n\t  }\n\t\n\t  if (h * 3 < 2) {\n\t    return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n\t  }\n\t\n\t  return m1;\n\t}\n\t\n\tfunction lerpNumber(a, b, p) {\n\t  return a + (b - a) * p;\n\t}\n\t\n\tfunction setRgba(out, r, g, b, a) {\n\t  out[0] = r;\n\t  out[1] = g;\n\t  out[2] = b;\n\t  out[3] = a;\n\t  return out;\n\t}\n\t\n\tfunction copyRgba(out, a) {\n\t  out[0] = a[0];\n\t  out[1] = a[1];\n\t  out[2] = a[2];\n\t  out[3] = a[3];\n\t  return out;\n\t}\n\t\n\tvar colorCache = new LRU(20);\n\tvar lastRemovedArr = null;\n\t\n\tfunction putToCache(colorStr, rgbaArr) {\n\t  // Reuse removed array\n\t  if (lastRemovedArr) {\n\t    copyRgba(lastRemovedArr, rgbaArr);\n\t  }\n\t\n\t  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());\n\t}\n\t/**\n\t * @param {string} colorStr\n\t * @param {Array.<number>} out\n\t * @return {Array.<number>}\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\t\n\tfunction parse(colorStr, rgbaArr) {\n\t  if (!colorStr) {\n\t    return;\n\t  }\n\t\n\t  rgbaArr = rgbaArr || [];\n\t  var cached = colorCache.get(colorStr);\n\t\n\t  if (cached) {\n\t    return copyRgba(rgbaArr, cached);\n\t  } // colorStr may be not string\n\t\n\t\n\t  colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.\n\t\n\t  var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.\n\t\n\t  if (str in kCSSColorTable) {\n\t    copyRgba(rgbaArr, kCSSColorTable[str]);\n\t    putToCache(colorStr, rgbaArr);\n\t    return rgbaArr;\n\t  } // #abc and #abc123 syntax.\n\t\n\t\n\t  if (str.charAt(0) === '#') {\n\t    if (str.length === 4) {\n\t      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\t\n\t      if (!(iv >= 0 && iv <= 0xfff)) {\n\t        setRgba(rgbaArr, 0, 0, 0, 1);\n\t        return; // Covers NaN.\n\t      }\n\t\n\t      setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);\n\t      putToCache(colorStr, rgbaArr);\n\t      return rgbaArr;\n\t    } else if (str.length === 7) {\n\t      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\t\n\t      if (!(iv >= 0 && iv <= 0xffffff)) {\n\t        setRgba(rgbaArr, 0, 0, 0, 1);\n\t        return; // Covers NaN.\n\t      }\n\t\n\t      setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);\n\t      putToCache(colorStr, rgbaArr);\n\t      return rgbaArr;\n\t    }\n\t\n\t    return;\n\t  }\n\t\n\t  var op = str.indexOf('('),\n\t      ep = str.indexOf(')');\n\t\n\t  if (op !== -1 && ep + 1 === str.length) {\n\t    var fname = str.substr(0, op);\n\t    var params = str.substr(op + 1, ep - (op + 1)).split(',');\n\t    var alpha = 1; // To allow case fallthrough.\n\t\n\t    switch (fname) {\n\t      case 'rgba':\n\t        if (params.length !== 4) {\n\t          setRgba(rgbaArr, 0, 0, 0, 1);\n\t          return;\n\t        }\n\t\n\t        alpha = parseCssFloat(params.pop());\n\t      // jshint ignore:line\n\t      // Fall through.\n\t\n\t      case 'rgb':\n\t        if (params.length !== 3) {\n\t          setRgba(rgbaArr, 0, 0, 0, 1);\n\t          return;\n\t        }\n\t\n\t        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);\n\t        putToCache(colorStr, rgbaArr);\n\t        return rgbaArr;\n\t\n\t      case 'hsla':\n\t        if (params.length !== 4) {\n\t          setRgba(rgbaArr, 0, 0, 0, 1);\n\t          return;\n\t        }\n\t\n\t        params[3] = parseCssFloat(params[3]);\n\t        hsla2rgba(params, rgbaArr);\n\t        putToCache(colorStr, rgbaArr);\n\t        return rgbaArr;\n\t\n\t      case 'hsl':\n\t        if (params.length !== 3) {\n\t          setRgba(rgbaArr, 0, 0, 0, 1);\n\t          return;\n\t        }\n\t\n\t        hsla2rgba(params, rgbaArr);\n\t        putToCache(colorStr, rgbaArr);\n\t        return rgbaArr;\n\t\n\t      default:\n\t        return;\n\t    }\n\t  }\n\t\n\t  setRgba(rgbaArr, 0, 0, 0, 1);\n\t  return;\n\t}\n\t/**\n\t * @param {Array.<number>} hsla\n\t * @param {Array.<number>} rgba\n\t * @return {Array.<number>} rgba\n\t */\n\t\n\t\n\tfunction hsla2rgba(hsla, rgba) {\n\t  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1\n\t  // NOTE(deanm): According to the CSS spec s/l should only be\n\t  // percentages, but we don't bother and let float or percentage.\n\t\n\t  var s = parseCssFloat(hsla[1]);\n\t  var l = parseCssFloat(hsla[2]);\n\t  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n\t  var m1 = l * 2 - m2;\n\t  rgba = rgba || [];\n\t  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);\n\t\n\t  if (hsla.length === 4) {\n\t    rgba[3] = hsla[3];\n\t  }\n\t\n\t  return rgba;\n\t}\n\t/**\n\t * @param {Array.<number>} rgba\n\t * @return {Array.<number>} hsla\n\t */\n\t\n\t\n\tfunction rgba2hsla(rgba) {\n\t  if (!rgba) {\n\t    return;\n\t  } // RGB from 0 to 255\n\t\n\t\n\t  var R = rgba[0] / 255;\n\t  var G = rgba[1] / 255;\n\t  var B = rgba[2] / 255;\n\t  var vMin = Math.min(R, G, B); // Min. value of RGB\n\t\n\t  var vMax = Math.max(R, G, B); // Max. value of RGB\n\t\n\t  var delta = vMax - vMin; // Delta RGB value\n\t\n\t  var L = (vMax + vMin) / 2;\n\t  var H;\n\t  var S; // HSL results from 0 to 1\n\t\n\t  if (delta === 0) {\n\t    H = 0;\n\t    S = 0;\n\t  } else {\n\t    if (L < 0.5) {\n\t      S = delta / (vMax + vMin);\n\t    } else {\n\t      S = delta / (2 - vMax - vMin);\n\t    }\n\t\n\t    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;\n\t    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;\n\t    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;\n\t\n\t    if (R === vMax) {\n\t      H = deltaB - deltaG;\n\t    } else if (G === vMax) {\n\t      H = 1 / 3 + deltaR - deltaB;\n\t    } else if (B === vMax) {\n\t      H = 2 / 3 + deltaG - deltaR;\n\t    }\n\t\n\t    if (H < 0) {\n\t      H += 1;\n\t    }\n\t\n\t    if (H > 1) {\n\t      H -= 1;\n\t    }\n\t  }\n\t\n\t  var hsla = [H * 360, S, L];\n\t\n\t  if (rgba[3] != null) {\n\t    hsla.push(rgba[3]);\n\t  }\n\t\n\t  return hsla;\n\t}\n\t/**\n\t * @param {string} color\n\t * @param {number} level\n\t * @return {string}\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\t\n\tfunction lift(color, level) {\n\t  var colorArr = parse(color);\n\t\n\t  if (colorArr) {\n\t    for (var i = 0; i < 3; i++) {\n\t      if (level < 0) {\n\t        colorArr[i] = colorArr[i] * (1 - level) | 0;\n\t      } else {\n\t        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;\n\t      }\n\t    }\n\t\n\t    return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n\t  }\n\t}\n\t/**\n\t * @param {string} color\n\t * @return {string}\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\t\n\tfunction toHex(color) {\n\t  var colorArr = parse(color);\n\t\n\t  if (colorArr) {\n\t    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);\n\t  }\n\t}\n\t/**\n\t * Map value to color. Faster than lerp methods because color is represented by rgba array.\n\t * @param {number} normalizedValue A float between 0 and 1.\n\t * @param {Array.<Array.<number>>} colors List of rgba color array\n\t * @param {Array.<number>} [out] Mapped gba color array\n\t * @return {Array.<number>} will be null/undefined if input illegal.\n\t */\n\t\n\t\n\tfunction fastLerp(normalizedValue, colors, out) {\n\t  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n\t    return;\n\t  }\n\t\n\t  out = out || [];\n\t  var value = normalizedValue * (colors.length - 1);\n\t  var leftIndex = Math.floor(value);\n\t  var rightIndex = Math.ceil(value);\n\t  var leftColor = colors[leftIndex];\n\t  var rightColor = colors[rightIndex];\n\t  var dv = value - leftIndex;\n\t  out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));\n\t  out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));\n\t  out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));\n\t  out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));\n\t  return out;\n\t}\n\t/**\n\t * @deprecated\n\t */\n\t\n\t\n\tvar fastMapToColor = fastLerp;\n\t/**\n\t * @param {number} normalizedValue A float between 0 and 1.\n\t * @param {Array.<string>} colors Color list.\n\t * @param {boolean=} fullOutput Default false.\n\t * @return {(string|Object)} Result color. If fullOutput,\n\t *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\tfunction lerp(normalizedValue, colors, fullOutput) {\n\t  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n\t    return;\n\t  }\n\t\n\t  var value = normalizedValue * (colors.length - 1);\n\t  var leftIndex = Math.floor(value);\n\t  var rightIndex = Math.ceil(value);\n\t  var leftColor = parse(colors[leftIndex]);\n\t  var rightColor = parse(colors[rightIndex]);\n\t  var dv = value - leftIndex;\n\t  var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');\n\t  return fullOutput ? {\n\t    color: color,\n\t    leftIndex: leftIndex,\n\t    rightIndex: rightIndex,\n\t    value: value\n\t  } : color;\n\t}\n\t/**\n\t * @deprecated\n\t */\n\t\n\t\n\tvar mapToColor = lerp;\n\t/**\n\t * @param {string} color\n\t * @param {number=} h 0 ~ 360, ignore when null.\n\t * @param {number=} s 0 ~ 1, ignore when null.\n\t * @param {number=} l 0 ~ 1, ignore when null.\n\t * @return {string} Color string in rgba format.\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\tfunction modifyHSL(color, h, s, l) {\n\t  color = parse(color);\n\t\n\t  if (color) {\n\t    color = rgba2hsla(color);\n\t    h != null && (color[0] = clampCssAngle(h));\n\t    s != null && (color[1] = parseCssFloat(s));\n\t    l != null && (color[2] = parseCssFloat(l));\n\t    return stringify(hsla2rgba(color), 'rgba');\n\t  }\n\t}\n\t/**\n\t * @param {string} color\n\t * @param {number=} alpha 0 ~ 1\n\t * @return {string} Color string in rgba format.\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\t\n\tfunction modifyAlpha(color, alpha) {\n\t  color = parse(color);\n\t\n\t  if (color && alpha != null) {\n\t    color[3] = clampCssFloat(alpha);\n\t    return stringify(color, 'rgba');\n\t  }\n\t}\n\t/**\n\t * @param {Array.<number>} arrColor like [12,33,44,0.4]\n\t * @param {string} type 'rgba', 'hsva', ...\n\t * @return {string} Result color. (If input illegal, return undefined).\n\t */\n\t\n\t\n\tfunction stringify(arrColor, type) {\n\t  if (!arrColor || !arrColor.length) {\n\t    return;\n\t  }\n\t\n\t  var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\t\n\t  if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n\t    colorStr += ',' + arrColor[3];\n\t  }\n\t\n\t  return type + '(' + colorStr + ')';\n\t}\n\t\n\texports.parse = parse;\n\texports.lift = lift;\n\texports.toHex = toHex;\n\texports.fastLerp = fastLerp;\n\texports.fastMapToColor = fastMapToColor;\n\texports.lerp = lerp;\n\texports.mapToColor = mapToColor;\n\texports.modifyHSL = modifyHSL;\n\texports.modifyAlpha = modifyAlpha;\n\texports.stringify = stringify;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports) {\n\n\t// Simple LRU cache use doubly linked list\n\t// @module zrender/core/LRU\n\t\n\t/**\n\t * Simple double linked list. Compared with array, it has O(1) remove operation.\n\t * @constructor\n\t */\n\tvar LinkedList = function () {\n\t  /**\n\t   * @type {module:zrender/core/LRU~Entry}\n\t   */\n\t  this.head = null;\n\t  /**\n\t   * @type {module:zrender/core/LRU~Entry}\n\t   */\n\t\n\t  this.tail = null;\n\t  this._len = 0;\n\t};\n\t\n\tvar linkedListProto = LinkedList.prototype;\n\t/**\n\t * Insert a new value at the tail\n\t * @param  {} val\n\t * @return {module:zrender/core/LRU~Entry}\n\t */\n\t\n\tlinkedListProto.insert = function (val) {\n\t  var entry = new Entry(val);\n\t  this.insertEntry(entry);\n\t  return entry;\n\t};\n\t/**\n\t * Insert an entry at the tail\n\t * @param  {module:zrender/core/LRU~Entry} entry\n\t */\n\t\n\t\n\tlinkedListProto.insertEntry = function (entry) {\n\t  if (!this.head) {\n\t    this.head = this.tail = entry;\n\t  } else {\n\t    this.tail.next = entry;\n\t    entry.prev = this.tail;\n\t    entry.next = null;\n\t    this.tail = entry;\n\t  }\n\t\n\t  this._len++;\n\t};\n\t/**\n\t * Remove entry.\n\t * @param  {module:zrender/core/LRU~Entry} entry\n\t */\n\t\n\t\n\tlinkedListProto.remove = function (entry) {\n\t  var prev = entry.prev;\n\t  var next = entry.next;\n\t\n\t  if (prev) {\n\t    prev.next = next;\n\t  } else {\n\t    // Is head\n\t    this.head = next;\n\t  }\n\t\n\t  if (next) {\n\t    next.prev = prev;\n\t  } else {\n\t    // Is tail\n\t    this.tail = prev;\n\t  }\n\t\n\t  entry.next = entry.prev = null;\n\t  this._len--;\n\t};\n\t/**\n\t * @return {number}\n\t */\n\t\n\t\n\tlinkedListProto.len = function () {\n\t  return this._len;\n\t};\n\t/**\n\t * Clear list\n\t */\n\t\n\t\n\tlinkedListProto.clear = function () {\n\t  this.head = this.tail = null;\n\t  this._len = 0;\n\t};\n\t/**\n\t * @constructor\n\t * @param {} val\n\t */\n\t\n\t\n\tvar Entry = function (val) {\n\t  /**\n\t   * @type {}\n\t   */\n\t  this.value = val;\n\t  /**\n\t   * @type {module:zrender/core/LRU~Entry}\n\t   */\n\t\n\t  this.next;\n\t  /**\n\t   * @type {module:zrender/core/LRU~Entry}\n\t   */\n\t\n\t  this.prev;\n\t};\n\t/**\n\t * LRU Cache\n\t * @constructor\n\t * @alias module:zrender/core/LRU\n\t */\n\t\n\t\n\tvar LRU = function (maxSize) {\n\t  this._list = new LinkedList();\n\t  this._map = {};\n\t  this._maxSize = maxSize || 10;\n\t  this._lastRemovedEntry = null;\n\t};\n\t\n\tvar LRUProto = LRU.prototype;\n\t/**\n\t * @param  {string} key\n\t * @param  {} value\n\t * @return {} Removed value\n\t */\n\t\n\tLRUProto.put = function (key, value) {\n\t  var list = this._list;\n\t  var map = this._map;\n\t  var removed = null;\n\t\n\t  if (map[key] == null) {\n\t    var len = list.len(); // Reuse last removed entry\n\t\n\t    var entry = this._lastRemovedEntry;\n\t\n\t    if (len >= this._maxSize && len > 0) {\n\t      // Remove the least recently used\n\t      var leastUsedEntry = list.head;\n\t      list.remove(leastUsedEntry);\n\t      delete map[leastUsedEntry.key];\n\t      removed = leastUsedEntry.value;\n\t      this._lastRemovedEntry = leastUsedEntry;\n\t    }\n\t\n\t    if (entry) {\n\t      entry.value = value;\n\t    } else {\n\t      entry = new Entry(value);\n\t    }\n\t\n\t    entry.key = key;\n\t    list.insertEntry(entry);\n\t    map[key] = entry;\n\t  }\n\t\n\t  return removed;\n\t};\n\t/**\n\t * @param  {string} key\n\t * @return {}\n\t */\n\t\n\t\n\tLRUProto.get = function (key) {\n\t  var entry = this._map[key];\n\t  var list = this._list;\n\t\n\t  if (entry != null) {\n\t    // Put the latest used entry in the tail\n\t    if (entry !== list.tail) {\n\t      list.remove(entry);\n\t      list.insertEntry(entry);\n\t    }\n\t\n\t    return entry.value;\n\t  }\n\t};\n\t/**\n\t * Clear the cache\n\t */\n\t\n\t\n\tLRUProto.clear = function () {\n\t  this._list.clear();\n\t\n\t  this._map = {};\n\t};\n\t\n\tvar _default = LRU;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _config = __webpack_require__(23);\n\t\n\tvar debugMode = _config.debugMode;\n\t\n\tvar log = function () {};\n\t\n\tif (debugMode === 1) {\n\t  log = function () {\n\t    for (var k in arguments) {\n\t      throw new Error(arguments[k]);\n\t    }\n\t  };\n\t} else if (debugMode > 1) {\n\t  log = function () {\n\t    for (var k in arguments) {\n\t      console.log(arguments[k]);\n\t    }\n\t  };\n\t}\n\t\n\tvar _default = log;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports) {\n\n\tvar dpr = 1; // If in browser environment\n\t\n\tif (typeof window !== 'undefined') {\n\t  dpr = Math.max(window.devicePixelRatio || 1, 1);\n\t}\n\t/**\n\t * config默认配置项\n\t * @exports zrender/config\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t */\n\t\n\t/**\n\t * debug日志选项：catchBrushException为true下有效\n\t * 0 : 不生成debug数据，发布用\n\t * 1 : 异常抛出，调试用\n\t * 2 : 控制台输出，调试用\n\t */\n\t\n\t\n\tvar debugMode = 0; // retina 屏幕优化\n\t\n\tvar devicePixelRatio = dpr;\n\texports.debugMode = debugMode;\n\texports.devicePixelRatio = devicePixelRatio;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar textHelper = __webpack_require__(25);\n\t\n\tvar BoundingRect = __webpack_require__(27);\n\t\n\t/**\n\t * Mixin for drawing text in a element bounding rect\n\t * @module zrender/mixin/RectText\n\t */\n\tvar tmpRect = new BoundingRect();\n\t\n\tvar RectText = function () {};\n\t\n\tRectText.prototype = {\n\t  constructor: RectText,\n\t\n\t  /**\n\t   * Draw text in a rect with specified position.\n\t   * @param  {CanvasRenderingContext2D} ctx\n\t   * @param  {Object} rect Displayable rect\n\t   */\n\t  drawRectText: function (ctx, rect) {\n\t    var style = this.style;\n\t    rect = style.textRect || rect; // Optimize, avoid normalize every time.\n\t\n\t    this.__dirty && textHelper.normalizeTextStyle(style, true);\n\t    var text = style.text; // Convert to string\n\t\n\t    text != null && (text += '');\n\t\n\t    if (!textHelper.needDrawText(text, style)) {\n\t      return;\n\t    } // FIXME\n\t\n\t\n\t    ctx.save(); // Transform rect to view space\n\t\n\t    var transform = this.transform;\n\t\n\t    if (!style.transformText) {\n\t      if (transform) {\n\t        tmpRect.copy(rect);\n\t        tmpRect.applyTransform(transform);\n\t        rect = tmpRect;\n\t      }\n\t    } else {\n\t      this.setTransform(ctx);\n\t    } // transformText and textRotation can not be used at the same time.\n\t\n\t\n\t    textHelper.renderText(this, ctx, text, style, rect);\n\t    ctx.restore();\n\t  }\n\t};\n\tvar _default = RectText;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _util = __webpack_require__(5);\n\t\n\tvar retrieve2 = _util.retrieve2;\n\tvar retrieve3 = _util.retrieve3;\n\tvar each = _util.each;\n\tvar normalizeCssArray = _util.normalizeCssArray;\n\tvar isString = _util.isString;\n\tvar isObject = _util.isObject;\n\t\n\tvar textContain = __webpack_require__(26);\n\t\n\tvar roundRectHelper = __webpack_require__(29);\n\t\n\tvar imageHelper = __webpack_require__(28);\n\t\n\t// TODO: Have not support 'start', 'end' yet.\n\tvar VALID_TEXT_ALIGN = {\n\t  left: 1,\n\t  right: 1,\n\t  center: 1\n\t};\n\tvar VALID_TEXT_VERTICAL_ALIGN = {\n\t  top: 1,\n\t  bottom: 1,\n\t  middle: 1\n\t};\n\t/**\n\t * @param {module:zrender/graphic/Style} style\n\t * @return {module:zrender/graphic/Style} The input style.\n\t */\n\t\n\tfunction normalizeTextStyle(style) {\n\t  normalizeStyle(style);\n\t  each(style.rich, normalizeStyle);\n\t  return style;\n\t}\n\t\n\tfunction normalizeStyle(style) {\n\t  if (style) {\n\t    style.font = textContain.makeFont(style);\n\t    var textAlign = style.textAlign;\n\t    textAlign === 'middle' && (textAlign = 'center');\n\t    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.\n\t\n\t    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n\t    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n\t    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';\n\t    var textPadding = style.textPadding;\n\t\n\t    if (textPadding) {\n\t      style.textPadding = normalizeCssArray(style.textPadding);\n\t    }\n\t  }\n\t}\n\t/**\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {string} text\n\t * @param {module:zrender/graphic/Style} style\n\t * @param {Object|boolean} [rect] {x, y, width, height}\n\t *                  If set false, rect text is not used.\n\t */\n\t\n\t\n\tfunction renderText(hostEl, ctx, text, style, rect) {\n\t  style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);\n\t}\n\t\n\tfunction renderPlainText(hostEl, ctx, text, style, rect) {\n\t  var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);\n\t  var textPadding = style.textPadding;\n\t  var contentBlock = hostEl.__textCotentBlock;\n\t\n\t  if (!contentBlock || hostEl.__dirty) {\n\t    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, font, textPadding, style.truncate);\n\t  }\n\t\n\t  var outerHeight = contentBlock.outerHeight;\n\t  var textLines = contentBlock.lines;\n\t  var lineHeight = contentBlock.lineHeight;\n\t  var boxPos = getBoxPosition(outerHeight, style, rect);\n\t  var baseX = boxPos.baseX;\n\t  var baseY = boxPos.baseY;\n\t  var textAlign = boxPos.textAlign;\n\t  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\t\n\t  applyTextRotation(ctx, style, rect, baseX, baseY);\n\t  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n\t  var textX = baseX;\n\t  var textY = boxY;\n\t  var needDrawBg = needDrawBackground(style);\n\t\n\t  if (needDrawBg || textPadding) {\n\t    // Consider performance, do not call getTextWidth util necessary.\n\t    var textWidth = textContain.getWidth(text, font);\n\t    var outerWidth = textWidth;\n\t    textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n\t    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n\t    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\t\n\t    if (textPadding) {\n\t      textX = getTextXForPadding(baseX, textAlign, textPadding);\n\t      textY += textPadding[0];\n\t    }\n\t  }\n\t\n\t  setCtx(ctx, 'textAlign', textAlign || 'left'); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n\t  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\t\n\t  setCtx(ctx, 'textBaseline', 'middle'); // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\t\n\t  setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);\n\t  setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');\n\t  setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);\n\t  setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0); // `textBaseline` is set as 'middle'.\n\t\n\t  textY += lineHeight / 2;\n\t  var textStrokeWidth = style.textStrokeWidth;\n\t  var textStroke = getStroke(style.textStroke, textStrokeWidth);\n\t  var textFill = getFill(style.textFill);\n\t\n\t  if (textStroke) {\n\t    setCtx(ctx, 'lineWidth', textStrokeWidth);\n\t    setCtx(ctx, 'strokeStyle', textStroke);\n\t  }\n\t\n\t  if (textFill) {\n\t    setCtx(ctx, 'fillStyle', textFill);\n\t  }\n\t\n\t  for (var i = 0; i < textLines.length; i++) {\n\t    // Fill after stroke so the outline will not cover the main part.\n\t    textStroke && ctx.strokeText(textLines[i], textX, textY);\n\t    textFill && ctx.fillText(textLines[i], textX, textY);\n\t    textY += lineHeight;\n\t  }\n\t}\n\t\n\tfunction renderRichText(hostEl, ctx, text, style, rect) {\n\t  var contentBlock = hostEl.__textCotentBlock;\n\t\n\t  if (!contentBlock || hostEl.__dirty) {\n\t    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n\t  }\n\t\n\t  drawRichText(hostEl, ctx, contentBlock, style, rect);\n\t}\n\t\n\tfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n\t  var contentWidth = contentBlock.width;\n\t  var outerWidth = contentBlock.outerWidth;\n\t  var outerHeight = contentBlock.outerHeight;\n\t  var textPadding = style.textPadding;\n\t  var boxPos = getBoxPosition(outerHeight, style, rect);\n\t  var baseX = boxPos.baseX;\n\t  var baseY = boxPos.baseY;\n\t  var textAlign = boxPos.textAlign;\n\t  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\t\n\t  applyTextRotation(ctx, style, rect, baseX, baseY);\n\t  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n\t  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n\t  var xLeft = boxX;\n\t  var lineTop = boxY;\n\t\n\t  if (textPadding) {\n\t    xLeft += textPadding[3];\n\t    lineTop += textPadding[0];\n\t  }\n\t\n\t  var xRight = xLeft + contentWidth;\n\t  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\t\n\t  for (var i = 0; i < contentBlock.lines.length; i++) {\n\t    var line = contentBlock.lines[i];\n\t    var tokens = line.tokens;\n\t    var tokenCount = tokens.length;\n\t    var lineHeight = line.lineHeight;\n\t    var usedWidth = line.width;\n\t    var leftIndex = 0;\n\t    var lineXLeft = xLeft;\n\t    var lineXRight = xRight;\n\t    var rightIndex = tokenCount - 1;\n\t    var token;\n\t\n\t    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {\n\t      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n\t      usedWidth -= token.width;\n\t      lineXLeft += token.width;\n\t      leftIndex++;\n\t    }\n\t\n\t    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {\n\t      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n\t      usedWidth -= token.width;\n\t      lineXRight -= token.width;\n\t      rightIndex--;\n\t    } // The other tokens are placed as textAlign 'center' if there is enough space.\n\t\n\t\n\t    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n\t\n\t    while (leftIndex <= rightIndex) {\n\t      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.\n\t\n\t      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n\t      lineXLeft += token.width;\n\t      leftIndex++;\n\t    }\n\t\n\t    lineTop += lineHeight;\n\t  }\n\t}\n\t\n\tfunction applyTextRotation(ctx, style, rect, x, y) {\n\t  // textRotation only apply in RectText.\n\t  if (rect && style.textRotation) {\n\t    var origin = style.textOrigin;\n\t\n\t    if (origin === 'center') {\n\t      x = rect.width / 2 + rect.x;\n\t      y = rect.height / 2 + rect.y;\n\t    } else if (origin) {\n\t      x = origin[0] + rect.x;\n\t      y = origin[1] + rect.y;\n\t    }\n\t\n\t    ctx.translate(x, y); // Positive: anticlockwise\n\t\n\t    ctx.rotate(-style.textRotation);\n\t    ctx.translate(-x, -y);\n\t  }\n\t}\n\t\n\tfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n\t  var tokenStyle = style.rich[token.styleName] || {}; // 'ctx.textBaseline' is always set as 'middle', for sake of\n\t  // the bias of \"Microsoft YaHei\".\n\t\n\t  var textVerticalAlign = token.textVerticalAlign;\n\t  var y = lineTop + lineHeight / 2;\n\t\n\t  if (textVerticalAlign === 'top') {\n\t    y = lineTop + token.height / 2;\n\t  } else if (textVerticalAlign === 'bottom') {\n\t    y = lineTop + lineHeight - token.height / 2;\n\t  }\n\t\n\t  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);\n\t  var textPadding = token.textPadding;\n\t\n\t  if (textPadding) {\n\t    x = getTextXForPadding(x, textAlign, textPadding);\n\t    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n\t  }\n\t\n\t  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n\t  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n\t  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n\t  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n\t  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n\t  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\t\n\t  setCtx(ctx, 'textBaseline', 'middle');\n\t  setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);\n\t  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n\t  var textFill = getFill(tokenStyle.textFill || style.textFill);\n\t  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.\n\t\n\t  if (textStroke) {\n\t    setCtx(ctx, 'lineWidth', textStrokeWidth);\n\t    setCtx(ctx, 'strokeStyle', textStroke);\n\t    ctx.strokeText(token.text, x, y);\n\t  }\n\t\n\t  if (textFill) {\n\t    setCtx(ctx, 'fillStyle', textFill);\n\t    ctx.fillText(token.text, x, y);\n\t  }\n\t}\n\t\n\tfunction needDrawBackground(style) {\n\t  return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;\n\t} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}\n\t// shape: {x, y, width, height}\n\t\n\t\n\tfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n\t  var textBackgroundColor = style.textBackgroundColor;\n\t  var textBorderWidth = style.textBorderWidth;\n\t  var textBorderColor = style.textBorderColor;\n\t  var isPlainBg = isString(textBackgroundColor);\n\t  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n\t  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n\t  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n\t  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\t\n\t  if (isPlainBg || textBorderWidth && textBorderColor) {\n\t    ctx.beginPath();\n\t    var textBorderRadius = style.textBorderRadius;\n\t\n\t    if (!textBorderRadius) {\n\t      ctx.rect(x, y, width, height);\n\t    } else {\n\t      roundRectHelper.buildPath(ctx, {\n\t        x: x,\n\t        y: y,\n\t        width: width,\n\t        height: height,\n\t        r: textBorderRadius\n\t      });\n\t    }\n\t\n\t    ctx.closePath();\n\t  }\n\t\n\t  if (isPlainBg) {\n\t    setCtx(ctx, 'fillStyle', textBackgroundColor);\n\t    ctx.fill();\n\t  } else if (isObject(textBackgroundColor)) {\n\t    var image = textBackgroundColor.image;\n\t    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);\n\t\n\t    if (image && imageHelper.isImageReady(image)) {\n\t      ctx.drawImage(image, x, y, width, height);\n\t    }\n\t  }\n\t\n\t  if (textBorderWidth && textBorderColor) {\n\t    setCtx(ctx, 'lineWidth', textBorderWidth);\n\t    setCtx(ctx, 'strokeStyle', textBorderColor);\n\t    ctx.stroke();\n\t  }\n\t}\n\t\n\tfunction onBgImageLoaded(image, textBackgroundColor) {\n\t  // Replace image, so that `contain/text.js#parseRichText`\n\t  // will get correct result in next tick.\n\t  textBackgroundColor.image = image;\n\t}\n\t\n\tfunction getBoxPosition(blockHeiht, style, rect) {\n\t  var baseX = style.x || 0;\n\t  var baseY = style.y || 0;\n\t  var textAlign = style.textAlign;\n\t  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord\n\t\n\t  if (rect) {\n\t    var textPosition = style.textPosition;\n\t\n\t    if (textPosition instanceof Array) {\n\t      // Percent\n\t      baseX = rect.x + parsePercent(textPosition[0], rect.width);\n\t      baseY = rect.y + parsePercent(textPosition[1], rect.height);\n\t    } else {\n\t      var res = textContain.adjustTextPositionOnRect(textPosition, rect, style.textDistance);\n\t      baseX = res.x;\n\t      baseY = res.y; // Default align and baseline when has textPosition\n\t\n\t      textAlign = textAlign || res.textAlign;\n\t      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n\t    } // textOffset is only support in RectText, otherwise\n\t    // we have to adjust boundingRect for textOffset.\n\t\n\t\n\t    var textOffset = style.textOffset;\n\t\n\t    if (textOffset) {\n\t      baseX += textOffset[0];\n\t      baseY += textOffset[1];\n\t    }\n\t  }\n\t\n\t  return {\n\t    baseX: baseX,\n\t    baseY: baseY,\n\t    textAlign: textAlign,\n\t    textVerticalAlign: textVerticalAlign\n\t  };\n\t}\n\t\n\tfunction setCtx(ctx, prop, value) {\n\t  // FIXME ??? performance try\n\t  // if (ctx.__currentValues[prop] !== value) {\n\t  // ctx[prop] = ctx.__currentValues[prop] = value;\n\t  ctx[prop] = value; // }\n\t\n\t  return ctx[prop];\n\t}\n\t/**\n\t * @param {string} [stroke] If specified, do not check style.textStroke.\n\t * @param {string} [lineWidth] If specified, do not check style.textStroke.\n\t * @param {number} style\n\t */\n\t\n\t\n\tfunction getStroke(stroke, lineWidth) {\n\t  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?\n\t  : stroke.image || stroke.colorStops ? '#000' : stroke;\n\t}\n\t\n\tfunction getFill(fill) {\n\t  return fill == null || fill === 'none' ? null // TODO pattern and gradient?\n\t  : fill.image || fill.colorStops ? '#000' : fill;\n\t}\n\t\n\tfunction parsePercent(value, maxValue) {\n\t  if (typeof value === 'string') {\n\t    if (value.lastIndexOf('%') >= 0) {\n\t      return parseFloat(value) / 100 * maxValue;\n\t    }\n\t\n\t    return parseFloat(value);\n\t  }\n\t\n\t  return value;\n\t}\n\t\n\tfunction getTextXForPadding(x, textAlign, textPadding) {\n\t  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n\t}\n\t/**\n\t * @param {string} text\n\t * @param {module:zrender/Style} style\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction needDrawText(text, style) {\n\t  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);\n\t}\n\t\n\texports.normalizeTextStyle = normalizeTextStyle;\n\texports.renderText = renderText;\n\texports.getStroke = getStroke;\n\texports.getFill = getFill;\n\texports.needDrawText = needDrawText;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar BoundingRect = __webpack_require__(27);\n\t\n\tvar imageHelper = __webpack_require__(28);\n\t\n\tvar _util = __webpack_require__(5);\n\t\n\tvar getContext = _util.getContext;\n\tvar extend = _util.extend;\n\tvar retrieve2 = _util.retrieve2;\n\tvar retrieve3 = _util.retrieve3;\n\tvar textWidthCache = {};\n\tvar textWidthCacheCounter = 0;\n\tvar TEXT_CACHE_MAX = 5000;\n\tvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\n\tvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\t\n\tvar methods = {};\n\t\n\tfunction $override(name, fn) {\n\t  methods[name] = fn;\n\t}\n\t/**\n\t * @public\n\t * @param {string} text\n\t * @param {string} font\n\t * @return {number} width\n\t */\n\t\n\t\n\tfunction getWidth(text, font) {\n\t  font = font || DEFAULT_FONT;\n\t  var key = text + ':' + font;\n\t\n\t  if (textWidthCache[key]) {\n\t    return textWidthCache[key];\n\t  }\n\t\n\t  var textLines = (text + '').split('\\n');\n\t  var width = 0;\n\t\n\t  for (var i = 0, l = textLines.length; i < l; i++) {\n\t    // textContain.measureText may be overrided in SVG or VML\n\t    width = Math.max(measureText(textLines[i], font).width, width);\n\t  }\n\t\n\t  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n\t    textWidthCacheCounter = 0;\n\t    textWidthCache = {};\n\t  }\n\t\n\t  textWidthCacheCounter++;\n\t  textWidthCache[key] = width;\n\t  return width;\n\t}\n\t/**\n\t * @public\n\t * @param {string} text\n\t * @param {string} font\n\t * @param {string} [textAlign='left']\n\t * @param {string} [textVerticalAlign='top']\n\t * @param {Array.<number>} [textPadding]\n\t * @param {Object} [rich]\n\t * @param {Object} [truncate]\n\t * @return {Object} {x, y, width, height, lineHeight}\n\t */\n\t\n\t\n\tfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n\t  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);\n\t}\n\t\n\tfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {\n\t  var contentBlock = parsePlainText(text, font, textPadding, truncate);\n\t  var outerWidth = getWidth(text, font);\n\t\n\t  if (textPadding) {\n\t    outerWidth += textPadding[1] + textPadding[3];\n\t  }\n\t\n\t  var outerHeight = contentBlock.outerHeight;\n\t  var x = adjustTextX(0, outerWidth, textAlign);\n\t  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n\t  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n\t  rect.lineHeight = contentBlock.lineHeight;\n\t  return rect;\n\t}\n\t\n\tfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n\t  var contentBlock = parseRichText(text, {\n\t    rich: rich,\n\t    truncate: truncate,\n\t    font: font,\n\t    textAlign: textAlign,\n\t    textPadding: textPadding\n\t  });\n\t  var outerWidth = contentBlock.outerWidth;\n\t  var outerHeight = contentBlock.outerHeight;\n\t  var x = adjustTextX(0, outerWidth, textAlign);\n\t  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n\t  return new BoundingRect(x, y, outerWidth, outerHeight);\n\t}\n\t/**\n\t * @public\n\t * @param {number} x\n\t * @param {number} width\n\t * @param {string} [textAlign='left']\n\t * @return {number} Adjusted x.\n\t */\n\t\n\t\n\tfunction adjustTextX(x, width, textAlign) {\n\t  // FIXME Right to left language\n\t  if (textAlign === 'right') {\n\t    x -= width;\n\t  } else if (textAlign === 'center') {\n\t    x -= width / 2;\n\t  }\n\t\n\t  return x;\n\t}\n\t/**\n\t * @public\n\t * @param {number} y\n\t * @param {number} height\n\t * @param {string} [textVerticalAlign='top']\n\t * @return {number} Adjusted y.\n\t */\n\t\n\t\n\tfunction adjustTextY(y, height, textVerticalAlign) {\n\t  if (textVerticalAlign === 'middle') {\n\t    y -= height / 2;\n\t  } else if (textVerticalAlign === 'bottom') {\n\t    y -= height;\n\t  }\n\t\n\t  return y;\n\t}\n\t/**\n\t * @public\n\t * @param {stirng} textPosition\n\t * @param {Object} rect {x, y, width, height}\n\t * @param {number} distance\n\t * @return {Object} {x, y, textAlign, textVerticalAlign}\n\t */\n\t\n\t\n\tfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n\t  var x = rect.x;\n\t  var y = rect.y;\n\t  var height = rect.height;\n\t  var width = rect.width;\n\t  var halfHeight = height / 2;\n\t  var textAlign = 'left';\n\t  var textVerticalAlign = 'top';\n\t\n\t  switch (textPosition) {\n\t    case 'left':\n\t      x -= distance;\n\t      y += halfHeight;\n\t      textAlign = 'right';\n\t      textVerticalAlign = 'middle';\n\t      break;\n\t\n\t    case 'right':\n\t      x += distance + width;\n\t      y += halfHeight;\n\t      textVerticalAlign = 'middle';\n\t      break;\n\t\n\t    case 'top':\n\t      x += width / 2;\n\t      y -= distance;\n\t      textAlign = 'center';\n\t      textVerticalAlign = 'bottom';\n\t      break;\n\t\n\t    case 'bottom':\n\t      x += width / 2;\n\t      y += height + distance;\n\t      textAlign = 'center';\n\t      break;\n\t\n\t    case 'inside':\n\t      x += width / 2;\n\t      y += halfHeight;\n\t      textAlign = 'center';\n\t      textVerticalAlign = 'middle';\n\t      break;\n\t\n\t    case 'insideLeft':\n\t      x += distance;\n\t      y += halfHeight;\n\t      textVerticalAlign = 'middle';\n\t      break;\n\t\n\t    case 'insideRight':\n\t      x += width - distance;\n\t      y += halfHeight;\n\t      textAlign = 'right';\n\t      textVerticalAlign = 'middle';\n\t      break;\n\t\n\t    case 'insideTop':\n\t      x += width / 2;\n\t      y += distance;\n\t      textAlign = 'center';\n\t      break;\n\t\n\t    case 'insideBottom':\n\t      x += width / 2;\n\t      y += height - distance;\n\t      textAlign = 'center';\n\t      textVerticalAlign = 'bottom';\n\t      break;\n\t\n\t    case 'insideTopLeft':\n\t      x += distance;\n\t      y += distance;\n\t      break;\n\t\n\t    case 'insideTopRight':\n\t      x += width - distance;\n\t      y += distance;\n\t      textAlign = 'right';\n\t      break;\n\t\n\t    case 'insideBottomLeft':\n\t      x += distance;\n\t      y += height - distance;\n\t      textVerticalAlign = 'bottom';\n\t      break;\n\t\n\t    case 'insideBottomRight':\n\t      x += width - distance;\n\t      y += height - distance;\n\t      textAlign = 'right';\n\t      textVerticalAlign = 'bottom';\n\t      break;\n\t  }\n\t\n\t  return {\n\t    x: x,\n\t    y: y,\n\t    textAlign: textAlign,\n\t    textVerticalAlign: textVerticalAlign\n\t  };\n\t}\n\t/**\n\t * Show ellipsis if overflow.\n\t *\n\t * @public\n\t * @param  {string} text\n\t * @param  {string} containerWidth\n\t * @param  {string} font\n\t * @param  {number} [ellipsis='...']\n\t * @param  {Object} [options]\n\t * @param  {number} [options.maxIterations=3]\n\t * @param  {number} [options.minChar=0] If truncate result are less\n\t *                  then minChar, ellipsis will not show, which is\n\t *                  better for user hint in some cases.\n\t * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n\t * @return {string}\n\t */\n\t\n\t\n\tfunction truncateText(text, containerWidth, font, ellipsis, options) {\n\t  if (!containerWidth) {\n\t    return '';\n\t  }\n\t\n\t  var textLines = (text + '').split('\\n');\n\t  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n\t  // It is not appropriate that every line has '...' when truncate multiple lines.\n\t\n\t  for (var i = 0, len = textLines.length; i < len; i++) {\n\t    textLines[i] = truncateSingleLine(textLines[i], options);\n\t  }\n\t\n\t  return textLines.join('\\n');\n\t}\n\t\n\tfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n\t  options = extend({}, options);\n\t  options.font = font;\n\t  var ellipsis = retrieve2(ellipsis, '...');\n\t  options.maxIterations = retrieve2(options.maxIterations, 2);\n\t  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n\t  // Other languages?\n\t\n\t  options.cnCharWidth = getWidth('国', font); // FIXME\n\t  // Consider proportional font?\n\t\n\t  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n\t  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n\t  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\t\n\t  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\t\n\t  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n\t    contentWidth -= ascCharWidth;\n\t  }\n\t\n\t  var ellipsisWidth = getWidth(ellipsis);\n\t\n\t  if (ellipsisWidth > contentWidth) {\n\t    ellipsis = '';\n\t    ellipsisWidth = 0;\n\t  }\n\t\n\t  contentWidth = containerWidth - ellipsisWidth;\n\t  options.ellipsis = ellipsis;\n\t  options.ellipsisWidth = ellipsisWidth;\n\t  options.contentWidth = contentWidth;\n\t  options.containerWidth = containerWidth;\n\t  return options;\n\t}\n\t\n\tfunction truncateSingleLine(textLine, options) {\n\t  var containerWidth = options.containerWidth;\n\t  var font = options.font;\n\t  var contentWidth = options.contentWidth;\n\t\n\t  if (!containerWidth) {\n\t    return '';\n\t  }\n\t\n\t  var lineWidth = getWidth(textLine, font);\n\t\n\t  if (lineWidth <= containerWidth) {\n\t    return textLine;\n\t  }\n\t\n\t  for (var j = 0;; j++) {\n\t    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n\t      textLine += options.ellipsis;\n\t      break;\n\t    }\n\t\n\t    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n\t    textLine = textLine.substr(0, subLength);\n\t    lineWidth = getWidth(textLine, font);\n\t  }\n\t\n\t  if (textLine === '') {\n\t    textLine = options.placeholder;\n\t  }\n\t\n\t  return textLine;\n\t}\n\t\n\tfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n\t  var width = 0;\n\t  var i = 0;\n\t\n\t  for (var len = text.length; i < len && width < contentWidth; i++) {\n\t    var charCode = text.charCodeAt(i);\n\t    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n\t  }\n\t\n\t  return i;\n\t}\n\t/**\n\t * @public\n\t * @param {string} font\n\t * @return {number} line height\n\t */\n\t\n\t\n\tfunction getLineHeight(font) {\n\t  // FIXME A rough approach.\n\t  return getWidth('国', font);\n\t}\n\t/**\n\t * @public\n\t * @param {string} text\n\t * @param {string} font\n\t * @return {Object} width\n\t */\n\t\n\t\n\tfunction measureText(text, font) {\n\t  return methods.measureText(text, font);\n\t} // Avoid assign to an exported variable, for transforming to cjs.\n\t\n\t\n\tmethods.measureText = function (text, font) {\n\t  var ctx = getContext();\n\t  ctx.font = font || DEFAULT_FONT;\n\t  return ctx.measureText(text);\n\t};\n\t/**\n\t * @public\n\t * @param {string} text\n\t * @param {string} font\n\t * @param {Object} [truncate]\n\t * @return {Object} block: {lineHeight, lines, height, outerHeight}\n\t *  Notice: for performance, do not calculate outerWidth util needed.\n\t */\n\t\n\t\n\tfunction parsePlainText(text, font, padding, truncate) {\n\t  text != null && (text += '');\n\t  var lineHeight = getLineHeight(font);\n\t  var lines = text ? text.split('\\n') : [];\n\t  var height = lines.length * lineHeight;\n\t  var outerHeight = height;\n\t\n\t  if (padding) {\n\t    outerHeight += padding[0] + padding[2];\n\t  }\n\t\n\t  if (text && truncate) {\n\t    var truncOuterHeight = truncate.outerHeight;\n\t    var truncOuterWidth = truncate.outerWidth;\n\t\n\t    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n\t      text = '';\n\t      lines = [];\n\t    } else if (truncOuterWidth != null) {\n\t      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n\t        minChar: truncate.minChar,\n\t        placeholder: truncate.placeholder\n\t      }); // FIXME\n\t      // It is not appropriate that every line has '...' when truncate multiple lines.\n\t\n\t      for (var i = 0, len = lines.length; i < len; i++) {\n\t        lines[i] = truncateSingleLine(lines[i], options);\n\t      }\n\t    }\n\t  }\n\t\n\t  return {\n\t    lines: lines,\n\t    height: height,\n\t    outerHeight: outerHeight,\n\t    lineHeight: lineHeight\n\t  };\n\t}\n\t/**\n\t * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n\t * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n\t *\n\t * @public\n\t * @param {string} text\n\t * @param {Object} style\n\t * @return {Object} block\n\t * {\n\t *      width,\n\t *      height,\n\t *      lines: [{\n\t *          lineHeight,\n\t *          width,\n\t *          tokens: [[{\n\t *              styleName,\n\t *              text,\n\t *              width,      // include textPadding\n\t *              height,     // include textPadding\n\t *              textWidth, // pure text width\n\t *              textHeight, // pure text height\n\t *              lineHeihgt,\n\t *              font,\n\t *              textAlign,\n\t *              textVerticalAlign\n\t *          }], [...], ...]\n\t *      }, ...]\n\t * }\n\t * If styleName is undefined, it is plain text.\n\t */\n\t\n\t\n\tfunction parseRichText(text, style) {\n\t  var contentBlock = {\n\t    lines: [],\n\t    width: 0,\n\t    height: 0\n\t  };\n\t  text != null && (text += '');\n\t\n\t  if (!text) {\n\t    return contentBlock;\n\t  }\n\t\n\t  var lastIndex = STYLE_REG.lastIndex = 0;\n\t  var result;\n\t\n\t  while ((result = STYLE_REG.exec(text)) != null) {\n\t    var matchedIndex = result.index;\n\t\n\t    if (matchedIndex > lastIndex) {\n\t      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n\t    }\n\t\n\t    pushTokens(contentBlock, result[2], result[1]);\n\t    lastIndex = STYLE_REG.lastIndex;\n\t  }\n\t\n\t  if (lastIndex < text.length) {\n\t    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n\t  }\n\t\n\t  var lines = contentBlock.lines;\n\t  var contentHeight = 0;\n\t  var contentWidth = 0; // For `textWidth: 100%`\n\t\n\t  var pendingList = [];\n\t  var stlPadding = style.textPadding;\n\t  var truncate = style.truncate;\n\t  var truncateWidth = truncate && truncate.outerWidth;\n\t  var truncateHeight = truncate && truncate.outerHeight;\n\t\n\t  if (stlPadding) {\n\t    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n\t    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n\t  } // Calculate layout info of tokens.\n\t\n\t\n\t  for (var i = 0; i < lines.length; i++) {\n\t    var line = lines[i];\n\t    var lineHeight = 0;\n\t    var lineWidth = 0;\n\t\n\t    for (var j = 0; j < line.tokens.length; j++) {\n\t      var token = line.tokens[j];\n\t      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\t\n\t      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\t\n\t      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\t\n\t      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n\t      // as box height of the block.\n\t      tokenStyle.textHeight, getLineHeight(font));\n\t      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n\t      token.height = tokenHeight;\n\t      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n\t      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n\t      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\t\n\t      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n\t        return {\n\t          lines: [],\n\t          width: 0,\n\t          height: 0\n\t        };\n\t      }\n\t\n\t      token.textWidth = getWidth(token.text, font);\n\t      var tokenWidth = tokenStyle.textWidth;\n\t      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n\t      // line when box width is needed to be auto.\n\t\n\t      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n\t        token.percentWidth = tokenWidth;\n\t        pendingList.push(token);\n\t        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n\t        // and it is too complicated.\n\t      } else {\n\t        if (tokenWidthNotSpecified) {\n\t          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n\t          // `getBoundingRect()` will not get correct result.\n\t\n\t          var textBackgroundColor = tokenStyle.textBackgroundColor;\n\t          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n\t          // (1) If image is not loaded, it will be loaded at render phase and call\n\t          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n\t          // image, and then the right size will be calculated here at the next tick.\n\t          // See `graphic/helper/text.js`.\n\t          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n\t          // use `imageHelper.findExistImage` to find cached image.\n\t          // `imageHelper.findExistImage` will always be called here before\n\t          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n\t          // which ensures that image will not be rendered before correct size calcualted.\n\t\n\t          if (bgImg) {\n\t            bgImg = imageHelper.findExistImage(bgImg);\n\t\n\t            if (imageHelper.isImageReady(bgImg)) {\n\t              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n\t            }\n\t          }\n\t        }\n\t\n\t        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n\t        tokenWidth += paddingW;\n\t        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\t\n\t        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n\t          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n\t            token.text = '';\n\t            token.textWidth = tokenWidth = 0;\n\t          } else {\n\t            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n\t              minChar: truncate.minChar\n\t            });\n\t            token.textWidth = getWidth(token.text, font);\n\t            tokenWidth = token.textWidth + paddingW;\n\t          }\n\t        }\n\t      }\n\t\n\t      lineWidth += token.width = tokenWidth;\n\t      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n\t    }\n\t\n\t    line.width = lineWidth;\n\t    line.lineHeight = lineHeight;\n\t    contentHeight += lineHeight;\n\t    contentWidth = Math.max(contentWidth, lineWidth);\n\t  }\n\t\n\t  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n\t  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\t\n\t  if (stlPadding) {\n\t    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n\t    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n\t  }\n\t\n\t  for (var i = 0; i < pendingList.length; i++) {\n\t    var token = pendingList[i];\n\t    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\t\n\t    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n\t  }\n\t\n\t  return contentBlock;\n\t}\n\t\n\tfunction pushTokens(block, str, styleName) {\n\t  var isEmptyStr = str === '';\n\t  var strs = str.split('\\n');\n\t  var lines = block.lines;\n\t\n\t  for (var i = 0; i < strs.length; i++) {\n\t    var text = strs[i];\n\t    var token = {\n\t      styleName: styleName,\n\t      text: text,\n\t      isLineHolder: !text && !isEmptyStr\n\t    }; // The first token should be appended to the last line.\n\t\n\t    if (!i) {\n\t      var tokens = (lines[lines.length - 1] || (lines[0] = {\n\t        tokens: []\n\t      })).tokens; // Consider cases:\n\t      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n\t      // (which is a placeholder) should be replaced by new token.\n\t      // (2) A image backage, where token likes {a|}.\n\t      // (3) A redundant '' will affect textAlign in line.\n\t      // (4) tokens with the same tplName should not be merged, because\n\t      // they should be displayed in different box (with border and padding).\n\t\n\t      var tokensLen = tokens.length;\n\t      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n\t      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n\t      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n\t    } // Other tokens always start a new line.\n\t    else {\n\t        // If there is '', insert it as a placeholder.\n\t        lines.push({\n\t          tokens: [token]\n\t        });\n\t      }\n\t  }\n\t}\n\t\n\tfunction makeFont(style) {\n\t  // FIXME in node-canvas fontWeight is before fontStyle\n\t  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n\t  return (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n\t  style.fontFamily || 'sans-serif'].join(' ') || style.textFont || style.font;\n\t}\n\t\n\texports.DEFAULT_FONT = DEFAULT_FONT;\n\texports.$override = $override;\n\texports.getWidth = getWidth;\n\texports.getBoundingRect = getBoundingRect;\n\texports.adjustTextX = adjustTextX;\n\texports.adjustTextY = adjustTextY;\n\texports.adjustTextPositionOnRect = adjustTextPositionOnRect;\n\texports.truncateText = truncateText;\n\texports.getLineHeight = getLineHeight;\n\texports.measureText = measureText;\n\texports.parsePlainText = parsePlainText;\n\texports.parseRichText = parseRichText;\n\texports.makeFont = makeFont;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar vec2 = __webpack_require__(15);\n\t\n\tvar matrix = __webpack_require__(14);\n\t\n\t/**\n\t * @module echarts/core/BoundingRect\n\t */\n\tvar v2ApplyTransform = vec2.applyTransform;\n\tvar mathMin = Math.min;\n\tvar mathMax = Math.max;\n\t/**\n\t * @alias module:echarts/core/BoundingRect\n\t */\n\t\n\tfunction BoundingRect(x, y, width, height) {\n\t  if (width < 0) {\n\t    x = x + width;\n\t    width = -width;\n\t  }\n\t\n\t  if (height < 0) {\n\t    y = y + height;\n\t    height = -height;\n\t  }\n\t  /**\n\t   * @type {number}\n\t   */\n\t\n\t\n\t  this.x = x;\n\t  /**\n\t   * @type {number}\n\t   */\n\t\n\t  this.y = y;\n\t  /**\n\t   * @type {number}\n\t   */\n\t\n\t  this.width = width;\n\t  /**\n\t   * @type {number}\n\t   */\n\t\n\t  this.height = height;\n\t}\n\t\n\tBoundingRect.prototype = {\n\t  constructor: BoundingRect,\n\t\n\t  /**\n\t   * @param {module:echarts/core/BoundingRect} other\n\t   */\n\t  union: function (other) {\n\t    var x = mathMin(other.x, this.x);\n\t    var y = mathMin(other.y, this.y);\n\t    this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n\t    this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n\t    this.x = x;\n\t    this.y = y;\n\t  },\n\t\n\t  /**\n\t   * @param {Array.<number>} m\n\t   * @methods\n\t   */\n\t  applyTransform: function () {\n\t    var lt = [];\n\t    var rb = [];\n\t    var lb = [];\n\t    var rt = [];\n\t    return function (m) {\n\t      // In case usage like this\n\t      // el.getBoundingRect().applyTransform(el.transform)\n\t      // And element has no transform\n\t      if (!m) {\n\t        return;\n\t      }\n\t\n\t      lt[0] = lb[0] = this.x;\n\t      lt[1] = rt[1] = this.y;\n\t      rb[0] = rt[0] = this.x + this.width;\n\t      rb[1] = lb[1] = this.y + this.height;\n\t      v2ApplyTransform(lt, lt, m);\n\t      v2ApplyTransform(rb, rb, m);\n\t      v2ApplyTransform(lb, lb, m);\n\t      v2ApplyTransform(rt, rt, m);\n\t      this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n\t      this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n\t      var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n\t      var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n\t      this.width = maxX - this.x;\n\t      this.height = maxY - this.y;\n\t    };\n\t  }(),\n\t\n\t  /**\n\t   * Calculate matrix of transforming from self to target rect\n\t   * @param  {module:zrender/core/BoundingRect} b\n\t   * @return {Array.<number>}\n\t   */\n\t  calculateTransform: function (b) {\n\t    var a = this;\n\t    var sx = b.width / a.width;\n\t    var sy = b.height / a.height;\n\t    var m = matrix.create(); // 矩阵右乘\n\t\n\t    matrix.translate(m, m, [-a.x, -a.y]);\n\t    matrix.scale(m, m, [sx, sy]);\n\t    matrix.translate(m, m, [b.x, b.y]);\n\t    return m;\n\t  },\n\t\n\t  /**\n\t   * @param {(module:echarts/core/BoundingRect|Object)} b\n\t   * @return {boolean}\n\t   */\n\t  intersect: function (b) {\n\t    if (!b) {\n\t      return false;\n\t    }\n\t\n\t    if (!(b instanceof BoundingRect)) {\n\t      // Normalize negative width/height.\n\t      b = BoundingRect.create(b);\n\t    }\n\t\n\t    var a = this;\n\t    var ax0 = a.x;\n\t    var ax1 = a.x + a.width;\n\t    var ay0 = a.y;\n\t    var ay1 = a.y + a.height;\n\t    var bx0 = b.x;\n\t    var bx1 = b.x + b.width;\n\t    var by0 = b.y;\n\t    var by1 = b.y + b.height;\n\t    return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n\t  },\n\t  contain: function (x, y) {\n\t    var rect = this;\n\t    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n\t  },\n\t\n\t  /**\n\t   * @return {module:echarts/core/BoundingRect}\n\t   */\n\t  clone: function () {\n\t    return new BoundingRect(this.x, this.y, this.width, this.height);\n\t  },\n\t\n\t  /**\n\t   * Copy from another rect\n\t   */\n\t  copy: function (other) {\n\t    this.x = other.x;\n\t    this.y = other.y;\n\t    this.width = other.width;\n\t    this.height = other.height;\n\t  },\n\t  plain: function () {\n\t    return {\n\t      x: this.x,\n\t      y: this.y,\n\t      width: this.width,\n\t      height: this.height\n\t    };\n\t  }\n\t};\n\t/**\n\t * @param {Object|module:zrender/core/BoundingRect} rect\n\t * @param {number} rect.x\n\t * @param {number} rect.y\n\t * @param {number} rect.width\n\t * @param {number} rect.height\n\t * @return {module:zrender/core/BoundingRect}\n\t */\n\t\n\tBoundingRect.create = function (rect) {\n\t  return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n\t};\n\t\n\tvar _default = BoundingRect;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar LRU = __webpack_require__(21);\n\t\n\tvar globalImageCache = new LRU(50);\n\t/**\n\t * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n\t * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n\t */\n\t\n\tfunction findExistImage(newImageOrSrc) {\n\t  if (typeof newImageOrSrc === 'string') {\n\t    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n\t    return cachedImgObj && cachedImgObj.image;\n\t  } else {\n\t    return newImageOrSrc;\n\t  }\n\t}\n\t/**\n\t * Caution: User should cache loaded images, but not just count on LRU.\n\t * Consider if required images more than LRU size, will dead loop occur?\n\t *\n\t * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n\t * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.\n\t * @param {module:zrender/Element} [hostEl] For calling `dirty`.\n\t * @param {Function} [cb] params: (image, cbPayload)\n\t * @param {Object} [cbPayload] Payload on cb calling.\n\t * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n\t */\n\t\n\t\n\tfunction createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {\n\t  if (!newImageOrSrc) {\n\t    return image;\n\t  } else if (typeof newImageOrSrc === 'string') {\n\t    // Image should not be loaded repeatly.\n\t    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {\n\t      return image;\n\t    } // Only when there is no existent image or existent image src\n\t    // is different, this method is responsible for load.\n\t\n\t\n\t    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n\t    var pendingWrap = {\n\t      hostEl: hostEl,\n\t      cb: cb,\n\t      cbPayload: cbPayload\n\t    };\n\t\n\t    if (cachedImgObj) {\n\t      image = cachedImgObj.image;\n\t      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);\n\t    } else {\n\t      !image && (image = new Image());\n\t      image.onload = imageOnLoad;\n\t      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {\n\t        image: image,\n\t        pending: [pendingWrap]\n\t      });\n\t      image.src = image.__zrImageSrc = newImageOrSrc;\n\t    }\n\t\n\t    return image;\n\t  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas\n\t  else {\n\t      return newImageOrSrc;\n\t    }\n\t}\n\t\n\tfunction imageOnLoad() {\n\t  var cachedImgObj = this.__cachedImgObj;\n\t  this.onload = this.__cachedImgObj = null;\n\t\n\t  for (var i = 0; i < cachedImgObj.pending.length; i++) {\n\t    var pendingWrap = cachedImgObj.pending[i];\n\t    var cb = pendingWrap.cb;\n\t    cb && cb(this, pendingWrap.cbPayload);\n\t    pendingWrap.hostEl.dirty();\n\t  }\n\t\n\t  cachedImgObj.pending.length = 0;\n\t}\n\t\n\tfunction isImageReady(image) {\n\t  return image && image.width && image.height;\n\t}\n\t\n\texports.findExistImage = findExistImage;\n\texports.createOrUpdateImage = createOrUpdateImage;\n\texports.isImageReady = isImageReady;\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports) {\n\n\tfunction buildPath(ctx, shape) {\n\t  var x = shape.x;\n\t  var y = shape.y;\n\t  var width = shape.width;\n\t  var height = shape.height;\n\t  var r = shape.r;\n\t  var r1;\n\t  var r2;\n\t  var r3;\n\t  var r4; // Convert width and height to positive for better borderRadius\n\t\n\t  if (width < 0) {\n\t    x = x + width;\n\t    width = -width;\n\t  }\n\t\n\t  if (height < 0) {\n\t    y = y + height;\n\t    height = -height;\n\t  }\n\t\n\t  if (typeof r === 'number') {\n\t    r1 = r2 = r3 = r4 = r;\n\t  } else if (r instanceof Array) {\n\t    if (r.length === 1) {\n\t      r1 = r2 = r3 = r4 = r[0];\n\t    } else if (r.length === 2) {\n\t      r1 = r3 = r[0];\n\t      r2 = r4 = r[1];\n\t    } else if (r.length === 3) {\n\t      r1 = r[0];\n\t      r2 = r4 = r[1];\n\t      r3 = r[2];\n\t    } else {\n\t      r1 = r[0];\n\t      r2 = r[1];\n\t      r3 = r[2];\n\t      r4 = r[3];\n\t    }\n\t  } else {\n\t    r1 = r2 = r3 = r4 = 0;\n\t  }\n\t\n\t  var total;\n\t\n\t  if (r1 + r2 > width) {\n\t    total = r1 + r2;\n\t    r1 *= width / total;\n\t    r2 *= width / total;\n\t  }\n\t\n\t  if (r3 + r4 > width) {\n\t    total = r3 + r4;\n\t    r3 *= width / total;\n\t    r4 *= width / total;\n\t  }\n\t\n\t  if (r2 + r3 > height) {\n\t    total = r2 + r3;\n\t    r2 *= height / total;\n\t    r3 *= height / total;\n\t  }\n\t\n\t  if (r1 + r4 > height) {\n\t    total = r1 + r4;\n\t    r1 *= height / total;\n\t    r4 *= height / total;\n\t  }\n\t\n\t  ctx.moveTo(x + r1, y);\n\t  ctx.lineTo(x + width - r2, y);\n\t  r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);\n\t  ctx.lineTo(x + width, y + height - r3);\n\t  r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);\n\t  ctx.lineTo(x + r4, y + height);\n\t  r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);\n\t  ctx.lineTo(x, y + r1);\n\t  r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n\t}\n\t\n\texports.buildPath = buildPath;\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar curve = __webpack_require__(31);\n\t\n\tvar vec2 = __webpack_require__(15);\n\t\n\tvar bbox = __webpack_require__(32);\n\t\n\tvar BoundingRect = __webpack_require__(27);\n\t\n\tvar _config = __webpack_require__(23);\n\t\n\tvar dpr = _config.devicePixelRatio;\n\t\n\t/**\n\t * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n\t * 可以用于 isInsidePath 判断以及获取boundingRect\n\t *\n\t * @module zrender/core/PathProxy\n\t * @author Yi Shen (http://www.github.com/pissang)\n\t */\n\t// TODO getTotalLength, getPointAtLength\n\tvar CMD = {\n\t  M: 1,\n\t  L: 2,\n\t  C: 3,\n\t  Q: 4,\n\t  A: 5,\n\t  Z: 6,\n\t  // Rect\n\t  R: 7\n\t}; // var CMD_MEM_SIZE = {\n\t//     M: 3,\n\t//     L: 3,\n\t//     C: 7,\n\t//     Q: 5,\n\t//     A: 9,\n\t//     R: 5,\n\t//     Z: 1\n\t// };\n\t\n\tvar min = [];\n\tvar max = [];\n\tvar min2 = [];\n\tvar max2 = [];\n\tvar mathMin = Math.min;\n\tvar mathMax = Math.max;\n\tvar mathCos = Math.cos;\n\tvar mathSin = Math.sin;\n\tvar mathSqrt = Math.sqrt;\n\tvar mathAbs = Math.abs;\n\tvar hasTypedArray = typeof Float32Array != 'undefined';\n\t/**\n\t * @alias module:zrender/core/PathProxy\n\t * @constructor\n\t */\n\t\n\tvar PathProxy = function (notSaveData) {\n\t  this._saveData = !(notSaveData || false);\n\t\n\t  if (this._saveData) {\n\t    /**\n\t     * Path data. Stored as flat array\n\t     * @type {Array.<Object>}\n\t     */\n\t    this.data = [];\n\t  }\n\t\n\t  this._ctx = null;\n\t};\n\t/**\n\t * 快速计算Path包围盒（并不是最小包围盒）\n\t * @return {Object}\n\t */\n\t\n\t\n\tPathProxy.prototype = {\n\t  constructor: PathProxy,\n\t  _xi: 0,\n\t  _yi: 0,\n\t  _x0: 0,\n\t  _y0: 0,\n\t  // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n\t  _ux: 0,\n\t  _uy: 0,\n\t  _len: 0,\n\t  _lineDash: null,\n\t  _dashOffset: 0,\n\t  _dashIdx: 0,\n\t  _dashSum: 0,\n\t\n\t  /**\n\t   * @readOnly\n\t   */\n\t  setScale: function (sx, sy) {\n\t    this._ux = mathAbs(1 / dpr / sx) || 0;\n\t    this._uy = mathAbs(1 / dpr / sy) || 0;\n\t  },\n\t  getContext: function () {\n\t    return this._ctx;\n\t  },\n\t\n\t  /**\n\t   * @param  {CanvasRenderingContext2D} ctx\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  beginPath: function (ctx) {\n\t    this._ctx = ctx;\n\t    ctx && ctx.beginPath();\n\t    ctx && (this.dpr = ctx.dpr); // Reset\n\t\n\t    if (this._saveData) {\n\t      this._len = 0;\n\t    }\n\t\n\t    if (this._lineDash) {\n\t      this._lineDash = null;\n\t      this._dashOffset = 0;\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param  {number} x\n\t   * @param  {number} y\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  moveTo: function (x, y) {\n\t    this.addData(CMD.M, x, y);\n\t    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n\t    // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n\t    // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n\t    // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n\t\n\t    this._x0 = x;\n\t    this._y0 = y;\n\t    this._xi = x;\n\t    this._yi = y;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param  {number} x\n\t   * @param  {number} y\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  lineTo: function (x, y) {\n\t    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment\n\t    || this._len < 5;\n\t    this.addData(CMD.L, x, y);\n\t\n\t    if (this._ctx && exceedUnit) {\n\t      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n\t    }\n\t\n\t    if (exceedUnit) {\n\t      this._xi = x;\n\t      this._yi = y;\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param  {number} x1\n\t   * @param  {number} y1\n\t   * @param  {number} x2\n\t   * @param  {number} y2\n\t   * @param  {number} x3\n\t   * @param  {number} y3\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n\t    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\t\n\t    if (this._ctx) {\n\t      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n\t    }\n\t\n\t    this._xi = x3;\n\t    this._yi = y3;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param  {number} x1\n\t   * @param  {number} y1\n\t   * @param  {number} x2\n\t   * @param  {number} y2\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  quadraticCurveTo: function (x1, y1, x2, y2) {\n\t    this.addData(CMD.Q, x1, y1, x2, y2);\n\t\n\t    if (this._ctx) {\n\t      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n\t    }\n\t\n\t    this._xi = x2;\n\t    this._yi = y2;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param  {number} cx\n\t   * @param  {number} cy\n\t   * @param  {number} r\n\t   * @param  {number} startAngle\n\t   * @param  {number} endAngle\n\t   * @param  {boolean} anticlockwise\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n\t    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);\n\t    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\t    this._xi = mathCos(endAngle) * r + cx;\n\t    this._yi = mathSin(endAngle) * r + cx;\n\t    return this;\n\t  },\n\t  // TODO\n\t  arcTo: function (x1, y1, x2, y2, radius) {\n\t    if (this._ctx) {\n\t      this._ctx.arcTo(x1, y1, x2, y2, radius);\n\t    }\n\t\n\t    return this;\n\t  },\n\t  // TODO\n\t  rect: function (x, y, w, h) {\n\t    this._ctx && this._ctx.rect(x, y, w, h);\n\t    this.addData(CMD.R, x, y, w, h);\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  closePath: function () {\n\t    this.addData(CMD.Z);\n\t    var ctx = this._ctx;\n\t    var x0 = this._x0;\n\t    var y0 = this._y0;\n\t\n\t    if (ctx) {\n\t      this._needsDash() && this._dashedLineTo(x0, y0);\n\t      ctx.closePath();\n\t    }\n\t\n\t    this._xi = x0;\n\t    this._yi = y0;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n\t   * stroke 同样\n\t   * @param {CanvasRenderingContext2D} ctx\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  fill: function (ctx) {\n\t    ctx && ctx.fill();\n\t    this.toStatic();\n\t  },\n\t\n\t  /**\n\t   * @param {CanvasRenderingContext2D} ctx\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  stroke: function (ctx) {\n\t    ctx && ctx.stroke();\n\t    this.toStatic();\n\t  },\n\t\n\t  /**\n\t   * 必须在其它绘制命令前调用\n\t   * Must be invoked before all other path drawing methods\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  setLineDash: function (lineDash) {\n\t    if (lineDash instanceof Array) {\n\t      this._lineDash = lineDash;\n\t      this._dashIdx = 0;\n\t      var lineDashSum = 0;\n\t\n\t      for (var i = 0; i < lineDash.length; i++) {\n\t        lineDashSum += lineDash[i];\n\t      }\n\t\n\t      this._dashSum = lineDashSum;\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 必须在其它绘制命令前调用\n\t   * Must be invoked before all other path drawing methods\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  setLineDashOffset: function (offset) {\n\t    this._dashOffset = offset;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   *\n\t   * @return {boolean}\n\t   */\n\t  len: function () {\n\t    return this._len;\n\t  },\n\t\n\t  /**\n\t   * 直接设置 Path 数据\n\t   */\n\t  setData: function (data) {\n\t    var len = data.length;\n\t\n\t    if (!(this.data && this.data.length == len) && hasTypedArray) {\n\t      this.data = new Float32Array(len);\n\t    }\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      this.data[i] = data[i];\n\t    }\n\t\n\t    this._len = len;\n\t  },\n\t\n\t  /**\n\t   * 添加子路径\n\t   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n\t   */\n\t  appendPath: function (path) {\n\t    if (!(path instanceof Array)) {\n\t      path = [path];\n\t    }\n\t\n\t    var len = path.length;\n\t    var appendSize = 0;\n\t    var offset = this._len;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      appendSize += path[i].len();\n\t    }\n\t\n\t    if (hasTypedArray && this.data instanceof Float32Array) {\n\t      this.data = new Float32Array(offset + appendSize);\n\t    }\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      var appendPathData = path[i].data;\n\t\n\t      for (var k = 0; k < appendPathData.length; k++) {\n\t        this.data[offset++] = appendPathData[k];\n\t      }\n\t    }\n\t\n\t    this._len = offset;\n\t  },\n\t\n\t  /**\n\t   * 填充 Path 数据。\n\t   * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n\t   */\n\t  addData: function (cmd) {\n\t    if (!this._saveData) {\n\t      return;\n\t    }\n\t\n\t    var data = this.data;\n\t\n\t    if (this._len + arguments.length > data.length) {\n\t      // 因为之前的数组已经转换成静态的 Float32Array\n\t      // 所以不够用时需要扩展一个新的动态数组\n\t      this._expandData();\n\t\n\t      data = this.data;\n\t    }\n\t\n\t    for (var i = 0; i < arguments.length; i++) {\n\t      data[this._len++] = arguments[i];\n\t    }\n\t\n\t    this._prevCmd = cmd;\n\t  },\n\t  _expandData: function () {\n\t    // Only if data is Float32Array\n\t    if (!(this.data instanceof Array)) {\n\t      var newData = [];\n\t\n\t      for (var i = 0; i < this._len; i++) {\n\t        newData[i] = this.data[i];\n\t      }\n\t\n\t      this.data = newData;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * If needs js implemented dashed line\n\t   * @return {boolean}\n\t   * @private\n\t   */\n\t  _needsDash: function () {\n\t    return this._lineDash;\n\t  },\n\t  _dashedLineTo: function (x1, y1) {\n\t    var dashSum = this._dashSum;\n\t    var offset = this._dashOffset;\n\t    var lineDash = this._lineDash;\n\t    var ctx = this._ctx;\n\t    var x0 = this._xi;\n\t    var y0 = this._yi;\n\t    var dx = x1 - x0;\n\t    var dy = y1 - y0;\n\t    var dist = mathSqrt(dx * dx + dy * dy);\n\t    var x = x0;\n\t    var y = y0;\n\t    var dash;\n\t    var nDash = lineDash.length;\n\t    var idx;\n\t    dx /= dist;\n\t    dy /= dist;\n\t\n\t    if (offset < 0) {\n\t      // Convert to positive offset\n\t      offset = dashSum + offset;\n\t    }\n\t\n\t    offset %= dashSum;\n\t    x -= offset * dx;\n\t    y -= offset * dy;\n\t\n\t    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n\t      idx = this._dashIdx;\n\t      dash = lineDash[idx];\n\t      x += dx * dash;\n\t      y += dy * dash;\n\t      this._dashIdx = (idx + 1) % nDash; // Skip positive offset\n\t\n\t      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n\t        continue;\n\t      }\n\t\n\t      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n\t    } // Offset for next lineTo\n\t\n\t\n\t    dx = x - x1;\n\t    dy = y - y1;\n\t    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t  },\n\t  // Not accurate dashed line to\n\t  _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n\t    var dashSum = this._dashSum;\n\t    var offset = this._dashOffset;\n\t    var lineDash = this._lineDash;\n\t    var ctx = this._ctx;\n\t    var x0 = this._xi;\n\t    var y0 = this._yi;\n\t    var t;\n\t    var dx;\n\t    var dy;\n\t    var cubicAt = curve.cubicAt;\n\t    var bezierLen = 0;\n\t    var idx = this._dashIdx;\n\t    var nDash = lineDash.length;\n\t    var x;\n\t    var y;\n\t    var tmpLen = 0;\n\t\n\t    if (offset < 0) {\n\t      // Convert to positive offset\n\t      offset = dashSum + offset;\n\t    }\n\t\n\t    offset %= dashSum; // Bezier approx length\n\t\n\t    for (t = 0; t < 1; t += 0.1) {\n\t      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);\n\t      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);\n\t      bezierLen += mathSqrt(dx * dx + dy * dy);\n\t    } // Find idx after add offset\n\t\n\t\n\t    for (; idx < nDash; idx++) {\n\t      tmpLen += lineDash[idx];\n\t\n\t      if (tmpLen > offset) {\n\t        break;\n\t      }\n\t    }\n\t\n\t    t = (tmpLen - offset) / bezierLen;\n\t\n\t    while (t <= 1) {\n\t      x = cubicAt(x0, x1, x2, x3, t);\n\t      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier\n\t      // Bad result if dash is long\n\t\n\t      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n\t      t += lineDash[idx] / bezierLen;\n\t      idx = (idx + 1) % nDash;\n\t    } // Finish the last segment and calculate the new offset\n\t\n\t\n\t    idx % 2 !== 0 && ctx.lineTo(x3, y3);\n\t    dx = x3 - x;\n\t    dy = y3 - y;\n\t    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t  },\n\t  _dashedQuadraticTo: function (x1, y1, x2, y2) {\n\t    // Convert quadratic to cubic using degree elevation\n\t    var x3 = x2;\n\t    var y3 = y2;\n\t    x2 = (x2 + 2 * x1) / 3;\n\t    y2 = (y2 + 2 * y1) / 3;\n\t    x1 = (this._xi + 2 * x1) / 3;\n\t    y1 = (this._yi + 2 * y1) / 3;\n\t\n\t    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n\t  },\n\t\n\t  /**\n\t   * 转成静态的 Float32Array 减少堆内存占用\n\t   * Convert dynamic array to static Float32Array\n\t   */\n\t  toStatic: function () {\n\t    var data = this.data;\n\t\n\t    if (data instanceof Array) {\n\t      data.length = this._len;\n\t\n\t      if (hasTypedArray) {\n\t        this.data = new Float32Array(data);\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @return {module:zrender/core/BoundingRect}\n\t   */\n\t  getBoundingRect: function () {\n\t    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n\t    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\t    var data = this.data;\n\t    var xi = 0;\n\t    var yi = 0;\n\t    var x0 = 0;\n\t    var y0 = 0;\n\t\n\t    for (var i = 0; i < data.length;) {\n\t      var cmd = data[i++];\n\t\n\t      if (i == 1) {\n\t        // 如果第一个命令是 L, C, Q\n\t        // 则 previous point 同绘制命令的第一个 point\n\t        //\n\t        // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t        xi = data[i];\n\t        yi = data[i + 1];\n\t        x0 = xi;\n\t        y0 = yi;\n\t      }\n\t\n\t      switch (cmd) {\n\t        case CMD.M:\n\t          // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n\t          // 在 closePath 的时候使用\n\t          x0 = data[i++];\n\t          y0 = data[i++];\n\t          xi = x0;\n\t          yi = y0;\n\t          min2[0] = x0;\n\t          min2[1] = y0;\n\t          max2[0] = x0;\n\t          max2[1] = y0;\n\t          break;\n\t\n\t        case CMD.L:\n\t          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n\t          xi = data[i++];\n\t          yi = data[i++];\n\t          break;\n\t\n\t        case CMD.C:\n\t          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n\t          xi = data[i++];\n\t          yi = data[i++];\n\t          break;\n\t\n\t        case CMD.Q:\n\t          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n\t          xi = data[i++];\n\t          yi = data[i++];\n\t          break;\n\t\n\t        case CMD.A:\n\t          // TODO Arc 判断的开销比较大\n\t          var cx = data[i++];\n\t          var cy = data[i++];\n\t          var rx = data[i++];\n\t          var ry = data[i++];\n\t          var startAngle = data[i++];\n\t          var endAngle = data[i++] + startAngle; // TODO Arc 旋转\n\t\n\t          var psi = data[i++];\n\t          var anticlockwise = 1 - data[i++];\n\t\n\t          if (i == 1) {\n\t            // 直接使用 arc 命令\n\t            // 第一个命令起点还未定义\n\t            x0 = mathCos(startAngle) * rx + cx;\n\t            y0 = mathSin(startAngle) * ry + cy;\n\t          }\n\t\n\t          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n\t          xi = mathCos(endAngle) * rx + cx;\n\t          yi = mathSin(endAngle) * ry + cy;\n\t          break;\n\t\n\t        case CMD.R:\n\t          x0 = xi = data[i++];\n\t          y0 = yi = data[i++];\n\t          var width = data[i++];\n\t          var height = data[i++]; // Use fromLine\n\t\n\t          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n\t          break;\n\t\n\t        case CMD.Z:\n\t          xi = x0;\n\t          yi = y0;\n\t          break;\n\t      } // Union\n\t\n\t\n\t      vec2.min(min, min, min2);\n\t      vec2.max(max, max, max2);\n\t    } // No data\n\t\n\t\n\t    if (i === 0) {\n\t      min[0] = min[1] = max[0] = max[1] = 0;\n\t    }\n\t\n\t    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t  },\n\t\n\t  /**\n\t   * Rebuild path from current data\n\t   * Rebuild path will not consider javascript implemented line dash.\n\t   * @param {CanvasRenderingContext2D} ctx\n\t   */\n\t  rebuildPath: function (ctx) {\n\t    var d = this.data;\n\t    var x0, y0;\n\t    var xi, yi;\n\t    var x, y;\n\t    var ux = this._ux;\n\t    var uy = this._uy;\n\t    var len = this._len;\n\t\n\t    for (var i = 0; i < len;) {\n\t      var cmd = d[i++];\n\t\n\t      if (i == 1) {\n\t        // 如果第一个命令是 L, C, Q\n\t        // 则 previous point 同绘制命令的第一个 point\n\t        //\n\t        // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t        xi = d[i];\n\t        yi = d[i + 1];\n\t        x0 = xi;\n\t        y0 = yi;\n\t      }\n\t\n\t      switch (cmd) {\n\t        case CMD.M:\n\t          x0 = xi = d[i++];\n\t          y0 = yi = d[i++];\n\t          ctx.moveTo(xi, yi);\n\t          break;\n\t\n\t        case CMD.L:\n\t          x = d[i++];\n\t          y = d[i++]; // Not draw too small seg between\n\t\n\t          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n\t            ctx.lineTo(x, y);\n\t            xi = x;\n\t            yi = y;\n\t          }\n\t\n\t          break;\n\t\n\t        case CMD.C:\n\t          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);\n\t          xi = d[i - 2];\n\t          yi = d[i - 1];\n\t          break;\n\t\n\t        case CMD.Q:\n\t          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n\t          xi = d[i - 2];\n\t          yi = d[i - 1];\n\t          break;\n\t\n\t        case CMD.A:\n\t          var cx = d[i++];\n\t          var cy = d[i++];\n\t          var rx = d[i++];\n\t          var ry = d[i++];\n\t          var theta = d[i++];\n\t          var dTheta = d[i++];\n\t          var psi = d[i++];\n\t          var fs = d[i++];\n\t          var r = rx > ry ? rx : ry;\n\t          var scaleX = rx > ry ? 1 : rx / ry;\n\t          var scaleY = rx > ry ? ry / rx : 1;\n\t          var isEllipse = Math.abs(rx - ry) > 1e-3;\n\t          var endAngle = theta + dTheta;\n\t\n\t          if (isEllipse) {\n\t            ctx.translate(cx, cy);\n\t            ctx.rotate(psi);\n\t            ctx.scale(scaleX, scaleY);\n\t            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n\t            ctx.scale(1 / scaleX, 1 / scaleY);\n\t            ctx.rotate(-psi);\n\t            ctx.translate(-cx, -cy);\n\t          } else {\n\t            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n\t          }\n\t\n\t          if (i == 1) {\n\t            // 直接使用 arc 命令\n\t            // 第一个命令起点还未定义\n\t            x0 = mathCos(theta) * rx + cx;\n\t            y0 = mathSin(theta) * ry + cy;\n\t          }\n\t\n\t          xi = mathCos(endAngle) * rx + cx;\n\t          yi = mathSin(endAngle) * ry + cy;\n\t          break;\n\t\n\t        case CMD.R:\n\t          x0 = xi = d[i];\n\t          y0 = yi = d[i + 1];\n\t          ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n\t          break;\n\t\n\t        case CMD.Z:\n\t          ctx.closePath();\n\t          xi = x0;\n\t          yi = y0;\n\t      }\n\t    }\n\t  }\n\t};\n\tPathProxy.CMD = CMD;\n\tvar _default = PathProxy;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _vector = __webpack_require__(15);\n\t\n\tvar v2Create = _vector.create;\n\tvar v2DistSquare = _vector.distSquare;\n\t\n\t/**\n\t * 曲线辅助模块\n\t * @module zrender/core/curve\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\tvar mathPow = Math.pow;\n\tvar mathSqrt = Math.sqrt;\n\tvar EPSILON = 1e-8;\n\tvar EPSILON_NUMERIC = 1e-4;\n\tvar THREE_SQRT = mathSqrt(3);\n\tvar ONE_THIRD = 1 / 3; // 临时变量\n\t\n\tvar _v0 = v2Create();\n\t\n\tvar _v1 = v2Create();\n\t\n\tvar _v2 = v2Create();\n\t\n\tfunction isAroundZero(val) {\n\t  return val > -EPSILON && val < EPSILON;\n\t}\n\t\n\tfunction isNotAroundZero(val) {\n\t  return val > EPSILON || val < -EPSILON;\n\t}\n\t/**\n\t * 计算三次贝塞尔值\n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {number} t\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction cubicAt(p0, p1, p2, p3, t) {\n\t  var onet = 1 - t;\n\t  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);\n\t}\n\t/**\n\t * 计算三次贝塞尔导数值\n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {number} t\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction cubicDerivativeAt(p0, p1, p2, p3, t) {\n\t  var onet = 1 - t;\n\t  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);\n\t}\n\t/**\n\t * 计算三次贝塞尔方程根，使用盛金公式\n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {number} val\n\t * @param  {Array.<number>} roots\n\t * @return {number} 有效根数目\n\t */\n\t\n\t\n\tfunction cubicRootAt(p0, p1, p2, p3, val, roots) {\n\t  // Evaluate roots of cubic functions\n\t  var a = p3 + 3 * (p1 - p2) - p0;\n\t  var b = 3 * (p2 - p1 * 2 + p0);\n\t  var c = 3 * (p1 - p0);\n\t  var d = p0 - val;\n\t  var A = b * b - 3 * a * c;\n\t  var B = b * c - 9 * a * d;\n\t  var C = c * c - 3 * b * d;\n\t  var n = 0;\n\t\n\t  if (isAroundZero(A) && isAroundZero(B)) {\n\t    if (isAroundZero(b)) {\n\t      roots[0] = 0;\n\t    } else {\n\t      var t1 = -c / b; //t1, t2, t3, b is not zero\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t    }\n\t  } else {\n\t    var disc = B * B - 4 * A * C;\n\t\n\t    if (isAroundZero(disc)) {\n\t      var K = B / A;\n\t      var t1 = -b / a + K; // t1, a is not zero\n\t\n\t      var t2 = -K / 2; // t2, t3\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t\n\t      if (t2 >= 0 && t2 <= 1) {\n\t        roots[n++] = t2;\n\t      }\n\t    } else if (disc > 0) {\n\t      var discSqrt = mathSqrt(disc);\n\t      var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n\t      var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\t\n\t      if (Y1 < 0) {\n\t        Y1 = -mathPow(-Y1, ONE_THIRD);\n\t      } else {\n\t        Y1 = mathPow(Y1, ONE_THIRD);\n\t      }\n\t\n\t      if (Y2 < 0) {\n\t        Y2 = -mathPow(-Y2, ONE_THIRD);\n\t      } else {\n\t        Y2 = mathPow(Y2, ONE_THIRD);\n\t      }\n\t\n\t      var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t    } else {\n\t      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n\t      var theta = Math.acos(T) / 3;\n\t      var ASqrt = mathSqrt(A);\n\t      var tmp = Math.cos(theta);\n\t      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n\t      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t\n\t      if (t2 >= 0 && t2 <= 1) {\n\t        roots[n++] = t2;\n\t      }\n\t\n\t      if (t3 >= 0 && t3 <= 1) {\n\t        roots[n++] = t3;\n\t      }\n\t    }\n\t  }\n\t\n\t  return n;\n\t}\n\t/**\n\t * 计算三次贝塞尔方程极限值的位置\n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {Array.<number>} extrema\n\t * @return {number} 有效数目\n\t */\n\t\n\t\n\tfunction cubicExtrema(p0, p1, p2, p3, extrema) {\n\t  var b = 6 * p2 - 12 * p1 + 6 * p0;\n\t  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n\t  var c = 3 * p1 - 3 * p0;\n\t  var n = 0;\n\t\n\t  if (isAroundZero(a)) {\n\t    if (isNotAroundZero(b)) {\n\t      var t1 = -c / b;\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        extrema[n++] = t1;\n\t      }\n\t    }\n\t  } else {\n\t    var disc = b * b - 4 * a * c;\n\t\n\t    if (isAroundZero(disc)) {\n\t      extrema[0] = -b / (2 * a);\n\t    } else if (disc > 0) {\n\t      var discSqrt = mathSqrt(disc);\n\t      var t1 = (-b + discSqrt) / (2 * a);\n\t      var t2 = (-b - discSqrt) / (2 * a);\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        extrema[n++] = t1;\n\t      }\n\t\n\t      if (t2 >= 0 && t2 <= 1) {\n\t        extrema[n++] = t2;\n\t      }\n\t    }\n\t  }\n\t\n\t  return n;\n\t}\n\t/**\n\t * 细分三次贝塞尔曲线\n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {number} t\n\t * @param  {Array.<number>} out\n\t */\n\t\n\t\n\tfunction cubicSubdivide(p0, p1, p2, p3, t, out) {\n\t  var p01 = (p1 - p0) * t + p0;\n\t  var p12 = (p2 - p1) * t + p1;\n\t  var p23 = (p3 - p2) * t + p2;\n\t  var p012 = (p12 - p01) * t + p01;\n\t  var p123 = (p23 - p12) * t + p12;\n\t  var p0123 = (p123 - p012) * t + p012; // Seg0\n\t\n\t  out[0] = p0;\n\t  out[1] = p01;\n\t  out[2] = p012;\n\t  out[3] = p0123; // Seg1\n\t\n\t  out[4] = p0123;\n\t  out[5] = p123;\n\t  out[6] = p23;\n\t  out[7] = p3;\n\t}\n\t/**\n\t * 投射点到三次贝塞尔曲线上，返回投射距离。\n\t * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n\t * @param {number} x0\n\t * @param {number} y0\n\t * @param {number} x1\n\t * @param {number} y1\n\t * @param {number} x2\n\t * @param {number} y2\n\t * @param {number} x3\n\t * @param {number} y3\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {Array.<number>} [out] 投射点\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {\n\t  // http://pomax.github.io/bezierinfo/#projections\n\t  var t;\n\t  var interval = 0.005;\n\t  var d = Infinity;\n\t  var prev;\n\t  var next;\n\t  var d1;\n\t  var d2;\n\t  _v0[0] = x;\n\t  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值\n\t  // PENDING\n\t\n\t  for (var _t = 0; _t < 1; _t += 0.05) {\n\t    _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n\t    _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n\t    d1 = v2DistSquare(_v0, _v1);\n\t\n\t    if (d1 < d) {\n\t      t = _t;\n\t      d = d1;\n\t    }\n\t  }\n\t\n\t  d = Infinity; // At most 32 iteration\n\t\n\t  for (var i = 0; i < 32; i++) {\n\t    if (interval < EPSILON_NUMERIC) {\n\t      break;\n\t    }\n\t\n\t    prev = t - interval;\n\t    next = t + interval; // t - interval\n\t\n\t    _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n\t    _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\t    d1 = v2DistSquare(_v1, _v0);\n\t\n\t    if (prev >= 0 && d1 < d) {\n\t      t = prev;\n\t      d = d1;\n\t    } else {\n\t      // t + interval\n\t      _v2[0] = cubicAt(x0, x1, x2, x3, next);\n\t      _v2[1] = cubicAt(y0, y1, y2, y3, next);\n\t      d2 = v2DistSquare(_v2, _v0);\n\t\n\t      if (next <= 1 && d2 < d) {\n\t        t = next;\n\t        d = d2;\n\t      } else {\n\t        interval *= 0.5;\n\t      }\n\t    }\n\t  } // t\n\t\n\t\n\t  if (out) {\n\t    out[0] = cubicAt(x0, x1, x2, x3, t);\n\t    out[1] = cubicAt(y0, y1, y2, y3, t);\n\t  } // console.log(interval, i);\n\t\n\t\n\t  return mathSqrt(d);\n\t}\n\t/**\n\t * 计算二次方贝塞尔值\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} t\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction quadraticAt(p0, p1, p2, t) {\n\t  var onet = 1 - t;\n\t  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n\t}\n\t/**\n\t * 计算二次方贝塞尔导数值\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} t\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction quadraticDerivativeAt(p0, p1, p2, t) {\n\t  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n\t}\n\t/**\n\t * 计算二次方贝塞尔方程根\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} t\n\t * @param  {Array.<number>} roots\n\t * @return {number} 有效根数目\n\t */\n\t\n\t\n\tfunction quadraticRootAt(p0, p1, p2, val, roots) {\n\t  var a = p0 - 2 * p1 + p2;\n\t  var b = 2 * (p1 - p0);\n\t  var c = p0 - val;\n\t  var n = 0;\n\t\n\t  if (isAroundZero(a)) {\n\t    if (isNotAroundZero(b)) {\n\t      var t1 = -c / b;\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t    }\n\t  } else {\n\t    var disc = b * b - 4 * a * c;\n\t\n\t    if (isAroundZero(disc)) {\n\t      var t1 = -b / (2 * a);\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t    } else if (disc > 0) {\n\t      var discSqrt = mathSqrt(disc);\n\t      var t1 = (-b + discSqrt) / (2 * a);\n\t      var t2 = (-b - discSqrt) / (2 * a);\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t\n\t      if (t2 >= 0 && t2 <= 1) {\n\t        roots[n++] = t2;\n\t      }\n\t    }\n\t  }\n\t\n\t  return n;\n\t}\n\t/**\n\t * 计算二次贝塞尔方程极限值\n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction quadraticExtremum(p0, p1, p2) {\n\t  var divider = p0 + p2 - 2 * p1;\n\t\n\t  if (divider === 0) {\n\t    // p1 is center of p0 and p2\n\t    return 0.5;\n\t  } else {\n\t    return (p0 - p1) / divider;\n\t  }\n\t}\n\t/**\n\t * 细分二次贝塞尔曲线\n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} t\n\t * @param  {Array.<number>} out\n\t */\n\t\n\t\n\tfunction quadraticSubdivide(p0, p1, p2, t, out) {\n\t  var p01 = (p1 - p0) * t + p0;\n\t  var p12 = (p2 - p1) * t + p1;\n\t  var p012 = (p12 - p01) * t + p01; // Seg0\n\t\n\t  out[0] = p0;\n\t  out[1] = p01;\n\t  out[2] = p012; // Seg1\n\t\n\t  out[3] = p012;\n\t  out[4] = p12;\n\t  out[5] = p2;\n\t}\n\t/**\n\t * 投射点到二次贝塞尔曲线上，返回投射距离。\n\t * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n\t * @param {number} x0\n\t * @param {number} y0\n\t * @param {number} x1\n\t * @param {number} y1\n\t * @param {number} x2\n\t * @param {number} y2\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {Array.<number>} out 投射点\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {\n\t  // http://pomax.github.io/bezierinfo/#projections\n\t  var t;\n\t  var interval = 0.005;\n\t  var d = Infinity;\n\t  _v0[0] = x;\n\t  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值\n\t  // PENDING\n\t\n\t  for (var _t = 0; _t < 1; _t += 0.05) {\n\t    _v1[0] = quadraticAt(x0, x1, x2, _t);\n\t    _v1[1] = quadraticAt(y0, y1, y2, _t);\n\t    var d1 = v2DistSquare(_v0, _v1);\n\t\n\t    if (d1 < d) {\n\t      t = _t;\n\t      d = d1;\n\t    }\n\t  }\n\t\n\t  d = Infinity; // At most 32 iteration\n\t\n\t  for (var i = 0; i < 32; i++) {\n\t    if (interval < EPSILON_NUMERIC) {\n\t      break;\n\t    }\n\t\n\t    var prev = t - interval;\n\t    var next = t + interval; // t - interval\n\t\n\t    _v1[0] = quadraticAt(x0, x1, x2, prev);\n\t    _v1[1] = quadraticAt(y0, y1, y2, prev);\n\t    var d1 = v2DistSquare(_v1, _v0);\n\t\n\t    if (prev >= 0 && d1 < d) {\n\t      t = prev;\n\t      d = d1;\n\t    } else {\n\t      // t + interval\n\t      _v2[0] = quadraticAt(x0, x1, x2, next);\n\t      _v2[1] = quadraticAt(y0, y1, y2, next);\n\t      var d2 = v2DistSquare(_v2, _v0);\n\t\n\t      if (next <= 1 && d2 < d) {\n\t        t = next;\n\t        d = d2;\n\t      } else {\n\t        interval *= 0.5;\n\t      }\n\t    }\n\t  } // t\n\t\n\t\n\t  if (out) {\n\t    out[0] = quadraticAt(x0, x1, x2, t);\n\t    out[1] = quadraticAt(y0, y1, y2, t);\n\t  } // console.log(interval, i);\n\t\n\t\n\t  return mathSqrt(d);\n\t}\n\t\n\texports.cubicAt = cubicAt;\n\texports.cubicDerivativeAt = cubicDerivativeAt;\n\texports.cubicRootAt = cubicRootAt;\n\texports.cubicExtrema = cubicExtrema;\n\texports.cubicSubdivide = cubicSubdivide;\n\texports.cubicProjectPoint = cubicProjectPoint;\n\texports.quadraticAt = quadraticAt;\n\texports.quadraticDerivativeAt = quadraticDerivativeAt;\n\texports.quadraticRootAt = quadraticRootAt;\n\texports.quadraticExtremum = quadraticExtremum;\n\texports.quadraticSubdivide = quadraticSubdivide;\n\texports.quadraticProjectPoint = quadraticProjectPoint;\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar vec2 = __webpack_require__(15);\n\t\n\tvar curve = __webpack_require__(31);\n\t\n\t/**\n\t * @author Yi Shen(https://github.com/pissang)\n\t */\n\tvar mathMin = Math.min;\n\tvar mathMax = Math.max;\n\tvar mathSin = Math.sin;\n\tvar mathCos = Math.cos;\n\tvar PI2 = Math.PI * 2;\n\tvar start = vec2.create();\n\tvar end = vec2.create();\n\tvar extremity = vec2.create();\n\t/**\n\t * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n\t * @module zrender/core/bbox\n\t * @param {Array<Object>} points 顶点数组\n\t * @param {number} min\n\t * @param {number} max\n\t */\n\t\n\tfunction fromPoints(points, min, max) {\n\t  if (points.length === 0) {\n\t    return;\n\t  }\n\t\n\t  var p = points[0];\n\t  var left = p[0];\n\t  var right = p[0];\n\t  var top = p[1];\n\t  var bottom = p[1];\n\t  var i;\n\t\n\t  for (i = 1; i < points.length; i++) {\n\t    p = points[i];\n\t    left = mathMin(left, p[0]);\n\t    right = mathMax(right, p[0]);\n\t    top = mathMin(top, p[1]);\n\t    bottom = mathMax(bottom, p[1]);\n\t  }\n\t\n\t  min[0] = left;\n\t  min[1] = top;\n\t  max[0] = right;\n\t  max[1] = bottom;\n\t}\n\t/**\n\t * @memberOf module:zrender/core/bbox\n\t * @param {number} x0\n\t * @param {number} y0\n\t * @param {number} x1\n\t * @param {number} y1\n\t * @param {Array.<number>} min\n\t * @param {Array.<number>} max\n\t */\n\t\n\t\n\tfunction fromLine(x0, y0, x1, y1, min, max) {\n\t  min[0] = mathMin(x0, x1);\n\t  min[1] = mathMin(y0, y1);\n\t  max[0] = mathMax(x0, x1);\n\t  max[1] = mathMax(y0, y1);\n\t}\n\t\n\tvar xDim = [];\n\tvar yDim = [];\n\t/**\n\t * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n\t * @memberOf module:zrender/core/bbox\n\t * @param {number} x0\n\t * @param {number} y0\n\t * @param {number} x1\n\t * @param {number} y1\n\t * @param {number} x2\n\t * @param {number} y2\n\t * @param {number} x3\n\t * @param {number} y3\n\t * @param {Array.<number>} min\n\t * @param {Array.<number>} max\n\t */\n\t\n\tfunction fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {\n\t  var cubicExtrema = curve.cubicExtrema;\n\t  var cubicAt = curve.cubicAt;\n\t  var i;\n\t  var n = cubicExtrema(x0, x1, x2, x3, xDim);\n\t  min[0] = Infinity;\n\t  min[1] = Infinity;\n\t  max[0] = -Infinity;\n\t  max[1] = -Infinity;\n\t\n\t  for (i = 0; i < n; i++) {\n\t    var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n\t    min[0] = mathMin(x, min[0]);\n\t    max[0] = mathMax(x, max[0]);\n\t  }\n\t\n\t  n = cubicExtrema(y0, y1, y2, y3, yDim);\n\t\n\t  for (i = 0; i < n; i++) {\n\t    var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n\t    min[1] = mathMin(y, min[1]);\n\t    max[1] = mathMax(y, max[1]);\n\t  }\n\t\n\t  min[0] = mathMin(x0, min[0]);\n\t  max[0] = mathMax(x0, max[0]);\n\t  min[0] = mathMin(x3, min[0]);\n\t  max[0] = mathMax(x3, max[0]);\n\t  min[1] = mathMin(y0, min[1]);\n\t  max[1] = mathMax(y0, max[1]);\n\t  min[1] = mathMin(y3, min[1]);\n\t  max[1] = mathMax(y3, max[1]);\n\t}\n\t/**\n\t * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n\t * @memberOf module:zrender/core/bbox\n\t * @param {number} x0\n\t * @param {number} y0\n\t * @param {number} x1\n\t * @param {number} y1\n\t * @param {number} x2\n\t * @param {number} y2\n\t * @param {Array.<number>} min\n\t * @param {Array.<number>} max\n\t */\n\t\n\t\n\tfunction fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {\n\t  var quadraticExtremum = curve.quadraticExtremum;\n\t  var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero\n\t\n\t  var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);\n\t  var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);\n\t  var x = quadraticAt(x0, x1, x2, tx);\n\t  var y = quadraticAt(y0, y1, y2, ty);\n\t  min[0] = mathMin(x0, x2, x);\n\t  min[1] = mathMin(y0, y2, y);\n\t  max[0] = mathMax(x0, x2, x);\n\t  max[1] = mathMax(y0, y2, y);\n\t}\n\t/**\n\t * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n\t * @method\n\t * @memberOf module:zrender/core/bbox\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {number} rx\n\t * @param {number} ry\n\t * @param {number} startAngle\n\t * @param {number} endAngle\n\t * @param {number} anticlockwise\n\t * @param {Array.<number>} min\n\t * @param {Array.<number>} max\n\t */\n\t\n\t\n\tfunction fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {\n\t  var vec2Min = vec2.min;\n\t  var vec2Max = vec2.max;\n\t  var diff = Math.abs(startAngle - endAngle);\n\t\n\t  if (diff % PI2 < 1e-4 && diff > 1e-4) {\n\t    // Is a circle\n\t    min[0] = x - rx;\n\t    min[1] = y - ry;\n\t    max[0] = x + rx;\n\t    max[1] = y + ry;\n\t    return;\n\t  }\n\t\n\t  start[0] = mathCos(startAngle) * rx + x;\n\t  start[1] = mathSin(startAngle) * ry + y;\n\t  end[0] = mathCos(endAngle) * rx + x;\n\t  end[1] = mathSin(endAngle) * ry + y;\n\t  vec2Min(min, start, end);\n\t  vec2Max(max, start, end); // Thresh to [0, Math.PI * 2]\n\t\n\t  startAngle = startAngle % PI2;\n\t\n\t  if (startAngle < 0) {\n\t    startAngle = startAngle + PI2;\n\t  }\n\t\n\t  endAngle = endAngle % PI2;\n\t\n\t  if (endAngle < 0) {\n\t    endAngle = endAngle + PI2;\n\t  }\n\t\n\t  if (startAngle > endAngle && !anticlockwise) {\n\t    endAngle += PI2;\n\t  } else if (startAngle < endAngle && anticlockwise) {\n\t    startAngle += PI2;\n\t  }\n\t\n\t  if (anticlockwise) {\n\t    var tmp = endAngle;\n\t    endAngle = startAngle;\n\t    startAngle = tmp;\n\t  } // var number = 0;\n\t  // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\t\n\t\n\t  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n\t    if (angle > startAngle) {\n\t      extremity[0] = mathCos(angle) * rx + x;\n\t      extremity[1] = mathSin(angle) * ry + y;\n\t      vec2Min(min, extremity, min);\n\t      vec2Max(max, extremity, max);\n\t    }\n\t  }\n\t}\n\t\n\texports.fromPoints = fromPoints;\n\texports.fromLine = fromLine;\n\texports.fromCubic = fromCubic;\n\texports.fromQuadratic = fromQuadratic;\n\texports.fromArc = fromArc;\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar PathProxy = __webpack_require__(30);\n\t\n\tvar line = __webpack_require__(34);\n\t\n\tvar cubic = __webpack_require__(35);\n\t\n\tvar quadratic = __webpack_require__(36);\n\t\n\tvar arc = __webpack_require__(37);\n\t\n\tvar _util = __webpack_require__(38);\n\t\n\tvar normalizeRadian = _util.normalizeRadian;\n\t\n\tvar curve = __webpack_require__(31);\n\t\n\tvar windingLine = __webpack_require__(39);\n\t\n\tvar CMD = PathProxy.CMD;\n\tvar PI2 = Math.PI * 2;\n\tvar EPSILON = 1e-4;\n\t\n\tfunction isAroundEqual(a, b) {\n\t  return Math.abs(a - b) < EPSILON;\n\t} // 临时数组\n\t\n\t\n\tvar roots = [-1, -1, -1];\n\tvar extrema = [-1, -1];\n\t\n\tfunction swapExtrema() {\n\t  var tmp = extrema[0];\n\t  extrema[0] = extrema[1];\n\t  extrema[1] = tmp;\n\t}\n\t\n\tfunction windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n\t  // Quick reject\n\t  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {\n\t    return 0;\n\t  }\n\t\n\t  var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\t\n\t  if (nRoots === 0) {\n\t    return 0;\n\t  } else {\n\t    var w = 0;\n\t    var nExtrema = -1;\n\t    var y0_, y1_;\n\t\n\t    for (var i = 0; i < nRoots; i++) {\n\t      var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon\n\t\n\t      var unit = t === 0 || t === 1 ? 0.5 : 1;\n\t      var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\t\n\t      if (x_ < x) {\n\t        // Quick reject\n\t        continue;\n\t      }\n\t\n\t      if (nExtrema < 0) {\n\t        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\t\n\t        if (extrema[1] < extrema[0] && nExtrema > 1) {\n\t          swapExtrema();\n\t        }\n\t\n\t        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\t\n\t        if (nExtrema > 1) {\n\t          y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n\t        }\n\t      }\n\t\n\t      if (nExtrema == 2) {\n\t        // 分成三段单调函数\n\t        if (t < extrema[0]) {\n\t          w += y0_ < y0 ? unit : -unit;\n\t        } else if (t < extrema[1]) {\n\t          w += y1_ < y0_ ? unit : -unit;\n\t        } else {\n\t          w += y3 < y1_ ? unit : -unit;\n\t        }\n\t      } else {\n\t        // 分成两段单调函数\n\t        if (t < extrema[0]) {\n\t          w += y0_ < y0 ? unit : -unit;\n\t        } else {\n\t          w += y3 < y0_ ? unit : -unit;\n\t        }\n\t      }\n\t    }\n\t\n\t    return w;\n\t  }\n\t}\n\t\n\tfunction windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n\t  // Quick reject\n\t  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {\n\t    return 0;\n\t  }\n\t\n\t  var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\t\n\t  if (nRoots === 0) {\n\t    return 0;\n\t  } else {\n\t    var t = curve.quadraticExtremum(y0, y1, y2);\n\t\n\t    if (t >= 0 && t <= 1) {\n\t      var w = 0;\n\t      var y_ = curve.quadraticAt(y0, y1, y2, t);\n\t\n\t      for (var i = 0; i < nRoots; i++) {\n\t        // Remove one endpoint.\n\t        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;\n\t        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\t\n\t        if (x_ < x) {\n\t          // Quick reject\n\t          continue;\n\t        }\n\t\n\t        if (roots[i] < t) {\n\t          w += y_ < y0 ? unit : -unit;\n\t        } else {\n\t          w += y2 < y_ ? unit : -unit;\n\t        }\n\t      }\n\t\n\t      return w;\n\t    } else {\n\t      // Remove one endpoint.\n\t      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;\n\t      var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\t\n\t      if (x_ < x) {\n\t        // Quick reject\n\t        return 0;\n\t      }\n\t\n\t      return y2 < y0 ? unit : -unit;\n\t    }\n\t  }\n\t} // TODO\n\t// Arc 旋转\n\t\n\t\n\tfunction windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {\n\t  y -= cy;\n\t\n\t  if (y > r || y < -r) {\n\t    return 0;\n\t  }\n\t\n\t  var tmp = Math.sqrt(r * r - y * y);\n\t  roots[0] = -tmp;\n\t  roots[1] = tmp;\n\t  var diff = Math.abs(startAngle - endAngle);\n\t\n\t  if (diff < 1e-4) {\n\t    return 0;\n\t  }\n\t\n\t  if (diff % PI2 < 1e-4) {\n\t    // Is a circle\n\t    startAngle = 0;\n\t    endAngle = PI2;\n\t    var dir = anticlockwise ? 1 : -1;\n\t\n\t    if (x >= roots[0] + cx && x <= roots[1] + cx) {\n\t      return dir;\n\t    } else {\n\t      return 0;\n\t    }\n\t  }\n\t\n\t  if (anticlockwise) {\n\t    var tmp = startAngle;\n\t    startAngle = normalizeRadian(endAngle);\n\t    endAngle = normalizeRadian(tmp);\n\t  } else {\n\t    startAngle = normalizeRadian(startAngle);\n\t    endAngle = normalizeRadian(endAngle);\n\t  }\n\t\n\t  if (startAngle > endAngle) {\n\t    endAngle += PI2;\n\t  }\n\t\n\t  var w = 0;\n\t\n\t  for (var i = 0; i < 2; i++) {\n\t    var x_ = roots[i];\n\t\n\t    if (x_ + cx > x) {\n\t      var angle = Math.atan2(y, x_);\n\t      var dir = anticlockwise ? 1 : -1;\n\t\n\t      if (angle < 0) {\n\t        angle = PI2 + angle;\n\t      }\n\t\n\t      if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n\t        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n\t          dir = -dir;\n\t        }\n\t\n\t        w += dir;\n\t      }\n\t    }\n\t  }\n\t\n\t  return w;\n\t}\n\t\n\tfunction containPath(data, lineWidth, isStroke, x, y) {\n\t  var w = 0;\n\t  var xi = 0;\n\t  var yi = 0;\n\t  var x0 = 0;\n\t  var y0 = 0;\n\t\n\t  for (var i = 0; i < data.length;) {\n\t    var cmd = data[i++]; // Begin a new subpath\n\t\n\t    if (cmd === CMD.M && i > 1) {\n\t      // Close previous subpath\n\t      if (!isStroke) {\n\t        w += windingLine(xi, yi, x0, y0, x, y);\n\t      } // 如果被任何一个 subpath 包含\n\t      // if (w !== 0) {\n\t      //     return true;\n\t      // }\n\t\n\t    }\n\t\n\t    if (i == 1) {\n\t      // 如果第一个命令是 L, C, Q\n\t      // 则 previous point 同绘制命令的第一个 point\n\t      //\n\t      // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t      xi = data[i];\n\t      yi = data[i + 1];\n\t      x0 = xi;\n\t      y0 = yi;\n\t    }\n\t\n\t    switch (cmd) {\n\t      case CMD.M:\n\t        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n\t        // 在 closePath 的时候使用\n\t        x0 = data[i++];\n\t        y0 = data[i++];\n\t        xi = x0;\n\t        yi = y0;\n\t        break;\n\t\n\t      case CMD.L:\n\t        if (isStroke) {\n\t          if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n\t          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n\t        }\n\t\n\t        xi = data[i++];\n\t        yi = data[i++];\n\t        break;\n\t\n\t      case CMD.C:\n\t        if (isStroke) {\n\t          if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n\t        }\n\t\n\t        xi = data[i++];\n\t        yi = data[i++];\n\t        break;\n\t\n\t      case CMD.Q:\n\t        if (isStroke) {\n\t          if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n\t        }\n\t\n\t        xi = data[i++];\n\t        yi = data[i++];\n\t        break;\n\t\n\t      case CMD.A:\n\t        // TODO Arc 判断的开销比较大\n\t        var cx = data[i++];\n\t        var cy = data[i++];\n\t        var rx = data[i++];\n\t        var ry = data[i++];\n\t        var theta = data[i++];\n\t        var dTheta = data[i++]; // TODO Arc 旋转\n\t\n\t        var psi = data[i++];\n\t        var anticlockwise = 1 - data[i++];\n\t        var x1 = Math.cos(theta) * rx + cx;\n\t        var y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令\n\t\n\t        if (i > 1) {\n\t          w += windingLine(xi, yi, x1, y1, x, y);\n\t        } else {\n\t          // 第一个命令起点还未定义\n\t          x0 = x1;\n\t          y0 = y1;\n\t        } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n\t\n\t\n\t        var _x = (x - cx) * ry / rx + cx;\n\t\n\t        if (isStroke) {\n\t          if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);\n\t        }\n\t\n\t        xi = Math.cos(theta + dTheta) * rx + cx;\n\t        yi = Math.sin(theta + dTheta) * ry + cy;\n\t        break;\n\t\n\t      case CMD.R:\n\t        x0 = xi = data[i++];\n\t        y0 = yi = data[i++];\n\t        var width = data[i++];\n\t        var height = data[i++];\n\t        var x1 = x0 + width;\n\t        var y1 = y0 + height;\n\t\n\t        if (isStroke) {\n\t          if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          // FIXME Clockwise ?\n\t          w += windingLine(x1, y0, x1, y1, x, y);\n\t          w += windingLine(x0, y1, x0, y0, x, y);\n\t        }\n\t\n\t        break;\n\t\n\t      case CMD.Z:\n\t        if (isStroke) {\n\t          if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          // Close a subpath\n\t          w += windingLine(xi, yi, x0, y0, x, y); // 如果被任何一个 subpath 包含\n\t          // FIXME subpaths may overlap\n\t          // if (w !== 0) {\n\t          //     return true;\n\t          // }\n\t        }\n\t\n\t        xi = x0;\n\t        yi = y0;\n\t        break;\n\t    }\n\t  }\n\t\n\t  if (!isStroke && !isAroundEqual(yi, y0)) {\n\t    w += windingLine(xi, yi, x0, y0, x, y) || 0;\n\t  }\n\t\n\t  return w !== 0;\n\t}\n\t\n\tfunction contain(pathData, x, y) {\n\t  return containPath(pathData, 0, false, x, y);\n\t}\n\t\n\tfunction containStroke(pathData, lineWidth, x, y) {\n\t  return containPath(pathData, lineWidth, true, x, y);\n\t}\n\t\n\texports.contain = contain;\n\texports.containStroke = containStroke;\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * 线段包含判断\n\t * @param  {number}  x0\n\t * @param  {number}  y0\n\t * @param  {number}  x1\n\t * @param  {number}  y1\n\t * @param  {number}  lineWidth\n\t * @param  {number}  x\n\t * @param  {number}  y\n\t * @return {boolean}\n\t */\n\tfunction containStroke(x0, y0, x1, y1, lineWidth, x, y) {\n\t  if (lineWidth === 0) {\n\t    return false;\n\t  }\n\t\n\t  var _l = lineWidth;\n\t  var _a = 0;\n\t  var _b = x0; // Quick reject\n\t\n\t  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {\n\t    return false;\n\t  }\n\t\n\t  if (x0 !== x1) {\n\t    _a = (y0 - y1) / (x0 - x1);\n\t    _b = (x0 * y1 - x1 * y0) / (x0 - x1);\n\t  } else {\n\t    return Math.abs(x - x0) <= _l / 2;\n\t  }\n\t\n\t  var tmp = _a * x - y + _b;\n\t\n\t  var _s = tmp * tmp / (_a * _a + 1);\n\t\n\t  return _s <= _l / 2 * _l / 2;\n\t}\n\t\n\texports.containStroke = containStroke;\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar curve = __webpack_require__(31);\n\t\n\t/**\n\t * 三次贝塞尔曲线描边包含判断\n\t * @param  {number}  x0\n\t * @param  {number}  y0\n\t * @param  {number}  x1\n\t * @param  {number}  y1\n\t * @param  {number}  x2\n\t * @param  {number}  y2\n\t * @param  {number}  x3\n\t * @param  {number}  y3\n\t * @param  {number}  lineWidth\n\t * @param  {number}  x\n\t * @param  {number}  y\n\t * @return {boolean}\n\t */\n\tfunction containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n\t  if (lineWidth === 0) {\n\t    return false;\n\t  }\n\t\n\t  var _l = lineWidth; // Quick reject\n\t\n\t  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {\n\t    return false;\n\t  }\n\t\n\t  var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);\n\t  return d <= _l / 2;\n\t}\n\t\n\texports.containStroke = containStroke;\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _curve = __webpack_require__(31);\n\t\n\tvar quadraticProjectPoint = _curve.quadraticProjectPoint;\n\t\n\t/**\n\t * 二次贝塞尔曲线描边包含判断\n\t * @param  {number}  x0\n\t * @param  {number}  y0\n\t * @param  {number}  x1\n\t * @param  {number}  y1\n\t * @param  {number}  x2\n\t * @param  {number}  y2\n\t * @param  {number}  lineWidth\n\t * @param  {number}  x\n\t * @param  {number}  y\n\t * @return {boolean}\n\t */\n\tfunction containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n\t  if (lineWidth === 0) {\n\t    return false;\n\t  }\n\t\n\t  var _l = lineWidth; // Quick reject\n\t\n\t  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {\n\t    return false;\n\t  }\n\t\n\t  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);\n\t  return d <= _l / 2;\n\t}\n\t\n\texports.containStroke = containStroke;\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _util = __webpack_require__(38);\n\t\n\tvar normalizeRadian = _util.normalizeRadian;\n\tvar PI2 = Math.PI * 2;\n\t/**\n\t * 圆弧描边包含判断\n\t * @param  {number}  cx\n\t * @param  {number}  cy\n\t * @param  {number}  r\n\t * @param  {number}  startAngle\n\t * @param  {number}  endAngle\n\t * @param  {boolean}  anticlockwise\n\t * @param  {number} lineWidth\n\t * @param  {number}  x\n\t * @param  {number}  y\n\t * @return {Boolean}\n\t */\n\t\n\tfunction containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {\n\t  if (lineWidth === 0) {\n\t    return false;\n\t  }\n\t\n\t  var _l = lineWidth;\n\t  x -= cx;\n\t  y -= cy;\n\t  var d = Math.sqrt(x * x + y * y);\n\t\n\t  if (d - _l > r || d + _l < r) {\n\t    return false;\n\t  }\n\t\n\t  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n\t    // Is a circle\n\t    return true;\n\t  }\n\t\n\t  if (anticlockwise) {\n\t    var tmp = startAngle;\n\t    startAngle = normalizeRadian(endAngle);\n\t    endAngle = normalizeRadian(tmp);\n\t  } else {\n\t    startAngle = normalizeRadian(startAngle);\n\t    endAngle = normalizeRadian(endAngle);\n\t  }\n\t\n\t  if (startAngle > endAngle) {\n\t    endAngle += PI2;\n\t  }\n\t\n\t  var angle = Math.atan2(y, x);\n\t\n\t  if (angle < 0) {\n\t    angle += PI2;\n\t  }\n\t\n\t  return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;\n\t}\n\t\n\texports.containStroke = containStroke;\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports) {\n\n\tvar PI2 = Math.PI * 2;\n\t\n\tfunction normalizeRadian(angle) {\n\t  angle %= PI2;\n\t\n\t  if (angle < 0) {\n\t    angle += PI2;\n\t  }\n\t\n\t  return angle;\n\t}\n\t\n\texports.normalizeRadian = normalizeRadian;\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports) {\n\n\tfunction windingLine(x0, y0, x1, y1, x, y) {\n\t  if (y > y0 && y > y1 || y < y0 && y < y1) {\n\t    return 0;\n\t  } // Ignore horizontal line\n\t\n\t\n\t  if (y1 === y0) {\n\t    return 0;\n\t  }\n\t\n\t  var dir = y1 < y0 ? 1 : -1;\n\t  var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon\n\t\n\t  if (t === 1 || t === 0) {\n\t    dir = y1 < y0 ? 0.5 : -0.5;\n\t  }\n\t\n\t  var x_ = t * (x1 - x0) + x0;\n\t  return x_ > x ? dir : 0;\n\t}\n\t\n\tmodule.exports = windingLine;\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports) {\n\n\tvar Pattern = function (image, repeat) {\n\t  // Should do nothing more in this constructor. Because gradient can be\n\t  // declard by `color: {image: ...}`, where this constructor will not be called.\n\t  this.image = image;\n\t  this.repeat = repeat; // Can be cloned\n\t\n\t  this.type = 'pattern';\n\t};\n\t\n\tPattern.prototype.getCanvasPattern = function (ctx) {\n\t  return ctx.createPattern(this.image, this.repeat || 'repeat');\n\t};\n\t\n\tvar _default = Pattern;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar PathProxy = __webpack_require__(30);\n\t\n\tvar _vector = __webpack_require__(15);\n\t\n\tvar v2ApplyTransform = _vector.applyTransform;\n\tvar CMD = PathProxy.CMD;\n\tvar points = [[], [], []];\n\tvar mathSqrt = Math.sqrt;\n\tvar mathAtan2 = Math.atan2;\n\t\n\tfunction _default(path, m) {\n\t  var data = path.data;\n\t  var cmd;\n\t  var nPoint;\n\t  var i;\n\t  var j;\n\t  var k;\n\t  var p;\n\t  var M = CMD.M;\n\t  var C = CMD.C;\n\t  var L = CMD.L;\n\t  var R = CMD.R;\n\t  var A = CMD.A;\n\t  var Q = CMD.Q;\n\t\n\t  for (i = 0, j = 0; i < data.length;) {\n\t    cmd = data[i++];\n\t    j = i;\n\t    nPoint = 0;\n\t\n\t    switch (cmd) {\n\t      case M:\n\t        nPoint = 1;\n\t        break;\n\t\n\t      case L:\n\t        nPoint = 1;\n\t        break;\n\t\n\t      case C:\n\t        nPoint = 3;\n\t        break;\n\t\n\t      case Q:\n\t        nPoint = 2;\n\t        break;\n\t\n\t      case A:\n\t        var x = m[4];\n\t        var y = m[5];\n\t        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n\t        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n\t        var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx\n\t\n\t        data[i] *= sx;\n\t        data[i++] += x; // cy\n\t\n\t        data[i] *= sy;\n\t        data[i++] += y; // Scale rx and ry\n\t        // FIXME Assume psi is 0 here\n\t\n\t        data[i++] *= sx;\n\t        data[i++] *= sy; // Start angle\n\t\n\t        data[i++] += angle; // end angle\n\t\n\t        data[i++] += angle; // FIXME psi\n\t\n\t        i += 2;\n\t        j = i;\n\t        break;\n\t\n\t      case R:\n\t        // x0, y0\n\t        p[0] = data[i++];\n\t        p[1] = data[i++];\n\t        v2ApplyTransform(p, p, m);\n\t        data[j++] = p[0];\n\t        data[j++] = p[1]; // x1, y1\n\t\n\t        p[0] += data[i++];\n\t        p[1] += data[i++];\n\t        v2ApplyTransform(p, p, m);\n\t        data[j++] = p[0];\n\t        data[j++] = p[1];\n\t    }\n\t\n\t    for (k = 0; k < nPoint; k++) {\n\t      var p = points[k];\n\t      p[0] = data[i++];\n\t      p[1] = data[i++];\n\t      v2ApplyTransform(p, p, m); // Write back\n\t\n\t      data[j++] = p[0];\n\t      data[j++] = p[1];\n\t    }\n\t  }\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * @param {Array.<Object>} colorStops\n\t */\n\tvar Gradient = function (colorStops) {\n\t  this.colorStops = colorStops || [];\n\t};\n\t\n\tGradient.prototype = {\n\t  constructor: Gradient,\n\t  addColorStop: function (offset, color) {\n\t    this.colorStops.push({\n\t      offset: offset,\n\t      color: color\n\t    });\n\t  }\n\t};\n\tvar _default = Gradient;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports) {\n\n\t// TODO Draggable for group\n\t// FIXME Draggable on element which has parent rotation or scale\n\tfunction Draggable() {\n\t  this.on('mousedown', this._dragStart, this);\n\t  this.on('mousemove', this._drag, this);\n\t  this.on('mouseup', this._dragEnd, this);\n\t  this.on('globalout', this._dragEnd, this); // this._dropTarget = null;\n\t  // this._draggingTarget = null;\n\t  // this._x = 0;\n\t  // this._y = 0;\n\t}\n\t\n\tDraggable.prototype = {\n\t  constructor: Draggable,\n\t  _dragStart: function (e) {\n\t    var draggingTarget = e.target;\n\t\n\t    if (draggingTarget && draggingTarget.draggable) {\n\t      this._draggingTarget = draggingTarget;\n\t      draggingTarget.dragging = true;\n\t      this._x = e.offsetX;\n\t      this._y = e.offsetY;\n\t      this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n\t    }\n\t  },\n\t  _drag: function (e) {\n\t    var draggingTarget = this._draggingTarget;\n\t\n\t    if (draggingTarget) {\n\t      var x = e.offsetX;\n\t      var y = e.offsetY;\n\t      var dx = x - this._x;\n\t      var dy = y - this._y;\n\t      this._x = x;\n\t      this._y = y;\n\t      draggingTarget.drift(dx, dy, e);\n\t      this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n\t      var dropTarget = this.findHover(x, y, draggingTarget).target;\n\t      var lastDropTarget = this._dropTarget;\n\t      this._dropTarget = dropTarget;\n\t\n\t      if (draggingTarget !== dropTarget) {\n\t        if (lastDropTarget && dropTarget !== lastDropTarget) {\n\t          this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n\t        }\n\t\n\t        if (dropTarget && dropTarget !== lastDropTarget) {\n\t          this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n\t        }\n\t      }\n\t    }\n\t  },\n\t  _dragEnd: function (e) {\n\t    var draggingTarget = this._draggingTarget;\n\t\n\t    if (draggingTarget) {\n\t      draggingTarget.dragging = false;\n\t    }\n\t\n\t    this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\t\n\t    if (this._dropTarget) {\n\t      this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n\t    }\n\t\n\t    this._draggingTarget = null;\n\t    this._dropTarget = null;\n\t  }\n\t};\n\t\n\tfunction param(target, e) {\n\t  return {\n\t    target: target,\n\t    topTarget: e && e.topTarget\n\t  };\n\t}\n\t\n\tvar _default = Draggable;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrUtil = __webpack_require__(5);\n\t\n\tvar Element = __webpack_require__(10);\n\t\n\tvar BoundingRect = __webpack_require__(27);\n\t\n\t/**\n\t * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上\n\t * @module zrender/graphic/Group\n\t * @example\n\t *     var Group = require('zrender/container/Group');\n\t *     var Circle = require('zrender/graphic/shape/Circle');\n\t *     var g = new Group();\n\t *     g.position[0] = 100;\n\t *     g.position[1] = 100;\n\t *     g.add(new Circle({\n\t *         style: {\n\t *             x: 100,\n\t *             y: 100,\n\t *             r: 20,\n\t *         }\n\t *     }));\n\t *     zr.add(g);\n\t */\n\t\n\t/**\n\t * @alias module:zrender/graphic/Group\n\t * @constructor\n\t * @extends module:zrender/mixin/Transformable\n\t * @extends module:zrender/mixin/Eventful\n\t */\n\tvar Group = function (opts) {\n\t  opts = opts || {};\n\t  Element.call(this, opts);\n\t\n\t  for (var key in opts) {\n\t    if (opts.hasOwnProperty(key)) {\n\t      this[key] = opts[key];\n\t    }\n\t  }\n\t\n\t  this._children = [];\n\t  this.__storage = null;\n\t  this.__dirty = true;\n\t};\n\t\n\tGroup.prototype = {\n\t  constructor: Group,\n\t  isGroup: true,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  type: 'group',\n\t\n\t  /**\n\t   * 所有子孙元素是否响应鼠标事件\n\t   * @name module:/zrender/container/Group#silent\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  silent: false,\n\t\n\t  /**\n\t   * @return {Array.<module:zrender/Element>}\n\t   */\n\t  children: function () {\n\t    return this._children.slice();\n\t  },\n\t\n\t  /**\n\t   * 获取指定 index 的儿子节点\n\t   * @param  {number} idx\n\t   * @return {module:zrender/Element}\n\t   */\n\t  childAt: function (idx) {\n\t    return this._children[idx];\n\t  },\n\t\n\t  /**\n\t   * 获取指定名字的儿子节点\n\t   * @param  {string} name\n\t   * @return {module:zrender/Element}\n\t   */\n\t  childOfName: function (name) {\n\t    var children = this._children;\n\t\n\t    for (var i = 0; i < children.length; i++) {\n\t      if (children[i].name === name) {\n\t        return children[i];\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @return {number}\n\t   */\n\t  childCount: function () {\n\t    return this._children.length;\n\t  },\n\t\n\t  /**\n\t   * 添加子节点到最后\n\t   * @param {module:zrender/Element} child\n\t   */\n\t  add: function (child) {\n\t    if (child && child !== this && child.parent !== this) {\n\t      this._children.push(child);\n\t\n\t      this._doAdd(child);\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 添加子节点在 nextSibling 之前\n\t   * @param {module:zrender/Element} child\n\t   * @param {module:zrender/Element} nextSibling\n\t   */\n\t  addBefore: function (child, nextSibling) {\n\t    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {\n\t      var children = this._children;\n\t      var idx = children.indexOf(nextSibling);\n\t\n\t      if (idx >= 0) {\n\t        children.splice(idx, 0, child);\n\t\n\t        this._doAdd(child);\n\t      }\n\t    }\n\t\n\t    return this;\n\t  },\n\t  _doAdd: function (child) {\n\t    if (child.parent) {\n\t      child.parent.remove(child);\n\t    }\n\t\n\t    child.parent = this;\n\t    var storage = this.__storage;\n\t    var zr = this.__zr;\n\t\n\t    if (storage && storage !== child.__storage) {\n\t      storage.addToStorage(child);\n\t\n\t      if (child instanceof Group) {\n\t        child.addChildrenToStorage(storage);\n\t      }\n\t    }\n\t\n\t    zr && zr.refresh();\n\t  },\n\t\n\t  /**\n\t   * 移除子节点\n\t   * @param {module:zrender/Element} child\n\t   */\n\t  remove: function (child) {\n\t    var zr = this.__zr;\n\t    var storage = this.__storage;\n\t    var children = this._children;\n\t    var idx = zrUtil.indexOf(children, child);\n\t\n\t    if (idx < 0) {\n\t      return this;\n\t    }\n\t\n\t    children.splice(idx, 1);\n\t    child.parent = null;\n\t\n\t    if (storage) {\n\t      storage.delFromStorage(child);\n\t\n\t      if (child instanceof Group) {\n\t        child.delChildrenFromStorage(storage);\n\t      }\n\t    }\n\t\n\t    zr && zr.refresh();\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 移除所有子节点\n\t   */\n\t  removeAll: function () {\n\t    var children = this._children;\n\t    var storage = this.__storage;\n\t    var child;\n\t    var i;\n\t\n\t    for (i = 0; i < children.length; i++) {\n\t      child = children[i];\n\t\n\t      if (storage) {\n\t        storage.delFromStorage(child);\n\t\n\t        if (child instanceof Group) {\n\t          child.delChildrenFromStorage(storage);\n\t        }\n\t      }\n\t\n\t      child.parent = null;\n\t    }\n\t\n\t    children.length = 0;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 遍历所有子节点\n\t   * @param  {Function} cb\n\t   * @param  {}   context\n\t   */\n\t  eachChild: function (cb, context) {\n\t    var children = this._children;\n\t\n\t    for (var i = 0; i < children.length; i++) {\n\t      var child = children[i];\n\t      cb.call(context, child, i);\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 深度优先遍历所有子孙节点\n\t   * @param  {Function} cb\n\t   * @param  {}   context\n\t   */\n\t  traverse: function (cb, context) {\n\t    for (var i = 0; i < this._children.length; i++) {\n\t      var child = this._children[i];\n\t      cb.call(context, child);\n\t\n\t      if (child.type === 'group') {\n\t        child.traverse(cb, context);\n\t      }\n\t    }\n\t\n\t    return this;\n\t  },\n\t  addChildrenToStorage: function (storage) {\n\t    for (var i = 0; i < this._children.length; i++) {\n\t      var child = this._children[i];\n\t      storage.addToStorage(child);\n\t\n\t      if (child instanceof Group) {\n\t        child.addChildrenToStorage(storage);\n\t      }\n\t    }\n\t  },\n\t  delChildrenFromStorage: function (storage) {\n\t    for (var i = 0; i < this._children.length; i++) {\n\t      var child = this._children[i];\n\t      storage.delFromStorage(child);\n\t\n\t      if (child instanceof Group) {\n\t        child.delChildrenFromStorage(storage);\n\t      }\n\t    }\n\t  },\n\t  dirty: function () {\n\t    this.__dirty = true;\n\t    this.__zr && this.__zr.refresh();\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @return {module:zrender/core/BoundingRect}\n\t   */\n\t  getBoundingRect: function (includeChildren) {\n\t    // TODO Caching\n\t    var rect = null;\n\t    var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t    var children = includeChildren || this._children;\n\t    var tmpMat = [];\n\t\n\t    for (var i = 0; i < children.length; i++) {\n\t      var child = children[i];\n\t\n\t      if (child.ignore || child.invisible) {\n\t        continue;\n\t      }\n\t\n\t      var childRect = child.getBoundingRect();\n\t      var transform = child.getLocalTransform(tmpMat); // TODO\n\t      // The boundingRect cacluated by transforming original\n\t      // rect may be bigger than the actual bundingRect when rotation\n\t      // is used. (Consider a circle rotated aginst its center, where\n\t      // the actual boundingRect should be the same as that not be\n\t      // rotated.) But we can not find better approach to calculate\n\t      // actual boundingRect yet, considering performance.\n\t\n\t      if (transform) {\n\t        tmpRect.copy(childRect);\n\t        tmpRect.applyTransform(transform);\n\t        rect = rect || tmpRect.clone();\n\t        rect.union(tmpRect);\n\t      } else {\n\t        rect = rect || childRect.clone();\n\t        rect.union(childRect);\n\t      }\n\t    }\n\t\n\t    return rect || tmpRect;\n\t  }\n\t};\n\tzrUtil.inherits(Group, Element);\n\tvar _default = Group;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Displayable = __webpack_require__(8);\n\t\n\tvar BoundingRect = __webpack_require__(27);\n\t\n\tvar zrUtil = __webpack_require__(5);\n\t\n\tvar imageHelper = __webpack_require__(28);\n\t\n\t/**\n\t * @alias zrender/graphic/Image\n\t * @extends module:zrender/graphic/Displayable\n\t * @constructor\n\t * @param {Object} opts\n\t */\n\tfunction ZImage(opts) {\n\t  Displayable.call(this, opts);\n\t}\n\t\n\tZImage.prototype = {\n\t  constructor: ZImage,\n\t  type: 'image',\n\t  brush: function (ctx, prevEl) {\n\t    var style = this.style;\n\t    var src = style.image; // Must bind each time\n\t\n\t    style.bind(ctx, this, prevEl);\n\t    var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);\n\t\n\t    if (!image || !imageHelper.isImageReady(image)) {\n\t      return;\n\t    } // 图片已经加载完成\n\t    // if (image.nodeName.toUpperCase() == 'IMG') {\n\t    //     if (!image.complete) {\n\t    //         return;\n\t    //     }\n\t    // }\n\t    // Else is canvas\n\t\n\t\n\t    var x = style.x || 0;\n\t    var y = style.y || 0;\n\t    var width = style.width;\n\t    var height = style.height;\n\t    var aspect = image.width / image.height;\n\t\n\t    if (width == null && height != null) {\n\t      // Keep image/height ratio\n\t      width = height * aspect;\n\t    } else if (height == null && width != null) {\n\t      height = width / aspect;\n\t    } else if (width == null && height == null) {\n\t      width = image.width;\n\t      height = image.height;\n\t    } // 设置transform\n\t\n\t\n\t    this.setTransform(ctx);\n\t\n\t    if (style.sWidth && style.sHeight) {\n\t      var sx = style.sx || 0;\n\t      var sy = style.sy || 0;\n\t      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n\t    } else if (style.sx && style.sy) {\n\t      var sx = style.sx;\n\t      var sy = style.sy;\n\t      var sWidth = width - sx;\n\t      var sHeight = height - sy;\n\t      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n\t    } else {\n\t      ctx.drawImage(image, x, y, width, height);\n\t    }\n\t\n\t    this.restoreTransform(ctx); // Draw rect text\n\t\n\t    if (style.text != null) {\n\t      this.drawRectText(ctx, this.getBoundingRect());\n\t    }\n\t  },\n\t  getBoundingRect: function () {\n\t    var style = this.style;\n\t\n\t    if (!this._rect) {\n\t      this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);\n\t    }\n\t\n\t    return this._rect;\n\t  }\n\t};\n\tzrUtil.inherits(ZImage, Displayable);\n\tvar _default = ZImage;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Displayable = __webpack_require__(8);\n\t\n\tvar zrUtil = __webpack_require__(5);\n\t\n\tvar textContain = __webpack_require__(26);\n\t\n\tvar textHelper = __webpack_require__(25);\n\t\n\t/**\n\t * @alias zrender/graphic/Text\n\t * @extends module:zrender/graphic/Displayable\n\t * @constructor\n\t * @param {Object} opts\n\t */\n\tvar Text = function (opts) {\n\t  // jshint ignore:line\n\t  Displayable.call(this, opts);\n\t};\n\t\n\tText.prototype = {\n\t  constructor: Text,\n\t  type: 'text',\n\t  brush: function (ctx, prevEl) {\n\t    var style = this.style; // Optimize, avoid normalize every time.\n\t\n\t    this.__dirty && textHelper.normalizeTextStyle(style, true); // Use props with prefix 'text'.\n\t\n\t    style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;\n\t    var text = style.text; // Convert to string\n\t\n\t    text != null && (text += ''); // Always bind style\n\t\n\t    style.bind(ctx, this, prevEl);\n\t\n\t    if (!textHelper.needDrawText(text, style)) {\n\t      return;\n\t    }\n\t\n\t    this.setTransform(ctx);\n\t    textHelper.renderText(this, ctx, text, style);\n\t    this.restoreTransform(ctx);\n\t  },\n\t  getBoundingRect: function () {\n\t    var style = this.style; // Optimize, avoid normalize every time.\n\t\n\t    this.__dirty && textHelper.normalizeTextStyle(style, true);\n\t\n\t    if (!this._rect) {\n\t      var text = style.text;\n\t      text != null ? text += '' : text = '';\n\t      var rect = textContain.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.rich);\n\t      rect.x += style.x || 0;\n\t      rect.y += style.y || 0;\n\t\n\t      if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {\n\t        var w = style.textStrokeWidth;\n\t        rect.x -= w / 2;\n\t        rect.y -= w / 2;\n\t        rect.width += w;\n\t        rect.height += w;\n\t      }\n\t\n\t      this._rect = rect;\n\t    }\n\t\n\t    return this._rect;\n\t  }\n\t};\n\tzrUtil.inherits(Text, Displayable);\n\tvar _default = Text;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(7);\n\t\n\t/**\n\t * 圆形\n\t * @module zrender/shape/Circle\n\t */\n\tvar _default = Path.extend({\n\t  type: 'circle',\n\t  shape: {\n\t    cx: 0,\n\t    cy: 0,\n\t    r: 0\n\t  },\n\t  buildPath: function (ctx, shape, inBundle) {\n\t    // Better stroking in ShapeBundle\n\t    // Always do it may have performence issue ( fill may be 2x more cost)\n\t    if (inBundle) {\n\t      ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t    } // else {\n\t    //     if (ctx.allocate && !ctx.data.length) {\n\t    //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n\t    //     }\n\t    // }\n\t    // Better stroking in ShapeBundle\n\t    // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t\n\t\n\t    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(7);\n\t\n\tvar fixClipWithShadow = __webpack_require__(49);\n\t\n\t/**\n\t * 扇形\n\t * @module zrender/graphic/shape/Sector\n\t */\n\tvar _default = Path.extend({\n\t  type: 'sector',\n\t  shape: {\n\t    cx: 0,\n\t    cy: 0,\n\t    r0: 0,\n\t    r: 0,\n\t    startAngle: 0,\n\t    endAngle: Math.PI * 2,\n\t    clockwise: true\n\t  },\n\t  brush: fixClipWithShadow(Path.prototype.brush),\n\t  buildPath: function (ctx, shape) {\n\t    var x = shape.cx;\n\t    var y = shape.cy;\n\t    var r0 = Math.max(shape.r0 || 0, 0);\n\t    var r = Math.max(shape.r, 0);\n\t    var startAngle = shape.startAngle;\n\t    var endAngle = shape.endAngle;\n\t    var clockwise = shape.clockwise;\n\t    var unitX = Math.cos(startAngle);\n\t    var unitY = Math.sin(startAngle);\n\t    ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\t    ctx.lineTo(unitX * r + x, unitY * r + y);\n\t    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t    ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);\n\t\n\t    if (r0 !== 0) {\n\t      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n\t    }\n\t\n\t    ctx.closePath();\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar env = __webpack_require__(50);\n\t\n\t// Fix weird bug in some version of IE11 (like 11.0.9600.178**),\n\t// where exception \"unexpected call to method or property access\"\n\t// might be thrown when calling ctx.fill or ctx.stroke after a path\n\t// whose area size is zero is drawn and ctx.clip() is called and\n\t// shadowBlur is set. See #4572, #3112, #5777.\n\t// (e.g.,\n\t//  ctx.moveTo(10, 10);\n\t//  ctx.lineTo(20, 10);\n\t//  ctx.closePath();\n\t//  ctx.clip();\n\t//  ctx.shadowBlur = 10;\n\t//  ...\n\t//  ctx.fill();\n\t// )\n\tvar shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];\n\t\n\tfunction _default(orignalBrush) {\n\t  // version string can be: '11.0'\n\t  return env.browser.ie && env.browser.version >= 11 ? function () {\n\t    var clipPaths = this.__clipPaths;\n\t    var style = this.style;\n\t    var modified;\n\t\n\t    if (clipPaths) {\n\t      for (var i = 0; i < clipPaths.length; i++) {\n\t        var clipPath = clipPaths[i];\n\t        var shape = clipPath && clipPath.shape;\n\t        var type = clipPath && clipPath.type;\n\t\n\t        if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {\n\t          for (var j = 0; j < shadowTemp.length; j++) {\n\t            // It is save to put shadowTemp static, because shadowTemp\n\t            // will be all modified each item brush called.\n\t            shadowTemp[j][2] = style[shadowTemp[j][0]];\n\t            style[shadowTemp[j][0]] = shadowTemp[j][1];\n\t          }\n\t\n\t          modified = true;\n\t          break;\n\t        }\n\t      }\n\t    }\n\t\n\t    orignalBrush.apply(this, arguments);\n\t\n\t    if (modified) {\n\t      for (var j = 0; j < shadowTemp.length; j++) {\n\t        style[shadowTemp[j][0]] = shadowTemp[j][2];\n\t      }\n\t    }\n\t  } : orignalBrush;\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * echarts设备环境识别\n\t *\n\t * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\n\t * @author firede[firede@firede.us]\n\t * @desc thanks zepto.\n\t */\n\tvar env = {};\n\t\n\tif (typeof navigator === 'undefined') {\n\t  // In node\n\t  env = {\n\t    browser: {},\n\t    os: {},\n\t    node: true,\n\t    // Assume canvas is supported\n\t    canvasSupported: true,\n\t    svgSupported: true\n\t  };\n\t} else {\n\t  env = detect(navigator.userAgent);\n\t}\n\t\n\tvar _default = env; // Zepto.js\n\t// (c) 2010-2013 Thomas Fuchs\n\t// Zepto.js may be freely distributed under the MIT license.\n\t\n\tfunction detect(ua) {\n\t  var os = {};\n\t  var browser = {}; // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n\t  // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n\t  // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n\t  // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n\t  // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n\t  // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n\t  // var touchpad = webos && ua.match(/TouchPad/);\n\t  // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n\t  // var silk = ua.match(/Silk\\/([\\d._]+)/);\n\t  // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n\t  // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n\t  // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n\t  // var playbook = ua.match(/PlayBook/);\n\t  // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\t\n\t  var firefox = ua.match(/Firefox\\/([\\d.]+)/); // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n\t  // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\t\n\t  var ie = ua.match(/MSIE\\s([\\d.]+)/) // IE 11 Trident/7.0; rv:11.0\n\t  || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n\t  var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\t\n\t  var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:\n\t  // - discern (more) between multiple browsers on android\n\t  // - decide if kindle fire in silk mode is android or not\n\t  // - Firefox on Android doesn't specify the Android version\n\t  // - possibly devide in os, device and browser hashes\n\t  // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\t  // if (android) os.android = true, os.version = android[2];\n\t  // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n\t  // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n\t  // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n\t  // if (webos) os.webos = true, os.version = webos[2];\n\t  // if (touchpad) os.touchpad = true;\n\t  // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n\t  // if (bb10) os.bb10 = true, os.version = bb10[2];\n\t  // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n\t  // if (playbook) browser.playbook = true;\n\t  // if (kindle) os.kindle = true, os.version = kindle[1];\n\t  // if (silk) browser.silk = true, browser.version = silk[1];\n\t  // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n\t  // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\t\n\t  if (firefox) {\n\t    browser.firefox = true;\n\t    browser.version = firefox[1];\n\t  } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n\t  // if (webview) browser.webview = true;\n\t\n\t\n\t  if (ie) {\n\t    browser.ie = true;\n\t    browser.version = ie[1];\n\t  }\n\t\n\t  if (edge) {\n\t    browser.edge = true;\n\t    browser.version = edge[1];\n\t  } // It is difficult to detect WeChat in Win Phone precisely, because ua can\n\t  // not be set on win phone. So we do not consider Win Phone.\n\t\n\t\n\t  if (weChat) {\n\t    browser.weChat = true;\n\t  } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n\t  //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n\t  // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n\t  //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n\t  //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\t\n\t\n\t  return {\n\t    browser: browser,\n\t    os: os,\n\t    node: false,\n\t    // 原生canvas支持，改极端点了\n\t    // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n\t    canvasSupported: !!document.createElement('canvas').getContext,\n\t    svgSupported: typeof SVGRect !== 'undefined',\n\t    // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n\t    // works on most browsers\n\t    // IE10/11 does not support touch event, and MS Edge supports them but not by\n\t    // default, so we dont check navigator.maxTouchPoints for them here.\n\t    touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n\t    // <http://caniuse.com/#search=pointer%20event>.\n\t    pointerEventsSupported: 'onpointerdown' in window // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n\t    // events currently. So we dont use that on other browsers unless tested sufficiently.\n\t    // Although IE 10 supports pointer event, it use old style and is different from the\n\t    // standard. So we exclude that. (IE 10 is hardly used on touch device)\n\t    && (browser.edge || browser.ie && browser.version >= 11)\n\t  };\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(7);\n\t\n\t/**\n\t * 圆环\n\t * @module zrender/graphic/shape/Ring\n\t */\n\tvar _default = Path.extend({\n\t  type: 'ring',\n\t  shape: {\n\t    cx: 0,\n\t    cy: 0,\n\t    r: 0,\n\t    r0: 0\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    var x = shape.cx;\n\t    var y = shape.cy;\n\t    var PI2 = Math.PI * 2;\n\t    ctx.moveTo(x + shape.r, y);\n\t    ctx.arc(x, y, shape.r, 0, PI2, false);\n\t    ctx.moveTo(x + shape.r0, y);\n\t    ctx.arc(x, y, shape.r0, 0, PI2, true);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(7);\n\t\n\tvar polyHelper = __webpack_require__(53);\n\t\n\t/**\n\t * 多边形\n\t * @module zrender/shape/Polygon\n\t */\n\tvar _default = Path.extend({\n\t  type: 'polygon',\n\t  shape: {\n\t    points: null,\n\t    smooth: false,\n\t    smoothConstraint: null\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    polyHelper.buildPath(ctx, shape, true);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar smoothSpline = __webpack_require__(54);\n\t\n\tvar smoothBezier = __webpack_require__(55);\n\t\n\tfunction buildPath(ctx, shape, closePath) {\n\t  var points = shape.points;\n\t  var smooth = shape.smooth;\n\t\n\t  if (points && points.length >= 2) {\n\t    if (smooth && smooth !== 'spline') {\n\t      var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);\n\t      ctx.moveTo(points[0][0], points[0][1]);\n\t      var len = points.length;\n\t\n\t      for (var i = 0; i < (closePath ? len : len - 1); i++) {\n\t        var cp1 = controlPoints[i * 2];\n\t        var cp2 = controlPoints[i * 2 + 1];\n\t        var p = points[(i + 1) % len];\n\t        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);\n\t      }\n\t    } else {\n\t      if (smooth === 'spline') {\n\t        points = smoothSpline(points, closePath);\n\t      }\n\t\n\t      ctx.moveTo(points[0][0], points[0][1]);\n\t\n\t      for (var i = 1, l = points.length; i < l; i++) {\n\t        ctx.lineTo(points[i][0], points[i][1]);\n\t      }\n\t    }\n\t\n\t    closePath && ctx.closePath();\n\t  }\n\t}\n\t\n\texports.buildPath = buildPath;\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _vector = __webpack_require__(15);\n\t\n\tvar v2Distance = _vector.distance;\n\t\n\t/**\n\t * Catmull-Rom spline 插值折线\n\t * @module zrender/shape/util/smoothSpline\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t/**\n\t * @inner\n\t */\n\tfunction interpolate(p0, p1, p2, p3, t, t2, t3) {\n\t  var v0 = (p2 - p0) * 0.5;\n\t  var v1 = (p3 - p1) * 0.5;\n\t  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n\t}\n\t/**\n\t * @alias module:zrender/shape/util/smoothSpline\n\t * @param {Array} points 线段顶点数组\n\t * @param {boolean} isLoop\n\t * @return {Array}\n\t */\n\t\n\t\n\tfunction _default(points, isLoop) {\n\t  var len = points.length;\n\t  var ret = [];\n\t  var distance = 0;\n\t\n\t  for (var i = 1; i < len; i++) {\n\t    distance += v2Distance(points[i - 1], points[i]);\n\t  }\n\t\n\t  var segs = distance / 2;\n\t  segs = segs < len ? len : segs;\n\t\n\t  for (var i = 0; i < segs; i++) {\n\t    var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n\t    var idx = Math.floor(pos);\n\t    var w = pos - idx;\n\t    var p0;\n\t    var p1 = points[idx % len];\n\t    var p2;\n\t    var p3;\n\t\n\t    if (!isLoop) {\n\t      p0 = points[idx === 0 ? idx : idx - 1];\n\t      p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n\t      p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n\t    } else {\n\t      p0 = points[(idx - 1 + len) % len];\n\t      p2 = points[(idx + 1) % len];\n\t      p3 = points[(idx + 2) % len];\n\t    }\n\t\n\t    var w2 = w * w;\n\t    var w3 = w * w2;\n\t    ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);\n\t  }\n\t\n\t  return ret;\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _vector = __webpack_require__(15);\n\t\n\tvar v2Min = _vector.min;\n\tvar v2Max = _vector.max;\n\tvar v2Scale = _vector.scale;\n\tvar v2Distance = _vector.distance;\n\tvar v2Add = _vector.add;\n\tvar v2Clone = _vector.clone;\n\tvar v2Sub = _vector.sub;\n\t\n\t/**\n\t * 贝塞尔平滑曲线\n\t * @module zrender/shape/util/smoothBezier\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t/**\n\t * 贝塞尔平滑曲线\n\t * @alias module:zrender/shape/util/smoothBezier\n\t * @param {Array} points 线段顶点数组\n\t * @param {number} smooth 平滑等级, 0-1\n\t * @param {boolean} isLoop\n\t * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n\t *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n\t *                           整个折线的包围盒做一个并集用来约束控制点。\n\t * @param {Array} 计算出来的控制点数组\n\t */\n\tfunction _default(points, smooth, isLoop, constraint) {\n\t  var cps = [];\n\t  var v = [];\n\t  var v1 = [];\n\t  var v2 = [];\n\t  var prevPoint;\n\t  var nextPoint;\n\t  var min, max;\n\t\n\t  if (constraint) {\n\t    min = [Infinity, Infinity];\n\t    max = [-Infinity, -Infinity];\n\t\n\t    for (var i = 0, len = points.length; i < len; i++) {\n\t      v2Min(min, min, points[i]);\n\t      v2Max(max, max, points[i]);\n\t    } // 与指定的包围盒做并集\n\t\n\t\n\t    v2Min(min, min, constraint[0]);\n\t    v2Max(max, max, constraint[1]);\n\t  }\n\t\n\t  for (var i = 0, len = points.length; i < len; i++) {\n\t    var point = points[i];\n\t\n\t    if (isLoop) {\n\t      prevPoint = points[i ? i - 1 : len - 1];\n\t      nextPoint = points[(i + 1) % len];\n\t    } else {\n\t      if (i === 0 || i === len - 1) {\n\t        cps.push(v2Clone(points[i]));\n\t        continue;\n\t      } else {\n\t        prevPoint = points[i - 1];\n\t        nextPoint = points[i + 1];\n\t      }\n\t    }\n\t\n\t    v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length\n\t\n\t    v2Scale(v, v, smooth);\n\t    var d0 = v2Distance(point, prevPoint);\n\t    var d1 = v2Distance(point, nextPoint);\n\t    var sum = d0 + d1;\n\t\n\t    if (sum !== 0) {\n\t      d0 /= sum;\n\t      d1 /= sum;\n\t    }\n\t\n\t    v2Scale(v1, v, -d0);\n\t    v2Scale(v2, v, d1);\n\t    var cp0 = v2Add([], point, v1);\n\t    var cp1 = v2Add([], point, v2);\n\t\n\t    if (constraint) {\n\t      v2Max(cp0, cp0, min);\n\t      v2Min(cp0, cp0, max);\n\t      v2Max(cp1, cp1, min);\n\t      v2Min(cp1, cp1, max);\n\t    }\n\t\n\t    cps.push(cp0);\n\t    cps.push(cp1);\n\t  }\n\t\n\t  if (isLoop) {\n\t    cps.push(cps.shift());\n\t  }\n\t\n\t  return cps;\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(7);\n\t\n\tvar polyHelper = __webpack_require__(53);\n\t\n\t/**\n\t * @module zrender/graphic/shape/Polyline\n\t */\n\tvar _default = Path.extend({\n\t  type: 'polyline',\n\t  shape: {\n\t    points: null,\n\t    smooth: false,\n\t    smoothConstraint: null\n\t  },\n\t  style: {\n\t    stroke: '#000',\n\t    fill: null\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    polyHelper.buildPath(ctx, shape, false);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(7);\n\t\n\tvar roundRectHelper = __webpack_require__(29);\n\t\n\t/**\n\t * 矩形\n\t * @module zrender/graphic/shape/Rect\n\t */\n\tvar _default = Path.extend({\n\t  type: 'rect',\n\t  shape: {\n\t    // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n\t    // r缩写为1         相当于 [1, 1, 1, 1]\n\t    // r缩写为[1]       相当于 [1, 1, 1, 1]\n\t    // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n\t    // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n\t    r: 0,\n\t    x: 0,\n\t    y: 0,\n\t    width: 0,\n\t    height: 0\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    var x = shape.x;\n\t    var y = shape.y;\n\t    var width = shape.width;\n\t    var height = shape.height;\n\t\n\t    if (!shape.r) {\n\t      ctx.rect(x, y, width, height);\n\t    } else {\n\t      roundRectHelper.buildPath(ctx, shape);\n\t    }\n\t\n\t    ctx.closePath();\n\t    return;\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(7);\n\t\n\t/**\n\t * 直线\n\t * @module zrender/graphic/shape/Line\n\t */\n\tvar _default = Path.extend({\n\t  type: 'line',\n\t  shape: {\n\t    // Start point\n\t    x1: 0,\n\t    y1: 0,\n\t    // End point\n\t    x2: 0,\n\t    y2: 0,\n\t    percent: 1\n\t  },\n\t  style: {\n\t    stroke: '#000',\n\t    fill: null\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    var x1 = shape.x1;\n\t    var y1 = shape.y1;\n\t    var x2 = shape.x2;\n\t    var y2 = shape.y2;\n\t    var percent = shape.percent;\n\t\n\t    if (percent === 0) {\n\t      return;\n\t    }\n\t\n\t    ctx.moveTo(x1, y1);\n\t\n\t    if (percent < 1) {\n\t      x2 = x1 * (1 - percent) + x2 * percent;\n\t      y2 = y1 * (1 - percent) + y2 * percent;\n\t    }\n\t\n\t    ctx.lineTo(x2, y2);\n\t  },\n\t\n\t  /**\n\t   * Get point at percent\n\t   * @param  {number} percent\n\t   * @return {Array.<number>}\n\t   */\n\t  pointAt: function (p) {\n\t    var shape = this.shape;\n\t    return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(7);\n\t\n\tvar vec2 = __webpack_require__(15);\n\t\n\tvar _curve = __webpack_require__(31);\n\t\n\tvar quadraticSubdivide = _curve.quadraticSubdivide;\n\tvar cubicSubdivide = _curve.cubicSubdivide;\n\tvar quadraticAt = _curve.quadraticAt;\n\tvar cubicAt = _curve.cubicAt;\n\tvar quadraticDerivativeAt = _curve.quadraticDerivativeAt;\n\tvar cubicDerivativeAt = _curve.cubicDerivativeAt;\n\t\n\t/**\n\t * 贝塞尔曲线\n\t * @module zrender/shape/BezierCurve\n\t */\n\tvar out = [];\n\t\n\tfunction someVectorAt(shape, t, isTangent) {\n\t  var cpx2 = shape.cpx2;\n\t  var cpy2 = shape.cpy2;\n\t\n\t  if (cpx2 === null || cpy2 === null) {\n\t    return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];\n\t  } else {\n\t    return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];\n\t  }\n\t}\n\t\n\tvar _default = Path.extend({\n\t  type: 'bezier-curve',\n\t  shape: {\n\t    x1: 0,\n\t    y1: 0,\n\t    x2: 0,\n\t    y2: 0,\n\t    cpx1: 0,\n\t    cpy1: 0,\n\t    // cpx2: 0,\n\t    // cpy2: 0\n\t    // Curve show percent, for animating\n\t    percent: 1\n\t  },\n\t  style: {\n\t    stroke: '#000',\n\t    fill: null\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    var x1 = shape.x1;\n\t    var y1 = shape.y1;\n\t    var x2 = shape.x2;\n\t    var y2 = shape.y2;\n\t    var cpx1 = shape.cpx1;\n\t    var cpy1 = shape.cpy1;\n\t    var cpx2 = shape.cpx2;\n\t    var cpy2 = shape.cpy2;\n\t    var percent = shape.percent;\n\t\n\t    if (percent === 0) {\n\t      return;\n\t    }\n\t\n\t    ctx.moveTo(x1, y1);\n\t\n\t    if (cpx2 == null || cpy2 == null) {\n\t      if (percent < 1) {\n\t        quadraticSubdivide(x1, cpx1, x2, percent, out);\n\t        cpx1 = out[1];\n\t        x2 = out[2];\n\t        quadraticSubdivide(y1, cpy1, y2, percent, out);\n\t        cpy1 = out[1];\n\t        y2 = out[2];\n\t      }\n\t\n\t      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n\t    } else {\n\t      if (percent < 1) {\n\t        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n\t        cpx1 = out[1];\n\t        cpx2 = out[2];\n\t        x2 = out[3];\n\t        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n\t        cpy1 = out[1];\n\t        cpy2 = out[2];\n\t        y2 = out[3];\n\t      }\n\t\n\t      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Get point at percent\n\t   * @param  {number} t\n\t   * @return {Array.<number>}\n\t   */\n\t  pointAt: function (t) {\n\t    return someVectorAt(this.shape, t, false);\n\t  },\n\t\n\t  /**\n\t   * Get tangent at percent\n\t   * @param  {number} t\n\t   * @return {Array.<number>}\n\t   */\n\t  tangentAt: function (t) {\n\t    var p = someVectorAt(this.shape, t, true);\n\t    return vec2.normalize(p, p);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(7);\n\t\n\t/**\n\t * 圆弧\n\t * @module zrender/graphic/shape/Arc\n\t */\n\tvar _default = Path.extend({\n\t  type: 'arc',\n\t  shape: {\n\t    cx: 0,\n\t    cy: 0,\n\t    r: 0,\n\t    startAngle: 0,\n\t    endAngle: Math.PI * 2,\n\t    clockwise: true\n\t  },\n\t  style: {\n\t    stroke: '#000',\n\t    fill: null\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    var x = shape.cx;\n\t    var y = shape.cy;\n\t    var r = Math.max(shape.r, 0);\n\t    var startAngle = shape.startAngle;\n\t    var endAngle = shape.endAngle;\n\t    var clockwise = shape.clockwise;\n\t    var unitX = Math.cos(startAngle);\n\t    var unitY = Math.sin(startAngle);\n\t    ctx.moveTo(unitX * r + x, unitY * r + y);\n\t    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrUtil = __webpack_require__(5);\n\t\n\tvar Gradient = __webpack_require__(42);\n\t\n\t/**\n\t * x, y, x2, y2 are all percent from 0 to 1\n\t * @param {number} [x=0]\n\t * @param {number} [y=0]\n\t * @param {number} [x2=1]\n\t * @param {number} [y2=0]\n\t * @param {Array.<Object>} colorStops\n\t * @param {boolean} [globalCoord=false]\n\t */\n\tvar LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n\t  // Should do nothing more in this constructor. Because gradient can be\n\t  // declard by `color: {type: 'linear', colorStops: ...}`, where\n\t  // this constructor will not be called.\n\t  this.x = x == null ? 0 : x;\n\t  this.y = y == null ? 0 : y;\n\t  this.x2 = x2 == null ? 1 : x2;\n\t  this.y2 = y2 == null ? 0 : y2; // Can be cloned\n\t\n\t  this.type = 'linear'; // If use global coord\n\t\n\t  this.global = globalCoord || false;\n\t  Gradient.call(this, colorStops);\n\t};\n\t\n\tLinearGradient.prototype = {\n\t  constructor: LinearGradient\n\t};\n\tzrUtil.inherits(LinearGradient, Gradient);\n\tvar _default = LinearGradient;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrUtil = __webpack_require__(5);\n\t\n\tvar Gradient = __webpack_require__(42);\n\t\n\t/**\n\t * x, y, r are all percent from 0 to 1\n\t * @param {number} [x=0.5]\n\t * @param {number} [y=0.5]\n\t * @param {number} [r=0.5]\n\t * @param {Array.<Object>} [colorStops]\n\t * @param {boolean} [globalCoord=false]\n\t */\n\tvar RadialGradient = function (x, y, r, colorStops, globalCoord) {\n\t  // Should do nothing more in this constructor. Because gradient can be\n\t  // declard by `color: {type: 'radial', colorStops: ...}`, where\n\t  // this constructor will not be called.\n\t  this.x = x == null ? 0.5 : x;\n\t  this.y = y == null ? 0.5 : y;\n\t  this.r = r == null ? 0.5 : r; // Can be cloned\n\t\n\t  this.type = 'radial'; // If use global coord\n\t\n\t  this.global = globalCoord || false;\n\t  Gradient.call(this, colorStops);\n\t};\n\t\n\tRadialGradient.prototype = {\n\t  constructor: RadialGradient\n\t};\n\tzrUtil.inherits(RadialGradient, Gradient);\n\tvar _default = RadialGradient;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrUtil = __webpack_require__(5);\n\t\n\tvar Style = __webpack_require__(9);\n\t\n\tvar _vector = __webpack_require__(15);\n\t\n\tvar vec2Copy = _vector.copy;\n\t\n\t/**\n\t * States machine for managing graphic states\n\t */\n\t\n\t/**\n\t * @typedef {Object} IGraphicState\n\t * @property {number} [zlevel]\n\t * @property {number} [z]\n\t * @property {Array.<number>} {position}\n\t * @property {Array.<number>|number} {rotation}\n\t * @property {Array.<number>} {scale}\n\t * @property {Object} style\n\t *\n\t * @property {Function} onenter\n\t * @property {Function} onleave\n\t * @property {Function} ontransition\n\t * @property {Array.<IGraphicStateTransition|string>} transition\n\t *           Transition object or a string descriptor like '* 30 0 Linear'\n\t */\n\tvar transitionProperties = ['position', 'rotation', 'scale', 'style', 'shape'];\n\t/**\n\t * @module zrender/graphic/States~TransitionObject\n\t */\n\t\n\tvar TransitionObject = function (opts) {\n\t  if (typeof opts == 'string') {\n\t    this._fromStr(opts);\n\t  } else if (opts) {\n\t    opts.property && (this.property = opts.property);\n\t    opts.duration != null && (this.duration = opts.duration);\n\t    opts.easing && (this.easing = opts.easing);\n\t    opts.delay && (this.delay = opts.delay);\n\t  }\n\t\n\t  if (this.property !== '*') {\n\t    this.property = this.property.split(',');\n\t  } else {\n\t    this.property = transitionProperties;\n\t  }\n\t};\n\t\n\tTransitionObject.prototype = {\n\t  constructor: TransitionObject,\n\t\n\t  /**\n\t   * List of all transition properties. Splitted by comma. Must not have spaces in the string.\n\t   * e.g. 'position,style.color'. '*' will match all the valid properties.\n\t   * @type {string}\n\t   * @default *\n\t   */\n\t  property: '*',\n\t\n\t  /**\n\t   * @type {string}\n\t   * @default 'Linear'\n\t   */\n\t  easing: 'Linear',\n\t\n\t  /**\n\t   * @type {number}\n\t   * @default 'number'\n\t   */\n\t  duration: 500,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  delay: 0,\n\t  _fromStr: function (str) {\n\t    var arr = str.split(/\\s+/g);\n\t    this.property = arr[0];\n\t    this.duration = +arr[1];\n\t    this.delay = +arr[2];\n\t    this.easing = arr[3];\n\t  }\n\t};\n\t/**\n\t * @alias module:zrender/graphic/States\n\t */\n\t\n\tvar GraphicStates = function (opts) {\n\t  opts = opts || {};\n\t  this._states = {};\n\t  /**\n\t   * Target element\n\t   * @type {zrender/graphic/Displayable|zrender/container/Group}\n\t   */\n\t\n\t  this._el = opts.el;\n\t  this._subStates = [];\n\t  this._transitionAnimators = [];\n\t\n\t  if (opts.initialState) {\n\t    this._initialState = opts.initialState;\n\t  }\n\t\n\t  var optsStates = opts.states;\n\t\n\t  if (optsStates) {\n\t    for (var name in optsStates) {\n\t      if (optsStates.hasOwnProperty(name)) {\n\t        var state = optsStates[name];\n\t\n\t        this._addState(name, state);\n\t      }\n\t    }\n\t  }\n\t\n\t  this.setState(this._initialState);\n\t};\n\t\n\tGraphicStates.prototype = {\n\t  constructor: GraphicStates,\n\t\n\t  /**\n\t   * All other state will be extended from initial state\n\t   * @type {string}\n\t   * @private\n\t   */\n\t  _initialState: 'normal',\n\t\n\t  /**\n\t   * Current state\n\t   * @type {string}\n\t   * @private\n\t   */\n\t  _currentState: '',\n\t  el: function () {\n\t    return this._el;\n\t  },\n\t  _addState: function (name, state) {\n\t    this._states[name] = state;\n\t\n\t    if (state.transition) {\n\t      state.transition = new TransitionObject(state.transition);\n\t    } // Extend from initial state\n\t\n\t\n\t    if (name !== this._initialState) {\n\t      this._extendFromInitial(state);\n\t    } else {\n\t      var el = this._el; // setState 的时候自带的 style 和 shape 都会被直接覆盖\n\t      // 所以这边先把自带的 style 和 shape 扩展到初始状态中\n\t\n\t      zrUtil.merge(state.style, el.style, false, false);\n\t\n\t      if (state.shape) {\n\t        zrUtil.merge(state.shape, el.shape, false, true);\n\t      } else {\n\t        state.shape = zrUtil.clone(el.shape, true);\n\t      }\n\t\n\t      for (var name in this._states) {\n\t        if (this._states.hasOwnProperty(name)) {\n\t          this._extendFromInitial(this._states[name]);\n\t        }\n\t      }\n\t    }\n\t  },\n\t  _extendFromInitial: function (state) {\n\t    var initialState = this._states[this._initialState];\n\t\n\t    if (initialState && state !== initialState) {\n\t      zrUtil.merge(state, initialState, false, true);\n\t    }\n\t  },\n\t  setState: function (name, silent) {\n\t    if (name === this._currentState && !this.transiting()) {\n\t      return;\n\t    }\n\t\n\t    var state = this._states[name];\n\t\n\t    if (state) {\n\t      this._stopTransition();\n\t\n\t      if (!silent) {\n\t        var prevState = this._states[this._currentState];\n\t\n\t        if (prevState) {\n\t          prevState.onleave && prevState.onleave.call(this);\n\t        }\n\t\n\t        state.onenter && state.onenter.call(this);\n\t      }\n\t\n\t      this._currentState = name;\n\t\n\t      if (this._el) {\n\t        var el = this._el; // Setting attributes\n\t\n\t        if (state.zlevel != null) {\n\t          el.zlevel = state.zlevel;\n\t        }\n\t\n\t        if (state.z != null) {\n\t          el.z = state.z;\n\t        } // SRT\n\t\n\t\n\t        state.position && vec2Copy(el.position, state.position);\n\t        state.scale && vec2Copy(el.scale, state.scale);\n\t\n\t        if (state.rotation != null) {\n\t          el.rotation = state.rotation;\n\t        } // Style\n\t\n\t\n\t        if (state.style) {\n\t          var initialState = this._states[this._initialState];\n\t          el.style = new Style();\n\t\n\t          if (initialState) {\n\t            el.style.extendFrom(initialState.style, false);\n\t          }\n\t\n\t          if ( // Not initial state\n\t          name != this._initialState // Not copied from initial state in _extendFromInitial method\n\t          && initialState.style !== state.style) {\n\t            el.style.extendFrom(state.style, true);\n\t          }\n\t        }\n\t\n\t        if (state.shape) {\n\t          el.shape = zrUtil.clone(state.shape, true);\n\t        }\n\t\n\t        el.dirty();\n\t      }\n\t    }\n\t\n\t    for (var i = 0; i < this._subStates.length; i++) {\n\t      this._subStates.setState(name);\n\t    }\n\t  },\n\t  getState: function () {\n\t    return this._currentState;\n\t  },\n\t  transitionState: function (target, done) {\n\t    if (target === this._currentState && !this.transiting()) {\n\t      return;\n\t    }\n\t\n\t    var state = this._states[target];\n\t    var styleShapeReg = /$[style|shape]\\./;\n\t    var self = this; // Animation 去重\n\t\n\t    var propPathMap = {};\n\t\n\t    if (state) {\n\t      self._stopTransition();\n\t\n\t      var el = self._el;\n\t\n\t      if (state.transition && el && el.__zr) {\n\t        // El can be animated\n\t        var transitionCfg = state.transition;\n\t        var property = transitionCfg.property;\n\t        var animatingCount = 0;\n\t\n\t        var animationDone = function () {\n\t          animatingCount--;\n\t\n\t          if (animatingCount === 0) {\n\t            self.setState(target);\n\t            done && done();\n\t          }\n\t        };\n\t\n\t        for (var i = 0; i < property.length; i++) {\n\t          var propName = property[i]; // Animating all the properties in style or shape\n\t\n\t          if (propName === 'style' || propName === 'shape') {\n\t            if (state[propName]) {\n\t              for (var key in state[propName]) {\n\t                if (!state[propName].hasOwnProperty(key)) {\n\t                  continue;\n\t                }\n\t\n\t                var path = propName + '.' + key;\n\t\n\t                if (propPathMap[path]) {\n\t                  continue;\n\t                }\n\t\n\t                propPathMap[path] = 1;\n\t                animatingCount += self._animProp(state, propName, key, transitionCfg, animationDone);\n\t              }\n\t            }\n\t          } else {\n\t            if (propPathMap[propName]) {\n\t              continue;\n\t            }\n\t\n\t            propPathMap[propName] = 1; // Animating particular property in style or style\n\t\n\t            if (propName.match(styleShapeReg)) {\n\t              // remove 'style.', 'shape.' prefix\n\t              var subProp = propName.slice(0, 5);\n\t              propName = propName.slice(6);\n\t              animatingCount += self._animProp(state, subProp, propName, transitionCfg, animationDone);\n\t            } else {\n\t              animatingCount += self._animProp(state, '', propName, transitionCfg, animationDone);\n\t            }\n\t          }\n\t        } // No transition properties\n\t\n\t\n\t        if (animatingCount === 0) {\n\t          self.setState(target);\n\t          done && done();\n\t        }\n\t      } else {\n\t        self.setState(target);\n\t        done && done();\n\t      }\n\t    }\n\t\n\t    var subStates = self._subStates;\n\t\n\t    for (var i = 0; i < subStates.length; i++) {\n\t      subStates.transitionState(target);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Do transition animation of particular property\n\t   * @param {Object} state\n\t   * @param {string} subPropKey\n\t   * @param {string} key\n\t   * @param {Object} transitionCfg\n\t   * @param {Function} done\n\t   * @private\n\t   */\n\t  _animProp: function (state, subPropKey, key, transitionCfg, done) {\n\t    var el = this._el;\n\t    var stateObj = subPropKey ? state[subPropKey] : state;\n\t    var elObj = subPropKey ? el[subPropKey] : el;\n\t    var availableProp = stateObj && key in stateObj && elObj && key in elObj;\n\t    var transitionAnimators = this._transitionAnimators;\n\t\n\t    if (availableProp) {\n\t      var obj = {};\n\t\n\t      if (stateObj[key] === elObj[key]) {\n\t        return 0;\n\t      }\n\t\n\t      obj[key] = stateObj[key];\n\t      var animator = el.animate(subPropKey).when(transitionCfg.duration, obj).delay(transitionCfg.dealy).done(function () {\n\t        var idx = zrUtil.indexOf(transitionAnimators, 1);\n\t\n\t        if (idx > 0) {\n\t          transitionAnimators.splice(idx, 1);\n\t        }\n\t\n\t        done();\n\t      }).start(transitionCfg.easing);\n\t      transitionAnimators.push(animator);\n\t      return 1;\n\t    }\n\t\n\t    return 0;\n\t  },\n\t  _stopTransition: function () {\n\t    var transitionAnimators = this._transitionAnimators;\n\t\n\t    for (var i = 0; i < transitionAnimators.length; i++) {\n\t      transitionAnimators[i].stop();\n\t    }\n\t\n\t    transitionAnimators.length = 0;\n\t  },\n\t  transiting: function () {\n\t    return this._transitionAnimators.length > 0;\n\t  },\n\t  addSubStates: function (states) {\n\t    this._subStates.push(states);\n\t  },\n\t  removeSubStates: function (states) {\n\t    var idx = zrUtil.indexOf(this._subStates, states);\n\t\n\t    if (idx >= 0) {\n\t      this._subStates.splice(states, 1);\n\t    }\n\t  }\n\t};\n\tvar _default = GraphicStates;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var BoundingRect = __webpack_require__(27);\r\n\t    function Minimap(bigCanvas,groupPosition, group,eagleEyeNode,distance,imgSrc) {\r\n\t\r\n\t        this.bigCanvas = bigCanvas;\r\n\t        this.eagleEyeNode = eagleEyeNode;\r\n\t        this.distance = distance;\r\n\t        this.imgSrc = imgSrc;\r\n\t        this.ratio;\r\n\t        this.groupRatio;\r\n\t        this.group = group;\r\n\t        this.img = document.createElement(\"img\");\r\n\t        this.selection = document.createElement('div');\r\n\t        this.groupPosition = zrUtil.clone(groupPosition);\r\n\t        this.selectPosition = [0,0];\r\n\t        this.render();\r\n\t    }\r\n\t\r\n\t    Minimap.prototype.render = function() {\r\n\t        var that = this;\r\n\t        that.ratio = 0.12;\r\n\t        var eagleEyeNodeWidth = that.group.width  * that.ratio;\r\n\t        var eagleEyeNodeHeight = that.group.height  * that.ratio;\r\n\t        that.eagleEyeNode.style.width = eagleEyeNodeWidth+\"px\";\r\n\t        that.eagleEyeNode.style.height = eagleEyeNodeHeight+\"px\";\r\n\t        that.eagleEyeNode.style.marginTop = -eagleEyeNodeHeight+\"px\";\r\n\t        that.eagleEyeNode.style.marginLeft = that.bigCanvas.getWidth()-eagleEyeNodeWidth+\"px\";\r\n\t        that.eagleEyeNode.style.position=\"relative\";\r\n\t        that.eagleEyeNode.style.background = \"url(\"+that.imgSrc+\") no-repeat\";\r\n\t        that.eagleEyeNode.style.backgroundSize = eagleEyeNodeWidth/(that.group.width*that.distance[2]/that.bigCanvas.getWidth())+\"px\";\r\n\t        that.backgroundSize = zrUtil.clone(that.eagleEyeNode.style.backgroundSize);\r\n\t        that.eagleEyeNode.innerHTML = \"\";\r\n\t        that.selection.style.border = \"1px solid #ff0000\";\r\n\t        that.selection.style.cursor = \"pointer\";\r\n\t        that.selection.style.width = that.bigCanvas.getWidth()/that.group.width*eagleEyeNodeWidth+\"px\";\r\n\t        that.selection.style.height = that.bigCanvas.getHeight()/that.group.height*eagleEyeNodeHeight+\"px\";\r\n\t        that.selectWidth = that.selection.style.width;\r\n\t        that.selectHeight = that.selection.style.height;\r\n\t        that.selection.style.position=\"absolute\";\r\n\t        that.selection.style.top = 0+\"px\";\r\n\t        that.selection.style.left = 0+\"px\";\r\n\t        that.eagleEyeNode.appendChild(this.selection);\r\n\t    };\r\n\t    Minimap.prototype.updataSelection = function(offectLeft,offectTop,zoomScale,nowZoom){\r\n\t        var that = this;\r\n\t        that.zoomScale = zoomScale;\r\n\t        this.selection.style.width = this.selection.style.width.replace(\"px\",\"\")/zoomScale+\"px\";\r\n\t        this.selection.style.height = this.selection.style.height.replace(\"px\",\"\")/zoomScale+\"px\";\r\n\t        that.selectPosition[0] = zrUtil.clone(offectLeft)*that.ratio/nowZoom;\r\n\t        that.selectPosition[1] = zrUtil.clone(offectTop)*that.ratio/nowZoom;\r\n\t        this.selection.style.left = -that.selectPosition[0]+\"px\";\r\n\t        this.selection.style.top = -that.selectPosition[1]+\"px\";\r\n\t    };\r\n\t    Minimap.prototype.updataMap = function(imgSrc,newGroup){\r\n\t        var that = this;\r\n\t        that.eagleEyeNode.style.backgroundImage = \"url(\"+imgSrc+\")\";\r\n\t        var eagleEyeNodeWidth = newGroup.width  * that.ratio;\r\n\t        var eagleEyeNodeHeight = newGroup.height  * that.ratio;\r\n\t        that.eagleEyeNode.style.width = eagleEyeNodeWidth+\"px\";\r\n\t        that.eagleEyeNode.style.height = eagleEyeNodeHeight+\"px\";\r\n\t        that.eagleEyeNode.style.marginTop = -eagleEyeNodeHeight+\"px\";\r\n\t        that.eagleEyeNode.style.marginLeft = that.bigCanvas.getWidth()-eagleEyeNodeWidth+\"px\";\r\n\t    };\r\n\t    Minimap.prototype.updataSelectionPosition = function(nowGroupPosition,nowZoom){\r\n\t        var that = this;\r\n\t        that.selectPosition[0] = zrUtil.clone(nowGroupPosition[0])*that.ratio/nowZoom;\r\n\t        that.selectPosition[1] = zrUtil.clone(nowGroupPosition[1])*that.ratio/nowZoom;\r\n\t        this.selection.style.left = -that.selectPosition[0]+\"px\";\r\n\t        this.selection.style.top = -that.selectPosition[1]+\"px\";\r\n\t    };\r\n\t    Minimap.prototype.updataGroupPosition = function(group,nowZoom){\r\n\t        var that = this;\r\n\t        var positionX = -Number(that.selection.style.left.substring(0,that.selection.style.left.length-2))/that.ratio*nowZoom;\r\n\t        var positionY = -Number(that.selection.style.top.substring(0,that.selection.style.top.length-2))/that.ratio*nowZoom;\r\n\t        group.attr(\"position\",[positionX,positionY]);\r\n\t    };\r\n\t\r\n\t    module.exports = Minimap;\r\n\t\r\n\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 工具方法类\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var Point = __webpack_require__(66);\r\n\t    var Line = __webpack_require__(67);\r\n\t    var BoundingRect = __webpack_require__(27);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    /**\r\n\t     * 构造类继承关系\r\n\t     *\r\n\t     * @param {Function} clazz 源类\r\n\t     * @param {Function} baseClazz 基类\r\n\t     */\r\n\t    function inherits(clazz, baseClazz) {\r\n\t        var clazzPrototype = clazz.prototype;\r\n\t\r\n\t        function F() {}\r\n\t        F.prototype = baseClazz.prototype;\r\n\t        clazz.prototype = new F();\r\n\t\r\n\t        for (var prop in clazzPrototype) {\r\n\t            clazz.prototype[prop] = clazzPrototype[prop];\r\n\t        }\r\n\t        clazz.prototype.constructor = clazz;\r\n\t        clazz.superClass = baseClazz;\r\n\t    }\r\n\t\r\n\t    function getUUID() {\r\n\t        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),\r\n\t            uuid = new Array(36),\r\n\t            rnd = 0,\r\n\t            r;\r\n\t        for (var i = 0; i < 36; i++) {\r\n\t            if (i == 8 || i == 13 || i == 18 || i == 23) {\r\n\t                uuid[i] = '-';\r\n\t            } else if (i == 14) {\r\n\t                uuid[i] = '4';\r\n\t            } else {\r\n\t                if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;\r\n\t                r = rnd & 0xf;\r\n\t                rnd = rnd >> 4;\r\n\t                uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\r\n\t            }\r\n\t        }\r\n\t        return \"sid-\" + uuid.join('');\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 计算两点之间的距离\r\n\t     *@param {Point} p1 - first {Point}\r\n\t     *@param {Point} p2 - second {Point}\r\n\t     *@return {Number} - the distance between those 2 points. It is always positive.\r\n\t     **/\r\n\t    function distance(p1, p2) {\r\n\t        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 返回一条折线 最长的两个点\r\n\t     * @param  {[type]} points [description]\r\n\t     * @return {[type]}        [description]\r\n\t     */\r\n\t    function getMaxLineLength(points) {\r\n\t        var m = distance(points[0], points[1]);\r\n\t        var result = [points[0], points[1]];\r\n\t        for (var i = 1; i < points.length - 1; i++) {\r\n\t\r\n\t            if (m < distance(points[i], points[i + 1])) {\r\n\t                m = distance(points[i], points[i + 1])\r\n\t                result = [points[i], points[i + 1]];\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return result;\r\n\t    }\r\n\t\r\n\t    /**Returns the length of a Polyline that would be created with a set of points\r\n\t     *@param {Array} v - an {Array} of {Points}\r\n\t     *@return {Number} - a positive number equal with total length*/\r\n\t    function getPolylineLength(v) {\r\n\t        var l = 0;\r\n\t        for (var i = 0; i < v.length - 1; i++) {\r\n\t            l += distance(v[i], v[i + 1]);\r\n\t        }\r\n\t\r\n\t        return l;\r\n\t    }\r\n\t\r\n\t\r\n\t    /**Returns the max of a vector\r\n\t     *@param {Array} v - vector of {Number}s\r\n\t     *@return {Number} - the maximum number from the vector or NaN if vector is empty\r\n\t     **/\r\n\t    function max(v) {\r\n\t        if (v.lenght == 0) {\r\n\t            return NaN;\r\n\t        } else {\r\n\t            var m = v[0];\r\n\t            for (var i = 0; i < v.length; i++) {\r\n\t                if (m < v[i]) {\r\n\t                    m = v[i];\r\n\t                }\r\n\t            }\r\n\t\r\n\t            return m;\r\n\t        }\r\n\t    }\r\n\t\r\n\t\r\n\t    /**Returns the min of a vector\r\n\t     *@param {Array} v - vector of {Number}s\r\n\t     *@return {Number} - the minimum number from the vector or NaN if vector is empty\r\n\t     *@author alex@scriptoid.com\r\n\t     **/\r\n\t    function min(v) {\r\n\t        if (v.lenght == 0) {\r\n\t            return NaN;\r\n\t        } else {\r\n\t            var m = v[0];\r\n\t            for (var i = 0; i < v.length; i++) {\r\n\t                if (m > v[i]) {\r\n\t                    m = v[i];\r\n\t                }\r\n\t            }\r\n\t\r\n\t            return m;\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 判断 点数组 是否正交直线路径\r\n\t     *Tests if a vector of points is an orthogonal path (moving in multiples of 90 degrees)\r\n\t     *@param {Array} v - an {Array} of {Point}s\r\n\t     *@return {Boolean} - true if path is valid, false otherwise\r\n\t     **/\r\n\t    function orthogonalPath(v) {\r\n\t        if (v.length <= 1) {\r\n\t            return true;\r\n\t        }\r\n\t\r\n\t        for (var i = 0; i < v.length - 1; i++) {\r\n\t            if (v[i].x != v[i + 1].x && v[i].y != v[i + 1].y) {\r\n\t                return false;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return true;\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     *Test to see if 2 {Line}s intersects. They are considered finite segments\r\n\t     *and not the infinite lines from geometry\r\n\t     *@param {Line} l1 - fist line/segment\r\n\t     *@param {Line} l2 - last line/segment\r\n\t     *@return {Boolean} true - if the lines intersect or false if not\r\n\t     **/\r\n\t    function lineIntersectsLine(l1, l2) {\r\n\t        // check for two vertical lines\r\n\t        if (l1.startPoint.x == l1.endPoint.x && l2.startPoint.x == l2.endPoint.x) {\r\n\t            return l1.startPoint.x == l2.startPoint.x ? // if 'infinite 'lines do coincide,\r\n\t                // then check segment bounds for overlapping\r\n\t                l1.contains(l2.startPoint.x, l2.startPoint.y) ||\r\n\t                l1.contains(l2.endPoint.x, l2.endPoint.y) :\r\n\t                // lines are paralel\r\n\t                false;\r\n\t        }\r\n\t        // if one line is vertical, and another line is not vertical\r\n\t        else if (l1.startPoint.x == l1.endPoint.x || l2.startPoint.x == l2.endPoint.x) {\r\n\t            // let assume l2 is vertical, otherwise exchange them\r\n\t            if (l1.startPoint.x == l1.endPoint.x) {\r\n\t                var l = l1;\r\n\t                l1 = l2;\r\n\t                l2 = l;\r\n\t            }\r\n\t            // finding intersection of 'infinite' lines\r\n\t            // equation of the first line is y = ax + b, second: x = c\r\n\t            var a = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);\r\n\t            var b = l1.startPoint.y - a * l1.startPoint.x;\r\n\t            var x0 = l2.startPoint.x;\r\n\t            var y0 = a * x0 + b;\r\n\t            return l1.contains(x0, y0) && l2.contains(x0, y0);\r\n\t        }\r\n\t\r\n\t        // check normal case - both lines are not vertical\r\n\t        else {\r\n\t            //line equation is : y = a*x + b, b = y - a * x\r\n\t            var a1 = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);\r\n\t            var b1 = l1.startPoint.y - a1 * l1.startPoint.x;\r\n\t\r\n\t            var a2 = (l2.endPoint.y - l2.startPoint.y) / (l2.endPoint.x - l2.startPoint.x);\r\n\t            var b2 = l2.startPoint.y - a2 * l2.startPoint.x;\r\n\t\r\n\t            if (a1 == a2) { //paralel lines\r\n\t                return b1 == b2 ?\r\n\t                    // for coincide lines, check for segment bounds overlapping\r\n\t                    l1.contains(l2.startPoint.x, l2.startPoint.y) || l1.contains(l2.endPoint.x, l2.endPoint.y) :\r\n\t                    // not coincide paralel lines have no chance to intersect\r\n\t                    false;\r\n\t            } else { //usual case - non paralel, the 'infinite' lines intersects...we only need to know if inside the segment\r\n\t\r\n\t                /*\r\n\t                 * if one of the lines are vertical, then x0 is equal to their x,\r\n\t                 * otherwise:\r\n\t                 * y1 = a1 * x + b1\r\n\t                 * y2 = a2 * x + b2\r\n\t                 * => x0 = (b2 - b1) / (a1 - a2)\r\n\t                 * => y0 = a1 * x0 + b1\r\n\t                 **/\r\n\t                x0 = (b2 - b1) / (a1 - a2);\r\n\t                y0 = a1 * x0 + b1;\r\n\t                return l1.contains(x0, y0) && l2.contains(x0, y0);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     *Tests if a a polyline defined by a set of points intersects a rectangle\r\n\t     *@param {Array} points - and {Array} of {Point}s\r\n\t     *@param {Array} bounds - the bounds of the rectangle defined by (x1, y1, x2, y2)\r\n\t     *@param {Boolean} closedPolyline - incase polyline is closed figure then true, else false\r\n\t     *\r\n\t     *@return true - if line intersects the rectangle, false - if not\r\n\t     **/\r\n\t    function polylineIntersectsRectangle(points, bounds, closedPolyline) {\r\n\t\r\n\t\r\n\t        //get the 4 lines/segments represented by the bounds\r\n\t        var lines = [];\r\n\t        lines.push(new Line(new Point(bounds[0], bounds[1]), new Point(bounds[2], bounds[1])));\r\n\t        lines.push(new Line(new Point(bounds[2], bounds[1]), new Point(bounds[2], bounds[3])));\r\n\t        lines.push(new Line(new Point(bounds[2], bounds[3]), new Point(bounds[0], bounds[3])));\r\n\t        lines.push(new Line(new Point(bounds[0], bounds[3]), new Point(bounds[0], bounds[1])));\r\n\t\r\n\t        for (var k = 0; k < points.length - 1; k++) {\r\n\t            //create a line out of each 2 consecutive points\r\n\t            var tempLine = new Line(points[k], points[k + 1]);\r\n\t\r\n\t            //see if that line intersect any of the line on bounds border\r\n\t            for (var i = 0; i < lines.length; i++) {\r\n\t                if (lineIntersectsLine(tempLine, lines[i])) {\r\n\t                    return true;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        //check the closed figure - that is last point connected to the first\r\n\t        if (closedPolyline) {\r\n\t            //create a line out of each 2 consecutive points\r\n\t            var tempLine1 = new Line(points[points.length - 1], points[0]);\r\n\t\r\n\t            //see if that line intersect any of the line on bounds border\r\n\t            for (var j = 0; j < lines.length; j++) {\r\n\t                if (lineIntersectsLine(tempLine1, lines[j])) {\r\n\t                    return true;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return false;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 计算路径的分数\r\n\t     * Score a ortogonal path made out of Points\r\n\t     *Iterates over a set of points (minimum 3)\r\n\t     *For each 3 points (i, i+1, i+2) :\r\n\t     *  - if the 3rd one is after the 2nd on the same line we add +1\r\n\t     *  - if the 3rd is up or down related to the 2nd we do not do anything +0\r\n\t     *  - if the 3rd goes back we imediatelly return -1\r\n\t     *@param {Array} v - an array of {Point}s\r\n\t     *@return {Number} - -1 if the path is wrong (goes back) or something >= 0 if is fine\r\n\t     *  The bigger the number the smooth the path is\r\n\t     **/\r\n\t    function scorePath(v) {\r\n\t        if (v.length <= 2) {\r\n\t            return -1;\r\n\t        }\r\n\t\r\n\t        var score = 0;\r\n\t        for (var i = 1; i < v.length - 1; i++) {\r\n\t            if (v[i - 1].x == v[i].x && v[i].x == v[i + 1].x) { //on the same vertical\r\n\t                if (signum(v[i + 1].y - v[i].y) == signum(v[i].y - v[i - 1].y)) { //same direction\r\n\t                    score++;\r\n\t                } else { //going back - no good\r\n\t                    return -1;\r\n\t                }\r\n\t            } else if (v[i - 1].y == v[i].y && v[i].y == v[i + 1].y) { //on the same horizontal\r\n\t                if (signum(v[i + 1].x - v[i].x) == signum(v[i].x - v[i - 1].x)) { //same direction\r\n\t                    score++;\r\n\t                } else { //going back - no good\r\n\t                    return -1;\r\n\t                }\r\n\t            } else { //not on same vertical nor horizontal\r\n\t                score--;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return score;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 返回数字符号（+ -)\r\n\t     * Returns the sign of a number\r\n\t     *@param {Number} x - the number\r\n\t     *@returns {Number}\r\n\t     *@see <a href=\"http://en.wikipedia.org/wiki/Sign_function\">http://en.wikipedia.org/wiki/Sign_function</a>\r\n\t     **/\r\n\t    function signum(x) {\r\n\t        if (x > 0)\r\n\t            return 1;\r\n\t        else if (x < 0)\r\n\t            return -1;\r\n\t        else\r\n\t            return 0;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 判断 点数组 是不是有效路径（没有回路）\r\n\t     *Tests if a vector of points is a valid path (not going back)\r\n\t     *There are a few problems here. If you have p1, p2, p3 and p4 and p2 = p3 you need to ignore that\r\n\t     *@param {Array} v - an {Array} of {Point}s\r\n\t     *@return {Boolean} - true if path is valid, false otherwise\r\n\t     **/\r\n\t    function forwardPath(v) {\r\n\t        if (v.length <= 2) {\r\n\t            return true;\r\n\t        }\r\n\t\r\n\t        for (var i = 0; i < v.length - 2; i++) {\r\n\t            if (v[i].x == v[i + 1].x && v[i + 1].x == v[i + 2].x) { //on the same vertical\r\n\t                if (signum(v[i + 1].y - v[i].y) != 0) { //test only we have a progressing path\r\n\t                    if (signum(v[i + 1].y - v[i].y) == -1 * signum(v[i + 2].y - v[i + 1].y)) { //going back (ignore zero)\r\n\t                        return false;\r\n\t                    }\r\n\t                }\r\n\t            } else if (v[i].y == v[i + 1].y && v[i + 1].y == v[i + 2].y) { //on the same horizontal\r\n\t                if (signum(v[i + 1].x - v[i].x) != 0) { //test only we have a progressing path\r\n\t                    if (signum(v[i + 1].x - v[i].x) == -1 * signum(v[i + 2].x - v[i + 1].x)) { //going back (ignore zero)\r\n\t                        return false;\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return true;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 将[x:0,y:0]转化为[0, 0]  给zrender使用\r\n\t     * @param  {[type]} points [description]\r\n\t     * @param  {[type]} isRevert [description]\r\n\t     * @return {[type]}        [description]\r\n\t     */\r\n\t    function traslatePoints(points, isRevert) {\r\n\t        var newPoints = [];\r\n\t        if (isRevert) {\r\n\t            for (var i = 0; i < points.length; i++) {\r\n\t                var point = points[i];\r\n\t                newPoints.push(new Point(point[0], point[1]));\r\n\t            }\r\n\t            return newPoints;\r\n\t        } else {\r\n\t            for (var j = 0; j < points.length; j++) {\r\n\t                var point1 = points[j];\r\n\t                newPoints.push([point1.x, point1.y]);\r\n\t            }\r\n\t            return newPoints;\r\n\t        }\r\n\t\r\n\t\r\n\t    }\r\n\t\r\n\t    function rotationMatrix(angle) {\r\n\t        var mReturn = [\r\n\t            [Math.cos(angle), -Math.sin(angle), 0],\r\n\t            [Math.sin(angle), Math.cos(angle), 0],\r\n\t            [0, 0, 1]\r\n\t        ];\r\n\t        return mReturn;\r\n\t    }\r\n\t\r\n\t    function translationMatrix(dx, dy) {\r\n\t        return [\r\n\t            [1, 0, dx],\r\n\t            [0, 1, dy],\r\n\t            [0, 0, 1]\r\n\t        ];\r\n\t    }\r\n\t\r\n\t    function scaleMatrix(sx, sy) {\r\n\t        if (sy == null) {\r\n\t            sy = sx;\r\n\t        }\r\n\t        return [\r\n\t            [sx, 0, 0],\r\n\t            [0, sy, 0],\r\n\t            [0, 0, 1]\r\n\t        ];\r\n\t    }\r\n\t\r\n\t    /** It will return the end point of a line on a given angle (clockwise).\r\n\t     * @param {Point} startPoint - the start of the line\r\n\t     * @param {Number} length - the length of the line\r\n\t     * @param {Number} angle - the angle of the line in radians\r\n\t     * @return {Point} - the endPoint of the line\r\n\t     */\r\n\t    function getEndPoint(startPoint, length, angle) {\r\n\t        var endPoint = startPoint.clone();\r\n\t        endPoint.transform(translationMatrix(-startPoint.x, -startPoint.y));\r\n\t        endPoint.y -= length;\r\n\t        endPoint.transform(rotationMatrix(angle));\r\n\t        endPoint.transform(translationMatrix(startPoint.x, startPoint.y));\r\n\t        return endPoint;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 获取获取两个图形的外面四个连接点\r\n\t     * @param  {[type]} rect [description]\r\n\t     * @param  {[type]} node [description]\r\n\t     * @return {[type]}      [description]\r\n\t     */\r\n\t    function getConnectorPoints(rect, node) {\r\n\t        node = node || {};\r\n\t        var boundingRect = zrUtil.clone(rect.boundingRect || rect);\r\n\t        var rotation = node.rotation;\r\n\t        var points = {\r\n\t            left: new Point(boundingRect.x, boundingRect.y + boundingRect.height / 2), //矩形 左中的位置\r\n\t            top: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y), //矩形 上中的位置\r\n\t            right: new Point(boundingRect.x + boundingRect.width, boundingRect.y + boundingRect.height / 2), //矩形 右中的位置\r\n\t            bottom: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y + boundingRect.height), //矩形 下中的位置\r\n\t            center: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y + boundingRect.height / 2) //中间位置\r\n\t\r\n\t        };\r\n\t        if (Object.keys(node).length > 0 && Math.abs(rotation) > 0) {\r\n\t            var rectNew = rect.boundingRect ? rect : getRect(node);\r\n\t            var center = { x: rectNew.x, y: rectNew.y }; // 中心点\r\n\t            Object.keys(points).forEach(function(key) {\r\n\t                var value = points[key];\r\n\t                var x0 = center.x - value.x;\r\n\t                var y0 = center.y - value.y;\r\n\t                var sin = Math.sin(-rotation);\r\n\t                var cos = Math.cos(-rotation);\r\n\t                var position_n_x = center.x - (x0 * cos - y0 * sin);\r\n\t                var position_n_y = center.y - (x0 * sin + y0 * cos);\r\n\t                points[key].x = position_n_x;\r\n\t                points[key].y = position_n_y;\r\n\t            });\r\n\t        }\r\n\t        return points;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 获取节点外面四个控制点和旋转点\r\n\t     * @param  {[type]} node [description]\r\n\t     * @return {[type]}      [description]\r\n\t     */\r\n\t    function getConnectorControls(rect, node) {\r\n\t        node = node || {};\r\n\t        var boundingRect = zrUtil.clone(rect.boundingRect);\r\n\t        var rotation = node.rotation;\r\n\t        var controls = {\r\n\t            tl: new Point(boundingRect.x, boundingRect.y), //矩形 左上角位置\r\n\t            tc: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y - 4), //矩形 上中位置\r\n\t            tr: new Point(boundingRect.x + boundingRect.width, boundingRect.y), //矩形 右上角位置\r\n\t            bl: new Point(boundingRect.x, boundingRect.y + boundingRect.height), //矩形 左下角\r\n\t            br: new Point(boundingRect.x + boundingRect.width, boundingRect.y + boundingRect.height), //矩形 右下角位置\r\n\t            mtr: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y - 20) // 旋转点位置\r\n\t        };\r\n\t        if (Object.keys(node).length > 0 && Math.abs(rotation) > 0) {\r\n\t            var rectNew = rect;\r\n\t            var center = { x: rectNew.x, y: rectNew.y }; // 中心点\r\n\t            Object.keys(controls).forEach(function(key) {\r\n\t                var value = controls[key];\r\n\t                var x0 = center.x - value.x;\r\n\t                var y0 = center.y - value.y;\r\n\t                var sin = Math.sin(-rotation);\r\n\t                var cos = Math.cos(-rotation);\r\n\t                var position_n_x = center.x - (x0 * cos - y0 * sin);\r\n\t                var position_n_y = center.y - (x0 * sin + y0 * cos);\r\n\t                controls[key].x = position_n_x;\r\n\t                controls[key].y = position_n_y;\r\n\t            });\r\n\t        }\r\n\t        return controls;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 根据中心点和旋转弧度，计算旋转后的点坐标\r\n\t     * @param  {[object|array]} points [原坐标]\r\n\t     * @param  {[object]}       center [中心点]\r\n\t     * @param  {[number]}       rotation [旋转弧度]\r\n\t     * @return {[type]}      [description]\r\n\t     */\r\n\t    function calculatePoints(points, center, rotation) {\r\n\t        var x = Array.isArray(points) ? points[0] : points.x;\r\n\t        var y = Array.isArray(points) ? points[1] : points.y;\r\n\t        var x0 = center.x - x;\r\n\t        var y0 = center.y - y;\r\n\t        var sin = Math.sin(-rotation);\r\n\t        var cos = Math.cos(-rotation);\r\n\t        var position_n_x = center.x - (x0 * cos - y0 * sin);\r\n\t        var position_n_y = center.y - (x0 * sin + y0 * cos);\r\n\t        if (Array.isArray(points)) {\r\n\t            return [position_n_x, position_n_y];\r\n\t        }\r\n\t        return {\r\n\t            x: position_n_x,\r\n\t            y: position_n_y\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 获取获取两个图形的外面四个连接点\r\n\t     * @param  {[type]} node [description]\r\n\t     * @return {[type]}      [description]\r\n\t     */\r\n\t    function getSoltPoints(node) {\r\n\t        return [\r\n\t            //top\r\n\t            [Math.round(node.getRect().width / 3 /10)*10, 0 ],\r\n\t            [Math.round(2*node.getRect().width / 3 /10)*10, 0 ],\r\n\t            //right\r\n\t            [node.getRect().width, Math.round(node.getRect().height / 3 /10)*10 ],\r\n\t            [node.getRect().width, Math.round(2*node.getRect().height / 3 /10)*10 ],\r\n\t            //bottom\r\n\t            [Math.round(node.getRect().width / 3 /10)*10, node.getRect().height ],\r\n\t            [Math.round(2*node.getRect().width / 3 /10)*10, node.getRect().height ],\r\n\t            //left\r\n\t            [0, Math.round(node.getRect().height / 3 /10)*10 ],\r\n\t            [0, Math.round(2*node.getRect().height / 3 /10)*10 ]\r\n\t\r\n\t        ]\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 计算 p1 p2两点所连接的直线的角度\r\n\t     * @param  {[type]} p1 [description]\r\n\t     * @param  {[type]} p2 [description]\r\n\t     * @return {[type]}    [description]\r\n\t     */\r\n\t    function tangentRotation(p1, p2) {\r\n\t        return -Math.PI / 2 - Math.atan2(\r\n\t            p2.y - p1.y, p2.x - p1.x\r\n\t        );\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 判断3点是否在一条直线上\r\n\t     * Tests if 3 points are coliniar with matrix determinants.\r\n\t     * If the determinat of matrix\r\n\t     * /         \\\r\n\t     * | x1 y1 1 |\r\n\t     * | x2 y2 1 |\r\n\t     * | x3 y3 1 |\r\n\t     * \\         /\r\n\t     * is zero it means that the points are colinear\r\n\t     *@param {Point} p1 - first point\r\n\t     *@param {Point} p2 - second point\r\n\t     *@param {Point} p3 - third point\r\n\t     * @param {Number} precission\r\n\t     *@return {Boolean} - true if coliniar and false if not\r\n\t     *@author Alex\r\n\t     *@see http://en.wikipedia.org/wiki/Determinant\r\n\t     *@see https://people.richland.edu/james/lecture/m116/matrices/applications.html\r\n\t     **/\r\n\t    function collinearity(p1, p2, p3, precission) {\r\n\t        var determinant = (p1.x * p2.y + p1.y * p3.x + p2.x * p3.y) - (p2.y * p3.x + p1.y * p2.x + p1.x * p3.y);\r\n\t\r\n\t        if (precission) {\r\n\t            return Math.abs(determinant) <= precission;\r\n\t        } else {\r\n\t            return determinant === 0;\r\n\t        }\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 四舍五入 保存decimals的小数\r\n\t     **/\r\n\t    function enhancedRound(number, decimals) {\r\n\t        return Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 获取两点之间的长度\r\n\t     **/\r\n\t    function getLength(startPoint, endPoint) {\r\n\t        return Math.sqrt(Math.pow(startPoint.x - endPoint.x, 2) + Math.pow(startPoint.y - endPoint.y, 2));\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 获取角度\r\n\t     * @param  {[type]} centerPoint  [description]\r\n\t     * @param  {[type]} outsidePoint [description]\r\n\t     * @param  {[type]} round        [description]\r\n\t     * @return {[type]}              [description]\r\n\t     */\r\n\t    function getAngle(centerPoint, outsidePoint, round) {\r\n\t        centerPoint.x = enhancedRound(centerPoint.x, 5);\r\n\t        centerPoint.y = enhancedRound(centerPoint.y, 5);\r\n\t        outsidePoint.x = enhancedRound(outsidePoint.x, 5);\r\n\t        outsidePoint.y = enhancedRound(outsidePoint.y, 5);\r\n\t        var angle = Math.atan((outsidePoint.x - centerPoint.x) / (outsidePoint.y - centerPoint.y));\r\n\t        angle = -angle;\r\n\t\r\n\t        //endAngle+=90;\r\n\t        if (outsidePoint.x >= centerPoint.x && outsidePoint.y >= centerPoint.y) {\r\n\t            angle += Math.PI;\r\n\t        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y >= centerPoint.y) {\r\n\t            angle += Math.PI;\r\n\t        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y <= centerPoint.y) {\r\n\t            angle += Math.PI * 2;\r\n\t        }\r\n\t        while (angle >= Math.PI * 2) {\r\n\t            angle -= Math.PI * 2;\r\n\t        }\r\n\t        if (isNaN(angle)) { //Nan\r\n\t            angle = 0; //we are at center point;\r\n\t        }\r\n\t        if (round) {\r\n\t            angle = Math.round(angle / round) * round\r\n\t        }\r\n\t        return angle;\r\n\t    }\r\n\t\r\n\t    function getRect(node, isCalcParent) {\r\n\t        var clipPath = node.clipPath;\r\n\t        var boundingRect = node.getBoundingRect();\r\n\t        // 节点裁剪后，以裁剪节点包围盒为准\r\n\t        if (clipPath) {\r\n\t            boundingRect = clipPath.getBoundingRect();\r\n\t        }\r\n\t        //创建最小包围盒虚线\r\n\t        var points = [];\r\n\t        points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n\t        points[1] = [boundingRect.width / 2, -boundingRect.height / 2];\r\n\t        points[2] = [boundingRect.width / 2, boundingRect.height / 2];\r\n\t        points[3] = [-boundingRect.width / 2, boundingRect.height / 2];\r\n\t        points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n\t\r\n\t        var positionX = node.position[0];\r\n\t        var positionY = node.position[1];\r\n\t        //这里要循环判断一把 有没有父节点 并且父节点不是根节点 然后进行相加\r\n\t        if (node.parent && node.parent.type === \"GroupNode\" && isCalcParent) {\r\n\t            positionX = positionX + node.parent.position[0];\r\n\t            positionY = positionY + node.parent.position[1];\r\n\t        }\r\n\t\r\n\t        var boundRect = new BoundingRect(\r\n\t                Number(positionX + boundingRect.x),   //注: 因事件为圆形  所以 x y 为圆心的位置  包围矩形要减去宽度一半\r\n\t                Number(positionY + boundingRect.y),\r\n\t                Number(boundingRect.width),\r\n\t                Number(boundingRect.height)\r\n\t            );\r\n\t        //中心点\r\n\t        var cx = Number(positionX) + Number(boundingRect.width) / 2 + Number(boundingRect.x);\r\n\t        var cy = Number(positionY) + Number(boundingRect.height) / 2 + Number(boundingRect.y);\r\n\t        return {\r\n\t            x: Number(cx),\r\n\t            y: Number(cy),\r\n\t            width: Number(boundingRect.width),\r\n\t            height: Number(boundingRect.height),\r\n\t            points: points,\r\n\t            boundingRect: boundRect\r\n\t        };\r\n\t    }\r\n\t\r\n\t    var StackedMap = {\r\n\t        createNew: function() {\r\n\t            var stack = [];\r\n\t\r\n\t            return {\r\n\t                add: function(key, value) {\r\n\t                    var arrKey = this.get(key);\r\n\t                    arrKey.push(value)\r\n\t\r\n\t                },\r\n\t                get: function(key) {\r\n\t                    for (var i = 0; i < stack.length; i++) {\r\n\t                        if (key == stack[i].key) {\r\n\t                            return stack[i].value;\r\n\t                        }\r\n\t                    }\r\n\t                    //如果没有找到的话，则创建一个新的数组\r\n\t                    var value = [];\r\n\t                    stack.push({ key: key, value: value });\r\n\t                    return value;\r\n\t                },\r\n\t                keys: function() {\r\n\t                    var keys = [];\r\n\t                    for (var i = 0; i < stack.length; i++) {\r\n\t                        keys.push(stack[i].key);\r\n\t                    }\r\n\t                    return keys;\r\n\t                },\r\n\t                top: function() {\r\n\t                    return stack[stack.length - 1];\r\n\t                },\r\n\t                remove: function(key) {\r\n\t                    var idx = -1;\r\n\t                    for (var i = 0; i < stack.length; i++) {\r\n\t                        if (key == stack[i].key) {\r\n\t                            idx = i;\r\n\t                            break;\r\n\t                        }\r\n\t                    }\r\n\t                    return stack.splice(idx, 1)[0];\r\n\t                },\r\n\t                removeItem: function(key, item) {\r\n\t                    var arrKey = this.get(key);\r\n\t                    var index = zrUtil.indexOf(arrKey, item);\r\n\t                    arrKey.splice(index, 1);\r\n\t\r\n\t                },\r\n\t                removeTop: function() {\r\n\t                    return stack.splice(stack.length - 1, 1)[0];\r\n\t                },\r\n\t                length: function() {\r\n\t                    return stack.length;\r\n\t                },\r\n\t                clear: function() {\r\n\t                    stack.splice(0, stack.length);\r\n\t                }\r\n\t            };\r\n\t        }\r\n\t    };\r\n\t\r\n\t    function randomColor() {\r\n\t        var arrHex = [\"0\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\"],\r\n\t            strHex = \"#\",\r\n\t            index;\r\n\t        for (var i = 0; i < 6; i++) {\r\n\t            index = Math.round(Math.random() * 15);\r\n\t            strHex += arrHex[index];\r\n\t        }\r\n\t        return strHex;\r\n\t    }\r\n\t\r\n\t    function isUndefined(obj) {\r\n\t        return obj === void 0;\r\n\t    }\r\n\t\r\n\t    function collinearReduction (v) {\r\n\t        var r = [];\r\n\t\r\n\t        if(v.length < 3){\r\n\t            return Point.cloneArray(v);\r\n\t        }\r\n\t\r\n\t        r.push( v[0].clone() );\r\n\t        for(var i=1; i < v.length-1; i++){\r\n\t            if( (v[i-1].x == v[i].x && v[i].x == v[i+1].x)  ||  (v[i-1].y == v[i].y && v[i].y == v[i+1].y) )\r\n\t            {\r\n\t                continue;\r\n\t            }\r\n\t            else{\r\n\t                r.push( v[i].clone() );\r\n\t            }\r\n\t        }\r\n\t        r.push( v[v.length-1].clone() );\r\n\t\r\n\t        return r;\r\n\t    }\r\n\t\r\n\t    // By default, Underscore uses ERB-style template delimiters, change the\r\n\t    // following template settings to use alternative delimiters.\r\n\t    var templateSettings = {\r\n\t        evaluate: /<%([\\s\\S]+?)%>/g,\r\n\t        interpolate: /<%=([\\s\\S]+?)%>/g,\r\n\t        escape: /<%-([\\s\\S]+?)%>/g\r\n\t    };\r\n\t\r\n\t    // When customizing `templateSettings`, if you don't want to define an\r\n\t    // interpolation, evaluation or escaping regex, we need one that is\r\n\t    // guaranteed not to match.\r\n\t    var noMatch = /(.)^/;\r\n\t\r\n\t    // Certain characters need to be escaped so that they can be put into a\r\n\t    // string literal.\r\n\t    var escapes = {\r\n\t        \"'\": \"'\",\r\n\t        '\\\\': '\\\\',\r\n\t        '\\r': 'r',\r\n\t        '\\n': 'n',\r\n\t        '\\u2028': 'u2028',\r\n\t        '\\u2029': 'u2029'\r\n\t    };\r\n\t\r\n\t    var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\r\n\t\r\n\t    var escapeChar = function(match) {\r\n\t        return '\\\\' + escapes[match];\r\n\t    };\r\n\t\r\n\t    // JavaScript micro-templating, similar to John Resig's implementation.\r\n\t    // Underscore templating handles arbitrary delimiters, preserves whitespace,\r\n\t    // and correctly escapes quotes within interpolated code.\r\n\t    // NB: `oldSettings` only exists for backwards compatibility.\r\n\t    function template(text, settings, oldSettings) {\r\n\t        if (!settings && oldSettings) settings = oldSettings;\r\n\t        settings = settings || {};\r\n\t        settings = zrUtil.defaults(settings, templateSettings, true);\r\n\t\r\n\t        // Combine delimiters into one regular expression via alternation.\r\n\t        var matcher = RegExp([\r\n\t            (settings.escape || noMatch).source,\r\n\t            (settings.interpolate || noMatch).source,\r\n\t            (settings.evaluate || noMatch).source\r\n\t        ].join('|') + '|$', 'g');\r\n\t\r\n\t        // Compile the template source, escaping string literals appropriately.\r\n\t        var index = 0;\r\n\t        var source = \"__p+='\";\r\n\t        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\r\n\t            source += text.slice(index, offset).replace(escaper, escapeChar);\r\n\t            index = offset + match.length;\r\n\t\r\n\t            if (escape) {\r\n\t                source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\r\n\t            } else if (interpolate) {\r\n\t                source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\r\n\t            } else if (evaluate) {\r\n\t                source += \"';\\n\" + evaluate + \"\\n__p+='\";\r\n\t            }\r\n\t\r\n\t            // Adobe VMs need the match returned to produce the correct offest.\r\n\t            return match;\r\n\t        });\r\n\t        source += \"';\\n\";\r\n\t\r\n\t        // If a variable is not specified, place data values in local scope.\r\n\t        if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\r\n\t\r\n\t        source = \"var __t,__p='',__j=Array.prototype.join,\" +\r\n\t            \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\r\n\t            source + 'return __p;\\n';\r\n\t\r\n\t        try {\r\n\t            var render = new Function(settings.variable || 'obj', source);\r\n\t        } catch (e) {\r\n\t            e.source = source;\r\n\t            throw e;\r\n\t        }\r\n\t\r\n\t        var template = function(data) {\r\n\t            return render.call(this, data);\r\n\t        };\r\n\t\r\n\t        // Provide the compiled source as a convenience for precompilation.\r\n\t        var argument = settings.variable || 'obj';\r\n\t        template.source = 'function(' + argument + '){\\n' + source + '}';\r\n\t\r\n\t        return template;\r\n\t    }\r\n\t\r\n\t    function isEmpty(obj) {\r\n\t        if (obj == null) return true;\r\n\t        if (zrUtil.isArrayLike(obj) && (zrUtil.isArray(obj) || zrUtil.isString(obj))) return obj.length === 0;\r\n\t    }\r\n\t    function mergeOpt(target, source, overwrite, exclude) {\r\n\t        // We should escapse that source is string\r\n\t        // and enter for ... in ...\r\n\t        if (!zrUtil.isObject(source) || !zrUtil.isObject(target)) {\r\n\t          return overwrite ? zrUtil.clone(source) : target;\r\n\t        }\r\n\t\r\n\t        for (var key in source) {\r\n\t          if (source.hasOwnProperty(key)) {\r\n\t            var targetProp = target[key];\r\n\t            var sourceProp = source[key];\r\n\t\r\n\t            if (zrUtil.isObject(sourceProp) && zrUtil.isObject(targetProp) && !zrUtil.isArray(sourceProp) && !zrUtil.isArray(targetProp) && !zrUtil.isDom(sourceProp) && !zrUtil.isDom(targetProp) && !zrUtil.isBuiltInObject(sourceProp) && !zrUtil.isBuiltInObject(targetProp) && !zrUtil.isPrimitive(sourceProp) && !zrUtil.isPrimitive(targetProp)) {\r\n\t              // 如果需要递归覆盖，就递归调用merge\r\n\t              mergeOpt(targetProp, sourceProp, overwrite, exclude);\r\n\t            } else if (overwrite || !(key in target)) {\r\n\t              // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\r\n\t              // NOTE，在 target[key] 不存在的时候也是直接覆盖\r\n\t                if (key !== exclude) {\r\n\t                    target[key] = zrUtil.clone(source[key], true);\r\n\t                }\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t        return target;\r\n\t    }\r\n\t    function Class() {}\r\n\t    Class.extend = function(proto) {\r\n\t        var base = function() {},\r\n\t            member,\r\n\t            that = this,\r\n\t            subclass = proto && proto.init ? proto.init : function () {\r\n\t                that.apply(this, arguments);\r\n\t            },\r\n\t            fn;\r\n\t\r\n\t        base.prototype = that.prototype;\r\n\t        fn = subclass.fn = subclass.prototype = new base();\r\n\t\r\n\t        for (member in proto) {\r\n\t            if (proto[member] != null && proto[member].constructor === Object) {\r\n\t                // Merge object members\r\n\t                fn[member] = zrUtil.mergeAll([{}, base.prototype[member], proto[member]],true);\r\n\t            } else {\r\n\t                fn[member] = proto[member];\r\n\t            }\r\n\t        }\r\n\t\r\n\t        fn.constructor = subclass;\r\n\t        subclass.extend = that.extend;\r\n\t\r\n\t        return subclass;\r\n\t    };\r\n\t\r\n\t    module.exports = {\r\n\t        inherits: inherits,\r\n\t        getUUID: getUUID,\r\n\t        distance: distance,\r\n\t        getPolylineLength: getPolylineLength,\r\n\t        max: max,\r\n\t        min: min,\r\n\t        isEmpty: isEmpty,\r\n\t        mergeOpt: mergeOpt,\r\n\t        orthogonalPath: orthogonalPath,\r\n\t        polylineIntersectsRectangle: polylineIntersectsRectangle,\r\n\t        scorePath: scorePath,\r\n\t        forwardPath: forwardPath,\r\n\t        traslatePoints: traslatePoints,\r\n\t        getEndPoint: getEndPoint,\r\n\t        getConnectorPoints: getConnectorPoints,\r\n\t        getConnectorControls: getConnectorControls,\r\n\t        calculatePoints: calculatePoints,\r\n\t        tangentRotation: tangentRotation,\r\n\t        collinearity: collinearity,\r\n\t        translationMatrix: translationMatrix,\r\n\t        scaleMatrix: scaleMatrix,\r\n\t        round: enhancedRound,\r\n\t        getLength: getLength,\r\n\t        getAngle: getAngle,\r\n\t        getRect: getRect,\r\n\t        StackedMap: StackedMap,\r\n\t        getMaxLineLength: getMaxLineLength,\r\n\t        randomColor: randomColor,\r\n\t        template: template,\r\n\t        isUndefined: isUndefined,\r\n\t        getSoltPoints:getSoltPoints,\r\n\t        collinearReduction: collinearReduction,\r\n\t        Class:Class\r\n\t    };\r\n\t\r\n\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports) {\n\n\t\r\n\t\r\n\t    /**\r\n\t      * Creates an instance of Point\r\n\t      *\r\n\t      *\r\n\t      * @constructor\r\n\t      * @this {Point}\r\n\t      * @param {Number} x The x coordinate of point.\r\n\t      * @param {Number} y The y coordinate of point.\r\n\t      * Note: Even if it is named Point this class should be named Dot as Dot is closer\r\n\t      * then Point from math perspective.\r\n\t      **/\r\n\t    function Point(x, y){\r\n\t        /**The x coordinate of point*/\r\n\t        this.x = x;\r\n\t\r\n\t        /**The y coordinate of point*/\r\n\t        this.y = y;\r\n\t\r\n\t\r\n\t    }\r\n\t\r\n\t    /**Creates a {Point} out of JSON parsed object\r\n\t     *@param {JSONObject} o - the JSON parsed object\r\n\t     *@return {Point} a newly constructed Point\r\n\t     **/\r\n\t    Point.load = function(o){\r\n\t        var newPoint = new Point(Number(o.x), Number(o.y));\r\n\t        return newPoint;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**Creates an array of points from an array of {JSONObject}s\r\n\t     *@param {Array} v - the array of JSONObjects\r\n\t     *@return an {Array} of {Point}s\r\n\t     **/\r\n\t    Point.loadArray = function(v){\r\n\t        var newPoints = [];\r\n\t        for(var i=0; i< v.length; i++){\r\n\t            newPoints.push(Point.load(v[i]));\r\n\t        }\r\n\t        return newPoints;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**Clones an array of points\r\n\t     *@param {Array} v - the array of {Point}s\r\n\t     *@return an {Array} of {Point}s\r\n\t     **/\r\n\t    Point.cloneArray = function(v){\r\n\t        var newPoints = [];\r\n\t        for(var i=0; i< v.length; i++){\r\n\t            newPoints.push(v[i].clone());\r\n\t        }\r\n\t        return newPoints;\r\n\t    };\r\n\t\r\n\t    Point.prototype = {\r\n\t        constructor : Point,\r\n\t\r\n\t        transform:function(matrix){\r\n\t            var oldX = this.x;\r\n\t            var oldY = this.y;\r\n\t            this.x = matrix[0][0] * oldX + matrix[0][1] * oldY + matrix[0][2];\r\n\t            this.y = matrix[1][0] * oldX + matrix[1][1] * oldY + matrix[1][2];\r\n\t        },\r\n\t\r\n\t        /**Tests if this point is similar to other point\r\n\t         *@param {Point} anotherPoint - the other point\r\n\t         **/\r\n\t        equals:function(anotherPoint){\r\n\t            if(! (anotherPoint instanceof Point) ){\r\n\t                return false;\r\n\t            }\r\n\t            return (this.x == anotherPoint.x)\r\n\t            && (this.y == anotherPoint.y)\r\n\t        },\r\n\t\r\n\t        /**Clone current Point\r\n\t         **/\r\n\t        clone: function(){\r\n\t            var newPoint = new Point(this.x, this.y);\r\n\t            return newPoint;\r\n\t        },\r\n\t\r\n\t        add: function(point) {\r\n\t            this.x = this.x + point.x;\r\n\t            this.y = this.y + point.y;\r\n\t            return this;\r\n\t        },\r\n\t\r\n\t        /**Tests to see if a point (x, y) is within a range of current Point\r\n\t         *@param {Numeric} x - the x coordinate of tested point\r\n\t         *@param {Numeric} y - the x coordinate of tested point\r\n\t         *@param {Numeric} radius - the radius of the vicinity\r\n\t         **/\r\n\t        near:function(x, y, radius){\r\n\t            var distance = Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));\r\n\t\r\n\t            return (distance <= radius);\r\n\t        },\r\n\t\r\n\t        contains: function(x,y){\r\n\t            return this.x == x && this.y == y;\r\n\t        },\r\n\t\r\n\t        toString:function(){\r\n\t            return '[' + this.x + ',' + this.y + ']';\r\n\t        },\r\n\t\r\n\t        getPoints:function(){\r\n\t            return [this];\r\n\t        }\r\n\t    };\r\n\t    module.exports = Point;\r\n\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports) {\n\n\t\r\n\t\r\n\t    /**\r\n\t      * Creates an instance of a Line. A Line is actually a segment and not a pure\r\n\t      * geometrical Line\r\n\t      *\r\n\t      * @constructor\r\n\t      * @this {Line}\r\n\t      * @param {Point} startPoint - starting point of the line\r\n\t      * @param {Point} endPoint - the ending point of the line\r\n\t      **/\r\n\t    function Line(startPoint, endPoint){\r\n\t        /**Starting {@link Point} of the line*/\r\n\t        this.startPoint = startPoint;\r\n\t\r\n\t        /**Ending {@link Point} of the line*/\r\n\t        this.endPoint = endPoint;\r\n\t\r\n\t        /**Serialization type*/\r\n\t        this.oType = 'Line'; //object type used for JSON deserialization\r\n\t    }\r\n\t\r\n\t    /**Creates a {Line} out of JSON parsed object\r\n\t     *@param {JSONObject} o - the JSON parsed object\r\n\t     *@return {Line} a newly constructed Line\r\n\t     **/\r\n\t    Line.load = function(o){\r\n\t        var newLine = new Line(\r\n\t            Point.load(o.startPoint),\r\n\t            Point.load(o.endPoint)\r\n\t        );\r\n\t\r\n\t        return newLine;\r\n\t    };\r\n\t\r\n\t    Line.prototype = {\r\n\t        contructor: Line,\r\n\t\r\n\t\r\n\t\r\n\t        clone:function(){\r\n\t            var ret = new Line(this.startPoint.clone(), this.endPoint.clone());\r\n\t            return ret;\r\n\t        },\r\n\t\r\n\t        equals:function(anotherLine){\r\n\t            if(!anotherLine instanceof Line){\r\n\t                return false;\r\n\t            }\r\n\t            return this.startPoint.equals(anotherLine.startPoint)\r\n\t            && this.endPoint.equals(anotherLine.endPoint)\r\n\t        },\r\n\t\r\n\t        /** Tests to see if a point belongs to this line (not as infinite line but more like a segment)\r\n\t         * Algorithm: Compute line's equation and see if (x, y) verifies it.\r\n\t         * @param {Number} x - the X coordinates\r\n\t         * @param {Number} y - the Y coordinates\r\n\t         **/\r\n\t        contains: function(x, y){\r\n\t            // if the point is inside rectangle bounds of the segment\r\n\t            if (Math.min(this.startPoint.x, this.endPoint.x) <= x\r\n\t                && x <= Math.max(this.startPoint.x, this.endPoint.x)\r\n\t                && Math.min(this.startPoint.y, this.endPoint.y) <= y\r\n\t                && y <= Math.max(this.startPoint.y, this.endPoint.y)) {\r\n\t\r\n\t                // check for vertical line\r\n\t                if (this.startPoint.x == this.endPoint.x) {\r\n\t                    return x == this.startPoint.x;\r\n\t                } else { // usual (not vertical) line can be represented as y = a * x + b\r\n\t                    var a = (this.endPoint.y - this.startPoint.y) / (this.endPoint.x - this.startPoint.x);\r\n\t                    var b = this.startPoint.y - a * this.startPoint.x;\r\n\t                    return y == a * x + b;\r\n\t                }\r\n\t            } else {\r\n\t                return false;\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /*\r\n\t         *See if we are near a {Line} by a certain radius (also includes the extremities into computation)\r\n\t         *@param {Number} x - the x coordinates\r\n\t         *@param {Number} y - the y coordinates\r\n\t         *@param {Number} radius - the radius to search for\r\n\t         *@see http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n\t         *@see \"Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227\"\r\n\t         **/\r\n\t        near:function(x,y,radius){\r\n\t\r\n\t            if(this.endPoint.x === this.startPoint.x){ //Vertical line, so the vicinity area is a rectangle\r\n\t                return ( (this.startPoint.y-radius<=y && this.endPoint.y+radius>=y)\r\n\t                        || (this.endPoint.y-radius<=y && this.startPoint.y+radius>=y))\r\n\t                && x > this.startPoint.x - radius && x < this.startPoint.x + radius ;\r\n\t            }\r\n\t\r\n\t            if(this.startPoint.y === this.endPoint.y){ //Horizontal line, so the vicinity area is a rectangle\r\n\t                return ( (this.startPoint.x - radius<=x && this.endPoint.x+radius>=x)\r\n\t                        || (this.endPoint.x-radius<=x && this.startPoint.x+radius>=x))\r\n\t                        && y>this.startPoint.y-radius && y<this.startPoint.y+radius ;\r\n\t            }\r\n\t\r\n\t\r\n\t            var startX = Math.min(this.endPoint.x,this.startPoint.x);\r\n\t            var startY = Math.min(this.endPoint.y,this.startPoint.y);\r\n\t            var endX = Math.max(this.endPoint.x,this.startPoint.x);\r\n\t            var endY = Math.max(this.endPoint.y,this.startPoint.y);\r\n\t\r\n\t            /*We will compute the distance from point to the line\r\n\t             * by using the algorithm from\r\n\t             * http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n\t             * */\r\n\t\r\n\t            //First we need to find a,b,c of the line equation ax + by + c = 0\r\n\t            var a = this.endPoint.y - this.startPoint.y;\r\n\t            var b = this.startPoint.x - this.endPoint.x;\r\n\t            var c = -(this.startPoint.x * this.endPoint.y - this.endPoint.x * this.startPoint.y);\r\n\t\r\n\t            //Secondly we get the distance \"Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227\"\r\n\t            var d = Math.abs( (a*x + b*y + c) / Math.sqrt(Math.pow(a,2) + Math.pow(b,2)) );\r\n\t\r\n\t            //Thirdly we get coordinates of closest line's point to target point\r\n\t            //http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Cartesian_coordinates\r\n\t            var closestX = (b * (b*x - a*y) - a*c) / ( Math.pow(a,2) + Math.pow(b,2) );\r\n\t            var closestY = (a * (-b*x + a*y) - b*c) / ( Math.pow(a,2) + Math.pow(b,2) );\r\n\t\r\n\t            var r = ( d <= radius && endX>=closestX && closestX>=startX && endY>=closestY && closestY>=startY ) //the projection of the point falls INSIDE of the segment\r\n\t                || this.startPoint.near(x,y,radius) || this.endPoint.near(x,y,radius); //the projection of the point falls OUTSIDE of the segment\r\n\t\r\n\t            return  r;\r\n\t\r\n\t        },\r\n\t\r\n\t        /**we need to create a new array each time, or we will affect the actual shape*/\r\n\t        getPoints:function(){\r\n\t            var points = [];\r\n\t            points.push(this.startPoint);\r\n\t            points.push(this.endPoint);\r\n\t            return points;\r\n\t        },\r\n\t\r\n\t        /**Return the {Point} corresponding the t certain t value\r\n\t         * @param {Number} t the value of parameter t, where t in [0,1], t is like a percent*/\r\n\t        getPoint: function(t){\r\n\t            var Xp = t * (this.endPoint.x - this.startPoint.x) + this.startPoint.x;\r\n\t            var Yp = t * (this.endPoint.y - this.startPoint.y) + this.startPoint.y;\r\n\t\r\n\t            return new Point(Xp, Yp);\r\n\t        },\r\n\t\r\n\t        // /**\r\n\t        //  * Returns the middle of the line\r\n\t        //  * @return {Point} the middle point\r\n\t        //  * */\r\n\t        // getMiddle : function(){\r\n\t        //     return Util.getMiddle(this.startPoint, this.endPoint);\r\n\t        // },\r\n\t\r\n\t\r\n\t        // getLength : function(){\r\n\t        //     return Util.getLength(this.startPoint, this.endPoint);\r\n\t        // },\r\n\t\r\n\t        // /**\r\n\t        //  *Get bounds for this line\r\n\t        //  *@author Alex Gheorghiu <alex@scriptoid.com>\r\n\t        //  **/\r\n\t        // getBounds:function(){\r\n\t        //     return Util.getBounds(this.getPoints());\r\n\t        // },\r\n\t\r\n\t        /**String representation*/\r\n\t        toString:function(){\r\n\t            return 'line(' + this.startPoint + ',' + this.endPoint + ')';\r\n\t        }\r\n\t    };\r\n\t    module.exports = Line;\r\n\t\r\n\t\r\n\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t\r\n\t    var apiList = [\r\n\t        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction',\r\n\t        'on', 'off', 'trigger', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption',\r\n\t        \"remove\", \"_getParentZr\", \"changeSelectConnectorType\",\"_addGroupNode\"\r\n\t    ];\r\n\t\r\n\t    function ExtensionAPI(instance) {\r\n\t        zrUtil.each(apiList, function (name) {\r\n\t            this[name] = zrUtil.bind(instance[name], instance);\r\n\t        }, this);\r\n\t    }\r\n\t\r\n\t    module.exports = ExtensionAPI;\r\n\t\r\n\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar guid = __webpack_require__(11);\n\t\n\tvar env = __webpack_require__(50);\n\t\n\tvar zrUtil = __webpack_require__(5);\n\t\n\tvar Handler = __webpack_require__(70);\n\t\n\tvar Storage = __webpack_require__(71);\n\t\n\tvar Painter = __webpack_require__(73);\n\t\n\tvar Animation = __webpack_require__(76);\n\t\n\tvar HandlerProxy = __webpack_require__(78);\n\t\n\t/*!\n\t* ZRender, a high performance 2d drawing library.\n\t*\n\t* Copyright (c) 2013, Baidu Inc.\n\t* All rights reserved.\n\t*\n\t* LICENSE\n\t* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n\t*/\n\tvar useVML = !env.canvasSupported;\n\tvar painterCtors = {\n\t  canvas: Painter\n\t};\n\tvar instances = {}; // ZRender实例map索引\n\t\n\t/**\n\t * @type {string}\n\t */\n\t\n\tvar version = '3.7.4';\n\t/**\n\t * Initializing a zrender instance\n\t * @param {HTMLElement} dom\n\t * @param {Object} opts\n\t * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t * @param {number} [opts.devicePixelRatio]\n\t * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n\t * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n\t * @return {module:zrender/ZRender}\n\t */\n\t\n\tfunction init(dom, opts) {\n\t  var zr = new ZRender(guid(), dom, opts);\n\t  instances[zr.id] = zr;\n\t  return zr;\n\t}\n\t/**\n\t * Dispose zrender instance\n\t * @param {module:zrender/ZRender} zr\n\t */\n\t\n\t\n\tfunction dispose(zr) {\n\t  if (zr) {\n\t    zr.dispose();\n\t  } else {\n\t    for (var key in instances) {\n\t      if (instances.hasOwnProperty(key)) {\n\t        instances[key].dispose();\n\t      }\n\t    }\n\t\n\t    instances = {};\n\t  }\n\t\n\t  return this;\n\t}\n\t/**\n\t * Get zrender instance by id\n\t * @param {string} id zrender instance id\n\t * @return {module:zrender/ZRender}\n\t */\n\t\n\t\n\tfunction getInstance(id) {\n\t  return instances[id];\n\t}\n\t\n\tfunction registerPainter(name, Ctor) {\n\t  painterCtors[name] = Ctor;\n\t}\n\t\n\tfunction delInstance(id) {\n\t  delete instances[id];\n\t}\n\t/**\n\t * @module zrender/ZRender\n\t */\n\t\n\t/**\n\t * @constructor\n\t * @alias module:zrender/ZRender\n\t * @param {string} id\n\t * @param {HTMLElement} dom\n\t * @param {Object} opts\n\t * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t * @param {number} [opts.devicePixelRatio]\n\t * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n\t * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n\t */\n\t\n\t\n\tvar ZRender = function (id, dom, opts) {\n\t  opts = opts || {};\n\t  /**\n\t   * @type {HTMLDomElement}\n\t   */\n\t\n\t  this.dom = dom;\n\t  /**\n\t   * @type {string}\n\t   */\n\t\n\t  this.id = id;\n\t  var self = this;\n\t  var storage = new Storage();\n\t  var rendererType = opts.renderer; // TODO WebGL\n\t\n\t  if (useVML) {\n\t    if (!painterCtors.vml) {\n\t      throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n\t    }\n\t\n\t    rendererType = 'vml';\n\t  } else if (!rendererType || !painterCtors[rendererType]) {\n\t    rendererType = 'canvas';\n\t  }\n\t\n\t  var painter = new painterCtors[rendererType](dom, storage, opts);\n\t  this.storage = storage;\n\t  this.painter = painter;\n\t  var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n\t  this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\t  /**\n\t   * @type {module:zrender/animation/Animation}\n\t   */\n\t\n\t  this.animation = new Animation({\n\t    stage: {\n\t      update: zrUtil.bind(this.flush, this)\n\t    }\n\t  });\n\t  this.animation.start();\n\t  /**\n\t   * @type {boolean}\n\t   * @private\n\t   */\n\t\n\t  this._needsRefresh; // 修改 storage.delFromStorage, 每次删除元素之前删除动画\n\t  // FIXME 有点ugly\n\t\n\t  var oldDelFromStorage = storage.delFromStorage;\n\t  var oldAddToStorage = storage.addToStorage;\n\t\n\t  storage.delFromStorage = function (el) {\n\t    oldDelFromStorage.call(storage, el);\n\t    el && el.removeSelfFromZr(self);\n\t  };\n\t\n\t  storage.addToStorage = function (el) {\n\t    oldAddToStorage.call(storage, el);\n\t    el.addSelfToZr(self);\n\t  };\n\t};\n\t\n\tZRender.prototype = {\n\t  constructor: ZRender,\n\t\n\t  /**\n\t   * 获取实例唯一标识\n\t   * @return {string}\n\t   */\n\t  getId: function () {\n\t    return this.id;\n\t  },\n\t\n\t  /**\n\t   * 添加元素\n\t   * @param  {module:zrender/Element} el\n\t   */\n\t  add: function (el) {\n\t    this.storage.addRoot(el);\n\t    this._needsRefresh = true;\n\t  },\n\t\n\t  /**\n\t   * 删除元素\n\t   * @param  {module:zrender/Element} el\n\t   */\n\t  remove: function (el) {\n\t    this.storage.delRoot(el);\n\t    this._needsRefresh = true;\n\t  },\n\t\n\t  /**\n\t   * Change configuration of layer\n\t   * @param {string} zLevel\n\t   * @param {Object} config\n\t   * @param {string} [config.clearColor=0] Clear color\n\t   * @param {string} [config.motionBlur=false] If enable motion blur\n\t   * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n\t  */\n\t  configLayer: function (zLevel, config) {\n\t    this.painter.configLayer(zLevel, config);\n\t    this._needsRefresh = true;\n\t  },\n\t\n\t  /**\n\t   * Repaint the canvas immediately\n\t   */\n\t  refreshImmediately: function () {\n\t    // var start = new Date();\n\t    // Clear needsRefresh ahead to avoid something wrong happens in refresh\n\t    // Or it will cause zrender refreshes again and again.\n\t    this._needsRefresh = false;\n\t    this.painter.refresh();\n\t    /**\n\t     * Avoid trigger zr.refresh in Element#beforeUpdate hook\n\t     */\n\t\n\t    this._needsRefresh = false; // var end = new Date();\n\t    // var log = document.getElementById('log');\n\t    // if (log) {\n\t    //     log.innerHTML = log.innerHTML + '<br>' + (end - start);\n\t    // }\n\t  },\n\t\n\t  /**\n\t   * Mark and repaint the canvas in the next frame of browser\n\t   */\n\t  refresh: function () {\n\t    this._needsRefresh = true;\n\t  },\n\t\n\t  /**\n\t   * Perform all refresh\n\t   */\n\t  flush: function () {\n\t    if (this._needsRefresh) {\n\t      this.refreshImmediately();\n\t    }\n\t\n\t    if (this._needsRefreshHover) {\n\t      this.refreshHoverImmediately();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Add element to hover layer\n\t   * @param  {module:zrender/Element} el\n\t   * @param {Object} style\n\t   */\n\t  addHover: function (el, style) {\n\t    if (this.painter.addHover) {\n\t      this.painter.addHover(el, style);\n\t      this.refreshHover();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Add element from hover layer\n\t   * @param  {module:zrender/Element} el\n\t   */\n\t  removeHover: function (el) {\n\t    if (this.painter.removeHover) {\n\t      this.painter.removeHover(el);\n\t      this.refreshHover();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Clear all hover elements in hover layer\n\t   * @param  {module:zrender/Element} el\n\t   */\n\t  clearHover: function () {\n\t    if (this.painter.clearHover) {\n\t      this.painter.clearHover();\n\t      this.refreshHover();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Refresh hover in next frame\n\t   */\n\t  refreshHover: function () {\n\t    this._needsRefreshHover = true;\n\t  },\n\t\n\t  /**\n\t   * Refresh hover immediately\n\t   */\n\t  refreshHoverImmediately: function () {\n\t    this._needsRefreshHover = false;\n\t    this.painter.refreshHover && this.painter.refreshHover();\n\t  },\n\t\n\t  /**\n\t   * Resize the canvas.\n\t   * Should be invoked when container size is changed\n\t   * @param {Object} [opts]\n\t   * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n\t   * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n\t   */\n\t  resize: function (opts) {\n\t    opts = opts || {};\n\t    this.painter.resize(opts.width, opts.height);\n\t    this.handler.resize();\n\t  },\n\t\n\t  /**\n\t   * Stop and clear all animation immediately\n\t   */\n\t  clearAnimation: function () {\n\t    this.animation.clear();\n\t  },\n\t\n\t  /**\n\t   * Get container width\n\t   */\n\t  getWidth: function () {\n\t    return this.painter.getWidth();\n\t  },\n\t\n\t  /**\n\t   * Get container height\n\t   */\n\t  getHeight: function () {\n\t    return this.painter.getHeight();\n\t  },\n\t\n\t  /**\n\t   * Export the canvas as Base64 URL\n\t   * @param {string} type\n\t   * @param {string} [backgroundColor='#fff']\n\t   * @return {string} Base64 URL\n\t   */\n\t  // toDataURL: function(type, backgroundColor) {\n\t  //     return this.painter.getRenderedCanvas({\n\t  //         backgroundColor: backgroundColor\n\t  //     }).toDataURL(type);\n\t  // },\n\t\n\t  /**\n\t   * Converting a path to image.\n\t   * It has much better performance of drawing image rather than drawing a vector path.\n\t   * @param {module:zrender/graphic/Path} e\n\t   * @param {number} width\n\t   * @param {number} height\n\t   */\n\t  pathToImage: function (e, dpr) {\n\t    return this.painter.pathToImage(e, dpr);\n\t  },\n\t\n\t  /**\n\t   * Set default cursor\n\t   * @param {string} [cursorStyle='default'] 例如 crosshair\n\t   */\n\t  setCursorStyle: function (cursorStyle) {\n\t    this.handler.setCursorStyle(cursorStyle);\n\t  },\n\t\n\t  /**\n\t   * Find hovered element\n\t   * @param {number} x\n\t   * @param {number} y\n\t   * @return {Object} {target, topTarget}\n\t   */\n\t  findHover: function (x, y) {\n\t    return this.handler.findHover(x, y);\n\t  },\n\t\n\t  /**\n\t   * Bind event\n\t   *\n\t   * @param {string} eventName Event name\n\t   * @param {Function} eventHandler Handler function\n\t   * @param {Object} [context] Context object\n\t   */\n\t  on: function (eventName, eventHandler, context) {\n\t    this.handler.on(eventName, eventHandler, context);\n\t  },\n\t\n\t  /**\n\t   * Unbind event\n\t   * @param {string} eventName Event name\n\t   * @param {Function} [eventHandler] Handler function\n\t   */\n\t  off: function (eventName, eventHandler) {\n\t    this.handler.off(eventName, eventHandler);\n\t  },\n\t\n\t  /**\n\t   * Trigger event manually\n\t   *\n\t   * @param {string} eventName Event name\n\t   * @param {event=} event Event object\n\t   */\n\t  trigger: function (eventName, event) {\n\t    this.handler.trigger(eventName, event);\n\t  },\n\t\n\t  /**\n\t   * Clear all objects and the canvas.\n\t   */\n\t  clear: function () {\n\t    this.storage.delRoot();\n\t    this.painter.clear();\n\t  },\n\t\n\t  /**\n\t   * Dispose self.\n\t   */\n\t  dispose: function () {\n\t    this.animation.stop();\n\t    this.clear();\n\t    this.storage.dispose();\n\t    this.painter.dispose();\n\t    this.handler.dispose();\n\t    this.animation = this.storage = this.painter = this.handler = null;\n\t    delInstance(this.id);\n\t  }\n\t};\n\texports.version = version;\n\texports.init = init;\n\texports.dispose = dispose;\n\texports.getInstance = getInstance;\n\texports.registerPainter = registerPainter;\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(5);\n\t\n\tvar vec2 = __webpack_require__(15);\n\t\n\tvar Draggable = __webpack_require__(43);\n\t\n\tvar Eventful = __webpack_require__(12);\n\t\n\t/**\n\t * Handler\n\t * @module zrender/Handler\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (shenyi.914@gmail.com)\n\t */\n\tvar SILENT = 'silent';\n\t\n\tfunction makeEventPacket(eveType, targetInfo, event) {\n\t  return {\n\t    type: eveType,\n\t    event: event,\n\t    // target can only be an element that is not silent.\n\t    target: targetInfo.target,\n\t    // topTarget can be a silent element.\n\t    topTarget: targetInfo.topTarget,\n\t    cancelBubble: false,\n\t    offsetX: event.zrX,\n\t    offsetY: event.zrY,\n\t    gestureEvent: event.gestureEvent,\n\t    pinchX: event.pinchX,\n\t    pinchY: event.pinchY,\n\t    pinchScale: event.pinchScale,\n\t    wheelDelta: event.zrDelta,\n\t    zrByTouch: event.zrByTouch,\n\t    which: event.which\n\t  };\n\t}\n\t\n\tfunction EmptyProxy() {}\n\t\n\tEmptyProxy.prototype.dispose = function () {};\n\t\n\tvar handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n\t/**\n\t * @alias module:zrender/Handler\n\t * @constructor\n\t * @extends module:zrender/mixin/Eventful\n\t * @param {module:zrender/Storage} storage Storage instance.\n\t * @param {module:zrender/Painter} painter Painter instance.\n\t * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n\t * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n\t */\n\t\n\tvar Handler = function (storage, painter, proxy, painterRoot) {\n\t  Eventful.call(this);\n\t  this.storage = storage;\n\t  this.painter = painter;\n\t  this.painterRoot = painterRoot;\n\t  proxy = proxy || new EmptyProxy();\n\t  /**\n\t   * Proxy of event. can be Dom, WebGLSurface, etc.\n\t   */\n\t\n\t  this.proxy = proxy; // Attach handler\n\t\n\t  proxy.handler = this;\n\t  /**\n\t   * {target, topTarget, x, y}\n\t   * @private\n\t   * @type {Object}\n\t   */\n\t\n\t  this._hovered = {};\n\t  /**\n\t   * @private\n\t   * @type {Date}\n\t   */\n\t\n\t  this._lastTouchMoment;\n\t  /**\n\t   * @private\n\t   * @type {number}\n\t   */\n\t\n\t  this._lastX;\n\t  /**\n\t   * @private\n\t   * @type {number}\n\t   */\n\t\n\t  this._lastY;\n\t  Draggable.call(this);\n\t  util.each(handlerNames, function (name) {\n\t    proxy.on && proxy.on(name, this[name], this);\n\t  }, this);\n\t};\n\t\n\tHandler.prototype = {\n\t  constructor: Handler,\n\t  mousemove: function (event) {\n\t    var x = event.zrX;\n\t    var y = event.zrY;\n\t    var lastHovered = this._hovered;\n\t    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call\n\t    // (like 'setOption' or 'dispatchAction') in event handlers, we should find\n\t    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.\n\t    // See #6198.\n\t\n\t    if (lastHoveredTarget && !lastHoveredTarget.__zr) {\n\t      lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n\t      lastHoveredTarget = lastHovered.target;\n\t    }\n\t\n\t    var hovered = this._hovered = this.findHover(x, y);\n\t    var hoveredTarget = hovered.target;\n\t    var proxy = this.proxy;\n\t    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element\n\t\n\t    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n\t      this.dispatchToElement(lastHovered, 'mouseout', event);\n\t    } // Mouse moving on one element\n\t\n\t\n\t    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element\n\t\n\t    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n\t      this.dispatchToElement(hovered, 'mouseover', event);\n\t    }\n\t  },\n\t  mouseout: function (event) {\n\t    this.dispatchToElement(this._hovered, 'mouseout', event); // There might be some doms created by upper layer application\n\t    // at the same level of painter.getViewportRoot() (e.g., tooltip\n\t    // dom created by echarts), where 'globalout' event should not\n\t    // be triggered when mouse enters these doms. (But 'mouseout'\n\t    // should be triggered at the original hovered element as usual).\n\t\n\t    var element = event.toElement || event.relatedTarget;\n\t    var innerDom;\n\t\n\t    do {\n\t      element = element && element.parentNode;\n\t    } while (element && element.nodeType != 9 && !(innerDom = element === this.painterRoot));\n\t\n\t    !innerDom && this.trigger('globalout', {\n\t      event: event\n\t    });\n\t  },\n\t\n\t  /**\n\t   * Resize\n\t   */\n\t  resize: function (event) {\n\t    this._hovered = {};\n\t  },\n\t\n\t  /**\n\t   * Dispatch event\n\t   * @param {string} eventName\n\t   * @param {event=} eventArgs\n\t   */\n\t  dispatch: function (eventName, eventArgs) {\n\t    var handler = this[eventName];\n\t    handler && handler.call(this, eventArgs);\n\t  },\n\t\n\t  /**\n\t   * Dispose\n\t   */\n\t  dispose: function () {\n\t    this.proxy.dispose();\n\t    this.storage = this.proxy = this.painter = null;\n\t  },\n\t\n\t  /**\n\t   * 设置默认的cursor style\n\t   * @param {string} [cursorStyle='default'] 例如 crosshair\n\t   */\n\t  setCursorStyle: function (cursorStyle) {\n\t    var proxy = this.proxy;\n\t    proxy.setCursor && proxy.setCursor(cursorStyle);\n\t  },\n\t\n\t  /**\n\t   * 事件分发代理\n\t   *\n\t   * @private\n\t   * @param {Object} targetInfo {target, topTarget} 目标图形元素\n\t   * @param {string} eventName 事件名称\n\t   * @param {Object} event 事件对象\n\t   */\n\t  dispatchToElement: function (targetInfo, eventName, event) {\n\t    targetInfo = targetInfo || {};\n\t    var el = targetInfo.target;\n\t\n\t    if (el && el.silent) {\n\t      return;\n\t    }\n\t\n\t    var eventHandler = 'on' + eventName;\n\t    var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\t\n\t    while (el) {\n\t      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\t      el.trigger(eventName, eventPacket);\n\t      el = el.parent;\n\t\n\t      if (eventPacket.cancelBubble) {\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (!eventPacket.cancelBubble) {\n\t      // 冒泡到顶级 zrender 对象\n\t      this.trigger(eventName, eventPacket); // 分发事件到用户自定义层\n\t      // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n\t\n\t      this.painter && this.painter.eachOtherLayer(function (layer) {\n\t        if (typeof layer[eventHandler] == 'function') {\n\t          layer[eventHandler].call(layer, eventPacket);\n\t        }\n\t\n\t        if (layer.trigger) {\n\t          layer.trigger(eventName, eventPacket);\n\t        }\n\t      });\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @private\n\t   * @param {number} x\n\t   * @param {number} y\n\t   * @param {module:zrender/graphic/Displayable} exclude\n\t   * @return {model:zrender/Element}\n\t   * @method\n\t   */\n\t  findHover: function (x, y, exclude) {\n\t    var list = this.storage.getDisplayList();\n\t    var out = {\n\t      x: x,\n\t      y: y\n\t    };\n\t\n\t    for (var i = list.length - 1; i >= 0; i--) {\n\t      var hoverCheckResult;\n\t\n\t      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode\n\t      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {\n\t        !out.topTarget && (out.topTarget = list[i]);\n\t\n\t        if (hoverCheckResult !== SILENT) {\n\t          out.target = list[i];\n\t          break;\n\t        }\n\t      }\n\t    }\n\t\n\t    return out;\n\t  }\n\t}; // Common handlers\n\t\n\tutil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n\t  Handler.prototype[name] = function (event) {\n\t    // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n\t    var hovered = this.findHover(event.zrX, event.zrY);\n\t    var hoveredTarget = hovered.target;\n\t\n\t    if (name === 'mousedown') {\n\t      this._downEl = hoveredTarget;\n\t      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup\n\t\n\t      this._upEl = hoveredTarget;\n\t    } else if (name === 'mosueup') {\n\t      this._upEl = hoveredTarget;\n\t    } else if (name === 'click') {\n\t      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,\n\t      // including the case that `mousedown` - `mousemove` - `mouseup`,\n\t      // which should be filtered, otherwise it will bring trouble to\n\t      // pan and zoom.\n\t      || !this._downPoint // Arbitrary value\n\t      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {\n\t        return;\n\t      }\n\t\n\t      this._downPoint = null;\n\t    }\n\t\n\t    this.dispatchToElement(hovered, name, event);\n\t  };\n\t});\n\t\n\tfunction isHover(displayable, x, y) {\n\t  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n\t    var el = displayable;\n\t    var isSilent;\n\t\n\t    while (el) {\n\t      // If clipped by ancestor.\n\t      // FIXME: If clipPath has neither stroke nor fill,\n\t      // el.clipPath.contain(x, y) will always return false.\n\t      if (el.clipPath && !el.clipPath.contain(x, y)) {\n\t        return false;\n\t      }\n\t\n\t      if (el.silent) {\n\t        isSilent = true;\n\t      }\n\t\n\t      el = el.parent;\n\t    }\n\t\n\t    return isSilent ? SILENT : true;\n\t  }\n\t\n\t  return false;\n\t}\n\t\n\tutil.mixin(Handler, Eventful);\n\tutil.mixin(Handler, Draggable);\n\tvar _default = Handler;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(5);\n\t\n\tvar env = __webpack_require__(50);\n\t\n\tvar Group = __webpack_require__(44);\n\t\n\tvar timsort = __webpack_require__(72);\n\t\n\t/**\n\t * Storage内容仓库模块\n\t * @module zrender/Storage\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t * @author errorrik (errorrik@gmail.com)\n\t * @author pissang (https://github.com/pissang/)\n\t */\n\t// Use timsort because in most case elements are partially sorted\n\t// https://jsfiddle.net/pissang/jr4x7mdm/8/\n\tfunction shapeCompareFunc(a, b) {\n\t  if (a.zlevel === b.zlevel) {\n\t    if (a.z === b.z) {\n\t      // if (a.z2 === b.z2) {\n\t      //     // FIXME Slow has renderidx compare\n\t      //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n\t      //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n\t      //     return a.__renderidx - b.__renderidx;\n\t      // }\n\t      return a.z2 - b.z2;\n\t    }\n\t\n\t    return a.z - b.z;\n\t  }\n\t\n\t  return a.zlevel - b.zlevel;\n\t}\n\t/**\n\t * 内容仓库 (M)\n\t * @alias module:zrender/Storage\n\t * @constructor\n\t */\n\t\n\t\n\tvar Storage = function () {\n\t  // jshint ignore:line\n\t  this._roots = [];\n\t  this._displayList = [];\n\t  this._displayListLen = 0;\n\t};\n\t\n\tStorage.prototype = {\n\t  constructor: Storage,\n\t\n\t  /**\n\t   * @param  {Function} cb\n\t   *\n\t   */\n\t  traverse: function (cb, context) {\n\t    for (var i = 0; i < this._roots.length; i++) {\n\t      this._roots[i].traverse(cb, context);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 返回所有图形的绘制队列\n\t   * @param {boolean} [update=false] 是否在返回前更新该数组\n\t   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\n\t   *\n\t   * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n\t   * @return {Array.<module:zrender/graphic/Displayable>}\n\t   */\n\t  getDisplayList: function (update, includeIgnore) {\n\t    includeIgnore = includeIgnore || false;\n\t\n\t    if (update) {\n\t      this.updateDisplayList(includeIgnore);\n\t    }\n\t\n\t    return this._displayList;\n\t  },\n\t\n\t  /**\n\t   * 更新图形的绘制队列。\n\t   * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\n\t   * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\n\t   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\n\t   */\n\t  updateDisplayList: function (includeIgnore) {\n\t    this._displayListLen = 0;\n\t    var roots = this._roots;\n\t    var displayList = this._displayList;\n\t\n\t    for (var i = 0, len = roots.length; i < len; i++) {\n\t      this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n\t    }\n\t\n\t    displayList.length = this._displayListLen; // for (var i = 0, len = displayList.length; i < len; i++) {\n\t    //     displayList[i].__renderidx = i;\n\t    // }\n\t    // displayList.sort(shapeCompareFunc);\n\t\n\t    env.canvasSupported && timsort(displayList, shapeCompareFunc);\n\t  },\n\t  _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\t    if (el.ignore && !includeIgnore) {\n\t      return;\n\t    }\n\t\n\t    el.beforeUpdate();\n\t\n\t    if (el.__dirty) {\n\t      el.update();\n\t    }\n\t\n\t    el.afterUpdate();\n\t    var userSetClipPath = el.clipPath;\n\t\n\t    if (userSetClipPath) {\n\t      // FIXME 效率影响\n\t      if (clipPaths) {\n\t        clipPaths = clipPaths.slice();\n\t      } else {\n\t        clipPaths = [];\n\t      }\n\t\n\t      var currentClipPath = userSetClipPath;\n\t      var parentClipPath = el; // Recursively add clip path\n\t\n\t      while (currentClipPath) {\n\t        // clipPath 的变换是基于使用这个 clipPath 的元素\n\t        currentClipPath.parent = parentClipPath;\n\t        currentClipPath.updateTransform();\n\t        clipPaths.push(currentClipPath);\n\t        parentClipPath = currentClipPath;\n\t        currentClipPath = currentClipPath.clipPath;\n\t      }\n\t    }\n\t\n\t    if (el.isGroup) {\n\t      var children = el._children;\n\t\n\t      for (var i = 0; i < children.length; i++) {\n\t        var child = children[i]; // Force to mark as dirty if group is dirty\n\t        // FIXME __dirtyPath ?\n\t\n\t        if (el.__dirty) {\n\t          child.__dirty = true;\n\t        }\n\t\n\t        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n\t      } // Mark group clean here\n\t\n\t\n\t      el.__dirty = false;\n\t    } else {\n\t      el.__clipPaths = clipPaths;\n\t      this._displayList[this._displayListLen++] = el;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 添加图形(Shape)或者组(Group)到根节点\n\t   * @param {module:zrender/Element} el\n\t   */\n\t  addRoot: function (el) {\n\t    if (el.__storage === this) {\n\t      return;\n\t    }\n\t\n\t    if (el instanceof Group) {\n\t      el.addChildrenToStorage(this);\n\t    }\n\t\n\t    this.addToStorage(el);\n\t\n\t    this._roots.push(el);\n\t  },\n\t\n\t  /**\n\t   * 删除指定的图形(Shape)或者组(Group)\n\t   * @param {string|Array.<string>} [el] 如果为空清空整个Storage\n\t   */\n\t  delRoot: function (el) {\n\t    if (el == null) {\n\t      // 不指定el清空\n\t      for (var i = 0; i < this._roots.length; i++) {\n\t        var root = this._roots[i];\n\t\n\t        if (root instanceof Group) {\n\t          root.delChildrenFromStorage(this);\n\t        }\n\t      }\n\t\n\t      this._roots = [];\n\t      this._displayList = [];\n\t      this._displayListLen = 0;\n\t      return;\n\t    }\n\t\n\t    if (el instanceof Array) {\n\t      for (var i = 0, l = el.length; i < l; i++) {\n\t        this.delRoot(el[i]);\n\t      }\n\t\n\t      return;\n\t    }\n\t\n\t    var idx = util.indexOf(this._roots, el);\n\t\n\t    if (idx >= 0) {\n\t      this.delFromStorage(el);\n\t\n\t      this._roots.splice(idx, 1);\n\t\n\t      if (el instanceof Group) {\n\t        el.delChildrenFromStorage(this);\n\t      }\n\t    }\n\t  },\n\t  addToStorage: function (el) {\n\t    el.__storage = this;\n\t    el.dirty(false);\n\t    return this;\n\t  },\n\t  delFromStorage: function (el) {\n\t    if (el) {\n\t      el.__storage = null;\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 清空并且释放Storage\n\t   */\n\t  dispose: function () {\n\t    this._renderList = this._roots = null;\n\t  },\n\t  displayableSortFunc: shapeCompareFunc\n\t};\n\tvar _default = Storage;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports) {\n\n\t// https://github.com/mziccard/node-timsort\n\tvar DEFAULT_MIN_MERGE = 32;\n\tvar DEFAULT_MIN_GALLOPING = 7;\n\tvar DEFAULT_TMP_STORAGE_LENGTH = 256;\n\t\n\tfunction minRunLength(n) {\n\t  var r = 0;\n\t\n\t  while (n >= DEFAULT_MIN_MERGE) {\n\t    r |= n & 1;\n\t    n >>= 1;\n\t  }\n\t\n\t  return n + r;\n\t}\n\t\n\tfunction makeAscendingRun(array, lo, hi, compare) {\n\t  var runHi = lo + 1;\n\t\n\t  if (runHi === hi) {\n\t    return 1;\n\t  }\n\t\n\t  if (compare(array[runHi++], array[lo]) < 0) {\n\t    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n\t      runHi++;\n\t    }\n\t\n\t    reverseRun(array, lo, runHi);\n\t  } else {\n\t    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n\t      runHi++;\n\t    }\n\t  }\n\t\n\t  return runHi - lo;\n\t}\n\t\n\tfunction reverseRun(array, lo, hi) {\n\t  hi--;\n\t\n\t  while (lo < hi) {\n\t    var t = array[lo];\n\t    array[lo++] = array[hi];\n\t    array[hi--] = t;\n\t  }\n\t}\n\t\n\tfunction binaryInsertionSort(array, lo, hi, start, compare) {\n\t  if (start === lo) {\n\t    start++;\n\t  }\n\t\n\t  for (; start < hi; start++) {\n\t    var pivot = array[start];\n\t    var left = lo;\n\t    var right = start;\n\t    var mid;\n\t\n\t    while (left < right) {\n\t      mid = left + right >>> 1;\n\t\n\t      if (compare(pivot, array[mid]) < 0) {\n\t        right = mid;\n\t      } else {\n\t        left = mid + 1;\n\t      }\n\t    }\n\t\n\t    var n = start - left;\n\t\n\t    switch (n) {\n\t      case 3:\n\t        array[left + 3] = array[left + 2];\n\t\n\t      case 2:\n\t        array[left + 2] = array[left + 1];\n\t\n\t      case 1:\n\t        array[left + 1] = array[left];\n\t        break;\n\t\n\t      default:\n\t        while (n > 0) {\n\t          array[left + n] = array[left + n - 1];\n\t          n--;\n\t        }\n\t\n\t    }\n\t\n\t    array[left] = pivot;\n\t  }\n\t}\n\t\n\tfunction gallopLeft(value, array, start, length, hint, compare) {\n\t  var lastOffset = 0;\n\t  var maxOffset = 0;\n\t  var offset = 1;\n\t\n\t  if (compare(value, array[start + hint]) > 0) {\n\t    maxOffset = length - hint;\n\t\n\t    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n\t      lastOffset = offset;\n\t      offset = (offset << 1) + 1;\n\t\n\t      if (offset <= 0) {\n\t        offset = maxOffset;\n\t      }\n\t    }\n\t\n\t    if (offset > maxOffset) {\n\t      offset = maxOffset;\n\t    }\n\t\n\t    lastOffset += hint;\n\t    offset += hint;\n\t  } else {\n\t    maxOffset = hint + 1;\n\t\n\t    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n\t      lastOffset = offset;\n\t      offset = (offset << 1) + 1;\n\t\n\t      if (offset <= 0) {\n\t        offset = maxOffset;\n\t      }\n\t    }\n\t\n\t    if (offset > maxOffset) {\n\t      offset = maxOffset;\n\t    }\n\t\n\t    var tmp = lastOffset;\n\t    lastOffset = hint - offset;\n\t    offset = hint - tmp;\n\t  }\n\t\n\t  lastOffset++;\n\t\n\t  while (lastOffset < offset) {\n\t    var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t    if (compare(value, array[start + m]) > 0) {\n\t      lastOffset = m + 1;\n\t    } else {\n\t      offset = m;\n\t    }\n\t  }\n\t\n\t  return offset;\n\t}\n\t\n\tfunction gallopRight(value, array, start, length, hint, compare) {\n\t  var lastOffset = 0;\n\t  var maxOffset = 0;\n\t  var offset = 1;\n\t\n\t  if (compare(value, array[start + hint]) < 0) {\n\t    maxOffset = hint + 1;\n\t\n\t    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n\t      lastOffset = offset;\n\t      offset = (offset << 1) + 1;\n\t\n\t      if (offset <= 0) {\n\t        offset = maxOffset;\n\t      }\n\t    }\n\t\n\t    if (offset > maxOffset) {\n\t      offset = maxOffset;\n\t    }\n\t\n\t    var tmp = lastOffset;\n\t    lastOffset = hint - offset;\n\t    offset = hint - tmp;\n\t  } else {\n\t    maxOffset = length - hint;\n\t\n\t    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n\t      lastOffset = offset;\n\t      offset = (offset << 1) + 1;\n\t\n\t      if (offset <= 0) {\n\t        offset = maxOffset;\n\t      }\n\t    }\n\t\n\t    if (offset > maxOffset) {\n\t      offset = maxOffset;\n\t    }\n\t\n\t    lastOffset += hint;\n\t    offset += hint;\n\t  }\n\t\n\t  lastOffset++;\n\t\n\t  while (lastOffset < offset) {\n\t    var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t    if (compare(value, array[start + m]) < 0) {\n\t      offset = m;\n\t    } else {\n\t      lastOffset = m + 1;\n\t    }\n\t  }\n\t\n\t  return offset;\n\t}\n\t\n\tfunction TimSort(array, compare) {\n\t  var minGallop = DEFAULT_MIN_GALLOPING;\n\t  var length = 0;\n\t  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n\t  var stackLength = 0;\n\t  var runStart;\n\t  var runLength;\n\t  var stackSize = 0;\n\t  length = array.length;\n\t\n\t  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n\t    tmpStorageLength = length >>> 1;\n\t  }\n\t\n\t  var tmp = [];\n\t  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\t  runStart = [];\n\t  runLength = [];\n\t\n\t  function pushRun(_runStart, _runLength) {\n\t    runStart[stackSize] = _runStart;\n\t    runLength[stackSize] = _runLength;\n\t    stackSize += 1;\n\t  }\n\t\n\t  function mergeRuns() {\n\t    while (stackSize > 1) {\n\t      var n = stackSize - 2;\n\t\n\t      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n\t        if (runLength[n - 1] < runLength[n + 1]) {\n\t          n--;\n\t        }\n\t      } else if (runLength[n] > runLength[n + 1]) {\n\t        break;\n\t      }\n\t\n\t      mergeAt(n);\n\t    }\n\t  }\n\t\n\t  function forceMergeRuns() {\n\t    while (stackSize > 1) {\n\t      var n = stackSize - 2;\n\t\n\t      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n\t        n--;\n\t      }\n\t\n\t      mergeAt(n);\n\t    }\n\t  }\n\t\n\t  function mergeAt(i) {\n\t    var start1 = runStart[i];\n\t    var length1 = runLength[i];\n\t    var start2 = runStart[i + 1];\n\t    var length2 = runLength[i + 1];\n\t    runLength[i] = length1 + length2;\n\t\n\t    if (i === stackSize - 3) {\n\t      runStart[i + 1] = runStart[i + 2];\n\t      runLength[i + 1] = runLength[i + 2];\n\t    }\n\t\n\t    stackSize--;\n\t    var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n\t    start1 += k;\n\t    length1 -= k;\n\t\n\t    if (length1 === 0) {\n\t      return;\n\t    }\n\t\n\t    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\t\n\t    if (length2 === 0) {\n\t      return;\n\t    }\n\t\n\t    if (length1 <= length2) {\n\t      mergeLow(start1, length1, start2, length2);\n\t    } else {\n\t      mergeHigh(start1, length1, start2, length2);\n\t    }\n\t  }\n\t\n\t  function mergeLow(start1, length1, start2, length2) {\n\t    var i = 0;\n\t\n\t    for (i = 0; i < length1; i++) {\n\t      tmp[i] = array[start1 + i];\n\t    }\n\t\n\t    var cursor1 = 0;\n\t    var cursor2 = start2;\n\t    var dest = start1;\n\t    array[dest++] = array[cursor2++];\n\t\n\t    if (--length2 === 0) {\n\t      for (i = 0; i < length1; i++) {\n\t        array[dest + i] = tmp[cursor1 + i];\n\t      }\n\t\n\t      return;\n\t    }\n\t\n\t    if (length1 === 1) {\n\t      for (i = 0; i < length2; i++) {\n\t        array[dest + i] = array[cursor2 + i];\n\t      }\n\t\n\t      array[dest + length2] = tmp[cursor1];\n\t      return;\n\t    }\n\t\n\t    var _minGallop = minGallop;\n\t    var count1, count2, exit;\n\t\n\t    while (1) {\n\t      count1 = 0;\n\t      count2 = 0;\n\t      exit = false;\n\t\n\t      do {\n\t        if (compare(array[cursor2], tmp[cursor1]) < 0) {\n\t          array[dest++] = array[cursor2++];\n\t          count2++;\n\t          count1 = 0;\n\t\n\t          if (--length2 === 0) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        } else {\n\t          array[dest++] = tmp[cursor1++];\n\t          count1++;\n\t          count2 = 0;\n\t\n\t          if (--length1 === 1) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t      } while ((count1 | count2) < _minGallop);\n\t\n\t      if (exit) {\n\t        break;\n\t      }\n\t\n\t      do {\n\t        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\t\n\t        if (count1 !== 0) {\n\t          for (i = 0; i < count1; i++) {\n\t            array[dest + i] = tmp[cursor1 + i];\n\t          }\n\t\n\t          dest += count1;\n\t          cursor1 += count1;\n\t          length1 -= count1;\n\t\n\t          if (length1 <= 1) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t\n\t        array[dest++] = array[cursor2++];\n\t\n\t        if (--length2 === 0) {\n\t          exit = true;\n\t          break;\n\t        }\n\t\n\t        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\t\n\t        if (count2 !== 0) {\n\t          for (i = 0; i < count2; i++) {\n\t            array[dest + i] = array[cursor2 + i];\n\t          }\n\t\n\t          dest += count2;\n\t          cursor2 += count2;\n\t          length2 -= count2;\n\t\n\t          if (length2 === 0) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t\n\t        array[dest++] = tmp[cursor1++];\n\t\n\t        if (--length1 === 1) {\n\t          exit = true;\n\t          break;\n\t        }\n\t\n\t        _minGallop--;\n\t      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t      if (exit) {\n\t        break;\n\t      }\n\t\n\t      if (_minGallop < 0) {\n\t        _minGallop = 0;\n\t      }\n\t\n\t      _minGallop += 2;\n\t    }\n\t\n\t    minGallop = _minGallop;\n\t    minGallop < 1 && (minGallop = 1);\n\t\n\t    if (length1 === 1) {\n\t      for (i = 0; i < length2; i++) {\n\t        array[dest + i] = array[cursor2 + i];\n\t      }\n\t\n\t      array[dest + length2] = tmp[cursor1];\n\t    } else if (length1 === 0) {\n\t      throw new Error(); // throw new Error('mergeLow preconditions were not respected');\n\t    } else {\n\t      for (i = 0; i < length1; i++) {\n\t        array[dest + i] = tmp[cursor1 + i];\n\t      }\n\t    }\n\t  }\n\t\n\t  function mergeHigh(start1, length1, start2, length2) {\n\t    var i = 0;\n\t\n\t    for (i = 0; i < length2; i++) {\n\t      tmp[i] = array[start2 + i];\n\t    }\n\t\n\t    var cursor1 = start1 + length1 - 1;\n\t    var cursor2 = length2 - 1;\n\t    var dest = start2 + length2 - 1;\n\t    var customCursor = 0;\n\t    var customDest = 0;\n\t    array[dest--] = array[cursor1--];\n\t\n\t    if (--length1 === 0) {\n\t      customCursor = dest - (length2 - 1);\n\t\n\t      for (i = 0; i < length2; i++) {\n\t        array[customCursor + i] = tmp[i];\n\t      }\n\t\n\t      return;\n\t    }\n\t\n\t    if (length2 === 1) {\n\t      dest -= length1;\n\t      cursor1 -= length1;\n\t      customDest = dest + 1;\n\t      customCursor = cursor1 + 1;\n\t\n\t      for (i = length1 - 1; i >= 0; i--) {\n\t        array[customDest + i] = array[customCursor + i];\n\t      }\n\t\n\t      array[dest] = tmp[cursor2];\n\t      return;\n\t    }\n\t\n\t    var _minGallop = minGallop;\n\t\n\t    while (true) {\n\t      var count1 = 0;\n\t      var count2 = 0;\n\t      var exit = false;\n\t\n\t      do {\n\t        if (compare(tmp[cursor2], array[cursor1]) < 0) {\n\t          array[dest--] = array[cursor1--];\n\t          count1++;\n\t          count2 = 0;\n\t\n\t          if (--length1 === 0) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        } else {\n\t          array[dest--] = tmp[cursor2--];\n\t          count2++;\n\t          count1 = 0;\n\t\n\t          if (--length2 === 1) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t      } while ((count1 | count2) < _minGallop);\n\t\n\t      if (exit) {\n\t        break;\n\t      }\n\t\n\t      do {\n\t        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\t\n\t        if (count1 !== 0) {\n\t          dest -= count1;\n\t          cursor1 -= count1;\n\t          length1 -= count1;\n\t          customDest = dest + 1;\n\t          customCursor = cursor1 + 1;\n\t\n\t          for (i = count1 - 1; i >= 0; i--) {\n\t            array[customDest + i] = array[customCursor + i];\n\t          }\n\t\n\t          if (length1 === 0) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t\n\t        array[dest--] = tmp[cursor2--];\n\t\n\t        if (--length2 === 1) {\n\t          exit = true;\n\t          break;\n\t        }\n\t\n\t        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\t\n\t        if (count2 !== 0) {\n\t          dest -= count2;\n\t          cursor2 -= count2;\n\t          length2 -= count2;\n\t          customDest = dest + 1;\n\t          customCursor = cursor2 + 1;\n\t\n\t          for (i = 0; i < count2; i++) {\n\t            array[customDest + i] = tmp[customCursor + i];\n\t          }\n\t\n\t          if (length2 <= 1) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t\n\t        array[dest--] = array[cursor1--];\n\t\n\t        if (--length1 === 0) {\n\t          exit = true;\n\t          break;\n\t        }\n\t\n\t        _minGallop--;\n\t      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t      if (exit) {\n\t        break;\n\t      }\n\t\n\t      if (_minGallop < 0) {\n\t        _minGallop = 0;\n\t      }\n\t\n\t      _minGallop += 2;\n\t    }\n\t\n\t    minGallop = _minGallop;\n\t\n\t    if (minGallop < 1) {\n\t      minGallop = 1;\n\t    }\n\t\n\t    if (length2 === 1) {\n\t      dest -= length1;\n\t      cursor1 -= length1;\n\t      customDest = dest + 1;\n\t      customCursor = cursor1 + 1;\n\t\n\t      for (i = length1 - 1; i >= 0; i--) {\n\t        array[customDest + i] = array[customCursor + i];\n\t      }\n\t\n\t      array[dest] = tmp[cursor2];\n\t    } else if (length2 === 0) {\n\t      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');\n\t    } else {\n\t      customCursor = dest - (length2 - 1);\n\t\n\t      for (i = 0; i < length2; i++) {\n\t        array[customCursor + i] = tmp[i];\n\t      }\n\t    }\n\t  }\n\t\n\t  this.mergeRuns = mergeRuns;\n\t  this.forceMergeRuns = forceMergeRuns;\n\t  this.pushRun = pushRun;\n\t}\n\t\n\tfunction sort(array, compare, lo, hi) {\n\t  if (!lo) {\n\t    lo = 0;\n\t  }\n\t\n\t  if (!hi) {\n\t    hi = array.length;\n\t  }\n\t\n\t  var remaining = hi - lo;\n\t\n\t  if (remaining < 2) {\n\t    return;\n\t  }\n\t\n\t  var runLength = 0;\n\t\n\t  if (remaining < DEFAULT_MIN_MERGE) {\n\t    runLength = makeAscendingRun(array, lo, hi, compare);\n\t    binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n\t    return;\n\t  }\n\t\n\t  var ts = new TimSort(array, compare);\n\t  var minRun = minRunLength(remaining);\n\t\n\t  do {\n\t    runLength = makeAscendingRun(array, lo, hi, compare);\n\t\n\t    if (runLength < minRun) {\n\t      var force = remaining;\n\t\n\t      if (force > minRun) {\n\t        force = minRun;\n\t      }\n\t\n\t      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n\t      runLength = force;\n\t    }\n\t\n\t    ts.pushRun(lo, runLength);\n\t    ts.mergeRuns();\n\t    remaining -= runLength;\n\t    lo += runLength;\n\t  } while (remaining !== 0);\n\t\n\t  ts.forceMergeRuns();\n\t}\n\t\n\tmodule.exports = sort;\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _config = __webpack_require__(23);\n\t\n\tvar devicePixelRatio = _config.devicePixelRatio;\n\t\n\tvar util = __webpack_require__(5);\n\t\n\tvar log = __webpack_require__(22);\n\t\n\tvar BoundingRect = __webpack_require__(27);\n\t\n\tvar timsort = __webpack_require__(72);\n\t\n\tvar Layer = __webpack_require__(74);\n\t\n\tvar requestAnimationFrame = __webpack_require__(75);\n\t\n\tvar Image = __webpack_require__(45);\n\t\n\t/**\n\t * Default canvas painter\n\t * @module zrender/Painter\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t// PENDIGN\n\t// Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n\t//\n\t// Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n\tvar MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\t\n\tfunction parseInt10(val) {\n\t  return parseInt(val, 10);\n\t}\n\t\n\tfunction isLayerValid(layer) {\n\t  if (!layer) {\n\t    return false;\n\t  }\n\t\n\t  if (layer.__builtin__) {\n\t    return true;\n\t  }\n\t\n\t  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n\t    return false;\n\t  }\n\t\n\t  return true;\n\t}\n\t\n\tfunction preProcessLayer(layer) {\n\t  layer.__unusedCount++;\n\t}\n\t\n\tfunction postProcessLayer(layer) {\n\t  if (layer.__unusedCount == 1) {\n\t    layer.clear();\n\t  }\n\t}\n\t\n\tvar tmpRect = new BoundingRect(0, 0, 0, 0);\n\tvar viewRect = new BoundingRect(0, 0, 0, 0);\n\t\n\tfunction isDisplayableCulled(el, width, height) {\n\t  tmpRect.copy(el.getBoundingRect());\n\t\n\t  if (el.transform) {\n\t    tmpRect.applyTransform(el.transform);\n\t  }\n\t\n\t  viewRect.width = width;\n\t  viewRect.height = height;\n\t  return !tmpRect.intersect(viewRect);\n\t}\n\t\n\tfunction isClipPathChanged(clipPaths, prevClipPaths) {\n\t  if (clipPaths == prevClipPaths) {\n\t    // Can both be null or undefined\n\t    return false;\n\t  }\n\t\n\t  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n\t    return true;\n\t  }\n\t\n\t  for (var i = 0; i < clipPaths.length; i++) {\n\t    if (clipPaths[i] !== prevClipPaths[i]) {\n\t      return true;\n\t    }\n\t  }\n\t}\n\t\n\tfunction doClip(clipPaths, ctx) {\n\t  for (var i = 0; i < clipPaths.length; i++) {\n\t    var clipPath = clipPaths[i];\n\t    clipPath.setTransform(ctx);\n\t    ctx.beginPath();\n\t    clipPath.buildPath(ctx, clipPath.shape);\n\t    ctx.clip(); // Transform back\n\t\n\t    clipPath.restoreTransform(ctx);\n\t  }\n\t}\n\t\n\tfunction createRoot(width, height) {\n\t  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n\t\n\t  domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';\n\t  return domRoot;\n\t}\n\t/**\n\t * @alias module:zrender/Painter\n\t * @constructor\n\t * @param {HTMLElement} root 绘图容器\n\t * @param {module:zrender/Storage} storage\n\t * @param {Object} opts\n\t */\n\t\n\t\n\tvar Painter = function (root, storage, opts) {\n\t  this.type = 'canvas'; // In node environment using node-canvas\n\t\n\t  var singleCanvas = !root.nodeName // In node ?\n\t  || root.nodeName.toUpperCase() === 'CANVAS';\n\t  this._opts = opts = util.extend({}, opts || {});\n\t  /**\n\t   * @type {number}\n\t   */\n\t\n\t  this.dpr = opts.devicePixelRatio || devicePixelRatio;\n\t  /**\n\t   * @type {boolean}\n\t   * @private\n\t   */\n\t\n\t  this._singleCanvas = singleCanvas;\n\t  /**\n\t   * 绘图容器\n\t   * @type {HTMLElement}\n\t   */\n\t\n\t  this.root = root;\n\t  var rootStyle = root.style;\n\t\n\t  if (rootStyle) {\n\t    rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n\t    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n\t    root.innerHTML = '';\n\t  }\n\t  /**\n\t   * @type {module:zrender/Storage}\n\t   */\n\t\n\t\n\t  this.storage = storage;\n\t  /**\n\t   * @type {Array.<number>}\n\t   * @private\n\t   */\n\t\n\t  var zlevelList = this._zlevelList = [];\n\t  /**\n\t   * @type {Object.<string, module:zrender/Layer>}\n\t   * @private\n\t   */\n\t\n\t  var layers = this._layers = {};\n\t  /**\n\t   * @type {Object.<string, Object>}\n\t   * @type {private}\n\t   */\n\t\n\t  this._layerConfig = {};\n\t\n\t  if (!singleCanvas) {\n\t    this._width = this._getSize(0);\n\t    this._height = this._getSize(1);\n\t    var domRoot = this._domRoot = createRoot(this._width, this._height);\n\t    root.appendChild(domRoot);\n\t  } else {\n\t    if (opts.width != null) {\n\t      root.width = opts.width;\n\t    }\n\t\n\t    if (opts.height != null) {\n\t      root.height = opts.height;\n\t    } // Use canvas width and height directly\n\t\n\t\n\t    var width = root.width;\n\t    var height = root.height;\n\t    this._width = width;\n\t    this._height = height; // Create layer if only one given canvas\n\t    // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\t\n\t    var mainLayer = new Layer(root, this, 1);\n\t    mainLayer.initContext(); // FIXME Use canvas width and height\n\t    // mainLayer.resize(width, height);\n\t\n\t    layers[0] = mainLayer;\n\t    zlevelList.push(0);\n\t    this._domRoot = root;\n\t  } // Layers for progressive rendering\n\t\n\t\n\t  this._progressiveLayers = [];\n\t  /**\n\t   * @type {module:zrender/Layer}\n\t   * @private\n\t   */\n\t\n\t  this._hoverlayer;\n\t  this._hoverElements = [];\n\t};\n\t\n\tPainter.prototype = {\n\t  constructor: Painter,\n\t  getType: function () {\n\t    return 'canvas';\n\t  },\n\t\n\t  /**\n\t   * If painter use a single canvas\n\t   * @return {boolean}\n\t   */\n\t  isSingleCanvas: function () {\n\t    return this._singleCanvas;\n\t  },\n\t\n\t  /**\n\t   * @return {HTMLDivElement}\n\t   */\n\t  getViewportRoot: function () {\n\t    return this._domRoot;\n\t  },\n\t  getViewportRootOffset: function () {\n\t    var viewportRoot = this.getViewportRoot();\n\t\n\t    if (viewportRoot) {\n\t      return {\n\t        offsetLeft: viewportRoot.offsetLeft || 0,\n\t        offsetTop: viewportRoot.offsetTop || 0\n\t      };\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 刷新\n\t   * @param {boolean} [paintAll=false] 强制绘制所有displayable\n\t   */\n\t  refresh: function (paintAll) {\n\t    var list = this.storage.getDisplayList(true);\n\t    var zlevelList = this._zlevelList;\n\t\n\t    this._paintList(list, paintAll); // Paint custum layers\n\t\n\t\n\t    for (var i = 0; i < zlevelList.length; i++) {\n\t      var z = zlevelList[i];\n\t      var layer = this._layers[z];\n\t\n\t      if (!layer.__builtin__ && layer.refresh) {\n\t        layer.refresh();\n\t      }\n\t    }\n\t\n\t    this.refreshHover();\n\t\n\t    if (this._progressiveLayers.length) {\n\t      this._startProgessive();\n\t    }\n\t\n\t    return this;\n\t  },\n\t  addHover: function (el, hoverStyle) {\n\t    if (el.__hoverMir) {\n\t      return;\n\t    }\n\t\n\t    var elMirror = new el.constructor({\n\t      style: el.style,\n\t      shape: el.shape\n\t    });\n\t    elMirror.__from = el;\n\t    el.__hoverMir = elMirror;\n\t    elMirror.setStyle(hoverStyle);\n\t\n\t    this._hoverElements.push(elMirror);\n\t  },\n\t  removeHover: function (el) {\n\t    var elMirror = el.__hoverMir;\n\t    var hoverElements = this._hoverElements;\n\t    var idx = util.indexOf(hoverElements, elMirror);\n\t\n\t    if (idx >= 0) {\n\t      hoverElements.splice(idx, 1);\n\t    }\n\t\n\t    el.__hoverMir = null;\n\t  },\n\t  clearHover: function (el) {\n\t    var hoverElements = this._hoverElements;\n\t\n\t    for (var i = 0; i < hoverElements.length; i++) {\n\t      var from = hoverElements[i].__from;\n\t\n\t      if (from) {\n\t        from.__hoverMir = null;\n\t      }\n\t    }\n\t\n\t    hoverElements.length = 0;\n\t  },\n\t  refreshHover: function () {\n\t    var hoverElements = this._hoverElements;\n\t    var len = hoverElements.length;\n\t    var hoverLayer = this._hoverlayer;\n\t    hoverLayer && hoverLayer.clear();\n\t\n\t    if (!len) {\n\t      return;\n\t    }\n\t\n\t    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel\n\t    // FIXME?\n\t\n\t    if (!hoverLayer) {\n\t      hoverLayer = this._hoverlayer = this.getLayer(1e5);\n\t    }\n\t\n\t    var scope = {};\n\t    hoverLayer.ctx.save();\n\t\n\t    for (var i = 0; i < len;) {\n\t      var el = hoverElements[i];\n\t      var originalEl = el.__from; // Original el is removed\n\t      // PENDING\n\t\n\t      if (!(originalEl && originalEl.__zr)) {\n\t        hoverElements.splice(i, 1);\n\t        originalEl.__hoverMir = null;\n\t        len--;\n\t        continue;\n\t      }\n\t\n\t      i++; // Use transform\n\t      // FIXME style and shape ?\n\t\n\t      if (!originalEl.invisible) {\n\t        el.transform = originalEl.transform;\n\t        el.invTransform = originalEl.invTransform;\n\t        el.__clipPaths = originalEl.__clipPaths; // el.\n\t\n\t        this._doPaintEl(el, hoverLayer, true, scope);\n\t      }\n\t    }\n\t\n\t    hoverLayer.ctx.restore();\n\t  },\n\t  _startProgessive: function () {\n\t    var self = this;\n\t\n\t    if (!self._furtherProgressive) {\n\t      return;\n\t    } // Use a token to stop progress steps triggered by\n\t    // previous zr.refresh calling.\n\t\n\t\n\t    var token = self._progressiveToken = +new Date();\n\t    self._progress++;\n\t    requestAnimationFrame(step);\n\t\n\t    function step() {\n\t      // In case refreshed or disposed\n\t      if (token === self._progressiveToken && self.storage) {\n\t        self._doPaintList(self.storage.getDisplayList());\n\t\n\t        if (self._furtherProgressive) {\n\t          self._progress++;\n\t          requestAnimationFrame(step);\n\t        } else {\n\t          self._progressiveToken = -1;\n\t        }\n\t      }\n\t    }\n\t  },\n\t  _clearProgressive: function () {\n\t    this._progressiveToken = -1;\n\t    this._progress = 0;\n\t    util.each(this._progressiveLayers, function (layer) {\n\t      layer.__dirty && layer.clear();\n\t    });\n\t  },\n\t  _paintList: function (list, paintAll) {\n\t    if (paintAll == null) {\n\t      paintAll = false;\n\t    }\n\t\n\t    this._updateLayerStatus(list);\n\t\n\t    this._clearProgressive();\n\t\n\t    this.eachBuiltinLayer(preProcessLayer);\n\t\n\t    this._doPaintList(list, paintAll);\n\t\n\t    this.eachBuiltinLayer(postProcessLayer);\n\t  },\n\t  _doPaintList: function (list, paintAll) {\n\t    var currentLayer;\n\t    var currentZLevel;\n\t    var ctx; // var invTransform = [];\n\t\n\t    var scope;\n\t    var progressiveLayerIdx = 0;\n\t    var currentProgressiveLayer;\n\t    var width = this._width;\n\t    var height = this._height;\n\t    var layerProgress;\n\t    var frame = this._progress;\n\t\n\t    function flushProgressiveLayer(layer) {\n\t      var dpr = ctx.dpr || 1;\n\t      ctx.save();\n\t      ctx.globalAlpha = 1;\n\t      ctx.shadowBlur = 0; // Avoid layer don't clear in next progressive frame\n\t\n\t      currentLayer.__dirty = true;\n\t      ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t      ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n\t      ctx.restore();\n\t    }\n\t\n\t    for (var i = 0, l = list.length; i < l; i++) {\n\t      var el = list[i];\n\t      var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\t      var elFrame = el.__frame; // Flush at current context\n\t      // PENDING\n\t\n\t      if (elFrame < 0 && currentProgressiveLayer) {\n\t        flushProgressiveLayer(currentProgressiveLayer);\n\t        currentProgressiveLayer = null;\n\t      } // Change draw layer\n\t\n\t\n\t      if (currentZLevel !== elZLevel) {\n\t        if (ctx) {\n\t          ctx.restore();\n\t        } // Reset scope\n\t\n\t\n\t        scope = {}; // Only 0 zlevel if only has one canvas\n\t\n\t        currentZLevel = elZLevel;\n\t        currentLayer = this.getLayer(currentZLevel);\n\t\n\t        if (!currentLayer.__builtin__) {\n\t          log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);\n\t        }\n\t\n\t        ctx = currentLayer.ctx;\n\t        ctx.save(); // Reset the count\n\t\n\t        currentLayer.__unusedCount = 0;\n\t\n\t        if (currentLayer.__dirty || paintAll) {\n\t          currentLayer.clear();\n\t        }\n\t      }\n\t\n\t      if (!(currentLayer.__dirty || paintAll)) {\n\t        continue;\n\t      }\n\t\n\t      if (elFrame >= 0) {\n\t        // Progressive layer changed\n\t        if (!currentProgressiveLayer) {\n\t          currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];\n\t          currentProgressiveLayer.ctx.save();\n\t          currentProgressiveLayer.renderScope = {};\n\t\n\t          if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {\n\t            // flushProgressiveLayer(currentProgressiveLayer);\n\t            // Quick jump all progressive elements\n\t            // All progressive element are not dirty, jump over and flush directly\n\t            i = currentProgressiveLayer.__nextIdxNotProg - 1; // currentProgressiveLayer = null;\n\t\n\t            continue;\n\t          }\n\t\n\t          layerProgress = currentProgressiveLayer.__progress;\n\t\n\t          if (!currentProgressiveLayer.__dirty) {\n\t            // Keep rendering\n\t            frame = layerProgress;\n\t          }\n\t\n\t          currentProgressiveLayer.__progress = frame + 1;\n\t        }\n\t\n\t        if (elFrame === frame) {\n\t          this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n\t        }\n\t      } else {\n\t        this._doPaintEl(el, currentLayer, paintAll, scope);\n\t      }\n\t\n\t      el.__dirty = false;\n\t    }\n\t\n\t    if (currentProgressiveLayer) {\n\t      flushProgressiveLayer(currentProgressiveLayer);\n\t    } // Restore the lastLayer ctx\n\t\n\t\n\t    ctx && ctx.restore(); // If still has clipping state\n\t    // if (scope.prevElClipPaths) {\n\t    //     ctx.restore();\n\t    // }\n\t\n\t    this._furtherProgressive = false;\n\t    util.each(this._progressiveLayers, function (layer) {\n\t      if (layer.__maxProgress >= layer.__progress) {\n\t        this._furtherProgressive = true;\n\t      }\n\t    }, this);\n\t  },\n\t  _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n\t    var ctx = currentLayer.ctx;\n\t    var m = el.transform;\n\t\n\t    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element\n\t    !el.invisible // Ignore transparent element\n\t    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas\n\t    // Draw a scale 0 element can cause all following draw wrong\n\t    // And setTransform with scale 0 will cause set back transform failed.\n\t    && !(m && !m[0] && !m[3]) // Ignore culled element\n\t    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n\t      var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements\n\t\n\t      if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {\n\t        // If has previous clipping state, restore from it\n\t        if (scope.prevElClipPaths) {\n\t          scope.prevClipLayer.ctx.restore();\n\t          scope.prevClipLayer = scope.prevElClipPaths = null; // Reset prevEl since context has been restored\n\t\n\t          scope.prevEl = null;\n\t        } // New clipping state\n\t\n\t\n\t        if (clipPaths) {\n\t          ctx.save();\n\t          doClip(clipPaths, ctx);\n\t          scope.prevClipLayer = currentLayer;\n\t          scope.prevElClipPaths = clipPaths;\n\t        }\n\t      }\n\t\n\t      el.beforeBrush && el.beforeBrush(ctx);\n\t      el.brush(ctx, scope.prevEl || null);\n\t      scope.prevEl = el;\n\t      el.afterBrush && el.afterBrush(ctx);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n\t   * @param {number} zlevel\n\t   * @return {module:zrender/Layer}\n\t   */\n\t  getLayer: function (zlevel) {\n\t    if (this._singleCanvas) {\n\t      return this._layers[0];\n\t    }\n\t\n\t    var layer = this._layers[zlevel];\n\t\n\t    if (!layer) {\n\t      // Create a new layer\n\t      layer = new Layer('zr_' + zlevel, this, this.dpr);\n\t      layer.__builtin__ = true;\n\t\n\t      if (this._layerConfig[zlevel]) {\n\t        util.merge(layer, this._layerConfig[zlevel], true);\n\t      }\n\t\n\t      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document\n\t      // Or excanvas will get 0px clientWidth and clientHeight\n\t\n\t      layer.initContext();\n\t    }\n\t\n\t    return layer;\n\t  },\n\t  insertLayer: function (zlevel, layer) {\n\t    var layersMap = this._layers;\n\t    var zlevelList = this._zlevelList;\n\t    var len = zlevelList.length;\n\t    var prevLayer = null;\n\t    var i = -1;\n\t    var domRoot = this._domRoot;\n\t\n\t    if (layersMap[zlevel]) {\n\t      log('ZLevel ' + zlevel + ' has been used already');\n\t      return;\n\t    } // Check if is a valid layer\n\t\n\t\n\t    if (!isLayerValid(layer)) {\n\t      log('Layer of zlevel ' + zlevel + ' is not valid');\n\t      return;\n\t    }\n\t\n\t    if (len > 0 && zlevel > zlevelList[0]) {\n\t      for (i = 0; i < len - 1; i++) {\n\t        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n\t          break;\n\t        }\n\t      }\n\t\n\t      prevLayer = layersMap[zlevelList[i]];\n\t    }\n\t\n\t    zlevelList.splice(i + 1, 0, zlevel);\n\t    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.\n\t    // (It can be a WebGL layer and assigned to a ZImage element)\n\t    // But it still under management of zrender.\n\t\n\t    if (!layer.virtual) {\n\t      if (prevLayer) {\n\t        var prevDom = prevLayer.dom;\n\t\n\t        if (prevDom.nextSibling) {\n\t          domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n\t        } else {\n\t          domRoot.appendChild(layer.dom);\n\t        }\n\t      } else {\n\t        if (domRoot.firstChild) {\n\t          domRoot.insertBefore(layer.dom, domRoot.firstChild);\n\t        } else {\n\t          domRoot.appendChild(layer.dom);\n\t        }\n\t      }\n\t    }\n\t  },\n\t  // Iterate each layer\n\t  eachLayer: function (cb, context) {\n\t    var zlevelList = this._zlevelList;\n\t    var z;\n\t    var i;\n\t\n\t    for (i = 0; i < zlevelList.length; i++) {\n\t      z = zlevelList[i];\n\t      cb.call(context, this._layers[z], z);\n\t    }\n\t  },\n\t  // Iterate each buildin layer\n\t  eachBuiltinLayer: function (cb, context) {\n\t    var zlevelList = this._zlevelList;\n\t    var layer;\n\t    var z;\n\t    var i;\n\t\n\t    for (i = 0; i < zlevelList.length; i++) {\n\t      z = zlevelList[i];\n\t      layer = this._layers[z];\n\t\n\t      if (layer.__builtin__) {\n\t        cb.call(context, layer, z);\n\t      }\n\t    }\n\t  },\n\t  // Iterate each other layer except buildin layer\n\t  eachOtherLayer: function (cb, context) {\n\t    var zlevelList = this._zlevelList;\n\t    var layer;\n\t    var z;\n\t    var i;\n\t\n\t    for (i = 0; i < zlevelList.length; i++) {\n\t      z = zlevelList[i];\n\t      layer = this._layers[z];\n\t\n\t      if (!layer.__builtin__) {\n\t        cb.call(context, layer, z);\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 获取所有已创建的层\n\t   * @param {Array.<module:zrender/Layer>} [prevLayer]\n\t   */\n\t  getLayers: function () {\n\t    return this._layers;\n\t  },\n\t  _updateLayerStatus: function (list) {\n\t    var layers = this._layers;\n\t    var progressiveLayers = this._progressiveLayers;\n\t    var elCountsLastFrame = {};\n\t    var progressiveElCountsLastFrame = {};\n\t    this.eachBuiltinLayer(function (layer, z) {\n\t      elCountsLastFrame[z] = layer.elCount;\n\t      layer.elCount = 0;\n\t      layer.__dirty = false;\n\t    });\n\t    util.each(progressiveLayers, function (layer, idx) {\n\t      progressiveElCountsLastFrame[idx] = layer.elCount;\n\t      layer.elCount = 0;\n\t      layer.__dirty = false;\n\t    });\n\t    var progressiveLayerCount = 0;\n\t    var currentProgressiveLayer;\n\t    var lastProgressiveKey;\n\t    var frameCount = 0;\n\t\n\t    for (var i = 0, l = list.length; i < l; i++) {\n\t      var el = list[i];\n\t      var zlevel = this._singleCanvas ? 0 : el.zlevel;\n\t      var layer = layers[zlevel];\n\t      var elProgress = el.progressive;\n\t\n\t      if (layer) {\n\t        layer.elCount++;\n\t        layer.__dirty = layer.__dirty || el.__dirty;\n\t      } /////// Update progressive\n\t\n\t\n\t      if (elProgress >= 0) {\n\t        // Fix wrong progressive sequence problem.\n\t        if (lastProgressiveKey !== elProgress) {\n\t          lastProgressiveKey = elProgress;\n\t          frameCount++;\n\t        }\n\t\n\t        var elFrame = el.__frame = frameCount - 1;\n\t\n\t        if (!currentProgressiveLayer) {\n\t          var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n\t          currentProgressiveLayer = progressiveLayers[idx];\n\t\n\t          if (!currentProgressiveLayer) {\n\t            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);\n\t            currentProgressiveLayer.initContext();\n\t          }\n\t\n\t          currentProgressiveLayer.__maxProgress = 0;\n\t        }\n\t\n\t        currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n\t        currentProgressiveLayer.elCount++;\n\t        currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);\n\t\n\t        if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n\t          // Should keep rendering this  layer because progressive rendering is not finished yet\n\t          layer.__dirty = true;\n\t        }\n\t      } else {\n\t        el.__frame = -1;\n\t\n\t        if (currentProgressiveLayer) {\n\t          currentProgressiveLayer.__nextIdxNotProg = i;\n\t          progressiveLayerCount++;\n\t          currentProgressiveLayer = null;\n\t        }\n\t      }\n\t    }\n\t\n\t    if (currentProgressiveLayer) {\n\t      progressiveLayerCount++;\n\t      currentProgressiveLayer.__nextIdxNotProg = i;\n\t    } // 层中的元素数量有发生变化\n\t\n\t\n\t    this.eachBuiltinLayer(function (layer, z) {\n\t      if (elCountsLastFrame[z] !== layer.elCount) {\n\t        layer.__dirty = true;\n\t      }\n\t    });\n\t    progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n\t    util.each(progressiveLayers, function (layer, idx) {\n\t      if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n\t        el.__dirty = true;\n\t      }\n\t\n\t      if (layer.__dirty) {\n\t        layer.__progress = 0;\n\t      }\n\t    });\n\t  },\n\t\n\t  /**\n\t   * 清除hover层外所有内容\n\t   */\n\t  clear: function () {\n\t    this.eachBuiltinLayer(this._clearLayer);\n\t    return this;\n\t  },\n\t  _clearLayer: function (layer) {\n\t    layer.clear();\n\t  },\n\t\n\t  /**\n\t   * 修改指定zlevel的绘制参数\n\t   *\n\t   * @param {string} zlevel\n\t   * @param {Object} config 配置对象\n\t   * @param {string} [config.clearColor=0] 每次清空画布的颜色\n\t   * @param {string} [config.motionBlur=false] 是否开启动态模糊\n\t   * @param {number} [config.lastFrameAlpha=0.7]\n\t   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n\t   */\n\t  configLayer: function (zlevel, config) {\n\t    if (config) {\n\t      var layerConfig = this._layerConfig;\n\t\n\t      if (!layerConfig[zlevel]) {\n\t        layerConfig[zlevel] = config;\n\t      } else {\n\t        util.merge(layerConfig[zlevel], config, true);\n\t      }\n\t\n\t      var layer = this._layers[zlevel];\n\t\n\t      if (layer) {\n\t        util.merge(layer, layerConfig[zlevel], true);\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 删除指定层\n\t   * @param {number} zlevel 层所在的zlevel\n\t   */\n\t  delLayer: function (zlevel) {\n\t    var layers = this._layers;\n\t    var zlevelList = this._zlevelList;\n\t    var layer = layers[zlevel];\n\t\n\t    if (!layer) {\n\t      return;\n\t    }\n\t\n\t    layer.dom.parentNode.removeChild(layer.dom);\n\t    delete layers[zlevel];\n\t    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n\t  },\n\t\n\t  /**\n\t   * 区域大小变化后重绘\n\t   */\n\t  resize: function (width, height) {\n\t    var domRoot = this._domRoot; // FIXME Why ?\n\t\n\t    domRoot.style.display = 'none'; // Save input w/h\n\t\n\t    var opts = this._opts;\n\t    width != null && (opts.width = width);\n\t    height != null && (opts.height = height);\n\t    width = this._getSize(0);\n\t    height = this._getSize(1);\n\t    domRoot.style.display = ''; // 优化没有实际改变的resize\n\t\n\t    if (this._width != width || height != this._height) {\n\t      domRoot.style.width = width + 'px';\n\t      domRoot.style.height = height + 'px';\n\t\n\t      for (var id in this._layers) {\n\t        if (this._layers.hasOwnProperty(id)) {\n\t          this._layers[id].resize(width, height);\n\t        }\n\t      }\n\t\n\t      util.each(this._progressiveLayers, function (layer) {\n\t        layer.resize(width, height);\n\t      });\n\t      this.refresh(true);\n\t    }\n\t\n\t    this._width = width;\n\t    this._height = height;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 清除单独的一个层\n\t   * @param {number} zlevel\n\t   */\n\t  clearLayer: function (zlevel) {\n\t    var layer = this._layers[zlevel];\n\t\n\t    if (layer) {\n\t      layer.clear();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 释放\n\t   */\n\t  dispose: function () {\n\t    this.root.innerHTML = '';\n\t    this.root = this.storage = this._domRoot = this._layers = null;\n\t  },\n\t\n\t  /**\n\t   * Get canvas which has all thing rendered\n\t   * @param {Object} opts\n\t   * @param {string} [opts.backgroundColor]\n\t   * @param {number} [opts.pixelRatio]\n\t   */\n\t  getRenderedCanvas: function (opts) {\n\t    opts = opts || {};\n\t\n\t    if (this._singleCanvas) {\n\t      return this._layers[0].dom;\n\t    }\n\t\n\t    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n\t    imageLayer.initContext();\n\t    imageLayer.clearColor = opts.backgroundColor;\n\t    imageLayer.clear();\n\t    var displayList = this.storage.getDisplayList(true);\n\t    var scope = {};\n\t    var zlevel;\n\t    var self = this;\n\t\n\t    function findAndDrawOtherLayer(smaller, larger) {\n\t      var zlevelList = self._zlevelList;\n\t\n\t      if (smaller == null) {\n\t        smaller = -Infinity;\n\t      }\n\t\n\t      var intermediateLayer;\n\t\n\t      for (var i = 0; i < zlevelList.length; i++) {\n\t        var z = zlevelList[i];\n\t        var layer = self._layers[z];\n\t\n\t        if (!layer.__builtin__ && z > smaller && z < larger) {\n\t          intermediateLayer = layer;\n\t          break;\n\t        }\n\t      }\n\t\n\t      if (intermediateLayer && intermediateLayer.renderToCanvas) {\n\t        imageLayer.ctx.save();\n\t        intermediateLayer.renderToCanvas(imageLayer.ctx);\n\t        imageLayer.ctx.restore();\n\t      }\n\t    }\n\t\n\t    for (var i = 0; i < displayList.length; i++) {\n\t      var el = displayList[i];\n\t\n\t      if (el.zlevel !== zlevel) {\n\t        findAndDrawOtherLayer(zlevel, el.zlevel);\n\t        zlevel = el.zlevel;\n\t      }\n\t\n\t      this._doPaintEl(el, imageLayer, true, scope);\n\t    }\n\t\n\t    findAndDrawOtherLayer(zlevel, Infinity);\n\t    return imageLayer.dom;\n\t  },\n\t\n\t  /**\n\t   * 获取绘图区域宽度\n\t   */\n\t  getWidth: function () {\n\t    return this._width;\n\t  },\n\t\n\t  /**\n\t   * 获取绘图区域高度\n\t   */\n\t  getHeight: function () {\n\t    return this._height;\n\t  },\n\t  _getSize: function (whIdx) {\n\t    var opts = this._opts;\n\t    var wh = ['width', 'height'][whIdx];\n\t    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n\t    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n\t    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\t\n\t    if (opts[wh] != null && opts[wh] !== 'auto') {\n\t      return parseFloat(opts[wh]);\n\t    }\n\t\n\t    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\t\n\t    var stl = document.defaultView.getComputedStyle(root);\n\t    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n\t  },\n\t  pathToImage: function (path, dpr) {\n\t    dpr = dpr || this.dpr;\n\t    var canvas = document.createElement('canvas');\n\t    var ctx = canvas.getContext('2d');\n\t    var rect = path.getBoundingRect();\n\t    var style = path.style;\n\t    var shadowBlurSize = style.shadowBlur;\n\t    var shadowOffsetX = style.shadowOffsetX;\n\t    var shadowOffsetY = style.shadowOffsetY;\n\t    var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n\t    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n\t    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n\t    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n\t    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n\t    var width = rect.width + leftMargin + rightMargin;\n\t    var height = rect.height + topMargin + bottomMargin;\n\t    canvas.width = width * dpr;\n\t    canvas.height = height * dpr;\n\t    ctx.scale(dpr, dpr);\n\t    ctx.clearRect(0, 0, width, height);\n\t    ctx.dpr = dpr;\n\t    var pathTransform = {\n\t      position: path.position,\n\t      rotation: path.rotation,\n\t      scale: path.scale\n\t    };\n\t    path.position = [leftMargin - rect.x, topMargin - rect.y];\n\t    path.rotation = 0;\n\t    path.scale = [1, 1];\n\t    path.updateTransform();\n\t\n\t    if (path) {\n\t      path.brush(ctx);\n\t    }\n\t\n\t    var ImageShape = Image;\n\t    var imgShape = new ImageShape({\n\t      style: {\n\t        x: 0,\n\t        y: 0,\n\t        image: canvas\n\t      }\n\t    });\n\t\n\t    if (pathTransform.position != null) {\n\t      imgShape.position = path.position = pathTransform.position;\n\t    }\n\t\n\t    if (pathTransform.rotation != null) {\n\t      imgShape.rotation = path.rotation = pathTransform.rotation;\n\t    }\n\t\n\t    if (pathTransform.scale != null) {\n\t      imgShape.scale = path.scale = pathTransform.scale;\n\t    }\n\t\n\t    return imgShape;\n\t  }\n\t};\n\tvar _default = Painter;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(5);\n\t\n\tvar _config = __webpack_require__(23);\n\t\n\tvar devicePixelRatio = _config.devicePixelRatio;\n\t\n\tvar Style = __webpack_require__(9);\n\t\n\tvar Pattern = __webpack_require__(40);\n\t\n\t/**\n\t * @module zrender/Layer\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\tfunction returnFalse() {\n\t  return false;\n\t}\n\t/**\n\t * 创建dom\n\t *\n\t * @inner\n\t * @param {string} id dom id 待用\n\t * @param {Painter} painter painter instance\n\t * @param {number} number\n\t */\n\t\n\t\n\tfunction createDom(id, painter, dpr) {\n\t  var newDom = util.createCanvas();\n\t  var width = painter.getWidth();\n\t  var height = painter.getHeight();\n\t  var newDomStyle = newDom.style; // 没append呢，请原谅我这样写，清晰~\n\t\n\t  newDomStyle.position = 'absolute';\n\t  newDomStyle.left = 0;\n\t  newDomStyle.top = 0;\n\t  newDomStyle.width = width + 'px';\n\t  newDomStyle.height = height + 'px';\n\t  newDom.width = width * dpr;\n\t  newDom.height = height * dpr; // id不作为索引用，避免可能造成的重名，定义为私有属性\n\t\n\t  newDom.setAttribute('data-zr-dom-id', id);\n\t  return newDom;\n\t}\n\t/**\n\t * @alias module:zrender/Layer\n\t * @constructor\n\t * @extends module:zrender/mixin/Transformable\n\t * @param {string} id\n\t * @param {module:zrender/Painter} painter\n\t * @param {number} [dpr]\n\t */\n\t\n\t\n\tvar Layer = function (id, painter, dpr) {\n\t  var dom;\n\t  dpr = dpr || devicePixelRatio;\n\t\n\t  if (typeof id === 'string') {\n\t    dom = createDom(id, painter, dpr);\n\t  } // Not using isDom because in node it will return false\n\t  else if (util.isObject(id)) {\n\t      dom = id;\n\t      id = dom.id;\n\t    }\n\t\n\t  this.id = id;\n\t  this.dom = dom;\n\t  var domStyle = dom.style;\n\t\n\t  if (domStyle) {\n\t    // Not in node\n\t    dom.onselectstart = returnFalse; // 避免页面选中的尴尬\n\t\n\t    domStyle['-webkit-user-select'] = 'none';\n\t    domStyle['user-select'] = 'none';\n\t    domStyle['-webkit-touch-callout'] = 'none';\n\t    domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n\t    domStyle['padding'] = 0;\n\t    domStyle['margin'] = 0;\n\t    domStyle['border-width'] = 0;\n\t  }\n\t\n\t  this.domBack = null;\n\t  this.ctxBack = null;\n\t  this.painter = painter;\n\t  this.config = null; // Configs\n\t\n\t  /**\n\t   * 每次清空画布的颜色\n\t   * @type {string}\n\t   * @default 0\n\t   */\n\t\n\t  this.clearColor = 0;\n\t  /**\n\t   * 是否开启动态模糊\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t\n\t  this.motionBlur = false;\n\t  /**\n\t   * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n\t   * @type {number}\n\t   * @default 0.7\n\t   */\n\t\n\t  this.lastFrameAlpha = 0.7;\n\t  /**\n\t   * Layer dpr\n\t   * @type {number}\n\t   */\n\t\n\t  this.dpr = dpr;\n\t};\n\t\n\tLayer.prototype = {\n\t  constructor: Layer,\n\t  elCount: 0,\n\t  __dirty: true,\n\t  initContext: function () {\n\t    this.ctx = this.dom.getContext('2d');\n\t    this.ctx.__currentValues = {};\n\t    this.ctx.dpr = this.dpr;\n\t  },\n\t  createBackBuffer: function () {\n\t    var dpr = this.dpr;\n\t    this.domBack = createDom('back-' + this.id, this.painter, dpr);\n\t    this.ctxBack = this.domBack.getContext('2d');\n\t    this.ctxBack.__currentValues = {};\n\t\n\t    if (dpr != 1) {\n\t      this.ctxBack.scale(dpr, dpr);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @param  {number} width\n\t   * @param  {number} height\n\t   */\n\t  resize: function (width, height) {\n\t    var dpr = this.dpr;\n\t    var dom = this.dom;\n\t    var domStyle = dom.style;\n\t    var domBack = this.domBack;\n\t    domStyle.width = width + 'px';\n\t    domStyle.height = height + 'px';\n\t    dom.width = width * dpr;\n\t    dom.height = height * dpr;\n\t\n\t    if (domBack) {\n\t      domBack.width = width * dpr;\n\t      domBack.height = height * dpr;\n\t\n\t      if (dpr != 1) {\n\t        this.ctxBack.scale(dpr, dpr);\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 清空该层画布\n\t   * @param {boolean} clearAll Clear all with out motion blur\n\t   */\n\t  clear: function (clearAll) {\n\t    var dom = this.dom;\n\t    var ctx = this.ctx;\n\t    var width = dom.width;\n\t    var height = dom.height;\n\t    var clearColor = this.clearColor;\n\t    var haveMotionBLur = this.motionBlur && !clearAll;\n\t    var lastFrameAlpha = this.lastFrameAlpha;\n\t    var dpr = this.dpr;\n\t\n\t    if (haveMotionBLur) {\n\t      if (!this.domBack) {\n\t        this.createBackBuffer();\n\t      }\n\t\n\t      this.ctxBack.globalCompositeOperation = 'copy';\n\t      this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);\n\t    }\n\t\n\t    ctx.clearRect(0, 0, width, height);\n\t\n\t    if (clearColor) {\n\t      var clearColorGradientOrPattern; // Gradient\n\t\n\t      if (clearColor.colorStops) {\n\t        // Cache canvas gradient\n\t        clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n\t          x: 0,\n\t          y: 0,\n\t          width: width,\n\t          height: height\n\t        });\n\t        clearColor.__canvasGradient = clearColorGradientOrPattern;\n\t      } // Pattern\n\t      else if (clearColor.image) {\n\t          clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n\t        }\n\t\n\t      ctx.save();\n\t      ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n\t      ctx.fillRect(0, 0, width, height);\n\t      ctx.restore();\n\t    }\n\t\n\t    if (haveMotionBLur) {\n\t      var domBack = this.domBack;\n\t      ctx.save();\n\t      ctx.globalAlpha = lastFrameAlpha;\n\t      ctx.drawImage(domBack, 0, 0, width, height);\n\t      ctx.restore();\n\t    }\n\t  }\n\t};\n\tvar _default = Layer;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports) {\n\n\tvar _default = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809\n\twindow.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {\n\t  setTimeout(func, 16);\n\t};\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(5);\n\t\n\tvar _event = __webpack_require__(77);\n\t\n\tvar Dispatcher = _event.Dispatcher;\n\t\n\tvar requestAnimationFrame = __webpack_require__(75);\n\t\n\tvar Animator = __webpack_require__(17);\n\t\n\t/**\n\t * 动画主类, 调度和管理所有动画控制器\n\t *\n\t * @module zrender/animation/Animation\n\t * @author pissang(https://github.com/pissang)\n\t */\n\t// TODO Additive animation\n\t// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n\t// https://developer.apple.com/videos/wwdc2014/#236\n\t\n\t/**\n\t * @typedef {Object} IZRenderStage\n\t * @property {Function} update\n\t */\n\t\n\t/**\n\t * @alias module:zrender/animation/Animation\n\t * @constructor\n\t * @param {Object} [options]\n\t * @param {Function} [options.onframe]\n\t * @param {IZRenderStage} [options.stage]\n\t * @example\n\t *     var animation = new Animation();\n\t *     var obj = {\n\t *         x: 100,\n\t *         y: 100\n\t *     };\n\t *     animation.animate(node.position)\n\t *         .when(1000, {\n\t *             x: 500,\n\t *             y: 500\n\t *         })\n\t *         .when(2000, {\n\t *             x: 100,\n\t *             y: 100\n\t *         })\n\t *         .start('spline');\n\t */\n\tvar Animation = function (options) {\n\t  options = options || {};\n\t  this.stage = options.stage || {};\n\t\n\t  this.onframe = options.onframe || function () {}; // private properties\n\t\n\t\n\t  this._clips = [];\n\t  this._running = false;\n\t  this._time;\n\t  this._pausedTime;\n\t  this._pauseStart;\n\t  this._paused = false;\n\t  Dispatcher.call(this);\n\t};\n\t\n\tAnimation.prototype = {\n\t  constructor: Animation,\n\t\n\t  /**\n\t   * 添加 clip\n\t   * @param {module:zrender/animation/Clip} clip\n\t   */\n\t  addClip: function (clip) {\n\t    this._clips.push(clip);\n\t  },\n\t\n\t  /**\n\t   * 添加 animator\n\t   * @param {module:zrender/animation/Animator} animator\n\t   */\n\t  addAnimator: function (animator) {\n\t    animator.animation = this;\n\t    var clips = animator.getClips();\n\t\n\t    for (var i = 0; i < clips.length; i++) {\n\t      this.addClip(clips[i]);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 删除动画片段\n\t   * @param {module:zrender/animation/Clip} clip\n\t   */\n\t  removeClip: function (clip) {\n\t    var idx = util.indexOf(this._clips, clip);\n\t\n\t    if (idx >= 0) {\n\t      this._clips.splice(idx, 1);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 删除动画片段\n\t   * @param {module:zrender/animation/Animator} animator\n\t   */\n\t  removeAnimator: function (animator) {\n\t    var clips = animator.getClips();\n\t\n\t    for (var i = 0; i < clips.length; i++) {\n\t      this.removeClip(clips[i]);\n\t    }\n\t\n\t    animator.animation = null;\n\t  },\n\t  _update: function () {\n\t    var time = new Date().getTime() - this._pausedTime;\n\t\n\t    var delta = time - this._time;\n\t    var clips = this._clips;\n\t    var len = clips.length;\n\t    var deferredEvents = [];\n\t    var deferredClips = [];\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      var clip = clips[i];\n\t      var e = clip.step(time, delta); // Throw out the events need to be called after\n\t      // stage.update, like destroy\n\t\n\t      if (e) {\n\t        deferredEvents.push(e);\n\t        deferredClips.push(clip);\n\t      }\n\t    } // Remove the finished clip\n\t\n\t\n\t    for (var i = 0; i < len;) {\n\t      if (clips[i]._needsRemove) {\n\t        clips[i] = clips[len - 1];\n\t        clips.pop();\n\t        len--;\n\t      } else {\n\t        i++;\n\t      }\n\t    }\n\t\n\t    len = deferredEvents.length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      deferredClips[i].fire(deferredEvents[i]);\n\t    }\n\t\n\t    this._time = time;\n\t    this.onframe(delta);\n\t    this.trigger('frame', delta);\n\t\n\t    if (this.stage.update) {\n\t      this.stage.update();\n\t    }\n\t  },\n\t  _startLoop: function () {\n\t    var self = this;\n\t    this._running = true;\n\t\n\t    function step() {\n\t      if (self._running) {\n\t        requestAnimationFrame(step);\n\t        !self._paused && self._update();\n\t      }\n\t    }\n\t\n\t    requestAnimationFrame(step);\n\t  },\n\t\n\t  /**\n\t   * 开始运行动画\n\t   */\n\t  start: function () {\n\t    this._time = new Date().getTime();\n\t    this._pausedTime = 0;\n\t\n\t    this._startLoop();\n\t  },\n\t\n\t  /**\n\t   * 停止运行动画\n\t   */\n\t  stop: function () {\n\t    this._running = false;\n\t  },\n\t\n\t  /**\n\t   * Pause\n\t   */\n\t  pause: function () {\n\t    if (!this._paused) {\n\t      this._pauseStart = new Date().getTime();\n\t      this._paused = true;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Resume\n\t   */\n\t  resume: function () {\n\t    if (this._paused) {\n\t      this._pausedTime += new Date().getTime() - this._pauseStart;\n\t      this._paused = false;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 清除所有动画片段\n\t   */\n\t  clear: function () {\n\t    this._clips = [];\n\t  },\n\t\n\t  /**\n\t   * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画\n\t   * @param  {Object} target\n\t   * @param  {Object} options\n\t   * @param  {boolean} [options.loop=false] 是否循环播放动画\n\t   * @param  {Function} [options.getter=null]\n\t   *         如果指定getter函数，会通过getter函数取属性值\n\t   * @param  {Function} [options.setter=null]\n\t   *         如果指定setter函数，会通过setter函数设置属性值\n\t   * @return {module:zrender/animation/Animation~Animator}\n\t   */\n\t  // TODO Gap\n\t  animate: function (target, options) {\n\t    options = options || {};\n\t    var animator = new Animator(target, options.loop, options.getter, options.setter);\n\t    this.addAnimator(animator);\n\t    return animator;\n\t  }\n\t};\n\tutil.mixin(Animation, Dispatcher);\n\tvar _default = Animation;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Eventful = __webpack_require__(12);\n\t\n\texports.Dispatcher = Eventful;\n\t\n\tvar env = __webpack_require__(50);\n\t\n\t/**\n\t * 事件辅助类\n\t * @module zrender/core/event\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t */\n\tvar isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\n\tvar MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;\n\t\n\tfunction getBoundingClientRect(el) {\n\t  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n\t  return el.getBoundingClientRect ? el.getBoundingClientRect() : {\n\t    left: 0,\n\t    top: 0\n\t  };\n\t} // `calculate` is optional, default false\n\t\n\t\n\tfunction clientToLocal(el, e, out, calculate) {\n\t  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative\n\t  // to the padding edge of the target element. The only browser using this convention\n\t  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n\t  // not support the properties.\n\t  // (see http://www.jacklmoore.com/notes/mouse-position/)\n\t  // In zr painter.dom, padding edge equals to border edge.\n\t  // FIXME\n\t  // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n\t  // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n\t  // is too complex. So css-transfrom dont support in this case temporarily.\n\t\n\t  if (calculate || !env.canvasSupported) {\n\t    defaultGetZrXY(el, e, out);\n\t  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n\t  // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n\t  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n\t  // zoom-factor, overflow / opacity layers, transforms ...)\n\t  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n\t  // <https://bugs.jquery.com/ticket/8523#comment:14>\n\t  // BTW3, In ff, offsetX/offsetY is always 0.\n\t  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n\t      out.zrX = e.layerX;\n\t      out.zrY = e.layerY;\n\t    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n\t    else if (e.offsetX != null) {\n\t        out.zrX = e.offsetX;\n\t        out.zrY = e.offsetY;\n\t      } // For some other device, e.g., IOS safari.\n\t      else {\n\t          defaultGetZrXY(el, e, out);\n\t        }\n\t\n\t  return out;\n\t}\n\t\n\tfunction defaultGetZrXY(el, e, out) {\n\t  // This well-known method below does not support css transform.\n\t  var box = getBoundingClientRect(el);\n\t  out.zrX = e.clientX - box.left;\n\t  out.zrY = e.clientY - box.top;\n\t}\n\t/**\n\t * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.\n\t * `calculate` is optional, default false.\n\t */\n\t\n\t\n\tfunction normalizeEvent(el, e, calculate) {\n\t  e = e || window.event;\n\t\n\t  if (e.zrX != null) {\n\t    return e;\n\t  }\n\t\n\t  var eventType = e.type;\n\t  var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\t\n\t  if (!isTouch) {\n\t    clientToLocal(el, e, e, calculate);\n\t    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n\t  } else {\n\t    var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n\t    touch && clientToLocal(el, touch, e, calculate);\n\t  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;\n\t  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js\n\t  // If e.which has been defined, if may be readonly,\n\t  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which\n\t\n\t\n\t  var button = e.button;\n\t\n\t  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {\n\t    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n\t  }\n\t\n\t  return e;\n\t}\n\t\n\tfunction addEventListener(el, name, handler) {\n\t  if (isDomLevel2) {\n\t    el.addEventListener(name, handler);\n\t  } else {\n\t    el.attachEvent('on' + name, handler);\n\t  }\n\t}\n\t\n\tfunction removeEventListener(el, name, handler) {\n\t  if (isDomLevel2) {\n\t    el.removeEventListener(name, handler);\n\t  } else {\n\t    el.detachEvent('on' + name, handler);\n\t  }\n\t}\n\t/**\n\t * preventDefault and stopPropagation.\n\t * Notice: do not do that in zrender. Upper application\n\t * do that if necessary.\n\t *\n\t * @memberOf module:zrender/core/event\n\t * @method\n\t * @param {Event} e : event对象\n\t */\n\t\n\t\n\tvar stop = isDomLevel2 ? function (e) {\n\t  e.preventDefault();\n\t  e.stopPropagation();\n\t  e.cancelBubble = true;\n\t} : function (e) {\n\t  e.returnValue = false;\n\t  e.cancelBubble = true;\n\t};\n\t\n\tfunction notLeftMouse(e) {\n\t  // If e.which is undefined, considered as left mouse event.\n\t  return e.which > 1;\n\t} // 做向上兼容\n\t\n\t\n\texports.clientToLocal = clientToLocal;\n\texports.normalizeEvent = normalizeEvent;\n\texports.addEventListener = addEventListener;\n\texports.removeEventListener = removeEventListener;\n\texports.stop = stop;\n\texports.notLeftMouse = notLeftMouse;\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _event = __webpack_require__(77);\n\t\n\tvar addEventListener = _event.addEventListener;\n\tvar removeEventListener = _event.removeEventListener;\n\tvar normalizeEvent = _event.normalizeEvent;\n\t\n\tvar zrUtil = __webpack_require__(5);\n\t\n\tvar Eventful = __webpack_require__(12);\n\t\n\tvar env = __webpack_require__(50);\n\t\n\tvar GestureMgr = __webpack_require__(79);\n\t\n\tvar TOUCH_CLICK_DELAY = 300;\n\tvar mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n\tvar touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];\n\tvar pointerEventNames = {\n\t  pointerdown: 1,\n\t  pointerup: 1,\n\t  pointermove: 1,\n\t  pointerout: 1\n\t};\n\tvar pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n\t  var nm = name.replace('mouse', 'pointer');\n\t  return pointerEventNames[nm] ? nm : name;\n\t});\n\t\n\tfunction eventNameFix(name) {\n\t  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n\t}\n\t\n\tfunction processGesture(proxy, event, stage) {\n\t  var gestureMgr = proxy._gestureMgr;\n\t  stage === 'start' && gestureMgr.clear();\n\t  var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null).target, proxy.dom);\n\t  stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.\n\t\n\t  if (gestureInfo) {\n\t    var type = gestureInfo.type;\n\t    event.gestureEvent = type;\n\t    proxy.handler.dispatchToElement({\n\t      target: gestureInfo.target\n\t    }, type, gestureInfo.event);\n\t  }\n\t} // function onMSGestureChange(proxy, event) {\n\t//     if (event.translationX || event.translationY) {\n\t//         // mousemove is carried by MSGesture to reduce the sensitivity.\n\t//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n\t//     }\n\t//     if (event.scale !== 1) {\n\t//         event.pinchX = event.offsetX;\n\t//         event.pinchY = event.offsetY;\n\t//         event.pinchScale = event.scale;\n\t//         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n\t//     }\n\t// }\n\t\n\t/**\n\t * Prevent mouse event from being dispatched after Touch Events action\n\t * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n\t * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n\t * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n\t * Result: Blocking Mouse Events for 700ms.\n\t */\n\t\n\t\n\tfunction setTouchTimer(instance) {\n\t  instance._touching = true;\n\t  clearTimeout(instance._touchTimer);\n\t  instance._touchTimer = setTimeout(function () {\n\t    instance._touching = false;\n\t  }, 700);\n\t}\n\t\n\tvar domHandlers = {\n\t  /**\n\t   * Mouse move handler\n\t   * @inner\n\t   * @param {Event} event\n\t   */\n\t  mousemove: function (event) {\n\t    event = normalizeEvent(this.dom, event);\n\t    this.trigger('mousemove', event);\n\t  },\n\t\n\t  /**\n\t   * Mouse out handler\n\t   * @inner\n\t   * @param {Event} event\n\t   */\n\t  mouseout: function (event) {\n\t    event = normalizeEvent(this.dom, event);\n\t    var element = event.toElement || event.relatedTarget;\n\t\n\t    if (element != this.dom) {\n\t      while (element && element.nodeType != 9) {\n\t        // 忽略包含在root中的dom引起的mouseOut\n\t        if (element === this.dom) {\n\t          return;\n\t        }\n\t\n\t        element = element.parentNode;\n\t      }\n\t    }\n\t\n\t    this.trigger('mouseout', event);\n\t  },\n\t\n\t  /**\n\t   * Touch开始响应函数\n\t   * @inner\n\t   * @param {Event} event\n\t   */\n\t  touchstart: function (event) {\n\t    // Default mouse behaviour should not be disabled here.\n\t    // For example, page may needs to be slided.\n\t    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n\t    // mouse event in upper applicatoin.\n\t\n\t    event.zrByTouch = true;\n\t    this._lastTouchMoment = new Date();\n\t    processGesture(this, event, 'start'); // In touch device, trigger `mousemove`(`mouseover`) should\n\t    // be triggered, and must before `mousedown` triggered.\n\t\n\t    domHandlers.mousemove.call(this, event);\n\t    domHandlers.mousedown.call(this, event);\n\t    setTouchTimer(this);\n\t  },\n\t\n\t  /**\n\t   * Touch移动响应函数\n\t   * @inner\n\t   * @param {Event} event\n\t   */\n\t  touchmove: function (event) {\n\t    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n\t    // mouse event in upper applicatoin.\n\t\n\t    event.zrByTouch = true;\n\t    processGesture(this, event, 'change'); // Mouse move should always be triggered no matter whether\n\t    // there is gestrue event, because mouse move and pinch may\n\t    // be used at the same time.\n\t\n\t    domHandlers.mousemove.call(this, event);\n\t    setTouchTimer(this);\n\t  },\n\t\n\t  /**\n\t   * Touch结束响应函数\n\t   * @inner\n\t   * @param {Event} event\n\t   */\n\t  touchend: function (event) {\n\t    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n\t    // mouse event in upper applicatoin.\n\t\n\t    event.zrByTouch = true;\n\t    processGesture(this, event, 'end');\n\t    domHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n\t    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n\t    // we can conveniently implement \"hover style\" in both PC and touch device just\n\t    // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n\t    // to remove \"hover style\" on an element, without any additional code for\n\t    // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n\t    // style\" will remain for user view)\n\t    // click event should always be triggered no matter whether\n\t    // there is gestrue event. System click can not be prevented.\n\t\n\t    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n\t      domHandlers.click.call(this, event);\n\t    }\n\t\n\t    setTouchTimer(this);\n\t  },\n\t  pointerdown: function (event) {\n\t    domHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {\n\t    //     this._msGesture.addPointer(event.pointerId);\n\t    // }\n\t  },\n\t  pointermove: function (event) {\n\t    // FIXME\n\t    // pointermove is so sensitive that it always triggered when\n\t    // tap(click) on touch screen, which affect some judgement in\n\t    // upper application. So, we dont support mousemove on MS touch\n\t    // device yet.\n\t    if (!isPointerFromTouch(event)) {\n\t      domHandlers.mousemove.call(this, event);\n\t    }\n\t  },\n\t  pointerup: function (event) {\n\t    domHandlers.mouseup.call(this, event);\n\t  },\n\t  pointerout: function (event) {\n\t    // pointerout will be triggered when tap on touch screen\n\t    // (IE11+/Edge on MS Surface) after click event triggered,\n\t    // which is inconsistent with the mousout behavior we defined\n\t    // in touchend. So we unify them.\n\t    // (check domHandlers.touchend for detailed explanation)\n\t    if (!isPointerFromTouch(event)) {\n\t      domHandlers.mouseout.call(this, event);\n\t    }\n\t  }\n\t};\n\t\n\tfunction isPointerFromTouch(event) {\n\t  var pointerType = event.pointerType;\n\t  return pointerType === 'pen' || pointerType === 'touch';\n\t} // function useMSGuesture(handlerProxy, event) {\n\t//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n\t// }\n\t// Common handlers\n\t\n\t\n\tzrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n\t  domHandlers[name] = function (event) {\n\t    event = normalizeEvent(this.dom, event);\n\t    this.trigger(name, event);\n\t  };\n\t});\n\t/**\n\t * 为控制类实例初始化dom 事件处理函数\n\t *\n\t * @inner\n\t * @param {module:zrender/Handler} instance 控制类实例\n\t */\n\t\n\tfunction initDomHandler(instance) {\n\t  zrUtil.each(touchHandlerNames, function (name) {\n\t    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t  });\n\t  zrUtil.each(pointerHandlerNames, function (name) {\n\t    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t  });\n\t  zrUtil.each(mouseHandlerNames, function (name) {\n\t    instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n\t  });\n\t\n\t  function makeMouseHandler(fn, instance) {\n\t    return function () {\n\t      if (instance._touching) {\n\t        return;\n\t      }\n\t\n\t      return fn.apply(instance, arguments);\n\t    };\n\t  }\n\t}\n\t\n\tfunction HandlerDomProxy(dom) {\n\t  Eventful.call(this);\n\t  this.dom = dom;\n\t  /**\n\t   * @private\n\t   * @type {boolean}\n\t   */\n\t\n\t  this._touching = false;\n\t  /**\n\t   * @private\n\t   * @type {number}\n\t   */\n\t\n\t  this._touchTimer;\n\t  /**\n\t   * @private\n\t   * @type {module:zrender/core/GestureMgr}\n\t   */\n\t\n\t  this._gestureMgr = new GestureMgr();\n\t  this._handlers = {};\n\t  initDomHandler(this);\n\t\n\t  if (env.pointerEventsSupported) {\n\t    // Only IE11+/Edge\n\t    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n\t    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n\t    // at the same time.\n\t    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n\t    // screen, which do not occurs in pointer event.\n\t    // So we use pointer event to both detect touch gesture and mouse behavior.\n\t    mountHandlers(pointerHandlerNames, this); // FIXME\n\t    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n\t    // which does not prevent defuault behavior occasionally (which may cause view port\n\t    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n\t    // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n\t    // touch screen. And we only support click behavior on MS touch screen now.\n\t    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n\t    // We dont support touch on IE on win7.\n\t    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n\t    // if (typeof MSGesture === 'function') {\n\t    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n\t    //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n\t    // }\n\t  } else {\n\t    if (env.touchEventsSupported) {\n\t      mountHandlers(touchHandlerNames, this); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n\t      // addEventListener(root, 'mouseout', this._mouseoutHandler);\n\t    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n\t    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n\t    // mouse event can not be handle in those devices.\n\t    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n\t    // mouseevent after touch event triggered, see `setTouchTimer`.\n\t\n\t\n\t    mountHandlers(mouseHandlerNames, this);\n\t  }\n\t\n\t  function mountHandlers(handlerNames, instance) {\n\t    zrUtil.each(handlerNames, function (name) {\n\t      addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n\t    }, instance);\n\t  }\n\t}\n\t\n\tvar handlerDomProxyProto = HandlerDomProxy.prototype;\n\t\n\thandlerDomProxyProto.dispose = function () {\n\t  var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\t\n\t  for (var i = 0; i < handlerNames.length; i++) {\n\t    var name = handlerNames[i];\n\t    removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n\t  }\n\t};\n\t\n\thandlerDomProxyProto.setCursor = function (cursorStyle) {\n\t  this.dom.style.cursor = cursorStyle || 'default';\n\t};\n\t\n\tzrUtil.mixin(HandlerDomProxy, Eventful);\n\tvar _default = HandlerDomProxy;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar eventUtil = __webpack_require__(77);\n\t\n\t/**\n\t * Only implements needed gestures for mobile.\n\t */\n\tvar GestureMgr = function () {\n\t  /**\n\t   * @private\n\t   * @type {Array.<Object>}\n\t   */\n\t  this._track = [];\n\t};\n\t\n\tGestureMgr.prototype = {\n\t  constructor: GestureMgr,\n\t  recognize: function (event, target, root) {\n\t    this._doTrack(event, target, root);\n\t\n\t    return this._recognize(event);\n\t  },\n\t  clear: function () {\n\t    this._track.length = 0;\n\t    return this;\n\t  },\n\t  _doTrack: function (event, target, root) {\n\t    var touches = event.touches;\n\t\n\t    if (!touches) {\n\t      return;\n\t    }\n\t\n\t    var trackItem = {\n\t      points: [],\n\t      touches: [],\n\t      target: target,\n\t      event: event\n\t    };\n\t\n\t    for (var i = 0, len = touches.length; i < len; i++) {\n\t      var touch = touches[i];\n\t      var pos = eventUtil.clientToLocal(root, touch, {});\n\t      trackItem.points.push([pos.zrX, pos.zrY]);\n\t      trackItem.touches.push(touch);\n\t    }\n\t\n\t    this._track.push(trackItem);\n\t  },\n\t  _recognize: function (event) {\n\t    for (var eventName in recognizers) {\n\t      if (recognizers.hasOwnProperty(eventName)) {\n\t        var gestureInfo = recognizers[eventName](this._track, event);\n\t\n\t        if (gestureInfo) {\n\t          return gestureInfo;\n\t        }\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\tfunction dist(pointPair) {\n\t  var dx = pointPair[1][0] - pointPair[0][0];\n\t  var dy = pointPair[1][1] - pointPair[0][1];\n\t  return Math.sqrt(dx * dx + dy * dy);\n\t}\n\t\n\tfunction center(pointPair) {\n\t  return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];\n\t}\n\t\n\tvar recognizers = {\n\t  pinch: function (track, event) {\n\t    var trackLen = track.length;\n\t\n\t    if (!trackLen) {\n\t      return;\n\t    }\n\t\n\t    var pinchEnd = (track[trackLen - 1] || {}).points;\n\t    var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\t\n\t    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {\n\t      var pinchScale = dist(pinchEnd) / dist(pinchPre);\n\t      !isFinite(pinchScale) && (pinchScale = 1);\n\t      event.pinchScale = pinchScale;\n\t      var pinchCenter = center(pinchEnd);\n\t      event.pinchX = pinchCenter[0];\n\t      event.pinchY = pinchCenter[1];\n\t      return {\n\t        type: 'pinch',\n\t        target: track[0].target,\n\t        event: event\n\t      };\n\t    }\n\t  } // Only pinch currently.\n\t\n\t};\n\tvar _default = GestureMgr;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 选中节点后，出现的操作框及按钮\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var Node = __webpack_require__(81);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var Util = __webpack_require__(65);\r\n\t    var graphic = __webpack_require__(4);\r\n\t    var Connector = __webpack_require__(82);\r\n\t    var env = __webpack_require__(50);\r\n\t    var icon = __webpack_require__(89);\r\n\t    var symbolUtil = __webpack_require__(83);\r\n\t    function OperationNode(node, zr, api,forbidEdit) {\r\n\t        Node.call(this);\r\n\t        this.node = node;\r\n\t        this.zr = zr;\r\n\t        this.forbidEdit = forbidEdit;\r\n\t        this._api = api;\r\n\t        this.render();\r\n\t    }\r\n\t\r\n\t    //事件\r\n\t    OperationNode.ARROW_DRAGEND = \"OperationNode:dragendArrow\";\r\n\t    OperationNode.ARROW_DRAG = \"OperationNode:dragArrow\";\r\n\t    OperationNode.ARROW_DRAGSTART = \"OperationNode:dragstartArrow\";\r\n\t    OperationNode.DELETE_CLICK = \"OperationNode:deleteClick\";\r\n\t    OperationNode.DEL = \"DEL\";\r\n\t    OperationNode.COMMENT_CLICK = \"OperationNode:commentClick\";\r\n\t    OperationNode.COMMENT = \"COMMENT\";\r\n\t        //内置操作图标的图像\r\n\t    OperationNode.opicons = {\r\n\t        STRAIGHT: icon.STRAIGHT_SVG,\r\n\t        JAGGED: icon.JAGGED_SVG,\r\n\t        CURVE: icon.CURVE_SVG,\r\n\t        DEL: icon.DEL_SVG,\r\n\t        COMMENT: icon.COMMENT_SVG\r\n\t    };\r\n\t\r\n\t    OperationNode.prototype.render = function() {\r\n\t        this.renderBase();\r\n\t        if (!this.forbidEdit) {\r\n\t            this.renderOther();\r\n\t        }\r\n\t    };\r\n\t\r\n\t    OperationNode.prototype.renderBase = function() {\r\n\t        this.createOperation();\r\n\t    };\r\n\t\r\n\t    OperationNode.prototype.createOperation = function() {\r\n\t        var me = this;\r\n\t        var ifShowNodeOperationIcons = this.node.operationIcons;\r\n\t        if (this.node.parent && this.node.parent.type === 'dragSelect') {\r\n\t            ifShowNodeOperationIcons = false;\r\n\t        }\r\n\t        if (!this.node.selectStyle) {\r\n\t            this.virtualRect = new graphic.Polyline({ style: { lineDash: [2] } });\r\n\t            this.virtualRect.isSelfComputePos = true;  // 自己计算位置\r\n\t            this.add(this.virtualRect);\r\n\t        } else {\r\n\t             if (this.node.type === 'ZPath') {  //addHover需要从它自身的构造函数中创建。1.Painter中addHover源码是根据shape与style创建 2.path中的构造函数是返回另一个元素\r\n\t                this.node._zCloneStyle = this.node.style.clone();\r\n\t                 this.node.setStyle(this.node.selectStyle);\r\n\t             } else if(this.node.setOrCancelSelectStyle) {\r\n\t                this.node.setOrCancelSelectStyle(true);\r\n\t             } else {\r\n\t                this._api.getZr().addHover(this.node, this.node.selectStyle);\r\n\t             }\r\n\t\r\n\t        }\r\n\t\r\n\t        if (ifShowNodeOperationIcons) {\r\n\t            zrUtil.each(this.node.operationIcons, function(item) {\r\n\t                //检查是否是内置图标\r\n\t                var opIconInstance = null;\r\n\t                var operationIcon = OperationNode.opicons[item.name.toUpperCase() + \"\"]\r\n\t                if (operationIcon) {\r\n\t\r\n\t                    if (this.forbidEdit) {\r\n\t                        return;\r\n\t                    }\r\n\t                    if (item.hidden) {\r\n\t                        return;\r\n\t                    }\r\n\t                    if (item.name == OperationNode.DEL) {\r\n\t                        //垃圾桶\r\n\t                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' },z:me.node.z+1,rectHover: true }, { x: 0, y: 0, width: 10, height: 15 });\r\n\t\r\n\t                        if(item.callback){\r\n\t                            opIconInstance.on(\"click\", function(e) {\r\n\t                                e.data = item;\r\n\t                                e.node = me.node;  // 将所附的节点也传递出去\r\n\t                                if (item.callback) {\r\n\t                                    item.callback(e);\r\n\t                                }\r\n\t                            });\r\n\t                        }else{\r\n\t                            opIconInstance.on(\"click\", function(e) {\r\n\t                                var params = {};\r\n\t                                params.event = e;\r\n\t                                params.target = this;\r\n\t                                params.type = OperationNode.DELETE_CLICK;\r\n\t                                me.trigger(params.type, params);\r\n\t                            });\r\n\t                        }\r\n\t                    } else if (item.name == OperationNode.COMMENT) {\r\n\t                        var rect = { x: 0, y: 0, width: 16, height: 16 };\r\n\t                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' }, z:me.node.z+2, rectHover: true }, rect);\r\n\t                        opIconInstance.on(\"click\", function(e) {\r\n\t                            var params = {};\r\n\t                            params.event = e;\r\n\t                            params.target = this;\r\n\t                            params.type = OperationNode.COMMENT_CLICK;\r\n\t                            me.trigger(params.type, params);\r\n\t                        });\r\n\t                    } else {\r\n\t                        var rectOther = { x: 0, y: 0, width: 15, height: 15 };\r\n\t                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' },draggable:true,z:me.node.z+2,lineType: Connector[\"TYPE_\" + item.name.toUpperCase()],rectHover: true }, rectOther);\r\n\t                        var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];\r\n\t                        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n\t                            opIconInstance.on(eveName, function(e) {\r\n\t                                var params = {};\r\n\t                                params.event = e;\r\n\t                                params.data = item.options\r\n\t                                params.type = \"OperationNode:\" + eveName + \"Arrow\";\r\n\t                                me.trigger(params.type, params);\r\n\t                            });\r\n\t                        });\r\n\t                    }\r\n\t\r\n\t                } else {\r\n\t                    opIconInstance = symbolUtil.createSymbol(item.iconPath, 0, 0, item.width || 15, item.height || 15, me.node.z+1, item.color||'#000');\r\n\t                    opIconInstance.on(\"click\", function(e) {\r\n\t                        e.data = item;\r\n\t                        e.node = me.node;  // 将所附的节点也传递出去\r\n\t                        if (item.callback) {\r\n\t                            item.callback(e);\r\n\t                        }\r\n\t                        var param = {event:e, type:\"OperationNode:\" + item.name + \"Click\"};\r\n\t                        me._api.trigger(param.type, param);\r\n\t                    });\r\n\t                }\r\n\t                opIconInstance.name = item.name;\r\n\t                me.add(opIconInstance);\r\n\t            });\r\n\t        }\r\n\t    };\r\n\t\r\n\t    OperationNode.prototype.refreshPostion = function(node, nodeRect) {\r\n\t        var i = 0;\r\n\t        var rbPoint = zrUtil.clone(nodeRect.points[2]); //取右下角坐标\r\n\t        var rotation = node.rotation;\r\n\t        var angle = rotation / (Math.PI/180);\r\n\t        if (Math.abs(rotation) > 0) {\r\n\t            var connectorControls = Util.getConnectorControls(nodeRect, node);\r\n\t            var brControl = connectorControls.br;\r\n\t            rbPoint = [brControl.x - nodeRect.x,  brControl.y - nodeRect.y];\r\n\t        }\r\n\t        //1.定位虚框\r\n\t        if (this.virtualRect) {\r\n\t            this.virtualRect.setShape({ points: nodeRect.points });\r\n\t            this.virtualRect.attr('rotation', rotation);\r\n\t        }\r\n\t        //2.定位每个小图标\r\n\t        this.eachChild(function(nodeItem) {\r\n\t            if (!nodeItem.isSelfComputePos) {\r\n\t                // 8px是第一个操作按钮图标的距离 靠太近不好看    20px是每个图标的间隔  10px是图标向偏的距离\r\n\t                nodeItem.attr(\"position\", [angle >= 0 ? rbPoint[0] + 8 + (i++ * 20) : rbPoint[0] - 20 - (i++ * 20), rbPoint[1] - 10]);\r\n\t            }\r\n\t        });\r\n\t\r\n\t        this.refreshPositionOther(node,nodeRect);\r\n\t    };\r\n\t\r\n\t    OperationNode.prototype.renderOther = function() {\r\n\t        //留给扩展使用\r\n\t    };\r\n\t    OperationNode.prototype.refreshPositionOther = function(node,nodeRect) {\r\n\t        //留给扩展使用\r\n\t        //3.定位整个operationNode\r\n\t        if ((node.parent && node.parent.isBg && node.parent.isBg == true) || (node.parent.type === \"GroupNode\")) {\r\n\t            this.attr(\"position\", [nodeRect.x, nodeRect.y])\r\n\t        } else {\r\n\t            var nodeShapeX = node.shape? node.shape.x:0;\r\n\t            var nodeSahpeY = node.shape? node.shape.y:0;\r\n\t            this.attr(\"position\", [nodeRect.x + node.parent.position[0]+nodeShapeX, nodeRect.y + node.parent.position[1]+nodeSahpeY])\r\n\t        }\r\n\t    };\r\n\t\r\n\t    OperationNode.prototype.cleanup = function() {\r\n\t        if(this.node.selectStyle) {\r\n\t            if (this.node.type === 'ZPath') {\r\n\t                this.node.setStyle(this.node._zCloneStyle);\r\n\t            } else if(this.node.setOrCancelSelectStyle) {\r\n\t                this.node.setOrCancelSelectStyle(false);\r\n\t             } else {\r\n\t                this._api.getZr().removeHover(this.node);\r\n\t            }\r\n\t\r\n\t        }\r\n\t    };\r\n\t\r\n\t    zrUtil.inherits(OperationNode, Node);\r\n\t    module.exports = OperationNode;\r\n\t\r\n\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var graphic = __webpack_require__(4);\r\n\t    var util = __webpack_require__(65)\r\n\t    //创建Node类 所有形状都继承Node  包括fromJSON toJSON\r\n\t    function Node() {\r\n\t        this.resourceId = util.getUUID(); // 生成节点ID\r\n\t        graphic.Group.call(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 由父类实现\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Node.prototype.render = function() {};\r\n\t\r\n\t    /**\r\n\t     * 由父类实现\r\n\t     * @param  {[type]} json [description]\r\n\t     * @return {[type]}      [description]\r\n\t     */\r\n\t    Node.prototype.getRect = function(json) {};\r\n\t\r\n\t    /**\r\n\t     * drawText\r\n\t     * @description 画一个文本\r\n\t     * @param {string} name\r\n\t     * @param {string} color\r\n\t     */\r\n\t    Node.prototype.drawText = function(name, color, position) {\r\n\t        var textName = this.bpmnInfo.name, x, y;\r\n\t        if(name != null){\r\n\t            textName = name;\r\n\t        }\r\n\t        var text = new graphic.Text({\r\n\t            style: {\r\n\t                text: textName,\r\n\t                color: color ? color : this.options.text.color,\r\n\t                textFont: '12px Microsoft YaHei'\r\n\t            },\r\n\t            zlevel: 20\r\n\t        });\r\n\t        //文字绘制的位置 \r\n\t        position = position ? position : 'init';\r\n\t        switch (position) {\r\n\t            //节点下方居中位置\r\n\t            case 'init': \r\n\t                //x = 中心点.x - 起始位置.x - 文字宽度的一半\r\n\t                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n\t                //y = 中心点.y - 起始位置.y + 偏移值（6）\r\n\t                y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + 6;\r\n\t                break;\r\n\t            //节点内部居中位置\r\n\t            case 'center':\r\n\t                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n\t                y = this.getRect().y - this.position[1] - 6;\r\n\t                break;\r\n\t            //节点内部居左位置\r\n\t            case 'left': \r\n\t                x = this.getRect().x - this.position[0] - text.getBoundingRect().width + 6;\r\n\t                y = this.getRect().y - this.position[1] - 6;\r\n\t                break;\r\n\t            default: break;\r\n\t        }\r\n\t        text.attr(\"style\", { x: x, y: y });\r\n\t        return {\r\n\t            text: text,\r\n\t            rect: text.getBoundingRect()\r\n\t        };\r\n\t    };\r\n\t    /**\r\n\t     * refreshText\r\n\t     * @description 刷新文本\r\n\t     */\r\n\t    Node.prototype.refreshText = function(pos) {\r\n\t        var text = this.childOfName(\"Title\"), x, y;\r\n\t        pos = pos ? pos : 'init';\r\n\t        switch (pos) {\r\n\t            case 'init': \r\n\t                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n\t                y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + 6;\r\n\t                break;\r\n\t            case 'center':\r\n\t                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n\t                y = this.getRect().y - this.position[1] - 6;\r\n\t                break;\r\n\t            case 'left':\r\n\t                x = 2;\r\n\t                y = this.getRect().y - this.position[1] - 6;\r\n\t                break;\r\n\t            default: break;\r\n\t        }\r\n\t        text.attr(\"style\", { x: x, y: y });\r\n\t    };\r\n\t    /**\r\n\t     * 由父类实现\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Node.prototype.toJSON = function() {};\r\n\t\r\n\t    graphic.Util.inherits(Node, graphic.Group);\r\n\t    module.exports = Node;\r\n\t\r\n\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 连接线\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var Util = __webpack_require__(65);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var vec2 = __webpack_require__(15);\r\n\t    var graphic = __webpack_require__(4);\r\n\t    var Node = __webpack_require__(81);\r\n\t    var symbolUtil = __webpack_require__(83);\r\n\t    var Handle = __webpack_require__(84);\r\n\t    var EffectLine = __webpack_require__(85);\r\n\t    var ConnectionPoint = __webpack_require__(86);\r\n\t    var Point = __webpack_require__(66);\r\n\t    var Model = __webpack_require__(87);\r\n\t\r\n\t    Connector.TYPE_STRAIGHT = 'straight';\r\n\t    Connector.TYPE_JAGGED = 'jagged';\r\n\t    Connector.TYPE_CURVE = 'curve';\r\n\t    Connector.TYPE_CHAIN = 'chain';\r\n\t    Connector.RADIUS = 3;\r\n\t    Connector.START_NODE = \"startNode\";\r\n\t    Connector.END_NODE = \"endNode\";\r\n\t    Connector.LEFT = \"left\";\r\n\t    Connector.RIGHT = \"right\";\r\n\t    Connector.TOP = \"top\";\r\n\t    Connector.BOTTOM = \"bottom\";\r\n\t    Connector.BOTTOM = \"bottom\";\r\n\t    Connector.SEPERATOR = \"-\";\r\n\t    Connector.NORMAL_COLOR = \"#000\";\r\n\t    Connector.SELECTED_COLOR = '#74B7E0';\r\n\t    /**\r\n\t     * 构造函数\r\n\t     * @param {[type]} options [description]\r\n\t     */\r\n\t    function Connector(options) {\r\n\t        Node.call(this);\r\n\t        this.opt = options || {};\r\n\t        if (this.opt.model) {\r\n\t            this.resourceId = this.opt.model.get(\"resourceId\");\r\n\t            this.model = this.opt.model;\r\n\t            this.opt = this.opt.model.option;\r\n\t        } else {\r\n\t            this.resourceId = Util.getUUID(); // 生成节点ID\r\n\t            this.model = new Model({});\r\n\t        }\r\n\t        var defaultOptions = {\r\n\t            symbol: { type: \"arrow\", size: 10, color: Connector.NORMAL_COLOR, both:false, offset:0 }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n\t            style: { lineWidth: 1, stroke: Connector.NORMAL_COLOR, lineType: Connector.TYPE_STRAIGHT }, //样式\r\n\t            hoverStyle: { lineWidth: 2, stroke: Connector.SELECTED_COLOR }, //移上去的样式\r\n\t            arrowHoverStyle: { fill: Connector.SELECTED_COLOR},\r\n\t            shape: { points: null, smooth: false, smoothConstraint: null }, //形状\r\n\t            position: { startPos:null, endPos:null,  //指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t                        startOffset:[0,0],  // 起始线段离节点的偏移\r\n\t                        endOffset:[0,0],    // 终止线段离节点的偏移\r\n\t                        escapeDistance:[30,30], // 第一条折线的长度，最后一条折线的长度\r\n\t                        points:null    //不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n\t                    },\r\n\t            autoChangePosition: false,\r\n\t            textContextMenu: null,\r\n\t            isEdit: true, //是否可编辑\r\n\t            text: {\r\n\t                text: null,\r\n\t                textFill: '#000000', // 文本颜色\r\n\t                textFont: '12px Microsoft YaHei',\r\n\t                textPos: 'center',\r\n\t                textRotateable: true\r\n\t            },\r\n\t            z: 0\r\n\t        }\r\n\t\r\n\t        this.options = Util.mergeOpt(defaultOptions, this.opt, true, 'textContextMenu');\r\n\t        this.handles = [];\r\n\t        this.conPointsGroup = new graphic.Group();\r\n\t        this.startNode = null;\r\n\t        this.endNode = null;\r\n\t        this.line = null;\r\n\t        this.groupCurve = new graphic.Group();\r\n\t        this.icons = []; // 用于存储线段上面的操作图标\r\n\t        this.render();\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 重新画线，如果传空则根据turningPoints 重新画线\r\n\t     * @param  {[type]} points [description]\r\n\t     * @return {[type]}        [description]\r\n\t     */\r\n\t    Connector.prototype.refresh = function(arrPoints) {\r\n\t        if (arrPoints) {\r\n\t            this.turningPoints = arrPoints;\r\n\t        }\r\n\t        //将[x:0,y:0]转化为[0, 0]  给zrender使用\r\n\t        var points = Util.traslatePoints(this.turningPoints);\r\n\t\r\n\t        if ((this.options.style.lineType == Connector.TYPE_CURVE) && (points.length > 2)) {\r\n\t            this.modifyCurve(this.turningPoints);\r\n\t        } else {\r\n\t            this.line.attr('shape', { points: points });\r\n\t        }\r\n\t\r\n\t        var lineText = this.childOfName('lineText');\r\n\t        var self = this, lineTextArr = [];\r\n\t        if (this.options.style.lineType == Connector.TYPE_CHAIN && zrUtil.isArray(this.options.text.text)) {\r\n\t            this.options.text.text.forEach(function (v, i) {\r\n\t                lineTextArr.push(self.childOfName('lineText-'+i));\r\n\t            });\r\n\t        } else if (!lineText && this.options.text.text) {\r\n\t            var text = this.drawText(\"lineText\", this.options.text.text, 0, 0);\r\n\t            this.add(text.text);\r\n\t            lineText = this.childOfName('lineText');\r\n\t        }\r\n\t        if (lineTextArr.length > 0) {\r\n\t            var cnt = lineTextArr.length,\r\n\t                distance = this.turningPoints[1].x - this.turningPoints[0].x,\r\n\t                gap = parseInt(distance/cnt),\r\n\t                pos = -(gap) * parseInt(cnt/2);\r\n\t\r\n\t            lineTextArr.forEach(function (v, i) {\r\n\t                var textPoint = self.getTextPostion(self.options.text), way = '';\r\n\t\r\n\t                var rate = self.getTextRotation(textPoint);\r\n\t                if (rate === -0 || rate === 0) {\r\n\t                    rate = 0;\r\n\t                } else {\r\n\t                    way = rate > 0 ? 'plus' : 'minus';\r\n\t                }\r\n\t                rate = Math.abs(rate);\r\n\t                var deg = (180*rate)/Math.PI;\r\n\t                var rotation = null, length = null;\r\n\t                v.setStyle(\"text\", zrUtil.isString(self.options.text.text[i]) ? self.options.text.text[i] : self.options.text.text[i].text);\r\n\t\r\n\t                if (way) {\r\n\t                    rotation = deg > 90 ? ((deg-45)*Math.PI)/180 : ((45+deg)*Math.PI)/180;\r\n\t                    rotation = way === 'minus' ? -(rotation) : rotation;\r\n\t                } else {\r\n\t                    rotation = (45*Math.PI)/180\r\n\t                }\r\n\t                v.attr('rotation', rotation);\r\n\t\r\n\t                if (deg === 90) {\r\n\t                    textPoint[1] -= pos;\r\n\t                } else {\r\n\t                    textPoint[0] += pos;\r\n\t                    if (rate !== 0) {\r\n\t                        length = Math.tan(deg*Math.PI/180)*pos;\r\n\t                        if (pos > 0) {\r\n\t                            textPoint[1] -= way === 'plus' ? length : -(length);\r\n\t                        } else {\r\n\t                            textPoint[1] += way === 'plus' ? -(length) : (length);\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                v.attr(\"position\", textPoint);\r\n\t                pos += gap;\r\n\t            });\r\n\t        }\r\n\t        if (lineText) {\r\n\t            lineText.setStyle(\"text\", this.options.text.text);\r\n\t            var textPoint = this.getTextPostion(this.options.text);\r\n\t            if (this.options.style.lineType == Connector.TYPE_STRAIGHT && this.options.text.textRotateable) { //#187\r\n\t                lineText.attr('rotation', this.getTextRotation(textPoint));\r\n\t            }\r\n\t            lineText.attr(\"position\", textPoint);\r\n\t        }\r\n\t        this.refreshFromToSymbol(points);\r\n\t    };\r\n\t    /**\r\n\t     * 渲染\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.render = function() {\r\n\t        var that = this;\r\n\t        //1.创建箭头\r\n\t        this.renderFromToSymbol();\r\n\t\r\n\t        //2.创建线\r\n\t        this.curveLine = new graphic.BezierCurve({\r\n\t            //position: this.options.position,\r\n\t            style: this.options.style,\r\n\t            z: this.options.z\r\n\t        });\r\n\t        this.groupCurve.add(this.curveLine);\r\n\t        this.add(this.groupCurve);\r\n\t        this.add(this.conPointsGroup);\r\n\t\r\n\t        this.polyLine = new graphic.Polyline({\r\n\t            //position: this.options.position,\r\n\t            shape: this.options.shape,\r\n\t            style: this.options.style,\r\n\t            z: this.options.z\r\n\t        });\r\n\t        this.add(this.polyLine);\r\n\t\r\n\t        if ((this.options.style.lineType == Connector.TYPE_CURVE)) {\r\n\t            this.line = this.groupCurve;\r\n\t            this.createHoverStyle(this.curveLine);\r\n\t            this.polyLine.hide();\r\n\t        } else {\r\n\t            this.line = this.polyLine;\r\n\t            this.createHoverStyle(this.polyLine);\r\n\t            this.curveLine.hide();\r\n\t        }\r\n\t\r\n\t        //3.侦听线事件\r\n\t        var MOUSE_EVENT_NAMES = ['dblclick', 'click']; //'click', 'dblclick', 'mouseover', 'mouseout'\r\n\t        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n\t            this.line.on(eveName, zrUtil.bind(function(e) {\r\n\t                e.cancelBubble = true;\r\n\t                var params = {};\r\n\t                params.event = e;\r\n\t                params.type = \"Connector:\" + eveName;\r\n\t                params.target = that;\r\n\t                this.trigger(params.type, params);\r\n\t                this.setStyle({color:Connector.SELECTED_COLOR},true);\r\n\t                if (this.options.isEdit == false) {\r\n\t                    return; }\r\n\t\r\n\t                if (this.options.isEdit && this.turningPoints.length >= 2) {\r\n\t                    this.createAllconnectionPoint()\r\n\t                }\r\n\t                if (this.handles.length < 1) {\r\n\t                    this.shapeSetHandle();\r\n\t                }\r\n\t\r\n\t            }, this));\r\n\t        }, this);\r\n\t\r\n\t        //4.创建线上文本\r\n\t        if (this.options.text.text) {\r\n\t            var text = null;\r\n\t            if (zrUtil.isArray(this.options.text.text) && this.options.style.lineType == Connector.TYPE_CHAIN) {\r\n\t                this.options.text.text.forEach(function (v, i) {\r\n\t                    var content = that.drawText(\"lineText-\"+i, v, 0, 0);\r\n\t                    if (zrUtil.isString(v)) {\r\n\t                        var obj = {};\r\n\t                        obj.text = v;\r\n\t                        obj.textId = content.text.id;\r\n\t                        that.options.text.text[i] = obj;\r\n\t                    } else {\r\n\t                        that.options.text.text[i].textId = content.text.id;\r\n\t                    }\r\n\t                    that.add(content.text);\r\n\t                    if(content && that.opt.textContextMenu) {\r\n\t                        var textContextMenu = that.opt.textContextMenu;\r\n\t                        content.text.on(\"contextmenu\",function(e) {\r\n\t                            e.event.preventDefault();\r\n\t                            e.event.stopPropagation();\r\n\t                            textContextMenu.buildMenu(e.event,this);\r\n\t                        })\r\n\t                    }\r\n\t                });\r\n\t            } else {\r\n\t                text = this.drawText(\"lineText\", this.options.text.text, 0, 0);\r\n\t                this.add(text.text);\r\n\t            }\r\n\t            if(text && this.opt.textContextMenu) {\r\n\t                var textContextMenu = this.opt.textContextMenu;\r\n\t                text.text.on(\"contextmenu\",function(e) {\r\n\t                    e.event.preventDefault();\r\n\t                    e.event.stopPropagation();\r\n\t                    textContextMenu.buildMenu(e.event,this);\r\n\t                })\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    Connector.prototype.renderFromToSymbol = function(options) {\r\n\t        var symbolTo = this.createSymbol('toSymbol', this.options); //arrow,triangle\r\n\t        if (symbolTo) {\r\n\t            this.add(symbolTo);\r\n\t        }\r\n\t        //如果双向箭头 则再创建首箭头\r\n\t        if (this.options.symbol.both) {\r\n\t            var symbolFrom = this.createSymbol('fromSymbol', this.options); //arrow,triangle\r\n\t            if (symbolFrom) {\r\n\t                this.add(symbolFrom);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    Connector.prototype.refreshFromToSymbol = function(points) {\r\n\t        var symbolTo = this.childOfName('toSymbol');\r\n\t        var symbolFrom = this.childOfName('fromSymbol');\r\n\t        var position = [], offset = this.options.symbol.offset;\r\n\t        if (symbolTo) {\r\n\t            if (this.options.effect && this.options.effect.show) {\r\n\t                new EffectLine(symbolTo, this.options, this.groupCurve, this.polyLine);\r\n\t            } else {\r\n\t                position = points[points.length - 1];\r\n\t                if (this.options.style.lineType !== Connector.TYPE_CURVE) {\r\n\t                    var distance = vec2.distance(points[points.length - 1], points[points.length - 2]);\r\n\t                    if (offset <= distance) {\r\n\t                        position = vec2.lerp(\r\n\t                            [], points[points.length - 1], points[points.length - 2],\r\n\t                            offset / distance);\r\n\t                    } else {\r\n\t                        position = points[points.length - 1];\r\n\t                    }\r\n\t                }\r\n\t                symbolTo.attr('position', position);\r\n\t                symbolTo.attr('rotation', Util.tangentRotation(this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]));\r\n\t            }\r\n\t        }\r\n\t\r\n\t        if (symbolFrom) {\r\n\t            position = points[0];\r\n\t            if (this.options.style.lineType !== Connector.TYPE_CURVE) {\r\n\t                var distanceFrom = vec2.distance(points[0], points[1]);\r\n\t                if (offset <= distanceFrom) {\r\n\t                    position = vec2.lerp(\r\n\t                        [], points[0], points[1],\r\n\t                        offset / distanceFrom);\r\n\t                } else {\r\n\t                    position = points[0];\r\n\t                }\r\n\t            }\r\n\t            symbolFrom.attr('position', position);\r\n\t            symbolFrom.attr('rotation', Util.tangentRotation(this.turningPoints[1], this.turningPoints[0]));\r\n\t        }\r\n\t    }\r\n\t    /**\r\n\t     * 设置style\r\n\t     * @param {object} options 样式对象\r\n\t     * @param {boolean} notSaveModel 设置样式是否保存到模型中,默认是false\r\n\t     */\r\n\t    Connector.prototype.setStyle = function(options,notSaveModel) {\r\n\t        var symbolTo = null;\r\n\t        if (options.color) {\r\n\t            if (this.options.style.lineType == Connector.TYPE_CURVE) {\r\n\t                this.groupCurve.eachChild(function(curve) {\r\n\t                    curve.attr(\"style\", { stroke: options.color });\r\n\t                    graphic.setNormalStyle(curve, { stroke: options.color });\r\n\t                });\r\n\t            } else {\r\n\t                this.polyLine.attr(\"style\", { stroke: options.color });\r\n\t                graphic.setNormalStyle(this.polyLine, { stroke: options.color });\r\n\t            }\r\n\t            symbolTo = this.childOfName('toSymbol');\r\n\t            if (symbolTo) {\r\n\t                symbolTo.attr(\"style\", { fill: options.color });\r\n\t                graphic.setNormalStyle(symbolTo, { fill: options.color });\r\n\t            }\r\n\t            if(!notSaveModel) {\r\n\t                this.options.style.stroke = options.color;\r\n\t                this.model.set(\"options.style.stroke\", options.color);\r\n\t                this.model.set(\"options.symbol.color\", options.color);\r\n\t                this.options.symbol.color = options.color;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        if (options.text) {\r\n\t            var lineText = this.childOfName('lineText');\r\n\t            //开始没有创建文本，后来传进来text了，需要先创建文本\r\n\t            if (!lineText && options.text.text) {\r\n\t                var text = this.drawText(\"lineText\", options.text.text, 0, 0);\r\n\t                this.add(text.text);\r\n\t                lineText = this.childOfName('lineText');\r\n\t            }\r\n\t\r\n\t            if (options.text.text || options.text.text == \"\") {\r\n\t                lineText.setStyle(\"text\", options.text.text);\r\n\t                this.options.text.text = options.text.text;\r\n\t            }\r\n\t            var textPoint = this.getTextPostion(options.text);\r\n\t            lineText.attr(\"position\", textPoint);\r\n\t            if (options.text.textPos) {\r\n\t                this.options.text.textPos = options.text.textPos;\r\n\t            }\r\n\t            if (options.text.offset) { //#187\r\n\t                this.options.text.offset = options.text.offset;\r\n\t            }\r\n\t\r\n\t            if (options.text.color) {\r\n\t                lineText.attr(\"style\", {\r\n\t                    textFill: options.text.color\r\n\t                });\r\n\t                this.options.text.textFill = options.text.color;\r\n\t            }\r\n\t\r\n\t            if (options.text.textFont) {\r\n\t                lineText.attr(\"style\", {\r\n\t                    textFont:options.text.textFont\r\n\t                });\r\n\t                this.options.text.textFont = options.text.textFont;\r\n\t            }\r\n\t\r\n\t            if (options.text.textFill) {\r\n\t                lineText.attr(\"style\", {\r\n\t                    textFill: options.text.textFill\r\n\t                });\r\n\t                this.options.text.textFill = options.text.textFill;\r\n\t            }\r\n\t            this.model.set(\"options.text\", options.text);\r\n\t        }\r\n\t\r\n\t        if (options.symbol) {\r\n\t            if (options.symbol.type) {\r\n\t                this.options.symbol.type = options.symbol.type;\r\n\t                this.model.set(\"options.symbol.type\", options.symbol.type);\r\n\t            }\r\n\t            if (options.symbol.size) {\r\n\t                this.options.symbol.size = options.symbol.size;\r\n\t                this.model.set(\"options.symbol.size\", options.symbol.size);\r\n\t            }\r\n\t            if (options.symbol.color) {\r\n\t                this.options.symbol.color = options.symbol.color;\r\n\t                this.model.set(\"options.symbol.color\", options.symbol.color);\r\n\t            }\r\n\t            if (options.symbol.z) {\r\n\t                this.options.symbol.z = options.symbol.z;\r\n\t                this.model.set(\"options.symbol.z\", options.symbol.z);\r\n\t            }\r\n\t\r\n\t            symbolTo = this.childOfName('toSymbol');\r\n\t            if (symbolTo) {\r\n\t                this.remove(symbolTo);\r\n\t            }\r\n\t            var symbol = this.createSymbol(\"toSymbol\", this.model.get(\"options\"))\r\n\t            if (symbol) {\r\n\t                this.add(symbol);\r\n\t            }\r\n\t            this.refresh();\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 获取线段的位置\r\n\t     * @param  {Object} text {text:'', color:'', textPos:''}\r\n\t     * @return {Object}      {x,y}\r\n\t     */\r\n\t    Connector.prototype.getTextPostion = function(text) {\r\n\t        var textPostion = [];\r\n\t        var textWidth = graphic.textContain.getWidth(text.text, text.textFont);\r\n\t        if (text && text.textPos) {\r\n\t            var offset = text.offset || 0;\r\n\t            var arrOffset = offset;\r\n\t            if (!zrUtil.isArray(offset)) {\r\n\t                arrOffset = [offset, 0];\r\n\t            }\r\n\t            if (text.textPos == 'start') {\r\n\t                textPostion = [this.turningPoints[0].x + arrOffset[0], this.turningPoints[0].y + arrOffset[1]];\r\n\t            } else if (text.textPos == 'end') {\r\n\t                var points = Util.getMaxLineLength([this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]]);\r\n\t                var angle = Util.getAngle(points[0], points[1]);\r\n\t                var length = Util.distance(points[0], points[1]) - textWidth;\r\n\t                var newPoint = Util.getEndPoint(points[0], length, angle);\r\n\t                textPostion = [newPoint.x + arrOffset[0], newPoint.y + arrOffset[1]];\r\n\t            } else {\r\n\t                var midPoint = this.middle(text);\r\n\t                textPostion = [midPoint[0] + arrOffset[0], midPoint[1] + arrOffset[1]];\r\n\t            }\r\n\t        } else {\r\n\t            var position = this.middle(text);\r\n\t            textPostion = [position[0] - textWidth / 2, position[1]];\r\n\t        }\r\n\t\r\n\t        return textPostion;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 获取线段的旋转角度\r\n\t     * @param  {Object} textPostion {x,y}\r\n\t     * @return {Number}             角度值\r\n\t     */\r\n\t    Connector.prototype.getTextRotation = function(textPostion) {\r\n\t        //计算出极坐标的角度\r\n\t        var points = Util.getMaxLineLength(this.turningPoints);\r\n\t        var angle = -Math.atan2(points[1].y - textPostion[1], points[1].x - textPostion[0]); //,Math.PI/2\r\n\t        return angle;\r\n\t    };\r\n\t\r\n\t    Connector.prototype.createHoverStyle = function(el) {\r\n\t        if (this.options.hoverStyle) {\r\n\t            graphic.setElementHoverStl(el, this.options.hoverStyle);\r\n\t\r\n\t            var symbolTo = this.childOfName('toSymbol');\r\n\t            if (symbolTo) { graphic.setElementHoverStl(symbolTo, this.options.arrowHoverStyle); }\r\n\t\r\n\t            el.on('mouseover', zrUtil.bind(function() {\r\n\t                    graphic.doEnterHover(el);\r\n\t                    if (symbolTo) { graphic.doEnterHover(symbolTo); }\r\n\t\r\n\t                    this.groupCurve.eachChild(function(line) {\r\n\t                        graphic.doEnterHover(line);\r\n\t                    });\r\n\t                }, this))\r\n\t                .on('mouseout', zrUtil.bind(function() {\r\n\t                    graphic.doLeaveHover(el);\r\n\t                    if (symbolTo) { graphic.doLeaveHover(symbolTo); }\r\n\t                    this.groupCurve.eachChild(function(line) {\r\n\t                        graphic.doLeaveHover(line);\r\n\t                    });\r\n\t                }, this));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 创建Node的连接点\r\n\t     * @private\r\n\t     *\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.createAllconnectionPoint = function() {\r\n\t        this.connectionPointCreate(this, this.turningPoints[0].clone(), ConnectionPoint.TYPE_CONNECTOR);\r\n\t        this.connectionPointCreate(this, this.turningPoints[this.turningPoints.length - 1].clone(), ConnectionPoint.TYPE_CONNECTOR);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建连接点\r\n\t     * @private\r\n\t     * @param  {[type]} shape [description]\r\n\t     * @param  {[type]} point [description]\r\n\t     * @param  {[type]} type  [description]\r\n\t     * @return {[type]}       [description]\r\n\t     */\r\n\t    Connector.prototype.connectionPointCreate = function(shape, point, type) {\r\n\t        var conPoint = new ConnectionPoint(this, point, type, this.options);\r\n\t        this.conPointsGroup.add(conPoint.shape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 清空控制点\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.clearHandles = function() {\r\n\t        for (var i = 0; i < this.handles.length; i++) {\r\n\t            this.remove(this.handles[i].handleShape);\r\n\t        }\r\n\t        this.handles = [];\r\n\t        if (this.conPointsGroup) {\r\n\t            this.conPointsGroup.removeAll();\r\n\t        }\r\n\t        //恢复原来的颜色\r\n\t        this.setStyle({color:this.options.style.stroke},true);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建拆线 线断的控制点\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.shapeSetHandle = function() {\r\n\t        for (var i = 1; i < this.turningPoints.length - 2; i++) {\r\n\t            var h;\r\n\t            var x, y;\r\n\t            //是否在一条线上\r\n\t            var isCollineaityFirst = Util.collinearity(this.turningPoints[i - 1], this.turningPoints[i], this.turningPoints[i + 1]);\r\n\t            var isCollineaitySecond = Util.collinearity(this.turningPoints[i], this.turningPoints[i + 1], this.turningPoints[i + 2]);\r\n\t            if ((!isCollineaityFirst && (!isCollineaitySecond || this.turningPoints[i + 1].equals(this.turningPoints[i + 2]))) || ((!isCollineaityFirst || this.turningPoints[i - 1].equals(this.turningPoints[i])) && !isCollineaitySecond)) {\r\n\t\r\n\t                if (this.turningPoints[i].x === this.turningPoints[i + 1].x) { //same vertical\r\n\t                    x = this.turningPoints[i].x;\r\n\t                    y = (this.turningPoints[i].y + this.turningPoints[i + 1].y) / 2;\r\n\t\r\n\t                    h = new Handle('h', x, y, this);\r\n\t\r\n\t\r\n\t                } else if (this.turningPoints[i].y === this.turningPoints[i + 1].y) { // same horizontal\r\n\t                    x = (this.turningPoints[i].x + this.turningPoints[i + 1].x) / 2;\r\n\t                    y = this.turningPoints[i].y;\r\n\t                    h = new Handle('v', x, y, this);\r\n\t                }\r\n\t                if (h) {\r\n\t                    this.add(h.handleShape);\r\n\t                    this.handles.push(h);\r\n\t                }\r\n\t\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 创建箭头\r\n\t     * @param  {[type]} name       [description]\r\n\t     * @param  {[type]} options [description]\r\n\t     * @return {[type]}            [description]\r\n\t     */\r\n\t    Connector.prototype.createSymbol = function(name, options) {\r\n\t        var symbolType = options.symbol.type;\r\n\t        var symbolSize = options.symbol.size;\r\n\t        if (symbolType === 'none') {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        if (!zrUtil.isArray(symbolSize)) {\r\n\t            symbolSize = [symbolSize, symbolSize];\r\n\t        }\r\n\t\r\n\t        var symbolZIndex = options.z;\r\n\t\r\n\t        if (options.symbol.z) { symbolZIndex = options.symbol.z }\r\n\t\r\n\t        var symbolPath = symbolUtil.createSymbol(\r\n\t            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,\r\n\t            symbolSize[0], symbolSize[1], symbolZIndex, options.symbol.color\r\n\t        );\r\n\t        symbolPath.name = name;\r\n\t\r\n\t        return symbolPath;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 绘制线段上的文本\r\n\t     * @param  {[type]} content [description]\r\n\t     * @param  {[type]} name [description]\r\n\t     * @param  {[type]} x       [description]\r\n\t     * @param  {[type]} y       [description]\r\n\t     * @param  {[type]} color   [description]\r\n\t     * @return {[type]}         [description]\r\n\t     */\r\n\t    Connector.prototype.drawText = function(name, content, x, y, color) {\r\n\t        var opt = zrUtil.isString(content) ? {text:content, x:x, y:y, fill:color}\r\n\t                                           : zrUtil.defaults({x:x, y:y, fill:color}, content, true);\r\n\t\r\n\t        var textStyle = zrUtil.defaults(zrUtil.clone(this.options.text), opt, true);\r\n\t        var text = new graphic.Text({\r\n\t            style: textStyle,\r\n\t            zlevel: 20,\r\n\t            name : name\r\n\t        });\r\n\t        return {\r\n\t            text: text,\r\n\t            rect: text.getBoundingRect()\r\n\t        };\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 获取线段的中间值\r\n\t     * @return {[type]} text\r\n\t     */\r\n\t    Connector.prototype.middle = function() {\r\n\t\r\n\t        if (this.options.style.lineType == Connector.TYPE_STRAIGHT || this.options.style.lineType == Connector.TYPE_CHAIN) {\r\n\t            var points = Util.getMaxLineLength(this.turningPoints);\r\n\t            //如果是求线段上的文字的中间值\r\n\t            // if(text) {\r\n\t            //     //取出字的长度，计算角度，\r\n\t            //     var textWidth = graphic.textContain.getWidth(text.text, text.textFont);\r\n\t            //     var angle = Util.getAngle(points[0],points[1]);\r\n\t            //     var length =  Util.distance(points[0],points[1])/2 - textWidth/2;\r\n\t            //     var newPoint = Util.getEndPoint(points[0], length, angle);\r\n\t            //     return [newPoint.x, newPoint.y];\r\n\t            // } else {\r\n\t            //     var middleX = (points[0].x + points[1].x)/2;\r\n\t            //     var middleY = (points[0].y + points[1].y) /2;\r\n\t            //     return [middleX, middleY];\r\n\t            // }\r\n\t            var middleX = (points[0].x + points[1].x) / 2;\r\n\t            var middleY = (points[0].y + points[1].y) / 2;\r\n\t            return [middleX, middleY];\r\n\t        } else if (this.options.style.lineType == Connector.TYPE_JAGGED) {\r\n\t\r\n\t            //find total distance\r\n\t            var distance = this.getLength();\r\n\t\r\n\t            //find between what turning points the half distance is\r\n\t            var index = -1;\r\n\t            var ellapsedDistance = 0;\r\n\t            for (var i = 0; i < this.turningPoints.length - 1; i++) {\r\n\t                index = i;\r\n\t                var segment = Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);\r\n\t                if (ellapsedDistance + segment < distance / 2) {\r\n\t                    ellapsedDistance += segment;\r\n\t                } else {\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t\r\n\t            //we have the middle distance somewhere between i(ndex) and i(ndex)+1\r\n\t            if (index != -1) {\r\n\t                var missingDistance = distance / 2 - ellapsedDistance;\r\n\t                if (Util.round(this.turningPoints[index].x, 3) == Util.round(this.turningPoints[index + 1].x, 3)) { //vertical segment (same x)\r\n\t                    return [this.turningPoints[index].x, Math.min(this.turningPoints[index].y, this.turningPoints[index + 1].y) + missingDistance];\r\n\t                } else if (Util.round(this.turningPoints[index].y, 3) == Util.round(this.turningPoints[index + 1].y, 3)) { //horizontal segment (same y)\r\n\t                    return [Math.min(this.turningPoints[index].x, this.turningPoints[index + 1].x) + missingDistance, this.turningPoints[index].y];\r\n\t                } else {\r\n\t                    console.error(\"Connector:middle() - this should never happen \" + this.turningPoints[index] + \" \" + this.turningPoints[index + 1] + \" nr of points \" + this.turningPoints.length);\r\n\t                }\r\n\t\r\n\t            }\r\n\t        } else if (this.options.style.lineType == Connector.TYPE_CURVE) {\r\n\t            var t = 0.5;\r\n\t            var l = this.getLength();\r\n\t\r\n\t            var walked = 0;\r\n\t            for (var j = 0; j < this.turningPoints.length - 1; j++) {\r\n\t                if (walked + Util.distance(this.turningPoints[j], this.turningPoints[j + 1]) > l * t) {\r\n\t                    break;\r\n\t                }\r\n\t\r\n\t                walked += Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);\r\n\t            }\r\n\t\r\n\t            var rest = l * t - walked;\r\n\t            var currentSegmentLength = Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);\r\n\t\r\n\t            //find the position/ration of the middle of Polyline on current segment\r\n\t            var segmentPercent = rest / currentSegmentLength;\r\n\t\r\n\t            var Xp = segmentPercent * (this.turningPoints[j + 1].x - this.turningPoints[j].x) + this.turningPoints[j].x;\r\n\t            var Yp = segmentPercent * (this.turningPoints[j + 1].y - this.turningPoints[j].y) + this.turningPoints[j].y;\r\n\t\r\n\t            return [Xp, Yp];\r\n\t\r\n\t        }\r\n\t\r\n\t        return null;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * find total distance\r\n\t     * @return {Number} [description]\r\n\t     */\r\n\t    Connector.prototype.getLength = function() {\r\n\t        //find total distance\r\n\t        var distance = 0;\r\n\t        for (var i = 0; i < this.turningPoints.length - 1; i++) {\r\n\t            distance += Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);\r\n\t        }\r\n\t        return distance;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 转JSON对象 bpmn使用\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.toJSON = function() {\r\n\t\r\n\t        this.model.set(\"resourceId\", this.resourceId);\r\n\t        this.model.set(\"properties.type\", 14);\r\n\t\r\n\t        this.model.set(\"bounds.upperLeft.x\", this.position[0]);\r\n\t        this.model.set(\"bounds.upperLeft.y\", this.position[1]);\r\n\t        this.model.set(\"bounds.lowerRight.x\", parseInt(this.position[0] + this.getBoundingRect().width));\r\n\t        this.model.set(\"bounds.lowerRight.y\", parseInt(this.position[1] + this.getBoundingRect().height));\r\n\t        this.model.set(\"style.sPos\", this.options.position.startPos);\r\n\t        this.model.set(\"style.ePos\", this.options.position.endPos);\r\n\t        this.model.set(\"style.lineDash\", this.options.style.lineDash);\r\n\t        this.model.set(\"style.stroke\", this.options.style.stroke);\r\n\t        this.model.set(\"symbol.type\", this.options.symbol.type);\r\n\t        this.model.set(\"dockers\", this.turningPoints);\r\n\t        return this.model.option;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * refreshModel  flow当序列化的时候调用 更新线段的位置 及线上的icons\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.refreshModel = function() {\r\n\t        this.model.set(\"options\", zrUtil.clone(this.options));\r\n\t        this.model.set(\"options.dockers\", this.turningPoints);\r\n\t        var icons = [];\r\n\t        for (var i = 0; i < this.icons.length; i++) {\r\n\t            var iconNode = this.icons[i];\r\n\t            var option = [iconNode.key, {\r\n\t                icon: iconNode.style.image,\r\n\t                width: iconNode.style.width,\r\n\t                height: iconNode.style.height\r\n\t            }];\r\n\t            icons.push(option);\r\n\t        }\r\n\t        this.model.set(\"icons\", icons);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 调整曲线的形状\r\n\t     * @param  {array} points 点数组\r\n\t     * @return {void}\r\n\t     */\r\n\t    Connector.prototype.modifyCurve = function(points) {\r\n\t        var sol = this.getCurvePoint(points);\r\n\t\r\n\t        // 1. 如果曲线的数量 比数量的中数量要少 则删除多余的线段\r\n\t        var willDelCurves = [];\r\n\t        for (var j = sol.length, cntCurve = this.groupCurve.childCount(); j < cntCurve; j++) {\r\n\t            willDelCurves.push(this.groupCurve.childAt(j));\r\n\t        }\r\n\t        zrUtil.each(willDelCurves, function(curve) {\r\n\t            this.groupCurve.remove(curve);\r\n\t        }, this);\r\n\t        // 2. 遍历曲线   如果存在则直接设置形状，否则创建\r\n\t        for (var i = 0; i < sol.length; i++) {\r\n\t            var line = this.groupCurve.childAt(i);\r\n\t            if (line) {\r\n\t                line.attr('shape', sol[i]);\r\n\t            } else {\r\n\t                var cure = new graphic.BezierCurve({\r\n\t                   // position: this.options.position,\r\n\t                    style: this.options.style,\r\n\t                    shape: sol[i],\r\n\t                    z: this.options.z\r\n\t                });\r\n\t                this.groupCurve.add(cure);\r\n\t                this.createHoverStyle(cure);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 根据传入的点数组计算曲线的点\r\n\t     * @param  {array} P 点数组\r\n\t     * @return {object}        曲线的点数组\r\n\t     */\r\n\t    Connector.prototype.getCurvePoint = function(P) {\r\n\t        var n = P.length;\r\n\t        var sol = [];\r\n\t        if (n === 3) {\r\n\t            sol.push({\r\n\t                x1: P[0].x,\r\n\t                y1: P[0].y,\r\n\t                cpx1: P[1].x,\r\n\t                cpy1: P[1].y,\r\n\t                x2: P[2].x,\r\n\t                y2: P[2].y\r\n\t            });\r\n\t            return sol;\r\n\t        } else if (n === 4) {\r\n\t            sol.push({\r\n\t                x1: P[0].x,\r\n\t                y1: P[0].y,\r\n\t                cpx1: P[1].x,\r\n\t                cpy1: P[1].y,\r\n\t                cpx2: P[2].x,\r\n\t                cpy2: P[2].y,\r\n\t                x2: P[3].x,\r\n\t                y2: P[3].y\r\n\t            });\r\n\t            return sol;\r\n\t        }\r\n\t\r\n\t\r\n\t        /**Computes the sum between two point\r\n\t         *@param p1 - {Point}\r\n\t         *@param p2 - {Point}\r\n\t         *@return {Point} the sum of initial points\r\n\t         **/\r\n\t        function sum(p1, p2) {\r\n\t            return new Point(p1.x + p2.x, p1.y + p2.y);\r\n\t        }\r\n\t\r\n\t\r\n\t        /**Computes the division of a {Point} by a number\r\n\t         *@param p - {Point}\r\n\t         *@param nr - {Number}\r\n\t         *@return {Point}\r\n\t         **/\r\n\t        function divide(p, nr) {\r\n\t            if (nr == 0) {\r\n\t                throw \"Division by zero not allowed (yet :) \" + this.callee;\r\n\t            }\r\n\t            return new Point(p.x / nr, p.y / nr);\r\n\t        }\r\n\t\r\n\t        /**Computes the multiplication of a {Point} by a number\r\n\t         *@param p - {Point}\r\n\t         *@param nr - {Number}\r\n\t         *@return {Point}\r\n\t         **/\r\n\t        function multiply(p, nr) {\r\n\t            return new Point(p.x * nr, p.y * nr);\r\n\t        }\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t        /*\r\n\t         *I do not get why first 4 must be 0 and last 3 of same value.....\r\n\t         *but otherwise we will get division by zero\r\n\t         */\r\n\t        var k = [0, 0, 0];\r\n\t\r\n\t        var j;\r\n\t        for (j = 0; j <= n - 3; j++) {\r\n\t            k.push(j);\r\n\t        }\r\n\t\r\n\t        k.push(n - 3, n - 3);\r\n\t\r\n\t\r\n\t\r\n\t        for (var i = 1; i <= n - 3; i++) {\r\n\t            //q1 - compute start point\r\n\t            var q1 = divide(sum(multiply(P[i], k[i + 4] - k[i + 2]), multiply(P[i + 1], k[i + 2] - k[i + 1])), k[i + 4] - k[i + 1]);\r\n\t\r\n\t            //q0 - compute 1st controll point\r\n\t            var q_01 = (k[i + 3] - k[i + 2]) / (k[i + 3] - k[i + 1]);\r\n\t            var q_02 = divide(sum(multiply(P[i - 1], k[i + 3] - k[i + 2]), multiply(P[i], k[i + 2] - k[i])), k[i + 3] - k[i]);\r\n\t            var q_03 = multiply(q1, (k[i + 2] - k[i + 1]) / (k[i + 3] - k[i + 1]));\r\n\t            var q0 = sum(multiply(q_02, q_01), q_03);\r\n\t\r\n\t            //q2 - compute 2nd controll point\r\n\t            var q2 = divide(sum(multiply(P[i], k[i + 4] - k[i + 3]), multiply(P[i + 1], k[i + 3] - k[i + 1])), k[i + 4] - k[i + 1]);\r\n\t\r\n\t            //q3 - compute end point\r\n\t            var q_31 = (k[i + 3] - k[i + 2]) / (k[i + 4] - k[i + 2]);\r\n\t            var q_32 = divide(sum(multiply(P[i + 1], k[i + 5] - k[i + 3]), multiply(P[i + 2], k[i + 3] - k[i + 2])), k[i + 5] - k[i + 2]);\r\n\t            var q_33 = multiply(q2, (k[i + 4] - k[i + 3]) / (k[i + 4] - k[i + 2]));\r\n\t            var q3 = sum(multiply(q_32, q_31), q_33);\r\n\t\r\n\t            //store solution\r\n\t            //\r\n\t            sol.push({\r\n\t                x1: q0.x,\r\n\t                y1: q0.y,\r\n\t                cpx1: q1.x,\r\n\t                cpy1: q1.y,\r\n\t                cpx2: q2.x,\r\n\t                cpy2: q2.y,\r\n\t                x2: q3.x,\r\n\t                y2: q3.y\r\n\t            });\r\n\t        }\r\n\t\r\n\t        return sol;\r\n\t    };\r\n\t\r\n\t\r\n\t    Util.inherits(Connector, Node);\r\n\t\r\n\t    module.exports = Connector;\r\n\t\r\n\t\r\n\n\n/***/ }),\n/* 83 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// Symbol factory\r\n\t\r\n\t\r\n\t    var graphic = __webpack_require__(4);\r\n\t    var BoundingRect = __webpack_require__(27);\r\n\t    /**\r\n\t     * Triangle shape\r\n\t     * @inner\r\n\t     */\r\n\t    var Triangle = graphic.extendShape({\r\n\t        type: 'triangle',\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t            cy: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t        buildPath: function (path, shape) {\r\n\t            var cx = shape.cx;\r\n\t            var cy = shape.cy;\r\n\t            var width = shape.width / 2;\r\n\t            var height = shape.height / 2;\r\n\t            path.moveTo(cx, cy - height);\r\n\t            path.lineTo(cx + width, cy + height);\r\n\t            path.lineTo(cx - width, cy + height);\r\n\t            path.closePath();\r\n\t        }\r\n\t    });\r\n\t    /**\r\n\t     * Diamond shape\r\n\t     * @inner\r\n\t     */\r\n\t    var Diamond = graphic.extendShape({\r\n\t        type: 'diamond',\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t            cy: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t        buildPath: function (path, shape) {\r\n\t            var cx = shape.cx;\r\n\t            var cy = shape.cy;\r\n\t            var width = shape.width / 2;\r\n\t            var height = shape.height / 2;\r\n\t            path.moveTo(cx, cy - height);\r\n\t            path.lineTo(cx + width, cy);\r\n\t            path.lineTo(cx, cy + height);\r\n\t            path.lineTo(cx - width, cy);\r\n\t            path.closePath();\r\n\t        }\r\n\t    });\r\n\t\r\n\t    /**\r\n\t     * Pin shape\r\n\t     * @inner\r\n\t     */\r\n\t    var Pin = graphic.extendShape({\r\n\t        type: 'pin',\r\n\t        shape: {\r\n\t            // x, y on the cusp\r\n\t            x: 0,\r\n\t            y: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t\r\n\t        buildPath: function (path, shape) {\r\n\t            var x = shape.x;\r\n\t            var y = shape.y;\r\n\t            var w = shape.width / 5 * 3;\r\n\t            // Height must be larger than width\r\n\t            var h = Math.max(w, shape.height);\r\n\t            var r = w / 2;\r\n\t\r\n\t            // Dist on y with tangent point and circle center\r\n\t            var dy = r * r / (h - r);\r\n\t            var cy = y - h + r + dy;\r\n\t            var angle = Math.asin(dy / r);\r\n\t            // Dist on x with tangent point and circle center\r\n\t            var dx = Math.cos(angle) * r;\r\n\t\r\n\t            var tanX = Math.sin(angle);\r\n\t            var tanY = Math.cos(angle);\r\n\t\r\n\t            path.arc(\r\n\t                x, cy, r,\r\n\t                Math.PI - angle,\r\n\t                Math.PI * 2 + angle\r\n\t            );\r\n\t\r\n\t            var cpLen = r * 0.6;\r\n\t            var cpLen2 = r * 0.7;\r\n\t            path.bezierCurveTo(\r\n\t                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\r\n\t                x, y - cpLen2,\r\n\t                x, y\r\n\t            );\r\n\t            path.bezierCurveTo(\r\n\t                x, y - cpLen2,\r\n\t                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\r\n\t                x - dx, cy + dy\r\n\t            );\r\n\t            path.closePath();\r\n\t        }\r\n\t    });\r\n\t\r\n\t    /**\r\n\t     * Arrow shape\r\n\t     * @inner\r\n\t     */\r\n\t    var Arrow = graphic.extendShape({\r\n\t\r\n\t        type: 'arrow',\r\n\t\r\n\t        shape: {\r\n\t            x: 0,\r\n\t            y: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var height = shape.height;\r\n\t            var width = shape.width;\r\n\t            var x = shape.x;\r\n\t            var y = shape.y;\r\n\t            var dx = width / 3 * 2;\r\n\t            ctx.moveTo(x, y);\r\n\t            ctx.lineTo(x + dx, y + height);\r\n\t            ctx.lineTo(x, y + height / 4 * 3);\r\n\t            ctx.lineTo(x - dx, y + height);\r\n\t            ctx.lineTo(x, y);\r\n\t            ctx.closePath();\r\n\t        }\r\n\t    });\r\n\t\r\n\t    /**\r\n\t     * Map of path contructors\r\n\t     * @type {Object.<string, module:zrender/graphic/Path>}\r\n\t     */\r\n\t    var symbolCtors = {\r\n\t        line: graphic.Line,\r\n\t\r\n\t        rect: graphic.Rect,\r\n\t\r\n\t        roundRect: graphic.Rect,\r\n\t\r\n\t        square: graphic.Rect,\r\n\t\r\n\t        circle: graphic.Circle,\r\n\t\r\n\t        diamond: Diamond,\r\n\t\r\n\t        pin: Pin,\r\n\t\r\n\t        arrow: Arrow,\r\n\t\r\n\t        triangle: Triangle\r\n\t    };\r\n\t\r\n\t    var symbolShapeMakers = {\r\n\t\r\n\t        line: function (x, y, w, h, shape) {\r\n\t            // FIXME\r\n\t            shape.x1 = x;\r\n\t            shape.y1 = y + h / 2;\r\n\t            shape.x2 = x + w;\r\n\t            shape.y2 = y + h / 2;\r\n\t        },\r\n\t\r\n\t        rect: function (x, y, w, h, shape) {\r\n\t            shape.x = x;\r\n\t            shape.y = y;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        },\r\n\t\r\n\t        roundRect: function (x, y, w, h, shape) {\r\n\t            shape.x = x;\r\n\t            shape.y = y;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t            shape.r = Math.min(w, h) / 4;\r\n\t        },\r\n\t\r\n\t        square: function (x, y, w, h, shape) {\r\n\t            var size = Math.min(w, h);\r\n\t            shape.x = x;\r\n\t            shape.y = y;\r\n\t            shape.width = size;\r\n\t            shape.height = size;\r\n\t        },\r\n\t\r\n\t        circle: function (x, y, w, h, shape) {\r\n\t            // Put circle in the center of square\r\n\t            shape.cx = x + w / 2;\r\n\t            shape.cy = y + h / 2;\r\n\t            shape.r = Math.min(w, h) / 2;\r\n\t        },\r\n\t\r\n\t        diamond: function (x, y, w, h, shape) {\r\n\t            shape.cx = x + w / 2;\r\n\t            shape.cy = y + h / 2;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        },\r\n\t\r\n\t        pin: function (x, y, w, h, shape) {\r\n\t            shape.x = x + w / 2;\r\n\t            shape.y = y + h / 2;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        },\r\n\t\r\n\t        arrow: function (x, y, w, h, shape) {\r\n\t            shape.x = x + w / 2;\r\n\t            shape.y = y + h / 2;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        },\r\n\t\r\n\t        triangle: function (x, y, w, h, shape) {\r\n\t            shape.cx = x + w / 2;\r\n\t            shape.cy = y + h / 2;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    var symbolBuildProxies = {};\r\n\t    for (var name in symbolCtors) {\r\n\t        symbolBuildProxies[name] = new symbolCtors[name]();\r\n\t    }\r\n\t\r\n\t    var Symbol = graphic.extendShape({\r\n\t\r\n\t        type: 'symbol',\r\n\t\r\n\t        shape: {\r\n\t            symbolType: '',\r\n\t            x: 0,\r\n\t            y: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t\r\n\t        beforeBrush: function () {\r\n\t            var style = this.style;\r\n\t            var shape = this.shape;\r\n\t            // FIXME\r\n\t            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\r\n\t                style.textPosition = ['50%', '40%'];\r\n\t                style.textAlign = 'center';\r\n\t                style.textVerticalAlign = 'middle';\r\n\t            }\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var symbolType = shape.symbolType;\r\n\t            var proxySymbol = symbolBuildProxies[symbolType];\r\n\t            if (shape.symbolType !== 'none') {\r\n\t                if (!proxySymbol) {\r\n\t                    // Default rect\r\n\t                    symbolType = 'rect';\r\n\t                    proxySymbol = symbolBuildProxies[symbolType];\r\n\t                }\r\n\t                symbolShapeMakers[symbolType](\r\n\t                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\r\n\t                );\r\n\t                proxySymbol.buildPath(ctx, proxySymbol.shape);\r\n\t            }\r\n\t        }\r\n\t    });\r\n\t\r\n\t    // Provide setColor helper method to avoid determine if set the fill or stroke outside\r\n\t    var symbolPathSetColor = function (color) {\r\n\t        if (this.type !== 'image') {\r\n\t            var symbolStyle = this.style;\r\n\t            var symbolShape = this.shape;\r\n\t            if (symbolShape && symbolShape.symbolType === 'line') {\r\n\t                symbolStyle.stroke = color;\r\n\t            }\r\n\t            else if (this.__isEmptyBrush) {\r\n\t                symbolStyle.stroke = color;\r\n\t                symbolStyle.fill = '#fff';\r\n\t            }\r\n\t            else {\r\n\t                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?\r\n\t                symbolStyle.fill && (symbolStyle.fill = color);\r\n\t                symbolStyle.stroke && (symbolStyle.stroke = color);\r\n\t            }\r\n\t            this.dirty();\r\n\t        }\r\n\t    };\r\n\t\r\n\t    var symbolUtil = {\r\n\t        /**\r\n\t         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\r\n\t         * @param {string} symbolType\r\n\t         * @param {number} x\r\n\t         * @param {number} y\r\n\t         * @param {number} w\r\n\t         * @param {number} h\r\n\t         * @param {number} z\r\n\t         * @param {string} color\r\n\t         */\r\n\t        createSymbol: function (symbolType, x, y, w, h, z, color) {\r\n\t            var isEmpty = symbolType.indexOf('empty') === 0;\r\n\t            if (isEmpty) {\r\n\t                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\r\n\t            }\r\n\t            var symbolPath;\r\n\t\r\n\t            if (symbolType.indexOf('image://') === 0) {\r\n\t                symbolPath = new graphic.Image({\r\n\t                    style: {\r\n\t                        image: symbolType.slice(8),\r\n\t                        x: x,\r\n\t                        y: y,\r\n\t                        width: w,\r\n\t                        height: h\r\n\t                    },\r\n\t                    z: z\r\n\t                });\r\n\t            }\r\n\t            else if (symbolType.indexOf('path://') === 0) {\r\n\t                symbolPath = graphic.makePath(symbolType.slice(7), {z: z, rectHover: true}, new BoundingRect(x, y, w, h));\r\n\t            }\r\n\t            else {\r\n\t                symbolPath = new Symbol({\r\n\t                    shape: {\r\n\t                        symbolType: symbolType,\r\n\t                        x: x,\r\n\t                        y: y,\r\n\t                        width: w,\r\n\t                        height: h\r\n\t                    },\r\n\t                    z: z\r\n\t                });\r\n\t            }\r\n\t\r\n\t            symbolPath.__isEmptyBrush = isEmpty;\r\n\t\r\n\t            symbolPath.setColor = symbolPathSetColor;\r\n\t\r\n\t            symbolPath.setColor(color);\r\n\t\r\n\t            return symbolPath;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    module.exports = symbolUtil;\r\n\t\r\n\n\n/***/ }),\n/* 84 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 画句柄\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var graphic = __webpack_require__(4);\r\n\t    var Util = __webpack_require__(65);\r\n\t    function Handle(type, x, y, connector){\r\n\t        this.type = type;\r\n\t\r\n\t        this.x = x;\r\n\t\r\n\t        this.y = y;\r\n\t\r\n\t        this.visible = true;\r\n\t\r\n\t        this.connector = connector;\r\n\t\r\n\t        this.handleShape = new graphic.Circle({\r\n\t            shape: {\r\n\t                cx: x,\r\n\t                cy: y,\r\n\t                r: Handle.RADIUS\r\n\t            },\r\n\t\r\n\t            style: {\r\n\t                fill: \"rgb(0,255,0)\",\r\n\t                stroke:\"rgb(0,0,0)\"\r\n\t            },\r\n\t            z : connector.options.z + 2,  //节点Z为1 线段为0;\r\n\t            draggable:true\r\n\t        });\r\n\t\r\n\t        var that = this;\r\n\t        this.handleShape.on(\"drag\", function(e) {\r\n\t            that.actionConnector(e.offsetX,e.offsetY);\r\n\t        });\r\n\t       // return this.circle;\r\n\t    }\r\n\t\r\n\t    Handle.RADIUS = 4;\r\n\t\r\n\t    Handle.prototype = {\r\n\t\r\n\t        constructor : Handle,\r\n\t\r\n\t        equals : function(anotherHandle){\r\n\t            if(!anotherHandle instanceof Handle){\r\n\t                return false;\r\n\t            }\r\n\t\r\n\t            return this.type == anotherHandle.type\r\n\t            && this.x == anotherHandle.x\r\n\t            && this.y == anotherHandle.y\r\n\t            && this.visible == anotherHandle.visible;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 移动句柄\r\n\t         * @param  {[type]} newX [description]\r\n\t         * @param  {[type]} newY [description]\r\n\t         * @return {[type]}      [description]\r\n\t         */\r\n\t        actionConnector: function(newX, newY){\r\n\t            switch(this.type){\r\n\t                case 'v':\r\n\t                    var index;\r\n\t                    // 找出两个转折点（可移动句柄在这两个转折点中间）\r\n\t                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){\r\n\t                        if(this.connector.turningPoints[i-1].y == this.connector.turningPoints[i].y\r\n\t                            && this.connector.turningPoints[i].y == this.y\r\n\t                            && Math.min(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) <= this.x\r\n\t                            && Math.max(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) >= this.x)\r\n\t                        {\r\n\t                            index = i;\r\n\t                        }\r\n\t                    }\r\n\t                    var deltaY = newY - this.y;\r\n\t                    var translationMatrix = Util.translationMatrix(0, deltaY);\r\n\t\r\n\t                    this.connector.turningPoints[index-1].transform(translationMatrix);\r\n\t                    this.connector.turningPoints[index].transform(translationMatrix);\r\n\t                    this.connector.refresh();\r\n\t                    this.y = newY;  //将句柄新的位置赋值给y\r\n\t\r\n\t                    break;\r\n\t\r\n\t                case 'h':\r\n\t                    var index;\r\n\t                    // 找出两个转折点（可移动句柄在这两个转折点中间）\r\n\t                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){\r\n\t                        if(this.connector.turningPoints[i-1].x == this.connector.turningPoints[i].x\r\n\t                            && this.connector.turningPoints[i].x == this.x\r\n\t                            && Math.min(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) <= this.y\r\n\t                            && Math.max(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) >= this.y)\r\n\t                            {\r\n\t                            index = i;\r\n\t                        }\r\n\t                    }\r\n\t                    var deltaX = newX-this.x;\r\n\t                    var translationMatrix = Util.translationMatrix(deltaX, 0);\r\n\t                    this.connector.turningPoints[index-1].transform(translationMatrix);\r\n\t                    this.connector.turningPoints[index].transform(translationMatrix);\r\n\t                    this.connector.refresh();\r\n\t                    this.x = newX; //将句柄新的位置赋值给x\r\n\t\r\n\t                    break;\r\n\t            }\r\n\t           //. this.shape.updateMiddleText();\r\n\t        }\r\n\t    };\r\n\t    module.exports = Handle;\r\n\t\r\n\t\r\n\t\r\n\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 连线动态效果\r\n\t * @author miao.cunzhi\r\n\t */\r\n\t\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var vec2 = __webpack_require__(15);\r\n\t    var curveUtil = __webpack_require__(31);\r\n\t    var symbolUtil = __webpack_require__(83);\r\n\t\r\n\t    function EffectLine(symbol, options, groupCurve, polyLine) {\r\n\t        this._lastFrame = 0;\r\n\t        this._lastFramePercent = 0;\r\n\t        this.symbol = symbol;\r\n\t        this.groupCurve = groupCurve;\r\n\t        this.initSymbol(options, polyLine);\r\n\t    }\r\n\t    var EffectLineProto = EffectLine.prototype;\r\n\t\r\n\t    EffectLineProto.initSymbol = function(options, polyLine) {\r\n\t        var that = this;\r\n\t        this.symbol.z2 = 100;\r\n\t        this.symbol.culling = true;\r\n\t        var period = options.effect.period * 1000;\r\n\t        this.symbol.__t = 0;\r\n\t        this.symbol.stopAnimation();\r\n\t        if ((options.style.lineType == \"curve\")) {\r\n\t            if (this.groupCurve) {\r\n\t                var i = 0;\r\n\t                period = period / this.groupCurve._children.length;\r\n\t                this.groupCurveAnimate(this.groupCurve._children[0], i, period);\r\n\t            }\r\n\t\r\n\t        } else {\r\n\t            this.symbol.animate('', true)\r\n\t                .when(period, {\r\n\t                    __t: 1\r\n\t                })\r\n\t                .delay(0)\r\n\t                .during(function() {\r\n\t                    that.updateSymbolPositionPolyline();\r\n\t                })\r\n\t                .start();\r\n\t            this.setAnimationPointsPolyline(polyLine.shape.points);\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    EffectLineProto.groupCurveAnimate = function(curveLine, i, period) {\r\n\t        var that = this;\r\n\t        if (curveLine == undefined) {\r\n\t            curveLine = this.groupCurve._children[0];\r\n\t            i = 0;\r\n\t        }\r\n\t        var points;\r\n\t        var pos = curveLine.shape;\r\n\t        points = [\r\n\t            [pos.x1, pos.y1],\r\n\t            [pos.x2, pos.y2],\r\n\t            [pos.cpx1, pos.cpy1],\r\n\t            [pos.cpx2, pos.cpy2]\r\n\t        ];\r\n\t        this.setAnimationPointsBezierCurve(points);\r\n\t        this.symbol.animate('')\r\n\t            .when(period, {\r\n\t                __t: 1\r\n\t            })\r\n\t            .delay(0)\r\n\t            .during(function() {\r\n\t                that.updateSymbolPositionBezierCurve();\r\n\t            })\r\n\t            .done(function() {\r\n\t                that.symbol.__t = 0;\r\n\t                that.groupCurveAnimate(that.groupCurve._children[i + 1], i + 1, period);\r\n\t            })\r\n\t            .start();\r\n\t\r\n\t    };\r\n\t\r\n\t\r\n\t    EffectLineProto.setAnimationPointsBezierCurve = function(points) {\r\n\t        this.symbol.__p1 = points[0];\r\n\t        this.symbol.__p2 = points[1];\r\n\t        this.symbol.__cp1 = points[2] || [\r\n\t            (points[0][0] + points[1][0]) / 2,\r\n\t            (points[0][1] + points[1][1]) / 2\r\n\t        ];\r\n\t        this.symbol.__cp2 = points[3];\r\n\t    };\r\n\t\r\n\t    EffectLineProto.updateSymbolPositionBezierCurve = function() {\r\n\t        var p1 = this.symbol.__p1;\r\n\t        var p2 = this.symbol.__p2;\r\n\t        var cp1 = this.symbol.__cp1;\r\n\t        var cp2 = this.symbol.__cp2;\r\n\t        var t = this.symbol.__t;\r\n\t        var pos = this.symbol.position;\r\n\t        var tx, ty;\r\n\t        if (cp2[0] != undefined) {\r\n\t            var cubicAt = curveUtil.cubicAt;\r\n\t            var cubicDerivativeAt = curveUtil.cubicDerivativeAt;\r\n\t            pos[0] = cubicAt(p1[0], cp1[0], cp2[0], p2[0], t);\r\n\t            pos[1] = cubicAt(p1[1], cp1[1], cp2[1], p2[1], t);\r\n\t            // Tangent\r\n\t            tx = cubicDerivativeAt(p1[0], cp1[0], cp2[0], p2[0], t);\r\n\t            ty = cubicDerivativeAt(p1[1], cp1[1], cp2[1], p2[1], t);\r\n\t        } else {\r\n\t            var quadraticAt = curveUtil.quadraticAt;\r\n\t            var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;\r\n\t            pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);\r\n\t            pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);\r\n\t            // Tangent\r\n\t            tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);\r\n\t            ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);\r\n\t        }\r\n\t        this.symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;\r\n\t\r\n\t        this.symbol.ignore = false;\r\n\t    };\r\n\t\r\n\t    EffectLineProto.setAnimationPointsPolyline = function(points) {\r\n\t        this._points = points;\r\n\t        var accLenArr = [0];\r\n\t        var len = 0;\r\n\t        for (var i = 1; i < points.length; i++) {\r\n\t            var p1 = points[i - 1];\r\n\t            var p2 = points[i];\r\n\t            len += vec2.dist(p1, p2);\r\n\t            accLenArr.push(len);\r\n\t        }\r\n\t        if (len === 0) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        for (var j = 0; j < accLenArr.length; j++) {\r\n\t            accLenArr[j] /= len;\r\n\t        }\r\n\t        this._offsets = accLenArr;\r\n\t        this._length = len;\r\n\t        this.symbol._lastFrame = 0;\r\n\t        this.symbol.__lastFramePercent = 0;\r\n\t    };\r\n\t\r\n\t    EffectLineProto.updateSymbolPositionPolyline = function() {\r\n\t        var t = this.symbol.__t;\r\n\t        var points = this._points;\r\n\t        var offsets = this._offsets;\r\n\t        var len = points.length;\r\n\t\r\n\t        if (!offsets) {\r\n\t            // Has length 0\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var lastFrame = this._lastFrame;\r\n\t        var frame;\r\n\t\r\n\t        if (t < this._lastFramePercent) {\r\n\t            // Start from the next frame\r\n\t            // PENDING start from lastFrame ?\r\n\t            var start = Math.min(lastFrame + 1, len - 1);\r\n\t            for (frame = start; frame >= 0; frame--) {\r\n\t                if (offsets[frame] <= t) {\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t            // PENDING really need to do this ?\r\n\t            frame = Math.min(frame, len - 2);\r\n\t        } else {\r\n\t            for (var frame = lastFrame; frame < len; frame++) {\r\n\t                if (offsets[frame] > t) {\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t            frame = Math.min(frame - 1, len - 2);\r\n\t        }\r\n\t        vec2.lerp(\r\n\t            this.symbol.position, points[frame], points[frame + 1],\r\n\t            (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame])\r\n\t        );\r\n\t\r\n\t        this._lastFrame = frame;\r\n\t        this._lastFramePercent = t;\r\n\t        var angle = -Math.atan2(points[frame + 1][1] - points[frame][1], points[frame + 1][0] - points[frame][0]);\r\n\t        this.symbol.rotation = angle - Math.PI / 2;\r\n\t        this.symbol.ignore = false;\r\n\t    };\r\n\t    module.exports = EffectLine;\r\n\t\r\n\n\n/***/ }),\n/* 86 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 控制点\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var graphic = __webpack_require__(4);\r\n\t    function ConnectionPoint(connector, point, type, options){\r\n\t        this.connector = connector;\r\n\t\r\n\t        this.point = point.clone();\r\n\t\r\n\t        this.type = type;\r\n\t\r\n\t        this.color = ConnectionPoint.NORMAL_COLOR;\r\n\t\r\n\t        this.oType = 'ConnectionPoint';\r\n\t\r\n\t        this.shape = new graphic.Circle({\r\n\t            shape: {\r\n\t                cx: this.point.x,\r\n\t                cy: this.point.y,\r\n\t                r: ConnectionPoint.RADIUS\r\n\t            },\r\n\t\r\n\t            style: {\r\n\t                fill: this.color,\r\n\t                stroke:'#000000'\r\n\t            },\r\n\t            z : options.z + 2  //节点Z为1 线段为0;\r\n\t        });\r\n\t        this.shape.type =  this.type;\r\n\t\r\n\t        this.shape.connector = connector;\r\n\t        //return this.circle;\r\n\t    }\r\n\t\r\n\t    ConnectionPoint.NORMAL_COLOR = \"#FFFF33\"; //yellow.\r\n\t\r\n\t    ConnectionPoint.OVER_COLOR = \"#FF9900\"; //orange\r\n\t\r\n\t    ConnectionPoint.CONNECTED_COLOR = \"#ff0000\"; //red\r\n\t\r\n\t    ConnectionPoint.RADIUS = 4;\r\n\t\r\n\t    ConnectionPoint.TYPE_FIGURE = 'figure';\r\n\t\r\n\t    ConnectionPoint.TYPE_CONNECTOR = 'connector';\r\n\t\r\n\t    ConnectionPoint.prototype = {\r\n\t\r\n\t        constructor : ConnectionPoint,\r\n\t\r\n\t        equals : function(anotherConnectionPoint){\r\n\t            return this.point.equals(anotherConnectionPoint.point)\r\n\t            && this.connector == anotherConnectionPoint.connector\r\n\t            && this.type == anotherConnectionPoint.type\r\n\t            && this.color == anotherConnectionPoint.color\r\n\t            && this.radius == anotherConnectionPoint.radius;\r\n\t        }\r\n\t\r\n\t\r\n\t    };\r\n\t    module.exports = ConnectionPoint;\r\n\t\r\n\t\r\n\t\r\n\n\n/***/ }),\n/* 87 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 节点等的模型\r\n\t * 里面存的数据用来处理序列化和反序列化\r\n\t * @class fish.topo.model\r\n\t */\r\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var clazzUtil = __webpack_require__(88);\r\n\t\r\n\t    function Model(option, parentModel,  extraOpt) {\r\n\t        this.parentModel = parentModel;\r\n\t        this.option = option;\r\n\t\r\n\t        // Simple optimization\r\n\t        if (this.init) {\r\n\t            if (arguments.length <= 3) {\r\n\t                this.init(option, parentModel,  extraOpt);\r\n\t            }\r\n\t            else {\r\n\t                this.init.apply(this, arguments);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    Model.prototype = {\r\n\t\r\n\t        constructor: Model,\r\n\t\r\n\t        /**\r\n\t         * Model 的初始化函数\r\n\t         * @private\r\n\t         * @param {Object} option\r\n\t         */\r\n\t        init: function (option) {\r\n\t            zrUtil.merge(option, this.getDefaultOption());\r\n\t        },\r\n\t\r\n\t        getDefaultOption: function () {\r\n\t            if (!this.hasOwnProperty('__defaultOption')) {\r\n\t                var optList = [];\r\n\t                var Class = this.constructor;\r\n\t                while (Class) {\r\n\t                    var opt = Class.prototype.defaultOption;\r\n\t                    opt && optList.push(opt);\r\n\t                    Class = Class.superClass;\r\n\t                }\r\n\t\r\n\t                var defaultOption = {};\r\n\t                for (var i = optList.length - 1; i >= 0; i--) {\r\n\t                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\r\n\t                }\r\n\t                this.__defaultOption = defaultOption;\r\n\t            }\r\n\t            return this.__defaultOption;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         */\r\n\t        mergeOption: function (option) {\r\n\t            zrUtil.merge(this.option, option, true);\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 获取model的某个属性的值\r\n\t         * @param {string} path model中的属性\r\n\t         * @return {String}\r\n\t         *\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *          node.model.get(\"options.text\");\r\n\t         */\r\n\t        get: function (path, ignoreParent) {\r\n\t            if (!path) {\r\n\t                return this.option;\r\n\t            }\r\n\t\r\n\t            if (typeof path === 'string') {\r\n\t                path = path.split('.');\r\n\t            }\r\n\t\r\n\t            var obj = this.option;\r\n\t            var parentModel = this.parentModel;\r\n\t            for (var i = 0; i < path.length; i++) {\r\n\t                // obj could be number/string/... (like 0)\r\n\t                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;\r\n\t                if (obj == null) {\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t            if (obj == null && parentModel && !ignoreParent) {\r\n\t                obj = parentModel.get(path);\r\n\t            }\r\n\t            return obj;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 设置model的某个属性的值\r\n\t         * @param {string} path model中的属性\r\n\t         * @param {String} value 所需要设置的值\r\n\t         * @return {String}\r\n\t         *\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *          node.model.set(\"options.text\",\"例子\");\r\n\t         */\r\n\t        set: function (path, value) {\r\n\t            var obj = this.option;\r\n\t\r\n\t            if (path.indexOf(\".\") == -1) {\r\n\t                obj[path] = value;\r\n\t            } else {\r\n\t                var fieldArray  = path.split('.');\r\n\t                var n = fieldArray.length;\r\n\t                var currentRef = obj;\r\n\t                var fieldName;\r\n\t\r\n\t                for (var i = 0; i < n - 1; i++) {\r\n\t                    fieldName = fieldArray[i];\r\n\t                    if(currentRef[fieldName] == null) {\r\n\t                        currentRef[fieldName] = {};\r\n\t                    }\r\n\t                    currentRef = currentRef[fieldName];\r\n\t                }\r\n\t                fieldName = fieldArray[n-1];\r\n\t                currentRef[fieldName] = value;\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         */\r\n\t        getShallow: function (key, ignoreParent) {\r\n\t            var option = this.option;\r\n\t            var val = option && option[key];\r\n\t            var parentModel = this.parentModel;\r\n\t            if (val == null && parentModel && !ignoreParent) {\r\n\t                val = parentModel.getShallow(key);\r\n\t            }\r\n\t            return val;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         */\r\n\t        getModel: function (path, parentModel) {\r\n\t            var obj = this.get(path, true);\r\n\t            var thisParentModel = this.parentModel;\r\n\t            var model = new Model(\r\n\t                obj, parentModel || (thisParentModel && thisParentModel.getModel(path))\r\n\t            );\r\n\t            return model;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         *清空model的option\r\n\t         * @private\r\n\t         */\r\n\t        isEmpty: function () {\r\n\t            return this.option == null;\r\n\t        },\r\n\t\r\n\t        restoreData: function () {},\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         */\r\n\t        clone: function () {\r\n\t            var Ctor = this.constructor;\r\n\t            return new Ctor(zrUtil.clone(this.option));\r\n\t        }\r\n\t    };\r\n\t\r\n\t    // Enable Model.extend.\r\n\t    clazzUtil.enableClassExtend(Model);\r\n\t\r\n\t    module.exports = Model;\r\n\t\r\n\n\n/***/ }),\n/* 88 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t\r\n\t    var clazz = {};\r\n\t\r\n\t    var TYPE_DELIMITER = '.';\r\n\t    var IS_CONTAINER = '___FT__COMPONENT__CONTAINER___';\r\n\t    /**\r\n\t     * @public\r\n\t     */\r\n\t    var parseClassType = clazz.parseClassType = function (componentType) {\r\n\t        var ret = {main: '', sub: ''};\r\n\t        if (componentType) {\r\n\t            componentType = componentType.split(TYPE_DELIMITER);\r\n\t            ret.main = componentType[0] || '';\r\n\t            ret.sub = componentType[1] || '';\r\n\t        }\r\n\t        return ret;\r\n\t    };\r\n\t    /**\r\n\t     * @public  相比 直接用zrUtil.inherits 好处是  可以直接调用父类的构造函数\r\n\t     */\r\n\t    clazz.enableClassExtend = function (RootClass, preConstruct) {\r\n\t        RootClass.extend = function (proto) {\r\n\t            var ExtendedClass = function () {\r\n\t                preConstruct && preConstruct.apply(this, arguments);\r\n\t                RootClass.apply(this, arguments);\r\n\t            };\r\n\t\r\n\t            zrUtil.extend(ExtendedClass.prototype, proto);\r\n\t\r\n\t            ExtendedClass.extend = this.extend;\r\n\t            ExtendedClass.superCall = superCall;\r\n\t            ExtendedClass.superApply = superApply;\r\n\t            zrUtil.inherits(ExtendedClass, this);\r\n\t            ExtendedClass.superClass = this;\r\n\t\r\n\t            return ExtendedClass;\r\n\t        };\r\n\t    };\r\n\t\r\n\t    // superCall should have class info, which can not be fetch from 'this'.\r\n\t    // Consider this case:\r\n\t    // class A has method f,\r\n\t    // class B inherits class A, overrides method f, f call superApply('f'),\r\n\t    // class C inherits class B, do not overrides method f,\r\n\t    // then when method of class C is called, dead loop occured.\r\n\t    function superCall(context, methodName) {\r\n\t        var args = zrUtil.slice(arguments, 2);\r\n\t        return this.superClass.prototype[methodName].apply(context, args);\r\n\t    }\r\n\t\r\n\t    function superApply(context, methodName, args) {\r\n\t        return this.superClass.prototype[methodName].apply(context, args);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @param {Object} entity\r\n\t     * @param {Object} options\r\n\t     * @param {boolean} [options.registerWhenExtend]\r\n\t     * @public\r\n\t     */\r\n\t    clazz.enableClassManagement = function (entity, options) {\r\n\t        options = options || {};\r\n\t\r\n\t        /**\r\n\t         * Component model classes\r\n\t         * key: componentType,\r\n\t         * value:\r\n\t         *     componentClass, when componentType is 'xxx'\r\n\t         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\r\n\t         * @type {Object}\r\n\t         */\r\n\t        var storage = {};\r\n\t\r\n\t        entity.registerClass = function (Clazz, componentType) {\r\n\t            if (componentType) {\r\n\t                componentType = parseClassType(componentType);\r\n\t\r\n\t                if (!componentType.sub) {\r\n\t                    if (storage[componentType.main]) {\r\n\t                        //已经注册过了，直接返回\r\n\t                        return;\r\n\t                    }\r\n\t                    storage[componentType.main] = Clazz;\r\n\t                }\r\n\t                else if (componentType.sub !== IS_CONTAINER) {\r\n\t                    var container = makeContainer(componentType);\r\n\t                    container[componentType.sub] = Clazz;\r\n\t                }\r\n\t            }\r\n\t            return Clazz;\r\n\t        };\r\n\t\r\n\t        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\r\n\t            var Clazz = storage[componentTypeMain];\r\n\t\r\n\t            if (Clazz && Clazz[IS_CONTAINER]) {\r\n\t                Clazz = subType ? Clazz[subType] : null;\r\n\t            }\r\n\t\r\n\t            if (throwWhenNotFound && !Clazz) {\r\n\t                throw new Error(\r\n\t                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'\r\n\t                );\r\n\t            }\r\n\t\r\n\t            return Clazz;\r\n\t        };\r\n\t\r\n\t        entity.getClassesByMainType = function (componentType) {\r\n\t            componentType = parseClassType(componentType);\r\n\t\r\n\t            var result = [];\r\n\t            var obj = storage[componentType.main];\r\n\t\r\n\t            if (obj && obj[IS_CONTAINER]) {\r\n\t                zrUtil.each(obj, function (o, type) {\r\n\t                    type !== IS_CONTAINER && result.push(o);\r\n\t                });\r\n\t            }\r\n\t            else {\r\n\t                result.push(obj);\r\n\t            }\r\n\t\r\n\t            return result;\r\n\t        };\r\n\t\r\n\t        entity.hasClass = function (componentType) {\r\n\t            // Just consider componentType.main.\r\n\t            componentType = parseClassType(componentType);\r\n\t            return !!storage[componentType.main];\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\r\n\t         */\r\n\t        entity.getAllClassMainTypes = function () {\r\n\t            var types = [];\r\n\t            zrUtil.each(storage, function (obj, type) {\r\n\t                types.push(type);\r\n\t            });\r\n\t            return types;\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * If a main type is container and has sub types\r\n\t         * @param  {string}  componentType\r\n\t         * @return {boolean}\r\n\t         */\r\n\t        entity.hasSubTypes = function (componentType) {\r\n\t            componentType = parseClassType(componentType);\r\n\t            var obj = storage[componentType.main];\r\n\t            return obj && obj[IS_CONTAINER];\r\n\t        };\r\n\t\r\n\t        entity.parseClassType = parseClassType;\r\n\t\r\n\t        function makeContainer(componentType) {\r\n\t            var container = storage[componentType.main];\r\n\t            if (!container || !container[IS_CONTAINER]) {\r\n\t                container = storage[componentType.main] = {};\r\n\t                container[IS_CONTAINER] = true;\r\n\t            }\r\n\t            return container;\r\n\t        }\r\n\t\r\n\t        if (options.registerWhenExtend) {\r\n\t            var originalExtend = entity.extend;\r\n\t            if (originalExtend) {\r\n\t                entity.extend = function (proto) {\r\n\t                    var ExtendedClass = originalExtend.call(this, proto);\r\n\t                    return entity.registerClass(ExtendedClass, proto.type);\r\n\t                };\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return entity;\r\n\t    };\r\n\t\r\n\t    module.exports = clazz;\r\n\t\r\n\n\n/***/ }),\n/* 89 */\n/***/ (function(module, exports) {\n\n\t/**\r\n\t * 操作图标类\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t\r\n\t    var IconOperation = {\r\n\t        STRAIGHT_SVG: 'M937.353846 724.676923C882.215385 669.538462 795.569231 661.661538 732.553846 701.046154L362.338462 330.830769C401.723077 267.815385 393.846154 181.169231 338.707692 126.030769 267.815385 55.138462 165.415385 55.138462 94.523077 126.030769 23.630769 196.923077 23.630769 299.323077 94.523077 370.215385 149.661538 425.353846 236.307692 433.230769 299.323077 393.846154L669.538462 764.061538C630.153846 827.076923 638.030769 913.723077 693.169231 968.861538 764.061538 1039.753846 866.461538 1039.753846 937.353846 968.861538 1000.369231 897.969231 1000.369231 795.569231 937.353846 724.676923L937.353846 724.676923ZM275.692308 307.2C244.184615 338.707692 189.046154 338.707692 157.538462 307.2 126.030769 275.692308 126.030769 220.553846 157.538462 189.046154 189.046154 157.538462 244.184615 157.538462 275.692308 189.046154 307.2 220.553846 307.2 267.815385 275.692308 307.2L275.692308 307.2ZM874.338462 913.723077C842.830769 945.230769 787.692308 945.230769 756.184615 913.723077 724.676923 882.215385 724.676923 827.076923 756.184615 795.569231 787.692308 764.061538 842.830769 764.061538 874.338462 795.569231 905.846154 827.076923 905.846154 874.338462 874.338462 913.723077L874.338462 913.723077Z',\r\n\t        JAGGED_SVG: 'M204.8 819.2l-51.2-102.4 204.8-307.2 51.2 102.4-204.8 307.2zM409.6 512l51.2-102.4 153.6 204.8-51.2 102.4-153.6-204.8zM819.2 204.8l51.2 102.4-204.8 409.6-51.2-102.4 204.8-409.6z                                    M153.6 716.8c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8H102.4v-102.4h102.4v102.4zM409.6 204.8C322.56 204.8 256 271.36 256 358.4s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8H358.4V307.2h102.4v102.4zM614.4 614.4c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8h-102.4v-102.4h102.4v102.4zM870.4 0c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8h-102.4V102.4h102.4v102.4z',\r\n\t        CURVE_SVG: 'M1014.285039 824.024234l-145.168428-144.37205c-12.969593-12.855825-37.543559-14.505466-44.597197 2.332252-1.877178 4.550734-2.275367 17.179022-2.275368 17.179022v97.556369H330.935383a118.319095 118.319095 0 0 1-118.546632-117.920905A118.319095 118.319095 0 0 1 330.992267 560.878016h445.516899c121.561493 0 220.426198-98.352747 220.426198-219.23163s-98.864705-219.174746-220.426198-219.174746H340.491925A174.236244 174.236244 0 0 0 174.105698 0 173.78117 173.78117 0 0 0 0.040107 173.09856a173.78117 173.78117 0 0 0 174.065591 173.09856 174.236244 174.236244 0 0 0 166.386227-122.471639h436.017241c65.416807 0 118.603516 52.902288 118.603515 117.920905A118.319095 118.319095 0 0 1 776.509166 459.624176H330.992267c-121.504609 0-220.369314 98.352747-220.369314 219.23163s98.864705 219.174746 220.369314 219.174746h491.194895v92.550561s0 14.221045 2.332252 19.795695c7.053638 16.894602 31.627604 17.577212 44.597197 4.664502l145.111543-144.315165a32.879056 32.879056 0 0 0 0-46.645027zM174.105698 244.94328c-39.818926 0-72.242909-32.25333-72.242909-71.84472s32.423983-71.787835 72.242909-71.787835c39.818926 0 72.186025 32.196446 72.186025 71.787835 0 39.591389-32.423983 71.787835-72.242909 71.787836z',\r\n\t        DEL_SVG: 'M980.992 256h-84.992v683.008c0 47.104-37.888 84.992-84.992 84.992H212.992c-47.104 0-84.992-37.888-84.992-84.992V256H43.008C19.456 256 0 236.544 0 212.992c0-23.552 19.456-43.008 43.008-43.008H256V84.992C256 37.888 293.888 0 340.992 0h340.992C730.112 0 768 37.888 768 84.992v84.992h214.016c23.552 0 43.008 19.456 43.008 43.008-1.024 23.552-20.48 43.008-44.032 43.008zM683.008 84.992H340.992v84.992h340.992V84.992zM212.992 939.008h596.992V256H212.992v683.008z m171.008-470.016v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-23.552 19.456-43.008 43.008-43.008 23.552 1.024 43.008 19.456 43.008 43.008zM512 427.008c23.552 0 43.008 19.456 43.008 43.008v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-24.576 19.456-43.008 43.008-43.008z m171.008 0c23.552 0 43.008 19.456 43.008 43.008v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-24.576 19.456-43.008 43.008-43.008z',\r\n\t        COMMENT_SVG: 'M209.92 152.064l572.416 1.536c12.8 0 23.04 10.24 23.04 23.04v237.568c0 12.8 10.24 23.04 23.04 23.04s23.04-10.24 23.04-23.04V125.44c0-12.8-10.24-23.04-23.04-23.04H158.72c-12.8 0-23.04 10.24-23.04 23.04v773.12c0 12.8 10.24 23.04 23.04 23.04h236.032c12.8 0 23.04-10.24 23.04-23.04s-10.24-22.528-22.528-23.04l-185.856-1.536c-12.8 0-22.528-10.24-22.528-23.04V174.592c0-12.288 10.24-22.528 23.04-22.528z                                            M268.8 570.368h159.232c13.312 0 24.064 10.752 24.576 24.064v2.56c0 13.312-10.752 24.576-24.576 24.576H268.8c-13.312 0-24.064-10.752-24.576-24.064v-2.56c0.512-13.312 11.264-24.576 24.576-24.576z m0-312.32h441.344c13.312 0 24.576 10.752 24.576 24.576v2.56c0 13.312-10.752 24.576-24.576 24.576H268.8c-13.312 0-24.576-10.752-24.576-24.576v-2.56c0.512-13.312 11.264-24.576 24.576-24.576z m0.512 155.648h269.312c13.312 0 24.576 10.752 24.576 24.064v2.56c0 13.312-10.752 24.576-24.576 24.576H269.312c-13.312 0-24.576-10.752-24.576-24.064v-2.56c0-13.824 10.752-24.576 24.576-24.576z m471.04 13.312l-246.784 339.456c-1.536 2.56-2.56 5.632-2.56 8.704l-1.536 132.096c0 9.728 9.728 16.896 18.944 14.336l122.88-37.888c3.072-1.024 5.632-3.072 7.68-5.632l246.784-338.944c4.608-6.144 3.584-15.36-2.56-19.968l-121.344-94.72c-7.168-5.632-16.896-4.096-21.504 2.56z m23.04 67.584l51.2 39.936c2.048 1.536 2.56 5.12 1.024 7.168l-26.112 35.84c-1.536 2.56-5.12 3.072-7.68 1.024l-51.712-38.912c-2.048-1.536-2.56-4.608-1.024-7.168l26.624-37.376c2.048-1.536 5.632-2.048 7.68-0.512z m-165.888 341.504l-35.328 10.752c-9.216 3.072-18.944-4.096-18.944-13.824l0.512-40.96c0-3.072 1.024-6.144 2.56-8.704l137.216-187.904c1.536-2.56 5.12-2.56 7.168-1.024l51.2 38.4c2.56 2.048 3.072 5.12 1.024 7.68l-137.728 189.952c-2.048 2.56-4.608 4.608-7.68 5.632z',\r\n\t        CHANGE_LINE_TYPE_SVG: 'M1008 335.2 1008 335.2l-160 144 0 0c-8.8 8-20 12.8-32 12.8-26.4 0-48-21.6-48-48 0-14.4 6.4-26.4 16-35.2l0 0 67.2-60L560 348.8c0 0 0 0 0 0L464 348.8l0 0L352 348.8 48 348.8c-26.4 0-48-21.6-48-48 0-26.4 21.6-48 48-48l124.8 0 0 0L416 252.8l0 0 208 0 0 0 227.2 0L784 192l0 0c-9.6-8.8-16-21.6-16-35.2 0-26.4 21.6-48 48-48 12 0 23.2 4.8 32 12.8l0 0 160 144 0 0c9.6 8.8 16 21.6 16 35.2C1024 314.4 1017.6 326.4 1008 335.2zM16 680.8 16 680.8l160-144 0 0c8.8-8 20-12.8 32-12.8 26.4 0 48 21.6 48 48 0 14.4-6.4 26.4-16 35.2l0 0-67.2 60L400 667.2l0 0 208 0 0 0 243.2 0 0 0L976 667.2c26.4 0 48 21.6 48 48 0 26.4-21.6 48-48 48L672 763.2 560 763.2c0 0 0 0 0 0L464 763.2l0 0L172.8 763.2 240 824l0 0c9.6 8.8 16 21.6 16 35.2 0 26.4-21.6 48-48 48-12 0-23.2-4.8-32-12.8l0 0L16 752l0 0c-9.6-8.8-16-21.6-16-35.2C0 701.6 6.4 689.6 16 680.8z'\r\n\t    }\r\n\t    module.exports = IconOperation;\r\n\n\n/***/ }),\n/* 90 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * flow连线管理类\r\n\t * @author miao.cunzhi\r\n\t */\r\n\t\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var ConnectionManager = __webpack_require__(91);\r\n\t    var Connector = __webpack_require__(82);\r\n\t    var Util = __webpack_require__(65);\r\n\t    var Point = __webpack_require__(66);\r\n\t    var Constants = __webpack_require__(93);\r\n\t\r\n\t    function FlowConnectionManager(api) {\r\n\t        ConnectionManager.call(this);\r\n\t        this.bundleOffset = 30; //多线段的偏移\r\n\t        this.bundleGap = 20; // 多线段的间隔\r\n\t        this.connectorMap = Util.StackedMap.createNew(); //存放多线段\r\n\t        this._api = api;\r\n\t    }\r\n\t\r\n\t    FlowConnectionManager.prototype.add = function(connector) {\r\n\t        this.connectors.push(connector);\r\n\t        //1.处理事件\r\n\t        this.handleConnectorEvent(connector);\r\n\t        //2.判断是否两节点相联\r\n\t        if(connector.startNode && connector.endNode) {\r\n\t            var key = this.getTwoNodeId(connector.startNode, connector.endNode, connector.options.position);\r\n\t            this.connectorMap.add(key, connector);\r\n\t\r\n\t            this.handleConnectorShrink(connector);\r\n\t\r\n\t            this.bundleOffset = connector.options.bundleOffset || this.bundleOffset;\r\n\t            this.bundleGap = connector.options.bundleGap || this.bundleGap;\r\n\t            //2. 获取这个key对应的线段数组\r\n\t            var arrCons = this.connectorMap.get(key);\r\n\t            if (arrCons.length == 1) {\r\n\t                //两个节点只有一个连线的情况\r\n\t                //判断一下 model里有没有dockers，如果有则调用构造point数组  或者调用refreshConnector计算如何画线\r\n\t                var dockers = connector.options.dockers;\r\n\t                var points = [];\r\n\t                if (dockers && dockers.length >= 2) {\r\n\t                    points = Point.loadArray(dockers);\r\n\t                    connector.refresh(points);\r\n\t                } else {\r\n\t                    if (connector.options.position.points) {\r\n\t                        var arrStartEndPoint = this.getStartEndPoint(connector);\r\n\t                        points = connector.options.position.points;\r\n\t                        points.unshift(arrStartEndPoint[0]);\r\n\t                        points.push(arrStartEndPoint[1]);\r\n\t                        connector.refresh(points);\r\n\t                    } else {\r\n\t                        this.refreshConnector(arrCons[0], true);\r\n\t                    }\r\n\t                }\r\n\t            } else if (arrCons.length > 1) {\r\n\t                //两个节点有多个连线的情况\r\n\t                this.refreshCons(arrCons);\r\n\t            }\r\n\t        } else {\r\n\t            //处理没有 起始节点与终止节点时的连线\r\n\t            this.handleConnectorPoints(connector)\r\n\t        }\r\n\t\r\n\t        //3.设置模型\r\n\t        this.handleConnectorModel(connector);\r\n\t        return connector;\r\n\t    }\r\n\t\r\n\t    FlowConnectionManager.prototype.handleConnectorEvent = function(connector) {\r\n\t        if (connector.conPointsGroup) {\r\n\t            connector.conPointsGroup.on(\"click\", function(e) {\r\n\t                var arrSplit = e.target.type.split(Connector.SEPERATOR);\r\n\t                var connector = e.target.connector;\r\n\t                if (arrSplit[0] === Connector.START_NODE) {\r\n\t                    connector.options.position.startPos = arrSplit[1];\r\n\t                } else if (arrSplit[0] === Connector.END_NODE) {\r\n\t                    connector.options.position.endPos = arrSplit[1];\r\n\t                }\r\n\t                this.refreshConnector(connector, true);\r\n\t                e.cancelBubble = true;\r\n\t                var params = {};\r\n\t                params.event = e;\r\n\t                params.type = \"conPointsGroup:click\";\r\n\t                params.lineNode = this.selConnector;\r\n\t                this._api.trigger(params.type, params);\r\n\t            }.bind(this));\r\n\t        }\r\n\t\r\n\t\r\n\t        var MOUSE_EVENT_NAMES = ['click', 'dblclick'];\r\n\t        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n\t            connector.on(\"Connector:\" + eveName, function(e) {\r\n\t                var selected = e.target;\r\n\t                if (this.selConnector !== selected) {\r\n\t                    this.selConnector && this.refreshConnector(this.selConnector);\r\n\t                    this.selConnector = selected;\r\n\t                }\r\n\t                e.cancelBubble = true;\r\n\t                var params = {};\r\n\t                params.event = e;\r\n\t                params.type = eveName;\r\n\t                params.target = this.selConnector;\r\n\t                this._api.trigger(params.type, params);\r\n\t            }.bind(this));\r\n\t        }.bind(this));\r\n\t    }\r\n\t\r\n\t    FlowConnectionManager.prototype.handleConnectorModel = function(connector) {\r\n\t        connector.model.set(Constants.ELEMENT_TYPE, Constants.CONNECTION);\r\n\t        if(connector.startNode && connector.endNode) {\r\n\t            connector.model.set(Constants.START_ID, connector.startNode.id);\r\n\t            connector.model.set(Constants.END_ID, connector.endNode.id);\r\n\t        }\r\n\t        connector.model.set(Constants.OPTIONS, zrUtil.clone(connector.options));\r\n\t    }\r\n\t\r\n\t    FlowConnectionManager.prototype.handleConnectorShrink = function(connector) {\r\n\t        var that = this;\r\n\t        //双击收紧为一条线\r\n\t        connector.line.on(\"dblclick\", function() {\r\n\t            if (connector.options.isShrink == false) {\r\n\t                return;\r\n\t            }\r\n\t            var con = this.parent;\r\n\t            var startNode = con.startNode;\r\n\t            var endNode = con.endNode;\r\n\t            //1.获取所有的线段\r\n\t            var key = that.getTwoNodeId(startNode, endNode, connector.options.position);\r\n\t            var cons = that.connectorMap.get(key);\r\n\t            if (cons.length == 1) {\r\n\t                return\r\n\t            }\r\n\t            //2.判断线是否处于隐藏状态\r\n\t            //2.将除中间的一条线进行隐藏\r\n\t            var half = parseInt(cons.length / 2);\r\n\t            for (var i = 0; i < cons.length; i++) {\r\n\t                if (i != (half)) {\r\n\t                    if (cons[i].ignore) {\r\n\t                        cons[i].show();\r\n\t                    } else {\r\n\t                        cons[i].hide();\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        })\r\n\t    }\r\n\t\r\n\t    //处理没有 起始节点与终止节点时的连线\r\n\t    FlowConnectionManager.prototype.handleConnectorPoints = function(connector) {\r\n\t        var options = connector.options;\r\n\t        var dockers = connector.options.dockers;\r\n\t        if (dockers && dockers.length >= 2) {\r\n\t            var points = Point.loadArray(dockers);\r\n\t            connector.refresh(points);\r\n\t        } else {\r\n\t            if (options.position && options.position.points) {\r\n\t                var oPoints = options.position.points;\r\n\t                connector.refresh(oPoints);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    FlowConnectionManager.prototype.getTwoNodeId = function(startNode, endNode, pos) {\r\n\t        return startNode.id + '-' + pos.startPos + \",\" + endNode.id + '-' + pos.endPos;\r\n\t    }\r\n\t    //处理多条线段\r\n\t    FlowConnectionManager.prototype.refreshCons = function(arrCons) {\r\n\t        //如果是折线的话\r\n\t        if (arrCons[0].options.style.lineType == Connector.TYPE_JAGGED) {\r\n\t            for (var i = 0; i < arrCons.length; i++) {\r\n\t                this.refreshConnector(arrCons[i], true);\r\n\t            }\r\n\t        } else {\r\n\t            this.refreshConsStraight(arrCons);\r\n\t        }\r\n\t    }\r\n\t\r\n\t    //处理多条线段(直线)\r\n\t    FlowConnectionManager.prototype.refreshConsStraight = function(arrCons) {\r\n\t        var half = parseInt(arrCons.length / 2);\r\n\t        var arrConnectResult = []\r\n\t\r\n\t        var startNode = arrCons[0].startNode;\r\n\t        var endNode = arrCons[0].endNode;\r\n\t        var sRect = Util.getRect(startNode);\r\n\t        var eRect = Util.getRect(endNode).boundingRect;\r\n\t        var sConnectorPoint = Util.getConnectorPoints(sRect, startNode);\r\n\t        var eConnectorPoint = Util.getConnectorPoints(eRect, endNode);\r\n\t        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n\t        var position = arrCons[0].options.position;\r\n\t        if (!position.startPos || !position.endPos) {\r\n\t            if (sRect.x < eRect.x) {\r\n\t                position.startPos = \"right\";\r\n\t                position.endPos = \"left\";\r\n\t            } else {\r\n\t                position.startPos = \"left\";\r\n\t                position.endPos = \"right\";\r\n\t            }\r\n\t        }\r\n\t\r\n\t        var startPoint = sConnectorPoint[position.startPos];\r\n\t        var endPoint = eConnectorPoint[position.endPos];\r\n\t        var angle = Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x);\r\n\t        var points = [];\r\n\t        for (var i = half; i >= 1; i--) {\r\n\t            points = []; //var points = [];\r\n\t            points.push(startPoint); //\r\n\t            // points.push(new Point(startPoint.x + bundleOffset , startPoint.y + i * bundleGap));\r\n\t            // points.push(new Point(endPoint.x - bundleOffset , startPoint.y + i * bundleGap)); //startPoint.x + bundleOffset\r\n\t            var secondPoint = startPoint.clone();\r\n\t\r\n\t            //secondPoint.x =  secondPoint.x + this.bundleOffset;\r\n\t            secondPoint.transform(Util.translationMatrix(0, this.bundleGap * i));\r\n\t            //secondPoint = this.boundOffsetXY(secondPoint, true);\r\n\t            //\r\n\t            //直角坐标 x, 和 y, 计算出极坐标\r\n\t\r\n\t\r\n\t            //从极坐标计算出直角坐标\r\n\t            secondPoint.x = secondPoint.x + this.bundleOffset * Math.cos(angle);\r\n\t            secondPoint.y = secondPoint.y + this.bundleOffset * Math.sin(angle);\r\n\t\r\n\t\r\n\t\r\n\t            //secondPoint.transform(Util.scaleMatrix(0.5));\r\n\t            points.push(secondPoint);\r\n\t\r\n\t            var thirdPoint = endPoint.clone();\r\n\t            //thirdPoint.x =  thirdPoint.x - this.bundleOffset;\r\n\t\r\n\t\r\n\t\r\n\t            thirdPoint.transform(Util.translationMatrix(0, this.bundleGap * i));\r\n\t            //thirdPoint = this.boundOffsetXY(thirdPoint, false);\r\n\t            //secondPoint.transform(Util.scaleMatrix(0.5));\r\n\t            //\r\n\t            //直角坐标 x, 和 y, 计算出极坐标\r\n\t\r\n\t            //从极坐标计算出直角坐标\r\n\t            thirdPoint.x = thirdPoint.x - this.bundleOffset * Math.cos(angle);\r\n\t            thirdPoint.y = thirdPoint.y - this.bundleOffset * Math.sin(angle);\r\n\t\r\n\t            points.push(thirdPoint);\r\n\t\r\n\t            points.push(endPoint);\r\n\t            arrConnectResult.push(points);\r\n\t        }\r\n\t\r\n\t        arrConnectResult.push([startPoint, endPoint]);\r\n\t\r\n\t        var upHalf = Math.ceil(arrCons.length / 2);\r\n\t        for (i = 1; i < upHalf; i++) {\r\n\t            points = []; //var points = [];\r\n\t            points.push(startPoint);\r\n\t            var secPoint = startPoint.clone();\r\n\t            //secPoint.x =  secPoint.x + this.bundleOffset;\r\n\t            secPoint.transform(Util.translationMatrix(0, -this.bundleGap * i));\r\n\t            secPoint.x = secPoint.x + this.bundleOffset * Math.cos(angle);\r\n\t            secPoint.y = secPoint.y + this.bundleOffset * Math.sin(angle);\r\n\t            points.push(secPoint);\r\n\t\r\n\t            var thdPoint = endPoint.clone();\r\n\t            //thdPoint.x =  thdPoint.x - this.bundleOffset;\r\n\t            thdPoint.transform(Util.translationMatrix(0, -this.bundleGap * i));\r\n\t            //从极坐标计算出直角坐标\r\n\t            thdPoint.x = thdPoint.x - this.bundleOffset * Math.cos(angle);\r\n\t            thdPoint.y = thdPoint.y - this.bundleOffset * Math.sin(angle);\r\n\t            //secondPoint.transform(Util.scaleMatrix(0.5));\r\n\t            points.push(thdPoint);\r\n\t\r\n\t            points.push(endPoint);\r\n\t            arrConnectResult.push(points);\r\n\t        }\r\n\t\r\n\t\r\n\t        for (i = 0; i < arrConnectResult.length; i++) {\r\n\t            arrCons[i].refresh(arrConnectResult[i]);\r\n\t        }\r\n\t\r\n\t    }\r\n\t\r\n\t    FlowConnectionManager.prototype.boundOffsetXY = function(point, isPositive) {\r\n\t        var resultPoint = point.clone();\r\n\t        //直角坐标 x, 和 y, 计算出极坐标\r\n\t        var angle = Math.atan2(resultPoint.y, resultPoint.x);\r\n\t        var r = Math.sqrt(Math.pow(resultPoint.x, 2) + Math.pow(resultPoint.y, 2));\r\n\t        if (isPositive) {\r\n\t            r = r + this.bundleOffset;\r\n\t        } else {\r\n\t            r = r - this.bundleOffset;\r\n\t        }\r\n\t\r\n\t\r\n\t        //从极坐标计算出直角坐标\r\n\t        resultPoint.x = r * Math.cos(angle);\r\n\t        resultPoint.y = r * Math.sin(angle);\r\n\t        return resultPoint;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 设置线段的模型数据  (类型 文字)\r\n\t     * @param {[type]} connector [description]\r\n\t     * @param {[type]} option    [description]\r\n\t     */\r\n\t    FlowConnectionManager.prototype.setModel = function(connector, option) {\r\n\t        var originLineType = connector.model.get(\"style.lineType\");\r\n\t        connector.model.mergeOption(option);\r\n\t        zrUtil.merge(connector.model.get(\"options\"), option, true);\r\n\t        if (originLineType !== option.style.lineType) {\r\n\t            this.refreshConnector(connector, true);\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 删除指定的线\r\n\t     * @param connector 欲删除的连线\r\n\t     * @param _zr zr\r\n\t     */\r\n\t    ConnectionManager.prototype.deleteByLine = function (connector,_zr) {\r\n\t        //1.将线 所联的startNode的outgoing数据删除\r\n\t        if(connector.startNode){\r\n\t            var startNodeOutgoing = connector.startNode.model.get(\"outgoing\");\r\n\t            index = zrUtil.indexOf(startNodeOutgoing, connector.resourceId);\r\n\t            if (index != -1) {\r\n\t                startNodeOutgoing.splice(index, 1);\r\n\t            }\r\n\t\r\n\t            if (this.connectorMap) {\r\n\t                var key = this.getTwoNodeId(connector.startNode, connector.endNode, connector.options.position);\r\n\t                this.connectorMap.removeItem(key, connector);\r\n\t            }\r\n\t        }\r\n\t\r\n\t\r\n\t        //2.从_zr上删除\r\n\t        _zr.remove(connector);\r\n\t\r\n\t\r\n\t        //3.从线数据中删除\r\n\t        var index = zrUtil.indexOf(this.connectors, connector);\r\n\t        if (index != -1) {\r\n\t            this.connectors.splice(index, 1);\r\n\t        }\r\n\t        if (this.selConnector === connector) {\r\n\t            this.selConnector = null;\r\n\t        }\r\n\t    }\r\n\t    /**\r\n\t     * 刷新连接线\r\n\t     * @param  {[type]} node [description]\r\n\t     * @return {[type]}      [description]\r\n\t     */\r\n\t    FlowConnectionManager.prototype.refreshLineByNode = function(node) {\r\n\t        // 判断这个节点是否有多条线段\r\n\t        var keys = this.connectorMap.keys();\r\n\t        for (var i = 0; i < keys.length; i++) {\r\n\t            var key = keys[i];\r\n\t            if (key.indexOf(node.id) != -1) {\r\n\t                var arrCons = this.connectorMap.get(key);\r\n\t                this.countLinePos(arrCons)\r\n\t                if (arrCons.length == 1) {\r\n\t                    //两个节点只有一个连线的情况\r\n\t                    this.refreshConnector(arrCons[0], true);\r\n\t                } else if (arrCons.length > 1) {\r\n\t                    //两个节点有多个连线的情况\r\n\t                    this.refreshCons(arrCons);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 刷新连接线\r\n\t     * @param  {[type]} node [description]\r\n\t     * @return {[type]}      [description]\r\n\t     */\r\n\t    FlowConnectionManager.prototype.toggleLineByNode = function(node, isShow) {\r\n\t        // 判断这个节点是否有多条线段\r\n\t        var keys = this.connectorMap.keys();\r\n\t        for (var i = 0; i < keys.length; i++) {\r\n\t            var key = keys[i];\r\n\t            if (key.indexOf(node.id) != -1) {\r\n\t                var arrCons = this.connectorMap.get(key);\r\n\t\r\n\t                zrUtil.each(arrCons, function(connection) {\r\n\t                    if(isShow) {\r\n\t                        connection.show();\r\n\t                    } else {\r\n\t                        connection.hide();\r\n\t                    }\r\n\t                })\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    /**\r\n\t     * 重新调整线的位置\r\n\t     */\r\n\t    FlowConnectionManager.prototype.countLinePos = function(arrCons) {\r\n\t        zrUtil.each(arrCons, function(connector) {\r\n\t            var options = connector.options;\r\n\t            if (options.autoChangePosition == true) {\r\n\t                var sRect = Util.getRect(connector.startNode).boundingRect;\r\n\t                var eRect = Util.getRect(connector.endNode).boundingRect;\r\n\t                var startPos = options.position.startPos;\r\n\t                var endPos = options.position.endPos;\r\n\t                var startPosNow = this.posIsChange(startPos, sRect, eRect, \"startNode\");\r\n\t                var endPosNow = this.posIsChange(endPos, sRect, eRect, \"endNode\");\r\n\t                if (startPos != startPosNow || endPos != endPosNow) {\r\n\t                    options.position.startPos = startPosNow;\r\n\t                    options.position.endPos = endPosNow;\r\n\t                }\r\n\t            }\r\n\t        },this);\r\n\t    }\r\n\t\r\n\t    FlowConnectionManager.prototype.posIsChange = function(pos, sRect, eRect, nodeType) {\r\n\t        var newPos\r\n\t        if (pos.indexOf(\"top\") != -1 || pos.indexOf(\"bottom\") != -1) {\r\n\t            if (sRect.y + sRect.height < eRect.y) {\r\n\t                if (nodeType == \"startNode\") {\r\n\t                    newPos = pos.replace(/(top|bottom)/g, \"bottom\");\r\n\t                } else {\r\n\t                    newPos = pos.replace(/(top|bottom)/g, \"top\");\r\n\t                }\r\n\t            } else if (eRect.y + eRect.height < sRect.y) {\r\n\t                if (nodeType == \"endNode\") {\r\n\t                    newPos = pos.replace(/(top|bottom)/g, \"bottom\");\r\n\t                } else {\r\n\t                    newPos = pos.replace(/(top|bottom)/g, \"top\");\r\n\t                }\r\n\t            } else if (sRect.x + sRect.width < eRect.x) {\r\n\t                if (nodeType == \"startNode\") {\r\n\t                    newPos = pos.replace(/(top|bottom)/g, \"right\");\r\n\t                } else {\r\n\t                    newPos = pos.replace(/(top|bottom)/g, \"left\");\r\n\t                }\r\n\t            } else if (eRect.x + eRect.width < sRect.x) {\r\n\t                if (nodeType == \"endNode\") {\r\n\t                    newPos = pos.replace(/(top|bottom)/g, \"right\");\r\n\t                } else {\r\n\t                    newPos = pos.replace(/(top|bottom)/g, \"left\");\r\n\t                }\r\n\t            }else {\r\n\t                newPos = pos;\r\n\t            }\r\n\t        } else if (pos.indexOf(\"left\") != -1 || pos.indexOf(\"right\") != -1) {\r\n\t            if (sRect.x + sRect.width < eRect.x) {\r\n\t                if (nodeType == \"startNode\") {\r\n\t                    newPos = pos.replace(/(right|left)/g, \"right\");\r\n\t                } else {\r\n\t                    newPos = pos.replace(/(right|left)/g, \"left\");\r\n\t                }\r\n\t            } else if (eRect.x + eRect.width < sRect.x) {\r\n\t                if (nodeType == \"endNode\") {\r\n\t                    newPos = pos.replace(/(right|left)/g, \"right\");\r\n\t                } else {\r\n\t                    newPos = pos.replace(/(right|left)/g, \"left\");\r\n\t                }\r\n\t            } else if (sRect.y + sRect.height < eRect.y) {\r\n\t                if (nodeType == \"startNode\") {\r\n\t                    newPos = pos.replace(/(right|left)/g, \"bottom\");\r\n\t                } else {\r\n\t                    newPos = pos.replace(/(right|left)/g, \"top\");\r\n\t                }\r\n\t            } else if (eRect.y + eRect.height < sRect.y) {\r\n\t                if (nodeType == \"endNode\") {\r\n\t                    newPos = pos.replace(/(right|left)/g, \"bottom\");\r\n\t                } else {\r\n\t                    newPos = pos.replace(/(right|left)/g, \"top\");\r\n\t                }\r\n\t            } else {\r\n\t                newPos = pos;\r\n\t            }\r\n\t        } else {\r\n\t            newPos = pos;\r\n\t        }\r\n\t        return newPos;\r\n\t    }\r\n\t\r\n\t\r\n\t    zrUtil.inherits(FlowConnectionManager, ConnectionManager);\r\n\t    module.exports = FlowConnectionManager;\r\n\t\r\n\n\n/***/ }),\n/* 91 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 连线管理类\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var Util = __webpack_require__(65);\r\n\t    var Point = __webpack_require__(66);\r\n\t    var Connector = __webpack_require__(82);\r\n\t    var Log = __webpack_require__(92);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t\r\n\t    function ConnectionManager() {\r\n\t        this.connectors = []; //当前画布所有的线段\r\n\t        this.selConnector = null; //当前选中的线段\r\n\t        this.tempConnector = null; //临时线段\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 设置线的不可编辑\r\n\t     * @param  {[type]} forbidEdit [description]\r\n\t     * @return {[type]}            [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.connectorForbidEdit = function (forbidEdit) {\r\n\t        for (var i = 0; i < this.connectors.length; i++) {\r\n\t            this.connectors[i].options.isEdit = !forbidEdit;\r\n\t        }\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 清空连接线上的调整位置按钮\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.clearSelectCon = function () {\r\n\t        if (this.selConnector != null) {\r\n\t            this.refreshConnector(this.selConnector);\r\n\t        }\r\n\t    }\r\n\t    /**\r\n\t     * 删除和节点相关联的连接线\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.deleteSelectCon = function (node, _zr) {\r\n\t        for (var i = 0; i < this.connectors.length; i++) {\r\n\t            if (this.connectors[i].startNode == node || this.connectors[i].endNode == node) {\r\n\t                //1.将线 所联的startNode的outgoing数据删除\r\n\t                var startNodeOutgoing = this.connectors[i].startNode.model.get(\"outgoing\");\r\n\t                var index = zrUtil.indexOf(startNodeOutgoing, this.connectors[i].resourceId);\r\n\t                if (index != -1) {\r\n\t                    startNodeOutgoing.splice(index, 1);\r\n\t                }\r\n\t                //2.从_zr上删除\r\n\t                _zr.remove(this.connectors[i]);\r\n\t                this.connectors.splice(i, 1);\r\n\t                i--;\r\n\t                this.selConnector = null;\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    ConnectionManager.prototype.removeLine = function (line, zr) {\r\n\t        this.selConnector = line;\r\n\t        this.deleteLine(zr);\r\n\t    }\r\n\t    /**\r\n\t     * 删除选定的线\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.deleteLine = function (_zr) {\r\n\t        //1.将线 所联的startNode的outgoing数据删除\r\n\t        if(this.selConnector.startNode){\r\n\t            var startNodeOutgoing = this.selConnector.startNode.model.get(\"outgoing\");\r\n\t            index = zrUtil.indexOf(startNodeOutgoing, this.selConnector.resourceId);\r\n\t            if (index != -1) {\r\n\t                startNodeOutgoing.splice(index, 1);\r\n\t            }\r\n\t\r\n\t            if (this.connectorMap) {\r\n\t                var key = this.getTwoNodeId(this.selConnector.startNode, this.selConnector.endNode, this.selConnector.options.position);\r\n\t                this.connectorMap.removeItem(key, this.selConnector);\r\n\t            }\r\n\t        }\r\n\t\r\n\t\r\n\t        //2.从_zr上删除\r\n\t        _zr.remove(this.selConnector);\r\n\t\r\n\t\r\n\t        //3.从线数据中删除\r\n\t        var index = zrUtil.indexOf(this.connectors, this.selConnector);\r\n\t        if (index != -1) {\r\n\t            this.connectors.splice(index, 1);\r\n\t        }\r\n\t        this.selConnector = null;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 重新画线\r\n\t     * @param  {[type]} connector          [description]\r\n\t     * @param  {[type]} force\r\n\t     * @return {[type]}                    [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.refreshConnector = function (connector, force) {\r\n\t        // 只有需要强制刷新  或者 连线为空（<2)时 才进行重新计算重绘\r\n\t        if (force || (!connector.turningPoints) || (connector.turningPoints.length < 2)) {\r\n\t            if (connector.model && connector.model.get(\"style.lineType\")) {\r\n\t                connector.options.style.lineType = connector.model.get(\"style.lineType\");\r\n\t            }\r\n\t            var arrStartEndPoint = this.getStartEndPoint(connector);\r\n\t            var escapeDistance = null;\r\n\t            if (connector.options.position && connector.options.position.escapeDistance) {\r\n\t                escapeDistance = connector.options.position.escapeDistance;\r\n\t            }\r\n\t            var solutions = this.connector2Points(connector.options.style.lineType, arrStartEndPoint[0],\r\n\t                arrStartEndPoint[1],\r\n\t                arrStartEndPoint[2], arrStartEndPoint[3], escapeDistance); // TYPE_STRAIGHT TYPE_JAGGED\r\n\t\r\n\t            connector.refresh(solutions[0][2]);\r\n\t        }\r\n\t\r\n\t        connector.clearHandles(); //清空handle\r\n\t    }\r\n\t\r\n\t\r\n\t    ConnectionManager.prototype.getStartEndPoint = function (connector) {\r\n\t        var startNode = connector.startNode;\r\n\t        var endNode = connector.endNode;\r\n\t        var isNotInSameGroup = true;\r\n\t        isNotInSameGroup = startNode.parent !== endNode.parent;\r\n\t\r\n\t        var sRect = startNode.getRect ? startNode.getRect().boundingRect : Util.getRect(startNode, isNotInSameGroup).boundingRect;\r\n\t        var sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(\r\n\t            sRect.y) + Number(sRect.height)];\r\n\t\r\n\t        var eRect = endNode.getRect ? endNode.getRect().boundingRect : Util.getRect(endNode, isNotInSameGroup).boundingRect;\r\n\t        var eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(\r\n\t            eRect.y) + Number(eRect.height)];\r\n\t\r\n\t\r\n\t        var sConnectorPoint = Util.getConnectorPoints(sRect, startNode);\r\n\t        var eConnectorPoint = Util.getConnectorPoints(eRect, endNode);\r\n\t\r\n\t        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n\t        var position = connector.options.position;\r\n\t        if (position.direction) {\r\n\t            var posArr = position.direction.split(',');\r\n\t            position.startPos = posArr[0];\r\n\t            position.endPos = posArr[1];\r\n\t        }\r\n\t        if (!position.startPos || !position.endPos) {\r\n\t            if (sRect.x < eRect.x) {\r\n\t                position.startPos = \"right\";\r\n\t                position.endPos = \"left\";\r\n\t            } else {\r\n\t                position.startPos = \"left\";\r\n\t                position.endPos = \"right\";\r\n\t            }\r\n\t        }\r\n\t        var startPoint = this.calcPointExpression(position.startPos, sConnectorPoint);\r\n\t        var endPoint = this.calcPointExpression(position.endPos, eConnectorPoint);\r\n\t        startPoint.add(new Point(position.startOffset[0], position.startOffset[1]));\r\n\t        endPoint.add(new Point(position.endOffset[0], position.endOffset[1]));\r\n\t        return [startPoint, endPoint, sBounds, eBounds];\r\n\t    }\r\n\t\r\n\t    ConnectionManager.prototype.calcPointExpression = function (pos, point) {\r\n\t        var variable = {\r\n\t            top: point.top.x,\r\n\t            left: point.left.y,\r\n\t            right: point.right.y,\r\n\t            bottom: point.bottom.x,\r\n\t            center: point.center.x\r\n\t        };\r\n\t\r\n\t        var expression = \"<% print(\" + pos + \") %>\";\r\n\t        var val = parseInt(Util.template(expression)(variable));\r\n\t        if (pos.indexOf(\"top\") != -1) {\r\n\t            return new Point(val, point.top.y);\r\n\t        } else if (pos.indexOf(\"left\") != -1) {\r\n\t            return new Point(point.left.x, val);\r\n\t        } else if (pos.indexOf(\"right\") != -1) {\r\n\t            return new Point(point.right.x, val);\r\n\t        } else if (pos.indexOf(\"bottom\") != -1) {\r\n\t            return new Point(val, point.bottom.y);\r\n\t        } else if (pos.indexOf(\"center\") != -1) {\r\n\t            return new Point(val, point.bottom.y);\r\n\t        } else {\r\n\t            throw new Error(\"pos参数错误\");\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 创建或修改临时线\r\n\t     * @param  {[type]} startNode             [description]\r\n\t     * @param  {[type]} rEndPoint             [description]\r\n\t     * @param  {[type]} lineType              [description]\r\n\t     * @param  {[type]} startPos              [description]\r\n\t     * @return {[type]}                       [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.manageTempConnector = function (startNode, rEndPoint, lineType, startPos, endPos, endNode) {\r\n\t        var eRect = null;\r\n\t        var eBounds = null;\r\n\t        var sRect = startNode.getRect ? startNode.getRect().boundingRect : Util.getRect(startNode, true).boundingRect;\r\n\t        var sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(\r\n\t            sRect.y) + Number(sRect.height)];\r\n\t\r\n\t        var sConnectorPoint = Util.getConnectorPoints(sRect, startNode);\r\n\t\r\n\t        if (!this.tempConnector) {\r\n\t            this.tempConnector = new Connector({\r\n\t                isEdit: false,\r\n\t                style: {\r\n\t                    lineType: lineType\r\n\t                }\r\n\t            });\r\n\t        }\r\n\t\r\n\t        var connector = this.tempConnector;\r\n\t        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n\t        var position = connector.options.position;\r\n\t        position.startPos = startPos ? startPos : (sRect.x < rEndPoint.x ? \"right\" : \"left\");\r\n\t        position.endPos = endPos ? endPos : (sRect.x < rEndPoint.x ? \"left\" : \"right\");\r\n\t\r\n\t        connector.options.style.lineType = lineType;\r\n\t        if (endNode) {\r\n\t            eRect = endNode.getRect ? endNode.getRect().boundingRect : Util.getRect(endNode, true).boundingRect;\r\n\t            eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(\r\n\t                eRect.y) + Number(eRect.height)];\r\n\t        }\r\n\t        var solutions = this.connector2Points(lineType, sConnectorPoint[position.startPos], rEndPoint,\r\n\t            sBounds, eBounds); // TYPE_STRAIGHT TYPE_JAGGED\r\n\t\r\n\t        connector.refresh(solutions[0][2]);\r\n\t        return connector;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 创建或修改临时反转线\r\n\t     * @param  {[type]} startPoint              [description]\r\n\t     * @param  {[type]} endNode                 [description]\r\n\t     * @param  {[type]} lineType                [description]\r\n\t     * @param  {[type]} endPos                  [description]\r\n\t     * @return {[type]}                         [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.manageReverseTempConnector = function (startPoint, endNode, lineType, endPos, startPos, startNode) {\r\n\t        var sRect = null;\r\n\t        var sBounds = null;\r\n\t        var eRect = endNode.getRect ? endNode.getRect().boundingRect : Util.getRect(endNode, true).boundingRect;\r\n\t        var eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(eRect.y) + Number(eRect.height)];\r\n\t        var eConnectorPoint = Util.getConnectorPoints(eRect, endNode);\r\n\t        if (!this.tempConnector) {\r\n\t            this.tempConnector = new Connector({\r\n\t                isEdit: false,\r\n\t                style: {\r\n\t                    lineType: lineType\r\n\t                }\r\n\t            });\r\n\t        }\r\n\t        var connector = this.tempConnector;\r\n\t        var position = connector.options.position;\r\n\t        position.endPos = endPos ? endPos : (eRect.x < startPoint.x ? \"right\" : \"left\");\r\n\t        position.startPos = startPos ? startPos : (eRect.x < startPoint.x ? \"left\" : \"right\");\r\n\t\r\n\t        connector.options.style.lineType = lineType;\r\n\t        if (startNode) {\r\n\t            sRect = startNode.getRect ? startNode.getRect().boundingRect : Util.getRect(startNode, true).boundingRect;\r\n\t            sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(\r\n\t            sRect.y) + Number(sRect.height)];\r\n\t        }\r\n\t        var solutions = this.connector2Points(lineType, startPoint, eConnectorPoint[position.endPos],\r\n\t            sBounds, eBounds); // TYPE_STRAIGHT TYPE_JAGGED\r\n\t\r\n\t        connector.refresh(solutions[0][2]);\r\n\t        return connector;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 删除临时线\r\n\t     * @param  {[type]} zr             [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.removeTempConnector = function (zr) {\r\n\t        if (this.tempConnector) {\r\n\t            zr.remove(this.tempConnector);\r\n\t            this.tempConnector = null;\r\n\t        }\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 算出 两个节点 指定两个点如何联线\r\n\t     * @param  {[type]} type       [description]\r\n\t     * @param  {[type]} startPoint [description]\r\n\t     * @param  {[type]} endPoint   [description]\r\n\t     * @param  {[type]} sBounds    [description]\r\n\t     * @param  {[type]} eBounds    [description]\r\n\t     * @return {[type]}            [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.connector2Points = function (type, startPoint, endPoint, sBounds, eBounds,\r\n\t        escapeDistance) {\r\n\t        var figureEscapeDistance = [30, 30];\r\n\t        if (escapeDistance) {\r\n\t            if (!zrUtil.isArray(escapeDistance)) {\r\n\t                figureEscapeDistance = [escapeDistance, escapeDistance];\r\n\t            } else {\r\n\t                figureEscapeDistance = escapeDistance;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        Log.group(\"connectionManager: connector2Points\");\r\n\t\r\n\t\r\n\t        Log.info(\"ConnectionManager: connector2Points (\" + type + \", \" + startPoint + \", \" + endPoint +\r\n\t            \", \" + sBounds + \", \" + eBounds + ')');\r\n\t        var solutions = [];\r\n\t\r\n\t\r\n\t\r\n\t        switch (type) {\r\n\t            case Connector.TYPE_CHAIN:\r\n\t\r\n\t            case Connector.TYPE_STRAIGHT: //直线\r\n\t                var points = [startPoint.clone(), endPoint.clone()];\r\n\t                solutions.push(['straight', 'straight', points]);\r\n\t                break;\r\n\t\r\n\t            case Connector.TYPE_CURVE: //曲线\r\n\t\r\n\t            case Connector.TYPE_JAGGED: //折线\r\n\t                var startExitPoint = null;\r\n\t                var endExitPoint = null;\r\n\t\r\n\t                //find start exit point  寻找开始出口\r\n\t                if (sBounds != null) {\r\n\t                    var potentialExits = [];\r\n\t\r\n\t                    potentialExits.push(new Point(startPoint.x, sBounds[1] - figureEscapeDistance[0])); //north 北\r\n\t                    potentialExits.push(new Point(sBounds[2] + figureEscapeDistance[0], startPoint.y)); //east  东\r\n\t                    potentialExits.push(new Point(startPoint.x, sBounds[3] + figureEscapeDistance[0])); //south  南\r\n\t                    potentialExits.push(new Point(sBounds[0] - figureEscapeDistance[0], startPoint.y)); //west  西\r\n\t\r\n\t                    //pick closest exit point  寻找与 startPoint 最靠近的出口点\r\n\t                    startExitPoint = potentialExits[0];\r\n\t                    for (var i = 1; i < potentialExits.length; i++) {\r\n\t                        if (Util.distance(startPoint, potentialExits[i]) < Util.distance(startPoint,\r\n\t                                startExitPoint)) {\r\n\t                            startExitPoint = potentialExits[i];\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t\r\n\t\r\n\t                //find end exit point  寻找结束出口\r\n\t                if (eBounds != null) {\r\n\t                    var potentialExits = [];\r\n\t\r\n\t                    potentialExits.push(new Point(endPoint.x, eBounds[1] - figureEscapeDistance[1])); //north\r\n\t                    potentialExits.push(new Point(eBounds[2] + figureEscapeDistance[1], endPoint.y)); //east\r\n\t                    potentialExits.push(new Point(endPoint.x, eBounds[3] + figureEscapeDistance[1])); //south\r\n\t                    potentialExits.push(new Point(eBounds[0] - figureEscapeDistance[1], endPoint.y)); //west\r\n\t\r\n\t                    //pick closest exit point  寻找与 endPoint 最靠近的出口点\r\n\t                    endExitPoint = potentialExits[0];\r\n\t                    for (var i = 1; i < potentialExits.length; i++) {\r\n\t                        if (Util.distance(endPoint, potentialExits[i]) < Util.distance(endPoint,\r\n\t                                endExitPoint)) {\r\n\t                            endExitPoint = potentialExits[i];\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                //Basic solution 最基本的解决方案   为其他解决方案做准备\r\n\t                var s = [startPoint];\r\n\t                var gapIndex = 0; //the index of the gap (where do we need to insert new points) DO NOT CHANGE IT\r\n\t                if (startExitPoint) {\r\n\t                    s.push(startExitPoint);\r\n\t                    gapIndex = 1;\r\n\t                }\r\n\t                if (endExitPoint) {\r\n\t                    s.push(endExitPoint);\r\n\t                }\r\n\t                s.push(endPoint);\r\n\t\r\n\t\r\n\t\r\n\t                //SO - no additional points     S0 解决方案 不添加任何点  基本不会被采用\r\n\t                var s0 = Point.cloneArray(s);\r\n\t                solutions.push(['s0', 's0', s0]);\r\n\t\r\n\t\r\n\t\r\n\t                //S1   S1 解决方案  只有一个折点\r\n\t                var s1 = Point.cloneArray(s);\r\n\t\r\n\t                //first variant   第一个变体 s1 s1_1方案  折线点在 startExitPoint的X 与 endExitPoint的 Y位置\r\n\t                var s1_1 = Point.cloneArray(s1);\r\n\t                s1_1.splice(gapIndex + 1, 0, new Point(s1_1[gapIndex].x, s1_1[gapIndex + 1].y));\r\n\t                solutions.push(['s1', 's1_1', s1_1]);\r\n\t\r\n\t                //second variant  第二变体 s1 s1-2方案  折线点在 endExitPoint的X 与  startExitPoint的Y位置\r\n\t                var s1_2 = Point.cloneArray(s1);\r\n\t                s1_2.splice(gapIndex + 1, 0, new Point(s1_2[gapIndex + 1].x, s1_2[gapIndex].y));\r\n\t                solutions.push(['s1', 's1_2', s1_2]);\r\n\t\r\n\t\r\n\t                //S2  S2 解决方案  添加两个折点\r\n\t\r\n\t                //Variant I   s2_1方案\r\n\t                var s2_1 = Point.cloneArray(s);\r\n\t                var s2_1_1 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex].y);\r\n\t                var s2_1_2 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex + 1].y);\r\n\t                s2_1.splice(gapIndex + 1, 0, s2_1_1, s2_1_2);\r\n\t                solutions.push(['s2', 's2_1', s2_1]);\r\n\t\r\n\t\r\n\t                //Variant II  s2_1方案  1折线点 x: startExitPoint的X 位置 y: startExitPoint的y+endExitPoint的y/2\r\n\t                //1折线点 x:endExitPoint的x  y:startExitPoint的y+endExitPoint的y/2\r\n\t                var s2_2 = Point.cloneArray(s);\r\n\t                var s2_2_1 = new Point(s2_2[gapIndex].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);\r\n\t                var s2_2_2 = new Point(s2_2[gapIndex + 1].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);\r\n\t                s2_2.splice(gapIndex + 1, 0, s2_2_1, s2_2_2);\r\n\t                solutions.push(['s2', 's2_2', s2_2]);\r\n\t\r\n\t\r\n\t                //Variant III\r\n\t                var s2_3 = Point.cloneArray(s);\r\n\t                //find the amount (stored in delta) of pixels we need to move right so no intersection with a figure will be present\r\n\t                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\t\r\n\t                var eastExits = [s2_3[gapIndex].x + 20, s2_3[gapIndex + 1].x + 20]; //add points X coordinates to be able to generate Variant III even in the absence of figures :p\r\n\t\r\n\t                if (sBounds) {\r\n\t                    eastExits.push(sBounds[2] + 20);\r\n\t                }\r\n\t\r\n\t                if (eBounds) {\r\n\t                    eastExits.push(eBounds[2] + 20);\r\n\t                }\r\n\t\r\n\t                var eastExit = Util.max(eastExits);\r\n\t                var s2_3_1 = new Point(eastExit, s2_3[gapIndex].y);\r\n\t                var s2_3_2 = new Point(eastExit, s2_3[gapIndex + 1].y);\r\n\t                s2_3.splice(gapIndex + 1, 0, s2_3_1, s2_3_2);\r\n\t                solutions.push(['s2', 's2_3', s2_3]);\r\n\t\r\n\t\r\n\t                //Variant IV  s2_4方案\r\n\t                var s2_4 = Point.cloneArray(s);\r\n\t                //find the amount (stored in delta) of pixels we need to move up so no intersection with a figure will be present\r\n\t                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\t\r\n\t                var northExits = [s2_4[gapIndex].y - 20, s2_4[gapIndex + 1].y - 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p\r\n\t\r\n\t                if (sBounds) {\r\n\t                    northExits.push(sBounds[1] - 20);\r\n\t                }\r\n\t\r\n\t                if (eBounds) {\r\n\t                    northExits.push(eBounds[1] - 20);\r\n\t                }\r\n\t\r\n\t                var northExit = Util.min(northExits);\r\n\t                var s2_4_1 = new Point(s2_4[gapIndex].x, northExit);\r\n\t                var s2_4_2 = new Point(s2_4[gapIndex + 1].x, northExit);\r\n\t                s2_4.splice(gapIndex + 1, 0, s2_4_1, s2_4_2);\r\n\t                solutions.push(['s2', 's2_4', s2_4]);\r\n\t\r\n\t\r\n\t                //Variant V\r\n\t                var s2_5 = Point.cloneArray(s);\r\n\t                //find the amount (stored in delta) of pixels we need to move left so no intersection with a figure will be present\r\n\t                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\t\r\n\t                var westExits = [s2_5[gapIndex].x - 20, s2_5[gapIndex + 1].x - 20]; //add points x coordinates to be able to generate Variant III even in the absence of figures :p\r\n\t\r\n\t                if (sBounds) {\r\n\t                    westExits.push(sBounds[0] - 20);\r\n\t                }\r\n\t\r\n\t                if (eBounds) {\r\n\t                    westExits.push(eBounds[0] - 20);\r\n\t                }\r\n\t\r\n\t                var westExit = Util.min(westExits);\r\n\t                var s2_5_1 = new Point(westExit, s2_5[gapIndex].y);\r\n\t                var s2_5_2 = new Point(westExit, s2_5[gapIndex + 1].y);\r\n\t                s2_5.splice(gapIndex + 1, 0, s2_5_1, s2_5_2);\r\n\t                solutions.push(['s2', 's2_5', s2_5]);\r\n\t\r\n\t\r\n\t                //Variant VI\r\n\t                var s2_6 = Point.cloneArray(s);\r\n\t                //find the amount (stored in delta) of pixels we need to move down so no intersection with a figure will be present\r\n\t                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\t\r\n\t                var southExits = [s2_6[gapIndex].y + 20, s2_6[gapIndex + 1].y + 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p\r\n\t\r\n\t                if (sBounds) {\r\n\t                    southExits.push(sBounds[3] + 20);\r\n\t                }\r\n\t\r\n\t                if (eBounds) {\r\n\t                    southExits.push(eBounds[3] + 20);\r\n\t                }\r\n\t\r\n\t                var southExit = Util.max(southExits);\r\n\t                var s2_6_1 = new Point(s2_6[gapIndex].x, southExit);\r\n\t                var s2_6_2 = new Point(s2_6[gapIndex + 1].x, southExit);\r\n\t                s2_6.splice(gapIndex + 1, 0, s2_6_1, s2_6_2);\r\n\t                solutions.push(['s2', 's2_6', s2_6]);\r\n\t\r\n\t\r\n\t\r\n\t                //FILTER solutions\r\n\t\r\n\t                /*Algorithm\r\n\t                 * 0. solutions are ordered from minimmun nr of points to maximum >:)\r\n\t                 * 1. remove all solutions that are not orthogonal (mainly s0 solution)\r\n\t                 * 2. remove all solutions that go backward (we will not need them ever)\r\n\t                 * 3. remove all solutions with intersections\r\n\t                 * 4. pick first class of solutions with same nr of points (ex: 2)\r\n\t                 * 5. pick the first solution with 90 degree angles (less turnarounds)\r\n\t                 * (not interesteted) sort by length :p\r\n\t                 */\r\n\t\r\n\t                //1. filter non ortogonal solutions 删除不是正交直线的方案\r\n\t                Log.info(\"Filter orthogonal solutions. Initial number of solutions = \" + solutions.length);\r\n\t                var orthogonalSolution = [];\r\n\t                for (var l = 0; l < solutions.length; l++) {\r\n\t                    var solution = solutions[l][2];\r\n\t                    if (Util.orthogonalPath(solution)) {\r\n\t                        orthogonalSolution.push(solutions[l]);\r\n\t                    }\r\n\t                }\r\n\t                solutions = orthogonalSolution;\r\n\t                Log.info(\"\\n\\tOrthogonalSolutions = \" + solutions.length);\r\n\t\r\n\t                //2. filter backward solutions  过滤 倒退的方案\r\n\t                //do not allow start and end points to coincide - ignore them\r\n\t                if (startPoint.equals(endPoint)) {\r\n\t                    Log.info(\r\n\t                        \"Start and end point coincide...skip backward solution. I think we will just fall on s0 :)\"\r\n\t                    );\r\n\t                } else {\r\n\t                    Log.info(\"Filter backward solutions. Initial number of solutions = \" + solutions.length);\r\n\t                    var forwardSolutions = [];\r\n\t                    var temp = '';\r\n\t                    for (var l = 0; l < solutions.length; l++) {\r\n\t                        var solution = solutions[l][2];\r\n\t                        if (Util.forwardPath(solution)) {\r\n\t                            forwardSolutions.push(solutions[l]);\r\n\t                        } else {\r\n\t                            temp = temp + \"\\n\\t\" + solution;\r\n\t                        }\r\n\t                    }\r\n\t                    solutions = forwardSolutions;\r\n\t                    Log.info(\"\\n\\t ForwardSolutions = \" + solutions.length);\r\n\t                    if (solutions.length == 0) {\r\n\t                        Log.info(\"Discarded solutions: \" + temp);\r\n\t                    }\r\n\t                }\r\n\t\r\n\t\r\n\t                //3. Filter non intersecting solutions  去除没有交集()的方案\r\n\t                Log.info(\"Filter non intersecting solutions. Initial number of solutions = \" + solutions.length);\r\n\t                var nonIntersectionSolutions = []\r\n\t                for (var l = 0; l < solutions.length; l++) {\r\n\t                    var solution = solutions[l][2];\r\n\t                    //Log.info(\"Solution id= \" + solutions[l][1] + ' nr points = ' + solution.length + \", points = \" + solution);\r\n\t                    var intersect = false;\r\n\t\r\n\t                    var innerLines = solution.slice(); //just a shallow copy\r\n\t\r\n\t                    /*If any bounds just trim the solution. So we avoid the strange case when a connection\r\n\t                     *startes from a point on a figure and ends inside of the same figure, but not on a connection point*/\r\n\t                    if (eBounds || sBounds) {\r\n\t                        //i0nnerLines = innerLines.slice(0, innerLines.length - 1);\r\n\t                        innerLines = innerLines.slice(1, innerLines.length - 1);\r\n\t                        //Log.info(\"\\t eBounds present,innerLines nr. points = \" + innerLines.length + \", points = \" + innerLines);\r\n\t                    }\r\n\t\r\n\t\r\n\t\r\n\t                    //now test for intersection\r\n\t                    if (sBounds) {\r\n\t                        intersect = intersect || Util.polylineIntersectsRectangle(innerLines, sBounds);\r\n\t                    }\r\n\t                    if (eBounds) {\r\n\t                        intersect = intersect || Util.polylineIntersectsRectangle(innerLines, eBounds);\r\n\t                    }\r\n\t\r\n\t                    if (!intersect) {\r\n\t                        nonIntersectionSolutions.push(solutions[l]);\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                //If all solutions intersect than this is destiny  :) and just ignore the intersection filter\r\n\t                if (nonIntersectionSolutions.length != 0) {\r\n\t                    //reasign to solutions\r\n\t                    solutions = nonIntersectionSolutions;\r\n\t                }\r\n\t\r\n\t                Log.info(\"\\n\\t nonIntersectionSolutions = \" + solutions.length);\r\n\t\r\n\t\r\n\t                //4. get first class of solutions with same nr of points 选择与第一个方案点数一样多的方案（因为第一个方案点数最少）\r\n\t                Log.info(\"Get first class of solutions with same nr of points\");\r\n\t                if (solutions.length == 0) {\r\n\t                    Log.info(\"This is not possible\");\r\n\t                }\r\n\t\r\n\t                var firstSolution = solutions[0][2]; //pick first solution\r\n\t                var nrOfPoints = firstSolution.length;\r\n\t                var sameNrPointsSolution = [];\r\n\t\r\n\t                for (var l = 0; l < solutions.length; l++) {\r\n\t                    var solution = solutions[l][2];\r\n\t                    if (solution.length == nrOfPoints) {\r\n\t                        sameNrPointsSolution.push(solutions[l]);\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                solutions = sameNrPointsSolution;\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t                /*5.  计算路径分数 ，取最分数高的\r\n\t                 Pick the first solution with 90 degree angles (less turnarounds)\r\n\t                 *in case we have more than one solution in our class\r\n\t                 */\r\n\t                Log.info(\"pick the first solution with 90 degree angles (less turnarounds)\");\r\n\t                var solIndex = 0;\r\n\t                for (var l = 0; l < solutions.length; l++) {\r\n\t                    var solution = solutions[l][2];\r\n\t                    if (Util.scorePath(solutions[solIndex][2]) < Util.scorePath(solutions[l][2])) {\r\n\t                        solIndex = l;\r\n\t                    }\r\n\t                }\r\n\t                solutions = [solutions[solIndex]];\r\n\t\r\n\t\r\n\t                break;\r\n\t        }\r\n\t\r\n\t        //SMOOTHING curve\r\n\t        if (type === Connector.TYPE_CURVE) {\r\n\t            this.smoothCurve(solutions);\r\n\t        }\r\n\t        //END SMOOTHING curve\r\n\t\r\n\t        Log.groupEnd();\r\n\t\r\n\t        return solutions;\r\n\t    }\r\n\t\r\n\t    ConnectionManager.prototype.smoothCurve = function (solutions) {\r\n\t        var option = 3;\r\n\t\r\n\t        switch (option) {\r\n\t            case 0:\r\n\t                //do nothing\r\n\t                break;\r\n\t\r\n\t            case 1: //add intermediate points\r\n\t                //Add the middle point for start and end segment so that we \"force\" the\r\n\t                //curve to both come \"perpendicular\" on bounds and also make the curve\r\n\t                //\"flee\" more from bounds (on exit)\r\n\t                for (var s = 0; s < solutions.length; s++) {\r\n\t                    var solTurningPoints = solutions[s][2];\r\n\t\r\n\t                    //first segment\r\n\t                    var a1 = solTurningPoints[0];\r\n\t                    var a2 = solTurningPoints[1];\r\n\t                    var startMiddlePoint = Util.getMiddle(a1, a2);\r\n\t                    solTurningPoints.splice(1, 0, startMiddlePoint);\r\n\t\r\n\t                    //last segment\r\n\t                    var a3 = solTurningPoints[solTurningPoints.length - 2];\r\n\t                    var a4 = solTurningPoints[solTurningPoints.length - 1];\r\n\t                    var endMiddlePoint = Util.getMiddle(a3, a4);\r\n\t                    solTurningPoints.splice(solTurningPoints.length - 1, 0, endMiddlePoint);\r\n\t                }\r\n\t                break;\r\n\t\r\n\t            case 2: //remove points\r\n\t\r\n\t                zrUtil.each(solutions, function(solution) {\r\n\t                    var solType = solution[0];\r\n\t                    if (solType == 's1' || solType == 's2') {\r\n\t                        var solTurningPoints = solution[2];\r\n\t                        solTurningPoints.splice(1, 1);\r\n\t                        solTurningPoints.splice(solTurningPoints.length - 2, 1);\r\n\t                    }\r\n\t                });\r\n\t                break;\r\n\t\r\n\t            case 3:\r\n\t                /*remove colinear point for s1 as it seems that more colinear points do not look good\r\n\t                 * on organic solutions >:D*/\r\n\t                zrUtil.each(solutions, function(solution) {\r\n\t                    var solType = solution[0];\r\n\t                    if (solType == 's1') {\r\n\t                        var solTurningPoints = solution[2];\r\n\t                        var reducedSolution = Util.collinearReduction(solTurningPoints);\r\n\t                        solution[2] = reducedSolution;\r\n\t                    }\r\n\t                });\r\n\t                break;\r\n\t        } //end switch\r\n\t\r\n\t    }\r\n\t\r\n\t    module.exports = ConnectionManager;\r\n\n\n/***/ }),\n/* 92 */\n/***/ (function(module, exports) {\n\n\t/**\r\n\t * 日志类\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t\r\n\t    var Log  = {\r\n\t        LOG_LEVEL_NONE  : 0,\r\n\t\r\n\t        LOG_LEVEL_DEBUG : 1,\r\n\t\r\n\t        LOG_LEVEL_INFO : 2,\r\n\t\r\n\t        LOG_LEVEL_ERROR : 3,\r\n\t\r\n\t        level : this.LOG_LEVEL_ERROR,\r\n\t        \r\n\t        /**\r\n\t        * The less important of all messages\r\n\t        * @param {String} message - the message to be logged\r\n\t        **/\r\n\t        debug: function (message){\r\n\t            if(typeof console !== 'undefined'){\r\n\t                if(this.level <= this.LOG_LEVEL_DEBUG){\r\n\t                    \r\n\t                    //in FF is debug\r\n\t                    if(typeof console.debug == 'function'){\r\n\t                        console.debug(message);\r\n\t                    }\r\n\t                    else{//TODO: in IE is log\r\n\t    //                    console.info(message);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t\r\n\t\r\n\t        /**\r\n\t        * The commonly used log message\r\n\t        * @param {String} message - the message to be logged\r\n\t        **/\r\n\t        info : function (message){\r\n\t            if(typeof console !== 'undefined'){\r\n\t                if(this.level <= this.LOG_LEVEL_INFO){\r\n\t                    console.info(message);\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /**\r\n\t        * The worse kind of message. Usually a crash\r\n\t        * @param {String} message - the message to be logged\r\n\t        **/\r\n\t        error : function (message){\r\n\t            if(typeof console !== 'undefined'){\r\n\t                if(this.level <= this.LOG_LEVEL_ERROR){\r\n\t                    console.error(message);\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         *Start grouping the log messages\r\n\t         *@param {String} title - the title of the group\r\n\t         *@see <a href=\"http://getfirebug.com/logging\">http://getfirebug.com/logging</a>\r\n\t         **/\r\n\t        group : function(title){\r\n\t            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info\r\n\t                if(typeof console !== 'undefined'){           \r\n\t                    /**If we do not test for group() function you will get an error in Opera\r\n\t                     *as Opera has it's own console...which does not have a group() function*/\r\n\t                    if(typeof console.group === 'function'){\r\n\t                        console.group(title);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /**Ends current message grouping*/\r\n\t        groupEnd : function(){\r\n\t            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info\r\n\t                if(typeof console !== 'undefined'){\r\n\t                    /**If we do not test for groupEnd() function you will get an error in Opera\r\n\t                     *as Opera has it's own console...which does not have a group() function*/\r\n\t                    if(typeof console.groupEnd === 'function'){\r\n\t                        console.groupEnd();\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    //Log.level = Log.LOG_LEVEL_DEBUG; \r\n\t    Log.level = Log.LOG_LEVEL_ERROR; \r\n\t    //Log.level = Log.LOG_LEVEL_ERROR;\r\n\t    //Log.level = Log.LOG_LEVEL_NONE;\r\n\t    module.exports = Log;\r\n\t    \r\n\n\n/***/ }),\n/* 93 */\n/***/ (function(module, exports) {\n\n\t/**\r\n\t * 常量定义\r\n\t */\r\n\t\r\n\t\tmodule.exports = \t{\r\n\t\t\tELEMENT_TYPE: \"elementType\",\r\n\t\t\tMODE: \"mode\",\r\n\t\t\tBACKGROUND: \"backgroud\",\r\n\t\t\tOPTIONS: \"options\",\r\n\t\t\tUSERDATA: \"userData\",\r\n\t\t\tID: \"id\",\r\n\t\t\tSTART_ID: \"startNodeId\",\r\n\t\t\tEND_ID: \"endNodeId\",\r\n\t\t\tALARM: \"Alarm\",\r\n\t\t\tRELATIONID:\"relationId\",\r\n\t\t\tRELATION_IMAGE:\"relationImage\",\r\n\t\t\tGROUP: \"Group\",\r\n\t\t\tGROUP_NODE:\"GroupNode\",\r\n\t\t\tCONNECTION: \"connection\",\r\n\t\t\tCHILDS: \"childs\",\r\n\t\t\tTREE_ROOT: \"treeRoot\",\r\n\t\t\tDOCKERS:\"options.dockers\",\r\n\t\t\tSTYLE_LINETYPE:\"style.lineType\",\r\n\t\t\tLINEOPERATIONICON:\"LineOperationIcon\",\r\n\t\t\tDEL:\"DEL\",\r\n\t\t\tLINK:\"straight\",\r\n\t\t\tFOLD:\"jagged\",\r\n\t\t\tCURVE:\"curve\"\r\n\t\t};\r\n\t\r\n\n\n/***/ }),\n/* 94 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Flow工具类\r\n\t * @author wang.xiaohu9\r\n\t */\r\n\t\r\n\t    var Constants = __webpack_require__(93);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var GroupNode = __webpack_require__(95);\r\n\t    var Rect = __webpack_require__(97);\r\n\t    var Circle = __webpack_require__(98);\r\n\t    var Image = __webpack_require__(99);\r\n\t    var Text = __webpack_require__(100);\r\n\t    var Sector = __webpack_require__(101);\r\n\t    var Ring = __webpack_require__(102);\r\n\t    var Ellipse = __webpack_require__(103);\r\n\t    var Heart = __webpack_require__(104);\r\n\t    var Droplet = __webpack_require__(105);\r\n\t    var Rose = __webpack_require__(106);\r\n\t    var Isogon = __webpack_require__(107);\r\n\t    var Polygon = __webpack_require__(108);\r\n\t    var Line = __webpack_require__(109);\r\n\t    var Polyline = __webpack_require__(110);\r\n\t    var BezierCurve = __webpack_require__(111);\r\n\t    var Arc = __webpack_require__(112);\r\n\t    var Star = __webpack_require__(113);\r\n\t    var Trochoid = __webpack_require__(114);\r\n\t    var Path = __webpack_require__(115);\r\n\t    var IconButton = __webpack_require__(116);\r\n\t    var Connector = __webpack_require__(82);\r\n\t    var flowLink = __webpack_require__(117);\r\n\t    /**\r\n\t     * 根据结点数组 导出JSON格式的数据\r\n\t     *\r\n\t     * @param {Array} model 总的模型\r\n\t     * @return {JSON} JSON格式的数据\r\n\t     */\r\n\t    function toJson(model, group) {\r\n\t        var jsonArr = [];\r\n\t        group.eachChild(function (node) {\r\n\t            if (node.model) {\r\n\t                //如果是组的话\r\n\t                if (node instanceof GroupNode) {\r\n\t                    var childArr = [];\r\n\t                    node.eachChild(function (childNode) {\r\n\t                        if (childNode.model) {\r\n\t                            if (childNode instanceof Connector) {\r\n\t                                childNode.refreshModel();\r\n\t                            } else {\r\n\t                                childNode.model.set(\"options.position\", childNode.position);\r\n\t                            }\r\n\t                            childArr.push(childNode.model.option);\r\n\t                        }\r\n\t                    });\r\n\t                    node.model.set(Constants.CHILDS, childArr);\r\n\t                }\r\n\t                if (node instanceof Connector) {\r\n\t                    node.refreshModel();\r\n\t                }\r\n\t                jsonArr.push(node.model.option);\r\n\t\r\n\t            }\r\n\t\r\n\t        })\r\n\t        model.set(Constants.CHILDS, jsonArr);\r\n\t        return model.option;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 根据 JSON 生成节点\r\n\t     * @param  {[type]} fishTopoflow [description]\r\n\t     * @param  {[type]} json         [description]\r\n\t     * @param {Boolean} isNoCount 是否需要step计数，默认是需要计数\r\n\t     * @return {[type]}              [description]\r\n\t     */\r\n\t    function fromJson(fishTopoflow, group, childShapes, isChild, layoutRootNode, isNoCount) {\r\n\t        var connectors = [];\r\n\t        // 1.先创建节点  遍历形状 获取模型\r\n\t        for (var i = 0; i < childShapes.length; i++) {\r\n\t            var shape = childShapes[i];\r\n\t            if (shape.elementType === Constants.CONNECTION) {\r\n\t                connectors.push(shape);\r\n\t            } else if (shape.elementType === Constants.ALARM) {\r\n\t                var relationNode = findNodeById(fishTopoflow.allNodes, shape.relationId);\r\n\t                fishTopoflow.createAlarm(relationNode, shape.options);\r\n\t            } else if ((shape.elementType === Constants.GROUP_NODE) || (shape.elementType === Constants.GROUP)) {\r\n\t                // 解决反序列组，组连线无法匹配组问题\r\n\t                // shape.options.id = shape.id;\r\n\t                var createdGroup = fishTopoflow.createNode(Constants.GROUP, shape.options, shape.userData);\r\n\t                if (shape.childs) {\r\n\t                    fromJson(fishTopoflow, createdGroup, shape.childs, true, layoutRootNode, isNoCount);\r\n\t                }\r\n\t\r\n\t                // 判断组节点是否有父节点\r\n\t                if (isChild) {\r\n\t                    group.add(createdGroup);\r\n\t                } else {\r\n\t                    fishTopoflow.addNode(createdGroup, {}, isNoCount);\r\n\t                }\r\n\t\r\n\t\r\n\t            } else {\r\n\t                // 根据options创建节点\r\n\t                var node = fishTopoflow.createNode(shape.elementType, shape.options, shape.userData);\r\n\t                if (isChild) {\r\n\t                    group.add(node);\r\n\t                } else {\r\n\t                    fishTopoflow.addNode(node, {}, isNoCount);\r\n\t                }\r\n\t\r\n\t                if (shape.options.layout) {\r\n\t                    if (shape.options.layout.layout === Constants.TREE_ROOT) {\r\n\t                        var nodeForLayout = findNodeById(fishTopoflow.allNodes, shape.id)\r\n\t                        layoutRootNode.push(nodeForLayout);\r\n\t                        //  fishTopo.layoutNode(\"tree\",{\"node\":node});\r\n\t                    }\r\n\t                }\r\n\t\r\n\t            }\r\n\t        }\r\n\t\r\n\t        // 2. 再创建线\r\n\t        zrUtil.each(connectors, function (line) {\r\n\t            var startNode = findNodeById(fishTopoflow.allNodes, line.startNodeId);\r\n\t            var endNode = findNodeById(fishTopoflow.allNodes, line.endNodeId);\r\n\t            if (startNode && endNode) {\r\n\t                var link = fishTopoflow.createLink(startNode, endNode, line.options, line.userData);\r\n\t                if (isChild) {\r\n\t                    group.add(link);\r\n\t                } else {\r\n\t                    fishTopoflow.addNode(link, {}, isNoCount);\r\n\t                }\r\n\t            }else{\r\n\t                var thisLink = flowLink.Link.createByPoint(line.options,line.userData);\r\n\t                if (isChild) {\r\n\t                    group.add(thisLink);\r\n\t                } else {\r\n\t                    fishTopoflow.addNode(thisLink, {}, isNoCount);\r\n\t                }\r\n\t            }\r\n\t        })\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 根据id在group中查找,  因组内子节点之间的连线,在group中查找不到,所以要在allNodes里面取\r\n\t     * @param  {[type]} group  [description]\r\n\t     * @param  {[type]} nodeId [description]\r\n\t     * @return {[type]}        [description]\r\n\t     */\r\n\t    function findNodeById(allNodes, nodeId) {\r\n\t        var retNode = null;\r\n\t        allNodes.forEach(function (node) {\r\n\t            if (node.id === nodeId) {\r\n\t                retNode = node;\r\n\t            }\r\n\t        });\r\n\t        return retNode;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Get canvas which has all thing rendered\r\n\t     * @param {Object} opts\r\n\t     * @param {string} [opts.backgroundColor]\r\n\t     */\r\n\t    function getRenderedCanvas(zr, opts) {\r\n\t        opts = opts || {};\r\n\t        opts.pixelRatio = opts.pixelRatio || 1;\r\n\t        opts.backgroundColor = opts.backgroundColor ||\r\n\t            \"#FFFFFF\";\r\n\t        var list = zr.storage.getDisplayList();\r\n\t        // Stop animations\r\n\t        zrUtil.each(list, function (el) {\r\n\t            var animators = el.animators;\r\n\t            var len = animators.length;\r\n\t            for (var i = 0; i < len; i++) {\r\n\t                animators[i].stop(false);\r\n\t            }\r\n\t        });\r\n\t        return zr.painter.getRenderedCanvas(opts);\r\n\t    }\r\n\t\r\n\t    function toDataURL(zr, opts) {\r\n\t        opts = opts || {};\r\n\t        var url = getRenderedCanvas(zr, opts).toDataURL(\r\n\t            'image/' + (opts && opts.type || 'png')\r\n\t        );\r\n\t        var list = zr.storage.getDisplayList();\r\n\t        // Start animations\r\n\t        zrUtil.each(list, function (el) {\r\n\t            var animators = el.animators;\r\n\t            var len = animators.length;\r\n\t            for (var i = 0; i < len; i++) {\r\n\t                animators[i].start();\r\n\t            }\r\n\t        });\r\n\t        return url;\r\n\t    }\r\n\t\r\n\t    function truncPosition(position) {\r\n\t        var x = parseInt(position[0], 10);\r\n\t        var y = parseInt(position[1], 10);\r\n\t        if (x < 0) {\r\n\t            x = 0\r\n\t        }\r\n\t        if (y < 0) {\r\n\t            y = 0\r\n\t        }\r\n\t        return [x, y];\r\n\t    }\r\n\t\r\n\t    function registerFlowNode(flowNode) {\r\n\t        var nodeCtors = {\r\n\t            Rect: Rect,\r\n\t            Circle: Circle,\r\n\t            Image: Image,\r\n\t            Text: Text,\r\n\t            Sector: Sector,\r\n\t            Ring: Ring,\r\n\t            Ellipse: Ellipse,\r\n\t            Heart: Heart,\r\n\t            Droplet: Droplet,\r\n\t            Rose: Rose,\r\n\t            Isogon: Isogon,\r\n\t            Polygon: Polygon,\r\n\t            Line: Line,\r\n\t            Polyline: Polyline,\r\n\t            BezierCurve: BezierCurve,\r\n\t            Arc: Arc,\r\n\t            Star: Star,\r\n\t            Trochoid: Trochoid,\r\n\t            Path: Path,\r\n\t            Group: GroupNode,\r\n\t            IconButton: IconButton\r\n\t        }\r\n\t        for (var name in nodeCtors) {\r\n\t            flowNode[name] = nodeCtors[name]\r\n\t        }\r\n\t        return flowNode;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Normalize css liked array configuration\r\n\t     * e.g.\r\n\t     *  3 => [3, 3, 3, 3]\r\n\t     *  [4, 2] => [4, 2, 4, 2]\r\n\t     *  [4, 3, 2] => [4, 3, 2, 3]\r\n\t     * @param {number|Array.<number>} val\r\n\t     */\r\n\t    function normalizeCssArray(val) {\r\n\t        var len = val.length;\r\n\t        if (typeof (val) === 'number') {\r\n\t            return [val, val, val, val];\r\n\t        } else if (len === 2) {\r\n\t            // vertical | horizontal\r\n\t            return [val[0], val[1], val[0], val[1]];\r\n\t        } else if (len === 3) {\r\n\t            // top | horizontal | bottom\r\n\t            return [val[0], val[1], val[2], val[1]];\r\n\t        }\r\n\t        return val;\r\n\t    }\r\n\t\r\n\t    function _trim(str) {\r\n\t        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\r\n\t    }\r\n\t\r\n\t    function parsePercent(percent, all) {\r\n\t        switch (percent) {\r\n\t            case 'center':\r\n\t            case 'middle':\r\n\t                percent = '50%';\r\n\t                break;\r\n\t            case 'left':\r\n\t            case 'top':\r\n\t                percent = '0%';\r\n\t                break;\r\n\t            case 'right':\r\n\t            case 'bottom':\r\n\t                percent = '100%';\r\n\t                break;\r\n\t        }\r\n\t        if (typeof percent === 'string') {\r\n\t            if (_trim(percent).match(/%$/)) {\r\n\t                return parseFloat(percent) / 100 * all;\r\n\t            }\r\n\t\r\n\t            return parseFloat(percent);\r\n\t        }\r\n\t\r\n\t        return percent == null ? NaN : +percent;\r\n\t    }\r\n\t\r\n\t\r\n\t\r\n\t    /**\r\n\t     * @param {string} str\r\n\t     * @param {boolean} [upperCaseFirst=false]\r\n\t     * @return {string} str\r\n\t     */\r\n\t    function toCamelCase(str, upperCaseFirst) {\r\n\t        str = (str || '').toLowerCase().replace(/-(.)/g, function (match, group1) {\r\n\t            return group1.toUpperCase();\r\n\t        });\r\n\t\r\n\t        if (upperCaseFirst && str) {\r\n\t            str = str.charAt(0).toUpperCase() + str.slice(1);\r\n\t        }\r\n\t\r\n\t        return str;\r\n\t    }\r\n\t    /**\r\n\t     * Enable property storage to any host object.\r\n\t     * Notice: Serialization is not supported.\r\n\t     *\r\n\t     * For example:\r\n\t     * var get = modelUitl.makeGetter();\r\n\t     *\r\n\t     * function some(hostObj) {\r\n\t     *      get(hostObj)._someProperty = 1212;\r\n\t     *      ...\r\n\t     * }\r\n\t     *\r\n\t     * @return {Function}\r\n\t     */\r\n\t    var makeGetter = (function () {\r\n\t        var index = 0;\r\n\t        return function () {\r\n\t            var key = '\\0__topo_prop_getter_' + index++;\r\n\t            return function (hostObj) {\r\n\t                return hostObj[key] || (hostObj[key] = {});\r\n\t            };\r\n\t        };\r\n\t    })();\r\n\t    var encodeHTML = function (source) {\r\n\t        return String(source)\r\n\t            .replace(/&/g, '&amp;')\r\n\t            .replace(/</g, '&lt;')\r\n\t            .replace(/>/g, '&gt;')\r\n\t            .replace(/\"/g, '&quot;')\r\n\t            .replace(/'/g, '&#39;');\r\n\t    };\r\n\t\r\n\t    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\r\n\t\r\n\t    var wrapVar = function (varName, seriesIdx) {\r\n\t        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\r\n\t    };\r\n\t    /**\r\n\t     * Template formatter\r\n\t     * @param {string} tpl\r\n\t     * @param {Array.<Object>|Object} paramsList\r\n\t     * @param {boolean} [encode=false]\r\n\t     * @return {string}\r\n\t     */\r\n\t    function formatTpl(tpl, paramsList, encode) {\r\n\t        if (!zrUtil.isArray(paramsList)) {\r\n\t            paramsList = [paramsList];\r\n\t        }\r\n\t        var seriesLen = paramsList.length;\r\n\t        if (!seriesLen) {\r\n\t            return '';\r\n\t        }\r\n\t\r\n\t        var $vars = paramsList[0].$vars || [];\r\n\t        for (var i = 0; i < $vars.length; i++) {\r\n\t            var alias = TPL_VAR_ALIAS[i];\r\n\t            var val = wrapVar(alias, 0);\r\n\t            tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);\r\n\t        }\r\n\t        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\r\n\t            for (var k = 0; k < $vars.length; k++) {\r\n\t                var ret = paramsList[seriesIdx][$vars[k]];\r\n\t                tpl = tpl.replace(\r\n\t                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\r\n\t                    encode ? encodeHTML(ret) : ret\r\n\t                );\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return tpl;\r\n\t    }\r\n\t\r\n\t\r\n\t    module.exports = {\r\n\t        toJson: toJson,\r\n\t        fromJson: fromJson,\r\n\t        toDataURL: toDataURL,\r\n\t        truncPosition: truncPosition,\r\n\t        registerFlowNode: registerFlowNode,\r\n\t        normalizeCssArray: normalizeCssArray,\r\n\t        parsePercent: parsePercent,\r\n\t        toCamelCase: toCamelCase,\r\n\t        makeGetter: makeGetter,\r\n\t        formatTpl: formatTpl,\r\n\t        findNodeById: findNodeById\r\n\t    };\r\n\n\n/***/ }),\n/* 95 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 组， 组中元素的坐标都是相对于这个组的<br>\r\n\t * @class fishTopoFlow.node.GroupNode\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var group1 = new node.Group({\r\n\t *           position:[60,50]\r\n\t *       });\r\n\t *\r\n\t *       var rect1 = new node.Rect({\r\n\t *           shape:{width:120,height:30},\r\n\t *           style:{text:\"标题\", fill:\"#FFB90F\",stroke:\"#bbbbbb\"},\r\n\t *           position:[0,0],\r\n\t *           selectable:false\r\n\t *       });\r\n\t *\r\n\t *       var rect2 = new node.Rect({\r\n\t *           shape:{width:120,height:60},\r\n\t *           style:{text:\"内容\", fill:\"#FFFFFF\",stroke:\"#bbbbbb\"},\r\n\t *           position:[0,30],\r\n\t *           selectable:false\r\n\t *       });\r\n\t *\r\n\t *       group1.add(rect1);\r\n\t *       group1.add(rect2);\r\n\t *       fishTopo.add(group1);\r\n\t */\r\n\t\r\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var BoundingRect = __webpack_require__(27);\r\n\t    var graphic = __webpack_require__(4);\r\n\t    var util = __webpack_require__(65);\r\n\t    var Connector = __webpack_require__(82);\r\n\t    var flowNode =__webpack_require__(96);\r\n\t\r\n\t    function GroupNode(opts) {\r\n\t        this.model = flowNode.genModel(\"GroupNode\", opts);\r\n\t        graphic.Group.call(this, opts);\r\n\t\r\n\t        var defaultOptions = {\r\n\t            shape: {\r\n\t                width: 5,\r\n\t                height: 5,\r\n\t                r: 5\r\n\t            },\r\n\t            style: {\r\n\t                fill: 'rgba(0,0,0,0)',//'#f9f9f9',\r\n\t                stroke: 'rgba(0,0,0,0)'//'#bbbbbb'\r\n\t            },\r\n\t            position: [0, 0]\r\n\t        };\r\n\t        this.options = zrUtil.merge(defaultOptions, opts, true);\r\n\t        //函数无法clone 原型clone不上\r\n\t        this.options.layout = opts.layout;\r\n\t        this.max = [1024, 960];\r\n\t        this.render(this.options);\r\n\t    }\r\n\t    GroupNode.RECT_NAME = \"GROUP_RECT_NAME\";\r\n\t    GroupNode.prototype = {\r\n\t        constructor: GroupNode,\r\n\t        type: \"GroupNode\",\r\n\t        render: function (model) {\r\n\t            var rect = new graphic.Rect({\r\n\t                shape: model.shape,\r\n\t                style: model.style,\r\n\t                //silent:true, //加上后 拖动 组中没有子元素的地方 无法手动了\r\n\t                z: 1\r\n\t            });\r\n\t            rect.name = GroupNode.RECT_NAME;\r\n\t            this.add(rect);\r\n\t            this.position = model.position;\r\n\t            this.mergedImage = model.mergedImage;\r\n\t        },\r\n\t        rectContain: function (x, y) {\r\n\t            var rect = util.getRect(this);\r\n\t            return rect.boundingRect.contain(x, y);\r\n\t        },\r\n\t\r\n\t        add: function(child) {\r\n\t            if (child && child !== this && child.parent !== this) {\r\n\t                this._children.push(child);\r\n\t                this._doAdd(child);\r\n\t            }\r\n\t            this._api && this._api._addGroupNode(this,child);\r\n\t            return this;\r\n\t\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 遍历组中每一个子节点\r\n\t         * @param  {Function} cb 回调函数cb\r\n\t         * @param  {Object} context   上下文context\r\n\t         */\r\n\t        each: function (cb, context) {\r\n\t            var children = this._children;\r\n\t            for (var i = 0; i < children.length; i++) {\r\n\t                var child = children[i];\r\n\t                if (child.name != GroupNode.RECT_NAME) {\r\n\t                    cb.call(context, child, i);\r\n\t                }\r\n\t            }\r\n\t            return this;\r\n\t        },\r\n\t        // 设置 group中框形大小为 group的包围和\r\n\t        willRender:function (api) {\r\n\t            if (this.options.layout) {\r\n\t                this.setLayout(this.options.layout);\r\n\t            }\r\n\t            this.setProperties({\r\n\t                shape: {\r\n\t                    width: this.getBoundingRect().width,\r\n\t                    height: this.getBoundingRect().height\r\n\t                }\r\n\t            });\r\n\t            this._api = api;\r\n\t        },\r\n\t\r\n\t        setLayout: function(Layout) {\r\n\t            Layout.run(this);\r\n\t        },\r\n\t\r\n\t        getRect: function () {\r\n\t            var boundingRect = this.getBoundingRect();\r\n\t            var clipPath = this.clipPath;\r\n\t            // 节点裁剪后，以裁剪节点包围盒为准\r\n\t            if (clipPath) {\r\n\t                boundingRect = clipPath.getBoundingRect();\r\n\t            }\r\n\t            //创建最小包围盒虚线\r\n\t            var points = [];\r\n\t            points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n\t            points[1] = [boundingRect.width / 2, -boundingRect.height / 2];\r\n\t            points[2] = [boundingRect.width / 2, boundingRect.height / 2];\r\n\t            points[3] = [-boundingRect.width / 2, boundingRect.height / 2];\r\n\t            points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n\t\r\n\t            var boundRect = new BoundingRect(this.position[0],\r\n\t                this.position[1],\r\n\t                boundingRect.width, boundingRect.height);\r\n\t            return {\r\n\t                x: this.position[0] + boundingRect.width / 2,\r\n\t                y: this.position[1] + boundingRect.height / 2,\r\n\t                width: boundingRect.width,\r\n\t                height: boundingRect.height,\r\n\t                points: points,\r\n\t                boundingRect: boundRect\r\n\t            };\r\n\t        },\r\n\t        /**\r\n\t         * 拖拽组内节点的时候，动态更改背景rect的大小\r\n\t         * @param nodeMessage 拖拽的组内节点的信息\r\n\t         */\r\n\t        modifyGroupRect: function (nodeMessage) {\r\n\t            //1.重置背景rect 的长宽\r\n\t            var minLength = this.options.shape.r;\r\n\t            this.setProperties({\r\n\t                shape: {\r\n\t                    width: minLength,\r\n\t                    height: minLength,\r\n\t                    r: minLength\r\n\t                }\r\n\t            });\r\n\t\r\n\t            var rect = this.childOfName(GroupNode.RECT_NAME);\r\n\t            var boundingRect = this.getBoundingRect();\r\n\t            var width = boundingRect.width;\r\n\t            var height = boundingRect.height;\r\n\t            var rx = rect.position[0],//rect.shape.x,\r\n\t                ry = rect.position[1];//rect.shape.y;\r\n\t            //2.取group中所有节点最靠上边和最高左边的值，不包括背景rect的值\r\n\t            var minX = this._children[1].position[0],\r\n\t                minY = this._children[1].position[1];\r\n\t            var maxX = this._children[1].position[0],\r\n\t                maxY = this._children[1].position[1];\r\n\t            var nowNodePosition = zrUtil.clone(nodeMessage.position);\r\n\t            for (var i = 1; i < this._children.length; i++) {\r\n\t                if (this._children[i] instanceof Connector || this._children[i].isIcon == true) {\r\n\t                    continue;\r\n\t                } else {\r\n\t                    if (minX > this._children[i].position[0]) {\r\n\t                        minX = this._children[i].position[0];\r\n\t                    }\r\n\t                    if (maxX < this._children[i].position[0]) {\r\n\t                        maxX = this._children[i].position[0];\r\n\t                    }\r\n\t                    if (minY > this._children[i].position[1]) {\r\n\t                        minY = this._children[i].position[1];\r\n\t                    }\r\n\t                    if (maxY < this._children[i].position[1]) {\r\n\t                        maxY = this._children[i].position[1];\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t\r\n\t            // 3. 宽度大于最大宽度\r\n\t            if (width > this.max[0]) {\r\n\t                width = this.max[0] - 2;\r\n\t                if (nodeMessage.position[0] > minX) {\r\n\t                    nowNodePosition[0] = minX + this.max[0] - nodeMessage.width;\r\n\t                } else {\r\n\t                    nowNodePosition[0] = maxX - this.max[0] + nodeMessage.width;\r\n\t                }\r\n\t            } else {\r\n\t                //移动节点改变group中背景rect的x位置，不超过最小的值\r\n\t                rx = rect.position[0] + nodeMessage.position[0];\r\n\t                if (rx > minX) {\r\n\t                    rx = minX;\r\n\t                }\r\n\t                if (nodeMessage.isMove) { //drag\r\n\t                    nowNodePosition[0] = nodeMessage.movePosition[0] + nodeMessage.moveX;\r\n\t                } else {\r\n\t                    nowNodePosition[0] = nodeMessage.position;\r\n\t                }\r\n\t                if (nodeMessage.position[0] > minX) {\r\n\t                    if (nowNodePosition[0] > minX + this.max[0] - nodeMessage.width) {\r\n\t                        nowNodePosition[0] = minX + this.max[0] - nodeMessage.width;\r\n\t                    }\r\n\t                } else {\r\n\t                    if (nowNodePosition[0] < maxX - this.max[0] + nodeMessage.width) {\r\n\t                        nowNodePosition[0] = maxX - this.max[0] + nodeMessage.width\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t            if (height > this.max[1]) {\r\n\t                height = this.max[1] - 2;\r\n\t                if (nodeMessage.position[1] > minY) {\r\n\t                    nowNodePosition[1] = minY + this.max[1] - nodeMessage.height;\r\n\t                } else {\r\n\t                    nowNodePosition[1] = maxY - this.max[1] + nodeMessage.height;\r\n\t                }\r\n\t            } else {\r\n\t                //移动节点改变group中背景rect的y位置，不超过最小的值\r\n\t                ry = rect.position[1] + (nodeMessage.position[1]);\r\n\t                if (ry > minY) {\r\n\t                    ry = minY;\r\n\t                }\r\n\t                if (nodeMessage.isMove) {\r\n\t                    nowNodePosition[1] = nodeMessage.movePosition[1] + nodeMessage.moveY;\r\n\t                } else {\r\n\t                    nowNodePosition[1] = nodeMessage.position[1];\r\n\t                }\r\n\t                if (nodeMessage.position[1] > minY) {\r\n\t                    if (nowNodePosition[1] > minY + this.max[1] - nodeMessage.height) {\r\n\t                        nowNodePosition[1] = minY + this.max[1] - nodeMessage.height;\r\n\t                    }\r\n\t                } else {\r\n\t                    if (nowNodePosition[1] < maxY - this.max[1] + nodeMessage.height) {\r\n\t                        nowNodePosition[1] = maxY - this.max[1] + nodeMessage.height\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t            if (nodeMessage.node.alarm) {\r\n\t                var newAlarmPosition = [nowNodePosition[0] + nodeMessage.node.getBoundingRect().width - (nodeMessage.node.alarm\r\n\t                        .getBoundingRect().width - 6), nowNodePosition[1] - nodeMessage.node.alarm.getBoundingRect()\r\n\t                    .height - 3\r\n\t                ];\r\n\t                nodeMessage.node.alarm.attr(\"position\", newAlarmPosition);\r\n\t            }\r\n\t            //改变背景rect的长宽和位置\r\n\t            this.setProperties({\r\n\t                shape: {\r\n\t                    width: width,\r\n\t                    height: height,\r\n\t                    x: rx,\r\n\t                    y: ry\r\n\t                }\r\n\t            });\r\n\t\r\n\t        },\r\n\t\r\n\t        setProperties: function (opt) {\r\n\t            var rect = this.childOfName(GroupNode.RECT_NAME);\r\n\t            rect.setShape(opt.shape);\r\n\t           // rect.attr(\"style\", opt.style);\r\n\t            this.attr('position', opt.position);\r\n\t           // this.attr(\"shape\", opt.shape);\r\n\t        },\r\n\t\r\n\t        merged: function () {\r\n\t            var that = this;\r\n\t            //保留group的初始位置\r\n\t            var groupPosition = zrUtil.clone(this.position);\r\n\t            //给小图片设置属性，隐藏group\r\n\t            var width = this._relationImage.getBoundingRect().width;\r\n\t            var height = this._relationImage.getBoundingRect().height;\r\n\t            //计算合并后的小图片的position\r\n\t            var relationImagePosition = [this.position[0] + this.childOfName(GroupNode.RECT_NAME).shape.x + (this.getBoundingRect()\r\n\t                    .width / 2 - width / 2), this.position[1] + this.childOfName(GroupNode.RECT_NAME).shape.y +\r\n\t                (this.getBoundingRect().height / 2 - height / 2)\r\n\t            ];\r\n\t            //将小图片的位置保留下来\r\n\t            var cloneImagePosition = zrUtil.clone(relationImagePosition);\r\n\t            this._relationImage.attr(\"style\", {\r\n\t                image: this.mergedImage,\r\n\t                width: width,\r\n\t                height: height\r\n\t            });\r\n\t            this._relationImage.attr(\"position\", relationImagePosition);\r\n\t            if (width > 0 && height > 0) {\r\n\t                this.hide();\r\n\t                this._relationImage.show();\r\n\t            }\r\n\t\r\n\t            //双击图片放出组\r\n\t            this._relationImage.on(\"dblclick\", function () {\r\n\t                //设置组的位置根据小图片的偏移量来计算\r\n\t                that.attr('position',[groupPosition[0] + (this.position[0] -cloneImagePosition[0]),\r\n\t                    groupPosition[1] + (this.position[1] - cloneImagePosition[1])]);\r\n\t                this.hide();\r\n\t                that.show();\r\n\t            });\r\n\t            return this._relationImage;\r\n\t        },\r\n\t        updateShape: function (ratio, ifParse) {\r\n\t            var scaleRatio = Number(ratio);\r\n\t            var shape = this.options.shape;\r\n\t            var newW = Number(shape.width * scaleRatio);\r\n\t            var newH = Number(newW * shape.height / shape.width);\r\n\t            if (ifParse) {\r\n\t                newW = parseInt(newW, 10);\r\n\t                newH = parseInt(newH, 10);\r\n\t            }\r\n\t            // 按比例缩放\r\n\t            this.setProperties({\r\n\t                shape: {\r\n\t                    width: newW,\r\n\t                    height: newH\r\n\t                }\r\n\t            });\r\n\t            // 更新组内节点\r\n\t            this.children().forEach(function(v) {\r\n\t                var position = v.position;\r\n\t                if (v.name !== GroupNode.RECT_NAME && !(v instanceof Connector) && v.type !== 'ZPath') {\r\n\t                    // 每个节点的position更新\r\n\t                    v.updateShape(ratio, ifParse);\r\n\t                    v.attr('position', [position[0] * scaleRatio, position[1] * scaleRatio]);\r\n\t                } else if (v.type === 'ZPath') {\r\n\t                    var rect = v.rect;\r\n\t                    rect.height = rect.height * scaleRatio;\r\n\t                    rect.width = rect.width * scaleRatio;\r\n\t                    v.attr({\r\n\t                        position: [position[0] * scaleRatio, position[1] * scaleRatio],\r\n\t                        rect: rect\r\n\t                    });\r\n\t                }\r\n\t            });\r\n\t        }\r\n\t    }\r\n\t\r\n\t    zrUtil.inherits(GroupNode, graphic.Group);\r\n\t    module.exports = GroupNode;\r\n\t\r\n\t/**\r\n\t * @method add\r\n\t * 将节点加入到这个组中最后\r\n\t * @param {Object} node 欲添加到组的节点\r\n\t */\r\n\t/**\r\n\t * @method removeAll\r\n\t * 移除所有子节点\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method remove\r\n\t * 移除所有子节点\r\n\t * @param {Object} child 子节点\r\n\t */\r\n\t/**\r\n\t * @method childOfName\r\n\t * 获取指定名字的儿子节点\r\n\t * @param {String} name\r\n\t * @return {Object} 节点\r\n\t */\r\n\t/**\r\n\t * @method traverse\r\n\t * 深度优先遍历所有子孙节点（each只遍历子节点）\r\n\t * @param {String} name\r\n\t * @return {Object} 节点\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {String} mergedImage=''  控制当双击时 组可以缩小为指定的图形。\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {Boolean} childDraggable=false  控制组内成员是否可以拖动\r\n\t */\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 96 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\r\n\t * fishTopoFlow的node对象，框架提供的节点都放在这个对象下。通过extend方法创建自定义节点<br>\r\n\t * @class fishTopoFlow.node\r\n\t * @abstract\r\n\t *\r\n\t    * **使用范例**：\r\n\t    *\r\n\t    *      @example\r\n\t    *       var node = fishTopoFlow.node;\r\n\t    *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t    *      var Diamond = node.extend({\r\n\t    *          type: 'Diamond',\r\n\t    *          shape: {\r\n\t    *              width: 0,\r\n\t    *              height: 0\r\n\t    *          },\r\n\t    *          buildPath: function (path, shape) {\r\n\t    *              var cx = 0;\r\n\t    *              var cy = 0;\r\n\t    *              var width = shape.width / 2;\r\n\t    *              var height = shape.height / 2;\r\n\t    *              path.moveTo(cx, cy - height);\r\n\t    *              path.lineTo(cx + width, cy);\r\n\t    *              path.lineTo(cx, cy + height);\r\n\t    *              path.lineTo(cx - width, cy);\r\n\t    *              path.closePath();\r\n\t    *          }\r\n\t    *      });\r\n\t    *        var diamod = new Diamond({\r\n\t    *            shape: {\r\n\t    *                width:50,\r\n\t    *                height:50\r\n\t    *            },\r\n\t    *            position:[60,60]\r\n\t    *        })\r\n\t    *        fishTopo.add(diamod);\r\n\t */\r\n\t\r\n\t    var Path = __webpack_require__(7);\r\n\t    var Constants = __webpack_require__(93);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var util = __webpack_require__(65);\r\n\t    var Model = __webpack_require__(87);\r\n\t    var flowNode = {};\r\n\t    /**\r\n\t     * 构造模型\r\n\t     * @private\r\n\t     */\r\n\t    flowNode.genModel = function (type, opts) {\r\n\t        var model = new Model({});\r\n\t        // 没有id的时候，缺少给一个UUID。创建节点或者反序列化的时候 节点的ID取的是opts.id\r\n\t\t\tif (!opts.id) {\r\n\t\t\t\topts.id = util.getUUID();\r\n\t        }\r\n\t        if (opts.style && opts.style.textLineHeight !== 0 && !opts.style.rich) { //#170\r\n\t            opts.style.rich = {};\r\n\t        }\r\n\t        model.set(Constants.ELEMENT_TYPE, type);\r\n\t        // 防止 new el.constructor({ style: el.style,shape: el.shape }); zrUtil.clone报错\r\n\t        if (opts.style && opts.style.host) {\r\n\t            delete opts.style.host;\r\n\t        }\r\n\t        model.set(Constants.OPTIONS, zrUtil.clone(opts));\r\n\t        if (\"draggable\" in opts) {\r\n\t            opts.isdraggable = opts.draggable;\r\n\t            delete opts.draggable;\r\n\t        }\r\n\t        if (!opts.z) {\r\n\t            opts.z = 1; //节点默认为1，线段0;\r\n\t        }\r\n\t\r\n\t        if (util.isUndefined(opts.hoverAnimation)) {\r\n\t            opts.hoverAnimation = false;\r\n\t        }\r\n\t\r\n\t        if (util.isUndefined(opts.selectable)) {\r\n\t            opts.selectable = true;  //默认可以选中\r\n\t        }\r\n\t        return model;\r\n\t    }\r\n\t\r\n\t    flowNode.addHoverAnimation = function(node) {\r\n\t        var scale = zrUtil.clone(node.scale) || [1,1];\r\n\t        var onEmphasis = function() {\r\n\t            this.animateTo({\r\n\t                scale: [scale[0] * 1.1, scale[1] * 1.1]\r\n\t            }, 400, 'elasticOut');\r\n\t        };\r\n\t        var onNormal = function() {\r\n\t            this.animateTo({\r\n\t                scale: scale\r\n\t            }, 400, 'elasticOut');\r\n\t        };\r\n\t        node.on('mouseover', onEmphasis)\r\n\t            .on('mouseout', onNormal)\r\n\t            .on('emphasis', onEmphasis)\r\n\t            .on('normal', onNormal);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @method extend\r\n\t     * 扩展一个 自定义节点, 比如钻石形等。\r\n\t     * @param {Object} props\r\n\t     * @param {string} props.type 自定义结节的名称 Path type\r\n\t     * @param {Function} [props.init] 初始化 Initialize\r\n\t     * @param {Function} props.buildPath 进行构建节点 Overwrite buildPath method\r\n\t     * @param {Object} [props.style] 缺省样式 Extended default style config\r\n\t     * @param {Object} [props.shape] 缺省节点参数 Extended default shape config\r\n\t     *\r\n\t     */\r\n\t    flowNode.extend = function (defaults) {\r\n\t        var Sub = function (opts) {\r\n\t            this.model = flowNode.genModel(defaults.type, opts);\r\n\t            Path.call(this, opts);\r\n\t\r\n\t            if (defaults.style) {\r\n\t                // Extend default style\r\n\t                this.style.extendFrom(defaults.style, false);\r\n\t            }\r\n\t\r\n\t            // Extend default shape\r\n\t            var defaultShape = defaults.shape;\r\n\t            if (defaultShape) {\r\n\t                this.shape = this.shape || {};\r\n\t                var thisShape = this.shape;\r\n\t                for (var name in defaultShape) {\r\n\t                    if (\r\n\t                        !thisShape.hasOwnProperty(name)\r\n\t                        && defaultShape.hasOwnProperty(name)\r\n\t                    ) {\r\n\t                        thisShape[name] = defaultShape[name];\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t\r\n\t            defaults.init && defaults.init.call(this, opts);\r\n\t\r\n\t        };\r\n\t\r\n\t        zrUtil.inherits(Sub, Path);\r\n\t\r\n\t        // FIXME 不能 extend position, rotation 等引用对象\r\n\t        for (var name in defaults) {\r\n\t            // Extending prototype values and methods\r\n\t            if (name !== 'style' && name !== 'shape') {\r\n\t                Sub.prototype[name] = defaults[name];\r\n\t            }\r\n\t        }\r\n\t        // 重写setStyle\r\n\t        Sub.prototype.setStyle = function(key, value) {\r\n\t            this.style.set(key, value);\r\n\t            this.dirty(false);\r\n\t            zrUtil.merge(this.model.get(\"options.style\"), key, true);\r\n\t            return this;\r\n\t        }\r\n\t\r\n\t        return Sub;\r\n\t    };\r\n\t    module.exports = flowNode;\r\n\t\r\n\t\r\n\t/**\r\n\t * @cfg {Array} position 节点的位置,统一使用position进行定位[x,y] eg. [100,100]\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {Object} style 样式参数\r\n\t * @cfg {string} style.fill=#000 填充色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red | gradient 注：单独文字使用textFill\r\n\t * @cfg {string} style.stroke=null 笔画颜色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red | gradient 注：单独文字使用textStoke\r\n\t * @cfg {number} style.lineWidth=1 笔画宽度\r\n\t * @cfg {Array} style.lineDash=null 笔画的虚线间隔，参数为交替绘制线段和间距长度的数字 参见[lineDashOffset](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/setLineDash) eg. lineDash:[6,10]\r\n\t * @cfg {number} style.lineDashOffset=0  笔画的虚线偏移量 参见[lineDashOffset](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineDashOffset)\r\n\t * @cfg {string} style.text=\"\" 节点上显示的文本,可以使用 \\n 来换行\r\n\t * @cfg {string} style.textFont='12px sans-serif' 字体大小、字体类型、粗细、字体样式。格式参见[css font](https://developer.mozilla.org/en-US/docs/Web/CSS/font) eg.textFont: 'italic bolder 14px Microsoft YaHei'\r\n\t * @cfg {string} style.fontStyle=null 字体样式\r\n\t * @cfg {string} style.fontWeight=#000 字体粗细\r\n\t * @cfg {number} style.fontSize=null 字体大小\r\n\t * @cfg {string} style.fontFamily=null 字体类型\r\n\t * @cfg {string} style.textFill=#000 节点上文本的填充色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red\r\n\t * @cfg {string} style.textStoke=null 节点上文本的描边色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red\r\n\t * @cfg {string|Array} style.textPosition=\"\" 文本在节点中的位置left|right|top|bottom|inside|insideLeft|insideRight|insideTop|insideBottom|insideTopLeft|insideTopRight|insideBottomLeft|insideBottomRight|[x,y]|[%,%]\r\n\t * @cfg {string} style.textBaseline=\"alphabetic\" 当前文本基线的属性 \"top\" || \"hanging\" || \"middle\" || \"alphabetic\" || \"ideographic\" || \"bottom\" 参见[css font](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/textBaseline)\r\n\t * @cfg {Array} style.textOffset=null 文本在节点的偏移值[x,y] eg. [10,10]\r\n\t * @cfg {string} style.textAlign=\"\" 文本在节点中的对齐方式 left | center | right\r\n\t * @cfg {string} style.textVerticalAlign=null 文本在节点中的垂直对齐方式 top | middle | bottom\r\n\t * @cfg {number} style.textDistance=5 文字的相对textPos的偏移量 eg. textPosition='left' textDistance=5 则文字的x坐标的值为 (left的坐标x值) -5\r\n\t * @cfg {string} style.textShadowColor='transparent' 文字阴影颜色\r\n\t * @cfg {number} style.textShadowBlur=0 文本阴影宽度 参见[shadowBlur](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowBlur)\r\n\t * @cfg {number} style.textShadowOffsetX=0 文本阴影 X 方向偏移 参见shadowOffsetX[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetX]\r\n\t * @cfg {number} style.textShadowOffsetY=0 文本阴影 Y 方向偏移 参见shadowOffsetY[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetY]\r\n\t * @cfg {number} style.textRotation=0 文本旋转的角度\r\n\t * @cfg {number} style.textBorderWidth=0 文字描边宽度\r\n\t * @cfg {string} style.textBorderColor=null 文字描边颜色\r\n\t * @cfg {number} style.textBorderRadius=0 文字描边半径\r\n\t * @cfg {string|Object} style.textBackgroundColor=null 文字背景(颜色或图片) eg. '#333' | {image:'./asset/img/clund.png'}\r\n\t * @cfg {number|Array} style.textPadding=null 文字padding  eg. `2` or `[2, 4]` or `[2, 3, 4, 5]`\r\n\t * @cfg {Object} style.rich=null 富文本样式属性\r\n\t * @cfg {number} style.textLineHeight=0 文字的行高\r\n\t * @cfg {number} style.opacity=1 图形透明度。支持从 0 到 1 的数字，为 0 时不绘制该图形。\r\n\t * @cfg {number} style.shadowBlur=0 阴影宽度 参见[shadowBlur](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowBlur)\r\n\t * @cfg {number} style.shadowOffsetX=0 阴影 X 方向偏移 参见shadowOffsetX[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetX]\r\n\t * @cfg {number} style.shadowOffsetY=0 阴影 Y 方向偏移 参见shadowOffsetY[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetY]\r\n\t * @cfg {string} style.shadowColor='#000' 阴影颜色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red 参见[shadowColor](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowColor)\r\n\t * @cfg {string} style.image=\"\" 图片的路径 用于Image\r\n\t * @cfg {number} style.width 图片的宽度 用于Image\r\n\t * @cfg {number} style.height 图片的高度 用于Image\r\n\t */\r\n\t\r\n\t /**\r\n\t * @cfg {Object} hoverStyle hover样式, 参数见style\r\n\t  */\r\n\t /**\r\n\t * @cfg {Object} selectStyle 选中节点的样式, 参数见style;  默认是一个虚的边框;  设为空对象则不显示选中边框;\r\n\t*/\r\n\t/**\r\n\t * @cfg {Boolean} draggable=true 是否可以被拖拽。\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {Boolean} ignore=false 是否隐藏状态（只读），fasle:隐藏,true:不隐藏\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {Boolean} selectable=true 节点是否可选中，默认是true\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {String} id 为了避免重复，目前由系统自动生成，如果不需要用可以忽略。建议使用nmae\r\n\t */\r\n\t\r\n\t/**\r\n\t *  @cfg {Boolean} hoverAnimation=false 是否开启 hover 在节点上的提示动画效果。，默认是false\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {String} name 指定节点的name, 可以使用childOfName等函数根据name查找节点\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {String} tooltip 节点的tooltip 内容可以包括HTML标签\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {Object} relative relative描述怎么根据父元素进行定位，设置了relative属性 就不需要设置position。支持：left、right、top、bottom\r\n\t * @cfg {Number|String} relative.left  距离父元素左边的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.left 和 right 只有一个可以生效。\r\n\t * @cfg {Number|String} relative.right  距离父元素右边的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.left 和 right 只有一个可以生效。\r\n\t * @cfg {Number|String} relative.top  距离父元素顶部的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.top 和 bottom 只有一个可以生效。\r\n\t * @cfg {Number|String} relative.bottom  距离父元素底部的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.top 和 bottom 只有一个可以生效。\r\n\t * @cfg {String} [bounding='all'] 决定此图形元素在定位时，对自身的包围盒计算方式。 1.'all'：（默认） 表示用自身以及子节点整体的经过 transform 后的包围盒进行定位。 这种方式易于使整体都限制在父元素范围中。2.'raw'： 表示仅仅用自身（不包括子节点）的没经过 tranform 的包围盒进行定位。 这种方式易于内容超出父元素范围的定位方式。\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {Array} scale 节点的缩放因子, [x,y] 水平与垂直方向的 eg. [1,1]\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {number} rotation 节点的旋转因子, 单位是角度 eg. 0.5* Math.PI\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {Array} origin 旋转和缩放的原点, [x,y] eg. [75,75]\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {number} z=0  z方向的高度，决定层叠关系。类似css zIndex\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {number} zlevel=0  决定此元素绘制在哪个 canvas 层中。注意，越多 canvas 层会占用越多资源。\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {Boolean} silent=false  是否不响应鼠标以及触摸事件。\r\n\t */\r\n\t/**\r\n\t * @cfg {Boolean} invisible=false  节点是否可见。\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {Object} parent  节点的父元素\r\n\t */\r\n\t/**\r\n\t * @cfg {Object} operationIcons  节点操作为选中的节点，提供默认操作或用户自定义操作。\r\n\t * @cfg {String} operationIcons.name 设置节点名称，可选值有constants.DEL(删除)，constants.LINK（直线），constants.FOLD（折线），constants.CURVE(曲线)，以及自定义名称\r\n\t * @cfg {String} operationIcons.iconPath 设置自定义节点图标路径\r\n\t * @cfg {Function} operationIcons.callback 设置节点被点击（click）的回调函数\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var image1 = new node.Image({\r\n\t *           style: {\r\n\t *               image: \"img/img-cic/icon-send-sms.svg\",\r\n\t *               width:120,\r\n\t *               height:70,\r\n\t *               text:\"操作:线段\",\r\n\t *               textPosition:\"insideBottom\"\r\n\t *           },\r\n\t *           position:[60,60],\r\n\t *           operationIcons: [\r\n\t *               { name: constants.LINK} ,\r\n\t *               { name: constants.FOLD },\r\n\t *               { name: constants.CURVE }\r\n\t *           ]\r\n\t *       });\r\n\t */\r\n\t\r\n\t/**\r\n\t * @property {Object} states\r\n\t * 用于设置节点的状态\r\n\t */\r\n\t\r\n\t\r\n\t/**\r\n\t * @property {Object} model\r\n\t * 节点的模型，用于存储序列化数据 以及用户自定义数据\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method attr\r\n\t * 设置节点属性\r\n\t * @param {String|Object} key 设置的属性。可以是 string 类型的属性名称，或者 Object 类型的属性及其值\r\n\t * @param {*} 属性值\r\n\t * **使用范例**\r\n\t *\r\n\t * @example\r\n\t *\r\n\t * node.attr('position', [100, 200]);\r\n\t * node.attr({\r\n\t *     style: {\r\n\t *         fill: 'red'\r\n\t *     },\r\n\t *     shape: {\r\n\t *         x: 100\r\n\t *     }\r\n\t * });\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method setStyle\r\n\t * 创建节点后，设置节点的样式（style属性）\r\n\t * @param {String} key 键名\r\n\t * @param {*} value 键值\r\n\t * @return {Object} 返回节点对象自身\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method setShape\r\n\t * 创建节点后，设置节点的形状（shape属性）\r\n\t * @param {String} key 键名\r\n\t * @param {*} value 键值\r\n\t * @return {Object} 返回节点对象自身\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method hide\r\n\t * 隐藏节点\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method show\r\n\t * 显示节点\r\n\t */\r\n\t\r\n\t\r\n\t/**\r\n\t * @method on\r\n\t * 绑定事件\r\n\t * @param {String} event 事件名\r\n\t * @param {Function} handler 事件处理函数\r\n\t * @param {Object} [context] 上下文\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method off\r\n\t * 解绑事件\r\n\t * @param {String} event 事件名\r\n\t * @param {Function} handler 事件处理函数\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method one\r\n\t * 单次触发绑定,trigger后销毁\r\n\t * @param {String} event 事件名\r\n\t * @param {Function} handler 事件处理函数\r\n\t * @param {Object} [context] 上下文\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method trigger\r\n\t * 事件分发\r\n\t * @param {String} type 事件类型\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method isSilent\r\n\t * 是否绑定了事件\r\n\t * @param {String} event 事件名\r\n\t * @return {boolean}\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method animate\r\n\t * 动画\r\n\t * @param {String} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性\r\n\t * @param {Boolean} [loop] 动画是否循环\r\n\t * @return {Object} 返回Animator对象\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *      el.animate('style', false)\r\n\t *         .when(1000, {x: 10} )\r\n\t *         .done(function(){ // Animation done })\r\n\t *         .start()\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method stopAnimation\r\n\t * 停止动画\r\n\t * @param {boolean} forwardToLast 是否在停止前移动到最后一帧\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method animateTo\r\n\t * 从一动属性过渡到另一种属性的动画\r\n\t * @param {Object} target 目前属性\r\n\t * @param {number} [time=500] 动画时间 单位ms\r\n\t * @param {string} [easing='linear'] 动画函数 参见[缓动示例](http://echarts.baidu.com/gallery/editor.html?c=line-easing)\r\n\t * @param {number} [delay=0] 延时时间\r\n\t * @param {Function} [callback] 动画结束回调\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *          // Animate position\r\n\t *          el.animateTo({\r\n\t *              position: [10, 10]\r\n\t *          }, function () { // done })\r\n\t *\r\n\t *          // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\r\n\t *          el.animateTo({\r\n\t *              shape: {\r\n\t *                  width: 500\r\n\t *              },\r\n\t *              style: {\r\n\t *                  fill: 'red'\r\n\t *              }\r\n\t *              position: [10, 10]\r\n\t *          }, 100, 100, 'cubicOut', function () { // done })\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event click\r\n\t * 单击事件\r\n\t * @param {Object} event 事件\r\n\t * @param {Object} event.target 目标对象\r\n\t * @param {Object} event.event 实际的浏览器事件对象\r\n\t * <pre>\r\n\t * node.on('click', function(event) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event dblclick\r\n\t * 当双击元素时，会发生 dblclick 事件。\r\n\t * @param {Object} event 事件\r\n\t * @param {Object} event.target 目标对象\r\n\t * @param {Object} event.event 实际的浏览器事件对象\r\n\t * <pre>\r\n\t * node.on('dblclick', function(event) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event mouseover\r\n\t * 当鼠标指针位于元素上方时，会发生 mouseover 事件\r\n\t * @param {Object} event 事件\r\n\t * @param {Object} event.target 目标对象\r\n\t * @param {Object} event.event 实际的浏览器事件对象\r\n\t * <pre>\r\n\t * node.on('mouseover', function(event) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event mouseout\r\n\t * 当鼠标指针从元素上移开时，发生 mouseout 事件。\r\n\t * @param {Object} event 事件\r\n\t * @param {Object} event.target 目标对象\r\n\t * @param {Object} event.event 实际的浏览器事件对象\r\n\t * <pre>\r\n\t * node.on('mouseout', function(event) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t\r\n\t/**\r\n\t * @event mousemove\r\n\t * 当鼠标指针在指定的元素中移动时，就会发生 mousemove 事件\r\n\t * @param {Object} event 事件\r\n\t * @param {Object} event.target 目标对象\r\n\t * @param {Object} event.event 实际的浏览器事件对象\r\n\t * <pre>\r\n\t * node.on('mousemove', function(event) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t\r\n\t/**\r\n\t * @event mousewheel\r\n\t * 当用户在指定的元素时滚动鼠标滑轮时,就会发生 mousewheel事件\r\n\t * @param {Object} event 事件\r\n\t * @param {Object} event.target 目标对象\r\n\t * @param {Object} event.event 实际的浏览器事件对象\r\n\t * <pre>\r\n\t * node.on('mousewheel', function(event) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t\r\n\t/**\r\n\t * @event mousedown\r\n\t * 当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件\r\n\t * @param {Object} event 事件\r\n\t * @param {Object} event.target 目标对象\r\n\t * @param {Object} event.event 实际的浏览器事件对象\r\n\t * <pre>\r\n\t * node.on('mousedown', function(event) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t\r\n\t/**\r\n\t * @event mouseup\r\n\t * 当在元素上放松鼠标按钮时，会发生 mouseup 事件。\r\n\t * @param {Object} event 事件\r\n\t * @param {Object} event.target 目标对象\r\n\t * @param {Object} event.event 实际的浏览器事件对象\r\n\t * <pre>\r\n\t * node.on('mouseup', function(event) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event contextmenu\r\n\t * 当在元素上点击鼠标右键时，会发生 contextmenu 事件。\r\n\t * @param {Object} event 事件\r\n\t * @param {Object} event.target 目标对象\r\n\t * @param {Object} event.event 实际的浏览器事件对象，如果想阻止默认的浏览器右键菜单请使用 event.event.preventDefault(); event.event.stopPropagation();\r\n\t\r\n\t * <pre>\r\n\t * node.on('contextmenu', function(event) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event dragstart\r\n\t * 当开始拖动节点的时候，会发生 dragstart 事件。\r\n\t *\r\n\t * <pre>\r\n\t * node.on('dragstart', function(e) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t\r\n\t/**\r\n\t * @event drag\r\n\t * 当拖动节点的时候，会发生 drag 事件。\r\n\t *\r\n\t * <pre>\r\n\t * node.on('drag', function(e) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event dragend\r\n\t * 当拖动节点结束的时候，会发生 dragend 事件。\r\n\t *\r\n\t * <pre>\r\n\t * node.on('dragend', function(e) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\n\n/***/ }),\n/* 97 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 矩形<br>\r\n\t * @class fishTopoFlow.node.Rect\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var rect = new node.Rect({\r\n\t *           shape:{width:100,height:60},\r\n\t *           position:[20,20]\r\n\t *       });\r\n\t *       fishTopo.add(rect);\r\n\t */\r\n\t\r\n\t    var roundRectHelper = __webpack_require__(29);\r\n\t\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Rect',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Array} shape.points=null 拆线点的坐标 可以从AI中获取。\r\n\t         * @cfg {Number|String|Boolean} [shape.smooth=false] 是否平滑曲线显示。如果为 number：表示贝塞尔 (bezier) 差值平滑，smooth 指定了平滑等级，范围 [0, 1];如果为 'spline'：表示 Catmull-Rom spline 差值平滑\r\n\t         * @cfg {Number} shape.smoothConstraint=null 是否将平滑曲线约束在包围盒中。smooth 为 number（bezier）时生效\r\n\t         */\r\n\t        shape: {\r\n\t            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\r\n\t            // r缩写为1         相当于 [1, 1, 1, 1]\r\n\t            // r缩写为[1]       相当于 [1, 1, 1, 1]\r\n\t            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\r\n\t            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\r\n\t            x: 0,\r\n\t            y: 0,\r\n\t            r: 0,\r\n\t            width: 50,\r\n\t            height: 50\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var x = 0;\r\n\t            var y = 0;\r\n\t            var width = shape.width;\r\n\t            var height = shape.height;\r\n\t            if (!shape.r) {\r\n\t                ctx.rect(x, y, width, height);\r\n\t            }\r\n\t            else {\r\n\t                roundRectHelper.buildPath(ctx, shape);\r\n\t            }\r\n\t            ctx.closePath();\r\n\t        },\r\n\t        updateShape: function (ratio, ifParse) {\r\n\t            var scaleRatio = Number(ratio);\r\n\t            var shape = this.shape;\r\n\t            var newW = Number(shape.width * scaleRatio);\r\n\t            var newH = Number(newW * shape.height / shape.width);\r\n\t            if (ifParse) {\r\n\t                newW = parseInt(newW, 10);\r\n\t                newH = parseInt(newH, 10);\r\n\t            }\r\n\t            // 按比例缩放\r\n\t            this.setShape({\r\n\t                width: newW,\r\n\t                height: newH\r\n\t            });\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 98 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\r\n\t * 圆形<br>\r\n\t * @class fishTopoFlow.node.Circle\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var circle = new node.Circle({\r\n\t *           shape:{r:24},\r\n\t *           position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(circle);\r\n\t */\r\n\t\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Circle',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.r=20 半径。\r\n\t         */\r\n\t        shape: {\r\n\t            r: 20\r\n\t        },\r\n\t\r\n\t        buildPath : function (ctx, shape, inBundle) {\r\n\t            // Better stroking in ShapeBundle\r\n\t            // Always do it may have performence issue ( fill may be 2x more cost)\r\n\t            if (inBundle) {\r\n\t                ctx.moveTo(shape.r, 0);\r\n\t            }\r\n\t            // Better stroking in ShapeBundle\r\n\t            // ctx.moveTo(shape.cx + shape.r, shape.cy);\r\n\t            ctx.arc(0, 0, shape.r, 0, Math.PI * 2, true);\r\n\t        },\r\n\t        updateShape: function (ratio, ifParse) {\r\n\t            var scaleRatio = Number(ratio);\r\n\t            var shape = this.shape;\r\n\t            var newR = Number(shape.r * scaleRatio);\r\n\t            if (ifParse) {\r\n\t                newR = parseInt(newR, 10);\r\n\t            }\r\n\t            // 按比例缩放\r\n\t            this.setShape({\r\n\t                r: newR\r\n\t            });\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 99 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 图片节点<br>\r\n\t * @class fishTopoFlow.node.Image\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var image = new node.Image({\r\n\t *           style: {\r\n\t *               image: \"../../examples/flow/img/img-cic/start.svg\",\r\n\t *               width:120,\r\n\t *               height:70,\r\n\t *               text:\"Event Name\"\r\n\t *           },\r\n\t *           position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(image);\r\n\t */\r\n\t\r\n\t\r\n\t    var Displayable = __webpack_require__(8);\r\n\t    var BoundingRect = __webpack_require__(27);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var flowNode = __webpack_require__(96);\r\n\t    var LRU = __webpack_require__(21);\r\n\t    var globalImageCache = new LRU(50);\r\n\t\r\n\t\r\n\t    function ZImage(opts) {\r\n\t        this.model = flowNode.genModel(\"Image\", opts);\r\n\t        Displayable.call(this, opts);\r\n\t\r\n\t        if (window.jQuery) {   //判断jQuery是否存在\r\n\t            this.resultDeferrd = jQuery.Deferred();\r\n\t            this.result = this.resultDeferrd.promise();\r\n\t        }\r\n\t    }\r\n\t\r\n\t    ZImage.prototype = {\r\n\t\r\n\t        constructor: ZImage,\r\n\t\r\n\t        type: 'Image',\r\n\t\r\n\t        brush: function (ctx, prevEl) {\r\n\t            var style = this.style;\r\n\t            var src = style.image;\r\n\t            var image;\r\n\t\r\n\t            // Must bind each time\r\n\t            style.bind(ctx, this, prevEl);\r\n\t            // style.image is a url string\r\n\t            if (typeof src === 'string') {\r\n\t                image = this._image;\r\n\t                if (image && image.src !== src) { //#171\r\n\t                    image = null;\r\n\t                }\r\n\t            }\r\n\t            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\r\n\t            else {\r\n\t                image = src;\r\n\t                image.isLoaded = true;\r\n\t            }\r\n\t            // FIXME Case create many images with src\r\n\t            if (!image && src) {\r\n\t                // Try get from global image cache\r\n\t                var cachedImgObj = globalImageCache.get(src);\r\n\t                if (!cachedImgObj) {\r\n\t                    // Create a new image\r\n\t                    image = new Image();\r\n\t                    image.isLoaded = false;\r\n\t                    image.onload = function () {\r\n\t                        image.isLoaded = true;\r\n\t                        image.onload = null;\r\n\t                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\r\n\t                            cachedImgObj.pending[i].dirty();\r\n\t                        }\r\n\t                    };\r\n\t                    cachedImgObj = {\r\n\t                        image: image,\r\n\t                        pending: [this]\r\n\t                    };\r\n\t                    image.src = src;\r\n\t                    globalImageCache.put(src, cachedImgObj);\r\n\t                    this._image = image;\r\n\t                    return;\r\n\t                }\r\n\t                else {\r\n\t                    image = cachedImgObj.image;\r\n\t                    this._image = image;\r\n\t                    // Image is not complete finish, add to pending list  如果使用的svg图片, IE11下就算加载成功image.width, image.height也都是为0\r\n\t                    if ((!image.width || !image.height) && (!image.src.endsWith(\"svg\"))) {\r\n\t                        cachedImgObj.pending.push(this);\r\n\t                        return;\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t\r\n\t            if (image) {\r\n\t                // 图片已经加载完成\r\n\t                // if (image.nodeName.toUpperCase() == 'IMG') {\r\n\t                //     if (!image.complete) {\r\n\t                //         return;\r\n\t                //     }\r\n\t                // }\r\n\t                // Else is canvas\r\n\t\r\n\t                var x = style.x || 0;\r\n\t                var y = style.y || 0;\r\n\t                // 如果使用的svg图片, IE11下就算加载成功image.width, image.height也都是为0\r\n\t                //此处如不注释, 会导致IE11下svg图片无法使用\r\n\t                // 图片加载失败\r\n\t                // if (!image.width || !image.height) {\r\n\t                //     return;\r\n\t                // }\r\n\t                if (!image.isLoaded) {\r\n\t                    if (window.jQuery) {\r\n\t                        this.resultDeferrd.reject(image);\r\n\t                    }\r\n\t                    return;\r\n\t                }\r\n\t\r\n\t                var width = style.width;\r\n\t                var height = style.height;\r\n\t                var aspect = image.width / image.height;\r\n\t                if (width == null && height != null) {\r\n\t                    // Keep image/height ratio\r\n\t                    width = height * aspect;\r\n\t                }\r\n\t                else if (height == null && width != null) {\r\n\t                    height = width / aspect;\r\n\t                }\r\n\t                else if (width == null && height == null) {\r\n\t                    width = image.width;\r\n\t                    height = image.height;\r\n\t                }\r\n\t\r\n\t                // 设置transform\r\n\t                this.setTransform(ctx);\r\n\t\r\n\t                if (style.sWidth && style.sHeight) {\r\n\t                    var sx = style.sx || 0;\r\n\t                    var sy = style.sy || 0;\r\n\t                    ctx.drawImage(\r\n\t                        image,\r\n\t                        sx, sy, style.sWidth, style.sHeight,\r\n\t                        x, y, width, height\r\n\t                    );\r\n\t                }\r\n\t                else if (style.sx && style.sy) {\r\n\t                    var sx2 = style.sx;\r\n\t                    var sy2 = style.sy;\r\n\t                    var sWidth = width - sx2;\r\n\t                    var sHeight = height - sy2;\r\n\t                    ctx.drawImage(\r\n\t                        image,\r\n\t                        sx2, sy2, sWidth, sHeight,\r\n\t                        x, y, width, height\r\n\t                    );\r\n\t                }\r\n\t                else {\r\n\t                    ctx.drawImage(image, x, y, width, height);\r\n\t                }\r\n\t                // 如果没设置宽和高的话自动根据图片宽高设置\r\n\t                if (style.width == null) {\r\n\t                    style.width = width;\r\n\t                }\r\n\t                if (style.height == null) {\r\n\t                    style.height = height;\r\n\t                }\r\n\t\r\n\t                this.restoreTransform(ctx);\r\n\t\r\n\t                // Draw rect text\r\n\t                if (style.text != null) {\r\n\t                    this.drawRectText(ctx, this.getBoundingRect());\r\n\t                }\r\n\t                if (window.jQuery) {\r\n\t                    this.resultDeferrd.resolve(image);\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t\r\n\t        getBoundingRect: function () {\r\n\t            var style = this.style;\r\n\t            if (! this._rect) {\r\n\t                this._rect = new BoundingRect(\r\n\t                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\r\n\t                );\r\n\t            }\r\n\t            return this._rect;\r\n\t        },\r\n\t        updateShape: function (ratio, ifParse) {\r\n\t            var scaleRatio = Number(ratio);\r\n\t            var style = this.style;\r\n\t            var newW = Number(style.width * scaleRatio);\r\n\t            var newH = Number(newW * style.height / style.width);\r\n\t            if (ifParse) {\r\n\t                newW = parseInt(newW, 10);\r\n\t                newH = parseInt(newH, 10);\r\n\t            }\r\n\t            // 按比例缩放\r\n\t            this.setStyle({\r\n\t                width: newW,\r\n\t                height: newH\r\n\t            });\r\n\t        }\r\n\t    };\r\n\t\r\n\t    zrUtil.inherits(ZImage, Displayable);\r\n\t\r\n\t    module.exports = ZImage;\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 100 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 文本<br>\r\n\t * @class fishTopoFlow.node.Text\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n\t *       var text = new node.Text({\r\n\t *           style:{text:\"文本也可以作为独立的节点进行拖拽\",fill:\"#ff0000\", textFont:\"16px Microsoft YaHei\"},\r\n\t *           position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(text);\r\n\t */\r\n\t\r\n\t    var Text = __webpack_require__(46);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var flowNode = __webpack_require__(96);\r\n\t    function ZText(opts) {\r\n\t        var defaultOptions = {\r\n\t            style:{textBaseline:\"top\"}   // 默认值  这样选中时的框才正确\r\n\t        };\r\n\t        var options = zrUtil.merge(defaultOptions, opts, true);\r\n\t        this.model = flowNode.genModel(\"Text\", options);\r\n\t        Text.call(this, options);\r\n\t    }\r\n\t\r\n\t    ZText.prototype = {\r\n\t        constructor: ZText,\r\n\t\r\n\t        type: 'Text',\r\n\t\r\n\t        updateShape: function () {\r\n\t            \r\n\t        }\r\n\t    }\r\n\t    zrUtil.inherits(ZText, Text);\r\n\t    module.exports = ZText;\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 101 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 扇形<br>\r\n\t * @class fishTopoFlow.node.Sector\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n\t *       var sector = new node.Sector({\r\n\t *           shape: {r:30, startAngle:0, endAngle:Math.PI * 0.5}, // startAngle\\endAngle是弧度单位\r\n\t *           position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(sector);\r\n\t */\r\n\t\r\n\t    var env = __webpack_require__(50);\r\n\t    var Path = __webpack_require__(7);\r\n\t\r\n\t    var shadowTemp = [\r\n\t        ['shadowBlur', 0],\r\n\t        ['shadowColor', '#000'],\r\n\t        ['shadowOffsetX', 0],\r\n\t        ['shadowOffsetY', 0]\r\n\t    ];\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Sector',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.r=0 外半径。\r\n\t         * @cfg {Number} shape.r0=0 内半径。\r\n\t         * @cfg {Number} shape.startAngle=0 开始弧度。\r\n\t         * @cfg {Number} shape.endAngle=Math.PI * 2  结束弧度。\r\n\t         * @cfg {Boolean} shape.clockwise=true 是否顺时针。\r\n\t         */\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t\r\n\t            cy: 0,\r\n\t\r\n\t            r0: 0,\r\n\t\r\n\t            r: 0,\r\n\t\r\n\t            startAngle: 0,\r\n\t\r\n\t            endAngle: Math.PI * 2,\r\n\t\r\n\t            clockwise: true\r\n\t        },\r\n\t\r\n\t        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'\r\n\t            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),\r\n\t            // where exception \"unexpected call to method or property access\"\r\n\t            // might be thrown when calling ctx.fill after a path whose area size\r\n\t            // is zero is drawn and ctx.clip() is called and shadowBlur is set.\r\n\t            // (e.g.,\r\n\t            //  ctx.moveTo(10, 10);\r\n\t            //  ctx.lineTo(20, 10);\r\n\t            //  ctx.closePath();\r\n\t            //  ctx.clip();\r\n\t            //  ctx.shadowBlur = 10;\r\n\t            //  ...\r\n\t            //  ctx.fill();\r\n\t            // )\r\n\t            ? function () {\r\n\t                var clipPaths = this.__clipPaths;\r\n\t                var style = this.style;\r\n\t                var modified;\r\n\t\r\n\t                if (clipPaths) {\r\n\t                    for (var i = 0; i < clipPaths.length; i++) {\r\n\t                        var shape = clipPaths[i] && clipPaths[i].shape;\r\n\t                        if (shape && shape.startAngle === shape.endAngle) {\r\n\t                            for (var j = 0; j < shadowTemp.length; j++) {\r\n\t                                shadowTemp[j][2] = style[shadowTemp[j][0]];\r\n\t                                style[shadowTemp[j][0]] = shadowTemp[j][1];\r\n\t                            }\r\n\t                            modified = true;\r\n\t                            break;\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                Path.prototype.brush.apply(this, arguments);\r\n\t\r\n\t                if (modified) {\r\n\t                    for (var k = 0; k < shadowTemp.length; k++) {\r\n\t                        style[shadowTemp[k][0]] = shadowTemp[k][2];\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t            : Path.prototype.brush,\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t\r\n\t            var x = shape.cx;\r\n\t            var y = shape.cy;\r\n\t            var r0 = Math.max(shape.r0 || 0, 0);\r\n\t            var r = Math.max(shape.r, 0);\r\n\t            var startAngle = shape.startAngle;\r\n\t            var endAngle = shape.endAngle;\r\n\t            var clockwise = shape.clockwise;\r\n\t\r\n\t            var unitX = Math.cos(startAngle);\r\n\t            var unitY = Math.sin(startAngle);\r\n\t\r\n\t            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\r\n\t\r\n\t            ctx.lineTo(unitX * r + x, unitY * r + y);\r\n\t\r\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\r\n\t\r\n\t            ctx.lineTo(\r\n\t                Math.cos(endAngle) * r0 + x,\r\n\t                Math.sin(endAngle) * r0 + y\r\n\t            );\r\n\t\r\n\t            if (r0 !== 0) {\r\n\t                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\r\n\t            }\r\n\t\r\n\t            ctx.closePath();\r\n\t        },\r\n\t        updateShape: function (ratio, ifParse) {\r\n\t            var scaleRatio = Number(ratio);\r\n\t            var shape = this.shape;\r\n\t            var newR = Number(shape.r * scaleRatio);\r\n\t            var newR0 = Number(shape.r0 * scaleRatio);\r\n\t            if (ifParse) {\r\n\t                newR = parseInt(newR, 10);\r\n\t                newR0 = parseInt(newR0, 10);\r\n\t            }\r\n\t            // 按比例缩放\r\n\t            this.setShape({\r\n\t                r: newR,\r\n\t                r0: newR0\r\n\t            });\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 102 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 环形<br>\r\n\t * @class fishTopoFlow.node.Ring\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n\t *       var ring = new node.Ring({\r\n\t *           shape: {r:30,  r0:10},  // r0 内半径\r\n\t *           position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(ring);\r\n\t */\r\n\t\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t         type: 'Ring',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.r=0 外半径。\r\n\t         * @cfg {Number} shape.r0=0 内半径。\r\n\t         */\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t            cy: 0,\r\n\t            r: 0,\r\n\t            r0: 0\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var x = shape.cx;\r\n\t            var y = shape.cy;\r\n\t            var PI2 = Math.PI * 2;\r\n\t            ctx.moveTo(x + shape.r, y);\r\n\t            ctx.arc(x, y, shape.r, 0, PI2, false);\r\n\t            ctx.moveTo(x + shape.r0, y);\r\n\t            ctx.arc(x, y, shape.r0, 0, PI2, true);\r\n\t        },\r\n\t        updateShape: function (ratio, ifParse) {\r\n\t            var scaleRatio = Number(ratio);\r\n\t            var shape = this.shape;\r\n\t            var newR = Number(shape.r * scaleRatio);\r\n\t            var newR0 = Number(shape.r0 * scaleRatio);\r\n\t            if (ifParse) {\r\n\t                newR = parseInt(newR, 10);\r\n\t                newR0 = parseInt(newR0, 10);\r\n\t            }\r\n\t            // 按比例缩放\r\n\t            this.setShape({\r\n\t                r: newR,\r\n\t                r0: newR0\r\n\t            });\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 103 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\r\n\t * 椭圆<br>\r\n\t * @class fishTopoFlow.node.Droplet\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var ellipse = new node.Ellipse({\r\n\t *           shape: {rx:70,  ry:30},  // rx:椭圆横半轴长 ry:椭圆纵半轴长\r\n\t *           position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(ellipse);\r\n\t */\r\n\t\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Ellipse',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.rx=0 椭圆横半轴长\r\n\t         * @cfg {Number} shape.ry=0 椭圆纵半轴长\r\n\t         */\r\n\t        shape: {\r\n\t            rx: 0, ry: 0\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var k = 0.5522848;\r\n\t            var x = 0;\r\n\t            var y = 0;\r\n\t            var a = shape.rx;\r\n\t            var b = shape.ry;\r\n\t            var ox = a * k; // 水平控制点偏移量\r\n\t            var oy = b * k; // 垂直控制点偏移量\r\n\t            // 从椭圆的左端点开始顺时针绘制四条三次贝塞尔曲线\r\n\t            ctx.moveTo(x - a, y);\r\n\t            ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);\r\n\t            ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);\r\n\t            ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);\r\n\t            ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);\r\n\t            ctx.closePath();\r\n\t        },\r\n\t        updateShape: function (ratio, ifParse) {\r\n\t            var scaleRatio = Number(ratio);\r\n\t            var shape = this.shape;\r\n\t            var newRx = Number(shape.rx * scaleRatio);\r\n\t            var newRy = Number(newRx * shape.ry / shape.rx);\r\n\t            if (ifParse) {\r\n\t                newRx = parseInt(newRx, 10);\r\n\t                newRy = parseInt(newRy, 10);\r\n\t            }\r\n\t            // 按比例缩放\r\n\t            this.setShape({\r\n\t                rx: newRx,\r\n\t                ry: newRy\r\n\t            });\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 104 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 心形<br>\r\n\t * @class fishTopoFlow.node.Heart\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var heart  = new node.Heart({\r\n\t *           shape: {width:40,  height:50},\r\n\t *           position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(heart );\r\n\t */\r\n\t\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Heart',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.cx=0 中心在父节点坐标系（以父节点左上角为原点）中的横坐标值。\r\n\t         * @cfg {Number} shape.cy=0 中心在父节点坐标系（以父节点左上角为原点）中的纵坐标值。\r\n\t         * @cfg {Number} shape.width=0 宽度。\r\n\t         * @cfg {Number} shape.height=0 高度。\r\n\t         */\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t            cy: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var x = shape.cx;\r\n\t            var y = shape.cy;\r\n\t            var a = shape.width;\r\n\t            var b = shape.height;\r\n\t            ctx.moveTo(x, y);\r\n\t            ctx.bezierCurveTo(\r\n\t                x + a / 2, y - b * 2 / 3,\r\n\t                x + a * 2, y + b / 3,\r\n\t                x, y + b\r\n\t            );\r\n\t            ctx.bezierCurveTo(\r\n\t                x - a *  2, y + b / 3,\r\n\t                x - a / 2, y - b * 2 / 3,\r\n\t                x, y\r\n\t            );\r\n\t        },\r\n\t        updateShape: function (ratio, ifParse) {\r\n\t            var scaleRatio = Number(ratio);\r\n\t            var shape = this.shape;\r\n\t            var newWidth = Number(shape.width * scaleRatio);\r\n\t            var newHeight = Number(newWidth * shape.height / shape.width);\r\n\t            if (ifParse) {\r\n\t                newWidth = parseInt(newWidth, 10);\r\n\t                newHeight = parseInt(newHeight, 10);\r\n\t            }\r\n\t            // 按比例缩放\r\n\t            this.setShape({\r\n\t                width: newWidth,\r\n\t                height: newHeight\r\n\t            });\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 105 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\r\n\t * 水滴形<br>\r\n\t * @class fishTopoFlow.node.Droplet\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var droplet = new node.Droplet({\r\n\t *           shape: {width:10,  height:30},\r\n\t *           position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(droplet);\r\n\t */\r\n\t\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Droplet',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.width=0 宽度。\r\n\t         * @cfg {Number} shape.height=0 高度。\r\n\t         */\r\n\t        shape: {\r\n\t            cx: 0, cy: 0,\r\n\t            width: 0, height: 0\r\n\t        },\r\n\t\r\n\t        buildPath : function (ctx, shape) {\r\n\t            var x = shape.cx;\r\n\t            var y = shape.cy;\r\n\t            var a = shape.width;\r\n\t            var b = shape.height;\r\n\t\r\n\t            ctx.moveTo(x, y + a);\r\n\t            ctx.bezierCurveTo(\r\n\t                x + a,\r\n\t                y + a,\r\n\t                x + a * 3 / 2,\r\n\t                y - a / 3,\r\n\t                x,\r\n\t                y - b\r\n\t            );\r\n\t            ctx.bezierCurveTo(\r\n\t                x - a * 3 / 2,\r\n\t                y - a / 3,\r\n\t                x - a,\r\n\t                y + a,\r\n\t                x,\r\n\t                y + a\r\n\t            );\r\n\t            ctx.closePath();\r\n\t        },\r\n\t        updateShape: function (ratio, ifParse) {\r\n\t            var scaleRatio = Number(ratio);\r\n\t            var shape = this.shape;\r\n\t            var newWidth = Number(shape.width * scaleRatio);\r\n\t            var newHeight = Number(newWidth * shape.height / shape.width);\r\n\t            if (ifParse) {\r\n\t                newWidth = parseInt(newWidth, 10);\r\n\t                newHeight = parseInt(newHeight, 10);\r\n\t            }\r\n\t            // 按比例缩放\r\n\t            this.setShape({\r\n\t                width: newWidth,\r\n\t                height: newHeight\r\n\t            });\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 106 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 玫瑰形<br>\r\n\t * @class fishTopoFlow.node.Rose\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n\t *       var rose = new node.Rose({\r\n\t *           shape: {r:[35], k:7, n:4},\r\n\t *           position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(rose);\r\n\t */\r\n\t\r\n\t    var sin = Math.sin;\r\n\t    var cos = Math.cos;\r\n\t    var radian = Math.PI / 180;\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Rose',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Array} shape.r=[]\r\n\t         * @cfg {Number} shape.k=0\r\n\t         * @cfg {Number} shape.n=1\r\n\t         */\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t            cy: 0,\r\n\t            r: [],\r\n\t            k: 0,\r\n\t            n: 1\r\n\t        },\r\n\t\r\n\t        style: {\r\n\t            stroke: '#000',\r\n\t            fill: null,\r\n\t            lineWidth: 2\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var x;\r\n\t            var y;\r\n\t            var R = shape.r;\r\n\t            var r;\r\n\t            var k = shape.k;\r\n\t            var n = shape.n;\r\n\t\r\n\t            var x0 = shape.cx;\r\n\t            var y0 = shape.cy;\r\n\t\r\n\t            ctx.moveTo(x0, y0);\r\n\t\r\n\t            for (var i = 0, len = R.length; i < len ; i++) {\r\n\t                r = R[i];\r\n\t\r\n\t                for (var j = 0; j <= 360 * n; j++) {\r\n\t                    x = r\r\n\t                         * sin(k / n * j % 360 * radian)\r\n\t                         * cos(j * radian)\r\n\t                         + x0;\r\n\t                    y = r\r\n\t                         * sin(k / n * j % 360 * radian)\r\n\t                         * sin(j * radian)\r\n\t                         + y0;\r\n\t                    ctx.lineTo(x, y);\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t        updateShape: function (ratio, ifParse) {\r\n\t            var scaleRatio = Number(ratio);\r\n\t            var shape = this.shape;\r\n\t            var newR = [];\r\n\t            shape.r.forEach(function (v) {\r\n\t                newR.push(Number(v * scaleRatio))\r\n\t            });\r\n\t            if (ifParse) {\r\n\t                newR.forEach(function (v) {\r\n\t                    v = parseInt(v, 10);\r\n\t                });\r\n\t            }\r\n\t            // 按比例缩放\r\n\t            this.setShape({\r\n\t                r: newR\r\n\t            });\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 107 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 正多边形<br>\r\n\t * @class fishTopoFlow.node.Isogon\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var isogon = new node.Isogon({\r\n\t *           shape: {r:40,  n:9},  // r半径 n几个边\r\n\t *           position:[60,50]\r\n\t *       });\r\n\t *       fishTopo.add(isogon);\r\n\t */\r\n\t\r\n\t    var PI = Math.PI;\r\n\t    var sin = Math.sin;\r\n\t    var cos = Math.cos;\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Isogon',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.r=0 半径\r\n\t         * @cfg {Number} shape.n=0 几个边\r\n\t         */\r\n\t       shape: {\r\n\t            x: 0, y: 0,\r\n\t            r: 0, n: 0\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var n = shape.n;\r\n\t            if (!n || n < 2) {\r\n\t                return;\r\n\t            }\r\n\t\r\n\t            var x = shape.x;\r\n\t            var y = shape.y;\r\n\t            var r = shape.r;\r\n\t\r\n\t            var dStep = 2 * PI / n;\r\n\t            var deg = -PI / 2;\r\n\t\r\n\t            ctx.moveTo(x + r * cos(deg), y + r * sin(deg));\r\n\t            for (var i = 0, end = n - 1; i < end; i++) {\r\n\t                deg += dStep;\r\n\t                ctx.lineTo(x + r * cos(deg), y + r * sin(deg));\r\n\t            }\r\n\t\r\n\t            ctx.closePath();\r\n\t\r\n\t            return;\r\n\t        },\r\n\t        updateShape: function (ratio, ifParse) {\r\n\t            var scaleRatio = Number(ratio);\r\n\t            var shape = this.shape;\r\n\t            var newR = Number(shape.r * scaleRatio);\r\n\t            if (ifParse) {\r\n\t                newR = parseInt(newR, 10);\r\n\t            }\r\n\t            // 按比例缩放\r\n\t            this.setShape({\r\n\t                r: newR\r\n\t            });\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 108 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 多边形<br>\r\n\t * @class fishTopoFlow.node.Polygon\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var polygon = new node.Polygon({\r\n\t *           shape: {points:[[85.275,0], [100,25.41], [85.275,50.821], [14.138,50.821], [0,25.41], [14.138,0]]},  // r半径 n几个边\r\n\t *           position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(polygon);\r\n\t */\r\n\t\r\n\t    var polyHelper = __webpack_require__(53);\r\n\t\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t       type: 'Polygon',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Array} shape.points=null 多边形点的坐标 可以从AI中获取。\r\n\t         * @cfg {Number|String|Boolean} [shape.smooth=false] 是否平滑曲线显示。如果为 number：表示贝塞尔 (bezier) 差值平滑，smooth 指定了平滑等级，范围 [0, 1];如果为 'spline'：表示 Catmull-Rom spline 差值平滑\r\n\t         * @cfg {Number} shape.smoothConstraint=null 是否将平滑曲线约束在包围盒中。smooth 为 number（bezier）时生效\r\n\t         */\r\n\t        shape: {\r\n\t            points: null,\r\n\t\r\n\t            smooth: false,\r\n\t\r\n\t            smoothConstraint: null\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            polyHelper.buildPath(ctx, shape, true);\r\n\t        },\r\n\t        updateShape: function (ratio, ifParse) {\r\n\t            var scaleRatio = Number(ratio);\r\n\t            var shape = this.shape;\r\n\t            var pointsNew = [];\r\n\t            shape.points.forEach(function(item) {\r\n\t                pointsNew.push([Number(item[0] * scaleRatio), Number(item[1] * scaleRatio)]);\r\n\t            });\r\n\t            if (ifParse) {\r\n\t                pointsNew.forEach(function(item) {\r\n\t                    item[0] = parseInt(item[0], 10);\r\n\t                    item[1] = parseInt(item[1], 10);\r\n\t                });\r\n\t            }\r\n\t            // 按比例缩放\r\n\t            this.setShape({\r\n\t                points: pointsNew\r\n\t            });\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 109 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 直线<br>\r\n\t * @class fishTopoFlow.node.Line\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var line = new node.Line({\r\n\t *           shape: {x1:60,  y1:60, x2:100, y2:100},  // x 起点 y终点\r\n\t *           style: {lineWidth:3}\r\n\t *       });\r\n\t *       fishTopo.add(line);\r\n\t */\r\n\t\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Line',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.x1=0 起始点的横坐标值。\r\n\t         * @cfg {Number} shape.y1=0 起始点的纵坐标值。\r\n\t         * @cfg {Number} shape.x2=0 终止点的横坐标值。\r\n\t         * @cfg {Number} shape.y2=0 终止点的纵坐标值。\r\n\t         */\r\n\t        shape: {\r\n\t            // Start point\r\n\t            x1: 0,\r\n\t            y1: 0,\r\n\t            // End point\r\n\t            x2: 0,\r\n\t            y2: 0,\r\n\t\r\n\t            percent: 1\r\n\t        },\r\n\t\r\n\t        style: {\r\n\t            stroke: '#000',\r\n\t            fill: null\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var x1 = shape.x1;\r\n\t            var y1 = shape.y1;\r\n\t            var x2 = shape.x2;\r\n\t            var y2 = shape.y2;\r\n\t            var percent = shape.percent;\r\n\t\r\n\t            if (percent === 0) {\r\n\t                return;\r\n\t            }\r\n\t\r\n\t            ctx.moveTo(x1, y1);\r\n\t\r\n\t            if (percent < 1) {\r\n\t                x2 = x1 * (1 - percent) + x2 * percent;\r\n\t                y2 = y1 * (1 - percent) + y2 * percent;\r\n\t            }\r\n\t            ctx.lineTo(x2, y2);\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * Get point at percent\r\n\t         * @param  {number} percent\r\n\t         * @return {Array.<number>}\r\n\t         */\r\n\t        pointAt: function (p) {\r\n\t            var shape = this.shape;\r\n\t            return [\r\n\t                shape.x1 * (1 - p) + shape.x2 * p,\r\n\t                shape.y1 * (1 - p) + shape.y2 * p\r\n\t            ];\r\n\t        },\r\n\t        updateShape: function (ratio, ifParse) {\r\n\t            var scaleRatio = Number(ratio);\r\n\t            var shape = this.shape;\r\n\t            var newX1 = Number(shape.x1 * scaleRatio);\r\n\t            var newX2 = Number(shape.x2 * scaleRatio);\r\n\t            var newY1 = Number(shape.y1 * scaleRatio);\r\n\t            var newY2 = Number(shape.y2 * scaleRatio);\r\n\t            if (ifParse) {\r\n\t                newX1 = parseInt(newX1, 10);\r\n\t            }\r\n\t            // 按比例缩放\r\n\t            this.setShape({\r\n\t                x1: newX1,\r\n\t                y1: newY1,\r\n\t                x2: newX2,\r\n\t                y2: newY2\r\n\t            });\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 110 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\r\n\t * 拆线<br>\r\n\t * @class fishTopoFlow.node.Polyline\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var polyline = new node.Polyline({\r\n\t *           shape: {points:[[57,138],[95,184],[115,166],[151,184] ]}\r\n\t *       });\r\n\t *       fishTopo.add(polyline);\r\n\t */\r\n\t\r\n\t    var polyHelper = __webpack_require__(53);\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Polyline',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Array} shape.points=null 拆线点的坐标 可以从AI中获取。\r\n\t         * @cfg {Number|String|Boolean} [shape.smooth=false] 是否平滑曲线显示。如果为 number：表示贝塞尔 (bezier) 差值平滑，smooth 指定了平滑等级，范围 [0, 1];如果为 'spline'：表示 Catmull-Rom spline 差值平滑\r\n\t         * @cfg {Number} shape.smoothConstraint=null 是否将平滑曲线约束在包围盒中。smooth 为 number（bezier）时生效\r\n\t         */\r\n\t        shape: {\r\n\t            points: null,\r\n\t\r\n\t            smooth: false,\r\n\t\r\n\t            smoothConstraint: null\r\n\t        },\r\n\t\r\n\t        style: {\r\n\t            stroke: '#000',\r\n\t\r\n\t            fill: null\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            polyHelper.buildPath(ctx, shape, false);\r\n\t        },\r\n\t        updateShape: function (ratio, ifParse) {\r\n\t            var scaleRatio = Number(ratio);\r\n\t            var shape = this.shape;\r\n\t            var pointsNew = [];\r\n\t            shape.points.forEach(function(item) {\r\n\t                pointsNew.push([Number(item[0] * scaleRatio), Number(item[1] * scaleRatio)]);\r\n\t            });\r\n\t            if (ifParse) {\r\n\t                pointsNew.forEach(function(item) {\r\n\t                    item[0] = parseInt(item[0], 10);\r\n\t                    item[1] = parseInt(item[1], 10);\r\n\t                });\r\n\t            }\r\n\t            // 按比例缩放\r\n\t            this.setShape({\r\n\t                points: pointsNew\r\n\t            });\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 111 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\r\n\t * 贝塞尔曲线<br>\r\n\t * @class fishTopoFlow.node.BezierCurve\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var bezierCurve = new node.BezierCurve({\r\n\t *           shape: {x1:0, y1:100, cpx1:0, cpy1:0, cpx2:0, cpy2:0, x2:100, y2:0},\r\n\t *           position: [60, 60]\r\n\t *       });\r\n\t *       fishTopo.add(bezierCurve);\r\n\t */\r\n\t\r\n\t\r\n\t    var curveTool = __webpack_require__(31);\r\n\t    var vec2 = __webpack_require__(15);\r\n\t    var quadraticSubdivide = curveTool.quadraticSubdivide;\r\n\t    var cubicSubdivide = curveTool.cubicSubdivide;\r\n\t    var quadraticAt = curveTool.quadraticAt;\r\n\t    var cubicAt = curveTool.cubicAt;\r\n\t    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\r\n\t    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\r\n\t\r\n\t    var out = [];\r\n\t\r\n\t    function someVectorAt(shape, t, isTangent) {\r\n\t        var cpx2 = shape.cpx2;\r\n\t        var cpy2 = shape.cpy2;\r\n\t        if (cpx2 === null || cpy2 === null) {\r\n\t            return [\r\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\r\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\r\n\t            ];\r\n\t        }\r\n\t        else {\r\n\t            return [\r\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\r\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\r\n\t            ];\r\n\t        }\r\n\t    }\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'BezierCurve',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.x1=0 起始点的横坐标值。\r\n\t         * @cfg {Number} shape.y1=0 起始点的纵坐标值。\r\n\t         * @cfg {Number} shape.x2=0 终止点的横坐标值。\r\n\t         * @cfg {Number} shape.y2=0 终止点的纵坐标值。\r\n\t         * @cfg {Number} shape.cpx1=0 控制点的横坐标值。\r\n\t         * @cfg {Boolean} shape.cpx2=0 控制点的纵坐标值。\r\n\t         */\r\n\t        shape: {\r\n\t            x1: 0,\r\n\t            y1: 0,\r\n\t            x2: 0,\r\n\t            y2: 0,\r\n\t            cpx1: 0,\r\n\t            cpy1: 0,\r\n\t\r\n\t            // Curve show percent, for animating\r\n\t            percent: 1\r\n\t        },\r\n\t\r\n\t        style: {\r\n\t            stroke: '#000',\r\n\t            fill: null\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var x1 = shape.x1;\r\n\t            var y1 = shape.y1;\r\n\t            var x2 = shape.x2;\r\n\t            var y2 = shape.y2;\r\n\t            var cpx1 = shape.cpx1;\r\n\t            var cpy1 = shape.cpy1;\r\n\t            var cpx2 = shape.cpx2;\r\n\t            var cpy2 = shape.cpy2;\r\n\t            var percent = shape.percent;\r\n\t            if (percent === 0) {\r\n\t                return;\r\n\t            }\r\n\t\r\n\t            ctx.moveTo(x1, y1);\r\n\t\r\n\t            if (cpx2 == null || cpy2 == null) {\r\n\t                if (percent < 1) {\r\n\t                    quadraticSubdivide(\r\n\t                        x1, cpx1, x2, percent, out\r\n\t                    );\r\n\t                    cpx1 = out[1];\r\n\t                    x2 = out[2];\r\n\t                    quadraticSubdivide(\r\n\t                        y1, cpy1, y2, percent, out\r\n\t                    );\r\n\t                    cpy1 = out[1];\r\n\t                    y2 = out[2];\r\n\t                }\r\n\t\r\n\t                ctx.quadraticCurveTo(\r\n\t                    cpx1, cpy1,\r\n\t                    x2, y2\r\n\t                );\r\n\t            }\r\n\t            else {\r\n\t                if (percent < 1) {\r\n\t                    cubicSubdivide(\r\n\t                        x1, cpx1, cpx2, x2, percent, out\r\n\t                    );\r\n\t                    cpx1 = out[1];\r\n\t                    cpx2 = out[2];\r\n\t                    x2 = out[3];\r\n\t                    cubicSubdivide(\r\n\t                        y1, cpy1, cpy2, y2, percent, out\r\n\t                    );\r\n\t                    cpy1 = out[1];\r\n\t                    cpy2 = out[2];\r\n\t                    y2 = out[3];\r\n\t                }\r\n\t                ctx.bezierCurveTo(\r\n\t                    cpx1, cpy1,\r\n\t                    cpx2, cpy2,\r\n\t                    x2, y2\r\n\t                );\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * Get point at percent\r\n\t         * @param  {number} t\r\n\t         * @return {Array.<number>}\r\n\t         */\r\n\t        pointAt: function (t) {\r\n\t            return someVectorAt(this.shape, t, false);\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * Get tangent at percent\r\n\t         * @param  {number} t\r\n\t         * @return {Array.<number>}\r\n\t         */\r\n\t        tangentAt: function (t) {\r\n\t            var p = someVectorAt(this.shape, t, true);\r\n\t            return vec2.normalize(p, p);\r\n\t        },\r\n\t        updateShape: function (ratio, ifParse) {\r\n\t            var scaleRatio = Number(ratio);\r\n\t            var shape = this.shape;\r\n\t            var pointsNew = {};\r\n\t            Object.keys(shape).forEach(function (key) {\r\n\t                var value = shape[key];\r\n\t                if (key !== 'percent') {\r\n\t                    pointsNew[key] = Number(value * scaleRatio);\r\n\t                } else {\r\n\t                    pointsNew[key] = value;\r\n\t                }\r\n\t            });\r\n\t            if (ifParse) {\r\n\t                Object.keys(pointsNew).forEach(function(key) {\r\n\t                    pointsNew[key] = parseInt(pointsNew[key], 10);\r\n\t                });\r\n\t            }\r\n\t            // 按比例缩放\r\n\t            this.setShape(pointsNew);\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 112 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\r\n\t * 圆弧<br>\r\n\t * @class fishTopoFlow.node.Arc\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var arc = new node.Arc({\r\n\t *           shape: {r:50, startAngle:0, endAngle:1.2*Math.PI},\r\n\t *           position: [60, 60]\r\n\t *       });\r\n\t *       fishTopo.add(arc);\r\n\t */\r\n\t\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Arc',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.r=0 半径。\r\n\t         * @cfg {Number} shape.startAngle=0 开始弧度。\r\n\t         * @cfg {Number} shape.endAngle=Math.PI * 2  结束弧度。\r\n\t         * @cfg {Boolean} shape.clockwise=true 是否顺时针。\r\n\t         */\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t            cy: 0,\r\n\t            r: 0,\r\n\t            startAngle: 0,\r\n\t            endAngle: Math.PI * 2,\r\n\t            clockwise: true\r\n\t        },\r\n\t\r\n\t        style: {\r\n\t\r\n\t            stroke: '#000',\r\n\t\r\n\t            fill: null\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t\r\n\t            var x = shape.cx;\r\n\t            var y = shape.cy;\r\n\t            var r = Math.max(shape.r, 0);\r\n\t            var startAngle = shape.startAngle;\r\n\t            var endAngle = shape.endAngle;\r\n\t            var clockwise = shape.clockwise;\r\n\t\r\n\t            var unitX = Math.cos(startAngle);\r\n\t            var unitY = Math.sin(startAngle);\r\n\t\r\n\t            ctx.moveTo(unitX * r + x, unitY * r + y);\r\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\r\n\t        },\r\n\t        updateShape: function (ratio, ifParse) {\r\n\t            var scaleRatio = Number(ratio);\r\n\t            var shape = this.shape;\r\n\t            var newR = Number(shape.r * scaleRatio);\r\n\t            if (ifParse) {\r\n\t                newR = parseInt(newR, 10);\r\n\t            }\r\n\t            // 按比例缩放\r\n\t            this.setShape({\r\n\t                r: newR\r\n\t            });\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 113 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\r\n\t * 星形<br>\r\n\t * @class fishTopoFlow.node.Star\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n\t *       var star = new node.Star({\r\n\t *           shape: {n:7, r:30},  //r半径 n几个角\r\n\t *           position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(star);\r\n\t */\r\n\t\r\n\t    var PI = Math.PI;\r\n\t\r\n\t    var cos = Math.cos;\r\n\t    var sin = Math.sin;\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Star',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.n=3 几个角。\r\n\t         * @cfg {Number} shape.r=0 外半径。\r\n\t         * @cfg {Number} shape.r0=0 内半径。\r\n\t         */\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t            cy: 0,\r\n\t            n: 3,\r\n\t            r0: null,\r\n\t            r: 0\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t\r\n\t            var n = shape.n;\r\n\t            if (!n || n < 2) {\r\n\t                return;\r\n\t            }\r\n\t\r\n\t            var x = shape.cx;\r\n\t            var y = shape.cy;\r\n\t            var r = shape.r;\r\n\t            var r0 = shape.r0;\r\n\t\r\n\t            // 如果未指定内部顶点外接圆半径，则自动计算\r\n\t            if (r0 == null) {\r\n\t                r0 = n > 4\r\n\t                    // 相隔的外部顶点的连线的交点，\r\n\t                    // 被取为内部交点，以此计算r0\r\n\t                    ? r * cos(2 * PI / n) / cos(PI / n)\r\n\t                    // 二三四角星的特殊处理\r\n\t                    : r / 3;\r\n\t            }\r\n\t\r\n\t            var dStep = PI / n;\r\n\t            var deg = -PI / 2;\r\n\t            var xStart = x + r * cos(deg);\r\n\t            var yStart = y + r * sin(deg);\r\n\t            deg += dStep;\r\n\t\r\n\t            // 记录边界点，用于判断inside\r\n\t            ctx.moveTo(xStart, yStart);\r\n\t            for (var i = 0, end = n * 2 - 1, ri; i < end; i++) {\r\n\t                ri = i % 2 === 0 ? r0 : r;\r\n\t                ctx.lineTo(x + ri * cos(deg), y + ri * sin(deg));\r\n\t                deg += dStep;\r\n\t            }\r\n\t\r\n\t            ctx.closePath();\r\n\t        },\r\n\t        updateShape: function (ratio, ifParse) {\r\n\t            var scaleRatio = Number(ratio);\r\n\t            var shape = this.shape;\r\n\t            var newR = Number(shape.r * scaleRatio);\r\n\t            if (ifParse) {\r\n\t                newR = parseInt(newR, 10);\r\n\t            }\r\n\t            // 按比例缩放\r\n\t            this.setShape({\r\n\t                r: newR\r\n\t            });\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 114 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\r\n\t * 旋轮曲线<br>\r\n\t * @class fishTopoFlow.node.Trochoid\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n\t *       var trochoid = new node.Trochoid({\r\n\t *           shape: {r:50, r0:35, d:30, location:null},  //r半径 n几个角\r\n\t *           position:[60,60],\r\n\t *           tooltip: \"旋轮曲线\"\r\n\t *       });\r\n\t *       fishTopo.add(trochoid);\r\n\t */\r\n\t\r\n\t\r\n\t    var cos = Math.cos;\r\n\t    var sin = Math.sin;\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Trochoid',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.r=0 外半径。\r\n\t         * @cfg {Number} shape.r0=0 内半径。\r\n\t         * @cfg {Number} shape.d=0\r\n\t         * @cfg {Number} shape.location='out'\r\n\t         */\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t            cy: 0,\r\n\t            r: 0,\r\n\t            r0: 0,\r\n\t            d: 0,\r\n\t            location: 'out'\r\n\t        },\r\n\t\r\n\t        style: {\r\n\t            stroke: '#000',\r\n\t\r\n\t            fill: null\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var x1;\r\n\t            var y1;\r\n\t            var x2;\r\n\t            var y2;\r\n\t            var R = shape.r;\r\n\t            var r = shape.r0;\r\n\t            var d = shape.d;\r\n\t            var offsetX = shape.cx;\r\n\t            var offsetY = shape.cy;\r\n\t            var delta = shape.location == 'out' ? 1 : -1;\r\n\t\r\n\t            if (shape.location && R <= r) {\r\n\t                return;\r\n\t            }\r\n\t\r\n\t            var num = 0;\r\n\t            var i = 1;\r\n\t            var theta;\r\n\t\r\n\t            x1 = (R + delta * r) * cos(0)\r\n\t                - delta * d * cos(0) + offsetX;\r\n\t            y1 = (R + delta * r) * sin(0)\r\n\t                - d * sin(0) + offsetY;\r\n\t\r\n\t            ctx.moveTo(x1, y1);\r\n\t\r\n\t            // 计算结束时的i\r\n\t            do {\r\n\t                num++;\r\n\t            }\r\n\t            while ((r * num) % (R + delta * r) !== 0);\r\n\t\r\n\t            do {\r\n\t                theta = Math.PI / 180 * i;\r\n\t                x2 = (R + delta * r) * cos(theta)\r\n\t                     - delta * d * cos((R / r +  delta) * theta)\r\n\t                     + offsetX;\r\n\t                y2 = (R + delta * r) * sin(theta)\r\n\t                     - d * sin((R / r + delta) * theta)\r\n\t                     + offsetY;\r\n\t                ctx.lineTo(x2, y2);\r\n\t                i++;\r\n\t            }\r\n\t            while (i <= (r * num) / (R + delta * r) * 360);\r\n\t\r\n\t        },\r\n\t        updateShape: function (ratio, ifParse) {\r\n\t            var scaleRatio = Number(ratio);\r\n\t            var shape = this.shape;\r\n\t            var newR = Number(shape.r * scaleRatio);\r\n\t            var newR0 = Number(shape.r0 * scaleRatio);\r\n\t            var newD = Number(shape.d * scaleRatio);\r\n\t            newR = parseInt(newR, 10);\r\n\t            newR0 = parseInt(newR0, 10);\r\n\t            newD = parseInt(newD, 10);\r\n\t            // 按比例缩放\r\n\t            this.setShape({\r\n\t                r: newR,\r\n\t                r0: newR0,\r\n\t                d: newD\r\n\t            });\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 115 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 路径<br>\r\n\t * @class fishTopoFlow.node.Path\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var path = new node.Path({\r\n\t *           pathData: 'M9 0l8 8-17 17 7 7 17-17 8 8v-23h-23z',\r\n\t *           rect: {x:0,y:0,width:30,height:30},\r\n\t *           position: [60,60]\r\n\t *       });\r\n\t *       fishTopo.add(path);\r\n\t */\r\n\t\r\n\t    var pathTool = __webpack_require__(6);\r\n\t    var Draggable = __webpack_require__(43);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var flowNode = __webpack_require__(96);\r\n\t\r\n\t    function ZPath(opts) {\r\n\t        /**\r\n\t         * @cfg {Object} options 参数\r\n\t         * @cfg {String} options.pathData path数据。\r\n\t         * @cfg {Object} options.rect 图形的大小。\r\n\t         * @cfg {Object} options.rect.width 图形的宽度。\r\n\t         * @cfg {Object} options.rect.height 图形的高度。\r\n\t         * @cfg {Number} [options.layout=null] 默认为null  仅支持\"center\"\r\n\t         *\r\n\t         */\r\n\t        var defaultOptions = {\r\n\t            style:{ fill: 'none',stroke: '#2c2c2c'},\r\n\t            rect:{x:0,y:0,width:0,height:0},\r\n\t            rectHover: true\r\n\t        }\r\n\t\r\n\t        var pathData = opts.pathData;\r\n\t        var model = flowNode.genModel(\"Path\", opts);\r\n\t        delete opts.pathData;\r\n\t        this.options = zrUtil.merge(defaultOptions, opts, true);\r\n\t        var path = pathTool.createFromString(pathData, this.options);\r\n\t        path.model = model;\r\n\t        Draggable.call(path);\r\n\t        var boundingRect = path.getBoundingRect();\r\n\t        var rect = this.options.rect;\r\n\t        var layout = opts.layout;\r\n\t        if (rect) {\r\n\t            var aspect = boundingRect.width / boundingRect.height;\r\n\t\r\n\t            if (layout === 'center') {\r\n\t                // Set rect to center, keep width / height ratio.\r\n\t                var width = rect.height * aspect;\r\n\t                var height;\r\n\t                if (width <= rect.width) {\r\n\t                    height = rect.height;\r\n\t                }\r\n\t                else {\r\n\t                    width = rect.width;\r\n\t                    height = width / aspect;\r\n\t                }\r\n\t                var cx = rect.x + rect.width / 2;\r\n\t                var cy = rect.y + rect.height / 2;\r\n\t\r\n\t                rect.x = cx - width / 2;\r\n\t                rect.y = cy - height / 2;\r\n\t                rect.width = width;\r\n\t                rect.height = height;\r\n\t            }\r\n\t\r\n\t            this.resizePath(path, rect);\r\n\t        }\r\n\t        path.type = 'ZPath';\r\n\t        return path;\r\n\t    }\r\n\t\r\n\t    ZPath.prototype = {\r\n\t\r\n\t        constructor: ZPath,\r\n\t\r\n\t        type: 'ZPath',\r\n\t        /**\r\n\t         * Resize a path to fit the rect\r\n\t         */\r\n\t        resizePath: function (path, rect) {\r\n\t                if (!path.applyTransform) {\r\n\t                    return;\r\n\t                }\r\n\t\r\n\t                var pathRect = path.getBoundingRect();\r\n\t\r\n\t                var m = pathRect.calculateTransform(rect);\r\n\t\r\n\t                path.applyTransform(m);\r\n\t        },\r\n\t        updateShape: function (ratio, ifParse) {\r\n\t            var scaleRatio = Number(ratio);\r\n\t            var rect = this.rect;\r\n\t            var newW = Number(rect.width * scaleRatio);\r\n\t            var newH = Number(newW * rect.height / rect.width);\r\n\t            if (ifParse) {\r\n\t                newW = parseInt(newW, 10);\r\n\t                newH = parseInt(newH, 10);\r\n\t            }\r\n\t            rect.width = newW;\r\n\t            rect.height = newH;\r\n\t            // 按比例缩放\r\n\t            this.attr('rect', rect);\r\n\t        }\r\n\t    }\r\n\t    zrUtil.inherits(ZPath, Draggable);\r\n\t    module.exports = ZPath;\r\n\t\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 116 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 图形按钮<br>\r\n\t * @class fishTopoFlow.node.IconButton\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var iconButton   = new node.IconButton({\r\n\t *          title:'IconButton',\r\n\t *          icon:'path://M432.45,595.444c0,2.177-4.661,6.82-11.305,6.82c-6.475,0-11.306-4.567-11.306-6.82s4.852-6.812,11.306-6.812C427.841,588.632,432.452,593.191,432.45,595.444L432.45,595.444z M421.155,589.876c-3.009,0-5.448,2.495-5.448,5.572s2.439,5.572,5.448,5.572c3.01,0,5.449-2.495,5.449-5.572C426.604,592.371,424.165,589.876,421.155,589.876L421.155,589.876z M421.146,591.891c-1.916,0-3.47,1.589-3.47,3.549c0,1.959,1.554,3.548,3.47,3.548s3.469-1.589,3.469-3.548C424.614,593.479,423.062,591.891,421.146,591.891L421.146,591.891zM421.146,591.891',\r\n\t *          itemSize:50,\r\n\t *          position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(iconButton);\r\n\t */\r\n\t\r\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var graphic = __webpack_require__(4);\r\n\t    var flowNode = __webpack_require__(96);\r\n\t\r\n\t    function IconButton(opts) {\r\n\t\r\n\t        /**\r\n\t         * @cfg {Object} options 构造参数\r\n\t         * @cfg {String} options.title=\"\" 鼠标移上去显示的文字\r\n\t         * @cfg {String} options.icon=\"\" Icon 的 path 字符串，支持使用自定义的 svg path 作为 icon，格式参见 [SVG PathData](https://www.w3.org/TR/SVG/paths.html#PathData)。可以从 Adobe Illustrator 等工具编辑导出。\r\n\t         * @cfg {Number} options.itemSize=15  icon 的大小\r\n\t         * @cfg {Object} options.iconStyle  图标样式\r\n\t         * @cfg {Object} options.iconStyle.normal 正常的样式\r\n\t         * @cfg {Number} options.iconStyle.normal.stroke='#666' 正常的样式（描边色）\r\n\t         * @cfg {Number} options.iconStyle.normal.fill='none' 正常的样式（填充色）\r\n\t         * @cfg {Object} options.iconStyle.emphasis 高亮状态下的样式\r\n\t         * @cfg {Number} options.iconStyle.emphasis.stroke='#666' 高亮状态下的样式（描边色）\r\n\t         * @cfg {Number} options.iconStyle.emphasis.fill='none' 高亮状态下的样式（填充色）\r\n\t         */\r\n\t        var defaultOptions = {\r\n\t            backgroundColor: 'transparent',\r\n\t            borderColor: '#ccc',\r\n\t            draggable:false,\r\n\t            selectable:false,\r\n\t            borderWidth: 0,\r\n\t            itemSize: 15,\r\n\t            showTitle: true,\r\n\t            icon:\"\",  //Icon 的 path 字符串，支持使用自定义的 svg path 作为 icon，格式参见 SVG PathData。可以从 Adobe Illustrator 等工具编辑导出。\r\n\t            iconStyle: {\r\n\t                normal: {\r\n\t                    stroke: '#666',\r\n\t                    fill: 'none'\r\n\t                },\r\n\t                emphasis: {\r\n\t                    stroke: '#3E98c5'\r\n\t                }\r\n\t            }\r\n\t        };\r\n\t        this.options = zrUtil.merge(defaultOptions, opts, true);\r\n\t\r\n\t        this.model = flowNode.genModel(\"IconButton\", this.options);\r\n\t        graphic.Group.call(this, this.options);\r\n\t        this.render();\r\n\t    }\r\n\t    IconButton.prototype = {\r\n\t        constructor: IconButton,\r\n\t        type: \"IconButton\",\r\n\t        render: function () {\r\n\t            var normalStyle = this.options.iconStyle.normal;\r\n\t            var hoverStyle = this.options.iconStyle.emphasis;\r\n\t            var itemSize = this.options.itemSize;\r\n\t            var icon = this.options.icon;\r\n\t            var style = {\r\n\t                x: -itemSize / 2,\r\n\t                y: -itemSize / 2,\r\n\t                width: itemSize,\r\n\t                height: itemSize\r\n\t            };\r\n\t            var path = icon.indexOf('image://') === 0 ?\r\n\t                (\r\n\t                    style.image = icon.slice(8),\r\n\t                    new graphic.Image({\r\n\t                        style: style\r\n\t                    })\r\n\t                ) :\r\n\t                graphic.makePath(\r\n\t                    icon.replace('path://', ''), {\r\n\t                        style: normalStyle,\r\n\t                        hoverStyle: hoverStyle,\r\n\t                        rectHover: true\r\n\t                    },\r\n\t                    style,\r\n\t                    'center'\r\n\t                );\r\n\t\r\n\t            graphic.setHoverStyle(path);\r\n\t\r\n\t            if (this.options.showTitle) {\r\n\t                path.__title = this.options.title;\r\n\t                path.on('mouseover', function () {\r\n\t                        // Should not reuse above hoverStyle, which might be modified.\r\n\t                        path.setStyle({\r\n\t                            text: this.options.title,\r\n\t                            textPosition: hoverStyle.textPosition || 'bottom',\r\n\t                            textFill: hoverStyle.fill || hoverStyle.stroke || '#000',\r\n\t                            textAlign: hoverStyle.textAlign || 'center'\r\n\t                        });\r\n\t                    }.bind(this))\r\n\t                    .on('mouseout', function () {\r\n\t                        path.setStyle({\r\n\t                            textFill: null\r\n\t                        });\r\n\t                    });\r\n\t            }\r\n\t\r\n\t            path.trigger('normal');\r\n\t            this.add(path);\r\n\t        }\r\n\t    }\r\n\t\r\n\t    zrUtil.inherits(IconButton, graphic.Group);\r\n\t    module.exports = IconButton;\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 117 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\r\n\t * fishTopoFlow的link对象，框架提供的连线都放在这个对象下。\r\n\t * @class fishTopoFlow.link\r\n\t * @abstract\r\n\t */\r\n\t\r\n\t    var Link = __webpack_require__(118);\r\n\t    var Fold = __webpack_require__(120);\r\n\t    var Curve = __webpack_require__(121);\r\n\t    var Chain = __webpack_require__(122);\r\n\t    var Connector = __webpack_require__(82);\r\n\t    var flowLink = {};\r\n\t    flowLink.Link = flowLink[Connector.TYPE_STRAIGHT] = Link;\r\n\t    flowLink.Fold = flowLink[Connector.TYPE_JAGGED] = Fold;\r\n\t    flowLink.Curve = flowLink[Connector.TYPE_CURVE] = Curve;\r\n\t    flowLink.Chain = flowLink[Connector.TYPE_CHAIN] = Chain;\r\n\t    module.exports = flowLink;\r\n\t\r\n\t\r\n\t/**\r\n\t * @method constructor\r\n\t * 连线的构造函数\r\n\t * @param  {Object} startNode 开始节点\r\n\t * @param  {Object} endNode   结束节点\r\n\t * @param  {Object} options 线段选项\r\n\t * @param {Object} [options.style] 节点的样式\r\n\t * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n\t * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n\t * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n\t * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n\t * @param {Object} [options.symbol] 线段的箭头\r\n\t * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n\t * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n\t * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n\t * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]\r\n\t * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]\r\n\t * @param {Number} [options.symbol.offset] 设置箭头在连线上的偏移量，默认是0；此属性只针对直线和折线类型有效，如果是折线，offset最大值不能超过options.bundleOffset(默认是30)设置的值 since V2.3.0\r\n\t * @param {Object} [options.text] 线段上的文字\r\n\t * @param {String} [options.text.text] 线段上的文字内容\r\n\t * @param {String} [options.text.color] 线段上的文字颜色\r\n\t * @param {String} [options.text.textFont] 线段上的文字字体\r\n\t * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n\t * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]\r\n\t * @param {Boolean} [options.text.textRotateable] 文字随线段旋转, 默认值为true\r\n\t * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t * @param {String} [options.position] 指定线段位置\r\n\t * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t * @param {Object} [options.position.startOffset] 线段开始位置的偏移\r\n\t * @param {Object} [options.position.endOffset] 线段结束位置的偏移\r\n\t * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]\r\n\t * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n\t * @param {Object} [options.effect] 线上动态效果\r\n\t * @param {String} [options.effect.show] 是否显示箭头动效\r\n\t * @param {Number} [options.effect.period] 动效移动速度\r\n\t * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n\t * @param {Number} [options.z] 连线的层级，越大越在前面显示\r\n\t * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)\r\n\t * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)\r\n\t * @return {Object} 返回创建成功的连线对象\r\n\t */\r\n\t\r\n\t\r\n\t/**\r\n\t * @method setStyle\r\n\t * 创建连线后，设置连线的样式\r\n\t * @param {Object} options 对应创建节点，传递的options参数\r\n\t * @param {Object} [options.text] 连线文字的样式\r\n\t * @param {Object} [options.symbol] 连线箭头的样式\r\n\t * @param {String} [options.color] 连线的颜色\r\n\t */\r\n\t/**\r\n\t * @method on\r\n\t * 绑定事件\r\n\t * @param {String} event 事件名\r\n\t * @param {Function} handler 事件处理函数\r\n\t * @param {Object} [context] 上下文\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method off\r\n\t * 解绑事件\r\n\t * @param {String} event 事件名\r\n\t * @param {Function} handler 事件处理函数\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method one\r\n\t * 单次触发绑定,trigger后销毁\r\n\t * @param {String} event 事件名\r\n\t * @param {Function} handler 事件处理函数\r\n\t * @param {Object} [context] 上下文\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method trigger\r\n\t * 事件分发\r\n\t * @param {String} type 事件类型\r\n\t */\r\n\t/**\r\n\t * @event click\r\n\t * 单击事件\r\n\t *\r\n\t * <pre>\r\n\t * flink.on('Connector:click', function(e) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event dblclick\r\n\t * 当双击元素时，会发生 dblclick 事件。\r\n\t *\r\n\t * <pre>\r\n\t * flink.on('Connector:dblclick', function(e) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\n\n/***/ }),\n/* 118 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 直线<br>\r\n\t * @class fishTopoFlow.link.Link\r\n\t * @extends fishTopoFlow.link\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var link = fishTopoFlow.link;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       //节点\r\n\t *       function newNode(x, y, w, h) {\r\n\t *           var rect = new node.Rect({\r\n\t *               shape: {width: w,height: h},\r\n\t *               position: [x, y],\r\n\t *               style: {fill: \"#167CFF\"}\r\n\t *           });\r\n\t *           fishTopo.add(rect);\r\n\t *           return rect;\r\n\t *       }\r\n\t *       //简单连线\r\n\t *       function newLink(startNode, endNode, text, dashedPattern) {\r\n\t *           var slink = new link.Link(startNode, endNode, {\r\n\t *               style: {lineDash: [dashedPattern]},\r\n\t *               text: {text: text}\r\n\t *           })\r\n\t *           fishTopo.add(slink);\r\n\t *           return slink;\r\n\t *       }\r\n\t *       var from = newNode(100, 60, 30, 30);\r\n\t *       var to = newNode(300, 60, 30, 30);\r\n\t *       newLink(from, to, '虚线带箭头', 5);\r\n\t */\r\n\t\r\n\t    var Connector = __webpack_require__(82);\r\n\t    var Flow = __webpack_require__(119);\r\n\t\r\n\t    function Link(startNode,endNode,options) {\r\n\t        var opt = Flow.translateLinkOptions(options);\r\n\t        //默认就是直线\r\n\t        var connector = new Connector(opt);\r\n\t        connector.startNode = startNode;\r\n\t        connector.endNode = endNode;\r\n\t\r\n\t        return connector;\r\n\t    }\r\n\t    /**\r\n\t     * @method createByPoint\r\n\t     * 用户指定连线的点，来进行画线\r\n\t     * @param  {Object} options 线段选项\r\n\t     * @param {Object} [options.style] 节点的样式\r\n\t     * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n\t     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n\t     * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n\t     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n\t     * @param {Object} [options.symbol] 线段的箭头\r\n\t     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n\t     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n\t     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n\t     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]\r\n\t     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]\r\n\t     * @param {Number} [options.symbol.offset] 设置箭头在连线上的偏移量，默认是0 since V2.3.0\r\n\t     * @param {Object} [options.text] 线段上的文字\r\n\t     * @param {String} [options.text.text] 线段上的文字内容\r\n\t     * @param {String} [options.text.textFill] 线段上的文字颜色\r\n\t     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n\t     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]\r\n\t     * @param {Boolean} [options.text.textRotateable] 文字随线段旋转, 默认值为true\r\n\t     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t     * @param {String} [options.position] 指定线段位置\r\n\t     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t     * @param {Object} [options.position.startOffset] 线段开始位置的偏移[x,y]   eg. startOffset:[0,10] 在x上偏移0 y上偏移10\r\n\t     * @param {Object} [options.position.endOffset] 线段结束位置的偏移[x,y]   eg. startOffset:[0,10] 在x上偏移0 y上偏移10\r\n\t     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]\r\n\t     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n\t     * @param {Object} [options.effect] 线上动态效果\r\n\t     * @param {String} [options.effect.show] 是否显示箭头动效\r\n\t     * @param {Number} [options.effect.period] 动效移动速度\r\n\t     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n\t     * @param {Number} [options.z] 连线的层级，越大越在前面显示\r\n\t     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)\r\n\t     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)\r\n\t     */\r\n\t    Link.createByPoint = function(options) {\r\n\t        var opt = Flow.translateLinkOptions(options);\r\n\t        //默认就是直线\r\n\t        var connector = new Connector(opt);\r\n\t        return connector;\r\n\t    }\r\n\t\r\n\t    module.exports = Link;\r\n\t\r\n\t\r\n\n\n/***/ }),\n/* 119 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Flow静态方法类\r\n\t * @class fish.topo.FishTopoFlow.Flow\r\n\t */\r\n\t\r\n\t\r\n\t    var Constants = __webpack_require__(93);\r\n\t    var GroupNode = __webpack_require__(95);\r\n\t    var util = __webpack_require__(65);\r\n\t    var Flow = {\r\n\t        FLOW_TYPE: \"elementType\",\r\n\t        LINK: \"connection\",\r\n\t        RECT: \"Rect\",\r\n\t        Group: 'Group',\r\n\t        IMAGE: 'Image',\r\n\t        TEXT: 'Text',\r\n\t        CIRCLE: 'Circle',\r\n\t        SECTOR: 'Sector',\r\n\t        RING: 'Ring',\r\n\t        POLYGON: 'Polygon',\r\n\t        POLYLINE: 'Polyline',\r\n\t        LINE: 'Line',\r\n\t        BEZIERCURVE: 'Beziercurve',\r\n\t        ARC: 'Arc',\r\n\t        SCENE:'scene',\r\n\t\r\n\t        /**\r\n\t         * @method setUserData\r\n\t         * 设置用户数据\r\n\t         * @param {Object} node 需要设置数据的节点\r\n\t         * @param {Object} obj 数据\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //设置自定义数据\r\n\t         *      this.fishTopo.Flow.setUserData(rect, { customObj: \"rect\" });\r\n\t         */\r\n\t        setUserData: function(node, obj) {\r\n\t            node.model.set(Constants.USERDATA, obj);\r\n\t        },\r\n\t        /**\r\n\t         * 获取设置的用户数据\r\n\t         * @param {Object} node 需要获取数据的节点\r\n\t         * @return {String}      数据\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //获取自定义数据\r\n\t         *      this.fishTopo.Flow.getUserData(rect);\r\n\t         */\r\n\t        getUserData: function(node) {\r\n\t            var userData = node.model.get(Constants.USERDATA);\r\n\t            if (util.isUndefined(userData)) {\r\n\t                userData = {};\r\n\t            }\r\n\t            return userData;\r\n\t        },\r\n\t        /**\r\n\t         * 判断是否是连线\r\n\t         * @param {Object} model 对象的model\r\n\t         * @return {Boolean}      是 否\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //判断是否是连线\r\n\t         *      var nodeModel = e.target.model;\r\n\t         *      if (this.fishTopo.Flow.isLink(nodeModel)) { return true;}\r\n\t         */\r\n\t        isLink: function(model) {\r\n\t            var elementType = model.get(Flow.FLOW_TYPE);\r\n\t            return elementType == Flow.LINK;\r\n\t        },\r\n\t        /**\r\n\t         * 判断是否是节点\r\n\t         * @param {Object} model 对象的model\r\n\t         * @return {Boolean}      是 否\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //判断是否是节点\r\n\t         *      var nodeModel = e.target.model;\r\n\t         *      if (this.fishTopo.Flow.isNode(nodeModel)) { return true;}\r\n\t         */\r\n\t\r\n\t        isNode: function(model) {\r\n\t            var elementType = model.get(Flow.FLOW_TYPE);\r\n\t            var isNode;\r\n\t            if(elementType !=  Flow.LINK && elementType !=  Flow.SCENE){\r\n\t                isNode = true;\r\n\t            }else{\r\n\t                isNode = false;\r\n\t            }\r\n\t            return isNode;\r\n\t        },\r\n\t\r\n\t        isInGroup: function(node) {\r\n\t            return node.parent && node.parent instanceof GroupNode;\r\n\t        },\r\n\t\r\n\t        isGroupNode: function(node) {\r\n\t            return node instanceof GroupNode;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 判断节点是否是矩形节点\r\n\t         * @param {Object} model 节点的model\r\n\t         * @return {Boolean}      是 否\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //判断是否是矩形节点\r\n\t         *      var nodeModel = e.target.model;\r\n\t         *      if (this.fishTopo.Flow.isRect(nodeModel)) { return true;}\r\n\t         */\r\n\t        isRect: function(model) {\r\n\t            var elementType = model.get(Flow.FLOW_TYPE);\r\n\t            return  elementType == Flow.RECT;\r\n\t        },\r\n\t        /**\r\n\t         * 判断节点是否是图片节点\r\n\t         * @param {Object} model 节点的model\r\n\t         * @return {Boolean}      是 否\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //判断是否是图片节点\r\n\t         *      var nodeModel = e.target.model;\r\n\t         *      if (this.fishTopo.Flow.isImage(nodeModel)) { return true;}\r\n\t         */\r\n\t        isImage: function(model) {\r\n\t            var elementType = model.get(Flow.FLOW_TYPE);\r\n\t            return elementType == Flow.IMAGE;\r\n\t        },\r\n\t        /**\r\n\t         * 判断节点是否是文字节点\r\n\t         * @param {Object} model 节点的model\r\n\t         * @return {Boolean}      是 否\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //判断是否是文字节点\r\n\t         *      var nodeModel = e.target.model;\r\n\t         *      if (this.fishTopo.Flow.isText(nodeModel)) { return true;}\r\n\t         */\r\n\t        isText: function(model) {\r\n\t            var elementType = model.get(Flow.FLOW_TYPE);\r\n\t            return elementType == Flow.TEXT;\r\n\t        },\r\n\t        /**\r\n\t         * 判断节点是否是圆形节点\r\n\t         * @param {Object} model 节点的model\r\n\t         * @return {Boolean}      是 否\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //判断是否是圆形节点\r\n\t         *      var nodeModel = e.target.model;\r\n\t         *      if (this.fishTopo.Flow.isCircle(nodeModel)) { return true;}\r\n\t         */\r\n\t        isCircle: function(model) {\r\n\t            var elementType = model.get(Flow.FLOW_TYPE);\r\n\t            return elementType == Flow.CIRCLE;\r\n\t        },\r\n\t        /**\r\n\t         * 获取节点的类型\r\n\t         * @param {Object} model 节点的model\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //获取节点类型\r\n\t         *      var nodeModel = e.target.model;\r\n\t         *      return this.fishTopo.Flow.getType(nodeModel);\r\n\t         */\r\n\t        getType: function(model) {\r\n\t            var elementType = model.get(Flow.FLOW_TYPE);\r\n\t            return elementType;\r\n\t        },\r\n\t        translateLinkOptions: function(options) {\r\n\t            if (options) {\r\n\t                if (options.pos) {\r\n\t                    var arrPos = options.pos.split(\",\");\r\n\t                    if (arrPos.length >= 2) {\r\n\t                        if (!options.position) {\r\n\t                            options.position = {};\r\n\t                        }\r\n\t                        options.position.startPos = arrPos[0];\r\n\t                        options.position.endPos = arrPos[1];\r\n\t                    }\r\n\t                }\r\n\t                if (options.text && options.text.color) {\r\n\t                    options.text.textFill = options.text.color;\r\n\t                }\r\n\t            }\r\n\t            return options;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    module.exports = Flow;\r\n\t\r\n\n\n/***/ }),\n/* 120 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 折线<br>\r\n\t * @class fishTopoFlow.link.Fold\r\n\t * @extends fishTopoFlow.link\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var link = fishTopoFlow.link;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       //节点\r\n\t *       function newNode(x, y, w, h) {\r\n\t *           var rect = new node.Rect({\r\n\t *               shape: {width: w,height: h},\r\n\t *               position: [x, y],\r\n\t *               style: {fill: \"#167CFF\"}\r\n\t *           });\r\n\t *           fishTopo.add(rect);\r\n\t *           return rect;\r\n\t *       }\r\n\t *       //折线\r\n\t *       function newFoldLink(startNode, endNode, text, direction, dashedPattern) {\r\n\t *           var flink = new link.Fold(startNode, endNode, {\r\n\t *               style: {lineDash: [dashedPattern]},\r\n\t *               text: {text: text},\r\n\t *               pos: direction\r\n\t *           })\r\n\t *           fishTopo.add(flink);\r\n\t *           return flink;\r\n\t *       }\r\n\t *       var from = newNode(100, 40, 30, 30);\r\n\t *       var to = newNode(300, 80, 30, 30);\r\n\t *       newFoldLink(from, to, '折线');\r\n\t */\r\n\t\r\n\t    var Connector = __webpack_require__(82);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var Flow = __webpack_require__(119);\r\n\t\r\n\t    function Fold(startNode,endNode,options) {\r\n\t        //折线\r\n\t        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_JAGGED}}, options, true);\r\n\t        opt = Flow.translateLinkOptions(opt);\r\n\t        var connector = new Connector(opt);\r\n\t        connector.startNode = startNode;\r\n\t        connector.endNode = endNode;\r\n\t\r\n\t        return connector;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @method createByPoint\r\n\t     * 用户指定连线的点，来进行画线\r\n\t     * @param  {Object} options 线段选项\r\n\t     * @param {Object} [options.style] 节点的样式\r\n\t     * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n\t     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n\t     * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n\t     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n\t     * @param {Object} [options.symbol] 线段的箭头\r\n\t     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n\t     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n\t     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n\t     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]\r\n\t     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]\r\n\t     * @param {Number} [options.symbol.offset] 设置箭头在连线上的偏移量，默认是0；offset最大值不能超过options.bundleOffset(默认30) 设置的值 since V2.3.0\r\n\t     * @param {Object} [options.text] 线段上的文字\r\n\t     * @param {String} [options.text.text] 线段上的文字内容\r\n\t     * @param {String} [options.text.color] 线段上的文字颜色\r\n\t     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n\t     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]\r\n\t     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t     * @param {String} [options.position] 指定线段位置\r\n\t     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t     * @param {Object} [options.position.startOffset] 线段开始位置的偏移\r\n\t     * @param {Object} [options.position.endOffset] 线段结束位置的偏移\r\n\t     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]\r\n\t     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n\t     * @param {Object} [options.effect] 线上动态效果\r\n\t     * @param {String} [options.effect.show] 是否显示箭头动效\r\n\t     * @param {Number} [options.effect.period] 动效移动速度\r\n\t     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n\t     * @param {Number} [options.z] 连线的层级，越大越在前面显示\r\n\t     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)\r\n\t     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)\r\n\t     */\r\n\t    Fold.createByPoint = function(options) {\r\n\t        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_JAGGED}}, options, true);\r\n\t        opt = Flow.translateLinkOptions(opt);\r\n\t        var connector = new Connector(opt);\r\n\t        return connector;\r\n\t    }\r\n\t    module.exports = Fold;\r\n\n\n/***/ }),\n/* 121 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 曲线<br>\r\n\t * @class fishTopoFlow.link.Curve\r\n\t * @extends fishTopoFlow.link\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var link = fishTopoFlow.link;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       //节点\r\n\t *       function newNode(x, y, w, h) {\r\n\t *           var rect = new node.Rect({\r\n\t *               shape: {width: w,height: h},\r\n\t *               position: [x, y],\r\n\t *               style: {fill: \"#167CFF\"}\r\n\t *           });\r\n\t *           fishTopo.add(rect);\r\n\t *           return rect;\r\n\t *       }\r\n\t *       //曲线\r\n\t *       function newCurveLink(startNode, endNode, text, direction, dashedPattern) {\r\n\t *           var clink = new link.Curve(startNode, endNode, {\r\n\t *               style: {lineDash: [dashedPattern]},\r\n\t *               text: {text: text},\r\n\t *               pos: direction\r\n\t *           })\r\n\t *           fishTopo.add(clink);\r\n\t *           return clink;\r\n\t *       }\r\n\t *       var from = newNode(100, 40, 30, 30);\r\n\t *       var to = newNode(300, 80, 30, 30);\r\n\t *       newCurveLink(from, to, '曲线');\r\n\t */\r\n\t\r\n\t    var Connector = __webpack_require__(82);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var Flow = __webpack_require__(119);\r\n\t    function Curve(startNode,endNode,options) {\r\n\t        //曲线\r\n\t        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_CURVE}}, options, true);\r\n\t        opt = Flow.translateLinkOptions(opt);\r\n\t\r\n\t        var connector = new Connector(opt);\r\n\t        connector.startNode = startNode;\r\n\t        connector.endNode = endNode;\r\n\t\r\n\t        return connector;\r\n\t    }\r\n\t    /**\r\n\t     * @method createByPoint\r\n\t     * 用户指定连线的点，来进行画线\r\n\t     * @param  {Object} options 线段选项\r\n\t     * @param {Object} [options.style] 节点的样式\r\n\t     * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n\t     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n\t     * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n\t     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n\t     * @param {Object} [options.symbol] 线段的箭头\r\n\t     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n\t     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n\t     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n\t     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]\r\n\t     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]\r\n\t     * @param {Object} [options.text] 线段上的文字\r\n\t     * @param {String} [options.text.text] 线段上的文字内容\r\n\t     * @param {String} [options.text.color] 线段上的文字颜色\r\n\t     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n\t     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]\r\n\t     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t     * @param {String} [options.position] 指定线段位置\r\n\t     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t     * @param {Object} [options.position.startOffset] 线段开始位置的偏移\r\n\t     * @param {Object} [options.position.endOffset] 线段结束位置的偏移\r\n\t     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]\r\n\t     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n\t     * @param {Object} [options.effect] 线上动态效果\r\n\t     * @param {String} [options.effect.show] 是否显示箭头动效\r\n\t     * @param {Number} [options.effect.period] 动效移动速度\r\n\t     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n\t     * @param {Number} [options.z] 连线的层级，越大越在前面显示\r\n\t     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)\r\n\t     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)\r\n\t     */\r\n\t    Curve.createByPoint = function(options) {\r\n\t        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_CURVE}}, options, true);\r\n\t        opt = Flow.translateLinkOptions(opt);\r\n\t        var connector = new Connector(opt);\r\n\t        return connector;\r\n\t    }\r\n\t    module.exports = Curve;\r\n\n\n/***/ }),\n/* 122 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 链路 支持线上多文本展示， 最大的不同是text.text对象为数组类型，表示多个文本的数据。数组元素可以为字符串，表示每个文本的名字；也可以是个对象，对象中必须指定text属性，其值为文本的名字，其余属性则为业务侧自定义的<br>\r\n\t * @class fishTopoFlow.link.Chain\r\n\t * @extends fishTopoFlow.link\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var link = fishTopoFlow.link;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       //节点\r\n\t *       function newNode(x, y, w, h) {\r\n\t *           var rect = new node.Rect({\r\n\t *               shape: {width: w,height: h},\r\n\t *               position: [x, y],\r\n\t *               style: {fill: \"#167CFF\"}\r\n\t *           });\r\n\t *           fishTopo.add(rect);\r\n\t *           return rect;\r\n\t *       }\r\n\t *       //节点间链路\r\n\t *       function newChain(startNode, endNode, text, dashedPattern) {\r\n\t *           var slink = new link.Chain(startNode, endNode, {\r\n\t *               style: {lineDash: [dashedPattern]},\r\n\t *               text: {text: text}\r\n\t *           })\r\n\t *           fishTopo.add(slink);\r\n\t *           return slink;\r\n\t *       }\r\n\t *       var from = newNode(100, 60, 30, 30);\r\n\t *       var to = newNode(300, 60, 30, 30);\r\n\t *       newChain(from, to, [{text: '倾斜文本1', linkId: 100}, {text: '倾斜文本2', linkId: 111}, {text: '倾斜文本3', linkId: 112}], 5);\r\n\t */\r\n\t\r\n\t    var Connector = __webpack_require__(82);\r\n\t    var Flow = __webpack_require__(119);\r\n\t\r\n\t    function Chain(startNode,endNode,options) {\r\n\t        options.style.lineType = Connector.TYPE_CHAIN\r\n\t        var opt = Flow.translateLinkOptions(options);\r\n\t        var connector = new Connector(opt);\r\n\t        connector.startNode = startNode;\r\n\t        connector.endNode = endNode;\r\n\t\r\n\t        return connector;\r\n\t    }\r\n\t    /**\r\n\t     * @method createByPoint\r\n\t     * 用户指定连线的点，来进行画线\r\n\t     * @param  {Object} options 线段选项\r\n\t     * @param {Object} [options.style] 节点的样式\r\n\t     * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n\t     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n\t     * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n\t     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n\t     * @param {Object} [options.symbol] 线段的箭头\r\n\t     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n\t     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n\t     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n\t     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]\r\n\t     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]\r\n\t     * @param {Number} [options.symbol.offset] 设置箭头在连线上的偏移量，默认是0 since V2.3.0\r\n\t     * @param {Object} [options.text] 线段上的文字\r\n\t     * @param {Object} [options.text.text] 为数组类型，表示多个文本的数据。数组元素可以为字符串，表示每个文本的名字；也可以是个对象，对象中必须指定text属性，其值为文本的名字，其余属性则为业务侧自定义的\r\n\t     * @param {String} [options.text.color] 线段上的文字颜色\r\n\t     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n\t     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]\r\n\t     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t     * @param {String} [options.position] 指定线段位置\r\n\t     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t     * @param {Object} [options.position.startOffset] 线段开始位置的偏移[x,y]   eg. startOffset:[0,10] 在x上偏移0 y上偏移10\r\n\t     * @param {Object} [options.position.endOffset] 线段结束位置的偏移[x,y]   eg. startOffset:[0,10] 在x上偏移0 y上偏移10\r\n\t     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]\r\n\t     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n\t     * @param {Object} [options.effect] 线上动态效果\r\n\t     * @param {String} [options.effect.show] 是否显示箭头动效\r\n\t     * @param {Number} [options.effect.period] 动效移动速度\r\n\t     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n\t     * @param {Number} [options.z] 连线的层级，越大越在前面显示\r\n\t     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)\r\n\t     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)\r\n\t     */\r\n\t    Chain.createByPoint = function(options) {\r\n\t        var opt = Flow.translateLinkOptions(options);\r\n\t        var connector = new Connector(opt);\r\n\t        return connector;\r\n\t    }\r\n\t\r\n\t    module.exports = Chain;\r\n\t\r\n\t\r\n\n\n/***/ }),\n/* 123 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 连线操作类\r\n\t * @author miao.cunzhi\r\n\t */\r\n\t\r\n\t    var symbolUtil = __webpack_require__(83);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var icon = __webpack_require__(89);\r\n\t    function LineOperationManager(connectionManager, api) {\r\n\t        this.lineOperations = [],\r\n\t        this.isEdit = true;\r\n\t        this.connectionManager = connectionManager;\r\n\t        this._api = api;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     *  this.lineOperationManager.addIcon(key, options);\r\n\t     */\r\n\t    LineOperationManager.prototype.addIcon = function(key, options) {\r\n\t        //判断是小图标否存在 ，存在则直接返回\r\n\t        var lineOperationIcon = zrUtil.find(options.lineNode.icons, function(icon) {\r\n\t            return icon.key === key;\r\n\t        });\r\n\t\r\n\t        if (lineOperationIcon) {\r\n\t            this.bindOperation(options.lineNode);\r\n\t            return;\r\n\t        }else {\r\n\t            var lineOperation = this.creatOperation(key, options);\r\n\t            this._api._getParentZr().add(lineOperation);\r\n\t            this.bindOperation(options.lineNode);\r\n\t            return lineOperation;\r\n\t        }\r\n\t    }\r\n\t\r\n\t\r\n\t    LineOperationManager.prototype.creatOperation = function(key, options) {\r\n\t        var lineOperation = symbolUtil.createSymbol(options.iconPath, 0, 0, options.width || 15, options.height || 15, 0, options.color||'#aaaaac');\r\n\t        lineOperation.key = key;\r\n\t        lineOperation._width =  options.width || 15;  // path情况下无法计算\r\n\t        lineOperation._isLineOperationIcon = true;\r\n\t        lineOperation.hide();\r\n\t        options.lineNode.icons.push(lineOperation);\r\n\t        this.lineOperations.push(lineOperation);\r\n\t\r\n\t        //小图标 点击事件  如果有回调则调用回调，否则派发事件\r\n\t        lineOperation.on(\"click\", function(event) {\r\n\t            if (options.callback) {\r\n\t                event.data = options;\r\n\t                event.lineNode = options.lineNode;\r\n\t                options.callback(event);\r\n\t            } else {\r\n\t                var params = {};\r\n\t                params.event = event;\r\n\t                params.type = \"click\";\r\n\t                params.elementType = \"LineOperationIcon\";\r\n\t                this._api.trigger(params.type, params);\r\n\t            }\r\n\t        }.bind(this));\r\n\t        return lineOperation;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 计算小图标的位置，并显示\r\n\t     * @param  {[type]} connector [description]\r\n\t     * @return {[type]}           [description]\r\n\t     */\r\n\t    LineOperationManager.prototype.bindOperation = function(connector) {\r\n\t        function parentX(node) {\r\n\t            if (node.parent && node.parent.nodeType == \"SubProcess\") {\r\n\t                return node.position[0] + parentX(node.parent)\r\n\t            } else {\r\n\t                return node.position[0]\r\n\t            }\r\n\t        }\r\n\t    \r\n\t        function parentY(node) {\r\n\t            if (node.parent && node.parent.nodeType == \"SubProcess\") {\r\n\t                return node.position[1] + parentY(node.parent)\r\n\t            } else {\r\n\t                return node.position[1]\r\n\t            }\r\n\t        }\r\n\t\r\n\t        if (this.isEdit == false) {\r\n\t            return;\r\n\t        }\r\n\t        var pointPosition = connector.middle(), posX, posY;\r\n\t        if (connector.parent && connector.parent.nodeType == \"SubProcess\") {\r\n\t            posX = pointPosition[0] + parentX(connector.parent);\r\n\t            posY = pointPosition[1] + parentY(connector.parent);\r\n\t        } else {\r\n\t            posX = pointPosition[0];\r\n\t            posY = pointPosition[1];\r\n\t        }\r\n\t\r\n\t        var arrLength = zrUtil.map(connector.icons, function(icon) {\r\n\t            return icon._width;\r\n\t        });\r\n\t\r\n\t        var totalLength = zrUtil.reduce(arrLength, function(previousValue,currentValue) {\r\n\t            return previousValue + currentValue + 10;\r\n\t        }, 0 );\r\n\t\r\n\t        zrUtil.each(connector.icons, function(icon, index) {\r\n\t            var connectorPosition = 0;\r\n\t            for (var k = 0; k < index; k++) {\r\n\t                connectorPosition += arrLength[k] + 10;\r\n\t            }\r\n\t            icon.attr(\"position\", [posX + connectorPosition - totalLength / 2, posY + 5]);\r\n\t            icon.show();\r\n\t            icon.attachLine = connector;\r\n\t        })\r\n\t    }\r\n\t\r\n\t    LineOperationManager.prototype.hideAllLineOperation = function() {\r\n\t        zrUtil.each(this.lineOperations, function(lineOperation) {\r\n\t            lineOperation.hide();\r\n\t        });\r\n\t    }\r\n\t\r\n\t    LineOperationManager.prototype.addDeleteIcon = function(lineNode,options) {\r\n\t        var opts = zrUtil.defaults({\r\n\t            iconPath: 'path://' + icon.DEL_SVG,\r\n\t            width: 12,\r\n\t            height: 14,\r\n\t            lineNode: lineNode,\r\n\t            callback: function(e) {\r\n\t                this._api.remove(e.target.attachLine);//this.connectionManager.selConnector);\r\n\t            }.bind(this)\r\n\t        }, options,true);\r\n\t\r\n\t        this.addIcon(\"delete\", opts);\r\n\t    }\r\n\t\r\n\t    LineOperationManager.prototype.addChangeLineTypeIcon = function(lineNode,options) {\r\n\t        var opts = zrUtil.defaults({\r\n\t            iconPath: 'path://' + icon.CHANGE_LINE_TYPE_SVG,\r\n\t            width: 15,\r\n\t            height: 15,\r\n\t            lineNode: lineNode,\r\n\t            callback: function () {\r\n\t                this._api.changeSelectConnectorType();\r\n\t            }.bind(this)\r\n\t        }, options,true);\r\n\t\r\n\t        this.addIcon(\"change\", opts)\r\n\t    }\r\n\t\r\n\t    module.exports = LineOperationManager;\r\n\t\r\n\n\n/***/ }),\n/* 124 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\r\n\t * fishTopoFlow的layout对象，框架提供的布局都放在这个对象下。通过addCustomLayout方法添加自定义布局\r\n\t * @class fishTopoFlow.layout\r\n\t * @abstract\r\n\t */\r\n\t\r\n\t    var BoundingRect = __webpack_require__(27);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var flowUtil = __webpack_require__(94);\r\n\t    var HLayout = __webpack_require__(125);\r\n\t    var VLayout = __webpack_require__(126);\r\n\t    var TreeLayout = __webpack_require__(127);\r\n\t    var ForceLayout = __webpack_require__(130);\r\n\t    var parsePercent = flowUtil.parsePercent;\r\n\t    var Tree = __webpack_require__(128);\r\n\t    var layout = {};\r\n\t    layout.HLayout = HLayout;\r\n\t    layout.VLayout = VLayout;\r\n\t    layout.TreeLayout = TreeLayout;\r\n\t    layout.ForceLayout = ForceLayout;\r\n\t    layout.Tree = Tree\r\n\t\r\n\t    /**\r\n\t     * @method addCustomLayout\r\n\t     * 添加自定义布局类\r\n\t     * @param {Object} customLayout 自定义布局的类\r\n\t     */\r\n\t    layout.addCustomLayout = function(customLayout) {\r\n\t        layout.customLayout = customLayout;\r\n\t    }\r\n\t\r\n\t\r\n\t    layout.getLayoutRect = function (positionInfo, containerRect, margin) {\r\n\t        margin = flowUtil.normalizeCssArray(margin || 0);\r\n\t\r\n\t        var containerWidth = containerRect.width;\r\n\t        var containerHeight = containerRect.height;\r\n\t\r\n\t        var left = parsePercent(positionInfo.left, containerWidth);\r\n\t        var top = parsePercent(positionInfo.top, containerHeight);\r\n\t        var right = parsePercent(positionInfo.right, containerWidth);\r\n\t        var bottom = parsePercent(positionInfo.bottom, containerHeight);\r\n\t        var width = parsePercent(positionInfo.width, containerWidth);\r\n\t        var height = parsePercent(positionInfo.height, containerHeight);\r\n\t\r\n\t        var verticalMargin = margin[2] + margin[0];\r\n\t        var horizontalMargin = margin[1] + margin[3];\r\n\t        var aspect = positionInfo.aspect;\r\n\t\r\n\t        // If width is not specified, calculate width from left and right\r\n\t        if (isNaN(width)) {\r\n\t            width = containerWidth - right - horizontalMargin - left;\r\n\t        }\r\n\t        if (isNaN(height)) {\r\n\t            height = containerHeight - bottom - verticalMargin - top;\r\n\t        }\r\n\t\r\n\t        // If width and height are not given\r\n\t        // 1. Graph should not exceeds the container\r\n\t        // 2. Aspect must be keeped\r\n\t        // 3. Graph should take the space as more as possible\r\n\t        if (isNaN(width) && isNaN(height)) {\r\n\t            if (aspect > containerWidth / containerHeight) {\r\n\t                width = containerWidth * 0.8;\r\n\t            }\r\n\t            else {\r\n\t                height = containerHeight * 0.8;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        if (aspect != null) {\r\n\t            // Calculate width or height with given aspect\r\n\t            if (isNaN(width)) {\r\n\t                width = aspect * height;\r\n\t            }\r\n\t            if (isNaN(height)) {\r\n\t                height = width / aspect;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        // If left is not specified, calculate left from right and width\r\n\t        if (isNaN(left)) {\r\n\t            left = containerWidth - right - width - horizontalMargin;\r\n\t        }\r\n\t        if (isNaN(top)) {\r\n\t            top = containerHeight - bottom - height - verticalMargin;\r\n\t        }\r\n\t\r\n\t        // Align left and top\r\n\t        switch (positionInfo.left || positionInfo.right) {\r\n\t            case 'center':\r\n\t                left = containerWidth / 2 - width / 2 - margin[3];\r\n\t                break;\r\n\t            case 'right':\r\n\t                left = containerWidth - width - horizontalMargin;\r\n\t                break;\r\n\t        }\r\n\t        switch (positionInfo.top || positionInfo.bottom) {\r\n\t            case 'middle':\r\n\t            case 'center':\r\n\t                top = containerHeight / 2 - height / 2 - margin[0];\r\n\t                break;\r\n\t            case 'bottom':\r\n\t                top = containerHeight - height - verticalMargin;\r\n\t                break;\r\n\t        }\r\n\t        // If something is wrong and left, top, width, height are calculated as NaN\r\n\t        left = left || 0;\r\n\t        top = top || 0;\r\n\t        if (isNaN(width)) {\r\n\t            // Width may be NaN if only one value is given except width\r\n\t            width = containerWidth - left - (right || 0);\r\n\t        }\r\n\t        if (isNaN(height)) {\r\n\t            // Height may be NaN if only one value is given except height\r\n\t            height = containerHeight - top - (bottom || 0);\r\n\t        }\r\n\t\r\n\t        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\r\n\t        rect.margin = margin;\r\n\t        return rect;\r\n\t    };\r\n\t\r\n\t\r\n\t    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {\r\n\t        var h = !opt || !opt.hv || opt.hv[0];\r\n\t        var v = !opt || !opt.hv || opt.hv[1];\r\n\t        var boundingMode = opt && opt.boundingMode || 'all';\r\n\t\r\n\t        if (!h && !v) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var rect;\r\n\t        if (boundingMode === 'raw') {\r\n\t            rect = (el.type === 'group' || el.type === 'GroupNode')\r\n\t                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)\r\n\t                : el.getBoundingRect();\r\n\t        }\r\n\t        else {\r\n\t            rect = el.getBoundingRect();\r\n\t            if (el.needLocalTransform()) {\r\n\t                var transform = el.getLocalTransform();\r\n\t                // Notice: raw rect may be inner object of el,\r\n\t                // which should not be modified.\r\n\t                rect = rect.clone();\r\n\t                rect.applyTransform(transform);\r\n\t            }\r\n\t        }\r\n\t\r\n\t        positionInfo = layout.getLayoutRect(\r\n\t            zrUtil.defaults(\r\n\t                {width: rect.width, height: rect.height},\r\n\t                positionInfo\r\n\t            ),\r\n\t            containerRect,\r\n\t            margin\r\n\t        );\r\n\t\r\n\t        // Because 'tranlate' is the last step in transform\r\n\t        // (see zrender/core/Transformable#getLocalTransfrom),\r\n\t        // we can just only modify el.position to get final result.\r\n\t        var elPos = el.position;\r\n\t        var dx = h ? positionInfo.x - rect.x : 0;\r\n\t        var dy = v ? positionInfo.y - rect.y : 0;\r\n\t\r\n\t        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\r\n\t    };\r\n\t\r\n\t\r\n\t    module.exports = layout;\r\n\n\n/***/ }),\n/* 125 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 水平布局<br>\r\n\t * @class fishTopoFlow.layout.HLayout\r\n\t * @extends fishTopoFlow.layout\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var layout = fishTopoFlow.layout;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       function newNode(group,text) {\r\n\t *           var rect = new node.Rect({\r\n\t *                   shape:{width:25,height:25},\r\n\t *                   style: {text:text,fill: \"#167CFF\"}\r\n\t *               });\r\n\t *           group.add(rect);\r\n\t *           return rect;\r\n\t *       }\r\n\t *       var hGroup =  new node.Group({\r\n\t *           style: {\r\n\t *               text: \"水平布局\",\r\n\t *               textPosition:\"bottom\"\r\n\t *           },\r\n\t *           position:[50,50],\r\n\t *           layout : new layout.HLayout({gap:10})\r\n\t *       });\r\n\t *       newNode(hGroup, \"A_1\")\r\n\t *       newNode(hGroup, \"A_2\");\r\n\t *       newNode(hGroup, \"A_3\");\r\n\t *       newNode(hGroup, \"A_4\");\r\n\t *       newNode(hGroup, \"A_5\");\r\n\t *       fishTopo.add(hGroup);\r\n\t */\r\n\t\r\n\t            var zrUtil = __webpack_require__(5);\r\n\t             var Connector = __webpack_require__(82);\r\n\t            function HLayout(opts) {\r\n\t                /**\r\n\t                 * @cfg {Number} gap 节点之间的间隔\r\n\t                 */\r\n\t                /**\r\n\t                 * @cfg {Number} maxHeight=Infinity 组最大的宽度，如果超过会换行\r\n\t                 */\r\n\t                var defaultOptions = {\r\n\t                    gap: 5,\r\n\t                    maxWidth: Infinity\r\n\t                };\r\n\t                this.options = zrUtil.merge(defaultOptions, opts, true);\r\n\t            }\r\n\t            /**\r\n\t             * @method run\r\n\t             * 进行垂直布局，一般不需要调用，直接将布局类 赋值给组layout 属性即可\r\n\t             * @param {Object} group 需要进行垂直布局的组\r\n\t             */\r\n\t            HLayout.prototype.run = function(group)  {\r\n\t                var x = 0;\r\n\t                var y = 0;\r\n\t                var currentLineMaxSize = 0;\r\n\t                group.each(function (child, idx) {\r\n\t                    if (child instanceof Connector) {\r\n\t                        return;\r\n\t                    }\r\n\t\r\n\t                    var position = child.position;\r\n\t                    var rect = child.getBoundingRect();\r\n\t                    var nextChild = group.childAt(idx + 1);\r\n\t                    var nextChildRect = nextChild && nextChild.getBoundingRect();\r\n\t                    var nextX;\r\n\t\r\n\t                    var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\r\n\t                    nextX = x + moveX;\r\n\t                    // Wrap when width exceeds maxWidth or meet a `newline` group\r\n\t                    if (nextX > this.options.maxWidth || child.newline) {\r\n\t                        x = 0;\r\n\t                        nextX = moveX;\r\n\t                        y += currentLineMaxSize + parseInt(this.options.gap,10);\r\n\t                        currentLineMaxSize = rect.height;\r\n\t                    } else {\r\n\t                        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\r\n\t                    }\r\n\t\r\n\t                    if (child.newline) {\r\n\t                        return;\r\n\t                    }\r\n\t\r\n\t                    position[0] = x;\r\n\t                    position[1] = y;\r\n\t                    x = nextX + this.options.gap;\r\n\t                },this);\r\n\t\r\n\t                return HLayout;\r\n\t            }\r\n\t        module.exports = HLayout;\r\n\t\r\n\t/**\r\n\t * @method addCustomLayout\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 126 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 垂直布局<br>\r\n\t * @class fishTopoFlow.layout.VLayout\r\n\t * @extends fishTopoFlow.layout\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var layout = fishTopoFlow.layout;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       function newNode(group,text) {\r\n\t *           var rect = new node.Rect({\r\n\t *                   shape:{width:25,height:25},\r\n\t *                   style: {text:text,fill: \"#167CFF\"}\r\n\t *               });\r\n\t *           group.add(rect);\r\n\t *           return rect;\r\n\t *       }\r\n\t *       var vGroup =  new node.Group({\r\n\t *           style: {\r\n\t *               text: \"垂直布局\",\r\n\t *               textPosition:\"bottom\"\r\n\t *           },\r\n\t *           position:[60,60],\r\n\t *           layout : new layout.VLayout({gap:10})\r\n\t *       });\r\n\t*\r\n\t *       newNode(vGroup, \"A_1\")\r\n\t *       newNode(vGroup, \"A_2\");\r\n\t *       newNode(vGroup, \"A_3\");\r\n\t *       newNode(vGroup, \"A_4\");\r\n\t *       newNode(vGroup, \"A_5\");\r\n\t *       fishTopo.add(vGroup);\r\n\t */\r\n\t\r\n\t            var zrUtil = __webpack_require__(5);\r\n\t            var Connector = __webpack_require__(82);\r\n\t            function VLayout(opts) {\r\n\t                /**\r\n\t                 * @cfg {Number} gap 节点之间的间隔\r\n\t                 */\r\n\t                /**\r\n\t                 * @cfg {Number} maxHeight=Infinity 组最大的高度，如果超过会换行\r\n\t                 */\r\n\t                var defaultOptions = {\r\n\t                    gap: 5,\r\n\t                    maxHeight: Infinity\r\n\t                };\r\n\t                this.options = zrUtil.merge(defaultOptions, opts, true);\r\n\t            }\r\n\t\r\n\t            /**\r\n\t             * @method run\r\n\t             * 进行垂直布局，一般不需要调用，直接将布局类 赋值给组layout 属性即可\r\n\t             * @param {Object} group 需要进行垂直布局的组\r\n\t             */\r\n\t            VLayout.prototype.run = function(group)  {\r\n\t                var x = 0;\r\n\t                var y = 0;\r\n\t                var currentLineMaxSize = 0;\r\n\t                group.each(function (child, idx) {\r\n\t                    if (child instanceof Connector) {\r\n\t                        return;\r\n\t                    }\r\n\t\r\n\t                    var position = child.position;\r\n\t                    var rect = child.getBoundingRect();\r\n\t                    var nextChild = group.childAt(idx + 1);\r\n\t                    var nextChildRect = nextChild && nextChild.getBoundingRect();\r\n\t                    var nextY;\r\n\t\r\n\t                    var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\r\n\t                    nextY = y + moveY;\r\n\t                    // Wrap when width exceeds maxHeight or meet a `newline` group\r\n\t                    if (nextY > this.options.maxHeight || child.newline) {\r\n\t                        x += currentLineMaxSize + parseInt(this.options.gap,10);\r\n\t                        y = 0;\r\n\t                        nextY = moveY;\r\n\t                        currentLineMaxSize = rect.width;\r\n\t                    }\r\n\t                    else {\r\n\t                        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\r\n\t                    }\r\n\t\r\n\t                    if (child.newline) {\r\n\t                        return;\r\n\t                    }\r\n\t\r\n\t                    position[0] = x;\r\n\t                    position[1] = y;\r\n\t                    y = nextY + this.options.gap;\r\n\t                },this);\r\n\t\r\n\t                return VLayout;\r\n\t            }\r\n\t        module.exports = VLayout;\r\n\t\r\n\t\r\n\t/**\r\n\t * @method addCustomLayout\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 127 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 树布局<br>\r\n\t * @class fishTopoFlow.layout.TreeLayout\r\n\t * @extends fishTopoFlow.layout\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var layout = fishTopoFlow.layout;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n\t *       function newNode(data) {\r\n\t *           var circle = new node.Circle({\r\n\t *               shape: { r: 15 },\r\n\t *               style: { fill: \"#4883b4\" },\r\n\t *               name: data.name\r\n\t *           });\r\n\t *           return circle;\r\n\t *       }\r\n\t *       var options = {\r\n\t *           createNodeFunction: newNode,\r\n\t *           data:[{\r\n\t *               name: '根节点',\r\n\t *               children: [\r\n\t *                   {   name: '节点1',\r\n\t *                       children: [\r\n\t *                           {name: '叶子节点1'},\r\n\t *                           {name: '叶子节点2'},\r\n\t *                           {name: '叶子节点3'},\r\n\t *                           {name: '叶子节点4'},\r\n\t *                           {name: '叶子节点5'},\r\n\t *                           {name: '叶子节点6'}\r\n\t *                       ]\r\n\t *                   },\r\n\t *                   {   name: '节点2',\r\n\t *                       children: [\r\n\t *                           {name: '叶子节点7'},\r\n\t *                           {name: '叶子节点8'}]\r\n\t *                   },\r\n\t *                   {   name: '节点3',\r\n\t *                       children: [\r\n\t *                           {name: '叶子节点9'},\r\n\t *                           {name: '叶子节点10'},\r\n\t *                           {name: '叶子节点11'},\r\n\t *                           {name: '叶子节点12'}\r\n\t *                       ]\r\n\t *                   }\r\n\t *               ]\r\n\t *           }]\r\n\t *       }\r\n\t*\r\n\t *       var treeLayout = new layout.TreeLayout({\r\n\t *           fishTopo:fishTopo,\r\n\t *           rootLocation:{x:'center', y:50},\r\n\t *           nodePadding:1\r\n\t *       });\r\n\t *       treeLayout.doLayout(options);\r\n\t */\r\n\t\r\n\t            var zrUtil = __webpack_require__(5);\r\n\t            var BoundingRect = __webpack_require__(27);\r\n\t            var flowUtil = __webpack_require__(94);\r\n\t            var parsePercent = flowUtil.parsePercent;\r\n\t            var TreeData = __webpack_require__(128);  // 数据依赖\r\n\t            var TreeHelper = __webpack_require__(129); // 布局依赖\r\n\t            function TreeLayout(opts) {\r\n\t                /**\r\n\t                 * @cfg {Object} fishTopo fishTopo实例\r\n\t                 */\r\n\t                /**\r\n\t                 * @cfg {Object} rootLocation 根节点坐标，支持绝对值（px）、字符和百分比 'center' | 'left' | 'right' | 'x%' | number\r\n\t                 * @cfg {Number|String} rootLocation.x  根节点横坐标，支持绝对值（px）、字符和百分比 'center' | 'left' | 'right' | 'x%' | number\r\n\t                 * @cfg {Number|String} rootLocation.y  根节点纵坐标，支持绝对值（px）、字符和百分比 'center' | 'left' | 'right' | 'x%' | number\r\n\t                 */\r\n\t                /**\r\n\t                 * @cfg {Number} layerPadding=100 层间距,默认:100\r\n\t                 */\r\n\t                /**\r\n\t                 * @cfg {Number} nodePadding=30 节点间距,默认:30\r\n\t                 */\r\n\t                /**\r\n\t                 *@cfg {String} direction 树的方向可选：'vertical' | 'horizontal' ,默认:vertical\r\n\t                 */\r\n\t                /**\r\n\t                 * @cfg {Object} lineStyle 连线的样式  参见{@link fishTopoFlow.link#constructor 构造函数options参数}\r\n\t                 */\r\n\t                var defaultOptions = {\r\n\t                    orient:'vertical',  // vertical,horizontal\r\n\t                    nodePadding:30, //节点间距\r\n\t                    layerPadding:100,  //层间距\r\n\t                    rootLocation: {x:100, y:230}, // 根节点坐标，支持绝对值（px）、字符和百分比\r\n\t                    animateTime : 500,\r\n\t                    lineStyle: {pos:'bottom,top', symbol:{type:'none'}}\r\n\t                };\r\n\t                if (opts.orient === 'horizontal') {\r\n\t                    defaultOptions.lineStyle.pos = 'right,left';\r\n\t                }\r\n\t\r\n\t                this.options = zrUtil.defaults(defaultOptions, opts, true);\r\n\t                this.nodePadding = this.options.nodePadding;\r\n\t                this.layerPadding = this.options.layerPadding;\r\n\t                this.fishTopo = this.options.fishTopo;\r\n\t                this._layerOffsets = [];\r\n\t                this._layers = [];\r\n\t                this._hideNodes = [];\r\n\t            }\r\n\t\r\n\t            /**\r\n\t             * @method layoutByRootNode\r\n\t             * 根据根节点及连线的关系 ，生成树\r\n\t             * @param {Object} rootNode 树的根节点\r\n\t             * @return {Object} boundingbox 包围和\r\n\t             */\r\n\t            TreeLayout.prototype.layoutByRootNode = function(rootNode) {\r\n\t                var connectors = this.fishTopo.connectionManager.connectors;  //所有线段的数组\r\n\t                //递归生成树型数据结构\r\n\t                function traverseNode(parentNode, treeData) {\r\n\t                    var childrenData = [];\r\n\t                    var childrenNode = [];\r\n\t                    //1.根据连线，找出起始节点的所有子节点\r\n\t                    zrUtil.each(connectors, function(connector) {\r\n\t                        if(connector.startNode === parentNode) {\r\n\t                            if(!connector.endNode.exclude) {   //如果是排斥的节点则不加入\r\n\t                                childrenNode.push(connector.endNode);\r\n\t                            }\r\n\t                        }\r\n\t                    })\r\n\t\r\n\t                    if (childrenNode.length > 0) {\r\n\t                        //2.遍历子节点\r\n\t                        zrUtil.each(childrenNode, function(node) {\r\n\t                             var nodeData = {name: node.id, node:node};\r\n\t                             childrenData.push(nodeData);\r\n\t                             traverseNode(node, nodeData);\r\n\t                        })\r\n\t                    }\r\n\t                    //3.将子节点放入children中\r\n\t                    if (childrenData.length > 0) {\r\n\t                        treeData.children = childrenData;\r\n\t                    }\r\n\t                }\r\n\t                var rootTreeData = {name: rootNode.id, node:rootNode};\r\n\t                traverseNode(rootNode,rootTreeData);\r\n\t                return this.doLayout({data:[rootTreeData]}, true);\r\n\t            }\r\n\t\r\n\t            /**\r\n\t             * @method doLayout\r\n\t             * 根据传过来树型结构数据进行树布局\r\n\t             * @param {Object} treeData 树形数据\r\n\t             * @param {Function} treeData.createNodeFunction=null 创建节点的函数 会把data中的数据 传递过去  如果没有默认就是创建圆形\r\n\t             * @param {Object} treeData.data 创建树布局数据（必须包括name属性）\r\n\t             * @param {boolean} isNotBuildLink=true 默认是自动创建连线，传true则不会自动创建连线\r\n\t             * @return {Object} boundingbox 包围和\r\n\t             */\r\n\t            TreeLayout.prototype.doLayout = function(treeData, isNotBuildLink)  {\r\n\t                var rootData = treeData.data[0];\r\n\t                this.treeData = treeData;\r\n\t\r\n\t                this.tree = TreeData.fromOptionData(rootData.name, rootData.children);\r\n\t                this.tree.root.data = rootData;\r\n\t\r\n\t\r\n\t                this._buildNode(treeData);\r\n\t\r\n\t                //根据root坐标 方向 对每个节点的坐标进行映射\r\n\t                this._setTreeShape(function() {\r\n\t                    this._buildAllLink(isNotBuildLink);\r\n\t                }.bind(this));\r\n\t\r\n\t                return this.getBoundingRect();\r\n\t            }\r\n\t\r\n\t            /**\r\n\t             * @private\r\n\t             * @method _buildAllLink\r\n\t             * 递归画出连接线 与设置节点坐标\r\n\t             */\r\n\t             TreeLayout.prototype._buildAllLink = function (isNotBuildLink) {\r\n\t                this.tree.traverse(function(treeNode) {\r\n\t                    //画连接线\r\n\t                    if (treeNode.children.length > 0 && !isNotBuildLink) {\r\n\t                        this._buildLinkByParent(treeNode, this.treeData.createLinkFunction)\r\n\t                    } else {\r\n\t                        this.fishTopo.connectionManager.refreshLineByNode(treeNode.data.node);\r\n\t                    }\r\n\t                },this)\r\n\t             }\r\n\t\r\n\t\r\n\t            /**\r\n\t             * @method getBoundingRect\r\n\t             * 计算出树的包围和\r\n\t             * @return {Object} boundingbox 包围和\r\n\t             */\r\n\t            TreeLayout.prototype.getBoundingRect = function() {\r\n\t                var rect = null;\r\n\t                this.tree.traverse(function(treeNode) {\r\n\t                    var childRect = BoundingRect.create({x:treeNode.layout.position[0], y:treeNode.layout.position[1], width:treeNode.layout.width, height: treeNode.layout.height});\r\n\t                    if (!rect) rect = childRect.clone();\r\n\t                    rect.union(childRect);\r\n\t                },this)\r\n\t                return rect;\r\n\t            }\r\n\t\r\n\t\r\n\t\r\n\t            TreeLayout.prototype._setTreeShape = function(doneCallback) {\r\n\t                var animateCount = 0;\r\n\t                var treeHelper = new TreeHelper(\r\n\t                    {\r\n\t                        nodePadding: this.nodePadding,\r\n\t                        layerPadding: this.layerPadding\r\n\t                    }\r\n\t                );\r\n\t\r\n\t\r\n\t                this.tree.traverse(function(treeNode) {\r\n\t                    if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){\r\n\t                        var boundingRect = treeNode.data.node.getBoundingRect();\r\n\t                        treeNode.layout = {\r\n\t                            width: treeNode.data.node._width || boundingRect.width,\r\n\t                            height: treeNode.data.node._height || boundingRect.height\r\n\t                        }\r\n\t                    }\r\n\t\r\n\t                },this);\r\n\t                treeHelper._hideNodes = this._hideNodes;\r\n\t                treeHelper.run(this.tree);\r\n\t                // 树的方向\r\n\t                var orient = this.options.orient;\r\n\t                var rootX = this.options.rootLocation.x;\r\n\t                var rootY = this.options.rootLocation.y;\r\n\t                var zrWidth = this.fishTopo.getWidth();\r\n\t                var zrHeight = this.fishTopo.getHeight();\r\n\t                if (rootX === 'center') {\r\n\t                    rootX = zrWidth * 0.5;\r\n\t                }\r\n\t                else {\r\n\t                    rootX = parsePercent(rootX, zrWidth);\r\n\t                }\r\n\t                if (rootY === 'center') {\r\n\t                    rootY = zrHeight * 0.5;\r\n\t                }\r\n\t                else {\r\n\t                    rootY = parsePercent(rootY, zrHeight);\r\n\t                }\r\n\t                rootY = parsePercent(rootY, zrHeight);\r\n\t                // 水平树\r\n\t                if (orient === 'horizontal') {\r\n\t                    rootX = isNaN(rootX) ? 10 : rootX;\r\n\t                    rootY = isNaN(rootY) ? zrHeight * 0.5 : rootY;\r\n\t                }\r\n\t                // 纵向树\r\n\t                else {\r\n\t                    rootX = isNaN(rootX) ? zrWidth * 0.5 : rootX;\r\n\t                    rootY = isNaN(rootY) ? 10 : rootY;\r\n\t                }\r\n\t                // tree layout自动算出来的root的坐标\r\n\t                var originRootX = this.tree.root.layout.position[0];\r\n\t\r\n\t                var treeNodeCount = treeHelper.count(this.tree) - this._hideNodes.length;\r\n\t                var minY = Infinity;\r\n\t\r\n\t                this.tree.traverse(\r\n\t                    function (treeNode) {\r\n\t                        var x;\r\n\t                        var y;\r\n\t                        if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){\r\n\t                            if (orient === 'vertical' && this.options.direction === 'inverse') {\r\n\t                                x = treeNode.layout.position[0] - originRootX + rootX;\r\n\t                                y = rootY - treeNode.layout.position[1];\r\n\t                            }\r\n\t                            else if (orient === 'vertical') {\r\n\t                                x = treeNode.layout.position[0] - originRootX + rootX;\r\n\t                                y = treeNode.layout.position[1] + rootY;\r\n\t                            }\r\n\t                            else if (orient === 'horizontal' && this.options.direction === 'inverse') {\r\n\t                                y = treeNode.layout.position[0] - originRootX + rootY;\r\n\t                                x = rootX - treeNode.layout.position[1];\r\n\t                            }\r\n\t                            else if (orient === 'horizontal') {\r\n\t                                y = treeNode.layout.position[0] - originRootX + rootY;\r\n\t                                x = treeNode.layout.position[1] + rootX;\r\n\t                            }\r\n\t                            treeNode.layout.__x = x;\r\n\t                            treeNode.layout.__y = y;\r\n\t                            if (y < minY) {\r\n\t                                minY = y;\r\n\t                            }\r\n\t                        }\r\n\t                    },\r\n\t                    this\r\n\t                );\r\n\t\r\n\t                this.tree.traverse(function (treeNode) {\r\n\t                    if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){\r\n\t                        if (minY > 0) {\r\n\t                            treeNode.layout.position[0] = treeNode.layout.__x;\r\n\t                            treeNode.layout.position[1] = treeNode.layout.__y;\r\n\t                        } else  {\r\n\t                            treeNode.layout.position[0] = treeNode.layout.__x;\r\n\t                            treeNode.layout.position[1] = treeNode.layout.__y - minY;\r\n\t                        }\r\n\t\r\n\t                        treeNode.data.node.animateTo({\r\n\t                            position: [treeNode.layout.position[0], treeNode.layout.position[1]]\r\n\t                        }, this.options.animateTime, function() {\r\n\t                            if (++animateCount === treeNodeCount) {\r\n\t                                doneCallback();\r\n\t                            }\r\n\t                        }.bind(this));\r\n\t                        //节点有孩子才显示 收缩按钮\r\n\t                        if(this._hideNodes.length == 0){\r\n\t                            if (treeNode.children.length > 0 && treeNode.data.node._toggleShrink) {\r\n\t                                treeNode.data.node._toggleShrink(true);\r\n\t                            }\r\n\t                        }\r\n\t                    }\r\n\t\r\n\t                },this)\r\n\t            }\r\n\t\r\n\t            TreeLayout.prototype._buildNode = function(treeData) {\r\n\t                if(!treeData.createNodeFunction) {\r\n\t                    treeData.createNodeFunction = this._defaultCreateNodeFunction;\r\n\t                }\r\n\t                //判断一下是否有node 如果没有则自己创建\r\n\t                this.tree.traverse(function(treeNode) {\r\n\t                    if(!treeNode.data.node) {\r\n\t                        var createNodeFunction = treeNode.data.createNodeFunction || treeData.createNodeFunction;\r\n\t                        var node = createNodeFunction(treeNode.data, this);\r\n\t                        node._childShow = true;\r\n\t                        this.fishTopo.add(node);\r\n\t                        treeNode.data.node = node;\r\n\t                    }\r\n\t                },this);\r\n\t            }\r\n\t\r\n\t            TreeLayout.prototype._defaultCreateNodeFunction = function(item) {\r\n\t                var circle = this.fishTopo.createNode(\"Circle\",{\r\n\t                    shape: { r: 15 },\r\n\t                    style: { fill: \"#4883b4\" },\r\n\t                    name: item.lable || item.name\r\n\t                });\r\n\t                return circle;\r\n\t            }\r\n\t\r\n\t            TreeLayout.prototype._buildLinkByParent = function (parentTreeNode, createLinkFunction) {\r\n\t                for (var i = 0, childLength = parentTreeNode.children.length; i < childLength; i++) {\r\n\t                    this._buildLink(parentTreeNode, parentTreeNode.children[i], createLinkFunction);\r\n\t                }\r\n\t            };\r\n\t\r\n\t\r\n\t            TreeLayout.prototype._buildLink = function (startTreeNode, endTreeNode, createLinkFunction) {\r\n\t                    var connector = null;\r\n\t                    var startNode = startTreeNode.data.node;\r\n\t                    var endNode = endTreeNode.data.node;\r\n\t                    if(createLinkFunction) {\r\n\t                        var paramObj =  endTreeNode.data;\r\n\t                        paramObj.startNode = startNode;\r\n\t                        paramObj.endNode = endNode;\r\n\t                        connector = createLinkFunction(paramObj);\r\n\t                    } else {\r\n\t                        var linkStyle = this.options.lineStyle;\r\n\t                        if (endTreeNode.data.lineStyle) {\r\n\t                            linkStyle = zrUtil.merge(zrUtil.clone(linkStyle), endTreeNode.data.lineStyle, true);\r\n\t                        }\r\n\t                        connector = this.fishTopo.createLink(startNode,endNode,linkStyle)\r\n\t                    }\r\n\t                    this.fishTopo.add(connector);\r\n\t            };\r\n\t\r\n\t            /**\r\n\t             * @method addChild\r\n\t             * 在指定topo节点下新增一个子节点\r\n\t             * @param {Object} treeNode 要增加子节点的topo节点\r\n\t             * @param {Object} data 新增子节点的数据\r\n\t             * @param {Function} callback 增加完子节点之后触发的回调函数\r\n\t             * @return {Object} 新增加的子节点\r\n\t             */\r\n\t            TreeLayout.prototype.addChild = function (treeNode, data, callback) {\r\n\t                var newTreeNode = (new TreeData(data.name)).root;\r\n\t                newTreeNode.data = data;\r\n\t\r\n\t                var node = this.treeData.createNodeFunction(newTreeNode.data, this);\r\n\t                node._childShow = true;\r\n\t                if (treeNode.children.length >= 1) {\r\n\t                    node.attr('position', zrUtil.clone(treeNode.children[treeNode.children.length - 1].layout.position));\r\n\t                } else {\r\n\t                    node.attr('position', zrUtil.clone(treeNode.layout.position));\r\n\t                }\r\n\t\r\n\t                this.fishTopo.add(node);\r\n\t                newTreeNode.data.node = node;\r\n\t                setTimeout(function () {\r\n\t                    this._buildLink(treeNode, newTreeNode, this.treeData.createLinkFunction);\r\n\t                }.bind(this), this.options.animateTime);\r\n\t\r\n\t                treeNode.add(newTreeNode);\r\n\t                this.refreshPositionAndLine(callback);\r\n\t                return node;\r\n\t            };\r\n\t\r\n\t            /**\r\n\t             * @method toggleChild\r\n\t             * 展示或者隐藏选中topo节点下的子节点以及与子节点之间的连线\r\n\t             * @param {Object} node 树节点\r\n\t             */\r\n\t            TreeLayout.prototype.toggleChild = function (node) {\r\n\t                var toggleTreeNode = this.findTreeNodeByNode(node);\r\n\t                if (node._childShow) {\r\n\t                    toggleTreeNode.traverse(function (treeNode) {\r\n\t                        if (treeNode.data.node !== node) {\r\n\t                            treeNode.data.node.hide();\r\n\t                            if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){\r\n\t                                this._hideNodes.push(treeNode);\r\n\t                            }\r\n\t                            this.fishTopo.connectionManager.toggleLineByNode(treeNode.data.node, false);\r\n\t                            if (treeNode.children.length > 0) {\r\n\t                                treeNode.data.node._childShow = false;\r\n\t                                treeNode.data.node._toggleShrink && treeNode.data.node._toggleShrink(false);\r\n\t                            }\r\n\t                        }\r\n\t                    },this);\r\n\t                    node._childShow = false;\r\n\t                    node._toggleShrink && node._toggleShrink(false);\r\n\t                    this.refreshPositionAndLine();\r\n\t                } else {\r\n\t                    toggleTreeNode.traverse(function (treeNode) {\r\n\t                        if (treeNode.data.node !== node) {\r\n\t                            treeNode.data.node.show();\r\n\t                            this._hideNodes.splice(zrUtil.indexOf(this._hideNodes, treeNode),1);\r\n\t                            this.fishTopo.connectionManager.toggleLineByNode(treeNode.data.node, true);\r\n\t                            if (treeNode.children.length > 0) {\r\n\t                                treeNode.data.node._childShow = true;\r\n\t                                treeNode.data.node._toggleShrink && treeNode.data.node._toggleShrink(true);\r\n\t                            }\r\n\t                        }\r\n\t                    },this);\r\n\t                    node._childShow = true;\r\n\t                    node._toggleShrink && node._toggleShrink(true);\r\n\t                    this.refreshPositionAndLine();\r\n\t                }\r\n\t            };\r\n\t\r\n\t            /**\r\n\t             * @method findTreeNodeByNode\r\n\t             * 根据topo节点找到树的节点\r\n\t             * @param {Object} node topo节点\r\n\t             * @return {Object} \r\n\t             */\r\n\t            TreeLayout.prototype.findTreeNodeByNode = function (node) {\r\n\t                var returnTreeNode = null;\r\n\t                this.tree.traverse(function (treeNode) {\r\n\t                    if (treeNode.data.node === node) {\r\n\t                        returnTreeNode = treeNode;\r\n\t                    }\r\n\t                });\r\n\t                return returnTreeNode;\r\n\t            };\r\n\t\r\n\t            /**\r\n\t             * @method removeNode\r\n\t             * 删除选中topo节点\r\n\t             * @param {Object} node topo节点\r\n\t             * @return {Boolean} 删除是否成功\r\n\t             */\r\n\t            TreeLayout.prototype.removeNode = function (node) {\r\n\t                var treeNode = this.findTreeNodeByNode(node);\r\n\t                var parentTreeNode = treeNode.parent;\r\n\t                if (!parentTreeNode) return false;\r\n\t                //遍历 topo中删除自己及孩子节点\r\n\t                treeNode.traverse(function (eachTreeNode) {\r\n\t                    this.fishTopo.remove(eachTreeNode.data.node); //删除节点\r\n\t                },this)\r\n\t\r\n\t                parentTreeNode.remove(treeNode);\r\n\t\r\n\t                //判断一下父节点是不是没有了,如果没有的话,要把线与+-号给隐藏掉\r\n\t                if (parentTreeNode.children.length === 0) {\r\n\t                    parentTreeNode.data.node._hideToggle && parentTreeNode.data.node._hideToggle();\r\n\t                }\r\n\t\r\n\t                //重新生成数据\r\n\t                this.refreshPositionAndLine();\r\n\t                return true;\r\n\t            };\r\n\t\r\n\t            /**\r\n\t             * @method removeChildren\r\n\t             * 删除选中topo节点下的所有子节点\r\n\t             * @param {Object} node topo节点\r\n\t             * @return {Boolean} 删除是否成功\r\n\t             */\r\n\t            TreeLayout.prototype.removeChildren = function (node) {\r\n\t                var treeNode = this.findTreeNodeByNode(node);\r\n\t                //遍历 topo中删除孩子节点\r\n\t                treeNode.traverse(function (eachTreeNode) {\r\n\t                    if (eachTreeNode !== treeNode) {\r\n\t                        this.fishTopo.remove(eachTreeNode.data.node); //删除节点\r\n\t                    }\r\n\t                },this)\r\n\t\r\n\t                treeNode.removeAllChildren();\r\n\t                node._hideToggle && node._hideToggle(); //this._hidePath(node);\r\n\t\r\n\t                //重新生成数据\r\n\t                this.refreshPositionAndLine();\r\n\t                return true;\r\n\t            };\r\n\t\r\n\t            /**\r\n\t             * @method refreshPositionAndLine\r\n\t             * 刷新当前树布局中所有节点的位置和节点之间的连线\r\n\t             * @param {Function} callback 刷新之后所触发的回调函数\r\n\t             */\r\n\t            TreeLayout.prototype.refreshPositionAndLine = function (callback) {\r\n\t                this.tree.root.updateDepthAndHeight(0);\r\n\t                this._setTreeShape(function () {\r\n\t                    this.tree.traverse(function (eachTreeNode) {\r\n\t                        this.fishTopo.connectionManager.refreshLineByNode(eachTreeNode.data.node);\r\n\t                    }, this);\r\n\t                    callback && callback();\r\n\t                }.bind(this));\r\n\t            }\r\n\t\r\n\t            /**\r\n\t             * @method changePosition\r\n\t             * 更改当前topo节点在其兄弟节点中的位置\r\n\t             * @param {Object} node 树节点\r\n\t             * @param {String} direction 节点移动的方向，next表示往下移动，prev表示往上移动\r\n\t             */\r\n\t            TreeLayout.prototype.changePosition = function (node, direction) {\r\n\t                var parentNode = node.parent;\r\n\t                var nowIndex = zrUtil.indexOf(parentNode.children, node);\r\n\t                var targetIndex;\r\n\t                if(direction == \"next\"){\r\n\t                    targetIndex = nowIndex + 1;\r\n\t                }else if(direction == \"prev\"){\r\n\t                    targetIndex = nowIndex - 1;\r\n\t                }\r\n\t                var targetNode = parentNode.children[targetIndex];\r\n\t                if(targetNode){\r\n\t                    var storage = targetNode;\r\n\t                    parentNode.children[targetIndex] = node;\r\n\t                    parentNode.children[nowIndex] = storage;\r\n\t                }\r\n\t                this.refreshPositionAndLine();\r\n\t                this.fishTopo.trigger('treeLayout:changePosition',{\r\n\t                    node:node,\r\n\t                    parentNode:parentNode,\r\n\t                    targetNode:targetNode\r\n\t                })\r\n\t            }\r\n\t\r\n\t        module.exports = TreeLayout;\r\n\t\r\n\t\r\n\t/**\r\n\t * @method addCustomLayout\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 128 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t\r\n\t    /**\r\n\t     * @constructor TreeNode\r\n\t     * @param {string} id Node ID\r\n\t     * @param {Object} [data]\r\n\t     */\r\n\t    function TreeNode(id, data) {\r\n\t        /**\r\n\t         * @type {string}\r\n\t         */\r\n\t        this.id = id;\r\n\t        /**\r\n\t         * 节点的深度\r\n\t         * @type {number}\r\n\t         */\r\n\t        this.depth = 0;\r\n\t        /**\r\n\t         * 以当前节点为根节点的子树的高度\r\n\t         * @type {number}\r\n\t         */\r\n\t        this.height = 0;\r\n\t        /**\r\n\t         * 子节点列表\r\n\t         * @type {Array.<TreeNode>}\r\n\t         */\r\n\t        this.children = [];\r\n\t\r\n\t        /**\r\n\t         * @type {TreeNode}\r\n\t         */\r\n\t        this.parent = null;\r\n\t\r\n\t        /**\r\n\t         * 存储的用户数据\r\n\t         * @type {Object}\r\n\t         */\r\n\t        this.data = data || null;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 添加子节点\r\n\t     * @param {TreeNode} child\r\n\t     */\r\n\t    TreeNode.prototype.add = function (child) {\r\n\t        var children = this.children;\r\n\t        if (child.parent === this) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        children.push(child);\r\n\t        child.parent = this;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 移除子节点\r\n\t     * @param {TreeNode} child\r\n\t     */\r\n\t    TreeNode.prototype.remove = function (child) {\r\n\t        var children = this.children;\r\n\t        var idx = zrUtil.indexOf(children, child);\r\n\t        if (idx >= 0) {\r\n\t            children.splice(idx, 1);\r\n\t            child.parent = null;\r\n\t        }\r\n\t    };\r\n\t\r\n\t     TreeNode.prototype.removeAllChildren = function () {\r\n\t         var children = this.children;\r\n\t         for (var i = 0; i < children.length; i++) {\r\n\t             var child = children[i];\r\n\t            child.parent = null;\r\n\t         }\r\n\t        this.children = [];\r\n\t     }\r\n\t\r\n\t    /**\r\n\t     * 遍历当前节点及其所有子节点\r\n\t     * @param  {Function} cb\r\n\t     * @param  {Object}   [context]\r\n\t     */\r\n\t    TreeNode.prototype.traverse = function (cb, context) {\r\n\t        cb.call(context, this);\r\n\t\r\n\t        for (var i = 0; i < this.children.length; i++) {\r\n\t            this.children[i].traverse(cb, context);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 遍历节前节点及所有子节点的数量\r\n\t     */\r\n\t    TreeNode.prototype.count = function () {\r\n\t        var count = 0;\r\n\t        this.traverse(function() {\r\n\t            count++;\r\n\t         });\r\n\t        return count;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 更新当前树及所有子树的高度和深度\r\n\t     * @param  {number} depth\r\n\t     */\r\n\t    TreeNode.prototype.updateDepthAndHeight = function (depth) {\r\n\t        var height = 0;\r\n\t        this.depth = depth;\r\n\t        for (var i = 0; i < this.children.length; i++) {\r\n\t            var child = this.children[i];\r\n\t            child.updateDepthAndHeight(depth + 1);\r\n\t            if (child.height > height) {\r\n\t                height = child.height;\r\n\t            }\r\n\t        }\r\n\t        this.height = height + 1;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @param  {string} id\r\n\t     * @return TreeNode\r\n\t     */\r\n\t    TreeNode.prototype.getNodeById = function (id) {\r\n\t        if (this.id === id) {\r\n\t            return this;\r\n\t        }\r\n\t        for (var i = 0; i < this.children.length; i++) {\r\n\t            var res = this.children[i].getNodeById(id);\r\n\t            if (res) {\r\n\t                return res;\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @constructor\r\n\t     * @alias module:echarts/data/Tree\r\n\t     * @param {string} id\r\n\t     */\r\n\t    function Tree(id) {\r\n\t        /**\r\n\t         * @type {TreeNode}\r\n\t         */\r\n\t        this.root = new TreeNode(id);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 遍历树的所有子节点(深度优先遍历)\r\n\t     * @param  {Function} cb\r\n\t     * @param  {Object}   [context]\r\n\t     */\r\n\t    Tree.prototype.traverse = function(cb, context) {\r\n\t        this.root.traverse(cb, context);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成子树\r\n\t     * @param  {string} id 子树根节点 id\r\n\t     * @return {module:echarts/data/Tree}\r\n\t     */\r\n\t    Tree.prototype.getSubTree = function(id) {\r\n\t        var root = this.getNodeById(id);\r\n\t        if (root) {\r\n\t            var tree = new Tree(root.id);\r\n\t            tree.root = root;\r\n\t            return tree;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @param  {string} id\r\n\t     * @return TreeNode\r\n\t     */\r\n\t    Tree.prototype.getNodeById = function (id) {\r\n\t        return this.root.getNodeById(id);\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 从 option 里的 data 数据构建树\r\n\t     * @param {string} id\r\n\t     * @param {Array.<Object>} data\r\n\t     * @return Tree\r\n\t     */\r\n\t    Tree.fromOptionData = function (id, data) {\r\n\t        var tree = new Tree(id);\r\n\t        var rootNode = tree.root;\r\n\t        // Root node\r\n\t        rootNode.data = {\r\n\t            name: id,\r\n\t            children: data\r\n\t        };\r\n\t\r\n\t        function buildHierarchy(dataNode, parentNode) {\r\n\t            var node = new TreeNode(dataNode.name, dataNode);\r\n\t            parentNode.add(node);\r\n\t            // 遍历添加子节点\r\n\t            var children = dataNode.children;\r\n\t            if (children) {\r\n\t                for (var i = 0; i < children.length; i++) {\r\n\t                    buildHierarchy(children[i], node);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        for (var i = 0; i < data.length; i++) {\r\n\t            buildHierarchy(data[i], rootNode);\r\n\t        }\r\n\t\r\n\t        tree.root.updateDepthAndHeight(0);\r\n\t\r\n\t        return tree;\r\n\t    };\r\n\t\r\n\t\r\n\t    Tree.fromDataSource = function (dataSource, rootItem) {\r\n\t\r\n\t        function _findChildItem(nodeName) {\r\n\t            return zrUtil.filter(dataSource.link,function(item){\r\n\t                if(item.from === nodeName && !item.pos) {  // 数据中有pos属性的不是子节点\r\n\t                    return item;\r\n\t                }\r\n\t            });\r\n\t        }\r\n\t\r\n\t\r\n\t        function buildHierarchy(root) {\r\n\t            var childItem = _findChildItem(root.id);\r\n\t            for (var i = 0; i < childItem.length; i++) {\r\n\t                var item = childItem[i];\r\n\t                var childTreeNode = treeNodesMap[item.to];\r\n\t                root.children.push(childTreeNode);\r\n\t                buildHierarchy(childTreeNode);\r\n\t            }\r\n\t        }\r\n\t\r\n\t        var treeNodesMap = {};\r\n\t        for (var i = 0; i < dataSource.node.length; i++) {\r\n\t            var node = dataSource.node[i];\r\n\t            var treeNode = new TreeNode(node.name,node);\r\n\t            treeNodesMap[node.name] = treeNode;\r\n\t        }\r\n\t\r\n\t        var tree = new Tree(rootItem.name);\r\n\t        var rootNode = tree.root;\r\n\t        // Root node\r\n\t        rootNode.data = rootItem;\r\n\t\r\n\t\r\n\t        buildHierarchy(tree.root);\r\n\t        tree.root.updateDepthAndHeight(0);\r\n\t\r\n\t        return tree;\r\n\t    };\r\n\t\r\n\t    module.exports = Tree;\r\n\n\n/***/ }),\n/* 129 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var vec2 = __webpack_require__(15);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t\r\n\t    function TreeHelper(opts) {\r\n\t        opts = opts || {};\r\n\t\r\n\t        this.nodePadding = opts.nodePadding || 30;\r\n\t\r\n\t        this.layerPadding = opts.layerPadding || 100;\r\n\t\r\n\t        this._layerOffsets = [];\r\n\t\r\n\t        this._layers = [];\r\n\t\r\n\t        this._hideNodes = [];\r\n\t    }\r\n\t\r\n\t    TreeHelper.prototype.count = function (tree) {\r\n\t        var count = 0;\r\n\t        tree.traverse(function() {\r\n\t            count++;\r\n\t         });\r\n\t        return count;\r\n\t    }\r\n\t\r\n\t    TreeHelper.prototype.run = function (tree) {\r\n\t        this._layerOffsets.length = 0;\r\n\t        for (var i = 0; i < tree.root.height + 1; i++) {\r\n\t            this._layerOffsets[i] = 0;\r\n\t            this._layers[i] = [];\r\n\t        }\r\n\t        this._updateNodeXPosition(tree.root);\r\n\t        var root = tree.root;\r\n\t        this._updateNodeYPosition(root, 0, root.layout.height);\r\n\t    };\r\n\t\r\n\t    TreeHelper.prototype._updateNodeXPosition = function (node) {\r\n\t        var minX = Infinity;\r\n\t        var maxX = -Infinity;\r\n\t        node.layout.position = node.layout.position || vec2.create();\r\n\t        for (var i = 0; i < node.children.length; i++) {\r\n\t            var child = node.children[i];\r\n\t            if(zrUtil.indexOf(this._hideNodes, child) == -1){\r\n\t                this._updateNodeXPosition(child);\r\n\t                var x = child.layout.position[0];\r\n\t                if (x < minX) {\r\n\t                    minX = x;\r\n\t                }\r\n\t                if (x > maxX) {\r\n\t                    maxX = x;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        if (node.children.length > 0 && (zrUtil.indexOf(this._hideNodes, node.children[0]) == -1)) {\r\n\t            node.layout.position[0] = (minX + maxX) / 2;\r\n\t        } else {\r\n\t            node.layout.position[0] = 0;\r\n\t            node.height = 0;   // 隐藏节点的 深度设为0\r\n\t        }\r\n\t        var off = this._layerOffsets[node.depth] || 0;\r\n\t        if (off > node.layout.position[0]) {\r\n\t            var shift = off - node.layout.position[0];\r\n\t            this._shiftSubtree(node, shift);\r\n\t            for (var j = node.depth + 1; j < node.height + node.depth; j++) {\r\n\t                this._layerOffsets[j] += shift;\r\n\t            }\r\n\t        }\r\n\t        this._layerOffsets[node.depth] = node.layout.position[0] + node.layout.width + this.nodePadding;\r\n\t\r\n\t        if(zrUtil.indexOf(this._layers[node.depth], node) == -1){\r\n\t            this._layers[node.depth].push(node);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    TreeHelper.prototype._shiftSubtree = function (root, offset) {\r\n\t        root.layout.position[0] += offset;\r\n\t        for (var i = 0; i < root.children.length; i++) {\r\n\t            if(zrUtil.indexOf(this._hideNodes,root.children[i]) == -1){\r\n\t                this._shiftSubtree(root.children[i], offset);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    TreeHelper.prototype._updateNodeYPosition = function (node, y, prevLayerHeight) {\r\n\t        if(zrUtil.indexOf(this._hideNodes,node) == -1){\r\n\t            node.layout.position[1] = y;\r\n\t            var layerHeight = 0;\r\n\t            for (var i = 0; i < node.children.length; i++) {\r\n\t                layerHeight = Math.max(node.children[i].layout.height, layerHeight);\r\n\t            }\r\n\t            var layerPadding = this.layerPadding;\r\n\t            if (typeof (layerPadding) === 'function') {\r\n\t                layerPadding = layerPadding(node.depth);\r\n\t            }\r\n\t            for (var j = 0; j < node.children.length; j++) {\r\n\t                this._updateNodeYPosition(node.children[j], y + layerPadding + prevLayerHeight, layerHeight);\r\n\t            }\r\n\t        }\r\n\t\r\n\t    };\r\n\t    module.exports = TreeHelper;\r\n\n\n/***/ }),\n/* 130 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 力导向布局<br>\r\n\t * @class fishTopoFlow.layout.ForceLayout\r\n\t * @extends fishTopoFlow.layout\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var layout = fishTopoFlow.layout;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       function newNode(data) {\r\n\t *           var circle = new node.Circle({\r\n\t *               shape: { r: 15 },\r\n\t *               style: { fill: \"#4883b4\" },\r\n\t *               name: data.name\r\n\t *           });\r\n\t *           return circle;\r\n\t *       }\r\n\t *       var options = {\r\n\t *           createNodeFunction: newNode,\r\n\t *           data:[{nodes:[\r\n\t *                           {name: '节点1'},\r\n\t *                           {name: '节点2'},\r\n\t *                           {name: '节点3'},\r\n\t *                           {name: '节点4'},\r\n\t *                           {name: '节点5'},\r\n\t *                           {name: '节点6'},\r\n\t *                           {name: '节点7'},\r\n\t *                           {name: '节点8'}\r\n\t *                       ],\r\n\t *                   links:[\r\n\t *                           {source:'节点1', target:'节点2'},\r\n\t *                           {source:'节点2', target:'节点3'},\r\n\t *                           {source:'节点3', target:'节点4'},\r\n\t *                           {source:'节点4', target:'节点5'},\r\n\t *                           {source:'节点5', target:'节点6'},\r\n\t *                           {source:'节点6', target:'节点7'},\r\n\t *                           {source:'节点7', target:'节点8'}\r\n\t *                       ]\r\n\t *           }]\r\n\t *       }\r\n\t *       var forceLayout = new layout.ForceLayout({\r\n\t *          fishTopo:fishTopo,\r\n\t *           repulsion: 200\r\n\t *       });\r\n\t *       forceLayout.doLayout(options);\r\n\t */\r\n\t\r\n\t\r\n\t\r\n\t    var forceHelper = __webpack_require__(131);\r\n\t    var vec2 = __webpack_require__(15);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    function ForceLayout(opts) {\r\n\t         /**\r\n\t         * @cfg {Object} fishTopo fishTopo实例\r\n\t         */\r\n\t         /**\r\n\t         * @cfg {Number} [repulsion=100] 节点之间的斥力因子。该值越大节点之间的斥力越大，两个节点间的距离也会越远，默认为100\r\n\t         */\r\n\t         /**\r\n\t         * @cfg {Number} [gravity=0.1] 节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。默认为0.1\r\n\t         */\r\n\t        /**\r\n\t         * @cfg {Number} [edgeLength=30] 边的两个节点之间的距离，这个距离也会受 repulsion影响。 默认为30\r\n\t         */\r\n\t        /**\r\n\t         * @cfg {Boolean} [once=true] 是否只进行布局一次。<br/>\r\n\t         * 如果设置为false，在布局结束以后，再拖拽节点，节点的定位会设置为fixed，释放被拖拽的节点，节点会回到原来的位置, 导致重新布局，同样会再次触发forceLayoutEnd事件。\r\n\t         */\r\n\t        /**\r\n\t         * @cfg {Object} [rect] 布局显示范围\r\n\t         *\r\n\t         * @cfg {Object} [rect.x] 布局显示范围x坐标\r\n\t         * @cfg {Object} [rect.y] 布局显示范围y坐标\r\n\t         * @cfg {Object} [rect.width] 布局显示宽度\r\n\t         * @cfg {Object} [rect.height] 布局显示高度\r\n\t         */\r\n\t        /**\r\n\t         * @cfg {Boolean} [layoutAnimation=true] 是否显示布局动画\r\n\t         */\r\n\t        /**\r\n\t         * @cfg {Object} [lineStyle] 连线的样式  参见{@link fishTopoFlow.link#constructor 构造函数options参数}\r\n\t         */\r\n\t        this.fishTopo = opts.fishTopo;\r\n\t        var defaultOptions = {\r\n\t            repulsion: 100,  //节点之间的斥力因子。该值越大节点之间的斥力越大，两个节点间的距离也会越远，默认为100\r\n\t            gravity: 0.1, //节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。默认为0.1\r\n\t            edgeLength: 30, // 边的两个节点之间的距离，这个距离也会受 repulsion。 默认为30\r\n\t            once:true,\r\n\t            layoutAnimation:true,\r\n\t            rect: {x:0, y:0, width:this.fishTopo.getWidth() ,height:this.fishTopo.getHeight()},\r\n\t            lineStyle: {symbol:{type:'none'}},\r\n\t            preservedPoints: {}\r\n\t        };\r\n\t\r\n\t        this.options = zrUtil.defaults(defaultOptions, opts, true);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @method doLayout\r\n\t     * 根据forceData进行力导向布局\r\n\t     * @param {Object} forceData 力导向数据\r\n\t     * @param {Function} forceData.createNodeFunction=null 创建节点的函数 会把data中nodes的数据 传递过去  如果没有默认就是创建圆形\r\n\t     * @param {Function} forceData.createLinkFunction=null 创建线段函数，参数是data.links数据，如果没有默认创建直线 since V2.3.0\r\n\t     * @param {Object} forceData.data 创建力导向布局数据\r\n\t     * @param {Object} forceData.data.nodes 创建力导向布局节点的对象数据（必须包括name属性）\r\n\t     * @param {Object} forceData.data.links 创建力导向布局连线的对象数据（必须包括name属性）\r\n\t     *\r\n\t     */\r\n\t    ForceLayout.prototype.doLayout = function(forceData) {\r\n\t         var rootData = forceData.data[0];\r\n\t         this.allNodes = this._buildNode(rootData.nodes, forceData.createNodeFunction);\r\n\t         this.allLinks = this._buildLinks(rootData.links, forceData.createLinkFunction);\r\n\t         this._forceIns();\r\n\t\r\n\t         this._startForceLayoutIteration();\r\n\t    }\r\n\t    /**\r\n\t     * @method autoLayout\r\n\t     * 根据已有节点进行力导向布局\r\n\t     * @since V2.3.0\r\n\t     */\r\n\t    ForceLayout.prototype.autoLayout = function() {\r\n\t        this.allNodes = this.fishTopo.allNodes;\r\n\t        this.allLinks = this.fishTopo.connectionManager.connectors;\r\n\t        this._forceIns();\r\n\t        this._startForceLayoutIteration();\r\n\t    }\r\n\t\r\n\t    ForceLayout.prototype._buildNode = function(datas, createNodeFunction) {\r\n\t        if(!fish.isFunction(createNodeFunction)) {\r\n\t            createNodeFunction = this._defaultCreateNodeFunction.bind(this);\r\n\t        }\r\n\t        var allNodes = [];\r\n\t        //判断一下是否有node 如果没有则自己创建\r\n\t        zrUtil.each(datas,  function(item,idx) {\r\n\t            if(!item.node) {\r\n\t                var createNode = item.createNodeFunction || createNodeFunction;\r\n\t                var node = createNode(item);\r\n\t                this.fishTopo.add(node);\r\n\t                this._addNodeEvent(node,idx);\r\n\t                allNodes.push(node);\r\n\t            }\r\n\t        },this);\r\n\t        return allNodes;\r\n\t    }\r\n\t\r\n\t    ForceLayout.prototype._addNodeEvent = function(node,idx) {\r\n\t        if(!this.options.once) {\r\n\t            node.on('drag', function() {\r\n\t                if(this.options.forceLayout) {\r\n\t                    this.options.forceLayout.warmUp();\r\n\t                    !this._layouting && this._startForceLayoutIteration();\r\n\t                    this.options.forceLayout.setFixed(idx);\r\n\t                }\r\n\t            },this).on('dragend', function() {\r\n\t                if(this.options.forceLayout) {\r\n\t                    this.options.forceLayout.setUnfixed(idx);\r\n\t                }\r\n\t            },this)\r\n\t        }\r\n\t    }\r\n\t\r\n\t    ForceLayout.prototype._defaultCreateNodeFunction = function(item) {\r\n\t        var circle = this.fishTopo.createNode(\"Circle\",{\r\n\t            shape: { r: 15 },\r\n\t            style: { fill: \"#4883b4\" },\r\n\t            name: item.lable || item.name\r\n\t        });\r\n\t        return circle;\r\n\t    }\r\n\t\r\n\t    ForceLayout.prototype._buildLinks = function(links,createLinkFunction) {\r\n\t        var allLinks = [];\r\n\t\r\n\t        zrUtil.each(links, function(link) {\r\n\t            var startNode = this.fishTopo.childOfName(link.source);\r\n\t            var endNode = this.fishTopo.childOfName(link.target);\r\n\t            if(startNode && endNode) {\r\n\t                 var connector = null;\r\n\t                if(createLinkFunction) {\r\n\t                    var paramObj = link;\r\n\t                    paramObj.startNode = startNode;\r\n\t                    paramObj.endNode = endNode;\r\n\t                    connector = createLinkFunction(paramObj);\r\n\t                } else {\r\n\t                    var linkStyle = this.options.lineStyle;\r\n\t                    if (link.style) {\r\n\t                        linkStyle = zrUtil.merge(zrUtil.clone(linkStyle), link.style, true);\r\n\t                    }\r\n\t                    connector = this.fishTopo.createLink(startNode,endNode,linkStyle);\r\n\t                }\r\n\t                this.fishTopo.add(connector);\r\n\t                allLinks.push(connector);\r\n\t            }\r\n\t        },this);\r\n\t        return allLinks;\r\n\t    }\r\n\t\r\n\t\r\n\t    ForceLayout.prototype._forceIns = function() {\r\n\t        var rect = this.options.rect;\r\n\t        var self = this;\r\n\t        var preservedPoints = this.options.preservedPoints;\r\n\t        var nodes = zrUtil.map(this.allNodes, function(node) {\r\n\t            var rep = this.options.repulsion; node.w = rep; node.rep = rep; node.p = null;\r\n\t            return {\r\n\t                w: rep,\r\n\t                rep: rep,\r\n\t                p: null\r\n\t            };\r\n\t        },this);\r\n\t        if (preservedPoints) {\r\n\t            zrUtil.each(this.allNodes, function(node,idx) {\r\n\t                node.attr(\"position\", preservedPoints[idx]);\r\n\t            })\r\n\t        }\r\n\t        zrUtil.each(this.allLinks, function(link) {\r\n\t            link.n1 = link.startNode,\r\n\t            link.n2 = link.endNode,\r\n\t            link.d = this.options.edgeLength;\r\n\t            link.curveness = 0;\r\n\t        },this)\r\n\t\r\n\t        var forceInstance = forceHelper(this.allNodes, this.allLinks, {\r\n\t            rect: rect,\r\n\t            gravity: this.options.gravity\r\n\t        });\r\n\t        var oldStep = forceInstance.step;\r\n\t        forceInstance.step = function(cb) {\r\n\t            zrUtil.each(this.allNodes, function(node) {\r\n\t                if (nodes.fixed) {\r\n\t                    vec2.copy(nodes.p, nodes.position);\r\n\t                }\r\n\t            })\r\n\t\r\n\t            oldStep(function(allNodes, allLinks, stopped) {\r\n\t                for (var i = 0, l = allNodes.length; i < l; i++) {\r\n\t                    if (!allNodes[i].fixed) {\r\n\t                        allNodes[i].attr(\"position\", allNodes[i].p);\r\n\t                    }\r\n\t                    preservedPoints[i] = allNodes[i].p;\r\n\t                }\r\n\t\r\n\t                zrUtil.each(allLinks, function(connector) {\r\n\t                    self.fishTopo.connectionManager.refreshConnector(connector, true);\r\n\t                })\r\n\t\r\n\t                cb && cb(stopped);\r\n\t            });\r\n\t        };\r\n\t        this.options.forceLayout = forceInstance;\r\n\t        this.options.preservedPoints = preservedPoints;\r\n\t        // Step to get the layout\r\n\t        forceInstance.step();\r\n\t    }\r\n\t\r\n\t\r\n\t    ForceLayout.prototype._startForceLayoutIteration = function () {\r\n\t        var self = this;\r\n\t        var layoutAnimation = this.options.layoutAnimation;\r\n\t        (function step() {\r\n\t            self.options.forceLayout.step(function (stopped) {\r\n\t                self._layouting = !stopped;\r\n\t                if (self._layouting) {\r\n\t                    if (layoutAnimation) {\r\n\t                        self._layoutTimeout = setTimeout(step, 16)\r\n\t                    } else {\r\n\t                        step();\r\n\t                    }\r\n\t                } else {\r\n\t                     self.fishTopo.trigger(\"forceLayoutEnd\");  //派发布局结束事件\r\n\t                }\r\n\t            })\r\n\t        })();\r\n\t    };\r\n\t    module.exports = ForceLayout;\r\n\t\r\n\t/**\r\n\t * @method addCustomLayout\r\n\t * @hide\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event forceLayoutEnd\r\n\t * 布局结束事件\r\n\t *\r\n\t * <pre>\r\n\t * fishtopo.on('forceLayoutEnd', function(e) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\n\n/***/ }),\n/* 131 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t\r\n\t    var vec2 = __webpack_require__(15);\r\n\t    var scaleAndAdd = vec2.scaleAndAdd;\r\n\t\r\n\t    // function adjacentNode(n, e) {\r\n\t    //     return e.n1 === n ? e.n2 : e.n1;\r\n\t    // }\r\n\t\r\n\t    module.exports = function (nodes, edges, opts) {\r\n\t        var rect = opts.rect;\r\n\t        var width = rect.width;\r\n\t        var height = rect.height;\r\n\t        var center = [rect.x + width / 2, rect.y + height / 2];\r\n\t        // var scale = opts.scale || 1;\r\n\t        var gravity = opts.gravity == null ? 0.1 : opts.gravity;\r\n\t\r\n\t        // for (var i = 0; i < edges.length; i++) {\r\n\t        //     var e = edges[i];\r\n\t        //     var n1 = e.n1;\r\n\t        //     var n2 = e.n2;\r\n\t        //     n1.edges = n1.edges || [];\r\n\t        //     n2.edges = n2.edges || [];\r\n\t        //     n1.edges.push(e);\r\n\t        //     n2.edges.push(e);\r\n\t        // }\r\n\t        // Init position\r\n\t        for (var i = 0; i < nodes.length; i++) {\r\n\t            var n = nodes[i];\r\n\t            if (!n.p) {\r\n\t                // Use the position from first adjecent node with defined position\r\n\t                // Or use a random position\r\n\t                // From d3\r\n\t                // if (n.edges) {\r\n\t                //     var j = -1;\r\n\t                //     while (++j < n.edges.length) {\r\n\t                //         var e = n.edges[j];\r\n\t                //         var other = adjacentNode(n, e);\r\n\t                //         if (other.p) {\r\n\t                //             n.p = vec2.clone(other.p);\r\n\t                //             break;\r\n\t                //         }\r\n\t                //     }\r\n\t                // }\r\n\t                // if (!n.p) {\r\n\t                    n.p = vec2.create(\r\n\t                        width * (Math.random() - 0.5) + center[0],\r\n\t                        height * (Math.random() - 0.5) + center[1]\r\n\t                    );\r\n\t                // }\r\n\t            }\r\n\t            n.pp = vec2.clone(n.p);\r\n\t            n.edges = null;\r\n\t        }\r\n\t\r\n\t        // Formula in 'Graph Drawing by Force-directed Placement'\r\n\t        // var k = scale * Math.sqrt(width * height / nodes.length);\r\n\t        // var k2 = k * k;\r\n\t\r\n\t        var friction = 0.6;\r\n\t\r\n\t        return {\r\n\t            warmUp: function () {\r\n\t                friction = 0.5;\r\n\t            },\r\n\t\r\n\t            setFixed: function (idx) {\r\n\t                nodes[idx].fixed = true;\r\n\t            },\r\n\t\r\n\t            setUnfixed: function (idx) {\r\n\t                nodes[idx].fixed = false;\r\n\t            },\r\n\t\r\n\t            step: function (cb) {\r\n\t                var v12 = [];\r\n\t                var nLen = nodes.length;\r\n\t                for (var i = 0; i < edges.length; i++) {\r\n\t                    var e = edges[i];\r\n\t                    var n1 = e.n1;\r\n\t                    var n2 = e.n2;\r\n\t\r\n\t                    vec2.sub(v12, n2.p, n1.p);\r\n\t                    var d = vec2.len(v12) - e.d;\r\n\t                    var w = n2.w / (n1.w + n2.w);\r\n\t                    vec2.normalize(v12, v12);\r\n\t\r\n\t                    !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);\r\n\t                    !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);\r\n\t                }\r\n\t                // Gravity\r\n\t                for (var i = 0; i < nLen; i++) {\r\n\t                    var n = nodes[i];\r\n\t                    if (!n.fixed) {\r\n\t                        vec2.sub(v12, center, n.p);\r\n\t                        // var d = vec2.len(v12);\r\n\t                        // vec2.scale(v12, v12, 1 / d);\r\n\t                        // var gravityFactor = gravity;\r\n\t                        vec2.scaleAndAdd(n.p, n.p, v12, gravity * friction);\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                // Repulsive\r\n\t                // PENDING\r\n\t                for (var i = 0; i < nLen; i++) {\r\n\t                    var n1 = nodes[i];\r\n\t                    for (var j = i + 1; j < nLen; j++) {\r\n\t                        var n2 = nodes[j];\r\n\t                        vec2.sub(v12, n2.p, n1.p);\r\n\t                        var d = vec2.len(v12);\r\n\t                        if (d === 0) {\r\n\t                            // Random repulse\r\n\t                            vec2.set(v12, Math.random() - 0.5, Math.random() - 0.5);\r\n\t                            d = 1;\r\n\t                        }\r\n\t                        var repFact = (n1.rep + n2.rep) / d / d;\r\n\t                        !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);\r\n\t                        !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);\r\n\t                    }\r\n\t                }\r\n\t                var v = [];\r\n\t                for (var i = 0; i < nLen; i++) {\r\n\t                    var n = nodes[i];\r\n\t                    if (!n.fixed) {\r\n\t                        vec2.sub(v, n.p, n.pp);\r\n\t                        vec2.scaleAndAdd(n.p, n.p, v, friction);\r\n\t                        vec2.copy(n.pp, n.p);\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                friction = friction * 0.992;\r\n\t\r\n\t                cb && cb(nodes, edges, friction < 0.01);\r\n\t            }\r\n\t        };\r\n\t    }\r\n\t\r\n\n\n/***/ }),\n/* 132 */\n/***/ (function(module, exports) {\n\n\t/**\r\n\t * 工具类\r\n\t * @class fishTopoFlow.util\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method initImagePool\r\n\t * 初始化图片池  用于对图片加载进行管理\r\n\t * @param {number} max 最大连接数。数值。\r\n\t * @returns {{load: Function, info: Function}}\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t        var imagepool = fishTopoFlow.util.initImagePool(100);\r\n\t        imagepool.load(grayArray, {\r\n\t            success: function(imgs) {\r\n\t            },\r\n\t            once: true\r\n\t        });\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method inherits\r\n\t * 构造类继承关系\r\n\t *\r\n\t * @param {Function} clazz 源类\r\n\t * @param {Function} baseClazz 基类\r\n\t */\r\n\t\r\n\t\r\n\t    var emptyFn = function() {};\r\n\t    //初始默认配置\r\n\t    var config_default = {\r\n\t        //线程池\"线程\"数量\r\n\t        thread: 5,\r\n\t        //图片加载失败重试次数\r\n\t        //重试2次，加上原有的一次，总共是3次\r\n\t        \"tries\": 2\r\n\t    };\r\n\t    //工具\r\n\t    var _helpers = {\r\n\t        //设置dom属性\r\n\t        setAttr: (function() {\r\n\t            var img = new Image();\r\n\t            //判断浏览器是否支持HTML5 dataset\r\n\t            if (img.dataset) {\r\n\t                return function(dom, name, value) {\r\n\t                    dom.dataset[name] = value;\r\n\t                    return value;\r\n\t                };\r\n\t            } else {\r\n\t                return function(dom, name, value) {\r\n\t                    dom.setAttribute(\"data-\" + name, value);\r\n\t                    return value;\r\n\t                };\r\n\t            }\r\n\t        }()),\r\n\t        //获取dom属性\r\n\t        getAttr: (function() {\r\n\t            var img = new Image();\r\n\t            //判断浏览器是否支持HTML5 dataset\r\n\t            if (img.dataset) {\r\n\t                return function(dom, name) {\r\n\t                    if(!dom.dataset[name]){\r\n\t                        return dom.getAttribute(\"data-\" + name);\r\n\t                    }else{\r\n\t                        return dom.dataset[name];\r\n\t                    }\r\n\t                };\r\n\t            } else {\r\n\t                return function(dom, name) {\r\n\t                    return dom.getAttribute(\"data-\" + name);\r\n\t                };\r\n\t            }\r\n\t        }())\r\n\t    };\r\n\t    /**\r\n\t     * 构造方法\r\n\t     * @private\r\n\t     * @param max 最大连接数。数值。\r\n\t     */\r\n\t    function ImagePool(max) {\r\n\t        //最大并发数量\r\n\t        this.max = max || config_default.thread;\r\n\t        this.linkHead = null;\r\n\t        this.linkNode = null;\r\n\t        //加载池\r\n\t        //[{img: dom,free: true, node: node}]\r\n\t        //node\r\n\t        //{src: \"\", options: {success: \"fn\",error: \"fn\", once: true}, tries: 0}\r\n\t        this.pool = [];\r\n\t    }\r\n\t    /**\r\n\t     * 初始化\r\n\t     * @private\r\n\t     */\r\n\t    ImagePool.prototype.initPool = function() {\r\n\t        var i, img, obj, _s;\r\n\t        _s = this;\r\n\t        for (i = 0; i < this.max; i++) {\r\n\t            obj = {};\r\n\t            img = new Image();\r\n\t            _helpers.setAttr(img, \"id\", i);\r\n\t            img.onload = function() {\r\n\t                //回调\r\n\t                _s.notice(_s.getNode(this), \"success\", this);\r\n\t                //处理任务\r\n\t                _s.executeLink(this);\r\n\t            };\r\n\t            img.onerror = function() {\r\n\t                var node = _s.getNode(this);\r\n\t                //判断尝试次数\r\n\t                if (node.tries < config_default.tries) {\r\n\t                    node.tries = node.tries+1;\r\n\t                    //再次追加到任务链表末尾\r\n\t                    _s.appendNode(_s.createNode(node.src, node.options, node.notice, node.group, node.tries));\r\n\t                } else {\r\n\t                    //error回调\r\n\t                    //node.options.error.call(null, this.src);\r\n\t                    _s.notice(node, \"error\", this);\r\n\t                }\r\n\t                //处理任务\r\n\t                _s.executeLink(this);\r\n\t            };\r\n\t            obj.img = img;\r\n\t            obj.free = true;\r\n\t            this.pool.push(obj);\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 回调封装\r\n\t     * @private\r\n\t     * @param node 节点。对象。\r\n\t     * @param status 状态。字符串。可选值：success(成功)|error(失败)\r\n\t     * @param img 图片。\r\n\t     */\r\n\t    ImagePool.prototype.notice = function(node, status, img) {\r\n\t        node.notice(status, img);\r\n\t    };\r\n\t    /**\r\n\t     * 处理链表任务\r\n\t     * @private\r\n\t     * @param dom 图像dom对象。对象。\r\n\t     */\r\n\t    ImagePool.prototype.executeLink = function(dom) {\r\n\t        //判断链表是否存在节点\r\n\t        if (this.linkHead) {\r\n\t            //加载下一个图片\r\n\t            this.setSrc(dom, this.linkHead);\r\n\t            //去除链表头\r\n\t            this.shiftNode();\r\n\t        } else {\r\n\t            //设置自身状态为空闲\r\n\t            this.status(dom, true);\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 获取空闲\"线程\"\r\n\t     * @private\r\n\t     */\r\n\t    ImagePool.prototype.getFree = function() {\r\n\t        var length, i;\r\n\t        for (i = 0, length = this.pool.length; i < length; i++) {\r\n\t            if (this.pool[i].free) {\r\n\t                return this.pool[i];\r\n\t            }\r\n\t        }\r\n\t        return null;\r\n\t    };\r\n\t    /**\r\n\t     * 封装src属性设置\r\n\t     * 因为改变src属性相当于加载图片，所以把操作封装起来\r\n\t     * @private\r\n\t     * @param dom 图像dom对象。对象。\r\n\t     * @param node 节点。对象。\r\n\t     */\r\n\t    ImagePool.prototype.setSrc = function(dom, node) {\r\n\t        //设置池中的\"线程\"为非空闲状态\r\n\t        this.status(dom, false);\r\n\t        //关联节点\r\n\t        this.setNode(dom, node);\r\n\t        //加载图片\r\n\t        dom.src = node.src;\r\n\t    };\r\n\t    /**\r\n\t     * 更新池中的\"线程\"状态\r\n\t     * @private\r\n\t     * @param dom 图像dom对象。对象。\r\n\t     * @param status 状态。布尔。可选值：true(空闲)|false(非空闲)\r\n\t     */\r\n\t    ImagePool.prototype.status = function(dom, status) {\r\n\t        var id = _helpers.getAttr(dom, \"id\");\r\n\t        if(id){\r\n\t            this.pool[id].free = status;\r\n\t        }\r\n\t\r\n\t        //空闲状态，清除关联的节点\r\n\t        if (status) {\r\n\t            this.pool[id].node = null;\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 更新池中的\"线程\"的关联节点\r\n\t     * @private\r\n\t     * @param dom 图像dom对象。对象。\r\n\t     * @param node 节点。对象。\r\n\t     */\r\n\t    ImagePool.prototype.setNode = function(dom, node) {\r\n\t        var id = _helpers.getAttr(dom, \"id\");\r\n\t        if(id){\r\n\t            this.pool[id].node = node;\r\n\t            return this.pool[id].node === node;\r\n\t        }\r\n\t\r\n\t    };\r\n\t    /**\r\n\t     * 获取池中的\"线程\"的关联节点\r\n\t     * @private\r\n\t     * @param dom 图像dom对象。对象。\r\n\t     */\r\n\t    ImagePool.prototype.getNode = function(dom) {\r\n\t        var id = _helpers.getAttr(dom, \"id\");\r\n\t        if(id){\r\n\t            return this.pool[id].node;\r\n\t        }\r\n\t\r\n\t    };\r\n\t    /**\r\n\t     * 对外接口，加载图片\r\n\t     * @private\r\n\t     * @param src 可以是src字符串，也可以是src字符串数组。\r\n\t     * @param options 用户自定义参数。包含：success回调、error回调、once标识。\r\n\t     */\r\n\t    ImagePool.prototype._load = function(src, options) {\r\n\t        var srcs = [],\r\n\t            free = null,\r\n\t            length = 0,\r\n\t            i = 0,\r\n\t            //只初始化一次回调策略\r\n\t            notice = (function() {\r\n\t                if (options.once) {\r\n\t                    return function(status, img) {\r\n\t                        var g = this.group,\r\n\t                            o = this.options;\r\n\t                        //记录\r\n\t                        g[status].push(img);\r\n\t                        //判断改组是否全部处理完成\r\n\t                        if (g.success.length + g.error.length === g.count) {\r\n\t                            //异步\r\n\t                            //实际上是作为另一个任务单独执行，防止回调函数执行时间过长影响图片加载速度\r\n\t                            setTimeout(function() {\r\n\t                                o.success.call(null, g.success, g.error, g.count);\r\n\t                            }, 1);\r\n\t                        }\r\n\t                    };\r\n\t                } else {\r\n\t                    return function(status, img) {\r\n\t                        var o = this.options;\r\n\t                        //直接回调\r\n\t                        setTimeout(function() {\r\n\t                            o[status].call(null, img);\r\n\t                        }, 1);\r\n\t                    };\r\n\t                }\r\n\t            }()),\r\n\t            group = {\r\n\t                count: 0,\r\n\t                success: [],\r\n\t                error: []\r\n\t            },\r\n\t            node = null;\r\n\t        options = options || {};\r\n\t        options.success = options.success || emptyFn;\r\n\t        options.error = options.error || emptyFn;\r\n\t        srcs = srcs.concat(src);\r\n\t        //设置组元素个数\r\n\t        group.count = srcs.length;\r\n\t        //遍历需要加载的图片\r\n\t        for (i = 0, length = srcs.length; i < length; i++) {\r\n\t            //创建节点\r\n\t            node = this.createNode(srcs[i], options, notice, group);\r\n\t            //判断线程池是否有空闲\r\n\t            free = this.getFree();\r\n\t            if (free) {\r\n\t                //有空闲，则立即加载图片\r\n\t                this.setSrc(free.img, node);\r\n\t            } else {\r\n\t                //没有空闲，将任务添加到链表\r\n\t                this.appendNode(node);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 获取内部状态信息\r\n\t     * @private\r\n\t     * @returns {Object}\r\n\t     */\r\n\t    ImagePool.prototype._info = function() {\r\n\t        var info = {},\r\n\t            length = 0,\r\n\t            i = 0,\r\n\t            node = null;\r\n\t        //线程\r\n\t        info.thread = {};\r\n\t        //线程总数量\r\n\t        info.thread.count = this.pool.length;\r\n\t        //空闲线程数量\r\n\t        info.thread.free = 0;\r\n\t        //任务\r\n\t        info.task = {};\r\n\t        //待处理任务数量\r\n\t        info.task.count = 0;\r\n\t        //获取空闲\"线程\"数量\r\n\t        for (i = 0, length = this.pool.length; i < length; i++) {\r\n\t            if (this.pool[i].free) {\r\n\t                info.thread.free = info.thread.free + 1;\r\n\t            }\r\n\t        }\r\n\t        //获取任务数量(任务链长度)\r\n\t        node = this.linkHead;\r\n\t        if (node) {\r\n\t            info.task.count = info.task.count + 1;\r\n\t            while (node.next) {\r\n\t                info.task.count = info.task.count + 1;\r\n\t                node = node.next;\r\n\t            }\r\n\t        }\r\n\t        return info;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建节点\r\n\t     * @private\r\n\t     * @param src 图片路径。字符串。\r\n\t     * @param options 用户自定义参数。包含：success回调、error回调、once标识。\r\n\t     * @param notice 回调策略。 函数。\r\n\t     * @param group 组信息。对象。{count: 0, success: [], error: []}\r\n\t     * @param tr 出错重试次数。数值。默认为0。\r\n\t     * @returns {Object}\r\n\t     */\r\n\t    ImagePool.prototype.createNode = function(src, options, notice, group, tr) {\r\n\t        var node = {};\r\n\t        node.src = src;\r\n\t        node.options = options;\r\n\t        node.notice = notice;\r\n\t        node.group = group;\r\n\t        node.tries = tr || 0;\r\n\t        return node;\r\n\t    };\r\n\t    /**\r\n\t     * 向任务链表末尾追加节点\r\n\t     * @private\r\n\t     * @param node 节点。对象。\r\n\t     */\r\n\t    ImagePool.prototype.appendNode = function(node) {\r\n\t        //判断链表是否为空\r\n\t        if (!this.linkHead) {\r\n\t            this.linkHead = node;\r\n\t            this.linkNode = node;\r\n\t        } else {\r\n\t            this.linkNode.next = node;\r\n\t            this.linkNode = node;\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 删除链表头\r\n\t     * @private\r\n\t     */\r\n\t    ImagePool.prototype.shiftNode = function() {\r\n\t        //判断链表是否存在节点\r\n\t        if (this.linkHead) {\r\n\t            //修改链表头\r\n\t            this.linkHead = this.linkHead.next || null;\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 初始化图片池\r\n\t     * @param {number} max 最大连接数。数值。\r\n\t     * @returns {{load: Function, info: Function}}\r\n\t     */\r\n\t    var initImagePool = function(max) {\r\n\t        var instance = new ImagePool(max);\r\n\t        instance.initPool();\r\n\t        return {\r\n\t            /**\r\n\t             * 加载图片\r\n\t             * @param {string|Array} src 可以是src字符串，也可以是src字符串数组。\r\n\t             * @param {Object} options 用户自定义参数。包含：success回调、error回调、once标识。\r\n\t             * @param {Function} [options.success] success回调\r\n\t             * @param {Function} [options.error] error回调\r\n\t             * @param {boolean} [options.once] 是否全部加载完毕后，一次回调\r\n\t             */\r\n\t            load: function() {\r\n\t                instance._load.apply(instance, arguments);\r\n\t            },\r\n\t            /**\r\n\t             * 获取内部状态信息\r\n\t             * @returns {Object}\r\n\t             */\r\n\t            info: function() {\r\n\t                return instance._info.call(instance);\r\n\t            }\r\n\t        };\r\n\t    };\r\n\t\r\n\t    module.exports = { initImagePool: initImagePool }\r\n\t\r\n\n\n/***/ }),\n/* 133 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var TooltipContent = __webpack_require__(134);\r\n\t    var globalListener = __webpack_require__(135);\r\n\t    var Model = __webpack_require__(87);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var env = __webpack_require__(50);\r\n\t    var flowUtil = __webpack_require__(94);\r\n\t    var layout = __webpack_require__(124);\r\n\t    function TooltipView(tooltipModel, api) {\r\n\t        this._tooltipContent = new TooltipContent(api.getDom(),api);\r\n\t        this._api = api;\r\n\t        this._tooltipModel = tooltipModel;\r\n\t        this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\r\n\t        this._initGloablListener();\r\n\t    }\r\n\t\r\n\t    TooltipView.prototype._initGloablListener = function() {\r\n\t        var triggerOn = this._tooltipModel.get('triggerOn');\r\n\t        // 当有 'click' | 'mousemove' | 'none' 事件时触发回调\r\n\t        globalListener.register(\r\n\t            'itemTooltip',\r\n\t            this._api,\r\n\t            function(currTrigger, e, dispatchAction){\r\n\t                if (triggerOn !== 'none') {\r\n\t                    if (triggerOn.indexOf(currTrigger) >= 0 ) {\r\n\t                        this._tryShow(e, dispatchAction);\r\n\t                    }\r\n\t                    else if (currTrigger === 'leave') {\r\n\t                        this._hide(dispatchAction)\r\n\t                    }\r\n\t                }\r\n\t            }.bind(this)\r\n\t        )\r\n\t    };\r\n\t\r\n\t    TooltipView.prototype._tryShow = function(e, dispatchAction) {\r\n\t            var el = e.target;\r\n\t            var tooltipModel = this._tooltipModel;\r\n\t\r\n\t            if (!tooltipModel) {\r\n\t                return;\r\n\t            }\r\n\t\r\n\t            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\r\n\t            this._lastX = e.offsetX;\r\n\t            this._lastY = e.offsetY;\r\n\t\r\n\t            if (el && el.tooltip) {\r\n\t                this._showComponentItemTooltip(e, el);\r\n\t            }\r\n\t            else {\r\n\t                this._hide(dispatchAction);\r\n\t            }\r\n\t    };\r\n\t\r\n\t     TooltipView.prototype._hide = function(dispatchAction) {\r\n\t            // Do not directly hideLater here, because this behavior may be prevented\r\n\t            // in dispatchAction when showTip is dispatched.\r\n\t\r\n\t            // FIXME\r\n\t            // duplicated hideTip if manuallyHideTip is called from dispatchAction.\r\n\t            this._lastDataByCoordSys = null;\r\n\t            dispatchAction({\r\n\t                type: 'hideTip',\r\n\t                from: this.uid\r\n\t            });\r\n\t            this.manuallyHideTip();\r\n\t        };\r\n\t\r\n\t       TooltipView.prototype.dispose = function () {\r\n\t            if (env.node) {\r\n\t                return;\r\n\t            }\r\n\t            this._tooltipContent.hide();\r\n\t            globalListener.unregister('itemTooltip', this._api);\r\n\t        };\r\n\t\r\n\t        TooltipView.prototype.manuallyHideTip = function () {\r\n\t            var tooltipContent = this._tooltipContent;\r\n\t\r\n\t            if (!this._alwaysShowContent) {\r\n\t                tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\r\n\t            }\r\n\t\r\n\t            this._lastX = this._lastY = null;\r\n\t\r\n\t\r\n\t        },\r\n\t\r\n\t    TooltipView.prototype._showComponentItemTooltip = function (e, el) {\r\n\t            var tooltipOpt = el.tooltip;\r\n\t            if (typeof tooltipOpt === 'string') {\r\n\t                var content = tooltipOpt;\r\n\t                tooltipOpt = {\r\n\t                    content: content,\r\n\t                    // Fixed formatter\r\n\t                    formatter: content\r\n\t                };\r\n\t            }\r\n\t            var subTooltipModel = new Model(tooltipOpt, this._tooltipModel);\r\n\t            var defaultHtml = subTooltipModel.get('content');\r\n\t            var asyncTicket = Math.random();\r\n\t\r\n\t            // Do not check whether `trigger` is 'none' here, because `trigger`\r\n\t            // only works on cooridinate system. In fact, we have not found case\r\n\t            // that requires setting `trigger` nothing on component yet.\r\n\t\r\n\t            this._showOrMove(subTooltipModel, function () {\r\n\t                this._showTooltipContent(\r\n\t                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},\r\n\t                    asyncTicket, e.offsetX, e.offsetY, e.position, el\r\n\t                );\r\n\t            });\r\n\t\r\n\t\r\n\t        };\r\n\t\r\n\t      TooltipView.prototype._showOrMove = function (tooltipModel, cb) {\r\n\t            // showDelay is used in this case: tooltip.enterable is set\r\n\t            // as true. User intent to move mouse into tooltip and click\r\n\t            // something. `showDelay` makes it easyer to enter the content\r\n\t            // but tooltip do not move immediately.\r\n\t            var delay = tooltipModel.get('showDelay');\r\n\t            cb = zrUtil.bind(cb, this);\r\n\t            clearTimeout(this._showTimout);\r\n\t            delay > 0\r\n\t                ? (this._showTimout = setTimeout(cb, delay))\r\n\t                : cb();\r\n\t        };\r\n\t\r\n\t        TooltipView.prototype._showTooltipContent = function (tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el) {\r\n\t            // Reset ticket\r\n\t            this._ticket = '';\r\n\t\r\n\t            if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {\r\n\t                return;\r\n\t            }\r\n\t\r\n\t            var tooltipContent = this._tooltipContent;\r\n\t\r\n\t            var formatter = tooltipModel.get('formatter');\r\n\t            positionExpr = positionExpr || tooltipModel.get('position');\r\n\t            var html = defaultHtml;\r\n\t\r\n\t            if (formatter && typeof formatter === 'string') {\r\n\t                html = flowUtil.formatTpl(formatter, params, true);\r\n\t            }\r\n\t            else if (typeof formatter === 'function') {\r\n\t                var callback = function (cbTicket, html) {\r\n\t                    if (cbTicket === this._ticket) {\r\n\t                        tooltipContent.setContent(html);\r\n\t                        this._updatePosition(\r\n\t                            tooltipModel, positionExpr, x, y, tooltipContent, params, el\r\n\t                        );\r\n\t                    }\r\n\t                }.bind(this);\r\n\t                this._ticket = asyncTicket;\r\n\t                html = formatter(params, asyncTicket, callback);\r\n\t            }\r\n\t\r\n\t            tooltipContent.setContent(html);\r\n\t            tooltipContent.show(tooltipModel);\r\n\t\r\n\t            this._updatePosition(\r\n\t                tooltipModel, positionExpr, x, y, tooltipContent, params, el\r\n\t            );\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * @param  {string|Function|Array.<number>} positionExpr\r\n\t         * @param  {number} x Mouse x\r\n\t         * @param  {number} y Mouse y\r\n\t         * @param  {boolean} confine Whether confine tooltip content in view rect.\r\n\t         * @param  {Object|<Array.<Object>} params\r\n\t         * @param  {module:zrender/Element} el target element\r\n\t         * @param  {module:echarts/ExtensionAPI} api\r\n\t         * @return {Array.<number>}\r\n\t         */\r\n\t        TooltipView.prototype._updatePosition = function (tooltipModel, positionExpr, x, y, content, params, el) {\r\n\t            var viewWidth = this._api.getWidth();\r\n\t            var viewHeight = this._api.getHeight();\r\n\t            positionExpr = positionExpr || tooltipModel.get('position');\r\n\t\r\n\t            var contentSize = content.getSize();\r\n\t            var align = tooltipModel.get('align');\r\n\t            var vAlign = tooltipModel.get('verticalAlign');\r\n\t            var rect = el && el.getBoundingRect().clone();\r\n\t            el && rect.applyTransform(el.transform);\r\n\t\r\n\t            if (typeof positionExpr === 'function') {\r\n\t                // Callback of position can be an array or a string specify the position\r\n\t                positionExpr = positionExpr([x, y], params, content.el, rect, {\r\n\t                    viewSize: [viewWidth, viewHeight],\r\n\t                    contentSize: contentSize.slice()\r\n\t                });\r\n\t            }\r\n\t\r\n\t            if (zrUtil.isArray(positionExpr)) {\r\n\t                x = flowUtil.parsePercent(positionExpr[0], viewWidth);\r\n\t                y = flowUtil.parsePercent(positionExpr[1], viewHeight);\r\n\t            }\r\n\t            else if (zrUtil.isObject(positionExpr)) {\r\n\t                positionExpr.width = contentSize[0];\r\n\t                positionExpr.height = contentSize[1];\r\n\t                var layoutRect = layout.getLayoutRect(\r\n\t                    positionExpr, {width: viewWidth, height: viewHeight}\r\n\t                );\r\n\t                x = layoutRect.x;\r\n\t                y = layoutRect.y;\r\n\t                align = null;\r\n\t                // When positionExpr is left/top/right/bottom,\r\n\t                // align and verticalAlign will not work.\r\n\t                vAlign = null;\r\n\t            }\r\n\t            // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\r\n\t            else if (typeof positionExpr === 'string' && el) {\r\n\t                var pos = calcTooltipPosition(\r\n\t                    positionExpr, rect, contentSize\r\n\t                );\r\n\t                x = pos[0];\r\n\t                y = pos[1];\r\n\t            }\r\n\t            else {\r\n\t                var pos1 = refixTooltipPosition(\r\n\t                    x, y, content.el, viewWidth, viewHeight, align ? 0 : 20, vAlign ? 0 : 20\r\n\t                );\r\n\t                x = pos1[0];\r\n\t                y = pos1[1];\r\n\t            }\r\n\t\r\n\t            align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);\r\n\t            vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);\r\n\t\r\n\t            if (tooltipModel.get('confine')) {\r\n\t                var pos2 = confineTooltipPosition(\r\n\t                    x, y, content.el, viewWidth, viewHeight\r\n\t                );\r\n\t                x = pos2[0];\r\n\t                y = pos2[1];\r\n\t            }\r\n\t\r\n\t            content.moveTo(x, y);\r\n\t        }\r\n\t\r\n\t    function calcTooltipPosition(position, rect, contentSize) {\r\n\t        var domWidth = contentSize[0];\r\n\t        var domHeight = contentSize[1];\r\n\t        var gap = 5;\r\n\t        var x = 0;\r\n\t        var y = 0;\r\n\t        var rectWidth = rect.width;\r\n\t        var rectHeight = rect.height;\r\n\t        switch (position) {\r\n\t            case 'inside':\r\n\t                x = rect.x + rectWidth / 2 - domWidth / 2;\r\n\t                y = rect.y + rectHeight / 2 - domHeight / 2;\r\n\t                break;\r\n\t            case 'top':\r\n\t                x = rect.x + rectWidth / 2 - domWidth / 2;\r\n\t                y = rect.y - domHeight - gap;\r\n\t                break;\r\n\t            case 'bottom':\r\n\t                x = rect.x + rectWidth / 2 - domWidth / 2;\r\n\t                y = rect.y + rectHeight + gap;\r\n\t                break;\r\n\t            case 'left':\r\n\t                x = rect.x - domWidth - gap;\r\n\t                y = rect.y + rectHeight / 2 - domHeight / 2;\r\n\t                break;\r\n\t            case 'right':\r\n\t                x = rect.x + rectWidth + gap;\r\n\t                y = rect.y + rectHeight / 2 - domHeight / 2;\r\n\t        }\r\n\t        return [x, y];\r\n\t    }\r\n\t    function refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {\r\n\t        var width = el.clientWidth;\r\n\t        var height = el.clientHeight;\r\n\t\r\n\t        if (x + width + gapH > viewWidth) {\r\n\t            x -= width + gapH;\r\n\t        }\r\n\t        else {\r\n\t            x += gapH;\r\n\t        }\r\n\t        if (y + height + gapV > viewHeight) {\r\n\t            y -= height + gapV;\r\n\t        }\r\n\t        else {\r\n\t            y += gapV;\r\n\t        }\r\n\t        return [x, y];\r\n\t    }\r\n\t\r\n\t    function isCenterAlign(align) {\r\n\t        return align === 'center' || align === 'middle';\r\n\t    }\r\n\t\r\n\t    function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\r\n\t        var width = el.clientWidth;\r\n\t        var height = el.clientHeight;\r\n\t\r\n\t        x = Math.min(x + width, viewWidth) - width;\r\n\t        y = Math.min(y + height, viewHeight) - height;\r\n\t        x = Math.max(x, 0);\r\n\t        y = Math.max(y, 0);\r\n\t\r\n\t        return [x, y];\r\n\t    }\r\n\t    module.exports = TooltipView;\r\n\n\n/***/ }),\n/* 134 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var zrColor = __webpack_require__(20);\r\n\t    var env = __webpack_require__(50);\r\n\t    var eventUtil = __webpack_require__(77);\r\n\t    var flowUtil = __webpack_require__(94);\r\n\t    var toCamelCase = flowUtil.toCamelCase;\r\n\t    var normalizeCssArray = flowUtil.normalizeCssArray;\r\n\t    var each = zrUtil.each;\r\n\t\r\n\t\r\n\t    var vendors = ['', '-webkit-', '-moz-', '-o-'];\r\n\t\r\n\t    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:999;';//fish popup zindex:1050\r\n\t    /**\r\n\t     * @param {number} duration\r\n\t     * @return {string}\r\n\t     * @inner\r\n\t     */\r\n\t    function assembleTransition(duration) {\r\n\t        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\r\n\t        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','\r\n\t                            + 'top ' + duration + 's ' + transitionCurve;\r\n\t        return zrUtil.map(vendors, function (vendorPrefix) {\r\n\t            return vendorPrefix + 'transition:' + transitionText;\r\n\t        }).join(';');\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @param {Object} textStyle\r\n\t     * @return {string}\r\n\t     * @inner\r\n\t     */\r\n\t    function assembleFont(textStyleModel) {\r\n\t        var cssText = [];\r\n\t\r\n\t        var fontSize = textStyleModel.get('fontSize');\r\n\t        var color = textStyleModel.get(\"color\");\r\n\t\r\n\t        color && cssText.push('color:' + color);\r\n\t\r\n\t        var font = textStyleModel.get(\"font\");\r\n\t        font && cssText.push('font:' + font);\r\n\t\r\n\t        fontSize &&\r\n\t            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\r\n\t\r\n\t        each(['decoration', 'align'], function (name) {\r\n\t            var val = textStyleModel.get(name);\r\n\t            val && cssText.push('text-' + name + ':' + val);\r\n\t        });\r\n\t\r\n\t        return cssText.join(';');\r\n\t    }\r\n\t    /**\r\n\t     * @param {Object} tooltipModel\r\n\t     * @return {string}\r\n\t     * @inner\r\n\t     */\r\n\t    function assembleCssText(tooltipModel) {\r\n\t\r\n\t        var cssText = [];\r\n\t\r\n\t        var transitionDuration = tooltipModel.get('transitionDuration');\r\n\t        var backgroundColor = tooltipModel.get('backgroundColor');\r\n\t        var textStyleModel = tooltipModel.getModel('textStyle');\r\n\t        var padding = tooltipModel.get('padding');\r\n\t\r\n\t        // Animation transition. Do not animate when transitionDuration is 0.\r\n\t        transitionDuration &&\r\n\t            cssText.push(assembleTransition(transitionDuration));\r\n\t\r\n\t        if (backgroundColor) {\r\n\t            if (env.canvasSupported) {\r\n\t                cssText.push('background-Color:' + backgroundColor);\r\n\t            }\r\n\t            else {\r\n\t                // for ie\r\n\t                cssText.push(\r\n\t                    'background-Color:#' + zrColor.toHex(backgroundColor)\r\n\t                );\r\n\t                cssText.push('filter:alpha(opacity=70)');\r\n\t            }\r\n\t        }\r\n\t\r\n\t        // Border style\r\n\t        each(['width', 'color', 'radius'], function (name) {\r\n\t            var borderName = 'border-' + name;\r\n\t            var camelCase = toCamelCase(borderName);\r\n\t            var val = tooltipModel.get(camelCase);\r\n\t            val != null &&\r\n\t                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\r\n\t        });\r\n\t\r\n\t        // Text style\r\n\t        cssText.push(assembleFont(textStyleModel));\r\n\t\r\n\t        // Padding\r\n\t        if (padding != null) {\r\n\t            cssText.push('padding:' + normalizeCssArray(padding).join('px ') + 'px');\r\n\t        }\r\n\t\r\n\t        return cssText.join(';') + ';';\r\n\t    }\r\n\t    /**\r\n\t     *\r\n\t     *\r\n\t     * @param {any} container\r\n\t     * @param {any} api\r\n\t     */\r\n\t    function TooltipContent(container, api) {\r\n\t        var el = document.createElement('div');\r\n\t        var zr = this._zr = api.getZr();\r\n\t\r\n\t        this.el = el;\r\n\t\r\n\t        this._x = api.getWidth() / 2;\r\n\t        this._y = api.getHeight() / 2;\r\n\t\r\n\t        container.appendChild(el);\r\n\t\r\n\t        this._container = container;\r\n\t\r\n\t        this._show = false;\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         */\r\n\t        this._hideTimeout;\r\n\t\r\n\t        var self = this;\r\n\t        el.onmouseenter = function () {\r\n\t            // clear the timeout in hideLater and keep showing tooltip\r\n\t            if (self._enterable) {\r\n\t                clearTimeout(self._hideTimeout);\r\n\t                self._show = true;\r\n\t            }\r\n\t            self._inContent = true;\r\n\t        };\r\n\t        el.onmousemove = function (e) {\r\n\t            e = e || window.event;\r\n\t            if (!self._enterable) {\r\n\t                // Try trigger zrender event to avoid mouse\r\n\t                // in and out shape too frequently\r\n\t                var handler = zr.handler;\r\n\t                eventUtil.normalizeEvent(container, e, true);\r\n\t                handler.dispatch('mousemove', e);\r\n\t            }\r\n\t        };\r\n\t        el.onmouseleave = function () {\r\n\t            if (self._enterable) {\r\n\t                if (self._show) {\r\n\t                    self.hideLater(self._hideDelay);\r\n\t                }\r\n\t            }\r\n\t            self._inContent = false;\r\n\t        };\r\n\t    }\r\n\t    TooltipContent.prototype = {\r\n\t\r\n\t        constructor: TooltipContent,\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         * @type {boolean}\r\n\t         */\r\n\t        _enterable: true,\r\n\t\r\n\t        /**\r\n\t         * Update when tooltip is rendered\r\n\t         */\r\n\t        update: function () {\r\n\t            // FIXME\r\n\t            // Move this logic to ec main?\r\n\t            var container = this._container;\r\n\t            var stl = container.currentStyle\r\n\t                || document.defaultView.getComputedStyle(container);\r\n\t            var domStyle = container.style;\r\n\t            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\r\n\t                domStyle.position = 'relative';\r\n\t            }\r\n\t            // Hide the tooltip\r\n\t            // PENDING\r\n\t            // this.hide();\r\n\t        },\r\n\t\r\n\t        show: function (tooltipModel) {\r\n\t            clearTimeout(this._hideTimeout);\r\n\t            var el = this.el;\r\n\t\r\n\t            el.style.cssText = gCssText + assembleCssText(tooltipModel)\r\n\t                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\r\n\t                + ';left:' + this._x + 'px;top:' + this._y + 'px;'\r\n\t                + (tooltipModel.get('extraCssText') || '');\r\n\t\r\n\t            el.style.display = el.innerHTML ?  'block' : 'none';\r\n\t\r\n\t            this._show = true;\r\n\t        },\r\n\t\r\n\t        setContent: function (content) {\r\n\t            this.el.innerHTML = content;\r\n\t        },\r\n\t\r\n\t        setEnterable: function (enterable) {\r\n\t            this._enterable = enterable;\r\n\t        },\r\n\t\r\n\t        getSize: function () {\r\n\t            var el = this.el;\r\n\t            return [el.clientWidth, el.clientHeight];\r\n\t        },\r\n\t\r\n\t        moveTo: function (x, y) {\r\n\t            // xy should be based on canvas root. But tooltipContent is\r\n\t            // the sibling of canvas root. So padding of ec container\r\n\t            // should be considered here.\r\n\t            var zr = this._zr;\r\n\t            var viewportRoot;\r\n\t            if (zr && zr.painter && (viewportRoot = zr.painter.getViewportRoot())) {\r\n\t                x += viewportRoot.offsetLeft || 0;\r\n\t                y += viewportRoot.offsetTop || 0;\r\n\t            }\r\n\t\r\n\t            var style = this.el.style;\r\n\t            style.left = x + 'px';\r\n\t            style.top = y + 'px';\r\n\t\r\n\t            this._x = x;\r\n\t            this._y = y;\r\n\t        },\r\n\t\r\n\t        hide: function () {\r\n\t            this.el.style.display = 'none';\r\n\t            this._show = false;\r\n\t        },\r\n\t\r\n\t        hideLater: function (time) {\r\n\t            if (this._show && !(this._inContent && this._enterable)) {\r\n\t                if (time) {\r\n\t                    this._hideDelay = time;\r\n\t                    // Set show false to avoid invoke hideLater mutiple times\r\n\t                    this._show = false;\r\n\t                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\r\n\t                }\r\n\t                else {\r\n\t                    this.hide();\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t\r\n\t        isShow: function () {\r\n\t            return this._show;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    module.exports = TooltipContent;\r\n\n\n/***/ }),\n/* 135 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t\r\n\t    var env = __webpack_require__(50);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var get = __webpack_require__(94).makeGetter();\r\n\t\r\n\t    var each = zrUtil.each;\r\n\t\r\n\t    var globalListener = {};\r\n\t\r\n\t    /**\r\n\t     * @param key 注册的字符串\r\n\t     * @param api ExtensionAPI\r\n\t     * @param handler 处理回调\r\n\t     */\r\n\t    globalListener.register = function (key, api, handler) {\r\n\t        if (env.node) {   //node环境下不执行\r\n\t            return;\r\n\t        }\r\n\t        //判断zrender的 records  并初始化\r\n\t        var zr = api.getZr();\r\n\t        get(zr).records || (get(zr).records = {});\r\n\t\r\n\t        initGlobalListeners(zr, api);\r\n\t\r\n\t        //将回调加入record\r\n\t        var record = get(zr).records[key] || (get(zr).records[key] = {});\r\n\t        record.handler = handler;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 初始化全局侦听\r\n\t     *\r\n\t     * @param {object} zr   zrender\r\n\t     * @param {object} api  ExtensionAPI\r\n\t     * @returns\r\n\t     */\r\n\t    function initGlobalListeners(zr, api) {\r\n\t        if (get(zr).initialized) {   //避免重复初始化\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        get(zr).initialized = true;\r\n\t\r\n\t        //侦听事件\r\n\t        useHandler('click', zrUtil.curry(doEnter, 'click'));\r\n\t        useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove'));\r\n\t        // useHandler('mouseout', onLeave);\r\n\t        useHandler('globalout', onLeave);\r\n\t\r\n\t        function useHandler(eventType, cb) {\r\n\t            zr.on(eventType, function (e) {\r\n\t                var dis = makeDispatchAction(api);\r\n\t                //遍历注册的 所有records， 并进行调用\r\n\t                each(get(zr).records, function (record) {\r\n\t                    record && cb(record, e, dis.dispatchAction);\r\n\t                });\r\n\t\r\n\t                dispatchTooltipFinally(dis.pendings, api);\r\n\t            });\r\n\t        }\r\n\t    }\r\n\t\r\n\t    function dispatchTooltipFinally(pendings, api) {\r\n\t        var showLen = pendings.showTip.length;\r\n\t        var hideLen = pendings.hideTip.length;\r\n\t\r\n\t        var actuallyPayload;\r\n\t        if (showLen) {\r\n\t            actuallyPayload = pendings.showTip[showLen - 1];\r\n\t        }\r\n\t        else if (hideLen) {\r\n\t            actuallyPayload = pendings.hideTip[hideLen - 1];\r\n\t        }\r\n\t        if (actuallyPayload) {\r\n\t            actuallyPayload.dispatchAction = null;\r\n\t            api.dispatchAction(actuallyPayload);\r\n\t        }\r\n\t    }\r\n\t\r\n\t    function onLeave(record, e, dispatchAction) {\r\n\t        record.handler('leave', null, dispatchAction);\r\n\t    }\r\n\t\r\n\t    function doEnter(currTrigger, record, e, dispatchAction) {\r\n\t        record.handler(currTrigger, e, dispatchAction);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 派发action   行将发生的\r\n\t     *\r\n\t     * @param {any} api\r\n\t     * @returns\r\n\t     */\r\n\t    function makeDispatchAction(api) {\r\n\t        var pendings = {\r\n\t            showTip: [],\r\n\t            hideTip: []\r\n\t        };\r\n\t        // FIXME\r\n\t        // better approach?\r\n\t        // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,\r\n\t        // which may be conflict, (axisPointer call showTip but tooltip call hideTip);\r\n\t        // So we have to add \"final stage\" to merge those dispatched actions.\r\n\t        var dispatchAction = function (payload) {\r\n\t            var pendingList = pendings[payload.type];\r\n\t            if (pendingList) {\r\n\t                pendingList.push(payload);\r\n\t            }\r\n\t            else {\r\n\t                payload.dispatchAction = dispatchAction;\r\n\t                api.dispatchAction(payload);\r\n\t            }\r\n\t        };\r\n\t\r\n\t        return {\r\n\t            dispatchAction: dispatchAction,\r\n\t            pendings: pendings\r\n\t        };\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @param {string} key\r\n\t     * @param {module:echarts/ExtensionAPI} api\r\n\t     */\r\n\t    globalListener.unregister = function (key, api) {\r\n\t        if (env.node) {\r\n\t            return;\r\n\t        }\r\n\t        var zr = api.getZr();\r\n\t        var record = (get(zr).records || {})[key];\r\n\t        if (record) {\r\n\t            get(zr).records[key] = null;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    module.exports = globalListener;\r\n\n\n/***/ }),\n/* 136 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t\r\n\t    var Model = __webpack_require__(87);\r\n\t    module.exports = Model.extend({\r\n\t\r\n\t        type: 'tooltip',\r\n\t\r\n\t        defaultOption: {\r\n\t            zlevel: 0,\r\n\t\r\n\t            z: 8,\r\n\t\r\n\t            show: true,\r\n\t\r\n\t            // tooltip主体内容\r\n\t            showContent: true,\r\n\t\r\n\t\r\n\t\r\n\t            // 'click' | 'mousemove' | 'none'\r\n\t            triggerOn: 'mousemove',\r\n\t\r\n\t            alwaysShowContent: false,\r\n\t\r\n\t            displayMode: 'single', // 'single' | 'multipleByCoordSys'\r\n\t\r\n\t            // 位置 {Array} | {Function}\r\n\t            // position: null\r\n\t            // Consider triggered from axisPointer handle, verticalAlign should be 'middle'\r\n\t            // align: null,\r\n\t            // verticalAlign: null,\r\n\t\r\n\t            // 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。\r\n\t            confine: false,\r\n\t\r\n\t            // 内容格式器：{string}（Template） ¦ {Function}\r\n\t            // formatter: null\r\n\t\r\n\t            showDelay: 0,\r\n\t\r\n\t            // 隐藏延迟，单位ms\r\n\t            hideDelay: 100,\r\n\t\r\n\t            // 动画变换时间，单位s\r\n\t            transitionDuration: 0.4,\r\n\t\r\n\t            enterable: false,\r\n\t\r\n\t            // 提示背景颜色，默认为透明度为0.7的黑色\r\n\t            backgroundColor: 'rgba(50,50,50,0.7)',\r\n\t\r\n\t            // 提示边框颜色\r\n\t            borderColor: '#333',\r\n\t\r\n\t            // 提示边框圆角，单位px，默认为4\r\n\t            borderRadius: 4,\r\n\t\r\n\t            // 提示边框线宽，单位px，默认为0（无边框）\r\n\t            borderWidth: 0,\r\n\t\r\n\t            // 提示内边距，单位px，默认各方向内边距为5，\r\n\t            // 接受数组分别设定上右下左边距，同css\r\n\t            padding: 5,\r\n\t\r\n\t            // Extra css text\r\n\t            extraCssText: '',\r\n\t\r\n\t            textStyle: {\r\n\t                color: '#fff',\r\n\t                fontSize: 14\r\n\t            }\r\n\t        }\r\n\t    });\r\n\n\n/***/ }),\n/* 137 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(138);\n\t\n\tvar _zrender = __webpack_require__(69);\n\t\n\tvar registerPainter = _zrender.registerPainter;\n\t\n\tvar Painter = __webpack_require__(140);\n\t\n\tregisterPainter('vml', Painter);\n\n/***/ }),\n/* 138 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar env = __webpack_require__(50);\n\t\n\tvar _vector = __webpack_require__(15);\n\t\n\tvar applyTransform = _vector.applyTransform;\n\t\n\tvar BoundingRect = __webpack_require__(27);\n\t\n\tvar colorTool = __webpack_require__(20);\n\t\n\tvar textContain = __webpack_require__(26);\n\t\n\tvar textHelper = __webpack_require__(25);\n\t\n\tvar RectText = __webpack_require__(24);\n\t\n\tvar Displayable = __webpack_require__(8);\n\t\n\tvar ZImage = __webpack_require__(45);\n\t\n\tvar Text = __webpack_require__(46);\n\t\n\tvar Path = __webpack_require__(7);\n\t\n\tvar PathProxy = __webpack_require__(30);\n\t\n\tvar Gradient = __webpack_require__(42);\n\t\n\tvar vmlCore = __webpack_require__(139);\n\t\n\t// http://www.w3.org/TR/NOTE-VML\n\t// TODO Use proxy like svg instead of overwrite brush methods\n\tvar CMD = PathProxy.CMD;\n\tvar round = Math.round;\n\tvar sqrt = Math.sqrt;\n\tvar abs = Math.abs;\n\tvar cos = Math.cos;\n\tvar sin = Math.sin;\n\tvar mathMax = Math.max;\n\t\n\tif (!env.canvasSupported) {\n\t  var comma = ',';\n\t  var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n\t  var Z = 21600;\n\t  var Z2 = Z / 2;\n\t  var ZLEVEL_BASE = 100000;\n\t  var Z_BASE = 1000;\n\t\n\t  var initRootElStyle = function (el) {\n\t    el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n\t    el.coordsize = Z + ',' + Z;\n\t    el.coordorigin = '0,0';\n\t  };\n\t\n\t  var encodeHtmlAttribute = function (s) {\n\t    return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n\t  };\n\t\n\t  var rgb2Str = function (r, g, b) {\n\t    return 'rgb(' + [r, g, b].join(',') + ')';\n\t  };\n\t\n\t  var append = function (parent, child) {\n\t    if (child && parent && child.parentNode !== parent) {\n\t      parent.appendChild(child);\n\t    }\n\t  };\n\t\n\t  var remove = function (parent, child) {\n\t    if (child && parent && child.parentNode === parent) {\n\t      parent.removeChild(child);\n\t    }\n\t  };\n\t\n\t  var getZIndex = function (zlevel, z, z2) {\n\t    // z 的取值范围为 [0, 1000]\n\t    return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n\t  };\n\t\n\t  var parsePercent = function (value, maxValue) {\n\t    if (typeof value === 'string') {\n\t      if (value.lastIndexOf('%') >= 0) {\n\t        return parseFloat(value) / 100 * maxValue;\n\t      }\n\t\n\t      return parseFloat(value);\n\t    }\n\t\n\t    return value;\n\t  };\n\t  /***************************************************\n\t   * PATH\n\t   **************************************************/\n\t\n\t\n\t  var setColorAndOpacity = function (el, color, opacity) {\n\t    var colorArr = colorTool.parse(color);\n\t    opacity = +opacity;\n\t\n\t    if (isNaN(opacity)) {\n\t      opacity = 1;\n\t    }\n\t\n\t    if (colorArr) {\n\t      el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n\t      el.opacity = opacity * colorArr[3];\n\t    }\n\t  };\n\t\n\t  var getColorAndAlpha = function (color) {\n\t    var colorArr = colorTool.parse(color);\n\t    return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];\n\t  };\n\t\n\t  var updateFillNode = function (el, style, zrEl) {\n\t    // TODO pattern\n\t    var fill = style.fill;\n\t\n\t    if (fill != null) {\n\t      // Modified from excanvas\n\t      if (fill instanceof Gradient) {\n\t        var gradientType;\n\t        var angle = 0;\n\t        var focus = [0, 0]; // additional offset\n\t\n\t        var shift = 0; // scale factor for offset\n\t\n\t        var expansion = 1;\n\t        var rect = zrEl.getBoundingRect();\n\t        var rectWidth = rect.width;\n\t        var rectHeight = rect.height;\n\t\n\t        if (fill.type === 'linear') {\n\t          gradientType = 'gradient';\n\t          var transform = zrEl.transform;\n\t          var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n\t          var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n\t\n\t          if (transform) {\n\t            applyTransform(p0, p0, transform);\n\t            applyTransform(p1, p1, transform);\n\t          }\n\t\n\t          var dx = p1[0] - p0[0];\n\t          var dy = p1[1] - p0[1];\n\t          angle = Math.atan2(dx, dy) * 180 / Math.PI; // The angle should be a non-negative number.\n\t\n\t          if (angle < 0) {\n\t            angle += 360;\n\t          } // Very small angles produce an unexpected result because they are\n\t          // converted to a scientific notation string.\n\t\n\t\n\t          if (angle < 1e-6) {\n\t            angle = 0;\n\t          }\n\t        } else {\n\t          gradientType = 'gradientradial';\n\t          var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n\t          var transform = zrEl.transform;\n\t          var scale = zrEl.scale;\n\t          var width = rectWidth;\n\t          var height = rectHeight;\n\t          focus = [// Percent in bounding rect\n\t          (p0[0] - rect.x) / width, (p0[1] - rect.y) / height];\n\t\n\t          if (transform) {\n\t            applyTransform(p0, p0, transform);\n\t          }\n\t\n\t          width /= scale[0] * Z;\n\t          height /= scale[1] * Z;\n\t          var dimension = mathMax(width, height);\n\t          shift = 2 * 0 / dimension;\n\t          expansion = 2 * fill.r / dimension - shift;\n\t        } // We need to sort the color stops in ascending order by offset,\n\t        // otherwise IE won't interpret it correctly.\n\t\n\t\n\t        var stops = fill.colorStops.slice();\n\t        stops.sort(function (cs1, cs2) {\n\t          return cs1.offset - cs2.offset;\n\t        });\n\t        var length = stops.length; // Color and alpha list of first and last stop\n\t\n\t        var colorAndAlphaList = [];\n\t        var colors = [];\n\t\n\t        for (var i = 0; i < length; i++) {\n\t          var stop = stops[i];\n\t          var colorAndAlpha = getColorAndAlpha(stop.color);\n\t          colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n\t\n\t          if (i === 0 || i === length - 1) {\n\t            colorAndAlphaList.push(colorAndAlpha);\n\t          }\n\t        }\n\t\n\t        if (length >= 2) {\n\t          var color1 = colorAndAlphaList[0][0];\n\t          var color2 = colorAndAlphaList[1][0];\n\t          var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n\t          var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n\t          el.type = gradientType;\n\t          el.method = 'none';\n\t          el.focus = '100%';\n\t          el.angle = angle;\n\t          el.color = color1;\n\t          el.color2 = color2;\n\t          el.colors = colors.join(','); // When colors attribute is used, the meanings of opacity and o:opacity2\n\t          // are reversed.\n\t\n\t          el.opacity = opacity2; // FIXME g_o_:opacity ?\n\t\n\t          el.opacity2 = opacity1;\n\t        }\n\t\n\t        if (gradientType === 'radial') {\n\t          el.focusposition = focus.join(',');\n\t        }\n\t      } else {\n\t        // FIXME Change from Gradient fill to color fill\n\t        setColorAndOpacity(el, fill, style.opacity);\n\t      }\n\t    }\n\t  };\n\t\n\t  var updateStrokeNode = function (el, style) {\n\t    // if (style.lineJoin != null) {\n\t    //     el.joinstyle = style.lineJoin;\n\t    // }\n\t    // if (style.miterLimit != null) {\n\t    //     el.miterlimit = style.miterLimit * Z;\n\t    // }\n\t    // if (style.lineCap != null) {\n\t    //     el.endcap = style.lineCap;\n\t    // }\n\t    if (style.lineDash != null) {\n\t      el.dashstyle = style.lineDash.join(' ');\n\t    }\n\t\n\t    if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n\t      setColorAndOpacity(el, style.stroke, style.opacity);\n\t    }\n\t  };\n\t\n\t  var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n\t    var isFill = type == 'fill';\n\t    var el = vmlEl.getElementsByTagName(type)[0]; // Stroke must have lineWidth\n\t\n\t    if (style[type] != null && style[type] !== 'none' && (isFill || !isFill && style.lineWidth)) {\n\t      vmlEl[isFill ? 'filled' : 'stroked'] = 'true'; // FIXME Remove before updating, or set `colors` will throw error\n\t\n\t      if (style[type] instanceof Gradient) {\n\t        remove(vmlEl, el);\n\t      }\n\t\n\t      if (!el) {\n\t        el = vmlCore.createNode(type);\n\t      }\n\t\n\t      isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n\t      append(vmlEl, el);\n\t    } else {\n\t      vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n\t      remove(vmlEl, el);\n\t    }\n\t  };\n\t\n\t  var points = [[], [], []];\n\t\n\t  var pathDataToString = function (path, m) {\n\t    var M = CMD.M;\n\t    var C = CMD.C;\n\t    var L = CMD.L;\n\t    var A = CMD.A;\n\t    var Q = CMD.Q;\n\t    var str = [];\n\t    var nPoint;\n\t    var cmdStr;\n\t    var cmd;\n\t    var i;\n\t    var xi;\n\t    var yi;\n\t    var data = path.data;\n\t    var dataLength = path.len();\n\t\n\t    for (i = 0; i < dataLength;) {\n\t      cmd = data[i++];\n\t      cmdStr = '';\n\t      nPoint = 0;\n\t\n\t      switch (cmd) {\n\t        case M:\n\t          cmdStr = ' m ';\n\t          nPoint = 1;\n\t          xi = data[i++];\n\t          yi = data[i++];\n\t          points[0][0] = xi;\n\t          points[0][1] = yi;\n\t          break;\n\t\n\t        case L:\n\t          cmdStr = ' l ';\n\t          nPoint = 1;\n\t          xi = data[i++];\n\t          yi = data[i++];\n\t          points[0][0] = xi;\n\t          points[0][1] = yi;\n\t          break;\n\t\n\t        case Q:\n\t        case C:\n\t          cmdStr = ' c ';\n\t          nPoint = 3;\n\t          var x1 = data[i++];\n\t          var y1 = data[i++];\n\t          var x2 = data[i++];\n\t          var y2 = data[i++];\n\t          var x3;\n\t          var y3;\n\t\n\t          if (cmd === Q) {\n\t            // Convert quadratic to cubic using degree elevation\n\t            x3 = x2;\n\t            y3 = y2;\n\t            x2 = (x2 + 2 * x1) / 3;\n\t            y2 = (y2 + 2 * y1) / 3;\n\t            x1 = (xi + 2 * x1) / 3;\n\t            y1 = (yi + 2 * y1) / 3;\n\t          } else {\n\t            x3 = data[i++];\n\t            y3 = data[i++];\n\t          }\n\t\n\t          points[0][0] = x1;\n\t          points[0][1] = y1;\n\t          points[1][0] = x2;\n\t          points[1][1] = y2;\n\t          points[2][0] = x3;\n\t          points[2][1] = y3;\n\t          xi = x3;\n\t          yi = y3;\n\t          break;\n\t\n\t        case A:\n\t          var x = 0;\n\t          var y = 0;\n\t          var sx = 1;\n\t          var sy = 1;\n\t          var angle = 0;\n\t\n\t          if (m) {\n\t            // Extract SRT from matrix\n\t            x = m[4];\n\t            y = m[5];\n\t            sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n\t            sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n\t            angle = Math.atan2(-m[1] / sy, m[0] / sx);\n\t          }\n\t\n\t          var cx = data[i++];\n\t          var cy = data[i++];\n\t          var rx = data[i++];\n\t          var ry = data[i++];\n\t          var startAngle = data[i++] + angle;\n\t          var endAngle = data[i++] + startAngle + angle; // FIXME\n\t          // var psi = data[i++];\n\t\n\t          i++;\n\t          var clockwise = data[i++];\n\t          var x0 = cx + cos(startAngle) * rx;\n\t          var y0 = cy + sin(startAngle) * ry;\n\t          var x1 = cx + cos(endAngle) * rx;\n\t          var y1 = cy + sin(endAngle) * ry;\n\t          var type = clockwise ? ' wa ' : ' at ';\n\t\n\t          if (Math.abs(x0 - x1) < 1e-4) {\n\t            // IE won't render arches drawn counter clockwise if x0 == x1.\n\t            if (Math.abs(endAngle - startAngle) > 1e-2) {\n\t              // Offset x0 by 1/80 of a pixel. Use something\n\t              // that can be represented in binary\n\t              if (clockwise) {\n\t                x0 += 270 / Z;\n\t              }\n\t            } else {\n\t              // Avoid case draw full circle\n\t              if (Math.abs(y0 - cy) < 1e-4) {\n\t                if (clockwise && x0 < cx || !clockwise && x0 > cx) {\n\t                  y1 -= 270 / Z;\n\t                } else {\n\t                  y1 += 270 / Z;\n\t                }\n\t              } else if (clockwise && y0 < cy || !clockwise && y0 > cy) {\n\t                x1 += 270 / Z;\n\t              } else {\n\t                x1 -= 270 / Z;\n\t              }\n\t            }\n\t          }\n\t\n\t          str.push(type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2));\n\t          xi = x1;\n\t          yi = y1;\n\t          break;\n\t\n\t        case CMD.R:\n\t          var p0 = points[0];\n\t          var p1 = points[1]; // x0, y0\n\t\n\t          p0[0] = data[i++];\n\t          p0[1] = data[i++]; // x1, y1\n\t\n\t          p1[0] = p0[0] + data[i++];\n\t          p1[1] = p0[1] + data[i++];\n\t\n\t          if (m) {\n\t            applyTransform(p0, p0, m);\n\t            applyTransform(p1, p1, m);\n\t          }\n\t\n\t          p0[0] = round(p0[0] * Z - Z2);\n\t          p1[0] = round(p1[0] * Z - Z2);\n\t          p0[1] = round(p0[1] * Z - Z2);\n\t          p1[1] = round(p1[1] * Z - Z2);\n\t          str.push( // x0, y0\n\t          ' m ', p0[0], comma, p0[1], // x1, y0\n\t          ' l ', p1[0], comma, p0[1], // x1, y1\n\t          ' l ', p1[0], comma, p1[1], // x0, y1\n\t          ' l ', p0[0], comma, p1[1]);\n\t          break;\n\t\n\t        case CMD.Z:\n\t          // FIXME Update xi, yi\n\t          str.push(' x ');\n\t      }\n\t\n\t      if (nPoint > 0) {\n\t        str.push(cmdStr);\n\t\n\t        for (var k = 0; k < nPoint; k++) {\n\t          var p = points[k];\n\t          m && applyTransform(p, p, m); // 不 round 会非常慢\n\t\n\t          str.push(round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k < nPoint - 1 ? comma : '');\n\t        }\n\t      }\n\t    }\n\t\n\t    return str.join('');\n\t  }; // Rewrite the original path method\n\t\n\t\n\t  Path.prototype.brushVML = function (vmlRoot) {\n\t    var style = this.style;\n\t    var vmlEl = this._vmlEl;\n\t\n\t    if (!vmlEl) {\n\t      vmlEl = vmlCore.createNode('shape');\n\t      initRootElStyle(vmlEl);\n\t      this._vmlEl = vmlEl;\n\t    }\n\t\n\t    updateFillAndStroke(vmlEl, 'fill', style, this);\n\t    updateFillAndStroke(vmlEl, 'stroke', style, this);\n\t    var m = this.transform;\n\t    var needTransform = m != null;\n\t    var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n\t\n\t    if (strokeEl) {\n\t      var lineWidth = style.lineWidth; // Get the line scale.\n\t      // Determinant of this.m_ means how much the area is enlarged by the\n\t      // transformation. So its square root can be used as a scale factor\n\t      // for width.\n\t\n\t      if (needTransform && !style.strokeNoScale) {\n\t        var det = m[0] * m[3] - m[1] * m[2];\n\t        lineWidth *= sqrt(abs(det));\n\t      }\n\t\n\t      strokeEl.weight = lineWidth + 'px';\n\t    }\n\t\n\t    var path = this.path || (this.path = new PathProxy());\n\t\n\t    if (this.__dirtyPath) {\n\t      path.beginPath();\n\t      this.buildPath(path, this.shape);\n\t      path.toStatic();\n\t      this.__dirtyPath = false;\n\t    }\n\t\n\t    vmlEl.path = pathDataToString(path, this.transform);\n\t    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\t\n\t    append(vmlRoot, vmlEl); // Text\n\t\n\t    if (style.text != null) {\n\t      this.drawRectText(vmlRoot, this.getBoundingRect());\n\t    } else {\n\t      this.removeRectText(vmlRoot);\n\t    }\n\t  };\n\t\n\t  Path.prototype.onRemove = function (vmlRoot) {\n\t    remove(vmlRoot, this._vmlEl);\n\t    this.removeRectText(vmlRoot);\n\t  };\n\t\n\t  Path.prototype.onAdd = function (vmlRoot) {\n\t    append(vmlRoot, this._vmlEl);\n\t    this.appendRectText(vmlRoot);\n\t  };\n\t  /***************************************************\n\t   * IMAGE\n\t   **************************************************/\n\t\n\t\n\t  var isImage = function (img) {\n\t    // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错\n\t    return typeof img === 'object' && img.tagName && img.tagName.toUpperCase() === 'IMG'; // return img instanceof Image;\n\t  }; // Rewrite the original path method\n\t\n\t\n\t  ZImage.prototype.brushVML = function (vmlRoot) {\n\t    var style = this.style;\n\t    var image = style.image; // Image original width, height\n\t\n\t    var ow;\n\t    var oh;\n\t\n\t    if (isImage(image)) {\n\t      var src = image.src;\n\t\n\t      if (src === this._imageSrc) {\n\t        ow = this._imageWidth;\n\t        oh = this._imageHeight;\n\t      } else {\n\t        var imageRuntimeStyle = image.runtimeStyle;\n\t        var oldRuntimeWidth = imageRuntimeStyle.width;\n\t        var oldRuntimeHeight = imageRuntimeStyle.height;\n\t        imageRuntimeStyle.width = 'auto';\n\t        imageRuntimeStyle.height = 'auto'; // get the original size\n\t\n\t        ow = image.width;\n\t        oh = image.height; // and remove overides\n\t\n\t        imageRuntimeStyle.width = oldRuntimeWidth;\n\t        imageRuntimeStyle.height = oldRuntimeHeight; // Caching image original width, height and src\n\t\n\t        this._imageSrc = src;\n\t        this._imageWidth = ow;\n\t        this._imageHeight = oh;\n\t      }\n\t\n\t      image = src;\n\t    } else {\n\t      if (image === this._imageSrc) {\n\t        ow = this._imageWidth;\n\t        oh = this._imageHeight;\n\t      }\n\t    }\n\t\n\t    if (!image) {\n\t      return;\n\t    }\n\t\n\t    var x = style.x || 0;\n\t    var y = style.y || 0;\n\t    var dw = style.width;\n\t    var dh = style.height;\n\t    var sw = style.sWidth;\n\t    var sh = style.sHeight;\n\t    var sx = style.sx || 0;\n\t    var sy = style.sy || 0;\n\t    var hasCrop = sw && sh;\n\t    var vmlEl = this._vmlEl;\n\t\n\t    if (!vmlEl) {\n\t      // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。\n\t      // vmlEl = vmlCore.createNode('group');\n\t      vmlEl = vmlCore.doc.createElement('div');\n\t      initRootElStyle(vmlEl);\n\t      this._vmlEl = vmlEl;\n\t    }\n\t\n\t    var vmlElStyle = vmlEl.style;\n\t    var hasRotation = false;\n\t    var m;\n\t    var scaleX = 1;\n\t    var scaleY = 1;\n\t\n\t    if (this.transform) {\n\t      m = this.transform;\n\t      scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n\t      scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n\t      hasRotation = m[1] || m[2];\n\t    }\n\t\n\t    if (hasRotation) {\n\t      // If filters are necessary (rotation exists), create them\n\t      // filters are bog-slow, so only create them if abbsolutely necessary\n\t      // The following check doesn't account for skews (which don't exist\n\t      // in the canvas spec (yet) anyway.\n\t      // From excanvas\n\t      var p0 = [x, y];\n\t      var p1 = [x + dw, y];\n\t      var p2 = [x, y + dh];\n\t      var p3 = [x + dw, y + dh];\n\t      applyTransform(p0, p0, m);\n\t      applyTransform(p1, p1, m);\n\t      applyTransform(p2, p2, m);\n\t      applyTransform(p3, p3, m);\n\t      var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n\t      var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n\t      var transformFilter = [];\n\t      transformFilter.push('M11=', m[0] / scaleX, comma, 'M12=', m[2] / scaleY, comma, 'M21=', m[1] / scaleX, comma, 'M22=', m[3] / scaleY, comma, 'Dx=', round(x * scaleX + m[4]), comma, 'Dy=', round(y * scaleY + m[5]));\n\t      vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0'; // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用\n\t\n\t      vmlElStyle.filter = imageTransformPrefix + '.Matrix(' + transformFilter.join('') + ', SizingMethod=clip)';\n\t    } else {\n\t      if (m) {\n\t        x = x * scaleX + m[4];\n\t        y = y * scaleY + m[5];\n\t      }\n\t\n\t      vmlElStyle.filter = '';\n\t      vmlElStyle.left = round(x) + 'px';\n\t      vmlElStyle.top = round(y) + 'px';\n\t    }\n\t\n\t    var imageEl = this._imageEl;\n\t    var cropEl = this._cropEl;\n\t\n\t    if (!imageEl) {\n\t      imageEl = vmlCore.doc.createElement('div');\n\t      this._imageEl = imageEl;\n\t    }\n\t\n\t    var imageELStyle = imageEl.style;\n\t\n\t    if (hasCrop) {\n\t      // Needs know image original width and height\n\t      if (!(ow && oh)) {\n\t        var tmpImage = new Image();\n\t        var self = this;\n\t\n\t        tmpImage.onload = function () {\n\t          tmpImage.onload = null;\n\t          ow = tmpImage.width;\n\t          oh = tmpImage.height; // Adjust image width and height to fit the ratio destinationSize / sourceSize\n\t\n\t          imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n\t          imageELStyle.height = round(scaleY * oh * dh / sh) + 'px'; // Caching image original width, height and src\n\t\n\t          self._imageWidth = ow;\n\t          self._imageHeight = oh;\n\t          self._imageSrc = image;\n\t        };\n\t\n\t        tmpImage.src = image;\n\t      } else {\n\t        imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n\t        imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n\t      }\n\t\n\t      if (!cropEl) {\n\t        cropEl = vmlCore.doc.createElement('div');\n\t        cropEl.style.overflow = 'hidden';\n\t        this._cropEl = cropEl;\n\t      }\n\t\n\t      var cropElStyle = cropEl.style;\n\t      cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n\t      cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n\t      cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx=' + -sx * dw / sw * scaleX + ',Dy=' + -sy * dh / sh * scaleY + ')';\n\t\n\t      if (!cropEl.parentNode) {\n\t        vmlEl.appendChild(cropEl);\n\t      }\n\t\n\t      if (imageEl.parentNode != cropEl) {\n\t        cropEl.appendChild(imageEl);\n\t      }\n\t    } else {\n\t      imageELStyle.width = round(scaleX * dw) + 'px';\n\t      imageELStyle.height = round(scaleY * dh) + 'px';\n\t      vmlEl.appendChild(imageEl);\n\t\n\t      if (cropEl && cropEl.parentNode) {\n\t        vmlEl.removeChild(cropEl);\n\t        this._cropEl = null;\n\t      }\n\t    }\n\t\n\t    var filterStr = '';\n\t    var alpha = style.opacity;\n\t\n\t    if (alpha < 1) {\n\t      filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n\t    }\n\t\n\t    filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n\t    imageELStyle.filter = filterStr;\n\t    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\t\n\t    append(vmlRoot, vmlEl); // Text\n\t\n\t    if (style.text != null) {\n\t      this.drawRectText(vmlRoot, this.getBoundingRect());\n\t    }\n\t  };\n\t\n\t  ZImage.prototype.onRemove = function (vmlRoot) {\n\t    remove(vmlRoot, this._vmlEl);\n\t    this._vmlEl = null;\n\t    this._cropEl = null;\n\t    this._imageEl = null;\n\t    this.removeRectText(vmlRoot);\n\t  };\n\t\n\t  ZImage.prototype.onAdd = function (vmlRoot) {\n\t    append(vmlRoot, this._vmlEl);\n\t    this.appendRectText(vmlRoot);\n\t  };\n\t  /***************************************************\n\t   * TEXT\n\t   **************************************************/\n\t\n\t\n\t  var DEFAULT_STYLE_NORMAL = 'normal';\n\t  var fontStyleCache = {};\n\t  var fontStyleCacheCount = 0;\n\t  var MAX_FONT_CACHE_SIZE = 100;\n\t  var fontEl = document.createElement('div');\n\t\n\t  var getFontStyle = function (fontString) {\n\t    var fontStyle = fontStyleCache[fontString];\n\t\n\t    if (!fontStyle) {\n\t      // Clear cache\n\t      if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n\t        fontStyleCacheCount = 0;\n\t        fontStyleCache = {};\n\t      }\n\t\n\t      var style = fontEl.style;\n\t      var fontFamily;\n\t\n\t      try {\n\t        style.font = fontString;\n\t        fontFamily = style.fontFamily.split(',')[0];\n\t      } catch (e) {}\n\t\n\t      fontStyle = {\n\t        style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n\t        variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n\t        weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n\t        size: parseFloat(style.fontSize || 12) | 0,\n\t        family: fontFamily || 'Microsoft YaHei'\n\t      };\n\t      fontStyleCache[fontString] = fontStyle;\n\t      fontStyleCacheCount++;\n\t    }\n\t\n\t    return fontStyle;\n\t  };\n\t\n\t  var textMeasureEl; // Overwrite measure text method\n\t\n\t  textContain.$override('measureText', function (text, textFont) {\n\t    var doc = vmlCore.doc;\n\t\n\t    if (!textMeasureEl) {\n\t      textMeasureEl = doc.createElement('div');\n\t      textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;' + 'padding:0;margin:0;border:none;white-space:pre;';\n\t      vmlCore.doc.body.appendChild(textMeasureEl);\n\t    }\n\t\n\t    try {\n\t      textMeasureEl.style.font = textFont;\n\t    } catch (ex) {// Ignore failures to set to invalid font.\n\t    }\n\t\n\t    textMeasureEl.innerHTML = ''; // Don't use innerHTML or innerText because they allow markup/whitespace.\n\t\n\t    textMeasureEl.appendChild(doc.createTextNode(text));\n\t    return {\n\t      width: textMeasureEl.offsetWidth\n\t    };\n\t  });\n\t  var tmpRect = new BoundingRect();\n\t\n\t  var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n\t    var style = this.style; // Optimize, avoid normalize every time.\n\t\n\t    this.__dirty && textHelper.normalizeTextStyle(style, true);\n\t    var text = style.text; // Convert to string\n\t\n\t    text != null && (text += '');\n\t\n\t    if (!text) {\n\t      return;\n\t    } // Convert rich text to plain text. Rich text is not supported in\n\t    // IE8-, but tags in rich text template will be removed.\n\t\n\t\n\t    if (style.rich) {\n\t      var contentBlock = textContain.parseRichText(text, style);\n\t      text = [];\n\t\n\t      for (var i = 0; i < contentBlock.lines.length; i++) {\n\t        var tokens = contentBlock.lines[i].tokens;\n\t        var textLine = [];\n\t\n\t        for (var j = 0; j < tokens.length; j++) {\n\t          textLine.push(tokens[j].text);\n\t        }\n\t\n\t        text.push(textLine.join(''));\n\t      }\n\t\n\t      text = text.join('\\n');\n\t    }\n\t\n\t    var x;\n\t    var y;\n\t    var align = style.textAlign;\n\t    var verticalAlign = style.textVerticalAlign;\n\t    var fontStyle = getFontStyle(style.font); // FIXME encodeHtmlAttribute ?\n\t\n\t    var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' ' + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n\t    textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign); // Transform rect to view space\n\t\n\t    var m = this.transform; // Ignore transform for text in other element\n\t\n\t    if (m && !fromTextEl) {\n\t      tmpRect.copy(rect);\n\t      tmpRect.applyTransform(m);\n\t      rect = tmpRect;\n\t    }\n\t\n\t    if (!fromTextEl) {\n\t      var textPosition = style.textPosition;\n\t      var distance = style.textDistance; // Text position represented by coord\n\t\n\t      if (textPosition instanceof Array) {\n\t        x = rect.x + parsePercent(textPosition[0], rect.width);\n\t        y = rect.y + parsePercent(textPosition[1], rect.height);\n\t        align = align || 'left';\n\t      } else {\n\t        var res = textContain.adjustTextPositionOnRect(textPosition, rect, distance);\n\t        x = res.x;\n\t        y = res.y; // Default align and baseline when has textPosition\n\t\n\t        align = align || res.textAlign;\n\t        verticalAlign = verticalAlign || res.textVerticalAlign;\n\t      }\n\t    } else {\n\t      x = rect.x;\n\t      y = rect.y;\n\t    }\n\t\n\t    x = textContain.adjustTextX(x, textRect.width, align);\n\t    y = textContain.adjustTextY(y, textRect.height, verticalAlign); // Force baseline 'middle'\n\t\n\t    y += textRect.height / 2; // var fontSize = fontStyle.size;\n\t    // 1.75 is an arbitrary number, as there is no info about the text baseline\n\t    // switch (baseline) {\n\t    // case 'hanging':\n\t    // case 'top':\n\t    //     y += fontSize / 1.75;\n\t    //     break;\n\t    //     case 'middle':\n\t    //         break;\n\t    //     default:\n\t    //     // case null:\n\t    //     // case 'alphabetic':\n\t    //     // case 'ideographic':\n\t    //     // case 'bottom':\n\t    //         y -= fontSize / 2.25;\n\t    //         break;\n\t    // }\n\t    // switch (align) {\n\t    //     case 'left':\n\t    //         break;\n\t    //     case 'center':\n\t    //         x -= textRect.width / 2;\n\t    //         break;\n\t    //     case 'right':\n\t    //         x -= textRect.width;\n\t    //         break;\n\t    // case 'end':\n\t    // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n\t    // break;\n\t    // case 'start':\n\t    // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n\t    // break;\n\t    // default:\n\t    //     align = 'left';\n\t    // }\n\t\n\t    var createNode = vmlCore.createNode;\n\t    var textVmlEl = this._textVmlEl;\n\t    var pathEl;\n\t    var textPathEl;\n\t    var skewEl;\n\t\n\t    if (!textVmlEl) {\n\t      textVmlEl = createNode('line');\n\t      pathEl = createNode('path');\n\t      textPathEl = createNode('textpath');\n\t      skewEl = createNode('skew'); // FIXME Why here is not cammel case\n\t      // Align 'center' seems wrong\n\t\n\t      textPathEl.style['v-text-align'] = 'left';\n\t      initRootElStyle(textVmlEl);\n\t      pathEl.textpathok = true;\n\t      textPathEl.on = true;\n\t      textVmlEl.from = '0 0';\n\t      textVmlEl.to = '1000 0.05';\n\t      append(textVmlEl, skewEl);\n\t      append(textVmlEl, pathEl);\n\t      append(textVmlEl, textPathEl);\n\t      this._textVmlEl = textVmlEl;\n\t    } else {\n\t      // 这里是在前面 appendChild 保证顺序的前提下\n\t      skewEl = textVmlEl.firstChild;\n\t      pathEl = skewEl.nextSibling;\n\t      textPathEl = pathEl.nextSibling;\n\t    }\n\t\n\t    var coords = [x, y];\n\t    var textVmlElStyle = textVmlEl.style; // Ignore transform for text in other element\n\t\n\t    if (m && fromTextEl) {\n\t      applyTransform(coords, coords, m);\n\t      skewEl.on = true;\n\t      skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0'; // Text position\n\t\n\t      skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0); // Left top point as origin\n\t\n\t      skewEl.origin = '0 0';\n\t      textVmlElStyle.left = '0px';\n\t      textVmlElStyle.top = '0px';\n\t    } else {\n\t      skewEl.on = false;\n\t      textVmlElStyle.left = round(x) + 'px';\n\t      textVmlElStyle.top = round(y) + 'px';\n\t    }\n\t\n\t    textPathEl.string = encodeHtmlAttribute(text); // TODO\n\t\n\t    try {\n\t      textPathEl.style.font = font;\n\t    } // Error font format\n\t    catch (e) {}\n\t\n\t    updateFillAndStroke(textVmlEl, 'fill', {\n\t      fill: style.textFill,\n\t      opacity: style.opacity\n\t    }, this);\n\t    updateFillAndStroke(textVmlEl, 'stroke', {\n\t      stroke: style.textStroke,\n\t      opacity: style.opacity,\n\t      lineDash: style.lineDash\n\t    }, this);\n\t    textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Attached to root\n\t\n\t    append(vmlRoot, textVmlEl);\n\t  };\n\t\n\t  var removeRectText = function (vmlRoot) {\n\t    remove(vmlRoot, this._textVmlEl);\n\t    this._textVmlEl = null;\n\t  };\n\t\n\t  var appendRectText = function (vmlRoot) {\n\t    append(vmlRoot, this._textVmlEl);\n\t  };\n\t\n\t  var list = [RectText, Displayable, ZImage, Path, Text]; // In case Displayable has been mixed in RectText\n\t\n\t  for (var i = 0; i < list.length; i++) {\n\t    var proto = list[i].prototype;\n\t    proto.drawRectText = drawRectText;\n\t    proto.removeRectText = removeRectText;\n\t    proto.appendRectText = appendRectText;\n\t  }\n\t\n\t  Text.prototype.brushVML = function (vmlRoot) {\n\t    var style = this.style;\n\t\n\t    if (style.text != null) {\n\t      this.drawRectText(vmlRoot, {\n\t        x: style.x || 0,\n\t        y: style.y || 0,\n\t        width: 0,\n\t        height: 0\n\t      }, this.getBoundingRect(), true);\n\t    } else {\n\t      this.removeRectText(vmlRoot);\n\t    }\n\t  };\n\t\n\t  Text.prototype.onRemove = function (vmlRoot) {\n\t    this.removeRectText(vmlRoot);\n\t  };\n\t\n\t  Text.prototype.onAdd = function (vmlRoot) {\n\t    this.appendRectText(vmlRoot);\n\t  };\n\t}\n\n/***/ }),\n/* 139 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar env = __webpack_require__(50);\n\t\n\tvar urn = 'urn:schemas-microsoft-com:vml';\n\tvar win = typeof window === 'undefined' ? null : window;\n\tvar vmlInited = false;\n\tvar doc = win && win.document;\n\t\n\tfunction createNode(tagName) {\n\t  return doCreateNode(tagName);\n\t} // Avoid assign to an exported variable, for transforming to cjs.\n\t\n\t\n\tvar doCreateNode;\n\t\n\tif (doc && !env.canvasSupported) {\n\t  try {\n\t    !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);\n\t\n\t    doCreateNode = function (tagName) {\n\t      return doc.createElement('<zrvml:' + tagName + ' class=\"zrvml\">');\n\t    };\n\t  } catch (e) {\n\t    doCreateNode = function (tagName) {\n\t      return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"zrvml\">');\n\t    };\n\t  }\n\t} // From raphael\n\t\n\t\n\tfunction initVML() {\n\t  if (vmlInited || !doc) {\n\t    return;\n\t  }\n\t\n\t  vmlInited = true;\n\t  var styleSheets = doc.styleSheets;\n\t\n\t  if (styleSheets.length < 31) {\n\t    doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');\n\t  } else {\n\t    // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n\t    styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');\n\t  }\n\t}\n\t\n\texports.doc = doc;\n\texports.createNode = createNode;\n\texports.initVML = initVML;\n\n/***/ }),\n/* 140 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrLog = __webpack_require__(22);\n\t\n\tvar vmlCore = __webpack_require__(139);\n\t\n\tvar _util = __webpack_require__(5);\n\t\n\tvar each = _util.each;\n\t\n\t/**\n\t * VML Painter.\n\t *\n\t * @module zrender/vml/Painter\n\t */\n\tfunction parseInt10(val) {\n\t  return parseInt(val, 10);\n\t}\n\t/**\n\t * @alias module:zrender/vml/Painter\n\t */\n\t\n\t\n\tfunction VMLPainter(root, storage) {\n\t  vmlCore.initVML();\n\t  this.root = root;\n\t  this.storage = storage;\n\t  var vmlViewport = document.createElement('div');\n\t  var vmlRoot = document.createElement('div');\n\t  vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n\t  vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n\t  root.appendChild(vmlViewport);\n\t  this._vmlRoot = vmlRoot;\n\t  this._vmlViewport = vmlViewport;\n\t  this.resize(); // Modify storage\n\t\n\t  var oldDelFromStorage = storage.delFromStorage;\n\t  var oldAddToStorage = storage.addToStorage;\n\t\n\t  storage.delFromStorage = function (el) {\n\t    oldDelFromStorage.call(storage, el);\n\t\n\t    if (el) {\n\t      el.onRemove && el.onRemove(vmlRoot);\n\t    }\n\t  };\n\t\n\t  storage.addToStorage = function (el) {\n\t    // Displayable already has a vml node\n\t    el.onAdd && el.onAdd(vmlRoot);\n\t    oldAddToStorage.call(storage, el);\n\t  };\n\t\n\t  this._firstPaint = true;\n\t}\n\t\n\tVMLPainter.prototype = {\n\t  constructor: VMLPainter,\n\t  getType: function () {\n\t    return 'vml';\n\t  },\n\t\n\t  /**\n\t   * @return {HTMLDivElement}\n\t   */\n\t  getViewportRoot: function () {\n\t    return this._vmlViewport;\n\t  },\n\t  getViewportRootOffset: function () {\n\t    var viewportRoot = this.getViewportRoot();\n\t\n\t    if (viewportRoot) {\n\t      return {\n\t        offsetLeft: viewportRoot.offsetLeft || 0,\n\t        offsetTop: viewportRoot.offsetTop || 0\n\t      };\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 刷新\n\t   */\n\t  refresh: function () {\n\t    var list = this.storage.getDisplayList(true, true);\n\t\n\t    this._paintList(list);\n\t  },\n\t  _paintList: function (list) {\n\t    var vmlRoot = this._vmlRoot;\n\t\n\t    for (var i = 0; i < list.length; i++) {\n\t      var el = list[i];\n\t\n\t      if (el.invisible || el.ignore) {\n\t        if (!el.__alreadyNotVisible) {\n\t          el.onRemove(vmlRoot);\n\t        } // Set as already invisible\n\t\n\t\n\t        el.__alreadyNotVisible = true;\n\t      } else {\n\t        if (el.__alreadyNotVisible) {\n\t          el.onAdd(vmlRoot);\n\t        }\n\t\n\t        el.__alreadyNotVisible = false;\n\t\n\t        if (el.__dirty) {\n\t          el.beforeBrush && el.beforeBrush();\n\t          (el.brushVML || el.brush).call(el, vmlRoot);\n\t          el.afterBrush && el.afterBrush();\n\t        }\n\t      }\n\t\n\t      el.__dirty = false;\n\t    }\n\t\n\t    if (this._firstPaint) {\n\t      // Detached from document at first time\n\t      // to avoid page refreshing too many times\n\t      // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变\n\t      this._vmlViewport.appendChild(vmlRoot);\n\t\n\t      this._firstPaint = false;\n\t    }\n\t  },\n\t  resize: function (width, height) {\n\t    var width = width == null ? this._getWidth() : width;\n\t    var height = height == null ? this._getHeight() : height;\n\t\n\t    if (this._width != width || this._height != height) {\n\t      this._width = width;\n\t      this._height = height;\n\t      var vmlViewportStyle = this._vmlViewport.style;\n\t      vmlViewportStyle.width = width + 'px';\n\t      vmlViewportStyle.height = height + 'px';\n\t    }\n\t  },\n\t  dispose: function () {\n\t    this.root.innerHTML = '';\n\t    this._vmlRoot = this._vmlViewport = this.storage = null;\n\t  },\n\t  getWidth: function () {\n\t    return this._width;\n\t  },\n\t  getHeight: function () {\n\t    return this._height;\n\t  },\n\t  clear: function () {\n\t    if (this._vmlViewport) {\n\t      this.root.removeChild(this._vmlViewport);\n\t    }\n\t  },\n\t  _getWidth: function () {\n\t    var root = this.root;\n\t    var stl = root.currentStyle;\n\t    return (root.clientWidth || parseInt10(stl.width)) - parseInt10(stl.paddingLeft) - parseInt10(stl.paddingRight) | 0;\n\t  },\n\t  _getHeight: function () {\n\t    var root = this.root;\n\t    var stl = root.currentStyle;\n\t    return (root.clientHeight || parseInt10(stl.height)) - parseInt10(stl.paddingTop) - parseInt10(stl.paddingBottom) | 0;\n\t  }\n\t}; // Not supported methods\n\t\n\tfunction createMethodNotSupport(method) {\n\t  return function () {\n\t    zrLog('In IE8.0 VML mode painter not support method \"' + method + '\"');\n\t  };\n\t} // Unsupported methods\n\t\n\t\n\teach(['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'], function (name) {\n\t  VMLPainter.prototype[name] = createMethodNotSupport(name);\n\t});\n\tvar _default = VMLPainter;\n\tmodule.exports = _default;\n\n/***/ })\n/******/ ])\n});\n;\n"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 01e449601b00a4f733d2","/**\r\n * Export fishTopo as CommonJS module\r\n */\r\nmodule.exports = require('./lib/fish-topo-flow/lib/FishTopoFlow.js');\r\n//兼容IE8 引入VML 如果不需要兼容IE8请删除\r\nrequire('zrender/lib/vml/vml');\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./index.flow.js\n// module id = 1\n// module chunks = 0","/**\r\n * fishtopo流程实例\r\n * @class fish.topo.FishTopoFlow\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *      var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n */\r\n\r\n/**\r\n * @event click\r\n * 节点或者线段的click事件\r\n * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *          this.fishTopo.on(\"click\", function(event) {\r\n *              console.log(\"点击的是：\" + event.target.model.get('elementType'));\r\n *          });\r\n */\r\n\r\n/**\r\n * @event dblclick\r\n * 节点或者线段的双击事件\r\n * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *          this.fishTopo.on(\"dblclick\", function(event) {\r\n *              console.log(\"双击的是：\" + event.target.model.get('elementType'));\r\n *          });\r\n */\r\n\r\n/**\r\n * @event create\r\n * 节点与线段创建完毕的事件\r\n * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *          this.fishTopo.on(\"create\", function(e) {\r\n *               if (me.fishTopo.Flow.isLink(e.target.model)) {\r\n *                  console.log(\"线段创建完毕：\" + e.target.model);\r\n *               }\r\n *          });\r\n */\r\n\r\n/**\r\n * @event delete\r\n * 节点与线段创建完毕的事件\r\n * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *          //节点删除完毕事件\r\n *          this.fishTopo.on(\"delete\", function(event) {\r\n *              console.log(\"删除的是：\" + event.target.model.get('elementType'));\r\n *          });\r\n */\r\n\r\n/**\r\n * @event dropDrag\r\n * 节点移动完成的事件\r\n * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *          //节点移动结束事件\r\n            this.fishTopo.on(\"dropDrag\", function(event) {\r\n                console.log(\"移动的节点是：\"+event.target.model.get('elementType'));\r\n            });\r\n */\r\n\r\n\r\n\r\n\r\n    require(\"../../fish-topo-core/lib/polyfill.js\");\r\n    var graphic = require(\"../../fish-topo-core/lib/graphic.js\");\r\n    var Minimap = require(\"../../fish-topo-core/lib/minimap.js\");\r\n    var util = require(\"../../fish-topo-core/lib/util.js\");\r\n    var Point = require(\"../../fish-topo-core/lib/Point.js\");\r\n    var ExtensionAPI = require('./ExtensionApi');\r\n    var Eventful = require('zrender/lib/mixin/Eventful');\r\n    var zrender = require('zrender/lib/zrender');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var OperationNode = require(\"../../fish-topo-core/lib/manager/OperationNode.js\");\r\n    var FlowConnectionManager = require(\"./manager/FlowConnectionManager.js\");\r\n    var FlowUtil = require(\"./util/FlowUtil.js\");\r\n    var Constants = require(\"./util/FlowConstants.js\");\r\n    var Model = require(\"../../fish-topo-core/lib/model.js\");\r\n    var eventTool = require('zrender/lib/core/event');\r\n    var Connector = require(\"../../fish-topo-core/lib/shapes/Connector.js\");\r\n    var LineOperationManager = require(\"../../fish-topo-core/lib/manager/LineOperationManager.js\");\r\n    var Flow = require(\"./Flow.js\");\r\n    var flowNode = require(\"./node/flowNode\");\r\n    var GroupNode = require(\"./node/GroupNode\");\r\n    var flowLink = require(\"./link/flowLink\");\r\n    var layout = require(\"./layout/layout\");\r\n    var textContain = require('zrender/lib/contain/text');\r\n    var ImagePool = require(\"../../fish-topo-core/lib/ImagePool.js\");\r\n    var ToolTipView = require(\"./tooltip/TooltipView\");\r\n    var TooltipModel = require(\"./tooltip/TooltipModel\");\r\n    var actions = {};\r\n    var keyCode = {ENTER:13, ESCAPE:27}\r\n    function FishTopoFlow(dom, opts) {\r\n        this.id;\r\n        this.group = null;\r\n        this._dom = dom;\r\n        this.nowZoom = 1;\r\n        this.canScale = true;\r\n        this.eagleEye = false;\r\n        this.eagleEyeNode = null;\r\n        this.initScaleRatio = 1;\r\n        this.operationNode = null;\r\n        this.step = 0;//前进后退计步数\r\n        this.stepJson = [];//存放每步的json\r\n        this.selectedNode = null;\r\n        this.allNodes = [];\r\n        this.minimap = null;\r\n        this._api = new ExtensionAPI(this);\r\n        this.connectionManager = new FlowConnectionManager(this._api);\r\n        this.lineOperationManager = new LineOperationManager(this.connectionManager,this._api);\r\n        this._zr = zrender.init(dom, {\r\n            renderer: opts.renderer || 'canvas',\r\n            devicePixelRatio: opts.devicePixelRatio\r\n        });\r\n        this._tooltipView = new ToolTipView(new TooltipModel(opts.tooltip),this._api);\r\n        this.Shape = graphic;\r\n        this.lineOpt = {};  //初始的线段配置信息\r\n        this.selectedNodes = [];\r\n        this.model = new Model({});\r\n        this.model.set(Constants.ELEMENT_TYPE, \"scene\");\r\n        this.model.set(Constants.MODE, \"normal\");\r\n        this.options = opts;\r\n        this.cursorMap = {\r\n            tl: 'nw-resize',\r\n            tr: 'ne-resize',\r\n            bl: 'sw-resize',\r\n            br: 'se-resize',\r\n            mtr:'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAAYFBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD6T+iNAAAAH3RSTlMA7sUMoYXnEkYYzaaTjQiAQCweBcG7fvnULh2ZdjMy6Fzd7wAAALJJREFUGNN1kFkOwzAIBQHvW/Y6Sbfc/5Y1ltqoljIf2BohBA8qU096xeV5L/+uFH4SpsGAGSKmThCyMz64Ud38Te0meIpHcTP1ndTKvqzSUuQILFMQJAUwIngBLCd0UrJhSRGqzHHU3FcHBVMokqxS38YNGQLQbhmgZZ23sVEXnXVmS467Fq0892SSLaW5SHrN9rz9bXv9EHIB+E9pdMG7Ys48Z2cjxo7FL3k8kPIE13wAmEUIO2ML9YMAAAAASUVORK5CYII=) 10 10, auto'\r\n        }; // 节点控制点鼠标信息(上左，上右，下左，下右，旋转)\r\n        this.cursorMaps = [\r\n            'n-resize',\r\n            'ne-resize',\r\n            'e-resize',\r\n            'se-resize',\r\n            's-resize',\r\n            'sw-resize',\r\n            'w-resize',\r\n            'nw-resize'\r\n        ]\r\n        this.cursorOffset = {\r\n            tr: 1,\r\n            br: 3,\r\n            bl: 5,\r\n            tl: 7\r\n        }\r\n        Eventful.call(this);\r\n    }\r\n\r\n    var fishTopoProto = FishTopoFlow.prototype;\r\n\r\n    /**\r\n     * 获取 fishTopo 实例容器的 dom 节点\r\n     * @return {HTMLElement}\r\n     */\r\n    fishTopoProto.getDom = function () {\r\n        return this._dom;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    fishTopoProto.getZr = function () {\r\n        return this._zr;\r\n    };\r\n    /**\r\n     * 获取 fishTopo 实例容器的宽度。\r\n     * @return {number}\r\n     */\r\n    fishTopoProto.getWidth = function () {\r\n        return this._zr.getWidth();\r\n    };\r\n\r\n    /**\r\n     * 获取 fishTopo 实例容器的高度。\r\n     * @return {number}\r\n     */\r\n    fishTopoProto.getHeight = function () {\r\n        return this._zr.getHeight();\r\n    };\r\n\r\n\r\n    /**\r\n     * 当前实例是否已经被释放。\r\n     * @return {boolean}\r\n     */\r\n    fishTopoProto.isDisposed = function () {\r\n        return this._disposed;\r\n    };\r\n\r\n    /**\r\n     * 释放 当前实例\r\n     */\r\n    fishTopoProto.dispose = function () {\r\n        this._disposed = true;\r\n\r\n        this._zr.dispose();\r\n\r\n        instances[this.id] = null;\r\n    };\r\n\r\n\r\n    /**\r\n     * 调整尺寸  在窗口大小发生改变时需要手工调用\r\n     * @param {number} width 宽度\r\n     * @param {number} height 高度\r\n     */\r\n    fishTopoProto.resize = function () {\r\n        this._zr.resize();\r\n\r\n    };\r\n\r\n    fishTopoProto.dispatchAction = function (payload) {\r\n        if(!actions[payload.type]) {\r\n            return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method option\r\n     * 修改画布的选项\r\n     * @param {String} key 键  如：roam linkModify  textEditable等\r\n     * @param {Boolean|String|Function} value 选项值\r\n     */\r\n    fishTopoProto.option = function(key,value) {\r\n        var model = new Model(this.options);\r\n        if (arguments.length === 0) {\r\n            return zrUtil.clone(this.options);\r\n        } else if (arguments.length === 1) {\r\n            return model.get(key);\r\n        } else if (arguments.length === 2) {\r\n            if (key === \"roam\") {\r\n                this.setRoam(value);\r\n            }\r\n            return model.set(key,value);\r\n        }\r\n    }\r\n\r\n\r\n    fishTopoProto.init = function () {\r\n        var MOUSE_EVENT_NAMES = 'ontouchstart' in window ? ['touchstart', 'touchmove', 'touchend'] : ['mousedown', 'mousemove', 'mouseup'];\r\n        this.group = new graphic.Group();\r\n        this.group.model = this.model;\r\n        this.group.isBg = true;\r\n        this._zr.add(this.group);\r\n\r\n        //是否允许鼠标滚轮放大缩小\r\n        if (this.options.roam === true) {\r\n            this.zrScale();\r\n        }\r\n\r\n        this.connectionManager.connectors = [];\r\n        //mouseup 会在各个node或线的click事件之点执行  在选中节点或线前 先清空选中效果\r\n        this._zr.on(\"mouseup\", function (e) { // clearSelect\r\n            // 1. 清空节点的选中效果\r\n            // this._removeOperationNode();\r\n            // 2. 点击的线 ，则直接返回\r\n            var shape = e.target;\r\n            if (shape && shape.model && Flow.isLink(shape.model)) {\r\n                return;\r\n            }\r\n            if (shape && shape.connector instanceof Connector) {\r\n                return;\r\n            }\r\n            // 3. 清空连接线\r\n            this.connectionManager.clearSelectCon();\r\n            // 4. 点击的是线上操作按钮，则直接返回\r\n            if (shape && shape._isLineOperationIcon && shape._isLineOperationIcon == true) {\r\n                return;\r\n            }\r\n            // 5.隐藏线上操作图标\r\n            this.lineOperationManager.hideAllLineOperation();\r\n        }.bind(this));\r\n\r\n        this._zr.on(\"click\", function (e) {\r\n            // 如果点击了控制点，则不会取消选中状态(控制点不在节点范围内)\r\n            var target = e.target || {};\r\n            var type = target.type;\r\n            if (type !== 'ConnectControlLine' && type !== 'ConnectControl') {\r\n                this.hideConnectorPoint();\r\n                this.hideConnectorControl();\r\n                this._removeOperationNode();\r\n                var nodeTarget = e.target;\r\n                var shape;\r\n                if (nodeTarget) {\r\n                    shape = nodeTarget.model;\r\n                }\r\n                if ((nodeTarget && shape && Flow.isLink(shape)) || (nodeTarget && shape && Flow.isNode(\r\n                        shape))) {\r\n                    return;\r\n                }\r\n            }\r\n            var params = {};\r\n            params.event = e;\r\n            params.type = \"click\";\r\n            params.target = this;\r\n            this._api.trigger(params.type, params);\r\n        }.bind(this));\r\n\r\n        // mouseMode统一在mousedown事件里判断\r\n        this._zr.on(\"mousedown\", function (e) {\r\n            if (this.options.mouseMode === 'drag-select') {\r\n                if ((e.target && e.target.model) ||\r\n                    (e.target && e.target.lineType && e.target.parent) ||\r\n                    (e.target && e.target.connector instanceof Connector) ||\r\n                    (e.target && e.target instanceof graphic.Circle) ||\r\n                    (e.target && e.target.name === \"GROUP_RECT_NAME\")) {\r\n                    return;\r\n                } else {\r\n                    this.hideConnectorPoint();\r\n                    this.hideConnectorControl();\r\n                    this._removeOperationNode();\r\n                    this._dragSelect(e.target, e.offsetX, e.offsetY);\r\n                }\r\n            }\r\n\r\n            if (this.options.mouseMode === 'drag-move') {\r\n                if ((e.target && e.target.model) || (e.target && e.target.lineType && e.target.parent) ||\r\n                    (e.target && e.target.connector instanceof Connector) || (e.target && e.target instanceof graphic\r\n                        .Circle)) {\r\n                    return;\r\n                } else {\r\n                    this._groupDragHandler(e.offsetX, e.offsetY);\r\n                }\r\n            }\r\n        }.bind(this));\r\n\r\n        this.on('conPointsGroup:click', function (argument) {\r\n            this.lineOperationManager.bindOperation(argument.lineNode);\r\n        }.bind(this));\r\n\r\n        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n            this._zr.on(eveName, function (e) {\r\n                var params = {};\r\n                params.event = e;\r\n                params.type = eveName;\r\n                params.target = this;\r\n                this._api.trigger(params.type, params);\r\n            }, this);\r\n        }, this);\r\n    };\r\n\r\n    fishTopoProto.setRoam = function (value) {\r\n        this._zr.off(\"mousewheel\");//禁止用户缩放画布\r\n        if (value === true) {\r\n            this.zrScale();\r\n        }\r\n    }\r\n\r\n    fishTopoProto.addGroupModel = function (groupNode) {\r\n        var that = this;\r\n        groupNode.eachChild(function (node) {\r\n            if (node.model) { \r\n                if (node instanceof GroupNode) {\r\n                    if (node.model && !node.model.option.childs && node.children().length > 0) {\r\n                        var childs = [];\r\n                        node.eachChild(function (childNode) {\r\n                            if (childNode.model) {\r\n                                if (childNode instanceof GroupNode) {\r\n                                    if (!childNode.model.option.childs && childNode.children().length > 0) {\r\n                                        that.addGroupModel(node);\r\n                                    }\r\n                                }\r\n                                childs.push(childNode.model.option);\r\n                                node.model.option.childs = childs;\r\n                            }\r\n                        })\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @method toJson\r\n     * 导出json\r\n     * @return {Object} json对象\r\n     */\r\n    fishTopoProto.toJson = function () {\r\n        this.addGroupModel(this.group);\r\n        return FlowUtil.toJson(this.model, this.group);\r\n    }\r\n\r\n    /**\r\n     * @method fromJson\r\n     * 导入json\r\n     * @param  {Object} json对象\r\n     * @param {Boolean} isNoCount 是否需要step计数，默认是需要计数\r\n     */\r\n    fishTopoProto.fromJson = function (json, isNoCount) {\r\n        this.clear(true);\r\n        var model = new Model(json);\r\n        this.setBackground(model.get(Constants.BACKGROUND));\r\n        var layoutRootNode = [];\r\n        FlowUtil.fromJson(this, this.group, model.get(Constants.CHILDS), false, layoutRootNode, isNoCount);\r\n        // for (var i = 0; i < layoutRootNode.length; i++) {\r\n        //     this.layoutNode(\"tree\", {\r\n        //         \"node\": layoutRootNode[i],\r\n        //         \"type\": layoutRootNode[i].treeType\r\n        //     });\r\n        // }\r\n    };\r\n    /**\r\n     * 添加节点或线段到画布 同add方法\r\n     * @method addNode\r\n     * @param {Object} node createNode或createLink返回的对象\r\n     * @param {Object} [option] 参数对象\r\n     * @param {Boolean} [option.trigger] 是否触发 beforeCreate事件\r\n     * @returns {Object} 返回添加成功的节点 ，如被用户取消之类则 返回null\r\n     */\r\n    /**\r\n     * 添加节点或线段到画布 同addNode方法\r\n     * @method add\r\n     * @param {Object} node createNode或createLink返回的对象\r\n     * @param {Object} [option] 参数对象\r\n     * @param {Boolean} isNoCount 是否需要step计数，默认是需要计数\r\n     * @param {Boolean} [option.trigger] 是否触发 beforeCreate事件\r\n     * @returns {Object} 返回添加成功的节点 ，如被用户取消之类则 返回null\r\n     */\r\n    fishTopoProto.add = fishTopoProto.addNode = function (node, options, isNoCount) {\r\n        if (!node) return null;\r\n\r\n        var opt = options || {};\r\n        if(opt.trigger !==false && (!this._trigger('beforeCreate', {target:node}))) {\r\n            return null;\r\n        }\r\n        if (node instanceof Connector) {\r\n            this.addConnectorAttrEvent(node);\r\n        } else {\r\n            if (Flow.isGroupNode(node)) {\r\n                node.willRender(this._api);\r\n                var groupOptions = node.model.get(Constants.OPTIONS);\r\n                if (groupOptions.mergedImage) {\r\n                    var groupReplaceImage = new flowNode.Image({\r\n                        style: {\r\n                            image: groupOptions.mergedImage,\r\n                            text: groupOptions.style.text,\r\n                            textPosition: 'bottom'\r\n                        },\r\n                        position: [-5000, -5000]\r\n                    });\r\n                    this.drag(groupReplaceImage);\r\n                    node._relationImage = groupReplaceImage;\r\n                    this.group.add(groupReplaceImage);\r\n                    setTimeout(function () {\r\n                        groupReplaceImage.hide();\r\n                    }, 300);\r\n                    node.on('dblclick', function () {\r\n                        node.merged();\r\n                    })\r\n                }\r\n                //遍历组中所有节点\r\n                node.each(function (child) {\r\n                    this._addGroupNode(node,child);\r\n                }, this);\r\n            }\r\n            this.addNodeAttrEvent(node, true);\r\n        }\r\n        this._trigger(\"create\", {target:node});\r\n\r\n        if (node.hoverStyle) {\r\n            graphic.setHoverStyle(node);\r\n        }\r\n\r\n        this.group.add(node);\r\n        if (node.relative) {  //必须在加入画布后执行\r\n            this._handleRelativePostion(node)\r\n        }\r\n        if (node.hoverAnimation && this.options.isAnimationEnabled) {\r\n            flowNode.addHoverAnimation(node);\r\n        }\r\n        if (isNoCount != true) {\r\n            this.stepCounter();\r\n        }\r\n        return node;\r\n    };\r\n\r\n\r\n    fishTopoProto._addGroupNode = function(groupNode, child){\r\n        if (child instanceof Connector) {\r\n            this.addConnectorAttrEvent(child);\r\n        } else {\r\n            this.addNodeAttrEvent(child, groupNode.options.childDraggable);\r\n            if (util.isUndefined(child.selectable)) {\r\n                child.selectable = false;  //组内默认不可选中\r\n            }\r\n            if (child.relative) {\r\n                this._handleRelativePostion(child)\r\n            }\r\n            if (child.hoverStyle) {\r\n                graphic.setHoverStyle(child);\r\n            }\r\n        }\r\n        this._trigger(\"create\", {target:child});\r\n    };\r\n\r\n    /**\r\n     * 在链路连线上添加文本\r\n     * @method addTextOnChain\r\n     * @param {Object} line 链路连线对象\r\n     * @param {Object} [text] 数组类型，表示多个文本的数据。数组元素可以为字符串，表示每个文本的名字；也可以是个对象，对象中必须指定text属性，其值为文本的名字\r\n     * @returns {Object} 返回 链路连线对象\r\n     */\r\n    fishTopoProto.addTextOnChain = function (line, text) {\r\n        if (line.options.style.lineType === Connector.TYPE_CHAIN) {\r\n            this.connectionManager.removeLine(line, this._getParentZr(line));\r\n            line.options.text.text.push(text);\r\n            line.options.textContextMenu = line.opt.textContextMenu;   //不然左键菜单没有了！！！\r\n            var slink = new flowLink.Chain(line.startNode, line.endNode, line.options);\r\n            this.add(slink);\r\n            return slink;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 在链路连线上删除指定文本\r\n     * @method delTextOnChain\r\n     * @param {Object} txtObj 文本对象\r\n     * @returns {Object} 返回 链路连线对象\r\n     */\r\n    fishTopoProto.delTextOnChain = function (txtObj) {\r\n        var id = txtObj.id, line = txtObj.parent, pos;\r\n        if (line.options.style.lineType === Connector.TYPE_CHAIN && zrUtil.isArray(line.options.text.text)) {\r\n            line.options.text.text.forEach(function (v, i) {\r\n                if (v.textId === id) {\r\n                    pos = i;\r\n                }\r\n            });\r\n            line.options.text.text.splice(pos, 1);\r\n\r\n            this.connectionManager.removeLine(line, this._getParentZr(line));\r\n            line.options.textContextMenu = line.opt.textContextMenu;   //不然左键菜单没有了！！！\r\n            var slink = new flowLink.Chain(line.startNode, line.endNode, line.options);\r\n            this.add(slink);\r\n            return slink;\r\n        }\r\n    }\r\n    /**\r\n     * 在链路连线上修改指定文本\r\n     * @method delTextOnChain\r\n     * @param {Object} txtObj 文本对象\r\n     * @param {String} name 修改的文本\r\n     * @returns {Object} 返回 链路连线对象\r\n     */\r\n    fishTopoProto.modifyTextOnChain = function (txtObj, name) {\r\n        var id = txtObj.id, line = txtObj.parent;\r\n        if (line.options.style.lineType === Connector.TYPE_CHAIN && zrUtil.isArray(line.options.text.text)) {\r\n            line.options.text.text.forEach(function (v, i) {\r\n                if (v.textId === id) {\r\n                    v.text = name;\r\n                }\r\n            });\r\n            txtObj.setStyle(\"text\", name);\r\n        }\r\n    }\r\n    /**\r\n     * 显示隐藏指定节点的连线\r\n     * @method toggleAllConNodeLine\r\n     * @param {Object} node 节点对象\r\n     * @param {String} type 显示还是隐藏 [hide|show]\r\n     */\r\n    fishTopoProto.toggleAllConNodeLine = function (node, type) {\r\n        var allLine = this.connectionManager.connectors;\r\n        if (zrUtil.isArray(allLine)) {\r\n            allLine.forEach(function (line) {\r\n                if (line.startNode.id === node.id) {\r\n                    type === 'hide' ? line.hide() : line.show();\r\n                }\r\n            })\r\n        }\r\n    };\r\n\r\n    fishTopoProto.addConnectorAttrEvent = function (connector) {\r\n        var that = this;\r\n        var chainLine = null;\r\n        if (connector.options.style.lineType === Connector.TYPE_CHAIN) {\r\n            var key = this.connectionManager.getTwoNodeId(connector.startNode, connector.endNode, connector.options.position);\r\n            var cons = this.connectionManager.connectorMap.get(key);\r\n            var orignText = [].concat(connector.options.text.text);\r\n            if (cons.length > 0) {\r\n                cons.forEach(function (v) {\r\n                    if (v.options.style.lineType === Connector.TYPE_CHAIN) {\r\n                        orignText = orignText.concat(v.options.text.text);\r\n                        chainLine = v;\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        //如果已存在链路\r\n        if (chainLine) {\r\n            connector.options.text.text = orignText;\r\n            this.connectionManager.removeLine(chainLine, this._getParentZr(chainLine));\r\n        }\r\n        connector.options.isEdit = !!this.options.linkModify;\r\n        connector.on(\"mousedown\", function () {\r\n            this.connectionManager.connectorForbidEdit(!this.options.linkModify);\r\n            this.isNode = false;\r\n        }.bind(this));\r\n        this.connectionManager.add(connector);\r\n        //支持双击编辑\r\n        connector.on(\"dblclick\", function () {\r\n            if (typeof this.options.text.textEditable == \"undefined\") {\r\n                if (that.options.textEditable) {\r\n                    that.connectorEdit(this);\r\n                }\r\n            } else {\r\n                if (this.options.text.textEditable) {\r\n                    that.connectorEdit(this);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    fishTopoProto.addNodeAttrEvent = function (node, childDraggable) {\r\n        var that = this;\r\n        if (childDraggable) {\r\n            this.drag(node);\r\n        }\r\n\r\n        node.attr(\"operationIcons\", node.model.get('options.operationIcons'));\r\n\r\n        //侦听节点的click dblclick事件，选中，并派发出去\r\n        node.on('click', function (event) {\r\n            var targeNode = this;\r\n            that.nodeClickHandler(targeNode);\r\n\r\n            var params = {};\r\n            params.event = event;\r\n            params.type = 'click';\r\n            params.target = targeNode;\r\n            that._api.trigger(params.type, params);\r\n            event.cancelBubble = true;\r\n\r\n            // 判断一下是否是组内成组的点击事件，如果是的话，那组也也派发一下\r\n            if (Flow.isInGroup(targeNode)) {\r\n                var parentNode = targeNode.parent;\r\n                if (!parentNode.childDraggable) {\r\n                    parentNode.trigger('click', {event:event, type:'click',target:parentNode});\r\n                }\r\n            }\r\n        });\r\n        node.on('dblclick', function (e) {\r\n            var targeNode = this;\r\n            if (!targeNode.style || (typeof targeNode.style.textEditable == \"undefined\")) {\r\n                if (that.options.textEditable) {\r\n                    that.nodeEdit(targeNode);\r\n                }\r\n            } else {\r\n                if (targeNode.style.textEditable) {\r\n                    that.nodeEdit(targeNode);\r\n                }\r\n            }\r\n            var params = {};\r\n            params.event = e;\r\n            params.type = 'dblclick';\r\n            params.target = targeNode;\r\n            that._api.trigger(params.type, params);\r\n\r\n            e.cancelBubble = true;\r\n        });\r\n\r\n        this.allNodes.push(node);\r\n    }\r\n\r\n    fishTopoProto._handleRelativePostion = function(node) {\r\n        var parentEl = node.parent;\r\n        var containerInfo = parentEl === this.group\r\n            ? {\r\n                width:this._api.getWidth(),\r\n                height:this._api.getHeight()\r\n            }\r\n            : {\r\n                width:parentEl.getBoundingRect().width,\r\n                height:parentEl.getBoundingRect().height\r\n            }\r\n        layout.positionElement(node, node.relative, containerInfo, node.relative.padding, {boundingMode:node.relative.bounding||'all'});\r\n    }\r\n\r\n    fishTopoProto._getParentZr = function(node) {\r\n        var parentZr = null;\r\n        if (node && node.parent) {\r\n            parentZr = node.parent;\r\n        } else {\r\n            parentZr = this.group;\r\n        }\r\n        return parentZr;\r\n    }\r\n\r\n    fishTopoProto._removeOperationNode = function() {\r\n        if (this.operationNode) {\r\n            this.group.remove(this.operationNode);\r\n            this.operationNode.cleanup();\r\n            this.operationNode = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 清空当前实例，会移除实例中所有的节点与线\r\n     * @method clear\r\n     */\r\n    fishTopoProto.clear = function (isNoCount) {\r\n        for (var i = 0; i < this.allNodes.length; i++) {\r\n            var parentZr = this._getParentZr(this.allNodes[i]);\r\n            this.connectionManager.deleteSelectCon(this.allNodes[i], parentZr)\r\n        }\r\n        this.connectionManager.connectorMap.clear();\r\n        this.allNodes = [];\r\n        this.operationNode = null;\r\n        this.selectedNode = null;\r\n        this.dragSelectRect = null;\r\n        this.selectedNodes = [];\r\n        this.hideConnectorPoint();\r\n        this.hideConnectorControl();\r\n        this.connectionManager.connectors = [];\r\n        this._zr.clear();\r\n        this.group = new graphic.Group();\r\n        this.group.isBg = true;\r\n        this._zr.add(this.group);\r\n        if (isNoCount != true) {\r\n            this.stepCounter();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 创建连线的小图标操作\r\n     * @param {string} key 小图标的名称\r\n     * @param {Object} options 小图标的相关参数\r\n     * @param {String} [options.icon] 小图标路径\r\n     * @param {Object} [options.lineNode] 线段实例\r\n     * @param {Function} [options.callback] 点击后的回调\r\n     *\r\n     * **使用范例**：\r\n     *\r\n     *      @example\r\n     *                  this.fishTopo.addIcon(\"icon1\", {\r\n     *                      icon: \"https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo_top_ca79a146.png\",\r\n     *                      lineNode: lineNode,\r\n     *                      callback: function(event) {\r\n     *                          alert(JSON.stringify(event.data))\r\n     *                      },\r\n     *                  });\r\n     */\r\n    fishTopoProto.addLineIcon = fishTopoProto.addIcon = function (key, options) {\r\n        this.lineOperationManager.addIcon(key, options);\r\n    };\r\n\r\n    /**\r\n     * 创建连线的默认删除操作\r\n     * @param  {Object} lineNode 线\r\n     *\r\n     *  **使用范例**：\r\n     *\r\n     *      @example\r\n     *      fishTopo.lineDefaultIcon(lineNode);\r\n     */\r\n    fishTopoProto.lineDefaultIcon = function (lineNode) {\r\n        this.addLineDeleteIcon(lineNode);\r\n        this.addLineChangeIcon(lineNode);\r\n    };\r\n\r\n    /**\r\n     * 创建连线的默认删除操作\r\n     * @param  {Object} lineNode 线\r\n     * @param {Object} [options] 连线操作的选项\r\n     *\r\n     *  **使用范例**：\r\n     *\r\n     *      @example\r\n     *      fishTopo.addLineChangeIcon(lineNode);\r\n     */\r\n    fishTopoProto.addLineDeleteIcon = function (lineNode,options) {\r\n        //创建删除\r\n        this.lineOperationManager.addDeleteIcon(lineNode,options);\r\n    };\r\n\r\n    /**\r\n     * 创建连线的默认切换类型操作\r\n     * @param  {Object} lineNode 线\r\n     * @param {Object} [options] 连线操作的选项\r\n     *\r\n     *  **使用范例**：\r\n     *\r\n     *      @example\r\n     *      fishTopo.addLineChangeIcon(lineNode);\r\n     */\r\n    fishTopoProto.addLineChangeIcon = function (lineNode,options) {\r\n        this.lineOperationManager.addChangeLineTypeIcon(lineNode,options);\r\n    };\r\n\r\n    /**\r\n     * 变更当前线的类型，如果不传则按顺序取下一个类型。先删除原来的线段 再增加一种类型的线段\r\n     * @param {String} lineType 欲变更线的类型\r\n     */\r\n    fishTopoProto.changeSelectConnectorType = function(lineType) {\r\n        var nextLineType = lineType;\r\n        var line = this.connectionManager.selConnector;\r\n        var originLineType = line.options.style.lineType;\r\n        if (nextLineType) {\r\n            if (nextLineType == originLineType) {\r\n                return;\r\n            }\r\n        } else {\r\n            var arrLineType = [Connector.TYPE_STRAIGHT, Connector.TYPE_JAGGED, Connector.TYPE_CURVE];\r\n            var index = zrUtil.indexOf(arrLineType, originLineType);\r\n            nextLineType = arrLineType[(index + 1) % arrLineType.length];\r\n        }\r\n\r\n        //this.remove(line, {trigger:false}); 这样会删除icons\r\n        this.connectionManager.deleteLine(this._getParentZr(line));\r\n        this.lineOperationManager.hideAllLineOperation();\r\n\r\n        zrUtil.merge(line.options, { dockers: [] }, true);\r\n        zrUtil.merge(line.options.style, { lineType: nextLineType }, true);\r\n        var nextLine = this.createConnectorByNodes(line.startNode, line.endNode, line.options, false);\r\n        if (nextLine) {\r\n            nextLine.icons = line.icons;\r\n            nextLine.on('Connector:click', function () {\r\n                this.lineOperationManager.bindOperation(nextLine);\r\n            }.bind(this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * 根据point创建节点上的连接点\r\n     * @param {Object} point x，y坐标  {x:x, y:y}\r\n     * @param {String} pos x，y坐标 [right|left|top|bottom]\r\n     * @param {String} lineType x，y坐标 [straight|jagged|curve]\r\n     */\r\n    fishTopoProto.createConnectorPoint = function(point, pos, lineType) {\r\n        var me = this;\r\n        var pointInstance = new graphic.Circle({\r\n            shape: {\r\n                cx: point.x,\r\n                cy: point.y,\r\n                r: 4\r\n            },\r\n            style: {\r\n                fill: '#FFFF33',\r\n                stroke:'#000000'\r\n            },\r\n                        z : 4,\r\n            draggable: true,\r\n            lineType: lineType\r\n        });\r\n        pointInstance.type = 'ConnectPoint';\r\n        pointInstance.pos = pos;                //记录是节点上哪个位置的连接点\r\n        var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];\r\n        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n            pointInstance.on(eveName, function(e) {\r\n                var params = {};\r\n                params.event = e;\r\n                params.type = \"ConnectPoint:\" + eveName;\r\n                me.group.trigger(params.type, params);\r\n            });\r\n        });\r\n        this.group.add(pointInstance);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * 隐藏节点上的连接点\r\n     */\r\n    fishTopoProto.hideConnectorPoint = function() {\r\n        var that = this;\r\n        this.group.children().forEach(function (v) {\r\n            if (v.type === 'ConnectPoint') {\r\n                that.group.remove(v);\r\n            }\r\n        })\r\n        this.group.off(\"ConnectPoint:dragstart\");\r\n        this.group.off(\"ConnectPoint:drag\");\r\n        this.group.off(\"ConnectPoint:dragend\");\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * 根据节点数组动态创建连接点\r\n     * @param  {Array} lineType 需要展示连接点的节点数组\r\n     * @param  {String} lineType 连线的线段类型 [straight|jagged|curve]\r\n     */\r\n    fishTopoProto.filterConnectPoint = function(targetNodes, lineType) {\r\n        var that = this;\r\n        var groupNodes = []; // 记录组内节点\r\n        var outsideNodes = []; // 记录组外节点\r\n        var nodes = [];\r\n        if (targetNodes.length > 1) {\r\n            targetNodes.forEach(function(item) {\r\n                if (Flow.isGroupNode(item)) {\r\n                    nodes.push(item);\r\n                    groupNodes = groupNodes.concat(item.children());\r\n                } else {\r\n                    outsideNodes.push(item);\r\n                }\r\n            });\r\n            // 比较组内外节点，过滤组内节点\r\n            outsideNodes.forEach(function(item) {\r\n                if (!groupNodes.includes(item)) {\r\n                    nodes.push(item);\r\n                }\r\n            });\r\n        } else {\r\n            nodes = targetNodes;\r\n        }\r\n        nodes.forEach(function(item) {\r\n            var rect = util.getRect(item);\r\n            var connectorPoint = util.getConnectorPoints(rect, item);\r\n            that.createConnectorPoint(connectorPoint.left, \"left\", lineType);\r\n            that.createConnectorPoint(connectorPoint.right, \"right\", lineType);\r\n            that.createConnectorPoint(connectorPoint.top, \"top\", lineType);\r\n            that.createConnectorPoint(connectorPoint.bottom, \"bottom\", lineType);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 在节点上显示连接点\r\n     * @param  {String} lineType 连线的线段类型 [straight|jagged|curve]\r\n     * @param {Object} [options] 连线的线段属性\r\n     *\r\n     *  **使用范例**：\r\n     *\r\n     *      @example\r\n     *       $('.btn-connect-jagged').click(function(e) {\r\n     *           fishTopo.showConnectorPoint(\"jagged\", {\r\n     *               symbol: {\r\n     *                   // 箭头颜色\r\n     *                   color: \"#BBBBBB\"\r\n     *               },\r\n     *               style: {\r\n     *                   // 线条颜色\r\n     *                   stroke: \"#BBBBBB\",\r\n     *               }\r\n     *           });\r\n     *       });\r\n     */\r\n    fishTopoProto.showConnectorPoint = function(lineType, lineOpt, ifCurrentNode) {\r\n        var that = this;\r\n        this.hideConnectorPoint();\r\n        if (lineOpt) {\r\n            this.lineOpt = lineOpt;  //缓存线段的配置信息\r\n        }\r\n        if (!ifCurrentNode) {\r\n            ifCurrentNode = false;\r\n        }\r\n        var targetNodes = ifCurrentNode ? [that.selectedNode] : that.allNodes;\r\n\r\n        if (!ifCurrentNode) {\r\n            // 所有节点连接点展示前，首先清除画布上的框选dragSelect\r\n            that._removeOperationNode();\r\n            that._releaseSelectNode();\r\n        }\r\n\r\n        // 让所有画布中的节点/当前节点显示连接点\r\n        this.filterConnectPoint(targetNodes, lineType);\r\n\r\n        // 根据连线点查找节点(考虑优化 创建连接点的时候 就把连接点与node进行绑定，就不用这个复杂的计算了)\r\n        function findConnectorNode(x, y, offset, pos) {\r\n            var node, endPos = null;\r\n            that.allNodes.forEach(function(item) {\r\n                var rect = util.getRect(item);\r\n                var connectorPoint = util.getConnectorPoints(rect, item);\r\n                if (pos) {\r\n                    if (Math.abs(connectorPoint[pos].x - x) <= offset && Math.abs(connectorPoint[pos].y - y) <= offset) {\r\n                        node = item;\r\n                    }\r\n                } else {\r\n                    if (Math.abs(connectorPoint[\"left\"].x - x) <= offset && Math.abs(connectorPoint[\"left\"].y - y) <= offset) {\r\n                        endPos = \"left\";\r\n                        node = item;\r\n                    } else if (Math.abs(connectorPoint[\"top\"].x - x) <= offset && Math.abs(connectorPoint[\"top\"].y - y) <= offset) {\r\n                        endPos = \"top\";\r\n                        node = item;\r\n                    } else if (Math.abs(connectorPoint[\"right\"].x - x) <= offset && Math.abs(connectorPoint[\"right\"].y - y) <= offset) {\r\n                        endPos = \"right\";\r\n                        node = item;\r\n                    } else if (Math.abs(connectorPoint[\"bottom\"].x - x) <= offset && Math.abs(connectorPoint[\"bottom\"].y - y) <= offset) {\r\n                        endPos = \"bottom\";\r\n                        node = item;\r\n                    }\r\n                }\r\n            });\r\n            return {\r\n                node: node,\r\n                endPos: endPos\r\n            };\r\n        }\r\n        this.group.on(\"ConnectPoint:dragstart\", function(e) {\r\n            // 如果是当前节点显示连接点，需要在拖动剪头时让画布中的其他节点显示连接点\r\n            if (ifCurrentNode) {\r\n                that.filterConnectPoint(that.allNodes, lineType);\r\n            }\r\n            var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;\r\n            var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;\r\n            var arrow = e.event.target;\r\n            that.startPos = arrow.pos;\r\n            that.selectConnNode = findConnectorNode(arrow.shape.cx, arrow.shape.cy, 0, that.startPos).node;\r\n            arrow.hide();\r\n            that.lineOperationManager.hideAllLineOperation();\r\n            that.reverseConnect = false;   //是否反向连线的标识\r\n            that.originNode = null;\r\n            var point = new Point(x, y);\r\n            that.connectionManager.connectors.forEach(function (v) {\r\n                if (v.endNode.id === that.selectConnNode.id && that.startPos === v.options.position.endPos) {\r\n                    that.connectionManager.deleteByLine(v, that.group);\r\n                    that.selectConnNode = v.startNode;\r\n                    that.startPos = v.options.position.startPos;\r\n                    that.originNode = v.endNode;\r\n                    that.originPos = v.options.position.endPos;\r\n                } else if (v.startNode.id === that.selectConnNode.id && that.startPos === v.options.position.startPos) {\r\n                    that.connectionManager.deleteByLine(v, that.group);\r\n                    that.reverseConnect = true;\r\n                    that.selectConnNode = v.endNode;\r\n                    that.endPos = v.options.position.endPos;\r\n                    that.originNode = v.startNode;\r\n                    that.originPos = v.options.position.startPos;\r\n                }\r\n            })\r\n            var connector;\r\n            if (that.reverseConnect) {\r\n                connector = that.connectionManager.manageReverseTempConnector(point, that.selectConnNode, arrow.lineType, that.endPos);\r\n            } else {\r\n                connector = that.connectionManager.manageTempConnector(that.selectConnNode, point, arrow.lineType, that.startPos);\r\n            }\r\n            that.group.add(connector);\r\n        });\r\n        this.group.on(\"ConnectPoint:drag\", function(e) {\r\n            var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;\r\n            var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;\r\n            var point = new Point(x, y);\r\n            var arrow = e.event.target;\r\n            if (that.reverseConnect) {\r\n                that.connectionManager.manageReverseTempConnector(point, that.selectConnNode, arrow.lineType, that.endPos);\r\n            } else {\r\n                that.connectionManager.manageTempConnector(that.selectConnNode, point, arrow.lineType, that.startPos);\r\n            }\r\n            that.group.children().forEach(function (v) {\r\n                if (v.type === 'ConnectPoint') {\r\n                    v.attr({style:{fill: \"#FFFF33\"},scale:[1,1],origin:[v.shape.cx,v.shape.cy]});\r\n                    if (Math.abs(v.shape.cx - x) <= 10 && Math.abs(v.shape.cy - y) <= 10) {\r\n                        var res = findConnectorNode(x, y, 10);\r\n                        if (that.reverseConnect) {\r\n                            that.connectionManager.manageReverseTempConnector(point, that.selectConnNode, arrow.lineType, that.endPos, res.endPos, res.node);\r\n                        } else {\r\n                            that.connectionManager.manageTempConnector(that.selectConnNode, point, arrow.lineType, that.startPos, res.endPos, res.node);\r\n                        }\r\n                        v.attr({style:{fill: \"#ff0000\"},scale:[1.5,1.5],origin:[v.shape.cx,v.shape.cy]});\r\n                    }\r\n                }\r\n            })\r\n        });\r\n        this.group.on(\"ConnectPoint:dragend\", function(e) {\r\n            var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;\r\n            var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;\r\n            var res = findConnectorNode(x, y, 10);\r\n            var targetNode = res.node;\r\n            var endPos = res.endPos || 'left';\r\n            var arrow = e.event.target;\r\n            //删除临时线\r\n            that.connectionManager.removeTempConnector(that.group);\r\n\r\n            //2.如果找到目标结点 则画线\r\n            if (targetNode && (that.selectConnNode.id !== targetNode.id)) {\r\n                var origin = {};\r\n                var connectOptions = {\r\n                    style: {\r\n                        lineType: arrow.lineType\r\n                    },\r\n                    position: {\r\n                        startPos: that.reverseConnect ? endPos : that.startPos,\r\n                        endPos: that.reverseConnect ? that.endPos : endPos\r\n                    }\r\n                }\r\n                var finalOpt = util.mergeOpt(connectOptions, that.lineOpt, true, 'position');\r\n                var start = that.reverseConnect ? targetNode : that.selectConnNode;\r\n                var end = that.reverseConnect ? that.selectConnNode : targetNode;\r\n                //如果有原始连线存在，则要暴露出去。\r\n                if (that.originNode) {\r\n                    origin.startNode = that.reverseConnect ? that.originNode : that.selectConnNode;\r\n                    origin.endNode = that.reverseConnect ? that.selectConnNode : that.originNode;\r\n                    origin.options = util.mergeOpt({\r\n                        style: {\r\n                            lineType: arrow.lineType\r\n                        },\r\n                        position: {\r\n                            startPos: that.reverseConnect ? that.originPos : that.startPos,\r\n                            endPos: that.reverseConnect ? that.endPos : that.originPos\r\n                        }\r\n                    }, that.lineOpt, true, 'position');\r\n                }\r\n                if(!that._trigger('beforeCreate', {target: start, endNode: end, connectOptions: finalOpt, origin: origin})) {\r\n                    return false;\r\n                }\r\n                that.createConnectorByNodes(start, end, finalOpt);\r\n                that.hideConnectorPoint();      //隐藏所有节点上的连接点\r\n                // 触发selectConnNode点击\r\n                // that.nodeClickHandler(that.selectConnNode);\r\n            } else {\r\n                arrow.show();\r\n                arrow.position = [0, 0];\r\n                //还原所有连接点的颜色\r\n                that.group.children().forEach(function (v) {\r\n                    if (v.type === 'ConnectPoint') {\r\n                        v.attr({style:{fill: \"#FFFF33\"},scale:[1,1],origin:[v.shape.cx,v.shape.cy]});\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n    fishTopoProto.createLineConnectorPoint = function(point, pos, lineType) {\r\n        var pointInstance = new graphic.Circle({\r\n            shape: {\r\n                cx: point.x,\r\n                cy: point.y,\r\n                r: 4\r\n            },\r\n            style: {\r\n                fill: '#FFFF33',\r\n                stroke:'#000000'\r\n            },\r\n            z : 4,\r\n            draggable: true,\r\n            lineType: lineType\r\n        });\r\n        pointInstance.type = 'ConnectPoint';\r\n        pointInstance.pos = pos;                //记录是节点上哪个位置的连接点\r\n        this.group.add(pointInstance);\r\n    }\r\n\r\n    fishTopoProto.getRotatedCornerCursor = function(node, pos) {\r\n        var that = this;\r\n        var rotation = node.rotation;\r\n        if (pos === 'mtr') {\r\n            return that.cursorMap[pos];\r\n        }\r\n        if (Math.abs(rotation) > 0) {\r\n            var angle = -rotation / (Math.PI/180);\r\n            var n = Math.round((angle % 360) / 45);\r\n            if (n < 0) {\r\n                n += 8; // full circle ahead\r\n            }\r\n            n += that.cursorOffset[pos];\r\n            n %= 8;\r\n            return that.cursorMaps[n];\r\n        }\r\n        return that.cursorMap[pos];\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * 根据point创建节点上的控制点\r\n     * @param {Object} point x，y坐标  {x:x, y:y}\r\n     * @param {String} pos x，y坐标 [tl|tc|tr|bl|br|mtr] (top-left, top-center, top-right, bottom-left, bottom-right, middle-top-rotate)\r\n     * @param {String} nodeId 创建控制点时传入当前节点的id，完成节点与控制点的绑定\r\n     */\r\n    fishTopoProto.createConnectorControl = function(point, pos, node) {\r\n        var me = this;\r\n        var posArr = pos.split(',');\r\n        if (posArr.length < 2) {\r\n            var controlCursor = me.getRotatedCornerCursor(node, pos);\r\n            var pointInstance = new graphic.Rect({\r\n                shape:{\r\n                    x: point.x - 4,\r\n                    y: point.y - 4,\r\n                    width: 8,\r\n                    height: 8\r\n                },\r\n                style: {\r\n                    fill: '#ffffff',\r\n                    stroke:'#000000'\r\n                },\r\n                z: 4,\r\n                rotation: node.rotation,\r\n                origin: [point.x, point.y],\r\n                cursor: controlCursor,\r\n                draggable: true\r\n            });\r\n            pointInstance.type = 'ConnectControl';\r\n            pointInstance.pos = pos;// 记录是节点上哪个位置的连接点\r\n            var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];\r\n            zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n                pointInstance.on(eveName, function(e) {\r\n                    var params = {};\r\n                    params.event = e;\r\n                    params.type = \"ConnectControl:\" + eveName;\r\n                    params.nodeId = node.id;\r\n                    params.cursor = controlCursor;\r\n                    me.group.trigger(params.type, params);\r\n                });\r\n            });\r\n            this.group.add(pointInstance);\r\n        } else {\r\n            // 旋转点与节点之间需要连线\r\n            var line = new graphic.Line({\r\n                shape: {\r\n                    x1: point.top.x,\r\n                    y1: point.top.y,\r\n                    x2: point.bottom.x,\r\n                    y2: point.bottom.y\r\n                },\r\n                style: {\r\n                    lineWidth: 1\r\n                },\r\n                z: 1,\r\n                draggable: false,\r\n                cursor: 'default'\r\n            });\r\n            line.type = 'ConnectControlLine';\r\n            line.nodeId = node.id;\r\n            this.group.add(line);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method returnConnectorControlParam\r\n     * 返回旋转点和缩放点控制参数\r\n     * @param  {Object} 当前节点对象\r\n     */\r\n    fishTopoProto.returnConnectorControlParam = function(node) {\r\n        var scaleFlag = typeof node.scaleable === 'boolean' ? node.scaleable : this.options.scaleable;\r\n        var rotateFlag = typeof node.rotatable === 'boolean' ? node.rotatable : this.options.rotatable;\r\n        return {\r\n            scaleable: scaleFlag,\r\n            rotatable: rotateFlag\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * 隐藏节点上的控制点\r\n     */\r\n    fishTopoProto.hideConnectorControl = function() {\r\n        var that = this;\r\n        var types = ['ConnectControl', 'ConnectControlLine'];\r\n        this.group.children().forEach(function (v) {\r\n            if (types.includes(v.type)) {\r\n                that.group.remove(v);\r\n            }\r\n        })\r\n        this.group.off(\"ConnectControl:dragstart\");\r\n        this.group.off(\"ConnectControl:drag\");\r\n        this.group.off(\"ConnectControl:dragend\");\r\n    }\r\n\r\n    /**\r\n     * 在节点上显示控制点\r\n     *\r\n     *  **使用范例**：\r\n     *\r\n     *      @example\r\n     *      fishTopo.showConnectorControl();\r\n    */\r\n   fishTopoProto.showConnectorControl = function() {\r\n    var that = this;\r\n    this.hideConnectorControl();\r\n    // 让当前节点显示控制点\r\n    var rect = util.getRect(this.selectedNode);\r\n    var connectorPoint = util.getConnectorControls(rect, this.selectedNode);\r\n    var params = this.returnConnectorControlParam(this.selectedNode);\r\n    if (params.scaleable) {\r\n        that.createConnectorControl(connectorPoint.tl, \"tl\", this.selectedNode);\r\n        that.createConnectorControl(connectorPoint.tr, \"tr\", this.selectedNode);\r\n        that.createConnectorControl(connectorPoint.bl, \"bl\", this.selectedNode);\r\n        that.createConnectorControl(connectorPoint.br, \"br\", this.selectedNode);\r\n    }\r\n    if (params.rotatable) {\r\n        that.createConnectorControl(connectorPoint.mtr, \"mtr\", this.selectedNode);\r\n        that.createConnectorControl({ top: connectorPoint.mtr, bottom: connectorPoint.tc }, \"mtr,tc\", this.selectedNode);\r\n    }\r\n\r\n    function findControlNode (id) {\r\n        var node = null;\r\n        that.group.children().forEach(function(item) {\r\n            if (item.id === id) {\r\n                    node = item;\r\n            }\r\n        });\r\n        return node;\r\n    }\r\n\r\n    this.group.on(\"ConnectControl:dragstart\", function(e) {\r\n        // 首先清除其他所有节点的控制点和连接点\r\n        var cursor = e.event.target.cursor;\r\n        var pos = e.event.target.pos;\r\n        var posMap = {\r\n            'tl': 'br',\r\n            'tr': 'bl',\r\n            'bl': 'tr',\r\n            'br': 'tl'\r\n        };\r\n        that.selectConnNode = findControlNode(e.nodeId);\r\n        if (cursor && pos !== 'mtr') {\r\n            var originNode = that.group.children().find(function (node) {\r\n                return node.pos === posMap[pos];\r\n            });\r\n            var currentNode = that.group.children().find(function (node) {\r\n                return node.pos === pos;\r\n            });\r\n            var boundingRect = that.selectConnNode.getBoundingRect();\r\n            that.oppositeShape = zrUtil.clone(originNode.shape);\r\n            that.currentShape = zrUtil.clone(currentNode.shape);\r\n            var rect = zrUtil.clone(util.getRect(that.selectConnNode, true));\r\n            var diagonal = Math.sqrt(Math.pow(rect.width, 2) + Math.pow(rect.height, 2));// 对角线长度\r\n            that.diagonal = diagonal;\r\n            that.originRect = zrUtil.clone(rect);\r\n            that.ifPointCenter = boundingRect.x < -1; // 判断中心点是否在节点中心(原形在中心，矩形在左上角)\r\n            // 移除node高亮\r\n            that.selectConnNode.selectStyle && that._api.getZr().removeHover(that.selectConnNode);\r\n        }\r\n    });\r\n    this.group.on(\"ConnectControl:drag\", function(e) {\r\n        var cursor = e.event.target.cursor;\r\n        var targetPos = e.event.target.pos;\r\n        var currentNode = that.selectConnNode;\r\n        var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;\r\n        var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;\r\n        var rect = util.getRect(currentNode, true);\r\n        if (targetPos === 'mtr') {\r\n            // 旋转\r\n            var r_x = x - currentNode.position[0];\r\n            var r_y = y - currentNode.position[1];\r\n            var origins = {\r\n                x: rect.x - currentNode.position[0],\r\n                y: rect.y - currentNode.position[1]\r\n            }\r\n            var rotation = Math.atan2(r_y, r_x);\r\n            that.selectedNode.attr({\r\n                'origin': [origins.x, origins.y],\r\n                'rotation': -rotation\r\n            });\r\n            var connectorPoint = util.getConnectorPoints(rect, that.selectedNode);\r\n            var controlPoint = util.getConnectorControls(rect, that.selectedNode);\r\n            // 节点连线点，控制点位置更新\r\n            that.group.children().forEach(function (item) {\r\n                var pos = item.pos;\r\n                if (item.type === 'ConnectControl') {\r\n                    if (pos === 'mtr') {\r\n                        item.attr('position', [0, 0]);\r\n                        item.attr('rotation', 0);\r\n                    }\r\n                    item.setShape({ x: controlPoint[pos].x - 4, y: controlPoint[pos].y - 4 });\r\n                    item.attr({\r\n                        'origin': [item.shape.x + 4, item.shape.y + 4],\r\n                        'rotation': -rotation\r\n                    });\r\n                } else if (item.type === 'ConnectControlLine') {\r\n                    item.setShape({ x1: controlPoint.mtr.x, x2: controlPoint.tc.x, y1: controlPoint.mtr.y, y2: controlPoint.tc.y });\r\n                } else if (item.type === 'ConnectPoint') {\r\n                    item.setShape({ cx: connectorPoint[pos].x, cy: connectorPoint[pos].y });\r\n                }\r\n            });\r\n        } else {\r\n            // 缩放(缩放点需要结合旋转角度计算)\r\n            var ratio = 1,\r\n                center = [],\r\n                centerPoint = {},\r\n                width0, height0;\r\n            var cursorsY = ['n-resize', 's-resize'];\r\n            var positionOrg = {\r\n                'tl': 'br',\r\n                'tr': 'bl',\r\n                'bl': 'tr',\r\n                'br': 'tl'\r\n            }\r\n\r\n            var scaleNodes = that.group.children().filter(function (node) {\r\n                return node.type === 'ConnectControl' && node.pos !== 'mtr'\r\n            });\r\n            var currentControlNode = scaleNodes.find(function(node) {\r\n                return node.pos === targetPos;\r\n            });\r\n\r\n            if (x <= 8) {\r\n                x = 8;\r\n            }\r\n            if (y <= 8) {\r\n                y = 8;\r\n            }\r\n\r\n            if (cursorsY.includes(cursor)) {\r\n                // 获取y轴比例即可\r\n                var startY = currentControlNode.shape.y + 4;\r\n                ratio = that.currentShape.y >= that.oppositeShape.y ? ((y - that.oppositeShape.y - 4) / (startY - that.oppositeShape.y)) : ((that.oppositeShape.y + 4 - y) / (that.oppositeShape.y - startY));\r\n            } else {\r\n                // 获取x轴比例即可\r\n                var startX = currentControlNode.shape.x + 4;\r\n                ratio = that.currentShape.x >= that.oppositeShape.x ? ((x - that.oppositeShape.x - 4) / (startX - that.oppositeShape.x)) : ((that.oppositeShape.x + 4 - x) / (that.oppositeShape.x - startX))\r\n            }\r\n            if (!/^[0-9]+.?[0-9]*/.test(ratio)) {\r\n                ratio = 1;\r\n            }\r\n            currentNode.updateShape(ratio);\r\n\r\n            var rectScale = util.getRect(currentNode, true);\r\n            centerPoint = that.ifPointCenter ? { x: that.originRect.x, y: that.originRect.y } : { x: that.originRect.boundingRect.x, y: that.originRect.boundingRect.y };\r\n            var diagonalNew = Math.sqrt(Math.pow(rectScale.width, 2) + Math.pow(rectScale.height, 2));// 对角线长度\r\n            switch (cursor) {\r\n                // 上,左上\r\n                case 'n-resize':\r\n                case 'nw-resize':\r\n                    width0 = (that.oppositeShape.x + 4 - centerPoint.x) * diagonalNew / that.diagonal;\r\n                    height0 = (that.oppositeShape.y + 4 - centerPoint.y) * diagonalNew / that.diagonal;\r\n                    center.push(that.oppositeShape.x - width0 + 4, that.oppositeShape.y - height0 + 4);\r\n                    break;\r\n                // 右,右上\r\n                case 'e-resize':\r\n                case 'ne-resize':\r\n                    width0 = (centerPoint.x - that.oppositeShape.x - 4) * diagonalNew / that.diagonal;\r\n                    height0 = (that.oppositeShape.y + 4 - centerPoint.y) * diagonalNew / that.diagonal;\r\n                    center.push(that.oppositeShape.x + width0 + 4, that.oppositeShape.y - height0 + 4);\r\n                    break;\r\n                // 下，右下\r\n                case 's-resize':\r\n                case 'se-resize':\r\n                    width0 = (centerPoint.x - that.oppositeShape.x - 4) * diagonalNew / that.diagonal;\r\n                    height0 = (centerPoint.y - that.oppositeShape.y - 4) * diagonalNew / that.diagonal;\r\n                    center.push(that.oppositeShape.x + width0 + 4, that.oppositeShape.y + height0 + 4);\r\n                    break;\r\n                // 左,左下\r\n                case 'w-resize':\r\n                case 'sw-resize':\r\n                    width0 = (that.oppositeShape.x + 4 - centerPoint.x) * diagonalNew / that.diagonal;\r\n                    height0 = (centerPoint.y - that.oppositeShape.y - 4) * diagonalNew / that.diagonal;\r\n                    center.push(that.oppositeShape.x - width0 + 4, that.oppositeShape.y + height0 + 4);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n\r\n            var originScale = {\r\n                x: rectScale.x - center[0],\r\n                y: rectScale.y - center[1]\r\n            }\r\n            currentNode.attr({\r\n                'position': center,\r\n                'origin': [originScale.x, originScale.y]\r\n            });\r\n\r\n            // 此时节点包围盒需要重新计算\r\n            var rectNow = util.getRect(currentNode, true);\r\n            var connectorPointScale = util.getConnectorPoints(rectNow, currentNode);\r\n            var controlPointScale = util.getConnectorControls(rectNow, currentNode);\r\n            that.group.children().forEach(function(item) {\r\n                var pos = item.pos;\r\n                if (pos === targetPos) {\r\n                    item.attr('position', [0, 0]);\r\n                }\r\n                if (item.type === 'ConnectControl' && pos !== positionOrg[targetPos]) {\r\n                    item.setShape({ x: controlPointScale[pos].x - 4, y: controlPointScale[pos].y - 4 });\r\n                    item.attr('origin', [controlPointScale[pos].x, controlPointScale[pos].y]);\r\n                } else if (item.type === 'ConnectControlLine') {\r\n                    item.setShape({ x1: controlPointScale.mtr.x, x2: controlPointScale.tc.x, y1: controlPointScale.mtr.y, y2: controlPointScale.tc.y });\r\n\r\n                } else if (item.type === 'ConnectPoint') {\r\n                    item.setShape({ cx: connectorPointScale[pos].x, cy: connectorPointScale[pos].y });\r\n                }\r\n            });\r\n        }\r\n        that.operationNode.refreshPostion(that.selectedNode, util.getRect(that.selectedNode));\r\n        // 1.5 刷新连线\r\n        that.connectionManager.refreshLineByNode(that.selectedNode);\r\n        // 1.6 如果是组的话,需要把组内所有结果都刷新一下线\r\n        if (Flow.isGroupNode(that.selectedNode)) {\r\n            that.selectedNode.each(function(childNode) {\r\n                that.connectionManager.refreshLineByNode(childNode);\r\n            });\r\n        }\r\n\r\n    });\r\n    this.group.on(\"ConnectControl:dragend\", function(e) {\r\n        // 更新节点position\r\n        var node = that.selectConnNode;\r\n        var position = node.position;\r\n        var origin = node.origin;\r\n        // position origin取整\r\n        that.selectConnNode.attr('position', [parseInt(position[0], 10), parseInt(position[1], 10)]);\r\n        if (Array.isArray(origin)) {\r\n            that.selectConnNode.attr('origin', [parseInt(origin[0], 10), parseInt(origin[1], 10)]);\r\n        }\r\n        node.updateShape(1, true);\r\n        if (node.model) {\r\n            // 更新model，支持序列化/反序列化\r\n            node.model.set(\"options.rotation\", node.rotation);\r\n            node.model.set(\"options.origin\", node.origin);\r\n            var elementType = node.model.option.elementType;\r\n            if (elementType === 'Image') {\r\n                node.model.set(\"options.style\", node.style);\r\n            } else {\r\n                node.model.set(\"options.shape\", node.shape);\r\n            }\r\n        }\r\n        // 1.4 触发点击\r\n        that.nodeClickHandler(node);\r\n        that.stepCounter();\r\n        that.oppositeShape = null;\r\n        that.currentShape = null;\r\n        that.diagonal = null;\r\n        that.originRect = null;\r\n        that.ifPointCenter = null;\r\n    });\r\n}\r\n\r\n    fishTopoProto.initOperationNode = function (node, ifCurrentNode) {\r\n        var that = this;\r\n        if (!ifCurrentNode) {\r\n            ifCurrentNode = false;\r\n        }\r\n        this.operationNode = new OperationNode(node, this.group, this._api);\r\n        // 根据连线点查找节点(考虑优化 创建连接点的时候 就把连接点与node进行绑定，就不用这个复杂的计算了)\r\n        function findConnectorNode(x, y, offset, pos) {\r\n            var node, endPos = null;\r\n            that.allNodes.forEach(function(item) {\r\n                var rect = util.getRect(item);\r\n                var connectorPoint = util.getConnectorPoints(rect, item);\r\n                if (pos) {\r\n                    if (Math.abs(connectorPoint[pos].x - x) <= offset && Math.abs(connectorPoint[pos].y - y) <= offset) {\r\n                        node = item;\r\n                    }\r\n                } else {\r\n                    if (Math.abs(connectorPoint[\"left\"].x - x) <= offset && Math.abs(connectorPoint[\"left\"].y - y) <= offset) {\r\n                        endPos = \"left\";\r\n                        node = item;\r\n                    } else if (Math.abs(connectorPoint[\"top\"].x - x) <= offset && Math.abs(connectorPoint[\"top\"].y - y) <= offset) {\r\n                        endPos = \"top\";\r\n                        node = item;\r\n                    } else if (Math.abs(connectorPoint[\"right\"].x - x) <= offset && Math.abs(connectorPoint[\"right\"].y - y) <= offset) {\r\n                        endPos = \"right\";\r\n                        node = item;\r\n                    } else if (Math.abs(connectorPoint[\"bottom\"].x - x) <= offset && Math.abs(connectorPoint[\"bottom\"].y - y) <= offset) {\r\n                        endPos = \"bottom\";\r\n                        node = item;\r\n                    }\r\n                }\r\n            });\r\n            return {\r\n                node: node,\r\n                endPos: endPos\r\n            };\r\n        }\r\n        this.operationNode.on(OperationNode.ARROW_DRAGSTART, function (e) {\r\n            this.hideConnectorPoint();\r\n            that.filterConnectPoint(that.allNodes, e.event.target.lineType);\r\n            var x = (e.event.offsetX - this.group.position[0]) / this.nowZoom;\r\n            var y = (e.event.offsetY - this.group.position[1]) / this.nowZoom;\r\n            if (e.data) {\r\n                this.lineOpt = e.data;  //缓存线段的配置信息\r\n            }\r\n            //拖拽开始先把 箭头图标 给隐藏\r\n            var arrow = e.event.target;\r\n            arrow.hide();\r\n            var rEndPoint = new Point(x, y);\r\n            var connector = this.connectionManager.manageTempConnector(this.selectedNode, rEndPoint,\r\n                arrow.lineType);\r\n            this.group.add(connector);\r\n            e.cancelBubble = true;\r\n        }.bind(this));\r\n\r\n        // 侦听 箭头 拖拽事件\r\n        this.operationNode.on(OperationNode.ARROW_DRAG, function (e) {\r\n            var x = (e.event.offsetX - this.group.position[0]) / this.nowZoom;\r\n            var y = (e.event.offsetY - this.group.position[1]) / this.nowZoom;\r\n            var arrow = e.event.target;\r\n            var rEndPoint = new Point(x, y);\r\n            this.connectionManager.manageTempConnector(this.selectedNode, rEndPoint, arrow.lineType);\r\n            that.group.children().forEach(function (v) {\r\n                if (v.type === 'ConnectPoint') {\r\n                    v.attr({style:{fill: \"#FFFF33\"},scale:[1,1],origin:[v.shape.cx,v.shape.cy]});\r\n                    if (Math.abs(v.shape.cx - x) <= 10 && Math.abs(v.shape.cy - y) <= 10) {\r\n                        var res = findConnectorNode(x, y, 10);\r\n                        that.connectionManager.manageTempConnector(that.selectedNode, rEndPoint, arrow.lineType, 'right', res.endPos, res.node);\r\n                        v.attr({style:{fill: \"#ff0000\"},scale:[1.5,1.5],origin:[v.shape.cx,v.shape.cy]});\r\n                    }\r\n                }\r\n            })\r\n            e.cancelBubble = true;\r\n        }.bind(this));\r\n\r\n        //侦听 箭头 拖拽结束事件 画线\r\n        this.operationNode.on(OperationNode.ARROW_DRAGEND, function (e) {\r\n            e.cancelBubble = true;\r\n            var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;\r\n            var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;\r\n            var res = findConnectorNode(x, y, 10);\r\n            var targetNode = res.node;\r\n            var endPos = res.endPos || 'left';\r\n            var arrow = e.event.target;\r\n            //拖拽结束先把 箭头图标 给显示\r\n            arrow.show();\r\n            //删除临时线\r\n            this.connectionManager.removeTempConnector(this.group);\r\n\r\n            //1.如果是子节点 内 节点拖拽 则 增加排除子节点的参数\r\n            // targetNode = findHover(this.allNodes, x, y);\r\n\r\n            //2.如果找到目标结点 则画线\r\n            if (targetNode && (this.selectedNode != targetNode)) {\r\n                var origin = {};\r\n                var connectOptions = {\r\n                    style: {\r\n                        lineType: arrow.lineType\r\n                    },\r\n                    position: {\r\n                        startPos: 'right',\r\n                        endPos: endPos\r\n                    }\r\n                }\r\n                var finalOpt = util.mergeOpt(connectOptions, that.lineOpt, true, 'position');\r\n                var start = that.selectedNode;\r\n                var end = targetNode;\r\n                //如果有原始连线存在，则要暴露出去。\r\n                if (that.originNode) {\r\n                    origin.startNode = that.selectedNode;\r\n                    origin.endNode = that.originNode;\r\n                    origin.options = util.mergeOpt({\r\n                        style: {\r\n                            lineType: arrow.lineType\r\n                        },\r\n                        position: {\r\n                            startPos: that.startPos,\r\n                            endPos: that.originPos\r\n                        }\r\n                    }, that.lineOpt, true, 'position');\r\n                }\r\n                if(!this._trigger('beforeCreate', {target:this.selectedNode,endNode:targetNode,connectOptions:connectOptions, origin: {}})) {\r\n                    return null;\r\n                }\r\n                that.createConnectorByNodes(start, end, finalOpt);\r\n            }\r\n            that.hideConnectorPoint();\r\n            // 连线成功/失败，当前节点依然是选中状态，需要重新计算虚线和图标位置\r\n            var node = that.selectedNode;\r\n            var shapeRect = util.getRect(node, true);\r\n            // 显示当前节点的连接点\r\n            that.showConnectorPoint('jagged', undefined, true);\r\n            that.operationNode.refreshPostion(node, shapeRect);\r\n        }.bind(this));\r\n\r\n        //删除按钮点击事件\r\n        this.operationNode.on(OperationNode.DELETE_CLICK, function () {\r\n            this.removeNode(this.selectedNode);\r\n        }.bind(this));\r\n        this.group.add(this.operationNode);\r\n    };\r\n\r\n    fishTopoProto.removeSelectedNodes = function() {\r\n        var that = this;\r\n        if (this.selectedNodes.length) {\r\n            this.selectedNodes.forEach(function(item, index) {\r\n                that.removeNode(item, {}, true);\r\n                if (index === that.selectedNodes.length - 1) {\r\n                    that.stepCounter();\r\n                }\r\n            });\r\n            this.selectedNodes = [];\r\n            this.dragSelectRect.off(\"mousedown\");\r\n            this.group.remove(this.dragSelectRect);\r\n        } else if (that.selectedNode) {\r\n            that.removeNode(that.selectedNode);\r\n            // 1. 隐藏连线点\r\n            this.hideConnectorPoint();\r\n            // 2. 隐藏控制点\r\n            this.hideConnectorControl();\r\n            // 3. 隐藏操作node\r\n            this._removeOperationNode();\r\n        }\r\n    };\r\n\r\n    fishTopoProto.findNodeChildIds = function (node, childIds) {\r\n        childIds.push(node.id);\r\n        node.children().filter(function (v) {\r\n            var pos = this.allNodes.findIndex(function (item) {\r\n                return item.id === v.id\r\n            });\r\n            return pos !== -1\r\n        }.bind(this)).forEach(function (sub) {\r\n            if (Flow.isGroupNode(sub)) {\r\n                this.findNodeChildIds(sub, childIds);\r\n            } else {\r\n                childIds.push(sub.id);\r\n            }\r\n        }.bind(this));\r\n    }\r\n\r\n    /**\r\n     * 移除场景中的某个节点或者线段,同removeNode\r\n     * @method remove\r\n     * @param  {Object} node or link 待删除的节点或者线段\r\n     * @param {Object} [options] 参数\r\n     * @param {Boolean} [options.trigger=true] 是否触发删除事件\r\n     *\r\n     *  **使用范例**：\r\n     *\r\n     *      @example\r\n     *      fishTopo.remove(peopleNode);\r\n     */\r\n\r\n    /**\r\n     * 移除场景中的某个节点或者线段,同remove\r\n     * @method removeNode\r\n     * @param  {Object} node or link 待删除的节点或者线段\r\n     * @param {Object} [options] 参数\r\n     * @param {Boolean} [options.trigger=true] 是否触发删除事件\r\n     *\r\n     *  **使用范例**：\r\n     *\r\n     *      @example\r\n     *      fishTopo.removeNode(peopleNode);\r\n     */\r\n    fishTopoProto.remove = fishTopoProto.removeNode = function (delNode, options, isNoCount) {\r\n        var opt = options || {};\r\n        if(opt.trigger !==false && (!this._trigger('beforeDelete', {target:delNode}))) {\r\n            return;\r\n        }\r\n        var parentZr = this._getParentZr(delNode);\r\n        if (delNode instanceof Connector) {\r\n            // 1.1 删除线段上的操作图标\r\n            zrUtil.each(delNode.icons, function(lineOperationIcon) {\r\n                parentZr.remove(lineOperationIcon);\r\n            })\r\n            // 1.2 删除当前选中线段\r\n            this.connectionManager.deleteByLine(delNode,parentZr);\r\n        } else {\r\n            //2.1 删除节点\r\n            parentZr.remove(delNode);\r\n            var childIds = [];\r\n            if (Flow.isGroupNode(delNode)) {\r\n                this.findNodeChildIds(delNode, childIds);\r\n            } else {\r\n                childIds.push(delNode.id);\r\n            }\r\n            //2.从allNodes数组中删除\r\n            this.allNodes = this.allNodes.filter(function (v) {\r\n                return childIds.indexOf(v.id) === -1\r\n            });\r\n            //2.3 删除和节点相关联的线段\r\n            this.connectionManager.deleteSelectCon(delNode, this.group);\r\n            //2.4 删除节点操作\r\n            this._removeOperationNode();\r\n        }\r\n\r\n        //3. 清空连接线上的调整位置按钮\r\n        this.connectionManager.clearSelectCon();\r\n        //4. 清空连接线上的操作按钮\r\n        this.lineOperationManager.hideAllLineOperation();\r\n        if (isNoCount != true) {\r\n            this.stepCounter();\r\n        }\r\n        //4. 派发删除事件\r\n         this._trigger(\"delete\", {target:delNode});\r\n    };\r\n\r\n    /**\r\n     * 选中场景中的某个节点,并且触发selectNode事件\r\n     * @param {Object} node 待选中的节点对象\r\n     * @since V2.3.0\r\n     *  **使用范例：**\r\n     * @example\r\n     * fishTopo.selectNode(node);\r\n     */\r\n\r\n    fishTopoProto.selectNode = function(node) {\r\n        if (node) {\r\n            this.nodeClickHandler(node);\r\n            this._trigger(\"selectNode\", {target:node});\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 根据节点创建连线\r\n     * @method createConnectorByNodes\r\n     * @param  {Object} startNode 开始节点\r\n     * @param  {Object} endNode   结束节点\r\n     * @param  {Object} options 线段选项 参见{@link fishTopoFlow.link#constructor 构造函数options参数}\r\n     * @param  {Boolean} trigger 是否触发create事件，默认是触发create事件，设置为false则不触发\r\n     */\r\n    fishTopoProto.createConnectorByNodes = function (startNode, endNode, options, trigger) {\r\n        var linkType = options.style.lineType || Connector.TYPE_STRAIGHT;\r\n        if (!flowLink[linkType]) {\r\n            return null;\r\n        }\r\n        var Link = flowLink[linkType];\r\n        var connector = new Link(startNode, endNode, options);\r\n        this.connectionManager.add(connector);\r\n\r\n        if (startNode.parent && endNode.parent && startNode.parent==endNode.parent ) {\r\n            endNode.parent.add(connector);\r\n        } else {\r\n            this.group.add(connector);\r\n        }\r\n\r\n        connector.on(\"mousedown\", function (e) {\r\n            this.connectionManager.connectorForbidEdit();\r\n            this.isNode = false;\r\n            this.showConnectorPoint(e.target.style.lineType);\r\n        }.bind(this));\r\n        connector.on(\"dblclick\", function () {\r\n            if (this.options.textEditable) {\r\n                this.connectorEdit(this);\r\n            }\r\n        }.bind(this));\r\n        if (trigger !== false) {\r\n            this._trigger(\"create\", { target: connector });\r\n        }\r\n        this.stepCounter();\r\n        return connector;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 派发创建完成事件  返回fales则取消\r\n     */\r\n    fishTopoProto._trigger = function(type, event, data) {\r\n        var callback = this.options[type];\r\n\r\n        if (data === void 0) data = {};\r\n        if (event === null) {\r\n            event = {type:type, target:this}\r\n        } else {\r\n            event.type = type;\r\n        }\r\n        event.data = data;\r\n        this._api.trigger(event.type, event);\r\n        return !(zrUtil.isFunction(callback) && callback.apply(this, [event].concat(data)) === false);\r\n    }\r\n\r\n\r\n    fishTopoProto.nodeClickHandler = function (node) {\r\n        var ifShowPoint = node.type !== 'dragSelect';\r\n        if (node.parent && node.parent.type === \"dragSelect\") {\r\n            ifShowPoint = false;\r\n        }\r\n        // 1. 隐藏连线点\r\n        this.hideConnectorPoint();\r\n        // 2. 隐藏控制点\r\n        this.hideConnectorControl();\r\n        // 3. 隐藏操作node\r\n        this._removeOperationNode();\r\n        // 鼠标点下 将操作框 移到对应的节点上\r\n        if (node.selectable === false) {\r\n            if (Flow.isInGroup(node)) {\r\n                var group = node.parent;\r\n                if (group.selectable === false) {\r\n                    return;\r\n                } else {\r\n                    node = group;   // 如果有组的话，就针对组进行处理\r\n                }\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n\r\n        this.selectedNode = node;\r\n        var shapeRect = util.getRect(node,true);\r\n        if (!this.operationNode) {\r\n            this.initOperationNode(node, true);\r\n        }\r\n        if (ifShowPoint) {\r\n            // 显示当前节点的连接点\r\n            this.showConnectorPoint('jagged', undefined, true);\r\n            var params = this.returnConnectorControlParam(node);\r\n            if (params.scaleable || params.rotatable) {\r\n                // 显示当前节点的控制点\r\n                this.showConnectorControl();\r\n            }\r\n        }\r\n        // 在存在子流程的情况下 需要把node也传递一下\r\n        this.operationNode.refreshPostion(node, shapeRect);\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 节点的移动操作, 为何要自己实现拖动？zredner Group不支持拖动，只能自己实现\r\n     */\r\n    fishTopoProto.drag = function (node) {\r\n        var that = this; // zrender中的一个bug event.target不会带group 只能用that 不能用bind(this)\r\n        node.on(\"mousedown\", function (event) {\r\n            var draggingTarget = this;\r\n            //如果加了属性 draggable:false或者拖拽框选里 则不可以拖动\r\n            if (draggingTarget.isdraggable == false || (this.parent && this.parent.type === \"dragSelect\")) {\r\n                return;\r\n            }\r\n            that._nodeDragHandler(draggingTarget, event.offsetX, event.offsetY);\r\n            event.cancelBubble = true;\r\n        });\r\n    };\r\n\r\n    fishTopoProto._nodeDragHandler = function (node, x, y) {\r\n        var isMove = 0;\r\n        var ts = this;\r\n        var nowGroupPosition = node.position;\r\n        var groupPositionX = node.position[0];\r\n        var groupPositionY = node.position[1];\r\n        node._startX = x;\r\n        node._startY = y;\r\n        if (node.type === \"dragSelect\") {\r\n            var allLines = this.group.children().filter(function (v) {\r\n                return v.model && v.model.option.elementType === \"connection\";\r\n            });\r\n            var nodes = this.dragSelectRect.children().filter(function (v) {\r\n                return v.name !== \"GROUP_RECT_NAME\" && v.model && v.model.option.elementType !== \"connection\";\r\n            });\r\n            var lines = this.dragSelectRect.children().filter(function (v) {\r\n                return v.name !== \"GROUP_RECT_NAME\" && v.model && v.model.option.elementType === \"connection\";\r\n            });\r\n            allLines.forEach(function (v) {\r\n                var startNode = nodes.find(function(node) {\r\n                    return node.id === v.startNode.id\r\n                });\r\n                var endNode = nodes.find(function(node) {\r\n                    return node.id === v.endNode.id\r\n                });\r\n                var ifExist = lines.findIndex(function(line) {\r\n                    return line.id === v.id\r\n                });\r\n                if ((startNode || endNode) && ifExist === -1) {\r\n                    ts.connectionManager.removeLine(v, ts._getParentZr(v));\r\n                }\r\n            });\r\n        }\r\n        node.trigger(\"dragstart\");\r\n        // 1、侦听移动事件\r\n\r\n        var moveHandler = function (event) {\r\n            event.cancelBubble = true;\r\n            var sX = (event.offsetX - node._startX) / (this.nowZoom);\r\n            var sY = (event.offsetY - node._startY) / (this.nowZoom);\r\n\r\n            if ((sX != 0) || (sY != 0)) {\r\n                isMove = 1;\r\n            }\r\n            node.trigger(\"drag\");\r\n            // 1.1处理组内的情况（如果节点拖动，组也跟着变）\r\n            if (Flow.isInGroup(node)) {\r\n                //放入node现有数值，用于重绘group\r\n                var nodeMessage = {\r\n                    width: Flow.isGroupNode(node) ? node.options.shape.width : (node.shape ? node.shape.width : node.style.width),\r\n                    height: Flow.isGroupNode(node) ? node.options.shape.height : (node.shape ? node.shape.height : node.style.height),\r\n                    position: node.position,\r\n                    movePosition: [groupPositionX, groupPositionY],\r\n                    moveX: sX,\r\n                    moveY: sY,\r\n                    node: node,\r\n                    isMove: isMove\r\n                };\r\n                node.parent.modifyGroupRect(nodeMessage);\r\n            }\r\n            nowGroupPosition[0] = groupPositionX + sX;\r\n            nowGroupPosition[1] = groupPositionY + sY;\r\n            node.attr(\"position\", nowGroupPosition);\r\n            // 1.2 处理告警的情况 （告警随着节点移动）\r\n            if (node.alarm) {\r\n                var newAlarmPosition = [nowGroupPosition[0] + node.getBoundingRect().width - (node.alarm\r\n                        .getBoundingRect().width - 6), nowGroupPosition[1] - node.alarm.getBoundingRect()\r\n                    .height - 3\r\n                ];\r\n                node.alarm.attr(\"position\", newAlarmPosition);\r\n            }\r\n            // 1.4 触发点击\r\n            this.nodeClickHandler(node);\r\n            // 1.5 刷新连线\r\n            this.connectionManager.refreshLineByNode(node);\r\n            // 1.6 如果是组的话,需要把组内所有结果都刷新一下线\r\n            if (Flow.isGroupNode(node)) {\r\n                node.each(function(childNode) {\r\n                    this.connectionManager.refreshLineByNode(childNode);\r\n                }.bind(this));\r\n            }\r\n            if (!Flow.isInGroup(node)) {\r\n                var group = this.isPosInGroup(this.allNodes, node);\r\n                for (var i = 0; i < this.allNodes.length; i++) {\r\n                    var item = this.allNodes[i];\r\n                    if (Flow.isGroupNode(item)) {\r\n                        if (group && item.id === group.id && item.id !== node.id) {\r\n                            item.children().find(function (v) {\r\n                                return v.name === \"GROUP_RECT_NAME\"\r\n                            }).attr(\"style\", {\r\n                                fill: \"#b6e3f5\"\r\n                            });\r\n                        } else {\r\n                            //恢复group的背景色\r\n                            item.children().find(function (v) {\r\n                                return v.name === \"GROUP_RECT_NAME\"\r\n                            }).attr(\"style\", {\r\n                                fill: \"rgba(0,0,0,0)\"\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }.bind(this);\r\n        this._zr.on('mousemove', moveHandler);\r\n\r\n\r\n\r\n        //2. 拖拽结束\r\n        var endDragHandler = function () {\r\n            if (node.model) {\r\n                node.model.set(\"options.position\", FlowUtil.truncPosition(node.position));\r\n            }\r\n\r\n            this._zr.off('mousemove', moveHandler);\r\n            this._zr.off('mouseup', endDragHandler);\r\n            this._zr.off(\"globalout\", endDragHandler);\r\n\r\n            //2.1 缩微图\r\n            if (isMove == 1) {\r\n                this._trigger(\"dropDrag\", {target:node});\r\n                node.trigger(\"dragend\");\r\n                if (this.eagleEye == true) {\r\n                    this.openEagleEye(this.eagleEyeNode);\r\n                }\r\n                if (!Flow.isInGroup(node)) {\r\n                    var group = this.isPosInGroup(this.allNodes, node);\r\n                    if (group) {\r\n                        for (var i = 0; i < this.allNodes.length; i++) {\r\n                            var item = this.allNodes[i];\r\n                            if (Flow.isGroupNode(item) && item.id === group.id && item.id !== node.id) {\r\n                                var parentZr = this._getParentZr(node);\r\n                                parentZr.remove(node);\r\n                                item.add(node);\r\n                                var nodeX = Flow.isGroupNode(node) ? node.position[0] + node.options.shape.x : node.position[0];\r\n                                var nodeY = Flow.isGroupNode(node) ? node.position[1] + node.options.shape.y : node.position[1];\r\n                                var groupX = this.parentX(group);\r\n                                var groupY = this.parentY(group);\r\n                                node.attr(\"position\", [nodeX - groupX + item.options.shape.x, nodeY - groupY + item.options.shape.y]);\r\n                                item.children().find(function (v) {\r\n                                    return v.name === \"GROUP_RECT_NAME\"\r\n                                }).attr(\"style\", {\r\n                                    fill: \"rgba(0,0,0,0)\"\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                this.stepCounter();\r\n            }\r\n        }.bind(this);\r\n        this._zr.on('mouseup', endDragHandler);\r\n        this._zr.on('globalout', endDragHandler);\r\n    }\r\n    fishTopoProto.parentX = function (node) {\r\n        if (node.parent && Flow.isGroupNode(node.parent) && this.group.id !== node.parent.id) {\r\n            return node.position[0] + node.options.shape.x + this.parentX(node.parent);\r\n        } else {\r\n            return node.position[0] + node.options.shape.x;\r\n        }\r\n    }\r\n\r\n    fishTopoProto.parentY = function (node) {\r\n        if (node.parent && Flow.isGroupNode(node.parent) && this.group.id !== node.parent.id) {\r\n            return node.position[1] + node.options.shape.y + this.parentY(node.parent);\r\n        } else {\r\n            return node.position[1] + node.options.shape.y;\r\n        }\r\n    }\r\n\r\n    fishTopoProto.isPosInGroup = function (allNodes, node) {\r\n        if (allNodes.length > 0) {\r\n            var res = null;\r\n            for (var i = 0; i < allNodes.length; i++) {\r\n                var group = allNodes[i];\r\n                if (Flow.isGroupNode(group)) {\r\n                    var groupWidth = group.options.shape.width;\r\n                    var groupHeight = group.options.shape.height;\r\n                    var groupX = this.parentX(group);\r\n                    var groupY = this.parentY(group);\r\n                    var rect = util.getRect(node, true);\r\n                    var nodeWidth = rect.width;\r\n                    var nodeHeight = rect.height;\r\n                    var nodeX = rect.x - nodeWidth/2;\r\n                    var nodeY = rect.y - nodeHeight/2;\r\n                    if (nodeX >= groupX && nodeY >= groupY && nodeX+nodeWidth <= groupX+groupWidth && nodeY+nodeHeight <= groupY+groupHeight) {\r\n                        var children = group.children();\r\n                        var sub = this.isPosInGroup(children, node);\r\n                        res = sub ? sub : group;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            return res;\r\n        }\r\n        return null\r\n    }\r\n\r\n\r\n    /**\r\n     * 创建节点\r\n     * @method createNode\r\n     * @param  {String} type 类型 eg. 'Rect'、'Circle'、'Image'、'Group'、'Text'等\r\n     * @param  {Object} opt 节点选项 详见{@link fishTopoFlow.node Config options}\r\n     * @param {Object} userData 用户传递的业务数据\r\n     * @return {Object} 创建的节点对象\r\n     *\r\n     * **使用范例**：\r\n     *\r\n     *      @example\r\n     *      var rect = this.fishTopo.createNode(\"Rect\", { //矩形\r\n     *          shape: {\r\n     *              width: 100,\r\n     *              height: 60,\r\n     *          },\r\n     *          style: {\r\n     *              text: \"基本矩形\",\r\n     *              fill: \"#167CFF\",\r\n     *              stroke: \"rgb(255,255,255)\",\r\n     *              textFont: '14px Microsoft YaHei'\r\n     *          },\r\n     *          position: [180, 100],\r\n     *          operationIcons: [{ name: 'DEL' },\r\n     *              { name: 'STRAIGHT' },\r\n     *              { name: 'JAGGED' },\r\n     *              { name: 'CURVE' },\r\n     *              {\r\n     *                  name: \"custom1\",\r\n     *                  iconPath: \"img/host.png\",\r\n     *                  callback: function(e) { alert(e.data.name + \" clicked\") }  //e.node是当前的节点\r\n     *              }\r\n     *          ]\r\n     *      });\r\n     */\r\n    fishTopoProto.createNode = fishTopoProto.creatNode = function (type, opt, userData) {\r\n        if (!flowNode[type]) {\r\n            return null;\r\n        }\r\n        var Shape = flowNode[type];\r\n        var node = new Shape(opt);\r\n\r\n        Flow.setUserData(node, userData);\r\n        return node;\r\n    };\r\n\r\n    /**\r\n     * 根据name获取节点\r\n     * @param  {String} name 在创建节点中  name属性设置的值\r\n     * @return {Object}      name对应的节点\r\n     */\r\n    fishTopoProto.childOfName = function (name) {\r\n        var arrResult = [];\r\n        var childrenNode = this.allNodes;\r\n        var childrenLine = this.connectionManager.connectors;\r\n        for (var i = 0; i < childrenNode.length; i++) {\r\n            if (childrenNode[i].model.get(\"options.name\") && childrenNode[i].model.get(\"options.name\") ==\r\n                name) {\r\n                arrResult.push(childrenNode[i]);\r\n            } else if (childrenNode[i].model.get(\"userData.name\") == name) {\r\n                arrResult.push(childrenNode[i]);\r\n            }\r\n        }\r\n        for (var j = 0; j < childrenLine.length; j++) {\r\n            if (childrenLine[j].model.get(\"options.name\") && childrenLine[j].model.get(\"options.name\") ==\r\n                name) {\r\n                arrResult.push(childrenLine[j]);\r\n            } else if (childrenLine[j].model.get(\"userData.name\") == name) {\r\n                arrResult.push(childrenLine[j]);\r\n            }\r\n        }\r\n        if (arrResult.length > 1) {\r\n            return arrResult;\r\n        } else {\r\n            return arrResult[0];\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 查找场景中的对象   例如: x坐标大于100的节点 findElements(function(node){ return node.position[0] > 100; });\r\n     * @param  {Function} cb      回调函数 参数为遍历的节点\r\n     * @param  {Object}   context 回调函数执行的上下文\r\n     * @return {Array}           返回查找到的对象\r\n     */\r\n    fishTopoProto.findElements = function (cb, context) {\r\n        var childrenNode = this.allNodes;\r\n        var childrenLine = this.connectionManager.connectors;\r\n        var arr = [];\r\n        for (var i = 0; i < childrenNode.length; i++) {\r\n            var child = childrenNode[i];\r\n            if (cb.call(context, child, i)) {\r\n                arr.push(child);\r\n            }\r\n        }\r\n        for (var j = 0; j < childrenLine.length; j++) {\r\n            var childL = childrenLine[j];\r\n            if (cb.call(context, childL, j)) {\r\n                arr.push(childL);\r\n            }\r\n        }\r\n        return arr;\r\n    };\r\n\r\n    /**\r\n     * 根据节点查找连线   例如: 默认查找开始节点的连线 findConnectorsByNode(node);\r\n     * @param  {Object}   node    节点\r\n     * @param  {Object}   options 是否查找开始节点\r\n     * @return {Array}            返回查找到的对象\r\n     */\r\n    fishTopoProto.findConnectorsByNode = function (node,options) {\r\n        var opts = options || {};\r\n        var arr = [];\r\n        // Default value\r\n        zrUtil.defaults(opts, {\r\n            startNode: true\r\n        });\r\n        var childrenLine = this.connectionManager.connectors;\r\n        for (var j = 0; j < childrenLine.length; j++) {\r\n            var childL = childrenLine[j];\r\n            if (opts.startNode) {\r\n                if(childL.startNode.id === node.id) {\r\n                    arr.push(childL);\r\n                }\r\n            } else {\r\n                if(childL.endNode.id === node.id) {\r\n                    arr.push(childL);\r\n                }\r\n            }\r\n        }\r\n        return arr;\r\n    };\r\n\r\n    /**\r\n     * 设置背景色  或 背景图片\r\n     * @param {string} imageUrl 背景色  或 背景图片 eg. 'img/bg.jpg'，为‘gridLine’时网格背景\r\n     * @param {string} isRepeat 是否重复背景  如果重复的话，将使用css的repeat 因为canvas不支持repeat\r\n     */\r\n    fishTopoProto.setBackground = function (imageUrl, isRepeat) {\r\n        if (imageUrl && imageUrl.length > 0) {\r\n            this.model.set(Constants.BACKGROUND, imageUrl);\r\n            if (imageUrl.substr(0, 1) == \"#\" || imageUrl.substr(0, 4) == \"rgba\") { //如果是颜色创建rect为背景\r\n                if (!document.createElement('canvas').getContext) {\r\n                    this._dom.style.backgroundColor = imageUrl;\r\n                } else {\r\n                    var imageShape = new this.Shape.Rect({\r\n                        shape: {\r\n                            width: this._zr.getWidth(),\r\n                            height: this._zr.getHeight()\r\n                        },\r\n                        style: {\r\n                            fill: imageUrl\r\n                        },\r\n                        cursor: 'default',\r\n                        z: -1\r\n                    });\r\n                    this._zr.add(imageShape);\r\n                }\r\n\r\n            } else if (imageUrl == \"gridLine\") {\r\n                this.gridLineGroup = new graphic.Group();\r\n                this.gridLine(0.2);\r\n                this._zr.add(this.gridLineGroup);\r\n            } else {\r\n                if (!document.createElement('canvas').getContext || isRepeat) {\r\n                    this._dom.style.backgroundImage = \"url(\" + imageUrl + \")\";\r\n                    this._dom.style.backgroundRepeat = \"repeat\";\r\n                } else {\r\n                    var imageShape1 = new this.Shape.Image({ //如果是图片创建image为背景\r\n                        position: [0, 0],\r\n                        scale: [1, 1],\r\n                        style: {\r\n                            x: 0,\r\n                            y: 0,\r\n                            image: imageUrl,\r\n                            width: this._zr.getWidth(),\r\n                            height: this._zr.getHeight()\r\n                        },\r\n                        cursor: 'default',\r\n                        z: -1\r\n                    });\r\n                    this._zr.add(imageShape1);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    //背景网格线\r\n    fishTopoProto.gridLine = function (opacity) {\r\n        var pixel = 10;\r\n        var widthLen = parseInt(this.getWidth() / pixel);\r\n        for (var x = 0; x <= widthLen; x++) {\r\n            var lineX = new graphic.Line({\r\n                shape: {\r\n                    x1: x * pixel,\r\n                    y1: 0,\r\n                    x2: x * pixel,\r\n                    y2: this.getHeight()\r\n                },\r\n                style: {\r\n                    lineDash: [1],\r\n                    opacity: opacity\r\n                },\r\n                z: 0,\r\n                draggable: false,\r\n                cursor: 'default'\r\n            });\r\n            this.gridLineGroup.add(lineX);\r\n        }\r\n\r\n        var heightLen = parseInt(this.getHeight() / pixel, pixel);\r\n        for (var y = 0; y <= heightLen; y++) {\r\n            var lineY = new graphic.Line({\r\n                shape: {\r\n                    x1: 0,\r\n                    y1: y * pixel,\r\n                    x2: this.getWidth(),\r\n                    y2: y * pixel\r\n                },\r\n                style: {\r\n                    lineDash: [1],\r\n                    opacity: opacity\r\n                },\r\n                z: 0,\r\n                draggable: false,\r\n                cursor: 'default'\r\n            });\r\n            this.gridLineGroup.add(lineY);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 创建线段\r\n     * @method createLink\r\n     * @param  {Object} startNode 开始节点\r\n     * @param  {Object} endNode   结束节点\r\n     * @param  {Object} options 线段选项\r\n     * @param {Object} [options.style] 节点的样式\r\n     * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n     * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n     * @param {Object} [options.symbol] 线段的箭头\r\n     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]\r\n     * @param {Object} [options.text] 线段上的文字\r\n     * @param {String} [options.text.text] 线段上的文字内容\r\n     * @param {String} [options.text.color] 线段上的文字颜色\r\n     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]\r\n     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n     * @param {String} [options.position] 指定线段位置\r\n     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n     * @param {Object} [options.position.startOffset] 线段开始位置的偏移\r\n     * @param {Object} [options.position.endOffset] 线段结束位置的偏移\r\n     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]\r\n     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n     * @param {Object} [options.effect] 线上动态效果\r\n     * @param {String} [options.effect.show] 是否显示箭头动效\r\n     * @param {Number} [options.effect.period] 动效移动速度\r\n     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n     * @param {Number} [options.z] [连线的层级，越大越在前面显示]\r\n     * @param {Object} userData 用户传递的业务数据\r\n     * @return {Object} 创建的线段对象\r\n     *\r\n     * **使用范例**：\r\n     *\r\n     *      @example\r\n     *      var link = me.fishTopo.createLink(startNode, endNode, {\r\n     *              symbol: { type: 'arrow', size: 10, color: \"rgb(0,200,255)\" }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n     *              style: { lineWidth: 3, stroke: \"rgb(0,200,255)\", lineDash: [3,3], lineType: \"jagged\"  }, //样式\r\n     *              text: {\r\n     *                  text: text,\r\n     *                  color: '#ffffff',\r\n     *                  textPos:textPos,//文字位置可选值 'start','center','end',默认值为center\r\n     *                  xOffset:10, //文字位置x偏移量\r\n     *              },\r\n     *              pos:'right,left',\r\n     *              effect: {\r\n     *                  show: true,//是否显示箭头动效\r\n     *                  period: 6,//箭头速度\r\n     *              },\r\n     *              position:{\r\n     *                    escapeDistance:[50,30],  //第一条折线的长度，最后一条折线的长度\r\n     *                    points:[\"x1,y1\",\"x2,y2\"]  不使用自动计算 指定连线的位置数组\r\n     *              },\r\n     *              z: 0\r\n     *          });\r\n     */\r\n    fishTopoProto.createLink = fishTopoProto.creatLink = function (startNode, endNode, options, userData) {\r\n        var linkType = Connector.TYPE_STRAIGHT;\r\n        if (options && options.style && options.style.lineType) {\r\n            linkType = options.style.lineType\r\n        }\r\n\r\n        if (!flowLink[linkType]) {\r\n            return null;\r\n        }\r\n        var Link = flowLink[linkType];\r\n        var connector = new Link(startNode, endNode, options);\r\n        if (userData) {\r\n            connector.model.set(Constants.USERDATA, zrUtil.clone(userData));\r\n        }\r\n\r\n        return connector;\r\n    };\r\n\r\n    /**\r\n     * 根据节点刷新节点所连的线（重新计算线的位置）\r\n     * @param  {Object} node [节点]\r\n     */\r\n    fishTopoProto.refreshLineByNode = function (node) {\r\n        this.connectionManager.refreshLineByNode(node);\r\n    };\r\n\r\n\r\n    /**\r\n     * @private\r\n     * 线上文字编辑\r\n     */\r\n    fishTopoProto.connectorEdit = function (thisConnector) {\r\n        var lineText = thisConnector.childOfName('lineText');\r\n        if (!lineText) {\r\n            return;\r\n        }\r\n        var textarea = this.createTextArea();\r\n        var textRect = textContain.getBoundingRect(lineText.style.text, lineText.style.textFont);\r\n        var maxWidth = 1.2 * util.getRect(lineText).width * this.nowZoom + 10;\r\n        textarea.style.width = 1.2 * util.getRect(lineText).width * this.nowZoom + \"px\";\r\n        textarea.style.height = (2 * textRect.height || 12) * this.nowZoom + \"px\";\r\n        textarea.style.border = \"1px dashed #2e2e2e\";\r\n        textarea.innerHTML = lineText.style.text;\r\n        thisConnector.setStyle({\r\n            text: {\r\n                text: \"\"\r\n            }\r\n        })\r\n        this._dom.appendChild(textarea);\r\n        this._dom.style.position = \"relative\";\r\n        textarea.style.lineHeight = (1.2 * textRect.lineHeight || 12) + \"px\";\r\n        textarea.style.top = (lineText.position[1] - textRect.height) * this.nowZoom + this.group\r\n            .position[1] + \"px\";\r\n        textarea.style.left = (lineText.position[0] - 0.55 * textRect.width) * this.nowZoom +\r\n            this.group.position[0] + \"px\";\r\n        textarea.focus();\r\n        textarea.select();\r\n        this._textareaResize(textRect, textarea, maxWidth);\r\n        textarea.onkeyup = function () {\r\n            textarea.style.width = textRect.width < 60 ? \"80px\" : textarea.style.width;\r\n            textarea.style.height = textarea.scrollHeight + 'px';\r\n        }\r\n        textarea.onfocusout = function () {\r\n            thisConnector.setStyle({\r\n                text: {\r\n                    text: textarea.value || \"\"\r\n                }\r\n            })\r\n            textarea.remove();\r\n        }\r\n    };\r\n    /**\r\n     * @private\r\n     * 节点上文字编辑\r\n     */\r\n    fishTopoProto.nodeEdit = function (thisNode) {\r\n        var MAXWIDTH_MULTIPLE_TOP_BOTTOM = 3.3; //text最大宽度与节点宽度的系数，在top/bottom位置\r\n        var isNotSetText = false;\r\n        var textarea = this.createTextArea();\r\n        var nodeText = zrUtil.clone(thisNode.style.text);\r\n        var textRect = textContain.getBoundingRect(nodeText, thisNode.style.textFont);\r\n        var textareaWidth = textRect.width < 25 ? (1.2 * textRect.width * this.nowZoom + 10) : 36;\r\n        var textareaHeight = (2 * textRect.height || 24) * this.nowZoom;\r\n        textarea.style.width = textareaWidth + 'px';\r\n        textarea.style.height = textareaHeight + \"px\";\r\n        var nodeRect = util.getRect(thisNode);\r\n        var maxWidth = 1.2 * nodeRect.width * this.nowZoom;\r\n        textarea.style.lineHeight = (1.2 * textRect.lineHeight || 14.4) + \"px\";\r\n        textarea.style.border = \"1px dashed #2e2e2e\";\r\n        textarea.innerHTML = thisNode.style.text;\r\n        textarea.style.maxWidth = maxWidth + 'px';\r\n        this.setStyle(thisNode, {text: \"\"});  //先把节点文本给清空，否则删除文本框中文字的时候，会显示出来\r\n        this._dom.appendChild(textarea);\r\n        this._dom.style.position = \"relative\";\r\n        var offestI = 1;\r\n        if (thisNode.style.textAlign == \"left\") {\r\n            offestI = 0;\r\n        }\r\n        if (thisNode.style.textAlign == \"right\") {\r\n            offestI = 2;\r\n        }\r\n        var offestP = 0;\r\n        if (thisNode.style.textPosition && thisNode.style.textPosition == \"bottom\") {\r\n            offestP = 1;\r\n            maxWidth = MAXWIDTH_MULTIPLE_TOP_BOTTOM * nodeRect.width * this.nowZoom;\r\n            textarea.style.maxWidth = maxWidth + \"px\";\r\n        }\r\n        if (thisNode.style.textPosition && thisNode.style.textPosition == \"top\") {\r\n            offestP = -1;\r\n            maxWidth = MAXWIDTH_MULTIPLE_TOP_BOTTOM * nodeRect.width * this.nowZoom;\r\n            textarea.style.maxWidth = maxWidth + \"px\";\r\n        }\r\n        textarea.style.top = (nodeRect.y - textareaHeight / 2 + offestP * (nodeRect.height - textRect.height /\r\n            2)) * this.nowZoom + this.group.position[1] + \"px\";\r\n        textarea.style.left = (nodeRect.x - offestI * textareaWidth / 2) * this.nowZoom +\r\n            this.group.position[0] + \"px\";\r\n        textarea.focus();\r\n        textarea.select();\r\n        textarea.onkeyup = function() {\r\n            if (event.keyCode == keyCode.ESCAPE) {\r\n                isNotSetText = true;\r\n                textarea.blur();\r\n            } else {\r\n                var textRect = textContain.getBoundingRect(textarea.value, thisNode.style.textFont);\r\n                this._textareaResize(textRect, textarea, maxWidth);\r\n            }\r\n        }.bind(this);\r\n\r\n        textarea.onblur = function() {\r\n            if (!isNotSetText) {\r\n                var text = this.handleWrap(textarea.value, textarea.style.maxWidth);\r\n                this.setStyle(thisNode, {text: text});\r\n            } else {\r\n                this.setStyle(thisNode, {text: nodeText});\r\n            }\r\n            textarea.remove();\r\n        }.bind(this);\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 创建文本域\r\n     */\r\n    fishTopoProto.createTextArea = function () {\r\n        var textarea = document.createElement(\"textarea\");\r\n        textarea.style.position = \"absolute\";\r\n        textarea.style.padding = \"6px\";\r\n        textarea.style.resize = \"none\";\r\n        textarea.style.whiteSpace = \"pre\";\r\n        textarea.style.lineHeight = \"125%\";\r\n        textarea.style.overflow = \"hidden\";\r\n        textarea.style.border = \"0\";\r\n        textarea.spellcheck = false;\r\n        return textarea;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 处理textarea自动换行\r\n     */\r\n    fishTopoProto.handleWrap = function (value, width) {\r\n        var spanNode = document.createElement(\"span\");\r\n        spanNode.style.position = \"absolute\";\r\n        spanNode.style.overflow = \"hidden\";\r\n        spanNode.style.border = \"0\";\r\n        spanNode.style.padding = \"0\";\r\n        spanNode.style.left = \"0\";\r\n        spanNode.style.top = \"0\";\r\n        this._dom.appendChild(spanNode);\r\n        var content = value.split(\"\\n\");\r\n        var result = \"\";\r\n        content.forEach(function(val, i){\r\n            var valLength = val.length;\r\n            if (valLength == 0) {\r\n                //result += \"\\n\";\r\n            } else {\r\n                var pre = \"\",\r\n                    innerVal, tempWidth, conWidth;\r\n                for (var innerI = 0; innerI < valLength; innerI++) {\r\n                    innerVal = val.charAt(innerI);\r\n                    spanNode.innerHTML = spanNode.innerHTML + innerVal;\r\n                    tempWidth = spanNode.clientWidth; //获取添加字符后隐藏域的宽度\r\n                    conWidth = Number(width.substring(0, width.length - 2));\r\n                    if (tempWidth > conWidth) {\r\n                        result += pre; //如果追加字符后隐藏域宽度大于TextArea宽度，则表明该字符为下一行字符，\r\n                        result += \"\\n\";\r\n                        spanNode.innerHTML = innerVal;\r\n                        pre = innerVal;\r\n                    } else if (innerI == valLength - 1) {\r\n                        result += pre + innerVal; //最后一个字符\r\n                        if (i < content.length - 1) {\r\n                            result += \"\\n\";\r\n                        }\r\n                        spanNode.innerHTML = \"\";\r\n                        pre = \"\";\r\n                    } else {\r\n                        pre += innerVal; //依次追加到pre变量中\r\n                    }\r\n\r\n                }\r\n            }\r\n        });\r\n        this._dom.removeChild(spanNode);\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 文本域自适应高宽\r\n     */\r\n    fishTopoProto._textareaResize = function (textRect, textarea, width) {\r\n        var minWidth = 0;\r\n        textarea.style.width = 0;\r\n        textarea.style.width = (1.2 * textRect.width) * this.nowZoom + \"px\";\r\n        if (width < 60) {\r\n            minWidth = width;\r\n        } else {\r\n            minWidth = 80\r\n        }\r\n        if (textRect.width <= minWidth) {\r\n            textarea.style.width = minWidth + \"px\";\r\n        }\r\n        textarea.style.height = \"0px\";\r\n        textarea.style.height = textarea.scrollHeight + 'px';\r\n        if (textarea.scrollHeight <= 0) {\r\n            textarea.style.height = \"12px\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method setStyle\r\n     * 节点更改style里的属性\r\n     * @param {String} name 节点style里的某个属性名称\r\n     * @param {String} string 节点style里的某个属性名称对应的值\r\n     * **使用范例**：\r\n     *\r\n     *      @example\r\n     *          //节点设置文字\r\n     *         fishtopo.setStyle(node,{text:\"例子\"});\r\n     */\r\n    fishTopoProto.setStyle = function (node, options) {\r\n        node.setStyle(options);\r\n        zrUtil.merge(node.model.get(\"options.style\"), options, true);\r\n    }\r\n\r\n    /**\r\n     * @method setShape\r\n     * 节点更改shape里的属性\r\n     * @param {String} name 节点shape里的某个属性名称\r\n     * @param {String} string 节点shape里的某个属性名称对应的值\r\n     * **使用范例**：\r\n     *\r\n     *      @example\r\n     *          //矩形节点设置宽\r\n     *         fishtopo.setShape(node,{width:100});\r\n     */\r\n    fishTopoProto.setShape = function (node, options) {\r\n        node.setShape(options);\r\n        if (node.model) {\r\n            zrUtil.merge(node.model.get(\"options.shape\"), options, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 创建节点上面的警告\r\n     * @method createAlarm\r\n     * @param  {Object} node 节点\r\n     * @param  {Object} opt  选项值\r\n     * @param  {Object} [opt.text] 警告的文字\r\n     * @param  {Object} [opt.textFont] 警告的文字的字体\r\n     * @param  {Object} [opt.textFill] 警告的文字的颜色\r\n     * @param  {Object} [opt.textBackground] 警告的背景的颜色\r\n     * @return {Object} 返回节点上的警告\r\n     *\r\n     * **使用范例**：\r\n     *\r\n     *      @example\r\n     *          this.fishTopo.createAlarm(s1,{\r\n     *          text:\"2 W\",\r\n     *          textFont:\"4px Microsoft YaHei\",\r\n     *          textFill:\"#FFFFFF\",\r\n     *          textBackground:\"rgba(255,0,0,0.6)\"\r\n     *      });//创建小图片和节点绑定\r\n     */\r\n    fishTopoProto.createAlarm = fishTopoProto.creatAlarm = function (node, opt) {\r\n        var group = this.createNode(\"Group\", {\r\n            style: {\r\n                fill: 'rgba(0,0,0,0)',\r\n                stroke: 'rgba(0,0,0,0)'\r\n            }\r\n        });\r\n        group.isdraggable = false;\r\n        var text = this.createNode(\"Text\", { //文字\r\n            style: {\r\n                text: opt.text,\r\n                textFont: opt.textFont,\r\n                fill: opt.textFill,\r\n                textBaseline: \"top\" //垂直对齐,\r\n            },\r\n            selectable: false,\r\n            position: [2, 0],\r\n            z: 2\r\n        });\r\n        text.isdraggable = false;\r\n        group.add(text);\r\n        if (Flow.isInGroup(node)) {\r\n            node.parent.add(group);\r\n        } else {\r\n            this.group.add(group);\r\n        }\r\n        var groupWidth = group.getBoundingRect().width + 2;\r\n        var groupHeight = group.getBoundingRect().height + 6;\r\n        var points = [\r\n            [0, 0],\r\n            [groupWidth, 0],\r\n            [groupWidth, groupHeight],\r\n            [groupWidth - 3, groupHeight],\r\n            [groupWidth - 6, groupHeight + 3],\r\n            [groupWidth - 9, groupHeight],\r\n            [0, groupHeight],\r\n            [0, 0]\r\n        ];\r\n        var Polyline = this.createNode(\"Polyline\", {\r\n            shape: {\r\n                points: points\r\n            },\r\n            style: {\r\n                fill: opt.textBackground,\r\n                stroke: opt.textBackground\r\n            },\r\n            selectable: false,\r\n            z: 1\r\n        });\r\n        Polyline.isdraggable = false;\r\n        group.add(Polyline);\r\n        var groupPosition = [node.position[0] + node.getBoundingRect().width - (group.getBoundingRect().width -\r\n            6), node.position[1] - group.getBoundingRect().height - 3];\r\n        group.attr(\"position\", groupPosition);\r\n        node.alarm = group;\r\n        //设置模型 给json序列化用\r\n        var model = new Model({});\r\n        model.set(Constants.ELEMENT_TYPE, Constants.ALARM);\r\n        model.set(Constants.OPTIONS, zrUtil.clone(opt));\r\n        model.set(Constants.RELATIONID, node.model.get(Constants.ID));\r\n        group.model = model;\r\n        return group;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 返回当前画布的数据\r\n     */\r\n    fishTopoProto.toDataURL = function (opts) {\r\n        return FlowUtil.toDataURL(this._zr, opts);\r\n    };\r\n\r\n    fishTopoProto._releaseSelectNode = function () {\r\n        if (this.dragSelectRect) {\r\n            var nodes = this.dragSelectRect.children().filter(function (v) {\r\n                return v.name !== \"GROUP_RECT_NAME\";\r\n            });\r\n            var groupNodesIds = this.group.children()\r\n                .filter(function (v) {\r\n                    return v.name !== \"GROUP_RECT_NAME\";\r\n                })\r\n                .map(function(v) {\r\n                    return v.id\r\n                });\r\n            var startX = this.dragSelectRect.position[0];\r\n            var startY = this.dragSelectRect.position[1];\r\n            for (var i = 0; i < nodes.length; i++) {\r\n                var item = nodes[i];\r\n                var nodeX = Flow.isGroupNode(item) ? item.position[0] + item.options.shape.x : item.position[0];\r\n                var nodeY = Flow.isGroupNode(item) ? item.position[1] + item.options.shape.y : item.position[1];\r\n                this.dragSelectRect.remove(item);\r\n                // group内不存在dragSelectRect节点方可添加\r\n                if (!groupNodesIds.includes(item.id)) {\r\n                    this.group.add(item);\r\n                }\r\n                if (item.model.option.elementType !== \"connection\") {\r\n                    item.attr(\"position\", [nodeX+startX, nodeY+startY]);\r\n                    this.connectionManager.refreshLineByNode(item);\r\n                }\r\n            }\r\n            this.dragSelectRect.off(\"mousedown\");\r\n            this.group.remove(this.dragSelectRect);\r\n        }\r\n    }\r\n\r\n    fishTopoProto._dragSelect = function (node, x, y) {\r\n        var canvasOffsetX = this.group.position[0];\r\n        var canvasOffsetY = this.group.position[1];\r\n        this._releaseSelectNode();  //还原选中的节点\r\n        this.dragSelectRect = new GroupNode({\r\n            shape:{ width: 0, height: 0},\r\n            position:[(x-canvasOffsetX)/this.nowZoom, (y-canvasOffsetY)/this.nowZoom],\r\n            childDraggable: false,\r\n            style: {\r\n                lineDash:[2,2],\r\n                fill: \"rgba(239,222,221,0.7)\",\r\n                stroke: '#ddd'\r\n            }\r\n        });\r\n        this.dragSelectRect.type = \"dragSelect\";\r\n        this.group.add(this.dragSelectRect);\r\n        this.drag(this.dragSelectRect);\r\n\r\n        var moveHandler = function (event) {\r\n            var posX = x <= event.offsetX ? x : event.offsetX;\r\n            var posY = y <= event.offsetY ? y : event.offsetY;\r\n            var width = Math.abs(event.offsetX - x);\r\n            var height = Math.abs(event.offsetY - y);\r\n            this.dragSelectRect.shape = {\r\n                width: width/this.nowZoom,\r\n                height: height/this.nowZoom\r\n            }\r\n            this.dragSelectRect.setProperties({shape: {width:width/this.nowZoom, height: height/this.nowZoom}, position: [(posX-canvasOffsetX)/this.nowZoom, (posY-canvasOffsetY)/this.nowZoom]});\r\n        }.bind(this);\r\n        this._zr.on('mousemove', moveHandler);\r\n\r\n        var endDragHandler = function (event) {\r\n            this._zr.off('mousemove', moveHandler);\r\n            this._zr.off('mouseup', endDragHandler);\r\n            this._zr.off(\"globalout\", endDragHandler);\r\n\r\n            var ts = this;\r\n            var allNodes = this.group.children().filter(function (v) {\r\n                return v.id !== ts.dragSelectRect.id && v.model && v.model.option.elementType !== \"connection\";\r\n            });\r\n            var allLines = this.group.children().filter(function (v) {\r\n                return v.model && v.model.option.elementType === \"connection\";\r\n            });\r\n            var startX = this.dragSelectRect.position[0];\r\n            var startY = this.dragSelectRect.position[1];\r\n            var width = this.dragSelectRect.options.shape.width;\r\n            var height = this.dragSelectRect.options.shape.height;\r\n            var cnt = 0;\r\n            allNodes.forEach(function (item) {\r\n                var rect = util.getRect(item, true);\r\n                var nodeWidth = rect.width;\r\n                var nodeHeight = rect.height;\r\n                var nodeX = rect.x - nodeWidth/2;\r\n                var nodeY = rect.y - nodeHeight/2;\r\n                if (nodeX >= startX && nodeY >= startY && nodeX+nodeWidth <= startX+width && nodeY+nodeHeight <= startY+height) {\r\n                    ts.group.remove(item);\r\n                    ts.dragSelectRect.add(item);\r\n                    ts.selectedNodes.push(item);\r\n                    item.attr(\"position\", [item.position[0]-startX, item.position[1]-startY]);\r\n                    cnt++;\r\n                }\r\n            });\r\n            allLines.forEach(function (item) {\r\n                var startNode = ts.dragSelectRect.children().find(function (v) {\r\n                    return v.id === item.startNode.id;\r\n                });\r\n                var endNode = ts.dragSelectRect.children().find(function (v) {\r\n                    return v.id === item.endNode.id;\r\n                });\r\n                if (startNode && endNode) {\r\n                    ts.group.remove(item);\r\n                    ts.dragSelectRect.add(item);\r\n                    ts.selectedNodes.push(item);\r\n                    ts.connectionManager.refreshLineByNode(item.startNode);\r\n                } else if (startNode || endNode) {\r\n                    // 删除选框外的节点与内节点间的连线\r\n                    ts.group.remove(item);\r\n                }\r\n            });\r\n            if (!cnt) {\r\n                this.dragSelectRect.off(\"mousedown\");\r\n                this.group.remove(this.dragSelectRect);\r\n            } else {\r\n                this.dragSelectRect.childOfName(\"GROUP_RECT_NAME\").attr(\"style\", {\r\n                    fill: \"rgba(0,0,0,0)\"\r\n                });\r\n            }\r\n            this.dragSelectRect.model.set(\"options.position\", FlowUtil.truncPosition(this.dragSelectRect.position));\r\n            this.dragSelectRect.model.set(\"options.shape\", this.dragSelectRect.shape);\r\n            // this.stepCounter();\r\n        }.bind(this);\r\n        this._zr.on('mouseup', endDragHandler);\r\n        this._zr.on(\"globalout\", endDragHandler);\r\n    }\r\n\r\n    fishTopoProto._groupDragHandler = function (x, y) {\r\n        // flow中最外层的group移动操作\r\n        var nowGroupPosition = this.group.position;\r\n        var groupPositionX = this.group.position[0];\r\n        var groupPositionY = this.group.position[1];\r\n\r\n        var moveHandler = function (event) {\r\n            var width = this.group.getBoundingRect().width * this.nowZoom;\r\n            var height = this.group.getBoundingRect().height * this.nowZoom;\r\n            var gx = this.group.getBoundingRect().x * this.nowZoom;\r\n            var gy = this.group.getBoundingRect().y * this.nowZoom;\r\n            var min = [10 - (width + gx), 10 - (height + gy)];\r\n            var max = [(this._zr.getWidth() - gx) - 10, (this._zr.getHeight() - gy) - 10];\r\n            var sX = event.offsetX - x;\r\n            var sY = event.offsetY - y;\r\n            nowGroupPosition[0] = groupPositionX + sX;\r\n            nowGroupPosition[1] = groupPositionY + sY;\r\n            if (nowGroupPosition[0] > max[0] || nowGroupPosition[1] > max[1] || nowGroupPosition[0] <\r\n                min[0] || nowGroupPosition[1] < min[1]) {\r\n                return;\r\n            } else {\r\n                this.group.attr(\"position\", nowGroupPosition);\r\n                if (this.eagleEye == true) {\r\n                    this.minimap.updataSelectionPosition(nowGroupPosition, this.nowZoom);\r\n                }\r\n            }\r\n        }.bind(this);\r\n        this._zr.on('mousemove', moveHandler);\r\n\r\n        var endDragHandler = function () {\r\n            this._zr.off('mousemove', moveHandler);\r\n            this._zr.off('mouseup', endDragHandler);\r\n            this._zr.off(\"globalout\", endDragHandler);\r\n        }.bind(this);\r\n        this._zr.on('mouseup', endDragHandler);\r\n        this._zr.on(\"globalout\", endDragHandler);\r\n    };\r\n\r\n    fishTopoProto.initScale = function () {\r\n        var groupMaxWidth = this.group.getBoundingRect().width;\r\n        var groupMaxHeight = this.group.getBoundingRect().height;\r\n        var rangeWidth = this.getWidth();\r\n        var rangeHeight = this.getHeight();\r\n        var initRatio = 1,\r\n            pos = [];\r\n        if (groupMaxWidth / groupMaxHeight > rangeWidth / rangeHeight) {\r\n            if (groupMaxWidth > rangeWidth) {\r\n                initRatio = rangeWidth / groupMaxWidth;\r\n            }\r\n        } else {\r\n            if (groupMaxHeight > rangeHeight) {\r\n                initRatio = rangeHeight / groupMaxHeight;\r\n            }\r\n        }\r\n        pos[0] = Math.abs(this.group.getBoundingRect().x) * initRatio;\r\n        pos[1] = Math.abs(this.group.getBoundingRect().y) * initRatio;\r\n        this.group.attr(\"position\", [pos[0], pos[1]]);\r\n        this.group.attr(\"scale\", [initRatio, initRatio]);\r\n        this.initScaleRatio = initRatio;\r\n        var distance = [pos[0], pos[1], this.initScaleRatio, groupMaxWidth, groupMaxHeight];\r\n        return distance;\r\n    };\r\n\r\n\t/**\r\n\t * 画布元素在水平方向和垂直方向居中\r\n     * @param  {Object} boundPos 其中需传入的属性分别为minX,minY,maxX,maxY包围画布上所有节点的最小边框的最小的x坐标、y坐标、最大的x坐标、y坐标\r\n\t */\r\n\tfishTopoProto.zrCenter = function (boundPos) {\r\n        var boundObj;\r\n        var nowGroupPosition = this.group.position;\r\n        if (zrUtil.isArray(boundPos)) {\r\n            boundObj = zrUtil.extend({}, {minX: boundPos[0], minY: boundPos[1], maxX: boundPos[2], maxY: boundPos[3]});\r\n        } else {\r\n            boundObj = zrUtil.extend({}, boundPos);\r\n        }\r\n        nowGroupPosition[0] = this._zr.dom.offsetWidth/2 - (boundObj.minX + ((boundObj.maxX - boundObj.minX)/2));\r\n        nowGroupPosition[1] = this._zr.dom.offsetHeight/2 - (boundObj.minY + ((boundObj.maxY - boundObj.minY)/2));\r\n        this.group.attr(\"position\", nowGroupPosition);\r\n    };\r\n\r\n    fishTopoProto.stepCounter = function() {\r\n        this.stepJson.splice(this.step, this.stepJson.length - (this.step));\r\n        this.step += 1;\r\n        var json = this.toJson();\r\n        this.stepJson.push(JSON.stringify(json));\r\n    };\r\n\r\n    /**\r\n     * 放大或者缩小\r\n     * @param  {String|Number} type 当为字符串时 \"enlarge\"放大  \"narrowing\"缩小  当为数值时 缩放的比例  建议0.3-1.7\r\n     */\r\n    fishTopoProto.zrScale = function (type) {\r\n        if (type) {\r\n            var zoomDelta = 0;\r\n            if (type == \"narrowing\") {\r\n                zoomDelta = -0.07;\r\n                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n            }\r\n            if (type == \"enlarge\") {\r\n                zoomDelta = 0.07;\r\n                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n            }\r\n            if (!isNaN(type)) {\r\n                var target = this.group;\r\n                if (target) {\r\n                    var zoomScale = type / target.scale[0];\r\n                    this._zoom = type;\r\n                    this.nowZoom = type;\r\n                    this.setScale(this._zr.getWidth() / 2, this._zr.getHeight() / 2,zoomScale);\r\n                }\r\n            }\r\n        } else {\r\n            this._zr.on('mousewheel', zrUtil.bind(function (e) {\r\n                eventTool.stop(e.event);\r\n                var zoomDelta = e.wheelDelta > 0 ? 0.07 : -0.07;\r\n                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n            }, this));\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    fishTopoProto.zoom = function (zoomDelta, zoomX, zoomY) {\r\n        if (this.canScale == false) {\r\n            return;\r\n        }\r\n        var target = this.group;\r\n        if (target) {\r\n\r\n            var newZoom = this._zoom = this._zoom || 1;\r\n            newZoom += zoomDelta;\r\n\r\n            newZoom = Number(newZoom.toFixed(2));\r\n            var zoomScale = newZoom / this._zoom;\r\n            if (newZoom > this.options.maxScale || newZoom < this.options.minScale) {\r\n                return;\r\n            }\r\n            this._zoom = newZoom;\r\n\r\n            this.nowZoom = newZoom;\r\n\r\n            this.setScale(zoomX, zoomY, zoomScale);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    fishTopoProto.setScale = function (zoomX, zoomY, zoomScale) {\r\n        var target = this.group;\r\n        var pos = target.position;\r\n        var scale = target.scale;\r\n        // Keep the mouse center when scaling\r\n        pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);\r\n        pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);\r\n        scale[0] *= zoomScale;\r\n        scale[1] *= zoomScale;\r\n        target.attr(\"position\", [pos[0], pos[1]]);\r\n        target.attr(\"scale\", [scale[0], scale[1]]);\r\n        if (this.eagleEye == true) {\r\n            this.minimap.updataSelection(pos[0], pos[1], zoomScale, this.nowZoom);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 鹰眼图\r\n     * @param  {HTMLElement} eagleEyeNode 显示鹰眼图的div元素\r\n     */\r\n    fishTopoProto.openEagleEye = function (eagleEyeNode) {\r\n        this.eagleEye = true;\r\n        this.eagleEyeNode = eagleEyeNode;\r\n        var groupPosition = zrUtil.clone(this.group.position);\r\n        var groupScale = zrUtil.clone(this.group.scale);\r\n        this.group.attr(\"position\", [0, 0]);\r\n        this.group.attr(\"scale\", [1, 1]);\r\n        var distance = this.initScale();\r\n        var imgSrc = this.toDataURL();\r\n        this.group.attr(\"position\", groupPosition);\r\n        this.group.attr(\"scale\", groupScale);\r\n        if (this.minimap) {\r\n            this.minimap.updataMap(imgSrc, this.group.getBoundingRect());\r\n        } else {\r\n            this.minimap = new Minimap(this, this.group.position, this.group.getBoundingRect(),\r\n                eagleEyeNode, distance, imgSrc);\r\n            setTimeout(zrUtil.bind(function () {\r\n                this.openEagleEye(this.eagleEyeNode)\r\n            }, this), 10);\r\n        }\r\n        this.minimap.selection.addEventListener(\"mousedown\", function (e) {\r\n            var startX = e.clientX;\r\n            var startY = e.clientY;\r\n            var minimapLeft = Number(this.minimap.selection.style.left.substring(0, this.minimap.selection\r\n                .style.left.length - 2));\r\n            var minimapTop = Number(this.minimap.selection.style.top.substring(0, this.minimap.selection\r\n                .style.top.length - 2));\r\n            var eagleEyeMove = function (e) {\r\n                var offsetX = e.clientX - startX;\r\n                var offsetY = e.clientY - startY;\r\n                this.minimap.selection.style.left = minimapLeft + offsetX + \"px\";\r\n                this.minimap.selection.style.top = minimapTop + offsetY + \"px\";\r\n                this.minimap.updataGroupPosition(this.group, this.nowZoom);\r\n            }.bind(this);\r\n\r\n            this.minimap.selection.addEventListener(\"mousemove\", eagleEyeMove);\r\n\r\n            var eagleEyeUp = function () {\r\n                this.minimap.selection.removeEventListener(\"mousemove\", eagleEyeMove);\r\n                this.minimap.selection.removeEventListener(\"mouseup\", eagleEyeUp);\r\n            }.bind(this);\r\n            this.minimap.selection.addEventListener(\"mouseup\", eagleEyeUp);\r\n        }.bind(this))\r\n    };\r\n\r\n    /**\r\n     * 根据节点位置变化更新组边框的大小\r\n     * @param {Object} node 节点\r\n     * @since V2.3.0\r\n     */\r\n    fishTopoProto.refreshGroupByNode = function (node) {//#181\r\n        if (Flow.isInGroup(node)) {\r\n            //放入node现有数值，用于重绘group\r\n            var nodeMessage = {\r\n                width: node.shape.width,\r\n                height: node.shape.height,\r\n                position: node.position,\r\n                isMove: 0,\r\n                node: node\r\n            };\r\n            node.parent.modifyGroupRect(nodeMessage);\r\n        }\r\n        this.connectionManager.refreshLineByNode(node);\r\n        if (Flow.isGroupNode(node)) {\r\n            node.each(function (childNode) {\r\n                this.connectionManager.refreshLineByNode(childNode);\r\n            }.bind(this));\r\n        }\r\n    };\r\n\r\n    zrUtil.mixin(FishTopoFlow, Eventful);\r\n\r\n    // ---------对外暴露fishTopoFlow------------------\r\n    var idBase = new Date() - 0;\r\n    var instances = {};\r\n    var DOM_ATTRIBUTE_KEY = '_fishTopoFlow_instance_';\r\n\r\n    /**\r\n     * fishTopoFlow全局对象，如果是amd方式加载，则直接返回\r\n     * @class fishTopoFlow\r\n     * @singleton\r\n     *\r\n     * **使用范例**：\r\n     *\r\n     *      @example\r\n     *      var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n     */\r\n    var fishTopoFlow = {\r\n        /**\r\n         * 版本号\r\n         * @type {String}\r\n         */\r\n        version: '3.0.0',\r\n        dependencies: {\r\n            zrender: '3.6.3'\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 初始化dom元素为 flow对象\r\n     * @member fishTopoFlow\r\n     * @param {HTMLElement} dom  一个div元素\r\n     * @param {Object} opts  传递的选项参数\r\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg' or 'vml'\r\n     * @param {number} [opts.devicePixelRatio=1] retina 屏幕优化\r\n     * @param {boolean} [opts.linkModify=false] 是否允许调整线段\r\n     * @param {boolean} [opts.textEditable=false] 是否允许双击节点编辑文字\r\n     * @param {boolean} [opts.mouseMode='default'] 设置鼠标在画布上的操作模式，默认为'default'：无任何操作，设为'drag-move'：平移漫游，设为'drag-select'：框选节点\r\n     * @param {boolean} [opts.roam=true] 是否开启鼠标缩放。默认开启，设为false表示关闭缩放功能。\r\n     * @param {Object} [opts.tooltip] tooltip配置项\r\n     * @param {boolean} [opts.tooltip.show] tooltip配置项:控制tooltip是否显示\r\n     * @param {boolean} [opts.isAnimationEnabled=true] 是否开启动画,默认为true\r\n     * @param {boolean} [opts.scaleable=false] 是否允许缩放,默认为false\r\n     * @param {boolean} [opts.rotatable=false] 是否允许旋转,默认为false\r\n     * @param {Function} [opts.beforeDelete] 删除节点或边线 之前的回调，如果返回false则不进行后续的删除操作\r\n     * @param {Object} [opts.beforeCreate] 创建节点或边线 之前的回调，如果返回false则不进行后续的删除操作\r\n     * @return {fish.topo.FishTopoFlow}\r\n     */\r\n    fishTopoFlow.init = function (dom, opts) {\r\n        if (!dom) {\r\n            throw new Error('Initialize failed: invalid dom.');\r\n        }\r\n\r\n        opts = opts || {};\r\n        // Default value\r\n        zrUtil.defaults(opts, {\r\n            type: \"flow\",\r\n            linkModify: false,\r\n            textEditable: false,\r\n            roam: true,\r\n            mouseMode: 'default',\r\n            tooltip: {\r\n                show:true\r\n            },  //覆盖tooltipModel\r\n            isAnimationEnabled: true,\r\n            scaleable: false,\r\n            rotatable: false,\r\n            beforeDelete: null,  // 删除之前的事件\r\n            beforeCreate:null,   //创建节点或连线之前的事件\r\n            maxScale: 1.7,       //画布放大的最大比例\r\n            minScale: 0.3        //画布缩小的最小比例\r\n        });\r\n\r\n        var fishTopoFlow = new FishTopoFlow(dom, opts);\r\n        fishTopoFlow.init();\r\n        fishTopoFlow.Flow = Flow;\r\n        fishTopoFlow.id = 'ft_' + idBase++;\r\n        instances[fishTopoFlow.id] = fishTopoFlow;\r\n\r\n        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoFlow.id);\r\n\r\n        return fishTopoFlow;\r\n    };\r\n\r\n\r\n    /**\r\n     * 获取 dom 容器上的实例。\r\n     * @member fishTopoFlow\r\n     * @param  {HTMLElement} dom 一个div元素\r\n     * @return {fish.topo.FishTopoFlow}\r\n     */\r\n    fishTopoFlow.getInstanceByDom = function (dom) {\r\n        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\r\n        return instances[key];\r\n    };\r\n\r\n    /**\r\n     * 销毁实例，实例销毁后无法再被使用。\r\n     *\r\n     * @member fishTopoFlow\r\n     * @param  {Object|string} chart fishTopoBpmn实例 或 fishTopoBpmn的id\r\n     */\r\n    fishTopoFlow.dispose = function (chart) {\r\n        var topo;\r\n        if (zrUtil.isDom(chart)) {\r\n            topo = fishTopoFlow.getInstanceByDom(chart);\r\n        } else if (typeof chart === 'string') {\r\n            topo = instances[chart];\r\n        }\r\n        if ((topo instanceof fishTopoFlow) && !topo.isDisposed()) {\r\n            topo.dispose();\r\n        }\r\n    };\r\n\r\n    //暴露出去的类\r\n    fishTopoFlow.graphic = graphic;\r\n    fishTopoFlow.node = FlowUtil.registerFlowNode(flowNode);\r\n    fishTopoFlow.link = flowLink;\r\n\r\n    fishTopoFlow.layout = layout;\r\n    fishTopoFlow.Flow = Flow;\r\n    fishTopoFlow.constants = Constants;\r\n    fishTopoFlow.util = util;\r\n    fishTopoFlow.util['initImagePool'] = ImagePool.initImagePool;\r\n    zrUtil.each([\r\n            'map', 'each', 'filter', 'indexOf', 'inherits',\r\n            'reduce', 'filter', 'bind', 'curry', 'isArray',\r\n            'isString', 'isObject', 'isFunction', 'extend',\r\n            'merge', \"mergeAll\"\r\n        ],\r\n        function (name) {\r\n            fishTopoFlow.util[name] = zrUtil[name];\r\n        }\r\n    );\r\n\r\n    module.exports = fishTopoFlow;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/FishTopoFlow.js\n// module id = 2\n// module chunks = 0","\r\n    //polyfill bind\r\n    if (!Function.prototype.bind) {\r\n        Function.prototype.bind = function(oThis) {\r\n            if (typeof this !== \"function\") {\r\n                // closest thing possible to the ECMAScript 5 internal IsCallable function\r\n                throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\r\n            }\r\n\r\n            var aArgs = Array.prototype.slice.call(arguments, 1),\r\n                fToBind = this,\r\n                fNOP = function() {},\r\n                fBound = function() {\r\n                    return fToBind.apply(this instanceof fNOP && oThis ? this : oThis || window,\r\n                        aArgs.concat(Array.prototype.slice.call(arguments)));\r\n                };\r\n\r\n            fNOP.prototype = this.prototype;\r\n            fBound.prototype = new fNOP();\r\n\r\n            return fBound;\r\n        };\r\n    }\r\n\r\n    //polyfill remove\r\n    if (!('remove' in Element.prototype)) {\r\n        Element.prototype.remove = function() {\r\n            if (this.parentNode) {\r\n                this.parentNode.removeChild(this);\r\n            }\r\n        };\r\n    }\r\n\r\n    if (!String.prototype.endsWith) {\r\n    String.prototype.endsWith = function(searchString, position) {\r\n        var subjectString = this.toString();\r\n        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {\r\n            position = subjectString.length;\r\n        }\r\n        position -= searchString.length;\r\n        var lastIndex = subjectString.indexOf(searchString, position);\r\n        return lastIndex !== -1 && lastIndex === position;\r\n    };\r\n    }\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/polyfill.js\n// module id = 3\n// module chunks = 0","'use strict';\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    var pathTool = require('zrender/lib/tool/path');\r\n    var round = Math.round;\r\n    var Path = require('zrender/lib/graphic/Path');\r\n    var colorTool = require('zrender/lib/tool/color');\r\n    var matrix = require('zrender/lib/core/matrix');\r\n    var vector = require('zrender/lib/core/vector');\r\n    var Gradient = require('zrender/lib/graphic/Gradient');\r\n    var Draggable = require('zrender/lib/mixin/Draggable');\r\n\r\n    var graphic = {};\r\n    graphic.Util = zrUtil;\r\n    graphic.Group = require('zrender/lib/container/Group');\r\n\r\n    graphic.Image = require('zrender/lib/graphic/Image');\r\n\r\n    graphic.Text = require('zrender/lib/graphic/Text');\r\n\r\n    graphic.textContain = require('zrender/lib/contain/text');\r\n\r\n    graphic.Circle = require('zrender/lib/graphic/shape/Circle');\r\n\r\n    graphic.Sector = require('zrender/lib/graphic/shape/Sector');\r\n\r\n    graphic.Ring = require('zrender/lib/graphic/shape/Ring');\r\n\r\n    graphic.Polygon = require('zrender/lib/graphic/shape/Polygon');\r\n\r\n    graphic.Polyline = require('zrender/lib/graphic/shape/Polyline');\r\n\r\n    graphic.Rect = require('zrender/lib/graphic/shape/Rect');\r\n\r\n    graphic.Line = require('zrender/lib/graphic/shape/Line');\r\n\r\n    graphic.BezierCurve = require('zrender/lib/graphic/shape/BezierCurve');\r\n\r\n    graphic.Arc = require('zrender/lib/graphic/shape/Arc');\r\n\r\n    graphic.LinearGradient = require('zrender/lib/graphic/LinearGradient');\r\n\r\n    graphic.RadialGradient = require('zrender/lib/graphic/RadialGradient');\r\n\r\n    graphic.BoundingRect = require('zrender/lib/core/BoundingRect');\r\n    graphic.States = require(\"zrender/lib/graphic/States.js\");\r\n    /**\r\n     * Extend shape with parameters\r\n     */\r\n    graphic.extendShape = function (opts) {\r\n        return Path.extend(opts);\r\n    };\r\n\r\n    /**\r\n     * Extend path\r\n     */\r\n    graphic.extendPath = function (pathData, opts) {\r\n        return pathTool.extendFromString(pathData, opts);\r\n    };\r\n\r\n    /**\r\n     * Create a path element from path data string\r\n     * @param {string} pathData\r\n     * @param {Object} opts\r\n     * @param {module:zrender/core/BoundingRect} rect\r\n     * @param {string} [layout=cover] 'center' or 'cover'\r\n     */\r\n    graphic.makePath = function (pathData, opts, rect, layout) {\r\n        var path = pathTool.createFromString(pathData, opts);\r\n        Draggable.call(path);\r\n        var boundingRect = path.getBoundingRect();\r\n        if (rect) {\r\n            var aspect = boundingRect.width / boundingRect.height;\r\n\r\n            if (layout === 'center') {\r\n                // Set rect to center, keep width / height ratio.\r\n                var width = rect.height * aspect;\r\n                var height;\r\n                if (width <= rect.width) {\r\n                    height = rect.height;\r\n                }\r\n                else {\r\n                    width = rect.width;\r\n                    height = width / aspect;\r\n                }\r\n                var cx = rect.x + rect.width / 2;\r\n                var cy = rect.y + rect.height / 2;\r\n\r\n                rect.x = cx - width / 2;\r\n                rect.y = cy - height / 2;\r\n                rect.width = width;\r\n                rect.height = height;\r\n            }\r\n\r\n            this.resizePath(path, rect);\r\n        }\r\n\r\n        zrUtil.inherits(path, Draggable);\r\n        return path;\r\n    };\r\n\r\n    graphic.mergePath = pathTool.mergePath;\r\n\r\n    /**\r\n     * Resize a path to fit the rect\r\n     * @param {module:zrender/graphic/Path} path\r\n     * @param {Object} rect\r\n     */\r\n    graphic.resizePath = function (path, rect) {\r\n        if (!path.applyTransform) {\r\n            return;\r\n        }\r\n\r\n        var pathRect = path.getBoundingRect();\r\n\r\n        var m = pathRect.calculateTransform(rect);\r\n\r\n        path.applyTransform(m);\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize line for canvas\r\n     *\r\n     * @param {Object} param\r\n     * @param {Object} [param.shape]\r\n     * @param {number} [param.shape.x1]\r\n     * @param {number} [param.shape.y1]\r\n     * @param {number} [param.shape.x2]\r\n     * @param {number} [param.shape.y2]\r\n     * @param {Object} [param.style]\r\n     * @param {number} [param.style.lineWidth]\r\n     * @return {Object} Modified param\r\n     */\r\n    graphic.subPixelOptimizeLine = function (param) {\r\n        var subPixelOptimize = graphic.subPixelOptimize;\r\n        var shape = param.shape;\r\n        var lineWidth = param.style.lineWidth;\r\n\r\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\r\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\r\n        }\r\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\r\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\r\n        }\r\n        return param;\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize rect for canvas\r\n     *\r\n     * @param {Object} param\r\n     * @param {Object} [param.shape]\r\n     * @param {number} [param.shape.x]\r\n     * @param {number} [param.shape.y]\r\n     * @param {number} [param.shape.width]\r\n     * @param {number} [param.shape.height]\r\n     * @param {Object} [param.style]\r\n     * @param {number} [param.style.lineWidth]\r\n     * @return {Object} Modified param\r\n     */\r\n    graphic.subPixelOptimizeRect = function (param) {\r\n        var subPixelOptimize = graphic.subPixelOptimize;\r\n        var shape = param.shape;\r\n        var lineWidth = param.style.lineWidth;\r\n        var originX = shape.x;\r\n        var originY = shape.y;\r\n        var originWidth = shape.width;\r\n        var originHeight = shape.height;\r\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\r\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\r\n        shape.width = Math.max(\r\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\r\n            originWidth === 0 ? 0 : 1\r\n        );\r\n        shape.height = Math.max(\r\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\r\n            originHeight === 0 ? 0 : 1\r\n        );\r\n        return param;\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize for canvas\r\n     *\r\n     * @param {number} position Coordinate, such as x, y\r\n     * @param {number} lineWidth Should be nonnegative integer.\r\n     * @param {boolean=} positiveOrNegative Default false (negative).\r\n     * @return {number} Optimized position.\r\n     */\r\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\r\n        // Assure that (position + lineWidth / 2) is near integer edge,\r\n        // otherwise line will be fuzzy in canvas.\r\n        var doubledPosition = round(position * 2);\r\n        return (doubledPosition + round(lineWidth)) % 2 === 0\r\n            ? doubledPosition / 2\r\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    function doSingleEnterHover(el) {\r\n        if (el.__isHover) {\r\n            return;\r\n        }\r\n        if (el.__hoverStlDirty) {\r\n            var stroke = el.style.stroke;\r\n            var fill = el.style.fill;\r\n\r\n            // Create hoverStyle on mouseover\r\n            var hoverStyle = el.__hoverStl;\r\n            var lift = colorTool.lift;\r\n            hoverStyle.fill = hoverStyle.fill\r\n                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));\r\n            hoverStyle.stroke = hoverStyle.stroke\r\n                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));\r\n\r\n            var normalStyle = {};\r\n            for (var name in hoverStyle) {\r\n                if (hoverStyle.hasOwnProperty(name)) {\r\n                    normalStyle[name] = el.style[name];\r\n                }\r\n            }\r\n\r\n            el.__normalStl = normalStyle;\r\n\r\n            el.__hoverStlDirty = false;\r\n        }\r\n        el.setStyle(el.__hoverStl);\r\n        el.z2 += 1;\r\n\r\n        el.__isHover = true;\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function doSingleLeaveHover(el) {\r\n        if (!el.__isHover) {\r\n            return;\r\n        }\r\n\r\n        var normalStl = el.__normalStl;\r\n        normalStl && el.setStyle(normalStl);\r\n        el.z2 -= 1;\r\n\r\n        el.__isHover = false;\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function doEnterHover(el) {\r\n        (el.type === 'group' || el.type === 'GroupNode')\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    doSingleEnterHover(child);\r\n                }\r\n            })\r\n            : doSingleEnterHover(el);\r\n    }\r\n    graphic.doEnterHover = doEnterHover;\r\n    function doLeaveHover(el) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    doSingleLeaveHover(child);\r\n                }\r\n            })\r\n            : doSingleLeaveHover(el);\r\n    }\r\n    graphic.doLeaveHover = doLeaveHover;\r\n    /**\r\n     * @inner\r\n     */\r\n    function setElementHoverStl(el, hoverStl) {\r\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\r\n        // Often used when item group has a label element and it's hoverStyle is different\r\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\r\n        el.__hoverStlDirty = true;\r\n    }\r\n    graphic.setElementHoverStl = setElementHoverStl;\r\n    /**\r\n     * @inner\r\n     */\r\n    function onElementMouseOver() {\r\n        // Only if element is not in emphasis status\r\n        !this.__isEmphasis && doEnterHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function onElementMouseOut() {\r\n        // Only if element is not in emphasis status\r\n        !this.__isEmphasis && doLeaveHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function enterEmphasis() {\r\n        this.__isEmphasis = true;\r\n        doEnterHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function leaveEmphasis() {\r\n        this.__isEmphasis = false;\r\n        doLeaveHover(this);\r\n    }\r\n\r\n    /**\r\n     * Set hover style of element\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} [hoverStyle]\r\n     */\r\n    graphic.setHoverStyle = function (el, hoverStyle) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    setElementHoverStl(child, hoverStyle);\r\n                }\r\n            })\r\n            : setElementHoverStl(el, hoverStyle);\r\n        // Remove previous bound handlers\r\n        el.on('mouseover', onElementMouseOver)\r\n          .on('mouseout', onElementMouseOut);\r\n\r\n        // Emphasis, normal can be triggered manually\r\n        el.on('emphasis', enterEmphasis)\r\n          .on('normal', leaveEmphasis);\r\n    };\r\n\r\n    graphic.setNormalStyle = function(el, options) {\r\n        if (el.__normalStl) {\r\n            for (var name in options) {\r\n                if (el.__normalStl.hasOwnProperty(name)) {\r\n                    el.__normalStl[name] = options[name];\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Set text option in the style\r\n     * @param {Object} textStyle\r\n     * @param {module:echarts/model/Model} labelModel\r\n     * @param {string} color\r\n     */\r\n    graphic.setText = function (textStyle, labelModel, color) {\r\n        var labelPosition = labelModel.getShallow('position') || 'inside';\r\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\r\n        var textStyleModel = labelModel.getModel('textStyle');\r\n        zrUtil.extend(textStyle, {\r\n            textDistance: labelModel.getShallow('distance') || 5,\r\n            textFont: textStyleModel.getFont(),\r\n            textPosition: labelPosition,\r\n            textFill: textStyleModel.getTextColor() || labelColor\r\n        });\r\n    };\r\n\r\n    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {\r\n        var postfix = isUpdate ? 'Update' : '';\r\n        var duration = animatableModel\r\n            && animatableModel.getShallow('animationDuration' + postfix);\r\n        var animationEasing = animatableModel\r\n            && animatableModel.getShallow('animationEasing' + postfix);\r\n\r\n        animatableModel && animatableModel.getShallow('animation')\r\n            ? el.animateTo(props, duration, animationEasing, cb)\r\n            : (el.attr(props), cb && cb());\r\n    }\r\n    /**\r\n     * Update graphic element properties with or without animation according to the configuration in series\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} props\r\n     * @param {module:echarts/model/Model} [animatableModel]\r\n     * @param {Function} cb\r\n     */\r\n    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);\r\n\r\n    /**\r\n     * Init graphic element properties with or without animation according to the configuration in series\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} props\r\n     * @param {module:echarts/model/Model} [animatableModel]\r\n     * @param {Function} cb\r\n     */\r\n    graphic.initProps = zrUtil.curry(animateOrSetProps, false);\r\n\r\n    /**\r\n     * Get transform matrix of target (param target),\r\n     * in coordinate of its ancestor (param ancestor)\r\n     *\r\n     * @param {module:zrender/mixin/Transformable} target\r\n     * @param {module:zrender/mixin/Transformable} ancestor\r\n     */\r\n    graphic.getTransform = function (target, ancestor) {\r\n        var mat = matrix.identity([]);\r\n\r\n        while (target && target !== ancestor) {\r\n            matrix.mul(mat, target.getLocalTransform(), mat);\r\n            target = target.parent;\r\n        }\r\n\r\n        return mat;\r\n    };\r\n\r\n    /**\r\n     * Apply transform to an vertex.\r\n     * @param {Array.<number>} vertex [x, y]\r\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n     * @param {boolean=} invert Whether use invert matrix.\r\n     * @return {Array.<number>} [x, y]\r\n     */\r\n    graphic.applyTransform = function (vertex, transform, invert) {\r\n        if (invert) {\r\n            transform = matrix.invert([], transform);\r\n        }\r\n        return vector.applyTransform([], vertex, transform);\r\n    };\r\n\r\n    /**\r\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\r\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n     * @param {boolean=} invert Whether use invert matrix.\r\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\r\n     */\r\n    graphic.transformDirection = function (direction, transform, invert) {\r\n\r\n        // Pick a base, ensure that transform result will not be (0, 0).\r\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\r\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\r\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\r\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\r\n\r\n        var vertex = [\r\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\r\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\r\n        ];\r\n\r\n        vertex = graphic.applyTransform(vertex, transform, invert);\r\n\r\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\r\n            ? (vertex[0] > 0 ? 'right' : 'left')\r\n            : (vertex[1] > 0 ? 'bottom' : 'top');\r\n    };\r\n\r\n    module.exports = graphic;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/graphic.js\n// module id = 4\n// module chunks = 0","/**\n * @module zrender/core/util\n */\n// 用于处理merge时无法遍历Date等对象的问题\nvar BUILTIN_OBJECT = {\n  '[object Function]': 1,\n  '[object RegExp]': 1,\n  '[object Date]': 1,\n  '[object Error]': 1,\n  '[object CanvasGradient]': 1,\n  '[object CanvasPattern]': 1,\n  // For node-canvas\n  '[object Image]': 1,\n  '[object Canvas]': 1\n};\nvar TYPED_ARRAY = {\n  '[object Int8Array]': 1,\n  '[object Uint8Array]': 1,\n  '[object Uint8ClampedArray]': 1,\n  '[object Int16Array]': 1,\n  '[object Uint16Array]': 1,\n  '[object Int32Array]': 1,\n  '[object Uint32Array]': 1,\n  '[object Float32Array]': 1,\n  '[object Float64Array]': 1\n};\nvar objToString = Object.prototype.toString;\nvar arrayProto = Array.prototype;\nvar nativeForEach = arrayProto.forEach;\nvar nativeFilter = arrayProto.filter;\nvar nativeSlice = arrayProto.slice;\nvar nativeMap = arrayProto.map;\nvar nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * Those data types can be cloned:\n *     Plain object, Array, TypedArray, number, string, null, undefined.\n * Those data types will be assgined using the orginal data:\n *     BUILTIN_OBJECT\n * Instance of user defined class will be cloned to a plain object, without\n * properties in prototype.\n * Other data types is not supported (not sure what will happen).\n *\n * Caution: do not support clone Date, for performance consideration.\n * (There might be a large number of date in `series.data`).\n * So date should not be modified in and out of echarts.\n *\n * @param {*} source\n * @return {*} new\n */\n\n\nfunction clone(source) {\n  if (source == null || typeof source != 'object') {\n    return source;\n  }\n\n  var result = source;\n  var typeStr = objToString.call(source);\n\n  if (typeStr === '[object Array]') {\n    result = [];\n\n    for (var i = 0, len = source.length; i < len; i++) {\n      result[i] = clone(source[i]);\n    }\n  } else if (TYPED_ARRAY[typeStr]) {\n    var Ctor = source.constructor;\n\n    if (source.constructor.from) {\n      result = Ctor.from(source);\n    } else {\n      result = new Ctor(source.length);\n\n      for (var i = 0, len = source.length; i < len; i++) {\n        result[i] = clone(source[i]);\n      }\n    }\n  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n    result = {};\n\n    for (var key in source) {\n      if (source.hasOwnProperty(key)) {\n        result[key] = clone(source[key]);\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} target\n * @param {*} source\n * @param {boolean} [overwrite=false]\n */\n\n\nfunction merge(target, source, overwrite) {\n  // We should escapse that source is string\n  // and enter for ... in ...\n  if (!isObject(source) || !isObject(target)) {\n    return overwrite ? clone(source) : target;\n  }\n\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      var targetProp = target[key];\n      var sourceProp = source[key];\n\n      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {\n        // 如果需要递归覆盖，就递归调用merge\n        merge(targetProp, sourceProp, overwrite);\n      } else if (overwrite || !(key in target)) {\n        // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n        // NOTE，在 target[key] 不存在的时候也是直接覆盖\n        target[key] = clone(source[key], true);\n      }\n    }\n  }\n\n  return target;\n}\n/**\n * @param {Array} targetAndSources The first item is target, and the rests are source.\n * @param {boolean} [overwrite=false]\n * @return {*} target\n */\n\n\nfunction mergeAll(targetAndSources, overwrite) {\n  var result = targetAndSources[0];\n\n  for (var i = 1, len = targetAndSources.length; i < len; i++) {\n    result = merge(result, targetAndSources[i], overwrite);\n  }\n\n  return result;\n}\n/**\n * @param {*} target\n * @param {*} source\n * @memberOf module:zrender/core/util\n */\n\n\nfunction extend(target, source) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n/**\n * @param {*} target\n * @param {*} source\n * @param {boolean} [overlay=false]\n * @memberOf module:zrender/core/util\n */\n\n\nfunction defaults(target, source, overlay) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nvar createCanvas = function () {\n  return methods.createCanvas();\n};\n\nmethods.createCanvas = function () {\n  return document.createElement('canvas');\n}; // FIXME\n\n\nvar _ctx;\n\nfunction getContext() {\n  if (!_ctx) {\n    // Use util.createCanvas instead of createCanvas\n    // because createCanvas may be overwritten in different environment\n    _ctx = createCanvas().getContext('2d');\n  }\n\n  return _ctx;\n}\n/**\n * 查询数组中元素的index\n * @memberOf module:zrender/core/util\n */\n\n\nfunction indexOf(array, value) {\n  if (array) {\n    if (array.indexOf) {\n      return array.indexOf(value);\n    }\n\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (array[i] === value) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n}\n/**\n * 构造类继承关系\n *\n * @memberOf module:zrender/core/util\n * @param {Function} clazz 源类\n * @param {Function} baseClazz 基类\n */\n\n\nfunction inherits(clazz, baseClazz) {\n  var clazzPrototype = clazz.prototype;\n\n  function F() {}\n\n  F.prototype = baseClazz.prototype;\n  clazz.prototype = new F();\n\n  for (var prop in clazzPrototype) {\n    clazz.prototype[prop] = clazzPrototype[prop];\n  }\n\n  clazz.prototype.constructor = clazz;\n  clazz.superClass = baseClazz;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Object|Function} target\n * @param {Object|Function} sorce\n * @param {boolean} overlay\n */\n\n\nfunction mixin(target, source, overlay) {\n  target = 'prototype' in target ? target.prototype : target;\n  source = 'prototype' in source ? source.prototype : source;\n  defaults(target, source, overlay);\n}\n/**\n * Consider typed array.\n * @param {Array|TypedArray} data\n */\n\n\nfunction isArrayLike(data) {\n  if (!data) {\n    return;\n  }\n\n  if (typeof data == 'string') {\n    return false;\n  }\n\n  return typeof data.length == 'number';\n}\n/**\n * 数组或对象遍历\n * @memberOf module:zrender/core/util\n * @param {Object|Array} obj\n * @param {Function} cb\n * @param {*} [context]\n */\n\n\nfunction each(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.forEach && obj.forEach === nativeForEach) {\n    obj.forEach(cb, context);\n  } else if (obj.length === +obj.length) {\n    for (var i = 0, len = obj.length; i < len; i++) {\n      cb.call(context, obj[i], i, obj);\n    }\n  } else {\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        cb.call(context, obj[key], key, obj);\n      }\n    }\n  }\n}\n/**\n * 数组映射\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction map(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.map && obj.map === nativeMap) {\n    return obj.map(cb, context);\n  } else {\n    var result = [];\n\n    for (var i = 0, len = obj.length; i < len; i++) {\n      result.push(cb.call(context, obj[i], i, obj));\n    }\n\n    return result;\n  }\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {Object} [memo]\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction reduce(obj, cb, memo, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.reduce && obj.reduce === nativeReduce) {\n    return obj.reduce(cb, memo, context);\n  } else {\n    for (var i = 0, len = obj.length; i < len; i++) {\n      memo = cb.call(context, memo, obj[i], i, obj);\n    }\n\n    return memo;\n  }\n}\n/**\n * 数组过滤\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction filter(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.filter && obj.filter === nativeFilter) {\n    return obj.filter(cb, context);\n  } else {\n    var result = [];\n\n    for (var i = 0, len = obj.length; i < len; i++) {\n      if (cb.call(context, obj[i], i, obj)) {\n        result.push(obj[i]);\n      }\n    }\n\n    return result;\n  }\n}\n/**\n * 数组项查找\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {*}\n */\n\n\nfunction find(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  for (var i = 0, len = obj.length; i < len; i++) {\n    if (cb.call(context, obj[i], i, obj)) {\n      return obj[i];\n    }\n  }\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Function} func\n * @param {*} context\n * @return {Function}\n */\n\n\nfunction bind(func, context) {\n  var args = nativeSlice.call(arguments, 2);\n  return function () {\n    return func.apply(context, args.concat(nativeSlice.call(arguments)));\n  };\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Function} func\n * @return {Function}\n */\n\n\nfunction curry(func) {\n  var args = nativeSlice.call(arguments, 1);\n  return function () {\n    return func.apply(this, args.concat(nativeSlice.call(arguments)));\n  };\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isArray(value) {\n  return objToString.call(value) === '[object Array]';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isString(value) {\n  return objToString.call(value) === '[object String]';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return type === 'function' || !!value && type == 'object';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isBuiltInObject(value) {\n  return !!BUILTIN_OBJECT[objToString.call(value)];\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isDom(value) {\n  return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';\n}\n/**\n * Whether is exactly NaN. Notice isNaN('a') returns true.\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction eqNaN(value) {\n  return value !== value;\n}\n/**\n * If value1 is not null, then return value1, otherwise judget rest of values.\n * Low performance.\n * @memberOf module:zrender/core/util\n * @return {*} Final value\n */\n\n\nfunction retrieve(values) {\n  for (var i = 0, len = arguments.length; i < len; i++) {\n    if (arguments[i] != null) {\n      return arguments[i];\n    }\n  }\n}\n\nfunction retrieve2(value0, value1) {\n  return value0 != null ? value0 : value1;\n}\n\nfunction retrieve3(value0, value1, value2) {\n  return value0 != null ? value0 : value1 != null ? value1 : value2;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Array} arr\n * @param {number} startIndex\n * @param {number} endIndex\n * @return {Array}\n */\n\n\nfunction slice() {\n  return Function.call.apply(nativeSlice, arguments);\n}\n/**\n * Normalize css liked array configuration\n * e.g.\n *  3 => [3, 3, 3, 3]\n *  [4, 2] => [4, 2, 4, 2]\n *  [4, 3, 2] => [4, 3, 2, 3]\n * @param {number|Array.<number>} val\n * @return {Array.<number>}\n */\n\n\nfunction normalizeCssArray(val) {\n  if (typeof val === 'number') {\n    return [val, val, val, val];\n  }\n\n  var len = val.length;\n\n  if (len === 2) {\n    // vertical | horizontal\n    return [val[0], val[1], val[0], val[1]];\n  } else if (len === 3) {\n    // top | horizontal | bottom\n    return [val[0], val[1], val[2], val[1]];\n  }\n\n  return val;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {boolean} condition\n * @param {string} message\n */\n\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nvar primitiveKey = '__ec_primitive__';\n/**\n * Set an object as primitive to be ignored traversing children in clone or merge\n */\n\nfunction setAsPrimitive(obj) {\n  obj[primitiveKey] = true;\n}\n\nfunction isPrimitive(obj) {\n  return obj[primitiveKey];\n}\n/**\n * @constructor\n * @param {Object} obj Only apply `ownProperty`.\n */\n\n\nfunction HashMap(obj) {\n  obj && each(obj, function (value, key) {\n    this.set(key, value);\n  }, this);\n} // Add prefix to avoid conflict with Object.prototype.\n\n\nvar HASH_MAP_PREFIX = '_ec_';\nvar HASH_MAP_PREFIX_LENGTH = 4;\nHashMap.prototype = {\n  constructor: HashMap,\n  // Do not provide `has` method to avoid defining what is `has`.\n  // (We usually treat `null` and `undefined` as the same, different\n  // from ES6 Map).\n  get: function (key) {\n    return this[HASH_MAP_PREFIX + key];\n  },\n  set: function (key, value) {\n    this[HASH_MAP_PREFIX + key] = value; // Comparing with invocation chaining, `return value` is more commonly\n    // used in this case: `var someVal = map.set('a', genVal());`\n\n    return value;\n  },\n  // Although util.each can be performed on this hashMap directly, user\n  // should not use the exposed keys, who are prefixed.\n  each: function (cb, context) {\n    context !== void 0 && (cb = bind(cb, context));\n\n    for (var prefixedKey in this) {\n      this.hasOwnProperty(prefixedKey) && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n    }\n  },\n  // Do not use this method if performance sensitive.\n  removeKey: function (key) {\n    delete this[HASH_MAP_PREFIX + key];\n  }\n};\n\nfunction createHashMap(obj) {\n  return new HashMap(obj);\n}\n\nfunction noop() {}\n\nexports.$override = $override;\nexports.clone = clone;\nexports.merge = merge;\nexports.mergeAll = mergeAll;\nexports.extend = extend;\nexports.defaults = defaults;\nexports.createCanvas = createCanvas;\nexports.getContext = getContext;\nexports.indexOf = indexOf;\nexports.inherits = inherits;\nexports.mixin = mixin;\nexports.isArrayLike = isArrayLike;\nexports.each = each;\nexports.map = map;\nexports.reduce = reduce;\nexports.filter = filter;\nexports.find = find;\nexports.bind = bind;\nexports.curry = curry;\nexports.isArray = isArray;\nexports.isFunction = isFunction;\nexports.isString = isString;\nexports.isObject = isObject;\nexports.isBuiltInObject = isBuiltInObject;\nexports.isDom = isDom;\nexports.eqNaN = eqNaN;\nexports.retrieve = retrieve;\nexports.retrieve2 = retrieve2;\nexports.retrieve3 = retrieve3;\nexports.slice = slice;\nexports.normalizeCssArray = normalizeCssArray;\nexports.assert = assert;\nexports.setAsPrimitive = setAsPrimitive;\nexports.isPrimitive = isPrimitive;\nexports.createHashMap = createHashMap;\nexports.noop = noop;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/util.js\n// module id = 5\n// module chunks = 0","var Path = require(\"../graphic/Path\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar transformPath = require(\"./transformPath\");\n\n// command chars\nvar cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];\nvar mathSqrt = Math.sqrt;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI = Math.PI;\n\nvar vMag = function (v) {\n  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n};\n\nvar vRatio = function (u, v) {\n  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n};\n\nvar vAngle = function (u, v) {\n  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n};\n\nfunction processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n  var psi = psiDeg * (PI / 180.0);\n  var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;\n  var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;\n  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n\n  if (lambda > 1) {\n    rx *= mathSqrt(lambda);\n    ry *= mathSqrt(lambda);\n  }\n\n  var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;\n  var cxp = f * rx * yp / ry;\n  var cyp = f * -ry * xp / rx;\n  var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;\n  var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;\n  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);\n  var u = [(xp - cxp) / rx, (yp - cyp) / ry];\n  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\n  var dTheta = vAngle(u, v);\n\n  if (vRatio(u, v) <= -1) {\n    dTheta = PI;\n  }\n\n  if (vRatio(u, v) >= 1) {\n    dTheta = 0;\n  }\n\n  if (fs === 0 && dTheta > 0) {\n    dTheta = dTheta - 2 * PI;\n  }\n\n  if (fs === 1 && dTheta < 0) {\n    dTheta = dTheta + 2 * PI;\n  }\n\n  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n}\n\nfunction createPathProxyFromString(data) {\n  if (!data) {\n    return [];\n  } // command string\n\n\n  var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');\n  var n; // create pipes so that we can split the data\n\n  for (n = 0; n < cc.length; n++) {\n    cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n  } // create array\n\n\n  var arr = cs.split('|'); // init context point\n\n  var cpx = 0;\n  var cpy = 0;\n  var path = new PathProxy();\n  var CMD = PathProxy.CMD;\n  var prevCmd;\n\n  for (n = 1; n < arr.length; n++) {\n    var str = arr[n];\n    var c = str.charAt(0);\n    var off = 0;\n    var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n    var cmd;\n\n    if (p.length > 0 && p[0] === '') {\n      p.shift();\n    }\n\n    for (var i = 0; i < p.length; i++) {\n      p[i] = parseFloat(p[i]);\n    }\n\n    while (off < p.length && !isNaN(p[off])) {\n      if (isNaN(p[0])) {\n        break;\n      }\n\n      var ctlPtx;\n      var ctlPty;\n      var rx;\n      var ry;\n      var psi;\n      var fa;\n      var fs;\n      var x1 = cpx;\n      var y1 = cpy; // convert l, H, h, V, and v to L\n\n      switch (c) {\n        case 'l':\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'L':\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'm':\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.M;\n          path.addData(cmd, cpx, cpy);\n          c = 'l';\n          break;\n\n        case 'M':\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.M;\n          path.addData(cmd, cpx, cpy);\n          c = 'L';\n          break;\n\n        case 'h':\n          cpx += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'H':\n          cpx = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'v':\n          cpy += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'V':\n          cpy = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'C':\n          cmd = CMD.C;\n          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);\n          cpx = p[off - 2];\n          cpy = p[off - 1];\n          break;\n\n        case 'c':\n          cmd = CMD.C;\n          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);\n          cpx += p[off - 2];\n          cpy += p[off - 1];\n          break;\n\n        case 'S':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.C) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cmd = CMD.C;\n          x1 = p[off++];\n          y1 = p[off++];\n          cpx = p[off++];\n          cpy = p[off++];\n          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n          break;\n\n        case 's':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.C) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cmd = CMD.C;\n          x1 = cpx + p[off++];\n          y1 = cpy + p[off++];\n          cpx += p[off++];\n          cpy += p[off++];\n          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n          break;\n\n        case 'Q':\n          x1 = p[off++];\n          y1 = p[off++];\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, x1, y1, cpx, cpy);\n          break;\n\n        case 'q':\n          x1 = p[off++] + cpx;\n          y1 = p[off++] + cpy;\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, x1, y1, cpx, cpy);\n          break;\n\n        case 'T':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.Q) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n          break;\n\n        case 't':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.Q) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n          break;\n\n        case 'A':\n          rx = p[off++];\n          ry = p[off++];\n          psi = p[off++];\n          fa = p[off++];\n          fs = p[off++];\n          x1 = cpx, y1 = cpy;\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.A;\n          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n          break;\n\n        case 'a':\n          rx = p[off++];\n          ry = p[off++];\n          psi = p[off++];\n          fa = p[off++];\n          fs = p[off++];\n          x1 = cpx, y1 = cpy;\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.A;\n          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n          break;\n      }\n    }\n\n    if (c === 'z' || c === 'Z') {\n      cmd = CMD.Z;\n      path.addData(cmd);\n    }\n\n    prevCmd = cmd;\n  }\n\n  path.toStatic();\n  return path;\n} // TODO Optimize double memory cost problem\n\n\nfunction createPathOptions(str, opts) {\n  var pathProxy = createPathProxyFromString(str);\n  opts = opts || {};\n\n  opts.buildPath = function (path) {\n    if (path.setData) {\n      path.setData(pathProxy.data); // Svg and vml renderer don't have context\n\n      var ctx = path.getContext();\n\n      if (ctx) {\n        path.rebuildPath(ctx);\n      }\n    } else {\n      var ctx = path;\n      pathProxy.rebuildPath(ctx);\n    }\n  };\n\n  opts.applyTransform = function (m) {\n    transformPath(pathProxy, m);\n    this.dirty(true);\n  };\n\n  return opts;\n}\n/**\n * Create a Path object from path string data\n * http://www.w3.org/TR/SVG/paths.html#PathData\n * @param  {Object} opts Other options\n */\n\n\nfunction createFromString(str, opts) {\n  return new Path(createPathOptions(str, opts));\n}\n/**\n * Create a Path class from path string data\n * @param  {string} str\n * @param  {Object} opts Other options\n */\n\n\nfunction extendFromString(str, opts) {\n  return Path.extend(createPathOptions(str, opts));\n}\n/**\n * Merge multiple paths\n */\n// TODO Apply transform\n// TODO stroke dash\n// TODO Optimize double memory cost problem\n\n\nfunction mergePath(pathEls, opts) {\n  var pathList = [];\n  var len = pathEls.length;\n\n  for (var i = 0; i < len; i++) {\n    var pathEl = pathEls[i];\n\n    if (!pathEl.path) {\n      pathEl.createPathProxy();\n    }\n\n    if (pathEl.__dirtyPath) {\n      pathEl.buildPath(pathEl.path, pathEl.shape, true);\n    }\n\n    pathList.push(pathEl.path);\n  }\n\n  var pathBundle = new Path(opts); // Need path proxy.\n\n  pathBundle.createPathProxy();\n\n  pathBundle.buildPath = function (path) {\n    path.appendPath(pathList); // Svg and vml renderer don't have context\n\n    var ctx = path.getContext();\n\n    if (ctx) {\n      path.rebuildPath(ctx);\n    }\n  };\n\n  return pathBundle;\n}\n\nexports.createFromString = createFromString;\nexports.extendFromString = extendFromString;\nexports.mergePath = mergePath;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/path.js\n// module id = 6\n// module chunks = 0","var Displayable = require(\"./Displayable\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar pathContain = require(\"../contain/path\");\n\nvar Pattern = require(\"./Pattern\");\n\nvar getCanvasPattern = Pattern.prototype.getCanvasPattern;\nvar abs = Math.abs;\nvar pathProxyForDraw = new PathProxy(true);\n/**\n * @alias module:zrender/graphic/Path\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\n\nfunction Path(opts) {\n  Displayable.call(this, opts);\n  /**\n   * @type {module:zrender/core/PathProxy}\n   * @readOnly\n   */\n\n  this.path = null;\n}\n\nPath.prototype = {\n  constructor: Path,\n  type: 'path',\n  __dirtyPath: true,\n  strokeContainThreshold: 5,\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var path = this.path || pathProxyForDraw;\n    var hasStroke = style.hasStroke();\n    var hasFill = style.hasFill();\n    var fill = style.fill;\n    var stroke = style.stroke;\n    var hasFillGradient = hasFill && !!fill.colorStops;\n    var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n    var hasFillPattern = hasFill && !!fill.image;\n    var hasStrokePattern = hasStroke && !!stroke.image;\n    style.bind(ctx, this, prevEl);\n    this.setTransform(ctx);\n\n    if (this.__dirty) {\n      var rect; // Update gradient because bounding rect may changed\n\n      if (hasFillGradient) {\n        rect = rect || this.getBoundingRect();\n        this._fillGradient = style.getGradient(ctx, fill, rect);\n      }\n\n      if (hasStrokeGradient) {\n        rect = rect || this.getBoundingRect();\n        this._strokeGradient = style.getGradient(ctx, stroke, rect);\n      }\n    } // Use the gradient or pattern\n\n\n    if (hasFillGradient) {\n      // PENDING If may have affect the state\n      ctx.fillStyle = this._fillGradient;\n    } else if (hasFillPattern) {\n      ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n    }\n\n    if (hasStrokeGradient) {\n      ctx.strokeStyle = this._strokeGradient;\n    } else if (hasStrokePattern) {\n      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n    }\n\n    var lineDash = style.lineDash;\n    var lineDashOffset = style.lineDashOffset;\n    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy\n\n    var scale = this.getGlobalScale();\n    path.setScale(scale[0], scale[1]); // Proxy context\n    // Rebuild path in following 2 cases\n    // 1. Path is dirty\n    // 2. Path needs javascript implemented lineDash stroking.\n    //    In this case, lineDash information will not be saved in PathProxy\n\n    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n      path.beginPath(ctx); // Setting line dash before build path\n\n      if (lineDash && !ctxLineDash) {\n        path.setLineDash(lineDash);\n        path.setLineDashOffset(lineDashOffset);\n      }\n\n      this.buildPath(path, this.shape, false); // Clear path dirty flag\n\n      if (this.path) {\n        this.__dirtyPath = false;\n      }\n    } else {\n      // Replay path building\n      ctx.beginPath();\n      this.path.rebuildPath(ctx);\n    }\n\n    hasFill && path.fill(ctx);\n\n    if (lineDash && ctxLineDash) {\n      ctx.setLineDash(lineDash);\n      ctx.lineDashOffset = lineDashOffset;\n    }\n\n    hasStroke && path.stroke(ctx);\n\n    if (lineDash && ctxLineDash) {\n      // PENDING\n      // Remove lineDash\n      ctx.setLineDash([]);\n    }\n\n    this.restoreTransform(ctx); // Draw rect text\n\n    if (style.text != null) {\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n  // Like in circle\n  buildPath: function (ctx, shapeCfg, inBundle) {},\n  createPathProxy: function () {\n    this.path = new PathProxy();\n  },\n  getBoundingRect: function () {\n    var rect = this._rect;\n    var style = this.style;\n    var needsUpdateRect = !rect;\n\n    if (needsUpdateRect) {\n      var path = this.path;\n\n      if (!path) {\n        // Create path on demand.\n        path = this.path = new PathProxy();\n      }\n\n      if (this.__dirtyPath) {\n        path.beginPath();\n        this.buildPath(path, this.shape, false);\n      }\n\n      rect = path.getBoundingRect();\n    }\n\n    this._rect = rect;\n\n    if (style.hasStroke()) {\n      // Needs update rect with stroke lineWidth when\n      // 1. Element changes scale or lineWidth\n      // 2. Shape is changed\n      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\n      if (this.__dirty || needsUpdateRect) {\n        rectWithStroke.copy(rect); // FIXME Must after updateTransform\n\n        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical\n\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill\n\n        if (!style.hasFill()) {\n          w = Math.max(w, this.strokeContainThreshold || 4);\n        } // Consider line width\n        // Line scale can't be 0;\n\n\n        if (lineScale > 1e-10) {\n          rectWithStroke.width += w / lineScale;\n          rectWithStroke.height += w / lineScale;\n          rectWithStroke.x -= w / lineScale / 2;\n          rectWithStroke.y -= w / lineScale / 2;\n        }\n      } // Return rect with stroke\n\n\n      return rectWithStroke;\n    }\n\n    return rect;\n  },\n  contain: function (x, y) {\n    var localPos = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    var style = this.style;\n    x = localPos[0];\n    y = localPos[1];\n\n    if (rect.contain(x, y)) {\n      var pathData = this.path.data;\n\n      if (style.hasStroke()) {\n        var lineWidth = style.lineWidth;\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;\n\n        if (lineScale > 1e-10) {\n          // Only add extra hover lineWidth when there are no fill\n          if (!style.hasFill()) {\n            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n          }\n\n          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n            return true;\n          }\n        }\n      }\n\n      if (style.hasFill()) {\n        return pathContain.contain(pathData, x, y);\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * @param  {boolean} dirtyPath\n   */\n  dirty: function (dirtyPath) {\n    if (dirtyPath == null) {\n      dirtyPath = true;\n    } // Only mark dirty, not mark clean\n\n\n    if (dirtyPath) {\n      this.__dirtyPath = dirtyPath;\n      this._rect = null;\n    }\n\n    this.__dirty = true;\n    this.__zr && this.__zr.refresh(); // Used as a clipping path\n\n    if (this.__clipTarget) {\n      this.__clipTarget.dirty();\n    }\n  },\n\n  /**\n   * Alias for animate('shape')\n   * @param {boolean} loop\n   */\n  animateShape: function (loop) {\n    return this.animate('shape', loop);\n  },\n  // Overwrite attrKV\n  attrKV: function (key, value) {\n    // FIXME\n    if (key === 'shape') {\n      this.setShape(value);\n      this.__dirtyPath = true;\n      this._rect = null;\n    } else {\n      Displayable.prototype.attrKV.call(this, key, value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setShape: function (key, value) {\n    var shape = this.shape; // Path from string may not have shape\n\n    if (shape) {\n      if (zrUtil.isObject(key)) {\n        for (var name in key) {\n          if (key.hasOwnProperty(name)) {\n            shape[name] = key[name];\n          }\n        }\n      } else {\n        shape[key] = value;\n      }\n\n      this.dirty(true);\n    }\n\n    return this;\n  },\n  getLineScale: function () {\n    var m = this.transform; // Get the line scale.\n    // Determinant of `m` means how much the area is enlarged by the\n    // transformation. So its square root can be used as a scale factor\n    // for width.\n\n    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n  }\n};\n/**\n * 扩展一个 Path element, 比如星形，圆等。\n * Extend a path element\n * @param {Object} props\n * @param {string} props.type Path type\n * @param {Function} props.init Initialize\n * @param {Function} props.buildPath Overwrite buildPath method\n * @param {Object} [props.style] Extended default style config\n * @param {Object} [props.shape] Extended default shape config\n */\n\nPath.extend = function (defaults) {\n  var Sub = function (opts) {\n    Path.call(this, opts);\n\n    if (defaults.style) {\n      // Extend default style\n      this.style.extendFrom(defaults.style, false);\n    } // Extend default shape\n\n\n    var defaultShape = defaults.shape;\n\n    if (defaultShape) {\n      this.shape = this.shape || {};\n      var thisShape = this.shape;\n\n      for (var name in defaultShape) {\n        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n          thisShape[name] = defaultShape[name];\n        }\n      }\n    }\n\n    defaults.init && defaults.init.call(this, opts);\n  };\n\n  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象\n\n  for (var name in defaults) {\n    // Extending prototype values and methods\n    if (name !== 'style' && name !== 'shape') {\n      Sub.prototype[name] = defaults[name];\n    }\n  }\n\n  return Sub;\n};\n\nzrUtil.inherits(Path, Displayable);\nvar _default = Path;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Path.js\n// module id = 7\n// module chunks = 0","var zrUtil = require(\"../core/util\");\n\nvar Style = require(\"./Style\");\n\nvar Element = require(\"../Element\");\n\nvar RectText = require(\"./mixin/RectText\");\n\n/**\n * 可绘制的图形基类\n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n/**\n * @alias module:zrender/graphic/Displayable\n * @extends module:zrender/Element\n * @extends module:zrender/graphic/mixin/RectText\n */\nfunction Displayable(opts) {\n  opts = opts || {};\n  Element.call(this, opts); // Extend properties\n\n  for (var name in opts) {\n    if (opts.hasOwnProperty(name) && name !== 'style') {\n      this[name] = opts[name];\n    }\n  }\n  /**\n   * @type {module:zrender/graphic/Style}\n   */\n\n\n  this.style = new Style(opts.style, this);\n  this._rect = null; // Shapes for cascade clipping.\n\n  this.__clipPaths = []; // FIXME Stateful must be mixined after style is setted\n  // Stateful.call(this, opts);\n}\n\nDisplayable.prototype = {\n  constructor: Displayable,\n  type: 'displayable',\n\n  /**\n   * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制\n   * Dirty flag. From which painter will determine if this displayable object needs brush\n   * @name module:zrender/graphic/Displayable#__dirty\n   * @type {boolean}\n   */\n  __dirty: true,\n\n  /**\n   * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\n   * If ignore drawing of the displayable object. Mouse event will still be triggered\n   * @name module:/zrender/graphic/Displayable#invisible\n   * @type {boolean}\n   * @default false\n   */\n  invisible: false,\n\n  /**\n   * @name module:/zrender/graphic/Displayable#z\n   * @type {number}\n   * @default 0\n   */\n  z: 0,\n\n  /**\n   * @name module:/zrender/graphic/Displayable#z\n   * @type {number}\n   * @default 0\n   */\n  z2: 0,\n\n  /**\n   * z层level，决定绘画在哪层canvas中\n   * @name module:/zrender/graphic/Displayable#zlevel\n   * @type {number}\n   * @default 0\n   */\n  zlevel: 0,\n\n  /**\n   * 是否可拖拽\n   * @name module:/zrender/graphic/Displayable#draggable\n   * @type {boolean}\n   * @default false\n   */\n  draggable: false,\n\n  /**\n   * 是否正在拖拽\n   * @name module:/zrender/graphic/Displayable#draggable\n   * @type {boolean}\n   * @default false\n   */\n  dragging: false,\n\n  /**\n   * 是否相应鼠标事件\n   * @name module:/zrender/graphic/Displayable#silent\n   * @type {boolean}\n   * @default false\n   */\n  silent: false,\n\n  /**\n   * If enable culling\n   * @type {boolean}\n   * @default false\n   */\n  culling: false,\n\n  /**\n   * Mouse cursor when hovered\n   * @name module:/zrender/graphic/Displayable#cursor\n   * @type {string}\n   */\n  cursor: 'pointer',\n\n  /**\n   * If hover area is bounding rect\n   * @name module:/zrender/graphic/Displayable#rectHover\n   * @type {string}\n   */\n  rectHover: false,\n\n  /**\n   * Render the element progressively when the value >= 0,\n   * usefull for large data.\n   * @type {number}\n   */\n  progressive: -1,\n  beforeBrush: function (ctx) {},\n  afterBrush: function (ctx) {},\n\n  /**\n   * 图形绘制方法\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  // Interface\n  brush: function (ctx, prevEl) {},\n\n  /**\n   * 获取最小包围盒\n   * @return {module:zrender/core/BoundingRect}\n   */\n  // Interface\n  getBoundingRect: function () {},\n\n  /**\n   * 判断坐标 x, y 是否在图形上\n   * If displayable element contain coord x, y\n   * @param  {number} x\n   * @param  {number} y\n   * @return {boolean}\n   */\n  contain: function (x, y) {\n    return this.rectContain(x, y);\n  },\n\n  /**\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {\n    cb.call(context, this);\n  },\n\n  /**\n   * 判断坐标 x, y 是否在图形的包围盒上\n   * If bounding rect of element contain coord x, y\n   * @param  {number} x\n   * @param  {number} y\n   * @return {boolean}\n   */\n  rectContain: function (x, y) {\n    var coord = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    return rect.contain(coord[0], coord[1]);\n  },\n\n  /**\n   * 标记图形元素为脏，并且在下一帧重绘\n   * Mark displayable element dirty and refresh next frame\n   */\n  dirty: function () {\n    this.__dirty = true;\n    this._rect = null;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * 图形是否会触发事件\n   * If displayable object binded any event\n   * @return {boolean}\n   */\n  // TODO, 通过 bind 绑定的事件\n  // isSilent: function () {\n  //     return !(\n  //         this.hoverable || this.draggable\n  //         || this.onmousemove || this.onmouseover || this.onmouseout\n  //         || this.onmousedown || this.onmouseup || this.onclick\n  //         || this.ondragenter || this.ondragover || this.ondragleave\n  //         || this.ondrop\n  //     );\n  // },\n\n  /**\n   * Alias for animate('style')\n   * @param {boolean} loop\n   */\n  animateStyle: function (loop) {\n    return this.animate('style', loop);\n  },\n  attrKV: function (key, value) {\n    if (key !== 'style') {\n      Element.prototype.attrKV.call(this, key, value);\n    } else {\n      this.style.set(value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setStyle: function (key, value) {\n    this.style.set(key, value);\n    this.dirty(false);\n    return this;\n  },\n\n  /**\n   * Use given style object\n   * @param  {Object} obj\n   */\n  useStyle: function (obj) {\n    this.style = new Style(obj, this);\n    this.dirty(false);\n    return this;\n  }\n};\nzrUtil.inherits(Displayable, Element);\nzrUtil.mixin(Displayable, RectText); // zrUtil.mixin(Displayable, Stateful);\n\nvar _default = Displayable;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Displayable.js\n// module id = 8\n// module chunks = 0","var STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\nvar Style = function (opts, host) {\n  this.extendFrom(opts, false);\n  this.host = host;\n};\n\nfunction createLinearGradient(ctx, obj, rect) {\n  var x = obj.x == null ? 0 : obj.x;\n  var x2 = obj.x2 == null ? 1 : obj.x2;\n  var y = obj.y == null ? 0 : obj.y;\n  var y2 = obj.y2 == null ? 0 : obj.y2;\n\n  if (!obj.global) {\n    x = x * rect.width + rect.x;\n    x2 = x2 * rect.width + rect.x;\n    y = y * rect.height + rect.y;\n    y2 = y2 * rect.height + rect.y;\n  }\n\n  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n  return canvasGradient;\n}\n\nfunction createRadialGradient(ctx, obj, rect) {\n  var width = rect.width;\n  var height = rect.height;\n  var min = Math.min(width, height);\n  var x = obj.x == null ? 0.5 : obj.x;\n  var y = obj.y == null ? 0.5 : obj.y;\n  var r = obj.r == null ? 0.5 : obj.r;\n\n  if (!obj.global) {\n    x = x * width + rect.x;\n    y = y * height + rect.y;\n    r = r * min;\n  }\n\n  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n  return canvasGradient;\n}\n\nStyle.prototype = {\n  constructor: Style,\n\n  /**\n   * @type {module:zrender/graphic/Displayable}\n   */\n  host: null,\n\n  /**\n   * @type {string}\n   */\n  fill: '#000',\n\n  /**\n   * @type {string}\n   */\n  stroke: null,\n\n  /**\n   * @type {number}\n   */\n  opacity: 1,\n\n  /**\n   * @type {Array.<number>}\n   */\n  lineDash: null,\n\n  /**\n   * @type {number}\n   */\n  lineDashOffset: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowOffsetY: 0,\n\n  /**\n   * @type {number}\n   */\n  lineWidth: 1,\n\n  /**\n   * If stroke ignore scale\n   * @type {Boolean}\n   */\n  strokeNoScale: false,\n  // Bounding rect text configuration\n  // Not affected by element transform\n\n  /**\n   * @type {string}\n   */\n  text: null,\n\n  /**\n   * If `fontSize` or `fontFamily` exists, `font` will be reset by\n   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.\n   * So do not visit it directly in upper application (like echarts),\n   * but use `contain/text#makeFont` instead.\n   * @type {string}\n   */\n  font: null,\n\n  /**\n   * The same as font. Use font please.\n   * @deprecated\n   * @type {string}\n   */\n  textFont: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontStyle: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontWeight: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * Should be 12 but not '12px'.\n   * @type {number}\n   */\n  fontSize: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontFamily: null,\n\n  /**\n   * Reserved for special functinality, like 'hr'.\n   * @type {string}\n   */\n  textTag: null,\n\n  /**\n   * @type {string}\n   */\n  textFill: '#000',\n\n  /**\n   * @type {string}\n   */\n  textStroke: null,\n\n  /**\n   * @type {number}\n   */\n  textWidth: null,\n\n  /**\n   * Only for textBackground.\n   * @type {number}\n   */\n  textHeight: null,\n\n  /**\n   * textStroke may be set as some color as a default\n   * value in upper applicaion, where the default value\n   * of textStrokeWidth should be 0 to make sure that\n   * user can choose to do not use text stroke.\n   * @type {number}\n   */\n  textStrokeWidth: 0,\n\n  /**\n   * @type {number}\n   */\n  textLineHeight: null,\n\n  /**\n   * 'inside', 'left', 'right', 'top', 'bottom'\n   * [x, y]\n   * Based on x, y of rect.\n   * @type {string|Array.<number>}\n   * @default 'inside'\n   */\n  textPosition: 'inside',\n\n  /**\n   * If not specified, use the boundingRect of a `displayable`.\n   * @type {Object}\n   */\n  textRect: null,\n\n  /**\n   * [x, y]\n   * @type {Array.<number>}\n   */\n  textOffset: null,\n\n  /**\n   * @type {string}\n   */\n  textAlign: null,\n\n  /**\n   * @type {string}\n   */\n  textVerticalAlign: null,\n\n  /**\n   * @type {number}\n   */\n  textDistance: 5,\n\n  /**\n   * @type {string}\n   */\n  textShadowColor: 'transparent',\n\n  /**\n   * @type {number}\n   */\n  textShadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  textShadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  textShadowOffsetY: 0,\n\n  /**\n   * @type {string}\n   */\n  textBoxShadowColor: 'transparent',\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowOffsetY: 0,\n\n  /**\n   * Whether transform text.\n   * Only useful in Path and Image element\n   * @type {boolean}\n   */\n  transformText: false,\n\n  /**\n   * Text rotate around position of Path or Image\n   * Only useful in Path and Image element and transformText is false.\n   */\n  textRotation: 0,\n\n  /**\n   * Text origin of text rotation, like [10, 40].\n   * Based on x, y of rect.\n   * Useful in label rotation of circular symbol.\n   * By default, this origin is textPosition.\n   * Can be 'center'.\n   * @type {string|Array.<number>}\n   */\n  textOrigin: null,\n\n  /**\n   * @type {string}\n   */\n  textBackgroundColor: null,\n\n  /**\n   * @type {string}\n   */\n  textBorderColor: null,\n\n  /**\n   * @type {number}\n   */\n  textBorderWidth: 0,\n\n  /**\n   * @type {number}\n   */\n  textBorderRadius: 0,\n\n  /**\n   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`\n   * @type {number|Array.<number>}\n   */\n  textPadding: null,\n\n  /**\n   * Text styles for rich text.\n   * @type {Object}\n   */\n  rich: null,\n\n  /**\n   * {outerWidth, outerHeight, ellipsis, placeholder}\n   * @type {Object}\n   */\n  truncate: null,\n\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n   * @type {string}\n   */\n  blend: null,\n\n  /**\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  bind: function (ctx, el, prevEl) {\n    var style = this;\n    var prevStyle = prevEl && prevEl.style;\n    var firstDraw = !prevStyle;\n\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n      var prop = STYLE_COMMON_PROPS[i];\n      var styleName = prop[0];\n\n      if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n        // FIXME Invalid property value will cause style leak from previous element.\n        ctx[styleName] = style[styleName] || prop[1];\n      }\n    }\n\n    if (firstDraw || style.fill !== prevStyle.fill) {\n      ctx.fillStyle = style.fill;\n    }\n\n    if (firstDraw || style.stroke !== prevStyle.stroke) {\n      ctx.strokeStyle = style.stroke;\n    }\n\n    if (firstDraw || style.opacity !== prevStyle.opacity) {\n      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n    }\n\n    if (firstDraw || style.blend !== prevStyle.blend) {\n      ctx.globalCompositeOperation = style.blend || 'source-over';\n    }\n\n    if (this.hasStroke()) {\n      var lineWidth = style.lineWidth;\n      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);\n    }\n  },\n  hasFill: function () {\n    var fill = this.fill;\n    return fill != null && fill !== 'none';\n  },\n  hasStroke: function () {\n    var stroke = this.stroke;\n    return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n  },\n\n  /**\n   * Extend from other style\n   * @param {zrender/graphic/Style} otherStyle\n   * @param {boolean} overwrite true: overwrirte any way.\n   *                            false: overwrite only when !target.hasOwnProperty\n   *                            others: overwrite when property is not null/undefined.\n   */\n  extendFrom: function (otherStyle, overwrite) {\n    if (otherStyle) {\n      for (var name in otherStyle) {\n        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {\n          this[name] = otherStyle[name];\n        }\n      }\n    }\n  },\n\n  /**\n   * Batch setting style with a given object\n   * @param {Object|string} obj\n   * @param {*} [obj]\n   */\n  set: function (obj, value) {\n    if (typeof obj === 'string') {\n      this[obj] = value;\n    } else {\n      this.extendFrom(obj, true);\n    }\n  },\n\n  /**\n   * Clone\n   * @return {zrender/graphic/Style} [description]\n   */\n  clone: function () {\n    var newStyle = new this.constructor();\n    newStyle.extendFrom(this, true);\n    return newStyle;\n  },\n  getGradient: function (ctx, obj, rect) {\n    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n    var canvasGradient = method(ctx, obj, rect);\n    var colorStops = obj.colorStops;\n\n    for (var i = 0; i < colorStops.length; i++) {\n      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n    }\n\n    return canvasGradient;\n  }\n};\nvar styleProto = Style.prototype;\n\nfor (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n  var prop = STYLE_COMMON_PROPS[i];\n\n  if (!(prop[0] in styleProto)) {\n    styleProto[prop[0]] = prop[1];\n  }\n} // Provide for others\n\n\nStyle.getGradient = styleProto.getGradient;\nvar _default = Style;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Style.js\n// module id = 9\n// module chunks = 0","var guid = require(\"./core/guid\");\n\nvar Eventful = require(\"./mixin/Eventful\");\n\nvar Transformable = require(\"./mixin/Transformable\");\n\nvar Animatable = require(\"./mixin/Animatable\");\n\nvar zrUtil = require(\"./core/util\");\n\n/**\n * @alias module:zrender/Element\n * @constructor\n * @extends {module:zrender/mixin/Animatable}\n * @extends {module:zrender/mixin/Transformable}\n * @extends {module:zrender/mixin/Eventful}\n */\nvar Element = function (opts) {\n  // jshint ignore:line\n  Transformable.call(this, opts);\n  Eventful.call(this, opts);\n  Animatable.call(this, opts);\n  /**\n   * 画布元素ID\n   * @type {string}\n   */\n\n  this.id = opts.id || guid();\n};\n\nElement.prototype = {\n  /**\n   * 元素类型\n   * Element type\n   * @type {string}\n   */\n  type: 'element',\n\n  /**\n   * 元素名字\n   * Element name\n   * @type {string}\n   */\n  name: '',\n\n  /**\n   * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n   * ZRender instance will be assigned when element is associated with zrender\n   * @name module:/zrender/Element#__zr\n   * @type {module:zrender/ZRender}\n   */\n  __zr: null,\n\n  /**\n   * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n   * If ignore drawing and events of the element object\n   * @name module:/zrender/Element#ignore\n   * @type {boolean}\n   * @default false\n   */\n  ignore: false,\n\n  /**\n   * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n   * 该路径会继承被裁减对象的变换\n   * @type {module:zrender/graphic/Path}\n   * @see http://www.w3.org/TR/2dcontext/#clipping-region\n   * @readOnly\n   */\n  clipPath: null,\n\n  /**\n   * Drift element\n   * @param  {number} dx dx on the global space\n   * @param  {number} dy dy on the global space\n   */\n  drift: function (dx, dy) {\n    switch (this.draggable) {\n      case 'horizontal':\n        dy = 0;\n        break;\n\n      case 'vertical':\n        dx = 0;\n        break;\n    }\n\n    var m = this.transform;\n\n    if (!m) {\n      m = this.transform = [1, 0, 0, 1, 0, 0];\n    }\n\n    m[4] += dx;\n    m[5] += dy;\n    this.decomposeTransform();\n    this.dirty(false);\n  },\n\n  /**\n   * Hook before update\n   */\n  beforeUpdate: function () {},\n\n  /**\n   * Hook after update\n   */\n  afterUpdate: function () {},\n\n  /**\n   * Update each frame\n   */\n  update: function () {\n    this.updateTransform();\n  },\n\n  /**\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {},\n\n  /**\n   * @protected\n   */\n  attrKV: function (key, value) {\n    if (key === 'position' || key === 'scale' || key === 'origin') {\n      // Copy the array\n      if (value) {\n        var target = this[key];\n\n        if (!target) {\n          target = this[key] = [];\n        }\n\n        target[0] = value[0];\n        target[1] = value[1];\n      }\n    } else {\n      this[key] = value;\n    }\n  },\n\n  /**\n   * Hide the element\n   */\n  hide: function () {\n    this.ignore = true;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * Show the element\n   */\n  show: function () {\n    this.ignore = false;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * @param {string|Object} key\n   * @param {*} value\n   */\n  attr: function (key, value) {\n    if (typeof key === 'string') {\n      this.attrKV(key, value);\n    } else if (zrUtil.isObject(key)) {\n      for (var name in key) {\n        if (key.hasOwnProperty(name)) {\n          this.attrKV(name, key[name]);\n        }\n      }\n    }\n\n    this.dirty(false);\n    return this;\n  },\n\n  /**\n   * @param {module:zrender/graphic/Path} clipPath\n   */\n  setClipPath: function (clipPath) {\n    var zr = this.__zr;\n\n    if (zr) {\n      clipPath.addSelfToZr(zr);\n    } // Remove previous clip path\n\n\n    if (this.clipPath && this.clipPath !== clipPath) {\n      this.removeClipPath();\n    }\n\n    this.clipPath = clipPath;\n    clipPath.__zr = zr;\n    clipPath.__clipTarget = this;\n    this.dirty(false);\n  },\n\n  /**\n   */\n  removeClipPath: function () {\n    var clipPath = this.clipPath;\n\n    if (clipPath) {\n      if (clipPath.__zr) {\n        clipPath.removeSelfFromZr(clipPath.__zr);\n      }\n\n      clipPath.__zr = null;\n      clipPath.__clipTarget = null;\n      this.clipPath = null;\n      this.dirty(false);\n    }\n  },\n\n  /**\n   * Add self from zrender instance.\n   * Not recursively because it will be invoked when element added to storage.\n   * @param {module:zrender/ZRender} zr\n   */\n  addSelfToZr: function (zr) {\n    this.__zr = zr; // 添加动画\n\n    var animators = this.animators;\n\n    if (animators) {\n      for (var i = 0; i < animators.length; i++) {\n        zr.animation.addAnimator(animators[i]);\n      }\n    }\n\n    if (this.clipPath) {\n      this.clipPath.addSelfToZr(zr);\n    }\n  },\n\n  /**\n   * Remove self from zrender instance.\n   * Not recursively because it will be invoked when element added to storage.\n   * @param {module:zrender/ZRender} zr\n   */\n  removeSelfFromZr: function (zr) {\n    this.__zr = null; // 移除动画\n\n    var animators = this.animators;\n\n    if (animators) {\n      for (var i = 0; i < animators.length; i++) {\n        zr.animation.removeAnimator(animators[i]);\n      }\n    }\n\n    if (this.clipPath) {\n      this.clipPath.removeSelfFromZr(zr);\n    }\n  }\n};\nzrUtil.mixin(Element, Animatable);\nzrUtil.mixin(Element, Transformable);\nzrUtil.mixin(Element, Eventful);\nvar _default = Element;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Element.js\n// module id = 10\n// module chunks = 0","/**\n * zrender: 生成唯一id\n *\n * @author errorrik (errorrik@gmail.com)\n */\nvar idStart = 0x0907;\n\nfunction _default() {\n  return idStart++;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/guid.js\n// module id = 11\n// module chunks = 0","/**\n * 事件扩展\n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\nvar arrySlice = Array.prototype.slice;\n/**\n * 事件分发器\n * @alias module:zrender/mixin/Eventful\n * @constructor\n */\n\nvar Eventful = function () {\n  this._$handlers = {};\n};\n\nEventful.prototype = {\n  constructor: Eventful,\n\n  /**\n   * 单次触发绑定，trigger后销毁\n   *\n   * @param {string} event 事件名\n   * @param {Function} handler 响应函数\n   * @param {Object} context\n   */\n  one: function (event, handler, context) {\n    var _h = this._$handlers;\n\n    if (!handler || !event) {\n      return this;\n    }\n\n    if (!_h[event]) {\n      _h[event] = [];\n    }\n\n    for (var i = 0; i < _h[event].length; i++) {\n      if (_h[event][i].h === handler) {\n        return this;\n      }\n    }\n\n    _h[event].push({\n      h: handler,\n      one: true,\n      ctx: context || this\n    });\n\n    return this;\n  },\n\n  /**\n   * 绑定事件\n   * @param {string} event 事件名\n   * @param {Function} handler 事件处理函数\n   * @param {Object} [context]\n   */\n  on: function (event, handler, context) {\n    var _h = this._$handlers;\n\n    if (!handler || !event) {\n      return this;\n    }\n\n    if (!_h[event]) {\n      _h[event] = [];\n    }\n\n    for (var i = 0; i < _h[event].length; i++) {\n      if (_h[event][i].h === handler) {\n        return this;\n      }\n    }\n\n    _h[event].push({\n      h: handler,\n      one: false,\n      ctx: context || this\n    });\n\n    return this;\n  },\n\n  /**\n   * 是否绑定了事件\n   * @param  {string}  event\n   * @return {boolean}\n   */\n  isSilent: function (event) {\n    var _h = this._$handlers;\n    return _h[event] && _h[event].length;\n  },\n\n  /**\n   * 解绑事件\n   * @param {string} event 事件名\n   * @param {Function} [handler] 事件处理函数\n   */\n  off: function (event, handler) {\n    var _h = this._$handlers;\n\n    if (!event) {\n      this._$handlers = {};\n      return this;\n    }\n\n    if (handler) {\n      if (_h[event]) {\n        var newList = [];\n\n        for (var i = 0, l = _h[event].length; i < l; i++) {\n          if (_h[event][i]['h'] != handler) {\n            newList.push(_h[event][i]);\n          }\n        }\n\n        _h[event] = newList;\n      }\n\n      if (_h[event] && _h[event].length === 0) {\n        delete _h[event];\n      }\n    } else {\n      delete _h[event];\n    }\n\n    return this;\n  },\n\n  /**\n   * 事件分发\n   *\n   * @param {string} type 事件类型\n   */\n  trigger: function (type) {\n    if (this._$handlers[type]) {\n      var args = arguments;\n      var argLen = args.length;\n\n      if (argLen > 3) {\n        args = arrySlice.call(args, 1);\n      }\n\n      var _h = this._$handlers[type];\n      var len = _h.length;\n\n      for (var i = 0; i < len;) {\n        // Optimize advise from backbone\n        switch (argLen) {\n          case 1:\n            _h[i]['h'].call(_h[i]['ctx']);\n\n            break;\n\n          case 2:\n            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\n            break;\n\n          case 3:\n            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\n            break;\n\n          default:\n            // have more than 2 given arguments\n            _h[i]['h'].apply(_h[i]['ctx'], args);\n\n            break;\n        }\n\n        if (_h[i]['one']) {\n          _h.splice(i, 1);\n\n          len--;\n        } else {\n          i++;\n        }\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * 带有context的事件分发, 最后一个参数是事件回调的context\n   * @param {string} type 事件类型\n   */\n  triggerWithContext: function (type) {\n    if (this._$handlers[type]) {\n      var args = arguments;\n      var argLen = args.length;\n\n      if (argLen > 4) {\n        args = arrySlice.call(args, 1, args.length - 1);\n      }\n\n      var ctx = args[args.length - 1];\n      var _h = this._$handlers[type];\n      var len = _h.length;\n\n      for (var i = 0; i < len;) {\n        // Optimize advise from backbone\n        switch (argLen) {\n          case 1:\n            _h[i]['h'].call(ctx);\n\n            break;\n\n          case 2:\n            _h[i]['h'].call(ctx, args[1]);\n\n            break;\n\n          case 3:\n            _h[i]['h'].call(ctx, args[1], args[2]);\n\n            break;\n\n          default:\n            // have more than 2 given arguments\n            _h[i]['h'].apply(ctx, args);\n\n            break;\n        }\n\n        if (_h[i]['one']) {\n          _h.splice(i, 1);\n\n          len--;\n        } else {\n          i++;\n        }\n      }\n    }\n\n    return this;\n  }\n}; // 对象可以通过 onxxxx 绑定事件\n\n/**\n * @event module:zrender/mixin/Eventful#onclick\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseover\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseout\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousemove\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousewheel\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousedown\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseup\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondrag\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragstart\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragend\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragenter\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragleave\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragover\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondrop\n * @type {Function}\n * @default null\n */\n\nvar _default = Eventful;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Eventful.js\n// module id = 12\n// module chunks = 0","var matrix = require(\"../core/matrix\");\n\nvar vector = require(\"../core/vector\");\n\n/**\n * 提供变换扩展\n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\nvar mIdentity = matrix.identity;\nvar EPSILON = 5e-5;\n\nfunction isNotAroundZero(val) {\n  return val > EPSILON || val < -EPSILON;\n}\n/**\n * @alias module:zrender/mixin/Transformable\n * @constructor\n */\n\n\nvar Transformable = function (opts) {\n  opts = opts || {}; // If there are no given position, rotation, scale\n\n  if (!opts.position) {\n    /**\n     * 平移\n     * @type {Array.<number>}\n     * @default [0, 0]\n     */\n    this.position = [0, 0];\n  }\n\n  if (opts.rotation == null) {\n    /**\n     * 旋转\n     * @type {Array.<number>}\n     * @default 0\n     */\n    this.rotation = 0;\n  }\n\n  if (!opts.scale) {\n    /**\n     * 缩放\n     * @type {Array.<number>}\n     * @default [1, 1]\n     */\n    this.scale = [1, 1];\n  }\n  /**\n   * 旋转和缩放的原点\n   * @type {Array.<number>}\n   * @default null\n   */\n\n\n  this.origin = this.origin || null;\n};\n\nvar transformableProto = Transformable.prototype;\ntransformableProto.transform = null;\n/**\n * 判断是否需要有坐标变换\n * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n */\n\ntransformableProto.needLocalTransform = function () {\n  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n};\n\ntransformableProto.updateTransform = function () {\n  var parent = this.parent;\n  var parentHasTransform = parent && parent.transform;\n  var needLocalTransform = this.needLocalTransform();\n  var m = this.transform;\n\n  if (!(needLocalTransform || parentHasTransform)) {\n    m && mIdentity(m);\n    return;\n  }\n\n  m = m || matrix.create();\n\n  if (needLocalTransform) {\n    this.getLocalTransform(m);\n  } else {\n    mIdentity(m);\n  } // 应用父节点变换\n\n\n  if (parentHasTransform) {\n    if (needLocalTransform) {\n      matrix.mul(m, parent.transform, m);\n    } else {\n      matrix.copy(m, parent.transform);\n    }\n  } // 保存这个变换矩阵\n\n\n  this.transform = m;\n  this.invTransform = this.invTransform || matrix.create();\n  matrix.invert(this.invTransform, m);\n};\n\ntransformableProto.getLocalTransform = function (m) {\n  return Transformable.getLocalTransform(this, m);\n};\n/**\n * 将自己的transform应用到context上\n * @param {CanvasRenderingContext2D} ctx\n */\n\n\ntransformableProto.setTransform = function (ctx) {\n  var m = this.transform;\n  var dpr = ctx.dpr || 1;\n\n  if (m) {\n    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n  } else {\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n  }\n};\n\ntransformableProto.restoreTransform = function (ctx) {\n  var dpr = ctx.dpr || 1;\n  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n};\n\nvar tmpTransform = [];\n/**\n * 分解`transform`矩阵到`position`, `rotation`, `scale`\n */\n\ntransformableProto.decomposeTransform = function () {\n  if (!this.transform) {\n    return;\n  }\n\n  var parent = this.parent;\n  var m = this.transform;\n\n  if (parent && parent.transform) {\n    // Get local transform and decompose them to position, scale, rotation\n    matrix.mul(tmpTransform, parent.invTransform, m);\n    m = tmpTransform;\n  }\n\n  var sx = m[0] * m[0] + m[1] * m[1];\n  var sy = m[2] * m[2] + m[3] * m[3];\n  var position = this.position;\n  var scale = this.scale;\n\n  if (isNotAroundZero(sx - 1)) {\n    sx = Math.sqrt(sx);\n  }\n\n  if (isNotAroundZero(sy - 1)) {\n    sy = Math.sqrt(sy);\n  }\n\n  if (m[0] < 0) {\n    sx = -sx;\n  }\n\n  if (m[3] < 0) {\n    sy = -sy;\n  }\n\n  position[0] = m[4];\n  position[1] = m[5];\n  scale[0] = sx;\n  scale[1] = sy;\n  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n};\n/**\n * Get global scale\n * @return {Array.<number>}\n */\n\n\ntransformableProto.getGlobalScale = function () {\n  var m = this.transform;\n\n  if (!m) {\n    return [1, 1];\n  }\n\n  var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n  var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\n  if (m[0] < 0) {\n    sx = -sx;\n  }\n\n  if (m[3] < 0) {\n    sy = -sy;\n  }\n\n  return [sx, sy];\n};\n/**\n * 变换坐标位置到 shape 的局部坐标空间\n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToLocal = function (x, y) {\n  var v2 = [x, y];\n  var invTransform = this.invTransform;\n\n  if (invTransform) {\n    vector.applyTransform(v2, v2, invTransform);\n  }\n\n  return v2;\n};\n/**\n * 变换局部坐标位置到全局坐标空间\n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToGlobal = function (x, y) {\n  var v2 = [x, y];\n  var transform = this.transform;\n\n  if (transform) {\n    vector.applyTransform(v2, v2, transform);\n  }\n\n  return v2;\n};\n/**\n * @static\n * @param {Object} target\n * @param {Array.<number>} target.origin\n * @param {number} target.rotation\n * @param {Array.<number>} target.position\n * @param {Array.<number>} [m]\n */\n\n\nTransformable.getLocalTransform = function (target, m) {\n  m = m || [];\n  mIdentity(m);\n  var origin = target.origin;\n  var scale = target.scale || [1, 1];\n  var rotation = target.rotation || 0;\n  var position = target.position || [0, 0];\n\n  if (origin) {\n    // Translate to origin\n    m[4] -= origin[0];\n    m[5] -= origin[1];\n  }\n\n  matrix.scale(m, m, scale);\n\n  if (rotation) {\n    matrix.rotate(m, m, rotation);\n  }\n\n  if (origin) {\n    // Translate back from origin\n    m[4] += origin[0];\n    m[5] += origin[1];\n  }\n\n  m[4] += position[0];\n  m[5] += position[1];\n  return m;\n};\n\nvar _default = Transformable;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Transformable.js\n// module id = 13\n// module chunks = 0","/**\n * 3x2矩阵操作类\n * @exports zrender/tool/matrix\n */\nvar ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n/**\n * 创建一个单位矩阵\n * @return {Float32Array|Array.<number>}\n */\n\nfunction create() {\n  var out = new ArrayCtor(6);\n  identity(out);\n  return out;\n}\n/**\n * 设置矩阵为单位矩阵\n * @param {Float32Array|Array.<number>} out\n */\n\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\n * 复制矩阵\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} m\n */\n\n\nfunction copy(out, m) {\n  out[0] = m[0];\n  out[1] = m[1];\n  out[2] = m[2];\n  out[3] = m[3];\n  out[4] = m[4];\n  out[5] = m[5];\n  return out;\n}\n/**\n * 矩阵相乘\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} m1\n * @param {Float32Array|Array.<number>} m2\n */\n\n\nfunction mul(out, m1, m2) {\n  // Consider matrix.mul(m, m2, m);\n  // where out is the same as m2.\n  // So use temp variable to escape error.\n  var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n  var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n  var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n  var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = out3;\n  out[4] = out4;\n  out[5] = out5;\n  return out;\n}\n/**\n * 平移变换\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {Float32Array|Array.<number>} v\n */\n\n\nfunction translate(out, a, v) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4] + v[0];\n  out[5] = a[5] + v[1];\n  return out;\n}\n/**\n * 旋转变换\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {number} rad\n */\n\n\nfunction rotate(out, a, rad) {\n  var aa = a[0];\n  var ac = a[2];\n  var atx = a[4];\n  var ab = a[1];\n  var ad = a[3];\n  var aty = a[5];\n  var st = Math.sin(rad);\n  var ct = Math.cos(rad);\n  out[0] = aa * ct + ab * st;\n  out[1] = -aa * st + ab * ct;\n  out[2] = ac * ct + ad * st;\n  out[3] = -ac * st + ct * ad;\n  out[4] = ct * atx + st * aty;\n  out[5] = ct * aty - st * atx;\n  return out;\n}\n/**\n * 缩放变换\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {Float32Array|Array.<number>} v\n */\n\n\nfunction scale(out, a, v) {\n  var vx = v[0];\n  var vy = v[1];\n  out[0] = a[0] * vx;\n  out[1] = a[1] * vy;\n  out[2] = a[2] * vx;\n  out[3] = a[3] * vy;\n  out[4] = a[4] * vx;\n  out[5] = a[5] * vy;\n  return out;\n}\n/**\n * 求逆矩阵\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n */\n\n\nfunction invert(out, a) {\n  var aa = a[0];\n  var ac = a[2];\n  var atx = a[4];\n  var ab = a[1];\n  var ad = a[3];\n  var aty = a[5];\n  var det = aa * ad - ab * ac;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = ad * det;\n  out[1] = -ab * det;\n  out[2] = -ac * det;\n  out[3] = aa * det;\n  out[4] = (ac * aty - ad * atx) * det;\n  out[5] = (ab * atx - aa * aty) * det;\n  return out;\n}\n\nexports.create = create;\nexports.identity = identity;\nexports.copy = copy;\nexports.mul = mul;\nexports.translate = translate;\nexports.rotate = rotate;\nexports.scale = scale;\nexports.invert = invert;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/matrix.js\n// module id = 14\n// module chunks = 0","var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n/**\n * 创建一个向量\n * @param {number} [x=0]\n * @param {number} [y=0]\n * @return {Vector2}\n */\n\nfunction create(x, y) {\n  var out = new ArrayCtor(2);\n\n  if (x == null) {\n    x = 0;\n  }\n\n  if (y == null) {\n    y = 0;\n  }\n\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * 复制向量数据\n * @param {Vector2} out\n * @param {Vector2} v\n * @return {Vector2}\n */\n\n\nfunction copy(out, v) {\n  out[0] = v[0];\n  out[1] = v[1];\n  return out;\n}\n/**\n * 克隆一个向量\n * @param {Vector2} v\n * @return {Vector2}\n */\n\n\nfunction clone(v) {\n  var out = new ArrayCtor(2);\n  out[0] = v[0];\n  out[1] = v[1];\n  return out;\n}\n/**\n * 设置向量的两个项\n * @param {Vector2} out\n * @param {number} a\n * @param {number} b\n * @return {Vector2} 结果\n */\n\n\nfunction set(out, a, b) {\n  out[0] = a;\n  out[1] = b;\n  return out;\n}\n/**\n * 向量相加\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction add(out, v1, v2) {\n  out[0] = v1[0] + v2[0];\n  out[1] = v1[1] + v2[1];\n  return out;\n}\n/**\n * 向量缩放后相加\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @param {number} a\n */\n\n\nfunction scaleAndAdd(out, v1, v2, a) {\n  out[0] = v1[0] + v2[0] * a;\n  out[1] = v1[1] + v2[1] * a;\n  return out;\n}\n/**\n * 向量相减\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction sub(out, v1, v2) {\n  out[0] = v1[0] - v2[0];\n  out[1] = v1[1] - v2[1];\n  return out;\n}\n/**\n * 向量长度\n * @param {Vector2} v\n * @return {number}\n */\n\n\nfunction len(v) {\n  return Math.sqrt(lenSquare(v));\n}\n\nvar length = len; // jshint ignore:line\n\n/**\n * 向量长度平方\n * @param {Vector2} v\n * @return {number}\n */\n\nfunction lenSquare(v) {\n  return v[0] * v[0] + v[1] * v[1];\n}\n\nvar lengthSquare = lenSquare;\n/**\n * 向量乘法\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\nfunction mul(out, v1, v2) {\n  out[0] = v1[0] * v2[0];\n  out[1] = v1[1] * v2[1];\n  return out;\n}\n/**\n * 向量除法\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction div(out, v1, v2) {\n  out[0] = v1[0] / v2[0];\n  out[1] = v1[1] / v2[1];\n  return out;\n}\n/**\n * 向量点乘\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\n\nfunction dot(v1, v2) {\n  return v1[0] * v2[0] + v1[1] * v2[1];\n}\n/**\n * 向量缩放\n * @param {Vector2} out\n * @param {Vector2} v\n * @param {number} s\n */\n\n\nfunction scale(out, v, s) {\n  out[0] = v[0] * s;\n  out[1] = v[1] * s;\n  return out;\n}\n/**\n * 向量归一化\n * @param {Vector2} out\n * @param {Vector2} v\n */\n\n\nfunction normalize(out, v) {\n  var d = len(v);\n\n  if (d === 0) {\n    out[0] = 0;\n    out[1] = 0;\n  } else {\n    out[0] = v[0] / d;\n    out[1] = v[1] / d;\n  }\n\n  return out;\n}\n/**\n * 计算向量间距离\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\n\nfunction distance(v1, v2) {\n  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));\n}\n\nvar dist = distance;\n/**\n * 向量距离平方\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\nfunction distanceSquare(v1, v2) {\n  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n}\n\nvar distSquare = distanceSquare;\n/**\n * 求负向量\n * @param {Vector2} out\n * @param {Vector2} v\n */\n\nfunction negate(out, v) {\n  out[0] = -v[0];\n  out[1] = -v[1];\n  return out;\n}\n/**\n * 插值两个点\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @param {number} t\n */\n\n\nfunction lerp(out, v1, v2, t) {\n  out[0] = v1[0] + t * (v2[0] - v1[0]);\n  out[1] = v1[1] + t * (v2[1] - v1[1]);\n  return out;\n}\n/**\n * 矩阵左乘向量\n * @param {Vector2} out\n * @param {Vector2} v\n * @param {Vector2} m\n */\n\n\nfunction applyTransform(out, v, m) {\n  var x = v[0];\n  var y = v[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\n * 求两个向量最小值\n * @param  {Vector2} out\n * @param  {Vector2} v1\n * @param  {Vector2} v2\n */\n\n\nfunction min(out, v1, v2) {\n  out[0] = Math.min(v1[0], v2[0]);\n  out[1] = Math.min(v1[1], v2[1]);\n  return out;\n}\n/**\n * 求两个向量最大值\n * @param  {Vector2} out\n * @param  {Vector2} v1\n * @param  {Vector2} v2\n */\n\n\nfunction max(out, v1, v2) {\n  out[0] = Math.max(v1[0], v2[0]);\n  out[1] = Math.max(v1[1], v2[1]);\n  return out;\n}\n\nexports.create = create;\nexports.copy = copy;\nexports.clone = clone;\nexports.set = set;\nexports.add = add;\nexports.scaleAndAdd = scaleAndAdd;\nexports.sub = sub;\nexports.len = len;\nexports.length = length;\nexports.lenSquare = lenSquare;\nexports.lengthSquare = lengthSquare;\nexports.mul = mul;\nexports.div = div;\nexports.dot = dot;\nexports.scale = scale;\nexports.normalize = normalize;\nexports.distance = distance;\nexports.dist = dist;\nexports.distanceSquare = distanceSquare;\nexports.distSquare = distSquare;\nexports.negate = negate;\nexports.lerp = lerp;\nexports.applyTransform = applyTransform;\nexports.min = min;\nexports.max = max;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/vector.js\n// module id = 15\n// module chunks = 0","var Animator = require(\"../animation/Animator\");\n\nvar log = require(\"../core/log\");\n\nvar _util = require(\"../core/util\");\n\nvar isString = _util.isString;\nvar isFunction = _util.isFunction;\nvar isObject = _util.isObject;\nvar isArrayLike = _util.isArrayLike;\nvar indexOf = _util.indexOf;\n\n/**\n * @alias modue:zrender/mixin/Animatable\n * @constructor\n */\nvar Animatable = function () {\n  /**\n   * @type {Array.<module:zrender/animation/Animator>}\n   * @readOnly\n   */\n  this.animators = [];\n};\n\nAnimatable.prototype = {\n  constructor: Animatable,\n\n  /**\n   * 动画\n   *\n   * @param {string} path The path to fetch value from object, like 'a.b.c'.\n   * @param {boolean} [loop] Whether to loop animation.\n   * @return {module:zrender/animation/Animator}\n   * @example:\n   *     el.animate('style', false)\n   *         .when(1000, {x: 10} )\n   *         .done(function(){ // Animation done })\n   *         .start()\n   */\n  animate: function (path, loop) {\n    var target;\n    var animatingShape = false;\n    var el = this;\n    var zr = this.__zr;\n\n    if (path) {\n      var pathSplitted = path.split('.');\n      var prop = el; // If animating shape\n\n      animatingShape = pathSplitted[0] === 'shape';\n\n      for (var i = 0, l = pathSplitted.length; i < l; i++) {\n        if (!prop) {\n          continue;\n        }\n\n        prop = prop[pathSplitted[i]];\n      }\n\n      if (prop) {\n        target = prop;\n      }\n    } else {\n      target = el;\n    }\n\n    if (!target) {\n      log('Property \"' + path + '\" is not existed in element ' + el.id);\n      return;\n    }\n\n    var animators = el.animators;\n    var animator = new Animator(target, loop);\n    animator.during(function (target) {\n      el.dirty(animatingShape);\n    }).done(function () {\n      // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n      animators.splice(indexOf(animators, animator), 1);\n    });\n    animators.push(animator); // If animate after added to the zrender\n\n    if (zr) {\n      zr.animation.addAnimator(animator);\n    }\n\n    return animator;\n  },\n\n  /**\n   * 停止动画\n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stopAnimation: function (forwardToLast) {\n    var animators = this.animators;\n    var len = animators.length;\n\n    for (var i = 0; i < len; i++) {\n      animators[i].stop(forwardToLast);\n    }\n\n    animators.length = 0;\n    return this;\n  },\n\n  /**\n   * Caution: this method will stop previous animation.\n   * So do not use this method to one element twice before\n   * animation starts, unless you know what you are doing.\n   * @param {Object} target\n   * @param {number} [time=500] Time in ms\n   * @param {string} [easing='linear']\n   * @param {number} [delay=0]\n   * @param {Function} [callback]\n   * @param {Function} [forceAnimate] Prevent stop animation and callback\n   *        immediently when target values are the same as current values.\n   *\n   * @example\n   *  // Animate position\n   *  el.animateTo({\n   *      position: [10, 10]\n   *  }, function () { // done })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n   *  el.animateTo({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100, 'cubicOut', function () { // done })\n   */\n  // TODO Return animation key\n  animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n    // animateTo(target, time, easing, callback);\n    if (isString(delay)) {\n      callback = easing;\n      easing = delay;\n      delay = 0;\n    } // animateTo(target, time, delay, callback);\n    else if (isFunction(easing)) {\n        callback = easing;\n        easing = 'linear';\n        delay = 0;\n      } // animateTo(target, time, callback);\n      else if (isFunction(delay)) {\n          callback = delay;\n          delay = 0;\n        } // animateTo(target, callback)\n        else if (isFunction(time)) {\n            callback = time;\n            time = 500;\n          } // animateTo(target)\n          else if (!time) {\n              time = 500;\n            } // Stop all previous animations\n\n\n    this.stopAnimation();\n\n    this._animateToShallow('', this, target, time, delay); // Animators may be removed immediately after start\n    // if there is nothing to animate\n\n\n    var animators = this.animators.slice();\n    var count = animators.length;\n\n    function done() {\n      count--;\n\n      if (!count) {\n        callback && callback();\n      }\n    } // No animators. This should be checked before animators[i].start(),\n    // because 'done' may be executed immediately if no need to animate.\n\n\n    if (!count) {\n      callback && callback();\n    } // Start after all animators created\n    // Incase any animator is done immediately when all animation properties are not changed\n\n\n    for (var i = 0; i < animators.length; i++) {\n      animators[i].done(done).start(easing, forceAnimate);\n    }\n  },\n\n  /**\n   * @private\n   * @param {string} path=''\n   * @param {Object} source=this\n   * @param {Object} target\n   * @param {number} [time=500]\n   * @param {number} [delay=0]\n   *\n   * @example\n   *  // Animate position\n   *  el._animateToShallow({\n   *      position: [10, 10]\n   *  })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms\n   *  el._animateToShallow({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100)\n   */\n  _animateToShallow: function (path, source, target, time, delay) {\n    var objShallow = {};\n    var propertyCount = 0;\n\n    for (var name in target) {\n      if (!target.hasOwnProperty(name)) {\n        continue;\n      }\n\n      if (source[name] != null) {\n        if (isObject(target[name]) && !isArrayLike(target[name])) {\n          this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);\n        } else {\n          objShallow[name] = target[name];\n          propertyCount++;\n        }\n      } else if (target[name] != null) {\n        // Attr directly if not has property\n        // FIXME, if some property not needed for element ?\n        if (!path) {\n          this.attr(name, target[name]);\n        } else {\n          // Shape or style\n          var props = {};\n          props[path] = {};\n          props[path][name] = target[name];\n          this.attr(props);\n        }\n      }\n    }\n\n    if (propertyCount > 0) {\n      this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n    }\n\n    return this;\n  }\n};\nvar _default = Animatable;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Animatable.js\n// module id = 16\n// module chunks = 0","var Clip = require(\"./Clip\");\n\nvar color = require(\"../tool/color\");\n\nvar _util = require(\"../core/util\");\n\nvar isArrayLike = _util.isArrayLike;\n\n/**\n * @module echarts/animation/Animator\n */\nvar arraySlice = Array.prototype.slice;\n\nfunction defaultGetter(target, key) {\n  return target[key];\n}\n\nfunction defaultSetter(target, key, value) {\n  target[key] = value;\n}\n/**\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} percent\n * @return {number}\n */\n\n\nfunction interpolateNumber(p0, p1, percent) {\n  return (p1 - p0) * percent + p0;\n}\n/**\n * @param  {string} p0\n * @param  {string} p1\n * @param  {number} percent\n * @return {string}\n */\n\n\nfunction interpolateString(p0, p1, percent) {\n  return percent > 0.5 ? p1 : p0;\n}\n/**\n * @param  {Array} p0\n * @param  {Array} p1\n * @param  {number} percent\n * @param  {Array} out\n * @param  {number} arrDim\n */\n\n\nfunction interpolateArray(p0, p1, percent, out, arrDim) {\n  var len = p0.length;\n\n  if (arrDim == 1) {\n    for (var i = 0; i < len; i++) {\n      out[i] = interpolateNumber(p0[i], p1[i], percent);\n    }\n  } else {\n    var len2 = len && p0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n      }\n    }\n  }\n} // arr0 is source array, arr1 is target array.\n// Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\n\nfunction fillArr(arr0, arr1, arrDim) {\n  var arr0Len = arr0.length;\n  var arr1Len = arr1.length;\n\n  if (arr0Len !== arr1Len) {\n    // FIXME Not work for TypedArray\n    var isPreviousLarger = arr0Len > arr1Len;\n\n    if (isPreviousLarger) {\n      // Cut the previous\n      arr0.length = arr1Len;\n    } else {\n      // Fill the previous\n      for (var i = arr0Len; i < arr1Len; i++) {\n        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n      }\n    }\n  } // Handling NaN value\n\n\n  var len2 = arr0[0] && arr0[0].length;\n\n  for (var i = 0; i < arr0.length; i++) {\n    if (arrDim === 1) {\n      if (isNaN(arr0[i])) {\n        arr0[i] = arr1[i];\n      }\n    } else {\n      for (var j = 0; j < len2; j++) {\n        if (isNaN(arr0[i][j])) {\n          arr0[i][j] = arr1[i][j];\n        }\n      }\n    }\n  }\n}\n/**\n * @param  {Array} arr0\n * @param  {Array} arr1\n * @param  {number} arrDim\n * @return {boolean}\n */\n\n\nfunction isArraySame(arr0, arr1, arrDim) {\n  if (arr0 === arr1) {\n    return true;\n  }\n\n  var len = arr0.length;\n\n  if (len !== arr1.length) {\n    return false;\n  }\n\n  if (arrDim === 1) {\n    for (var i = 0; i < len; i++) {\n      if (arr0[i] !== arr1[i]) {\n        return false;\n      }\n    }\n  } else {\n    var len2 = arr0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        if (arr0[i][j] !== arr1[i][j]) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Catmull Rom interpolate array\n * @param  {Array} p0\n * @param  {Array} p1\n * @param  {Array} p2\n * @param  {Array} p3\n * @param  {number} t\n * @param  {number} t2\n * @param  {number} t3\n * @param  {Array} out\n * @param  {number} arrDim\n */\n\n\nfunction catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {\n  var len = p0.length;\n\n  if (arrDim == 1) {\n    for (var i = 0; i < len; i++) {\n      out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);\n    }\n  } else {\n    var len2 = p0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);\n      }\n    }\n  }\n}\n/**\n * Catmull Rom interpolate number\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @param  {number} t2\n * @param  {number} t3\n * @return {number}\n */\n\n\nfunction catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n  var v0 = (p2 - p0) * 0.5;\n  var v1 = (p3 - p1) * 0.5;\n  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n}\n\nfunction cloneValue(value) {\n  if (isArrayLike(value)) {\n    var len = value.length;\n\n    if (isArrayLike(value[0])) {\n      var ret = [];\n\n      for (var i = 0; i < len; i++) {\n        ret.push(arraySlice.call(value[i]));\n      }\n\n      return ret;\n    }\n\n    return arraySlice.call(value);\n  }\n\n  return value;\n}\n\nfunction rgba2String(rgba) {\n  rgba[0] = Math.floor(rgba[0]);\n  rgba[1] = Math.floor(rgba[1]);\n  rgba[2] = Math.floor(rgba[2]);\n  return 'rgba(' + rgba.join(',') + ')';\n}\n\nfunction getArrayDim(keyframes) {\n  var lastValue = keyframes[keyframes.length - 1].value;\n  return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n}\n\nfunction createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {\n  var getter = animator._getter;\n  var setter = animator._setter;\n  var useSpline = easing === 'spline';\n  var trackLen = keyframes.length;\n\n  if (!trackLen) {\n    return;\n  } // Guess data type\n\n\n  var firstVal = keyframes[0].value;\n  var isValueArray = isArrayLike(firstVal);\n  var isValueColor = false;\n  var isValueString = false; // For vertices morphing\n\n  var arrDim = isValueArray ? getArrayDim(keyframes) : 0;\n  var trackMaxTime; // Sort keyframe as ascending\n\n  keyframes.sort(function (a, b) {\n    return a.time - b.time;\n  });\n  trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe\n\n  var kfPercents = []; // Value of each keyframe\n\n  var kfValues = [];\n  var prevValue = keyframes[0].value;\n  var isAllValueEqual = true;\n\n  for (var i = 0; i < trackLen; i++) {\n    kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string\n\n    var value = keyframes[i].value; // Check if value is equal, deep check if value is array\n\n    if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {\n      isAllValueEqual = false;\n    }\n\n    prevValue = value; // Try converting a string to a color array\n\n    if (typeof value == 'string') {\n      var colorArray = color.parse(value);\n\n      if (colorArray) {\n        value = colorArray;\n        isValueColor = true;\n      } else {\n        isValueString = true;\n      }\n    }\n\n    kfValues.push(value);\n  }\n\n  if (!forceAnimate && isAllValueEqual) {\n    return;\n  }\n\n  var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value\n\n  for (var i = 0; i < trackLen - 1; i++) {\n    if (isValueArray) {\n      fillArr(kfValues[i], lastValue, arrDim);\n    } else {\n      if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n        kfValues[i] = lastValue;\n      }\n    }\n  }\n\n  isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when\n  // animation playback is sequency\n\n  var lastFrame = 0;\n  var lastFramePercent = 0;\n  var start;\n  var w;\n  var p0;\n  var p1;\n  var p2;\n  var p3;\n\n  if (isValueColor) {\n    var rgba = [0, 0, 0, 0];\n  }\n\n  var onframe = function (target, percent) {\n    // Find the range keyframes\n    // kf1-----kf2---------current--------kf3\n    // find kf2 and kf3 and do interpolation\n    var frame; // In the easing function like elasticOut, percent may less than 0\n\n    if (percent < 0) {\n      frame = 0;\n    } else if (percent < lastFramePercent) {\n      // Start from next key\n      // PENDING start from lastFrame ?\n      start = Math.min(lastFrame + 1, trackLen - 1);\n\n      for (frame = start; frame >= 0; frame--) {\n        if (kfPercents[frame] <= percent) {\n          break;\n        }\n      } // PENDING really need to do this ?\n\n\n      frame = Math.min(frame, trackLen - 2);\n    } else {\n      for (frame = lastFrame; frame < trackLen; frame++) {\n        if (kfPercents[frame] > percent) {\n          break;\n        }\n      }\n\n      frame = Math.min(frame - 1, trackLen - 2);\n    }\n\n    lastFrame = frame;\n    lastFramePercent = percent;\n    var range = kfPercents[frame + 1] - kfPercents[frame];\n\n    if (range === 0) {\n      return;\n    } else {\n      w = (percent - kfPercents[frame]) / range;\n    }\n\n    if (useSpline) {\n      p1 = kfValues[frame];\n      p0 = kfValues[frame === 0 ? frame : frame - 1];\n      p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n      p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\n      if (isValueArray) {\n        catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);\n      } else {\n        var value;\n\n        if (isValueColor) {\n          value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);\n          value = rgba2String(rgba);\n        } else if (isValueString) {\n          // String is step(0.5)\n          return interpolateString(p1, p2, w);\n        } else {\n          value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);\n        }\n\n        setter(target, propName, value);\n      }\n    } else {\n      if (isValueArray) {\n        interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);\n      } else {\n        var value;\n\n        if (isValueColor) {\n          interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);\n          value = rgba2String(rgba);\n        } else if (isValueString) {\n          // String is step(0.5)\n          return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n        } else {\n          value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n        }\n\n        setter(target, propName, value);\n      }\n    }\n  };\n\n  var clip = new Clip({\n    target: animator._target,\n    life: trackMaxTime,\n    loop: animator._loop,\n    delay: animator._delay,\n    onframe: onframe,\n    ondestroy: oneTrackDone\n  });\n\n  if (easing && easing !== 'spline') {\n    clip.easing = easing;\n  }\n\n  return clip;\n}\n/**\n * @alias module:zrender/animation/Animator\n * @constructor\n * @param {Object} target\n * @param {boolean} loop\n * @param {Function} getter\n * @param {Function} setter\n */\n\n\nvar Animator = function (target, loop, getter, setter) {\n  this._tracks = {};\n  this._target = target;\n  this._loop = loop || false;\n  this._getter = getter || defaultGetter;\n  this._setter = setter || defaultSetter;\n  this._clipCount = 0;\n  this._delay = 0;\n  this._doneList = [];\n  this._onframeList = [];\n  this._clipList = [];\n};\n\nAnimator.prototype = {\n  /**\n   * 设置动画关键帧\n   * @param  {number} time 关键帧时间，单位是ms\n   * @param  {Object} props 关键帧的属性值，key-value表示\n   * @return {module:zrender/animation/Animator}\n   */\n  when: function (time\n  /* ms */\n  , props) {\n    var tracks = this._tracks;\n\n    for (var propName in props) {\n      if (!props.hasOwnProperty(propName)) {\n        continue;\n      }\n\n      if (!tracks[propName]) {\n        tracks[propName] = []; // Invalid value\n\n        var value = this._getter(this._target, propName);\n\n        if (value == null) {\n          // zrLog('Invalid property ' + propName);\n          continue;\n        } // If time is 0\n        //  Then props is given initialize value\n        // Else\n        //  Initialize value from current prop value\n\n\n        if (time !== 0) {\n          tracks[propName].push({\n            time: 0,\n            value: cloneValue(value)\n          });\n        }\n      }\n\n      tracks[propName].push({\n        time: time,\n        value: props[propName]\n      });\n    }\n\n    return this;\n  },\n\n  /**\n   * 添加动画每一帧的回调函数\n   * @param  {Function} callback\n   * @return {module:zrender/animation/Animator}\n   */\n  during: function (callback) {\n    this._onframeList.push(callback);\n\n    return this;\n  },\n  pause: function () {\n    for (var i = 0; i < this._clipList.length; i++) {\n      this._clipList[i].pause();\n    }\n\n    this._paused = true;\n  },\n  resume: function () {\n    for (var i = 0; i < this._clipList.length; i++) {\n      this._clipList[i].resume();\n    }\n\n    this._paused = false;\n  },\n  isPaused: function () {\n    return !!this._paused;\n  },\n  _doneCallback: function () {\n    // Clear all tracks\n    this._tracks = {}; // Clear all clips\n\n    this._clipList.length = 0;\n    var doneList = this._doneList;\n    var len = doneList.length;\n\n    for (var i = 0; i < len; i++) {\n      doneList[i].call(this);\n    }\n  },\n\n  /**\n   * 开始执行动画\n   * @param  {string|Function} [easing]\n   *         动画缓动函数，详见{@link module:zrender/animation/easing}\n   * @param  {boolean} forceAnimate\n   * @return {module:zrender/animation/Animator}\n   */\n  start: function (easing, forceAnimate) {\n    var self = this;\n    var clipCount = 0;\n\n    var oneTrackDone = function () {\n      clipCount--;\n\n      if (!clipCount) {\n        self._doneCallback();\n      }\n    };\n\n    var lastClip;\n\n    for (var propName in this._tracks) {\n      if (!this._tracks.hasOwnProperty(propName)) {\n        continue;\n      }\n\n      var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);\n\n      if (clip) {\n        this._clipList.push(clip);\n\n        clipCount++; // If start after added to animation\n\n        if (this.animation) {\n          this.animation.addClip(clip);\n        }\n\n        lastClip = clip;\n      }\n    } // Add during callback on the last clip\n\n\n    if (lastClip) {\n      var oldOnFrame = lastClip.onframe;\n\n      lastClip.onframe = function (target, percent) {\n        oldOnFrame(target, percent);\n\n        for (var i = 0; i < self._onframeList.length; i++) {\n          self._onframeList[i](target, percent);\n        }\n      };\n    } // This optimization will help the case that in the upper application\n    // the view may be refreshed frequently, where animation will be\n    // called repeatly but nothing changed.\n\n\n    if (!clipCount) {\n      this._doneCallback();\n    }\n\n    return this;\n  },\n\n  /**\n   * 停止动画\n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stop: function (forwardToLast) {\n    var clipList = this._clipList;\n    var animation = this.animation;\n\n    for (var i = 0; i < clipList.length; i++) {\n      var clip = clipList[i];\n\n      if (forwardToLast) {\n        // Move to last frame before stop\n        clip.onframe(this._target, 1);\n      }\n\n      animation && animation.removeClip(clip);\n    }\n\n    clipList.length = 0;\n  },\n\n  /**\n   * 设置动画延迟开始的时间\n   * @param  {number} time 单位ms\n   * @return {module:zrender/animation/Animator}\n   */\n  delay: function (time) {\n    this._delay = time;\n    return this;\n  },\n\n  /**\n   * 添加动画结束的回调\n   * @param  {Function} cb\n   * @return {module:zrender/animation/Animator}\n   */\n  done: function (cb) {\n    if (cb) {\n      this._doneList.push(cb);\n    }\n\n    return this;\n  },\n\n  /**\n   * @return {Array.<module:zrender/animation/Clip>}\n   */\n  getClips: function () {\n    return this._clipList;\n  }\n};\nvar _default = Animator;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Animator.js\n// module id = 17\n// module chunks = 0","var easingFuncs = require(\"./easing\");\n\n/**\n * 动画主控制器\n * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\n * @config life(1000) 动画时长\n * @config delay(0) 动画延迟时间\n * @config loop(true)\n * @config gap(0) 循环的间隔时间\n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\nfunction Clip(options) {\n  this._target = options.target; // 生命周期\n\n  this._life = options.life || 1000; // 延时\n\n  this._delay = options.delay || 0; // 开始时间\n  // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n\n  this._initialized = false; // 是否循环\n\n  this.loop = options.loop == null ? false : options.loop;\n  this.gap = options.gap || 0;\n  this.easing = options.easing || 'Linear';\n  this.onframe = options.onframe;\n  this.ondestroy = options.ondestroy;\n  this.onrestart = options.onrestart;\n  this._pausedTime = 0;\n  this._paused = false;\n}\n\nClip.prototype = {\n  constructor: Clip,\n  step: function (globalTime, deltaTime) {\n    // Set startTime on first step, or _startTime may has milleseconds different between clips\n    // PENDING\n    if (!this._initialized) {\n      this._startTime = globalTime + this._delay;\n      this._initialized = true;\n    }\n\n    if (this._paused) {\n      this._pausedTime += deltaTime;\n      return;\n    }\n\n    var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // 还没开始\n\n    if (percent < 0) {\n      return;\n    }\n\n    percent = Math.min(percent, 1);\n    var easing = this.easing;\n    var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n    var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;\n    this.fire('frame', schedule); // 结束\n\n    if (percent == 1) {\n      if (this.loop) {\n        this.restart(globalTime); // 重新开始周期\n        // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n\n        return 'restart';\n      } // 动画完成将这个控制器标识为待删除\n      // 在Animation.update中进行批量删除\n\n\n      this._needsRemove = true;\n      return 'destroy';\n    }\n\n    return null;\n  },\n  restart: function (globalTime) {\n    var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n    this._startTime = globalTime - remainder + this.gap;\n    this._pausedTime = 0;\n    this._needsRemove = false;\n  },\n  fire: function (eventType, arg) {\n    eventType = 'on' + eventType;\n\n    if (this[eventType]) {\n      this[eventType](this._target, arg);\n    }\n  },\n  pause: function () {\n    this._paused = true;\n  },\n  resume: function () {\n    this._paused = false;\n  }\n};\nvar _default = Clip;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Clip.js\n// module id = 18\n// module chunks = 0","/**\n * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\nvar easing = {\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  linear: function (k) {\n    return k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticIn: function (k) {\n    return k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticOut: function (k) {\n    return k * (2 - k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k;\n    }\n\n    return -0.5 * (--k * (k - 2) - 1);\n  },\n  // 三次方的缓动（t^3）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicIn: function (k) {\n    return k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicOut: function (k) {\n    return --k * k * k + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k;\n    }\n\n    return 0.5 * ((k -= 2) * k * k + 2);\n  },\n  // 四次方的缓动（t^4）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticIn: function (k) {\n    return k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticOut: function (k) {\n    return 1 - --k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k * k;\n    }\n\n    return -0.5 * ((k -= 2) * k * k * k - 2);\n  },\n  // 五次方的缓动（t^5）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticIn: function (k) {\n    return k * k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticOut: function (k) {\n    return --k * k * k * k * k + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k * k * k;\n    }\n\n    return 0.5 * ((k -= 2) * k * k * k * k + 2);\n  },\n  // 正弦曲线的缓动（sin(t)）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalIn: function (k) {\n    return 1 - Math.cos(k * Math.PI / 2);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalOut: function (k) {\n    return Math.sin(k * Math.PI / 2);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalInOut: function (k) {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n  },\n  // 指数曲线的缓动（2^t）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialIn: function (k) {\n    return k === 0 ? 0 : Math.pow(1024, k - 1);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialOut: function (k) {\n    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialInOut: function (k) {\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if ((k *= 2) < 1) {\n      return 0.5 * Math.pow(1024, k - 1);\n    }\n\n    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n  },\n  // 圆形曲线的缓动（sqrt(1-t^2)）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularIn: function (k) {\n    return 1 - Math.sqrt(1 - k * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularOut: function (k) {\n    return Math.sqrt(1 - --k * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return -0.5 * (Math.sqrt(1 - k * k) - 1);\n    }\n\n    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n  },\n  // 创建类似于弹簧在停止前来回振荡的动画\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticIn: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticOut: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticInOut: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    if ((k *= 2) < 1) {\n      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n    }\n\n    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n  },\n  // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backIn: function (k) {\n    var s = 1.70158;\n    return k * k * ((s + 1) * k - s);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backOut: function (k) {\n    var s = 1.70158;\n    return --k * k * ((s + 1) * k + s) + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backInOut: function (k) {\n    var s = 1.70158 * 1.525;\n\n    if ((k *= 2) < 1) {\n      return 0.5 * (k * k * ((s + 1) * k - s));\n    }\n\n    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n  },\n  // 创建弹跳效果\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceIn: function (k) {\n    return 1 - easing.bounceOut(1 - k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceOut: function (k) {\n    if (k < 1 / 2.75) {\n      return 7.5625 * k * k;\n    } else if (k < 2 / 2.75) {\n      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n    } else if (k < 2.5 / 2.75) {\n      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n    } else {\n      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n    }\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceInOut: function (k) {\n    if (k < 0.5) {\n      return easing.bounceIn(k * 2) * 0.5;\n    }\n\n    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n  }\n};\nvar _default = easing;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/easing.js\n// module id = 19\n// module chunks = 0","var LRU = require(\"../core/LRU\");\n\nvar kCSSColorTable = {\n  'transparent': [0, 0, 0, 0],\n  'aliceblue': [240, 248, 255, 1],\n  'antiquewhite': [250, 235, 215, 1],\n  'aqua': [0, 255, 255, 1],\n  'aquamarine': [127, 255, 212, 1],\n  'azure': [240, 255, 255, 1],\n  'beige': [245, 245, 220, 1],\n  'bisque': [255, 228, 196, 1],\n  'black': [0, 0, 0, 1],\n  'blanchedalmond': [255, 235, 205, 1],\n  'blue': [0, 0, 255, 1],\n  'blueviolet': [138, 43, 226, 1],\n  'brown': [165, 42, 42, 1],\n  'burlywood': [222, 184, 135, 1],\n  'cadetblue': [95, 158, 160, 1],\n  'chartreuse': [127, 255, 0, 1],\n  'chocolate': [210, 105, 30, 1],\n  'coral': [255, 127, 80, 1],\n  'cornflowerblue': [100, 149, 237, 1],\n  'cornsilk': [255, 248, 220, 1],\n  'crimson': [220, 20, 60, 1],\n  'cyan': [0, 255, 255, 1],\n  'darkblue': [0, 0, 139, 1],\n  'darkcyan': [0, 139, 139, 1],\n  'darkgoldenrod': [184, 134, 11, 1],\n  'darkgray': [169, 169, 169, 1],\n  'darkgreen': [0, 100, 0, 1],\n  'darkgrey': [169, 169, 169, 1],\n  'darkkhaki': [189, 183, 107, 1],\n  'darkmagenta': [139, 0, 139, 1],\n  'darkolivegreen': [85, 107, 47, 1],\n  'darkorange': [255, 140, 0, 1],\n  'darkorchid': [153, 50, 204, 1],\n  'darkred': [139, 0, 0, 1],\n  'darksalmon': [233, 150, 122, 1],\n  'darkseagreen': [143, 188, 143, 1],\n  'darkslateblue': [72, 61, 139, 1],\n  'darkslategray': [47, 79, 79, 1],\n  'darkslategrey': [47, 79, 79, 1],\n  'darkturquoise': [0, 206, 209, 1],\n  'darkviolet': [148, 0, 211, 1],\n  'deeppink': [255, 20, 147, 1],\n  'deepskyblue': [0, 191, 255, 1],\n  'dimgray': [105, 105, 105, 1],\n  'dimgrey': [105, 105, 105, 1],\n  'dodgerblue': [30, 144, 255, 1],\n  'firebrick': [178, 34, 34, 1],\n  'floralwhite': [255, 250, 240, 1],\n  'forestgreen': [34, 139, 34, 1],\n  'fuchsia': [255, 0, 255, 1],\n  'gainsboro': [220, 220, 220, 1],\n  'ghostwhite': [248, 248, 255, 1],\n  'gold': [255, 215, 0, 1],\n  'goldenrod': [218, 165, 32, 1],\n  'gray': [128, 128, 128, 1],\n  'green': [0, 128, 0, 1],\n  'greenyellow': [173, 255, 47, 1],\n  'grey': [128, 128, 128, 1],\n  'honeydew': [240, 255, 240, 1],\n  'hotpink': [255, 105, 180, 1],\n  'indianred': [205, 92, 92, 1],\n  'indigo': [75, 0, 130, 1],\n  'ivory': [255, 255, 240, 1],\n  'khaki': [240, 230, 140, 1],\n  'lavender': [230, 230, 250, 1],\n  'lavenderblush': [255, 240, 245, 1],\n  'lawngreen': [124, 252, 0, 1],\n  'lemonchiffon': [255, 250, 205, 1],\n  'lightblue': [173, 216, 230, 1],\n  'lightcoral': [240, 128, 128, 1],\n  'lightcyan': [224, 255, 255, 1],\n  'lightgoldenrodyellow': [250, 250, 210, 1],\n  'lightgray': [211, 211, 211, 1],\n  'lightgreen': [144, 238, 144, 1],\n  'lightgrey': [211, 211, 211, 1],\n  'lightpink': [255, 182, 193, 1],\n  'lightsalmon': [255, 160, 122, 1],\n  'lightseagreen': [32, 178, 170, 1],\n  'lightskyblue': [135, 206, 250, 1],\n  'lightslategray': [119, 136, 153, 1],\n  'lightslategrey': [119, 136, 153, 1],\n  'lightsteelblue': [176, 196, 222, 1],\n  'lightyellow': [255, 255, 224, 1],\n  'lime': [0, 255, 0, 1],\n  'limegreen': [50, 205, 50, 1],\n  'linen': [250, 240, 230, 1],\n  'magenta': [255, 0, 255, 1],\n  'maroon': [128, 0, 0, 1],\n  'mediumaquamarine': [102, 205, 170, 1],\n  'mediumblue': [0, 0, 205, 1],\n  'mediumorchid': [186, 85, 211, 1],\n  'mediumpurple': [147, 112, 219, 1],\n  'mediumseagreen': [60, 179, 113, 1],\n  'mediumslateblue': [123, 104, 238, 1],\n  'mediumspringgreen': [0, 250, 154, 1],\n  'mediumturquoise': [72, 209, 204, 1],\n  'mediumvioletred': [199, 21, 133, 1],\n  'midnightblue': [25, 25, 112, 1],\n  'mintcream': [245, 255, 250, 1],\n  'mistyrose': [255, 228, 225, 1],\n  'moccasin': [255, 228, 181, 1],\n  'navajowhite': [255, 222, 173, 1],\n  'navy': [0, 0, 128, 1],\n  'oldlace': [253, 245, 230, 1],\n  'olive': [128, 128, 0, 1],\n  'olivedrab': [107, 142, 35, 1],\n  'orange': [255, 165, 0, 1],\n  'orangered': [255, 69, 0, 1],\n  'orchid': [218, 112, 214, 1],\n  'palegoldenrod': [238, 232, 170, 1],\n  'palegreen': [152, 251, 152, 1],\n  'paleturquoise': [175, 238, 238, 1],\n  'palevioletred': [219, 112, 147, 1],\n  'papayawhip': [255, 239, 213, 1],\n  'peachpuff': [255, 218, 185, 1],\n  'peru': [205, 133, 63, 1],\n  'pink': [255, 192, 203, 1],\n  'plum': [221, 160, 221, 1],\n  'powderblue': [176, 224, 230, 1],\n  'purple': [128, 0, 128, 1],\n  'red': [255, 0, 0, 1],\n  'rosybrown': [188, 143, 143, 1],\n  'royalblue': [65, 105, 225, 1],\n  'saddlebrown': [139, 69, 19, 1],\n  'salmon': [250, 128, 114, 1],\n  'sandybrown': [244, 164, 96, 1],\n  'seagreen': [46, 139, 87, 1],\n  'seashell': [255, 245, 238, 1],\n  'sienna': [160, 82, 45, 1],\n  'silver': [192, 192, 192, 1],\n  'skyblue': [135, 206, 235, 1],\n  'slateblue': [106, 90, 205, 1],\n  'slategray': [112, 128, 144, 1],\n  'slategrey': [112, 128, 144, 1],\n  'snow': [255, 250, 250, 1],\n  'springgreen': [0, 255, 127, 1],\n  'steelblue': [70, 130, 180, 1],\n  'tan': [210, 180, 140, 1],\n  'teal': [0, 128, 128, 1],\n  'thistle': [216, 191, 216, 1],\n  'tomato': [255, 99, 71, 1],\n  'turquoise': [64, 224, 208, 1],\n  'violet': [238, 130, 238, 1],\n  'wheat': [245, 222, 179, 1],\n  'white': [255, 255, 255, 1],\n  'whitesmoke': [245, 245, 245, 1],\n  'yellow': [255, 255, 0, 1],\n  'yellowgreen': [154, 205, 50, 1]\n};\n\nfunction clampCssByte(i) {\n  // Clamp to integer 0 .. 255.\n  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\n  return i < 0 ? 0 : i > 255 ? 255 : i;\n}\n\nfunction clampCssAngle(i) {\n  // Clamp to integer 0 .. 360.\n  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\n  return i < 0 ? 0 : i > 360 ? 360 : i;\n}\n\nfunction clampCssFloat(f) {\n  // Clamp to float 0.0 .. 1.0.\n  return f < 0 ? 0 : f > 1 ? 1 : f;\n}\n\nfunction parseCssInt(str) {\n  // int or percentage.\n  if (str.length && str.charAt(str.length - 1) === '%') {\n    return clampCssByte(parseFloat(str) / 100 * 255);\n  }\n\n  return clampCssByte(parseInt(str, 10));\n}\n\nfunction parseCssFloat(str) {\n  // float or percentage.\n  if (str.length && str.charAt(str.length - 1) === '%') {\n    return clampCssFloat(parseFloat(str) / 100);\n  }\n\n  return clampCssFloat(parseFloat(str));\n}\n\nfunction cssHueToRgb(m1, m2, h) {\n  if (h < 0) {\n    h += 1;\n  } else if (h > 1) {\n    h -= 1;\n  }\n\n  if (h * 6 < 1) {\n    return m1 + (m2 - m1) * h * 6;\n  }\n\n  if (h * 2 < 1) {\n    return m2;\n  }\n\n  if (h * 3 < 2) {\n    return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n  }\n\n  return m1;\n}\n\nfunction lerpNumber(a, b, p) {\n  return a + (b - a) * p;\n}\n\nfunction setRgba(out, r, g, b, a) {\n  out[0] = r;\n  out[1] = g;\n  out[2] = b;\n  out[3] = a;\n  return out;\n}\n\nfunction copyRgba(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\nvar colorCache = new LRU(20);\nvar lastRemovedArr = null;\n\nfunction putToCache(colorStr, rgbaArr) {\n  // Reuse removed array\n  if (lastRemovedArr) {\n    copyRgba(lastRemovedArr, rgbaArr);\n  }\n\n  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());\n}\n/**\n * @param {string} colorStr\n * @param {Array.<number>} out\n * @return {Array.<number>}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction parse(colorStr, rgbaArr) {\n  if (!colorStr) {\n    return;\n  }\n\n  rgbaArr = rgbaArr || [];\n  var cached = colorCache.get(colorStr);\n\n  if (cached) {\n    return copyRgba(rgbaArr, cached);\n  } // colorStr may be not string\n\n\n  colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.\n\n  var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.\n\n  if (str in kCSSColorTable) {\n    copyRgba(rgbaArr, kCSSColorTable[str]);\n    putToCache(colorStr, rgbaArr);\n    return rgbaArr;\n  } // #abc and #abc123 syntax.\n\n\n  if (str.charAt(0) === '#') {\n    if (str.length === 4) {\n      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\n      if (!(iv >= 0 && iv <= 0xfff)) {\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return; // Covers NaN.\n      }\n\n      setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);\n      putToCache(colorStr, rgbaArr);\n      return rgbaArr;\n    } else if (str.length === 7) {\n      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\n      if (!(iv >= 0 && iv <= 0xffffff)) {\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return; // Covers NaN.\n      }\n\n      setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);\n      putToCache(colorStr, rgbaArr);\n      return rgbaArr;\n    }\n\n    return;\n  }\n\n  var op = str.indexOf('('),\n      ep = str.indexOf(')');\n\n  if (op !== -1 && ep + 1 === str.length) {\n    var fname = str.substr(0, op);\n    var params = str.substr(op + 1, ep - (op + 1)).split(',');\n    var alpha = 1; // To allow case fallthrough.\n\n    switch (fname) {\n      case 'rgba':\n        if (params.length !== 4) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        alpha = parseCssFloat(params.pop());\n      // jshint ignore:line\n      // Fall through.\n\n      case 'rgb':\n        if (params.length !== 3) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      case 'hsla':\n        if (params.length !== 4) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        params[3] = parseCssFloat(params[3]);\n        hsla2rgba(params, rgbaArr);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      case 'hsl':\n        if (params.length !== 3) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        hsla2rgba(params, rgbaArr);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      default:\n        return;\n    }\n  }\n\n  setRgba(rgbaArr, 0, 0, 0, 1);\n  return;\n}\n/**\n * @param {Array.<number>} hsla\n * @param {Array.<number>} rgba\n * @return {Array.<number>} rgba\n */\n\n\nfunction hsla2rgba(hsla, rgba) {\n  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1\n  // NOTE(deanm): According to the CSS spec s/l should only be\n  // percentages, but we don't bother and let float or percentage.\n\n  var s = parseCssFloat(hsla[1]);\n  var l = parseCssFloat(hsla[2]);\n  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n  var m1 = l * 2 - m2;\n  rgba = rgba || [];\n  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);\n\n  if (hsla.length === 4) {\n    rgba[3] = hsla[3];\n  }\n\n  return rgba;\n}\n/**\n * @param {Array.<number>} rgba\n * @return {Array.<number>} hsla\n */\n\n\nfunction rgba2hsla(rgba) {\n  if (!rgba) {\n    return;\n  } // RGB from 0 to 255\n\n\n  var R = rgba[0] / 255;\n  var G = rgba[1] / 255;\n  var B = rgba[2] / 255;\n  var vMin = Math.min(R, G, B); // Min. value of RGB\n\n  var vMax = Math.max(R, G, B); // Max. value of RGB\n\n  var delta = vMax - vMin; // Delta RGB value\n\n  var L = (vMax + vMin) / 2;\n  var H;\n  var S; // HSL results from 0 to 1\n\n  if (delta === 0) {\n    H = 0;\n    S = 0;\n  } else {\n    if (L < 0.5) {\n      S = delta / (vMax + vMin);\n    } else {\n      S = delta / (2 - vMax - vMin);\n    }\n\n    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;\n    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;\n    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;\n\n    if (R === vMax) {\n      H = deltaB - deltaG;\n    } else if (G === vMax) {\n      H = 1 / 3 + deltaR - deltaB;\n    } else if (B === vMax) {\n      H = 2 / 3 + deltaG - deltaR;\n    }\n\n    if (H < 0) {\n      H += 1;\n    }\n\n    if (H > 1) {\n      H -= 1;\n    }\n  }\n\n  var hsla = [H * 360, S, L];\n\n  if (rgba[3] != null) {\n    hsla.push(rgba[3]);\n  }\n\n  return hsla;\n}\n/**\n * @param {string} color\n * @param {number} level\n * @return {string}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction lift(color, level) {\n  var colorArr = parse(color);\n\n  if (colorArr) {\n    for (var i = 0; i < 3; i++) {\n      if (level < 0) {\n        colorArr[i] = colorArr[i] * (1 - level) | 0;\n      } else {\n        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;\n      }\n    }\n\n    return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n  }\n}\n/**\n * @param {string} color\n * @return {string}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction toHex(color) {\n  var colorArr = parse(color);\n\n  if (colorArr) {\n    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);\n  }\n}\n/**\n * Map value to color. Faster than lerp methods because color is represented by rgba array.\n * @param {number} normalizedValue A float between 0 and 1.\n * @param {Array.<Array.<number>>} colors List of rgba color array\n * @param {Array.<number>} [out] Mapped gba color array\n * @return {Array.<number>} will be null/undefined if input illegal.\n */\n\n\nfunction fastLerp(normalizedValue, colors, out) {\n  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n    return;\n  }\n\n  out = out || [];\n  var value = normalizedValue * (colors.length - 1);\n  var leftIndex = Math.floor(value);\n  var rightIndex = Math.ceil(value);\n  var leftColor = colors[leftIndex];\n  var rightColor = colors[rightIndex];\n  var dv = value - leftIndex;\n  out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));\n  out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));\n  out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));\n  out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));\n  return out;\n}\n/**\n * @deprecated\n */\n\n\nvar fastMapToColor = fastLerp;\n/**\n * @param {number} normalizedValue A float between 0 and 1.\n * @param {Array.<string>} colors Color list.\n * @param {boolean=} fullOutput Default false.\n * @return {(string|Object)} Result color. If fullOutput,\n *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n * @memberOf module:zrender/util/color\n */\n\nfunction lerp(normalizedValue, colors, fullOutput) {\n  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n    return;\n  }\n\n  var value = normalizedValue * (colors.length - 1);\n  var leftIndex = Math.floor(value);\n  var rightIndex = Math.ceil(value);\n  var leftColor = parse(colors[leftIndex]);\n  var rightColor = parse(colors[rightIndex]);\n  var dv = value - leftIndex;\n  var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');\n  return fullOutput ? {\n    color: color,\n    leftIndex: leftIndex,\n    rightIndex: rightIndex,\n    value: value\n  } : color;\n}\n/**\n * @deprecated\n */\n\n\nvar mapToColor = lerp;\n/**\n * @param {string} color\n * @param {number=} h 0 ~ 360, ignore when null.\n * @param {number=} s 0 ~ 1, ignore when null.\n * @param {number=} l 0 ~ 1, ignore when null.\n * @return {string} Color string in rgba format.\n * @memberOf module:zrender/util/color\n */\n\nfunction modifyHSL(color, h, s, l) {\n  color = parse(color);\n\n  if (color) {\n    color = rgba2hsla(color);\n    h != null && (color[0] = clampCssAngle(h));\n    s != null && (color[1] = parseCssFloat(s));\n    l != null && (color[2] = parseCssFloat(l));\n    return stringify(hsla2rgba(color), 'rgba');\n  }\n}\n/**\n * @param {string} color\n * @param {number=} alpha 0 ~ 1\n * @return {string} Color string in rgba format.\n * @memberOf module:zrender/util/color\n */\n\n\nfunction modifyAlpha(color, alpha) {\n  color = parse(color);\n\n  if (color && alpha != null) {\n    color[3] = clampCssFloat(alpha);\n    return stringify(color, 'rgba');\n  }\n}\n/**\n * @param {Array.<number>} arrColor like [12,33,44,0.4]\n * @param {string} type 'rgba', 'hsva', ...\n * @return {string} Result color. (If input illegal, return undefined).\n */\n\n\nfunction stringify(arrColor, type) {\n  if (!arrColor || !arrColor.length) {\n    return;\n  }\n\n  var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\n  if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n    colorStr += ',' + arrColor[3];\n  }\n\n  return type + '(' + colorStr + ')';\n}\n\nexports.parse = parse;\nexports.lift = lift;\nexports.toHex = toHex;\nexports.fastLerp = fastLerp;\nexports.fastMapToColor = fastMapToColor;\nexports.lerp = lerp;\nexports.mapToColor = mapToColor;\nexports.modifyHSL = modifyHSL;\nexports.modifyAlpha = modifyAlpha;\nexports.stringify = stringify;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/color.js\n// module id = 20\n// module chunks = 0","// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n/**\n * Simple double linked list. Compared with array, it has O(1) remove operation.\n * @constructor\n */\nvar LinkedList = function () {\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n  this.head = null;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.tail = null;\n  this._len = 0;\n};\n\nvar linkedListProto = LinkedList.prototype;\n/**\n * Insert a new value at the tail\n * @param  {} val\n * @return {module:zrender/core/LRU~Entry}\n */\n\nlinkedListProto.insert = function (val) {\n  var entry = new Entry(val);\n  this.insertEntry(entry);\n  return entry;\n};\n/**\n * Insert an entry at the tail\n * @param  {module:zrender/core/LRU~Entry} entry\n */\n\n\nlinkedListProto.insertEntry = function (entry) {\n  if (!this.head) {\n    this.head = this.tail = entry;\n  } else {\n    this.tail.next = entry;\n    entry.prev = this.tail;\n    entry.next = null;\n    this.tail = entry;\n  }\n\n  this._len++;\n};\n/**\n * Remove entry.\n * @param  {module:zrender/core/LRU~Entry} entry\n */\n\n\nlinkedListProto.remove = function (entry) {\n  var prev = entry.prev;\n  var next = entry.next;\n\n  if (prev) {\n    prev.next = next;\n  } else {\n    // Is head\n    this.head = next;\n  }\n\n  if (next) {\n    next.prev = prev;\n  } else {\n    // Is tail\n    this.tail = prev;\n  }\n\n  entry.next = entry.prev = null;\n  this._len--;\n};\n/**\n * @return {number}\n */\n\n\nlinkedListProto.len = function () {\n  return this._len;\n};\n/**\n * Clear list\n */\n\n\nlinkedListProto.clear = function () {\n  this.head = this.tail = null;\n  this._len = 0;\n};\n/**\n * @constructor\n * @param {} val\n */\n\n\nvar Entry = function (val) {\n  /**\n   * @type {}\n   */\n  this.value = val;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.next;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.prev;\n};\n/**\n * LRU Cache\n * @constructor\n * @alias module:zrender/core/LRU\n */\n\n\nvar LRU = function (maxSize) {\n  this._list = new LinkedList();\n  this._map = {};\n  this._maxSize = maxSize || 10;\n  this._lastRemovedEntry = null;\n};\n\nvar LRUProto = LRU.prototype;\n/**\n * @param  {string} key\n * @param  {} value\n * @return {} Removed value\n */\n\nLRUProto.put = function (key, value) {\n  var list = this._list;\n  var map = this._map;\n  var removed = null;\n\n  if (map[key] == null) {\n    var len = list.len(); // Reuse last removed entry\n\n    var entry = this._lastRemovedEntry;\n\n    if (len >= this._maxSize && len > 0) {\n      // Remove the least recently used\n      var leastUsedEntry = list.head;\n      list.remove(leastUsedEntry);\n      delete map[leastUsedEntry.key];\n      removed = leastUsedEntry.value;\n      this._lastRemovedEntry = leastUsedEntry;\n    }\n\n    if (entry) {\n      entry.value = value;\n    } else {\n      entry = new Entry(value);\n    }\n\n    entry.key = key;\n    list.insertEntry(entry);\n    map[key] = entry;\n  }\n\n  return removed;\n};\n/**\n * @param  {string} key\n * @return {}\n */\n\n\nLRUProto.get = function (key) {\n  var entry = this._map[key];\n  var list = this._list;\n\n  if (entry != null) {\n    // Put the latest used entry in the tail\n    if (entry !== list.tail) {\n      list.remove(entry);\n      list.insertEntry(entry);\n    }\n\n    return entry.value;\n  }\n};\n/**\n * Clear the cache\n */\n\n\nLRUProto.clear = function () {\n  this._list.clear();\n\n  this._map = {};\n};\n\nvar _default = LRU;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/LRU.js\n// module id = 21\n// module chunks = 0","var _config = require(\"../config\");\n\nvar debugMode = _config.debugMode;\n\nvar log = function () {};\n\nif (debugMode === 1) {\n  log = function () {\n    for (var k in arguments) {\n      throw new Error(arguments[k]);\n    }\n  };\n} else if (debugMode > 1) {\n  log = function () {\n    for (var k in arguments) {\n      console.log(arguments[k]);\n    }\n  };\n}\n\nvar _default = log;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/log.js\n// module id = 22\n// module chunks = 0","var dpr = 1; // If in browser environment\n\nif (typeof window !== 'undefined') {\n  dpr = Math.max(window.devicePixelRatio || 1, 1);\n}\n/**\n * config默认配置项\n * @exports zrender/config\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n */\n\n/**\n * debug日志选项：catchBrushException为true下有效\n * 0 : 不生成debug数据，发布用\n * 1 : 异常抛出，调试用\n * 2 : 控制台输出，调试用\n */\n\n\nvar debugMode = 0; // retina 屏幕优化\n\nvar devicePixelRatio = dpr;\nexports.debugMode = debugMode;\nexports.devicePixelRatio = devicePixelRatio;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/config.js\n// module id = 23\n// module chunks = 0","var textHelper = require(\"../helper/text\");\n\nvar BoundingRect = require(\"../../core/BoundingRect\");\n\n/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\nvar tmpRect = new BoundingRect();\n\nvar RectText = function () {};\n\nRectText.prototype = {\n  constructor: RectText,\n\n  /**\n   * Draw text in a rect with specified position.\n   * @param  {CanvasRenderingContext2D} ctx\n   * @param  {Object} rect Displayable rect\n   */\n  drawRectText: function (ctx, rect) {\n    var style = this.style;\n    rect = style.textRect || rect; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true);\n    var text = style.text; // Convert to string\n\n    text != null && (text += '');\n\n    if (!textHelper.needDrawText(text, style)) {\n      return;\n    } // FIXME\n\n\n    ctx.save(); // Transform rect to view space\n\n    var transform = this.transform;\n\n    if (!style.transformText) {\n      if (transform) {\n        tmpRect.copy(rect);\n        tmpRect.applyTransform(transform);\n        rect = tmpRect;\n      }\n    } else {\n      this.setTransform(ctx);\n    } // transformText and textRotation can not be used at the same time.\n\n\n    textHelper.renderText(this, ctx, text, style, rect);\n    ctx.restore();\n  }\n};\nvar _default = RectText;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/mixin/RectText.js\n// module id = 24\n// module chunks = 0","var _util = require(\"../../core/util\");\n\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar each = _util.each;\nvar normalizeCssArray = _util.normalizeCssArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\n\nvar textContain = require(\"../../contain/text\");\n\nvar roundRectHelper = require(\"./roundRect\");\n\nvar imageHelper = require(\"./image\");\n\n// TODO: Have not support 'start', 'end' yet.\nvar VALID_TEXT_ALIGN = {\n  left: 1,\n  right: 1,\n  center: 1\n};\nvar VALID_TEXT_VERTICAL_ALIGN = {\n  top: 1,\n  bottom: 1,\n  middle: 1\n};\n/**\n * @param {module:zrender/graphic/Style} style\n * @return {module:zrender/graphic/Style} The input style.\n */\n\nfunction normalizeTextStyle(style) {\n  normalizeStyle(style);\n  each(style.rich, normalizeStyle);\n  return style;\n}\n\nfunction normalizeStyle(style) {\n  if (style) {\n    style.font = textContain.makeFont(style);\n    var textAlign = style.textAlign;\n    textAlign === 'middle' && (textAlign = 'center');\n    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.\n\n    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';\n    var textPadding = style.textPadding;\n\n    if (textPadding) {\n      style.textPadding = normalizeCssArray(style.textPadding);\n    }\n  }\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {string} text\n * @param {module:zrender/graphic/Style} style\n * @param {Object|boolean} [rect] {x, y, width, height}\n *                  If set false, rect text is not used.\n */\n\n\nfunction renderText(hostEl, ctx, text, style, rect) {\n  style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);\n}\n\nfunction renderPlainText(hostEl, ctx, text, style, rect) {\n  var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);\n  var textPadding = style.textPadding;\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirty) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, font, textPadding, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var textLines = contentBlock.lines;\n  var lineHeight = contentBlock.lineHeight;\n  var boxPos = getBoxPosition(outerHeight, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY;\n  var needDrawBg = needDrawBackground(style);\n\n  if (needDrawBg || textPadding) {\n    // Consider performance, do not call getTextWidth util necessary.\n    var textWidth = textContain.getWidth(text, font);\n    var outerWidth = textWidth;\n    textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n    if (textPadding) {\n      textX = getTextXForPadding(baseX, textAlign, textPadding);\n      textY += textPadding[0];\n    }\n  }\n\n  setCtx(ctx, 'textAlign', textAlign || 'left'); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle'); // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\n  setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0); // `textBaseline` is set as 'middle'.\n\n  textY += lineHeight / 2;\n  var textStrokeWidth = style.textStrokeWidth;\n  var textStroke = getStroke(style.textStroke, textStrokeWidth);\n  var textFill = getFill(style.textFill);\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n  }\n\n  for (var i = 0; i < textLines.length; i++) {\n    // Fill after stroke so the outline will not cover the main part.\n    textStroke && ctx.strokeText(textLines[i], textX, textY);\n    textFill && ctx.fillText(textLines[i], textX, textY);\n    textY += lineHeight;\n  }\n}\n\nfunction renderRichText(hostEl, ctx, text, style, rect) {\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirty) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n  }\n\n  drawRichText(hostEl, ctx, contentBlock, style, rect);\n}\n\nfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n  var contentWidth = contentBlock.width;\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var textPadding = style.textPadding;\n  var boxPos = getBoxPosition(outerHeight, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var xLeft = boxX;\n  var lineTop = boxY;\n\n  if (textPadding) {\n    xLeft += textPadding[3];\n    lineTop += textPadding[0];\n  }\n\n  var xRight = xLeft + contentWidth;\n  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n  for (var i = 0; i < contentBlock.lines.length; i++) {\n    var line = contentBlock.lines[i];\n    var tokens = line.tokens;\n    var tokenCount = tokens.length;\n    var lineHeight = line.lineHeight;\n    var usedWidth = line.width;\n    var leftIndex = 0;\n    var lineXLeft = xLeft;\n    var lineXRight = xRight;\n    var rightIndex = tokenCount - 1;\n    var token;\n\n    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n      usedWidth -= token.width;\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n      usedWidth -= token.width;\n      lineXRight -= token.width;\n      rightIndex--;\n    } // The other tokens are placed as textAlign 'center' if there is enough space.\n\n\n    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n\n    while (leftIndex <= rightIndex) {\n      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.\n\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    lineTop += lineHeight;\n  }\n}\n\nfunction applyTextRotation(ctx, style, rect, x, y) {\n  // textRotation only apply in RectText.\n  if (rect && style.textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      x = rect.width / 2 + rect.x;\n      y = rect.height / 2 + rect.y;\n    } else if (origin) {\n      x = origin[0] + rect.x;\n      y = origin[1] + rect.y;\n    }\n\n    ctx.translate(x, y); // Positive: anticlockwise\n\n    ctx.rotate(-style.textRotation);\n    ctx.translate(-x, -y);\n  }\n}\n\nfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n  var tokenStyle = style.rich[token.styleName] || {}; // 'ctx.textBaseline' is always set as 'middle', for sake of\n  // the bias of \"Microsoft YaHei\".\n\n  var textVerticalAlign = token.textVerticalAlign;\n  var y = lineTop + lineHeight / 2;\n\n  if (textVerticalAlign === 'top') {\n    y = lineTop + token.height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y = lineTop + lineHeight - token.height / 2;\n  }\n\n  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);\n  var textPadding = token.textPadding;\n\n  if (textPadding) {\n    x = getTextXForPadding(x, textAlign, textPadding);\n    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n  }\n\n  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle');\n  setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);\n  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n  var textFill = getFill(tokenStyle.textFill || style.textFill);\n  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n    ctx.strokeText(token.text, x, y);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n    ctx.fillText(token.text, x, y);\n  }\n}\n\nfunction needDrawBackground(style) {\n  return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;\n} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}\n// shape: {x, y, width, height}\n\n\nfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n  var textBackgroundColor = style.textBackgroundColor;\n  var textBorderWidth = style.textBorderWidth;\n  var textBorderColor = style.textBorderColor;\n  var isPlainBg = isString(textBackgroundColor);\n  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\n  if (isPlainBg || textBorderWidth && textBorderColor) {\n    ctx.beginPath();\n    var textBorderRadius = style.textBorderRadius;\n\n    if (!textBorderRadius) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        r: textBorderRadius\n      });\n    }\n\n    ctx.closePath();\n  }\n\n  if (isPlainBg) {\n    setCtx(ctx, 'fillStyle', textBackgroundColor);\n    ctx.fill();\n  } else if (isObject(textBackgroundColor)) {\n    var image = textBackgroundColor.image;\n    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);\n\n    if (image && imageHelper.isImageReady(image)) {\n      ctx.drawImage(image, x, y, width, height);\n    }\n  }\n\n  if (textBorderWidth && textBorderColor) {\n    setCtx(ctx, 'lineWidth', textBorderWidth);\n    setCtx(ctx, 'strokeStyle', textBorderColor);\n    ctx.stroke();\n  }\n}\n\nfunction onBgImageLoaded(image, textBackgroundColor) {\n  // Replace image, so that `contain/text.js#parseRichText`\n  // will get correct result in next tick.\n  textBackgroundColor.image = image;\n}\n\nfunction getBoxPosition(blockHeiht, style, rect) {\n  var baseX = style.x || 0;\n  var baseY = style.y || 0;\n  var textAlign = style.textAlign;\n  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord\n\n  if (rect) {\n    var textPosition = style.textPosition;\n\n    if (textPosition instanceof Array) {\n      // Percent\n      baseX = rect.x + parsePercent(textPosition[0], rect.width);\n      baseY = rect.y + parsePercent(textPosition[1], rect.height);\n    } else {\n      var res = textContain.adjustTextPositionOnRect(textPosition, rect, style.textDistance);\n      baseX = res.x;\n      baseY = res.y; // Default align and baseline when has textPosition\n\n      textAlign = textAlign || res.textAlign;\n      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n    } // textOffset is only support in RectText, otherwise\n    // we have to adjust boundingRect for textOffset.\n\n\n    var textOffset = style.textOffset;\n\n    if (textOffset) {\n      baseX += textOffset[0];\n      baseY += textOffset[1];\n    }\n  }\n\n  return {\n    baseX: baseX,\n    baseY: baseY,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction setCtx(ctx, prop, value) {\n  // FIXME ??? performance try\n  // if (ctx.__currentValues[prop] !== value) {\n  // ctx[prop] = ctx.__currentValues[prop] = value;\n  ctx[prop] = value; // }\n\n  return ctx[prop];\n}\n/**\n * @param {string} [stroke] If specified, do not check style.textStroke.\n * @param {string} [lineWidth] If specified, do not check style.textStroke.\n * @param {number} style\n */\n\n\nfunction getStroke(stroke, lineWidth) {\n  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?\n  : stroke.image || stroke.colorStops ? '#000' : stroke;\n}\n\nfunction getFill(fill) {\n  return fill == null || fill === 'none' ? null // TODO pattern and gradient?\n  : fill.image || fill.colorStops ? '#000' : fill;\n}\n\nfunction parsePercent(value, maxValue) {\n  if (typeof value === 'string') {\n    if (value.lastIndexOf('%') >= 0) {\n      return parseFloat(value) / 100 * maxValue;\n    }\n\n    return parseFloat(value);\n  }\n\n  return value;\n}\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n/**\n * @param {string} text\n * @param {module:zrender/Style} style\n * @return {boolean}\n */\n\n\nfunction needDrawText(text, style) {\n  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);\n}\n\nexports.normalizeTextStyle = normalizeTextStyle;\nexports.renderText = renderText;\nexports.getStroke = getStroke;\nexports.getFill = getFill;\nexports.needDrawText = needDrawText;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/text.js\n// module id = 25\n// module chunks = 0","var BoundingRect = require(\"../core/BoundingRect\");\n\nvar imageHelper = require(\"../graphic/helper/image\");\n\nvar _util = require(\"../core/util\");\n\nvar getContext = _util.getContext;\nvar extend = _util.extend;\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar textWidthCache = {};\nvar textWidthCacheCounter = 0;\nvar TEXT_CACHE_MAX = 5000;\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {number} width\n */\n\n\nfunction getWidth(text, font) {\n  font = font || DEFAULT_FONT;\n  var key = text + ':' + font;\n\n  if (textWidthCache[key]) {\n    return textWidthCache[key];\n  }\n\n  var textLines = (text + '').split('\\n');\n  var width = 0;\n\n  for (var i = 0, l = textLines.length; i < l; i++) {\n    // textContain.measureText may be overrided in SVG or VML\n    width = Math.max(measureText(textLines[i], font).width, width);\n  }\n\n  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n    textWidthCacheCounter = 0;\n    textWidthCache = {};\n  }\n\n  textWidthCacheCounter++;\n  textWidthCache[key] = width;\n  return width;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {string} [textAlign='left']\n * @param {string} [textVerticalAlign='top']\n * @param {Array.<number>} [textPadding]\n * @param {Object} [rich]\n * @param {Object} [truncate]\n * @return {Object} {x, y, width, height, lineHeight}\n */\n\n\nfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);\n}\n\nfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {\n  var contentBlock = parsePlainText(text, font, textPadding, truncate);\n  var outerWidth = getWidth(text, font);\n\n  if (textPadding) {\n    outerWidth += textPadding[1] + textPadding[3];\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n  rect.lineHeight = contentBlock.lineHeight;\n  return rect;\n}\n\nfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n  var contentBlock = parseRichText(text, {\n    rich: rich,\n    truncate: truncate,\n    font: font,\n    textAlign: textAlign,\n    textPadding: textPadding\n  });\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  return new BoundingRect(x, y, outerWidth, outerHeight);\n}\n/**\n * @public\n * @param {number} x\n * @param {number} width\n * @param {string} [textAlign='left']\n * @return {number} Adjusted x.\n */\n\n\nfunction adjustTextX(x, width, textAlign) {\n  // FIXME Right to left language\n  if (textAlign === 'right') {\n    x -= width;\n  } else if (textAlign === 'center') {\n    x -= width / 2;\n  }\n\n  return x;\n}\n/**\n * @public\n * @param {number} y\n * @param {number} height\n * @param {string} [textVerticalAlign='top']\n * @return {number} Adjusted y.\n */\n\n\nfunction adjustTextY(y, height, textVerticalAlign) {\n  if (textVerticalAlign === 'middle') {\n    y -= height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y -= height;\n  }\n\n  return y;\n}\n/**\n * @public\n * @param {stirng} textPosition\n * @param {Object} rect {x, y, width, height}\n * @param {number} distance\n * @return {Object} {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n  var x = rect.x;\n  var y = rect.y;\n  var height = rect.height;\n  var width = rect.width;\n  var halfHeight = height / 2;\n  var textAlign = 'left';\n  var textVerticalAlign = 'top';\n\n  switch (textPosition) {\n    case 'left':\n      x -= distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'right':\n      x += distance + width;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'top':\n      x += width / 2;\n      y -= distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'bottom':\n      x += width / 2;\n      y += height + distance;\n      textAlign = 'center';\n      break;\n\n    case 'inside':\n      x += width / 2;\n      y += halfHeight;\n      textAlign = 'center';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideLeft':\n      x += distance;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideRight':\n      x += width - distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideTop':\n      x += width / 2;\n      y += distance;\n      textAlign = 'center';\n      break;\n\n    case 'insideBottom':\n      x += width / 2;\n      y += height - distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideTopLeft':\n      x += distance;\n      y += distance;\n      break;\n\n    case 'insideTopRight':\n      x += width - distance;\n      y += distance;\n      textAlign = 'right';\n      break;\n\n    case 'insideBottomLeft':\n      x += distance;\n      y += height - distance;\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideBottomRight':\n      x += width - distance;\n      y += height - distance;\n      textAlign = 'right';\n      textVerticalAlign = 'bottom';\n      break;\n  }\n\n  return {\n    x: x,\n    y: y,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n/**\n * Show ellipsis if overflow.\n *\n * @public\n * @param  {string} text\n * @param  {string} containerWidth\n * @param  {string} font\n * @param  {number} [ellipsis='...']\n * @param  {Object} [options]\n * @param  {number} [options.maxIterations=3]\n * @param  {number} [options.minChar=0] If truncate result are less\n *                  then minChar, ellipsis will not show, which is\n *                  better for user hint in some cases.\n * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n * @return {string}\n */\n\n\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    return '';\n  }\n\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n  // It is not appropriate that every line has '...' when truncate multiple lines.\n\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    textLines[i] = truncateSingleLine(textLines[i], options);\n  }\n\n  return textLines.join('\\n');\n}\n\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = extend({}, options);\n  options.font = font;\n  var ellipsis = retrieve2(ellipsis, '...');\n  options.maxIterations = retrieve2(options.maxIterations, 2);\n  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n  // Other languages?\n\n  options.cnCharWidth = getWidth('国', font); // FIXME\n  // Consider proportional font?\n\n  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\n  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n\n  var ellipsisWidth = getWidth(ellipsis);\n\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n\n  contentWidth = containerWidth - ellipsisWidth;\n  options.ellipsis = ellipsis;\n  options.ellipsisWidth = ellipsisWidth;\n  options.contentWidth = contentWidth;\n  options.containerWidth = containerWidth;\n  return options;\n}\n\nfunction truncateSingleLine(textLine, options) {\n  var containerWidth = options.containerWidth;\n  var font = options.font;\n  var contentWidth = options.contentWidth;\n\n  if (!containerWidth) {\n    return '';\n  }\n\n  var lineWidth = getWidth(textLine, font);\n\n  if (lineWidth <= containerWidth) {\n    return textLine;\n  }\n\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = getWidth(textLine, font);\n  }\n\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n\n  return textLine;\n}\n\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n  var width = 0;\n  var i = 0;\n\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    var charCode = text.charCodeAt(i);\n    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n  }\n\n  return i;\n}\n/**\n * @public\n * @param {string} font\n * @return {number} line height\n */\n\n\nfunction getLineHeight(font) {\n  // FIXME A rough approach.\n  return getWidth('国', font);\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {Object} width\n */\n\n\nfunction measureText(text, font) {\n  return methods.measureText(text, font);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nmethods.measureText = function (text, font) {\n  var ctx = getContext();\n  ctx.font = font || DEFAULT_FONT;\n  return ctx.measureText(text);\n};\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {Object} [truncate]\n * @return {Object} block: {lineHeight, lines, height, outerHeight}\n *  Notice: for performance, do not calculate outerWidth util needed.\n */\n\n\nfunction parsePlainText(text, font, padding, truncate) {\n  text != null && (text += '');\n  var lineHeight = getLineHeight(font);\n  var lines = text ? text.split('\\n') : [];\n  var height = lines.length * lineHeight;\n  var outerHeight = height;\n\n  if (padding) {\n    outerHeight += padding[0] + padding[2];\n  }\n\n  if (text && truncate) {\n    var truncOuterHeight = truncate.outerHeight;\n    var truncOuterWidth = truncate.outerWidth;\n\n    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n      text = '';\n      lines = [];\n    } else if (truncOuterWidth != null) {\n      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n        minChar: truncate.minChar,\n        placeholder: truncate.placeholder\n      }); // FIXME\n      // It is not appropriate that every line has '...' when truncate multiple lines.\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        lines[i] = truncateSingleLine(lines[i], options);\n      }\n    }\n  }\n\n  return {\n    lines: lines,\n    height: height,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight\n  };\n}\n/**\n * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n *\n * @public\n * @param {string} text\n * @param {Object} style\n * @return {Object} block\n * {\n *      width,\n *      height,\n *      lines: [{\n *          lineHeight,\n *          width,\n *          tokens: [[{\n *              styleName,\n *              text,\n *              width,      // include textPadding\n *              height,     // include textPadding\n *              textWidth, // pure text width\n *              textHeight, // pure text height\n *              lineHeihgt,\n *              font,\n *              textAlign,\n *              textVerticalAlign\n *          }], [...], ...]\n *      }, ...]\n * }\n * If styleName is undefined, it is plain text.\n */\n\n\nfunction parseRichText(text, style) {\n  var contentBlock = {\n    lines: [],\n    width: 0,\n    height: 0\n  };\n  text != null && (text += '');\n\n  if (!text) {\n    return contentBlock;\n  }\n\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n    }\n\n    pushTokens(contentBlock, result[2], result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n  }\n\n  var lines = contentBlock.lines;\n  var contentHeight = 0;\n  var contentWidth = 0; // For `textWidth: 100%`\n\n  var pendingList = [];\n  var stlPadding = style.textPadding;\n  var truncate = style.truncate;\n  var truncateWidth = truncate && truncate.outerWidth;\n  var truncateHeight = truncate && truncate.outerHeight;\n\n  if (stlPadding) {\n    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n  } // Calculate layout info of tokens.\n\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\n      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\n      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\n      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n      // as box height of the block.\n      tokenStyle.textHeight, getLineHeight(font));\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n        return {\n          lines: [],\n          width: 0,\n          height: 0\n        };\n      }\n\n      token.textWidth = getWidth(token.text, font);\n      var tokenWidth = tokenStyle.textWidth;\n      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n      // line when box width is needed to be auto.\n\n      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n        token.percentWidth = tokenWidth;\n        pendingList.push(token);\n        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n        // and it is too complicated.\n      } else {\n        if (tokenWidthNotSpecified) {\n          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n          // `getBoundingRect()` will not get correct result.\n\n          var textBackgroundColor = tokenStyle.textBackgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n          // (1) If image is not loaded, it will be loaded at render phase and call\n          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n          // image, and then the right size will be calculated here at the next tick.\n          // See `graphic/helper/text.js`.\n          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n          // use `imageHelper.findExistImage` to find cached image.\n          // `imageHelper.findExistImage` will always be called here before\n          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n          // which ensures that image will not be rendered before correct size calcualted.\n\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n\n            if (imageHelper.isImageReady(bgImg)) {\n              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n\n        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n        tokenWidth += paddingW;\n        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n            token.text = '';\n            token.textWidth = tokenWidth = 0;\n          } else {\n            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n              minChar: truncate.minChar\n            });\n            token.textWidth = getWidth(token.text, font);\n            tokenWidth = token.textWidth + paddingW;\n          }\n        }\n      }\n\n      lineWidth += token.width = tokenWidth;\n      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n    }\n\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    contentHeight += lineHeight;\n    contentWidth = Math.max(contentWidth, lineWidth);\n  }\n\n  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n  if (stlPadding) {\n    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n  }\n\n  for (var i = 0; i < pendingList.length; i++) {\n    var token = pendingList[i];\n    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\n    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n  }\n\n  return contentBlock;\n}\n\nfunction pushTokens(block, str, styleName) {\n  var isEmptyStr = str === '';\n  var strs = str.split('\\n');\n  var lines = block.lines;\n\n  for (var i = 0; i < strs.length; i++) {\n    var text = strs[i];\n    var token = {\n      styleName: styleName,\n      text: text,\n      isLineHolder: !text && !isEmptyStr\n    }; // The first token should be appended to the last line.\n\n    if (!i) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = {\n        tokens: []\n      })).tokens; // Consider cases:\n      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n      // (which is a placeholder) should be replaced by new token.\n      // (2) A image backage, where token likes {a|}.\n      // (3) A redundant '' will affect textAlign in line.\n      // (4) tokens with the same tplName should not be merged, because\n      // they should be displayed in different box (with border and padding).\n\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } // Other tokens always start a new line.\n    else {\n        // If there is '', insert it as a placeholder.\n        lines.push({\n          tokens: [token]\n        });\n      }\n  }\n}\n\nfunction makeFont(style) {\n  // FIXME in node-canvas fontWeight is before fontStyle\n  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n  return (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n  style.fontFamily || 'sans-serif'].join(' ') || style.textFont || style.font;\n}\n\nexports.DEFAULT_FONT = DEFAULT_FONT;\nexports.$override = $override;\nexports.getWidth = getWidth;\nexports.getBoundingRect = getBoundingRect;\nexports.adjustTextX = adjustTextX;\nexports.adjustTextY = adjustTextY;\nexports.adjustTextPositionOnRect = adjustTextPositionOnRect;\nexports.truncateText = truncateText;\nexports.getLineHeight = getLineHeight;\nexports.measureText = measureText;\nexports.parsePlainText = parsePlainText;\nexports.parseRichText = parseRichText;\nexports.makeFont = makeFont;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/text.js\n// module id = 26\n// module chunks = 0","var vec2 = require(\"./vector\");\n\nvar matrix = require(\"./matrix\");\n\n/**\n * @module echarts/core/BoundingRect\n */\nvar v2ApplyTransform = vec2.applyTransform;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\n/**\n * @alias module:echarts/core/BoundingRect\n */\n\nfunction BoundingRect(x, y, width, height) {\n  if (width < 0) {\n    x = x + width;\n    width = -width;\n  }\n\n  if (height < 0) {\n    y = y + height;\n    height = -height;\n  }\n  /**\n   * @type {number}\n   */\n\n\n  this.x = x;\n  /**\n   * @type {number}\n   */\n\n  this.y = y;\n  /**\n   * @type {number}\n   */\n\n  this.width = width;\n  /**\n   * @type {number}\n   */\n\n  this.height = height;\n}\n\nBoundingRect.prototype = {\n  constructor: BoundingRect,\n\n  /**\n   * @param {module:echarts/core/BoundingRect} other\n   */\n  union: function (other) {\n    var x = mathMin(other.x, this.x);\n    var y = mathMin(other.y, this.y);\n    this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n    this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n    this.x = x;\n    this.y = y;\n  },\n\n  /**\n   * @param {Array.<number>} m\n   * @methods\n   */\n  applyTransform: function () {\n    var lt = [];\n    var rb = [];\n    var lb = [];\n    var rt = [];\n    return function (m) {\n      // In case usage like this\n      // el.getBoundingRect().applyTransform(el.transform)\n      // And element has no transform\n      if (!m) {\n        return;\n      }\n\n      lt[0] = lb[0] = this.x;\n      lt[1] = rt[1] = this.y;\n      rb[0] = rt[0] = this.x + this.width;\n      rb[1] = lb[1] = this.y + this.height;\n      v2ApplyTransform(lt, lt, m);\n      v2ApplyTransform(rb, rb, m);\n      v2ApplyTransform(lb, lb, m);\n      v2ApplyTransform(rt, rt, m);\n      this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n      this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n      var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n      var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n      this.width = maxX - this.x;\n      this.height = maxY - this.y;\n    };\n  }(),\n\n  /**\n   * Calculate matrix of transforming from self to target rect\n   * @param  {module:zrender/core/BoundingRect} b\n   * @return {Array.<number>}\n   */\n  calculateTransform: function (b) {\n    var a = this;\n    var sx = b.width / a.width;\n    var sy = b.height / a.height;\n    var m = matrix.create(); // 矩阵右乘\n\n    matrix.translate(m, m, [-a.x, -a.y]);\n    matrix.scale(m, m, [sx, sy]);\n    matrix.translate(m, m, [b.x, b.y]);\n    return m;\n  },\n\n  /**\n   * @param {(module:echarts/core/BoundingRect|Object)} b\n   * @return {boolean}\n   */\n  intersect: function (b) {\n    if (!b) {\n      return false;\n    }\n\n    if (!(b instanceof BoundingRect)) {\n      // Normalize negative width/height.\n      b = BoundingRect.create(b);\n    }\n\n    var a = this;\n    var ax0 = a.x;\n    var ax1 = a.x + a.width;\n    var ay0 = a.y;\n    var ay1 = a.y + a.height;\n    var bx0 = b.x;\n    var bx1 = b.x + b.width;\n    var by0 = b.y;\n    var by1 = b.y + b.height;\n    return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n  },\n  contain: function (x, y) {\n    var rect = this;\n    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n  },\n\n  /**\n   * @return {module:echarts/core/BoundingRect}\n   */\n  clone: function () {\n    return new BoundingRect(this.x, this.y, this.width, this.height);\n  },\n\n  /**\n   * Copy from another rect\n   */\n  copy: function (other) {\n    this.x = other.x;\n    this.y = other.y;\n    this.width = other.width;\n    this.height = other.height;\n  },\n  plain: function () {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height\n    };\n  }\n};\n/**\n * @param {Object|module:zrender/core/BoundingRect} rect\n * @param {number} rect.x\n * @param {number} rect.y\n * @param {number} rect.width\n * @param {number} rect.height\n * @return {module:zrender/core/BoundingRect}\n */\n\nBoundingRect.create = function (rect) {\n  return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n};\n\nvar _default = BoundingRect;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/BoundingRect.js\n// module id = 27\n// module chunks = 0","var LRU = require(\"../../core/LRU\");\n\nvar globalImageCache = new LRU(50);\n/**\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n */\n\nfunction findExistImage(newImageOrSrc) {\n  if (typeof newImageOrSrc === 'string') {\n    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n    return cachedImgObj && cachedImgObj.image;\n  } else {\n    return newImageOrSrc;\n  }\n}\n/**\n * Caution: User should cache loaded images, but not just count on LRU.\n * Consider if required images more than LRU size, will dead loop occur?\n *\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.\n * @param {module:zrender/Element} [hostEl] For calling `dirty`.\n * @param {Function} [cb] params: (image, cbPayload)\n * @param {Object} [cbPayload] Payload on cb calling.\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n */\n\n\nfunction createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {\n  if (!newImageOrSrc) {\n    return image;\n  } else if (typeof newImageOrSrc === 'string') {\n    // Image should not be loaded repeatly.\n    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {\n      return image;\n    } // Only when there is no existent image or existent image src\n    // is different, this method is responsible for load.\n\n\n    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n    var pendingWrap = {\n      hostEl: hostEl,\n      cb: cb,\n      cbPayload: cbPayload\n    };\n\n    if (cachedImgObj) {\n      image = cachedImgObj.image;\n      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);\n    } else {\n      !image && (image = new Image());\n      image.onload = imageOnLoad;\n      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {\n        image: image,\n        pending: [pendingWrap]\n      });\n      image.src = image.__zrImageSrc = newImageOrSrc;\n    }\n\n    return image;\n  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas\n  else {\n      return newImageOrSrc;\n    }\n}\n\nfunction imageOnLoad() {\n  var cachedImgObj = this.__cachedImgObj;\n  this.onload = this.__cachedImgObj = null;\n\n  for (var i = 0; i < cachedImgObj.pending.length; i++) {\n    var pendingWrap = cachedImgObj.pending[i];\n    var cb = pendingWrap.cb;\n    cb && cb(this, pendingWrap.cbPayload);\n    pendingWrap.hostEl.dirty();\n  }\n\n  cachedImgObj.pending.length = 0;\n}\n\nfunction isImageReady(image) {\n  return image && image.width && image.height;\n}\n\nexports.findExistImage = findExistImage;\nexports.createOrUpdateImage = createOrUpdateImage;\nexports.isImageReady = isImageReady;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/image.js\n// module id = 28\n// module chunks = 0","function buildPath(ctx, shape) {\n  var x = shape.x;\n  var y = shape.y;\n  var width = shape.width;\n  var height = shape.height;\n  var r = shape.r;\n  var r1;\n  var r2;\n  var r3;\n  var r4; // Convert width and height to positive for better borderRadius\n\n  if (width < 0) {\n    x = x + width;\n    width = -width;\n  }\n\n  if (height < 0) {\n    y = y + height;\n    height = -height;\n  }\n\n  if (typeof r === 'number') {\n    r1 = r2 = r3 = r4 = r;\n  } else if (r instanceof Array) {\n    if (r.length === 1) {\n      r1 = r2 = r3 = r4 = r[0];\n    } else if (r.length === 2) {\n      r1 = r3 = r[0];\n      r2 = r4 = r[1];\n    } else if (r.length === 3) {\n      r1 = r[0];\n      r2 = r4 = r[1];\n      r3 = r[2];\n    } else {\n      r1 = r[0];\n      r2 = r[1];\n      r3 = r[2];\n      r4 = r[3];\n    }\n  } else {\n    r1 = r2 = r3 = r4 = 0;\n  }\n\n  var total;\n\n  if (r1 + r2 > width) {\n    total = r1 + r2;\n    r1 *= width / total;\n    r2 *= width / total;\n  }\n\n  if (r3 + r4 > width) {\n    total = r3 + r4;\n    r3 *= width / total;\n    r4 *= width / total;\n  }\n\n  if (r2 + r3 > height) {\n    total = r2 + r3;\n    r2 *= height / total;\n    r3 *= height / total;\n  }\n\n  if (r1 + r4 > height) {\n    total = r1 + r4;\n    r1 *= height / total;\n    r4 *= height / total;\n  }\n\n  ctx.moveTo(x + r1, y);\n  ctx.lineTo(x + width - r2, y);\n  r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);\n  ctx.lineTo(x + width, y + height - r3);\n  r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);\n  ctx.lineTo(x + r4, y + height);\n  r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);\n  ctx.lineTo(x, y + r1);\n  r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n}\n\nexports.buildPath = buildPath;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/roundRect.js\n// module id = 29\n// module chunks = 0","var curve = require(\"./curve\");\n\nvar vec2 = require(\"./vector\");\n\nvar bbox = require(\"./bbox\");\n\nvar BoundingRect = require(\"./BoundingRect\");\n\nvar _config = require(\"../config\");\n\nvar dpr = _config.devicePixelRatio;\n\n/**\n * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n * 可以用于 isInsidePath 判断以及获取boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n// TODO getTotalLength, getPointAtLength\nvar CMD = {\n  M: 1,\n  L: 2,\n  C: 3,\n  Q: 4,\n  A: 5,\n  Z: 6,\n  // Rect\n  R: 7\n}; // var CMD_MEM_SIZE = {\n//     M: 3,\n//     L: 3,\n//     C: 7,\n//     Q: 5,\n//     A: 9,\n//     R: 5,\n//     Z: 1\n// };\n\nvar min = [];\nvar max = [];\nvar min2 = [];\nvar max2 = [];\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathCos = Math.cos;\nvar mathSin = Math.sin;\nvar mathSqrt = Math.sqrt;\nvar mathAbs = Math.abs;\nvar hasTypedArray = typeof Float32Array != 'undefined';\n/**\n * @alias module:zrender/core/PathProxy\n * @constructor\n */\n\nvar PathProxy = function (notSaveData) {\n  this._saveData = !(notSaveData || false);\n\n  if (this._saveData) {\n    /**\n     * Path data. Stored as flat array\n     * @type {Array.<Object>}\n     */\n    this.data = [];\n  }\n\n  this._ctx = null;\n};\n/**\n * 快速计算Path包围盒（并不是最小包围盒）\n * @return {Object}\n */\n\n\nPathProxy.prototype = {\n  constructor: PathProxy,\n  _xi: 0,\n  _yi: 0,\n  _x0: 0,\n  _y0: 0,\n  // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n  _ux: 0,\n  _uy: 0,\n  _len: 0,\n  _lineDash: null,\n  _dashOffset: 0,\n  _dashIdx: 0,\n  _dashSum: 0,\n\n  /**\n   * @readOnly\n   */\n  setScale: function (sx, sy) {\n    this._ux = mathAbs(1 / dpr / sx) || 0;\n    this._uy = mathAbs(1 / dpr / sy) || 0;\n  },\n  getContext: function () {\n    return this._ctx;\n  },\n\n  /**\n   * @param  {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  beginPath: function (ctx) {\n    this._ctx = ctx;\n    ctx && ctx.beginPath();\n    ctx && (this.dpr = ctx.dpr); // Reset\n\n    if (this._saveData) {\n      this._len = 0;\n    }\n\n    if (this._lineDash) {\n      this._lineDash = null;\n      this._dashOffset = 0;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param  {number} x\n   * @param  {number} y\n   * @return {module:zrender/core/PathProxy}\n   */\n  moveTo: function (x, y) {\n    this.addData(CMD.M, x, y);\n    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n    // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n    // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n    // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n\n    this._x0 = x;\n    this._y0 = y;\n    this._xi = x;\n    this._yi = y;\n    return this;\n  },\n\n  /**\n   * @param  {number} x\n   * @param  {number} y\n   * @return {module:zrender/core/PathProxy}\n   */\n  lineTo: function (x, y) {\n    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment\n    || this._len < 5;\n    this.addData(CMD.L, x, y);\n\n    if (this._ctx && exceedUnit) {\n      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n    }\n\n    if (exceedUnit) {\n      this._xi = x;\n      this._yi = y;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param  {number} x1\n   * @param  {number} y1\n   * @param  {number} x2\n   * @param  {number} y2\n   * @param  {number} x3\n   * @param  {number} y3\n   * @return {module:zrender/core/PathProxy}\n   */\n  bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\n    if (this._ctx) {\n      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n    }\n\n    this._xi = x3;\n    this._yi = y3;\n    return this;\n  },\n\n  /**\n   * @param  {number} x1\n   * @param  {number} y1\n   * @param  {number} x2\n   * @param  {number} y2\n   * @return {module:zrender/core/PathProxy}\n   */\n  quadraticCurveTo: function (x1, y1, x2, y2) {\n    this.addData(CMD.Q, x1, y1, x2, y2);\n\n    if (this._ctx) {\n      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n    }\n\n    this._xi = x2;\n    this._yi = y2;\n    return this;\n  },\n\n  /**\n   * @param  {number} cx\n   * @param  {number} cy\n   * @param  {number} r\n   * @param  {number} startAngle\n   * @param  {number} endAngle\n   * @param  {boolean} anticlockwise\n   * @return {module:zrender/core/PathProxy}\n   */\n  arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);\n    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n    this._xi = mathCos(endAngle) * r + cx;\n    this._yi = mathSin(endAngle) * r + cx;\n    return this;\n  },\n  // TODO\n  arcTo: function (x1, y1, x2, y2, radius) {\n    if (this._ctx) {\n      this._ctx.arcTo(x1, y1, x2, y2, radius);\n    }\n\n    return this;\n  },\n  // TODO\n  rect: function (x, y, w, h) {\n    this._ctx && this._ctx.rect(x, y, w, h);\n    this.addData(CMD.R, x, y, w, h);\n    return this;\n  },\n\n  /**\n   * @return {module:zrender/core/PathProxy}\n   */\n  closePath: function () {\n    this.addData(CMD.Z);\n    var ctx = this._ctx;\n    var x0 = this._x0;\n    var y0 = this._y0;\n\n    if (ctx) {\n      this._needsDash() && this._dashedLineTo(x0, y0);\n      ctx.closePath();\n    }\n\n    this._xi = x0;\n    this._yi = y0;\n    return this;\n  },\n\n  /**\n   * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n   * stroke 同样\n   * @param {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  fill: function (ctx) {\n    ctx && ctx.fill();\n    this.toStatic();\n  },\n\n  /**\n   * @param {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  stroke: function (ctx) {\n    ctx && ctx.stroke();\n    this.toStatic();\n  },\n\n  /**\n   * 必须在其它绘制命令前调用\n   * Must be invoked before all other path drawing methods\n   * @return {module:zrender/core/PathProxy}\n   */\n  setLineDash: function (lineDash) {\n    if (lineDash instanceof Array) {\n      this._lineDash = lineDash;\n      this._dashIdx = 0;\n      var lineDashSum = 0;\n\n      for (var i = 0; i < lineDash.length; i++) {\n        lineDashSum += lineDash[i];\n      }\n\n      this._dashSum = lineDashSum;\n    }\n\n    return this;\n  },\n\n  /**\n   * 必须在其它绘制命令前调用\n   * Must be invoked before all other path drawing methods\n   * @return {module:zrender/core/PathProxy}\n   */\n  setLineDashOffset: function (offset) {\n    this._dashOffset = offset;\n    return this;\n  },\n\n  /**\n   *\n   * @return {boolean}\n   */\n  len: function () {\n    return this._len;\n  },\n\n  /**\n   * 直接设置 Path 数据\n   */\n  setData: function (data) {\n    var len = data.length;\n\n    if (!(this.data && this.data.length == len) && hasTypedArray) {\n      this.data = new Float32Array(len);\n    }\n\n    for (var i = 0; i < len; i++) {\n      this.data[i] = data[i];\n    }\n\n    this._len = len;\n  },\n\n  /**\n   * 添加子路径\n   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n   */\n  appendPath: function (path) {\n    if (!(path instanceof Array)) {\n      path = [path];\n    }\n\n    var len = path.length;\n    var appendSize = 0;\n    var offset = this._len;\n\n    for (var i = 0; i < len; i++) {\n      appendSize += path[i].len();\n    }\n\n    if (hasTypedArray && this.data instanceof Float32Array) {\n      this.data = new Float32Array(offset + appendSize);\n    }\n\n    for (var i = 0; i < len; i++) {\n      var appendPathData = path[i].data;\n\n      for (var k = 0; k < appendPathData.length; k++) {\n        this.data[offset++] = appendPathData[k];\n      }\n    }\n\n    this._len = offset;\n  },\n\n  /**\n   * 填充 Path 数据。\n   * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n   */\n  addData: function (cmd) {\n    if (!this._saveData) {\n      return;\n    }\n\n    var data = this.data;\n\n    if (this._len + arguments.length > data.length) {\n      // 因为之前的数组已经转换成静态的 Float32Array\n      // 所以不够用时需要扩展一个新的动态数组\n      this._expandData();\n\n      data = this.data;\n    }\n\n    for (var i = 0; i < arguments.length; i++) {\n      data[this._len++] = arguments[i];\n    }\n\n    this._prevCmd = cmd;\n  },\n  _expandData: function () {\n    // Only if data is Float32Array\n    if (!(this.data instanceof Array)) {\n      var newData = [];\n\n      for (var i = 0; i < this._len; i++) {\n        newData[i] = this.data[i];\n      }\n\n      this.data = newData;\n    }\n  },\n\n  /**\n   * If needs js implemented dashed line\n   * @return {boolean}\n   * @private\n   */\n  _needsDash: function () {\n    return this._lineDash;\n  },\n  _dashedLineTo: function (x1, y1) {\n    var dashSum = this._dashSum;\n    var offset = this._dashOffset;\n    var lineDash = this._lineDash;\n    var ctx = this._ctx;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n    var dist = mathSqrt(dx * dx + dy * dy);\n    var x = x0;\n    var y = y0;\n    var dash;\n    var nDash = lineDash.length;\n    var idx;\n    dx /= dist;\n    dy /= dist;\n\n    if (offset < 0) {\n      // Convert to positive offset\n      offset = dashSum + offset;\n    }\n\n    offset %= dashSum;\n    x -= offset * dx;\n    y -= offset * dy;\n\n    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n      idx = this._dashIdx;\n      dash = lineDash[idx];\n      x += dx * dash;\n      y += dy * dash;\n      this._dashIdx = (idx + 1) % nDash; // Skip positive offset\n\n      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n        continue;\n      }\n\n      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n    } // Offset for next lineTo\n\n\n    dx = x - x1;\n    dy = y - y1;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  },\n  // Not accurate dashed line to\n  _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n    var dashSum = this._dashSum;\n    var offset = this._dashOffset;\n    var lineDash = this._lineDash;\n    var ctx = this._ctx;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var t;\n    var dx;\n    var dy;\n    var cubicAt = curve.cubicAt;\n    var bezierLen = 0;\n    var idx = this._dashIdx;\n    var nDash = lineDash.length;\n    var x;\n    var y;\n    var tmpLen = 0;\n\n    if (offset < 0) {\n      // Convert to positive offset\n      offset = dashSum + offset;\n    }\n\n    offset %= dashSum; // Bezier approx length\n\n    for (t = 0; t < 1; t += 0.1) {\n      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);\n      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);\n      bezierLen += mathSqrt(dx * dx + dy * dy);\n    } // Find idx after add offset\n\n\n    for (; idx < nDash; idx++) {\n      tmpLen += lineDash[idx];\n\n      if (tmpLen > offset) {\n        break;\n      }\n    }\n\n    t = (tmpLen - offset) / bezierLen;\n\n    while (t <= 1) {\n      x = cubicAt(x0, x1, x2, x3, t);\n      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier\n      // Bad result if dash is long\n\n      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n      t += lineDash[idx] / bezierLen;\n      idx = (idx + 1) % nDash;\n    } // Finish the last segment and calculate the new offset\n\n\n    idx % 2 !== 0 && ctx.lineTo(x3, y3);\n    dx = x3 - x;\n    dy = y3 - y;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  },\n  _dashedQuadraticTo: function (x1, y1, x2, y2) {\n    // Convert quadratic to cubic using degree elevation\n    var x3 = x2;\n    var y3 = y2;\n    x2 = (x2 + 2 * x1) / 3;\n    y2 = (y2 + 2 * y1) / 3;\n    x1 = (this._xi + 2 * x1) / 3;\n    y1 = (this._yi + 2 * y1) / 3;\n\n    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n  },\n\n  /**\n   * 转成静态的 Float32Array 减少堆内存占用\n   * Convert dynamic array to static Float32Array\n   */\n  toStatic: function () {\n    var data = this.data;\n\n    if (data instanceof Array) {\n      data.length = this._len;\n\n      if (hasTypedArray) {\n        this.data = new Float32Array(data);\n      }\n    }\n  },\n\n  /**\n   * @return {module:zrender/core/BoundingRect}\n   */\n  getBoundingRect: function () {\n    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n    var data = this.data;\n    var xi = 0;\n    var yi = 0;\n    var x0 = 0;\n    var y0 = 0;\n\n    for (var i = 0; i < data.length;) {\n      var cmd = data[i++];\n\n      if (i == 1) {\n        // 如果第一个命令是 L, C, Q\n        // 则 previous point 同绘制命令的第一个 point\n        //\n        // 第一个命令为 Arc 的情况下会在后面特殊处理\n        xi = data[i];\n        yi = data[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n\n      switch (cmd) {\n        case CMD.M:\n          // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n          // 在 closePath 的时候使用\n          x0 = data[i++];\n          y0 = data[i++];\n          xi = x0;\n          yi = y0;\n          min2[0] = x0;\n          min2[1] = y0;\n          max2[0] = x0;\n          max2[1] = y0;\n          break;\n\n        case CMD.L:\n          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.C:\n          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.Q:\n          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.A:\n          // TODO Arc 判断的开销比较大\n          var cx = data[i++];\n          var cy = data[i++];\n          var rx = data[i++];\n          var ry = data[i++];\n          var startAngle = data[i++];\n          var endAngle = data[i++] + startAngle; // TODO Arc 旋转\n\n          var psi = data[i++];\n          var anticlockwise = 1 - data[i++];\n\n          if (i == 1) {\n            // 直接使用 arc 命令\n            // 第一个命令起点还未定义\n            x0 = mathCos(startAngle) * rx + cx;\n            y0 = mathSin(startAngle) * ry + cy;\n          }\n\n          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n\n        case CMD.R:\n          x0 = xi = data[i++];\n          y0 = yi = data[i++];\n          var width = data[i++];\n          var height = data[i++]; // Use fromLine\n\n          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n          break;\n\n        case CMD.Z:\n          xi = x0;\n          yi = y0;\n          break;\n      } // Union\n\n\n      vec2.min(min, min, min2);\n      vec2.max(max, max, max2);\n    } // No data\n\n\n    if (i === 0) {\n      min[0] = min[1] = max[0] = max[1] = 0;\n    }\n\n    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n  },\n\n  /**\n   * Rebuild path from current data\n   * Rebuild path will not consider javascript implemented line dash.\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  rebuildPath: function (ctx) {\n    var d = this.data;\n    var x0, y0;\n    var xi, yi;\n    var x, y;\n    var ux = this._ux;\n    var uy = this._uy;\n    var len = this._len;\n\n    for (var i = 0; i < len;) {\n      var cmd = d[i++];\n\n      if (i == 1) {\n        // 如果第一个命令是 L, C, Q\n        // 则 previous point 同绘制命令的第一个 point\n        //\n        // 第一个命令为 Arc 的情况下会在后面特殊处理\n        xi = d[i];\n        yi = d[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n\n      switch (cmd) {\n        case CMD.M:\n          x0 = xi = d[i++];\n          y0 = yi = d[i++];\n          ctx.moveTo(xi, yi);\n          break;\n\n        case CMD.L:\n          x = d[i++];\n          y = d[i++]; // Not draw too small seg between\n\n          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n            ctx.lineTo(x, y);\n            xi = x;\n            yi = y;\n          }\n\n          break;\n\n        case CMD.C:\n          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);\n          xi = d[i - 2];\n          yi = d[i - 1];\n          break;\n\n        case CMD.Q:\n          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n          xi = d[i - 2];\n          yi = d[i - 1];\n          break;\n\n        case CMD.A:\n          var cx = d[i++];\n          var cy = d[i++];\n          var rx = d[i++];\n          var ry = d[i++];\n          var theta = d[i++];\n          var dTheta = d[i++];\n          var psi = d[i++];\n          var fs = d[i++];\n          var r = rx > ry ? rx : ry;\n          var scaleX = rx > ry ? 1 : rx / ry;\n          var scaleY = rx > ry ? ry / rx : 1;\n          var isEllipse = Math.abs(rx - ry) > 1e-3;\n          var endAngle = theta + dTheta;\n\n          if (isEllipse) {\n            ctx.translate(cx, cy);\n            ctx.rotate(psi);\n            ctx.scale(scaleX, scaleY);\n            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n            ctx.scale(1 / scaleX, 1 / scaleY);\n            ctx.rotate(-psi);\n            ctx.translate(-cx, -cy);\n          } else {\n            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n          }\n\n          if (i == 1) {\n            // 直接使用 arc 命令\n            // 第一个命令起点还未定义\n            x0 = mathCos(theta) * rx + cx;\n            y0 = mathSin(theta) * ry + cy;\n          }\n\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n\n        case CMD.R:\n          x0 = xi = d[i];\n          y0 = yi = d[i + 1];\n          ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n          break;\n\n        case CMD.Z:\n          ctx.closePath();\n          xi = x0;\n          yi = y0;\n      }\n    }\n  }\n};\nPathProxy.CMD = CMD;\nvar _default = PathProxy;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/PathProxy.js\n// module id = 30\n// module chunks = 0","var _vector = require(\"./vector\");\n\nvar v2Create = _vector.create;\nvar v2DistSquare = _vector.distSquare;\n\n/**\n * 曲线辅助模块\n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\nvar mathPow = Math.pow;\nvar mathSqrt = Math.sqrt;\nvar EPSILON = 1e-8;\nvar EPSILON_NUMERIC = 1e-4;\nvar THREE_SQRT = mathSqrt(3);\nvar ONE_THIRD = 1 / 3; // 临时变量\n\nvar _v0 = v2Create();\n\nvar _v1 = v2Create();\n\nvar _v2 = v2Create();\n\nfunction isAroundZero(val) {\n  return val > -EPSILON && val < EPSILON;\n}\n\nfunction isNotAroundZero(val) {\n  return val > EPSILON || val < -EPSILON;\n}\n/**\n * 计算三次贝塞尔值\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction cubicAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t;\n  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);\n}\n/**\n * 计算三次贝塞尔导数值\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction cubicDerivativeAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t;\n  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);\n}\n/**\n * 计算三次贝塞尔方程根，使用盛金公式\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} val\n * @param  {Array.<number>} roots\n * @return {number} 有效根数目\n */\n\n\nfunction cubicRootAt(p0, p1, p2, p3, val, roots) {\n  // Evaluate roots of cubic functions\n  var a = p3 + 3 * (p1 - p2) - p0;\n  var b = 3 * (p2 - p1 * 2 + p0);\n  var c = 3 * (p1 - p0);\n  var d = p0 - val;\n  var A = b * b - 3 * a * c;\n  var B = b * c - 9 * a * d;\n  var C = c * c - 3 * b * d;\n  var n = 0;\n\n  if (isAroundZero(A) && isAroundZero(B)) {\n    if (isAroundZero(b)) {\n      roots[0] = 0;\n    } else {\n      var t1 = -c / b; //t1, t2, t3, b is not zero\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    }\n  } else {\n    var disc = B * B - 4 * A * C;\n\n    if (isAroundZero(disc)) {\n      var K = B / A;\n      var t1 = -b / a + K; // t1, a is not zero\n\n      var t2 = -K / 2; // t2, t3\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n      var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\n      if (Y1 < 0) {\n        Y1 = -mathPow(-Y1, ONE_THIRD);\n      } else {\n        Y1 = mathPow(Y1, ONE_THIRD);\n      }\n\n      if (Y2 < 0) {\n        Y2 = -mathPow(-Y2, ONE_THIRD);\n      } else {\n        Y2 = mathPow(Y2, ONE_THIRD);\n      }\n\n      var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    } else {\n      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n      var theta = Math.acos(T) / 3;\n      var ASqrt = mathSqrt(A);\n      var tmp = Math.cos(theta);\n      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n\n      if (t3 >= 0 && t3 <= 1) {\n        roots[n++] = t3;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * 计算三次贝塞尔方程极限值的位置\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {Array.<number>} extrema\n * @return {number} 有效数目\n */\n\n\nfunction cubicExtrema(p0, p1, p2, p3, extrema) {\n  var b = 6 * p2 - 12 * p1 + 6 * p0;\n  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n  var c = 3 * p1 - 3 * p0;\n  var n = 0;\n\n  if (isAroundZero(a)) {\n    if (isNotAroundZero(b)) {\n      var t1 = -c / b;\n\n      if (t1 >= 0 && t1 <= 1) {\n        extrema[n++] = t1;\n      }\n    }\n  } else {\n    var disc = b * b - 4 * a * c;\n\n    if (isAroundZero(disc)) {\n      extrema[0] = -b / (2 * a);\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var t1 = (-b + discSqrt) / (2 * a);\n      var t2 = (-b - discSqrt) / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        extrema[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        extrema[n++] = t2;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * 细分三次贝塞尔曲线\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @param  {Array.<number>} out\n */\n\n\nfunction cubicSubdivide(p0, p1, p2, p3, t, out) {\n  var p01 = (p1 - p0) * t + p0;\n  var p12 = (p2 - p1) * t + p1;\n  var p23 = (p3 - p2) * t + p2;\n  var p012 = (p12 - p01) * t + p01;\n  var p123 = (p23 - p12) * t + p12;\n  var p0123 = (p123 - p012) * t + p012; // Seg0\n\n  out[0] = p0;\n  out[1] = p01;\n  out[2] = p012;\n  out[3] = p0123; // Seg1\n\n  out[4] = p0123;\n  out[5] = p123;\n  out[6] = p23;\n  out[7] = p3;\n}\n/**\n * 投射点到三次贝塞尔曲线上，返回投射距离。\n * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x3\n * @param {number} y3\n * @param {number} x\n * @param {number} y\n * @param {Array.<number>} [out] 投射点\n * @return {number}\n */\n\n\nfunction cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {\n  // http://pomax.github.io/bezierinfo/#projections\n  var t;\n  var interval = 0.005;\n  var d = Infinity;\n  var prev;\n  var next;\n  var d1;\n  var d2;\n  _v0[0] = x;\n  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值\n  // PENDING\n\n  for (var _t = 0; _t < 1; _t += 0.05) {\n    _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n    _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n    d1 = v2DistSquare(_v0, _v1);\n\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n\n  d = Infinity; // At most 32 iteration\n\n  for (var i = 0; i < 32; i++) {\n    if (interval < EPSILON_NUMERIC) {\n      break;\n    }\n\n    prev = t - interval;\n    next = t + interval; // t - interval\n\n    _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n    _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n    d1 = v2DistSquare(_v1, _v0);\n\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      // t + interval\n      _v2[0] = cubicAt(x0, x1, x2, x3, next);\n      _v2[1] = cubicAt(y0, y1, y2, y3, next);\n      d2 = v2DistSquare(_v2, _v0);\n\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  } // t\n\n\n  if (out) {\n    out[0] = cubicAt(x0, x1, x2, x3, t);\n    out[1] = cubicAt(y0, y1, y2, y3, t);\n  } // console.log(interval, i);\n\n\n  return mathSqrt(d);\n}\n/**\n * 计算二次方贝塞尔值\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction quadraticAt(p0, p1, p2, t) {\n  var onet = 1 - t;\n  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n}\n/**\n * 计算二次方贝塞尔导数值\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction quadraticDerivativeAt(p0, p1, p2, t) {\n  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n}\n/**\n * 计算二次方贝塞尔方程根\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @param  {Array.<number>} roots\n * @return {number} 有效根数目\n */\n\n\nfunction quadraticRootAt(p0, p1, p2, val, roots) {\n  var a = p0 - 2 * p1 + p2;\n  var b = 2 * (p1 - p0);\n  var c = p0 - val;\n  var n = 0;\n\n  if (isAroundZero(a)) {\n    if (isNotAroundZero(b)) {\n      var t1 = -c / b;\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    }\n  } else {\n    var disc = b * b - 4 * a * c;\n\n    if (isAroundZero(disc)) {\n      var t1 = -b / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var t1 = (-b + discSqrt) / (2 * a);\n      var t2 = (-b - discSqrt) / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * 计算二次贝塞尔方程极限值\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @return {number}\n */\n\n\nfunction quadraticExtremum(p0, p1, p2) {\n  var divider = p0 + p2 - 2 * p1;\n\n  if (divider === 0) {\n    // p1 is center of p0 and p2\n    return 0.5;\n  } else {\n    return (p0 - p1) / divider;\n  }\n}\n/**\n * 细分二次贝塞尔曲线\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @param  {Array.<number>} out\n */\n\n\nfunction quadraticSubdivide(p0, p1, p2, t, out) {\n  var p01 = (p1 - p0) * t + p0;\n  var p12 = (p2 - p1) * t + p1;\n  var p012 = (p12 - p01) * t + p01; // Seg0\n\n  out[0] = p0;\n  out[1] = p01;\n  out[2] = p012; // Seg1\n\n  out[3] = p012;\n  out[4] = p12;\n  out[5] = p2;\n}\n/**\n * 投射点到二次贝塞尔曲线上，返回投射距离。\n * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x\n * @param {number} y\n * @param {Array.<number>} out 投射点\n * @return {number}\n */\n\n\nfunction quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {\n  // http://pomax.github.io/bezierinfo/#projections\n  var t;\n  var interval = 0.005;\n  var d = Infinity;\n  _v0[0] = x;\n  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值\n  // PENDING\n\n  for (var _t = 0; _t < 1; _t += 0.05) {\n    _v1[0] = quadraticAt(x0, x1, x2, _t);\n    _v1[1] = quadraticAt(y0, y1, y2, _t);\n    var d1 = v2DistSquare(_v0, _v1);\n\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n\n  d = Infinity; // At most 32 iteration\n\n  for (var i = 0; i < 32; i++) {\n    if (interval < EPSILON_NUMERIC) {\n      break;\n    }\n\n    var prev = t - interval;\n    var next = t + interval; // t - interval\n\n    _v1[0] = quadraticAt(x0, x1, x2, prev);\n    _v1[1] = quadraticAt(y0, y1, y2, prev);\n    var d1 = v2DistSquare(_v1, _v0);\n\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      // t + interval\n      _v2[0] = quadraticAt(x0, x1, x2, next);\n      _v2[1] = quadraticAt(y0, y1, y2, next);\n      var d2 = v2DistSquare(_v2, _v0);\n\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  } // t\n\n\n  if (out) {\n    out[0] = quadraticAt(x0, x1, x2, t);\n    out[1] = quadraticAt(y0, y1, y2, t);\n  } // console.log(interval, i);\n\n\n  return mathSqrt(d);\n}\n\nexports.cubicAt = cubicAt;\nexports.cubicDerivativeAt = cubicDerivativeAt;\nexports.cubicRootAt = cubicRootAt;\nexports.cubicExtrema = cubicExtrema;\nexports.cubicSubdivide = cubicSubdivide;\nexports.cubicProjectPoint = cubicProjectPoint;\nexports.quadraticAt = quadraticAt;\nexports.quadraticDerivativeAt = quadraticDerivativeAt;\nexports.quadraticRootAt = quadraticRootAt;\nexports.quadraticExtremum = quadraticExtremum;\nexports.quadraticSubdivide = quadraticSubdivide;\nexports.quadraticProjectPoint = quadraticProjectPoint;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/curve.js\n// module id = 31\n// module chunks = 0","var vec2 = require(\"./vector\");\n\nvar curve = require(\"./curve\");\n\n/**\n * @author Yi Shen(https://github.com/pissang)\n */\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI2 = Math.PI * 2;\nvar start = vec2.create();\nvar end = vec2.create();\nvar extremity = vec2.create();\n/**\n * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n * @module zrender/core/bbox\n * @param {Array<Object>} points 顶点数组\n * @param {number} min\n * @param {number} max\n */\n\nfunction fromPoints(points, min, max) {\n  if (points.length === 0) {\n    return;\n  }\n\n  var p = points[0];\n  var left = p[0];\n  var right = p[0];\n  var top = p[1];\n  var bottom = p[1];\n  var i;\n\n  for (i = 1; i < points.length; i++) {\n    p = points[i];\n    left = mathMin(left, p[0]);\n    right = mathMax(right, p[0]);\n    top = mathMin(top, p[1]);\n    bottom = mathMax(bottom, p[1]);\n  }\n\n  min[0] = left;\n  min[1] = top;\n  max[0] = right;\n  max[1] = bottom;\n}\n/**\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromLine(x0, y0, x1, y1, min, max) {\n  min[0] = mathMin(x0, x1);\n  min[1] = mathMin(y0, y1);\n  max[0] = mathMax(x0, x1);\n  max[1] = mathMax(y0, y1);\n}\n\nvar xDim = [];\nvar yDim = [];\n/**\n * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x3\n * @param {number} y3\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\nfunction fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {\n  var cubicExtrema = curve.cubicExtrema;\n  var cubicAt = curve.cubicAt;\n  var i;\n  var n = cubicExtrema(x0, x1, x2, x3, xDim);\n  min[0] = Infinity;\n  min[1] = Infinity;\n  max[0] = -Infinity;\n  max[1] = -Infinity;\n\n  for (i = 0; i < n; i++) {\n    var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n    min[0] = mathMin(x, min[0]);\n    max[0] = mathMax(x, max[0]);\n  }\n\n  n = cubicExtrema(y0, y1, y2, y3, yDim);\n\n  for (i = 0; i < n; i++) {\n    var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n    min[1] = mathMin(y, min[1]);\n    max[1] = mathMax(y, max[1]);\n  }\n\n  min[0] = mathMin(x0, min[0]);\n  max[0] = mathMax(x0, max[0]);\n  min[0] = mathMin(x3, min[0]);\n  max[0] = mathMax(x3, max[0]);\n  min[1] = mathMin(y0, min[1]);\n  max[1] = mathMax(y0, max[1]);\n  min[1] = mathMin(y3, min[1]);\n  max[1] = mathMax(y3, max[1]);\n}\n/**\n * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {\n  var quadraticExtremum = curve.quadraticExtremum;\n  var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero\n\n  var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);\n  var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);\n  var x = quadraticAt(x0, x1, x2, tx);\n  var y = quadraticAt(y0, y1, y2, ty);\n  min[0] = mathMin(x0, x2, x);\n  min[1] = mathMin(y0, y2, y);\n  max[0] = mathMax(x0, x2, x);\n  max[1] = mathMax(y0, y2, y);\n}\n/**\n * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n * @method\n * @memberOf module:zrender/core/bbox\n * @param {number} x\n * @param {number} y\n * @param {number} rx\n * @param {number} ry\n * @param {number} startAngle\n * @param {number} endAngle\n * @param {number} anticlockwise\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {\n  var vec2Min = vec2.min;\n  var vec2Max = vec2.max;\n  var diff = Math.abs(startAngle - endAngle);\n\n  if (diff % PI2 < 1e-4 && diff > 1e-4) {\n    // Is a circle\n    min[0] = x - rx;\n    min[1] = y - ry;\n    max[0] = x + rx;\n    max[1] = y + ry;\n    return;\n  }\n\n  start[0] = mathCos(startAngle) * rx + x;\n  start[1] = mathSin(startAngle) * ry + y;\n  end[0] = mathCos(endAngle) * rx + x;\n  end[1] = mathSin(endAngle) * ry + y;\n  vec2Min(min, start, end);\n  vec2Max(max, start, end); // Thresh to [0, Math.PI * 2]\n\n  startAngle = startAngle % PI2;\n\n  if (startAngle < 0) {\n    startAngle = startAngle + PI2;\n  }\n\n  endAngle = endAngle % PI2;\n\n  if (endAngle < 0) {\n    endAngle = endAngle + PI2;\n  }\n\n  if (startAngle > endAngle && !anticlockwise) {\n    endAngle += PI2;\n  } else if (startAngle < endAngle && anticlockwise) {\n    startAngle += PI2;\n  }\n\n  if (anticlockwise) {\n    var tmp = endAngle;\n    endAngle = startAngle;\n    startAngle = tmp;\n  } // var number = 0;\n  // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\n\n  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n    if (angle > startAngle) {\n      extremity[0] = mathCos(angle) * rx + x;\n      extremity[1] = mathSin(angle) * ry + y;\n      vec2Min(min, extremity, min);\n      vec2Max(max, extremity, max);\n    }\n  }\n}\n\nexports.fromPoints = fromPoints;\nexports.fromLine = fromLine;\nexports.fromCubic = fromCubic;\nexports.fromQuadratic = fromQuadratic;\nexports.fromArc = fromArc;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/bbox.js\n// module id = 32\n// module chunks = 0","var PathProxy = require(\"../core/PathProxy\");\n\nvar line = require(\"./line\");\n\nvar cubic = require(\"./cubic\");\n\nvar quadratic = require(\"./quadratic\");\n\nvar arc = require(\"./arc\");\n\nvar _util = require(\"./util\");\n\nvar normalizeRadian = _util.normalizeRadian;\n\nvar curve = require(\"../core/curve\");\n\nvar windingLine = require(\"./windingLine\");\n\nvar CMD = PathProxy.CMD;\nvar PI2 = Math.PI * 2;\nvar EPSILON = 1e-4;\n\nfunction isAroundEqual(a, b) {\n  return Math.abs(a - b) < EPSILON;\n} // 临时数组\n\n\nvar roots = [-1, -1, -1];\nvar extrema = [-1, -1];\n\nfunction swapExtrema() {\n  var tmp = extrema[0];\n  extrema[0] = extrema[1];\n  extrema[1] = tmp;\n}\n\nfunction windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n  // Quick reject\n  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {\n    return 0;\n  }\n\n  var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\n  if (nRoots === 0) {\n    return 0;\n  } else {\n    var w = 0;\n    var nExtrema = -1;\n    var y0_, y1_;\n\n    for (var i = 0; i < nRoots; i++) {\n      var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon\n\n      var unit = t === 0 || t === 1 ? 0.5 : 1;\n      var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\n      if (x_ < x) {\n        // Quick reject\n        continue;\n      }\n\n      if (nExtrema < 0) {\n        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\n        if (extrema[1] < extrema[0] && nExtrema > 1) {\n          swapExtrema();\n        }\n\n        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\n        if (nExtrema > 1) {\n          y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n        }\n      }\n\n      if (nExtrema == 2) {\n        // 分成三段单调函数\n        if (t < extrema[0]) {\n          w += y0_ < y0 ? unit : -unit;\n        } else if (t < extrema[1]) {\n          w += y1_ < y0_ ? unit : -unit;\n        } else {\n          w += y3 < y1_ ? unit : -unit;\n        }\n      } else {\n        // 分成两段单调函数\n        if (t < extrema[0]) {\n          w += y0_ < y0 ? unit : -unit;\n        } else {\n          w += y3 < y0_ ? unit : -unit;\n        }\n      }\n    }\n\n    return w;\n  }\n}\n\nfunction windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n  // Quick reject\n  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {\n    return 0;\n  }\n\n  var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\n  if (nRoots === 0) {\n    return 0;\n  } else {\n    var t = curve.quadraticExtremum(y0, y1, y2);\n\n    if (t >= 0 && t <= 1) {\n      var w = 0;\n      var y_ = curve.quadraticAt(y0, y1, y2, t);\n\n      for (var i = 0; i < nRoots; i++) {\n        // Remove one endpoint.\n        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;\n        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\n        if (x_ < x) {\n          // Quick reject\n          continue;\n        }\n\n        if (roots[i] < t) {\n          w += y_ < y0 ? unit : -unit;\n        } else {\n          w += y2 < y_ ? unit : -unit;\n        }\n      }\n\n      return w;\n    } else {\n      // Remove one endpoint.\n      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;\n      var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\n      if (x_ < x) {\n        // Quick reject\n        return 0;\n      }\n\n      return y2 < y0 ? unit : -unit;\n    }\n  }\n} // TODO\n// Arc 旋转\n\n\nfunction windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {\n  y -= cy;\n\n  if (y > r || y < -r) {\n    return 0;\n  }\n\n  var tmp = Math.sqrt(r * r - y * y);\n  roots[0] = -tmp;\n  roots[1] = tmp;\n  var diff = Math.abs(startAngle - endAngle);\n\n  if (diff < 1e-4) {\n    return 0;\n  }\n\n  if (diff % PI2 < 1e-4) {\n    // Is a circle\n    startAngle = 0;\n    endAngle = PI2;\n    var dir = anticlockwise ? 1 : -1;\n\n    if (x >= roots[0] + cx && x <= roots[1] + cx) {\n      return dir;\n    } else {\n      return 0;\n    }\n  }\n\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = normalizeRadian(endAngle);\n    endAngle = normalizeRadian(tmp);\n  } else {\n    startAngle = normalizeRadian(startAngle);\n    endAngle = normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var w = 0;\n\n  for (var i = 0; i < 2; i++) {\n    var x_ = roots[i];\n\n    if (x_ + cx > x) {\n      var angle = Math.atan2(y, x_);\n      var dir = anticlockwise ? 1 : -1;\n\n      if (angle < 0) {\n        angle = PI2 + angle;\n      }\n\n      if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n          dir = -dir;\n        }\n\n        w += dir;\n      }\n    }\n  }\n\n  return w;\n}\n\nfunction containPath(data, lineWidth, isStroke, x, y) {\n  var w = 0;\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n\n  for (var i = 0; i < data.length;) {\n    var cmd = data[i++]; // Begin a new subpath\n\n    if (cmd === CMD.M && i > 1) {\n      // Close previous subpath\n      if (!isStroke) {\n        w += windingLine(xi, yi, x0, y0, x, y);\n      } // 如果被任何一个 subpath 包含\n      // if (w !== 0) {\n      //     return true;\n      // }\n\n    }\n\n    if (i == 1) {\n      // 如果第一个命令是 L, C, Q\n      // 则 previous point 同绘制命令的第一个 point\n      //\n      // 第一个命令为 Arc 的情况下会在后面特殊处理\n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n    }\n\n    switch (cmd) {\n      case CMD.M:\n        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n        // 在 closePath 的时候使用\n        x0 = data[i++];\n        y0 = data[i++];\n        xi = x0;\n        yi = y0;\n        break;\n\n      case CMD.L:\n        if (isStroke) {\n          if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.C:\n        if (isStroke) {\n          if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.Q:\n        if (isStroke) {\n          if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.A:\n        // TODO Arc 判断的开销比较大\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++]; // TODO Arc 旋转\n\n        var psi = data[i++];\n        var anticlockwise = 1 - data[i++];\n        var x1 = Math.cos(theta) * rx + cx;\n        var y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令\n\n        if (i > 1) {\n          w += windingLine(xi, yi, x1, y1, x, y);\n        } else {\n          // 第一个命令起点还未定义\n          x0 = x1;\n          y0 = y1;\n        } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n\n\n        var _x = (x - cx) * ry / rx + cx;\n\n        if (isStroke) {\n          if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {\n            return true;\n          }\n        } else {\n          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);\n        }\n\n        xi = Math.cos(theta + dTheta) * rx + cx;\n        yi = Math.sin(theta + dTheta) * ry + cy;\n        break;\n\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        var width = data[i++];\n        var height = data[i++];\n        var x1 = x0 + width;\n        var y1 = y0 + height;\n\n        if (isStroke) {\n          if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // FIXME Clockwise ?\n          w += windingLine(x1, y0, x1, y1, x, y);\n          w += windingLine(x0, y1, x0, y0, x, y);\n        }\n\n        break;\n\n      case CMD.Z:\n        if (isStroke) {\n          if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // Close a subpath\n          w += windingLine(xi, yi, x0, y0, x, y); // 如果被任何一个 subpath 包含\n          // FIXME subpaths may overlap\n          // if (w !== 0) {\n          //     return true;\n          // }\n        }\n\n        xi = x0;\n        yi = y0;\n        break;\n    }\n  }\n\n  if (!isStroke && !isAroundEqual(yi, y0)) {\n    w += windingLine(xi, yi, x0, y0, x, y) || 0;\n  }\n\n  return w !== 0;\n}\n\nfunction contain(pathData, x, y) {\n  return containPath(pathData, 0, false, x, y);\n}\n\nfunction containStroke(pathData, lineWidth, x, y) {\n  return containPath(pathData, lineWidth, true, x, y);\n}\n\nexports.contain = contain;\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/path.js\n// module id = 33\n// module chunks = 0","/**\n * 线段包含判断\n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth;\n  var _a = 0;\n  var _b = x0; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {\n    return false;\n  }\n\n  if (x0 !== x1) {\n    _a = (y0 - y1) / (x0 - x1);\n    _b = (x0 * y1 - x1 * y0) / (x0 - x1);\n  } else {\n    return Math.abs(x - x0) <= _l / 2;\n  }\n\n  var tmp = _a * x - y + _b;\n\n  var _s = tmp * tmp / (_a * _a + 1);\n\n  return _s <= _l / 2 * _l / 2;\n}\n\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/line.js\n// module id = 34\n// module chunks = 0","var curve = require(\"../core/curve\");\n\n/**\n * 三次贝塞尔曲线描边包含判断\n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  x2\n * @param  {number}  y2\n * @param  {number}  x3\n * @param  {number}  y3\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {\n    return false;\n  }\n\n  var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);\n  return d <= _l / 2;\n}\n\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/cubic.js\n// module id = 35\n// module chunks = 0","var _curve = require(\"../core/curve\");\n\nvar quadraticProjectPoint = _curve.quadraticProjectPoint;\n\n/**\n * 二次贝塞尔曲线描边包含判断\n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  x2\n * @param  {number}  y2\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {\n    return false;\n  }\n\n  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);\n  return d <= _l / 2;\n}\n\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/quadratic.js\n// module id = 36\n// module chunks = 0","var _util = require(\"./util\");\n\nvar normalizeRadian = _util.normalizeRadian;\nvar PI2 = Math.PI * 2;\n/**\n * 圆弧描边包含判断\n * @param  {number}  cx\n * @param  {number}  cy\n * @param  {number}  r\n * @param  {number}  startAngle\n * @param  {number}  endAngle\n * @param  {boolean}  anticlockwise\n * @param  {number} lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {Boolean}\n */\n\nfunction containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth;\n  x -= cx;\n  y -= cy;\n  var d = Math.sqrt(x * x + y * y);\n\n  if (d - _l > r || d + _l < r) {\n    return false;\n  }\n\n  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n    // Is a circle\n    return true;\n  }\n\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = normalizeRadian(endAngle);\n    endAngle = normalizeRadian(tmp);\n  } else {\n    startAngle = normalizeRadian(startAngle);\n    endAngle = normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var angle = Math.atan2(y, x);\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;\n}\n\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/arc.js\n// module id = 37\n// module chunks = 0","var PI2 = Math.PI * 2;\n\nfunction normalizeRadian(angle) {\n  angle %= PI2;\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  return angle;\n}\n\nexports.normalizeRadian = normalizeRadian;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/util.js\n// module id = 38\n// module chunks = 0","function windingLine(x0, y0, x1, y1, x, y) {\n  if (y > y0 && y > y1 || y < y0 && y < y1) {\n    return 0;\n  } // Ignore horizontal line\n\n\n  if (y1 === y0) {\n    return 0;\n  }\n\n  var dir = y1 < y0 ? 1 : -1;\n  var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon\n\n  if (t === 1 || t === 0) {\n    dir = y1 < y0 ? 0.5 : -0.5;\n  }\n\n  var x_ = t * (x1 - x0) + x0;\n  return x_ > x ? dir : 0;\n}\n\nmodule.exports = windingLine;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/windingLine.js\n// module id = 39\n// module chunks = 0","var Pattern = function (image, repeat) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {image: ...}`, where this constructor will not be called.\n  this.image = image;\n  this.repeat = repeat; // Can be cloned\n\n  this.type = 'pattern';\n};\n\nPattern.prototype.getCanvasPattern = function (ctx) {\n  return ctx.createPattern(this.image, this.repeat || 'repeat');\n};\n\nvar _default = Pattern;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Pattern.js\n// module id = 40\n// module chunks = 0","var PathProxy = require(\"../core/PathProxy\");\n\nvar _vector = require(\"../core/vector\");\n\nvar v2ApplyTransform = _vector.applyTransform;\nvar CMD = PathProxy.CMD;\nvar points = [[], [], []];\nvar mathSqrt = Math.sqrt;\nvar mathAtan2 = Math.atan2;\n\nfunction _default(path, m) {\n  var data = path.data;\n  var cmd;\n  var nPoint;\n  var i;\n  var j;\n  var k;\n  var p;\n  var M = CMD.M;\n  var C = CMD.C;\n  var L = CMD.L;\n  var R = CMD.R;\n  var A = CMD.A;\n  var Q = CMD.Q;\n\n  for (i = 0, j = 0; i < data.length;) {\n    cmd = data[i++];\n    j = i;\n    nPoint = 0;\n\n    switch (cmd) {\n      case M:\n        nPoint = 1;\n        break;\n\n      case L:\n        nPoint = 1;\n        break;\n\n      case C:\n        nPoint = 3;\n        break;\n\n      case Q:\n        nPoint = 2;\n        break;\n\n      case A:\n        var x = m[4];\n        var y = m[5];\n        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n        var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx\n\n        data[i] *= sx;\n        data[i++] += x; // cy\n\n        data[i] *= sy;\n        data[i++] += y; // Scale rx and ry\n        // FIXME Assume psi is 0 here\n\n        data[i++] *= sx;\n        data[i++] *= sy; // Start angle\n\n        data[i++] += angle; // end angle\n\n        data[i++] += angle; // FIXME psi\n\n        i += 2;\n        j = i;\n        break;\n\n      case R:\n        // x0, y0\n        p[0] = data[i++];\n        p[1] = data[i++];\n        v2ApplyTransform(p, p, m);\n        data[j++] = p[0];\n        data[j++] = p[1]; // x1, y1\n\n        p[0] += data[i++];\n        p[1] += data[i++];\n        v2ApplyTransform(p, p, m);\n        data[j++] = p[0];\n        data[j++] = p[1];\n    }\n\n    for (k = 0; k < nPoint; k++) {\n      var p = points[k];\n      p[0] = data[i++];\n      p[1] = data[i++];\n      v2ApplyTransform(p, p, m); // Write back\n\n      data[j++] = p[0];\n      data[j++] = p[1];\n    }\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/transformPath.js\n// module id = 41\n// module chunks = 0","/**\n * @param {Array.<Object>} colorStops\n */\nvar Gradient = function (colorStops) {\n  this.colorStops = colorStops || [];\n};\n\nGradient.prototype = {\n  constructor: Gradient,\n  addColorStop: function (offset, color) {\n    this.colorStops.push({\n      offset: offset,\n      color: color\n    });\n  }\n};\nvar _default = Gradient;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Gradient.js\n// module id = 42\n// module chunks = 0","// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\nfunction Draggable() {\n  this.on('mousedown', this._dragStart, this);\n  this.on('mousemove', this._drag, this);\n  this.on('mouseup', this._dragEnd, this);\n  this.on('globalout', this._dragEnd, this); // this._dropTarget = null;\n  // this._draggingTarget = null;\n  // this._x = 0;\n  // this._y = 0;\n}\n\nDraggable.prototype = {\n  constructor: Draggable,\n  _dragStart: function (e) {\n    var draggingTarget = e.target;\n\n    if (draggingTarget && draggingTarget.draggable) {\n      this._draggingTarget = draggingTarget;\n      draggingTarget.dragging = true;\n      this._x = e.offsetX;\n      this._y = e.offsetY;\n      this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n    }\n  },\n  _drag: function (e) {\n    var draggingTarget = this._draggingTarget;\n\n    if (draggingTarget) {\n      var x = e.offsetX;\n      var y = e.offsetY;\n      var dx = x - this._x;\n      var dy = y - this._y;\n      this._x = x;\n      this._y = y;\n      draggingTarget.drift(dx, dy, e);\n      this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n      var dropTarget = this.findHover(x, y, draggingTarget).target;\n      var lastDropTarget = this._dropTarget;\n      this._dropTarget = dropTarget;\n\n      if (draggingTarget !== dropTarget) {\n        if (lastDropTarget && dropTarget !== lastDropTarget) {\n          this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n        }\n\n        if (dropTarget && dropTarget !== lastDropTarget) {\n          this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n        }\n      }\n    }\n  },\n  _dragEnd: function (e) {\n    var draggingTarget = this._draggingTarget;\n\n    if (draggingTarget) {\n      draggingTarget.dragging = false;\n    }\n\n    this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\n    if (this._dropTarget) {\n      this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n    }\n\n    this._draggingTarget = null;\n    this._dropTarget = null;\n  }\n};\n\nfunction param(target, e) {\n  return {\n    target: target,\n    topTarget: e && e.topTarget\n  };\n}\n\nvar _default = Draggable;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Draggable.js\n// module id = 43\n// module chunks = 0","var zrUtil = require(\"../core/util\");\n\nvar Element = require(\"../Element\");\n\nvar BoundingRect = require(\"../core/BoundingRect\");\n\n/**\n * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/container/Group');\n *     var Circle = require('zrender/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n/**\n * @alias module:zrender/graphic/Group\n * @constructor\n * @extends module:zrender/mixin/Transformable\n * @extends module:zrender/mixin/Eventful\n */\nvar Group = function (opts) {\n  opts = opts || {};\n  Element.call(this, opts);\n\n  for (var key in opts) {\n    if (opts.hasOwnProperty(key)) {\n      this[key] = opts[key];\n    }\n  }\n\n  this._children = [];\n  this.__storage = null;\n  this.__dirty = true;\n};\n\nGroup.prototype = {\n  constructor: Group,\n  isGroup: true,\n\n  /**\n   * @type {string}\n   */\n  type: 'group',\n\n  /**\n   * 所有子孙元素是否响应鼠标事件\n   * @name module:/zrender/container/Group#silent\n   * @type {boolean}\n   * @default false\n   */\n  silent: false,\n\n  /**\n   * @return {Array.<module:zrender/Element>}\n   */\n  children: function () {\n    return this._children.slice();\n  },\n\n  /**\n   * 获取指定 index 的儿子节点\n   * @param  {number} idx\n   * @return {module:zrender/Element}\n   */\n  childAt: function (idx) {\n    return this._children[idx];\n  },\n\n  /**\n   * 获取指定名字的儿子节点\n   * @param  {string} name\n   * @return {module:zrender/Element}\n   */\n  childOfName: function (name) {\n    var children = this._children;\n\n    for (var i = 0; i < children.length; i++) {\n      if (children[i].name === name) {\n        return children[i];\n      }\n    }\n  },\n\n  /**\n   * @return {number}\n   */\n  childCount: function () {\n    return this._children.length;\n  },\n\n  /**\n   * 添加子节点到最后\n   * @param {module:zrender/Element} child\n   */\n  add: function (child) {\n    if (child && child !== this && child.parent !== this) {\n      this._children.push(child);\n\n      this._doAdd(child);\n    }\n\n    return this;\n  },\n\n  /**\n   * 添加子节点在 nextSibling 之前\n   * @param {module:zrender/Element} child\n   * @param {module:zrender/Element} nextSibling\n   */\n  addBefore: function (child, nextSibling) {\n    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {\n      var children = this._children;\n      var idx = children.indexOf(nextSibling);\n\n      if (idx >= 0) {\n        children.splice(idx, 0, child);\n\n        this._doAdd(child);\n      }\n    }\n\n    return this;\n  },\n  _doAdd: function (child) {\n    if (child.parent) {\n      child.parent.remove(child);\n    }\n\n    child.parent = this;\n    var storage = this.__storage;\n    var zr = this.__zr;\n\n    if (storage && storage !== child.__storage) {\n      storage.addToStorage(child);\n\n      if (child instanceof Group) {\n        child.addChildrenToStorage(storage);\n      }\n    }\n\n    zr && zr.refresh();\n  },\n\n  /**\n   * 移除子节点\n   * @param {module:zrender/Element} child\n   */\n  remove: function (child) {\n    var zr = this.__zr;\n    var storage = this.__storage;\n    var children = this._children;\n    var idx = zrUtil.indexOf(children, child);\n\n    if (idx < 0) {\n      return this;\n    }\n\n    children.splice(idx, 1);\n    child.parent = null;\n\n    if (storage) {\n      storage.delFromStorage(child);\n\n      if (child instanceof Group) {\n        child.delChildrenFromStorage(storage);\n      }\n    }\n\n    zr && zr.refresh();\n    return this;\n  },\n\n  /**\n   * 移除所有子节点\n   */\n  removeAll: function () {\n    var children = this._children;\n    var storage = this.__storage;\n    var child;\n    var i;\n\n    for (i = 0; i < children.length; i++) {\n      child = children[i];\n\n      if (storage) {\n        storage.delFromStorage(child);\n\n        if (child instanceof Group) {\n          child.delChildrenFromStorage(storage);\n        }\n      }\n\n      child.parent = null;\n    }\n\n    children.length = 0;\n    return this;\n  },\n\n  /**\n   * 遍历所有子节点\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  eachChild: function (cb, context) {\n    var children = this._children;\n\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n      cb.call(context, child, i);\n    }\n\n    return this;\n  },\n\n  /**\n   * 深度优先遍历所有子孙节点\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      cb.call(context, child);\n\n      if (child.type === 'group') {\n        child.traverse(cb, context);\n      }\n    }\n\n    return this;\n  },\n  addChildrenToStorage: function (storage) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      storage.addToStorage(child);\n\n      if (child instanceof Group) {\n        child.addChildrenToStorage(storage);\n      }\n    }\n  },\n  delChildrenFromStorage: function (storage) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      storage.delFromStorage(child);\n\n      if (child instanceof Group) {\n        child.delChildrenFromStorage(storage);\n      }\n    }\n  },\n  dirty: function () {\n    this.__dirty = true;\n    this.__zr && this.__zr.refresh();\n    return this;\n  },\n\n  /**\n   * @return {module:zrender/core/BoundingRect}\n   */\n  getBoundingRect: function (includeChildren) {\n    // TODO Caching\n    var rect = null;\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var children = includeChildren || this._children;\n    var tmpMat = [];\n\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n\n      if (child.ignore || child.invisible) {\n        continue;\n      }\n\n      var childRect = child.getBoundingRect();\n      var transform = child.getLocalTransform(tmpMat); // TODO\n      // The boundingRect cacluated by transforming original\n      // rect may be bigger than the actual bundingRect when rotation\n      // is used. (Consider a circle rotated aginst its center, where\n      // the actual boundingRect should be the same as that not be\n      // rotated.) But we can not find better approach to calculate\n      // actual boundingRect yet, considering performance.\n\n      if (transform) {\n        tmpRect.copy(childRect);\n        tmpRect.applyTransform(transform);\n        rect = rect || tmpRect.clone();\n        rect.union(tmpRect);\n      } else {\n        rect = rect || childRect.clone();\n        rect.union(childRect);\n      }\n    }\n\n    return rect || tmpRect;\n  }\n};\nzrUtil.inherits(Group, Element);\nvar _default = Group;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/container/Group.js\n// module id = 44\n// module chunks = 0","var Displayable = require(\"./Displayable\");\n\nvar BoundingRect = require(\"../core/BoundingRect\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar imageHelper = require(\"./helper/image\");\n\n/**\n * @alias zrender/graphic/Image\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\nfunction ZImage(opts) {\n  Displayable.call(this, opts);\n}\n\nZImage.prototype = {\n  constructor: ZImage,\n  type: 'image',\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var src = style.image; // Must bind each time\n\n    style.bind(ctx, this, prevEl);\n    var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);\n\n    if (!image || !imageHelper.isImageReady(image)) {\n      return;\n    } // 图片已经加载完成\n    // if (image.nodeName.toUpperCase() == 'IMG') {\n    //     if (!image.complete) {\n    //         return;\n    //     }\n    // }\n    // Else is canvas\n\n\n    var x = style.x || 0;\n    var y = style.y || 0;\n    var width = style.width;\n    var height = style.height;\n    var aspect = image.width / image.height;\n\n    if (width == null && height != null) {\n      // Keep image/height ratio\n      width = height * aspect;\n    } else if (height == null && width != null) {\n      height = width / aspect;\n    } else if (width == null && height == null) {\n      width = image.width;\n      height = image.height;\n    } // 设置transform\n\n\n    this.setTransform(ctx);\n\n    if (style.sWidth && style.sHeight) {\n      var sx = style.sx || 0;\n      var sy = style.sy || 0;\n      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n    } else if (style.sx && style.sy) {\n      var sx = style.sx;\n      var sy = style.sy;\n      var sWidth = width - sx;\n      var sHeight = height - sy;\n      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n    } else {\n      ctx.drawImage(image, x, y, width, height);\n    }\n\n    this.restoreTransform(ctx); // Draw rect text\n\n    if (style.text != null) {\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  getBoundingRect: function () {\n    var style = this.style;\n\n    if (!this._rect) {\n      this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);\n    }\n\n    return this._rect;\n  }\n};\nzrUtil.inherits(ZImage, Displayable);\nvar _default = ZImage;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Image.js\n// module id = 45\n// module chunks = 0","var Displayable = require(\"./Displayable\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar textContain = require(\"../contain/text\");\n\nvar textHelper = require(\"./helper/text\");\n\n/**\n * @alias zrender/graphic/Text\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\nvar Text = function (opts) {\n  // jshint ignore:line\n  Displayable.call(this, opts);\n};\n\nText.prototype = {\n  constructor: Text,\n  type: 'text',\n  brush: function (ctx, prevEl) {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true); // Use props with prefix 'text'.\n\n    style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;\n    var text = style.text; // Convert to string\n\n    text != null && (text += ''); // Always bind style\n\n    style.bind(ctx, this, prevEl);\n\n    if (!textHelper.needDrawText(text, style)) {\n      return;\n    }\n\n    this.setTransform(ctx);\n    textHelper.renderText(this, ctx, text, style);\n    this.restoreTransform(ctx);\n  },\n  getBoundingRect: function () {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true);\n\n    if (!this._rect) {\n      var text = style.text;\n      text != null ? text += '' : text = '';\n      var rect = textContain.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.rich);\n      rect.x += style.x || 0;\n      rect.y += style.y || 0;\n\n      if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {\n        var w = style.textStrokeWidth;\n        rect.x -= w / 2;\n        rect.y -= w / 2;\n        rect.width += w;\n        rect.height += w;\n      }\n\n      this._rect = rect;\n    }\n\n    return this._rect;\n  }\n};\nzrUtil.inherits(Text, Displayable);\nvar _default = Text;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Text.js\n// module id = 46\n// module chunks = 0","var Path = require(\"../Path\");\n\n/**\n * 圆形\n * @module zrender/shape/Circle\n */\nvar _default = Path.extend({\n  type: 'circle',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0\n  },\n  buildPath: function (ctx, shape, inBundle) {\n    // Better stroking in ShapeBundle\n    // Always do it may have performence issue ( fill may be 2x more cost)\n    if (inBundle) {\n      ctx.moveTo(shape.cx + shape.r, shape.cy);\n    } // else {\n    //     if (ctx.allocate && !ctx.data.length) {\n    //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n    //     }\n    // }\n    // Better stroking in ShapeBundle\n    // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\n\n    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Circle.js\n// module id = 47\n// module chunks = 0","var Path = require(\"../Path\");\n\nvar fixClipWithShadow = require(\"../helper/fixClipWithShadow\");\n\n/**\n * 扇形\n * @module zrender/graphic/shape/Sector\n */\nvar _default = Path.extend({\n  type: 'sector',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r0: 0,\n    r: 0,\n    startAngle: 0,\n    endAngle: Math.PI * 2,\n    clockwise: true\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var r0 = Math.max(shape.r0 || 0, 0);\n    var r = Math.max(shape.r, 0);\n    var startAngle = shape.startAngle;\n    var endAngle = shape.endAngle;\n    var clockwise = shape.clockwise;\n    var unitX = Math.cos(startAngle);\n    var unitY = Math.sin(startAngle);\n    ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n    ctx.lineTo(unitX * r + x, unitY * r + y);\n    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n    ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);\n\n    if (r0 !== 0) {\n      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n    }\n\n    ctx.closePath();\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Sector.js\n// module id = 48\n// module chunks = 0","var env = require(\"../../core/env\");\n\n// Fix weird bug in some version of IE11 (like 11.0.9600.178**),\n// where exception \"unexpected call to method or property access\"\n// might be thrown when calling ctx.fill or ctx.stroke after a path\n// whose area size is zero is drawn and ctx.clip() is called and\n// shadowBlur is set. See #4572, #3112, #5777.\n// (e.g.,\n//  ctx.moveTo(10, 10);\n//  ctx.lineTo(20, 10);\n//  ctx.closePath();\n//  ctx.clip();\n//  ctx.shadowBlur = 10;\n//  ...\n//  ctx.fill();\n// )\nvar shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];\n\nfunction _default(orignalBrush) {\n  // version string can be: '11.0'\n  return env.browser.ie && env.browser.version >= 11 ? function () {\n    var clipPaths = this.__clipPaths;\n    var style = this.style;\n    var modified;\n\n    if (clipPaths) {\n      for (var i = 0; i < clipPaths.length; i++) {\n        var clipPath = clipPaths[i];\n        var shape = clipPath && clipPath.shape;\n        var type = clipPath && clipPath.type;\n\n        if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {\n          for (var j = 0; j < shadowTemp.length; j++) {\n            // It is save to put shadowTemp static, because shadowTemp\n            // will be all modified each item brush called.\n            shadowTemp[j][2] = style[shadowTemp[j][0]];\n            style[shadowTemp[j][0]] = shadowTemp[j][1];\n          }\n\n          modified = true;\n          break;\n        }\n      }\n    }\n\n    orignalBrush.apply(this, arguments);\n\n    if (modified) {\n      for (var j = 0; j < shadowTemp.length; j++) {\n        style[shadowTemp[j][0]] = shadowTemp[j][2];\n      }\n    }\n  } : orignalBrush;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/fixClipWithShadow.js\n// module id = 49\n// module chunks = 0","/**\n * echarts设备环境识别\n *\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\nvar env = {};\n\nif (typeof navigator === 'undefined') {\n  // In node\n  env = {\n    browser: {},\n    os: {},\n    node: true,\n    // Assume canvas is supported\n    canvasSupported: true,\n    svgSupported: true\n  };\n} else {\n  env = detect(navigator.userAgent);\n}\n\nvar _default = env; // Zepto.js\n// (c) 2010-2013 Thomas Fuchs\n// Zepto.js may be freely distributed under the MIT license.\n\nfunction detect(ua) {\n  var os = {};\n  var browser = {}; // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n  // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n  // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n  // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n  // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n  // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n  // var touchpad = webos && ua.match(/TouchPad/);\n  // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n  // var silk = ua.match(/Silk\\/([\\d._]+)/);\n  // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n  // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n  // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n  // var playbook = ua.match(/PlayBook/);\n  // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\n  var firefox = ua.match(/Firefox\\/([\\d.]+)/); // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n  // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\n  var ie = ua.match(/MSIE\\s([\\d.]+)/) // IE 11 Trident/7.0; rv:11.0\n  || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n  var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n  var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:\n  // - discern (more) between multiple browsers on android\n  // - decide if kindle fire in silk mode is android or not\n  // - Firefox on Android doesn't specify the Android version\n  // - possibly devide in os, device and browser hashes\n  // if (browser.webkit = !!webkit) browser.version = webkit[1];\n  // if (android) os.android = true, os.version = android[2];\n  // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n  // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n  // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n  // if (webos) os.webos = true, os.version = webos[2];\n  // if (touchpad) os.touchpad = true;\n  // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n  // if (bb10) os.bb10 = true, os.version = bb10[2];\n  // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n  // if (playbook) browser.playbook = true;\n  // if (kindle) os.kindle = true, os.version = kindle[1];\n  // if (silk) browser.silk = true, browser.version = silk[1];\n  // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n  // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\n  if (firefox) {\n    browser.firefox = true;\n    browser.version = firefox[1];\n  } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n  // if (webview) browser.webview = true;\n\n\n  if (ie) {\n    browser.ie = true;\n    browser.version = ie[1];\n  }\n\n  if (edge) {\n    browser.edge = true;\n    browser.version = edge[1];\n  } // It is difficult to detect WeChat in Win Phone precisely, because ua can\n  // not be set on win phone. So we do not consider Win Phone.\n\n\n  if (weChat) {\n    browser.weChat = true;\n  } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n  //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n  // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n  //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n  //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n\n  return {\n    browser: browser,\n    os: os,\n    node: false,\n    // 原生canvas支持，改极端点了\n    // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n    canvasSupported: !!document.createElement('canvas').getContext,\n    svgSupported: typeof SVGRect !== 'undefined',\n    // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n    // works on most browsers\n    // IE10/11 does not support touch event, and MS Edge supports them but not by\n    // default, so we dont check navigator.maxTouchPoints for them here.\n    touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n    // <http://caniuse.com/#search=pointer%20event>.\n    pointerEventsSupported: 'onpointerdown' in window // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n    // events currently. So we dont use that on other browsers unless tested sufficiently.\n    // Although IE 10 supports pointer event, it use old style and is different from the\n    // standard. So we exclude that. (IE 10 is hardly used on touch device)\n    && (browser.edge || browser.ie && browser.version >= 11)\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/env.js\n// module id = 50\n// module chunks = 0","var Path = require(\"../Path\");\n\n/**\n * 圆环\n * @module zrender/graphic/shape/Ring\n */\nvar _default = Path.extend({\n  type: 'ring',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0,\n    r0: 0\n  },\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var PI2 = Math.PI * 2;\n    ctx.moveTo(x + shape.r, y);\n    ctx.arc(x, y, shape.r, 0, PI2, false);\n    ctx.moveTo(x + shape.r0, y);\n    ctx.arc(x, y, shape.r0, 0, PI2, true);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Ring.js\n// module id = 51\n// module chunks = 0","var Path = require(\"../Path\");\n\nvar polyHelper = require(\"../helper/poly\");\n\n/**\n * 多边形\n * @module zrender/shape/Polygon\n */\nvar _default = Path.extend({\n  type: 'polygon',\n  shape: {\n    points: null,\n    smooth: false,\n    smoothConstraint: null\n  },\n  buildPath: function (ctx, shape) {\n    polyHelper.buildPath(ctx, shape, true);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Polygon.js\n// module id = 52\n// module chunks = 0","var smoothSpline = require(\"./smoothSpline\");\n\nvar smoothBezier = require(\"./smoothBezier\");\n\nfunction buildPath(ctx, shape, closePath) {\n  var points = shape.points;\n  var smooth = shape.smooth;\n\n  if (points && points.length >= 2) {\n    if (smooth && smooth !== 'spline') {\n      var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);\n      ctx.moveTo(points[0][0], points[0][1]);\n      var len = points.length;\n\n      for (var i = 0; i < (closePath ? len : len - 1); i++) {\n        var cp1 = controlPoints[i * 2];\n        var cp2 = controlPoints[i * 2 + 1];\n        var p = points[(i + 1) % len];\n        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);\n      }\n    } else {\n      if (smooth === 'spline') {\n        points = smoothSpline(points, closePath);\n      }\n\n      ctx.moveTo(points[0][0], points[0][1]);\n\n      for (var i = 1, l = points.length; i < l; i++) {\n        ctx.lineTo(points[i][0], points[i][1]);\n      }\n    }\n\n    closePath && ctx.closePath();\n  }\n}\n\nexports.buildPath = buildPath;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/poly.js\n// module id = 53\n// module chunks = 0","var _vector = require(\"../../core/vector\");\n\nvar v2Distance = _vector.distance;\n\n/**\n * Catmull-Rom spline 插值折线\n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n/**\n * @inner\n */\nfunction interpolate(p0, p1, p2, p3, t, t2, t3) {\n  var v0 = (p2 - p0) * 0.5;\n  var v1 = (p3 - p1) * 0.5;\n  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n}\n/**\n * @alias module:zrender/shape/util/smoothSpline\n * @param {Array} points 线段顶点数组\n * @param {boolean} isLoop\n * @return {Array}\n */\n\n\nfunction _default(points, isLoop) {\n  var len = points.length;\n  var ret = [];\n  var distance = 0;\n\n  for (var i = 1; i < len; i++) {\n    distance += v2Distance(points[i - 1], points[i]);\n  }\n\n  var segs = distance / 2;\n  segs = segs < len ? len : segs;\n\n  for (var i = 0; i < segs; i++) {\n    var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n    var idx = Math.floor(pos);\n    var w = pos - idx;\n    var p0;\n    var p1 = points[idx % len];\n    var p2;\n    var p3;\n\n    if (!isLoop) {\n      p0 = points[idx === 0 ? idx : idx - 1];\n      p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n      p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n    } else {\n      p0 = points[(idx - 1 + len) % len];\n      p2 = points[(idx + 1) % len];\n      p3 = points[(idx + 2) % len];\n    }\n\n    var w2 = w * w;\n    var w3 = w * w2;\n    ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);\n  }\n\n  return ret;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/smoothSpline.js\n// module id = 54\n// module chunks = 0","var _vector = require(\"../../core/vector\");\n\nvar v2Min = _vector.min;\nvar v2Max = _vector.max;\nvar v2Scale = _vector.scale;\nvar v2Distance = _vector.distance;\nvar v2Add = _vector.add;\nvar v2Clone = _vector.clone;\nvar v2Sub = _vector.sub;\n\n/**\n * 贝塞尔平滑曲线\n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n/**\n * 贝塞尔平滑曲线\n * @alias module:zrender/shape/util/smoothBezier\n * @param {Array} points 线段顶点数组\n * @param {number} smooth 平滑等级, 0-1\n * @param {boolean} isLoop\n * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n *                           整个折线的包围盒做一个并集用来约束控制点。\n * @param {Array} 计算出来的控制点数组\n */\nfunction _default(points, smooth, isLoop, constraint) {\n  var cps = [];\n  var v = [];\n  var v1 = [];\n  var v2 = [];\n  var prevPoint;\n  var nextPoint;\n  var min, max;\n\n  if (constraint) {\n    min = [Infinity, Infinity];\n    max = [-Infinity, -Infinity];\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      v2Min(min, min, points[i]);\n      v2Max(max, max, points[i]);\n    } // 与指定的包围盒做并集\n\n\n    v2Min(min, min, constraint[0]);\n    v2Max(max, max, constraint[1]);\n  }\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n\n    if (isLoop) {\n      prevPoint = points[i ? i - 1 : len - 1];\n      nextPoint = points[(i + 1) % len];\n    } else {\n      if (i === 0 || i === len - 1) {\n        cps.push(v2Clone(points[i]));\n        continue;\n      } else {\n        prevPoint = points[i - 1];\n        nextPoint = points[i + 1];\n      }\n    }\n\n    v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length\n\n    v2Scale(v, v, smooth);\n    var d0 = v2Distance(point, prevPoint);\n    var d1 = v2Distance(point, nextPoint);\n    var sum = d0 + d1;\n\n    if (sum !== 0) {\n      d0 /= sum;\n      d1 /= sum;\n    }\n\n    v2Scale(v1, v, -d0);\n    v2Scale(v2, v, d1);\n    var cp0 = v2Add([], point, v1);\n    var cp1 = v2Add([], point, v2);\n\n    if (constraint) {\n      v2Max(cp0, cp0, min);\n      v2Min(cp0, cp0, max);\n      v2Max(cp1, cp1, min);\n      v2Min(cp1, cp1, max);\n    }\n\n    cps.push(cp0);\n    cps.push(cp1);\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n\n  return cps;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/smoothBezier.js\n// module id = 55\n// module chunks = 0","var Path = require(\"../Path\");\n\nvar polyHelper = require(\"../helper/poly\");\n\n/**\n * @module zrender/graphic/shape/Polyline\n */\nvar _default = Path.extend({\n  type: 'polyline',\n  shape: {\n    points: null,\n    smooth: false,\n    smoothConstraint: null\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    polyHelper.buildPath(ctx, shape, false);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Polyline.js\n// module id = 56\n// module chunks = 0","var Path = require(\"../Path\");\n\nvar roundRectHelper = require(\"../helper/roundRect\");\n\n/**\n * 矩形\n * @module zrender/graphic/shape/Rect\n */\nvar _default = Path.extend({\n  type: 'rect',\n  shape: {\n    // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n    // r缩写为1         相当于 [1, 1, 1, 1]\n    // r缩写为[1]       相当于 [1, 1, 1, 1]\n    // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n    // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n    r: 0,\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (ctx, shape) {\n    var x = shape.x;\n    var y = shape.y;\n    var width = shape.width;\n    var height = shape.height;\n\n    if (!shape.r) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, shape);\n    }\n\n    ctx.closePath();\n    return;\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Rect.js\n// module id = 57\n// module chunks = 0","var Path = require(\"../Path\");\n\n/**\n * 直线\n * @module zrender/graphic/shape/Line\n */\nvar _default = Path.extend({\n  type: 'line',\n  shape: {\n    // Start point\n    x1: 0,\n    y1: 0,\n    // End point\n    x2: 0,\n    y2: 0,\n    percent: 1\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x1 = shape.x1;\n    var y1 = shape.y1;\n    var x2 = shape.x2;\n    var y2 = shape.y2;\n    var percent = shape.percent;\n\n    if (percent === 0) {\n      return;\n    }\n\n    ctx.moveTo(x1, y1);\n\n    if (percent < 1) {\n      x2 = x1 * (1 - percent) + x2 * percent;\n      y2 = y1 * (1 - percent) + y2 * percent;\n    }\n\n    ctx.lineTo(x2, y2);\n  },\n\n  /**\n   * Get point at percent\n   * @param  {number} percent\n   * @return {Array.<number>}\n   */\n  pointAt: function (p) {\n    var shape = this.shape;\n    return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Line.js\n// module id = 58\n// module chunks = 0","var Path = require(\"../Path\");\n\nvar vec2 = require(\"../../core/vector\");\n\nvar _curve = require(\"../../core/curve\");\n\nvar quadraticSubdivide = _curve.quadraticSubdivide;\nvar cubicSubdivide = _curve.cubicSubdivide;\nvar quadraticAt = _curve.quadraticAt;\nvar cubicAt = _curve.cubicAt;\nvar quadraticDerivativeAt = _curve.quadraticDerivativeAt;\nvar cubicDerivativeAt = _curve.cubicDerivativeAt;\n\n/**\n * 贝塞尔曲线\n * @module zrender/shape/BezierCurve\n */\nvar out = [];\n\nfunction someVectorAt(shape, t, isTangent) {\n  var cpx2 = shape.cpx2;\n  var cpy2 = shape.cpy2;\n\n  if (cpx2 === null || cpy2 === null) {\n    return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];\n  } else {\n    return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];\n  }\n}\n\nvar _default = Path.extend({\n  type: 'bezier-curve',\n  shape: {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0,\n    cpx1: 0,\n    cpy1: 0,\n    // cpx2: 0,\n    // cpy2: 0\n    // Curve show percent, for animating\n    percent: 1\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x1 = shape.x1;\n    var y1 = shape.y1;\n    var x2 = shape.x2;\n    var y2 = shape.y2;\n    var cpx1 = shape.cpx1;\n    var cpy1 = shape.cpy1;\n    var cpx2 = shape.cpx2;\n    var cpy2 = shape.cpy2;\n    var percent = shape.percent;\n\n    if (percent === 0) {\n      return;\n    }\n\n    ctx.moveTo(x1, y1);\n\n    if (cpx2 == null || cpy2 == null) {\n      if (percent < 1) {\n        quadraticSubdivide(x1, cpx1, x2, percent, out);\n        cpx1 = out[1];\n        x2 = out[2];\n        quadraticSubdivide(y1, cpy1, y2, percent, out);\n        cpy1 = out[1];\n        y2 = out[2];\n      }\n\n      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n    } else {\n      if (percent < 1) {\n        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n        cpx1 = out[1];\n        cpx2 = out[2];\n        x2 = out[3];\n        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n        cpy1 = out[1];\n        cpy2 = out[2];\n        y2 = out[3];\n      }\n\n      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n    }\n  },\n\n  /**\n   * Get point at percent\n   * @param  {number} t\n   * @return {Array.<number>}\n   */\n  pointAt: function (t) {\n    return someVectorAt(this.shape, t, false);\n  },\n\n  /**\n   * Get tangent at percent\n   * @param  {number} t\n   * @return {Array.<number>}\n   */\n  tangentAt: function (t) {\n    var p = someVectorAt(this.shape, t, true);\n    return vec2.normalize(p, p);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/BezierCurve.js\n// module id = 59\n// module chunks = 0","var Path = require(\"../Path\");\n\n/**\n * 圆弧\n * @module zrender/graphic/shape/Arc\n */\nvar _default = Path.extend({\n  type: 'arc',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0,\n    startAngle: 0,\n    endAngle: Math.PI * 2,\n    clockwise: true\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var r = Math.max(shape.r, 0);\n    var startAngle = shape.startAngle;\n    var endAngle = shape.endAngle;\n    var clockwise = shape.clockwise;\n    var unitX = Math.cos(startAngle);\n    var unitY = Math.sin(startAngle);\n    ctx.moveTo(unitX * r + x, unitY * r + y);\n    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Arc.js\n// module id = 60\n// module chunks = 0","var zrUtil = require(\"../core/util\");\n\nvar Gradient = require(\"./Gradient\");\n\n/**\n * x, y, x2, y2 are all percent from 0 to 1\n * @param {number} [x=0]\n * @param {number} [y=0]\n * @param {number} [x2=1]\n * @param {number} [y2=0]\n * @param {Array.<Object>} colorStops\n * @param {boolean} [globalCoord=false]\n */\nvar LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {type: 'linear', colorStops: ...}`, where\n  // this constructor will not be called.\n  this.x = x == null ? 0 : x;\n  this.y = y == null ? 0 : y;\n  this.x2 = x2 == null ? 1 : x2;\n  this.y2 = y2 == null ? 0 : y2; // Can be cloned\n\n  this.type = 'linear'; // If use global coord\n\n  this.global = globalCoord || false;\n  Gradient.call(this, colorStops);\n};\n\nLinearGradient.prototype = {\n  constructor: LinearGradient\n};\nzrUtil.inherits(LinearGradient, Gradient);\nvar _default = LinearGradient;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/LinearGradient.js\n// module id = 61\n// module chunks = 0","var zrUtil = require(\"../core/util\");\n\nvar Gradient = require(\"./Gradient\");\n\n/**\n * x, y, r are all percent from 0 to 1\n * @param {number} [x=0.5]\n * @param {number} [y=0.5]\n * @param {number} [r=0.5]\n * @param {Array.<Object>} [colorStops]\n * @param {boolean} [globalCoord=false]\n */\nvar RadialGradient = function (x, y, r, colorStops, globalCoord) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {type: 'radial', colorStops: ...}`, where\n  // this constructor will not be called.\n  this.x = x == null ? 0.5 : x;\n  this.y = y == null ? 0.5 : y;\n  this.r = r == null ? 0.5 : r; // Can be cloned\n\n  this.type = 'radial'; // If use global coord\n\n  this.global = globalCoord || false;\n  Gradient.call(this, colorStops);\n};\n\nRadialGradient.prototype = {\n  constructor: RadialGradient\n};\nzrUtil.inherits(RadialGradient, Gradient);\nvar _default = RadialGradient;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/RadialGradient.js\n// module id = 62\n// module chunks = 0","var zrUtil = require(\"../core/util\");\n\nvar Style = require(\"./Style\");\n\nvar _vector = require(\"../core/vector\");\n\nvar vec2Copy = _vector.copy;\n\n/**\n * States machine for managing graphic states\n */\n\n/**\n * @typedef {Object} IGraphicState\n * @property {number} [zlevel]\n * @property {number} [z]\n * @property {Array.<number>} {position}\n * @property {Array.<number>|number} {rotation}\n * @property {Array.<number>} {scale}\n * @property {Object} style\n *\n * @property {Function} onenter\n * @property {Function} onleave\n * @property {Function} ontransition\n * @property {Array.<IGraphicStateTransition|string>} transition\n *           Transition object or a string descriptor like '* 30 0 Linear'\n */\nvar transitionProperties = ['position', 'rotation', 'scale', 'style', 'shape'];\n/**\n * @module zrender/graphic/States~TransitionObject\n */\n\nvar TransitionObject = function (opts) {\n  if (typeof opts == 'string') {\n    this._fromStr(opts);\n  } else if (opts) {\n    opts.property && (this.property = opts.property);\n    opts.duration != null && (this.duration = opts.duration);\n    opts.easing && (this.easing = opts.easing);\n    opts.delay && (this.delay = opts.delay);\n  }\n\n  if (this.property !== '*') {\n    this.property = this.property.split(',');\n  } else {\n    this.property = transitionProperties;\n  }\n};\n\nTransitionObject.prototype = {\n  constructor: TransitionObject,\n\n  /**\n   * List of all transition properties. Splitted by comma. Must not have spaces in the string.\n   * e.g. 'position,style.color'. '*' will match all the valid properties.\n   * @type {string}\n   * @default *\n   */\n  property: '*',\n\n  /**\n   * @type {string}\n   * @default 'Linear'\n   */\n  easing: 'Linear',\n\n  /**\n   * @type {number}\n   * @default 'number'\n   */\n  duration: 500,\n\n  /**\n   * @type {number}\n   */\n  delay: 0,\n  _fromStr: function (str) {\n    var arr = str.split(/\\s+/g);\n    this.property = arr[0];\n    this.duration = +arr[1];\n    this.delay = +arr[2];\n    this.easing = arr[3];\n  }\n};\n/**\n * @alias module:zrender/graphic/States\n */\n\nvar GraphicStates = function (opts) {\n  opts = opts || {};\n  this._states = {};\n  /**\n   * Target element\n   * @type {zrender/graphic/Displayable|zrender/container/Group}\n   */\n\n  this._el = opts.el;\n  this._subStates = [];\n  this._transitionAnimators = [];\n\n  if (opts.initialState) {\n    this._initialState = opts.initialState;\n  }\n\n  var optsStates = opts.states;\n\n  if (optsStates) {\n    for (var name in optsStates) {\n      if (optsStates.hasOwnProperty(name)) {\n        var state = optsStates[name];\n\n        this._addState(name, state);\n      }\n    }\n  }\n\n  this.setState(this._initialState);\n};\n\nGraphicStates.prototype = {\n  constructor: GraphicStates,\n\n  /**\n   * All other state will be extended from initial state\n   * @type {string}\n   * @private\n   */\n  _initialState: 'normal',\n\n  /**\n   * Current state\n   * @type {string}\n   * @private\n   */\n  _currentState: '',\n  el: function () {\n    return this._el;\n  },\n  _addState: function (name, state) {\n    this._states[name] = state;\n\n    if (state.transition) {\n      state.transition = new TransitionObject(state.transition);\n    } // Extend from initial state\n\n\n    if (name !== this._initialState) {\n      this._extendFromInitial(state);\n    } else {\n      var el = this._el; // setState 的时候自带的 style 和 shape 都会被直接覆盖\n      // 所以这边先把自带的 style 和 shape 扩展到初始状态中\n\n      zrUtil.merge(state.style, el.style, false, false);\n\n      if (state.shape) {\n        zrUtil.merge(state.shape, el.shape, false, true);\n      } else {\n        state.shape = zrUtil.clone(el.shape, true);\n      }\n\n      for (var name in this._states) {\n        if (this._states.hasOwnProperty(name)) {\n          this._extendFromInitial(this._states[name]);\n        }\n      }\n    }\n  },\n  _extendFromInitial: function (state) {\n    var initialState = this._states[this._initialState];\n\n    if (initialState && state !== initialState) {\n      zrUtil.merge(state, initialState, false, true);\n    }\n  },\n  setState: function (name, silent) {\n    if (name === this._currentState && !this.transiting()) {\n      return;\n    }\n\n    var state = this._states[name];\n\n    if (state) {\n      this._stopTransition();\n\n      if (!silent) {\n        var prevState = this._states[this._currentState];\n\n        if (prevState) {\n          prevState.onleave && prevState.onleave.call(this);\n        }\n\n        state.onenter && state.onenter.call(this);\n      }\n\n      this._currentState = name;\n\n      if (this._el) {\n        var el = this._el; // Setting attributes\n\n        if (state.zlevel != null) {\n          el.zlevel = state.zlevel;\n        }\n\n        if (state.z != null) {\n          el.z = state.z;\n        } // SRT\n\n\n        state.position && vec2Copy(el.position, state.position);\n        state.scale && vec2Copy(el.scale, state.scale);\n\n        if (state.rotation != null) {\n          el.rotation = state.rotation;\n        } // Style\n\n\n        if (state.style) {\n          var initialState = this._states[this._initialState];\n          el.style = new Style();\n\n          if (initialState) {\n            el.style.extendFrom(initialState.style, false);\n          }\n\n          if ( // Not initial state\n          name != this._initialState // Not copied from initial state in _extendFromInitial method\n          && initialState.style !== state.style) {\n            el.style.extendFrom(state.style, true);\n          }\n        }\n\n        if (state.shape) {\n          el.shape = zrUtil.clone(state.shape, true);\n        }\n\n        el.dirty();\n      }\n    }\n\n    for (var i = 0; i < this._subStates.length; i++) {\n      this._subStates.setState(name);\n    }\n  },\n  getState: function () {\n    return this._currentState;\n  },\n  transitionState: function (target, done) {\n    if (target === this._currentState && !this.transiting()) {\n      return;\n    }\n\n    var state = this._states[target];\n    var styleShapeReg = /$[style|shape]\\./;\n    var self = this; // Animation 去重\n\n    var propPathMap = {};\n\n    if (state) {\n      self._stopTransition();\n\n      var el = self._el;\n\n      if (state.transition && el && el.__zr) {\n        // El can be animated\n        var transitionCfg = state.transition;\n        var property = transitionCfg.property;\n        var animatingCount = 0;\n\n        var animationDone = function () {\n          animatingCount--;\n\n          if (animatingCount === 0) {\n            self.setState(target);\n            done && done();\n          }\n        };\n\n        for (var i = 0; i < property.length; i++) {\n          var propName = property[i]; // Animating all the properties in style or shape\n\n          if (propName === 'style' || propName === 'shape') {\n            if (state[propName]) {\n              for (var key in state[propName]) {\n                if (!state[propName].hasOwnProperty(key)) {\n                  continue;\n                }\n\n                var path = propName + '.' + key;\n\n                if (propPathMap[path]) {\n                  continue;\n                }\n\n                propPathMap[path] = 1;\n                animatingCount += self._animProp(state, propName, key, transitionCfg, animationDone);\n              }\n            }\n          } else {\n            if (propPathMap[propName]) {\n              continue;\n            }\n\n            propPathMap[propName] = 1; // Animating particular property in style or style\n\n            if (propName.match(styleShapeReg)) {\n              // remove 'style.', 'shape.' prefix\n              var subProp = propName.slice(0, 5);\n              propName = propName.slice(6);\n              animatingCount += self._animProp(state, subProp, propName, transitionCfg, animationDone);\n            } else {\n              animatingCount += self._animProp(state, '', propName, transitionCfg, animationDone);\n            }\n          }\n        } // No transition properties\n\n\n        if (animatingCount === 0) {\n          self.setState(target);\n          done && done();\n        }\n      } else {\n        self.setState(target);\n        done && done();\n      }\n    }\n\n    var subStates = self._subStates;\n\n    for (var i = 0; i < subStates.length; i++) {\n      subStates.transitionState(target);\n    }\n  },\n\n  /**\n   * Do transition animation of particular property\n   * @param {Object} state\n   * @param {string} subPropKey\n   * @param {string} key\n   * @param {Object} transitionCfg\n   * @param {Function} done\n   * @private\n   */\n  _animProp: function (state, subPropKey, key, transitionCfg, done) {\n    var el = this._el;\n    var stateObj = subPropKey ? state[subPropKey] : state;\n    var elObj = subPropKey ? el[subPropKey] : el;\n    var availableProp = stateObj && key in stateObj && elObj && key in elObj;\n    var transitionAnimators = this._transitionAnimators;\n\n    if (availableProp) {\n      var obj = {};\n\n      if (stateObj[key] === elObj[key]) {\n        return 0;\n      }\n\n      obj[key] = stateObj[key];\n      var animator = el.animate(subPropKey).when(transitionCfg.duration, obj).delay(transitionCfg.dealy).done(function () {\n        var idx = zrUtil.indexOf(transitionAnimators, 1);\n\n        if (idx > 0) {\n          transitionAnimators.splice(idx, 1);\n        }\n\n        done();\n      }).start(transitionCfg.easing);\n      transitionAnimators.push(animator);\n      return 1;\n    }\n\n    return 0;\n  },\n  _stopTransition: function () {\n    var transitionAnimators = this._transitionAnimators;\n\n    for (var i = 0; i < transitionAnimators.length; i++) {\n      transitionAnimators[i].stop();\n    }\n\n    transitionAnimators.length = 0;\n  },\n  transiting: function () {\n    return this._transitionAnimators.length > 0;\n  },\n  addSubStates: function (states) {\n    this._subStates.push(states);\n  },\n  removeSubStates: function (states) {\n    var idx = zrUtil.indexOf(this._subStates, states);\n\n    if (idx >= 0) {\n      this._subStates.splice(states, 1);\n    }\n  }\n};\nvar _default = GraphicStates;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/States.js\n// module id = 63\n// module chunks = 0","\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var BoundingRect = require('zrender/lib/core/BoundingRect.js');\r\n    function Minimap(bigCanvas,groupPosition, group,eagleEyeNode,distance,imgSrc) {\r\n\r\n        this.bigCanvas = bigCanvas;\r\n        this.eagleEyeNode = eagleEyeNode;\r\n        this.distance = distance;\r\n        this.imgSrc = imgSrc;\r\n        this.ratio;\r\n        this.groupRatio;\r\n        this.group = group;\r\n        this.img = document.createElement(\"img\");\r\n        this.selection = document.createElement('div');\r\n        this.groupPosition = zrUtil.clone(groupPosition);\r\n        this.selectPosition = [0,0];\r\n        this.render();\r\n    }\r\n\r\n    Minimap.prototype.render = function() {\r\n        var that = this;\r\n        that.ratio = 0.12;\r\n        var eagleEyeNodeWidth = that.group.width  * that.ratio;\r\n        var eagleEyeNodeHeight = that.group.height  * that.ratio;\r\n        that.eagleEyeNode.style.width = eagleEyeNodeWidth+\"px\";\r\n        that.eagleEyeNode.style.height = eagleEyeNodeHeight+\"px\";\r\n        that.eagleEyeNode.style.marginTop = -eagleEyeNodeHeight+\"px\";\r\n        that.eagleEyeNode.style.marginLeft = that.bigCanvas.getWidth()-eagleEyeNodeWidth+\"px\";\r\n        that.eagleEyeNode.style.position=\"relative\";\r\n        that.eagleEyeNode.style.background = \"url(\"+that.imgSrc+\") no-repeat\";\r\n        that.eagleEyeNode.style.backgroundSize = eagleEyeNodeWidth/(that.group.width*that.distance[2]/that.bigCanvas.getWidth())+\"px\";\r\n        that.backgroundSize = zrUtil.clone(that.eagleEyeNode.style.backgroundSize);\r\n        that.eagleEyeNode.innerHTML = \"\";\r\n        that.selection.style.border = \"1px solid #ff0000\";\r\n        that.selection.style.cursor = \"pointer\";\r\n        that.selection.style.width = that.bigCanvas.getWidth()/that.group.width*eagleEyeNodeWidth+\"px\";\r\n        that.selection.style.height = that.bigCanvas.getHeight()/that.group.height*eagleEyeNodeHeight+\"px\";\r\n        that.selectWidth = that.selection.style.width;\r\n        that.selectHeight = that.selection.style.height;\r\n        that.selection.style.position=\"absolute\";\r\n        that.selection.style.top = 0+\"px\";\r\n        that.selection.style.left = 0+\"px\";\r\n        that.eagleEyeNode.appendChild(this.selection);\r\n    };\r\n    Minimap.prototype.updataSelection = function(offectLeft,offectTop,zoomScale,nowZoom){\r\n        var that = this;\r\n        that.zoomScale = zoomScale;\r\n        this.selection.style.width = this.selection.style.width.replace(\"px\",\"\")/zoomScale+\"px\";\r\n        this.selection.style.height = this.selection.style.height.replace(\"px\",\"\")/zoomScale+\"px\";\r\n        that.selectPosition[0] = zrUtil.clone(offectLeft)*that.ratio/nowZoom;\r\n        that.selectPosition[1] = zrUtil.clone(offectTop)*that.ratio/nowZoom;\r\n        this.selection.style.left = -that.selectPosition[0]+\"px\";\r\n        this.selection.style.top = -that.selectPosition[1]+\"px\";\r\n    };\r\n    Minimap.prototype.updataMap = function(imgSrc,newGroup){\r\n        var that = this;\r\n        that.eagleEyeNode.style.backgroundImage = \"url(\"+imgSrc+\")\";\r\n        var eagleEyeNodeWidth = newGroup.width  * that.ratio;\r\n        var eagleEyeNodeHeight = newGroup.height  * that.ratio;\r\n        that.eagleEyeNode.style.width = eagleEyeNodeWidth+\"px\";\r\n        that.eagleEyeNode.style.height = eagleEyeNodeHeight+\"px\";\r\n        that.eagleEyeNode.style.marginTop = -eagleEyeNodeHeight+\"px\";\r\n        that.eagleEyeNode.style.marginLeft = that.bigCanvas.getWidth()-eagleEyeNodeWidth+\"px\";\r\n    };\r\n    Minimap.prototype.updataSelectionPosition = function(nowGroupPosition,nowZoom){\r\n        var that = this;\r\n        that.selectPosition[0] = zrUtil.clone(nowGroupPosition[0])*that.ratio/nowZoom;\r\n        that.selectPosition[1] = zrUtil.clone(nowGroupPosition[1])*that.ratio/nowZoom;\r\n        this.selection.style.left = -that.selectPosition[0]+\"px\";\r\n        this.selection.style.top = -that.selectPosition[1]+\"px\";\r\n    };\r\n    Minimap.prototype.updataGroupPosition = function(group,nowZoom){\r\n        var that = this;\r\n        var positionX = -Number(that.selection.style.left.substring(0,that.selection.style.left.length-2))/that.ratio*nowZoom;\r\n        var positionY = -Number(that.selection.style.top.substring(0,that.selection.style.top.length-2))/that.ratio*nowZoom;\r\n        group.attr(\"position\",[positionX,positionY]);\r\n    };\r\n\r\n    module.exports = Minimap;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/minimap.js\n// module id = 64\n// module chunks = 0","/**\r\n * 工具方法类\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var Point = require(\"./Point.js\");\r\n    var Line = require(\"./LineStruct.js\");\r\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    /**\r\n     * 构造类继承关系\r\n     *\r\n     * @param {Function} clazz 源类\r\n     * @param {Function} baseClazz 基类\r\n     */\r\n    function inherits(clazz, baseClazz) {\r\n        var clazzPrototype = clazz.prototype;\r\n\r\n        function F() {}\r\n        F.prototype = baseClazz.prototype;\r\n        clazz.prototype = new F();\r\n\r\n        for (var prop in clazzPrototype) {\r\n            clazz.prototype[prop] = clazzPrototype[prop];\r\n        }\r\n        clazz.prototype.constructor = clazz;\r\n        clazz.superClass = baseClazz;\r\n    }\r\n\r\n    function getUUID() {\r\n        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),\r\n            uuid = new Array(36),\r\n            rnd = 0,\r\n            r;\r\n        for (var i = 0; i < 36; i++) {\r\n            if (i == 8 || i == 13 || i == 18 || i == 23) {\r\n                uuid[i] = '-';\r\n            } else if (i == 14) {\r\n                uuid[i] = '4';\r\n            } else {\r\n                if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;\r\n                r = rnd & 0xf;\r\n                rnd = rnd >> 4;\r\n                uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\r\n            }\r\n        }\r\n        return \"sid-\" + uuid.join('');\r\n    }\r\n\r\n\r\n    /**\r\n     * 计算两点之间的距离\r\n     *@param {Point} p1 - first {Point}\r\n     *@param {Point} p2 - second {Point}\r\n     *@return {Number} - the distance between those 2 points. It is always positive.\r\n     **/\r\n    function distance(p1, p2) {\r\n        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\r\n    }\r\n\r\n    /**\r\n     * 返回一条折线 最长的两个点\r\n     * @param  {[type]} points [description]\r\n     * @return {[type]}        [description]\r\n     */\r\n    function getMaxLineLength(points) {\r\n        var m = distance(points[0], points[1]);\r\n        var result = [points[0], points[1]];\r\n        for (var i = 1; i < points.length - 1; i++) {\r\n\r\n            if (m < distance(points[i], points[i + 1])) {\r\n                m = distance(points[i], points[i + 1])\r\n                result = [points[i], points[i + 1]];\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**Returns the length of a Polyline that would be created with a set of points\r\n     *@param {Array} v - an {Array} of {Points}\r\n     *@return {Number} - a positive number equal with total length*/\r\n    function getPolylineLength(v) {\r\n        var l = 0;\r\n        for (var i = 0; i < v.length - 1; i++) {\r\n            l += distance(v[i], v[i + 1]);\r\n        }\r\n\r\n        return l;\r\n    }\r\n\r\n\r\n    /**Returns the max of a vector\r\n     *@param {Array} v - vector of {Number}s\r\n     *@return {Number} - the maximum number from the vector or NaN if vector is empty\r\n     **/\r\n    function max(v) {\r\n        if (v.lenght == 0) {\r\n            return NaN;\r\n        } else {\r\n            var m = v[0];\r\n            for (var i = 0; i < v.length; i++) {\r\n                if (m < v[i]) {\r\n                    m = v[i];\r\n                }\r\n            }\r\n\r\n            return m;\r\n        }\r\n    }\r\n\r\n\r\n    /**Returns the min of a vector\r\n     *@param {Array} v - vector of {Number}s\r\n     *@return {Number} - the minimum number from the vector or NaN if vector is empty\r\n     *@author alex@scriptoid.com\r\n     **/\r\n    function min(v) {\r\n        if (v.lenght == 0) {\r\n            return NaN;\r\n        } else {\r\n            var m = v[0];\r\n            for (var i = 0; i < v.length; i++) {\r\n                if (m > v[i]) {\r\n                    m = v[i];\r\n                }\r\n            }\r\n\r\n            return m;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 判断 点数组 是否正交直线路径\r\n     *Tests if a vector of points is an orthogonal path (moving in multiples of 90 degrees)\r\n     *@param {Array} v - an {Array} of {Point}s\r\n     *@return {Boolean} - true if path is valid, false otherwise\r\n     **/\r\n    function orthogonalPath(v) {\r\n        if (v.length <= 1) {\r\n            return true;\r\n        }\r\n\r\n        for (var i = 0; i < v.length - 1; i++) {\r\n            if (v[i].x != v[i + 1].x && v[i].y != v[i + 1].y) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     *Test to see if 2 {Line}s intersects. They are considered finite segments\r\n     *and not the infinite lines from geometry\r\n     *@param {Line} l1 - fist line/segment\r\n     *@param {Line} l2 - last line/segment\r\n     *@return {Boolean} true - if the lines intersect or false if not\r\n     **/\r\n    function lineIntersectsLine(l1, l2) {\r\n        // check for two vertical lines\r\n        if (l1.startPoint.x == l1.endPoint.x && l2.startPoint.x == l2.endPoint.x) {\r\n            return l1.startPoint.x == l2.startPoint.x ? // if 'infinite 'lines do coincide,\r\n                // then check segment bounds for overlapping\r\n                l1.contains(l2.startPoint.x, l2.startPoint.y) ||\r\n                l1.contains(l2.endPoint.x, l2.endPoint.y) :\r\n                // lines are paralel\r\n                false;\r\n        }\r\n        // if one line is vertical, and another line is not vertical\r\n        else if (l1.startPoint.x == l1.endPoint.x || l2.startPoint.x == l2.endPoint.x) {\r\n            // let assume l2 is vertical, otherwise exchange them\r\n            if (l1.startPoint.x == l1.endPoint.x) {\r\n                var l = l1;\r\n                l1 = l2;\r\n                l2 = l;\r\n            }\r\n            // finding intersection of 'infinite' lines\r\n            // equation of the first line is y = ax + b, second: x = c\r\n            var a = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);\r\n            var b = l1.startPoint.y - a * l1.startPoint.x;\r\n            var x0 = l2.startPoint.x;\r\n            var y0 = a * x0 + b;\r\n            return l1.contains(x0, y0) && l2.contains(x0, y0);\r\n        }\r\n\r\n        // check normal case - both lines are not vertical\r\n        else {\r\n            //line equation is : y = a*x + b, b = y - a * x\r\n            var a1 = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);\r\n            var b1 = l1.startPoint.y - a1 * l1.startPoint.x;\r\n\r\n            var a2 = (l2.endPoint.y - l2.startPoint.y) / (l2.endPoint.x - l2.startPoint.x);\r\n            var b2 = l2.startPoint.y - a2 * l2.startPoint.x;\r\n\r\n            if (a1 == a2) { //paralel lines\r\n                return b1 == b2 ?\r\n                    // for coincide lines, check for segment bounds overlapping\r\n                    l1.contains(l2.startPoint.x, l2.startPoint.y) || l1.contains(l2.endPoint.x, l2.endPoint.y) :\r\n                    // not coincide paralel lines have no chance to intersect\r\n                    false;\r\n            } else { //usual case - non paralel, the 'infinite' lines intersects...we only need to know if inside the segment\r\n\r\n                /*\r\n                 * if one of the lines are vertical, then x0 is equal to their x,\r\n                 * otherwise:\r\n                 * y1 = a1 * x + b1\r\n                 * y2 = a2 * x + b2\r\n                 * => x0 = (b2 - b1) / (a1 - a2)\r\n                 * => y0 = a1 * x0 + b1\r\n                 **/\r\n                x0 = (b2 - b1) / (a1 - a2);\r\n                y0 = a1 * x0 + b1;\r\n                return l1.contains(x0, y0) && l2.contains(x0, y0);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     *Tests if a a polyline defined by a set of points intersects a rectangle\r\n     *@param {Array} points - and {Array} of {Point}s\r\n     *@param {Array} bounds - the bounds of the rectangle defined by (x1, y1, x2, y2)\r\n     *@param {Boolean} closedPolyline - incase polyline is closed figure then true, else false\r\n     *\r\n     *@return true - if line intersects the rectangle, false - if not\r\n     **/\r\n    function polylineIntersectsRectangle(points, bounds, closedPolyline) {\r\n\r\n\r\n        //get the 4 lines/segments represented by the bounds\r\n        var lines = [];\r\n        lines.push(new Line(new Point(bounds[0], bounds[1]), new Point(bounds[2], bounds[1])));\r\n        lines.push(new Line(new Point(bounds[2], bounds[1]), new Point(bounds[2], bounds[3])));\r\n        lines.push(new Line(new Point(bounds[2], bounds[3]), new Point(bounds[0], bounds[3])));\r\n        lines.push(new Line(new Point(bounds[0], bounds[3]), new Point(bounds[0], bounds[1])));\r\n\r\n        for (var k = 0; k < points.length - 1; k++) {\r\n            //create a line out of each 2 consecutive points\r\n            var tempLine = new Line(points[k], points[k + 1]);\r\n\r\n            //see if that line intersect any of the line on bounds border\r\n            for (var i = 0; i < lines.length; i++) {\r\n                if (lineIntersectsLine(tempLine, lines[i])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        //check the closed figure - that is last point connected to the first\r\n        if (closedPolyline) {\r\n            //create a line out of each 2 consecutive points\r\n            var tempLine1 = new Line(points[points.length - 1], points[0]);\r\n\r\n            //see if that line intersect any of the line on bounds border\r\n            for (var j = 0; j < lines.length; j++) {\r\n                if (lineIntersectsLine(tempLine1, lines[j])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * 计算路径的分数\r\n     * Score a ortogonal path made out of Points\r\n     *Iterates over a set of points (minimum 3)\r\n     *For each 3 points (i, i+1, i+2) :\r\n     *  - if the 3rd one is after the 2nd on the same line we add +1\r\n     *  - if the 3rd is up or down related to the 2nd we do not do anything +0\r\n     *  - if the 3rd goes back we imediatelly return -1\r\n     *@param {Array} v - an array of {Point}s\r\n     *@return {Number} - -1 if the path is wrong (goes back) or something >= 0 if is fine\r\n     *  The bigger the number the smooth the path is\r\n     **/\r\n    function scorePath(v) {\r\n        if (v.length <= 2) {\r\n            return -1;\r\n        }\r\n\r\n        var score = 0;\r\n        for (var i = 1; i < v.length - 1; i++) {\r\n            if (v[i - 1].x == v[i].x && v[i].x == v[i + 1].x) { //on the same vertical\r\n                if (signum(v[i + 1].y - v[i].y) == signum(v[i].y - v[i - 1].y)) { //same direction\r\n                    score++;\r\n                } else { //going back - no good\r\n                    return -1;\r\n                }\r\n            } else if (v[i - 1].y == v[i].y && v[i].y == v[i + 1].y) { //on the same horizontal\r\n                if (signum(v[i + 1].x - v[i].x) == signum(v[i].x - v[i - 1].x)) { //same direction\r\n                    score++;\r\n                } else { //going back - no good\r\n                    return -1;\r\n                }\r\n            } else { //not on same vertical nor horizontal\r\n                score--;\r\n            }\r\n        }\r\n\r\n        return score;\r\n    }\r\n\r\n    /**\r\n     * 返回数字符号（+ -)\r\n     * Returns the sign of a number\r\n     *@param {Number} x - the number\r\n     *@returns {Number}\r\n     *@see <a href=\"http://en.wikipedia.org/wiki/Sign_function\">http://en.wikipedia.org/wiki/Sign_function</a>\r\n     **/\r\n    function signum(x) {\r\n        if (x > 0)\r\n            return 1;\r\n        else if (x < 0)\r\n            return -1;\r\n        else\r\n            return 0;\r\n    }\r\n\r\n    /**\r\n     * 判断 点数组 是不是有效路径（没有回路）\r\n     *Tests if a vector of points is a valid path (not going back)\r\n     *There are a few problems here. If you have p1, p2, p3 and p4 and p2 = p3 you need to ignore that\r\n     *@param {Array} v - an {Array} of {Point}s\r\n     *@return {Boolean} - true if path is valid, false otherwise\r\n     **/\r\n    function forwardPath(v) {\r\n        if (v.length <= 2) {\r\n            return true;\r\n        }\r\n\r\n        for (var i = 0; i < v.length - 2; i++) {\r\n            if (v[i].x == v[i + 1].x && v[i + 1].x == v[i + 2].x) { //on the same vertical\r\n                if (signum(v[i + 1].y - v[i].y) != 0) { //test only we have a progressing path\r\n                    if (signum(v[i + 1].y - v[i].y) == -1 * signum(v[i + 2].y - v[i + 1].y)) { //going back (ignore zero)\r\n                        return false;\r\n                    }\r\n                }\r\n            } else if (v[i].y == v[i + 1].y && v[i + 1].y == v[i + 2].y) { //on the same horizontal\r\n                if (signum(v[i + 1].x - v[i].x) != 0) { //test only we have a progressing path\r\n                    if (signum(v[i + 1].x - v[i].x) == -1 * signum(v[i + 2].x - v[i + 1].x)) { //going back (ignore zero)\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * 将[x:0,y:0]转化为[0, 0]  给zrender使用\r\n     * @param  {[type]} points [description]\r\n     * @param  {[type]} isRevert [description]\r\n     * @return {[type]}        [description]\r\n     */\r\n    function traslatePoints(points, isRevert) {\r\n        var newPoints = [];\r\n        if (isRevert) {\r\n            for (var i = 0; i < points.length; i++) {\r\n                var point = points[i];\r\n                newPoints.push(new Point(point[0], point[1]));\r\n            }\r\n            return newPoints;\r\n        } else {\r\n            for (var j = 0; j < points.length; j++) {\r\n                var point1 = points[j];\r\n                newPoints.push([point1.x, point1.y]);\r\n            }\r\n            return newPoints;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    function rotationMatrix(angle) {\r\n        var mReturn = [\r\n            [Math.cos(angle), -Math.sin(angle), 0],\r\n            [Math.sin(angle), Math.cos(angle), 0],\r\n            [0, 0, 1]\r\n        ];\r\n        return mReturn;\r\n    }\r\n\r\n    function translationMatrix(dx, dy) {\r\n        return [\r\n            [1, 0, dx],\r\n            [0, 1, dy],\r\n            [0, 0, 1]\r\n        ];\r\n    }\r\n\r\n    function scaleMatrix(sx, sy) {\r\n        if (sy == null) {\r\n            sy = sx;\r\n        }\r\n        return [\r\n            [sx, 0, 0],\r\n            [0, sy, 0],\r\n            [0, 0, 1]\r\n        ];\r\n    }\r\n\r\n    /** It will return the end point of a line on a given angle (clockwise).\r\n     * @param {Point} startPoint - the start of the line\r\n     * @param {Number} length - the length of the line\r\n     * @param {Number} angle - the angle of the line in radians\r\n     * @return {Point} - the endPoint of the line\r\n     */\r\n    function getEndPoint(startPoint, length, angle) {\r\n        var endPoint = startPoint.clone();\r\n        endPoint.transform(translationMatrix(-startPoint.x, -startPoint.y));\r\n        endPoint.y -= length;\r\n        endPoint.transform(rotationMatrix(angle));\r\n        endPoint.transform(translationMatrix(startPoint.x, startPoint.y));\r\n        return endPoint;\r\n    }\r\n\r\n    /**\r\n     * 获取获取两个图形的外面四个连接点\r\n     * @param  {[type]} rect [description]\r\n     * @param  {[type]} node [description]\r\n     * @return {[type]}      [description]\r\n     */\r\n    function getConnectorPoints(rect, node) {\r\n        node = node || {};\r\n        var boundingRect = zrUtil.clone(rect.boundingRect || rect);\r\n        var rotation = node.rotation;\r\n        var points = {\r\n            left: new Point(boundingRect.x, boundingRect.y + boundingRect.height / 2), //矩形 左中的位置\r\n            top: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y), //矩形 上中的位置\r\n            right: new Point(boundingRect.x + boundingRect.width, boundingRect.y + boundingRect.height / 2), //矩形 右中的位置\r\n            bottom: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y + boundingRect.height), //矩形 下中的位置\r\n            center: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y + boundingRect.height / 2) //中间位置\r\n\r\n        };\r\n        if (Object.keys(node).length > 0 && Math.abs(rotation) > 0) {\r\n            var rectNew = rect.boundingRect ? rect : getRect(node);\r\n            var center = { x: rectNew.x, y: rectNew.y }; // 中心点\r\n            Object.keys(points).forEach(function(key) {\r\n                var value = points[key];\r\n                var x0 = center.x - value.x;\r\n                var y0 = center.y - value.y;\r\n                var sin = Math.sin(-rotation);\r\n                var cos = Math.cos(-rotation);\r\n                var position_n_x = center.x - (x0 * cos - y0 * sin);\r\n                var position_n_y = center.y - (x0 * sin + y0 * cos);\r\n                points[key].x = position_n_x;\r\n                points[key].y = position_n_y;\r\n            });\r\n        }\r\n        return points;\r\n    }\r\n\r\n    /**\r\n     * 获取节点外面四个控制点和旋转点\r\n     * @param  {[type]} node [description]\r\n     * @return {[type]}      [description]\r\n     */\r\n    function getConnectorControls(rect, node) {\r\n        node = node || {};\r\n        var boundingRect = zrUtil.clone(rect.boundingRect);\r\n        var rotation = node.rotation;\r\n        var controls = {\r\n            tl: new Point(boundingRect.x, boundingRect.y), //矩形 左上角位置\r\n            tc: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y - 4), //矩形 上中位置\r\n            tr: new Point(boundingRect.x + boundingRect.width, boundingRect.y), //矩形 右上角位置\r\n            bl: new Point(boundingRect.x, boundingRect.y + boundingRect.height), //矩形 左下角\r\n            br: new Point(boundingRect.x + boundingRect.width, boundingRect.y + boundingRect.height), //矩形 右下角位置\r\n            mtr: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y - 20) // 旋转点位置\r\n        };\r\n        if (Object.keys(node).length > 0 && Math.abs(rotation) > 0) {\r\n            var rectNew = rect;\r\n            var center = { x: rectNew.x, y: rectNew.y }; // 中心点\r\n            Object.keys(controls).forEach(function(key) {\r\n                var value = controls[key];\r\n                var x0 = center.x - value.x;\r\n                var y0 = center.y - value.y;\r\n                var sin = Math.sin(-rotation);\r\n                var cos = Math.cos(-rotation);\r\n                var position_n_x = center.x - (x0 * cos - y0 * sin);\r\n                var position_n_y = center.y - (x0 * sin + y0 * cos);\r\n                controls[key].x = position_n_x;\r\n                controls[key].y = position_n_y;\r\n            });\r\n        }\r\n        return controls;\r\n    }\r\n\r\n    /**\r\n     * 根据中心点和旋转弧度，计算旋转后的点坐标\r\n     * @param  {[object|array]} points [原坐标]\r\n     * @param  {[object]}       center [中心点]\r\n     * @param  {[number]}       rotation [旋转弧度]\r\n     * @return {[type]}      [description]\r\n     */\r\n    function calculatePoints(points, center, rotation) {\r\n        var x = Array.isArray(points) ? points[0] : points.x;\r\n        var y = Array.isArray(points) ? points[1] : points.y;\r\n        var x0 = center.x - x;\r\n        var y0 = center.y - y;\r\n        var sin = Math.sin(-rotation);\r\n        var cos = Math.cos(-rotation);\r\n        var position_n_x = center.x - (x0 * cos - y0 * sin);\r\n        var position_n_y = center.y - (x0 * sin + y0 * cos);\r\n        if (Array.isArray(points)) {\r\n            return [position_n_x, position_n_y];\r\n        }\r\n        return {\r\n            x: position_n_x,\r\n            y: position_n_y\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取获取两个图形的外面四个连接点\r\n     * @param  {[type]} node [description]\r\n     * @return {[type]}      [description]\r\n     */\r\n    function getSoltPoints(node) {\r\n        return [\r\n            //top\r\n            [Math.round(node.getRect().width / 3 /10)*10, 0 ],\r\n            [Math.round(2*node.getRect().width / 3 /10)*10, 0 ],\r\n            //right\r\n            [node.getRect().width, Math.round(node.getRect().height / 3 /10)*10 ],\r\n            [node.getRect().width, Math.round(2*node.getRect().height / 3 /10)*10 ],\r\n            //bottom\r\n            [Math.round(node.getRect().width / 3 /10)*10, node.getRect().height ],\r\n            [Math.round(2*node.getRect().width / 3 /10)*10, node.getRect().height ],\r\n            //left\r\n            [0, Math.round(node.getRect().height / 3 /10)*10 ],\r\n            [0, Math.round(2*node.getRect().height / 3 /10)*10 ]\r\n\r\n        ]\r\n    }\r\n\r\n    /**\r\n     * 计算 p1 p2两点所连接的直线的角度\r\n     * @param  {[type]} p1 [description]\r\n     * @param  {[type]} p2 [description]\r\n     * @return {[type]}    [description]\r\n     */\r\n    function tangentRotation(p1, p2) {\r\n        return -Math.PI / 2 - Math.atan2(\r\n            p2.y - p1.y, p2.x - p1.x\r\n        );\r\n    }\r\n\r\n    /**\r\n     * 判断3点是否在一条直线上\r\n     * Tests if 3 points are coliniar with matrix determinants.\r\n     * If the determinat of matrix\r\n     * /         \\\r\n     * | x1 y1 1 |\r\n     * | x2 y2 1 |\r\n     * | x3 y3 1 |\r\n     * \\         /\r\n     * is zero it means that the points are colinear\r\n     *@param {Point} p1 - first point\r\n     *@param {Point} p2 - second point\r\n     *@param {Point} p3 - third point\r\n     * @param {Number} precission\r\n     *@return {Boolean} - true if coliniar and false if not\r\n     *@author Alex\r\n     *@see http://en.wikipedia.org/wiki/Determinant\r\n     *@see https://people.richland.edu/james/lecture/m116/matrices/applications.html\r\n     **/\r\n    function collinearity(p1, p2, p3, precission) {\r\n        var determinant = (p1.x * p2.y + p1.y * p3.x + p2.x * p3.y) - (p2.y * p3.x + p1.y * p2.x + p1.x * p3.y);\r\n\r\n        if (precission) {\r\n            return Math.abs(determinant) <= precission;\r\n        } else {\r\n            return determinant === 0;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 四舍五入 保存decimals的小数\r\n     **/\r\n    function enhancedRound(number, decimals) {\r\n        return Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);\r\n    }\r\n\r\n    /**\r\n     * 获取两点之间的长度\r\n     **/\r\n    function getLength(startPoint, endPoint) {\r\n        return Math.sqrt(Math.pow(startPoint.x - endPoint.x, 2) + Math.pow(startPoint.y - endPoint.y, 2));\r\n    }\r\n\r\n    /**\r\n     * 获取角度\r\n     * @param  {[type]} centerPoint  [description]\r\n     * @param  {[type]} outsidePoint [description]\r\n     * @param  {[type]} round        [description]\r\n     * @return {[type]}              [description]\r\n     */\r\n    function getAngle(centerPoint, outsidePoint, round) {\r\n        centerPoint.x = enhancedRound(centerPoint.x, 5);\r\n        centerPoint.y = enhancedRound(centerPoint.y, 5);\r\n        outsidePoint.x = enhancedRound(outsidePoint.x, 5);\r\n        outsidePoint.y = enhancedRound(outsidePoint.y, 5);\r\n        var angle = Math.atan((outsidePoint.x - centerPoint.x) / (outsidePoint.y - centerPoint.y));\r\n        angle = -angle;\r\n\r\n        //endAngle+=90;\r\n        if (outsidePoint.x >= centerPoint.x && outsidePoint.y >= centerPoint.y) {\r\n            angle += Math.PI;\r\n        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y >= centerPoint.y) {\r\n            angle += Math.PI;\r\n        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y <= centerPoint.y) {\r\n            angle += Math.PI * 2;\r\n        }\r\n        while (angle >= Math.PI * 2) {\r\n            angle -= Math.PI * 2;\r\n        }\r\n        if (isNaN(angle)) { //Nan\r\n            angle = 0; //we are at center point;\r\n        }\r\n        if (round) {\r\n            angle = Math.round(angle / round) * round\r\n        }\r\n        return angle;\r\n    }\r\n\r\n    function getRect(node, isCalcParent) {\r\n        var clipPath = node.clipPath;\r\n        var boundingRect = node.getBoundingRect();\r\n        // 节点裁剪后，以裁剪节点包围盒为准\r\n        if (clipPath) {\r\n            boundingRect = clipPath.getBoundingRect();\r\n        }\r\n        //创建最小包围盒虚线\r\n        var points = [];\r\n        points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n        points[1] = [boundingRect.width / 2, -boundingRect.height / 2];\r\n        points[2] = [boundingRect.width / 2, boundingRect.height / 2];\r\n        points[3] = [-boundingRect.width / 2, boundingRect.height / 2];\r\n        points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n\r\n        var positionX = node.position[0];\r\n        var positionY = node.position[1];\r\n        //这里要循环判断一把 有没有父节点 并且父节点不是根节点 然后进行相加\r\n        if (node.parent && node.parent.type === \"GroupNode\" && isCalcParent) {\r\n            positionX = positionX + node.parent.position[0];\r\n            positionY = positionY + node.parent.position[1];\r\n        }\r\n\r\n        var boundRect = new BoundingRect(\r\n                Number(positionX + boundingRect.x),   //注: 因事件为圆形  所以 x y 为圆心的位置  包围矩形要减去宽度一半\r\n                Number(positionY + boundingRect.y),\r\n                Number(boundingRect.width),\r\n                Number(boundingRect.height)\r\n            );\r\n        //中心点\r\n        var cx = Number(positionX) + Number(boundingRect.width) / 2 + Number(boundingRect.x);\r\n        var cy = Number(positionY) + Number(boundingRect.height) / 2 + Number(boundingRect.y);\r\n        return {\r\n            x: Number(cx),\r\n            y: Number(cy),\r\n            width: Number(boundingRect.width),\r\n            height: Number(boundingRect.height),\r\n            points: points,\r\n            boundingRect: boundRect\r\n        };\r\n    }\r\n\r\n    var StackedMap = {\r\n        createNew: function() {\r\n            var stack = [];\r\n\r\n            return {\r\n                add: function(key, value) {\r\n                    var arrKey = this.get(key);\r\n                    arrKey.push(value)\r\n\r\n                },\r\n                get: function(key) {\r\n                    for (var i = 0; i < stack.length; i++) {\r\n                        if (key == stack[i].key) {\r\n                            return stack[i].value;\r\n                        }\r\n                    }\r\n                    //如果没有找到的话，则创建一个新的数组\r\n                    var value = [];\r\n                    stack.push({ key: key, value: value });\r\n                    return value;\r\n                },\r\n                keys: function() {\r\n                    var keys = [];\r\n                    for (var i = 0; i < stack.length; i++) {\r\n                        keys.push(stack[i].key);\r\n                    }\r\n                    return keys;\r\n                },\r\n                top: function() {\r\n                    return stack[stack.length - 1];\r\n                },\r\n                remove: function(key) {\r\n                    var idx = -1;\r\n                    for (var i = 0; i < stack.length; i++) {\r\n                        if (key == stack[i].key) {\r\n                            idx = i;\r\n                            break;\r\n                        }\r\n                    }\r\n                    return stack.splice(idx, 1)[0];\r\n                },\r\n                removeItem: function(key, item) {\r\n                    var arrKey = this.get(key);\r\n                    var index = zrUtil.indexOf(arrKey, item);\r\n                    arrKey.splice(index, 1);\r\n\r\n                },\r\n                removeTop: function() {\r\n                    return stack.splice(stack.length - 1, 1)[0];\r\n                },\r\n                length: function() {\r\n                    return stack.length;\r\n                },\r\n                clear: function() {\r\n                    stack.splice(0, stack.length);\r\n                }\r\n            };\r\n        }\r\n    };\r\n\r\n    function randomColor() {\r\n        var arrHex = [\"0\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\"],\r\n            strHex = \"#\",\r\n            index;\r\n        for (var i = 0; i < 6; i++) {\r\n            index = Math.round(Math.random() * 15);\r\n            strHex += arrHex[index];\r\n        }\r\n        return strHex;\r\n    }\r\n\r\n    function isUndefined(obj) {\r\n        return obj === void 0;\r\n    }\r\n\r\n    function collinearReduction (v) {\r\n        var r = [];\r\n\r\n        if(v.length < 3){\r\n            return Point.cloneArray(v);\r\n        }\r\n\r\n        r.push( v[0].clone() );\r\n        for(var i=1; i < v.length-1; i++){\r\n            if( (v[i-1].x == v[i].x && v[i].x == v[i+1].x)  ||  (v[i-1].y == v[i].y && v[i].y == v[i+1].y) )\r\n            {\r\n                continue;\r\n            }\r\n            else{\r\n                r.push( v[i].clone() );\r\n            }\r\n        }\r\n        r.push( v[v.length-1].clone() );\r\n\r\n        return r;\r\n    }\r\n\r\n    // By default, Underscore uses ERB-style template delimiters, change the\r\n    // following template settings to use alternative delimiters.\r\n    var templateSettings = {\r\n        evaluate: /<%([\\s\\S]+?)%>/g,\r\n        interpolate: /<%=([\\s\\S]+?)%>/g,\r\n        escape: /<%-([\\s\\S]+?)%>/g\r\n    };\r\n\r\n    // When customizing `templateSettings`, if you don't want to define an\r\n    // interpolation, evaluation or escaping regex, we need one that is\r\n    // guaranteed not to match.\r\n    var noMatch = /(.)^/;\r\n\r\n    // Certain characters need to be escaped so that they can be put into a\r\n    // string literal.\r\n    var escapes = {\r\n        \"'\": \"'\",\r\n        '\\\\': '\\\\',\r\n        '\\r': 'r',\r\n        '\\n': 'n',\r\n        '\\u2028': 'u2028',\r\n        '\\u2029': 'u2029'\r\n    };\r\n\r\n    var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\r\n\r\n    var escapeChar = function(match) {\r\n        return '\\\\' + escapes[match];\r\n    };\r\n\r\n    // JavaScript micro-templating, similar to John Resig's implementation.\r\n    // Underscore templating handles arbitrary delimiters, preserves whitespace,\r\n    // and correctly escapes quotes within interpolated code.\r\n    // NB: `oldSettings` only exists for backwards compatibility.\r\n    function template(text, settings, oldSettings) {\r\n        if (!settings && oldSettings) settings = oldSettings;\r\n        settings = settings || {};\r\n        settings = zrUtil.defaults(settings, templateSettings, true);\r\n\r\n        // Combine delimiters into one regular expression via alternation.\r\n        var matcher = RegExp([\r\n            (settings.escape || noMatch).source,\r\n            (settings.interpolate || noMatch).source,\r\n            (settings.evaluate || noMatch).source\r\n        ].join('|') + '|$', 'g');\r\n\r\n        // Compile the template source, escaping string literals appropriately.\r\n        var index = 0;\r\n        var source = \"__p+='\";\r\n        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\r\n            source += text.slice(index, offset).replace(escaper, escapeChar);\r\n            index = offset + match.length;\r\n\r\n            if (escape) {\r\n                source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\r\n            } else if (interpolate) {\r\n                source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\r\n            } else if (evaluate) {\r\n                source += \"';\\n\" + evaluate + \"\\n__p+='\";\r\n            }\r\n\r\n            // Adobe VMs need the match returned to produce the correct offest.\r\n            return match;\r\n        });\r\n        source += \"';\\n\";\r\n\r\n        // If a variable is not specified, place data values in local scope.\r\n        if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\r\n\r\n        source = \"var __t,__p='',__j=Array.prototype.join,\" +\r\n            \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\r\n            source + 'return __p;\\n';\r\n\r\n        try {\r\n            var render = new Function(settings.variable || 'obj', source);\r\n        } catch (e) {\r\n            e.source = source;\r\n            throw e;\r\n        }\r\n\r\n        var template = function(data) {\r\n            return render.call(this, data);\r\n        };\r\n\r\n        // Provide the compiled source as a convenience for precompilation.\r\n        var argument = settings.variable || 'obj';\r\n        template.source = 'function(' + argument + '){\\n' + source + '}';\r\n\r\n        return template;\r\n    }\r\n\r\n    function isEmpty(obj) {\r\n        if (obj == null) return true;\r\n        if (zrUtil.isArrayLike(obj) && (zrUtil.isArray(obj) || zrUtil.isString(obj))) return obj.length === 0;\r\n    }\r\n    function mergeOpt(target, source, overwrite, exclude) {\r\n        // We should escapse that source is string\r\n        // and enter for ... in ...\r\n        if (!zrUtil.isObject(source) || !zrUtil.isObject(target)) {\r\n          return overwrite ? zrUtil.clone(source) : target;\r\n        }\r\n\r\n        for (var key in source) {\r\n          if (source.hasOwnProperty(key)) {\r\n            var targetProp = target[key];\r\n            var sourceProp = source[key];\r\n\r\n            if (zrUtil.isObject(sourceProp) && zrUtil.isObject(targetProp) && !zrUtil.isArray(sourceProp) && !zrUtil.isArray(targetProp) && !zrUtil.isDom(sourceProp) && !zrUtil.isDom(targetProp) && !zrUtil.isBuiltInObject(sourceProp) && !zrUtil.isBuiltInObject(targetProp) && !zrUtil.isPrimitive(sourceProp) && !zrUtil.isPrimitive(targetProp)) {\r\n              // 如果需要递归覆盖，就递归调用merge\r\n              mergeOpt(targetProp, sourceProp, overwrite, exclude);\r\n            } else if (overwrite || !(key in target)) {\r\n              // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\r\n              // NOTE，在 target[key] 不存在的时候也是直接覆盖\r\n                if (key !== exclude) {\r\n                    target[key] = zrUtil.clone(source[key], true);\r\n                }\r\n            }\r\n          }\r\n        }\r\n        return target;\r\n    }\r\n    function Class() {}\r\n    Class.extend = function(proto) {\r\n        var base = function() {},\r\n            member,\r\n            that = this,\r\n            subclass = proto && proto.init ? proto.init : function () {\r\n                that.apply(this, arguments);\r\n            },\r\n            fn;\r\n\r\n        base.prototype = that.prototype;\r\n        fn = subclass.fn = subclass.prototype = new base();\r\n\r\n        for (member in proto) {\r\n            if (proto[member] != null && proto[member].constructor === Object) {\r\n                // Merge object members\r\n                fn[member] = zrUtil.mergeAll([{}, base.prototype[member], proto[member]],true);\r\n            } else {\r\n                fn[member] = proto[member];\r\n            }\r\n        }\r\n\r\n        fn.constructor = subclass;\r\n        subclass.extend = that.extend;\r\n\r\n        return subclass;\r\n    };\r\n\r\n    module.exports = {\r\n        inherits: inherits,\r\n        getUUID: getUUID,\r\n        distance: distance,\r\n        getPolylineLength: getPolylineLength,\r\n        max: max,\r\n        min: min,\r\n        isEmpty: isEmpty,\r\n        mergeOpt: mergeOpt,\r\n        orthogonalPath: orthogonalPath,\r\n        polylineIntersectsRectangle: polylineIntersectsRectangle,\r\n        scorePath: scorePath,\r\n        forwardPath: forwardPath,\r\n        traslatePoints: traslatePoints,\r\n        getEndPoint: getEndPoint,\r\n        getConnectorPoints: getConnectorPoints,\r\n        getConnectorControls: getConnectorControls,\r\n        calculatePoints: calculatePoints,\r\n        tangentRotation: tangentRotation,\r\n        collinearity: collinearity,\r\n        translationMatrix: translationMatrix,\r\n        scaleMatrix: scaleMatrix,\r\n        round: enhancedRound,\r\n        getLength: getLength,\r\n        getAngle: getAngle,\r\n        getRect: getRect,\r\n        StackedMap: StackedMap,\r\n        getMaxLineLength: getMaxLineLength,\r\n        randomColor: randomColor,\r\n        template: template,\r\n        isUndefined: isUndefined,\r\n        getSoltPoints:getSoltPoints,\r\n        collinearReduction: collinearReduction,\r\n        Class:Class\r\n    };\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/util.js\n// module id = 65\n// module chunks = 0","\r\n\r\n    /**\r\n      * Creates an instance of Point\r\n      *\r\n      *\r\n      * @constructor\r\n      * @this {Point}\r\n      * @param {Number} x The x coordinate of point.\r\n      * @param {Number} y The y coordinate of point.\r\n      * Note: Even if it is named Point this class should be named Dot as Dot is closer\r\n      * then Point from math perspective.\r\n      **/\r\n    function Point(x, y){\r\n        /**The x coordinate of point*/\r\n        this.x = x;\r\n\r\n        /**The y coordinate of point*/\r\n        this.y = y;\r\n\r\n\r\n    }\r\n\r\n    /**Creates a {Point} out of JSON parsed object\r\n     *@param {JSONObject} o - the JSON parsed object\r\n     *@return {Point} a newly constructed Point\r\n     **/\r\n    Point.load = function(o){\r\n        var newPoint = new Point(Number(o.x), Number(o.y));\r\n        return newPoint;\r\n    };\r\n\r\n\r\n    /**Creates an array of points from an array of {JSONObject}s\r\n     *@param {Array} v - the array of JSONObjects\r\n     *@return an {Array} of {Point}s\r\n     **/\r\n    Point.loadArray = function(v){\r\n        var newPoints = [];\r\n        for(var i=0; i< v.length; i++){\r\n            newPoints.push(Point.load(v[i]));\r\n        }\r\n        return newPoints;\r\n    };\r\n\r\n\r\n    /**Clones an array of points\r\n     *@param {Array} v - the array of {Point}s\r\n     *@return an {Array} of {Point}s\r\n     **/\r\n    Point.cloneArray = function(v){\r\n        var newPoints = [];\r\n        for(var i=0; i< v.length; i++){\r\n            newPoints.push(v[i].clone());\r\n        }\r\n        return newPoints;\r\n    };\r\n\r\n    Point.prototype = {\r\n        constructor : Point,\r\n\r\n        transform:function(matrix){\r\n            var oldX = this.x;\r\n            var oldY = this.y;\r\n            this.x = matrix[0][0] * oldX + matrix[0][1] * oldY + matrix[0][2];\r\n            this.y = matrix[1][0] * oldX + matrix[1][1] * oldY + matrix[1][2];\r\n        },\r\n\r\n        /**Tests if this point is similar to other point\r\n         *@param {Point} anotherPoint - the other point\r\n         **/\r\n        equals:function(anotherPoint){\r\n            if(! (anotherPoint instanceof Point) ){\r\n                return false;\r\n            }\r\n            return (this.x == anotherPoint.x)\r\n            && (this.y == anotherPoint.y)\r\n        },\r\n\r\n        /**Clone current Point\r\n         **/\r\n        clone: function(){\r\n            var newPoint = new Point(this.x, this.y);\r\n            return newPoint;\r\n        },\r\n\r\n        add: function(point) {\r\n            this.x = this.x + point.x;\r\n            this.y = this.y + point.y;\r\n            return this;\r\n        },\r\n\r\n        /**Tests to see if a point (x, y) is within a range of current Point\r\n         *@param {Numeric} x - the x coordinate of tested point\r\n         *@param {Numeric} y - the x coordinate of tested point\r\n         *@param {Numeric} radius - the radius of the vicinity\r\n         **/\r\n        near:function(x, y, radius){\r\n            var distance = Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));\r\n\r\n            return (distance <= radius);\r\n        },\r\n\r\n        contains: function(x,y){\r\n            return this.x == x && this.y == y;\r\n        },\r\n\r\n        toString:function(){\r\n            return '[' + this.x + ',' + this.y + ']';\r\n        },\r\n\r\n        getPoints:function(){\r\n            return [this];\r\n        }\r\n    };\r\n    module.exports = Point;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/Point.js\n// module id = 66\n// module chunks = 0","\r\n\r\n    /**\r\n      * Creates an instance of a Line. A Line is actually a segment and not a pure\r\n      * geometrical Line\r\n      *\r\n      * @constructor\r\n      * @this {Line}\r\n      * @param {Point} startPoint - starting point of the line\r\n      * @param {Point} endPoint - the ending point of the line\r\n      **/\r\n    function Line(startPoint, endPoint){\r\n        /**Starting {@link Point} of the line*/\r\n        this.startPoint = startPoint;\r\n\r\n        /**Ending {@link Point} of the line*/\r\n        this.endPoint = endPoint;\r\n\r\n        /**Serialization type*/\r\n        this.oType = 'Line'; //object type used for JSON deserialization\r\n    }\r\n\r\n    /**Creates a {Line} out of JSON parsed object\r\n     *@param {JSONObject} o - the JSON parsed object\r\n     *@return {Line} a newly constructed Line\r\n     **/\r\n    Line.load = function(o){\r\n        var newLine = new Line(\r\n            Point.load(o.startPoint),\r\n            Point.load(o.endPoint)\r\n        );\r\n\r\n        return newLine;\r\n    };\r\n\r\n    Line.prototype = {\r\n        contructor: Line,\r\n\r\n\r\n\r\n        clone:function(){\r\n            var ret = new Line(this.startPoint.clone(), this.endPoint.clone());\r\n            return ret;\r\n        },\r\n\r\n        equals:function(anotherLine){\r\n            if(!anotherLine instanceof Line){\r\n                return false;\r\n            }\r\n            return this.startPoint.equals(anotherLine.startPoint)\r\n            && this.endPoint.equals(anotherLine.endPoint)\r\n        },\r\n\r\n        /** Tests to see if a point belongs to this line (not as infinite line but more like a segment)\r\n         * Algorithm: Compute line's equation and see if (x, y) verifies it.\r\n         * @param {Number} x - the X coordinates\r\n         * @param {Number} y - the Y coordinates\r\n         **/\r\n        contains: function(x, y){\r\n            // if the point is inside rectangle bounds of the segment\r\n            if (Math.min(this.startPoint.x, this.endPoint.x) <= x\r\n                && x <= Math.max(this.startPoint.x, this.endPoint.x)\r\n                && Math.min(this.startPoint.y, this.endPoint.y) <= y\r\n                && y <= Math.max(this.startPoint.y, this.endPoint.y)) {\r\n\r\n                // check for vertical line\r\n                if (this.startPoint.x == this.endPoint.x) {\r\n                    return x == this.startPoint.x;\r\n                } else { // usual (not vertical) line can be represented as y = a * x + b\r\n                    var a = (this.endPoint.y - this.startPoint.y) / (this.endPoint.x - this.startPoint.x);\r\n                    var b = this.startPoint.y - a * this.startPoint.x;\r\n                    return y == a * x + b;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        },\r\n\r\n        /*\r\n         *See if we are near a {Line} by a certain radius (also includes the extremities into computation)\r\n         *@param {Number} x - the x coordinates\r\n         *@param {Number} y - the y coordinates\r\n         *@param {Number} radius - the radius to search for\r\n         *@see http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n         *@see \"Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227\"\r\n         **/\r\n        near:function(x,y,radius){\r\n\r\n            if(this.endPoint.x === this.startPoint.x){ //Vertical line, so the vicinity area is a rectangle\r\n                return ( (this.startPoint.y-radius<=y && this.endPoint.y+radius>=y)\r\n                        || (this.endPoint.y-radius<=y && this.startPoint.y+radius>=y))\r\n                && x > this.startPoint.x - radius && x < this.startPoint.x + radius ;\r\n            }\r\n\r\n            if(this.startPoint.y === this.endPoint.y){ //Horizontal line, so the vicinity area is a rectangle\r\n                return ( (this.startPoint.x - radius<=x && this.endPoint.x+radius>=x)\r\n                        || (this.endPoint.x-radius<=x && this.startPoint.x+radius>=x))\r\n                        && y>this.startPoint.y-radius && y<this.startPoint.y+radius ;\r\n            }\r\n\r\n\r\n            var startX = Math.min(this.endPoint.x,this.startPoint.x);\r\n            var startY = Math.min(this.endPoint.y,this.startPoint.y);\r\n            var endX = Math.max(this.endPoint.x,this.startPoint.x);\r\n            var endY = Math.max(this.endPoint.y,this.startPoint.y);\r\n\r\n            /*We will compute the distance from point to the line\r\n             * by using the algorithm from\r\n             * http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n             * */\r\n\r\n            //First we need to find a,b,c of the line equation ax + by + c = 0\r\n            var a = this.endPoint.y - this.startPoint.y;\r\n            var b = this.startPoint.x - this.endPoint.x;\r\n            var c = -(this.startPoint.x * this.endPoint.y - this.endPoint.x * this.startPoint.y);\r\n\r\n            //Secondly we get the distance \"Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227\"\r\n            var d = Math.abs( (a*x + b*y + c) / Math.sqrt(Math.pow(a,2) + Math.pow(b,2)) );\r\n\r\n            //Thirdly we get coordinates of closest line's point to target point\r\n            //http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Cartesian_coordinates\r\n            var closestX = (b * (b*x - a*y) - a*c) / ( Math.pow(a,2) + Math.pow(b,2) );\r\n            var closestY = (a * (-b*x + a*y) - b*c) / ( Math.pow(a,2) + Math.pow(b,2) );\r\n\r\n            var r = ( d <= radius && endX>=closestX && closestX>=startX && endY>=closestY && closestY>=startY ) //the projection of the point falls INSIDE of the segment\r\n                || this.startPoint.near(x,y,radius) || this.endPoint.near(x,y,radius); //the projection of the point falls OUTSIDE of the segment\r\n\r\n            return  r;\r\n\r\n        },\r\n\r\n        /**we need to create a new array each time, or we will affect the actual shape*/\r\n        getPoints:function(){\r\n            var points = [];\r\n            points.push(this.startPoint);\r\n            points.push(this.endPoint);\r\n            return points;\r\n        },\r\n\r\n        /**Return the {Point} corresponding the t certain t value\r\n         * @param {Number} t the value of parameter t, where t in [0,1], t is like a percent*/\r\n        getPoint: function(t){\r\n            var Xp = t * (this.endPoint.x - this.startPoint.x) + this.startPoint.x;\r\n            var Yp = t * (this.endPoint.y - this.startPoint.y) + this.startPoint.y;\r\n\r\n            return new Point(Xp, Yp);\r\n        },\r\n\r\n        // /**\r\n        //  * Returns the middle of the line\r\n        //  * @return {Point} the middle point\r\n        //  * */\r\n        // getMiddle : function(){\r\n        //     return Util.getMiddle(this.startPoint, this.endPoint);\r\n        // },\r\n\r\n\r\n        // getLength : function(){\r\n        //     return Util.getLength(this.startPoint, this.endPoint);\r\n        // },\r\n\r\n        // /**\r\n        //  *Get bounds for this line\r\n        //  *@author Alex Gheorghiu <alex@scriptoid.com>\r\n        //  **/\r\n        // getBounds:function(){\r\n        //     return Util.getBounds(this.getPoints());\r\n        // },\r\n\r\n        /**String representation*/\r\n        toString:function(){\r\n            return 'line(' + this.startPoint + ',' + this.endPoint + ')';\r\n        }\r\n    };\r\n    module.exports = Line;\r\n\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/LineStruct.js\n// module id = 67\n// module chunks = 0","'use strict';\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    var apiList = [\r\n        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction',\r\n        'on', 'off', 'trigger', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption',\r\n        \"remove\", \"_getParentZr\", \"changeSelectConnectorType\",\"_addGroupNode\"\r\n    ];\r\n\r\n    function ExtensionAPI(instance) {\r\n        zrUtil.each(apiList, function (name) {\r\n            this[name] = zrUtil.bind(instance[name], instance);\r\n        }, this);\r\n    }\r\n\r\n    module.exports = ExtensionAPI;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/ExtensionApi.js\n// module id = 68\n// module chunks = 0","var guid = require(\"./core/guid\");\n\nvar env = require(\"./core/env\");\n\nvar zrUtil = require(\"./core/util\");\n\nvar Handler = require(\"./Handler\");\n\nvar Storage = require(\"./Storage\");\n\nvar Painter = require(\"./Painter\");\n\nvar Animation = require(\"./animation/Animation\");\n\nvar HandlerProxy = require(\"./dom/HandlerProxy\");\n\n/*!\n* ZRender, a high performance 2d drawing library.\n*\n* Copyright (c) 2013, Baidu Inc.\n* All rights reserved.\n*\n* LICENSE\n* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n*/\nvar useVML = !env.canvasSupported;\nvar painterCtors = {\n  canvas: Painter\n};\nvar instances = {}; // ZRender实例map索引\n\n/**\n * @type {string}\n */\n\nvar version = '3.7.4';\n/**\n * Initializing a zrender instance\n * @param {HTMLElement} dom\n * @param {Object} opts\n * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n * @param {number} [opts.devicePixelRatio]\n * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n * @return {module:zrender/ZRender}\n */\n\nfunction init(dom, opts) {\n  var zr = new ZRender(guid(), dom, opts);\n  instances[zr.id] = zr;\n  return zr;\n}\n/**\n * Dispose zrender instance\n * @param {module:zrender/ZRender} zr\n */\n\n\nfunction dispose(zr) {\n  if (zr) {\n    zr.dispose();\n  } else {\n    for (var key in instances) {\n      if (instances.hasOwnProperty(key)) {\n        instances[key].dispose();\n      }\n    }\n\n    instances = {};\n  }\n\n  return this;\n}\n/**\n * Get zrender instance by id\n * @param {string} id zrender instance id\n * @return {module:zrender/ZRender}\n */\n\n\nfunction getInstance(id) {\n  return instances[id];\n}\n\nfunction registerPainter(name, Ctor) {\n  painterCtors[name] = Ctor;\n}\n\nfunction delInstance(id) {\n  delete instances[id];\n}\n/**\n * @module zrender/ZRender\n */\n\n/**\n * @constructor\n * @alias module:zrender/ZRender\n * @param {string} id\n * @param {HTMLElement} dom\n * @param {Object} opts\n * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n * @param {number} [opts.devicePixelRatio]\n * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n */\n\n\nvar ZRender = function (id, dom, opts) {\n  opts = opts || {};\n  /**\n   * @type {HTMLDomElement}\n   */\n\n  this.dom = dom;\n  /**\n   * @type {string}\n   */\n\n  this.id = id;\n  var self = this;\n  var storage = new Storage();\n  var rendererType = opts.renderer; // TODO WebGL\n\n  if (useVML) {\n    if (!painterCtors.vml) {\n      throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n    }\n\n    rendererType = 'vml';\n  } else if (!rendererType || !painterCtors[rendererType]) {\n    rendererType = 'canvas';\n  }\n\n  var painter = new painterCtors[rendererType](dom, storage, opts);\n  this.storage = storage;\n  this.painter = painter;\n  var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n  this.handler = new Handler(storage, painter, handerProxy, painter.root);\n  /**\n   * @type {module:zrender/animation/Animation}\n   */\n\n  this.animation = new Animation({\n    stage: {\n      update: zrUtil.bind(this.flush, this)\n    }\n  });\n  this.animation.start();\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._needsRefresh; // 修改 storage.delFromStorage, 每次删除元素之前删除动画\n  // FIXME 有点ugly\n\n  var oldDelFromStorage = storage.delFromStorage;\n  var oldAddToStorage = storage.addToStorage;\n\n  storage.delFromStorage = function (el) {\n    oldDelFromStorage.call(storage, el);\n    el && el.removeSelfFromZr(self);\n  };\n\n  storage.addToStorage = function (el) {\n    oldAddToStorage.call(storage, el);\n    el.addSelfToZr(self);\n  };\n};\n\nZRender.prototype = {\n  constructor: ZRender,\n\n  /**\n   * 获取实例唯一标识\n   * @return {string}\n   */\n  getId: function () {\n    return this.id;\n  },\n\n  /**\n   * 添加元素\n   * @param  {module:zrender/Element} el\n   */\n  add: function (el) {\n    this.storage.addRoot(el);\n    this._needsRefresh = true;\n  },\n\n  /**\n   * 删除元素\n   * @param  {module:zrender/Element} el\n   */\n  remove: function (el) {\n    this.storage.delRoot(el);\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Change configuration of layer\n   * @param {string} zLevel\n   * @param {Object} config\n   * @param {string} [config.clearColor=0] Clear color\n   * @param {string} [config.motionBlur=false] If enable motion blur\n   * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n  */\n  configLayer: function (zLevel, config) {\n    this.painter.configLayer(zLevel, config);\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Repaint the canvas immediately\n   */\n  refreshImmediately: function () {\n    // var start = new Date();\n    // Clear needsRefresh ahead to avoid something wrong happens in refresh\n    // Or it will cause zrender refreshes again and again.\n    this._needsRefresh = false;\n    this.painter.refresh();\n    /**\n     * Avoid trigger zr.refresh in Element#beforeUpdate hook\n     */\n\n    this._needsRefresh = false; // var end = new Date();\n    // var log = document.getElementById('log');\n    // if (log) {\n    //     log.innerHTML = log.innerHTML + '<br>' + (end - start);\n    // }\n  },\n\n  /**\n   * Mark and repaint the canvas in the next frame of browser\n   */\n  refresh: function () {\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Perform all refresh\n   */\n  flush: function () {\n    if (this._needsRefresh) {\n      this.refreshImmediately();\n    }\n\n    if (this._needsRefreshHover) {\n      this.refreshHoverImmediately();\n    }\n  },\n\n  /**\n   * Add element to hover layer\n   * @param  {module:zrender/Element} el\n   * @param {Object} style\n   */\n  addHover: function (el, style) {\n    if (this.painter.addHover) {\n      this.painter.addHover(el, style);\n      this.refreshHover();\n    }\n  },\n\n  /**\n   * Add element from hover layer\n   * @param  {module:zrender/Element} el\n   */\n  removeHover: function (el) {\n    if (this.painter.removeHover) {\n      this.painter.removeHover(el);\n      this.refreshHover();\n    }\n  },\n\n  /**\n   * Clear all hover elements in hover layer\n   * @param  {module:zrender/Element} el\n   */\n  clearHover: function () {\n    if (this.painter.clearHover) {\n      this.painter.clearHover();\n      this.refreshHover();\n    }\n  },\n\n  /**\n   * Refresh hover in next frame\n   */\n  refreshHover: function () {\n    this._needsRefreshHover = true;\n  },\n\n  /**\n   * Refresh hover immediately\n   */\n  refreshHoverImmediately: function () {\n    this._needsRefreshHover = false;\n    this.painter.refreshHover && this.painter.refreshHover();\n  },\n\n  /**\n   * Resize the canvas.\n   * Should be invoked when container size is changed\n   * @param {Object} [opts]\n   * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n   * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n   */\n  resize: function (opts) {\n    opts = opts || {};\n    this.painter.resize(opts.width, opts.height);\n    this.handler.resize();\n  },\n\n  /**\n   * Stop and clear all animation immediately\n   */\n  clearAnimation: function () {\n    this.animation.clear();\n  },\n\n  /**\n   * Get container width\n   */\n  getWidth: function () {\n    return this.painter.getWidth();\n  },\n\n  /**\n   * Get container height\n   */\n  getHeight: function () {\n    return this.painter.getHeight();\n  },\n\n  /**\n   * Export the canvas as Base64 URL\n   * @param {string} type\n   * @param {string} [backgroundColor='#fff']\n   * @return {string} Base64 URL\n   */\n  // toDataURL: function(type, backgroundColor) {\n  //     return this.painter.getRenderedCanvas({\n  //         backgroundColor: backgroundColor\n  //     }).toDataURL(type);\n  // },\n\n  /**\n   * Converting a path to image.\n   * It has much better performance of drawing image rather than drawing a vector path.\n   * @param {module:zrender/graphic/Path} e\n   * @param {number} width\n   * @param {number} height\n   */\n  pathToImage: function (e, dpr) {\n    return this.painter.pathToImage(e, dpr);\n  },\n\n  /**\n   * Set default cursor\n   * @param {string} [cursorStyle='default'] 例如 crosshair\n   */\n  setCursorStyle: function (cursorStyle) {\n    this.handler.setCursorStyle(cursorStyle);\n  },\n\n  /**\n   * Find hovered element\n   * @param {number} x\n   * @param {number} y\n   * @return {Object} {target, topTarget}\n   */\n  findHover: function (x, y) {\n    return this.handler.findHover(x, y);\n  },\n\n  /**\n   * Bind event\n   *\n   * @param {string} eventName Event name\n   * @param {Function} eventHandler Handler function\n   * @param {Object} [context] Context object\n   */\n  on: function (eventName, eventHandler, context) {\n    this.handler.on(eventName, eventHandler, context);\n  },\n\n  /**\n   * Unbind event\n   * @param {string} eventName Event name\n   * @param {Function} [eventHandler] Handler function\n   */\n  off: function (eventName, eventHandler) {\n    this.handler.off(eventName, eventHandler);\n  },\n\n  /**\n   * Trigger event manually\n   *\n   * @param {string} eventName Event name\n   * @param {event=} event Event object\n   */\n  trigger: function (eventName, event) {\n    this.handler.trigger(eventName, event);\n  },\n\n  /**\n   * Clear all objects and the canvas.\n   */\n  clear: function () {\n    this.storage.delRoot();\n    this.painter.clear();\n  },\n\n  /**\n   * Dispose self.\n   */\n  dispose: function () {\n    this.animation.stop();\n    this.clear();\n    this.storage.dispose();\n    this.painter.dispose();\n    this.handler.dispose();\n    this.animation = this.storage = this.painter = this.handler = null;\n    delInstance(this.id);\n  }\n};\nexports.version = version;\nexports.init = init;\nexports.dispose = dispose;\nexports.getInstance = getInstance;\nexports.registerPainter = registerPainter;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/zrender.js\n// module id = 69\n// module chunks = 0","var util = require(\"./core/util\");\n\nvar vec2 = require(\"./core/vector\");\n\nvar Draggable = require(\"./mixin/Draggable\");\n\nvar Eventful = require(\"./mixin/Eventful\");\n\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\nvar SILENT = 'silent';\n\nfunction makeEventPacket(eveType, targetInfo, event) {\n  return {\n    type: eveType,\n    event: event,\n    // target can only be an element that is not silent.\n    target: targetInfo.target,\n    // topTarget can be a silent element.\n    topTarget: targetInfo.topTarget,\n    cancelBubble: false,\n    offsetX: event.zrX,\n    offsetY: event.zrY,\n    gestureEvent: event.gestureEvent,\n    pinchX: event.pinchX,\n    pinchY: event.pinchY,\n    pinchScale: event.pinchScale,\n    wheelDelta: event.zrDelta,\n    zrByTouch: event.zrByTouch,\n    which: event.which\n  };\n}\n\nfunction EmptyProxy() {}\n\nEmptyProxy.prototype.dispose = function () {};\n\nvar handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n/**\n * @alias module:zrender/Handler\n * @constructor\n * @extends module:zrender/mixin/Eventful\n * @param {module:zrender/Storage} storage Storage instance.\n * @param {module:zrender/Painter} painter Painter instance.\n * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n */\n\nvar Handler = function (storage, painter, proxy, painterRoot) {\n  Eventful.call(this);\n  this.storage = storage;\n  this.painter = painter;\n  this.painterRoot = painterRoot;\n  proxy = proxy || new EmptyProxy();\n  /**\n   * Proxy of event. can be Dom, WebGLSurface, etc.\n   */\n\n  this.proxy = proxy; // Attach handler\n\n  proxy.handler = this;\n  /**\n   * {target, topTarget, x, y}\n   * @private\n   * @type {Object}\n   */\n\n  this._hovered = {};\n  /**\n   * @private\n   * @type {Date}\n   */\n\n  this._lastTouchMoment;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._lastX;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._lastY;\n  Draggable.call(this);\n  util.each(handlerNames, function (name) {\n    proxy.on && proxy.on(name, this[name], this);\n  }, this);\n};\n\nHandler.prototype = {\n  constructor: Handler,\n  mousemove: function (event) {\n    var x = event.zrX;\n    var y = event.zrY;\n    var lastHovered = this._hovered;\n    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call\n    // (like 'setOption' or 'dispatchAction') in event handlers, we should find\n    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.\n    // See #6198.\n\n    if (lastHoveredTarget && !lastHoveredTarget.__zr) {\n      lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n      lastHoveredTarget = lastHovered.target;\n    }\n\n    var hovered = this._hovered = this.findHover(x, y);\n    var hoveredTarget = hovered.target;\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element\n\n    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(lastHovered, 'mouseout', event);\n    } // Mouse moving on one element\n\n\n    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element\n\n    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(hovered, 'mouseover', event);\n    }\n  },\n  mouseout: function (event) {\n    this.dispatchToElement(this._hovered, 'mouseout', event); // There might be some doms created by upper layer application\n    // at the same level of painter.getViewportRoot() (e.g., tooltip\n    // dom created by echarts), where 'globalout' event should not\n    // be triggered when mouse enters these doms. (But 'mouseout'\n    // should be triggered at the original hovered element as usual).\n\n    var element = event.toElement || event.relatedTarget;\n    var innerDom;\n\n    do {\n      element = element && element.parentNode;\n    } while (element && element.nodeType != 9 && !(innerDom = element === this.painterRoot));\n\n    !innerDom && this.trigger('globalout', {\n      event: event\n    });\n  },\n\n  /**\n   * Resize\n   */\n  resize: function (event) {\n    this._hovered = {};\n  },\n\n  /**\n   * Dispatch event\n   * @param {string} eventName\n   * @param {event=} eventArgs\n   */\n  dispatch: function (eventName, eventArgs) {\n    var handler = this[eventName];\n    handler && handler.call(this, eventArgs);\n  },\n\n  /**\n   * Dispose\n   */\n  dispose: function () {\n    this.proxy.dispose();\n    this.storage = this.proxy = this.painter = null;\n  },\n\n  /**\n   * 设置默认的cursor style\n   * @param {string} [cursorStyle='default'] 例如 crosshair\n   */\n  setCursorStyle: function (cursorStyle) {\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(cursorStyle);\n  },\n\n  /**\n   * 事件分发代理\n   *\n   * @private\n   * @param {Object} targetInfo {target, topTarget} 目标图形元素\n   * @param {string} eventName 事件名称\n   * @param {Object} event 事件对象\n   */\n  dispatchToElement: function (targetInfo, eventName, event) {\n    targetInfo = targetInfo || {};\n    var el = targetInfo.target;\n\n    if (el && el.silent) {\n      return;\n    }\n\n    var eventHandler = 'on' + eventName;\n    var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\n    while (el) {\n      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n      el.trigger(eventName, eventPacket);\n      el = el.parent;\n\n      if (eventPacket.cancelBubble) {\n        break;\n      }\n    }\n\n    if (!eventPacket.cancelBubble) {\n      // 冒泡到顶级 zrender 对象\n      this.trigger(eventName, eventPacket); // 分发事件到用户自定义层\n      // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n\n      this.painter && this.painter.eachOtherLayer(function (layer) {\n        if (typeof layer[eventHandler] == 'function') {\n          layer[eventHandler].call(layer, eventPacket);\n        }\n\n        if (layer.trigger) {\n          layer.trigger(eventName, eventPacket);\n        }\n      });\n    }\n  },\n\n  /**\n   * @private\n   * @param {number} x\n   * @param {number} y\n   * @param {module:zrender/graphic/Displayable} exclude\n   * @return {model:zrender/Element}\n   * @method\n   */\n  findHover: function (x, y, exclude) {\n    var list = this.storage.getDisplayList();\n    var out = {\n      x: x,\n      y: y\n    };\n\n    for (var i = list.length - 1; i >= 0; i--) {\n      var hoverCheckResult;\n\n      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode\n      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {\n        !out.topTarget && (out.topTarget = list[i]);\n\n        if (hoverCheckResult !== SILENT) {\n          out.target = list[i];\n          break;\n        }\n      }\n    }\n\n    return out;\n  }\n}; // Common handlers\n\nutil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  Handler.prototype[name] = function (event) {\n    // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n    var hovered = this.findHover(event.zrX, event.zrY);\n    var hoveredTarget = hovered.target;\n\n    if (name === 'mousedown') {\n      this._downEl = hoveredTarget;\n      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup\n\n      this._upEl = hoveredTarget;\n    } else if (name === 'mosueup') {\n      this._upEl = hoveredTarget;\n    } else if (name === 'click') {\n      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,\n      // including the case that `mousedown` - `mousemove` - `mouseup`,\n      // which should be filtered, otherwise it will bring trouble to\n      // pan and zoom.\n      || !this._downPoint // Arbitrary value\n      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {\n        return;\n      }\n\n      this._downPoint = null;\n    }\n\n    this.dispatchToElement(hovered, name, event);\n  };\n});\n\nfunction isHover(displayable, x, y) {\n  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n    var el = displayable;\n    var isSilent;\n\n    while (el) {\n      // If clipped by ancestor.\n      // FIXME: If clipPath has neither stroke nor fill,\n      // el.clipPath.contain(x, y) will always return false.\n      if (el.clipPath && !el.clipPath.contain(x, y)) {\n        return false;\n      }\n\n      if (el.silent) {\n        isSilent = true;\n      }\n\n      el = el.parent;\n    }\n\n    return isSilent ? SILENT : true;\n  }\n\n  return false;\n}\n\nutil.mixin(Handler, Eventful);\nutil.mixin(Handler, Draggable);\nvar _default = Handler;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Handler.js\n// module id = 70\n// module chunks = 0","var util = require(\"./core/util\");\n\nvar env = require(\"./core/env\");\n\nvar Group = require(\"./container/Group\");\n\nvar timsort = require(\"./core/timsort\");\n\n/**\n * Storage内容仓库模块\n * @module zrender/Storage\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n// Use timsort because in most case elements are partially sorted\n// https://jsfiddle.net/pissang/jr4x7mdm/8/\nfunction shapeCompareFunc(a, b) {\n  if (a.zlevel === b.zlevel) {\n    if (a.z === b.z) {\n      // if (a.z2 === b.z2) {\n      //     // FIXME Slow has renderidx compare\n      //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n      //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n      //     return a.__renderidx - b.__renderidx;\n      // }\n      return a.z2 - b.z2;\n    }\n\n    return a.z - b.z;\n  }\n\n  return a.zlevel - b.zlevel;\n}\n/**\n * 内容仓库 (M)\n * @alias module:zrender/Storage\n * @constructor\n */\n\n\nvar Storage = function () {\n  // jshint ignore:line\n  this._roots = [];\n  this._displayList = [];\n  this._displayListLen = 0;\n};\n\nStorage.prototype = {\n  constructor: Storage,\n\n  /**\n   * @param  {Function} cb\n   *\n   */\n  traverse: function (cb, context) {\n    for (var i = 0; i < this._roots.length; i++) {\n      this._roots[i].traverse(cb, context);\n    }\n  },\n\n  /**\n   * 返回所有图形的绘制队列\n   * @param {boolean} [update=false] 是否在返回前更新该数组\n   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\n   *\n   * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n   * @return {Array.<module:zrender/graphic/Displayable>}\n   */\n  getDisplayList: function (update, includeIgnore) {\n    includeIgnore = includeIgnore || false;\n\n    if (update) {\n      this.updateDisplayList(includeIgnore);\n    }\n\n    return this._displayList;\n  },\n\n  /**\n   * 更新图形的绘制队列。\n   * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\n   * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\n   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\n   */\n  updateDisplayList: function (includeIgnore) {\n    this._displayListLen = 0;\n    var roots = this._roots;\n    var displayList = this._displayList;\n\n    for (var i = 0, len = roots.length; i < len; i++) {\n      this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n    }\n\n    displayList.length = this._displayListLen; // for (var i = 0, len = displayList.length; i < len; i++) {\n    //     displayList[i].__renderidx = i;\n    // }\n    // displayList.sort(shapeCompareFunc);\n\n    env.canvasSupported && timsort(displayList, shapeCompareFunc);\n  },\n  _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n    if (el.ignore && !includeIgnore) {\n      return;\n    }\n\n    el.beforeUpdate();\n\n    if (el.__dirty) {\n      el.update();\n    }\n\n    el.afterUpdate();\n    var userSetClipPath = el.clipPath;\n\n    if (userSetClipPath) {\n      // FIXME 效率影响\n      if (clipPaths) {\n        clipPaths = clipPaths.slice();\n      } else {\n        clipPaths = [];\n      }\n\n      var currentClipPath = userSetClipPath;\n      var parentClipPath = el; // Recursively add clip path\n\n      while (currentClipPath) {\n        // clipPath 的变换是基于使用这个 clipPath 的元素\n        currentClipPath.parent = parentClipPath;\n        currentClipPath.updateTransform();\n        clipPaths.push(currentClipPath);\n        parentClipPath = currentClipPath;\n        currentClipPath = currentClipPath.clipPath;\n      }\n    }\n\n    if (el.isGroup) {\n      var children = el._children;\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i]; // Force to mark as dirty if group is dirty\n        // FIXME __dirtyPath ?\n\n        if (el.__dirty) {\n          child.__dirty = true;\n        }\n\n        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n      } // Mark group clean here\n\n\n      el.__dirty = false;\n    } else {\n      el.__clipPaths = clipPaths;\n      this._displayList[this._displayListLen++] = el;\n    }\n  },\n\n  /**\n   * 添加图形(Shape)或者组(Group)到根节点\n   * @param {module:zrender/Element} el\n   */\n  addRoot: function (el) {\n    if (el.__storage === this) {\n      return;\n    }\n\n    if (el instanceof Group) {\n      el.addChildrenToStorage(this);\n    }\n\n    this.addToStorage(el);\n\n    this._roots.push(el);\n  },\n\n  /**\n   * 删除指定的图形(Shape)或者组(Group)\n   * @param {string|Array.<string>} [el] 如果为空清空整个Storage\n   */\n  delRoot: function (el) {\n    if (el == null) {\n      // 不指定el清空\n      for (var i = 0; i < this._roots.length; i++) {\n        var root = this._roots[i];\n\n        if (root instanceof Group) {\n          root.delChildrenFromStorage(this);\n        }\n      }\n\n      this._roots = [];\n      this._displayList = [];\n      this._displayListLen = 0;\n      return;\n    }\n\n    if (el instanceof Array) {\n      for (var i = 0, l = el.length; i < l; i++) {\n        this.delRoot(el[i]);\n      }\n\n      return;\n    }\n\n    var idx = util.indexOf(this._roots, el);\n\n    if (idx >= 0) {\n      this.delFromStorage(el);\n\n      this._roots.splice(idx, 1);\n\n      if (el instanceof Group) {\n        el.delChildrenFromStorage(this);\n      }\n    }\n  },\n  addToStorage: function (el) {\n    el.__storage = this;\n    el.dirty(false);\n    return this;\n  },\n  delFromStorage: function (el) {\n    if (el) {\n      el.__storage = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * 清空并且释放Storage\n   */\n  dispose: function () {\n    this._renderList = this._roots = null;\n  },\n  displayableSortFunc: shapeCompareFunc\n};\nvar _default = Storage;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Storage.js\n// module id = 71\n// module chunks = 0","// https://github.com/mziccard/node-timsort\nvar DEFAULT_MIN_MERGE = 32;\nvar DEFAULT_MIN_GALLOPING = 7;\nvar DEFAULT_TMP_STORAGE_LENGTH = 256;\n\nfunction minRunLength(n) {\n  var r = 0;\n\n  while (n >= DEFAULT_MIN_MERGE) {\n    r |= n & 1;\n    n >>= 1;\n  }\n\n  return n + r;\n}\n\nfunction makeAscendingRun(array, lo, hi, compare) {\n  var runHi = lo + 1;\n\n  if (runHi === hi) {\n    return 1;\n  }\n\n  if (compare(array[runHi++], array[lo]) < 0) {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n      runHi++;\n    }\n\n    reverseRun(array, lo, runHi);\n  } else {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n      runHi++;\n    }\n  }\n\n  return runHi - lo;\n}\n\nfunction reverseRun(array, lo, hi) {\n  hi--;\n\n  while (lo < hi) {\n    var t = array[lo];\n    array[lo++] = array[hi];\n    array[hi--] = t;\n  }\n}\n\nfunction binaryInsertionSort(array, lo, hi, start, compare) {\n  if (start === lo) {\n    start++;\n  }\n\n  for (; start < hi; start++) {\n    var pivot = array[start];\n    var left = lo;\n    var right = start;\n    var mid;\n\n    while (left < right) {\n      mid = left + right >>> 1;\n\n      if (compare(pivot, array[mid]) < 0) {\n        right = mid;\n      } else {\n        left = mid + 1;\n      }\n    }\n\n    var n = start - left;\n\n    switch (n) {\n      case 3:\n        array[left + 3] = array[left + 2];\n\n      case 2:\n        array[left + 2] = array[left + 1];\n\n      case 1:\n        array[left + 1] = array[left];\n        break;\n\n      default:\n        while (n > 0) {\n          array[left + n] = array[left + n - 1];\n          n--;\n        }\n\n    }\n\n    array[left] = pivot;\n  }\n}\n\nfunction gallopLeft(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) > 0) {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  } else {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) > 0) {\n      lastOffset = m + 1;\n    } else {\n      offset = m;\n    }\n  }\n\n  return offset;\n}\n\nfunction gallopRight(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) < 0) {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  } else {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) < 0) {\n      offset = m;\n    } else {\n      lastOffset = m + 1;\n    }\n  }\n\n  return offset;\n}\n\nfunction TimSort(array, compare) {\n  var minGallop = DEFAULT_MIN_GALLOPING;\n  var length = 0;\n  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n  var stackLength = 0;\n  var runStart;\n  var runLength;\n  var stackSize = 0;\n  length = array.length;\n\n  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n    tmpStorageLength = length >>> 1;\n  }\n\n  var tmp = [];\n  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n  runStart = [];\n  runLength = [];\n\n  function pushRun(_runStart, _runLength) {\n    runStart[stackSize] = _runStart;\n    runLength[stackSize] = _runLength;\n    stackSize += 1;\n  }\n\n  function mergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n        if (runLength[n - 1] < runLength[n + 1]) {\n          n--;\n        }\n      } else if (runLength[n] > runLength[n + 1]) {\n        break;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function forceMergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n        n--;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function mergeAt(i) {\n    var start1 = runStart[i];\n    var length1 = runLength[i];\n    var start2 = runStart[i + 1];\n    var length2 = runLength[i + 1];\n    runLength[i] = length1 + length2;\n\n    if (i === stackSize - 3) {\n      runStart[i + 1] = runStart[i + 2];\n      runLength[i + 1] = runLength[i + 2];\n    }\n\n    stackSize--;\n    var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n    start1 += k;\n    length1 -= k;\n\n    if (length1 === 0) {\n      return;\n    }\n\n    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n    if (length2 === 0) {\n      return;\n    }\n\n    if (length1 <= length2) {\n      mergeLow(start1, length1, start2, length2);\n    } else {\n      mergeHigh(start1, length1, start2, length2);\n    }\n  }\n\n  function mergeLow(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length1; i++) {\n      tmp[i] = array[start1 + i];\n    }\n\n    var cursor1 = 0;\n    var cursor2 = start2;\n    var dest = start1;\n    array[dest++] = array[cursor2++];\n\n    if (--length2 === 0) {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n\n      return;\n    }\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n      return;\n    }\n\n    var _minGallop = minGallop;\n    var count1, count2, exit;\n\n    while (1) {\n      count1 = 0;\n      count2 = 0;\n      exit = false;\n\n      do {\n        if (compare(array[cursor2], tmp[cursor1]) < 0) {\n          array[dest++] = array[cursor2++];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest++] = tmp[cursor1++];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n        if (count1 !== 0) {\n          for (i = 0; i < count1; i++) {\n            array[dest + i] = tmp[cursor1 + i];\n          }\n\n          dest += count1;\n          cursor1 += count1;\n          length1 -= count1;\n\n          if (length1 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = array[cursor2++];\n\n        if (--length2 === 0) {\n          exit = true;\n          break;\n        }\n\n        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n        if (count2 !== 0) {\n          for (i = 0; i < count2; i++) {\n            array[dest + i] = array[cursor2 + i];\n          }\n\n          dest += count2;\n          cursor2 += count2;\n          length2 -= count2;\n\n          if (length2 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = tmp[cursor1++];\n\n        if (--length1 === 1) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n    minGallop < 1 && (minGallop = 1);\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n    } else if (length1 === 0) {\n      throw new Error(); // throw new Error('mergeLow preconditions were not respected');\n    } else {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n    }\n  }\n\n  function mergeHigh(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length2; i++) {\n      tmp[i] = array[start2 + i];\n    }\n\n    var cursor1 = start1 + length1 - 1;\n    var cursor2 = length2 - 1;\n    var dest = start2 + length2 - 1;\n    var customCursor = 0;\n    var customDest = 0;\n    array[dest--] = array[cursor1--];\n\n    if (--length1 === 0) {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n\n      return;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n      return;\n    }\n\n    var _minGallop = minGallop;\n\n    while (true) {\n      var count1 = 0;\n      var count2 = 0;\n      var exit = false;\n\n      do {\n        if (compare(tmp[cursor2], array[cursor1]) < 0) {\n          array[dest--] = array[cursor1--];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest--] = tmp[cursor2--];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n        if (count1 !== 0) {\n          dest -= count1;\n          cursor1 -= count1;\n          length1 -= count1;\n          customDest = dest + 1;\n          customCursor = cursor1 + 1;\n\n          for (i = count1 - 1; i >= 0; i--) {\n            array[customDest + i] = array[customCursor + i];\n          }\n\n          if (length1 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = tmp[cursor2--];\n\n        if (--length2 === 1) {\n          exit = true;\n          break;\n        }\n\n        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n        if (count2 !== 0) {\n          dest -= count2;\n          cursor2 -= count2;\n          length2 -= count2;\n          customDest = dest + 1;\n          customCursor = cursor2 + 1;\n\n          for (i = 0; i < count2; i++) {\n            array[customDest + i] = tmp[customCursor + i];\n          }\n\n          if (length2 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = array[cursor1--];\n\n        if (--length1 === 0) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n\n    if (minGallop < 1) {\n      minGallop = 1;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n    } else if (length2 === 0) {\n      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');\n    } else {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n    }\n  }\n\n  this.mergeRuns = mergeRuns;\n  this.forceMergeRuns = forceMergeRuns;\n  this.pushRun = pushRun;\n}\n\nfunction sort(array, compare, lo, hi) {\n  if (!lo) {\n    lo = 0;\n  }\n\n  if (!hi) {\n    hi = array.length;\n  }\n\n  var remaining = hi - lo;\n\n  if (remaining < 2) {\n    return;\n  }\n\n  var runLength = 0;\n\n  if (remaining < DEFAULT_MIN_MERGE) {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n    binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n    return;\n  }\n\n  var ts = new TimSort(array, compare);\n  var minRun = minRunLength(remaining);\n\n  do {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n\n    if (runLength < minRun) {\n      var force = remaining;\n\n      if (force > minRun) {\n        force = minRun;\n      }\n\n      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n      runLength = force;\n    }\n\n    ts.pushRun(lo, runLength);\n    ts.mergeRuns();\n    remaining -= runLength;\n    lo += runLength;\n  } while (remaining !== 0);\n\n  ts.forceMergeRuns();\n}\n\nmodule.exports = sort;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/timsort.js\n// module id = 72\n// module chunks = 0","var _config = require(\"./config\");\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar util = require(\"./core/util\");\n\nvar log = require(\"./core/log\");\n\nvar BoundingRect = require(\"./core/BoundingRect\");\n\nvar timsort = require(\"./core/timsort\");\n\nvar Layer = require(\"./Layer\");\n\nvar requestAnimationFrame = require(\"./animation/requestAnimationFrame\");\n\nvar Image = require(\"./graphic/Image\");\n\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n// PENDIGN\n// Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n//\n// Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\nvar MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n\nfunction isLayerValid(layer) {\n  if (!layer) {\n    return false;\n  }\n\n  if (layer.__builtin__) {\n    return true;\n  }\n\n  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction preProcessLayer(layer) {\n  layer.__unusedCount++;\n}\n\nfunction postProcessLayer(layer) {\n  if (layer.__unusedCount == 1) {\n    layer.clear();\n  }\n}\n\nvar tmpRect = new BoundingRect(0, 0, 0, 0);\nvar viewRect = new BoundingRect(0, 0, 0, 0);\n\nfunction isDisplayableCulled(el, width, height) {\n  tmpRect.copy(el.getBoundingRect());\n\n  if (el.transform) {\n    tmpRect.applyTransform(el.transform);\n  }\n\n  viewRect.width = width;\n  viewRect.height = height;\n  return !tmpRect.intersect(viewRect);\n}\n\nfunction isClipPathChanged(clipPaths, prevClipPaths) {\n  if (clipPaths == prevClipPaths) {\n    // Can both be null or undefined\n    return false;\n  }\n\n  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n    return true;\n  }\n\n  for (var i = 0; i < clipPaths.length; i++) {\n    if (clipPaths[i] !== prevClipPaths[i]) {\n      return true;\n    }\n  }\n}\n\nfunction doClip(clipPaths, ctx) {\n  for (var i = 0; i < clipPaths.length; i++) {\n    var clipPath = clipPaths[i];\n    clipPath.setTransform(ctx);\n    ctx.beginPath();\n    clipPath.buildPath(ctx, clipPath.shape);\n    ctx.clip(); // Transform back\n\n    clipPath.restoreTransform(ctx);\n  }\n}\n\nfunction createRoot(width, height) {\n  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n\n  domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';\n  return domRoot;\n}\n/**\n * @alias module:zrender/Painter\n * @constructor\n * @param {HTMLElement} root 绘图容器\n * @param {module:zrender/Storage} storage\n * @param {Object} opts\n */\n\n\nvar Painter = function (root, storage, opts) {\n  this.type = 'canvas'; // In node environment using node-canvas\n\n  var singleCanvas = !root.nodeName // In node ?\n  || root.nodeName.toUpperCase() === 'CANVAS';\n  this._opts = opts = util.extend({}, opts || {});\n  /**\n   * @type {number}\n   */\n\n  this.dpr = opts.devicePixelRatio || devicePixelRatio;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._singleCanvas = singleCanvas;\n  /**\n   * 绘图容器\n   * @type {HTMLElement}\n   */\n\n  this.root = root;\n  var rootStyle = root.style;\n\n  if (rootStyle) {\n    rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n    root.innerHTML = '';\n  }\n  /**\n   * @type {module:zrender/Storage}\n   */\n\n\n  this.storage = storage;\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n\n  var zlevelList = this._zlevelList = [];\n  /**\n   * @type {Object.<string, module:zrender/Layer>}\n   * @private\n   */\n\n  var layers = this._layers = {};\n  /**\n   * @type {Object.<string, Object>}\n   * @type {private}\n   */\n\n  this._layerConfig = {};\n\n  if (!singleCanvas) {\n    this._width = this._getSize(0);\n    this._height = this._getSize(1);\n    var domRoot = this._domRoot = createRoot(this._width, this._height);\n    root.appendChild(domRoot);\n  } else {\n    if (opts.width != null) {\n      root.width = opts.width;\n    }\n\n    if (opts.height != null) {\n      root.height = opts.height;\n    } // Use canvas width and height directly\n\n\n    var width = root.width;\n    var height = root.height;\n    this._width = width;\n    this._height = height; // Create layer if only one given canvas\n    // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\n    var mainLayer = new Layer(root, this, 1);\n    mainLayer.initContext(); // FIXME Use canvas width and height\n    // mainLayer.resize(width, height);\n\n    layers[0] = mainLayer;\n    zlevelList.push(0);\n    this._domRoot = root;\n  } // Layers for progressive rendering\n\n\n  this._progressiveLayers = [];\n  /**\n   * @type {module:zrender/Layer}\n   * @private\n   */\n\n  this._hoverlayer;\n  this._hoverElements = [];\n};\n\nPainter.prototype = {\n  constructor: Painter,\n  getType: function () {\n    return 'canvas';\n  },\n\n  /**\n   * If painter use a single canvas\n   * @return {boolean}\n   */\n  isSingleCanvas: function () {\n    return this._singleCanvas;\n  },\n\n  /**\n   * @return {HTMLDivElement}\n   */\n  getViewportRoot: function () {\n    return this._domRoot;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\n   * 刷新\n   * @param {boolean} [paintAll=false] 强制绘制所有displayable\n   */\n  refresh: function (paintAll) {\n    var list = this.storage.getDisplayList(true);\n    var zlevelList = this._zlevelList;\n\n    this._paintList(list, paintAll); // Paint custum layers\n\n\n    for (var i = 0; i < zlevelList.length; i++) {\n      var z = zlevelList[i];\n      var layer = this._layers[z];\n\n      if (!layer.__builtin__ && layer.refresh) {\n        layer.refresh();\n      }\n    }\n\n    this.refreshHover();\n\n    if (this._progressiveLayers.length) {\n      this._startProgessive();\n    }\n\n    return this;\n  },\n  addHover: function (el, hoverStyle) {\n    if (el.__hoverMir) {\n      return;\n    }\n\n    var elMirror = new el.constructor({\n      style: el.style,\n      shape: el.shape\n    });\n    elMirror.__from = el;\n    el.__hoverMir = elMirror;\n    elMirror.setStyle(hoverStyle);\n\n    this._hoverElements.push(elMirror);\n  },\n  removeHover: function (el) {\n    var elMirror = el.__hoverMir;\n    var hoverElements = this._hoverElements;\n    var idx = util.indexOf(hoverElements, elMirror);\n\n    if (idx >= 0) {\n      hoverElements.splice(idx, 1);\n    }\n\n    el.__hoverMir = null;\n  },\n  clearHover: function (el) {\n    var hoverElements = this._hoverElements;\n\n    for (var i = 0; i < hoverElements.length; i++) {\n      var from = hoverElements[i].__from;\n\n      if (from) {\n        from.__hoverMir = null;\n      }\n    }\n\n    hoverElements.length = 0;\n  },\n  refreshHover: function () {\n    var hoverElements = this._hoverElements;\n    var len = hoverElements.length;\n    var hoverLayer = this._hoverlayer;\n    hoverLayer && hoverLayer.clear();\n\n    if (!len) {\n      return;\n    }\n\n    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel\n    // FIXME?\n\n    if (!hoverLayer) {\n      hoverLayer = this._hoverlayer = this.getLayer(1e5);\n    }\n\n    var scope = {};\n    hoverLayer.ctx.save();\n\n    for (var i = 0; i < len;) {\n      var el = hoverElements[i];\n      var originalEl = el.__from; // Original el is removed\n      // PENDING\n\n      if (!(originalEl && originalEl.__zr)) {\n        hoverElements.splice(i, 1);\n        originalEl.__hoverMir = null;\n        len--;\n        continue;\n      }\n\n      i++; // Use transform\n      // FIXME style and shape ?\n\n      if (!originalEl.invisible) {\n        el.transform = originalEl.transform;\n        el.invTransform = originalEl.invTransform;\n        el.__clipPaths = originalEl.__clipPaths; // el.\n\n        this._doPaintEl(el, hoverLayer, true, scope);\n      }\n    }\n\n    hoverLayer.ctx.restore();\n  },\n  _startProgessive: function () {\n    var self = this;\n\n    if (!self._furtherProgressive) {\n      return;\n    } // Use a token to stop progress steps triggered by\n    // previous zr.refresh calling.\n\n\n    var token = self._progressiveToken = +new Date();\n    self._progress++;\n    requestAnimationFrame(step);\n\n    function step() {\n      // In case refreshed or disposed\n      if (token === self._progressiveToken && self.storage) {\n        self._doPaintList(self.storage.getDisplayList());\n\n        if (self._furtherProgressive) {\n          self._progress++;\n          requestAnimationFrame(step);\n        } else {\n          self._progressiveToken = -1;\n        }\n      }\n    }\n  },\n  _clearProgressive: function () {\n    this._progressiveToken = -1;\n    this._progress = 0;\n    util.each(this._progressiveLayers, function (layer) {\n      layer.__dirty && layer.clear();\n    });\n  },\n  _paintList: function (list, paintAll) {\n    if (paintAll == null) {\n      paintAll = false;\n    }\n\n    this._updateLayerStatus(list);\n\n    this._clearProgressive();\n\n    this.eachBuiltinLayer(preProcessLayer);\n\n    this._doPaintList(list, paintAll);\n\n    this.eachBuiltinLayer(postProcessLayer);\n  },\n  _doPaintList: function (list, paintAll) {\n    var currentLayer;\n    var currentZLevel;\n    var ctx; // var invTransform = [];\n\n    var scope;\n    var progressiveLayerIdx = 0;\n    var currentProgressiveLayer;\n    var width = this._width;\n    var height = this._height;\n    var layerProgress;\n    var frame = this._progress;\n\n    function flushProgressiveLayer(layer) {\n      var dpr = ctx.dpr || 1;\n      ctx.save();\n      ctx.globalAlpha = 1;\n      ctx.shadowBlur = 0; // Avoid layer don't clear in next progressive frame\n\n      currentLayer.__dirty = true;\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n      ctx.restore();\n    }\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      var el = list[i];\n      var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n      var elFrame = el.__frame; // Flush at current context\n      // PENDING\n\n      if (elFrame < 0 && currentProgressiveLayer) {\n        flushProgressiveLayer(currentProgressiveLayer);\n        currentProgressiveLayer = null;\n      } // Change draw layer\n\n\n      if (currentZLevel !== elZLevel) {\n        if (ctx) {\n          ctx.restore();\n        } // Reset scope\n\n\n        scope = {}; // Only 0 zlevel if only has one canvas\n\n        currentZLevel = elZLevel;\n        currentLayer = this.getLayer(currentZLevel);\n\n        if (!currentLayer.__builtin__) {\n          log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);\n        }\n\n        ctx = currentLayer.ctx;\n        ctx.save(); // Reset the count\n\n        currentLayer.__unusedCount = 0;\n\n        if (currentLayer.__dirty || paintAll) {\n          currentLayer.clear();\n        }\n      }\n\n      if (!(currentLayer.__dirty || paintAll)) {\n        continue;\n      }\n\n      if (elFrame >= 0) {\n        // Progressive layer changed\n        if (!currentProgressiveLayer) {\n          currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];\n          currentProgressiveLayer.ctx.save();\n          currentProgressiveLayer.renderScope = {};\n\n          if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {\n            // flushProgressiveLayer(currentProgressiveLayer);\n            // Quick jump all progressive elements\n            // All progressive element are not dirty, jump over and flush directly\n            i = currentProgressiveLayer.__nextIdxNotProg - 1; // currentProgressiveLayer = null;\n\n            continue;\n          }\n\n          layerProgress = currentProgressiveLayer.__progress;\n\n          if (!currentProgressiveLayer.__dirty) {\n            // Keep rendering\n            frame = layerProgress;\n          }\n\n          currentProgressiveLayer.__progress = frame + 1;\n        }\n\n        if (elFrame === frame) {\n          this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n        }\n      } else {\n        this._doPaintEl(el, currentLayer, paintAll, scope);\n      }\n\n      el.__dirty = false;\n    }\n\n    if (currentProgressiveLayer) {\n      flushProgressiveLayer(currentProgressiveLayer);\n    } // Restore the lastLayer ctx\n\n\n    ctx && ctx.restore(); // If still has clipping state\n    // if (scope.prevElClipPaths) {\n    //     ctx.restore();\n    // }\n\n    this._furtherProgressive = false;\n    util.each(this._progressiveLayers, function (layer) {\n      if (layer.__maxProgress >= layer.__progress) {\n        this._furtherProgressive = true;\n      }\n    }, this);\n  },\n  _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n    var ctx = currentLayer.ctx;\n    var m = el.transform;\n\n    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element\n    !el.invisible // Ignore transparent element\n    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas\n    // Draw a scale 0 element can cause all following draw wrong\n    // And setTransform with scale 0 will cause set back transform failed.\n    && !(m && !m[0] && !m[3]) // Ignore culled element\n    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n      var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements\n\n      if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {\n        // If has previous clipping state, restore from it\n        if (scope.prevElClipPaths) {\n          scope.prevClipLayer.ctx.restore();\n          scope.prevClipLayer = scope.prevElClipPaths = null; // Reset prevEl since context has been restored\n\n          scope.prevEl = null;\n        } // New clipping state\n\n\n        if (clipPaths) {\n          ctx.save();\n          doClip(clipPaths, ctx);\n          scope.prevClipLayer = currentLayer;\n          scope.prevElClipPaths = clipPaths;\n        }\n      }\n\n      el.beforeBrush && el.beforeBrush(ctx);\n      el.brush(ctx, scope.prevEl || null);\n      scope.prevEl = el;\n      el.afterBrush && el.afterBrush(ctx);\n    }\n  },\n\n  /**\n   * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n   * @param {number} zlevel\n   * @return {module:zrender/Layer}\n   */\n  getLayer: function (zlevel) {\n    if (this._singleCanvas) {\n      return this._layers[0];\n    }\n\n    var layer = this._layers[zlevel];\n\n    if (!layer) {\n      // Create a new layer\n      layer = new Layer('zr_' + zlevel, this, this.dpr);\n      layer.__builtin__ = true;\n\n      if (this._layerConfig[zlevel]) {\n        util.merge(layer, this._layerConfig[zlevel], true);\n      }\n\n      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document\n      // Or excanvas will get 0px clientWidth and clientHeight\n\n      layer.initContext();\n    }\n\n    return layer;\n  },\n  insertLayer: function (zlevel, layer) {\n    var layersMap = this._layers;\n    var zlevelList = this._zlevelList;\n    var len = zlevelList.length;\n    var prevLayer = null;\n    var i = -1;\n    var domRoot = this._domRoot;\n\n    if (layersMap[zlevel]) {\n      log('ZLevel ' + zlevel + ' has been used already');\n      return;\n    } // Check if is a valid layer\n\n\n    if (!isLayerValid(layer)) {\n      log('Layer of zlevel ' + zlevel + ' is not valid');\n      return;\n    }\n\n    if (len > 0 && zlevel > zlevelList[0]) {\n      for (i = 0; i < len - 1; i++) {\n        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n          break;\n        }\n      }\n\n      prevLayer = layersMap[zlevelList[i]];\n    }\n\n    zlevelList.splice(i + 1, 0, zlevel);\n    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.\n    // (It can be a WebGL layer and assigned to a ZImage element)\n    // But it still under management of zrender.\n\n    if (!layer.virtual) {\n      if (prevLayer) {\n        var prevDom = prevLayer.dom;\n\n        if (prevDom.nextSibling) {\n          domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      } else {\n        if (domRoot.firstChild) {\n          domRoot.insertBefore(layer.dom, domRoot.firstChild);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      }\n    }\n  },\n  // Iterate each layer\n  eachLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      cb.call(context, this._layers[z], z);\n    }\n  },\n  // Iterate each buildin layer\n  eachBuiltinLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n  // Iterate each other layer except buildin layer\n  eachOtherLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (!layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n\n  /**\n   * 获取所有已创建的层\n   * @param {Array.<module:zrender/Layer>} [prevLayer]\n   */\n  getLayers: function () {\n    return this._layers;\n  },\n  _updateLayerStatus: function (list) {\n    var layers = this._layers;\n    var progressiveLayers = this._progressiveLayers;\n    var elCountsLastFrame = {};\n    var progressiveElCountsLastFrame = {};\n    this.eachBuiltinLayer(function (layer, z) {\n      elCountsLastFrame[z] = layer.elCount;\n      layer.elCount = 0;\n      layer.__dirty = false;\n    });\n    util.each(progressiveLayers, function (layer, idx) {\n      progressiveElCountsLastFrame[idx] = layer.elCount;\n      layer.elCount = 0;\n      layer.__dirty = false;\n    });\n    var progressiveLayerCount = 0;\n    var currentProgressiveLayer;\n    var lastProgressiveKey;\n    var frameCount = 0;\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      var el = list[i];\n      var zlevel = this._singleCanvas ? 0 : el.zlevel;\n      var layer = layers[zlevel];\n      var elProgress = el.progressive;\n\n      if (layer) {\n        layer.elCount++;\n        layer.__dirty = layer.__dirty || el.__dirty;\n      } /////// Update progressive\n\n\n      if (elProgress >= 0) {\n        // Fix wrong progressive sequence problem.\n        if (lastProgressiveKey !== elProgress) {\n          lastProgressiveKey = elProgress;\n          frameCount++;\n        }\n\n        var elFrame = el.__frame = frameCount - 1;\n\n        if (!currentProgressiveLayer) {\n          var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n          currentProgressiveLayer = progressiveLayers[idx];\n\n          if (!currentProgressiveLayer) {\n            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);\n            currentProgressiveLayer.initContext();\n          }\n\n          currentProgressiveLayer.__maxProgress = 0;\n        }\n\n        currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n        currentProgressiveLayer.elCount++;\n        currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);\n\n        if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n          // Should keep rendering this  layer because progressive rendering is not finished yet\n          layer.__dirty = true;\n        }\n      } else {\n        el.__frame = -1;\n\n        if (currentProgressiveLayer) {\n          currentProgressiveLayer.__nextIdxNotProg = i;\n          progressiveLayerCount++;\n          currentProgressiveLayer = null;\n        }\n      }\n    }\n\n    if (currentProgressiveLayer) {\n      progressiveLayerCount++;\n      currentProgressiveLayer.__nextIdxNotProg = i;\n    } // 层中的元素数量有发生变化\n\n\n    this.eachBuiltinLayer(function (layer, z) {\n      if (elCountsLastFrame[z] !== layer.elCount) {\n        layer.__dirty = true;\n      }\n    });\n    progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n    util.each(progressiveLayers, function (layer, idx) {\n      if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n        el.__dirty = true;\n      }\n\n      if (layer.__dirty) {\n        layer.__progress = 0;\n      }\n    });\n  },\n\n  /**\n   * 清除hover层外所有内容\n   */\n  clear: function () {\n    this.eachBuiltinLayer(this._clearLayer);\n    return this;\n  },\n  _clearLayer: function (layer) {\n    layer.clear();\n  },\n\n  /**\n   * 修改指定zlevel的绘制参数\n   *\n   * @param {string} zlevel\n   * @param {Object} config 配置对象\n   * @param {string} [config.clearColor=0] 每次清空画布的颜色\n   * @param {string} [config.motionBlur=false] 是否开启动态模糊\n   * @param {number} [config.lastFrameAlpha=0.7]\n   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n   */\n  configLayer: function (zlevel, config) {\n    if (config) {\n      var layerConfig = this._layerConfig;\n\n      if (!layerConfig[zlevel]) {\n        layerConfig[zlevel] = config;\n      } else {\n        util.merge(layerConfig[zlevel], config, true);\n      }\n\n      var layer = this._layers[zlevel];\n\n      if (layer) {\n        util.merge(layer, layerConfig[zlevel], true);\n      }\n    }\n  },\n\n  /**\n   * 删除指定层\n   * @param {number} zlevel 层所在的zlevel\n   */\n  delLayer: function (zlevel) {\n    var layers = this._layers;\n    var zlevelList = this._zlevelList;\n    var layer = layers[zlevel];\n\n    if (!layer) {\n      return;\n    }\n\n    layer.dom.parentNode.removeChild(layer.dom);\n    delete layers[zlevel];\n    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n  },\n\n  /**\n   * 区域大小变化后重绘\n   */\n  resize: function (width, height) {\n    var domRoot = this._domRoot; // FIXME Why ?\n\n    domRoot.style.display = 'none'; // Save input w/h\n\n    var opts = this._opts;\n    width != null && (opts.width = width);\n    height != null && (opts.height = height);\n    width = this._getSize(0);\n    height = this._getSize(1);\n    domRoot.style.display = ''; // 优化没有实际改变的resize\n\n    if (this._width != width || height != this._height) {\n      domRoot.style.width = width + 'px';\n      domRoot.style.height = height + 'px';\n\n      for (var id in this._layers) {\n        if (this._layers.hasOwnProperty(id)) {\n          this._layers[id].resize(width, height);\n        }\n      }\n\n      util.each(this._progressiveLayers, function (layer) {\n        layer.resize(width, height);\n      });\n      this.refresh(true);\n    }\n\n    this._width = width;\n    this._height = height;\n    return this;\n  },\n\n  /**\n   * 清除单独的一个层\n   * @param {number} zlevel\n   */\n  clearLayer: function (zlevel) {\n    var layer = this._layers[zlevel];\n\n    if (layer) {\n      layer.clear();\n    }\n  },\n\n  /**\n   * 释放\n   */\n  dispose: function () {\n    this.root.innerHTML = '';\n    this.root = this.storage = this._domRoot = this._layers = null;\n  },\n\n  /**\n   * Get canvas which has all thing rendered\n   * @param {Object} opts\n   * @param {string} [opts.backgroundColor]\n   * @param {number} [opts.pixelRatio]\n   */\n  getRenderedCanvas: function (opts) {\n    opts = opts || {};\n\n    if (this._singleCanvas) {\n      return this._layers[0].dom;\n    }\n\n    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n    imageLayer.initContext();\n    imageLayer.clearColor = opts.backgroundColor;\n    imageLayer.clear();\n    var displayList = this.storage.getDisplayList(true);\n    var scope = {};\n    var zlevel;\n    var self = this;\n\n    function findAndDrawOtherLayer(smaller, larger) {\n      var zlevelList = self._zlevelList;\n\n      if (smaller == null) {\n        smaller = -Infinity;\n      }\n\n      var intermediateLayer;\n\n      for (var i = 0; i < zlevelList.length; i++) {\n        var z = zlevelList[i];\n        var layer = self._layers[z];\n\n        if (!layer.__builtin__ && z > smaller && z < larger) {\n          intermediateLayer = layer;\n          break;\n        }\n      }\n\n      if (intermediateLayer && intermediateLayer.renderToCanvas) {\n        imageLayer.ctx.save();\n        intermediateLayer.renderToCanvas(imageLayer.ctx);\n        imageLayer.ctx.restore();\n      }\n    }\n\n    for (var i = 0; i < displayList.length; i++) {\n      var el = displayList[i];\n\n      if (el.zlevel !== zlevel) {\n        findAndDrawOtherLayer(zlevel, el.zlevel);\n        zlevel = el.zlevel;\n      }\n\n      this._doPaintEl(el, imageLayer, true, scope);\n    }\n\n    findAndDrawOtherLayer(zlevel, Infinity);\n    return imageLayer.dom;\n  },\n\n  /**\n   * 获取绘图区域宽度\n   */\n  getWidth: function () {\n    return this._width;\n  },\n\n  /**\n   * 获取绘图区域高度\n   */\n  getHeight: function () {\n    return this._height;\n  },\n  _getSize: function (whIdx) {\n    var opts = this._opts;\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n      return parseFloat(opts[wh]);\n    }\n\n    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\n    var stl = document.defaultView.getComputedStyle(root);\n    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n  },\n  pathToImage: function (path, dpr) {\n    dpr = dpr || this.dpr;\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    var rect = path.getBoundingRect();\n    var style = path.style;\n    var shadowBlurSize = style.shadowBlur;\n    var shadowOffsetX = style.shadowOffsetX;\n    var shadowOffsetY = style.shadowOffsetY;\n    var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n    var width = rect.width + leftMargin + rightMargin;\n    var height = rect.height + topMargin + bottomMargin;\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    ctx.scale(dpr, dpr);\n    ctx.clearRect(0, 0, width, height);\n    ctx.dpr = dpr;\n    var pathTransform = {\n      position: path.position,\n      rotation: path.rotation,\n      scale: path.scale\n    };\n    path.position = [leftMargin - rect.x, topMargin - rect.y];\n    path.rotation = 0;\n    path.scale = [1, 1];\n    path.updateTransform();\n\n    if (path) {\n      path.brush(ctx);\n    }\n\n    var ImageShape = Image;\n    var imgShape = new ImageShape({\n      style: {\n        x: 0,\n        y: 0,\n        image: canvas\n      }\n    });\n\n    if (pathTransform.position != null) {\n      imgShape.position = path.position = pathTransform.position;\n    }\n\n    if (pathTransform.rotation != null) {\n      imgShape.rotation = path.rotation = pathTransform.rotation;\n    }\n\n    if (pathTransform.scale != null) {\n      imgShape.scale = path.scale = pathTransform.scale;\n    }\n\n    return imgShape;\n  }\n};\nvar _default = Painter;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Painter.js\n// module id = 73\n// module chunks = 0","var util = require(\"./core/util\");\n\nvar _config = require(\"./config\");\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar Style = require(\"./graphic/Style\");\n\nvar Pattern = require(\"./graphic/Pattern\");\n\n/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\nfunction returnFalse() {\n  return false;\n}\n/**\n * 创建dom\n *\n * @inner\n * @param {string} id dom id 待用\n * @param {Painter} painter painter instance\n * @param {number} number\n */\n\n\nfunction createDom(id, painter, dpr) {\n  var newDom = util.createCanvas();\n  var width = painter.getWidth();\n  var height = painter.getHeight();\n  var newDomStyle = newDom.style; // 没append呢，请原谅我这样写，清晰~\n\n  newDomStyle.position = 'absolute';\n  newDomStyle.left = 0;\n  newDomStyle.top = 0;\n  newDomStyle.width = width + 'px';\n  newDomStyle.height = height + 'px';\n  newDom.width = width * dpr;\n  newDom.height = height * dpr; // id不作为索引用，避免可能造成的重名，定义为私有属性\n\n  newDom.setAttribute('data-zr-dom-id', id);\n  return newDom;\n}\n/**\n * @alias module:zrender/Layer\n * @constructor\n * @extends module:zrender/mixin/Transformable\n * @param {string} id\n * @param {module:zrender/Painter} painter\n * @param {number} [dpr]\n */\n\n\nvar Layer = function (id, painter, dpr) {\n  var dom;\n  dpr = dpr || devicePixelRatio;\n\n  if (typeof id === 'string') {\n    dom = createDom(id, painter, dpr);\n  } // Not using isDom because in node it will return false\n  else if (util.isObject(id)) {\n      dom = id;\n      id = dom.id;\n    }\n\n  this.id = id;\n  this.dom = dom;\n  var domStyle = dom.style;\n\n  if (domStyle) {\n    // Not in node\n    dom.onselectstart = returnFalse; // 避免页面选中的尴尬\n\n    domStyle['-webkit-user-select'] = 'none';\n    domStyle['user-select'] = 'none';\n    domStyle['-webkit-touch-callout'] = 'none';\n    domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n    domStyle['padding'] = 0;\n    domStyle['margin'] = 0;\n    domStyle['border-width'] = 0;\n  }\n\n  this.domBack = null;\n  this.ctxBack = null;\n  this.painter = painter;\n  this.config = null; // Configs\n\n  /**\n   * 每次清空画布的颜色\n   * @type {string}\n   * @default 0\n   */\n\n  this.clearColor = 0;\n  /**\n   * 是否开启动态模糊\n   * @type {boolean}\n   * @default false\n   */\n\n  this.motionBlur = false;\n  /**\n   * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n   * @type {number}\n   * @default 0.7\n   */\n\n  this.lastFrameAlpha = 0.7;\n  /**\n   * Layer dpr\n   * @type {number}\n   */\n\n  this.dpr = dpr;\n};\n\nLayer.prototype = {\n  constructor: Layer,\n  elCount: 0,\n  __dirty: true,\n  initContext: function () {\n    this.ctx = this.dom.getContext('2d');\n    this.ctx.__currentValues = {};\n    this.ctx.dpr = this.dpr;\n  },\n  createBackBuffer: function () {\n    var dpr = this.dpr;\n    this.domBack = createDom('back-' + this.id, this.painter, dpr);\n    this.ctxBack = this.domBack.getContext('2d');\n    this.ctxBack.__currentValues = {};\n\n    if (dpr != 1) {\n      this.ctxBack.scale(dpr, dpr);\n    }\n  },\n\n  /**\n   * @param  {number} width\n   * @param  {number} height\n   */\n  resize: function (width, height) {\n    var dpr = this.dpr;\n    var dom = this.dom;\n    var domStyle = dom.style;\n    var domBack = this.domBack;\n    domStyle.width = width + 'px';\n    domStyle.height = height + 'px';\n    dom.width = width * dpr;\n    dom.height = height * dpr;\n\n    if (domBack) {\n      domBack.width = width * dpr;\n      domBack.height = height * dpr;\n\n      if (dpr != 1) {\n        this.ctxBack.scale(dpr, dpr);\n      }\n    }\n  },\n\n  /**\n   * 清空该层画布\n   * @param {boolean} clearAll Clear all with out motion blur\n   */\n  clear: function (clearAll) {\n    var dom = this.dom;\n    var ctx = this.ctx;\n    var width = dom.width;\n    var height = dom.height;\n    var clearColor = this.clearColor;\n    var haveMotionBLur = this.motionBlur && !clearAll;\n    var lastFrameAlpha = this.lastFrameAlpha;\n    var dpr = this.dpr;\n\n    if (haveMotionBLur) {\n      if (!this.domBack) {\n        this.createBackBuffer();\n      }\n\n      this.ctxBack.globalCompositeOperation = 'copy';\n      this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);\n    }\n\n    ctx.clearRect(0, 0, width, height);\n\n    if (clearColor) {\n      var clearColorGradientOrPattern; // Gradient\n\n      if (clearColor.colorStops) {\n        // Cache canvas gradient\n        clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n          x: 0,\n          y: 0,\n          width: width,\n          height: height\n        });\n        clearColor.__canvasGradient = clearColorGradientOrPattern;\n      } // Pattern\n      else if (clearColor.image) {\n          clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n        }\n\n      ctx.save();\n      ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n      ctx.fillRect(0, 0, width, height);\n      ctx.restore();\n    }\n\n    if (haveMotionBLur) {\n      var domBack = this.domBack;\n      ctx.save();\n      ctx.globalAlpha = lastFrameAlpha;\n      ctx.drawImage(domBack, 0, 0, width, height);\n      ctx.restore();\n    }\n  }\n};\nvar _default = Layer;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Layer.js\n// module id = 74\n// module chunks = 0","var _default = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809\nwindow.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {\n  setTimeout(func, 16);\n};\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/requestAnimationFrame.js\n// module id = 75\n// module chunks = 0","var util = require(\"../core/util\");\n\nvar _event = require(\"../core/event\");\n\nvar Dispatcher = _event.Dispatcher;\n\nvar requestAnimationFrame = require(\"./requestAnimationFrame\");\n\nvar Animator = require(\"./Animator\");\n\n/**\n * 动画主类, 调度和管理所有动画控制器\n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n/**\n * @typedef {Object} IZRenderStage\n * @property {Function} update\n */\n\n/**\n * @alias module:zrender/animation/Animation\n * @constructor\n * @param {Object} [options]\n * @param {Function} [options.onframe]\n * @param {IZRenderStage} [options.stage]\n * @example\n *     var animation = new Animation();\n *     var obj = {\n *         x: 100,\n *         y: 100\n *     };\n *     animation.animate(node.position)\n *         .when(1000, {\n *             x: 500,\n *             y: 500\n *         })\n *         .when(2000, {\n *             x: 100,\n *             y: 100\n *         })\n *         .start('spline');\n */\nvar Animation = function (options) {\n  options = options || {};\n  this.stage = options.stage || {};\n\n  this.onframe = options.onframe || function () {}; // private properties\n\n\n  this._clips = [];\n  this._running = false;\n  this._time;\n  this._pausedTime;\n  this._pauseStart;\n  this._paused = false;\n  Dispatcher.call(this);\n};\n\nAnimation.prototype = {\n  constructor: Animation,\n\n  /**\n   * 添加 clip\n   * @param {module:zrender/animation/Clip} clip\n   */\n  addClip: function (clip) {\n    this._clips.push(clip);\n  },\n\n  /**\n   * 添加 animator\n   * @param {module:zrender/animation/Animator} animator\n   */\n  addAnimator: function (animator) {\n    animator.animation = this;\n    var clips = animator.getClips();\n\n    for (var i = 0; i < clips.length; i++) {\n      this.addClip(clips[i]);\n    }\n  },\n\n  /**\n   * 删除动画片段\n   * @param {module:zrender/animation/Clip} clip\n   */\n  removeClip: function (clip) {\n    var idx = util.indexOf(this._clips, clip);\n\n    if (idx >= 0) {\n      this._clips.splice(idx, 1);\n    }\n  },\n\n  /**\n   * 删除动画片段\n   * @param {module:zrender/animation/Animator} animator\n   */\n  removeAnimator: function (animator) {\n    var clips = animator.getClips();\n\n    for (var i = 0; i < clips.length; i++) {\n      this.removeClip(clips[i]);\n    }\n\n    animator.animation = null;\n  },\n  _update: function () {\n    var time = new Date().getTime() - this._pausedTime;\n\n    var delta = time - this._time;\n    var clips = this._clips;\n    var len = clips.length;\n    var deferredEvents = [];\n    var deferredClips = [];\n\n    for (var i = 0; i < len; i++) {\n      var clip = clips[i];\n      var e = clip.step(time, delta); // Throw out the events need to be called after\n      // stage.update, like destroy\n\n      if (e) {\n        deferredEvents.push(e);\n        deferredClips.push(clip);\n      }\n    } // Remove the finished clip\n\n\n    for (var i = 0; i < len;) {\n      if (clips[i]._needsRemove) {\n        clips[i] = clips[len - 1];\n        clips.pop();\n        len--;\n      } else {\n        i++;\n      }\n    }\n\n    len = deferredEvents.length;\n\n    for (var i = 0; i < len; i++) {\n      deferredClips[i].fire(deferredEvents[i]);\n    }\n\n    this._time = time;\n    this.onframe(delta);\n    this.trigger('frame', delta);\n\n    if (this.stage.update) {\n      this.stage.update();\n    }\n  },\n  _startLoop: function () {\n    var self = this;\n    this._running = true;\n\n    function step() {\n      if (self._running) {\n        requestAnimationFrame(step);\n        !self._paused && self._update();\n      }\n    }\n\n    requestAnimationFrame(step);\n  },\n\n  /**\n   * 开始运行动画\n   */\n  start: function () {\n    this._time = new Date().getTime();\n    this._pausedTime = 0;\n\n    this._startLoop();\n  },\n\n  /**\n   * 停止运行动画\n   */\n  stop: function () {\n    this._running = false;\n  },\n\n  /**\n   * Pause\n   */\n  pause: function () {\n    if (!this._paused) {\n      this._pauseStart = new Date().getTime();\n      this._paused = true;\n    }\n  },\n\n  /**\n   * Resume\n   */\n  resume: function () {\n    if (this._paused) {\n      this._pausedTime += new Date().getTime() - this._pauseStart;\n      this._paused = false;\n    }\n  },\n\n  /**\n   * 清除所有动画片段\n   */\n  clear: function () {\n    this._clips = [];\n  },\n\n  /**\n   * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画\n   * @param  {Object} target\n   * @param  {Object} options\n   * @param  {boolean} [options.loop=false] 是否循环播放动画\n   * @param  {Function} [options.getter=null]\n   *         如果指定getter函数，会通过getter函数取属性值\n   * @param  {Function} [options.setter=null]\n   *         如果指定setter函数，会通过setter函数设置属性值\n   * @return {module:zrender/animation/Animation~Animator}\n   */\n  // TODO Gap\n  animate: function (target, options) {\n    options = options || {};\n    var animator = new Animator(target, options.loop, options.getter, options.setter);\n    this.addAnimator(animator);\n    return animator;\n  }\n};\nutil.mixin(Animation, Dispatcher);\nvar _default = Animation;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Animation.js\n// module id = 76\n// module chunks = 0","var Eventful = require(\"../mixin/Eventful\");\n\nexports.Dispatcher = Eventful;\n\nvar env = require(\"./env\");\n\n/**\n * 事件辅助类\n * @module zrender/core/event\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n */\nvar isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\nvar MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;\n\nfunction getBoundingClientRect(el) {\n  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n  return el.getBoundingClientRect ? el.getBoundingClientRect() : {\n    left: 0,\n    top: 0\n  };\n} // `calculate` is optional, default false\n\n\nfunction clientToLocal(el, e, out, calculate) {\n  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative\n  // to the padding edge of the target element. The only browser using this convention\n  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n  // not support the properties.\n  // (see http://www.jacklmoore.com/notes/mouse-position/)\n  // In zr painter.dom, padding edge equals to border edge.\n  // FIXME\n  // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n  // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n  // is too complex. So css-transfrom dont support in this case temporarily.\n\n  if (calculate || !env.canvasSupported) {\n    defaultGetZrXY(el, e, out);\n  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n  // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n  // zoom-factor, overflow / opacity layers, transforms ...)\n  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n  // <https://bugs.jquery.com/ticket/8523#comment:14>\n  // BTW3, In ff, offsetX/offsetY is always 0.\n  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n      out.zrX = e.layerX;\n      out.zrY = e.layerY;\n    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n    else if (e.offsetX != null) {\n        out.zrX = e.offsetX;\n        out.zrY = e.offsetY;\n      } // For some other device, e.g., IOS safari.\n      else {\n          defaultGetZrXY(el, e, out);\n        }\n\n  return out;\n}\n\nfunction defaultGetZrXY(el, e, out) {\n  // This well-known method below does not support css transform.\n  var box = getBoundingClientRect(el);\n  out.zrX = e.clientX - box.left;\n  out.zrY = e.clientY - box.top;\n}\n/**\n * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.\n * `calculate` is optional, default false.\n */\n\n\nfunction normalizeEvent(el, e, calculate) {\n  e = e || window.event;\n\n  if (e.zrX != null) {\n    return e;\n  }\n\n  var eventType = e.type;\n  var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n  if (!isTouch) {\n    clientToLocal(el, e, e, calculate);\n    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n  } else {\n    var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n    touch && clientToLocal(el, touch, e, calculate);\n  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;\n  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js\n  // If e.which has been defined, if may be readonly,\n  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which\n\n\n  var button = e.button;\n\n  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {\n    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n  }\n\n  return e;\n}\n\nfunction addEventListener(el, name, handler) {\n  if (isDomLevel2) {\n    el.addEventListener(name, handler);\n  } else {\n    el.attachEvent('on' + name, handler);\n  }\n}\n\nfunction removeEventListener(el, name, handler) {\n  if (isDomLevel2) {\n    el.removeEventListener(name, handler);\n  } else {\n    el.detachEvent('on' + name, handler);\n  }\n}\n/**\n * preventDefault and stopPropagation.\n * Notice: do not do that in zrender. Upper application\n * do that if necessary.\n *\n * @memberOf module:zrender/core/event\n * @method\n * @param {Event} e : event对象\n */\n\n\nvar stop = isDomLevel2 ? function (e) {\n  e.preventDefault();\n  e.stopPropagation();\n  e.cancelBubble = true;\n} : function (e) {\n  e.returnValue = false;\n  e.cancelBubble = true;\n};\n\nfunction notLeftMouse(e) {\n  // If e.which is undefined, considered as left mouse event.\n  return e.which > 1;\n} // 做向上兼容\n\n\nexports.clientToLocal = clientToLocal;\nexports.normalizeEvent = normalizeEvent;\nexports.addEventListener = addEventListener;\nexports.removeEventListener = removeEventListener;\nexports.stop = stop;\nexports.notLeftMouse = notLeftMouse;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/event.js\n// module id = 77\n// module chunks = 0","var _event = require(\"../core/event\");\n\nvar addEventListener = _event.addEventListener;\nvar removeEventListener = _event.removeEventListener;\nvar normalizeEvent = _event.normalizeEvent;\n\nvar zrUtil = require(\"../core/util\");\n\nvar Eventful = require(\"../mixin/Eventful\");\n\nvar env = require(\"../core/env\");\n\nvar GestureMgr = require(\"../core/GestureMgr\");\n\nvar TOUCH_CLICK_DELAY = 300;\nvar mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\nvar touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];\nvar pointerEventNames = {\n  pointerdown: 1,\n  pointerup: 1,\n  pointermove: 1,\n  pointerout: 1\n};\nvar pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n  var nm = name.replace('mouse', 'pointer');\n  return pointerEventNames[nm] ? nm : name;\n});\n\nfunction eventNameFix(name) {\n  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n}\n\nfunction processGesture(proxy, event, stage) {\n  var gestureMgr = proxy._gestureMgr;\n  stage === 'start' && gestureMgr.clear();\n  var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null).target, proxy.dom);\n  stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.\n\n  if (gestureInfo) {\n    var type = gestureInfo.type;\n    event.gestureEvent = type;\n    proxy.handler.dispatchToElement({\n      target: gestureInfo.target\n    }, type, gestureInfo.event);\n  }\n} // function onMSGestureChange(proxy, event) {\n//     if (event.translationX || event.translationY) {\n//         // mousemove is carried by MSGesture to reduce the sensitivity.\n//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n//     }\n//     if (event.scale !== 1) {\n//         event.pinchX = event.offsetX;\n//         event.pinchY = event.offsetY;\n//         event.pinchScale = event.scale;\n//         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n//     }\n// }\n\n/**\n * Prevent mouse event from being dispatched after Touch Events action\n * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n * Result: Blocking Mouse Events for 700ms.\n */\n\n\nfunction setTouchTimer(instance) {\n  instance._touching = true;\n  clearTimeout(instance._touchTimer);\n  instance._touchTimer = setTimeout(function () {\n    instance._touching = false;\n  }, 700);\n}\n\nvar domHandlers = {\n  /**\n   * Mouse move handler\n   * @inner\n   * @param {Event} event\n   */\n  mousemove: function (event) {\n    event = normalizeEvent(this.dom, event);\n    this.trigger('mousemove', event);\n  },\n\n  /**\n   * Mouse out handler\n   * @inner\n   * @param {Event} event\n   */\n  mouseout: function (event) {\n    event = normalizeEvent(this.dom, event);\n    var element = event.toElement || event.relatedTarget;\n\n    if (element != this.dom) {\n      while (element && element.nodeType != 9) {\n        // 忽略包含在root中的dom引起的mouseOut\n        if (element === this.dom) {\n          return;\n        }\n\n        element = element.parentNode;\n      }\n    }\n\n    this.trigger('mouseout', event);\n  },\n\n  /**\n   * Touch开始响应函数\n   * @inner\n   * @param {Event} event\n   */\n  touchstart: function (event) {\n    // Default mouse behaviour should not be disabled here.\n    // For example, page may needs to be slided.\n    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n    // mouse event in upper applicatoin.\n\n    event.zrByTouch = true;\n    this._lastTouchMoment = new Date();\n    processGesture(this, event, 'start'); // In touch device, trigger `mousemove`(`mouseover`) should\n    // be triggered, and must before `mousedown` triggered.\n\n    domHandlers.mousemove.call(this, event);\n    domHandlers.mousedown.call(this, event);\n    setTouchTimer(this);\n  },\n\n  /**\n   * Touch移动响应函数\n   * @inner\n   * @param {Event} event\n   */\n  touchmove: function (event) {\n    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n    // mouse event in upper applicatoin.\n\n    event.zrByTouch = true;\n    processGesture(this, event, 'change'); // Mouse move should always be triggered no matter whether\n    // there is gestrue event, because mouse move and pinch may\n    // be used at the same time.\n\n    domHandlers.mousemove.call(this, event);\n    setTouchTimer(this);\n  },\n\n  /**\n   * Touch结束响应函数\n   * @inner\n   * @param {Event} event\n   */\n  touchend: function (event) {\n    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n    // mouse event in upper applicatoin.\n\n    event.zrByTouch = true;\n    processGesture(this, event, 'end');\n    domHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n    // we can conveniently implement \"hover style\" in both PC and touch device just\n    // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n    // to remove \"hover style\" on an element, without any additional code for\n    // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n    // style\" will remain for user view)\n    // click event should always be triggered no matter whether\n    // there is gestrue event. System click can not be prevented.\n\n    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n      domHandlers.click.call(this, event);\n    }\n\n    setTouchTimer(this);\n  },\n  pointerdown: function (event) {\n    domHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {\n    //     this._msGesture.addPointer(event.pointerId);\n    // }\n  },\n  pointermove: function (event) {\n    // FIXME\n    // pointermove is so sensitive that it always triggered when\n    // tap(click) on touch screen, which affect some judgement in\n    // upper application. So, we dont support mousemove on MS touch\n    // device yet.\n    if (!isPointerFromTouch(event)) {\n      domHandlers.mousemove.call(this, event);\n    }\n  },\n  pointerup: function (event) {\n    domHandlers.mouseup.call(this, event);\n  },\n  pointerout: function (event) {\n    // pointerout will be triggered when tap on touch screen\n    // (IE11+/Edge on MS Surface) after click event triggered,\n    // which is inconsistent with the mousout behavior we defined\n    // in touchend. So we unify them.\n    // (check domHandlers.touchend for detailed explanation)\n    if (!isPointerFromTouch(event)) {\n      domHandlers.mouseout.call(this, event);\n    }\n  }\n};\n\nfunction isPointerFromTouch(event) {\n  var pointerType = event.pointerType;\n  return pointerType === 'pen' || pointerType === 'touch';\n} // function useMSGuesture(handlerProxy, event) {\n//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n// }\n// Common handlers\n\n\nzrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  domHandlers[name] = function (event) {\n    event = normalizeEvent(this.dom, event);\n    this.trigger(name, event);\n  };\n});\n/**\n * 为控制类实例初始化dom 事件处理函数\n *\n * @inner\n * @param {module:zrender/Handler} instance 控制类实例\n */\n\nfunction initDomHandler(instance) {\n  zrUtil.each(touchHandlerNames, function (name) {\n    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n  });\n  zrUtil.each(pointerHandlerNames, function (name) {\n    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n  });\n  zrUtil.each(mouseHandlerNames, function (name) {\n    instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n  });\n\n  function makeMouseHandler(fn, instance) {\n    return function () {\n      if (instance._touching) {\n        return;\n      }\n\n      return fn.apply(instance, arguments);\n    };\n  }\n}\n\nfunction HandlerDomProxy(dom) {\n  Eventful.call(this);\n  this.dom = dom;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._touching = false;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._touchTimer;\n  /**\n   * @private\n   * @type {module:zrender/core/GestureMgr}\n   */\n\n  this._gestureMgr = new GestureMgr();\n  this._handlers = {};\n  initDomHandler(this);\n\n  if (env.pointerEventsSupported) {\n    // Only IE11+/Edge\n    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n    // at the same time.\n    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n    // screen, which do not occurs in pointer event.\n    // So we use pointer event to both detect touch gesture and mouse behavior.\n    mountHandlers(pointerHandlerNames, this); // FIXME\n    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n    // which does not prevent defuault behavior occasionally (which may cause view port\n    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n    // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n    // touch screen. And we only support click behavior on MS touch screen now.\n    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n    // We dont support touch on IE on win7.\n    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n    // if (typeof MSGesture === 'function') {\n    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n    //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n    // }\n  } else {\n    if (env.touchEventsSupported) {\n      mountHandlers(touchHandlerNames, this); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n      // addEventListener(root, 'mouseout', this._mouseoutHandler);\n    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n    // mouse event can not be handle in those devices.\n    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n    // mouseevent after touch event triggered, see `setTouchTimer`.\n\n\n    mountHandlers(mouseHandlerNames, this);\n  }\n\n  function mountHandlers(handlerNames, instance) {\n    zrUtil.each(handlerNames, function (name) {\n      addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n    }, instance);\n  }\n}\n\nvar handlerDomProxyProto = HandlerDomProxy.prototype;\n\nhandlerDomProxyProto.dispose = function () {\n  var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n  for (var i = 0; i < handlerNames.length; i++) {\n    var name = handlerNames[i];\n    removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n  }\n};\n\nhandlerDomProxyProto.setCursor = function (cursorStyle) {\n  this.dom.style.cursor = cursorStyle || 'default';\n};\n\nzrUtil.mixin(HandlerDomProxy, Eventful);\nvar _default = HandlerDomProxy;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/dom/HandlerProxy.js\n// module id = 78\n// module chunks = 0","var eventUtil = require(\"./event\");\n\n/**\n * Only implements needed gestures for mobile.\n */\nvar GestureMgr = function () {\n  /**\n   * @private\n   * @type {Array.<Object>}\n   */\n  this._track = [];\n};\n\nGestureMgr.prototype = {\n  constructor: GestureMgr,\n  recognize: function (event, target, root) {\n    this._doTrack(event, target, root);\n\n    return this._recognize(event);\n  },\n  clear: function () {\n    this._track.length = 0;\n    return this;\n  },\n  _doTrack: function (event, target, root) {\n    var touches = event.touches;\n\n    if (!touches) {\n      return;\n    }\n\n    var trackItem = {\n      points: [],\n      touches: [],\n      target: target,\n      event: event\n    };\n\n    for (var i = 0, len = touches.length; i < len; i++) {\n      var touch = touches[i];\n      var pos = eventUtil.clientToLocal(root, touch, {});\n      trackItem.points.push([pos.zrX, pos.zrY]);\n      trackItem.touches.push(touch);\n    }\n\n    this._track.push(trackItem);\n  },\n  _recognize: function (event) {\n    for (var eventName in recognizers) {\n      if (recognizers.hasOwnProperty(eventName)) {\n        var gestureInfo = recognizers[eventName](this._track, event);\n\n        if (gestureInfo) {\n          return gestureInfo;\n        }\n      }\n    }\n  }\n};\n\nfunction dist(pointPair) {\n  var dx = pointPair[1][0] - pointPair[0][0];\n  var dy = pointPair[1][1] - pointPair[0][1];\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction center(pointPair) {\n  return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];\n}\n\nvar recognizers = {\n  pinch: function (track, event) {\n    var trackLen = track.length;\n\n    if (!trackLen) {\n      return;\n    }\n\n    var pinchEnd = (track[trackLen - 1] || {}).points;\n    var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {\n      var pinchScale = dist(pinchEnd) / dist(pinchPre);\n      !isFinite(pinchScale) && (pinchScale = 1);\n      event.pinchScale = pinchScale;\n      var pinchCenter = center(pinchEnd);\n      event.pinchX = pinchCenter[0];\n      event.pinchY = pinchCenter[1];\n      return {\n        type: 'pinch',\n        target: track[0].target,\n        event: event\n      };\n    }\n  } // Only pinch currently.\n\n};\nvar _default = GestureMgr;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/GestureMgr.js\n// module id = 79\n// module chunks = 0","/**\r\n * 选中节点后，出现的操作框及按钮\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var Node = require(\"../Node\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var Util = require(\"../util.js\");\r\n    var graphic = require(\"../graphic.js\");\r\n    var Connector = require(\"../shapes/Connector.js\");\r\n    var env = require('zrender/lib/core/env');\r\n    var icon = require('./IconOperation');\r\n    var symbolUtil = require('../shapes/Symbol');\r\n    function OperationNode(node, zr, api,forbidEdit) {\r\n        Node.call(this);\r\n        this.node = node;\r\n        this.zr = zr;\r\n        this.forbidEdit = forbidEdit;\r\n        this._api = api;\r\n        this.render();\r\n    }\r\n\r\n    //事件\r\n    OperationNode.ARROW_DRAGEND = \"OperationNode:dragendArrow\";\r\n    OperationNode.ARROW_DRAG = \"OperationNode:dragArrow\";\r\n    OperationNode.ARROW_DRAGSTART = \"OperationNode:dragstartArrow\";\r\n    OperationNode.DELETE_CLICK = \"OperationNode:deleteClick\";\r\n    OperationNode.DEL = \"DEL\";\r\n    OperationNode.COMMENT_CLICK = \"OperationNode:commentClick\";\r\n    OperationNode.COMMENT = \"COMMENT\";\r\n        //内置操作图标的图像\r\n    OperationNode.opicons = {\r\n        STRAIGHT: icon.STRAIGHT_SVG,\r\n        JAGGED: icon.JAGGED_SVG,\r\n        CURVE: icon.CURVE_SVG,\r\n        DEL: icon.DEL_SVG,\r\n        COMMENT: icon.COMMENT_SVG\r\n    };\r\n\r\n    OperationNode.prototype.render = function() {\r\n        this.renderBase();\r\n        if (!this.forbidEdit) {\r\n            this.renderOther();\r\n        }\r\n    };\r\n\r\n    OperationNode.prototype.renderBase = function() {\r\n        this.createOperation();\r\n    };\r\n\r\n    OperationNode.prototype.createOperation = function() {\r\n        var me = this;\r\n        var ifShowNodeOperationIcons = this.node.operationIcons;\r\n        if (this.node.parent && this.node.parent.type === 'dragSelect') {\r\n            ifShowNodeOperationIcons = false;\r\n        }\r\n        if (!this.node.selectStyle) {\r\n            this.virtualRect = new graphic.Polyline({ style: { lineDash: [2] } });\r\n            this.virtualRect.isSelfComputePos = true;  // 自己计算位置\r\n            this.add(this.virtualRect);\r\n        } else {\r\n             if (this.node.type === 'ZPath') {  //addHover需要从它自身的构造函数中创建。1.Painter中addHover源码是根据shape与style创建 2.path中的构造函数是返回另一个元素\r\n                this.node._zCloneStyle = this.node.style.clone();\r\n                 this.node.setStyle(this.node.selectStyle);\r\n             } else if(this.node.setOrCancelSelectStyle) {\r\n                this.node.setOrCancelSelectStyle(true);\r\n             } else {\r\n                this._api.getZr().addHover(this.node, this.node.selectStyle);\r\n             }\r\n\r\n        }\r\n\r\n        if (ifShowNodeOperationIcons) {\r\n            zrUtil.each(this.node.operationIcons, function(item) {\r\n                //检查是否是内置图标\r\n                var opIconInstance = null;\r\n                var operationIcon = OperationNode.opicons[item.name.toUpperCase() + \"\"]\r\n                if (operationIcon) {\r\n\r\n                    if (this.forbidEdit) {\r\n                        return;\r\n                    }\r\n                    if (item.hidden) {\r\n                        return;\r\n                    }\r\n                    if (item.name == OperationNode.DEL) {\r\n                        //垃圾桶\r\n                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' },z:me.node.z+1,rectHover: true }, { x: 0, y: 0, width: 10, height: 15 });\r\n\r\n                        if(item.callback){\r\n                            opIconInstance.on(\"click\", function(e) {\r\n                                e.data = item;\r\n                                e.node = me.node;  // 将所附的节点也传递出去\r\n                                if (item.callback) {\r\n                                    item.callback(e);\r\n                                }\r\n                            });\r\n                        }else{\r\n                            opIconInstance.on(\"click\", function(e) {\r\n                                var params = {};\r\n                                params.event = e;\r\n                                params.target = this;\r\n                                params.type = OperationNode.DELETE_CLICK;\r\n                                me.trigger(params.type, params);\r\n                            });\r\n                        }\r\n                    } else if (item.name == OperationNode.COMMENT) {\r\n                        var rect = { x: 0, y: 0, width: 16, height: 16 };\r\n                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' }, z:me.node.z+2, rectHover: true }, rect);\r\n                        opIconInstance.on(\"click\", function(e) {\r\n                            var params = {};\r\n                            params.event = e;\r\n                            params.target = this;\r\n                            params.type = OperationNode.COMMENT_CLICK;\r\n                            me.trigger(params.type, params);\r\n                        });\r\n                    } else {\r\n                        var rectOther = { x: 0, y: 0, width: 15, height: 15 };\r\n                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' },draggable:true,z:me.node.z+2,lineType: Connector[\"TYPE_\" + item.name.toUpperCase()],rectHover: true }, rectOther);\r\n                        var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];\r\n                        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n                            opIconInstance.on(eveName, function(e) {\r\n                                var params = {};\r\n                                params.event = e;\r\n                                params.data = item.options\r\n                                params.type = \"OperationNode:\" + eveName + \"Arrow\";\r\n                                me.trigger(params.type, params);\r\n                            });\r\n                        });\r\n                    }\r\n\r\n                } else {\r\n                    opIconInstance = symbolUtil.createSymbol(item.iconPath, 0, 0, item.width || 15, item.height || 15, me.node.z+1, item.color||'#000');\r\n                    opIconInstance.on(\"click\", function(e) {\r\n                        e.data = item;\r\n                        e.node = me.node;  // 将所附的节点也传递出去\r\n                        if (item.callback) {\r\n                            item.callback(e);\r\n                        }\r\n                        var param = {event:e, type:\"OperationNode:\" + item.name + \"Click\"};\r\n                        me._api.trigger(param.type, param);\r\n                    });\r\n                }\r\n                opIconInstance.name = item.name;\r\n                me.add(opIconInstance);\r\n            });\r\n        }\r\n    };\r\n\r\n    OperationNode.prototype.refreshPostion = function(node, nodeRect) {\r\n        var i = 0;\r\n        var rbPoint = zrUtil.clone(nodeRect.points[2]); //取右下角坐标\r\n        var rotation = node.rotation;\r\n        var angle = rotation / (Math.PI/180);\r\n        if (Math.abs(rotation) > 0) {\r\n            var connectorControls = Util.getConnectorControls(nodeRect, node);\r\n            var brControl = connectorControls.br;\r\n            rbPoint = [brControl.x - nodeRect.x,  brControl.y - nodeRect.y];\r\n        }\r\n        //1.定位虚框\r\n        if (this.virtualRect) {\r\n            this.virtualRect.setShape({ points: nodeRect.points });\r\n            this.virtualRect.attr('rotation', rotation);\r\n        }\r\n        //2.定位每个小图标\r\n        this.eachChild(function(nodeItem) {\r\n            if (!nodeItem.isSelfComputePos) {\r\n                // 8px是第一个操作按钮图标的距离 靠太近不好看    20px是每个图标的间隔  10px是图标向偏的距离\r\n                nodeItem.attr(\"position\", [angle >= 0 ? rbPoint[0] + 8 + (i++ * 20) : rbPoint[0] - 20 - (i++ * 20), rbPoint[1] - 10]);\r\n            }\r\n        });\r\n\r\n        this.refreshPositionOther(node,nodeRect);\r\n    };\r\n\r\n    OperationNode.prototype.renderOther = function() {\r\n        //留给扩展使用\r\n    };\r\n    OperationNode.prototype.refreshPositionOther = function(node,nodeRect) {\r\n        //留给扩展使用\r\n        //3.定位整个operationNode\r\n        if ((node.parent && node.parent.isBg && node.parent.isBg == true) || (node.parent.type === \"GroupNode\")) {\r\n            this.attr(\"position\", [nodeRect.x, nodeRect.y])\r\n        } else {\r\n            var nodeShapeX = node.shape? node.shape.x:0;\r\n            var nodeSahpeY = node.shape? node.shape.y:0;\r\n            this.attr(\"position\", [nodeRect.x + node.parent.position[0]+nodeShapeX, nodeRect.y + node.parent.position[1]+nodeSahpeY])\r\n        }\r\n    };\r\n\r\n    OperationNode.prototype.cleanup = function() {\r\n        if(this.node.selectStyle) {\r\n            if (this.node.type === 'ZPath') {\r\n                this.node.setStyle(this.node._zCloneStyle);\r\n            } else if(this.node.setOrCancelSelectStyle) {\r\n                this.node.setOrCancelSelectStyle(false);\r\n             } else {\r\n                this._api.getZr().removeHover(this.node);\r\n            }\r\n\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(OperationNode, Node);\r\n    module.exports = OperationNode;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/manager/OperationNode.js\n// module id = 80\n// module chunks = 0","\r\n    var graphic = require('./graphic');\r\n    var util = require(\"./util.js\")\r\n    //创建Node类 所有形状都继承Node  包括fromJSON toJSON\r\n    function Node() {\r\n        this.resourceId = util.getUUID(); // 生成节点ID\r\n        graphic.Group.call(this);\r\n    }\r\n\r\n    /**\r\n     * 由父类实现\r\n     * @return {[type]} [description]\r\n     */\r\n    Node.prototype.render = function() {};\r\n\r\n    /**\r\n     * 由父类实现\r\n     * @param  {[type]} json [description]\r\n     * @return {[type]}      [description]\r\n     */\r\n    Node.prototype.getRect = function(json) {};\r\n\r\n    /**\r\n     * drawText\r\n     * @description 画一个文本\r\n     * @param {string} name\r\n     * @param {string} color\r\n     */\r\n    Node.prototype.drawText = function(name, color, position) {\r\n        var textName = this.bpmnInfo.name, x, y;\r\n        if(name != null){\r\n            textName = name;\r\n        }\r\n        var text = new graphic.Text({\r\n            style: {\r\n                text: textName,\r\n                color: color ? color : this.options.text.color,\r\n                textFont: '12px Microsoft YaHei'\r\n            },\r\n            zlevel: 20\r\n        });\r\n        //文字绘制的位置 \r\n        position = position ? position : 'init';\r\n        switch (position) {\r\n            //节点下方居中位置\r\n            case 'init': \r\n                //x = 中心点.x - 起始位置.x - 文字宽度的一半\r\n                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n                //y = 中心点.y - 起始位置.y + 偏移值（6）\r\n                y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + 6;\r\n                break;\r\n            //节点内部居中位置\r\n            case 'center':\r\n                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n                y = this.getRect().y - this.position[1] - 6;\r\n                break;\r\n            //节点内部居左位置\r\n            case 'left': \r\n                x = this.getRect().x - this.position[0] - text.getBoundingRect().width + 6;\r\n                y = this.getRect().y - this.position[1] - 6;\r\n                break;\r\n            default: break;\r\n        }\r\n        text.attr(\"style\", { x: x, y: y });\r\n        return {\r\n            text: text,\r\n            rect: text.getBoundingRect()\r\n        };\r\n    };\r\n    /**\r\n     * refreshText\r\n     * @description 刷新文本\r\n     */\r\n    Node.prototype.refreshText = function(pos) {\r\n        var text = this.childOfName(\"Title\"), x, y;\r\n        pos = pos ? pos : 'init';\r\n        switch (pos) {\r\n            case 'init': \r\n                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n                y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + 6;\r\n                break;\r\n            case 'center':\r\n                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n                y = this.getRect().y - this.position[1] - 6;\r\n                break;\r\n            case 'left':\r\n                x = 2;\r\n                y = this.getRect().y - this.position[1] - 6;\r\n                break;\r\n            default: break;\r\n        }\r\n        text.attr(\"style\", { x: x, y: y });\r\n    };\r\n    /**\r\n     * 由父类实现\r\n     * @return {[type]} [description]\r\n     */\r\n    Node.prototype.toJSON = function() {};\r\n\r\n    graphic.Util.inherits(Node, graphic.Group);\r\n    module.exports = Node;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/Node.js\n// module id = 81\n// module chunks = 0","/**\r\n * 连接线\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var Util = require(\"../util.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var vec2 = require('zrender/lib/core/vector');\r\n    var graphic = require(\"../graphic.js\");\r\n    var Node = require(\"../Node.js\");\r\n    var symbolUtil = require(\"./Symbol.js\");\r\n    var Handle = require(\"./Handle.js\");\r\n    var EffectLine = require(\"./EffectLine.js\");\r\n    var ConnectionPoint = require(\"./ConnectionPoint.js\");\r\n    var Point = require(\"../Point.js\");\r\n    var Model = require(\"../model.js\");\r\n\r\n    Connector.TYPE_STRAIGHT = 'straight';\r\n    Connector.TYPE_JAGGED = 'jagged';\r\n    Connector.TYPE_CURVE = 'curve';\r\n    Connector.TYPE_CHAIN = 'chain';\r\n    Connector.RADIUS = 3;\r\n    Connector.START_NODE = \"startNode\";\r\n    Connector.END_NODE = \"endNode\";\r\n    Connector.LEFT = \"left\";\r\n    Connector.RIGHT = \"right\";\r\n    Connector.TOP = \"top\";\r\n    Connector.BOTTOM = \"bottom\";\r\n    Connector.BOTTOM = \"bottom\";\r\n    Connector.SEPERATOR = \"-\";\r\n    Connector.NORMAL_COLOR = \"#000\";\r\n    Connector.SELECTED_COLOR = '#74B7E0';\r\n    /**\r\n     * 构造函数\r\n     * @param {[type]} options [description]\r\n     */\r\n    function Connector(options) {\r\n        Node.call(this);\r\n        this.opt = options || {};\r\n        if (this.opt.model) {\r\n            this.resourceId = this.opt.model.get(\"resourceId\");\r\n            this.model = this.opt.model;\r\n            this.opt = this.opt.model.option;\r\n        } else {\r\n            this.resourceId = Util.getUUID(); // 生成节点ID\r\n            this.model = new Model({});\r\n        }\r\n        var defaultOptions = {\r\n            symbol: { type: \"arrow\", size: 10, color: Connector.NORMAL_COLOR, both:false, offset:0 }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n            style: { lineWidth: 1, stroke: Connector.NORMAL_COLOR, lineType: Connector.TYPE_STRAIGHT }, //样式\r\n            hoverStyle: { lineWidth: 2, stroke: Connector.SELECTED_COLOR }, //移上去的样式\r\n            arrowHoverStyle: { fill: Connector.SELECTED_COLOR},\r\n            shape: { points: null, smooth: false, smoothConstraint: null }, //形状\r\n            position: { startPos:null, endPos:null,  //指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n                        startOffset:[0,0],  // 起始线段离节点的偏移\r\n                        endOffset:[0,0],    // 终止线段离节点的偏移\r\n                        escapeDistance:[30,30], // 第一条折线的长度，最后一条折线的长度\r\n                        points:null    //不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n                    },\r\n            autoChangePosition: false,\r\n            textContextMenu: null,\r\n            isEdit: true, //是否可编辑\r\n            text: {\r\n                text: null,\r\n                textFill: '#000000', // 文本颜色\r\n                textFont: '12px Microsoft YaHei',\r\n                textPos: 'center',\r\n                textRotateable: true\r\n            },\r\n            z: 0\r\n        }\r\n\r\n        this.options = Util.mergeOpt(defaultOptions, this.opt, true, 'textContextMenu');\r\n        this.handles = [];\r\n        this.conPointsGroup = new graphic.Group();\r\n        this.startNode = null;\r\n        this.endNode = null;\r\n        this.line = null;\r\n        this.groupCurve = new graphic.Group();\r\n        this.icons = []; // 用于存储线段上面的操作图标\r\n        this.render();\r\n    }\r\n\r\n\r\n    /**\r\n     * 重新画线，如果传空则根据turningPoints 重新画线\r\n     * @param  {[type]} points [description]\r\n     * @return {[type]}        [description]\r\n     */\r\n    Connector.prototype.refresh = function(arrPoints) {\r\n        if (arrPoints) {\r\n            this.turningPoints = arrPoints;\r\n        }\r\n        //将[x:0,y:0]转化为[0, 0]  给zrender使用\r\n        var points = Util.traslatePoints(this.turningPoints);\r\n\r\n        if ((this.options.style.lineType == Connector.TYPE_CURVE) && (points.length > 2)) {\r\n            this.modifyCurve(this.turningPoints);\r\n        } else {\r\n            this.line.attr('shape', { points: points });\r\n        }\r\n\r\n        var lineText = this.childOfName('lineText');\r\n        var self = this, lineTextArr = [];\r\n        if (this.options.style.lineType == Connector.TYPE_CHAIN && zrUtil.isArray(this.options.text.text)) {\r\n            this.options.text.text.forEach(function (v, i) {\r\n                lineTextArr.push(self.childOfName('lineText-'+i));\r\n            });\r\n        } else if (!lineText && this.options.text.text) {\r\n            var text = this.drawText(\"lineText\", this.options.text.text, 0, 0);\r\n            this.add(text.text);\r\n            lineText = this.childOfName('lineText');\r\n        }\r\n        if (lineTextArr.length > 0) {\r\n            var cnt = lineTextArr.length,\r\n                distance = this.turningPoints[1].x - this.turningPoints[0].x,\r\n                gap = parseInt(distance/cnt),\r\n                pos = -(gap) * parseInt(cnt/2);\r\n\r\n            lineTextArr.forEach(function (v, i) {\r\n                var textPoint = self.getTextPostion(self.options.text), way = '';\r\n\r\n                var rate = self.getTextRotation(textPoint);\r\n                if (rate === -0 || rate === 0) {\r\n                    rate = 0;\r\n                } else {\r\n                    way = rate > 0 ? 'plus' : 'minus';\r\n                }\r\n                rate = Math.abs(rate);\r\n                var deg = (180*rate)/Math.PI;\r\n                var rotation = null, length = null;\r\n                v.setStyle(\"text\", zrUtil.isString(self.options.text.text[i]) ? self.options.text.text[i] : self.options.text.text[i].text);\r\n\r\n                if (way) {\r\n                    rotation = deg > 90 ? ((deg-45)*Math.PI)/180 : ((45+deg)*Math.PI)/180;\r\n                    rotation = way === 'minus' ? -(rotation) : rotation;\r\n                } else {\r\n                    rotation = (45*Math.PI)/180\r\n                }\r\n                v.attr('rotation', rotation);\r\n\r\n                if (deg === 90) {\r\n                    textPoint[1] -= pos;\r\n                } else {\r\n                    textPoint[0] += pos;\r\n                    if (rate !== 0) {\r\n                        length = Math.tan(deg*Math.PI/180)*pos;\r\n                        if (pos > 0) {\r\n                            textPoint[1] -= way === 'plus' ? length : -(length);\r\n                        } else {\r\n                            textPoint[1] += way === 'plus' ? -(length) : (length);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                v.attr(\"position\", textPoint);\r\n                pos += gap;\r\n            });\r\n        }\r\n        if (lineText) {\r\n            lineText.setStyle(\"text\", this.options.text.text);\r\n            var textPoint = this.getTextPostion(this.options.text);\r\n            if (this.options.style.lineType == Connector.TYPE_STRAIGHT && this.options.text.textRotateable) { //#187\r\n                lineText.attr('rotation', this.getTextRotation(textPoint));\r\n            }\r\n            lineText.attr(\"position\", textPoint);\r\n        }\r\n        this.refreshFromToSymbol(points);\r\n    };\r\n    /**\r\n     * 渲染\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.render = function() {\r\n        var that = this;\r\n        //1.创建箭头\r\n        this.renderFromToSymbol();\r\n\r\n        //2.创建线\r\n        this.curveLine = new graphic.BezierCurve({\r\n            //position: this.options.position,\r\n            style: this.options.style,\r\n            z: this.options.z\r\n        });\r\n        this.groupCurve.add(this.curveLine);\r\n        this.add(this.groupCurve);\r\n        this.add(this.conPointsGroup);\r\n\r\n        this.polyLine = new graphic.Polyline({\r\n            //position: this.options.position,\r\n            shape: this.options.shape,\r\n            style: this.options.style,\r\n            z: this.options.z\r\n        });\r\n        this.add(this.polyLine);\r\n\r\n        if ((this.options.style.lineType == Connector.TYPE_CURVE)) {\r\n            this.line = this.groupCurve;\r\n            this.createHoverStyle(this.curveLine);\r\n            this.polyLine.hide();\r\n        } else {\r\n            this.line = this.polyLine;\r\n            this.createHoverStyle(this.polyLine);\r\n            this.curveLine.hide();\r\n        }\r\n\r\n        //3.侦听线事件\r\n        var MOUSE_EVENT_NAMES = ['dblclick', 'click']; //'click', 'dblclick', 'mouseover', 'mouseout'\r\n        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n            this.line.on(eveName, zrUtil.bind(function(e) {\r\n                e.cancelBubble = true;\r\n                var params = {};\r\n                params.event = e;\r\n                params.type = \"Connector:\" + eveName;\r\n                params.target = that;\r\n                this.trigger(params.type, params);\r\n                this.setStyle({color:Connector.SELECTED_COLOR},true);\r\n                if (this.options.isEdit == false) {\r\n                    return; }\r\n\r\n                if (this.options.isEdit && this.turningPoints.length >= 2) {\r\n                    this.createAllconnectionPoint()\r\n                }\r\n                if (this.handles.length < 1) {\r\n                    this.shapeSetHandle();\r\n                }\r\n\r\n            }, this));\r\n        }, this);\r\n\r\n        //4.创建线上文本\r\n        if (this.options.text.text) {\r\n            var text = null;\r\n            if (zrUtil.isArray(this.options.text.text) && this.options.style.lineType == Connector.TYPE_CHAIN) {\r\n                this.options.text.text.forEach(function (v, i) {\r\n                    var content = that.drawText(\"lineText-\"+i, v, 0, 0);\r\n                    if (zrUtil.isString(v)) {\r\n                        var obj = {};\r\n                        obj.text = v;\r\n                        obj.textId = content.text.id;\r\n                        that.options.text.text[i] = obj;\r\n                    } else {\r\n                        that.options.text.text[i].textId = content.text.id;\r\n                    }\r\n                    that.add(content.text);\r\n                    if(content && that.opt.textContextMenu) {\r\n                        var textContextMenu = that.opt.textContextMenu;\r\n                        content.text.on(\"contextmenu\",function(e) {\r\n                            e.event.preventDefault();\r\n                            e.event.stopPropagation();\r\n                            textContextMenu.buildMenu(e.event,this);\r\n                        })\r\n                    }\r\n                });\r\n            } else {\r\n                text = this.drawText(\"lineText\", this.options.text.text, 0, 0);\r\n                this.add(text.text);\r\n            }\r\n            if(text && this.opt.textContextMenu) {\r\n                var textContextMenu = this.opt.textContextMenu;\r\n                text.text.on(\"contextmenu\",function(e) {\r\n                    e.event.preventDefault();\r\n                    e.event.stopPropagation();\r\n                    textContextMenu.buildMenu(e.event,this);\r\n                })\r\n            }\r\n        }\r\n    };\r\n\r\n    Connector.prototype.renderFromToSymbol = function(options) {\r\n        var symbolTo = this.createSymbol('toSymbol', this.options); //arrow,triangle\r\n        if (symbolTo) {\r\n            this.add(symbolTo);\r\n        }\r\n        //如果双向箭头 则再创建首箭头\r\n        if (this.options.symbol.both) {\r\n            var symbolFrom = this.createSymbol('fromSymbol', this.options); //arrow,triangle\r\n            if (symbolFrom) {\r\n                this.add(symbolFrom);\r\n            }\r\n        }\r\n    }\r\n\r\n    Connector.prototype.refreshFromToSymbol = function(points) {\r\n        var symbolTo = this.childOfName('toSymbol');\r\n        var symbolFrom = this.childOfName('fromSymbol');\r\n        var position = [], offset = this.options.symbol.offset;\r\n        if (symbolTo) {\r\n            if (this.options.effect && this.options.effect.show) {\r\n                new EffectLine(symbolTo, this.options, this.groupCurve, this.polyLine);\r\n            } else {\r\n                position = points[points.length - 1];\r\n                if (this.options.style.lineType !== Connector.TYPE_CURVE) {\r\n                    var distance = vec2.distance(points[points.length - 1], points[points.length - 2]);\r\n                    if (offset <= distance) {\r\n                        position = vec2.lerp(\r\n                            [], points[points.length - 1], points[points.length - 2],\r\n                            offset / distance);\r\n                    } else {\r\n                        position = points[points.length - 1];\r\n                    }\r\n                }\r\n                symbolTo.attr('position', position);\r\n                symbolTo.attr('rotation', Util.tangentRotation(this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]));\r\n            }\r\n        }\r\n\r\n        if (symbolFrom) {\r\n            position = points[0];\r\n            if (this.options.style.lineType !== Connector.TYPE_CURVE) {\r\n                var distanceFrom = vec2.distance(points[0], points[1]);\r\n                if (offset <= distanceFrom) {\r\n                    position = vec2.lerp(\r\n                        [], points[0], points[1],\r\n                        offset / distanceFrom);\r\n                } else {\r\n                    position = points[0];\r\n                }\r\n            }\r\n            symbolFrom.attr('position', position);\r\n            symbolFrom.attr('rotation', Util.tangentRotation(this.turningPoints[1], this.turningPoints[0]));\r\n        }\r\n    }\r\n    /**\r\n     * 设置style\r\n     * @param {object} options 样式对象\r\n     * @param {boolean} notSaveModel 设置样式是否保存到模型中,默认是false\r\n     */\r\n    Connector.prototype.setStyle = function(options,notSaveModel) {\r\n        var symbolTo = null;\r\n        if (options.color) {\r\n            if (this.options.style.lineType == Connector.TYPE_CURVE) {\r\n                this.groupCurve.eachChild(function(curve) {\r\n                    curve.attr(\"style\", { stroke: options.color });\r\n                    graphic.setNormalStyle(curve, { stroke: options.color });\r\n                });\r\n            } else {\r\n                this.polyLine.attr(\"style\", { stroke: options.color });\r\n                graphic.setNormalStyle(this.polyLine, { stroke: options.color });\r\n            }\r\n            symbolTo = this.childOfName('toSymbol');\r\n            if (symbolTo) {\r\n                symbolTo.attr(\"style\", { fill: options.color });\r\n                graphic.setNormalStyle(symbolTo, { fill: options.color });\r\n            }\r\n            if(!notSaveModel) {\r\n                this.options.style.stroke = options.color;\r\n                this.model.set(\"options.style.stroke\", options.color);\r\n                this.model.set(\"options.symbol.color\", options.color);\r\n                this.options.symbol.color = options.color;\r\n            }\r\n        }\r\n\r\n        if (options.text) {\r\n            var lineText = this.childOfName('lineText');\r\n            //开始没有创建文本，后来传进来text了，需要先创建文本\r\n            if (!lineText && options.text.text) {\r\n                var text = this.drawText(\"lineText\", options.text.text, 0, 0);\r\n                this.add(text.text);\r\n                lineText = this.childOfName('lineText');\r\n            }\r\n\r\n            if (options.text.text || options.text.text == \"\") {\r\n                lineText.setStyle(\"text\", options.text.text);\r\n                this.options.text.text = options.text.text;\r\n            }\r\n            var textPoint = this.getTextPostion(options.text);\r\n            lineText.attr(\"position\", textPoint);\r\n            if (options.text.textPos) {\r\n                this.options.text.textPos = options.text.textPos;\r\n            }\r\n            if (options.text.offset) { //#187\r\n                this.options.text.offset = options.text.offset;\r\n            }\r\n\r\n            if (options.text.color) {\r\n                lineText.attr(\"style\", {\r\n                    textFill: options.text.color\r\n                });\r\n                this.options.text.textFill = options.text.color;\r\n            }\r\n\r\n            if (options.text.textFont) {\r\n                lineText.attr(\"style\", {\r\n                    textFont:options.text.textFont\r\n                });\r\n                this.options.text.textFont = options.text.textFont;\r\n            }\r\n\r\n            if (options.text.textFill) {\r\n                lineText.attr(\"style\", {\r\n                    textFill: options.text.textFill\r\n                });\r\n                this.options.text.textFill = options.text.textFill;\r\n            }\r\n            this.model.set(\"options.text\", options.text);\r\n        }\r\n\r\n        if (options.symbol) {\r\n            if (options.symbol.type) {\r\n                this.options.symbol.type = options.symbol.type;\r\n                this.model.set(\"options.symbol.type\", options.symbol.type);\r\n            }\r\n            if (options.symbol.size) {\r\n                this.options.symbol.size = options.symbol.size;\r\n                this.model.set(\"options.symbol.size\", options.symbol.size);\r\n            }\r\n            if (options.symbol.color) {\r\n                this.options.symbol.color = options.symbol.color;\r\n                this.model.set(\"options.symbol.color\", options.symbol.color);\r\n            }\r\n            if (options.symbol.z) {\r\n                this.options.symbol.z = options.symbol.z;\r\n                this.model.set(\"options.symbol.z\", options.symbol.z);\r\n            }\r\n\r\n            symbolTo = this.childOfName('toSymbol');\r\n            if (symbolTo) {\r\n                this.remove(symbolTo);\r\n            }\r\n            var symbol = this.createSymbol(\"toSymbol\", this.model.get(\"options\"))\r\n            if (symbol) {\r\n                this.add(symbol);\r\n            }\r\n            this.refresh();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 获取线段的位置\r\n     * @param  {Object} text {text:'', color:'', textPos:''}\r\n     * @return {Object}      {x,y}\r\n     */\r\n    Connector.prototype.getTextPostion = function(text) {\r\n        var textPostion = [];\r\n        var textWidth = graphic.textContain.getWidth(text.text, text.textFont);\r\n        if (text && text.textPos) {\r\n            var offset = text.offset || 0;\r\n            var arrOffset = offset;\r\n            if (!zrUtil.isArray(offset)) {\r\n                arrOffset = [offset, 0];\r\n            }\r\n            if (text.textPos == 'start') {\r\n                textPostion = [this.turningPoints[0].x + arrOffset[0], this.turningPoints[0].y + arrOffset[1]];\r\n            } else if (text.textPos == 'end') {\r\n                var points = Util.getMaxLineLength([this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]]);\r\n                var angle = Util.getAngle(points[0], points[1]);\r\n                var length = Util.distance(points[0], points[1]) - textWidth;\r\n                var newPoint = Util.getEndPoint(points[0], length, angle);\r\n                textPostion = [newPoint.x + arrOffset[0], newPoint.y + arrOffset[1]];\r\n            } else {\r\n                var midPoint = this.middle(text);\r\n                textPostion = [midPoint[0] + arrOffset[0], midPoint[1] + arrOffset[1]];\r\n            }\r\n        } else {\r\n            var position = this.middle(text);\r\n            textPostion = [position[0] - textWidth / 2, position[1]];\r\n        }\r\n\r\n        return textPostion;\r\n    };\r\n\r\n    /**\r\n     * 获取线段的旋转角度\r\n     * @param  {Object} textPostion {x,y}\r\n     * @return {Number}             角度值\r\n     */\r\n    Connector.prototype.getTextRotation = function(textPostion) {\r\n        //计算出极坐标的角度\r\n        var points = Util.getMaxLineLength(this.turningPoints);\r\n        var angle = -Math.atan2(points[1].y - textPostion[1], points[1].x - textPostion[0]); //,Math.PI/2\r\n        return angle;\r\n    };\r\n\r\n    Connector.prototype.createHoverStyle = function(el) {\r\n        if (this.options.hoverStyle) {\r\n            graphic.setElementHoverStl(el, this.options.hoverStyle);\r\n\r\n            var symbolTo = this.childOfName('toSymbol');\r\n            if (symbolTo) { graphic.setElementHoverStl(symbolTo, this.options.arrowHoverStyle); }\r\n\r\n            el.on('mouseover', zrUtil.bind(function() {\r\n                    graphic.doEnterHover(el);\r\n                    if (symbolTo) { graphic.doEnterHover(symbolTo); }\r\n\r\n                    this.groupCurve.eachChild(function(line) {\r\n                        graphic.doEnterHover(line);\r\n                    });\r\n                }, this))\r\n                .on('mouseout', zrUtil.bind(function() {\r\n                    graphic.doLeaveHover(el);\r\n                    if (symbolTo) { graphic.doLeaveHover(symbolTo); }\r\n                    this.groupCurve.eachChild(function(line) {\r\n                        graphic.doLeaveHover(line);\r\n                    });\r\n                }, this));\r\n        }\r\n    };\r\n    /**\r\n     * 创建Node的连接点\r\n     * @private\r\n     *\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.createAllconnectionPoint = function() {\r\n        this.connectionPointCreate(this, this.turningPoints[0].clone(), ConnectionPoint.TYPE_CONNECTOR);\r\n        this.connectionPointCreate(this, this.turningPoints[this.turningPoints.length - 1].clone(), ConnectionPoint.TYPE_CONNECTOR);\r\n    };\r\n\r\n    /**\r\n     * 创建连接点\r\n     * @private\r\n     * @param  {[type]} shape [description]\r\n     * @param  {[type]} point [description]\r\n     * @param  {[type]} type  [description]\r\n     * @return {[type]}       [description]\r\n     */\r\n    Connector.prototype.connectionPointCreate = function(shape, point, type) {\r\n        var conPoint = new ConnectionPoint(this, point, type, this.options);\r\n        this.conPointsGroup.add(conPoint.shape);\r\n    };\r\n\r\n    /**\r\n     * 清空控制点\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.clearHandles = function() {\r\n        for (var i = 0; i < this.handles.length; i++) {\r\n            this.remove(this.handles[i].handleShape);\r\n        }\r\n        this.handles = [];\r\n        if (this.conPointsGroup) {\r\n            this.conPointsGroup.removeAll();\r\n        }\r\n        //恢复原来的颜色\r\n        this.setStyle({color:this.options.style.stroke},true);\r\n    };\r\n\r\n    /**\r\n     * 创建拆线 线断的控制点\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.shapeSetHandle = function() {\r\n        for (var i = 1; i < this.turningPoints.length - 2; i++) {\r\n            var h;\r\n            var x, y;\r\n            //是否在一条线上\r\n            var isCollineaityFirst = Util.collinearity(this.turningPoints[i - 1], this.turningPoints[i], this.turningPoints[i + 1]);\r\n            var isCollineaitySecond = Util.collinearity(this.turningPoints[i], this.turningPoints[i + 1], this.turningPoints[i + 2]);\r\n            if ((!isCollineaityFirst && (!isCollineaitySecond || this.turningPoints[i + 1].equals(this.turningPoints[i + 2]))) || ((!isCollineaityFirst || this.turningPoints[i - 1].equals(this.turningPoints[i])) && !isCollineaitySecond)) {\r\n\r\n                if (this.turningPoints[i].x === this.turningPoints[i + 1].x) { //same vertical\r\n                    x = this.turningPoints[i].x;\r\n                    y = (this.turningPoints[i].y + this.turningPoints[i + 1].y) / 2;\r\n\r\n                    h = new Handle('h', x, y, this);\r\n\r\n\r\n                } else if (this.turningPoints[i].y === this.turningPoints[i + 1].y) { // same horizontal\r\n                    x = (this.turningPoints[i].x + this.turningPoints[i + 1].x) / 2;\r\n                    y = this.turningPoints[i].y;\r\n                    h = new Handle('v', x, y, this);\r\n                }\r\n                if (h) {\r\n                    this.add(h.handleShape);\r\n                    this.handles.push(h);\r\n                }\r\n\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * 创建箭头\r\n     * @param  {[type]} name       [description]\r\n     * @param  {[type]} options [description]\r\n     * @return {[type]}            [description]\r\n     */\r\n    Connector.prototype.createSymbol = function(name, options) {\r\n        var symbolType = options.symbol.type;\r\n        var symbolSize = options.symbol.size;\r\n        if (symbolType === 'none') {\r\n            return;\r\n        }\r\n\r\n        if (!zrUtil.isArray(symbolSize)) {\r\n            symbolSize = [symbolSize, symbolSize];\r\n        }\r\n\r\n        var symbolZIndex = options.z;\r\n\r\n        if (options.symbol.z) { symbolZIndex = options.symbol.z }\r\n\r\n        var symbolPath = symbolUtil.createSymbol(\r\n            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,\r\n            symbolSize[0], symbolSize[1], symbolZIndex, options.symbol.color\r\n        );\r\n        symbolPath.name = name;\r\n\r\n        return symbolPath;\r\n    };\r\n\r\n    /**\r\n     * 绘制线段上的文本\r\n     * @param  {[type]} content [description]\r\n     * @param  {[type]} name [description]\r\n     * @param  {[type]} x       [description]\r\n     * @param  {[type]} y       [description]\r\n     * @param  {[type]} color   [description]\r\n     * @return {[type]}         [description]\r\n     */\r\n    Connector.prototype.drawText = function(name, content, x, y, color) {\r\n        var opt = zrUtil.isString(content) ? {text:content, x:x, y:y, fill:color}\r\n                                           : zrUtil.defaults({x:x, y:y, fill:color}, content, true);\r\n\r\n        var textStyle = zrUtil.defaults(zrUtil.clone(this.options.text), opt, true);\r\n        var text = new graphic.Text({\r\n            style: textStyle,\r\n            zlevel: 20,\r\n            name : name\r\n        });\r\n        return {\r\n            text: text,\r\n            rect: text.getBoundingRect()\r\n        };\r\n    };\r\n\r\n    /**\r\n     * 获取线段的中间值\r\n     * @return {[type]} text\r\n     */\r\n    Connector.prototype.middle = function() {\r\n\r\n        if (this.options.style.lineType == Connector.TYPE_STRAIGHT || this.options.style.lineType == Connector.TYPE_CHAIN) {\r\n            var points = Util.getMaxLineLength(this.turningPoints);\r\n            //如果是求线段上的文字的中间值\r\n            // if(text) {\r\n            //     //取出字的长度，计算角度，\r\n            //     var textWidth = graphic.textContain.getWidth(text.text, text.textFont);\r\n            //     var angle = Util.getAngle(points[0],points[1]);\r\n            //     var length =  Util.distance(points[0],points[1])/2 - textWidth/2;\r\n            //     var newPoint = Util.getEndPoint(points[0], length, angle);\r\n            //     return [newPoint.x, newPoint.y];\r\n            // } else {\r\n            //     var middleX = (points[0].x + points[1].x)/2;\r\n            //     var middleY = (points[0].y + points[1].y) /2;\r\n            //     return [middleX, middleY];\r\n            // }\r\n            var middleX = (points[0].x + points[1].x) / 2;\r\n            var middleY = (points[0].y + points[1].y) / 2;\r\n            return [middleX, middleY];\r\n        } else if (this.options.style.lineType == Connector.TYPE_JAGGED) {\r\n\r\n            //find total distance\r\n            var distance = this.getLength();\r\n\r\n            //find between what turning points the half distance is\r\n            var index = -1;\r\n            var ellapsedDistance = 0;\r\n            for (var i = 0; i < this.turningPoints.length - 1; i++) {\r\n                index = i;\r\n                var segment = Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);\r\n                if (ellapsedDistance + segment < distance / 2) {\r\n                    ellapsedDistance += segment;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            //we have the middle distance somewhere between i(ndex) and i(ndex)+1\r\n            if (index != -1) {\r\n                var missingDistance = distance / 2 - ellapsedDistance;\r\n                if (Util.round(this.turningPoints[index].x, 3) == Util.round(this.turningPoints[index + 1].x, 3)) { //vertical segment (same x)\r\n                    return [this.turningPoints[index].x, Math.min(this.turningPoints[index].y, this.turningPoints[index + 1].y) + missingDistance];\r\n                } else if (Util.round(this.turningPoints[index].y, 3) == Util.round(this.turningPoints[index + 1].y, 3)) { //horizontal segment (same y)\r\n                    return [Math.min(this.turningPoints[index].x, this.turningPoints[index + 1].x) + missingDistance, this.turningPoints[index].y];\r\n                } else {\r\n                    console.error(\"Connector:middle() - this should never happen \" + this.turningPoints[index] + \" \" + this.turningPoints[index + 1] + \" nr of points \" + this.turningPoints.length);\r\n                }\r\n\r\n            }\r\n        } else if (this.options.style.lineType == Connector.TYPE_CURVE) {\r\n            var t = 0.5;\r\n            var l = this.getLength();\r\n\r\n            var walked = 0;\r\n            for (var j = 0; j < this.turningPoints.length - 1; j++) {\r\n                if (walked + Util.distance(this.turningPoints[j], this.turningPoints[j + 1]) > l * t) {\r\n                    break;\r\n                }\r\n\r\n                walked += Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);\r\n            }\r\n\r\n            var rest = l * t - walked;\r\n            var currentSegmentLength = Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);\r\n\r\n            //find the position/ration of the middle of Polyline on current segment\r\n            var segmentPercent = rest / currentSegmentLength;\r\n\r\n            var Xp = segmentPercent * (this.turningPoints[j + 1].x - this.turningPoints[j].x) + this.turningPoints[j].x;\r\n            var Yp = segmentPercent * (this.turningPoints[j + 1].y - this.turningPoints[j].y) + this.turningPoints[j].y;\r\n\r\n            return [Xp, Yp];\r\n\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * find total distance\r\n     * @return {Number} [description]\r\n     */\r\n    Connector.prototype.getLength = function() {\r\n        //find total distance\r\n        var distance = 0;\r\n        for (var i = 0; i < this.turningPoints.length - 1; i++) {\r\n            distance += Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);\r\n        }\r\n        return distance;\r\n    };\r\n\r\n    /**\r\n     * 转JSON对象 bpmn使用\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.toJSON = function() {\r\n\r\n        this.model.set(\"resourceId\", this.resourceId);\r\n        this.model.set(\"properties.type\", 14);\r\n\r\n        this.model.set(\"bounds.upperLeft.x\", this.position[0]);\r\n        this.model.set(\"bounds.upperLeft.y\", this.position[1]);\r\n        this.model.set(\"bounds.lowerRight.x\", parseInt(this.position[0] + this.getBoundingRect().width));\r\n        this.model.set(\"bounds.lowerRight.y\", parseInt(this.position[1] + this.getBoundingRect().height));\r\n        this.model.set(\"style.sPos\", this.options.position.startPos);\r\n        this.model.set(\"style.ePos\", this.options.position.endPos);\r\n        this.model.set(\"style.lineDash\", this.options.style.lineDash);\r\n        this.model.set(\"style.stroke\", this.options.style.stroke);\r\n        this.model.set(\"symbol.type\", this.options.symbol.type);\r\n        this.model.set(\"dockers\", this.turningPoints);\r\n        return this.model.option;\r\n    };\r\n\r\n    /**\r\n     * refreshModel  flow当序列化的时候调用 更新线段的位置 及线上的icons\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.refreshModel = function() {\r\n        this.model.set(\"options\", zrUtil.clone(this.options));\r\n        this.model.set(\"options.dockers\", this.turningPoints);\r\n        var icons = [];\r\n        for (var i = 0; i < this.icons.length; i++) {\r\n            var iconNode = this.icons[i];\r\n            var option = [iconNode.key, {\r\n                icon: iconNode.style.image,\r\n                width: iconNode.style.width,\r\n                height: iconNode.style.height\r\n            }];\r\n            icons.push(option);\r\n        }\r\n        this.model.set(\"icons\", icons);\r\n    };\r\n\r\n    /**\r\n     * 调整曲线的形状\r\n     * @param  {array} points 点数组\r\n     * @return {void}\r\n     */\r\n    Connector.prototype.modifyCurve = function(points) {\r\n        var sol = this.getCurvePoint(points);\r\n\r\n        // 1. 如果曲线的数量 比数量的中数量要少 则删除多余的线段\r\n        var willDelCurves = [];\r\n        for (var j = sol.length, cntCurve = this.groupCurve.childCount(); j < cntCurve; j++) {\r\n            willDelCurves.push(this.groupCurve.childAt(j));\r\n        }\r\n        zrUtil.each(willDelCurves, function(curve) {\r\n            this.groupCurve.remove(curve);\r\n        }, this);\r\n        // 2. 遍历曲线   如果存在则直接设置形状，否则创建\r\n        for (var i = 0; i < sol.length; i++) {\r\n            var line = this.groupCurve.childAt(i);\r\n            if (line) {\r\n                line.attr('shape', sol[i]);\r\n            } else {\r\n                var cure = new graphic.BezierCurve({\r\n                   // position: this.options.position,\r\n                    style: this.options.style,\r\n                    shape: sol[i],\r\n                    z: this.options.z\r\n                });\r\n                this.groupCurve.add(cure);\r\n                this.createHoverStyle(cure);\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * 根据传入的点数组计算曲线的点\r\n     * @param  {array} P 点数组\r\n     * @return {object}        曲线的点数组\r\n     */\r\n    Connector.prototype.getCurvePoint = function(P) {\r\n        var n = P.length;\r\n        var sol = [];\r\n        if (n === 3) {\r\n            sol.push({\r\n                x1: P[0].x,\r\n                y1: P[0].y,\r\n                cpx1: P[1].x,\r\n                cpy1: P[1].y,\r\n                x2: P[2].x,\r\n                y2: P[2].y\r\n            });\r\n            return sol;\r\n        } else if (n === 4) {\r\n            sol.push({\r\n                x1: P[0].x,\r\n                y1: P[0].y,\r\n                cpx1: P[1].x,\r\n                cpy1: P[1].y,\r\n                cpx2: P[2].x,\r\n                cpy2: P[2].y,\r\n                x2: P[3].x,\r\n                y2: P[3].y\r\n            });\r\n            return sol;\r\n        }\r\n\r\n\r\n        /**Computes the sum between two point\r\n         *@param p1 - {Point}\r\n         *@param p2 - {Point}\r\n         *@return {Point} the sum of initial points\r\n         **/\r\n        function sum(p1, p2) {\r\n            return new Point(p1.x + p2.x, p1.y + p2.y);\r\n        }\r\n\r\n\r\n        /**Computes the division of a {Point} by a number\r\n         *@param p - {Point}\r\n         *@param nr - {Number}\r\n         *@return {Point}\r\n         **/\r\n        function divide(p, nr) {\r\n            if (nr == 0) {\r\n                throw \"Division by zero not allowed (yet :) \" + this.callee;\r\n            }\r\n            return new Point(p.x / nr, p.y / nr);\r\n        }\r\n\r\n        /**Computes the multiplication of a {Point} by a number\r\n         *@param p - {Point}\r\n         *@param nr - {Number}\r\n         *@return {Point}\r\n         **/\r\n        function multiply(p, nr) {\r\n            return new Point(p.x * nr, p.y * nr);\r\n        }\r\n\r\n\r\n\r\n\r\n        /*\r\n         *I do not get why first 4 must be 0 and last 3 of same value.....\r\n         *but otherwise we will get division by zero\r\n         */\r\n        var k = [0, 0, 0];\r\n\r\n        var j;\r\n        for (j = 0; j <= n - 3; j++) {\r\n            k.push(j);\r\n        }\r\n\r\n        k.push(n - 3, n - 3);\r\n\r\n\r\n\r\n        for (var i = 1; i <= n - 3; i++) {\r\n            //q1 - compute start point\r\n            var q1 = divide(sum(multiply(P[i], k[i + 4] - k[i + 2]), multiply(P[i + 1], k[i + 2] - k[i + 1])), k[i + 4] - k[i + 1]);\r\n\r\n            //q0 - compute 1st controll point\r\n            var q_01 = (k[i + 3] - k[i + 2]) / (k[i + 3] - k[i + 1]);\r\n            var q_02 = divide(sum(multiply(P[i - 1], k[i + 3] - k[i + 2]), multiply(P[i], k[i + 2] - k[i])), k[i + 3] - k[i]);\r\n            var q_03 = multiply(q1, (k[i + 2] - k[i + 1]) / (k[i + 3] - k[i + 1]));\r\n            var q0 = sum(multiply(q_02, q_01), q_03);\r\n\r\n            //q2 - compute 2nd controll point\r\n            var q2 = divide(sum(multiply(P[i], k[i + 4] - k[i + 3]), multiply(P[i + 1], k[i + 3] - k[i + 1])), k[i + 4] - k[i + 1]);\r\n\r\n            //q3 - compute end point\r\n            var q_31 = (k[i + 3] - k[i + 2]) / (k[i + 4] - k[i + 2]);\r\n            var q_32 = divide(sum(multiply(P[i + 1], k[i + 5] - k[i + 3]), multiply(P[i + 2], k[i + 3] - k[i + 2])), k[i + 5] - k[i + 2]);\r\n            var q_33 = multiply(q2, (k[i + 4] - k[i + 3]) / (k[i + 4] - k[i + 2]));\r\n            var q3 = sum(multiply(q_32, q_31), q_33);\r\n\r\n            //store solution\r\n            //\r\n            sol.push({\r\n                x1: q0.x,\r\n                y1: q0.y,\r\n                cpx1: q1.x,\r\n                cpy1: q1.y,\r\n                cpx2: q2.x,\r\n                cpy2: q2.y,\r\n                x2: q3.x,\r\n                y2: q3.y\r\n            });\r\n        }\r\n\r\n        return sol;\r\n    };\r\n\r\n\r\n    Util.inherits(Connector, Node);\r\n\r\n    module.exports = Connector;\r\n\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/shapes/Connector.js\n// module id = 82\n// module chunks = 0","'use strict';\n// Symbol factory\r\n\r\n\r\n    var graphic = require('../graphic');\r\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\r\n    /**\r\n     * Triangle shape\r\n     * @inner\r\n     */\r\n    var Triangle = graphic.extendShape({\r\n        type: 'triangle',\r\n        shape: {\r\n            cx: 0,\r\n            cy: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n        buildPath: function (path, shape) {\r\n            var cx = shape.cx;\r\n            var cy = shape.cy;\r\n            var width = shape.width / 2;\r\n            var height = shape.height / 2;\r\n            path.moveTo(cx, cy - height);\r\n            path.lineTo(cx + width, cy + height);\r\n            path.lineTo(cx - width, cy + height);\r\n            path.closePath();\r\n        }\r\n    });\r\n    /**\r\n     * Diamond shape\r\n     * @inner\r\n     */\r\n    var Diamond = graphic.extendShape({\r\n        type: 'diamond',\r\n        shape: {\r\n            cx: 0,\r\n            cy: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n        buildPath: function (path, shape) {\r\n            var cx = shape.cx;\r\n            var cy = shape.cy;\r\n            var width = shape.width / 2;\r\n            var height = shape.height / 2;\r\n            path.moveTo(cx, cy - height);\r\n            path.lineTo(cx + width, cy);\r\n            path.lineTo(cx, cy + height);\r\n            path.lineTo(cx - width, cy);\r\n            path.closePath();\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Pin shape\r\n     * @inner\r\n     */\r\n    var Pin = graphic.extendShape({\r\n        type: 'pin',\r\n        shape: {\r\n            // x, y on the cusp\r\n            x: 0,\r\n            y: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n\r\n        buildPath: function (path, shape) {\r\n            var x = shape.x;\r\n            var y = shape.y;\r\n            var w = shape.width / 5 * 3;\r\n            // Height must be larger than width\r\n            var h = Math.max(w, shape.height);\r\n            var r = w / 2;\r\n\r\n            // Dist on y with tangent point and circle center\r\n            var dy = r * r / (h - r);\r\n            var cy = y - h + r + dy;\r\n            var angle = Math.asin(dy / r);\r\n            // Dist on x with tangent point and circle center\r\n            var dx = Math.cos(angle) * r;\r\n\r\n            var tanX = Math.sin(angle);\r\n            var tanY = Math.cos(angle);\r\n\r\n            path.arc(\r\n                x, cy, r,\r\n                Math.PI - angle,\r\n                Math.PI * 2 + angle\r\n            );\r\n\r\n            var cpLen = r * 0.6;\r\n            var cpLen2 = r * 0.7;\r\n            path.bezierCurveTo(\r\n                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\r\n                x, y - cpLen2,\r\n                x, y\r\n            );\r\n            path.bezierCurveTo(\r\n                x, y - cpLen2,\r\n                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\r\n                x - dx, cy + dy\r\n            );\r\n            path.closePath();\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Arrow shape\r\n     * @inner\r\n     */\r\n    var Arrow = graphic.extendShape({\r\n\r\n        type: 'arrow',\r\n\r\n        shape: {\r\n            x: 0,\r\n            y: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var height = shape.height;\r\n            var width = shape.width;\r\n            var x = shape.x;\r\n            var y = shape.y;\r\n            var dx = width / 3 * 2;\r\n            ctx.moveTo(x, y);\r\n            ctx.lineTo(x + dx, y + height);\r\n            ctx.lineTo(x, y + height / 4 * 3);\r\n            ctx.lineTo(x - dx, y + height);\r\n            ctx.lineTo(x, y);\r\n            ctx.closePath();\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Map of path contructors\r\n     * @type {Object.<string, module:zrender/graphic/Path>}\r\n     */\r\n    var symbolCtors = {\r\n        line: graphic.Line,\r\n\r\n        rect: graphic.Rect,\r\n\r\n        roundRect: graphic.Rect,\r\n\r\n        square: graphic.Rect,\r\n\r\n        circle: graphic.Circle,\r\n\r\n        diamond: Diamond,\r\n\r\n        pin: Pin,\r\n\r\n        arrow: Arrow,\r\n\r\n        triangle: Triangle\r\n    };\r\n\r\n    var symbolShapeMakers = {\r\n\r\n        line: function (x, y, w, h, shape) {\r\n            // FIXME\r\n            shape.x1 = x;\r\n            shape.y1 = y + h / 2;\r\n            shape.x2 = x + w;\r\n            shape.y2 = y + h / 2;\r\n        },\r\n\r\n        rect: function (x, y, w, h, shape) {\r\n            shape.x = x;\r\n            shape.y = y;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        },\r\n\r\n        roundRect: function (x, y, w, h, shape) {\r\n            shape.x = x;\r\n            shape.y = y;\r\n            shape.width = w;\r\n            shape.height = h;\r\n            shape.r = Math.min(w, h) / 4;\r\n        },\r\n\r\n        square: function (x, y, w, h, shape) {\r\n            var size = Math.min(w, h);\r\n            shape.x = x;\r\n            shape.y = y;\r\n            shape.width = size;\r\n            shape.height = size;\r\n        },\r\n\r\n        circle: function (x, y, w, h, shape) {\r\n            // Put circle in the center of square\r\n            shape.cx = x + w / 2;\r\n            shape.cy = y + h / 2;\r\n            shape.r = Math.min(w, h) / 2;\r\n        },\r\n\r\n        diamond: function (x, y, w, h, shape) {\r\n            shape.cx = x + w / 2;\r\n            shape.cy = y + h / 2;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        },\r\n\r\n        pin: function (x, y, w, h, shape) {\r\n            shape.x = x + w / 2;\r\n            shape.y = y + h / 2;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        },\r\n\r\n        arrow: function (x, y, w, h, shape) {\r\n            shape.x = x + w / 2;\r\n            shape.y = y + h / 2;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        },\r\n\r\n        triangle: function (x, y, w, h, shape) {\r\n            shape.cx = x + w / 2;\r\n            shape.cy = y + h / 2;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        }\r\n    };\r\n\r\n    var symbolBuildProxies = {};\r\n    for (var name in symbolCtors) {\r\n        symbolBuildProxies[name] = new symbolCtors[name]();\r\n    }\r\n\r\n    var Symbol = graphic.extendShape({\r\n\r\n        type: 'symbol',\r\n\r\n        shape: {\r\n            symbolType: '',\r\n            x: 0,\r\n            y: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n\r\n        beforeBrush: function () {\r\n            var style = this.style;\r\n            var shape = this.shape;\r\n            // FIXME\r\n            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\r\n                style.textPosition = ['50%', '40%'];\r\n                style.textAlign = 'center';\r\n                style.textVerticalAlign = 'middle';\r\n            }\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var symbolType = shape.symbolType;\r\n            var proxySymbol = symbolBuildProxies[symbolType];\r\n            if (shape.symbolType !== 'none') {\r\n                if (!proxySymbol) {\r\n                    // Default rect\r\n                    symbolType = 'rect';\r\n                    proxySymbol = symbolBuildProxies[symbolType];\r\n                }\r\n                symbolShapeMakers[symbolType](\r\n                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\r\n                );\r\n                proxySymbol.buildPath(ctx, proxySymbol.shape);\r\n            }\r\n        }\r\n    });\r\n\r\n    // Provide setColor helper method to avoid determine if set the fill or stroke outside\r\n    var symbolPathSetColor = function (color) {\r\n        if (this.type !== 'image') {\r\n            var symbolStyle = this.style;\r\n            var symbolShape = this.shape;\r\n            if (symbolShape && symbolShape.symbolType === 'line') {\r\n                symbolStyle.stroke = color;\r\n            }\r\n            else if (this.__isEmptyBrush) {\r\n                symbolStyle.stroke = color;\r\n                symbolStyle.fill = '#fff';\r\n            }\r\n            else {\r\n                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?\r\n                symbolStyle.fill && (symbolStyle.fill = color);\r\n                symbolStyle.stroke && (symbolStyle.stroke = color);\r\n            }\r\n            this.dirty();\r\n        }\r\n    };\r\n\r\n    var symbolUtil = {\r\n        /**\r\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\r\n         * @param {string} symbolType\r\n         * @param {number} x\r\n         * @param {number} y\r\n         * @param {number} w\r\n         * @param {number} h\r\n         * @param {number} z\r\n         * @param {string} color\r\n         */\r\n        createSymbol: function (symbolType, x, y, w, h, z, color) {\r\n            var isEmpty = symbolType.indexOf('empty') === 0;\r\n            if (isEmpty) {\r\n                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\r\n            }\r\n            var symbolPath;\r\n\r\n            if (symbolType.indexOf('image://') === 0) {\r\n                symbolPath = new graphic.Image({\r\n                    style: {\r\n                        image: symbolType.slice(8),\r\n                        x: x,\r\n                        y: y,\r\n                        width: w,\r\n                        height: h\r\n                    },\r\n                    z: z\r\n                });\r\n            }\r\n            else if (symbolType.indexOf('path://') === 0) {\r\n                symbolPath = graphic.makePath(symbolType.slice(7), {z: z, rectHover: true}, new BoundingRect(x, y, w, h));\r\n            }\r\n            else {\r\n                symbolPath = new Symbol({\r\n                    shape: {\r\n                        symbolType: symbolType,\r\n                        x: x,\r\n                        y: y,\r\n                        width: w,\r\n                        height: h\r\n                    },\r\n                    z: z\r\n                });\r\n            }\r\n\r\n            symbolPath.__isEmptyBrush = isEmpty;\r\n\r\n            symbolPath.setColor = symbolPathSetColor;\r\n\r\n            symbolPath.setColor(color);\r\n\r\n            return symbolPath;\r\n        }\r\n    };\r\n\r\n    module.exports = symbolUtil;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/shapes/Symbol.js\n// module id = 83\n// module chunks = 0","/**\r\n * 画句柄\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var graphic = require(\"../graphic.js\");\r\n    var Util = require(\"../util.js\");\r\n    function Handle(type, x, y, connector){\r\n        this.type = type;\r\n\r\n        this.x = x;\r\n\r\n        this.y = y;\r\n\r\n        this.visible = true;\r\n\r\n        this.connector = connector;\r\n\r\n        this.handleShape = new graphic.Circle({\r\n            shape: {\r\n                cx: x,\r\n                cy: y,\r\n                r: Handle.RADIUS\r\n            },\r\n\r\n            style: {\r\n                fill: \"rgb(0,255,0)\",\r\n                stroke:\"rgb(0,0,0)\"\r\n            },\r\n            z : connector.options.z + 2,  //节点Z为1 线段为0;\r\n            draggable:true\r\n        });\r\n\r\n        var that = this;\r\n        this.handleShape.on(\"drag\", function(e) {\r\n            that.actionConnector(e.offsetX,e.offsetY);\r\n        });\r\n       // return this.circle;\r\n    }\r\n\r\n    Handle.RADIUS = 4;\r\n\r\n    Handle.prototype = {\r\n\r\n        constructor : Handle,\r\n\r\n        equals : function(anotherHandle){\r\n            if(!anotherHandle instanceof Handle){\r\n                return false;\r\n            }\r\n\r\n            return this.type == anotherHandle.type\r\n            && this.x == anotherHandle.x\r\n            && this.y == anotherHandle.y\r\n            && this.visible == anotherHandle.visible;\r\n        },\r\n\r\n        /**\r\n         * 移动句柄\r\n         * @param  {[type]} newX [description]\r\n         * @param  {[type]} newY [description]\r\n         * @return {[type]}      [description]\r\n         */\r\n        actionConnector: function(newX, newY){\r\n            switch(this.type){\r\n                case 'v':\r\n                    var index;\r\n                    // 找出两个转折点（可移动句柄在这两个转折点中间）\r\n                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){\r\n                        if(this.connector.turningPoints[i-1].y == this.connector.turningPoints[i].y\r\n                            && this.connector.turningPoints[i].y == this.y\r\n                            && Math.min(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) <= this.x\r\n                            && Math.max(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) >= this.x)\r\n                        {\r\n                            index = i;\r\n                        }\r\n                    }\r\n                    var deltaY = newY - this.y;\r\n                    var translationMatrix = Util.translationMatrix(0, deltaY);\r\n\r\n                    this.connector.turningPoints[index-1].transform(translationMatrix);\r\n                    this.connector.turningPoints[index].transform(translationMatrix);\r\n                    this.connector.refresh();\r\n                    this.y = newY;  //将句柄新的位置赋值给y\r\n\r\n                    break;\r\n\r\n                case 'h':\r\n                    var index;\r\n                    // 找出两个转折点（可移动句柄在这两个转折点中间）\r\n                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){\r\n                        if(this.connector.turningPoints[i-1].x == this.connector.turningPoints[i].x\r\n                            && this.connector.turningPoints[i].x == this.x\r\n                            && Math.min(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) <= this.y\r\n                            && Math.max(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) >= this.y)\r\n                            {\r\n                            index = i;\r\n                        }\r\n                    }\r\n                    var deltaX = newX-this.x;\r\n                    var translationMatrix = Util.translationMatrix(deltaX, 0);\r\n                    this.connector.turningPoints[index-1].transform(translationMatrix);\r\n                    this.connector.turningPoints[index].transform(translationMatrix);\r\n                    this.connector.refresh();\r\n                    this.x = newX; //将句柄新的位置赋值给x\r\n\r\n                    break;\r\n            }\r\n           //. this.shape.updateMiddleText();\r\n        }\r\n    };\r\n    module.exports = Handle;\r\n\r\n\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/shapes/Handle.js\n// module id = 84\n// module chunks = 0","/**\r\n * 连线动态效果\r\n * @author miao.cunzhi\r\n */\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var vec2 = require('zrender/lib/core/vector');\r\n    var curveUtil = require('zrender/lib/core/curve');\r\n    var symbolUtil = require('./Symbol.js');\r\n\r\n    function EffectLine(symbol, options, groupCurve, polyLine) {\r\n        this._lastFrame = 0;\r\n        this._lastFramePercent = 0;\r\n        this.symbol = symbol;\r\n        this.groupCurve = groupCurve;\r\n        this.initSymbol(options, polyLine);\r\n    }\r\n    var EffectLineProto = EffectLine.prototype;\r\n\r\n    EffectLineProto.initSymbol = function(options, polyLine) {\r\n        var that = this;\r\n        this.symbol.z2 = 100;\r\n        this.symbol.culling = true;\r\n        var period = options.effect.period * 1000;\r\n        this.symbol.__t = 0;\r\n        this.symbol.stopAnimation();\r\n        if ((options.style.lineType == \"curve\")) {\r\n            if (this.groupCurve) {\r\n                var i = 0;\r\n                period = period / this.groupCurve._children.length;\r\n                this.groupCurveAnimate(this.groupCurve._children[0], i, period);\r\n            }\r\n\r\n        } else {\r\n            this.symbol.animate('', true)\r\n                .when(period, {\r\n                    __t: 1\r\n                })\r\n                .delay(0)\r\n                .during(function() {\r\n                    that.updateSymbolPositionPolyline();\r\n                })\r\n                .start();\r\n            this.setAnimationPointsPolyline(polyLine.shape.points);\r\n        }\r\n\r\n    };\r\n\r\n    EffectLineProto.groupCurveAnimate = function(curveLine, i, period) {\r\n        var that = this;\r\n        if (curveLine == undefined) {\r\n            curveLine = this.groupCurve._children[0];\r\n            i = 0;\r\n        }\r\n        var points;\r\n        var pos = curveLine.shape;\r\n        points = [\r\n            [pos.x1, pos.y1],\r\n            [pos.x2, pos.y2],\r\n            [pos.cpx1, pos.cpy1],\r\n            [pos.cpx2, pos.cpy2]\r\n        ];\r\n        this.setAnimationPointsBezierCurve(points);\r\n        this.symbol.animate('')\r\n            .when(period, {\r\n                __t: 1\r\n            })\r\n            .delay(0)\r\n            .during(function() {\r\n                that.updateSymbolPositionBezierCurve();\r\n            })\r\n            .done(function() {\r\n                that.symbol.__t = 0;\r\n                that.groupCurveAnimate(that.groupCurve._children[i + 1], i + 1, period);\r\n            })\r\n            .start();\r\n\r\n    };\r\n\r\n\r\n    EffectLineProto.setAnimationPointsBezierCurve = function(points) {\r\n        this.symbol.__p1 = points[0];\r\n        this.symbol.__p2 = points[1];\r\n        this.symbol.__cp1 = points[2] || [\r\n            (points[0][0] + points[1][0]) / 2,\r\n            (points[0][1] + points[1][1]) / 2\r\n        ];\r\n        this.symbol.__cp2 = points[3];\r\n    };\r\n\r\n    EffectLineProto.updateSymbolPositionBezierCurve = function() {\r\n        var p1 = this.symbol.__p1;\r\n        var p2 = this.symbol.__p2;\r\n        var cp1 = this.symbol.__cp1;\r\n        var cp2 = this.symbol.__cp2;\r\n        var t = this.symbol.__t;\r\n        var pos = this.symbol.position;\r\n        var tx, ty;\r\n        if (cp2[0] != undefined) {\r\n            var cubicAt = curveUtil.cubicAt;\r\n            var cubicDerivativeAt = curveUtil.cubicDerivativeAt;\r\n            pos[0] = cubicAt(p1[0], cp1[0], cp2[0], p2[0], t);\r\n            pos[1] = cubicAt(p1[1], cp1[1], cp2[1], p2[1], t);\r\n            // Tangent\r\n            tx = cubicDerivativeAt(p1[0], cp1[0], cp2[0], p2[0], t);\r\n            ty = cubicDerivativeAt(p1[1], cp1[1], cp2[1], p2[1], t);\r\n        } else {\r\n            var quadraticAt = curveUtil.quadraticAt;\r\n            var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;\r\n            pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);\r\n            pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);\r\n            // Tangent\r\n            tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);\r\n            ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);\r\n        }\r\n        this.symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;\r\n\r\n        this.symbol.ignore = false;\r\n    };\r\n\r\n    EffectLineProto.setAnimationPointsPolyline = function(points) {\r\n        this._points = points;\r\n        var accLenArr = [0];\r\n        var len = 0;\r\n        for (var i = 1; i < points.length; i++) {\r\n            var p1 = points[i - 1];\r\n            var p2 = points[i];\r\n            len += vec2.dist(p1, p2);\r\n            accLenArr.push(len);\r\n        }\r\n        if (len === 0) {\r\n            return;\r\n        }\r\n\r\n        for (var j = 0; j < accLenArr.length; j++) {\r\n            accLenArr[j] /= len;\r\n        }\r\n        this._offsets = accLenArr;\r\n        this._length = len;\r\n        this.symbol._lastFrame = 0;\r\n        this.symbol.__lastFramePercent = 0;\r\n    };\r\n\r\n    EffectLineProto.updateSymbolPositionPolyline = function() {\r\n        var t = this.symbol.__t;\r\n        var points = this._points;\r\n        var offsets = this._offsets;\r\n        var len = points.length;\r\n\r\n        if (!offsets) {\r\n            // Has length 0\r\n            return;\r\n        }\r\n\r\n        var lastFrame = this._lastFrame;\r\n        var frame;\r\n\r\n        if (t < this._lastFramePercent) {\r\n            // Start from the next frame\r\n            // PENDING start from lastFrame ?\r\n            var start = Math.min(lastFrame + 1, len - 1);\r\n            for (frame = start; frame >= 0; frame--) {\r\n                if (offsets[frame] <= t) {\r\n                    break;\r\n                }\r\n            }\r\n            // PENDING really need to do this ?\r\n            frame = Math.min(frame, len - 2);\r\n        } else {\r\n            for (var frame = lastFrame; frame < len; frame++) {\r\n                if (offsets[frame] > t) {\r\n                    break;\r\n                }\r\n            }\r\n            frame = Math.min(frame - 1, len - 2);\r\n        }\r\n        vec2.lerp(\r\n            this.symbol.position, points[frame], points[frame + 1],\r\n            (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame])\r\n        );\r\n\r\n        this._lastFrame = frame;\r\n        this._lastFramePercent = t;\r\n        var angle = -Math.atan2(points[frame + 1][1] - points[frame][1], points[frame + 1][0] - points[frame][0]);\r\n        this.symbol.rotation = angle - Math.PI / 2;\r\n        this.symbol.ignore = false;\r\n    };\r\n    module.exports = EffectLine;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/shapes/EffectLine.js\n// module id = 85\n// module chunks = 0","/**\r\n * 控制点\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var graphic = require(\"../graphic.js\");\r\n    function ConnectionPoint(connector, point, type, options){\r\n        this.connector = connector;\r\n\r\n        this.point = point.clone();\r\n\r\n        this.type = type;\r\n\r\n        this.color = ConnectionPoint.NORMAL_COLOR;\r\n\r\n        this.oType = 'ConnectionPoint';\r\n\r\n        this.shape = new graphic.Circle({\r\n            shape: {\r\n                cx: this.point.x,\r\n                cy: this.point.y,\r\n                r: ConnectionPoint.RADIUS\r\n            },\r\n\r\n            style: {\r\n                fill: this.color,\r\n                stroke:'#000000'\r\n            },\r\n            z : options.z + 2  //节点Z为1 线段为0;\r\n        });\r\n        this.shape.type =  this.type;\r\n\r\n        this.shape.connector = connector;\r\n        //return this.circle;\r\n    }\r\n\r\n    ConnectionPoint.NORMAL_COLOR = \"#FFFF33\"; //yellow.\r\n\r\n    ConnectionPoint.OVER_COLOR = \"#FF9900\"; //orange\r\n\r\n    ConnectionPoint.CONNECTED_COLOR = \"#ff0000\"; //red\r\n\r\n    ConnectionPoint.RADIUS = 4;\r\n\r\n    ConnectionPoint.TYPE_FIGURE = 'figure';\r\n\r\n    ConnectionPoint.TYPE_CONNECTOR = 'connector';\r\n\r\n    ConnectionPoint.prototype = {\r\n\r\n        constructor : ConnectionPoint,\r\n\r\n        equals : function(anotherConnectionPoint){\r\n            return this.point.equals(anotherConnectionPoint.point)\r\n            && this.connector == anotherConnectionPoint.connector\r\n            && this.type == anotherConnectionPoint.type\r\n            && this.color == anotherConnectionPoint.color\r\n            && this.radius == anotherConnectionPoint.radius;\r\n        }\r\n\r\n\r\n    };\r\n    module.exports = ConnectionPoint;\r\n\r\n\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/shapes/ConnectionPoint.js\n// module id = 86\n// module chunks = 0","/**\r\n * 节点等的模型\r\n * 里面存的数据用来处理序列化和反序列化\r\n * @class fish.topo.model\r\n */\r\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var clazzUtil = require('./clazz');\r\n\r\n    function Model(option, parentModel,  extraOpt) {\r\n        this.parentModel = parentModel;\r\n        this.option = option;\r\n\r\n        // Simple optimization\r\n        if (this.init) {\r\n            if (arguments.length <= 3) {\r\n                this.init(option, parentModel,  extraOpt);\r\n            }\r\n            else {\r\n                this.init.apply(this, arguments);\r\n            }\r\n        }\r\n    }\r\n\r\n    Model.prototype = {\r\n\r\n        constructor: Model,\r\n\r\n        /**\r\n         * Model 的初始化函数\r\n         * @private\r\n         * @param {Object} option\r\n         */\r\n        init: function (option) {\r\n            zrUtil.merge(option, this.getDefaultOption());\r\n        },\r\n\r\n        getDefaultOption: function () {\r\n            if (!this.hasOwnProperty('__defaultOption')) {\r\n                var optList = [];\r\n                var Class = this.constructor;\r\n                while (Class) {\r\n                    var opt = Class.prototype.defaultOption;\r\n                    opt && optList.push(opt);\r\n                    Class = Class.superClass;\r\n                }\r\n\r\n                var defaultOption = {};\r\n                for (var i = optList.length - 1; i >= 0; i--) {\r\n                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\r\n                }\r\n                this.__defaultOption = defaultOption;\r\n            }\r\n            return this.__defaultOption;\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        mergeOption: function (option) {\r\n            zrUtil.merge(this.option, option, true);\r\n        },\r\n\r\n        /**\r\n         * 获取model的某个属性的值\r\n         * @param {string} path model中的属性\r\n         * @return {String}\r\n         *\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *          node.model.get(\"options.text\");\r\n         */\r\n        get: function (path, ignoreParent) {\r\n            if (!path) {\r\n                return this.option;\r\n            }\r\n\r\n            if (typeof path === 'string') {\r\n                path = path.split('.');\r\n            }\r\n\r\n            var obj = this.option;\r\n            var parentModel = this.parentModel;\r\n            for (var i = 0; i < path.length; i++) {\r\n                // obj could be number/string/... (like 0)\r\n                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;\r\n                if (obj == null) {\r\n                    break;\r\n                }\r\n            }\r\n            if (obj == null && parentModel && !ignoreParent) {\r\n                obj = parentModel.get(path);\r\n            }\r\n            return obj;\r\n        },\r\n\r\n        /**\r\n         * 设置model的某个属性的值\r\n         * @param {string} path model中的属性\r\n         * @param {String} value 所需要设置的值\r\n         * @return {String}\r\n         *\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *          node.model.set(\"options.text\",\"例子\");\r\n         */\r\n        set: function (path, value) {\r\n            var obj = this.option;\r\n\r\n            if (path.indexOf(\".\") == -1) {\r\n                obj[path] = value;\r\n            } else {\r\n                var fieldArray  = path.split('.');\r\n                var n = fieldArray.length;\r\n                var currentRef = obj;\r\n                var fieldName;\r\n\r\n                for (var i = 0; i < n - 1; i++) {\r\n                    fieldName = fieldArray[i];\r\n                    if(currentRef[fieldName] == null) {\r\n                        currentRef[fieldName] = {};\r\n                    }\r\n                    currentRef = currentRef[fieldName];\r\n                }\r\n                fieldName = fieldArray[n-1];\r\n                currentRef[fieldName] = value;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        getShallow: function (key, ignoreParent) {\r\n            var option = this.option;\r\n            var val = option && option[key];\r\n            var parentModel = this.parentModel;\r\n            if (val == null && parentModel && !ignoreParent) {\r\n                val = parentModel.getShallow(key);\r\n            }\r\n            return val;\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        getModel: function (path, parentModel) {\r\n            var obj = this.get(path, true);\r\n            var thisParentModel = this.parentModel;\r\n            var model = new Model(\r\n                obj, parentModel || (thisParentModel && thisParentModel.getModel(path))\r\n            );\r\n            return model;\r\n        },\r\n\r\n        /**\r\n         *清空model的option\r\n         * @private\r\n         */\r\n        isEmpty: function () {\r\n            return this.option == null;\r\n        },\r\n\r\n        restoreData: function () {},\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        clone: function () {\r\n            var Ctor = this.constructor;\r\n            return new Ctor(zrUtil.clone(this.option));\r\n        }\r\n    };\r\n\r\n    // Enable Model.extend.\r\n    clazzUtil.enableClassExtend(Model);\r\n\r\n    module.exports = Model;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/model.js\n// module id = 87\n// module chunks = 0","\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    var clazz = {};\r\n\r\n    var TYPE_DELIMITER = '.';\r\n    var IS_CONTAINER = '___FT__COMPONENT__CONTAINER___';\r\n    /**\r\n     * @public\r\n     */\r\n    var parseClassType = clazz.parseClassType = function (componentType) {\r\n        var ret = {main: '', sub: ''};\r\n        if (componentType) {\r\n            componentType = componentType.split(TYPE_DELIMITER);\r\n            ret.main = componentType[0] || '';\r\n            ret.sub = componentType[1] || '';\r\n        }\r\n        return ret;\r\n    };\r\n    /**\r\n     * @public  相比 直接用zrUtil.inherits 好处是  可以直接调用父类的构造函数\r\n     */\r\n    clazz.enableClassExtend = function (RootClass, preConstruct) {\r\n        RootClass.extend = function (proto) {\r\n            var ExtendedClass = function () {\r\n                preConstruct && preConstruct.apply(this, arguments);\r\n                RootClass.apply(this, arguments);\r\n            };\r\n\r\n            zrUtil.extend(ExtendedClass.prototype, proto);\r\n\r\n            ExtendedClass.extend = this.extend;\r\n            ExtendedClass.superCall = superCall;\r\n            ExtendedClass.superApply = superApply;\r\n            zrUtil.inherits(ExtendedClass, this);\r\n            ExtendedClass.superClass = this;\r\n\r\n            return ExtendedClass;\r\n        };\r\n    };\r\n\r\n    // superCall should have class info, which can not be fetch from 'this'.\r\n    // Consider this case:\r\n    // class A has method f,\r\n    // class B inherits class A, overrides method f, f call superApply('f'),\r\n    // class C inherits class B, do not overrides method f,\r\n    // then when method of class C is called, dead loop occured.\r\n    function superCall(context, methodName) {\r\n        var args = zrUtil.slice(arguments, 2);\r\n        return this.superClass.prototype[methodName].apply(context, args);\r\n    }\r\n\r\n    function superApply(context, methodName, args) {\r\n        return this.superClass.prototype[methodName].apply(context, args);\r\n    }\r\n\r\n    /**\r\n     * @param {Object} entity\r\n     * @param {Object} options\r\n     * @param {boolean} [options.registerWhenExtend]\r\n     * @public\r\n     */\r\n    clazz.enableClassManagement = function (entity, options) {\r\n        options = options || {};\r\n\r\n        /**\r\n         * Component model classes\r\n         * key: componentType,\r\n         * value:\r\n         *     componentClass, when componentType is 'xxx'\r\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\r\n         * @type {Object}\r\n         */\r\n        var storage = {};\r\n\r\n        entity.registerClass = function (Clazz, componentType) {\r\n            if (componentType) {\r\n                componentType = parseClassType(componentType);\r\n\r\n                if (!componentType.sub) {\r\n                    if (storage[componentType.main]) {\r\n                        //已经注册过了，直接返回\r\n                        return;\r\n                    }\r\n                    storage[componentType.main] = Clazz;\r\n                }\r\n                else if (componentType.sub !== IS_CONTAINER) {\r\n                    var container = makeContainer(componentType);\r\n                    container[componentType.sub] = Clazz;\r\n                }\r\n            }\r\n            return Clazz;\r\n        };\r\n\r\n        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\r\n            var Clazz = storage[componentTypeMain];\r\n\r\n            if (Clazz && Clazz[IS_CONTAINER]) {\r\n                Clazz = subType ? Clazz[subType] : null;\r\n            }\r\n\r\n            if (throwWhenNotFound && !Clazz) {\r\n                throw new Error(\r\n                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'\r\n                );\r\n            }\r\n\r\n            return Clazz;\r\n        };\r\n\r\n        entity.getClassesByMainType = function (componentType) {\r\n            componentType = parseClassType(componentType);\r\n\r\n            var result = [];\r\n            var obj = storage[componentType.main];\r\n\r\n            if (obj && obj[IS_CONTAINER]) {\r\n                zrUtil.each(obj, function (o, type) {\r\n                    type !== IS_CONTAINER && result.push(o);\r\n                });\r\n            }\r\n            else {\r\n                result.push(obj);\r\n            }\r\n\r\n            return result;\r\n        };\r\n\r\n        entity.hasClass = function (componentType) {\r\n            // Just consider componentType.main.\r\n            componentType = parseClassType(componentType);\r\n            return !!storage[componentType.main];\r\n        };\r\n\r\n        /**\r\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\r\n         */\r\n        entity.getAllClassMainTypes = function () {\r\n            var types = [];\r\n            zrUtil.each(storage, function (obj, type) {\r\n                types.push(type);\r\n            });\r\n            return types;\r\n        };\r\n\r\n        /**\r\n         * If a main type is container and has sub types\r\n         * @param  {string}  componentType\r\n         * @return {boolean}\r\n         */\r\n        entity.hasSubTypes = function (componentType) {\r\n            componentType = parseClassType(componentType);\r\n            var obj = storage[componentType.main];\r\n            return obj && obj[IS_CONTAINER];\r\n        };\r\n\r\n        entity.parseClassType = parseClassType;\r\n\r\n        function makeContainer(componentType) {\r\n            var container = storage[componentType.main];\r\n            if (!container || !container[IS_CONTAINER]) {\r\n                container = storage[componentType.main] = {};\r\n                container[IS_CONTAINER] = true;\r\n            }\r\n            return container;\r\n        }\r\n\r\n        if (options.registerWhenExtend) {\r\n            var originalExtend = entity.extend;\r\n            if (originalExtend) {\r\n                entity.extend = function (proto) {\r\n                    var ExtendedClass = originalExtend.call(this, proto);\r\n                    return entity.registerClass(ExtendedClass, proto.type);\r\n                };\r\n            }\r\n        }\r\n\r\n        return entity;\r\n    };\r\n\r\n    module.exports = clazz;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/clazz.js\n// module id = 88\n// module chunks = 0","/**\r\n * 操作图标类\r\n * @author wang.xiaohu\r\n */\r\n\r\n\r\n    var IconOperation = {\r\n        STRAIGHT_SVG: 'M937.353846 724.676923C882.215385 669.538462 795.569231 661.661538 732.553846 701.046154L362.338462 330.830769C401.723077 267.815385 393.846154 181.169231 338.707692 126.030769 267.815385 55.138462 165.415385 55.138462 94.523077 126.030769 23.630769 196.923077 23.630769 299.323077 94.523077 370.215385 149.661538 425.353846 236.307692 433.230769 299.323077 393.846154L669.538462 764.061538C630.153846 827.076923 638.030769 913.723077 693.169231 968.861538 764.061538 1039.753846 866.461538 1039.753846 937.353846 968.861538 1000.369231 897.969231 1000.369231 795.569231 937.353846 724.676923L937.353846 724.676923ZM275.692308 307.2C244.184615 338.707692 189.046154 338.707692 157.538462 307.2 126.030769 275.692308 126.030769 220.553846 157.538462 189.046154 189.046154 157.538462 244.184615 157.538462 275.692308 189.046154 307.2 220.553846 307.2 267.815385 275.692308 307.2L275.692308 307.2ZM874.338462 913.723077C842.830769 945.230769 787.692308 945.230769 756.184615 913.723077 724.676923 882.215385 724.676923 827.076923 756.184615 795.569231 787.692308 764.061538 842.830769 764.061538 874.338462 795.569231 905.846154 827.076923 905.846154 874.338462 874.338462 913.723077L874.338462 913.723077Z',\r\n        JAGGED_SVG: 'M204.8 819.2l-51.2-102.4 204.8-307.2 51.2 102.4-204.8 307.2zM409.6 512l51.2-102.4 153.6 204.8-51.2 102.4-153.6-204.8zM819.2 204.8l51.2 102.4-204.8 409.6-51.2-102.4 204.8-409.6z                                    M153.6 716.8c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8H102.4v-102.4h102.4v102.4zM409.6 204.8C322.56 204.8 256 271.36 256 358.4s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8H358.4V307.2h102.4v102.4zM614.4 614.4c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8h-102.4v-102.4h102.4v102.4zM870.4 0c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8h-102.4V102.4h102.4v102.4z',\r\n        CURVE_SVG: 'M1014.285039 824.024234l-145.168428-144.37205c-12.969593-12.855825-37.543559-14.505466-44.597197 2.332252-1.877178 4.550734-2.275367 17.179022-2.275368 17.179022v97.556369H330.935383a118.319095 118.319095 0 0 1-118.546632-117.920905A118.319095 118.319095 0 0 1 330.992267 560.878016h445.516899c121.561493 0 220.426198-98.352747 220.426198-219.23163s-98.864705-219.174746-220.426198-219.174746H340.491925A174.236244 174.236244 0 0 0 174.105698 0 173.78117 173.78117 0 0 0 0.040107 173.09856a173.78117 173.78117 0 0 0 174.065591 173.09856 174.236244 174.236244 0 0 0 166.386227-122.471639h436.017241c65.416807 0 118.603516 52.902288 118.603515 117.920905A118.319095 118.319095 0 0 1 776.509166 459.624176H330.992267c-121.504609 0-220.369314 98.352747-220.369314 219.23163s98.864705 219.174746 220.369314 219.174746h491.194895v92.550561s0 14.221045 2.332252 19.795695c7.053638 16.894602 31.627604 17.577212 44.597197 4.664502l145.111543-144.315165a32.879056 32.879056 0 0 0 0-46.645027zM174.105698 244.94328c-39.818926 0-72.242909-32.25333-72.242909-71.84472s32.423983-71.787835 72.242909-71.787835c39.818926 0 72.186025 32.196446 72.186025 71.787835 0 39.591389-32.423983 71.787835-72.242909 71.787836z',\r\n        DEL_SVG: 'M980.992 256h-84.992v683.008c0 47.104-37.888 84.992-84.992 84.992H212.992c-47.104 0-84.992-37.888-84.992-84.992V256H43.008C19.456 256 0 236.544 0 212.992c0-23.552 19.456-43.008 43.008-43.008H256V84.992C256 37.888 293.888 0 340.992 0h340.992C730.112 0 768 37.888 768 84.992v84.992h214.016c23.552 0 43.008 19.456 43.008 43.008-1.024 23.552-20.48 43.008-44.032 43.008zM683.008 84.992H340.992v84.992h340.992V84.992zM212.992 939.008h596.992V256H212.992v683.008z m171.008-470.016v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-23.552 19.456-43.008 43.008-43.008 23.552 1.024 43.008 19.456 43.008 43.008zM512 427.008c23.552 0 43.008 19.456 43.008 43.008v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-24.576 19.456-43.008 43.008-43.008z m171.008 0c23.552 0 43.008 19.456 43.008 43.008v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-24.576 19.456-43.008 43.008-43.008z',\r\n        COMMENT_SVG: 'M209.92 152.064l572.416 1.536c12.8 0 23.04 10.24 23.04 23.04v237.568c0 12.8 10.24 23.04 23.04 23.04s23.04-10.24 23.04-23.04V125.44c0-12.8-10.24-23.04-23.04-23.04H158.72c-12.8 0-23.04 10.24-23.04 23.04v773.12c0 12.8 10.24 23.04 23.04 23.04h236.032c12.8 0 23.04-10.24 23.04-23.04s-10.24-22.528-22.528-23.04l-185.856-1.536c-12.8 0-22.528-10.24-22.528-23.04V174.592c0-12.288 10.24-22.528 23.04-22.528z                                            M268.8 570.368h159.232c13.312 0 24.064 10.752 24.576 24.064v2.56c0 13.312-10.752 24.576-24.576 24.576H268.8c-13.312 0-24.064-10.752-24.576-24.064v-2.56c0.512-13.312 11.264-24.576 24.576-24.576z m0-312.32h441.344c13.312 0 24.576 10.752 24.576 24.576v2.56c0 13.312-10.752 24.576-24.576 24.576H268.8c-13.312 0-24.576-10.752-24.576-24.576v-2.56c0.512-13.312 11.264-24.576 24.576-24.576z m0.512 155.648h269.312c13.312 0 24.576 10.752 24.576 24.064v2.56c0 13.312-10.752 24.576-24.576 24.576H269.312c-13.312 0-24.576-10.752-24.576-24.064v-2.56c0-13.824 10.752-24.576 24.576-24.576z m471.04 13.312l-246.784 339.456c-1.536 2.56-2.56 5.632-2.56 8.704l-1.536 132.096c0 9.728 9.728 16.896 18.944 14.336l122.88-37.888c3.072-1.024 5.632-3.072 7.68-5.632l246.784-338.944c4.608-6.144 3.584-15.36-2.56-19.968l-121.344-94.72c-7.168-5.632-16.896-4.096-21.504 2.56z m23.04 67.584l51.2 39.936c2.048 1.536 2.56 5.12 1.024 7.168l-26.112 35.84c-1.536 2.56-5.12 3.072-7.68 1.024l-51.712-38.912c-2.048-1.536-2.56-4.608-1.024-7.168l26.624-37.376c2.048-1.536 5.632-2.048 7.68-0.512z m-165.888 341.504l-35.328 10.752c-9.216 3.072-18.944-4.096-18.944-13.824l0.512-40.96c0-3.072 1.024-6.144 2.56-8.704l137.216-187.904c1.536-2.56 5.12-2.56 7.168-1.024l51.2 38.4c2.56 2.048 3.072 5.12 1.024 7.68l-137.728 189.952c-2.048 2.56-4.608 4.608-7.68 5.632z',\r\n        CHANGE_LINE_TYPE_SVG: 'M1008 335.2 1008 335.2l-160 144 0 0c-8.8 8-20 12.8-32 12.8-26.4 0-48-21.6-48-48 0-14.4 6.4-26.4 16-35.2l0 0 67.2-60L560 348.8c0 0 0 0 0 0L464 348.8l0 0L352 348.8 48 348.8c-26.4 0-48-21.6-48-48 0-26.4 21.6-48 48-48l124.8 0 0 0L416 252.8l0 0 208 0 0 0 227.2 0L784 192l0 0c-9.6-8.8-16-21.6-16-35.2 0-26.4 21.6-48 48-48 12 0 23.2 4.8 32 12.8l0 0 160 144 0 0c9.6 8.8 16 21.6 16 35.2C1024 314.4 1017.6 326.4 1008 335.2zM16 680.8 16 680.8l160-144 0 0c8.8-8 20-12.8 32-12.8 26.4 0 48 21.6 48 48 0 14.4-6.4 26.4-16 35.2l0 0-67.2 60L400 667.2l0 0 208 0 0 0 243.2 0 0 0L976 667.2c26.4 0 48 21.6 48 48 0 26.4-21.6 48-48 48L672 763.2 560 763.2c0 0 0 0 0 0L464 763.2l0 0L172.8 763.2 240 824l0 0c9.6 8.8 16 21.6 16 35.2 0 26.4-21.6 48-48 48-12 0-23.2-4.8-32-12.8l0 0L16 752l0 0c-9.6-8.8-16-21.6-16-35.2C0 701.6 6.4 689.6 16 680.8z'\r\n    }\r\n    module.exports = IconOperation;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/manager/IconOperation.js\n// module id = 89\n// module chunks = 0","/**\r\n * flow连线管理类\r\n * @author miao.cunzhi\r\n */\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var ConnectionManager = require(\"../../../fish-topo-core/lib/manager/ConnectionManager.js\");\r\n    var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n    var Util = require('../../../fish-topo-core/lib/util');\r\n    var Point = require(\"../../../fish-topo-core/lib/Point.js\");\r\n    var Constants = require(\"../util/FlowConstants.js\");\r\n\r\n    function FlowConnectionManager(api) {\r\n        ConnectionManager.call(this);\r\n        this.bundleOffset = 30; //多线段的偏移\r\n        this.bundleGap = 20; // 多线段的间隔\r\n        this.connectorMap = Util.StackedMap.createNew(); //存放多线段\r\n        this._api = api;\r\n    }\r\n\r\n    FlowConnectionManager.prototype.add = function(connector) {\r\n        this.connectors.push(connector);\r\n        //1.处理事件\r\n        this.handleConnectorEvent(connector);\r\n        //2.判断是否两节点相联\r\n        if(connector.startNode && connector.endNode) {\r\n            var key = this.getTwoNodeId(connector.startNode, connector.endNode, connector.options.position);\r\n            this.connectorMap.add(key, connector);\r\n\r\n            this.handleConnectorShrink(connector);\r\n\r\n            this.bundleOffset = connector.options.bundleOffset || this.bundleOffset;\r\n            this.bundleGap = connector.options.bundleGap || this.bundleGap;\r\n            //2. 获取这个key对应的线段数组\r\n            var arrCons = this.connectorMap.get(key);\r\n            if (arrCons.length == 1) {\r\n                //两个节点只有一个连线的情况\r\n                //判断一下 model里有没有dockers，如果有则调用构造point数组  或者调用refreshConnector计算如何画线\r\n                var dockers = connector.options.dockers;\r\n                var points = [];\r\n                if (dockers && dockers.length >= 2) {\r\n                    points = Point.loadArray(dockers);\r\n                    connector.refresh(points);\r\n                } else {\r\n                    if (connector.options.position.points) {\r\n                        var arrStartEndPoint = this.getStartEndPoint(connector);\r\n                        points = connector.options.position.points;\r\n                        points.unshift(arrStartEndPoint[0]);\r\n                        points.push(arrStartEndPoint[1]);\r\n                        connector.refresh(points);\r\n                    } else {\r\n                        this.refreshConnector(arrCons[0], true);\r\n                    }\r\n                }\r\n            } else if (arrCons.length > 1) {\r\n                //两个节点有多个连线的情况\r\n                this.refreshCons(arrCons);\r\n            }\r\n        } else {\r\n            //处理没有 起始节点与终止节点时的连线\r\n            this.handleConnectorPoints(connector)\r\n        }\r\n\r\n        //3.设置模型\r\n        this.handleConnectorModel(connector);\r\n        return connector;\r\n    }\r\n\r\n    FlowConnectionManager.prototype.handleConnectorEvent = function(connector) {\r\n        if (connector.conPointsGroup) {\r\n            connector.conPointsGroup.on(\"click\", function(e) {\r\n                var arrSplit = e.target.type.split(Connector.SEPERATOR);\r\n                var connector = e.target.connector;\r\n                if (arrSplit[0] === Connector.START_NODE) {\r\n                    connector.options.position.startPos = arrSplit[1];\r\n                } else if (arrSplit[0] === Connector.END_NODE) {\r\n                    connector.options.position.endPos = arrSplit[1];\r\n                }\r\n                this.refreshConnector(connector, true);\r\n                e.cancelBubble = true;\r\n                var params = {};\r\n                params.event = e;\r\n                params.type = \"conPointsGroup:click\";\r\n                params.lineNode = this.selConnector;\r\n                this._api.trigger(params.type, params);\r\n            }.bind(this));\r\n        }\r\n\r\n\r\n        var MOUSE_EVENT_NAMES = ['click', 'dblclick'];\r\n        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n            connector.on(\"Connector:\" + eveName, function(e) {\r\n                var selected = e.target;\r\n                if (this.selConnector !== selected) {\r\n                    this.selConnector && this.refreshConnector(this.selConnector);\r\n                    this.selConnector = selected;\r\n                }\r\n                e.cancelBubble = true;\r\n                var params = {};\r\n                params.event = e;\r\n                params.type = eveName;\r\n                params.target = this.selConnector;\r\n                this._api.trigger(params.type, params);\r\n            }.bind(this));\r\n        }.bind(this));\r\n    }\r\n\r\n    FlowConnectionManager.prototype.handleConnectorModel = function(connector) {\r\n        connector.model.set(Constants.ELEMENT_TYPE, Constants.CONNECTION);\r\n        if(connector.startNode && connector.endNode) {\r\n            connector.model.set(Constants.START_ID, connector.startNode.id);\r\n            connector.model.set(Constants.END_ID, connector.endNode.id);\r\n        }\r\n        connector.model.set(Constants.OPTIONS, zrUtil.clone(connector.options));\r\n    }\r\n\r\n    FlowConnectionManager.prototype.handleConnectorShrink = function(connector) {\r\n        var that = this;\r\n        //双击收紧为一条线\r\n        connector.line.on(\"dblclick\", function() {\r\n            if (connector.options.isShrink == false) {\r\n                return;\r\n            }\r\n            var con = this.parent;\r\n            var startNode = con.startNode;\r\n            var endNode = con.endNode;\r\n            //1.获取所有的线段\r\n            var key = that.getTwoNodeId(startNode, endNode, connector.options.position);\r\n            var cons = that.connectorMap.get(key);\r\n            if (cons.length == 1) {\r\n                return\r\n            }\r\n            //2.判断线是否处于隐藏状态\r\n            //2.将除中间的一条线进行隐藏\r\n            var half = parseInt(cons.length / 2);\r\n            for (var i = 0; i < cons.length; i++) {\r\n                if (i != (half)) {\r\n                    if (cons[i].ignore) {\r\n                        cons[i].show();\r\n                    } else {\r\n                        cons[i].hide();\r\n                    }\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    //处理没有 起始节点与终止节点时的连线\r\n    FlowConnectionManager.prototype.handleConnectorPoints = function(connector) {\r\n        var options = connector.options;\r\n        var dockers = connector.options.dockers;\r\n        if (dockers && dockers.length >= 2) {\r\n            var points = Point.loadArray(dockers);\r\n            connector.refresh(points);\r\n        } else {\r\n            if (options.position && options.position.points) {\r\n                var oPoints = options.position.points;\r\n                connector.refresh(oPoints);\r\n            }\r\n        }\r\n    }\r\n\r\n    FlowConnectionManager.prototype.getTwoNodeId = function(startNode, endNode, pos) {\r\n        return startNode.id + '-' + pos.startPos + \",\" + endNode.id + '-' + pos.endPos;\r\n    }\r\n    //处理多条线段\r\n    FlowConnectionManager.prototype.refreshCons = function(arrCons) {\r\n        //如果是折线的话\r\n        if (arrCons[0].options.style.lineType == Connector.TYPE_JAGGED) {\r\n            for (var i = 0; i < arrCons.length; i++) {\r\n                this.refreshConnector(arrCons[i], true);\r\n            }\r\n        } else {\r\n            this.refreshConsStraight(arrCons);\r\n        }\r\n    }\r\n\r\n    //处理多条线段(直线)\r\n    FlowConnectionManager.prototype.refreshConsStraight = function(arrCons) {\r\n        var half = parseInt(arrCons.length / 2);\r\n        var arrConnectResult = []\r\n\r\n        var startNode = arrCons[0].startNode;\r\n        var endNode = arrCons[0].endNode;\r\n        var sRect = Util.getRect(startNode);\r\n        var eRect = Util.getRect(endNode).boundingRect;\r\n        var sConnectorPoint = Util.getConnectorPoints(sRect, startNode);\r\n        var eConnectorPoint = Util.getConnectorPoints(eRect, endNode);\r\n        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n        var position = arrCons[0].options.position;\r\n        if (!position.startPos || !position.endPos) {\r\n            if (sRect.x < eRect.x) {\r\n                position.startPos = \"right\";\r\n                position.endPos = \"left\";\r\n            } else {\r\n                position.startPos = \"left\";\r\n                position.endPos = \"right\";\r\n            }\r\n        }\r\n\r\n        var startPoint = sConnectorPoint[position.startPos];\r\n        var endPoint = eConnectorPoint[position.endPos];\r\n        var angle = Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x);\r\n        var points = [];\r\n        for (var i = half; i >= 1; i--) {\r\n            points = []; //var points = [];\r\n            points.push(startPoint); //\r\n            // points.push(new Point(startPoint.x + bundleOffset , startPoint.y + i * bundleGap));\r\n            // points.push(new Point(endPoint.x - bundleOffset , startPoint.y + i * bundleGap)); //startPoint.x + bundleOffset\r\n            var secondPoint = startPoint.clone();\r\n\r\n            //secondPoint.x =  secondPoint.x + this.bundleOffset;\r\n            secondPoint.transform(Util.translationMatrix(0, this.bundleGap * i));\r\n            //secondPoint = this.boundOffsetXY(secondPoint, true);\r\n            //\r\n            //直角坐标 x, 和 y, 计算出极坐标\r\n\r\n\r\n            //从极坐标计算出直角坐标\r\n            secondPoint.x = secondPoint.x + this.bundleOffset * Math.cos(angle);\r\n            secondPoint.y = secondPoint.y + this.bundleOffset * Math.sin(angle);\r\n\r\n\r\n\r\n            //secondPoint.transform(Util.scaleMatrix(0.5));\r\n            points.push(secondPoint);\r\n\r\n            var thirdPoint = endPoint.clone();\r\n            //thirdPoint.x =  thirdPoint.x - this.bundleOffset;\r\n\r\n\r\n\r\n            thirdPoint.transform(Util.translationMatrix(0, this.bundleGap * i));\r\n            //thirdPoint = this.boundOffsetXY(thirdPoint, false);\r\n            //secondPoint.transform(Util.scaleMatrix(0.5));\r\n            //\r\n            //直角坐标 x, 和 y, 计算出极坐标\r\n\r\n            //从极坐标计算出直角坐标\r\n            thirdPoint.x = thirdPoint.x - this.bundleOffset * Math.cos(angle);\r\n            thirdPoint.y = thirdPoint.y - this.bundleOffset * Math.sin(angle);\r\n\r\n            points.push(thirdPoint);\r\n\r\n            points.push(endPoint);\r\n            arrConnectResult.push(points);\r\n        }\r\n\r\n        arrConnectResult.push([startPoint, endPoint]);\r\n\r\n        var upHalf = Math.ceil(arrCons.length / 2);\r\n        for (i = 1; i < upHalf; i++) {\r\n            points = []; //var points = [];\r\n            points.push(startPoint);\r\n            var secPoint = startPoint.clone();\r\n            //secPoint.x =  secPoint.x + this.bundleOffset;\r\n            secPoint.transform(Util.translationMatrix(0, -this.bundleGap * i));\r\n            secPoint.x = secPoint.x + this.bundleOffset * Math.cos(angle);\r\n            secPoint.y = secPoint.y + this.bundleOffset * Math.sin(angle);\r\n            points.push(secPoint);\r\n\r\n            var thdPoint = endPoint.clone();\r\n            //thdPoint.x =  thdPoint.x - this.bundleOffset;\r\n            thdPoint.transform(Util.translationMatrix(0, -this.bundleGap * i));\r\n            //从极坐标计算出直角坐标\r\n            thdPoint.x = thdPoint.x - this.bundleOffset * Math.cos(angle);\r\n            thdPoint.y = thdPoint.y - this.bundleOffset * Math.sin(angle);\r\n            //secondPoint.transform(Util.scaleMatrix(0.5));\r\n            points.push(thdPoint);\r\n\r\n            points.push(endPoint);\r\n            arrConnectResult.push(points);\r\n        }\r\n\r\n\r\n        for (i = 0; i < arrConnectResult.length; i++) {\r\n            arrCons[i].refresh(arrConnectResult[i]);\r\n        }\r\n\r\n    }\r\n\r\n    FlowConnectionManager.prototype.boundOffsetXY = function(point, isPositive) {\r\n        var resultPoint = point.clone();\r\n        //直角坐标 x, 和 y, 计算出极坐标\r\n        var angle = Math.atan2(resultPoint.y, resultPoint.x);\r\n        var r = Math.sqrt(Math.pow(resultPoint.x, 2) + Math.pow(resultPoint.y, 2));\r\n        if (isPositive) {\r\n            r = r + this.bundleOffset;\r\n        } else {\r\n            r = r - this.bundleOffset;\r\n        }\r\n\r\n\r\n        //从极坐标计算出直角坐标\r\n        resultPoint.x = r * Math.cos(angle);\r\n        resultPoint.y = r * Math.sin(angle);\r\n        return resultPoint;\r\n    }\r\n\r\n    /**\r\n     * 设置线段的模型数据  (类型 文字)\r\n     * @param {[type]} connector [description]\r\n     * @param {[type]} option    [description]\r\n     */\r\n    FlowConnectionManager.prototype.setModel = function(connector, option) {\r\n        var originLineType = connector.model.get(\"style.lineType\");\r\n        connector.model.mergeOption(option);\r\n        zrUtil.merge(connector.model.get(\"options\"), option, true);\r\n        if (originLineType !== option.style.lineType) {\r\n            this.refreshConnector(connector, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 删除指定的线\r\n     * @param connector 欲删除的连线\r\n     * @param _zr zr\r\n     */\r\n    ConnectionManager.prototype.deleteByLine = function (connector,_zr) {\r\n        //1.将线 所联的startNode的outgoing数据删除\r\n        if(connector.startNode){\r\n            var startNodeOutgoing = connector.startNode.model.get(\"outgoing\");\r\n            index = zrUtil.indexOf(startNodeOutgoing, connector.resourceId);\r\n            if (index != -1) {\r\n                startNodeOutgoing.splice(index, 1);\r\n            }\r\n\r\n            if (this.connectorMap) {\r\n                var key = this.getTwoNodeId(connector.startNode, connector.endNode, connector.options.position);\r\n                this.connectorMap.removeItem(key, connector);\r\n            }\r\n        }\r\n\r\n\r\n        //2.从_zr上删除\r\n        _zr.remove(connector);\r\n\r\n\r\n        //3.从线数据中删除\r\n        var index = zrUtil.indexOf(this.connectors, connector);\r\n        if (index != -1) {\r\n            this.connectors.splice(index, 1);\r\n        }\r\n        if (this.selConnector === connector) {\r\n            this.selConnector = null;\r\n        }\r\n    }\r\n    /**\r\n     * 刷新连接线\r\n     * @param  {[type]} node [description]\r\n     * @return {[type]}      [description]\r\n     */\r\n    FlowConnectionManager.prototype.refreshLineByNode = function(node) {\r\n        // 判断这个节点是否有多条线段\r\n        var keys = this.connectorMap.keys();\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var key = keys[i];\r\n            if (key.indexOf(node.id) != -1) {\r\n                var arrCons = this.connectorMap.get(key);\r\n                this.countLinePos(arrCons)\r\n                if (arrCons.length == 1) {\r\n                    //两个节点只有一个连线的情况\r\n                    this.refreshConnector(arrCons[0], true);\r\n                } else if (arrCons.length > 1) {\r\n                    //两个节点有多个连线的情况\r\n                    this.refreshCons(arrCons);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 刷新连接线\r\n     * @param  {[type]} node [description]\r\n     * @return {[type]}      [description]\r\n     */\r\n    FlowConnectionManager.prototype.toggleLineByNode = function(node, isShow) {\r\n        // 判断这个节点是否有多条线段\r\n        var keys = this.connectorMap.keys();\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var key = keys[i];\r\n            if (key.indexOf(node.id) != -1) {\r\n                var arrCons = this.connectorMap.get(key);\r\n\r\n                zrUtil.each(arrCons, function(connection) {\r\n                    if(isShow) {\r\n                        connection.show();\r\n                    } else {\r\n                        connection.hide();\r\n                    }\r\n                })\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 重新调整线的位置\r\n     */\r\n    FlowConnectionManager.prototype.countLinePos = function(arrCons) {\r\n        zrUtil.each(arrCons, function(connector) {\r\n            var options = connector.options;\r\n            if (options.autoChangePosition == true) {\r\n                var sRect = Util.getRect(connector.startNode).boundingRect;\r\n                var eRect = Util.getRect(connector.endNode).boundingRect;\r\n                var startPos = options.position.startPos;\r\n                var endPos = options.position.endPos;\r\n                var startPosNow = this.posIsChange(startPos, sRect, eRect, \"startNode\");\r\n                var endPosNow = this.posIsChange(endPos, sRect, eRect, \"endNode\");\r\n                if (startPos != startPosNow || endPos != endPosNow) {\r\n                    options.position.startPos = startPosNow;\r\n                    options.position.endPos = endPosNow;\r\n                }\r\n            }\r\n        },this);\r\n    }\r\n\r\n    FlowConnectionManager.prototype.posIsChange = function(pos, sRect, eRect, nodeType) {\r\n        var newPos\r\n        if (pos.indexOf(\"top\") != -1 || pos.indexOf(\"bottom\") != -1) {\r\n            if (sRect.y + sRect.height < eRect.y) {\r\n                if (nodeType == \"startNode\") {\r\n                    newPos = pos.replace(/(top|bottom)/g, \"bottom\");\r\n                } else {\r\n                    newPos = pos.replace(/(top|bottom)/g, \"top\");\r\n                }\r\n            } else if (eRect.y + eRect.height < sRect.y) {\r\n                if (nodeType == \"endNode\") {\r\n                    newPos = pos.replace(/(top|bottom)/g, \"bottom\");\r\n                } else {\r\n                    newPos = pos.replace(/(top|bottom)/g, \"top\");\r\n                }\r\n            } else if (sRect.x + sRect.width < eRect.x) {\r\n                if (nodeType == \"startNode\") {\r\n                    newPos = pos.replace(/(top|bottom)/g, \"right\");\r\n                } else {\r\n                    newPos = pos.replace(/(top|bottom)/g, \"left\");\r\n                }\r\n            } else if (eRect.x + eRect.width < sRect.x) {\r\n                if (nodeType == \"endNode\") {\r\n                    newPos = pos.replace(/(top|bottom)/g, \"right\");\r\n                } else {\r\n                    newPos = pos.replace(/(top|bottom)/g, \"left\");\r\n                }\r\n            }else {\r\n                newPos = pos;\r\n            }\r\n        } else if (pos.indexOf(\"left\") != -1 || pos.indexOf(\"right\") != -1) {\r\n            if (sRect.x + sRect.width < eRect.x) {\r\n                if (nodeType == \"startNode\") {\r\n                    newPos = pos.replace(/(right|left)/g, \"right\");\r\n                } else {\r\n                    newPos = pos.replace(/(right|left)/g, \"left\");\r\n                }\r\n            } else if (eRect.x + eRect.width < sRect.x) {\r\n                if (nodeType == \"endNode\") {\r\n                    newPos = pos.replace(/(right|left)/g, \"right\");\r\n                } else {\r\n                    newPos = pos.replace(/(right|left)/g, \"left\");\r\n                }\r\n            } else if (sRect.y + sRect.height < eRect.y) {\r\n                if (nodeType == \"startNode\") {\r\n                    newPos = pos.replace(/(right|left)/g, \"bottom\");\r\n                } else {\r\n                    newPos = pos.replace(/(right|left)/g, \"top\");\r\n                }\r\n            } else if (eRect.y + eRect.height < sRect.y) {\r\n                if (nodeType == \"endNode\") {\r\n                    newPos = pos.replace(/(right|left)/g, \"bottom\");\r\n                } else {\r\n                    newPos = pos.replace(/(right|left)/g, \"top\");\r\n                }\r\n            } else {\r\n                newPos = pos;\r\n            }\r\n        } else {\r\n            newPos = pos;\r\n        }\r\n        return newPos;\r\n    }\r\n\r\n\r\n    zrUtil.inherits(FlowConnectionManager, ConnectionManager);\r\n    module.exports = FlowConnectionManager;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/manager/FlowConnectionManager.js\n// module id = 90\n// module chunks = 0","/**\r\n * 连线管理类\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var Util = require('../util');\r\n    var Point = require(\"../Point.js\");\r\n    var Connector = require(\"../shapes/Connector.js\");\r\n    var Log = require(\"../Log.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    function ConnectionManager() {\r\n        this.connectors = []; //当前画布所有的线段\r\n        this.selConnector = null; //当前选中的线段\r\n        this.tempConnector = null; //临时线段\r\n    }\r\n\r\n    /**\r\n     * 设置线的不可编辑\r\n     * @param  {[type]} forbidEdit [description]\r\n     * @return {[type]}            [description]\r\n     */\r\n    ConnectionManager.prototype.connectorForbidEdit = function (forbidEdit) {\r\n        for (var i = 0; i < this.connectors.length; i++) {\r\n            this.connectors[i].options.isEdit = !forbidEdit;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 清空连接线上的调整位置按钮\r\n     * @return {[type]} [description]\r\n     */\r\n    ConnectionManager.prototype.clearSelectCon = function () {\r\n        if (this.selConnector != null) {\r\n            this.refreshConnector(this.selConnector);\r\n        }\r\n    }\r\n    /**\r\n     * 删除和节点相关联的连接线\r\n     * @return {[type]} [description]\r\n     */\r\n    ConnectionManager.prototype.deleteSelectCon = function (node, _zr) {\r\n        for (var i = 0; i < this.connectors.length; i++) {\r\n            if (this.connectors[i].startNode == node || this.connectors[i].endNode == node) {\r\n                //1.将线 所联的startNode的outgoing数据删除\r\n                var startNodeOutgoing = this.connectors[i].startNode.model.get(\"outgoing\");\r\n                var index = zrUtil.indexOf(startNodeOutgoing, this.connectors[i].resourceId);\r\n                if (index != -1) {\r\n                    startNodeOutgoing.splice(index, 1);\r\n                }\r\n                //2.从_zr上删除\r\n                _zr.remove(this.connectors[i]);\r\n                this.connectors.splice(i, 1);\r\n                i--;\r\n                this.selConnector = null;\r\n            }\r\n        }\r\n    }\r\n    ConnectionManager.prototype.removeLine = function (line, zr) {\r\n        this.selConnector = line;\r\n        this.deleteLine(zr);\r\n    }\r\n    /**\r\n     * 删除选定的线\r\n     * @return {[type]} [description]\r\n     */\r\n    ConnectionManager.prototype.deleteLine = function (_zr) {\r\n        //1.将线 所联的startNode的outgoing数据删除\r\n        if(this.selConnector.startNode){\r\n            var startNodeOutgoing = this.selConnector.startNode.model.get(\"outgoing\");\r\n            index = zrUtil.indexOf(startNodeOutgoing, this.selConnector.resourceId);\r\n            if (index != -1) {\r\n                startNodeOutgoing.splice(index, 1);\r\n            }\r\n\r\n            if (this.connectorMap) {\r\n                var key = this.getTwoNodeId(this.selConnector.startNode, this.selConnector.endNode, this.selConnector.options.position);\r\n                this.connectorMap.removeItem(key, this.selConnector);\r\n            }\r\n        }\r\n\r\n\r\n        //2.从_zr上删除\r\n        _zr.remove(this.selConnector);\r\n\r\n\r\n        //3.从线数据中删除\r\n        var index = zrUtil.indexOf(this.connectors, this.selConnector);\r\n        if (index != -1) {\r\n            this.connectors.splice(index, 1);\r\n        }\r\n        this.selConnector = null;\r\n    }\r\n\r\n    /**\r\n     * 重新画线\r\n     * @param  {[type]} connector          [description]\r\n     * @param  {[type]} force\r\n     * @return {[type]}                    [description]\r\n     */\r\n    ConnectionManager.prototype.refreshConnector = function (connector, force) {\r\n        // 只有需要强制刷新  或者 连线为空（<2)时 才进行重新计算重绘\r\n        if (force || (!connector.turningPoints) || (connector.turningPoints.length < 2)) {\r\n            if (connector.model && connector.model.get(\"style.lineType\")) {\r\n                connector.options.style.lineType = connector.model.get(\"style.lineType\");\r\n            }\r\n            var arrStartEndPoint = this.getStartEndPoint(connector);\r\n            var escapeDistance = null;\r\n            if (connector.options.position && connector.options.position.escapeDistance) {\r\n                escapeDistance = connector.options.position.escapeDistance;\r\n            }\r\n            var solutions = this.connector2Points(connector.options.style.lineType, arrStartEndPoint[0],\r\n                arrStartEndPoint[1],\r\n                arrStartEndPoint[2], arrStartEndPoint[3], escapeDistance); // TYPE_STRAIGHT TYPE_JAGGED\r\n\r\n            connector.refresh(solutions[0][2]);\r\n        }\r\n\r\n        connector.clearHandles(); //清空handle\r\n    }\r\n\r\n\r\n    ConnectionManager.prototype.getStartEndPoint = function (connector) {\r\n        var startNode = connector.startNode;\r\n        var endNode = connector.endNode;\r\n        var isNotInSameGroup = true;\r\n        isNotInSameGroup = startNode.parent !== endNode.parent;\r\n\r\n        var sRect = startNode.getRect ? startNode.getRect().boundingRect : Util.getRect(startNode, isNotInSameGroup).boundingRect;\r\n        var sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(\r\n            sRect.y) + Number(sRect.height)];\r\n\r\n        var eRect = endNode.getRect ? endNode.getRect().boundingRect : Util.getRect(endNode, isNotInSameGroup).boundingRect;\r\n        var eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(\r\n            eRect.y) + Number(eRect.height)];\r\n\r\n\r\n        var sConnectorPoint = Util.getConnectorPoints(sRect, startNode);\r\n        var eConnectorPoint = Util.getConnectorPoints(eRect, endNode);\r\n\r\n        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n        var position = connector.options.position;\r\n        if (position.direction) {\r\n            var posArr = position.direction.split(',');\r\n            position.startPos = posArr[0];\r\n            position.endPos = posArr[1];\r\n        }\r\n        if (!position.startPos || !position.endPos) {\r\n            if (sRect.x < eRect.x) {\r\n                position.startPos = \"right\";\r\n                position.endPos = \"left\";\r\n            } else {\r\n                position.startPos = \"left\";\r\n                position.endPos = \"right\";\r\n            }\r\n        }\r\n        var startPoint = this.calcPointExpression(position.startPos, sConnectorPoint);\r\n        var endPoint = this.calcPointExpression(position.endPos, eConnectorPoint);\r\n        startPoint.add(new Point(position.startOffset[0], position.startOffset[1]));\r\n        endPoint.add(new Point(position.endOffset[0], position.endOffset[1]));\r\n        return [startPoint, endPoint, sBounds, eBounds];\r\n    }\r\n\r\n    ConnectionManager.prototype.calcPointExpression = function (pos, point) {\r\n        var variable = {\r\n            top: point.top.x,\r\n            left: point.left.y,\r\n            right: point.right.y,\r\n            bottom: point.bottom.x,\r\n            center: point.center.x\r\n        };\r\n\r\n        var expression = \"<% print(\" + pos + \") %>\";\r\n        var val = parseInt(Util.template(expression)(variable));\r\n        if (pos.indexOf(\"top\") != -1) {\r\n            return new Point(val, point.top.y);\r\n        } else if (pos.indexOf(\"left\") != -1) {\r\n            return new Point(point.left.x, val);\r\n        } else if (pos.indexOf(\"right\") != -1) {\r\n            return new Point(point.right.x, val);\r\n        } else if (pos.indexOf(\"bottom\") != -1) {\r\n            return new Point(val, point.bottom.y);\r\n        } else if (pos.indexOf(\"center\") != -1) {\r\n            return new Point(val, point.bottom.y);\r\n        } else {\r\n            throw new Error(\"pos参数错误\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 创建或修改临时线\r\n     * @param  {[type]} startNode             [description]\r\n     * @param  {[type]} rEndPoint             [description]\r\n     * @param  {[type]} lineType              [description]\r\n     * @param  {[type]} startPos              [description]\r\n     * @return {[type]}                       [description]\r\n     */\r\n    ConnectionManager.prototype.manageTempConnector = function (startNode, rEndPoint, lineType, startPos, endPos, endNode) {\r\n        var eRect = null;\r\n        var eBounds = null;\r\n        var sRect = startNode.getRect ? startNode.getRect().boundingRect : Util.getRect(startNode, true).boundingRect;\r\n        var sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(\r\n            sRect.y) + Number(sRect.height)];\r\n\r\n        var sConnectorPoint = Util.getConnectorPoints(sRect, startNode);\r\n\r\n        if (!this.tempConnector) {\r\n            this.tempConnector = new Connector({\r\n                isEdit: false,\r\n                style: {\r\n                    lineType: lineType\r\n                }\r\n            });\r\n        }\r\n\r\n        var connector = this.tempConnector;\r\n        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n        var position = connector.options.position;\r\n        position.startPos = startPos ? startPos : (sRect.x < rEndPoint.x ? \"right\" : \"left\");\r\n        position.endPos = endPos ? endPos : (sRect.x < rEndPoint.x ? \"left\" : \"right\");\r\n\r\n        connector.options.style.lineType = lineType;\r\n        if (endNode) {\r\n            eRect = endNode.getRect ? endNode.getRect().boundingRect : Util.getRect(endNode, true).boundingRect;\r\n            eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(\r\n                eRect.y) + Number(eRect.height)];\r\n        }\r\n        var solutions = this.connector2Points(lineType, sConnectorPoint[position.startPos], rEndPoint,\r\n            sBounds, eBounds); // TYPE_STRAIGHT TYPE_JAGGED\r\n\r\n        connector.refresh(solutions[0][2]);\r\n        return connector;\r\n    }\r\n\r\n    /**\r\n     * 创建或修改临时反转线\r\n     * @param  {[type]} startPoint              [description]\r\n     * @param  {[type]} endNode                 [description]\r\n     * @param  {[type]} lineType                [description]\r\n     * @param  {[type]} endPos                  [description]\r\n     * @return {[type]}                         [description]\r\n     */\r\n    ConnectionManager.prototype.manageReverseTempConnector = function (startPoint, endNode, lineType, endPos, startPos, startNode) {\r\n        var sRect = null;\r\n        var sBounds = null;\r\n        var eRect = endNode.getRect ? endNode.getRect().boundingRect : Util.getRect(endNode, true).boundingRect;\r\n        var eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(eRect.y) + Number(eRect.height)];\r\n        var eConnectorPoint = Util.getConnectorPoints(eRect, endNode);\r\n        if (!this.tempConnector) {\r\n            this.tempConnector = new Connector({\r\n                isEdit: false,\r\n                style: {\r\n                    lineType: lineType\r\n                }\r\n            });\r\n        }\r\n        var connector = this.tempConnector;\r\n        var position = connector.options.position;\r\n        position.endPos = endPos ? endPos : (eRect.x < startPoint.x ? \"right\" : \"left\");\r\n        position.startPos = startPos ? startPos : (eRect.x < startPoint.x ? \"left\" : \"right\");\r\n\r\n        connector.options.style.lineType = lineType;\r\n        if (startNode) {\r\n            sRect = startNode.getRect ? startNode.getRect().boundingRect : Util.getRect(startNode, true).boundingRect;\r\n            sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(\r\n            sRect.y) + Number(sRect.height)];\r\n        }\r\n        var solutions = this.connector2Points(lineType, startPoint, eConnectorPoint[position.endPos],\r\n            sBounds, eBounds); // TYPE_STRAIGHT TYPE_JAGGED\r\n\r\n        connector.refresh(solutions[0][2]);\r\n        return connector;\r\n    }\r\n\r\n    /**\r\n     * 删除临时线\r\n     * @param  {[type]} zr             [description]\r\n     */\r\n    ConnectionManager.prototype.removeTempConnector = function (zr) {\r\n        if (this.tempConnector) {\r\n            zr.remove(this.tempConnector);\r\n            this.tempConnector = null;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 算出 两个节点 指定两个点如何联线\r\n     * @param  {[type]} type       [description]\r\n     * @param  {[type]} startPoint [description]\r\n     * @param  {[type]} endPoint   [description]\r\n     * @param  {[type]} sBounds    [description]\r\n     * @param  {[type]} eBounds    [description]\r\n     * @return {[type]}            [description]\r\n     */\r\n    ConnectionManager.prototype.connector2Points = function (type, startPoint, endPoint, sBounds, eBounds,\r\n        escapeDistance) {\r\n        var figureEscapeDistance = [30, 30];\r\n        if (escapeDistance) {\r\n            if (!zrUtil.isArray(escapeDistance)) {\r\n                figureEscapeDistance = [escapeDistance, escapeDistance];\r\n            } else {\r\n                figureEscapeDistance = escapeDistance;\r\n            }\r\n        }\r\n\r\n        Log.group(\"connectionManager: connector2Points\");\r\n\r\n\r\n        Log.info(\"ConnectionManager: connector2Points (\" + type + \", \" + startPoint + \", \" + endPoint +\r\n            \", \" + sBounds + \", \" + eBounds + ')');\r\n        var solutions = [];\r\n\r\n\r\n\r\n        switch (type) {\r\n            case Connector.TYPE_CHAIN:\r\n\r\n            case Connector.TYPE_STRAIGHT: //直线\r\n                var points = [startPoint.clone(), endPoint.clone()];\r\n                solutions.push(['straight', 'straight', points]);\r\n                break;\r\n\r\n            case Connector.TYPE_CURVE: //曲线\r\n\r\n            case Connector.TYPE_JAGGED: //折线\r\n                var startExitPoint = null;\r\n                var endExitPoint = null;\r\n\r\n                //find start exit point  寻找开始出口\r\n                if (sBounds != null) {\r\n                    var potentialExits = [];\r\n\r\n                    potentialExits.push(new Point(startPoint.x, sBounds[1] - figureEscapeDistance[0])); //north 北\r\n                    potentialExits.push(new Point(sBounds[2] + figureEscapeDistance[0], startPoint.y)); //east  东\r\n                    potentialExits.push(new Point(startPoint.x, sBounds[3] + figureEscapeDistance[0])); //south  南\r\n                    potentialExits.push(new Point(sBounds[0] - figureEscapeDistance[0], startPoint.y)); //west  西\r\n\r\n                    //pick closest exit point  寻找与 startPoint 最靠近的出口点\r\n                    startExitPoint = potentialExits[0];\r\n                    for (var i = 1; i < potentialExits.length; i++) {\r\n                        if (Util.distance(startPoint, potentialExits[i]) < Util.distance(startPoint,\r\n                                startExitPoint)) {\r\n                            startExitPoint = potentialExits[i];\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n                //find end exit point  寻找结束出口\r\n                if (eBounds != null) {\r\n                    var potentialExits = [];\r\n\r\n                    potentialExits.push(new Point(endPoint.x, eBounds[1] - figureEscapeDistance[1])); //north\r\n                    potentialExits.push(new Point(eBounds[2] + figureEscapeDistance[1], endPoint.y)); //east\r\n                    potentialExits.push(new Point(endPoint.x, eBounds[3] + figureEscapeDistance[1])); //south\r\n                    potentialExits.push(new Point(eBounds[0] - figureEscapeDistance[1], endPoint.y)); //west\r\n\r\n                    //pick closest exit point  寻找与 endPoint 最靠近的出口点\r\n                    endExitPoint = potentialExits[0];\r\n                    for (var i = 1; i < potentialExits.length; i++) {\r\n                        if (Util.distance(endPoint, potentialExits[i]) < Util.distance(endPoint,\r\n                                endExitPoint)) {\r\n                            endExitPoint = potentialExits[i];\r\n                        }\r\n                    }\r\n                }\r\n\r\n                //Basic solution 最基本的解决方案   为其他解决方案做准备\r\n                var s = [startPoint];\r\n                var gapIndex = 0; //the index of the gap (where do we need to insert new points) DO NOT CHANGE IT\r\n                if (startExitPoint) {\r\n                    s.push(startExitPoint);\r\n                    gapIndex = 1;\r\n                }\r\n                if (endExitPoint) {\r\n                    s.push(endExitPoint);\r\n                }\r\n                s.push(endPoint);\r\n\r\n\r\n\r\n                //SO - no additional points     S0 解决方案 不添加任何点  基本不会被采用\r\n                var s0 = Point.cloneArray(s);\r\n                solutions.push(['s0', 's0', s0]);\r\n\r\n\r\n\r\n                //S1   S1 解决方案  只有一个折点\r\n                var s1 = Point.cloneArray(s);\r\n\r\n                //first variant   第一个变体 s1 s1_1方案  折线点在 startExitPoint的X 与 endExitPoint的 Y位置\r\n                var s1_1 = Point.cloneArray(s1);\r\n                s1_1.splice(gapIndex + 1, 0, new Point(s1_1[gapIndex].x, s1_1[gapIndex + 1].y));\r\n                solutions.push(['s1', 's1_1', s1_1]);\r\n\r\n                //second variant  第二变体 s1 s1-2方案  折线点在 endExitPoint的X 与  startExitPoint的Y位置\r\n                var s1_2 = Point.cloneArray(s1);\r\n                s1_2.splice(gapIndex + 1, 0, new Point(s1_2[gapIndex + 1].x, s1_2[gapIndex].y));\r\n                solutions.push(['s1', 's1_2', s1_2]);\r\n\r\n\r\n                //S2  S2 解决方案  添加两个折点\r\n\r\n                //Variant I   s2_1方案\r\n                var s2_1 = Point.cloneArray(s);\r\n                var s2_1_1 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex].y);\r\n                var s2_1_2 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex + 1].y);\r\n                s2_1.splice(gapIndex + 1, 0, s2_1_1, s2_1_2);\r\n                solutions.push(['s2', 's2_1', s2_1]);\r\n\r\n\r\n                //Variant II  s2_1方案  1折线点 x: startExitPoint的X 位置 y: startExitPoint的y+endExitPoint的y/2\r\n                //1折线点 x:endExitPoint的x  y:startExitPoint的y+endExitPoint的y/2\r\n                var s2_2 = Point.cloneArray(s);\r\n                var s2_2_1 = new Point(s2_2[gapIndex].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);\r\n                var s2_2_2 = new Point(s2_2[gapIndex + 1].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);\r\n                s2_2.splice(gapIndex + 1, 0, s2_2_1, s2_2_2);\r\n                solutions.push(['s2', 's2_2', s2_2]);\r\n\r\n\r\n                //Variant III\r\n                var s2_3 = Point.cloneArray(s);\r\n                //find the amount (stored in delta) of pixels we need to move right so no intersection with a figure will be present\r\n                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\r\n                var eastExits = [s2_3[gapIndex].x + 20, s2_3[gapIndex + 1].x + 20]; //add points X coordinates to be able to generate Variant III even in the absence of figures :p\r\n\r\n                if (sBounds) {\r\n                    eastExits.push(sBounds[2] + 20);\r\n                }\r\n\r\n                if (eBounds) {\r\n                    eastExits.push(eBounds[2] + 20);\r\n                }\r\n\r\n                var eastExit = Util.max(eastExits);\r\n                var s2_3_1 = new Point(eastExit, s2_3[gapIndex].y);\r\n                var s2_3_2 = new Point(eastExit, s2_3[gapIndex + 1].y);\r\n                s2_3.splice(gapIndex + 1, 0, s2_3_1, s2_3_2);\r\n                solutions.push(['s2', 's2_3', s2_3]);\r\n\r\n\r\n                //Variant IV  s2_4方案\r\n                var s2_4 = Point.cloneArray(s);\r\n                //find the amount (stored in delta) of pixels we need to move up so no intersection with a figure will be present\r\n                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\r\n                var northExits = [s2_4[gapIndex].y - 20, s2_4[gapIndex + 1].y - 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p\r\n\r\n                if (sBounds) {\r\n                    northExits.push(sBounds[1] - 20);\r\n                }\r\n\r\n                if (eBounds) {\r\n                    northExits.push(eBounds[1] - 20);\r\n                }\r\n\r\n                var northExit = Util.min(northExits);\r\n                var s2_4_1 = new Point(s2_4[gapIndex].x, northExit);\r\n                var s2_4_2 = new Point(s2_4[gapIndex + 1].x, northExit);\r\n                s2_4.splice(gapIndex + 1, 0, s2_4_1, s2_4_2);\r\n                solutions.push(['s2', 's2_4', s2_4]);\r\n\r\n\r\n                //Variant V\r\n                var s2_5 = Point.cloneArray(s);\r\n                //find the amount (stored in delta) of pixels we need to move left so no intersection with a figure will be present\r\n                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\r\n                var westExits = [s2_5[gapIndex].x - 20, s2_5[gapIndex + 1].x - 20]; //add points x coordinates to be able to generate Variant III even in the absence of figures :p\r\n\r\n                if (sBounds) {\r\n                    westExits.push(sBounds[0] - 20);\r\n                }\r\n\r\n                if (eBounds) {\r\n                    westExits.push(eBounds[0] - 20);\r\n                }\r\n\r\n                var westExit = Util.min(westExits);\r\n                var s2_5_1 = new Point(westExit, s2_5[gapIndex].y);\r\n                var s2_5_2 = new Point(westExit, s2_5[gapIndex + 1].y);\r\n                s2_5.splice(gapIndex + 1, 0, s2_5_1, s2_5_2);\r\n                solutions.push(['s2', 's2_5', s2_5]);\r\n\r\n\r\n                //Variant VI\r\n                var s2_6 = Point.cloneArray(s);\r\n                //find the amount (stored in delta) of pixels we need to move down so no intersection with a figure will be present\r\n                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\r\n                var southExits = [s2_6[gapIndex].y + 20, s2_6[gapIndex + 1].y + 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p\r\n\r\n                if (sBounds) {\r\n                    southExits.push(sBounds[3] + 20);\r\n                }\r\n\r\n                if (eBounds) {\r\n                    southExits.push(eBounds[3] + 20);\r\n                }\r\n\r\n                var southExit = Util.max(southExits);\r\n                var s2_6_1 = new Point(s2_6[gapIndex].x, southExit);\r\n                var s2_6_2 = new Point(s2_6[gapIndex + 1].x, southExit);\r\n                s2_6.splice(gapIndex + 1, 0, s2_6_1, s2_6_2);\r\n                solutions.push(['s2', 's2_6', s2_6]);\r\n\r\n\r\n\r\n                //FILTER solutions\r\n\r\n                /*Algorithm\r\n                 * 0. solutions are ordered from minimmun nr of points to maximum >:)\r\n                 * 1. remove all solutions that are not orthogonal (mainly s0 solution)\r\n                 * 2. remove all solutions that go backward (we will not need them ever)\r\n                 * 3. remove all solutions with intersections\r\n                 * 4. pick first class of solutions with same nr of points (ex: 2)\r\n                 * 5. pick the first solution with 90 degree angles (less turnarounds)\r\n                 * (not interesteted) sort by length :p\r\n                 */\r\n\r\n                //1. filter non ortogonal solutions 删除不是正交直线的方案\r\n                Log.info(\"Filter orthogonal solutions. Initial number of solutions = \" + solutions.length);\r\n                var orthogonalSolution = [];\r\n                for (var l = 0; l < solutions.length; l++) {\r\n                    var solution = solutions[l][2];\r\n                    if (Util.orthogonalPath(solution)) {\r\n                        orthogonalSolution.push(solutions[l]);\r\n                    }\r\n                }\r\n                solutions = orthogonalSolution;\r\n                Log.info(\"\\n\\tOrthogonalSolutions = \" + solutions.length);\r\n\r\n                //2. filter backward solutions  过滤 倒退的方案\r\n                //do not allow start and end points to coincide - ignore them\r\n                if (startPoint.equals(endPoint)) {\r\n                    Log.info(\r\n                        \"Start and end point coincide...skip backward solution. I think we will just fall on s0 :)\"\r\n                    );\r\n                } else {\r\n                    Log.info(\"Filter backward solutions. Initial number of solutions = \" + solutions.length);\r\n                    var forwardSolutions = [];\r\n                    var temp = '';\r\n                    for (var l = 0; l < solutions.length; l++) {\r\n                        var solution = solutions[l][2];\r\n                        if (Util.forwardPath(solution)) {\r\n                            forwardSolutions.push(solutions[l]);\r\n                        } else {\r\n                            temp = temp + \"\\n\\t\" + solution;\r\n                        }\r\n                    }\r\n                    solutions = forwardSolutions;\r\n                    Log.info(\"\\n\\t ForwardSolutions = \" + solutions.length);\r\n                    if (solutions.length == 0) {\r\n                        Log.info(\"Discarded solutions: \" + temp);\r\n                    }\r\n                }\r\n\r\n\r\n                //3. Filter non intersecting solutions  去除没有交集()的方案\r\n                Log.info(\"Filter non intersecting solutions. Initial number of solutions = \" + solutions.length);\r\n                var nonIntersectionSolutions = []\r\n                for (var l = 0; l < solutions.length; l++) {\r\n                    var solution = solutions[l][2];\r\n                    //Log.info(\"Solution id= \" + solutions[l][1] + ' nr points = ' + solution.length + \", points = \" + solution);\r\n                    var intersect = false;\r\n\r\n                    var innerLines = solution.slice(); //just a shallow copy\r\n\r\n                    /*If any bounds just trim the solution. So we avoid the strange case when a connection\r\n                     *startes from a point on a figure and ends inside of the same figure, but not on a connection point*/\r\n                    if (eBounds || sBounds) {\r\n                        //i0nnerLines = innerLines.slice(0, innerLines.length - 1);\r\n                        innerLines = innerLines.slice(1, innerLines.length - 1);\r\n                        //Log.info(\"\\t eBounds present,innerLines nr. points = \" + innerLines.length + \", points = \" + innerLines);\r\n                    }\r\n\r\n\r\n\r\n                    //now test for intersection\r\n                    if (sBounds) {\r\n                        intersect = intersect || Util.polylineIntersectsRectangle(innerLines, sBounds);\r\n                    }\r\n                    if (eBounds) {\r\n                        intersect = intersect || Util.polylineIntersectsRectangle(innerLines, eBounds);\r\n                    }\r\n\r\n                    if (!intersect) {\r\n                        nonIntersectionSolutions.push(solutions[l]);\r\n                    }\r\n                }\r\n\r\n                //If all solutions intersect than this is destiny  :) and just ignore the intersection filter\r\n                if (nonIntersectionSolutions.length != 0) {\r\n                    //reasign to solutions\r\n                    solutions = nonIntersectionSolutions;\r\n                }\r\n\r\n                Log.info(\"\\n\\t nonIntersectionSolutions = \" + solutions.length);\r\n\r\n\r\n                //4. get first class of solutions with same nr of points 选择与第一个方案点数一样多的方案（因为第一个方案点数最少）\r\n                Log.info(\"Get first class of solutions with same nr of points\");\r\n                if (solutions.length == 0) {\r\n                    Log.info(\"This is not possible\");\r\n                }\r\n\r\n                var firstSolution = solutions[0][2]; //pick first solution\r\n                var nrOfPoints = firstSolution.length;\r\n                var sameNrPointsSolution = [];\r\n\r\n                for (var l = 0; l < solutions.length; l++) {\r\n                    var solution = solutions[l][2];\r\n                    if (solution.length == nrOfPoints) {\r\n                        sameNrPointsSolution.push(solutions[l]);\r\n                    }\r\n                }\r\n\r\n                solutions = sameNrPointsSolution;\r\n\r\n\r\n\r\n\r\n                /*5.  计算路径分数 ，取最分数高的\r\n                 Pick the first solution with 90 degree angles (less turnarounds)\r\n                 *in case we have more than one solution in our class\r\n                 */\r\n                Log.info(\"pick the first solution with 90 degree angles (less turnarounds)\");\r\n                var solIndex = 0;\r\n                for (var l = 0; l < solutions.length; l++) {\r\n                    var solution = solutions[l][2];\r\n                    if (Util.scorePath(solutions[solIndex][2]) < Util.scorePath(solutions[l][2])) {\r\n                        solIndex = l;\r\n                    }\r\n                }\r\n                solutions = [solutions[solIndex]];\r\n\r\n\r\n                break;\r\n        }\r\n\r\n        //SMOOTHING curve\r\n        if (type === Connector.TYPE_CURVE) {\r\n            this.smoothCurve(solutions);\r\n        }\r\n        //END SMOOTHING curve\r\n\r\n        Log.groupEnd();\r\n\r\n        return solutions;\r\n    }\r\n\r\n    ConnectionManager.prototype.smoothCurve = function (solutions) {\r\n        var option = 3;\r\n\r\n        switch (option) {\r\n            case 0:\r\n                //do nothing\r\n                break;\r\n\r\n            case 1: //add intermediate points\r\n                //Add the middle point for start and end segment so that we \"force\" the\r\n                //curve to both come \"perpendicular\" on bounds and also make the curve\r\n                //\"flee\" more from bounds (on exit)\r\n                for (var s = 0; s < solutions.length; s++) {\r\n                    var solTurningPoints = solutions[s][2];\r\n\r\n                    //first segment\r\n                    var a1 = solTurningPoints[0];\r\n                    var a2 = solTurningPoints[1];\r\n                    var startMiddlePoint = Util.getMiddle(a1, a2);\r\n                    solTurningPoints.splice(1, 0, startMiddlePoint);\r\n\r\n                    //last segment\r\n                    var a3 = solTurningPoints[solTurningPoints.length - 2];\r\n                    var a4 = solTurningPoints[solTurningPoints.length - 1];\r\n                    var endMiddlePoint = Util.getMiddle(a3, a4);\r\n                    solTurningPoints.splice(solTurningPoints.length - 1, 0, endMiddlePoint);\r\n                }\r\n                break;\r\n\r\n            case 2: //remove points\r\n\r\n                zrUtil.each(solutions, function(solution) {\r\n                    var solType = solution[0];\r\n                    if (solType == 's1' || solType == 's2') {\r\n                        var solTurningPoints = solution[2];\r\n                        solTurningPoints.splice(1, 1);\r\n                        solTurningPoints.splice(solTurningPoints.length - 2, 1);\r\n                    }\r\n                });\r\n                break;\r\n\r\n            case 3:\r\n                /*remove colinear point for s1 as it seems that more colinear points do not look good\r\n                 * on organic solutions >:D*/\r\n                zrUtil.each(solutions, function(solution) {\r\n                    var solType = solution[0];\r\n                    if (solType == 's1') {\r\n                        var solTurningPoints = solution[2];\r\n                        var reducedSolution = Util.collinearReduction(solTurningPoints);\r\n                        solution[2] = reducedSolution;\r\n                    }\r\n                });\r\n                break;\r\n        } //end switch\r\n\r\n    }\r\n\r\n    module.exports = ConnectionManager;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/manager/ConnectionManager.js\n// module id = 91\n// module chunks = 0","/**\r\n * 日志类\r\n * @author wang.xiaohu\r\n */\r\n\r\n\r\n    var Log  = {\r\n        LOG_LEVEL_NONE  : 0,\r\n\r\n        LOG_LEVEL_DEBUG : 1,\r\n\r\n        LOG_LEVEL_INFO : 2,\r\n\r\n        LOG_LEVEL_ERROR : 3,\r\n\r\n        level : this.LOG_LEVEL_ERROR,\r\n        \r\n        /**\r\n        * The less important of all messages\r\n        * @param {String} message - the message to be logged\r\n        **/\r\n        debug: function (message){\r\n            if(typeof console !== 'undefined'){\r\n                if(this.level <= this.LOG_LEVEL_DEBUG){\r\n                    \r\n                    //in FF is debug\r\n                    if(typeof console.debug == 'function'){\r\n                        console.debug(message);\r\n                    }\r\n                    else{//TODO: in IE is log\r\n    //                    console.info(message);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n\r\n        /**\r\n        * The commonly used log message\r\n        * @param {String} message - the message to be logged\r\n        **/\r\n        info : function (message){\r\n            if(typeof console !== 'undefined'){\r\n                if(this.level <= this.LOG_LEVEL_INFO){\r\n                    console.info(message);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n        * The worse kind of message. Usually a crash\r\n        * @param {String} message - the message to be logged\r\n        **/\r\n        error : function (message){\r\n            if(typeof console !== 'undefined'){\r\n                if(this.level <= this.LOG_LEVEL_ERROR){\r\n                    console.error(message);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         *Start grouping the log messages\r\n         *@param {String} title - the title of the group\r\n         *@see <a href=\"http://getfirebug.com/logging\">http://getfirebug.com/logging</a>\r\n         **/\r\n        group : function(title){\r\n            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info\r\n                if(typeof console !== 'undefined'){           \r\n                    /**If we do not test for group() function you will get an error in Opera\r\n                     *as Opera has it's own console...which does not have a group() function*/\r\n                    if(typeof console.group === 'function'){\r\n                        console.group(title);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        /**Ends current message grouping*/\r\n        groupEnd : function(){\r\n            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info\r\n                if(typeof console !== 'undefined'){\r\n                    /**If we do not test for groupEnd() function you will get an error in Opera\r\n                     *as Opera has it's own console...which does not have a group() function*/\r\n                    if(typeof console.groupEnd === 'function'){\r\n                        console.groupEnd();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    };\r\n\r\n    //Log.level = Log.LOG_LEVEL_DEBUG; \r\n    Log.level = Log.LOG_LEVEL_ERROR; \r\n    //Log.level = Log.LOG_LEVEL_ERROR;\r\n    //Log.level = Log.LOG_LEVEL_NONE;\r\n    module.exports = Log;\r\n    \r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/Log.js\n// module id = 92\n// module chunks = 0","/**\r\n * 常量定义\r\n */\r\n\r\n\tmodule.exports = \t{\r\n\t\tELEMENT_TYPE: \"elementType\",\r\n\t\tMODE: \"mode\",\r\n\t\tBACKGROUND: \"backgroud\",\r\n\t\tOPTIONS: \"options\",\r\n\t\tUSERDATA: \"userData\",\r\n\t\tID: \"id\",\r\n\t\tSTART_ID: \"startNodeId\",\r\n\t\tEND_ID: \"endNodeId\",\r\n\t\tALARM: \"Alarm\",\r\n\t\tRELATIONID:\"relationId\",\r\n\t\tRELATION_IMAGE:\"relationImage\",\r\n\t\tGROUP: \"Group\",\r\n\t\tGROUP_NODE:\"GroupNode\",\r\n\t\tCONNECTION: \"connection\",\r\n\t\tCHILDS: \"childs\",\r\n\t\tTREE_ROOT: \"treeRoot\",\r\n\t\tDOCKERS:\"options.dockers\",\r\n\t\tSTYLE_LINETYPE:\"style.lineType\",\r\n\t\tLINEOPERATIONICON:\"LineOperationIcon\",\r\n\t\tDEL:\"DEL\",\r\n\t\tLINK:\"straight\",\r\n\t\tFOLD:\"jagged\",\r\n\t\tCURVE:\"curve\"\r\n\t};\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/util/FlowConstants.js\n// module id = 93\n// module chunks = 0","/**\r\n * Flow工具类\r\n * @author wang.xiaohu9\r\n */\r\n\r\n    var Constants = require(\"./FlowConstants.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var GroupNode = require(\"../node/GroupNode.js\");\r\n    var Rect = require(\"../node/Rect.js\");\r\n    var Circle = require(\"../node/Circle.js\");\r\n    var Image = require(\"../node/Image.js\");\r\n    var Text = require(\"../node/Text.js\");\r\n    var Sector = require(\"../node/Sector.js\");\r\n    var Ring = require(\"../node/Ring.js\");\r\n    var Ellipse = require(\"../node/Ellipse.js\");\r\n    var Heart = require(\"../node/Heart.js\");\r\n    var Droplet = require(\"../node/Droplet.js\");\r\n    var Rose = require(\"../node/Rose.js\");\r\n    var Isogon = require(\"../node/Isogon.js\");\r\n    var Polygon = require(\"../node/Polygon.js\");\r\n    var Line = require(\"../node/Line.js\");\r\n    var Polyline = require(\"../node/Polyline.js\");\r\n    var BezierCurve = require(\"../node/BezierCurve.js\");\r\n    var Arc = require(\"../node/Arc.js\");\r\n    var Star = require(\"../node/Star.js\");\r\n    var Trochoid = require(\"../node/Trochoid.js\");\r\n    var Path = require(\"../node/Path.js\");\r\n    var IconButton = require(\"../node/IconButton\");\r\n    var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n    var flowLink = require(\"../link/flowLink\");\r\n    /**\r\n     * 根据结点数组 导出JSON格式的数据\r\n     *\r\n     * @param {Array} model 总的模型\r\n     * @return {JSON} JSON格式的数据\r\n     */\r\n    function toJson(model, group) {\r\n        var jsonArr = [];\r\n        group.eachChild(function (node) {\r\n            if (node.model) {\r\n                //如果是组的话\r\n                if (node instanceof GroupNode) {\r\n                    var childArr = [];\r\n                    node.eachChild(function (childNode) {\r\n                        if (childNode.model) {\r\n                            if (childNode instanceof Connector) {\r\n                                childNode.refreshModel();\r\n                            } else {\r\n                                childNode.model.set(\"options.position\", childNode.position);\r\n                            }\r\n                            childArr.push(childNode.model.option);\r\n                        }\r\n                    });\r\n                    node.model.set(Constants.CHILDS, childArr);\r\n                }\r\n                if (node instanceof Connector) {\r\n                    node.refreshModel();\r\n                }\r\n                jsonArr.push(node.model.option);\r\n\r\n            }\r\n\r\n        })\r\n        model.set(Constants.CHILDS, jsonArr);\r\n        return model.option;\r\n    }\r\n\r\n    /**\r\n     * 根据 JSON 生成节点\r\n     * @param  {[type]} fishTopoflow [description]\r\n     * @param  {[type]} json         [description]\r\n     * @param {Boolean} isNoCount 是否需要step计数，默认是需要计数\r\n     * @return {[type]}              [description]\r\n     */\r\n    function fromJson(fishTopoflow, group, childShapes, isChild, layoutRootNode, isNoCount) {\r\n        var connectors = [];\r\n        // 1.先创建节点  遍历形状 获取模型\r\n        for (var i = 0; i < childShapes.length; i++) {\r\n            var shape = childShapes[i];\r\n            if (shape.elementType === Constants.CONNECTION) {\r\n                connectors.push(shape);\r\n            } else if (shape.elementType === Constants.ALARM) {\r\n                var relationNode = findNodeById(fishTopoflow.allNodes, shape.relationId);\r\n                fishTopoflow.createAlarm(relationNode, shape.options);\r\n            } else if ((shape.elementType === Constants.GROUP_NODE) || (shape.elementType === Constants.GROUP)) {\r\n                // 解决反序列组，组连线无法匹配组问题\r\n                // shape.options.id = shape.id;\r\n                var createdGroup = fishTopoflow.createNode(Constants.GROUP, shape.options, shape.userData);\r\n                if (shape.childs) {\r\n                    fromJson(fishTopoflow, createdGroup, shape.childs, true, layoutRootNode, isNoCount);\r\n                }\r\n\r\n                // 判断组节点是否有父节点\r\n                if (isChild) {\r\n                    group.add(createdGroup);\r\n                } else {\r\n                    fishTopoflow.addNode(createdGroup, {}, isNoCount);\r\n                }\r\n\r\n\r\n            } else {\r\n                // 根据options创建节点\r\n                var node = fishTopoflow.createNode(shape.elementType, shape.options, shape.userData);\r\n                if (isChild) {\r\n                    group.add(node);\r\n                } else {\r\n                    fishTopoflow.addNode(node, {}, isNoCount);\r\n                }\r\n\r\n                if (shape.options.layout) {\r\n                    if (shape.options.layout.layout === Constants.TREE_ROOT) {\r\n                        var nodeForLayout = findNodeById(fishTopoflow.allNodes, shape.id)\r\n                        layoutRootNode.push(nodeForLayout);\r\n                        //  fishTopo.layoutNode(\"tree\",{\"node\":node});\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        // 2. 再创建线\r\n        zrUtil.each(connectors, function (line) {\r\n            var startNode = findNodeById(fishTopoflow.allNodes, line.startNodeId);\r\n            var endNode = findNodeById(fishTopoflow.allNodes, line.endNodeId);\r\n            if (startNode && endNode) {\r\n                var link = fishTopoflow.createLink(startNode, endNode, line.options, line.userData);\r\n                if (isChild) {\r\n                    group.add(link);\r\n                } else {\r\n                    fishTopoflow.addNode(link, {}, isNoCount);\r\n                }\r\n            }else{\r\n                var thisLink = flowLink.Link.createByPoint(line.options,line.userData);\r\n                if (isChild) {\r\n                    group.add(thisLink);\r\n                } else {\r\n                    fishTopoflow.addNode(thisLink, {}, isNoCount);\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * 根据id在group中查找,  因组内子节点之间的连线,在group中查找不到,所以要在allNodes里面取\r\n     * @param  {[type]} group  [description]\r\n     * @param  {[type]} nodeId [description]\r\n     * @return {[type]}        [description]\r\n     */\r\n    function findNodeById(allNodes, nodeId) {\r\n        var retNode = null;\r\n        allNodes.forEach(function (node) {\r\n            if (node.id === nodeId) {\r\n                retNode = node;\r\n            }\r\n        });\r\n        return retNode;\r\n    }\r\n\r\n    /**\r\n     * Get canvas which has all thing rendered\r\n     * @param {Object} opts\r\n     * @param {string} [opts.backgroundColor]\r\n     */\r\n    function getRenderedCanvas(zr, opts) {\r\n        opts = opts || {};\r\n        opts.pixelRatio = opts.pixelRatio || 1;\r\n        opts.backgroundColor = opts.backgroundColor ||\r\n            \"#FFFFFF\";\r\n        var list = zr.storage.getDisplayList();\r\n        // Stop animations\r\n        zrUtil.each(list, function (el) {\r\n            var animators = el.animators;\r\n            var len = animators.length;\r\n            for (var i = 0; i < len; i++) {\r\n                animators[i].stop(false);\r\n            }\r\n        });\r\n        return zr.painter.getRenderedCanvas(opts);\r\n    }\r\n\r\n    function toDataURL(zr, opts) {\r\n        opts = opts || {};\r\n        var url = getRenderedCanvas(zr, opts).toDataURL(\r\n            'image/' + (opts && opts.type || 'png')\r\n        );\r\n        var list = zr.storage.getDisplayList();\r\n        // Start animations\r\n        zrUtil.each(list, function (el) {\r\n            var animators = el.animators;\r\n            var len = animators.length;\r\n            for (var i = 0; i < len; i++) {\r\n                animators[i].start();\r\n            }\r\n        });\r\n        return url;\r\n    }\r\n\r\n    function truncPosition(position) {\r\n        var x = parseInt(position[0], 10);\r\n        var y = parseInt(position[1], 10);\r\n        if (x < 0) {\r\n            x = 0\r\n        }\r\n        if (y < 0) {\r\n            y = 0\r\n        }\r\n        return [x, y];\r\n    }\r\n\r\n    function registerFlowNode(flowNode) {\r\n        var nodeCtors = {\r\n            Rect: Rect,\r\n            Circle: Circle,\r\n            Image: Image,\r\n            Text: Text,\r\n            Sector: Sector,\r\n            Ring: Ring,\r\n            Ellipse: Ellipse,\r\n            Heart: Heart,\r\n            Droplet: Droplet,\r\n            Rose: Rose,\r\n            Isogon: Isogon,\r\n            Polygon: Polygon,\r\n            Line: Line,\r\n            Polyline: Polyline,\r\n            BezierCurve: BezierCurve,\r\n            Arc: Arc,\r\n            Star: Star,\r\n            Trochoid: Trochoid,\r\n            Path: Path,\r\n            Group: GroupNode,\r\n            IconButton: IconButton\r\n        }\r\n        for (var name in nodeCtors) {\r\n            flowNode[name] = nodeCtors[name]\r\n        }\r\n        return flowNode;\r\n    }\r\n\r\n    /**\r\n     * Normalize css liked array configuration\r\n     * e.g.\r\n     *  3 => [3, 3, 3, 3]\r\n     *  [4, 2] => [4, 2, 4, 2]\r\n     *  [4, 3, 2] => [4, 3, 2, 3]\r\n     * @param {number|Array.<number>} val\r\n     */\r\n    function normalizeCssArray(val) {\r\n        var len = val.length;\r\n        if (typeof (val) === 'number') {\r\n            return [val, val, val, val];\r\n        } else if (len === 2) {\r\n            // vertical | horizontal\r\n            return [val[0], val[1], val[0], val[1]];\r\n        } else if (len === 3) {\r\n            // top | horizontal | bottom\r\n            return [val[0], val[1], val[2], val[1]];\r\n        }\r\n        return val;\r\n    }\r\n\r\n    function _trim(str) {\r\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\r\n    }\r\n\r\n    function parsePercent(percent, all) {\r\n        switch (percent) {\r\n            case 'center':\r\n            case 'middle':\r\n                percent = '50%';\r\n                break;\r\n            case 'left':\r\n            case 'top':\r\n                percent = '0%';\r\n                break;\r\n            case 'right':\r\n            case 'bottom':\r\n                percent = '100%';\r\n                break;\r\n        }\r\n        if (typeof percent === 'string') {\r\n            if (_trim(percent).match(/%$/)) {\r\n                return parseFloat(percent) / 100 * all;\r\n            }\r\n\r\n            return parseFloat(percent);\r\n        }\r\n\r\n        return percent == null ? NaN : +percent;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @param {string} str\r\n     * @param {boolean} [upperCaseFirst=false]\r\n     * @return {string} str\r\n     */\r\n    function toCamelCase(str, upperCaseFirst) {\r\n        str = (str || '').toLowerCase().replace(/-(.)/g, function (match, group1) {\r\n            return group1.toUpperCase();\r\n        });\r\n\r\n        if (upperCaseFirst && str) {\r\n            str = str.charAt(0).toUpperCase() + str.slice(1);\r\n        }\r\n\r\n        return str;\r\n    }\r\n    /**\r\n     * Enable property storage to any host object.\r\n     * Notice: Serialization is not supported.\r\n     *\r\n     * For example:\r\n     * var get = modelUitl.makeGetter();\r\n     *\r\n     * function some(hostObj) {\r\n     *      get(hostObj)._someProperty = 1212;\r\n     *      ...\r\n     * }\r\n     *\r\n     * @return {Function}\r\n     */\r\n    var makeGetter = (function () {\r\n        var index = 0;\r\n        return function () {\r\n            var key = '\\0__topo_prop_getter_' + index++;\r\n            return function (hostObj) {\r\n                return hostObj[key] || (hostObj[key] = {});\r\n            };\r\n        };\r\n    })();\r\n    var encodeHTML = function (source) {\r\n        return String(source)\r\n            .replace(/&/g, '&amp;')\r\n            .replace(/</g, '&lt;')\r\n            .replace(/>/g, '&gt;')\r\n            .replace(/\"/g, '&quot;')\r\n            .replace(/'/g, '&#39;');\r\n    };\r\n\r\n    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\r\n\r\n    var wrapVar = function (varName, seriesIdx) {\r\n        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\r\n    };\r\n    /**\r\n     * Template formatter\r\n     * @param {string} tpl\r\n     * @param {Array.<Object>|Object} paramsList\r\n     * @param {boolean} [encode=false]\r\n     * @return {string}\r\n     */\r\n    function formatTpl(tpl, paramsList, encode) {\r\n        if (!zrUtil.isArray(paramsList)) {\r\n            paramsList = [paramsList];\r\n        }\r\n        var seriesLen = paramsList.length;\r\n        if (!seriesLen) {\r\n            return '';\r\n        }\r\n\r\n        var $vars = paramsList[0].$vars || [];\r\n        for (var i = 0; i < $vars.length; i++) {\r\n            var alias = TPL_VAR_ALIAS[i];\r\n            var val = wrapVar(alias, 0);\r\n            tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);\r\n        }\r\n        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\r\n            for (var k = 0; k < $vars.length; k++) {\r\n                var ret = paramsList[seriesIdx][$vars[k]];\r\n                tpl = tpl.replace(\r\n                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\r\n                    encode ? encodeHTML(ret) : ret\r\n                );\r\n            }\r\n        }\r\n\r\n        return tpl;\r\n    }\r\n\r\n\r\n    module.exports = {\r\n        toJson: toJson,\r\n        fromJson: fromJson,\r\n        toDataURL: toDataURL,\r\n        truncPosition: truncPosition,\r\n        registerFlowNode: registerFlowNode,\r\n        normalizeCssArray: normalizeCssArray,\r\n        parsePercent: parsePercent,\r\n        toCamelCase: toCamelCase,\r\n        makeGetter: makeGetter,\r\n        formatTpl: formatTpl,\r\n        findNodeById: findNodeById\r\n    };\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/util/FlowUtil.js\n// module id = 94\n// module chunks = 0","/**\r\n * 组， 组中元素的坐标都是相对于这个组的<br>\r\n * @class fishTopoFlow.node.GroupNode\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var group1 = new node.Group({\r\n *           position:[60,50]\r\n *       });\r\n *\r\n *       var rect1 = new node.Rect({\r\n *           shape:{width:120,height:30},\r\n *           style:{text:\"标题\", fill:\"#FFB90F\",stroke:\"#bbbbbb\"},\r\n *           position:[0,0],\r\n *           selectable:false\r\n *       });\r\n *\r\n *       var rect2 = new node.Rect({\r\n *           shape:{width:120,height:60},\r\n *           style:{text:\"内容\", fill:\"#FFFFFF\",stroke:\"#bbbbbb\"},\r\n *           position:[0,30],\r\n *           selectable:false\r\n *       });\r\n *\r\n *       group1.add(rect1);\r\n *       group1.add(rect2);\r\n *       fishTopo.add(group1);\r\n */\r\n\r\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var BoundingRect = require('zrender/lib/core/BoundingRect.js');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n    var util = require(\"../../../fish-topo-core/lib/util.js\");\r\n    var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n    var flowNode =require('./flowNode');\r\n\r\n    function GroupNode(opts) {\r\n        this.model = flowNode.genModel(\"GroupNode\", opts);\r\n        graphic.Group.call(this, opts);\r\n\r\n        var defaultOptions = {\r\n            shape: {\r\n                width: 5,\r\n                height: 5,\r\n                r: 5\r\n            },\r\n            style: {\r\n                fill: 'rgba(0,0,0,0)',//'#f9f9f9',\r\n                stroke: 'rgba(0,0,0,0)'//'#bbbbbb'\r\n            },\r\n            position: [0, 0]\r\n        };\r\n        this.options = zrUtil.merge(defaultOptions, opts, true);\r\n        //函数无法clone 原型clone不上\r\n        this.options.layout = opts.layout;\r\n        this.max = [1024, 960];\r\n        this.render(this.options);\r\n    }\r\n    GroupNode.RECT_NAME = \"GROUP_RECT_NAME\";\r\n    GroupNode.prototype = {\r\n        constructor: GroupNode,\r\n        type: \"GroupNode\",\r\n        render: function (model) {\r\n            var rect = new graphic.Rect({\r\n                shape: model.shape,\r\n                style: model.style,\r\n                //silent:true, //加上后 拖动 组中没有子元素的地方 无法手动了\r\n                z: 1\r\n            });\r\n            rect.name = GroupNode.RECT_NAME;\r\n            this.add(rect);\r\n            this.position = model.position;\r\n            this.mergedImage = model.mergedImage;\r\n        },\r\n        rectContain: function (x, y) {\r\n            var rect = util.getRect(this);\r\n            return rect.boundingRect.contain(x, y);\r\n        },\r\n\r\n        add: function(child) {\r\n            if (child && child !== this && child.parent !== this) {\r\n                this._children.push(child);\r\n                this._doAdd(child);\r\n            }\r\n            this._api && this._api._addGroupNode(this,child);\r\n            return this;\r\n\r\n        },\r\n\r\n        /**\r\n         * 遍历组中每一个子节点\r\n         * @param  {Function} cb 回调函数cb\r\n         * @param  {Object} context   上下文context\r\n         */\r\n        each: function (cb, context) {\r\n            var children = this._children;\r\n            for (var i = 0; i < children.length; i++) {\r\n                var child = children[i];\r\n                if (child.name != GroupNode.RECT_NAME) {\r\n                    cb.call(context, child, i);\r\n                }\r\n            }\r\n            return this;\r\n        },\r\n        // 设置 group中框形大小为 group的包围和\r\n        willRender:function (api) {\r\n            if (this.options.layout) {\r\n                this.setLayout(this.options.layout);\r\n            }\r\n            this.setProperties({\r\n                shape: {\r\n                    width: this.getBoundingRect().width,\r\n                    height: this.getBoundingRect().height\r\n                }\r\n            });\r\n            this._api = api;\r\n        },\r\n\r\n        setLayout: function(Layout) {\r\n            Layout.run(this);\r\n        },\r\n\r\n        getRect: function () {\r\n            var boundingRect = this.getBoundingRect();\r\n            var clipPath = this.clipPath;\r\n            // 节点裁剪后，以裁剪节点包围盒为准\r\n            if (clipPath) {\r\n                boundingRect = clipPath.getBoundingRect();\r\n            }\r\n            //创建最小包围盒虚线\r\n            var points = [];\r\n            points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n            points[1] = [boundingRect.width / 2, -boundingRect.height / 2];\r\n            points[2] = [boundingRect.width / 2, boundingRect.height / 2];\r\n            points[3] = [-boundingRect.width / 2, boundingRect.height / 2];\r\n            points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n\r\n            var boundRect = new BoundingRect(this.position[0],\r\n                this.position[1],\r\n                boundingRect.width, boundingRect.height);\r\n            return {\r\n                x: this.position[0] + boundingRect.width / 2,\r\n                y: this.position[1] + boundingRect.height / 2,\r\n                width: boundingRect.width,\r\n                height: boundingRect.height,\r\n                points: points,\r\n                boundingRect: boundRect\r\n            };\r\n        },\r\n        /**\r\n         * 拖拽组内节点的时候，动态更改背景rect的大小\r\n         * @param nodeMessage 拖拽的组内节点的信息\r\n         */\r\n        modifyGroupRect: function (nodeMessage) {\r\n            //1.重置背景rect 的长宽\r\n            var minLength = this.options.shape.r;\r\n            this.setProperties({\r\n                shape: {\r\n                    width: minLength,\r\n                    height: minLength,\r\n                    r: minLength\r\n                }\r\n            });\r\n\r\n            var rect = this.childOfName(GroupNode.RECT_NAME);\r\n            var boundingRect = this.getBoundingRect();\r\n            var width = boundingRect.width;\r\n            var height = boundingRect.height;\r\n            var rx = rect.position[0],//rect.shape.x,\r\n                ry = rect.position[1];//rect.shape.y;\r\n            //2.取group中所有节点最靠上边和最高左边的值，不包括背景rect的值\r\n            var minX = this._children[1].position[0],\r\n                minY = this._children[1].position[1];\r\n            var maxX = this._children[1].position[0],\r\n                maxY = this._children[1].position[1];\r\n            var nowNodePosition = zrUtil.clone(nodeMessage.position);\r\n            for (var i = 1; i < this._children.length; i++) {\r\n                if (this._children[i] instanceof Connector || this._children[i].isIcon == true) {\r\n                    continue;\r\n                } else {\r\n                    if (minX > this._children[i].position[0]) {\r\n                        minX = this._children[i].position[0];\r\n                    }\r\n                    if (maxX < this._children[i].position[0]) {\r\n                        maxX = this._children[i].position[0];\r\n                    }\r\n                    if (minY > this._children[i].position[1]) {\r\n                        minY = this._children[i].position[1];\r\n                    }\r\n                    if (maxY < this._children[i].position[1]) {\r\n                        maxY = this._children[i].position[1];\r\n                    }\r\n                }\r\n            }\r\n\r\n            // 3. 宽度大于最大宽度\r\n            if (width > this.max[0]) {\r\n                width = this.max[0] - 2;\r\n                if (nodeMessage.position[0] > minX) {\r\n                    nowNodePosition[0] = minX + this.max[0] - nodeMessage.width;\r\n                } else {\r\n                    nowNodePosition[0] = maxX - this.max[0] + nodeMessage.width;\r\n                }\r\n            } else {\r\n                //移动节点改变group中背景rect的x位置，不超过最小的值\r\n                rx = rect.position[0] + nodeMessage.position[0];\r\n                if (rx > minX) {\r\n                    rx = minX;\r\n                }\r\n                if (nodeMessage.isMove) { //drag\r\n                    nowNodePosition[0] = nodeMessage.movePosition[0] + nodeMessage.moveX;\r\n                } else {\r\n                    nowNodePosition[0] = nodeMessage.position;\r\n                }\r\n                if (nodeMessage.position[0] > minX) {\r\n                    if (nowNodePosition[0] > minX + this.max[0] - nodeMessage.width) {\r\n                        nowNodePosition[0] = minX + this.max[0] - nodeMessage.width;\r\n                    }\r\n                } else {\r\n                    if (nowNodePosition[0] < maxX - this.max[0] + nodeMessage.width) {\r\n                        nowNodePosition[0] = maxX - this.max[0] + nodeMessage.width\r\n                    }\r\n                }\r\n            }\r\n            if (height > this.max[1]) {\r\n                height = this.max[1] - 2;\r\n                if (nodeMessage.position[1] > minY) {\r\n                    nowNodePosition[1] = minY + this.max[1] - nodeMessage.height;\r\n                } else {\r\n                    nowNodePosition[1] = maxY - this.max[1] + nodeMessage.height;\r\n                }\r\n            } else {\r\n                //移动节点改变group中背景rect的y位置，不超过最小的值\r\n                ry = rect.position[1] + (nodeMessage.position[1]);\r\n                if (ry > minY) {\r\n                    ry = minY;\r\n                }\r\n                if (nodeMessage.isMove) {\r\n                    nowNodePosition[1] = nodeMessage.movePosition[1] + nodeMessage.moveY;\r\n                } else {\r\n                    nowNodePosition[1] = nodeMessage.position[1];\r\n                }\r\n                if (nodeMessage.position[1] > minY) {\r\n                    if (nowNodePosition[1] > minY + this.max[1] - nodeMessage.height) {\r\n                        nowNodePosition[1] = minY + this.max[1] - nodeMessage.height;\r\n                    }\r\n                } else {\r\n                    if (nowNodePosition[1] < maxY - this.max[1] + nodeMessage.height) {\r\n                        nowNodePosition[1] = maxY - this.max[1] + nodeMessage.height\r\n                    }\r\n                }\r\n            }\r\n            if (nodeMessage.node.alarm) {\r\n                var newAlarmPosition = [nowNodePosition[0] + nodeMessage.node.getBoundingRect().width - (nodeMessage.node.alarm\r\n                        .getBoundingRect().width - 6), nowNodePosition[1] - nodeMessage.node.alarm.getBoundingRect()\r\n                    .height - 3\r\n                ];\r\n                nodeMessage.node.alarm.attr(\"position\", newAlarmPosition);\r\n            }\r\n            //改变背景rect的长宽和位置\r\n            this.setProperties({\r\n                shape: {\r\n                    width: width,\r\n                    height: height,\r\n                    x: rx,\r\n                    y: ry\r\n                }\r\n            });\r\n\r\n        },\r\n\r\n        setProperties: function (opt) {\r\n            var rect = this.childOfName(GroupNode.RECT_NAME);\r\n            rect.setShape(opt.shape);\r\n           // rect.attr(\"style\", opt.style);\r\n            this.attr('position', opt.position);\r\n           // this.attr(\"shape\", opt.shape);\r\n        },\r\n\r\n        merged: function () {\r\n            var that = this;\r\n            //保留group的初始位置\r\n            var groupPosition = zrUtil.clone(this.position);\r\n            //给小图片设置属性，隐藏group\r\n            var width = this._relationImage.getBoundingRect().width;\r\n            var height = this._relationImage.getBoundingRect().height;\r\n            //计算合并后的小图片的position\r\n            var relationImagePosition = [this.position[0] + this.childOfName(GroupNode.RECT_NAME).shape.x + (this.getBoundingRect()\r\n                    .width / 2 - width / 2), this.position[1] + this.childOfName(GroupNode.RECT_NAME).shape.y +\r\n                (this.getBoundingRect().height / 2 - height / 2)\r\n            ];\r\n            //将小图片的位置保留下来\r\n            var cloneImagePosition = zrUtil.clone(relationImagePosition);\r\n            this._relationImage.attr(\"style\", {\r\n                image: this.mergedImage,\r\n                width: width,\r\n                height: height\r\n            });\r\n            this._relationImage.attr(\"position\", relationImagePosition);\r\n            if (width > 0 && height > 0) {\r\n                this.hide();\r\n                this._relationImage.show();\r\n            }\r\n\r\n            //双击图片放出组\r\n            this._relationImage.on(\"dblclick\", function () {\r\n                //设置组的位置根据小图片的偏移量来计算\r\n                that.attr('position',[groupPosition[0] + (this.position[0] -cloneImagePosition[0]),\r\n                    groupPosition[1] + (this.position[1] - cloneImagePosition[1])]);\r\n                this.hide();\r\n                that.show();\r\n            });\r\n            return this._relationImage;\r\n        },\r\n        updateShape: function (ratio, ifParse) {\r\n            var scaleRatio = Number(ratio);\r\n            var shape = this.options.shape;\r\n            var newW = Number(shape.width * scaleRatio);\r\n            var newH = Number(newW * shape.height / shape.width);\r\n            if (ifParse) {\r\n                newW = parseInt(newW, 10);\r\n                newH = parseInt(newH, 10);\r\n            }\r\n            // 按比例缩放\r\n            this.setProperties({\r\n                shape: {\r\n                    width: newW,\r\n                    height: newH\r\n                }\r\n            });\r\n            // 更新组内节点\r\n            this.children().forEach(function(v) {\r\n                var position = v.position;\r\n                if (v.name !== GroupNode.RECT_NAME && !(v instanceof Connector) && v.type !== 'ZPath') {\r\n                    // 每个节点的position更新\r\n                    v.updateShape(ratio, ifParse);\r\n                    v.attr('position', [position[0] * scaleRatio, position[1] * scaleRatio]);\r\n                } else if (v.type === 'ZPath') {\r\n                    var rect = v.rect;\r\n                    rect.height = rect.height * scaleRatio;\r\n                    rect.width = rect.width * scaleRatio;\r\n                    v.attr({\r\n                        position: [position[0] * scaleRatio, position[1] * scaleRatio],\r\n                        rect: rect\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    zrUtil.inherits(GroupNode, graphic.Group);\r\n    module.exports = GroupNode;\r\n\r\n/**\r\n * @method add\r\n * 将节点加入到这个组中最后\r\n * @param {Object} node 欲添加到组的节点\r\n */\r\n/**\r\n * @method removeAll\r\n * 移除所有子节点\r\n */\r\n\r\n/**\r\n * @method remove\r\n * 移除所有子节点\r\n * @param {Object} child 子节点\r\n */\r\n/**\r\n * @method childOfName\r\n * 获取指定名字的儿子节点\r\n * @param {String} name\r\n * @return {Object} 节点\r\n */\r\n/**\r\n * @method traverse\r\n * 深度优先遍历所有子孙节点（each只遍历子节点）\r\n * @param {String} name\r\n * @return {Object} 节点\r\n */\r\n\r\n/**\r\n * @cfg {String} mergedImage=''  控制当双击时 组可以缩小为指定的图形。\r\n */\r\n\r\n/**\r\n * @cfg {Boolean} childDraggable=false  控制组内成员是否可以拖动\r\n */\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/GroupNode.js\n// module id = 95\n// module chunks = 0","'use strict';\n/**\r\n * fishTopoFlow的node对象，框架提供的节点都放在这个对象下。通过extend方法创建自定义节点<br>\r\n * @class fishTopoFlow.node\r\n * @abstract\r\n *\r\n    * **使用范例**：\r\n    *\r\n    *      @example\r\n    *       var node = fishTopoFlow.node;\r\n    *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n    *      var Diamond = node.extend({\r\n    *          type: 'Diamond',\r\n    *          shape: {\r\n    *              width: 0,\r\n    *              height: 0\r\n    *          },\r\n    *          buildPath: function (path, shape) {\r\n    *              var cx = 0;\r\n    *              var cy = 0;\r\n    *              var width = shape.width / 2;\r\n    *              var height = shape.height / 2;\r\n    *              path.moveTo(cx, cy - height);\r\n    *              path.lineTo(cx + width, cy);\r\n    *              path.lineTo(cx, cy + height);\r\n    *              path.lineTo(cx - width, cy);\r\n    *              path.closePath();\r\n    *          }\r\n    *      });\r\n    *        var diamod = new Diamond({\r\n    *            shape: {\r\n    *                width:50,\r\n    *                height:50\r\n    *            },\r\n    *            position:[60,60]\r\n    *        })\r\n    *        fishTopo.add(diamod);\r\n */\r\n\r\n    var Path = require('zrender/lib/graphic/Path');\r\n    var Constants = require(\"../util/FlowConstants.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var util = require(\"../../../fish-topo-core/lib/util.js\");\r\n    var Model = require(\"../../../fish-topo-core/lib/model.js\");\r\n    var flowNode = {};\r\n    /**\r\n     * 构造模型\r\n     * @private\r\n     */\r\n    flowNode.genModel = function (type, opts) {\r\n        var model = new Model({});\r\n        // 没有id的时候，缺少给一个UUID。创建节点或者反序列化的时候 节点的ID取的是opts.id\r\n\t\tif (!opts.id) {\r\n\t\t\topts.id = util.getUUID();\r\n        }\r\n        if (opts.style && opts.style.textLineHeight !== 0 && !opts.style.rich) { //#170\r\n            opts.style.rich = {};\r\n        }\r\n        model.set(Constants.ELEMENT_TYPE, type);\r\n        // 防止 new el.constructor({ style: el.style,shape: el.shape }); zrUtil.clone报错\r\n        if (opts.style && opts.style.host) {\r\n            delete opts.style.host;\r\n        }\r\n        model.set(Constants.OPTIONS, zrUtil.clone(opts));\r\n        if (\"draggable\" in opts) {\r\n            opts.isdraggable = opts.draggable;\r\n            delete opts.draggable;\r\n        }\r\n        if (!opts.z) {\r\n            opts.z = 1; //节点默认为1，线段0;\r\n        }\r\n\r\n        if (util.isUndefined(opts.hoverAnimation)) {\r\n            opts.hoverAnimation = false;\r\n        }\r\n\r\n        if (util.isUndefined(opts.selectable)) {\r\n            opts.selectable = true;  //默认可以选中\r\n        }\r\n        return model;\r\n    }\r\n\r\n    flowNode.addHoverAnimation = function(node) {\r\n        var scale = zrUtil.clone(node.scale) || [1,1];\r\n        var onEmphasis = function() {\r\n            this.animateTo({\r\n                scale: [scale[0] * 1.1, scale[1] * 1.1]\r\n            }, 400, 'elasticOut');\r\n        };\r\n        var onNormal = function() {\r\n            this.animateTo({\r\n                scale: scale\r\n            }, 400, 'elasticOut');\r\n        };\r\n        node.on('mouseover', onEmphasis)\r\n            .on('mouseout', onNormal)\r\n            .on('emphasis', onEmphasis)\r\n            .on('normal', onNormal);\r\n    }\r\n\r\n    /**\r\n     * @method extend\r\n     * 扩展一个 自定义节点, 比如钻石形等。\r\n     * @param {Object} props\r\n     * @param {string} props.type 自定义结节的名称 Path type\r\n     * @param {Function} [props.init] 初始化 Initialize\r\n     * @param {Function} props.buildPath 进行构建节点 Overwrite buildPath method\r\n     * @param {Object} [props.style] 缺省样式 Extended default style config\r\n     * @param {Object} [props.shape] 缺省节点参数 Extended default shape config\r\n     *\r\n     */\r\n    flowNode.extend = function (defaults) {\r\n        var Sub = function (opts) {\r\n            this.model = flowNode.genModel(defaults.type, opts);\r\n            Path.call(this, opts);\r\n\r\n            if (defaults.style) {\r\n                // Extend default style\r\n                this.style.extendFrom(defaults.style, false);\r\n            }\r\n\r\n            // Extend default shape\r\n            var defaultShape = defaults.shape;\r\n            if (defaultShape) {\r\n                this.shape = this.shape || {};\r\n                var thisShape = this.shape;\r\n                for (var name in defaultShape) {\r\n                    if (\r\n                        !thisShape.hasOwnProperty(name)\r\n                        && defaultShape.hasOwnProperty(name)\r\n                    ) {\r\n                        thisShape[name] = defaultShape[name];\r\n                    }\r\n                }\r\n            }\r\n\r\n            defaults.init && defaults.init.call(this, opts);\r\n\r\n        };\r\n\r\n        zrUtil.inherits(Sub, Path);\r\n\r\n        // FIXME 不能 extend position, rotation 等引用对象\r\n        for (var name in defaults) {\r\n            // Extending prototype values and methods\r\n            if (name !== 'style' && name !== 'shape') {\r\n                Sub.prototype[name] = defaults[name];\r\n            }\r\n        }\r\n        // 重写setStyle\r\n        Sub.prototype.setStyle = function(key, value) {\r\n            this.style.set(key, value);\r\n            this.dirty(false);\r\n            zrUtil.merge(this.model.get(\"options.style\"), key, true);\r\n            return this;\r\n        }\r\n\r\n        return Sub;\r\n    };\r\n    module.exports = flowNode;\r\n\r\n\r\n/**\r\n * @cfg {Array} position 节点的位置,统一使用position进行定位[x,y] eg. [100,100]\r\n */\r\n\r\n/**\r\n * @cfg {Object} style 样式参数\r\n * @cfg {string} style.fill=#000 填充色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red | gradient 注：单独文字使用textFill\r\n * @cfg {string} style.stroke=null 笔画颜色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red | gradient 注：单独文字使用textStoke\r\n * @cfg {number} style.lineWidth=1 笔画宽度\r\n * @cfg {Array} style.lineDash=null 笔画的虚线间隔，参数为交替绘制线段和间距长度的数字 参见[lineDashOffset](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/setLineDash) eg. lineDash:[6,10]\r\n * @cfg {number} style.lineDashOffset=0  笔画的虚线偏移量 参见[lineDashOffset](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineDashOffset)\r\n * @cfg {string} style.text=\"\" 节点上显示的文本,可以使用 \\n 来换行\r\n * @cfg {string} style.textFont='12px sans-serif' 字体大小、字体类型、粗细、字体样式。格式参见[css font](https://developer.mozilla.org/en-US/docs/Web/CSS/font) eg.textFont: 'italic bolder 14px Microsoft YaHei'\r\n * @cfg {string} style.fontStyle=null 字体样式\r\n * @cfg {string} style.fontWeight=#000 字体粗细\r\n * @cfg {number} style.fontSize=null 字体大小\r\n * @cfg {string} style.fontFamily=null 字体类型\r\n * @cfg {string} style.textFill=#000 节点上文本的填充色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red\r\n * @cfg {string} style.textStoke=null 节点上文本的描边色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red\r\n * @cfg {string|Array} style.textPosition=\"\" 文本在节点中的位置left|right|top|bottom|inside|insideLeft|insideRight|insideTop|insideBottom|insideTopLeft|insideTopRight|insideBottomLeft|insideBottomRight|[x,y]|[%,%]\r\n * @cfg {string} style.textBaseline=\"alphabetic\" 当前文本基线的属性 \"top\" || \"hanging\" || \"middle\" || \"alphabetic\" || \"ideographic\" || \"bottom\" 参见[css font](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/textBaseline)\r\n * @cfg {Array} style.textOffset=null 文本在节点的偏移值[x,y] eg. [10,10]\r\n * @cfg {string} style.textAlign=\"\" 文本在节点中的对齐方式 left | center | right\r\n * @cfg {string} style.textVerticalAlign=null 文本在节点中的垂直对齐方式 top | middle | bottom\r\n * @cfg {number} style.textDistance=5 文字的相对textPos的偏移量 eg. textPosition='left' textDistance=5 则文字的x坐标的值为 (left的坐标x值) -5\r\n * @cfg {string} style.textShadowColor='transparent' 文字阴影颜色\r\n * @cfg {number} style.textShadowBlur=0 文本阴影宽度 参见[shadowBlur](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowBlur)\r\n * @cfg {number} style.textShadowOffsetX=0 文本阴影 X 方向偏移 参见shadowOffsetX[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetX]\r\n * @cfg {number} style.textShadowOffsetY=0 文本阴影 Y 方向偏移 参见shadowOffsetY[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetY]\r\n * @cfg {number} style.textRotation=0 文本旋转的角度\r\n * @cfg {number} style.textBorderWidth=0 文字描边宽度\r\n * @cfg {string} style.textBorderColor=null 文字描边颜色\r\n * @cfg {number} style.textBorderRadius=0 文字描边半径\r\n * @cfg {string|Object} style.textBackgroundColor=null 文字背景(颜色或图片) eg. '#333' | {image:'./asset/img/clund.png'}\r\n * @cfg {number|Array} style.textPadding=null 文字padding  eg. `2` or `[2, 4]` or `[2, 3, 4, 5]`\r\n * @cfg {Object} style.rich=null 富文本样式属性\r\n * @cfg {number} style.textLineHeight=0 文字的行高\r\n * @cfg {number} style.opacity=1 图形透明度。支持从 0 到 1 的数字，为 0 时不绘制该图形。\r\n * @cfg {number} style.shadowBlur=0 阴影宽度 参见[shadowBlur](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowBlur)\r\n * @cfg {number} style.shadowOffsetX=0 阴影 X 方向偏移 参见shadowOffsetX[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetX]\r\n * @cfg {number} style.shadowOffsetY=0 阴影 Y 方向偏移 参见shadowOffsetY[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetY]\r\n * @cfg {string} style.shadowColor='#000' 阴影颜色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red 参见[shadowColor](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowColor)\r\n * @cfg {string} style.image=\"\" 图片的路径 用于Image\r\n * @cfg {number} style.width 图片的宽度 用于Image\r\n * @cfg {number} style.height 图片的高度 用于Image\r\n */\r\n\r\n /**\r\n * @cfg {Object} hoverStyle hover样式, 参数见style\r\n  */\r\n /**\r\n * @cfg {Object} selectStyle 选中节点的样式, 参数见style;  默认是一个虚的边框;  设为空对象则不显示选中边框;\r\n*/\r\n/**\r\n * @cfg {Boolean} draggable=true 是否可以被拖拽。\r\n */\r\n\r\n/**\r\n * @cfg {Boolean} ignore=false 是否隐藏状态（只读），fasle:隐藏,true:不隐藏\r\n */\r\n\r\n/**\r\n * @cfg {Boolean} selectable=true 节点是否可选中，默认是true\r\n */\r\n\r\n/**\r\n * @cfg {String} id 为了避免重复，目前由系统自动生成，如果不需要用可以忽略。建议使用nmae\r\n */\r\n\r\n/**\r\n *  @cfg {Boolean} hoverAnimation=false 是否开启 hover 在节点上的提示动画效果。，默认是false\r\n */\r\n\r\n/**\r\n * @cfg {String} name 指定节点的name, 可以使用childOfName等函数根据name查找节点\r\n */\r\n\r\n/**\r\n * @cfg {String} tooltip 节点的tooltip 内容可以包括HTML标签\r\n */\r\n\r\n/**\r\n * @cfg {Object} relative relative描述怎么根据父元素进行定位，设置了relative属性 就不需要设置position。支持：left、right、top、bottom\r\n * @cfg {Number|String} relative.left  距离父元素左边的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.left 和 right 只有一个可以生效。\r\n * @cfg {Number|String} relative.right  距离父元素右边的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.left 和 right 只有一个可以生效。\r\n * @cfg {Number|String} relative.top  距离父元素顶部的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.top 和 bottom 只有一个可以生效。\r\n * @cfg {Number|String} relative.bottom  距离父元素底部的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.top 和 bottom 只有一个可以生效。\r\n * @cfg {String} [bounding='all'] 决定此图形元素在定位时，对自身的包围盒计算方式。 1.'all'：（默认） 表示用自身以及子节点整体的经过 transform 后的包围盒进行定位。 这种方式易于使整体都限制在父元素范围中。2.'raw'： 表示仅仅用自身（不包括子节点）的没经过 tranform 的包围盒进行定位。 这种方式易于内容超出父元素范围的定位方式。\r\n */\r\n\r\n/**\r\n * @cfg {Array} scale 节点的缩放因子, [x,y] 水平与垂直方向的 eg. [1,1]\r\n */\r\n\r\n/**\r\n * @cfg {number} rotation 节点的旋转因子, 单位是角度 eg. 0.5* Math.PI\r\n */\r\n\r\n/**\r\n * @cfg {Array} origin 旋转和缩放的原点, [x,y] eg. [75,75]\r\n */\r\n\r\n/**\r\n * @cfg {number} z=0  z方向的高度，决定层叠关系。类似css zIndex\r\n */\r\n\r\n/**\r\n * @cfg {number} zlevel=0  决定此元素绘制在哪个 canvas 层中。注意，越多 canvas 层会占用越多资源。\r\n */\r\n\r\n/**\r\n * @cfg {Boolean} silent=false  是否不响应鼠标以及触摸事件。\r\n */\r\n/**\r\n * @cfg {Boolean} invisible=false  节点是否可见。\r\n */\r\n\r\n/**\r\n * @cfg {Object} parent  节点的父元素\r\n */\r\n/**\r\n * @cfg {Object} operationIcons  节点操作为选中的节点，提供默认操作或用户自定义操作。\r\n * @cfg {String} operationIcons.name 设置节点名称，可选值有constants.DEL(删除)，constants.LINK（直线），constants.FOLD（折线），constants.CURVE(曲线)，以及自定义名称\r\n * @cfg {String} operationIcons.iconPath 设置自定义节点图标路径\r\n * @cfg {Function} operationIcons.callback 设置节点被点击（click）的回调函数\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var image1 = new node.Image({\r\n *           style: {\r\n *               image: \"img/img-cic/icon-send-sms.svg\",\r\n *               width:120,\r\n *               height:70,\r\n *               text:\"操作:线段\",\r\n *               textPosition:\"insideBottom\"\r\n *           },\r\n *           position:[60,60],\r\n *           operationIcons: [\r\n *               { name: constants.LINK} ,\r\n *               { name: constants.FOLD },\r\n *               { name: constants.CURVE }\r\n *           ]\r\n *       });\r\n */\r\n\r\n/**\r\n * @property {Object} states\r\n * 用于设置节点的状态\r\n */\r\n\r\n\r\n/**\r\n * @property {Object} model\r\n * 节点的模型，用于存储序列化数据 以及用户自定义数据\r\n */\r\n\r\n/**\r\n * @method attr\r\n * 设置节点属性\r\n * @param {String|Object} key 设置的属性。可以是 string 类型的属性名称，或者 Object 类型的属性及其值\r\n * @param {*} 属性值\r\n * **使用范例**\r\n *\r\n * @example\r\n *\r\n * node.attr('position', [100, 200]);\r\n * node.attr({\r\n *     style: {\r\n *         fill: 'red'\r\n *     },\r\n *     shape: {\r\n *         x: 100\r\n *     }\r\n * });\r\n */\r\n\r\n/**\r\n * @method setStyle\r\n * 创建节点后，设置节点的样式（style属性）\r\n * @param {String} key 键名\r\n * @param {*} value 键值\r\n * @return {Object} 返回节点对象自身\r\n */\r\n\r\n/**\r\n * @method setShape\r\n * 创建节点后，设置节点的形状（shape属性）\r\n * @param {String} key 键名\r\n * @param {*} value 键值\r\n * @return {Object} 返回节点对象自身\r\n */\r\n\r\n/**\r\n * @method hide\r\n * 隐藏节点\r\n */\r\n\r\n/**\r\n * @method show\r\n * 显示节点\r\n */\r\n\r\n\r\n/**\r\n * @method on\r\n * 绑定事件\r\n * @param {String} event 事件名\r\n * @param {Function} handler 事件处理函数\r\n * @param {Object} [context] 上下文\r\n */\r\n\r\n/**\r\n * @method off\r\n * 解绑事件\r\n * @param {String} event 事件名\r\n * @param {Function} handler 事件处理函数\r\n */\r\n\r\n/**\r\n * @method one\r\n * 单次触发绑定,trigger后销毁\r\n * @param {String} event 事件名\r\n * @param {Function} handler 事件处理函数\r\n * @param {Object} [context] 上下文\r\n */\r\n\r\n/**\r\n * @method trigger\r\n * 事件分发\r\n * @param {String} type 事件类型\r\n */\r\n\r\n/**\r\n * @method isSilent\r\n * 是否绑定了事件\r\n * @param {String} event 事件名\r\n * @return {boolean}\r\n */\r\n\r\n/**\r\n * @method animate\r\n * 动画\r\n * @param {String} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性\r\n * @param {Boolean} [loop] 动画是否循环\r\n * @return {Object} 返回Animator对象\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *      el.animate('style', false)\r\n *         .when(1000, {x: 10} )\r\n *         .done(function(){ // Animation done })\r\n *         .start()\r\n */\r\n\r\n/**\r\n * @method stopAnimation\r\n * 停止动画\r\n * @param {boolean} forwardToLast 是否在停止前移动到最后一帧\r\n */\r\n\r\n/**\r\n * @method animateTo\r\n * 从一动属性过渡到另一种属性的动画\r\n * @param {Object} target 目前属性\r\n * @param {number} [time=500] 动画时间 单位ms\r\n * @param {string} [easing='linear'] 动画函数 参见[缓动示例](http://echarts.baidu.com/gallery/editor.html?c=line-easing)\r\n * @param {number} [delay=0] 延时时间\r\n * @param {Function} [callback] 动画结束回调\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *          // Animate position\r\n *          el.animateTo({\r\n *              position: [10, 10]\r\n *          }, function () { // done })\r\n *\r\n *          // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\r\n *          el.animateTo({\r\n *              shape: {\r\n *                  width: 500\r\n *              },\r\n *              style: {\r\n *                  fill: 'red'\r\n *              }\r\n *              position: [10, 10]\r\n *          }, 100, 100, 'cubicOut', function () { // done })\r\n */\r\n\r\n/**\r\n * @event click\r\n * 单击事件\r\n * @param {Object} event 事件\r\n * @param {Object} event.target 目标对象\r\n * @param {Object} event.event 实际的浏览器事件对象\r\n * <pre>\r\n * node.on('click', function(event) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n/**\r\n * @event dblclick\r\n * 当双击元素时，会发生 dblclick 事件。\r\n * @param {Object} event 事件\r\n * @param {Object} event.target 目标对象\r\n * @param {Object} event.event 实际的浏览器事件对象\r\n * <pre>\r\n * node.on('dblclick', function(event) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n/**\r\n * @event mouseover\r\n * 当鼠标指针位于元素上方时，会发生 mouseover 事件\r\n * @param {Object} event 事件\r\n * @param {Object} event.target 目标对象\r\n * @param {Object} event.event 实际的浏览器事件对象\r\n * <pre>\r\n * node.on('mouseover', function(event) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n/**\r\n * @event mouseout\r\n * 当鼠标指针从元素上移开时，发生 mouseout 事件。\r\n * @param {Object} event 事件\r\n * @param {Object} event.target 目标对象\r\n * @param {Object} event.event 实际的浏览器事件对象\r\n * <pre>\r\n * node.on('mouseout', function(event) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n\r\n/**\r\n * @event mousemove\r\n * 当鼠标指针在指定的元素中移动时，就会发生 mousemove 事件\r\n * @param {Object} event 事件\r\n * @param {Object} event.target 目标对象\r\n * @param {Object} event.event 实际的浏览器事件对象\r\n * <pre>\r\n * node.on('mousemove', function(event) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n\r\n/**\r\n * @event mousewheel\r\n * 当用户在指定的元素时滚动鼠标滑轮时,就会发生 mousewheel事件\r\n * @param {Object} event 事件\r\n * @param {Object} event.target 目标对象\r\n * @param {Object} event.event 实际的浏览器事件对象\r\n * <pre>\r\n * node.on('mousewheel', function(event) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n\r\n/**\r\n * @event mousedown\r\n * 当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件\r\n * @param {Object} event 事件\r\n * @param {Object} event.target 目标对象\r\n * @param {Object} event.event 实际的浏览器事件对象\r\n * <pre>\r\n * node.on('mousedown', function(event) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n\r\n/**\r\n * @event mouseup\r\n * 当在元素上放松鼠标按钮时，会发生 mouseup 事件。\r\n * @param {Object} event 事件\r\n * @param {Object} event.target 目标对象\r\n * @param {Object} event.event 实际的浏览器事件对象\r\n * <pre>\r\n * node.on('mouseup', function(event) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n/**\r\n * @event contextmenu\r\n * 当在元素上点击鼠标右键时，会发生 contextmenu 事件。\r\n * @param {Object} event 事件\r\n * @param {Object} event.target 目标对象\r\n * @param {Object} event.event 实际的浏览器事件对象，如果想阻止默认的浏览器右键菜单请使用 event.event.preventDefault(); event.event.stopPropagation();\r\n\r\n * <pre>\r\n * node.on('contextmenu', function(event) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n/**\r\n * @event dragstart\r\n * 当开始拖动节点的时候，会发生 dragstart 事件。\r\n *\r\n * <pre>\r\n * node.on('dragstart', function(e) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n\r\n/**\r\n * @event drag\r\n * 当拖动节点的时候，会发生 drag 事件。\r\n *\r\n * <pre>\r\n * node.on('drag', function(e) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n/**\r\n * @event dragend\r\n * 当拖动节点结束的时候，会发生 dragend 事件。\r\n *\r\n * <pre>\r\n * node.on('dragend', function(e) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/flowNode.js\n// module id = 96\n// module chunks = 0","/**\r\n * 矩形<br>\r\n * @class fishTopoFlow.node.Rect\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var rect = new node.Rect({\r\n *           shape:{width:100,height:60},\r\n *           position:[20,20]\r\n *       });\r\n *       fishTopo.add(rect);\r\n */\r\n\r\n    var roundRectHelper = require('zrender/lib/graphic/helper/roundRect');\r\n\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Rect',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Array} shape.points=null 拆线点的坐标 可以从AI中获取。\r\n         * @cfg {Number|String|Boolean} [shape.smooth=false] 是否平滑曲线显示。如果为 number：表示贝塞尔 (bezier) 差值平滑，smooth 指定了平滑等级，范围 [0, 1];如果为 'spline'：表示 Catmull-Rom spline 差值平滑\r\n         * @cfg {Number} shape.smoothConstraint=null 是否将平滑曲线约束在包围盒中。smooth 为 number（bezier）时生效\r\n         */\r\n        shape: {\r\n            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\r\n            // r缩写为1         相当于 [1, 1, 1, 1]\r\n            // r缩写为[1]       相当于 [1, 1, 1, 1]\r\n            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\r\n            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\r\n            x: 0,\r\n            y: 0,\r\n            r: 0,\r\n            width: 50,\r\n            height: 50\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var x = 0;\r\n            var y = 0;\r\n            var width = shape.width;\r\n            var height = shape.height;\r\n            if (!shape.r) {\r\n                ctx.rect(x, y, width, height);\r\n            }\r\n            else {\r\n                roundRectHelper.buildPath(ctx, shape);\r\n            }\r\n            ctx.closePath();\r\n        },\r\n        updateShape: function (ratio, ifParse) {\r\n            var scaleRatio = Number(ratio);\r\n            var shape = this.shape;\r\n            var newW = Number(shape.width * scaleRatio);\r\n            var newH = Number(newW * shape.height / shape.width);\r\n            if (ifParse) {\r\n                newW = parseInt(newW, 10);\r\n                newH = parseInt(newH, 10);\r\n            }\r\n            // 按比例缩放\r\n            this.setShape({\r\n                width: newW,\r\n                height: newH\r\n            });\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Rect.js\n// module id = 97\n// module chunks = 0","'use strict';\n/**\r\n * 圆形<br>\r\n * @class fishTopoFlow.node.Circle\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var circle = new node.Circle({\r\n *           shape:{r:24},\r\n *           position:[60,60]\r\n *       });\r\n *       fishTopo.add(circle);\r\n */\r\n\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Circle',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.r=20 半径。\r\n         */\r\n        shape: {\r\n            r: 20\r\n        },\r\n\r\n        buildPath : function (ctx, shape, inBundle) {\r\n            // Better stroking in ShapeBundle\r\n            // Always do it may have performence issue ( fill may be 2x more cost)\r\n            if (inBundle) {\r\n                ctx.moveTo(shape.r, 0);\r\n            }\r\n            // Better stroking in ShapeBundle\r\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\r\n            ctx.arc(0, 0, shape.r, 0, Math.PI * 2, true);\r\n        },\r\n        updateShape: function (ratio, ifParse) {\r\n            var scaleRatio = Number(ratio);\r\n            var shape = this.shape;\r\n            var newR = Number(shape.r * scaleRatio);\r\n            if (ifParse) {\r\n                newR = parseInt(newR, 10);\r\n            }\r\n            // 按比例缩放\r\n            this.setShape({\r\n                r: newR\r\n            });\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Circle.js\n// module id = 98\n// module chunks = 0","/**\r\n * 图片节点<br>\r\n * @class fishTopoFlow.node.Image\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var image = new node.Image({\r\n *           style: {\r\n *               image: \"../../examples/flow/img/img-cic/start.svg\",\r\n *               width:120,\r\n *               height:70,\r\n *               text:\"Event Name\"\r\n *           },\r\n *           position:[60,60]\r\n *       });\r\n *       fishTopo.add(image);\r\n */\r\n\r\n\r\n    var Displayable = require('zrender/lib/graphic/Displayable');\r\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var flowNode = require('./flowNode');\r\n    var LRU = require('zrender/lib/core/LRU');\r\n    var globalImageCache = new LRU(50);\r\n\r\n\r\n    function ZImage(opts) {\r\n        this.model = flowNode.genModel(\"Image\", opts);\r\n        Displayable.call(this, opts);\r\n\r\n        if (window.jQuery) {   //判断jQuery是否存在\r\n            this.resultDeferrd = jQuery.Deferred();\r\n            this.result = this.resultDeferrd.promise();\r\n        }\r\n    }\r\n\r\n    ZImage.prototype = {\r\n\r\n        constructor: ZImage,\r\n\r\n        type: 'Image',\r\n\r\n        brush: function (ctx, prevEl) {\r\n            var style = this.style;\r\n            var src = style.image;\r\n            var image;\r\n\r\n            // Must bind each time\r\n            style.bind(ctx, this, prevEl);\r\n            // style.image is a url string\r\n            if (typeof src === 'string') {\r\n                image = this._image;\r\n                if (image && image.src !== src) { //#171\r\n                    image = null;\r\n                }\r\n            }\r\n            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\r\n            else {\r\n                image = src;\r\n                image.isLoaded = true;\r\n            }\r\n            // FIXME Case create many images with src\r\n            if (!image && src) {\r\n                // Try get from global image cache\r\n                var cachedImgObj = globalImageCache.get(src);\r\n                if (!cachedImgObj) {\r\n                    // Create a new image\r\n                    image = new Image();\r\n                    image.isLoaded = false;\r\n                    image.onload = function () {\r\n                        image.isLoaded = true;\r\n                        image.onload = null;\r\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\r\n                            cachedImgObj.pending[i].dirty();\r\n                        }\r\n                    };\r\n                    cachedImgObj = {\r\n                        image: image,\r\n                        pending: [this]\r\n                    };\r\n                    image.src = src;\r\n                    globalImageCache.put(src, cachedImgObj);\r\n                    this._image = image;\r\n                    return;\r\n                }\r\n                else {\r\n                    image = cachedImgObj.image;\r\n                    this._image = image;\r\n                    // Image is not complete finish, add to pending list  如果使用的svg图片, IE11下就算加载成功image.width, image.height也都是为0\r\n                    if ((!image.width || !image.height) && (!image.src.endsWith(\"svg\"))) {\r\n                        cachedImgObj.pending.push(this);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (image) {\r\n                // 图片已经加载完成\r\n                // if (image.nodeName.toUpperCase() == 'IMG') {\r\n                //     if (!image.complete) {\r\n                //         return;\r\n                //     }\r\n                // }\r\n                // Else is canvas\r\n\r\n                var x = style.x || 0;\r\n                var y = style.y || 0;\r\n                // 如果使用的svg图片, IE11下就算加载成功image.width, image.height也都是为0\r\n                //此处如不注释, 会导致IE11下svg图片无法使用\r\n                // 图片加载失败\r\n                // if (!image.width || !image.height) {\r\n                //     return;\r\n                // }\r\n                if (!image.isLoaded) {\r\n                    if (window.jQuery) {\r\n                        this.resultDeferrd.reject(image);\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                var width = style.width;\r\n                var height = style.height;\r\n                var aspect = image.width / image.height;\r\n                if (width == null && height != null) {\r\n                    // Keep image/height ratio\r\n                    width = height * aspect;\r\n                }\r\n                else if (height == null && width != null) {\r\n                    height = width / aspect;\r\n                }\r\n                else if (width == null && height == null) {\r\n                    width = image.width;\r\n                    height = image.height;\r\n                }\r\n\r\n                // 设置transform\r\n                this.setTransform(ctx);\r\n\r\n                if (style.sWidth && style.sHeight) {\r\n                    var sx = style.sx || 0;\r\n                    var sy = style.sy || 0;\r\n                    ctx.drawImage(\r\n                        image,\r\n                        sx, sy, style.sWidth, style.sHeight,\r\n                        x, y, width, height\r\n                    );\r\n                }\r\n                else if (style.sx && style.sy) {\r\n                    var sx2 = style.sx;\r\n                    var sy2 = style.sy;\r\n                    var sWidth = width - sx2;\r\n                    var sHeight = height - sy2;\r\n                    ctx.drawImage(\r\n                        image,\r\n                        sx2, sy2, sWidth, sHeight,\r\n                        x, y, width, height\r\n                    );\r\n                }\r\n                else {\r\n                    ctx.drawImage(image, x, y, width, height);\r\n                }\r\n                // 如果没设置宽和高的话自动根据图片宽高设置\r\n                if (style.width == null) {\r\n                    style.width = width;\r\n                }\r\n                if (style.height == null) {\r\n                    style.height = height;\r\n                }\r\n\r\n                this.restoreTransform(ctx);\r\n\r\n                // Draw rect text\r\n                if (style.text != null) {\r\n                    this.drawRectText(ctx, this.getBoundingRect());\r\n                }\r\n                if (window.jQuery) {\r\n                    this.resultDeferrd.resolve(image);\r\n                }\r\n            }\r\n        },\r\n\r\n        getBoundingRect: function () {\r\n            var style = this.style;\r\n            if (! this._rect) {\r\n                this._rect = new BoundingRect(\r\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\r\n                );\r\n            }\r\n            return this._rect;\r\n        },\r\n        updateShape: function (ratio, ifParse) {\r\n            var scaleRatio = Number(ratio);\r\n            var style = this.style;\r\n            var newW = Number(style.width * scaleRatio);\r\n            var newH = Number(newW * style.height / style.width);\r\n            if (ifParse) {\r\n                newW = parseInt(newW, 10);\r\n                newH = parseInt(newH, 10);\r\n            }\r\n            // 按比例缩放\r\n            this.setStyle({\r\n                width: newW,\r\n                height: newH\r\n            });\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(ZImage, Displayable);\r\n\r\n    module.exports = ZImage;\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Image.js\n// module id = 99\n// module chunks = 0","/**\r\n * 文本<br>\r\n * @class fishTopoFlow.node.Text\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n *       var text = new node.Text({\r\n *           style:{text:\"文本也可以作为独立的节点进行拖拽\",fill:\"#ff0000\", textFont:\"16px Microsoft YaHei\"},\r\n *           position:[60,60]\r\n *       });\r\n *       fishTopo.add(text);\r\n */\r\n\r\n    var Text = require('zrender/lib/graphic/Text');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var flowNode = require('./flowNode');\r\n    function ZText(opts) {\r\n        var defaultOptions = {\r\n            style:{textBaseline:\"top\"}   // 默认值  这样选中时的框才正确\r\n        };\r\n        var options = zrUtil.merge(defaultOptions, opts, true);\r\n        this.model = flowNode.genModel(\"Text\", options);\r\n        Text.call(this, options);\r\n    }\r\n\r\n    ZText.prototype = {\r\n        constructor: ZText,\r\n\r\n        type: 'Text',\r\n\r\n        updateShape: function () {\r\n            \r\n        }\r\n    }\r\n    zrUtil.inherits(ZText, Text);\r\n    module.exports = ZText;\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Text.js\n// module id = 100\n// module chunks = 0","/**\r\n * 扇形<br>\r\n * @class fishTopoFlow.node.Sector\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n *       var sector = new node.Sector({\r\n *           shape: {r:30, startAngle:0, endAngle:Math.PI * 0.5}, // startAngle\\endAngle是弧度单位\r\n *           position:[60,60]\r\n *       });\r\n *       fishTopo.add(sector);\r\n */\r\n\r\n    var env = require('zrender/lib/core/env');\r\n    var Path = require('zrender/lib/graphic/Path');\r\n\r\n    var shadowTemp = [\r\n        ['shadowBlur', 0],\r\n        ['shadowColor', '#000'],\r\n        ['shadowOffsetX', 0],\r\n        ['shadowOffsetY', 0]\r\n    ];\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Sector',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.r=0 外半径。\r\n         * @cfg {Number} shape.r0=0 内半径。\r\n         * @cfg {Number} shape.startAngle=0 开始弧度。\r\n         * @cfg {Number} shape.endAngle=Math.PI * 2  结束弧度。\r\n         * @cfg {Boolean} shape.clockwise=true 是否顺时针。\r\n         */\r\n        shape: {\r\n            cx: 0,\r\n\r\n            cy: 0,\r\n\r\n            r0: 0,\r\n\r\n            r: 0,\r\n\r\n            startAngle: 0,\r\n\r\n            endAngle: Math.PI * 2,\r\n\r\n            clockwise: true\r\n        },\r\n\r\n        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'\r\n            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),\r\n            // where exception \"unexpected call to method or property access\"\r\n            // might be thrown when calling ctx.fill after a path whose area size\r\n            // is zero is drawn and ctx.clip() is called and shadowBlur is set.\r\n            // (e.g.,\r\n            //  ctx.moveTo(10, 10);\r\n            //  ctx.lineTo(20, 10);\r\n            //  ctx.closePath();\r\n            //  ctx.clip();\r\n            //  ctx.shadowBlur = 10;\r\n            //  ...\r\n            //  ctx.fill();\r\n            // )\r\n            ? function () {\r\n                var clipPaths = this.__clipPaths;\r\n                var style = this.style;\r\n                var modified;\r\n\r\n                if (clipPaths) {\r\n                    for (var i = 0; i < clipPaths.length; i++) {\r\n                        var shape = clipPaths[i] && clipPaths[i].shape;\r\n                        if (shape && shape.startAngle === shape.endAngle) {\r\n                            for (var j = 0; j < shadowTemp.length; j++) {\r\n                                shadowTemp[j][2] = style[shadowTemp[j][0]];\r\n                                style[shadowTemp[j][0]] = shadowTemp[j][1];\r\n                            }\r\n                            modified = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                Path.prototype.brush.apply(this, arguments);\r\n\r\n                if (modified) {\r\n                    for (var k = 0; k < shadowTemp.length; k++) {\r\n                        style[shadowTemp[k][0]] = shadowTemp[k][2];\r\n                    }\r\n                }\r\n            }\r\n            : Path.prototype.brush,\r\n\r\n        buildPath: function (ctx, shape) {\r\n\r\n            var x = shape.cx;\r\n            var y = shape.cy;\r\n            var r0 = Math.max(shape.r0 || 0, 0);\r\n            var r = Math.max(shape.r, 0);\r\n            var startAngle = shape.startAngle;\r\n            var endAngle = shape.endAngle;\r\n            var clockwise = shape.clockwise;\r\n\r\n            var unitX = Math.cos(startAngle);\r\n            var unitY = Math.sin(startAngle);\r\n\r\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\r\n\r\n            ctx.lineTo(unitX * r + x, unitY * r + y);\r\n\r\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\r\n\r\n            ctx.lineTo(\r\n                Math.cos(endAngle) * r0 + x,\r\n                Math.sin(endAngle) * r0 + y\r\n            );\r\n\r\n            if (r0 !== 0) {\r\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\r\n            }\r\n\r\n            ctx.closePath();\r\n        },\r\n        updateShape: function (ratio, ifParse) {\r\n            var scaleRatio = Number(ratio);\r\n            var shape = this.shape;\r\n            var newR = Number(shape.r * scaleRatio);\r\n            var newR0 = Number(shape.r0 * scaleRatio);\r\n            if (ifParse) {\r\n                newR = parseInt(newR, 10);\r\n                newR0 = parseInt(newR0, 10);\r\n            }\r\n            // 按比例缩放\r\n            this.setShape({\r\n                r: newR,\r\n                r0: newR0\r\n            });\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Sector.js\n// module id = 101\n// module chunks = 0","/**\r\n * 环形<br>\r\n * @class fishTopoFlow.node.Ring\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n *       var ring = new node.Ring({\r\n *           shape: {r:30,  r0:10},  // r0 内半径\r\n *           position:[60,60]\r\n *       });\r\n *       fishTopo.add(ring);\r\n */\r\n\r\n    module.exports = require('./flowNode').extend({\r\n\r\n         type: 'Ring',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.r=0 外半径。\r\n         * @cfg {Number} shape.r0=0 内半径。\r\n         */\r\n        shape: {\r\n            cx: 0,\r\n            cy: 0,\r\n            r: 0,\r\n            r0: 0\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var x = shape.cx;\r\n            var y = shape.cy;\r\n            var PI2 = Math.PI * 2;\r\n            ctx.moveTo(x + shape.r, y);\r\n            ctx.arc(x, y, shape.r, 0, PI2, false);\r\n            ctx.moveTo(x + shape.r0, y);\r\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\r\n        },\r\n        updateShape: function (ratio, ifParse) {\r\n            var scaleRatio = Number(ratio);\r\n            var shape = this.shape;\r\n            var newR = Number(shape.r * scaleRatio);\r\n            var newR0 = Number(shape.r0 * scaleRatio);\r\n            if (ifParse) {\r\n                newR = parseInt(newR, 10);\r\n                newR0 = parseInt(newR0, 10);\r\n            }\r\n            // 按比例缩放\r\n            this.setShape({\r\n                r: newR,\r\n                r0: newR0\r\n            });\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Ring.js\n// module id = 102\n// module chunks = 0","'use strict';\n/**\r\n * 椭圆<br>\r\n * @class fishTopoFlow.node.Droplet\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var ellipse = new node.Ellipse({\r\n *           shape: {rx:70,  ry:30},  // rx:椭圆横半轴长 ry:椭圆纵半轴长\r\n *           position:[60,60]\r\n *       });\r\n *       fishTopo.add(ellipse);\r\n */\r\n\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Ellipse',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.rx=0 椭圆横半轴长\r\n         * @cfg {Number} shape.ry=0 椭圆纵半轴长\r\n         */\r\n        shape: {\r\n            rx: 0, ry: 0\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var k = 0.5522848;\r\n            var x = 0;\r\n            var y = 0;\r\n            var a = shape.rx;\r\n            var b = shape.ry;\r\n            var ox = a * k; // 水平控制点偏移量\r\n            var oy = b * k; // 垂直控制点偏移量\r\n            // 从椭圆的左端点开始顺时针绘制四条三次贝塞尔曲线\r\n            ctx.moveTo(x - a, y);\r\n            ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);\r\n            ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);\r\n            ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);\r\n            ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);\r\n            ctx.closePath();\r\n        },\r\n        updateShape: function (ratio, ifParse) {\r\n            var scaleRatio = Number(ratio);\r\n            var shape = this.shape;\r\n            var newRx = Number(shape.rx * scaleRatio);\r\n            var newRy = Number(newRx * shape.ry / shape.rx);\r\n            if (ifParse) {\r\n                newRx = parseInt(newRx, 10);\r\n                newRy = parseInt(newRy, 10);\r\n            }\r\n            // 按比例缩放\r\n            this.setShape({\r\n                rx: newRx,\r\n                ry: newRy\r\n            });\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Ellipse.js\n// module id = 103\n// module chunks = 0","/**\r\n * 心形<br>\r\n * @class fishTopoFlow.node.Heart\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var heart  = new node.Heart({\r\n *           shape: {width:40,  height:50},\r\n *           position:[60,60]\r\n *       });\r\n *       fishTopo.add(heart );\r\n */\r\n\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Heart',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.cx=0 中心在父节点坐标系（以父节点左上角为原点）中的横坐标值。\r\n         * @cfg {Number} shape.cy=0 中心在父节点坐标系（以父节点左上角为原点）中的纵坐标值。\r\n         * @cfg {Number} shape.width=0 宽度。\r\n         * @cfg {Number} shape.height=0 高度。\r\n         */\r\n        shape: {\r\n            cx: 0,\r\n            cy: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var x = shape.cx;\r\n            var y = shape.cy;\r\n            var a = shape.width;\r\n            var b = shape.height;\r\n            ctx.moveTo(x, y);\r\n            ctx.bezierCurveTo(\r\n                x + a / 2, y - b * 2 / 3,\r\n                x + a * 2, y + b / 3,\r\n                x, y + b\r\n            );\r\n            ctx.bezierCurveTo(\r\n                x - a *  2, y + b / 3,\r\n                x - a / 2, y - b * 2 / 3,\r\n                x, y\r\n            );\r\n        },\r\n        updateShape: function (ratio, ifParse) {\r\n            var scaleRatio = Number(ratio);\r\n            var shape = this.shape;\r\n            var newWidth = Number(shape.width * scaleRatio);\r\n            var newHeight = Number(newWidth * shape.height / shape.width);\r\n            if (ifParse) {\r\n                newWidth = parseInt(newWidth, 10);\r\n                newHeight = parseInt(newHeight, 10);\r\n            }\r\n            // 按比例缩放\r\n            this.setShape({\r\n                width: newWidth,\r\n                height: newHeight\r\n            });\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Heart.js\n// module id = 104\n// module chunks = 0","'use strict';\n/**\r\n * 水滴形<br>\r\n * @class fishTopoFlow.node.Droplet\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var droplet = new node.Droplet({\r\n *           shape: {width:10,  height:30},\r\n *           position:[60,60]\r\n *       });\r\n *       fishTopo.add(droplet);\r\n */\r\n\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Droplet',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.width=0 宽度。\r\n         * @cfg {Number} shape.height=0 高度。\r\n         */\r\n        shape: {\r\n            cx: 0, cy: 0,\r\n            width: 0, height: 0\r\n        },\r\n\r\n        buildPath : function (ctx, shape) {\r\n            var x = shape.cx;\r\n            var y = shape.cy;\r\n            var a = shape.width;\r\n            var b = shape.height;\r\n\r\n            ctx.moveTo(x, y + a);\r\n            ctx.bezierCurveTo(\r\n                x + a,\r\n                y + a,\r\n                x + a * 3 / 2,\r\n                y - a / 3,\r\n                x,\r\n                y - b\r\n            );\r\n            ctx.bezierCurveTo(\r\n                x - a * 3 / 2,\r\n                y - a / 3,\r\n                x - a,\r\n                y + a,\r\n                x,\r\n                y + a\r\n            );\r\n            ctx.closePath();\r\n        },\r\n        updateShape: function (ratio, ifParse) {\r\n            var scaleRatio = Number(ratio);\r\n            var shape = this.shape;\r\n            var newWidth = Number(shape.width * scaleRatio);\r\n            var newHeight = Number(newWidth * shape.height / shape.width);\r\n            if (ifParse) {\r\n                newWidth = parseInt(newWidth, 10);\r\n                newHeight = parseInt(newHeight, 10);\r\n            }\r\n            // 按比例缩放\r\n            this.setShape({\r\n                width: newWidth,\r\n                height: newHeight\r\n            });\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Droplet.js\n// module id = 105\n// module chunks = 0","/**\r\n * 玫瑰形<br>\r\n * @class fishTopoFlow.node.Rose\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n *       var rose = new node.Rose({\r\n *           shape: {r:[35], k:7, n:4},\r\n *           position:[60,60]\r\n *       });\r\n *       fishTopo.add(rose);\r\n */\r\n\r\n    var sin = Math.sin;\r\n    var cos = Math.cos;\r\n    var radian = Math.PI / 180;\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Rose',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Array} shape.r=[]\r\n         * @cfg {Number} shape.k=0\r\n         * @cfg {Number} shape.n=1\r\n         */\r\n        shape: {\r\n            cx: 0,\r\n            cy: 0,\r\n            r: [],\r\n            k: 0,\r\n            n: 1\r\n        },\r\n\r\n        style: {\r\n            stroke: '#000',\r\n            fill: null,\r\n            lineWidth: 2\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var x;\r\n            var y;\r\n            var R = shape.r;\r\n            var r;\r\n            var k = shape.k;\r\n            var n = shape.n;\r\n\r\n            var x0 = shape.cx;\r\n            var y0 = shape.cy;\r\n\r\n            ctx.moveTo(x0, y0);\r\n\r\n            for (var i = 0, len = R.length; i < len ; i++) {\r\n                r = R[i];\r\n\r\n                for (var j = 0; j <= 360 * n; j++) {\r\n                    x = r\r\n                         * sin(k / n * j % 360 * radian)\r\n                         * cos(j * radian)\r\n                         + x0;\r\n                    y = r\r\n                         * sin(k / n * j % 360 * radian)\r\n                         * sin(j * radian)\r\n                         + y0;\r\n                    ctx.lineTo(x, y);\r\n                }\r\n            }\r\n        },\r\n        updateShape: function (ratio, ifParse) {\r\n            var scaleRatio = Number(ratio);\r\n            var shape = this.shape;\r\n            var newR = [];\r\n            shape.r.forEach(function (v) {\r\n                newR.push(Number(v * scaleRatio))\r\n            });\r\n            if (ifParse) {\r\n                newR.forEach(function (v) {\r\n                    v = parseInt(v, 10);\r\n                });\r\n            }\r\n            // 按比例缩放\r\n            this.setShape({\r\n                r: newR\r\n            });\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Rose.js\n// module id = 106\n// module chunks = 0","/**\r\n * 正多边形<br>\r\n * @class fishTopoFlow.node.Isogon\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var isogon = new node.Isogon({\r\n *           shape: {r:40,  n:9},  // r半径 n几个边\r\n *           position:[60,50]\r\n *       });\r\n *       fishTopo.add(isogon);\r\n */\r\n\r\n    var PI = Math.PI;\r\n    var sin = Math.sin;\r\n    var cos = Math.cos;\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Isogon',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.r=0 半径\r\n         * @cfg {Number} shape.n=0 几个边\r\n         */\r\n       shape: {\r\n            x: 0, y: 0,\r\n            r: 0, n: 0\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var n = shape.n;\r\n            if (!n || n < 2) {\r\n                return;\r\n            }\r\n\r\n            var x = shape.x;\r\n            var y = shape.y;\r\n            var r = shape.r;\r\n\r\n            var dStep = 2 * PI / n;\r\n            var deg = -PI / 2;\r\n\r\n            ctx.moveTo(x + r * cos(deg), y + r * sin(deg));\r\n            for (var i = 0, end = n - 1; i < end; i++) {\r\n                deg += dStep;\r\n                ctx.lineTo(x + r * cos(deg), y + r * sin(deg));\r\n            }\r\n\r\n            ctx.closePath();\r\n\r\n            return;\r\n        },\r\n        updateShape: function (ratio, ifParse) {\r\n            var scaleRatio = Number(ratio);\r\n            var shape = this.shape;\r\n            var newR = Number(shape.r * scaleRatio);\r\n            if (ifParse) {\r\n                newR = parseInt(newR, 10);\r\n            }\r\n            // 按比例缩放\r\n            this.setShape({\r\n                r: newR\r\n            });\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Isogon.js\n// module id = 107\n// module chunks = 0","/**\r\n * 多边形<br>\r\n * @class fishTopoFlow.node.Polygon\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var polygon = new node.Polygon({\r\n *           shape: {points:[[85.275,0], [100,25.41], [85.275,50.821], [14.138,50.821], [0,25.41], [14.138,0]]},  // r半径 n几个边\r\n *           position:[60,60]\r\n *       });\r\n *       fishTopo.add(polygon);\r\n */\r\n\r\n    var polyHelper = require('zrender/lib/graphic/helper/poly');\r\n\r\n    module.exports = require('./flowNode').extend({\r\n\r\n       type: 'Polygon',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Array} shape.points=null 多边形点的坐标 可以从AI中获取。\r\n         * @cfg {Number|String|Boolean} [shape.smooth=false] 是否平滑曲线显示。如果为 number：表示贝塞尔 (bezier) 差值平滑，smooth 指定了平滑等级，范围 [0, 1];如果为 'spline'：表示 Catmull-Rom spline 差值平滑\r\n         * @cfg {Number} shape.smoothConstraint=null 是否将平滑曲线约束在包围盒中。smooth 为 number（bezier）时生效\r\n         */\r\n        shape: {\r\n            points: null,\r\n\r\n            smooth: false,\r\n\r\n            smoothConstraint: null\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            polyHelper.buildPath(ctx, shape, true);\r\n        },\r\n        updateShape: function (ratio, ifParse) {\r\n            var scaleRatio = Number(ratio);\r\n            var shape = this.shape;\r\n            var pointsNew = [];\r\n            shape.points.forEach(function(item) {\r\n                pointsNew.push([Number(item[0] * scaleRatio), Number(item[1] * scaleRatio)]);\r\n            });\r\n            if (ifParse) {\r\n                pointsNew.forEach(function(item) {\r\n                    item[0] = parseInt(item[0], 10);\r\n                    item[1] = parseInt(item[1], 10);\r\n                });\r\n            }\r\n            // 按比例缩放\r\n            this.setShape({\r\n                points: pointsNew\r\n            });\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Polygon.js\n// module id = 108\n// module chunks = 0","/**\r\n * 直线<br>\r\n * @class fishTopoFlow.node.Line\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var line = new node.Line({\r\n *           shape: {x1:60,  y1:60, x2:100, y2:100},  // x 起点 y终点\r\n *           style: {lineWidth:3}\r\n *       });\r\n *       fishTopo.add(line);\r\n */\r\n\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Line',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.x1=0 起始点的横坐标值。\r\n         * @cfg {Number} shape.y1=0 起始点的纵坐标值。\r\n         * @cfg {Number} shape.x2=0 终止点的横坐标值。\r\n         * @cfg {Number} shape.y2=0 终止点的纵坐标值。\r\n         */\r\n        shape: {\r\n            // Start point\r\n            x1: 0,\r\n            y1: 0,\r\n            // End point\r\n            x2: 0,\r\n            y2: 0,\r\n\r\n            percent: 1\r\n        },\r\n\r\n        style: {\r\n            stroke: '#000',\r\n            fill: null\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var x1 = shape.x1;\r\n            var y1 = shape.y1;\r\n            var x2 = shape.x2;\r\n            var y2 = shape.y2;\r\n            var percent = shape.percent;\r\n\r\n            if (percent === 0) {\r\n                return;\r\n            }\r\n\r\n            ctx.moveTo(x1, y1);\r\n\r\n            if (percent < 1) {\r\n                x2 = x1 * (1 - percent) + x2 * percent;\r\n                y2 = y1 * (1 - percent) + y2 * percent;\r\n            }\r\n            ctx.lineTo(x2, y2);\r\n        },\r\n\r\n        /**\r\n         * Get point at percent\r\n         * @param  {number} percent\r\n         * @return {Array.<number>}\r\n         */\r\n        pointAt: function (p) {\r\n            var shape = this.shape;\r\n            return [\r\n                shape.x1 * (1 - p) + shape.x2 * p,\r\n                shape.y1 * (1 - p) + shape.y2 * p\r\n            ];\r\n        },\r\n        updateShape: function (ratio, ifParse) {\r\n            var scaleRatio = Number(ratio);\r\n            var shape = this.shape;\r\n            var newX1 = Number(shape.x1 * scaleRatio);\r\n            var newX2 = Number(shape.x2 * scaleRatio);\r\n            var newY1 = Number(shape.y1 * scaleRatio);\r\n            var newY2 = Number(shape.y2 * scaleRatio);\r\n            if (ifParse) {\r\n                newX1 = parseInt(newX1, 10);\r\n            }\r\n            // 按比例缩放\r\n            this.setShape({\r\n                x1: newX1,\r\n                y1: newY1,\r\n                x2: newX2,\r\n                y2: newY2\r\n            });\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Line.js\n// module id = 109\n// module chunks = 0","'use strict';\n/**\r\n * 拆线<br>\r\n * @class fishTopoFlow.node.Polyline\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var polyline = new node.Polyline({\r\n *           shape: {points:[[57,138],[95,184],[115,166],[151,184] ]}\r\n *       });\r\n *       fishTopo.add(polyline);\r\n */\r\n\r\n    var polyHelper = require('zrender/lib/graphic/helper/poly');\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Polyline',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Array} shape.points=null 拆线点的坐标 可以从AI中获取。\r\n         * @cfg {Number|String|Boolean} [shape.smooth=false] 是否平滑曲线显示。如果为 number：表示贝塞尔 (bezier) 差值平滑，smooth 指定了平滑等级，范围 [0, 1];如果为 'spline'：表示 Catmull-Rom spline 差值平滑\r\n         * @cfg {Number} shape.smoothConstraint=null 是否将平滑曲线约束在包围盒中。smooth 为 number（bezier）时生效\r\n         */\r\n        shape: {\r\n            points: null,\r\n\r\n            smooth: false,\r\n\r\n            smoothConstraint: null\r\n        },\r\n\r\n        style: {\r\n            stroke: '#000',\r\n\r\n            fill: null\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            polyHelper.buildPath(ctx, shape, false);\r\n        },\r\n        updateShape: function (ratio, ifParse) {\r\n            var scaleRatio = Number(ratio);\r\n            var shape = this.shape;\r\n            var pointsNew = [];\r\n            shape.points.forEach(function(item) {\r\n                pointsNew.push([Number(item[0] * scaleRatio), Number(item[1] * scaleRatio)]);\r\n            });\r\n            if (ifParse) {\r\n                pointsNew.forEach(function(item) {\r\n                    item[0] = parseInt(item[0], 10);\r\n                    item[1] = parseInt(item[1], 10);\r\n                });\r\n            }\r\n            // 按比例缩放\r\n            this.setShape({\r\n                points: pointsNew\r\n            });\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Polyline.js\n// module id = 110\n// module chunks = 0","'use strict';\n/**\r\n * 贝塞尔曲线<br>\r\n * @class fishTopoFlow.node.BezierCurve\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var bezierCurve = new node.BezierCurve({\r\n *           shape: {x1:0, y1:100, cpx1:0, cpy1:0, cpx2:0, cpy2:0, x2:100, y2:0},\r\n *           position: [60, 60]\r\n *       });\r\n *       fishTopo.add(bezierCurve);\r\n */\r\n\r\n\r\n    var curveTool = require('zrender/lib/core/curve');\r\n    var vec2 = require('zrender/lib/core/vector');\r\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\r\n    var cubicSubdivide = curveTool.cubicSubdivide;\r\n    var quadraticAt = curveTool.quadraticAt;\r\n    var cubicAt = curveTool.cubicAt;\r\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\r\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\r\n\r\n    var out = [];\r\n\r\n    function someVectorAt(shape, t, isTangent) {\r\n        var cpx2 = shape.cpx2;\r\n        var cpy2 = shape.cpy2;\r\n        if (cpx2 === null || cpy2 === null) {\r\n            return [\r\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\r\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\r\n            ];\r\n        }\r\n        else {\r\n            return [\r\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\r\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\r\n            ];\r\n        }\r\n    }\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'BezierCurve',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.x1=0 起始点的横坐标值。\r\n         * @cfg {Number} shape.y1=0 起始点的纵坐标值。\r\n         * @cfg {Number} shape.x2=0 终止点的横坐标值。\r\n         * @cfg {Number} shape.y2=0 终止点的纵坐标值。\r\n         * @cfg {Number} shape.cpx1=0 控制点的横坐标值。\r\n         * @cfg {Boolean} shape.cpx2=0 控制点的纵坐标值。\r\n         */\r\n        shape: {\r\n            x1: 0,\r\n            y1: 0,\r\n            x2: 0,\r\n            y2: 0,\r\n            cpx1: 0,\r\n            cpy1: 0,\r\n\r\n            // Curve show percent, for animating\r\n            percent: 1\r\n        },\r\n\r\n        style: {\r\n            stroke: '#000',\r\n            fill: null\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var x1 = shape.x1;\r\n            var y1 = shape.y1;\r\n            var x2 = shape.x2;\r\n            var y2 = shape.y2;\r\n            var cpx1 = shape.cpx1;\r\n            var cpy1 = shape.cpy1;\r\n            var cpx2 = shape.cpx2;\r\n            var cpy2 = shape.cpy2;\r\n            var percent = shape.percent;\r\n            if (percent === 0) {\r\n                return;\r\n            }\r\n\r\n            ctx.moveTo(x1, y1);\r\n\r\n            if (cpx2 == null || cpy2 == null) {\r\n                if (percent < 1) {\r\n                    quadraticSubdivide(\r\n                        x1, cpx1, x2, percent, out\r\n                    );\r\n                    cpx1 = out[1];\r\n                    x2 = out[2];\r\n                    quadraticSubdivide(\r\n                        y1, cpy1, y2, percent, out\r\n                    );\r\n                    cpy1 = out[1];\r\n                    y2 = out[2];\r\n                }\r\n\r\n                ctx.quadraticCurveTo(\r\n                    cpx1, cpy1,\r\n                    x2, y2\r\n                );\r\n            }\r\n            else {\r\n                if (percent < 1) {\r\n                    cubicSubdivide(\r\n                        x1, cpx1, cpx2, x2, percent, out\r\n                    );\r\n                    cpx1 = out[1];\r\n                    cpx2 = out[2];\r\n                    x2 = out[3];\r\n                    cubicSubdivide(\r\n                        y1, cpy1, cpy2, y2, percent, out\r\n                    );\r\n                    cpy1 = out[1];\r\n                    cpy2 = out[2];\r\n                    y2 = out[3];\r\n                }\r\n                ctx.bezierCurveTo(\r\n                    cpx1, cpy1,\r\n                    cpx2, cpy2,\r\n                    x2, y2\r\n                );\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Get point at percent\r\n         * @param  {number} t\r\n         * @return {Array.<number>}\r\n         */\r\n        pointAt: function (t) {\r\n            return someVectorAt(this.shape, t, false);\r\n        },\r\n\r\n        /**\r\n         * Get tangent at percent\r\n         * @param  {number} t\r\n         * @return {Array.<number>}\r\n         */\r\n        tangentAt: function (t) {\r\n            var p = someVectorAt(this.shape, t, true);\r\n            return vec2.normalize(p, p);\r\n        },\r\n        updateShape: function (ratio, ifParse) {\r\n            var scaleRatio = Number(ratio);\r\n            var shape = this.shape;\r\n            var pointsNew = {};\r\n            Object.keys(shape).forEach(function (key) {\r\n                var value = shape[key];\r\n                if (key !== 'percent') {\r\n                    pointsNew[key] = Number(value * scaleRatio);\r\n                } else {\r\n                    pointsNew[key] = value;\r\n                }\r\n            });\r\n            if (ifParse) {\r\n                Object.keys(pointsNew).forEach(function(key) {\r\n                    pointsNew[key] = parseInt(pointsNew[key], 10);\r\n                });\r\n            }\r\n            // 按比例缩放\r\n            this.setShape(pointsNew);\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/BezierCurve.js\n// module id = 111\n// module chunks = 0","'use strict';\n/**\r\n * 圆弧<br>\r\n * @class fishTopoFlow.node.Arc\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var arc = new node.Arc({\r\n *           shape: {r:50, startAngle:0, endAngle:1.2*Math.PI},\r\n *           position: [60, 60]\r\n *       });\r\n *       fishTopo.add(arc);\r\n */\r\n\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Arc',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.r=0 半径。\r\n         * @cfg {Number} shape.startAngle=0 开始弧度。\r\n         * @cfg {Number} shape.endAngle=Math.PI * 2  结束弧度。\r\n         * @cfg {Boolean} shape.clockwise=true 是否顺时针。\r\n         */\r\n        shape: {\r\n            cx: 0,\r\n            cy: 0,\r\n            r: 0,\r\n            startAngle: 0,\r\n            endAngle: Math.PI * 2,\r\n            clockwise: true\r\n        },\r\n\r\n        style: {\r\n\r\n            stroke: '#000',\r\n\r\n            fill: null\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n\r\n            var x = shape.cx;\r\n            var y = shape.cy;\r\n            var r = Math.max(shape.r, 0);\r\n            var startAngle = shape.startAngle;\r\n            var endAngle = shape.endAngle;\r\n            var clockwise = shape.clockwise;\r\n\r\n            var unitX = Math.cos(startAngle);\r\n            var unitY = Math.sin(startAngle);\r\n\r\n            ctx.moveTo(unitX * r + x, unitY * r + y);\r\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\r\n        },\r\n        updateShape: function (ratio, ifParse) {\r\n            var scaleRatio = Number(ratio);\r\n            var shape = this.shape;\r\n            var newR = Number(shape.r * scaleRatio);\r\n            if (ifParse) {\r\n                newR = parseInt(newR, 10);\r\n            }\r\n            // 按比例缩放\r\n            this.setShape({\r\n                r: newR\r\n            });\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Arc.js\n// module id = 112\n// module chunks = 0","'use strict';\n/**\r\n * 星形<br>\r\n * @class fishTopoFlow.node.Star\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n *       var star = new node.Star({\r\n *           shape: {n:7, r:30},  //r半径 n几个角\r\n *           position:[60,60]\r\n *       });\r\n *       fishTopo.add(star);\r\n */\r\n\r\n    var PI = Math.PI;\r\n\r\n    var cos = Math.cos;\r\n    var sin = Math.sin;\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Star',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.n=3 几个角。\r\n         * @cfg {Number} shape.r=0 外半径。\r\n         * @cfg {Number} shape.r0=0 内半径。\r\n         */\r\n        shape: {\r\n            cx: 0,\r\n            cy: 0,\r\n            n: 3,\r\n            r0: null,\r\n            r: 0\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n\r\n            var n = shape.n;\r\n            if (!n || n < 2) {\r\n                return;\r\n            }\r\n\r\n            var x = shape.cx;\r\n            var y = shape.cy;\r\n            var r = shape.r;\r\n            var r0 = shape.r0;\r\n\r\n            // 如果未指定内部顶点外接圆半径，则自动计算\r\n            if (r0 == null) {\r\n                r0 = n > 4\r\n                    // 相隔的外部顶点的连线的交点，\r\n                    // 被取为内部交点，以此计算r0\r\n                    ? r * cos(2 * PI / n) / cos(PI / n)\r\n                    // 二三四角星的特殊处理\r\n                    : r / 3;\r\n            }\r\n\r\n            var dStep = PI / n;\r\n            var deg = -PI / 2;\r\n            var xStart = x + r * cos(deg);\r\n            var yStart = y + r * sin(deg);\r\n            deg += dStep;\r\n\r\n            // 记录边界点，用于判断inside\r\n            ctx.moveTo(xStart, yStart);\r\n            for (var i = 0, end = n * 2 - 1, ri; i < end; i++) {\r\n                ri = i % 2 === 0 ? r0 : r;\r\n                ctx.lineTo(x + ri * cos(deg), y + ri * sin(deg));\r\n                deg += dStep;\r\n            }\r\n\r\n            ctx.closePath();\r\n        },\r\n        updateShape: function (ratio, ifParse) {\r\n            var scaleRatio = Number(ratio);\r\n            var shape = this.shape;\r\n            var newR = Number(shape.r * scaleRatio);\r\n            if (ifParse) {\r\n                newR = parseInt(newR, 10);\r\n            }\r\n            // 按比例缩放\r\n            this.setShape({\r\n                r: newR\r\n            });\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Star.js\n// module id = 113\n// module chunks = 0","'use strict';\n/**\r\n * 旋轮曲线<br>\r\n * @class fishTopoFlow.node.Trochoid\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n *       var trochoid = new node.Trochoid({\r\n *           shape: {r:50, r0:35, d:30, location:null},  //r半径 n几个角\r\n *           position:[60,60],\r\n *           tooltip: \"旋轮曲线\"\r\n *       });\r\n *       fishTopo.add(trochoid);\r\n */\r\n\r\n\r\n    var cos = Math.cos;\r\n    var sin = Math.sin;\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Trochoid',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.r=0 外半径。\r\n         * @cfg {Number} shape.r0=0 内半径。\r\n         * @cfg {Number} shape.d=0\r\n         * @cfg {Number} shape.location='out'\r\n         */\r\n        shape: {\r\n            cx: 0,\r\n            cy: 0,\r\n            r: 0,\r\n            r0: 0,\r\n            d: 0,\r\n            location: 'out'\r\n        },\r\n\r\n        style: {\r\n            stroke: '#000',\r\n\r\n            fill: null\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var x1;\r\n            var y1;\r\n            var x2;\r\n            var y2;\r\n            var R = shape.r;\r\n            var r = shape.r0;\r\n            var d = shape.d;\r\n            var offsetX = shape.cx;\r\n            var offsetY = shape.cy;\r\n            var delta = shape.location == 'out' ? 1 : -1;\r\n\r\n            if (shape.location && R <= r) {\r\n                return;\r\n            }\r\n\r\n            var num = 0;\r\n            var i = 1;\r\n            var theta;\r\n\r\n            x1 = (R + delta * r) * cos(0)\r\n                - delta * d * cos(0) + offsetX;\r\n            y1 = (R + delta * r) * sin(0)\r\n                - d * sin(0) + offsetY;\r\n\r\n            ctx.moveTo(x1, y1);\r\n\r\n            // 计算结束时的i\r\n            do {\r\n                num++;\r\n            }\r\n            while ((r * num) % (R + delta * r) !== 0);\r\n\r\n            do {\r\n                theta = Math.PI / 180 * i;\r\n                x2 = (R + delta * r) * cos(theta)\r\n                     - delta * d * cos((R / r +  delta) * theta)\r\n                     + offsetX;\r\n                y2 = (R + delta * r) * sin(theta)\r\n                     - d * sin((R / r + delta) * theta)\r\n                     + offsetY;\r\n                ctx.lineTo(x2, y2);\r\n                i++;\r\n            }\r\n            while (i <= (r * num) / (R + delta * r) * 360);\r\n\r\n        },\r\n        updateShape: function (ratio, ifParse) {\r\n            var scaleRatio = Number(ratio);\r\n            var shape = this.shape;\r\n            var newR = Number(shape.r * scaleRatio);\r\n            var newR0 = Number(shape.r0 * scaleRatio);\r\n            var newD = Number(shape.d * scaleRatio);\r\n            newR = parseInt(newR, 10);\r\n            newR0 = parseInt(newR0, 10);\r\n            newD = parseInt(newD, 10);\r\n            // 按比例缩放\r\n            this.setShape({\r\n                r: newR,\r\n                r0: newR0,\r\n                d: newD\r\n            });\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Trochoid.js\n// module id = 114\n// module chunks = 0","/**\r\n * 路径<br>\r\n * @class fishTopoFlow.node.Path\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var path = new node.Path({\r\n *           pathData: 'M9 0l8 8-17 17 7 7 17-17 8 8v-23h-23z',\r\n *           rect: {x:0,y:0,width:30,height:30},\r\n *           position: [60,60]\r\n *       });\r\n *       fishTopo.add(path);\r\n */\r\n\r\n    var pathTool = require('zrender/lib/tool/path');\r\n    var Draggable = require('zrender/lib/mixin/Draggable');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var flowNode = require('./flowNode');\r\n\r\n    function ZPath(opts) {\r\n        /**\r\n         * @cfg {Object} options 参数\r\n         * @cfg {String} options.pathData path数据。\r\n         * @cfg {Object} options.rect 图形的大小。\r\n         * @cfg {Object} options.rect.width 图形的宽度。\r\n         * @cfg {Object} options.rect.height 图形的高度。\r\n         * @cfg {Number} [options.layout=null] 默认为null  仅支持\"center\"\r\n         *\r\n         */\r\n        var defaultOptions = {\r\n            style:{ fill: 'none',stroke: '#2c2c2c'},\r\n            rect:{x:0,y:0,width:0,height:0},\r\n            rectHover: true\r\n        }\r\n\r\n        var pathData = opts.pathData;\r\n        var model = flowNode.genModel(\"Path\", opts);\r\n        delete opts.pathData;\r\n        this.options = zrUtil.merge(defaultOptions, opts, true);\r\n        var path = pathTool.createFromString(pathData, this.options);\r\n        path.model = model;\r\n        Draggable.call(path);\r\n        var boundingRect = path.getBoundingRect();\r\n        var rect = this.options.rect;\r\n        var layout = opts.layout;\r\n        if (rect) {\r\n            var aspect = boundingRect.width / boundingRect.height;\r\n\r\n            if (layout === 'center') {\r\n                // Set rect to center, keep width / height ratio.\r\n                var width = rect.height * aspect;\r\n                var height;\r\n                if (width <= rect.width) {\r\n                    height = rect.height;\r\n                }\r\n                else {\r\n                    width = rect.width;\r\n                    height = width / aspect;\r\n                }\r\n                var cx = rect.x + rect.width / 2;\r\n                var cy = rect.y + rect.height / 2;\r\n\r\n                rect.x = cx - width / 2;\r\n                rect.y = cy - height / 2;\r\n                rect.width = width;\r\n                rect.height = height;\r\n            }\r\n\r\n            this.resizePath(path, rect);\r\n        }\r\n        path.type = 'ZPath';\r\n        return path;\r\n    }\r\n\r\n    ZPath.prototype = {\r\n\r\n        constructor: ZPath,\r\n\r\n        type: 'ZPath',\r\n        /**\r\n         * Resize a path to fit the rect\r\n         */\r\n        resizePath: function (path, rect) {\r\n                if (!path.applyTransform) {\r\n                    return;\r\n                }\r\n\r\n                var pathRect = path.getBoundingRect();\r\n\r\n                var m = pathRect.calculateTransform(rect);\r\n\r\n                path.applyTransform(m);\r\n        },\r\n        updateShape: function (ratio, ifParse) {\r\n            var scaleRatio = Number(ratio);\r\n            var rect = this.rect;\r\n            var newW = Number(rect.width * scaleRatio);\r\n            var newH = Number(newW * rect.height / rect.width);\r\n            if (ifParse) {\r\n                newW = parseInt(newW, 10);\r\n                newH = parseInt(newH, 10);\r\n            }\r\n            rect.width = newW;\r\n            rect.height = newH;\r\n            // 按比例缩放\r\n            this.attr('rect', rect);\r\n        }\r\n    }\r\n    zrUtil.inherits(ZPath, Draggable);\r\n    module.exports = ZPath;\r\n\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Path.js\n// module id = 115\n// module chunks = 0","/**\r\n * 图形按钮<br>\r\n * @class fishTopoFlow.node.IconButton\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var iconButton   = new node.IconButton({\r\n *          title:'IconButton',\r\n *          icon:'path://M432.45,595.444c0,2.177-4.661,6.82-11.305,6.82c-6.475,0-11.306-4.567-11.306-6.82s4.852-6.812,11.306-6.812C427.841,588.632,432.452,593.191,432.45,595.444L432.45,595.444z M421.155,589.876c-3.009,0-5.448,2.495-5.448,5.572s2.439,5.572,5.448,5.572c3.01,0,5.449-2.495,5.449-5.572C426.604,592.371,424.165,589.876,421.155,589.876L421.155,589.876z M421.146,591.891c-1.916,0-3.47,1.589-3.47,3.549c0,1.959,1.554,3.548,3.47,3.548s3.469-1.589,3.469-3.548C424.614,593.479,423.062,591.891,421.146,591.891L421.146,591.891zM421.146,591.891',\r\n *          itemSize:50,\r\n *          position:[60,60]\r\n *       });\r\n *       fishTopo.add(iconButton);\r\n */\r\n\r\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n    var flowNode = require('./flowNode');\r\n\r\n    function IconButton(opts) {\r\n\r\n        /**\r\n         * @cfg {Object} options 构造参数\r\n         * @cfg {String} options.title=\"\" 鼠标移上去显示的文字\r\n         * @cfg {String} options.icon=\"\" Icon 的 path 字符串，支持使用自定义的 svg path 作为 icon，格式参见 [SVG PathData](https://www.w3.org/TR/SVG/paths.html#PathData)。可以从 Adobe Illustrator 等工具编辑导出。\r\n         * @cfg {Number} options.itemSize=15  icon 的大小\r\n         * @cfg {Object} options.iconStyle  图标样式\r\n         * @cfg {Object} options.iconStyle.normal 正常的样式\r\n         * @cfg {Number} options.iconStyle.normal.stroke='#666' 正常的样式（描边色）\r\n         * @cfg {Number} options.iconStyle.normal.fill='none' 正常的样式（填充色）\r\n         * @cfg {Object} options.iconStyle.emphasis 高亮状态下的样式\r\n         * @cfg {Number} options.iconStyle.emphasis.stroke='#666' 高亮状态下的样式（描边色）\r\n         * @cfg {Number} options.iconStyle.emphasis.fill='none' 高亮状态下的样式（填充色）\r\n         */\r\n        var defaultOptions = {\r\n            backgroundColor: 'transparent',\r\n            borderColor: '#ccc',\r\n            draggable:false,\r\n            selectable:false,\r\n            borderWidth: 0,\r\n            itemSize: 15,\r\n            showTitle: true,\r\n            icon:\"\",  //Icon 的 path 字符串，支持使用自定义的 svg path 作为 icon，格式参见 SVG PathData。可以从 Adobe Illustrator 等工具编辑导出。\r\n            iconStyle: {\r\n                normal: {\r\n                    stroke: '#666',\r\n                    fill: 'none'\r\n                },\r\n                emphasis: {\r\n                    stroke: '#3E98c5'\r\n                }\r\n            }\r\n        };\r\n        this.options = zrUtil.merge(defaultOptions, opts, true);\r\n\r\n        this.model = flowNode.genModel(\"IconButton\", this.options);\r\n        graphic.Group.call(this, this.options);\r\n        this.render();\r\n    }\r\n    IconButton.prototype = {\r\n        constructor: IconButton,\r\n        type: \"IconButton\",\r\n        render: function () {\r\n            var normalStyle = this.options.iconStyle.normal;\r\n            var hoverStyle = this.options.iconStyle.emphasis;\r\n            var itemSize = this.options.itemSize;\r\n            var icon = this.options.icon;\r\n            var style = {\r\n                x: -itemSize / 2,\r\n                y: -itemSize / 2,\r\n                width: itemSize,\r\n                height: itemSize\r\n            };\r\n            var path = icon.indexOf('image://') === 0 ?\r\n                (\r\n                    style.image = icon.slice(8),\r\n                    new graphic.Image({\r\n                        style: style\r\n                    })\r\n                ) :\r\n                graphic.makePath(\r\n                    icon.replace('path://', ''), {\r\n                        style: normalStyle,\r\n                        hoverStyle: hoverStyle,\r\n                        rectHover: true\r\n                    },\r\n                    style,\r\n                    'center'\r\n                );\r\n\r\n            graphic.setHoverStyle(path);\r\n\r\n            if (this.options.showTitle) {\r\n                path.__title = this.options.title;\r\n                path.on('mouseover', function () {\r\n                        // Should not reuse above hoverStyle, which might be modified.\r\n                        path.setStyle({\r\n                            text: this.options.title,\r\n                            textPosition: hoverStyle.textPosition || 'bottom',\r\n                            textFill: hoverStyle.fill || hoverStyle.stroke || '#000',\r\n                            textAlign: hoverStyle.textAlign || 'center'\r\n                        });\r\n                    }.bind(this))\r\n                    .on('mouseout', function () {\r\n                        path.setStyle({\r\n                            textFill: null\r\n                        });\r\n                    });\r\n            }\r\n\r\n            path.trigger('normal');\r\n            this.add(path);\r\n        }\r\n    }\r\n\r\n    zrUtil.inherits(IconButton, graphic.Group);\r\n    module.exports = IconButton;\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/IconButton.js\n// module id = 116\n// module chunks = 0","'use strict';\n/**\r\n * fishTopoFlow的link对象，框架提供的连线都放在这个对象下。\r\n * @class fishTopoFlow.link\r\n * @abstract\r\n */\r\n\r\n    var Link = require('./Link');\r\n    var Fold = require('./Fold');\r\n    var Curve = require('./Curve');\r\n    var Chain = require('./Chain');\r\n    var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n    var flowLink = {};\r\n    flowLink.Link = flowLink[Connector.TYPE_STRAIGHT] = Link;\r\n    flowLink.Fold = flowLink[Connector.TYPE_JAGGED] = Fold;\r\n    flowLink.Curve = flowLink[Connector.TYPE_CURVE] = Curve;\r\n    flowLink.Chain = flowLink[Connector.TYPE_CHAIN] = Chain;\r\n    module.exports = flowLink;\r\n\r\n\r\n/**\r\n * @method constructor\r\n * 连线的构造函数\r\n * @param  {Object} startNode 开始节点\r\n * @param  {Object} endNode   结束节点\r\n * @param  {Object} options 线段选项\r\n * @param {Object} [options.style] 节点的样式\r\n * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n * @param {Object} [options.symbol] 线段的箭头\r\n * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]\r\n * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]\r\n * @param {Number} [options.symbol.offset] 设置箭头在连线上的偏移量，默认是0；此属性只针对直线和折线类型有效，如果是折线，offset最大值不能超过options.bundleOffset(默认是30)设置的值 since V2.3.0\r\n * @param {Object} [options.text] 线段上的文字\r\n * @param {String} [options.text.text] 线段上的文字内容\r\n * @param {String} [options.text.color] 线段上的文字颜色\r\n * @param {String} [options.text.textFont] 线段上的文字字体\r\n * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]\r\n * @param {Boolean} [options.text.textRotateable] 文字随线段旋转, 默认值为true\r\n * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n * @param {String} [options.position] 指定线段位置\r\n * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n * @param {Object} [options.position.startOffset] 线段开始位置的偏移\r\n * @param {Object} [options.position.endOffset] 线段结束位置的偏移\r\n * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]\r\n * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n * @param {Object} [options.effect] 线上动态效果\r\n * @param {String} [options.effect.show] 是否显示箭头动效\r\n * @param {Number} [options.effect.period] 动效移动速度\r\n * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n * @param {Number} [options.z] 连线的层级，越大越在前面显示\r\n * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)\r\n * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)\r\n * @return {Object} 返回创建成功的连线对象\r\n */\r\n\r\n\r\n/**\r\n * @method setStyle\r\n * 创建连线后，设置连线的样式\r\n * @param {Object} options 对应创建节点，传递的options参数\r\n * @param {Object} [options.text] 连线文字的样式\r\n * @param {Object} [options.symbol] 连线箭头的样式\r\n * @param {String} [options.color] 连线的颜色\r\n */\r\n/**\r\n * @method on\r\n * 绑定事件\r\n * @param {String} event 事件名\r\n * @param {Function} handler 事件处理函数\r\n * @param {Object} [context] 上下文\r\n */\r\n\r\n/**\r\n * @method off\r\n * 解绑事件\r\n * @param {String} event 事件名\r\n * @param {Function} handler 事件处理函数\r\n */\r\n\r\n/**\r\n * @method one\r\n * 单次触发绑定,trigger后销毁\r\n * @param {String} event 事件名\r\n * @param {Function} handler 事件处理函数\r\n * @param {Object} [context] 上下文\r\n */\r\n\r\n/**\r\n * @method trigger\r\n * 事件分发\r\n * @param {String} type 事件类型\r\n */\r\n/**\r\n * @event click\r\n * 单击事件\r\n *\r\n * <pre>\r\n * flink.on('Connector:click', function(e) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n/**\r\n * @event dblclick\r\n * 当双击元素时，会发生 dblclick 事件。\r\n *\r\n * <pre>\r\n * flink.on('Connector:dblclick', function(e) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/link/flowLink.js\n// module id = 117\n// module chunks = 0","/**\r\n * 直线<br>\r\n * @class fishTopoFlow.link.Link\r\n * @extends fishTopoFlow.link\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var link = fishTopoFlow.link;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       //节点\r\n *       function newNode(x, y, w, h) {\r\n *           var rect = new node.Rect({\r\n *               shape: {width: w,height: h},\r\n *               position: [x, y],\r\n *               style: {fill: \"#167CFF\"}\r\n *           });\r\n *           fishTopo.add(rect);\r\n *           return rect;\r\n *       }\r\n *       //简单连线\r\n *       function newLink(startNode, endNode, text, dashedPattern) {\r\n *           var slink = new link.Link(startNode, endNode, {\r\n *               style: {lineDash: [dashedPattern]},\r\n *               text: {text: text}\r\n *           })\r\n *           fishTopo.add(slink);\r\n *           return slink;\r\n *       }\r\n *       var from = newNode(100, 60, 30, 30);\r\n *       var to = newNode(300, 60, 30, 30);\r\n *       newLink(from, to, '虚线带箭头', 5);\r\n */\r\n\r\n    var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n    var Flow = require(\"../Flow\");\r\n\r\n    function Link(startNode,endNode,options) {\r\n        var opt = Flow.translateLinkOptions(options);\r\n        //默认就是直线\r\n        var connector = new Connector(opt);\r\n        connector.startNode = startNode;\r\n        connector.endNode = endNode;\r\n\r\n        return connector;\r\n    }\r\n    /**\r\n     * @method createByPoint\r\n     * 用户指定连线的点，来进行画线\r\n     * @param  {Object} options 线段选项\r\n     * @param {Object} [options.style] 节点的样式\r\n     * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n     * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n     * @param {Object} [options.symbol] 线段的箭头\r\n     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]\r\n     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]\r\n     * @param {Number} [options.symbol.offset] 设置箭头在连线上的偏移量，默认是0 since V2.3.0\r\n     * @param {Object} [options.text] 线段上的文字\r\n     * @param {String} [options.text.text] 线段上的文字内容\r\n     * @param {String} [options.text.textFill] 线段上的文字颜色\r\n     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]\r\n     * @param {Boolean} [options.text.textRotateable] 文字随线段旋转, 默认值为true\r\n     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n     * @param {String} [options.position] 指定线段位置\r\n     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n     * @param {Object} [options.position.startOffset] 线段开始位置的偏移[x,y]   eg. startOffset:[0,10] 在x上偏移0 y上偏移10\r\n     * @param {Object} [options.position.endOffset] 线段结束位置的偏移[x,y]   eg. startOffset:[0,10] 在x上偏移0 y上偏移10\r\n     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]\r\n     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n     * @param {Object} [options.effect] 线上动态效果\r\n     * @param {String} [options.effect.show] 是否显示箭头动效\r\n     * @param {Number} [options.effect.period] 动效移动速度\r\n     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n     * @param {Number} [options.z] 连线的层级，越大越在前面显示\r\n     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)\r\n     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)\r\n     */\r\n    Link.createByPoint = function(options) {\r\n        var opt = Flow.translateLinkOptions(options);\r\n        //默认就是直线\r\n        var connector = new Connector(opt);\r\n        return connector;\r\n    }\r\n\r\n    module.exports = Link;\r\n\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/link/Link.js\n// module id = 118\n// module chunks = 0","/**\r\n * Flow静态方法类\r\n * @class fish.topo.FishTopoFlow.Flow\r\n */\r\n\r\n\r\n    var Constants = require(\"./util/FlowConstants.js\");\r\n    var GroupNode = require(\"./node/GroupNode.js\");\r\n    var util = require(\"../../fish-topo-core/lib/util.js\");\r\n    var Flow = {\r\n        FLOW_TYPE: \"elementType\",\r\n        LINK: \"connection\",\r\n        RECT: \"Rect\",\r\n        Group: 'Group',\r\n        IMAGE: 'Image',\r\n        TEXT: 'Text',\r\n        CIRCLE: 'Circle',\r\n        SECTOR: 'Sector',\r\n        RING: 'Ring',\r\n        POLYGON: 'Polygon',\r\n        POLYLINE: 'Polyline',\r\n        LINE: 'Line',\r\n        BEZIERCURVE: 'Beziercurve',\r\n        ARC: 'Arc',\r\n        SCENE:'scene',\r\n\r\n        /**\r\n         * @method setUserData\r\n         * 设置用户数据\r\n         * @param {Object} node 需要设置数据的节点\r\n         * @param {Object} obj 数据\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //设置自定义数据\r\n         *      this.fishTopo.Flow.setUserData(rect, { customObj: \"rect\" });\r\n         */\r\n        setUserData: function(node, obj) {\r\n            node.model.set(Constants.USERDATA, obj);\r\n        },\r\n        /**\r\n         * 获取设置的用户数据\r\n         * @param {Object} node 需要获取数据的节点\r\n         * @return {String}      数据\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //获取自定义数据\r\n         *      this.fishTopo.Flow.getUserData(rect);\r\n         */\r\n        getUserData: function(node) {\r\n            var userData = node.model.get(Constants.USERDATA);\r\n            if (util.isUndefined(userData)) {\r\n                userData = {};\r\n            }\r\n            return userData;\r\n        },\r\n        /**\r\n         * 判断是否是连线\r\n         * @param {Object} model 对象的model\r\n         * @return {Boolean}      是 否\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //判断是否是连线\r\n         *      var nodeModel = e.target.model;\r\n         *      if (this.fishTopo.Flow.isLink(nodeModel)) { return true;}\r\n         */\r\n        isLink: function(model) {\r\n            var elementType = model.get(Flow.FLOW_TYPE);\r\n            return elementType == Flow.LINK;\r\n        },\r\n        /**\r\n         * 判断是否是节点\r\n         * @param {Object} model 对象的model\r\n         * @return {Boolean}      是 否\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //判断是否是节点\r\n         *      var nodeModel = e.target.model;\r\n         *      if (this.fishTopo.Flow.isNode(nodeModel)) { return true;}\r\n         */\r\n\r\n        isNode: function(model) {\r\n            var elementType = model.get(Flow.FLOW_TYPE);\r\n            var isNode;\r\n            if(elementType !=  Flow.LINK && elementType !=  Flow.SCENE){\r\n                isNode = true;\r\n            }else{\r\n                isNode = false;\r\n            }\r\n            return isNode;\r\n        },\r\n\r\n        isInGroup: function(node) {\r\n            return node.parent && node.parent instanceof GroupNode;\r\n        },\r\n\r\n        isGroupNode: function(node) {\r\n            return node instanceof GroupNode;\r\n        },\r\n\r\n        /**\r\n         * 判断节点是否是矩形节点\r\n         * @param {Object} model 节点的model\r\n         * @return {Boolean}      是 否\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //判断是否是矩形节点\r\n         *      var nodeModel = e.target.model;\r\n         *      if (this.fishTopo.Flow.isRect(nodeModel)) { return true;}\r\n         */\r\n        isRect: function(model) {\r\n            var elementType = model.get(Flow.FLOW_TYPE);\r\n            return  elementType == Flow.RECT;\r\n        },\r\n        /**\r\n         * 判断节点是否是图片节点\r\n         * @param {Object} model 节点的model\r\n         * @return {Boolean}      是 否\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //判断是否是图片节点\r\n         *      var nodeModel = e.target.model;\r\n         *      if (this.fishTopo.Flow.isImage(nodeModel)) { return true;}\r\n         */\r\n        isImage: function(model) {\r\n            var elementType = model.get(Flow.FLOW_TYPE);\r\n            return elementType == Flow.IMAGE;\r\n        },\r\n        /**\r\n         * 判断节点是否是文字节点\r\n         * @param {Object} model 节点的model\r\n         * @return {Boolean}      是 否\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //判断是否是文字节点\r\n         *      var nodeModel = e.target.model;\r\n         *      if (this.fishTopo.Flow.isText(nodeModel)) { return true;}\r\n         */\r\n        isText: function(model) {\r\n            var elementType = model.get(Flow.FLOW_TYPE);\r\n            return elementType == Flow.TEXT;\r\n        },\r\n        /**\r\n         * 判断节点是否是圆形节点\r\n         * @param {Object} model 节点的model\r\n         * @return {Boolean}      是 否\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //判断是否是圆形节点\r\n         *      var nodeModel = e.target.model;\r\n         *      if (this.fishTopo.Flow.isCircle(nodeModel)) { return true;}\r\n         */\r\n        isCircle: function(model) {\r\n            var elementType = model.get(Flow.FLOW_TYPE);\r\n            return elementType == Flow.CIRCLE;\r\n        },\r\n        /**\r\n         * 获取节点的类型\r\n         * @param {Object} model 节点的model\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //获取节点类型\r\n         *      var nodeModel = e.target.model;\r\n         *      return this.fishTopo.Flow.getType(nodeModel);\r\n         */\r\n        getType: function(model) {\r\n            var elementType = model.get(Flow.FLOW_TYPE);\r\n            return elementType;\r\n        },\r\n        translateLinkOptions: function(options) {\r\n            if (options) {\r\n                if (options.pos) {\r\n                    var arrPos = options.pos.split(\",\");\r\n                    if (arrPos.length >= 2) {\r\n                        if (!options.position) {\r\n                            options.position = {};\r\n                        }\r\n                        options.position.startPos = arrPos[0];\r\n                        options.position.endPos = arrPos[1];\r\n                    }\r\n                }\r\n                if (options.text && options.text.color) {\r\n                    options.text.textFill = options.text.color;\r\n                }\r\n            }\r\n            return options;\r\n        }\r\n    };\r\n\r\n    module.exports = Flow;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/Flow.js\n// module id = 119\n// module chunks = 0","/**\r\n * 折线<br>\r\n * @class fishTopoFlow.link.Fold\r\n * @extends fishTopoFlow.link\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var link = fishTopoFlow.link;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       //节点\r\n *       function newNode(x, y, w, h) {\r\n *           var rect = new node.Rect({\r\n *               shape: {width: w,height: h},\r\n *               position: [x, y],\r\n *               style: {fill: \"#167CFF\"}\r\n *           });\r\n *           fishTopo.add(rect);\r\n *           return rect;\r\n *       }\r\n *       //折线\r\n *       function newFoldLink(startNode, endNode, text, direction, dashedPattern) {\r\n *           var flink = new link.Fold(startNode, endNode, {\r\n *               style: {lineDash: [dashedPattern]},\r\n *               text: {text: text},\r\n *               pos: direction\r\n *           })\r\n *           fishTopo.add(flink);\r\n *           return flink;\r\n *       }\r\n *       var from = newNode(100, 40, 30, 30);\r\n *       var to = newNode(300, 80, 30, 30);\r\n *       newFoldLink(from, to, '折线');\r\n */\r\n\r\n    var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var Flow = require(\"../Flow\");\r\n\r\n    function Fold(startNode,endNode,options) {\r\n        //折线\r\n        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_JAGGED}}, options, true);\r\n        opt = Flow.translateLinkOptions(opt);\r\n        var connector = new Connector(opt);\r\n        connector.startNode = startNode;\r\n        connector.endNode = endNode;\r\n\r\n        return connector;\r\n    }\r\n\r\n    /**\r\n     * @method createByPoint\r\n     * 用户指定连线的点，来进行画线\r\n     * @param  {Object} options 线段选项\r\n     * @param {Object} [options.style] 节点的样式\r\n     * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n     * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n     * @param {Object} [options.symbol] 线段的箭头\r\n     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]\r\n     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]\r\n     * @param {Number} [options.symbol.offset] 设置箭头在连线上的偏移量，默认是0；offset最大值不能超过options.bundleOffset(默认30) 设置的值 since V2.3.0\r\n     * @param {Object} [options.text] 线段上的文字\r\n     * @param {String} [options.text.text] 线段上的文字内容\r\n     * @param {String} [options.text.color] 线段上的文字颜色\r\n     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]\r\n     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n     * @param {String} [options.position] 指定线段位置\r\n     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n     * @param {Object} [options.position.startOffset] 线段开始位置的偏移\r\n     * @param {Object} [options.position.endOffset] 线段结束位置的偏移\r\n     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]\r\n     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n     * @param {Object} [options.effect] 线上动态效果\r\n     * @param {String} [options.effect.show] 是否显示箭头动效\r\n     * @param {Number} [options.effect.period] 动效移动速度\r\n     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n     * @param {Number} [options.z] 连线的层级，越大越在前面显示\r\n     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)\r\n     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)\r\n     */\r\n    Fold.createByPoint = function(options) {\r\n        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_JAGGED}}, options, true);\r\n        opt = Flow.translateLinkOptions(opt);\r\n        var connector = new Connector(opt);\r\n        return connector;\r\n    }\r\n    module.exports = Fold;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/link/Fold.js\n// module id = 120\n// module chunks = 0","/**\r\n * 曲线<br>\r\n * @class fishTopoFlow.link.Curve\r\n * @extends fishTopoFlow.link\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var link = fishTopoFlow.link;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       //节点\r\n *       function newNode(x, y, w, h) {\r\n *           var rect = new node.Rect({\r\n *               shape: {width: w,height: h},\r\n *               position: [x, y],\r\n *               style: {fill: \"#167CFF\"}\r\n *           });\r\n *           fishTopo.add(rect);\r\n *           return rect;\r\n *       }\r\n *       //曲线\r\n *       function newCurveLink(startNode, endNode, text, direction, dashedPattern) {\r\n *           var clink = new link.Curve(startNode, endNode, {\r\n *               style: {lineDash: [dashedPattern]},\r\n *               text: {text: text},\r\n *               pos: direction\r\n *           })\r\n *           fishTopo.add(clink);\r\n *           return clink;\r\n *       }\r\n *       var from = newNode(100, 40, 30, 30);\r\n *       var to = newNode(300, 80, 30, 30);\r\n *       newCurveLink(from, to, '曲线');\r\n */\r\n\r\n    var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var Flow = require(\"../Flow\");\r\n    function Curve(startNode,endNode,options) {\r\n        //曲线\r\n        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_CURVE}}, options, true);\r\n        opt = Flow.translateLinkOptions(opt);\r\n\r\n        var connector = new Connector(opt);\r\n        connector.startNode = startNode;\r\n        connector.endNode = endNode;\r\n\r\n        return connector;\r\n    }\r\n    /**\r\n     * @method createByPoint\r\n     * 用户指定连线的点，来进行画线\r\n     * @param  {Object} options 线段选项\r\n     * @param {Object} [options.style] 节点的样式\r\n     * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n     * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n     * @param {Object} [options.symbol] 线段的箭头\r\n     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]\r\n     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]\r\n     * @param {Object} [options.text] 线段上的文字\r\n     * @param {String} [options.text.text] 线段上的文字内容\r\n     * @param {String} [options.text.color] 线段上的文字颜色\r\n     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]\r\n     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n     * @param {String} [options.position] 指定线段位置\r\n     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n     * @param {Object} [options.position.startOffset] 线段开始位置的偏移\r\n     * @param {Object} [options.position.endOffset] 线段结束位置的偏移\r\n     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]\r\n     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n     * @param {Object} [options.effect] 线上动态效果\r\n     * @param {String} [options.effect.show] 是否显示箭头动效\r\n     * @param {Number} [options.effect.period] 动效移动速度\r\n     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n     * @param {Number} [options.z] 连线的层级，越大越在前面显示\r\n     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)\r\n     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)\r\n     */\r\n    Curve.createByPoint = function(options) {\r\n        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_CURVE}}, options, true);\r\n        opt = Flow.translateLinkOptions(opt);\r\n        var connector = new Connector(opt);\r\n        return connector;\r\n    }\r\n    module.exports = Curve;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/link/Curve.js\n// module id = 121\n// module chunks = 0","/**\r\n * 链路 支持线上多文本展示， 最大的不同是text.text对象为数组类型，表示多个文本的数据。数组元素可以为字符串，表示每个文本的名字；也可以是个对象，对象中必须指定text属性，其值为文本的名字，其余属性则为业务侧自定义的<br>\r\n * @class fishTopoFlow.link.Chain\r\n * @extends fishTopoFlow.link\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var link = fishTopoFlow.link;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       //节点\r\n *       function newNode(x, y, w, h) {\r\n *           var rect = new node.Rect({\r\n *               shape: {width: w,height: h},\r\n *               position: [x, y],\r\n *               style: {fill: \"#167CFF\"}\r\n *           });\r\n *           fishTopo.add(rect);\r\n *           return rect;\r\n *       }\r\n *       //节点间链路\r\n *       function newChain(startNode, endNode, text, dashedPattern) {\r\n *           var slink = new link.Chain(startNode, endNode, {\r\n *               style: {lineDash: [dashedPattern]},\r\n *               text: {text: text}\r\n *           })\r\n *           fishTopo.add(slink);\r\n *           return slink;\r\n *       }\r\n *       var from = newNode(100, 60, 30, 30);\r\n *       var to = newNode(300, 60, 30, 30);\r\n *       newChain(from, to, [{text: '倾斜文本1', linkId: 100}, {text: '倾斜文本2', linkId: 111}, {text: '倾斜文本3', linkId: 112}], 5);\r\n */\r\n\r\n    var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n    var Flow = require(\"../Flow\");\r\n\r\n    function Chain(startNode,endNode,options) {\r\n        options.style.lineType = Connector.TYPE_CHAIN\r\n        var opt = Flow.translateLinkOptions(options);\r\n        var connector = new Connector(opt);\r\n        connector.startNode = startNode;\r\n        connector.endNode = endNode;\r\n\r\n        return connector;\r\n    }\r\n    /**\r\n     * @method createByPoint\r\n     * 用户指定连线的点，来进行画线\r\n     * @param  {Object} options 线段选项\r\n     * @param {Object} [options.style] 节点的样式\r\n     * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n     * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n     * @param {Object} [options.symbol] 线段的箭头\r\n     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]\r\n     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]\r\n     * @param {Number} [options.symbol.offset] 设置箭头在连线上的偏移量，默认是0 since V2.3.0\r\n     * @param {Object} [options.text] 线段上的文字\r\n     * @param {Object} [options.text.text] 为数组类型，表示多个文本的数据。数组元素可以为字符串，表示每个文本的名字；也可以是个对象，对象中必须指定text属性，其值为文本的名字，其余属性则为业务侧自定义的\r\n     * @param {String} [options.text.color] 线段上的文字颜色\r\n     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]\r\n     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n     * @param {String} [options.position] 指定线段位置\r\n     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n     * @param {Object} [options.position.startOffset] 线段开始位置的偏移[x,y]   eg. startOffset:[0,10] 在x上偏移0 y上偏移10\r\n     * @param {Object} [options.position.endOffset] 线段结束位置的偏移[x,y]   eg. startOffset:[0,10] 在x上偏移0 y上偏移10\r\n     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]\r\n     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n     * @param {Object} [options.effect] 线上动态效果\r\n     * @param {String} [options.effect.show] 是否显示箭头动效\r\n     * @param {Number} [options.effect.period] 动效移动速度\r\n     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n     * @param {Number} [options.z] 连线的层级，越大越在前面显示\r\n     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)\r\n     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)\r\n     */\r\n    Chain.createByPoint = function(options) {\r\n        var opt = Flow.translateLinkOptions(options);\r\n        var connector = new Connector(opt);\r\n        return connector;\r\n    }\r\n\r\n    module.exports = Chain;\r\n\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/link/Chain.js\n// module id = 122\n// module chunks = 0","/**\r\n * 连线操作类\r\n * @author miao.cunzhi\r\n */\r\n\r\n    var symbolUtil = require('../shapes/Symbol');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var icon = require('./IconOperation');\r\n    function LineOperationManager(connectionManager, api) {\r\n        this.lineOperations = [],\r\n        this.isEdit = true;\r\n        this.connectionManager = connectionManager;\r\n        this._api = api;\r\n    }\r\n\r\n    /**\r\n     *  this.lineOperationManager.addIcon(key, options);\r\n     */\r\n    LineOperationManager.prototype.addIcon = function(key, options) {\r\n        //判断是小图标否存在 ，存在则直接返回\r\n        var lineOperationIcon = zrUtil.find(options.lineNode.icons, function(icon) {\r\n            return icon.key === key;\r\n        });\r\n\r\n        if (lineOperationIcon) {\r\n            this.bindOperation(options.lineNode);\r\n            return;\r\n        }else {\r\n            var lineOperation = this.creatOperation(key, options);\r\n            this._api._getParentZr().add(lineOperation);\r\n            this.bindOperation(options.lineNode);\r\n            return lineOperation;\r\n        }\r\n    }\r\n\r\n\r\n    LineOperationManager.prototype.creatOperation = function(key, options) {\r\n        var lineOperation = symbolUtil.createSymbol(options.iconPath, 0, 0, options.width || 15, options.height || 15, 0, options.color||'#aaaaac');\r\n        lineOperation.key = key;\r\n        lineOperation._width =  options.width || 15;  // path情况下无法计算\r\n        lineOperation._isLineOperationIcon = true;\r\n        lineOperation.hide();\r\n        options.lineNode.icons.push(lineOperation);\r\n        this.lineOperations.push(lineOperation);\r\n\r\n        //小图标 点击事件  如果有回调则调用回调，否则派发事件\r\n        lineOperation.on(\"click\", function(event) {\r\n            if (options.callback) {\r\n                event.data = options;\r\n                event.lineNode = options.lineNode;\r\n                options.callback(event);\r\n            } else {\r\n                var params = {};\r\n                params.event = event;\r\n                params.type = \"click\";\r\n                params.elementType = \"LineOperationIcon\";\r\n                this._api.trigger(params.type, params);\r\n            }\r\n        }.bind(this));\r\n        return lineOperation;\r\n    }\r\n\r\n    /**\r\n     * 计算小图标的位置，并显示\r\n     * @param  {[type]} connector [description]\r\n     * @return {[type]}           [description]\r\n     */\r\n    LineOperationManager.prototype.bindOperation = function(connector) {\r\n        function parentX(node) {\r\n            if (node.parent && node.parent.nodeType == \"SubProcess\") {\r\n                return node.position[0] + parentX(node.parent)\r\n            } else {\r\n                return node.position[0]\r\n            }\r\n        }\r\n    \r\n        function parentY(node) {\r\n            if (node.parent && node.parent.nodeType == \"SubProcess\") {\r\n                return node.position[1] + parentY(node.parent)\r\n            } else {\r\n                return node.position[1]\r\n            }\r\n        }\r\n\r\n        if (this.isEdit == false) {\r\n            return;\r\n        }\r\n        var pointPosition = connector.middle(), posX, posY;\r\n        if (connector.parent && connector.parent.nodeType == \"SubProcess\") {\r\n            posX = pointPosition[0] + parentX(connector.parent);\r\n            posY = pointPosition[1] + parentY(connector.parent);\r\n        } else {\r\n            posX = pointPosition[0];\r\n            posY = pointPosition[1];\r\n        }\r\n\r\n        var arrLength = zrUtil.map(connector.icons, function(icon) {\r\n            return icon._width;\r\n        });\r\n\r\n        var totalLength = zrUtil.reduce(arrLength, function(previousValue,currentValue) {\r\n            return previousValue + currentValue + 10;\r\n        }, 0 );\r\n\r\n        zrUtil.each(connector.icons, function(icon, index) {\r\n            var connectorPosition = 0;\r\n            for (var k = 0; k < index; k++) {\r\n                connectorPosition += arrLength[k] + 10;\r\n            }\r\n            icon.attr(\"position\", [posX + connectorPosition - totalLength / 2, posY + 5]);\r\n            icon.show();\r\n            icon.attachLine = connector;\r\n        })\r\n    }\r\n\r\n    LineOperationManager.prototype.hideAllLineOperation = function() {\r\n        zrUtil.each(this.lineOperations, function(lineOperation) {\r\n            lineOperation.hide();\r\n        });\r\n    }\r\n\r\n    LineOperationManager.prototype.addDeleteIcon = function(lineNode,options) {\r\n        var opts = zrUtil.defaults({\r\n            iconPath: 'path://' + icon.DEL_SVG,\r\n            width: 12,\r\n            height: 14,\r\n            lineNode: lineNode,\r\n            callback: function(e) {\r\n                this._api.remove(e.target.attachLine);//this.connectionManager.selConnector);\r\n            }.bind(this)\r\n        }, options,true);\r\n\r\n        this.addIcon(\"delete\", opts);\r\n    }\r\n\r\n    LineOperationManager.prototype.addChangeLineTypeIcon = function(lineNode,options) {\r\n        var opts = zrUtil.defaults({\r\n            iconPath: 'path://' + icon.CHANGE_LINE_TYPE_SVG,\r\n            width: 15,\r\n            height: 15,\r\n            lineNode: lineNode,\r\n            callback: function () {\r\n                this._api.changeSelectConnectorType();\r\n            }.bind(this)\r\n        }, options,true);\r\n\r\n        this.addIcon(\"change\", opts)\r\n    }\r\n\r\n    module.exports = LineOperationManager;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/manager/LineOperationManager.js\n// module id = 123\n// module chunks = 0","'use strict';\n/**\r\n * fishTopoFlow的layout对象，框架提供的布局都放在这个对象下。通过addCustomLayout方法添加自定义布局\r\n * @class fishTopoFlow.layout\r\n * @abstract\r\n */\r\n\r\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var flowUtil = require(\"../util/FlowUtil\");\r\n    var HLayout = require('./HLayout');\r\n    var VLayout = require('./VLayout');\r\n    var TreeLayout = require('./TreeLayout');\r\n    var ForceLayout = require('./ForceLayout');\r\n    var parsePercent = flowUtil.parsePercent;\r\n    var Tree = require('../data/Tree');\r\n    var layout = {};\r\n    layout.HLayout = HLayout;\r\n    layout.VLayout = VLayout;\r\n    layout.TreeLayout = TreeLayout;\r\n    layout.ForceLayout = ForceLayout;\r\n    layout.Tree = Tree\r\n\r\n    /**\r\n     * @method addCustomLayout\r\n     * 添加自定义布局类\r\n     * @param {Object} customLayout 自定义布局的类\r\n     */\r\n    layout.addCustomLayout = function(customLayout) {\r\n        layout.customLayout = customLayout;\r\n    }\r\n\r\n\r\n    layout.getLayoutRect = function (positionInfo, containerRect, margin) {\r\n        margin = flowUtil.normalizeCssArray(margin || 0);\r\n\r\n        var containerWidth = containerRect.width;\r\n        var containerHeight = containerRect.height;\r\n\r\n        var left = parsePercent(positionInfo.left, containerWidth);\r\n        var top = parsePercent(positionInfo.top, containerHeight);\r\n        var right = parsePercent(positionInfo.right, containerWidth);\r\n        var bottom = parsePercent(positionInfo.bottom, containerHeight);\r\n        var width = parsePercent(positionInfo.width, containerWidth);\r\n        var height = parsePercent(positionInfo.height, containerHeight);\r\n\r\n        var verticalMargin = margin[2] + margin[0];\r\n        var horizontalMargin = margin[1] + margin[3];\r\n        var aspect = positionInfo.aspect;\r\n\r\n        // If width is not specified, calculate width from left and right\r\n        if (isNaN(width)) {\r\n            width = containerWidth - right - horizontalMargin - left;\r\n        }\r\n        if (isNaN(height)) {\r\n            height = containerHeight - bottom - verticalMargin - top;\r\n        }\r\n\r\n        // If width and height are not given\r\n        // 1. Graph should not exceeds the container\r\n        // 2. Aspect must be keeped\r\n        // 3. Graph should take the space as more as possible\r\n        if (isNaN(width) && isNaN(height)) {\r\n            if (aspect > containerWidth / containerHeight) {\r\n                width = containerWidth * 0.8;\r\n            }\r\n            else {\r\n                height = containerHeight * 0.8;\r\n            }\r\n        }\r\n\r\n        if (aspect != null) {\r\n            // Calculate width or height with given aspect\r\n            if (isNaN(width)) {\r\n                width = aspect * height;\r\n            }\r\n            if (isNaN(height)) {\r\n                height = width / aspect;\r\n            }\r\n        }\r\n\r\n        // If left is not specified, calculate left from right and width\r\n        if (isNaN(left)) {\r\n            left = containerWidth - right - width - horizontalMargin;\r\n        }\r\n        if (isNaN(top)) {\r\n            top = containerHeight - bottom - height - verticalMargin;\r\n        }\r\n\r\n        // Align left and top\r\n        switch (positionInfo.left || positionInfo.right) {\r\n            case 'center':\r\n                left = containerWidth / 2 - width / 2 - margin[3];\r\n                break;\r\n            case 'right':\r\n                left = containerWidth - width - horizontalMargin;\r\n                break;\r\n        }\r\n        switch (positionInfo.top || positionInfo.bottom) {\r\n            case 'middle':\r\n            case 'center':\r\n                top = containerHeight / 2 - height / 2 - margin[0];\r\n                break;\r\n            case 'bottom':\r\n                top = containerHeight - height - verticalMargin;\r\n                break;\r\n        }\r\n        // If something is wrong and left, top, width, height are calculated as NaN\r\n        left = left || 0;\r\n        top = top || 0;\r\n        if (isNaN(width)) {\r\n            // Width may be NaN if only one value is given except width\r\n            width = containerWidth - left - (right || 0);\r\n        }\r\n        if (isNaN(height)) {\r\n            // Height may be NaN if only one value is given except height\r\n            height = containerHeight - top - (bottom || 0);\r\n        }\r\n\r\n        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\r\n        rect.margin = margin;\r\n        return rect;\r\n    };\r\n\r\n\r\n    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {\r\n        var h = !opt || !opt.hv || opt.hv[0];\r\n        var v = !opt || !opt.hv || opt.hv[1];\r\n        var boundingMode = opt && opt.boundingMode || 'all';\r\n\r\n        if (!h && !v) {\r\n            return;\r\n        }\r\n\r\n        var rect;\r\n        if (boundingMode === 'raw') {\r\n            rect = (el.type === 'group' || el.type === 'GroupNode')\r\n                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)\r\n                : el.getBoundingRect();\r\n        }\r\n        else {\r\n            rect = el.getBoundingRect();\r\n            if (el.needLocalTransform()) {\r\n                var transform = el.getLocalTransform();\r\n                // Notice: raw rect may be inner object of el,\r\n                // which should not be modified.\r\n                rect = rect.clone();\r\n                rect.applyTransform(transform);\r\n            }\r\n        }\r\n\r\n        positionInfo = layout.getLayoutRect(\r\n            zrUtil.defaults(\r\n                {width: rect.width, height: rect.height},\r\n                positionInfo\r\n            ),\r\n            containerRect,\r\n            margin\r\n        );\r\n\r\n        // Because 'tranlate' is the last step in transform\r\n        // (see zrender/core/Transformable#getLocalTransfrom),\r\n        // we can just only modify el.position to get final result.\r\n        var elPos = el.position;\r\n        var dx = h ? positionInfo.x - rect.x : 0;\r\n        var dy = v ? positionInfo.y - rect.y : 0;\r\n\r\n        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\r\n    };\r\n\r\n\r\n    module.exports = layout;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/layout/layout.js\n// module id = 124\n// module chunks = 0","/**\r\n * 水平布局<br>\r\n * @class fishTopoFlow.layout.HLayout\r\n * @extends fishTopoFlow.layout\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var layout = fishTopoFlow.layout;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       function newNode(group,text) {\r\n *           var rect = new node.Rect({\r\n *                   shape:{width:25,height:25},\r\n *                   style: {text:text,fill: \"#167CFF\"}\r\n *               });\r\n *           group.add(rect);\r\n *           return rect;\r\n *       }\r\n *       var hGroup =  new node.Group({\r\n *           style: {\r\n *               text: \"水平布局\",\r\n *               textPosition:\"bottom\"\r\n *           },\r\n *           position:[50,50],\r\n *           layout : new layout.HLayout({gap:10})\r\n *       });\r\n *       newNode(hGroup, \"A_1\")\r\n *       newNode(hGroup, \"A_2\");\r\n *       newNode(hGroup, \"A_3\");\r\n *       newNode(hGroup, \"A_4\");\r\n *       newNode(hGroup, \"A_5\");\r\n *       fishTopo.add(hGroup);\r\n */\r\n\r\n            var zrUtil = require('zrender/lib/core/util');\r\n             var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n            function HLayout(opts) {\r\n                /**\r\n                 * @cfg {Number} gap 节点之间的间隔\r\n                 */\r\n                /**\r\n                 * @cfg {Number} maxHeight=Infinity 组最大的宽度，如果超过会换行\r\n                 */\r\n                var defaultOptions = {\r\n                    gap: 5,\r\n                    maxWidth: Infinity\r\n                };\r\n                this.options = zrUtil.merge(defaultOptions, opts, true);\r\n            }\r\n            /**\r\n             * @method run\r\n             * 进行垂直布局，一般不需要调用，直接将布局类 赋值给组layout 属性即可\r\n             * @param {Object} group 需要进行垂直布局的组\r\n             */\r\n            HLayout.prototype.run = function(group)  {\r\n                var x = 0;\r\n                var y = 0;\r\n                var currentLineMaxSize = 0;\r\n                group.each(function (child, idx) {\r\n                    if (child instanceof Connector) {\r\n                        return;\r\n                    }\r\n\r\n                    var position = child.position;\r\n                    var rect = child.getBoundingRect();\r\n                    var nextChild = group.childAt(idx + 1);\r\n                    var nextChildRect = nextChild && nextChild.getBoundingRect();\r\n                    var nextX;\r\n\r\n                    var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\r\n                    nextX = x + moveX;\r\n                    // Wrap when width exceeds maxWidth or meet a `newline` group\r\n                    if (nextX > this.options.maxWidth || child.newline) {\r\n                        x = 0;\r\n                        nextX = moveX;\r\n                        y += currentLineMaxSize + parseInt(this.options.gap,10);\r\n                        currentLineMaxSize = rect.height;\r\n                    } else {\r\n                        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\r\n                    }\r\n\r\n                    if (child.newline) {\r\n                        return;\r\n                    }\r\n\r\n                    position[0] = x;\r\n                    position[1] = y;\r\n                    x = nextX + this.options.gap;\r\n                },this);\r\n\r\n                return HLayout;\r\n            }\r\n        module.exports = HLayout;\r\n\r\n/**\r\n * @method addCustomLayout\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/layout/HLayout.js\n// module id = 125\n// module chunks = 0","/**\r\n * 垂直布局<br>\r\n * @class fishTopoFlow.layout.VLayout\r\n * @extends fishTopoFlow.layout\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var layout = fishTopoFlow.layout;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       function newNode(group,text) {\r\n *           var rect = new node.Rect({\r\n *                   shape:{width:25,height:25},\r\n *                   style: {text:text,fill: \"#167CFF\"}\r\n *               });\r\n *           group.add(rect);\r\n *           return rect;\r\n *       }\r\n *       var vGroup =  new node.Group({\r\n *           style: {\r\n *               text: \"垂直布局\",\r\n *               textPosition:\"bottom\"\r\n *           },\r\n *           position:[60,60],\r\n *           layout : new layout.VLayout({gap:10})\r\n *       });\r\n*\r\n *       newNode(vGroup, \"A_1\")\r\n *       newNode(vGroup, \"A_2\");\r\n *       newNode(vGroup, \"A_3\");\r\n *       newNode(vGroup, \"A_4\");\r\n *       newNode(vGroup, \"A_5\");\r\n *       fishTopo.add(vGroup);\r\n */\r\n\r\n            var zrUtil = require('zrender/lib/core/util');\r\n            var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n            function VLayout(opts) {\r\n                /**\r\n                 * @cfg {Number} gap 节点之间的间隔\r\n                 */\r\n                /**\r\n                 * @cfg {Number} maxHeight=Infinity 组最大的高度，如果超过会换行\r\n                 */\r\n                var defaultOptions = {\r\n                    gap: 5,\r\n                    maxHeight: Infinity\r\n                };\r\n                this.options = zrUtil.merge(defaultOptions, opts, true);\r\n            }\r\n\r\n            /**\r\n             * @method run\r\n             * 进行垂直布局，一般不需要调用，直接将布局类 赋值给组layout 属性即可\r\n             * @param {Object} group 需要进行垂直布局的组\r\n             */\r\n            VLayout.prototype.run = function(group)  {\r\n                var x = 0;\r\n                var y = 0;\r\n                var currentLineMaxSize = 0;\r\n                group.each(function (child, idx) {\r\n                    if (child instanceof Connector) {\r\n                        return;\r\n                    }\r\n\r\n                    var position = child.position;\r\n                    var rect = child.getBoundingRect();\r\n                    var nextChild = group.childAt(idx + 1);\r\n                    var nextChildRect = nextChild && nextChild.getBoundingRect();\r\n                    var nextY;\r\n\r\n                    var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\r\n                    nextY = y + moveY;\r\n                    // Wrap when width exceeds maxHeight or meet a `newline` group\r\n                    if (nextY > this.options.maxHeight || child.newline) {\r\n                        x += currentLineMaxSize + parseInt(this.options.gap,10);\r\n                        y = 0;\r\n                        nextY = moveY;\r\n                        currentLineMaxSize = rect.width;\r\n                    }\r\n                    else {\r\n                        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\r\n                    }\r\n\r\n                    if (child.newline) {\r\n                        return;\r\n                    }\r\n\r\n                    position[0] = x;\r\n                    position[1] = y;\r\n                    y = nextY + this.options.gap;\r\n                },this);\r\n\r\n                return VLayout;\r\n            }\r\n        module.exports = VLayout;\r\n\r\n\r\n/**\r\n * @method addCustomLayout\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/layout/VLayout.js\n// module id = 126\n// module chunks = 0","/**\r\n * 树布局<br>\r\n * @class fishTopoFlow.layout.TreeLayout\r\n * @extends fishTopoFlow.layout\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var layout = fishTopoFlow.layout;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n *       function newNode(data) {\r\n *           var circle = new node.Circle({\r\n *               shape: { r: 15 },\r\n *               style: { fill: \"#4883b4\" },\r\n *               name: data.name\r\n *           });\r\n *           return circle;\r\n *       }\r\n *       var options = {\r\n *           createNodeFunction: newNode,\r\n *           data:[{\r\n *               name: '根节点',\r\n *               children: [\r\n *                   {   name: '节点1',\r\n *                       children: [\r\n *                           {name: '叶子节点1'},\r\n *                           {name: '叶子节点2'},\r\n *                           {name: '叶子节点3'},\r\n *                           {name: '叶子节点4'},\r\n *                           {name: '叶子节点5'},\r\n *                           {name: '叶子节点6'}\r\n *                       ]\r\n *                   },\r\n *                   {   name: '节点2',\r\n *                       children: [\r\n *                           {name: '叶子节点7'},\r\n *                           {name: '叶子节点8'}]\r\n *                   },\r\n *                   {   name: '节点3',\r\n *                       children: [\r\n *                           {name: '叶子节点9'},\r\n *                           {name: '叶子节点10'},\r\n *                           {name: '叶子节点11'},\r\n *                           {name: '叶子节点12'}\r\n *                       ]\r\n *                   }\r\n *               ]\r\n *           }]\r\n *       }\r\n*\r\n *       var treeLayout = new layout.TreeLayout({\r\n *           fishTopo:fishTopo,\r\n *           rootLocation:{x:'center', y:50},\r\n *           nodePadding:1\r\n *       });\r\n *       treeLayout.doLayout(options);\r\n */\r\n\r\n            var zrUtil = require('zrender/lib/core/util');\r\n            var BoundingRect = require('zrender/lib/core/BoundingRect');\r\n            var flowUtil = require('../util/FlowUtil');\r\n            var parsePercent = flowUtil.parsePercent;\r\n            var TreeData = require('../data/Tree');  // 数据依赖\r\n            var TreeHelper = require(\"./treeHelper\"); // 布局依赖\r\n            function TreeLayout(opts) {\r\n                /**\r\n                 * @cfg {Object} fishTopo fishTopo实例\r\n                 */\r\n                /**\r\n                 * @cfg {Object} rootLocation 根节点坐标，支持绝对值（px）、字符和百分比 'center' | 'left' | 'right' | 'x%' | number\r\n                 * @cfg {Number|String} rootLocation.x  根节点横坐标，支持绝对值（px）、字符和百分比 'center' | 'left' | 'right' | 'x%' | number\r\n                 * @cfg {Number|String} rootLocation.y  根节点纵坐标，支持绝对值（px）、字符和百分比 'center' | 'left' | 'right' | 'x%' | number\r\n                 */\r\n                /**\r\n                 * @cfg {Number} layerPadding=100 层间距,默认:100\r\n                 */\r\n                /**\r\n                 * @cfg {Number} nodePadding=30 节点间距,默认:30\r\n                 */\r\n                /**\r\n                 *@cfg {String} direction 树的方向可选：'vertical' | 'horizontal' ,默认:vertical\r\n                 */\r\n                /**\r\n                 * @cfg {Object} lineStyle 连线的样式  参见{@link fishTopoFlow.link#constructor 构造函数options参数}\r\n                 */\r\n                var defaultOptions = {\r\n                    orient:'vertical',  // vertical,horizontal\r\n                    nodePadding:30, //节点间距\r\n                    layerPadding:100,  //层间距\r\n                    rootLocation: {x:100, y:230}, // 根节点坐标，支持绝对值（px）、字符和百分比\r\n                    animateTime : 500,\r\n                    lineStyle: {pos:'bottom,top', symbol:{type:'none'}}\r\n                };\r\n                if (opts.orient === 'horizontal') {\r\n                    defaultOptions.lineStyle.pos = 'right,left';\r\n                }\r\n\r\n                this.options = zrUtil.defaults(defaultOptions, opts, true);\r\n                this.nodePadding = this.options.nodePadding;\r\n                this.layerPadding = this.options.layerPadding;\r\n                this.fishTopo = this.options.fishTopo;\r\n                this._layerOffsets = [];\r\n                this._layers = [];\r\n                this._hideNodes = [];\r\n            }\r\n\r\n            /**\r\n             * @method layoutByRootNode\r\n             * 根据根节点及连线的关系 ，生成树\r\n             * @param {Object} rootNode 树的根节点\r\n             * @return {Object} boundingbox 包围和\r\n             */\r\n            TreeLayout.prototype.layoutByRootNode = function(rootNode) {\r\n                var connectors = this.fishTopo.connectionManager.connectors;  //所有线段的数组\r\n                //递归生成树型数据结构\r\n                function traverseNode(parentNode, treeData) {\r\n                    var childrenData = [];\r\n                    var childrenNode = [];\r\n                    //1.根据连线，找出起始节点的所有子节点\r\n                    zrUtil.each(connectors, function(connector) {\r\n                        if(connector.startNode === parentNode) {\r\n                            if(!connector.endNode.exclude) {   //如果是排斥的节点则不加入\r\n                                childrenNode.push(connector.endNode);\r\n                            }\r\n                        }\r\n                    })\r\n\r\n                    if (childrenNode.length > 0) {\r\n                        //2.遍历子节点\r\n                        zrUtil.each(childrenNode, function(node) {\r\n                             var nodeData = {name: node.id, node:node};\r\n                             childrenData.push(nodeData);\r\n                             traverseNode(node, nodeData);\r\n                        })\r\n                    }\r\n                    //3.将子节点放入children中\r\n                    if (childrenData.length > 0) {\r\n                        treeData.children = childrenData;\r\n                    }\r\n                }\r\n                var rootTreeData = {name: rootNode.id, node:rootNode};\r\n                traverseNode(rootNode,rootTreeData);\r\n                return this.doLayout({data:[rootTreeData]}, true);\r\n            }\r\n\r\n            /**\r\n             * @method doLayout\r\n             * 根据传过来树型结构数据进行树布局\r\n             * @param {Object} treeData 树形数据\r\n             * @param {Function} treeData.createNodeFunction=null 创建节点的函数 会把data中的数据 传递过去  如果没有默认就是创建圆形\r\n             * @param {Object} treeData.data 创建树布局数据（必须包括name属性）\r\n             * @param {boolean} isNotBuildLink=true 默认是自动创建连线，传true则不会自动创建连线\r\n             * @return {Object} boundingbox 包围和\r\n             */\r\n            TreeLayout.prototype.doLayout = function(treeData, isNotBuildLink)  {\r\n                var rootData = treeData.data[0];\r\n                this.treeData = treeData;\r\n\r\n                this.tree = TreeData.fromOptionData(rootData.name, rootData.children);\r\n                this.tree.root.data = rootData;\r\n\r\n\r\n                this._buildNode(treeData);\r\n\r\n                //根据root坐标 方向 对每个节点的坐标进行映射\r\n                this._setTreeShape(function() {\r\n                    this._buildAllLink(isNotBuildLink);\r\n                }.bind(this));\r\n\r\n                return this.getBoundingRect();\r\n            }\r\n\r\n            /**\r\n             * @private\r\n             * @method _buildAllLink\r\n             * 递归画出连接线 与设置节点坐标\r\n             */\r\n             TreeLayout.prototype._buildAllLink = function (isNotBuildLink) {\r\n                this.tree.traverse(function(treeNode) {\r\n                    //画连接线\r\n                    if (treeNode.children.length > 0 && !isNotBuildLink) {\r\n                        this._buildLinkByParent(treeNode, this.treeData.createLinkFunction)\r\n                    } else {\r\n                        this.fishTopo.connectionManager.refreshLineByNode(treeNode.data.node);\r\n                    }\r\n                },this)\r\n             }\r\n\r\n\r\n            /**\r\n             * @method getBoundingRect\r\n             * 计算出树的包围和\r\n             * @return {Object} boundingbox 包围和\r\n             */\r\n            TreeLayout.prototype.getBoundingRect = function() {\r\n                var rect = null;\r\n                this.tree.traverse(function(treeNode) {\r\n                    var childRect = BoundingRect.create({x:treeNode.layout.position[0], y:treeNode.layout.position[1], width:treeNode.layout.width, height: treeNode.layout.height});\r\n                    if (!rect) rect = childRect.clone();\r\n                    rect.union(childRect);\r\n                },this)\r\n                return rect;\r\n            }\r\n\r\n\r\n\r\n            TreeLayout.prototype._setTreeShape = function(doneCallback) {\r\n                var animateCount = 0;\r\n                var treeHelper = new TreeHelper(\r\n                    {\r\n                        nodePadding: this.nodePadding,\r\n                        layerPadding: this.layerPadding\r\n                    }\r\n                );\r\n\r\n\r\n                this.tree.traverse(function(treeNode) {\r\n                    if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){\r\n                        var boundingRect = treeNode.data.node.getBoundingRect();\r\n                        treeNode.layout = {\r\n                            width: treeNode.data.node._width || boundingRect.width,\r\n                            height: treeNode.data.node._height || boundingRect.height\r\n                        }\r\n                    }\r\n\r\n                },this);\r\n                treeHelper._hideNodes = this._hideNodes;\r\n                treeHelper.run(this.tree);\r\n                // 树的方向\r\n                var orient = this.options.orient;\r\n                var rootX = this.options.rootLocation.x;\r\n                var rootY = this.options.rootLocation.y;\r\n                var zrWidth = this.fishTopo.getWidth();\r\n                var zrHeight = this.fishTopo.getHeight();\r\n                if (rootX === 'center') {\r\n                    rootX = zrWidth * 0.5;\r\n                }\r\n                else {\r\n                    rootX = parsePercent(rootX, zrWidth);\r\n                }\r\n                if (rootY === 'center') {\r\n                    rootY = zrHeight * 0.5;\r\n                }\r\n                else {\r\n                    rootY = parsePercent(rootY, zrHeight);\r\n                }\r\n                rootY = parsePercent(rootY, zrHeight);\r\n                // 水平树\r\n                if (orient === 'horizontal') {\r\n                    rootX = isNaN(rootX) ? 10 : rootX;\r\n                    rootY = isNaN(rootY) ? zrHeight * 0.5 : rootY;\r\n                }\r\n                // 纵向树\r\n                else {\r\n                    rootX = isNaN(rootX) ? zrWidth * 0.5 : rootX;\r\n                    rootY = isNaN(rootY) ? 10 : rootY;\r\n                }\r\n                // tree layout自动算出来的root的坐标\r\n                var originRootX = this.tree.root.layout.position[0];\r\n\r\n                var treeNodeCount = treeHelper.count(this.tree) - this._hideNodes.length;\r\n                var minY = Infinity;\r\n\r\n                this.tree.traverse(\r\n                    function (treeNode) {\r\n                        var x;\r\n                        var y;\r\n                        if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){\r\n                            if (orient === 'vertical' && this.options.direction === 'inverse') {\r\n                                x = treeNode.layout.position[0] - originRootX + rootX;\r\n                                y = rootY - treeNode.layout.position[1];\r\n                            }\r\n                            else if (orient === 'vertical') {\r\n                                x = treeNode.layout.position[0] - originRootX + rootX;\r\n                                y = treeNode.layout.position[1] + rootY;\r\n                            }\r\n                            else if (orient === 'horizontal' && this.options.direction === 'inverse') {\r\n                                y = treeNode.layout.position[0] - originRootX + rootY;\r\n                                x = rootX - treeNode.layout.position[1];\r\n                            }\r\n                            else if (orient === 'horizontal') {\r\n                                y = treeNode.layout.position[0] - originRootX + rootY;\r\n                                x = treeNode.layout.position[1] + rootX;\r\n                            }\r\n                            treeNode.layout.__x = x;\r\n                            treeNode.layout.__y = y;\r\n                            if (y < minY) {\r\n                                minY = y;\r\n                            }\r\n                        }\r\n                    },\r\n                    this\r\n                );\r\n\r\n                this.tree.traverse(function (treeNode) {\r\n                    if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){\r\n                        if (minY > 0) {\r\n                            treeNode.layout.position[0] = treeNode.layout.__x;\r\n                            treeNode.layout.position[1] = treeNode.layout.__y;\r\n                        } else  {\r\n                            treeNode.layout.position[0] = treeNode.layout.__x;\r\n                            treeNode.layout.position[1] = treeNode.layout.__y - minY;\r\n                        }\r\n\r\n                        treeNode.data.node.animateTo({\r\n                            position: [treeNode.layout.position[0], treeNode.layout.position[1]]\r\n                        }, this.options.animateTime, function() {\r\n                            if (++animateCount === treeNodeCount) {\r\n                                doneCallback();\r\n                            }\r\n                        }.bind(this));\r\n                        //节点有孩子才显示 收缩按钮\r\n                        if(this._hideNodes.length == 0){\r\n                            if (treeNode.children.length > 0 && treeNode.data.node._toggleShrink) {\r\n                                treeNode.data.node._toggleShrink(true);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                },this)\r\n            }\r\n\r\n            TreeLayout.prototype._buildNode = function(treeData) {\r\n                if(!treeData.createNodeFunction) {\r\n                    treeData.createNodeFunction = this._defaultCreateNodeFunction;\r\n                }\r\n                //判断一下是否有node 如果没有则自己创建\r\n                this.tree.traverse(function(treeNode) {\r\n                    if(!treeNode.data.node) {\r\n                        var createNodeFunction = treeNode.data.createNodeFunction || treeData.createNodeFunction;\r\n                        var node = createNodeFunction(treeNode.data, this);\r\n                        node._childShow = true;\r\n                        this.fishTopo.add(node);\r\n                        treeNode.data.node = node;\r\n                    }\r\n                },this);\r\n            }\r\n\r\n            TreeLayout.prototype._defaultCreateNodeFunction = function(item) {\r\n                var circle = this.fishTopo.createNode(\"Circle\",{\r\n                    shape: { r: 15 },\r\n                    style: { fill: \"#4883b4\" },\r\n                    name: item.lable || item.name\r\n                });\r\n                return circle;\r\n            }\r\n\r\n            TreeLayout.prototype._buildLinkByParent = function (parentTreeNode, createLinkFunction) {\r\n                for (var i = 0, childLength = parentTreeNode.children.length; i < childLength; i++) {\r\n                    this._buildLink(parentTreeNode, parentTreeNode.children[i], createLinkFunction);\r\n                }\r\n            };\r\n\r\n\r\n            TreeLayout.prototype._buildLink = function (startTreeNode, endTreeNode, createLinkFunction) {\r\n                    var connector = null;\r\n                    var startNode = startTreeNode.data.node;\r\n                    var endNode = endTreeNode.data.node;\r\n                    if(createLinkFunction) {\r\n                        var paramObj =  endTreeNode.data;\r\n                        paramObj.startNode = startNode;\r\n                        paramObj.endNode = endNode;\r\n                        connector = createLinkFunction(paramObj);\r\n                    } else {\r\n                        var linkStyle = this.options.lineStyle;\r\n                        if (endTreeNode.data.lineStyle) {\r\n                            linkStyle = zrUtil.merge(zrUtil.clone(linkStyle), endTreeNode.data.lineStyle, true);\r\n                        }\r\n                        connector = this.fishTopo.createLink(startNode,endNode,linkStyle)\r\n                    }\r\n                    this.fishTopo.add(connector);\r\n            };\r\n\r\n            /**\r\n             * @method addChild\r\n             * 在指定topo节点下新增一个子节点\r\n             * @param {Object} treeNode 要增加子节点的topo节点\r\n             * @param {Object} data 新增子节点的数据\r\n             * @param {Function} callback 增加完子节点之后触发的回调函数\r\n             * @return {Object} 新增加的子节点\r\n             */\r\n            TreeLayout.prototype.addChild = function (treeNode, data, callback) {\r\n                var newTreeNode = (new TreeData(data.name)).root;\r\n                newTreeNode.data = data;\r\n\r\n                var node = this.treeData.createNodeFunction(newTreeNode.data, this);\r\n                node._childShow = true;\r\n                if (treeNode.children.length >= 1) {\r\n                    node.attr('position', zrUtil.clone(treeNode.children[treeNode.children.length - 1].layout.position));\r\n                } else {\r\n                    node.attr('position', zrUtil.clone(treeNode.layout.position));\r\n                }\r\n\r\n                this.fishTopo.add(node);\r\n                newTreeNode.data.node = node;\r\n                setTimeout(function () {\r\n                    this._buildLink(treeNode, newTreeNode, this.treeData.createLinkFunction);\r\n                }.bind(this), this.options.animateTime);\r\n\r\n                treeNode.add(newTreeNode);\r\n                this.refreshPositionAndLine(callback);\r\n                return node;\r\n            };\r\n\r\n            /**\r\n             * @method toggleChild\r\n             * 展示或者隐藏选中topo节点下的子节点以及与子节点之间的连线\r\n             * @param {Object} node 树节点\r\n             */\r\n            TreeLayout.prototype.toggleChild = function (node) {\r\n                var toggleTreeNode = this.findTreeNodeByNode(node);\r\n                if (node._childShow) {\r\n                    toggleTreeNode.traverse(function (treeNode) {\r\n                        if (treeNode.data.node !== node) {\r\n                            treeNode.data.node.hide();\r\n                            if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){\r\n                                this._hideNodes.push(treeNode);\r\n                            }\r\n                            this.fishTopo.connectionManager.toggleLineByNode(treeNode.data.node, false);\r\n                            if (treeNode.children.length > 0) {\r\n                                treeNode.data.node._childShow = false;\r\n                                treeNode.data.node._toggleShrink && treeNode.data.node._toggleShrink(false);\r\n                            }\r\n                        }\r\n                    },this);\r\n                    node._childShow = false;\r\n                    node._toggleShrink && node._toggleShrink(false);\r\n                    this.refreshPositionAndLine();\r\n                } else {\r\n                    toggleTreeNode.traverse(function (treeNode) {\r\n                        if (treeNode.data.node !== node) {\r\n                            treeNode.data.node.show();\r\n                            this._hideNodes.splice(zrUtil.indexOf(this._hideNodes, treeNode),1);\r\n                            this.fishTopo.connectionManager.toggleLineByNode(treeNode.data.node, true);\r\n                            if (treeNode.children.length > 0) {\r\n                                treeNode.data.node._childShow = true;\r\n                                treeNode.data.node._toggleShrink && treeNode.data.node._toggleShrink(true);\r\n                            }\r\n                        }\r\n                    },this);\r\n                    node._childShow = true;\r\n                    node._toggleShrink && node._toggleShrink(true);\r\n                    this.refreshPositionAndLine();\r\n                }\r\n            };\r\n\r\n            /**\r\n             * @method findTreeNodeByNode\r\n             * 根据topo节点找到树的节点\r\n             * @param {Object} node topo节点\r\n             * @return {Object} \r\n             */\r\n            TreeLayout.prototype.findTreeNodeByNode = function (node) {\r\n                var returnTreeNode = null;\r\n                this.tree.traverse(function (treeNode) {\r\n                    if (treeNode.data.node === node) {\r\n                        returnTreeNode = treeNode;\r\n                    }\r\n                });\r\n                return returnTreeNode;\r\n            };\r\n\r\n            /**\r\n             * @method removeNode\r\n             * 删除选中topo节点\r\n             * @param {Object} node topo节点\r\n             * @return {Boolean} 删除是否成功\r\n             */\r\n            TreeLayout.prototype.removeNode = function (node) {\r\n                var treeNode = this.findTreeNodeByNode(node);\r\n                var parentTreeNode = treeNode.parent;\r\n                if (!parentTreeNode) return false;\r\n                //遍历 topo中删除自己及孩子节点\r\n                treeNode.traverse(function (eachTreeNode) {\r\n                    this.fishTopo.remove(eachTreeNode.data.node); //删除节点\r\n                },this)\r\n\r\n                parentTreeNode.remove(treeNode);\r\n\r\n                //判断一下父节点是不是没有了,如果没有的话,要把线与+-号给隐藏掉\r\n                if (parentTreeNode.children.length === 0) {\r\n                    parentTreeNode.data.node._hideToggle && parentTreeNode.data.node._hideToggle();\r\n                }\r\n\r\n                //重新生成数据\r\n                this.refreshPositionAndLine();\r\n                return true;\r\n            };\r\n\r\n            /**\r\n             * @method removeChildren\r\n             * 删除选中topo节点下的所有子节点\r\n             * @param {Object} node topo节点\r\n             * @return {Boolean} 删除是否成功\r\n             */\r\n            TreeLayout.prototype.removeChildren = function (node) {\r\n                var treeNode = this.findTreeNodeByNode(node);\r\n                //遍历 topo中删除孩子节点\r\n                treeNode.traverse(function (eachTreeNode) {\r\n                    if (eachTreeNode !== treeNode) {\r\n                        this.fishTopo.remove(eachTreeNode.data.node); //删除节点\r\n                    }\r\n                },this)\r\n\r\n                treeNode.removeAllChildren();\r\n                node._hideToggle && node._hideToggle(); //this._hidePath(node);\r\n\r\n                //重新生成数据\r\n                this.refreshPositionAndLine();\r\n                return true;\r\n            };\r\n\r\n            /**\r\n             * @method refreshPositionAndLine\r\n             * 刷新当前树布局中所有节点的位置和节点之间的连线\r\n             * @param {Function} callback 刷新之后所触发的回调函数\r\n             */\r\n            TreeLayout.prototype.refreshPositionAndLine = function (callback) {\r\n                this.tree.root.updateDepthAndHeight(0);\r\n                this._setTreeShape(function () {\r\n                    this.tree.traverse(function (eachTreeNode) {\r\n                        this.fishTopo.connectionManager.refreshLineByNode(eachTreeNode.data.node);\r\n                    }, this);\r\n                    callback && callback();\r\n                }.bind(this));\r\n            }\r\n\r\n            /**\r\n             * @method changePosition\r\n             * 更改当前topo节点在其兄弟节点中的位置\r\n             * @param {Object} node 树节点\r\n             * @param {String} direction 节点移动的方向，next表示往下移动，prev表示往上移动\r\n             */\r\n            TreeLayout.prototype.changePosition = function (node, direction) {\r\n                var parentNode = node.parent;\r\n                var nowIndex = zrUtil.indexOf(parentNode.children, node);\r\n                var targetIndex;\r\n                if(direction == \"next\"){\r\n                    targetIndex = nowIndex + 1;\r\n                }else if(direction == \"prev\"){\r\n                    targetIndex = nowIndex - 1;\r\n                }\r\n                var targetNode = parentNode.children[targetIndex];\r\n                if(targetNode){\r\n                    var storage = targetNode;\r\n                    parentNode.children[targetIndex] = node;\r\n                    parentNode.children[nowIndex] = storage;\r\n                }\r\n                this.refreshPositionAndLine();\r\n                this.fishTopo.trigger('treeLayout:changePosition',{\r\n                    node:node,\r\n                    parentNode:parentNode,\r\n                    targetNode:targetNode\r\n                })\r\n            }\r\n\r\n        module.exports = TreeLayout;\r\n\r\n\r\n/**\r\n * @method addCustomLayout\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/layout/TreeLayout.js\n// module id = 127\n// module chunks = 0","\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    /**\r\n     * @constructor TreeNode\r\n     * @param {string} id Node ID\r\n     * @param {Object} [data]\r\n     */\r\n    function TreeNode(id, data) {\r\n        /**\r\n         * @type {string}\r\n         */\r\n        this.id = id;\r\n        /**\r\n         * 节点的深度\r\n         * @type {number}\r\n         */\r\n        this.depth = 0;\r\n        /**\r\n         * 以当前节点为根节点的子树的高度\r\n         * @type {number}\r\n         */\r\n        this.height = 0;\r\n        /**\r\n         * 子节点列表\r\n         * @type {Array.<TreeNode>}\r\n         */\r\n        this.children = [];\r\n\r\n        /**\r\n         * @type {TreeNode}\r\n         */\r\n        this.parent = null;\r\n\r\n        /**\r\n         * 存储的用户数据\r\n         * @type {Object}\r\n         */\r\n        this.data = data || null;\r\n    }\r\n\r\n    /**\r\n     * 添加子节点\r\n     * @param {TreeNode} child\r\n     */\r\n    TreeNode.prototype.add = function (child) {\r\n        var children = this.children;\r\n        if (child.parent === this) {\r\n            return;\r\n        }\r\n\r\n        children.push(child);\r\n        child.parent = this;\r\n    };\r\n\r\n    /**\r\n     * 移除子节点\r\n     * @param {TreeNode} child\r\n     */\r\n    TreeNode.prototype.remove = function (child) {\r\n        var children = this.children;\r\n        var idx = zrUtil.indexOf(children, child);\r\n        if (idx >= 0) {\r\n            children.splice(idx, 1);\r\n            child.parent = null;\r\n        }\r\n    };\r\n\r\n     TreeNode.prototype.removeAllChildren = function () {\r\n         var children = this.children;\r\n         for (var i = 0; i < children.length; i++) {\r\n             var child = children[i];\r\n            child.parent = null;\r\n         }\r\n        this.children = [];\r\n     }\r\n\r\n    /**\r\n     * 遍历当前节点及其所有子节点\r\n     * @param  {Function} cb\r\n     * @param  {Object}   [context]\r\n     */\r\n    TreeNode.prototype.traverse = function (cb, context) {\r\n        cb.call(context, this);\r\n\r\n        for (var i = 0; i < this.children.length; i++) {\r\n            this.children[i].traverse(cb, context);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 遍历节前节点及所有子节点的数量\r\n     */\r\n    TreeNode.prototype.count = function () {\r\n        var count = 0;\r\n        this.traverse(function() {\r\n            count++;\r\n         });\r\n        return count;\r\n    }\r\n\r\n    /**\r\n     * 更新当前树及所有子树的高度和深度\r\n     * @param  {number} depth\r\n     */\r\n    TreeNode.prototype.updateDepthAndHeight = function (depth) {\r\n        var height = 0;\r\n        this.depth = depth;\r\n        for (var i = 0; i < this.children.length; i++) {\r\n            var child = this.children[i];\r\n            child.updateDepthAndHeight(depth + 1);\r\n            if (child.height > height) {\r\n                height = child.height;\r\n            }\r\n        }\r\n        this.height = height + 1;\r\n    };\r\n\r\n    /**\r\n     * @param  {string} id\r\n     * @return TreeNode\r\n     */\r\n    TreeNode.prototype.getNodeById = function (id) {\r\n        if (this.id === id) {\r\n            return this;\r\n        }\r\n        for (var i = 0; i < this.children.length; i++) {\r\n            var res = this.children[i].getNodeById(id);\r\n            if (res) {\r\n                return res;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @constructor\r\n     * @alias module:echarts/data/Tree\r\n     * @param {string} id\r\n     */\r\n    function Tree(id) {\r\n        /**\r\n         * @type {TreeNode}\r\n         */\r\n        this.root = new TreeNode(id);\r\n    }\r\n\r\n    /**\r\n     * 遍历树的所有子节点(深度优先遍历)\r\n     * @param  {Function} cb\r\n     * @param  {Object}   [context]\r\n     */\r\n    Tree.prototype.traverse = function(cb, context) {\r\n        this.root.traverse(cb, context);\r\n    };\r\n\r\n    /**\r\n     * 生成子树\r\n     * @param  {string} id 子树根节点 id\r\n     * @return {module:echarts/data/Tree}\r\n     */\r\n    Tree.prototype.getSubTree = function(id) {\r\n        var root = this.getNodeById(id);\r\n        if (root) {\r\n            var tree = new Tree(root.id);\r\n            tree.root = root;\r\n            return tree;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @param  {string} id\r\n     * @return TreeNode\r\n     */\r\n    Tree.prototype.getNodeById = function (id) {\r\n        return this.root.getNodeById(id);\r\n    };\r\n\r\n\r\n    /**\r\n     * 从 option 里的 data 数据构建树\r\n     * @param {string} id\r\n     * @param {Array.<Object>} data\r\n     * @return Tree\r\n     */\r\n    Tree.fromOptionData = function (id, data) {\r\n        var tree = new Tree(id);\r\n        var rootNode = tree.root;\r\n        // Root node\r\n        rootNode.data = {\r\n            name: id,\r\n            children: data\r\n        };\r\n\r\n        function buildHierarchy(dataNode, parentNode) {\r\n            var node = new TreeNode(dataNode.name, dataNode);\r\n            parentNode.add(node);\r\n            // 遍历添加子节点\r\n            var children = dataNode.children;\r\n            if (children) {\r\n                for (var i = 0; i < children.length; i++) {\r\n                    buildHierarchy(children[i], node);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (var i = 0; i < data.length; i++) {\r\n            buildHierarchy(data[i], rootNode);\r\n        }\r\n\r\n        tree.root.updateDepthAndHeight(0);\r\n\r\n        return tree;\r\n    };\r\n\r\n\r\n    Tree.fromDataSource = function (dataSource, rootItem) {\r\n\r\n        function _findChildItem(nodeName) {\r\n            return zrUtil.filter(dataSource.link,function(item){\r\n                if(item.from === nodeName && !item.pos) {  // 数据中有pos属性的不是子节点\r\n                    return item;\r\n                }\r\n            });\r\n        }\r\n\r\n\r\n        function buildHierarchy(root) {\r\n            var childItem = _findChildItem(root.id);\r\n            for (var i = 0; i < childItem.length; i++) {\r\n                var item = childItem[i];\r\n                var childTreeNode = treeNodesMap[item.to];\r\n                root.children.push(childTreeNode);\r\n                buildHierarchy(childTreeNode);\r\n            }\r\n        }\r\n\r\n        var treeNodesMap = {};\r\n        for (var i = 0; i < dataSource.node.length; i++) {\r\n            var node = dataSource.node[i];\r\n            var treeNode = new TreeNode(node.name,node);\r\n            treeNodesMap[node.name] = treeNode;\r\n        }\r\n\r\n        var tree = new Tree(rootItem.name);\r\n        var rootNode = tree.root;\r\n        // Root node\r\n        rootNode.data = rootItem;\r\n\r\n\r\n        buildHierarchy(tree.root);\r\n        tree.root.updateDepthAndHeight(0);\r\n\r\n        return tree;\r\n    };\r\n\r\n    module.exports = Tree;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/data/Tree.js\n// module id = 128\n// module chunks = 0","\r\n    var vec2 = require('zrender/lib/core/vector');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    function TreeHelper(opts) {\r\n        opts = opts || {};\r\n\r\n        this.nodePadding = opts.nodePadding || 30;\r\n\r\n        this.layerPadding = opts.layerPadding || 100;\r\n\r\n        this._layerOffsets = [];\r\n\r\n        this._layers = [];\r\n\r\n        this._hideNodes = [];\r\n    }\r\n\r\n    TreeHelper.prototype.count = function (tree) {\r\n        var count = 0;\r\n        tree.traverse(function() {\r\n            count++;\r\n         });\r\n        return count;\r\n    }\r\n\r\n    TreeHelper.prototype.run = function (tree) {\r\n        this._layerOffsets.length = 0;\r\n        for (var i = 0; i < tree.root.height + 1; i++) {\r\n            this._layerOffsets[i] = 0;\r\n            this._layers[i] = [];\r\n        }\r\n        this._updateNodeXPosition(tree.root);\r\n        var root = tree.root;\r\n        this._updateNodeYPosition(root, 0, root.layout.height);\r\n    };\r\n\r\n    TreeHelper.prototype._updateNodeXPosition = function (node) {\r\n        var minX = Infinity;\r\n        var maxX = -Infinity;\r\n        node.layout.position = node.layout.position || vec2.create();\r\n        for (var i = 0; i < node.children.length; i++) {\r\n            var child = node.children[i];\r\n            if(zrUtil.indexOf(this._hideNodes, child) == -1){\r\n                this._updateNodeXPosition(child);\r\n                var x = child.layout.position[0];\r\n                if (x < minX) {\r\n                    minX = x;\r\n                }\r\n                if (x > maxX) {\r\n                    maxX = x;\r\n                }\r\n            }\r\n        }\r\n        if (node.children.length > 0 && (zrUtil.indexOf(this._hideNodes, node.children[0]) == -1)) {\r\n            node.layout.position[0] = (minX + maxX) / 2;\r\n        } else {\r\n            node.layout.position[0] = 0;\r\n            node.height = 0;   // 隐藏节点的 深度设为0\r\n        }\r\n        var off = this._layerOffsets[node.depth] || 0;\r\n        if (off > node.layout.position[0]) {\r\n            var shift = off - node.layout.position[0];\r\n            this._shiftSubtree(node, shift);\r\n            for (var j = node.depth + 1; j < node.height + node.depth; j++) {\r\n                this._layerOffsets[j] += shift;\r\n            }\r\n        }\r\n        this._layerOffsets[node.depth] = node.layout.position[0] + node.layout.width + this.nodePadding;\r\n\r\n        if(zrUtil.indexOf(this._layers[node.depth], node) == -1){\r\n            this._layers[node.depth].push(node);\r\n        }\r\n    };\r\n\r\n    TreeHelper.prototype._shiftSubtree = function (root, offset) {\r\n        root.layout.position[0] += offset;\r\n        for (var i = 0; i < root.children.length; i++) {\r\n            if(zrUtil.indexOf(this._hideNodes,root.children[i]) == -1){\r\n                this._shiftSubtree(root.children[i], offset);\r\n            }\r\n        }\r\n    };\r\n\r\n    TreeHelper.prototype._updateNodeYPosition = function (node, y, prevLayerHeight) {\r\n        if(zrUtil.indexOf(this._hideNodes,node) == -1){\r\n            node.layout.position[1] = y;\r\n            var layerHeight = 0;\r\n            for (var i = 0; i < node.children.length; i++) {\r\n                layerHeight = Math.max(node.children[i].layout.height, layerHeight);\r\n            }\r\n            var layerPadding = this.layerPadding;\r\n            if (typeof (layerPadding) === 'function') {\r\n                layerPadding = layerPadding(node.depth);\r\n            }\r\n            for (var j = 0; j < node.children.length; j++) {\r\n                this._updateNodeYPosition(node.children[j], y + layerPadding + prevLayerHeight, layerHeight);\r\n            }\r\n        }\r\n\r\n    };\r\n    module.exports = TreeHelper;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/layout/treeHelper.js\n// module id = 129\n// module chunks = 0","/**\r\n * 力导向布局<br>\r\n * @class fishTopoFlow.layout.ForceLayout\r\n * @extends fishTopoFlow.layout\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var layout = fishTopoFlow.layout;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       function newNode(data) {\r\n *           var circle = new node.Circle({\r\n *               shape: { r: 15 },\r\n *               style: { fill: \"#4883b4\" },\r\n *               name: data.name\r\n *           });\r\n *           return circle;\r\n *       }\r\n *       var options = {\r\n *           createNodeFunction: newNode,\r\n *           data:[{nodes:[\r\n *                           {name: '节点1'},\r\n *                           {name: '节点2'},\r\n *                           {name: '节点3'},\r\n *                           {name: '节点4'},\r\n *                           {name: '节点5'},\r\n *                           {name: '节点6'},\r\n *                           {name: '节点7'},\r\n *                           {name: '节点8'}\r\n *                       ],\r\n *                   links:[\r\n *                           {source:'节点1', target:'节点2'},\r\n *                           {source:'节点2', target:'节点3'},\r\n *                           {source:'节点3', target:'节点4'},\r\n *                           {source:'节点4', target:'节点5'},\r\n *                           {source:'节点5', target:'节点6'},\r\n *                           {source:'节点6', target:'节点7'},\r\n *                           {source:'节点7', target:'节点8'}\r\n *                       ]\r\n *           }]\r\n *       }\r\n *       var forceLayout = new layout.ForceLayout({\r\n *          fishTopo:fishTopo,\r\n *           repulsion: 200\r\n *       });\r\n *       forceLayout.doLayout(options);\r\n */\r\n\r\n\r\n\r\n    var forceHelper = require('./forceHelper');\r\n    var vec2 = require('zrender/lib/core/vector');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    function ForceLayout(opts) {\r\n         /**\r\n         * @cfg {Object} fishTopo fishTopo实例\r\n         */\r\n         /**\r\n         * @cfg {Number} [repulsion=100] 节点之间的斥力因子。该值越大节点之间的斥力越大，两个节点间的距离也会越远，默认为100\r\n         */\r\n         /**\r\n         * @cfg {Number} [gravity=0.1] 节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。默认为0.1\r\n         */\r\n        /**\r\n         * @cfg {Number} [edgeLength=30] 边的两个节点之间的距离，这个距离也会受 repulsion影响。 默认为30\r\n         */\r\n        /**\r\n         * @cfg {Boolean} [once=true] 是否只进行布局一次。<br/>\r\n         * 如果设置为false，在布局结束以后，再拖拽节点，节点的定位会设置为fixed，释放被拖拽的节点，节点会回到原来的位置, 导致重新布局，同样会再次触发forceLayoutEnd事件。\r\n         */\r\n        /**\r\n         * @cfg {Object} [rect] 布局显示范围\r\n         *\r\n         * @cfg {Object} [rect.x] 布局显示范围x坐标\r\n         * @cfg {Object} [rect.y] 布局显示范围y坐标\r\n         * @cfg {Object} [rect.width] 布局显示宽度\r\n         * @cfg {Object} [rect.height] 布局显示高度\r\n         */\r\n        /**\r\n         * @cfg {Boolean} [layoutAnimation=true] 是否显示布局动画\r\n         */\r\n        /**\r\n         * @cfg {Object} [lineStyle] 连线的样式  参见{@link fishTopoFlow.link#constructor 构造函数options参数}\r\n         */\r\n        this.fishTopo = opts.fishTopo;\r\n        var defaultOptions = {\r\n            repulsion: 100,  //节点之间的斥力因子。该值越大节点之间的斥力越大，两个节点间的距离也会越远，默认为100\r\n            gravity: 0.1, //节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。默认为0.1\r\n            edgeLength: 30, // 边的两个节点之间的距离，这个距离也会受 repulsion。 默认为30\r\n            once:true,\r\n            layoutAnimation:true,\r\n            rect: {x:0, y:0, width:this.fishTopo.getWidth() ,height:this.fishTopo.getHeight()},\r\n            lineStyle: {symbol:{type:'none'}},\r\n            preservedPoints: {}\r\n        };\r\n\r\n        this.options = zrUtil.defaults(defaultOptions, opts, true);\r\n    }\r\n\r\n    /**\r\n     * @method doLayout\r\n     * 根据forceData进行力导向布局\r\n     * @param {Object} forceData 力导向数据\r\n     * @param {Function} forceData.createNodeFunction=null 创建节点的函数 会把data中nodes的数据 传递过去  如果没有默认就是创建圆形\r\n     * @param {Function} forceData.createLinkFunction=null 创建线段函数，参数是data.links数据，如果没有默认创建直线 since V2.3.0\r\n     * @param {Object} forceData.data 创建力导向布局数据\r\n     * @param {Object} forceData.data.nodes 创建力导向布局节点的对象数据（必须包括name属性）\r\n     * @param {Object} forceData.data.links 创建力导向布局连线的对象数据（必须包括name属性）\r\n     *\r\n     */\r\n    ForceLayout.prototype.doLayout = function(forceData) {\r\n         var rootData = forceData.data[0];\r\n         this.allNodes = this._buildNode(rootData.nodes, forceData.createNodeFunction);\r\n         this.allLinks = this._buildLinks(rootData.links, forceData.createLinkFunction);\r\n         this._forceIns();\r\n\r\n         this._startForceLayoutIteration();\r\n    }\r\n    /**\r\n     * @method autoLayout\r\n     * 根据已有节点进行力导向布局\r\n     * @since V2.3.0\r\n     */\r\n    ForceLayout.prototype.autoLayout = function() {\r\n        this.allNodes = this.fishTopo.allNodes;\r\n        this.allLinks = this.fishTopo.connectionManager.connectors;\r\n        this._forceIns();\r\n        this._startForceLayoutIteration();\r\n    }\r\n\r\n    ForceLayout.prototype._buildNode = function(datas, createNodeFunction) {\r\n        if(!fish.isFunction(createNodeFunction)) {\r\n            createNodeFunction = this._defaultCreateNodeFunction.bind(this);\r\n        }\r\n        var allNodes = [];\r\n        //判断一下是否有node 如果没有则自己创建\r\n        zrUtil.each(datas,  function(item,idx) {\r\n            if(!item.node) {\r\n                var createNode = item.createNodeFunction || createNodeFunction;\r\n                var node = createNode(item);\r\n                this.fishTopo.add(node);\r\n                this._addNodeEvent(node,idx);\r\n                allNodes.push(node);\r\n            }\r\n        },this);\r\n        return allNodes;\r\n    }\r\n\r\n    ForceLayout.prototype._addNodeEvent = function(node,idx) {\r\n        if(!this.options.once) {\r\n            node.on('drag', function() {\r\n                if(this.options.forceLayout) {\r\n                    this.options.forceLayout.warmUp();\r\n                    !this._layouting && this._startForceLayoutIteration();\r\n                    this.options.forceLayout.setFixed(idx);\r\n                }\r\n            },this).on('dragend', function() {\r\n                if(this.options.forceLayout) {\r\n                    this.options.forceLayout.setUnfixed(idx);\r\n                }\r\n            },this)\r\n        }\r\n    }\r\n\r\n    ForceLayout.prototype._defaultCreateNodeFunction = function(item) {\r\n        var circle = this.fishTopo.createNode(\"Circle\",{\r\n            shape: { r: 15 },\r\n            style: { fill: \"#4883b4\" },\r\n            name: item.lable || item.name\r\n        });\r\n        return circle;\r\n    }\r\n\r\n    ForceLayout.prototype._buildLinks = function(links,createLinkFunction) {\r\n        var allLinks = [];\r\n\r\n        zrUtil.each(links, function(link) {\r\n            var startNode = this.fishTopo.childOfName(link.source);\r\n            var endNode = this.fishTopo.childOfName(link.target);\r\n            if(startNode && endNode) {\r\n                 var connector = null;\r\n                if(createLinkFunction) {\r\n                    var paramObj = link;\r\n                    paramObj.startNode = startNode;\r\n                    paramObj.endNode = endNode;\r\n                    connector = createLinkFunction(paramObj);\r\n                } else {\r\n                    var linkStyle = this.options.lineStyle;\r\n                    if (link.style) {\r\n                        linkStyle = zrUtil.merge(zrUtil.clone(linkStyle), link.style, true);\r\n                    }\r\n                    connector = this.fishTopo.createLink(startNode,endNode,linkStyle);\r\n                }\r\n                this.fishTopo.add(connector);\r\n                allLinks.push(connector);\r\n            }\r\n        },this);\r\n        return allLinks;\r\n    }\r\n\r\n\r\n    ForceLayout.prototype._forceIns = function() {\r\n        var rect = this.options.rect;\r\n        var self = this;\r\n        var preservedPoints = this.options.preservedPoints;\r\n        var nodes = zrUtil.map(this.allNodes, function(node) {\r\n            var rep = this.options.repulsion; node.w = rep; node.rep = rep; node.p = null;\r\n            return {\r\n                w: rep,\r\n                rep: rep,\r\n                p: null\r\n            };\r\n        },this);\r\n        if (preservedPoints) {\r\n            zrUtil.each(this.allNodes, function(node,idx) {\r\n                node.attr(\"position\", preservedPoints[idx]);\r\n            })\r\n        }\r\n        zrUtil.each(this.allLinks, function(link) {\r\n            link.n1 = link.startNode,\r\n            link.n2 = link.endNode,\r\n            link.d = this.options.edgeLength;\r\n            link.curveness = 0;\r\n        },this)\r\n\r\n        var forceInstance = forceHelper(this.allNodes, this.allLinks, {\r\n            rect: rect,\r\n            gravity: this.options.gravity\r\n        });\r\n        var oldStep = forceInstance.step;\r\n        forceInstance.step = function(cb) {\r\n            zrUtil.each(this.allNodes, function(node) {\r\n                if (nodes.fixed) {\r\n                    vec2.copy(nodes.p, nodes.position);\r\n                }\r\n            })\r\n\r\n            oldStep(function(allNodes, allLinks, stopped) {\r\n                for (var i = 0, l = allNodes.length; i < l; i++) {\r\n                    if (!allNodes[i].fixed) {\r\n                        allNodes[i].attr(\"position\", allNodes[i].p);\r\n                    }\r\n                    preservedPoints[i] = allNodes[i].p;\r\n                }\r\n\r\n                zrUtil.each(allLinks, function(connector) {\r\n                    self.fishTopo.connectionManager.refreshConnector(connector, true);\r\n                })\r\n\r\n                cb && cb(stopped);\r\n            });\r\n        };\r\n        this.options.forceLayout = forceInstance;\r\n        this.options.preservedPoints = preservedPoints;\r\n        // Step to get the layout\r\n        forceInstance.step();\r\n    }\r\n\r\n\r\n    ForceLayout.prototype._startForceLayoutIteration = function () {\r\n        var self = this;\r\n        var layoutAnimation = this.options.layoutAnimation;\r\n        (function step() {\r\n            self.options.forceLayout.step(function (stopped) {\r\n                self._layouting = !stopped;\r\n                if (self._layouting) {\r\n                    if (layoutAnimation) {\r\n                        self._layoutTimeout = setTimeout(step, 16)\r\n                    } else {\r\n                        step();\r\n                    }\r\n                } else {\r\n                     self.fishTopo.trigger(\"forceLayoutEnd\");  //派发布局结束事件\r\n                }\r\n            })\r\n        })();\r\n    };\r\n    module.exports = ForceLayout;\r\n\r\n/**\r\n * @method addCustomLayout\r\n * @hide\r\n */\r\n\r\n/**\r\n * @event forceLayoutEnd\r\n * 布局结束事件\r\n *\r\n * <pre>\r\n * fishtopo.on('forceLayoutEnd', function(e) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/layout/ForceLayout.js\n// module id = 130\n// module chunks = 0","\r\n\r\n    var vec2 = require('zrender/lib/core/vector');\r\n    var scaleAndAdd = vec2.scaleAndAdd;\r\n\r\n    // function adjacentNode(n, e) {\r\n    //     return e.n1 === n ? e.n2 : e.n1;\r\n    // }\r\n\r\n    module.exports = function (nodes, edges, opts) {\r\n        var rect = opts.rect;\r\n        var width = rect.width;\r\n        var height = rect.height;\r\n        var center = [rect.x + width / 2, rect.y + height / 2];\r\n        // var scale = opts.scale || 1;\r\n        var gravity = opts.gravity == null ? 0.1 : opts.gravity;\r\n\r\n        // for (var i = 0; i < edges.length; i++) {\r\n        //     var e = edges[i];\r\n        //     var n1 = e.n1;\r\n        //     var n2 = e.n2;\r\n        //     n1.edges = n1.edges || [];\r\n        //     n2.edges = n2.edges || [];\r\n        //     n1.edges.push(e);\r\n        //     n2.edges.push(e);\r\n        // }\r\n        // Init position\r\n        for (var i = 0; i < nodes.length; i++) {\r\n            var n = nodes[i];\r\n            if (!n.p) {\r\n                // Use the position from first adjecent node with defined position\r\n                // Or use a random position\r\n                // From d3\r\n                // if (n.edges) {\r\n                //     var j = -1;\r\n                //     while (++j < n.edges.length) {\r\n                //         var e = n.edges[j];\r\n                //         var other = adjacentNode(n, e);\r\n                //         if (other.p) {\r\n                //             n.p = vec2.clone(other.p);\r\n                //             break;\r\n                //         }\r\n                //     }\r\n                // }\r\n                // if (!n.p) {\r\n                    n.p = vec2.create(\r\n                        width * (Math.random() - 0.5) + center[0],\r\n                        height * (Math.random() - 0.5) + center[1]\r\n                    );\r\n                // }\r\n            }\r\n            n.pp = vec2.clone(n.p);\r\n            n.edges = null;\r\n        }\r\n\r\n        // Formula in 'Graph Drawing by Force-directed Placement'\r\n        // var k = scale * Math.sqrt(width * height / nodes.length);\r\n        // var k2 = k * k;\r\n\r\n        var friction = 0.6;\r\n\r\n        return {\r\n            warmUp: function () {\r\n                friction = 0.5;\r\n            },\r\n\r\n            setFixed: function (idx) {\r\n                nodes[idx].fixed = true;\r\n            },\r\n\r\n            setUnfixed: function (idx) {\r\n                nodes[idx].fixed = false;\r\n            },\r\n\r\n            step: function (cb) {\r\n                var v12 = [];\r\n                var nLen = nodes.length;\r\n                for (var i = 0; i < edges.length; i++) {\r\n                    var e = edges[i];\r\n                    var n1 = e.n1;\r\n                    var n2 = e.n2;\r\n\r\n                    vec2.sub(v12, n2.p, n1.p);\r\n                    var d = vec2.len(v12) - e.d;\r\n                    var w = n2.w / (n1.w + n2.w);\r\n                    vec2.normalize(v12, v12);\r\n\r\n                    !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);\r\n                    !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);\r\n                }\r\n                // Gravity\r\n                for (var i = 0; i < nLen; i++) {\r\n                    var n = nodes[i];\r\n                    if (!n.fixed) {\r\n                        vec2.sub(v12, center, n.p);\r\n                        // var d = vec2.len(v12);\r\n                        // vec2.scale(v12, v12, 1 / d);\r\n                        // var gravityFactor = gravity;\r\n                        vec2.scaleAndAdd(n.p, n.p, v12, gravity * friction);\r\n                    }\r\n                }\r\n\r\n                // Repulsive\r\n                // PENDING\r\n                for (var i = 0; i < nLen; i++) {\r\n                    var n1 = nodes[i];\r\n                    for (var j = i + 1; j < nLen; j++) {\r\n                        var n2 = nodes[j];\r\n                        vec2.sub(v12, n2.p, n1.p);\r\n                        var d = vec2.len(v12);\r\n                        if (d === 0) {\r\n                            // Random repulse\r\n                            vec2.set(v12, Math.random() - 0.5, Math.random() - 0.5);\r\n                            d = 1;\r\n                        }\r\n                        var repFact = (n1.rep + n2.rep) / d / d;\r\n                        !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);\r\n                        !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);\r\n                    }\r\n                }\r\n                var v = [];\r\n                for (var i = 0; i < nLen; i++) {\r\n                    var n = nodes[i];\r\n                    if (!n.fixed) {\r\n                        vec2.sub(v, n.p, n.pp);\r\n                        vec2.scaleAndAdd(n.p, n.p, v, friction);\r\n                        vec2.copy(n.pp, n.p);\r\n                    }\r\n                }\r\n\r\n                friction = friction * 0.992;\r\n\r\n                cb && cb(nodes, edges, friction < 0.01);\r\n            }\r\n        };\r\n    }\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/layout/forceHelper.js\n// module id = 131\n// module chunks = 0","/**\r\n * 工具类\r\n * @class fishTopoFlow.util\r\n */\r\n\r\n/**\r\n * @method initImagePool\r\n * 初始化图片池  用于对图片加载进行管理\r\n * @param {number} max 最大连接数。数值。\r\n * @returns {{load: Function, info: Function}}\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n        var imagepool = fishTopoFlow.util.initImagePool(100);\r\n        imagepool.load(grayArray, {\r\n            success: function(imgs) {\r\n            },\r\n            once: true\r\n        });\r\n */\r\n\r\n/**\r\n * @method inherits\r\n * 构造类继承关系\r\n *\r\n * @param {Function} clazz 源类\r\n * @param {Function} baseClazz 基类\r\n */\r\n\r\n\r\n    var emptyFn = function() {};\r\n    //初始默认配置\r\n    var config_default = {\r\n        //线程池\"线程\"数量\r\n        thread: 5,\r\n        //图片加载失败重试次数\r\n        //重试2次，加上原有的一次，总共是3次\r\n        \"tries\": 2\r\n    };\r\n    //工具\r\n    var _helpers = {\r\n        //设置dom属性\r\n        setAttr: (function() {\r\n            var img = new Image();\r\n            //判断浏览器是否支持HTML5 dataset\r\n            if (img.dataset) {\r\n                return function(dom, name, value) {\r\n                    dom.dataset[name] = value;\r\n                    return value;\r\n                };\r\n            } else {\r\n                return function(dom, name, value) {\r\n                    dom.setAttribute(\"data-\" + name, value);\r\n                    return value;\r\n                };\r\n            }\r\n        }()),\r\n        //获取dom属性\r\n        getAttr: (function() {\r\n            var img = new Image();\r\n            //判断浏览器是否支持HTML5 dataset\r\n            if (img.dataset) {\r\n                return function(dom, name) {\r\n                    if(!dom.dataset[name]){\r\n                        return dom.getAttribute(\"data-\" + name);\r\n                    }else{\r\n                        return dom.dataset[name];\r\n                    }\r\n                };\r\n            } else {\r\n                return function(dom, name) {\r\n                    return dom.getAttribute(\"data-\" + name);\r\n                };\r\n            }\r\n        }())\r\n    };\r\n    /**\r\n     * 构造方法\r\n     * @private\r\n     * @param max 最大连接数。数值。\r\n     */\r\n    function ImagePool(max) {\r\n        //最大并发数量\r\n        this.max = max || config_default.thread;\r\n        this.linkHead = null;\r\n        this.linkNode = null;\r\n        //加载池\r\n        //[{img: dom,free: true, node: node}]\r\n        //node\r\n        //{src: \"\", options: {success: \"fn\",error: \"fn\", once: true}, tries: 0}\r\n        this.pool = [];\r\n    }\r\n    /**\r\n     * 初始化\r\n     * @private\r\n     */\r\n    ImagePool.prototype.initPool = function() {\r\n        var i, img, obj, _s;\r\n        _s = this;\r\n        for (i = 0; i < this.max; i++) {\r\n            obj = {};\r\n            img = new Image();\r\n            _helpers.setAttr(img, \"id\", i);\r\n            img.onload = function() {\r\n                //回调\r\n                _s.notice(_s.getNode(this), \"success\", this);\r\n                //处理任务\r\n                _s.executeLink(this);\r\n            };\r\n            img.onerror = function() {\r\n                var node = _s.getNode(this);\r\n                //判断尝试次数\r\n                if (node.tries < config_default.tries) {\r\n                    node.tries = node.tries+1;\r\n                    //再次追加到任务链表末尾\r\n                    _s.appendNode(_s.createNode(node.src, node.options, node.notice, node.group, node.tries));\r\n                } else {\r\n                    //error回调\r\n                    //node.options.error.call(null, this.src);\r\n                    _s.notice(node, \"error\", this);\r\n                }\r\n                //处理任务\r\n                _s.executeLink(this);\r\n            };\r\n            obj.img = img;\r\n            obj.free = true;\r\n            this.pool.push(obj);\r\n        }\r\n    };\r\n    /**\r\n     * 回调封装\r\n     * @private\r\n     * @param node 节点。对象。\r\n     * @param status 状态。字符串。可选值：success(成功)|error(失败)\r\n     * @param img 图片。\r\n     */\r\n    ImagePool.prototype.notice = function(node, status, img) {\r\n        node.notice(status, img);\r\n    };\r\n    /**\r\n     * 处理链表任务\r\n     * @private\r\n     * @param dom 图像dom对象。对象。\r\n     */\r\n    ImagePool.prototype.executeLink = function(dom) {\r\n        //判断链表是否存在节点\r\n        if (this.linkHead) {\r\n            //加载下一个图片\r\n            this.setSrc(dom, this.linkHead);\r\n            //去除链表头\r\n            this.shiftNode();\r\n        } else {\r\n            //设置自身状态为空闲\r\n            this.status(dom, true);\r\n        }\r\n    };\r\n    /**\r\n     * 获取空闲\"线程\"\r\n     * @private\r\n     */\r\n    ImagePool.prototype.getFree = function() {\r\n        var length, i;\r\n        for (i = 0, length = this.pool.length; i < length; i++) {\r\n            if (this.pool[i].free) {\r\n                return this.pool[i];\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * 封装src属性设置\r\n     * 因为改变src属性相当于加载图片，所以把操作封装起来\r\n     * @private\r\n     * @param dom 图像dom对象。对象。\r\n     * @param node 节点。对象。\r\n     */\r\n    ImagePool.prototype.setSrc = function(dom, node) {\r\n        //设置池中的\"线程\"为非空闲状态\r\n        this.status(dom, false);\r\n        //关联节点\r\n        this.setNode(dom, node);\r\n        //加载图片\r\n        dom.src = node.src;\r\n    };\r\n    /**\r\n     * 更新池中的\"线程\"状态\r\n     * @private\r\n     * @param dom 图像dom对象。对象。\r\n     * @param status 状态。布尔。可选值：true(空闲)|false(非空闲)\r\n     */\r\n    ImagePool.prototype.status = function(dom, status) {\r\n        var id = _helpers.getAttr(dom, \"id\");\r\n        if(id){\r\n            this.pool[id].free = status;\r\n        }\r\n\r\n        //空闲状态，清除关联的节点\r\n        if (status) {\r\n            this.pool[id].node = null;\r\n        }\r\n    };\r\n    /**\r\n     * 更新池中的\"线程\"的关联节点\r\n     * @private\r\n     * @param dom 图像dom对象。对象。\r\n     * @param node 节点。对象。\r\n     */\r\n    ImagePool.prototype.setNode = function(dom, node) {\r\n        var id = _helpers.getAttr(dom, \"id\");\r\n        if(id){\r\n            this.pool[id].node = node;\r\n            return this.pool[id].node === node;\r\n        }\r\n\r\n    };\r\n    /**\r\n     * 获取池中的\"线程\"的关联节点\r\n     * @private\r\n     * @param dom 图像dom对象。对象。\r\n     */\r\n    ImagePool.prototype.getNode = function(dom) {\r\n        var id = _helpers.getAttr(dom, \"id\");\r\n        if(id){\r\n            return this.pool[id].node;\r\n        }\r\n\r\n    };\r\n    /**\r\n     * 对外接口，加载图片\r\n     * @private\r\n     * @param src 可以是src字符串，也可以是src字符串数组。\r\n     * @param options 用户自定义参数。包含：success回调、error回调、once标识。\r\n     */\r\n    ImagePool.prototype._load = function(src, options) {\r\n        var srcs = [],\r\n            free = null,\r\n            length = 0,\r\n            i = 0,\r\n            //只初始化一次回调策略\r\n            notice = (function() {\r\n                if (options.once) {\r\n                    return function(status, img) {\r\n                        var g = this.group,\r\n                            o = this.options;\r\n                        //记录\r\n                        g[status].push(img);\r\n                        //判断改组是否全部处理完成\r\n                        if (g.success.length + g.error.length === g.count) {\r\n                            //异步\r\n                            //实际上是作为另一个任务单独执行，防止回调函数执行时间过长影响图片加载速度\r\n                            setTimeout(function() {\r\n                                o.success.call(null, g.success, g.error, g.count);\r\n                            }, 1);\r\n                        }\r\n                    };\r\n                } else {\r\n                    return function(status, img) {\r\n                        var o = this.options;\r\n                        //直接回调\r\n                        setTimeout(function() {\r\n                            o[status].call(null, img);\r\n                        }, 1);\r\n                    };\r\n                }\r\n            }()),\r\n            group = {\r\n                count: 0,\r\n                success: [],\r\n                error: []\r\n            },\r\n            node = null;\r\n        options = options || {};\r\n        options.success = options.success || emptyFn;\r\n        options.error = options.error || emptyFn;\r\n        srcs = srcs.concat(src);\r\n        //设置组元素个数\r\n        group.count = srcs.length;\r\n        //遍历需要加载的图片\r\n        for (i = 0, length = srcs.length; i < length; i++) {\r\n            //创建节点\r\n            node = this.createNode(srcs[i], options, notice, group);\r\n            //判断线程池是否有空闲\r\n            free = this.getFree();\r\n            if (free) {\r\n                //有空闲，则立即加载图片\r\n                this.setSrc(free.img, node);\r\n            } else {\r\n                //没有空闲，将任务添加到链表\r\n                this.appendNode(node);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * 获取内部状态信息\r\n     * @private\r\n     * @returns {Object}\r\n     */\r\n    ImagePool.prototype._info = function() {\r\n        var info = {},\r\n            length = 0,\r\n            i = 0,\r\n            node = null;\r\n        //线程\r\n        info.thread = {};\r\n        //线程总数量\r\n        info.thread.count = this.pool.length;\r\n        //空闲线程数量\r\n        info.thread.free = 0;\r\n        //任务\r\n        info.task = {};\r\n        //待处理任务数量\r\n        info.task.count = 0;\r\n        //获取空闲\"线程\"数量\r\n        for (i = 0, length = this.pool.length; i < length; i++) {\r\n            if (this.pool[i].free) {\r\n                info.thread.free = info.thread.free + 1;\r\n            }\r\n        }\r\n        //获取任务数量(任务链长度)\r\n        node = this.linkHead;\r\n        if (node) {\r\n            info.task.count = info.task.count + 1;\r\n            while (node.next) {\r\n                info.task.count = info.task.count + 1;\r\n                node = node.next;\r\n            }\r\n        }\r\n        return info;\r\n    };\r\n\r\n    /**\r\n     * 创建节点\r\n     * @private\r\n     * @param src 图片路径。字符串。\r\n     * @param options 用户自定义参数。包含：success回调、error回调、once标识。\r\n     * @param notice 回调策略。 函数。\r\n     * @param group 组信息。对象。{count: 0, success: [], error: []}\r\n     * @param tr 出错重试次数。数值。默认为0。\r\n     * @returns {Object}\r\n     */\r\n    ImagePool.prototype.createNode = function(src, options, notice, group, tr) {\r\n        var node = {};\r\n        node.src = src;\r\n        node.options = options;\r\n        node.notice = notice;\r\n        node.group = group;\r\n        node.tries = tr || 0;\r\n        return node;\r\n    };\r\n    /**\r\n     * 向任务链表末尾追加节点\r\n     * @private\r\n     * @param node 节点。对象。\r\n     */\r\n    ImagePool.prototype.appendNode = function(node) {\r\n        //判断链表是否为空\r\n        if (!this.linkHead) {\r\n            this.linkHead = node;\r\n            this.linkNode = node;\r\n        } else {\r\n            this.linkNode.next = node;\r\n            this.linkNode = node;\r\n        }\r\n    };\r\n    /**\r\n     * 删除链表头\r\n     * @private\r\n     */\r\n    ImagePool.prototype.shiftNode = function() {\r\n        //判断链表是否存在节点\r\n        if (this.linkHead) {\r\n            //修改链表头\r\n            this.linkHead = this.linkHead.next || null;\r\n        }\r\n    };\r\n    /**\r\n     * 初始化图片池\r\n     * @param {number} max 最大连接数。数值。\r\n     * @returns {{load: Function, info: Function}}\r\n     */\r\n    var initImagePool = function(max) {\r\n        var instance = new ImagePool(max);\r\n        instance.initPool();\r\n        return {\r\n            /**\r\n             * 加载图片\r\n             * @param {string|Array} src 可以是src字符串，也可以是src字符串数组。\r\n             * @param {Object} options 用户自定义参数。包含：success回调、error回调、once标识。\r\n             * @param {Function} [options.success] success回调\r\n             * @param {Function} [options.error] error回调\r\n             * @param {boolean} [options.once] 是否全部加载完毕后，一次回调\r\n             */\r\n            load: function() {\r\n                instance._load.apply(instance, arguments);\r\n            },\r\n            /**\r\n             * 获取内部状态信息\r\n             * @returns {Object}\r\n             */\r\n            info: function() {\r\n                return instance._info.call(instance);\r\n            }\r\n        };\r\n    };\r\n\r\n    module.exports = { initImagePool: initImagePool }\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/ImagePool.js\n// module id = 132\n// module chunks = 0","\r\n    var TooltipContent = require('./TooltipContent');\r\n    var globalListener = require('./globalListener');\r\n    var Model = require('../../../fish-topo-core/lib/model');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var env = require('zrender/lib/core/env');\r\n    var flowUtil = require('../util/FlowUtil');\r\n    var layout = require(\"../layout/layout\");\r\n    function TooltipView(tooltipModel, api) {\r\n        this._tooltipContent = new TooltipContent(api.getDom(),api);\r\n        this._api = api;\r\n        this._tooltipModel = tooltipModel;\r\n        this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\r\n        this._initGloablListener();\r\n    }\r\n\r\n    TooltipView.prototype._initGloablListener = function() {\r\n        var triggerOn = this._tooltipModel.get('triggerOn');\r\n        // 当有 'click' | 'mousemove' | 'none' 事件时触发回调\r\n        globalListener.register(\r\n            'itemTooltip',\r\n            this._api,\r\n            function(currTrigger, e, dispatchAction){\r\n                if (triggerOn !== 'none') {\r\n                    if (triggerOn.indexOf(currTrigger) >= 0 ) {\r\n                        this._tryShow(e, dispatchAction);\r\n                    }\r\n                    else if (currTrigger === 'leave') {\r\n                        this._hide(dispatchAction)\r\n                    }\r\n                }\r\n            }.bind(this)\r\n        )\r\n    };\r\n\r\n    TooltipView.prototype._tryShow = function(e, dispatchAction) {\r\n            var el = e.target;\r\n            var tooltipModel = this._tooltipModel;\r\n\r\n            if (!tooltipModel) {\r\n                return;\r\n            }\r\n\r\n            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\r\n            this._lastX = e.offsetX;\r\n            this._lastY = e.offsetY;\r\n\r\n            if (el && el.tooltip) {\r\n                this._showComponentItemTooltip(e, el);\r\n            }\r\n            else {\r\n                this._hide(dispatchAction);\r\n            }\r\n    };\r\n\r\n     TooltipView.prototype._hide = function(dispatchAction) {\r\n            // Do not directly hideLater here, because this behavior may be prevented\r\n            // in dispatchAction when showTip is dispatched.\r\n\r\n            // FIXME\r\n            // duplicated hideTip if manuallyHideTip is called from dispatchAction.\r\n            this._lastDataByCoordSys = null;\r\n            dispatchAction({\r\n                type: 'hideTip',\r\n                from: this.uid\r\n            });\r\n            this.manuallyHideTip();\r\n        };\r\n\r\n       TooltipView.prototype.dispose = function () {\r\n            if (env.node) {\r\n                return;\r\n            }\r\n            this._tooltipContent.hide();\r\n            globalListener.unregister('itemTooltip', this._api);\r\n        };\r\n\r\n        TooltipView.prototype.manuallyHideTip = function () {\r\n            var tooltipContent = this._tooltipContent;\r\n\r\n            if (!this._alwaysShowContent) {\r\n                tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\r\n            }\r\n\r\n            this._lastX = this._lastY = null;\r\n\r\n\r\n        },\r\n\r\n    TooltipView.prototype._showComponentItemTooltip = function (e, el) {\r\n            var tooltipOpt = el.tooltip;\r\n            if (typeof tooltipOpt === 'string') {\r\n                var content = tooltipOpt;\r\n                tooltipOpt = {\r\n                    content: content,\r\n                    // Fixed formatter\r\n                    formatter: content\r\n                };\r\n            }\r\n            var subTooltipModel = new Model(tooltipOpt, this._tooltipModel);\r\n            var defaultHtml = subTooltipModel.get('content');\r\n            var asyncTicket = Math.random();\r\n\r\n            // Do not check whether `trigger` is 'none' here, because `trigger`\r\n            // only works on cooridinate system. In fact, we have not found case\r\n            // that requires setting `trigger` nothing on component yet.\r\n\r\n            this._showOrMove(subTooltipModel, function () {\r\n                this._showTooltipContent(\r\n                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},\r\n                    asyncTicket, e.offsetX, e.offsetY, e.position, el\r\n                );\r\n            });\r\n\r\n\r\n        };\r\n\r\n      TooltipView.prototype._showOrMove = function (tooltipModel, cb) {\r\n            // showDelay is used in this case: tooltip.enterable is set\r\n            // as true. User intent to move mouse into tooltip and click\r\n            // something. `showDelay` makes it easyer to enter the content\r\n            // but tooltip do not move immediately.\r\n            var delay = tooltipModel.get('showDelay');\r\n            cb = zrUtil.bind(cb, this);\r\n            clearTimeout(this._showTimout);\r\n            delay > 0\r\n                ? (this._showTimout = setTimeout(cb, delay))\r\n                : cb();\r\n        };\r\n\r\n        TooltipView.prototype._showTooltipContent = function (tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el) {\r\n            // Reset ticket\r\n            this._ticket = '';\r\n\r\n            if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {\r\n                return;\r\n            }\r\n\r\n            var tooltipContent = this._tooltipContent;\r\n\r\n            var formatter = tooltipModel.get('formatter');\r\n            positionExpr = positionExpr || tooltipModel.get('position');\r\n            var html = defaultHtml;\r\n\r\n            if (formatter && typeof formatter === 'string') {\r\n                html = flowUtil.formatTpl(formatter, params, true);\r\n            }\r\n            else if (typeof formatter === 'function') {\r\n                var callback = function (cbTicket, html) {\r\n                    if (cbTicket === this._ticket) {\r\n                        tooltipContent.setContent(html);\r\n                        this._updatePosition(\r\n                            tooltipModel, positionExpr, x, y, tooltipContent, params, el\r\n                        );\r\n                    }\r\n                }.bind(this);\r\n                this._ticket = asyncTicket;\r\n                html = formatter(params, asyncTicket, callback);\r\n            }\r\n\r\n            tooltipContent.setContent(html);\r\n            tooltipContent.show(tooltipModel);\r\n\r\n            this._updatePosition(\r\n                tooltipModel, positionExpr, x, y, tooltipContent, params, el\r\n            );\r\n        };\r\n\r\n        /**\r\n         * @param  {string|Function|Array.<number>} positionExpr\r\n         * @param  {number} x Mouse x\r\n         * @param  {number} y Mouse y\r\n         * @param  {boolean} confine Whether confine tooltip content in view rect.\r\n         * @param  {Object|<Array.<Object>} params\r\n         * @param  {module:zrender/Element} el target element\r\n         * @param  {module:echarts/ExtensionAPI} api\r\n         * @return {Array.<number>}\r\n         */\r\n        TooltipView.prototype._updatePosition = function (tooltipModel, positionExpr, x, y, content, params, el) {\r\n            var viewWidth = this._api.getWidth();\r\n            var viewHeight = this._api.getHeight();\r\n            positionExpr = positionExpr || tooltipModel.get('position');\r\n\r\n            var contentSize = content.getSize();\r\n            var align = tooltipModel.get('align');\r\n            var vAlign = tooltipModel.get('verticalAlign');\r\n            var rect = el && el.getBoundingRect().clone();\r\n            el && rect.applyTransform(el.transform);\r\n\r\n            if (typeof positionExpr === 'function') {\r\n                // Callback of position can be an array or a string specify the position\r\n                positionExpr = positionExpr([x, y], params, content.el, rect, {\r\n                    viewSize: [viewWidth, viewHeight],\r\n                    contentSize: contentSize.slice()\r\n                });\r\n            }\r\n\r\n            if (zrUtil.isArray(positionExpr)) {\r\n                x = flowUtil.parsePercent(positionExpr[0], viewWidth);\r\n                y = flowUtil.parsePercent(positionExpr[1], viewHeight);\r\n            }\r\n            else if (zrUtil.isObject(positionExpr)) {\r\n                positionExpr.width = contentSize[0];\r\n                positionExpr.height = contentSize[1];\r\n                var layoutRect = layout.getLayoutRect(\r\n                    positionExpr, {width: viewWidth, height: viewHeight}\r\n                );\r\n                x = layoutRect.x;\r\n                y = layoutRect.y;\r\n                align = null;\r\n                // When positionExpr is left/top/right/bottom,\r\n                // align and verticalAlign will not work.\r\n                vAlign = null;\r\n            }\r\n            // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\r\n            else if (typeof positionExpr === 'string' && el) {\r\n                var pos = calcTooltipPosition(\r\n                    positionExpr, rect, contentSize\r\n                );\r\n                x = pos[0];\r\n                y = pos[1];\r\n            }\r\n            else {\r\n                var pos1 = refixTooltipPosition(\r\n                    x, y, content.el, viewWidth, viewHeight, align ? 0 : 20, vAlign ? 0 : 20\r\n                );\r\n                x = pos1[0];\r\n                y = pos1[1];\r\n            }\r\n\r\n            align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);\r\n            vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);\r\n\r\n            if (tooltipModel.get('confine')) {\r\n                var pos2 = confineTooltipPosition(\r\n                    x, y, content.el, viewWidth, viewHeight\r\n                );\r\n                x = pos2[0];\r\n                y = pos2[1];\r\n            }\r\n\r\n            content.moveTo(x, y);\r\n        }\r\n\r\n    function calcTooltipPosition(position, rect, contentSize) {\r\n        var domWidth = contentSize[0];\r\n        var domHeight = contentSize[1];\r\n        var gap = 5;\r\n        var x = 0;\r\n        var y = 0;\r\n        var rectWidth = rect.width;\r\n        var rectHeight = rect.height;\r\n        switch (position) {\r\n            case 'inside':\r\n                x = rect.x + rectWidth / 2 - domWidth / 2;\r\n                y = rect.y + rectHeight / 2 - domHeight / 2;\r\n                break;\r\n            case 'top':\r\n                x = rect.x + rectWidth / 2 - domWidth / 2;\r\n                y = rect.y - domHeight - gap;\r\n                break;\r\n            case 'bottom':\r\n                x = rect.x + rectWidth / 2 - domWidth / 2;\r\n                y = rect.y + rectHeight + gap;\r\n                break;\r\n            case 'left':\r\n                x = rect.x - domWidth - gap;\r\n                y = rect.y + rectHeight / 2 - domHeight / 2;\r\n                break;\r\n            case 'right':\r\n                x = rect.x + rectWidth + gap;\r\n                y = rect.y + rectHeight / 2 - domHeight / 2;\r\n        }\r\n        return [x, y];\r\n    }\r\n    function refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {\r\n        var width = el.clientWidth;\r\n        var height = el.clientHeight;\r\n\r\n        if (x + width + gapH > viewWidth) {\r\n            x -= width + gapH;\r\n        }\r\n        else {\r\n            x += gapH;\r\n        }\r\n        if (y + height + gapV > viewHeight) {\r\n            y -= height + gapV;\r\n        }\r\n        else {\r\n            y += gapV;\r\n        }\r\n        return [x, y];\r\n    }\r\n\r\n    function isCenterAlign(align) {\r\n        return align === 'center' || align === 'middle';\r\n    }\r\n\r\n    function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\r\n        var width = el.clientWidth;\r\n        var height = el.clientHeight;\r\n\r\n        x = Math.min(x + width, viewWidth) - width;\r\n        y = Math.min(y + height, viewHeight) - height;\r\n        x = Math.max(x, 0);\r\n        y = Math.max(y, 0);\r\n\r\n        return [x, y];\r\n    }\r\n    module.exports = TooltipView;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/tooltip/TooltipView.js\n// module id = 133\n// module chunks = 0","\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var zrColor = require('zrender/lib/tool/color');\r\n    var env = require('zrender/lib/core/env');\r\n    var eventUtil = require('zrender/lib/core/event');\r\n    var flowUtil = require('../util/FlowUtil');\r\n    var toCamelCase = flowUtil.toCamelCase;\r\n    var normalizeCssArray = flowUtil.normalizeCssArray;\r\n    var each = zrUtil.each;\r\n\r\n\r\n    var vendors = ['', '-webkit-', '-moz-', '-o-'];\r\n\r\n    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:999;';//fish popup zindex:1050\r\n    /**\r\n     * @param {number} duration\r\n     * @return {string}\r\n     * @inner\r\n     */\r\n    function assembleTransition(duration) {\r\n        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\r\n        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','\r\n                            + 'top ' + duration + 's ' + transitionCurve;\r\n        return zrUtil.map(vendors, function (vendorPrefix) {\r\n            return vendorPrefix + 'transition:' + transitionText;\r\n        }).join(';');\r\n    }\r\n\r\n    /**\r\n     * @param {Object} textStyle\r\n     * @return {string}\r\n     * @inner\r\n     */\r\n    function assembleFont(textStyleModel) {\r\n        var cssText = [];\r\n\r\n        var fontSize = textStyleModel.get('fontSize');\r\n        var color = textStyleModel.get(\"color\");\r\n\r\n        color && cssText.push('color:' + color);\r\n\r\n        var font = textStyleModel.get(\"font\");\r\n        font && cssText.push('font:' + font);\r\n\r\n        fontSize &&\r\n            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\r\n\r\n        each(['decoration', 'align'], function (name) {\r\n            var val = textStyleModel.get(name);\r\n            val && cssText.push('text-' + name + ':' + val);\r\n        });\r\n\r\n        return cssText.join(';');\r\n    }\r\n    /**\r\n     * @param {Object} tooltipModel\r\n     * @return {string}\r\n     * @inner\r\n     */\r\n    function assembleCssText(tooltipModel) {\r\n\r\n        var cssText = [];\r\n\r\n        var transitionDuration = tooltipModel.get('transitionDuration');\r\n        var backgroundColor = tooltipModel.get('backgroundColor');\r\n        var textStyleModel = tooltipModel.getModel('textStyle');\r\n        var padding = tooltipModel.get('padding');\r\n\r\n        // Animation transition. Do not animate when transitionDuration is 0.\r\n        transitionDuration &&\r\n            cssText.push(assembleTransition(transitionDuration));\r\n\r\n        if (backgroundColor) {\r\n            if (env.canvasSupported) {\r\n                cssText.push('background-Color:' + backgroundColor);\r\n            }\r\n            else {\r\n                // for ie\r\n                cssText.push(\r\n                    'background-Color:#' + zrColor.toHex(backgroundColor)\r\n                );\r\n                cssText.push('filter:alpha(opacity=70)');\r\n            }\r\n        }\r\n\r\n        // Border style\r\n        each(['width', 'color', 'radius'], function (name) {\r\n            var borderName = 'border-' + name;\r\n            var camelCase = toCamelCase(borderName);\r\n            var val = tooltipModel.get(camelCase);\r\n            val != null &&\r\n                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\r\n        });\r\n\r\n        // Text style\r\n        cssText.push(assembleFont(textStyleModel));\r\n\r\n        // Padding\r\n        if (padding != null) {\r\n            cssText.push('padding:' + normalizeCssArray(padding).join('px ') + 'px');\r\n        }\r\n\r\n        return cssText.join(';') + ';';\r\n    }\r\n    /**\r\n     *\r\n     *\r\n     * @param {any} container\r\n     * @param {any} api\r\n     */\r\n    function TooltipContent(container, api) {\r\n        var el = document.createElement('div');\r\n        var zr = this._zr = api.getZr();\r\n\r\n        this.el = el;\r\n\r\n        this._x = api.getWidth() / 2;\r\n        this._y = api.getHeight() / 2;\r\n\r\n        container.appendChild(el);\r\n\r\n        this._container = container;\r\n\r\n        this._show = false;\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        this._hideTimeout;\r\n\r\n        var self = this;\r\n        el.onmouseenter = function () {\r\n            // clear the timeout in hideLater and keep showing tooltip\r\n            if (self._enterable) {\r\n                clearTimeout(self._hideTimeout);\r\n                self._show = true;\r\n            }\r\n            self._inContent = true;\r\n        };\r\n        el.onmousemove = function (e) {\r\n            e = e || window.event;\r\n            if (!self._enterable) {\r\n                // Try trigger zrender event to avoid mouse\r\n                // in and out shape too frequently\r\n                var handler = zr.handler;\r\n                eventUtil.normalizeEvent(container, e, true);\r\n                handler.dispatch('mousemove', e);\r\n            }\r\n        };\r\n        el.onmouseleave = function () {\r\n            if (self._enterable) {\r\n                if (self._show) {\r\n                    self.hideLater(self._hideDelay);\r\n                }\r\n            }\r\n            self._inContent = false;\r\n        };\r\n    }\r\n    TooltipContent.prototype = {\r\n\r\n        constructor: TooltipContent,\r\n\r\n        /**\r\n         * @private\r\n         * @type {boolean}\r\n         */\r\n        _enterable: true,\r\n\r\n        /**\r\n         * Update when tooltip is rendered\r\n         */\r\n        update: function () {\r\n            // FIXME\r\n            // Move this logic to ec main?\r\n            var container = this._container;\r\n            var stl = container.currentStyle\r\n                || document.defaultView.getComputedStyle(container);\r\n            var domStyle = container.style;\r\n            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\r\n                domStyle.position = 'relative';\r\n            }\r\n            // Hide the tooltip\r\n            // PENDING\r\n            // this.hide();\r\n        },\r\n\r\n        show: function (tooltipModel) {\r\n            clearTimeout(this._hideTimeout);\r\n            var el = this.el;\r\n\r\n            el.style.cssText = gCssText + assembleCssText(tooltipModel)\r\n                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\r\n                + ';left:' + this._x + 'px;top:' + this._y + 'px;'\r\n                + (tooltipModel.get('extraCssText') || '');\r\n\r\n            el.style.display = el.innerHTML ?  'block' : 'none';\r\n\r\n            this._show = true;\r\n        },\r\n\r\n        setContent: function (content) {\r\n            this.el.innerHTML = content;\r\n        },\r\n\r\n        setEnterable: function (enterable) {\r\n            this._enterable = enterable;\r\n        },\r\n\r\n        getSize: function () {\r\n            var el = this.el;\r\n            return [el.clientWidth, el.clientHeight];\r\n        },\r\n\r\n        moveTo: function (x, y) {\r\n            // xy should be based on canvas root. But tooltipContent is\r\n            // the sibling of canvas root. So padding of ec container\r\n            // should be considered here.\r\n            var zr = this._zr;\r\n            var viewportRoot;\r\n            if (zr && zr.painter && (viewportRoot = zr.painter.getViewportRoot())) {\r\n                x += viewportRoot.offsetLeft || 0;\r\n                y += viewportRoot.offsetTop || 0;\r\n            }\r\n\r\n            var style = this.el.style;\r\n            style.left = x + 'px';\r\n            style.top = y + 'px';\r\n\r\n            this._x = x;\r\n            this._y = y;\r\n        },\r\n\r\n        hide: function () {\r\n            this.el.style.display = 'none';\r\n            this._show = false;\r\n        },\r\n\r\n        hideLater: function (time) {\r\n            if (this._show && !(this._inContent && this._enterable)) {\r\n                if (time) {\r\n                    this._hideDelay = time;\r\n                    // Set show false to avoid invoke hideLater mutiple times\r\n                    this._show = false;\r\n                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\r\n                }\r\n                else {\r\n                    this.hide();\r\n                }\r\n            }\r\n        },\r\n\r\n        isShow: function () {\r\n            return this._show;\r\n        }\r\n    };\r\n\r\n    module.exports = TooltipContent;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/tooltip/TooltipContent.js\n// module id = 134\n// module chunks = 0","\r\n\r\n    var env = require('zrender/lib/core/env');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var get = require('../util/FlowUtil').makeGetter();\r\n\r\n    var each = zrUtil.each;\r\n\r\n    var globalListener = {};\r\n\r\n    /**\r\n     * @param key 注册的字符串\r\n     * @param api ExtensionAPI\r\n     * @param handler 处理回调\r\n     */\r\n    globalListener.register = function (key, api, handler) {\r\n        if (env.node) {   //node环境下不执行\r\n            return;\r\n        }\r\n        //判断zrender的 records  并初始化\r\n        var zr = api.getZr();\r\n        get(zr).records || (get(zr).records = {});\r\n\r\n        initGlobalListeners(zr, api);\r\n\r\n        //将回调加入record\r\n        var record = get(zr).records[key] || (get(zr).records[key] = {});\r\n        record.handler = handler;\r\n    };\r\n\r\n    /**\r\n     * 初始化全局侦听\r\n     *\r\n     * @param {object} zr   zrender\r\n     * @param {object} api  ExtensionAPI\r\n     * @returns\r\n     */\r\n    function initGlobalListeners(zr, api) {\r\n        if (get(zr).initialized) {   //避免重复初始化\r\n            return;\r\n        }\r\n\r\n        get(zr).initialized = true;\r\n\r\n        //侦听事件\r\n        useHandler('click', zrUtil.curry(doEnter, 'click'));\r\n        useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove'));\r\n        // useHandler('mouseout', onLeave);\r\n        useHandler('globalout', onLeave);\r\n\r\n        function useHandler(eventType, cb) {\r\n            zr.on(eventType, function (e) {\r\n                var dis = makeDispatchAction(api);\r\n                //遍历注册的 所有records， 并进行调用\r\n                each(get(zr).records, function (record) {\r\n                    record && cb(record, e, dis.dispatchAction);\r\n                });\r\n\r\n                dispatchTooltipFinally(dis.pendings, api);\r\n            });\r\n        }\r\n    }\r\n\r\n    function dispatchTooltipFinally(pendings, api) {\r\n        var showLen = pendings.showTip.length;\r\n        var hideLen = pendings.hideTip.length;\r\n\r\n        var actuallyPayload;\r\n        if (showLen) {\r\n            actuallyPayload = pendings.showTip[showLen - 1];\r\n        }\r\n        else if (hideLen) {\r\n            actuallyPayload = pendings.hideTip[hideLen - 1];\r\n        }\r\n        if (actuallyPayload) {\r\n            actuallyPayload.dispatchAction = null;\r\n            api.dispatchAction(actuallyPayload);\r\n        }\r\n    }\r\n\r\n    function onLeave(record, e, dispatchAction) {\r\n        record.handler('leave', null, dispatchAction);\r\n    }\r\n\r\n    function doEnter(currTrigger, record, e, dispatchAction) {\r\n        record.handler(currTrigger, e, dispatchAction);\r\n    }\r\n\r\n    /**\r\n     * 派发action   行将发生的\r\n     *\r\n     * @param {any} api\r\n     * @returns\r\n     */\r\n    function makeDispatchAction(api) {\r\n        var pendings = {\r\n            showTip: [],\r\n            hideTip: []\r\n        };\r\n        // FIXME\r\n        // better approach?\r\n        // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,\r\n        // which may be conflict, (axisPointer call showTip but tooltip call hideTip);\r\n        // So we have to add \"final stage\" to merge those dispatched actions.\r\n        var dispatchAction = function (payload) {\r\n            var pendingList = pendings[payload.type];\r\n            if (pendingList) {\r\n                pendingList.push(payload);\r\n            }\r\n            else {\r\n                payload.dispatchAction = dispatchAction;\r\n                api.dispatchAction(payload);\r\n            }\r\n        };\r\n\r\n        return {\r\n            dispatchAction: dispatchAction,\r\n            pendings: pendings\r\n        };\r\n    }\r\n\r\n    /**\r\n     * @param {string} key\r\n     * @param {module:echarts/ExtensionAPI} api\r\n     */\r\n    globalListener.unregister = function (key, api) {\r\n        if (env.node) {\r\n            return;\r\n        }\r\n        var zr = api.getZr();\r\n        var record = (get(zr).records || {})[key];\r\n        if (record) {\r\n            get(zr).records[key] = null;\r\n        }\r\n    };\r\n\r\n    module.exports = globalListener;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/tooltip/globalListener.js\n// module id = 135\n// module chunks = 0","\r\n\r\n    var Model = require('../../../fish-topo-core/lib/model');\r\n    module.exports = Model.extend({\r\n\r\n        type: 'tooltip',\r\n\r\n        defaultOption: {\r\n            zlevel: 0,\r\n\r\n            z: 8,\r\n\r\n            show: true,\r\n\r\n            // tooltip主体内容\r\n            showContent: true,\r\n\r\n\r\n\r\n            // 'click' | 'mousemove' | 'none'\r\n            triggerOn: 'mousemove',\r\n\r\n            alwaysShowContent: false,\r\n\r\n            displayMode: 'single', // 'single' | 'multipleByCoordSys'\r\n\r\n            // 位置 {Array} | {Function}\r\n            // position: null\r\n            // Consider triggered from axisPointer handle, verticalAlign should be 'middle'\r\n            // align: null,\r\n            // verticalAlign: null,\r\n\r\n            // 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。\r\n            confine: false,\r\n\r\n            // 内容格式器：{string}（Template） ¦ {Function}\r\n            // formatter: null\r\n\r\n            showDelay: 0,\r\n\r\n            // 隐藏延迟，单位ms\r\n            hideDelay: 100,\r\n\r\n            // 动画变换时间，单位s\r\n            transitionDuration: 0.4,\r\n\r\n            enterable: false,\r\n\r\n            // 提示背景颜色，默认为透明度为0.7的黑色\r\n            backgroundColor: 'rgba(50,50,50,0.7)',\r\n\r\n            // 提示边框颜色\r\n            borderColor: '#333',\r\n\r\n            // 提示边框圆角，单位px，默认为4\r\n            borderRadius: 4,\r\n\r\n            // 提示边框线宽，单位px，默认为0（无边框）\r\n            borderWidth: 0,\r\n\r\n            // 提示内边距，单位px，默认各方向内边距为5，\r\n            // 接受数组分别设定上右下左边距，同css\r\n            padding: 5,\r\n\r\n            // Extra css text\r\n            extraCssText: '',\r\n\r\n            textStyle: {\r\n                color: '#fff',\r\n                fontSize: 14\r\n            }\r\n        }\r\n    });\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/tooltip/TooltipModel.js\n// module id = 136\n// module chunks = 0","require(\"./graphic\");\n\nvar _zrender = require(\"../zrender\");\n\nvar registerPainter = _zrender.registerPainter;\n\nvar Painter = require(\"./Painter\");\n\nregisterPainter('vml', Painter);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/vml/vml.js\n// module id = 137\n// module chunks = 0","var env = require(\"../core/env\");\n\nvar _vector = require(\"../core/vector\");\n\nvar applyTransform = _vector.applyTransform;\n\nvar BoundingRect = require(\"../core/BoundingRect\");\n\nvar colorTool = require(\"../tool/color\");\n\nvar textContain = require(\"../contain/text\");\n\nvar textHelper = require(\"../graphic/helper/text\");\n\nvar RectText = require(\"../graphic/mixin/RectText\");\n\nvar Displayable = require(\"../graphic/Displayable\");\n\nvar ZImage = require(\"../graphic/Image\");\n\nvar Text = require(\"../graphic/Text\");\n\nvar Path = require(\"../graphic/Path\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar Gradient = require(\"../graphic/Gradient\");\n\nvar vmlCore = require(\"./core\");\n\n// http://www.w3.org/TR/NOTE-VML\n// TODO Use proxy like svg instead of overwrite brush methods\nvar CMD = PathProxy.CMD;\nvar round = Math.round;\nvar sqrt = Math.sqrt;\nvar abs = Math.abs;\nvar cos = Math.cos;\nvar sin = Math.sin;\nvar mathMax = Math.max;\n\nif (!env.canvasSupported) {\n  var comma = ',';\n  var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n  var Z = 21600;\n  var Z2 = Z / 2;\n  var ZLEVEL_BASE = 100000;\n  var Z_BASE = 1000;\n\n  var initRootElStyle = function (el) {\n    el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n    el.coordsize = Z + ',' + Z;\n    el.coordorigin = '0,0';\n  };\n\n  var encodeHtmlAttribute = function (s) {\n    return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n  };\n\n  var rgb2Str = function (r, g, b) {\n    return 'rgb(' + [r, g, b].join(',') + ')';\n  };\n\n  var append = function (parent, child) {\n    if (child && parent && child.parentNode !== parent) {\n      parent.appendChild(child);\n    }\n  };\n\n  var remove = function (parent, child) {\n    if (child && parent && child.parentNode === parent) {\n      parent.removeChild(child);\n    }\n  };\n\n  var getZIndex = function (zlevel, z, z2) {\n    // z 的取值范围为 [0, 1000]\n    return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n  };\n\n  var parsePercent = function (value, maxValue) {\n    if (typeof value === 'string') {\n      if (value.lastIndexOf('%') >= 0) {\n        return parseFloat(value) / 100 * maxValue;\n      }\n\n      return parseFloat(value);\n    }\n\n    return value;\n  };\n  /***************************************************\n   * PATH\n   **************************************************/\n\n\n  var setColorAndOpacity = function (el, color, opacity) {\n    var colorArr = colorTool.parse(color);\n    opacity = +opacity;\n\n    if (isNaN(opacity)) {\n      opacity = 1;\n    }\n\n    if (colorArr) {\n      el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n      el.opacity = opacity * colorArr[3];\n    }\n  };\n\n  var getColorAndAlpha = function (color) {\n    var colorArr = colorTool.parse(color);\n    return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];\n  };\n\n  var updateFillNode = function (el, style, zrEl) {\n    // TODO pattern\n    var fill = style.fill;\n\n    if (fill != null) {\n      // Modified from excanvas\n      if (fill instanceof Gradient) {\n        var gradientType;\n        var angle = 0;\n        var focus = [0, 0]; // additional offset\n\n        var shift = 0; // scale factor for offset\n\n        var expansion = 1;\n        var rect = zrEl.getBoundingRect();\n        var rectWidth = rect.width;\n        var rectHeight = rect.height;\n\n        if (fill.type === 'linear') {\n          gradientType = 'gradient';\n          var transform = zrEl.transform;\n          var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n          var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n\n          if (transform) {\n            applyTransform(p0, p0, transform);\n            applyTransform(p1, p1, transform);\n          }\n\n          var dx = p1[0] - p0[0];\n          var dy = p1[1] - p0[1];\n          angle = Math.atan2(dx, dy) * 180 / Math.PI; // The angle should be a non-negative number.\n\n          if (angle < 0) {\n            angle += 360;\n          } // Very small angles produce an unexpected result because they are\n          // converted to a scientific notation string.\n\n\n          if (angle < 1e-6) {\n            angle = 0;\n          }\n        } else {\n          gradientType = 'gradientradial';\n          var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n          var transform = zrEl.transform;\n          var scale = zrEl.scale;\n          var width = rectWidth;\n          var height = rectHeight;\n          focus = [// Percent in bounding rect\n          (p0[0] - rect.x) / width, (p0[1] - rect.y) / height];\n\n          if (transform) {\n            applyTransform(p0, p0, transform);\n          }\n\n          width /= scale[0] * Z;\n          height /= scale[1] * Z;\n          var dimension = mathMax(width, height);\n          shift = 2 * 0 / dimension;\n          expansion = 2 * fill.r / dimension - shift;\n        } // We need to sort the color stops in ascending order by offset,\n        // otherwise IE won't interpret it correctly.\n\n\n        var stops = fill.colorStops.slice();\n        stops.sort(function (cs1, cs2) {\n          return cs1.offset - cs2.offset;\n        });\n        var length = stops.length; // Color and alpha list of first and last stop\n\n        var colorAndAlphaList = [];\n        var colors = [];\n\n        for (var i = 0; i < length; i++) {\n          var stop = stops[i];\n          var colorAndAlpha = getColorAndAlpha(stop.color);\n          colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n\n          if (i === 0 || i === length - 1) {\n            colorAndAlphaList.push(colorAndAlpha);\n          }\n        }\n\n        if (length >= 2) {\n          var color1 = colorAndAlphaList[0][0];\n          var color2 = colorAndAlphaList[1][0];\n          var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n          var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n          el.type = gradientType;\n          el.method = 'none';\n          el.focus = '100%';\n          el.angle = angle;\n          el.color = color1;\n          el.color2 = color2;\n          el.colors = colors.join(','); // When colors attribute is used, the meanings of opacity and o:opacity2\n          // are reversed.\n\n          el.opacity = opacity2; // FIXME g_o_:opacity ?\n\n          el.opacity2 = opacity1;\n        }\n\n        if (gradientType === 'radial') {\n          el.focusposition = focus.join(',');\n        }\n      } else {\n        // FIXME Change from Gradient fill to color fill\n        setColorAndOpacity(el, fill, style.opacity);\n      }\n    }\n  };\n\n  var updateStrokeNode = function (el, style) {\n    // if (style.lineJoin != null) {\n    //     el.joinstyle = style.lineJoin;\n    // }\n    // if (style.miterLimit != null) {\n    //     el.miterlimit = style.miterLimit * Z;\n    // }\n    // if (style.lineCap != null) {\n    //     el.endcap = style.lineCap;\n    // }\n    if (style.lineDash != null) {\n      el.dashstyle = style.lineDash.join(' ');\n    }\n\n    if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n      setColorAndOpacity(el, style.stroke, style.opacity);\n    }\n  };\n\n  var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n    var isFill = type == 'fill';\n    var el = vmlEl.getElementsByTagName(type)[0]; // Stroke must have lineWidth\n\n    if (style[type] != null && style[type] !== 'none' && (isFill || !isFill && style.lineWidth)) {\n      vmlEl[isFill ? 'filled' : 'stroked'] = 'true'; // FIXME Remove before updating, or set `colors` will throw error\n\n      if (style[type] instanceof Gradient) {\n        remove(vmlEl, el);\n      }\n\n      if (!el) {\n        el = vmlCore.createNode(type);\n      }\n\n      isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n      append(vmlEl, el);\n    } else {\n      vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n      remove(vmlEl, el);\n    }\n  };\n\n  var points = [[], [], []];\n\n  var pathDataToString = function (path, m) {\n    var M = CMD.M;\n    var C = CMD.C;\n    var L = CMD.L;\n    var A = CMD.A;\n    var Q = CMD.Q;\n    var str = [];\n    var nPoint;\n    var cmdStr;\n    var cmd;\n    var i;\n    var xi;\n    var yi;\n    var data = path.data;\n    var dataLength = path.len();\n\n    for (i = 0; i < dataLength;) {\n      cmd = data[i++];\n      cmdStr = '';\n      nPoint = 0;\n\n      switch (cmd) {\n        case M:\n          cmdStr = ' m ';\n          nPoint = 1;\n          xi = data[i++];\n          yi = data[i++];\n          points[0][0] = xi;\n          points[0][1] = yi;\n          break;\n\n        case L:\n          cmdStr = ' l ';\n          nPoint = 1;\n          xi = data[i++];\n          yi = data[i++];\n          points[0][0] = xi;\n          points[0][1] = yi;\n          break;\n\n        case Q:\n        case C:\n          cmdStr = ' c ';\n          nPoint = 3;\n          var x1 = data[i++];\n          var y1 = data[i++];\n          var x2 = data[i++];\n          var y2 = data[i++];\n          var x3;\n          var y3;\n\n          if (cmd === Q) {\n            // Convert quadratic to cubic using degree elevation\n            x3 = x2;\n            y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (xi + 2 * x1) / 3;\n            y1 = (yi + 2 * y1) / 3;\n          } else {\n            x3 = data[i++];\n            y3 = data[i++];\n          }\n\n          points[0][0] = x1;\n          points[0][1] = y1;\n          points[1][0] = x2;\n          points[1][1] = y2;\n          points[2][0] = x3;\n          points[2][1] = y3;\n          xi = x3;\n          yi = y3;\n          break;\n\n        case A:\n          var x = 0;\n          var y = 0;\n          var sx = 1;\n          var sy = 1;\n          var angle = 0;\n\n          if (m) {\n            // Extract SRT from matrix\n            x = m[4];\n            y = m[5];\n            sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n            sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n            angle = Math.atan2(-m[1] / sy, m[0] / sx);\n          }\n\n          var cx = data[i++];\n          var cy = data[i++];\n          var rx = data[i++];\n          var ry = data[i++];\n          var startAngle = data[i++] + angle;\n          var endAngle = data[i++] + startAngle + angle; // FIXME\n          // var psi = data[i++];\n\n          i++;\n          var clockwise = data[i++];\n          var x0 = cx + cos(startAngle) * rx;\n          var y0 = cy + sin(startAngle) * ry;\n          var x1 = cx + cos(endAngle) * rx;\n          var y1 = cy + sin(endAngle) * ry;\n          var type = clockwise ? ' wa ' : ' at ';\n\n          if (Math.abs(x0 - x1) < 1e-4) {\n            // IE won't render arches drawn counter clockwise if x0 == x1.\n            if (Math.abs(endAngle - startAngle) > 1e-2) {\n              // Offset x0 by 1/80 of a pixel. Use something\n              // that can be represented in binary\n              if (clockwise) {\n                x0 += 270 / Z;\n              }\n            } else {\n              // Avoid case draw full circle\n              if (Math.abs(y0 - cy) < 1e-4) {\n                if (clockwise && x0 < cx || !clockwise && x0 > cx) {\n                  y1 -= 270 / Z;\n                } else {\n                  y1 += 270 / Z;\n                }\n              } else if (clockwise && y0 < cy || !clockwise && y0 > cy) {\n                x1 += 270 / Z;\n              } else {\n                x1 -= 270 / Z;\n              }\n            }\n          }\n\n          str.push(type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2));\n          xi = x1;\n          yi = y1;\n          break;\n\n        case CMD.R:\n          var p0 = points[0];\n          var p1 = points[1]; // x0, y0\n\n          p0[0] = data[i++];\n          p0[1] = data[i++]; // x1, y1\n\n          p1[0] = p0[0] + data[i++];\n          p1[1] = p0[1] + data[i++];\n\n          if (m) {\n            applyTransform(p0, p0, m);\n            applyTransform(p1, p1, m);\n          }\n\n          p0[0] = round(p0[0] * Z - Z2);\n          p1[0] = round(p1[0] * Z - Z2);\n          p0[1] = round(p0[1] * Z - Z2);\n          p1[1] = round(p1[1] * Z - Z2);\n          str.push( // x0, y0\n          ' m ', p0[0], comma, p0[1], // x1, y0\n          ' l ', p1[0], comma, p0[1], // x1, y1\n          ' l ', p1[0], comma, p1[1], // x0, y1\n          ' l ', p0[0], comma, p1[1]);\n          break;\n\n        case CMD.Z:\n          // FIXME Update xi, yi\n          str.push(' x ');\n      }\n\n      if (nPoint > 0) {\n        str.push(cmdStr);\n\n        for (var k = 0; k < nPoint; k++) {\n          var p = points[k];\n          m && applyTransform(p, p, m); // 不 round 会非常慢\n\n          str.push(round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k < nPoint - 1 ? comma : '');\n        }\n      }\n    }\n\n    return str.join('');\n  }; // Rewrite the original path method\n\n\n  Path.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n    var vmlEl = this._vmlEl;\n\n    if (!vmlEl) {\n      vmlEl = vmlCore.createNode('shape');\n      initRootElStyle(vmlEl);\n      this._vmlEl = vmlEl;\n    }\n\n    updateFillAndStroke(vmlEl, 'fill', style, this);\n    updateFillAndStroke(vmlEl, 'stroke', style, this);\n    var m = this.transform;\n    var needTransform = m != null;\n    var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n\n    if (strokeEl) {\n      var lineWidth = style.lineWidth; // Get the line scale.\n      // Determinant of this.m_ means how much the area is enlarged by the\n      // transformation. So its square root can be used as a scale factor\n      // for width.\n\n      if (needTransform && !style.strokeNoScale) {\n        var det = m[0] * m[3] - m[1] * m[2];\n        lineWidth *= sqrt(abs(det));\n      }\n\n      strokeEl.weight = lineWidth + 'px';\n    }\n\n    var path = this.path || (this.path = new PathProxy());\n\n    if (this.__dirtyPath) {\n      path.beginPath();\n      this.buildPath(path, this.shape);\n      path.toStatic();\n      this.__dirtyPath = false;\n    }\n\n    vmlEl.path = pathDataToString(path, this.transform);\n    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\n    append(vmlRoot, vmlEl); // Text\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, this.getBoundingRect());\n    } else {\n      this.removeRectText(vmlRoot);\n    }\n  };\n\n  Path.prototype.onRemove = function (vmlRoot) {\n    remove(vmlRoot, this._vmlEl);\n    this.removeRectText(vmlRoot);\n  };\n\n  Path.prototype.onAdd = function (vmlRoot) {\n    append(vmlRoot, this._vmlEl);\n    this.appendRectText(vmlRoot);\n  };\n  /***************************************************\n   * IMAGE\n   **************************************************/\n\n\n  var isImage = function (img) {\n    // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错\n    return typeof img === 'object' && img.tagName && img.tagName.toUpperCase() === 'IMG'; // return img instanceof Image;\n  }; // Rewrite the original path method\n\n\n  ZImage.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n    var image = style.image; // Image original width, height\n\n    var ow;\n    var oh;\n\n    if (isImage(image)) {\n      var src = image.src;\n\n      if (src === this._imageSrc) {\n        ow = this._imageWidth;\n        oh = this._imageHeight;\n      } else {\n        var imageRuntimeStyle = image.runtimeStyle;\n        var oldRuntimeWidth = imageRuntimeStyle.width;\n        var oldRuntimeHeight = imageRuntimeStyle.height;\n        imageRuntimeStyle.width = 'auto';\n        imageRuntimeStyle.height = 'auto'; // get the original size\n\n        ow = image.width;\n        oh = image.height; // and remove overides\n\n        imageRuntimeStyle.width = oldRuntimeWidth;\n        imageRuntimeStyle.height = oldRuntimeHeight; // Caching image original width, height and src\n\n        this._imageSrc = src;\n        this._imageWidth = ow;\n        this._imageHeight = oh;\n      }\n\n      image = src;\n    } else {\n      if (image === this._imageSrc) {\n        ow = this._imageWidth;\n        oh = this._imageHeight;\n      }\n    }\n\n    if (!image) {\n      return;\n    }\n\n    var x = style.x || 0;\n    var y = style.y || 0;\n    var dw = style.width;\n    var dh = style.height;\n    var sw = style.sWidth;\n    var sh = style.sHeight;\n    var sx = style.sx || 0;\n    var sy = style.sy || 0;\n    var hasCrop = sw && sh;\n    var vmlEl = this._vmlEl;\n\n    if (!vmlEl) {\n      // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。\n      // vmlEl = vmlCore.createNode('group');\n      vmlEl = vmlCore.doc.createElement('div');\n      initRootElStyle(vmlEl);\n      this._vmlEl = vmlEl;\n    }\n\n    var vmlElStyle = vmlEl.style;\n    var hasRotation = false;\n    var m;\n    var scaleX = 1;\n    var scaleY = 1;\n\n    if (this.transform) {\n      m = this.transform;\n      scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n      scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n      hasRotation = m[1] || m[2];\n    }\n\n    if (hasRotation) {\n      // If filters are necessary (rotation exists), create them\n      // filters are bog-slow, so only create them if abbsolutely necessary\n      // The following check doesn't account for skews (which don't exist\n      // in the canvas spec (yet) anyway.\n      // From excanvas\n      var p0 = [x, y];\n      var p1 = [x + dw, y];\n      var p2 = [x, y + dh];\n      var p3 = [x + dw, y + dh];\n      applyTransform(p0, p0, m);\n      applyTransform(p1, p1, m);\n      applyTransform(p2, p2, m);\n      applyTransform(p3, p3, m);\n      var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n      var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n      var transformFilter = [];\n      transformFilter.push('M11=', m[0] / scaleX, comma, 'M12=', m[2] / scaleY, comma, 'M21=', m[1] / scaleX, comma, 'M22=', m[3] / scaleY, comma, 'Dx=', round(x * scaleX + m[4]), comma, 'Dy=', round(y * scaleY + m[5]));\n      vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0'; // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用\n\n      vmlElStyle.filter = imageTransformPrefix + '.Matrix(' + transformFilter.join('') + ', SizingMethod=clip)';\n    } else {\n      if (m) {\n        x = x * scaleX + m[4];\n        y = y * scaleY + m[5];\n      }\n\n      vmlElStyle.filter = '';\n      vmlElStyle.left = round(x) + 'px';\n      vmlElStyle.top = round(y) + 'px';\n    }\n\n    var imageEl = this._imageEl;\n    var cropEl = this._cropEl;\n\n    if (!imageEl) {\n      imageEl = vmlCore.doc.createElement('div');\n      this._imageEl = imageEl;\n    }\n\n    var imageELStyle = imageEl.style;\n\n    if (hasCrop) {\n      // Needs know image original width and height\n      if (!(ow && oh)) {\n        var tmpImage = new Image();\n        var self = this;\n\n        tmpImage.onload = function () {\n          tmpImage.onload = null;\n          ow = tmpImage.width;\n          oh = tmpImage.height; // Adjust image width and height to fit the ratio destinationSize / sourceSize\n\n          imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n          imageELStyle.height = round(scaleY * oh * dh / sh) + 'px'; // Caching image original width, height and src\n\n          self._imageWidth = ow;\n          self._imageHeight = oh;\n          self._imageSrc = image;\n        };\n\n        tmpImage.src = image;\n      } else {\n        imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n        imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n      }\n\n      if (!cropEl) {\n        cropEl = vmlCore.doc.createElement('div');\n        cropEl.style.overflow = 'hidden';\n        this._cropEl = cropEl;\n      }\n\n      var cropElStyle = cropEl.style;\n      cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n      cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n      cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx=' + -sx * dw / sw * scaleX + ',Dy=' + -sy * dh / sh * scaleY + ')';\n\n      if (!cropEl.parentNode) {\n        vmlEl.appendChild(cropEl);\n      }\n\n      if (imageEl.parentNode != cropEl) {\n        cropEl.appendChild(imageEl);\n      }\n    } else {\n      imageELStyle.width = round(scaleX * dw) + 'px';\n      imageELStyle.height = round(scaleY * dh) + 'px';\n      vmlEl.appendChild(imageEl);\n\n      if (cropEl && cropEl.parentNode) {\n        vmlEl.removeChild(cropEl);\n        this._cropEl = null;\n      }\n    }\n\n    var filterStr = '';\n    var alpha = style.opacity;\n\n    if (alpha < 1) {\n      filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n    }\n\n    filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n    imageELStyle.filter = filterStr;\n    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\n    append(vmlRoot, vmlEl); // Text\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, this.getBoundingRect());\n    }\n  };\n\n  ZImage.prototype.onRemove = function (vmlRoot) {\n    remove(vmlRoot, this._vmlEl);\n    this._vmlEl = null;\n    this._cropEl = null;\n    this._imageEl = null;\n    this.removeRectText(vmlRoot);\n  };\n\n  ZImage.prototype.onAdd = function (vmlRoot) {\n    append(vmlRoot, this._vmlEl);\n    this.appendRectText(vmlRoot);\n  };\n  /***************************************************\n   * TEXT\n   **************************************************/\n\n\n  var DEFAULT_STYLE_NORMAL = 'normal';\n  var fontStyleCache = {};\n  var fontStyleCacheCount = 0;\n  var MAX_FONT_CACHE_SIZE = 100;\n  var fontEl = document.createElement('div');\n\n  var getFontStyle = function (fontString) {\n    var fontStyle = fontStyleCache[fontString];\n\n    if (!fontStyle) {\n      // Clear cache\n      if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n        fontStyleCacheCount = 0;\n        fontStyleCache = {};\n      }\n\n      var style = fontEl.style;\n      var fontFamily;\n\n      try {\n        style.font = fontString;\n        fontFamily = style.fontFamily.split(',')[0];\n      } catch (e) {}\n\n      fontStyle = {\n        style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n        variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n        weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n        size: parseFloat(style.fontSize || 12) | 0,\n        family: fontFamily || 'Microsoft YaHei'\n      };\n      fontStyleCache[fontString] = fontStyle;\n      fontStyleCacheCount++;\n    }\n\n    return fontStyle;\n  };\n\n  var textMeasureEl; // Overwrite measure text method\n\n  textContain.$override('measureText', function (text, textFont) {\n    var doc = vmlCore.doc;\n\n    if (!textMeasureEl) {\n      textMeasureEl = doc.createElement('div');\n      textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;' + 'padding:0;margin:0;border:none;white-space:pre;';\n      vmlCore.doc.body.appendChild(textMeasureEl);\n    }\n\n    try {\n      textMeasureEl.style.font = textFont;\n    } catch (ex) {// Ignore failures to set to invalid font.\n    }\n\n    textMeasureEl.innerHTML = ''; // Don't use innerHTML or innerText because they allow markup/whitespace.\n\n    textMeasureEl.appendChild(doc.createTextNode(text));\n    return {\n      width: textMeasureEl.offsetWidth\n    };\n  });\n  var tmpRect = new BoundingRect();\n\n  var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true);\n    var text = style.text; // Convert to string\n\n    text != null && (text += '');\n\n    if (!text) {\n      return;\n    } // Convert rich text to plain text. Rich text is not supported in\n    // IE8-, but tags in rich text template will be removed.\n\n\n    if (style.rich) {\n      var contentBlock = textContain.parseRichText(text, style);\n      text = [];\n\n      for (var i = 0; i < contentBlock.lines.length; i++) {\n        var tokens = contentBlock.lines[i].tokens;\n        var textLine = [];\n\n        for (var j = 0; j < tokens.length; j++) {\n          textLine.push(tokens[j].text);\n        }\n\n        text.push(textLine.join(''));\n      }\n\n      text = text.join('\\n');\n    }\n\n    var x;\n    var y;\n    var align = style.textAlign;\n    var verticalAlign = style.textVerticalAlign;\n    var fontStyle = getFontStyle(style.font); // FIXME encodeHtmlAttribute ?\n\n    var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' ' + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n    textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign); // Transform rect to view space\n\n    var m = this.transform; // Ignore transform for text in other element\n\n    if (m && !fromTextEl) {\n      tmpRect.copy(rect);\n      tmpRect.applyTransform(m);\n      rect = tmpRect;\n    }\n\n    if (!fromTextEl) {\n      var textPosition = style.textPosition;\n      var distance = style.textDistance; // Text position represented by coord\n\n      if (textPosition instanceof Array) {\n        x = rect.x + parsePercent(textPosition[0], rect.width);\n        y = rect.y + parsePercent(textPosition[1], rect.height);\n        align = align || 'left';\n      } else {\n        var res = textContain.adjustTextPositionOnRect(textPosition, rect, distance);\n        x = res.x;\n        y = res.y; // Default align and baseline when has textPosition\n\n        align = align || res.textAlign;\n        verticalAlign = verticalAlign || res.textVerticalAlign;\n      }\n    } else {\n      x = rect.x;\n      y = rect.y;\n    }\n\n    x = textContain.adjustTextX(x, textRect.width, align);\n    y = textContain.adjustTextY(y, textRect.height, verticalAlign); // Force baseline 'middle'\n\n    y += textRect.height / 2; // var fontSize = fontStyle.size;\n    // 1.75 is an arbitrary number, as there is no info about the text baseline\n    // switch (baseline) {\n    // case 'hanging':\n    // case 'top':\n    //     y += fontSize / 1.75;\n    //     break;\n    //     case 'middle':\n    //         break;\n    //     default:\n    //     // case null:\n    //     // case 'alphabetic':\n    //     // case 'ideographic':\n    //     // case 'bottom':\n    //         y -= fontSize / 2.25;\n    //         break;\n    // }\n    // switch (align) {\n    //     case 'left':\n    //         break;\n    //     case 'center':\n    //         x -= textRect.width / 2;\n    //         break;\n    //     case 'right':\n    //         x -= textRect.width;\n    //         break;\n    // case 'end':\n    // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n    // break;\n    // case 'start':\n    // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n    // break;\n    // default:\n    //     align = 'left';\n    // }\n\n    var createNode = vmlCore.createNode;\n    var textVmlEl = this._textVmlEl;\n    var pathEl;\n    var textPathEl;\n    var skewEl;\n\n    if (!textVmlEl) {\n      textVmlEl = createNode('line');\n      pathEl = createNode('path');\n      textPathEl = createNode('textpath');\n      skewEl = createNode('skew'); // FIXME Why here is not cammel case\n      // Align 'center' seems wrong\n\n      textPathEl.style['v-text-align'] = 'left';\n      initRootElStyle(textVmlEl);\n      pathEl.textpathok = true;\n      textPathEl.on = true;\n      textVmlEl.from = '0 0';\n      textVmlEl.to = '1000 0.05';\n      append(textVmlEl, skewEl);\n      append(textVmlEl, pathEl);\n      append(textVmlEl, textPathEl);\n      this._textVmlEl = textVmlEl;\n    } else {\n      // 这里是在前面 appendChild 保证顺序的前提下\n      skewEl = textVmlEl.firstChild;\n      pathEl = skewEl.nextSibling;\n      textPathEl = pathEl.nextSibling;\n    }\n\n    var coords = [x, y];\n    var textVmlElStyle = textVmlEl.style; // Ignore transform for text in other element\n\n    if (m && fromTextEl) {\n      applyTransform(coords, coords, m);\n      skewEl.on = true;\n      skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0'; // Text position\n\n      skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0); // Left top point as origin\n\n      skewEl.origin = '0 0';\n      textVmlElStyle.left = '0px';\n      textVmlElStyle.top = '0px';\n    } else {\n      skewEl.on = false;\n      textVmlElStyle.left = round(x) + 'px';\n      textVmlElStyle.top = round(y) + 'px';\n    }\n\n    textPathEl.string = encodeHtmlAttribute(text); // TODO\n\n    try {\n      textPathEl.style.font = font;\n    } // Error font format\n    catch (e) {}\n\n    updateFillAndStroke(textVmlEl, 'fill', {\n      fill: style.textFill,\n      opacity: style.opacity\n    }, this);\n    updateFillAndStroke(textVmlEl, 'stroke', {\n      stroke: style.textStroke,\n      opacity: style.opacity,\n      lineDash: style.lineDash\n    }, this);\n    textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Attached to root\n\n    append(vmlRoot, textVmlEl);\n  };\n\n  var removeRectText = function (vmlRoot) {\n    remove(vmlRoot, this._textVmlEl);\n    this._textVmlEl = null;\n  };\n\n  var appendRectText = function (vmlRoot) {\n    append(vmlRoot, this._textVmlEl);\n  };\n\n  var list = [RectText, Displayable, ZImage, Path, Text]; // In case Displayable has been mixed in RectText\n\n  for (var i = 0; i < list.length; i++) {\n    var proto = list[i].prototype;\n    proto.drawRectText = drawRectText;\n    proto.removeRectText = removeRectText;\n    proto.appendRectText = appendRectText;\n  }\n\n  Text.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, {\n        x: style.x || 0,\n        y: style.y || 0,\n        width: 0,\n        height: 0\n      }, this.getBoundingRect(), true);\n    } else {\n      this.removeRectText(vmlRoot);\n    }\n  };\n\n  Text.prototype.onRemove = function (vmlRoot) {\n    this.removeRectText(vmlRoot);\n  };\n\n  Text.prototype.onAdd = function (vmlRoot) {\n    this.appendRectText(vmlRoot);\n  };\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/vml/graphic.js\n// module id = 138\n// module chunks = 0","var env = require(\"../core/env\");\n\nvar urn = 'urn:schemas-microsoft-com:vml';\nvar win = typeof window === 'undefined' ? null : window;\nvar vmlInited = false;\nvar doc = win && win.document;\n\nfunction createNode(tagName) {\n  return doCreateNode(tagName);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nvar doCreateNode;\n\nif (doc && !env.canvasSupported) {\n  try {\n    !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);\n\n    doCreateNode = function (tagName) {\n      return doc.createElement('<zrvml:' + tagName + ' class=\"zrvml\">');\n    };\n  } catch (e) {\n    doCreateNode = function (tagName) {\n      return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"zrvml\">');\n    };\n  }\n} // From raphael\n\n\nfunction initVML() {\n  if (vmlInited || !doc) {\n    return;\n  }\n\n  vmlInited = true;\n  var styleSheets = doc.styleSheets;\n\n  if (styleSheets.length < 31) {\n    doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');\n  } else {\n    // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n    styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');\n  }\n}\n\nexports.doc = doc;\nexports.createNode = createNode;\nexports.initVML = initVML;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/vml/core.js\n// module id = 139\n// module chunks = 0","var zrLog = require(\"../core/log\");\n\nvar vmlCore = require(\"./core\");\n\nvar _util = require(\"../core/util\");\n\nvar each = _util.each;\n\n/**\n * VML Painter.\n *\n * @module zrender/vml/Painter\n */\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n/**\n * @alias module:zrender/vml/Painter\n */\n\n\nfunction VMLPainter(root, storage) {\n  vmlCore.initVML();\n  this.root = root;\n  this.storage = storage;\n  var vmlViewport = document.createElement('div');\n  var vmlRoot = document.createElement('div');\n  vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n  vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n  root.appendChild(vmlViewport);\n  this._vmlRoot = vmlRoot;\n  this._vmlViewport = vmlViewport;\n  this.resize(); // Modify storage\n\n  var oldDelFromStorage = storage.delFromStorage;\n  var oldAddToStorage = storage.addToStorage;\n\n  storage.delFromStorage = function (el) {\n    oldDelFromStorage.call(storage, el);\n\n    if (el) {\n      el.onRemove && el.onRemove(vmlRoot);\n    }\n  };\n\n  storage.addToStorage = function (el) {\n    // Displayable already has a vml node\n    el.onAdd && el.onAdd(vmlRoot);\n    oldAddToStorage.call(storage, el);\n  };\n\n  this._firstPaint = true;\n}\n\nVMLPainter.prototype = {\n  constructor: VMLPainter,\n  getType: function () {\n    return 'vml';\n  },\n\n  /**\n   * @return {HTMLDivElement}\n   */\n  getViewportRoot: function () {\n    return this._vmlViewport;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\n   * 刷新\n   */\n  refresh: function () {\n    var list = this.storage.getDisplayList(true, true);\n\n    this._paintList(list);\n  },\n  _paintList: function (list) {\n    var vmlRoot = this._vmlRoot;\n\n    for (var i = 0; i < list.length; i++) {\n      var el = list[i];\n\n      if (el.invisible || el.ignore) {\n        if (!el.__alreadyNotVisible) {\n          el.onRemove(vmlRoot);\n        } // Set as already invisible\n\n\n        el.__alreadyNotVisible = true;\n      } else {\n        if (el.__alreadyNotVisible) {\n          el.onAdd(vmlRoot);\n        }\n\n        el.__alreadyNotVisible = false;\n\n        if (el.__dirty) {\n          el.beforeBrush && el.beforeBrush();\n          (el.brushVML || el.brush).call(el, vmlRoot);\n          el.afterBrush && el.afterBrush();\n        }\n      }\n\n      el.__dirty = false;\n    }\n\n    if (this._firstPaint) {\n      // Detached from document at first time\n      // to avoid page refreshing too many times\n      // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变\n      this._vmlViewport.appendChild(vmlRoot);\n\n      this._firstPaint = false;\n    }\n  },\n  resize: function (width, height) {\n    var width = width == null ? this._getWidth() : width;\n    var height = height == null ? this._getHeight() : height;\n\n    if (this._width != width || this._height != height) {\n      this._width = width;\n      this._height = height;\n      var vmlViewportStyle = this._vmlViewport.style;\n      vmlViewportStyle.width = width + 'px';\n      vmlViewportStyle.height = height + 'px';\n    }\n  },\n  dispose: function () {\n    this.root.innerHTML = '';\n    this._vmlRoot = this._vmlViewport = this.storage = null;\n  },\n  getWidth: function () {\n    return this._width;\n  },\n  getHeight: function () {\n    return this._height;\n  },\n  clear: function () {\n    if (this._vmlViewport) {\n      this.root.removeChild(this._vmlViewport);\n    }\n  },\n  _getWidth: function () {\n    var root = this.root;\n    var stl = root.currentStyle;\n    return (root.clientWidth || parseInt10(stl.width)) - parseInt10(stl.paddingLeft) - parseInt10(stl.paddingRight) | 0;\n  },\n  _getHeight: function () {\n    var root = this.root;\n    var stl = root.currentStyle;\n    return (root.clientHeight || parseInt10(stl.height)) - parseInt10(stl.paddingTop) - parseInt10(stl.paddingBottom) | 0;\n  }\n}; // Not supported methods\n\nfunction createMethodNotSupport(method) {\n  return function () {\n    zrLog('In IE8.0 VML mode painter not support method \"' + method + '\"');\n  };\n} // Unsupported methods\n\n\neach(['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'], function (name) {\n  VMLPainter.prototype[name] = createMethodNotSupport(name);\n});\nvar _default = VMLPainter;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/vml/Painter.js\n// module id = 140\n// module chunks = 0"]}