(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["fishTopoBo"] = factory();
	else
		root["fishTopoBo"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Export fishTopo as CommonJS module
	 */
	module.exports = __webpack_require__(2);
	//兼容IE8 引入VML 如果不需要兼容IE8请删除
	__webpack_require__(82);
	


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Created by majianan on 16/5/19.
	 *
	 */
	
	    var zr = __webpack_require__(3);
	    var util = __webpack_require__(6);
	    var BoNode = __webpack_require__(42);
	    var Relation = __webpack_require__(80);
	    var Const = __webpack_require__(43);
	    var graphic = __webpack_require__(45);
	    var eventTool = __webpack_require__(39);
	    __webpack_require__(81);
	
	    function FishTopoBo(dom, opts) {
	        /**
	         * 缩放
	         * @type {number}
	         */
	        this.nowZoom = 1;
	        this.canScale = true;
	
	        /**
	         * 初始化zrender
	         */
	        this._zr = zr.init(dom, {
	            renderer: opts.renderer || 'canvas',
	            devicePixelRatio: opts.devicePixelRatio
	        });
	    }
	
	    var fishTopoProto = FishTopoBo.prototype;
	
	    /**
	     * 初始化
	     */
	    fishTopoProto.init = function () {
	        this.group = new graphic.Group();
	        this.groupDrag(this.group);
	        this._zr.add(this.group);
	        this.zrScale();
	    };
	
	    /**
	     * 调整尺寸  在窗口大小发生改变时需要手工调用
	     */
	    fishTopoProto.resize = function () {
	        this._zr.resize();
	    };
	
	    /**
	     * 添加BO
	     * @param {Object} boData, bo数据
	     * @param {{
	     *          startPos: {x: number, y: number} 起始位置,
	     *          displayAttrDataType: boolean 是否显示属性数据类型,
	     *          displayAttrEvent: boolean 是否显示属性事件决策,
	     *          boClickable: boolean BO是否支持点击事件, 可空 默认false
	     *          boPopupUrl: String 点击BO弹出页面地址
	     *          boEventClickable: boolean BO事件决策是否支持点击事件, 可空 默认false
	     *          boEventPopupUrl: String 点击BO事件决策弹出页面地址
	     *          bindBoClickEvent: function(options) BO点击事件，返回函数参数为options，它的属性有DATA等
	     *          attrEventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false
	     *          attrEventPopupUrl: String 点击BO属性事件决策弹出页面地址
	     *          isCurrent: boolean 是否为当前BO
	     *          lineStyle: {stroke: string, lineWidth: number, lineDash: Array} 关联线样式
	     *          lineHoverStyle: {stroke: string, lineWidth: number, lineDash: Array} 关联线hover样式
	     *          arrowStyle: {fill: string, stroke: string} 关联线箭头样式
	     *          arrowHoverStyle: {fill: string, stroke: string} 关联线箭头hover样式
	     *          }} opts
	     * @returns {*}
	     */
	    fishTopoProto.addBo = function (boData, opts) {
	        //设置BO父子关系，便于后续整体移动
	        this._setParent(boData);
	
	        //layout BO的布局信息，x,y左上角起始坐标, level:层级
	        boData.layout = {
	            x: opts.startPos.x,
	            y: opts.startPos.y,
	            level: 1
	        };
	
	        //计算BO的X坐标
	        this._bfs(boData);
	
	        //按照起始坐标整体左移
	        this._moveRightByParent(boData, opts.startPos.x - boData.layout.x);
	
	        //画BO
	        var boNode = new BoNode(boData, opts);
	        this.group.add(boNode.getShape());
	
	        //创建子BO
	        this.addChildBo(boNode, opts);
	
	        return boNode;
	    };
	
	    /**
	     * 设置BO的父子关系
	     * @param {Object} boData BO数据
	     * @private
	     */
	    fishTopoProto._setParent = function (boData) {
	        if (boData.child) {
	            var childCnt = boData.child.length,
	                childBoArr = boData.child;
	            for (var i = 0; i < childCnt; i++) {
	                childBoArr[i].parent = boData;
	                if (childBoArr[i + 1]) {
	                    childBoArr[i].next = childBoArr[i + 1];
	                }
	                //设置最后子节点的next=下一个父节点的第一个子节点
	                else if (boData.next && boData.next.child) {
	                    childBoArr[i].next = boData.next.child[0];
	                }
	                this._setParent(childBoArr[i]);
	            }
	        }
	    };
	
	
	    /**
	     * Breadth-First-Search 计算X坐标
	     * 由于BO宽度定死，可以在画图之前计算每个BO的起始X坐标
	     * 每个BO的高度根据显示内容不固定，因此需要根据实际的父BO高度才能计算本身的起始Y坐标
	     * @param boData
	     * @private
	     */
	    fishTopoProto._bfs = function (boData) {
	        //用于保存每个level的最大坐标值
	        this._levelMaxPos = {};
	
	        this._queue = [];   //存放BO数据
	        this._queue.push(boData);
	
	        while (this._queue.length > 0) {
	            var tmp = this._queue.shift();
	            //console.log('BO[' + tmp.name + '] {x: ' + tmp.layout.x + ', level: ' + tmp.layout.level + '} ');
	            //console.log('    ***Before this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);
	
	            //该level第一个节点
	            if (!this._levelMaxPos[tmp.layout.level]) {
	                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};
	            }
	            //当前就是最右侧的节点
	            else if (this._levelMaxPos[tmp.layout.level].x + Const.BO_NODE_WIDTH <= tmp.layout.x) {
	                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};
	            }
	            //当前节点与之前的节点有交叉，则需要连同父节点整体向右移动
	            else {
	                this._moveRightByChild(tmp, this._levelMaxPos[tmp.layout.level].x - tmp.layout.x + Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X)
	                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};
	            }
	
	            //console.log('    ***After this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);
	
	            //存在子节点，计算子节点坐标，同时添加到队列中，以便后续计算调整x坐标
	            if (tmp.child) {
	                var childCnt = tmp.child.length;
	
	                for (var i = 0; i < childCnt; i++) {
	
	                    tmp.child[i].layout = {
	                        x: tmp.layout.x - (Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X) * ((childCnt - 1) / 2 - i),
	                        level: tmp.layout.level + 1
	                    };
	
	                    this._queue.push(tmp.child[i]);
	                }
	            }
	        }
	    };
	
	    /**
	     * 子节点右移时，同时下一个子节点，以及父节点都同时移动
	     * @param boData
	     * @param width
	     * @private
	     */
	    fishTopoProto._moveRightByChild = function (boData, width) {
	        if (boData) {
	
	            if (!boData.layout.moved) {
	
	                if (boData.layout.level == 1) {
	                    boData.layout.x += width / 2;
	                } else {
	                    boData.layout.x += width;
	                }
	
	                boData.layout.moved = true;
	            }
	            //当前节点的下一节点整体右移
	            this._moveRightByPrevious(boData.next, width);
	            //当前节点的父节点整体右移
	            this._moveRightByChild(boData.parent, width);
	        }
	
	    };
	
	    /**
	     * 前一个节点右移的时候，所有后面的节点整体右移
	     * @param boData
	     * @param width
	     * @private
	     */
	    fishTopoProto._moveRightByPrevious = function (boData, width) {
	        if (boData) {
	            boData.layout.x += width;
	            //当前节点的所有后续节点整体右移
	            this._moveRightByPrevious(boData.next, width);
	        }
	    };
	
	    /**
	     * 父节点右移时，所有子节点整体右移
	     * @param boData
	     * @param width
	     * @private
	     */
	    fishTopoProto._moveRightByParent = function (boData, width) {
	        if (boData) {
	            boData.layout.x += width;
	            if (boData.child) {
	                for (var i = 0; i < boData.child.length; i++) {
	                    this._moveRightByParent(boData.child[i], width);
	                }
	            }
	        }
	    };
	
	    /**
	     * 添加子BO
	     * @param {BoNode} parentBoNode
	     * @param {Object} opts
	     * @private
	     */
	    fishTopoProto.addChildBo = function (parentBoNode, opts) {
	
	        this._queue = []; //需要根据BO节点的实际高度计算自己点的起始Y坐标，因此存放的是BoNode图形
	        this._queue.push(parentBoNode);
	
	        while (this._queue.length > 0) {
	            var tmp = this._queue.shift(),
	                boNodeHeight = tmp.getShape().getBoundingRect().height;
	            //console.log('Parent BO[' + tmp.getData().name + '] {y: ' + tmp.getLayout().y + ', level: ' + tmp.getLayout().level + ', boNodeHeight:' + boNodeHeight + '} ');
	            //console.log('    ***Before this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);
	
	            //如果是该Level第一个节点，或者当低于原来的节点
	            if (!this._levelMaxPos[tmp.getLayout().level].y ||
	                this._levelMaxPos[tmp.getLayout().level].y < tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y) {
	                this._levelMaxPos[tmp.getLayout().level].y = tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y;
	            }
	
	            //console.log('    ***After this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);
	
	            if (tmp.getData().child) {
	
	                var childBoArr = tmp.getData().child,
	                    childCnt = childBoArr.length,
	                    boNode,
	                    relationNode;
	
	                //该level所有子节点的起始Y坐标都相同
	                opts.startPos.y = this._levelMaxPos[tmp.getLayout().level].y;
	                for (var i = 0; i < childCnt; i++) {
	                    opts.startPos.x = childBoArr[i].layout.x;
	                    childBoArr[i].layout.y = opts.startPos.y;
	                    boNode = new BoNode(childBoArr[i], opts);
	                    //console.log('Child BO[' + boNode.getData().name + '] {y: ' + opts.startPos.y + ', level: ' + boNode.getLayout().level + '} ');
	
	                    this.group.add(boNode.getShape());
	                    this._queue.push(boNode);
	
	                    //BO关系
	                    if (childBoArr[i].relation) {
	                        var _relationLen = childBoArr[i].relation.length;
	                        for (var j = 0; j < _relationLen; j++) {
	                            var sourceId = childBoArr[i].relation[j].sourceId,
	                                targetId = childBoArr[i].relation[j].targetId,
	                                sourceText = childBoArr[i].relation[j].sourceText,
	                                targetText = childBoArr[i].relation[j].targetText;
	
	                            relationNode = new Relation(
	                                boNode.getShape().childOfName(sourceId),
	                                tmp.getShape().childOfName(targetId),
	                                sourceText,
	                                targetText,
	                                opts.lineStyle,
	                                opts.lineHoverStyle,
	                                opts.arrowStyle,
	                                opts.arrowHoverStyle
	                            );
	                            this.group.add(relationNode.getShape());
	                        }
	                    }
	                }
	
	            }
	        }
	    };
	
	    /**
	     * 设置当前BO为特殊样式
	     * @param {String} boId, BO标识
	     * @param {Object} style, BO特殊样式,可空
	     */
	    fishTopoProto.setCurrentBo = function (boId, style) {
	        var length = this.group.childCount();
	        for (var i = 0; i < length; i++) {
	            if (this.group.childAt(i).name == boId) {
	                this.group.childAt(i).setCurrent(style);
	            }
	        }
	    };
	
	    /**
	     * 清空
	     */
	    fishTopoProto.clear = function () {
	        this._zr.clear();
	        this.group = new graphic.Group();
	        this._zr.add(this.group);
	    };
	
	    /**
	     * 缩放功能
	     * @param type
	     */
	    fishTopoProto.zrScale = function (type) {
	        var that = this;
	        if (type) {
	            if (type == "narrowing") {
	                var zoomDelta = 1 / 1.1;
	                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);
	            }
	            if (type == "enlarge") {
	                var zoomDelta = 1.1;
	                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);
	            }
	        } else {
	            that._zr.on('mousewheel', function (e) {
	                eventTool.stop(e.event);
	                var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;
	                zoom(zoomDelta, e.offsetX, e.offsetY);
	            });
	        }
	        ;
	        function zoom(zoomDelta, zoomX, zoomY) {
	            if (that.canScale == false) {
	                return;
	            }
	            var target = that.group;
	            if (target) {
	                var pos = target.position;
	                var scale = target.scale;
	                var newZoom = that._zoom = that._zoom || 1;
	                newZoom *= zoomDelta;
	                var zoomScale = newZoom / that._zoom;
	                // if(newZoom>2.6||newZoom<0.38){
	                //     return;
	                // };
	                that._zoom = newZoom;
	
	                that.nowZoom = newZoom;
	                // Keep the mouse center when scaling
	                pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);
	                pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);
	                scale[0] *= zoomScale;
	                scale[1] *= zoomScale;
	                target.attr("position", [pos[0], pos[1]]);
	                target.attr("scale", [scale[0], scale[1]]);
	                //that.minimap.updateSelectionPosition(pos,zoomScale);
	            }
	        }
	    };
	
	    /**
	     * 拖拽Group
	     */
	    fishTopoProto.groupDrag = function () {
	        var that = this;
	        that._zr.on("mousedown", function (e) {
	            groupDragFunction(e);
	            e.cancelBubble = true;
	        });
	        function groupDragFunction(e) {
	            var startX = e.event.clientX;
	            var startY = e.event.clientY;
	            var moveFunction = function (e) {
	                moveDrag(e);
	            }
	            var nowGroupPosition = that.group.position;
	            var groupPositionX = that.group.position[0];
	            var groupPositionY = that.group.position[1];
	            var alarmPositionX, alarmPositionY;
	
	            function moveDrag(e) {
	                var width = that.group.getBoundingRect().width * that.nowZoom;
	                var height = that.group.getBoundingRect().height * that.nowZoom;
	                var gx = that.group.getBoundingRect().x * that.nowZoom;
	                var gy = that.group.getBoundingRect().y * that.nowZoom;
	                var min = [10 - (width + gx), 10 - (height + gy)];
	                var max = [(that._zr.getWidth() - gx) - 10, (that._zr.getHeight() - gy) - 10];
	                var sX = (e.event.clientX - startX) * (that.nowZoom);
	                var sY = (e.event.clientY - startY) * (that.nowZoom);
	                nowGroupPosition[0] = groupPositionX + (sX);
	                nowGroupPosition[1] = groupPositionY + (sY);
	                if (nowGroupPosition[0] > max[0] || nowGroupPosition[1] > max[1] || nowGroupPosition[0] < min[0] || nowGroupPosition[1] < min[1]) {
	                    return;
	                } else {
	                    that.group.attr("position", nowGroupPosition);
	                }
	            }
	
	            that._zr.on('mousemove', moveFunction);
	            var upFunction = function (e) {
	                endDrag(e);
	            }
	
	            function endDrag(e) {
	                that._zr.off('mousemove', moveFunction);
	                that._zr.off('mouseup', upFunction);
	                that._zr.off("globalout", upFunction);
	            }
	
	            that._zr.on('mouseup', upFunction);
	            that._zr.on("globalout", upFunction);
	        }
	    };
	
	    /**
	     * 拖拽
	     * @param node
	     */
	    fishTopoProto.drag = function (node) {
	        var that = this;
	        node.on("mousedown", function (e) {
	            if (this.isdraggable == false) {
	                return;
	            }
	            groupDragFunction(e);
	            e.cancelBubble = true;
	        });
	        function groupDragFunction(e) {
	            var startX = e.event.clientX;
	            var startY = e.event.clientY;
	            var moveFunction = function (e) {
	                moveDrag(e);
	            }
	            var nowGroupPosition = node.position;
	            var groupPositionX = node.position[0];
	            var groupPositionY = node.position[1];
	            var alarmPositionX, alarmPositionY;
	            if (node.alarm) {
	                var newAlarmPosition = node.alarm.position;
	                alarmPositionX = node.alarm.position[0];
	                alarmPositionY = node.alarm.position[1];
	            }
	            ;
	            function moveDrag(e) {
	                var sX = (e.event.clientX - startX) / (that.nowZoom);
	                var sY = (e.event.clientY - startY) / (that.nowZoom);
	                if (node.parent && node.parent instanceof GroupNode) {
	                    //放入node现有数值，用于重绘group
	                    var nodeMessage = {
	                        width: node.shape.width,
	                        height: node.shape.height,
	                        position: node.position,
	                        nodeXY: [node.shape.x, node.shape.y],
	                        movePosition: [groupPositionX, groupPositionY],
	                        moveX: sX,
	                        moveY: sY
	                    };
	                    var groupNode = node.parent;
	                    groupNode.reDraw(nodeMessage, node);
	                } else {
	                    nowGroupPosition[0] = groupPositionX + (sX);
	                    nowGroupPosition[1] = groupPositionY + (sY);
	                    node.attr("position", nowGroupPosition);
	                    if (node.alarm) {
	                        var newAlarmPosition = [nowGroupPosition[0] + node.getBoundingRect().width - (node.alarm.getBoundingRect().width - 6), nowGroupPosition[1] - node.alarm.getBoundingRect().height - 3];
	                        node.alarm.attr("position", newAlarmPosition);
	                    }
	                    ;
	                }
	                ConnectionManager.refreshLineByNode(node);
	            }
	
	            that._zr.on('mousemove', moveFunction);
	            var upFunction = function (e) {
	                endDrag(e);
	            }
	            //拖拽结束
	            function endDrag(e) {
	                that._zr.off('mousemove', moveFunction);
	                that._zr.off('mouseup', upFunction);
	                that._zr.off("globalout", upFunction);
	                //布局重新计算
	                if (node.layout) {
	                    that.layoutNode("tree", {"node": node});
	                }
	                if (that.forceLayoutOption) {
	                    var nodes = that.forceLayoutOption.allNodes;
	                    if (_.indexOf(nodes, node) != -1) {
	                        that.layoutNode("force", this.forceLayoutOption);
	                    }
	                }
	                ;
	            }
	
	            that._zr.on('mouseup', upFunction);
	            that._zr.on("globalout", upFunction);
	        }
	    };
	
	
	    // ---------对外暴露fishTopoBo------------------
	    var idBase = new Date() - 0;
	    var instances = {};
	    var DOM_ATTRIBUTE_KEY = '_fishTopoBo_instance_';
	    var fishTopoBo = {
	        /**
	         * @type {number}
	         */
	        version: '3.0.0',
	        dependencies: {
	            zrender: '3.0.4'
	        }
	    };
	
	    /**
	     * @param {HTMLDomElement} dom
	     * @param {Object} opts
	     */
	    fishTopoBo.init = function (dom, opts) {
	        if (!dom) {
	            throw new Error('Initialize failed: invalid dom.');
	        }
	
	        opts = opts || {};
	        // Default value
	        util.defaults(opts,
	            {
	                type: "bpmn",
	                showGridLine: true,
	                devicePixelRatio: 1,
	                gridLineSpacing:10
	            }
	        );
	
	        var fishTopoBo = new FishTopoBo(dom, opts);
	        fishTopoBo.init();
	
	        fishTopoBo.id = 'ft_' + idBase++;
	        instances[fishTopoBo.id] = fishTopoBo;
	
	        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoBo.id);
	
	        return fishTopoBo;
	    };
	
	
	    /**
	     * @param  {HTMLDomElement} dom
	     * @return {fishTopo}
	     */
	    fishTopoBo.getInstanceByDom = function (dom) {
	        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);
	        return instances[key];
	    };
	
	    /**
	     * Dispose a fishTopo instance
	     * @param  {module:fishTopo|HTMLDomElement|string} fishTopo
	     */
	    fishTopoBo.dispose = function (chart) {
	        var topo;
	        if (zrUtil.isDom(chart)) {
	            topo = fishTopoBo.getInstanceByDom(chart);
	        }
	        else if (typeof chart === 'string') {
	            topo = instances[chart];
	        }
	        if ((topo instanceof fishTopoBo) && !topo.isDisposed()) {
	            topo.dispose();
	        }
	    };
	
	    module.exports = fishTopoBo;
	


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	var guid = __webpack_require__(4);
	
	var env = __webpack_require__(5);
	
	var zrUtil = __webpack_require__(6);
	
	var Handler = __webpack_require__(7);
	
	var Storage = __webpack_require__(11);
	
	var Painter = __webpack_require__(26);
	
	var Animation = __webpack_require__(38);
	
	var HandlerProxy = __webpack_require__(40);
	
	/*!
	* ZRender, a high performance 2d drawing library.
	*
	* Copyright (c) 2013, Baidu Inc.
	* All rights reserved.
	*
	* LICENSE
	* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
	*/
	var useVML = !env.canvasSupported;
	var painterCtors = {
	  canvas: Painter
	};
	var instances = {}; // ZRender实例map索引
	
	/**
	 * @type {string}
	 */
	
	var version = '3.7.4';
	/**
	 * Initializing a zrender instance
	 * @param {HTMLElement} dom
	 * @param {Object} opts
	 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	 * @param {number} [opts.devicePixelRatio]
	 * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
	 * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
	 * @return {module:zrender/ZRender}
	 */
	
	function init(dom, opts) {
	  var zr = new ZRender(guid(), dom, opts);
	  instances[zr.id] = zr;
	  return zr;
	}
	/**
	 * Dispose zrender instance
	 * @param {module:zrender/ZRender} zr
	 */
	
	
	function dispose(zr) {
	  if (zr) {
	    zr.dispose();
	  } else {
	    for (var key in instances) {
	      if (instances.hasOwnProperty(key)) {
	        instances[key].dispose();
	      }
	    }
	
	    instances = {};
	  }
	
	  return this;
	}
	/**
	 * Get zrender instance by id
	 * @param {string} id zrender instance id
	 * @return {module:zrender/ZRender}
	 */
	
	
	function getInstance(id) {
	  return instances[id];
	}
	
	function registerPainter(name, Ctor) {
	  painterCtors[name] = Ctor;
	}
	
	function delInstance(id) {
	  delete instances[id];
	}
	/**
	 * @module zrender/ZRender
	 */
	
	/**
	 * @constructor
	 * @alias module:zrender/ZRender
	 * @param {string} id
	 * @param {HTMLElement} dom
	 * @param {Object} opts
	 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	 * @param {number} [opts.devicePixelRatio]
	 * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
	 * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
	 */
	
	
	var ZRender = function (id, dom, opts) {
	  opts = opts || {};
	  /**
	   * @type {HTMLDomElement}
	   */
	
	  this.dom = dom;
	  /**
	   * @type {string}
	   */
	
	  this.id = id;
	  var self = this;
	  var storage = new Storage();
	  var rendererType = opts.renderer; // TODO WebGL
	
	  if (useVML) {
	    if (!painterCtors.vml) {
	      throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
	    }
	
	    rendererType = 'vml';
	  } else if (!rendererType || !painterCtors[rendererType]) {
	    rendererType = 'canvas';
	  }
	
	  var painter = new painterCtors[rendererType](dom, storage, opts);
	  this.storage = storage;
	  this.painter = painter;
	  var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;
	  this.handler = new Handler(storage, painter, handerProxy, painter.root);
	  /**
	   * @type {module:zrender/animation/Animation}
	   */
	
	  this.animation = new Animation({
	    stage: {
	      update: zrUtil.bind(this.flush, this)
	    }
	  });
	  this.animation.start();
	  /**
	   * @type {boolean}
	   * @private
	   */
	
	  this._needsRefresh; // 修改 storage.delFromStorage, 每次删除元素之前删除动画
	  // FIXME 有点ugly
	
	  var oldDelFromStorage = storage.delFromStorage;
	  var oldAddToStorage = storage.addToStorage;
	
	  storage.delFromStorage = function (el) {
	    oldDelFromStorage.call(storage, el);
	    el && el.removeSelfFromZr(self);
	  };
	
	  storage.addToStorage = function (el) {
	    oldAddToStorage.call(storage, el);
	    el.addSelfToZr(self);
	  };
	};
	
	ZRender.prototype = {
	  constructor: ZRender,
	
	  /**
	   * 获取实例唯一标识
	   * @return {string}
	   */
	  getId: function () {
	    return this.id;
	  },
	
	  /**
	   * 添加元素
	   * @param  {module:zrender/Element} el
	   */
	  add: function (el) {
	    this.storage.addRoot(el);
	    this._needsRefresh = true;
	  },
	
	  /**
	   * 删除元素
	   * @param  {module:zrender/Element} el
	   */
	  remove: function (el) {
	    this.storage.delRoot(el);
	    this._needsRefresh = true;
	  },
	
	  /**
	   * Change configuration of layer
	   * @param {string} zLevel
	   * @param {Object} config
	   * @param {string} [config.clearColor=0] Clear color
	   * @param {string} [config.motionBlur=false] If enable motion blur
	   * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
	  */
	  configLayer: function (zLevel, config) {
	    this.painter.configLayer(zLevel, config);
	    this._needsRefresh = true;
	  },
	
	  /**
	   * Repaint the canvas immediately
	   */
	  refreshImmediately: function () {
	    // var start = new Date();
	    // Clear needsRefresh ahead to avoid something wrong happens in refresh
	    // Or it will cause zrender refreshes again and again.
	    this._needsRefresh = false;
	    this.painter.refresh();
	    /**
	     * Avoid trigger zr.refresh in Element#beforeUpdate hook
	     */
	
	    this._needsRefresh = false; // var end = new Date();
	    // var log = document.getElementById('log');
	    // if (log) {
	    //     log.innerHTML = log.innerHTML + '<br>' + (end - start);
	    // }
	  },
	
	  /**
	   * Mark and repaint the canvas in the next frame of browser
	   */
	  refresh: function () {
	    this._needsRefresh = true;
	  },
	
	  /**
	   * Perform all refresh
	   */
	  flush: function () {
	    if (this._needsRefresh) {
	      this.refreshImmediately();
	    }
	
	    if (this._needsRefreshHover) {
	      this.refreshHoverImmediately();
	    }
	  },
	
	  /**
	   * Add element to hover layer
	   * @param  {module:zrender/Element} el
	   * @param {Object} style
	   */
	  addHover: function (el, style) {
	    if (this.painter.addHover) {
	      this.painter.addHover(el, style);
	      this.refreshHover();
	    }
	  },
	
	  /**
	   * Add element from hover layer
	   * @param  {module:zrender/Element} el
	   */
	  removeHover: function (el) {
	    if (this.painter.removeHover) {
	      this.painter.removeHover(el);
	      this.refreshHover();
	    }
	  },
	
	  /**
	   * Clear all hover elements in hover layer
	   * @param  {module:zrender/Element} el
	   */
	  clearHover: function () {
	    if (this.painter.clearHover) {
	      this.painter.clearHover();
	      this.refreshHover();
	    }
	  },
	
	  /**
	   * Refresh hover in next frame
	   */
	  refreshHover: function () {
	    this._needsRefreshHover = true;
	  },
	
	  /**
	   * Refresh hover immediately
	   */
	  refreshHoverImmediately: function () {
	    this._needsRefreshHover = false;
	    this.painter.refreshHover && this.painter.refreshHover();
	  },
	
	  /**
	   * Resize the canvas.
	   * Should be invoked when container size is changed
	   * @param {Object} [opts]
	   * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
	   * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
	   */
	  resize: function (opts) {
	    opts = opts || {};
	    this.painter.resize(opts.width, opts.height);
	    this.handler.resize();
	  },
	
	  /**
	   * Stop and clear all animation immediately
	   */
	  clearAnimation: function () {
	    this.animation.clear();
	  },
	
	  /**
	   * Get container width
	   */
	  getWidth: function () {
	    return this.painter.getWidth();
	  },
	
	  /**
	   * Get container height
	   */
	  getHeight: function () {
	    return this.painter.getHeight();
	  },
	
	  /**
	   * Export the canvas as Base64 URL
	   * @param {string} type
	   * @param {string} [backgroundColor='#fff']
	   * @return {string} Base64 URL
	   */
	  // toDataURL: function(type, backgroundColor) {
	  //     return this.painter.getRenderedCanvas({
	  //         backgroundColor: backgroundColor
	  //     }).toDataURL(type);
	  // },
	
	  /**
	   * Converting a path to image.
	   * It has much better performance of drawing image rather than drawing a vector path.
	   * @param {module:zrender/graphic/Path} e
	   * @param {number} width
	   * @param {number} height
	   */
	  pathToImage: function (e, dpr) {
	    return this.painter.pathToImage(e, dpr);
	  },
	
	  /**
	   * Set default cursor
	   * @param {string} [cursorStyle='default'] 例如 crosshair
	   */
	  setCursorStyle: function (cursorStyle) {
	    this.handler.setCursorStyle(cursorStyle);
	  },
	
	  /**
	   * Find hovered element
	   * @param {number} x
	   * @param {number} y
	   * @return {Object} {target, topTarget}
	   */
	  findHover: function (x, y) {
	    return this.handler.findHover(x, y);
	  },
	
	  /**
	   * Bind event
	   *
	   * @param {string} eventName Event name
	   * @param {Function} eventHandler Handler function
	   * @param {Object} [context] Context object
	   */
	  on: function (eventName, eventHandler, context) {
	    this.handler.on(eventName, eventHandler, context);
	  },
	
	  /**
	   * Unbind event
	   * @param {string} eventName Event name
	   * @param {Function} [eventHandler] Handler function
	   */
	  off: function (eventName, eventHandler) {
	    this.handler.off(eventName, eventHandler);
	  },
	
	  /**
	   * Trigger event manually
	   *
	   * @param {string} eventName Event name
	   * @param {event=} event Event object
	   */
	  trigger: function (eventName, event) {
	    this.handler.trigger(eventName, event);
	  },
	
	  /**
	   * Clear all objects and the canvas.
	   */
	  clear: function () {
	    this.storage.delRoot();
	    this.painter.clear();
	  },
	
	  /**
	   * Dispose self.
	   */
	  dispose: function () {
	    this.animation.stop();
	    this.clear();
	    this.storage.dispose();
	    this.painter.dispose();
	    this.handler.dispose();
	    this.animation = this.storage = this.painter = this.handler = null;
	    delInstance(this.id);
	  }
	};
	exports.version = version;
	exports.init = init;
	exports.dispose = dispose;
	exports.getInstance = getInstance;
	exports.registerPainter = registerPainter;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	/**
	 * zrender: 生成唯一id
	 *
	 * @author errorrik (errorrik@gmail.com)
	 */
	var idStart = 0x0907;
	
	function _default() {
	  return idStart++;
	}
	
	module.exports = _default;

/***/ }),
/* 5 */
/***/ (function(module, exports) {

	/**
	 * echarts设备环境识别
	 *
	 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
	 * @author firede[firede@firede.us]
	 * @desc thanks zepto.
	 */
	var env = {};
	
	if (typeof navigator === 'undefined') {
	  // In node
	  env = {
	    browser: {},
	    os: {},
	    node: true,
	    // Assume canvas is supported
	    canvasSupported: true,
	    svgSupported: true
	  };
	} else {
	  env = detect(navigator.userAgent);
	}
	
	var _default = env; // Zepto.js
	// (c) 2010-2013 Thomas Fuchs
	// Zepto.js may be freely distributed under the MIT license.
	
	function detect(ua) {
	  var os = {};
	  var browser = {}; // var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
	  // var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
	  // var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
	  // var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
	  // var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
	  // var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
	  // var touchpad = webos && ua.match(/TouchPad/);
	  // var kindle = ua.match(/Kindle\/([\d.]+)/);
	  // var silk = ua.match(/Silk\/([\d._]+)/);
	  // var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
	  // var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
	  // var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
	  // var playbook = ua.match(/PlayBook/);
	  // var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);
	
	  var firefox = ua.match(/Firefox\/([\d.]+)/); // var safari = webkit && ua.match(/Mobile\//) && !chrome;
	  // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;
	
	  var ie = ua.match(/MSIE\s([\d.]+)/) // IE 11 Trident/7.0; rv:11.0
	  || ua.match(/Trident\/.+?rv:(([\d.]+))/);
	  var edge = ua.match(/Edge\/([\d.]+)/); // IE 12 and 12+
	
	  var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:
	  // - discern (more) between multiple browsers on android
	  // - decide if kindle fire in silk mode is android or not
	  // - Firefox on Android doesn't specify the Android version
	  // - possibly devide in os, device and browser hashes
	  // if (browser.webkit = !!webkit) browser.version = webkit[1];
	  // if (android) os.android = true, os.version = android[2];
	  // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
	  // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
	  // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
	  // if (webos) os.webos = true, os.version = webos[2];
	  // if (touchpad) os.touchpad = true;
	  // if (blackberry) os.blackberry = true, os.version = blackberry[2];
	  // if (bb10) os.bb10 = true, os.version = bb10[2];
	  // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
	  // if (playbook) browser.playbook = true;
	  // if (kindle) os.kindle = true, os.version = kindle[1];
	  // if (silk) browser.silk = true, browser.version = silk[1];
	  // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
	  // if (chrome) browser.chrome = true, browser.version = chrome[1];
	
	  if (firefox) {
	    browser.firefox = true;
	    browser.version = firefox[1];
	  } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
	  // if (webview) browser.webview = true;
	
	
	  if (ie) {
	    browser.ie = true;
	    browser.version = ie[1];
	  }
	
	  if (edge) {
	    browser.edge = true;
	    browser.version = edge[1];
	  } // It is difficult to detect WeChat in Win Phone precisely, because ua can
	  // not be set on win phone. So we do not consider Win Phone.
	
	
	  if (weChat) {
	    browser.weChat = true;
	  } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
	  //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
	  // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||
	  //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
	  //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));
	
	
	  return {
	    browser: browser,
	    os: os,
	    node: false,
	    // 原生canvas支持，改极端点了
	    // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
	    canvasSupported: !!document.createElement('canvas').getContext,
	    svgSupported: typeof SVGRect !== 'undefined',
	    // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>
	    // works on most browsers
	    // IE10/11 does not support touch event, and MS Edge supports them but not by
	    // default, so we dont check navigator.maxTouchPoints for them here.
	    touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,
	    // <http://caniuse.com/#search=pointer%20event>.
	    pointerEventsSupported: 'onpointerdown' in window // Firefox supports pointer but not by default, only MS browsers are reliable on pointer
	    // events currently. So we dont use that on other browsers unless tested sufficiently.
	    // Although IE 10 supports pointer event, it use old style and is different from the
	    // standard. So we exclude that. (IE 10 is hardly used on touch device)
	    && (browser.edge || browser.ie && browser.version >= 11)
	  };
	}
	
	module.exports = _default;

/***/ }),
/* 6 */
/***/ (function(module, exports) {

	/**
	 * @module zrender/core/util
	 */
	// 用于处理merge时无法遍历Date等对象的问题
	var BUILTIN_OBJECT = {
	  '[object Function]': 1,
	  '[object RegExp]': 1,
	  '[object Date]': 1,
	  '[object Error]': 1,
	  '[object CanvasGradient]': 1,
	  '[object CanvasPattern]': 1,
	  // For node-canvas
	  '[object Image]': 1,
	  '[object Canvas]': 1
	};
	var TYPED_ARRAY = {
	  '[object Int8Array]': 1,
	  '[object Uint8Array]': 1,
	  '[object Uint8ClampedArray]': 1,
	  '[object Int16Array]': 1,
	  '[object Uint16Array]': 1,
	  '[object Int32Array]': 1,
	  '[object Uint32Array]': 1,
	  '[object Float32Array]': 1,
	  '[object Float64Array]': 1
	};
	var objToString = Object.prototype.toString;
	var arrayProto = Array.prototype;
	var nativeForEach = arrayProto.forEach;
	var nativeFilter = arrayProto.filter;
	var nativeSlice = arrayProto.slice;
	var nativeMap = arrayProto.map;
	var nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.
	
	var methods = {};
	
	function $override(name, fn) {
	  methods[name] = fn;
	}
	/**
	 * Those data types can be cloned:
	 *     Plain object, Array, TypedArray, number, string, null, undefined.
	 * Those data types will be assgined using the orginal data:
	 *     BUILTIN_OBJECT
	 * Instance of user defined class will be cloned to a plain object, without
	 * properties in prototype.
	 * Other data types is not supported (not sure what will happen).
	 *
	 * Caution: do not support clone Date, for performance consideration.
	 * (There might be a large number of date in `series.data`).
	 * So date should not be modified in and out of echarts.
	 *
	 * @param {*} source
	 * @return {*} new
	 */
	
	
	function clone(source) {
	  if (source == null || typeof source != 'object') {
	    return source;
	  }
	
	  var result = source;
	  var typeStr = objToString.call(source);
	
	  if (typeStr === '[object Array]') {
	    result = [];
	
	    for (var i = 0, len = source.length; i < len; i++) {
	      result[i] = clone(source[i]);
	    }
	  } else if (TYPED_ARRAY[typeStr]) {
	    var Ctor = source.constructor;
	
	    if (source.constructor.from) {
	      result = Ctor.from(source);
	    } else {
	      result = new Ctor(source.length);
	
	      for (var i = 0, len = source.length; i < len; i++) {
	        result[i] = clone(source[i]);
	      }
	    }
	  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
	    result = {};
	
	    for (var key in source) {
	      if (source.hasOwnProperty(key)) {
	        result[key] = clone(source[key]);
	      }
	    }
	  }
	
	  return result;
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} target
	 * @param {*} source
	 * @param {boolean} [overwrite=false]
	 */
	
	
	function merge(target, source, overwrite) {
	  // We should escapse that source is string
	  // and enter for ... in ...
	  if (!isObject(source) || !isObject(target)) {
	    return overwrite ? clone(source) : target;
	  }
	
	  for (var key in source) {
	    if (source.hasOwnProperty(key)) {
	      var targetProp = target[key];
	      var sourceProp = source[key];
	
	      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
	        // 如果需要递归覆盖，就递归调用merge
	        merge(targetProp, sourceProp, overwrite);
	      } else if (overwrite || !(key in target)) {
	        // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
	        // NOTE，在 target[key] 不存在的时候也是直接覆盖
	        target[key] = clone(source[key], true);
	      }
	    }
	  }
	
	  return target;
	}
	/**
	 * @param {Array} targetAndSources The first item is target, and the rests are source.
	 * @param {boolean} [overwrite=false]
	 * @return {*} target
	 */
	
	
	function mergeAll(targetAndSources, overwrite) {
	  var result = targetAndSources[0];
	
	  for (var i = 1, len = targetAndSources.length; i < len; i++) {
	    result = merge(result, targetAndSources[i], overwrite);
	  }
	
	  return result;
	}
	/**
	 * @param {*} target
	 * @param {*} source
	 * @memberOf module:zrender/core/util
	 */
	
	
	function extend(target, source) {
	  for (var key in source) {
	    if (source.hasOwnProperty(key)) {
	      target[key] = source[key];
	    }
	  }
	
	  return target;
	}
	/**
	 * @param {*} target
	 * @param {*} source
	 * @param {boolean} [overlay=false]
	 * @memberOf module:zrender/core/util
	 */
	
	
	function defaults(target, source, overlay) {
	  for (var key in source) {
	    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {
	      target[key] = source[key];
	    }
	  }
	
	  return target;
	}
	
	var createCanvas = function () {
	  return methods.createCanvas();
	};
	
	methods.createCanvas = function () {
	  return document.createElement('canvas');
	}; // FIXME
	
	
	var _ctx;
	
	function getContext() {
	  if (!_ctx) {
	    // Use util.createCanvas instead of createCanvas
	    // because createCanvas may be overwritten in different environment
	    _ctx = createCanvas().getContext('2d');
	  }
	
	  return _ctx;
	}
	/**
	 * 查询数组中元素的index
	 * @memberOf module:zrender/core/util
	 */
	
	
	function indexOf(array, value) {
	  if (array) {
	    if (array.indexOf) {
	      return array.indexOf(value);
	    }
	
	    for (var i = 0, len = array.length; i < len; i++) {
	      if (array[i] === value) {
	        return i;
	      }
	    }
	  }
	
	  return -1;
	}
	/**
	 * 构造类继承关系
	 *
	 * @memberOf module:zrender/core/util
	 * @param {Function} clazz 源类
	 * @param {Function} baseClazz 基类
	 */
	
	
	function inherits(clazz, baseClazz) {
	  var clazzPrototype = clazz.prototype;
	
	  function F() {}
	
	  F.prototype = baseClazz.prototype;
	  clazz.prototype = new F();
	
	  for (var prop in clazzPrototype) {
	    clazz.prototype[prop] = clazzPrototype[prop];
	  }
	
	  clazz.prototype.constructor = clazz;
	  clazz.superClass = baseClazz;
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Object|Function} target
	 * @param {Object|Function} sorce
	 * @param {boolean} overlay
	 */
	
	
	function mixin(target, source, overlay) {
	  target = 'prototype' in target ? target.prototype : target;
	  source = 'prototype' in source ? source.prototype : source;
	  defaults(target, source, overlay);
	}
	/**
	 * Consider typed array.
	 * @param {Array|TypedArray} data
	 */
	
	
	function isArrayLike(data) {
	  if (!data) {
	    return;
	  }
	
	  if (typeof data == 'string') {
	    return false;
	  }
	
	  return typeof data.length == 'number';
	}
	/**
	 * 数组或对象遍历
	 * @memberOf module:zrender/core/util
	 * @param {Object|Array} obj
	 * @param {Function} cb
	 * @param {*} [context]
	 */
	
	
	function each(obj, cb, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  if (obj.forEach && obj.forEach === nativeForEach) {
	    obj.forEach(cb, context);
	  } else if (obj.length === +obj.length) {
	    for (var i = 0, len = obj.length; i < len; i++) {
	      cb.call(context, obj[i], i, obj);
	    }
	  } else {
	    for (var key in obj) {
	      if (obj.hasOwnProperty(key)) {
	        cb.call(context, obj[key], key, obj);
	      }
	    }
	  }
	}
	/**
	 * 数组映射
	 * @memberOf module:zrender/core/util
	 * @param {Array} obj
	 * @param {Function} cb
	 * @param {*} [context]
	 * @return {Array}
	 */
	
	
	function map(obj, cb, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  if (obj.map && obj.map === nativeMap) {
	    return obj.map(cb, context);
	  } else {
	    var result = [];
	
	    for (var i = 0, len = obj.length; i < len; i++) {
	      result.push(cb.call(context, obj[i], i, obj));
	    }
	
	    return result;
	  }
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Array} obj
	 * @param {Function} cb
	 * @param {Object} [memo]
	 * @param {*} [context]
	 * @return {Array}
	 */
	
	
	function reduce(obj, cb, memo, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  if (obj.reduce && obj.reduce === nativeReduce) {
	    return obj.reduce(cb, memo, context);
	  } else {
	    for (var i = 0, len = obj.length; i < len; i++) {
	      memo = cb.call(context, memo, obj[i], i, obj);
	    }
	
	    return memo;
	  }
	}
	/**
	 * 数组过滤
	 * @memberOf module:zrender/core/util
	 * @param {Array} obj
	 * @param {Function} cb
	 * @param {*} [context]
	 * @return {Array}
	 */
	
	
	function filter(obj, cb, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  if (obj.filter && obj.filter === nativeFilter) {
	    return obj.filter(cb, context);
	  } else {
	    var result = [];
	
	    for (var i = 0, len = obj.length; i < len; i++) {
	      if (cb.call(context, obj[i], i, obj)) {
	        result.push(obj[i]);
	      }
	    }
	
	    return result;
	  }
	}
	/**
	 * 数组项查找
	 * @memberOf module:zrender/core/util
	 * @param {Array} obj
	 * @param {Function} cb
	 * @param {*} [context]
	 * @return {*}
	 */
	
	
	function find(obj, cb, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  for (var i = 0, len = obj.length; i < len; i++) {
	    if (cb.call(context, obj[i], i, obj)) {
	      return obj[i];
	    }
	  }
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Function} func
	 * @param {*} context
	 * @return {Function}
	 */
	
	
	function bind(func, context) {
	  var args = nativeSlice.call(arguments, 2);
	  return function () {
	    return func.apply(context, args.concat(nativeSlice.call(arguments)));
	  };
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Function} func
	 * @return {Function}
	 */
	
	
	function curry(func) {
	  var args = nativeSlice.call(arguments, 1);
	  return function () {
	    return func.apply(this, args.concat(nativeSlice.call(arguments)));
	  };
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isArray(value) {
	  return objToString.call(value) === '[object Array]';
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isFunction(value) {
	  return typeof value === 'function';
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isString(value) {
	  return objToString.call(value) === '[object String]';
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return type === 'function' || !!value && type == 'object';
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isBuiltInObject(value) {
	  return !!BUILTIN_OBJECT[objToString.call(value)];
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isDom(value) {
	  return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';
	}
	/**
	 * Whether is exactly NaN. Notice isNaN('a') returns true.
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function eqNaN(value) {
	  return value !== value;
	}
	/**
	 * If value1 is not null, then return value1, otherwise judget rest of values.
	 * Low performance.
	 * @memberOf module:zrender/core/util
	 * @return {*} Final value
	 */
	
	
	function retrieve(values) {
	  for (var i = 0, len = arguments.length; i < len; i++) {
	    if (arguments[i] != null) {
	      return arguments[i];
	    }
	  }
	}
	
	function retrieve2(value0, value1) {
	  return value0 != null ? value0 : value1;
	}
	
	function retrieve3(value0, value1, value2) {
	  return value0 != null ? value0 : value1 != null ? value1 : value2;
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Array} arr
	 * @param {number} startIndex
	 * @param {number} endIndex
	 * @return {Array}
	 */
	
	
	function slice() {
	  return Function.call.apply(nativeSlice, arguments);
	}
	/**
	 * Normalize css liked array configuration
	 * e.g.
	 *  3 => [3, 3, 3, 3]
	 *  [4, 2] => [4, 2, 4, 2]
	 *  [4, 3, 2] => [4, 3, 2, 3]
	 * @param {number|Array.<number>} val
	 * @return {Array.<number>}
	 */
	
	
	function normalizeCssArray(val) {
	  if (typeof val === 'number') {
	    return [val, val, val, val];
	  }
	
	  var len = val.length;
	
	  if (len === 2) {
	    // vertical | horizontal
	    return [val[0], val[1], val[0], val[1]];
	  } else if (len === 3) {
	    // top | horizontal | bottom
	    return [val[0], val[1], val[2], val[1]];
	  }
	
	  return val;
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {boolean} condition
	 * @param {string} message
	 */
	
	
	function assert(condition, message) {
	  if (!condition) {
	    throw new Error(message);
	  }
	}
	
	var primitiveKey = '__ec_primitive__';
	/**
	 * Set an object as primitive to be ignored traversing children in clone or merge
	 */
	
	function setAsPrimitive(obj) {
	  obj[primitiveKey] = true;
	}
	
	function isPrimitive(obj) {
	  return obj[primitiveKey];
	}
	/**
	 * @constructor
	 * @param {Object} obj Only apply `ownProperty`.
	 */
	
	
	function HashMap(obj) {
	  obj && each(obj, function (value, key) {
	    this.set(key, value);
	  }, this);
	} // Add prefix to avoid conflict with Object.prototype.
	
	
	var HASH_MAP_PREFIX = '_ec_';
	var HASH_MAP_PREFIX_LENGTH = 4;
	HashMap.prototype = {
	  constructor: HashMap,
	  // Do not provide `has` method to avoid defining what is `has`.
	  // (We usually treat `null` and `undefined` as the same, different
	  // from ES6 Map).
	  get: function (key) {
	    return this[HASH_MAP_PREFIX + key];
	  },
	  set: function (key, value) {
	    this[HASH_MAP_PREFIX + key] = value; // Comparing with invocation chaining, `return value` is more commonly
	    // used in this case: `var someVal = map.set('a', genVal());`
	
	    return value;
	  },
	  // Although util.each can be performed on this hashMap directly, user
	  // should not use the exposed keys, who are prefixed.
	  each: function (cb, context) {
	    context !== void 0 && (cb = bind(cb, context));
	
	    for (var prefixedKey in this) {
	      this.hasOwnProperty(prefixedKey) && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));
	    }
	  },
	  // Do not use this method if performance sensitive.
	  removeKey: function (key) {
	    delete this[HASH_MAP_PREFIX + key];
	  }
	};
	
	function createHashMap(obj) {
	  return new HashMap(obj);
	}
	
	function noop() {}
	
	exports.$override = $override;
	exports.clone = clone;
	exports.merge = merge;
	exports.mergeAll = mergeAll;
	exports.extend = extend;
	exports.defaults = defaults;
	exports.createCanvas = createCanvas;
	exports.getContext = getContext;
	exports.indexOf = indexOf;
	exports.inherits = inherits;
	exports.mixin = mixin;
	exports.isArrayLike = isArrayLike;
	exports.each = each;
	exports.map = map;
	exports.reduce = reduce;
	exports.filter = filter;
	exports.find = find;
	exports.bind = bind;
	exports.curry = curry;
	exports.isArray = isArray;
	exports.isFunction = isFunction;
	exports.isString = isString;
	exports.isObject = isObject;
	exports.isBuiltInObject = isBuiltInObject;
	exports.isDom = isDom;
	exports.eqNaN = eqNaN;
	exports.retrieve = retrieve;
	exports.retrieve2 = retrieve2;
	exports.retrieve3 = retrieve3;
	exports.slice = slice;
	exports.normalizeCssArray = normalizeCssArray;
	exports.assert = assert;
	exports.setAsPrimitive = setAsPrimitive;
	exports.isPrimitive = isPrimitive;
	exports.createHashMap = createHashMap;
	exports.noop = noop;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(6);
	
	var vec2 = __webpack_require__(8);
	
	var Draggable = __webpack_require__(9);
	
	var Eventful = __webpack_require__(10);
	
	/**
	 * Handler
	 * @module zrender/Handler
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (shenyi.914@gmail.com)
	 */
	var SILENT = 'silent';
	
	function makeEventPacket(eveType, targetInfo, event) {
	  return {
	    type: eveType,
	    event: event,
	    // target can only be an element that is not silent.
	    target: targetInfo.target,
	    // topTarget can be a silent element.
	    topTarget: targetInfo.topTarget,
	    cancelBubble: false,
	    offsetX: event.zrX,
	    offsetY: event.zrY,
	    gestureEvent: event.gestureEvent,
	    pinchX: event.pinchX,
	    pinchY: event.pinchY,
	    pinchScale: event.pinchScale,
	    wheelDelta: event.zrDelta,
	    zrByTouch: event.zrByTouch,
	    which: event.which
	  };
	}
	
	function EmptyProxy() {}
	
	EmptyProxy.prototype.dispose = function () {};
	
	var handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
	/**
	 * @alias module:zrender/Handler
	 * @constructor
	 * @extends module:zrender/mixin/Eventful
	 * @param {module:zrender/Storage} storage Storage instance.
	 * @param {module:zrender/Painter} painter Painter instance.
	 * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.
	 * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).
	 */
	
	var Handler = function (storage, painter, proxy, painterRoot) {
	  Eventful.call(this);
	  this.storage = storage;
	  this.painter = painter;
	  this.painterRoot = painterRoot;
	  proxy = proxy || new EmptyProxy();
	  /**
	   * Proxy of event. can be Dom, WebGLSurface, etc.
	   */
	
	  this.proxy = proxy; // Attach handler
	
	  proxy.handler = this;
	  /**
	   * {target, topTarget, x, y}
	   * @private
	   * @type {Object}
	   */
	
	  this._hovered = {};
	  /**
	   * @private
	   * @type {Date}
	   */
	
	  this._lastTouchMoment;
	  /**
	   * @private
	   * @type {number}
	   */
	
	  this._lastX;
	  /**
	   * @private
	   * @type {number}
	   */
	
	  this._lastY;
	  Draggable.call(this);
	  util.each(handlerNames, function (name) {
	    proxy.on && proxy.on(name, this[name], this);
	  }, this);
	};
	
	Handler.prototype = {
	  constructor: Handler,
	  mousemove: function (event) {
	    var x = event.zrX;
	    var y = event.zrY;
	    var lastHovered = this._hovered;
	    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call
	    // (like 'setOption' or 'dispatchAction') in event handlers, we should find
	    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.
	    // See #6198.
	
	    if (lastHoveredTarget && !lastHoveredTarget.__zr) {
	      lastHovered = this.findHover(lastHovered.x, lastHovered.y);
	      lastHoveredTarget = lastHovered.target;
	    }
	
	    var hovered = this._hovered = this.findHover(x, y);
	    var hoveredTarget = hovered.target;
	    var proxy = this.proxy;
	    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element
	
	    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
	      this.dispatchToElement(lastHovered, 'mouseout', event);
	    } // Mouse moving on one element
	
	
	    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element
	
	    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
	      this.dispatchToElement(hovered, 'mouseover', event);
	    }
	  },
	  mouseout: function (event) {
	    this.dispatchToElement(this._hovered, 'mouseout', event); // There might be some doms created by upper layer application
	    // at the same level of painter.getViewportRoot() (e.g., tooltip
	    // dom created by echarts), where 'globalout' event should not
	    // be triggered when mouse enters these doms. (But 'mouseout'
	    // should be triggered at the original hovered element as usual).
	
	    var element = event.toElement || event.relatedTarget;
	    var innerDom;
	
	    do {
	      element = element && element.parentNode;
	    } while (element && element.nodeType != 9 && !(innerDom = element === this.painterRoot));
	
	    !innerDom && this.trigger('globalout', {
	      event: event
	    });
	  },
	
	  /**
	   * Resize
	   */
	  resize: function (event) {
	    this._hovered = {};
	  },
	
	  /**
	   * Dispatch event
	   * @param {string} eventName
	   * @param {event=} eventArgs
	   */
	  dispatch: function (eventName, eventArgs) {
	    var handler = this[eventName];
	    handler && handler.call(this, eventArgs);
	  },
	
	  /**
	   * Dispose
	   */
	  dispose: function () {
	    this.proxy.dispose();
	    this.storage = this.proxy = this.painter = null;
	  },
	
	  /**
	   * 设置默认的cursor style
	   * @param {string} [cursorStyle='default'] 例如 crosshair
	   */
	  setCursorStyle: function (cursorStyle) {
	    var proxy = this.proxy;
	    proxy.setCursor && proxy.setCursor(cursorStyle);
	  },
	
	  /**
	   * 事件分发代理
	   *
	   * @private
	   * @param {Object} targetInfo {target, topTarget} 目标图形元素
	   * @param {string} eventName 事件名称
	   * @param {Object} event 事件对象
	   */
	  dispatchToElement: function (targetInfo, eventName, event) {
	    targetInfo = targetInfo || {};
	    var el = targetInfo.target;
	
	    if (el && el.silent) {
	      return;
	    }
	
	    var eventHandler = 'on' + eventName;
	    var eventPacket = makeEventPacket(eventName, targetInfo, event);
	
	    while (el) {
	      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
	      el.trigger(eventName, eventPacket);
	      el = el.parent;
	
	      if (eventPacket.cancelBubble) {
	        break;
	      }
	    }
	
	    if (!eventPacket.cancelBubble) {
	      // 冒泡到顶级 zrender 对象
	      this.trigger(eventName, eventPacket); // 分发事件到用户自定义层
	      // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在
	
	      this.painter && this.painter.eachOtherLayer(function (layer) {
	        if (typeof layer[eventHandler] == 'function') {
	          layer[eventHandler].call(layer, eventPacket);
	        }
	
	        if (layer.trigger) {
	          layer.trigger(eventName, eventPacket);
	        }
	      });
	    }
	  },
	
	  /**
	   * @private
	   * @param {number} x
	   * @param {number} y
	   * @param {module:zrender/graphic/Displayable} exclude
	   * @return {model:zrender/Element}
	   * @method
	   */
	  findHover: function (x, y, exclude) {
	    var list = this.storage.getDisplayList();
	    var out = {
	      x: x,
	      y: y
	    };
	
	    for (var i = list.length - 1; i >= 0; i--) {
	      var hoverCheckResult;
	
	      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode
	      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {
	        !out.topTarget && (out.topTarget = list[i]);
	
	        if (hoverCheckResult !== SILENT) {
	          out.target = list[i];
	          break;
	        }
	      }
	    }
	
	    return out;
	  }
	}; // Common handlers
	
	util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
	  Handler.prototype[name] = function (event) {
	    // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover
	    var hovered = this.findHover(event.zrX, event.zrY);
	    var hoveredTarget = hovered.target;
	
	    if (name === 'mousedown') {
	      this._downEl = hoveredTarget;
	      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup
	
	      this._upEl = hoveredTarget;
	    } else if (name === 'mosueup') {
	      this._upEl = hoveredTarget;
	    } else if (name === 'click') {
	      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,
	      // including the case that `mousedown` - `mousemove` - `mouseup`,
	      // which should be filtered, otherwise it will bring trouble to
	      // pan and zoom.
	      || !this._downPoint // Arbitrary value
	      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {
	        return;
	      }
	
	      this._downPoint = null;
	    }
	
	    this.dispatchToElement(hovered, name, event);
	  };
	});
	
	function isHover(displayable, x, y) {
	  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
	    var el = displayable;
	    var isSilent;
	
	    while (el) {
	      // If clipped by ancestor.
	      // FIXME: If clipPath has neither stroke nor fill,
	      // el.clipPath.contain(x, y) will always return false.
	      if (el.clipPath && !el.clipPath.contain(x, y)) {
	        return false;
	      }
	
	      if (el.silent) {
	        isSilent = true;
	      }
	
	      el = el.parent;
	    }
	
	    return isSilent ? SILENT : true;
	  }
	
	  return false;
	}
	
	util.mixin(Handler, Eventful);
	util.mixin(Handler, Draggable);
	var _default = Handler;
	module.exports = _default;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

	var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
	/**
	 * 创建一个向量
	 * @param {number} [x=0]
	 * @param {number} [y=0]
	 * @return {Vector2}
	 */
	
	function create(x, y) {
	  var out = new ArrayCtor(2);
	
	  if (x == null) {
	    x = 0;
	  }
	
	  if (y == null) {
	    y = 0;
	  }
	
	  out[0] = x;
	  out[1] = y;
	  return out;
	}
	/**
	 * 复制向量数据
	 * @param {Vector2} out
	 * @param {Vector2} v
	 * @return {Vector2}
	 */
	
	
	function copy(out, v) {
	  out[0] = v[0];
	  out[1] = v[1];
	  return out;
	}
	/**
	 * 克隆一个向量
	 * @param {Vector2} v
	 * @return {Vector2}
	 */
	
	
	function clone(v) {
	  var out = new ArrayCtor(2);
	  out[0] = v[0];
	  out[1] = v[1];
	  return out;
	}
	/**
	 * 设置向量的两个项
	 * @param {Vector2} out
	 * @param {number} a
	 * @param {number} b
	 * @return {Vector2} 结果
	 */
	
	
	function set(out, a, b) {
	  out[0] = a;
	  out[1] = b;
	  return out;
	}
	/**
	 * 向量相加
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 */
	
	
	function add(out, v1, v2) {
	  out[0] = v1[0] + v2[0];
	  out[1] = v1[1] + v2[1];
	  return out;
	}
	/**
	 * 向量缩放后相加
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @param {number} a
	 */
	
	
	function scaleAndAdd(out, v1, v2, a) {
	  out[0] = v1[0] + v2[0] * a;
	  out[1] = v1[1] + v2[1] * a;
	  return out;
	}
	/**
	 * 向量相减
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 */
	
	
	function sub(out, v1, v2) {
	  out[0] = v1[0] - v2[0];
	  out[1] = v1[1] - v2[1];
	  return out;
	}
	/**
	 * 向量长度
	 * @param {Vector2} v
	 * @return {number}
	 */
	
	
	function len(v) {
	  return Math.sqrt(lenSquare(v));
	}
	
	var length = len; // jshint ignore:line
	
	/**
	 * 向量长度平方
	 * @param {Vector2} v
	 * @return {number}
	 */
	
	function lenSquare(v) {
	  return v[0] * v[0] + v[1] * v[1];
	}
	
	var lengthSquare = lenSquare;
	/**
	 * 向量乘法
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 */
	
	function mul(out, v1, v2) {
	  out[0] = v1[0] * v2[0];
	  out[1] = v1[1] * v2[1];
	  return out;
	}
	/**
	 * 向量除法
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 */
	
	
	function div(out, v1, v2) {
	  out[0] = v1[0] / v2[0];
	  out[1] = v1[1] / v2[1];
	  return out;
	}
	/**
	 * 向量点乘
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @return {number}
	 */
	
	
	function dot(v1, v2) {
	  return v1[0] * v2[0] + v1[1] * v2[1];
	}
	/**
	 * 向量缩放
	 * @param {Vector2} out
	 * @param {Vector2} v
	 * @param {number} s
	 */
	
	
	function scale(out, v, s) {
	  out[0] = v[0] * s;
	  out[1] = v[1] * s;
	  return out;
	}
	/**
	 * 向量归一化
	 * @param {Vector2} out
	 * @param {Vector2} v
	 */
	
	
	function normalize(out, v) {
	  var d = len(v);
	
	  if (d === 0) {
	    out[0] = 0;
	    out[1] = 0;
	  } else {
	    out[0] = v[0] / d;
	    out[1] = v[1] / d;
	  }
	
	  return out;
	}
	/**
	 * 计算向量间距离
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @return {number}
	 */
	
	
	function distance(v1, v2) {
	  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
	}
	
	var dist = distance;
	/**
	 * 向量距离平方
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @return {number}
	 */
	
	function distanceSquare(v1, v2) {
	  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
	}
	
	var distSquare = distanceSquare;
	/**
	 * 求负向量
	 * @param {Vector2} out
	 * @param {Vector2} v
	 */
	
	function negate(out, v) {
	  out[0] = -v[0];
	  out[1] = -v[1];
	  return out;
	}
	/**
	 * 插值两个点
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @param {number} t
	 */
	
	
	function lerp(out, v1, v2, t) {
	  out[0] = v1[0] + t * (v2[0] - v1[0]);
	  out[1] = v1[1] + t * (v2[1] - v1[1]);
	  return out;
	}
	/**
	 * 矩阵左乘向量
	 * @param {Vector2} out
	 * @param {Vector2} v
	 * @param {Vector2} m
	 */
	
	
	function applyTransform(out, v, m) {
	  var x = v[0];
	  var y = v[1];
	  out[0] = m[0] * x + m[2] * y + m[4];
	  out[1] = m[1] * x + m[3] * y + m[5];
	  return out;
	}
	/**
	 * 求两个向量最小值
	 * @param  {Vector2} out
	 * @param  {Vector2} v1
	 * @param  {Vector2} v2
	 */
	
	
	function min(out, v1, v2) {
	  out[0] = Math.min(v1[0], v2[0]);
	  out[1] = Math.min(v1[1], v2[1]);
	  return out;
	}
	/**
	 * 求两个向量最大值
	 * @param  {Vector2} out
	 * @param  {Vector2} v1
	 * @param  {Vector2} v2
	 */
	
	
	function max(out, v1, v2) {
	  out[0] = Math.max(v1[0], v2[0]);
	  out[1] = Math.max(v1[1], v2[1]);
	  return out;
	}
	
	exports.create = create;
	exports.copy = copy;
	exports.clone = clone;
	exports.set = set;
	exports.add = add;
	exports.scaleAndAdd = scaleAndAdd;
	exports.sub = sub;
	exports.len = len;
	exports.length = length;
	exports.lenSquare = lenSquare;
	exports.lengthSquare = lengthSquare;
	exports.mul = mul;
	exports.div = div;
	exports.dot = dot;
	exports.scale = scale;
	exports.normalize = normalize;
	exports.distance = distance;
	exports.dist = dist;
	exports.distanceSquare = distanceSquare;
	exports.distSquare = distSquare;
	exports.negate = negate;
	exports.lerp = lerp;
	exports.applyTransform = applyTransform;
	exports.min = min;
	exports.max = max;

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	// TODO Draggable for group
	// FIXME Draggable on element which has parent rotation or scale
	function Draggable() {
	  this.on('mousedown', this._dragStart, this);
	  this.on('mousemove', this._drag, this);
	  this.on('mouseup', this._dragEnd, this);
	  this.on('globalout', this._dragEnd, this); // this._dropTarget = null;
	  // this._draggingTarget = null;
	  // this._x = 0;
	  // this._y = 0;
	}
	
	Draggable.prototype = {
	  constructor: Draggable,
	  _dragStart: function (e) {
	    var draggingTarget = e.target;
	
	    if (draggingTarget && draggingTarget.draggable) {
	      this._draggingTarget = draggingTarget;
	      draggingTarget.dragging = true;
	      this._x = e.offsetX;
	      this._y = e.offsetY;
	      this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);
	    }
	  },
	  _drag: function (e) {
	    var draggingTarget = this._draggingTarget;
	
	    if (draggingTarget) {
	      var x = e.offsetX;
	      var y = e.offsetY;
	      var dx = x - this._x;
	      var dy = y - this._y;
	      this._x = x;
	      this._y = y;
	      draggingTarget.drift(dx, dy, e);
	      this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);
	      var dropTarget = this.findHover(x, y, draggingTarget).target;
	      var lastDropTarget = this._dropTarget;
	      this._dropTarget = dropTarget;
	
	      if (draggingTarget !== dropTarget) {
	        if (lastDropTarget && dropTarget !== lastDropTarget) {
	          this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);
	        }
	
	        if (dropTarget && dropTarget !== lastDropTarget) {
	          this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);
	        }
	      }
	    }
	  },
	  _dragEnd: function (e) {
	    var draggingTarget = this._draggingTarget;
	
	    if (draggingTarget) {
	      draggingTarget.dragging = false;
	    }
	
	    this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);
	
	    if (this._dropTarget) {
	      this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);
	    }
	
	    this._draggingTarget = null;
	    this._dropTarget = null;
	  }
	};
	
	function param(target, e) {
	  return {
	    target: target,
	    topTarget: e && e.topTarget
	  };
	}
	
	var _default = Draggable;
	module.exports = _default;

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	/**
	 * 事件扩展
	 * @module zrender/mixin/Eventful
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	var arrySlice = Array.prototype.slice;
	/**
	 * 事件分发器
	 * @alias module:zrender/mixin/Eventful
	 * @constructor
	 */
	
	var Eventful = function () {
	  this._$handlers = {};
	};
	
	Eventful.prototype = {
	  constructor: Eventful,
	
	  /**
	   * 单次触发绑定，trigger后销毁
	   *
	   * @param {string} event 事件名
	   * @param {Function} handler 响应函数
	   * @param {Object} context
	   */
	  one: function (event, handler, context) {
	    var _h = this._$handlers;
	
	    if (!handler || !event) {
	      return this;
	    }
	
	    if (!_h[event]) {
	      _h[event] = [];
	    }
	
	    for (var i = 0; i < _h[event].length; i++) {
	      if (_h[event][i].h === handler) {
	        return this;
	      }
	    }
	
	    _h[event].push({
	      h: handler,
	      one: true,
	      ctx: context || this
	    });
	
	    return this;
	  },
	
	  /**
	   * 绑定事件
	   * @param {string} event 事件名
	   * @param {Function} handler 事件处理函数
	   * @param {Object} [context]
	   */
	  on: function (event, handler, context) {
	    var _h = this._$handlers;
	
	    if (!handler || !event) {
	      return this;
	    }
	
	    if (!_h[event]) {
	      _h[event] = [];
	    }
	
	    for (var i = 0; i < _h[event].length; i++) {
	      if (_h[event][i].h === handler) {
	        return this;
	      }
	    }
	
	    _h[event].push({
	      h: handler,
	      one: false,
	      ctx: context || this
	    });
	
	    return this;
	  },
	
	  /**
	   * 是否绑定了事件
	   * @param  {string}  event
	   * @return {boolean}
	   */
	  isSilent: function (event) {
	    var _h = this._$handlers;
	    return _h[event] && _h[event].length;
	  },
	
	  /**
	   * 解绑事件
	   * @param {string} event 事件名
	   * @param {Function} [handler] 事件处理函数
	   */
	  off: function (event, handler) {
	    var _h = this._$handlers;
	
	    if (!event) {
	      this._$handlers = {};
	      return this;
	    }
	
	    if (handler) {
	      if (_h[event]) {
	        var newList = [];
	
	        for (var i = 0, l = _h[event].length; i < l; i++) {
	          if (_h[event][i]['h'] != handler) {
	            newList.push(_h[event][i]);
	          }
	        }
	
	        _h[event] = newList;
	      }
	
	      if (_h[event] && _h[event].length === 0) {
	        delete _h[event];
	      }
	    } else {
	      delete _h[event];
	    }
	
	    return this;
	  },
	
	  /**
	   * 事件分发
	   *
	   * @param {string} type 事件类型
	   */
	  trigger: function (type) {
	    if (this._$handlers[type]) {
	      var args = arguments;
	      var argLen = args.length;
	
	      if (argLen > 3) {
	        args = arrySlice.call(args, 1);
	      }
	
	      var _h = this._$handlers[type];
	      var len = _h.length;
	
	      for (var i = 0; i < len;) {
	        // Optimize advise from backbone
	        switch (argLen) {
	          case 1:
	            _h[i]['h'].call(_h[i]['ctx']);
	
	            break;
	
	          case 2:
	            _h[i]['h'].call(_h[i]['ctx'], args[1]);
	
	            break;
	
	          case 3:
	            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);
	
	            break;
	
	          default:
	            // have more than 2 given arguments
	            _h[i]['h'].apply(_h[i]['ctx'], args);
	
	            break;
	        }
	
	        if (_h[i]['one']) {
	          _h.splice(i, 1);
	
	          len--;
	        } else {
	          i++;
	        }
	      }
	    }
	
	    return this;
	  },
	
	  /**
	   * 带有context的事件分发, 最后一个参数是事件回调的context
	   * @param {string} type 事件类型
	   */
	  triggerWithContext: function (type) {
	    if (this._$handlers[type]) {
	      var args = arguments;
	      var argLen = args.length;
	
	      if (argLen > 4) {
	        args = arrySlice.call(args, 1, args.length - 1);
	      }
	
	      var ctx = args[args.length - 1];
	      var _h = this._$handlers[type];
	      var len = _h.length;
	
	      for (var i = 0; i < len;) {
	        // Optimize advise from backbone
	        switch (argLen) {
	          case 1:
	            _h[i]['h'].call(ctx);
	
	            break;
	
	          case 2:
	            _h[i]['h'].call(ctx, args[1]);
	
	            break;
	
	          case 3:
	            _h[i]['h'].call(ctx, args[1], args[2]);
	
	            break;
	
	          default:
	            // have more than 2 given arguments
	            _h[i]['h'].apply(ctx, args);
	
	            break;
	        }
	
	        if (_h[i]['one']) {
	          _h.splice(i, 1);
	
	          len--;
	        } else {
	          i++;
	        }
	      }
	    }
	
	    return this;
	  }
	}; // 对象可以通过 onxxxx 绑定事件
	
	/**
	 * @event module:zrender/mixin/Eventful#onclick
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmouseover
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmouseout
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmousemove
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmousewheel
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmousedown
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmouseup
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondrag
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragstart
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragend
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragenter
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragleave
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragover
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondrop
	 * @type {Function}
	 * @default null
	 */
	
	var _default = Eventful;
	module.exports = _default;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(6);
	
	var env = __webpack_require__(5);
	
	var Group = __webpack_require__(12);
	
	var timsort = __webpack_require__(25);
	
	/**
	 * Storage内容仓库模块
	 * @module zrender/Storage
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 * @author errorrik (errorrik@gmail.com)
	 * @author pissang (https://github.com/pissang/)
	 */
	// Use timsort because in most case elements are partially sorted
	// https://jsfiddle.net/pissang/jr4x7mdm/8/
	function shapeCompareFunc(a, b) {
	  if (a.zlevel === b.zlevel) {
	    if (a.z === b.z) {
	      // if (a.z2 === b.z2) {
	      //     // FIXME Slow has renderidx compare
	      //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement
	      //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012
	      //     return a.__renderidx - b.__renderidx;
	      // }
	      return a.z2 - b.z2;
	    }
	
	    return a.z - b.z;
	  }
	
	  return a.zlevel - b.zlevel;
	}
	/**
	 * 内容仓库 (M)
	 * @alias module:zrender/Storage
	 * @constructor
	 */
	
	
	var Storage = function () {
	  // jshint ignore:line
	  this._roots = [];
	  this._displayList = [];
	  this._displayListLen = 0;
	};
	
	Storage.prototype = {
	  constructor: Storage,
	
	  /**
	   * @param  {Function} cb
	   *
	   */
	  traverse: function (cb, context) {
	    for (var i = 0; i < this._roots.length; i++) {
	      this._roots[i].traverse(cb, context);
	    }
	  },
	
	  /**
	   * 返回所有图形的绘制队列
	   * @param {boolean} [update=false] 是否在返回前更新该数组
	   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
	   *
	   * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
	   * @return {Array.<module:zrender/graphic/Displayable>}
	   */
	  getDisplayList: function (update, includeIgnore) {
	    includeIgnore = includeIgnore || false;
	
	    if (update) {
	      this.updateDisplayList(includeIgnore);
	    }
	
	    return this._displayList;
	  },
	
	  /**
	   * 更新图形的绘制队列。
	   * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
	   * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
	   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
	   */
	  updateDisplayList: function (includeIgnore) {
	    this._displayListLen = 0;
	    var roots = this._roots;
	    var displayList = this._displayList;
	
	    for (var i = 0, len = roots.length; i < len; i++) {
	      this._updateAndAddDisplayable(roots[i], null, includeIgnore);
	    }
	
	    displayList.length = this._displayListLen; // for (var i = 0, len = displayList.length; i < len; i++) {
	    //     displayList[i].__renderidx = i;
	    // }
	    // displayList.sort(shapeCompareFunc);
	
	    env.canvasSupported && timsort(displayList, shapeCompareFunc);
	  },
	  _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {
	    if (el.ignore && !includeIgnore) {
	      return;
	    }
	
	    el.beforeUpdate();
	
	    if (el.__dirty) {
	      el.update();
	    }
	
	    el.afterUpdate();
	    var userSetClipPath = el.clipPath;
	
	    if (userSetClipPath) {
	      // FIXME 效率影响
	      if (clipPaths) {
	        clipPaths = clipPaths.slice();
	      } else {
	        clipPaths = [];
	      }
	
	      var currentClipPath = userSetClipPath;
	      var parentClipPath = el; // Recursively add clip path
	
	      while (currentClipPath) {
	        // clipPath 的变换是基于使用这个 clipPath 的元素
	        currentClipPath.parent = parentClipPath;
	        currentClipPath.updateTransform();
	        clipPaths.push(currentClipPath);
	        parentClipPath = currentClipPath;
	        currentClipPath = currentClipPath.clipPath;
	      }
	    }
	
	    if (el.isGroup) {
	      var children = el._children;
	
	      for (var i = 0; i < children.length; i++) {
	        var child = children[i]; // Force to mark as dirty if group is dirty
	        // FIXME __dirtyPath ?
	
	        if (el.__dirty) {
	          child.__dirty = true;
	        }
	
	        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
	      } // Mark group clean here
	
	
	      el.__dirty = false;
	    } else {
	      el.__clipPaths = clipPaths;
	      this._displayList[this._displayListLen++] = el;
	    }
	  },
	
	  /**
	   * 添加图形(Shape)或者组(Group)到根节点
	   * @param {module:zrender/Element} el
	   */
	  addRoot: function (el) {
	    if (el.__storage === this) {
	      return;
	    }
	
	    if (el instanceof Group) {
	      el.addChildrenToStorage(this);
	    }
	
	    this.addToStorage(el);
	
	    this._roots.push(el);
	  },
	
	  /**
	   * 删除指定的图形(Shape)或者组(Group)
	   * @param {string|Array.<string>} [el] 如果为空清空整个Storage
	   */
	  delRoot: function (el) {
	    if (el == null) {
	      // 不指定el清空
	      for (var i = 0; i < this._roots.length; i++) {
	        var root = this._roots[i];
	
	        if (root instanceof Group) {
	          root.delChildrenFromStorage(this);
	        }
	      }
	
	      this._roots = [];
	      this._displayList = [];
	      this._displayListLen = 0;
	      return;
	    }
	
	    if (el instanceof Array) {
	      for (var i = 0, l = el.length; i < l; i++) {
	        this.delRoot(el[i]);
	      }
	
	      return;
	    }
	
	    var idx = util.indexOf(this._roots, el);
	
	    if (idx >= 0) {
	      this.delFromStorage(el);
	
	      this._roots.splice(idx, 1);
	
	      if (el instanceof Group) {
	        el.delChildrenFromStorage(this);
	      }
	    }
	  },
	  addToStorage: function (el) {
	    el.__storage = this;
	    el.dirty(false);
	    return this;
	  },
	  delFromStorage: function (el) {
	    if (el) {
	      el.__storage = null;
	    }
	
	    return this;
	  },
	
	  /**
	   * 清空并且释放Storage
	   */
	  dispose: function () {
	    this._renderList = this._roots = null;
	  },
	  displayableSortFunc: shapeCompareFunc
	};
	var _default = Storage;
	module.exports = _default;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(6);
	
	var Element = __webpack_require__(13);
	
	var BoundingRect = __webpack_require__(24);
	
	/**
	 * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
	 * @module zrender/graphic/Group
	 * @example
	 *     var Group = require('zrender/container/Group');
	 *     var Circle = require('zrender/graphic/shape/Circle');
	 *     var g = new Group();
	 *     g.position[0] = 100;
	 *     g.position[1] = 100;
	 *     g.add(new Circle({
	 *         style: {
	 *             x: 100,
	 *             y: 100,
	 *             r: 20,
	 *         }
	 *     }));
	 *     zr.add(g);
	 */
	
	/**
	 * @alias module:zrender/graphic/Group
	 * @constructor
	 * @extends module:zrender/mixin/Transformable
	 * @extends module:zrender/mixin/Eventful
	 */
	var Group = function (opts) {
	  opts = opts || {};
	  Element.call(this, opts);
	
	  for (var key in opts) {
	    if (opts.hasOwnProperty(key)) {
	      this[key] = opts[key];
	    }
	  }
	
	  this._children = [];
	  this.__storage = null;
	  this.__dirty = true;
	};
	
	Group.prototype = {
	  constructor: Group,
	  isGroup: true,
	
	  /**
	   * @type {string}
	   */
	  type: 'group',
	
	  /**
	   * 所有子孙元素是否响应鼠标事件
	   * @name module:/zrender/container/Group#silent
	   * @type {boolean}
	   * @default false
	   */
	  silent: false,
	
	  /**
	   * @return {Array.<module:zrender/Element>}
	   */
	  children: function () {
	    return this._children.slice();
	  },
	
	  /**
	   * 获取指定 index 的儿子节点
	   * @param  {number} idx
	   * @return {module:zrender/Element}
	   */
	  childAt: function (idx) {
	    return this._children[idx];
	  },
	
	  /**
	   * 获取指定名字的儿子节点
	   * @param  {string} name
	   * @return {module:zrender/Element}
	   */
	  childOfName: function (name) {
	    var children = this._children;
	
	    for (var i = 0; i < children.length; i++) {
	      if (children[i].name === name) {
	        return children[i];
	      }
	    }
	  },
	
	  /**
	   * @return {number}
	   */
	  childCount: function () {
	    return this._children.length;
	  },
	
	  /**
	   * 添加子节点到最后
	   * @param {module:zrender/Element} child
	   */
	  add: function (child) {
	    if (child && child !== this && child.parent !== this) {
	      this._children.push(child);
	
	      this._doAdd(child);
	    }
	
	    return this;
	  },
	
	  /**
	   * 添加子节点在 nextSibling 之前
	   * @param {module:zrender/Element} child
	   * @param {module:zrender/Element} nextSibling
	   */
	  addBefore: function (child, nextSibling) {
	    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {
	      var children = this._children;
	      var idx = children.indexOf(nextSibling);
	
	      if (idx >= 0) {
	        children.splice(idx, 0, child);
	
	        this._doAdd(child);
	      }
	    }
	
	    return this;
	  },
	  _doAdd: function (child) {
	    if (child.parent) {
	      child.parent.remove(child);
	    }
	
	    child.parent = this;
	    var storage = this.__storage;
	    var zr = this.__zr;
	
	    if (storage && storage !== child.__storage) {
	      storage.addToStorage(child);
	
	      if (child instanceof Group) {
	        child.addChildrenToStorage(storage);
	      }
	    }
	
	    zr && zr.refresh();
	  },
	
	  /**
	   * 移除子节点
	   * @param {module:zrender/Element} child
	   */
	  remove: function (child) {
	    var zr = this.__zr;
	    var storage = this.__storage;
	    var children = this._children;
	    var idx = zrUtil.indexOf(children, child);
	
	    if (idx < 0) {
	      return this;
	    }
	
	    children.splice(idx, 1);
	    child.parent = null;
	
	    if (storage) {
	      storage.delFromStorage(child);
	
	      if (child instanceof Group) {
	        child.delChildrenFromStorage(storage);
	      }
	    }
	
	    zr && zr.refresh();
	    return this;
	  },
	
	  /**
	   * 移除所有子节点
	   */
	  removeAll: function () {
	    var children = this._children;
	    var storage = this.__storage;
	    var child;
	    var i;
	
	    for (i = 0; i < children.length; i++) {
	      child = children[i];
	
	      if (storage) {
	        storage.delFromStorage(child);
	
	        if (child instanceof Group) {
	          child.delChildrenFromStorage(storage);
	        }
	      }
	
	      child.parent = null;
	    }
	
	    children.length = 0;
	    return this;
	  },
	
	  /**
	   * 遍历所有子节点
	   * @param  {Function} cb
	   * @param  {}   context
	   */
	  eachChild: function (cb, context) {
	    var children = this._children;
	
	    for (var i = 0; i < children.length; i++) {
	      var child = children[i];
	      cb.call(context, child, i);
	    }
	
	    return this;
	  },
	
	  /**
	   * 深度优先遍历所有子孙节点
	   * @param  {Function} cb
	   * @param  {}   context
	   */
	  traverse: function (cb, context) {
	    for (var i = 0; i < this._children.length; i++) {
	      var child = this._children[i];
	      cb.call(context, child);
	
	      if (child.type === 'group') {
	        child.traverse(cb, context);
	      }
	    }
	
	    return this;
	  },
	  addChildrenToStorage: function (storage) {
	    for (var i = 0; i < this._children.length; i++) {
	      var child = this._children[i];
	      storage.addToStorage(child);
	
	      if (child instanceof Group) {
	        child.addChildrenToStorage(storage);
	      }
	    }
	  },
	  delChildrenFromStorage: function (storage) {
	    for (var i = 0; i < this._children.length; i++) {
	      var child = this._children[i];
	      storage.delFromStorage(child);
	
	      if (child instanceof Group) {
	        child.delChildrenFromStorage(storage);
	      }
	    }
	  },
	  dirty: function () {
	    this.__dirty = true;
	    this.__zr && this.__zr.refresh();
	    return this;
	  },
	
	  /**
	   * @return {module:zrender/core/BoundingRect}
	   */
	  getBoundingRect: function (includeChildren) {
	    // TODO Caching
	    var rect = null;
	    var tmpRect = new BoundingRect(0, 0, 0, 0);
	    var children = includeChildren || this._children;
	    var tmpMat = [];
	
	    for (var i = 0; i < children.length; i++) {
	      var child = children[i];
	
	      if (child.ignore || child.invisible) {
	        continue;
	      }
	
	      var childRect = child.getBoundingRect();
	      var transform = child.getLocalTransform(tmpMat); // TODO
	      // The boundingRect cacluated by transforming original
	      // rect may be bigger than the actual bundingRect when rotation
	      // is used. (Consider a circle rotated aginst its center, where
	      // the actual boundingRect should be the same as that not be
	      // rotated.) But we can not find better approach to calculate
	      // actual boundingRect yet, considering performance.
	
	      if (transform) {
	        tmpRect.copy(childRect);
	        tmpRect.applyTransform(transform);
	        rect = rect || tmpRect.clone();
	        rect.union(tmpRect);
	      } else {
	        rect = rect || childRect.clone();
	        rect.union(childRect);
	      }
	    }
	
	    return rect || tmpRect;
	  }
	};
	zrUtil.inherits(Group, Element);
	var _default = Group;
	module.exports = _default;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	var guid = __webpack_require__(4);
	
	var Eventful = __webpack_require__(10);
	
	var Transformable = __webpack_require__(14);
	
	var Animatable = __webpack_require__(16);
	
	var zrUtil = __webpack_require__(6);
	
	/**
	 * @alias module:zrender/Element
	 * @constructor
	 * @extends {module:zrender/mixin/Animatable}
	 * @extends {module:zrender/mixin/Transformable}
	 * @extends {module:zrender/mixin/Eventful}
	 */
	var Element = function (opts) {
	  // jshint ignore:line
	  Transformable.call(this, opts);
	  Eventful.call(this, opts);
	  Animatable.call(this, opts);
	  /**
	   * 画布元素ID
	   * @type {string}
	   */
	
	  this.id = opts.id || guid();
	};
	
	Element.prototype = {
	  /**
	   * 元素类型
	   * Element type
	   * @type {string}
	   */
	  type: 'element',
	
	  /**
	   * 元素名字
	   * Element name
	   * @type {string}
	   */
	  name: '',
	
	  /**
	   * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
	   * ZRender instance will be assigned when element is associated with zrender
	   * @name module:/zrender/Element#__zr
	   * @type {module:zrender/ZRender}
	   */
	  __zr: null,
	
	  /**
	   * 图形是否忽略，为true时忽略图形的绘制以及事件触发
	   * If ignore drawing and events of the element object
	   * @name module:/zrender/Element#ignore
	   * @type {boolean}
	   * @default false
	   */
	  ignore: false,
	
	  /**
	   * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
	   * 该路径会继承被裁减对象的变换
	   * @type {module:zrender/graphic/Path}
	   * @see http://www.w3.org/TR/2dcontext/#clipping-region
	   * @readOnly
	   */
	  clipPath: null,
	
	  /**
	   * Drift element
	   * @param  {number} dx dx on the global space
	   * @param  {number} dy dy on the global space
	   */
	  drift: function (dx, dy) {
	    switch (this.draggable) {
	      case 'horizontal':
	        dy = 0;
	        break;
	
	      case 'vertical':
	        dx = 0;
	        break;
	    }
	
	    var m = this.transform;
	
	    if (!m) {
	      m = this.transform = [1, 0, 0, 1, 0, 0];
	    }
	
	    m[4] += dx;
	    m[5] += dy;
	    this.decomposeTransform();
	    this.dirty(false);
	  },
	
	  /**
	   * Hook before update
	   */
	  beforeUpdate: function () {},
	
	  /**
	   * Hook after update
	   */
	  afterUpdate: function () {},
	
	  /**
	   * Update each frame
	   */
	  update: function () {
	    this.updateTransform();
	  },
	
	  /**
	   * @param  {Function} cb
	   * @param  {}   context
	   */
	  traverse: function (cb, context) {},
	
	  /**
	   * @protected
	   */
	  attrKV: function (key, value) {
	    if (key === 'position' || key === 'scale' || key === 'origin') {
	      // Copy the array
	      if (value) {
	        var target = this[key];
	
	        if (!target) {
	          target = this[key] = [];
	        }
	
	        target[0] = value[0];
	        target[1] = value[1];
	      }
	    } else {
	      this[key] = value;
	    }
	  },
	
	  /**
	   * Hide the element
	   */
	  hide: function () {
	    this.ignore = true;
	    this.__zr && this.__zr.refresh();
	  },
	
	  /**
	   * Show the element
	   */
	  show: function () {
	    this.ignore = false;
	    this.__zr && this.__zr.refresh();
	  },
	
	  /**
	   * @param {string|Object} key
	   * @param {*} value
	   */
	  attr: function (key, value) {
	    if (typeof key === 'string') {
	      this.attrKV(key, value);
	    } else if (zrUtil.isObject(key)) {
	      for (var name in key) {
	        if (key.hasOwnProperty(name)) {
	          this.attrKV(name, key[name]);
	        }
	      }
	    }
	
	    this.dirty(false);
	    return this;
	  },
	
	  /**
	   * @param {module:zrender/graphic/Path} clipPath
	   */
	  setClipPath: function (clipPath) {
	    var zr = this.__zr;
	
	    if (zr) {
	      clipPath.addSelfToZr(zr);
	    } // Remove previous clip path
	
	
	    if (this.clipPath && this.clipPath !== clipPath) {
	      this.removeClipPath();
	    }
	
	    this.clipPath = clipPath;
	    clipPath.__zr = zr;
	    clipPath.__clipTarget = this;
	    this.dirty(false);
	  },
	
	  /**
	   */
	  removeClipPath: function () {
	    var clipPath = this.clipPath;
	
	    if (clipPath) {
	      if (clipPath.__zr) {
	        clipPath.removeSelfFromZr(clipPath.__zr);
	      }
	
	      clipPath.__zr = null;
	      clipPath.__clipTarget = null;
	      this.clipPath = null;
	      this.dirty(false);
	    }
	  },
	
	  /**
	   * Add self from zrender instance.
	   * Not recursively because it will be invoked when element added to storage.
	   * @param {module:zrender/ZRender} zr
	   */
	  addSelfToZr: function (zr) {
	    this.__zr = zr; // 添加动画
	
	    var animators = this.animators;
	
	    if (animators) {
	      for (var i = 0; i < animators.length; i++) {
	        zr.animation.addAnimator(animators[i]);
	      }
	    }
	
	    if (this.clipPath) {
	      this.clipPath.addSelfToZr(zr);
	    }
	  },
	
	  /**
	   * Remove self from zrender instance.
	   * Not recursively because it will be invoked when element added to storage.
	   * @param {module:zrender/ZRender} zr
	   */
	  removeSelfFromZr: function (zr) {
	    this.__zr = null; // 移除动画
	
	    var animators = this.animators;
	
	    if (animators) {
	      for (var i = 0; i < animators.length; i++) {
	        zr.animation.removeAnimator(animators[i]);
	      }
	    }
	
	    if (this.clipPath) {
	      this.clipPath.removeSelfFromZr(zr);
	    }
	  }
	};
	zrUtil.mixin(Element, Animatable);
	zrUtil.mixin(Element, Transformable);
	zrUtil.mixin(Element, Eventful);
	var _default = Element;
	module.exports = _default;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	var matrix = __webpack_require__(15);
	
	var vector = __webpack_require__(8);
	
	/**
	 * 提供变换扩展
	 * @module zrender/mixin/Transformable
	 * @author pissang (https://www.github.com/pissang)
	 */
	var mIdentity = matrix.identity;
	var EPSILON = 5e-5;
	
	function isNotAroundZero(val) {
	  return val > EPSILON || val < -EPSILON;
	}
	/**
	 * @alias module:zrender/mixin/Transformable
	 * @constructor
	 */
	
	
	var Transformable = function (opts) {
	  opts = opts || {}; // If there are no given position, rotation, scale
	
	  if (!opts.position) {
	    /**
	     * 平移
	     * @type {Array.<number>}
	     * @default [0, 0]
	     */
	    this.position = [0, 0];
	  }
	
	  if (opts.rotation == null) {
	    /**
	     * 旋转
	     * @type {Array.<number>}
	     * @default 0
	     */
	    this.rotation = 0;
	  }
	
	  if (!opts.scale) {
	    /**
	     * 缩放
	     * @type {Array.<number>}
	     * @default [1, 1]
	     */
	    this.scale = [1, 1];
	  }
	  /**
	   * 旋转和缩放的原点
	   * @type {Array.<number>}
	   * @default null
	   */
	
	
	  this.origin = this.origin || null;
	};
	
	var transformableProto = Transformable.prototype;
	transformableProto.transform = null;
	/**
	 * 判断是否需要有坐标变换
	 * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
	 */
	
	transformableProto.needLocalTransform = function () {
	  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);
	};
	
	transformableProto.updateTransform = function () {
	  var parent = this.parent;
	  var parentHasTransform = parent && parent.transform;
	  var needLocalTransform = this.needLocalTransform();
	  var m = this.transform;
	
	  if (!(needLocalTransform || parentHasTransform)) {
	    m && mIdentity(m);
	    return;
	  }
	
	  m = m || matrix.create();
	
	  if (needLocalTransform) {
	    this.getLocalTransform(m);
	  } else {
	    mIdentity(m);
	  } // 应用父节点变换
	
	
	  if (parentHasTransform) {
	    if (needLocalTransform) {
	      matrix.mul(m, parent.transform, m);
	    } else {
	      matrix.copy(m, parent.transform);
	    }
	  } // 保存这个变换矩阵
	
	
	  this.transform = m;
	  this.invTransform = this.invTransform || matrix.create();
	  matrix.invert(this.invTransform, m);
	};
	
	transformableProto.getLocalTransform = function (m) {
	  return Transformable.getLocalTransform(this, m);
	};
	/**
	 * 将自己的transform应用到context上
	 * @param {CanvasRenderingContext2D} ctx
	 */
	
	
	transformableProto.setTransform = function (ctx) {
	  var m = this.transform;
	  var dpr = ctx.dpr || 1;
	
	  if (m) {
	    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
	  } else {
	    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	  }
	};
	
	transformableProto.restoreTransform = function (ctx) {
	  var dpr = ctx.dpr || 1;
	  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	};
	
	var tmpTransform = [];
	/**
	 * 分解`transform`矩阵到`position`, `rotation`, `scale`
	 */
	
	transformableProto.decomposeTransform = function () {
	  if (!this.transform) {
	    return;
	  }
	
	  var parent = this.parent;
	  var m = this.transform;
	
	  if (parent && parent.transform) {
	    // Get local transform and decompose them to position, scale, rotation
	    matrix.mul(tmpTransform, parent.invTransform, m);
	    m = tmpTransform;
	  }
	
	  var sx = m[0] * m[0] + m[1] * m[1];
	  var sy = m[2] * m[2] + m[3] * m[3];
	  var position = this.position;
	  var scale = this.scale;
	
	  if (isNotAroundZero(sx - 1)) {
	    sx = Math.sqrt(sx);
	  }
	
	  if (isNotAroundZero(sy - 1)) {
	    sy = Math.sqrt(sy);
	  }
	
	  if (m[0] < 0) {
	    sx = -sx;
	  }
	
	  if (m[3] < 0) {
	    sy = -sy;
	  }
	
	  position[0] = m[4];
	  position[1] = m[5];
	  scale[0] = sx;
	  scale[1] = sy;
	  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
	};
	/**
	 * Get global scale
	 * @return {Array.<number>}
	 */
	
	
	transformableProto.getGlobalScale = function () {
	  var m = this.transform;
	
	  if (!m) {
	    return [1, 1];
	  }
	
	  var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
	  var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);
	
	  if (m[0] < 0) {
	    sx = -sx;
	  }
	
	  if (m[3] < 0) {
	    sy = -sy;
	  }
	
	  return [sx, sy];
	};
	/**
	 * 变换坐标位置到 shape 的局部坐标空间
	 * @method
	 * @param {number} x
	 * @param {number} y
	 * @return {Array.<number>}
	 */
	
	
	transformableProto.transformCoordToLocal = function (x, y) {
	  var v2 = [x, y];
	  var invTransform = this.invTransform;
	
	  if (invTransform) {
	    vector.applyTransform(v2, v2, invTransform);
	  }
	
	  return v2;
	};
	/**
	 * 变换局部坐标位置到全局坐标空间
	 * @method
	 * @param {number} x
	 * @param {number} y
	 * @return {Array.<number>}
	 */
	
	
	transformableProto.transformCoordToGlobal = function (x, y) {
	  var v2 = [x, y];
	  var transform = this.transform;
	
	  if (transform) {
	    vector.applyTransform(v2, v2, transform);
	  }
	
	  return v2;
	};
	/**
	 * @static
	 * @param {Object} target
	 * @param {Array.<number>} target.origin
	 * @param {number} target.rotation
	 * @param {Array.<number>} target.position
	 * @param {Array.<number>} [m]
	 */
	
	
	Transformable.getLocalTransform = function (target, m) {
	  m = m || [];
	  mIdentity(m);
	  var origin = target.origin;
	  var scale = target.scale || [1, 1];
	  var rotation = target.rotation || 0;
	  var position = target.position || [0, 0];
	
	  if (origin) {
	    // Translate to origin
	    m[4] -= origin[0];
	    m[5] -= origin[1];
	  }
	
	  matrix.scale(m, m, scale);
	
	  if (rotation) {
	    matrix.rotate(m, m, rotation);
	  }
	
	  if (origin) {
	    // Translate back from origin
	    m[4] += origin[0];
	    m[5] += origin[1];
	  }
	
	  m[4] += position[0];
	  m[5] += position[1];
	  return m;
	};
	
	var _default = Transformable;
	module.exports = _default;

/***/ }),
/* 15 */
/***/ (function(module, exports) {

	/**
	 * 3x2矩阵操作类
	 * @exports zrender/tool/matrix
	 */
	var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
	/**
	 * 创建一个单位矩阵
	 * @return {Float32Array|Array.<number>}
	 */
	
	function create() {
	  var out = new ArrayCtor(6);
	  identity(out);
	  return out;
	}
	/**
	 * 设置矩阵为单位矩阵
	 * @param {Float32Array|Array.<number>} out
	 */
	
	
	function identity(out) {
	  out[0] = 1;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 1;
	  out[4] = 0;
	  out[5] = 0;
	  return out;
	}
	/**
	 * 复制矩阵
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} m
	 */
	
	
	function copy(out, m) {
	  out[0] = m[0];
	  out[1] = m[1];
	  out[2] = m[2];
	  out[3] = m[3];
	  out[4] = m[4];
	  out[5] = m[5];
	  return out;
	}
	/**
	 * 矩阵相乘
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} m1
	 * @param {Float32Array|Array.<number>} m2
	 */
	
	
	function mul(out, m1, m2) {
	  // Consider matrix.mul(m, m2, m);
	  // where out is the same as m2.
	  // So use temp variable to escape error.
	  var out0 = m1[0] * m2[0] + m1[2] * m2[1];
	  var out1 = m1[1] * m2[0] + m1[3] * m2[1];
	  var out2 = m1[0] * m2[2] + m1[2] * m2[3];
	  var out3 = m1[1] * m2[2] + m1[3] * m2[3];
	  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
	  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
	  out[0] = out0;
	  out[1] = out1;
	  out[2] = out2;
	  out[3] = out3;
	  out[4] = out4;
	  out[5] = out5;
	  return out;
	}
	/**
	 * 平移变换
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} a
	 * @param {Float32Array|Array.<number>} v
	 */
	
	
	function translate(out, a, v) {
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  out[4] = a[4] + v[0];
	  out[5] = a[5] + v[1];
	  return out;
	}
	/**
	 * 旋转变换
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} a
	 * @param {number} rad
	 */
	
	
	function rotate(out, a, rad) {
	  var aa = a[0];
	  var ac = a[2];
	  var atx = a[4];
	  var ab = a[1];
	  var ad = a[3];
	  var aty = a[5];
	  var st = Math.sin(rad);
	  var ct = Math.cos(rad);
	  out[0] = aa * ct + ab * st;
	  out[1] = -aa * st + ab * ct;
	  out[2] = ac * ct + ad * st;
	  out[3] = -ac * st + ct * ad;
	  out[4] = ct * atx + st * aty;
	  out[5] = ct * aty - st * atx;
	  return out;
	}
	/**
	 * 缩放变换
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} a
	 * @param {Float32Array|Array.<number>} v
	 */
	
	
	function scale(out, a, v) {
	  var vx = v[0];
	  var vy = v[1];
	  out[0] = a[0] * vx;
	  out[1] = a[1] * vy;
	  out[2] = a[2] * vx;
	  out[3] = a[3] * vy;
	  out[4] = a[4] * vx;
	  out[5] = a[5] * vy;
	  return out;
	}
	/**
	 * 求逆矩阵
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} a
	 */
	
	
	function invert(out, a) {
	  var aa = a[0];
	  var ac = a[2];
	  var atx = a[4];
	  var ab = a[1];
	  var ad = a[3];
	  var aty = a[5];
	  var det = aa * ad - ab * ac;
	
	  if (!det) {
	    return null;
	  }
	
	  det = 1.0 / det;
	  out[0] = ad * det;
	  out[1] = -ab * det;
	  out[2] = -ac * det;
	  out[3] = aa * det;
	  out[4] = (ac * aty - ad * atx) * det;
	  out[5] = (ab * atx - aa * aty) * det;
	  return out;
	}
	
	exports.create = create;
	exports.identity = identity;
	exports.copy = copy;
	exports.mul = mul;
	exports.translate = translate;
	exports.rotate = rotate;
	exports.scale = scale;
	exports.invert = invert;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	var Animator = __webpack_require__(17);
	
	var log = __webpack_require__(22);
	
	var _util = __webpack_require__(6);
	
	var isString = _util.isString;
	var isFunction = _util.isFunction;
	var isObject = _util.isObject;
	var isArrayLike = _util.isArrayLike;
	var indexOf = _util.indexOf;
	
	/**
	 * @alias modue:zrender/mixin/Animatable
	 * @constructor
	 */
	var Animatable = function () {
	  /**
	   * @type {Array.<module:zrender/animation/Animator>}
	   * @readOnly
	   */
	  this.animators = [];
	};
	
	Animatable.prototype = {
	  constructor: Animatable,
	
	  /**
	   * 动画
	   *
	   * @param {string} path The path to fetch value from object, like 'a.b.c'.
	   * @param {boolean} [loop] Whether to loop animation.
	   * @return {module:zrender/animation/Animator}
	   * @example:
	   *     el.animate('style', false)
	   *         .when(1000, {x: 10} )
	   *         .done(function(){ // Animation done })
	   *         .start()
	   */
	  animate: function (path, loop) {
	    var target;
	    var animatingShape = false;
	    var el = this;
	    var zr = this.__zr;
	
	    if (path) {
	      var pathSplitted = path.split('.');
	      var prop = el; // If animating shape
	
	      animatingShape = pathSplitted[0] === 'shape';
	
	      for (var i = 0, l = pathSplitted.length; i < l; i++) {
	        if (!prop) {
	          continue;
	        }
	
	        prop = prop[pathSplitted[i]];
	      }
	
	      if (prop) {
	        target = prop;
	      }
	    } else {
	      target = el;
	    }
	
	    if (!target) {
	      log('Property "' + path + '" is not existed in element ' + el.id);
	      return;
	    }
	
	    var animators = el.animators;
	    var animator = new Animator(target, loop);
	    animator.during(function (target) {
	      el.dirty(animatingShape);
	    }).done(function () {
	      // FIXME Animator will not be removed if use `Animator#stop` to stop animation
	      animators.splice(indexOf(animators, animator), 1);
	    });
	    animators.push(animator); // If animate after added to the zrender
	
	    if (zr) {
	      zr.animation.addAnimator(animator);
	    }
	
	    return animator;
	  },
	
	  /**
	   * 停止动画
	   * @param {boolean} forwardToLast If move to last frame before stop
	   */
	  stopAnimation: function (forwardToLast) {
	    var animators = this.animators;
	    var len = animators.length;
	
	    for (var i = 0; i < len; i++) {
	      animators[i].stop(forwardToLast);
	    }
	
	    animators.length = 0;
	    return this;
	  },
	
	  /**
	   * Caution: this method will stop previous animation.
	   * So do not use this method to one element twice before
	   * animation starts, unless you know what you are doing.
	   * @param {Object} target
	   * @param {number} [time=500] Time in ms
	   * @param {string} [easing='linear']
	   * @param {number} [delay=0]
	   * @param {Function} [callback]
	   * @param {Function} [forceAnimate] Prevent stop animation and callback
	   *        immediently when target values are the same as current values.
	   *
	   * @example
	   *  // Animate position
	   *  el.animateTo({
	   *      position: [10, 10]
	   *  }, function () { // done })
	   *
	   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
	   *  el.animateTo({
	   *      shape: {
	   *          width: 500
	   *      },
	   *      style: {
	   *          fill: 'red'
	   *      }
	   *      position: [10, 10]
	   *  }, 100, 100, 'cubicOut', function () { // done })
	   */
	  // TODO Return animation key
	  animateTo: function (target, time, delay, easing, callback, forceAnimate) {
	    // animateTo(target, time, easing, callback);
	    if (isString(delay)) {
	      callback = easing;
	      easing = delay;
	      delay = 0;
	    } // animateTo(target, time, delay, callback);
	    else if (isFunction(easing)) {
	        callback = easing;
	        easing = 'linear';
	        delay = 0;
	      } // animateTo(target, time, callback);
	      else if (isFunction(delay)) {
	          callback = delay;
	          delay = 0;
	        } // animateTo(target, callback)
	        else if (isFunction(time)) {
	            callback = time;
	            time = 500;
	          } // animateTo(target)
	          else if (!time) {
	              time = 500;
	            } // Stop all previous animations
	
	
	    this.stopAnimation();
	
	    this._animateToShallow('', this, target, time, delay); // Animators may be removed immediately after start
	    // if there is nothing to animate
	
	
	    var animators = this.animators.slice();
	    var count = animators.length;
	
	    function done() {
	      count--;
	
	      if (!count) {
	        callback && callback();
	      }
	    } // No animators. This should be checked before animators[i].start(),
	    // because 'done' may be executed immediately if no need to animate.
	
	
	    if (!count) {
	      callback && callback();
	    } // Start after all animators created
	    // Incase any animator is done immediately when all animation properties are not changed
	
	
	    for (var i = 0; i < animators.length; i++) {
	      animators[i].done(done).start(easing, forceAnimate);
	    }
	  },
	
	  /**
	   * @private
	   * @param {string} path=''
	   * @param {Object} source=this
	   * @param {Object} target
	   * @param {number} [time=500]
	   * @param {number} [delay=0]
	   *
	   * @example
	   *  // Animate position
	   *  el._animateToShallow({
	   *      position: [10, 10]
	   *  })
	   *
	   *  // Animate shape, style and position in 100ms, delayed 100ms
	   *  el._animateToShallow({
	   *      shape: {
	   *          width: 500
	   *      },
	   *      style: {
	   *          fill: 'red'
	   *      }
	   *      position: [10, 10]
	   *  }, 100, 100)
	   */
	  _animateToShallow: function (path, source, target, time, delay) {
	    var objShallow = {};
	    var propertyCount = 0;
	
	    for (var name in target) {
	      if (!target.hasOwnProperty(name)) {
	        continue;
	      }
	
	      if (source[name] != null) {
	        if (isObject(target[name]) && !isArrayLike(target[name])) {
	          this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);
	        } else {
	          objShallow[name] = target[name];
	          propertyCount++;
	        }
	      } else if (target[name] != null) {
	        // Attr directly if not has property
	        // FIXME, if some property not needed for element ?
	        if (!path) {
	          this.attr(name, target[name]);
	        } else {
	          // Shape or style
	          var props = {};
	          props[path] = {};
	          props[path][name] = target[name];
	          this.attr(props);
	        }
	      }
	    }
	
	    if (propertyCount > 0) {
	      this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);
	    }
	
	    return this;
	  }
	};
	var _default = Animatable;
	module.exports = _default;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	var Clip = __webpack_require__(18);
	
	var color = __webpack_require__(20);
	
	var _util = __webpack_require__(6);
	
	var isArrayLike = _util.isArrayLike;
	
	/**
	 * @module echarts/animation/Animator
	 */
	var arraySlice = Array.prototype.slice;
	
	function defaultGetter(target, key) {
	  return target[key];
	}
	
	function defaultSetter(target, key, value) {
	  target[key] = value;
	}
	/**
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} percent
	 * @return {number}
	 */
	
	
	function interpolateNumber(p0, p1, percent) {
	  return (p1 - p0) * percent + p0;
	}
	/**
	 * @param  {string} p0
	 * @param  {string} p1
	 * @param  {number} percent
	 * @return {string}
	 */
	
	
	function interpolateString(p0, p1, percent) {
	  return percent > 0.5 ? p1 : p0;
	}
	/**
	 * @param  {Array} p0
	 * @param  {Array} p1
	 * @param  {number} percent
	 * @param  {Array} out
	 * @param  {number} arrDim
	 */
	
	
	function interpolateArray(p0, p1, percent, out, arrDim) {
	  var len = p0.length;
	
	  if (arrDim == 1) {
	    for (var i = 0; i < len; i++) {
	      out[i] = interpolateNumber(p0[i], p1[i], percent);
	    }
	  } else {
	    var len2 = len && p0[0].length;
	
	    for (var i = 0; i < len; i++) {
	      for (var j = 0; j < len2; j++) {
	        out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);
	      }
	    }
	  }
	} // arr0 is source array, arr1 is target array.
	// Do some preprocess to avoid error happened when interpolating from arr0 to arr1
	
	
	function fillArr(arr0, arr1, arrDim) {
	  var arr0Len = arr0.length;
	  var arr1Len = arr1.length;
	
	  if (arr0Len !== arr1Len) {
	    // FIXME Not work for TypedArray
	    var isPreviousLarger = arr0Len > arr1Len;
	
	    if (isPreviousLarger) {
	      // Cut the previous
	      arr0.length = arr1Len;
	    } else {
	      // Fill the previous
	      for (var i = arr0Len; i < arr1Len; i++) {
	        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
	      }
	    }
	  } // Handling NaN value
	
	
	  var len2 = arr0[0] && arr0[0].length;
	
	  for (var i = 0; i < arr0.length; i++) {
	    if (arrDim === 1) {
	      if (isNaN(arr0[i])) {
	        arr0[i] = arr1[i];
	      }
	    } else {
	      for (var j = 0; j < len2; j++) {
	        if (isNaN(arr0[i][j])) {
	          arr0[i][j] = arr1[i][j];
	        }
	      }
	    }
	  }
	}
	/**
	 * @param  {Array} arr0
	 * @param  {Array} arr1
	 * @param  {number} arrDim
	 * @return {boolean}
	 */
	
	
	function isArraySame(arr0, arr1, arrDim) {
	  if (arr0 === arr1) {
	    return true;
	  }
	
	  var len = arr0.length;
	
	  if (len !== arr1.length) {
	    return false;
	  }
	
	  if (arrDim === 1) {
	    for (var i = 0; i < len; i++) {
	      if (arr0[i] !== arr1[i]) {
	        return false;
	      }
	    }
	  } else {
	    var len2 = arr0[0].length;
	
	    for (var i = 0; i < len; i++) {
	      for (var j = 0; j < len2; j++) {
	        if (arr0[i][j] !== arr1[i][j]) {
	          return false;
	        }
	      }
	    }
	  }
	
	  return true;
	}
	/**
	 * Catmull Rom interpolate array
	 * @param  {Array} p0
	 * @param  {Array} p1
	 * @param  {Array} p2
	 * @param  {Array} p3
	 * @param  {number} t
	 * @param  {number} t2
	 * @param  {number} t3
	 * @param  {Array} out
	 * @param  {number} arrDim
	 */
	
	
	function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {
	  var len = p0.length;
	
	  if (arrDim == 1) {
	    for (var i = 0; i < len; i++) {
	      out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);
	    }
	  } else {
	    var len2 = p0[0].length;
	
	    for (var i = 0; i < len; i++) {
	      for (var j = 0; j < len2; j++) {
	        out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);
	      }
	    }
	  }
	}
	/**
	 * Catmull Rom interpolate number
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} t
	 * @param  {number} t2
	 * @param  {number} t3
	 * @return {number}
	 */
	
	
	function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
	  var v0 = (p2 - p0) * 0.5;
	  var v1 = (p3 - p1) * 0.5;
	  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
	}
	
	function cloneValue(value) {
	  if (isArrayLike(value)) {
	    var len = value.length;
	
	    if (isArrayLike(value[0])) {
	      var ret = [];
	
	      for (var i = 0; i < len; i++) {
	        ret.push(arraySlice.call(value[i]));
	      }
	
	      return ret;
	    }
	
	    return arraySlice.call(value);
	  }
	
	  return value;
	}
	
	function rgba2String(rgba) {
	  rgba[0] = Math.floor(rgba[0]);
	  rgba[1] = Math.floor(rgba[1]);
	  rgba[2] = Math.floor(rgba[2]);
	  return 'rgba(' + rgba.join(',') + ')';
	}
	
	function getArrayDim(keyframes) {
	  var lastValue = keyframes[keyframes.length - 1].value;
	  return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;
	}
	
	function createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {
	  var getter = animator._getter;
	  var setter = animator._setter;
	  var useSpline = easing === 'spline';
	  var trackLen = keyframes.length;
	
	  if (!trackLen) {
	    return;
	  } // Guess data type
	
	
	  var firstVal = keyframes[0].value;
	  var isValueArray = isArrayLike(firstVal);
	  var isValueColor = false;
	  var isValueString = false; // For vertices morphing
	
	  var arrDim = isValueArray ? getArrayDim(keyframes) : 0;
	  var trackMaxTime; // Sort keyframe as ascending
	
	  keyframes.sort(function (a, b) {
	    return a.time - b.time;
	  });
	  trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe
	
	  var kfPercents = []; // Value of each keyframe
	
	  var kfValues = [];
	  var prevValue = keyframes[0].value;
	  var isAllValueEqual = true;
	
	  for (var i = 0; i < trackLen; i++) {
	    kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string
	
	    var value = keyframes[i].value; // Check if value is equal, deep check if value is array
	
	    if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {
	      isAllValueEqual = false;
	    }
	
	    prevValue = value; // Try converting a string to a color array
	
	    if (typeof value == 'string') {
	      var colorArray = color.parse(value);
	
	      if (colorArray) {
	        value = colorArray;
	        isValueColor = true;
	      } else {
	        isValueString = true;
	      }
	    }
	
	    kfValues.push(value);
	  }
	
	  if (!forceAnimate && isAllValueEqual) {
	    return;
	  }
	
	  var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value
	
	  for (var i = 0; i < trackLen - 1; i++) {
	    if (isValueArray) {
	      fillArr(kfValues[i], lastValue, arrDim);
	    } else {
	      if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
	        kfValues[i] = lastValue;
	      }
	    }
	  }
	
	  isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when
	  // animation playback is sequency
	
	  var lastFrame = 0;
	  var lastFramePercent = 0;
	  var start;
	  var w;
	  var p0;
	  var p1;
	  var p2;
	  var p3;
	
	  if (isValueColor) {
	    var rgba = [0, 0, 0, 0];
	  }
	
	  var onframe = function (target, percent) {
	    // Find the range keyframes
	    // kf1-----kf2---------current--------kf3
	    // find kf2 and kf3 and do interpolation
	    var frame; // In the easing function like elasticOut, percent may less than 0
	
	    if (percent < 0) {
	      frame = 0;
	    } else if (percent < lastFramePercent) {
	      // Start from next key
	      // PENDING start from lastFrame ?
	      start = Math.min(lastFrame + 1, trackLen - 1);
	
	      for (frame = start; frame >= 0; frame--) {
	        if (kfPercents[frame] <= percent) {
	          break;
	        }
	      } // PENDING really need to do this ?
	
	
	      frame = Math.min(frame, trackLen - 2);
	    } else {
	      for (frame = lastFrame; frame < trackLen; frame++) {
	        if (kfPercents[frame] > percent) {
	          break;
	        }
	      }
	
	      frame = Math.min(frame - 1, trackLen - 2);
	    }
	
	    lastFrame = frame;
	    lastFramePercent = percent;
	    var range = kfPercents[frame + 1] - kfPercents[frame];
	
	    if (range === 0) {
	      return;
	    } else {
	      w = (percent - kfPercents[frame]) / range;
	    }
	
	    if (useSpline) {
	      p1 = kfValues[frame];
	      p0 = kfValues[frame === 0 ? frame : frame - 1];
	      p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
	      p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];
	
	      if (isValueArray) {
	        catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);
	      } else {
	        var value;
	
	        if (isValueColor) {
	          value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);
	          value = rgba2String(rgba);
	        } else if (isValueString) {
	          // String is step(0.5)
	          return interpolateString(p1, p2, w);
	        } else {
	          value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);
	        }
	
	        setter(target, propName, value);
	      }
	    } else {
	      if (isValueArray) {
	        interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);
	      } else {
	        var value;
	
	        if (isValueColor) {
	          interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);
	          value = rgba2String(rgba);
	        } else if (isValueString) {
	          // String is step(0.5)
	          return interpolateString(kfValues[frame], kfValues[frame + 1], w);
	        } else {
	          value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
	        }
	
	        setter(target, propName, value);
	      }
	    }
	  };
	
	  var clip = new Clip({
	    target: animator._target,
	    life: trackMaxTime,
	    loop: animator._loop,
	    delay: animator._delay,
	    onframe: onframe,
	    ondestroy: oneTrackDone
	  });
	
	  if (easing && easing !== 'spline') {
	    clip.easing = easing;
	  }
	
	  return clip;
	}
	/**
	 * @alias module:zrender/animation/Animator
	 * @constructor
	 * @param {Object} target
	 * @param {boolean} loop
	 * @param {Function} getter
	 * @param {Function} setter
	 */
	
	
	var Animator = function (target, loop, getter, setter) {
	  this._tracks = {};
	  this._target = target;
	  this._loop = loop || false;
	  this._getter = getter || defaultGetter;
	  this._setter = setter || defaultSetter;
	  this._clipCount = 0;
	  this._delay = 0;
	  this._doneList = [];
	  this._onframeList = [];
	  this._clipList = [];
	};
	
	Animator.prototype = {
	  /**
	   * 设置动画关键帧
	   * @param  {number} time 关键帧时间，单位是ms
	   * @param  {Object} props 关键帧的属性值，key-value表示
	   * @return {module:zrender/animation/Animator}
	   */
	  when: function (time
	  /* ms */
	  , props) {
	    var tracks = this._tracks;
	
	    for (var propName in props) {
	      if (!props.hasOwnProperty(propName)) {
	        continue;
	      }
	
	      if (!tracks[propName]) {
	        tracks[propName] = []; // Invalid value
	
	        var value = this._getter(this._target, propName);
	
	        if (value == null) {
	          // zrLog('Invalid property ' + propName);
	          continue;
	        } // If time is 0
	        //  Then props is given initialize value
	        // Else
	        //  Initialize value from current prop value
	
	
	        if (time !== 0) {
	          tracks[propName].push({
	            time: 0,
	            value: cloneValue(value)
	          });
	        }
	      }
	
	      tracks[propName].push({
	        time: time,
	        value: props[propName]
	      });
	    }
	
	    return this;
	  },
	
	  /**
	   * 添加动画每一帧的回调函数
	   * @param  {Function} callback
	   * @return {module:zrender/animation/Animator}
	   */
	  during: function (callback) {
	    this._onframeList.push(callback);
	
	    return this;
	  },
	  pause: function () {
	    for (var i = 0; i < this._clipList.length; i++) {
	      this._clipList[i].pause();
	    }
	
	    this._paused = true;
	  },
	  resume: function () {
	    for (var i = 0; i < this._clipList.length; i++) {
	      this._clipList[i].resume();
	    }
	
	    this._paused = false;
	  },
	  isPaused: function () {
	    return !!this._paused;
	  },
	  _doneCallback: function () {
	    // Clear all tracks
	    this._tracks = {}; // Clear all clips
	
	    this._clipList.length = 0;
	    var doneList = this._doneList;
	    var len = doneList.length;
	
	    for (var i = 0; i < len; i++) {
	      doneList[i].call(this);
	    }
	  },
	
	  /**
	   * 开始执行动画
	   * @param  {string|Function} [easing]
	   *         动画缓动函数，详见{@link module:zrender/animation/easing}
	   * @param  {boolean} forceAnimate
	   * @return {module:zrender/animation/Animator}
	   */
	  start: function (easing, forceAnimate) {
	    var self = this;
	    var clipCount = 0;
	
	    var oneTrackDone = function () {
	      clipCount--;
	
	      if (!clipCount) {
	        self._doneCallback();
	      }
	    };
	
	    var lastClip;
	
	    for (var propName in this._tracks) {
	      if (!this._tracks.hasOwnProperty(propName)) {
	        continue;
	      }
	
	      var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);
	
	      if (clip) {
	        this._clipList.push(clip);
	
	        clipCount++; // If start after added to animation
	
	        if (this.animation) {
	          this.animation.addClip(clip);
	        }
	
	        lastClip = clip;
	      }
	    } // Add during callback on the last clip
	
	
	    if (lastClip) {
	      var oldOnFrame = lastClip.onframe;
	
	      lastClip.onframe = function (target, percent) {
	        oldOnFrame(target, percent);
	
	        for (var i = 0; i < self._onframeList.length; i++) {
	          self._onframeList[i](target, percent);
	        }
	      };
	    } // This optimization will help the case that in the upper application
	    // the view may be refreshed frequently, where animation will be
	    // called repeatly but nothing changed.
	
	
	    if (!clipCount) {
	      this._doneCallback();
	    }
	
	    return this;
	  },
	
	  /**
	   * 停止动画
	   * @param {boolean} forwardToLast If move to last frame before stop
	   */
	  stop: function (forwardToLast) {
	    var clipList = this._clipList;
	    var animation = this.animation;
	
	    for (var i = 0; i < clipList.length; i++) {
	      var clip = clipList[i];
	
	      if (forwardToLast) {
	        // Move to last frame before stop
	        clip.onframe(this._target, 1);
	      }
	
	      animation && animation.removeClip(clip);
	    }
	
	    clipList.length = 0;
	  },
	
	  /**
	   * 设置动画延迟开始的时间
	   * @param  {number} time 单位ms
	   * @return {module:zrender/animation/Animator}
	   */
	  delay: function (time) {
	    this._delay = time;
	    return this;
	  },
	
	  /**
	   * 添加动画结束的回调
	   * @param  {Function} cb
	   * @return {module:zrender/animation/Animator}
	   */
	  done: function (cb) {
	    if (cb) {
	      this._doneList.push(cb);
	    }
	
	    return this;
	  },
	
	  /**
	   * @return {Array.<module:zrender/animation/Clip>}
	   */
	  getClips: function () {
	    return this._clipList;
	  }
	};
	var _default = Animator;
	module.exports = _default;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	var easingFuncs = __webpack_require__(19);
	
	/**
	 * 动画主控制器
	 * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
	 * @config life(1000) 动画时长
	 * @config delay(0) 动画延迟时间
	 * @config loop(true)
	 * @config gap(0) 循环的间隔时间
	 * @config onframe
	 * @config easing(optional)
	 * @config ondestroy(optional)
	 * @config onrestart(optional)
	 *
	 * TODO pause
	 */
	function Clip(options) {
	  this._target = options.target; // 生命周期
	
	  this._life = options.life || 1000; // 延时
	
	  this._delay = options.delay || 0; // 开始时间
	  // this._startTime = new Date().getTime() + this._delay;// 单位毫秒
	
	  this._initialized = false; // 是否循环
	
	  this.loop = options.loop == null ? false : options.loop;
	  this.gap = options.gap || 0;
	  this.easing = options.easing || 'Linear';
	  this.onframe = options.onframe;
	  this.ondestroy = options.ondestroy;
	  this.onrestart = options.onrestart;
	  this._pausedTime = 0;
	  this._paused = false;
	}
	
	Clip.prototype = {
	  constructor: Clip,
	  step: function (globalTime, deltaTime) {
	    // Set startTime on first step, or _startTime may has milleseconds different between clips
	    // PENDING
	    if (!this._initialized) {
	      this._startTime = globalTime + this._delay;
	      this._initialized = true;
	    }
	
	    if (this._paused) {
	      this._pausedTime += deltaTime;
	      return;
	    }
	
	    var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // 还没开始
	
	    if (percent < 0) {
	      return;
	    }
	
	    percent = Math.min(percent, 1);
	    var easing = this.easing;
	    var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;
	    var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;
	    this.fire('frame', schedule); // 结束
	
	    if (percent == 1) {
	      if (this.loop) {
	        this.restart(globalTime); // 重新开始周期
	        // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件
	
	        return 'restart';
	      } // 动画完成将这个控制器标识为待删除
	      // 在Animation.update中进行批量删除
	
	
	      this._needsRemove = true;
	      return 'destroy';
	    }
	
	    return null;
	  },
	  restart: function (globalTime) {
	    var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;
	    this._startTime = globalTime - remainder + this.gap;
	    this._pausedTime = 0;
	    this._needsRemove = false;
	  },
	  fire: function (eventType, arg) {
	    eventType = 'on' + eventType;
	
	    if (this[eventType]) {
	      this[eventType](this._target, arg);
	    }
	  },
	  pause: function () {
	    this._paused = true;
	  },
	  resume: function () {
	    this._paused = false;
	  }
	};
	var _default = Clip;
	module.exports = _default;

/***/ }),
/* 19 */
/***/ (function(module, exports) {

	/**
	 * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
	 * @see http://sole.github.io/tween.js/examples/03_graphs.html
	 * @exports zrender/animation/easing
	 */
	var easing = {
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  linear: function (k) {
	    return k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quadraticIn: function (k) {
	    return k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quadraticOut: function (k) {
	    return k * (2 - k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quadraticInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return 0.5 * k * k;
	    }
	
	    return -0.5 * (--k * (k - 2) - 1);
	  },
	  // 三次方的缓动（t^3）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  cubicIn: function (k) {
	    return k * k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  cubicOut: function (k) {
	    return --k * k * k + 1;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  cubicInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return 0.5 * k * k * k;
	    }
	
	    return 0.5 * ((k -= 2) * k * k + 2);
	  },
	  // 四次方的缓动（t^4）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quarticIn: function (k) {
	    return k * k * k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quarticOut: function (k) {
	    return 1 - --k * k * k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quarticInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return 0.5 * k * k * k * k;
	    }
	
	    return -0.5 * ((k -= 2) * k * k * k - 2);
	  },
	  // 五次方的缓动（t^5）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quinticIn: function (k) {
	    return k * k * k * k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quinticOut: function (k) {
	    return --k * k * k * k * k + 1;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quinticInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return 0.5 * k * k * k * k * k;
	    }
	
	    return 0.5 * ((k -= 2) * k * k * k * k + 2);
	  },
	  // 正弦曲线的缓动（sin(t)）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  sinusoidalIn: function (k) {
	    return 1 - Math.cos(k * Math.PI / 2);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  sinusoidalOut: function (k) {
	    return Math.sin(k * Math.PI / 2);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  sinusoidalInOut: function (k) {
	    return 0.5 * (1 - Math.cos(Math.PI * k));
	  },
	  // 指数曲线的缓动（2^t）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  exponentialIn: function (k) {
	    return k === 0 ? 0 : Math.pow(1024, k - 1);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  exponentialOut: function (k) {
	    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  exponentialInOut: function (k) {
	    if (k === 0) {
	      return 0;
	    }
	
	    if (k === 1) {
	      return 1;
	    }
	
	    if ((k *= 2) < 1) {
	      return 0.5 * Math.pow(1024, k - 1);
	    }
	
	    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
	  },
	  // 圆形曲线的缓动（sqrt(1-t^2)）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  circularIn: function (k) {
	    return 1 - Math.sqrt(1 - k * k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  circularOut: function (k) {
	    return Math.sqrt(1 - --k * k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  circularInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return -0.5 * (Math.sqrt(1 - k * k) - 1);
	    }
	
	    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
	  },
	  // 创建类似于弹簧在停止前来回振荡的动画
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  elasticIn: function (k) {
	    var s;
	    var a = 0.1;
	    var p = 0.4;
	
	    if (k === 0) {
	      return 0;
	    }
	
	    if (k === 1) {
	      return 1;
	    }
	
	    if (!a || a < 1) {
	      a = 1;
	      s = p / 4;
	    } else {
	      s = p * Math.asin(1 / a) / (2 * Math.PI);
	    }
	
	    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  elasticOut: function (k) {
	    var s;
	    var a = 0.1;
	    var p = 0.4;
	
	    if (k === 0) {
	      return 0;
	    }
	
	    if (k === 1) {
	      return 1;
	    }
	
	    if (!a || a < 1) {
	      a = 1;
	      s = p / 4;
	    } else {
	      s = p * Math.asin(1 / a) / (2 * Math.PI);
	    }
	
	    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  elasticInOut: function (k) {
	    var s;
	    var a = 0.1;
	    var p = 0.4;
	
	    if (k === 0) {
	      return 0;
	    }
	
	    if (k === 1) {
	      return 1;
	    }
	
	    if (!a || a < 1) {
	      a = 1;
	      s = p / 4;
	    } else {
	      s = p * Math.asin(1 / a) / (2 * Math.PI);
	    }
	
	    if ((k *= 2) < 1) {
	      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
	    }
	
	    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
	  },
	  // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  backIn: function (k) {
	    var s = 1.70158;
	    return k * k * ((s + 1) * k - s);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  backOut: function (k) {
	    var s = 1.70158;
	    return --k * k * ((s + 1) * k + s) + 1;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  backInOut: function (k) {
	    var s = 1.70158 * 1.525;
	
	    if ((k *= 2) < 1) {
	      return 0.5 * (k * k * ((s + 1) * k - s));
	    }
	
	    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
	  },
	  // 创建弹跳效果
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  bounceIn: function (k) {
	    return 1 - easing.bounceOut(1 - k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  bounceOut: function (k) {
	    if (k < 1 / 2.75) {
	      return 7.5625 * k * k;
	    } else if (k < 2 / 2.75) {
	      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
	    } else if (k < 2.5 / 2.75) {
	      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
	    } else {
	      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
	    }
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  bounceInOut: function (k) {
	    if (k < 0.5) {
	      return easing.bounceIn(k * 2) * 0.5;
	    }
	
	    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
	  }
	};
	var _default = easing;
	module.exports = _default;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	var LRU = __webpack_require__(21);
	
	var kCSSColorTable = {
	  'transparent': [0, 0, 0, 0],
	  'aliceblue': [240, 248, 255, 1],
	  'antiquewhite': [250, 235, 215, 1],
	  'aqua': [0, 255, 255, 1],
	  'aquamarine': [127, 255, 212, 1],
	  'azure': [240, 255, 255, 1],
	  'beige': [245, 245, 220, 1],
	  'bisque': [255, 228, 196, 1],
	  'black': [0, 0, 0, 1],
	  'blanchedalmond': [255, 235, 205, 1],
	  'blue': [0, 0, 255, 1],
	  'blueviolet': [138, 43, 226, 1],
	  'brown': [165, 42, 42, 1],
	  'burlywood': [222, 184, 135, 1],
	  'cadetblue': [95, 158, 160, 1],
	  'chartreuse': [127, 255, 0, 1],
	  'chocolate': [210, 105, 30, 1],
	  'coral': [255, 127, 80, 1],
	  'cornflowerblue': [100, 149, 237, 1],
	  'cornsilk': [255, 248, 220, 1],
	  'crimson': [220, 20, 60, 1],
	  'cyan': [0, 255, 255, 1],
	  'darkblue': [0, 0, 139, 1],
	  'darkcyan': [0, 139, 139, 1],
	  'darkgoldenrod': [184, 134, 11, 1],
	  'darkgray': [169, 169, 169, 1],
	  'darkgreen': [0, 100, 0, 1],
	  'darkgrey': [169, 169, 169, 1],
	  'darkkhaki': [189, 183, 107, 1],
	  'darkmagenta': [139, 0, 139, 1],
	  'darkolivegreen': [85, 107, 47, 1],
	  'darkorange': [255, 140, 0, 1],
	  'darkorchid': [153, 50, 204, 1],
	  'darkred': [139, 0, 0, 1],
	  'darksalmon': [233, 150, 122, 1],
	  'darkseagreen': [143, 188, 143, 1],
	  'darkslateblue': [72, 61, 139, 1],
	  'darkslategray': [47, 79, 79, 1],
	  'darkslategrey': [47, 79, 79, 1],
	  'darkturquoise': [0, 206, 209, 1],
	  'darkviolet': [148, 0, 211, 1],
	  'deeppink': [255, 20, 147, 1],
	  'deepskyblue': [0, 191, 255, 1],
	  'dimgray': [105, 105, 105, 1],
	  'dimgrey': [105, 105, 105, 1],
	  'dodgerblue': [30, 144, 255, 1],
	  'firebrick': [178, 34, 34, 1],
	  'floralwhite': [255, 250, 240, 1],
	  'forestgreen': [34, 139, 34, 1],
	  'fuchsia': [255, 0, 255, 1],
	  'gainsboro': [220, 220, 220, 1],
	  'ghostwhite': [248, 248, 255, 1],
	  'gold': [255, 215, 0, 1],
	  'goldenrod': [218, 165, 32, 1],
	  'gray': [128, 128, 128, 1],
	  'green': [0, 128, 0, 1],
	  'greenyellow': [173, 255, 47, 1],
	  'grey': [128, 128, 128, 1],
	  'honeydew': [240, 255, 240, 1],
	  'hotpink': [255, 105, 180, 1],
	  'indianred': [205, 92, 92, 1],
	  'indigo': [75, 0, 130, 1],
	  'ivory': [255, 255, 240, 1],
	  'khaki': [240, 230, 140, 1],
	  'lavender': [230, 230, 250, 1],
	  'lavenderblush': [255, 240, 245, 1],
	  'lawngreen': [124, 252, 0, 1],
	  'lemonchiffon': [255, 250, 205, 1],
	  'lightblue': [173, 216, 230, 1],
	  'lightcoral': [240, 128, 128, 1],
	  'lightcyan': [224, 255, 255, 1],
	  'lightgoldenrodyellow': [250, 250, 210, 1],
	  'lightgray': [211, 211, 211, 1],
	  'lightgreen': [144, 238, 144, 1],
	  'lightgrey': [211, 211, 211, 1],
	  'lightpink': [255, 182, 193, 1],
	  'lightsalmon': [255, 160, 122, 1],
	  'lightseagreen': [32, 178, 170, 1],
	  'lightskyblue': [135, 206, 250, 1],
	  'lightslategray': [119, 136, 153, 1],
	  'lightslategrey': [119, 136, 153, 1],
	  'lightsteelblue': [176, 196, 222, 1],
	  'lightyellow': [255, 255, 224, 1],
	  'lime': [0, 255, 0, 1],
	  'limegreen': [50, 205, 50, 1],
	  'linen': [250, 240, 230, 1],
	  'magenta': [255, 0, 255, 1],
	  'maroon': [128, 0, 0, 1],
	  'mediumaquamarine': [102, 205, 170, 1],
	  'mediumblue': [0, 0, 205, 1],
	  'mediumorchid': [186, 85, 211, 1],
	  'mediumpurple': [147, 112, 219, 1],
	  'mediumseagreen': [60, 179, 113, 1],
	  'mediumslateblue': [123, 104, 238, 1],
	  'mediumspringgreen': [0, 250, 154, 1],
	  'mediumturquoise': [72, 209, 204, 1],
	  'mediumvioletred': [199, 21, 133, 1],
	  'midnightblue': [25, 25, 112, 1],
	  'mintcream': [245, 255, 250, 1],
	  'mistyrose': [255, 228, 225, 1],
	  'moccasin': [255, 228, 181, 1],
	  'navajowhite': [255, 222, 173, 1],
	  'navy': [0, 0, 128, 1],
	  'oldlace': [253, 245, 230, 1],
	  'olive': [128, 128, 0, 1],
	  'olivedrab': [107, 142, 35, 1],
	  'orange': [255, 165, 0, 1],
	  'orangered': [255, 69, 0, 1],
	  'orchid': [218, 112, 214, 1],
	  'palegoldenrod': [238, 232, 170, 1],
	  'palegreen': [152, 251, 152, 1],
	  'paleturquoise': [175, 238, 238, 1],
	  'palevioletred': [219, 112, 147, 1],
	  'papayawhip': [255, 239, 213, 1],
	  'peachpuff': [255, 218, 185, 1],
	  'peru': [205, 133, 63, 1],
	  'pink': [255, 192, 203, 1],
	  'plum': [221, 160, 221, 1],
	  'powderblue': [176, 224, 230, 1],
	  'purple': [128, 0, 128, 1],
	  'red': [255, 0, 0, 1],
	  'rosybrown': [188, 143, 143, 1],
	  'royalblue': [65, 105, 225, 1],
	  'saddlebrown': [139, 69, 19, 1],
	  'salmon': [250, 128, 114, 1],
	  'sandybrown': [244, 164, 96, 1],
	  'seagreen': [46, 139, 87, 1],
	  'seashell': [255, 245, 238, 1],
	  'sienna': [160, 82, 45, 1],
	  'silver': [192, 192, 192, 1],
	  'skyblue': [135, 206, 235, 1],
	  'slateblue': [106, 90, 205, 1],
	  'slategray': [112, 128, 144, 1],
	  'slategrey': [112, 128, 144, 1],
	  'snow': [255, 250, 250, 1],
	  'springgreen': [0, 255, 127, 1],
	  'steelblue': [70, 130, 180, 1],
	  'tan': [210, 180, 140, 1],
	  'teal': [0, 128, 128, 1],
	  'thistle': [216, 191, 216, 1],
	  'tomato': [255, 99, 71, 1],
	  'turquoise': [64, 224, 208, 1],
	  'violet': [238, 130, 238, 1],
	  'wheat': [245, 222, 179, 1],
	  'white': [255, 255, 255, 1],
	  'whitesmoke': [245, 245, 245, 1],
	  'yellow': [255, 255, 0, 1],
	  'yellowgreen': [154, 205, 50, 1]
	};
	
	function clampCssByte(i) {
	  // Clamp to integer 0 .. 255.
	  i = Math.round(i); // Seems to be what Chrome does (vs truncation).
	
	  return i < 0 ? 0 : i > 255 ? 255 : i;
	}
	
	function clampCssAngle(i) {
	  // Clamp to integer 0 .. 360.
	  i = Math.round(i); // Seems to be what Chrome does (vs truncation).
	
	  return i < 0 ? 0 : i > 360 ? 360 : i;
	}
	
	function clampCssFloat(f) {
	  // Clamp to float 0.0 .. 1.0.
	  return f < 0 ? 0 : f > 1 ? 1 : f;
	}
	
	function parseCssInt(str) {
	  // int or percentage.
	  if (str.length && str.charAt(str.length - 1) === '%') {
	    return clampCssByte(parseFloat(str) / 100 * 255);
	  }
	
	  return clampCssByte(parseInt(str, 10));
	}
	
	function parseCssFloat(str) {
	  // float or percentage.
	  if (str.length && str.charAt(str.length - 1) === '%') {
	    return clampCssFloat(parseFloat(str) / 100);
	  }
	
	  return clampCssFloat(parseFloat(str));
	}
	
	function cssHueToRgb(m1, m2, h) {
	  if (h < 0) {
	    h += 1;
	  } else if (h > 1) {
	    h -= 1;
	  }
	
	  if (h * 6 < 1) {
	    return m1 + (m2 - m1) * h * 6;
	  }
	
	  if (h * 2 < 1) {
	    return m2;
	  }
	
	  if (h * 3 < 2) {
	    return m1 + (m2 - m1) * (2 / 3 - h) * 6;
	  }
	
	  return m1;
	}
	
	function lerpNumber(a, b, p) {
	  return a + (b - a) * p;
	}
	
	function setRgba(out, r, g, b, a) {
	  out[0] = r;
	  out[1] = g;
	  out[2] = b;
	  out[3] = a;
	  return out;
	}
	
	function copyRgba(out, a) {
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  return out;
	}
	
	var colorCache = new LRU(20);
	var lastRemovedArr = null;
	
	function putToCache(colorStr, rgbaArr) {
	  // Reuse removed array
	  if (lastRemovedArr) {
	    copyRgba(lastRemovedArr, rgbaArr);
	  }
	
	  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
	}
	/**
	 * @param {string} colorStr
	 * @param {Array.<number>} out
	 * @return {Array.<number>}
	 * @memberOf module:zrender/util/color
	 */
	
	
	function parse(colorStr, rgbaArr) {
	  if (!colorStr) {
	    return;
	  }
	
	  rgbaArr = rgbaArr || [];
	  var cached = colorCache.get(colorStr);
	
	  if (cached) {
	    return copyRgba(rgbaArr, cached);
	  } // colorStr may be not string
	
	
	  colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.
	
	  var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.
	
	  if (str in kCSSColorTable) {
	    copyRgba(rgbaArr, kCSSColorTable[str]);
	    putToCache(colorStr, rgbaArr);
	    return rgbaArr;
	  } // #abc and #abc123 syntax.
	
	
	  if (str.charAt(0) === '#') {
	    if (str.length === 4) {
	      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.
	
	      if (!(iv >= 0 && iv <= 0xfff)) {
	        setRgba(rgbaArr, 0, 0, 0, 1);
	        return; // Covers NaN.
	      }
	
	      setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);
	      putToCache(colorStr, rgbaArr);
	      return rgbaArr;
	    } else if (str.length === 7) {
	      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.
	
	      if (!(iv >= 0 && iv <= 0xffffff)) {
	        setRgba(rgbaArr, 0, 0, 0, 1);
	        return; // Covers NaN.
	      }
	
	      setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);
	      putToCache(colorStr, rgbaArr);
	      return rgbaArr;
	    }
	
	    return;
	  }
	
	  var op = str.indexOf('('),
	      ep = str.indexOf(')');
	
	  if (op !== -1 && ep + 1 === str.length) {
	    var fname = str.substr(0, op);
	    var params = str.substr(op + 1, ep - (op + 1)).split(',');
	    var alpha = 1; // To allow case fallthrough.
	
	    switch (fname) {
	      case 'rgba':
	        if (params.length !== 4) {
	          setRgba(rgbaArr, 0, 0, 0, 1);
	          return;
	        }
	
	        alpha = parseCssFloat(params.pop());
	      // jshint ignore:line
	      // Fall through.
	
	      case 'rgb':
	        if (params.length !== 3) {
	          setRgba(rgbaArr, 0, 0, 0, 1);
	          return;
	        }
	
	        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);
	        putToCache(colorStr, rgbaArr);
	        return rgbaArr;
	
	      case 'hsla':
	        if (params.length !== 4) {
	          setRgba(rgbaArr, 0, 0, 0, 1);
	          return;
	        }
	
	        params[3] = parseCssFloat(params[3]);
	        hsla2rgba(params, rgbaArr);
	        putToCache(colorStr, rgbaArr);
	        return rgbaArr;
	
	      case 'hsl':
	        if (params.length !== 3) {
	          setRgba(rgbaArr, 0, 0, 0, 1);
	          return;
	        }
	
	        hsla2rgba(params, rgbaArr);
	        putToCache(colorStr, rgbaArr);
	        return rgbaArr;
	
	      default:
	        return;
	    }
	  }
	
	  setRgba(rgbaArr, 0, 0, 0, 1);
	  return;
	}
	/**
	 * @param {Array.<number>} hsla
	 * @param {Array.<number>} rgba
	 * @return {Array.<number>} rgba
	 */
	
	
	function hsla2rgba(hsla, rgba) {
	  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1
	  // NOTE(deanm): According to the CSS spec s/l should only be
	  // percentages, but we don't bother and let float or percentage.
	
	  var s = parseCssFloat(hsla[1]);
	  var l = parseCssFloat(hsla[2]);
	  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
	  var m1 = l * 2 - m2;
	  rgba = rgba || [];
	  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);
	
	  if (hsla.length === 4) {
	    rgba[3] = hsla[3];
	  }
	
	  return rgba;
	}
	/**
	 * @param {Array.<number>} rgba
	 * @return {Array.<number>} hsla
	 */
	
	
	function rgba2hsla(rgba) {
	  if (!rgba) {
	    return;
	  } // RGB from 0 to 255
	
	
	  var R = rgba[0] / 255;
	  var G = rgba[1] / 255;
	  var B = rgba[2] / 255;
	  var vMin = Math.min(R, G, B); // Min. value of RGB
	
	  var vMax = Math.max(R, G, B); // Max. value of RGB
	
	  var delta = vMax - vMin; // Delta RGB value
	
	  var L = (vMax + vMin) / 2;
	  var H;
	  var S; // HSL results from 0 to 1
	
	  if (delta === 0) {
	    H = 0;
	    S = 0;
	  } else {
	    if (L < 0.5) {
	      S = delta / (vMax + vMin);
	    } else {
	      S = delta / (2 - vMax - vMin);
	    }
	
	    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
	    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
	    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;
	
	    if (R === vMax) {
	      H = deltaB - deltaG;
	    } else if (G === vMax) {
	      H = 1 / 3 + deltaR - deltaB;
	    } else if (B === vMax) {
	      H = 2 / 3 + deltaG - deltaR;
	    }
	
	    if (H < 0) {
	      H += 1;
	    }
	
	    if (H > 1) {
	      H -= 1;
	    }
	  }
	
	  var hsla = [H * 360, S, L];
	
	  if (rgba[3] != null) {
	    hsla.push(rgba[3]);
	  }
	
	  return hsla;
	}
	/**
	 * @param {string} color
	 * @param {number} level
	 * @return {string}
	 * @memberOf module:zrender/util/color
	 */
	
	
	function lift(color, level) {
	  var colorArr = parse(color);
	
	  if (colorArr) {
	    for (var i = 0; i < 3; i++) {
	      if (level < 0) {
	        colorArr[i] = colorArr[i] * (1 - level) | 0;
	      } else {
	        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;
	      }
	    }
	
	    return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
	  }
	}
	/**
	 * @param {string} color
	 * @return {string}
	 * @memberOf module:zrender/util/color
	 */
	
	
	function toHex(color) {
	  var colorArr = parse(color);
	
	  if (colorArr) {
	    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
	  }
	}
	/**
	 * Map value to color. Faster than lerp methods because color is represented by rgba array.
	 * @param {number} normalizedValue A float between 0 and 1.
	 * @param {Array.<Array.<number>>} colors List of rgba color array
	 * @param {Array.<number>} [out] Mapped gba color array
	 * @return {Array.<number>} will be null/undefined if input illegal.
	 */
	
	
	function fastLerp(normalizedValue, colors, out) {
	  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
	    return;
	  }
	
	  out = out || [];
	  var value = normalizedValue * (colors.length - 1);
	  var leftIndex = Math.floor(value);
	  var rightIndex = Math.ceil(value);
	  var leftColor = colors[leftIndex];
	  var rightColor = colors[rightIndex];
	  var dv = value - leftIndex;
	  out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
	  out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
	  out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
	  out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
	  return out;
	}
	/**
	 * @deprecated
	 */
	
	
	var fastMapToColor = fastLerp;
	/**
	 * @param {number} normalizedValue A float between 0 and 1.
	 * @param {Array.<string>} colors Color list.
	 * @param {boolean=} fullOutput Default false.
	 * @return {(string|Object)} Result color. If fullOutput,
	 *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
	 * @memberOf module:zrender/util/color
	 */
	
	function lerp(normalizedValue, colors, fullOutput) {
	  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
	    return;
	  }
	
	  var value = normalizedValue * (colors.length - 1);
	  var leftIndex = Math.floor(value);
	  var rightIndex = Math.ceil(value);
	  var leftColor = parse(colors[leftIndex]);
	  var rightColor = parse(colors[rightIndex]);
	  var dv = value - leftIndex;
	  var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');
	  return fullOutput ? {
	    color: color,
	    leftIndex: leftIndex,
	    rightIndex: rightIndex,
	    value: value
	  } : color;
	}
	/**
	 * @deprecated
	 */
	
	
	var mapToColor = lerp;
	/**
	 * @param {string} color
	 * @param {number=} h 0 ~ 360, ignore when null.
	 * @param {number=} s 0 ~ 1, ignore when null.
	 * @param {number=} l 0 ~ 1, ignore when null.
	 * @return {string} Color string in rgba format.
	 * @memberOf module:zrender/util/color
	 */
	
	function modifyHSL(color, h, s, l) {
	  color = parse(color);
	
	  if (color) {
	    color = rgba2hsla(color);
	    h != null && (color[0] = clampCssAngle(h));
	    s != null && (color[1] = parseCssFloat(s));
	    l != null && (color[2] = parseCssFloat(l));
	    return stringify(hsla2rgba(color), 'rgba');
	  }
	}
	/**
	 * @param {string} color
	 * @param {number=} alpha 0 ~ 1
	 * @return {string} Color string in rgba format.
	 * @memberOf module:zrender/util/color
	 */
	
	
	function modifyAlpha(color, alpha) {
	  color = parse(color);
	
	  if (color && alpha != null) {
	    color[3] = clampCssFloat(alpha);
	    return stringify(color, 'rgba');
	  }
	}
	/**
	 * @param {Array.<number>} arrColor like [12,33,44,0.4]
	 * @param {string} type 'rgba', 'hsva', ...
	 * @return {string} Result color. (If input illegal, return undefined).
	 */
	
	
	function stringify(arrColor, type) {
	  if (!arrColor || !arrColor.length) {
	    return;
	  }
	
	  var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];
	
	  if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
	    colorStr += ',' + arrColor[3];
	  }
	
	  return type + '(' + colorStr + ')';
	}
	
	exports.parse = parse;
	exports.lift = lift;
	exports.toHex = toHex;
	exports.fastLerp = fastLerp;
	exports.fastMapToColor = fastMapToColor;
	exports.lerp = lerp;
	exports.mapToColor = mapToColor;
	exports.modifyHSL = modifyHSL;
	exports.modifyAlpha = modifyAlpha;
	exports.stringify = stringify;

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	// Simple LRU cache use doubly linked list
	// @module zrender/core/LRU
	
	/**
	 * Simple double linked list. Compared with array, it has O(1) remove operation.
	 * @constructor
	 */
	var LinkedList = function () {
	  /**
	   * @type {module:zrender/core/LRU~Entry}
	   */
	  this.head = null;
	  /**
	   * @type {module:zrender/core/LRU~Entry}
	   */
	
	  this.tail = null;
	  this._len = 0;
	};
	
	var linkedListProto = LinkedList.prototype;
	/**
	 * Insert a new value at the tail
	 * @param  {} val
	 * @return {module:zrender/core/LRU~Entry}
	 */
	
	linkedListProto.insert = function (val) {
	  var entry = new Entry(val);
	  this.insertEntry(entry);
	  return entry;
	};
	/**
	 * Insert an entry at the tail
	 * @param  {module:zrender/core/LRU~Entry} entry
	 */
	
	
	linkedListProto.insertEntry = function (entry) {
	  if (!this.head) {
	    this.head = this.tail = entry;
	  } else {
	    this.tail.next = entry;
	    entry.prev = this.tail;
	    entry.next = null;
	    this.tail = entry;
	  }
	
	  this._len++;
	};
	/**
	 * Remove entry.
	 * @param  {module:zrender/core/LRU~Entry} entry
	 */
	
	
	linkedListProto.remove = function (entry) {
	  var prev = entry.prev;
	  var next = entry.next;
	
	  if (prev) {
	    prev.next = next;
	  } else {
	    // Is head
	    this.head = next;
	  }
	
	  if (next) {
	    next.prev = prev;
	  } else {
	    // Is tail
	    this.tail = prev;
	  }
	
	  entry.next = entry.prev = null;
	  this._len--;
	};
	/**
	 * @return {number}
	 */
	
	
	linkedListProto.len = function () {
	  return this._len;
	};
	/**
	 * Clear list
	 */
	
	
	linkedListProto.clear = function () {
	  this.head = this.tail = null;
	  this._len = 0;
	};
	/**
	 * @constructor
	 * @param {} val
	 */
	
	
	var Entry = function (val) {
	  /**
	   * @type {}
	   */
	  this.value = val;
	  /**
	   * @type {module:zrender/core/LRU~Entry}
	   */
	
	  this.next;
	  /**
	   * @type {module:zrender/core/LRU~Entry}
	   */
	
	  this.prev;
	};
	/**
	 * LRU Cache
	 * @constructor
	 * @alias module:zrender/core/LRU
	 */
	
	
	var LRU = function (maxSize) {
	  this._list = new LinkedList();
	  this._map = {};
	  this._maxSize = maxSize || 10;
	  this._lastRemovedEntry = null;
	};
	
	var LRUProto = LRU.prototype;
	/**
	 * @param  {string} key
	 * @param  {} value
	 * @return {} Removed value
	 */
	
	LRUProto.put = function (key, value) {
	  var list = this._list;
	  var map = this._map;
	  var removed = null;
	
	  if (map[key] == null) {
	    var len = list.len(); // Reuse last removed entry
	
	    var entry = this._lastRemovedEntry;
	
	    if (len >= this._maxSize && len > 0) {
	      // Remove the least recently used
	      var leastUsedEntry = list.head;
	      list.remove(leastUsedEntry);
	      delete map[leastUsedEntry.key];
	      removed = leastUsedEntry.value;
	      this._lastRemovedEntry = leastUsedEntry;
	    }
	
	    if (entry) {
	      entry.value = value;
	    } else {
	      entry = new Entry(value);
	    }
	
	    entry.key = key;
	    list.insertEntry(entry);
	    map[key] = entry;
	  }
	
	  return removed;
	};
	/**
	 * @param  {string} key
	 * @return {}
	 */
	
	
	LRUProto.get = function (key) {
	  var entry = this._map[key];
	  var list = this._list;
	
	  if (entry != null) {
	    // Put the latest used entry in the tail
	    if (entry !== list.tail) {
	      list.remove(entry);
	      list.insertEntry(entry);
	    }
	
	    return entry.value;
	  }
	};
	/**
	 * Clear the cache
	 */
	
	
	LRUProto.clear = function () {
	  this._list.clear();
	
	  this._map = {};
	};
	
	var _default = LRU;
	module.exports = _default;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	var _config = __webpack_require__(23);
	
	var debugMode = _config.debugMode;
	
	var log = function () {};
	
	if (debugMode === 1) {
	  log = function () {
	    for (var k in arguments) {
	      throw new Error(arguments[k]);
	    }
	  };
	} else if (debugMode > 1) {
	  log = function () {
	    for (var k in arguments) {
	      console.log(arguments[k]);
	    }
	  };
	}
	
	var _default = log;
	module.exports = _default;

/***/ }),
/* 23 */
/***/ (function(module, exports) {

	var dpr = 1; // If in browser environment
	
	if (typeof window !== 'undefined') {
	  dpr = Math.max(window.devicePixelRatio || 1, 1);
	}
	/**
	 * config默认配置项
	 * @exports zrender/config
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 */
	
	/**
	 * debug日志选项：catchBrushException为true下有效
	 * 0 : 不生成debug数据，发布用
	 * 1 : 异常抛出，调试用
	 * 2 : 控制台输出，调试用
	 */
	
	
	var debugMode = 0; // retina 屏幕优化
	
	var devicePixelRatio = dpr;
	exports.debugMode = debugMode;
	exports.devicePixelRatio = devicePixelRatio;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	var vec2 = __webpack_require__(8);
	
	var matrix = __webpack_require__(15);
	
	/**
	 * @module echarts/core/BoundingRect
	 */
	var v2ApplyTransform = vec2.applyTransform;
	var mathMin = Math.min;
	var mathMax = Math.max;
	/**
	 * @alias module:echarts/core/BoundingRect
	 */
	
	function BoundingRect(x, y, width, height) {
	  if (width < 0) {
	    x = x + width;
	    width = -width;
	  }
	
	  if (height < 0) {
	    y = y + height;
	    height = -height;
	  }
	  /**
	   * @type {number}
	   */
	
	
	  this.x = x;
	  /**
	   * @type {number}
	   */
	
	  this.y = y;
	  /**
	   * @type {number}
	   */
	
	  this.width = width;
	  /**
	   * @type {number}
	   */
	
	  this.height = height;
	}
	
	BoundingRect.prototype = {
	  constructor: BoundingRect,
	
	  /**
	   * @param {module:echarts/core/BoundingRect} other
	   */
	  union: function (other) {
	    var x = mathMin(other.x, this.x);
	    var y = mathMin(other.y, this.y);
	    this.width = mathMax(other.x + other.width, this.x + this.width) - x;
	    this.height = mathMax(other.y + other.height, this.y + this.height) - y;
	    this.x = x;
	    this.y = y;
	  },
	
	  /**
	   * @param {Array.<number>} m
	   * @methods
	   */
	  applyTransform: function () {
	    var lt = [];
	    var rb = [];
	    var lb = [];
	    var rt = [];
	    return function (m) {
	      // In case usage like this
	      // el.getBoundingRect().applyTransform(el.transform)
	      // And element has no transform
	      if (!m) {
	        return;
	      }
	
	      lt[0] = lb[0] = this.x;
	      lt[1] = rt[1] = this.y;
	      rb[0] = rt[0] = this.x + this.width;
	      rb[1] = lb[1] = this.y + this.height;
	      v2ApplyTransform(lt, lt, m);
	      v2ApplyTransform(rb, rb, m);
	      v2ApplyTransform(lb, lb, m);
	      v2ApplyTransform(rt, rt, m);
	      this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);
	      this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);
	      var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);
	      var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);
	      this.width = maxX - this.x;
	      this.height = maxY - this.y;
	    };
	  }(),
	
	  /**
	   * Calculate matrix of transforming from self to target rect
	   * @param  {module:zrender/core/BoundingRect} b
	   * @return {Array.<number>}
	   */
	  calculateTransform: function (b) {
	    var a = this;
	    var sx = b.width / a.width;
	    var sy = b.height / a.height;
	    var m = matrix.create(); // 矩阵右乘
	
	    matrix.translate(m, m, [-a.x, -a.y]);
	    matrix.scale(m, m, [sx, sy]);
	    matrix.translate(m, m, [b.x, b.y]);
	    return m;
	  },
	
	  /**
	   * @param {(module:echarts/core/BoundingRect|Object)} b
	   * @return {boolean}
	   */
	  intersect: function (b) {
	    if (!b) {
	      return false;
	    }
	
	    if (!(b instanceof BoundingRect)) {
	      // Normalize negative width/height.
	      b = BoundingRect.create(b);
	    }
	
	    var a = this;
	    var ax0 = a.x;
	    var ax1 = a.x + a.width;
	    var ay0 = a.y;
	    var ay1 = a.y + a.height;
	    var bx0 = b.x;
	    var bx1 = b.x + b.width;
	    var by0 = b.y;
	    var by1 = b.y + b.height;
	    return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
	  },
	  contain: function (x, y) {
	    var rect = this;
	    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
	  },
	
	  /**
	   * @return {module:echarts/core/BoundingRect}
	   */
	  clone: function () {
	    return new BoundingRect(this.x, this.y, this.width, this.height);
	  },
	
	  /**
	   * Copy from another rect
	   */
	  copy: function (other) {
	    this.x = other.x;
	    this.y = other.y;
	    this.width = other.width;
	    this.height = other.height;
	  },
	  plain: function () {
	    return {
	      x: this.x,
	      y: this.y,
	      width: this.width,
	      height: this.height
	    };
	  }
	};
	/**
	 * @param {Object|module:zrender/core/BoundingRect} rect
	 * @param {number} rect.x
	 * @param {number} rect.y
	 * @param {number} rect.width
	 * @param {number} rect.height
	 * @return {module:zrender/core/BoundingRect}
	 */
	
	BoundingRect.create = function (rect) {
	  return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
	};
	
	var _default = BoundingRect;
	module.exports = _default;

/***/ }),
/* 25 */
/***/ (function(module, exports) {

	// https://github.com/mziccard/node-timsort
	var DEFAULT_MIN_MERGE = 32;
	var DEFAULT_MIN_GALLOPING = 7;
	var DEFAULT_TMP_STORAGE_LENGTH = 256;
	
	function minRunLength(n) {
	  var r = 0;
	
	  while (n >= DEFAULT_MIN_MERGE) {
	    r |= n & 1;
	    n >>= 1;
	  }
	
	  return n + r;
	}
	
	function makeAscendingRun(array, lo, hi, compare) {
	  var runHi = lo + 1;
	
	  if (runHi === hi) {
	    return 1;
	  }
	
	  if (compare(array[runHi++], array[lo]) < 0) {
	    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
	      runHi++;
	    }
	
	    reverseRun(array, lo, runHi);
	  } else {
	    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
	      runHi++;
	    }
	  }
	
	  return runHi - lo;
	}
	
	function reverseRun(array, lo, hi) {
	  hi--;
	
	  while (lo < hi) {
	    var t = array[lo];
	    array[lo++] = array[hi];
	    array[hi--] = t;
	  }
	}
	
	function binaryInsertionSort(array, lo, hi, start, compare) {
	  if (start === lo) {
	    start++;
	  }
	
	  for (; start < hi; start++) {
	    var pivot = array[start];
	    var left = lo;
	    var right = start;
	    var mid;
	
	    while (left < right) {
	      mid = left + right >>> 1;
	
	      if (compare(pivot, array[mid]) < 0) {
	        right = mid;
	      } else {
	        left = mid + 1;
	      }
	    }
	
	    var n = start - left;
	
	    switch (n) {
	      case 3:
	        array[left + 3] = array[left + 2];
	
	      case 2:
	        array[left + 2] = array[left + 1];
	
	      case 1:
	        array[left + 1] = array[left];
	        break;
	
	      default:
	        while (n > 0) {
	          array[left + n] = array[left + n - 1];
	          n--;
	        }
	
	    }
	
	    array[left] = pivot;
	  }
	}
	
	function gallopLeft(value, array, start, length, hint, compare) {
	  var lastOffset = 0;
	  var maxOffset = 0;
	  var offset = 1;
	
	  if (compare(value, array[start + hint]) > 0) {
	    maxOffset = length - hint;
	
	    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
	      lastOffset = offset;
	      offset = (offset << 1) + 1;
	
	      if (offset <= 0) {
	        offset = maxOffset;
	      }
	    }
	
	    if (offset > maxOffset) {
	      offset = maxOffset;
	    }
	
	    lastOffset += hint;
	    offset += hint;
	  } else {
	    maxOffset = hint + 1;
	
	    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
	      lastOffset = offset;
	      offset = (offset << 1) + 1;
	
	      if (offset <= 0) {
	        offset = maxOffset;
	      }
	    }
	
	    if (offset > maxOffset) {
	      offset = maxOffset;
	    }
	
	    var tmp = lastOffset;
	    lastOffset = hint - offset;
	    offset = hint - tmp;
	  }
	
	  lastOffset++;
	
	  while (lastOffset < offset) {
	    var m = lastOffset + (offset - lastOffset >>> 1);
	
	    if (compare(value, array[start + m]) > 0) {
	      lastOffset = m + 1;
	    } else {
	      offset = m;
	    }
	  }
	
	  return offset;
	}
	
	function gallopRight(value, array, start, length, hint, compare) {
	  var lastOffset = 0;
	  var maxOffset = 0;
	  var offset = 1;
	
	  if (compare(value, array[start + hint]) < 0) {
	    maxOffset = hint + 1;
	
	    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
	      lastOffset = offset;
	      offset = (offset << 1) + 1;
	
	      if (offset <= 0) {
	        offset = maxOffset;
	      }
	    }
	
	    if (offset > maxOffset) {
	      offset = maxOffset;
	    }
	
	    var tmp = lastOffset;
	    lastOffset = hint - offset;
	    offset = hint - tmp;
	  } else {
	    maxOffset = length - hint;
	
	    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
	      lastOffset = offset;
	      offset = (offset << 1) + 1;
	
	      if (offset <= 0) {
	        offset = maxOffset;
	      }
	    }
	
	    if (offset > maxOffset) {
	      offset = maxOffset;
	    }
	
	    lastOffset += hint;
	    offset += hint;
	  }
	
	  lastOffset++;
	
	  while (lastOffset < offset) {
	    var m = lastOffset + (offset - lastOffset >>> 1);
	
	    if (compare(value, array[start + m]) < 0) {
	      offset = m;
	    } else {
	      lastOffset = m + 1;
	    }
	  }
	
	  return offset;
	}
	
	function TimSort(array, compare) {
	  var minGallop = DEFAULT_MIN_GALLOPING;
	  var length = 0;
	  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
	  var stackLength = 0;
	  var runStart;
	  var runLength;
	  var stackSize = 0;
	  length = array.length;
	
	  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
	    tmpStorageLength = length >>> 1;
	  }
	
	  var tmp = [];
	  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
	  runStart = [];
	  runLength = [];
	
	  function pushRun(_runStart, _runLength) {
	    runStart[stackSize] = _runStart;
	    runLength[stackSize] = _runLength;
	    stackSize += 1;
	  }
	
	  function mergeRuns() {
	    while (stackSize > 1) {
	      var n = stackSize - 2;
	
	      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
	        if (runLength[n - 1] < runLength[n + 1]) {
	          n--;
	        }
	      } else if (runLength[n] > runLength[n + 1]) {
	        break;
	      }
	
	      mergeAt(n);
	    }
	  }
	
	  function forceMergeRuns() {
	    while (stackSize > 1) {
	      var n = stackSize - 2;
	
	      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
	        n--;
	      }
	
	      mergeAt(n);
	    }
	  }
	
	  function mergeAt(i) {
	    var start1 = runStart[i];
	    var length1 = runLength[i];
	    var start2 = runStart[i + 1];
	    var length2 = runLength[i + 1];
	    runLength[i] = length1 + length2;
	
	    if (i === stackSize - 3) {
	      runStart[i + 1] = runStart[i + 2];
	      runLength[i + 1] = runLength[i + 2];
	    }
	
	    stackSize--;
	    var k = gallopRight(array[start2], array, start1, length1, 0, compare);
	    start1 += k;
	    length1 -= k;
	
	    if (length1 === 0) {
	      return;
	    }
	
	    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);
	
	    if (length2 === 0) {
	      return;
	    }
	
	    if (length1 <= length2) {
	      mergeLow(start1, length1, start2, length2);
	    } else {
	      mergeHigh(start1, length1, start2, length2);
	    }
	  }
	
	  function mergeLow(start1, length1, start2, length2) {
	    var i = 0;
	
	    for (i = 0; i < length1; i++) {
	      tmp[i] = array[start1 + i];
	    }
	
	    var cursor1 = 0;
	    var cursor2 = start2;
	    var dest = start1;
	    array[dest++] = array[cursor2++];
	
	    if (--length2 === 0) {
	      for (i = 0; i < length1; i++) {
	        array[dest + i] = tmp[cursor1 + i];
	      }
	
	      return;
	    }
	
	    if (length1 === 1) {
	      for (i = 0; i < length2; i++) {
	        array[dest + i] = array[cursor2 + i];
	      }
	
	      array[dest + length2] = tmp[cursor1];
	      return;
	    }
	
	    var _minGallop = minGallop;
	    var count1, count2, exit;
	
	    while (1) {
	      count1 = 0;
	      count2 = 0;
	      exit = false;
	
	      do {
	        if (compare(array[cursor2], tmp[cursor1]) < 0) {
	          array[dest++] = array[cursor2++];
	          count2++;
	          count1 = 0;
	
	          if (--length2 === 0) {
	            exit = true;
	            break;
	          }
	        } else {
	          array[dest++] = tmp[cursor1++];
	          count1++;
	          count2 = 0;
	
	          if (--length1 === 1) {
	            exit = true;
	            break;
	          }
	        }
	      } while ((count1 | count2) < _minGallop);
	
	      if (exit) {
	        break;
	      }
	
	      do {
	        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);
	
	        if (count1 !== 0) {
	          for (i = 0; i < count1; i++) {
	            array[dest + i] = tmp[cursor1 + i];
	          }
	
	          dest += count1;
	          cursor1 += count1;
	          length1 -= count1;
	
	          if (length1 <= 1) {
	            exit = true;
	            break;
	          }
	        }
	
	        array[dest++] = array[cursor2++];
	
	        if (--length2 === 0) {
	          exit = true;
	          break;
	        }
	
	        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);
	
	        if (count2 !== 0) {
	          for (i = 0; i < count2; i++) {
	            array[dest + i] = array[cursor2 + i];
	          }
	
	          dest += count2;
	          cursor2 += count2;
	          length2 -= count2;
	
	          if (length2 === 0) {
	            exit = true;
	            break;
	          }
	        }
	
	        array[dest++] = tmp[cursor1++];
	
	        if (--length1 === 1) {
	          exit = true;
	          break;
	        }
	
	        _minGallop--;
	      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	
	      if (exit) {
	        break;
	      }
	
	      if (_minGallop < 0) {
	        _minGallop = 0;
	      }
	
	      _minGallop += 2;
	    }
	
	    minGallop = _minGallop;
	    minGallop < 1 && (minGallop = 1);
	
	    if (length1 === 1) {
	      for (i = 0; i < length2; i++) {
	        array[dest + i] = array[cursor2 + i];
	      }
	
	      array[dest + length2] = tmp[cursor1];
	    } else if (length1 === 0) {
	      throw new Error(); // throw new Error('mergeLow preconditions were not respected');
	    } else {
	      for (i = 0; i < length1; i++) {
	        array[dest + i] = tmp[cursor1 + i];
	      }
	    }
	  }
	
	  function mergeHigh(start1, length1, start2, length2) {
	    var i = 0;
	
	    for (i = 0; i < length2; i++) {
	      tmp[i] = array[start2 + i];
	    }
	
	    var cursor1 = start1 + length1 - 1;
	    var cursor2 = length2 - 1;
	    var dest = start2 + length2 - 1;
	    var customCursor = 0;
	    var customDest = 0;
	    array[dest--] = array[cursor1--];
	
	    if (--length1 === 0) {
	      customCursor = dest - (length2 - 1);
	
	      for (i = 0; i < length2; i++) {
	        array[customCursor + i] = tmp[i];
	      }
	
	      return;
	    }
	
	    if (length2 === 1) {
	      dest -= length1;
	      cursor1 -= length1;
	      customDest = dest + 1;
	      customCursor = cursor1 + 1;
	
	      for (i = length1 - 1; i >= 0; i--) {
	        array[customDest + i] = array[customCursor + i];
	      }
	
	      array[dest] = tmp[cursor2];
	      return;
	    }
	
	    var _minGallop = minGallop;
	
	    while (true) {
	      var count1 = 0;
	      var count2 = 0;
	      var exit = false;
	
	      do {
	        if (compare(tmp[cursor2], array[cursor1]) < 0) {
	          array[dest--] = array[cursor1--];
	          count1++;
	          count2 = 0;
	
	          if (--length1 === 0) {
	            exit = true;
	            break;
	          }
	        } else {
	          array[dest--] = tmp[cursor2--];
	          count2++;
	          count1 = 0;
	
	          if (--length2 === 1) {
	            exit = true;
	            break;
	          }
	        }
	      } while ((count1 | count2) < _minGallop);
	
	      if (exit) {
	        break;
	      }
	
	      do {
	        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);
	
	        if (count1 !== 0) {
	          dest -= count1;
	          cursor1 -= count1;
	          length1 -= count1;
	          customDest = dest + 1;
	          customCursor = cursor1 + 1;
	
	          for (i = count1 - 1; i >= 0; i--) {
	            array[customDest + i] = array[customCursor + i];
	          }
	
	          if (length1 === 0) {
	            exit = true;
	            break;
	          }
	        }
	
	        array[dest--] = tmp[cursor2--];
	
	        if (--length2 === 1) {
	          exit = true;
	          break;
	        }
	
	        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);
	
	        if (count2 !== 0) {
	          dest -= count2;
	          cursor2 -= count2;
	          length2 -= count2;
	          customDest = dest + 1;
	          customCursor = cursor2 + 1;
	
	          for (i = 0; i < count2; i++) {
	            array[customDest + i] = tmp[customCursor + i];
	          }
	
	          if (length2 <= 1) {
	            exit = true;
	            break;
	          }
	        }
	
	        array[dest--] = array[cursor1--];
	
	        if (--length1 === 0) {
	          exit = true;
	          break;
	        }
	
	        _minGallop--;
	      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	
	      if (exit) {
	        break;
	      }
	
	      if (_minGallop < 0) {
	        _minGallop = 0;
	      }
	
	      _minGallop += 2;
	    }
	
	    minGallop = _minGallop;
	
	    if (minGallop < 1) {
	      minGallop = 1;
	    }
	
	    if (length2 === 1) {
	      dest -= length1;
	      cursor1 -= length1;
	      customDest = dest + 1;
	      customCursor = cursor1 + 1;
	
	      for (i = length1 - 1; i >= 0; i--) {
	        array[customDest + i] = array[customCursor + i];
	      }
	
	      array[dest] = tmp[cursor2];
	    } else if (length2 === 0) {
	      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');
	    } else {
	      customCursor = dest - (length2 - 1);
	
	      for (i = 0; i < length2; i++) {
	        array[customCursor + i] = tmp[i];
	      }
	    }
	  }
	
	  this.mergeRuns = mergeRuns;
	  this.forceMergeRuns = forceMergeRuns;
	  this.pushRun = pushRun;
	}
	
	function sort(array, compare, lo, hi) {
	  if (!lo) {
	    lo = 0;
	  }
	
	  if (!hi) {
	    hi = array.length;
	  }
	
	  var remaining = hi - lo;
	
	  if (remaining < 2) {
	    return;
	  }
	
	  var runLength = 0;
	
	  if (remaining < DEFAULT_MIN_MERGE) {
	    runLength = makeAscendingRun(array, lo, hi, compare);
	    binaryInsertionSort(array, lo, hi, lo + runLength, compare);
	    return;
	  }
	
	  var ts = new TimSort(array, compare);
	  var minRun = minRunLength(remaining);
	
	  do {
	    runLength = makeAscendingRun(array, lo, hi, compare);
	
	    if (runLength < minRun) {
	      var force = remaining;
	
	      if (force > minRun) {
	        force = minRun;
	      }
	
	      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
	      runLength = force;
	    }
	
	    ts.pushRun(lo, runLength);
	    ts.mergeRuns();
	    remaining -= runLength;
	    lo += runLength;
	  } while (remaining !== 0);
	
	  ts.forceMergeRuns();
	}
	
	module.exports = sort;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	var _config = __webpack_require__(23);
	
	var devicePixelRatio = _config.devicePixelRatio;
	
	var util = __webpack_require__(6);
	
	var log = __webpack_require__(22);
	
	var BoundingRect = __webpack_require__(24);
	
	var timsort = __webpack_require__(25);
	
	var Layer = __webpack_require__(27);
	
	var requestAnimationFrame = __webpack_require__(30);
	
	var Image = __webpack_require__(31);
	
	/**
	 * Default canvas painter
	 * @module zrender/Painter
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	// PENDIGN
	// Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.
	//
	// Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.
	var MAX_PROGRESSIVE_LAYER_NUMBER = 5;
	
	function parseInt10(val) {
	  return parseInt(val, 10);
	}
	
	function isLayerValid(layer) {
	  if (!layer) {
	    return false;
	  }
	
	  if (layer.__builtin__) {
	    return true;
	  }
	
	  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {
	    return false;
	  }
	
	  return true;
	}
	
	function preProcessLayer(layer) {
	  layer.__unusedCount++;
	}
	
	function postProcessLayer(layer) {
	  if (layer.__unusedCount == 1) {
	    layer.clear();
	  }
	}
	
	var tmpRect = new BoundingRect(0, 0, 0, 0);
	var viewRect = new BoundingRect(0, 0, 0, 0);
	
	function isDisplayableCulled(el, width, height) {
	  tmpRect.copy(el.getBoundingRect());
	
	  if (el.transform) {
	    tmpRect.applyTransform(el.transform);
	  }
	
	  viewRect.width = width;
	  viewRect.height = height;
	  return !tmpRect.intersect(viewRect);
	}
	
	function isClipPathChanged(clipPaths, prevClipPaths) {
	  if (clipPaths == prevClipPaths) {
	    // Can both be null or undefined
	    return false;
	  }
	
	  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
	    return true;
	  }
	
	  for (var i = 0; i < clipPaths.length; i++) {
	    if (clipPaths[i] !== prevClipPaths[i]) {
	      return true;
	    }
	  }
	}
	
	function doClip(clipPaths, ctx) {
	  for (var i = 0; i < clipPaths.length; i++) {
	    var clipPath = clipPaths[i];
	    clipPath.setTransform(ctx);
	    ctx.beginPath();
	    clipPath.buildPath(ctx, clipPath.shape);
	    ctx.clip(); // Transform back
	
	    clipPath.restoreTransform(ctx);
	  }
	}
	
	function createRoot(width, height) {
	  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬
	
	  domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';
	  return domRoot;
	}
	/**
	 * @alias module:zrender/Painter
	 * @constructor
	 * @param {HTMLElement} root 绘图容器
	 * @param {module:zrender/Storage} storage
	 * @param {Object} opts
	 */
	
	
	var Painter = function (root, storage, opts) {
	  this.type = 'canvas'; // In node environment using node-canvas
	
	  var singleCanvas = !root.nodeName // In node ?
	  || root.nodeName.toUpperCase() === 'CANVAS';
	  this._opts = opts = util.extend({}, opts || {});
	  /**
	   * @type {number}
	   */
	
	  this.dpr = opts.devicePixelRatio || devicePixelRatio;
	  /**
	   * @type {boolean}
	   * @private
	   */
	
	  this._singleCanvas = singleCanvas;
	  /**
	   * 绘图容器
	   * @type {HTMLElement}
	   */
	
	  this.root = root;
	  var rootStyle = root.style;
	
	  if (rootStyle) {
	    rootStyle['-webkit-tap-highlight-color'] = 'transparent';
	    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';
	    root.innerHTML = '';
	  }
	  /**
	   * @type {module:zrender/Storage}
	   */
	
	
	  this.storage = storage;
	  /**
	   * @type {Array.<number>}
	   * @private
	   */
	
	  var zlevelList = this._zlevelList = [];
	  /**
	   * @type {Object.<string, module:zrender/Layer>}
	   * @private
	   */
	
	  var layers = this._layers = {};
	  /**
	   * @type {Object.<string, Object>}
	   * @type {private}
	   */
	
	  this._layerConfig = {};
	
	  if (!singleCanvas) {
	    this._width = this._getSize(0);
	    this._height = this._getSize(1);
	    var domRoot = this._domRoot = createRoot(this._width, this._height);
	    root.appendChild(domRoot);
	  } else {
	    if (opts.width != null) {
	      root.width = opts.width;
	    }
	
	    if (opts.height != null) {
	      root.height = opts.height;
	    } // Use canvas width and height directly
	
	
	    var width = root.width;
	    var height = root.height;
	    this._width = width;
	    this._height = height; // Create layer if only one given canvas
	    // Device pixel ratio is fixed to 1 because given canvas has its specified width and height
	
	    var mainLayer = new Layer(root, this, 1);
	    mainLayer.initContext(); // FIXME Use canvas width and height
	    // mainLayer.resize(width, height);
	
	    layers[0] = mainLayer;
	    zlevelList.push(0);
	    this._domRoot = root;
	  } // Layers for progressive rendering
	
	
	  this._progressiveLayers = [];
	  /**
	   * @type {module:zrender/Layer}
	   * @private
	   */
	
	  this._hoverlayer;
	  this._hoverElements = [];
	};
	
	Painter.prototype = {
	  constructor: Painter,
	  getType: function () {
	    return 'canvas';
	  },
	
	  /**
	   * If painter use a single canvas
	   * @return {boolean}
	   */
	  isSingleCanvas: function () {
	    return this._singleCanvas;
	  },
	
	  /**
	   * @return {HTMLDivElement}
	   */
	  getViewportRoot: function () {
	    return this._domRoot;
	  },
	  getViewportRootOffset: function () {
	    var viewportRoot = this.getViewportRoot();
	
	    if (viewportRoot) {
	      return {
	        offsetLeft: viewportRoot.offsetLeft || 0,
	        offsetTop: viewportRoot.offsetTop || 0
	      };
	    }
	  },
	
	  /**
	   * 刷新
	   * @param {boolean} [paintAll=false] 强制绘制所有displayable
	   */
	  refresh: function (paintAll) {
	    var list = this.storage.getDisplayList(true);
	    var zlevelList = this._zlevelList;
	
	    this._paintList(list, paintAll); // Paint custum layers
	
	
	    for (var i = 0; i < zlevelList.length; i++) {
	      var z = zlevelList[i];
	      var layer = this._layers[z];
	
	      if (!layer.__builtin__ && layer.refresh) {
	        layer.refresh();
	      }
	    }
	
	    this.refreshHover();
	
	    if (this._progressiveLayers.length) {
	      this._startProgessive();
	    }
	
	    return this;
	  },
	  addHover: function (el, hoverStyle) {
	    if (el.__hoverMir) {
	      return;
	    }
	
	    var elMirror = new el.constructor({
	      style: el.style,
	      shape: el.shape
	    });
	    elMirror.__from = el;
	    el.__hoverMir = elMirror;
	    elMirror.setStyle(hoverStyle);
	
	    this._hoverElements.push(elMirror);
	  },
	  removeHover: function (el) {
	    var elMirror = el.__hoverMir;
	    var hoverElements = this._hoverElements;
	    var idx = util.indexOf(hoverElements, elMirror);
	
	    if (idx >= 0) {
	      hoverElements.splice(idx, 1);
	    }
	
	    el.__hoverMir = null;
	  },
	  clearHover: function (el) {
	    var hoverElements = this._hoverElements;
	
	    for (var i = 0; i < hoverElements.length; i++) {
	      var from = hoverElements[i].__from;
	
	      if (from) {
	        from.__hoverMir = null;
	      }
	    }
	
	    hoverElements.length = 0;
	  },
	  refreshHover: function () {
	    var hoverElements = this._hoverElements;
	    var len = hoverElements.length;
	    var hoverLayer = this._hoverlayer;
	    hoverLayer && hoverLayer.clear();
	
	    if (!len) {
	      return;
	    }
	
	    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel
	    // FIXME?
	
	    if (!hoverLayer) {
	      hoverLayer = this._hoverlayer = this.getLayer(1e5);
	    }
	
	    var scope = {};
	    hoverLayer.ctx.save();
	
	    for (var i = 0; i < len;) {
	      var el = hoverElements[i];
	      var originalEl = el.__from; // Original el is removed
	      // PENDING
	
	      if (!(originalEl && originalEl.__zr)) {
	        hoverElements.splice(i, 1);
	        originalEl.__hoverMir = null;
	        len--;
	        continue;
	      }
	
	      i++; // Use transform
	      // FIXME style and shape ?
	
	      if (!originalEl.invisible) {
	        el.transform = originalEl.transform;
	        el.invTransform = originalEl.invTransform;
	        el.__clipPaths = originalEl.__clipPaths; // el.
	
	        this._doPaintEl(el, hoverLayer, true, scope);
	      }
	    }
	
	    hoverLayer.ctx.restore();
	  },
	  _startProgessive: function () {
	    var self = this;
	
	    if (!self._furtherProgressive) {
	      return;
	    } // Use a token to stop progress steps triggered by
	    // previous zr.refresh calling.
	
	
	    var token = self._progressiveToken = +new Date();
	    self._progress++;
	    requestAnimationFrame(step);
	
	    function step() {
	      // In case refreshed or disposed
	      if (token === self._progressiveToken && self.storage) {
	        self._doPaintList(self.storage.getDisplayList());
	
	        if (self._furtherProgressive) {
	          self._progress++;
	          requestAnimationFrame(step);
	        } else {
	          self._progressiveToken = -1;
	        }
	      }
	    }
	  },
	  _clearProgressive: function () {
	    this._progressiveToken = -1;
	    this._progress = 0;
	    util.each(this._progressiveLayers, function (layer) {
	      layer.__dirty && layer.clear();
	    });
	  },
	  _paintList: function (list, paintAll) {
	    if (paintAll == null) {
	      paintAll = false;
	    }
	
	    this._updateLayerStatus(list);
	
	    this._clearProgressive();
	
	    this.eachBuiltinLayer(preProcessLayer);
	
	    this._doPaintList(list, paintAll);
	
	    this.eachBuiltinLayer(postProcessLayer);
	  },
	  _doPaintList: function (list, paintAll) {
	    var currentLayer;
	    var currentZLevel;
	    var ctx; // var invTransform = [];
	
	    var scope;
	    var progressiveLayerIdx = 0;
	    var currentProgressiveLayer;
	    var width = this._width;
	    var height = this._height;
	    var layerProgress;
	    var frame = this._progress;
	
	    function flushProgressiveLayer(layer) {
	      var dpr = ctx.dpr || 1;
	      ctx.save();
	      ctx.globalAlpha = 1;
	      ctx.shadowBlur = 0; // Avoid layer don't clear in next progressive frame
	
	      currentLayer.__dirty = true;
	      ctx.setTransform(1, 0, 0, 1, 0, 0);
	      ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);
	      ctx.restore();
	    }
	
	    for (var i = 0, l = list.length; i < l; i++) {
	      var el = list[i];
	      var elZLevel = this._singleCanvas ? 0 : el.zlevel;
	      var elFrame = el.__frame; // Flush at current context
	      // PENDING
	
	      if (elFrame < 0 && currentProgressiveLayer) {
	        flushProgressiveLayer(currentProgressiveLayer);
	        currentProgressiveLayer = null;
	      } // Change draw layer
	
	
	      if (currentZLevel !== elZLevel) {
	        if (ctx) {
	          ctx.restore();
	        } // Reset scope
	
	
	        scope = {}; // Only 0 zlevel if only has one canvas
	
	        currentZLevel = elZLevel;
	        currentLayer = this.getLayer(currentZLevel);
	
	        if (!currentLayer.__builtin__) {
	          log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);
	        }
	
	        ctx = currentLayer.ctx;
	        ctx.save(); // Reset the count
	
	        currentLayer.__unusedCount = 0;
	
	        if (currentLayer.__dirty || paintAll) {
	          currentLayer.clear();
	        }
	      }
	
	      if (!(currentLayer.__dirty || paintAll)) {
	        continue;
	      }
	
	      if (elFrame >= 0) {
	        // Progressive layer changed
	        if (!currentProgressiveLayer) {
	          currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];
	          currentProgressiveLayer.ctx.save();
	          currentProgressiveLayer.renderScope = {};
	
	          if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {
	            // flushProgressiveLayer(currentProgressiveLayer);
	            // Quick jump all progressive elements
	            // All progressive element are not dirty, jump over and flush directly
	            i = currentProgressiveLayer.__nextIdxNotProg - 1; // currentProgressiveLayer = null;
	
	            continue;
	          }
	
	          layerProgress = currentProgressiveLayer.__progress;
	
	          if (!currentProgressiveLayer.__dirty) {
	            // Keep rendering
	            frame = layerProgress;
	          }
	
	          currentProgressiveLayer.__progress = frame + 1;
	        }
	
	        if (elFrame === frame) {
	          this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);
	        }
	      } else {
	        this._doPaintEl(el, currentLayer, paintAll, scope);
	      }
	
	      el.__dirty = false;
	    }
	
	    if (currentProgressiveLayer) {
	      flushProgressiveLayer(currentProgressiveLayer);
	    } // Restore the lastLayer ctx
	
	
	    ctx && ctx.restore(); // If still has clipping state
	    // if (scope.prevElClipPaths) {
	    //     ctx.restore();
	    // }
	
	    this._furtherProgressive = false;
	    util.each(this._progressiveLayers, function (layer) {
	      if (layer.__maxProgress >= layer.__progress) {
	        this._furtherProgressive = true;
	      }
	    }, this);
	  },
	  _doPaintEl: function (el, currentLayer, forcePaint, scope) {
	    var ctx = currentLayer.ctx;
	    var m = el.transform;
	
	    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element
	    !el.invisible // Ignore transparent element
	    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas
	    // Draw a scale 0 element can cause all following draw wrong
	    // And setTransform with scale 0 will cause set back transform failed.
	    && !(m && !m[0] && !m[3]) // Ignore culled element
	    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {
	      var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements
	
	      if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {
	        // If has previous clipping state, restore from it
	        if (scope.prevElClipPaths) {
	          scope.prevClipLayer.ctx.restore();
	          scope.prevClipLayer = scope.prevElClipPaths = null; // Reset prevEl since context has been restored
	
	          scope.prevEl = null;
	        } // New clipping state
	
	
	        if (clipPaths) {
	          ctx.save();
	          doClip(clipPaths, ctx);
	          scope.prevClipLayer = currentLayer;
	          scope.prevElClipPaths = clipPaths;
	        }
	      }
	
	      el.beforeBrush && el.beforeBrush(ctx);
	      el.brush(ctx, scope.prevEl || null);
	      scope.prevEl = el;
	      el.afterBrush && el.afterBrush(ctx);
	    }
	  },
	
	  /**
	   * 获取 zlevel 所在层，如果不存在则会创建一个新的层
	   * @param {number} zlevel
	   * @return {module:zrender/Layer}
	   */
	  getLayer: function (zlevel) {
	    if (this._singleCanvas) {
	      return this._layers[0];
	    }
	
	    var layer = this._layers[zlevel];
	
	    if (!layer) {
	      // Create a new layer
	      layer = new Layer('zr_' + zlevel, this, this.dpr);
	      layer.__builtin__ = true;
	
	      if (this._layerConfig[zlevel]) {
	        util.merge(layer, this._layerConfig[zlevel], true);
	      }
	
	      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document
	      // Or excanvas will get 0px clientWidth and clientHeight
	
	      layer.initContext();
	    }
	
	    return layer;
	  },
	  insertLayer: function (zlevel, layer) {
	    var layersMap = this._layers;
	    var zlevelList = this._zlevelList;
	    var len = zlevelList.length;
	    var prevLayer = null;
	    var i = -1;
	    var domRoot = this._domRoot;
	
	    if (layersMap[zlevel]) {
	      log('ZLevel ' + zlevel + ' has been used already');
	      return;
	    } // Check if is a valid layer
	
	
	    if (!isLayerValid(layer)) {
	      log('Layer of zlevel ' + zlevel + ' is not valid');
	      return;
	    }
	
	    if (len > 0 && zlevel > zlevelList[0]) {
	      for (i = 0; i < len - 1; i++) {
	        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
	          break;
	        }
	      }
	
	      prevLayer = layersMap[zlevelList[i]];
	    }
	
	    zlevelList.splice(i + 1, 0, zlevel);
	    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.
	    // (It can be a WebGL layer and assigned to a ZImage element)
	    // But it still under management of zrender.
	
	    if (!layer.virtual) {
	      if (prevLayer) {
	        var prevDom = prevLayer.dom;
	
	        if (prevDom.nextSibling) {
	          domRoot.insertBefore(layer.dom, prevDom.nextSibling);
	        } else {
	          domRoot.appendChild(layer.dom);
	        }
	      } else {
	        if (domRoot.firstChild) {
	          domRoot.insertBefore(layer.dom, domRoot.firstChild);
	        } else {
	          domRoot.appendChild(layer.dom);
	        }
	      }
	    }
	  },
	  // Iterate each layer
	  eachLayer: function (cb, context) {
	    var zlevelList = this._zlevelList;
	    var z;
	    var i;
	
	    for (i = 0; i < zlevelList.length; i++) {
	      z = zlevelList[i];
	      cb.call(context, this._layers[z], z);
	    }
	  },
	  // Iterate each buildin layer
	  eachBuiltinLayer: function (cb, context) {
	    var zlevelList = this._zlevelList;
	    var layer;
	    var z;
	    var i;
	
	    for (i = 0; i < zlevelList.length; i++) {
	      z = zlevelList[i];
	      layer = this._layers[z];
	
	      if (layer.__builtin__) {
	        cb.call(context, layer, z);
	      }
	    }
	  },
	  // Iterate each other layer except buildin layer
	  eachOtherLayer: function (cb, context) {
	    var zlevelList = this._zlevelList;
	    var layer;
	    var z;
	    var i;
	
	    for (i = 0; i < zlevelList.length; i++) {
	      z = zlevelList[i];
	      layer = this._layers[z];
	
	      if (!layer.__builtin__) {
	        cb.call(context, layer, z);
	      }
	    }
	  },
	
	  /**
	   * 获取所有已创建的层
	   * @param {Array.<module:zrender/Layer>} [prevLayer]
	   */
	  getLayers: function () {
	    return this._layers;
	  },
	  _updateLayerStatus: function (list) {
	    var layers = this._layers;
	    var progressiveLayers = this._progressiveLayers;
	    var elCountsLastFrame = {};
	    var progressiveElCountsLastFrame = {};
	    this.eachBuiltinLayer(function (layer, z) {
	      elCountsLastFrame[z] = layer.elCount;
	      layer.elCount = 0;
	      layer.__dirty = false;
	    });
	    util.each(progressiveLayers, function (layer, idx) {
	      progressiveElCountsLastFrame[idx] = layer.elCount;
	      layer.elCount = 0;
	      layer.__dirty = false;
	    });
	    var progressiveLayerCount = 0;
	    var currentProgressiveLayer;
	    var lastProgressiveKey;
	    var frameCount = 0;
	
	    for (var i = 0, l = list.length; i < l; i++) {
	      var el = list[i];
	      var zlevel = this._singleCanvas ? 0 : el.zlevel;
	      var layer = layers[zlevel];
	      var elProgress = el.progressive;
	
	      if (layer) {
	        layer.elCount++;
	        layer.__dirty = layer.__dirty || el.__dirty;
	      } /////// Update progressive
	
	
	      if (elProgress >= 0) {
	        // Fix wrong progressive sequence problem.
	        if (lastProgressiveKey !== elProgress) {
	          lastProgressiveKey = elProgress;
	          frameCount++;
	        }
	
	        var elFrame = el.__frame = frameCount - 1;
	
	        if (!currentProgressiveLayer) {
	          var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);
	          currentProgressiveLayer = progressiveLayers[idx];
	
	          if (!currentProgressiveLayer) {
	            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);
	            currentProgressiveLayer.initContext();
	          }
	
	          currentProgressiveLayer.__maxProgress = 0;
	        }
	
	        currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;
	        currentProgressiveLayer.elCount++;
	        currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);
	
	        if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {
	          // Should keep rendering this  layer because progressive rendering is not finished yet
	          layer.__dirty = true;
	        }
	      } else {
	        el.__frame = -1;
	
	        if (currentProgressiveLayer) {
	          currentProgressiveLayer.__nextIdxNotProg = i;
	          progressiveLayerCount++;
	          currentProgressiveLayer = null;
	        }
	      }
	    }
	
	    if (currentProgressiveLayer) {
	      progressiveLayerCount++;
	      currentProgressiveLayer.__nextIdxNotProg = i;
	    } // 层中的元素数量有发生变化
	
	
	    this.eachBuiltinLayer(function (layer, z) {
	      if (elCountsLastFrame[z] !== layer.elCount) {
	        layer.__dirty = true;
	      }
	    });
	    progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);
	    util.each(progressiveLayers, function (layer, idx) {
	      if (progressiveElCountsLastFrame[idx] !== layer.elCount) {
	        el.__dirty = true;
	      }
	
	      if (layer.__dirty) {
	        layer.__progress = 0;
	      }
	    });
	  },
	
	  /**
	   * 清除hover层外所有内容
	   */
	  clear: function () {
	    this.eachBuiltinLayer(this._clearLayer);
	    return this;
	  },
	  _clearLayer: function (layer) {
	    layer.clear();
	  },
	
	  /**
	   * 修改指定zlevel的绘制参数
	   *
	   * @param {string} zlevel
	   * @param {Object} config 配置对象
	   * @param {string} [config.clearColor=0] 每次清空画布的颜色
	   * @param {string} [config.motionBlur=false] 是否开启动态模糊
	   * @param {number} [config.lastFrameAlpha=0.7]
	   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	   */
	  configLayer: function (zlevel, config) {
	    if (config) {
	      var layerConfig = this._layerConfig;
	
	      if (!layerConfig[zlevel]) {
	        layerConfig[zlevel] = config;
	      } else {
	        util.merge(layerConfig[zlevel], config, true);
	      }
	
	      var layer = this._layers[zlevel];
	
	      if (layer) {
	        util.merge(layer, layerConfig[zlevel], true);
	      }
	    }
	  },
	
	  /**
	   * 删除指定层
	   * @param {number} zlevel 层所在的zlevel
	   */
	  delLayer: function (zlevel) {
	    var layers = this._layers;
	    var zlevelList = this._zlevelList;
	    var layer = layers[zlevel];
	
	    if (!layer) {
	      return;
	    }
	
	    layer.dom.parentNode.removeChild(layer.dom);
	    delete layers[zlevel];
	    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
	  },
	
	  /**
	   * 区域大小变化后重绘
	   */
	  resize: function (width, height) {
	    var domRoot = this._domRoot; // FIXME Why ?
	
	    domRoot.style.display = 'none'; // Save input w/h
	
	    var opts = this._opts;
	    width != null && (opts.width = width);
	    height != null && (opts.height = height);
	    width = this._getSize(0);
	    height = this._getSize(1);
	    domRoot.style.display = ''; // 优化没有实际改变的resize
	
	    if (this._width != width || height != this._height) {
	      domRoot.style.width = width + 'px';
	      domRoot.style.height = height + 'px';
	
	      for (var id in this._layers) {
	        if (this._layers.hasOwnProperty(id)) {
	          this._layers[id].resize(width, height);
	        }
	      }
	
	      util.each(this._progressiveLayers, function (layer) {
	        layer.resize(width, height);
	      });
	      this.refresh(true);
	    }
	
	    this._width = width;
	    this._height = height;
	    return this;
	  },
	
	  /**
	   * 清除单独的一个层
	   * @param {number} zlevel
	   */
	  clearLayer: function (zlevel) {
	    var layer = this._layers[zlevel];
	
	    if (layer) {
	      layer.clear();
	    }
	  },
	
	  /**
	   * 释放
	   */
	  dispose: function () {
	    this.root.innerHTML = '';
	    this.root = this.storage = this._domRoot = this._layers = null;
	  },
	
	  /**
	   * Get canvas which has all thing rendered
	   * @param {Object} opts
	   * @param {string} [opts.backgroundColor]
	   * @param {number} [opts.pixelRatio]
	   */
	  getRenderedCanvas: function (opts) {
	    opts = opts || {};
	
	    if (this._singleCanvas) {
	      return this._layers[0].dom;
	    }
	
	    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);
	    imageLayer.initContext();
	    imageLayer.clearColor = opts.backgroundColor;
	    imageLayer.clear();
	    var displayList = this.storage.getDisplayList(true);
	    var scope = {};
	    var zlevel;
	    var self = this;
	
	    function findAndDrawOtherLayer(smaller, larger) {
	      var zlevelList = self._zlevelList;
	
	      if (smaller == null) {
	        smaller = -Infinity;
	      }
	
	      var intermediateLayer;
	
	      for (var i = 0; i < zlevelList.length; i++) {
	        var z = zlevelList[i];
	        var layer = self._layers[z];
	
	        if (!layer.__builtin__ && z > smaller && z < larger) {
	          intermediateLayer = layer;
	          break;
	        }
	      }
	
	      if (intermediateLayer && intermediateLayer.renderToCanvas) {
	        imageLayer.ctx.save();
	        intermediateLayer.renderToCanvas(imageLayer.ctx);
	        imageLayer.ctx.restore();
	      }
	    }
	
	    for (var i = 0; i < displayList.length; i++) {
	      var el = displayList[i];
	
	      if (el.zlevel !== zlevel) {
	        findAndDrawOtherLayer(zlevel, el.zlevel);
	        zlevel = el.zlevel;
	      }
	
	      this._doPaintEl(el, imageLayer, true, scope);
	    }
	
	    findAndDrawOtherLayer(zlevel, Infinity);
	    return imageLayer.dom;
	  },
	
	  /**
	   * 获取绘图区域宽度
	   */
	  getWidth: function () {
	    return this._width;
	  },
	
	  /**
	   * 获取绘图区域高度
	   */
	  getHeight: function () {
	    return this._height;
	  },
	  _getSize: function (whIdx) {
	    var opts = this._opts;
	    var wh = ['width', 'height'][whIdx];
	    var cwh = ['clientWidth', 'clientHeight'][whIdx];
	    var plt = ['paddingLeft', 'paddingTop'][whIdx];
	    var prb = ['paddingRight', 'paddingBottom'][whIdx];
	
	    if (opts[wh] != null && opts[wh] !== 'auto') {
	      return parseFloat(opts[wh]);
	    }
	
	    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.
	
	    var stl = document.defaultView.getComputedStyle(root);
	    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
	  },
	  pathToImage: function (path, dpr) {
	    dpr = dpr || this.dpr;
	    var canvas = document.createElement('canvas');
	    var ctx = canvas.getContext('2d');
	    var rect = path.getBoundingRect();
	    var style = path.style;
	    var shadowBlurSize = style.shadowBlur;
	    var shadowOffsetX = style.shadowOffsetX;
	    var shadowOffsetY = style.shadowOffsetY;
	    var lineWidth = style.hasStroke() ? style.lineWidth : 0;
	    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);
	    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);
	    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);
	    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);
	    var width = rect.width + leftMargin + rightMargin;
	    var height = rect.height + topMargin + bottomMargin;
	    canvas.width = width * dpr;
	    canvas.height = height * dpr;
	    ctx.scale(dpr, dpr);
	    ctx.clearRect(0, 0, width, height);
	    ctx.dpr = dpr;
	    var pathTransform = {
	      position: path.position,
	      rotation: path.rotation,
	      scale: path.scale
	    };
	    path.position = [leftMargin - rect.x, topMargin - rect.y];
	    path.rotation = 0;
	    path.scale = [1, 1];
	    path.updateTransform();
	
	    if (path) {
	      path.brush(ctx);
	    }
	
	    var ImageShape = Image;
	    var imgShape = new ImageShape({
	      style: {
	        x: 0,
	        y: 0,
	        image: canvas
	      }
	    });
	
	    if (pathTransform.position != null) {
	      imgShape.position = path.position = pathTransform.position;
	    }
	
	    if (pathTransform.rotation != null) {
	      imgShape.rotation = path.rotation = pathTransform.rotation;
	    }
	
	    if (pathTransform.scale != null) {
	      imgShape.scale = path.scale = pathTransform.scale;
	    }
	
	    return imgShape;
	  }
	};
	var _default = Painter;
	module.exports = _default;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(6);
	
	var _config = __webpack_require__(23);
	
	var devicePixelRatio = _config.devicePixelRatio;
	
	var Style = __webpack_require__(28);
	
	var Pattern = __webpack_require__(29);
	
	/**
	 * @module zrender/Layer
	 * @author pissang(https://www.github.com/pissang)
	 */
	function returnFalse() {
	  return false;
	}
	/**
	 * 创建dom
	 *
	 * @inner
	 * @param {string} id dom id 待用
	 * @param {Painter} painter painter instance
	 * @param {number} number
	 */
	
	
	function createDom(id, painter, dpr) {
	  var newDom = util.createCanvas();
	  var width = painter.getWidth();
	  var height = painter.getHeight();
	  var newDomStyle = newDom.style; // 没append呢，请原谅我这样写，清晰~
	
	  newDomStyle.position = 'absolute';
	  newDomStyle.left = 0;
	  newDomStyle.top = 0;
	  newDomStyle.width = width + 'px';
	  newDomStyle.height = height + 'px';
	  newDom.width = width * dpr;
	  newDom.height = height * dpr; // id不作为索引用，避免可能造成的重名，定义为私有属性
	
	  newDom.setAttribute('data-zr-dom-id', id);
	  return newDom;
	}
	/**
	 * @alias module:zrender/Layer
	 * @constructor
	 * @extends module:zrender/mixin/Transformable
	 * @param {string} id
	 * @param {module:zrender/Painter} painter
	 * @param {number} [dpr]
	 */
	
	
	var Layer = function (id, painter, dpr) {
	  var dom;
	  dpr = dpr || devicePixelRatio;
	
	  if (typeof id === 'string') {
	    dom = createDom(id, painter, dpr);
	  } // Not using isDom because in node it will return false
	  else if (util.isObject(id)) {
	      dom = id;
	      id = dom.id;
	    }
	
	  this.id = id;
	  this.dom = dom;
	  var domStyle = dom.style;
	
	  if (domStyle) {
	    // Not in node
	    dom.onselectstart = returnFalse; // 避免页面选中的尴尬
	
	    domStyle['-webkit-user-select'] = 'none';
	    domStyle['user-select'] = 'none';
	    domStyle['-webkit-touch-callout'] = 'none';
	    domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
	    domStyle['padding'] = 0;
	    domStyle['margin'] = 0;
	    domStyle['border-width'] = 0;
	  }
	
	  this.domBack = null;
	  this.ctxBack = null;
	  this.painter = painter;
	  this.config = null; // Configs
	
	  /**
	   * 每次清空画布的颜色
	   * @type {string}
	   * @default 0
	   */
	
	  this.clearColor = 0;
	  /**
	   * 是否开启动态模糊
	   * @type {boolean}
	   * @default false
	   */
	
	  this.motionBlur = false;
	  /**
	   * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	   * @type {number}
	   * @default 0.7
	   */
	
	  this.lastFrameAlpha = 0.7;
	  /**
	   * Layer dpr
	   * @type {number}
	   */
	
	  this.dpr = dpr;
	};
	
	Layer.prototype = {
	  constructor: Layer,
	  elCount: 0,
	  __dirty: true,
	  initContext: function () {
	    this.ctx = this.dom.getContext('2d');
	    this.ctx.__currentValues = {};
	    this.ctx.dpr = this.dpr;
	  },
	  createBackBuffer: function () {
	    var dpr = this.dpr;
	    this.domBack = createDom('back-' + this.id, this.painter, dpr);
	    this.ctxBack = this.domBack.getContext('2d');
	    this.ctxBack.__currentValues = {};
	
	    if (dpr != 1) {
	      this.ctxBack.scale(dpr, dpr);
	    }
	  },
	
	  /**
	   * @param  {number} width
	   * @param  {number} height
	   */
	  resize: function (width, height) {
	    var dpr = this.dpr;
	    var dom = this.dom;
	    var domStyle = dom.style;
	    var domBack = this.domBack;
	    domStyle.width = width + 'px';
	    domStyle.height = height + 'px';
	    dom.width = width * dpr;
	    dom.height = height * dpr;
	
	    if (domBack) {
	      domBack.width = width * dpr;
	      domBack.height = height * dpr;
	
	      if (dpr != 1) {
	        this.ctxBack.scale(dpr, dpr);
	      }
	    }
	  },
	
	  /**
	   * 清空该层画布
	   * @param {boolean} clearAll Clear all with out motion blur
	   */
	  clear: function (clearAll) {
	    var dom = this.dom;
	    var ctx = this.ctx;
	    var width = dom.width;
	    var height = dom.height;
	    var clearColor = this.clearColor;
	    var haveMotionBLur = this.motionBlur && !clearAll;
	    var lastFrameAlpha = this.lastFrameAlpha;
	    var dpr = this.dpr;
	
	    if (haveMotionBLur) {
	      if (!this.domBack) {
	        this.createBackBuffer();
	      }
	
	      this.ctxBack.globalCompositeOperation = 'copy';
	      this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);
	    }
	
	    ctx.clearRect(0, 0, width, height);
	
	    if (clearColor) {
	      var clearColorGradientOrPattern; // Gradient
	
	      if (clearColor.colorStops) {
	        // Cache canvas gradient
	        clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {
	          x: 0,
	          y: 0,
	          width: width,
	          height: height
	        });
	        clearColor.__canvasGradient = clearColorGradientOrPattern;
	      } // Pattern
	      else if (clearColor.image) {
	          clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);
	        }
	
	      ctx.save();
	      ctx.fillStyle = clearColorGradientOrPattern || clearColor;
	      ctx.fillRect(0, 0, width, height);
	      ctx.restore();
	    }
	
	    if (haveMotionBLur) {
	      var domBack = this.domBack;
	      ctx.save();
	      ctx.globalAlpha = lastFrameAlpha;
	      ctx.drawImage(domBack, 0, 0, width, height);
	      ctx.restore();
	    }
	  }
	};
	var _default = Layer;
	module.exports = _default;

/***/ }),
/* 28 */
/***/ (function(module, exports) {

	var STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);
	// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);
	
	var Style = function (opts, host) {
	  this.extendFrom(opts, false);
	  this.host = host;
	};
	
	function createLinearGradient(ctx, obj, rect) {
	  var x = obj.x == null ? 0 : obj.x;
	  var x2 = obj.x2 == null ? 1 : obj.x2;
	  var y = obj.y == null ? 0 : obj.y;
	  var y2 = obj.y2 == null ? 0 : obj.y2;
	
	  if (!obj.global) {
	    x = x * rect.width + rect.x;
	    x2 = x2 * rect.width + rect.x;
	    y = y * rect.height + rect.y;
	    y2 = y2 * rect.height + rect.y;
	  }
	
	  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
	  return canvasGradient;
	}
	
	function createRadialGradient(ctx, obj, rect) {
	  var width = rect.width;
	  var height = rect.height;
	  var min = Math.min(width, height);
	  var x = obj.x == null ? 0.5 : obj.x;
	  var y = obj.y == null ? 0.5 : obj.y;
	  var r = obj.r == null ? 0.5 : obj.r;
	
	  if (!obj.global) {
	    x = x * width + rect.x;
	    y = y * height + rect.y;
	    r = r * min;
	  }
	
	  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
	  return canvasGradient;
	}
	
	Style.prototype = {
	  constructor: Style,
	
	  /**
	   * @type {module:zrender/graphic/Displayable}
	   */
	  host: null,
	
	  /**
	   * @type {string}
	   */
	  fill: '#000',
	
	  /**
	   * @type {string}
	   */
	  stroke: null,
	
	  /**
	   * @type {number}
	   */
	  opacity: 1,
	
	  /**
	   * @type {Array.<number>}
	   */
	  lineDash: null,
	
	  /**
	   * @type {number}
	   */
	  lineDashOffset: 0,
	
	  /**
	   * @type {number}
	   */
	  shadowBlur: 0,
	
	  /**
	   * @type {number}
	   */
	  shadowOffsetX: 0,
	
	  /**
	   * @type {number}
	   */
	  shadowOffsetY: 0,
	
	  /**
	   * @type {number}
	   */
	  lineWidth: 1,
	
	  /**
	   * If stroke ignore scale
	   * @type {Boolean}
	   */
	  strokeNoScale: false,
	  // Bounding rect text configuration
	  // Not affected by element transform
	
	  /**
	   * @type {string}
	   */
	  text: null,
	
	  /**
	   * If `fontSize` or `fontFamily` exists, `font` will be reset by
	   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.
	   * So do not visit it directly in upper application (like echarts),
	   * but use `contain/text#makeFont` instead.
	   * @type {string}
	   */
	  font: null,
	
	  /**
	   * The same as font. Use font please.
	   * @deprecated
	   * @type {string}
	   */
	  textFont: null,
	
	  /**
	   * It helps merging respectively, rather than parsing an entire font string.
	   * @type {string}
	   */
	  fontStyle: null,
	
	  /**
	   * It helps merging respectively, rather than parsing an entire font string.
	   * @type {string}
	   */
	  fontWeight: null,
	
	  /**
	   * It helps merging respectively, rather than parsing an entire font string.
	   * Should be 12 but not '12px'.
	   * @type {number}
	   */
	  fontSize: null,
	
	  /**
	   * It helps merging respectively, rather than parsing an entire font string.
	   * @type {string}
	   */
	  fontFamily: null,
	
	  /**
	   * Reserved for special functinality, like 'hr'.
	   * @type {string}
	   */
	  textTag: null,
	
	  /**
	   * @type {string}
	   */
	  textFill: '#000',
	
	  /**
	   * @type {string}
	   */
	  textStroke: null,
	
	  /**
	   * @type {number}
	   */
	  textWidth: null,
	
	  /**
	   * Only for textBackground.
	   * @type {number}
	   */
	  textHeight: null,
	
	  /**
	   * textStroke may be set as some color as a default
	   * value in upper applicaion, where the default value
	   * of textStrokeWidth should be 0 to make sure that
	   * user can choose to do not use text stroke.
	   * @type {number}
	   */
	  textStrokeWidth: 0,
	
	  /**
	   * @type {number}
	   */
	  textLineHeight: null,
	
	  /**
	   * 'inside', 'left', 'right', 'top', 'bottom'
	   * [x, y]
	   * Based on x, y of rect.
	   * @type {string|Array.<number>}
	   * @default 'inside'
	   */
	  textPosition: 'inside',
	
	  /**
	   * If not specified, use the boundingRect of a `displayable`.
	   * @type {Object}
	   */
	  textRect: null,
	
	  /**
	   * [x, y]
	   * @type {Array.<number>}
	   */
	  textOffset: null,
	
	  /**
	   * @type {string}
	   */
	  textAlign: null,
	
	  /**
	   * @type {string}
	   */
	  textVerticalAlign: null,
	
	  /**
	   * @type {number}
	   */
	  textDistance: 5,
	
	  /**
	   * @type {string}
	   */
	  textShadowColor: 'transparent',
	
	  /**
	   * @type {number}
	   */
	  textShadowBlur: 0,
	
	  /**
	   * @type {number}
	   */
	  textShadowOffsetX: 0,
	
	  /**
	   * @type {number}
	   */
	  textShadowOffsetY: 0,
	
	  /**
	   * @type {string}
	   */
	  textBoxShadowColor: 'transparent',
	
	  /**
	   * @type {number}
	   */
	  textBoxShadowBlur: 0,
	
	  /**
	   * @type {number}
	   */
	  textBoxShadowOffsetX: 0,
	
	  /**
	   * @type {number}
	   */
	  textBoxShadowOffsetY: 0,
	
	  /**
	   * Whether transform text.
	   * Only useful in Path and Image element
	   * @type {boolean}
	   */
	  transformText: false,
	
	  /**
	   * Text rotate around position of Path or Image
	   * Only useful in Path and Image element and transformText is false.
	   */
	  textRotation: 0,
	
	  /**
	   * Text origin of text rotation, like [10, 40].
	   * Based on x, y of rect.
	   * Useful in label rotation of circular symbol.
	   * By default, this origin is textPosition.
	   * Can be 'center'.
	   * @type {string|Array.<number>}
	   */
	  textOrigin: null,
	
	  /**
	   * @type {string}
	   */
	  textBackgroundColor: null,
	
	  /**
	   * @type {string}
	   */
	  textBorderColor: null,
	
	  /**
	   * @type {number}
	   */
	  textBorderWidth: 0,
	
	  /**
	   * @type {number}
	   */
	  textBorderRadius: 0,
	
	  /**
	   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`
	   * @type {number|Array.<number>}
	   */
	  textPadding: null,
	
	  /**
	   * Text styles for rich text.
	   * @type {Object}
	   */
	  rich: null,
	
	  /**
	   * {outerWidth, outerHeight, ellipsis, placeholder}
	   * @type {Object}
	   */
	  truncate: null,
	
	  /**
	   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
	   * @type {string}
	   */
	  blend: null,
	
	  /**
	   * @param {CanvasRenderingContext2D} ctx
	   */
	  bind: function (ctx, el, prevEl) {
	    var style = this;
	    var prevStyle = prevEl && prevEl.style;
	    var firstDraw = !prevStyle;
	
	    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
	      var prop = STYLE_COMMON_PROPS[i];
	      var styleName = prop[0];
	
	      if (firstDraw || style[styleName] !== prevStyle[styleName]) {
	        // FIXME Invalid property value will cause style leak from previous element.
	        ctx[styleName] = style[styleName] || prop[1];
	      }
	    }
	
	    if (firstDraw || style.fill !== prevStyle.fill) {
	      ctx.fillStyle = style.fill;
	    }
	
	    if (firstDraw || style.stroke !== prevStyle.stroke) {
	      ctx.strokeStyle = style.stroke;
	    }
	
	    if (firstDraw || style.opacity !== prevStyle.opacity) {
	      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
	    }
	
	    if (firstDraw || style.blend !== prevStyle.blend) {
	      ctx.globalCompositeOperation = style.blend || 'source-over';
	    }
	
	    if (this.hasStroke()) {
	      var lineWidth = style.lineWidth;
	      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);
	    }
	  },
	  hasFill: function () {
	    var fill = this.fill;
	    return fill != null && fill !== 'none';
	  },
	  hasStroke: function () {
	    var stroke = this.stroke;
	    return stroke != null && stroke !== 'none' && this.lineWidth > 0;
	  },
	
	  /**
	   * Extend from other style
	   * @param {zrender/graphic/Style} otherStyle
	   * @param {boolean} overwrite true: overwrirte any way.
	   *                            false: overwrite only when !target.hasOwnProperty
	   *                            others: overwrite when property is not null/undefined.
	   */
	  extendFrom: function (otherStyle, overwrite) {
	    if (otherStyle) {
	      for (var name in otherStyle) {
	        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {
	          this[name] = otherStyle[name];
	        }
	      }
	    }
	  },
	
	  /**
	   * Batch setting style with a given object
	   * @param {Object|string} obj
	   * @param {*} [obj]
	   */
	  set: function (obj, value) {
	    if (typeof obj === 'string') {
	      this[obj] = value;
	    } else {
	      this.extendFrom(obj, true);
	    }
	  },
	
	  /**
	   * Clone
	   * @return {zrender/graphic/Style} [description]
	   */
	  clone: function () {
	    var newStyle = new this.constructor();
	    newStyle.extendFrom(this, true);
	    return newStyle;
	  },
	  getGradient: function (ctx, obj, rect) {
	    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;
	    var canvasGradient = method(ctx, obj, rect);
	    var colorStops = obj.colorStops;
	
	    for (var i = 0; i < colorStops.length; i++) {
	      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
	    }
	
	    return canvasGradient;
	  }
	};
	var styleProto = Style.prototype;
	
	for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
	  var prop = STYLE_COMMON_PROPS[i];
	
	  if (!(prop[0] in styleProto)) {
	    styleProto[prop[0]] = prop[1];
	  }
	} // Provide for others
	
	
	Style.getGradient = styleProto.getGradient;
	var _default = Style;
	module.exports = _default;

/***/ }),
/* 29 */
/***/ (function(module, exports) {

	var Pattern = function (image, repeat) {
	  // Should do nothing more in this constructor. Because gradient can be
	  // declard by `color: {image: ...}`, where this constructor will not be called.
	  this.image = image;
	  this.repeat = repeat; // Can be cloned
	
	  this.type = 'pattern';
	};
	
	Pattern.prototype.getCanvasPattern = function (ctx) {
	  return ctx.createPattern(this.image, this.repeat || 'repeat');
	};
	
	var _default = Pattern;
	module.exports = _default;

/***/ }),
/* 30 */
/***/ (function(module, exports) {

	var _default = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809
	window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {
	  setTimeout(func, 16);
	};
	
	module.exports = _default;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	var Displayable = __webpack_require__(32);
	
	var BoundingRect = __webpack_require__(24);
	
	var zrUtil = __webpack_require__(6);
	
	var imageHelper = __webpack_require__(36);
	
	/**
	 * @alias zrender/graphic/Image
	 * @extends module:zrender/graphic/Displayable
	 * @constructor
	 * @param {Object} opts
	 */
	function ZImage(opts) {
	  Displayable.call(this, opts);
	}
	
	ZImage.prototype = {
	  constructor: ZImage,
	  type: 'image',
	  brush: function (ctx, prevEl) {
	    var style = this.style;
	    var src = style.image; // Must bind each time
	
	    style.bind(ctx, this, prevEl);
	    var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);
	
	    if (!image || !imageHelper.isImageReady(image)) {
	      return;
	    } // 图片已经加载完成
	    // if (image.nodeName.toUpperCase() == 'IMG') {
	    //     if (!image.complete) {
	    //         return;
	    //     }
	    // }
	    // Else is canvas
	
	
	    var x = style.x || 0;
	    var y = style.y || 0;
	    var width = style.width;
	    var height = style.height;
	    var aspect = image.width / image.height;
	
	    if (width == null && height != null) {
	      // Keep image/height ratio
	      width = height * aspect;
	    } else if (height == null && width != null) {
	      height = width / aspect;
	    } else if (width == null && height == null) {
	      width = image.width;
	      height = image.height;
	    } // 设置transform
	
	
	    this.setTransform(ctx);
	
	    if (style.sWidth && style.sHeight) {
	      var sx = style.sx || 0;
	      var sy = style.sy || 0;
	      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
	    } else if (style.sx && style.sy) {
	      var sx = style.sx;
	      var sy = style.sy;
	      var sWidth = width - sx;
	      var sHeight = height - sy;
	      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
	    } else {
	      ctx.drawImage(image, x, y, width, height);
	    }
	
	    this.restoreTransform(ctx); // Draw rect text
	
	    if (style.text != null) {
	      this.drawRectText(ctx, this.getBoundingRect());
	    }
	  },
	  getBoundingRect: function () {
	    var style = this.style;
	
	    if (!this._rect) {
	      this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);
	    }
	
	    return this._rect;
	  }
	};
	zrUtil.inherits(ZImage, Displayable);
	var _default = ZImage;
	module.exports = _default;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(6);
	
	var Style = __webpack_require__(28);
	
	var Element = __webpack_require__(13);
	
	var RectText = __webpack_require__(33);
	
	/**
	 * 可绘制的图形基类
	 * Base class of all displayable graphic objects
	 * @module zrender/graphic/Displayable
	 */
	
	/**
	 * @alias module:zrender/graphic/Displayable
	 * @extends module:zrender/Element
	 * @extends module:zrender/graphic/mixin/RectText
	 */
	function Displayable(opts) {
	  opts = opts || {};
	  Element.call(this, opts); // Extend properties
	
	  for (var name in opts) {
	    if (opts.hasOwnProperty(name) && name !== 'style') {
	      this[name] = opts[name];
	    }
	  }
	  /**
	   * @type {module:zrender/graphic/Style}
	   */
	
	
	  this.style = new Style(opts.style, this);
	  this._rect = null; // Shapes for cascade clipping.
	
	  this.__clipPaths = []; // FIXME Stateful must be mixined after style is setted
	  // Stateful.call(this, opts);
	}
	
	Displayable.prototype = {
	  constructor: Displayable,
	  type: 'displayable',
	
	  /**
	   * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制
	   * Dirty flag. From which painter will determine if this displayable object needs brush
	   * @name module:zrender/graphic/Displayable#__dirty
	   * @type {boolean}
	   */
	  __dirty: true,
	
	  /**
	   * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件
	   * If ignore drawing of the displayable object. Mouse event will still be triggered
	   * @name module:/zrender/graphic/Displayable#invisible
	   * @type {boolean}
	   * @default false
	   */
	  invisible: false,
	
	  /**
	   * @name module:/zrender/graphic/Displayable#z
	   * @type {number}
	   * @default 0
	   */
	  z: 0,
	
	  /**
	   * @name module:/zrender/graphic/Displayable#z
	   * @type {number}
	   * @default 0
	   */
	  z2: 0,
	
	  /**
	   * z层level，决定绘画在哪层canvas中
	   * @name module:/zrender/graphic/Displayable#zlevel
	   * @type {number}
	   * @default 0
	   */
	  zlevel: 0,
	
	  /**
	   * 是否可拖拽
	   * @name module:/zrender/graphic/Displayable#draggable
	   * @type {boolean}
	   * @default false
	   */
	  draggable: false,
	
	  /**
	   * 是否正在拖拽
	   * @name module:/zrender/graphic/Displayable#draggable
	   * @type {boolean}
	   * @default false
	   */
	  dragging: false,
	
	  /**
	   * 是否相应鼠标事件
	   * @name module:/zrender/graphic/Displayable#silent
	   * @type {boolean}
	   * @default false
	   */
	  silent: false,
	
	  /**
	   * If enable culling
	   * @type {boolean}
	   * @default false
	   */
	  culling: false,
	
	  /**
	   * Mouse cursor when hovered
	   * @name module:/zrender/graphic/Displayable#cursor
	   * @type {string}
	   */
	  cursor: 'pointer',
	
	  /**
	   * If hover area is bounding rect
	   * @name module:/zrender/graphic/Displayable#rectHover
	   * @type {string}
	   */
	  rectHover: false,
	
	  /**
	   * Render the element progressively when the value >= 0,
	   * usefull for large data.
	   * @type {number}
	   */
	  progressive: -1,
	  beforeBrush: function (ctx) {},
	  afterBrush: function (ctx) {},
	
	  /**
	   * 图形绘制方法
	   * @param {CanvasRenderingContext2D} ctx
	   */
	  // Interface
	  brush: function (ctx, prevEl) {},
	
	  /**
	   * 获取最小包围盒
	   * @return {module:zrender/core/BoundingRect}
	   */
	  // Interface
	  getBoundingRect: function () {},
	
	  /**
	   * 判断坐标 x, y 是否在图形上
	   * If displayable element contain coord x, y
	   * @param  {number} x
	   * @param  {number} y
	   * @return {boolean}
	   */
	  contain: function (x, y) {
	    return this.rectContain(x, y);
	  },
	
	  /**
	   * @param  {Function} cb
	   * @param  {}   context
	   */
	  traverse: function (cb, context) {
	    cb.call(context, this);
	  },
	
	  /**
	   * 判断坐标 x, y 是否在图形的包围盒上
	   * If bounding rect of element contain coord x, y
	   * @param  {number} x
	   * @param  {number} y
	   * @return {boolean}
	   */
	  rectContain: function (x, y) {
	    var coord = this.transformCoordToLocal(x, y);
	    var rect = this.getBoundingRect();
	    return rect.contain(coord[0], coord[1]);
	  },
	
	  /**
	   * 标记图形元素为脏，并且在下一帧重绘
	   * Mark displayable element dirty and refresh next frame
	   */
	  dirty: function () {
	    this.__dirty = true;
	    this._rect = null;
	    this.__zr && this.__zr.refresh();
	  },
	
	  /**
	   * 图形是否会触发事件
	   * If displayable object binded any event
	   * @return {boolean}
	   */
	  // TODO, 通过 bind 绑定的事件
	  // isSilent: function () {
	  //     return !(
	  //         this.hoverable || this.draggable
	  //         || this.onmousemove || this.onmouseover || this.onmouseout
	  //         || this.onmousedown || this.onmouseup || this.onclick
	  //         || this.ondragenter || this.ondragover || this.ondragleave
	  //         || this.ondrop
	  //     );
	  // },
	
	  /**
	   * Alias for animate('style')
	   * @param {boolean} loop
	   */
	  animateStyle: function (loop) {
	    return this.animate('style', loop);
	  },
	  attrKV: function (key, value) {
	    if (key !== 'style') {
	      Element.prototype.attrKV.call(this, key, value);
	    } else {
	      this.style.set(value);
	    }
	  },
	
	  /**
	   * @param {Object|string} key
	   * @param {*} value
	   */
	  setStyle: function (key, value) {
	    this.style.set(key, value);
	    this.dirty(false);
	    return this;
	  },
	
	  /**
	   * Use given style object
	   * @param  {Object} obj
	   */
	  useStyle: function (obj) {
	    this.style = new Style(obj, this);
	    this.dirty(false);
	    return this;
	  }
	};
	zrUtil.inherits(Displayable, Element);
	zrUtil.mixin(Displayable, RectText); // zrUtil.mixin(Displayable, Stateful);
	
	var _default = Displayable;
	module.exports = _default;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	var textHelper = __webpack_require__(34);
	
	var BoundingRect = __webpack_require__(24);
	
	/**
	 * Mixin for drawing text in a element bounding rect
	 * @module zrender/mixin/RectText
	 */
	var tmpRect = new BoundingRect();
	
	var RectText = function () {};
	
	RectText.prototype = {
	  constructor: RectText,
	
	  /**
	   * Draw text in a rect with specified position.
	   * @param  {CanvasRenderingContext2D} ctx
	   * @param  {Object} rect Displayable rect
	   */
	  drawRectText: function (ctx, rect) {
	    var style = this.style;
	    rect = style.textRect || rect; // Optimize, avoid normalize every time.
	
	    this.__dirty && textHelper.normalizeTextStyle(style, true);
	    var text = style.text; // Convert to string
	
	    text != null && (text += '');
	
	    if (!textHelper.needDrawText(text, style)) {
	      return;
	    } // FIXME
	
	
	    ctx.save(); // Transform rect to view space
	
	    var transform = this.transform;
	
	    if (!style.transformText) {
	      if (transform) {
	        tmpRect.copy(rect);
	        tmpRect.applyTransform(transform);
	        rect = tmpRect;
	      }
	    } else {
	      this.setTransform(ctx);
	    } // transformText and textRotation can not be used at the same time.
	
	
	    textHelper.renderText(this, ctx, text, style, rect);
	    ctx.restore();
	  }
	};
	var _default = RectText;
	module.exports = _default;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	var _util = __webpack_require__(6);
	
	var retrieve2 = _util.retrieve2;
	var retrieve3 = _util.retrieve3;
	var each = _util.each;
	var normalizeCssArray = _util.normalizeCssArray;
	var isString = _util.isString;
	var isObject = _util.isObject;
	
	var textContain = __webpack_require__(35);
	
	var roundRectHelper = __webpack_require__(37);
	
	var imageHelper = __webpack_require__(36);
	
	// TODO: Have not support 'start', 'end' yet.
	var VALID_TEXT_ALIGN = {
	  left: 1,
	  right: 1,
	  center: 1
	};
	var VALID_TEXT_VERTICAL_ALIGN = {
	  top: 1,
	  bottom: 1,
	  middle: 1
	};
	/**
	 * @param {module:zrender/graphic/Style} style
	 * @return {module:zrender/graphic/Style} The input style.
	 */
	
	function normalizeTextStyle(style) {
	  normalizeStyle(style);
	  each(style.rich, normalizeStyle);
	  return style;
	}
	
	function normalizeStyle(style) {
	  if (style) {
	    style.font = textContain.makeFont(style);
	    var textAlign = style.textAlign;
	    textAlign === 'middle' && (textAlign = 'center');
	    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.
	
	    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;
	    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');
	    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';
	    var textPadding = style.textPadding;
	
	    if (textPadding) {
	      style.textPadding = normalizeCssArray(style.textPadding);
	    }
	  }
	}
	/**
	 * @param {CanvasRenderingContext2D} ctx
	 * @param {string} text
	 * @param {module:zrender/graphic/Style} style
	 * @param {Object|boolean} [rect] {x, y, width, height}
	 *                  If set false, rect text is not used.
	 */
	
	
	function renderText(hostEl, ctx, text, style, rect) {
	  style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);
	}
	
	function renderPlainText(hostEl, ctx, text, style, rect) {
	  var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);
	  var textPadding = style.textPadding;
	  var contentBlock = hostEl.__textCotentBlock;
	
	  if (!contentBlock || hostEl.__dirty) {
	    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, font, textPadding, style.truncate);
	  }
	
	  var outerHeight = contentBlock.outerHeight;
	  var textLines = contentBlock.lines;
	  var lineHeight = contentBlock.lineHeight;
	  var boxPos = getBoxPosition(outerHeight, style, rect);
	  var baseX = boxPos.baseX;
	  var baseY = boxPos.baseY;
	  var textAlign = boxPos.textAlign;
	  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.
	
	  applyTextRotation(ctx, style, rect, baseX, baseY);
	  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
	  var textX = baseX;
	  var textY = boxY;
	  var needDrawBg = needDrawBackground(style);
	
	  if (needDrawBg || textPadding) {
	    // Consider performance, do not call getTextWidth util necessary.
	    var textWidth = textContain.getWidth(text, font);
	    var outerWidth = textWidth;
	    textPadding && (outerWidth += textPadding[1] + textPadding[3]);
	    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
	    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);
	
	    if (textPadding) {
	      textX = getTextXForPadding(baseX, textAlign, textPadding);
	      textY += textPadding[0];
	    }
	  }
	
	  setCtx(ctx, 'textAlign', textAlign || 'left'); // Force baseline to be "middle". Otherwise, if using "top", the
	  // text will offset downward a little bit in font "Microsoft YaHei".
	
	  setCtx(ctx, 'textBaseline', 'middle'); // Always set shadowBlur and shadowOffset to avoid leak from displayable.
	
	  setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);
	  setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');
	  setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);
	  setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0); // `textBaseline` is set as 'middle'.
	
	  textY += lineHeight / 2;
	  var textStrokeWidth = style.textStrokeWidth;
	  var textStroke = getStroke(style.textStroke, textStrokeWidth);
	  var textFill = getFill(style.textFill);
	
	  if (textStroke) {
	    setCtx(ctx, 'lineWidth', textStrokeWidth);
	    setCtx(ctx, 'strokeStyle', textStroke);
	  }
	
	  if (textFill) {
	    setCtx(ctx, 'fillStyle', textFill);
	  }
	
	  for (var i = 0; i < textLines.length; i++) {
	    // Fill after stroke so the outline will not cover the main part.
	    textStroke && ctx.strokeText(textLines[i], textX, textY);
	    textFill && ctx.fillText(textLines[i], textX, textY);
	    textY += lineHeight;
	  }
	}
	
	function renderRichText(hostEl, ctx, text, style, rect) {
	  var contentBlock = hostEl.__textCotentBlock;
	
	  if (!contentBlock || hostEl.__dirty) {
	    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);
	  }
	
	  drawRichText(hostEl, ctx, contentBlock, style, rect);
	}
	
	function drawRichText(hostEl, ctx, contentBlock, style, rect) {
	  var contentWidth = contentBlock.width;
	  var outerWidth = contentBlock.outerWidth;
	  var outerHeight = contentBlock.outerHeight;
	  var textPadding = style.textPadding;
	  var boxPos = getBoxPosition(outerHeight, style, rect);
	  var baseX = boxPos.baseX;
	  var baseY = boxPos.baseY;
	  var textAlign = boxPos.textAlign;
	  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.
	
	  applyTextRotation(ctx, style, rect, baseX, baseY);
	  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
	  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
	  var xLeft = boxX;
	  var lineTop = boxY;
	
	  if (textPadding) {
	    xLeft += textPadding[3];
	    lineTop += textPadding[0];
	  }
	
	  var xRight = xLeft + contentWidth;
	  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);
	
	  for (var i = 0; i < contentBlock.lines.length; i++) {
	    var line = contentBlock.lines[i];
	    var tokens = line.tokens;
	    var tokenCount = tokens.length;
	    var lineHeight = line.lineHeight;
	    var usedWidth = line.width;
	    var leftIndex = 0;
	    var lineXLeft = xLeft;
	    var lineXRight = xRight;
	    var rightIndex = tokenCount - 1;
	    var token;
	
	    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {
	      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');
	      usedWidth -= token.width;
	      lineXLeft += token.width;
	      leftIndex++;
	    }
	
	    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {
	      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');
	      usedWidth -= token.width;
	      lineXRight -= token.width;
	      rightIndex--;
	    } // The other tokens are placed as textAlign 'center' if there is enough space.
	
	
	    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;
	
	    while (leftIndex <= rightIndex) {
	      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.
	
	      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');
	      lineXLeft += token.width;
	      leftIndex++;
	    }
	
	    lineTop += lineHeight;
	  }
	}
	
	function applyTextRotation(ctx, style, rect, x, y) {
	  // textRotation only apply in RectText.
	  if (rect && style.textRotation) {
	    var origin = style.textOrigin;
	
	    if (origin === 'center') {
	      x = rect.width / 2 + rect.x;
	      y = rect.height / 2 + rect.y;
	    } else if (origin) {
	      x = origin[0] + rect.x;
	      y = origin[1] + rect.y;
	    }
	
	    ctx.translate(x, y); // Positive: anticlockwise
	
	    ctx.rotate(-style.textRotation);
	    ctx.translate(-x, -y);
	  }
	}
	
	function placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {
	  var tokenStyle = style.rich[token.styleName] || {}; // 'ctx.textBaseline' is always set as 'middle', for sake of
	  // the bias of "Microsoft YaHei".
	
	  var textVerticalAlign = token.textVerticalAlign;
	  var y = lineTop + lineHeight / 2;
	
	  if (textVerticalAlign === 'top') {
	    y = lineTop + token.height / 2;
	  } else if (textVerticalAlign === 'bottom') {
	    y = lineTop + lineHeight - token.height / 2;
	  }
	
	  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);
	  var textPadding = token.textPadding;
	
	  if (textPadding) {
	    x = getTextXForPadding(x, textAlign, textPadding);
	    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;
	  }
	
	  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));
	  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');
	  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));
	  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));
	  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be "middle". Otherwise, if using "top", the
	  // text will offset downward a little bit in font "Microsoft YaHei".
	
	  setCtx(ctx, 'textBaseline', 'middle');
	  setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);
	  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);
	  var textFill = getFill(tokenStyle.textFill || style.textFill);
	  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.
	
	  if (textStroke) {
	    setCtx(ctx, 'lineWidth', textStrokeWidth);
	    setCtx(ctx, 'strokeStyle', textStroke);
	    ctx.strokeText(token.text, x, y);
	  }
	
	  if (textFill) {
	    setCtx(ctx, 'fillStyle', textFill);
	    ctx.fillText(token.text, x, y);
	  }
	}
	
	function needDrawBackground(style) {
	  return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;
	} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}
	// shape: {x, y, width, height}
	
	
	function drawBackground(hostEl, ctx, style, x, y, width, height) {
	  var textBackgroundColor = style.textBackgroundColor;
	  var textBorderWidth = style.textBorderWidth;
	  var textBorderColor = style.textBorderColor;
	  var isPlainBg = isString(textBackgroundColor);
	  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);
	  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');
	  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);
	  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);
	
	  if (isPlainBg || textBorderWidth && textBorderColor) {
	    ctx.beginPath();
	    var textBorderRadius = style.textBorderRadius;
	
	    if (!textBorderRadius) {
	      ctx.rect(x, y, width, height);
	    } else {
	      roundRectHelper.buildPath(ctx, {
	        x: x,
	        y: y,
	        width: width,
	        height: height,
	        r: textBorderRadius
	      });
	    }
	
	    ctx.closePath();
	  }
	
	  if (isPlainBg) {
	    setCtx(ctx, 'fillStyle', textBackgroundColor);
	    ctx.fill();
	  } else if (isObject(textBackgroundColor)) {
	    var image = textBackgroundColor.image;
	    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);
	
	    if (image && imageHelper.isImageReady(image)) {
	      ctx.drawImage(image, x, y, width, height);
	    }
	  }
	
	  if (textBorderWidth && textBorderColor) {
	    setCtx(ctx, 'lineWidth', textBorderWidth);
	    setCtx(ctx, 'strokeStyle', textBorderColor);
	    ctx.stroke();
	  }
	}
	
	function onBgImageLoaded(image, textBackgroundColor) {
	  // Replace image, so that `contain/text.js#parseRichText`
	  // will get correct result in next tick.
	  textBackgroundColor.image = image;
	}
	
	function getBoxPosition(blockHeiht, style, rect) {
	  var baseX = style.x || 0;
	  var baseY = style.y || 0;
	  var textAlign = style.textAlign;
	  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord
	
	  if (rect) {
	    var textPosition = style.textPosition;
	
	    if (textPosition instanceof Array) {
	      // Percent
	      baseX = rect.x + parsePercent(textPosition[0], rect.width);
	      baseY = rect.y + parsePercent(textPosition[1], rect.height);
	    } else {
	      var res = textContain.adjustTextPositionOnRect(textPosition, rect, style.textDistance);
	      baseX = res.x;
	      baseY = res.y; // Default align and baseline when has textPosition
	
	      textAlign = textAlign || res.textAlign;
	      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;
	    } // textOffset is only support in RectText, otherwise
	    // we have to adjust boundingRect for textOffset.
	
	
	    var textOffset = style.textOffset;
	
	    if (textOffset) {
	      baseX += textOffset[0];
	      baseY += textOffset[1];
	    }
	  }
	
	  return {
	    baseX: baseX,
	    baseY: baseY,
	    textAlign: textAlign,
	    textVerticalAlign: textVerticalAlign
	  };
	}
	
	function setCtx(ctx, prop, value) {
	  // FIXME ??? performance try
	  // if (ctx.__currentValues[prop] !== value) {
	  // ctx[prop] = ctx.__currentValues[prop] = value;
	  ctx[prop] = value; // }
	
	  return ctx[prop];
	}
	/**
	 * @param {string} [stroke] If specified, do not check style.textStroke.
	 * @param {string} [lineWidth] If specified, do not check style.textStroke.
	 * @param {number} style
	 */
	
	
	function getStroke(stroke, lineWidth) {
	  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?
	  : stroke.image || stroke.colorStops ? '#000' : stroke;
	}
	
	function getFill(fill) {
	  return fill == null || fill === 'none' ? null // TODO pattern and gradient?
	  : fill.image || fill.colorStops ? '#000' : fill;
	}
	
	function parsePercent(value, maxValue) {
	  if (typeof value === 'string') {
	    if (value.lastIndexOf('%') >= 0) {
	      return parseFloat(value) / 100 * maxValue;
	    }
	
	    return parseFloat(value);
	  }
	
	  return value;
	}
	
	function getTextXForPadding(x, textAlign, textPadding) {
	  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
	}
	/**
	 * @param {string} text
	 * @param {module:zrender/Style} style
	 * @return {boolean}
	 */
	
	
	function needDrawText(text, style) {
	  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);
	}
	
	exports.normalizeTextStyle = normalizeTextStyle;
	exports.renderText = renderText;
	exports.getStroke = getStroke;
	exports.getFill = getFill;
	exports.needDrawText = needDrawText;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	var BoundingRect = __webpack_require__(24);
	
	var imageHelper = __webpack_require__(36);
	
	var _util = __webpack_require__(6);
	
	var getContext = _util.getContext;
	var extend = _util.extend;
	var retrieve2 = _util.retrieve2;
	var retrieve3 = _util.retrieve3;
	var textWidthCache = {};
	var textWidthCacheCounter = 0;
	var TEXT_CACHE_MAX = 5000;
	var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
	var DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.
	
	var methods = {};
	
	function $override(name, fn) {
	  methods[name] = fn;
	}
	/**
	 * @public
	 * @param {string} text
	 * @param {string} font
	 * @return {number} width
	 */
	
	
	function getWidth(text, font) {
	  font = font || DEFAULT_FONT;
	  var key = text + ':' + font;
	
	  if (textWidthCache[key]) {
	    return textWidthCache[key];
	  }
	
	  var textLines = (text + '').split('\n');
	  var width = 0;
	
	  for (var i = 0, l = textLines.length; i < l; i++) {
	    // textContain.measureText may be overrided in SVG or VML
	    width = Math.max(measureText(textLines[i], font).width, width);
	  }
	
	  if (textWidthCacheCounter > TEXT_CACHE_MAX) {
	    textWidthCacheCounter = 0;
	    textWidthCache = {};
	  }
	
	  textWidthCacheCounter++;
	  textWidthCache[key] = width;
	  return width;
	}
	/**
	 * @public
	 * @param {string} text
	 * @param {string} font
	 * @param {string} [textAlign='left']
	 * @param {string} [textVerticalAlign='top']
	 * @param {Array.<number>} [textPadding]
	 * @param {Object} [rich]
	 * @param {Object} [truncate]
	 * @return {Object} {x, y, width, height, lineHeight}
	 */
	
	
	function getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
	  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);
	}
	
	function getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {
	  var contentBlock = parsePlainText(text, font, textPadding, truncate);
	  var outerWidth = getWidth(text, font);
	
	  if (textPadding) {
	    outerWidth += textPadding[1] + textPadding[3];
	  }
	
	  var outerHeight = contentBlock.outerHeight;
	  var x = adjustTextX(0, outerWidth, textAlign);
	  var y = adjustTextY(0, outerHeight, textVerticalAlign);
	  var rect = new BoundingRect(x, y, outerWidth, outerHeight);
	  rect.lineHeight = contentBlock.lineHeight;
	  return rect;
	}
	
	function getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
	  var contentBlock = parseRichText(text, {
	    rich: rich,
	    truncate: truncate,
	    font: font,
	    textAlign: textAlign,
	    textPadding: textPadding
	  });
	  var outerWidth = contentBlock.outerWidth;
	  var outerHeight = contentBlock.outerHeight;
	  var x = adjustTextX(0, outerWidth, textAlign);
	  var y = adjustTextY(0, outerHeight, textVerticalAlign);
	  return new BoundingRect(x, y, outerWidth, outerHeight);
	}
	/**
	 * @public
	 * @param {number} x
	 * @param {number} width
	 * @param {string} [textAlign='left']
	 * @return {number} Adjusted x.
	 */
	
	
	function adjustTextX(x, width, textAlign) {
	  // FIXME Right to left language
	  if (textAlign === 'right') {
	    x -= width;
	  } else if (textAlign === 'center') {
	    x -= width / 2;
	  }
	
	  return x;
	}
	/**
	 * @public
	 * @param {number} y
	 * @param {number} height
	 * @param {string} [textVerticalAlign='top']
	 * @return {number} Adjusted y.
	 */
	
	
	function adjustTextY(y, height, textVerticalAlign) {
	  if (textVerticalAlign === 'middle') {
	    y -= height / 2;
	  } else if (textVerticalAlign === 'bottom') {
	    y -= height;
	  }
	
	  return y;
	}
	/**
	 * @public
	 * @param {stirng} textPosition
	 * @param {Object} rect {x, y, width, height}
	 * @param {number} distance
	 * @return {Object} {x, y, textAlign, textVerticalAlign}
	 */
	
	
	function adjustTextPositionOnRect(textPosition, rect, distance) {
	  var x = rect.x;
	  var y = rect.y;
	  var height = rect.height;
	  var width = rect.width;
	  var halfHeight = height / 2;
	  var textAlign = 'left';
	  var textVerticalAlign = 'top';
	
	  switch (textPosition) {
	    case 'left':
	      x -= distance;
	      y += halfHeight;
	      textAlign = 'right';
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'right':
	      x += distance + width;
	      y += halfHeight;
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'top':
	      x += width / 2;
	      y -= distance;
	      textAlign = 'center';
	      textVerticalAlign = 'bottom';
	      break;
	
	    case 'bottom':
	      x += width / 2;
	      y += height + distance;
	      textAlign = 'center';
	      break;
	
	    case 'inside':
	      x += width / 2;
	      y += halfHeight;
	      textAlign = 'center';
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'insideLeft':
	      x += distance;
	      y += halfHeight;
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'insideRight':
	      x += width - distance;
	      y += halfHeight;
	      textAlign = 'right';
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'insideTop':
	      x += width / 2;
	      y += distance;
	      textAlign = 'center';
	      break;
	
	    case 'insideBottom':
	      x += width / 2;
	      y += height - distance;
	      textAlign = 'center';
	      textVerticalAlign = 'bottom';
	      break;
	
	    case 'insideTopLeft':
	      x += distance;
	      y += distance;
	      break;
	
	    case 'insideTopRight':
	      x += width - distance;
	      y += distance;
	      textAlign = 'right';
	      break;
	
	    case 'insideBottomLeft':
	      x += distance;
	      y += height - distance;
	      textVerticalAlign = 'bottom';
	      break;
	
	    case 'insideBottomRight':
	      x += width - distance;
	      y += height - distance;
	      textAlign = 'right';
	      textVerticalAlign = 'bottom';
	      break;
	  }
	
	  return {
	    x: x,
	    y: y,
	    textAlign: textAlign,
	    textVerticalAlign: textVerticalAlign
	  };
	}
	/**
	 * Show ellipsis if overflow.
	 *
	 * @public
	 * @param  {string} text
	 * @param  {string} containerWidth
	 * @param  {string} font
	 * @param  {number} [ellipsis='...']
	 * @param  {Object} [options]
	 * @param  {number} [options.maxIterations=3]
	 * @param  {number} [options.minChar=0] If truncate result are less
	 *                  then minChar, ellipsis will not show, which is
	 *                  better for user hint in some cases.
	 * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.
	 * @return {string}
	 */
	
	
	function truncateText(text, containerWidth, font, ellipsis, options) {
	  if (!containerWidth) {
	    return '';
	  }
	
	  var textLines = (text + '').split('\n');
	  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME
	  // It is not appropriate that every line has '...' when truncate multiple lines.
	
	  for (var i = 0, len = textLines.length; i < len; i++) {
	    textLines[i] = truncateSingleLine(textLines[i], options);
	  }
	
	  return textLines.join('\n');
	}
	
	function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
	  options = extend({}, options);
	  options.font = font;
	  var ellipsis = retrieve2(ellipsis, '...');
	  options.maxIterations = retrieve2(options.maxIterations, 2);
	  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME
	  // Other languages?
	
	  options.cnCharWidth = getWidth('国', font); // FIXME
	  // Consider proportional font?
	
	  var ascCharWidth = options.ascCharWidth = getWidth('a', font);
	  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.
	  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.
	
	  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.
	
	  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
	    contentWidth -= ascCharWidth;
	  }
	
	  var ellipsisWidth = getWidth(ellipsis);
	
	  if (ellipsisWidth > contentWidth) {
	    ellipsis = '';
	    ellipsisWidth = 0;
	  }
	
	  contentWidth = containerWidth - ellipsisWidth;
	  options.ellipsis = ellipsis;
	  options.ellipsisWidth = ellipsisWidth;
	  options.contentWidth = contentWidth;
	  options.containerWidth = containerWidth;
	  return options;
	}
	
	function truncateSingleLine(textLine, options) {
	  var containerWidth = options.containerWidth;
	  var font = options.font;
	  var contentWidth = options.contentWidth;
	
	  if (!containerWidth) {
	    return '';
	  }
	
	  var lineWidth = getWidth(textLine, font);
	
	  if (lineWidth <= containerWidth) {
	    return textLine;
	  }
	
	  for (var j = 0;; j++) {
	    if (lineWidth <= contentWidth || j >= options.maxIterations) {
	      textLine += options.ellipsis;
	      break;
	    }
	
	    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
	    textLine = textLine.substr(0, subLength);
	    lineWidth = getWidth(textLine, font);
	  }
	
	  if (textLine === '') {
	    textLine = options.placeholder;
	  }
	
	  return textLine;
	}
	
	function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
	  var width = 0;
	  var i = 0;
	
	  for (var len = text.length; i < len && width < contentWidth; i++) {
	    var charCode = text.charCodeAt(i);
	    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
	  }
	
	  return i;
	}
	/**
	 * @public
	 * @param {string} font
	 * @return {number} line height
	 */
	
	
	function getLineHeight(font) {
	  // FIXME A rough approach.
	  return getWidth('国', font);
	}
	/**
	 * @public
	 * @param {string} text
	 * @param {string} font
	 * @return {Object} width
	 */
	
	
	function measureText(text, font) {
	  return methods.measureText(text, font);
	} // Avoid assign to an exported variable, for transforming to cjs.
	
	
	methods.measureText = function (text, font) {
	  var ctx = getContext();
	  ctx.font = font || DEFAULT_FONT;
	  return ctx.measureText(text);
	};
	/**
	 * @public
	 * @param {string} text
	 * @param {string} font
	 * @param {Object} [truncate]
	 * @return {Object} block: {lineHeight, lines, height, outerHeight}
	 *  Notice: for performance, do not calculate outerWidth util needed.
	 */
	
	
	function parsePlainText(text, font, padding, truncate) {
	  text != null && (text += '');
	  var lineHeight = getLineHeight(font);
	  var lines = text ? text.split('\n') : [];
	  var height = lines.length * lineHeight;
	  var outerHeight = height;
	
	  if (padding) {
	    outerHeight += padding[0] + padding[2];
	  }
	
	  if (text && truncate) {
	    var truncOuterHeight = truncate.outerHeight;
	    var truncOuterWidth = truncate.outerWidth;
	
	    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {
	      text = '';
	      lines = [];
	    } else if (truncOuterWidth != null) {
	      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {
	        minChar: truncate.minChar,
	        placeholder: truncate.placeholder
	      }); // FIXME
	      // It is not appropriate that every line has '...' when truncate multiple lines.
	
	      for (var i = 0, len = lines.length; i < len; i++) {
	        lines[i] = truncateSingleLine(lines[i], options);
	      }
	    }
	  }
	
	  return {
	    lines: lines,
	    height: height,
	    outerHeight: outerHeight,
	    lineHeight: lineHeight
	  };
	}
	/**
	 * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'
	 * Also consider 'bbbb{a|xxx\nzzz}xxxx\naaaa'.
	 *
	 * @public
	 * @param {string} text
	 * @param {Object} style
	 * @return {Object} block
	 * {
	 *      width,
	 *      height,
	 *      lines: [{
	 *          lineHeight,
	 *          width,
	 *          tokens: [[{
	 *              styleName,
	 *              text,
	 *              width,      // include textPadding
	 *              height,     // include textPadding
	 *              textWidth, // pure text width
	 *              textHeight, // pure text height
	 *              lineHeihgt,
	 *              font,
	 *              textAlign,
	 *              textVerticalAlign
	 *          }], [...], ...]
	 *      }, ...]
	 * }
	 * If styleName is undefined, it is plain text.
	 */
	
	
	function parseRichText(text, style) {
	  var contentBlock = {
	    lines: [],
	    width: 0,
	    height: 0
	  };
	  text != null && (text += '');
	
	  if (!text) {
	    return contentBlock;
	  }
	
	  var lastIndex = STYLE_REG.lastIndex = 0;
	  var result;
	
	  while ((result = STYLE_REG.exec(text)) != null) {
	    var matchedIndex = result.index;
	
	    if (matchedIndex > lastIndex) {
	      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));
	    }
	
	    pushTokens(contentBlock, result[2], result[1]);
	    lastIndex = STYLE_REG.lastIndex;
	  }
	
	  if (lastIndex < text.length) {
	    pushTokens(contentBlock, text.substring(lastIndex, text.length));
	  }
	
	  var lines = contentBlock.lines;
	  var contentHeight = 0;
	  var contentWidth = 0; // For `textWidth: 100%`
	
	  var pendingList = [];
	  var stlPadding = style.textPadding;
	  var truncate = style.truncate;
	  var truncateWidth = truncate && truncate.outerWidth;
	  var truncateHeight = truncate && truncate.outerHeight;
	
	  if (stlPadding) {
	    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);
	    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);
	  } // Calculate layout info of tokens.
	
	
	  for (var i = 0; i < lines.length; i++) {
	    var line = lines[i];
	    var lineHeight = 0;
	    var lineWidth = 0;
	
	    for (var j = 0; j < line.tokens.length; j++) {
	      var token = line.tokens[j];
	      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.
	
	      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.
	
	      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.
	
	      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified
	      // as box height of the block.
	      tokenStyle.textHeight, getLineHeight(font));
	      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
	      token.height = tokenHeight;
	      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);
	      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;
	      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';
	
	      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {
	        return {
	          lines: [],
	          width: 0,
	          height: 0
	        };
	      }
	
	      token.textWidth = getWidth(token.text, font);
	      var tokenWidth = tokenStyle.textWidth;
	      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate
	      // line when box width is needed to be auto.
	
	      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {
	        token.percentWidth = tokenWidth;
	        pendingList.push(token);
	        tokenWidth = 0; // Do not truncate in this case, because there is no user case
	        // and it is too complicated.
	      } else {
	        if (tokenWidthNotSpecified) {
	          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling
	          // `getBoundingRect()` will not get correct result.
	
	          var textBackgroundColor = tokenStyle.textBackgroundColor;
	          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:
	          // (1) If image is not loaded, it will be loaded at render phase and call
	          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded
	          // image, and then the right size will be calculated here at the next tick.
	          // See `graphic/helper/text.js`.
	          // (2) If image loaded, and `textBackgroundColor.image` is image src string,
	          // use `imageHelper.findExistImage` to find cached image.
	          // `imageHelper.findExistImage` will always be called here before
	          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`
	          // which ensures that image will not be rendered before correct size calcualted.
	
	          if (bgImg) {
	            bgImg = imageHelper.findExistImage(bgImg);
	
	            if (imageHelper.isImageReady(bgImg)) {
	              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);
	            }
	          }
	        }
	
	        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;
	        tokenWidth += paddingW;
	        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;
	
	        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {
	          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {
	            token.text = '';
	            token.textWidth = tokenWidth = 0;
	          } else {
	            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {
	              minChar: truncate.minChar
	            });
	            token.textWidth = getWidth(token.text, font);
	            tokenWidth = token.textWidth + paddingW;
	          }
	        }
	      }
	
	      lineWidth += token.width = tokenWidth;
	      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
	    }
	
	    line.width = lineWidth;
	    line.lineHeight = lineHeight;
	    contentHeight += lineHeight;
	    contentWidth = Math.max(contentWidth, lineWidth);
	  }
	
	  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);
	  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);
	
	  if (stlPadding) {
	    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
	    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
	  }
	
	  for (var i = 0; i < pendingList.length; i++) {
	    var token = pendingList[i];
	    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.
	
	    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;
	  }
	
	  return contentBlock;
	}
	
	function pushTokens(block, str, styleName) {
	  var isEmptyStr = str === '';
	  var strs = str.split('\n');
	  var lines = block.lines;
	
	  for (var i = 0; i < strs.length; i++) {
	    var text = strs[i];
	    var token = {
	      styleName: styleName,
	      text: text,
	      isLineHolder: !text && !isEmptyStr
	    }; // The first token should be appended to the last line.
	
	    if (!i) {
	      var tokens = (lines[lines.length - 1] || (lines[0] = {
	        tokens: []
	      })).tokens; // Consider cases:
	      // (1) ''.split('\n') => ['', '\n', ''], the '' at the first item
	      // (which is a placeholder) should be replaced by new token.
	      // (2) A image backage, where token likes {a|}.
	      // (3) A redundant '' will affect textAlign in line.
	      // (4) tokens with the same tplName should not be merged, because
	      // they should be displayed in different box (with border and padding).
	
	      var tokensLen = tokens.length;
	      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the "lineHolder" or
	      // "emptyStr". Otherwise a redundant '' will affect textAlign in line.
	      (text || !tokensLen || isEmptyStr) && tokens.push(token);
	    } // Other tokens always start a new line.
	    else {
	        // If there is '', insert it as a placeholder.
	        lines.push({
	          tokens: [token]
	        });
	      }
	  }
	}
	
	function makeFont(style) {
	  // FIXME in node-canvas fontWeight is before fontStyle
	  // Use `fontSize` `fontFamily` to check whether font properties are defined.
	  return (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.
	  style.fontFamily || 'sans-serif'].join(' ') || style.textFont || style.font;
	}
	
	exports.DEFAULT_FONT = DEFAULT_FONT;
	exports.$override = $override;
	exports.getWidth = getWidth;
	exports.getBoundingRect = getBoundingRect;
	exports.adjustTextX = adjustTextX;
	exports.adjustTextY = adjustTextY;
	exports.adjustTextPositionOnRect = adjustTextPositionOnRect;
	exports.truncateText = truncateText;
	exports.getLineHeight = getLineHeight;
	exports.measureText = measureText;
	exports.parsePlainText = parsePlainText;
	exports.parseRichText = parseRichText;
	exports.makeFont = makeFont;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	var LRU = __webpack_require__(21);
	
	var globalImageCache = new LRU(50);
	/**
	 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
	 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
	 */
	
	function findExistImage(newImageOrSrc) {
	  if (typeof newImageOrSrc === 'string') {
	    var cachedImgObj = globalImageCache.get(newImageOrSrc);
	    return cachedImgObj && cachedImgObj.image;
	  } else {
	    return newImageOrSrc;
	  }
	}
	/**
	 * Caution: User should cache loaded images, but not just count on LRU.
	 * Consider if required images more than LRU size, will dead loop occur?
	 *
	 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
	 * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.
	 * @param {module:zrender/Element} [hostEl] For calling `dirty`.
	 * @param {Function} [cb] params: (image, cbPayload)
	 * @param {Object} [cbPayload] Payload on cb calling.
	 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
	 */
	
	
	function createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {
	  if (!newImageOrSrc) {
	    return image;
	  } else if (typeof newImageOrSrc === 'string') {
	    // Image should not be loaded repeatly.
	    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
	      return image;
	    } // Only when there is no existent image or existent image src
	    // is different, this method is responsible for load.
	
	
	    var cachedImgObj = globalImageCache.get(newImageOrSrc);
	    var pendingWrap = {
	      hostEl: hostEl,
	      cb: cb,
	      cbPayload: cbPayload
	    };
	
	    if (cachedImgObj) {
	      image = cachedImgObj.image;
	      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
	    } else {
	      !image && (image = new Image());
	      image.onload = imageOnLoad;
	      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
	        image: image,
	        pending: [pendingWrap]
	      });
	      image.src = image.__zrImageSrc = newImageOrSrc;
	    }
	
	    return image;
	  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas
	  else {
	      return newImageOrSrc;
	    }
	}
	
	function imageOnLoad() {
	  var cachedImgObj = this.__cachedImgObj;
	  this.onload = this.__cachedImgObj = null;
	
	  for (var i = 0; i < cachedImgObj.pending.length; i++) {
	    var pendingWrap = cachedImgObj.pending[i];
	    var cb = pendingWrap.cb;
	    cb && cb(this, pendingWrap.cbPayload);
	    pendingWrap.hostEl.dirty();
	  }
	
	  cachedImgObj.pending.length = 0;
	}
	
	function isImageReady(image) {
	  return image && image.width && image.height;
	}
	
	exports.findExistImage = findExistImage;
	exports.createOrUpdateImage = createOrUpdateImage;
	exports.isImageReady = isImageReady;

/***/ }),
/* 37 */
/***/ (function(module, exports) {

	function buildPath(ctx, shape) {
	  var x = shape.x;
	  var y = shape.y;
	  var width = shape.width;
	  var height = shape.height;
	  var r = shape.r;
	  var r1;
	  var r2;
	  var r3;
	  var r4; // Convert width and height to positive for better borderRadius
	
	  if (width < 0) {
	    x = x + width;
	    width = -width;
	  }
	
	  if (height < 0) {
	    y = y + height;
	    height = -height;
	  }
	
	  if (typeof r === 'number') {
	    r1 = r2 = r3 = r4 = r;
	  } else if (r instanceof Array) {
	    if (r.length === 1) {
	      r1 = r2 = r3 = r4 = r[0];
	    } else if (r.length === 2) {
	      r1 = r3 = r[0];
	      r2 = r4 = r[1];
	    } else if (r.length === 3) {
	      r1 = r[0];
	      r2 = r4 = r[1];
	      r3 = r[2];
	    } else {
	      r1 = r[0];
	      r2 = r[1];
	      r3 = r[2];
	      r4 = r[3];
	    }
	  } else {
	    r1 = r2 = r3 = r4 = 0;
	  }
	
	  var total;
	
	  if (r1 + r2 > width) {
	    total = r1 + r2;
	    r1 *= width / total;
	    r2 *= width / total;
	  }
	
	  if (r3 + r4 > width) {
	    total = r3 + r4;
	    r3 *= width / total;
	    r4 *= width / total;
	  }
	
	  if (r2 + r3 > height) {
	    total = r2 + r3;
	    r2 *= height / total;
	    r3 *= height / total;
	  }
	
	  if (r1 + r4 > height) {
	    total = r1 + r4;
	    r1 *= height / total;
	    r4 *= height / total;
	  }
	
	  ctx.moveTo(x + r1, y);
	  ctx.lineTo(x + width - r2, y);
	  r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);
	  ctx.lineTo(x + width, y + height - r3);
	  r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);
	  ctx.lineTo(x + r4, y + height);
	  r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);
	  ctx.lineTo(x, y + r1);
	  r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
	}
	
	exports.buildPath = buildPath;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(6);
	
	var _event = __webpack_require__(39);
	
	var Dispatcher = _event.Dispatcher;
	
	var requestAnimationFrame = __webpack_require__(30);
	
	var Animator = __webpack_require__(17);
	
	/**
	 * 动画主类, 调度和管理所有动画控制器
	 *
	 * @module zrender/animation/Animation
	 * @author pissang(https://github.com/pissang)
	 */
	// TODO Additive animation
	// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/
	// https://developer.apple.com/videos/wwdc2014/#236
	
	/**
	 * @typedef {Object} IZRenderStage
	 * @property {Function} update
	 */
	
	/**
	 * @alias module:zrender/animation/Animation
	 * @constructor
	 * @param {Object} [options]
	 * @param {Function} [options.onframe]
	 * @param {IZRenderStage} [options.stage]
	 * @example
	 *     var animation = new Animation();
	 *     var obj = {
	 *         x: 100,
	 *         y: 100
	 *     };
	 *     animation.animate(node.position)
	 *         .when(1000, {
	 *             x: 500,
	 *             y: 500
	 *         })
	 *         .when(2000, {
	 *             x: 100,
	 *             y: 100
	 *         })
	 *         .start('spline');
	 */
	var Animation = function (options) {
	  options = options || {};
	  this.stage = options.stage || {};
	
	  this.onframe = options.onframe || function () {}; // private properties
	
	
	  this._clips = [];
	  this._running = false;
	  this._time;
	  this._pausedTime;
	  this._pauseStart;
	  this._paused = false;
	  Dispatcher.call(this);
	};
	
	Animation.prototype = {
	  constructor: Animation,
	
	  /**
	   * 添加 clip
	   * @param {module:zrender/animation/Clip} clip
	   */
	  addClip: function (clip) {
	    this._clips.push(clip);
	  },
	
	  /**
	   * 添加 animator
	   * @param {module:zrender/animation/Animator} animator
	   */
	  addAnimator: function (animator) {
	    animator.animation = this;
	    var clips = animator.getClips();
	
	    for (var i = 0; i < clips.length; i++) {
	      this.addClip(clips[i]);
	    }
	  },
	
	  /**
	   * 删除动画片段
	   * @param {module:zrender/animation/Clip} clip
	   */
	  removeClip: function (clip) {
	    var idx = util.indexOf(this._clips, clip);
	
	    if (idx >= 0) {
	      this._clips.splice(idx, 1);
	    }
	  },
	
	  /**
	   * 删除动画片段
	   * @param {module:zrender/animation/Animator} animator
	   */
	  removeAnimator: function (animator) {
	    var clips = animator.getClips();
	
	    for (var i = 0; i < clips.length; i++) {
	      this.removeClip(clips[i]);
	    }
	
	    animator.animation = null;
	  },
	  _update: function () {
	    var time = new Date().getTime() - this._pausedTime;
	
	    var delta = time - this._time;
	    var clips = this._clips;
	    var len = clips.length;
	    var deferredEvents = [];
	    var deferredClips = [];
	
	    for (var i = 0; i < len; i++) {
	      var clip = clips[i];
	      var e = clip.step(time, delta); // Throw out the events need to be called after
	      // stage.update, like destroy
	
	      if (e) {
	        deferredEvents.push(e);
	        deferredClips.push(clip);
	      }
	    } // Remove the finished clip
	
	
	    for (var i = 0; i < len;) {
	      if (clips[i]._needsRemove) {
	        clips[i] = clips[len - 1];
	        clips.pop();
	        len--;
	      } else {
	        i++;
	      }
	    }
	
	    len = deferredEvents.length;
	
	    for (var i = 0; i < len; i++) {
	      deferredClips[i].fire(deferredEvents[i]);
	    }
	
	    this._time = time;
	    this.onframe(delta);
	    this.trigger('frame', delta);
	
	    if (this.stage.update) {
	      this.stage.update();
	    }
	  },
	  _startLoop: function () {
	    var self = this;
	    this._running = true;
	
	    function step() {
	      if (self._running) {
	        requestAnimationFrame(step);
	        !self._paused && self._update();
	      }
	    }
	
	    requestAnimationFrame(step);
	  },
	
	  /**
	   * 开始运行动画
	   */
	  start: function () {
	    this._time = new Date().getTime();
	    this._pausedTime = 0;
	
	    this._startLoop();
	  },
	
	  /**
	   * 停止运行动画
	   */
	  stop: function () {
	    this._running = false;
	  },
	
	  /**
	   * Pause
	   */
	  pause: function () {
	    if (!this._paused) {
	      this._pauseStart = new Date().getTime();
	      this._paused = true;
	    }
	  },
	
	  /**
	   * Resume
	   */
	  resume: function () {
	    if (this._paused) {
	      this._pausedTime += new Date().getTime() - this._pauseStart;
	      this._paused = false;
	    }
	  },
	
	  /**
	   * 清除所有动画片段
	   */
	  clear: function () {
	    this._clips = [];
	  },
	
	  /**
	   * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画
	   * @param  {Object} target
	   * @param  {Object} options
	   * @param  {boolean} [options.loop=false] 是否循环播放动画
	   * @param  {Function} [options.getter=null]
	   *         如果指定getter函数，会通过getter函数取属性值
	   * @param  {Function} [options.setter=null]
	   *         如果指定setter函数，会通过setter函数设置属性值
	   * @return {module:zrender/animation/Animation~Animator}
	   */
	  // TODO Gap
	  animate: function (target, options) {
	    options = options || {};
	    var animator = new Animator(target, options.loop, options.getter, options.setter);
	    this.addAnimator(animator);
	    return animator;
	  }
	};
	util.mixin(Animation, Dispatcher);
	var _default = Animation;
	module.exports = _default;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	var Eventful = __webpack_require__(10);
	
	exports.Dispatcher = Eventful;
	
	var env = __webpack_require__(5);
	
	/**
	 * 事件辅助类
	 * @module zrender/core/event
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 */
	var isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;
	var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
	
	function getBoundingClientRect(el) {
	  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect
	  return el.getBoundingClientRect ? el.getBoundingClientRect() : {
	    left: 0,
	    top: 0
	  };
	} // `calculate` is optional, default false
	
	
	function clientToLocal(el, e, out, calculate) {
	  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative
	  // to the padding edge of the target element. The only browser using this convention
	  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does
	  // not support the properties.
	  // (see http://www.jacklmoore.com/notes/mouse-position/)
	  // In zr painter.dom, padding edge equals to border edge.
	  // FIXME
	  // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and
	  // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y
	  // is too complex. So css-transfrom dont support in this case temporarily.
	
	  if (calculate || !env.canvasSupported) {
	    defaultGetZrXY(el, e, out);
	  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned
	  // ancestor element, so we should make sure el is positioned (e.g., not position:static).
	  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add
	  // zoom-factor, overflow / opacity layers, transforms ...)
	  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.
	  // <https://bugs.jquery.com/ticket/8523#comment:14>
	  // BTW3, In ff, offsetX/offsetY is always 0.
	  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {
	      out.zrX = e.layerX;
	      out.zrY = e.layerY;
	    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)
	    else if (e.offsetX != null) {
	        out.zrX = e.offsetX;
	        out.zrY = e.offsetY;
	      } // For some other device, e.g., IOS safari.
	      else {
	          defaultGetZrXY(el, e, out);
	        }
	
	  return out;
	}
	
	function defaultGetZrXY(el, e, out) {
	  // This well-known method below does not support css transform.
	  var box = getBoundingClientRect(el);
	  out.zrX = e.clientX - box.left;
	  out.zrY = e.clientY - box.top;
	}
	/**
	 * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.
	 * `calculate` is optional, default false.
	 */
	
	
	function normalizeEvent(el, e, calculate) {
	  e = e || window.event;
	
	  if (e.zrX != null) {
	    return e;
	  }
	
	  var eventType = e.type;
	  var isTouch = eventType && eventType.indexOf('touch') >= 0;
	
	  if (!isTouch) {
	    clientToLocal(el, e, e, calculate);
	    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
	  } else {
	    var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];
	    touch && clientToLocal(el, touch, e, calculate);
	  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;
	  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js
	  // If e.which has been defined, if may be readonly,
	  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which
	
	
	  var button = e.button;
	
	  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {
	    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
	  }
	
	  return e;
	}
	
	function addEventListener(el, name, handler) {
	  if (isDomLevel2) {
	    el.addEventListener(name, handler);
	  } else {
	    el.attachEvent('on' + name, handler);
	  }
	}
	
	function removeEventListener(el, name, handler) {
	  if (isDomLevel2) {
	    el.removeEventListener(name, handler);
	  } else {
	    el.detachEvent('on' + name, handler);
	  }
	}
	/**
	 * preventDefault and stopPropagation.
	 * Notice: do not do that in zrender. Upper application
	 * do that if necessary.
	 *
	 * @memberOf module:zrender/core/event
	 * @method
	 * @param {Event} e : event对象
	 */
	
	
	var stop = isDomLevel2 ? function (e) {
	  e.preventDefault();
	  e.stopPropagation();
	  e.cancelBubble = true;
	} : function (e) {
	  e.returnValue = false;
	  e.cancelBubble = true;
	};
	
	function notLeftMouse(e) {
	  // If e.which is undefined, considered as left mouse event.
	  return e.which > 1;
	} // 做向上兼容
	
	
	exports.clientToLocal = clientToLocal;
	exports.normalizeEvent = normalizeEvent;
	exports.addEventListener = addEventListener;
	exports.removeEventListener = removeEventListener;
	exports.stop = stop;
	exports.notLeftMouse = notLeftMouse;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	var _event = __webpack_require__(39);
	
	var addEventListener = _event.addEventListener;
	var removeEventListener = _event.removeEventListener;
	var normalizeEvent = _event.normalizeEvent;
	
	var zrUtil = __webpack_require__(6);
	
	var Eventful = __webpack_require__(10);
	
	var env = __webpack_require__(5);
	
	var GestureMgr = __webpack_require__(41);
	
	var TOUCH_CLICK_DELAY = 300;
	var mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
	var touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];
	var pointerEventNames = {
	  pointerdown: 1,
	  pointerup: 1,
	  pointermove: 1,
	  pointerout: 1
	};
	var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {
	  var nm = name.replace('mouse', 'pointer');
	  return pointerEventNames[nm] ? nm : name;
	});
	
	function eventNameFix(name) {
	  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;
	}
	
	function processGesture(proxy, event, stage) {
	  var gestureMgr = proxy._gestureMgr;
	  stage === 'start' && gestureMgr.clear();
	  var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null).target, proxy.dom);
	  stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.
	
	  if (gestureInfo) {
	    var type = gestureInfo.type;
	    event.gestureEvent = type;
	    proxy.handler.dispatchToElement({
	      target: gestureInfo.target
	    }, type, gestureInfo.event);
	  }
	} // function onMSGestureChange(proxy, event) {
	//     if (event.translationX || event.translationY) {
	//         // mousemove is carried by MSGesture to reduce the sensitivity.
	//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);
	//     }
	//     if (event.scale !== 1) {
	//         event.pinchX = event.offsetX;
	//         event.pinchY = event.offsetY;
	//         event.pinchScale = event.scale;
	//         proxy.handler.dispatchToElement(event.target, 'pinch', event);
	//     }
	// }
	
	/**
	 * Prevent mouse event from being dispatched after Touch Events action
	 * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
	 * 1. Mobile browsers dispatch mouse events 300ms after touchend.
	 * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
	 * Result: Blocking Mouse Events for 700ms.
	 */
	
	
	function setTouchTimer(instance) {
	  instance._touching = true;
	  clearTimeout(instance._touchTimer);
	  instance._touchTimer = setTimeout(function () {
	    instance._touching = false;
	  }, 700);
	}
	
	var domHandlers = {
	  /**
	   * Mouse move handler
	   * @inner
	   * @param {Event} event
	   */
	  mousemove: function (event) {
	    event = normalizeEvent(this.dom, event);
	    this.trigger('mousemove', event);
	  },
	
	  /**
	   * Mouse out handler
	   * @inner
	   * @param {Event} event
	   */
	  mouseout: function (event) {
	    event = normalizeEvent(this.dom, event);
	    var element = event.toElement || event.relatedTarget;
	
	    if (element != this.dom) {
	      while (element && element.nodeType != 9) {
	        // 忽略包含在root中的dom引起的mouseOut
	        if (element === this.dom) {
	          return;
	        }
	
	        element = element.parentNode;
	      }
	    }
	
	    this.trigger('mouseout', event);
	  },
	
	  /**
	   * Touch开始响应函数
	   * @inner
	   * @param {Event} event
	   */
	  touchstart: function (event) {
	    // Default mouse behaviour should not be disabled here.
	    // For example, page may needs to be slided.
	    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
	    // mouse event in upper applicatoin.
	
	    event.zrByTouch = true;
	    this._lastTouchMoment = new Date();
	    processGesture(this, event, 'start'); // In touch device, trigger `mousemove`(`mouseover`) should
	    // be triggered, and must before `mousedown` triggered.
	
	    domHandlers.mousemove.call(this, event);
	    domHandlers.mousedown.call(this, event);
	    setTouchTimer(this);
	  },
	
	  /**
	   * Touch移动响应函数
	   * @inner
	   * @param {Event} event
	   */
	  touchmove: function (event) {
	    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
	    // mouse event in upper applicatoin.
	
	    event.zrByTouch = true;
	    processGesture(this, event, 'change'); // Mouse move should always be triggered no matter whether
	    // there is gestrue event, because mouse move and pinch may
	    // be used at the same time.
	
	    domHandlers.mousemove.call(this, event);
	    setTouchTimer(this);
	  },
	
	  /**
	   * Touch结束响应函数
	   * @inner
	   * @param {Event} event
	   */
	  touchend: function (event) {
	    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
	    // mouse event in upper applicatoin.
	
	    event.zrByTouch = true;
	    processGesture(this, event, 'end');
	    domHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is
	    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,
	    // we can conveniently implement "hover style" in both PC and touch device just
	    // by listening to `mouseover` to add "hover style" and listening to `mouseout`
	    // to remove "hover style" on an element, without any additional code for
	    // compatibility. (`mouseout` will not be triggered in `touchend`, so "hover
	    // style" will remain for user view)
	    // click event should always be triggered no matter whether
	    // there is gestrue event. System click can not be prevented.
	
	    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
	      domHandlers.click.call(this, event);
	    }
	
	    setTouchTimer(this);
	  },
	  pointerdown: function (event) {
	    domHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {
	    //     this._msGesture.addPointer(event.pointerId);
	    // }
	  },
	  pointermove: function (event) {
	    // FIXME
	    // pointermove is so sensitive that it always triggered when
	    // tap(click) on touch screen, which affect some judgement in
	    // upper application. So, we dont support mousemove on MS touch
	    // device yet.
	    if (!isPointerFromTouch(event)) {
	      domHandlers.mousemove.call(this, event);
	    }
	  },
	  pointerup: function (event) {
	    domHandlers.mouseup.call(this, event);
	  },
	  pointerout: function (event) {
	    // pointerout will be triggered when tap on touch screen
	    // (IE11+/Edge on MS Surface) after click event triggered,
	    // which is inconsistent with the mousout behavior we defined
	    // in touchend. So we unify them.
	    // (check domHandlers.touchend for detailed explanation)
	    if (!isPointerFromTouch(event)) {
	      domHandlers.mouseout.call(this, event);
	    }
	  }
	};
	
	function isPointerFromTouch(event) {
	  var pointerType = event.pointerType;
	  return pointerType === 'pen' || pointerType === 'touch';
	} // function useMSGuesture(handlerProxy, event) {
	//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;
	// }
	// Common handlers
	
	
	zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
	  domHandlers[name] = function (event) {
	    event = normalizeEvent(this.dom, event);
	    this.trigger(name, event);
	  };
	});
	/**
	 * 为控制类实例初始化dom 事件处理函数
	 *
	 * @inner
	 * @param {module:zrender/Handler} instance 控制类实例
	 */
	
	function initDomHandler(instance) {
	  zrUtil.each(touchHandlerNames, function (name) {
	    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
	  });
	  zrUtil.each(pointerHandlerNames, function (name) {
	    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
	  });
	  zrUtil.each(mouseHandlerNames, function (name) {
	    instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);
	  });
	
	  function makeMouseHandler(fn, instance) {
	    return function () {
	      if (instance._touching) {
	        return;
	      }
	
	      return fn.apply(instance, arguments);
	    };
	  }
	}
	
	function HandlerDomProxy(dom) {
	  Eventful.call(this);
	  this.dom = dom;
	  /**
	   * @private
	   * @type {boolean}
	   */
	
	  this._touching = false;
	  /**
	   * @private
	   * @type {number}
	   */
	
	  this._touchTimer;
	  /**
	   * @private
	   * @type {module:zrender/core/GestureMgr}
	   */
	
	  this._gestureMgr = new GestureMgr();
	  this._handlers = {};
	  initDomHandler(this);
	
	  if (env.pointerEventsSupported) {
	    // Only IE11+/Edge
	    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),
	    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event
	    // at the same time.
	    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on
	    // screen, which do not occurs in pointer event.
	    // So we use pointer event to both detect touch gesture and mouse behavior.
	    mountHandlers(pointerHandlerNames, this); // FIXME
	    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,
	    // which does not prevent defuault behavior occasionally (which may cause view port
	    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.
	    // So we have to not to use MSGesture and not to support touchmove and pinch on MS
	    // touch screen. And we only support click behavior on MS touch screen now.
	    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.
	    // We dont support touch on IE on win7.
	    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>
	    // if (typeof MSGesture === 'function') {
	    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line
	    //     dom.addEventListener('MSGestureChange', onMSGestureChange);
	    // }
	  } else {
	    if (env.touchEventsSupported) {
	      mountHandlers(touchHandlerNames, this); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.
	      // addEventListener(root, 'mouseout', this._mouseoutHandler);
	    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface
	    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise
	    // mouse event can not be handle in those devices.
	    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent
	    // mouseevent after touch event triggered, see `setTouchTimer`.
	
	
	    mountHandlers(mouseHandlerNames, this);
	  }
	
	  function mountHandlers(handlerNames, instance) {
	    zrUtil.each(handlerNames, function (name) {
	      addEventListener(dom, eventNameFix(name), instance._handlers[name]);
	    }, instance);
	  }
	}
	
	var handlerDomProxyProto = HandlerDomProxy.prototype;
	
	handlerDomProxyProto.dispose = function () {
	  var handlerNames = mouseHandlerNames.concat(touchHandlerNames);
	
	  for (var i = 0; i < handlerNames.length; i++) {
	    var name = handlerNames[i];
	    removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);
	  }
	};
	
	handlerDomProxyProto.setCursor = function (cursorStyle) {
	  this.dom.style.cursor = cursorStyle || 'default';
	};
	
	zrUtil.mixin(HandlerDomProxy, Eventful);
	var _default = HandlerDomProxy;
	module.exports = _default;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	var eventUtil = __webpack_require__(39);
	
	/**
	 * Only implements needed gestures for mobile.
	 */
	var GestureMgr = function () {
	  /**
	   * @private
	   * @type {Array.<Object>}
	   */
	  this._track = [];
	};
	
	GestureMgr.prototype = {
	  constructor: GestureMgr,
	  recognize: function (event, target, root) {
	    this._doTrack(event, target, root);
	
	    return this._recognize(event);
	  },
	  clear: function () {
	    this._track.length = 0;
	    return this;
	  },
	  _doTrack: function (event, target, root) {
	    var touches = event.touches;
	
	    if (!touches) {
	      return;
	    }
	
	    var trackItem = {
	      points: [],
	      touches: [],
	      target: target,
	      event: event
	    };
	
	    for (var i = 0, len = touches.length; i < len; i++) {
	      var touch = touches[i];
	      var pos = eventUtil.clientToLocal(root, touch, {});
	      trackItem.points.push([pos.zrX, pos.zrY]);
	      trackItem.touches.push(touch);
	    }
	
	    this._track.push(trackItem);
	  },
	  _recognize: function (event) {
	    for (var eventName in recognizers) {
	      if (recognizers.hasOwnProperty(eventName)) {
	        var gestureInfo = recognizers[eventName](this._track, event);
	
	        if (gestureInfo) {
	          return gestureInfo;
	        }
	      }
	    }
	  }
	};
	
	function dist(pointPair) {
	  var dx = pointPair[1][0] - pointPair[0][0];
	  var dy = pointPair[1][1] - pointPair[0][1];
	  return Math.sqrt(dx * dx + dy * dy);
	}
	
	function center(pointPair) {
	  return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];
	}
	
	var recognizers = {
	  pinch: function (track, event) {
	    var trackLen = track.length;
	
	    if (!trackLen) {
	      return;
	    }
	
	    var pinchEnd = (track[trackLen - 1] || {}).points;
	    var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;
	
	    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
	      var pinchScale = dist(pinchEnd) / dist(pinchPre);
	      !isFinite(pinchScale) && (pinchScale = 1);
	      event.pinchScale = pinchScale;
	      var pinchCenter = center(pinchEnd);
	      event.pinchX = pinchCenter[0];
	      event.pinchY = pinchCenter[1];
	      return {
	        type: 'pinch',
	        target: track[0].target,
	        event: event
	      };
	    }
	  } // Only pinch currently.
	
	};
	var _default = GestureMgr;
	module.exports = _default;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * BO节点
	 * 1.BO是一个矩形
	 * 2.BO有名字
	 * 3.BO有事件决策[]，双击事件决策弹出详情
	 * 4.BO有外键属性[]
	 * 5.BO有子BO
	 * 6.当前BO特殊颜色显示
	 * 7.双击BO弹出BO属性以及属性事件决策页面
	 * @module fish-topo-bo/node/BoNode
	 * Created by majianan on 16/5/19.
	 */
	
	    var Const = __webpack_require__(43);
	    var BoName = __webpack_require__(44);
	    var EventDecision = __webpack_require__(77);
	    var Line = __webpack_require__(78);
	    var BoAttr = __webpack_require__(79);
	    var graphic = __webpack_require__(45);
	    var nodeOptions = null;
	
	    /**
	     *
	     * @param {{
	     *          id: String BO主键,
	     *          name: String BO名字,
	     *          boEventArr: [] BO事件决策数组,
	     *          boAttrArr: [] BO属性数组
	     *          }} boData, bo数据对象
	     * @param {{
	     *          startPos: {x: number, y: number} 起始位置,
	     *          displayAttrDataType: boolean 是否显示属性数据类型,
	     *          displayAttrEvent: boolean 是否显示属性事件决策,
	     *          boClickable: boolean BO是否支持点击事件, 可空 默认false
	     *          boPopupOpts: Object BO弹出页面参数，url,width,height等
	     *          boEventClickable: boolean BO事件决策是否支持点击事件, 可空 默认false
	     *          boEventPopupOpts: Object BO事件决策弹出页面参数，url,width,height等
	     *          bindBoClickEvent: function(options) BO点击事件，返回函数参数为options，它的属性有DATA等
	     *          attrEventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false
	     *          attrEventPopupOpts: Object 点击BO属性事件决策弹出页面参数，url,width,height等
	     *          isCurrent: boolean 是否为当前BO
	     *          }} opts
	     * @constructor
	     */
	    function BO(boData, opts) {
	        nodeOptions = opts;
	
	        /**
	         * BO数据
	         * @type {Object}
	         * @private
	         */
	        this._data = boData;
	
	        /**
	         * 初始坐标，用于最后画BO矩形
	         * @type {{x: number, y: number}}
	         * @private
	         */
	        this._oriStartPos = opts.startPos;
	
	        /**
	         * 每个控件的起始参照坐标，每个控件画完之后都会重新计算
	         * @type {{x: number, y: number}}
	         * @private
	         */
	        this._nextStartPos = {
	            x: opts.startPos.x,
	            y: opts.startPos.y
	        };
	
	        /**
	         * 是否显示属性数据类型
	         * @type {boolean}
	         * @private
	         */
	        this._displayAttrDataType = opts.displayAttrDataType || false;
	
	        /**
	         * 是否显示属性事件决策
	         * @type {boolean}
	         * @private
	         */
	        this._displayAttrEvent = opts.displayAttrEvent || false;
	
	        //TODO
	        if (this._displayAttrEvent) {
	            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 3;
	        } else if (this._displayAttrDataType) {
	            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 1.5;
	        }
	
	        /**
	         * 是否支持点击
	         * @type {boolean}
	         * @private
	         */
	        this._boClickable = opts.boClickable || false;
	        this._boPopupOpts = opts.boPopupOpts;
	        this._boEventClickable = opts.boEventClickable || false;
	        this._boEventPopupOpts = opts.boEventPopupOpts;
	        this._attrEventClickable = opts.attrEventClickable || false;
	        this._attrEventPopupOpts = opts.attrEventPopupOpts;
	
	        /**
	         * 是否是当前BO，当前BO特殊颜色显示
	         * @type {boolean}
	         * @private
	         */
	        this._isCurrent = opts.isCurrent || false;
	
	
	        /**
	         * BO矩形高度，根据实际内容计算
	         * @type {number}
	         * @private
	         */
	        this._boShapeHeight = 0;
	
	        /**
	         * Group容器
	         * @type zrender/graphic/Group
	         * @private
	         */
	        this._group = new graphic.Group();
	        this._group.name = this._data.id;
	        this._group.setCurrent = function (style) {
	            //Group最后一个是BO矩形
	            var _boShape = this.childAt(this.childCount() - 1);
	
	            if (style) {
	                Object.assign(_boShape.style, style);
	            } else {
	                //默认效果
	                _boShape.style.fill = '#66CC99';
	            }
	
	        };
	
	        this._render();
	    }
	
	
	    var boProto = BO.prototype;
	
	    /**
	     * 获取BO整体图形
	     * @returns {zrender/graphic/Group}
	     */
	    boProto.getShape = function () {
	        return this._group;
	    };
	
	    /**
	     * 获取数据
	     * @returns {Object}
	     */
	    boProto.getData = function () {
	        return this._data;
	    };
	
	    boProto.getLayout = function () {
	        return this._data.layout;
	    };
	
	
	
	    /**
	     * 设置当前BO特殊演示显示
	     */
	    boProto.setCurrent = function () {
	        //BO矩形是最后一个图形
	        this.childAt(this.childCount - 1).style.fill = '#66CC99'
	    };
	
	    /**
	     * 生成BO整体图形
	     * @private
	     */
	    boProto._render = function () {
	        //BO名字
	        this._createBoName();
	
	        //BO事件决策
	        this._createEventDecision();
	
	        //BO属性
	        this._createBoAttr();
	
	        //BO矩形
	        this._createBoShape();
	
	        //TODO
	        Const.BO_NODE_WIDTH = 180;
	    };
	
	
	    /**
	     * 生成BO名字文本
	     * @private
	     */
	    boProto._createBoName = function () {
	        var _boNameShape = BoName(this._data.name, this._nextStartPos);
	
	        if (this._boClickable) {
	            _boNameShape.clickable = this._boClickable;
	            _boNameShape._data = this._data;
	            _boNameShape._boPopupOpts = this._boPopupOpts;
	            _boNameShape.onclick = this._click;
	        }
	
	        this._group.add(_boNameShape);
	        this._calNextShapeStartPos(_boNameShape);
	    };
	
	    /**
	     * 生成BO事件决策
	     * @private
	     */
	    boProto._createEventDecision = function () {
	
	        //如果没有BO事件决策，则返回
	        if (!this._data.boEventArr) {
	            return;
	        }
	
	        var _boEventArr = this._data.boEventArr,
	            _boEventLen = _boEventArr.length,
	            _eventShape,
	            _eventOpts = {
	                startPos: this._nextStartPos,
	                clickable: this._boEventClickable,
	                popupOpts: this._boEventPopupOpts,
	                bindBoClickEvent: nodeOptions.bindBoClickEvent
	            };
	
	        for (var i = 0; i < _boEventLen; i++) {
	            _eventShape = new EventDecision(_boEventArr[i], _eventOpts);
	            this._group.add(_eventShape.getShape());
	            this._calNextShapeStartPos(_eventShape.getShape());
	        }
	
	    };
	
	    /**
	     * 生成BO属性
	     * @private
	     */
	    boProto._createBoAttr = function () {
	        //如果没有BO属性，则返回
	        if (!this._data.boAttrArr) {
	            return;
	        }
	
	        var _boAttrArr = this._data.boAttrArr,
	            _boAttrLen = _boAttrArr.length,
	            _boAttrShape, _lineShape,
	            _attrEventStartPos = {x: this._nextStartPos.x + Const.BO_NODE_WIDTH / 2, y: this._nextStartPos.y};
	
	        for (var i = 0; i < _boAttrLen; i++) {
	            if (i == 0) {
	                _lineShape = Line.BoLine(this._nextStartPos); //实线
	            }
	            else {
	                _lineShape = Line.AttrLine(this._nextStartPos);//虚线
	            }
	
	            this._group.add(_lineShape);
	
	            this._calNextShapeStartPos(_lineShape);
	
	            _boAttrShape = new BoAttr(_boAttrArr[i],
	                {
	                    startPos: this._nextStartPos,
	                    displayDataType: this._displayAttrDataType,
	                    displayEventDecision: this._displayAttrEvent,
	                    eventClickable: this._attrEventClickable,
	                    eventPopupOpts: this._attrEventPopupOpts,
	                    bindBoClickEvent: nodeOptions.bindBoClickEvent
	                }
	            );
	            this._group.add(_boAttrShape.getShape());
	            this._calNextShapeStartPos(_boAttrShape.getShape())
	        }
	
	        if (this._displayAttrEvent) {
	            _lineShape = Line.AttrEventLine(_attrEventStartPos,
	                this._nextStartPos.y - _attrEventStartPos.y
	            );
	            this._group.add(_lineShape);
	        }
	    };
	
	
	    /**
	     * 计算下一个图形的开始位置，以及BO矩形的高度
	     * @param curShape 当前图形
	     * @private
	     */
	    boProto._calNextShapeStartPos = function (curShape) {
	        //下一图形起始位置
	        this._nextStartPos.y += curShape.getBoundingRect().height;
	
	        //BO矩形高度增加
	        this._boShapeHeight += curShape.getBoundingRect().height;
	    };
	
	
	    /**
	     * 生成BO矩形
	     * @private
	     */
	    boProto._createBoShape = function () {
	        var height = this._boShapeHeight > Const.BO_NODE_DEFAULT_HEIGHT ?
	                this._boShapeHeight : Const.BO_NODE_DEFAULT_HEIGHT,
	            shape = new graphic.Rect({
	                position: [this._oriStartPos.x, this._oriStartPos.y],
	
	                shape: {
	                    r: 5,
	                    width: Const.BO_NODE_WIDTH,
	                    height: height
	                },
	
	                style: {
	                    brushType: 'both',
	                    fill: this._isCurrent ? '#66CC99' : 'white',
	                    stroke: '#000000',
	                    lineWidth: 1,
	                    lineCape: 'round'
	                },
	
	                zlevel: -1
	            });
	
	        if (this._boClickable) {
	            shape._data = this._data;
	            shape._boPopupOpts = this._boPopupOpts;
	
	            shape.clickable = this._boClickable;
	            shape.onclick = this._click;
	        }
	
	        this._group.add(shape);
	    };
	
	    /**
	     * 点击事件
	     * @private
	     */
	    boProto._click = function () {
	        var options = Object.assign(
	            {
	                DATA: this._data
	            }, this._boPopupOpts);
	
	        nodeOptions.bindBoClickEvent(options);
	    };
	
	    module.exports = BO;
	


/***/ }),
/* 43 */
/***/ (function(module, exports) {

	/**
	 * Created by majianan on 16/5/19.
	 */
	
	    module.exports = {
	        BO_NODE_WIDTH: 180,    //BO矩形宽度
	        BO_NODE_DEFAULT_HEIGHT: 60,	//BO矩形默认高度，即只有BO名字的情况
	        BO_NODE_OFFSET_X: 90, //BO矩形的水平偏移量=矩形宽度的一般
	        BO_NODE_OFFSET_Y: 50, //BO矩形的垂直偏移量
	
	        BO_NAME_FONT: 'bold 18px Arial', //'normal 16px verdana',    //BO名字文本样式,
	        BO_NAME_PADDING_TOP: 10,   //BO名字与矩形上边框的距离
	        BO_NAME_PADDING_BOTTOM: 15,   //BO名字与下一个控件（事件决策或者横线）的距离
	
	        BO_EVENT_HEIGHT: 20,   //BO事件决策多边形高度
	        BO_EVENT_WIDTH: 140,   //BO事件决策多边形宽度
	        BO_EVENT_FONT: 'normal 14px Arial',  //BO事件决策名字文本样式
	
	        BO_ATTR_FONT: 'normal 14px Arial',   //BO属性名字文本样式
	        BO_ATTR_PADDING_TOP: 5,   //BO属性名字与矩形上边框的距离
	        BO_ATTR_PADDING_BOTTOM: 5,   //BO属性名字与下一个控件（事件决策或者横线）的距离
	        BO_ATTR_PADDING_LEFT: 5,   //BO属性名字与矩形左边框的距离
	        BO_ATTR_DATA_TYPE_PADDING_RIGHT: 5, //BO属性数据类型与矩形右边框的距离
	        BO_ATTR_EVENT_WIDTH: 135,   //BO属性事件决策多边形宽度
	
	        LINE_DASH: 10,  //虚线
	        RELATION_OFFSET: 40,   //关联关系的初始偏移量，即第一段折线宽度
	        RELATION_ARROW_WIDTH: 10,  //关联关系三角箭头水平宽度
	        RELATION_ARROW_HEIGHT: 5,  //关联关系三角箭头垂直高度的一半
	        RELATION_TEXT_OFFSET_X: 10, //关联关系文字说明水平偏移量
	        RELATION_TEXT_OFFSET_Y: 5 //关联关系文字说明垂直偏移量
	    };
	


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * BO名字
	 * @module fish-topo-bo/node/BoName
	 * Created by majianan on 16/5/19.
	 */
	
	    var Const = __webpack_require__(43);
	    var graphic = __webpack_require__(45);
	
	    /**
	     *
	     * @param {String} text, BO名字
	     * @param {{x: number, y: number}} startPos, 起始位置
	     * @returns {zrender/graphic/Text}
	     * @constructor
	     */
	    function BoName(text, startPos) {
	        var x = startPos.x,
	            y = startPos.y + Const.BO_NAME_PADDING_TOP, //文字到矩形上边框的距离 padding-top=10
	
	            shape = new graphic.Text({
	                style: {
	                    text: text,
	                    textFont: Const.BO_NAME_FONT,
	                    textAlign: 'left',  //靠左开始，便于计算位置
	                    textBaseline: 'top'
	                },
	
	                position: [x, y]
	            });
	
	        //文字居中显示，重新计算文本水平起始位置 = 矩形水平起始位置 + (BO矩形宽度 - 文本宽度)/2
	        shape.position[0] += (Const.BO_NODE_WIDTH - shape.getBoundingRect().width) / 2;
	
	        //重新设置BO名字图形高度 = 文本高度 + padding-top + padding-bottom
	        shape.getBoundingRect().height += Const.BO_NAME_PADDING_TOP + Const.BO_NAME_PADDING_BOTTOM;
	
	        return shape;
	    }
	
	    module.exports = BoName;
	


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(6);
	
	    var pathTool = __webpack_require__(46);
	    var round = Math.round;
	    var Path = __webpack_require__(47);
	    var colorTool = __webpack_require__(20);
	    var matrix = __webpack_require__(15);
	    var vector = __webpack_require__(8);
	    var Gradient = __webpack_require__(59);
	    var Draggable = __webpack_require__(9);
	
	    var graphic = {};
	    graphic.Util = zrUtil;
	    graphic.Group = __webpack_require__(12);
	
	    graphic.Image = __webpack_require__(31);
	
	    graphic.Text = __webpack_require__(60);
	
	    graphic.textContain = __webpack_require__(35);
	
	    graphic.Circle = __webpack_require__(61);
	
	    graphic.Sector = __webpack_require__(62);
	
	    graphic.Ring = __webpack_require__(64);
	
	    graphic.Polygon = __webpack_require__(65);
	
	    graphic.Polyline = __webpack_require__(69);
	
	    graphic.Rect = __webpack_require__(70);
	
	    graphic.Line = __webpack_require__(71);
	
	    graphic.BezierCurve = __webpack_require__(72);
	
	    graphic.Arc = __webpack_require__(73);
	
	    graphic.LinearGradient = __webpack_require__(74);
	
	    graphic.RadialGradient = __webpack_require__(75);
	
	    graphic.BoundingRect = __webpack_require__(24);
	    graphic.States = __webpack_require__(76);
	    /**
	     * Extend shape with parameters
	     */
	    graphic.extendShape = function (opts) {
	        return Path.extend(opts);
	    };
	
	    /**
	     * Extend path
	     */
	    graphic.extendPath = function (pathData, opts) {
	        return pathTool.extendFromString(pathData, opts);
	    };
	
	    /**
	     * Create a path element from path data string
	     * @param {string} pathData
	     * @param {Object} opts
	     * @param {module:zrender/core/BoundingRect} rect
	     * @param {string} [layout=cover] 'center' or 'cover'
	     */
	    graphic.makePath = function (pathData, opts, rect, layout) {
	        var path = pathTool.createFromString(pathData, opts);
	        Draggable.call(path);
	        var boundingRect = path.getBoundingRect();
	        if (rect) {
	            var aspect = boundingRect.width / boundingRect.height;
	
	            if (layout === 'center') {
	                // Set rect to center, keep width / height ratio.
	                var width = rect.height * aspect;
	                var height;
	                if (width <= rect.width) {
	                    height = rect.height;
	                }
	                else {
	                    width = rect.width;
	                    height = width / aspect;
	                }
	                var cx = rect.x + rect.width / 2;
	                var cy = rect.y + rect.height / 2;
	
	                rect.x = cx - width / 2;
	                rect.y = cy - height / 2;
	                rect.width = width;
	                rect.height = height;
	            }
	
	            this.resizePath(path, rect);
	        }
	
	        zrUtil.inherits(path, Draggable);
	        return path;
	    };
	
	    graphic.mergePath = pathTool.mergePath;
	
	    /**
	     * Resize a path to fit the rect
	     * @param {module:zrender/graphic/Path} path
	     * @param {Object} rect
	     */
	    graphic.resizePath = function (path, rect) {
	        if (!path.applyTransform) {
	            return;
	        }
	
	        var pathRect = path.getBoundingRect();
	
	        var m = pathRect.calculateTransform(rect);
	
	        path.applyTransform(m);
	    };
	
	    /**
	     * Sub pixel optimize line for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x1]
	     * @param {number} [param.shape.y1]
	     * @param {number} [param.shape.x2]
	     * @param {number} [param.shape.y2]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeLine = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	
	        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {
	            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);
	        }
	        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {
	            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);
	        }
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize rect for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x]
	     * @param {number} [param.shape.y]
	     * @param {number} [param.shape.width]
	     * @param {number} [param.shape.height]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeRect = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	        var originX = shape.x;
	        var originY = shape.y;
	        var originWidth = shape.width;
	        var originHeight = shape.height;
	        shape.x = subPixelOptimize(shape.x, lineWidth, true);
	        shape.y = subPixelOptimize(shape.y, lineWidth, true);
	        shape.width = Math.max(
	            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,
	            originWidth === 0 ? 0 : 1
	        );
	        shape.height = Math.max(
	            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,
	            originHeight === 0 ? 0 : 1
	        );
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize for canvas
	     *
	     * @param {number} position Coordinate, such as x, y
	     * @param {number} lineWidth Should be nonnegative integer.
	     * @param {boolean=} positiveOrNegative Default false (negative).
	     * @return {number} Optimized position.
	     */
	    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {
	        // Assure that (position + lineWidth / 2) is near integer edge,
	        // otherwise line will be fuzzy in canvas.
	        var doubledPosition = round(position * 2);
	        return (doubledPosition + round(lineWidth)) % 2 === 0
	            ? doubledPosition / 2
	            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
	    };
	
	    /**
	     * @private
	     */
	    function doSingleEnterHover(el) {
	        if (el.__isHover) {
	            return;
	        }
	        if (el.__hoverStlDirty) {
	            var stroke = el.style.stroke;
	            var fill = el.style.fill;
	
	            // Create hoverStyle on mouseover
	            var hoverStyle = el.__hoverStl;
	            var lift = colorTool.lift;
	            hoverStyle.fill = hoverStyle.fill
	                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));
	            hoverStyle.stroke = hoverStyle.stroke
	                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));
	
	            var normalStyle = {};
	            for (var name in hoverStyle) {
	                if (hoverStyle.hasOwnProperty(name)) {
	                    normalStyle[name] = el.style[name];
	                }
	            }
	
	            el.__normalStl = normalStyle;
	
	            el.__hoverStlDirty = false;
	        }
	        el.setStyle(el.__hoverStl);
	        el.z2 += 1;
	
	        el.__isHover = true;
	    }
	
	    /**
	     * @inner
	     */
	    function doSingleLeaveHover(el) {
	        if (!el.__isHover) {
	            return;
	        }
	
	        var normalStl = el.__normalStl;
	        normalStl && el.setStyle(normalStl);
	        el.z2 -= 1;
	
	        el.__isHover = false;
	    }
	
	    /**
	     * @inner
	     */
	    function doEnterHover(el) {
	        (el.type === 'group' || el.type === 'GroupNode')
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleEnterHover(child);
	                }
	            })
	            : doSingleEnterHover(el);
	    }
	    graphic.doEnterHover = doEnterHover;
	    function doLeaveHover(el) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleLeaveHover(child);
	                }
	            })
	            : doSingleLeaveHover(el);
	    }
	    graphic.doLeaveHover = doLeaveHover;
	    /**
	     * @inner
	     */
	    function setElementHoverStl(el, hoverStl) {
	        // If element has sepcified hoverStyle, then use it instead of given hoverStyle
	        // Often used when item group has a label element and it's hoverStyle is different
	        el.__hoverStl = el.hoverStyle || hoverStl || {};
	        el.__hoverStlDirty = true;
	    }
	    graphic.setElementHoverStl = setElementHoverStl;
	    /**
	     * @inner
	     */
	    function onElementMouseOver() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function onElementMouseOut() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doLeaveHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function enterEmphasis() {
	        this.__isEmphasis = true;
	        doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function leaveEmphasis() {
	        this.__isEmphasis = false;
	        doLeaveHover(this);
	    }
	
	    /**
	     * Set hover style of element
	     * @param {module:zrender/Element} el
	     * @param {Object} [hoverStyle]
	     */
	    graphic.setHoverStyle = function (el, hoverStyle) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    setElementHoverStl(child, hoverStyle);
	                }
	            })
	            : setElementHoverStl(el, hoverStyle);
	        // Remove previous bound handlers
	        el.on('mouseover', onElementMouseOver)
	          .on('mouseout', onElementMouseOut);
	
	        // Emphasis, normal can be triggered manually
	        el.on('emphasis', enterEmphasis)
	          .on('normal', leaveEmphasis);
	    };
	
	    graphic.setNormalStyle = function(el, options) {
	        if (el.__normalStl) {
	            for (var name in options) {
	                if (el.__normalStl.hasOwnProperty(name)) {
	                    el.__normalStl[name] = options[name];
	                }
	            }
	        }
	    };
	
	    /**
	     * Set text option in the style
	     * @param {Object} textStyle
	     * @param {module:echarts/model/Model} labelModel
	     * @param {string} color
	     */
	    graphic.setText = function (textStyle, labelModel, color) {
	        var labelPosition = labelModel.getShallow('position') || 'inside';
	        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;
	        var textStyleModel = labelModel.getModel('textStyle');
	        zrUtil.extend(textStyle, {
	            textDistance: labelModel.getShallow('distance') || 5,
	            textFont: textStyleModel.getFont(),
	            textPosition: labelPosition,
	            textFill: textStyleModel.getTextColor() || labelColor
	        });
	    };
	
	    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {
	        var postfix = isUpdate ? 'Update' : '';
	        var duration = animatableModel
	            && animatableModel.getShallow('animationDuration' + postfix);
	        var animationEasing = animatableModel
	            && animatableModel.getShallow('animationEasing' + postfix);
	
	        animatableModel && animatableModel.getShallow('animation')
	            ? el.animateTo(props, duration, animationEasing, cb)
	            : (el.attr(props), cb && cb());
	    }
	    /**
	     * Update graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
	    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);
	
	    /**
	     * Init graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
	    graphic.initProps = zrUtil.curry(animateOrSetProps, false);
	
	    /**
	     * Get transform matrix of target (param target),
	     * in coordinate of its ancestor (param ancestor)
	     *
	     * @param {module:zrender/mixin/Transformable} target
	     * @param {module:zrender/mixin/Transformable} ancestor
	     */
	    graphic.getTransform = function (target, ancestor) {
	        var mat = matrix.identity([]);
	
	        while (target && target !== ancestor) {
	            matrix.mul(mat, target.getLocalTransform(), mat);
	            target = target.parent;
	        }
	
	        return mat;
	    };
	
	    /**
	     * Apply transform to an vertex.
	     * @param {Array.<number>} vertex [x, y]
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {Array.<number>} [x, y]
	     */
	    graphic.applyTransform = function (vertex, transform, invert) {
	        if (invert) {
	            transform = matrix.invert([], transform);
	        }
	        return vector.applyTransform([], vertex, transform);
	    };
	
	    /**
	     * @param {string} direction 'left' 'right' 'top' 'bottom'
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'
	     */
	    graphic.transformDirection = function (direction, transform, invert) {
	
	        // Pick a base, ensure that transform result will not be (0, 0).
	        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[0]);
	        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[2]);
	
	        var vertex = [
	            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,
	            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0
	        ];
	
	        vertex = graphic.applyTransform(vertex, transform, invert);
	
	        return Math.abs(vertex[0]) > Math.abs(vertex[1])
	            ? (vertex[0] > 0 ? 'right' : 'left')
	            : (vertex[1] > 0 ? 'bottom' : 'top');
	    };
	
	    module.exports = graphic;
	


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(47);
	
	var PathProxy = __webpack_require__(48);
	
	var transformPath = __webpack_require__(58);
	
	// command chars
	var cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];
	var mathSqrt = Math.sqrt;
	var mathSin = Math.sin;
	var mathCos = Math.cos;
	var PI = Math.PI;
	
	var vMag = function (v) {
	  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
	};
	
	var vRatio = function (u, v) {
	  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
	};
	
	var vAngle = function (u, v) {
	  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
	};
	
	function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
	  var psi = psiDeg * (PI / 180.0);
	  var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;
	  var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;
	  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
	
	  if (lambda > 1) {
	    rx *= mathSqrt(lambda);
	    ry *= mathSqrt(lambda);
	  }
	
	  var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
	  var cxp = f * rx * yp / ry;
	  var cyp = f * -ry * xp / rx;
	  var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;
	  var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;
	  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
	  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
	  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
	  var dTheta = vAngle(u, v);
	
	  if (vRatio(u, v) <= -1) {
	    dTheta = PI;
	  }
	
	  if (vRatio(u, v) >= 1) {
	    dTheta = 0;
	  }
	
	  if (fs === 0 && dTheta > 0) {
	    dTheta = dTheta - 2 * PI;
	  }
	
	  if (fs === 1 && dTheta < 0) {
	    dTheta = dTheta + 2 * PI;
	  }
	
	  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
	}
	
	function createPathProxyFromString(data) {
	  if (!data) {
	    return [];
	  } // command string
	
	
	  var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');
	  var n; // create pipes so that we can split the data
	
	  for (n = 0; n < cc.length; n++) {
	    cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
	  } // create array
	
	
	  var arr = cs.split('|'); // init context point
	
	  var cpx = 0;
	  var cpy = 0;
	  var path = new PathProxy();
	  var CMD = PathProxy.CMD;
	  var prevCmd;
	
	  for (n = 1; n < arr.length; n++) {
	    var str = arr[n];
	    var c = str.charAt(0);
	    var off = 0;
	    var p = str.slice(1).replace(/e,-/g, 'e-').split(',');
	    var cmd;
	
	    if (p.length > 0 && p[0] === '') {
	      p.shift();
	    }
	
	    for (var i = 0; i < p.length; i++) {
	      p[i] = parseFloat(p[i]);
	    }
	
	    while (off < p.length && !isNaN(p[off])) {
	      if (isNaN(p[0])) {
	        break;
	      }
	
	      var ctlPtx;
	      var ctlPty;
	      var rx;
	      var ry;
	      var psi;
	      var fa;
	      var fs;
	      var x1 = cpx;
	      var y1 = cpy; // convert l, H, h, V, and v to L
	
	      switch (c) {
	        case 'l':
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'L':
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'm':
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.M;
	          path.addData(cmd, cpx, cpy);
	          c = 'l';
	          break;
	
	        case 'M':
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.M;
	          path.addData(cmd, cpx, cpy);
	          c = 'L';
	          break;
	
	        case 'h':
	          cpx += p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'H':
	          cpx = p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'v':
	          cpy += p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'V':
	          cpy = p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'C':
	          cmd = CMD.C;
	          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
	          cpx = p[off - 2];
	          cpy = p[off - 1];
	          break;
	
	        case 'c':
	          cmd = CMD.C;
	          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
	          cpx += p[off - 2];
	          cpy += p[off - 1];
	          break;
	
	        case 'S':
	          ctlPtx = cpx;
	          ctlPty = cpy;
	          var len = path.len();
	          var pathData = path.data;
	
	          if (prevCmd === CMD.C) {
	            ctlPtx += cpx - pathData[len - 4];
	            ctlPty += cpy - pathData[len - 3];
	          }
	
	          cmd = CMD.C;
	          x1 = p[off++];
	          y1 = p[off++];
	          cpx = p[off++];
	          cpy = p[off++];
	          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	          break;
	
	        case 's':
	          ctlPtx = cpx;
	          ctlPty = cpy;
	          var len = path.len();
	          var pathData = path.data;
	
	          if (prevCmd === CMD.C) {
	            ctlPtx += cpx - pathData[len - 4];
	            ctlPty += cpy - pathData[len - 3];
	          }
	
	          cmd = CMD.C;
	          x1 = cpx + p[off++];
	          y1 = cpy + p[off++];
	          cpx += p[off++];
	          cpy += p[off++];
	          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	          break;
	
	        case 'Q':
	          x1 = p[off++];
	          y1 = p[off++];
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.Q;
	          path.addData(cmd, x1, y1, cpx, cpy);
	          break;
	
	        case 'q':
	          x1 = p[off++] + cpx;
	          y1 = p[off++] + cpy;
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.Q;
	          path.addData(cmd, x1, y1, cpx, cpy);
	          break;
	
	        case 'T':
	          ctlPtx = cpx;
	          ctlPty = cpy;
	          var len = path.len();
	          var pathData = path.data;
	
	          if (prevCmd === CMD.Q) {
	            ctlPtx += cpx - pathData[len - 4];
	            ctlPty += cpy - pathData[len - 3];
	          }
	
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.Q;
	          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	          break;
	
	        case 't':
	          ctlPtx = cpx;
	          ctlPty = cpy;
	          var len = path.len();
	          var pathData = path.data;
	
	          if (prevCmd === CMD.Q) {
	            ctlPtx += cpx - pathData[len - 4];
	            ctlPty += cpy - pathData[len - 3];
	          }
	
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.Q;
	          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	          break;
	
	        case 'A':
	          rx = p[off++];
	          ry = p[off++];
	          psi = p[off++];
	          fa = p[off++];
	          fs = p[off++];
	          x1 = cpx, y1 = cpy;
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.A;
	          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
	          break;
	
	        case 'a':
	          rx = p[off++];
	          ry = p[off++];
	          psi = p[off++];
	          fa = p[off++];
	          fs = p[off++];
	          x1 = cpx, y1 = cpy;
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.A;
	          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
	          break;
	      }
	    }
	
	    if (c === 'z' || c === 'Z') {
	      cmd = CMD.Z;
	      path.addData(cmd);
	    }
	
	    prevCmd = cmd;
	  }
	
	  path.toStatic();
	  return path;
	} // TODO Optimize double memory cost problem
	
	
	function createPathOptions(str, opts) {
	  var pathProxy = createPathProxyFromString(str);
	  opts = opts || {};
	
	  opts.buildPath = function (path) {
	    if (path.setData) {
	      path.setData(pathProxy.data); // Svg and vml renderer don't have context
	
	      var ctx = path.getContext();
	
	      if (ctx) {
	        path.rebuildPath(ctx);
	      }
	    } else {
	      var ctx = path;
	      pathProxy.rebuildPath(ctx);
	    }
	  };
	
	  opts.applyTransform = function (m) {
	    transformPath(pathProxy, m);
	    this.dirty(true);
	  };
	
	  return opts;
	}
	/**
	 * Create a Path object from path string data
	 * http://www.w3.org/TR/SVG/paths.html#PathData
	 * @param  {Object} opts Other options
	 */
	
	
	function createFromString(str, opts) {
	  return new Path(createPathOptions(str, opts));
	}
	/**
	 * Create a Path class from path string data
	 * @param  {string} str
	 * @param  {Object} opts Other options
	 */
	
	
	function extendFromString(str, opts) {
	  return Path.extend(createPathOptions(str, opts));
	}
	/**
	 * Merge multiple paths
	 */
	// TODO Apply transform
	// TODO stroke dash
	// TODO Optimize double memory cost problem
	
	
	function mergePath(pathEls, opts) {
	  var pathList = [];
	  var len = pathEls.length;
	
	  for (var i = 0; i < len; i++) {
	    var pathEl = pathEls[i];
	
	    if (!pathEl.path) {
	      pathEl.createPathProxy();
	    }
	
	    if (pathEl.__dirtyPath) {
	      pathEl.buildPath(pathEl.path, pathEl.shape, true);
	    }
	
	    pathList.push(pathEl.path);
	  }
	
	  var pathBundle = new Path(opts); // Need path proxy.
	
	  pathBundle.createPathProxy();
	
	  pathBundle.buildPath = function (path) {
	    path.appendPath(pathList); // Svg and vml renderer don't have context
	
	    var ctx = path.getContext();
	
	    if (ctx) {
	      path.rebuildPath(ctx);
	    }
	  };
	
	  return pathBundle;
	}
	
	exports.createFromString = createFromString;
	exports.extendFromString = extendFromString;
	exports.mergePath = mergePath;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	var Displayable = __webpack_require__(32);
	
	var zrUtil = __webpack_require__(6);
	
	var PathProxy = __webpack_require__(48);
	
	var pathContain = __webpack_require__(51);
	
	var Pattern = __webpack_require__(29);
	
	var getCanvasPattern = Pattern.prototype.getCanvasPattern;
	var abs = Math.abs;
	var pathProxyForDraw = new PathProxy(true);
	/**
	 * @alias module:zrender/graphic/Path
	 * @extends module:zrender/graphic/Displayable
	 * @constructor
	 * @param {Object} opts
	 */
	
	function Path(opts) {
	  Displayable.call(this, opts);
	  /**
	   * @type {module:zrender/core/PathProxy}
	   * @readOnly
	   */
	
	  this.path = null;
	}
	
	Path.prototype = {
	  constructor: Path,
	  type: 'path',
	  __dirtyPath: true,
	  strokeContainThreshold: 5,
	  brush: function (ctx, prevEl) {
	    var style = this.style;
	    var path = this.path || pathProxyForDraw;
	    var hasStroke = style.hasStroke();
	    var hasFill = style.hasFill();
	    var fill = style.fill;
	    var stroke = style.stroke;
	    var hasFillGradient = hasFill && !!fill.colorStops;
	    var hasStrokeGradient = hasStroke && !!stroke.colorStops;
	    var hasFillPattern = hasFill && !!fill.image;
	    var hasStrokePattern = hasStroke && !!stroke.image;
	    style.bind(ctx, this, prevEl);
	    this.setTransform(ctx);
	
	    if (this.__dirty) {
	      var rect; // Update gradient because bounding rect may changed
	
	      if (hasFillGradient) {
	        rect = rect || this.getBoundingRect();
	        this._fillGradient = style.getGradient(ctx, fill, rect);
	      }
	
	      if (hasStrokeGradient) {
	        rect = rect || this.getBoundingRect();
	        this._strokeGradient = style.getGradient(ctx, stroke, rect);
	      }
	    } // Use the gradient or pattern
	
	
	    if (hasFillGradient) {
	      // PENDING If may have affect the state
	      ctx.fillStyle = this._fillGradient;
	    } else if (hasFillPattern) {
	      ctx.fillStyle = getCanvasPattern.call(fill, ctx);
	    }
	
	    if (hasStrokeGradient) {
	      ctx.strokeStyle = this._strokeGradient;
	    } else if (hasStrokePattern) {
	      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
	    }
	
	    var lineDash = style.lineDash;
	    var lineDashOffset = style.lineDashOffset;
	    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy
	
	    var scale = this.getGlobalScale();
	    path.setScale(scale[0], scale[1]); // Proxy context
	    // Rebuild path in following 2 cases
	    // 1. Path is dirty
	    // 2. Path needs javascript implemented lineDash stroking.
	    //    In this case, lineDash information will not be saved in PathProxy
	
	    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {
	      path.beginPath(ctx); // Setting line dash before build path
	
	      if (lineDash && !ctxLineDash) {
	        path.setLineDash(lineDash);
	        path.setLineDashOffset(lineDashOffset);
	      }
	
	      this.buildPath(path, this.shape, false); // Clear path dirty flag
	
	      if (this.path) {
	        this.__dirtyPath = false;
	      }
	    } else {
	      // Replay path building
	      ctx.beginPath();
	      this.path.rebuildPath(ctx);
	    }
	
	    hasFill && path.fill(ctx);
	
	    if (lineDash && ctxLineDash) {
	      ctx.setLineDash(lineDash);
	      ctx.lineDashOffset = lineDashOffset;
	    }
	
	    hasStroke && path.stroke(ctx);
	
	    if (lineDash && ctxLineDash) {
	      // PENDING
	      // Remove lineDash
	      ctx.setLineDash([]);
	    }
	
	    this.restoreTransform(ctx); // Draw rect text
	
	    if (style.text != null) {
	      this.drawRectText(ctx, this.getBoundingRect());
	    }
	  },
	  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
	  // Like in circle
	  buildPath: function (ctx, shapeCfg, inBundle) {},
	  createPathProxy: function () {
	    this.path = new PathProxy();
	  },
	  getBoundingRect: function () {
	    var rect = this._rect;
	    var style = this.style;
	    var needsUpdateRect = !rect;
	
	    if (needsUpdateRect) {
	      var path = this.path;
	
	      if (!path) {
	        // Create path on demand.
	        path = this.path = new PathProxy();
	      }
	
	      if (this.__dirtyPath) {
	        path.beginPath();
	        this.buildPath(path, this.shape, false);
	      }
	
	      rect = path.getBoundingRect();
	    }
	
	    this._rect = rect;
	
	    if (style.hasStroke()) {
	      // Needs update rect with stroke lineWidth when
	      // 1. Element changes scale or lineWidth
	      // 2. Shape is changed
	      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());
	
	      if (this.__dirty || needsUpdateRect) {
	        rectWithStroke.copy(rect); // FIXME Must after updateTransform
	
	        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical
	
	        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill
	
	        if (!style.hasFill()) {
	          w = Math.max(w, this.strokeContainThreshold || 4);
	        } // Consider line width
	        // Line scale can't be 0;
	
	
	        if (lineScale > 1e-10) {
	          rectWithStroke.width += w / lineScale;
	          rectWithStroke.height += w / lineScale;
	          rectWithStroke.x -= w / lineScale / 2;
	          rectWithStroke.y -= w / lineScale / 2;
	        }
	      } // Return rect with stroke
	
	
	      return rectWithStroke;
	    }
	
	    return rect;
	  },
	  contain: function (x, y) {
	    var localPos = this.transformCoordToLocal(x, y);
	    var rect = this.getBoundingRect();
	    var style = this.style;
	    x = localPos[0];
	    y = localPos[1];
	
	    if (rect.contain(x, y)) {
	      var pathData = this.path.data;
	
	      if (style.hasStroke()) {
	        var lineWidth = style.lineWidth;
	        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;
	
	        if (lineScale > 1e-10) {
	          // Only add extra hover lineWidth when there are no fill
	          if (!style.hasFill()) {
	            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
	          }
	
	          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {
	            return true;
	          }
	        }
	      }
	
	      if (style.hasFill()) {
	        return pathContain.contain(pathData, x, y);
	      }
	    }
	
	    return false;
	  },
	
	  /**
	   * @param  {boolean} dirtyPath
	   */
	  dirty: function (dirtyPath) {
	    if (dirtyPath == null) {
	      dirtyPath = true;
	    } // Only mark dirty, not mark clean
	
	
	    if (dirtyPath) {
	      this.__dirtyPath = dirtyPath;
	      this._rect = null;
	    }
	
	    this.__dirty = true;
	    this.__zr && this.__zr.refresh(); // Used as a clipping path
	
	    if (this.__clipTarget) {
	      this.__clipTarget.dirty();
	    }
	  },
	
	  /**
	   * Alias for animate('shape')
	   * @param {boolean} loop
	   */
	  animateShape: function (loop) {
	    return this.animate('shape', loop);
	  },
	  // Overwrite attrKV
	  attrKV: function (key, value) {
	    // FIXME
	    if (key === 'shape') {
	      this.setShape(value);
	      this.__dirtyPath = true;
	      this._rect = null;
	    } else {
	      Displayable.prototype.attrKV.call(this, key, value);
	    }
	  },
	
	  /**
	   * @param {Object|string} key
	   * @param {*} value
	   */
	  setShape: function (key, value) {
	    var shape = this.shape; // Path from string may not have shape
	
	    if (shape) {
	      if (zrUtil.isObject(key)) {
	        for (var name in key) {
	          if (key.hasOwnProperty(name)) {
	            shape[name] = key[name];
	          }
	        }
	      } else {
	        shape[key] = value;
	      }
	
	      this.dirty(true);
	    }
	
	    return this;
	  },
	  getLineScale: function () {
	    var m = this.transform; // Get the line scale.
	    // Determinant of `m` means how much the area is enlarged by the
	    // transformation. So its square root can be used as a scale factor
	    // for width.
	
	    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;
	  }
	};
	/**
	 * 扩展一个 Path element, 比如星形，圆等。
	 * Extend a path element
	 * @param {Object} props
	 * @param {string} props.type Path type
	 * @param {Function} props.init Initialize
	 * @param {Function} props.buildPath Overwrite buildPath method
	 * @param {Object} [props.style] Extended default style config
	 * @param {Object} [props.shape] Extended default shape config
	 */
	
	Path.extend = function (defaults) {
	  var Sub = function (opts) {
	    Path.call(this, opts);
	
	    if (defaults.style) {
	      // Extend default style
	      this.style.extendFrom(defaults.style, false);
	    } // Extend default shape
	
	
	    var defaultShape = defaults.shape;
	
	    if (defaultShape) {
	      this.shape = this.shape || {};
	      var thisShape = this.shape;
	
	      for (var name in defaultShape) {
	        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {
	          thisShape[name] = defaultShape[name];
	        }
	      }
	    }
	
	    defaults.init && defaults.init.call(this, opts);
	  };
	
	  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象
	
	  for (var name in defaults) {
	    // Extending prototype values and methods
	    if (name !== 'style' && name !== 'shape') {
	      Sub.prototype[name] = defaults[name];
	    }
	  }
	
	  return Sub;
	};
	
	zrUtil.inherits(Path, Displayable);
	var _default = Path;
	module.exports = _default;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	var curve = __webpack_require__(49);
	
	var vec2 = __webpack_require__(8);
	
	var bbox = __webpack_require__(50);
	
	var BoundingRect = __webpack_require__(24);
	
	var _config = __webpack_require__(23);
	
	var dpr = _config.devicePixelRatio;
	
	/**
	 * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
	 * 可以用于 isInsidePath 判断以及获取boundingRect
	 *
	 * @module zrender/core/PathProxy
	 * @author Yi Shen (http://www.github.com/pissang)
	 */
	// TODO getTotalLength, getPointAtLength
	var CMD = {
	  M: 1,
	  L: 2,
	  C: 3,
	  Q: 4,
	  A: 5,
	  Z: 6,
	  // Rect
	  R: 7
	}; // var CMD_MEM_SIZE = {
	//     M: 3,
	//     L: 3,
	//     C: 7,
	//     Q: 5,
	//     A: 9,
	//     R: 5,
	//     Z: 1
	// };
	
	var min = [];
	var max = [];
	var min2 = [];
	var max2 = [];
	var mathMin = Math.min;
	var mathMax = Math.max;
	var mathCos = Math.cos;
	var mathSin = Math.sin;
	var mathSqrt = Math.sqrt;
	var mathAbs = Math.abs;
	var hasTypedArray = typeof Float32Array != 'undefined';
	/**
	 * @alias module:zrender/core/PathProxy
	 * @constructor
	 */
	
	var PathProxy = function (notSaveData) {
	  this._saveData = !(notSaveData || false);
	
	  if (this._saveData) {
	    /**
	     * Path data. Stored as flat array
	     * @type {Array.<Object>}
	     */
	    this.data = [];
	  }
	
	  this._ctx = null;
	};
	/**
	 * 快速计算Path包围盒（并不是最小包围盒）
	 * @return {Object}
	 */
	
	
	PathProxy.prototype = {
	  constructor: PathProxy,
	  _xi: 0,
	  _yi: 0,
	  _x0: 0,
	  _y0: 0,
	  // Unit x, Unit y. Provide for avoiding drawing that too short line segment
	  _ux: 0,
	  _uy: 0,
	  _len: 0,
	  _lineDash: null,
	  _dashOffset: 0,
	  _dashIdx: 0,
	  _dashSum: 0,
	
	  /**
	   * @readOnly
	   */
	  setScale: function (sx, sy) {
	    this._ux = mathAbs(1 / dpr / sx) || 0;
	    this._uy = mathAbs(1 / dpr / sy) || 0;
	  },
	  getContext: function () {
	    return this._ctx;
	  },
	
	  /**
	   * @param  {CanvasRenderingContext2D} ctx
	   * @return {module:zrender/core/PathProxy}
	   */
	  beginPath: function (ctx) {
	    this._ctx = ctx;
	    ctx && ctx.beginPath();
	    ctx && (this.dpr = ctx.dpr); // Reset
	
	    if (this._saveData) {
	      this._len = 0;
	    }
	
	    if (this._lineDash) {
	      this._lineDash = null;
	      this._dashOffset = 0;
	    }
	
	    return this;
	  },
	
	  /**
	   * @param  {number} x
	   * @param  {number} y
	   * @return {module:zrender/core/PathProxy}
	   */
	  moveTo: function (x, y) {
	    this.addData(CMD.M, x, y);
	    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用
	    // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。
	    // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要
	    // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持
	
	    this._x0 = x;
	    this._y0 = y;
	    this._xi = x;
	    this._yi = y;
	    return this;
	  },
	
	  /**
	   * @param  {number} x
	   * @param  {number} y
	   * @return {module:zrender/core/PathProxy}
	   */
	  lineTo: function (x, y) {
	    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment
	    || this._len < 5;
	    this.addData(CMD.L, x, y);
	
	    if (this._ctx && exceedUnit) {
	      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);
	    }
	
	    if (exceedUnit) {
	      this._xi = x;
	      this._yi = y;
	    }
	
	    return this;
	  },
	
	  /**
	   * @param  {number} x1
	   * @param  {number} y1
	   * @param  {number} x2
	   * @param  {number} y2
	   * @param  {number} x3
	   * @param  {number} y3
	   * @return {module:zrender/core/PathProxy}
	   */
	  bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {
	    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);
	
	    if (this._ctx) {
	      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
	    }
	
	    this._xi = x3;
	    this._yi = y3;
	    return this;
	  },
	
	  /**
	   * @param  {number} x1
	   * @param  {number} y1
	   * @param  {number} x2
	   * @param  {number} y2
	   * @return {module:zrender/core/PathProxy}
	   */
	  quadraticCurveTo: function (x1, y1, x2, y2) {
	    this.addData(CMD.Q, x1, y1, x2, y2);
	
	    if (this._ctx) {
	      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
	    }
	
	    this._xi = x2;
	    this._yi = y2;
	    return this;
	  },
	
	  /**
	   * @param  {number} cx
	   * @param  {number} cy
	   * @param  {number} r
	   * @param  {number} startAngle
	   * @param  {number} endAngle
	   * @param  {boolean} anticlockwise
	   * @return {module:zrender/core/PathProxy}
	   */
	  arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {
	    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);
	    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
	    this._xi = mathCos(endAngle) * r + cx;
	    this._yi = mathSin(endAngle) * r + cx;
	    return this;
	  },
	  // TODO
	  arcTo: function (x1, y1, x2, y2, radius) {
	    if (this._ctx) {
	      this._ctx.arcTo(x1, y1, x2, y2, radius);
	    }
	
	    return this;
	  },
	  // TODO
	  rect: function (x, y, w, h) {
	    this._ctx && this._ctx.rect(x, y, w, h);
	    this.addData(CMD.R, x, y, w, h);
	    return this;
	  },
	
	  /**
	   * @return {module:zrender/core/PathProxy}
	   */
	  closePath: function () {
	    this.addData(CMD.Z);
	    var ctx = this._ctx;
	    var x0 = this._x0;
	    var y0 = this._y0;
	
	    if (ctx) {
	      this._needsDash() && this._dashedLineTo(x0, y0);
	      ctx.closePath();
	    }
	
	    this._xi = x0;
	    this._yi = y0;
	    return this;
	  },
	
	  /**
	   * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
	   * stroke 同样
	   * @param {CanvasRenderingContext2D} ctx
	   * @return {module:zrender/core/PathProxy}
	   */
	  fill: function (ctx) {
	    ctx && ctx.fill();
	    this.toStatic();
	  },
	
	  /**
	   * @param {CanvasRenderingContext2D} ctx
	   * @return {module:zrender/core/PathProxy}
	   */
	  stroke: function (ctx) {
	    ctx && ctx.stroke();
	    this.toStatic();
	  },
	
	  /**
	   * 必须在其它绘制命令前调用
	   * Must be invoked before all other path drawing methods
	   * @return {module:zrender/core/PathProxy}
	   */
	  setLineDash: function (lineDash) {
	    if (lineDash instanceof Array) {
	      this._lineDash = lineDash;
	      this._dashIdx = 0;
	      var lineDashSum = 0;
	
	      for (var i = 0; i < lineDash.length; i++) {
	        lineDashSum += lineDash[i];
	      }
	
	      this._dashSum = lineDashSum;
	    }
	
	    return this;
	  },
	
	  /**
	   * 必须在其它绘制命令前调用
	   * Must be invoked before all other path drawing methods
	   * @return {module:zrender/core/PathProxy}
	   */
	  setLineDashOffset: function (offset) {
	    this._dashOffset = offset;
	    return this;
	  },
	
	  /**
	   *
	   * @return {boolean}
	   */
	  len: function () {
	    return this._len;
	  },
	
	  /**
	   * 直接设置 Path 数据
	   */
	  setData: function (data) {
	    var len = data.length;
	
	    if (!(this.data && this.data.length == len) && hasTypedArray) {
	      this.data = new Float32Array(len);
	    }
	
	    for (var i = 0; i < len; i++) {
	      this.data[i] = data[i];
	    }
	
	    this._len = len;
	  },
	
	  /**
	   * 添加子路径
	   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
	   */
	  appendPath: function (path) {
	    if (!(path instanceof Array)) {
	      path = [path];
	    }
	
	    var len = path.length;
	    var appendSize = 0;
	    var offset = this._len;
	
	    for (var i = 0; i < len; i++) {
	      appendSize += path[i].len();
	    }
	
	    if (hasTypedArray && this.data instanceof Float32Array) {
	      this.data = new Float32Array(offset + appendSize);
	    }
	
	    for (var i = 0; i < len; i++) {
	      var appendPathData = path[i].data;
	
	      for (var k = 0; k < appendPathData.length; k++) {
	        this.data[offset++] = appendPathData[k];
	      }
	    }
	
	    this._len = offset;
	  },
	
	  /**
	   * 填充 Path 数据。
	   * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
	   */
	  addData: function (cmd) {
	    if (!this._saveData) {
	      return;
	    }
	
	    var data = this.data;
	
	    if (this._len + arguments.length > data.length) {
	      // 因为之前的数组已经转换成静态的 Float32Array
	      // 所以不够用时需要扩展一个新的动态数组
	      this._expandData();
	
	      data = this.data;
	    }
	
	    for (var i = 0; i < arguments.length; i++) {
	      data[this._len++] = arguments[i];
	    }
	
	    this._prevCmd = cmd;
	  },
	  _expandData: function () {
	    // Only if data is Float32Array
	    if (!(this.data instanceof Array)) {
	      var newData = [];
	
	      for (var i = 0; i < this._len; i++) {
	        newData[i] = this.data[i];
	      }
	
	      this.data = newData;
	    }
	  },
	
	  /**
	   * If needs js implemented dashed line
	   * @return {boolean}
	   * @private
	   */
	  _needsDash: function () {
	    return this._lineDash;
	  },
	  _dashedLineTo: function (x1, y1) {
	    var dashSum = this._dashSum;
	    var offset = this._dashOffset;
	    var lineDash = this._lineDash;
	    var ctx = this._ctx;
	    var x0 = this._xi;
	    var y0 = this._yi;
	    var dx = x1 - x0;
	    var dy = y1 - y0;
	    var dist = mathSqrt(dx * dx + dy * dy);
	    var x = x0;
	    var y = y0;
	    var dash;
	    var nDash = lineDash.length;
	    var idx;
	    dx /= dist;
	    dy /= dist;
	
	    if (offset < 0) {
	      // Convert to positive offset
	      offset = dashSum + offset;
	    }
	
	    offset %= dashSum;
	    x -= offset * dx;
	    y -= offset * dy;
	
	    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {
	      idx = this._dashIdx;
	      dash = lineDash[idx];
	      x += dx * dash;
	      y += dy * dash;
	      this._dashIdx = (idx + 1) % nDash; // Skip positive offset
	
	      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {
	        continue;
	      }
	
	      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));
	    } // Offset for next lineTo
	
	
	    dx = x - x1;
	    dy = y - y1;
	    this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	  },
	  // Not accurate dashed line to
	  _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {
	    var dashSum = this._dashSum;
	    var offset = this._dashOffset;
	    var lineDash = this._lineDash;
	    var ctx = this._ctx;
	    var x0 = this._xi;
	    var y0 = this._yi;
	    var t;
	    var dx;
	    var dy;
	    var cubicAt = curve.cubicAt;
	    var bezierLen = 0;
	    var idx = this._dashIdx;
	    var nDash = lineDash.length;
	    var x;
	    var y;
	    var tmpLen = 0;
	
	    if (offset < 0) {
	      // Convert to positive offset
	      offset = dashSum + offset;
	    }
	
	    offset %= dashSum; // Bezier approx length
	
	    for (t = 0; t < 1; t += 0.1) {
	      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);
	      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);
	      bezierLen += mathSqrt(dx * dx + dy * dy);
	    } // Find idx after add offset
	
	
	    for (; idx < nDash; idx++) {
	      tmpLen += lineDash[idx];
	
	      if (tmpLen > offset) {
	        break;
	      }
	    }
	
	    t = (tmpLen - offset) / bezierLen;
	
	    while (t <= 1) {
	      x = cubicAt(x0, x1, x2, x3, t);
	      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier
	      // Bad result if dash is long
	
	      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
	      t += lineDash[idx] / bezierLen;
	      idx = (idx + 1) % nDash;
	    } // Finish the last segment and calculate the new offset
	
	
	    idx % 2 !== 0 && ctx.lineTo(x3, y3);
	    dx = x3 - x;
	    dy = y3 - y;
	    this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	  },
	  _dashedQuadraticTo: function (x1, y1, x2, y2) {
	    // Convert quadratic to cubic using degree elevation
	    var x3 = x2;
	    var y3 = y2;
	    x2 = (x2 + 2 * x1) / 3;
	    y2 = (y2 + 2 * y1) / 3;
	    x1 = (this._xi + 2 * x1) / 3;
	    y1 = (this._yi + 2 * y1) / 3;
	
	    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
	  },
	
	  /**
	   * 转成静态的 Float32Array 减少堆内存占用
	   * Convert dynamic array to static Float32Array
	   */
	  toStatic: function () {
	    var data = this.data;
	
	    if (data instanceof Array) {
	      data.length = this._len;
	
	      if (hasTypedArray) {
	        this.data = new Float32Array(data);
	      }
	    }
	  },
	
	  /**
	   * @return {module:zrender/core/BoundingRect}
	   */
	  getBoundingRect: function () {
	    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
	    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
	    var data = this.data;
	    var xi = 0;
	    var yi = 0;
	    var x0 = 0;
	    var y0 = 0;
	
	    for (var i = 0; i < data.length;) {
	      var cmd = data[i++];
	
	      if (i == 1) {
	        // 如果第一个命令是 L, C, Q
	        // 则 previous point 同绘制命令的第一个 point
	        //
	        // 第一个命令为 Arc 的情况下会在后面特殊处理
	        xi = data[i];
	        yi = data[i + 1];
	        x0 = xi;
	        y0 = yi;
	      }
	
	      switch (cmd) {
	        case CMD.M:
	          // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	          // 在 closePath 的时候使用
	          x0 = data[i++];
	          y0 = data[i++];
	          xi = x0;
	          yi = y0;
	          min2[0] = x0;
	          min2[1] = y0;
	          max2[0] = x0;
	          max2[1] = y0;
	          break;
	
	        case CMD.L:
	          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
	          xi = data[i++];
	          yi = data[i++];
	          break;
	
	        case CMD.C:
	          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);
	          xi = data[i++];
	          yi = data[i++];
	          break;
	
	        case CMD.Q:
	          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);
	          xi = data[i++];
	          yi = data[i++];
	          break;
	
	        case CMD.A:
	          // TODO Arc 判断的开销比较大
	          var cx = data[i++];
	          var cy = data[i++];
	          var rx = data[i++];
	          var ry = data[i++];
	          var startAngle = data[i++];
	          var endAngle = data[i++] + startAngle; // TODO Arc 旋转
	
	          var psi = data[i++];
	          var anticlockwise = 1 - data[i++];
	
	          if (i == 1) {
	            // 直接使用 arc 命令
	            // 第一个命令起点还未定义
	            x0 = mathCos(startAngle) * rx + cx;
	            y0 = mathSin(startAngle) * ry + cy;
	          }
	
	          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
	          xi = mathCos(endAngle) * rx + cx;
	          yi = mathSin(endAngle) * ry + cy;
	          break;
	
	        case CMD.R:
	          x0 = xi = data[i++];
	          y0 = yi = data[i++];
	          var width = data[i++];
	          var height = data[i++]; // Use fromLine
	
	          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
	          break;
	
	        case CMD.Z:
	          xi = x0;
	          yi = y0;
	          break;
	      } // Union
	
	
	      vec2.min(min, min, min2);
	      vec2.max(max, max, max2);
	    } // No data
	
	
	    if (i === 0) {
	      min[0] = min[1] = max[0] = max[1] = 0;
	    }
	
	    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	  },
	
	  /**
	   * Rebuild path from current data
	   * Rebuild path will not consider javascript implemented line dash.
	   * @param {CanvasRenderingContext2D} ctx
	   */
	  rebuildPath: function (ctx) {
	    var d = this.data;
	    var x0, y0;
	    var xi, yi;
	    var x, y;
	    var ux = this._ux;
	    var uy = this._uy;
	    var len = this._len;
	
	    for (var i = 0; i < len;) {
	      var cmd = d[i++];
	
	      if (i == 1) {
	        // 如果第一个命令是 L, C, Q
	        // 则 previous point 同绘制命令的第一个 point
	        //
	        // 第一个命令为 Arc 的情况下会在后面特殊处理
	        xi = d[i];
	        yi = d[i + 1];
	        x0 = xi;
	        y0 = yi;
	      }
	
	      switch (cmd) {
	        case CMD.M:
	          x0 = xi = d[i++];
	          y0 = yi = d[i++];
	          ctx.moveTo(xi, yi);
	          break;
	
	        case CMD.L:
	          x = d[i++];
	          y = d[i++]; // Not draw too small seg between
	
	          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
	            ctx.lineTo(x, y);
	            xi = x;
	            yi = y;
	          }
	
	          break;
	
	        case CMD.C:
	          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);
	          xi = d[i - 2];
	          yi = d[i - 1];
	          break;
	
	        case CMD.Q:
	          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
	          xi = d[i - 2];
	          yi = d[i - 1];
	          break;
	
	        case CMD.A:
	          var cx = d[i++];
	          var cy = d[i++];
	          var rx = d[i++];
	          var ry = d[i++];
	          var theta = d[i++];
	          var dTheta = d[i++];
	          var psi = d[i++];
	          var fs = d[i++];
	          var r = rx > ry ? rx : ry;
	          var scaleX = rx > ry ? 1 : rx / ry;
	          var scaleY = rx > ry ? ry / rx : 1;
	          var isEllipse = Math.abs(rx - ry) > 1e-3;
	          var endAngle = theta + dTheta;
	
	          if (isEllipse) {
	            ctx.translate(cx, cy);
	            ctx.rotate(psi);
	            ctx.scale(scaleX, scaleY);
	            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
	            ctx.scale(1 / scaleX, 1 / scaleY);
	            ctx.rotate(-psi);
	            ctx.translate(-cx, -cy);
	          } else {
	            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
	          }
	
	          if (i == 1) {
	            // 直接使用 arc 命令
	            // 第一个命令起点还未定义
	            x0 = mathCos(theta) * rx + cx;
	            y0 = mathSin(theta) * ry + cy;
	          }
	
	          xi = mathCos(endAngle) * rx + cx;
	          yi = mathSin(endAngle) * ry + cy;
	          break;
	
	        case CMD.R:
	          x0 = xi = d[i];
	          y0 = yi = d[i + 1];
	          ctx.rect(d[i++], d[i++], d[i++], d[i++]);
	          break;
	
	        case CMD.Z:
	          ctx.closePath();
	          xi = x0;
	          yi = y0;
	      }
	    }
	  }
	};
	PathProxy.CMD = CMD;
	var _default = PathProxy;
	module.exports = _default;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	var _vector = __webpack_require__(8);
	
	var v2Create = _vector.create;
	var v2DistSquare = _vector.distSquare;
	
	/**
	 * 曲线辅助模块
	 * @module zrender/core/curve
	 * @author pissang(https://www.github.com/pissang)
	 */
	var mathPow = Math.pow;
	var mathSqrt = Math.sqrt;
	var EPSILON = 1e-8;
	var EPSILON_NUMERIC = 1e-4;
	var THREE_SQRT = mathSqrt(3);
	var ONE_THIRD = 1 / 3; // 临时变量
	
	var _v0 = v2Create();
	
	var _v1 = v2Create();
	
	var _v2 = v2Create();
	
	function isAroundZero(val) {
	  return val > -EPSILON && val < EPSILON;
	}
	
	function isNotAroundZero(val) {
	  return val > EPSILON || val < -EPSILON;
	}
	/**
	 * 计算三次贝塞尔值
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} t
	 * @return {number}
	 */
	
	
	function cubicAt(p0, p1, p2, p3, t) {
	  var onet = 1 - t;
	  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
	}
	/**
	 * 计算三次贝塞尔导数值
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} t
	 * @return {number}
	 */
	
	
	function cubicDerivativeAt(p0, p1, p2, p3, t) {
	  var onet = 1 - t;
	  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
	}
	/**
	 * 计算三次贝塞尔方程根，使用盛金公式
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} val
	 * @param  {Array.<number>} roots
	 * @return {number} 有效根数目
	 */
	
	
	function cubicRootAt(p0, p1, p2, p3, val, roots) {
	  // Evaluate roots of cubic functions
	  var a = p3 + 3 * (p1 - p2) - p0;
	  var b = 3 * (p2 - p1 * 2 + p0);
	  var c = 3 * (p1 - p0);
	  var d = p0 - val;
	  var A = b * b - 3 * a * c;
	  var B = b * c - 9 * a * d;
	  var C = c * c - 3 * b * d;
	  var n = 0;
	
	  if (isAroundZero(A) && isAroundZero(B)) {
	    if (isAroundZero(b)) {
	      roots[0] = 0;
	    } else {
	      var t1 = -c / b; //t1, t2, t3, b is not zero
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	    }
	  } else {
	    var disc = B * B - 4 * A * C;
	
	    if (isAroundZero(disc)) {
	      var K = B / A;
	      var t1 = -b / a + K; // t1, a is not zero
	
	      var t2 = -K / 2; // t2, t3
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	
	      if (t2 >= 0 && t2 <= 1) {
	        roots[n++] = t2;
	      }
	    } else if (disc > 0) {
	      var discSqrt = mathSqrt(disc);
	      var Y1 = A * b + 1.5 * a * (-B + discSqrt);
	      var Y2 = A * b + 1.5 * a * (-B - discSqrt);
	
	      if (Y1 < 0) {
	        Y1 = -mathPow(-Y1, ONE_THIRD);
	      } else {
	        Y1 = mathPow(Y1, ONE_THIRD);
	      }
	
	      if (Y2 < 0) {
	        Y2 = -mathPow(-Y2, ONE_THIRD);
	      } else {
	        Y2 = mathPow(Y2, ONE_THIRD);
	      }
	
	      var t1 = (-b - (Y1 + Y2)) / (3 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	    } else {
	      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
	      var theta = Math.acos(T) / 3;
	      var ASqrt = mathSqrt(A);
	      var tmp = Math.cos(theta);
	      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
	      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
	      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	
	      if (t2 >= 0 && t2 <= 1) {
	        roots[n++] = t2;
	      }
	
	      if (t3 >= 0 && t3 <= 1) {
	        roots[n++] = t3;
	      }
	    }
	  }
	
	  return n;
	}
	/**
	 * 计算三次贝塞尔方程极限值的位置
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {Array.<number>} extrema
	 * @return {number} 有效数目
	 */
	
	
	function cubicExtrema(p0, p1, p2, p3, extrema) {
	  var b = 6 * p2 - 12 * p1 + 6 * p0;
	  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
	  var c = 3 * p1 - 3 * p0;
	  var n = 0;
	
	  if (isAroundZero(a)) {
	    if (isNotAroundZero(b)) {
	      var t1 = -c / b;
	
	      if (t1 >= 0 && t1 <= 1) {
	        extrema[n++] = t1;
	      }
	    }
	  } else {
	    var disc = b * b - 4 * a * c;
	
	    if (isAroundZero(disc)) {
	      extrema[0] = -b / (2 * a);
	    } else if (disc > 0) {
	      var discSqrt = mathSqrt(disc);
	      var t1 = (-b + discSqrt) / (2 * a);
	      var t2 = (-b - discSqrt) / (2 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        extrema[n++] = t1;
	      }
	
	      if (t2 >= 0 && t2 <= 1) {
	        extrema[n++] = t2;
	      }
	    }
	  }
	
	  return n;
	}
	/**
	 * 细分三次贝塞尔曲线
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} t
	 * @param  {Array.<number>} out
	 */
	
	
	function cubicSubdivide(p0, p1, p2, p3, t, out) {
	  var p01 = (p1 - p0) * t + p0;
	  var p12 = (p2 - p1) * t + p1;
	  var p23 = (p3 - p2) * t + p2;
	  var p012 = (p12 - p01) * t + p01;
	  var p123 = (p23 - p12) * t + p12;
	  var p0123 = (p123 - p012) * t + p012; // Seg0
	
	  out[0] = p0;
	  out[1] = p01;
	  out[2] = p012;
	  out[3] = p0123; // Seg1
	
	  out[4] = p0123;
	  out[5] = p123;
	  out[6] = p23;
	  out[7] = p3;
	}
	/**
	 * 投射点到三次贝塞尔曲线上，返回投射距离。
	 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {number} x2
	 * @param {number} y2
	 * @param {number} x3
	 * @param {number} y3
	 * @param {number} x
	 * @param {number} y
	 * @param {Array.<number>} [out] 投射点
	 * @return {number}
	 */
	
	
	function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
	  // http://pomax.github.io/bezierinfo/#projections
	  var t;
	  var interval = 0.005;
	  var d = Infinity;
	  var prev;
	  var next;
	  var d1;
	  var d2;
	  _v0[0] = x;
	  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值
	  // PENDING
	
	  for (var _t = 0; _t < 1; _t += 0.05) {
	    _v1[0] = cubicAt(x0, x1, x2, x3, _t);
	    _v1[1] = cubicAt(y0, y1, y2, y3, _t);
	    d1 = v2DistSquare(_v0, _v1);
	
	    if (d1 < d) {
	      t = _t;
	      d = d1;
	    }
	  }
	
	  d = Infinity; // At most 32 iteration
	
	  for (var i = 0; i < 32; i++) {
	    if (interval < EPSILON_NUMERIC) {
	      break;
	    }
	
	    prev = t - interval;
	    next = t + interval; // t - interval
	
	    _v1[0] = cubicAt(x0, x1, x2, x3, prev);
	    _v1[1] = cubicAt(y0, y1, y2, y3, prev);
	    d1 = v2DistSquare(_v1, _v0);
	
	    if (prev >= 0 && d1 < d) {
	      t = prev;
	      d = d1;
	    } else {
	      // t + interval
	      _v2[0] = cubicAt(x0, x1, x2, x3, next);
	      _v2[1] = cubicAt(y0, y1, y2, y3, next);
	      d2 = v2DistSquare(_v2, _v0);
	
	      if (next <= 1 && d2 < d) {
	        t = next;
	        d = d2;
	      } else {
	        interval *= 0.5;
	      }
	    }
	  } // t
	
	
	  if (out) {
	    out[0] = cubicAt(x0, x1, x2, x3, t);
	    out[1] = cubicAt(y0, y1, y2, y3, t);
	  } // console.log(interval, i);
	
	
	  return mathSqrt(d);
	}
	/**
	 * 计算二次方贝塞尔值
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} t
	 * @return {number}
	 */
	
	
	function quadraticAt(p0, p1, p2, t) {
	  var onet = 1 - t;
	  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
	}
	/**
	 * 计算二次方贝塞尔导数值
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} t
	 * @return {number}
	 */
	
	
	function quadraticDerivativeAt(p0, p1, p2, t) {
	  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
	}
	/**
	 * 计算二次方贝塞尔方程根
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} t
	 * @param  {Array.<number>} roots
	 * @return {number} 有效根数目
	 */
	
	
	function quadraticRootAt(p0, p1, p2, val, roots) {
	  var a = p0 - 2 * p1 + p2;
	  var b = 2 * (p1 - p0);
	  var c = p0 - val;
	  var n = 0;
	
	  if (isAroundZero(a)) {
	    if (isNotAroundZero(b)) {
	      var t1 = -c / b;
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	    }
	  } else {
	    var disc = b * b - 4 * a * c;
	
	    if (isAroundZero(disc)) {
	      var t1 = -b / (2 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	    } else if (disc > 0) {
	      var discSqrt = mathSqrt(disc);
	      var t1 = (-b + discSqrt) / (2 * a);
	      var t2 = (-b - discSqrt) / (2 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	
	      if (t2 >= 0 && t2 <= 1) {
	        roots[n++] = t2;
	      }
	    }
	  }
	
	  return n;
	}
	/**
	 * 计算二次贝塞尔方程极限值
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @return {number}
	 */
	
	
	function quadraticExtremum(p0, p1, p2) {
	  var divider = p0 + p2 - 2 * p1;
	
	  if (divider === 0) {
	    // p1 is center of p0 and p2
	    return 0.5;
	  } else {
	    return (p0 - p1) / divider;
	  }
	}
	/**
	 * 细分二次贝塞尔曲线
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} t
	 * @param  {Array.<number>} out
	 */
	
	
	function quadraticSubdivide(p0, p1, p2, t, out) {
	  var p01 = (p1 - p0) * t + p0;
	  var p12 = (p2 - p1) * t + p1;
	  var p012 = (p12 - p01) * t + p01; // Seg0
	
	  out[0] = p0;
	  out[1] = p01;
	  out[2] = p012; // Seg1
	
	  out[3] = p012;
	  out[4] = p12;
	  out[5] = p2;
	}
	/**
	 * 投射点到二次贝塞尔曲线上，返回投射距离。
	 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {number} x2
	 * @param {number} y2
	 * @param {number} x
	 * @param {number} y
	 * @param {Array.<number>} out 投射点
	 * @return {number}
	 */
	
	
	function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
	  // http://pomax.github.io/bezierinfo/#projections
	  var t;
	  var interval = 0.005;
	  var d = Infinity;
	  _v0[0] = x;
	  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值
	  // PENDING
	
	  for (var _t = 0; _t < 1; _t += 0.05) {
	    _v1[0] = quadraticAt(x0, x1, x2, _t);
	    _v1[1] = quadraticAt(y0, y1, y2, _t);
	    var d1 = v2DistSquare(_v0, _v1);
	
	    if (d1 < d) {
	      t = _t;
	      d = d1;
	    }
	  }
	
	  d = Infinity; // At most 32 iteration
	
	  for (var i = 0; i < 32; i++) {
	    if (interval < EPSILON_NUMERIC) {
	      break;
	    }
	
	    var prev = t - interval;
	    var next = t + interval; // t - interval
	
	    _v1[0] = quadraticAt(x0, x1, x2, prev);
	    _v1[1] = quadraticAt(y0, y1, y2, prev);
	    var d1 = v2DistSquare(_v1, _v0);
	
	    if (prev >= 0 && d1 < d) {
	      t = prev;
	      d = d1;
	    } else {
	      // t + interval
	      _v2[0] = quadraticAt(x0, x1, x2, next);
	      _v2[1] = quadraticAt(y0, y1, y2, next);
	      var d2 = v2DistSquare(_v2, _v0);
	
	      if (next <= 1 && d2 < d) {
	        t = next;
	        d = d2;
	      } else {
	        interval *= 0.5;
	      }
	    }
	  } // t
	
	
	  if (out) {
	    out[0] = quadraticAt(x0, x1, x2, t);
	    out[1] = quadraticAt(y0, y1, y2, t);
	  } // console.log(interval, i);
	
	
	  return mathSqrt(d);
	}
	
	exports.cubicAt = cubicAt;
	exports.cubicDerivativeAt = cubicDerivativeAt;
	exports.cubicRootAt = cubicRootAt;
	exports.cubicExtrema = cubicExtrema;
	exports.cubicSubdivide = cubicSubdivide;
	exports.cubicProjectPoint = cubicProjectPoint;
	exports.quadraticAt = quadraticAt;
	exports.quadraticDerivativeAt = quadraticDerivativeAt;
	exports.quadraticRootAt = quadraticRootAt;
	exports.quadraticExtremum = quadraticExtremum;
	exports.quadraticSubdivide = quadraticSubdivide;
	exports.quadraticProjectPoint = quadraticProjectPoint;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	var vec2 = __webpack_require__(8);
	
	var curve = __webpack_require__(49);
	
	/**
	 * @author Yi Shen(https://github.com/pissang)
	 */
	var mathMin = Math.min;
	var mathMax = Math.max;
	var mathSin = Math.sin;
	var mathCos = Math.cos;
	var PI2 = Math.PI * 2;
	var start = vec2.create();
	var end = vec2.create();
	var extremity = vec2.create();
	/**
	 * 从顶点数组中计算出最小包围盒，写入`min`和`max`中
	 * @module zrender/core/bbox
	 * @param {Array<Object>} points 顶点数组
	 * @param {number} min
	 * @param {number} max
	 */
	
	function fromPoints(points, min, max) {
	  if (points.length === 0) {
	    return;
	  }
	
	  var p = points[0];
	  var left = p[0];
	  var right = p[0];
	  var top = p[1];
	  var bottom = p[1];
	  var i;
	
	  for (i = 1; i < points.length; i++) {
	    p = points[i];
	    left = mathMin(left, p[0]);
	    right = mathMax(right, p[0]);
	    top = mathMin(top, p[1]);
	    bottom = mathMax(bottom, p[1]);
	  }
	
	  min[0] = left;
	  min[1] = top;
	  max[0] = right;
	  max[1] = bottom;
	}
	/**
	 * @memberOf module:zrender/core/bbox
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {Array.<number>} min
	 * @param {Array.<number>} max
	 */
	
	
	function fromLine(x0, y0, x1, y1, min, max) {
	  min[0] = mathMin(x0, x1);
	  min[1] = mathMin(y0, y1);
	  max[0] = mathMax(x0, x1);
	  max[1] = mathMax(y0, y1);
	}
	
	var xDim = [];
	var yDim = [];
	/**
	 * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
	 * @memberOf module:zrender/core/bbox
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {number} x2
	 * @param {number} y2
	 * @param {number} x3
	 * @param {number} y3
	 * @param {Array.<number>} min
	 * @param {Array.<number>} max
	 */
	
	function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {
	  var cubicExtrema = curve.cubicExtrema;
	  var cubicAt = curve.cubicAt;
	  var i;
	  var n = cubicExtrema(x0, x1, x2, x3, xDim);
	  min[0] = Infinity;
	  min[1] = Infinity;
	  max[0] = -Infinity;
	  max[1] = -Infinity;
	
	  for (i = 0; i < n; i++) {
	    var x = cubicAt(x0, x1, x2, x3, xDim[i]);
	    min[0] = mathMin(x, min[0]);
	    max[0] = mathMax(x, max[0]);
	  }
	
	  n = cubicExtrema(y0, y1, y2, y3, yDim);
	
	  for (i = 0; i < n; i++) {
	    var y = cubicAt(y0, y1, y2, y3, yDim[i]);
	    min[1] = mathMin(y, min[1]);
	    max[1] = mathMax(y, max[1]);
	  }
	
	  min[0] = mathMin(x0, min[0]);
	  max[0] = mathMax(x0, max[0]);
	  min[0] = mathMin(x3, min[0]);
	  max[0] = mathMax(x3, max[0]);
	  min[1] = mathMin(y0, min[1]);
	  max[1] = mathMax(y0, max[1]);
	  min[1] = mathMin(y3, min[1]);
	  max[1] = mathMax(y3, max[1]);
	}
	/**
	 * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
	 * @memberOf module:zrender/core/bbox
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {number} x2
	 * @param {number} y2
	 * @param {Array.<number>} min
	 * @param {Array.<number>} max
	 */
	
	
	function fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {
	  var quadraticExtremum = curve.quadraticExtremum;
	  var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero
	
	  var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);
	  var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);
	  var x = quadraticAt(x0, x1, x2, tx);
	  var y = quadraticAt(y0, y1, y2, ty);
	  min[0] = mathMin(x0, x2, x);
	  min[1] = mathMin(y0, y2, y);
	  max[0] = mathMax(x0, x2, x);
	  max[1] = mathMax(y0, y2, y);
	}
	/**
	 * 从圆弧中计算出最小包围盒，写入`min`和`max`中
	 * @method
	 * @memberOf module:zrender/core/bbox
	 * @param {number} x
	 * @param {number} y
	 * @param {number} rx
	 * @param {number} ry
	 * @param {number} startAngle
	 * @param {number} endAngle
	 * @param {number} anticlockwise
	 * @param {Array.<number>} min
	 * @param {Array.<number>} max
	 */
	
	
	function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {
	  var vec2Min = vec2.min;
	  var vec2Max = vec2.max;
	  var diff = Math.abs(startAngle - endAngle);
	
	  if (diff % PI2 < 1e-4 && diff > 1e-4) {
	    // Is a circle
	    min[0] = x - rx;
	    min[1] = y - ry;
	    max[0] = x + rx;
	    max[1] = y + ry;
	    return;
	  }
	
	  start[0] = mathCos(startAngle) * rx + x;
	  start[1] = mathSin(startAngle) * ry + y;
	  end[0] = mathCos(endAngle) * rx + x;
	  end[1] = mathSin(endAngle) * ry + y;
	  vec2Min(min, start, end);
	  vec2Max(max, start, end); // Thresh to [0, Math.PI * 2]
	
	  startAngle = startAngle % PI2;
	
	  if (startAngle < 0) {
	    startAngle = startAngle + PI2;
	  }
	
	  endAngle = endAngle % PI2;
	
	  if (endAngle < 0) {
	    endAngle = endAngle + PI2;
	  }
	
	  if (startAngle > endAngle && !anticlockwise) {
	    endAngle += PI2;
	  } else if (startAngle < endAngle && anticlockwise) {
	    startAngle += PI2;
	  }
	
	  if (anticlockwise) {
	    var tmp = endAngle;
	    endAngle = startAngle;
	    startAngle = tmp;
	  } // var number = 0;
	  // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;
	
	
	  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
	    if (angle > startAngle) {
	      extremity[0] = mathCos(angle) * rx + x;
	      extremity[1] = mathSin(angle) * ry + y;
	      vec2Min(min, extremity, min);
	      vec2Max(max, extremity, max);
	    }
	  }
	}
	
	exports.fromPoints = fromPoints;
	exports.fromLine = fromLine;
	exports.fromCubic = fromCubic;
	exports.fromQuadratic = fromQuadratic;
	exports.fromArc = fromArc;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	var PathProxy = __webpack_require__(48);
	
	var line = __webpack_require__(52);
	
	var cubic = __webpack_require__(53);
	
	var quadratic = __webpack_require__(54);
	
	var arc = __webpack_require__(55);
	
	var _util = __webpack_require__(56);
	
	var normalizeRadian = _util.normalizeRadian;
	
	var curve = __webpack_require__(49);
	
	var windingLine = __webpack_require__(57);
	
	var CMD = PathProxy.CMD;
	var PI2 = Math.PI * 2;
	var EPSILON = 1e-4;
	
	function isAroundEqual(a, b) {
	  return Math.abs(a - b) < EPSILON;
	} // 临时数组
	
	
	var roots = [-1, -1, -1];
	var extrema = [-1, -1];
	
	function swapExtrema() {
	  var tmp = extrema[0];
	  extrema[0] = extrema[1];
	  extrema[1] = tmp;
	}
	
	function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
	  // Quick reject
	  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
	    return 0;
	  }
	
	  var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
	
	  if (nRoots === 0) {
	    return 0;
	  } else {
	    var w = 0;
	    var nExtrema = -1;
	    var y0_, y1_;
	
	    for (var i = 0; i < nRoots; i++) {
	      var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon
	
	      var unit = t === 0 || t === 1 ? 0.5 : 1;
	      var x_ = curve.cubicAt(x0, x1, x2, x3, t);
	
	      if (x_ < x) {
	        // Quick reject
	        continue;
	      }
	
	      if (nExtrema < 0) {
	        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
	
	        if (extrema[1] < extrema[0] && nExtrema > 1) {
	          swapExtrema();
	        }
	
	        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
	
	        if (nExtrema > 1) {
	          y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
	        }
	      }
	
	      if (nExtrema == 2) {
	        // 分成三段单调函数
	        if (t < extrema[0]) {
	          w += y0_ < y0 ? unit : -unit;
	        } else if (t < extrema[1]) {
	          w += y1_ < y0_ ? unit : -unit;
	        } else {
	          w += y3 < y1_ ? unit : -unit;
	        }
	      } else {
	        // 分成两段单调函数
	        if (t < extrema[0]) {
	          w += y0_ < y0 ? unit : -unit;
	        } else {
	          w += y3 < y0_ ? unit : -unit;
	        }
	      }
	    }
	
	    return w;
	  }
	}
	
	function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
	  // Quick reject
	  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
	    return 0;
	  }
	
	  var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
	
	  if (nRoots === 0) {
	    return 0;
	  } else {
	    var t = curve.quadraticExtremum(y0, y1, y2);
	
	    if (t >= 0 && t <= 1) {
	      var w = 0;
	      var y_ = curve.quadraticAt(y0, y1, y2, t);
	
	      for (var i = 0; i < nRoots; i++) {
	        // Remove one endpoint.
	        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
	        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
	
	        if (x_ < x) {
	          // Quick reject
	          continue;
	        }
	
	        if (roots[i] < t) {
	          w += y_ < y0 ? unit : -unit;
	        } else {
	          w += y2 < y_ ? unit : -unit;
	        }
	      }
	
	      return w;
	    } else {
	      // Remove one endpoint.
	      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
	      var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
	
	      if (x_ < x) {
	        // Quick reject
	        return 0;
	      }
	
	      return y2 < y0 ? unit : -unit;
	    }
	  }
	} // TODO
	// Arc 旋转
	
	
	function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
	  y -= cy;
	
	  if (y > r || y < -r) {
	    return 0;
	  }
	
	  var tmp = Math.sqrt(r * r - y * y);
	  roots[0] = -tmp;
	  roots[1] = tmp;
	  var diff = Math.abs(startAngle - endAngle);
	
	  if (diff < 1e-4) {
	    return 0;
	  }
	
	  if (diff % PI2 < 1e-4) {
	    // Is a circle
	    startAngle = 0;
	    endAngle = PI2;
	    var dir = anticlockwise ? 1 : -1;
	
	    if (x >= roots[0] + cx && x <= roots[1] + cx) {
	      return dir;
	    } else {
	      return 0;
	    }
	  }
	
	  if (anticlockwise) {
	    var tmp = startAngle;
	    startAngle = normalizeRadian(endAngle);
	    endAngle = normalizeRadian(tmp);
	  } else {
	    startAngle = normalizeRadian(startAngle);
	    endAngle = normalizeRadian(endAngle);
	  }
	
	  if (startAngle > endAngle) {
	    endAngle += PI2;
	  }
	
	  var w = 0;
	
	  for (var i = 0; i < 2; i++) {
	    var x_ = roots[i];
	
	    if (x_ + cx > x) {
	      var angle = Math.atan2(y, x_);
	      var dir = anticlockwise ? 1 : -1;
	
	      if (angle < 0) {
	        angle = PI2 + angle;
	      }
	
	      if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {
	        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
	          dir = -dir;
	        }
	
	        w += dir;
	      }
	    }
	  }
	
	  return w;
	}
	
	function containPath(data, lineWidth, isStroke, x, y) {
	  var w = 0;
	  var xi = 0;
	  var yi = 0;
	  var x0 = 0;
	  var y0 = 0;
	
	  for (var i = 0; i < data.length;) {
	    var cmd = data[i++]; // Begin a new subpath
	
	    if (cmd === CMD.M && i > 1) {
	      // Close previous subpath
	      if (!isStroke) {
	        w += windingLine(xi, yi, x0, y0, x, y);
	      } // 如果被任何一个 subpath 包含
	      // if (w !== 0) {
	      //     return true;
	      // }
	
	    }
	
	    if (i == 1) {
	      // 如果第一个命令是 L, C, Q
	      // 则 previous point 同绘制命令的第一个 point
	      //
	      // 第一个命令为 Arc 的情况下会在后面特殊处理
	      xi = data[i];
	      yi = data[i + 1];
	      x0 = xi;
	      y0 = yi;
	    }
	
	    switch (cmd) {
	      case CMD.M:
	        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	        // 在 closePath 的时候使用
	        x0 = data[i++];
	        y0 = data[i++];
	        xi = x0;
	        yi = y0;
	        break;
	
	      case CMD.L:
	        if (isStroke) {
	          if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN
	          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
	        }
	
	        xi = data[i++];
	        yi = data[i++];
	        break;
	
	      case CMD.C:
	        if (isStroke) {
	          if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
	        }
	
	        xi = data[i++];
	        yi = data[i++];
	        break;
	
	      case CMD.Q:
	        if (isStroke) {
	          if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
	        }
	
	        xi = data[i++];
	        yi = data[i++];
	        break;
	
	      case CMD.A:
	        // TODO Arc 判断的开销比较大
	        var cx = data[i++];
	        var cy = data[i++];
	        var rx = data[i++];
	        var ry = data[i++];
	        var theta = data[i++];
	        var dTheta = data[i++]; // TODO Arc 旋转
	
	        var psi = data[i++];
	        var anticlockwise = 1 - data[i++];
	        var x1 = Math.cos(theta) * rx + cx;
	        var y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令
	
	        if (i > 1) {
	          w += windingLine(xi, yi, x1, y1, x, y);
	        } else {
	          // 第一个命令起点还未定义
	          x0 = x1;
	          y0 = y1;
	        } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放
	
	
	        var _x = (x - cx) * ry / rx + cx;
	
	        if (isStroke) {
	          if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
	            return true;
	          }
	        } else {
	          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
	        }
	
	        xi = Math.cos(theta + dTheta) * rx + cx;
	        yi = Math.sin(theta + dTheta) * ry + cy;
	        break;
	
	      case CMD.R:
	        x0 = xi = data[i++];
	        y0 = yi = data[i++];
	        var width = data[i++];
	        var height = data[i++];
	        var x1 = x0 + width;
	        var y1 = y0 + height;
	
	        if (isStroke) {
	          if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          // FIXME Clockwise ?
	          w += windingLine(x1, y0, x1, y1, x, y);
	          w += windingLine(x0, y1, x0, y0, x, y);
	        }
	
	        break;
	
	      case CMD.Z:
	        if (isStroke) {
	          if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          // Close a subpath
	          w += windingLine(xi, yi, x0, y0, x, y); // 如果被任何一个 subpath 包含
	          // FIXME subpaths may overlap
	          // if (w !== 0) {
	          //     return true;
	          // }
	        }
	
	        xi = x0;
	        yi = y0;
	        break;
	    }
	  }
	
	  if (!isStroke && !isAroundEqual(yi, y0)) {
	    w += windingLine(xi, yi, x0, y0, x, y) || 0;
	  }
	
	  return w !== 0;
	}
	
	function contain(pathData, x, y) {
	  return containPath(pathData, 0, false, x, y);
	}
	
	function containStroke(pathData, lineWidth, x, y) {
	  return containPath(pathData, lineWidth, true, x, y);
	}
	
	exports.contain = contain;
	exports.containStroke = containStroke;

/***/ }),
/* 52 */
/***/ (function(module, exports) {

	/**
	 * 线段包含判断
	 * @param  {number}  x0
	 * @param  {number}  y0
	 * @param  {number}  x1
	 * @param  {number}  y1
	 * @param  {number}  lineWidth
	 * @param  {number}  x
	 * @param  {number}  y
	 * @return {boolean}
	 */
	function containStroke(x0, y0, x1, y1, lineWidth, x, y) {
	  if (lineWidth === 0) {
	    return false;
	  }
	
	  var _l = lineWidth;
	  var _a = 0;
	  var _b = x0; // Quick reject
	
	  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
	    return false;
	  }
	
	  if (x0 !== x1) {
	    _a = (y0 - y1) / (x0 - x1);
	    _b = (x0 * y1 - x1 * y0) / (x0 - x1);
	  } else {
	    return Math.abs(x - x0) <= _l / 2;
	  }
	
	  var tmp = _a * x - y + _b;
	
	  var _s = tmp * tmp / (_a * _a + 1);
	
	  return _s <= _l / 2 * _l / 2;
	}
	
	exports.containStroke = containStroke;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	var curve = __webpack_require__(49);
	
	/**
	 * 三次贝塞尔曲线描边包含判断
	 * @param  {number}  x0
	 * @param  {number}  y0
	 * @param  {number}  x1
	 * @param  {number}  y1
	 * @param  {number}  x2
	 * @param  {number}  y2
	 * @param  {number}  x3
	 * @param  {number}  y3
	 * @param  {number}  lineWidth
	 * @param  {number}  x
	 * @param  {number}  y
	 * @return {boolean}
	 */
	function containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
	  if (lineWidth === 0) {
	    return false;
	  }
	
	  var _l = lineWidth; // Quick reject
	
	  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
	    return false;
	  }
	
	  var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
	  return d <= _l / 2;
	}
	
	exports.containStroke = containStroke;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	var _curve = __webpack_require__(49);
	
	var quadraticProjectPoint = _curve.quadraticProjectPoint;
	
	/**
	 * 二次贝塞尔曲线描边包含判断
	 * @param  {number}  x0
	 * @param  {number}  y0
	 * @param  {number}  x1
	 * @param  {number}  y1
	 * @param  {number}  x2
	 * @param  {number}  y2
	 * @param  {number}  lineWidth
	 * @param  {number}  x
	 * @param  {number}  y
	 * @return {boolean}
	 */
	function containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
	  if (lineWidth === 0) {
	    return false;
	  }
	
	  var _l = lineWidth; // Quick reject
	
	  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
	    return false;
	  }
	
	  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
	  return d <= _l / 2;
	}
	
	exports.containStroke = containStroke;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	var _util = __webpack_require__(56);
	
	var normalizeRadian = _util.normalizeRadian;
	var PI2 = Math.PI * 2;
	/**
	 * 圆弧描边包含判断
	 * @param  {number}  cx
	 * @param  {number}  cy
	 * @param  {number}  r
	 * @param  {number}  startAngle
	 * @param  {number}  endAngle
	 * @param  {boolean}  anticlockwise
	 * @param  {number} lineWidth
	 * @param  {number}  x
	 * @param  {number}  y
	 * @return {Boolean}
	 */
	
	function containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
	  if (lineWidth === 0) {
	    return false;
	  }
	
	  var _l = lineWidth;
	  x -= cx;
	  y -= cy;
	  var d = Math.sqrt(x * x + y * y);
	
	  if (d - _l > r || d + _l < r) {
	    return false;
	  }
	
	  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {
	    // Is a circle
	    return true;
	  }
	
	  if (anticlockwise) {
	    var tmp = startAngle;
	    startAngle = normalizeRadian(endAngle);
	    endAngle = normalizeRadian(tmp);
	  } else {
	    startAngle = normalizeRadian(startAngle);
	    endAngle = normalizeRadian(endAngle);
	  }
	
	  if (startAngle > endAngle) {
	    endAngle += PI2;
	  }
	
	  var angle = Math.atan2(y, x);
	
	  if (angle < 0) {
	    angle += PI2;
	  }
	
	  return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;
	}
	
	exports.containStroke = containStroke;

/***/ }),
/* 56 */
/***/ (function(module, exports) {

	var PI2 = Math.PI * 2;
	
	function normalizeRadian(angle) {
	  angle %= PI2;
	
	  if (angle < 0) {
	    angle += PI2;
	  }
	
	  return angle;
	}
	
	exports.normalizeRadian = normalizeRadian;

/***/ }),
/* 57 */
/***/ (function(module, exports) {

	function windingLine(x0, y0, x1, y1, x, y) {
	  if (y > y0 && y > y1 || y < y0 && y < y1) {
	    return 0;
	  } // Ignore horizontal line
	
	
	  if (y1 === y0) {
	    return 0;
	  }
	
	  var dir = y1 < y0 ? 1 : -1;
	  var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon
	
	  if (t === 1 || t === 0) {
	    dir = y1 < y0 ? 0.5 : -0.5;
	  }
	
	  var x_ = t * (x1 - x0) + x0;
	  return x_ > x ? dir : 0;
	}
	
	module.exports = windingLine;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	var PathProxy = __webpack_require__(48);
	
	var _vector = __webpack_require__(8);
	
	var v2ApplyTransform = _vector.applyTransform;
	var CMD = PathProxy.CMD;
	var points = [[], [], []];
	var mathSqrt = Math.sqrt;
	var mathAtan2 = Math.atan2;
	
	function _default(path, m) {
	  var data = path.data;
	  var cmd;
	  var nPoint;
	  var i;
	  var j;
	  var k;
	  var p;
	  var M = CMD.M;
	  var C = CMD.C;
	  var L = CMD.L;
	  var R = CMD.R;
	  var A = CMD.A;
	  var Q = CMD.Q;
	
	  for (i = 0, j = 0; i < data.length;) {
	    cmd = data[i++];
	    j = i;
	    nPoint = 0;
	
	    switch (cmd) {
	      case M:
	        nPoint = 1;
	        break;
	
	      case L:
	        nPoint = 1;
	        break;
	
	      case C:
	        nPoint = 3;
	        break;
	
	      case Q:
	        nPoint = 2;
	        break;
	
	      case A:
	        var x = m[4];
	        var y = m[5];
	        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);
	        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);
	        var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx
	
	        data[i] *= sx;
	        data[i++] += x; // cy
	
	        data[i] *= sy;
	        data[i++] += y; // Scale rx and ry
	        // FIXME Assume psi is 0 here
	
	        data[i++] *= sx;
	        data[i++] *= sy; // Start angle
	
	        data[i++] += angle; // end angle
	
	        data[i++] += angle; // FIXME psi
	
	        i += 2;
	        j = i;
	        break;
	
	      case R:
	        // x0, y0
	        p[0] = data[i++];
	        p[1] = data[i++];
	        v2ApplyTransform(p, p, m);
	        data[j++] = p[0];
	        data[j++] = p[1]; // x1, y1
	
	        p[0] += data[i++];
	        p[1] += data[i++];
	        v2ApplyTransform(p, p, m);
	        data[j++] = p[0];
	        data[j++] = p[1];
	    }
	
	    for (k = 0; k < nPoint; k++) {
	      var p = points[k];
	      p[0] = data[i++];
	      p[1] = data[i++];
	      v2ApplyTransform(p, p, m); // Write back
	
	      data[j++] = p[0];
	      data[j++] = p[1];
	    }
	  }
	}
	
	module.exports = _default;

/***/ }),
/* 59 */
/***/ (function(module, exports) {

	/**
	 * @param {Array.<Object>} colorStops
	 */
	var Gradient = function (colorStops) {
	  this.colorStops = colorStops || [];
	};
	
	Gradient.prototype = {
	  constructor: Gradient,
	  addColorStop: function (offset, color) {
	    this.colorStops.push({
	      offset: offset,
	      color: color
	    });
	  }
	};
	var _default = Gradient;
	module.exports = _default;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	var Displayable = __webpack_require__(32);
	
	var zrUtil = __webpack_require__(6);
	
	var textContain = __webpack_require__(35);
	
	var textHelper = __webpack_require__(34);
	
	/**
	 * @alias zrender/graphic/Text
	 * @extends module:zrender/graphic/Displayable
	 * @constructor
	 * @param {Object} opts
	 */
	var Text = function (opts) {
	  // jshint ignore:line
	  Displayable.call(this, opts);
	};
	
	Text.prototype = {
	  constructor: Text,
	  type: 'text',
	  brush: function (ctx, prevEl) {
	    var style = this.style; // Optimize, avoid normalize every time.
	
	    this.__dirty && textHelper.normalizeTextStyle(style, true); // Use props with prefix 'text'.
	
	    style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;
	    var text = style.text; // Convert to string
	
	    text != null && (text += ''); // Always bind style
	
	    style.bind(ctx, this, prevEl);
	
	    if (!textHelper.needDrawText(text, style)) {
	      return;
	    }
	
	    this.setTransform(ctx);
	    textHelper.renderText(this, ctx, text, style);
	    this.restoreTransform(ctx);
	  },
	  getBoundingRect: function () {
	    var style = this.style; // Optimize, avoid normalize every time.
	
	    this.__dirty && textHelper.normalizeTextStyle(style, true);
	
	    if (!this._rect) {
	      var text = style.text;
	      text != null ? text += '' : text = '';
	      var rect = textContain.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.rich);
	      rect.x += style.x || 0;
	      rect.y += style.y || 0;
	
	      if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {
	        var w = style.textStrokeWidth;
	        rect.x -= w / 2;
	        rect.y -= w / 2;
	        rect.width += w;
	        rect.height += w;
	      }
	
	      this._rect = rect;
	    }
	
	    return this._rect;
	  }
	};
	zrUtil.inherits(Text, Displayable);
	var _default = Text;
	module.exports = _default;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(47);
	
	/**
	 * 圆形
	 * @module zrender/shape/Circle
	 */
	var _default = Path.extend({
	  type: 'circle',
	  shape: {
	    cx: 0,
	    cy: 0,
	    r: 0
	  },
	  buildPath: function (ctx, shape, inBundle) {
	    // Better stroking in ShapeBundle
	    // Always do it may have performence issue ( fill may be 2x more cost)
	    if (inBundle) {
	      ctx.moveTo(shape.cx + shape.r, shape.cy);
	    } // else {
	    //     if (ctx.allocate && !ctx.data.length) {
	    //         ctx.allocate(ctx.CMD_MEM_SIZE.A);
	    //     }
	    // }
	    // Better stroking in ShapeBundle
	    // ctx.moveTo(shape.cx + shape.r, shape.cy);
	
	
	    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(47);
	
	var fixClipWithShadow = __webpack_require__(63);
	
	/**
	 * 扇形
	 * @module zrender/graphic/shape/Sector
	 */
	var _default = Path.extend({
	  type: 'sector',
	  shape: {
	    cx: 0,
	    cy: 0,
	    r0: 0,
	    r: 0,
	    startAngle: 0,
	    endAngle: Math.PI * 2,
	    clockwise: true
	  },
	  brush: fixClipWithShadow(Path.prototype.brush),
	  buildPath: function (ctx, shape) {
	    var x = shape.cx;
	    var y = shape.cy;
	    var r0 = Math.max(shape.r0 || 0, 0);
	    var r = Math.max(shape.r, 0);
	    var startAngle = shape.startAngle;
	    var endAngle = shape.endAngle;
	    var clockwise = shape.clockwise;
	    var unitX = Math.cos(startAngle);
	    var unitY = Math.sin(startAngle);
	    ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
	    ctx.lineTo(unitX * r + x, unitY * r + y);
	    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	    ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);
	
	    if (r0 !== 0) {
	      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
	    }
	
	    ctx.closePath();
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	var env = __webpack_require__(5);
	
	// Fix weird bug in some version of IE11 (like 11.0.9600.178**),
	// where exception "unexpected call to method or property access"
	// might be thrown when calling ctx.fill or ctx.stroke after a path
	// whose area size is zero is drawn and ctx.clip() is called and
	// shadowBlur is set. See #4572, #3112, #5777.
	// (e.g.,
	//  ctx.moveTo(10, 10);
	//  ctx.lineTo(20, 10);
	//  ctx.closePath();
	//  ctx.clip();
	//  ctx.shadowBlur = 10;
	//  ...
	//  ctx.fill();
	// )
	var shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];
	
	function _default(orignalBrush) {
	  // version string can be: '11.0'
	  return env.browser.ie && env.browser.version >= 11 ? function () {
	    var clipPaths = this.__clipPaths;
	    var style = this.style;
	    var modified;
	
	    if (clipPaths) {
	      for (var i = 0; i < clipPaths.length; i++) {
	        var clipPath = clipPaths[i];
	        var shape = clipPath && clipPath.shape;
	        var type = clipPath && clipPath.type;
	
	        if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {
	          for (var j = 0; j < shadowTemp.length; j++) {
	            // It is save to put shadowTemp static, because shadowTemp
	            // will be all modified each item brush called.
	            shadowTemp[j][2] = style[shadowTemp[j][0]];
	            style[shadowTemp[j][0]] = shadowTemp[j][1];
	          }
	
	          modified = true;
	          break;
	        }
	      }
	    }
	
	    orignalBrush.apply(this, arguments);
	
	    if (modified) {
	      for (var j = 0; j < shadowTemp.length; j++) {
	        style[shadowTemp[j][0]] = shadowTemp[j][2];
	      }
	    }
	  } : orignalBrush;
	}
	
	module.exports = _default;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(47);
	
	/**
	 * 圆环
	 * @module zrender/graphic/shape/Ring
	 */
	var _default = Path.extend({
	  type: 'ring',
	  shape: {
	    cx: 0,
	    cy: 0,
	    r: 0,
	    r0: 0
	  },
	  buildPath: function (ctx, shape) {
	    var x = shape.cx;
	    var y = shape.cy;
	    var PI2 = Math.PI * 2;
	    ctx.moveTo(x + shape.r, y);
	    ctx.arc(x, y, shape.r, 0, PI2, false);
	    ctx.moveTo(x + shape.r0, y);
	    ctx.arc(x, y, shape.r0, 0, PI2, true);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(47);
	
	var polyHelper = __webpack_require__(66);
	
	/**
	 * 多边形
	 * @module zrender/shape/Polygon
	 */
	var _default = Path.extend({
	  type: 'polygon',
	  shape: {
	    points: null,
	    smooth: false,
	    smoothConstraint: null
	  },
	  buildPath: function (ctx, shape) {
	    polyHelper.buildPath(ctx, shape, true);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	var smoothSpline = __webpack_require__(67);
	
	var smoothBezier = __webpack_require__(68);
	
	function buildPath(ctx, shape, closePath) {
	  var points = shape.points;
	  var smooth = shape.smooth;
	
	  if (points && points.length >= 2) {
	    if (smooth && smooth !== 'spline') {
	      var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);
	      ctx.moveTo(points[0][0], points[0][1]);
	      var len = points.length;
	
	      for (var i = 0; i < (closePath ? len : len - 1); i++) {
	        var cp1 = controlPoints[i * 2];
	        var cp2 = controlPoints[i * 2 + 1];
	        var p = points[(i + 1) % len];
	        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
	      }
	    } else {
	      if (smooth === 'spline') {
	        points = smoothSpline(points, closePath);
	      }
	
	      ctx.moveTo(points[0][0], points[0][1]);
	
	      for (var i = 1, l = points.length; i < l; i++) {
	        ctx.lineTo(points[i][0], points[i][1]);
	      }
	    }
	
	    closePath && ctx.closePath();
	  }
	}
	
	exports.buildPath = buildPath;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	var _vector = __webpack_require__(8);
	
	var v2Distance = _vector.distance;
	
	/**
	 * Catmull-Rom spline 插值折线
	 * @module zrender/shape/util/smoothSpline
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	
	/**
	 * @inner
	 */
	function interpolate(p0, p1, p2, p3, t, t2, t3) {
	  var v0 = (p2 - p0) * 0.5;
	  var v1 = (p3 - p1) * 0.5;
	  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
	}
	/**
	 * @alias module:zrender/shape/util/smoothSpline
	 * @param {Array} points 线段顶点数组
	 * @param {boolean} isLoop
	 * @return {Array}
	 */
	
	
	function _default(points, isLoop) {
	  var len = points.length;
	  var ret = [];
	  var distance = 0;
	
	  for (var i = 1; i < len; i++) {
	    distance += v2Distance(points[i - 1], points[i]);
	  }
	
	  var segs = distance / 2;
	  segs = segs < len ? len : segs;
	
	  for (var i = 0; i < segs; i++) {
	    var pos = i / (segs - 1) * (isLoop ? len : len - 1);
	    var idx = Math.floor(pos);
	    var w = pos - idx;
	    var p0;
	    var p1 = points[idx % len];
	    var p2;
	    var p3;
	
	    if (!isLoop) {
	      p0 = points[idx === 0 ? idx : idx - 1];
	      p2 = points[idx > len - 2 ? len - 1 : idx + 1];
	      p3 = points[idx > len - 3 ? len - 1 : idx + 2];
	    } else {
	      p0 = points[(idx - 1 + len) % len];
	      p2 = points[(idx + 1) % len];
	      p3 = points[(idx + 2) % len];
	    }
	
	    var w2 = w * w;
	    var w3 = w * w2;
	    ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);
	  }
	
	  return ret;
	}
	
	module.exports = _default;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	var _vector = __webpack_require__(8);
	
	var v2Min = _vector.min;
	var v2Max = _vector.max;
	var v2Scale = _vector.scale;
	var v2Distance = _vector.distance;
	var v2Add = _vector.add;
	var v2Clone = _vector.clone;
	var v2Sub = _vector.sub;
	
	/**
	 * 贝塞尔平滑曲线
	 * @module zrender/shape/util/smoothBezier
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	
	/**
	 * 贝塞尔平滑曲线
	 * @alias module:zrender/shape/util/smoothBezier
	 * @param {Array} points 线段顶点数组
	 * @param {number} smooth 平滑等级, 0-1
	 * @param {boolean} isLoop
	 * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内
	 *                           比如 [[0, 0], [100, 100]], 这个包围盒会与
	 *                           整个折线的包围盒做一个并集用来约束控制点。
	 * @param {Array} 计算出来的控制点数组
	 */
	function _default(points, smooth, isLoop, constraint) {
	  var cps = [];
	  var v = [];
	  var v1 = [];
	  var v2 = [];
	  var prevPoint;
	  var nextPoint;
	  var min, max;
	
	  if (constraint) {
	    min = [Infinity, Infinity];
	    max = [-Infinity, -Infinity];
	
	    for (var i = 0, len = points.length; i < len; i++) {
	      v2Min(min, min, points[i]);
	      v2Max(max, max, points[i]);
	    } // 与指定的包围盒做并集
	
	
	    v2Min(min, min, constraint[0]);
	    v2Max(max, max, constraint[1]);
	  }
	
	  for (var i = 0, len = points.length; i < len; i++) {
	    var point = points[i];
	
	    if (isLoop) {
	      prevPoint = points[i ? i - 1 : len - 1];
	      nextPoint = points[(i + 1) % len];
	    } else {
	      if (i === 0 || i === len - 1) {
	        cps.push(v2Clone(points[i]));
	        continue;
	      } else {
	        prevPoint = points[i - 1];
	        nextPoint = points[i + 1];
	      }
	    }
	
	    v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length
	
	    v2Scale(v, v, smooth);
	    var d0 = v2Distance(point, prevPoint);
	    var d1 = v2Distance(point, nextPoint);
	    var sum = d0 + d1;
	
	    if (sum !== 0) {
	      d0 /= sum;
	      d1 /= sum;
	    }
	
	    v2Scale(v1, v, -d0);
	    v2Scale(v2, v, d1);
	    var cp0 = v2Add([], point, v1);
	    var cp1 = v2Add([], point, v2);
	
	    if (constraint) {
	      v2Max(cp0, cp0, min);
	      v2Min(cp0, cp0, max);
	      v2Max(cp1, cp1, min);
	      v2Min(cp1, cp1, max);
	    }
	
	    cps.push(cp0);
	    cps.push(cp1);
	  }
	
	  if (isLoop) {
	    cps.push(cps.shift());
	  }
	
	  return cps;
	}
	
	module.exports = _default;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(47);
	
	var polyHelper = __webpack_require__(66);
	
	/**
	 * @module zrender/graphic/shape/Polyline
	 */
	var _default = Path.extend({
	  type: 'polyline',
	  shape: {
	    points: null,
	    smooth: false,
	    smoothConstraint: null
	  },
	  style: {
	    stroke: '#000',
	    fill: null
	  },
	  buildPath: function (ctx, shape) {
	    polyHelper.buildPath(ctx, shape, false);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(47);
	
	var roundRectHelper = __webpack_require__(37);
	
	/**
	 * 矩形
	 * @module zrender/graphic/shape/Rect
	 */
	var _default = Path.extend({
	  type: 'rect',
	  shape: {
	    // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
	    // r缩写为1         相当于 [1, 1, 1, 1]
	    // r缩写为[1]       相当于 [1, 1, 1, 1]
	    // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
	    // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
	    r: 0,
	    x: 0,
	    y: 0,
	    width: 0,
	    height: 0
	  },
	  buildPath: function (ctx, shape) {
	    var x = shape.x;
	    var y = shape.y;
	    var width = shape.width;
	    var height = shape.height;
	
	    if (!shape.r) {
	      ctx.rect(x, y, width, height);
	    } else {
	      roundRectHelper.buildPath(ctx, shape);
	    }
	
	    ctx.closePath();
	    return;
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(47);
	
	/**
	 * 直线
	 * @module zrender/graphic/shape/Line
	 */
	var _default = Path.extend({
	  type: 'line',
	  shape: {
	    // Start point
	    x1: 0,
	    y1: 0,
	    // End point
	    x2: 0,
	    y2: 0,
	    percent: 1
	  },
	  style: {
	    stroke: '#000',
	    fill: null
	  },
	  buildPath: function (ctx, shape) {
	    var x1 = shape.x1;
	    var y1 = shape.y1;
	    var x2 = shape.x2;
	    var y2 = shape.y2;
	    var percent = shape.percent;
	
	    if (percent === 0) {
	      return;
	    }
	
	    ctx.moveTo(x1, y1);
	
	    if (percent < 1) {
	      x2 = x1 * (1 - percent) + x2 * percent;
	      y2 = y1 * (1 - percent) + y2 * percent;
	    }
	
	    ctx.lineTo(x2, y2);
	  },
	
	  /**
	   * Get point at percent
	   * @param  {number} percent
	   * @return {Array.<number>}
	   */
	  pointAt: function (p) {
	    var shape = this.shape;
	    return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(47);
	
	var vec2 = __webpack_require__(8);
	
	var _curve = __webpack_require__(49);
	
	var quadraticSubdivide = _curve.quadraticSubdivide;
	var cubicSubdivide = _curve.cubicSubdivide;
	var quadraticAt = _curve.quadraticAt;
	var cubicAt = _curve.cubicAt;
	var quadraticDerivativeAt = _curve.quadraticDerivativeAt;
	var cubicDerivativeAt = _curve.cubicDerivativeAt;
	
	/**
	 * 贝塞尔曲线
	 * @module zrender/shape/BezierCurve
	 */
	var out = [];
	
	function someVectorAt(shape, t, isTangent) {
	  var cpx2 = shape.cpx2;
	  var cpy2 = shape.cpy2;
	
	  if (cpx2 === null || cpy2 === null) {
	    return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];
	  } else {
	    return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];
	  }
	}
	
	var _default = Path.extend({
	  type: 'bezier-curve',
	  shape: {
	    x1: 0,
	    y1: 0,
	    x2: 0,
	    y2: 0,
	    cpx1: 0,
	    cpy1: 0,
	    // cpx2: 0,
	    // cpy2: 0
	    // Curve show percent, for animating
	    percent: 1
	  },
	  style: {
	    stroke: '#000',
	    fill: null
	  },
	  buildPath: function (ctx, shape) {
	    var x1 = shape.x1;
	    var y1 = shape.y1;
	    var x2 = shape.x2;
	    var y2 = shape.y2;
	    var cpx1 = shape.cpx1;
	    var cpy1 = shape.cpy1;
	    var cpx2 = shape.cpx2;
	    var cpy2 = shape.cpy2;
	    var percent = shape.percent;
	
	    if (percent === 0) {
	      return;
	    }
	
	    ctx.moveTo(x1, y1);
	
	    if (cpx2 == null || cpy2 == null) {
	      if (percent < 1) {
	        quadraticSubdivide(x1, cpx1, x2, percent, out);
	        cpx1 = out[1];
	        x2 = out[2];
	        quadraticSubdivide(y1, cpy1, y2, percent, out);
	        cpy1 = out[1];
	        y2 = out[2];
	      }
	
	      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
	    } else {
	      if (percent < 1) {
	        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
	        cpx1 = out[1];
	        cpx2 = out[2];
	        x2 = out[3];
	        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
	        cpy1 = out[1];
	        cpy2 = out[2];
	        y2 = out[3];
	      }
	
	      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
	    }
	  },
	
	  /**
	   * Get point at percent
	   * @param  {number} t
	   * @return {Array.<number>}
	   */
	  pointAt: function (t) {
	    return someVectorAt(this.shape, t, false);
	  },
	
	  /**
	   * Get tangent at percent
	   * @param  {number} t
	   * @return {Array.<number>}
	   */
	  tangentAt: function (t) {
	    var p = someVectorAt(this.shape, t, true);
	    return vec2.normalize(p, p);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(47);
	
	/**
	 * 圆弧
	 * @module zrender/graphic/shape/Arc
	 */
	var _default = Path.extend({
	  type: 'arc',
	  shape: {
	    cx: 0,
	    cy: 0,
	    r: 0,
	    startAngle: 0,
	    endAngle: Math.PI * 2,
	    clockwise: true
	  },
	  style: {
	    stroke: '#000',
	    fill: null
	  },
	  buildPath: function (ctx, shape) {
	    var x = shape.cx;
	    var y = shape.cy;
	    var r = Math.max(shape.r, 0);
	    var startAngle = shape.startAngle;
	    var endAngle = shape.endAngle;
	    var clockwise = shape.clockwise;
	    var unitX = Math.cos(startAngle);
	    var unitY = Math.sin(startAngle);
	    ctx.moveTo(unitX * r + x, unitY * r + y);
	    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(6);
	
	var Gradient = __webpack_require__(59);
	
	/**
	 * x, y, x2, y2 are all percent from 0 to 1
	 * @param {number} [x=0]
	 * @param {number} [y=0]
	 * @param {number} [x2=1]
	 * @param {number} [y2=0]
	 * @param {Array.<Object>} colorStops
	 * @param {boolean} [globalCoord=false]
	 */
	var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {
	  // Should do nothing more in this constructor. Because gradient can be
	  // declard by `color: {type: 'linear', colorStops: ...}`, where
	  // this constructor will not be called.
	  this.x = x == null ? 0 : x;
	  this.y = y == null ? 0 : y;
	  this.x2 = x2 == null ? 1 : x2;
	  this.y2 = y2 == null ? 0 : y2; // Can be cloned
	
	  this.type = 'linear'; // If use global coord
	
	  this.global = globalCoord || false;
	  Gradient.call(this, colorStops);
	};
	
	LinearGradient.prototype = {
	  constructor: LinearGradient
	};
	zrUtil.inherits(LinearGradient, Gradient);
	var _default = LinearGradient;
	module.exports = _default;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(6);
	
	var Gradient = __webpack_require__(59);
	
	/**
	 * x, y, r are all percent from 0 to 1
	 * @param {number} [x=0.5]
	 * @param {number} [y=0.5]
	 * @param {number} [r=0.5]
	 * @param {Array.<Object>} [colorStops]
	 * @param {boolean} [globalCoord=false]
	 */
	var RadialGradient = function (x, y, r, colorStops, globalCoord) {
	  // Should do nothing more in this constructor. Because gradient can be
	  // declard by `color: {type: 'radial', colorStops: ...}`, where
	  // this constructor will not be called.
	  this.x = x == null ? 0.5 : x;
	  this.y = y == null ? 0.5 : y;
	  this.r = r == null ? 0.5 : r; // Can be cloned
	
	  this.type = 'radial'; // If use global coord
	
	  this.global = globalCoord || false;
	  Gradient.call(this, colorStops);
	};
	
	RadialGradient.prototype = {
	  constructor: RadialGradient
	};
	zrUtil.inherits(RadialGradient, Gradient);
	var _default = RadialGradient;
	module.exports = _default;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(6);
	
	var Style = __webpack_require__(28);
	
	var _vector = __webpack_require__(8);
	
	var vec2Copy = _vector.copy;
	
	/**
	 * States machine for managing graphic states
	 */
	
	/**
	 * @typedef {Object} IGraphicState
	 * @property {number} [zlevel]
	 * @property {number} [z]
	 * @property {Array.<number>} {position}
	 * @property {Array.<number>|number} {rotation}
	 * @property {Array.<number>} {scale}
	 * @property {Object} style
	 *
	 * @property {Function} onenter
	 * @property {Function} onleave
	 * @property {Function} ontransition
	 * @property {Array.<IGraphicStateTransition|string>} transition
	 *           Transition object or a string descriptor like '* 30 0 Linear'
	 */
	var transitionProperties = ['position', 'rotation', 'scale', 'style', 'shape'];
	/**
	 * @module zrender/graphic/States~TransitionObject
	 */
	
	var TransitionObject = function (opts) {
	  if (typeof opts == 'string') {
	    this._fromStr(opts);
	  } else if (opts) {
	    opts.property && (this.property = opts.property);
	    opts.duration != null && (this.duration = opts.duration);
	    opts.easing && (this.easing = opts.easing);
	    opts.delay && (this.delay = opts.delay);
	  }
	
	  if (this.property !== '*') {
	    this.property = this.property.split(',');
	  } else {
	    this.property = transitionProperties;
	  }
	};
	
	TransitionObject.prototype = {
	  constructor: TransitionObject,
	
	  /**
	   * List of all transition properties. Splitted by comma. Must not have spaces in the string.
	   * e.g. 'position,style.color'. '*' will match all the valid properties.
	   * @type {string}
	   * @default *
	   */
	  property: '*',
	
	  /**
	   * @type {string}
	   * @default 'Linear'
	   */
	  easing: 'Linear',
	
	  /**
	   * @type {number}
	   * @default 'number'
	   */
	  duration: 500,
	
	  /**
	   * @type {number}
	   */
	  delay: 0,
	  _fromStr: function (str) {
	    var arr = str.split(/\s+/g);
	    this.property = arr[0];
	    this.duration = +arr[1];
	    this.delay = +arr[2];
	    this.easing = arr[3];
	  }
	};
	/**
	 * @alias module:zrender/graphic/States
	 */
	
	var GraphicStates = function (opts) {
	  opts = opts || {};
	  this._states = {};
	  /**
	   * Target element
	   * @type {zrender/graphic/Displayable|zrender/container/Group}
	   */
	
	  this._el = opts.el;
	  this._subStates = [];
	  this._transitionAnimators = [];
	
	  if (opts.initialState) {
	    this._initialState = opts.initialState;
	  }
	
	  var optsStates = opts.states;
	
	  if (optsStates) {
	    for (var name in optsStates) {
	      if (optsStates.hasOwnProperty(name)) {
	        var state = optsStates[name];
	
	        this._addState(name, state);
	      }
	    }
	  }
	
	  this.setState(this._initialState);
	};
	
	GraphicStates.prototype = {
	  constructor: GraphicStates,
	
	  /**
	   * All other state will be extended from initial state
	   * @type {string}
	   * @private
	   */
	  _initialState: 'normal',
	
	  /**
	   * Current state
	   * @type {string}
	   * @private
	   */
	  _currentState: '',
	  el: function () {
	    return this._el;
	  },
	  _addState: function (name, state) {
	    this._states[name] = state;
	
	    if (state.transition) {
	      state.transition = new TransitionObject(state.transition);
	    } // Extend from initial state
	
	
	    if (name !== this._initialState) {
	      this._extendFromInitial(state);
	    } else {
	      var el = this._el; // setState 的时候自带的 style 和 shape 都会被直接覆盖
	      // 所以这边先把自带的 style 和 shape 扩展到初始状态中
	
	      zrUtil.merge(state.style, el.style, false, false);
	
	      if (state.shape) {
	        zrUtil.merge(state.shape, el.shape, false, true);
	      } else {
	        state.shape = zrUtil.clone(el.shape, true);
	      }
	
	      for (var name in this._states) {
	        if (this._states.hasOwnProperty(name)) {
	          this._extendFromInitial(this._states[name]);
	        }
	      }
	    }
	  },
	  _extendFromInitial: function (state) {
	    var initialState = this._states[this._initialState];
	
	    if (initialState && state !== initialState) {
	      zrUtil.merge(state, initialState, false, true);
	    }
	  },
	  setState: function (name, silent) {
	    if (name === this._currentState && !this.transiting()) {
	      return;
	    }
	
	    var state = this._states[name];
	
	    if (state) {
	      this._stopTransition();
	
	      if (!silent) {
	        var prevState = this._states[this._currentState];
	
	        if (prevState) {
	          prevState.onleave && prevState.onleave.call(this);
	        }
	
	        state.onenter && state.onenter.call(this);
	      }
	
	      this._currentState = name;
	
	      if (this._el) {
	        var el = this._el; // Setting attributes
	
	        if (state.zlevel != null) {
	          el.zlevel = state.zlevel;
	        }
	
	        if (state.z != null) {
	          el.z = state.z;
	        } // SRT
	
	
	        state.position && vec2Copy(el.position, state.position);
	        state.scale && vec2Copy(el.scale, state.scale);
	
	        if (state.rotation != null) {
	          el.rotation = state.rotation;
	        } // Style
	
	
	        if (state.style) {
	          var initialState = this._states[this._initialState];
	          el.style = new Style();
	
	          if (initialState) {
	            el.style.extendFrom(initialState.style, false);
	          }
	
	          if ( // Not initial state
	          name != this._initialState // Not copied from initial state in _extendFromInitial method
	          && initialState.style !== state.style) {
	            el.style.extendFrom(state.style, true);
	          }
	        }
	
	        if (state.shape) {
	          el.shape = zrUtil.clone(state.shape, true);
	        }
	
	        el.dirty();
	      }
	    }
	
	    for (var i = 0; i < this._subStates.length; i++) {
	      this._subStates.setState(name);
	    }
	  },
	  getState: function () {
	    return this._currentState;
	  },
	  transitionState: function (target, done) {
	    if (target === this._currentState && !this.transiting()) {
	      return;
	    }
	
	    var state = this._states[target];
	    var styleShapeReg = /$[style|shape]\./;
	    var self = this; // Animation 去重
	
	    var propPathMap = {};
	
	    if (state) {
	      self._stopTransition();
	
	      var el = self._el;
	
	      if (state.transition && el && el.__zr) {
	        // El can be animated
	        var transitionCfg = state.transition;
	        var property = transitionCfg.property;
	        var animatingCount = 0;
	
	        var animationDone = function () {
	          animatingCount--;
	
	          if (animatingCount === 0) {
	            self.setState(target);
	            done && done();
	          }
	        };
	
	        for (var i = 0; i < property.length; i++) {
	          var propName = property[i]; // Animating all the properties in style or shape
	
	          if (propName === 'style' || propName === 'shape') {
	            if (state[propName]) {
	              for (var key in state[propName]) {
	                if (!state[propName].hasOwnProperty(key)) {
	                  continue;
	                }
	
	                var path = propName + '.' + key;
	
	                if (propPathMap[path]) {
	                  continue;
	                }
	
	                propPathMap[path] = 1;
	                animatingCount += self._animProp(state, propName, key, transitionCfg, animationDone);
	              }
	            }
	          } else {
	            if (propPathMap[propName]) {
	              continue;
	            }
	
	            propPathMap[propName] = 1; // Animating particular property in style or style
	
	            if (propName.match(styleShapeReg)) {
	              // remove 'style.', 'shape.' prefix
	              var subProp = propName.slice(0, 5);
	              propName = propName.slice(6);
	              animatingCount += self._animProp(state, subProp, propName, transitionCfg, animationDone);
	            } else {
	              animatingCount += self._animProp(state, '', propName, transitionCfg, animationDone);
	            }
	          }
	        } // No transition properties
	
	
	        if (animatingCount === 0) {
	          self.setState(target);
	          done && done();
	        }
	      } else {
	        self.setState(target);
	        done && done();
	      }
	    }
	
	    var subStates = self._subStates;
	
	    for (var i = 0; i < subStates.length; i++) {
	      subStates.transitionState(target);
	    }
	  },
	
	  /**
	   * Do transition animation of particular property
	   * @param {Object} state
	   * @param {string} subPropKey
	   * @param {string} key
	   * @param {Object} transitionCfg
	   * @param {Function} done
	   * @private
	   */
	  _animProp: function (state, subPropKey, key, transitionCfg, done) {
	    var el = this._el;
	    var stateObj = subPropKey ? state[subPropKey] : state;
	    var elObj = subPropKey ? el[subPropKey] : el;
	    var availableProp = stateObj && key in stateObj && elObj && key in elObj;
	    var transitionAnimators = this._transitionAnimators;
	
	    if (availableProp) {
	      var obj = {};
	
	      if (stateObj[key] === elObj[key]) {
	        return 0;
	      }
	
	      obj[key] = stateObj[key];
	      var animator = el.animate(subPropKey).when(transitionCfg.duration, obj).delay(transitionCfg.dealy).done(function () {
	        var idx = zrUtil.indexOf(transitionAnimators, 1);
	
	        if (idx > 0) {
	          transitionAnimators.splice(idx, 1);
	        }
	
	        done();
	      }).start(transitionCfg.easing);
	      transitionAnimators.push(animator);
	      return 1;
	    }
	
	    return 0;
	  },
	  _stopTransition: function () {
	    var transitionAnimators = this._transitionAnimators;
	
	    for (var i = 0; i < transitionAnimators.length; i++) {
	      transitionAnimators[i].stop();
	    }
	
	    transitionAnimators.length = 0;
	  },
	  transiting: function () {
	    return this._transitionAnimators.length > 0;
	  },
	  addSubStates: function (states) {
	    this._subStates.push(states);
	  },
	  removeSubStates: function (states) {
	    var idx = zrUtil.indexOf(this._subStates, states);
	
	    if (idx >= 0) {
	      this._subStates.splice(states, 1);
	    }
	  }
	};
	var _default = GraphicStates;
	module.exports = _default;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 事件决策多边形
	 * @module fish-topo-bo/node/EventDecisionNode
	 * Created by majianan on 16/5/19.
	 */
	
	    var Const = __webpack_require__(43);
	    var graphic = __webpack_require__(45);
	    var nodeOptions = null;
	
	    function EventDecisionNode(data, opts) {
	        nodeOptions = opts;
	
	        /**
	         * BO属性数据
	         * @type {Object}
	         * @private
	         */
	        this._data = data;
	
	        /**
	         * 起始位置坐标
	         * @type {startPos}
	         * @private
	         */
	        this._startPos = opts.startPos;
	
	        this._type = opts.type || 'boEvent';
	
	        /**
	         * 是否支持点击
	         * @type {boolean}
	         * @private
	         */
	        this._clickable = opts.clickable || false;
	        this._popupOpts = opts.popupOpts;
	
	        /**
	         * Group容器
	         * @type zrender/graphic/Group
	         * @private
	         */
	        this._group = new graphic.Group();
	        this._group.name = this._data.id;
	
	        //生成BO属性图形
	        this._render();
	    }
	
	    var eventProto = EventDecisionNode.prototype;
	
	    /**
	     * 获取关系整体图形
	     * @returns {zrender/graphic/Group}
	     */
	    eventProto.getShape = function () {
	        return this._group;
	    };
	
	    /**
	     * 生成事件决策图形
	     * @private
	     */
	    eventProto._render = function () {
	        //多边形
	        this._createEventShape();
	        //文字
	        this._createEVentName();
	    };
	
	    /**
	     * 事件决策多边形
	     * @private
	     */
	    eventProto._createEventShape = function () {
	
	        //多边形高度
	        var height = Const.BO_EVENT_HEIGHT,
	            x = this._startPos.x + 1,
	            y = this._startPos.y,
	            width = this._type == 'boEvent' ? Const.BO_EVENT_WIDTH : Const.BO_ATTR_EVENT_WIDTH,
	
	            shape = new graphic.Polygon({
	                name: this._data.id,
	                shape: {
	                    points: [
	                        [x, y],
	                        [x + width - 10, y],
	                        [x + width, y + height / 2],
	                        [x + width - 10, y + height],
	                        [x, y + height]]
	                },
	
	                style: {
	                    fill: '#FFCCCC',
	                    stroke: '#000000',
	                    lineWidth: 0.75
	                }
	
	            });
	
	        if (this._clickable) {
	            shape.clickable = this._clickable;
	            shape._data = this._data;
	            shape._popupOpts = this._popupOpts;
	            shape.onclick = this._click;
	        }
	
	
	        this._group.add(shape);
	    };
	
	    /**
	     * 点击事件
	     * @private
	     */
	    eventProto._click = function () {
	        var options = Object.assign(
	            {
	                DATA: this._data
	            }, this._popupOpts);
	
	        nodeOptions.bindBoClickEvent(options);
	    };
	
	    /**
	     * 事件决策名称
	     * @private
	     */
	    eventProto._createEVentName = function () {
	        var x = this._startPos.x + (this._type == 'boEvent' ? Const.BO_ATTR_PADDING_LEFT : 15),
	            y = this._startPos.y,
	
	            eventNameShape = new graphic.Text({
	                style: {
	                    text: this._data.name,
	                    textFont: Const.BO_EVENT_FONT,
	                    textAlign: 'left',  //靠左开始，便于计算位置
	                    textBaseline: 'top'
	                },
	
	                position: [x, y]
	            });
	
	        if (this._clickable) {
	            eventNameShape.clickable = this._clickable;
	            eventNameShape._data = this._data;
	            eventNameShape._popupOpts = this._popupOpts;
	            eventNameShape.onclick = this._click;
	        }
	
	        this._group.add(eventNameShape);
	    };
	
	    module.exports = EventDecisionNode;
	


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * BO矩形内部的横线，分为实线和虚线两种
	 * @module fish-topo-bo/node/LineNode
	 * Created by majianan on 16/5/19.
	 */
	
	
	    var Const = __webpack_require__(43);
	    var graphic = __webpack_require__(45);
	    var util = __webpack_require__(6);
	    /**
	     * BO名字下面的实现
	     * @param {{x: *, y: *}} startPos, 开始坐标
	     * @returns {zrender/graphic/shape/Line}
	     * @constructor
	     */
	    function BoLine(startPos) {
	
	        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y};
	
	        return _line(startPos, endPos);
	    }
	
	    /**
	     * BO属性之间的虚线
	     * @param {{x: *, y: *}} startPos, 开始坐标
	     * @returns {zrender/graphic/shape/Line}
	     * @constructor
	     */
	    function AttrLine(startPos) {
	
	        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y},
	            style = {lineDash: [Const.LINE_DASH]};
	
	        return _line(startPos, endPos, style);
	    }
	
	    /**
	     * BO属性与BO事件决策之间的垂直虚线
	     * @param {{x: *, y: *}} startPos, 开始坐标
	     * @param {int} attrHeight, 高度
	     * @returns {zrender/graphic/shape/Line}
	     * @constructor
	     */
	    function AttrEventLine(startPos, attrHeight) {
	        var endPos = {x: startPos.x, y: startPos.y + attrHeight},
	            style = {lineDash: [Const.LINE_DASH]};
	
	        return _line(startPos, endPos, style);
	    }
	
	    /**
	     * 画线
	     * @param {{x: *, y: *}} startPos, 开始坐标
	     * @param {{x: *, y: *}} endPos, 结束坐标
	     * @param {Object} style, 样式,可空
	     * @returns {zrender/graphic/shape/Line}
	     * @private
	     */
	    function _line(startPos, endPos, style) {
	
	        var _style = {
	            strokeColor: '#000000',
	            lineWidth: 0.5,
	            percent: 1
	        };
	
	        util.extend(_style, style);
	
	        var shape = new graphic.Line({
	            shape: {
	                // Start point
	                x1: startPos.x,
	                y1: startPos.y,
	
	                // End point
	                x2: endPos.x,
	                y2: endPos.y,
	
	                percent: 1
	            },
	
	            style: _style
	        });
	
	        return shape;
	    }
	
	
	    module.exports = {
	        BoLine: BoLine,
	        AttrLine: AttrLine,
	        AttrEventLine: AttrEventLine
	    };
	


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * BO属性
	 * 1.BO属性名字
	 * 2.BO属性数据类型
	 * 3.BO属性事件决策
	 * @module fish-topo-bo/node/BoAttrNode
	 * Created by majianan on 16/5/19.
	 */
	
	    var Const = __webpack_require__(43);
	    var EventDecision = __webpack_require__(77);
	    var graphic = __webpack_require__(45);
	    var nodeOptions = null;
	
	    /**
	     *
	     * @param {{
	     *          id: String bo属性标识,
	     *          code: String bo属性编码
	     *          keyValue: boolean 是否为主键,
	     *          dataType: String 属性数据类型,
	     *          boAttrEventArr:[] 属性事件决策数组
	     *          }} boAttrData BO属性数据对象,
	     * @param {{
	     *          startPos: {x: number, y: number}起始位置,
	     *          displayDataType: boolean 是否显示数据类型,
	     *          displayEventDecision: boolean 是否显示事件决策,
	     *          eventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false,
	     *          eventPopupOpts: Object 点击BO属性事件决策弹出页面参数，url,width,height等,
	     *          }} opts
	     * @constructor
	     */
	    function BoAttr(boAttrData, opts) {
	        nodeOptions = opts;
	
	        /**
	         * BO属性数据
	         * @type {Object}
	         * @private
	         */
	        this._data = boAttrData;
	
	        /**
	         * 是否为主键
	         * @type {boolean}
	         * @private
	         */
	        this._keyValue = boAttrData.keyValue || false;
	
	        /**
	         * 起始位置坐标
	         * @type {startPos}
	         * @private
	         */
	        this._startPos = opts.startPos;
	
	        /**
	         * 是否显示数据类型
	         * @type {boolean}
	         * @private
	         */
	        this._displayDataType = opts.displayDataType || false;
	
	        /**
	         * 是否显示事件决策
	         * @type {boolean}
	         * @private
	         */
	        this._displayEventDecision = opts.displayEventDecision || false;
	
	        /**
	         * 是否支持点击
	         * @type {boolean}
	         * @private
	         */
	        this._eventClickable = opts.eventClickable || false;
	        this._eventPopupOpts = opts.eventPopupOpts;
	
	        /**
	         * Group容器
	         * @type zrender/graphic/Group
	         * @private
	         */
	        this._group = new graphic.Group();
	        this._group.name = this._data.id;
	
	        //生成BO属性图形
	        this._render();
	    }
	
	    var boAttrProto = BoAttr.prototype;
	
	    /**
	     * 获取关系整体图形
	     * @returns {zrender/graphic/Group}
	     */
	    boAttrProto.getShape = function () {
	        return this._group;
	    };
	
	
	    /**
	     * 生成BO属性图形
	     * @private
	     */
	    boAttrProto._render = function () {
	        //属性名字
	        this._createText();
	
	        //属性数据类型
	        this._createDataType();
	
	        //属性事件决策
	        this._createEventDecision();
	    };
	
	    /**
	     * 属性名字
	     * @private
	     */
	    boAttrProto._createText = function () {
	
	        var x = this._startPos.x + Const.BO_ATTR_PADDING_LEFT,
	            y = this._startPos.y,
	
	            attrNameShape = new graphic.Text({
	                style: {
	                    text: this._data.name,
	                    textFont: Const.BO_ATTR_FONT,
	                    textAlign: 'left',  //靠左开始，便于计算位置
	                    textBaseline: 'top',
	                    //lineWidth: 1,
	                    fill: this._keyValue ? 'red' : 'black'
	                },
	
	                position: [x, y]
	            });
	
	        //重新设置图形高度 = 文本高度 + padding-top + padding-bottom
	        attrNameShape.getBoundingRect().height += Const.BO_ATTR_PADDING_TOP + Const.BO_ATTR_PADDING_BOTTOM;
	        //重新设置图形高度 = BO矩形宽度，用于后续Relation画图计算
	        attrNameShape.getBoundingRect().width = Const.BO_NODE_WIDTH;
	
	        //重新设置B起始水平坐标 = 减去偏移量
	        attrNameShape.getBoundingRect().x += -Const.BO_ATTR_PADDING_LEFT;
	        //attrNameShape.getBoundingRect().y = + attrNameShape.position[1];
	
	        this._group.add(attrNameShape);
	    };
	
	    /**
	     * 属性数据类型
	     * @private
	     */
	    boAttrProto._createDataType = function () {
	        if (!this._displayDataType) {
	            return;
	        }
	
	        var x = this._startPos.x + Const.BO_NODE_WIDTH - 10,
	            y = this._startPos.y,
	            textAlign = 'right';
	
	        //如果还要显示事件决策，则宽度重新计算
	        if (this._displayEventDecision) {
	            textAlign = 'left';
	            x = this._startPos.x + Const.BO_NODE_WIDTH / 3;
	        }
	
	        var _dataTypeShape = new graphic.Text({
	            style: {
	                text: this._data.dataType || '',
	                textFont: Const.BO_ATTR_FONT,
	                textAlign: textAlign,  //靠左开始，便于计算位置
	                textBaseline: 'top',
	                lineWidth: 1
	            },
	
	            position: [x, y]
	        });
	
	        this._group.add(_dataTypeShape);
	    };
	
	    /**
	     * 属性事件决策
	     * @private
	     */
	    boAttrProto._createEventDecision = function () {
	        if (!this._displayEventDecision) {
	            return;
	        }
	
	        var _boAttrEventArr = this._data.boAttrEventArr || [],
	            _boAttrEventLen = _boAttrEventArr.length,
	            padding = (_boAttrEventLen > 1) ? 10 : 0,
	            _startPos = {
	                x: this._startPos.x + Const.BO_NODE_WIDTH / 2 + Const.BO_ATTR_EVENT_WIDTH * (_boAttrEventLen - 1) - padding,
	                y: this._startPos.y
	            };
	
	        //从右向左画，
	        for (var i = _boAttrEventLen - 1; i >= 0; i--) {
	            this._group.add(new EventDecision(_boAttrEventArr[i], {
	                startPos: _startPos,
	                type: 'boAttrEvent',
	                clickable: this._eventClickable,
	                popupOpts: this._eventPopupOpts,
	                bindBoClickEvent: nodeOptions.bindBoClickEvent
	            }).getShape());
	            _startPos = {x: _startPos.x - Const.BO_ATTR_EVENT_WIDTH + 10, y: _startPos.y};
	        }
	        /*_startPos = {
	         x: this._startPos.x + Const.BO_NODE_WIDTH / 2,
	         y: this._startPos.y};
	
	         for (var i = 0; i < _boAttrEventLen; i++) {
	         this._group.add(event.BoAttrEvent(_boAttrEventArr[i], _startPos, i + 2));
	         _startPos = {x: _startPos.x + Const.BO_ATTR_EVENT_WIDTH - 5, y: _startPos.y};
	         }*/
	
	
	    };
	
	    module.exports = BoAttr;
	


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 用来创建关联关系
	 * 关联关系包括折线、箭头、关系文字说明
	 * @module fish-topo-bo/node/Relation
	 * Created by majianan on 16/5/19.
	 */
	
	    var Const = __webpack_require__(43);
	    var graphic = __webpack_require__(45);
	    var zrUtil = __webpack_require__(6);
	
	    /**
	     *
	     * @param sourceShape, 开始图形
	     * @param targetShape, 目标图形
	     * @param {String} sourceText, 关系开始文字说明,可空
	     * @param {String} targetText, 关系结束文字说明,可空
	     * @param {String} lineStyle, 关联线样式
	     * @param {String} lineHoverStyle, 关联线hover样式
	     * @param {String} arrowStyle, 关联线箭头样式
	     * @param {String} arrowHoverStyle, 关联线箭头hover样式
	     * @constructor
	     */
	    function Relation(sourceShape, targetShape, sourceText, targetText, lineStyle, lineHoverStyle, arrowStyle, arrowHoverStyle) {
	        this._sourceText = sourceText;
	        this._targetText = targetText;
	
	        this._group = new graphic.Group();
	
	        //左侧开始位置
	        this._lStartPos = {
	            x: sourceShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,
	            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2
	        };
	
	        //左侧结束位置
	        this._lEndPos = {
	            x: targetShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,
	            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2
	        };
	
	        //右侧开始位置
	        this._rStartPos = {
	            x: sourceShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,
	            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2
	        };
	
	        //右侧结束位置
	        this._rEndPos = {
	            x: targetShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,
	            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2
	        };
	
	        //判断画线方向
	        this._leftDirection = this._lStartPos.x - this._lEndPos.x <= 0;
	
	        //关联线样式
	        this._lineStyle = lineStyle;
	
	        //关联线hover样式
	        this._lineHoverStyle = lineHoverStyle;
	
	        //关联线箭头样式
	        this._arrowStyle = arrowStyle;
	
	        //关联线箭头hover样式
	        this._arrowHoverStyle = arrowHoverStyle;
	
	        //生成图形
	        this._render();
	    }
	
	    var relationProto = Relation.prototype;
	
	    /**
	     * 获取关系整体图形
	     * @returns {*}
	     */
	    relationProto.getShape = function () {
	        return this._group;
	    };
	
	    /**
	     * 生成关系整体图形
	     * @private
	     */
	    relationProto._render = function () {
	        //画线
	        this._createLine();
	
	        //箭头
	        this._createArrow();
	
	        //关系说明文字
	        this._createText();
	
	    };
	
	    /**
	     * 生成关系折线
	     * @private
	     */
	    relationProto._createLine = function () {
	        var _linePoints = [];
	
	        if (this._leftDirection) {
	            //第一点
	            _linePoints.push([this._lStartPos.x, this._lStartPos.y]);
	            //第二点
	            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lStartPos.y]);
	            //第三点
	            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lEndPos.y]);
	            //第四点
	            _linePoints.push([this._lEndPos.x, this._lEndPos.y]);
	        }
	        else {
	            //第一点
	            _linePoints.push([this._rStartPos.x, this._rStartPos.y]);
	            //第二点
	            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._lStartPos.y]);
	            //第三点
	            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._rEndPos.y]);
	            //第四点
	            _linePoints.push([this._rEndPos.x, this._rEndPos.y]);
	        }
	
	        var _lineShape = new graphic.Polyline({
	            shape: {
	                points: _linePoints
	            },
	
	            style: {
	                //fill: 'blue',
	                stroke: this._lineStyle.stroke,
	                lineWidth: this._lineStyle.lineWidth,
	                lineDash: this._lineStyle.lineDash
	            }
	
	        });
	
	        this._group.add(_lineShape);
	
	        //线hover
	        this._createHoverStyle(_lineShape, this._lineHoverStyle);
	
	    };
	
	    /**
	     * 生成箭头图形
	     * @private
	     */
	    relationProto._createArrow = function () {
	        var _arrowPoints = [];
	
	        if (this._leftDirection) {
	            //右侧第一点
	            _arrowPoints.push([this._lEndPos.x, this._lEndPos.y]);
	            //下面第二点
	            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y + Const.RELATION_ARROW_HEIGHT]);
	            //上面第三点
	            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_ARROW_HEIGHT]);
	        }
	        else {
	            //左侧第一点
	            _arrowPoints.push([this._rEndPos.x, this._rEndPos.y]);
	            //下面第二点
	            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y + Const.RELATION_ARROW_HEIGHT]);
	            //上面第三点
	            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_ARROW_HEIGHT]);
	        }
	
	        var _arrowShape = new graphic.Polyline({
	            shape: {
	                points: _arrowPoints
	            },
	
	            style: {
	                fill: this._arrowStyle.fill,
	                stroke: this._arrowStyle.stroke
	            }
	        });
	
	        this._group.add(_arrowShape);
	
	        //箭头hover
	        this._createHoverStyle(_arrowShape, this._arrowHoverStyle);
	    };
	
	    /**
	     * 生成文字说明
	     * @private
	     */
	    relationProto._createText = function () {
	        var _sourceTextPos,
	            _targetTextPos,
	            _textAlign;
	
	        if (this._leftDirection) {
	            _sourceTextPos = [this._lStartPos.x - 10, this._lStartPos.y - Const.RELATION_TEXT_OFFSET_Y];
	            _targetTextPos = [this._lEndPos.x - 10 - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_TEXT_OFFSET_Y];
	            _textAlign = 'right';
	        }
	        else {
	            _sourceTextPos = [this._rStartPos.x + 10, this._rStartPos.y - Const.RELATION_TEXT_OFFSET_Y];
	            _targetTextPos = [this._rEndPos.x + 10 + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_TEXT_OFFSET_Y];
	            _textAlign = 'left';
	        }
	
	        //开始文字
	        if (this._sourceText) {
	            var _srcTextShape = new graphic.Text({
	                position: _sourceTextPos,
	
	                style: {
	                    text: this._sourceText,
	                    textFont: Const.BO_ATTR_FONT,
	                    textAlign: _textAlign,
	                    textBaseline: 'buttom',
	                    lineWidth: 1
	                }
	            });
	            this._group.add(_srcTextShape);
	        }
	
	        //结束文字
	        if (this._targetText) {
	            var _targetTextShape = new graphic.Text({
	                position: _targetTextPos,
	
	                style: {
	                    text: this._targetText,
	                    textFont: Const.BO_ATTR_FONT,
	                    textAlign: _textAlign,
	                    textBaseline: 'buttom',
	                    lineWidth: 1
	                }
	            });
	            this._group.add(_targetTextShape);
	        }
	
	    };
	
	    /**
	     * 关联线hover
	     * @private
	     */
	    relationProto._createHoverStyle = function (el, style) {
	        if (style) {
	            graphic.setElementHoverStl(el, style);
	            el.on('mouseover', zrUtil.bind(function() {
	                graphic.doEnterHover(el);
	                this._group.eachChild(function(line) {
	                    graphic.doEnterHover(line);
	                });
	            }, this))
	            .on('mouseout', zrUtil.bind(function() {
	                graphic.doLeaveHover(el);
	                this._group.eachChild(function(line) {
	                    graphic.doLeaveHover(line);
	                });
	            }, this));
	        }
	    };
	
	    module.exports = Relation;


/***/ }),
/* 81 */
/***/ (function(module, exports) {

	
	    if (typeof Object.assign != 'function') {
	        // Must be writable: true, enumerable: false, configurable: true
	        Object.defineProperty(Object, "assign", {
	            value: function assign(target, varArgs) { // .length of function is 2
	                'use strict';
	                if (target == null) { // TypeError if undefined or null
	                    throw new TypeError('Cannot convert undefined or null to object');
	                }
	
	                var to = Object(target);
	
	                for (var index = 1; index < arguments.length; index++) {
	                    var nextSource = arguments[index];
	
	                    if (nextSource != null) { // Skip over if undefined or null
	                    for (var nextKey in nextSource) {
	                        // Avoid bugs when hasOwnProperty is shadowed
	                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
	                        to[nextKey] = nextSource[nextKey];
	                        }
	                    }
	                    }
	                }
	                return to;
	            },
	            writable: true,
	            configurable: true
	        });
	    }
	


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(83);
	
	var _zrender = __webpack_require__(3);
	
	var registerPainter = _zrender.registerPainter;
	
	var Painter = __webpack_require__(85);
	
	registerPainter('vml', Painter);

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	var env = __webpack_require__(5);
	
	var _vector = __webpack_require__(8);
	
	var applyTransform = _vector.applyTransform;
	
	var BoundingRect = __webpack_require__(24);
	
	var colorTool = __webpack_require__(20);
	
	var textContain = __webpack_require__(35);
	
	var textHelper = __webpack_require__(34);
	
	var RectText = __webpack_require__(33);
	
	var Displayable = __webpack_require__(32);
	
	var ZImage = __webpack_require__(31);
	
	var Text = __webpack_require__(60);
	
	var Path = __webpack_require__(47);
	
	var PathProxy = __webpack_require__(48);
	
	var Gradient = __webpack_require__(59);
	
	var vmlCore = __webpack_require__(84);
	
	// http://www.w3.org/TR/NOTE-VML
	// TODO Use proxy like svg instead of overwrite brush methods
	var CMD = PathProxy.CMD;
	var round = Math.round;
	var sqrt = Math.sqrt;
	var abs = Math.abs;
	var cos = Math.cos;
	var sin = Math.sin;
	var mathMax = Math.max;
	
	if (!env.canvasSupported) {
	  var comma = ',';
	  var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';
	  var Z = 21600;
	  var Z2 = Z / 2;
	  var ZLEVEL_BASE = 100000;
	  var Z_BASE = 1000;
	
	  var initRootElStyle = function (el) {
	    el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';
	    el.coordsize = Z + ',' + Z;
	    el.coordorigin = '0,0';
	  };
	
	  var encodeHtmlAttribute = function (s) {
	    return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
	  };
	
	  var rgb2Str = function (r, g, b) {
	    return 'rgb(' + [r, g, b].join(',') + ')';
	  };
	
	  var append = function (parent, child) {
	    if (child && parent && child.parentNode !== parent) {
	      parent.appendChild(child);
	    }
	  };
	
	  var remove = function (parent, child) {
	    if (child && parent && child.parentNode === parent) {
	      parent.removeChild(child);
	    }
	  };
	
	  var getZIndex = function (zlevel, z, z2) {
	    // z 的取值范围为 [0, 1000]
	    return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;
	  };
	
	  var parsePercent = function (value, maxValue) {
	    if (typeof value === 'string') {
	      if (value.lastIndexOf('%') >= 0) {
	        return parseFloat(value) / 100 * maxValue;
	      }
	
	      return parseFloat(value);
	    }
	
	    return value;
	  };
	  /***************************************************
	   * PATH
	   **************************************************/
	
	
	  var setColorAndOpacity = function (el, color, opacity) {
	    var colorArr = colorTool.parse(color);
	    opacity = +opacity;
	
	    if (isNaN(opacity)) {
	      opacity = 1;
	    }
	
	    if (colorArr) {
	      el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);
	      el.opacity = opacity * colorArr[3];
	    }
	  };
	
	  var getColorAndAlpha = function (color) {
	    var colorArr = colorTool.parse(color);
	    return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];
	  };
	
	  var updateFillNode = function (el, style, zrEl) {
	    // TODO pattern
	    var fill = style.fill;
	
	    if (fill != null) {
	      // Modified from excanvas
	      if (fill instanceof Gradient) {
	        var gradientType;
	        var angle = 0;
	        var focus = [0, 0]; // additional offset
	
	        var shift = 0; // scale factor for offset
	
	        var expansion = 1;
	        var rect = zrEl.getBoundingRect();
	        var rectWidth = rect.width;
	        var rectHeight = rect.height;
	
	        if (fill.type === 'linear') {
	          gradientType = 'gradient';
	          var transform = zrEl.transform;
	          var p0 = [fill.x * rectWidth, fill.y * rectHeight];
	          var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];
	
	          if (transform) {
	            applyTransform(p0, p0, transform);
	            applyTransform(p1, p1, transform);
	          }
	
	          var dx = p1[0] - p0[0];
	          var dy = p1[1] - p0[1];
	          angle = Math.atan2(dx, dy) * 180 / Math.PI; // The angle should be a non-negative number.
	
	          if (angle < 0) {
	            angle += 360;
	          } // Very small angles produce an unexpected result because they are
	          // converted to a scientific notation string.
	
	
	          if (angle < 1e-6) {
	            angle = 0;
	          }
	        } else {
	          gradientType = 'gradientradial';
	          var p0 = [fill.x * rectWidth, fill.y * rectHeight];
	          var transform = zrEl.transform;
	          var scale = zrEl.scale;
	          var width = rectWidth;
	          var height = rectHeight;
	          focus = [// Percent in bounding rect
	          (p0[0] - rect.x) / width, (p0[1] - rect.y) / height];
	
	          if (transform) {
	            applyTransform(p0, p0, transform);
	          }
	
	          width /= scale[0] * Z;
	          height /= scale[1] * Z;
	          var dimension = mathMax(width, height);
	          shift = 2 * 0 / dimension;
	          expansion = 2 * fill.r / dimension - shift;
	        } // We need to sort the color stops in ascending order by offset,
	        // otherwise IE won't interpret it correctly.
	
	
	        var stops = fill.colorStops.slice();
	        stops.sort(function (cs1, cs2) {
	          return cs1.offset - cs2.offset;
	        });
	        var length = stops.length; // Color and alpha list of first and last stop
	
	        var colorAndAlphaList = [];
	        var colors = [];
	
	        for (var i = 0; i < length; i++) {
	          var stop = stops[i];
	          var colorAndAlpha = getColorAndAlpha(stop.color);
	          colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);
	
	          if (i === 0 || i === length - 1) {
	            colorAndAlphaList.push(colorAndAlpha);
	          }
	        }
	
	        if (length >= 2) {
	          var color1 = colorAndAlphaList[0][0];
	          var color2 = colorAndAlphaList[1][0];
	          var opacity1 = colorAndAlphaList[0][1] * style.opacity;
	          var opacity2 = colorAndAlphaList[1][1] * style.opacity;
	          el.type = gradientType;
	          el.method = 'none';
	          el.focus = '100%';
	          el.angle = angle;
	          el.color = color1;
	          el.color2 = color2;
	          el.colors = colors.join(','); // When colors attribute is used, the meanings of opacity and o:opacity2
	          // are reversed.
	
	          el.opacity = opacity2; // FIXME g_o_:opacity ?
	
	          el.opacity2 = opacity1;
	        }
	
	        if (gradientType === 'radial') {
	          el.focusposition = focus.join(',');
	        }
	      } else {
	        // FIXME Change from Gradient fill to color fill
	        setColorAndOpacity(el, fill, style.opacity);
	      }
	    }
	  };
	
	  var updateStrokeNode = function (el, style) {
	    // if (style.lineJoin != null) {
	    //     el.joinstyle = style.lineJoin;
	    // }
	    // if (style.miterLimit != null) {
	    //     el.miterlimit = style.miterLimit * Z;
	    // }
	    // if (style.lineCap != null) {
	    //     el.endcap = style.lineCap;
	    // }
	    if (style.lineDash != null) {
	      el.dashstyle = style.lineDash.join(' ');
	    }
	
	    if (style.stroke != null && !(style.stroke instanceof Gradient)) {
	      setColorAndOpacity(el, style.stroke, style.opacity);
	    }
	  };
	
	  var updateFillAndStroke = function (vmlEl, type, style, zrEl) {
	    var isFill = type == 'fill';
	    var el = vmlEl.getElementsByTagName(type)[0]; // Stroke must have lineWidth
	
	    if (style[type] != null && style[type] !== 'none' && (isFill || !isFill && style.lineWidth)) {
	      vmlEl[isFill ? 'filled' : 'stroked'] = 'true'; // FIXME Remove before updating, or set `colors` will throw error
	
	      if (style[type] instanceof Gradient) {
	        remove(vmlEl, el);
	      }
	
	      if (!el) {
	        el = vmlCore.createNode(type);
	      }
	
	      isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);
	      append(vmlEl, el);
	    } else {
	      vmlEl[isFill ? 'filled' : 'stroked'] = 'false';
	      remove(vmlEl, el);
	    }
	  };
	
	  var points = [[], [], []];
	
	  var pathDataToString = function (path, m) {
	    var M = CMD.M;
	    var C = CMD.C;
	    var L = CMD.L;
	    var A = CMD.A;
	    var Q = CMD.Q;
	    var str = [];
	    var nPoint;
	    var cmdStr;
	    var cmd;
	    var i;
	    var xi;
	    var yi;
	    var data = path.data;
	    var dataLength = path.len();
	
	    for (i = 0; i < dataLength;) {
	      cmd = data[i++];
	      cmdStr = '';
	      nPoint = 0;
	
	      switch (cmd) {
	        case M:
	          cmdStr = ' m ';
	          nPoint = 1;
	          xi = data[i++];
	          yi = data[i++];
	          points[0][0] = xi;
	          points[0][1] = yi;
	          break;
	
	        case L:
	          cmdStr = ' l ';
	          nPoint = 1;
	          xi = data[i++];
	          yi = data[i++];
	          points[0][0] = xi;
	          points[0][1] = yi;
	          break;
	
	        case Q:
	        case C:
	          cmdStr = ' c ';
	          nPoint = 3;
	          var x1 = data[i++];
	          var y1 = data[i++];
	          var x2 = data[i++];
	          var y2 = data[i++];
	          var x3;
	          var y3;
	
	          if (cmd === Q) {
	            // Convert quadratic to cubic using degree elevation
	            x3 = x2;
	            y3 = y2;
	            x2 = (x2 + 2 * x1) / 3;
	            y2 = (y2 + 2 * y1) / 3;
	            x1 = (xi + 2 * x1) / 3;
	            y1 = (yi + 2 * y1) / 3;
	          } else {
	            x3 = data[i++];
	            y3 = data[i++];
	          }
	
	          points[0][0] = x1;
	          points[0][1] = y1;
	          points[1][0] = x2;
	          points[1][1] = y2;
	          points[2][0] = x3;
	          points[2][1] = y3;
	          xi = x3;
	          yi = y3;
	          break;
	
	        case A:
	          var x = 0;
	          var y = 0;
	          var sx = 1;
	          var sy = 1;
	          var angle = 0;
	
	          if (m) {
	            // Extract SRT from matrix
	            x = m[4];
	            y = m[5];
	            sx = sqrt(m[0] * m[0] + m[1] * m[1]);
	            sy = sqrt(m[2] * m[2] + m[3] * m[3]);
	            angle = Math.atan2(-m[1] / sy, m[0] / sx);
	          }
	
	          var cx = data[i++];
	          var cy = data[i++];
	          var rx = data[i++];
	          var ry = data[i++];
	          var startAngle = data[i++] + angle;
	          var endAngle = data[i++] + startAngle + angle; // FIXME
	          // var psi = data[i++];
	
	          i++;
	          var clockwise = data[i++];
	          var x0 = cx + cos(startAngle) * rx;
	          var y0 = cy + sin(startAngle) * ry;
	          var x1 = cx + cos(endAngle) * rx;
	          var y1 = cy + sin(endAngle) * ry;
	          var type = clockwise ? ' wa ' : ' at ';
	
	          if (Math.abs(x0 - x1) < 1e-4) {
	            // IE won't render arches drawn counter clockwise if x0 == x1.
	            if (Math.abs(endAngle - startAngle) > 1e-2) {
	              // Offset x0 by 1/80 of a pixel. Use something
	              // that can be represented in binary
	              if (clockwise) {
	                x0 += 270 / Z;
	              }
	            } else {
	              // Avoid case draw full circle
	              if (Math.abs(y0 - cy) < 1e-4) {
	                if (clockwise && x0 < cx || !clockwise && x0 > cx) {
	                  y1 -= 270 / Z;
	                } else {
	                  y1 += 270 / Z;
	                }
	              } else if (clockwise && y0 < cy || !clockwise && y0 > cy) {
	                x1 += 270 / Z;
	              } else {
	                x1 -= 270 / Z;
	              }
	            }
	          }
	
	          str.push(type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2));
	          xi = x1;
	          yi = y1;
	          break;
	
	        case CMD.R:
	          var p0 = points[0];
	          var p1 = points[1]; // x0, y0
	
	          p0[0] = data[i++];
	          p0[1] = data[i++]; // x1, y1
	
	          p1[0] = p0[0] + data[i++];
	          p1[1] = p0[1] + data[i++];
	
	          if (m) {
	            applyTransform(p0, p0, m);
	            applyTransform(p1, p1, m);
	          }
	
	          p0[0] = round(p0[0] * Z - Z2);
	          p1[0] = round(p1[0] * Z - Z2);
	          p0[1] = round(p0[1] * Z - Z2);
	          p1[1] = round(p1[1] * Z - Z2);
	          str.push( // x0, y0
	          ' m ', p0[0], comma, p0[1], // x1, y0
	          ' l ', p1[0], comma, p0[1], // x1, y1
	          ' l ', p1[0], comma, p1[1], // x0, y1
	          ' l ', p0[0], comma, p1[1]);
	          break;
	
	        case CMD.Z:
	          // FIXME Update xi, yi
	          str.push(' x ');
	      }
	
	      if (nPoint > 0) {
	        str.push(cmdStr);
	
	        for (var k = 0; k < nPoint; k++) {
	          var p = points[k];
	          m && applyTransform(p, p, m); // 不 round 会非常慢
	
	          str.push(round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k < nPoint - 1 ? comma : '');
	        }
	      }
	    }
	
	    return str.join('');
	  }; // Rewrite the original path method
	
	
	  Path.prototype.brushVML = function (vmlRoot) {
	    var style = this.style;
	    var vmlEl = this._vmlEl;
	
	    if (!vmlEl) {
	      vmlEl = vmlCore.createNode('shape');
	      initRootElStyle(vmlEl);
	      this._vmlEl = vmlEl;
	    }
	
	    updateFillAndStroke(vmlEl, 'fill', style, this);
	    updateFillAndStroke(vmlEl, 'stroke', style, this);
	    var m = this.transform;
	    var needTransform = m != null;
	    var strokeEl = vmlEl.getElementsByTagName('stroke')[0];
	
	    if (strokeEl) {
	      var lineWidth = style.lineWidth; // Get the line scale.
	      // Determinant of this.m_ means how much the area is enlarged by the
	      // transformation. So its square root can be used as a scale factor
	      // for width.
	
	      if (needTransform && !style.strokeNoScale) {
	        var det = m[0] * m[3] - m[1] * m[2];
	        lineWidth *= sqrt(abs(det));
	      }
	
	      strokeEl.weight = lineWidth + 'px';
	    }
	
	    var path = this.path || (this.path = new PathProxy());
	
	    if (this.__dirtyPath) {
	      path.beginPath();
	      this.buildPath(path, this.shape);
	      path.toStatic();
	      this.__dirtyPath = false;
	    }
	
	    vmlEl.path = pathDataToString(path, this.transform);
	    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root
	
	    append(vmlRoot, vmlEl); // Text
	
	    if (style.text != null) {
	      this.drawRectText(vmlRoot, this.getBoundingRect());
	    } else {
	      this.removeRectText(vmlRoot);
	    }
	  };
	
	  Path.prototype.onRemove = function (vmlRoot) {
	    remove(vmlRoot, this._vmlEl);
	    this.removeRectText(vmlRoot);
	  };
	
	  Path.prototype.onAdd = function (vmlRoot) {
	    append(vmlRoot, this._vmlEl);
	    this.appendRectText(vmlRoot);
	  };
	  /***************************************************
	   * IMAGE
	   **************************************************/
	
	
	  var isImage = function (img) {
	    // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错
	    return typeof img === 'object' && img.tagName && img.tagName.toUpperCase() === 'IMG'; // return img instanceof Image;
	  }; // Rewrite the original path method
	
	
	  ZImage.prototype.brushVML = function (vmlRoot) {
	    var style = this.style;
	    var image = style.image; // Image original width, height
	
	    var ow;
	    var oh;
	
	    if (isImage(image)) {
	      var src = image.src;
	
	      if (src === this._imageSrc) {
	        ow = this._imageWidth;
	        oh = this._imageHeight;
	      } else {
	        var imageRuntimeStyle = image.runtimeStyle;
	        var oldRuntimeWidth = imageRuntimeStyle.width;
	        var oldRuntimeHeight = imageRuntimeStyle.height;
	        imageRuntimeStyle.width = 'auto';
	        imageRuntimeStyle.height = 'auto'; // get the original size
	
	        ow = image.width;
	        oh = image.height; // and remove overides
	
	        imageRuntimeStyle.width = oldRuntimeWidth;
	        imageRuntimeStyle.height = oldRuntimeHeight; // Caching image original width, height and src
	
	        this._imageSrc = src;
	        this._imageWidth = ow;
	        this._imageHeight = oh;
	      }
	
	      image = src;
	    } else {
	      if (image === this._imageSrc) {
	        ow = this._imageWidth;
	        oh = this._imageHeight;
	      }
	    }
	
	    if (!image) {
	      return;
	    }
	
	    var x = style.x || 0;
	    var y = style.y || 0;
	    var dw = style.width;
	    var dh = style.height;
	    var sw = style.sWidth;
	    var sh = style.sHeight;
	    var sx = style.sx || 0;
	    var sy = style.sy || 0;
	    var hasCrop = sw && sh;
	    var vmlEl = this._vmlEl;
	
	    if (!vmlEl) {
	      // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。
	      // vmlEl = vmlCore.createNode('group');
	      vmlEl = vmlCore.doc.createElement('div');
	      initRootElStyle(vmlEl);
	      this._vmlEl = vmlEl;
	    }
	
	    var vmlElStyle = vmlEl.style;
	    var hasRotation = false;
	    var m;
	    var scaleX = 1;
	    var scaleY = 1;
	
	    if (this.transform) {
	      m = this.transform;
	      scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);
	      scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);
	      hasRotation = m[1] || m[2];
	    }
	
	    if (hasRotation) {
	      // If filters are necessary (rotation exists), create them
	      // filters are bog-slow, so only create them if abbsolutely necessary
	      // The following check doesn't account for skews (which don't exist
	      // in the canvas spec (yet) anyway.
	      // From excanvas
	      var p0 = [x, y];
	      var p1 = [x + dw, y];
	      var p2 = [x, y + dh];
	      var p3 = [x + dw, y + dh];
	      applyTransform(p0, p0, m);
	      applyTransform(p1, p1, m);
	      applyTransform(p2, p2, m);
	      applyTransform(p3, p3, m);
	      var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);
	      var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);
	      var transformFilter = [];
	      transformFilter.push('M11=', m[0] / scaleX, comma, 'M12=', m[2] / scaleY, comma, 'M21=', m[1] / scaleX, comma, 'M22=', m[3] / scaleY, comma, 'Dx=', round(x * scaleX + m[4]), comma, 'Dy=', round(y * scaleY + m[5]));
	      vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0'; // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用
	
	      vmlElStyle.filter = imageTransformPrefix + '.Matrix(' + transformFilter.join('') + ', SizingMethod=clip)';
	    } else {
	      if (m) {
	        x = x * scaleX + m[4];
	        y = y * scaleY + m[5];
	      }
	
	      vmlElStyle.filter = '';
	      vmlElStyle.left = round(x) + 'px';
	      vmlElStyle.top = round(y) + 'px';
	    }
	
	    var imageEl = this._imageEl;
	    var cropEl = this._cropEl;
	
	    if (!imageEl) {
	      imageEl = vmlCore.doc.createElement('div');
	      this._imageEl = imageEl;
	    }
	
	    var imageELStyle = imageEl.style;
	
	    if (hasCrop) {
	      // Needs know image original width and height
	      if (!(ow && oh)) {
	        var tmpImage = new Image();
	        var self = this;
	
	        tmpImage.onload = function () {
	          tmpImage.onload = null;
	          ow = tmpImage.width;
	          oh = tmpImage.height; // Adjust image width and height to fit the ratio destinationSize / sourceSize
	
	          imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
	          imageELStyle.height = round(scaleY * oh * dh / sh) + 'px'; // Caching image original width, height and src
	
	          self._imageWidth = ow;
	          self._imageHeight = oh;
	          self._imageSrc = image;
	        };
	
	        tmpImage.src = image;
	      } else {
	        imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
	        imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';
	      }
	
	      if (!cropEl) {
	        cropEl = vmlCore.doc.createElement('div');
	        cropEl.style.overflow = 'hidden';
	        this._cropEl = cropEl;
	      }
	
	      var cropElStyle = cropEl.style;
	      cropElStyle.width = round((dw + sx * dw / sw) * scaleX);
	      cropElStyle.height = round((dh + sy * dh / sh) * scaleY);
	      cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx=' + -sx * dw / sw * scaleX + ',Dy=' + -sy * dh / sh * scaleY + ')';
	
	      if (!cropEl.parentNode) {
	        vmlEl.appendChild(cropEl);
	      }
	
	      if (imageEl.parentNode != cropEl) {
	        cropEl.appendChild(imageEl);
	      }
	    } else {
	      imageELStyle.width = round(scaleX * dw) + 'px';
	      imageELStyle.height = round(scaleY * dh) + 'px';
	      vmlEl.appendChild(imageEl);
	
	      if (cropEl && cropEl.parentNode) {
	        vmlEl.removeChild(cropEl);
	        this._cropEl = null;
	      }
	    }
	
	    var filterStr = '';
	    var alpha = style.opacity;
	
	    if (alpha < 1) {
	      filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';
	    }
	
	    filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';
	    imageELStyle.filter = filterStr;
	    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root
	
	    append(vmlRoot, vmlEl); // Text
	
	    if (style.text != null) {
	      this.drawRectText(vmlRoot, this.getBoundingRect());
	    }
	  };
	
	  ZImage.prototype.onRemove = function (vmlRoot) {
	    remove(vmlRoot, this._vmlEl);
	    this._vmlEl = null;
	    this._cropEl = null;
	    this._imageEl = null;
	    this.removeRectText(vmlRoot);
	  };
	
	  ZImage.prototype.onAdd = function (vmlRoot) {
	    append(vmlRoot, this._vmlEl);
	    this.appendRectText(vmlRoot);
	  };
	  /***************************************************
	   * TEXT
	   **************************************************/
	
	
	  var DEFAULT_STYLE_NORMAL = 'normal';
	  var fontStyleCache = {};
	  var fontStyleCacheCount = 0;
	  var MAX_FONT_CACHE_SIZE = 100;
	  var fontEl = document.createElement('div');
	
	  var getFontStyle = function (fontString) {
	    var fontStyle = fontStyleCache[fontString];
	
	    if (!fontStyle) {
	      // Clear cache
	      if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {
	        fontStyleCacheCount = 0;
	        fontStyleCache = {};
	      }
	
	      var style = fontEl.style;
	      var fontFamily;
	
	      try {
	        style.font = fontString;
	        fontFamily = style.fontFamily.split(',')[0];
	      } catch (e) {}
	
	      fontStyle = {
	        style: style.fontStyle || DEFAULT_STYLE_NORMAL,
	        variant: style.fontVariant || DEFAULT_STYLE_NORMAL,
	        weight: style.fontWeight || DEFAULT_STYLE_NORMAL,
	        size: parseFloat(style.fontSize || 12) | 0,
	        family: fontFamily || 'Microsoft YaHei'
	      };
	      fontStyleCache[fontString] = fontStyle;
	      fontStyleCacheCount++;
	    }
	
	    return fontStyle;
	  };
	
	  var textMeasureEl; // Overwrite measure text method
	
	  textContain.$override('measureText', function (text, textFont) {
	    var doc = vmlCore.doc;
	
	    if (!textMeasureEl) {
	      textMeasureEl = doc.createElement('div');
	      textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;' + 'padding:0;margin:0;border:none;white-space:pre;';
	      vmlCore.doc.body.appendChild(textMeasureEl);
	    }
	
	    try {
	      textMeasureEl.style.font = textFont;
	    } catch (ex) {// Ignore failures to set to invalid font.
	    }
	
	    textMeasureEl.innerHTML = ''; // Don't use innerHTML or innerText because they allow markup/whitespace.
	
	    textMeasureEl.appendChild(doc.createTextNode(text));
	    return {
	      width: textMeasureEl.offsetWidth
	    };
	  });
	  var tmpRect = new BoundingRect();
	
	  var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {
	    var style = this.style; // Optimize, avoid normalize every time.
	
	    this.__dirty && textHelper.normalizeTextStyle(style, true);
	    var text = style.text; // Convert to string
	
	    text != null && (text += '');
	
	    if (!text) {
	      return;
	    } // Convert rich text to plain text. Rich text is not supported in
	    // IE8-, but tags in rich text template will be removed.
	
	
	    if (style.rich) {
	      var contentBlock = textContain.parseRichText(text, style);
	      text = [];
	
	      for (var i = 0; i < contentBlock.lines.length; i++) {
	        var tokens = contentBlock.lines[i].tokens;
	        var textLine = [];
	
	        for (var j = 0; j < tokens.length; j++) {
	          textLine.push(tokens[j].text);
	        }
	
	        text.push(textLine.join(''));
	      }
	
	      text = text.join('\n');
	    }
	
	    var x;
	    var y;
	    var align = style.textAlign;
	    var verticalAlign = style.textVerticalAlign;
	    var fontStyle = getFontStyle(style.font); // FIXME encodeHtmlAttribute ?
	
	    var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' ' + fontStyle.size + 'px "' + fontStyle.family + '"';
	    textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign); // Transform rect to view space
	
	    var m = this.transform; // Ignore transform for text in other element
	
	    if (m && !fromTextEl) {
	      tmpRect.copy(rect);
	      tmpRect.applyTransform(m);
	      rect = tmpRect;
	    }
	
	    if (!fromTextEl) {
	      var textPosition = style.textPosition;
	      var distance = style.textDistance; // Text position represented by coord
	
	      if (textPosition instanceof Array) {
	        x = rect.x + parsePercent(textPosition[0], rect.width);
	        y = rect.y + parsePercent(textPosition[1], rect.height);
	        align = align || 'left';
	      } else {
	        var res = textContain.adjustTextPositionOnRect(textPosition, rect, distance);
	        x = res.x;
	        y = res.y; // Default align and baseline when has textPosition
	
	        align = align || res.textAlign;
	        verticalAlign = verticalAlign || res.textVerticalAlign;
	      }
	    } else {
	      x = rect.x;
	      y = rect.y;
	    }
	
	    x = textContain.adjustTextX(x, textRect.width, align);
	    y = textContain.adjustTextY(y, textRect.height, verticalAlign); // Force baseline 'middle'
	
	    y += textRect.height / 2; // var fontSize = fontStyle.size;
	    // 1.75 is an arbitrary number, as there is no info about the text baseline
	    // switch (baseline) {
	    // case 'hanging':
	    // case 'top':
	    //     y += fontSize / 1.75;
	    //     break;
	    //     case 'middle':
	    //         break;
	    //     default:
	    //     // case null:
	    //     // case 'alphabetic':
	    //     // case 'ideographic':
	    //     // case 'bottom':
	    //         y -= fontSize / 2.25;
	    //         break;
	    // }
	    // switch (align) {
	    //     case 'left':
	    //         break;
	    //     case 'center':
	    //         x -= textRect.width / 2;
	    //         break;
	    //     case 'right':
	    //         x -= textRect.width;
	    //         break;
	    // case 'end':
	    // align = elementStyle.direction == 'ltr' ? 'right' : 'left';
	    // break;
	    // case 'start':
	    // align = elementStyle.direction == 'rtl' ? 'right' : 'left';
	    // break;
	    // default:
	    //     align = 'left';
	    // }
	
	    var createNode = vmlCore.createNode;
	    var textVmlEl = this._textVmlEl;
	    var pathEl;
	    var textPathEl;
	    var skewEl;
	
	    if (!textVmlEl) {
	      textVmlEl = createNode('line');
	      pathEl = createNode('path');
	      textPathEl = createNode('textpath');
	      skewEl = createNode('skew'); // FIXME Why here is not cammel case
	      // Align 'center' seems wrong
	
	      textPathEl.style['v-text-align'] = 'left';
	      initRootElStyle(textVmlEl);
	      pathEl.textpathok = true;
	      textPathEl.on = true;
	      textVmlEl.from = '0 0';
	      textVmlEl.to = '1000 0.05';
	      append(textVmlEl, skewEl);
	      append(textVmlEl, pathEl);
	      append(textVmlEl, textPathEl);
	      this._textVmlEl = textVmlEl;
	    } else {
	      // 这里是在前面 appendChild 保证顺序的前提下
	      skewEl = textVmlEl.firstChild;
	      pathEl = skewEl.nextSibling;
	      textPathEl = pathEl.nextSibling;
	    }
	
	    var coords = [x, y];
	    var textVmlElStyle = textVmlEl.style; // Ignore transform for text in other element
	
	    if (m && fromTextEl) {
	      applyTransform(coords, coords, m);
	      skewEl.on = true;
	      skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0'; // Text position
	
	      skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0); // Left top point as origin
	
	      skewEl.origin = '0 0';
	      textVmlElStyle.left = '0px';
	      textVmlElStyle.top = '0px';
	    } else {
	      skewEl.on = false;
	      textVmlElStyle.left = round(x) + 'px';
	      textVmlElStyle.top = round(y) + 'px';
	    }
	
	    textPathEl.string = encodeHtmlAttribute(text); // TODO
	
	    try {
	      textPathEl.style.font = font;
	    } // Error font format
	    catch (e) {}
	
	    updateFillAndStroke(textVmlEl, 'fill', {
	      fill: style.textFill,
	      opacity: style.opacity
	    }, this);
	    updateFillAndStroke(textVmlEl, 'stroke', {
	      stroke: style.textStroke,
	      opacity: style.opacity,
	      lineDash: style.lineDash
	    }, this);
	    textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Attached to root
	
	    append(vmlRoot, textVmlEl);
	  };
	
	  var removeRectText = function (vmlRoot) {
	    remove(vmlRoot, this._textVmlEl);
	    this._textVmlEl = null;
	  };
	
	  var appendRectText = function (vmlRoot) {
	    append(vmlRoot, this._textVmlEl);
	  };
	
	  var list = [RectText, Displayable, ZImage, Path, Text]; // In case Displayable has been mixed in RectText
	
	  for (var i = 0; i < list.length; i++) {
	    var proto = list[i].prototype;
	    proto.drawRectText = drawRectText;
	    proto.removeRectText = removeRectText;
	    proto.appendRectText = appendRectText;
	  }
	
	  Text.prototype.brushVML = function (vmlRoot) {
	    var style = this.style;
	
	    if (style.text != null) {
	      this.drawRectText(vmlRoot, {
	        x: style.x || 0,
	        y: style.y || 0,
	        width: 0,
	        height: 0
	      }, this.getBoundingRect(), true);
	    } else {
	      this.removeRectText(vmlRoot);
	    }
	  };
	
	  Text.prototype.onRemove = function (vmlRoot) {
	    this.removeRectText(vmlRoot);
	  };
	
	  Text.prototype.onAdd = function (vmlRoot) {
	    this.appendRectText(vmlRoot);
	  };
	}

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	var env = __webpack_require__(5);
	
	var urn = 'urn:schemas-microsoft-com:vml';
	var win = typeof window === 'undefined' ? null : window;
	var vmlInited = false;
	var doc = win && win.document;
	
	function createNode(tagName) {
	  return doCreateNode(tagName);
	} // Avoid assign to an exported variable, for transforming to cjs.
	
	
	var doCreateNode;
	
	if (doc && !env.canvasSupported) {
	  try {
	    !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);
	
	    doCreateNode = function (tagName) {
	      return doc.createElement('<zrvml:' + tagName + ' class="zrvml">');
	    };
	  } catch (e) {
	    doCreateNode = function (tagName) {
	      return doc.createElement('<' + tagName + ' xmlns="' + urn + '" class="zrvml">');
	    };
	  }
	} // From raphael
	
	
	function initVML() {
	  if (vmlInited || !doc) {
	    return;
	  }
	
	  vmlInited = true;
	  var styleSheets = doc.styleSheets;
	
	  if (styleSheets.length < 31) {
	    doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');
	  } else {
	    // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx
	    styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');
	  }
	}
	
	exports.doc = doc;
	exports.createNode = createNode;
	exports.initVML = initVML;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	var zrLog = __webpack_require__(22);
	
	var vmlCore = __webpack_require__(84);
	
	var _util = __webpack_require__(6);
	
	var each = _util.each;
	
	/**
	 * VML Painter.
	 *
	 * @module zrender/vml/Painter
	 */
	function parseInt10(val) {
	  return parseInt(val, 10);
	}
	/**
	 * @alias module:zrender/vml/Painter
	 */
	
	
	function VMLPainter(root, storage) {
	  vmlCore.initVML();
	  this.root = root;
	  this.storage = storage;
	  var vmlViewport = document.createElement('div');
	  var vmlRoot = document.createElement('div');
	  vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';
	  vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';
	  root.appendChild(vmlViewport);
	  this._vmlRoot = vmlRoot;
	  this._vmlViewport = vmlViewport;
	  this.resize(); // Modify storage
	
	  var oldDelFromStorage = storage.delFromStorage;
	  var oldAddToStorage = storage.addToStorage;
	
	  storage.delFromStorage = function (el) {
	    oldDelFromStorage.call(storage, el);
	
	    if (el) {
	      el.onRemove && el.onRemove(vmlRoot);
	    }
	  };
	
	  storage.addToStorage = function (el) {
	    // Displayable already has a vml node
	    el.onAdd && el.onAdd(vmlRoot);
	    oldAddToStorage.call(storage, el);
	  };
	
	  this._firstPaint = true;
	}
	
	VMLPainter.prototype = {
	  constructor: VMLPainter,
	  getType: function () {
	    return 'vml';
	  },
	
	  /**
	   * @return {HTMLDivElement}
	   */
	  getViewportRoot: function () {
	    return this._vmlViewport;
	  },
	  getViewportRootOffset: function () {
	    var viewportRoot = this.getViewportRoot();
	
	    if (viewportRoot) {
	      return {
	        offsetLeft: viewportRoot.offsetLeft || 0,
	        offsetTop: viewportRoot.offsetTop || 0
	      };
	    }
	  },
	
	  /**
	   * 刷新
	   */
	  refresh: function () {
	    var list = this.storage.getDisplayList(true, true);
	
	    this._paintList(list);
	  },
	  _paintList: function (list) {
	    var vmlRoot = this._vmlRoot;
	
	    for (var i = 0; i < list.length; i++) {
	      var el = list[i];
	
	      if (el.invisible || el.ignore) {
	        if (!el.__alreadyNotVisible) {
	          el.onRemove(vmlRoot);
	        } // Set as already invisible
	
	
	        el.__alreadyNotVisible = true;
	      } else {
	        if (el.__alreadyNotVisible) {
	          el.onAdd(vmlRoot);
	        }
	
	        el.__alreadyNotVisible = false;
	
	        if (el.__dirty) {
	          el.beforeBrush && el.beforeBrush();
	          (el.brushVML || el.brush).call(el, vmlRoot);
	          el.afterBrush && el.afterBrush();
	        }
	      }
	
	      el.__dirty = false;
	    }
	
	    if (this._firstPaint) {
	      // Detached from document at first time
	      // to avoid page refreshing too many times
	      // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变
	      this._vmlViewport.appendChild(vmlRoot);
	
	      this._firstPaint = false;
	    }
	  },
	  resize: function (width, height) {
	    var width = width == null ? this._getWidth() : width;
	    var height = height == null ? this._getHeight() : height;
	
	    if (this._width != width || this._height != height) {
	      this._width = width;
	      this._height = height;
	      var vmlViewportStyle = this._vmlViewport.style;
	      vmlViewportStyle.width = width + 'px';
	      vmlViewportStyle.height = height + 'px';
	    }
	  },
	  dispose: function () {
	    this.root.innerHTML = '';
	    this._vmlRoot = this._vmlViewport = this.storage = null;
	  },
	  getWidth: function () {
	    return this._width;
	  },
	  getHeight: function () {
	    return this._height;
	  },
	  clear: function () {
	    if (this._vmlViewport) {
	      this.root.removeChild(this._vmlViewport);
	    }
	  },
	  _getWidth: function () {
	    var root = this.root;
	    var stl = root.currentStyle;
	    return (root.clientWidth || parseInt10(stl.width)) - parseInt10(stl.paddingLeft) - parseInt10(stl.paddingRight) | 0;
	  },
	  _getHeight: function () {
	    var root = this.root;
	    var stl = root.currentStyle;
	    return (root.clientHeight || parseInt10(stl.height)) - parseInt10(stl.paddingTop) - parseInt10(stl.paddingBottom) | 0;
	  }
	}; // Not supported methods
	
	function createMethodNotSupport(method) {
	  return function () {
	    zrLog('In IE8.0 VML mode painter not support method "' + method + '"');
	  };
	} // Unsupported methods
	
	
	each(['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'], function (name) {
	  VMLPainter.prototype[name] = createMethodNotSupport(name);
	});
	var _default = VMLPainter;
	module.exports = _default;

/***/ })
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBmMTlkZGE4OWJkYzQ3MTBjOTVmNyIsIndlYnBhY2s6Ly8vLi9pbmRleC5iby5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJvL2xpYi9GaXNoVG9wb0JvLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvenJlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvZ3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvZW52LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS91dGlsLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvSGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvbWl4aW4vRHJhZ2dhYmxlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9TdG9yYWdlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL21peGluL1RyYW5zZm9ybWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL21hdHJpeC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL21peGluL0FuaW1hdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQ2xpcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9lYXNpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi90b29sL2NvbG9yLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9MUlUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL2xvZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS90aW1zb3J0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvUGFpbnRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL0xheWVyLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9TdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0dGVybi5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvbWl4aW4vUmVjdFRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci90ZXh0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi90ZXh0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvaW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9yb3VuZFJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0aW9uLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2RvbS9IYW5kbGVyUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL0dlc3R1cmVNZ3IuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1iby9saWIvbm9kZS9Cb05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1iby9saWIvbW9kZWxzL0NvbnN0LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYm8vbGliL25vZGUvQm9OYW1lLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvUGF0aFByb3h5LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9jdXJ2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvYmJveC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vbGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vY3ViaWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL3F1YWRyYXRpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vYXJjLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi91dGlsLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi93aW5kaW5nTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3Rvb2wvdHJhbnNmb3JtUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvR3JhZGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1RleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0NpcmNsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvU2VjdG9yLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvZml4Q2xpcFdpdGhTaGFkb3cuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlnb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9wb2x5LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoU3BsaW5lLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoQmV6aWVyLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0FyYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9TdGF0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1iby9saWIvbm9kZS9FdmVudERlY2lzaW9uTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJvL2xpYi9ub2RlL0xpbmVOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYm8vbGliL25vZGUvQm9BdHRyTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJvL2xpYi9ub2RlL1JlbGF0aW9uLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvb2JqZWN0QXNzaWduUG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi92bWwvdm1sLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvdm1sL2dyYXBoaWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi92bWwvY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3ZtbC9QYWludGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FB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UUFBTztBQUNQOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQjs7Ozs7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVEsWUFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWUsYUFBYTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCLGFBQWE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCLGFBQWE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBcUIsWUFBWTtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLE9BQU07QUFDTixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxjQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFtQiwrQkFBK0I7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYSxzQkFBc0I7QUFDbkMsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxjQUFhLGNBQWM7QUFDM0IsY0FBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGVBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLHVCQUF1QjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFlLCtCQUErQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7QUFHRDtBQUNBO0FBQ0EsMkI7Ozs7OztBQzliQTtBQUNBO0FBQ0EsMEJBQXlCLFdBQVc7QUFDcEM7QUFDQSx3QkFBdUI7O0FBRXZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkI7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCOzs7Ozs7QUNMQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBLGdDQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQjs7Ozs7O0FDMUZBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjs7O0FBR0E7QUFDQSxxQkFBb0I7O0FBRXBCLHlCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0EsaUNBQWdDO0FBQ2hDLGdDQUErQjs7QUFFL0I7QUFDQTtBQUNBLGNBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQSxtQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBLGtDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCLGVBQWMsT0FBTztBQUNyQixlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGVBQWMsU0FBUztBQUN2QixnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCLGVBQWMsT0FBTztBQUNyQixlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0EsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxjQUFhLGNBQWM7QUFDM0IsY0FBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGVBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQW9DOztBQUVwQztBQUNBLDJCOzs7Ozs7QUN4UEE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjLHlCQUF5QjtBQUN2QyxlQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0EsbUNBQWtDOztBQUVsQztBQUNBLDJCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBLE1BQUs7OztBQUdMLGdCQUFlOztBQUVmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQjs7Ozs7O0FDdERBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLDZCQUE2QjtBQUN4QyxhQUFZLDZCQUE2QjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNEY7O0FBRTVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcseUJBQXlCO0FBQ3BDLFlBQVcsT0FBTztBQUNsQixZQUFXLDZCQUE2QjtBQUN4QyxZQUFXLGVBQWUsU0FBUztBQUNuQztBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWdEO0FBQ2hEOztBQUVBLHlDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0EsOERBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7O0FBR0w7O0FBRUE7QUFDQSxpQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLHlCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFxRjs7QUFFckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDLFlBQVk7QUFDYixZQUFXOzs7QUFHWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBa0Q7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFvQjs7QUFFcEI7QUFDQTtBQUNBLE1BQUs7QUFDTDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcscUJBQXFCO0FBQ2hDLGFBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7Ozs7OztBQ2xiQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixxQkFBcUIsS0FBSztBQUM3QyxzQ0FBcUM7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGFBQVksT0FBTztBQUNuQjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxlQUFlO0FBQzFCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsYUFBWSxPQUFPLEVBQUU7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixhQUFZLE9BQU87QUFDbkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixhQUFZLE9BQU87QUFDbkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTyxPQUFPO0FBQ3pCLFlBQVcsT0FBTztBQUNsQixhQUFZLE9BQU8sRUFBRTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGFBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2RUFBNEU7QUFDNUU7O0FBRUEsMENBQXlDLFNBQVM7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlFQUFnRTtBQUNoRTs7QUFFQSw2Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQSw0REFBMkQ7QUFDM0Q7O0FBRUEsdUVBQXNFOztBQUV0RSxrQkFBaUIsNkNBQTZDO0FBQzlEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE2QixpQ0FBaUM7QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVksT0FBTztBQUNuQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixhQUFZLE9BQU87QUFDbkI7OztBQUdBO0FBQ0E7QUFDQSxFQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGFBQVksT0FBTyxTQUFTO0FBQzVCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFPLEVBQUU7QUFDVDs7QUFFQSwwQ0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLFlBQVksV0FBVyxZQUFZLElBQUksR0FBRztBQUN0RSx3QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixhQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7O0FBR0gsa0JBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLHdCQUF3QjtBQUMzQztBQUNBLDZFQUE0RTs7QUFFNUUsb0VBQW1FOztBQUVuRSw2REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdGQUErRTtBQUMvRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUI7QUFDdkI7QUFDQSxRQUFPO0FBQ1A7QUFDQSx3Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQSx3RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCLHdCQUF3QjtBQUN6QztBQUNBLDJDQUEwQzs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsUUFBTyxVQUFVO0FBQ2pCO0FBQ0E7QUFDQSxrREFBaUQsR0FBRztBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Qjs7Ozs7O0FDOXFCQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxpREFBaUQ7QUFDNUQsYUFBWSwwQ0FBMEM7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLGlEQUFpRDtBQUM1RCxZQUFXLDBDQUEwQztBQUNyRCxZQUFXLHVCQUF1QjtBQUNsQyxZQUFXLFNBQVM7QUFDcEIsWUFBVyxPQUFPO0FBQ2xCLGFBQVksMENBQTBDO0FBQ3REOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCLGlDQUFpQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQzs7Ozs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCOzs7Ozs7QUNoRkE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGVBQWMsU0FBUztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBbUQ7OztBQUduRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWEsOEJBQThCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGNBQWEsa0NBQWtDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGNBQWEsOEJBQThCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxjQUFhLGtDQUFrQztBQUMvQztBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLGtCQUFrQjtBQUNyQztBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsU0FBUztBQUM1QjtBQUNBLHNDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7OztBQUdMLG9CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCLGVBQWMsT0FBTztBQUNyQixlQUFjLFFBQVE7QUFDdEIsZUFBYyxTQUFTO0FBQ3ZCO0FBQ0EsZUFBYyxTQUFTO0FBQ3ZCO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQjs7Ozs7O0FDN09BOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHLG9DQUFvQyxjQUFjLGFBQWE7QUFDbEU7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQzs7Ozs7O0FDcEpBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQSwwQ0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBLDZDQUE0QztBQUM1Qzs7QUFFQTtBQUNBLDJDQUEwQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGNBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0EsNkNBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQSw2Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLHVCQUF1QjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLDhDQUE2QztBQUM3QztBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQjs7Ozs7O0FDNVVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBeUMsU0FBUztBQUNsRDtBQUNBLHdEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBNkM7QUFDN0MsOENBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLDJCOzs7Ozs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0EsNEJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFrQzs7QUFFbEMsd0JBQXVCLGdCQUFnQjtBQUN2QztBQUNBLDhEQUE2RDtBQUM3RDtBQUNBO0FBQ0EsZ0VBQStEO0FBQy9EOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTs7QUFFQTs7Ozs7Ozs7QUN2V0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0Isc0JBQXNCO0FBQ3RDLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQSxjQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQ3hDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxpQ0FBaUM7QUFDaEQsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSw0QkFBNEI7QUFDM0MsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxTQUFTO0FBQ3hCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLHVCQUF1QjtBQUN0QyxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSwyQkFBMkI7QUFDMUMsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsdUJBQXVCO0FBQ3RDLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsMkJBQTJCO0FBQzFDLGdCQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsdUJBQXVCO0FBQ3RDLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsMkJBQTJCO0FBQzFDLGdCQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLG1DQUFtQztBQUNsRCxnQkFBZSxtQ0FBbUM7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLGVBQWU7QUFDOUIsZ0JBQWUsZUFBZTtBQUM5QixnQkFBZSxTQUFTO0FBQ3hCLGlCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxlQUFlO0FBQzlCLGdCQUFlLFNBQVM7QUFDeEIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ3JjQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7O0FBR0g7QUFDQSxTQUFROztBQUVSLGNBQWEsZUFBZTtBQUM1QjtBQUNBLElBQUc7OztBQUdILDJCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsY0FBYztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW1DOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLGtCQUFpQixTQUFTO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQ0FBa0M7O0FBRWxDOztBQUVBO0FBQ0EsK0JBQThCOztBQUU5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQjs7Ozs7O0FDeFpBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF3Qzs7QUFFeEM7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLG1EQUFrRDtBQUNsRDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQWtDOztBQUVsQyxpQ0FBZ0M7O0FBRWhDLHVFQUFzRTs7QUFFdEU7QUFDQTtBQUNBLFVBQVM7QUFDVDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7O0FBR1A7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUVBQXNFOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0EsZUFBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxjQUFhLGNBQWM7QUFDM0IsY0FBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBLDRCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsU0FBUztBQUNwQixZQUFXLFNBQVM7QUFDcEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCOzs7Ozs7QUM1VkE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsZUFBYyx5QkFBeUI7QUFDdkMsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDOztBQUVoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCLGVBQWMsT0FBTztBQUNyQixlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EseUNBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGVBQWMsT0FBTztBQUNyQixlQUFjLE9BQU87QUFDckIsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGVBQWMsT0FBTztBQUNyQixlQUFjLE9BQU87QUFDckIsZUFBYyxPQUFPO0FBQ3JCLGVBQWMsT0FBTztBQUNyQixlQUFjLE9BQU87QUFDckIsZUFBYyxPQUFPO0FBQ3JCLGVBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxlQUFjLE9BQU87QUFDckIsZUFBYyxPQUFPO0FBQ3JCLGVBQWMsT0FBTztBQUNyQixlQUFjLE9BQU87QUFDckIsZUFBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGVBQWMsT0FBTztBQUNyQixlQUFjLE9BQU87QUFDckIsZUFBYyxPQUFPO0FBQ3JCLGVBQWMsT0FBTztBQUNyQixlQUFjLE9BQU87QUFDckIsZUFBYyxRQUFRO0FBQ3RCLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGNBQWEseUJBQXlCO0FBQ3RDLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxjQUFhLHlCQUF5QjtBQUN0QyxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCLHFCQUFxQjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFtQixTQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxjQUFhLG9FQUFvRTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsU0FBUztBQUM1Qjs7QUFFQSxzQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFtQixzQkFBc0I7QUFDekM7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBcUIsZUFBZTtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBc0I7O0FBRXRCLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7O0FBR0wsV0FBVSxhQUFhO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsaUJBQWlCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWdEOztBQUVoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQzs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87OztBQUdQO0FBQ0E7QUFDQSxNQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGNBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsU0FBUztBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkI7Ozs7OztBQzF2QkE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjs7QUFFdEI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxlQUFlO0FBQzNCLGFBQVksT0FBTztBQUNuQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLHVCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLDJCQUEwQjs7QUFFMUIsdUJBQXNCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLGVBQWU7QUFDM0IsYUFBWSxPQUFPO0FBQ25COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLGVBQWU7QUFDM0I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsZUFBZTtBQUMxQixhQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiOztBQUVBLG1CQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFlOztBQUVmLGtCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksZUFBZTtBQUMzQixhQUFZLE9BQU87QUFDbkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWTtBQUNaOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxlQUFlO0FBQzNCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQSxpQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLGVBQWU7QUFDMUIsYUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUEsbUJBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWU7O0FBRWYsa0JBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQSxJQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RDs7Ozs7O0FDbmhCQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxjQUFjO0FBQ3pCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLGVBQWU7QUFDMUIsWUFBVyxlQUFlO0FBQzFCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxlQUFlO0FBQzFCLFlBQVcsZUFBZTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLGVBQWU7QUFDMUIsWUFBVyxlQUFlO0FBQzFCOzs7QUFHQTtBQUNBO0FBQ0EsdUNBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLGVBQWU7QUFDMUIsWUFBVyxlQUFlO0FBQzFCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkI7O0FBRTNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOzs7QUFHQSxzQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQjs7Ozs7O0FDNU5BOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLFlBQVk7QUFDL0Isd0JBQXVCOztBQUV2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFpQixPQUFPO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCLGlCQUFpQjtBQUNsQyx5QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0EsNENBQTJDOztBQUUzQztBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7OztBQUdUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxrREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztB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Q0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVELDJCOzs7Ozs7QUN2QkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVELDJCOzs7Ozs7QUN2Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGVBQWMsT0FBTztBQUNyQixlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQsMkI7Ozs7OztBQ3JEQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBLG1CQUFrQjtBQUNsQjtBQUNBLDRCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQXlD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QTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBLG9CQUFtQixpQkFBaUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7O0FBR1Q7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQSwyQiIsImZpbGUiOiJmaXNoVG9wb0JvLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiZmlzaFRvcG9Cb1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJmaXNoVG9wb0JvXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGYxOWRkYTg5YmRjNDcxMGM5NWY3IiwiLyoqXHJcbiAqIEV4cG9ydCBmaXNoVG9wbyBhcyBDb21tb25KUyBtb2R1bGVcclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvZmlzaC10b3BvLWJvL2xpYi9GaXNoVG9wb0JvLmpzJyk7XHJcbi8v5YW85a65SUU4IOW8leWFpVZNTCDlpoLmnpzkuI3pnIDopoHlhbzlrrlJRTjor7fliKDpmaRcclxucmVxdWlyZSgnenJlbmRlci9saWIvdm1sL3ZtbCcpO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbmRleC5iby5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQ3JlYXRlZCBieSBtYWppYW5hbiBvbiAxNi81LzE5LlxyXG4gKlxyXG4gKi9cclxuXHJcbiAgICB2YXIgenIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi96cmVuZGVyJyk7XHJcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIEJvTm9kZSA9IHJlcXVpcmUoJy4vbm9kZS9Cb05vZGUnKTtcclxuICAgIHZhciBSZWxhdGlvbiA9IHJlcXVpcmUoJy4vbm9kZS9SZWxhdGlvbicpO1xyXG4gICAgdmFyIENvbnN0ID0gcmVxdWlyZSgnLi9tb2RlbHMvQ29uc3QnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZXZlbnQnKTtcclxuICAgIHJlcXVpcmUoJy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9vYmplY3RBc3NpZ25Qb2x5ZmlsbC5qcycpO1xyXG5cclxuICAgIGZ1bmN0aW9uIEZpc2hUb3BvQm8oZG9tLCBvcHRzKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog57yp5pS+XHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm5vd1pvb20gPSAxO1xyXG4gICAgICAgIHRoaXMuY2FuU2NhbGUgPSB0cnVlO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDliJ3lp4vljJZ6cmVuZGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fenIgPSB6ci5pbml0KGRvbSwge1xyXG4gICAgICAgICAgICByZW5kZXJlcjogb3B0cy5yZW5kZXJlciB8fCAnY2FudmFzJyxcclxuICAgICAgICAgICAgZGV2aWNlUGl4ZWxSYXRpbzogb3B0cy5kZXZpY2VQaXhlbFJhdGlvXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZpc2hUb3BvUHJvdG8gPSBGaXNoVG9wb0JvLnByb3RvdHlwZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIneWni+WMllxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XHJcbiAgICAgICAgdGhpcy5ncm91cERyYWcodGhpcy5ncm91cCk7XHJcbiAgICAgICAgdGhpcy5fenIuYWRkKHRoaXMuZ3JvdXApO1xyXG4gICAgICAgIHRoaXMuenJTY2FsZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOiwg+aVtOWwuuWvuCAg5Zyo56qX5Y+j5aSn5bCP5Y+R55Sf5pS55Y+Y5pe26ZyA6KaB5omL5bel6LCD55SoXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8ucmVzaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX3pyLnJlc2l6ZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOa3u+WKoEJPXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYm9EYXRhLCBib+aVsOaNrlxyXG4gICAgICogQHBhcmFtIHt7XHJcbiAgICAgKiAgICAgICAgICBzdGFydFBvczoge3g6IG51bWJlciwgeTogbnVtYmVyfSDotbflp4vkvY3nva4sXHJcbiAgICAgKiAgICAgICAgICBkaXNwbGF5QXR0ckRhdGFUeXBlOiBib29sZWFuIOaYr+WQpuaYvuekuuWxnuaAp+aVsOaNruexu+WeiyxcclxuICAgICAqICAgICAgICAgIGRpc3BsYXlBdHRyRXZlbnQ6IGJvb2xlYW4g5piv5ZCm5pi+56S65bGe5oCn5LqL5Lu25Yaz562WLFxyXG4gICAgICogICAgICAgICAgYm9DbGlja2FibGU6IGJvb2xlYW4gQk/mmK/lkKbmlK/mjIHngrnlh7vkuovku7YsIOWPr+epuiDpu5jorqRmYWxzZVxyXG4gICAgICogICAgICAgICAgYm9Qb3B1cFVybDogU3RyaW5nIOeCueWHu0JP5by55Ye66aG16Z2i5Zyw5Z2AXHJcbiAgICAgKiAgICAgICAgICBib0V2ZW50Q2xpY2thYmxlOiBib29sZWFuIEJP5LqL5Lu25Yaz562W5piv5ZCm5pSv5oyB54K55Ye75LqL5Lu2LCDlj6/nqbog6buY6K6kZmFsc2VcclxuICAgICAqICAgICAgICAgIGJvRXZlbnRQb3B1cFVybDogU3RyaW5nIOeCueWHu0JP5LqL5Lu25Yaz562W5by55Ye66aG16Z2i5Zyw5Z2AXHJcbiAgICAgKiAgICAgICAgICBiaW5kQm9DbGlja0V2ZW50OiBmdW5jdGlvbihvcHRpb25zKSBCT+eCueWHu+S6i+S7tu+8jOi/lOWbnuWHveaVsOWPguaVsOS4um9wdGlvbnPvvIzlroPnmoTlsZ7mgKfmnIlEQVRB562JXHJcbiAgICAgKiAgICAgICAgICBhdHRyRXZlbnRDbGlja2FibGU6IGJvb2xlYW4gQk/lsZ7mgKfkuovku7blhrPnrZbmmK/lkKbmlK/mjIHngrnlh7vkuovku7YsIOWPr+epuiDpu5jorqRmYWxzZVxyXG4gICAgICogICAgICAgICAgYXR0ckV2ZW50UG9wdXBVcmw6IFN0cmluZyDngrnlh7tCT+WxnuaAp+S6i+S7tuWGs+etluW8ueWHuumhtemdouWcsOWdgFxyXG4gICAgICogICAgICAgICAgaXNDdXJyZW50OiBib29sZWFuIOaYr+WQpuS4uuW9k+WJjUJPXHJcbiAgICAgKiAgICAgICAgICBsaW5lU3R5bGU6IHtzdHJva2U6IHN0cmluZywgbGluZVdpZHRoOiBudW1iZXIsIGxpbmVEYXNoOiBBcnJheX0g5YWz6IGU57q/5qC35byPXHJcbiAgICAgKiAgICAgICAgICBsaW5lSG92ZXJTdHlsZToge3N0cm9rZTogc3RyaW5nLCBsaW5lV2lkdGg6IG51bWJlciwgbGluZURhc2g6IEFycmF5fSDlhbPogZTnur9ob3Zlcuagt+W8j1xyXG4gICAgICogICAgICAgICAgYXJyb3dTdHlsZToge2ZpbGw6IHN0cmluZywgc3Ryb2tlOiBzdHJpbmd9IOWFs+iBlOe6v+eureWktOagt+W8j1xyXG4gICAgICogICAgICAgICAgYXJyb3dIb3ZlclN0eWxlOiB7ZmlsbDogc3RyaW5nLCBzdHJva2U6IHN0cmluZ30g5YWz6IGU57q/566t5aS0aG92ZXLmoLflvI9cclxuICAgICAqICAgICAgICAgIH19IG9wdHNcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmFkZEJvID0gZnVuY3Rpb24gKGJvRGF0YSwgb3B0cykge1xyXG4gICAgICAgIC8v6K6+572uQk/niLblrZDlhbPns7vvvIzkvr/kuo7lkI7nu63mlbTkvZPnp7vliqhcclxuICAgICAgICB0aGlzLl9zZXRQYXJlbnQoYm9EYXRhKTtcclxuXHJcbiAgICAgICAgLy9sYXlvdXQgQk/nmoTluIPlsYDkv6Hmga/vvIx4LHnlt6bkuIrop5Lotbflp4vlnZDmoIcsIGxldmVsOuWxgue6p1xyXG4gICAgICAgIGJvRGF0YS5sYXlvdXQgPSB7XHJcbiAgICAgICAgICAgIHg6IG9wdHMuc3RhcnRQb3MueCxcclxuICAgICAgICAgICAgeTogb3B0cy5zdGFydFBvcy55LFxyXG4gICAgICAgICAgICBsZXZlbDogMVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8v6K6h566XQk/nmoRY5Z2Q5qCHXHJcbiAgICAgICAgdGhpcy5fYmZzKGJvRGF0YSk7XHJcblxyXG4gICAgICAgIC8v5oyJ54Wn6LW35aeL5Z2Q5qCH5pW05L2T5bem56e7XHJcbiAgICAgICAgdGhpcy5fbW92ZVJpZ2h0QnlQYXJlbnQoYm9EYXRhLCBvcHRzLnN0YXJ0UG9zLnggLSBib0RhdGEubGF5b3V0LngpO1xyXG5cclxuICAgICAgICAvL+eUu0JPXHJcbiAgICAgICAgdmFyIGJvTm9kZSA9IG5ldyBCb05vZGUoYm9EYXRhLCBvcHRzKTtcclxuICAgICAgICB0aGlzLmdyb3VwLmFkZChib05vZGUuZ2V0U2hhcGUoKSk7XHJcblxyXG4gICAgICAgIC8v5Yib5bu65a2QQk9cclxuICAgICAgICB0aGlzLmFkZENoaWxkQm8oYm9Ob2RlLCBvcHRzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGJvTm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva5CT+eahOeItuWtkOWFs+ezu1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJvRGF0YSBCT+aVsOaNrlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5fc2V0UGFyZW50ID0gZnVuY3Rpb24gKGJvRGF0YSkge1xyXG4gICAgICAgIGlmIChib0RhdGEuY2hpbGQpIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkQ250ID0gYm9EYXRhLmNoaWxkLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGNoaWxkQm9BcnIgPSBib0RhdGEuY2hpbGQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRDbnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRCb0FycltpXS5wYXJlbnQgPSBib0RhdGE7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRCb0FycltpICsgMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZEJvQXJyW2ldLm5leHQgPSBjaGlsZEJvQXJyW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8v6K6+572u5pyA5ZCO5a2Q6IqC54K555qEbmV4dD3kuIvkuIDkuKrniLboioLngrnnmoTnrKzkuIDkuKrlrZDoioLngrlcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJvRGF0YS5uZXh0ICYmIGJvRGF0YS5uZXh0LmNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRCb0FycltpXS5uZXh0ID0gYm9EYXRhLm5leHQuY2hpbGRbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQYXJlbnQoY2hpbGRCb0FycltpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJyZWFkdGgtRmlyc3QtU2VhcmNoIOiuoeeul1jlnZDmoIdcclxuICAgICAqIOeUseS6jkJP5a695bqm5a6a5q2777yM5Y+v5Lul5Zyo55S75Zu+5LmL5YmN6K6h566X5q+P5LiqQk/nmoTotbflp4tY5Z2Q5qCHXHJcbiAgICAgKiDmr4/kuKpCT+eahOmrmOW6puagueaNruaYvuekuuWGheWuueS4jeWbuuWumu+8jOWboOatpOmcgOimgeagueaNruWunumZheeahOeItkJP6auY5bqm5omN6IO96K6h566X5pys6Lqr55qE6LW35aeLWeWdkOagh1xyXG4gICAgICogQHBhcmFtIGJvRGF0YVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5fYmZzID0gZnVuY3Rpb24gKGJvRGF0YSkge1xyXG4gICAgICAgIC8v55So5LqO5L+d5a2Y5q+P5LiqbGV2ZWznmoTmnIDlpKflnZDmoIflgLxcclxuICAgICAgICB0aGlzLl9sZXZlbE1heFBvcyA9IHt9O1xyXG5cclxuICAgICAgICB0aGlzLl9xdWV1ZSA9IFtdOyAgIC8v5a2Y5pS+Qk/mlbDmja5cclxuICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKGJvRGF0YSk7XHJcblxyXG4gICAgICAgIHdoaWxlICh0aGlzLl9xdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciB0bXAgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdCT1snICsgdG1wLm5hbWUgKyAnXSB7eDogJyArIHRtcC5sYXlvdXQueCArICcsIGxldmVsOiAnICsgdG1wLmxheW91dC5sZXZlbCArICd9ICcpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcgICAgKioqQmVmb3JlIHRoaXMuX2xldmVsTWF4UG9zWycgKyB0bXAubGF5b3V0LmxldmVsICsgJ109JyArIHRoaXMuX2xldmVsTWF4UG9zW3RtcC5sYXlvdXQubGV2ZWxdKTtcclxuXHJcbiAgICAgICAgICAgIC8v6K+lbGV2ZWznrKzkuIDkuKroioLngrlcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9sZXZlbE1heFBvc1t0bXAubGF5b3V0LmxldmVsXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGV2ZWxNYXhQb3NbdG1wLmxheW91dC5sZXZlbF0gPSB7eDogdG1wLmxheW91dC54fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL+W9k+WJjeWwseaYr+acgOWPs+S+p+eahOiKgueCuVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9sZXZlbE1heFBvc1t0bXAubGF5b3V0LmxldmVsXS54ICsgQ29uc3QuQk9fTk9ERV9XSURUSCA8PSB0bXAubGF5b3V0LngpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xldmVsTWF4UG9zW3RtcC5sYXlvdXQubGV2ZWxdID0ge3g6IHRtcC5sYXlvdXQueH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy/lvZPliY3oioLngrnkuI7kuYvliY3nmoToioLngrnmnInkuqTlj4nvvIzliJnpnIDopoHov57lkIzniLboioLngrnmlbTkvZPlkJHlj7Pnp7vliqhcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3ZlUmlnaHRCeUNoaWxkKHRtcCwgdGhpcy5fbGV2ZWxNYXhQb3NbdG1wLmxheW91dC5sZXZlbF0ueCAtIHRtcC5sYXlvdXQueCArIENvbnN0LkJPX05PREVfV0lEVEggKyBDb25zdC5CT19OT0RFX09GRlNFVF9YKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGV2ZWxNYXhQb3NbdG1wLmxheW91dC5sZXZlbF0gPSB7eDogdG1wLmxheW91dC54fTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnICAgICoqKkFmdGVyIHRoaXMuX2xldmVsTWF4UG9zWycgKyB0bXAubGF5b3V0LmxldmVsICsgJ109JyArIHRoaXMuX2xldmVsTWF4UG9zW3RtcC5sYXlvdXQubGV2ZWxdKTtcclxuXHJcbiAgICAgICAgICAgIC8v5a2Y5Zyo5a2Q6IqC54K577yM6K6h566X5a2Q6IqC54K55Z2Q5qCH77yM5ZCM5pe25re75Yqg5Yiw6Zif5YiX5Lit77yM5Lul5L6/5ZCO57ut6K6h566X6LCD5pW0eOWdkOagh1xyXG4gICAgICAgICAgICBpZiAodG1wLmNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRDbnQgPSB0bXAuY2hpbGQubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRDbnQ7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0bXAuY2hpbGRbaV0ubGF5b3V0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB0bXAubGF5b3V0LnggLSAoQ29uc3QuQk9fTk9ERV9XSURUSCArIENvbnN0LkJPX05PREVfT0ZGU0VUX1gpICogKChjaGlsZENudCAtIDEpIC8gMiAtIGkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogdG1wLmxheW91dC5sZXZlbCArIDFcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKHRtcC5jaGlsZFtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5a2Q6IqC54K55Y+z56e75pe277yM5ZCM5pe25LiL5LiA5Liq5a2Q6IqC54K577yM5Lul5Y+K54i26IqC54K56YO95ZCM5pe256e75YqoXHJcbiAgICAgKiBAcGFyYW0gYm9EYXRhXHJcbiAgICAgKiBAcGFyYW0gd2lkdGhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uX21vdmVSaWdodEJ5Q2hpbGQgPSBmdW5jdGlvbiAoYm9EYXRhLCB3aWR0aCkge1xyXG4gICAgICAgIGlmIChib0RhdGEpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICghYm9EYXRhLmxheW91dC5tb3ZlZCkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChib0RhdGEubGF5b3V0LmxldmVsID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBib0RhdGEubGF5b3V0LnggKz0gd2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBib0RhdGEubGF5b3V0LnggKz0gd2lkdGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYm9EYXRhLmxheW91dC5tb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy/lvZPliY3oioLngrnnmoTkuIvkuIDoioLngrnmlbTkvZPlj7Pnp7tcclxuICAgICAgICAgICAgdGhpcy5fbW92ZVJpZ2h0QnlQcmV2aW91cyhib0RhdGEubmV4dCwgd2lkdGgpO1xyXG4gICAgICAgICAgICAvL+W9k+WJjeiKgueCueeahOeItuiKgueCueaVtOS9k+WPs+enu1xyXG4gICAgICAgICAgICB0aGlzLl9tb3ZlUmlnaHRCeUNoaWxkKGJvRGF0YS5wYXJlbnQsIHdpZHRoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWJjeS4gOS4quiKgueCueWPs+enu+eahOaXtuWAme+8jOaJgOacieWQjumdoueahOiKgueCueaVtOS9k+WPs+enu1xyXG4gICAgICogQHBhcmFtIGJvRGF0YVxyXG4gICAgICogQHBhcmFtIHdpZHRoXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLl9tb3ZlUmlnaHRCeVByZXZpb3VzID0gZnVuY3Rpb24gKGJvRGF0YSwgd2lkdGgpIHtcclxuICAgICAgICBpZiAoYm9EYXRhKSB7XHJcbiAgICAgICAgICAgIGJvRGF0YS5sYXlvdXQueCArPSB3aWR0aDtcclxuICAgICAgICAgICAgLy/lvZPliY3oioLngrnnmoTmiYDmnInlkI7nu63oioLngrnmlbTkvZPlj7Pnp7tcclxuICAgICAgICAgICAgdGhpcy5fbW92ZVJpZ2h0QnlQcmV2aW91cyhib0RhdGEubmV4dCwgd2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDniLboioLngrnlj7Pnp7vml7bvvIzmiYDmnInlrZDoioLngrnmlbTkvZPlj7Pnp7tcclxuICAgICAqIEBwYXJhbSBib0RhdGFcclxuICAgICAqIEBwYXJhbSB3aWR0aFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5fbW92ZVJpZ2h0QnlQYXJlbnQgPSBmdW5jdGlvbiAoYm9EYXRhLCB3aWR0aCkge1xyXG4gICAgICAgIGlmIChib0RhdGEpIHtcclxuICAgICAgICAgICAgYm9EYXRhLmxheW91dC54ICs9IHdpZHRoO1xyXG4gICAgICAgICAgICBpZiAoYm9EYXRhLmNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvRGF0YS5jaGlsZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21vdmVSaWdodEJ5UGFyZW50KGJvRGF0YS5jaGlsZFtpXSwgd2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOa3u+WKoOWtkEJPXHJcbiAgICAgKiBAcGFyYW0ge0JvTm9kZX0gcGFyZW50Qm9Ob2RlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5hZGRDaGlsZEJvID0gZnVuY3Rpb24gKHBhcmVudEJvTm9kZSwgb3B0cykge1xyXG5cclxuICAgICAgICB0aGlzLl9xdWV1ZSA9IFtdOyAvL+mcgOimgeagueaNrkJP6IqC54K555qE5a6e6ZmF6auY5bqm6K6h566X6Ieq5bex54K555qE6LW35aeLWeWdkOagh++8jOWboOatpOWtmOaUvueahOaYr0JvTm9kZeWbvuW9olxyXG4gICAgICAgIHRoaXMuX3F1ZXVlLnB1c2gocGFyZW50Qm9Ob2RlKTtcclxuXHJcbiAgICAgICAgd2hpbGUgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIHRtcCA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCksXHJcbiAgICAgICAgICAgICAgICBib05vZGVIZWlnaHQgPSB0bXAuZ2V0U2hhcGUoKS5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ1BhcmVudCBCT1snICsgdG1wLmdldERhdGEoKS5uYW1lICsgJ10ge3k6ICcgKyB0bXAuZ2V0TGF5b3V0KCkueSArICcsIGxldmVsOiAnICsgdG1wLmdldExheW91dCgpLmxldmVsICsgJywgYm9Ob2RlSGVpZ2h0OicgKyBib05vZGVIZWlnaHQgKyAnfSAnKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnICAgICoqKkJlZm9yZSB0aGlzLl9sZXZlbE1heFBvc1snICsgdG1wLmdldExheW91dCgpLmxldmVsICsgJ109JyArIHRoaXMuX2xldmVsTWF4UG9zW3RtcC5nZXRMYXlvdXQoKS5sZXZlbF0pO1xyXG5cclxuICAgICAgICAgICAgLy/lpoLmnpzmmK/or6VMZXZlbOesrOS4gOS4quiKgueCue+8jOaIluiAheW9k+S9juS6juWOn+adpeeahOiKgueCuVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2xldmVsTWF4UG9zW3RtcC5nZXRMYXlvdXQoKS5sZXZlbF0ueSB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGV2ZWxNYXhQb3NbdG1wLmdldExheW91dCgpLmxldmVsXS55IDwgdG1wLmdldExheW91dCgpLnkgKyBib05vZGVIZWlnaHQgKyBDb25zdC5CT19OT0RFX09GRlNFVF9ZKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sZXZlbE1heFBvc1t0bXAuZ2V0TGF5b3V0KCkubGV2ZWxdLnkgPSB0bXAuZ2V0TGF5b3V0KCkueSArIGJvTm9kZUhlaWdodCArIENvbnN0LkJPX05PREVfT0ZGU0VUX1k7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJyAgICAqKipBZnRlciB0aGlzLl9sZXZlbE1heFBvc1snICsgdG1wLmdldExheW91dCgpLmxldmVsICsgJ109JyArIHRoaXMuX2xldmVsTWF4UG9zW3RtcC5nZXRMYXlvdXQoKS5sZXZlbF0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRtcC5nZXREYXRhKCkuY2hpbGQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRCb0FyciA9IHRtcC5nZXREYXRhKCkuY2hpbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDbnQgPSBjaGlsZEJvQXJyLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICBib05vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25Ob2RlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8v6K+lbGV2ZWzmiYDmnInlrZDoioLngrnnmoTotbflp4tZ5Z2Q5qCH6YO955u45ZCMXHJcbiAgICAgICAgICAgICAgICBvcHRzLnN0YXJ0UG9zLnkgPSB0aGlzLl9sZXZlbE1heFBvc1t0bXAuZ2V0TGF5b3V0KCkubGV2ZWxdLnk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkQ250OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRzLnN0YXJ0UG9zLnggPSBjaGlsZEJvQXJyW2ldLmxheW91dC54O1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQm9BcnJbaV0ubGF5b3V0LnkgPSBvcHRzLnN0YXJ0UG9zLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9Ob2RlID0gbmV3IEJvTm9kZShjaGlsZEJvQXJyW2ldLCBvcHRzKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdDaGlsZCBCT1snICsgYm9Ob2RlLmdldERhdGEoKS5uYW1lICsgJ10ge3k6ICcgKyBvcHRzLnN0YXJ0UG9zLnkgKyAnLCBsZXZlbDogJyArIGJvTm9kZS5nZXRMYXlvdXQoKS5sZXZlbCArICd9ICcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChib05vZGUuZ2V0U2hhcGUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXVldWUucHVzaChib05vZGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL0JP5YWz57O7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkQm9BcnJbaV0ucmVsYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWxhdGlvbkxlbiA9IGNoaWxkQm9BcnJbaV0ucmVsYXRpb24ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IF9yZWxhdGlvbkxlbjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlSWQgPSBjaGlsZEJvQXJyW2ldLnJlbGF0aW9uW2pdLnNvdXJjZUlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldElkID0gY2hpbGRCb0FycltpXS5yZWxhdGlvbltqXS50YXJnZXRJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VUZXh0ID0gY2hpbGRCb0FycltpXS5yZWxhdGlvbltqXS5zb3VyY2VUZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFRleHQgPSBjaGlsZEJvQXJyW2ldLnJlbGF0aW9uW2pdLnRhcmdldFRleHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25Ob2RlID0gbmV3IFJlbGF0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvTm9kZS5nZXRTaGFwZSgpLmNoaWxkT2ZOYW1lKHNvdXJjZUlkKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAuZ2V0U2hhcGUoKS5jaGlsZE9mTmFtZSh0YXJnZXRJZCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRUZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMubGluZVN0eWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMubGluZUhvdmVyU3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5hcnJvd1N0eWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuYXJyb3dIb3ZlclN0eWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQocmVsYXRpb25Ob2RlLmdldFNoYXBlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva7lvZPliY1CT+S4uueJueauiuagt+W8j1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGJvSWQsIEJP5qCH6K+GXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGUsIEJP54m55q6K5qC35byPLOWPr+epulxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLnNldEN1cnJlbnRCbyA9IGZ1bmN0aW9uIChib0lkLCBzdHlsZSkge1xyXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmdyb3VwLmNoaWxkQ291bnQoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdyb3VwLmNoaWxkQXQoaSkubmFtZSA9PSBib0lkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLmNoaWxkQXQoaSkuc2V0Q3VycmVudChzdHlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5riF56m6XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fenIuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcclxuICAgICAgICB0aGlzLl96ci5hZGQodGhpcy5ncm91cCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog57yp5pS+5Yqf6IO9XHJcbiAgICAgKiBAcGFyYW0gdHlwZVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLnpyU2NhbGUgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBpZiAodHlwZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PSBcIm5hcnJvd2luZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgem9vbURlbHRhID0gMSAvIDEuMTtcclxuICAgICAgICAgICAgICAgIHpvb20oem9vbURlbHRhLCB0aGlzLl96ci5nZXRXaWR0aCgpIC8gMiwgdGhpcy5fenIuZ2V0SGVpZ2h0KCkgLyAyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZSA9PSBcImVubGFyZ2VcIikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHpvb21EZWx0YSA9IDEuMTtcclxuICAgICAgICAgICAgICAgIHpvb20oem9vbURlbHRhLCB0aGlzLl96ci5nZXRXaWR0aCgpIC8gMiwgdGhpcy5fenIuZ2V0SGVpZ2h0KCkgLyAyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoYXQuX3pyLm9uKCdtb3VzZXdoZWVsJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50VG9vbC5zdG9wKGUuZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHpvb21EZWx0YSA9IGUud2hlZWxEZWx0YSA+IDAgPyAxLjEgOiAxIC8gMS4xO1xyXG4gICAgICAgICAgICAgICAgem9vbSh6b29tRGVsdGEsIGUub2Zmc2V0WCwgZS5vZmZzZXRZKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIDtcclxuICAgICAgICBmdW5jdGlvbiB6b29tKHpvb21EZWx0YSwgem9vbVgsIHpvb21ZKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGF0LmNhblNjYWxlID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoYXQuZ3JvdXA7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3MgPSB0YXJnZXQucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSB0YXJnZXQuc2NhbGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3Wm9vbSA9IHRoYXQuX3pvb20gPSB0aGF0Ll96b29tIHx8IDE7XHJcbiAgICAgICAgICAgICAgICBuZXdab29tICo9IHpvb21EZWx0YTtcclxuICAgICAgICAgICAgICAgIHZhciB6b29tU2NhbGUgPSBuZXdab29tIC8gdGhhdC5fem9vbTtcclxuICAgICAgICAgICAgICAgIC8vIGlmKG5ld1pvb20+Mi42fHxuZXdab29tPDAuMzgpe1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIC8vIH07XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll96b29tID0gbmV3Wm9vbTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGF0Lm5vd1pvb20gPSBuZXdab29tO1xyXG4gICAgICAgICAgICAgICAgLy8gS2VlcCB0aGUgbW91c2UgY2VudGVyIHdoZW4gc2NhbGluZ1xyXG4gICAgICAgICAgICAgICAgcG9zWzBdIC09ICh6b29tWCAtIHBvc1swXSkgKiAoem9vbVNjYWxlIC0gMSk7XHJcbiAgICAgICAgICAgICAgICBwb3NbMV0gLT0gKHpvb21ZIC0gcG9zWzFdKSAqICh6b29tU2NhbGUgLSAxKTtcclxuICAgICAgICAgICAgICAgIHNjYWxlWzBdICo9IHpvb21TY2FsZTtcclxuICAgICAgICAgICAgICAgIHNjYWxlWzFdICo9IHpvb21TY2FsZTtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5hdHRyKFwicG9zaXRpb25cIiwgW3Bvc1swXSwgcG9zWzFdXSk7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYXR0cihcInNjYWxlXCIsIFtzY2FsZVswXSwgc2NhbGVbMV1dKTtcclxuICAgICAgICAgICAgICAgIC8vdGhhdC5taW5pbWFwLnVwZGF0ZVNlbGVjdGlvblBvc2l0aW9uKHBvcyx6b29tU2NhbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOaLluaLvUdyb3VwXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZ3JvdXBEcmFnID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGF0Ll96ci5vbihcIm1vdXNlZG93blwiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBncm91cERyYWdGdW5jdGlvbihlKTtcclxuICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZ1bmN0aW9uIGdyb3VwRHJhZ0Z1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0WCA9IGUuZXZlbnQuY2xpZW50WDtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0WSA9IGUuZXZlbnQuY2xpZW50WTtcclxuICAgICAgICAgICAgdmFyIG1vdmVGdW5jdGlvbiA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBtb3ZlRHJhZyhlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbm93R3JvdXBQb3NpdGlvbiA9IHRoYXQuZ3JvdXAucG9zaXRpb247XHJcbiAgICAgICAgICAgIHZhciBncm91cFBvc2l0aW9uWCA9IHRoYXQuZ3JvdXAucG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgIHZhciBncm91cFBvc2l0aW9uWSA9IHRoYXQuZ3JvdXAucG9zaXRpb25bMV07XHJcbiAgICAgICAgICAgIHZhciBhbGFybVBvc2l0aW9uWCwgYWxhcm1Qb3NpdGlvblk7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBtb3ZlRHJhZyhlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSB0aGF0Lmdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoICogdGhhdC5ub3dab29tO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoYXQuZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0ICogdGhhdC5ub3dab29tO1xyXG4gICAgICAgICAgICAgICAgdmFyIGd4ID0gdGhhdC5ncm91cC5nZXRCb3VuZGluZ1JlY3QoKS54ICogdGhhdC5ub3dab29tO1xyXG4gICAgICAgICAgICAgICAgdmFyIGd5ID0gdGhhdC5ncm91cC5nZXRCb3VuZGluZ1JlY3QoKS55ICogdGhhdC5ub3dab29tO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1pbiA9IFsxMCAtICh3aWR0aCArIGd4KSwgMTAgLSAoaGVpZ2h0ICsgZ3kpXTtcclxuICAgICAgICAgICAgICAgIHZhciBtYXggPSBbKHRoYXQuX3pyLmdldFdpZHRoKCkgLSBneCkgLSAxMCwgKHRoYXQuX3pyLmdldEhlaWdodCgpIC0gZ3kpIC0gMTBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNYID0gKGUuZXZlbnQuY2xpZW50WCAtIHN0YXJ0WCkgKiAodGhhdC5ub3dab29tKTtcclxuICAgICAgICAgICAgICAgIHZhciBzWSA9IChlLmV2ZW50LmNsaWVudFkgLSBzdGFydFkpICogKHRoYXQubm93Wm9vbSk7XHJcbiAgICAgICAgICAgICAgICBub3dHcm91cFBvc2l0aW9uWzBdID0gZ3JvdXBQb3NpdGlvblggKyAoc1gpO1xyXG4gICAgICAgICAgICAgICAgbm93R3JvdXBQb3NpdGlvblsxXSA9IGdyb3VwUG9zaXRpb25ZICsgKHNZKTtcclxuICAgICAgICAgICAgICAgIGlmIChub3dHcm91cFBvc2l0aW9uWzBdID4gbWF4WzBdIHx8IG5vd0dyb3VwUG9zaXRpb25bMV0gPiBtYXhbMV0gfHwgbm93R3JvdXBQb3NpdGlvblswXSA8IG1pblswXSB8fCBub3dHcm91cFBvc2l0aW9uWzFdIDwgbWluWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0Lmdyb3VwLmF0dHIoXCJwb3NpdGlvblwiLCBub3dHcm91cFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhhdC5fenIub24oJ21vdXNlbW92ZScsIG1vdmVGdW5jdGlvbik7XHJcbiAgICAgICAgICAgIHZhciB1cEZ1bmN0aW9uID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGVuZERyYWcoZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGVuZERyYWcoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fenIub2ZmKCdtb3VzZW1vdmUnLCBtb3ZlRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fenIub2ZmKCdtb3VzZXVwJywgdXBGdW5jdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll96ci5vZmYoXCJnbG9iYWxvdXRcIiwgdXBGdW5jdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoYXQuX3pyLm9uKCdtb3VzZXVwJywgdXBGdW5jdGlvbik7XHJcbiAgICAgICAgICAgIHRoYXQuX3pyLm9uKFwiZ2xvYmFsb3V0XCIsIHVwRnVuY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmi5bmi71cclxuICAgICAqIEBwYXJhbSBub2RlXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZHJhZyA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIG5vZGUub24oXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNkcmFnZ2FibGUgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBncm91cERyYWdGdW5jdGlvbihlKTtcclxuICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZ1bmN0aW9uIGdyb3VwRHJhZ0Z1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0WCA9IGUuZXZlbnQuY2xpZW50WDtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0WSA9IGUuZXZlbnQuY2xpZW50WTtcclxuICAgICAgICAgICAgdmFyIG1vdmVGdW5jdGlvbiA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBtb3ZlRHJhZyhlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbm93R3JvdXBQb3NpdGlvbiA9IG5vZGUucG9zaXRpb247XHJcbiAgICAgICAgICAgIHZhciBncm91cFBvc2l0aW9uWCA9IG5vZGUucG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgIHZhciBncm91cFBvc2l0aW9uWSA9IG5vZGUucG9zaXRpb25bMV07XHJcbiAgICAgICAgICAgIHZhciBhbGFybVBvc2l0aW9uWCwgYWxhcm1Qb3NpdGlvblk7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmFsYXJtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3QWxhcm1Qb3NpdGlvbiA9IG5vZGUuYWxhcm0ucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBhbGFybVBvc2l0aW9uWCA9IG5vZGUuYWxhcm0ucG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICBhbGFybVBvc2l0aW9uWSA9IG5vZGUuYWxhcm0ucG9zaXRpb25bMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBtb3ZlRHJhZyhlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc1ggPSAoZS5ldmVudC5jbGllbnRYIC0gc3RhcnRYKSAvICh0aGF0Lm5vd1pvb20pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNZID0gKGUuZXZlbnQuY2xpZW50WSAtIHN0YXJ0WSkgLyAodGhhdC5ub3dab29tKTtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudCBpbnN0YW5jZW9mIEdyb3VwTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8v5pS+5YWlbm9kZeeOsOacieaVsOWAvO+8jOeUqOS6jumHjee7mGdyb3VwXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVNZXNzYWdlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogbm9kZS5zaGFwZS53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBub2RlLnNoYXBlLmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG5vZGUucG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVYWTogW25vZGUuc2hhcGUueCwgbm9kZS5zaGFwZS55XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVBvc2l0aW9uOiBbZ3JvdXBQb3NpdGlvblgsIGdyb3VwUG9zaXRpb25ZXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVg6IHNYLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWTogc1lcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cE5vZGUgPSBub2RlLnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICBncm91cE5vZGUucmVEcmF3KG5vZGVNZXNzYWdlLCBub2RlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm93R3JvdXBQb3NpdGlvblswXSA9IGdyb3VwUG9zaXRpb25YICsgKHNYKTtcclxuICAgICAgICAgICAgICAgICAgICBub3dHcm91cFBvc2l0aW9uWzFdID0gZ3JvdXBQb3NpdGlvblkgKyAoc1kpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYXR0cihcInBvc2l0aW9uXCIsIG5vd0dyb3VwUG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmFsYXJtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdBbGFybVBvc2l0aW9uID0gW25vd0dyb3VwUG9zaXRpb25bMF0gKyBub2RlLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC0gKG5vZGUuYWxhcm0uZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggLSA2KSwgbm93R3JvdXBQb3NpdGlvblsxXSAtIG5vZGUuYWxhcm0uZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0IC0gM107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYWxhcm0uYXR0cihcInBvc2l0aW9uXCIsIG5ld0FsYXJtUG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBDb25uZWN0aW9uTWFuYWdlci5yZWZyZXNoTGluZUJ5Tm9kZShub2RlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhhdC5fenIub24oJ21vdXNlbW92ZScsIG1vdmVGdW5jdGlvbik7XHJcbiAgICAgICAgICAgIHZhciB1cEZ1bmN0aW9uID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGVuZERyYWcoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy/mi5bmi73nu5PmnZ9cclxuICAgICAgICAgICAgZnVuY3Rpb24gZW5kRHJhZyhlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll96ci5vZmYoJ21vdXNlbW92ZScsIG1vdmVGdW5jdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll96ci5vZmYoJ21vdXNldXAnLCB1cEZ1bmN0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoYXQuX3pyLm9mZihcImdsb2JhbG91dFwiLCB1cEZ1bmN0aW9uKTtcclxuICAgICAgICAgICAgICAgIC8v5biD5bGA6YeN5paw6K6h566XXHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5sYXlvdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmxheW91dE5vZGUoXCJ0cmVlXCIsIHtcIm5vZGVcIjogbm9kZX0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoYXQuZm9yY2VMYXlvdXRPcHRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGF0LmZvcmNlTGF5b3V0T3B0aW9uLmFsbE5vZGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfLmluZGV4T2Yobm9kZXMsIG5vZGUpICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQubGF5b3V0Tm9kZShcImZvcmNlXCIsIHRoaXMuZm9yY2VMYXlvdXRPcHRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhhdC5fenIub24oJ21vdXNldXAnLCB1cEZ1bmN0aW9uKTtcclxuICAgICAgICAgICAgdGhhdC5fenIub24oXCJnbG9iYWxvdXRcIiwgdXBGdW5jdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLy8gLS0tLS0tLS0t5a+55aSW5pq06ZyyZmlzaFRvcG9Cby0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgdmFyIGlkQmFzZSA9IG5ldyBEYXRlKCkgLSAwO1xyXG4gICAgdmFyIGluc3RhbmNlcyA9IHt9O1xyXG4gICAgdmFyIERPTV9BVFRSSUJVVEVfS0VZID0gJ19maXNoVG9wb0JvX2luc3RhbmNlXyc7XHJcbiAgICB2YXIgZmlzaFRvcG9CbyA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZlcnNpb246ICczLjAuMCcsXHJcbiAgICAgICAgZGVwZW5kZW5jaWVzOiB7XHJcbiAgICAgICAgICAgIHpyZW5kZXI6ICczLjAuNCdcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtIVE1MRG9tRWxlbWVudH0gZG9tXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb0JvLmluaXQgPSBmdW5jdGlvbiAoZG9tLCBvcHRzKSB7XHJcbiAgICAgICAgaWYgKCFkb20pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbml0aWFsaXplIGZhaWxlZDogaW52YWxpZCBkb20uJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcclxuICAgICAgICAvLyBEZWZhdWx0IHZhbHVlXHJcbiAgICAgICAgdXRpbC5kZWZhdWx0cyhvcHRzLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJwbW5cIixcclxuICAgICAgICAgICAgICAgIHNob3dHcmlkTGluZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGRldmljZVBpeGVsUmF0aW86IDEsXHJcbiAgICAgICAgICAgICAgICBncmlkTGluZVNwYWNpbmc6MTBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHZhciBmaXNoVG9wb0JvID0gbmV3IEZpc2hUb3BvQm8oZG9tLCBvcHRzKTtcclxuICAgICAgICBmaXNoVG9wb0JvLmluaXQoKTtcclxuXHJcbiAgICAgICAgZmlzaFRvcG9Cby5pZCA9ICdmdF8nICsgaWRCYXNlKys7XHJcbiAgICAgICAgaW5zdGFuY2VzW2Zpc2hUb3BvQm8uaWRdID0gZmlzaFRvcG9CbztcclxuXHJcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZSAmJiBkb20uc2V0QXR0cmlidXRlKERPTV9BVFRSSUJVVEVfS0VZLCBmaXNoVG9wb0JvLmlkKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZpc2hUb3BvQm87XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSAge0hUTUxEb21FbGVtZW50fSBkb21cclxuICAgICAqIEByZXR1cm4ge2Zpc2hUb3BvfVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb0JvLmdldEluc3RhbmNlQnlEb20gPSBmdW5jdGlvbiAoZG9tKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IGRvbS5nZXRBdHRyaWJ1dGUoRE9NX0FUVFJJQlVURV9LRVkpO1xyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZXNba2V5XTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwb3NlIGEgZmlzaFRvcG8gaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSAge21vZHVsZTpmaXNoVG9wb3xIVE1MRG9tRWxlbWVudHxzdHJpbmd9IGZpc2hUb3BvXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvQm8uZGlzcG9zZSA9IGZ1bmN0aW9uIChjaGFydCkge1xyXG4gICAgICAgIHZhciB0b3BvO1xyXG4gICAgICAgIGlmICh6clV0aWwuaXNEb20oY2hhcnQpKSB7XHJcbiAgICAgICAgICAgIHRvcG8gPSBmaXNoVG9wb0JvLmdldEluc3RhbmNlQnlEb20oY2hhcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2hhcnQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRvcG8gPSBpbnN0YW5jZXNbY2hhcnRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHRvcG8gaW5zdGFuY2VvZiBmaXNoVG9wb0JvKSAmJiAhdG9wby5pc0Rpc3Bvc2VkKCkpIHtcclxuICAgICAgICAgICAgdG9wby5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZpc2hUb3BvQm87XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYm8vbGliL0Zpc2hUb3BvQm8uanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGd1aWQgPSByZXF1aXJlKFwiLi9jb3JlL2d1aWRcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwiLi9jb3JlL2VudlwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxudmFyIEhhbmRsZXIgPSByZXF1aXJlKFwiLi9IYW5kbGVyXCIpO1xuXG52YXIgU3RvcmFnZSA9IHJlcXVpcmUoXCIuL1N0b3JhZ2VcIik7XG5cbnZhciBQYWludGVyID0gcmVxdWlyZShcIi4vUGFpbnRlclwiKTtcblxudmFyIEFuaW1hdGlvbiA9IHJlcXVpcmUoXCIuL2FuaW1hdGlvbi9BbmltYXRpb25cIik7XG5cbnZhciBIYW5kbGVyUHJveHkgPSByZXF1aXJlKFwiLi9kb20vSGFuZGxlclByb3h5XCIpO1xuXG4vKiFcbiogWlJlbmRlciwgYSBoaWdoIHBlcmZvcm1hbmNlIDJkIGRyYXdpbmcgbGlicmFyeS5cbipcbiogQ29weXJpZ2h0IChjKSAyMDEzLCBCYWlkdSBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIExJQ0VOU0VcbiogaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS96cmVuZGVyL2Jsb2IvbWFzdGVyL0xJQ0VOU0UudHh0XG4qL1xudmFyIHVzZVZNTCA9ICFlbnYuY2FudmFzU3VwcG9ydGVkO1xudmFyIHBhaW50ZXJDdG9ycyA9IHtcbiAgY2FudmFzOiBQYWludGVyXG59O1xudmFyIGluc3RhbmNlcyA9IHt9OyAvLyBaUmVuZGVy5a6e5L6LbWFw57Si5byVXG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuXG52YXIgdmVyc2lvbiA9ICczLjcuNCc7XG4vKipcbiAqIEluaXRpYWxpemluZyBhIHpyZW5kZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5yZW5kZXJlcj0nY2FudmFzJ10gJ2NhbnZhcycgb3IgJ3N2ZydcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvXVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRzLmhlaWdodF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICovXG5cbmZ1bmN0aW9uIGluaXQoZG9tLCBvcHRzKSB7XG4gIHZhciB6ciA9IG5ldyBaUmVuZGVyKGd1aWQoKSwgZG9tLCBvcHRzKTtcbiAgaW5zdGFuY2VzW3pyLmlkXSA9IHpyO1xuICByZXR1cm4genI7XG59XG4vKipcbiAqIERpc3Bvc2UgenJlbmRlciBpbnN0YW5jZVxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICovXG5cblxuZnVuY3Rpb24gZGlzcG9zZSh6cikge1xuICBpZiAoenIpIHtcbiAgICB6ci5kaXNwb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIga2V5IGluIGluc3RhbmNlcykge1xuICAgICAgaWYgKGluc3RhbmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGluc3RhbmNlc1trZXldLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnN0YW5jZXMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuLyoqXG4gKiBHZXQgenJlbmRlciBpbnN0YW5jZSBieSBpZFxuICogQHBhcmFtIHtzdHJpbmd9IGlkIHpyZW5kZXIgaW5zdGFuY2UgaWRcbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRJbnN0YW5jZShpZCkge1xuICByZXR1cm4gaW5zdGFuY2VzW2lkXTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJQYWludGVyKG5hbWUsIEN0b3IpIHtcbiAgcGFpbnRlckN0b3JzW25hbWVdID0gQ3Rvcjtcbn1cblxuZnVuY3Rpb24gZGVsSW5zdGFuY2UoaWQpIHtcbiAgZGVsZXRlIGluc3RhbmNlc1tpZF07XG59XG4vKipcbiAqIEBtb2R1bGUgenJlbmRlci9aUmVuZGVyXG4gKi9cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9aUmVuZGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5yZW5kZXJlcj0nY2FudmFzJ10gJ2NhbnZhcycgb3IgJ3N2ZydcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICovXG5cblxudmFyIFpSZW5kZXIgPSBmdW5jdGlvbiAoaWQsIGRvbSwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgLyoqXG4gICAqIEB0eXBlIHtIVE1MRG9tRWxlbWVudH1cbiAgICovXG5cbiAgdGhpcy5kb20gPSBkb207XG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cblxuICB0aGlzLmlkID0gaWQ7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHN0b3JhZ2UgPSBuZXcgU3RvcmFnZSgpO1xuICB2YXIgcmVuZGVyZXJUeXBlID0gb3B0cy5yZW5kZXJlcjsgLy8gVE9ETyBXZWJHTFxuXG4gIGlmICh1c2VWTUwpIHtcbiAgICBpZiAoIXBhaW50ZXJDdG9ycy52bWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gcmVxdWlyZSBcXCd6cmVuZGVyL3ZtbC92bWxcXCcgdG8gc3VwcG9ydCBJRTgnKTtcbiAgICB9XG5cbiAgICByZW5kZXJlclR5cGUgPSAndm1sJztcbiAgfSBlbHNlIGlmICghcmVuZGVyZXJUeXBlIHx8ICFwYWludGVyQ3RvcnNbcmVuZGVyZXJUeXBlXSkge1xuICAgIHJlbmRlcmVyVHlwZSA9ICdjYW52YXMnO1xuICB9XG5cbiAgdmFyIHBhaW50ZXIgPSBuZXcgcGFpbnRlckN0b3JzW3JlbmRlcmVyVHlwZV0oZG9tLCBzdG9yYWdlLCBvcHRzKTtcbiAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcbiAgdmFyIGhhbmRlclByb3h5ID0gIWVudi5ub2RlID8gbmV3IEhhbmRsZXJQcm94eShwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpKSA6IG51bGw7XG4gIHRoaXMuaGFuZGxlciA9IG5ldyBIYW5kbGVyKHN0b3JhZ2UsIHBhaW50ZXIsIGhhbmRlclByb3h5LCBwYWludGVyLnJvb3QpO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb259XG4gICAqL1xuXG4gIHRoaXMuYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbih7XG4gICAgc3RhZ2U6IHtcbiAgICAgIHVwZGF0ZTogenJVdGlsLmJpbmQodGhpcy5mbHVzaCwgdGhpcylcbiAgICB9XG4gIH0pO1xuICB0aGlzLmFuaW1hdGlvbi5zdGFydCgpO1xuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX25lZWRzUmVmcmVzaDsgLy8g5L+u5pS5IHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UsIOavj+asoeWIoOmZpOWFg+e0oOS5i+WJjeWIoOmZpOWKqOeUu1xuICAvLyBGSVhNRSDmnInngrl1Z2x5XG5cbiAgdmFyIG9sZERlbEZyb21TdG9yYWdlID0gc3RvcmFnZS5kZWxGcm9tU3RvcmFnZTtcbiAgdmFyIG9sZEFkZFRvU3RvcmFnZSA9IHN0b3JhZ2UuYWRkVG9TdG9yYWdlO1xuXG4gIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICBvbGREZWxGcm9tU3RvcmFnZS5jYWxsKHN0b3JhZ2UsIGVsKTtcbiAgICBlbCAmJiBlbC5yZW1vdmVTZWxmRnJvbVpyKHNlbGYpO1xuICB9O1xuXG4gIHN0b3JhZ2UuYWRkVG9TdG9yYWdlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgb2xkQWRkVG9TdG9yYWdlLmNhbGwoc3RvcmFnZSwgZWwpO1xuICAgIGVsLmFkZFNlbGZUb1pyKHNlbGYpO1xuICB9O1xufTtcblxuWlJlbmRlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBaUmVuZGVyLFxuXG4gIC8qKlxuICAgKiDojrflj5blrp7kvovllK/kuIDmoIfor4ZcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0SWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pZDtcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5YWD57SgXG4gICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAqL1xuICBhZGQ6IGZ1bmN0aW9uIChlbCkge1xuICAgIHRoaXMuc3RvcmFnZS5hZGRSb290KGVsKTtcbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiDliKDpmaTlhYPntKBcbiAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgdGhpcy5zdG9yYWdlLmRlbFJvb3QoZWwpO1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoYW5nZSBjb25maWd1cmF0aW9uIG9mIGxheWVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6TGV2ZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5jbGVhckNvbG9yPTBdIENsZWFyIGNvbG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLm1vdGlvbkJsdXI9ZmFsc2VdIElmIGVuYWJsZSBtb3Rpb24gYmx1clxuICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5sYXN0RnJhbWVBbHBoYT0wLjddIE1vdGlvbiBibHVyIGZhY3Rvci4gTGFyZ2VyIHZhbHVlIGNhdXNlIGxvbmdlciB0cmFpbGVyXG4gICovXG4gIGNvbmZpZ0xheWVyOiBmdW5jdGlvbiAoekxldmVsLCBjb25maWcpIHtcbiAgICB0aGlzLnBhaW50ZXIuY29uZmlnTGF5ZXIoekxldmVsLCBjb25maWcpO1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgdGhlIGNhbnZhcyBpbW1lZGlhdGVseVxuICAgKi9cbiAgcmVmcmVzaEltbWVkaWF0ZWx5OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gdmFyIHN0YXJ0ID0gbmV3IERhdGUoKTtcbiAgICAvLyBDbGVhciBuZWVkc1JlZnJlc2ggYWhlYWQgdG8gYXZvaWQgc29tZXRoaW5nIHdyb25nIGhhcHBlbnMgaW4gcmVmcmVzaFxuICAgIC8vIE9yIGl0IHdpbGwgY2F1c2UgenJlbmRlciByZWZyZXNoZXMgYWdhaW4gYW5kIGFnYWluLlxuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IGZhbHNlO1xuICAgIHRoaXMucGFpbnRlci5yZWZyZXNoKCk7XG4gICAgLyoqXG4gICAgICogQXZvaWQgdHJpZ2dlciB6ci5yZWZyZXNoIGluIEVsZW1lbnQjYmVmb3JlVXBkYXRlIGhvb2tcbiAgICAgKi9cblxuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IGZhbHNlOyAvLyB2YXIgZW5kID0gbmV3IERhdGUoKTtcbiAgICAvLyB2YXIgbG9nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvZycpO1xuICAgIC8vIGlmIChsb2cpIHtcbiAgICAvLyAgICAgbG9nLmlubmVySFRNTCA9IGxvZy5pbm5lckhUTUwgKyAnPGJyPicgKyAoZW5kIC0gc3RhcnQpO1xuICAgIC8vIH1cbiAgfSxcblxuICAvKipcbiAgICogTWFyayBhbmQgcmVwYWludCB0aGUgY2FudmFzIGluIHRoZSBuZXh0IGZyYW1lIG9mIGJyb3dzZXJcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFsbCByZWZyZXNoXG4gICAqL1xuICBmbHVzaDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9uZWVkc1JlZnJlc2gpIHtcbiAgICAgIHRoaXMucmVmcmVzaEltbWVkaWF0ZWx5KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyKSB7XG4gICAgICB0aGlzLnJlZnJlc2hIb3ZlckltbWVkaWF0ZWx5KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgZWxlbWVudCB0byBob3ZlciBsYXllclxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICovXG4gIGFkZEhvdmVyOiBmdW5jdGlvbiAoZWwsIHN0eWxlKSB7XG4gICAgaWYgKHRoaXMucGFpbnRlci5hZGRIb3Zlcikge1xuICAgICAgdGhpcy5wYWludGVyLmFkZEhvdmVyKGVsLCBzdHlsZSk7XG4gICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWRkIGVsZW1lbnQgZnJvbSBob3ZlciBsYXllclxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKi9cbiAgcmVtb3ZlSG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmICh0aGlzLnBhaW50ZXIucmVtb3ZlSG92ZXIpIHtcbiAgICAgIHRoaXMucGFpbnRlci5yZW1vdmVIb3ZlcihlbCk7XG4gICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2xlYXIgYWxsIGhvdmVyIGVsZW1lbnRzIGluIGhvdmVyIGxheWVyXG4gICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAqL1xuICBjbGVhckhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucGFpbnRlci5jbGVhckhvdmVyKSB7XG4gICAgICB0aGlzLnBhaW50ZXIuY2xlYXJIb3ZlcigpO1xuICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZnJlc2ggaG92ZXIgaW4gbmV4dCBmcmFtZVxuICAgKi9cbiAgcmVmcmVzaEhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fbmVlZHNSZWZyZXNoSG92ZXIgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIGhvdmVyIGltbWVkaWF0ZWx5XG4gICAqL1xuICByZWZyZXNoSG92ZXJJbW1lZGlhdGVseTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyID0gZmFsc2U7XG4gICAgdGhpcy5wYWludGVyLnJlZnJlc2hIb3ZlciAmJiB0aGlzLnBhaW50ZXIucmVmcmVzaEhvdmVyKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2l6ZSB0aGUgY2FudmFzLlxuICAgKiBTaG91bGQgYmUgaW52b2tlZCB3aGVuIGNvbnRhaW5lciBzaXplIGlzIGNoYW5nZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgKi9cbiAgcmVzaXplOiBmdW5jdGlvbiAob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHRoaXMucGFpbnRlci5yZXNpemUob3B0cy53aWR0aCwgb3B0cy5oZWlnaHQpO1xuICAgIHRoaXMuaGFuZGxlci5yZXNpemUoKTtcbiAgfSxcblxuICAvKipcbiAgICogU3RvcCBhbmQgY2xlYXIgYWxsIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxuICAgKi9cbiAgY2xlYXJBbmltYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFuaW1hdGlvbi5jbGVhcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgY29udGFpbmVyIHdpZHRoXG4gICAqL1xuICBnZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0V2lkdGgoKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGNvbnRhaW5lciBoZWlnaHRcbiAgICovXG4gIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0SGVpZ2h0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4cG9ydCB0aGUgY2FudmFzIGFzIEJhc2U2NCBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtiYWNrZ3JvdW5kQ29sb3I9JyNmZmYnXVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEJhc2U2NCBVUkxcbiAgICovXG4gIC8vIHRvRGF0YVVSTDogZnVuY3Rpb24odHlwZSwgYmFja2dyb3VuZENvbG9yKSB7XG4gIC8vICAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldFJlbmRlcmVkQ2FudmFzKHtcbiAgLy8gICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvclxuICAvLyAgICAgfSkudG9EYXRhVVJMKHR5cGUpO1xuICAvLyB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0aW5nIGEgcGF0aCB0byBpbWFnZS5cbiAgICogSXQgaGFzIG11Y2ggYmV0dGVyIHBlcmZvcm1hbmNlIG9mIGRyYXdpbmcgaW1hZ2UgcmF0aGVyIHRoYW4gZHJhd2luZyBhIHZlY3RvciBwYXRoLlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH0gZVxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgKi9cbiAgcGF0aFRvSW1hZ2U6IGZ1bmN0aW9uIChlLCBkcHIpIHtcbiAgICByZXR1cm4gdGhpcy5wYWludGVyLnBhdGhUb0ltYWdlKGUsIGRwcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCBkZWZhdWx0IGN1cnNvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvclN0eWxlPSdkZWZhdWx0J10g5L6L5aaCIGNyb3NzaGFpclxuICAgKi9cbiAgc2V0Q3Vyc29yU3R5bGU6IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgIHRoaXMuaGFuZGxlci5zZXRDdXJzb3JTdHlsZShjdXJzb3JTdHlsZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmQgaG92ZXJlZCBlbGVtZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge09iamVjdH0ge3RhcmdldCwgdG9wVGFyZ2V0fVxuICAgKi9cbiAgZmluZEhvdmVyOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZmluZEhvdmVyKHgsIHkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBCaW5kIGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudEhhbmRsZXIgSGFuZGxlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIENvbnRleHQgb2JqZWN0XG4gICAqL1xuICBvbjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgdGhpcy5oYW5kbGVyLm9uKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogVW5iaW5kIGV2ZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXZlbnRIYW5kbGVyXSBIYW5kbGVyIGZ1bmN0aW9uXG4gICAqL1xuICBvZmY6IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50SGFuZGxlcikge1xuICAgIHRoaXMuaGFuZGxlci5vZmYoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGV2ZW50IG1hbnVhbGx5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge2V2ZW50PX0gZXZlbnQgRXZlbnQgb2JqZWN0XG4gICAqL1xuICB0cmlnZ2VyOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudCkge1xuICAgIHRoaXMuaGFuZGxlci50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgb2JqZWN0cyBhbmQgdGhlIGNhbnZhcy5cbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdG9yYWdlLmRlbFJvb3QoKTtcbiAgICB0aGlzLnBhaW50ZXIuY2xlYXIoKTtcbiAgfSxcblxuICAvKipcbiAgICogRGlzcG9zZSBzZWxmLlxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYW5pbWF0aW9uLnN0b3AoKTtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5zdG9yYWdlLmRpc3Bvc2UoKTtcbiAgICB0aGlzLnBhaW50ZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuaGFuZGxlci5kaXNwb3NlKCk7XG4gICAgdGhpcy5hbmltYXRpb24gPSB0aGlzLnN0b3JhZ2UgPSB0aGlzLnBhaW50ZXIgPSB0aGlzLmhhbmRsZXIgPSBudWxsO1xuICAgIGRlbEluc3RhbmNlKHRoaXMuaWQpO1xuICB9XG59O1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5leHBvcnRzLmRpc3Bvc2UgPSBkaXNwb3NlO1xuZXhwb3J0cy5nZXRJbnN0YW5jZSA9IGdldEluc3RhbmNlO1xuZXhwb3J0cy5yZWdpc3RlclBhaW50ZXIgPSByZWdpc3RlclBhaW50ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL3pyZW5kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiB6cmVuZGVyOiDnlJ/miJDllK/kuIBpZFxuICpcbiAqIEBhdXRob3IgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xudmFyIGlkU3RhcnQgPSAweDA5MDc7XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICByZXR1cm4gaWRTdGFydCsrO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL2d1aWQuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBlY2hhcnRz6K6+5aSH546v5aKD6K+G5YirXG4gKlxuICogQGRlc2MgZWNoYXJ0c+WfuuS6jkNhbnZhc++8jOe6r0phdmFzY3JpcHTlm77ooajlupPvvIzmj5Dkvpvnm7Top4LvvIznlJ/liqjvvIzlj6/kuqTkupLvvIzlj6/kuKrmgKfljJblrprliLbnmoTmlbDmja7nu5/orqHlm77ooajjgIJcbiAqIEBhdXRob3IgZmlyZWRlW2ZpcmVkZUBmaXJlZGUudXNdXG4gKiBAZGVzYyB0aGFua3MgemVwdG8uXG4gKi9cbnZhciBlbnYgPSB7fTtcblxuaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIEluIG5vZGVcbiAgZW52ID0ge1xuICAgIGJyb3dzZXI6IHt9LFxuICAgIG9zOiB7fSxcbiAgICBub2RlOiB0cnVlLFxuICAgIC8vIEFzc3VtZSBjYW52YXMgaXMgc3VwcG9ydGVkXG4gICAgY2FudmFzU3VwcG9ydGVkOiB0cnVlLFxuICAgIHN2Z1N1cHBvcnRlZDogdHJ1ZVxuICB9O1xufSBlbHNlIHtcbiAgZW52ID0gZGV0ZWN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xufVxuXG52YXIgX2RlZmF1bHQgPSBlbnY7IC8vIFplcHRvLmpzXG4vLyAoYykgMjAxMC0yMDEzIFRob21hcyBGdWNoc1xuLy8gWmVwdG8uanMgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbmZ1bmN0aW9uIGRldGVjdCh1YSkge1xuICB2YXIgb3MgPSB7fTtcbiAgdmFyIGJyb3dzZXIgPSB7fTsgLy8gdmFyIHdlYmtpdCA9IHVhLm1hdGNoKC9XZWJba0tdaXRbXFwvXXswLDF9KFtcXGQuXSspLyk7XG4gIC8vIHZhciBhbmRyb2lkID0gdWEubWF0Y2goLyhBbmRyb2lkKTs/W1xcc1xcL10rKFtcXGQuXSspPy8pO1xuICAvLyB2YXIgaXBhZCA9IHVhLm1hdGNoKC8oaVBhZCkuKk9TXFxzKFtcXGRfXSspLyk7XG4gIC8vIHZhciBpcG9kID0gdWEubWF0Y2goLyhpUG9kKSguKk9TXFxzKFtcXGRfXSspKT8vKTtcbiAgLy8gdmFyIGlwaG9uZSA9ICFpcGFkICYmIHVhLm1hdGNoKC8oaVBob25lXFxzT1MpXFxzKFtcXGRfXSspLyk7XG4gIC8vIHZhciB3ZWJvcyA9IHVhLm1hdGNoKC8od2ViT1N8aHB3T1MpW1xcc1xcL10oW1xcZC5dKykvKTtcbiAgLy8gdmFyIHRvdWNocGFkID0gd2Vib3MgJiYgdWEubWF0Y2goL1RvdWNoUGFkLyk7XG4gIC8vIHZhciBraW5kbGUgPSB1YS5tYXRjaCgvS2luZGxlXFwvKFtcXGQuXSspLyk7XG4gIC8vIHZhciBzaWxrID0gdWEubWF0Y2goL1NpbGtcXC8oW1xcZC5fXSspLyk7XG4gIC8vIHZhciBibGFja2JlcnJ5ID0gdWEubWF0Y2goLyhCbGFja0JlcnJ5KS4qVmVyc2lvblxcLyhbXFxkLl0rKS8pO1xuICAvLyB2YXIgYmIxMCA9IHVhLm1hdGNoKC8oQkIxMCkuKlZlcnNpb25cXC8oW1xcZC5dKykvKTtcbiAgLy8gdmFyIHJpbXRhYmxldG9zID0gdWEubWF0Y2goLyhSSU1cXHNUYWJsZXRcXHNPUylcXHMoW1xcZC5dKykvKTtcbiAgLy8gdmFyIHBsYXlib29rID0gdWEubWF0Y2goL1BsYXlCb29rLyk7XG4gIC8vIHZhciBjaHJvbWUgPSB1YS5tYXRjaCgvQ2hyb21lXFwvKFtcXGQuXSspLykgfHwgdWEubWF0Y2goL0NyaU9TXFwvKFtcXGQuXSspLyk7XG5cbiAgdmFyIGZpcmVmb3ggPSB1YS5tYXRjaCgvRmlyZWZveFxcLyhbXFxkLl0rKS8pOyAvLyB2YXIgc2FmYXJpID0gd2Via2l0ICYmIHVhLm1hdGNoKC9Nb2JpbGVcXC8vKSAmJiAhY2hyb21lO1xuICAvLyB2YXIgd2VidmlldyA9IHVhLm1hdGNoKC8oaVBob25lfGlQb2R8aVBhZCkuKkFwcGxlV2ViS2l0KD8hLipTYWZhcmkpLykgJiYgIWNocm9tZTtcblxuICB2YXIgaWUgPSB1YS5tYXRjaCgvTVNJRVxccyhbXFxkLl0rKS8pIC8vIElFIDExIFRyaWRlbnQvNy4wOyBydjoxMS4wXG4gIHx8IHVhLm1hdGNoKC9UcmlkZW50XFwvLis/cnY6KChbXFxkLl0rKSkvKTtcbiAgdmFyIGVkZ2UgPSB1YS5tYXRjaCgvRWRnZVxcLyhbXFxkLl0rKS8pOyAvLyBJRSAxMiBhbmQgMTIrXG5cbiAgdmFyIHdlQ2hhdCA9IC9taWNyb21lc3Nlbmdlci9pLnRlc3QodWEpOyAvLyBUb2RvOiBjbGVhbiB0aGlzIHVwIHdpdGggYSBiZXR0ZXIgT1MvYnJvd3NlciBzZXBlcmF0aW9uOlxuICAvLyAtIGRpc2Nlcm4gKG1vcmUpIGJldHdlZW4gbXVsdGlwbGUgYnJvd3NlcnMgb24gYW5kcm9pZFxuICAvLyAtIGRlY2lkZSBpZiBraW5kbGUgZmlyZSBpbiBzaWxrIG1vZGUgaXMgYW5kcm9pZCBvciBub3RcbiAgLy8gLSBGaXJlZm94IG9uIEFuZHJvaWQgZG9lc24ndCBzcGVjaWZ5IHRoZSBBbmRyb2lkIHZlcnNpb25cbiAgLy8gLSBwb3NzaWJseSBkZXZpZGUgaW4gb3MsIGRldmljZSBhbmQgYnJvd3NlciBoYXNoZXNcbiAgLy8gaWYgKGJyb3dzZXIud2Via2l0ID0gISF3ZWJraXQpIGJyb3dzZXIudmVyc2lvbiA9IHdlYmtpdFsxXTtcbiAgLy8gaWYgKGFuZHJvaWQpIG9zLmFuZHJvaWQgPSB0cnVlLCBvcy52ZXJzaW9uID0gYW5kcm9pZFsyXTtcbiAgLy8gaWYgKGlwaG9uZSAmJiAhaXBvZCkgb3MuaW9zID0gb3MuaXBob25lID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwaG9uZVsyXS5yZXBsYWNlKC9fL2csICcuJyk7XG4gIC8vIGlmIChpcGFkKSBvcy5pb3MgPSBvcy5pcGFkID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwYWRbMl0ucmVwbGFjZSgvXy9nLCAnLicpO1xuICAvLyBpZiAoaXBvZCkgb3MuaW9zID0gb3MuaXBvZCA9IHRydWUsIG9zLnZlcnNpb24gPSBpcG9kWzNdID8gaXBvZFszXS5yZXBsYWNlKC9fL2csICcuJykgOiBudWxsO1xuICAvLyBpZiAod2Vib3MpIG9zLndlYm9zID0gdHJ1ZSwgb3MudmVyc2lvbiA9IHdlYm9zWzJdO1xuICAvLyBpZiAodG91Y2hwYWQpIG9zLnRvdWNocGFkID0gdHJ1ZTtcbiAgLy8gaWYgKGJsYWNrYmVycnkpIG9zLmJsYWNrYmVycnkgPSB0cnVlLCBvcy52ZXJzaW9uID0gYmxhY2tiZXJyeVsyXTtcbiAgLy8gaWYgKGJiMTApIG9zLmJiMTAgPSB0cnVlLCBvcy52ZXJzaW9uID0gYmIxMFsyXTtcbiAgLy8gaWYgKHJpbXRhYmxldG9zKSBvcy5yaW10YWJsZXRvcyA9IHRydWUsIG9zLnZlcnNpb24gPSByaW10YWJsZXRvc1syXTtcbiAgLy8gaWYgKHBsYXlib29rKSBicm93c2VyLnBsYXlib29rID0gdHJ1ZTtcbiAgLy8gaWYgKGtpbmRsZSkgb3Mua2luZGxlID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGtpbmRsZVsxXTtcbiAgLy8gaWYgKHNpbGspIGJyb3dzZXIuc2lsayA9IHRydWUsIGJyb3dzZXIudmVyc2lvbiA9IHNpbGtbMV07XG4gIC8vIGlmICghc2lsayAmJiBvcy5hbmRyb2lkICYmIHVhLm1hdGNoKC9LaW5kbGUgRmlyZS8pKSBicm93c2VyLnNpbGsgPSB0cnVlO1xuICAvLyBpZiAoY2hyb21lKSBicm93c2VyLmNocm9tZSA9IHRydWUsIGJyb3dzZXIudmVyc2lvbiA9IGNocm9tZVsxXTtcblxuICBpZiAoZmlyZWZveCkge1xuICAgIGJyb3dzZXIuZmlyZWZveCA9IHRydWU7XG4gICAgYnJvd3Nlci52ZXJzaW9uID0gZmlyZWZveFsxXTtcbiAgfSAvLyBpZiAoc2FmYXJpICYmICh1YS5tYXRjaCgvU2FmYXJpLykgfHwgISFvcy5pb3MpKSBicm93c2VyLnNhZmFyaSA9IHRydWU7XG4gIC8vIGlmICh3ZWJ2aWV3KSBicm93c2VyLndlYnZpZXcgPSB0cnVlO1xuXG5cbiAgaWYgKGllKSB7XG4gICAgYnJvd3Nlci5pZSA9IHRydWU7XG4gICAgYnJvd3Nlci52ZXJzaW9uID0gaWVbMV07XG4gIH1cblxuICBpZiAoZWRnZSkge1xuICAgIGJyb3dzZXIuZWRnZSA9IHRydWU7XG4gICAgYnJvd3Nlci52ZXJzaW9uID0gZWRnZVsxXTtcbiAgfSAvLyBJdCBpcyBkaWZmaWN1bHQgdG8gZGV0ZWN0IFdlQ2hhdCBpbiBXaW4gUGhvbmUgcHJlY2lzZWx5LCBiZWNhdXNlIHVhIGNhblxuICAvLyBub3QgYmUgc2V0IG9uIHdpbiBwaG9uZS4gU28gd2UgZG8gbm90IGNvbnNpZGVyIFdpbiBQaG9uZS5cblxuXG4gIGlmICh3ZUNoYXQpIHtcbiAgICBicm93c2VyLndlQ2hhdCA9IHRydWU7XG4gIH0gLy8gb3MudGFibGV0ID0gISEoaXBhZCB8fCBwbGF5Ym9vayB8fCAoYW5kcm9pZCAmJiAhdWEubWF0Y2goL01vYmlsZS8pKSB8fFxuICAvLyAgICAgKGZpcmVmb3ggJiYgdWEubWF0Y2goL1RhYmxldC8pKSB8fCAoaWUgJiYgIXVhLm1hdGNoKC9QaG9uZS8pICYmIHVhLm1hdGNoKC9Ub3VjaC8pKSk7XG4gIC8vIG9zLnBob25lICA9ICEhKCFvcy50YWJsZXQgJiYgIW9zLmlwb2QgJiYgKGFuZHJvaWQgfHwgaXBob25lIHx8IHdlYm9zIHx8XG4gIC8vICAgICAoY2hyb21lICYmIHVhLm1hdGNoKC9BbmRyb2lkLykpIHx8IChjaHJvbWUgJiYgdWEubWF0Y2goL0NyaU9TXFwvKFtcXGQuXSspLykpIHx8XG4gIC8vICAgICAoZmlyZWZveCAmJiB1YS5tYXRjaCgvTW9iaWxlLykpIHx8IChpZSAmJiB1YS5tYXRjaCgvVG91Y2gvKSkpKTtcblxuXG4gIHJldHVybiB7XG4gICAgYnJvd3NlcjogYnJvd3NlcixcbiAgICBvczogb3MsXG4gICAgbm9kZTogZmFsc2UsXG4gICAgLy8g5Y6f55SfY2FudmFz5pSv5oyB77yM5pS55p6B56uv54K55LqGXG4gICAgLy8gY2FudmFzU3VwcG9ydGVkIDogIShicm93c2VyLmllICYmIHBhcnNlRmxvYXQoYnJvd3Nlci52ZXJzaW9uKSA8IDkpXG4gICAgY2FudmFzU3VwcG9ydGVkOiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQsXG4gICAgc3ZnU3VwcG9ydGVkOiB0eXBlb2YgU1ZHUmVjdCAhPT0gJ3VuZGVmaW5lZCcsXG4gICAgLy8gQHNlZSA8aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80ODE3MDI5L3doYXRzLXRoZS1iZXN0LXdheS10by1kZXRlY3QtYS10b3VjaC1zY3JlZW4tZGV2aWNlLXVzaW5nLWphdmFzY3JpcHQ+XG4gICAgLy8gd29ya3Mgb24gbW9zdCBicm93c2Vyc1xuICAgIC8vIElFMTAvMTEgZG9lcyBub3Qgc3VwcG9ydCB0b3VjaCBldmVudCwgYW5kIE1TIEVkZ2Ugc3VwcG9ydHMgdGhlbSBidXQgbm90IGJ5XG4gICAgLy8gZGVmYXVsdCwgc28gd2UgZG9udCBjaGVjayBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgZm9yIHRoZW0gaGVyZS5cbiAgICB0b3VjaEV2ZW50c1N1cHBvcnRlZDogJ29udG91Y2hzdGFydCcgaW4gd2luZG93ICYmICFicm93c2VyLmllICYmICFicm93c2VyLmVkZ2UsXG4gICAgLy8gPGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXBvaW50ZXIlMjBldmVudD4uXG4gICAgcG9pbnRlckV2ZW50c1N1cHBvcnRlZDogJ29ucG9pbnRlcmRvd24nIGluIHdpbmRvdyAvLyBGaXJlZm94IHN1cHBvcnRzIHBvaW50ZXIgYnV0IG5vdCBieSBkZWZhdWx0LCBvbmx5IE1TIGJyb3dzZXJzIGFyZSByZWxpYWJsZSBvbiBwb2ludGVyXG4gICAgLy8gZXZlbnRzIGN1cnJlbnRseS4gU28gd2UgZG9udCB1c2UgdGhhdCBvbiBvdGhlciBicm93c2VycyB1bmxlc3MgdGVzdGVkIHN1ZmZpY2llbnRseS5cbiAgICAvLyBBbHRob3VnaCBJRSAxMCBzdXBwb3J0cyBwb2ludGVyIGV2ZW50LCBpdCB1c2Ugb2xkIHN0eWxlIGFuZCBpcyBkaWZmZXJlbnQgZnJvbSB0aGVcbiAgICAvLyBzdGFuZGFyZC4gU28gd2UgZXhjbHVkZSB0aGF0LiAoSUUgMTAgaXMgaGFyZGx5IHVzZWQgb24gdG91Y2ggZGV2aWNlKVxuICAgICYmIChicm93c2VyLmVkZ2UgfHwgYnJvd3Nlci5pZSAmJiBicm93c2VyLnZlcnNpb24gPj0gMTEpXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvZW52LmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvdXRpbFxuICovXG4vLyDnlKjkuo7lpITnkIZtZXJnZeaXtuaXoOazlemBjeWOhkRhdGXnrYnlr7nosaHnmoTpl67pophcbnZhciBCVUlMVElOX09CSkVDVCA9IHtcbiAgJ1tvYmplY3QgRnVuY3Rpb25dJzogMSxcbiAgJ1tvYmplY3QgUmVnRXhwXSc6IDEsXG4gICdbb2JqZWN0IERhdGVdJzogMSxcbiAgJ1tvYmplY3QgRXJyb3JdJzogMSxcbiAgJ1tvYmplY3QgQ2FudmFzR3JhZGllbnRdJzogMSxcbiAgJ1tvYmplY3QgQ2FudmFzUGF0dGVybl0nOiAxLFxuICAvLyBGb3Igbm9kZS1jYW52YXNcbiAgJ1tvYmplY3QgSW1hZ2VdJzogMSxcbiAgJ1tvYmplY3QgQ2FudmFzXSc6IDFcbn07XG52YXIgVFlQRURfQVJSQVkgPSB7XG4gICdbb2JqZWN0IEludDhBcnJheV0nOiAxLFxuICAnW29iamVjdCBVaW50OEFycmF5XSc6IDEsXG4gICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSc6IDEsXG4gICdbb2JqZWN0IEludDE2QXJyYXldJzogMSxcbiAgJ1tvYmplY3QgVWludDE2QXJyYXldJzogMSxcbiAgJ1tvYmplY3QgSW50MzJBcnJheV0nOiAxLFxuICAnW29iamVjdCBVaW50MzJBcnJheV0nOiAxLFxuICAnW29iamVjdCBGbG9hdDMyQXJyYXldJzogMSxcbiAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSc6IDFcbn07XG52YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgbmF0aXZlRm9yRWFjaCA9IGFycmF5UHJvdG8uZm9yRWFjaDtcbnZhciBuYXRpdmVGaWx0ZXIgPSBhcnJheVByb3RvLmZpbHRlcjtcbnZhciBuYXRpdmVTbGljZSA9IGFycmF5UHJvdG8uc2xpY2U7XG52YXIgbmF0aXZlTWFwID0gYXJyYXlQcm90by5tYXA7XG52YXIgbmF0aXZlUmVkdWNlID0gYXJyYXlQcm90by5yZWR1Y2U7IC8vIEF2b2lkIGFzc2lnbiB0byBhbiBleHBvcnRlZCB2YXJpYWJsZSwgZm9yIHRyYW5zZm9ybWluZyB0byBjanMuXG5cbnZhciBtZXRob2RzID0ge307XG5cbmZ1bmN0aW9uICRvdmVycmlkZShuYW1lLCBmbikge1xuICBtZXRob2RzW25hbWVdID0gZm47XG59XG4vKipcbiAqIFRob3NlIGRhdGEgdHlwZXMgY2FuIGJlIGNsb25lZDpcbiAqICAgICBQbGFpbiBvYmplY3QsIEFycmF5LCBUeXBlZEFycmF5LCBudW1iZXIsIHN0cmluZywgbnVsbCwgdW5kZWZpbmVkLlxuICogVGhvc2UgZGF0YSB0eXBlcyB3aWxsIGJlIGFzc2dpbmVkIHVzaW5nIHRoZSBvcmdpbmFsIGRhdGE6XG4gKiAgICAgQlVJTFRJTl9PQkpFQ1RcbiAqIEluc3RhbmNlIG9mIHVzZXIgZGVmaW5lZCBjbGFzcyB3aWxsIGJlIGNsb25lZCB0byBhIHBsYWluIG9iamVjdCwgd2l0aG91dFxuICogcHJvcGVydGllcyBpbiBwcm90b3R5cGUuXG4gKiBPdGhlciBkYXRhIHR5cGVzIGlzIG5vdCBzdXBwb3J0ZWQgKG5vdCBzdXJlIHdoYXQgd2lsbCBoYXBwZW4pLlxuICpcbiAqIENhdXRpb246IGRvIG5vdCBzdXBwb3J0IGNsb25lIERhdGUsIGZvciBwZXJmb3JtYW5jZSBjb25zaWRlcmF0aW9uLlxuICogKFRoZXJlIG1pZ2h0IGJlIGEgbGFyZ2UgbnVtYmVyIG9mIGRhdGUgaW4gYHNlcmllcy5kYXRhYCkuXG4gKiBTbyBkYXRlIHNob3VsZCBub3QgYmUgbW9kaWZpZWQgaW4gYW5kIG91dCBvZiBlY2hhcnRzLlxuICpcbiAqIEBwYXJhbSB7Kn0gc291cmNlXG4gKiBAcmV0dXJuIHsqfSBuZXdcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lKHNvdXJjZSkge1xuICBpZiAoc291cmNlID09IG51bGwgfHwgdHlwZW9mIHNvdXJjZSAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gc291cmNlO1xuICB2YXIgdHlwZVN0ciA9IG9ialRvU3RyaW5nLmNhbGwoc291cmNlKTtcblxuICBpZiAodHlwZVN0ciA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gY2xvbmUoc291cmNlW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoVFlQRURfQVJSQVlbdHlwZVN0cl0pIHtcbiAgICB2YXIgQ3RvciA9IHNvdXJjZS5jb25zdHJ1Y3RvcjtcblxuICAgIGlmIChzb3VyY2UuY29uc3RydWN0b3IuZnJvbSkge1xuICAgICAgcmVzdWx0ID0gQ3Rvci5mcm9tKHNvdXJjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBDdG9yKHNvdXJjZS5sZW5ndGgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IGNsb25lKHNvdXJjZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCFCVUlMVElOX09CSkVDVFt0eXBlU3RyXSAmJiAhaXNQcmltaXRpdmUoc291cmNlKSAmJiAhaXNEb20oc291cmNlKSkge1xuICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gY2xvbmUoc291cmNlW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gKiBAcGFyYW0geyp9IHNvdXJjZVxuICogQHBhcmFtIHtib29sZWFufSBbb3ZlcndyaXRlPWZhbHNlXVxuICovXG5cblxuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG92ZXJ3cml0ZSkge1xuICAvLyBXZSBzaG91bGQgZXNjYXBzZSB0aGF0IHNvdXJjZSBpcyBzdHJpbmdcbiAgLy8gYW5kIGVudGVyIGZvciAuLi4gaW4gLi4uXG4gIGlmICghaXNPYmplY3Qoc291cmNlKSB8fCAhaXNPYmplY3QodGFyZ2V0KSkge1xuICAgIHJldHVybiBvdmVyd3JpdGUgPyBjbG9uZShzb3VyY2UpIDogdGFyZ2V0O1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdmFyIHRhcmdldFByb3AgPSB0YXJnZXRba2V5XTtcbiAgICAgIHZhciBzb3VyY2VQcm9wID0gc291cmNlW2tleV07XG5cbiAgICAgIGlmIChpc09iamVjdChzb3VyY2VQcm9wKSAmJiBpc09iamVjdCh0YXJnZXRQcm9wKSAmJiAhaXNBcnJheShzb3VyY2VQcm9wKSAmJiAhaXNBcnJheSh0YXJnZXRQcm9wKSAmJiAhaXNEb20oc291cmNlUHJvcCkgJiYgIWlzRG9tKHRhcmdldFByb3ApICYmICFpc0J1aWx0SW5PYmplY3Qoc291cmNlUHJvcCkgJiYgIWlzQnVpbHRJbk9iamVjdCh0YXJnZXRQcm9wKSAmJiAhaXNQcmltaXRpdmUoc291cmNlUHJvcCkgJiYgIWlzUHJpbWl0aXZlKHRhcmdldFByb3ApKSB7XG4gICAgICAgIC8vIOWmguaenOmcgOimgemAkuW9kuimhueblu+8jOWwsemAkuW9kuiwg+eUqG1lcmdlXG4gICAgICAgIG1lcmdlKHRhcmdldFByb3AsIHNvdXJjZVByb3AsIG92ZXJ3cml0ZSk7XG4gICAgICB9IGVsc2UgaWYgKG92ZXJ3cml0ZSB8fCAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIC8vIOWQpuWImeWPquWkhOeQhm92ZXJ3cml0ZeS4unRydWXvvIzmiJbogIXlnKjnm67moIflr7nosaHkuK3msqHmnInmraTlsZ7mgKfnmoTmg4XlhrVcbiAgICAgICAgLy8gTk9URe+8jOWcqCB0YXJnZXRba2V5XSDkuI3lrZjlnKjnmoTml7blgJnkuZ/mmK/nm7TmjqXopobnm5ZcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBjbG9uZShzb3VyY2Vba2V5XSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0QW5kU291cmNlcyBUaGUgZmlyc3QgaXRlbSBpcyB0YXJnZXQsIGFuZCB0aGUgcmVzdHMgYXJlIHNvdXJjZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJ3cml0ZT1mYWxzZV1cbiAqIEByZXR1cm4geyp9IHRhcmdldFxuICovXG5cblxuZnVuY3Rpb24gbWVyZ2VBbGwodGFyZ2V0QW5kU291cmNlcywgb3ZlcndyaXRlKSB7XG4gIHZhciByZXN1bHQgPSB0YXJnZXRBbmRTb3VyY2VzWzBdO1xuXG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSB0YXJnZXRBbmRTb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ID0gbWVyZ2UocmVzdWx0LCB0YXJnZXRBbmRTb3VyY2VzW2ldLCBvdmVyd3JpdGUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQHBhcmFtIHsqfSB0YXJnZXRcbiAqIEBwYXJhbSB7Kn0gc291cmNlXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKi9cblxuXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuLyoqXG4gKiBAcGFyYW0geyp9IHRhcmdldFxuICogQHBhcmFtIHsqfSBzb3VyY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJsYXk9ZmFsc2VdXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKi9cblxuXG5mdW5jdGlvbiBkZWZhdWx0cyh0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSkge1xuICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChvdmVybGF5ID8gc291cmNlW2tleV0gIT0gbnVsbCA6IHRhcmdldFtrZXldID09IG51bGwpKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBjcmVhdGVDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBtZXRob2RzLmNyZWF0ZUNhbnZhcygpO1xufTtcblxubWV0aG9kcy5jcmVhdGVDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbn07IC8vIEZJWE1FXG5cblxudmFyIF9jdHg7XG5cbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIGlmICghX2N0eCkge1xuICAgIC8vIFVzZSB1dGlsLmNyZWF0ZUNhbnZhcyBpbnN0ZWFkIG9mIGNyZWF0ZUNhbnZhc1xuICAgIC8vIGJlY2F1c2UgY3JlYXRlQ2FudmFzIG1heSBiZSBvdmVyd3JpdHRlbiBpbiBkaWZmZXJlbnQgZW52aXJvbm1lbnRcbiAgICBfY3R4ID0gY3JlYXRlQ2FudmFzKCkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgfVxuXG4gIHJldHVybiBfY3R4O1xufVxuLyoqXG4gKiDmn6Xor6LmlbDnu4TkuK3lhYPntKDnmoRpbmRleFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICovXG5cblxuZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgaWYgKGFycmF5KSB7XG4gICAgaWYgKGFycmF5LmluZGV4T2YpIHtcbiAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKHZhbHVlKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuLyoqXG4gKiDmnoTpgKDnsbvnu6fmib/lhbPns7tcbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbGF6eiDmupDnsbtcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VDbGF6eiDln7rnsbtcbiAqL1xuXG5cbmZ1bmN0aW9uIGluaGVyaXRzKGNsYXp6LCBiYXNlQ2xhenopIHtcbiAgdmFyIGNsYXp6UHJvdG90eXBlID0gY2xhenoucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIEYoKSB7fVxuXG4gIEYucHJvdG90eXBlID0gYmFzZUNsYXp6LnByb3RvdHlwZTtcbiAgY2xhenoucHJvdG90eXBlID0gbmV3IEYoKTtcblxuICBmb3IgKHZhciBwcm9wIGluIGNsYXp6UHJvdG90eXBlKSB7XG4gICAgY2xhenoucHJvdG90eXBlW3Byb3BdID0gY2xhenpQcm90b3R5cGVbcHJvcF07XG4gIH1cblxuICBjbGF6ei5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjbGF6ejtcbiAgY2xhenouc3VwZXJDbGFzcyA9IGJhc2VDbGF6ejtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHRhcmdldFxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHNvcmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJsYXlcbiAqL1xuXG5cbmZ1bmN0aW9uIG1peGluKHRhcmdldCwgc291cmNlLCBvdmVybGF5KSB7XG4gIHRhcmdldCA9ICdwcm90b3R5cGUnIGluIHRhcmdldCA/IHRhcmdldC5wcm90b3R5cGUgOiB0YXJnZXQ7XG4gIHNvdXJjZSA9ICdwcm90b3R5cGUnIGluIHNvdXJjZSA/IHNvdXJjZS5wcm90b3R5cGUgOiBzb3VyY2U7XG4gIGRlZmF1bHRzKHRhcmdldCwgc291cmNlLCBvdmVybGF5KTtcbn1cbi8qKlxuICogQ29uc2lkZXIgdHlwZWQgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fFR5cGVkQXJyYXl9IGRhdGFcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKGRhdGEpIHtcbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVvZiBkYXRhLmxlbmd0aCA9PSAnbnVtYmVyJztcbn1cbi8qKlxuICog5pWw57uE5oiW5a+56LGh6YGN5Y6GXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAqL1xuXG5cbmZ1bmN0aW9uIGVhY2gob2JqLCBjYiwgY29udGV4dCkge1xuICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG9iai5mb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBuYXRpdmVGb3JFYWNoKSB7XG4gICAgb2JqLmZvckVhY2goY2IsIGNvbnRleHQpO1xuICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIOaVsOe7hOaYoOWwhFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtBcnJheX0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cblxuZnVuY3Rpb24gbWFwKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChvYmoubWFwICYmIG9iai5tYXAgPT09IG5hdGl2ZU1hcCkge1xuICAgIHJldHVybiBvYmoubWFwKGNiLCBjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByZXN1bHQucHVzaChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge09iamVjdH0gW21lbW9dXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuXG5mdW5jdGlvbiByZWR1Y2Uob2JqLCBjYiwgbWVtbywgY29udGV4dCkge1xuICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG9iai5yZWR1Y2UgJiYgb2JqLnJlZHVjZSA9PT0gbmF0aXZlUmVkdWNlKSB7XG4gICAgcmV0dXJuIG9iai5yZWR1Y2UoY2IsIG1lbW8sIGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG1lbW8gPSBjYi5jYWxsKGNvbnRleHQsIG1lbW8sIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtbztcbiAgfVxufVxuLyoqXG4gKiDmlbDnu4Tov4fmu6RcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbHRlcihvYmosIGNiLCBjb250ZXh0KSB7XG4gIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAob2JqLmZpbHRlciAmJiBvYmouZmlsdGVyID09PSBuYXRpdmVGaWx0ZXIpIHtcbiAgICByZXR1cm4gb2JqLmZpbHRlcihjYiwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG9ialtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuLyoqXG4gKiDmlbDnu4Tpobnmn6Xmib5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKiBAcmV0dXJuIHsqfVxuICovXG5cblxuZnVuY3Rpb24gZmluZChvYmosIGNiLCBjb250ZXh0KSB7XG4gIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKSB7XG4gICAgICByZXR1cm4gb2JqW2ldO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gKiBAcGFyYW0geyp9IGNvbnRleHRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cblxuZnVuY3Rpb24gYmluZChmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBhcmdzID0gbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICB9O1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGN1cnJ5KGZ1bmMpIHtcbiAgdmFyIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncy5jb25jYXQobmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gIH07XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8ICEhdmFsdWUgJiYgdHlwZSA9PSAnb2JqZWN0Jztcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzQnVpbHRJbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gISFCVUlMVElOX09CSkVDVFtvYmpUb1N0cmluZy5jYWxsKHZhbHVlKV07XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0RvbSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZS5vd25lckRvY3VtZW50ID09PSAnb2JqZWN0Jztcbn1cbi8qKlxuICogV2hldGhlciBpcyBleGFjdGx5IE5hTi4gTm90aWNlIGlzTmFOKCdhJykgcmV0dXJucyB0cnVlLlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGVxTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG4vKipcbiAqIElmIHZhbHVlMSBpcyBub3QgbnVsbCwgdGhlbiByZXR1cm4gdmFsdWUxLCBvdGhlcndpc2UganVkZ2V0IHJlc3Qgb2YgdmFsdWVzLlxuICogTG93IHBlcmZvcm1hbmNlLlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHJldHVybiB7Kn0gRmluYWwgdmFsdWVcbiAqL1xuXG5cbmZ1bmN0aW9uIHJldHJpZXZlKHZhbHVlcykge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGFyZ3VtZW50c1tpXSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyaWV2ZTIodmFsdWUwLCB2YWx1ZTEpIHtcbiAgcmV0dXJuIHZhbHVlMCAhPSBudWxsID8gdmFsdWUwIDogdmFsdWUxO1xufVxuXG5mdW5jdGlvbiByZXRyaWV2ZTModmFsdWUwLCB2YWx1ZTEsIHZhbHVlMikge1xuICByZXR1cm4gdmFsdWUwICE9IG51bGwgPyB2YWx1ZTAgOiB2YWx1ZTEgIT0gbnVsbCA/IHZhbHVlMSA6IHZhbHVlMjtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGVuZEluZGV4XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmZ1bmN0aW9uIHNsaWNlKCkge1xuICByZXR1cm4gRnVuY3Rpb24uY2FsbC5hcHBseShuYXRpdmVTbGljZSwgYXJndW1lbnRzKTtcbn1cbi8qKlxuICogTm9ybWFsaXplIGNzcyBsaWtlZCBhcnJheSBjb25maWd1cmF0aW9uXG4gKiBlLmcuXG4gKiAgMyA9PiBbMywgMywgMywgM11cbiAqICBbNCwgMl0gPT4gWzQsIDIsIDQsIDJdXG4gKiAgWzQsIDMsIDJdID0+IFs0LCAzLCAyLCAzXVxuICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IHZhbFxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemVDc3NBcnJheSh2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIFt2YWwsIHZhbCwgdmFsLCB2YWxdO1xuICB9XG5cbiAgdmFyIGxlbiA9IHZhbC5sZW5ndGg7XG5cbiAgaWYgKGxlbiA9PT0gMikge1xuICAgIC8vIHZlcnRpY2FsIHwgaG9yaXpvbnRhbFxuICAgIHJldHVybiBbdmFsWzBdLCB2YWxbMV0sIHZhbFswXSwgdmFsWzFdXTtcbiAgfSBlbHNlIGlmIChsZW4gPT09IDMpIHtcbiAgICAvLyB0b3AgfCBob3Jpem9udGFsIHwgYm90dG9tXG4gICAgcmV0dXJuIFt2YWxbMF0sIHZhbFsxXSwgdmFsWzJdLCB2YWxbMV1dO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtib29sZWFufSBjb25kaXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cblxuXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbnZhciBwcmltaXRpdmVLZXkgPSAnX19lY19wcmltaXRpdmVfXyc7XG4vKipcbiAqIFNldCBhbiBvYmplY3QgYXMgcHJpbWl0aXZlIHRvIGJlIGlnbm9yZWQgdHJhdmVyc2luZyBjaGlsZHJlbiBpbiBjbG9uZSBvciBtZXJnZVxuICovXG5cbmZ1bmN0aW9uIHNldEFzUHJpbWl0aXZlKG9iaikge1xuICBvYmpbcHJpbWl0aXZlS2V5XSA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKG9iaikge1xuICByZXR1cm4gb2JqW3ByaW1pdGl2ZUtleV07XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPbmx5IGFwcGx5IGBvd25Qcm9wZXJ0eWAuXG4gKi9cblxuXG5mdW5jdGlvbiBIYXNoTWFwKG9iaikge1xuICBvYmogJiYgZWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gIH0sIHRoaXMpO1xufSAvLyBBZGQgcHJlZml4IHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZS5cblxuXG52YXIgSEFTSF9NQVBfUFJFRklYID0gJ19lY18nO1xudmFyIEhBU0hfTUFQX1BSRUZJWF9MRU5HVEggPSA0O1xuSGFzaE1hcC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBIYXNoTWFwLFxuICAvLyBEbyBub3QgcHJvdmlkZSBgaGFzYCBtZXRob2QgdG8gYXZvaWQgZGVmaW5pbmcgd2hhdCBpcyBgaGFzYC5cbiAgLy8gKFdlIHVzdWFsbHkgdHJlYXQgYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBhcyB0aGUgc2FtZSwgZGlmZmVyZW50XG4gIC8vIGZyb20gRVM2IE1hcCkuXG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzW0hBU0hfTUFQX1BSRUZJWCArIGtleV07XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzW0hBU0hfTUFQX1BSRUZJWCArIGtleV0gPSB2YWx1ZTsgLy8gQ29tcGFyaW5nIHdpdGggaW52b2NhdGlvbiBjaGFpbmluZywgYHJldHVybiB2YWx1ZWAgaXMgbW9yZSBjb21tb25seVxuICAgIC8vIHVzZWQgaW4gdGhpcyBjYXNlOiBgdmFyIHNvbWVWYWwgPSBtYXAuc2V0KCdhJywgZ2VuVmFsKCkpO2BcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgLy8gQWx0aG91Z2ggdXRpbC5lYWNoIGNhbiBiZSBwZXJmb3JtZWQgb24gdGhpcyBoYXNoTWFwIGRpcmVjdGx5LCB1c2VyXG4gIC8vIHNob3VsZCBub3QgdXNlIHRoZSBleHBvc2VkIGtleXMsIHdobyBhcmUgcHJlZml4ZWQuXG4gIGVhY2g6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIGNvbnRleHQgIT09IHZvaWQgMCAmJiAoY2IgPSBiaW5kKGNiLCBjb250ZXh0KSk7XG5cbiAgICBmb3IgKHZhciBwcmVmaXhlZEtleSBpbiB0aGlzKSB7XG4gICAgICB0aGlzLmhhc093blByb3BlcnR5KHByZWZpeGVkS2V5KSAmJiBjYih0aGlzW3ByZWZpeGVkS2V5XSwgcHJlZml4ZWRLZXkuc2xpY2UoSEFTSF9NQVBfUFJFRklYX0xFTkdUSCkpO1xuICAgIH1cbiAgfSxcbiAgLy8gRG8gbm90IHVzZSB0aGlzIG1ldGhvZCBpZiBwZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG4gIHJlbW92ZUtleTogZnVuY3Rpb24gKGtleSkge1xuICAgIGRlbGV0ZSB0aGlzW0hBU0hfTUFQX1BSRUZJWCArIGtleV07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hNYXAob2JqKSB7XG4gIHJldHVybiBuZXcgSGFzaE1hcChvYmopO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZXhwb3J0cy4kb3ZlcnJpZGUgPSAkb3ZlcnJpZGU7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5leHBvcnRzLm1lcmdlID0gbWVyZ2U7XG5leHBvcnRzLm1lcmdlQWxsID0gbWVyZ2VBbGw7XG5leHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcbmV4cG9ydHMuZGVmYXVsdHMgPSBkZWZhdWx0cztcbmV4cG9ydHMuY3JlYXRlQ2FudmFzID0gY3JlYXRlQ2FudmFzO1xuZXhwb3J0cy5nZXRDb250ZXh0ID0gZ2V0Q29udGV4dDtcbmV4cG9ydHMuaW5kZXhPZiA9IGluZGV4T2Y7XG5leHBvcnRzLmluaGVyaXRzID0gaW5oZXJpdHM7XG5leHBvcnRzLm1peGluID0gbWl4aW47XG5leHBvcnRzLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2U7XG5leHBvcnRzLmVhY2ggPSBlYWNoO1xuZXhwb3J0cy5tYXAgPSBtYXA7XG5leHBvcnRzLnJlZHVjZSA9IHJlZHVjZTtcbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyO1xuZXhwb3J0cy5maW5kID0gZmluZDtcbmV4cG9ydHMuYmluZCA9IGJpbmQ7XG5leHBvcnRzLmN1cnJ5ID0gY3Vycnk7XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbmV4cG9ydHMuaXNCdWlsdEluT2JqZWN0ID0gaXNCdWlsdEluT2JqZWN0O1xuZXhwb3J0cy5pc0RvbSA9IGlzRG9tO1xuZXhwb3J0cy5lcU5hTiA9IGVxTmFOO1xuZXhwb3J0cy5yZXRyaWV2ZSA9IHJldHJpZXZlO1xuZXhwb3J0cy5yZXRyaWV2ZTIgPSByZXRyaWV2ZTI7XG5leHBvcnRzLnJldHJpZXZlMyA9IHJldHJpZXZlMztcbmV4cG9ydHMuc2xpY2UgPSBzbGljZTtcbmV4cG9ydHMubm9ybWFsaXplQ3NzQXJyYXkgPSBub3JtYWxpemVDc3NBcnJheTtcbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuZXhwb3J0cy5zZXRBc1ByaW1pdGl2ZSA9IHNldEFzUHJpbWl0aXZlO1xuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuZXhwb3J0cy5jcmVhdGVIYXNoTWFwID0gY3JlYXRlSGFzaE1hcDtcbmV4cG9ydHMubm9vcCA9IG5vb3A7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxudmFyIHZlYzIgPSByZXF1aXJlKFwiLi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIERyYWdnYWJsZSA9IHJlcXVpcmUoXCIuL21peGluL0RyYWdnYWJsZVwiKTtcblxudmFyIEV2ZW50ZnVsID0gcmVxdWlyZShcIi4vbWl4aW4vRXZlbnRmdWxcIik7XG5cbi8qKlxuICogSGFuZGxlclxuICogQG1vZHVsZSB6cmVuZGVyL0hhbmRsZXJcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChzaGVueWkuOTE0QGdtYWlsLmNvbSlcbiAqL1xudmFyIFNJTEVOVCA9ICdzaWxlbnQnO1xuXG5mdW5jdGlvbiBtYWtlRXZlbnRQYWNrZXQoZXZlVHlwZSwgdGFyZ2V0SW5mbywgZXZlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBldmVUeXBlLFxuICAgIGV2ZW50OiBldmVudCxcbiAgICAvLyB0YXJnZXQgY2FuIG9ubHkgYmUgYW4gZWxlbWVudCB0aGF0IGlzIG5vdCBzaWxlbnQuXG4gICAgdGFyZ2V0OiB0YXJnZXRJbmZvLnRhcmdldCxcbiAgICAvLyB0b3BUYXJnZXQgY2FuIGJlIGEgc2lsZW50IGVsZW1lbnQuXG4gICAgdG9wVGFyZ2V0OiB0YXJnZXRJbmZvLnRvcFRhcmdldCxcbiAgICBjYW5jZWxCdWJibGU6IGZhbHNlLFxuICAgIG9mZnNldFg6IGV2ZW50LnpyWCxcbiAgICBvZmZzZXRZOiBldmVudC56clksXG4gICAgZ2VzdHVyZUV2ZW50OiBldmVudC5nZXN0dXJlRXZlbnQsXG4gICAgcGluY2hYOiBldmVudC5waW5jaFgsXG4gICAgcGluY2hZOiBldmVudC5waW5jaFksXG4gICAgcGluY2hTY2FsZTogZXZlbnQucGluY2hTY2FsZSxcbiAgICB3aGVlbERlbHRhOiBldmVudC56ckRlbHRhLFxuICAgIHpyQnlUb3VjaDogZXZlbnQuenJCeVRvdWNoLFxuICAgIHdoaWNoOiBldmVudC53aGljaFxuICB9O1xufVxuXG5mdW5jdGlvbiBFbXB0eVByb3h5KCkge31cblxuRW1wdHlQcm94eS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgaGFuZGxlck5hbWVzID0gWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZXdoZWVsJywgJ21vdXNlb3V0JywgJ21vdXNldXAnLCAnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdjb250ZXh0bWVudSddO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvSGFuZGxlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9TdG9yYWdlfSBzdG9yYWdlIFN0b3JhZ2UgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1BhaW50ZXJ9IHBhaW50ZXIgUGFpbnRlciBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZG9tL0hhbmRsZXJQcm94eX0gcHJveHkgSGFuZGxlclByb3h5IGluc3RhbmNlLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFpbnRlclJvb3QgcGFpbnRlci5yb290IChub3QgcGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSkuXG4gKi9cblxudmFyIEhhbmRsZXIgPSBmdW5jdGlvbiAoc3RvcmFnZSwgcGFpbnRlciwgcHJveHksIHBhaW50ZXJSb290KSB7XG4gIEV2ZW50ZnVsLmNhbGwodGhpcyk7XG4gIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG4gIHRoaXMucGFpbnRlclJvb3QgPSBwYWludGVyUm9vdDtcbiAgcHJveHkgPSBwcm94eSB8fCBuZXcgRW1wdHlQcm94eSgpO1xuICAvKipcbiAgICogUHJveHkgb2YgZXZlbnQuIGNhbiBiZSBEb20sIFdlYkdMU3VyZmFjZSwgZXRjLlxuICAgKi9cblxuICB0aGlzLnByb3h5ID0gcHJveHk7IC8vIEF0dGFjaCBoYW5kbGVyXG5cbiAgcHJveHkuaGFuZGxlciA9IHRoaXM7XG4gIC8qKlxuICAgKiB7dGFyZ2V0LCB0b3BUYXJnZXQsIHgsIHl9XG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIHRoaXMuX2hvdmVyZWQgPSB7fTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtEYXRlfVxuICAgKi9cblxuICB0aGlzLl9sYXN0VG91Y2hNb21lbnQ7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLl9sYXN0WDtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuX2xhc3RZO1xuICBEcmFnZ2FibGUuY2FsbCh0aGlzKTtcbiAgdXRpbC5lYWNoKGhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBwcm94eS5vbiAmJiBwcm94eS5vbihuYW1lLCB0aGlzW25hbWVdLCB0aGlzKTtcbiAgfSwgdGhpcyk7XG59O1xuXG5IYW5kbGVyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEhhbmRsZXIsXG4gIG1vdXNlbW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHggPSBldmVudC56clg7XG4gICAgdmFyIHkgPSBldmVudC56clk7XG4gICAgdmFyIGxhc3RIb3ZlcmVkID0gdGhpcy5faG92ZXJlZDtcbiAgICB2YXIgbGFzdEhvdmVyZWRUYXJnZXQgPSBsYXN0SG92ZXJlZC50YXJnZXQ7IC8vIElmIGxhc3RIb3ZlcmVkVGFyZ2V0IGlzIHJlbW92ZWQgZnJvbSB6ciAoZGV0ZWN0ZWQgYnkgJ19fenInKSBieSBzb21lIEFQSSBjYWxsXG4gICAgLy8gKGxpa2UgJ3NldE9wdGlvbicgb3IgJ2Rpc3BhdGNoQWN0aW9uJykgaW4gZXZlbnQgaGFuZGxlcnMsIHdlIHNob3VsZCBmaW5kXG4gICAgLy8gbGFzdEhvdmVyZWQgYWdhaW4gaGVyZS4gT3RoZXJ3aXNlICdtb3VzZW91dCcgY2FuIG5vdCBiZSB0cmlnZ2VyZWQgbm9ybWFsbHkuXG4gICAgLy8gU2VlICM2MTk4LlxuXG4gICAgaWYgKGxhc3RIb3ZlcmVkVGFyZ2V0ICYmICFsYXN0SG92ZXJlZFRhcmdldC5fX3pyKSB7XG4gICAgICBsYXN0SG92ZXJlZCA9IHRoaXMuZmluZEhvdmVyKGxhc3RIb3ZlcmVkLngsIGxhc3RIb3ZlcmVkLnkpO1xuICAgICAgbGFzdEhvdmVyZWRUYXJnZXQgPSBsYXN0SG92ZXJlZC50YXJnZXQ7XG4gICAgfVxuXG4gICAgdmFyIGhvdmVyZWQgPSB0aGlzLl9ob3ZlcmVkID0gdGhpcy5maW5kSG92ZXIoeCwgeSk7XG4gICAgdmFyIGhvdmVyZWRUYXJnZXQgPSBob3ZlcmVkLnRhcmdldDtcbiAgICB2YXIgcHJveHkgPSB0aGlzLnByb3h5O1xuICAgIHByb3h5LnNldEN1cnNvciAmJiBwcm94eS5zZXRDdXJzb3IoaG92ZXJlZFRhcmdldCA/IGhvdmVyZWRUYXJnZXQuY3Vyc29yIDogJ2RlZmF1bHQnKTsgLy8gTW91c2Ugb3V0IG9uIHByZXZpb3VzIGhvdmVyZWQgZWxlbWVudFxuXG4gICAgaWYgKGxhc3RIb3ZlcmVkVGFyZ2V0ICYmIGhvdmVyZWRUYXJnZXQgIT09IGxhc3RIb3ZlcmVkVGFyZ2V0KSB7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGxhc3RIb3ZlcmVkLCAnbW91c2VvdXQnLCBldmVudCk7XG4gICAgfSAvLyBNb3VzZSBtb3Zpbmcgb24gb25lIGVsZW1lbnRcblxuXG4gICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChob3ZlcmVkLCAnbW91c2Vtb3ZlJywgZXZlbnQpOyAvLyBNb3VzZSBvdmVyIG9uIGEgbmV3IGVsZW1lbnRcblxuICAgIGlmIChob3ZlcmVkVGFyZ2V0ICYmIGhvdmVyZWRUYXJnZXQgIT09IGxhc3RIb3ZlcmVkVGFyZ2V0KSB7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsICdtb3VzZW92ZXInLCBldmVudCk7XG4gICAgfVxuICB9LFxuICBtb3VzZW91dDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudCh0aGlzLl9ob3ZlcmVkLCAnbW91c2VvdXQnLCBldmVudCk7IC8vIFRoZXJlIG1pZ2h0IGJlIHNvbWUgZG9tcyBjcmVhdGVkIGJ5IHVwcGVyIGxheWVyIGFwcGxpY2F0aW9uXG4gICAgLy8gYXQgdGhlIHNhbWUgbGV2ZWwgb2YgcGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSAoZS5nLiwgdG9vbHRpcFxuICAgIC8vIGRvbSBjcmVhdGVkIGJ5IGVjaGFydHMpLCB3aGVyZSAnZ2xvYmFsb3V0JyBldmVudCBzaG91bGQgbm90XG4gICAgLy8gYmUgdHJpZ2dlcmVkIHdoZW4gbW91c2UgZW50ZXJzIHRoZXNlIGRvbXMuIChCdXQgJ21vdXNlb3V0J1xuICAgIC8vIHNob3VsZCBiZSB0cmlnZ2VyZWQgYXQgdGhlIG9yaWdpbmFsIGhvdmVyZWQgZWxlbWVudCBhcyB1c3VhbCkuXG5cbiAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRvRWxlbWVudCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgIHZhciBpbm5lckRvbTtcblxuICAgIGRvIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50ICYmIGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICB9IHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgIT0gOSAmJiAhKGlubmVyRG9tID0gZWxlbWVudCA9PT0gdGhpcy5wYWludGVyUm9vdCkpO1xuXG4gICAgIWlubmVyRG9tICYmIHRoaXMudHJpZ2dlcignZ2xvYmFsb3V0Jywge1xuICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2l6ZVxuICAgKi9cbiAgcmVzaXplOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLl9ob3ZlcmVkID0ge307XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc3BhdGNoIGV2ZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtldmVudD19IGV2ZW50QXJnc1xuICAgKi9cbiAgZGlzcGF0Y2g6IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50QXJncykge1xuICAgIHZhciBoYW5kbGVyID0gdGhpc1tldmVudE5hbWVdO1xuICAgIGhhbmRsZXIgJiYgaGFuZGxlci5jYWxsKHRoaXMsIGV2ZW50QXJncyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc3Bvc2VcbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnByb3h5LmRpc3Bvc2UoKTtcbiAgICB0aGlzLnN0b3JhZ2UgPSB0aGlzLnByb3h5ID0gdGhpcy5wYWludGVyID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICog6K6+572u6buY6K6k55qEY3Vyc29yIHN0eWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yU3R5bGU9J2RlZmF1bHQnXSDkvovlpoIgY3Jvc3NoYWlyXG4gICAqL1xuICBzZXRDdXJzb3JTdHlsZTogZnVuY3Rpb24gKGN1cnNvclN0eWxlKSB7XG4gICAgdmFyIHByb3h5ID0gdGhpcy5wcm94eTtcbiAgICBwcm94eS5zZXRDdXJzb3IgJiYgcHJveHkuc2V0Q3Vyc29yKGN1cnNvclN0eWxlKTtcbiAgfSxcblxuICAvKipcbiAgICog5LqL5Lu25YiG5Y+R5Luj55CGXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRJbmZvIHt0YXJnZXQsIHRvcFRhcmdldH0g55uu5qCH5Zu+5b2i5YWD57SgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUg5LqL5Lu25ZCN56ewXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7blr7nosaFcbiAgICovXG4gIGRpc3BhdGNoVG9FbGVtZW50OiBmdW5jdGlvbiAodGFyZ2V0SW5mbywgZXZlbnROYW1lLCBldmVudCkge1xuICAgIHRhcmdldEluZm8gPSB0YXJnZXRJbmZvIHx8IHt9O1xuICAgIHZhciBlbCA9IHRhcmdldEluZm8udGFyZ2V0O1xuXG4gICAgaWYgKGVsICYmIGVsLnNpbGVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBldmVudEhhbmRsZXIgPSAnb24nICsgZXZlbnROYW1lO1xuICAgIHZhciBldmVudFBhY2tldCA9IG1ha2VFdmVudFBhY2tldChldmVudE5hbWUsIHRhcmdldEluZm8sIGV2ZW50KTtcblxuICAgIHdoaWxlIChlbCkge1xuICAgICAgZWxbZXZlbnRIYW5kbGVyXSAmJiAoZXZlbnRQYWNrZXQuY2FuY2VsQnViYmxlID0gZWxbZXZlbnRIYW5kbGVyXS5jYWxsKGVsLCBldmVudFBhY2tldCkpO1xuICAgICAgZWwudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTtcbiAgICAgIGVsID0gZWwucGFyZW50O1xuXG4gICAgICBpZiAoZXZlbnRQYWNrZXQuY2FuY2VsQnViYmxlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZXZlbnRQYWNrZXQuY2FuY2VsQnViYmxlKSB7XG4gICAgICAvLyDlhpLms6HliLDpobbnuqcgenJlbmRlciDlr7nosaFcbiAgICAgIHRoaXMudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTsgLy8g5YiG5Y+R5LqL5Lu25Yiw55So5oi36Ieq5a6a5LmJ5bGCXG4gICAgICAvLyDnlKjmiLfmnInlj6/og73lnKjlhajlsYAgY2xpY2sg5LqL5Lu25LitIGRpc3Bvc2XvvIzmiYDku6XpnIDopoHliKTmlq3kuIsgcGFpbnRlciDmmK/lkKblrZjlnKhcblxuICAgICAgdGhpcy5wYWludGVyICYmIHRoaXMucGFpbnRlci5lYWNoT3RoZXJMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsYXllcltldmVudEhhbmRsZXJdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBsYXllcltldmVudEhhbmRsZXJdLmNhbGwobGF5ZXIsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXllci50cmlnZ2VyKSB7XG4gICAgICAgICAgbGF5ZXIudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGV9IGV4Y2x1ZGVcbiAgICogQHJldHVybiB7bW9kZWw6enJlbmRlci9FbGVtZW50fVxuICAgKiBAbWV0aG9kXG4gICAqL1xuICBmaW5kSG92ZXI6IGZ1bmN0aW9uICh4LCB5LCBleGNsdWRlKSB7XG4gICAgdmFyIGxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKTtcbiAgICB2YXIgb3V0ID0ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBob3ZlckNoZWNrUmVzdWx0O1xuXG4gICAgICBpZiAobGlzdFtpXSAhPT0gZXhjbHVkZSAvLyBnZXREaXNwbGF5TGlzdCBtYXkgaW5jbHVkZSBpZ25vcmVkIGl0ZW0gaW4gVk1MIG1vZGVcbiAgICAgICYmICFsaXN0W2ldLmlnbm9yZSAmJiAoaG92ZXJDaGVja1Jlc3VsdCA9IGlzSG92ZXIobGlzdFtpXSwgeCwgeSkpKSB7XG4gICAgICAgICFvdXQudG9wVGFyZ2V0ICYmIChvdXQudG9wVGFyZ2V0ID0gbGlzdFtpXSk7XG5cbiAgICAgICAgaWYgKGhvdmVyQ2hlY2tSZXN1bHQgIT09IFNJTEVOVCkge1xuICAgICAgICAgIG91dC50YXJnZXQgPSBsaXN0W2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbiAgfVxufTsgLy8gQ29tbW9uIGhhbmRsZXJzXG5cbnV0aWwuZWFjaChbJ2NsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNld2hlZWwnLCAnZGJsY2xpY2snLCAnY29udGV4dG1lbnUnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgSGFuZGxlci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBGaW5kIGhvdmVyIGFnYWluIHRvIGF2b2lkIGNsaWNrIGV2ZW50IGlzIGRpc3BhdGNoZWQgbWFudWFsbHkuIE9yIGNsaWNrIGlzIHRyaWdnZXJlZCB3aXRob3V0IG1vdXNlb3ZlclxuICAgIHZhciBob3ZlcmVkID0gdGhpcy5maW5kSG92ZXIoZXZlbnQuenJYLCBldmVudC56clkpO1xuICAgIHZhciBob3ZlcmVkVGFyZ2V0ID0gaG92ZXJlZC50YXJnZXQ7XG5cbiAgICBpZiAobmFtZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgIHRoaXMuX2Rvd25FbCA9IGhvdmVyZWRUYXJnZXQ7XG4gICAgICB0aGlzLl9kb3duUG9pbnQgPSBbZXZlbnQuenJYLCBldmVudC56clldOyAvLyBJbiBjYXNlIGNsaWNrIHRyaWdnZXJlZCBiZWZvcmUgbW91c2V1cFxuXG4gICAgICB0aGlzLl91cEVsID0gaG92ZXJlZFRhcmdldDtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdtb3N1ZXVwJykge1xuICAgICAgdGhpcy5fdXBFbCA9IGhvdmVyZWRUYXJnZXQ7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICBpZiAodGhpcy5fZG93bkVsICE9PSB0aGlzLl91cEVsIC8vIE9yaWdpbmFsIGNsaWNrIGV2ZW50IGlzIHRyaWdnZXJlZCBvbiB0aGUgd2hvbGUgY2FudmFzIGVsZW1lbnQsXG4gICAgICAvLyBpbmNsdWRpbmcgdGhlIGNhc2UgdGhhdCBgbW91c2Vkb3duYCAtIGBtb3VzZW1vdmVgIC0gYG1vdXNldXBgLFxuICAgICAgLy8gd2hpY2ggc2hvdWxkIGJlIGZpbHRlcmVkLCBvdGhlcndpc2UgaXQgd2lsbCBicmluZyB0cm91YmxlIHRvXG4gICAgICAvLyBwYW4gYW5kIHpvb20uXG4gICAgICB8fCAhdGhpcy5fZG93blBvaW50IC8vIEFyYml0cmFyeSB2YWx1ZVxuICAgICAgfHwgdmVjMi5kaXN0KHRoaXMuX2Rvd25Qb2ludCwgW2V2ZW50LnpyWCwgZXZlbnQuenJZXSkgPiA0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZG93blBvaW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsIG5hbWUsIGV2ZW50KTtcbiAgfTtcbn0pO1xuXG5mdW5jdGlvbiBpc0hvdmVyKGRpc3BsYXlhYmxlLCB4LCB5KSB7XG4gIGlmIChkaXNwbGF5YWJsZVtkaXNwbGF5YWJsZS5yZWN0SG92ZXIgPyAncmVjdENvbnRhaW4nIDogJ2NvbnRhaW4nXSh4LCB5KSkge1xuICAgIHZhciBlbCA9IGRpc3BsYXlhYmxlO1xuICAgIHZhciBpc1NpbGVudDtcblxuICAgIHdoaWxlIChlbCkge1xuICAgICAgLy8gSWYgY2xpcHBlZCBieSBhbmNlc3Rvci5cbiAgICAgIC8vIEZJWE1FOiBJZiBjbGlwUGF0aCBoYXMgbmVpdGhlciBzdHJva2Ugbm9yIGZpbGwsXG4gICAgICAvLyBlbC5jbGlwUGF0aC5jb250YWluKHgsIHkpIHdpbGwgYWx3YXlzIHJldHVybiBmYWxzZS5cbiAgICAgIGlmIChlbC5jbGlwUGF0aCAmJiAhZWwuY2xpcFBhdGguY29udGFpbih4LCB5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbC5zaWxlbnQpIHtcbiAgICAgICAgaXNTaWxlbnQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBlbCA9IGVsLnBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNTaWxlbnQgPyBTSUxFTlQgOiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG51dGlsLm1peGluKEhhbmRsZXIsIEV2ZW50ZnVsKTtcbnV0aWwubWl4aW4oSGFuZGxlciwgRHJhZ2dhYmxlKTtcbnZhciBfZGVmYXVsdCA9IEhhbmRsZXI7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9IYW5kbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBcnJheUN0b3IgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IEFycmF5IDogRmxvYXQzMkFycmF5O1xuLyoqXG4gKiDliJvlu7rkuIDkuKrlkJHph49cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXVxuICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdXG4gKiBAcmV0dXJuIHtWZWN0b3IyfVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZSh4LCB5KSB7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXlDdG9yKDIpO1xuXG4gIGlmICh4ID09IG51bGwpIHtcbiAgICB4ID0gMDtcbiAgfVxuXG4gIGlmICh5ID09IG51bGwpIHtcbiAgICB5ID0gMDtcbiAgfVxuXG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWkjeWItuWQkemHj+aVsOaNrlxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICogQHJldHVybiB7VmVjdG9yMn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IHZbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWFi+mahuS4gOS4quWQkemHj1xuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcmV0dXJuIHtWZWN0b3IyfVxuICovXG5cblxuZnVuY3Rpb24gY2xvbmUodikge1xuICB2YXIgb3V0ID0gbmV3IEFycmF5Q3RvcigyKTtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog6K6+572u5ZCR6YeP55qE5Lik5Liq6aG5XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtWZWN0b3IyfSDnu5PmnpxcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYTtcbiAgb3V0WzFdID0gYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP55u45YqgXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICovXG5cblxuZnVuY3Rpb24gYWRkKG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IHYxWzBdICsgdjJbMF07XG4gIG91dFsxXSA9IHYxWzFdICsgdjJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+e8qeaUvuWQjuebuOWKoFxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKi9cblxuXG5mdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIHYxLCB2MiwgYSkge1xuICBvdXRbMF0gPSB2MVswXSArIHYyWzBdICogYTtcbiAgb3V0WzFdID0gdjFbMV0gKyB2MlsxXSAqIGE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+ebuOWHj1xuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN1YihvdXQsIHYxLCB2Mikge1xuICBvdXRbMF0gPSB2MVswXSAtIHYyWzBdO1xuICBvdXRbMV0gPSB2MVsxXSAtIHYyWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlkJHph4/plb/luqZcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gbGVuKHYpIHtcbiAgcmV0dXJuIE1hdGguc3FydChsZW5TcXVhcmUodikpO1xufVxuXG52YXIgbGVuZ3RoID0gbGVuOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuLyoqXG4gKiDlkJHph4/plb/luqblubPmlrlcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cbmZ1bmN0aW9uIGxlblNxdWFyZSh2KSB7XG4gIHJldHVybiB2WzBdICogdlswXSArIHZbMV0gKiB2WzFdO1xufVxuXG52YXIgbGVuZ3RoU3F1YXJlID0gbGVuU3F1YXJlO1xuLyoqXG4gKiDlkJHph4/kuZjms5VcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKi9cblxuZnVuY3Rpb24gbXVsKG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IHYxWzBdICogdjJbMF07XG4gIG91dFsxXSA9IHYxWzFdICogdjJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+mZpOazlVxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRpdihvdXQsIHYxLCB2Mikge1xuICBvdXRbMF0gPSB2MVswXSAvIHYyWzBdO1xuICBvdXRbMV0gPSB2MVsxXSAvIHYyWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlkJHph4/ngrnkuZhcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGRvdCh2MSwgdjIpIHtcbiAgcmV0dXJuIHYxWzBdICogdjJbMF0gKyB2MVsxXSAqIHYyWzFdO1xufVxuLyoqXG4gKiDlkJHph4/nvKnmlL5cbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqIEBwYXJhbSB7bnVtYmVyfSBzXG4gKi9cblxuXG5mdW5jdGlvbiBzY2FsZShvdXQsIHYsIHMpIHtcbiAgb3V0WzBdID0gdlswXSAqIHM7XG4gIG91dFsxXSA9IHZbMV0gKiBzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlkJHph4/lvZLkuIDljJZcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqL1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIHYpIHtcbiAgdmFyIGQgPSBsZW4odik7XG5cbiAgaWYgKGQgPT09IDApIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gdlswXSAvIGQ7XG4gICAgb3V0WzFdID0gdlsxXSAvIGQ7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDorqHnrpflkJHph4/pl7Tot53nprtcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGRpc3RhbmNlKHYxLCB2Mikge1xuICByZXR1cm4gTWF0aC5zcXJ0KCh2MVswXSAtIHYyWzBdKSAqICh2MVswXSAtIHYyWzBdKSArICh2MVsxXSAtIHYyWzFdKSAqICh2MVsxXSAtIHYyWzFdKSk7XG59XG5cbnZhciBkaXN0ID0gZGlzdGFuY2U7XG4vKipcbiAqIOWQkemHj+i3neemu+W5s+aWuVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cbmZ1bmN0aW9uIGRpc3RhbmNlU3F1YXJlKHYxLCB2Mikge1xuICByZXR1cm4gKHYxWzBdIC0gdjJbMF0pICogKHYxWzBdIC0gdjJbMF0pICsgKHYxWzFdIC0gdjJbMV0pICogKHYxWzFdIC0gdjJbMV0pO1xufVxuXG52YXIgZGlzdFNxdWFyZSA9IGRpc3RhbmNlU3F1YXJlO1xuLyoqXG4gKiDmsYLotJ/lkJHph49cbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqL1xuXG5mdW5jdGlvbiBuZWdhdGUob3V0LCB2KSB7XG4gIG91dFswXSA9IC12WzBdO1xuICBvdXRbMV0gPSAtdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5o+S5YC85Lik5Liq54K5XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqL1xuXG5cbmZ1bmN0aW9uIGxlcnAob3V0LCB2MSwgdjIsIHQpIHtcbiAgb3V0WzBdID0gdjFbMF0gKyB0ICogKHYyWzBdIC0gdjFbMF0pO1xuICBvdXRbMV0gPSB2MVsxXSArIHQgKiAodjJbMV0gLSB2MVsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOefqemYteW3puS5mOWQkemHj1xuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICogQHBhcmFtIHtWZWN0b3IyfSBtXG4gKi9cblxuXG5mdW5jdGlvbiBhcHBseVRyYW5zZm9ybShvdXQsIHYsIG0pIHtcbiAgdmFyIHggPSB2WzBdO1xuICB2YXIgeSA9IHZbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5rGC5Lik5Liq5ZCR6YeP5pyA5bCP5YC8XG4gKiBAcGFyYW0gIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0gIHtWZWN0b3IyfSB2MlxuICovXG5cblxuZnVuY3Rpb24gbWluKG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IE1hdGgubWluKHYxWzBdLCB2MlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKHYxWzFdLCB2MlsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOaxguS4pOS4quWQkemHj+acgOWkp+WAvFxuICogQHBhcmFtICB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0gIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtICB7VmVjdG9yMn0gdjJcbiAqL1xuXG5cbmZ1bmN0aW9uIG1heChvdXQsIHYxLCB2Mikge1xuICBvdXRbMF0gPSBNYXRoLm1heCh2MVswXSwgdjJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heCh2MVsxXSwgdjJbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuXG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuY29weSA9IGNvcHk7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMuYWRkID0gYWRkO1xuZXhwb3J0cy5zY2FsZUFuZEFkZCA9IHNjYWxlQW5kQWRkO1xuZXhwb3J0cy5zdWIgPSBzdWI7XG5leHBvcnRzLmxlbiA9IGxlbjtcbmV4cG9ydHMubGVuZ3RoID0gbGVuZ3RoO1xuZXhwb3J0cy5sZW5TcXVhcmUgPSBsZW5TcXVhcmU7XG5leHBvcnRzLmxlbmd0aFNxdWFyZSA9IGxlbmd0aFNxdWFyZTtcbmV4cG9ydHMubXVsID0gbXVsO1xuZXhwb3J0cy5kaXYgPSBkaXY7XG5leHBvcnRzLmRvdCA9IGRvdDtcbmV4cG9ydHMuc2NhbGUgPSBzY2FsZTtcbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuZXhwb3J0cy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuZXhwb3J0cy5kaXN0ID0gZGlzdDtcbmV4cG9ydHMuZGlzdGFuY2VTcXVhcmUgPSBkaXN0YW5jZVNxdWFyZTtcbmV4cG9ydHMuZGlzdFNxdWFyZSA9IGRpc3RTcXVhcmU7XG5leHBvcnRzLm5lZ2F0ZSA9IG5lZ2F0ZTtcbmV4cG9ydHMubGVycCA9IGxlcnA7XG5leHBvcnRzLmFwcGx5VHJhbnNmb3JtID0gYXBwbHlUcmFuc2Zvcm07XG5leHBvcnRzLm1pbiA9IG1pbjtcbmV4cG9ydHMubWF4ID0gbWF4O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL3ZlY3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUT0RPIERyYWdnYWJsZSBmb3IgZ3JvdXBcbi8vIEZJWE1FIERyYWdnYWJsZSBvbiBlbGVtZW50IHdoaWNoIGhhcyBwYXJlbnQgcm90YXRpb24gb3Igc2NhbGVcbmZ1bmN0aW9uIERyYWdnYWJsZSgpIHtcbiAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5fZHJhZ1N0YXJ0LCB0aGlzKTtcbiAgdGhpcy5vbignbW91c2Vtb3ZlJywgdGhpcy5fZHJhZywgdGhpcyk7XG4gIHRoaXMub24oJ21vdXNldXAnLCB0aGlzLl9kcmFnRW5kLCB0aGlzKTtcbiAgdGhpcy5vbignZ2xvYmFsb3V0JywgdGhpcy5fZHJhZ0VuZCwgdGhpcyk7IC8vIHRoaXMuX2Ryb3BUYXJnZXQgPSBudWxsO1xuICAvLyB0aGlzLl9kcmFnZ2luZ1RhcmdldCA9IG51bGw7XG4gIC8vIHRoaXMuX3ggPSAwO1xuICAvLyB0aGlzLl95ID0gMDtcbn1cblxuRHJhZ2dhYmxlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IERyYWdnYWJsZSxcbiAgX2RyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSBlLnRhcmdldDtcblxuICAgIGlmIChkcmFnZ2luZ1RhcmdldCAmJiBkcmFnZ2luZ1RhcmdldC5kcmFnZ2FibGUpIHtcbiAgICAgIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gZHJhZ2dpbmdUYXJnZXQ7XG4gICAgICBkcmFnZ2luZ1RhcmdldC5kcmFnZ2luZyA9IHRydWU7XG4gICAgICB0aGlzLl94ID0gZS5vZmZzZXRYO1xuICAgICAgdGhpcy5feSA9IGUub2Zmc2V0WTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0oZHJhZ2dpbmdUYXJnZXQsIGUpLCAnZHJhZ3N0YXJ0JywgZS5ldmVudCk7XG4gICAgfVxuICB9LFxuICBfZHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSB0aGlzLl9kcmFnZ2luZ1RhcmdldDtcblxuICAgIGlmIChkcmFnZ2luZ1RhcmdldCkge1xuICAgICAgdmFyIHggPSBlLm9mZnNldFg7XG4gICAgICB2YXIgeSA9IGUub2Zmc2V0WTtcbiAgICAgIHZhciBkeCA9IHggLSB0aGlzLl94O1xuICAgICAgdmFyIGR5ID0geSAtIHRoaXMuX3k7XG4gICAgICB0aGlzLl94ID0geDtcbiAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJpZnQoZHgsIGR5LCBlKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0oZHJhZ2dpbmdUYXJnZXQsIGUpLCAnZHJhZycsIGUuZXZlbnQpO1xuICAgICAgdmFyIGRyb3BUYXJnZXQgPSB0aGlzLmZpbmRIb3Zlcih4LCB5LCBkcmFnZ2luZ1RhcmdldCkudGFyZ2V0O1xuICAgICAgdmFyIGxhc3REcm9wVGFyZ2V0ID0gdGhpcy5fZHJvcFRhcmdldDtcbiAgICAgIHRoaXMuX2Ryb3BUYXJnZXQgPSBkcm9wVGFyZ2V0O1xuXG4gICAgICBpZiAoZHJhZ2dpbmdUYXJnZXQgIT09IGRyb3BUYXJnZXQpIHtcbiAgICAgICAgaWYgKGxhc3REcm9wVGFyZ2V0ICYmIGRyb3BUYXJnZXQgIT09IGxhc3REcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShsYXN0RHJvcFRhcmdldCwgZSksICdkcmFnbGVhdmUnLCBlLmV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcm9wVGFyZ2V0ICYmIGRyb3BUYXJnZXQgIT09IGxhc3REcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShkcm9wVGFyZ2V0LCBlKSwgJ2RyYWdlbnRlcicsIGUuZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBfZHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSB0aGlzLl9kcmFnZ2luZ1RhcmdldDtcblxuICAgIGlmIChkcmFnZ2luZ1RhcmdldCkge1xuICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKGRyYWdnaW5nVGFyZ2V0LCBlKSwgJ2RyYWdlbmQnLCBlLmV2ZW50KTtcblxuICAgIGlmICh0aGlzLl9kcm9wVGFyZ2V0KSB7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKHRoaXMuX2Ryb3BUYXJnZXQsIGUpLCAnZHJvcCcsIGUuZXZlbnQpO1xuICAgIH1cblxuICAgIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gbnVsbDtcbiAgICB0aGlzLl9kcm9wVGFyZ2V0ID0gbnVsbDtcbiAgfVxufTtcblxuZnVuY3Rpb24gcGFyYW0odGFyZ2V0LCBlKSB7XG4gIHJldHVybiB7XG4gICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgdG9wVGFyZ2V0OiBlICYmIGUudG9wVGFyZ2V0XG4gIH07XG59XG5cbnZhciBfZGVmYXVsdCA9IERyYWdnYWJsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL21peGluL0RyYWdnYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIOS6i+S7tuaJqeWxlVxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG52YXIgYXJyeVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuLyoqXG4gKiDkuovku7bliIblj5HlmahcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bFxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxudmFyIEV2ZW50ZnVsID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl8kaGFuZGxlcnMgPSB7fTtcbn07XG5cbkV2ZW50ZnVsLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEV2ZW50ZnVsLFxuXG4gIC8qKlxuICAgKiDljZXmrKHop6blj5Hnu5HlrprvvIx0cmlnZ2Vy5ZCO6ZSA5q+BXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCDkuovku7blkI1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDlk43lupTlh73mlbBcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICovXG4gIG9uZTogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuXG4gICAgaWYgKCFoYW5kbGVyIHx8ICFldmVudCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKCFfaFtldmVudF0pIHtcbiAgICAgIF9oW2V2ZW50XSA9IFtdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2hbZXZlbnRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoX2hbZXZlbnRdW2ldLmggPT09IGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2hbZXZlbnRdLnB1c2goe1xuICAgICAgaDogaGFuZGxlcixcbiAgICAgIG9uZTogdHJ1ZSxcbiAgICAgIGN0eDogY29udGV4dCB8fCB0aGlzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog57uR5a6a5LqL5Lu2XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCDkuovku7blkI1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDkuovku7blpITnkIblh73mlbBcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICAgKi9cbiAgb246IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlciwgY29udGV4dCkge1xuICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcblxuICAgIGlmICghaGFuZGxlciB8fCAhZXZlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICghX2hbZXZlbnRdKSB7XG4gICAgICBfaFtldmVudF0gPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9oW2V2ZW50XS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKF9oW2V2ZW50XVtpXS5oID09PSBoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9oW2V2ZW50XS5wdXNoKHtcbiAgICAgIGg6IGhhbmRsZXIsXG4gICAgICBvbmU6IGZhbHNlLFxuICAgICAgY3R4OiBjb250ZXh0IHx8IHRoaXNcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmmK/lkKbnu5Hlrprkuobkuovku7ZcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgZXZlbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzU2lsZW50OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG4gICAgcmV0dXJuIF9oW2V2ZW50XSAmJiBfaFtldmVudF0ubGVuZ3RoO1xuICB9LFxuXG4gIC8qKlxuICAgKiDop6Pnu5Hkuovku7ZcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl0g5LqL5Lu25aSE55CG5Ye95pWwXG4gICAqL1xuICBvZmY6IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlcikge1xuICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcblxuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHRoaXMuXyRoYW5kbGVycyA9IHt9O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIGlmIChfaFtldmVudF0pIHtcbiAgICAgICAgdmFyIG5ld0xpc3QgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9oW2V2ZW50XS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoX2hbZXZlbnRdW2ldWydoJ10gIT0gaGFuZGxlcikge1xuICAgICAgICAgICAgbmV3TGlzdC5wdXNoKF9oW2V2ZW50XVtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX2hbZXZlbnRdID0gbmV3TGlzdDtcbiAgICAgIH1cblxuICAgICAgaWYgKF9oW2V2ZW50XSAmJiBfaFtldmVudF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSBfaFtldmVudF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBfaFtldmVudF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOS6i+S7tuWIhuWPkVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcbiAgICovXG4gIHRyaWdnZXI6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKHRoaXMuXyRoYW5kbGVyc1t0eXBlXSkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgYXJnTGVuID0gYXJncy5sZW5ndGg7XG5cbiAgICAgIGlmIChhcmdMZW4gPiAzKSB7XG4gICAgICAgIGFyZ3MgPSBhcnJ5U2xpY2UuY2FsbChhcmdzLCAxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzW3R5cGVdO1xuICAgICAgdmFyIGxlbiA9IF9oLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgIC8vIE9wdGltaXplIGFkdmlzZSBmcm9tIGJhY2tib25lXG4gICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSwgYXJnc1sxXSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSwgYXJnc1sxXSwgYXJnc1syXSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIGhhdmUgbW9yZSB0aGFuIDIgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICBfaFtpXVsnaCddLmFwcGx5KF9oW2ldWydjdHgnXSwgYXJncyk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9oW2ldWydvbmUnXSkge1xuICAgICAgICAgIF9oLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgIGxlbi0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDluKbmnIljb250ZXh055qE5LqL5Lu25YiG5Y+RLCDmnIDlkI7kuIDkuKrlj4LmlbDmmK/kuovku7blm57osIPnmoRjb250ZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgKi9cbiAgdHJpZ2dlcldpdGhDb250ZXh0OiBmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmICh0aGlzLl8kaGFuZGxlcnNbdHlwZV0pIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIGFyZ0xlbiA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgICBpZiAoYXJnTGVuID4gNCkge1xuICAgICAgICBhcmdzID0gYXJyeVNsaWNlLmNhbGwoYXJncywgMSwgYXJncy5sZW5ndGggLSAxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN0eCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVyc1t0eXBlXTtcbiAgICAgIHZhciBsZW4gPSBfaC5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAvLyBPcHRpbWl6ZSBhZHZpc2UgZnJvbSBiYWNrYm9uZVxuICAgICAgICBzd2l0Y2ggKGFyZ0xlbikge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChjdHgpO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChjdHgsIGFyZ3NbMV0pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChjdHgsIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBoYXZlIG1vcmUgdGhhbiAyIGdpdmVuIGFyZ3VtZW50c1xuICAgICAgICAgICAgX2hbaV1bJ2gnXS5hcHBseShjdHgsIGFyZ3MpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfaFtpXVsnb25lJ10pIHtcbiAgICAgICAgICBfaC5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICBsZW4tLTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTsgLy8g5a+56LGh5Y+v5Lul6YCa6L+HIG9ueHh4eCDnu5Hlrprkuovku7ZcblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25jbGlja1xuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2VvdmVyXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZW91dFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2Vtb3ZlXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZXdoZWVsXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZWRvd25cbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNldXBcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdzdGFydFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ2VuZFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ2VudGVyXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnbGVhdmVcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdvdmVyXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcm9wXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxudmFyIF9kZWZhdWx0ID0gRXZlbnRmdWw7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9taXhpbi9FdmVudGZ1bC5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwiLi9jb3JlL2VudlwiKTtcblxudmFyIEdyb3VwID0gcmVxdWlyZShcIi4vY29udGFpbmVyL0dyb3VwXCIpO1xuXG52YXIgdGltc29ydCA9IHJlcXVpcmUoXCIuL2NvcmUvdGltc29ydFwiKTtcblxuLyoqXG4gKiBTdG9yYWdl5YaF5a655LuT5bqT5qih5Z2XXG4gKiBAbW9kdWxlIHpyZW5kZXIvU3RvcmFnZVxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiBAYXV0aG9yIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nLylcbiAqL1xuLy8gVXNlIHRpbXNvcnQgYmVjYXVzZSBpbiBtb3N0IGNhc2UgZWxlbWVudHMgYXJlIHBhcnRpYWxseSBzb3J0ZWRcbi8vIGh0dHBzOi8vanNmaWRkbGUubmV0L3Bpc3NhbmcvanI0eDdtZG0vOC9cbmZ1bmN0aW9uIHNoYXBlQ29tcGFyZUZ1bmMoYSwgYikge1xuICBpZiAoYS56bGV2ZWwgPT09IGIuemxldmVsKSB7XG4gICAgaWYgKGEueiA9PT0gYi56KSB7XG4gICAgICAvLyBpZiAoYS56MiA9PT0gYi56Mikge1xuICAgICAgLy8gICAgIC8vIEZJWE1FIFNsb3cgaGFzIHJlbmRlcmlkeCBjb21wYXJlXG4gICAgICAvLyAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMDg4MzQyMS9zb3J0aW5nLWluLWphdmFzY3JpcHQtc2hvdWxkLWV2ZXJ5LWNvbXBhcmUtZnVuY3Rpb24taGF2ZS1hLXJldHVybi0wLXN0YXRlbWVudFxuICAgICAgLy8gICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92OC92OC9ibG9iLzQ3Y2NlNTQ0YTMxZWQ1NTc3ZmZlMjk2M2Y2N2FjYjQxNDRlZTAyMzIvc3JjL2pzL2FycmF5LmpzI0wxMDEyXG4gICAgICAvLyAgICAgcmV0dXJuIGEuX19yZW5kZXJpZHggLSBiLl9fcmVuZGVyaWR4O1xuICAgICAgLy8gfVxuICAgICAgcmV0dXJuIGEuejIgLSBiLnoyO1xuICAgIH1cblxuICAgIHJldHVybiBhLnogLSBiLno7XG4gIH1cblxuICByZXR1cm4gYS56bGV2ZWwgLSBiLnpsZXZlbDtcbn1cbi8qKlxuICog5YaF5a655LuT5bqTIChNKVxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL1N0b3JhZ2VcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIFN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICB0aGlzLl9yb290cyA9IFtdO1xuICB0aGlzLl9kaXNwbGF5TGlzdCA9IFtdO1xuICB0aGlzLl9kaXNwbGF5TGlzdExlbiA9IDA7XG59O1xuXG5TdG9yYWdlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFN0b3JhZ2UsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgKlxuICAgKi9cbiAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3Jvb3RzW2ldLnRyYXZlcnNlKGNiLCBjb250ZXh0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOi/lOWbnuaJgOacieWbvuW9oueahOe7mOWItumYn+WIl1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1cGRhdGU9ZmFsc2VdIOaYr+WQpuWcqOi/lOWbnuWJjeabtOaWsOivpeaVsOe7hFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSWdub3JlPWZhbHNlXSDmmK/lkKbljIXlkKsgaWdub3JlIOeahOaVsOe7hCwg5ZyoIHVwZGF0ZSDkuLogdHJ1ZSDnmoTml7blgJnmnInmlYhcbiAgICpcbiAgICog6K+m6KeBe0BsaW5rIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUucHJvdG90eXBlLnVwZGF0ZURpc3BsYXlMaXN0fVxuICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZT59XG4gICAqL1xuICBnZXREaXNwbGF5TGlzdDogZnVuY3Rpb24gKHVwZGF0ZSwgaW5jbHVkZUlnbm9yZSkge1xuICAgIGluY2x1ZGVJZ25vcmUgPSBpbmNsdWRlSWdub3JlIHx8IGZhbHNlO1xuXG4gICAgaWYgKHVwZGF0ZSkge1xuICAgICAgdGhpcy51cGRhdGVEaXNwbGF5TGlzdChpbmNsdWRlSWdub3JlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZGlzcGxheUxpc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOabtOaWsOWbvuW9oueahOe7mOWItumYn+WIl+OAglxuICAgKiDmr4/mrKHnu5jliLbliY3pg73kvJrosIPnlKjvvIzor6Xmlrnms5XkvJrlhYjmt7HluqbkvJjlhYjpgY3ljobmlbTkuKrmoJHvvIzmm7TmlrDmiYDmnIlHcm91cOWSjFNoYXBl55qE5Y+Y5o2i5bm25LiU5oqK5omA5pyJ5Y+v6KeB55qEU2hhcGXkv53lrZjliLDmlbDnu4TkuK3vvIxcbiAgICog5pyA5ZCO5qC55o2u57uY5Yi255qE5LyY5YWI57qn77yIemxldmVsID4geiA+IOaPkuWFpemhuuW6j++8ieaOkuW6j+W+l+WIsOe7mOWItumYn+WIl1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSWdub3JlPWZhbHNlXSDmmK/lkKbljIXlkKsgaWdub3JlIOeahOaVsOe7hFxuICAgKi9cbiAgdXBkYXRlRGlzcGxheUxpc3Q6IGZ1bmN0aW9uIChpbmNsdWRlSWdub3JlKSB7XG4gICAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xuICAgIHZhciByb290cyA9IHRoaXMuX3Jvb3RzO1xuICAgIHZhciBkaXNwbGF5TGlzdCA9IHRoaXMuX2Rpc3BsYXlMaXN0O1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJvb3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLl91cGRhdGVBbmRBZGREaXNwbGF5YWJsZShyb290c1tpXSwgbnVsbCwgaW5jbHVkZUlnbm9yZSk7XG4gICAgfVxuXG4gICAgZGlzcGxheUxpc3QubGVuZ3RoID0gdGhpcy5fZGlzcGxheUxpc3RMZW47IC8vIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkaXNwbGF5TGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIC8vICAgICBkaXNwbGF5TGlzdFtpXS5fX3JlbmRlcmlkeCA9IGk7XG4gICAgLy8gfVxuICAgIC8vIGRpc3BsYXlMaXN0LnNvcnQoc2hhcGVDb21wYXJlRnVuYyk7XG5cbiAgICBlbnYuY2FudmFzU3VwcG9ydGVkICYmIHRpbXNvcnQoZGlzcGxheUxpc3QsIHNoYXBlQ29tcGFyZUZ1bmMpO1xuICB9LFxuICBfdXBkYXRlQW5kQWRkRGlzcGxheWFibGU6IGZ1bmN0aW9uIChlbCwgY2xpcFBhdGhzLCBpbmNsdWRlSWdub3JlKSB7XG4gICAgaWYgKGVsLmlnbm9yZSAmJiAhaW5jbHVkZUlnbm9yZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsLmJlZm9yZVVwZGF0ZSgpO1xuXG4gICAgaWYgKGVsLl9fZGlydHkpIHtcbiAgICAgIGVsLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGVsLmFmdGVyVXBkYXRlKCk7XG4gICAgdmFyIHVzZXJTZXRDbGlwUGF0aCA9IGVsLmNsaXBQYXRoO1xuXG4gICAgaWYgKHVzZXJTZXRDbGlwUGF0aCkge1xuICAgICAgLy8gRklYTUUg5pWI546H5b2x5ZONXG4gICAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICAgIGNsaXBQYXRocyA9IGNsaXBQYXRocy5zbGljZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xpcFBhdGhzID0gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50Q2xpcFBhdGggPSB1c2VyU2V0Q2xpcFBhdGg7XG4gICAgICB2YXIgcGFyZW50Q2xpcFBhdGggPSBlbDsgLy8gUmVjdXJzaXZlbHkgYWRkIGNsaXAgcGF0aFxuXG4gICAgICB3aGlsZSAoY3VycmVudENsaXBQYXRoKSB7XG4gICAgICAgIC8vIGNsaXBQYXRoIOeahOWPmOaNouaYr+WfuuS6juS9v+eUqOi/meS4qiBjbGlwUGF0aCDnmoTlhYPntKBcbiAgICAgICAgY3VycmVudENsaXBQYXRoLnBhcmVudCA9IHBhcmVudENsaXBQYXRoO1xuICAgICAgICBjdXJyZW50Q2xpcFBhdGgudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIGNsaXBQYXRocy5wdXNoKGN1cnJlbnRDbGlwUGF0aCk7XG4gICAgICAgIHBhcmVudENsaXBQYXRoID0gY3VycmVudENsaXBQYXRoO1xuICAgICAgICBjdXJyZW50Q2xpcFBhdGggPSBjdXJyZW50Q2xpcFBhdGguY2xpcFBhdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVsLmlzR3JvdXApIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLl9jaGlsZHJlbjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTsgLy8gRm9yY2UgdG8gbWFyayBhcyBkaXJ0eSBpZiBncm91cCBpcyBkaXJ0eVxuICAgICAgICAvLyBGSVhNRSBfX2RpcnR5UGF0aCA/XG5cbiAgICAgICAgaWYgKGVsLl9fZGlydHkpIHtcbiAgICAgICAgICBjaGlsZC5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUFuZEFkZERpc3BsYXlhYmxlKGNoaWxkLCBjbGlwUGF0aHMsIGluY2x1ZGVJZ25vcmUpO1xuICAgICAgfSAvLyBNYXJrIGdyb3VwIGNsZWFuIGhlcmVcblxuXG4gICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLl9fY2xpcFBhdGhzID0gY2xpcFBhdGhzO1xuICAgICAgdGhpcy5fZGlzcGxheUxpc3RbdGhpcy5fZGlzcGxheUxpc3RMZW4rK10gPSBlbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWbvuW9oihTaGFwZSnmiJbogIXnu4QoR3JvdXAp5Yiw5qC56IqC54K5XG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICovXG4gIGFkZFJvb3Q6IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbC5fX3N0b3JhZ2UgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWwgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgZWwuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2UodGhpcyk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRUb1N0b3JhZ2UoZWwpO1xuXG4gICAgdGhpcy5fcm9vdHMucHVzaChlbCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWIoOmZpOaMh+WumueahOWbvuW9oihTaGFwZSnmiJbogIXnu4QoR3JvdXApXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBbZWxdIOWmguaenOS4uuepuua4heepuuaVtOS4qlN0b3JhZ2VcbiAgICovXG4gIGRlbFJvb3Q6IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbCA9PSBudWxsKSB7XG4gICAgICAvLyDkuI3mjIflrpplbOa4heepulxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9yb290cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3RzW2ldO1xuXG4gICAgICAgIGlmIChyb290IGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICByb290LmRlbENoaWxkcmVuRnJvbVN0b3JhZ2UodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fcm9vdHMgPSBbXTtcbiAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0ID0gW107XG4gICAgICB0aGlzLl9kaXNwbGF5TGlzdExlbiA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZGVsUm9vdChlbFtpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaWR4ID0gdXRpbC5pbmRleE9mKHRoaXMuX3Jvb3RzLCBlbCk7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIHRoaXMuZGVsRnJvbVN0b3JhZ2UoZWwpO1xuXG4gICAgICB0aGlzLl9yb290cy5zcGxpY2UoaWR4LCAxKTtcblxuICAgICAgaWYgKGVsIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgZWwuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGFkZFRvU3RvcmFnZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgZWwuX19zdG9yYWdlID0gdGhpcztcbiAgICBlbC5kaXJ0eShmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGRlbEZyb21TdG9yYWdlOiBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLl9fc3RvcmFnZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa4heepuuW5tuS4lOmHiuaUvlN0b3JhZ2VcbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9yZW5kZXJMaXN0ID0gdGhpcy5fcm9vdHMgPSBudWxsO1xuICB9LFxuICBkaXNwbGF5YWJsZVNvcnRGdW5jOiBzaGFwZUNvbXBhcmVGdW5jXG59O1xudmFyIF9kZWZhdWx0ID0gU3RvcmFnZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL1N0b3JhZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoXCIuLi9FbGVtZW50XCIpO1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4uL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG4vKipcbiAqIEdyb3Vw5piv5LiA5Liq5a655Zmo77yM5Y+v5Lul5o+S5YWl5a2Q6IqC54K577yMR3JvdXDnmoTlj5jmjaLkuZ/kvJrooqvlupTnlKjliLDlrZDoioLngrnkuIpcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL0dyb3VwXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBHcm91cCA9IHJlcXVpcmUoJ3pyZW5kZXIvY29udGFpbmVyL0dyb3VwJyk7XG4gKiAgICAgdmFyIENpcmNsZSA9IHJlcXVpcmUoJ3pyZW5kZXIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUnKTtcbiAqICAgICB2YXIgZyA9IG5ldyBHcm91cCgpO1xuICogICAgIGcucG9zaXRpb25bMF0gPSAxMDA7XG4gKiAgICAgZy5wb3NpdGlvblsxXSA9IDEwMDtcbiAqICAgICBnLmFkZChuZXcgQ2lyY2xlKHtcbiAqICAgICAgICAgc3R5bGU6IHtcbiAqICAgICAgICAgICAgIHg6IDEwMCxcbiAqICAgICAgICAgICAgIHk6IDEwMCxcbiAqICAgICAgICAgICAgIHI6IDIwLFxuICogICAgICAgICB9XG4gKiAgICAgfSkpO1xuICogICAgIHpyLmFkZChnKTtcbiAqL1xuXG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0dyb3VwXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gKi9cbnZhciBHcm91cCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBFbGVtZW50LmNhbGwodGhpcywgb3B0cyk7XG5cbiAgZm9yICh2YXIga2V5IGluIG9wdHMpIHtcbiAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICB0aGlzW2tleV0gPSBvcHRzW2tleV07XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcbiAgdGhpcy5fX3N0b3JhZ2UgPSBudWxsO1xuICB0aGlzLl9fZGlydHkgPSB0cnVlO1xufTtcblxuR3JvdXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogR3JvdXAsXG4gIGlzR3JvdXA6IHRydWUsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0eXBlOiAnZ3JvdXAnLFxuXG4gIC8qKlxuICAgKiDmiYDmnInlrZDlrZnlhYPntKDmmK/lkKblk43lupTpvKDmoIfkuovku7ZcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2NvbnRhaW5lci9Hcm91cCNzaWxlbnRcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvRWxlbWVudD59XG4gICAqL1xuICBjaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5zbGljZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bmjIflrpogaW5kZXgg55qE5YS/5a2Q6IqC54K5XG4gICAqIEBwYXJhbSAge251bWJlcn0gaWR4XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gICAqL1xuICBjaGlsZEF0OiBmdW5jdGlvbiAoaWR4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuW2lkeF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIOiOt+WPluaMh+WumuWQjeWtl+eahOWEv+WtkOiKgueCuVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWVcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cbiAgICovXG4gIGNoaWxkT2ZOYW1lOiBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGNoaWxkcmVuW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgY2hpbGRDb3VudDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWtkOiKgueCueWIsOacgOWQjlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAqL1xuICBhZGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCAmJiBjaGlsZCAhPT0gdGhpcyAmJiBjaGlsZC5wYXJlbnQgIT09IHRoaXMpIHtcbiAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY2hpbGQpO1xuXG4gICAgICB0aGlzLl9kb0FkZChjaGlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWtkOiKgueCueWcqCBuZXh0U2libGluZyDkuYvliY1cbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBjaGlsZFxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IG5leHRTaWJsaW5nXG4gICAqL1xuICBhZGRCZWZvcmU6IGZ1bmN0aW9uIChjaGlsZCwgbmV4dFNpYmxpbmcpIHtcbiAgICBpZiAoY2hpbGQgJiYgY2hpbGQgIT09IHRoaXMgJiYgY2hpbGQucGFyZW50ICE9PSB0aGlzICYmIG5leHRTaWJsaW5nICYmIG5leHRTaWJsaW5nLnBhcmVudCA9PT0gdGhpcykge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgICB2YXIgaWR4ID0gY2hpbGRyZW4uaW5kZXhPZihuZXh0U2libGluZyk7XG5cbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaWR4LCAwLCBjaGlsZCk7XG5cbiAgICAgICAgdGhpcy5fZG9BZGQoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfZG9BZGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZC5wYXJlbnQpIHtcbiAgICAgIGNoaWxkLnBhcmVudC5yZW1vdmUoY2hpbGQpO1xuICAgIH1cblxuICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICB2YXIgenIgPSB0aGlzLl9fenI7XG5cbiAgICBpZiAoc3RvcmFnZSAmJiBzdG9yYWdlICE9PSBjaGlsZC5fX3N0b3JhZ2UpIHtcbiAgICAgIHN0b3JhZ2UuYWRkVG9TdG9yYWdlKGNoaWxkKTtcblxuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgY2hpbGQuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgenIgJiYgenIucmVmcmVzaCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDnp7vpmaTlrZDoioLngrlcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBjaGlsZFxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICB2YXIgenIgPSB0aGlzLl9fenI7XG4gICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICB2YXIgaWR4ID0genJVdGlsLmluZGV4T2YoY2hpbGRyZW4sIGNoaWxkKTtcblxuICAgIGlmIChpZHggPCAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjaGlsZHJlbi5zcGxpY2UoaWR4LCAxKTtcbiAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuXG4gICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICBjaGlsZC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHpyICYmIHpyLnJlZnJlc2goKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog56e76Zmk5omA5pyJ5a2Q6IqC54K5XG4gICAqL1xuICByZW1vdmVBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX19zdG9yYWdlO1xuICAgIHZhciBjaGlsZDtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgICAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZShjaGlsZCk7XG5cbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICBjaGlsZC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgfVxuXG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog6YGN5Y6G5omA5pyJ5a2Q6IqC54K5XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgKi9cbiAgZWFjaENoaWxkOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgY2IuY2FsbChjb250ZXh0LCBjaGlsZCwgaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3seW6puS8mOWFiOmBjeWOhuaJgOacieWtkOWtmeiKgueCuVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICovXG4gIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgIGNiLmNhbGwoY29udGV4dCwgY2hpbGQpO1xuXG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICBjaGlsZC50cmF2ZXJzZShjYiwgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZENoaWxkcmVuVG9TdG9yYWdlOiBmdW5jdGlvbiAoc3RvcmFnZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuICAgICAgc3RvcmFnZS5hZGRUb1N0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICBjaGlsZC5hZGRDaGlsZHJlblRvU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRlbENoaWxkcmVuRnJvbVN0b3JhZ2U6IGZ1bmN0aW9uIChzdG9yYWdlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICBzdG9yYWdlLmRlbEZyb21TdG9yYWdlKGNoaWxkKTtcblxuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAqL1xuICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uIChpbmNsdWRlQ2hpbGRyZW4pIHtcbiAgICAvLyBUT0RPIENhY2hpbmdcbiAgICB2YXIgcmVjdCA9IG51bGw7XG4gICAgdmFyIHRtcFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuICAgIHZhciBjaGlsZHJlbiA9IGluY2x1ZGVDaGlsZHJlbiB8fCB0aGlzLl9jaGlsZHJlbjtcbiAgICB2YXIgdG1wTWF0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgICAgaWYgKGNoaWxkLmlnbm9yZSB8fCBjaGlsZC5pbnZpc2libGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZFJlY3QgPSBjaGlsZC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBjaGlsZC5nZXRMb2NhbFRyYW5zZm9ybSh0bXBNYXQpOyAvLyBUT0RPXG4gICAgICAvLyBUaGUgYm91bmRpbmdSZWN0IGNhY2x1YXRlZCBieSB0cmFuc2Zvcm1pbmcgb3JpZ2luYWxcbiAgICAgIC8vIHJlY3QgbWF5IGJlIGJpZ2dlciB0aGFuIHRoZSBhY3R1YWwgYnVuZGluZ1JlY3Qgd2hlbiByb3RhdGlvblxuICAgICAgLy8gaXMgdXNlZC4gKENvbnNpZGVyIGEgY2lyY2xlIHJvdGF0ZWQgYWdpbnN0IGl0cyBjZW50ZXIsIHdoZXJlXG4gICAgICAvLyB0aGUgYWN0dWFsIGJvdW5kaW5nUmVjdCBzaG91bGQgYmUgdGhlIHNhbWUgYXMgdGhhdCBub3QgYmVcbiAgICAgIC8vIHJvdGF0ZWQuKSBCdXQgd2UgY2FuIG5vdCBmaW5kIGJldHRlciBhcHByb2FjaCB0byBjYWxjdWxhdGVcbiAgICAgIC8vIGFjdHVhbCBib3VuZGluZ1JlY3QgeWV0LCBjb25zaWRlcmluZyBwZXJmb3JtYW5jZS5cblxuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICB0bXBSZWN0LmNvcHkoY2hpbGRSZWN0KTtcbiAgICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgICAgICByZWN0ID0gcmVjdCB8fCB0bXBSZWN0LmNsb25lKCk7XG4gICAgICAgIHJlY3QudW5pb24odG1wUmVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWN0ID0gcmVjdCB8fCBjaGlsZFJlY3QuY2xvbmUoKTtcbiAgICAgICAgcmVjdC51bmlvbihjaGlsZFJlY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZWN0IHx8IHRtcFJlY3Q7XG4gIH1cbn07XG56clV0aWwuaW5oZXJpdHMoR3JvdXAsIEVsZW1lbnQpO1xudmFyIF9kZWZhdWx0ID0gR3JvdXA7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXAuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBndWlkID0gcmVxdWlyZShcIi4vY29yZS9ndWlkXCIpO1xuXG52YXIgRXZlbnRmdWwgPSByZXF1aXJlKFwiLi9taXhpbi9FdmVudGZ1bFwiKTtcblxudmFyIFRyYW5zZm9ybWFibGUgPSByZXF1aXJlKFwiLi9taXhpbi9UcmFuc2Zvcm1hYmxlXCIpO1xuXG52YXIgQW5pbWF0YWJsZSA9IHJlcXVpcmUoXCIuL21peGluL0FuaW1hdGFibGVcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL0VsZW1lbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL21peGluL0FuaW1hdGFibGV9XG4gKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZX1cbiAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bH1cbiAqL1xudmFyIEVsZW1lbnQgPSBmdW5jdGlvbiAob3B0cykge1xuICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgVHJhbnNmb3JtYWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuICBFdmVudGZ1bC5jYWxsKHRoaXMsIG9wdHMpO1xuICBBbmltYXRhYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gIC8qKlxuICAgKiDnlLvluIPlhYPntKBJRFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cblxuICB0aGlzLmlkID0gb3B0cy5pZCB8fCBndWlkKCk7XG59O1xuXG5FbGVtZW50LnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIOWFg+e0oOexu+Wei1xuICAgKiBFbGVtZW50IHR5cGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHR5cGU6ICdlbGVtZW50JyxcblxuICAvKipcbiAgICog5YWD57Sg5ZCN5a2XXG4gICAqIEVsZW1lbnQgbmFtZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgbmFtZTogJycsXG5cbiAgLyoqXG4gICAqIFpSZW5kZXIg5a6e5L6L5a+56LGh77yM5Lya5ZyoIGVsZW1lbnQg5re75Yqg5YiwIHpyZW5kZXIg5a6e5L6L5Lit5ZCO6Ieq5Yqo6LWL5YC8XG4gICAqIFpSZW5kZXIgaW5zdGFuY2Ugd2lsbCBiZSBhc3NpZ25lZCB3aGVuIGVsZW1lbnQgaXMgYXNzb2NpYXRlZCB3aXRoIHpyZW5kZXJcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL0VsZW1lbnQjX196clxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn1cbiAgICovXG4gIF9fenI6IG51bGwsXG5cbiAgLyoqXG4gICAqIOWbvuW9ouaYr+WQpuW/veeVpe+8jOS4unRydWXml7blv73nlaXlm77lvaLnmoTnu5jliLbku6Xlj4rkuovku7bop6blj5FcbiAgICogSWYgaWdub3JlIGRyYXdpbmcgYW5kIGV2ZW50cyBvZiB0aGUgZWxlbWVudCBvYmplY3RcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL0VsZW1lbnQjaWdub3JlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgaWdub3JlOiBmYWxzZSxcblxuICAvKipcbiAgICog55So5LqO6KOB5Ymq55qE6Lev5b6EKHNoYXBlKe+8jOaJgOaciSBHcm91cCDlhoXnmoTot6/lvoTlnKjnu5jliLbml7bpg73kvJrooqvov5nkuKrot6/lvoToo4HliapcbiAgICog6K+l6Lev5b6E5Lya57un5om/6KKr6KOB5YeP5a+56LGh55qE5Y+Y5o2iXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9XG4gICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMmRjb250ZXh0LyNjbGlwcGluZy1yZWdpb25cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICBjbGlwUGF0aDogbnVsbCxcblxuICAvKipcbiAgICogRHJpZnQgZWxlbWVudFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR4IGR4IG9uIHRoZSBnbG9iYWwgc3BhY2VcbiAgICogQHBhcmFtICB7bnVtYmVyfSBkeSBkeSBvbiB0aGUgZ2xvYmFsIHNwYWNlXG4gICAqL1xuICBkcmlmdDogZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgIHN3aXRjaCAodGhpcy5kcmFnZ2FibGUpIHtcbiAgICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgICBkeSA9IDA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICAgIGR4ID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcblxuICAgIGlmICghbSkge1xuICAgICAgbSA9IHRoaXMudHJhbnNmb3JtID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgIH1cblxuICAgIG1bNF0gKz0gZHg7XG4gICAgbVs1XSArPSBkeTtcbiAgICB0aGlzLmRlY29tcG9zZVRyYW5zZm9ybSgpO1xuICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIb29rIGJlZm9yZSB1cGRhdGVcbiAgICovXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gKCkge30sXG5cbiAgLyoqXG4gICAqIEhvb2sgYWZ0ZXIgdXBkYXRlXG4gICAqL1xuICBhZnRlclVwZGF0ZTogZnVuY3Rpb24gKCkge30sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBlYWNoIGZyYW1lXG4gICAqL1xuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICovXG4gIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHt9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBhdHRyS1Y6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSA9PT0gJ3Bvc2l0aW9uJyB8fCBrZXkgPT09ICdzY2FsZScgfHwga2V5ID09PSAnb3JpZ2luJykge1xuICAgICAgLy8gQ29weSB0aGUgYXJyYXlcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpc1trZXldO1xuXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgdGFyZ2V0ID0gdGhpc1trZXldID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXRbMF0gPSB2YWx1ZVswXTtcbiAgICAgICAgdGFyZ2V0WzFdID0gdmFsdWVbMV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSGlkZSB0aGUgZWxlbWVudFxuICAgKi9cbiAgaGlkZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaWdub3JlID0gdHJ1ZTtcbiAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgfSxcblxuICAvKipcbiAgICogU2hvdyB0aGUgZWxlbWVudFxuICAgKi9cbiAgc2hvdzogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaWdub3JlID0gZmFsc2U7XG4gICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0ga2V5XG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIGF0dHI6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmF0dHJLVihrZXksIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHpyVXRpbC5pc09iamVjdChrZXkpKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGtleSkge1xuICAgICAgICBpZiAoa2V5Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdGhpcy5hdHRyS1YobmFtZSwga2V5W25hbWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH0gY2xpcFBhdGhcbiAgICovXG4gIHNldENsaXBQYXRoOiBmdW5jdGlvbiAoY2xpcFBhdGgpIHtcbiAgICB2YXIgenIgPSB0aGlzLl9fenI7XG5cbiAgICBpZiAoenIpIHtcbiAgICAgIGNsaXBQYXRoLmFkZFNlbGZUb1pyKHpyKTtcbiAgICB9IC8vIFJlbW92ZSBwcmV2aW91cyBjbGlwIHBhdGhcblxuXG4gICAgaWYgKHRoaXMuY2xpcFBhdGggJiYgdGhpcy5jbGlwUGF0aCAhPT0gY2xpcFBhdGgpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xpcFBhdGgoKTtcbiAgICB9XG5cbiAgICB0aGlzLmNsaXBQYXRoID0gY2xpcFBhdGg7XG4gICAgY2xpcFBhdGguX196ciA9IHpyO1xuICAgIGNsaXBQYXRoLl9fY2xpcFRhcmdldCA9IHRoaXM7XG4gICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqL1xuICByZW1vdmVDbGlwUGF0aDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbGlwUGF0aCA9IHRoaXMuY2xpcFBhdGg7XG5cbiAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgIGlmIChjbGlwUGF0aC5fX3pyKSB7XG4gICAgICAgIGNsaXBQYXRoLnJlbW92ZVNlbGZGcm9tWnIoY2xpcFBhdGguX196cik7XG4gICAgICB9XG5cbiAgICAgIGNsaXBQYXRoLl9fenIgPSBudWxsO1xuICAgICAgY2xpcFBhdGguX19jbGlwVGFyZ2V0ID0gbnVsbDtcbiAgICAgIHRoaXMuY2xpcFBhdGggPSBudWxsO1xuICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgc2VsZiBmcm9tIHpyZW5kZXIgaW5zdGFuY2UuXG4gICAqIE5vdCByZWN1cnNpdmVseSBiZWNhdXNlIGl0IHdpbGwgYmUgaW52b2tlZCB3aGVuIGVsZW1lbnQgYWRkZWQgdG8gc3RvcmFnZS5cbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICAgKi9cbiAgYWRkU2VsZlRvWnI6IGZ1bmN0aW9uICh6cikge1xuICAgIHRoaXMuX196ciA9IHpyOyAvLyDmt7vliqDliqjnlLtcblxuICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcblxuICAgIGlmIChhbmltYXRvcnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHpyLmFuaW1hdGlvbi5hZGRBbmltYXRvcihhbmltYXRvcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICB0aGlzLmNsaXBQYXRoLmFkZFNlbGZUb1pyKHpyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBzZWxmIGZyb20genJlbmRlciBpbnN0YW5jZS5cbiAgICogTm90IHJlY3Vyc2l2ZWx5IGJlY2F1c2UgaXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gZWxlbWVudCBhZGRlZCB0byBzdG9yYWdlLlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9IHpyXG4gICAqL1xuICByZW1vdmVTZWxmRnJvbVpyOiBmdW5jdGlvbiAoenIpIHtcbiAgICB0aGlzLl9fenIgPSBudWxsOyAvLyDnp7vpmaTliqjnlLtcblxuICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcblxuICAgIGlmIChhbmltYXRvcnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHpyLmFuaW1hdGlvbi5yZW1vdmVBbmltYXRvcihhbmltYXRvcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICB0aGlzLmNsaXBQYXRoLnJlbW92ZVNlbGZGcm9tWnIoenIpO1xuICAgIH1cbiAgfVxufTtcbnpyVXRpbC5taXhpbihFbGVtZW50LCBBbmltYXRhYmxlKTtcbnpyVXRpbC5taXhpbihFbGVtZW50LCBUcmFuc2Zvcm1hYmxlKTtcbnpyVXRpbC5taXhpbihFbGVtZW50LCBFdmVudGZ1bCk7XG52YXIgX2RlZmF1bHQgPSBFbGVtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvRWxlbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1hdHJpeCA9IHJlcXVpcmUoXCIuLi9jb3JlL21hdHJpeFwiKTtcblxudmFyIHZlY3RvciA9IHJlcXVpcmUoXCIuLi9jb3JlL3ZlY3RvclwiKTtcblxuLyoqXG4gKiDmj5Dkvpvlj5jmjaLmianlsZVcbiAqIEBtb2R1bGUgenJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xudmFyIG1JZGVudGl0eSA9IG1hdHJpeC5pZGVudGl0eTtcbnZhciBFUFNJTE9OID0gNWUtNTtcblxuZnVuY3Rpb24gaXNOb3RBcm91bmRaZXJvKHZhbCkge1xuICByZXR1cm4gdmFsID4gRVBTSUxPTiB8fCB2YWwgPCAtRVBTSUxPTjtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIFRyYW5zZm9ybWFibGUgPSBmdW5jdGlvbiAob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTsgLy8gSWYgdGhlcmUgYXJlIG5vIGdpdmVuIHBvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGVcblxuICBpZiAoIW9wdHMucG9zaXRpb24pIHtcbiAgICAvKipcbiAgICAgKiDlubPnp7tcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQGRlZmF1bHQgWzAsIDBdXG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiA9IFswLCAwXTtcbiAgfVxuXG4gIGlmIChvcHRzLnJvdGF0aW9uID09IG51bGwpIHtcbiAgICAvKipcbiAgICAgKiDml4vovaxcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMucm90YXRpb24gPSAwO1xuICB9XG5cbiAgaWYgKCFvcHRzLnNjYWxlKSB7XG4gICAgLyoqXG4gICAgICog57yp5pS+XG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAqIEBkZWZhdWx0IFsxLCAxXVxuICAgICAqL1xuICAgIHRoaXMuc2NhbGUgPSBbMSwgMV07XG4gIH1cbiAgLyoqXG4gICAqIOaXi+i9rOWSjOe8qeaUvueahOWOn+eCuVxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICovXG5cblxuICB0aGlzLm9yaWdpbiA9IHRoaXMub3JpZ2luIHx8IG51bGw7XG59O1xuXG52YXIgdHJhbnNmb3JtYWJsZVByb3RvID0gVHJhbnNmb3JtYWJsZS5wcm90b3R5cGU7XG50cmFuc2Zvcm1hYmxlUHJvdG8udHJhbnNmb3JtID0gbnVsbDtcbi8qKlxuICog5Yik5pat5piv5ZCm6ZyA6KaB5pyJ5Z2Q5qCH5Y+Y5o2iXG4gKiDlpoLmnpzmnInlnZDmoIflj5jmjaIsIOWImeS7jnBvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGXku6Xlj4rniLboioLngrnnmoR0cmFuc2Zvcm3orqHnrpflh7roh6rouqvnmoR0cmFuc2Zvcm3nn6npmLVcbiAqL1xuXG50cmFuc2Zvcm1hYmxlUHJvdG8ubmVlZExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNOb3RBcm91bmRaZXJvKHRoaXMucm90YXRpb24pIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnBvc2l0aW9uWzBdKSB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5wb3NpdGlvblsxXSkgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMuc2NhbGVbMF0gLSAxKSB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5zY2FsZVsxXSAtIDEpO1xufTtcblxudHJhbnNmb3JtYWJsZVByb3RvLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICB2YXIgcGFyZW50SGFzVHJhbnNmb3JtID0gcGFyZW50ICYmIHBhcmVudC50cmFuc2Zvcm07XG4gIHZhciBuZWVkTG9jYWxUcmFuc2Zvcm0gPSB0aGlzLm5lZWRMb2NhbFRyYW5zZm9ybSgpO1xuICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gIGlmICghKG5lZWRMb2NhbFRyYW5zZm9ybSB8fCBwYXJlbnRIYXNUcmFuc2Zvcm0pKSB7XG4gICAgbSAmJiBtSWRlbnRpdHkobSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbSA9IG0gfHwgbWF0cml4LmNyZWF0ZSgpO1xuXG4gIGlmIChuZWVkTG9jYWxUcmFuc2Zvcm0pIHtcbiAgICB0aGlzLmdldExvY2FsVHJhbnNmb3JtKG0pO1xuICB9IGVsc2Uge1xuICAgIG1JZGVudGl0eShtKTtcbiAgfSAvLyDlupTnlKjniLboioLngrnlj5jmjaJcblxuXG4gIGlmIChwYXJlbnRIYXNUcmFuc2Zvcm0pIHtcbiAgICBpZiAobmVlZExvY2FsVHJhbnNmb3JtKSB7XG4gICAgICBtYXRyaXgubXVsKG0sIHBhcmVudC50cmFuc2Zvcm0sIG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXRyaXguY29weShtLCBwYXJlbnQudHJhbnNmb3JtKTtcbiAgICB9XG4gIH0gLy8g5L+d5a2Y6L+Z5Liq5Y+Y5o2i55+p6Zi1XG5cblxuICB0aGlzLnRyYW5zZm9ybSA9IG07XG4gIHRoaXMuaW52VHJhbnNmb3JtID0gdGhpcy5pbnZUcmFuc2Zvcm0gfHwgbWF0cml4LmNyZWF0ZSgpO1xuICBtYXRyaXguaW52ZXJ0KHRoaXMuaW52VHJhbnNmb3JtLCBtKTtcbn07XG5cbnRyYW5zZm9ybWFibGVQcm90by5nZXRMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChtKSB7XG4gIHJldHVybiBUcmFuc2Zvcm1hYmxlLmdldExvY2FsVHJhbnNmb3JtKHRoaXMsIG0pO1xufTtcbi8qKlxuICog5bCG6Ieq5bex55qEdHJhbnNmb3Jt5bqU55So5YiwY29udGV4dOS4ilxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICovXG5cblxudHJhbnNmb3JtYWJsZVByb3RvLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgdmFyIGRwciA9IGN0eC5kcHIgfHwgMTtcblxuICBpZiAobSkge1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oZHByICogbVswXSwgZHByICogbVsxXSwgZHByICogbVsyXSwgZHByICogbVszXSwgZHByICogbVs0XSwgZHByICogbVs1XSk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LnNldFRyYW5zZm9ybShkcHIsIDAsIDAsIGRwciwgMCwgMCk7XG4gIH1cbn07XG5cbnRyYW5zZm9ybWFibGVQcm90by5yZXN0b3JlVHJhbnNmb3JtID0gZnVuY3Rpb24gKGN0eCkge1xuICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuICBjdHguc2V0VHJhbnNmb3JtKGRwciwgMCwgMCwgZHByLCAwLCAwKTtcbn07XG5cbnZhciB0bXBUcmFuc2Zvcm0gPSBbXTtcbi8qKlxuICog5YiG6KejYHRyYW5zZm9ybWDnn6npmLXliLBgcG9zaXRpb25gLCBgcm90YXRpb25gLCBgc2NhbGVgXG4gKi9cblxudHJhbnNmb3JtYWJsZVByb3RvLmRlY29tcG9zZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnRyYW5zZm9ybSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcblxuICBpZiAocGFyZW50ICYmIHBhcmVudC50cmFuc2Zvcm0pIHtcbiAgICAvLyBHZXQgbG9jYWwgdHJhbnNmb3JtIGFuZCBkZWNvbXBvc2UgdGhlbSB0byBwb3NpdGlvbiwgc2NhbGUsIHJvdGF0aW9uXG4gICAgbWF0cml4Lm11bCh0bXBUcmFuc2Zvcm0sIHBhcmVudC5pbnZUcmFuc2Zvcm0sIG0pO1xuICAgIG0gPSB0bXBUcmFuc2Zvcm07XG4gIH1cblxuICB2YXIgc3ggPSBtWzBdICogbVswXSArIG1bMV0gKiBtWzFdO1xuICB2YXIgc3kgPSBtWzJdICogbVsyXSArIG1bM10gKiBtWzNdO1xuICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuXG4gIGlmIChpc05vdEFyb3VuZFplcm8oc3ggLSAxKSkge1xuICAgIHN4ID0gTWF0aC5zcXJ0KHN4KTtcbiAgfVxuXG4gIGlmIChpc05vdEFyb3VuZFplcm8oc3kgLSAxKSkge1xuICAgIHN5ID0gTWF0aC5zcXJ0KHN5KTtcbiAgfVxuXG4gIGlmIChtWzBdIDwgMCkge1xuICAgIHN4ID0gLXN4O1xuICB9XG5cbiAgaWYgKG1bM10gPCAwKSB7XG4gICAgc3kgPSAtc3k7XG4gIH1cblxuICBwb3NpdGlvblswXSA9IG1bNF07XG4gIHBvc2l0aW9uWzFdID0gbVs1XTtcbiAgc2NhbGVbMF0gPSBzeDtcbiAgc2NhbGVbMV0gPSBzeTtcbiAgdGhpcy5yb3RhdGlvbiA9IE1hdGguYXRhbjIoLW1bMV0gLyBzeSwgbVswXSAvIHN4KTtcbn07XG4vKipcbiAqIEdldCBnbG9iYWwgc2NhbGVcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICovXG5cblxudHJhbnNmb3JtYWJsZVByb3RvLmdldEdsb2JhbFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gIGlmICghbSkge1xuICAgIHJldHVybiBbMSwgMV07XG4gIH1cblxuICB2YXIgc3ggPSBNYXRoLnNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gIHZhciBzeSA9IE1hdGguc3FydChtWzJdICogbVsyXSArIG1bM10gKiBtWzNdKTtcblxuICBpZiAobVswXSA8IDApIHtcbiAgICBzeCA9IC1zeDtcbiAgfVxuXG4gIGlmIChtWzNdIDwgMCkge1xuICAgIHN5ID0gLXN5O1xuICB9XG5cbiAgcmV0dXJuIFtzeCwgc3ldO1xufTtcbi8qKlxuICog5Y+Y5o2i5Z2Q5qCH5L2N572u5YiwIHNoYXBlIOeahOWxgOmDqOWdkOagh+epuumXtFxuICogQG1ldGhvZFxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAqL1xuXG5cbnRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm1Db29yZFRvTG9jYWwgPSBmdW5jdGlvbiAoeCwgeSkge1xuICB2YXIgdjIgPSBbeCwgeV07XG4gIHZhciBpbnZUcmFuc2Zvcm0gPSB0aGlzLmludlRyYW5zZm9ybTtcblxuICBpZiAoaW52VHJhbnNmb3JtKSB7XG4gICAgdmVjdG9yLmFwcGx5VHJhbnNmb3JtKHYyLCB2MiwgaW52VHJhbnNmb3JtKTtcbiAgfVxuXG4gIHJldHVybiB2Mjtcbn07XG4vKipcbiAqIOWPmOaNouWxgOmDqOWdkOagh+S9jee9ruWIsOWFqOWxgOWdkOagh+epuumXtFxuICogQG1ldGhvZFxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAqL1xuXG5cbnRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm1Db29yZFRvR2xvYmFsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgdmFyIHYyID0gW3gsIHldO1xuICB2YXIgdHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgaWYgKHRyYW5zZm9ybSkge1xuICAgIHZlY3Rvci5hcHBseVRyYW5zZm9ybSh2MiwgdjIsIHRyYW5zZm9ybSk7XG4gIH1cblxuICByZXR1cm4gdjI7XG59O1xuLyoqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0YXJnZXQub3JpZ2luXG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0LnJvdGF0aW9uXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0YXJnZXQucG9zaXRpb25cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFttXVxuICovXG5cblxuVHJhbnNmb3JtYWJsZS5nZXRMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0YXJnZXQsIG0pIHtcbiAgbSA9IG0gfHwgW107XG4gIG1JZGVudGl0eShtKTtcbiAgdmFyIG9yaWdpbiA9IHRhcmdldC5vcmlnaW47XG4gIHZhciBzY2FsZSA9IHRhcmdldC5zY2FsZSB8fCBbMSwgMV07XG4gIHZhciByb3RhdGlvbiA9IHRhcmdldC5yb3RhdGlvbiB8fCAwO1xuICB2YXIgcG9zaXRpb24gPSB0YXJnZXQucG9zaXRpb24gfHwgWzAsIDBdO1xuXG4gIGlmIChvcmlnaW4pIHtcbiAgICAvLyBUcmFuc2xhdGUgdG8gb3JpZ2luXG4gICAgbVs0XSAtPSBvcmlnaW5bMF07XG4gICAgbVs1XSAtPSBvcmlnaW5bMV07XG4gIH1cblxuICBtYXRyaXguc2NhbGUobSwgbSwgc2NhbGUpO1xuXG4gIGlmIChyb3RhdGlvbikge1xuICAgIG1hdHJpeC5yb3RhdGUobSwgbSwgcm90YXRpb24pO1xuICB9XG5cbiAgaWYgKG9yaWdpbikge1xuICAgIC8vIFRyYW5zbGF0ZSBiYWNrIGZyb20gb3JpZ2luXG4gICAgbVs0XSArPSBvcmlnaW5bMF07XG4gICAgbVs1XSArPSBvcmlnaW5bMV07XG4gIH1cblxuICBtWzRdICs9IHBvc2l0aW9uWzBdO1xuICBtWzVdICs9IHBvc2l0aW9uWzFdO1xuICByZXR1cm4gbTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IFRyYW5zZm9ybWFibGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9taXhpbi9UcmFuc2Zvcm1hYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIDN4MuefqemYteaTjeS9nOexu1xuICogQGV4cG9ydHMgenJlbmRlci90b29sL21hdHJpeFxuICovXG52YXIgQXJyYXlDdG9yID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyBBcnJheSA6IEZsb2F0MzJBcnJheTtcbi8qKlxuICog5Yib5bu65LiA5Liq5Y2V5L2N55+p6Zi1XG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IEFycmF5Q3Rvcig2KTtcbiAgaWRlbnRpdHkob3V0KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog6K6+572u55+p6Zi15Li65Y2V5L2N55+p6Zi1XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5aSN5Yi255+p6Zi1XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gbVxuICovXG5cblxuZnVuY3Rpb24gY29weShvdXQsIG0pIHtcbiAgb3V0WzBdID0gbVswXTtcbiAgb3V0WzFdID0gbVsxXTtcbiAgb3V0WzJdID0gbVsyXTtcbiAgb3V0WzNdID0gbVszXTtcbiAgb3V0WzRdID0gbVs0XTtcbiAgb3V0WzVdID0gbVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog55+p6Zi155u45LmYXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gbTFcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtMlxuICovXG5cblxuZnVuY3Rpb24gbXVsKG91dCwgbTEsIG0yKSB7XG4gIC8vIENvbnNpZGVyIG1hdHJpeC5tdWwobSwgbTIsIG0pO1xuICAvLyB3aGVyZSBvdXQgaXMgdGhlIHNhbWUgYXMgbTIuXG4gIC8vIFNvIHVzZSB0ZW1wIHZhcmlhYmxlIHRvIGVzY2FwZSBlcnJvci5cbiAgdmFyIG91dDAgPSBtMVswXSAqIG0yWzBdICsgbTFbMl0gKiBtMlsxXTtcbiAgdmFyIG91dDEgPSBtMVsxXSAqIG0yWzBdICsgbTFbM10gKiBtMlsxXTtcbiAgdmFyIG91dDIgPSBtMVswXSAqIG0yWzJdICsgbTFbMl0gKiBtMlszXTtcbiAgdmFyIG91dDMgPSBtMVsxXSAqIG0yWzJdICsgbTFbM10gKiBtMlszXTtcbiAgdmFyIG91dDQgPSBtMVswXSAqIG0yWzRdICsgbTFbMl0gKiBtMls1XSArIG0xWzRdO1xuICB2YXIgb3V0NSA9IG0xWzFdICogbTJbNF0gKyBtMVszXSAqIG0yWzVdICsgbTFbNV07XG4gIG91dFswXSA9IG91dDA7XG4gIG91dFsxXSA9IG91dDE7XG4gIG91dFsyXSA9IG91dDI7XG4gIG91dFszXSA9IG91dDM7XG4gIG91dFs0XSA9IG91dDQ7XG4gIG91dFs1XSA9IG91dDU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOW5s+enu+WPmOaNolxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSB2XG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF0gKyB2WzBdO1xuICBvdXRbNV0gPSBhWzVdICsgdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5peL6L2s5Y+Y5o2iXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZFxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIHZhciBhYSA9IGFbMF07XG4gIHZhciBhYyA9IGFbMl07XG4gIHZhciBhdHggPSBhWzRdO1xuICB2YXIgYWIgPSBhWzFdO1xuICB2YXIgYWQgPSBhWzNdO1xuICB2YXIgYXR5ID0gYVs1XTtcbiAgdmFyIHN0ID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGN0ID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYWEgKiBjdCArIGFiICogc3Q7XG4gIG91dFsxXSA9IC1hYSAqIHN0ICsgYWIgKiBjdDtcbiAgb3V0WzJdID0gYWMgKiBjdCArIGFkICogc3Q7XG4gIG91dFszXSA9IC1hYyAqIHN0ICsgY3QgKiBhZDtcbiAgb3V0WzRdID0gY3QgKiBhdHggKyBzdCAqIGF0eTtcbiAgb3V0WzVdID0gY3QgKiBhdHkgLSBzdCAqIGF0eDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog57yp5pS+5Y+Y5o2iXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IHZcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgdnggPSB2WzBdO1xuICB2YXIgdnkgPSB2WzFdO1xuICBvdXRbMF0gPSBhWzBdICogdng7XG4gIG91dFsxXSA9IGFbMV0gKiB2eTtcbiAgb3V0WzJdID0gYVsyXSAqIHZ4O1xuICBvdXRbM10gPSBhWzNdICogdnk7XG4gIG91dFs0XSA9IGFbNF0gKiB2eDtcbiAgb3V0WzVdID0gYVs1XSAqIHZ5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDmsYLpgIbnn6npmLVcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gKi9cblxuXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhYSA9IGFbMF07XG4gIHZhciBhYyA9IGFbMl07XG4gIHZhciBhdHggPSBhWzRdO1xuICB2YXIgYWIgPSBhWzFdO1xuICB2YXIgYWQgPSBhWzNdO1xuICB2YXIgYXR5ID0gYVs1XTtcbiAgdmFyIGRldCA9IGFhICogYWQgLSBhYiAqIGFjO1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkZXQgPSAxLjAgLyBkZXQ7XG4gIG91dFswXSA9IGFkICogZGV0O1xuICBvdXRbMV0gPSAtYWIgKiBkZXQ7XG4gIG91dFsyXSA9IC1hYyAqIGRldDtcbiAgb3V0WzNdID0gYWEgKiBkZXQ7XG4gIG91dFs0XSA9IChhYyAqIGF0eSAtIGFkICogYXR4KSAqIGRldDtcbiAgb3V0WzVdID0gKGFiICogYXR4IC0gYWEgKiBhdHkpICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuXG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbmV4cG9ydHMuY29weSA9IGNvcHk7XG5leHBvcnRzLm11bCA9IG11bDtcbmV4cG9ydHMudHJhbnNsYXRlID0gdHJhbnNsYXRlO1xuZXhwb3J0cy5yb3RhdGUgPSByb3RhdGU7XG5leHBvcnRzLnNjYWxlID0gc2NhbGU7XG5leHBvcnRzLmludmVydCA9IGludmVydDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29yZS9tYXRyaXguanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBbmltYXRvciA9IHJlcXVpcmUoXCIuLi9hbmltYXRpb24vQW5pbWF0b3JcIik7XG5cbnZhciBsb2cgPSByZXF1aXJlKFwiLi4vY29yZS9sb2dcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBpc1N0cmluZyA9IF91dGlsLmlzU3RyaW5nO1xudmFyIGlzRnVuY3Rpb24gPSBfdXRpbC5pc0Z1bmN0aW9uO1xudmFyIGlzT2JqZWN0ID0gX3V0aWwuaXNPYmplY3Q7XG52YXIgaXNBcnJheUxpa2UgPSBfdXRpbC5pc0FycmF5TGlrZTtcbnZhciBpbmRleE9mID0gX3V0aWwuaW5kZXhPZjtcblxuLyoqXG4gKiBAYWxpYXMgbW9kdWU6enJlbmRlci9taXhpbi9BbmltYXRhYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEFuaW1hdGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcj59XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgdGhpcy5hbmltYXRvcnMgPSBbXTtcbn07XG5cbkFuaW1hdGFibGUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQW5pbWF0YWJsZSxcblxuICAvKipcbiAgICog5Yqo55S7XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGZldGNoIHZhbHVlIGZyb20gb2JqZWN0LCBsaWtlICdhLmIuYycuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2xvb3BdIFdoZXRoZXIgdG8gbG9vcCBhbmltYXRpb24uXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICogQGV4YW1wbGU6XG4gICAqICAgICBlbC5hbmltYXRlKCdzdHlsZScsIGZhbHNlKVxuICAgKiAgICAgICAgIC53aGVuKDEwMDAsIHt4OiAxMH0gKVxuICAgKiAgICAgICAgIC5kb25lKGZ1bmN0aW9uKCl7IC8vIEFuaW1hdGlvbiBkb25lIH0pXG4gICAqICAgICAgICAgLnN0YXJ0KClcbiAgICovXG4gIGFuaW1hdGU6IGZ1bmN0aW9uIChwYXRoLCBsb29wKSB7XG4gICAgdmFyIHRhcmdldDtcbiAgICB2YXIgYW5pbWF0aW5nU2hhcGUgPSBmYWxzZTtcbiAgICB2YXIgZWwgPSB0aGlzO1xuICAgIHZhciB6ciA9IHRoaXMuX196cjtcblxuICAgIGlmIChwYXRoKSB7XG4gICAgICB2YXIgcGF0aFNwbGl0dGVkID0gcGF0aC5zcGxpdCgnLicpO1xuICAgICAgdmFyIHByb3AgPSBlbDsgLy8gSWYgYW5pbWF0aW5nIHNoYXBlXG5cbiAgICAgIGFuaW1hdGluZ1NoYXBlID0gcGF0aFNwbGl0dGVkWzBdID09PSAnc2hhcGUnO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGhTcGxpdHRlZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKCFwcm9wKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wID0gcHJvcFtwYXRoU3BsaXR0ZWRbaV1dO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcCkge1xuICAgICAgICB0YXJnZXQgPSBwcm9wO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQgPSBlbDtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgbG9nKCdQcm9wZXJ0eSBcIicgKyBwYXRoICsgJ1wiIGlzIG5vdCBleGlzdGVkIGluIGVsZW1lbnQgJyArIGVsLmlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYW5pbWF0b3JzID0gZWwuYW5pbWF0b3JzO1xuICAgIHZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcih0YXJnZXQsIGxvb3ApO1xuICAgIGFuaW1hdG9yLmR1cmluZyhmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBlbC5kaXJ0eShhbmltYXRpbmdTaGFwZSk7XG4gICAgfSkuZG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBGSVhNRSBBbmltYXRvciB3aWxsIG5vdCBiZSByZW1vdmVkIGlmIHVzZSBgQW5pbWF0b3Ijc3RvcGAgdG8gc3RvcCBhbmltYXRpb25cbiAgICAgIGFuaW1hdG9ycy5zcGxpY2UoaW5kZXhPZihhbmltYXRvcnMsIGFuaW1hdG9yKSwgMSk7XG4gICAgfSk7XG4gICAgYW5pbWF0b3JzLnB1c2goYW5pbWF0b3IpOyAvLyBJZiBhbmltYXRlIGFmdGVyIGFkZGVkIHRvIHRoZSB6cmVuZGVyXG5cbiAgICBpZiAoenIpIHtcbiAgICAgIHpyLmFuaW1hdGlvbi5hZGRBbmltYXRvcihhbmltYXRvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuaW1hdG9yO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlgZzmraLliqjnlLtcbiAgICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkVG9MYXN0IElmIG1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgKi9cbiAgc3RvcEFuaW1hdGlvbjogZnVuY3Rpb24gKGZvcndhcmRUb0xhc3QpIHtcbiAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnM7XG4gICAgdmFyIGxlbiA9IGFuaW1hdG9ycy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhbmltYXRvcnNbaV0uc3RvcChmb3J3YXJkVG9MYXN0KTtcbiAgICB9XG5cbiAgICBhbmltYXRvcnMubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQ2F1dGlvbjogdGhpcyBtZXRob2Qgd2lsbCBzdG9wIHByZXZpb3VzIGFuaW1hdGlvbi5cbiAgICogU28gZG8gbm90IHVzZSB0aGlzIG1ldGhvZCB0byBvbmUgZWxlbWVudCB0d2ljZSBiZWZvcmVcbiAgICogYW5pbWF0aW9uIHN0YXJ0cywgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWU9NTAwXSBUaW1lIGluIG1zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZWFzaW5nPSdsaW5lYXInXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5PTBdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZvcmNlQW5pbWF0ZV0gUHJldmVudCBzdG9wIGFuaW1hdGlvbiBhbmQgY2FsbGJhY2tcbiAgICogICAgICAgIGltbWVkaWVudGx5IHdoZW4gdGFyZ2V0IHZhbHVlcyBhcmUgdGhlIHNhbWUgYXMgY3VycmVudCB2YWx1ZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAvLyBBbmltYXRlIHBvc2l0aW9uXG4gICAqICBlbC5hbmltYXRlVG8oe1xuICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgKiAgfSwgZnVuY3Rpb24gKCkgeyAvLyBkb25lIH0pXG4gICAqXG4gICAqICAvLyBBbmltYXRlIHNoYXBlLCBzdHlsZSBhbmQgcG9zaXRpb24gaW4gMTAwbXMsIGRlbGF5ZWQgMTAwbXMsIHdpdGggY3ViaWNPdXQgZWFzaW5nXG4gICAqICBlbC5hbmltYXRlVG8oe1xuICAgKiAgICAgIHNoYXBlOiB7XG4gICAqICAgICAgICAgIHdpZHRoOiA1MDBcbiAgICogICAgICB9LFxuICAgKiAgICAgIHN0eWxlOiB7XG4gICAqICAgICAgICAgIGZpbGw6ICdyZWQnXG4gICAqICAgICAgfVxuICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgKiAgfSwgMTAwLCAxMDAsICdjdWJpY091dCcsIGZ1bmN0aW9uICgpIHsgLy8gZG9uZSB9KVxuICAgKi9cbiAgLy8gVE9ETyBSZXR1cm4gYW5pbWF0aW9uIGtleVxuICBhbmltYXRlVG86IGZ1bmN0aW9uICh0YXJnZXQsIHRpbWUsIGRlbGF5LCBlYXNpbmcsIGNhbGxiYWNrLCBmb3JjZUFuaW1hdGUpIHtcbiAgICAvLyBhbmltYXRlVG8odGFyZ2V0LCB0aW1lLCBlYXNpbmcsIGNhbGxiYWNrKTtcbiAgICBpZiAoaXNTdHJpbmcoZGVsYXkpKSB7XG4gICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgIGVhc2luZyA9IGRlbGF5O1xuICAgICAgZGVsYXkgPSAwO1xuICAgIH0gLy8gYW5pbWF0ZVRvKHRhcmdldCwgdGltZSwgZGVsYXksIGNhbGxiYWNrKTtcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVhc2luZykpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgICAgIGVhc2luZyA9ICdsaW5lYXInO1xuICAgICAgICBkZWxheSA9IDA7XG4gICAgICB9IC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGNhbGxiYWNrKTtcbiAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oZGVsYXkpKSB7XG4gICAgICAgICAgY2FsbGJhY2sgPSBkZWxheTtcbiAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgIH0gLy8gYW5pbWF0ZVRvKHRhcmdldCwgY2FsbGJhY2spXG4gICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24odGltZSkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdGltZTtcbiAgICAgICAgICAgIHRpbWUgPSA1MDA7XG4gICAgICAgICAgfSAvLyBhbmltYXRlVG8odGFyZ2V0KVxuICAgICAgICAgIGVsc2UgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgICAgIHRpbWUgPSA1MDA7XG4gICAgICAgICAgICB9IC8vIFN0b3AgYWxsIHByZXZpb3VzIGFuaW1hdGlvbnNcblxuXG4gICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG5cbiAgICB0aGlzLl9hbmltYXRlVG9TaGFsbG93KCcnLCB0aGlzLCB0YXJnZXQsIHRpbWUsIGRlbGF5KTsgLy8gQW5pbWF0b3JzIG1heSBiZSByZW1vdmVkIGltbWVkaWF0ZWx5IGFmdGVyIHN0YXJ0XG4gICAgLy8gaWYgdGhlcmUgaXMgbm90aGluZyB0byBhbmltYXRlXG5cblxuICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycy5zbGljZSgpO1xuICAgIHZhciBjb3VudCA9IGFuaW1hdG9ycy5sZW5ndGg7XG5cbiAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgY291bnQtLTtcblxuICAgICAgaWYgKCFjb3VudCkge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0gLy8gTm8gYW5pbWF0b3JzLiBUaGlzIHNob3VsZCBiZSBjaGVja2VkIGJlZm9yZSBhbmltYXRvcnNbaV0uc3RhcnQoKSxcbiAgICAvLyBiZWNhdXNlICdkb25lJyBtYXkgYmUgZXhlY3V0ZWQgaW1tZWRpYXRlbHkgaWYgbm8gbmVlZCB0byBhbmltYXRlLlxuXG5cbiAgICBpZiAoIWNvdW50KSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgIH0gLy8gU3RhcnQgYWZ0ZXIgYWxsIGFuaW1hdG9ycyBjcmVhdGVkXG4gICAgLy8gSW5jYXNlIGFueSBhbmltYXRvciBpcyBkb25lIGltbWVkaWF0ZWx5IHdoZW4gYWxsIGFuaW1hdGlvbiBwcm9wZXJ0aWVzIGFyZSBub3QgY2hhbmdlZFxuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgYW5pbWF0b3JzW2ldLmRvbmUoZG9uZSkuc3RhcnQoZWFzaW5nLCBmb3JjZUFuaW1hdGUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGg9JydcbiAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZT10aGlzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lPTUwMF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gQW5pbWF0ZSBwb3NpdGlvblxuICAgKiAgZWwuX2FuaW1hdGVUb1NoYWxsb3coe1xuICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgKiAgfSlcbiAgICpcbiAgICogIC8vIEFuaW1hdGUgc2hhcGUsIHN0eWxlIGFuZCBwb3NpdGlvbiBpbiAxMDBtcywgZGVsYXllZCAxMDBtc1xuICAgKiAgZWwuX2FuaW1hdGVUb1NoYWxsb3coe1xuICAgKiAgICAgIHNoYXBlOiB7XG4gICAqICAgICAgICAgIHdpZHRoOiA1MDBcbiAgICogICAgICB9LFxuICAgKiAgICAgIHN0eWxlOiB7XG4gICAqICAgICAgICAgIGZpbGw6ICdyZWQnXG4gICAqICAgICAgfVxuICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgKiAgfSwgMTAwLCAxMDApXG4gICAqL1xuICBfYW5pbWF0ZVRvU2hhbGxvdzogZnVuY3Rpb24gKHBhdGgsIHNvdXJjZSwgdGFyZ2V0LCB0aW1lLCBkZWxheSkge1xuICAgIHZhciBvYmpTaGFsbG93ID0ge307XG4gICAgdmFyIHByb3BlcnR5Q291bnQgPSAwO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiB0YXJnZXQpIHtcbiAgICAgIGlmICghdGFyZ2V0Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc291cmNlW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHRhcmdldFtuYW1lXSkgJiYgIWlzQXJyYXlMaWtlKHRhcmdldFtuYW1lXSkpIHtcbiAgICAgICAgICB0aGlzLl9hbmltYXRlVG9TaGFsbG93KHBhdGggPyBwYXRoICsgJy4nICsgbmFtZSA6IG5hbWUsIHNvdXJjZVtuYW1lXSwgdGFyZ2V0W25hbWVdLCB0aW1lLCBkZWxheSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqU2hhbGxvd1tuYW1lXSA9IHRhcmdldFtuYW1lXTtcbiAgICAgICAgICBwcm9wZXJ0eUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0W25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgLy8gQXR0ciBkaXJlY3RseSBpZiBub3QgaGFzIHByb3BlcnR5XG4gICAgICAgIC8vIEZJWE1FLCBpZiBzb21lIHByb3BlcnR5IG5vdCBuZWVkZWQgZm9yIGVsZW1lbnQgP1xuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICB0aGlzLmF0dHIobmFtZSwgdGFyZ2V0W25hbWVdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTaGFwZSBvciBzdHlsZVxuICAgICAgICAgIHZhciBwcm9wcyA9IHt9O1xuICAgICAgICAgIHByb3BzW3BhdGhdID0ge307XG4gICAgICAgICAgcHJvcHNbcGF0aF1bbmFtZV0gPSB0YXJnZXRbbmFtZV07XG4gICAgICAgICAgdGhpcy5hdHRyKHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9wZXJ0eUNvdW50ID4gMCkge1xuICAgICAgdGhpcy5hbmltYXRlKHBhdGgsIGZhbHNlKS53aGVuKHRpbWUgPT0gbnVsbCA/IDUwMCA6IHRpbWUsIG9ialNoYWxsb3cpLmRlbGF5KGRlbGF5IHx8IDApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gQW5pbWF0YWJsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL21peGluL0FuaW1hdGFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDbGlwID0gcmVxdWlyZShcIi4vQ2xpcFwiKTtcblxudmFyIGNvbG9yID0gcmVxdWlyZShcIi4uL3Rvb2wvY29sb3JcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBpc0FycmF5TGlrZSA9IF91dGlsLmlzQXJyYXlMaWtlO1xuXG4vKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9hbmltYXRpb24vQW5pbWF0b3JcbiAqL1xudmFyIGFycmF5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXR0ZXIodGFyZ2V0LCBrZXkpIHtcbiAgcmV0dXJuIHRhcmdldFtrZXldO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0U2V0dGVyKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICB0YXJnZXRba2V5XSA9IHZhbHVlO1xufVxuLyoqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGludGVycG9sYXRlTnVtYmVyKHAwLCBwMSwgcGVyY2VudCkge1xuICByZXR1cm4gKHAxIC0gcDApICogcGVyY2VudCArIHAwO1xufVxuLyoqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHAwXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGludGVycG9sYXRlU3RyaW5nKHAwLCBwMSwgcGVyY2VudCkge1xuICByZXR1cm4gcGVyY2VudCA+IDAuNSA/IHAxIDogcDA7XG59XG4vKipcbiAqIEBwYXJhbSAge0FycmF5fSBwMFxuICogQHBhcmFtICB7QXJyYXl9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge251bWJlcn0gYXJyRGltXG4gKi9cblxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUFycmF5KHAwLCBwMSwgcGVyY2VudCwgb3V0LCBhcnJEaW0pIHtcbiAgdmFyIGxlbiA9IHAwLmxlbmd0aDtcblxuICBpZiAoYXJyRGltID09IDEpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBvdXRbaV0gPSBpbnRlcnBvbGF0ZU51bWJlcihwMFtpXSwgcDFbaV0sIHBlcmNlbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuMiA9IGxlbiAmJiBwMFswXS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICBvdXRbaV1bal0gPSBpbnRlcnBvbGF0ZU51bWJlcihwMFtpXVtqXSwgcDFbaV1bal0sIHBlcmNlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyBhcnIwIGlzIHNvdXJjZSBhcnJheSwgYXJyMSBpcyB0YXJnZXQgYXJyYXkuXG4vLyBEbyBzb21lIHByZXByb2Nlc3MgdG8gYXZvaWQgZXJyb3IgaGFwcGVuZWQgd2hlbiBpbnRlcnBvbGF0aW5nIGZyb20gYXJyMCB0byBhcnIxXG5cblxuZnVuY3Rpb24gZmlsbEFycihhcnIwLCBhcnIxLCBhcnJEaW0pIHtcbiAgdmFyIGFycjBMZW4gPSBhcnIwLmxlbmd0aDtcbiAgdmFyIGFycjFMZW4gPSBhcnIxLmxlbmd0aDtcblxuICBpZiAoYXJyMExlbiAhPT0gYXJyMUxlbikge1xuICAgIC8vIEZJWE1FIE5vdCB3b3JrIGZvciBUeXBlZEFycmF5XG4gICAgdmFyIGlzUHJldmlvdXNMYXJnZXIgPSBhcnIwTGVuID4gYXJyMUxlbjtcblxuICAgIGlmIChpc1ByZXZpb3VzTGFyZ2VyKSB7XG4gICAgICAvLyBDdXQgdGhlIHByZXZpb3VzXG4gICAgICBhcnIwLmxlbmd0aCA9IGFycjFMZW47XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbGwgdGhlIHByZXZpb3VzXG4gICAgICBmb3IgKHZhciBpID0gYXJyMExlbjsgaSA8IGFycjFMZW47IGkrKykge1xuICAgICAgICBhcnIwLnB1c2goYXJyRGltID09PSAxID8gYXJyMVtpXSA6IGFycmF5U2xpY2UuY2FsbChhcnIxW2ldKSk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEhhbmRsaW5nIE5hTiB2YWx1ZVxuXG5cbiAgdmFyIGxlbjIgPSBhcnIwWzBdICYmIGFycjBbMF0ubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyMC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJEaW0gPT09IDEpIHtcbiAgICAgIGlmIChpc05hTihhcnIwW2ldKSkge1xuICAgICAgICBhcnIwW2ldID0gYXJyMVtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgaWYgKGlzTmFOKGFycjBbaV1bal0pKSB7XG4gICAgICAgICAgYXJyMFtpXVtqXSA9IGFycjFbaV1bal07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtICB7QXJyYXl9IGFycjBcbiAqIEBwYXJhbSAge0FycmF5fSBhcnIxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFyckRpbVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzQXJyYXlTYW1lKGFycjAsIGFycjEsIGFyckRpbSkge1xuICBpZiAoYXJyMCA9PT0gYXJyMSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGxlbiA9IGFycjAubGVuZ3RoO1xuXG4gIGlmIChsZW4gIT09IGFycjEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGFyckRpbSA9PT0gMSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChhcnIwW2ldICE9PSBhcnIxW2ldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbjIgPSBhcnIwWzBdLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgIGlmIChhcnIwW2ldW2pdICE9PSBhcnIxW2ldW2pdKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIENhdG11bGwgUm9tIGludGVycG9sYXRlIGFycmF5XG4gKiBAcGFyYW0gIHtBcnJheX0gcDBcbiAqIEBwYXJhbSAge0FycmF5fSBwMVxuICogQHBhcmFtICB7QXJyYXl9IHAyXG4gKiBAcGFyYW0gIHtBcnJheX0gcDNcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7bnVtYmVyfSB0MlxuICogQHBhcmFtICB7bnVtYmVyfSB0M1xuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNhdG11bGxSb21JbnRlcnBvbGF0ZUFycmF5KHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMsIG91dCwgYXJyRGltKSB7XG4gIHZhciBsZW4gPSBwMC5sZW5ndGg7XG5cbiAgaWYgKGFyckRpbSA9PSAxKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgb3V0W2ldID0gY2F0bXVsbFJvbUludGVycG9sYXRlKHAwW2ldLCBwMVtpXSwgcDJbaV0sIHAzW2ldLCB0LCB0MiwgdDMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuMiA9IHAwWzBdLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgIG91dFtpXVtqXSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZShwMFtpXVtqXSwgcDFbaV1bal0sIHAyW2ldW2pdLCBwM1tpXVtqXSwgdCwgdDIsIHQzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQ2F0bXVsbCBSb20gaW50ZXJwb2xhdGUgbnVtYmVyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge251bWJlcn0gdDJcbiAqIEBwYXJhbSAge251bWJlcn0gdDNcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNhdG11bGxSb21JbnRlcnBvbGF0ZShwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzKSB7XG4gIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNTtcbiAgdmFyIHYxID0gKHAzIC0gcDEpICogMC41O1xuICByZXR1cm4gKDIgKiAocDEgLSBwMikgKyB2MCArIHYxKSAqIHQzICsgKC0zICogKHAxIC0gcDIpIC0gMiAqIHYwIC0gdjEpICogdDIgKyB2MCAqIHQgKyBwMTtcbn1cblxuZnVuY3Rpb24gY2xvbmVWYWx1ZSh2YWx1ZSkge1xuICBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aDtcblxuICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZVswXSkpIHtcbiAgICAgIHZhciByZXQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByZXQucHVzaChhcnJheVNsaWNlLmNhbGwodmFsdWVbaV0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlTbGljZS5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcmdiYTJTdHJpbmcocmdiYSkge1xuICByZ2JhWzBdID0gTWF0aC5mbG9vcihyZ2JhWzBdKTtcbiAgcmdiYVsxXSA9IE1hdGguZmxvb3IocmdiYVsxXSk7XG4gIHJnYmFbMl0gPSBNYXRoLmZsb29yKHJnYmFbMl0pO1xuICByZXR1cm4gJ3JnYmEoJyArIHJnYmEuam9pbignLCcpICsgJyknO1xufVxuXG5mdW5jdGlvbiBnZXRBcnJheURpbShrZXlmcmFtZXMpIHtcbiAgdmFyIGxhc3RWYWx1ZSA9IGtleWZyYW1lc1trZXlmcmFtZXMubGVuZ3RoIC0gMV0udmFsdWU7XG4gIHJldHVybiBpc0FycmF5TGlrZShsYXN0VmFsdWUgJiYgbGFzdFZhbHVlWzBdKSA/IDIgOiAxO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFja0NsaXAoYW5pbWF0b3IsIGVhc2luZywgb25lVHJhY2tEb25lLCBrZXlmcmFtZXMsIHByb3BOYW1lLCBmb3JjZUFuaW1hdGUpIHtcbiAgdmFyIGdldHRlciA9IGFuaW1hdG9yLl9nZXR0ZXI7XG4gIHZhciBzZXR0ZXIgPSBhbmltYXRvci5fc2V0dGVyO1xuICB2YXIgdXNlU3BsaW5lID0gZWFzaW5nID09PSAnc3BsaW5lJztcbiAgdmFyIHRyYWNrTGVuID0ga2V5ZnJhbWVzLmxlbmd0aDtcblxuICBpZiAoIXRyYWNrTGVuKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIEd1ZXNzIGRhdGEgdHlwZVxuXG5cbiAgdmFyIGZpcnN0VmFsID0ga2V5ZnJhbWVzWzBdLnZhbHVlO1xuICB2YXIgaXNWYWx1ZUFycmF5ID0gaXNBcnJheUxpa2UoZmlyc3RWYWwpO1xuICB2YXIgaXNWYWx1ZUNvbG9yID0gZmFsc2U7XG4gIHZhciBpc1ZhbHVlU3RyaW5nID0gZmFsc2U7IC8vIEZvciB2ZXJ0aWNlcyBtb3JwaGluZ1xuXG4gIHZhciBhcnJEaW0gPSBpc1ZhbHVlQXJyYXkgPyBnZXRBcnJheURpbShrZXlmcmFtZXMpIDogMDtcbiAgdmFyIHRyYWNrTWF4VGltZTsgLy8gU29ydCBrZXlmcmFtZSBhcyBhc2NlbmRpbmdcblxuICBrZXlmcmFtZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLnRpbWUgLSBiLnRpbWU7XG4gIH0pO1xuICB0cmFja01heFRpbWUgPSBrZXlmcmFtZXNbdHJhY2tMZW4gLSAxXS50aW1lOyAvLyBQZXJjZW50cyBvZiBlYWNoIGtleWZyYW1lXG5cbiAgdmFyIGtmUGVyY2VudHMgPSBbXTsgLy8gVmFsdWUgb2YgZWFjaCBrZXlmcmFtZVxuXG4gIHZhciBrZlZhbHVlcyA9IFtdO1xuICB2YXIgcHJldlZhbHVlID0ga2V5ZnJhbWVzWzBdLnZhbHVlO1xuICB2YXIgaXNBbGxWYWx1ZUVxdWFsID0gdHJ1ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGVuOyBpKyspIHtcbiAgICBrZlBlcmNlbnRzLnB1c2goa2V5ZnJhbWVzW2ldLnRpbWUgLyB0cmFja01heFRpbWUpOyAvLyBBc3N1bWUgdmFsdWUgaXMgYSBjb2xvciB3aGVuIGl0IGlzIGEgc3RyaW5nXG5cbiAgICB2YXIgdmFsdWUgPSBrZXlmcmFtZXNbaV0udmFsdWU7IC8vIENoZWNrIGlmIHZhbHVlIGlzIGVxdWFsLCBkZWVwIGNoZWNrIGlmIHZhbHVlIGlzIGFycmF5XG5cbiAgICBpZiAoIShpc1ZhbHVlQXJyYXkgJiYgaXNBcnJheVNhbWUodmFsdWUsIHByZXZWYWx1ZSwgYXJyRGltKSB8fCAhaXNWYWx1ZUFycmF5ICYmIHZhbHVlID09PSBwcmV2VmFsdWUpKSB7XG4gICAgICBpc0FsbFZhbHVlRXF1YWwgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBwcmV2VmFsdWUgPSB2YWx1ZTsgLy8gVHJ5IGNvbnZlcnRpbmcgYSBzdHJpbmcgdG8gYSBjb2xvciBhcnJheVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgdmFyIGNvbG9yQXJyYXkgPSBjb2xvci5wYXJzZSh2YWx1ZSk7XG5cbiAgICAgIGlmIChjb2xvckFycmF5KSB7XG4gICAgICAgIHZhbHVlID0gY29sb3JBcnJheTtcbiAgICAgICAgaXNWYWx1ZUNvbG9yID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzVmFsdWVTdHJpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGtmVmFsdWVzLnB1c2godmFsdWUpO1xuICB9XG5cbiAgaWYgKCFmb3JjZUFuaW1hdGUgJiYgaXNBbGxWYWx1ZUVxdWFsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxhc3RWYWx1ZSA9IGtmVmFsdWVzW3RyYWNrTGVuIC0gMV07IC8vIFBvbHlmaWxsIGFycmF5IGFuZCBOYU4gdmFsdWVcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGVuIC0gMTsgaSsrKSB7XG4gICAgaWYgKGlzVmFsdWVBcnJheSkge1xuICAgICAgZmlsbEFycihrZlZhbHVlc1tpXSwgbGFzdFZhbHVlLCBhcnJEaW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNOYU4oa2ZWYWx1ZXNbaV0pICYmICFpc05hTihsYXN0VmFsdWUpICYmICFpc1ZhbHVlU3RyaW5nICYmICFpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAga2ZWYWx1ZXNbaV0gPSBsYXN0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNWYWx1ZUFycmF5ICYmIGZpbGxBcnIoZ2V0dGVyKGFuaW1hdG9yLl90YXJnZXQsIHByb3BOYW1lKSwgbGFzdFZhbHVlLCBhcnJEaW0pOyAvLyBDYWNoZSB0aGUga2V5IG9mIGxhc3QgZnJhbWUgdG8gc3BlZWQgdXAgd2hlblxuICAvLyBhbmltYXRpb24gcGxheWJhY2sgaXMgc2VxdWVuY3lcblxuICB2YXIgbGFzdEZyYW1lID0gMDtcbiAgdmFyIGxhc3RGcmFtZVBlcmNlbnQgPSAwO1xuICB2YXIgc3RhcnQ7XG4gIHZhciB3O1xuICB2YXIgcDA7XG4gIHZhciBwMTtcbiAgdmFyIHAyO1xuICB2YXIgcDM7XG5cbiAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgIHZhciByZ2JhID0gWzAsIDAsIDAsIDBdO1xuICB9XG5cbiAgdmFyIG9uZnJhbWUgPSBmdW5jdGlvbiAodGFyZ2V0LCBwZXJjZW50KSB7XG4gICAgLy8gRmluZCB0aGUgcmFuZ2Uga2V5ZnJhbWVzXG4gICAgLy8ga2YxLS0tLS1rZjItLS0tLS0tLS1jdXJyZW50LS0tLS0tLS1rZjNcbiAgICAvLyBmaW5kIGtmMiBhbmQga2YzIGFuZCBkbyBpbnRlcnBvbGF0aW9uXG4gICAgdmFyIGZyYW1lOyAvLyBJbiB0aGUgZWFzaW5nIGZ1bmN0aW9uIGxpa2UgZWxhc3RpY091dCwgcGVyY2VudCBtYXkgbGVzcyB0aGFuIDBcblxuICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgZnJhbWUgPSAwO1xuICAgIH0gZWxzZSBpZiAocGVyY2VudCA8IGxhc3RGcmFtZVBlcmNlbnQpIHtcbiAgICAgIC8vIFN0YXJ0IGZyb20gbmV4dCBrZXlcbiAgICAgIC8vIFBFTkRJTkcgc3RhcnQgZnJvbSBsYXN0RnJhbWUgP1xuICAgICAgc3RhcnQgPSBNYXRoLm1pbihsYXN0RnJhbWUgKyAxLCB0cmFja0xlbiAtIDEpO1xuXG4gICAgICBmb3IgKGZyYW1lID0gc3RhcnQ7IGZyYW1lID49IDA7IGZyYW1lLS0pIHtcbiAgICAgICAgaWYgKGtmUGVyY2VudHNbZnJhbWVdIDw9IHBlcmNlbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAvLyBQRU5ESU5HIHJlYWxseSBuZWVkIHRvIGRvIHRoaXMgP1xuXG5cbiAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUsIHRyYWNrTGVuIC0gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoZnJhbWUgPSBsYXN0RnJhbWU7IGZyYW1lIDwgdHJhY2tMZW47IGZyYW1lKyspIHtcbiAgICAgICAgaWYgKGtmUGVyY2VudHNbZnJhbWVdID4gcGVyY2VudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUgLSAxLCB0cmFja0xlbiAtIDIpO1xuICAgIH1cblxuICAgIGxhc3RGcmFtZSA9IGZyYW1lO1xuICAgIGxhc3RGcmFtZVBlcmNlbnQgPSBwZXJjZW50O1xuICAgIHZhciByYW5nZSA9IGtmUGVyY2VudHNbZnJhbWUgKyAxXSAtIGtmUGVyY2VudHNbZnJhbWVdO1xuXG4gICAgaWYgKHJhbmdlID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHcgPSAocGVyY2VudCAtIGtmUGVyY2VudHNbZnJhbWVdKSAvIHJhbmdlO1xuICAgIH1cblxuICAgIGlmICh1c2VTcGxpbmUpIHtcbiAgICAgIHAxID0ga2ZWYWx1ZXNbZnJhbWVdO1xuICAgICAgcDAgPSBrZlZhbHVlc1tmcmFtZSA9PT0gMCA/IGZyYW1lIDogZnJhbWUgLSAxXTtcbiAgICAgIHAyID0ga2ZWYWx1ZXNbZnJhbWUgPiB0cmFja0xlbiAtIDIgPyB0cmFja0xlbiAtIDEgOiBmcmFtZSArIDFdO1xuICAgICAgcDMgPSBrZlZhbHVlc1tmcmFtZSA+IHRyYWNrTGVuIC0gMyA/IHRyYWNrTGVuIC0gMSA6IGZyYW1lICsgMl07XG5cbiAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgY2F0bXVsbFJvbUludGVycG9sYXRlQXJyYXkocDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHcsIGdldHRlcih0YXJnZXQsIHByb3BOYW1lKSwgYXJyRGltKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICBpZiAoaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgICAgdmFsdWUgPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShwMCwgcDEsIHAyLCBwMywgdywgdyAqIHcsIHcgKiB3ICogdywgcmdiYSwgMSk7XG4gICAgICAgICAgdmFsdWUgPSByZ2JhMlN0cmluZyhyZ2JhKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ZhbHVlU3RyaW5nKSB7XG4gICAgICAgICAgLy8gU3RyaW5nIGlzIHN0ZXAoMC41KVxuICAgICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZVN0cmluZyhwMSwgcDIsIHcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gY2F0bXVsbFJvbUludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB3LCB3ICogdywgdyAqIHcgKiB3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldHRlcih0YXJnZXQsIHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVBcnJheShrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcsIGdldHRlcih0YXJnZXQsIHByb3BOYW1lKSwgYXJyRGltKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICBpZiAoaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgICAgaW50ZXJwb2xhdGVBcnJheShrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcsIHJnYmEsIDEpO1xuICAgICAgICAgIHZhbHVlID0gcmdiYTJTdHJpbmcocmdiYSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNWYWx1ZVN0cmluZykge1xuICAgICAgICAgIC8vIFN0cmluZyBpcyBzdGVwKDAuNSlcbiAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVTdHJpbmcoa2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGludGVycG9sYXRlTnVtYmVyKGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgY2xpcCA9IG5ldyBDbGlwKHtcbiAgICB0YXJnZXQ6IGFuaW1hdG9yLl90YXJnZXQsXG4gICAgbGlmZTogdHJhY2tNYXhUaW1lLFxuICAgIGxvb3A6IGFuaW1hdG9yLl9sb29wLFxuICAgIGRlbGF5OiBhbmltYXRvci5fZGVsYXksXG4gICAgb25mcmFtZTogb25mcmFtZSxcbiAgICBvbmRlc3Ryb3k6IG9uZVRyYWNrRG9uZVxuICB9KTtcblxuICBpZiAoZWFzaW5nICYmIGVhc2luZyAhPT0gJ3NwbGluZScpIHtcbiAgICBjbGlwLmVhc2luZyA9IGVhc2luZztcbiAgfVxuXG4gIHJldHVybiBjbGlwO1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXJcbiAqL1xuXG5cbnZhciBBbmltYXRvciA9IGZ1bmN0aW9uICh0YXJnZXQsIGxvb3AsIGdldHRlciwgc2V0dGVyKSB7XG4gIHRoaXMuX3RyYWNrcyA9IHt9O1xuICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gIHRoaXMuX2xvb3AgPSBsb29wIHx8IGZhbHNlO1xuICB0aGlzLl9nZXR0ZXIgPSBnZXR0ZXIgfHwgZGVmYXVsdEdldHRlcjtcbiAgdGhpcy5fc2V0dGVyID0gc2V0dGVyIHx8IGRlZmF1bHRTZXR0ZXI7XG4gIHRoaXMuX2NsaXBDb3VudCA9IDA7XG4gIHRoaXMuX2RlbGF5ID0gMDtcbiAgdGhpcy5fZG9uZUxpc3QgPSBbXTtcbiAgdGhpcy5fb25mcmFtZUxpc3QgPSBbXTtcbiAgdGhpcy5fY2xpcExpc3QgPSBbXTtcbn07XG5cbkFuaW1hdG9yLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIOiuvue9ruWKqOeUu+WFs+mUruW4p1xuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRpbWUg5YWz6ZSu5bin5pe26Ze077yM5Y2V5L2N5pivbXNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwcm9wcyDlhbPplK7luKfnmoTlsZ7mgKflgLzvvIxrZXktdmFsdWXooajnpLpcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKi9cbiAgd2hlbjogZnVuY3Rpb24gKHRpbWVcbiAgLyogbXMgKi9cbiAgLCBwcm9wcykge1xuICAgIHZhciB0cmFja3MgPSB0aGlzLl90cmFja3M7XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wcykge1xuICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghdHJhY2tzW3Byb3BOYW1lXSkge1xuICAgICAgICB0cmFja3NbcHJvcE5hbWVdID0gW107IC8vIEludmFsaWQgdmFsdWVcblxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9nZXR0ZXIodGhpcy5fdGFyZ2V0LCBwcm9wTmFtZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAvLyB6ckxvZygnSW52YWxpZCBwcm9wZXJ0eSAnICsgcHJvcE5hbWUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIElmIHRpbWUgaXMgMFxuICAgICAgICAvLyAgVGhlbiBwcm9wcyBpcyBnaXZlbiBpbml0aWFsaXplIHZhbHVlXG4gICAgICAgIC8vIEVsc2VcbiAgICAgICAgLy8gIEluaXRpYWxpemUgdmFsdWUgZnJvbSBjdXJyZW50IHByb3AgdmFsdWVcblxuXG4gICAgICAgIGlmICh0aW1lICE9PSAwKSB7XG4gICAgICAgICAgdHJhY2tzW3Byb3BOYW1lXS5wdXNoKHtcbiAgICAgICAgICAgIHRpbWU6IDAsXG4gICAgICAgICAgICB2YWx1ZTogY2xvbmVWYWx1ZSh2YWx1ZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0cmFja3NbcHJvcE5hbWVdLnB1c2goe1xuICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICB2YWx1ZTogcHJvcHNbcHJvcE5hbWVdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5Yqo55S75q+P5LiA5bin55qE5Zue6LCD5Ye95pWwXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAqL1xuICBkdXJpbmc6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMuX29uZnJhbWVMaXN0LnB1c2goY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jbGlwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fY2xpcExpc3RbaV0ucGF1c2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICB9LFxuICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NsaXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9jbGlwTGlzdFtpXS5yZXN1bWUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgfSxcbiAgaXNQYXVzZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9wYXVzZWQ7XG4gIH0sXG4gIF9kb25lQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBDbGVhciBhbGwgdHJhY2tzXG4gICAgdGhpcy5fdHJhY2tzID0ge307IC8vIENsZWFyIGFsbCBjbGlwc1xuXG4gICAgdGhpcy5fY2xpcExpc3QubGVuZ3RoID0gMDtcbiAgICB2YXIgZG9uZUxpc3QgPSB0aGlzLl9kb25lTGlzdDtcbiAgICB2YXIgbGVuID0gZG9uZUxpc3QubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZG9uZUxpc3RbaV0uY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOW8gOWni+aJp+ihjOWKqOeUu1xuICAgKiBAcGFyYW0gIHtzdHJpbmd8RnVuY3Rpb259IFtlYXNpbmddXG4gICAqICAgICAgICAg5Yqo55S757yT5Yqo5Ye95pWw77yM6K+m6KeBe0BsaW5rIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9lYXNpbmd9XG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGZvcmNlQW5pbWF0ZVxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAqL1xuICBzdGFydDogZnVuY3Rpb24gKGVhc2luZywgZm9yY2VBbmltYXRlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjbGlwQ291bnQgPSAwO1xuXG4gICAgdmFyIG9uZVRyYWNrRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNsaXBDb3VudC0tO1xuXG4gICAgICBpZiAoIWNsaXBDb3VudCkge1xuICAgICAgICBzZWxmLl9kb25lQ2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGxhc3RDbGlwO1xuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdGhpcy5fdHJhY2tzKSB7XG4gICAgICBpZiAoIXRoaXMuX3RyYWNrcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjbGlwID0gY3JlYXRlVHJhY2tDbGlwKHRoaXMsIGVhc2luZywgb25lVHJhY2tEb25lLCB0aGlzLl90cmFja3NbcHJvcE5hbWVdLCBwcm9wTmFtZSwgZm9yY2VBbmltYXRlKTtcblxuICAgICAgaWYgKGNsaXApIHtcbiAgICAgICAgdGhpcy5fY2xpcExpc3QucHVzaChjbGlwKTtcblxuICAgICAgICBjbGlwQ291bnQrKzsgLy8gSWYgc3RhcnQgYWZ0ZXIgYWRkZWQgdG8gYW5pbWF0aW9uXG5cbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5hbmltYXRpb24uYWRkQ2xpcChjbGlwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RDbGlwID0gY2xpcDtcbiAgICAgIH1cbiAgICB9IC8vIEFkZCBkdXJpbmcgY2FsbGJhY2sgb24gdGhlIGxhc3QgY2xpcFxuXG5cbiAgICBpZiAobGFzdENsaXApIHtcbiAgICAgIHZhciBvbGRPbkZyYW1lID0gbGFzdENsaXAub25mcmFtZTtcblxuICAgICAgbGFzdENsaXAub25mcmFtZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHBlcmNlbnQpIHtcbiAgICAgICAgb2xkT25GcmFtZSh0YXJnZXQsIHBlcmNlbnQpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5fb25mcmFtZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzZWxmLl9vbmZyYW1lTGlzdFtpXSh0YXJnZXQsIHBlcmNlbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gLy8gVGhpcyBvcHRpbWl6YXRpb24gd2lsbCBoZWxwIHRoZSBjYXNlIHRoYXQgaW4gdGhlIHVwcGVyIGFwcGxpY2F0aW9uXG4gICAgLy8gdGhlIHZpZXcgbWF5IGJlIHJlZnJlc2hlZCBmcmVxdWVudGx5LCB3aGVyZSBhbmltYXRpb24gd2lsbCBiZVxuICAgIC8vIGNhbGxlZCByZXBlYXRseSBidXQgbm90aGluZyBjaGFuZ2VkLlxuXG5cbiAgICBpZiAoIWNsaXBDb3VudCkge1xuICAgICAgdGhpcy5fZG9uZUNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWBnOatouWKqOeUu1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcndhcmRUb0xhc3QgSWYgbW92ZSB0byBsYXN0IGZyYW1lIGJlZm9yZSBzdG9wXG4gICAqL1xuICBzdG9wOiBmdW5jdGlvbiAoZm9yd2FyZFRvTGFzdCkge1xuICAgIHZhciBjbGlwTGlzdCA9IHRoaXMuX2NsaXBMaXN0O1xuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjbGlwID0gY2xpcExpc3RbaV07XG5cbiAgICAgIGlmIChmb3J3YXJkVG9MYXN0KSB7XG4gICAgICAgIC8vIE1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgICAgICBjbGlwLm9uZnJhbWUodGhpcy5fdGFyZ2V0LCAxKTtcbiAgICAgIH1cblxuICAgICAgYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5yZW1vdmVDbGlwKGNsaXApO1xuICAgIH1cblxuICAgIGNsaXBMaXN0Lmxlbmd0aCA9IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOiuvue9ruWKqOeUu+W7tui/n+W8gOWni+eahOaXtumXtFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRpbWUg5Y2V5L2NbXNcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKi9cbiAgZGVsYXk6IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgdGhpcy5fZGVsYXkgPSB0aW1lO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqDliqjnlLvnu5PmnZ/nmoTlm57osINcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICovXG4gIGRvbmU6IGZ1bmN0aW9uIChjYikge1xuICAgIGlmIChjYikge1xuICAgICAgdGhpcy5fZG9uZUxpc3QucHVzaChjYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcD59XG4gICAqL1xuICBnZXRDbGlwczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jbGlwTGlzdDtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IEFuaW1hdG9yO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZWFzaW5nRnVuY3MgPSByZXF1aXJlKFwiLi9lYXNpbmdcIik7XG5cbi8qKlxuICog5Yqo55S75Li75o6n5Yi25ZmoXG4gKiBAY29uZmlnIHRhcmdldCDliqjnlLvlr7nosaHvvIzlj6/ku6XmmK/mlbDnu4TvvIzlpoLmnpzmmK/mlbDnu4TnmoTor53kvJrmibnph4/liIblj5FvbmZyYW1l562J5LqL5Lu2XG4gKiBAY29uZmlnIGxpZmUoMTAwMCkg5Yqo55S75pe26ZW/XG4gKiBAY29uZmlnIGRlbGF5KDApIOWKqOeUu+W7tui/n+aXtumXtFxuICogQGNvbmZpZyBsb29wKHRydWUpXG4gKiBAY29uZmlnIGdhcCgwKSDlvqrnjq/nmoTpl7TpmpTml7bpl7RcbiAqIEBjb25maWcgb25mcmFtZVxuICogQGNvbmZpZyBlYXNpbmcob3B0aW9uYWwpXG4gKiBAY29uZmlnIG9uZGVzdHJveShvcHRpb25hbClcbiAqIEBjb25maWcgb25yZXN0YXJ0KG9wdGlvbmFsKVxuICpcbiAqIFRPRE8gcGF1c2VcbiAqL1xuZnVuY3Rpb24gQ2xpcChvcHRpb25zKSB7XG4gIHRoaXMuX3RhcmdldCA9IG9wdGlvbnMudGFyZ2V0OyAvLyDnlJ/lkb3lkajmnJ9cblxuICB0aGlzLl9saWZlID0gb3B0aW9ucy5saWZlIHx8IDEwMDA7IC8vIOW7tuaXtlxuXG4gIHRoaXMuX2RlbGF5ID0gb3B0aW9ucy5kZWxheSB8fCAwOyAvLyDlvIDlp4vml7bpl7RcbiAgLy8gdGhpcy5fc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyB0aGlzLl9kZWxheTsvLyDljZXkvY3mr6vnp5JcblxuICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlOyAvLyDmmK/lkKblvqrnjq9cblxuICB0aGlzLmxvb3AgPSBvcHRpb25zLmxvb3AgPT0gbnVsbCA/IGZhbHNlIDogb3B0aW9ucy5sb29wO1xuICB0aGlzLmdhcCA9IG9wdGlvbnMuZ2FwIHx8IDA7XG4gIHRoaXMuZWFzaW5nID0gb3B0aW9ucy5lYXNpbmcgfHwgJ0xpbmVhcic7XG4gIHRoaXMub25mcmFtZSA9IG9wdGlvbnMub25mcmFtZTtcbiAgdGhpcy5vbmRlc3Ryb3kgPSBvcHRpb25zLm9uZGVzdHJveTtcbiAgdGhpcy5vbnJlc3RhcnQgPSBvcHRpb25zLm9ucmVzdGFydDtcbiAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG4gIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xufVxuXG5DbGlwLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IENsaXAsXG4gIHN0ZXA6IGZ1bmN0aW9uIChnbG9iYWxUaW1lLCBkZWx0YVRpbWUpIHtcbiAgICAvLyBTZXQgc3RhcnRUaW1lIG9uIGZpcnN0IHN0ZXAsIG9yIF9zdGFydFRpbWUgbWF5IGhhcyBtaWxsZXNlY29uZHMgZGlmZmVyZW50IGJldHdlZW4gY2xpcHNcbiAgICAvLyBQRU5ESU5HXG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgdGhpcy5fc3RhcnRUaW1lID0gZ2xvYmFsVGltZSArIHRoaXMuX2RlbGF5O1xuICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wYXVzZWQpIHtcbiAgICAgIHRoaXMuX3BhdXNlZFRpbWUgKz0gZGVsdGFUaW1lO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwZXJjZW50ID0gKGdsb2JhbFRpbWUgLSB0aGlzLl9zdGFydFRpbWUgLSB0aGlzLl9wYXVzZWRUaW1lKSAvIHRoaXMuX2xpZmU7IC8vIOi/mOayoeW8gOWni1xuXG4gICAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGVyY2VudCA9IE1hdGgubWluKHBlcmNlbnQsIDEpO1xuICAgIHZhciBlYXNpbmcgPSB0aGlzLmVhc2luZztcbiAgICB2YXIgZWFzaW5nRnVuYyA9IHR5cGVvZiBlYXNpbmcgPT0gJ3N0cmluZycgPyBlYXNpbmdGdW5jc1tlYXNpbmddIDogZWFzaW5nO1xuICAgIHZhciBzY2hlZHVsZSA9IHR5cGVvZiBlYXNpbmdGdW5jID09PSAnZnVuY3Rpb24nID8gZWFzaW5nRnVuYyhwZXJjZW50KSA6IHBlcmNlbnQ7XG4gICAgdGhpcy5maXJlKCdmcmFtZScsIHNjaGVkdWxlKTsgLy8g57uT5p2fXG5cbiAgICBpZiAocGVyY2VudCA9PSAxKSB7XG4gICAgICBpZiAodGhpcy5sb29wKSB7XG4gICAgICAgIHRoaXMucmVzdGFydChnbG9iYWxUaW1lKTsgLy8g6YeN5paw5byA5aeL5ZGo5pyfXG4gICAgICAgIC8vIOaKm+WHuuiAjOS4jeaYr+ebtOaOpeiwg+eUqOS6i+S7tuebtOWIsCBzdGFnZS51cGRhdGUg5ZCO5YaN57uf5LiA6LCD55So6L+Z5Lqb5LqL5Lu2XG5cbiAgICAgICAgcmV0dXJuICdyZXN0YXJ0JztcbiAgICAgIH0gLy8g5Yqo55S75a6M5oiQ5bCG6L+Z5Liq5o6n5Yi25Zmo5qCH6K+G5Li65b6F5Yig6ZmkXG4gICAgICAvLyDlnKhBbmltYXRpb24udXBkYXRl5Lit6L+b6KGM5om56YeP5Yig6ZmkXG5cblxuICAgICAgdGhpcy5fbmVlZHNSZW1vdmUgPSB0cnVlO1xuICAgICAgcmV0dXJuICdkZXN0cm95JztcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgcmVzdGFydDogZnVuY3Rpb24gKGdsb2JhbFRpbWUpIHtcbiAgICB2YXIgcmVtYWluZGVyID0gKGdsb2JhbFRpbWUgLSB0aGlzLl9zdGFydFRpbWUgLSB0aGlzLl9wYXVzZWRUaW1lKSAlIHRoaXMuX2xpZmU7XG4gICAgdGhpcy5fc3RhcnRUaW1lID0gZ2xvYmFsVGltZSAtIHJlbWFpbmRlciArIHRoaXMuZ2FwO1xuICAgIHRoaXMuX3BhdXNlZFRpbWUgPSAwO1xuICAgIHRoaXMuX25lZWRzUmVtb3ZlID0gZmFsc2U7XG4gIH0sXG4gIGZpcmU6IGZ1bmN0aW9uIChldmVudFR5cGUsIGFyZykge1xuICAgIGV2ZW50VHlwZSA9ICdvbicgKyBldmVudFR5cGU7XG5cbiAgICBpZiAodGhpc1tldmVudFR5cGVdKSB7XG4gICAgICB0aGlzW2V2ZW50VHlwZV0odGhpcy5fdGFyZ2V0LCBhcmcpO1xuICAgIH1cbiAgfSxcbiAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICB9LFxuICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IENsaXA7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQ2xpcC5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiDnvJPliqjku6PnoIHmnaXoh6ogaHR0cHM6Ly9naXRodWIuY29tL3NvbGUvdHdlZW4uanMvYmxvYi9tYXN0ZXIvc3JjL1R3ZWVuLmpzXG4gKiBAc2VlIGh0dHA6Ly9zb2xlLmdpdGh1Yi5pby90d2Vlbi5qcy9leGFtcGxlcy8wM19ncmFwaHMuaHRtbFxuICogQGV4cG9ydHMgenJlbmRlci9hbmltYXRpb24vZWFzaW5nXG4gKi9cbnZhciBlYXNpbmcgPSB7XG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBsaW5lYXI6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGs7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1YWRyYXRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrICogaztcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVhZHJhdGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrICogKDIgLSBrKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVhZHJhdGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrO1xuICAgIH1cblxuICAgIHJldHVybiAtMC41ICogKC0tayAqIChrIC0gMikgLSAxKTtcbiAgfSxcbiAgLy8g5LiJ5qyh5pa555qE57yT5Yqo77yIdF4z77yJXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGN1YmljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgKiBrICogaztcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY3ViaWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIC0tayAqIGsgKiBrICsgMTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY3ViaWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrO1xuICAgIH1cblxuICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayArIDIpO1xuICB9LFxuICAvLyDlm5vmrKHmlrnnmoTnvJPliqjvvIh0XjTvvIlcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVhcnRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrICogayAqIGsgKiBrO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWFydGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAxIC0gLS1rICogayAqIGsgKiBrO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWFydGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGs7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0wLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgLSAyKTtcbiAgfSxcbiAgLy8g5LqU5qyh5pa555qE57yT5Yqo77yIdF4177yJXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1aW50aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayAqIGsgKiBrICogayAqIGs7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1aW50aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIC0tayAqIGsgKiBrICogayAqIGsgKyAxO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWludGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGsgKiBrO1xuICAgIH1cblxuICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgKiBrICsgMik7XG4gIH0sXG4gIC8vIOato+W8puabsue6v+eahOe8k+WKqO+8iHNpbih0Ke+8iVxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBzaW51c29pZGFsSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLmNvcyhrICogTWF0aC5QSSAvIDIpO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBzaW51c29pZGFsT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBNYXRoLnNpbihrICogTWF0aC5QSSAvIDIpO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBzaW51c29pZGFsSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKTtcbiAgfSxcbiAgLy8g5oyH5pWw5puy57q/55qE57yT5Yqo77yIMl5077yJXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGV4cG9uZW50aWFsSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgPT09IDAgPyAwIDogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBleHBvbmVudGlhbE91dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayA9PT0gMSA/IDEgOiAxIC0gTWF0aC5wb3coMiwgLTEwICogayk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGV4cG9uZW50aWFsSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKGsgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChrID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuICAgIH1cblxuICAgIHJldHVybiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqIChrIC0gMSkpICsgMik7XG4gIH0sXG4gIC8vIOWchuW9ouabsue6v+eahOe8k+WKqO+8iHNxcnQoMS10XjIp77yJXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGNpcmN1bGFySW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIGsgKiBrKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY2lyY3VsYXJPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgxIC0gLS1rICogayk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGNpcmN1bGFySW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSBrICogaykgLSAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKGsgLT0gMikgKiBrKSArIDEpO1xuICB9LFxuICAvLyDliJvlu7rnsbvkvLzkuo7lvLnnsKflnKjlgZzmraLliY3mnaXlm57mjK/ojaHnmoTliqjnlLtcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgZWxhc3RpY0luOiBmdW5jdGlvbiAoaykge1xuICAgIHZhciBzO1xuICAgIHZhciBhID0gMC4xO1xuICAgIHZhciBwID0gMC40O1xuXG4gICAgaWYgKGsgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChrID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgIGEgPSAxO1xuICAgICAgcyA9IHAgLyA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgIH1cblxuICAgIHJldHVybiAtKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBlbGFzdGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHZhciBzO1xuICAgIHZhciBhID0gMC4xO1xuICAgIHZhciBwID0gMC40O1xuXG4gICAgaWYgKGsgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChrID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgIGEgPSAxO1xuICAgICAgcyA9IHAgLyA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgIH1cblxuICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogaykgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICsgMTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgZWxhc3RpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHZhciBzO1xuICAgIHZhciBhID0gMC4xO1xuICAgIHZhciBwID0gMC40O1xuXG4gICAgaWYgKGsgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChrID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgIGEgPSAxO1xuICAgICAgcyA9IHAgLyA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgIH1cblxuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAtMC41ICogKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuICAgIH1cblxuICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogKGsgLT0gMSkpICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSAqIDAuNSArIDE7XG4gIH0sXG4gIC8vIOWcqOafkOS4gOWKqOeUu+W8gOWni+ayv+aMh+ekuueahOi3r+W+hOi/m+ihjOWKqOeUu+WkhOeQhuWJjeeojeeojeaUtuWbnuivpeWKqOeUu+eahOenu+WKqFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBiYWNrSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiBrICogayAqICgocyArIDEpICogayAtIHMpO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBiYWNrT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHZhciBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gLS1rICogayAqICgocyArIDEpICogayArIHMpICsgMTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgYmFja0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHZhciBzID0gMS43MDE1OCAqIDEuNTI1O1xuXG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIChrICogayAqICgocyArIDEpICogayAtIHMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqICgocyArIDEpICogayArIHMpICsgMik7XG4gIH0sXG4gIC8vIOWIm+W7uuW8uei3s+aViOaenFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBib3VuY2VJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gMSAtIGVhc2luZy5ib3VuY2VPdXQoMSAtIGspO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBib3VuY2VPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKGsgPCAxIC8gMi43NSkge1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIGsgKiBrO1xuICAgIH0gZWxzZSBpZiAoayA8IDIgLyAyLjc1KSB7XG4gICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gMS41IC8gMi43NSkgKiBrICsgMC43NTtcbiAgICB9IGVsc2UgaWYgKGsgPCAyLjUgLyAyLjc1KSB7XG4gICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gMi4yNSAvIDIuNzUpICogayArIDAuOTM3NTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09IDIuNjI1IC8gMi43NSkgKiBrICsgMC45ODQzNzU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBib3VuY2VJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoayA8IDAuNSkge1xuICAgICAgcmV0dXJuIGVhc2luZy5ib3VuY2VJbihrICogMikgKiAwLjU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVhc2luZy5ib3VuY2VPdXQoayAqIDIgLSAxKSAqIDAuNSArIDAuNTtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IGVhc2luZztcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9lYXNpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBMUlUgPSByZXF1aXJlKFwiLi4vY29yZS9MUlVcIik7XG5cbnZhciBrQ1NTQ29sb3JUYWJsZSA9IHtcbiAgJ3RyYW5zcGFyZW50JzogWzAsIDAsIDAsIDBdLFxuICAnYWxpY2VibHVlJzogWzI0MCwgMjQ4LCAyNTUsIDFdLFxuICAnYW50aXF1ZXdoaXRlJzogWzI1MCwgMjM1LCAyMTUsIDFdLFxuICAnYXF1YSc6IFswLCAyNTUsIDI1NSwgMV0sXG4gICdhcXVhbWFyaW5lJzogWzEyNywgMjU1LCAyMTIsIDFdLFxuICAnYXp1cmUnOiBbMjQwLCAyNTUsIDI1NSwgMV0sXG4gICdiZWlnZSc6IFsyNDUsIDI0NSwgMjIwLCAxXSxcbiAgJ2Jpc3F1ZSc6IFsyNTUsIDIyOCwgMTk2LCAxXSxcbiAgJ2JsYWNrJzogWzAsIDAsIDAsIDFdLFxuICAnYmxhbmNoZWRhbG1vbmQnOiBbMjU1LCAyMzUsIDIwNSwgMV0sXG4gICdibHVlJzogWzAsIDAsIDI1NSwgMV0sXG4gICdibHVldmlvbGV0JzogWzEzOCwgNDMsIDIyNiwgMV0sXG4gICdicm93bic6IFsxNjUsIDQyLCA0MiwgMV0sXG4gICdidXJseXdvb2QnOiBbMjIyLCAxODQsIDEzNSwgMV0sXG4gICdjYWRldGJsdWUnOiBbOTUsIDE1OCwgMTYwLCAxXSxcbiAgJ2NoYXJ0cmV1c2UnOiBbMTI3LCAyNTUsIDAsIDFdLFxuICAnY2hvY29sYXRlJzogWzIxMCwgMTA1LCAzMCwgMV0sXG4gICdjb3JhbCc6IFsyNTUsIDEyNywgODAsIDFdLFxuICAnY29ybmZsb3dlcmJsdWUnOiBbMTAwLCAxNDksIDIzNywgMV0sXG4gICdjb3Juc2lsayc6IFsyNTUsIDI0OCwgMjIwLCAxXSxcbiAgJ2NyaW1zb24nOiBbMjIwLCAyMCwgNjAsIDFdLFxuICAnY3lhbic6IFswLCAyNTUsIDI1NSwgMV0sXG4gICdkYXJrYmx1ZSc6IFswLCAwLCAxMzksIDFdLFxuICAnZGFya2N5YW4nOiBbMCwgMTM5LCAxMzksIDFdLFxuICAnZGFya2dvbGRlbnJvZCc6IFsxODQsIDEzNCwgMTEsIDFdLFxuICAnZGFya2dyYXknOiBbMTY5LCAxNjksIDE2OSwgMV0sXG4gICdkYXJrZ3JlZW4nOiBbMCwgMTAwLCAwLCAxXSxcbiAgJ2RhcmtncmV5JzogWzE2OSwgMTY5LCAxNjksIDFdLFxuICAnZGFya2toYWtpJzogWzE4OSwgMTgzLCAxMDcsIDFdLFxuICAnZGFya21hZ2VudGEnOiBbMTM5LCAwLCAxMzksIDFdLFxuICAnZGFya29saXZlZ3JlZW4nOiBbODUsIDEwNywgNDcsIDFdLFxuICAnZGFya29yYW5nZSc6IFsyNTUsIDE0MCwgMCwgMV0sXG4gICdkYXJrb3JjaGlkJzogWzE1MywgNTAsIDIwNCwgMV0sXG4gICdkYXJrcmVkJzogWzEzOSwgMCwgMCwgMV0sXG4gICdkYXJrc2FsbW9uJzogWzIzMywgMTUwLCAxMjIsIDFdLFxuICAnZGFya3NlYWdyZWVuJzogWzE0MywgMTg4LCAxNDMsIDFdLFxuICAnZGFya3NsYXRlYmx1ZSc6IFs3MiwgNjEsIDEzOSwgMV0sXG4gICdkYXJrc2xhdGVncmF5JzogWzQ3LCA3OSwgNzksIDFdLFxuICAnZGFya3NsYXRlZ3JleSc6IFs0NywgNzksIDc5LCAxXSxcbiAgJ2Rhcmt0dXJxdW9pc2UnOiBbMCwgMjA2LCAyMDksIDFdLFxuICAnZGFya3Zpb2xldCc6IFsxNDgsIDAsIDIxMSwgMV0sXG4gICdkZWVwcGluayc6IFsyNTUsIDIwLCAxNDcsIDFdLFxuICAnZGVlcHNreWJsdWUnOiBbMCwgMTkxLCAyNTUsIDFdLFxuICAnZGltZ3JheSc6IFsxMDUsIDEwNSwgMTA1LCAxXSxcbiAgJ2RpbWdyZXknOiBbMTA1LCAxMDUsIDEwNSwgMV0sXG4gICdkb2RnZXJibHVlJzogWzMwLCAxNDQsIDI1NSwgMV0sXG4gICdmaXJlYnJpY2snOiBbMTc4LCAzNCwgMzQsIDFdLFxuICAnZmxvcmFsd2hpdGUnOiBbMjU1LCAyNTAsIDI0MCwgMV0sXG4gICdmb3Jlc3RncmVlbic6IFszNCwgMTM5LCAzNCwgMV0sXG4gICdmdWNoc2lhJzogWzI1NSwgMCwgMjU1LCAxXSxcbiAgJ2dhaW5zYm9ybyc6IFsyMjAsIDIyMCwgMjIwLCAxXSxcbiAgJ2dob3N0d2hpdGUnOiBbMjQ4LCAyNDgsIDI1NSwgMV0sXG4gICdnb2xkJzogWzI1NSwgMjE1LCAwLCAxXSxcbiAgJ2dvbGRlbnJvZCc6IFsyMTgsIDE2NSwgMzIsIDFdLFxuICAnZ3JheSc6IFsxMjgsIDEyOCwgMTI4LCAxXSxcbiAgJ2dyZWVuJzogWzAsIDEyOCwgMCwgMV0sXG4gICdncmVlbnllbGxvdyc6IFsxNzMsIDI1NSwgNDcsIDFdLFxuICAnZ3JleSc6IFsxMjgsIDEyOCwgMTI4LCAxXSxcbiAgJ2hvbmV5ZGV3JzogWzI0MCwgMjU1LCAyNDAsIDFdLFxuICAnaG90cGluayc6IFsyNTUsIDEwNSwgMTgwLCAxXSxcbiAgJ2luZGlhbnJlZCc6IFsyMDUsIDkyLCA5MiwgMV0sXG4gICdpbmRpZ28nOiBbNzUsIDAsIDEzMCwgMV0sXG4gICdpdm9yeSc6IFsyNTUsIDI1NSwgMjQwLCAxXSxcbiAgJ2toYWtpJzogWzI0MCwgMjMwLCAxNDAsIDFdLFxuICAnbGF2ZW5kZXInOiBbMjMwLCAyMzAsIDI1MCwgMV0sXG4gICdsYXZlbmRlcmJsdXNoJzogWzI1NSwgMjQwLCAyNDUsIDFdLFxuICAnbGF3bmdyZWVuJzogWzEyNCwgMjUyLCAwLCAxXSxcbiAgJ2xlbW9uY2hpZmZvbic6IFsyNTUsIDI1MCwgMjA1LCAxXSxcbiAgJ2xpZ2h0Ymx1ZSc6IFsxNzMsIDIxNiwgMjMwLCAxXSxcbiAgJ2xpZ2h0Y29yYWwnOiBbMjQwLCAxMjgsIDEyOCwgMV0sXG4gICdsaWdodGN5YW4nOiBbMjI0LCAyNTUsIDI1NSwgMV0sXG4gICdsaWdodGdvbGRlbnJvZHllbGxvdyc6IFsyNTAsIDI1MCwgMjEwLCAxXSxcbiAgJ2xpZ2h0Z3JheSc6IFsyMTEsIDIxMSwgMjExLCAxXSxcbiAgJ2xpZ2h0Z3JlZW4nOiBbMTQ0LCAyMzgsIDE0NCwgMV0sXG4gICdsaWdodGdyZXknOiBbMjExLCAyMTEsIDIxMSwgMV0sXG4gICdsaWdodHBpbmsnOiBbMjU1LCAxODIsIDE5MywgMV0sXG4gICdsaWdodHNhbG1vbic6IFsyNTUsIDE2MCwgMTIyLCAxXSxcbiAgJ2xpZ2h0c2VhZ3JlZW4nOiBbMzIsIDE3OCwgMTcwLCAxXSxcbiAgJ2xpZ2h0c2t5Ymx1ZSc6IFsxMzUsIDIwNiwgMjUwLCAxXSxcbiAgJ2xpZ2h0c2xhdGVncmF5JzogWzExOSwgMTM2LCAxNTMsIDFdLFxuICAnbGlnaHRzbGF0ZWdyZXknOiBbMTE5LCAxMzYsIDE1MywgMV0sXG4gICdsaWdodHN0ZWVsYmx1ZSc6IFsxNzYsIDE5NiwgMjIyLCAxXSxcbiAgJ2xpZ2h0eWVsbG93JzogWzI1NSwgMjU1LCAyMjQsIDFdLFxuICAnbGltZSc6IFswLCAyNTUsIDAsIDFdLFxuICAnbGltZWdyZWVuJzogWzUwLCAyMDUsIDUwLCAxXSxcbiAgJ2xpbmVuJzogWzI1MCwgMjQwLCAyMzAsIDFdLFxuICAnbWFnZW50YSc6IFsyNTUsIDAsIDI1NSwgMV0sXG4gICdtYXJvb24nOiBbMTI4LCAwLCAwLCAxXSxcbiAgJ21lZGl1bWFxdWFtYXJpbmUnOiBbMTAyLCAyMDUsIDE3MCwgMV0sXG4gICdtZWRpdW1ibHVlJzogWzAsIDAsIDIwNSwgMV0sXG4gICdtZWRpdW1vcmNoaWQnOiBbMTg2LCA4NSwgMjExLCAxXSxcbiAgJ21lZGl1bXB1cnBsZSc6IFsxNDcsIDExMiwgMjE5LCAxXSxcbiAgJ21lZGl1bXNlYWdyZWVuJzogWzYwLCAxNzksIDExMywgMV0sXG4gICdtZWRpdW1zbGF0ZWJsdWUnOiBbMTIzLCAxMDQsIDIzOCwgMV0sXG4gICdtZWRpdW1zcHJpbmdncmVlbic6IFswLCAyNTAsIDE1NCwgMV0sXG4gICdtZWRpdW10dXJxdW9pc2UnOiBbNzIsIDIwOSwgMjA0LCAxXSxcbiAgJ21lZGl1bXZpb2xldHJlZCc6IFsxOTksIDIxLCAxMzMsIDFdLFxuICAnbWlkbmlnaHRibHVlJzogWzI1LCAyNSwgMTEyLCAxXSxcbiAgJ21pbnRjcmVhbSc6IFsyNDUsIDI1NSwgMjUwLCAxXSxcbiAgJ21pc3R5cm9zZSc6IFsyNTUsIDIyOCwgMjI1LCAxXSxcbiAgJ21vY2Nhc2luJzogWzI1NSwgMjI4LCAxODEsIDFdLFxuICAnbmF2YWpvd2hpdGUnOiBbMjU1LCAyMjIsIDE3MywgMV0sXG4gICduYXZ5JzogWzAsIDAsIDEyOCwgMV0sXG4gICdvbGRsYWNlJzogWzI1MywgMjQ1LCAyMzAsIDFdLFxuICAnb2xpdmUnOiBbMTI4LCAxMjgsIDAsIDFdLFxuICAnb2xpdmVkcmFiJzogWzEwNywgMTQyLCAzNSwgMV0sXG4gICdvcmFuZ2UnOiBbMjU1LCAxNjUsIDAsIDFdLFxuICAnb3JhbmdlcmVkJzogWzI1NSwgNjksIDAsIDFdLFxuICAnb3JjaGlkJzogWzIxOCwgMTEyLCAyMTQsIDFdLFxuICAncGFsZWdvbGRlbnJvZCc6IFsyMzgsIDIzMiwgMTcwLCAxXSxcbiAgJ3BhbGVncmVlbic6IFsxNTIsIDI1MSwgMTUyLCAxXSxcbiAgJ3BhbGV0dXJxdW9pc2UnOiBbMTc1LCAyMzgsIDIzOCwgMV0sXG4gICdwYWxldmlvbGV0cmVkJzogWzIxOSwgMTEyLCAxNDcsIDFdLFxuICAncGFwYXlhd2hpcCc6IFsyNTUsIDIzOSwgMjEzLCAxXSxcbiAgJ3BlYWNocHVmZic6IFsyNTUsIDIxOCwgMTg1LCAxXSxcbiAgJ3BlcnUnOiBbMjA1LCAxMzMsIDYzLCAxXSxcbiAgJ3BpbmsnOiBbMjU1LCAxOTIsIDIwMywgMV0sXG4gICdwbHVtJzogWzIyMSwgMTYwLCAyMjEsIDFdLFxuICAncG93ZGVyYmx1ZSc6IFsxNzYsIDIyNCwgMjMwLCAxXSxcbiAgJ3B1cnBsZSc6IFsxMjgsIDAsIDEyOCwgMV0sXG4gICdyZWQnOiBbMjU1LCAwLCAwLCAxXSxcbiAgJ3Jvc3licm93bic6IFsxODgsIDE0MywgMTQzLCAxXSxcbiAgJ3JveWFsYmx1ZSc6IFs2NSwgMTA1LCAyMjUsIDFdLFxuICAnc2FkZGxlYnJvd24nOiBbMTM5LCA2OSwgMTksIDFdLFxuICAnc2FsbW9uJzogWzI1MCwgMTI4LCAxMTQsIDFdLFxuICAnc2FuZHlicm93bic6IFsyNDQsIDE2NCwgOTYsIDFdLFxuICAnc2VhZ3JlZW4nOiBbNDYsIDEzOSwgODcsIDFdLFxuICAnc2Vhc2hlbGwnOiBbMjU1LCAyNDUsIDIzOCwgMV0sXG4gICdzaWVubmEnOiBbMTYwLCA4MiwgNDUsIDFdLFxuICAnc2lsdmVyJzogWzE5MiwgMTkyLCAxOTIsIDFdLFxuICAnc2t5Ymx1ZSc6IFsxMzUsIDIwNiwgMjM1LCAxXSxcbiAgJ3NsYXRlYmx1ZSc6IFsxMDYsIDkwLCAyMDUsIDFdLFxuICAnc2xhdGVncmF5JzogWzExMiwgMTI4LCAxNDQsIDFdLFxuICAnc2xhdGVncmV5JzogWzExMiwgMTI4LCAxNDQsIDFdLFxuICAnc25vdyc6IFsyNTUsIDI1MCwgMjUwLCAxXSxcbiAgJ3NwcmluZ2dyZWVuJzogWzAsIDI1NSwgMTI3LCAxXSxcbiAgJ3N0ZWVsYmx1ZSc6IFs3MCwgMTMwLCAxODAsIDFdLFxuICAndGFuJzogWzIxMCwgMTgwLCAxNDAsIDFdLFxuICAndGVhbCc6IFswLCAxMjgsIDEyOCwgMV0sXG4gICd0aGlzdGxlJzogWzIxNiwgMTkxLCAyMTYsIDFdLFxuICAndG9tYXRvJzogWzI1NSwgOTksIDcxLCAxXSxcbiAgJ3R1cnF1b2lzZSc6IFs2NCwgMjI0LCAyMDgsIDFdLFxuICAndmlvbGV0JzogWzIzOCwgMTMwLCAyMzgsIDFdLFxuICAnd2hlYXQnOiBbMjQ1LCAyMjIsIDE3OSwgMV0sXG4gICd3aGl0ZSc6IFsyNTUsIDI1NSwgMjU1LCAxXSxcbiAgJ3doaXRlc21va2UnOiBbMjQ1LCAyNDUsIDI0NSwgMV0sXG4gICd5ZWxsb3cnOiBbMjU1LCAyNTUsIDAsIDFdLFxuICAneWVsbG93Z3JlZW4nOiBbMTU0LCAyMDUsIDUwLCAxXVxufTtcblxuZnVuY3Rpb24gY2xhbXBDc3NCeXRlKGkpIHtcbiAgLy8gQ2xhbXAgdG8gaW50ZWdlciAwIC4uIDI1NS5cbiAgaSA9IE1hdGgucm91bmQoaSk7IC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxuXG4gIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMjU1ID8gMjU1IDogaTtcbn1cblxuZnVuY3Rpb24gY2xhbXBDc3NBbmdsZShpKSB7XG4gIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAzNjAuXG4gIGkgPSBNYXRoLnJvdW5kKGkpOyAvLyBTZWVtcyB0byBiZSB3aGF0IENocm9tZSBkb2VzICh2cyB0cnVuY2F0aW9uKS5cblxuICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDM2MCA/IDM2MCA6IGk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wQ3NzRmxvYXQoZikge1xuICAvLyBDbGFtcCB0byBmbG9hdCAwLjAgLi4gMS4wLlxuICByZXR1cm4gZiA8IDAgPyAwIDogZiA+IDEgPyAxIDogZjtcbn1cblxuZnVuY3Rpb24gcGFyc2VDc3NJbnQoc3RyKSB7XG4gIC8vIGludCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyLmxlbmd0aCAmJiBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgcmV0dXJuIGNsYW1wQ3NzQnl0ZShwYXJzZUZsb2F0KHN0cikgLyAxMDAgKiAyNTUpO1xuICB9XG5cbiAgcmV0dXJuIGNsYW1wQ3NzQnl0ZShwYXJzZUludChzdHIsIDEwKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ3NzRmxvYXQoc3RyKSB7XG4gIC8vIGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gIGlmIChzdHIubGVuZ3RoICYmIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09PSAnJScpIHtcbiAgICByZXR1cm4gY2xhbXBDc3NGbG9hdChwYXJzZUZsb2F0KHN0cikgLyAxMDApO1xuICB9XG5cbiAgcmV0dXJuIGNsYW1wQ3NzRmxvYXQocGFyc2VGbG9hdChzdHIpKTtcbn1cblxuZnVuY3Rpb24gY3NzSHVlVG9SZ2IobTEsIG0yLCBoKSB7XG4gIGlmIChoIDwgMCkge1xuICAgIGggKz0gMTtcbiAgfSBlbHNlIGlmIChoID4gMSkge1xuICAgIGggLT0gMTtcbiAgfVxuXG4gIGlmIChoICogNiA8IDEpIHtcbiAgICByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiBoICogNjtcbiAgfVxuXG4gIGlmIChoICogMiA8IDEpIHtcbiAgICByZXR1cm4gbTI7XG4gIH1cblxuICBpZiAoaCAqIDMgPCAyKSB7XG4gICAgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDIgLyAzIC0gaCkgKiA2O1xuICB9XG5cbiAgcmV0dXJuIG0xO1xufVxuXG5mdW5jdGlvbiBsZXJwTnVtYmVyKGEsIGIsIHApIHtcbiAgcmV0dXJuIGEgKyAoYiAtIGEpICogcDtcbn1cblxuZnVuY3Rpb24gc2V0UmdiYShvdXQsIHIsIGcsIGIsIGEpIHtcbiAgb3V0WzBdID0gcjtcbiAgb3V0WzFdID0gZztcbiAgb3V0WzJdID0gYjtcbiAgb3V0WzNdID0gYTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gY29weVJnYmEob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbnZhciBjb2xvckNhY2hlID0gbmV3IExSVSgyMCk7XG52YXIgbGFzdFJlbW92ZWRBcnIgPSBudWxsO1xuXG5mdW5jdGlvbiBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKSB7XG4gIC8vIFJldXNlIHJlbW92ZWQgYXJyYXlcbiAgaWYgKGxhc3RSZW1vdmVkQXJyKSB7XG4gICAgY29weVJnYmEobGFzdFJlbW92ZWRBcnIsIHJnYmFBcnIpO1xuICB9XG5cbiAgbGFzdFJlbW92ZWRBcnIgPSBjb2xvckNhY2hlLnB1dChjb2xvclN0ciwgbGFzdFJlbW92ZWRBcnIgfHwgcmdiYUFyci5zbGljZSgpKTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yU3RyXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBvdXRcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlKGNvbG9yU3RyLCByZ2JhQXJyKSB7XG4gIGlmICghY29sb3JTdHIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZ2JhQXJyID0gcmdiYUFyciB8fCBbXTtcbiAgdmFyIGNhY2hlZCA9IGNvbG9yQ2FjaGUuZ2V0KGNvbG9yU3RyKTtcblxuICBpZiAoY2FjaGVkKSB7XG4gICAgcmV0dXJuIGNvcHlSZ2JhKHJnYmFBcnIsIGNhY2hlZCk7XG4gIH0gLy8gY29sb3JTdHIgbWF5IGJlIG5vdCBzdHJpbmdcblxuXG4gIGNvbG9yU3RyID0gY29sb3JTdHIgKyAnJzsgLy8gUmVtb3ZlIGFsbCB3aGl0ZXNwYWNlLCBub3QgY29tcGxpYW50LCBidXQgc2hvdWxkIGp1c3QgYmUgbW9yZSBhY2NlcHRpbmcuXG5cbiAgdmFyIHN0ciA9IGNvbG9yU3RyLnJlcGxhY2UoLyAvZywgJycpLnRvTG93ZXJDYXNlKCk7IC8vIENvbG9yIGtleXdvcmRzIChhbmQgdHJhbnNwYXJlbnQpIGxvb2t1cC5cblxuICBpZiAoc3RyIGluIGtDU1NDb2xvclRhYmxlKSB7XG4gICAgY29weVJnYmEocmdiYUFyciwga0NTU0NvbG9yVGFibGVbc3RyXSk7XG4gICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgcmV0dXJuIHJnYmFBcnI7XG4gIH0gLy8gI2FiYyBhbmQgI2FiYzEyMyBzeW50YXguXG5cblxuICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDQpIHtcbiAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG5cbiAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmYpKSB7XG4gICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgIHJldHVybjsgLy8gQ292ZXJzIE5hTi5cbiAgICAgIH1cblxuICAgICAgc2V0UmdiYShyZ2JhQXJyLCAoaXYgJiAweGYwMCkgPj4gNCB8IChpdiAmIDB4ZjAwKSA+PiA4LCBpdiAmIDB4ZjAgfCAoaXYgJiAweGYwKSA+PiA0LCBpdiAmIDB4ZiB8IChpdiAmIDB4ZikgPDwgNCwgMSk7XG4gICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgIHJldHVybiByZ2JhQXJyO1xuICAgIH0gZWxzZSBpZiAoc3RyLmxlbmd0aCA9PT0gNykge1xuICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cblxuICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZmZmZikpIHtcbiAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgcmV0dXJuOyAvLyBDb3ZlcnMgTmFOLlxuICAgICAgfVxuXG4gICAgICBzZXRSZ2JhKHJnYmFBcnIsIChpdiAmIDB4ZmYwMDAwKSA+PiAxNiwgKGl2ICYgMHhmZjAwKSA+PiA4LCBpdiAmIDB4ZmYsIDEpO1xuICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICByZXR1cm4gcmdiYUFycjtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb3AgPSBzdHIuaW5kZXhPZignKCcpLFxuICAgICAgZXAgPSBzdHIuaW5kZXhPZignKScpO1xuXG4gIGlmIChvcCAhPT0gLTEgJiYgZXAgKyAxID09PSBzdHIubGVuZ3RoKSB7XG4gICAgdmFyIGZuYW1lID0gc3RyLnN1YnN0cigwLCBvcCk7XG4gICAgdmFyIHBhcmFtcyA9IHN0ci5zdWJzdHIob3AgKyAxLCBlcCAtIChvcCArIDEpKS5zcGxpdCgnLCcpO1xuICAgIHZhciBhbHBoYSA9IDE7IC8vIFRvIGFsbG93IGNhc2UgZmFsbHRocm91Z2guXG5cbiAgICBzd2l0Y2ggKGZuYW1lKSB7XG4gICAgICBjYXNlICdyZ2JhJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGFscGhhID0gcGFyc2VDc3NGbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAvLyBGYWxsIHRocm91Z2guXG5cbiAgICAgIGNhc2UgJ3JnYic6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIHBhcnNlQ3NzSW50KHBhcmFtc1swXSksIHBhcnNlQ3NzSW50KHBhcmFtc1sxXSksIHBhcnNlQ3NzSW50KHBhcmFtc1syXSksIGFscGhhKTtcbiAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgIHJldHVybiByZ2JhQXJyO1xuXG4gICAgICBjYXNlICdoc2xhJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtc1szXSA9IHBhcnNlQ3NzRmxvYXQocGFyYW1zWzNdKTtcbiAgICAgICAgaHNsYTJyZ2JhKHBhcmFtcywgcmdiYUFycik7XG4gICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICByZXR1cm4gcmdiYUFycjtcblxuICAgICAgY2FzZSAnaHNsJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGhzbGEycmdiYShwYXJhbXMsIHJnYmFBcnIpO1xuICAgICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICByZXR1cm47XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGhzbGFcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHJnYmFcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSByZ2JhXG4gKi9cblxuXG5mdW5jdGlvbiBoc2xhMnJnYmEoaHNsYSwgcmdiYSkge1xuICB2YXIgaCA9IChwYXJzZUZsb2F0KGhzbGFbMF0pICUgMzYwICsgMzYwKSAlIDM2MCAvIDM2MDsgLy8gMCAuLiAxXG4gIC8vIE5PVEUoZGVhbm0pOiBBY2NvcmRpbmcgdG8gdGhlIENTUyBzcGVjIHMvbCBzaG91bGQgb25seSBiZVxuICAvLyBwZXJjZW50YWdlcywgYnV0IHdlIGRvbid0IGJvdGhlciBhbmQgbGV0IGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG5cbiAgdmFyIHMgPSBwYXJzZUNzc0Zsb2F0KGhzbGFbMV0pO1xuICB2YXIgbCA9IHBhcnNlQ3NzRmxvYXQoaHNsYVsyXSk7XG4gIHZhciBtMiA9IGwgPD0gMC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuICB2YXIgbTEgPSBsICogMiAtIG0yO1xuICByZ2JhID0gcmdiYSB8fCBbXTtcbiAgc2V0UmdiYShyZ2JhLCBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoICsgMSAvIDMpICogMjU1KSwgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCkgKiAyNTUpLCBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoIC0gMSAvIDMpICogMjU1KSwgMSk7XG5cbiAgaWYgKGhzbGEubGVuZ3RoID09PSA0KSB7XG4gICAgcmdiYVszXSA9IGhzbGFbM107XG4gIH1cblxuICByZXR1cm4gcmdiYTtcbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcmdiYVxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IGhzbGFcbiAqL1xuXG5cbmZ1bmN0aW9uIHJnYmEyaHNsYShyZ2JhKSB7XG4gIGlmICghcmdiYSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBSR0IgZnJvbSAwIHRvIDI1NVxuXG5cbiAgdmFyIFIgPSByZ2JhWzBdIC8gMjU1O1xuICB2YXIgRyA9IHJnYmFbMV0gLyAyNTU7XG4gIHZhciBCID0gcmdiYVsyXSAvIDI1NTtcbiAgdmFyIHZNaW4gPSBNYXRoLm1pbihSLCBHLCBCKTsgLy8gTWluLiB2YWx1ZSBvZiBSR0JcblxuICB2YXIgdk1heCA9IE1hdGgubWF4KFIsIEcsIEIpOyAvLyBNYXguIHZhbHVlIG9mIFJHQlxuXG4gIHZhciBkZWx0YSA9IHZNYXggLSB2TWluOyAvLyBEZWx0YSBSR0IgdmFsdWVcblxuICB2YXIgTCA9ICh2TWF4ICsgdk1pbikgLyAyO1xuICB2YXIgSDtcbiAgdmFyIFM7IC8vIEhTTCByZXN1bHRzIGZyb20gMCB0byAxXG5cbiAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgSCA9IDA7XG4gICAgUyA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaWYgKEwgPCAwLjUpIHtcbiAgICAgIFMgPSBkZWx0YSAvICh2TWF4ICsgdk1pbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFMgPSBkZWx0YSAvICgyIC0gdk1heCAtIHZNaW4pO1xuICAgIH1cblxuICAgIHZhciBkZWx0YVIgPSAoKHZNYXggLSBSKSAvIDYgKyBkZWx0YSAvIDIpIC8gZGVsdGE7XG4gICAgdmFyIGRlbHRhRyA9ICgodk1heCAtIEcpIC8gNiArIGRlbHRhIC8gMikgLyBkZWx0YTtcbiAgICB2YXIgZGVsdGFCID0gKCh2TWF4IC0gQikgLyA2ICsgZGVsdGEgLyAyKSAvIGRlbHRhO1xuXG4gICAgaWYgKFIgPT09IHZNYXgpIHtcbiAgICAgIEggPSBkZWx0YUIgLSBkZWx0YUc7XG4gICAgfSBlbHNlIGlmIChHID09PSB2TWF4KSB7XG4gICAgICBIID0gMSAvIDMgKyBkZWx0YVIgLSBkZWx0YUI7XG4gICAgfSBlbHNlIGlmIChCID09PSB2TWF4KSB7XG4gICAgICBIID0gMiAvIDMgKyBkZWx0YUcgLSBkZWx0YVI7XG4gICAgfVxuXG4gICAgaWYgKEggPCAwKSB7XG4gICAgICBIICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKEggPiAxKSB7XG4gICAgICBIIC09IDE7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhzbGEgPSBbSCAqIDM2MCwgUywgTF07XG5cbiAgaWYgKHJnYmFbM10gIT0gbnVsbCkge1xuICAgIGhzbGEucHVzaChyZ2JhWzNdKTtcbiAgfVxuXG4gIHJldHVybiBoc2xhO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFxuICogQHJldHVybiB7c3RyaW5nfVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5cbmZ1bmN0aW9uIGxpZnQoY29sb3IsIGxldmVsKSB7XG4gIHZhciBjb2xvckFyciA9IHBhcnNlKGNvbG9yKTtcblxuICBpZiAoY29sb3JBcnIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgaWYgKGxldmVsIDwgMCkge1xuICAgICAgICBjb2xvckFycltpXSA9IGNvbG9yQXJyW2ldICogKDEgLSBsZXZlbCkgfCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sb3JBcnJbaV0gPSAoMjU1IC0gY29sb3JBcnJbaV0pICogbGV2ZWwgKyBjb2xvckFycltpXSB8IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvckFyciwgY29sb3JBcnIubGVuZ3RoID09PSA0ID8gJ3JnYmEnIDogJ3JnYicpO1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICogQHJldHVybiB7c3RyaW5nfVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvSGV4KGNvbG9yKSB7XG4gIHZhciBjb2xvckFyciA9IHBhcnNlKGNvbG9yKTtcblxuICBpZiAoY29sb3JBcnIpIHtcbiAgICByZXR1cm4gKCgxIDw8IDI0KSArIChjb2xvckFyclswXSA8PCAxNikgKyAoY29sb3JBcnJbMV0gPDwgOCkgKyArY29sb3JBcnJbMl0pLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbiAgfVxufVxuLyoqXG4gKiBNYXAgdmFsdWUgdG8gY29sb3IuIEZhc3RlciB0aGFuIGxlcnAgbWV0aG9kcyBiZWNhdXNlIGNvbG9yIGlzIHJlcHJlc2VudGVkIGJ5IHJnYmEgYXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcn0gbm9ybWFsaXplZFZhbHVlIEEgZmxvYXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBjb2xvcnMgTGlzdCBvZiByZ2JhIGNvbG9yIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbb3V0XSBNYXBwZWQgZ2JhIGNvbG9yIGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gd2lsbCBiZSBudWxsL3VuZGVmaW5lZCBpZiBpbnB1dCBpbGxlZ2FsLlxuICovXG5cblxuZnVuY3Rpb24gZmFzdExlcnAobm9ybWFsaXplZFZhbHVlLCBjb2xvcnMsIG91dCkge1xuICBpZiAoIShjb2xvcnMgJiYgY29sb3JzLmxlbmd0aCkgfHwgIShub3JtYWxpemVkVmFsdWUgPj0gMCAmJiBub3JtYWxpemVkVmFsdWUgPD0gMSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvdXQgPSBvdXQgfHwgW107XG4gIHZhciB2YWx1ZSA9IG5vcm1hbGl6ZWRWYWx1ZSAqIChjb2xvcnMubGVuZ3RoIC0gMSk7XG4gIHZhciBsZWZ0SW5kZXggPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgdmFyIHJpZ2h0SW5kZXggPSBNYXRoLmNlaWwodmFsdWUpO1xuICB2YXIgbGVmdENvbG9yID0gY29sb3JzW2xlZnRJbmRleF07XG4gIHZhciByaWdodENvbG9yID0gY29sb3JzW3JpZ2h0SW5kZXhdO1xuICB2YXIgZHYgPSB2YWx1ZSAtIGxlZnRJbmRleDtcbiAgb3V0WzBdID0gY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzBdLCByaWdodENvbG9yWzBdLCBkdikpO1xuICBvdXRbMV0gPSBjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMV0sIHJpZ2h0Q29sb3JbMV0sIGR2KSk7XG4gIG91dFsyXSA9IGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclsyXSwgcmlnaHRDb2xvclsyXSwgZHYpKTtcbiAgb3V0WzNdID0gY2xhbXBDc3NGbG9hdChsZXJwTnVtYmVyKGxlZnRDb2xvclszXSwgcmlnaHRDb2xvclszXSwgZHYpKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuXG5cbnZhciBmYXN0TWFwVG9Db2xvciA9IGZhc3RMZXJwO1xuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbm9ybWFsaXplZFZhbHVlIEEgZmxvYXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY29sb3JzIENvbG9yIGxpc3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBmdWxsT3V0cHV0IERlZmF1bHQgZmFsc2UuXG4gKiBAcmV0dXJuIHsoc3RyaW5nfE9iamVjdCl9IFJlc3VsdCBjb2xvci4gSWYgZnVsbE91dHB1dCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtjb2xvcjogLi4uLCBsZWZ0SW5kZXg6IC4uLiwgcmlnaHRJbmRleDogLi4uLCB2YWx1ZTogLi4ufSxcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuZnVuY3Rpb24gbGVycChub3JtYWxpemVkVmFsdWUsIGNvbG9ycywgZnVsbE91dHB1dCkge1xuICBpZiAoIShjb2xvcnMgJiYgY29sb3JzLmxlbmd0aCkgfHwgIShub3JtYWxpemVkVmFsdWUgPj0gMCAmJiBub3JtYWxpemVkVmFsdWUgPD0gMSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdmFsdWUgPSBub3JtYWxpemVkVmFsdWUgKiAoY29sb3JzLmxlbmd0aCAtIDEpO1xuICB2YXIgbGVmdEluZGV4ID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gIHZhciByaWdodEluZGV4ID0gTWF0aC5jZWlsKHZhbHVlKTtcbiAgdmFyIGxlZnRDb2xvciA9IHBhcnNlKGNvbG9yc1tsZWZ0SW5kZXhdKTtcbiAgdmFyIHJpZ2h0Q29sb3IgPSBwYXJzZShjb2xvcnNbcmlnaHRJbmRleF0pO1xuICB2YXIgZHYgPSB2YWx1ZSAtIGxlZnRJbmRleDtcbiAgdmFyIGNvbG9yID0gc3RyaW5naWZ5KFtjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMF0sIHJpZ2h0Q29sb3JbMF0sIGR2KSksIGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclsxXSwgcmlnaHRDb2xvclsxXSwgZHYpKSwgY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzJdLCByaWdodENvbG9yWzJdLCBkdikpLCBjbGFtcENzc0Zsb2F0KGxlcnBOdW1iZXIobGVmdENvbG9yWzNdLCByaWdodENvbG9yWzNdLCBkdikpXSwgJ3JnYmEnKTtcbiAgcmV0dXJuIGZ1bGxPdXRwdXQgPyB7XG4gICAgY29sb3I6IGNvbG9yLFxuICAgIGxlZnRJbmRleDogbGVmdEluZGV4LFxuICAgIHJpZ2h0SW5kZXg6IHJpZ2h0SW5kZXgsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH0gOiBjb2xvcjtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuXG5cbnZhciBtYXBUb0NvbG9yID0gbGVycDtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gKiBAcGFyYW0ge251bWJlcj19IGggMCB+IDM2MCwgaWdub3JlIHdoZW4gbnVsbC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gcyAwIH4gMSwgaWdub3JlIHdoZW4gbnVsbC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gbCAwIH4gMSwgaWdub3JlIHdoZW4gbnVsbC5cbiAqIEByZXR1cm4ge3N0cmluZ30gQ29sb3Igc3RyaW5nIGluIHJnYmEgZm9ybWF0LlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5mdW5jdGlvbiBtb2RpZnlIU0woY29sb3IsIGgsIHMsIGwpIHtcbiAgY29sb3IgPSBwYXJzZShjb2xvcik7XG5cbiAgaWYgKGNvbG9yKSB7XG4gICAgY29sb3IgPSByZ2JhMmhzbGEoY29sb3IpO1xuICAgIGggIT0gbnVsbCAmJiAoY29sb3JbMF0gPSBjbGFtcENzc0FuZ2xlKGgpKTtcbiAgICBzICE9IG51bGwgJiYgKGNvbG9yWzFdID0gcGFyc2VDc3NGbG9hdChzKSk7XG4gICAgbCAhPSBudWxsICYmIChjb2xvclsyXSA9IHBhcnNlQ3NzRmxvYXQobCkpO1xuICAgIHJldHVybiBzdHJpbmdpZnkoaHNsYTJyZ2JhKGNvbG9yKSwgJ3JnYmEnKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAqIEBwYXJhbSB7bnVtYmVyPX0gYWxwaGEgMCB+IDFcbiAqIEByZXR1cm4ge3N0cmluZ30gQ29sb3Igc3RyaW5nIGluIHJnYmEgZm9ybWF0LlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5cbmZ1bmN0aW9uIG1vZGlmeUFscGhhKGNvbG9yLCBhbHBoYSkge1xuICBjb2xvciA9IHBhcnNlKGNvbG9yKTtcblxuICBpZiAoY29sb3IgJiYgYWxwaGEgIT0gbnVsbCkge1xuICAgIGNvbG9yWzNdID0gY2xhbXBDc3NGbG9hdChhbHBoYSk7XG4gICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvciwgJ3JnYmEnKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhcnJDb2xvciBsaWtlIFsxMiwzMyw0NCwwLjRdXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAncmdiYScsICdoc3ZhJywgLi4uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJlc3VsdCBjb2xvci4gKElmIGlucHV0IGlsbGVnYWwsIHJldHVybiB1bmRlZmluZWQpLlxuICovXG5cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFyckNvbG9yLCB0eXBlKSB7XG4gIGlmICghYXJyQ29sb3IgfHwgIWFyckNvbG9yLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb2xvclN0ciA9IGFyckNvbG9yWzBdICsgJywnICsgYXJyQ29sb3JbMV0gKyAnLCcgKyBhcnJDb2xvclsyXTtcblxuICBpZiAodHlwZSA9PT0gJ3JnYmEnIHx8IHR5cGUgPT09ICdoc3ZhJyB8fCB0eXBlID09PSAnaHNsYScpIHtcbiAgICBjb2xvclN0ciArPSAnLCcgKyBhcnJDb2xvclszXTtcbiAgfVxuXG4gIHJldHVybiB0eXBlICsgJygnICsgY29sb3JTdHIgKyAnKSc7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMubGlmdCA9IGxpZnQ7XG5leHBvcnRzLnRvSGV4ID0gdG9IZXg7XG5leHBvcnRzLmZhc3RMZXJwID0gZmFzdExlcnA7XG5leHBvcnRzLmZhc3RNYXBUb0NvbG9yID0gZmFzdE1hcFRvQ29sb3I7XG5leHBvcnRzLmxlcnAgPSBsZXJwO1xuZXhwb3J0cy5tYXBUb0NvbG9yID0gbWFwVG9Db2xvcjtcbmV4cG9ydHMubW9kaWZ5SFNMID0gbW9kaWZ5SFNMO1xuZXhwb3J0cy5tb2RpZnlBbHBoYSA9IG1vZGlmeUFscGhhO1xuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL3Rvb2wvY29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFNpbXBsZSBMUlUgY2FjaGUgdXNlIGRvdWJseSBsaW5rZWQgbGlzdFxuLy8gQG1vZHVsZSB6cmVuZGVyL2NvcmUvTFJVXG5cbi8qKlxuICogU2ltcGxlIGRvdWJsZSBsaW5rZWQgbGlzdC4gQ29tcGFyZWQgd2l0aCBhcnJheSwgaXQgaGFzIE8oMSkgcmVtb3ZlIG9wZXJhdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTGlua2VkTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICovXG4gIHRoaXMuaGVhZCA9IG51bGw7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAqL1xuXG4gIHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMuX2xlbiA9IDA7XG59O1xuXG52YXIgbGlua2VkTGlzdFByb3RvID0gTGlua2VkTGlzdC5wcm90b3R5cGU7XG4vKipcbiAqIEluc2VydCBhIG5ldyB2YWx1ZSBhdCB0aGUgdGFpbFxuICogQHBhcmFtICB7fSB2YWxcbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICovXG5cbmxpbmtlZExpc3RQcm90by5pbnNlcnQgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHZhciBlbnRyeSA9IG5ldyBFbnRyeSh2YWwpO1xuICB0aGlzLmluc2VydEVudHJ5KGVudHJ5KTtcbiAgcmV0dXJuIGVudHJ5O1xufTtcbi8qKlxuICogSW5zZXJ0IGFuIGVudHJ5IGF0IHRoZSB0YWlsXG4gKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX0gZW50cnlcbiAqL1xuXG5cbmxpbmtlZExpc3RQcm90by5pbnNlcnRFbnRyeSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IGVudHJ5O1xuICB9IGVsc2Uge1xuICAgIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7XG4gICAgZW50cnkucHJldiA9IHRoaXMudGFpbDtcbiAgICBlbnRyeS5uZXh0ID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgfVxuXG4gIHRoaXMuX2xlbisrO1xufTtcbi8qKlxuICogUmVtb3ZlIGVudHJ5LlxuICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9IGVudHJ5XG4gKi9cblxuXG5saW5rZWRMaXN0UHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gIHZhciBwcmV2ID0gZW50cnkucHJldjtcbiAgdmFyIG5leHQgPSBlbnRyeS5uZXh0O1xuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgfSBlbHNlIHtcbiAgICAvLyBJcyBoZWFkXG4gICAgdGhpcy5oZWFkID0gbmV4dDtcbiAgfVxuXG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5wcmV2ID0gcHJldjtcbiAgfSBlbHNlIHtcbiAgICAvLyBJcyB0YWlsXG4gICAgdGhpcy50YWlsID0gcHJldjtcbiAgfVxuXG4gIGVudHJ5Lm5leHQgPSBlbnRyeS5wcmV2ID0gbnVsbDtcbiAgdGhpcy5fbGVuLS07XG59O1xuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5saW5rZWRMaXN0UHJvdG8ubGVuID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fbGVuO1xufTtcbi8qKlxuICogQ2xlYXIgbGlzdFxuICovXG5cblxubGlua2VkTGlzdFByb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICB0aGlzLl9sZW4gPSAwO1xufTtcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge30gdmFsXG4gKi9cblxuXG52YXIgRW50cnkgPSBmdW5jdGlvbiAodmFsKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7fVxuICAgKi9cbiAgdGhpcy52YWx1ZSA9IHZhbDtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICovXG5cbiAgdGhpcy5uZXh0O1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgKi9cblxuICB0aGlzLnByZXY7XG59O1xuLyoqXG4gKiBMUlUgQ2FjaGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2NvcmUvTFJVXG4gKi9cblxuXG52YXIgTFJVID0gZnVuY3Rpb24gKG1heFNpemUpIHtcbiAgdGhpcy5fbGlzdCA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gIHRoaXMuX21hcCA9IHt9O1xuICB0aGlzLl9tYXhTaXplID0gbWF4U2l6ZSB8fCAxMDtcbiAgdGhpcy5fbGFzdFJlbW92ZWRFbnRyeSA9IG51bGw7XG59O1xuXG52YXIgTFJVUHJvdG8gPSBMUlUucHJvdG90eXBlO1xuLyoqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGtleVxuICogQHBhcmFtICB7fSB2YWx1ZVxuICogQHJldHVybiB7fSBSZW1vdmVkIHZhbHVlXG4gKi9cblxuTFJVUHJvdG8ucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdmFyIGxpc3QgPSB0aGlzLl9saXN0O1xuICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuICB2YXIgcmVtb3ZlZCA9IG51bGw7XG5cbiAgaWYgKG1hcFtrZXldID09IG51bGwpIHtcbiAgICB2YXIgbGVuID0gbGlzdC5sZW4oKTsgLy8gUmV1c2UgbGFzdCByZW1vdmVkIGVudHJ5XG5cbiAgICB2YXIgZW50cnkgPSB0aGlzLl9sYXN0UmVtb3ZlZEVudHJ5O1xuXG4gICAgaWYgKGxlbiA+PSB0aGlzLl9tYXhTaXplICYmIGxlbiA+IDApIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZFxuICAgICAgdmFyIGxlYXN0VXNlZEVudHJ5ID0gbGlzdC5oZWFkO1xuICAgICAgbGlzdC5yZW1vdmUobGVhc3RVc2VkRW50cnkpO1xuICAgICAgZGVsZXRlIG1hcFtsZWFzdFVzZWRFbnRyeS5rZXldO1xuICAgICAgcmVtb3ZlZCA9IGxlYXN0VXNlZEVudHJ5LnZhbHVlO1xuICAgICAgdGhpcy5fbGFzdFJlbW92ZWRFbnRyeSA9IGxlYXN0VXNlZEVudHJ5O1xuICAgIH1cblxuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkudmFsdWUgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50cnkgPSBuZXcgRW50cnkodmFsdWUpO1xuICAgIH1cblxuICAgIGVudHJ5LmtleSA9IGtleTtcbiAgICBsaXN0Lmluc2VydEVudHJ5KGVudHJ5KTtcbiAgICBtYXBba2V5XSA9IGVudHJ5O1xuICB9XG5cbiAgcmV0dXJuIHJlbW92ZWQ7XG59O1xuLyoqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGtleVxuICogQHJldHVybiB7fVxuICovXG5cblxuTFJVUHJvdG8uZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICB2YXIgZW50cnkgPSB0aGlzLl9tYXBba2V5XTtcbiAgdmFyIGxpc3QgPSB0aGlzLl9saXN0O1xuXG4gIGlmIChlbnRyeSAhPSBudWxsKSB7XG4gICAgLy8gUHV0IHRoZSBsYXRlc3QgdXNlZCBlbnRyeSBpbiB0aGUgdGFpbFxuICAgIGlmIChlbnRyeSAhPT0gbGlzdC50YWlsKSB7XG4gICAgICBsaXN0LnJlbW92ZShlbnRyeSk7XG4gICAgICBsaXN0Lmluc2VydEVudHJ5KGVudHJ5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gIH1cbn07XG4vKipcbiAqIENsZWFyIHRoZSBjYWNoZVxuICovXG5cblxuTFJVUHJvdG8uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2xpc3QuY2xlYXIoKTtcblxuICB0aGlzLl9tYXAgPSB7fTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IExSVTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvTFJVLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi9jb25maWdcIik7XG5cbnZhciBkZWJ1Z01vZGUgPSBfY29uZmlnLmRlYnVnTW9kZTtcblxudmFyIGxvZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG5pZiAoZGVidWdNb2RlID09PSAxKSB7XG4gIGxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBrIGluIGFyZ3VtZW50cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGFyZ3VtZW50c1trXSk7XG4gICAgfVxuICB9O1xufSBlbHNlIGlmIChkZWJ1Z01vZGUgPiAxKSB7XG4gIGxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBrIGluIGFyZ3VtZW50cykge1xuICAgICAgY29uc29sZS5sb2coYXJndW1lbnRzW2tdKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBfZGVmYXVsdCA9IGxvZztcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvbG9nLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZHByID0gMTsgLy8gSWYgaW4gYnJvd3NlciBlbnZpcm9ubWVudFxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZHByID0gTWF0aC5tYXgod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSwgMSk7XG59XG4vKipcbiAqIGNvbmZpZ+m7mOiupOmFjee9rumhuVxuICogQGV4cG9ydHMgenJlbmRlci9jb25maWdcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICogZGVidWfml6Xlv5fpgInpobnvvJpjYXRjaEJydXNoRXhjZXB0aW9u5Li6dHJ1ZeS4i+acieaViFxuICogMCA6IOS4jeeUn+aIkGRlYnVn5pWw5o2u77yM5Y+R5biD55SoXG4gKiAxIDog5byC5bi45oqb5Ye677yM6LCD6K+V55SoXG4gKiAyIDog5o6n5Yi25Y+w6L6T5Ye677yM6LCD6K+V55SoXG4gKi9cblxuXG52YXIgZGVidWdNb2RlID0gMDsgLy8gcmV0aW5hIOWxj+W5leS8mOWMllxuXG52YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IGRwcjtcbmV4cG9ydHMuZGVidWdNb2RlID0gZGVidWdNb2RlO1xuZXhwb3J0cy5kZXZpY2VQaXhlbFJhdGlvID0gZGV2aWNlUGl4ZWxSYXRpbztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29uZmlnLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdmVjMiA9IHJlcXVpcmUoXCIuL3ZlY3RvclwiKTtcblxudmFyIG1hdHJpeCA9IHJlcXVpcmUoXCIuL21hdHJpeFwiKTtcblxuLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3RcbiAqL1xudmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSB2ZWMyLmFwcGx5VHJhbnNmb3JtO1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdFxuICovXG5cbmZ1bmN0aW9uIEJvdW5kaW5nUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGlmICh3aWR0aCA8IDApIHtcbiAgICB4ID0geCArIHdpZHRoO1xuICAgIHdpZHRoID0gLXdpZHRoO1xuICB9XG5cbiAgaWYgKGhlaWdodCA8IDApIHtcbiAgICB5ID0geSArIGhlaWdodDtcbiAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuXG4gIHRoaXMueCA9IHg7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLnkgPSB5O1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG59XG5cbkJvdW5kaW5nUmVjdC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBCb3VuZGluZ1JlY3QsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R9IG90aGVyXG4gICAqL1xuICB1bmlvbjogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgdmFyIHggPSBtYXRoTWluKG90aGVyLngsIHRoaXMueCk7XG4gICAgdmFyIHkgPSBtYXRoTWluKG90aGVyLnksIHRoaXMueSk7XG4gICAgdGhpcy53aWR0aCA9IG1hdGhNYXgob3RoZXIueCArIG90aGVyLndpZHRoLCB0aGlzLnggKyB0aGlzLndpZHRoKSAtIHg7XG4gICAgdGhpcy5oZWlnaHQgPSBtYXRoTWF4KG90aGVyLnkgKyBvdGhlci5oZWlnaHQsIHRoaXMueSArIHRoaXMuaGVpZ2h0KSAtIHk7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtXG4gICAqIEBtZXRob2RzXG4gICAqL1xuICBhcHBseVRyYW5zZm9ybTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBsdCA9IFtdO1xuICAgIHZhciByYiA9IFtdO1xuICAgIHZhciBsYiA9IFtdO1xuICAgIHZhciBydCA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiAobSkge1xuICAgICAgLy8gSW4gY2FzZSB1c2FnZSBsaWtlIHRoaXNcbiAgICAgIC8vIGVsLmdldEJvdW5kaW5nUmVjdCgpLmFwcGx5VHJhbnNmb3JtKGVsLnRyYW5zZm9ybSlcbiAgICAgIC8vIEFuZCBlbGVtZW50IGhhcyBubyB0cmFuc2Zvcm1cbiAgICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGx0WzBdID0gbGJbMF0gPSB0aGlzLng7XG4gICAgICBsdFsxXSA9IHJ0WzFdID0gdGhpcy55O1xuICAgICAgcmJbMF0gPSBydFswXSA9IHRoaXMueCArIHRoaXMud2lkdGg7XG4gICAgICByYlsxXSA9IGxiWzFdID0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKGx0LCBsdCwgbSk7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKHJiLCByYiwgbSk7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKGxiLCBsYiwgbSk7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKHJ0LCBydCwgbSk7XG4gICAgICB0aGlzLnggPSBtYXRoTWluKGx0WzBdLCByYlswXSwgbGJbMF0sIHJ0WzBdKTtcbiAgICAgIHRoaXMueSA9IG1hdGhNaW4obHRbMV0sIHJiWzFdLCBsYlsxXSwgcnRbMV0pO1xuICAgICAgdmFyIG1heFggPSBtYXRoTWF4KGx0WzBdLCByYlswXSwgbGJbMF0sIHJ0WzBdKTtcbiAgICAgIHZhciBtYXhZID0gbWF0aE1heChsdFsxXSwgcmJbMV0sIGxiWzFdLCBydFsxXSk7XG4gICAgICB0aGlzLndpZHRoID0gbWF4WCAtIHRoaXMueDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gbWF4WSAtIHRoaXMueTtcbiAgICB9O1xuICB9KCksXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBtYXRyaXggb2YgdHJhbnNmb3JtaW5nIGZyb20gc2VsZiB0byB0YXJnZXQgcmVjdFxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH0gYlxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIGNhbGN1bGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKGIpIHtcbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgdmFyIHN4ID0gYi53aWR0aCAvIGEud2lkdGg7XG4gICAgdmFyIHN5ID0gYi5oZWlnaHQgLyBhLmhlaWdodDtcbiAgICB2YXIgbSA9IG1hdHJpeC5jcmVhdGUoKTsgLy8g55+p6Zi15Y+z5LmYXG5cbiAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFstYS54LCAtYS55XSk7XG4gICAgbWF0cml4LnNjYWxlKG0sIG0sIFtzeCwgc3ldKTtcbiAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFtiLngsIGIueV0pO1xuICAgIHJldHVybiBtO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyhtb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdHxPYmplY3QpfSBiXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpbnRlcnNlY3Q6IGZ1bmN0aW9uIChiKSB7XG4gICAgaWYgKCFiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCEoYiBpbnN0YW5jZW9mIEJvdW5kaW5nUmVjdCkpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZSBuZWdhdGl2ZSB3aWR0aC9oZWlnaHQuXG4gICAgICBiID0gQm91bmRpbmdSZWN0LmNyZWF0ZShiKTtcbiAgICB9XG5cbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgdmFyIGF4MCA9IGEueDtcbiAgICB2YXIgYXgxID0gYS54ICsgYS53aWR0aDtcbiAgICB2YXIgYXkwID0gYS55O1xuICAgIHZhciBheTEgPSBhLnkgKyBhLmhlaWdodDtcbiAgICB2YXIgYngwID0gYi54O1xuICAgIHZhciBieDEgPSBiLnggKyBiLndpZHRoO1xuICAgIHZhciBieTAgPSBiLnk7XG4gICAgdmFyIGJ5MSA9IGIueSArIGIuaGVpZ2h0O1xuICAgIHJldHVybiAhKGF4MSA8IGJ4MCB8fCBieDEgPCBheDAgfHwgYXkxIDwgYnkwIHx8IGJ5MSA8IGF5MCk7XG4gIH0sXG4gIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIHJlY3QgPSB0aGlzO1xuICAgIHJldHVybiB4ID49IHJlY3QueCAmJiB4IDw9IHJlY3QueCArIHJlY3Qud2lkdGggJiYgeSA+PSByZWN0LnkgJiYgeSA8PSByZWN0LnkgKyByZWN0LmhlaWdodDtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAqL1xuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgQm91bmRpbmdSZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvcHkgZnJvbSBhbm90aGVyIHJlY3RcbiAgICovXG4gIGNvcHk6IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHRoaXMueCA9IG90aGVyLng7XG4gICAgdGhpcy55ID0gb3RoZXIueTtcbiAgICB0aGlzLndpZHRoID0gb3RoZXIud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBvdGhlci5oZWlnaHQ7XG4gIH0sXG4gIHBsYWluOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHRoaXMueCxcbiAgICAgIHk6IHRoaXMueSxcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fG1vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSByZWN0XG4gKiBAcGFyYW0ge251bWJlcn0gcmVjdC54XG4gKiBAcGFyYW0ge251bWJlcn0gcmVjdC55XG4gKiBAcGFyYW0ge251bWJlcn0gcmVjdC53aWR0aFxuICogQHBhcmFtIHtudW1iZXJ9IHJlY3QuaGVpZ2h0XG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAqL1xuXG5Cb3VuZGluZ1JlY3QuY3JlYXRlID0gZnVuY3Rpb24gKHJlY3QpIHtcbiAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IEJvdW5kaW5nUmVjdDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbXppY2NhcmQvbm9kZS10aW1zb3J0XG52YXIgREVGQVVMVF9NSU5fTUVSR0UgPSAzMjtcbnZhciBERUZBVUxUX01JTl9HQUxMT1BJTkcgPSA3O1xudmFyIERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIID0gMjU2O1xuXG5mdW5jdGlvbiBtaW5SdW5MZW5ndGgobikge1xuICB2YXIgciA9IDA7XG5cbiAgd2hpbGUgKG4gPj0gREVGQVVMVF9NSU5fTUVSR0UpIHtcbiAgICByIHw9IG4gJiAxO1xuICAgIG4gPj49IDE7XG4gIH1cblxuICByZXR1cm4gbiArIHI7XG59XG5cbmZ1bmN0aW9uIG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSkge1xuICB2YXIgcnVuSGkgPSBsbyArIDE7XG5cbiAgaWYgKHJ1bkhpID09PSBoaSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgaWYgKGNvbXBhcmUoYXJyYXlbcnVuSGkrK10sIGFycmF5W2xvXSkgPCAwKSB7XG4gICAgd2hpbGUgKHJ1bkhpIDwgaGkgJiYgY29tcGFyZShhcnJheVtydW5IaV0sIGFycmF5W3J1bkhpIC0gMV0pIDwgMCkge1xuICAgICAgcnVuSGkrKztcbiAgICB9XG5cbiAgICByZXZlcnNlUnVuKGFycmF5LCBsbywgcnVuSGkpO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChydW5IaSA8IGhpICYmIGNvbXBhcmUoYXJyYXlbcnVuSGldLCBhcnJheVtydW5IaSAtIDFdKSA+PSAwKSB7XG4gICAgICBydW5IaSsrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBydW5IaSAtIGxvO1xufVxuXG5mdW5jdGlvbiByZXZlcnNlUnVuKGFycmF5LCBsbywgaGkpIHtcbiAgaGktLTtcblxuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIHZhciB0ID0gYXJyYXlbbG9dO1xuICAgIGFycmF5W2xvKytdID0gYXJyYXlbaGldO1xuICAgIGFycmF5W2hpLS1dID0gdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgaGksIHN0YXJ0LCBjb21wYXJlKSB7XG4gIGlmIChzdGFydCA9PT0gbG8pIHtcbiAgICBzdGFydCsrO1xuICB9XG5cbiAgZm9yICg7IHN0YXJ0IDwgaGk7IHN0YXJ0KyspIHtcbiAgICB2YXIgcGl2b3QgPSBhcnJheVtzdGFydF07XG4gICAgdmFyIGxlZnQgPSBsbztcbiAgICB2YXIgcmlnaHQgPSBzdGFydDtcbiAgICB2YXIgbWlkO1xuXG4gICAgd2hpbGUgKGxlZnQgPCByaWdodCkge1xuICAgICAgbWlkID0gbGVmdCArIHJpZ2h0ID4+PiAxO1xuXG4gICAgICBpZiAoY29tcGFyZShwaXZvdCwgYXJyYXlbbWlkXSkgPCAwKSB7XG4gICAgICAgIHJpZ2h0ID0gbWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCA9IG1pZCArIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG4gPSBzdGFydCAtIGxlZnQ7XG5cbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgYXJyYXlbbGVmdCArIDNdID0gYXJyYXlbbGVmdCArIDJdO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIGFycmF5W2xlZnQgKyAyXSA9IGFycmF5W2xlZnQgKyAxXTtcblxuICAgICAgY2FzZSAxOlxuICAgICAgICBhcnJheVtsZWZ0ICsgMV0gPSBhcnJheVtsZWZ0XTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAgIGFycmF5W2xlZnQgKyBuXSA9IGFycmF5W2xlZnQgKyBuIC0gMV07XG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBhcnJheVtsZWZ0XSA9IHBpdm90O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdhbGxvcExlZnQodmFsdWUsIGFycmF5LCBzdGFydCwgbGVuZ3RoLCBoaW50LCBjb21wYXJlKSB7XG4gIHZhciBsYXN0T2Zmc2V0ID0gMDtcbiAgdmFyIG1heE9mZnNldCA9IDA7XG4gIHZhciBvZmZzZXQgPSAxO1xuXG4gIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnRdKSA+IDApIHtcbiAgICBtYXhPZmZzZXQgPSBsZW5ndGggLSBoaW50O1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgKyBvZmZzZXRdKSA+IDApIHtcbiAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgfVxuXG4gICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgIG9mZnNldCArPSBoaW50O1xuICB9IGVsc2Uge1xuICAgIG1heE9mZnNldCA9IGhpbnQgKyAxO1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgLSBvZmZzZXRdKSA8PSAwKSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgIH1cblxuICAgIHZhciB0bXAgPSBsYXN0T2Zmc2V0O1xuICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGhpbnQgLSB0bXA7XG4gIH1cblxuICBsYXN0T2Zmc2V0Kys7XG5cbiAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICB2YXIgbSA9IGxhc3RPZmZzZXQgKyAob2Zmc2V0IC0gbGFzdE9mZnNldCA+Pj4gMSk7XG5cbiAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBtXSkgPiAwKSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gbSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCA9IG07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gZ2FsbG9wUmlnaHQodmFsdWUsIGFycmF5LCBzdGFydCwgbGVuZ3RoLCBoaW50LCBjb21wYXJlKSB7XG4gIHZhciBsYXN0T2Zmc2V0ID0gMDtcbiAgdmFyIG1heE9mZnNldCA9IDA7XG4gIHZhciBvZmZzZXQgPSAxO1xuXG4gIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnRdKSA8IDApIHtcbiAgICBtYXhPZmZzZXQgPSBoaW50ICsgMTtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50IC0gb2Zmc2V0XSkgPCAwKSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgIH1cblxuICAgIHZhciB0bXAgPSBsYXN0T2Zmc2V0O1xuICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGhpbnQgLSB0bXA7XG4gIH0gZWxzZSB7XG4gICAgbWF4T2Zmc2V0ID0gbGVuZ3RoIC0gaGludDtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50ICsgb2Zmc2V0XSkgPj0gMCkge1xuICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICB9XG5cbiAgICBsYXN0T2Zmc2V0ICs9IGhpbnQ7XG4gICAgb2Zmc2V0ICs9IGhpbnQ7XG4gIH1cblxuICBsYXN0T2Zmc2V0Kys7XG5cbiAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICB2YXIgbSA9IGxhc3RPZmZzZXQgKyAob2Zmc2V0IC0gbGFzdE9mZnNldCA+Pj4gMSk7XG5cbiAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBtXSkgPCAwKSB7XG4gICAgICBvZmZzZXQgPSBtO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gbSArIDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gVGltU29ydChhcnJheSwgY29tcGFyZSkge1xuICB2YXIgbWluR2FsbG9wID0gREVGQVVMVF9NSU5fR0FMTE9QSU5HO1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIHRtcFN0b3JhZ2VMZW5ndGggPSBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSDtcbiAgdmFyIHN0YWNrTGVuZ3RoID0gMDtcbiAgdmFyIHJ1blN0YXJ0O1xuICB2YXIgcnVuTGVuZ3RoO1xuICB2YXIgc3RhY2tTaXplID0gMDtcbiAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPCAyICogREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEgpIHtcbiAgICB0bXBTdG9yYWdlTGVuZ3RoID0gbGVuZ3RoID4+PiAxO1xuICB9XG5cbiAgdmFyIHRtcCA9IFtdO1xuICBzdGFja0xlbmd0aCA9IGxlbmd0aCA8IDEyMCA/IDUgOiBsZW5ndGggPCAxNTQyID8gMTAgOiBsZW5ndGggPCAxMTkxNTEgPyAxOSA6IDQwO1xuICBydW5TdGFydCA9IFtdO1xuICBydW5MZW5ndGggPSBbXTtcblxuICBmdW5jdGlvbiBwdXNoUnVuKF9ydW5TdGFydCwgX3J1bkxlbmd0aCkge1xuICAgIHJ1blN0YXJ0W3N0YWNrU2l6ZV0gPSBfcnVuU3RhcnQ7XG4gICAgcnVuTGVuZ3RoW3N0YWNrU2l6ZV0gPSBfcnVuTGVuZ3RoO1xuICAgIHN0YWNrU2l6ZSArPSAxO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VSdW5zKCkge1xuICAgIHdoaWxlIChzdGFja1NpemUgPiAxKSB7XG4gICAgICB2YXIgbiA9IHN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgIGlmIChuID49IDEgJiYgcnVuTGVuZ3RoW24gLSAxXSA8PSBydW5MZW5ndGhbbl0gKyBydW5MZW5ndGhbbiArIDFdIHx8IG4gPj0gMiAmJiBydW5MZW5ndGhbbiAtIDJdIDw9IHJ1bkxlbmd0aFtuXSArIHJ1bkxlbmd0aFtuIC0gMV0pIHtcbiAgICAgICAgaWYgKHJ1bkxlbmd0aFtuIC0gMV0gPCBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJ1bkxlbmd0aFtuXSA+IHJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG1lcmdlQXQobik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZm9yY2VNZXJnZVJ1bnMoKSB7XG4gICAgd2hpbGUgKHN0YWNrU2l6ZSA+IDEpIHtcbiAgICAgIHZhciBuID0gc3RhY2tTaXplIC0gMjtcblxuICAgICAgaWYgKG4gPiAwICYmIHJ1bkxlbmd0aFtuIC0gMV0gPCBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgIG4tLTtcbiAgICAgIH1cblxuICAgICAgbWVyZ2VBdChuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUF0KGkpIHtcbiAgICB2YXIgc3RhcnQxID0gcnVuU3RhcnRbaV07XG4gICAgdmFyIGxlbmd0aDEgPSBydW5MZW5ndGhbaV07XG4gICAgdmFyIHN0YXJ0MiA9IHJ1blN0YXJ0W2kgKyAxXTtcbiAgICB2YXIgbGVuZ3RoMiA9IHJ1bkxlbmd0aFtpICsgMV07XG4gICAgcnVuTGVuZ3RoW2ldID0gbGVuZ3RoMSArIGxlbmd0aDI7XG5cbiAgICBpZiAoaSA9PT0gc3RhY2tTaXplIC0gMykge1xuICAgICAgcnVuU3RhcnRbaSArIDFdID0gcnVuU3RhcnRbaSArIDJdO1xuICAgICAgcnVuTGVuZ3RoW2kgKyAxXSA9IHJ1bkxlbmd0aFtpICsgMl07XG4gICAgfVxuXG4gICAgc3RhY2tTaXplLS07XG4gICAgdmFyIGsgPSBnYWxsb3BSaWdodChhcnJheVtzdGFydDJdLCBhcnJheSwgc3RhcnQxLCBsZW5ndGgxLCAwLCBjb21wYXJlKTtcbiAgICBzdGFydDEgKz0gaztcbiAgICBsZW5ndGgxIC09IGs7XG5cbiAgICBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxlbmd0aDIgPSBnYWxsb3BMZWZ0KGFycmF5W3N0YXJ0MSArIGxlbmd0aDEgLSAxXSwgYXJyYXksIHN0YXJ0MiwgbGVuZ3RoMiwgbGVuZ3RoMiAtIDEsIGNvbXBhcmUpO1xuXG4gICAgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoMSA8PSBsZW5ndGgyKSB7XG4gICAgICBtZXJnZUxvdyhzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlSGlnaChzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VMb3coc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpIHtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICB0bXBbaV0gPSBhcnJheVtzdGFydDEgKyBpXTtcbiAgICB9XG5cbiAgICB2YXIgY3Vyc29yMSA9IDA7XG4gICAgdmFyIGN1cnNvcjIgPSBzdGFydDI7XG4gICAgdmFyIGRlc3QgPSBzdGFydDE7XG4gICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG5cbiAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoMSA9PT0gMSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICB9XG5cbiAgICAgIGFycmF5W2Rlc3QgKyBsZW5ndGgyXSA9IHRtcFtjdXJzb3IxXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX21pbkdhbGxvcCA9IG1pbkdhbGxvcDtcbiAgICB2YXIgY291bnQxLCBjb3VudDIsIGV4aXQ7XG5cbiAgICB3aGlsZSAoMSkge1xuICAgICAgY291bnQxID0gMDtcbiAgICAgIGNvdW50MiA9IDA7XG4gICAgICBleGl0ID0gZmFsc2U7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyYXlbY3Vyc29yMl0sIHRtcFtjdXJzb3IxXSkgPCAwKSB7XG4gICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG4gICAgICAgICAgY291bnQyKys7XG4gICAgICAgICAgY291bnQxID0gMDtcblxuICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSB0bXBbY3Vyc29yMSsrXTtcbiAgICAgICAgICBjb3VudDErKztcbiAgICAgICAgICBjb3VudDIgPSAwO1xuXG4gICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKChjb3VudDEgfCBjb3VudDIpIDwgX21pbkdhbGxvcCk7XG5cbiAgICAgIGlmIChleGl0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkbyB7XG4gICAgICAgIGNvdW50MSA9IGdhbGxvcFJpZ2h0KGFycmF5W2N1cnNvcjJdLCB0bXAsIGN1cnNvcjEsIGxlbmd0aDEsIDAsIGNvbXBhcmUpO1xuXG4gICAgICAgIGlmIChjb3VudDEgIT09IDApIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQxOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVzdCArPSBjb3VudDE7XG4gICAgICAgICAgY3Vyc29yMSArPSBjb3VudDE7XG4gICAgICAgICAgbGVuZ3RoMSAtPSBjb3VudDE7XG5cbiAgICAgICAgICBpZiAobGVuZ3RoMSA8PSAxKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuXG4gICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvdW50MiA9IGdhbGxvcExlZnQodG1wW2N1cnNvcjFdLCBhcnJheSwgY3Vyc29yMiwgbGVuZ3RoMiwgMCwgY29tcGFyZSk7XG5cbiAgICAgICAgaWYgKGNvdW50MiAhPT0gMCkge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDI7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlc3QgKz0gY291bnQyO1xuICAgICAgICAgIGN1cnNvcjIgKz0gY291bnQyO1xuICAgICAgICAgIGxlbmd0aDIgLT0gY291bnQyO1xuXG4gICAgICAgICAgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlbZGVzdCsrXSA9IHRtcFtjdXJzb3IxKytdO1xuXG4gICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIF9taW5HYWxsb3AtLTtcbiAgICAgIH0gd2hpbGUgKGNvdW50MSA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcgfHwgY291bnQyID49IERFRkFVTFRfTUlOX0dBTExPUElORyk7XG5cbiAgICAgIGlmIChleGl0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoX21pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgX21pbkdhbGxvcCA9IDA7XG4gICAgICB9XG5cbiAgICAgIF9taW5HYWxsb3AgKz0gMjtcbiAgICB9XG5cbiAgICBtaW5HYWxsb3AgPSBfbWluR2FsbG9wO1xuICAgIG1pbkdhbGxvcCA8IDEgJiYgKG1pbkdhbGxvcCA9IDEpO1xuXG4gICAgaWYgKGxlbmd0aDEgPT09IDEpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgfVxuXG4gICAgICBhcnJheVtkZXN0ICsgbGVuZ3RoMl0gPSB0bXBbY3Vyc29yMV07XG4gICAgfSBlbHNlIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTsgLy8gdGhyb3cgbmV3IEVycm9yKCdtZXJnZUxvdyBwcmVjb25kaXRpb25zIHdlcmUgbm90IHJlc3BlY3RlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VIaWdoKHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKSB7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgdG1wW2ldID0gYXJyYXlbc3RhcnQyICsgaV07XG4gICAgfVxuXG4gICAgdmFyIGN1cnNvcjEgPSBzdGFydDEgKyBsZW5ndGgxIC0gMTtcbiAgICB2YXIgY3Vyc29yMiA9IGxlbmd0aDIgLSAxO1xuICAgIHZhciBkZXN0ID0gc3RhcnQyICsgbGVuZ3RoMiAtIDE7XG4gICAgdmFyIGN1c3RvbUN1cnNvciA9IDA7XG4gICAgdmFyIGN1c3RvbURlc3QgPSAwO1xuICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuXG4gICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV0gPSB0bXBbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoMiA9PT0gMSkge1xuICAgICAgZGVzdCAtPSBsZW5ndGgxO1xuICAgICAgY3Vyc29yMSAtPSBsZW5ndGgxO1xuICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgIGZvciAoaSA9IGxlbmd0aDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgIH1cblxuICAgICAgYXJyYXlbZGVzdF0gPSB0bXBbY3Vyc29yMl07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9taW5HYWxsb3AgPSBtaW5HYWxsb3A7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIGNvdW50MSA9IDA7XG4gICAgICB2YXIgY291bnQyID0gMDtcbiAgICAgIHZhciBleGl0ID0gZmFsc2U7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGNvbXBhcmUodG1wW2N1cnNvcjJdLCBhcnJheVtjdXJzb3IxXSkgPCAwKSB7XG4gICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG4gICAgICAgICAgY291bnQxKys7XG4gICAgICAgICAgY291bnQyID0gMDtcblxuICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSB0bXBbY3Vyc29yMi0tXTtcbiAgICAgICAgICBjb3VudDIrKztcbiAgICAgICAgICBjb3VudDEgPSAwO1xuXG4gICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKChjb3VudDEgfCBjb3VudDIpIDwgX21pbkdhbGxvcCk7XG5cbiAgICAgIGlmIChleGl0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkbyB7XG4gICAgICAgIGNvdW50MSA9IGxlbmd0aDEgLSBnYWxsb3BSaWdodCh0bXBbY3Vyc29yMl0sIGFycmF5LCBzdGFydDEsIGxlbmd0aDEsIGxlbmd0aDEgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICBpZiAoY291bnQxICE9PSAwKSB7XG4gICAgICAgICAgZGVzdCAtPSBjb3VudDE7XG4gICAgICAgICAgY3Vyc29yMSAtPSBjb3VudDE7XG4gICAgICAgICAgbGVuZ3RoMSAtPSBjb3VudDE7XG4gICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjEgKyAxO1xuXG4gICAgICAgICAgZm9yIChpID0gY291bnQxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5W2Rlc3QtLV0gPSB0bXBbY3Vyc29yMi0tXTtcblxuICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjb3VudDIgPSBsZW5ndGgyIC0gZ2FsbG9wTGVmdChhcnJheVtjdXJzb3IxXSwgdG1wLCAwLCBsZW5ndGgyLCBsZW5ndGgyIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgaWYgKGNvdW50MiAhPT0gMCkge1xuICAgICAgICAgIGRlc3QgLT0gY291bnQyO1xuICAgICAgICAgIGN1cnNvcjIgLT0gY291bnQyO1xuICAgICAgICAgIGxlbmd0aDIgLT0gY291bnQyO1xuICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IyICsgMTtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDI7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gdG1wW2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsZW5ndGgyIDw9IDEpIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG5cbiAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgX21pbkdhbGxvcC0tO1xuICAgICAgfSB3aGlsZSAoY291bnQxID49IERFRkFVTFRfTUlOX0dBTExPUElORyB8fCBjb3VudDIgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HKTtcblxuICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChfbWluR2FsbG9wIDwgMCkge1xuICAgICAgICBfbWluR2FsbG9wID0gMDtcbiAgICAgIH1cblxuICAgICAgX21pbkdhbGxvcCArPSAyO1xuICAgIH1cblxuICAgIG1pbkdhbGxvcCA9IF9taW5HYWxsb3A7XG5cbiAgICBpZiAobWluR2FsbG9wIDwgMSkge1xuICAgICAgbWluR2FsbG9wID0gMTtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoMiA9PT0gMSkge1xuICAgICAgZGVzdCAtPSBsZW5ndGgxO1xuICAgICAgY3Vyc29yMSAtPSBsZW5ndGgxO1xuICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgIGZvciAoaSA9IGxlbmd0aDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgIH1cblxuICAgICAgYXJyYXlbZGVzdF0gPSB0bXBbY3Vyc29yMl07XG4gICAgfSBlbHNlIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTsgLy8gdGhyb3cgbmV3IEVycm9yKCdtZXJnZUhpZ2ggcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV0gPSB0bXBbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5tZXJnZVJ1bnMgPSBtZXJnZVJ1bnM7XG4gIHRoaXMuZm9yY2VNZXJnZVJ1bnMgPSBmb3JjZU1lcmdlUnVucztcbiAgdGhpcy5wdXNoUnVuID0gcHVzaFJ1bjtcbn1cblxuZnVuY3Rpb24gc29ydChhcnJheSwgY29tcGFyZSwgbG8sIGhpKSB7XG4gIGlmICghbG8pIHtcbiAgICBsbyA9IDA7XG4gIH1cblxuICBpZiAoIWhpKSB7XG4gICAgaGkgPSBhcnJheS5sZW5ndGg7XG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gaGkgLSBsbztcblxuICBpZiAocmVtYWluaW5nIDwgMikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBydW5MZW5ndGggPSAwO1xuXG4gIGlmIChyZW1haW5pbmcgPCBERUZBVUxUX01JTl9NRVJHRSkge1xuICAgIHJ1bkxlbmd0aCA9IG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSk7XG4gICAgYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGhpLCBsbyArIHJ1bkxlbmd0aCwgY29tcGFyZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRzID0gbmV3IFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpO1xuICB2YXIgbWluUnVuID0gbWluUnVuTGVuZ3RoKHJlbWFpbmluZyk7XG5cbiAgZG8ge1xuICAgIHJ1bkxlbmd0aCA9IG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSk7XG5cbiAgICBpZiAocnVuTGVuZ3RoIDwgbWluUnVuKSB7XG4gICAgICB2YXIgZm9yY2UgPSByZW1haW5pbmc7XG5cbiAgICAgIGlmIChmb3JjZSA+IG1pblJ1bikge1xuICAgICAgICBmb3JjZSA9IG1pblJ1bjtcbiAgICAgIH1cblxuICAgICAgYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGxvICsgZm9yY2UsIGxvICsgcnVuTGVuZ3RoLCBjb21wYXJlKTtcbiAgICAgIHJ1bkxlbmd0aCA9IGZvcmNlO1xuICAgIH1cblxuICAgIHRzLnB1c2hSdW4obG8sIHJ1bkxlbmd0aCk7XG4gICAgdHMubWVyZ2VSdW5zKCk7XG4gICAgcmVtYWluaW5nIC09IHJ1bkxlbmd0aDtcbiAgICBsbyArPSBydW5MZW5ndGg7XG4gIH0gd2hpbGUgKHJlbWFpbmluZyAhPT0gMCk7XG5cbiAgdHMuZm9yY2VNZXJnZVJ1bnMoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzb3J0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL3RpbXNvcnQuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuXG52YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IF9jb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbnZhciBsb2cgPSByZXF1aXJlKFwiLi9jb3JlL2xvZ1wiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgdGltc29ydCA9IHJlcXVpcmUoXCIuL2NvcmUvdGltc29ydFwiKTtcblxudmFyIExheWVyID0gcmVxdWlyZShcIi4vTGF5ZXJcIik7XG5cbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1aXJlKFwiLi9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIpO1xuXG52YXIgSW1hZ2UgPSByZXF1aXJlKFwiLi9ncmFwaGljL0ltYWdlXCIpO1xuXG4vKipcbiAqIERlZmF1bHQgY2FudmFzIHBhaW50ZXJcbiAqIEBtb2R1bGUgenJlbmRlci9QYWludGVyXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqICAgICAgICAgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG4vLyBQRU5ESUdOXG4vLyBMYXllciBleGNlZWRzIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgbWF5IGhhdmUgc29tZSBwcm9ibGVtIHdoZW4gZmx1c2ggZGlyZWN0bHkgc2Vjb25kIHRpbWUuXG4vL1xuLy8gTWF4aW11bSBwcm9ncmVzc2l2ZSBsYXllci4gV2hlbiBleGNlZWRpbmcgdGhpcyBudW1iZXIuIEFsbCBlbGVtZW50cyB3aWxsIGJlIGRyYXdlZCBpbiB0aGUgbGFzdCBsYXllci5cbnZhciBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSID0gNTtcblxuZnVuY3Rpb24gcGFyc2VJbnQxMCh2YWwpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApO1xufVxuXG5mdW5jdGlvbiBpc0xheWVyVmFsaWQobGF5ZXIpIHtcbiAgaWYgKCFsYXllcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChsYXllci5fX2J1aWx0aW5fXykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBsYXllci5yZXNpemUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGxheWVyLnJlZnJlc2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcHJlUHJvY2Vzc0xheWVyKGxheWVyKSB7XG4gIGxheWVyLl9fdW51c2VkQ291bnQrKztcbn1cblxuZnVuY3Rpb24gcG9zdFByb2Nlc3NMYXllcihsYXllcikge1xuICBpZiAobGF5ZXIuX191bnVzZWRDb3VudCA9PSAxKSB7XG4gICAgbGF5ZXIuY2xlYXIoKTtcbiAgfVxufVxuXG52YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG52YXIgdmlld1JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuXG5mdW5jdGlvbiBpc0Rpc3BsYXlhYmxlQ3VsbGVkKGVsLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHRtcFJlY3QuY29weShlbC5nZXRCb3VuZGluZ1JlY3QoKSk7XG5cbiAgaWYgKGVsLnRyYW5zZm9ybSkge1xuICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0oZWwudHJhbnNmb3JtKTtcbiAgfVxuXG4gIHZpZXdSZWN0LndpZHRoID0gd2lkdGg7XG4gIHZpZXdSZWN0LmhlaWdodCA9IGhlaWdodDtcbiAgcmV0dXJuICF0bXBSZWN0LmludGVyc2VjdCh2aWV3UmVjdCk7XG59XG5cbmZ1bmN0aW9uIGlzQ2xpcFBhdGhDaGFuZ2VkKGNsaXBQYXRocywgcHJldkNsaXBQYXRocykge1xuICBpZiAoY2xpcFBhdGhzID09IHByZXZDbGlwUGF0aHMpIHtcbiAgICAvLyBDYW4gYm90aCBiZSBudWxsIG9yIHVuZGVmaW5lZFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghY2xpcFBhdGhzIHx8ICFwcmV2Q2xpcFBhdGhzIHx8IGNsaXBQYXRocy5sZW5ndGggIT09IHByZXZDbGlwUGF0aHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjbGlwUGF0aHNbaV0gIT09IHByZXZDbGlwUGF0aHNbaV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkb0NsaXAoY2xpcFBhdGhzLCBjdHgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2xpcFBhdGggPSBjbGlwUGF0aHNbaV07XG4gICAgY2xpcFBhdGguc2V0VHJhbnNmb3JtKGN0eCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGNsaXBQYXRoLmJ1aWxkUGF0aChjdHgsIGNsaXBQYXRoLnNoYXBlKTtcbiAgICBjdHguY2xpcCgpOyAvLyBUcmFuc2Zvcm0gYmFja1xuXG4gICAgY2xpcFBhdGgucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3Qod2lkdGgsIGhlaWdodCkge1xuICB2YXIgZG9tUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOyAvLyBkb21Sb290Lm9uc2VsZWN0c3RhcnQgPSByZXR1cm5GYWxzZTsgLy8g6YG/5YWN6aG16Z2i6YCJ5Lit55qE5bC05bCsXG5cbiAgZG9tUm9vdC5zdHlsZS5jc3NUZXh0ID0gWydwb3NpdGlvbjpyZWxhdGl2ZScsICdvdmVyZmxvdzpoaWRkZW4nLCAnd2lkdGg6JyArIHdpZHRoICsgJ3B4JywgJ2hlaWdodDonICsgaGVpZ2h0ICsgJ3B4JywgJ3BhZGRpbmc6MCcsICdtYXJnaW46MCcsICdib3JkZXItd2lkdGg6MCddLmpvaW4oJzsnKSArICc7JztcbiAgcmV0dXJuIGRvbVJvb3Q7XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9QYWludGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJvb3Qg57uY5Zu+5a655ZmoXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cblxuXG52YXIgUGFpbnRlciA9IGZ1bmN0aW9uIChyb290LCBzdG9yYWdlLCBvcHRzKSB7XG4gIHRoaXMudHlwZSA9ICdjYW52YXMnOyAvLyBJbiBub2RlIGVudmlyb25tZW50IHVzaW5nIG5vZGUtY2FudmFzXG5cbiAgdmFyIHNpbmdsZUNhbnZhcyA9ICFyb290Lm5vZGVOYW1lIC8vIEluIG5vZGUgP1xuICB8fCByb290Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdDQU5WQVMnO1xuICB0aGlzLl9vcHRzID0gb3B0cyA9IHV0aWwuZXh0ZW5kKHt9LCBvcHRzIHx8IHt9KTtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuZHByID0gb3B0cy5kZXZpY2VQaXhlbFJhdGlvIHx8IGRldmljZVBpeGVsUmF0aW87XG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fc2luZ2xlQ2FudmFzID0gc2luZ2xlQ2FudmFzO1xuICAvKipcbiAgICog57uY5Zu+5a655ZmoXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICovXG5cbiAgdGhpcy5yb290ID0gcm9vdDtcbiAgdmFyIHJvb3RTdHlsZSA9IHJvb3Quc3R5bGU7XG5cbiAgaWYgKHJvb3RTdHlsZSkge1xuICAgIHJvb3RTdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAndHJhbnNwYXJlbnQnO1xuICAgIHJvb3RTdHlsZVsnLXdlYmtpdC11c2VyLXNlbGVjdCddID0gcm9vdFN0eWxlWyd1c2VyLXNlbGVjdCddID0gcm9vdFN0eWxlWyctd2Via2l0LXRvdWNoLWNhbGxvdXQnXSA9ICdub25lJztcbiAgICByb290LmlubmVySFRNTCA9ICcnO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX1cbiAgICovXG5cblxuICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAvKipcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3QgPSBbXTtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnpyZW5kZXIvTGF5ZXI+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzID0ge307XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIE9iamVjdD59XG4gICAqIEB0eXBlIHtwcml2YXRlfVxuICAgKi9cblxuICB0aGlzLl9sYXllckNvbmZpZyA9IHt9O1xuXG4gIGlmICghc2luZ2xlQ2FudmFzKSB7XG4gICAgdGhpcy5fd2lkdGggPSB0aGlzLl9nZXRTaXplKDApO1xuICAgIHRoaXMuX2hlaWdodCA9IHRoaXMuX2dldFNpemUoMSk7XG4gICAgdmFyIGRvbVJvb3QgPSB0aGlzLl9kb21Sb290ID0gY3JlYXRlUm9vdCh0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICByb290LmFwcGVuZENoaWxkKGRvbVJvb3QpO1xuICB9IGVsc2Uge1xuICAgIGlmIChvcHRzLndpZHRoICE9IG51bGwpIHtcbiAgICAgIHJvb3Qud2lkdGggPSBvcHRzLndpZHRoO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICByb290LmhlaWdodCA9IG9wdHMuaGVpZ2h0O1xuICAgIH0gLy8gVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0IGRpcmVjdGx5XG5cblxuICAgIHZhciB3aWR0aCA9IHJvb3Qud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHJvb3QuaGVpZ2h0O1xuICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0OyAvLyBDcmVhdGUgbGF5ZXIgaWYgb25seSBvbmUgZ2l2ZW4gY2FudmFzXG4gICAgLy8gRGV2aWNlIHBpeGVsIHJhdGlvIGlzIGZpeGVkIHRvIDEgYmVjYXVzZSBnaXZlbiBjYW52YXMgaGFzIGl0cyBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodFxuXG4gICAgdmFyIG1haW5MYXllciA9IG5ldyBMYXllcihyb290LCB0aGlzLCAxKTtcbiAgICBtYWluTGF5ZXIuaW5pdENvbnRleHQoKTsgLy8gRklYTUUgVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgLy8gbWFpbkxheWVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGxheWVyc1swXSA9IG1haW5MYXllcjtcbiAgICB6bGV2ZWxMaXN0LnB1c2goMCk7XG4gICAgdGhpcy5fZG9tUm9vdCA9IHJvb3Q7XG4gIH0gLy8gTGF5ZXJzIGZvciBwcm9ncmVzc2l2ZSByZW5kZXJpbmdcblxuXG4gIHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzID0gW107XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvTGF5ZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2hvdmVybGF5ZXI7XG4gIHRoaXMuX2hvdmVyRWxlbWVudHMgPSBbXTtcbn07XG5cblBhaW50ZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUGFpbnRlcixcbiAgZ2V0VHlwZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnY2FudmFzJztcbiAgfSxcblxuICAvKipcbiAgICogSWYgcGFpbnRlciB1c2UgYSBzaW5nbGUgY2FudmFzXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc1NpbmdsZUNhbnZhczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zaW5nbGVDYW52YXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxEaXZFbGVtZW50fVxuICAgKi9cbiAgZ2V0Vmlld3BvcnRSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RvbVJvb3Q7XG4gIH0sXG4gIGdldFZpZXdwb3J0Um9vdE9mZnNldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciB2aWV3cG9ydFJvb3QgPSB0aGlzLmdldFZpZXdwb3J0Um9vdCgpO1xuXG4gICAgaWYgKHZpZXdwb3J0Um9vdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0TGVmdDogdmlld3BvcnRSb290Lm9mZnNldExlZnQgfHwgMCxcbiAgICAgICAgb2Zmc2V0VG9wOiB2aWV3cG9ydFJvb3Qub2Zmc2V0VG9wIHx8IDBcbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDliLfmlrBcbiAgICogQHBhcmFtIHtib29sZWFufSBbcGFpbnRBbGw9ZmFsc2VdIOW8uuWItue7mOWItuaJgOaciWRpc3BsYXlhYmxlXG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiAocGFpbnRBbGwpIHtcbiAgICB2YXIgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlKTtcbiAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG5cbiAgICB0aGlzLl9wYWludExpc3QobGlzdCwgcGFpbnRBbGwpOyAvLyBQYWludCBjdXN0dW0gbGF5ZXJzXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuXG4gICAgICBpZiAoIWxheWVyLl9fYnVpbHRpbl9fICYmIGxheWVyLnJlZnJlc2gpIHtcbiAgICAgICAgbGF5ZXIucmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG5cbiAgICBpZiAodGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9zdGFydFByb2dlc3NpdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkSG92ZXI6IGZ1bmN0aW9uIChlbCwgaG92ZXJTdHlsZSkge1xuICAgIGlmIChlbC5fX2hvdmVyTWlyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsTWlycm9yID0gbmV3IGVsLmNvbnN0cnVjdG9yKHtcbiAgICAgIHN0eWxlOiBlbC5zdHlsZSxcbiAgICAgIHNoYXBlOiBlbC5zaGFwZVxuICAgIH0pO1xuICAgIGVsTWlycm9yLl9fZnJvbSA9IGVsO1xuICAgIGVsLl9faG92ZXJNaXIgPSBlbE1pcnJvcjtcbiAgICBlbE1pcnJvci5zZXRTdHlsZShob3ZlclN0eWxlKTtcblxuICAgIHRoaXMuX2hvdmVyRWxlbWVudHMucHVzaChlbE1pcnJvcik7XG4gIH0sXG4gIHJlbW92ZUhvdmVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICB2YXIgZWxNaXJyb3IgPSBlbC5fX2hvdmVyTWlyO1xuICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcbiAgICB2YXIgaWR4ID0gdXRpbC5pbmRleE9mKGhvdmVyRWxlbWVudHMsIGVsTWlycm9yKTtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgaG92ZXJFbGVtZW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG5cbiAgICBlbC5fX2hvdmVyTWlyID0gbnVsbDtcbiAgfSxcbiAgY2xlYXJIb3ZlcjogZnVuY3Rpb24gKGVsKSB7XG4gICAgdmFyIGhvdmVyRWxlbWVudHMgPSB0aGlzLl9ob3ZlckVsZW1lbnRzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3ZlckVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZnJvbSA9IGhvdmVyRWxlbWVudHNbaV0uX19mcm9tO1xuXG4gICAgICBpZiAoZnJvbSkge1xuICAgICAgICBmcm9tLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhvdmVyRWxlbWVudHMubGVuZ3RoID0gMDtcbiAgfSxcbiAgcmVmcmVzaEhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhvdmVyRWxlbWVudHMgPSB0aGlzLl9ob3ZlckVsZW1lbnRzO1xuICAgIHZhciBsZW4gPSBob3ZlckVsZW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaG92ZXJMYXllciA9IHRoaXMuX2hvdmVybGF5ZXI7XG4gICAgaG92ZXJMYXllciAmJiBob3ZlckxheWVyLmNsZWFyKCk7XG5cbiAgICBpZiAoIWxlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRpbXNvcnQoaG92ZXJFbGVtZW50cywgdGhpcy5zdG9yYWdlLmRpc3BsYXlhYmxlU29ydEZ1bmMpOyAvLyBVc2UgYSBleHRyZWFtIGxhcmdlIHpsZXZlbFxuICAgIC8vIEZJWE1FP1xuXG4gICAgaWYgKCFob3ZlckxheWVyKSB7XG4gICAgICBob3ZlckxheWVyID0gdGhpcy5faG92ZXJsYXllciA9IHRoaXMuZ2V0TGF5ZXIoMWU1KTtcbiAgICB9XG5cbiAgICB2YXIgc2NvcGUgPSB7fTtcbiAgICBob3ZlckxheWVyLmN0eC5zYXZlKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgIHZhciBlbCA9IGhvdmVyRWxlbWVudHNbaV07XG4gICAgICB2YXIgb3JpZ2luYWxFbCA9IGVsLl9fZnJvbTsgLy8gT3JpZ2luYWwgZWwgaXMgcmVtb3ZlZFxuICAgICAgLy8gUEVORElOR1xuXG4gICAgICBpZiAoIShvcmlnaW5hbEVsICYmIG9yaWdpbmFsRWwuX196cikpIHtcbiAgICAgICAgaG92ZXJFbGVtZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIG9yaWdpbmFsRWwuX19ob3Zlck1pciA9IG51bGw7XG4gICAgICAgIGxlbi0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaSsrOyAvLyBVc2UgdHJhbnNmb3JtXG4gICAgICAvLyBGSVhNRSBzdHlsZSBhbmQgc2hhcGUgP1xuXG4gICAgICBpZiAoIW9yaWdpbmFsRWwuaW52aXNpYmxlKSB7XG4gICAgICAgIGVsLnRyYW5zZm9ybSA9IG9yaWdpbmFsRWwudHJhbnNmb3JtO1xuICAgICAgICBlbC5pbnZUcmFuc2Zvcm0gPSBvcmlnaW5hbEVsLmludlRyYW5zZm9ybTtcbiAgICAgICAgZWwuX19jbGlwUGF0aHMgPSBvcmlnaW5hbEVsLl9fY2xpcFBhdGhzOyAvLyBlbC5cblxuICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGhvdmVyTGF5ZXIsIHRydWUsIHNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBob3ZlckxheWVyLmN0eC5yZXN0b3JlKCk7XG4gIH0sXG4gIF9zdGFydFByb2dlc3NpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoIXNlbGYuX2Z1cnRoZXJQcm9ncmVzc2l2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVXNlIGEgdG9rZW4gdG8gc3RvcCBwcm9ncmVzcyBzdGVwcyB0cmlnZ2VyZWQgYnlcbiAgICAvLyBwcmV2aW91cyB6ci5yZWZyZXNoIGNhbGxpbmcuXG5cblxuICAgIHZhciB0b2tlbiA9IHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSArbmV3IERhdGUoKTtcbiAgICBzZWxmLl9wcm9ncmVzcysrO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcblxuICAgIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgICAvLyBJbiBjYXNlIHJlZnJlc2hlZCBvciBkaXNwb3NlZFxuICAgICAgaWYgKHRva2VuID09PSBzZWxmLl9wcm9ncmVzc2l2ZVRva2VuICYmIHNlbGYuc3RvcmFnZSkge1xuICAgICAgICBzZWxmLl9kb1BhaW50TGlzdChzZWxmLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKSk7XG5cbiAgICAgICAgaWYgKHNlbGYuX2Z1cnRoZXJQcm9ncmVzc2l2ZSkge1xuICAgICAgICAgIHNlbGYuX3Byb2dyZXNzKys7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2NsZWFyUHJvZ3Jlc3NpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZVRva2VuID0gLTE7XG4gICAgdGhpcy5fcHJvZ3Jlc3MgPSAwO1xuICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICBsYXllci5fX2RpcnR5ICYmIGxheWVyLmNsZWFyKCk7XG4gICAgfSk7XG4gIH0sXG4gIF9wYWludExpc3Q6IGZ1bmN0aW9uIChsaXN0LCBwYWludEFsbCkge1xuICAgIGlmIChwYWludEFsbCA9PSBudWxsKSB7XG4gICAgICBwYWludEFsbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUxheWVyU3RhdHVzKGxpc3QpO1xuXG4gICAgdGhpcy5fY2xlYXJQcm9ncmVzc2l2ZSgpO1xuXG4gICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKHByZVByb2Nlc3NMYXllcik7XG5cbiAgICB0aGlzLl9kb1BhaW50TGlzdChsaXN0LCBwYWludEFsbCk7XG5cbiAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIocG9zdFByb2Nlc3NMYXllcik7XG4gIH0sXG4gIF9kb1BhaW50TGlzdDogZnVuY3Rpb24gKGxpc3QsIHBhaW50QWxsKSB7XG4gICAgdmFyIGN1cnJlbnRMYXllcjtcbiAgICB2YXIgY3VycmVudFpMZXZlbDtcbiAgICB2YXIgY3R4OyAvLyB2YXIgaW52VHJhbnNmb3JtID0gW107XG5cbiAgICB2YXIgc2NvcGU7XG4gICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJJZHggPSAwO1xuICAgIHZhciBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcjtcbiAgICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgIHZhciBsYXllclByb2dyZXNzO1xuICAgIHZhciBmcmFtZSA9IHRoaXMuX3Byb2dyZXNzO1xuXG4gICAgZnVuY3Rpb24gZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGxheWVyKSB7XG4gICAgICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICBjdHguc2hhZG93Qmx1ciA9IDA7IC8vIEF2b2lkIGxheWVyIGRvbid0IGNsZWFyIGluIG5leHQgcHJvZ3Jlc3NpdmUgZnJhbWVcblxuICAgICAgY3VycmVudExheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UobGF5ZXIuZG9tLCAwLCAwLCB3aWR0aCAqIGRwciwgaGVpZ2h0ICogZHByKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgIHZhciBlbFpMZXZlbCA9IHRoaXMuX3NpbmdsZUNhbnZhcyA/IDAgOiBlbC56bGV2ZWw7XG4gICAgICB2YXIgZWxGcmFtZSA9IGVsLl9fZnJhbWU7IC8vIEZsdXNoIGF0IGN1cnJlbnQgY29udGV4dFxuICAgICAgLy8gUEVORElOR1xuXG4gICAgICBpZiAoZWxGcmFtZSA8IDAgJiYgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKTtcbiAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgfSAvLyBDaGFuZ2UgZHJhdyBsYXllclxuXG5cbiAgICAgIGlmIChjdXJyZW50WkxldmVsICE9PSBlbFpMZXZlbCkge1xuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfSAvLyBSZXNldCBzY29wZVxuXG5cbiAgICAgICAgc2NvcGUgPSB7fTsgLy8gT25seSAwIHpsZXZlbCBpZiBvbmx5IGhhcyBvbmUgY2FudmFzXG5cbiAgICAgICAgY3VycmVudFpMZXZlbCA9IGVsWkxldmVsO1xuICAgICAgICBjdXJyZW50TGF5ZXIgPSB0aGlzLmdldExheWVyKGN1cnJlbnRaTGV2ZWwpO1xuXG4gICAgICAgIGlmICghY3VycmVudExheWVyLl9fYnVpbHRpbl9fKSB7XG4gICAgICAgICAgbG9nKCdaTGV2ZWwgJyArIGN1cnJlbnRaTGV2ZWwgKyAnIGhhcyBiZWVuIHVzZWQgYnkgdW5rb3duIGxheWVyICcgKyBjdXJyZW50TGF5ZXIuaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4ID0gY3VycmVudExheWVyLmN0eDtcbiAgICAgICAgY3R4LnNhdmUoKTsgLy8gUmVzZXQgdGhlIGNvdW50XG5cbiAgICAgICAgY3VycmVudExheWVyLl9fdW51c2VkQ291bnQgPSAwO1xuXG4gICAgICAgIGlmIChjdXJyZW50TGF5ZXIuX19kaXJ0eSB8fCBwYWludEFsbCkge1xuICAgICAgICAgIGN1cnJlbnRMYXllci5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghKGN1cnJlbnRMYXllci5fX2RpcnR5IHx8IHBhaW50QWxsKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsRnJhbWUgPj0gMCkge1xuICAgICAgICAvLyBQcm9ncmVzc2l2ZSBsYXllciBjaGFuZ2VkXG4gICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzW01hdGgubWluKHByb2dyZXNzaXZlTGF5ZXJJZHgrKywgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiAtIDEpXTtcbiAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5jdHguc2F2ZSgpO1xuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLnJlbmRlclNjb3BlID0ge307XG5cbiAgICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgJiYgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19wcm9ncmVzcyA+IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIC8vIGZsdXNoUHJvZ3Jlc3NpdmVMYXllcihjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcik7XG4gICAgICAgICAgICAvLyBRdWljayBqdW1wIGFsbCBwcm9ncmVzc2l2ZSBlbGVtZW50c1xuICAgICAgICAgICAgLy8gQWxsIHByb2dyZXNzaXZlIGVsZW1lbnQgYXJlIG5vdCBkaXJ0eSwganVtcCBvdmVyIGFuZCBmbHVzaCBkaXJlY3RseVxuICAgICAgICAgICAgaSA9IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgLSAxOyAvLyBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IG51bGw7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxheWVyUHJvZ3Jlc3MgPSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzO1xuXG4gICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5KSB7XG4gICAgICAgICAgICAvLyBLZWVwIHJlbmRlcmluZ1xuICAgICAgICAgICAgZnJhbWUgPSBsYXllclByb2dyZXNzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3MgPSBmcmFtZSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxGcmFtZSA9PT0gZnJhbWUpIHtcbiAgICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLCB0cnVlLCBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5yZW5kZXJTY29wZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgY3VycmVudExheWVyLCBwYWludEFsbCwgc2NvcGUpO1xuICAgICAgfVxuXG4gICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICBmbHVzaFByb2dyZXNzaXZlTGF5ZXIoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpO1xuICAgIH0gLy8gUmVzdG9yZSB0aGUgbGFzdExheWVyIGN0eFxuXG5cbiAgICBjdHggJiYgY3R4LnJlc3RvcmUoKTsgLy8gSWYgc3RpbGwgaGFzIGNsaXBwaW5nIHN0YXRlXG4gICAgLy8gaWYgKHNjb3BlLnByZXZFbENsaXBQYXRocykge1xuICAgIC8vICAgICBjdHgucmVzdG9yZSgpO1xuICAgIC8vIH1cblxuICAgIHRoaXMuX2Z1cnRoZXJQcm9ncmVzc2l2ZSA9IGZhbHNlO1xuICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICBpZiAobGF5ZXIuX19tYXhQcm9ncmVzcyA+PSBsYXllci5fX3Byb2dyZXNzKSB7XG4gICAgICAgIHRoaXMuX2Z1cnRoZXJQcm9ncmVzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH0sXG4gIF9kb1BhaW50RWw6IGZ1bmN0aW9uIChlbCwgY3VycmVudExheWVyLCBmb3JjZVBhaW50LCBzY29wZSkge1xuICAgIHZhciBjdHggPSBjdXJyZW50TGF5ZXIuY3R4O1xuICAgIHZhciBtID0gZWwudHJhbnNmb3JtO1xuXG4gICAgaWYgKChjdXJyZW50TGF5ZXIuX19kaXJ0eSB8fCBmb3JjZVBhaW50KSAmJiAvLyBJZ25vcmUgaW52aXNpYmxlIGVsZW1lbnRcbiAgICAhZWwuaW52aXNpYmxlIC8vIElnbm9yZSB0cmFuc3BhcmVudCBlbGVtZW50XG4gICAgJiYgZWwuc3R5bGUub3BhY2l0eSAhPT0gMCAvLyBJZ25vcmUgc2NhbGUgMCBlbGVtZW50LCBpbiBzb21lIGVudmlyb25tZW50IGxpa2Ugbm9kZS1jYW52YXNcbiAgICAvLyBEcmF3IGEgc2NhbGUgMCBlbGVtZW50IGNhbiBjYXVzZSBhbGwgZm9sbG93aW5nIGRyYXcgd3JvbmdcbiAgICAvLyBBbmQgc2V0VHJhbnNmb3JtIHdpdGggc2NhbGUgMCB3aWxsIGNhdXNlIHNldCBiYWNrIHRyYW5zZm9ybSBmYWlsZWQuXG4gICAgJiYgIShtICYmICFtWzBdICYmICFtWzNdKSAvLyBJZ25vcmUgY3VsbGVkIGVsZW1lbnRcbiAgICAmJiAhKGVsLmN1bGxpbmcgJiYgaXNEaXNwbGF5YWJsZUN1bGxlZChlbCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCkpKSB7XG4gICAgICB2YXIgY2xpcFBhdGhzID0gZWwuX19jbGlwUGF0aHM7IC8vIE9wdGltaXplIHdoZW4gY2xpcHBpbmcgb24gZ3JvdXAgd2l0aCBzZXZlcmFsIGVsZW1lbnRzXG5cbiAgICAgIGlmIChzY29wZS5wcmV2Q2xpcExheWVyICE9PSBjdXJyZW50TGF5ZXIgfHwgaXNDbGlwUGF0aENoYW5nZWQoY2xpcFBhdGhzLCBzY29wZS5wcmV2RWxDbGlwUGF0aHMpKSB7XG4gICAgICAgIC8vIElmIGhhcyBwcmV2aW91cyBjbGlwcGluZyBzdGF0ZSwgcmVzdG9yZSBmcm9tIGl0XG4gICAgICAgIGlmIChzY29wZS5wcmV2RWxDbGlwUGF0aHMpIHtcbiAgICAgICAgICBzY29wZS5wcmV2Q2xpcExheWVyLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgc2NvcGUucHJldkNsaXBMYXllciA9IHNjb3BlLnByZXZFbENsaXBQYXRocyA9IG51bGw7IC8vIFJlc2V0IHByZXZFbCBzaW5jZSBjb250ZXh0IGhhcyBiZWVuIHJlc3RvcmVkXG5cbiAgICAgICAgICBzY29wZS5wcmV2RWwgPSBudWxsO1xuICAgICAgICB9IC8vIE5ldyBjbGlwcGluZyBzdGF0ZVxuXG5cbiAgICAgICAgaWYgKGNsaXBQYXRocykge1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgZG9DbGlwKGNsaXBQYXRocywgY3R4KTtcbiAgICAgICAgICBzY29wZS5wcmV2Q2xpcExheWVyID0gY3VycmVudExheWVyO1xuICAgICAgICAgIHNjb3BlLnByZXZFbENsaXBQYXRocyA9IGNsaXBQYXRocztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbC5iZWZvcmVCcnVzaCAmJiBlbC5iZWZvcmVCcnVzaChjdHgpO1xuICAgICAgZWwuYnJ1c2goY3R4LCBzY29wZS5wcmV2RWwgfHwgbnVsbCk7XG4gICAgICBzY29wZS5wcmV2RWwgPSBlbDtcbiAgICAgIGVsLmFmdGVyQnJ1c2ggJiYgZWwuYWZ0ZXJCcnVzaChjdHgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog6I635Y+WIHpsZXZlbCDmiYDlnKjlsYLvvIzlpoLmnpzkuI3lrZjlnKjliJnkvJrliJvlu7rkuIDkuKrmlrDnmoTlsYJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHpsZXZlbFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9MYXllcn1cbiAgICovXG4gIGdldExheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgaWYgKHRoaXMuX3NpbmdsZUNhbnZhcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1swXTtcbiAgICB9XG5cbiAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcblxuICAgIGlmICghbGF5ZXIpIHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBsYXllclxuICAgICAgbGF5ZXIgPSBuZXcgTGF5ZXIoJ3pyXycgKyB6bGV2ZWwsIHRoaXMsIHRoaXMuZHByKTtcbiAgICAgIGxheWVyLl9fYnVpbHRpbl9fID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMuX2xheWVyQ29uZmlnW3psZXZlbF0pIHtcbiAgICAgICAgdXRpbC5tZXJnZShsYXllciwgdGhpcy5fbGF5ZXJDb25maWdbemxldmVsXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5zZXJ0TGF5ZXIoemxldmVsLCBsYXllcik7IC8vIENvbnRleHQgaXMgY3JlYXRlZCBhZnRlciBkb20gaW5zZXJ0ZWQgdG8gZG9jdW1lbnRcbiAgICAgIC8vIE9yIGV4Y2FudmFzIHdpbGwgZ2V0IDBweCBjbGllbnRXaWR0aCBhbmQgY2xpZW50SGVpZ2h0XG5cbiAgICAgIGxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxheWVyO1xuICB9LFxuICBpbnNlcnRMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgbGF5ZXIpIHtcbiAgICB2YXIgbGF5ZXJzTWFwID0gdGhpcy5fbGF5ZXJzO1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgbGVuID0gemxldmVsTGlzdC5sZW5ndGg7XG4gICAgdmFyIHByZXZMYXllciA9IG51bGw7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3Q7XG5cbiAgICBpZiAobGF5ZXJzTWFwW3psZXZlbF0pIHtcbiAgICAgIGxvZygnWkxldmVsICcgKyB6bGV2ZWwgKyAnIGhhcyBiZWVuIHVzZWQgYWxyZWFkeScpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ2hlY2sgaWYgaXMgYSB2YWxpZCBsYXllclxuXG5cbiAgICBpZiAoIWlzTGF5ZXJWYWxpZChsYXllcikpIHtcbiAgICAgIGxvZygnTGF5ZXIgb2YgemxldmVsICcgKyB6bGV2ZWwgKyAnIGlzIG5vdCB2YWxpZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsZW4gPiAwICYmIHpsZXZlbCA+IHpsZXZlbExpc3RbMF0pIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKHpsZXZlbExpc3RbaV0gPCB6bGV2ZWwgJiYgemxldmVsTGlzdFtpICsgMV0gPiB6bGV2ZWwpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcmV2TGF5ZXIgPSBsYXllcnNNYXBbemxldmVsTGlzdFtpXV07XG4gICAgfVxuXG4gICAgemxldmVsTGlzdC5zcGxpY2UoaSArIDEsIDAsIHpsZXZlbCk7XG4gICAgbGF5ZXJzTWFwW3psZXZlbF0gPSBsYXllcjsgLy8gVml0dWFsIGxheWVyIHdpbGwgbm90IGRpcmVjdGx5IHNob3cgb24gdGhlIHNjcmVlbi5cbiAgICAvLyAoSXQgY2FuIGJlIGEgV2ViR0wgbGF5ZXIgYW5kIGFzc2lnbmVkIHRvIGEgWkltYWdlIGVsZW1lbnQpXG4gICAgLy8gQnV0IGl0IHN0aWxsIHVuZGVyIG1hbmFnZW1lbnQgb2YgenJlbmRlci5cblxuICAgIGlmICghbGF5ZXIudmlydHVhbCkge1xuICAgICAgaWYgKHByZXZMYXllcikge1xuICAgICAgICB2YXIgcHJldkRvbSA9IHByZXZMYXllci5kb207XG5cbiAgICAgICAgaWYgKHByZXZEb20ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICBkb21Sb290Lmluc2VydEJlZm9yZShsYXllci5kb20sIHByZXZEb20ubmV4dFNpYmxpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbVJvb3QuYXBwZW5kQ2hpbGQobGF5ZXIuZG9tKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRvbVJvb3QuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGRvbVJvb3QuaW5zZXJ0QmVmb3JlKGxheWVyLmRvbSwgZG9tUm9vdC5maXJzdENoaWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb21Sb290LmFwcGVuZENoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8vIEl0ZXJhdGUgZWFjaCBsYXllclxuICBlYWNoTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgejtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW3pdLCB6KTtcbiAgICB9XG4gIH0sXG4gIC8vIEl0ZXJhdGUgZWFjaCBidWlsZGluIGxheWVyXG4gIGVhY2hCdWlsdGluTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgbGF5ZXI7XG4gICAgdmFyIHo7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICBsYXllciA9IHRoaXMuX2xheWVyc1t6XTtcblxuICAgICAgaWYgKGxheWVyLl9fYnVpbHRpbl9fKSB7XG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgbGF5ZXIsIHopO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gSXRlcmF0ZSBlYWNoIG90aGVyIGxheWVyIGV4Y2VwdCBidWlsZGluIGxheWVyXG4gIGVhY2hPdGhlckxheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgdmFyIGxheWVyO1xuICAgIHZhciB6O1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG5cbiAgICAgIGlmICghbGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCBsYXllciwgeik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bmiYDmnInlt7LliJvlu7rnmoTlsYJcbiAgICogQHBhcmFtIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvTGF5ZXI+fSBbcHJldkxheWVyXVxuICAgKi9cbiAgZ2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xheWVycztcbiAgfSxcbiAgX3VwZGF0ZUxheWVyU3RhdHVzOiBmdW5jdGlvbiAobGlzdCkge1xuICAgIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJzID0gdGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnM7XG4gICAgdmFyIGVsQ291bnRzTGFzdEZyYW1lID0ge307XG4gICAgdmFyIHByb2dyZXNzaXZlRWxDb3VudHNMYXN0RnJhbWUgPSB7fTtcbiAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICBlbENvdW50c0xhc3RGcmFtZVt6XSA9IGxheWVyLmVsQ291bnQ7XG4gICAgICBsYXllci5lbENvdW50ID0gMDtcbiAgICAgIGxheWVyLl9fZGlydHkgPSBmYWxzZTtcbiAgICB9KTtcbiAgICB1dGlsLmVhY2gocHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllciwgaWR4KSB7XG4gICAgICBwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lW2lkeF0gPSBsYXllci5lbENvdW50O1xuICAgICAgbGF5ZXIuZWxDb3VudCA9IDA7XG4gICAgICBsYXllci5fX2RpcnR5ID0gZmFsc2U7XG4gICAgfSk7XG4gICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJDb3VudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyO1xuICAgIHZhciBsYXN0UHJvZ3Jlc3NpdmVLZXk7XG4gICAgdmFyIGZyYW1lQ291bnQgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgIHZhciB6bGV2ZWwgPSB0aGlzLl9zaW5nbGVDYW52YXMgPyAwIDogZWwuemxldmVsO1xuICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW3psZXZlbF07XG4gICAgICB2YXIgZWxQcm9ncmVzcyA9IGVsLnByb2dyZXNzaXZlO1xuXG4gICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuZWxDb3VudCsrO1xuICAgICAgICBsYXllci5fX2RpcnR5ID0gbGF5ZXIuX19kaXJ0eSB8fCBlbC5fX2RpcnR5O1xuICAgICAgfSAvLy8vLy8vIFVwZGF0ZSBwcm9ncmVzc2l2ZVxuXG5cbiAgICAgIGlmIChlbFByb2dyZXNzID49IDApIHtcbiAgICAgICAgLy8gRml4IHdyb25nIHByb2dyZXNzaXZlIHNlcXVlbmNlIHByb2JsZW0uXG4gICAgICAgIGlmIChsYXN0UHJvZ3Jlc3NpdmVLZXkgIT09IGVsUHJvZ3Jlc3MpIHtcbiAgICAgICAgICBsYXN0UHJvZ3Jlc3NpdmVLZXkgPSBlbFByb2dyZXNzO1xuICAgICAgICAgIGZyYW1lQ291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbEZyYW1lID0gZWwuX19mcmFtZSA9IGZyYW1lQ291bnQgLSAxO1xuXG4gICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICB2YXIgaWR4ID0gTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllckNvdW50LCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSIC0gMSk7XG4gICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBwcm9ncmVzc2l2ZUxheWVyc1tpZHhdO1xuXG4gICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBwcm9ncmVzc2l2ZUxheWVyc1tpZHhdID0gbmV3IExheWVyKCdwcm9ncmVzc2l2ZScsIHRoaXMsIHRoaXMuZHByKTtcbiAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5ID0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19kaXJ0eSB8fCBlbC5fX2RpcnR5O1xuICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5lbENvdW50Kys7XG4gICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPSBNYXRoLm1heChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzLCBlbEZyYW1lKTtcblxuICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcyA+PSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzKSB7XG4gICAgICAgICAgLy8gU2hvdWxkIGtlZXAgcmVuZGVyaW5nIHRoaXMgIGxheWVyIGJlY2F1c2UgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nIGlzIG5vdCBmaW5pc2hlZCB5ZXRcbiAgICAgICAgICBsYXllci5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuX19mcmFtZSA9IC0xO1xuXG4gICAgICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgPSBpO1xuICAgICAgICAgIHByb2dyZXNzaXZlTGF5ZXJDb3VudCsrO1xuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgcHJvZ3Jlc3NpdmVMYXllckNvdW50Kys7XG4gICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nID0gaTtcbiAgICB9IC8vIOWxguS4reeahOWFg+e0oOaVsOmHj+acieWPkeeUn+WPmOWMllxuXG5cbiAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICBpZiAoZWxDb3VudHNMYXN0RnJhbWVbel0gIT09IGxheWVyLmVsQ291bnQpIHtcbiAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcHJvZ3Jlc3NpdmVMYXllcnMubGVuZ3RoID0gTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllckNvdW50LCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSKTtcbiAgICB1dGlsLmVhY2gocHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllciwgaWR4KSB7XG4gICAgICBpZiAocHJvZ3Jlc3NpdmVFbENvdW50c0xhc3RGcmFtZVtpZHhdICE9PSBsYXllci5lbENvdW50KSB7XG4gICAgICAgIGVsLl9fZGlydHkgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobGF5ZXIuX19kaXJ0eSkge1xuICAgICAgICBsYXllci5fX3Byb2dyZXNzID0gMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICog5riF6ZmkaG92ZXLlsYLlpJbmiYDmnInlhoXlrrlcbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKHRoaXMuX2NsZWFyTGF5ZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfY2xlYXJMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgbGF5ZXIuY2xlYXIoKTtcbiAgfSxcblxuICAvKipcbiAgICog5L+u5pS55oyH5a6aemxldmVs55qE57uY5Yi25Y+C5pWwXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6bGV2ZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyDphY3nva7lr7nosaFcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuY2xlYXJDb2xvcj0wXSDmr4/mrKHmuIXnqbrnlLvluIPnmoTpopzoibJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcubW90aW9uQmx1cj1mYWxzZV0g5piv5ZCm5byA5ZCv5Yqo5oCB5qih57OKXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLmxhc3RGcmFtZUFscGhhPTAuN11cbiAgICogICAgICAgICAgICAgICAgIOWcqOW8gOWQr+WKqOaAgeaooeeziueahOaXtuWAmeS9v+eUqO+8jOS4juS4iuS4gOW4p+a3t+WQiOeahGFscGhh5YC877yM5YC86LaK5aSn5bC+6L+56LaK5piO5pi+XG4gICAqL1xuICBjb25maWdMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgdmFyIGxheWVyQ29uZmlnID0gdGhpcy5fbGF5ZXJDb25maWc7XG5cbiAgICAgIGlmICghbGF5ZXJDb25maWdbemxldmVsXSkge1xuICAgICAgICBsYXllckNvbmZpZ1t6bGV2ZWxdID0gY29uZmlnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbC5tZXJnZShsYXllckNvbmZpZ1t6bGV2ZWxdLCBjb25maWcsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcblxuICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgIHV0aWwubWVyZ2UobGF5ZXIsIGxheWVyQ29uZmlnW3psZXZlbF0sIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5oyH5a6a5bGCXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWwg5bGC5omA5Zyo55qEemxldmVsXG4gICAqL1xuICBkZWxMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgIHZhciBsYXllciA9IGxheWVyc1t6bGV2ZWxdO1xuXG4gICAgaWYgKCFsYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxheWVyLmRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxheWVyLmRvbSk7XG4gICAgZGVsZXRlIGxheWVyc1t6bGV2ZWxdO1xuICAgIHpsZXZlbExpc3Quc3BsaWNlKHV0aWwuaW5kZXhPZih6bGV2ZWxMaXN0LCB6bGV2ZWwpLCAxKTtcbiAgfSxcblxuICAvKipcbiAgICog5Yy65Z+f5aSn5bCP5Y+Y5YyW5ZCO6YeN57uYXG4gICAqL1xuICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIGRvbVJvb3QgPSB0aGlzLl9kb21Sb290OyAvLyBGSVhNRSBXaHkgP1xuXG4gICAgZG9tUm9vdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBTYXZlIGlucHV0IHcvaFxuXG4gICAgdmFyIG9wdHMgPSB0aGlzLl9vcHRzO1xuICAgIHdpZHRoICE9IG51bGwgJiYgKG9wdHMud2lkdGggPSB3aWR0aCk7XG4gICAgaGVpZ2h0ICE9IG51bGwgJiYgKG9wdHMuaGVpZ2h0ID0gaGVpZ2h0KTtcbiAgICB3aWR0aCA9IHRoaXMuX2dldFNpemUoMCk7XG4gICAgaGVpZ2h0ID0gdGhpcy5fZ2V0U2l6ZSgxKTtcbiAgICBkb21Sb290LnN0eWxlLmRpc3BsYXkgPSAnJzsgLy8g5LyY5YyW5rKh5pyJ5a6e6ZmF5pS55Y+Y55qEcmVzaXplXG5cbiAgICBpZiAodGhpcy5fd2lkdGggIT0gd2lkdGggfHwgaGVpZ2h0ICE9IHRoaXMuX2hlaWdodCkge1xuICAgICAgZG9tUm9vdC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgIGRvbVJvb3Quc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXllcnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgdGhpcy5fbGF5ZXJzW2lkXS5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdXRpbC5lYWNoKHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJlZnJlc2godHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa4hemZpOWNleeLrOeahOS4gOS4quWxglxuICAgKiBAcGFyYW0ge251bWJlcn0gemxldmVsXG4gICAqL1xuICBjbGVhckxheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3psZXZlbF07XG5cbiAgICBpZiAobGF5ZXIpIHtcbiAgICAgIGxheWVyLmNsZWFyKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDph4rmlL5cbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJvb3QuaW5uZXJIVE1MID0gJyc7XG4gICAgdGhpcy5yb290ID0gdGhpcy5zdG9yYWdlID0gdGhpcy5fZG9tUm9vdCA9IHRoaXMuX2xheWVycyA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBjYW52YXMgd2hpY2ggaGFzIGFsbCB0aGluZyByZW5kZXJlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFja2dyb3VuZENvbG9yXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMucGl4ZWxSYXRpb11cbiAgICovXG4gIGdldFJlbmRlcmVkQ2FudmFzOiBmdW5jdGlvbiAob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgaWYgKHRoaXMuX3NpbmdsZUNhbnZhcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1swXS5kb207XG4gICAgfVxuXG4gICAgdmFyIGltYWdlTGF5ZXIgPSBuZXcgTGF5ZXIoJ2ltYWdlJywgdGhpcywgb3B0cy5waXhlbFJhdGlvIHx8IHRoaXMuZHByKTtcbiAgICBpbWFnZUxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgaW1hZ2VMYXllci5jbGVhckNvbG9yID0gb3B0cy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgaW1hZ2VMYXllci5jbGVhcigpO1xuICAgIHZhciBkaXNwbGF5TGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlKTtcbiAgICB2YXIgc2NvcGUgPSB7fTtcbiAgICB2YXIgemxldmVsO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGZpbmRBbmREcmF3T3RoZXJMYXllcihzbWFsbGVyLCBsYXJnZXIpIHtcbiAgICAgIHZhciB6bGV2ZWxMaXN0ID0gc2VsZi5femxldmVsTGlzdDtcblxuICAgICAgaWYgKHNtYWxsZXIgPT0gbnVsbCkge1xuICAgICAgICBzbWFsbGVyID0gLUluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICB2YXIgaW50ZXJtZWRpYXRlTGF5ZXI7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICAgIHZhciBsYXllciA9IHNlbGYuX2xheWVyc1t6XTtcblxuICAgICAgICBpZiAoIWxheWVyLl9fYnVpbHRpbl9fICYmIHogPiBzbWFsbGVyICYmIHogPCBsYXJnZXIpIHtcbiAgICAgICAgICBpbnRlcm1lZGlhdGVMYXllciA9IGxheWVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnRlcm1lZGlhdGVMYXllciAmJiBpbnRlcm1lZGlhdGVMYXllci5yZW5kZXJUb0NhbnZhcykge1xuICAgICAgICBpbWFnZUxheWVyLmN0eC5zYXZlKCk7XG4gICAgICAgIGludGVybWVkaWF0ZUxheWVyLnJlbmRlclRvQ2FudmFzKGltYWdlTGF5ZXIuY3R4KTtcbiAgICAgICAgaW1hZ2VMYXllci5jdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGxheUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbCA9IGRpc3BsYXlMaXN0W2ldO1xuXG4gICAgICBpZiAoZWwuemxldmVsICE9PSB6bGV2ZWwpIHtcbiAgICAgICAgZmluZEFuZERyYXdPdGhlckxheWVyKHpsZXZlbCwgZWwuemxldmVsKTtcbiAgICAgICAgemxldmVsID0gZWwuemxldmVsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGltYWdlTGF5ZXIsIHRydWUsIHNjb3BlKTtcbiAgICB9XG5cbiAgICBmaW5kQW5kRHJhd090aGVyTGF5ZXIoemxldmVsLCBJbmZpbml0eSk7XG4gICAgcmV0dXJuIGltYWdlTGF5ZXIuZG9tO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bnu5jlm77ljLrln5/lrr3luqZcbiAgICovXG4gIGdldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bnu5jlm77ljLrln5/pq5jluqZcbiAgICovXG4gIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH0sXG4gIF9nZXRTaXplOiBmdW5jdGlvbiAod2hJZHgpIHtcbiAgICB2YXIgb3B0cyA9IHRoaXMuX29wdHM7XG4gICAgdmFyIHdoID0gWyd3aWR0aCcsICdoZWlnaHQnXVt3aElkeF07XG4gICAgdmFyIGN3aCA9IFsnY2xpZW50V2lkdGgnLCAnY2xpZW50SGVpZ2h0J11bd2hJZHhdO1xuICAgIHZhciBwbHQgPSBbJ3BhZGRpbmdMZWZ0JywgJ3BhZGRpbmdUb3AnXVt3aElkeF07XG4gICAgdmFyIHByYiA9IFsncGFkZGluZ1JpZ2h0JywgJ3BhZGRpbmdCb3R0b20nXVt3aElkeF07XG5cbiAgICBpZiAob3B0c1t3aF0gIT0gbnVsbCAmJiBvcHRzW3doXSAhPT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChvcHRzW3doXSk7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7IC8vIElFOCBkb2VzIG5vdCBzdXBwb3J0IGdldENvbXB1dGVkU3R5bGUsIGJ1dCBpdCB1c2UgVk1MLlxuXG4gICAgdmFyIHN0bCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUocm9vdCk7XG4gICAgcmV0dXJuIChyb290W2N3aF0gfHwgcGFyc2VJbnQxMChzdGxbd2hdKSB8fCBwYXJzZUludDEwKHJvb3Quc3R5bGVbd2hdKSkgLSAocGFyc2VJbnQxMChzdGxbcGx0XSkgfHwgMCkgLSAocGFyc2VJbnQxMChzdGxbcHJiXSkgfHwgMCkgfCAwO1xuICB9LFxuICBwYXRoVG9JbWFnZTogZnVuY3Rpb24gKHBhdGgsIGRwcikge1xuICAgIGRwciA9IGRwciB8fCB0aGlzLmRwcjtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgc3R5bGUgPSBwYXRoLnN0eWxlO1xuICAgIHZhciBzaGFkb3dCbHVyU2l6ZSA9IHN0eWxlLnNoYWRvd0JsdXI7XG4gICAgdmFyIHNoYWRvd09mZnNldFggPSBzdHlsZS5zaGFkb3dPZmZzZXRYO1xuICAgIHZhciBzaGFkb3dPZmZzZXRZID0gc3R5bGUuc2hhZG93T2Zmc2V0WTtcbiAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUuaGFzU3Ryb2tlKCkgPyBzdHlsZS5saW5lV2lkdGggOiAwO1xuICAgIHZhciBsZWZ0TWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgLXNoYWRvd09mZnNldFggKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgdmFyIHJpZ2h0TWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgc2hhZG93T2Zmc2V0WCArIHNoYWRvd0JsdXJTaXplKTtcbiAgICB2YXIgdG9wTWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgLXNoYWRvd09mZnNldFkgKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgdmFyIGJvdHRvbU1hcmdpbiA9IE1hdGgubWF4KGxpbmVXaWR0aCAvIDIsIHNoYWRvd09mZnNldFkgKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgdmFyIHdpZHRoID0gcmVjdC53aWR0aCArIGxlZnRNYXJnaW4gKyByaWdodE1hcmdpbjtcbiAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgKyB0b3BNYXJnaW4gKyBib3R0b21NYXJnaW47XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcbiAgICBjdHguc2NhbGUoZHByLCBkcHIpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgY3R4LmRwciA9IGRwcjtcbiAgICB2YXIgcGF0aFRyYW5zZm9ybSA9IHtcbiAgICAgIHBvc2l0aW9uOiBwYXRoLnBvc2l0aW9uLFxuICAgICAgcm90YXRpb246IHBhdGgucm90YXRpb24sXG4gICAgICBzY2FsZTogcGF0aC5zY2FsZVxuICAgIH07XG4gICAgcGF0aC5wb3NpdGlvbiA9IFtsZWZ0TWFyZ2luIC0gcmVjdC54LCB0b3BNYXJnaW4gLSByZWN0LnldO1xuICAgIHBhdGgucm90YXRpb24gPSAwO1xuICAgIHBhdGguc2NhbGUgPSBbMSwgMV07XG4gICAgcGF0aC51cGRhdGVUcmFuc2Zvcm0oKTtcblxuICAgIGlmIChwYXRoKSB7XG4gICAgICBwYXRoLmJydXNoKGN0eCk7XG4gICAgfVxuXG4gICAgdmFyIEltYWdlU2hhcGUgPSBJbWFnZTtcbiAgICB2YXIgaW1nU2hhcGUgPSBuZXcgSW1hZ2VTaGFwZSh7XG4gICAgICBzdHlsZToge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICBpbWFnZTogY2FudmFzXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocGF0aFRyYW5zZm9ybS5wb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICBpbWdTaGFwZS5wb3NpdGlvbiA9IHBhdGgucG9zaXRpb24gPSBwYXRoVHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgIH1cblxuICAgIGlmIChwYXRoVHJhbnNmb3JtLnJvdGF0aW9uICE9IG51bGwpIHtcbiAgICAgIGltZ1NoYXBlLnJvdGF0aW9uID0gcGF0aC5yb3RhdGlvbiA9IHBhdGhUcmFuc2Zvcm0ucm90YXRpb247XG4gICAgfVxuXG4gICAgaWYgKHBhdGhUcmFuc2Zvcm0uc2NhbGUgIT0gbnVsbCkge1xuICAgICAgaW1nU2hhcGUuc2NhbGUgPSBwYXRoLnNjYWxlID0gcGF0aFRyYW5zZm9ybS5zY2FsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW1nU2hhcGU7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBQYWludGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvUGFpbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbnZhciBfY29uZmlnID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuXG52YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IF9jb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcblxudmFyIFN0eWxlID0gcmVxdWlyZShcIi4vZ3JhcGhpYy9TdHlsZVwiKTtcblxudmFyIFBhdHRlcm4gPSByZXF1aXJlKFwiLi9ncmFwaGljL1BhdHRlcm5cIik7XG5cbi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL0xheWVyXG4gKiBAYXV0aG9yIHBpc3NhbmcoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiDliJvlu7pkb21cbiAqXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBkb20gaWQg5b6F55SoXG4gKiBAcGFyYW0ge1BhaW50ZXJ9IHBhaW50ZXIgcGFpbnRlciBpbnN0YW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlclxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRG9tKGlkLCBwYWludGVyLCBkcHIpIHtcbiAgdmFyIG5ld0RvbSA9IHV0aWwuY3JlYXRlQ2FudmFzKCk7XG4gIHZhciB3aWR0aCA9IHBhaW50ZXIuZ2V0V2lkdGgoKTtcbiAgdmFyIGhlaWdodCA9IHBhaW50ZXIuZ2V0SGVpZ2h0KCk7XG4gIHZhciBuZXdEb21TdHlsZSA9IG5ld0RvbS5zdHlsZTsgLy8g5rKhYXBwZW5k5ZGi77yM6K+35Y6f6LCF5oiR6L+Z5qC35YaZ77yM5riF5pmwflxuXG4gIG5ld0RvbVN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgbmV3RG9tU3R5bGUubGVmdCA9IDA7XG4gIG5ld0RvbVN0eWxlLnRvcCA9IDA7XG4gIG5ld0RvbVN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICBuZXdEb21TdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICBuZXdEb20ud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgbmV3RG9tLmhlaWdodCA9IGhlaWdodCAqIGRwcjsgLy8gaWTkuI3kvZzkuLrntKLlvJXnlKjvvIzpgb/lhY3lj6/og73pgKDmiJDnmoTph43lkI3vvIzlrprkuYnkuLrnp4HmnInlsZ7mgKdcblxuICBuZXdEb20uc2V0QXR0cmlidXRlKCdkYXRhLXpyLWRvbS1pZCcsIGlkKTtcbiAgcmV0dXJuIG5ld0RvbTtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL0xheWVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9QYWludGVyfSBwYWludGVyXG4gKiBAcGFyYW0ge251bWJlcn0gW2Rwcl1cbiAqL1xuXG5cbnZhciBMYXllciA9IGZ1bmN0aW9uIChpZCwgcGFpbnRlciwgZHByKSB7XG4gIHZhciBkb207XG4gIGRwciA9IGRwciB8fCBkZXZpY2VQaXhlbFJhdGlvO1xuXG4gIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgZG9tID0gY3JlYXRlRG9tKGlkLCBwYWludGVyLCBkcHIpO1xuICB9IC8vIE5vdCB1c2luZyBpc0RvbSBiZWNhdXNlIGluIG5vZGUgaXQgd2lsbCByZXR1cm4gZmFsc2VcbiAgZWxzZSBpZiAodXRpbC5pc09iamVjdChpZCkpIHtcbiAgICAgIGRvbSA9IGlkO1xuICAgICAgaWQgPSBkb20uaWQ7XG4gICAgfVxuXG4gIHRoaXMuaWQgPSBpZDtcbiAgdGhpcy5kb20gPSBkb207XG4gIHZhciBkb21TdHlsZSA9IGRvbS5zdHlsZTtcblxuICBpZiAoZG9tU3R5bGUpIHtcbiAgICAvLyBOb3QgaW4gbm9kZVxuICAgIGRvbS5vbnNlbGVjdHN0YXJ0ID0gcmV0dXJuRmFsc2U7IC8vIOmBv+WFjemhtemdoumAieS4reeahOWwtOWwrFxuXG4gICAgZG9tU3R5bGVbJy13ZWJraXQtdXNlci1zZWxlY3QnXSA9ICdub25lJztcbiAgICBkb21TdHlsZVsndXNlci1zZWxlY3QnXSA9ICdub25lJztcbiAgICBkb21TdHlsZVsnLXdlYmtpdC10b3VjaC1jYWxsb3V0J10gPSAnbm9uZSc7XG4gICAgZG9tU3R5bGVbJy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvciddID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgIGRvbVN0eWxlWydwYWRkaW5nJ10gPSAwO1xuICAgIGRvbVN0eWxlWydtYXJnaW4nXSA9IDA7XG4gICAgZG9tU3R5bGVbJ2JvcmRlci13aWR0aCddID0gMDtcbiAgfVxuXG4gIHRoaXMuZG9tQmFjayA9IG51bGw7XG4gIHRoaXMuY3R4QmFjayA9IG51bGw7XG4gIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG4gIHRoaXMuY29uZmlnID0gbnVsbDsgLy8gQ29uZmlnc1xuXG4gIC8qKlxuICAgKiDmr4/mrKHmuIXnqbrnlLvluIPnmoTpopzoibJcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cblxuICB0aGlzLmNsZWFyQ29sb3IgPSAwO1xuICAvKipcbiAgICog5piv5ZCm5byA5ZCv5Yqo5oCB5qih57OKXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cblxuICB0aGlzLm1vdGlvbkJsdXIgPSBmYWxzZTtcbiAgLyoqXG4gICAqIOWcqOW8gOWQr+WKqOaAgeaooeeziueahOaXtuWAmeS9v+eUqO+8jOS4juS4iuS4gOW4p+a3t+WQiOeahGFscGhh5YC877yM5YC86LaK5aSn5bC+6L+56LaK5piO5pi+XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDAuN1xuICAgKi9cblxuICB0aGlzLmxhc3RGcmFtZUFscGhhID0gMC43O1xuICAvKipcbiAgICogTGF5ZXIgZHByXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuZHByID0gZHByO1xufTtcblxuTGF5ZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTGF5ZXIsXG4gIGVsQ291bnQ6IDAsXG4gIF9fZGlydHk6IHRydWUsXG4gIGluaXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jdHggPSB0aGlzLmRvbS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMuY3R4Ll9fY3VycmVudFZhbHVlcyA9IHt9O1xuICAgIHRoaXMuY3R4LmRwciA9IHRoaXMuZHByO1xuICB9LFxuICBjcmVhdGVCYWNrQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRwciA9IHRoaXMuZHByO1xuICAgIHRoaXMuZG9tQmFjayA9IGNyZWF0ZURvbSgnYmFjay0nICsgdGhpcy5pZCwgdGhpcy5wYWludGVyLCBkcHIpO1xuICAgIHRoaXMuY3R4QmFjayA9IHRoaXMuZG9tQmFjay5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMuY3R4QmFjay5fX2N1cnJlbnRWYWx1ZXMgPSB7fTtcblxuICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgdGhpcy5jdHhCYWNrLnNjYWxlKGRwciwgZHByKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0gd2lkdGhcbiAgICogQHBhcmFtICB7bnVtYmVyfSBoZWlnaHRcbiAgICovXG4gIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgZHByID0gdGhpcy5kcHI7XG4gICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgIHZhciBkb21TdHlsZSA9IGRvbS5zdHlsZTtcbiAgICB2YXIgZG9tQmFjayA9IHRoaXMuZG9tQmFjaztcbiAgICBkb21TdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICBkb21TdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIGRvbS53aWR0aCA9IHdpZHRoICogZHByO1xuICAgIGRvbS5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG5cbiAgICBpZiAoZG9tQmFjaykge1xuICAgICAgZG9tQmFjay53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgZG9tQmFjay5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG5cbiAgICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgICB0aGlzLmN0eEJhY2suc2NhbGUoZHByLCBkcHIpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5riF56m66K+l5bGC55S75biDXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXJBbGwgQ2xlYXIgYWxsIHdpdGggb3V0IG1vdGlvbiBibHVyXG4gICAqL1xuICBjbGVhcjogZnVuY3Rpb24gKGNsZWFyQWxsKSB7XG4gICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICB2YXIgd2lkdGggPSBkb20ud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IGRvbS5oZWlnaHQ7XG4gICAgdmFyIGNsZWFyQ29sb3IgPSB0aGlzLmNsZWFyQ29sb3I7XG4gICAgdmFyIGhhdmVNb3Rpb25CTHVyID0gdGhpcy5tb3Rpb25CbHVyICYmICFjbGVhckFsbDtcbiAgICB2YXIgbGFzdEZyYW1lQWxwaGEgPSB0aGlzLmxhc3RGcmFtZUFscGhhO1xuICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgIGlmIChoYXZlTW90aW9uQkx1cikge1xuICAgICAgaWYgKCF0aGlzLmRvbUJhY2spIHtcbiAgICAgICAgdGhpcy5jcmVhdGVCYWNrQnVmZmVyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4QmFjay5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG4gICAgICB0aGlzLmN0eEJhY2suZHJhd0ltYWdlKGRvbSwgMCwgMCwgd2lkdGggLyBkcHIsIGhlaWdodCAvIGRwcik7XG4gICAgfVxuXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGlmIChjbGVhckNvbG9yKSB7XG4gICAgICB2YXIgY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuOyAvLyBHcmFkaWVudFxuXG4gICAgICBpZiAoY2xlYXJDb2xvci5jb2xvclN0b3BzKSB7XG4gICAgICAgIC8vIENhY2hlIGNhbnZhcyBncmFkaWVudFxuICAgICAgICBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gPSBjbGVhckNvbG9yLl9fY2FudmFzR3JhZGllbnQgfHwgU3R5bGUuZ2V0R3JhZGllbnQoY3R4LCBjbGVhckNvbG9yLCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgY2xlYXJDb2xvci5fX2NhbnZhc0dyYWRpZW50ID0gY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuO1xuICAgICAgfSAvLyBQYXR0ZXJuXG4gICAgICBlbHNlIGlmIChjbGVhckNvbG9yLmltYWdlKSB7XG4gICAgICAgICAgY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuID0gUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybi5jYWxsKGNsZWFyQ29sb3IsIGN0eCk7XG4gICAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gfHwgY2xlYXJDb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgaWYgKGhhdmVNb3Rpb25CTHVyKSB7XG4gICAgICB2YXIgZG9tQmFjayA9IHRoaXMuZG9tQmFjaztcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBsYXN0RnJhbWVBbHBoYTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoZG9tQmFjaywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IExheWVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvTGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTVFlMRV9DT01NT05fUFJPUFMgPSBbWydzaGFkb3dCbHVyJywgMF0sIFsnc2hhZG93T2Zmc2V0WCcsIDBdLCBbJ3NoYWRvd09mZnNldFknLCAwXSwgWydzaGFkb3dDb2xvcicsICcjMDAwJ10sIFsnbGluZUNhcCcsICdidXR0J10sIFsnbGluZUpvaW4nLCAnbWl0ZXInXSwgWydtaXRlckxpbWl0JywgMTBdXTsgLy8gdmFyIFNIQURPV19QUk9QUyA9IFNUWUxFX0NPTU1PTl9QUk9QUy5zbGljZSgwLCA0KTtcbi8vIHZhciBMSU5FX1BST1BTID0gU1RZTEVfQ09NTU9OX1BST1BTLnNsaWNlKDQpO1xuXG52YXIgU3R5bGUgPSBmdW5jdGlvbiAob3B0cywgaG9zdCkge1xuICB0aGlzLmV4dGVuZEZyb20ob3B0cywgZmFsc2UpO1xuICB0aGlzLmhvc3QgPSBob3N0O1xufTtcblxuZnVuY3Rpb24gY3JlYXRlTGluZWFyR3JhZGllbnQoY3R4LCBvYmosIHJlY3QpIHtcbiAgdmFyIHggPSBvYmoueCA9PSBudWxsID8gMCA6IG9iai54O1xuICB2YXIgeDIgPSBvYmoueDIgPT0gbnVsbCA/IDEgOiBvYmoueDI7XG4gIHZhciB5ID0gb2JqLnkgPT0gbnVsbCA/IDAgOiBvYmoueTtcbiAgdmFyIHkyID0gb2JqLnkyID09IG51bGwgPyAwIDogb2JqLnkyO1xuXG4gIGlmICghb2JqLmdsb2JhbCkge1xuICAgIHggPSB4ICogcmVjdC53aWR0aCArIHJlY3QueDtcbiAgICB4MiA9IHgyICogcmVjdC53aWR0aCArIHJlY3QueDtcbiAgICB5ID0geSAqIHJlY3QuaGVpZ2h0ICsgcmVjdC55O1xuICAgIHkyID0geTIgKiByZWN0LmhlaWdodCArIHJlY3QueTtcbiAgfVxuXG4gIHZhciBjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4LCB5LCB4MiwgeTIpO1xuICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJhZGlhbEdyYWRpZW50KGN0eCwgb2JqLCByZWN0KSB7XG4gIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gIHZhciBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgdmFyIG1pbiA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xuICB2YXIgeCA9IG9iai54ID09IG51bGwgPyAwLjUgOiBvYmoueDtcbiAgdmFyIHkgPSBvYmoueSA9PSBudWxsID8gMC41IDogb2JqLnk7XG4gIHZhciByID0gb2JqLnIgPT0gbnVsbCA/IDAuNSA6IG9iai5yO1xuXG4gIGlmICghb2JqLmdsb2JhbCkge1xuICAgIHggPSB4ICogd2lkdGggKyByZWN0Lng7XG4gICAgeSA9IHkgKiBoZWlnaHQgKyByZWN0Lnk7XG4gICAgciA9IHIgKiBtaW47XG4gIH1cblxuICB2YXIgY2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoeCwgeSwgMCwgeCwgeSwgcik7XG4gIHJldHVybiBjYW52YXNHcmFkaWVudDtcbn1cblxuU3R5bGUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU3R5bGUsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlfVxuICAgKi9cbiAgaG9zdDogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGZpbGw6ICcjMDAwJyxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0cm9rZTogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIG9wYWNpdHk6IDEsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIGxpbmVEYXNoOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgbGluZURhc2hPZmZzZXQ6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzaGFkb3dCbHVyOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc2hhZG93T2Zmc2V0WDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHNoYWRvd09mZnNldFk6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBsaW5lV2lkdGg6IDEsXG5cbiAgLyoqXG4gICAqIElmIHN0cm9rZSBpZ25vcmUgc2NhbGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBzdHJva2VOb1NjYWxlOiBmYWxzZSxcbiAgLy8gQm91bmRpbmcgcmVjdCB0ZXh0IGNvbmZpZ3VyYXRpb25cbiAgLy8gTm90IGFmZmVjdGVkIGJ5IGVsZW1lbnQgdHJhbnNmb3JtXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0OiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZiBgZm9udFNpemVgIG9yIGBmb250RmFtaWx5YCBleGlzdHMsIGBmb250YCB3aWxsIGJlIHJlc2V0IGJ5XG4gICAqIGBmb250U2l6ZWAsIGBmb250U3R5bGVgLCBgZm9udFdlaWdodGAsIGBmb250RmFtaWx5YC5cbiAgICogU28gZG8gbm90IHZpc2l0IGl0IGRpcmVjdGx5IGluIHVwcGVyIGFwcGxpY2F0aW9uIChsaWtlIGVjaGFydHMpLFxuICAgKiBidXQgdXNlIGBjb250YWluL3RleHQjbWFrZUZvbnRgIGluc3RlYWQuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBmb250OiBudWxsLFxuXG4gIC8qKlxuICAgKiBUaGUgc2FtZSBhcyBmb250LiBVc2UgZm9udCBwbGVhc2UuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0Rm9udDogbnVsbCxcblxuICAvKipcbiAgICogSXQgaGVscHMgbWVyZ2luZyByZXNwZWN0aXZlbHksIHJhdGhlciB0aGFuIHBhcnNpbmcgYW4gZW50aXJlIGZvbnQgc3RyaW5nLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZm9udFN0eWxlOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJdCBoZWxwcyBtZXJnaW5nIHJlc3BlY3RpdmVseSwgcmF0aGVyIHRoYW4gcGFyc2luZyBhbiBlbnRpcmUgZm9udCBzdHJpbmcuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBmb250V2VpZ2h0OiBudWxsLFxuXG4gIC8qKlxuICAgKiBJdCBoZWxwcyBtZXJnaW5nIHJlc3BlY3RpdmVseSwgcmF0aGVyIHRoYW4gcGFyc2luZyBhbiBlbnRpcmUgZm9udCBzdHJpbmcuXG4gICAqIFNob3VsZCBiZSAxMiBidXQgbm90ICcxMnB4Jy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGZvbnRTaXplOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJdCBoZWxwcyBtZXJnaW5nIHJlc3BlY3RpdmVseSwgcmF0aGVyIHRoYW4gcGFyc2luZyBhbiBlbnRpcmUgZm9udCBzdHJpbmcuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBmb250RmFtaWx5OiBudWxsLFxuXG4gIC8qKlxuICAgKiBSZXNlcnZlZCBmb3Igc3BlY2lhbCBmdW5jdGluYWxpdHksIGxpa2UgJ2hyJy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRUYWc6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0RmlsbDogJyMwMDAnLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dFN0cm9rZTogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRXaWR0aDogbnVsbCxcblxuICAvKipcbiAgICogT25seSBmb3IgdGV4dEJhY2tncm91bmQuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0SGVpZ2h0OiBudWxsLFxuXG4gIC8qKlxuICAgKiB0ZXh0U3Ryb2tlIG1heSBiZSBzZXQgYXMgc29tZSBjb2xvciBhcyBhIGRlZmF1bHRcbiAgICogdmFsdWUgaW4gdXBwZXIgYXBwbGljYWlvbiwgd2hlcmUgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICogb2YgdGV4dFN0cm9rZVdpZHRoIHNob3VsZCBiZSAwIHRvIG1ha2Ugc3VyZSB0aGF0XG4gICAqIHVzZXIgY2FuIGNob29zZSB0byBkbyBub3QgdXNlIHRleHQgc3Ryb2tlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dFN0cm9rZVdpZHRoOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dExpbmVIZWlnaHQ6IG51bGwsXG5cbiAgLyoqXG4gICAqICdpbnNpZGUnLCAnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ1xuICAgKiBbeCwgeV1cbiAgICogQmFzZWQgb24geCwgeSBvZiByZWN0LlxuICAgKiBAdHlwZSB7c3RyaW5nfEFycmF5LjxudW1iZXI+fVxuICAgKiBAZGVmYXVsdCAnaW5zaWRlJ1xuICAgKi9cbiAgdGV4dFBvc2l0aW9uOiAnaW5zaWRlJyxcblxuICAvKipcbiAgICogSWYgbm90IHNwZWNpZmllZCwgdXNlIHRoZSBib3VuZGluZ1JlY3Qgb2YgYSBgZGlzcGxheWFibGVgLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdGV4dFJlY3Q6IG51bGwsXG5cbiAgLyoqXG4gICAqIFt4LCB5XVxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICB0ZXh0T2Zmc2V0OiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEFsaWduOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dFZlcnRpY2FsQWxpZ246IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0RGlzdGFuY2U6IDUsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0U2hhZG93Q29sb3I6ICd0cmFuc3BhcmVudCcsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0U2hhZG93Qmx1cjogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRTaGFkb3dPZmZzZXRYOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dFNoYWRvd09mZnNldFk6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0Qm94U2hhZG93Q29sb3I6ICd0cmFuc3BhcmVudCcsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0Qm94U2hhZG93Qmx1cjogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRCb3hTaGFkb3dPZmZzZXRYOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dEJveFNoYWRvd09mZnNldFk6IDAsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdHJhbnNmb3JtIHRleHQuXG4gICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnRcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB0cmFuc2Zvcm1UZXh0OiBmYWxzZSxcblxuICAvKipcbiAgICogVGV4dCByb3RhdGUgYXJvdW5kIHBvc2l0aW9uIG9mIFBhdGggb3IgSW1hZ2VcbiAgICogT25seSB1c2VmdWwgaW4gUGF0aCBhbmQgSW1hZ2UgZWxlbWVudCBhbmQgdHJhbnNmb3JtVGV4dCBpcyBmYWxzZS5cbiAgICovXG4gIHRleHRSb3RhdGlvbjogMCxcblxuICAvKipcbiAgICogVGV4dCBvcmlnaW4gb2YgdGV4dCByb3RhdGlvbiwgbGlrZSBbMTAsIDQwXS5cbiAgICogQmFzZWQgb24geCwgeSBvZiByZWN0LlxuICAgKiBVc2VmdWwgaW4gbGFiZWwgcm90YXRpb24gb2YgY2lyY3VsYXIgc3ltYm9sLlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIG9yaWdpbiBpcyB0ZXh0UG9zaXRpb24uXG4gICAqIENhbiBiZSAnY2VudGVyJy5cbiAgICogQHR5cGUge3N0cmluZ3xBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIHRleHRPcmlnaW46IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0QmFja2dyb3VuZENvbG9yOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEJvcmRlckNvbG9yOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dEJvcmRlcldpZHRoOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dEJvcmRlclJhZGl1czogMCxcblxuICAvKipcbiAgICogQ2FuIGJlIGAyYCBvciBgWzIsIDRdYCBvciBgWzIsIDMsIDQsIDVdYFxuICAgKiBAdHlwZSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgdGV4dFBhZGRpbmc6IG51bGwsXG5cbiAgLyoqXG4gICAqIFRleHQgc3R5bGVzIGZvciByaWNoIHRleHQuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICByaWNoOiBudWxsLFxuXG4gIC8qKlxuICAgKiB7b3V0ZXJXaWR0aCwgb3V0ZXJIZWlnaHQsIGVsbGlwc2lzLCBwbGFjZWhvbGRlcn1cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHRydW5jYXRlOiBudWxsLFxuXG4gIC8qKlxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2dsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgYmxlbmQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICovXG4gIGJpbmQ6IGZ1bmN0aW9uIChjdHgsIGVsLCBwcmV2RWwpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzO1xuICAgIHZhciBwcmV2U3R5bGUgPSBwcmV2RWwgJiYgcHJldkVsLnN0eWxlO1xuICAgIHZhciBmaXJzdERyYXcgPSAhcHJldlN0eWxlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBTVFlMRV9DT01NT05fUFJPUFMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gU1RZTEVfQ09NTU9OX1BST1BTW2ldO1xuICAgICAgdmFyIHN0eWxlTmFtZSA9IHByb3BbMF07XG5cbiAgICAgIGlmIChmaXJzdERyYXcgfHwgc3R5bGVbc3R5bGVOYW1lXSAhPT0gcHJldlN0eWxlW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgLy8gRklYTUUgSW52YWxpZCBwcm9wZXJ0eSB2YWx1ZSB3aWxsIGNhdXNlIHN0eWxlIGxlYWsgZnJvbSBwcmV2aW91cyBlbGVtZW50LlxuICAgICAgICBjdHhbc3R5bGVOYW1lXSA9IHN0eWxlW3N0eWxlTmFtZV0gfHwgcHJvcFsxXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmlyc3REcmF3IHx8IHN0eWxlLmZpbGwgIT09IHByZXZTdHlsZS5maWxsKSB7XG4gICAgICBjdHguZmlsbFN0eWxlID0gc3R5bGUuZmlsbDtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3REcmF3IHx8IHN0eWxlLnN0cm9rZSAhPT0gcHJldlN0eWxlLnN0cm9rZSkge1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuc3Ryb2tlO1xuICAgIH1cblxuICAgIGlmIChmaXJzdERyYXcgfHwgc3R5bGUub3BhY2l0eSAhPT0gcHJldlN0eWxlLm9wYWNpdHkpIHtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHN0eWxlLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBzdHlsZS5vcGFjaXR5O1xuICAgIH1cblxuICAgIGlmIChmaXJzdERyYXcgfHwgc3R5bGUuYmxlbmQgIT09IHByZXZTdHlsZS5ibGVuZCkge1xuICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHN0eWxlLmJsZW5kIHx8ICdzb3VyY2Utb3Zlcic7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzU3Ryb2tlKCkpIHtcbiAgICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoIC8gKHRoaXMuc3Ryb2tlTm9TY2FsZSAmJiBlbCAmJiBlbC5nZXRMaW5lU2NhbGUgPyBlbC5nZXRMaW5lU2NhbGUoKSA6IDEpO1xuICAgIH1cbiAgfSxcbiAgaGFzRmlsbDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmaWxsID0gdGhpcy5maWxsO1xuICAgIHJldHVybiBmaWxsICE9IG51bGwgJiYgZmlsbCAhPT0gJ25vbmUnO1xuICB9LFxuICBoYXNTdHJva2U6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3Ryb2tlID0gdGhpcy5zdHJva2U7XG4gICAgcmV0dXJuIHN0cm9rZSAhPSBudWxsICYmIHN0cm9rZSAhPT0gJ25vbmUnICYmIHRoaXMubGluZVdpZHRoID4gMDtcbiAgfSxcblxuICAvKipcbiAgICogRXh0ZW5kIGZyb20gb3RoZXIgc3R5bGVcbiAgICogQHBhcmFtIHt6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IG90aGVyU3R5bGVcbiAgICogQHBhcmFtIHtib29sZWFufSBvdmVyd3JpdGUgdHJ1ZTogb3ZlcndyaXJ0ZSBhbnkgd2F5LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZTogb3ZlcndyaXRlIG9ubHkgd2hlbiAhdGFyZ2V0Lmhhc093blByb3BlcnR5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyczogb3ZlcndyaXRlIHdoZW4gcHJvcGVydHkgaXMgbm90IG51bGwvdW5kZWZpbmVkLlxuICAgKi9cbiAgZXh0ZW5kRnJvbTogZnVuY3Rpb24gKG90aGVyU3R5bGUsIG92ZXJ3cml0ZSkge1xuICAgIGlmIChvdGhlclN0eWxlKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIG90aGVyU3R5bGUpIHtcbiAgICAgICAgaWYgKG90aGVyU3R5bGUuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgKG92ZXJ3cml0ZSA9PT0gdHJ1ZSB8fCAob3ZlcndyaXRlID09PSBmYWxzZSA/ICF0aGlzLmhhc093blByb3BlcnR5KG5hbWUpIDogb3RoZXJTdHlsZVtuYW1lXSAhPSBudWxsKSkpIHtcbiAgICAgICAgICB0aGlzW25hbWVdID0gb3RoZXJTdHlsZVtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQmF0Y2ggc2V0dGluZyBzdHlsZSB3aXRoIGEgZ2l2ZW4gb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gb2JqXG4gICAqIEBwYXJhbSB7Kn0gW29ial1cbiAgICovXG4gIHNldDogZnVuY3Rpb24gKG9iaiwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXNbb2JqXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4dGVuZEZyb20ob2JqLCB0cnVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsb25lXG4gICAqIEByZXR1cm4ge3pyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV3U3R5bGUgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xuICAgIG5ld1N0eWxlLmV4dGVuZEZyb20odGhpcywgdHJ1ZSk7XG4gICAgcmV0dXJuIG5ld1N0eWxlO1xuICB9LFxuICBnZXRHcmFkaWVudDogZnVuY3Rpb24gKGN0eCwgb2JqLCByZWN0KSB7XG4gICAgdmFyIG1ldGhvZCA9IG9iai50eXBlID09PSAncmFkaWFsJyA/IGNyZWF0ZVJhZGlhbEdyYWRpZW50IDogY3JlYXRlTGluZWFyR3JhZGllbnQ7XG4gICAgdmFyIGNhbnZhc0dyYWRpZW50ID0gbWV0aG9kKGN0eCwgb2JqLCByZWN0KTtcbiAgICB2YXIgY29sb3JTdG9wcyA9IG9iai5jb2xvclN0b3BzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvclN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYW52YXNHcmFkaWVudC5hZGRDb2xvclN0b3AoY29sb3JTdG9wc1tpXS5vZmZzZXQsIGNvbG9yU3RvcHNbaV0uY29sb3IpO1xuICAgIH1cblxuICAgIHJldHVybiBjYW52YXNHcmFkaWVudDtcbiAgfVxufTtcbnZhciBzdHlsZVByb3RvID0gU3R5bGUucHJvdG90eXBlO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IFNUWUxFX0NPTU1PTl9QUk9QUy5sZW5ndGg7IGkrKykge1xuICB2YXIgcHJvcCA9IFNUWUxFX0NPTU1PTl9QUk9QU1tpXTtcblxuICBpZiAoIShwcm9wWzBdIGluIHN0eWxlUHJvdG8pKSB7XG4gICAgc3R5bGVQcm90b1twcm9wWzBdXSA9IHByb3BbMV07XG4gIH1cbn0gLy8gUHJvdmlkZSBmb3Igb3RoZXJzXG5cblxuU3R5bGUuZ2V0R3JhZGllbnQgPSBzdHlsZVByb3RvLmdldEdyYWRpZW50O1xudmFyIF9kZWZhdWx0ID0gU3R5bGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1N0eWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF0dGVybiA9IGZ1bmN0aW9uIChpbWFnZSwgcmVwZWF0KSB7XG4gIC8vIFNob3VsZCBkbyBub3RoaW5nIG1vcmUgaW4gdGhpcyBjb25zdHJ1Y3Rvci4gQmVjYXVzZSBncmFkaWVudCBjYW4gYmVcbiAgLy8gZGVjbGFyZCBieSBgY29sb3I6IHtpbWFnZTogLi4ufWAsIHdoZXJlIHRoaXMgY29uc3RydWN0b3Igd2lsbCBub3QgYmUgY2FsbGVkLlxuICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gIHRoaXMucmVwZWF0ID0gcmVwZWF0OyAvLyBDYW4gYmUgY2xvbmVkXG5cbiAgdGhpcy50eXBlID0gJ3BhdHRlcm4nO1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybiA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHRoaXMuaW1hZ2UsIHRoaXMucmVwZWF0IHx8ICdyZXBlYXQnKTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IFBhdHRlcm47XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1BhdHRlcm4uanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfZGVmYXVsdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lY29tZmUvenJlbmRlci9pc3N1ZXMvMTg5I2lzc3VlY29tbWVudC0yMjQ5MTk4MDlcbndpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSAmJiB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSkgfHwgZnVuY3Rpb24gKGZ1bmMpIHtcbiAgc2V0VGltZW91dChmdW5jLCAxNik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKFwiLi9EaXNwbGF5YWJsZVwiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuLi9jb3JlL0JvdW5kaW5nUmVjdFwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBpbWFnZUhlbHBlciA9IHJlcXVpcmUoXCIuL2hlbHBlci9pbWFnZVwiKTtcblxuLyoqXG4gKiBAYWxpYXMgenJlbmRlci9ncmFwaGljL0ltYWdlXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbmZ1bmN0aW9uIFpJbWFnZShvcHRzKSB7XG4gIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG59XG5cblpJbWFnZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBaSW1hZ2UsXG4gIHR5cGU6ICdpbWFnZScsXG4gIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHZhciBzcmMgPSBzdHlsZS5pbWFnZTsgLy8gTXVzdCBiaW5kIGVhY2ggdGltZVxuXG4gICAgc3R5bGUuYmluZChjdHgsIHRoaXMsIHByZXZFbCk7XG4gICAgdmFyIGltYWdlID0gdGhpcy5faW1hZ2UgPSBpbWFnZUhlbHBlci5jcmVhdGVPclVwZGF0ZUltYWdlKHNyYywgdGhpcy5faW1hZ2UsIHRoaXMsIHRoaXMub25sb2FkKTtcblxuICAgIGlmICghaW1hZ2UgfHwgIWltYWdlSGVscGVyLmlzSW1hZ2VSZWFkeShpbWFnZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIOWbvueJh+W3sue7j+WKoOi9veWujOaIkFxuICAgIC8vIGlmIChpbWFnZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09ICdJTUcnKSB7XG4gICAgLy8gICAgIGlmICghaW1hZ2UuY29tcGxldGUpIHtcbiAgICAvLyAgICAgICAgIHJldHVybjtcbiAgICAvLyAgICAgfVxuICAgIC8vIH1cbiAgICAvLyBFbHNlIGlzIGNhbnZhc1xuXG5cbiAgICB2YXIgeCA9IHN0eWxlLnggfHwgMDtcbiAgICB2YXIgeSA9IHN0eWxlLnkgfHwgMDtcbiAgICB2YXIgd2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gc3R5bGUuaGVpZ2h0O1xuICAgIHZhciBhc3BlY3QgPSBpbWFnZS53aWR0aCAvIGltYWdlLmhlaWdodDtcblxuICAgIGlmICh3aWR0aCA9PSBudWxsICYmIGhlaWdodCAhPSBudWxsKSB7XG4gICAgICAvLyBLZWVwIGltYWdlL2hlaWdodCByYXRpb1xuICAgICAgd2lkdGggPSBoZWlnaHQgKiBhc3BlY3Q7XG4gICAgfSBlbHNlIGlmIChoZWlnaHQgPT0gbnVsbCAmJiB3aWR0aCAhPSBudWxsKSB7XG4gICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdDtcbiAgICB9IGVsc2UgaWYgKHdpZHRoID09IG51bGwgJiYgaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgIHdpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgfSAvLyDorr7nva50cmFuc2Zvcm1cblxuXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcblxuICAgIGlmIChzdHlsZS5zV2lkdGggJiYgc3R5bGUuc0hlaWdodCkge1xuICAgICAgdmFyIHN4ID0gc3R5bGUuc3ggfHwgMDtcbiAgICAgIHZhciBzeSA9IHN0eWxlLnN5IHx8IDA7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBzeCwgc3ksIHN0eWxlLnNXaWR0aCwgc3R5bGUuc0hlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIGlmIChzdHlsZS5zeCAmJiBzdHlsZS5zeSkge1xuICAgICAgdmFyIHN4ID0gc3R5bGUuc3g7XG4gICAgICB2YXIgc3kgPSBzdHlsZS5zeTtcbiAgICAgIHZhciBzV2lkdGggPSB3aWR0aCAtIHN4O1xuICAgICAgdmFyIHNIZWlnaHQgPSBoZWlnaHQgLSBzeTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIHN4LCBzeSwgc1dpZHRoLCBzSGVpZ2h0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7IC8vIERyYXcgcmVjdCB0ZXh0XG5cbiAgICBpZiAoc3R5bGUudGV4dCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmRyYXdSZWN0VGV4dChjdHgsIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgIH1cbiAgfSxcbiAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcblxuICAgIGlmICghdGhpcy5fcmVjdCkge1xuICAgICAgdGhpcy5fcmVjdCA9IG5ldyBCb3VuZGluZ1JlY3Qoc3R5bGUueCB8fCAwLCBzdHlsZS55IHx8IDAsIHN0eWxlLndpZHRoIHx8IDAsIHN0eWxlLmhlaWdodCB8fCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgfVxufTtcbnpyVXRpbC5pbmhlcml0cyhaSW1hZ2UsIERpc3BsYXlhYmxlKTtcbnZhciBfZGVmYXVsdCA9IFpJbWFnZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgU3R5bGUgPSByZXF1aXJlKFwiLi9TdHlsZVwiKTtcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKFwiLi4vRWxlbWVudFwiKTtcblxudmFyIFJlY3RUZXh0ID0gcmVxdWlyZShcIi4vbWl4aW4vUmVjdFRleHRcIik7XG5cbi8qKlxuICog5Y+v57uY5Yi255qE5Zu+5b2i5Z+657G7XG4gKiBCYXNlIGNsYXNzIG9mIGFsbCBkaXNwbGF5YWJsZSBncmFwaGljIG9iamVjdHNcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKi9cblxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvRWxlbWVudFxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9taXhpbi9SZWN0VGV4dFxuICovXG5mdW5jdGlvbiBEaXNwbGF5YWJsZShvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBFbGVtZW50LmNhbGwodGhpcywgb3B0cyk7IC8vIEV4dGVuZCBwcm9wZXJ0aWVzXG5cbiAgZm9yICh2YXIgbmFtZSBpbiBvcHRzKSB7XG4gICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgbmFtZSAhPT0gJ3N0eWxlJykge1xuICAgICAgdGhpc1tuYW1lXSA9IG9wdHNbbmFtZV07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9TdHlsZX1cbiAgICovXG5cblxuICB0aGlzLnN0eWxlID0gbmV3IFN0eWxlKG9wdHMuc3R5bGUsIHRoaXMpO1xuICB0aGlzLl9yZWN0ID0gbnVsbDsgLy8gU2hhcGVzIGZvciBjYXNjYWRlIGNsaXBwaW5nLlxuXG4gIHRoaXMuX19jbGlwUGF0aHMgPSBbXTsgLy8gRklYTUUgU3RhdGVmdWwgbXVzdCBiZSBtaXhpbmVkIGFmdGVyIHN0eWxlIGlzIHNldHRlZFxuICAvLyBTdGF0ZWZ1bC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG5EaXNwbGF5YWJsZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBEaXNwbGF5YWJsZSxcbiAgdHlwZTogJ2Rpc3BsYXlhYmxlJyxcblxuICAvKipcbiAgICogRGlzcGxheWFibGUg5piv5ZCm5Li66ISP77yMUGFpbnRlciDkuK3kvJrmoLnmja7or6XmoIforrDliKTmlq3mmK/lkKbpnIDopoHmmK/lkKbpnIDopoHph43mlrDnu5jliLZcbiAgICogRGlydHkgZmxhZy4gRnJvbSB3aGljaCBwYWludGVyIHdpbGwgZGV0ZXJtaW5lIGlmIHRoaXMgZGlzcGxheWFibGUgb2JqZWN0IG5lZWRzIGJydXNoXG4gICAqIEBuYW1lIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjX19kaXJ0eVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIF9fZGlydHk6IHRydWUsXG5cbiAgLyoqXG4gICAqIOWbvuW9ouaYr+WQpuWPr+inge+8jOS4unRydWXml7bkuI3nu5jliLblm77lvaLvvIzkvYbmmK/ku43og73op6blj5HpvKDmoIfkuovku7ZcbiAgICogSWYgaWdub3JlIGRyYXdpbmcgb2YgdGhlIGRpc3BsYXlhYmxlIG9iamVjdC4gTW91c2UgZXZlbnQgd2lsbCBzdGlsbCBiZSB0cmlnZ2VyZWRcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjaW52aXNpYmxlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgaW52aXNpYmxlOiBmYWxzZSxcblxuICAvKipcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjelxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICB6OiAwLFxuXG4gIC8qKlxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIHoyOiAwLFxuXG4gIC8qKlxuICAgKiB65bGCbGV2ZWzvvIzlhrPlrprnu5jnlLvlnKjlk6rlsYJjYW52YXPkuK1cbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjemxldmVsXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIHpsZXZlbDogMCxcblxuICAvKipcbiAgICog5piv5ZCm5Y+v5ouW5ou9XG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2RyYWdnYWJsZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRyYWdnYWJsZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIOaYr+WQpuato+WcqOaLluaLvVxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNkcmFnZ2FibGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkcmFnZ2luZzogZmFsc2UsXG5cbiAgLyoqXG4gICAqIOaYr+WQpuebuOW6lOm8oOagh+S6i+S7tlxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNzaWxlbnRcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBJZiBlbmFibGUgY3VsbGluZ1xuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGN1bGxpbmc6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBNb3VzZSBjdXJzb3Igd2hlbiBob3ZlcmVkXG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2N1cnNvclxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgY3Vyc29yOiAncG9pbnRlcicsXG5cbiAgLyoqXG4gICAqIElmIGhvdmVyIGFyZWEgaXMgYm91bmRpbmcgcmVjdFxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNyZWN0SG92ZXJcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHJlY3RIb3ZlcjogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgZWxlbWVudCBwcm9ncmVzc2l2ZWx5IHdoZW4gdGhlIHZhbHVlID49IDAsXG4gICAqIHVzZWZ1bGwgZm9yIGxhcmdlIGRhdGEuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBwcm9ncmVzc2l2ZTogLTEsXG4gIGJlZm9yZUJydXNoOiBmdW5jdGlvbiAoY3R4KSB7fSxcbiAgYWZ0ZXJCcnVzaDogZnVuY3Rpb24gKGN0eCkge30sXG5cbiAgLyoqXG4gICAqIOWbvuW9oue7mOWItuaWueazlVxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqL1xuICAvLyBJbnRlcmZhY2VcbiAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge30sXG5cbiAgLyoqXG4gICAqIOiOt+WPluacgOWwj+WMheWbtOebklxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICovXG4gIC8vIEludGVyZmFjZVxuICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIC8qKlxuICAgKiDliKTmlq3lnZDmoIcgeCwgeSDmmK/lkKblnKjlm77lvaLkuIpcbiAgICogSWYgZGlzcGxheWFibGUgZWxlbWVudCBjb250YWluIGNvb3JkIHgsIHlcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgY29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5yZWN0Q29udGFpbih4LCB5KTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAqL1xuICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgY2IuY2FsbChjb250ZXh0LCB0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICog5Yik5pat5Z2Q5qCHIHgsIHkg5piv5ZCm5Zyo5Zu+5b2i55qE5YyF5Zu055uS5LiKXG4gICAqIElmIGJvdW5kaW5nIHJlY3Qgb2YgZWxlbWVudCBjb250YWluIGNvb3JkIHgsIHlcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgcmVjdENvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIGNvb3JkID0gdGhpcy50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHJldHVybiByZWN0LmNvbnRhaW4oY29vcmRbMF0sIGNvb3JkWzFdKTtcbiAgfSxcblxuICAvKipcbiAgICog5qCH6K6w5Zu+5b2i5YWD57Sg5Li66ISP77yM5bm25LiU5Zyo5LiL5LiA5bin6YeN57uYXG4gICAqIE1hcmsgZGlzcGxheWFibGUgZWxlbWVudCBkaXJ0eSBhbmQgcmVmcmVzaCBuZXh0IGZyYW1lXG4gICAqL1xuICBkaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fcmVjdCA9IG51bGw7XG4gICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWbvuW9ouaYr+WQpuS8muinpuWPkeS6i+S7tlxuICAgKiBJZiBkaXNwbGF5YWJsZSBvYmplY3QgYmluZGVkIGFueSBldmVudFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgLy8gVE9ETywg6YCa6L+HIGJpbmQg57uR5a6a55qE5LqL5Lu2XG4gIC8vIGlzU2lsZW50OiBmdW5jdGlvbiAoKSB7XG4gIC8vICAgICByZXR1cm4gIShcbiAgLy8gICAgICAgICB0aGlzLmhvdmVyYWJsZSB8fCB0aGlzLmRyYWdnYWJsZVxuICAvLyAgICAgICAgIHx8IHRoaXMub25tb3VzZW1vdmUgfHwgdGhpcy5vbm1vdXNlb3ZlciB8fCB0aGlzLm9ubW91c2VvdXRcbiAgLy8gICAgICAgICB8fCB0aGlzLm9ubW91c2Vkb3duIHx8IHRoaXMub25tb3VzZXVwIHx8IHRoaXMub25jbGlja1xuICAvLyAgICAgICAgIHx8IHRoaXMub25kcmFnZW50ZXIgfHwgdGhpcy5vbmRyYWdvdmVyIHx8IHRoaXMub25kcmFnbGVhdmVcbiAgLy8gICAgICAgICB8fCB0aGlzLm9uZHJvcFxuICAvLyAgICAgKTtcbiAgLy8gfSxcblxuICAvKipcbiAgICogQWxpYXMgZm9yIGFuaW1hdGUoJ3N0eWxlJylcbiAgICogQHBhcmFtIHtib29sZWFufSBsb29wXG4gICAqL1xuICBhbmltYXRlU3R5bGU6IGZ1bmN0aW9uIChsb29wKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSgnc3R5bGUnLCBsb29wKTtcbiAgfSxcbiAgYXR0cktWOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgIT09ICdzdHlsZScpIHtcbiAgICAgIEVsZW1lbnQucHJvdG90eXBlLmF0dHJLVi5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0eWxlLnNldCh2YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICBzZXRTdHlsZTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLnN0eWxlLnNldChrZXksIHZhbHVlKTtcbiAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogVXNlIGdpdmVuIHN0eWxlIG9iamVjdFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9ialxuICAgKi9cbiAgdXNlU3R5bGU6IGZ1bmN0aW9uIChvYmopIHtcbiAgICB0aGlzLnN0eWxlID0gbmV3IFN0eWxlKG9iaiwgdGhpcyk7XG4gICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG56clV0aWwuaW5oZXJpdHMoRGlzcGxheWFibGUsIEVsZW1lbnQpO1xuenJVdGlsLm1peGluKERpc3BsYXlhYmxlLCBSZWN0VGV4dCk7IC8vIHpyVXRpbC5taXhpbihEaXNwbGF5YWJsZSwgU3RhdGVmdWwpO1xuXG52YXIgX2RlZmF1bHQgPSBEaXNwbGF5YWJsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvRGlzcGxheWFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0ZXh0SGVscGVyID0gcmVxdWlyZShcIi4uL2hlbHBlci90ZXh0XCIpO1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG4vKipcbiAqIE1peGluIGZvciBkcmF3aW5nIHRleHQgaW4gYSBlbGVtZW50IGJvdW5kaW5nIHJlY3RcbiAqIEBtb2R1bGUgenJlbmRlci9taXhpbi9SZWN0VGV4dFxuICovXG52YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoKTtcblxudmFyIFJlY3RUZXh0ID0gZnVuY3Rpb24gKCkge307XG5cblJlY3RUZXh0LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFJlY3RUZXh0LFxuXG4gIC8qKlxuICAgKiBEcmF3IHRleHQgaW4gYSByZWN0IHdpdGggc3BlY2lmaWVkIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHJlY3QgRGlzcGxheWFibGUgcmVjdFxuICAgKi9cbiAgZHJhd1JlY3RUZXh0OiBmdW5jdGlvbiAoY3R4LCByZWN0KSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICByZWN0ID0gc3R5bGUudGV4dFJlY3QgfHwgcmVjdDsgLy8gT3B0aW1pemUsIGF2b2lkIG5vcm1hbGl6ZSBldmVyeSB0aW1lLlxuXG4gICAgdGhpcy5fX2RpcnR5ICYmIHRleHRIZWxwZXIubm9ybWFsaXplVGV4dFN0eWxlKHN0eWxlLCB0cnVlKTtcbiAgICB2YXIgdGV4dCA9IHN0eWxlLnRleHQ7IC8vIENvbnZlcnQgdG8gc3RyaW5nXG5cbiAgICB0ZXh0ICE9IG51bGwgJiYgKHRleHQgKz0gJycpO1xuXG4gICAgaWYgKCF0ZXh0SGVscGVyLm5lZWREcmF3VGV4dCh0ZXh0LCBzdHlsZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZJWE1FXG5cblxuICAgIGN0eC5zYXZlKCk7IC8vIFRyYW5zZm9ybSByZWN0IHRvIHZpZXcgc3BhY2VcblxuICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybTtcblxuICAgIGlmICghc3R5bGUudHJhbnNmb3JtVGV4dCkge1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICB0bXBSZWN0LmNvcHkocmVjdCk7XG4gICAgICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgICAgcmVjdCA9IHRtcFJlY3Q7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG4gICAgfSAvLyB0cmFuc2Zvcm1UZXh0IGFuZCB0ZXh0Um90YXRpb24gY2FuIG5vdCBiZSB1c2VkIGF0IHRoZSBzYW1lIHRpbWUuXG5cblxuICAgIHRleHRIZWxwZXIucmVuZGVyVGV4dCh0aGlzLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gUmVjdFRleHQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL21peGluL1JlY3RUZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX3V0aWwgPSByZXF1aXJlKFwiLi4vLi4vY29yZS91dGlsXCIpO1xuXG52YXIgcmV0cmlldmUyID0gX3V0aWwucmV0cmlldmUyO1xudmFyIHJldHJpZXZlMyA9IF91dGlsLnJldHJpZXZlMztcbnZhciBlYWNoID0gX3V0aWwuZWFjaDtcbnZhciBub3JtYWxpemVDc3NBcnJheSA9IF91dGlsLm5vcm1hbGl6ZUNzc0FycmF5O1xudmFyIGlzU3RyaW5nID0gX3V0aWwuaXNTdHJpbmc7XG52YXIgaXNPYmplY3QgPSBfdXRpbC5pc09iamVjdDtcblxudmFyIHRleHRDb250YWluID0gcmVxdWlyZShcIi4uLy4uL2NvbnRhaW4vdGV4dFwiKTtcblxudmFyIHJvdW5kUmVjdEhlbHBlciA9IHJlcXVpcmUoXCIuL3JvdW5kUmVjdFwiKTtcblxudmFyIGltYWdlSGVscGVyID0gcmVxdWlyZShcIi4vaW1hZ2VcIik7XG5cbi8vIFRPRE86IEhhdmUgbm90IHN1cHBvcnQgJ3N0YXJ0JywgJ2VuZCcgeWV0LlxudmFyIFZBTElEX1RFWFRfQUxJR04gPSB7XG4gIGxlZnQ6IDEsXG4gIHJpZ2h0OiAxLFxuICBjZW50ZXI6IDFcbn07XG52YXIgVkFMSURfVEVYVF9WRVJUSUNBTF9BTElHTiA9IHtcbiAgdG9wOiAxLFxuICBib3R0b206IDEsXG4gIG1pZGRsZTogMVxufTtcbi8qKlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfSBzdHlsZVxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gVGhlIGlucHV0IHN0eWxlLlxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRleHRTdHlsZShzdHlsZSkge1xuICBub3JtYWxpemVTdHlsZShzdHlsZSk7XG4gIGVhY2goc3R5bGUucmljaCwgbm9ybWFsaXplU3R5bGUpO1xuICByZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlKHN0eWxlKSB7XG4gIGlmIChzdHlsZSkge1xuICAgIHN0eWxlLmZvbnQgPSB0ZXh0Q29udGFpbi5tYWtlRm9udChzdHlsZSk7XG4gICAgdmFyIHRleHRBbGlnbiA9IHN0eWxlLnRleHRBbGlnbjtcbiAgICB0ZXh0QWxpZ24gPT09ICdtaWRkbGUnICYmICh0ZXh0QWxpZ24gPSAnY2VudGVyJyk7XG4gICAgc3R5bGUudGV4dEFsaWduID0gdGV4dEFsaWduID09IG51bGwgfHwgVkFMSURfVEVYVF9BTElHTlt0ZXh0QWxpZ25dID8gdGV4dEFsaWduIDogJ2xlZnQnOyAvLyBDb21wYXRpYmxlIHdpdGggdGV4dEJhc2VsaW5lLlxuXG4gICAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24gfHwgc3R5bGUudGV4dEJhc2VsaW5lO1xuICAgIHRleHRWZXJ0aWNhbEFsaWduID09PSAnY2VudGVyJyAmJiAodGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJyk7XG4gICAgc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24gPSB0ZXh0VmVydGljYWxBbGlnbiA9PSBudWxsIHx8IFZBTElEX1RFWFRfVkVSVElDQUxfQUxJR05bdGV4dFZlcnRpY2FsQWxpZ25dID8gdGV4dFZlcnRpY2FsQWxpZ24gOiAndG9wJztcbiAgICB2YXIgdGV4dFBhZGRpbmcgPSBzdHlsZS50ZXh0UGFkZGluZztcblxuICAgIGlmICh0ZXh0UGFkZGluZykge1xuICAgICAgc3R5bGUudGV4dFBhZGRpbmcgPSBub3JtYWxpemVDc3NBcnJheShzdHlsZS50ZXh0UGFkZGluZyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IHN0eWxlXG4gKiBAcGFyYW0ge09iamVjdHxib29sZWFufSBbcmVjdF0ge3gsIHksIHdpZHRoLCBoZWlnaHR9XG4gKiAgICAgICAgICAgICAgICAgIElmIHNldCBmYWxzZSwgcmVjdCB0ZXh0IGlzIG5vdCB1c2VkLlxuICovXG5cblxuZnVuY3Rpb24gcmVuZGVyVGV4dChob3N0RWwsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QpIHtcbiAgc3R5bGUucmljaCA/IHJlbmRlclJpY2hUZXh0KGhvc3RFbCwgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCkgOiByZW5kZXJQbGFpblRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0KTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyUGxhaW5UZXh0KGhvc3RFbCwgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCkge1xuICB2YXIgZm9udCA9IHNldEN0eChjdHgsICdmb250Jywgc3R5bGUuZm9udCB8fCB0ZXh0Q29udGFpbi5ERUZBVUxUX0ZPTlQpO1xuICB2YXIgdGV4dFBhZGRpbmcgPSBzdHlsZS50ZXh0UGFkZGluZztcbiAgdmFyIGNvbnRlbnRCbG9jayA9IGhvc3RFbC5fX3RleHRDb3RlbnRCbG9jaztcblxuICBpZiAoIWNvbnRlbnRCbG9jayB8fCBob3N0RWwuX19kaXJ0eSkge1xuICAgIGNvbnRlbnRCbG9jayA9IGhvc3RFbC5fX3RleHRDb3RlbnRCbG9jayA9IHRleHRDb250YWluLnBhcnNlUGxhaW5UZXh0KHRleHQsIGZvbnQsIHRleHRQYWRkaW5nLCBzdHlsZS50cnVuY2F0ZSk7XG4gIH1cblxuICB2YXIgb3V0ZXJIZWlnaHQgPSBjb250ZW50QmxvY2sub3V0ZXJIZWlnaHQ7XG4gIHZhciB0ZXh0TGluZXMgPSBjb250ZW50QmxvY2subGluZXM7XG4gIHZhciBsaW5lSGVpZ2h0ID0gY29udGVudEJsb2NrLmxpbmVIZWlnaHQ7XG4gIHZhciBib3hQb3MgPSBnZXRCb3hQb3NpdGlvbihvdXRlckhlaWdodCwgc3R5bGUsIHJlY3QpO1xuICB2YXIgYmFzZVggPSBib3hQb3MuYmFzZVg7XG4gIHZhciBiYXNlWSA9IGJveFBvcy5iYXNlWTtcbiAgdmFyIHRleHRBbGlnbiA9IGJveFBvcy50ZXh0QWxpZ247XG4gIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IGJveFBvcy50ZXh0VmVydGljYWxBbGlnbjsgLy8gT3JpZ2luIG9mIHRleHRSb3RhdGlvbiBzaG91bGQgYmUgdGhlIGJhc2UgcG9pbnQgb2YgdGV4dCBkcmF3aW5nLlxuXG4gIGFwcGx5VGV4dFJvdGF0aW9uKGN0eCwgc3R5bGUsIHJlY3QsIGJhc2VYLCBiYXNlWSk7XG4gIHZhciBib3hZID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFkoYmFzZVksIG91dGVySGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbik7XG4gIHZhciB0ZXh0WCA9IGJhc2VYO1xuICB2YXIgdGV4dFkgPSBib3hZO1xuICB2YXIgbmVlZERyYXdCZyA9IG5lZWREcmF3QmFja2dyb3VuZChzdHlsZSk7XG5cbiAgaWYgKG5lZWREcmF3QmcgfHwgdGV4dFBhZGRpbmcpIHtcbiAgICAvLyBDb25zaWRlciBwZXJmb3JtYW5jZSwgZG8gbm90IGNhbGwgZ2V0VGV4dFdpZHRoIHV0aWwgbmVjZXNzYXJ5LlxuICAgIHZhciB0ZXh0V2lkdGggPSB0ZXh0Q29udGFpbi5nZXRXaWR0aCh0ZXh0LCBmb250KTtcbiAgICB2YXIgb3V0ZXJXaWR0aCA9IHRleHRXaWR0aDtcbiAgICB0ZXh0UGFkZGluZyAmJiAob3V0ZXJXaWR0aCArPSB0ZXh0UGFkZGluZ1sxXSArIHRleHRQYWRkaW5nWzNdKTtcbiAgICB2YXIgYm94WCA9IHRleHRDb250YWluLmFkanVzdFRleHRYKGJhc2VYLCBvdXRlcldpZHRoLCB0ZXh0QWxpZ24pO1xuICAgIG5lZWREcmF3QmcgJiYgZHJhd0JhY2tncm91bmQoaG9zdEVsLCBjdHgsIHN0eWxlLCBib3hYLCBib3hZLCBvdXRlcldpZHRoLCBvdXRlckhlaWdodCk7XG5cbiAgICBpZiAodGV4dFBhZGRpbmcpIHtcbiAgICAgIHRleHRYID0gZ2V0VGV4dFhGb3JQYWRkaW5nKGJhc2VYLCB0ZXh0QWxpZ24sIHRleHRQYWRkaW5nKTtcbiAgICAgIHRleHRZICs9IHRleHRQYWRkaW5nWzBdO1xuICAgIH1cbiAgfVxuXG4gIHNldEN0eChjdHgsICd0ZXh0QWxpZ24nLCB0ZXh0QWxpZ24gfHwgJ2xlZnQnKTsgLy8gRm9yY2UgYmFzZWxpbmUgdG8gYmUgXCJtaWRkbGVcIi4gT3RoZXJ3aXNlLCBpZiB1c2luZyBcInRvcFwiLCB0aGVcbiAgLy8gdGV4dCB3aWxsIG9mZnNldCBkb3dud2FyZCBhIGxpdHRsZSBiaXQgaW4gZm9udCBcIk1pY3Jvc29mdCBZYUhlaVwiLlxuXG4gIHNldEN0eChjdHgsICd0ZXh0QmFzZWxpbmUnLCAnbWlkZGxlJyk7IC8vIEFsd2F5cyBzZXQgc2hhZG93Qmx1ciBhbmQgc2hhZG93T2Zmc2V0IHRvIGF2b2lkIGxlYWsgZnJvbSBkaXNwbGF5YWJsZS5cblxuICBzZXRDdHgoY3R4LCAnc2hhZG93Qmx1cicsIHN0eWxlLnRleHRTaGFkb3dCbHVyIHx8IDApO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93Q29sb3InLCBzdHlsZS50ZXh0U2hhZG93Q29sb3IgfHwgJ3RyYW5zcGFyZW50Jyk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dPZmZzZXRYJywgc3R5bGUudGV4dFNoYWRvd09mZnNldFggfHwgMCk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dPZmZzZXRZJywgc3R5bGUudGV4dFNoYWRvd09mZnNldFkgfHwgMCk7IC8vIGB0ZXh0QmFzZWxpbmVgIGlzIHNldCBhcyAnbWlkZGxlJy5cblxuICB0ZXh0WSArPSBsaW5lSGVpZ2h0IC8gMjtcbiAgdmFyIHRleHRTdHJva2VXaWR0aCA9IHN0eWxlLnRleHRTdHJva2VXaWR0aDtcbiAgdmFyIHRleHRTdHJva2UgPSBnZXRTdHJva2Uoc3R5bGUudGV4dFN0cm9rZSwgdGV4dFN0cm9rZVdpZHRoKTtcbiAgdmFyIHRleHRGaWxsID0gZ2V0RmlsbChzdHlsZS50ZXh0RmlsbCk7XG5cbiAgaWYgKHRleHRTdHJva2UpIHtcbiAgICBzZXRDdHgoY3R4LCAnbGluZVdpZHRoJywgdGV4dFN0cm9rZVdpZHRoKTtcbiAgICBzZXRDdHgoY3R4LCAnc3Ryb2tlU3R5bGUnLCB0ZXh0U3Ryb2tlKTtcbiAgfVxuXG4gIGlmICh0ZXh0RmlsbCkge1xuICAgIHNldEN0eChjdHgsICdmaWxsU3R5bGUnLCB0ZXh0RmlsbCk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIEZpbGwgYWZ0ZXIgc3Ryb2tlIHNvIHRoZSBvdXRsaW5lIHdpbGwgbm90IGNvdmVyIHRoZSBtYWluIHBhcnQuXG4gICAgdGV4dFN0cm9rZSAmJiBjdHguc3Ryb2tlVGV4dCh0ZXh0TGluZXNbaV0sIHRleHRYLCB0ZXh0WSk7XG4gICAgdGV4dEZpbGwgJiYgY3R4LmZpbGxUZXh0KHRleHRMaW5lc1tpXSwgdGV4dFgsIHRleHRZKTtcbiAgICB0ZXh0WSArPSBsaW5lSGVpZ2h0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclJpY2hUZXh0KGhvc3RFbCwgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCkge1xuICB2YXIgY29udGVudEJsb2NrID0gaG9zdEVsLl9fdGV4dENvdGVudEJsb2NrO1xuXG4gIGlmICghY29udGVudEJsb2NrIHx8IGhvc3RFbC5fX2RpcnR5KSB7XG4gICAgY29udGVudEJsb2NrID0gaG9zdEVsLl9fdGV4dENvdGVudEJsb2NrID0gdGV4dENvbnRhaW4ucGFyc2VSaWNoVGV4dCh0ZXh0LCBzdHlsZSk7XG4gIH1cblxuICBkcmF3UmljaFRleHQoaG9zdEVsLCBjdHgsIGNvbnRlbnRCbG9jaywgc3R5bGUsIHJlY3QpO1xufVxuXG5mdW5jdGlvbiBkcmF3UmljaFRleHQoaG9zdEVsLCBjdHgsIGNvbnRlbnRCbG9jaywgc3R5bGUsIHJlY3QpIHtcbiAgdmFyIGNvbnRlbnRXaWR0aCA9IGNvbnRlbnRCbG9jay53aWR0aDtcbiAgdmFyIG91dGVyV2lkdGggPSBjb250ZW50QmxvY2sub3V0ZXJXaWR0aDtcbiAgdmFyIG91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLm91dGVySGVpZ2h0O1xuICB2YXIgdGV4dFBhZGRpbmcgPSBzdHlsZS50ZXh0UGFkZGluZztcbiAgdmFyIGJveFBvcyA9IGdldEJveFBvc2l0aW9uKG91dGVySGVpZ2h0LCBzdHlsZSwgcmVjdCk7XG4gIHZhciBiYXNlWCA9IGJveFBvcy5iYXNlWDtcbiAgdmFyIGJhc2VZID0gYm94UG9zLmJhc2VZO1xuICB2YXIgdGV4dEFsaWduID0gYm94UG9zLnRleHRBbGlnbjtcbiAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gYm94UG9zLnRleHRWZXJ0aWNhbEFsaWduOyAvLyBPcmlnaW4gb2YgdGV4dFJvdGF0aW9uIHNob3VsZCBiZSB0aGUgYmFzZSBwb2ludCBvZiB0ZXh0IGRyYXdpbmcuXG5cbiAgYXBwbHlUZXh0Um90YXRpb24oY3R4LCBzdHlsZSwgcmVjdCwgYmFzZVgsIGJhc2VZKTtcbiAgdmFyIGJveFggPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0WChiYXNlWCwgb3V0ZXJXaWR0aCwgdGV4dEFsaWduKTtcbiAgdmFyIGJveFkgPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0WShiYXNlWSwgb3V0ZXJIZWlnaHQsIHRleHRWZXJ0aWNhbEFsaWduKTtcbiAgdmFyIHhMZWZ0ID0gYm94WDtcbiAgdmFyIGxpbmVUb3AgPSBib3hZO1xuXG4gIGlmICh0ZXh0UGFkZGluZykge1xuICAgIHhMZWZ0ICs9IHRleHRQYWRkaW5nWzNdO1xuICAgIGxpbmVUb3AgKz0gdGV4dFBhZGRpbmdbMF07XG4gIH1cblxuICB2YXIgeFJpZ2h0ID0geExlZnQgKyBjb250ZW50V2lkdGg7XG4gIG5lZWREcmF3QmFja2dyb3VuZChzdHlsZSkgJiYgZHJhd0JhY2tncm91bmQoaG9zdEVsLCBjdHgsIHN0eWxlLCBib3hYLCBib3hZLCBvdXRlcldpZHRoLCBvdXRlckhlaWdodCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QmxvY2subGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGluZSA9IGNvbnRlbnRCbG9jay5saW5lc1tpXTtcbiAgICB2YXIgdG9rZW5zID0gbGluZS50b2tlbnM7XG4gICAgdmFyIHRva2VuQ291bnQgPSB0b2tlbnMubGVuZ3RoO1xuICAgIHZhciBsaW5lSGVpZ2h0ID0gbGluZS5saW5lSGVpZ2h0O1xuICAgIHZhciB1c2VkV2lkdGggPSBsaW5lLndpZHRoO1xuICAgIHZhciBsZWZ0SW5kZXggPSAwO1xuICAgIHZhciBsaW5lWExlZnQgPSB4TGVmdDtcbiAgICB2YXIgbGluZVhSaWdodCA9IHhSaWdodDtcbiAgICB2YXIgcmlnaHRJbmRleCA9IHRva2VuQ291bnQgLSAxO1xuICAgIHZhciB0b2tlbjtcblxuICAgIHdoaWxlIChsZWZ0SW5kZXggPCB0b2tlbkNvdW50ICYmICh0b2tlbiA9IHRva2Vuc1tsZWZ0SW5kZXhdLCAhdG9rZW4udGV4dEFsaWduIHx8IHRva2VuLnRleHRBbGlnbiA9PT0gJ2xlZnQnKSkge1xuICAgICAgcGxhY2VUb2tlbihob3N0RWwsIGN0eCwgdG9rZW4sIHN0eWxlLCBsaW5lSGVpZ2h0LCBsaW5lVG9wLCBsaW5lWExlZnQsICdsZWZ0Jyk7XG4gICAgICB1c2VkV2lkdGggLT0gdG9rZW4ud2lkdGg7XG4gICAgICBsaW5lWExlZnQgKz0gdG9rZW4ud2lkdGg7XG4gICAgICBsZWZ0SW5kZXgrKztcbiAgICB9XG5cbiAgICB3aGlsZSAocmlnaHRJbmRleCA+PSAwICYmICh0b2tlbiA9IHRva2Vuc1tyaWdodEluZGV4XSwgdG9rZW4udGV4dEFsaWduID09PSAncmlnaHQnKSkge1xuICAgICAgcGxhY2VUb2tlbihob3N0RWwsIGN0eCwgdG9rZW4sIHN0eWxlLCBsaW5lSGVpZ2h0LCBsaW5lVG9wLCBsaW5lWFJpZ2h0LCAncmlnaHQnKTtcbiAgICAgIHVzZWRXaWR0aCAtPSB0b2tlbi53aWR0aDtcbiAgICAgIGxpbmVYUmlnaHQgLT0gdG9rZW4ud2lkdGg7XG4gICAgICByaWdodEluZGV4LS07XG4gICAgfSAvLyBUaGUgb3RoZXIgdG9rZW5zIGFyZSBwbGFjZWQgYXMgdGV4dEFsaWduICdjZW50ZXInIGlmIHRoZXJlIGlzIGVub3VnaCBzcGFjZS5cblxuXG4gICAgbGluZVhMZWZ0ICs9IChjb250ZW50V2lkdGggLSAobGluZVhMZWZ0IC0geExlZnQpIC0gKHhSaWdodCAtIGxpbmVYUmlnaHQpIC0gdXNlZFdpZHRoKSAvIDI7XG5cbiAgICB3aGlsZSAobGVmdEluZGV4IDw9IHJpZ2h0SW5kZXgpIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2xlZnRJbmRleF07IC8vIENvbnNpZGVyIHdpZHRoIHNwZWNpZmllZCBieSB1c2VyLCB1c2UgJ2NlbnRlcicgcmF0aGVyIHRoYW4gJ2xlZnQnLlxuXG4gICAgICBwbGFjZVRva2VuKGhvc3RFbCwgY3R4LCB0b2tlbiwgc3R5bGUsIGxpbmVIZWlnaHQsIGxpbmVUb3AsIGxpbmVYTGVmdCArIHRva2VuLndpZHRoIC8gMiwgJ2NlbnRlcicpO1xuICAgICAgbGluZVhMZWZ0ICs9IHRva2VuLndpZHRoO1xuICAgICAgbGVmdEluZGV4Kys7XG4gICAgfVxuXG4gICAgbGluZVRvcCArPSBsaW5lSGVpZ2h0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VGV4dFJvdGF0aW9uKGN0eCwgc3R5bGUsIHJlY3QsIHgsIHkpIHtcbiAgLy8gdGV4dFJvdGF0aW9uIG9ubHkgYXBwbHkgaW4gUmVjdFRleHQuXG4gIGlmIChyZWN0ICYmIHN0eWxlLnRleHRSb3RhdGlvbikge1xuICAgIHZhciBvcmlnaW4gPSBzdHlsZS50ZXh0T3JpZ2luO1xuXG4gICAgaWYgKG9yaWdpbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHggPSByZWN0LndpZHRoIC8gMiArIHJlY3QueDtcbiAgICAgIHkgPSByZWN0LmhlaWdodCAvIDIgKyByZWN0Lnk7XG4gICAgfSBlbHNlIGlmIChvcmlnaW4pIHtcbiAgICAgIHggPSBvcmlnaW5bMF0gKyByZWN0Lng7XG4gICAgICB5ID0gb3JpZ2luWzFdICsgcmVjdC55O1xuICAgIH1cblxuICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7IC8vIFBvc2l0aXZlOiBhbnRpY2xvY2t3aXNlXG5cbiAgICBjdHgucm90YXRlKC1zdHlsZS50ZXh0Um90YXRpb24pO1xuICAgIGN0eC50cmFuc2xhdGUoLXgsIC15KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwbGFjZVRva2VuKGhvc3RFbCwgY3R4LCB0b2tlbiwgc3R5bGUsIGxpbmVIZWlnaHQsIGxpbmVUb3AsIHgsIHRleHRBbGlnbikge1xuICB2YXIgdG9rZW5TdHlsZSA9IHN0eWxlLnJpY2hbdG9rZW4uc3R5bGVOYW1lXSB8fCB7fTsgLy8gJ2N0eC50ZXh0QmFzZWxpbmUnIGlzIGFsd2F5cyBzZXQgYXMgJ21pZGRsZScsIGZvciBzYWtlIG9mXG4gIC8vIHRoZSBiaWFzIG9mIFwiTWljcm9zb2Z0IFlhSGVpXCIuXG5cbiAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gdG9rZW4udGV4dFZlcnRpY2FsQWxpZ247XG4gIHZhciB5ID0gbGluZVRvcCArIGxpbmVIZWlnaHQgLyAyO1xuXG4gIGlmICh0ZXh0VmVydGljYWxBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICB5ID0gbGluZVRvcCArIHRva2VuLmhlaWdodCAvIDI7XG4gIH0gZWxzZSBpZiAodGV4dFZlcnRpY2FsQWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgeSA9IGxpbmVUb3AgKyBsaW5lSGVpZ2h0IC0gdG9rZW4uaGVpZ2h0IC8gMjtcbiAgfVxuXG4gICF0b2tlbi5pc0xpbmVIb2xkZXIgJiYgbmVlZERyYXdCYWNrZ3JvdW5kKHRva2VuU3R5bGUpICYmIGRyYXdCYWNrZ3JvdW5kKGhvc3RFbCwgY3R4LCB0b2tlblN0eWxlLCB0ZXh0QWxpZ24gPT09ICdyaWdodCcgPyB4IC0gdG9rZW4ud2lkdGggOiB0ZXh0QWxpZ24gPT09ICdjZW50ZXInID8geCAtIHRva2VuLndpZHRoIC8gMiA6IHgsIHkgLSB0b2tlbi5oZWlnaHQgLyAyLCB0b2tlbi53aWR0aCwgdG9rZW4uaGVpZ2h0KTtcbiAgdmFyIHRleHRQYWRkaW5nID0gdG9rZW4udGV4dFBhZGRpbmc7XG5cbiAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgeCA9IGdldFRleHRYRm9yUGFkZGluZyh4LCB0ZXh0QWxpZ24sIHRleHRQYWRkaW5nKTtcbiAgICB5IC09IHRva2VuLmhlaWdodCAvIDIgLSB0ZXh0UGFkZGluZ1syXSAtIHRva2VuLnRleHRIZWlnaHQgLyAyO1xuICB9XG5cbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0JsdXInLCByZXRyaWV2ZTModG9rZW5TdHlsZS50ZXh0U2hhZG93Qmx1ciwgc3R5bGUudGV4dFNoYWRvd0JsdXIsIDApKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0NvbG9yJywgdG9rZW5TdHlsZS50ZXh0U2hhZG93Q29sb3IgfHwgc3R5bGUudGV4dFNoYWRvd0NvbG9yIHx8ICd0cmFuc3BhcmVudCcpO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WCcsIHJldHJpZXZlMyh0b2tlblN0eWxlLnRleHRTaGFkb3dPZmZzZXRYLCBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WCwgMCkpO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WScsIHJldHJpZXZlMyh0b2tlblN0eWxlLnRleHRTaGFkb3dPZmZzZXRZLCBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WSwgMCkpO1xuICBzZXRDdHgoY3R4LCAndGV4dEFsaWduJywgdGV4dEFsaWduKTsgLy8gRm9yY2UgYmFzZWxpbmUgdG8gYmUgXCJtaWRkbGVcIi4gT3RoZXJ3aXNlLCBpZiB1c2luZyBcInRvcFwiLCB0aGVcbiAgLy8gdGV4dCB3aWxsIG9mZnNldCBkb3dud2FyZCBhIGxpdHRsZSBiaXQgaW4gZm9udCBcIk1pY3Jvc29mdCBZYUhlaVwiLlxuXG4gIHNldEN0eChjdHgsICd0ZXh0QmFzZWxpbmUnLCAnbWlkZGxlJyk7XG4gIHNldEN0eChjdHgsICdmb250JywgdG9rZW4uZm9udCB8fCB0ZXh0Q29udGFpbi5ERUZBVUxUX0ZPTlQpO1xuICB2YXIgdGV4dFN0cm9rZSA9IGdldFN0cm9rZSh0b2tlblN0eWxlLnRleHRTdHJva2UgfHwgc3R5bGUudGV4dFN0cm9rZSwgdGV4dFN0cm9rZVdpZHRoKTtcbiAgdmFyIHRleHRGaWxsID0gZ2V0RmlsbCh0b2tlblN0eWxlLnRleHRGaWxsIHx8IHN0eWxlLnRleHRGaWxsKTtcbiAgdmFyIHRleHRTdHJva2VXaWR0aCA9IHJldHJpZXZlMih0b2tlblN0eWxlLnRleHRTdHJva2VXaWR0aCwgc3R5bGUudGV4dFN0cm9rZVdpZHRoKTsgLy8gRmlsbCBhZnRlciBzdHJva2Ugc28gdGhlIG91dGxpbmUgd2lsbCBub3QgY292ZXIgdGhlIG1haW4gcGFydC5cblxuICBpZiAodGV4dFN0cm9rZSkge1xuICAgIHNldEN0eChjdHgsICdsaW5lV2lkdGgnLCB0ZXh0U3Ryb2tlV2lkdGgpO1xuICAgIHNldEN0eChjdHgsICdzdHJva2VTdHlsZScsIHRleHRTdHJva2UpO1xuICAgIGN0eC5zdHJva2VUZXh0KHRva2VuLnRleHQsIHgsIHkpO1xuICB9XG5cbiAgaWYgKHRleHRGaWxsKSB7XG4gICAgc2V0Q3R4KGN0eCwgJ2ZpbGxTdHlsZScsIHRleHRGaWxsKTtcbiAgICBjdHguZmlsbFRleHQodG9rZW4udGV4dCwgeCwgeSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbmVlZERyYXdCYWNrZ3JvdW5kKHN0eWxlKSB7XG4gIHJldHVybiBzdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yIHx8IHN0eWxlLnRleHRCb3JkZXJXaWR0aCAmJiBzdHlsZS50ZXh0Qm9yZGVyQ29sb3I7XG59IC8vIHN0eWxlOiB7dGV4dEJhY2tncm91bmRDb2xvciwgdGV4dEJvcmRlcldpZHRoLCB0ZXh0Qm9yZGVyQ29sb3IsIHRleHRCb3JkZXJSYWRpdXN9XG4vLyBzaGFwZToge3gsIHksIHdpZHRoLCBoZWlnaHR9XG5cblxuZnVuY3Rpb24gZHJhd0JhY2tncm91bmQoaG9zdEVsLCBjdHgsIHN0eWxlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciB0ZXh0QmFja2dyb3VuZENvbG9yID0gc3R5bGUudGV4dEJhY2tncm91bmRDb2xvcjtcbiAgdmFyIHRleHRCb3JkZXJXaWR0aCA9IHN0eWxlLnRleHRCb3JkZXJXaWR0aDtcbiAgdmFyIHRleHRCb3JkZXJDb2xvciA9IHN0eWxlLnRleHRCb3JkZXJDb2xvcjtcbiAgdmFyIGlzUGxhaW5CZyA9IGlzU3RyaW5nKHRleHRCYWNrZ3JvdW5kQ29sb3IpO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93Qmx1cicsIHN0eWxlLnRleHRCb3hTaGFkb3dCbHVyIHx8IDApO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93Q29sb3InLCBzdHlsZS50ZXh0Qm94U2hhZG93Q29sb3IgfHwgJ3RyYW5zcGFyZW50Jyk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dPZmZzZXRYJywgc3R5bGUudGV4dEJveFNoYWRvd09mZnNldFggfHwgMCk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dPZmZzZXRZJywgc3R5bGUudGV4dEJveFNoYWRvd09mZnNldFkgfHwgMCk7XG5cbiAgaWYgKGlzUGxhaW5CZyB8fCB0ZXh0Qm9yZGVyV2lkdGggJiYgdGV4dEJvcmRlckNvbG9yKSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIHZhciB0ZXh0Qm9yZGVyUmFkaXVzID0gc3R5bGUudGV4dEJvcmRlclJhZGl1cztcblxuICAgIGlmICghdGV4dEJvcmRlclJhZGl1cykge1xuICAgICAgY3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvdW5kUmVjdEhlbHBlci5idWlsZFBhdGgoY3R4LCB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHI6IHRleHRCb3JkZXJSYWRpdXNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgfVxuXG4gIGlmIChpc1BsYWluQmcpIHtcbiAgICBzZXRDdHgoY3R4LCAnZmlsbFN0eWxlJywgdGV4dEJhY2tncm91bmRDb2xvcik7XG4gICAgY3R4LmZpbGwoKTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh0ZXh0QmFja2dyb3VuZENvbG9yKSkge1xuICAgIHZhciBpbWFnZSA9IHRleHRCYWNrZ3JvdW5kQ29sb3IuaW1hZ2U7XG4gICAgaW1hZ2UgPSBpbWFnZUhlbHBlci5jcmVhdGVPclVwZGF0ZUltYWdlKGltYWdlLCBudWxsLCBob3N0RWwsIG9uQmdJbWFnZUxvYWRlZCwgdGV4dEJhY2tncm91bmRDb2xvcik7XG5cbiAgICBpZiAoaW1hZ2UgJiYgaW1hZ2VIZWxwZXIuaXNJbWFnZVJlYWR5KGltYWdlKSkge1xuICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRleHRCb3JkZXJXaWR0aCAmJiB0ZXh0Qm9yZGVyQ29sb3IpIHtcbiAgICBzZXRDdHgoY3R4LCAnbGluZVdpZHRoJywgdGV4dEJvcmRlcldpZHRoKTtcbiAgICBzZXRDdHgoY3R4LCAnc3Ryb2tlU3R5bGUnLCB0ZXh0Qm9yZGVyQ29sb3IpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkJnSW1hZ2VMb2FkZWQoaW1hZ2UsIHRleHRCYWNrZ3JvdW5kQ29sb3IpIHtcbiAgLy8gUmVwbGFjZSBpbWFnZSwgc28gdGhhdCBgY29udGFpbi90ZXh0LmpzI3BhcnNlUmljaFRleHRgXG4gIC8vIHdpbGwgZ2V0IGNvcnJlY3QgcmVzdWx0IGluIG5leHQgdGljay5cbiAgdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZSA9IGltYWdlO1xufVxuXG5mdW5jdGlvbiBnZXRCb3hQb3NpdGlvbihibG9ja0hlaWh0LCBzdHlsZSwgcmVjdCkge1xuICB2YXIgYmFzZVggPSBzdHlsZS54IHx8IDA7XG4gIHZhciBiYXNlWSA9IHN0eWxlLnkgfHwgMDtcbiAgdmFyIHRleHRBbGlnbiA9IHN0eWxlLnRleHRBbGlnbjtcbiAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gc3R5bGUudGV4dFZlcnRpY2FsQWxpZ247IC8vIFRleHQgcG9zaXRpb24gcmVwcmVzZW50ZWQgYnkgY29vcmRcblxuICBpZiAocmVjdCkge1xuICAgIHZhciB0ZXh0UG9zaXRpb24gPSBzdHlsZS50ZXh0UG9zaXRpb247XG5cbiAgICBpZiAodGV4dFBvc2l0aW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIC8vIFBlcmNlbnRcbiAgICAgIGJhc2VYID0gcmVjdC54ICsgcGFyc2VQZXJjZW50KHRleHRQb3NpdGlvblswXSwgcmVjdC53aWR0aCk7XG4gICAgICBiYXNlWSA9IHJlY3QueSArIHBhcnNlUGVyY2VudCh0ZXh0UG9zaXRpb25bMV0sIHJlY3QuaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlcyA9IHRleHRDb250YWluLmFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCh0ZXh0UG9zaXRpb24sIHJlY3QsIHN0eWxlLnRleHREaXN0YW5jZSk7XG4gICAgICBiYXNlWCA9IHJlcy54O1xuICAgICAgYmFzZVkgPSByZXMueTsgLy8gRGVmYXVsdCBhbGlnbiBhbmQgYmFzZWxpbmUgd2hlbiBoYXMgdGV4dFBvc2l0aW9uXG5cbiAgICAgIHRleHRBbGlnbiA9IHRleHRBbGlnbiB8fCByZXMudGV4dEFsaWduO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSB0ZXh0VmVydGljYWxBbGlnbiB8fCByZXMudGV4dFZlcnRpY2FsQWxpZ247XG4gICAgfSAvLyB0ZXh0T2Zmc2V0IGlzIG9ubHkgc3VwcG9ydCBpbiBSZWN0VGV4dCwgb3RoZXJ3aXNlXG4gICAgLy8gd2UgaGF2ZSB0byBhZGp1c3QgYm91bmRpbmdSZWN0IGZvciB0ZXh0T2Zmc2V0LlxuXG5cbiAgICB2YXIgdGV4dE9mZnNldCA9IHN0eWxlLnRleHRPZmZzZXQ7XG5cbiAgICBpZiAodGV4dE9mZnNldCkge1xuICAgICAgYmFzZVggKz0gdGV4dE9mZnNldFswXTtcbiAgICAgIGJhc2VZICs9IHRleHRPZmZzZXRbMV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiYXNlWDogYmFzZVgsXG4gICAgYmFzZVk6IGJhc2VZLFxuICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgIHRleHRWZXJ0aWNhbEFsaWduOiB0ZXh0VmVydGljYWxBbGlnblxuICB9O1xufVxuXG5mdW5jdGlvbiBzZXRDdHgoY3R4LCBwcm9wLCB2YWx1ZSkge1xuICAvLyBGSVhNRSA/Pz8gcGVyZm9ybWFuY2UgdHJ5XG4gIC8vIGlmIChjdHguX19jdXJyZW50VmFsdWVzW3Byb3BdICE9PSB2YWx1ZSkge1xuICAvLyBjdHhbcHJvcF0gPSBjdHguX19jdXJyZW50VmFsdWVzW3Byb3BdID0gdmFsdWU7XG4gIGN0eFtwcm9wXSA9IHZhbHVlOyAvLyB9XG5cbiAgcmV0dXJuIGN0eFtwcm9wXTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJva2VdIElmIHNwZWNpZmllZCwgZG8gbm90IGNoZWNrIHN0eWxlLnRleHRTdHJva2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xpbmVXaWR0aF0gSWYgc3BlY2lmaWVkLCBkbyBub3QgY2hlY2sgc3R5bGUudGV4dFN0cm9rZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHlsZVxuICovXG5cblxuZnVuY3Rpb24gZ2V0U3Ryb2tlKHN0cm9rZSwgbGluZVdpZHRoKSB7XG4gIHJldHVybiBzdHJva2UgPT0gbnVsbCB8fCBsaW5lV2lkdGggPD0gMCB8fCBzdHJva2UgPT09ICd0cmFuc3BhcmVudCcgfHwgc3Ryb2tlID09PSAnbm9uZScgPyBudWxsIC8vIFRPRE8gcGF0dGVybiBhbmQgZ3JhZGllbnQ/XG4gIDogc3Ryb2tlLmltYWdlIHx8IHN0cm9rZS5jb2xvclN0b3BzID8gJyMwMDAnIDogc3Ryb2tlO1xufVxuXG5mdW5jdGlvbiBnZXRGaWxsKGZpbGwpIHtcbiAgcmV0dXJuIGZpbGwgPT0gbnVsbCB8fCBmaWxsID09PSAnbm9uZScgPyBudWxsIC8vIFRPRE8gcGF0dGVybiBhbmQgZ3JhZGllbnQ/XG4gIDogZmlsbC5pbWFnZSB8fCBmaWxsLmNvbG9yU3RvcHMgPyAnIzAwMCcgOiBmaWxsO1xufVxuXG5mdW5jdGlvbiBwYXJzZVBlcmNlbnQodmFsdWUsIG1heFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHZhbHVlLmxhc3RJbmRleE9mKCclJykgPj0gMCkge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwICogbWF4VmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0WEZvclBhZGRpbmcoeCwgdGV4dEFsaWduLCB0ZXh0UGFkZGluZykge1xuICByZXR1cm4gdGV4dEFsaWduID09PSAncmlnaHQnID8geCAtIHRleHRQYWRkaW5nWzFdIDogdGV4dEFsaWduID09PSAnY2VudGVyJyA/IHggKyB0ZXh0UGFkZGluZ1szXSAvIDIgLSB0ZXh0UGFkZGluZ1sxXSAvIDIgOiB4ICsgdGV4dFBhZGRpbmdbM107XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0eWxlfSBzdHlsZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIG5lZWREcmF3VGV4dCh0ZXh0LCBzdHlsZSkge1xuICByZXR1cm4gdGV4dCAhPSBudWxsICYmICh0ZXh0IHx8IHN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3IgfHwgc3R5bGUudGV4dEJvcmRlcldpZHRoICYmIHN0eWxlLnRleHRCb3JkZXJDb2xvciB8fCBzdHlsZS50ZXh0UGFkZGluZyk7XG59XG5cbmV4cG9ydHMubm9ybWFsaXplVGV4dFN0eWxlID0gbm9ybWFsaXplVGV4dFN0eWxlO1xuZXhwb3J0cy5yZW5kZXJUZXh0ID0gcmVuZGVyVGV4dDtcbmV4cG9ydHMuZ2V0U3Ryb2tlID0gZ2V0U3Ryb2tlO1xuZXhwb3J0cy5nZXRGaWxsID0gZ2V0RmlsbDtcbmV4cG9ydHMubmVlZERyYXdUZXh0ID0gbmVlZERyYXdUZXh0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci90ZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4uL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgaW1hZ2VIZWxwZXIgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9oZWxwZXIvaW1hZ2VcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBnZXRDb250ZXh0ID0gX3V0aWwuZ2V0Q29udGV4dDtcbnZhciBleHRlbmQgPSBfdXRpbC5leHRlbmQ7XG52YXIgcmV0cmlldmUyID0gX3V0aWwucmV0cmlldmUyO1xudmFyIHJldHJpZXZlMyA9IF91dGlsLnJldHJpZXZlMztcbnZhciB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xudmFyIHRleHRXaWR0aENhY2hlQ291bnRlciA9IDA7XG52YXIgVEVYVF9DQUNIRV9NQVggPSA1MDAwO1xudmFyIFNUWUxFX1JFRyA9IC9cXHsoW2EtekEtWjAtOV9dKylcXHwoW159XSopXFx9L2c7XG52YXIgREVGQVVMVF9GT05UID0gJzEycHggc2Fucy1zZXJpZic7IC8vIEF2b2lkIGFzc2lnbiB0byBhbiBleHBvcnRlZCB2YXJpYWJsZSwgZm9yIHRyYW5zZm9ybWluZyB0byBjanMuXG5cbnZhciBtZXRob2RzID0ge307XG5cbmZ1bmN0aW9uICRvdmVycmlkZShuYW1lLCBmbikge1xuICBtZXRob2RzW25hbWVdID0gZm47XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHJldHVybiB7bnVtYmVyfSB3aWR0aFxuICovXG5cblxuZnVuY3Rpb24gZ2V0V2lkdGgodGV4dCwgZm9udCkge1xuICBmb250ID0gZm9udCB8fCBERUZBVUxUX0ZPTlQ7XG4gIHZhciBrZXkgPSB0ZXh0ICsgJzonICsgZm9udDtcblxuICBpZiAodGV4dFdpZHRoQ2FjaGVba2V5XSkge1xuICAgIHJldHVybiB0ZXh0V2lkdGhDYWNoZVtrZXldO1xuICB9XG5cbiAgdmFyIHRleHRMaW5lcyA9ICh0ZXh0ICsgJycpLnNwbGl0KCdcXG4nKTtcbiAgdmFyIHdpZHRoID0gMDtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHRleHRMaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAvLyB0ZXh0Q29udGFpbi5tZWFzdXJlVGV4dCBtYXkgYmUgb3ZlcnJpZGVkIGluIFNWRyBvciBWTUxcbiAgICB3aWR0aCA9IE1hdGgubWF4KG1lYXN1cmVUZXh0KHRleHRMaW5lc1tpXSwgZm9udCkud2lkdGgsIHdpZHRoKTtcbiAgfVxuXG4gIGlmICh0ZXh0V2lkdGhDYWNoZUNvdW50ZXIgPiBURVhUX0NBQ0hFX01BWCkge1xuICAgIHRleHRXaWR0aENhY2hlQ291bnRlciA9IDA7XG4gICAgdGV4dFdpZHRoQ2FjaGUgPSB7fTtcbiAgfVxuXG4gIHRleHRXaWR0aENhY2hlQ291bnRlcisrO1xuICB0ZXh0V2lkdGhDYWNoZVtrZXldID0gd2lkdGg7XG4gIHJldHVybiB3aWR0aDtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcGFyYW0ge3N0cmluZ30gW3RleHRBbGlnbj0nbGVmdCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW3RleHRWZXJ0aWNhbEFsaWduPSd0b3AnXVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW3RleHRQYWRkaW5nXVxuICogQHBhcmFtIHtPYmplY3R9IFtyaWNoXVxuICogQHBhcmFtIHtPYmplY3R9IFt0cnVuY2F0ZV1cbiAqIEByZXR1cm4ge09iamVjdH0ge3gsIHksIHdpZHRoLCBoZWlnaHQsIGxpbmVIZWlnaHR9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ1JlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHJpY2gsIHRydW5jYXRlKSB7XG4gIHJldHVybiByaWNoID8gZ2V0UmljaFRleHRSZWN0KHRleHQsIGZvbnQsIHRleHRBbGlnbiwgdGV4dFZlcnRpY2FsQWxpZ24sIHRleHRQYWRkaW5nLCByaWNoLCB0cnVuY2F0ZSkgOiBnZXRQbGFpblRleHRSZWN0KHRleHQsIGZvbnQsIHRleHRBbGlnbiwgdGV4dFZlcnRpY2FsQWxpZ24sIHRleHRQYWRkaW5nLCB0cnVuY2F0ZSk7XG59XG5cbmZ1bmN0aW9uIGdldFBsYWluVGV4dFJlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHRydW5jYXRlKSB7XG4gIHZhciBjb250ZW50QmxvY2sgPSBwYXJzZVBsYWluVGV4dCh0ZXh0LCBmb250LCB0ZXh0UGFkZGluZywgdHJ1bmNhdGUpO1xuICB2YXIgb3V0ZXJXaWR0aCA9IGdldFdpZHRoKHRleHQsIGZvbnQpO1xuXG4gIGlmICh0ZXh0UGFkZGluZykge1xuICAgIG91dGVyV2lkdGggKz0gdGV4dFBhZGRpbmdbMV0gKyB0ZXh0UGFkZGluZ1szXTtcbiAgfVxuXG4gIHZhciBvdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5vdXRlckhlaWdodDtcbiAgdmFyIHggPSBhZGp1c3RUZXh0WCgwLCBvdXRlcldpZHRoLCB0ZXh0QWxpZ24pO1xuICB2YXIgeSA9IGFkanVzdFRleHRZKDAsIG91dGVySGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbik7XG4gIHZhciByZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCh4LCB5LCBvdXRlcldpZHRoLCBvdXRlckhlaWdodCk7XG4gIHJlY3QubGluZUhlaWdodCA9IGNvbnRlbnRCbG9jay5saW5lSGVpZ2h0O1xuICByZXR1cm4gcmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0UmljaFRleHRSZWN0KHRleHQsIGZvbnQsIHRleHRBbGlnbiwgdGV4dFZlcnRpY2FsQWxpZ24sIHRleHRQYWRkaW5nLCByaWNoLCB0cnVuY2F0ZSkge1xuICB2YXIgY29udGVudEJsb2NrID0gcGFyc2VSaWNoVGV4dCh0ZXh0LCB7XG4gICAgcmljaDogcmljaCxcbiAgICB0cnVuY2F0ZTogdHJ1bmNhdGUsXG4gICAgZm9udDogZm9udCxcbiAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICB0ZXh0UGFkZGluZzogdGV4dFBhZGRpbmdcbiAgfSk7XG4gIHZhciBvdXRlcldpZHRoID0gY29udGVudEJsb2NrLm91dGVyV2lkdGg7XG4gIHZhciBvdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5vdXRlckhlaWdodDtcbiAgdmFyIHggPSBhZGp1c3RUZXh0WCgwLCBvdXRlcldpZHRoLCB0ZXh0QWxpZ24pO1xuICB2YXIgeSA9IGFkanVzdFRleHRZKDAsIG91dGVySGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbik7XG4gIHJldHVybiBuZXcgQm91bmRpbmdSZWN0KHgsIHksIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0KTtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0QWxpZ249J2xlZnQnXVxuICogQHJldHVybiB7bnVtYmVyfSBBZGp1c3RlZCB4LlxuICovXG5cblxuZnVuY3Rpb24gYWRqdXN0VGV4dFgoeCwgd2lkdGgsIHRleHRBbGlnbikge1xuICAvLyBGSVhNRSBSaWdodCB0byBsZWZ0IGxhbmd1YWdlXG4gIGlmICh0ZXh0QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IHdpZHRoO1xuICB9IGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09IHdpZHRoIC8gMjtcbiAgfVxuXG4gIHJldHVybiB4O1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0VmVydGljYWxBbGlnbj0ndG9wJ11cbiAqIEByZXR1cm4ge251bWJlcn0gQWRqdXN0ZWQgeS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGFkanVzdFRleHRZKHksIGhlaWdodCwgdGV4dFZlcnRpY2FsQWxpZ24pIHtcbiAgaWYgKHRleHRWZXJ0aWNhbEFsaWduID09PSAnbWlkZGxlJykge1xuICAgIHkgLT0gaGVpZ2h0IC8gMjtcbiAgfSBlbHNlIGlmICh0ZXh0VmVydGljYWxBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICB5IC09IGhlaWdodDtcbiAgfVxuXG4gIHJldHVybiB5O1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0aXJuZ30gdGV4dFBvc2l0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjdCB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICogQHJldHVybiB7T2JqZWN0fSB7eCwgeSwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCh0ZXh0UG9zaXRpb24sIHJlY3QsIGRpc3RhbmNlKSB7XG4gIHZhciB4ID0gcmVjdC54O1xuICB2YXIgeSA9IHJlY3QueTtcbiAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICB2YXIgd2lkdGggPSByZWN0LndpZHRoO1xuICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gIHZhciB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9ICd0b3AnO1xuXG4gIHN3aXRjaCAodGV4dFBvc2l0aW9uKSB7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICB4IC09IGRpc3RhbmNlO1xuICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHggKz0gZGlzdGFuY2UgKyB3aWR0aDtcbiAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RvcCc6XG4gICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgIHkgLT0gZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgIHkgKz0gaGVpZ2h0ICsgZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlJzpcbiAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVMZWZ0JzpcbiAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVSaWdodCc6XG4gICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlVG9wJzpcbiAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgeSArPSBkaXN0YW5jZTtcbiAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVCb3R0b20nOlxuICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICB5ICs9IGhlaWdodCAtIGRpc3RhbmNlO1xuICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVUb3BMZWZ0JzpcbiAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGRpc3RhbmNlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVUb3BSaWdodCc6XG4gICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGRpc3RhbmNlO1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlQm90dG9tTGVmdCc6XG4gICAgICB4ICs9IGRpc3RhbmNlO1xuICAgICAgeSArPSBoZWlnaHQgLSBkaXN0YW5jZTtcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZUJvdHRvbVJpZ2h0JzpcbiAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gaGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRWZXJ0aWNhbEFsaWduXG4gIH07XG59XG4vKipcbiAqIFNob3cgZWxsaXBzaXMgaWYgb3ZlcmZsb3cuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvbnRhaW5lcldpZHRoXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZvbnRcbiAqIEBwYXJhbSAge251bWJlcn0gW2VsbGlwc2lzPScuLi4nXVxuICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMubWF4SXRlcmF0aW9ucz0zXVxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5taW5DaGFyPTBdIElmIHRydW5jYXRlIHJlc3VsdCBhcmUgbGVzc1xuICogICAgICAgICAgICAgICAgICB0aGVuIG1pbkNoYXIsIGVsbGlwc2lzIHdpbGwgbm90IHNob3csIHdoaWNoIGlzXG4gKiAgICAgICAgICAgICAgICAgIGJldHRlciBmb3IgdXNlciBoaW50IGluIHNvbWUgY2FzZXMuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLnBsYWNlaG9sZGVyPScnXSBXaGVuIGFsbCB0cnVuY2F0ZWQsIHVzZSB0aGUgcGxhY2Vob2xkZXIuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiB0cnVuY2F0ZVRleHQodGV4dCwgY29udGFpbmVyV2lkdGgsIGZvbnQsIGVsbGlwc2lzLCBvcHRpb25zKSB7XG4gIGlmICghY29udGFpbmVyV2lkdGgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgdGV4dExpbmVzID0gKHRleHQgKyAnJykuc3BsaXQoJ1xcbicpO1xuICBvcHRpb25zID0gcHJlcGFyZVRydW5jYXRlT3B0aW9ucyhjb250YWluZXJXaWR0aCwgZm9udCwgZWxsaXBzaXMsIG9wdGlvbnMpOyAvLyBGSVhNRVxuICAvLyBJdCBpcyBub3QgYXBwcm9wcmlhdGUgdGhhdCBldmVyeSBsaW5lIGhhcyAnLi4uJyB3aGVuIHRydW5jYXRlIG11bHRpcGxlIGxpbmVzLlxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB0ZXh0TGluZXNbaV0gPSB0cnVuY2F0ZVNpbmdsZUxpbmUodGV4dExpbmVzW2ldLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB0ZXh0TGluZXMuam9pbignXFxuJyk7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUcnVuY2F0ZU9wdGlvbnMoY29udGFpbmVyV2lkdGgsIGZvbnQsIGVsbGlwc2lzLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICBvcHRpb25zLmZvbnQgPSBmb250O1xuICB2YXIgZWxsaXBzaXMgPSByZXRyaWV2ZTIoZWxsaXBzaXMsICcuLi4nKTtcbiAgb3B0aW9ucy5tYXhJdGVyYXRpb25zID0gcmV0cmlldmUyKG9wdGlvbnMubWF4SXRlcmF0aW9ucywgMik7XG4gIHZhciBtaW5DaGFyID0gb3B0aW9ucy5taW5DaGFyID0gcmV0cmlldmUyKG9wdGlvbnMubWluQ2hhciwgMCk7IC8vIEZJWE1FXG4gIC8vIE90aGVyIGxhbmd1YWdlcz9cblxuICBvcHRpb25zLmNuQ2hhcldpZHRoID0gZ2V0V2lkdGgoJ+WbvScsIGZvbnQpOyAvLyBGSVhNRVxuICAvLyBDb25zaWRlciBwcm9wb3J0aW9uYWwgZm9udD9cblxuICB2YXIgYXNjQ2hhcldpZHRoID0gb3B0aW9ucy5hc2NDaGFyV2lkdGggPSBnZXRXaWR0aCgnYScsIGZvbnQpO1xuICBvcHRpb25zLnBsYWNlaG9sZGVyID0gcmV0cmlldmUyKG9wdGlvbnMucGxhY2Vob2xkZXIsICcnKTsgLy8gRXhhbXBsZSAxOiBtaW5DaGFyOiAzLCB0ZXh0OiAnYXNkZnp4Y3YnLCB0cnVuY2F0ZSByZXN1bHQ6ICdhc2RmJywgYnV0IG5vdDogJ2EuLi4nLlxuICAvLyBFeGFtcGxlIDI6IG1pbkNoYXI6IDMsIHRleHQ6ICfnu7TluqYnLCB0cnVuY2F0ZSByZXN1bHQ6ICfnu7QnLCBidXQgbm90OiAnLi4uJy5cblxuICB2YXIgY29udGVudFdpZHRoID0gY29udGFpbmVyV2lkdGggPSBNYXRoLm1heCgwLCBjb250YWluZXJXaWR0aCAtIDEpOyAvLyBSZXNlcnZlIHNvbWUgZ2FwLlxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWluQ2hhciAmJiBjb250ZW50V2lkdGggPj0gYXNjQ2hhcldpZHRoOyBpKyspIHtcbiAgICBjb250ZW50V2lkdGggLT0gYXNjQ2hhcldpZHRoO1xuICB9XG5cbiAgdmFyIGVsbGlwc2lzV2lkdGggPSBnZXRXaWR0aChlbGxpcHNpcyk7XG5cbiAgaWYgKGVsbGlwc2lzV2lkdGggPiBjb250ZW50V2lkdGgpIHtcbiAgICBlbGxpcHNpcyA9ICcnO1xuICAgIGVsbGlwc2lzV2lkdGggPSAwO1xuICB9XG5cbiAgY29udGVudFdpZHRoID0gY29udGFpbmVyV2lkdGggLSBlbGxpcHNpc1dpZHRoO1xuICBvcHRpb25zLmVsbGlwc2lzID0gZWxsaXBzaXM7XG4gIG9wdGlvbnMuZWxsaXBzaXNXaWR0aCA9IGVsbGlwc2lzV2lkdGg7XG4gIG9wdGlvbnMuY29udGVudFdpZHRoID0gY29udGVudFdpZHRoO1xuICBvcHRpb25zLmNvbnRhaW5lcldpZHRoID0gY29udGFpbmVyV2lkdGg7XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiB0cnVuY2F0ZVNpbmdsZUxpbmUodGV4dExpbmUsIG9wdGlvbnMpIHtcbiAgdmFyIGNvbnRhaW5lcldpZHRoID0gb3B0aW9ucy5jb250YWluZXJXaWR0aDtcbiAgdmFyIGZvbnQgPSBvcHRpb25zLmZvbnQ7XG4gIHZhciBjb250ZW50V2lkdGggPSBvcHRpb25zLmNvbnRlbnRXaWR0aDtcblxuICBpZiAoIWNvbnRhaW5lcldpZHRoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIGxpbmVXaWR0aCA9IGdldFdpZHRoKHRleHRMaW5lLCBmb250KTtcblxuICBpZiAobGluZVdpZHRoIDw9IGNvbnRhaW5lcldpZHRoKSB7XG4gICAgcmV0dXJuIHRleHRMaW5lO1xuICB9XG5cbiAgZm9yICh2YXIgaiA9IDA7OyBqKyspIHtcbiAgICBpZiAobGluZVdpZHRoIDw9IGNvbnRlbnRXaWR0aCB8fCBqID49IG9wdGlvbnMubWF4SXRlcmF0aW9ucykge1xuICAgICAgdGV4dExpbmUgKz0gb3B0aW9ucy5lbGxpcHNpcztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBzdWJMZW5ndGggPSBqID09PSAwID8gZXN0aW1hdGVMZW5ndGgodGV4dExpbmUsIGNvbnRlbnRXaWR0aCwgb3B0aW9ucy5hc2NDaGFyV2lkdGgsIG9wdGlvbnMuY25DaGFyV2lkdGgpIDogbGluZVdpZHRoID4gMCA/IE1hdGguZmxvb3IodGV4dExpbmUubGVuZ3RoICogY29udGVudFdpZHRoIC8gbGluZVdpZHRoKSA6IDA7XG4gICAgdGV4dExpbmUgPSB0ZXh0TGluZS5zdWJzdHIoMCwgc3ViTGVuZ3RoKTtcbiAgICBsaW5lV2lkdGggPSBnZXRXaWR0aCh0ZXh0TGluZSwgZm9udCk7XG4gIH1cblxuICBpZiAodGV4dExpbmUgPT09ICcnKSB7XG4gICAgdGV4dExpbmUgPSBvcHRpb25zLnBsYWNlaG9sZGVyO1xuICB9XG5cbiAgcmV0dXJuIHRleHRMaW5lO1xufVxuXG5mdW5jdGlvbiBlc3RpbWF0ZUxlbmd0aCh0ZXh0LCBjb250ZW50V2lkdGgsIGFzY0NoYXJXaWR0aCwgY25DaGFyV2lkdGgpIHtcbiAgdmFyIHdpZHRoID0gMDtcbiAgdmFyIGkgPSAwO1xuXG4gIGZvciAodmFyIGxlbiA9IHRleHQubGVuZ3RoOyBpIDwgbGVuICYmIHdpZHRoIDwgY29udGVudFdpZHRoOyBpKyspIHtcbiAgICB2YXIgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgd2lkdGggKz0gMCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSAxMjcgPyBhc2NDaGFyV2lkdGggOiBjbkNoYXJXaWR0aDtcbiAgfVxuXG4gIHJldHVybiBpO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHJldHVybiB7bnVtYmVyfSBsaW5lIGhlaWdodFxuICovXG5cblxuZnVuY3Rpb24gZ2V0TGluZUhlaWdodChmb250KSB7XG4gIC8vIEZJWE1FIEEgcm91Z2ggYXBwcm9hY2guXG4gIHJldHVybiBnZXRXaWR0aCgn5Zu9JywgZm9udCk7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHJldHVybiB7T2JqZWN0fSB3aWR0aFxuICovXG5cblxuZnVuY3Rpb24gbWVhc3VyZVRleHQodGV4dCwgZm9udCkge1xuICByZXR1cm4gbWV0aG9kcy5tZWFzdXJlVGV4dCh0ZXh0LCBmb250KTtcbn0gLy8gQXZvaWQgYXNzaWduIHRvIGFuIGV4cG9ydGVkIHZhcmlhYmxlLCBmb3IgdHJhbnNmb3JtaW5nIHRvIGNqcy5cblxuXG5tZXRob2RzLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGZvbnQpIHtcbiAgdmFyIGN0eCA9IGdldENvbnRleHQoKTtcbiAgY3R4LmZvbnQgPSBmb250IHx8IERFRkFVTFRfRk9OVDtcbiAgcmV0dXJuIGN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcbn07XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHBhcmFtIHtPYmplY3R9IFt0cnVuY2F0ZV1cbiAqIEByZXR1cm4ge09iamVjdH0gYmxvY2s6IHtsaW5lSGVpZ2h0LCBsaW5lcywgaGVpZ2h0LCBvdXRlckhlaWdodH1cbiAqICBOb3RpY2U6IGZvciBwZXJmb3JtYW5jZSwgZG8gbm90IGNhbGN1bGF0ZSBvdXRlcldpZHRoIHV0aWwgbmVlZGVkLlxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VQbGFpblRleHQodGV4dCwgZm9udCwgcGFkZGluZywgdHJ1bmNhdGUpIHtcbiAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcbiAgdmFyIGxpbmVIZWlnaHQgPSBnZXRMaW5lSGVpZ2h0KGZvbnQpO1xuICB2YXIgbGluZXMgPSB0ZXh0ID8gdGV4dC5zcGxpdCgnXFxuJykgOiBbXTtcbiAgdmFyIGhlaWdodCA9IGxpbmVzLmxlbmd0aCAqIGxpbmVIZWlnaHQ7XG4gIHZhciBvdXRlckhlaWdodCA9IGhlaWdodDtcblxuICBpZiAocGFkZGluZykge1xuICAgIG91dGVySGVpZ2h0ICs9IHBhZGRpbmdbMF0gKyBwYWRkaW5nWzJdO1xuICB9XG5cbiAgaWYgKHRleHQgJiYgdHJ1bmNhdGUpIHtcbiAgICB2YXIgdHJ1bmNPdXRlckhlaWdodCA9IHRydW5jYXRlLm91dGVySGVpZ2h0O1xuICAgIHZhciB0cnVuY091dGVyV2lkdGggPSB0cnVuY2F0ZS5vdXRlcldpZHRoO1xuXG4gICAgaWYgKHRydW5jT3V0ZXJIZWlnaHQgIT0gbnVsbCAmJiBvdXRlckhlaWdodCA+IHRydW5jT3V0ZXJIZWlnaHQpIHtcbiAgICAgIHRleHQgPSAnJztcbiAgICAgIGxpbmVzID0gW107XG4gICAgfSBlbHNlIGlmICh0cnVuY091dGVyV2lkdGggIT0gbnVsbCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBwcmVwYXJlVHJ1bmNhdGVPcHRpb25zKHRydW5jT3V0ZXJXaWR0aCAtIChwYWRkaW5nID8gcGFkZGluZ1sxXSArIHBhZGRpbmdbM10gOiAwKSwgZm9udCwgdHJ1bmNhdGUuZWxsaXBzaXMsIHtcbiAgICAgICAgbWluQ2hhcjogdHJ1bmNhdGUubWluQ2hhcixcbiAgICAgICAgcGxhY2Vob2xkZXI6IHRydW5jYXRlLnBsYWNlaG9sZGVyXG4gICAgICB9KTsgLy8gRklYTUVcbiAgICAgIC8vIEl0IGlzIG5vdCBhcHByb3ByaWF0ZSB0aGF0IGV2ZXJ5IGxpbmUgaGFzICcuLi4nIHdoZW4gdHJ1bmNhdGUgbXVsdGlwbGUgbGluZXMuXG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsaW5lc1tpXSA9IHRydW5jYXRlU2luZ2xlTGluZShsaW5lc1tpXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsaW5lczogbGluZXMsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgb3V0ZXJIZWlnaHQ6IG91dGVySGVpZ2h0LFxuICAgIGxpbmVIZWlnaHQ6IGxpbmVIZWlnaHRcbiAgfTtcbn1cbi8qKlxuICogRm9yIGV4YW1wbGU6ICdzb21lIHRleHQge2F8c29tZSB0ZXh0fW90aGVyIHRleHR7Ynxzb21lIHRleHR9eHh4e2N8fXh4eCdcbiAqIEFsc28gY29uc2lkZXIgJ2JiYmJ7YXx4eHhcXG56enp9eHh4eFxcbmFhYWEnLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAqIEByZXR1cm4ge09iamVjdH0gYmxvY2tcbiAqIHtcbiAqICAgICAgd2lkdGgsXG4gKiAgICAgIGhlaWdodCxcbiAqICAgICAgbGluZXM6IFt7XG4gKiAgICAgICAgICBsaW5lSGVpZ2h0LFxuICogICAgICAgICAgd2lkdGgsXG4gKiAgICAgICAgICB0b2tlbnM6IFtbe1xuICogICAgICAgICAgICAgIHN0eWxlTmFtZSxcbiAqICAgICAgICAgICAgICB0ZXh0LFxuICogICAgICAgICAgICAgIHdpZHRoLCAgICAgIC8vIGluY2x1ZGUgdGV4dFBhZGRpbmdcbiAqICAgICAgICAgICAgICBoZWlnaHQsICAgICAvLyBpbmNsdWRlIHRleHRQYWRkaW5nXG4gKiAgICAgICAgICAgICAgdGV4dFdpZHRoLCAvLyBwdXJlIHRleHQgd2lkdGhcbiAqICAgICAgICAgICAgICB0ZXh0SGVpZ2h0LCAvLyBwdXJlIHRleHQgaGVpZ2h0XG4gKiAgICAgICAgICAgICAgbGluZUhlaWhndCxcbiAqICAgICAgICAgICAgICBmb250LFxuICogICAgICAgICAgICAgIHRleHRBbGlnbixcbiAqICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnblxuICogICAgICAgICAgfV0sIFsuLi5dLCAuLi5dXG4gKiAgICAgIH0sIC4uLl1cbiAqIH1cbiAqIElmIHN0eWxlTmFtZSBpcyB1bmRlZmluZWQsIGl0IGlzIHBsYWluIHRleHQuXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVJpY2hUZXh0KHRleHQsIHN0eWxlKSB7XG4gIHZhciBjb250ZW50QmxvY2sgPSB7XG4gICAgbGluZXM6IFtdLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9O1xuICB0ZXh0ICE9IG51bGwgJiYgKHRleHQgKz0gJycpO1xuXG4gIGlmICghdGV4dCkge1xuICAgIHJldHVybiBjb250ZW50QmxvY2s7XG4gIH1cblxuICB2YXIgbGFzdEluZGV4ID0gU1RZTEVfUkVHLmxhc3RJbmRleCA9IDA7XG4gIHZhciByZXN1bHQ7XG5cbiAgd2hpbGUgKChyZXN1bHQgPSBTVFlMRV9SRUcuZXhlYyh0ZXh0KSkgIT0gbnVsbCkge1xuICAgIHZhciBtYXRjaGVkSW5kZXggPSByZXN1bHQuaW5kZXg7XG5cbiAgICBpZiAobWF0Y2hlZEluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICBwdXNoVG9rZW5zKGNvbnRlbnRCbG9jaywgdGV4dC5zdWJzdHJpbmcobGFzdEluZGV4LCBtYXRjaGVkSW5kZXgpKTtcbiAgICB9XG5cbiAgICBwdXNoVG9rZW5zKGNvbnRlbnRCbG9jaywgcmVzdWx0WzJdLCByZXN1bHRbMV0pO1xuICAgIGxhc3RJbmRleCA9IFNUWUxFX1JFRy5sYXN0SW5kZXg7XG4gIH1cblxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICBwdXNoVG9rZW5zKGNvbnRlbnRCbG9jaywgdGV4dC5zdWJzdHJpbmcobGFzdEluZGV4LCB0ZXh0Lmxlbmd0aCkpO1xuICB9XG5cbiAgdmFyIGxpbmVzID0gY29udGVudEJsb2NrLmxpbmVzO1xuICB2YXIgY29udGVudEhlaWdodCA9IDA7XG4gIHZhciBjb250ZW50V2lkdGggPSAwOyAvLyBGb3IgYHRleHRXaWR0aDogMTAwJWBcblxuICB2YXIgcGVuZGluZ0xpc3QgPSBbXTtcbiAgdmFyIHN0bFBhZGRpbmcgPSBzdHlsZS50ZXh0UGFkZGluZztcbiAgdmFyIHRydW5jYXRlID0gc3R5bGUudHJ1bmNhdGU7XG4gIHZhciB0cnVuY2F0ZVdpZHRoID0gdHJ1bmNhdGUgJiYgdHJ1bmNhdGUub3V0ZXJXaWR0aDtcbiAgdmFyIHRydW5jYXRlSGVpZ2h0ID0gdHJ1bmNhdGUgJiYgdHJ1bmNhdGUub3V0ZXJIZWlnaHQ7XG5cbiAgaWYgKHN0bFBhZGRpbmcpIHtcbiAgICB0cnVuY2F0ZVdpZHRoICE9IG51bGwgJiYgKHRydW5jYXRlV2lkdGggLT0gc3RsUGFkZGluZ1sxXSArIHN0bFBhZGRpbmdbM10pO1xuICAgIHRydW5jYXRlSGVpZ2h0ICE9IG51bGwgJiYgKHRydW5jYXRlSGVpZ2h0IC09IHN0bFBhZGRpbmdbMF0gKyBzdGxQYWRkaW5nWzJdKTtcbiAgfSAvLyBDYWxjdWxhdGUgbGF5b3V0IGluZm8gb2YgdG9rZW5zLlxuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW5lID0gbGluZXNbaV07XG4gICAgdmFyIGxpbmVIZWlnaHQgPSAwO1xuICAgIHZhciBsaW5lV2lkdGggPSAwO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lLnRva2Vucy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHRva2VuID0gbGluZS50b2tlbnNbal07XG4gICAgICB2YXIgdG9rZW5TdHlsZSA9IHRva2VuLnN0eWxlTmFtZSAmJiBzdHlsZS5yaWNoW3Rva2VuLnN0eWxlTmFtZV0gfHwge307IC8vIHRleHRQYWRkaW5nIHNob3VsZCBub3QgaW5oZXJpdCBmcm9tIHN0eWxlLlxuXG4gICAgICB2YXIgdGV4dFBhZGRpbmcgPSB0b2tlbi50ZXh0UGFkZGluZyA9IHRva2VuU3R5bGUudGV4dFBhZGRpbmc7IC8vIHRleHRGb250IGhhcyBiZWVuIGFzaWduZWQgdG8gZm9udCBieSBgbm9ybWFsaXplU3R5bGVgLlxuXG4gICAgICB2YXIgZm9udCA9IHRva2VuLmZvbnQgPSB0b2tlblN0eWxlLmZvbnQgfHwgc3R5bGUuZm9udDsgLy8gdGV4dEhlaWdodCBjYW4gYmUgdXNlZCB3aGVuIHRleHRWZXJ0aWNhbEFsaWduIGlzIHNwZWNpZmllZCBpbiB0b2tlbi5cblxuICAgICAgdmFyIHRva2VuSGVpZ2h0ID0gdG9rZW4udGV4dEhlaWdodCA9IHJldHJpZXZlMiggLy8gdGV4dEhlaWdodCBzaG91bGQgbm90IGJlIGluaGVyaXRlZCwgY29uc2lkZXIgaXQgY2FuIGJlIHNwZWNpZmllZFxuICAgICAgLy8gYXMgYm94IGhlaWdodCBvZiB0aGUgYmxvY2suXG4gICAgICB0b2tlblN0eWxlLnRleHRIZWlnaHQsIGdldExpbmVIZWlnaHQoZm9udCkpO1xuICAgICAgdGV4dFBhZGRpbmcgJiYgKHRva2VuSGVpZ2h0ICs9IHRleHRQYWRkaW5nWzBdICsgdGV4dFBhZGRpbmdbMl0pO1xuICAgICAgdG9rZW4uaGVpZ2h0ID0gdG9rZW5IZWlnaHQ7XG4gICAgICB0b2tlbi5saW5lSGVpZ2h0ID0gcmV0cmlldmUzKHRva2VuU3R5bGUudGV4dExpbmVIZWlnaHQsIHN0eWxlLnRleHRMaW5lSGVpZ2h0LCB0b2tlbkhlaWdodCk7XG4gICAgICB0b2tlbi50ZXh0QWxpZ24gPSB0b2tlblN0eWxlICYmIHRva2VuU3R5bGUudGV4dEFsaWduIHx8IHN0eWxlLnRleHRBbGlnbjtcbiAgICAgIHRva2VuLnRleHRWZXJ0aWNhbEFsaWduID0gdG9rZW5TdHlsZSAmJiB0b2tlblN0eWxlLnRleHRWZXJ0aWNhbEFsaWduIHx8ICdtaWRkbGUnO1xuXG4gICAgICBpZiAodHJ1bmNhdGVIZWlnaHQgIT0gbnVsbCAmJiBjb250ZW50SGVpZ2h0ICsgdG9rZW4ubGluZUhlaWdodCA+IHRydW5jYXRlSGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0b2tlbi50ZXh0V2lkdGggPSBnZXRXaWR0aCh0b2tlbi50ZXh0LCBmb250KTtcbiAgICAgIHZhciB0b2tlbldpZHRoID0gdG9rZW5TdHlsZS50ZXh0V2lkdGg7XG4gICAgICB2YXIgdG9rZW5XaWR0aE5vdFNwZWNpZmllZCA9IHRva2VuV2lkdGggPT0gbnVsbCB8fCB0b2tlbldpZHRoID09PSAnYXV0byc7IC8vIFBlcmNlbnQgd2lkdGgsIGNhbiBiZSBgMTAwJWAsIGNhbiBiZSB1c2VkIGluIGRyYXdpbmcgc2VwYXJhdGVcbiAgICAgIC8vIGxpbmUgd2hlbiBib3ggd2lkdGggaXMgbmVlZGVkIHRvIGJlIGF1dG8uXG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW5XaWR0aCA9PT0gJ3N0cmluZycgJiYgdG9rZW5XaWR0aC5jaGFyQXQodG9rZW5XaWR0aC5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgICAgIHRva2VuLnBlcmNlbnRXaWR0aCA9IHRva2VuV2lkdGg7XG4gICAgICAgIHBlbmRpbmdMaXN0LnB1c2godG9rZW4pO1xuICAgICAgICB0b2tlbldpZHRoID0gMDsgLy8gRG8gbm90IHRydW5jYXRlIGluIHRoaXMgY2FzZSwgYmVjYXVzZSB0aGVyZSBpcyBubyB1c2VyIGNhc2VcbiAgICAgICAgLy8gYW5kIGl0IGlzIHRvbyBjb21wbGljYXRlZC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0b2tlbldpZHRoTm90U3BlY2lmaWVkKSB7XG4gICAgICAgICAgdG9rZW5XaWR0aCA9IHRva2VuLnRleHRXaWR0aDsgLy8gRklYTUU6IElmIGltYWdlIGlzIG5vdCBsb2FkZWQgYW5kIHRleHRXaWR0aCBpcyBub3Qgc3BlY2lmaWVkLCBjYWxsaW5nXG4gICAgICAgICAgLy8gYGdldEJvdW5kaW5nUmVjdCgpYCB3aWxsIG5vdCBnZXQgY29ycmVjdCByZXN1bHQuXG5cbiAgICAgICAgICB2YXIgdGV4dEJhY2tncm91bmRDb2xvciA9IHRva2VuU3R5bGUudGV4dEJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICB2YXIgYmdJbWcgPSB0ZXh0QmFja2dyb3VuZENvbG9yICYmIHRleHRCYWNrZ3JvdW5kQ29sb3IuaW1hZ2U7IC8vIFVzZSBjYXNlczpcbiAgICAgICAgICAvLyAoMSkgSWYgaW1hZ2UgaXMgbm90IGxvYWRlZCwgaXQgd2lsbCBiZSBsb2FkZWQgYXQgcmVuZGVyIHBoYXNlIGFuZCBjYWxsXG4gICAgICAgICAgLy8gYGRpcnR5KClgIGFuZCBgdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZWAgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBsb2FkZWRcbiAgICAgICAgICAvLyBpbWFnZSwgYW5kIHRoZW4gdGhlIHJpZ2h0IHNpemUgd2lsbCBiZSBjYWxjdWxhdGVkIGhlcmUgYXQgdGhlIG5leHQgdGljay5cbiAgICAgICAgICAvLyBTZWUgYGdyYXBoaWMvaGVscGVyL3RleHQuanNgLlxuICAgICAgICAgIC8vICgyKSBJZiBpbWFnZSBsb2FkZWQsIGFuZCBgdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZWAgaXMgaW1hZ2Ugc3JjIHN0cmluZyxcbiAgICAgICAgICAvLyB1c2UgYGltYWdlSGVscGVyLmZpbmRFeGlzdEltYWdlYCB0byBmaW5kIGNhY2hlZCBpbWFnZS5cbiAgICAgICAgICAvLyBgaW1hZ2VIZWxwZXIuZmluZEV4aXN0SW1hZ2VgIHdpbGwgYWx3YXlzIGJlIGNhbGxlZCBoZXJlIGJlZm9yZVxuICAgICAgICAgIC8vIGBpbWFnZUhlbHBlci5jcmVhdGVPclVwZGF0ZUltYWdlYCBpbiBgZ3JhcGhpYy9oZWxwZXIvdGV4dC5qcyNyZW5kZXJSaWNoVGV4dGBcbiAgICAgICAgICAvLyB3aGljaCBlbnN1cmVzIHRoYXQgaW1hZ2Ugd2lsbCBub3QgYmUgcmVuZGVyZWQgYmVmb3JlIGNvcnJlY3Qgc2l6ZSBjYWxjdWFsdGVkLlxuXG4gICAgICAgICAgaWYgKGJnSW1nKSB7XG4gICAgICAgICAgICBiZ0ltZyA9IGltYWdlSGVscGVyLmZpbmRFeGlzdEltYWdlKGJnSW1nKTtcblxuICAgICAgICAgICAgaWYgKGltYWdlSGVscGVyLmlzSW1hZ2VSZWFkeShiZ0ltZykpIHtcbiAgICAgICAgICAgICAgdG9rZW5XaWR0aCA9IE1hdGgubWF4KHRva2VuV2lkdGgsIGJnSW1nLndpZHRoICogdG9rZW5IZWlnaHQgLyBiZ0ltZy5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYWRkaW5nVyA9IHRleHRQYWRkaW5nID8gdGV4dFBhZGRpbmdbMV0gKyB0ZXh0UGFkZGluZ1szXSA6IDA7XG4gICAgICAgIHRva2VuV2lkdGggKz0gcGFkZGluZ1c7XG4gICAgICAgIHZhciByZW1pYW5UcnVuY1dpZHRoID0gdHJ1bmNhdGVXaWR0aCAhPSBudWxsID8gdHJ1bmNhdGVXaWR0aCAtIGxpbmVXaWR0aCA6IG51bGw7XG5cbiAgICAgICAgaWYgKHJlbWlhblRydW5jV2lkdGggIT0gbnVsbCAmJiByZW1pYW5UcnVuY1dpZHRoIDwgdG9rZW5XaWR0aCkge1xuICAgICAgICAgIGlmICghdG9rZW5XaWR0aE5vdFNwZWNpZmllZCB8fCByZW1pYW5UcnVuY1dpZHRoIDwgcGFkZGluZ1cpIHtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSAnJztcbiAgICAgICAgICAgIHRva2VuLnRleHRXaWR0aCA9IHRva2VuV2lkdGggPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gdHJ1bmNhdGVUZXh0KHRva2VuLnRleHQsIHJlbWlhblRydW5jV2lkdGggLSBwYWRkaW5nVywgZm9udCwgdHJ1bmNhdGUuZWxsaXBzaXMsIHtcbiAgICAgICAgICAgICAgbWluQ2hhcjogdHJ1bmNhdGUubWluQ2hhclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0b2tlbi50ZXh0V2lkdGggPSBnZXRXaWR0aCh0b2tlbi50ZXh0LCBmb250KTtcbiAgICAgICAgICAgIHRva2VuV2lkdGggPSB0b2tlbi50ZXh0V2lkdGggKyBwYWRkaW5nVztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGluZVdpZHRoICs9IHRva2VuLndpZHRoID0gdG9rZW5XaWR0aDtcbiAgICAgIHRva2VuU3R5bGUgJiYgKGxpbmVIZWlnaHQgPSBNYXRoLm1heChsaW5lSGVpZ2h0LCB0b2tlbi5saW5lSGVpZ2h0KSk7XG4gICAgfVxuXG4gICAgbGluZS53aWR0aCA9IGxpbmVXaWR0aDtcbiAgICBsaW5lLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgIGNvbnRlbnRIZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICBjb250ZW50V2lkdGggPSBNYXRoLm1heChjb250ZW50V2lkdGgsIGxpbmVXaWR0aCk7XG4gIH1cblxuICBjb250ZW50QmxvY2sub3V0ZXJXaWR0aCA9IGNvbnRlbnRCbG9jay53aWR0aCA9IHJldHJpZXZlMihzdHlsZS50ZXh0V2lkdGgsIGNvbnRlbnRXaWR0aCk7XG4gIGNvbnRlbnRCbG9jay5vdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5oZWlnaHQgPSByZXRyaWV2ZTIoc3R5bGUudGV4dEhlaWdodCwgY29udGVudEhlaWdodCk7XG5cbiAgaWYgKHN0bFBhZGRpbmcpIHtcbiAgICBjb250ZW50QmxvY2sub3V0ZXJXaWR0aCArPSBzdGxQYWRkaW5nWzFdICsgc3RsUGFkZGluZ1szXTtcbiAgICBjb250ZW50QmxvY2sub3V0ZXJIZWlnaHQgKz0gc3RsUGFkZGluZ1swXSArIHN0bFBhZGRpbmdbMl07XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBlbmRpbmdMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gcGVuZGluZ0xpc3RbaV07XG4gICAgdmFyIHBlcmNlbnRXaWR0aCA9IHRva2VuLnBlcmNlbnRXaWR0aDsgLy8gU2hvdWxkIG5vdCBiYXNlIG9uIG91dGVyV2lkdGgsIGJlY2F1c2UgdG9rZW4gY2FuIG5vdCBiZSBwbGFjZWQgb3V0IG9mIHBhZGRpbmcuXG5cbiAgICB0b2tlbi53aWR0aCA9IHBhcnNlSW50KHBlcmNlbnRXaWR0aCwgMTApIC8gMTAwICogY29udGVudFdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRlbnRCbG9jaztcbn1cblxuZnVuY3Rpb24gcHVzaFRva2VucyhibG9jaywgc3RyLCBzdHlsZU5hbWUpIHtcbiAgdmFyIGlzRW1wdHlTdHIgPSBzdHIgPT09ICcnO1xuICB2YXIgc3RycyA9IHN0ci5zcGxpdCgnXFxuJyk7XG4gIHZhciBsaW5lcyA9IGJsb2NrLmxpbmVzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Rycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0ZXh0ID0gc3Ryc1tpXTtcbiAgICB2YXIgdG9rZW4gPSB7XG4gICAgICBzdHlsZU5hbWU6IHN0eWxlTmFtZSxcbiAgICAgIHRleHQ6IHRleHQsXG4gICAgICBpc0xpbmVIb2xkZXI6ICF0ZXh0ICYmICFpc0VtcHR5U3RyXG4gICAgfTsgLy8gVGhlIGZpcnN0IHRva2VuIHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgbGFzdCBsaW5lLlxuXG4gICAgaWYgKCFpKSB7XG4gICAgICB2YXIgdG9rZW5zID0gKGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdIHx8IChsaW5lc1swXSA9IHtcbiAgICAgICAgdG9rZW5zOiBbXVxuICAgICAgfSkpLnRva2VuczsgLy8gQ29uc2lkZXIgY2FzZXM6XG4gICAgICAvLyAoMSkgJycuc3BsaXQoJ1xcbicpID0+IFsnJywgJ1xcbicsICcnXSwgdGhlICcnIGF0IHRoZSBmaXJzdCBpdGVtXG4gICAgICAvLyAod2hpY2ggaXMgYSBwbGFjZWhvbGRlcikgc2hvdWxkIGJlIHJlcGxhY2VkIGJ5IG5ldyB0b2tlbi5cbiAgICAgIC8vICgyKSBBIGltYWdlIGJhY2thZ2UsIHdoZXJlIHRva2VuIGxpa2VzIHthfH0uXG4gICAgICAvLyAoMykgQSByZWR1bmRhbnQgJycgd2lsbCBhZmZlY3QgdGV4dEFsaWduIGluIGxpbmUuXG4gICAgICAvLyAoNCkgdG9rZW5zIHdpdGggdGhlIHNhbWUgdHBsTmFtZSBzaG91bGQgbm90IGJlIG1lcmdlZCwgYmVjYXVzZVxuICAgICAgLy8gdGhleSBzaG91bGQgYmUgZGlzcGxheWVkIGluIGRpZmZlcmVudCBib3ggKHdpdGggYm9yZGVyIGFuZCBwYWRkaW5nKS5cblxuICAgICAgdmFyIHRva2Vuc0xlbiA9IHRva2Vucy5sZW5ndGg7XG4gICAgICB0b2tlbnNMZW4gPT09IDEgJiYgdG9rZW5zWzBdLmlzTGluZUhvbGRlciA/IHRva2Vuc1swXSA9IHRva2VuIDogLy8gQ29uc2lkZXIgdGV4dCBpcyAnJywgb25seSBpbnNlcnQgd2hlbiBpdCBpcyB0aGUgXCJsaW5lSG9sZGVyXCIgb3JcbiAgICAgIC8vIFwiZW1wdHlTdHJcIi4gT3RoZXJ3aXNlIGEgcmVkdW5kYW50ICcnIHdpbGwgYWZmZWN0IHRleHRBbGlnbiBpbiBsaW5lLlxuICAgICAgKHRleHQgfHwgIXRva2Vuc0xlbiB8fCBpc0VtcHR5U3RyKSAmJiB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgfSAvLyBPdGhlciB0b2tlbnMgYWx3YXlzIHN0YXJ0IGEgbmV3IGxpbmUuXG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzICcnLCBpbnNlcnQgaXQgYXMgYSBwbGFjZWhvbGRlci5cbiAgICAgICAgbGluZXMucHVzaCh7XG4gICAgICAgICAgdG9rZW5zOiBbdG9rZW5dXG4gICAgICAgIH0pO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VGb250KHN0eWxlKSB7XG4gIC8vIEZJWE1FIGluIG5vZGUtY2FudmFzIGZvbnRXZWlnaHQgaXMgYmVmb3JlIGZvbnRTdHlsZVxuICAvLyBVc2UgYGZvbnRTaXplYCBgZm9udEZhbWlseWAgdG8gY2hlY2sgd2hldGhlciBmb250IHByb3BlcnRpZXMgYXJlIGRlZmluZWQuXG4gIHJldHVybiAoc3R5bGUuZm9udFNpemUgfHwgc3R5bGUuZm9udEZhbWlseSkgJiYgW3N0eWxlLmZvbnRTdHlsZSwgc3R5bGUuZm9udFdlaWdodCwgKHN0eWxlLmZvbnRTaXplIHx8IDEyKSArICdweCcsIC8vIElmIGZvbnQgcHJvcGVydGllcyBhcmUgZGVmaW5lZCwgYGZvbnRGYW1pbHlgIHNob3VsZCBub3QgYmUgaWdub3JlZC5cbiAgc3R5bGUuZm9udEZhbWlseSB8fCAnc2Fucy1zZXJpZiddLmpvaW4oJyAnKSB8fCBzdHlsZS50ZXh0Rm9udCB8fCBzdHlsZS5mb250O1xufVxuXG5leHBvcnRzLkRFRkFVTFRfRk9OVCA9IERFRkFVTFRfRk9OVDtcbmV4cG9ydHMuJG92ZXJyaWRlID0gJG92ZXJyaWRlO1xuZXhwb3J0cy5nZXRXaWR0aCA9IGdldFdpZHRoO1xuZXhwb3J0cy5nZXRCb3VuZGluZ1JlY3QgPSBnZXRCb3VuZGluZ1JlY3Q7XG5leHBvcnRzLmFkanVzdFRleHRYID0gYWRqdXN0VGV4dFg7XG5leHBvcnRzLmFkanVzdFRleHRZID0gYWRqdXN0VGV4dFk7XG5leHBvcnRzLmFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCA9IGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdDtcbmV4cG9ydHMudHJ1bmNhdGVUZXh0ID0gdHJ1bmNhdGVUZXh0O1xuZXhwb3J0cy5nZXRMaW5lSGVpZ2h0ID0gZ2V0TGluZUhlaWdodDtcbmV4cG9ydHMubWVhc3VyZVRleHQgPSBtZWFzdXJlVGV4dDtcbmV4cG9ydHMucGFyc2VQbGFpblRleHQgPSBwYXJzZVBsYWluVGV4dDtcbmV4cG9ydHMucGFyc2VSaWNoVGV4dCA9IHBhcnNlUmljaFRleHQ7XG5leHBvcnRzLm1ha2VGb250ID0gbWFrZUZvbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExSVSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL0xSVVwiKTtcblxudmFyIGdsb2JhbEltYWdlQ2FjaGUgPSBuZXcgTFJVKDUwKTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxDYW52YXN9IG5ld0ltYWdlT3JTcmNcbiAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBpbWFnZVxuICovXG5cbmZ1bmN0aW9uIGZpbmRFeGlzdEltYWdlKG5ld0ltYWdlT3JTcmMpIHtcbiAgaWYgKHR5cGVvZiBuZXdJbWFnZU9yU3JjID09PSAnc3RyaW5nJykge1xuICAgIHZhciBjYWNoZWRJbWdPYmogPSBnbG9iYWxJbWFnZUNhY2hlLmdldChuZXdJbWFnZU9yU3JjKTtcbiAgICByZXR1cm4gY2FjaGVkSW1nT2JqICYmIGNhY2hlZEltZ09iai5pbWFnZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3SW1hZ2VPclNyYztcbiAgfVxufVxuLyoqXG4gKiBDYXV0aW9uOiBVc2VyIHNob3VsZCBjYWNoZSBsb2FkZWQgaW1hZ2VzLCBidXQgbm90IGp1c3QgY291bnQgb24gTFJVLlxuICogQ29uc2lkZXIgaWYgcmVxdWlyZWQgaW1hZ2VzIG1vcmUgdGhhbiBMUlUgc2l6ZSwgd2lsbCBkZWFkIGxvb3Agb2NjdXI/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxDYW52YXN9IG5ld0ltYWdlT3JTcmNcbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxDYW52YXN9IGltYWdlIEV4aXN0ZW50IGltYWdlLlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBbaG9zdEVsXSBGb3IgY2FsbGluZyBgZGlydHlgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBwYXJhbXM6IChpbWFnZSwgY2JQYXlsb2FkKVxuICogQHBhcmFtIHtPYmplY3R9IFtjYlBheWxvYWRdIFBheWxvYWQgb24gY2IgY2FsbGluZy5cbiAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBpbWFnZVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVJbWFnZShuZXdJbWFnZU9yU3JjLCBpbWFnZSwgaG9zdEVsLCBjYiwgY2JQYXlsb2FkKSB7XG4gIGlmICghbmV3SW1hZ2VPclNyYykge1xuICAgIHJldHVybiBpbWFnZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbmV3SW1hZ2VPclNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBJbWFnZSBzaG91bGQgbm90IGJlIGxvYWRlZCByZXBlYXRseS5cbiAgICBpZiAoaW1hZ2UgJiYgaW1hZ2UuX196ckltYWdlU3JjID09PSBuZXdJbWFnZU9yU3JjIHx8ICFob3N0RWwpIHtcbiAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9IC8vIE9ubHkgd2hlbiB0aGVyZSBpcyBubyBleGlzdGVudCBpbWFnZSBvciBleGlzdGVudCBpbWFnZSBzcmNcbiAgICAvLyBpcyBkaWZmZXJlbnQsIHRoaXMgbWV0aG9kIGlzIHJlc3BvbnNpYmxlIGZvciBsb2FkLlxuXG5cbiAgICB2YXIgY2FjaGVkSW1nT2JqID0gZ2xvYmFsSW1hZ2VDYWNoZS5nZXQobmV3SW1hZ2VPclNyYyk7XG4gICAgdmFyIHBlbmRpbmdXcmFwID0ge1xuICAgICAgaG9zdEVsOiBob3N0RWwsXG4gICAgICBjYjogY2IsXG4gICAgICBjYlBheWxvYWQ6IGNiUGF5bG9hZFxuICAgIH07XG5cbiAgICBpZiAoY2FjaGVkSW1nT2JqKSB7XG4gICAgICBpbWFnZSA9IGNhY2hlZEltZ09iai5pbWFnZTtcbiAgICAgICFpc0ltYWdlUmVhZHkoaW1hZ2UpICYmIGNhY2hlZEltZ09iai5wZW5kaW5nLnB1c2gocGVuZGluZ1dyYXApO1xuICAgIH0gZWxzZSB7XG4gICAgICAhaW1hZ2UgJiYgKGltYWdlID0gbmV3IEltYWdlKCkpO1xuICAgICAgaW1hZ2Uub25sb2FkID0gaW1hZ2VPbkxvYWQ7XG4gICAgICBnbG9iYWxJbWFnZUNhY2hlLnB1dChuZXdJbWFnZU9yU3JjLCBpbWFnZS5fX2NhY2hlZEltZ09iaiA9IHtcbiAgICAgICAgaW1hZ2U6IGltYWdlLFxuICAgICAgICBwZW5kaW5nOiBbcGVuZGluZ1dyYXBdXG4gICAgICB9KTtcbiAgICAgIGltYWdlLnNyYyA9IGltYWdlLl9fenJJbWFnZVNyYyA9IG5ld0ltYWdlT3JTcmM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGltYWdlO1xuICB9IC8vIG5ld0ltYWdlT3JTcmMgaXMgYW4gSFRNTEltYWdlRWxlbWVudCBvciBIVE1MQ2FudmFzRWxlbWVudCBvciBDYW52YXNcbiAgZWxzZSB7XG4gICAgICByZXR1cm4gbmV3SW1hZ2VPclNyYztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGltYWdlT25Mb2FkKCkge1xuICB2YXIgY2FjaGVkSW1nT2JqID0gdGhpcy5fX2NhY2hlZEltZ09iajtcbiAgdGhpcy5vbmxvYWQgPSB0aGlzLl9fY2FjaGVkSW1nT2JqID0gbnVsbDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhY2hlZEltZ09iai5wZW5kaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBlbmRpbmdXcmFwID0gY2FjaGVkSW1nT2JqLnBlbmRpbmdbaV07XG4gICAgdmFyIGNiID0gcGVuZGluZ1dyYXAuY2I7XG4gICAgY2IgJiYgY2IodGhpcywgcGVuZGluZ1dyYXAuY2JQYXlsb2FkKTtcbiAgICBwZW5kaW5nV3JhcC5ob3N0RWwuZGlydHkoKTtcbiAgfVxuXG4gIGNhY2hlZEltZ09iai5wZW5kaW5nLmxlbmd0aCA9IDA7XG59XG5cbmZ1bmN0aW9uIGlzSW1hZ2VSZWFkeShpbWFnZSkge1xuICByZXR1cm4gaW1hZ2UgJiYgaW1hZ2Uud2lkdGggJiYgaW1hZ2UuaGVpZ2h0O1xufVxuXG5leHBvcnRzLmZpbmRFeGlzdEltYWdlID0gZmluZEV4aXN0SW1hZ2U7XG5leHBvcnRzLmNyZWF0ZU9yVXBkYXRlSW1hZ2UgPSBjcmVhdGVPclVwZGF0ZUltYWdlO1xuZXhwb3J0cy5pc0ltYWdlUmVhZHkgPSBpc0ltYWdlUmVhZHk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL2ltYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBidWlsZFBhdGgoY3R4LCBzaGFwZSkge1xuICB2YXIgeCA9IHNoYXBlLng7XG4gIHZhciB5ID0gc2hhcGUueTtcbiAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gIHZhciByID0gc2hhcGUucjtcbiAgdmFyIHIxO1xuICB2YXIgcjI7XG4gIHZhciByMztcbiAgdmFyIHI0OyAvLyBDb252ZXJ0IHdpZHRoIGFuZCBoZWlnaHQgdG8gcG9zaXRpdmUgZm9yIGJldHRlciBib3JkZXJSYWRpdXNcblxuICBpZiAod2lkdGggPCAwKSB7XG4gICAgeCA9IHggKyB3aWR0aDtcbiAgICB3aWR0aCA9IC13aWR0aDtcbiAgfVxuXG4gIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgeSA9IHkgKyBoZWlnaHQ7XG4gICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgciA9PT0gJ251bWJlcicpIHtcbiAgICByMSA9IHIyID0gcjMgPSByNCA9IHI7XG4gIH0gZWxzZSBpZiAociBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgaWYgKHIubGVuZ3RoID09PSAxKSB7XG4gICAgICByMSA9IHIyID0gcjMgPSByNCA9IHJbMF07XG4gICAgfSBlbHNlIGlmIChyLmxlbmd0aCA9PT0gMikge1xuICAgICAgcjEgPSByMyA9IHJbMF07XG4gICAgICByMiA9IHI0ID0gclsxXTtcbiAgICB9IGVsc2UgaWYgKHIubGVuZ3RoID09PSAzKSB7XG4gICAgICByMSA9IHJbMF07XG4gICAgICByMiA9IHI0ID0gclsxXTtcbiAgICAgIHIzID0gclsyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcjEgPSByWzBdO1xuICAgICAgcjIgPSByWzFdO1xuICAgICAgcjMgPSByWzJdO1xuICAgICAgcjQgPSByWzNdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByMSA9IHIyID0gcjMgPSByNCA9IDA7XG4gIH1cblxuICB2YXIgdG90YWw7XG5cbiAgaWYgKHIxICsgcjIgPiB3aWR0aCkge1xuICAgIHRvdGFsID0gcjEgKyByMjtcbiAgICByMSAqPSB3aWR0aCAvIHRvdGFsO1xuICAgIHIyICo9IHdpZHRoIC8gdG90YWw7XG4gIH1cblxuICBpZiAocjMgKyByNCA+IHdpZHRoKSB7XG4gICAgdG90YWwgPSByMyArIHI0O1xuICAgIHIzICo9IHdpZHRoIC8gdG90YWw7XG4gICAgcjQgKj0gd2lkdGggLyB0b3RhbDtcbiAgfVxuXG4gIGlmIChyMiArIHIzID4gaGVpZ2h0KSB7XG4gICAgdG90YWwgPSByMiArIHIzO1xuICAgIHIyICo9IGhlaWdodCAvIHRvdGFsO1xuICAgIHIzICo9IGhlaWdodCAvIHRvdGFsO1xuICB9XG5cbiAgaWYgKHIxICsgcjQgPiBoZWlnaHQpIHtcbiAgICB0b3RhbCA9IHIxICsgcjQ7XG4gICAgcjEgKj0gaGVpZ2h0IC8gdG90YWw7XG4gICAgcjQgKj0gaGVpZ2h0IC8gdG90YWw7XG4gIH1cblxuICBjdHgubW92ZVRvKHggKyByMSwgeSk7XG4gIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcjIsIHkpO1xuICByMiAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHIyKTtcbiAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByMyk7XG4gIHIzICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcjMsIHkgKyBoZWlnaHQpO1xuICBjdHgubGluZVRvKHggKyByNCwgeSArIGhlaWdodCk7XG4gIHI0ICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByNCk7XG4gIGN0eC5saW5lVG8oeCwgeSArIHIxKTtcbiAgcjEgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHIxLCB5KTtcbn1cblxuZXhwb3J0cy5idWlsZFBhdGggPSBidWlsZFBhdGg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3JvdW5kUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgX2V2ZW50ID0gcmVxdWlyZShcIi4uL2NvcmUvZXZlbnRcIik7XG5cbnZhciBEaXNwYXRjaGVyID0gX2V2ZW50LkRpc3BhdGNoZXI7XG5cbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1aXJlKFwiLi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIik7XG5cbnZhciBBbmltYXRvciA9IHJlcXVpcmUoXCIuL0FuaW1hdG9yXCIpO1xuXG4vKipcbiAqIOWKqOeUu+S4u+exuywg6LCD5bqm5ZKM566h55CG5omA5pyJ5Yqo55S75o6n5Yi25ZmoXG4gKlxuICogQG1vZHVsZSB6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25cbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuLy8gVE9ETyBBZGRpdGl2ZSBhbmltYXRpb25cbi8vIGh0dHA6Ly9pb3NvdGVyaWMuY29tL2FkZGl0aXZlLWFuaW1hdGlvbnMtYW5pbWF0ZXdpdGhkdXJhdGlvbi1pbi1pb3MtOC9cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS92aWRlb3Mvd3dkYzIwMTQvIzIzNlxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IElaUmVuZGVyU3RhZ2VcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVwZGF0ZVxuICovXG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25mcmFtZV1cbiAqIEBwYXJhbSB7SVpSZW5kZXJTdGFnZX0gW29wdGlvbnMuc3RhZ2VdXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKCk7XG4gKiAgICAgdmFyIG9iaiA9IHtcbiAqICAgICAgICAgeDogMTAwLFxuICogICAgICAgICB5OiAxMDBcbiAqICAgICB9O1xuICogICAgIGFuaW1hdGlvbi5hbmltYXRlKG5vZGUucG9zaXRpb24pXG4gKiAgICAgICAgIC53aGVuKDEwMDAsIHtcbiAqICAgICAgICAgICAgIHg6IDUwMCxcbiAqICAgICAgICAgICAgIHk6IDUwMFxuICogICAgICAgICB9KVxuICogICAgICAgICAud2hlbigyMDAwLCB7XG4gKiAgICAgICAgICAgICB4OiAxMDAsXG4gKiAgICAgICAgICAgICB5OiAxMDBcbiAqICAgICAgICAgfSlcbiAqICAgICAgICAgLnN0YXJ0KCdzcGxpbmUnKTtcbiAqL1xudmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLnN0YWdlID0gb3B0aW9ucy5zdGFnZSB8fCB7fTtcblxuICB0aGlzLm9uZnJhbWUgPSBvcHRpb25zLm9uZnJhbWUgfHwgZnVuY3Rpb24gKCkge307IC8vIHByaXZhdGUgcHJvcGVydGllc1xuXG5cbiAgdGhpcy5fY2xpcHMgPSBbXTtcbiAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICB0aGlzLl90aW1lO1xuICB0aGlzLl9wYXVzZWRUaW1lO1xuICB0aGlzLl9wYXVzZVN0YXJ0O1xuICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgRGlzcGF0Y2hlci5jYWxsKHRoaXMpO1xufTtcblxuQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEFuaW1hdGlvbixcblxuICAvKipcbiAgICog5re75YqgIGNsaXBcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcH0gY2xpcFxuICAgKi9cbiAgYWRkQ2xpcDogZnVuY3Rpb24gKGNsaXApIHtcbiAgICB0aGlzLl9jbGlwcy5wdXNoKGNsaXApO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqAgYW5pbWF0b3JcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9IGFuaW1hdG9yXG4gICAqL1xuICBhZGRBbmltYXRvcjogZnVuY3Rpb24gKGFuaW1hdG9yKSB7XG4gICAgYW5pbWF0b3IuYW5pbWF0aW9uID0gdGhpcztcbiAgICB2YXIgY2xpcHMgPSBhbmltYXRvci5nZXRDbGlwcygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5hZGRDbGlwKGNsaXBzW2ldKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWIoOmZpOWKqOeUu+eJh+autVxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwfSBjbGlwXG4gICAqL1xuICByZW1vdmVDbGlwOiBmdW5jdGlvbiAoY2xpcCkge1xuICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YodGhpcy5fY2xpcHMsIGNsaXApO1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICB0aGlzLl9jbGlwcy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWIoOmZpOWKqOeUu+eJh+autVxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn0gYW5pbWF0b3JcbiAgICovXG4gIHJlbW92ZUFuaW1hdG9yOiBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICB2YXIgY2xpcHMgPSBhbmltYXRvci5nZXRDbGlwcygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5yZW1vdmVDbGlwKGNsaXBzW2ldKTtcbiAgICB9XG5cbiAgICBhbmltYXRvci5hbmltYXRpb24gPSBudWxsO1xuICB9LFxuICBfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuX3BhdXNlZFRpbWU7XG5cbiAgICB2YXIgZGVsdGEgPSB0aW1lIC0gdGhpcy5fdGltZTtcbiAgICB2YXIgY2xpcHMgPSB0aGlzLl9jbGlwcztcbiAgICB2YXIgbGVuID0gY2xpcHMubGVuZ3RoO1xuICAgIHZhciBkZWZlcnJlZEV2ZW50cyA9IFtdO1xuICAgIHZhciBkZWZlcnJlZENsaXBzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgY2xpcCA9IGNsaXBzW2ldO1xuICAgICAgdmFyIGUgPSBjbGlwLnN0ZXAodGltZSwgZGVsdGEpOyAvLyBUaHJvdyBvdXQgdGhlIGV2ZW50cyBuZWVkIHRvIGJlIGNhbGxlZCBhZnRlclxuICAgICAgLy8gc3RhZ2UudXBkYXRlLCBsaWtlIGRlc3Ryb3lcblxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgZGVmZXJyZWRFdmVudHMucHVzaChlKTtcbiAgICAgICAgZGVmZXJyZWRDbGlwcy5wdXNoKGNsaXApO1xuICAgICAgfVxuICAgIH0gLy8gUmVtb3ZlIHRoZSBmaW5pc2hlZCBjbGlwXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgaWYgKGNsaXBzW2ldLl9uZWVkc1JlbW92ZSkge1xuICAgICAgICBjbGlwc1tpXSA9IGNsaXBzW2xlbiAtIDFdO1xuICAgICAgICBjbGlwcy5wb3AoKTtcbiAgICAgICAgbGVuLS07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGVuID0gZGVmZXJyZWRFdmVudHMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVmZXJyZWRDbGlwc1tpXS5maXJlKGRlZmVycmVkRXZlbnRzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLl90aW1lID0gdGltZTtcbiAgICB0aGlzLm9uZnJhbWUoZGVsdGEpO1xuICAgIHRoaXMudHJpZ2dlcignZnJhbWUnLCBkZWx0YSk7XG5cbiAgICBpZiAodGhpcy5zdGFnZS51cGRhdGUpIHtcbiAgICAgIHRoaXMuc3RhZ2UudXBkYXRlKCk7XG4gICAgfVxuICB9LFxuICBfc3RhcnRMb29wOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuXG4gICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgIGlmIChzZWxmLl9ydW5uaW5nKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICAgICAgIXNlbGYuX3BhdXNlZCAmJiBzZWxmLl91cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOW8gOWni+i/kOihjOWKqOeUu1xuICAgKi9cbiAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl90aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG5cbiAgICB0aGlzLl9zdGFydExvb3AoKTtcbiAgfSxcblxuICAvKipcbiAgICog5YGc5q2i6L+Q6KGM5Yqo55S7XG4gICAqL1xuICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQYXVzZVxuICAgKi9cbiAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX3BhdXNlZCkge1xuICAgICAgdGhpcy5fcGF1c2VTdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc3VtZVxuICAgKi9cbiAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgICAgdGhpcy5fcGF1c2VkVGltZSArPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuX3BhdXNlU3RhcnQ7XG4gICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa4hemZpOaJgOacieWKqOeUu+eJh+autVxuICAgKi9cbiAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jbGlwcyA9IFtdO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlr7nkuIDkuKrnm67moIfliJvlu7rkuIDkuKphbmltYXRvcuWvueixoe+8jOWPr+S7peaMh+Wumuebruagh+S4reeahOWxnuaAp+S9v+eUqOWKqOeUu1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMubG9vcD1mYWxzZV0g5piv5ZCm5b6q546v5pKt5pS+5Yqo55S7XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZXR0ZXI9bnVsbF1cbiAgICogICAgICAgICDlpoLmnpzmjIflrppnZXR0ZXLlh73mlbDvvIzkvJrpgJrov4dnZXR0ZXLlh73mlbDlj5blsZ7mgKflgLxcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IFtvcHRpb25zLnNldHRlcj1udWxsXVxuICAgKiAgICAgICAgIOWmguaenOaMh+WumnNldHRlcuWHveaVsO+8jOS8mumAmui/h3NldHRlcuWHveaVsOiuvue9ruWxnuaAp+WAvFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9ufkFuaW1hdG9yfVxuICAgKi9cbiAgLy8gVE9ETyBHYXBcbiAgYW5pbWF0ZTogZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcih0YXJnZXQsIG9wdGlvbnMubG9vcCwgb3B0aW9ucy5nZXR0ZXIsIG9wdGlvbnMuc2V0dGVyKTtcbiAgICB0aGlzLmFkZEFuaW1hdG9yKGFuaW1hdG9yKTtcbiAgICByZXR1cm4gYW5pbWF0b3I7XG4gIH1cbn07XG51dGlsLm1peGluKEFuaW1hdGlvbiwgRGlzcGF0Y2hlcik7XG52YXIgX2RlZmF1bHQgPSBBbmltYXRpb247XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXZlbnRmdWwgPSByZXF1aXJlKFwiLi4vbWl4aW4vRXZlbnRmdWxcIik7XG5cbmV4cG9ydHMuRGlzcGF0Y2hlciA9IEV2ZW50ZnVsO1xuXG52YXIgZW52ID0gcmVxdWlyZShcIi4vZW52XCIpO1xuXG4vKipcbiAqIOS6i+S7tui+heWKqeexu1xuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvZXZlbnRcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICovXG52YXIgaXNEb21MZXZlbDIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhIXdpbmRvdy5hZGRFdmVudExpc3RlbmVyO1xudmFyIE1PVVNFX0VWRU5UX1JFRyA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLztcblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKSB7XG4gIC8vIEJsYWNrQmVycnkgNSwgaU9TIDMgKG9yaWdpbmFsIGlQaG9uZSkgZG9uJ3QgaGF2ZSBnZXRCb3VuZGluZ1JlY3RcbiAgcmV0dXJuIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCA/IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDoge1xuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwXG4gIH07XG59IC8vIGBjYWxjdWxhdGVgIGlzIG9wdGlvbmFsLCBkZWZhdWx0IGZhbHNlXG5cblxuZnVuY3Rpb24gY2xpZW50VG9Mb2NhbChlbCwgZSwgb3V0LCBjYWxjdWxhdGUpIHtcbiAgb3V0ID0gb3V0IHx8IHt9OyAvLyBBY2NvcmRpbmcgdG8gdGhlIFczQyBXb3JraW5nIERyYWZ0LCBvZmZzZXRYIGFuZCBvZmZzZXRZIHNob3VsZCBiZSByZWxhdGl2ZVxuICAvLyB0byB0aGUgcGFkZGluZyBlZGdlIG9mIHRoZSB0YXJnZXQgZWxlbWVudC4gVGhlIG9ubHkgYnJvd3NlciB1c2luZyB0aGlzIGNvbnZlbnRpb25cbiAgLy8gaXMgSUUuIFdlYmtpdCB1c2VzIHRoZSBib3JkZXIgZWRnZSwgT3BlcmEgdXNlcyB0aGUgY29udGVudCBlZGdlLCBhbmQgRmlyZUZveCBkb2VzXG4gIC8vIG5vdCBzdXBwb3J0IHRoZSBwcm9wZXJ0aWVzLlxuICAvLyAoc2VlIGh0dHA6Ly93d3cuamFja2xtb29yZS5jb20vbm90ZXMvbW91c2UtcG9zaXRpb24vKVxuICAvLyBJbiB6ciBwYWludGVyLmRvbSwgcGFkZGluZyBlZGdlIGVxdWFscyB0byBib3JkZXIgZWRnZS5cbiAgLy8gRklYTUVcbiAgLy8gV2hlbiBtb3VzZW1vdmUgZXZlbnQgdHJpZ2dlcmVkIG9uIGVjIHRvb2x0aXAsIHRhcmdldCBpcyBub3QgenIgcGFpbnRlci5kb20sIGFuZFxuICAvLyBvZmZzZXRYL1kgaXMgcmVsYXRpdmUgdG8gZS50YXJnZXQsIHdoZXJlIHRoZSBjYWxjdWxhdGlvbiBvZiB6clgvWSB2aWEgb2Zmc2V0WC9ZXG4gIC8vIGlzIHRvbyBjb21wbGV4LiBTbyBjc3MtdHJhbnNmcm9tIGRvbnQgc3VwcG9ydCBpbiB0aGlzIGNhc2UgdGVtcG9yYXJpbHkuXG5cbiAgaWYgKGNhbGN1bGF0ZSB8fCAhZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgIGRlZmF1bHRHZXRaclhZKGVsLCBlLCBvdXQpO1xuICB9IC8vIENhdXRpb246IEluIEZpcmVGb3gsIGxheWVyWC9sYXllclkgTW91c2UgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGNsb3Nlc3QgcG9zaXRpb25lZFxuICAvLyBhbmNlc3RvciBlbGVtZW50LCBzbyB3ZSBzaG91bGQgbWFrZSBzdXJlIGVsIGlzIHBvc2l0aW9uZWQgKGUuZy4sIG5vdCBwb3NpdGlvbjpzdGF0aWMpLlxuICAvLyBCVFcxLCBXZWJraXQgZG9uJ3QgcmV0dXJuIHRoZSBzYW1lIHJlc3VsdHMgYXMgRkYgaW4gbm9uLXNpbXBsZSBjYXNlcyAobGlrZSBhZGRcbiAgLy8gem9vbS1mYWN0b3IsIG92ZXJmbG93IC8gb3BhY2l0eSBsYXllcnMsIHRyYW5zZm9ybXMgLi4uKVxuICAvLyBCVFcyLCAoZXYub2Zmc2V0WSB8fCBldi5wYWdlWSAtICQoZXYudGFyZ2V0KS5vZmZzZXQoKS50b3ApIGlzIG5vdCBjb3JyZWN0IGluIHByZXNlcnZlLTNkLlxuICAvLyA8aHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0Lzg1MjMjY29tbWVudDoxND5cbiAgLy8gQlRXMywgSW4gZmYsIG9mZnNldFgvb2Zmc2V0WSBpcyBhbHdheXMgMC5cbiAgZWxzZSBpZiAoZW52LmJyb3dzZXIuZmlyZWZveCAmJiBlLmxheWVyWCAhPSBudWxsICYmIGUubGF5ZXJYICE9PSBlLm9mZnNldFgpIHtcbiAgICAgIG91dC56clggPSBlLmxheWVyWDtcbiAgICAgIG91dC56clkgPSBlLmxheWVyWTtcbiAgICB9IC8vIEZvciBJRTYrLCBjaHJvbWUsIHNhZmFyaSwgb3BlcmEuIChXaGVuIHdpbGwgZmYgc3VwcG9ydCBvZmZzZXRYPylcbiAgICBlbHNlIGlmIChlLm9mZnNldFggIT0gbnVsbCkge1xuICAgICAgICBvdXQuenJYID0gZS5vZmZzZXRYO1xuICAgICAgICBvdXQuenJZID0gZS5vZmZzZXRZO1xuICAgICAgfSAvLyBGb3Igc29tZSBvdGhlciBkZXZpY2UsIGUuZy4sIElPUyBzYWZhcmkuXG4gICAgICBlbHNlIHtcbiAgICAgICAgICBkZWZhdWx0R2V0WnJYWShlbCwgZSwgb3V0KTtcbiAgICAgICAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXRaclhZKGVsLCBlLCBvdXQpIHtcbiAgLy8gVGhpcyB3ZWxsLWtub3duIG1ldGhvZCBiZWxvdyBkb2VzIG5vdCBzdXBwb3J0IGNzcyB0cmFuc2Zvcm0uXG4gIHZhciBib3ggPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWwpO1xuICBvdXQuenJYID0gZS5jbGllbnRYIC0gYm94LmxlZnQ7XG4gIG91dC56clkgPSBlLmNsaWVudFkgLSBib3gudG9wO1xufVxuLyoqXG4gKiDlpoLmnpzlrZjlnKjnrKzkuInmlrnltYzlhaXnmoTkuIDkuptkb23op6blj5HnmoTkuovku7bvvIzmiJZ0b3VjaOS6i+S7tu+8jOmcgOimgei9rOaNouS4gOS4i+S6i+S7tuWdkOaghy5cbiAqIGBjYWxjdWxhdGVgIGlzIG9wdGlvbmFsLCBkZWZhdWx0IGZhbHNlLlxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnQoZWwsIGUsIGNhbGN1bGF0ZSkge1xuICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgaWYgKGUuenJYICE9IG51bGwpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuXG4gIHZhciBldmVudFR5cGUgPSBlLnR5cGU7XG4gIHZhciBpc1RvdWNoID0gZXZlbnRUeXBlICYmIGV2ZW50VHlwZS5pbmRleE9mKCd0b3VjaCcpID49IDA7XG5cbiAgaWYgKCFpc1RvdWNoKSB7XG4gICAgY2xpZW50VG9Mb2NhbChlbCwgZSwgZSwgY2FsY3VsYXRlKTtcbiAgICBlLnpyRGVsdGEgPSBlLndoZWVsRGVsdGEgPyBlLndoZWVsRGVsdGEgLyAxMjAgOiAtKGUuZGV0YWlsIHx8IDApIC8gMztcbiAgfSBlbHNlIHtcbiAgICB2YXIgdG91Y2ggPSBldmVudFR5cGUgIT0gJ3RvdWNoZW5kJyA/IGUudGFyZ2V0VG91Y2hlc1swXSA6IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgdG91Y2ggJiYgY2xpZW50VG9Mb2NhbChlbCwgdG91Y2gsIGUsIGNhbGN1bGF0ZSk7XG4gIH0gLy8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodDsgb3RoZXJ3aXNlOiAwO1xuICAvLyBTZWUgalF1ZXJ5OiBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iL21hc3Rlci9zcmMvZXZlbnQuanNcbiAgLy8gSWYgZS53aGljaCBoYXMgYmVlbiBkZWZpbmVkLCBpZiBtYXkgYmUgcmVhZG9ubHksXG4gIC8vIHNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQvd2hpY2hcblxuXG4gIHZhciBidXR0b24gPSBlLmJ1dHRvbjtcblxuICBpZiAoZS53aGljaCA9PSBudWxsICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIE1PVVNFX0VWRU5UX1JFRy50ZXN0KGUudHlwZSkpIHtcbiAgICBlLndoaWNoID0gYnV0dG9uICYgMSA/IDEgOiBidXR0b24gJiAyID8gMyA6IGJ1dHRvbiAmIDQgPyAyIDogMDtcbiAgfVxuXG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBoYW5kbGVyKSB7XG4gIGlmIChpc0RvbUxldmVsMikge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcik7XG4gIH0gZWxzZSB7XG4gICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIG5hbWUsIGhhbmRsZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGhhbmRsZXIpIHtcbiAgaWYgKGlzRG9tTGV2ZWwyKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5kZXRhY2hFdmVudCgnb24nICsgbmFtZSwgaGFuZGxlcik7XG4gIH1cbn1cbi8qKlxuICogcHJldmVudERlZmF1bHQgYW5kIHN0b3BQcm9wYWdhdGlvbi5cbiAqIE5vdGljZTogZG8gbm90IGRvIHRoYXQgaW4genJlbmRlci4gVXBwZXIgYXBwbGljYXRpb25cbiAqIGRvIHRoYXQgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2V2ZW50XG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0ge0V2ZW50fSBlIDogZXZlbnTlr7nosaFcbiAqL1xuXG5cbnZhciBzdG9wID0gaXNEb21MZXZlbDIgPyBmdW5jdGlvbiAoZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbn0gOiBmdW5jdGlvbiAoZSkge1xuICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIG5vdExlZnRNb3VzZShlKSB7XG4gIC8vIElmIGUud2hpY2ggaXMgdW5kZWZpbmVkLCBjb25zaWRlcmVkIGFzIGxlZnQgbW91c2UgZXZlbnQuXG4gIHJldHVybiBlLndoaWNoID4gMTtcbn0gLy8g5YGa5ZCR5LiK5YW85a65XG5cblxuZXhwb3J0cy5jbGllbnRUb0xvY2FsID0gY2xpZW50VG9Mb2NhbDtcbmV4cG9ydHMubm9ybWFsaXplRXZlbnQgPSBub3JtYWxpemVFdmVudDtcbmV4cG9ydHMuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXI7XG5leHBvcnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyO1xuZXhwb3J0cy5zdG9wID0gc3RvcDtcbmV4cG9ydHMubm90TGVmdE1vdXNlID0gbm90TGVmdE1vdXNlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL2V2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX2V2ZW50ID0gcmVxdWlyZShcIi4uL2NvcmUvZXZlbnRcIik7XG5cbnZhciBhZGRFdmVudExpc3RlbmVyID0gX2V2ZW50LmFkZEV2ZW50TGlzdGVuZXI7XG52YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IF9ldmVudC5yZW1vdmVFdmVudExpc3RlbmVyO1xudmFyIG5vcm1hbGl6ZUV2ZW50ID0gX2V2ZW50Lm5vcm1hbGl6ZUV2ZW50O1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIEV2ZW50ZnVsID0gcmVxdWlyZShcIi4uL21peGluL0V2ZW50ZnVsXCIpO1xuXG52YXIgZW52ID0gcmVxdWlyZShcIi4uL2NvcmUvZW52XCIpO1xuXG52YXIgR2VzdHVyZU1nciA9IHJlcXVpcmUoXCIuLi9jb3JlL0dlc3R1cmVNZ3JcIik7XG5cbnZhciBUT1VDSF9DTElDS19ERUxBWSA9IDMwMDtcbnZhciBtb3VzZUhhbmRsZXJOYW1lcyA9IFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2V3aGVlbCcsICdtb3VzZW91dCcsICdtb3VzZXVwJywgJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnY29udGV4dG1lbnUnXTtcbnZhciB0b3VjaEhhbmRsZXJOYW1lcyA9IFsndG91Y2hzdGFydCcsICd0b3VjaGVuZCcsICd0b3VjaG1vdmUnXTtcbnZhciBwb2ludGVyRXZlbnROYW1lcyA9IHtcbiAgcG9pbnRlcmRvd246IDEsXG4gIHBvaW50ZXJ1cDogMSxcbiAgcG9pbnRlcm1vdmU6IDEsXG4gIHBvaW50ZXJvdXQ6IDFcbn07XG52YXIgcG9pbnRlckhhbmRsZXJOYW1lcyA9IHpyVXRpbC5tYXAobW91c2VIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBubSA9IG5hbWUucmVwbGFjZSgnbW91c2UnLCAncG9pbnRlcicpO1xuICByZXR1cm4gcG9pbnRlckV2ZW50TmFtZXNbbm1dID8gbm0gOiBuYW1lO1xufSk7XG5cbmZ1bmN0aW9uIGV2ZW50TmFtZUZpeChuYW1lKSB7XG4gIHJldHVybiBuYW1lID09PSAnbW91c2V3aGVlbCcgJiYgZW52LmJyb3dzZXIuZmlyZWZveCA/ICdET01Nb3VzZVNjcm9sbCcgOiBuYW1lO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzR2VzdHVyZShwcm94eSwgZXZlbnQsIHN0YWdlKSB7XG4gIHZhciBnZXN0dXJlTWdyID0gcHJveHkuX2dlc3R1cmVNZ3I7XG4gIHN0YWdlID09PSAnc3RhcnQnICYmIGdlc3R1cmVNZ3IuY2xlYXIoKTtcbiAgdmFyIGdlc3R1cmVJbmZvID0gZ2VzdHVyZU1nci5yZWNvZ25pemUoZXZlbnQsIHByb3h5LmhhbmRsZXIuZmluZEhvdmVyKGV2ZW50LnpyWCwgZXZlbnQuenJZLCBudWxsKS50YXJnZXQsIHByb3h5LmRvbSk7XG4gIHN0YWdlID09PSAnZW5kJyAmJiBnZXN0dXJlTWdyLmNsZWFyKCk7IC8vIERvIG5vdCBkbyBhbnkgcHJldmVudERlZmF1bHQgaGVyZS4gVXBwZXIgYXBwbGljYXRpb24gZG8gdGhhdCBpZiBuZWNlc3NhcnkuXG5cbiAgaWYgKGdlc3R1cmVJbmZvKSB7XG4gICAgdmFyIHR5cGUgPSBnZXN0dXJlSW5mby50eXBlO1xuICAgIGV2ZW50Lmdlc3R1cmVFdmVudCA9IHR5cGU7XG4gICAgcHJveHkuaGFuZGxlci5kaXNwYXRjaFRvRWxlbWVudCh7XG4gICAgICB0YXJnZXQ6IGdlc3R1cmVJbmZvLnRhcmdldFxuICAgIH0sIHR5cGUsIGdlc3R1cmVJbmZvLmV2ZW50KTtcbiAgfVxufSAvLyBmdW5jdGlvbiBvbk1TR2VzdHVyZUNoYW5nZShwcm94eSwgZXZlbnQpIHtcbi8vICAgICBpZiAoZXZlbnQudHJhbnNsYXRpb25YIHx8IGV2ZW50LnRyYW5zbGF0aW9uWSkge1xuLy8gICAgICAgICAvLyBtb3VzZW1vdmUgaXMgY2FycmllZCBieSBNU0dlc3R1cmUgdG8gcmVkdWNlIHRoZSBzZW5zaXRpdml0eS5cbi8vICAgICAgICAgcHJveHkuaGFuZGxlci5kaXNwYXRjaFRvRWxlbWVudChldmVudC50YXJnZXQsICdtb3VzZW1vdmUnLCBldmVudCk7XG4vLyAgICAgfVxuLy8gICAgIGlmIChldmVudC5zY2FsZSAhPT0gMSkge1xuLy8gICAgICAgICBldmVudC5waW5jaFggPSBldmVudC5vZmZzZXRYO1xuLy8gICAgICAgICBldmVudC5waW5jaFkgPSBldmVudC5vZmZzZXRZO1xuLy8gICAgICAgICBldmVudC5waW5jaFNjYWxlID0gZXZlbnQuc2NhbGU7XG4vLyAgICAgICAgIHByb3h5LmhhbmRsZXIuZGlzcGF0Y2hUb0VsZW1lbnQoZXZlbnQudGFyZ2V0LCAncGluY2gnLCBldmVudCk7XG4vLyAgICAgfVxuLy8gfVxuXG4vKipcbiAqIFByZXZlbnQgbW91c2UgZXZlbnQgZnJvbSBiZWluZyBkaXNwYXRjaGVkIGFmdGVyIFRvdWNoIEV2ZW50cyBhY3Rpb25cbiAqIEBzZWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9kZWx0YWtvc2gvaGFuZGpzL2Jsb2IvbWFzdGVyL3NyYy9oYW5kLmJhc2UuanM+XG4gKiAxLiBNb2JpbGUgYnJvd3NlcnMgZGlzcGF0Y2ggbW91c2UgZXZlbnRzIDMwMG1zIGFmdGVyIHRvdWNoZW5kLlxuICogMi4gQ2hyb21lIGZvciBBbmRyb2lkIGRpc3BhdGNoIG1vdXNlZG93biBmb3IgbG9uZy10b3VjaCBhYm91dCA2NTBtc1xuICogUmVzdWx0OiBCbG9ja2luZyBNb3VzZSBFdmVudHMgZm9yIDcwMG1zLlxuICovXG5cblxuZnVuY3Rpb24gc2V0VG91Y2hUaW1lcihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5fdG91Y2hpbmcgPSB0cnVlO1xuICBjbGVhclRpbWVvdXQoaW5zdGFuY2UuX3RvdWNoVGltZXIpO1xuICBpbnN0YW5jZS5fdG91Y2hUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGluc3RhbmNlLl90b3VjaGluZyA9IGZhbHNlO1xuICB9LCA3MDApO1xufVxuXG52YXIgZG9tSGFuZGxlcnMgPSB7XG4gIC8qKlxuICAgKiBNb3VzZSBtb3ZlIGhhbmRsZXJcbiAgICogQGlubmVyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqL1xuICBtb3VzZW1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcbiAgICB0aGlzLnRyaWdnZXIoJ21vdXNlbW92ZScsIGV2ZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogTW91c2Ugb3V0IGhhbmRsZXJcbiAgICogQGlubmVyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqL1xuICBtb3VzZW91dDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuICAgIHZhciBlbGVtZW50ID0gZXZlbnQudG9FbGVtZW50IHx8IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG5cbiAgICBpZiAoZWxlbWVudCAhPSB0aGlzLmRvbSkge1xuICAgICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSAhPSA5KSB7XG4gICAgICAgIC8vIOW/veeVpeWMheWQq+WcqHJvb3TkuK3nmoRkb23lvJXotbfnmoRtb3VzZU91dFxuICAgICAgICBpZiAoZWxlbWVudCA9PT0gdGhpcy5kb20pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudHJpZ2dlcignbW91c2VvdXQnLCBldmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRvdWNo5byA5aeL5ZON5bqU5Ye95pWwXG4gICAqIEBpbm5lclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKi9cbiAgdG91Y2hzdGFydDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gRGVmYXVsdCBtb3VzZSBiZWhhdmlvdXIgc2hvdWxkIG5vdCBiZSBkaXNhYmxlZCBoZXJlLlxuICAgIC8vIEZvciBleGFtcGxlLCBwYWdlIG1heSBuZWVkcyB0byBiZSBzbGlkZWQuXG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpOyAvLyBNYXJrIHRvdWNoLCB3aGljaCBpcyB1c2VmdWwgaW4gZGlzdGluZ3Vpc2ggdG91Y2ggYW5kXG4gICAgLy8gbW91c2UgZXZlbnQgaW4gdXBwZXIgYXBwbGljYXRvaW4uXG5cbiAgICBldmVudC56ckJ5VG91Y2ggPSB0cnVlO1xuICAgIHRoaXMuX2xhc3RUb3VjaE1vbWVudCA9IG5ldyBEYXRlKCk7XG4gICAgcHJvY2Vzc0dlc3R1cmUodGhpcywgZXZlbnQsICdzdGFydCcpOyAvLyBJbiB0b3VjaCBkZXZpY2UsIHRyaWdnZXIgYG1vdXNlbW92ZWAoYG1vdXNlb3ZlcmApIHNob3VsZFxuICAgIC8vIGJlIHRyaWdnZXJlZCwgYW5kIG11c3QgYmVmb3JlIGBtb3VzZWRvd25gIHRyaWdnZXJlZC5cblxuICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICBkb21IYW5kbGVycy5tb3VzZWRvd24uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgc2V0VG91Y2hUaW1lcih0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogVG91Y2jnp7vliqjlk43lupTlh73mlbBcbiAgICogQGlubmVyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqL1xuICB0b3VjaG1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTsgLy8gTWFyayB0b3VjaCwgd2hpY2ggaXMgdXNlZnVsIGluIGRpc3Rpbmd1aXNoIHRvdWNoIGFuZFxuICAgIC8vIG1vdXNlIGV2ZW50IGluIHVwcGVyIGFwcGxpY2F0b2luLlxuXG4gICAgZXZlbnQuenJCeVRvdWNoID0gdHJ1ZTtcbiAgICBwcm9jZXNzR2VzdHVyZSh0aGlzLCBldmVudCwgJ2NoYW5nZScpOyAvLyBNb3VzZSBtb3ZlIHNob3VsZCBhbHdheXMgYmUgdHJpZ2dlcmVkIG5vIG1hdHRlciB3aGV0aGVyXG4gICAgLy8gdGhlcmUgaXMgZ2VzdHJ1ZSBldmVudCwgYmVjYXVzZSBtb3VzZSBtb3ZlIGFuZCBwaW5jaCBtYXlcbiAgICAvLyBiZSB1c2VkIGF0IHRoZSBzYW1lIHRpbWUuXG5cbiAgICBkb21IYW5kbGVycy5tb3VzZW1vdmUuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgc2V0VG91Y2hUaW1lcih0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogVG91Y2jnu5PmnZ/lk43lupTlh73mlbBcbiAgICogQGlubmVyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqL1xuICB0b3VjaGVuZDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpOyAvLyBNYXJrIHRvdWNoLCB3aGljaCBpcyB1c2VmdWwgaW4gZGlzdGluZ3Vpc2ggdG91Y2ggYW5kXG4gICAgLy8gbW91c2UgZXZlbnQgaW4gdXBwZXIgYXBwbGljYXRvaW4uXG5cbiAgICBldmVudC56ckJ5VG91Y2ggPSB0cnVlO1xuICAgIHByb2Nlc3NHZXN0dXJlKHRoaXMsIGV2ZW50LCAnZW5kJyk7XG4gICAgZG9tSGFuZGxlcnMubW91c2V1cC5jYWxsKHRoaXMsIGV2ZW50KTsgLy8gRG8gbm90IHRyaWdnZXIgYG1vdXNlb3V0YCBoZXJlLCBpbiBzcGl0ZSBvZiBgbW91c2Vtb3ZlYChgbW91c2VvdmVyYCkgaXNcbiAgICAvLyB0cmlnZ2VyZWQgaW4gYHRvdWNoc3RhcnRgLiBUaGlzIHNlZW1zIHRvIGJlIGlsbG9naWNhbCwgYnV0IGJ5IHRoaXMgbWVjaGFuaXNtLFxuICAgIC8vIHdlIGNhbiBjb252ZW5pZW50bHkgaW1wbGVtZW50IFwiaG92ZXIgc3R5bGVcIiBpbiBib3RoIFBDIGFuZCB0b3VjaCBkZXZpY2UganVzdFxuICAgIC8vIGJ5IGxpc3RlbmluZyB0byBgbW91c2VvdmVyYCB0byBhZGQgXCJob3ZlciBzdHlsZVwiIGFuZCBsaXN0ZW5pbmcgdG8gYG1vdXNlb3V0YFxuICAgIC8vIHRvIHJlbW92ZSBcImhvdmVyIHN0eWxlXCIgb24gYW4gZWxlbWVudCwgd2l0aG91dCBhbnkgYWRkaXRpb25hbCBjb2RlIGZvclxuICAgIC8vIGNvbXBhdGliaWxpdHkuIChgbW91c2VvdXRgIHdpbGwgbm90IGJlIHRyaWdnZXJlZCBpbiBgdG91Y2hlbmRgLCBzbyBcImhvdmVyXG4gICAgLy8gc3R5bGVcIiB3aWxsIHJlbWFpbiBmb3IgdXNlciB2aWV3KVxuICAgIC8vIGNsaWNrIGV2ZW50IHNob3VsZCBhbHdheXMgYmUgdHJpZ2dlcmVkIG5vIG1hdHRlciB3aGV0aGVyXG4gICAgLy8gdGhlcmUgaXMgZ2VzdHJ1ZSBldmVudC4gU3lzdGVtIGNsaWNrIGNhbiBub3QgYmUgcHJldmVudGVkLlxuXG4gICAgaWYgKCtuZXcgRGF0ZSgpIC0gdGhpcy5fbGFzdFRvdWNoTW9tZW50IDwgVE9VQ0hfQ0xJQ0tfREVMQVkpIHtcbiAgICAgIGRvbUhhbmRsZXJzLmNsaWNrLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cblxuICAgIHNldFRvdWNoVGltZXIodGhpcyk7XG4gIH0sXG4gIHBvaW50ZXJkb3duOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBkb21IYW5kbGVycy5tb3VzZWRvd24uY2FsbCh0aGlzLCBldmVudCk7IC8vIGlmICh1c2VNU0d1ZXN0dXJlKHRoaXMsIGV2ZW50KSkge1xuICAgIC8vICAgICB0aGlzLl9tc0dlc3R1cmUuYWRkUG9pbnRlcihldmVudC5wb2ludGVySWQpO1xuICAgIC8vIH1cbiAgfSxcbiAgcG9pbnRlcm1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIEZJWE1FXG4gICAgLy8gcG9pbnRlcm1vdmUgaXMgc28gc2Vuc2l0aXZlIHRoYXQgaXQgYWx3YXlzIHRyaWdnZXJlZCB3aGVuXG4gICAgLy8gdGFwKGNsaWNrKSBvbiB0b3VjaCBzY3JlZW4sIHdoaWNoIGFmZmVjdCBzb21lIGp1ZGdlbWVudCBpblxuICAgIC8vIHVwcGVyIGFwcGxpY2F0aW9uLiBTbywgd2UgZG9udCBzdXBwb3J0IG1vdXNlbW92ZSBvbiBNUyB0b3VjaFxuICAgIC8vIGRldmljZSB5ZXQuXG4gICAgaWYgKCFpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpKSB7XG4gICAgICBkb21IYW5kbGVycy5tb3VzZW1vdmUuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9LFxuICBwb2ludGVydXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGRvbUhhbmRsZXJzLm1vdXNldXAuY2FsbCh0aGlzLCBldmVudCk7XG4gIH0sXG4gIHBvaW50ZXJvdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIHBvaW50ZXJvdXQgd2lsbCBiZSB0cmlnZ2VyZWQgd2hlbiB0YXAgb24gdG91Y2ggc2NyZWVuXG4gICAgLy8gKElFMTErL0VkZ2Ugb24gTVMgU3VyZmFjZSkgYWZ0ZXIgY2xpY2sgZXZlbnQgdHJpZ2dlcmVkLFxuICAgIC8vIHdoaWNoIGlzIGluY29uc2lzdGVudCB3aXRoIHRoZSBtb3Vzb3V0IGJlaGF2aW9yIHdlIGRlZmluZWRcbiAgICAvLyBpbiB0b3VjaGVuZC4gU28gd2UgdW5pZnkgdGhlbS5cbiAgICAvLyAoY2hlY2sgZG9tSGFuZGxlcnMudG91Y2hlbmQgZm9yIGRldGFpbGVkIGV4cGxhbmF0aW9uKVxuICAgIGlmICghaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSkge1xuICAgICAgZG9tSGFuZGxlcnMubW91c2VvdXQuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpIHtcbiAgdmFyIHBvaW50ZXJUeXBlID0gZXZlbnQucG9pbnRlclR5cGU7XG4gIHJldHVybiBwb2ludGVyVHlwZSA9PT0gJ3BlbicgfHwgcG9pbnRlclR5cGUgPT09ICd0b3VjaCc7XG59IC8vIGZ1bmN0aW9uIHVzZU1TR3Vlc3R1cmUoaGFuZGxlclByb3h5LCBldmVudCkge1xuLy8gICAgIHJldHVybiBpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpICYmICEhaGFuZGxlclByb3h5Ll9tc0dlc3R1cmU7XG4vLyB9XG4vLyBDb21tb24gaGFuZGxlcnNcblxuXG56clV0aWwuZWFjaChbJ2NsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNld2hlZWwnLCAnZGJsY2xpY2snLCAnY29udGV4dG1lbnUnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgZG9tSGFuZGxlcnNbbmFtZV0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgdGhpcy50cmlnZ2VyKG5hbWUsIGV2ZW50KTtcbiAgfTtcbn0pO1xuLyoqXG4gKiDkuLrmjqfliLbnsbvlrp7kvovliJ3lp4vljJZkb20g5LqL5Lu25aSE55CG5Ye95pWwXG4gKlxuICogQGlubmVyXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0hhbmRsZXJ9IGluc3RhbmNlIOaOp+WItuexu+WunuS+i1xuICovXG5cbmZ1bmN0aW9uIGluaXREb21IYW5kbGVyKGluc3RhbmNlKSB7XG4gIHpyVXRpbC5lYWNoKHRvdWNoSGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSA9IHpyVXRpbC5iaW5kKGRvbUhhbmRsZXJzW25hbWVdLCBpbnN0YW5jZSk7XG4gIH0pO1xuICB6clV0aWwuZWFjaChwb2ludGVySGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSA9IHpyVXRpbC5iaW5kKGRvbUhhbmRsZXJzW25hbWVdLCBpbnN0YW5jZSk7XG4gIH0pO1xuICB6clV0aWwuZWFjaChtb3VzZUhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0gPSBtYWtlTW91c2VIYW5kbGVyKGRvbUhhbmRsZXJzW25hbWVdLCBpbnN0YW5jZSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIG1ha2VNb3VzZUhhbmRsZXIoZm4sIGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5fdG91Y2hpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4uYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBIYW5kbGVyRG9tUHJveHkoZG9tKSB7XG4gIEV2ZW50ZnVsLmNhbGwodGhpcyk7XG4gIHRoaXMuZG9tID0gZG9tO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuXG4gIHRoaXMuX3RvdWNoaW5nID0gZmFsc2U7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLl90b3VjaFRpbWVyO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvR2VzdHVyZU1ncn1cbiAgICovXG5cbiAgdGhpcy5fZ2VzdHVyZU1nciA9IG5ldyBHZXN0dXJlTWdyKCk7XG4gIHRoaXMuX2hhbmRsZXJzID0ge307XG4gIGluaXREb21IYW5kbGVyKHRoaXMpO1xuXG4gIGlmIChlbnYucG9pbnRlckV2ZW50c1N1cHBvcnRlZCkge1xuICAgIC8vIE9ubHkgSUUxMSsvRWRnZVxuICAgIC8vIDEuIE9uIGRldmljZXMgdGhhdCBib3RoIGVuYWJsZSB0b3VjaCBhbmQgbW91c2UgKGUuZy4sIE1TIFN1cmZhY2UgYW5kIGxlbm92byBYMjQwKSxcbiAgICAvLyBJRTExKy9FZGdlIGRvIG5vdCB0cmlnZ2VyIHRvdWNoIGV2ZW50LCBidXQgdHJpZ2dlciBwb2ludGVyIGV2ZW50IGFuZCBtb3VzZSBldmVudFxuICAgIC8vIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgLy8gMi4gT24gTVMgU3VyZmFjZSwgaXQgcHJvYmFibGVseSBvbmx5IHRyaWdnZXIgbW91c2Vkb3duIGJ1dCBubyBtb3VzZXVwIHdoZW4gdGFwIG9uXG4gICAgLy8gc2NyZWVuLCB3aGljaCBkbyBub3Qgb2NjdXJzIGluIHBvaW50ZXIgZXZlbnQuXG4gICAgLy8gU28gd2UgdXNlIHBvaW50ZXIgZXZlbnQgdG8gYm90aCBkZXRlY3QgdG91Y2ggZ2VzdHVyZSBhbmQgbW91c2UgYmVoYXZpb3IuXG4gICAgbW91bnRIYW5kbGVycyhwb2ludGVySGFuZGxlck5hbWVzLCB0aGlzKTsgLy8gRklYTUVcbiAgICAvLyBOb3RlOiBNUyBHZXN0dXJlIHJlcXVpcmUgQ1NTIHRvdWNoLWFjdGlvbiBzZXQuIEJ1dCB0b3VjaC1hY3Rpb24gaXMgbm90IHJlbGlhYmxlLFxuICAgIC8vIHdoaWNoIGRvZXMgbm90IHByZXZlbnQgZGVmdWF1bHQgYmVoYXZpb3Igb2NjYXNpb25hbGx5ICh3aGljaCBtYXkgY2F1c2UgdmlldyBwb3J0XG4gICAgLy8gem9vbWVkIGluIGJ1dCB1c2UgY2FuIG5vdCB6b29tIGl0IGJhY2spLiBBbmQgZXZlbnQucHJldmVudERlZmF1bHQoKSBkb2VzIG5vdCB3b3JrLlxuICAgIC8vIFNvIHdlIGhhdmUgdG8gbm90IHRvIHVzZSBNU0dlc3R1cmUgYW5kIG5vdCB0byBzdXBwb3J0IHRvdWNobW92ZSBhbmQgcGluY2ggb24gTVNcbiAgICAvLyB0b3VjaCBzY3JlZW4uIEFuZCB3ZSBvbmx5IHN1cHBvcnQgY2xpY2sgYmVoYXZpb3Igb24gTVMgdG91Y2ggc2NyZWVuIG5vdy5cbiAgICAvLyBNUyBHZXN0dXJlIEV2ZW50IGlzIG9ubHkgc3VwcG9ydGVkIG9uIElFMTErL0VkZ2UgYW5kIG9uIFdpbmRvd3MgOCsuXG4gICAgLy8gV2UgZG9udCBzdXBwb3J0IHRvdWNoIG9uIElFIG9uIHdpbjcuXG4gICAgLy8gU2VlIDxodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2RuNDMzMjQzKHY9dnMuODUpLmFzcHg+XG4gICAgLy8gaWYgKHR5cGVvZiBNU0dlc3R1cmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAgICAgKHRoaXMuX21zR2VzdHVyZSA9IG5ldyBNU0dlc3R1cmUoKSkudGFyZ2V0ID0gZG9tOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAvLyAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ01TR2VzdHVyZUNoYW5nZScsIG9uTVNHZXN0dXJlQ2hhbmdlKTtcbiAgICAvLyB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVudi50b3VjaEV2ZW50c1N1cHBvcnRlZCkge1xuICAgICAgbW91bnRIYW5kbGVycyh0b3VjaEhhbmRsZXJOYW1lcywgdGhpcyk7IC8vIEhhbmRsZXIgb2YgJ21vdXNlb3V0JyBldmVudCBpcyBuZWVkZWQgaW4gdG91Y2ggbW9kZSwgd2hpY2ggd2lsbCBiZSBtb3VudGVkIGJlbG93LlxuICAgICAgLy8gYWRkRXZlbnRMaXN0ZW5lcihyb290LCAnbW91c2VvdXQnLCB0aGlzLl9tb3VzZW91dEhhbmRsZXIpO1xuICAgIH0gLy8gMS4gQ29uc2lkZXJpbmcgc29tZSBkZXZpY2VzIHRoYXQgYm90aCBlbmFibGUgdG91Y2ggYW5kIG1vdXNlIGV2ZW50IChsaWtlIG9uIE1TIFN1cmZhY2VcbiAgICAvLyBhbmQgbGVub3ZvIFgyNDAsIEBzZWUgIzIzNTApLCB3ZSBtYWtlIG1vdXNlIGV2ZW50IGJlIGFsd2F5cyBsaXN0ZW5lZCwgb3RoZXJ3aXNlXG4gICAgLy8gbW91c2UgZXZlbnQgY2FuIG5vdCBiZSBoYW5kbGUgaW4gdGhvc2UgZGV2aWNlcy5cbiAgICAvLyAyLiBPbiBNUyBTdXJmYWNlLCBDaHJvbWUgd2lsbCB0cmlnZ2VyIGJvdGggdG91Y2ggZXZlbnQgYW5kIG1vdXNlIGV2ZW50LiBIb3cgdG8gcHJldmVudFxuICAgIC8vIG1vdXNlZXZlbnQgYWZ0ZXIgdG91Y2ggZXZlbnQgdHJpZ2dlcmVkLCBzZWUgYHNldFRvdWNoVGltZXJgLlxuXG5cbiAgICBtb3VudEhhbmRsZXJzKG1vdXNlSGFuZGxlck5hbWVzLCB0aGlzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdW50SGFuZGxlcnMoaGFuZGxlck5hbWVzLCBpbnN0YW5jZSkge1xuICAgIHpyVXRpbC5lYWNoKGhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZG9tLCBldmVudE5hbWVGaXgobmFtZSksIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSk7XG4gICAgfSwgaW5zdGFuY2UpO1xuICB9XG59XG5cbnZhciBoYW5kbGVyRG9tUHJveHlQcm90byA9IEhhbmRsZXJEb21Qcm94eS5wcm90b3R5cGU7XG5cbmhhbmRsZXJEb21Qcm94eVByb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoYW5kbGVyTmFtZXMgPSBtb3VzZUhhbmRsZXJOYW1lcy5jb25jYXQodG91Y2hIYW5kbGVyTmFtZXMpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBoYW5kbGVyTmFtZXNbaV07XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLmRvbSwgZXZlbnROYW1lRml4KG5hbWUpLCB0aGlzLl9oYW5kbGVyc1tuYW1lXSk7XG4gIH1cbn07XG5cbmhhbmRsZXJEb21Qcm94eVByb3RvLnNldEN1cnNvciA9IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICB0aGlzLmRvbS5zdHlsZS5jdXJzb3IgPSBjdXJzb3JTdHlsZSB8fCAnZGVmYXVsdCc7XG59O1xuXG56clV0aWwubWl4aW4oSGFuZGxlckRvbVByb3h5LCBFdmVudGZ1bCk7XG52YXIgX2RlZmF1bHQgPSBIYW5kbGVyRG9tUHJveHk7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9kb20vSGFuZGxlclByb3h5LmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZXZlbnRVdGlsID0gcmVxdWlyZShcIi4vZXZlbnRcIik7XG5cbi8qKlxuICogT25seSBpbXBsZW1lbnRzIG5lZWRlZCBnZXN0dXJlcyBmb3IgbW9iaWxlLlxuICovXG52YXIgR2VzdHVyZU1nciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICovXG4gIHRoaXMuX3RyYWNrID0gW107XG59O1xuXG5HZXN0dXJlTWdyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEdlc3R1cmVNZ3IsXG4gIHJlY29nbml6ZTogZnVuY3Rpb24gKGV2ZW50LCB0YXJnZXQsIHJvb3QpIHtcbiAgICB0aGlzLl9kb1RyYWNrKGV2ZW50LCB0YXJnZXQsIHJvb3QpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3JlY29nbml6ZShldmVudCk7XG4gIH0sXG4gIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdHJhY2subGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgX2RvVHJhY2s6IGZ1bmN0aW9uIChldmVudCwgdGFyZ2V0LCByb290KSB7XG4gICAgdmFyIHRvdWNoZXMgPSBldmVudC50b3VjaGVzO1xuXG4gICAgaWYgKCF0b3VjaGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRyYWNrSXRlbSA9IHtcbiAgICAgIHBvaW50czogW10sXG4gICAgICB0b3VjaGVzOiBbXSxcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b3VjaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgdG91Y2ggPSB0b3VjaGVzW2ldO1xuICAgICAgdmFyIHBvcyA9IGV2ZW50VXRpbC5jbGllbnRUb0xvY2FsKHJvb3QsIHRvdWNoLCB7fSk7XG4gICAgICB0cmFja0l0ZW0ucG9pbnRzLnB1c2goW3Bvcy56clgsIHBvcy56clldKTtcbiAgICAgIHRyYWNrSXRlbS50b3VjaGVzLnB1c2godG91Y2gpO1xuICAgIH1cblxuICAgIHRoaXMuX3RyYWNrLnB1c2godHJhY2tJdGVtKTtcbiAgfSxcbiAgX3JlY29nbml6ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHJlY29nbml6ZXJzKSB7XG4gICAgICBpZiAocmVjb2duaXplcnMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICB2YXIgZ2VzdHVyZUluZm8gPSByZWNvZ25pemVyc1tldmVudE5hbWVdKHRoaXMuX3RyYWNrLCBldmVudCk7XG5cbiAgICAgICAgaWYgKGdlc3R1cmVJbmZvKSB7XG4gICAgICAgICAgcmV0dXJuIGdlc3R1cmVJbmZvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBkaXN0KHBvaW50UGFpcikge1xuICB2YXIgZHggPSBwb2ludFBhaXJbMV1bMF0gLSBwb2ludFBhaXJbMF1bMF07XG4gIHZhciBkeSA9IHBvaW50UGFpclsxXVsxXSAtIHBvaW50UGFpclswXVsxXTtcbiAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG59XG5cbmZ1bmN0aW9uIGNlbnRlcihwb2ludFBhaXIpIHtcbiAgcmV0dXJuIFsocG9pbnRQYWlyWzBdWzBdICsgcG9pbnRQYWlyWzFdWzBdKSAvIDIsIChwb2ludFBhaXJbMF1bMV0gKyBwb2ludFBhaXJbMV1bMV0pIC8gMl07XG59XG5cbnZhciByZWNvZ25pemVycyA9IHtcbiAgcGluY2g6IGZ1bmN0aW9uICh0cmFjaywgZXZlbnQpIHtcbiAgICB2YXIgdHJhY2tMZW4gPSB0cmFjay5sZW5ndGg7XG5cbiAgICBpZiAoIXRyYWNrTGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBpbmNoRW5kID0gKHRyYWNrW3RyYWNrTGVuIC0gMV0gfHwge30pLnBvaW50cztcbiAgICB2YXIgcGluY2hQcmUgPSAodHJhY2tbdHJhY2tMZW4gLSAyXSB8fCB7fSkucG9pbnRzIHx8IHBpbmNoRW5kO1xuXG4gICAgaWYgKHBpbmNoUHJlICYmIHBpbmNoUHJlLmxlbmd0aCA+IDEgJiYgcGluY2hFbmQgJiYgcGluY2hFbmQubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIHBpbmNoU2NhbGUgPSBkaXN0KHBpbmNoRW5kKSAvIGRpc3QocGluY2hQcmUpO1xuICAgICAgIWlzRmluaXRlKHBpbmNoU2NhbGUpICYmIChwaW5jaFNjYWxlID0gMSk7XG4gICAgICBldmVudC5waW5jaFNjYWxlID0gcGluY2hTY2FsZTtcbiAgICAgIHZhciBwaW5jaENlbnRlciA9IGNlbnRlcihwaW5jaEVuZCk7XG4gICAgICBldmVudC5waW5jaFggPSBwaW5jaENlbnRlclswXTtcbiAgICAgIGV2ZW50LnBpbmNoWSA9IHBpbmNoQ2VudGVyWzFdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3BpbmNoJyxcbiAgICAgICAgdGFyZ2V0OiB0cmFja1swXS50YXJnZXQsXG4gICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgfTtcbiAgICB9XG4gIH0gLy8gT25seSBwaW5jaCBjdXJyZW50bHkuXG5cbn07XG52YXIgX2RlZmF1bHQgPSBHZXN0dXJlTWdyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29yZS9HZXN0dXJlTWdyLmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQk/oioLngrlcclxuICogMS5CT+aYr+S4gOS4quefqeW9olxyXG4gKiAyLkJP5pyJ5ZCN5a2XXHJcbiAqIDMuQk/mnInkuovku7blhrPnrZZbXe+8jOWPjOWHu+S6i+S7tuWGs+etluW8ueWHuuivpuaDhVxyXG4gKiA0LkJP5pyJ5aSW6ZSu5bGe5oCnW11cclxuICogNS5CT+acieWtkEJPXHJcbiAqIDYu5b2T5YmNQk/nibnmrorpopzoibLmmL7npLpcclxuICogNy7lj4zlh7tCT+W8ueWHukJP5bGe5oCn5Lul5Y+K5bGe5oCn5LqL5Lu25Yaz562W6aG16Z2iXHJcbiAqIEBtb2R1bGUgZmlzaC10b3BvLWJvL25vZGUvQm9Ob2RlXHJcbiAqIENyZWF0ZWQgYnkgbWFqaWFuYW4gb24gMTYvNS8xOS5cclxuICovXHJcblxyXG4gICAgdmFyIENvbnN0ID0gcmVxdWlyZSgnLi4vbW9kZWxzL0NvbnN0Jyk7XHJcbiAgICB2YXIgQm9OYW1lID0gcmVxdWlyZSgnLi4vbm9kZS9Cb05hbWUnKTtcclxuICAgIHZhciBFdmVudERlY2lzaW9uID0gcmVxdWlyZSgnLi4vbm9kZS9FdmVudERlY2lzaW9uTm9kZScpO1xyXG4gICAgdmFyIExpbmUgPSByZXF1aXJlKCcuLi9ub2RlL0xpbmVOb2RlJyk7XHJcbiAgICB2YXIgQm9BdHRyID0gcmVxdWlyZSgnLi4vbm9kZS9Cb0F0dHJOb2RlJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBub2RlT3B0aW9ucyA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHt7XHJcbiAgICAgKiAgICAgICAgICBpZDogU3RyaW5nIEJP5Li76ZSuLFxyXG4gICAgICogICAgICAgICAgbmFtZTogU3RyaW5nIEJP5ZCN5a2XLFxyXG4gICAgICogICAgICAgICAgYm9FdmVudEFycjogW10gQk/kuovku7blhrPnrZbmlbDnu4QsXHJcbiAgICAgKiAgICAgICAgICBib0F0dHJBcnI6IFtdIEJP5bGe5oCn5pWw57uEXHJcbiAgICAgKiAgICAgICAgICB9fSBib0RhdGEsIGJv5pWw5o2u5a+56LGhXHJcbiAgICAgKiBAcGFyYW0ge3tcclxuICAgICAqICAgICAgICAgIHN0YXJ0UG9zOiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9IOi1t+Wni+S9jee9rixcclxuICAgICAqICAgICAgICAgIGRpc3BsYXlBdHRyRGF0YVR5cGU6IGJvb2xlYW4g5piv5ZCm5pi+56S65bGe5oCn5pWw5o2u57G75Z6LLFxyXG4gICAgICogICAgICAgICAgZGlzcGxheUF0dHJFdmVudDogYm9vbGVhbiDmmK/lkKbmmL7npLrlsZ7mgKfkuovku7blhrPnrZYsXHJcbiAgICAgKiAgICAgICAgICBib0NsaWNrYWJsZTogYm9vbGVhbiBCT+aYr+WQpuaUr+aMgeeCueWHu+S6i+S7tiwg5Y+v56m6IOm7mOiupGZhbHNlXHJcbiAgICAgKiAgICAgICAgICBib1BvcHVwT3B0czogT2JqZWN0IEJP5by55Ye66aG16Z2i5Y+C5pWw77yMdXJsLHdpZHRoLGhlaWdodOetiVxyXG4gICAgICogICAgICAgICAgYm9FdmVudENsaWNrYWJsZTogYm9vbGVhbiBCT+S6i+S7tuWGs+etluaYr+WQpuaUr+aMgeeCueWHu+S6i+S7tiwg5Y+v56m6IOm7mOiupGZhbHNlXHJcbiAgICAgKiAgICAgICAgICBib0V2ZW50UG9wdXBPcHRzOiBPYmplY3QgQk/kuovku7blhrPnrZblvLnlh7rpobXpnaLlj4LmlbDvvIx1cmwsd2lkdGgsaGVpZ2h0562JXHJcbiAgICAgKiAgICAgICAgICBiaW5kQm9DbGlja0V2ZW50OiBmdW5jdGlvbihvcHRpb25zKSBCT+eCueWHu+S6i+S7tu+8jOi/lOWbnuWHveaVsOWPguaVsOS4um9wdGlvbnPvvIzlroPnmoTlsZ7mgKfmnIlEQVRB562JXHJcbiAgICAgKiAgICAgICAgICBhdHRyRXZlbnRDbGlja2FibGU6IGJvb2xlYW4gQk/lsZ7mgKfkuovku7blhrPnrZbmmK/lkKbmlK/mjIHngrnlh7vkuovku7YsIOWPr+epuiDpu5jorqRmYWxzZVxyXG4gICAgICogICAgICAgICAgYXR0ckV2ZW50UG9wdXBPcHRzOiBPYmplY3Qg54K55Ye7Qk/lsZ7mgKfkuovku7blhrPnrZblvLnlh7rpobXpnaLlj4LmlbDvvIx1cmwsd2lkdGgsaGVpZ2h0562JXHJcbiAgICAgKiAgICAgICAgICBpc0N1cnJlbnQ6IGJvb2xlYW4g5piv5ZCm5Li65b2T5YmNQk9cclxuICAgICAqICAgICAgICAgIH19IG9wdHNcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBCTyhib0RhdGEsIG9wdHMpIHtcclxuICAgICAgICBub2RlT3B0aW9ucyA9IG9wdHM7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJP5pWw5o2uXHJcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2RhdGEgPSBib0RhdGE7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOWIneWni+WdkOagh++8jOeUqOS6juacgOWQjueUu0JP55+p5b2iXHJcbiAgICAgICAgICogQHR5cGUge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9vcmlTdGFydFBvcyA9IG9wdHMuc3RhcnRQb3M7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOavj+S4quaOp+S7tueahOi1t+Wni+WPgueFp+WdkOagh++8jOavj+S4quaOp+S7tueUu+WujOS5i+WQjumDveS8mumHjeaWsOiuoeeul1xyXG4gICAgICAgICAqIEB0eXBlIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fbmV4dFN0YXJ0UG9zID0ge1xyXG4gICAgICAgICAgICB4OiBvcHRzLnN0YXJ0UG9zLngsXHJcbiAgICAgICAgICAgIHk6IG9wdHMuc3RhcnRQb3MueVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOaYr+WQpuaYvuekuuWxnuaAp+aVsOaNruexu+Wei1xyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fZGlzcGxheUF0dHJEYXRhVHlwZSA9IG9wdHMuZGlzcGxheUF0dHJEYXRhVHlwZSB8fCBmYWxzZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5piv5ZCm5pi+56S65bGe5oCn5LqL5Lu25Yaz562WXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9kaXNwbGF5QXR0ckV2ZW50ID0gb3B0cy5kaXNwbGF5QXR0ckV2ZW50IHx8IGZhbHNlO1xyXG5cclxuICAgICAgICAvL1RPRE9cclxuICAgICAgICBpZiAodGhpcy5fZGlzcGxheUF0dHJFdmVudCkge1xyXG4gICAgICAgICAgICBDb25zdC5CT19OT0RFX1dJRFRIID0gQ29uc3QuQk9fTk9ERV9XSURUSCAqIDM7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9kaXNwbGF5QXR0ckRhdGFUeXBlKSB7XHJcbiAgICAgICAgICAgIENvbnN0LkJPX05PREVfV0lEVEggPSBDb25zdC5CT19OT0RFX1dJRFRIICogMS41O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5piv5ZCm5pSv5oyB54K55Ye7XHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9ib0NsaWNrYWJsZSA9IG9wdHMuYm9DbGlja2FibGUgfHwgZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fYm9Qb3B1cE9wdHMgPSBvcHRzLmJvUG9wdXBPcHRzO1xyXG4gICAgICAgIHRoaXMuX2JvRXZlbnRDbGlja2FibGUgPSBvcHRzLmJvRXZlbnRDbGlja2FibGUgfHwgZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fYm9FdmVudFBvcHVwT3B0cyA9IG9wdHMuYm9FdmVudFBvcHVwT3B0cztcclxuICAgICAgICB0aGlzLl9hdHRyRXZlbnRDbGlja2FibGUgPSBvcHRzLmF0dHJFdmVudENsaWNrYWJsZSB8fCBmYWxzZTtcclxuICAgICAgICB0aGlzLl9hdHRyRXZlbnRQb3B1cE9wdHMgPSBvcHRzLmF0dHJFdmVudFBvcHVwT3B0cztcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5piv5ZCm5piv5b2T5YmNQk/vvIzlvZPliY1CT+eJueauiuminOiJsuaYvuekulxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5faXNDdXJyZW50ID0gb3B0cy5pc0N1cnJlbnQgfHwgZmFsc2U7XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCT+efqeW9oumrmOW6pu+8jOagueaNruWunumZheWGheWuueiuoeeul1xyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9ib1NoYXBlSGVpZ2h0ID0gMDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR3JvdXDlrrnlmahcclxuICAgICAgICAgKiBAdHlwZSB6cmVuZGVyL2dyYXBoaWMvR3JvdXBcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2dyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcclxuICAgICAgICB0aGlzLl9ncm91cC5uYW1lID0gdGhpcy5fZGF0YS5pZDtcclxuICAgICAgICB0aGlzLl9ncm91cC5zZXRDdXJyZW50ID0gZnVuY3Rpb24gKHN0eWxlKSB7XHJcbiAgICAgICAgICAgIC8vR3JvdXDmnIDlkI7kuIDkuKrmmK9CT+efqeW9olxyXG4gICAgICAgICAgICB2YXIgX2JvU2hhcGUgPSB0aGlzLmNoaWxkQXQodGhpcy5jaGlsZENvdW50KCkgLSAxKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihfYm9TaGFwZS5zdHlsZSwgc3R5bGUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy/pu5jorqTmlYjmnpxcclxuICAgICAgICAgICAgICAgIF9ib1NoYXBlLnN0eWxlLmZpbGwgPSAnIzY2Q0M5OSc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5fcmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHZhciBib1Byb3RvID0gQk8ucHJvdG90eXBlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+WQk/mlbTkvZPlm77lvaJcclxuICAgICAqIEByZXR1cm5zIHt6cmVuZGVyL2dyYXBoaWMvR3JvdXB9XHJcbiAgICAgKi9cclxuICAgIGJvUHJvdG8uZ2V0U2hhcGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3VwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluaVsOaNrlxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgYm9Qcm90by5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xyXG4gICAgfTtcclxuXHJcbiAgICBib1Byb3RvLmdldExheW91dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5sYXlvdXQ7XHJcbiAgICB9O1xyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva7lvZPliY1CT+eJueauiua8lOekuuaYvuekulxyXG4gICAgICovXHJcbiAgICBib1Byb3RvLnNldEN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy9CT+efqeW9ouaYr+acgOWQjuS4gOS4quWbvuW9olxyXG4gICAgICAgIHRoaXMuY2hpbGRBdCh0aGlzLmNoaWxkQ291bnQgLSAxKS5zdHlsZS5maWxsID0gJyM2NkNDOTknXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog55Sf5oiQQk/mlbTkvZPlm77lvaJcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGJvUHJvdG8uX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL0JP5ZCN5a2XXHJcbiAgICAgICAgdGhpcy5fY3JlYXRlQm9OYW1lKCk7XHJcblxyXG4gICAgICAgIC8vQk/kuovku7blhrPnrZZcclxuICAgICAgICB0aGlzLl9jcmVhdGVFdmVudERlY2lzaW9uKCk7XHJcblxyXG4gICAgICAgIC8vQk/lsZ7mgKdcclxuICAgICAgICB0aGlzLl9jcmVhdGVCb0F0dHIoKTtcclxuXHJcbiAgICAgICAgLy9CT+efqeW9olxyXG4gICAgICAgIHRoaXMuX2NyZWF0ZUJvU2hhcGUoKTtcclxuXHJcbiAgICAgICAgLy9UT0RPXHJcbiAgICAgICAgQ29uc3QuQk9fTk9ERV9XSURUSCA9IDE4MDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog55Sf5oiQQk/lkI3lrZfmlofmnKxcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGJvUHJvdG8uX2NyZWF0ZUJvTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2JvTmFtZVNoYXBlID0gQm9OYW1lKHRoaXMuX2RhdGEubmFtZSwgdGhpcy5fbmV4dFN0YXJ0UG9zKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2JvQ2xpY2thYmxlKSB7XHJcbiAgICAgICAgICAgIF9ib05hbWVTaGFwZS5jbGlja2FibGUgPSB0aGlzLl9ib0NsaWNrYWJsZTtcclxuICAgICAgICAgICAgX2JvTmFtZVNoYXBlLl9kYXRhID0gdGhpcy5fZGF0YTtcclxuICAgICAgICAgICAgX2JvTmFtZVNoYXBlLl9ib1BvcHVwT3B0cyA9IHRoaXMuX2JvUG9wdXBPcHRzO1xyXG4gICAgICAgICAgICBfYm9OYW1lU2hhcGUub25jbGljayA9IHRoaXMuX2NsaWNrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fZ3JvdXAuYWRkKF9ib05hbWVTaGFwZSk7XHJcbiAgICAgICAgdGhpcy5fY2FsTmV4dFNoYXBlU3RhcnRQb3MoX2JvTmFtZVNoYXBlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnlJ/miJBCT+S6i+S7tuWGs+etllxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgYm9Qcm90by5fY3JlYXRlRXZlbnREZWNpc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgLy/lpoLmnpzmsqHmnIlCT+S6i+S7tuWGs+etlu+8jOWImei/lOWbnlxyXG4gICAgICAgIGlmICghdGhpcy5fZGF0YS5ib0V2ZW50QXJyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBfYm9FdmVudEFyciA9IHRoaXMuX2RhdGEuYm9FdmVudEFycixcclxuICAgICAgICAgICAgX2JvRXZlbnRMZW4gPSBfYm9FdmVudEFyci5sZW5ndGgsXHJcbiAgICAgICAgICAgIF9ldmVudFNoYXBlLFxyXG4gICAgICAgICAgICBfZXZlbnRPcHRzID0ge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRQb3M6IHRoaXMuX25leHRTdGFydFBvcyxcclxuICAgICAgICAgICAgICAgIGNsaWNrYWJsZTogdGhpcy5fYm9FdmVudENsaWNrYWJsZSxcclxuICAgICAgICAgICAgICAgIHBvcHVwT3B0czogdGhpcy5fYm9FdmVudFBvcHVwT3B0cyxcclxuICAgICAgICAgICAgICAgIGJpbmRCb0NsaWNrRXZlbnQ6IG5vZGVPcHRpb25zLmJpbmRCb0NsaWNrRXZlbnRcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfYm9FdmVudExlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIF9ldmVudFNoYXBlID0gbmV3IEV2ZW50RGVjaXNpb24oX2JvRXZlbnRBcnJbaV0sIF9ldmVudE9wdHMpO1xyXG4gICAgICAgICAgICB0aGlzLl9ncm91cC5hZGQoX2V2ZW50U2hhcGUuZ2V0U2hhcGUoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbE5leHRTaGFwZVN0YXJ0UG9zKF9ldmVudFNoYXBlLmdldFNoYXBlKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog55Sf5oiQQk/lsZ7mgKdcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGJvUHJvdG8uX2NyZWF0ZUJvQXR0ciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL+WmguaenOayoeaciUJP5bGe5oCn77yM5YiZ6L+U5ZueXHJcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRhLmJvQXR0ckFycikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgX2JvQXR0ckFyciA9IHRoaXMuX2RhdGEuYm9BdHRyQXJyLFxyXG4gICAgICAgICAgICBfYm9BdHRyTGVuID0gX2JvQXR0ckFyci5sZW5ndGgsXHJcbiAgICAgICAgICAgIF9ib0F0dHJTaGFwZSwgX2xpbmVTaGFwZSxcclxuICAgICAgICAgICAgX2F0dHJFdmVudFN0YXJ0UG9zID0ge3g6IHRoaXMuX25leHRTdGFydFBvcy54ICsgQ29uc3QuQk9fTk9ERV9XSURUSCAvIDIsIHk6IHRoaXMuX25leHRTdGFydFBvcy55fTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfYm9BdHRyTGVuOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGkgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgX2xpbmVTaGFwZSA9IExpbmUuQm9MaW5lKHRoaXMuX25leHRTdGFydFBvcyk7IC8v5a6e57q/XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfbGluZVNoYXBlID0gTGluZS5BdHRyTGluZSh0aGlzLl9uZXh0U3RhcnRQb3MpOy8v6Jma57q/XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2dyb3VwLmFkZChfbGluZVNoYXBlKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2NhbE5leHRTaGFwZVN0YXJ0UG9zKF9saW5lU2hhcGUpO1xyXG5cclxuICAgICAgICAgICAgX2JvQXR0clNoYXBlID0gbmV3IEJvQXR0cihfYm9BdHRyQXJyW2ldLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zOiB0aGlzLl9uZXh0U3RhcnRQb3MsXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGFUeXBlOiB0aGlzLl9kaXNwbGF5QXR0ckRhdGFUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlFdmVudERlY2lzaW9uOiB0aGlzLl9kaXNwbGF5QXR0ckV2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Q2xpY2thYmxlOiB0aGlzLl9hdHRyRXZlbnRDbGlja2FibGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRQb3B1cE9wdHM6IHRoaXMuX2F0dHJFdmVudFBvcHVwT3B0cyxcclxuICAgICAgICAgICAgICAgICAgICBiaW5kQm9DbGlja0V2ZW50OiBub2RlT3B0aW9ucy5iaW5kQm9DbGlja0V2ZW50XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyb3VwLmFkZChfYm9BdHRyU2hhcGUuZ2V0U2hhcGUoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbE5leHRTaGFwZVN0YXJ0UG9zKF9ib0F0dHJTaGFwZS5nZXRTaGFwZSgpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3BsYXlBdHRyRXZlbnQpIHtcclxuICAgICAgICAgICAgX2xpbmVTaGFwZSA9IExpbmUuQXR0ckV2ZW50TGluZShfYXR0ckV2ZW50U3RhcnRQb3MsXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9uZXh0U3RhcnRQb3MueSAtIF9hdHRyRXZlbnRTdGFydFBvcy55XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyb3VwLmFkZChfbGluZVNoYXBlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiuoeeul+S4i+S4gOS4quWbvuW9oueahOW8gOWni+S9jee9ru+8jOS7peWPikJP55+p5b2i55qE6auY5bqmXHJcbiAgICAgKiBAcGFyYW0gY3VyU2hhcGUg5b2T5YmN5Zu+5b2iXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBib1Byb3RvLl9jYWxOZXh0U2hhcGVTdGFydFBvcyA9IGZ1bmN0aW9uIChjdXJTaGFwZSkge1xyXG4gICAgICAgIC8v5LiL5LiA5Zu+5b2i6LW35aeL5L2N572uXHJcbiAgICAgICAgdGhpcy5fbmV4dFN0YXJ0UG9zLnkgKz0gY3VyU2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0O1xyXG5cclxuICAgICAgICAvL0JP55+p5b2i6auY5bqm5aKe5YqgXHJcbiAgICAgICAgdGhpcy5fYm9TaGFwZUhlaWdodCArPSBjdXJTaGFwZS5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQ7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOeUn+aIkEJP55+p5b2iXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBib1Byb3RvLl9jcmVhdGVCb1NoYXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLl9ib1NoYXBlSGVpZ2h0ID4gQ29uc3QuQk9fTk9ERV9ERUZBVUxUX0hFSUdIVCA/XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ib1NoYXBlSGVpZ2h0IDogQ29uc3QuQk9fTk9ERV9ERUZBVUxUX0hFSUdIVCxcclxuICAgICAgICAgICAgc2hhcGUgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbdGhpcy5fb3JpU3RhcnRQb3MueCwgdGhpcy5fb3JpU3RhcnRQb3MueV0sXHJcblxyXG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICByOiA1LFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBDb25zdC5CT19OT0RFX1dJRFRILFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJ1c2hUeXBlOiAnYm90aCcsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogdGhpcy5faXNDdXJyZW50ID8gJyM2NkNDOTknIDogJ3doaXRlJyxcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICcjMDAwMDAwJyxcclxuICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZUNhcGU6ICdyb3VuZCdcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgemxldmVsOiAtMVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2JvQ2xpY2thYmxlKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLl9kYXRhID0gdGhpcy5fZGF0YTtcclxuICAgICAgICAgICAgc2hhcGUuX2JvUG9wdXBPcHRzID0gdGhpcy5fYm9Qb3B1cE9wdHM7XHJcblxyXG4gICAgICAgICAgICBzaGFwZS5jbGlja2FibGUgPSB0aGlzLl9ib0NsaWNrYWJsZTtcclxuICAgICAgICAgICAgc2hhcGUub25jbGljayA9IHRoaXMuX2NsaWNrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fZ3JvdXAuYWRkKHNoYXBlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDngrnlh7vkuovku7ZcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGJvUHJvdG8uX2NsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgREFUQTogdGhpcy5fZGF0YVxyXG4gICAgICAgICAgICB9LCB0aGlzLl9ib1BvcHVwT3B0cyk7XHJcblxyXG4gICAgICAgIG5vZGVPcHRpb25zLmJpbmRCb0NsaWNrRXZlbnQob3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQk87XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYm8vbGliL25vZGUvQm9Ob2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQ3JlYXRlZCBieSBtYWppYW5hbiBvbiAxNi81LzE5LlxyXG4gKi9cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgICAgICBCT19OT0RFX1dJRFRIOiAxODAsICAgIC8vQk/nn6nlvaLlrr3luqZcclxuICAgICAgICBCT19OT0RFX0RFRkFVTFRfSEVJR0hUOiA2MCxcdC8vQk/nn6nlvaLpu5jorqTpq5jluqbvvIzljbPlj6rmnIlCT+WQjeWtl+eahOaDheWGtVxyXG4gICAgICAgIEJPX05PREVfT0ZGU0VUX1g6IDkwLCAvL0JP55+p5b2i55qE5rC05bmz5YGP56e76YePPeefqeW9ouWuveW6pueahOS4gOiIrFxyXG4gICAgICAgIEJPX05PREVfT0ZGU0VUX1k6IDUwLCAvL0JP55+p5b2i55qE5Z6C55u05YGP56e76YePXHJcblxyXG4gICAgICAgIEJPX05BTUVfRk9OVDogJ2JvbGQgMThweCBBcmlhbCcsIC8vJ25vcm1hbCAxNnB4IHZlcmRhbmEnLCAgICAvL0JP5ZCN5a2X5paH5pys5qC35byPLFxyXG4gICAgICAgIEJPX05BTUVfUEFERElOR19UT1A6IDEwLCAgIC8vQk/lkI3lrZfkuI7nn6nlvaLkuIrovrnmoYbnmoTot53nprtcclxuICAgICAgICBCT19OQU1FX1BBRERJTkdfQk9UVE9NOiAxNSwgICAvL0JP5ZCN5a2X5LiO5LiL5LiA5Liq5o6n5Lu277yI5LqL5Lu25Yaz562W5oiW6ICF5qiq57q/77yJ55qE6Led56a7XHJcblxyXG4gICAgICAgIEJPX0VWRU5UX0hFSUdIVDogMjAsICAgLy9CT+S6i+S7tuWGs+etluWkmui+ueW9oumrmOW6plxyXG4gICAgICAgIEJPX0VWRU5UX1dJRFRIOiAxNDAsICAgLy9CT+S6i+S7tuWGs+etluWkmui+ueW9ouWuveW6plxyXG4gICAgICAgIEJPX0VWRU5UX0ZPTlQ6ICdub3JtYWwgMTRweCBBcmlhbCcsICAvL0JP5LqL5Lu25Yaz562W5ZCN5a2X5paH5pys5qC35byPXHJcblxyXG4gICAgICAgIEJPX0FUVFJfRk9OVDogJ25vcm1hbCAxNHB4IEFyaWFsJywgICAvL0JP5bGe5oCn5ZCN5a2X5paH5pys5qC35byPXHJcbiAgICAgICAgQk9fQVRUUl9QQURESU5HX1RPUDogNSwgICAvL0JP5bGe5oCn5ZCN5a2X5LiO55+p5b2i5LiK6L655qGG55qE6Led56a7XHJcbiAgICAgICAgQk9fQVRUUl9QQURESU5HX0JPVFRPTTogNSwgICAvL0JP5bGe5oCn5ZCN5a2X5LiO5LiL5LiA5Liq5o6n5Lu277yI5LqL5Lu25Yaz562W5oiW6ICF5qiq57q/77yJ55qE6Led56a7XHJcbiAgICAgICAgQk9fQVRUUl9QQURESU5HX0xFRlQ6IDUsICAgLy9CT+WxnuaAp+WQjeWtl+S4juefqeW9ouW3pui+ueahhueahOi3neemu1xyXG4gICAgICAgIEJPX0FUVFJfREFUQV9UWVBFX1BBRERJTkdfUklHSFQ6IDUsIC8vQk/lsZ7mgKfmlbDmja7nsbvlnovkuI7nn6nlvaLlj7PovrnmoYbnmoTot53nprtcclxuICAgICAgICBCT19BVFRSX0VWRU5UX1dJRFRIOiAxMzUsICAgLy9CT+WxnuaAp+S6i+S7tuWGs+etluWkmui+ueW9ouWuveW6plxyXG5cclxuICAgICAgICBMSU5FX0RBU0g6IDEwLCAgLy/omZrnur9cclxuICAgICAgICBSRUxBVElPTl9PRkZTRVQ6IDQwLCAgIC8v5YWz6IGU5YWz57O755qE5Yid5aeL5YGP56e76YeP77yM5Y2z56ys5LiA5q615oqY57q/5a695bqmXHJcbiAgICAgICAgUkVMQVRJT05fQVJST1dfV0lEVEg6IDEwLCAgLy/lhbPogZTlhbPns7vkuInop5Lnrq3lpLTmsLTlubPlrr3luqZcclxuICAgICAgICBSRUxBVElPTl9BUlJPV19IRUlHSFQ6IDUsICAvL+WFs+iBlOWFs+ezu+S4ieinkueureWktOWeguebtOmrmOW6pueahOS4gOWNilxyXG4gICAgICAgIFJFTEFUSU9OX1RFWFRfT0ZGU0VUX1g6IDEwLCAvL+WFs+iBlOWFs+ezu+aWh+Wtl+ivtOaYjuawtOW5s+WBj+enu+mHj1xyXG4gICAgICAgIFJFTEFUSU9OX1RFWFRfT0ZGU0VUX1k6IDUgLy/lhbPogZTlhbPns7vmloflrZfor7TmmI7lnoLnm7TlgY/np7vph49cclxuICAgIH07XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYm8vbGliL21vZGVscy9Db25zdC5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEJP5ZCN5a2XXHJcbiAqIEBtb2R1bGUgZmlzaC10b3BvLWJvL25vZGUvQm9OYW1lXHJcbiAqIENyZWF0ZWQgYnkgbWFqaWFuYW4gb24gMTYvNS8xOS5cclxuICovXHJcblxyXG4gICAgdmFyIENvbnN0ID0gcmVxdWlyZSgnLi4vbW9kZWxzL0NvbnN0Jyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCwgQk/lkI3lrZdcclxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gc3RhcnRQb3MsIOi1t+Wni+S9jee9rlxyXG4gICAgICogQHJldHVybnMge3pyZW5kZXIvZ3JhcGhpYy9UZXh0fVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEJvTmFtZSh0ZXh0LCBzdGFydFBvcykge1xyXG4gICAgICAgIHZhciB4ID0gc3RhcnRQb3MueCxcclxuICAgICAgICAgICAgeSA9IHN0YXJ0UG9zLnkgKyBDb25zdC5CT19OQU1FX1BBRERJTkdfVE9QLCAvL+aWh+Wtl+WIsOefqeW9ouS4iui+ueahhueahOi3neemuyBwYWRkaW5nLXRvcD0xMFxyXG5cclxuICAgICAgICAgICAgc2hhcGUgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0Rm9udDogQ29uc3QuQk9fTkFNRV9GT05ULFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2xlZnQnLCAgLy/pnaDlt6blvIDlp4vvvIzkvr/kuo7orqHnrpfkvY3nva5cclxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICd0b3AnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbeCwgeV1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8v5paH5a2X5bGF5Lit5pi+56S677yM6YeN5paw6K6h566X5paH5pys5rC05bmz6LW35aeL5L2N572uID0g55+p5b2i5rC05bmz6LW35aeL5L2N572uICsgKEJP55+p5b2i5a695bqmIC0g5paH5pys5a695bqmKS8yXHJcbiAgICAgICAgc2hhcGUucG9zaXRpb25bMF0gKz0gKENvbnN0LkJPX05PREVfV0lEVEggLSBzaGFwZS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCkgLyAyO1xyXG5cclxuICAgICAgICAvL+mHjeaWsOiuvue9rkJP5ZCN5a2X5Zu+5b2i6auY5bqmID0g5paH5pys6auY5bqmICsgcGFkZGluZy10b3AgKyBwYWRkaW5nLWJvdHRvbVxyXG4gICAgICAgIHNoYXBlLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCArPSBDb25zdC5CT19OQU1FX1BBRERJTkdfVE9QICsgQ29uc3QuQk9fTkFNRV9QQURESU5HX0JPVFRPTTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNoYXBlO1xyXG4gICAgfVxyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQm9OYW1lO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWJvL2xpYi9ub2RlL0JvTmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXHJcblxyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG5cclxuICAgIHZhciBwYXRoVG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3Rvb2wvcGF0aCcpO1xyXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcclxuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoJyk7XHJcbiAgICB2YXIgY29sb3JUb29sID0gcmVxdWlyZSgnenJlbmRlci9saWIvdG9vbC9jb2xvcicpO1xyXG4gICAgdmFyIG1hdHJpeCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvbWF0cml4Jyk7XHJcbiAgICB2YXIgdmVjdG9yID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS92ZWN0b3InKTtcclxuICAgIHZhciBHcmFkaWVudCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvR3JhZGllbnQnKTtcclxuICAgIHZhciBEcmFnZ2FibGUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9taXhpbi9EcmFnZ2FibGUnKTtcclxuXHJcbiAgICB2YXIgZ3JhcGhpYyA9IHt9O1xyXG4gICAgZ3JhcGhpYy5VdGlsID0genJVdGlsO1xyXG4gICAgZ3JhcGhpYy5Hcm91cCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cCcpO1xyXG5cclxuICAgIGdyYXBoaWMuSW1hZ2UgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5UZXh0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9UZXh0Jyk7XHJcblxyXG4gICAgZ3JhcGhpYy50ZXh0Q29udGFpbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dCcpO1xyXG5cclxuICAgIGdyYXBoaWMuQ2lyY2xlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUnKTtcclxuXHJcbiAgICBncmFwaGljLlNlY3RvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvU2VjdG9yJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5SaW5nID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SaW5nJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5Qb2x5Z29uID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5Qb2x5bGluZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUnKTtcclxuXHJcbiAgICBncmFwaGljLlJlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JlY3QnKTtcclxuXHJcbiAgICBncmFwaGljLkxpbmUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0xpbmUnKTtcclxuXHJcbiAgICBncmFwaGljLkJlemllckN1cnZlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZScpO1xyXG5cclxuICAgIGdyYXBoaWMuQXJjID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9BcmMnKTtcclxuXHJcbiAgICBncmFwaGljLkxpbmVhckdyYWRpZW50ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudCcpO1xyXG5cclxuICAgIGdyYXBoaWMuUmFkaWFsR3JhZGllbnQgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50Jyk7XHJcblxyXG4gICAgZ3JhcGhpYy5Cb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xyXG4gICAgZ3JhcGhpYy5TdGF0ZXMgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9TdGF0ZXMuanNcIik7XHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZCBzaGFwZSB3aXRoIHBhcmFtZXRlcnNcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5leHRlbmRTaGFwZSA9IGZ1bmN0aW9uIChvcHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIFBhdGguZXh0ZW5kKG9wdHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZCBwYXRoXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuZXh0ZW5kUGF0aCA9IGZ1bmN0aW9uIChwYXRoRGF0YSwgb3B0cykge1xyXG4gICAgICAgIHJldHVybiBwYXRoVG9vbC5leHRlbmRGcm9tU3RyaW5nKHBhdGhEYXRhLCBvcHRzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBwYXRoIGVsZW1lbnQgZnJvbSBwYXRoIGRhdGEgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aERhdGFcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSByZWN0XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xheW91dD1jb3Zlcl0gJ2NlbnRlcicgb3IgJ2NvdmVyJ1xyXG4gICAgICovXHJcbiAgICBncmFwaGljLm1ha2VQYXRoID0gZnVuY3Rpb24gKHBhdGhEYXRhLCBvcHRzLCByZWN0LCBsYXlvdXQpIHtcclxuICAgICAgICB2YXIgcGF0aCA9IHBhdGhUb29sLmNyZWF0ZUZyb21TdHJpbmcocGF0aERhdGEsIG9wdHMpO1xyXG4gICAgICAgIERyYWdnYWJsZS5jYWxsKHBhdGgpO1xyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIGlmIChyZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBhc3BlY3QgPSBib3VuZGluZ1JlY3Qud2lkdGggLyBib3VuZGluZ1JlY3QuaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGxheW91dCA9PT0gJ2NlbnRlcicpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNldCByZWN0IHRvIGNlbnRlciwga2VlcCB3aWR0aCAvIGhlaWdodCByYXRpby5cclxuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHJlY3QuaGVpZ2h0ICogYXNwZWN0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodDtcclxuICAgICAgICAgICAgICAgIGlmICh3aWR0aCA8PSByZWN0LndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY3ggPSByZWN0LnggKyByZWN0LndpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHZhciBjeSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMjtcclxuXHJcbiAgICAgICAgICAgICAgICByZWN0LnggPSBjeCAtIHdpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHJlY3QueSA9IGN5IC0gaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgICAgIHJlY3Qud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgICAgIHJlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVBhdGgocGF0aCwgcmVjdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB6clV0aWwuaW5oZXJpdHMocGF0aCwgRHJhZ2dhYmxlKTtcclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH07XHJcblxyXG4gICAgZ3JhcGhpYy5tZXJnZVBhdGggPSBwYXRoVG9vbC5tZXJnZVBhdGg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemUgYSBwYXRoIHRvIGZpdCB0aGUgcmVjdFxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IHBhdGhcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0XHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMucmVzaXplUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCByZWN0KSB7XHJcbiAgICAgICAgaWYgKCFwYXRoLmFwcGx5VHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBwYXRoUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XHJcblxyXG4gICAgICAgIHZhciBtID0gcGF0aFJlY3QuY2FsY3VsYXRlVHJhbnNmb3JtKHJlY3QpO1xyXG5cclxuICAgICAgICBwYXRoLmFwcGx5VHJhbnNmb3JtKG0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YiBwaXhlbCBvcHRpbWl6ZSBsaW5lIGZvciBjYW52YXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc2hhcGVdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLngxXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS55MV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueDJdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnkyXVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zdHlsZV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc3R5bGUubGluZVdpZHRoXVxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBNb2RpZmllZCBwYXJhbVxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemVMaW5lID0gZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgICAgdmFyIHN1YlBpeGVsT3B0aW1pemUgPSBncmFwaGljLnN1YlBpeGVsT3B0aW1pemU7XHJcbiAgICAgICAgdmFyIHNoYXBlID0gcGFyYW0uc2hhcGU7XHJcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHBhcmFtLnN0eWxlLmxpbmVXaWR0aDtcclxuXHJcbiAgICAgICAgaWYgKHJvdW5kKHNoYXBlLngxICogMikgPT09IHJvdW5kKHNoYXBlLngyICogMikpIHtcclxuICAgICAgICAgICAgc2hhcGUueDEgPSBzaGFwZS54MiA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueDEsIGxpbmVXaWR0aCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyb3VuZChzaGFwZS55MSAqIDIpID09PSByb3VuZChzaGFwZS55MiAqIDIpKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLnkxID0gc2hhcGUueTIgPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLnkxLCBsaW5lV2lkdGgsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyYW07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3ViIHBpeGVsIG9wdGltaXplIHJlY3QgZm9yIGNhbnZhc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zaGFwZV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueF1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUud2lkdGhdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLmhlaWdodF1cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc3R5bGVdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnN0eWxlLmxpbmVXaWR0aF1cclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gTW9kaWZpZWQgcGFyYW1cclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplUmVjdCA9IGZ1bmN0aW9uIChwYXJhbSkge1xyXG4gICAgICAgIHZhciBzdWJQaXhlbE9wdGltaXplID0gZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplO1xyXG4gICAgICAgIHZhciBzaGFwZSA9IHBhcmFtLnNoYXBlO1xyXG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBwYXJhbS5zdHlsZS5saW5lV2lkdGg7XHJcbiAgICAgICAgdmFyIG9yaWdpblggPSBzaGFwZS54O1xyXG4gICAgICAgIHZhciBvcmlnaW5ZID0gc2hhcGUueTtcclxuICAgICAgICB2YXIgb3JpZ2luV2lkdGggPSBzaGFwZS53aWR0aDtcclxuICAgICAgICB2YXIgb3JpZ2luSGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xyXG4gICAgICAgIHNoYXBlLnggPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLngsIGxpbmVXaWR0aCwgdHJ1ZSk7XHJcbiAgICAgICAgc2hhcGUueSA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueSwgbGluZVdpZHRoLCB0cnVlKTtcclxuICAgICAgICBzaGFwZS53aWR0aCA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICBzdWJQaXhlbE9wdGltaXplKG9yaWdpblggKyBvcmlnaW5XaWR0aCwgbGluZVdpZHRoLCBmYWxzZSkgLSBzaGFwZS54LFxyXG4gICAgICAgICAgICBvcmlnaW5XaWR0aCA9PT0gMCA/IDAgOiAxXHJcbiAgICAgICAgKTtcclxuICAgICAgICBzaGFwZS5oZWlnaHQgPSBNYXRoLm1heChcclxuICAgICAgICAgICAgc3ViUGl4ZWxPcHRpbWl6ZShvcmlnaW5ZICsgb3JpZ2luSGVpZ2h0LCBsaW5lV2lkdGgsIGZhbHNlKSAtIHNoYXBlLnksXHJcbiAgICAgICAgICAgIG9yaWdpbkhlaWdodCA9PT0gMCA/IDAgOiAxXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gcGFyYW07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3ViIHBpeGVsIG9wdGltaXplIGZvciBjYW52YXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gQ29vcmRpbmF0ZSwgc3VjaCBhcyB4LCB5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGluZVdpZHRoIFNob3VsZCBiZSBub25uZWdhdGl2ZSBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gcG9zaXRpdmVPck5lZ2F0aXZlIERlZmF1bHQgZmFsc2UgKG5lZ2F0aXZlKS5cclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gT3B0aW1pemVkIHBvc2l0aW9uLlxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemUgPSBmdW5jdGlvbiAocG9zaXRpb24sIGxpbmVXaWR0aCwgcG9zaXRpdmVPck5lZ2F0aXZlKSB7XHJcbiAgICAgICAgLy8gQXNzdXJlIHRoYXQgKHBvc2l0aW9uICsgbGluZVdpZHRoIC8gMikgaXMgbmVhciBpbnRlZ2VyIGVkZ2UsXHJcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGxpbmUgd2lsbCBiZSBmdXp6eSBpbiBjYW52YXMuXHJcbiAgICAgICAgdmFyIGRvdWJsZWRQb3NpdGlvbiA9IHJvdW5kKHBvc2l0aW9uICogMik7XHJcbiAgICAgICAgcmV0dXJuIChkb3VibGVkUG9zaXRpb24gKyByb3VuZChsaW5lV2lkdGgpKSAlIDIgPT09IDBcclxuICAgICAgICAgICAgPyBkb3VibGVkUG9zaXRpb24gLyAyXHJcbiAgICAgICAgICAgIDogKGRvdWJsZWRQb3NpdGlvbiArIChwb3NpdGl2ZU9yTmVnYXRpdmUgPyAxIDogLTEpKSAvIDI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZG9TaW5nbGVFbnRlckhvdmVyKGVsKSB7XHJcbiAgICAgICAgaWYgKGVsLl9faXNIb3Zlcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbC5fX2hvdmVyU3RsRGlydHkpIHtcclxuICAgICAgICAgICAgdmFyIHN0cm9rZSA9IGVsLnN0eWxlLnN0cm9rZTtcclxuICAgICAgICAgICAgdmFyIGZpbGwgPSBlbC5zdHlsZS5maWxsO1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGhvdmVyU3R5bGUgb24gbW91c2VvdmVyXHJcbiAgICAgICAgICAgIHZhciBob3ZlclN0eWxlID0gZWwuX19ob3ZlclN0bDtcclxuICAgICAgICAgICAgdmFyIGxpZnQgPSBjb2xvclRvb2wubGlmdDtcclxuICAgICAgICAgICAgaG92ZXJTdHlsZS5maWxsID0gaG92ZXJTdHlsZS5maWxsXHJcbiAgICAgICAgICAgICAgICB8fCAoZmlsbCAmJiAoZmlsbCBpbnN0YW5jZW9mIEdyYWRpZW50ID8gZmlsbCA6IGxpZnQoZmlsbCwgLTAuMSkpKTtcclxuICAgICAgICAgICAgaG92ZXJTdHlsZS5zdHJva2UgPSBob3ZlclN0eWxlLnN0cm9rZVxyXG4gICAgICAgICAgICAgICAgfHwgKHN0cm9rZSAmJiAoc3Ryb2tlIGluc3RhbmNlb2YgR3JhZGllbnQgPyBzdHJva2UgOiBsaWZ0KHN0cm9rZSwgLTAuMSkpKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBub3JtYWxTdHlsZSA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGhvdmVyU3R5bGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChob3ZlclN0eWxlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsU3R5bGVbbmFtZV0gPSBlbC5zdHlsZVtuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZWwuX19ub3JtYWxTdGwgPSBub3JtYWxTdHlsZTtcclxuXHJcbiAgICAgICAgICAgIGVsLl9faG92ZXJTdGxEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbC5zZXRTdHlsZShlbC5fX2hvdmVyU3RsKTtcclxuICAgICAgICBlbC56MiArPSAxO1xyXG5cclxuICAgICAgICBlbC5fX2lzSG92ZXIgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGRvU2luZ2xlTGVhdmVIb3ZlcihlbCkge1xyXG4gICAgICAgIGlmICghZWwuX19pc0hvdmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBub3JtYWxTdGwgPSBlbC5fX25vcm1hbFN0bDtcclxuICAgICAgICBub3JtYWxTdGwgJiYgZWwuc2V0U3R5bGUobm9ybWFsU3RsKTtcclxuICAgICAgICBlbC56MiAtPSAxO1xyXG5cclxuICAgICAgICBlbC5fX2lzSG92ZXIgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkb0VudGVySG92ZXIoZWwpIHtcclxuICAgICAgICAoZWwudHlwZSA9PT0gJ2dyb3VwJyB8fCBlbC50eXBlID09PSAnR3JvdXBOb2RlJylcclxuICAgICAgICAgICAgPyBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSAnZ3JvdXAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9TaW5nbGVFbnRlckhvdmVyKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgOiBkb1NpbmdsZUVudGVySG92ZXIoZWwpO1xyXG4gICAgfVxyXG4gICAgZ3JhcGhpYy5kb0VudGVySG92ZXIgPSBkb0VudGVySG92ZXI7XHJcbiAgICBmdW5jdGlvbiBkb0xlYXZlSG92ZXIoZWwpIHtcclxuICAgICAgICBlbC50eXBlID09PSAnZ3JvdXAnXHJcbiAgICAgICAgICAgID8gZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvU2luZ2xlTGVhdmVIb3ZlcihjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIDogZG9TaW5nbGVMZWF2ZUhvdmVyKGVsKTtcclxuICAgIH1cclxuICAgIGdyYXBoaWMuZG9MZWF2ZUhvdmVyID0gZG9MZWF2ZUhvdmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2V0RWxlbWVudEhvdmVyU3RsKGVsLCBob3ZlclN0bCkge1xyXG4gICAgICAgIC8vIElmIGVsZW1lbnQgaGFzIHNlcGNpZmllZCBob3ZlclN0eWxlLCB0aGVuIHVzZSBpdCBpbnN0ZWFkIG9mIGdpdmVuIGhvdmVyU3R5bGVcclxuICAgICAgICAvLyBPZnRlbiB1c2VkIHdoZW4gaXRlbSBncm91cCBoYXMgYSBsYWJlbCBlbGVtZW50IGFuZCBpdCdzIGhvdmVyU3R5bGUgaXMgZGlmZmVyZW50XHJcbiAgICAgICAgZWwuX19ob3ZlclN0bCA9IGVsLmhvdmVyU3R5bGUgfHwgaG92ZXJTdGwgfHwge307XHJcbiAgICAgICAgZWwuX19ob3ZlclN0bERpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGdyYXBoaWMuc2V0RWxlbWVudEhvdmVyU3RsID0gc2V0RWxlbWVudEhvdmVyU3RsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25FbGVtZW50TW91c2VPdmVyKCkge1xyXG4gICAgICAgIC8vIE9ubHkgaWYgZWxlbWVudCBpcyBub3QgaW4gZW1waGFzaXMgc3RhdHVzXHJcbiAgICAgICAgIXRoaXMuX19pc0VtcGhhc2lzICYmIGRvRW50ZXJIb3Zlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBvbkVsZW1lbnRNb3VzZU91dCgpIHtcclxuICAgICAgICAvLyBPbmx5IGlmIGVsZW1lbnQgaXMgbm90IGluIGVtcGhhc2lzIHN0YXR1c1xyXG4gICAgICAgICF0aGlzLl9faXNFbXBoYXNpcyAmJiBkb0xlYXZlSG92ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZW50ZXJFbXBoYXNpcygpIHtcclxuICAgICAgICB0aGlzLl9faXNFbXBoYXNpcyA9IHRydWU7XHJcbiAgICAgICAgZG9FbnRlckhvdmVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGxlYXZlRW1waGFzaXMoKSB7XHJcbiAgICAgICAgdGhpcy5fX2lzRW1waGFzaXMgPSBmYWxzZTtcclxuICAgICAgICBkb0xlYXZlSG92ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgaG92ZXIgc3R5bGUgb2YgZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtob3ZlclN0eWxlXVxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnNldEhvdmVyU3R5bGUgPSBmdW5jdGlvbiAoZWwsIGhvdmVyU3R5bGUpIHtcclxuICAgICAgICBlbC50eXBlID09PSAnZ3JvdXAnXHJcbiAgICAgICAgICAgID8gZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRIb3ZlclN0bChjaGlsZCwgaG92ZXJTdHlsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIDogc2V0RWxlbWVudEhvdmVyU3RsKGVsLCBob3ZlclN0eWxlKTtcclxuICAgICAgICAvLyBSZW1vdmUgcHJldmlvdXMgYm91bmQgaGFuZGxlcnNcclxuICAgICAgICBlbC5vbignbW91c2VvdmVyJywgb25FbGVtZW50TW91c2VPdmVyKVxyXG4gICAgICAgICAgLm9uKCdtb3VzZW91dCcsIG9uRWxlbWVudE1vdXNlT3V0KTtcclxuXHJcbiAgICAgICAgLy8gRW1waGFzaXMsIG5vcm1hbCBjYW4gYmUgdHJpZ2dlcmVkIG1hbnVhbGx5XHJcbiAgICAgICAgZWwub24oJ2VtcGhhc2lzJywgZW50ZXJFbXBoYXNpcylcclxuICAgICAgICAgIC5vbignbm9ybWFsJywgbGVhdmVFbXBoYXNpcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUgPSBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChlbC5fX25vcm1hbFN0bCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC5fX25vcm1hbFN0bC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLl9fbm9ybWFsU3RsW25hbWVdID0gb3B0aW9uc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGV4dCBvcHRpb24gaW4gdGhlIHN0eWxlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGV4dFN0eWxlXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBsYWJlbE1vZGVsXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5zZXRUZXh0ID0gZnVuY3Rpb24gKHRleHRTdHlsZSwgbGFiZWxNb2RlbCwgY29sb3IpIHtcclxuICAgICAgICB2YXIgbGFiZWxQb3NpdGlvbiA9IGxhYmVsTW9kZWwuZ2V0U2hhbGxvdygncG9zaXRpb24nKSB8fCAnaW5zaWRlJztcclxuICAgICAgICB2YXIgbGFiZWxDb2xvciA9IGxhYmVsUG9zaXRpb24uaW5kZXhPZignaW5zaWRlJykgPj0gMCA/ICd3aGl0ZScgOiBjb2xvcjtcclxuICAgICAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBsYWJlbE1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcclxuICAgICAgICB6clV0aWwuZXh0ZW5kKHRleHRTdHlsZSwge1xyXG4gICAgICAgICAgICB0ZXh0RGlzdGFuY2U6IGxhYmVsTW9kZWwuZ2V0U2hhbGxvdygnZGlzdGFuY2UnKSB8fCA1LFxyXG4gICAgICAgICAgICB0ZXh0Rm9udDogdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpLFxyXG4gICAgICAgICAgICB0ZXh0UG9zaXRpb246IGxhYmVsUG9zaXRpb24sXHJcbiAgICAgICAgICAgIHRleHRGaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSB8fCBsYWJlbENvbG9yXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGFuaW1hdGVPclNldFByb3BzKGlzVXBkYXRlLCBlbCwgcHJvcHMsIGFuaW1hdGFibGVNb2RlbCwgY2IpIHtcclxuICAgICAgICB2YXIgcG9zdGZpeCA9IGlzVXBkYXRlID8gJ1VwZGF0ZScgOiAnJztcclxuICAgICAgICB2YXIgZHVyYXRpb24gPSBhbmltYXRhYmxlTW9kZWxcclxuICAgICAgICAgICAgJiYgYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbkR1cmF0aW9uJyArIHBvc3RmaXgpO1xyXG4gICAgICAgIHZhciBhbmltYXRpb25FYXNpbmcgPSBhbmltYXRhYmxlTW9kZWxcclxuICAgICAgICAgICAgJiYgYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbkVhc2luZycgKyBwb3N0Zml4KTtcclxuXHJcbiAgICAgICAgYW5pbWF0YWJsZU1vZGVsICYmIGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KCdhbmltYXRpb24nKVxyXG4gICAgICAgICAgICA/IGVsLmFuaW1hdGVUbyhwcm9wcywgZHVyYXRpb24sIGFuaW1hdGlvbkVhc2luZywgY2IpXHJcbiAgICAgICAgICAgIDogKGVsLmF0dHIocHJvcHMpLCBjYiAmJiBjYigpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGdyYXBoaWMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24gYWNjb3JkaW5nIHRvIHRoZSBjb25maWd1cmF0aW9uIGluIHNlcmllc1xyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbYW5pbWF0YWJsZU1vZGVsXVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy51cGRhdGVQcm9wcyA9IHpyVXRpbC5jdXJyeShhbmltYXRlT3JTZXRQcm9wcywgdHJ1ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0IGdyYXBoaWMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24gYWNjb3JkaW5nIHRvIHRoZSBjb25maWd1cmF0aW9uIGluIHNlcmllc1xyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbYW5pbWF0YWJsZU1vZGVsXVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5pbml0UHJvcHMgPSB6clV0aWwuY3VycnkoYW5pbWF0ZU9yU2V0UHJvcHMsIGZhbHNlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0cmFuc2Zvcm0gbWF0cml4IG9mIHRhcmdldCAocGFyYW0gdGFyZ2V0KSxcclxuICAgICAqIGluIGNvb3JkaW5hdGUgb2YgaXRzIGFuY2VzdG9yIChwYXJhbSBhbmNlc3RvcilcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGV9IHRhcmdldFxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfSBhbmNlc3RvclxyXG4gICAgICovXHJcbiAgICBncmFwaGljLmdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0YXJnZXQsIGFuY2VzdG9yKSB7XHJcbiAgICAgICAgdmFyIG1hdCA9IG1hdHJpeC5pZGVudGl0eShbXSk7XHJcblxyXG4gICAgICAgIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSBhbmNlc3Rvcikge1xyXG4gICAgICAgICAgICBtYXRyaXgubXVsKG1hdCwgdGFyZ2V0LmdldExvY2FsVHJhbnNmb3JtKCksIG1hdCk7XHJcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbWF0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IHRyYW5zZm9ybSB0byBhbiB2ZXJ0ZXguXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2ZXJ0ZXggW3gsIHldXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0cmFuc2Zvcm0gVHJhbnNmb3JtIG1hdHJpeDogbGlrZSBbMSwgMCwgMCwgMSwgMCwgMF1cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGludmVydCBXaGV0aGVyIHVzZSBpbnZlcnQgbWF0cml4LlxyXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFt4LCB5XVxyXG4gICAgICovXHJcbiAgICBncmFwaGljLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKHZlcnRleCwgdHJhbnNmb3JtLCBpbnZlcnQpIHtcclxuICAgICAgICBpZiAoaW52ZXJ0KSB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IG1hdHJpeC5pbnZlcnQoW10sIHRyYW5zZm9ybSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0oW10sIHZlcnRleCwgdHJhbnNmb3JtKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uICdsZWZ0JyAncmlnaHQnICd0b3AnICdib3R0b20nXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0cmFuc2Zvcm0gVHJhbnNmb3JtIG1hdHJpeDogbGlrZSBbMSwgMCwgMCwgMSwgMCwgMF1cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGludmVydCBXaGV0aGVyIHVzZSBpbnZlcnQgbWF0cml4LlxyXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUcmFuc2Zvcm1lZCBkaXJlY3Rpb24uICdsZWZ0JyAncmlnaHQnICd0b3AnICdib3R0b20nXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMudHJhbnNmb3JtRGlyZWN0aW9uID0gZnVuY3Rpb24gKGRpcmVjdGlvbiwgdHJhbnNmb3JtLCBpbnZlcnQpIHtcclxuXHJcbiAgICAgICAgLy8gUGljayBhIGJhc2UsIGVuc3VyZSB0aGF0IHRyYW5zZm9ybSByZXN1bHQgd2lsbCBub3QgYmUgKDAsIDApLlxyXG4gICAgICAgIHZhciBoQmFzZSA9ICh0cmFuc2Zvcm1bNF0gPT09IDAgfHwgdHJhbnNmb3JtWzVdID09PSAwIHx8IHRyYW5zZm9ybVswXSA9PT0gMClcclxuICAgICAgICAgICAgPyAxIDogTWF0aC5hYnMoMiAqIHRyYW5zZm9ybVs0XSAvIHRyYW5zZm9ybVswXSk7XHJcbiAgICAgICAgdmFyIHZCYXNlID0gKHRyYW5zZm9ybVs0XSA9PT0gMCB8fCB0cmFuc2Zvcm1bNV0gPT09IDAgfHwgdHJhbnNmb3JtWzJdID09PSAwKVxyXG4gICAgICAgICAgICA/IDEgOiBNYXRoLmFicygyICogdHJhbnNmb3JtWzRdIC8gdHJhbnNmb3JtWzJdKTtcclxuXHJcbiAgICAgICAgdmFyIHZlcnRleCA9IFtcclxuICAgICAgICAgICAgZGlyZWN0aW9uID09PSAnbGVmdCcgPyAtaEJhc2UgOiBkaXJlY3Rpb24gPT09ICdyaWdodCcgPyBoQmFzZSA6IDAsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ3RvcCcgPyAtdkJhc2UgOiBkaXJlY3Rpb24gPT09ICdib3R0b20nID8gdkJhc2UgOiAwXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgdmVydGV4ID0gZ3JhcGhpYy5hcHBseVRyYW5zZm9ybSh2ZXJ0ZXgsIHRyYW5zZm9ybSwgaW52ZXJ0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHZlcnRleFswXSkgPiBNYXRoLmFicyh2ZXJ0ZXhbMV0pXHJcbiAgICAgICAgICAgID8gKHZlcnRleFswXSA+IDAgPyAncmlnaHQnIDogJ2xlZnQnKVxyXG4gICAgICAgICAgICA6ICh2ZXJ0ZXhbMV0gPiAwID8gJ2JvdHRvbScgOiAndG9wJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gZ3JhcGhpYztcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL1BhdGhcIik7XG5cbnZhciBQYXRoUHJveHkgPSByZXF1aXJlKFwiLi4vY29yZS9QYXRoUHJveHlcIik7XG5cbnZhciB0cmFuc2Zvcm1QYXRoID0gcmVxdWlyZShcIi4vdHJhbnNmb3JtUGF0aFwiKTtcblxuLy8gY29tbWFuZCBjaGFyc1xudmFyIGNjID0gWydtJywgJ00nLCAnbCcsICdMJywgJ3YnLCAnVicsICdoJywgJ0gnLCAneicsICdaJywgJ2MnLCAnQycsICdxJywgJ1EnLCAndCcsICdUJywgJ3MnLCAnUycsICdhJywgJ0EnXTtcbnZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbnZhciBtYXRoU2luID0gTWF0aC5zaW47XG52YXIgbWF0aENvcyA9IE1hdGguY29zO1xudmFyIFBJID0gTWF0aC5QSTtcblxudmFyIHZNYWcgPSBmdW5jdGlvbiAodikge1xuICByZXR1cm4gTWF0aC5zcXJ0KHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0pO1xufTtcblxudmFyIHZSYXRpbyA9IGZ1bmN0aW9uICh1LCB2KSB7XG4gIHJldHVybiAodVswXSAqIHZbMF0gKyB1WzFdICogdlsxXSkgLyAodk1hZyh1KSAqIHZNYWcodikpO1xufTtcblxudmFyIHZBbmdsZSA9IGZ1bmN0aW9uICh1LCB2KSB7XG4gIHJldHVybiAodVswXSAqIHZbMV0gPCB1WzFdICogdlswXSA/IC0xIDogMSkgKiBNYXRoLmFjb3ModlJhdGlvKHUsIHYpKTtcbn07XG5cbmZ1bmN0aW9uIHByb2Nlc3NBcmMoeDEsIHkxLCB4MiwgeTIsIGZhLCBmcywgcngsIHJ5LCBwc2lEZWcsIGNtZCwgcGF0aCkge1xuICB2YXIgcHNpID0gcHNpRGVnICogKFBJIC8gMTgwLjApO1xuICB2YXIgeHAgPSBtYXRoQ29zKHBzaSkgKiAoeDEgLSB4MikgLyAyLjAgKyBtYXRoU2luKHBzaSkgKiAoeTEgLSB5MikgLyAyLjA7XG4gIHZhciB5cCA9IC0xICogbWF0aFNpbihwc2kpICogKHgxIC0geDIpIC8gMi4wICsgbWF0aENvcyhwc2kpICogKHkxIC0geTIpIC8gMi4wO1xuICB2YXIgbGFtYmRhID0geHAgKiB4cCAvIChyeCAqIHJ4KSArIHlwICogeXAgLyAocnkgKiByeSk7XG5cbiAgaWYgKGxhbWJkYSA+IDEpIHtcbiAgICByeCAqPSBtYXRoU3FydChsYW1iZGEpO1xuICAgIHJ5ICo9IG1hdGhTcXJ0KGxhbWJkYSk7XG4gIH1cblxuICB2YXIgZiA9IChmYSA9PT0gZnMgPyAtMSA6IDEpICogbWF0aFNxcnQoKHJ4ICogcnggKiAocnkgKiByeSkgLSByeCAqIHJ4ICogKHlwICogeXApIC0gcnkgKiByeSAqICh4cCAqIHhwKSkgLyAocnggKiByeCAqICh5cCAqIHlwKSArIHJ5ICogcnkgKiAoeHAgKiB4cCkpKSB8fCAwO1xuICB2YXIgY3hwID0gZiAqIHJ4ICogeXAgLyByeTtcbiAgdmFyIGN5cCA9IGYgKiAtcnkgKiB4cCAvIHJ4O1xuICB2YXIgY3ggPSAoeDEgKyB4MikgLyAyLjAgKyBtYXRoQ29zKHBzaSkgKiBjeHAgLSBtYXRoU2luKHBzaSkgKiBjeXA7XG4gIHZhciBjeSA9ICh5MSArIHkyKSAvIDIuMCArIG1hdGhTaW4ocHNpKSAqIGN4cCArIG1hdGhDb3MocHNpKSAqIGN5cDtcbiAgdmFyIHRoZXRhID0gdkFuZ2xlKFsxLCAwXSwgWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XSk7XG4gIHZhciB1ID0gWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XTtcbiAgdmFyIHYgPSBbKC0xICogeHAgLSBjeHApIC8gcngsICgtMSAqIHlwIC0gY3lwKSAvIHJ5XTtcbiAgdmFyIGRUaGV0YSA9IHZBbmdsZSh1LCB2KTtcblxuICBpZiAodlJhdGlvKHUsIHYpIDw9IC0xKSB7XG4gICAgZFRoZXRhID0gUEk7XG4gIH1cblxuICBpZiAodlJhdGlvKHUsIHYpID49IDEpIHtcbiAgICBkVGhldGEgPSAwO1xuICB9XG5cbiAgaWYgKGZzID09PSAwICYmIGRUaGV0YSA+IDApIHtcbiAgICBkVGhldGEgPSBkVGhldGEgLSAyICogUEk7XG4gIH1cblxuICBpZiAoZnMgPT09IDEgJiYgZFRoZXRhIDwgMCkge1xuICAgIGRUaGV0YSA9IGRUaGV0YSArIDIgKiBQSTtcbiAgfVxuXG4gIHBhdGguYWRkRGF0YShjbWQsIGN4LCBjeSwgcngsIHJ5LCB0aGV0YSwgZFRoZXRhLCBwc2ksIGZzKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0aFByb3h5RnJvbVN0cmluZyhkYXRhKSB7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVybiBbXTtcbiAgfSAvLyBjb21tYW5kIHN0cmluZ1xuXG5cbiAgdmFyIGNzID0gZGF0YS5yZXBsYWNlKC8tL2csICcgLScpLnJlcGxhY2UoLyAgL2csICcgJykucmVwbGFjZSgvIC9nLCAnLCcpLnJlcGxhY2UoLywsL2csICcsJyk7XG4gIHZhciBuOyAvLyBjcmVhdGUgcGlwZXMgc28gdGhhdCB3ZSBjYW4gc3BsaXQgdGhlIGRhdGFcblxuICBmb3IgKG4gPSAwOyBuIDwgY2MubGVuZ3RoOyBuKyspIHtcbiAgICBjcyA9IGNzLnJlcGxhY2UobmV3IFJlZ0V4cChjY1tuXSwgJ2cnKSwgJ3wnICsgY2Nbbl0pO1xuICB9IC8vIGNyZWF0ZSBhcnJheVxuXG5cbiAgdmFyIGFyciA9IGNzLnNwbGl0KCd8Jyk7IC8vIGluaXQgY29udGV4dCBwb2ludFxuXG4gIHZhciBjcHggPSAwO1xuICB2YXIgY3B5ID0gMDtcbiAgdmFyIHBhdGggPSBuZXcgUGF0aFByb3h5KCk7XG4gIHZhciBDTUQgPSBQYXRoUHJveHkuQ01EO1xuICB2YXIgcHJldkNtZDtcblxuICBmb3IgKG4gPSAxOyBuIDwgYXJyLmxlbmd0aDsgbisrKSB7XG4gICAgdmFyIHN0ciA9IGFycltuXTtcbiAgICB2YXIgYyA9IHN0ci5jaGFyQXQoMCk7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgdmFyIHAgPSBzdHIuc2xpY2UoMSkucmVwbGFjZSgvZSwtL2csICdlLScpLnNwbGl0KCcsJyk7XG4gICAgdmFyIGNtZDtcblxuICAgIGlmIChwLmxlbmd0aCA+IDAgJiYgcFswXSA9PT0gJycpIHtcbiAgICAgIHAuc2hpZnQoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBbaV0gPSBwYXJzZUZsb2F0KHBbaV0pO1xuICAgIH1cblxuICAgIHdoaWxlIChvZmYgPCBwLmxlbmd0aCAmJiAhaXNOYU4ocFtvZmZdKSkge1xuICAgICAgaWYgKGlzTmFOKHBbMF0pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3RsUHR4O1xuICAgICAgdmFyIGN0bFB0eTtcbiAgICAgIHZhciByeDtcbiAgICAgIHZhciByeTtcbiAgICAgIHZhciBwc2k7XG4gICAgICB2YXIgZmE7XG4gICAgICB2YXIgZnM7XG4gICAgICB2YXIgeDEgPSBjcHg7XG4gICAgICB2YXIgeTEgPSBjcHk7IC8vIGNvbnZlcnQgbCwgSCwgaCwgViwgYW5kIHYgdG8gTFxuXG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELk07XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGMgPSAnbCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELk07XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGMgPSAnTCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSk7XG4gICAgICAgICAgY3B4ID0gcFtvZmYgLSAyXTtcbiAgICAgICAgICBjcHkgPSBwW29mZiAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHBbb2ZmKytdICsgY3B4LCBwW29mZisrXSArIGNweSwgcFtvZmYrK10gKyBjcHgsIHBbb2ZmKytdICsgY3B5LCBwW29mZisrXSArIGNweCwgcFtvZmYrK10gKyBjcHkpO1xuICAgICAgICAgIGNweCArPSBwW29mZiAtIDJdO1xuICAgICAgICAgIGNweSArPSBwW29mZiAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuXG4gICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5DKSB7XG4gICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgeDEgPSBwW29mZisrXTtcbiAgICAgICAgICB5MSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcblxuICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuQykge1xuICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgIHgxID0gY3B4ICsgcFtvZmYrK107XG4gICAgICAgICAgeTEgPSBjcHkgKyBwW29mZisrXTtcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICB4MSA9IHBbb2ZmKytdO1xuICAgICAgICAgIHkxID0gcFtvZmYrK107XG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgeDEgPSBwW29mZisrXSArIGNweDtcbiAgICAgICAgICB5MSA9IHBbb2ZmKytdICsgY3B5O1xuICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG5cbiAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELlEpIHtcbiAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuXG4gICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5RKSB7XG4gICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgIHJ4ID0gcFtvZmYrK107XG4gICAgICAgICAgcnkgPSBwW29mZisrXTtcbiAgICAgICAgICBwc2kgPSBwW29mZisrXTtcbiAgICAgICAgICBmYSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGZzID0gcFtvZmYrK107XG4gICAgICAgICAgeDEgPSBjcHgsIHkxID0gY3B5O1xuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgIHByb2Nlc3NBcmMoeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSwgY21kLCBwYXRoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICByeCA9IHBbb2ZmKytdO1xuICAgICAgICAgIHJ5ID0gcFtvZmYrK107XG4gICAgICAgICAgcHNpID0gcFtvZmYrK107XG4gICAgICAgICAgZmEgPSBwW29mZisrXTtcbiAgICAgICAgICBmcyA9IHBbb2ZmKytdO1xuICAgICAgICAgIHgxID0gY3B4LCB5MSA9IGNweTtcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgIHByb2Nlc3NBcmMoeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSwgY21kLCBwYXRoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYyA9PT0gJ3onIHx8IGMgPT09ICdaJykge1xuICAgICAgY21kID0gQ01ELlo7XG4gICAgICBwYXRoLmFkZERhdGEoY21kKTtcbiAgICB9XG5cbiAgICBwcmV2Q21kID0gY21kO1xuICB9XG5cbiAgcGF0aC50b1N0YXRpYygpO1xuICByZXR1cm4gcGF0aDtcbn0gLy8gVE9ETyBPcHRpbWl6ZSBkb3VibGUgbWVtb3J5IGNvc3QgcHJvYmxlbVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykge1xuICB2YXIgcGF0aFByb3h5ID0gY3JlYXRlUGF0aFByb3h5RnJvbVN0cmluZyhzdHIpO1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBvcHRzLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgaWYgKHBhdGguc2V0RGF0YSkge1xuICAgICAgcGF0aC5zZXREYXRhKHBhdGhQcm94eS5kYXRhKTsgLy8gU3ZnIGFuZCB2bWwgcmVuZGVyZXIgZG9uJ3QgaGF2ZSBjb250ZXh0XG5cbiAgICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQoKTtcblxuICAgICAgaWYgKGN0eCkge1xuICAgICAgICBwYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjdHggPSBwYXRoO1xuICAgICAgcGF0aFByb3h5LnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgfVxuICB9O1xuXG4gIG9wdHMuYXBwbHlUcmFuc2Zvcm0gPSBmdW5jdGlvbiAobSkge1xuICAgIHRyYW5zZm9ybVBhdGgocGF0aFByb3h5LCBtKTtcbiAgICB0aGlzLmRpcnR5KHRydWUpO1xuICB9O1xuXG4gIHJldHVybiBvcHRzO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBQYXRoIG9iamVjdCBmcm9tIHBhdGggc3RyaW5nIGRhdGFcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhEYXRhXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgT3RoZXIgb3B0aW9uc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRnJvbVN0cmluZyhzdHIsIG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBQYXRoKGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBQYXRoIGNsYXNzIGZyb20gcGF0aCBzdHJpbmcgZGF0YVxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0cyBPdGhlciBvcHRpb25zXG4gKi9cblxuXG5mdW5jdGlvbiBleHRlbmRGcm9tU3RyaW5nKHN0ciwgb3B0cykge1xuICByZXR1cm4gUGF0aC5leHRlbmQoY3JlYXRlUGF0aE9wdGlvbnMoc3RyLCBvcHRzKSk7XG59XG4vKipcbiAqIE1lcmdlIG11bHRpcGxlIHBhdGhzXG4gKi9cbi8vIFRPRE8gQXBwbHkgdHJhbnNmb3JtXG4vLyBUT0RPIHN0cm9rZSBkYXNoXG4vLyBUT0RPIE9wdGltaXplIGRvdWJsZSBtZW1vcnkgY29zdCBwcm9ibGVtXG5cblxuZnVuY3Rpb24gbWVyZ2VQYXRoKHBhdGhFbHMsIG9wdHMpIHtcbiAgdmFyIHBhdGhMaXN0ID0gW107XG4gIHZhciBsZW4gPSBwYXRoRWxzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHBhdGhFbCA9IHBhdGhFbHNbaV07XG5cbiAgICBpZiAoIXBhdGhFbC5wYXRoKSB7XG4gICAgICBwYXRoRWwuY3JlYXRlUGF0aFByb3h5KCk7XG4gICAgfVxuXG4gICAgaWYgKHBhdGhFbC5fX2RpcnR5UGF0aCkge1xuICAgICAgcGF0aEVsLmJ1aWxkUGF0aChwYXRoRWwucGF0aCwgcGF0aEVsLnNoYXBlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBwYXRoTGlzdC5wdXNoKHBhdGhFbC5wYXRoKTtcbiAgfVxuXG4gIHZhciBwYXRoQnVuZGxlID0gbmV3IFBhdGgob3B0cyk7IC8vIE5lZWQgcGF0aCBwcm94eS5cblxuICBwYXRoQnVuZGxlLmNyZWF0ZVBhdGhQcm94eSgpO1xuXG4gIHBhdGhCdW5kbGUuYnVpbGRQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBwYXRoLmFwcGVuZFBhdGgocGF0aExpc3QpOyAvLyBTdmcgYW5kIHZtbCByZW5kZXJlciBkb24ndCBoYXZlIGNvbnRleHRcblxuICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQoKTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIHBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHBhdGhCdW5kbGU7XG59XG5cbmV4cG9ydHMuY3JlYXRlRnJvbVN0cmluZyA9IGNyZWF0ZUZyb21TdHJpbmc7XG5leHBvcnRzLmV4dGVuZEZyb21TdHJpbmcgPSBleHRlbmRGcm9tU3RyaW5nO1xuZXhwb3J0cy5tZXJnZVBhdGggPSBtZXJnZVBhdGg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZShcIi4vRGlzcGxheWFibGVcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgUGF0aFByb3h5ID0gcmVxdWlyZShcIi4uL2NvcmUvUGF0aFByb3h5XCIpO1xuXG52YXIgcGF0aENvbnRhaW4gPSByZXF1aXJlKFwiLi4vY29udGFpbi9wYXRoXCIpO1xuXG52YXIgUGF0dGVybiA9IHJlcXVpcmUoXCIuL1BhdHRlcm5cIik7XG5cbnZhciBnZXRDYW52YXNQYXR0ZXJuID0gUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybjtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBwYXRoUHJveHlGb3JEcmF3ID0gbmV3IFBhdGhQcm94eSh0cnVlKTtcbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aFxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5cbmZ1bmN0aW9uIFBhdGgob3B0cykge1xuICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG5cbiAgdGhpcy5wYXRoID0gbnVsbDtcbn1cblxuUGF0aC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQYXRoLFxuICB0eXBlOiAncGF0aCcsXG4gIF9fZGlydHlQYXRoOiB0cnVlLFxuICBzdHJva2VDb250YWluVGhyZXNob2xkOiA1LFxuICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgcGF0aCA9IHRoaXMucGF0aCB8fCBwYXRoUHJveHlGb3JEcmF3O1xuICAgIHZhciBoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKTtcbiAgICB2YXIgaGFzRmlsbCA9IHN0eWxlLmhhc0ZpbGwoKTtcbiAgICB2YXIgZmlsbCA9IHN0eWxlLmZpbGw7XG4gICAgdmFyIHN0cm9rZSA9IHN0eWxlLnN0cm9rZTtcbiAgICB2YXIgaGFzRmlsbEdyYWRpZW50ID0gaGFzRmlsbCAmJiAhIWZpbGwuY29sb3JTdG9wcztcbiAgICB2YXIgaGFzU3Ryb2tlR3JhZGllbnQgPSBoYXNTdHJva2UgJiYgISFzdHJva2UuY29sb3JTdG9wcztcbiAgICB2YXIgaGFzRmlsbFBhdHRlcm4gPSBoYXNGaWxsICYmICEhZmlsbC5pbWFnZTtcbiAgICB2YXIgaGFzU3Ryb2tlUGF0dGVybiA9IGhhc1N0cm9rZSAmJiAhIXN0cm9rZS5pbWFnZTtcbiAgICBzdHlsZS5iaW5kKGN0eCwgdGhpcywgcHJldkVsKTtcbiAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuXG4gICAgaWYgKHRoaXMuX19kaXJ0eSkge1xuICAgICAgdmFyIHJlY3Q7IC8vIFVwZGF0ZSBncmFkaWVudCBiZWNhdXNlIGJvdW5kaW5nIHJlY3QgbWF5IGNoYW5nZWRcblxuICAgICAgaWYgKGhhc0ZpbGxHcmFkaWVudCkge1xuICAgICAgICByZWN0ID0gcmVjdCB8fCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICB0aGlzLl9maWxsR3JhZGllbnQgPSBzdHlsZS5nZXRHcmFkaWVudChjdHgsIGZpbGwsIHJlY3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzU3Ryb2tlR3JhZGllbnQpIHtcbiAgICAgICAgcmVjdCA9IHJlY3QgfHwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgdGhpcy5fc3Ryb2tlR3JhZGllbnQgPSBzdHlsZS5nZXRHcmFkaWVudChjdHgsIHN0cm9rZSwgcmVjdCk7XG4gICAgICB9XG4gICAgfSAvLyBVc2UgdGhlIGdyYWRpZW50IG9yIHBhdHRlcm5cblxuXG4gICAgaWYgKGhhc0ZpbGxHcmFkaWVudCkge1xuICAgICAgLy8gUEVORElORyBJZiBtYXkgaGF2ZSBhZmZlY3QgdGhlIHN0YXRlXG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5fZmlsbEdyYWRpZW50O1xuICAgIH0gZWxzZSBpZiAoaGFzRmlsbFBhdHRlcm4pIHtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBnZXRDYW52YXNQYXR0ZXJuLmNhbGwoZmlsbCwgY3R4KTtcbiAgICB9XG5cbiAgICBpZiAoaGFzU3Ryb2tlR3JhZGllbnQpIHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuX3N0cm9rZUdyYWRpZW50O1xuICAgIH0gZWxzZSBpZiAoaGFzU3Ryb2tlUGF0dGVybikge1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZ2V0Q2FudmFzUGF0dGVybi5jYWxsKHN0cm9rZSwgY3R4KTtcbiAgICB9XG5cbiAgICB2YXIgbGluZURhc2ggPSBzdHlsZS5saW5lRGFzaDtcbiAgICB2YXIgbGluZURhc2hPZmZzZXQgPSBzdHlsZS5saW5lRGFzaE9mZnNldDtcbiAgICB2YXIgY3R4TGluZURhc2ggPSAhIWN0eC5zZXRMaW5lRGFzaDsgLy8gVXBkYXRlIHBhdGggc3gsIHN5XG5cbiAgICB2YXIgc2NhbGUgPSB0aGlzLmdldEdsb2JhbFNjYWxlKCk7XG4gICAgcGF0aC5zZXRTY2FsZShzY2FsZVswXSwgc2NhbGVbMV0pOyAvLyBQcm94eSBjb250ZXh0XG4gICAgLy8gUmVidWlsZCBwYXRoIGluIGZvbGxvd2luZyAyIGNhc2VzXG4gICAgLy8gMS4gUGF0aCBpcyBkaXJ0eVxuICAgIC8vIDIuIFBhdGggbmVlZHMgamF2YXNjcmlwdCBpbXBsZW1lbnRlZCBsaW5lRGFzaCBzdHJva2luZy5cbiAgICAvLyAgICBJbiB0aGlzIGNhc2UsIGxpbmVEYXNoIGluZm9ybWF0aW9uIHdpbGwgbm90IGJlIHNhdmVkIGluIFBhdGhQcm94eVxuXG4gICAgaWYgKHRoaXMuX19kaXJ0eVBhdGggfHwgbGluZURhc2ggJiYgIWN0eExpbmVEYXNoICYmIGhhc1N0cm9rZSkge1xuICAgICAgcGF0aC5iZWdpblBhdGgoY3R4KTsgLy8gU2V0dGluZyBsaW5lIGRhc2ggYmVmb3JlIGJ1aWxkIHBhdGhcblxuICAgICAgaWYgKGxpbmVEYXNoICYmICFjdHhMaW5lRGFzaCkge1xuICAgICAgICBwYXRoLnNldExpbmVEYXNoKGxpbmVEYXNoKTtcbiAgICAgICAgcGF0aC5zZXRMaW5lRGFzaE9mZnNldChsaW5lRGFzaE9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnVpbGRQYXRoKHBhdGgsIHRoaXMuc2hhcGUsIGZhbHNlKTsgLy8gQ2xlYXIgcGF0aCBkaXJ0eSBmbGFnXG5cbiAgICAgIGlmICh0aGlzLnBhdGgpIHtcbiAgICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXBsYXkgcGF0aCBidWlsZGluZ1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5wYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgfVxuXG4gICAgaGFzRmlsbCAmJiBwYXRoLmZpbGwoY3R4KTtcblxuICAgIGlmIChsaW5lRGFzaCAmJiBjdHhMaW5lRGFzaCkge1xuICAgICAgY3R4LnNldExpbmVEYXNoKGxpbmVEYXNoKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xuICAgIH1cblxuICAgIGhhc1N0cm9rZSAmJiBwYXRoLnN0cm9rZShjdHgpO1xuXG4gICAgaWYgKGxpbmVEYXNoICYmIGN0eExpbmVEYXNoKSB7XG4gICAgICAvLyBQRU5ESU5HXG4gICAgICAvLyBSZW1vdmUgbGluZURhc2hcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7IC8vIERyYXcgcmVjdCB0ZXh0XG5cbiAgICBpZiAoc3R5bGUudGV4dCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmRyYXdSZWN0VGV4dChjdHgsIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgIH1cbiAgfSxcbiAgLy8gV2hlbiBidW5kbGluZyBwYXRoLCBzb21lIHNoYXBlIG1heSBkZWNpZGUgaWYgdXNlIG1vdmVUbyB0byBiZWdpbiBhIG5ldyBzdWJwYXRoIG9yIGNsb3NlUGF0aFxuICAvLyBMaWtlIGluIGNpcmNsZVxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlQ2ZnLCBpbkJ1bmRsZSkge30sXG4gIGNyZWF0ZVBhdGhQcm94eTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucGF0aCA9IG5ldyBQYXRoUHJveHkoKTtcbiAgfSxcbiAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlY3QgPSB0aGlzLl9yZWN0O1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgdmFyIG5lZWRzVXBkYXRlUmVjdCA9ICFyZWN0O1xuXG4gICAgaWYgKG5lZWRzVXBkYXRlUmVjdCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG5cbiAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAvLyBDcmVhdGUgcGF0aCBvbiBkZW1hbmQuXG4gICAgICAgIHBhdGggPSB0aGlzLnBhdGggPSBuZXcgUGF0aFByb3h5KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9fZGlydHlQYXRoKSB7XG4gICAgICAgIHBhdGguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuYnVpbGRQYXRoKHBhdGgsIHRoaXMuc2hhcGUsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVjdCA9IHJlY3Q7XG5cbiAgICBpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgIC8vIE5lZWRzIHVwZGF0ZSByZWN0IHdpdGggc3Ryb2tlIGxpbmVXaWR0aCB3aGVuXG4gICAgICAvLyAxLiBFbGVtZW50IGNoYW5nZXMgc2NhbGUgb3IgbGluZVdpZHRoXG4gICAgICAvLyAyLiBTaGFwZSBpcyBjaGFuZ2VkXG4gICAgICB2YXIgcmVjdFdpdGhTdHJva2UgPSB0aGlzLl9yZWN0V2l0aFN0cm9rZSB8fCAodGhpcy5fcmVjdFdpdGhTdHJva2UgPSByZWN0LmNsb25lKCkpO1xuXG4gICAgICBpZiAodGhpcy5fX2RpcnR5IHx8IG5lZWRzVXBkYXRlUmVjdCkge1xuICAgICAgICByZWN0V2l0aFN0cm9rZS5jb3B5KHJlY3QpOyAvLyBGSVhNRSBNdXN0IGFmdGVyIHVwZGF0ZVRyYW5zZm9ybVxuXG4gICAgICAgIHZhciB3ID0gc3R5bGUubGluZVdpZHRoOyAvLyBQRU5ESU5HLCBNaW4gbGluZSB3aWR0aCBpcyBuZWVkZWQgd2hlbiBsaW5lIGlzIGhvcml6b250YWwgb3IgdmVydGljYWxcblxuICAgICAgICB2YXIgbGluZVNjYWxlID0gc3R5bGUuc3Ryb2tlTm9TY2FsZSA/IHRoaXMuZ2V0TGluZVNjYWxlKCkgOiAxOyAvLyBPbmx5IGFkZCBleHRyYSBob3ZlciBsaW5lV2lkdGggd2hlbiB0aGVyZSBhcmUgbm8gZmlsbFxuXG4gICAgICAgIGlmICghc3R5bGUuaGFzRmlsbCgpKSB7XG4gICAgICAgICAgdyA9IE1hdGgubWF4KHcsIHRoaXMuc3Ryb2tlQ29udGFpblRocmVzaG9sZCB8fCA0KTtcbiAgICAgICAgfSAvLyBDb25zaWRlciBsaW5lIHdpZHRoXG4gICAgICAgIC8vIExpbmUgc2NhbGUgY2FuJ3QgYmUgMDtcblxuXG4gICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLndpZHRoICs9IHcgLyBsaW5lU2NhbGU7XG4gICAgICAgICAgcmVjdFdpdGhTdHJva2UuaGVpZ2h0ICs9IHcgLyBsaW5lU2NhbGU7XG4gICAgICAgICAgcmVjdFdpdGhTdHJva2UueCAtPSB3IC8gbGluZVNjYWxlIC8gMjtcbiAgICAgICAgICByZWN0V2l0aFN0cm9rZS55IC09IHcgLyBsaW5lU2NhbGUgLyAyO1xuICAgICAgICB9XG4gICAgICB9IC8vIFJldHVybiByZWN0IHdpdGggc3Ryb2tlXG5cblxuICAgICAgcmV0dXJuIHJlY3RXaXRoU3Ryb2tlO1xuICAgIH1cblxuICAgIHJldHVybiByZWN0O1xuICB9LFxuICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHZhciBsb2NhbFBvcyA9IHRoaXMudHJhbnNmb3JtQ29vcmRUb0xvY2FsKHgsIHkpO1xuICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHggPSBsb2NhbFBvc1swXTtcbiAgICB5ID0gbG9jYWxQb3NbMV07XG5cbiAgICBpZiAocmVjdC5jb250YWluKHgsIHkpKSB7XG4gICAgICB2YXIgcGF0aERhdGEgPSB0aGlzLnBhdGguZGF0YTtcblxuICAgICAgaWYgKHN0eWxlLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICAgIHZhciBsaW5lU2NhbGUgPSBzdHlsZS5zdHJva2VOb1NjYWxlID8gdGhpcy5nZXRMaW5lU2NhbGUoKSA6IDE7IC8vIExpbmUgc2NhbGUgY2FuJ3QgYmUgMDtcblxuICAgICAgICBpZiAobGluZVNjYWxlID4gMWUtMTApIHtcbiAgICAgICAgICAvLyBPbmx5IGFkZCBleHRyYSBob3ZlciBsaW5lV2lkdGggd2hlbiB0aGVyZSBhcmUgbm8gZmlsbFxuICAgICAgICAgIGlmICghc3R5bGUuaGFzRmlsbCgpKSB7XG4gICAgICAgICAgICBsaW5lV2lkdGggPSBNYXRoLm1heChsaW5lV2lkdGgsIHRoaXMuc3Ryb2tlQ29udGFpblRocmVzaG9sZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhdGhDb250YWluLmNvbnRhaW5TdHJva2UocGF0aERhdGEsIGxpbmVXaWR0aCAvIGxpbmVTY2FsZSwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3R5bGUuaGFzRmlsbCgpKSB7XG4gICAgICAgIHJldHVybiBwYXRoQ29udGFpbi5jb250YWluKHBhdGhEYXRhLCB4LCB5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGRpcnR5UGF0aFxuICAgKi9cbiAgZGlydHk6IGZ1bmN0aW9uIChkaXJ0eVBhdGgpIHtcbiAgICBpZiAoZGlydHlQYXRoID09IG51bGwpIHtcbiAgICAgIGRpcnR5UGF0aCA9IHRydWU7XG4gICAgfSAvLyBPbmx5IG1hcmsgZGlydHksIG5vdCBtYXJrIGNsZWFuXG5cblxuICAgIGlmIChkaXJ0eVBhdGgpIHtcbiAgICAgIHRoaXMuX19kaXJ0eVBhdGggPSBkaXJ0eVBhdGg7XG4gICAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpOyAvLyBVc2VkIGFzIGEgY2xpcHBpbmcgcGF0aFxuXG4gICAgaWYgKHRoaXMuX19jbGlwVGFyZ2V0KSB7XG4gICAgICB0aGlzLl9fY2xpcFRhcmdldC5kaXJ0eSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWxpYXMgZm9yIGFuaW1hdGUoJ3NoYXBlJylcbiAgICogQHBhcmFtIHtib29sZWFufSBsb29wXG4gICAqL1xuICBhbmltYXRlU2hhcGU6IGZ1bmN0aW9uIChsb29wKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSgnc2hhcGUnLCBsb29wKTtcbiAgfSxcbiAgLy8gT3ZlcndyaXRlIGF0dHJLVlxuICBhdHRyS1Y6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgLy8gRklYTUVcbiAgICBpZiAoa2V5ID09PSAnc2hhcGUnKSB7XG4gICAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgICAgIHRoaXMuX19kaXJ0eVBhdGggPSB0cnVlO1xuICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIERpc3BsYXlhYmxlLnByb3RvdHlwZS5hdHRyS1YuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIHNldFNoYXBlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7IC8vIFBhdGggZnJvbSBzdHJpbmcgbWF5IG5vdCBoYXZlIHNoYXBlXG5cbiAgICBpZiAoc2hhcGUpIHtcbiAgICAgIGlmICh6clV0aWwuaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGtleSkge1xuICAgICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHNoYXBlW25hbWVdID0ga2V5W25hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2hhcGVba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRpcnR5KHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBnZXRMaW5lU2NhbGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtOyAvLyBHZXQgdGhlIGxpbmUgc2NhbGUuXG4gICAgLy8gRGV0ZXJtaW5hbnQgb2YgYG1gIG1lYW5zIGhvdyBtdWNoIHRoZSBhcmVhIGlzIGVubGFyZ2VkIGJ5IHRoZVxuICAgIC8vIHRyYW5zZm9ybWF0aW9uLiBTbyBpdHMgc3F1YXJlIHJvb3QgY2FuIGJlIHVzZWQgYXMgYSBzY2FsZSBmYWN0b3JcbiAgICAvLyBmb3Igd2lkdGguXG5cbiAgICByZXR1cm4gbSAmJiBhYnMobVswXSAtIDEpID4gMWUtMTAgJiYgYWJzKG1bM10gLSAxKSA+IDFlLTEwID8gTWF0aC5zcXJ0KGFicyhtWzBdICogbVszXSAtIG1bMl0gKiBtWzFdKSkgOiAxO1xuICB9XG59O1xuLyoqXG4gKiDmianlsZXkuIDkuKogUGF0aCBlbGVtZW50LCDmr5TlpoLmmJ/lvaLvvIzlnIbnrYnjgIJcbiAqIEV4dGVuZCBhIHBhdGggZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcHMudHlwZSBQYXRoIHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByb3BzLmluaXQgSW5pdGlhbGl6ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvcHMuYnVpbGRQYXRoIE92ZXJ3cml0ZSBidWlsZFBhdGggbWV0aG9kXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzLnN0eWxlXSBFeHRlbmRlZCBkZWZhdWx0IHN0eWxlIGNvbmZpZ1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5zaGFwZV0gRXh0ZW5kZWQgZGVmYXVsdCBzaGFwZSBjb25maWdcbiAqL1xuXG5QYXRoLmV4dGVuZCA9IGZ1bmN0aW9uIChkZWZhdWx0cykge1xuICB2YXIgU3ViID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICBQYXRoLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICBpZiAoZGVmYXVsdHMuc3R5bGUpIHtcbiAgICAgIC8vIEV4dGVuZCBkZWZhdWx0IHN0eWxlXG4gICAgICB0aGlzLnN0eWxlLmV4dGVuZEZyb20oZGVmYXVsdHMuc3R5bGUsIGZhbHNlKTtcbiAgICB9IC8vIEV4dGVuZCBkZWZhdWx0IHNoYXBlXG5cblxuICAgIHZhciBkZWZhdWx0U2hhcGUgPSBkZWZhdWx0cy5zaGFwZTtcblxuICAgIGlmIChkZWZhdWx0U2hhcGUpIHtcbiAgICAgIHRoaXMuc2hhcGUgPSB0aGlzLnNoYXBlIHx8IHt9O1xuICAgICAgdmFyIHRoaXNTaGFwZSA9IHRoaXMuc2hhcGU7XG5cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdFNoYXBlKSB7XG4gICAgICAgIGlmICghdGhpc1NoYXBlLmhhc093blByb3BlcnR5KG5hbWUpICYmIGRlZmF1bHRTaGFwZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHRoaXNTaGFwZVtuYW1lXSA9IGRlZmF1bHRTaGFwZVtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGRlZmF1bHRzLmluaXQgJiYgZGVmYXVsdHMuaW5pdC5jYWxsKHRoaXMsIG9wdHMpO1xuICB9O1xuXG4gIHpyVXRpbC5pbmhlcml0cyhTdWIsIFBhdGgpOyAvLyBGSVhNRSDkuI3og70gZXh0ZW5kIHBvc2l0aW9uLCByb3RhdGlvbiDnrYnlvJXnlKjlr7nosaFcblxuICBmb3IgKHZhciBuYW1lIGluIGRlZmF1bHRzKSB7XG4gICAgLy8gRXh0ZW5kaW5nIHByb3RvdHlwZSB2YWx1ZXMgYW5kIG1ldGhvZHNcbiAgICBpZiAobmFtZSAhPT0gJ3N0eWxlJyAmJiBuYW1lICE9PSAnc2hhcGUnKSB7XG4gICAgICBTdWIucHJvdG90eXBlW25hbWVdID0gZGVmYXVsdHNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFN1Yjtcbn07XG5cbnpyVXRpbC5pbmhlcml0cyhQYXRoLCBEaXNwbGF5YWJsZSk7XG52YXIgX2RlZmF1bHQgPSBQYXRoO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9QYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY3VydmUgPSByZXF1aXJlKFwiLi9jdXJ2ZVwiKTtcblxudmFyIHZlYzIgPSByZXF1aXJlKFwiLi92ZWN0b3JcIik7XG5cbnZhciBiYm94ID0gcmVxdWlyZShcIi4vYmJveFwiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuL0JvdW5kaW5nUmVjdFwiKTtcblxudmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpO1xuXG52YXIgZHByID0gX2NvbmZpZy5kZXZpY2VQaXhlbFJhdGlvO1xuXG4vKipcbiAqIFBhdGgg5Luj55CG77yM5Y+v5Lul5ZyoYGJ1aWxkUGF0aGDkuK3nlKjkuo7mm7/ku6NgY3R4YCwg5Lya5L+d5a2Y5q+P5LiqcGF0aOaTjeS9nOeahOWRveS7pOWIsHBhdGhDb21tYW5kc+WxnuaAp+S4rVxuICog5Y+v5Lul55So5LqOIGlzSW5zaWRlUGF0aCDliKTmlq3ku6Xlj4rojrflj5Zib3VuZGluZ1JlY3RcbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9QYXRoUHJveHlcbiAqIEBhdXRob3IgWWkgU2hlbiAoaHR0cDovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbi8vIFRPRE8gZ2V0VG90YWxMZW5ndGgsIGdldFBvaW50QXRMZW5ndGhcbnZhciBDTUQgPSB7XG4gIE06IDEsXG4gIEw6IDIsXG4gIEM6IDMsXG4gIFE6IDQsXG4gIEE6IDUsXG4gIFo6IDYsXG4gIC8vIFJlY3RcbiAgUjogN1xufTsgLy8gdmFyIENNRF9NRU1fU0laRSA9IHtcbi8vICAgICBNOiAzLFxuLy8gICAgIEw6IDMsXG4vLyAgICAgQzogNyxcbi8vICAgICBROiA1LFxuLy8gICAgIEE6IDksXG4vLyAgICAgUjogNSxcbi8vICAgICBaOiAxXG4vLyB9O1xuXG52YXIgbWluID0gW107XG52YXIgbWF4ID0gW107XG52YXIgbWluMiA9IFtdO1xudmFyIG1heDIgPSBbXTtcbnZhciBtYXRoTWluID0gTWF0aC5taW47XG52YXIgbWF0aE1heCA9IE1hdGgubWF4O1xudmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcbnZhciBtYXRoU2luID0gTWF0aC5zaW47XG52YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgbWF0aEFicyA9IE1hdGguYWJzO1xudmFyIGhhc1R5cGVkQXJyYXkgPSB0eXBlb2YgRmxvYXQzMkFycmF5ICE9ICd1bmRlZmluZWQnO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbnZhciBQYXRoUHJveHkgPSBmdW5jdGlvbiAobm90U2F2ZURhdGEpIHtcbiAgdGhpcy5fc2F2ZURhdGEgPSAhKG5vdFNhdmVEYXRhIHx8IGZhbHNlKTtcblxuICBpZiAodGhpcy5fc2F2ZURhdGEpIHtcbiAgICAvKipcbiAgICAgKiBQYXRoIGRhdGEuIFN0b3JlZCBhcyBmbGF0IGFycmF5XG4gICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICB9XG5cbiAgdGhpcy5fY3R4ID0gbnVsbDtcbn07XG4vKipcbiAqIOW/q+mAn+iuoeeul1BhdGjljIXlm7Tnm5LvvIjlubbkuI3mmK/mnIDlsI/ljIXlm7Tnm5LvvIlcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5cblBhdGhQcm94eS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQYXRoUHJveHksXG4gIF94aTogMCxcbiAgX3lpOiAwLFxuICBfeDA6IDAsXG4gIF95MDogMCxcbiAgLy8gVW5pdCB4LCBVbml0IHkuIFByb3ZpZGUgZm9yIGF2b2lkaW5nIGRyYXdpbmcgdGhhdCB0b28gc2hvcnQgbGluZSBzZWdtZW50XG4gIF91eDogMCxcbiAgX3V5OiAwLFxuICBfbGVuOiAwLFxuICBfbGluZURhc2g6IG51bGwsXG4gIF9kYXNoT2Zmc2V0OiAwLFxuICBfZGFzaElkeDogMCxcbiAgX2Rhc2hTdW06IDAsXG5cbiAgLyoqXG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgc2V0U2NhbGU6IGZ1bmN0aW9uIChzeCwgc3kpIHtcbiAgICB0aGlzLl91eCA9IG1hdGhBYnMoMSAvIGRwciAvIHN4KSB8fCAwO1xuICAgIHRoaXMuX3V5ID0gbWF0aEFicygxIC8gZHByIC8gc3kpIHx8IDA7XG4gIH0sXG4gIGdldENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3R4O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGJlZ2luUGF0aDogZnVuY3Rpb24gKGN0eCkge1xuICAgIHRoaXMuX2N0eCA9IGN0eDtcbiAgICBjdHggJiYgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eCAmJiAodGhpcy5kcHIgPSBjdHguZHByKTsgLy8gUmVzZXRcblxuICAgIGlmICh0aGlzLl9zYXZlRGF0YSkge1xuICAgICAgdGhpcy5fbGVuID0gMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGluZURhc2gpIHtcbiAgICAgIHRoaXMuX2xpbmVEYXNoID0gbnVsbDtcbiAgICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgbW92ZVRvOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHRoaXMuYWRkRGF0YShDTUQuTSwgeCwgeSk7XG4gICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5tb3ZlVG8oeCwgeSk7IC8vIHgwLCB5MCwgeGksIHlpIOaYr+iusOW9leWcqCBfZGFzaGVkWFhYWFRvIOaWueazleS4reS9v+eUqFxuICAgIC8vIHhpLCB5aSDorrDlvZXlvZPliY3ngrksIHgwLCB5MCDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeWbnuWIsOi1t+Wni+eCueOAglxuICAgIC8vIOacieWPr+iDveWcqCBiZWdpblBhdGgg5LmL5ZCO55u05o6l6LCD55SoIGxpbmVUb++8jOi/meaXtuWAmSB4MCwgeTAg6ZyA6KaBXG4gICAgLy8g5ZyoIGxpbmVUbyDmlrnms5XkuK3orrDlvZXvvIzov5nph4zlhYjkuI3ogIPomZHov5nnp43mg4XlhrXvvIxkYXNoZWQgbGluZSDkuZ/lj6rlnKggSUUxMC0g5Lit5LiN5pSv5oyBXG5cbiAgICB0aGlzLl94MCA9IHg7XG4gICAgdGhpcy5feTAgPSB5O1xuICAgIHRoaXMuX3hpID0geDtcbiAgICB0aGlzLl95aSA9IHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBsaW5lVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIGV4Y2VlZFVuaXQgPSBtYXRoQWJzKHggLSB0aGlzLl94aSkgPiB0aGlzLl91eCB8fCBtYXRoQWJzKHkgLSB0aGlzLl95aSkgPiB0aGlzLl91eSAvLyBGb3JjZSBkcmF3IHRoZSBmaXJzdCBzZWdtZW50XG4gICAgfHwgdGhpcy5fbGVuIDwgNTtcbiAgICB0aGlzLmFkZERhdGEoQ01ELkwsIHgsIHkpO1xuXG4gICAgaWYgKHRoaXMuX2N0eCAmJiBleGNlZWRVbml0KSB7XG4gICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZExpbmVUbyh4LCB5KSA6IHRoaXMuX2N0eC5saW5lVG8oeCwgeSk7XG4gICAgfVxuXG4gICAgaWYgKGV4Y2VlZFVuaXQpIHtcbiAgICAgIHRoaXMuX3hpID0geDtcbiAgICAgIHRoaXMuX3lpID0geTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxXG4gICAqIEBwYXJhbSAge251bWJlcn0geDJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgzXG4gICAqIEBwYXJhbSAge251bWJlcn0geTNcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIHRoaXMuYWRkRGF0YShDTUQuQywgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG5cbiAgICBpZiAodGhpcy5fY3R4KSB7XG4gICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZEJlemllclRvKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIDogdGhpcy5fY3R4LmJlemllckN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gICAgfVxuXG4gICAgdGhpcy5feGkgPSB4MztcbiAgICB0aGlzLl95aSA9IHkzO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxXG4gICAqIEBwYXJhbSAge251bWJlcn0geTFcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgcXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdGhpcy5hZGREYXRhKENNRC5RLCB4MSwgeTEsIHgyLCB5Mik7XG5cbiAgICBpZiAodGhpcy5fY3R4KSB7XG4gICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZFF1YWRyYXRpY1RvKHgxLCB5MSwgeDIsIHkyKSA6IHRoaXMuX2N0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyKTtcbiAgICB9XG5cbiAgICB0aGlzLl94aSA9IHgyO1xuICAgIHRoaXMuX3lpID0geTI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0gY3hcbiAgICogQHBhcmFtICB7bnVtYmVyfSBjeVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSBzdGFydEFuZ2xlXG4gICAqIEBwYXJhbSAge251bWJlcn0gZW5kQW5nbGVcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gYW50aWNsb2Nrd2lzZVxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGFyYzogZnVuY3Rpb24gKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpIHtcbiAgICB0aGlzLmFkZERhdGEoQ01ELkEsIGN4LCBjeSwgciwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUgLSBzdGFydEFuZ2xlLCAwLCBhbnRpY2xvY2t3aXNlID8gMCA6IDEpO1xuICAgIHRoaXMuX2N0eCAmJiB0aGlzLl9jdHguYXJjKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpO1xuICAgIHRoaXMuX3hpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByICsgY3g7XG4gICAgdGhpcy5feWkgPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHIgKyBjeDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gVE9ET1xuICBhcmNUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcbiAgICBpZiAodGhpcy5fY3R4KSB7XG4gICAgICB0aGlzLl9jdHguYXJjVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIFRPRE9cbiAgcmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcbiAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgdGhpcy5hZGREYXRhKENNRC5SLCB4LCB5LCB3LCBoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBjbG9zZVBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFkZERhdGEoQ01ELlopO1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgdmFyIHgwID0gdGhpcy5feDA7XG4gICAgdmFyIHkwID0gdGhpcy5feTA7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICB0aGlzLl9uZWVkc0Rhc2goKSAmJiB0aGlzLl9kYXNoZWRMaW5lVG8oeDAsIHkwKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG5cbiAgICB0aGlzLl94aSA9IHgwO1xuICAgIHRoaXMuX3lpID0geTA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnRleHQg5LuO5aSW6YOo5Lyg5YWl77yM5Zug5Li65pyJ5Y+v6IO95pivIHJlYnVpbGRQYXRoIOWujOS5i+WQjuWGjSBmaWxs44CCXG4gICAqIHN0cm9rZSDlkIzmoLdcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGZpbGw6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICBjdHggJiYgY3R4LmZpbGwoKTtcbiAgICB0aGlzLnRvU3RhdGljKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBzdHJva2U6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICBjdHggJiYgY3R4LnN0cm9rZSgpO1xuICAgIHRoaXMudG9TdGF0aWMoKTtcbiAgfSxcblxuICAvKipcbiAgICog5b+F6aG75Zyo5YW25a6D57uY5Yi25ZG95Luk5YmN6LCD55SoXG4gICAqIE11c3QgYmUgaW52b2tlZCBiZWZvcmUgYWxsIG90aGVyIHBhdGggZHJhd2luZyBtZXRob2RzXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgc2V0TGluZURhc2g6IGZ1bmN0aW9uIChsaW5lRGFzaCkge1xuICAgIGlmIChsaW5lRGFzaCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICB0aGlzLl9saW5lRGFzaCA9IGxpbmVEYXNoO1xuICAgICAgdGhpcy5fZGFzaElkeCA9IDA7XG4gICAgICB2YXIgbGluZURhc2hTdW0gPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVEYXNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpbmVEYXNoU3VtICs9IGxpbmVEYXNoW2ldO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kYXNoU3VtID0gbGluZURhc2hTdW07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOW/hemhu+WcqOWFtuWug+e7mOWItuWRveS7pOWJjeiwg+eUqFxuICAgKiBNdXN0IGJlIGludm9rZWQgYmVmb3JlIGFsbCBvdGhlciBwYXRoIGRyYXdpbmcgbWV0aG9kc1xuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIHNldExpbmVEYXNoT2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgdGhpcy5fZGFzaE9mZnNldCA9IG9mZnNldDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGxlbjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9sZW47XG4gIH0sXG5cbiAgLyoqXG4gICAqIOebtOaOpeiuvue9riBQYXRoIOaVsOaNrlxuICAgKi9cbiAgc2V0RGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgbGVuID0gZGF0YS5sZW5ndGg7XG5cbiAgICBpZiAoISh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmxlbmd0aCA9PSBsZW4pICYmIGhhc1R5cGVkQXJyYXkpIHtcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkobGVuKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLmRhdGFbaV0gPSBkYXRhW2ldO1xuICAgIH1cblxuICAgIHRoaXMuX2xlbiA9IGxlbjtcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5a2Q6Lev5b6EXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl8QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5Pn0gcGF0aFxuICAgKi9cbiAgYXBwZW5kUGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICBwYXRoID0gW3BhdGhdO1xuICAgIH1cblxuICAgIHZhciBsZW4gPSBwYXRoLmxlbmd0aDtcbiAgICB2YXIgYXBwZW5kU2l6ZSA9IDA7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMuX2xlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFwcGVuZFNpemUgKz0gcGF0aFtpXS5sZW4oKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVHlwZWRBcnJheSAmJiB0aGlzLmRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkob2Zmc2V0ICsgYXBwZW5kU2l6ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGFwcGVuZFBhdGhEYXRhID0gcGF0aFtpXS5kYXRhO1xuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGFwcGVuZFBhdGhEYXRhLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHRoaXMuZGF0YVtvZmZzZXQrK10gPSBhcHBlbmRQYXRoRGF0YVtrXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9sZW4gPSBvZmZzZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWhq+WFhSBQYXRoIOaVsOaNruOAglxuICAgKiDlsL3ph4/lpI3nlKjogIzkuI3nlLPmmI7mlrDnmoTmlbDnu4TjgILlpKfpg6jliIblm77lvaLph43nu5jnmoTmjIfku6TmlbDmja7plb/luqbpg73mmK/kuI3lj5jnmoTjgIJcbiAgICovXG4gIGFkZERhdGE6IGZ1bmN0aW9uIChjbWQpIHtcbiAgICBpZiAoIXRoaXMuX3NhdmVEYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG5cbiAgICBpZiAodGhpcy5fbGVuICsgYXJndW1lbnRzLmxlbmd0aCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAvLyDlm6DkuLrkuYvliY3nmoTmlbDnu4Tlt7Lnu4/ovazmjaLmiJDpnZnmgIHnmoQgRmxvYXQzMkFycmF5XG4gICAgICAvLyDmiYDku6XkuI3lpJ/nlKjml7bpnIDopoHmianlsZXkuIDkuKrmlrDnmoTliqjmgIHmlbDnu4RcbiAgICAgIHRoaXMuX2V4cGFuZERhdGEoKTtcblxuICAgICAgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YVt0aGlzLl9sZW4rK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgdGhpcy5fcHJldkNtZCA9IGNtZDtcbiAgfSxcbiAgX2V4cGFuZERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBPbmx5IGlmIGRhdGEgaXMgRmxvYXQzMkFycmF5XG4gICAgaWYgKCEodGhpcy5kYXRhIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICB2YXIgbmV3RGF0YSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xlbjsgaSsrKSB7XG4gICAgICAgIG5ld0RhdGFbaV0gPSB0aGlzLmRhdGFbaV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGF0YSA9IG5ld0RhdGE7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBuZWVkcyBqcyBpbXBsZW1lbnRlZCBkYXNoZWQgbGluZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX25lZWRzRGFzaDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9saW5lRGFzaDtcbiAgfSxcbiAgX2Rhc2hlZExpbmVUbzogZnVuY3Rpb24gKHgxLCB5MSkge1xuICAgIHZhciBkYXNoU3VtID0gdGhpcy5fZGFzaFN1bTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZGFzaE9mZnNldDtcbiAgICB2YXIgbGluZURhc2ggPSB0aGlzLl9saW5lRGFzaDtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIHZhciB4MCA9IHRoaXMuX3hpO1xuICAgIHZhciB5MCA9IHRoaXMuX3lpO1xuICAgIHZhciBkeCA9IHgxIC0geDA7XG4gICAgdmFyIGR5ID0geTEgLSB5MDtcbiAgICB2YXIgZGlzdCA9IG1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB2YXIgeCA9IHgwO1xuICAgIHZhciB5ID0geTA7XG4gICAgdmFyIGRhc2g7XG4gICAgdmFyIG5EYXNoID0gbGluZURhc2gubGVuZ3RoO1xuICAgIHZhciBpZHg7XG4gICAgZHggLz0gZGlzdDtcbiAgICBkeSAvPSBkaXN0O1xuXG4gICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgIC8vIENvbnZlcnQgdG8gcG9zaXRpdmUgb2Zmc2V0XG4gICAgICBvZmZzZXQgPSBkYXNoU3VtICsgb2Zmc2V0O1xuICAgIH1cblxuICAgIG9mZnNldCAlPSBkYXNoU3VtO1xuICAgIHggLT0gb2Zmc2V0ICogZHg7XG4gICAgeSAtPSBvZmZzZXQgKiBkeTtcblxuICAgIHdoaWxlIChkeCA+IDAgJiYgeCA8PSB4MSB8fCBkeCA8IDAgJiYgeCA+PSB4MSB8fCBkeCA9PSAwICYmIChkeSA+IDAgJiYgeSA8PSB5MSB8fCBkeSA8IDAgJiYgeSA+PSB5MSkpIHtcbiAgICAgIGlkeCA9IHRoaXMuX2Rhc2hJZHg7XG4gICAgICBkYXNoID0gbGluZURhc2hbaWR4XTtcbiAgICAgIHggKz0gZHggKiBkYXNoO1xuICAgICAgeSArPSBkeSAqIGRhc2g7XG4gICAgICB0aGlzLl9kYXNoSWR4ID0gKGlkeCArIDEpICUgbkRhc2g7IC8vIFNraXAgcG9zaXRpdmUgb2Zmc2V0XG5cbiAgICAgIGlmIChkeCA+IDAgJiYgeCA8IHgwIHx8IGR4IDwgMCAmJiB4ID4geDAgfHwgZHkgPiAwICYmIHkgPCB5MCB8fCBkeSA8IDAgJiYgeSA+IHkwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjdHhbaWR4ICUgMiA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKGR4ID49IDAgPyBtYXRoTWluKHgsIHgxKSA6IG1hdGhNYXgoeCwgeDEpLCBkeSA+PSAwID8gbWF0aE1pbih5LCB5MSkgOiBtYXRoTWF4KHksIHkxKSk7XG4gICAgfSAvLyBPZmZzZXQgZm9yIG5leHQgbGluZVRvXG5cblxuICAgIGR4ID0geCAtIHgxO1xuICAgIGR5ID0geSAtIHkxO1xuICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAtbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICB9LFxuICAvLyBOb3QgYWNjdXJhdGUgZGFzaGVkIGxpbmUgdG9cbiAgX2Rhc2hlZEJlemllclRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIHZhciBkYXNoU3VtID0gdGhpcy5fZGFzaFN1bTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZGFzaE9mZnNldDtcbiAgICB2YXIgbGluZURhc2ggPSB0aGlzLl9saW5lRGFzaDtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIHZhciB4MCA9IHRoaXMuX3hpO1xuICAgIHZhciB5MCA9IHRoaXMuX3lpO1xuICAgIHZhciB0O1xuICAgIHZhciBkeDtcbiAgICB2YXIgZHk7XG4gICAgdmFyIGN1YmljQXQgPSBjdXJ2ZS5jdWJpY0F0O1xuICAgIHZhciBiZXppZXJMZW4gPSAwO1xuICAgIHZhciBpZHggPSB0aGlzLl9kYXNoSWR4O1xuICAgIHZhciBuRGFzaCA9IGxpbmVEYXNoLmxlbmd0aDtcbiAgICB2YXIgeDtcbiAgICB2YXIgeTtcbiAgICB2YXIgdG1wTGVuID0gMDtcblxuICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAvLyBDb252ZXJ0IHRvIHBvc2l0aXZlIG9mZnNldFxuICAgICAgb2Zmc2V0ID0gZGFzaFN1bSArIG9mZnNldDtcbiAgICB9XG5cbiAgICBvZmZzZXQgJT0gZGFzaFN1bTsgLy8gQmV6aWVyIGFwcHJveCBsZW5ndGhcblxuICAgIGZvciAodCA9IDA7IHQgPCAxOyB0ICs9IDAuMSkge1xuICAgICAgZHggPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0ICsgMC4xKSAtIGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgICAgZHkgPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0ICsgMC4xKSAtIGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQpO1xuICAgICAgYmV6aWVyTGVuICs9IG1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB9IC8vIEZpbmQgaWR4IGFmdGVyIGFkZCBvZmZzZXRcblxuXG4gICAgZm9yICg7IGlkeCA8IG5EYXNoOyBpZHgrKykge1xuICAgICAgdG1wTGVuICs9IGxpbmVEYXNoW2lkeF07XG5cbiAgICAgIGlmICh0bXBMZW4gPiBvZmZzZXQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdCA9ICh0bXBMZW4gLSBvZmZzZXQpIC8gYmV6aWVyTGVuO1xuXG4gICAgd2hpbGUgKHQgPD0gMSkge1xuICAgICAgeCA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgICAgeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQpOyAvLyBVc2UgbGluZSB0byBhcHByb3hpbWF0ZSBkYXNoZWQgYmV6aWVyXG4gICAgICAvLyBCYWQgcmVzdWx0IGlmIGRhc2ggaXMgbG9uZ1xuXG4gICAgICBpZHggJSAyID8gY3R4Lm1vdmVUbyh4LCB5KSA6IGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICB0ICs9IGxpbmVEYXNoW2lkeF0gLyBiZXppZXJMZW47XG4gICAgICBpZHggPSAoaWR4ICsgMSkgJSBuRGFzaDtcbiAgICB9IC8vIEZpbmlzaCB0aGUgbGFzdCBzZWdtZW50IGFuZCBjYWxjdWxhdGUgdGhlIG5ldyBvZmZzZXRcblxuXG4gICAgaWR4ICUgMiAhPT0gMCAmJiBjdHgubGluZVRvKHgzLCB5Myk7XG4gICAgZHggPSB4MyAtIHg7XG4gICAgZHkgPSB5MyAtIHk7XG4gICAgdGhpcy5fZGFzaE9mZnNldCA9IC1tYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIH0sXG4gIF9kYXNoZWRRdWFkcmF0aWNUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgLy8gQ29udmVydCBxdWFkcmF0aWMgdG8gY3ViaWMgdXNpbmcgZGVncmVlIGVsZXZhdGlvblxuICAgIHZhciB4MyA9IHgyO1xuICAgIHZhciB5MyA9IHkyO1xuICAgIHgyID0gKHgyICsgMiAqIHgxKSAvIDM7XG4gICAgeTIgPSAoeTIgKyAyICogeTEpIC8gMztcbiAgICB4MSA9ICh0aGlzLl94aSArIDIgKiB4MSkgLyAzO1xuICAgIHkxID0gKHRoaXMuX3lpICsgMiAqIHkxKSAvIDM7XG5cbiAgICB0aGlzLl9kYXNoZWRCZXppZXJUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgfSxcblxuICAvKipcbiAgICog6L2s5oiQ6Z2Z5oCB55qEIEZsb2F0MzJBcnJheSDlh4/lsJHloIblhoXlrZjljaDnlKhcbiAgICogQ29udmVydCBkeW5hbWljIGFycmF5IHRvIHN0YXRpYyBGbG9hdDMyQXJyYXlcbiAgICovXG4gIHRvU3RhdGljOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG5cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBkYXRhLmxlbmd0aCA9IHRoaXMuX2xlbjtcblxuICAgICAgaWYgKGhhc1R5cGVkQXJyYXkpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgKi9cbiAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgbWluWzBdID0gbWluWzFdID0gbWluMlswXSA9IG1pbjJbMV0gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIG1heFswXSA9IG1heFsxXSA9IG1heDJbMF0gPSBtYXgyWzFdID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIHhpID0gMDtcbiAgICB2YXIgeWkgPSAwO1xuICAgIHZhciB4MCA9IDA7XG4gICAgdmFyIHkwID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgICB2YXIgY21kID0gZGF0YVtpKytdO1xuXG4gICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgIC8vIOWmguaenOesrOS4gOS4quWRveS7pOaYryBMLCBDLCBRXG4gICAgICAgIC8vIOWImSBwcmV2aW91cyBwb2ludCDlkIznu5jliLblkb3ku6TnmoTnrKzkuIDkuKogcG9pbnRcbiAgICAgICAgLy9cbiAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk5Li6IEFyYyDnmoTmg4XlhrXkuIvkvJrlnKjlkI7pnaLnibnmrorlpITnkIZcbiAgICAgICAgeGkgPSBkYXRhW2ldO1xuICAgICAgICB5aSA9IGRhdGFbaSArIDFdO1xuICAgICAgICB4MCA9IHhpO1xuICAgICAgICB5MCA9IHlpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICBjYXNlIENNRC5NOlxuICAgICAgICAgIC8vIG1vdmVUbyDlkb3ku6Tph43mlrDliJvlu7rkuIDkuKrmlrDnmoQgc3VicGF0aCwg5bm25LiU5pu05paw5paw55qE6LW354K5XG4gICAgICAgICAgLy8g5ZyoIGNsb3NlUGF0aCDnmoTml7blgJnkvb/nlKhcbiAgICAgICAgICB4MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgbWluMlswXSA9IHgwO1xuICAgICAgICAgIG1pbjJbMV0gPSB5MDtcbiAgICAgICAgICBtYXgyWzBdID0geDA7XG4gICAgICAgICAgbWF4MlsxXSA9IHkwO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgYmJveC5mcm9tTGluZSh4aSwgeWksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5DOlxuICAgICAgICAgIGJib3guZnJvbUN1YmljKHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgICBiYm94LmZyb21RdWFkcmF0aWMoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIG1pbjIsIG1heDIpO1xuICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgICAgLy8gVE9ETyBBcmMg5Yik5pat55qE5byA6ZSA5q+U6L6D5aSnXG4gICAgICAgICAgdmFyIGN4ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgcnggPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHJ5ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciBlbmRBbmdsZSA9IGRhdGFbaSsrXSArIHN0YXJ0QW5nbGU7IC8vIFRPRE8gQXJjIOaXi+i9rFxuXG4gICAgICAgICAgdmFyIHBzaSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgYW50aWNsb2Nrd2lzZSA9IDEgLSBkYXRhW2krK107XG5cbiAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAvLyDnm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICB4MCA9IG1hdGhDb3Moc3RhcnRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgICAgeTAgPSBtYXRoU2luKHN0YXJ0QW5nbGUpICogcnkgKyBjeTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBiYm94LmZyb21BcmMoY3gsIGN5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICB4aSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyBjeDtcbiAgICAgICAgICB5aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogcnkgKyBjeTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5SOlxuICAgICAgICAgIHgwID0geGkgPSBkYXRhW2krK107XG4gICAgICAgICAgeTAgPSB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgd2lkdGggPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIGhlaWdodCA9IGRhdGFbaSsrXTsgLy8gVXNlIGZyb21MaW5lXG5cbiAgICAgICAgICBiYm94LmZyb21MaW5lKHgwLCB5MCwgeDAgKyB3aWR0aCwgeTAgKyBoZWlnaHQsIG1pbjIsIG1heDIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICB5aSA9IHkwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBVbmlvblxuXG5cbiAgICAgIHZlYzIubWluKG1pbiwgbWluLCBtaW4yKTtcbiAgICAgIHZlYzIubWF4KG1heCwgbWF4LCBtYXgyKTtcbiAgICB9IC8vIE5vIGRhdGFcblxuXG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIG1pblswXSA9IG1pblsxXSA9IG1heFswXSA9IG1heFsxXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVidWlsZCBwYXRoIGZyb20gY3VycmVudCBkYXRhXG4gICAqIFJlYnVpbGQgcGF0aCB3aWxsIG5vdCBjb25zaWRlciBqYXZhc2NyaXB0IGltcGxlbWVudGVkIGxpbmUgZGFzaC5cbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKi9cbiAgcmVidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICB2YXIgZCA9IHRoaXMuZGF0YTtcbiAgICB2YXIgeDAsIHkwO1xuICAgIHZhciB4aSwgeWk7XG4gICAgdmFyIHgsIHk7XG4gICAgdmFyIHV4ID0gdGhpcy5fdXg7XG4gICAgdmFyIHV5ID0gdGhpcy5fdXk7XG4gICAgdmFyIGxlbiA9IHRoaXMuX2xlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgdmFyIGNtZCA9IGRbaSsrXTtcblxuICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAvLyDlpoLmnpznrKzkuIDkuKrlkb3ku6TmmK8gTCwgQywgUVxuICAgICAgICAvLyDliJkgcHJldmlvdXMgcG9pbnQg5ZCM57uY5Yi25ZG95Luk55qE56ys5LiA5LiqIHBvaW50XG4gICAgICAgIC8vXG4gICAgICAgIC8vIOesrOS4gOS4quWRveS7pOS4uiBBcmMg55qE5oOF5Ya15LiL5Lya5Zyo5ZCO6Z2i54m55q6K5aSE55CGXG4gICAgICAgIHhpID0gZFtpXTtcbiAgICAgICAgeWkgPSBkW2kgKyAxXTtcbiAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgeTAgPSB5aTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgY2FzZSBDTUQuTTpcbiAgICAgICAgICB4MCA9IHhpID0gZFtpKytdO1xuICAgICAgICAgIHkwID0geWkgPSBkW2krK107XG4gICAgICAgICAgY3R4Lm1vdmVUbyh4aSwgeWkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgeCA9IGRbaSsrXTtcbiAgICAgICAgICB5ID0gZFtpKytdOyAvLyBOb3QgZHJhdyB0b28gc21hbGwgc2VnIGJldHdlZW5cblxuICAgICAgICAgIGlmIChtYXRoQWJzKHggLSB4aSkgPiB1eCB8fCBtYXRoQWJzKHkgLSB5aSkgPiB1eSB8fCBpID09PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgeGkgPSB4O1xuICAgICAgICAgICAgeWkgPSB5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSk7XG4gICAgICAgICAgeGkgPSBkW2kgLSAyXTtcbiAgICAgICAgICB5aSA9IGRbaSAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlE6XG4gICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICB4aSA9IGRbaSAtIDJdO1xuICAgICAgICAgIHlpID0gZFtpIC0gMV07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICB2YXIgY3ggPSBkW2krK107XG4gICAgICAgICAgdmFyIGN5ID0gZFtpKytdO1xuICAgICAgICAgIHZhciByeCA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgcnkgPSBkW2krK107XG4gICAgICAgICAgdmFyIHRoZXRhID0gZFtpKytdO1xuICAgICAgICAgIHZhciBkVGhldGEgPSBkW2krK107XG4gICAgICAgICAgdmFyIHBzaSA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgZnMgPSBkW2krK107XG4gICAgICAgICAgdmFyIHIgPSByeCA+IHJ5ID8gcnggOiByeTtcbiAgICAgICAgICB2YXIgc2NhbGVYID0gcnggPiByeSA/IDEgOiByeCAvIHJ5O1xuICAgICAgICAgIHZhciBzY2FsZVkgPSByeCA+IHJ5ID8gcnkgLyByeCA6IDE7XG4gICAgICAgICAgdmFyIGlzRWxsaXBzZSA9IE1hdGguYWJzKHJ4IC0gcnkpID4gMWUtMztcbiAgICAgICAgICB2YXIgZW5kQW5nbGUgPSB0aGV0YSArIGRUaGV0YTtcblxuICAgICAgICAgIGlmIChpc0VsbGlwc2UpIHtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY3gsIGN5KTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUocHNpKTtcbiAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICBjdHguYXJjKDAsIDAsIHIsIHRoZXRhLCBlbmRBbmdsZSwgMSAtIGZzKTtcbiAgICAgICAgICAgIGN0eC5zY2FsZSgxIC8gc2NhbGVYLCAxIC8gc2NhbGVZKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoLXBzaSk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1jeCwgLWN5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmFyYyhjeCwgY3ksIHIsIHRoZXRhLCBlbmRBbmdsZSwgMSAtIGZzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAvLyDnm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICB4MCA9IG1hdGhDb3ModGhldGEpICogcnggKyBjeDtcbiAgICAgICAgICAgIHkwID0gbWF0aFNpbih0aGV0YSkgKiByeSArIGN5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHhpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgIHlpID0gbWF0aFNpbihlbmRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgeDAgPSB4aSA9IGRbaV07XG4gICAgICAgICAgeTAgPSB5aSA9IGRbaSArIDFdO1xuICAgICAgICAgIGN0eC5yZWN0KGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICB5aSA9IHkwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblBhdGhQcm94eS5DTUQgPSBDTUQ7XG52YXIgX2RlZmF1bHQgPSBQYXRoUHJveHk7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL1BhdGhQcm94eS5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi92ZWN0b3JcIik7XG5cbnZhciB2MkNyZWF0ZSA9IF92ZWN0b3IuY3JlYXRlO1xudmFyIHYyRGlzdFNxdWFyZSA9IF92ZWN0b3IuZGlzdFNxdWFyZTtcblxuLyoqXG4gKiDmm7Lnur/ovoXliqnmqKHlnZdcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL2N1cnZlXG4gKiBAYXV0aG9yIHBpc3NhbmcoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG52YXIgbWF0aFBvdyA9IE1hdGgucG93O1xudmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xudmFyIEVQU0lMT04gPSAxZS04O1xudmFyIEVQU0lMT05fTlVNRVJJQyA9IDFlLTQ7XG52YXIgVEhSRUVfU1FSVCA9IG1hdGhTcXJ0KDMpO1xudmFyIE9ORV9USElSRCA9IDEgLyAzOyAvLyDkuLTml7blj5jph49cblxudmFyIF92MCA9IHYyQ3JlYXRlKCk7XG5cbnZhciBfdjEgPSB2MkNyZWF0ZSgpO1xuXG52YXIgX3YyID0gdjJDcmVhdGUoKTtcblxuZnVuY3Rpb24gaXNBcm91bmRaZXJvKHZhbCkge1xuICByZXR1cm4gdmFsID4gLUVQU0lMT04gJiYgdmFsIDwgRVBTSUxPTjtcbn1cblxuZnVuY3Rpb24gaXNOb3RBcm91bmRaZXJvKHZhbCkge1xuICByZXR1cm4gdmFsID4gRVBTSUxPTiB8fCB2YWwgPCAtRVBTSUxPTjtcbn1cbi8qKlxuICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5YC8XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY0F0KHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gIHZhciBvbmV0ID0gMSAtIHQ7XG4gIHJldHVybiBvbmV0ICogb25ldCAqIChvbmV0ICogcDAgKyAzICogdCAqIHAxKSArIHQgKiB0ICogKHQgKiBwMyArIDMgKiBvbmV0ICogcDIpO1xufVxuLyoqXG4gKiDorqHnrpfkuInmrKHotJ3loZ7lsJTlr7zmlbDlgLxcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGN1YmljRGVyaXZhdGl2ZUF0KHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gIHZhciBvbmV0ID0gMSAtIHQ7XG4gIHJldHVybiAzICogKCgocDEgLSBwMCkgKiBvbmV0ICsgMiAqIChwMiAtIHAxKSAqIHQpICogb25ldCArIChwMyAtIHAyKSAqIHQgKiB0KTtcbn1cbi8qKlxuICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5pa556iL5qC577yM5L2/55So55ub6YeR5YWs5byPXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB2YWxcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSByb290c1xuICogQHJldHVybiB7bnVtYmVyfSDmnInmlYjmoLnmlbDnm65cbiAqL1xuXG5cbmZ1bmN0aW9uIGN1YmljUm9vdEF0KHAwLCBwMSwgcDIsIHAzLCB2YWwsIHJvb3RzKSB7XG4gIC8vIEV2YWx1YXRlIHJvb3RzIG9mIGN1YmljIGZ1bmN0aW9uc1xuICB2YXIgYSA9IHAzICsgMyAqIChwMSAtIHAyKSAtIHAwO1xuICB2YXIgYiA9IDMgKiAocDIgLSBwMSAqIDIgKyBwMCk7XG4gIHZhciBjID0gMyAqIChwMSAtIHAwKTtcbiAgdmFyIGQgPSBwMCAtIHZhbDtcbiAgdmFyIEEgPSBiICogYiAtIDMgKiBhICogYztcbiAgdmFyIEIgPSBiICogYyAtIDkgKiBhICogZDtcbiAgdmFyIEMgPSBjICogYyAtIDMgKiBiICogZDtcbiAgdmFyIG4gPSAwO1xuXG4gIGlmIChpc0Fyb3VuZFplcm8oQSkgJiYgaXNBcm91bmRaZXJvKEIpKSB7XG4gICAgaWYgKGlzQXJvdW5kWmVybyhiKSkge1xuICAgICAgcm9vdHNbMF0gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdDEgPSAtYyAvIGI7IC8vdDEsIHQyLCB0MywgYiBpcyBub3QgemVyb1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpc2MgPSBCICogQiAtIDQgKiBBICogQztcblxuICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgIHZhciBLID0gQiAvIEE7XG4gICAgICB2YXIgdDEgPSAtYiAvIGEgKyBLOyAvLyB0MSwgYSBpcyBub3QgemVyb1xuXG4gICAgICB2YXIgdDIgPSAtSyAvIDI7IC8vIHQyLCB0M1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cblxuICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgdmFyIGRpc2NTcXJ0ID0gbWF0aFNxcnQoZGlzYyk7XG4gICAgICB2YXIgWTEgPSBBICogYiArIDEuNSAqIGEgKiAoLUIgKyBkaXNjU3FydCk7XG4gICAgICB2YXIgWTIgPSBBICogYiArIDEuNSAqIGEgKiAoLUIgLSBkaXNjU3FydCk7XG5cbiAgICAgIGlmIChZMSA8IDApIHtcbiAgICAgICAgWTEgPSAtbWF0aFBvdygtWTEsIE9ORV9USElSRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBZMSA9IG1hdGhQb3coWTEsIE9ORV9USElSRCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChZMiA8IDApIHtcbiAgICAgICAgWTIgPSAtbWF0aFBvdygtWTIsIE9ORV9USElSRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBZMiA9IG1hdGhQb3coWTIsIE9ORV9USElSRCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0MSA9ICgtYiAtIChZMSArIFkyKSkgLyAoMyAqIGEpO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIFQgPSAoMiAqIEEgKiBiIC0gMyAqIGEgKiBCKSAvICgyICogbWF0aFNxcnQoQSAqIEEgKiBBKSk7XG4gICAgICB2YXIgdGhldGEgPSBNYXRoLmFjb3MoVCkgLyAzO1xuICAgICAgdmFyIEFTcXJ0ID0gbWF0aFNxcnQoQSk7XG4gICAgICB2YXIgdG1wID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgdmFyIHQxID0gKC1iIC0gMiAqIEFTcXJ0ICogdG1wKSAvICgzICogYSk7XG4gICAgICB2YXIgdDIgPSAoLWIgKyBBU3FydCAqICh0bXAgKyBUSFJFRV9TUVJUICogTWF0aC5zaW4odGhldGEpKSkgLyAoMyAqIGEpO1xuICAgICAgdmFyIHQzID0gKC1iICsgQVNxcnQgKiAodG1wIC0gVEhSRUVfU1FSVCAqIE1hdGguc2luKHRoZXRhKSkpIC8gKDMgKiBhKTtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQyO1xuICAgICAgfVxuXG4gICAgICBpZiAodDMgPj0gMCAmJiB0MyA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbjtcbn1cbi8qKlxuICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5pa556iL5p6B6ZmQ5YC855qE5L2N572uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IGV4dHJlbWFcbiAqIEByZXR1cm4ge251bWJlcn0g5pyJ5pWI5pWw55uuXG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY0V4dHJlbWEocDAsIHAxLCBwMiwgcDMsIGV4dHJlbWEpIHtcbiAgdmFyIGIgPSA2ICogcDIgLSAxMiAqIHAxICsgNiAqIHAwO1xuICB2YXIgYSA9IDkgKiBwMSArIDMgKiBwMyAtIDMgKiBwMCAtIDkgKiBwMjtcbiAgdmFyIGMgPSAzICogcDEgLSAzICogcDA7XG4gIHZhciBuID0gMDtcblxuICBpZiAoaXNBcm91bmRaZXJvKGEpKSB7XG4gICAgaWYgKGlzTm90QXJvdW5kWmVybyhiKSkge1xuICAgICAgdmFyIHQxID0gLWMgLyBiO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIGV4dHJlbWFbbisrXSA9IHQxO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuXG4gICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgZXh0cmVtYVswXSA9IC1iIC8gKDIgKiBhKTtcbiAgICB9IGVsc2UgaWYgKGRpc2MgPiAwKSB7XG4gICAgICB2YXIgZGlzY1NxcnQgPSBtYXRoU3FydChkaXNjKTtcbiAgICAgIHZhciB0MSA9ICgtYiArIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICB2YXIgdDIgPSAoLWIgLSBkaXNjU3FydCkgLyAoMiAqIGEpO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIGV4dHJlbWFbbisrXSA9IHQxO1xuICAgICAgfVxuXG4gICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgIGV4dHJlbWFbbisrXSA9IHQyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuO1xufVxuLyoqXG4gKiDnu4bliIbkuInmrKHotJ3loZ7lsJTmm7Lnur9cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGN1YmljU3ViZGl2aWRlKHAwLCBwMSwgcDIsIHAzLCB0LCBvdXQpIHtcbiAgdmFyIHAwMSA9IChwMSAtIHAwKSAqIHQgKyBwMDtcbiAgdmFyIHAxMiA9IChwMiAtIHAxKSAqIHQgKyBwMTtcbiAgdmFyIHAyMyA9IChwMyAtIHAyKSAqIHQgKyBwMjtcbiAgdmFyIHAwMTIgPSAocDEyIC0gcDAxKSAqIHQgKyBwMDE7XG4gIHZhciBwMTIzID0gKHAyMyAtIHAxMikgKiB0ICsgcDEyO1xuICB2YXIgcDAxMjMgPSAocDEyMyAtIHAwMTIpICogdCArIHAwMTI7IC8vIFNlZzBcblxuICBvdXRbMF0gPSBwMDtcbiAgb3V0WzFdID0gcDAxO1xuICBvdXRbMl0gPSBwMDEyO1xuICBvdXRbM10gPSBwMDEyMzsgLy8gU2VnMVxuXG4gIG91dFs0XSA9IHAwMTIzO1xuICBvdXRbNV0gPSBwMTIzO1xuICBvdXRbNl0gPSBwMjM7XG4gIG91dFs3XSA9IHAzO1xufVxuLyoqXG4gKiDmipXlsITngrnliLDkuInmrKHotJ3loZ7lsJTmm7Lnur/kuIrvvIzov5Tlm57mipXlsITot53nprvjgIJcbiAqIOaKleWwhOeCueacieWPr+iDveS8muacieS4gOS4quaIluiAheWkmuS4qu+8jOi/memHjOWPqui/lOWbnuWFtuS4rei3neemu+acgOefreeahOS4gOS4quOAglxuICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gKiBAcGFyYW0ge251bWJlcn0geTBcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge251bWJlcn0geDJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gKiBAcGFyYW0ge251bWJlcn0geTNcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW291dF0g5oqV5bCE54K5XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY1Byb2plY3RQb2ludCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHgsIHksIG91dCkge1xuICAvLyBodHRwOi8vcG9tYXguZ2l0aHViLmlvL2JlemllcmluZm8vI3Byb2plY3Rpb25zXG4gIHZhciB0O1xuICB2YXIgaW50ZXJ2YWwgPSAwLjAwNTtcbiAgdmFyIGQgPSBJbmZpbml0eTtcbiAgdmFyIHByZXY7XG4gIHZhciBuZXh0O1xuICB2YXIgZDE7XG4gIHZhciBkMjtcbiAgX3YwWzBdID0geDtcbiAgX3YwWzFdID0geTsgLy8g5YWI57KX55Wl5Lyw6K6h5LiA5LiL5Y+v6IO955qE5pyA5bCP6Led56a755qEIHQg5YC8XG4gIC8vIFBFTkRJTkdcblxuICBmb3IgKHZhciBfdCA9IDA7IF90IDwgMTsgX3QgKz0gMC4wNSkge1xuICAgIF92MVswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIF90KTtcbiAgICBfdjFbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBfdCk7XG4gICAgZDEgPSB2MkRpc3RTcXVhcmUoX3YwLCBfdjEpO1xuXG4gICAgaWYgKGQxIDwgZCkge1xuICAgICAgdCA9IF90O1xuICAgICAgZCA9IGQxO1xuICAgIH1cbiAgfVxuXG4gIGQgPSBJbmZpbml0eTsgLy8gQXQgbW9zdCAzMiBpdGVyYXRpb25cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICBpZiAoaW50ZXJ2YWwgPCBFUFNJTE9OX05VTUVSSUMpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHByZXYgPSB0IC0gaW50ZXJ2YWw7XG4gICAgbmV4dCA9IHQgKyBpbnRlcnZhbDsgLy8gdCAtIGludGVydmFsXG5cbiAgICBfdjFbMF0gPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCBwcmV2KTtcbiAgICBfdjFbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBwcmV2KTtcbiAgICBkMSA9IHYyRGlzdFNxdWFyZShfdjEsIF92MCk7XG5cbiAgICBpZiAocHJldiA+PSAwICYmIGQxIDwgZCkge1xuICAgICAgdCA9IHByZXY7XG4gICAgICBkID0gZDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHQgKyBpbnRlcnZhbFxuICAgICAgX3YyWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgbmV4dCk7XG4gICAgICBfdjJbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBuZXh0KTtcbiAgICAgIGQyID0gdjJEaXN0U3F1YXJlKF92MiwgX3YwKTtcblxuICAgICAgaWYgKG5leHQgPD0gMSAmJiBkMiA8IGQpIHtcbiAgICAgICAgdCA9IG5leHQ7XG4gICAgICAgIGQgPSBkMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVydmFsICo9IDAuNTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gdFxuXG5cbiAgaWYgKG91dCkge1xuICAgIG91dFswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgIG91dFsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQpO1xuICB9IC8vIGNvbnNvbGUubG9nKGludGVydmFsLCBpKTtcblxuXG4gIHJldHVybiBtYXRoU3FydChkKTtcbn1cbi8qKlxuICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5YC8XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIHF1YWRyYXRpY0F0KHAwLCBwMSwgcDIsIHQpIHtcbiAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgcmV0dXJuIG9uZXQgKiAob25ldCAqIHAwICsgMiAqIHQgKiBwMSkgKyB0ICogdCAqIHAyO1xufVxuLyoqXG4gKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTlr7zmlbDlgLxcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljRGVyaXZhdGl2ZUF0KHAwLCBwMSwgcDIsIHQpIHtcbiAgcmV0dXJuIDIgKiAoKDEgLSB0KSAqIChwMSAtIHAwKSArIHQgKiAocDIgLSBwMSkpO1xufVxuLyoqXG4gKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTmlrnnqIvmoLlcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IHJvb3RzXG4gKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOagueaVsOebrlxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljUm9vdEF0KHAwLCBwMSwgcDIsIHZhbCwgcm9vdHMpIHtcbiAgdmFyIGEgPSBwMCAtIDIgKiBwMSArIHAyO1xuICB2YXIgYiA9IDIgKiAocDEgLSBwMCk7XG4gIHZhciBjID0gcDAgLSB2YWw7XG4gIHZhciBuID0gMDtcblxuICBpZiAoaXNBcm91bmRaZXJvKGEpKSB7XG4gICAgaWYgKGlzTm90QXJvdW5kWmVybyhiKSkge1xuICAgICAgdmFyIHQxID0gLWMgLyBiO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpc2MgPSBiICogYiAtIDQgKiBhICogYztcblxuICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgIHZhciB0MSA9IC1iIC8gKDIgKiBhKTtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgdmFyIGRpc2NTcXJ0ID0gbWF0aFNxcnQoZGlzYyk7XG4gICAgICB2YXIgdDEgPSAoLWIgKyBkaXNjU3FydCkgLyAoMiAqIGEpO1xuICAgICAgdmFyIHQyID0gKC1iIC0gZGlzY1NxcnQpIC8gKDIgKiBhKTtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuO1xufVxuLyoqXG4gKiDorqHnrpfkuozmrKHotJ3loZ7lsJTmlrnnqIvmnoHpmZDlgLxcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBxdWFkcmF0aWNFeHRyZW11bShwMCwgcDEsIHAyKSB7XG4gIHZhciBkaXZpZGVyID0gcDAgKyBwMiAtIDIgKiBwMTtcblxuICBpZiAoZGl2aWRlciA9PT0gMCkge1xuICAgIC8vIHAxIGlzIGNlbnRlciBvZiBwMCBhbmQgcDJcbiAgICByZXR1cm4gMC41O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAocDAgLSBwMSkgLyBkaXZpZGVyO1xuICB9XG59XG4vKipcbiAqIOe7huWIhuS6jOasoei0neWhnuWwlOabsue6v1xuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IG91dFxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljU3ViZGl2aWRlKHAwLCBwMSwgcDIsIHQsIG91dCkge1xuICB2YXIgcDAxID0gKHAxIC0gcDApICogdCArIHAwO1xuICB2YXIgcDEyID0gKHAyIC0gcDEpICogdCArIHAxO1xuICB2YXIgcDAxMiA9IChwMTIgLSBwMDEpICogdCArIHAwMTsgLy8gU2VnMFxuXG4gIG91dFswXSA9IHAwO1xuICBvdXRbMV0gPSBwMDE7XG4gIG91dFsyXSA9IHAwMTI7IC8vIFNlZzFcblxuICBvdXRbM10gPSBwMDEyO1xuICBvdXRbNF0gPSBwMTI7XG4gIG91dFs1XSA9IHAyO1xufVxuLyoqXG4gKiDmipXlsITngrnliLDkuozmrKHotJ3loZ7lsJTmm7Lnur/kuIrvvIzov5Tlm57mipXlsITot53nprvjgIJcbiAqIOaKleWwhOeCueacieWPr+iDveS8muacieS4gOS4quaIluiAheWkmuS4qu+8jOi/memHjOWPqui/lOWbnuWFtuS4rei3neemu+acgOefreeahOS4gOS4quOAglxuICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gKiBAcGFyYW0ge251bWJlcn0geTBcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge251bWJlcn0geDJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBvdXQg5oqV5bCE54K5XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBxdWFkcmF0aWNQcm9qZWN0UG9pbnQoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSwgb3V0KSB7XG4gIC8vIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby8jcHJvamVjdGlvbnNcbiAgdmFyIHQ7XG4gIHZhciBpbnRlcnZhbCA9IDAuMDA1O1xuICB2YXIgZCA9IEluZmluaXR5O1xuICBfdjBbMF0gPSB4O1xuICBfdjBbMV0gPSB5OyAvLyDlhYjnspfnlaXkvLDorqHkuIDkuIvlj6/og73nmoTmnIDlsI/ot53nprvnmoQgdCDlgLxcbiAgLy8gUEVORElOR1xuXG4gIGZvciAodmFyIF90ID0gMDsgX3QgPCAxOyBfdCArPSAwLjA1KSB7XG4gICAgX3YxWzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgX3QpO1xuICAgIF92MVsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIF90KTtcbiAgICB2YXIgZDEgPSB2MkRpc3RTcXVhcmUoX3YwLCBfdjEpO1xuXG4gICAgaWYgKGQxIDwgZCkge1xuICAgICAgdCA9IF90O1xuICAgICAgZCA9IGQxO1xuICAgIH1cbiAgfVxuXG4gIGQgPSBJbmZpbml0eTsgLy8gQXQgbW9zdCAzMiBpdGVyYXRpb25cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICBpZiAoaW50ZXJ2YWwgPCBFUFNJTE9OX05VTUVSSUMpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgIHZhciBuZXh0ID0gdCArIGludGVydmFsOyAvLyB0IC0gaW50ZXJ2YWxcblxuICAgIF92MVswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHByZXYpO1xuICAgIF92MVsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHByZXYpO1xuICAgIHZhciBkMSA9IHYyRGlzdFNxdWFyZShfdjEsIF92MCk7XG5cbiAgICBpZiAocHJldiA+PSAwICYmIGQxIDwgZCkge1xuICAgICAgdCA9IHByZXY7XG4gICAgICBkID0gZDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHQgKyBpbnRlcnZhbFxuICAgICAgX3YyWzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgbmV4dCk7XG4gICAgICBfdjJbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCBuZXh0KTtcbiAgICAgIHZhciBkMiA9IHYyRGlzdFNxdWFyZShfdjIsIF92MCk7XG5cbiAgICAgIGlmIChuZXh0IDw9IDEgJiYgZDIgPCBkKSB7XG4gICAgICAgIHQgPSBuZXh0O1xuICAgICAgICBkID0gZDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcnZhbCAqPSAwLjU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIHRcblxuXG4gIGlmIChvdXQpIHtcbiAgICBvdXRbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCB0KTtcbiAgICBvdXRbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCB0KTtcbiAgfSAvLyBjb25zb2xlLmxvZyhpbnRlcnZhbCwgaSk7XG5cblxuICByZXR1cm4gbWF0aFNxcnQoZCk7XG59XG5cbmV4cG9ydHMuY3ViaWNBdCA9IGN1YmljQXQ7XG5leHBvcnRzLmN1YmljRGVyaXZhdGl2ZUF0ID0gY3ViaWNEZXJpdmF0aXZlQXQ7XG5leHBvcnRzLmN1YmljUm9vdEF0ID0gY3ViaWNSb290QXQ7XG5leHBvcnRzLmN1YmljRXh0cmVtYSA9IGN1YmljRXh0cmVtYTtcbmV4cG9ydHMuY3ViaWNTdWJkaXZpZGUgPSBjdWJpY1N1YmRpdmlkZTtcbmV4cG9ydHMuY3ViaWNQcm9qZWN0UG9pbnQgPSBjdWJpY1Byb2plY3RQb2ludDtcbmV4cG9ydHMucXVhZHJhdGljQXQgPSBxdWFkcmF0aWNBdDtcbmV4cG9ydHMucXVhZHJhdGljRGVyaXZhdGl2ZUF0ID0gcXVhZHJhdGljRGVyaXZhdGl2ZUF0O1xuZXhwb3J0cy5xdWFkcmF0aWNSb290QXQgPSBxdWFkcmF0aWNSb290QXQ7XG5leHBvcnRzLnF1YWRyYXRpY0V4dHJlbXVtID0gcXVhZHJhdGljRXh0cmVtdW07XG5leHBvcnRzLnF1YWRyYXRpY1N1YmRpdmlkZSA9IHF1YWRyYXRpY1N1YmRpdmlkZTtcbmV4cG9ydHMucXVhZHJhdGljUHJvamVjdFBvaW50ID0gcXVhZHJhdGljUHJvamVjdFBvaW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL2N1cnZlLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdmVjMiA9IHJlcXVpcmUoXCIuL3ZlY3RvclwiKTtcblxudmFyIGN1cnZlID0gcmVxdWlyZShcIi4vY3VydmVcIik7XG5cbi8qKlxuICogQGF1dGhvciBZaSBTaGVuKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG52YXIgbWF0aE1pbiA9IE1hdGgubWluO1xudmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbnZhciBtYXRoU2luID0gTWF0aC5zaW47XG52YXIgbWF0aENvcyA9IE1hdGguY29zO1xudmFyIFBJMiA9IE1hdGguUEkgKiAyO1xudmFyIHN0YXJ0ID0gdmVjMi5jcmVhdGUoKTtcbnZhciBlbmQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGV4dHJlbWl0eSA9IHZlYzIuY3JlYXRlKCk7XG4vKipcbiAqIOS7jumhtueCueaVsOe7hOS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL2Jib3hcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcG9pbnRzIOmhtueCueaVsOe7hFxuICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICovXG5cbmZ1bmN0aW9uIGZyb21Qb2ludHMocG9pbnRzLCBtaW4sIG1heCkge1xuICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwID0gcG9pbnRzWzBdO1xuICB2YXIgbGVmdCA9IHBbMF07XG4gIHZhciByaWdodCA9IHBbMF07XG4gIHZhciB0b3AgPSBwWzFdO1xuICB2YXIgYm90dG9tID0gcFsxXTtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIHAgPSBwb2ludHNbaV07XG4gICAgbGVmdCA9IG1hdGhNaW4obGVmdCwgcFswXSk7XG4gICAgcmlnaHQgPSBtYXRoTWF4KHJpZ2h0LCBwWzBdKTtcbiAgICB0b3AgPSBtYXRoTWluKHRvcCwgcFsxXSk7XG4gICAgYm90dG9tID0gbWF0aE1heChib3R0b20sIHBbMV0pO1xuICB9XG5cbiAgbWluWzBdID0gbGVmdDtcbiAgbWluWzFdID0gdG9wO1xuICBtYXhbMF0gPSByaWdodDtcbiAgbWF4WzFdID0gYm90dG9tO1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gKiBAcGFyYW0ge251bWJlcn0geDBcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gKiBAcGFyYW0ge251bWJlcn0geTFcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tTGluZSh4MCwgeTAsIHgxLCB5MSwgbWluLCBtYXgpIHtcbiAgbWluWzBdID0gbWF0aE1pbih4MCwgeDEpO1xuICBtaW5bMV0gPSBtYXRoTWluKHkwLCB5MSk7XG4gIG1heFswXSA9IG1hdGhNYXgoeDAsIHgxKTtcbiAgbWF4WzFdID0gbWF0aE1heCh5MCwgeTEpO1xufVxuXG52YXIgeERpbSA9IFtdO1xudmFyIHlEaW0gPSBbXTtcbi8qKlxuICog5LuO5LiJ6Zi26LSd5aGe5bCU5puy57q/KHAwLCBwMSwgcDIsIHAzKeS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gKiBAcGFyYW0ge251bWJlcn0geTJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4M1xuICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICovXG5cbmZ1bmN0aW9uIGZyb21DdWJpYyh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIG1pbiwgbWF4KSB7XG4gIHZhciBjdWJpY0V4dHJlbWEgPSBjdXJ2ZS5jdWJpY0V4dHJlbWE7XG4gIHZhciBjdWJpY0F0ID0gY3VydmUuY3ViaWNBdDtcbiAgdmFyIGk7XG4gIHZhciBuID0gY3ViaWNFeHRyZW1hKHgwLCB4MSwgeDIsIHgzLCB4RGltKTtcbiAgbWluWzBdID0gSW5maW5pdHk7XG4gIG1pblsxXSA9IEluZmluaXR5O1xuICBtYXhbMF0gPSAtSW5maW5pdHk7XG4gIG1heFsxXSA9IC1JbmZpbml0eTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgdmFyIHggPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB4RGltW2ldKTtcbiAgICBtaW5bMF0gPSBtYXRoTWluKHgsIG1pblswXSk7XG4gICAgbWF4WzBdID0gbWF0aE1heCh4LCBtYXhbMF0pO1xuICB9XG5cbiAgbiA9IGN1YmljRXh0cmVtYSh5MCwgeTEsIHkyLCB5MywgeURpbSk7XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgIHZhciB5ID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgeURpbVtpXSk7XG4gICAgbWluWzFdID0gbWF0aE1pbih5LCBtaW5bMV0pO1xuICAgIG1heFsxXSA9IG1hdGhNYXgoeSwgbWF4WzFdKTtcbiAgfVxuXG4gIG1pblswXSA9IG1hdGhNaW4oeDAsIG1pblswXSk7XG4gIG1heFswXSA9IG1hdGhNYXgoeDAsIG1heFswXSk7XG4gIG1pblswXSA9IG1hdGhNaW4oeDMsIG1pblswXSk7XG4gIG1heFswXSA9IG1hdGhNYXgoeDMsIG1heFswXSk7XG4gIG1pblsxXSA9IG1hdGhNaW4oeTAsIG1pblsxXSk7XG4gIG1heFsxXSA9IG1hdGhNYXgoeTAsIG1heFsxXSk7XG4gIG1pblsxXSA9IG1hdGhNaW4oeTMsIG1pblsxXSk7XG4gIG1heFsxXSA9IG1hdGhNYXgoeTMsIG1heFsxXSk7XG59XG4vKipcbiAqIOS7juS6jOmYtui0neWhnuWwlOabsue6vyhwMCwgcDEsIHAyKeS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gKiBAcGFyYW0ge251bWJlcn0geTJcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUXVhZHJhdGljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIG1pbiwgbWF4KSB7XG4gIHZhciBxdWFkcmF0aWNFeHRyZW11bSA9IGN1cnZlLnF1YWRyYXRpY0V4dHJlbXVtO1xuICB2YXIgcXVhZHJhdGljQXQgPSBjdXJ2ZS5xdWFkcmF0aWNBdDsgLy8gRmluZCBleHRyZW1pdGllcywgd2hlcmUgZGVyaXZhdGl2ZSBpbiB4IGRpbSBvciB5IGRpbSBpcyB6ZXJvXG5cbiAgdmFyIHR4ID0gbWF0aE1heChtYXRoTWluKHF1YWRyYXRpY0V4dHJlbXVtKHgwLCB4MSwgeDIpLCAxKSwgMCk7XG4gIHZhciB0eSA9IG1hdGhNYXgobWF0aE1pbihxdWFkcmF0aWNFeHRyZW11bSh5MCwgeTEsIHkyKSwgMSksIDApO1xuICB2YXIgeCA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHR4KTtcbiAgdmFyIHkgPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCB0eSk7XG4gIG1pblswXSA9IG1hdGhNaW4oeDAsIHgyLCB4KTtcbiAgbWluWzFdID0gbWF0aE1pbih5MCwgeTIsIHkpO1xuICBtYXhbMF0gPSBtYXRoTWF4KHgwLCB4MiwgeCk7XG4gIG1heFsxXSA9IG1hdGhNYXgoeTAsIHkyLCB5KTtcbn1cbi8qKlxuICog5LuO5ZyG5byn5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICogQG1ldGhvZFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcGFyYW0ge251bWJlcn0gcnhcbiAqIEBwYXJhbSB7bnVtYmVyfSByeVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0QW5nbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRBbmdsZVxuICogQHBhcmFtIHtudW1iZXJ9IGFudGljbG9ja3dpc2VcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tQXJjKHgsIHksIHJ4LCByeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIG1pbiwgbWF4KSB7XG4gIHZhciB2ZWMyTWluID0gdmVjMi5taW47XG4gIHZhciB2ZWMyTWF4ID0gdmVjMi5tYXg7XG4gIHZhciBkaWZmID0gTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKTtcblxuICBpZiAoZGlmZiAlIFBJMiA8IDFlLTQgJiYgZGlmZiA+IDFlLTQpIHtcbiAgICAvLyBJcyBhIGNpcmNsZVxuICAgIG1pblswXSA9IHggLSByeDtcbiAgICBtaW5bMV0gPSB5IC0gcnk7XG4gICAgbWF4WzBdID0geCArIHJ4O1xuICAgIG1heFsxXSA9IHkgKyByeTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdGFydFswXSA9IG1hdGhDb3Moc3RhcnRBbmdsZSkgKiByeCArIHg7XG4gIHN0YXJ0WzFdID0gbWF0aFNpbihzdGFydEFuZ2xlKSAqIHJ5ICsgeTtcbiAgZW5kWzBdID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIHg7XG4gIGVuZFsxXSA9IG1hdGhTaW4oZW5kQW5nbGUpICogcnkgKyB5O1xuICB2ZWMyTWluKG1pbiwgc3RhcnQsIGVuZCk7XG4gIHZlYzJNYXgobWF4LCBzdGFydCwgZW5kKTsgLy8gVGhyZXNoIHRvIFswLCBNYXRoLlBJICogMl1cblxuICBzdGFydEFuZ2xlID0gc3RhcnRBbmdsZSAlIFBJMjtcblxuICBpZiAoc3RhcnRBbmdsZSA8IDApIHtcbiAgICBzdGFydEFuZ2xlID0gc3RhcnRBbmdsZSArIFBJMjtcbiAgfVxuXG4gIGVuZEFuZ2xlID0gZW5kQW5nbGUgJSBQSTI7XG5cbiAgaWYgKGVuZEFuZ2xlIDwgMCkge1xuICAgIGVuZEFuZ2xlID0gZW5kQW5nbGUgKyBQSTI7XG4gIH1cblxuICBpZiAoc3RhcnRBbmdsZSA+IGVuZEFuZ2xlICYmICFhbnRpY2xvY2t3aXNlKSB7XG4gICAgZW5kQW5nbGUgKz0gUEkyO1xuICB9IGVsc2UgaWYgKHN0YXJ0QW5nbGUgPCBlbmRBbmdsZSAmJiBhbnRpY2xvY2t3aXNlKSB7XG4gICAgc3RhcnRBbmdsZSArPSBQSTI7XG4gIH1cblxuICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgIHZhciB0bXAgPSBlbmRBbmdsZTtcbiAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGU7XG4gICAgc3RhcnRBbmdsZSA9IHRtcDtcbiAgfSAvLyB2YXIgbnVtYmVyID0gMDtcbiAgLy8gdmFyIHN0ZXAgPSAoYW50aWNsb2Nrd2lzZSA/IC1NYXRoLlBJIDogTWF0aC5QSSkgLyAyO1xuXG5cbiAgZm9yICh2YXIgYW5nbGUgPSAwOyBhbmdsZSA8IGVuZEFuZ2xlOyBhbmdsZSArPSBNYXRoLlBJIC8gMikge1xuICAgIGlmIChhbmdsZSA+IHN0YXJ0QW5nbGUpIHtcbiAgICAgIGV4dHJlbWl0eVswXSA9IG1hdGhDb3MoYW5nbGUpICogcnggKyB4O1xuICAgICAgZXh0cmVtaXR5WzFdID0gbWF0aFNpbihhbmdsZSkgKiByeSArIHk7XG4gICAgICB2ZWMyTWluKG1pbiwgZXh0cmVtaXR5LCBtaW4pO1xuICAgICAgdmVjMk1heChtYXgsIGV4dHJlbWl0eSwgbWF4KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5mcm9tUG9pbnRzID0gZnJvbVBvaW50cztcbmV4cG9ydHMuZnJvbUxpbmUgPSBmcm9tTGluZTtcbmV4cG9ydHMuZnJvbUN1YmljID0gZnJvbUN1YmljO1xuZXhwb3J0cy5mcm9tUXVhZHJhdGljID0gZnJvbVF1YWRyYXRpYztcbmV4cG9ydHMuZnJvbUFyYyA9IGZyb21BcmM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvYmJveC5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdGhQcm94eSA9IHJlcXVpcmUoXCIuLi9jb3JlL1BhdGhQcm94eVwiKTtcblxudmFyIGxpbmUgPSByZXF1aXJlKFwiLi9saW5lXCIpO1xuXG52YXIgY3ViaWMgPSByZXF1aXJlKFwiLi9jdWJpY1wiKTtcblxudmFyIHF1YWRyYXRpYyA9IHJlcXVpcmUoXCIuL3F1YWRyYXRpY1wiKTtcblxudmFyIGFyYyA9IHJlcXVpcmUoXCIuL2FyY1wiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIG5vcm1hbGl6ZVJhZGlhbiA9IF91dGlsLm5vcm1hbGl6ZVJhZGlhbjtcblxudmFyIGN1cnZlID0gcmVxdWlyZShcIi4uL2NvcmUvY3VydmVcIik7XG5cbnZhciB3aW5kaW5nTGluZSA9IHJlcXVpcmUoXCIuL3dpbmRpbmdMaW5lXCIpO1xuXG52YXIgQ01EID0gUGF0aFByb3h5LkNNRDtcbnZhciBQSTIgPSBNYXRoLlBJICogMjtcbnZhciBFUFNJTE9OID0gMWUtNDtcblxuZnVuY3Rpb24gaXNBcm91bmRFcXVhbChhLCBiKSB7XG4gIHJldHVybiBNYXRoLmFicyhhIC0gYikgPCBFUFNJTE9OO1xufSAvLyDkuLTml7bmlbDnu4RcblxuXG52YXIgcm9vdHMgPSBbLTEsIC0xLCAtMV07XG52YXIgZXh0cmVtYSA9IFstMSwgLTFdO1xuXG5mdW5jdGlvbiBzd2FwRXh0cmVtYSgpIHtcbiAgdmFyIHRtcCA9IGV4dHJlbWFbMF07XG4gIGV4dHJlbWFbMF0gPSBleHRyZW1hWzFdO1xuICBleHRyZW1hWzFdID0gdG1wO1xufVxuXG5mdW5jdGlvbiB3aW5kaW5nQ3ViaWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4LCB5KSB7XG4gIC8vIFF1aWNrIHJlamVjdFxuICBpZiAoeSA+IHkwICYmIHkgPiB5MSAmJiB5ID4geTIgJiYgeSA+IHkzIHx8IHkgPCB5MCAmJiB5IDwgeTEgJiYgeSA8IHkyICYmIHkgPCB5Mykge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIG5Sb290cyA9IGN1cnZlLmN1YmljUm9vdEF0KHkwLCB5MSwgeTIsIHkzLCB5LCByb290cyk7XG5cbiAgaWYgKG5Sb290cyA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHZhciB3ID0gMDtcbiAgICB2YXIgbkV4dHJlbWEgPSAtMTtcbiAgICB2YXIgeTBfLCB5MV87XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Sb290czsgaSsrKSB7XG4gICAgICB2YXIgdCA9IHJvb3RzW2ldOyAvLyBBdm9pZCB3aW5kaW5nIGVycm9yIHdoZW4gaW50ZXJzZWN0aW9uIHBvaW50IGlzIHRoZSBjb25uZWN0IHBvaW50IG9mIHR3byBsaW5lIG9mIHBvbHlnb25cblxuICAgICAgdmFyIHVuaXQgPSB0ID09PSAwIHx8IHQgPT09IDEgPyAwLjUgOiAxO1xuICAgICAgdmFyIHhfID0gY3VydmUuY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG5cbiAgICAgIGlmICh4XyA8IHgpIHtcbiAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobkV4dHJlbWEgPCAwKSB7XG4gICAgICAgIG5FeHRyZW1hID0gY3VydmUuY3ViaWNFeHRyZW1hKHkwLCB5MSwgeTIsIHkzLCBleHRyZW1hKTtcblxuICAgICAgICBpZiAoZXh0cmVtYVsxXSA8IGV4dHJlbWFbMF0gJiYgbkV4dHJlbWEgPiAxKSB7XG4gICAgICAgICAgc3dhcEV4dHJlbWEoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHkwXyA9IGN1cnZlLmN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWFbMF0pO1xuXG4gICAgICAgIGlmIChuRXh0cmVtYSA+IDEpIHtcbiAgICAgICAgICB5MV8gPSBjdXJ2ZS5jdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBleHRyZW1hWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobkV4dHJlbWEgPT0gMikge1xuICAgICAgICAvLyDliIbmiJDkuInmrrXljZXosIPlh73mlbBcbiAgICAgICAgaWYgKHQgPCBleHRyZW1hWzBdKSB7XG4gICAgICAgICAgdyArPSB5MF8gPCB5MCA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfSBlbHNlIGlmICh0IDwgZXh0cmVtYVsxXSkge1xuICAgICAgICAgIHcgKz0geTFfIDwgeTBfID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0geTMgPCB5MV8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIOWIhuaIkOS4pOauteWNleiwg+WHveaVsFxuICAgICAgICBpZiAodCA8IGV4dHJlbWFbMF0pIHtcbiAgICAgICAgICB3ICs9IHkwXyA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0geTMgPCB5MF8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdztcbiAgfVxufVxuXG5mdW5jdGlvbiB3aW5kaW5nUXVhZHJhdGljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgLy8gUXVpY2sgcmVqZWN0XG4gIGlmICh5ID4geTAgJiYgeSA+IHkxICYmIHkgPiB5MiB8fCB5IDwgeTAgJiYgeSA8IHkxICYmIHkgPCB5Mikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIG5Sb290cyA9IGN1cnZlLnF1YWRyYXRpY1Jvb3RBdCh5MCwgeTEsIHkyLCB5LCByb290cyk7XG5cbiAgaWYgKG5Sb290cyA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHZhciB0ID0gY3VydmUucXVhZHJhdGljRXh0cmVtdW0oeTAsIHkxLCB5Mik7XG5cbiAgICBpZiAodCA+PSAwICYmIHQgPD0gMSkge1xuICAgICAgdmFyIHcgPSAwO1xuICAgICAgdmFyIHlfID0gY3VydmUucXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblJvb3RzOyBpKyspIHtcbiAgICAgICAgLy8gUmVtb3ZlIG9uZSBlbmRwb2ludC5cbiAgICAgICAgdmFyIHVuaXQgPSByb290c1tpXSA9PT0gMCB8fCByb290c1tpXSA9PT0gMSA/IDAuNSA6IDE7XG4gICAgICAgIHZhciB4XyA9IGN1cnZlLnF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHJvb3RzW2ldKTtcblxuICAgICAgICBpZiAoeF8gPCB4KSB7XG4gICAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm9vdHNbaV0gPCB0KSB7XG4gICAgICAgICAgdyArPSB5XyA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0geTIgPCB5XyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtb3ZlIG9uZSBlbmRwb2ludC5cbiAgICAgIHZhciB1bml0ID0gcm9vdHNbMF0gPT09IDAgfHwgcm9vdHNbMF0gPT09IDEgPyAwLjUgOiAxO1xuICAgICAgdmFyIHhfID0gY3VydmUucXVhZHJhdGljQXQoeDAsIHgxLCB4Miwgcm9vdHNbMF0pO1xuXG4gICAgICBpZiAoeF8gPCB4KSB7XG4gICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHkyIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgfVxuICB9XG59IC8vIFRPRE9cbi8vIEFyYyDml4vovaxcblxuXG5mdW5jdGlvbiB3aW5kaW5nQXJjKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIHgsIHkpIHtcbiAgeSAtPSBjeTtcblxuICBpZiAoeSA+IHIgfHwgeSA8IC1yKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgdG1wID0gTWF0aC5zcXJ0KHIgKiByIC0geSAqIHkpO1xuICByb290c1swXSA9IC10bXA7XG4gIHJvb3RzWzFdID0gdG1wO1xuICB2YXIgZGlmZiA9IE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSk7XG5cbiAgaWYgKGRpZmYgPCAxZS00KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoZGlmZiAlIFBJMiA8IDFlLTQpIHtcbiAgICAvLyBJcyBhIGNpcmNsZVxuICAgIHN0YXJ0QW5nbGUgPSAwO1xuICAgIGVuZEFuZ2xlID0gUEkyO1xuICAgIHZhciBkaXIgPSBhbnRpY2xvY2t3aXNlID8gMSA6IC0xO1xuXG4gICAgaWYgKHggPj0gcm9vdHNbMF0gKyBjeCAmJiB4IDw9IHJvb3RzWzFdICsgY3gpIHtcbiAgICAgIHJldHVybiBkaXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhbnRpY2xvY2t3aXNlKSB7XG4gICAgdmFyIHRtcCA9IHN0YXJ0QW5nbGU7XG4gICAgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4odG1wKTtcbiAgfSBlbHNlIHtcbiAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHN0YXJ0QW5nbGUpO1xuICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgfVxuXG4gIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICBlbmRBbmdsZSArPSBQSTI7XG4gIH1cblxuICB2YXIgdyA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICB2YXIgeF8gPSByb290c1tpXTtcblxuICAgIGlmICh4XyArIGN4ID4geCkge1xuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih5LCB4Xyk7XG4gICAgICB2YXIgZGlyID0gYW50aWNsb2Nrd2lzZSA/IDEgOiAtMTtcblxuICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICBhbmdsZSA9IFBJMiArIGFuZ2xlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYW5nbGUgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSA8PSBlbmRBbmdsZSB8fCBhbmdsZSArIFBJMiA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlICsgUEkyIDw9IGVuZEFuZ2xlKSB7XG4gICAgICAgIGlmIChhbmdsZSA+IE1hdGguUEkgLyAyICYmIGFuZ2xlIDwgTWF0aC5QSSAqIDEuNSkge1xuICAgICAgICAgIGRpciA9IC1kaXI7XG4gICAgICAgIH1cblxuICAgICAgICB3ICs9IGRpcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdztcbn1cblxuZnVuY3Rpb24gY29udGFpblBhdGgoZGF0YSwgbGluZVdpZHRoLCBpc1N0cm9rZSwgeCwgeSkge1xuICB2YXIgdyA9IDA7XG4gIHZhciB4aSA9IDA7XG4gIHZhciB5aSA9IDA7XG4gIHZhciB4MCA9IDA7XG4gIHZhciB5MCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICB2YXIgY21kID0gZGF0YVtpKytdOyAvLyBCZWdpbiBhIG5ldyBzdWJwYXRoXG5cbiAgICBpZiAoY21kID09PSBDTUQuTSAmJiBpID4gMSkge1xuICAgICAgLy8gQ2xvc2UgcHJldmlvdXMgc3VicGF0aFxuICAgICAgaWYgKCFpc1N0cm9rZSkge1xuICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KTtcbiAgICAgIH0gLy8g5aaC5p6c6KKr5Lu75L2V5LiA5LiqIHN1YnBhdGgg5YyF5ZCrXG4gICAgICAvLyBpZiAodyAhPT0gMCkge1xuICAgICAgLy8gICAgIHJldHVybiB0cnVlO1xuICAgICAgLy8gfVxuXG4gICAgfVxuXG4gICAgaWYgKGkgPT0gMSkge1xuICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgIC8vIOWImSBwcmV2aW91cyBwb2ludCDlkIznu5jliLblkb3ku6TnmoTnrKzkuIDkuKogcG9pbnRcbiAgICAgIC8vXG4gICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgeGkgPSBkYXRhW2ldO1xuICAgICAgeWkgPSBkYXRhW2kgKyAxXTtcbiAgICAgIHgwID0geGk7XG4gICAgICB5MCA9IHlpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICBjYXNlIENNRC5NOlxuICAgICAgICAvLyBtb3ZlVG8g5ZG95Luk6YeN5paw5Yib5bu65LiA5Liq5paw55qEIHN1YnBhdGgsIOW5tuS4lOabtOaWsOaWsOeahOi1t+eCuVxuICAgICAgICAvLyDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeS9v+eUqFxuICAgICAgICB4MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgeTAgPSBkYXRhW2krK107XG4gICAgICAgIHhpID0geDA7XG4gICAgICAgIHlpID0geTA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5MOlxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAobGluZS5jb250YWluU3Ryb2tlKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOT1RFIOWcqOesrOS4gOS4quWRveS7pOS4uiBMLCBDLCBRIOeahOaXtuWAmeS8muiuoeeul+WHuiBOYU5cbiAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIHgsIHkpIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5DOlxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAoY3ViaWMuY29udGFpblN0cm9rZSh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHdpbmRpbmdDdWJpYyh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIHgsIHkpIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5ROlxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAocXVhZHJhdGljLmNvbnRhaW5TdHJva2UoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHdpbmRpbmdRdWFkcmF0aWMoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIHgsIHkpIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5BOlxuICAgICAgICAvLyBUT0RPIEFyYyDliKTmlq3nmoTlvIDplIDmr5TovoPlpKdcbiAgICAgICAgdmFyIGN4ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgY3kgPSBkYXRhW2krK107XG4gICAgICAgIHZhciByeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHJ5ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgdGhldGEgPSBkYXRhW2krK107XG4gICAgICAgIHZhciBkVGhldGEgPSBkYXRhW2krK107IC8vIFRPRE8gQXJjIOaXi+i9rFxuXG4gICAgICAgIHZhciBwc2kgPSBkYXRhW2krK107XG4gICAgICAgIHZhciBhbnRpY2xvY2t3aXNlID0gMSAtIGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHgxID0gTWF0aC5jb3ModGhldGEpICogcnggKyBjeDtcbiAgICAgICAgdmFyIHkxID0gTWF0aC5zaW4odGhldGEpICogcnkgKyBjeTsgLy8g5LiN5piv55u05o6l5L2/55SoIGFyYyDlkb3ku6RcblxuICAgICAgICBpZiAoaSA+IDEpIHtcbiAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDEsIHkxLCB4LCB5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICB4MCA9IHgxO1xuICAgICAgICAgIHkwID0geTE7XG4gICAgICAgIH0gLy8genIg5L2/55Soc2NhbGXmnaXmqKHmi5/mpK3lnIYsIOi/memHjOS5n+WvuXjlgZrkuIDlrprnmoTnvKnmlL5cblxuXG4gICAgICAgIHZhciBfeCA9ICh4IC0gY3gpICogcnkgLyByeCArIGN4O1xuXG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChhcmMuY29udGFpblN0cm9rZShjeCwgY3ksIHJ5LCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIGFudGljbG9ja3dpc2UsIGxpbmVXaWR0aCwgX3gsIHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdyArPSB3aW5kaW5nQXJjKGN4LCBjeSwgcnksIHRoZXRhLCB0aGV0YSArIGRUaGV0YSwgYW50aWNsb2Nrd2lzZSwgX3gsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgeGkgPSBNYXRoLmNvcyh0aGV0YSArIGRUaGV0YSkgKiByeCArIGN4O1xuICAgICAgICB5aSA9IE1hdGguc2luKHRoZXRhICsgZFRoZXRhKSAqIHJ5ICsgY3k7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5SOlxuICAgICAgICB4MCA9IHhpID0gZGF0YVtpKytdO1xuICAgICAgICB5MCA9IHlpID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgd2lkdGggPSBkYXRhW2krK107XG4gICAgICAgIHZhciBoZWlnaHQgPSBkYXRhW2krK107XG4gICAgICAgIHZhciB4MSA9IHgwICsgd2lkdGg7XG4gICAgICAgIHZhciB5MSA9IHkwICsgaGVpZ2h0O1xuXG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChsaW5lLmNvbnRhaW5TdHJva2UoeDAsIHkwLCB4MSwgeTAsIGxpbmVXaWR0aCwgeCwgeSkgfHwgbGluZS5jb250YWluU3Ryb2tlKHgxLCB5MCwgeDEsIHkxLCBsaW5lV2lkdGgsIHgsIHkpIHx8IGxpbmUuY29udGFpblN0cm9rZSh4MSwgeTEsIHgwLCB5MSwgbGluZVdpZHRoLCB4LCB5KSB8fCBsaW5lLmNvbnRhaW5TdHJva2UoeDAsIHkxLCB4MCwgeTAsIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGSVhNRSBDbG9ja3dpc2UgP1xuICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeDEsIHkwLCB4MSwgeTEsIHgsIHkpO1xuICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeDAsIHkxLCB4MCwgeTAsIHgsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChsaW5lLmNvbnRhaW5TdHJva2UoeGksIHlpLCB4MCwgeTAsIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDbG9zZSBhIHN1YnBhdGhcbiAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KTsgLy8g5aaC5p6c6KKr5Lu75L2V5LiA5LiqIHN1YnBhdGgg5YyF5ZCrXG4gICAgICAgICAgLy8gRklYTUUgc3VicGF0aHMgbWF5IG92ZXJsYXBcbiAgICAgICAgICAvLyBpZiAodyAhPT0gMCkge1xuICAgICAgICAgIC8vICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAvLyB9XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IHgwO1xuICAgICAgICB5aSA9IHkwO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoIWlzU3Ryb2tlICYmICFpc0Fyb3VuZEVxdWFsKHlpLCB5MCkpIHtcbiAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KSB8fCAwO1xuICB9XG5cbiAgcmV0dXJuIHcgIT09IDA7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW4ocGF0aERhdGEsIHgsIHkpIHtcbiAgcmV0dXJuIGNvbnRhaW5QYXRoKHBhdGhEYXRhLCAwLCBmYWxzZSwgeCwgeSk7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5TdHJva2UocGF0aERhdGEsIGxpbmVXaWR0aCwgeCwgeSkge1xuICByZXR1cm4gY29udGFpblBhdGgocGF0aERhdGEsIGxpbmVXaWR0aCwgdHJ1ZSwgeCwgeSk7XG59XG5cbmV4cG9ydHMuY29udGFpbiA9IGNvbnRhaW47XG5leHBvcnRzLmNvbnRhaW5TdHJva2UgPSBjb250YWluU3Ryb2tlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb250YWluL3BhdGguanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICog57q/5q615YyF5ZCr5Yik5patXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAqIEBwYXJhbSAge251bWJlcn0gIHgxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MVxuICogQHBhcmFtICB7bnVtYmVyfSAgbGluZVdpZHRoXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb250YWluU3Ryb2tlKHgwLCB5MCwgeDEsIHkxLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBfbCA9IGxpbmVXaWR0aDtcbiAgdmFyIF9hID0gMDtcbiAgdmFyIF9iID0geDA7IC8vIFF1aWNrIHJlamVjdFxuXG4gIGlmICh5ID4geTAgKyBfbCAmJiB5ID4geTEgKyBfbCB8fCB5IDwgeTAgLSBfbCAmJiB5IDwgeTEgLSBfbCB8fCB4ID4geDAgKyBfbCAmJiB4ID4geDEgKyBfbCB8fCB4IDwgeDAgLSBfbCAmJiB4IDwgeDEgLSBfbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh4MCAhPT0geDEpIHtcbiAgICBfYSA9ICh5MCAtIHkxKSAvICh4MCAtIHgxKTtcbiAgICBfYiA9ICh4MCAqIHkxIC0geDEgKiB5MCkgLyAoeDAgLSB4MSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHggLSB4MCkgPD0gX2wgLyAyO1xuICB9XG5cbiAgdmFyIHRtcCA9IF9hICogeCAtIHkgKyBfYjtcblxuICB2YXIgX3MgPSB0bXAgKiB0bXAgLyAoX2EgKiBfYSArIDEpO1xuXG4gIHJldHVybiBfcyA8PSBfbCAvIDIgKiBfbCAvIDI7XG59XG5cbmV4cG9ydHMuY29udGFpblN0cm9rZSA9IGNvbnRhaW5TdHJva2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vbGluZS5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGN1cnZlID0gcmVxdWlyZShcIi4uL2NvcmUvY3VydmVcIik7XG5cbi8qKlxuICog5LiJ5qyh6LSd5aGe5bCU5puy57q/5o+P6L655YyF5ZCr5Yik5patXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAqIEBwYXJhbSAge251bWJlcn0gIHgxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MVxuICogQHBhcmFtICB7bnVtYmVyfSAgeDJcbiAqIEBwYXJhbSAge251bWJlcn0gIHkyXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4M1xuICogQHBhcmFtICB7bnVtYmVyfSAgeTNcbiAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIGxpbmVXaWR0aCwgeCwgeSkge1xuICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIF9sID0gbGluZVdpZHRoOyAvLyBRdWljayByZWplY3RcblxuICBpZiAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wgJiYgeSA+IHkyICsgX2wgJiYgeSA+IHkzICsgX2wgfHwgeSA8IHkwIC0gX2wgJiYgeSA8IHkxIC0gX2wgJiYgeSA8IHkyIC0gX2wgJiYgeSA8IHkzIC0gX2wgfHwgeCA+IHgwICsgX2wgJiYgeCA+IHgxICsgX2wgJiYgeCA+IHgyICsgX2wgJiYgeCA+IHgzICsgX2wgfHwgeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wgJiYgeCA8IHgyIC0gX2wgJiYgeCA8IHgzIC0gX2wpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZCA9IGN1cnZlLmN1YmljUHJvamVjdFBvaW50KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeCwgeSwgbnVsbCk7XG4gIHJldHVybiBkIDw9IF9sIC8gMjtcbn1cblxuZXhwb3J0cy5jb250YWluU3Ryb2tlID0gY29udGFpblN0cm9rZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29udGFpbi9jdWJpYy5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9jdXJ2ZSA9IHJlcXVpcmUoXCIuLi9jb3JlL2N1cnZlXCIpO1xuXG52YXIgcXVhZHJhdGljUHJvamVjdFBvaW50ID0gX2N1cnZlLnF1YWRyYXRpY1Byb2plY3RQb2ludDtcblxuLyoqXG4gKiDkuozmrKHotJ3loZ7lsJTmm7Lnur/mj4/ovrnljIXlkKvliKTmlq1cbiAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MlxuICogQHBhcmFtICB7bnVtYmVyfSAgeTJcbiAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBfbCA9IGxpbmVXaWR0aDsgLy8gUXVpY2sgcmVqZWN0XG5cbiAgaWYgKHkgPiB5MCArIF9sICYmIHkgPiB5MSArIF9sICYmIHkgPiB5MiArIF9sIHx8IHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sICYmIHkgPCB5MiAtIF9sIHx8IHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sICYmIHggPiB4MiArIF9sIHx8IHggPCB4MCAtIF9sICYmIHggPCB4MSAtIF9sICYmIHggPCB4MiAtIF9sKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGQgPSBxdWFkcmF0aWNQcm9qZWN0UG9pbnQoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSwgbnVsbCk7XG4gIHJldHVybiBkIDw9IF9sIC8gMjtcbn1cblxuZXhwb3J0cy5jb250YWluU3Ryb2tlID0gY29udGFpblN0cm9rZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29udGFpbi9xdWFkcmF0aWMuanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBub3JtYWxpemVSYWRpYW4gPSBfdXRpbC5ub3JtYWxpemVSYWRpYW47XG52YXIgUEkyID0gTWF0aC5QSSAqIDI7XG4vKipcbiAqIOWchuW8p+aPj+i+ueWMheWQq+WIpOaWrVxuICogQHBhcmFtICB7bnVtYmVyfSAgY3hcbiAqIEBwYXJhbSAge251bWJlcn0gIGN5XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICByXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBzdGFydEFuZ2xlXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBlbmRBbmdsZVxuICogQHBhcmFtICB7Ym9vbGVhbn0gIGFudGljbG9ja3dpc2VcbiAqIEBwYXJhbSAge251bWJlcn0gbGluZVdpZHRoXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGNvbnRhaW5TdHJva2UoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSwgbGluZVdpZHRoLCB4LCB5KSB7XG4gIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gIHggLT0gY3g7XG4gIHkgLT0gY3k7XG4gIHZhciBkID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXG4gIGlmIChkIC0gX2wgPiByIHx8IGQgKyBfbCA8IHIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSAlIFBJMiA8IDFlLTQpIHtcbiAgICAvLyBJcyBhIGNpcmNsZVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbih0bXApO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oc3RhcnRBbmdsZSk7XG4gICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICB9XG5cbiAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeSwgeCk7XG5cbiAgaWYgKGFuZ2xlIDwgMCkge1xuICAgIGFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIHJldHVybiBhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlIHx8IGFuZ2xlICsgUEkyID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgKyBQSTIgPD0gZW5kQW5nbGU7XG59XG5cbmV4cG9ydHMuY29udGFpblN0cm9rZSA9IGNvbnRhaW5TdHJva2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vYXJjLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJhZGlhbihhbmdsZSkge1xuICBhbmdsZSAlPSBQSTI7XG5cbiAgaWYgKGFuZ2xlIDwgMCkge1xuICAgIGFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIHJldHVybiBhbmdsZTtcbn1cblxuZXhwb3J0cy5ub3JtYWxpemVSYWRpYW4gPSBub3JtYWxpemVSYWRpYW47XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gd2luZGluZ0xpbmUoeDAsIHkwLCB4MSwgeTEsIHgsIHkpIHtcbiAgaWYgKHkgPiB5MCAmJiB5ID4geTEgfHwgeSA8IHkwICYmIHkgPCB5MSkge1xuICAgIHJldHVybiAwO1xuICB9IC8vIElnbm9yZSBob3Jpem9udGFsIGxpbmVcblxuXG4gIGlmICh5MSA9PT0geTApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBkaXIgPSB5MSA8IHkwID8gMSA6IC0xO1xuICB2YXIgdCA9ICh5IC0geTApIC8gKHkxIC0geTApOyAvLyBBdm9pZCB3aW5kaW5nIGVycm9yIHdoZW4gaW50ZXJzZWN0aW9uIHBvaW50IGlzIHRoZSBjb25uZWN0IHBvaW50IG9mIHR3byBsaW5lIG9mIHBvbHlnb25cblxuICBpZiAodCA9PT0gMSB8fCB0ID09PSAwKSB7XG4gICAgZGlyID0geTEgPCB5MCA/IDAuNSA6IC0wLjU7XG4gIH1cblxuICB2YXIgeF8gPSB0ICogKHgxIC0geDApICsgeDA7XG4gIHJldHVybiB4XyA+IHggPyBkaXIgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpbmRpbmdMaW5lO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb250YWluL3dpbmRpbmdMaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF0aFByb3h5ID0gcmVxdWlyZShcIi4uL2NvcmUvUGF0aFByb3h5XCIpO1xuXG52YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuLi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSBfdmVjdG9yLmFwcGx5VHJhbnNmb3JtO1xudmFyIENNRCA9IFBhdGhQcm94eS5DTUQ7XG52YXIgcG9pbnRzID0gW1tdLCBbXSwgW11dO1xudmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xudmFyIG1hdGhBdGFuMiA9IE1hdGguYXRhbjI7XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KHBhdGgsIG0pIHtcbiAgdmFyIGRhdGEgPSBwYXRoLmRhdGE7XG4gIHZhciBjbWQ7XG4gIHZhciBuUG9pbnQ7XG4gIHZhciBpO1xuICB2YXIgajtcbiAgdmFyIGs7XG4gIHZhciBwO1xuICB2YXIgTSA9IENNRC5NO1xuICB2YXIgQyA9IENNRC5DO1xuICB2YXIgTCA9IENNRC5MO1xuICB2YXIgUiA9IENNRC5SO1xuICB2YXIgQSA9IENNRC5BO1xuICB2YXIgUSA9IENNRC5RO1xuXG4gIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgY21kID0gZGF0YVtpKytdO1xuICAgIGogPSBpO1xuICAgIG5Qb2ludCA9IDA7XG5cbiAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgY2FzZSBNOlxuICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMOlxuICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDOlxuICAgICAgICBuUG9pbnQgPSAzO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBROlxuICAgICAgICBuUG9pbnQgPSAyO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBBOlxuICAgICAgICB2YXIgeCA9IG1bNF07XG4gICAgICAgIHZhciB5ID0gbVs1XTtcbiAgICAgICAgdmFyIHN4ID0gbWF0aFNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gICAgICAgIHZhciBzeSA9IG1hdGhTcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuICAgICAgICB2YXIgYW5nbGUgPSBtYXRoQXRhbjIoLW1bMV0gLyBzeSwgbVswXSAvIHN4KTsgLy8gY3hcblxuICAgICAgICBkYXRhW2ldICo9IHN4O1xuICAgICAgICBkYXRhW2krK10gKz0geDsgLy8gY3lcblxuICAgICAgICBkYXRhW2ldICo9IHN5O1xuICAgICAgICBkYXRhW2krK10gKz0geTsgLy8gU2NhbGUgcnggYW5kIHJ5XG4gICAgICAgIC8vIEZJWE1FIEFzc3VtZSBwc2kgaXMgMCBoZXJlXG5cbiAgICAgICAgZGF0YVtpKytdICo9IHN4O1xuICAgICAgICBkYXRhW2krK10gKj0gc3k7IC8vIFN0YXJ0IGFuZ2xlXG5cbiAgICAgICAgZGF0YVtpKytdICs9IGFuZ2xlOyAvLyBlbmQgYW5nbGVcblxuICAgICAgICBkYXRhW2krK10gKz0gYW5nbGU7IC8vIEZJWE1FIHBzaVxuXG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgaiA9IGk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFI6XG4gICAgICAgIC8vIHgwLCB5MFxuICAgICAgICBwWzBdID0gZGF0YVtpKytdO1xuICAgICAgICBwWzFdID0gZGF0YVtpKytdO1xuICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pO1xuICAgICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgICBkYXRhW2orK10gPSBwWzFdOyAvLyB4MSwgeTFcblxuICAgICAgICBwWzBdICs9IGRhdGFbaSsrXTtcbiAgICAgICAgcFsxXSArPSBkYXRhW2krK107XG4gICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7XG4gICAgICAgIGRhdGFbaisrXSA9IHBbMF07XG4gICAgICAgIGRhdGFbaisrXSA9IHBbMV07XG4gICAgfVxuXG4gICAgZm9yIChrID0gMDsgayA8IG5Qb2ludDsgaysrKSB7XG4gICAgICB2YXIgcCA9IHBvaW50c1trXTtcbiAgICAgIHBbMF0gPSBkYXRhW2krK107XG4gICAgICBwWzFdID0gZGF0YVtpKytdO1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTsgLy8gV3JpdGUgYmFja1xuXG4gICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgZGF0YVtqKytdID0gcFsxXTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvdG9vbC90cmFuc2Zvcm1QYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGNvbG9yU3RvcHNcbiAqL1xudmFyIEdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yU3RvcHMpIHtcbiAgdGhpcy5jb2xvclN0b3BzID0gY29sb3JTdG9wcyB8fCBbXTtcbn07XG5cbkdyYWRpZW50LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEdyYWRpZW50LFxuICBhZGRDb2xvclN0b3A6IGZ1bmN0aW9uIChvZmZzZXQsIGNvbG9yKSB7XG4gICAgdGhpcy5jb2xvclN0b3BzLnB1c2goe1xuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICBjb2xvcjogY29sb3JcbiAgICB9KTtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IEdyYWRpZW50O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9HcmFkaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZShcIi4vRGlzcGxheWFibGVcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKFwiLi4vY29udGFpbi90ZXh0XCIpO1xuXG52YXIgdGV4dEhlbHBlciA9IHJlcXVpcmUoXCIuL2hlbHBlci90ZXh0XCIpO1xuXG4vKipcbiAqIEBhbGlhcyB6cmVuZGVyL2dyYXBoaWMvVGV4dFxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG52YXIgVGV4dCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xufTtcblxuVGV4dC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUZXh0LFxuICB0eXBlOiAndGV4dCcsXG4gIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlOyAvLyBPcHRpbWl6ZSwgYXZvaWQgbm9ybWFsaXplIGV2ZXJ5IHRpbWUuXG5cbiAgICB0aGlzLl9fZGlydHkgJiYgdGV4dEhlbHBlci5ub3JtYWxpemVUZXh0U3R5bGUoc3R5bGUsIHRydWUpOyAvLyBVc2UgcHJvcHMgd2l0aCBwcmVmaXggJ3RleHQnLlxuXG4gICAgc3R5bGUuZmlsbCA9IHN0eWxlLnN0cm9rZSA9IHN0eWxlLnNoYWRvd0JsdXIgPSBzdHlsZS5zaGFkb3dDb2xvciA9IHN0eWxlLnNoYWRvd09mZnNldFggPSBzdHlsZS5zaGFkb3dPZmZzZXRZID0gbnVsbDtcbiAgICB2YXIgdGV4dCA9IHN0eWxlLnRleHQ7IC8vIENvbnZlcnQgdG8gc3RyaW5nXG5cbiAgICB0ZXh0ICE9IG51bGwgJiYgKHRleHQgKz0gJycpOyAvLyBBbHdheXMgYmluZCBzdHlsZVxuXG4gICAgc3R5bGUuYmluZChjdHgsIHRoaXMsIHByZXZFbCk7XG5cbiAgICBpZiAoIXRleHRIZWxwZXIubmVlZERyYXdUZXh0KHRleHQsIHN0eWxlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG4gICAgdGV4dEhlbHBlci5yZW5kZXJUZXh0KHRoaXMsIGN0eCwgdGV4dCwgc3R5bGUpO1xuICAgIHRoaXMucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuICB9LFxuICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlOyAvLyBPcHRpbWl6ZSwgYXZvaWQgbm9ybWFsaXplIGV2ZXJ5IHRpbWUuXG5cbiAgICB0aGlzLl9fZGlydHkgJiYgdGV4dEhlbHBlci5ub3JtYWxpemVUZXh0U3R5bGUoc3R5bGUsIHRydWUpO1xuXG4gICAgaWYgKCF0aGlzLl9yZWN0KSB7XG4gICAgICB2YXIgdGV4dCA9IHN0eWxlLnRleHQ7XG4gICAgICB0ZXh0ICE9IG51bGwgPyB0ZXh0ICs9ICcnIDogdGV4dCA9ICcnO1xuICAgICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3Qoc3R5bGUudGV4dCArICcnLCBzdHlsZS5mb250LCBzdHlsZS50ZXh0QWxpZ24sIHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduLCBzdHlsZS50ZXh0UGFkZGluZywgc3R5bGUucmljaCk7XG4gICAgICByZWN0LnggKz0gc3R5bGUueCB8fCAwO1xuICAgICAgcmVjdC55ICs9IHN0eWxlLnkgfHwgMDtcblxuICAgICAgaWYgKHRleHRIZWxwZXIuZ2V0U3Ryb2tlKHN0eWxlLnRleHRTdHJva2UsIHN0eWxlLnRleHRTdHJva2VXaWR0aCkpIHtcbiAgICAgICAgdmFyIHcgPSBzdHlsZS50ZXh0U3Ryb2tlV2lkdGg7XG4gICAgICAgIHJlY3QueCAtPSB3IC8gMjtcbiAgICAgICAgcmVjdC55IC09IHcgLyAyO1xuICAgICAgICByZWN0LndpZHRoICs9IHc7XG4gICAgICAgIHJlY3QuaGVpZ2h0ICs9IHc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlY3QgPSByZWN0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWN0O1xuICB9XG59O1xuenJVdGlsLmluaGVyaXRzKFRleHQsIERpc3BsYXlhYmxlKTtcbnZhciBfZGVmYXVsdCA9IFRleHQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1RleHQuanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbi8qKlxuICog5ZyG5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvQ2lyY2xlXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ2NpcmNsZScsXG4gIHNoYXBlOiB7XG4gICAgY3g6IDAsXG4gICAgY3k6IDAsXG4gICAgcjogMFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlLCBpbkJ1bmRsZSkge1xuICAgIC8vIEJldHRlciBzdHJva2luZyBpbiBTaGFwZUJ1bmRsZVxuICAgIC8vIEFsd2F5cyBkbyBpdCBtYXkgaGF2ZSBwZXJmb3JtZW5jZSBpc3N1ZSAoIGZpbGwgbWF5IGJlIDJ4IG1vcmUgY29zdClcbiAgICBpZiAoaW5CdW5kbGUpIHtcbiAgICAgIGN0eC5tb3ZlVG8oc2hhcGUuY3ggKyBzaGFwZS5yLCBzaGFwZS5jeSk7XG4gICAgfSAvLyBlbHNlIHtcbiAgICAvLyAgICAgaWYgKGN0eC5hbGxvY2F0ZSAmJiAhY3R4LmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gICAgICAgICBjdHguYWxsb2NhdGUoY3R4LkNNRF9NRU1fU0laRS5BKTtcbiAgICAvLyAgICAgfVxuICAgIC8vIH1cbiAgICAvLyBCZXR0ZXIgc3Ryb2tpbmcgaW4gU2hhcGVCdW5kbGVcbiAgICAvLyBjdHgubW92ZVRvKHNoYXBlLmN4ICsgc2hhcGUuciwgc2hhcGUuY3kpO1xuXG5cbiAgICBjdHguYXJjKHNoYXBlLmN4LCBzaGFwZS5jeSwgc2hhcGUuciwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbnZhciBmaXhDbGlwV2l0aFNoYWRvdyA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvZml4Q2xpcFdpdGhTaGFkb3dcIik7XG5cbi8qKlxuICog5omH5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9TZWN0b3JcbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnc2VjdG9yJyxcbiAgc2hhcGU6IHtcbiAgICBjeDogMCxcbiAgICBjeTogMCxcbiAgICByMDogMCxcbiAgICByOiAwLFxuICAgIHN0YXJ0QW5nbGU6IDAsXG4gICAgZW5kQW5nbGU6IE1hdGguUEkgKiAyLFxuICAgIGNsb2Nrd2lzZTogdHJ1ZVxuICB9LFxuICBicnVzaDogZml4Q2xpcFdpdGhTaGFkb3coUGF0aC5wcm90b3R5cGUuYnJ1c2gpLFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHggPSBzaGFwZS5jeDtcbiAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgIHZhciByMCA9IE1hdGgubWF4KHNoYXBlLnIwIHx8IDAsIDApO1xuICAgIHZhciByID0gTWF0aC5tYXgoc2hhcGUuciwgMCk7XG4gICAgdmFyIHN0YXJ0QW5nbGUgPSBzaGFwZS5zdGFydEFuZ2xlO1xuICAgIHZhciBlbmRBbmdsZSA9IHNoYXBlLmVuZEFuZ2xlO1xuICAgIHZhciBjbG9ja3dpc2UgPSBzaGFwZS5jbG9ja3dpc2U7XG4gICAgdmFyIHVuaXRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgdmFyIHVuaXRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgY3R4Lm1vdmVUbyh1bml0WCAqIHIwICsgeCwgdW5pdFkgKiByMCArIHkpO1xuICAgIGN0eC5saW5lVG8odW5pdFggKiByICsgeCwgdW5pdFkgKiByICsgeSk7XG4gICAgY3R4LmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgIWNsb2Nrd2lzZSk7XG4gICAgY3R4LmxpbmVUbyhNYXRoLmNvcyhlbmRBbmdsZSkgKiByMCArIHgsIE1hdGguc2luKGVuZEFuZ2xlKSAqIHIwICsgeSk7XG5cbiAgICBpZiAocjAgIT09IDApIHtcbiAgICAgIGN0eC5hcmMoeCwgeSwgcjAsIGVuZEFuZ2xlLCBzdGFydEFuZ2xlLCBjbG9ja3dpc2UpO1xuICAgIH1cblxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvU2VjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZW52ID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvZW52XCIpO1xuXG4vLyBGaXggd2VpcmQgYnVnIGluIHNvbWUgdmVyc2lvbiBvZiBJRTExIChsaWtlIDExLjAuOTYwMC4xNzgqKiksXG4vLyB3aGVyZSBleGNlcHRpb24gXCJ1bmV4cGVjdGVkIGNhbGwgdG8gbWV0aG9kIG9yIHByb3BlcnR5IGFjY2Vzc1wiXG4vLyBtaWdodCBiZSB0aHJvd24gd2hlbiBjYWxsaW5nIGN0eC5maWxsIG9yIGN0eC5zdHJva2UgYWZ0ZXIgYSBwYXRoXG4vLyB3aG9zZSBhcmVhIHNpemUgaXMgemVybyBpcyBkcmF3biBhbmQgY3R4LmNsaXAoKSBpcyBjYWxsZWQgYW5kXG4vLyBzaGFkb3dCbHVyIGlzIHNldC4gU2VlICM0NTcyLCAjMzExMiwgIzU3NzcuXG4vLyAoZS5nLixcbi8vICBjdHgubW92ZVRvKDEwLCAxMCk7XG4vLyAgY3R4LmxpbmVUbygyMCwgMTApO1xuLy8gIGN0eC5jbG9zZVBhdGgoKTtcbi8vICBjdHguY2xpcCgpO1xuLy8gIGN0eC5zaGFkb3dCbHVyID0gMTA7XG4vLyAgLi4uXG4vLyAgY3R4LmZpbGwoKTtcbi8vIClcbnZhciBzaGFkb3dUZW1wID0gW1snc2hhZG93Qmx1cicsIDBdLCBbJ3NoYWRvd0NvbG9yJywgJyMwMDAnXSwgWydzaGFkb3dPZmZzZXRYJywgMF0sIFsnc2hhZG93T2Zmc2V0WScsIDBdXTtcblxuZnVuY3Rpb24gX2RlZmF1bHQob3JpZ25hbEJydXNoKSB7XG4gIC8vIHZlcnNpb24gc3RyaW5nIGNhbiBiZTogJzExLjAnXG4gIHJldHVybiBlbnYuYnJvd3Nlci5pZSAmJiBlbnYuYnJvd3Nlci52ZXJzaW9uID49IDExID8gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbGlwUGF0aHMgPSB0aGlzLl9fY2xpcFBhdGhzO1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgdmFyIG1vZGlmaWVkO1xuXG4gICAgaWYgKGNsaXBQYXRocykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNsaXBQYXRoID0gY2xpcFBhdGhzW2ldO1xuICAgICAgICB2YXIgc2hhcGUgPSBjbGlwUGF0aCAmJiBjbGlwUGF0aC5zaGFwZTtcbiAgICAgICAgdmFyIHR5cGUgPSBjbGlwUGF0aCAmJiBjbGlwUGF0aC50eXBlO1xuXG4gICAgICAgIGlmIChzaGFwZSAmJiAodHlwZSA9PT0gJ3NlY3RvcicgJiYgc2hhcGUuc3RhcnRBbmdsZSA9PT0gc2hhcGUuZW5kQW5nbGUgfHwgdHlwZSA9PT0gJ3JlY3QnICYmICghc2hhcGUud2lkdGggfHwgIXNoYXBlLmhlaWdodCkpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzaGFkb3dUZW1wLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAvLyBJdCBpcyBzYXZlIHRvIHB1dCBzaGFkb3dUZW1wIHN0YXRpYywgYmVjYXVzZSBzaGFkb3dUZW1wXG4gICAgICAgICAgICAvLyB3aWxsIGJlIGFsbCBtb2RpZmllZCBlYWNoIGl0ZW0gYnJ1c2ggY2FsbGVkLlxuICAgICAgICAgICAgc2hhZG93VGVtcFtqXVsyXSA9IHN0eWxlW3NoYWRvd1RlbXBbal1bMF1dO1xuICAgICAgICAgICAgc3R5bGVbc2hhZG93VGVtcFtqXVswXV0gPSBzaGFkb3dUZW1wW2pdWzFdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG9yaWduYWxCcnVzaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgaWYgKG1vZGlmaWVkKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNoYWRvd1RlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc3R5bGVbc2hhZG93VGVtcFtqXVswXV0gPSBzaGFkb3dUZW1wW2pdWzJdO1xuICAgICAgfVxuICAgIH1cbiAgfSA6IG9yaWduYWxCcnVzaDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvZml4Q2xpcFdpdGhTaGFkb3cuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbi8qKlxuICog5ZyG546vXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9SaW5nXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ3JpbmcnLFxuICBzaGFwZToge1xuICAgIGN4OiAwLFxuICAgIGN5OiAwLFxuICAgIHI6IDAsXG4gICAgcjA6IDBcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICB2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG4gICAgY3R4Lm1vdmVUbyh4ICsgc2hhcGUuciwgeSk7XG4gICAgY3R4LmFyYyh4LCB5LCBzaGFwZS5yLCAwLCBQSTIsIGZhbHNlKTtcbiAgICBjdHgubW92ZVRvKHggKyBzaGFwZS5yMCwgeSk7XG4gICAgY3R4LmFyYyh4LCB5LCBzaGFwZS5yMCwgMCwgUEkyLCB0cnVlKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmluZy5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxudmFyIHBvbHlIZWxwZXIgPSByZXF1aXJlKFwiLi4vaGVscGVyL3BvbHlcIik7XG5cbi8qKlxuICog5aSa6L655b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvUG9seWdvblxuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdwb2x5Z29uJyxcbiAgc2hhcGU6IHtcbiAgICBwb2ludHM6IG51bGwsXG4gICAgc21vb3RoOiBmYWxzZSxcbiAgICBzbW9vdGhDb25zdHJhaW50OiBudWxsXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICBwb2x5SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlLCB0cnVlKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWdvbi5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHNtb290aFNwbGluZSA9IHJlcXVpcmUoXCIuL3Ntb290aFNwbGluZVwiKTtcblxudmFyIHNtb290aEJlemllciA9IHJlcXVpcmUoXCIuL3Ntb290aEJlemllclwiKTtcblxuZnVuY3Rpb24gYnVpbGRQYXRoKGN0eCwgc2hhcGUsIGNsb3NlUGF0aCkge1xuICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuICB2YXIgc21vb3RoID0gc2hhcGUuc21vb3RoO1xuXG4gIGlmIChwb2ludHMgJiYgcG9pbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgaWYgKHNtb290aCAmJiBzbW9vdGggIT09ICdzcGxpbmUnKSB7XG4gICAgICB2YXIgY29udHJvbFBvaW50cyA9IHNtb290aEJlemllcihwb2ludHMsIHNtb290aCwgY2xvc2VQYXRoLCBzaGFwZS5zbW9vdGhDb25zdHJhaW50KTtcbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0pO1xuICAgICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgKGNsb3NlUGF0aCA/IGxlbiA6IGxlbiAtIDEpOyBpKyspIHtcbiAgICAgICAgdmFyIGNwMSA9IGNvbnRyb2xQb2ludHNbaSAqIDJdO1xuICAgICAgICB2YXIgY3AyID0gY29udHJvbFBvaW50c1tpICogMiArIDFdO1xuICAgICAgICB2YXIgcCA9IHBvaW50c1soaSArIDEpICUgbGVuXTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3AxWzBdLCBjcDFbMV0sIGNwMlswXSwgY3AyWzFdLCBwWzBdLCBwWzFdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNtb290aCA9PT0gJ3NwbGluZScpIHtcbiAgICAgICAgcG9pbnRzID0gc21vb3RoU3BsaW5lKHBvaW50cywgY2xvc2VQYXRoKTtcbiAgICAgIH1cblxuICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF1bMF0sIHBvaW50c1swXVsxXSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjdHgubGluZVRvKHBvaW50c1tpXVswXSwgcG9pbnRzW2ldWzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbG9zZVBhdGggJiYgY3R4LmNsb3NlUGF0aCgpO1xuICB9XG59XG5cbmV4cG9ydHMuYnVpbGRQYXRoID0gYnVpbGRQYXRoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9wb2x5LmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIHYyRGlzdGFuY2UgPSBfdmVjdG9yLmRpc3RhbmNlO1xuXG4vKipcbiAqIENhdG11bGwtUm9tIHNwbGluZSDmj5LlgLzmipjnur9cbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS91dGlsL3Ntb290aFNwbGluZVxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKiAgICAgICAgIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vKipcbiAqIEBpbm5lclxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzKSB7XG4gIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNTtcbiAgdmFyIHYxID0gKHAzIC0gcDEpICogMC41O1xuICByZXR1cm4gKDIgKiAocDEgLSBwMikgKyB2MCArIHYxKSAqIHQzICsgKC0zICogKHAxIC0gcDIpIC0gMiAqIHYwIC0gdjEpICogdDIgKyB2MCAqIHQgKyBwMTtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoU3BsaW5lXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludHMg57q/5q616aG254K55pWw57uEXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG9vcFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuXG5mdW5jdGlvbiBfZGVmYXVsdChwb2ludHMsIGlzTG9vcCkge1xuICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgdmFyIHJldCA9IFtdO1xuICB2YXIgZGlzdGFuY2UgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICBkaXN0YW5jZSArPSB2MkRpc3RhbmNlKHBvaW50c1tpIC0gMV0sIHBvaW50c1tpXSk7XG4gIH1cblxuICB2YXIgc2VncyA9IGRpc3RhbmNlIC8gMjtcbiAgc2VncyA9IHNlZ3MgPCBsZW4gPyBsZW4gOiBzZWdzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnczsgaSsrKSB7XG4gICAgdmFyIHBvcyA9IGkgLyAoc2VncyAtIDEpICogKGlzTG9vcCA/IGxlbiA6IGxlbiAtIDEpO1xuICAgIHZhciBpZHggPSBNYXRoLmZsb29yKHBvcyk7XG4gICAgdmFyIHcgPSBwb3MgLSBpZHg7XG4gICAgdmFyIHAwO1xuICAgIHZhciBwMSA9IHBvaW50c1tpZHggJSBsZW5dO1xuICAgIHZhciBwMjtcbiAgICB2YXIgcDM7XG5cbiAgICBpZiAoIWlzTG9vcCkge1xuICAgICAgcDAgPSBwb2ludHNbaWR4ID09PSAwID8gaWR4IDogaWR4IC0gMV07XG4gICAgICBwMiA9IHBvaW50c1tpZHggPiBsZW4gLSAyID8gbGVuIC0gMSA6IGlkeCArIDFdO1xuICAgICAgcDMgPSBwb2ludHNbaWR4ID4gbGVuIC0gMyA/IGxlbiAtIDEgOiBpZHggKyAyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcDAgPSBwb2ludHNbKGlkeCAtIDEgKyBsZW4pICUgbGVuXTtcbiAgICAgIHAyID0gcG9pbnRzWyhpZHggKyAxKSAlIGxlbl07XG4gICAgICBwMyA9IHBvaW50c1soaWR4ICsgMikgJSBsZW5dO1xuICAgIH1cblxuICAgIHZhciB3MiA9IHcgKiB3O1xuICAgIHZhciB3MyA9IHcgKiB3MjtcbiAgICByZXQucHVzaChbaW50ZXJwb2xhdGUocDBbMF0sIHAxWzBdLCBwMlswXSwgcDNbMF0sIHcsIHcyLCB3MyksIGludGVycG9sYXRlKHAwWzFdLCBwMVsxXSwgcDJbMV0sIHAzWzFdLCB3LCB3MiwgdzMpXSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhTcGxpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgdjJNaW4gPSBfdmVjdG9yLm1pbjtcbnZhciB2Mk1heCA9IF92ZWN0b3IubWF4O1xudmFyIHYyU2NhbGUgPSBfdmVjdG9yLnNjYWxlO1xudmFyIHYyRGlzdGFuY2UgPSBfdmVjdG9yLmRpc3RhbmNlO1xudmFyIHYyQWRkID0gX3ZlY3Rvci5hZGQ7XG52YXIgdjJDbG9uZSA9IF92ZWN0b3IuY2xvbmU7XG52YXIgdjJTdWIgPSBfdmVjdG9yLnN1YjtcblxuLyoqXG4gKiDotJ3loZ7lsJTlubPmu5Hmm7Lnur9cbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS91dGlsL3Ntb290aEJlemllclxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKiAgICAgICAgIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vKipcbiAqIOi0neWhnuWwlOW5s+a7keabsue6v1xuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoQmV6aWVyXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludHMg57q/5q616aG254K55pWw57uEXG4gKiBAcGFyYW0ge251bWJlcn0gc21vb3RoIOW5s+a7keetiee6pywgMC0xXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG9vcFxuICogQHBhcmFtIHtBcnJheX0gY29uc3RyYWludCDlsIborqHnrpflh7rmnaXnmoTmjqfliLbngrnnuqbmnZ/lnKjkuIDkuKrljIXlm7Tnm5LlhoVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAg5q+U5aaCIFtbMCwgMF0sIFsxMDAsIDEwMF1dLCDov5nkuKrljIXlm7Tnm5LkvJrkuI5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAg5pW05Liq5oqY57q/55qE5YyF5Zu055uS5YGa5LiA5Liq5bm26ZuG55So5p2l57qm5p2f5o6n5Yi254K544CCXG4gKiBAcGFyYW0ge0FycmF5fSDorqHnrpflh7rmnaXnmoTmjqfliLbngrnmlbDnu4RcbiAqL1xuZnVuY3Rpb24gX2RlZmF1bHQocG9pbnRzLCBzbW9vdGgsIGlzTG9vcCwgY29uc3RyYWludCkge1xuICB2YXIgY3BzID0gW107XG4gIHZhciB2ID0gW107XG4gIHZhciB2MSA9IFtdO1xuICB2YXIgdjIgPSBbXTtcbiAgdmFyIHByZXZQb2ludDtcbiAgdmFyIG5leHRQb2ludDtcbiAgdmFyIG1pbiwgbWF4O1xuXG4gIGlmIChjb25zdHJhaW50KSB7XG4gICAgbWluID0gW0luZmluaXR5LCBJbmZpbml0eV07XG4gICAgbWF4ID0gWy1JbmZpbml0eSwgLUluZmluaXR5XTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHYyTWluKG1pbiwgbWluLCBwb2ludHNbaV0pO1xuICAgICAgdjJNYXgobWF4LCBtYXgsIHBvaW50c1tpXSk7XG4gICAgfSAvLyDkuI7mjIflrprnmoTljIXlm7Tnm5LlgZrlubbpm4ZcblxuXG4gICAgdjJNaW4obWluLCBtaW4sIGNvbnN0cmFpbnRbMF0pO1xuICAgIHYyTWF4KG1heCwgbWF4LCBjb25zdHJhaW50WzFdKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV07XG5cbiAgICBpZiAoaXNMb29wKSB7XG4gICAgICBwcmV2UG9pbnQgPSBwb2ludHNbaSA/IGkgLSAxIDogbGVuIC0gMV07XG4gICAgICBuZXh0UG9pbnQgPSBwb2ludHNbKGkgKyAxKSAlIGxlbl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgY3BzLnB1c2godjJDbG9uZShwb2ludHNbaV0pKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2UG9pbnQgPSBwb2ludHNbaSAtIDFdO1xuICAgICAgICBuZXh0UG9pbnQgPSBwb2ludHNbaSArIDFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHYyU3ViKHYsIG5leHRQb2ludCwgcHJldlBvaW50KTsgLy8gdXNlIGRlZ3JlZSB0byBzY2FsZSB0aGUgaGFuZGxlIGxlbmd0aFxuXG4gICAgdjJTY2FsZSh2LCB2LCBzbW9vdGgpO1xuICAgIHZhciBkMCA9IHYyRGlzdGFuY2UocG9pbnQsIHByZXZQb2ludCk7XG4gICAgdmFyIGQxID0gdjJEaXN0YW5jZShwb2ludCwgbmV4dFBvaW50KTtcbiAgICB2YXIgc3VtID0gZDAgKyBkMTtcblxuICAgIGlmIChzdW0gIT09IDApIHtcbiAgICAgIGQwIC89IHN1bTtcbiAgICAgIGQxIC89IHN1bTtcbiAgICB9XG5cbiAgICB2MlNjYWxlKHYxLCB2LCAtZDApO1xuICAgIHYyU2NhbGUodjIsIHYsIGQxKTtcbiAgICB2YXIgY3AwID0gdjJBZGQoW10sIHBvaW50LCB2MSk7XG4gICAgdmFyIGNwMSA9IHYyQWRkKFtdLCBwb2ludCwgdjIpO1xuXG4gICAgaWYgKGNvbnN0cmFpbnQpIHtcbiAgICAgIHYyTWF4KGNwMCwgY3AwLCBtaW4pO1xuICAgICAgdjJNaW4oY3AwLCBjcDAsIG1heCk7XG4gICAgICB2Mk1heChjcDEsIGNwMSwgbWluKTtcbiAgICAgIHYyTWluKGNwMSwgY3AxLCBtYXgpO1xuICAgIH1cblxuICAgIGNwcy5wdXNoKGNwMCk7XG4gICAgY3BzLnB1c2goY3AxKTtcbiAgfVxuXG4gIGlmIChpc0xvb3ApIHtcbiAgICBjcHMucHVzaChjcHMuc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gY3BzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhCZXppZXIuanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbnZhciBwb2x5SGVscGVyID0gcmVxdWlyZShcIi4uL2hlbHBlci9wb2x5XCIpO1xuXG4vKipcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1BvbHlsaW5lXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ3BvbHlsaW5lJyxcbiAgc2hhcGU6IHtcbiAgICBwb2ludHM6IG51bGwsXG4gICAgc21vb3RoOiBmYWxzZSxcbiAgICBzbW9vdGhDb25zdHJhaW50OiBudWxsXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgZmlsbDogbnVsbFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgcG9seUhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSwgZmFsc2UpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZS5qc1xuLy8gbW9kdWxlIGlkID0gNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxudmFyIHJvdW5kUmVjdEhlbHBlciA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvcm91bmRSZWN0XCIpO1xuXG4vKipcbiAqIOefqeW9olxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUmVjdFxuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdyZWN0JyxcbiAgc2hhcGU6IHtcbiAgICAvLyDlt6bkuIrjgIHlj7PkuIrjgIHlj7PkuIvjgIHlt6bkuIvop5LnmoTljYrlvoTkvp3mrKHkuLpyMeOAgXIy44CBcjPjgIFyNFxuICAgIC8vIHLnvKnlhpnkuLoxICAgICAgICAg55u45b2T5LqOIFsxLCAxLCAxLCAxXVxuICAgIC8vIHLnvKnlhpnkuLpbMV0gICAgICAg55u45b2T5LqOIFsxLCAxLCAxLCAxXVxuICAgIC8vIHLnvKnlhpnkuLpbMSwgMl0gICAg55u45b2T5LqOIFsxLCAyLCAxLCAyXVxuICAgIC8vIHLnvKnlhpnkuLpbMSwgMiwgM10g55u45b2T5LqOIFsxLCAyLCAzLCAyXVxuICAgIHI6IDAsXG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHggPSBzaGFwZS54O1xuICAgIHZhciB5ID0gc2hhcGUueTtcbiAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xuXG4gICAgaWYgKCFzaGFwZS5yKSB7XG4gICAgICBjdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm91bmRSZWN0SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlKTtcbiAgICB9XG5cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgcmV0dXJuO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG4vKipcbiAqIOebtOe6v1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvTGluZVxuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdsaW5lJyxcbiAgc2hhcGU6IHtcbiAgICAvLyBTdGFydCBwb2ludFxuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIC8vIEVuZCBwb2ludFxuICAgIHgyOiAwLFxuICAgIHkyOiAwLFxuICAgIHBlcmNlbnQ6IDFcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICBzdHJva2U6ICcjMDAwJyxcbiAgICBmaWxsOiBudWxsXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgeDEgPSBzaGFwZS54MTtcbiAgICB2YXIgeTEgPSBzaGFwZS55MTtcbiAgICB2YXIgeDIgPSBzaGFwZS54MjtcbiAgICB2YXIgeTIgPSBzaGFwZS55MjtcbiAgICB2YXIgcGVyY2VudCA9IHNoYXBlLnBlcmNlbnQ7XG5cbiAgICBpZiAocGVyY2VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcblxuICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgeDIgPSB4MSAqICgxIC0gcGVyY2VudCkgKyB4MiAqIHBlcmNlbnQ7XG4gICAgICB5MiA9IHkxICogKDEgLSBwZXJjZW50KSArIHkyICogcGVyY2VudDtcbiAgICB9XG5cbiAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBwb2ludCBhdCBwZXJjZW50XG4gICAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIHBvaW50QXQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcbiAgICByZXR1cm4gW3NoYXBlLngxICogKDEgLSBwKSArIHNoYXBlLngyICogcCwgc2hhcGUueTEgKiAoMSAtIHApICsgc2hhcGUueTIgKiBwXTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxudmFyIHZlYzIgPSByZXF1aXJlKFwiLi4vLi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciBfY3VydmUgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9jdXJ2ZVwiKTtcblxudmFyIHF1YWRyYXRpY1N1YmRpdmlkZSA9IF9jdXJ2ZS5xdWFkcmF0aWNTdWJkaXZpZGU7XG52YXIgY3ViaWNTdWJkaXZpZGUgPSBfY3VydmUuY3ViaWNTdWJkaXZpZGU7XG52YXIgcXVhZHJhdGljQXQgPSBfY3VydmUucXVhZHJhdGljQXQ7XG52YXIgY3ViaWNBdCA9IF9jdXJ2ZS5jdWJpY0F0O1xudmFyIHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA9IF9jdXJ2ZS5xdWFkcmF0aWNEZXJpdmF0aXZlQXQ7XG52YXIgY3ViaWNEZXJpdmF0aXZlQXQgPSBfY3VydmUuY3ViaWNEZXJpdmF0aXZlQXQ7XG5cbi8qKlxuICog6LSd5aGe5bCU5puy57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvQmV6aWVyQ3VydmVcbiAqL1xudmFyIG91dCA9IFtdO1xuXG5mdW5jdGlvbiBzb21lVmVjdG9yQXQoc2hhcGUsIHQsIGlzVGFuZ2VudCkge1xuICB2YXIgY3B4MiA9IHNoYXBlLmNweDI7XG4gIHZhciBjcHkyID0gc2hhcGUuY3B5MjtcblxuICBpZiAoY3B4MiA9PT0gbnVsbCB8fCBjcHkyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFsoaXNUYW5nZW50ID8gY3ViaWNEZXJpdmF0aXZlQXQgOiBjdWJpY0F0KShzaGFwZS54MSwgc2hhcGUuY3B4MSwgc2hhcGUuY3B4Miwgc2hhcGUueDIsIHQpLCAoaXNUYW5nZW50ID8gY3ViaWNEZXJpdmF0aXZlQXQgOiBjdWJpY0F0KShzaGFwZS55MSwgc2hhcGUuY3B5MSwgc2hhcGUuY3B5Miwgc2hhcGUueTIsIHQpXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gWyhpc1RhbmdlbnQgPyBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgOiBxdWFkcmF0aWNBdCkoc2hhcGUueDEsIHNoYXBlLmNweDEsIHNoYXBlLngyLCB0KSwgKGlzVGFuZ2VudCA/IHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA6IHF1YWRyYXRpY0F0KShzaGFwZS55MSwgc2hhcGUuY3B5MSwgc2hhcGUueTIsIHQpXTtcbiAgfVxufVxuXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdiZXppZXItY3VydmUnLFxuICBzaGFwZToge1xuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIHgyOiAwLFxuICAgIHkyOiAwLFxuICAgIGNweDE6IDAsXG4gICAgY3B5MTogMCxcbiAgICAvLyBjcHgyOiAwLFxuICAgIC8vIGNweTI6IDBcbiAgICAvLyBDdXJ2ZSBzaG93IHBlcmNlbnQsIGZvciBhbmltYXRpbmdcbiAgICBwZXJjZW50OiAxXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgZmlsbDogbnVsbFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHgxID0gc2hhcGUueDE7XG4gICAgdmFyIHkxID0gc2hhcGUueTE7XG4gICAgdmFyIHgyID0gc2hhcGUueDI7XG4gICAgdmFyIHkyID0gc2hhcGUueTI7XG4gICAgdmFyIGNweDEgPSBzaGFwZS5jcHgxO1xuICAgIHZhciBjcHkxID0gc2hhcGUuY3B5MTtcbiAgICB2YXIgY3B4MiA9IHNoYXBlLmNweDI7XG4gICAgdmFyIGNweTIgPSBzaGFwZS5jcHkyO1xuICAgIHZhciBwZXJjZW50ID0gc2hhcGUucGVyY2VudDtcblxuICAgIGlmIChwZXJjZW50ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuXG4gICAgaWYgKGNweDIgPT0gbnVsbCB8fCBjcHkyID09IG51bGwpIHtcbiAgICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGUoeDEsIGNweDEsIHgyLCBwZXJjZW50LCBvdXQpO1xuICAgICAgICBjcHgxID0gb3V0WzFdO1xuICAgICAgICB4MiA9IG91dFsyXTtcbiAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlKHkxLCBjcHkxLCB5MiwgcGVyY2VudCwgb3V0KTtcbiAgICAgICAgY3B5MSA9IG91dFsxXTtcbiAgICAgICAgeTIgPSBvdXRbMl07XG4gICAgICB9XG5cbiAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNweDEsIGNweTEsIHgyLCB5Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgICBjdWJpY1N1YmRpdmlkZSh4MSwgY3B4MSwgY3B4MiwgeDIsIHBlcmNlbnQsIG91dCk7XG4gICAgICAgIGNweDEgPSBvdXRbMV07XG4gICAgICAgIGNweDIgPSBvdXRbMl07XG4gICAgICAgIHgyID0gb3V0WzNdO1xuICAgICAgICBjdWJpY1N1YmRpdmlkZSh5MSwgY3B5MSwgY3B5MiwgeTIsIHBlcmNlbnQsIG91dCk7XG4gICAgICAgIGNweTEgPSBvdXRbMV07XG4gICAgICAgIGNweTIgPSBvdXRbMl07XG4gICAgICAgIHkyID0gb3V0WzNdO1xuICAgICAgfVxuXG4gICAgICBjdHguYmV6aWVyQ3VydmVUbyhjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLCB4MiwgeTIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogR2V0IHBvaW50IGF0IHBlcmNlbnRcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgcG9pbnRBdDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gc29tZVZlY3RvckF0KHRoaXMuc2hhcGUsIHQsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRhbmdlbnQgYXQgcGVyY2VudFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICB0YW5nZW50QXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIHAgPSBzb21lVmVjdG9yQXQodGhpcy5zaGFwZSwgdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHZlYzIubm9ybWFsaXplKHAsIHApO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZS5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxuLyoqXG4gKiDlnIblvKdcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL0FyY1xuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdhcmMnLFxuICBzaGFwZToge1xuICAgIGN4OiAwLFxuICAgIGN5OiAwLFxuICAgIHI6IDAsXG4gICAgc3RhcnRBbmdsZTogMCxcbiAgICBlbmRBbmdsZTogTWF0aC5QSSAqIDIsXG4gICAgY2xvY2t3aXNlOiB0cnVlXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgZmlsbDogbnVsbFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHggPSBzaGFwZS5jeDtcbiAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgIHZhciByID0gTWF0aC5tYXgoc2hhcGUuciwgMCk7XG4gICAgdmFyIHN0YXJ0QW5nbGUgPSBzaGFwZS5zdGFydEFuZ2xlO1xuICAgIHZhciBlbmRBbmdsZSA9IHNoYXBlLmVuZEFuZ2xlO1xuICAgIHZhciBjbG9ja3dpc2UgPSBzaGFwZS5jbG9ja3dpc2U7XG4gICAgdmFyIHVuaXRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgdmFyIHVuaXRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgY3R4Lm1vdmVUbyh1bml0WCAqIHIgKyB4LCB1bml0WSAqIHIgKyB5KTtcbiAgICBjdHguYXJjKHgsIHksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCAhY2xvY2t3aXNlKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQXJjLmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIEdyYWRpZW50ID0gcmVxdWlyZShcIi4vR3JhZGllbnRcIik7XG5cbi8qKlxuICogeCwgeSwgeDIsIHkyIGFyZSBhbGwgcGVyY2VudCBmcm9tIDAgdG8gMVxuICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeDI9MV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeTI9MF1cbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGNvbG9yU3RvcHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2dsb2JhbENvb3JkPWZhbHNlXVxuICovXG52YXIgTGluZWFyR3JhZGllbnQgPSBmdW5jdGlvbiAoeCwgeSwgeDIsIHkyLCBjb2xvclN0b3BzLCBnbG9iYWxDb29yZCkge1xuICAvLyBTaG91bGQgZG8gbm90aGluZyBtb3JlIGluIHRoaXMgY29uc3RydWN0b3IuIEJlY2F1c2UgZ3JhZGllbnQgY2FuIGJlXG4gIC8vIGRlY2xhcmQgYnkgYGNvbG9yOiB7dHlwZTogJ2xpbmVhcicsIGNvbG9yU3RvcHM6IC4uLn1gLCB3aGVyZVxuICAvLyB0aGlzIGNvbnN0cnVjdG9yIHdpbGwgbm90IGJlIGNhbGxlZC5cbiAgdGhpcy54ID0geCA9PSBudWxsID8gMCA6IHg7XG4gIHRoaXMueSA9IHkgPT0gbnVsbCA/IDAgOiB5O1xuICB0aGlzLngyID0geDIgPT0gbnVsbCA/IDEgOiB4MjtcbiAgdGhpcy55MiA9IHkyID09IG51bGwgPyAwIDogeTI7IC8vIENhbiBiZSBjbG9uZWRcblxuICB0aGlzLnR5cGUgPSAnbGluZWFyJzsgLy8gSWYgdXNlIGdsb2JhbCBjb29yZFxuXG4gIHRoaXMuZ2xvYmFsID0gZ2xvYmFsQ29vcmQgfHwgZmFsc2U7XG4gIEdyYWRpZW50LmNhbGwodGhpcywgY29sb3JTdG9wcyk7XG59O1xuXG5MaW5lYXJHcmFkaWVudC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBMaW5lYXJHcmFkaWVudFxufTtcbnpyVXRpbC5pbmhlcml0cyhMaW5lYXJHcmFkaWVudCwgR3JhZGllbnQpO1xudmFyIF9kZWZhdWx0ID0gTGluZWFyR3JhZGllbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0xpbmVhckdyYWRpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIEdyYWRpZW50ID0gcmVxdWlyZShcIi4vR3JhZGllbnRcIik7XG5cbi8qKlxuICogeCwgeSwgciBhcmUgYWxsIHBlcmNlbnQgZnJvbSAwIHRvIDFcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wLjVdXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MC41XVxuICogQHBhcmFtIHtudW1iZXJ9IFtyPTAuNV1cbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFtjb2xvclN0b3BzXVxuICogQHBhcmFtIHtib29sZWFufSBbZ2xvYmFsQ29vcmQ9ZmFsc2VdXG4gKi9cbnZhciBSYWRpYWxHcmFkaWVudCA9IGZ1bmN0aW9uICh4LCB5LCByLCBjb2xvclN0b3BzLCBnbG9iYWxDb29yZCkge1xuICAvLyBTaG91bGQgZG8gbm90aGluZyBtb3JlIGluIHRoaXMgY29uc3RydWN0b3IuIEJlY2F1c2UgZ3JhZGllbnQgY2FuIGJlXG4gIC8vIGRlY2xhcmQgYnkgYGNvbG9yOiB7dHlwZTogJ3JhZGlhbCcsIGNvbG9yU3RvcHM6IC4uLn1gLCB3aGVyZVxuICAvLyB0aGlzIGNvbnN0cnVjdG9yIHdpbGwgbm90IGJlIGNhbGxlZC5cbiAgdGhpcy54ID0geCA9PSBudWxsID8gMC41IDogeDtcbiAgdGhpcy55ID0geSA9PSBudWxsID8gMC41IDogeTtcbiAgdGhpcy5yID0gciA9PSBudWxsID8gMC41IDogcjsgLy8gQ2FuIGJlIGNsb25lZFxuXG4gIHRoaXMudHlwZSA9ICdyYWRpYWwnOyAvLyBJZiB1c2UgZ2xvYmFsIGNvb3JkXG5cbiAgdGhpcy5nbG9iYWwgPSBnbG9iYWxDb29yZCB8fCBmYWxzZTtcbiAgR3JhZGllbnQuY2FsbCh0aGlzLCBjb2xvclN0b3BzKTtcbn07XG5cblJhZGlhbEdyYWRpZW50LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFJhZGlhbEdyYWRpZW50XG59O1xuenJVdGlsLmluaGVyaXRzKFJhZGlhbEdyYWRpZW50LCBHcmFkaWVudCk7XG52YXIgX2RlZmF1bHQgPSBSYWRpYWxHcmFkaWVudDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUmFkaWFsR3JhZGllbnQuanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgU3R5bGUgPSByZXF1aXJlKFwiLi9TdHlsZVwiKTtcblxudmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciB2ZWMyQ29weSA9IF92ZWN0b3IuY29weTtcblxuLyoqXG4gKiBTdGF0ZXMgbWFjaGluZSBmb3IgbWFuYWdpbmcgZ3JhcGhpYyBzdGF0ZXNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IElHcmFwaGljU3RhdGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbemxldmVsXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6XVxuICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPn0ge3Bvc2l0aW9ufVxuICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPnxudW1iZXJ9IHtyb3RhdGlvbn1cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj59IHtzY2FsZX1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBzdHlsZVxuICpcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG9uZW50ZXJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG9ubGVhdmVcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG9udHJhbnNpdGlvblxuICogQHByb3BlcnR5IHtBcnJheS48SUdyYXBoaWNTdGF0ZVRyYW5zaXRpb258c3RyaW5nPn0gdHJhbnNpdGlvblxuICogICAgICAgICAgIFRyYW5zaXRpb24gb2JqZWN0IG9yIGEgc3RyaW5nIGRlc2NyaXB0b3IgbGlrZSAnKiAzMCAwIExpbmVhcidcbiAqL1xudmFyIHRyYW5zaXRpb25Qcm9wZXJ0aWVzID0gWydwb3NpdGlvbicsICdyb3RhdGlvbicsICdzY2FsZScsICdzdHlsZScsICdzaGFwZSddO1xuLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9TdGF0ZXN+VHJhbnNpdGlvbk9iamVjdFxuICovXG5cbnZhciBUcmFuc2l0aW9uT2JqZWN0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5fZnJvbVN0cihvcHRzKTtcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgb3B0cy5wcm9wZXJ0eSAmJiAodGhpcy5wcm9wZXJ0eSA9IG9wdHMucHJvcGVydHkpO1xuICAgIG9wdHMuZHVyYXRpb24gIT0gbnVsbCAmJiAodGhpcy5kdXJhdGlvbiA9IG9wdHMuZHVyYXRpb24pO1xuICAgIG9wdHMuZWFzaW5nICYmICh0aGlzLmVhc2luZyA9IG9wdHMuZWFzaW5nKTtcbiAgICBvcHRzLmRlbGF5ICYmICh0aGlzLmRlbGF5ID0gb3B0cy5kZWxheSk7XG4gIH1cblxuICBpZiAodGhpcy5wcm9wZXJ0eSAhPT0gJyonKSB7XG4gICAgdGhpcy5wcm9wZXJ0eSA9IHRoaXMucHJvcGVydHkuc3BsaXQoJywnKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnByb3BlcnR5ID0gdHJhbnNpdGlvblByb3BlcnRpZXM7XG4gIH1cbn07XG5cblRyYW5zaXRpb25PYmplY3QucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVHJhbnNpdGlvbk9iamVjdCxcblxuICAvKipcbiAgICogTGlzdCBvZiBhbGwgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzLiBTcGxpdHRlZCBieSBjb21tYS4gTXVzdCBub3QgaGF2ZSBzcGFjZXMgaW4gdGhlIHN0cmluZy5cbiAgICogZS5nLiAncG9zaXRpb24sc3R5bGUuY29sb3InLiAnKicgd2lsbCBtYXRjaCBhbGwgdGhlIHZhbGlkIHByb3BlcnRpZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICpcbiAgICovXG4gIHByb3BlcnR5OiAnKicsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICdMaW5lYXInXG4gICAqL1xuICBlYXNpbmc6ICdMaW5lYXInLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAnbnVtYmVyJ1xuICAgKi9cbiAgZHVyYXRpb246IDUwMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGRlbGF5OiAwLFxuICBfZnJvbVN0cjogZnVuY3Rpb24gKHN0cikge1xuICAgIHZhciBhcnIgPSBzdHIuc3BsaXQoL1xccysvZyk7XG4gICAgdGhpcy5wcm9wZXJ0eSA9IGFyclswXTtcbiAgICB0aGlzLmR1cmF0aW9uID0gK2FyclsxXTtcbiAgICB0aGlzLmRlbGF5ID0gK2FyclsyXTtcbiAgICB0aGlzLmVhc2luZyA9IGFyclszXTtcbiAgfVxufTtcbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3RhdGVzXG4gKi9cblxudmFyIEdyYXBoaWNTdGF0ZXMgPSBmdW5jdGlvbiAob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdGhpcy5fc3RhdGVzID0ge307XG4gIC8qKlxuICAgKiBUYXJnZXQgZWxlbWVudFxuICAgKiBAdHlwZSB7enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlfHpyZW5kZXIvY29udGFpbmVyL0dyb3VwfVxuICAgKi9cblxuICB0aGlzLl9lbCA9IG9wdHMuZWw7XG4gIHRoaXMuX3N1YlN0YXRlcyA9IFtdO1xuICB0aGlzLl90cmFuc2l0aW9uQW5pbWF0b3JzID0gW107XG5cbiAgaWYgKG9wdHMuaW5pdGlhbFN0YXRlKSB7XG4gICAgdGhpcy5faW5pdGlhbFN0YXRlID0gb3B0cy5pbml0aWFsU3RhdGU7XG4gIH1cblxuICB2YXIgb3B0c1N0YXRlcyA9IG9wdHMuc3RhdGVzO1xuXG4gIGlmIChvcHRzU3RhdGVzKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBvcHRzU3RhdGVzKSB7XG4gICAgICBpZiAob3B0c1N0YXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBvcHRzU3RhdGVzW25hbWVdO1xuXG4gICAgICAgIHRoaXMuX2FkZFN0YXRlKG5hbWUsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLnNldFN0YXRlKHRoaXMuX2luaXRpYWxTdGF0ZSk7XG59O1xuXG5HcmFwaGljU3RhdGVzLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEdyYXBoaWNTdGF0ZXMsXG5cbiAgLyoqXG4gICAqIEFsbCBvdGhlciBzdGF0ZSB3aWxsIGJlIGV4dGVuZGVkIGZyb20gaW5pdGlhbCBzdGF0ZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRpYWxTdGF0ZTogJ25vcm1hbCcsXG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgc3RhdGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jdXJyZW50U3RhdGU6ICcnLFxuICBlbDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9lbDtcbiAgfSxcbiAgX2FkZFN0YXRlOiBmdW5jdGlvbiAobmFtZSwgc3RhdGUpIHtcbiAgICB0aGlzLl9zdGF0ZXNbbmFtZV0gPSBzdGF0ZTtcblxuICAgIGlmIChzdGF0ZS50cmFuc2l0aW9uKSB7XG4gICAgICBzdGF0ZS50cmFuc2l0aW9uID0gbmV3IFRyYW5zaXRpb25PYmplY3Qoc3RhdGUudHJhbnNpdGlvbik7XG4gICAgfSAvLyBFeHRlbmQgZnJvbSBpbml0aWFsIHN0YXRlXG5cblxuICAgIGlmIChuYW1lICE9PSB0aGlzLl9pbml0aWFsU3RhdGUpIHtcbiAgICAgIHRoaXMuX2V4dGVuZEZyb21Jbml0aWFsKHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVsID0gdGhpcy5fZWw7IC8vIHNldFN0YXRlIOeahOaXtuWAmeiHquW4pueahCBzdHlsZSDlkowgc2hhcGUg6YO95Lya6KKr55u05o6l6KaG55uWXG4gICAgICAvLyDmiYDku6Xov5novrnlhYjmioroh6rluKbnmoQgc3R5bGUg5ZKMIHNoYXBlIOaJqeWxleWIsOWIneWni+eKtuaAgeS4rVxuXG4gICAgICB6clV0aWwubWVyZ2Uoc3RhdGUuc3R5bGUsIGVsLnN0eWxlLCBmYWxzZSwgZmFsc2UpO1xuXG4gICAgICBpZiAoc3RhdGUuc2hhcGUpIHtcbiAgICAgICAgenJVdGlsLm1lcmdlKHN0YXRlLnNoYXBlLCBlbC5zaGFwZSwgZmFsc2UsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuc2hhcGUgPSB6clV0aWwuY2xvbmUoZWwuc2hhcGUsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMuX3N0YXRlcykge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdGhpcy5fZXh0ZW5kRnJvbUluaXRpYWwodGhpcy5fc3RhdGVzW25hbWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2V4dGVuZEZyb21Jbml0aWFsOiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gdGhpcy5fc3RhdGVzW3RoaXMuX2luaXRpYWxTdGF0ZV07XG5cbiAgICBpZiAoaW5pdGlhbFN0YXRlICYmIHN0YXRlICE9PSBpbml0aWFsU3RhdGUpIHtcbiAgICAgIHpyVXRpbC5tZXJnZShzdGF0ZSwgaW5pdGlhbFN0YXRlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICB9LFxuICBzZXRTdGF0ZTogZnVuY3Rpb24gKG5hbWUsIHNpbGVudCkge1xuICAgIGlmIChuYW1lID09PSB0aGlzLl9jdXJyZW50U3RhdGUgJiYgIXRoaXMudHJhbnNpdGluZygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGVzW25hbWVdO1xuXG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICB0aGlzLl9zdG9wVHJhbnNpdGlvbigpO1xuXG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICB2YXIgcHJldlN0YXRlID0gdGhpcy5fc3RhdGVzW3RoaXMuX2N1cnJlbnRTdGF0ZV07XG5cbiAgICAgICAgaWYgKHByZXZTdGF0ZSkge1xuICAgICAgICAgIHByZXZTdGF0ZS5vbmxlYXZlICYmIHByZXZTdGF0ZS5vbmxlYXZlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5vbmVudGVyICYmIHN0YXRlLm9uZW50ZXIuY2FsbCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY3VycmVudFN0YXRlID0gbmFtZTtcblxuICAgICAgaWYgKHRoaXMuX2VsKSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXMuX2VsOyAvLyBTZXR0aW5nIGF0dHJpYnV0ZXNcblxuICAgICAgICBpZiAoc3RhdGUuemxldmVsICE9IG51bGwpIHtcbiAgICAgICAgICBlbC56bGV2ZWwgPSBzdGF0ZS56bGV2ZWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUueiAhPSBudWxsKSB7XG4gICAgICAgICAgZWwueiA9IHN0YXRlLno7XG4gICAgICAgIH0gLy8gU1JUXG5cblxuICAgICAgICBzdGF0ZS5wb3NpdGlvbiAmJiB2ZWMyQ29weShlbC5wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBzdGF0ZS5zY2FsZSAmJiB2ZWMyQ29weShlbC5zY2FsZSwgc3RhdGUuc2NhbGUpO1xuXG4gICAgICAgIGlmIChzdGF0ZS5yb3RhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgZWwucm90YXRpb24gPSBzdGF0ZS5yb3RhdGlvbjtcbiAgICAgICAgfSAvLyBTdHlsZVxuXG5cbiAgICAgICAgaWYgKHN0YXRlLnN0eWxlKSB7XG4gICAgICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IHRoaXMuX3N0YXRlc1t0aGlzLl9pbml0aWFsU3RhdGVdO1xuICAgICAgICAgIGVsLnN0eWxlID0gbmV3IFN0eWxlKCk7XG5cbiAgICAgICAgICBpZiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS5leHRlbmRGcm9tKGluaXRpYWxTdGF0ZS5zdHlsZSwgZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICggLy8gTm90IGluaXRpYWwgc3RhdGVcbiAgICAgICAgICBuYW1lICE9IHRoaXMuX2luaXRpYWxTdGF0ZSAvLyBOb3QgY29waWVkIGZyb20gaW5pdGlhbCBzdGF0ZSBpbiBfZXh0ZW5kRnJvbUluaXRpYWwgbWV0aG9kXG4gICAgICAgICAgJiYgaW5pdGlhbFN0YXRlLnN0eWxlICE9PSBzdGF0ZS5zdHlsZSkge1xuICAgICAgICAgICAgZWwuc3R5bGUuZXh0ZW5kRnJvbShzdGF0ZS5zdHlsZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLnNoYXBlKSB7XG4gICAgICAgICAgZWwuc2hhcGUgPSB6clV0aWwuY2xvbmUoc3RhdGUuc2hhcGUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwuZGlydHkoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3N1YlN0YXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fc3ViU3RhdGVzLnNldFN0YXRlKG5hbWUpO1xuICAgIH1cbiAgfSxcbiAgZ2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFN0YXRlO1xuICB9LFxuICB0cmFuc2l0aW9uU3RhdGU6IGZ1bmN0aW9uICh0YXJnZXQsIGRvbmUpIHtcbiAgICBpZiAodGFyZ2V0ID09PSB0aGlzLl9jdXJyZW50U3RhdGUgJiYgIXRoaXMudHJhbnNpdGluZygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGVzW3RhcmdldF07XG4gICAgdmFyIHN0eWxlU2hhcGVSZWcgPSAvJFtzdHlsZXxzaGFwZV1cXC4vO1xuICAgIHZhciBzZWxmID0gdGhpczsgLy8gQW5pbWF0aW9uIOWOu+mHjVxuXG4gICAgdmFyIHByb3BQYXRoTWFwID0ge307XG5cbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIHNlbGYuX3N0b3BUcmFuc2l0aW9uKCk7XG5cbiAgICAgIHZhciBlbCA9IHNlbGYuX2VsO1xuXG4gICAgICBpZiAoc3RhdGUudHJhbnNpdGlvbiAmJiBlbCAmJiBlbC5fX3pyKSB7XG4gICAgICAgIC8vIEVsIGNhbiBiZSBhbmltYXRlZFxuICAgICAgICB2YXIgdHJhbnNpdGlvbkNmZyA9IHN0YXRlLnRyYW5zaXRpb247XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHRyYW5zaXRpb25DZmcucHJvcGVydHk7XG4gICAgICAgIHZhciBhbmltYXRpbmdDb3VudCA9IDA7XG5cbiAgICAgICAgdmFyIGFuaW1hdGlvbkRvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYW5pbWF0aW5nQ291bnQtLTtcblxuICAgICAgICAgIGlmIChhbmltYXRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgc2VsZi5zZXRTdGF0ZSh0YXJnZXQpO1xuICAgICAgICAgICAgZG9uZSAmJiBkb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eVtpXTsgLy8gQW5pbWF0aW5nIGFsbCB0aGUgcHJvcGVydGllcyBpbiBzdHlsZSBvciBzaGFwZVxuXG4gICAgICAgICAgaWYgKHByb3BOYW1lID09PSAnc3R5bGUnIHx8IHByb3BOYW1lID09PSAnc2hhcGUnKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGVbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzdGF0ZVtwcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlW3Byb3BOYW1lXS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IHByb3BOYW1lICsgJy4nICsga2V5O1xuXG4gICAgICAgICAgICAgICAgaWYgKHByb3BQYXRoTWFwW3BhdGhdKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwcm9wUGF0aE1hcFtwYXRoXSA9IDE7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW5nQ291bnQgKz0gc2VsZi5fYW5pbVByb3Aoc3RhdGUsIHByb3BOYW1lLCBrZXksIHRyYW5zaXRpb25DZmcsIGFuaW1hdGlvbkRvbmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcm9wUGF0aE1hcFtwcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb3BQYXRoTWFwW3Byb3BOYW1lXSA9IDE7IC8vIEFuaW1hdGluZyBwYXJ0aWN1bGFyIHByb3BlcnR5IGluIHN0eWxlIG9yIHN0eWxlXG5cbiAgICAgICAgICAgIGlmIChwcm9wTmFtZS5tYXRjaChzdHlsZVNoYXBlUmVnKSkge1xuICAgICAgICAgICAgICAvLyByZW1vdmUgJ3N0eWxlLicsICdzaGFwZS4nIHByZWZpeFxuICAgICAgICAgICAgICB2YXIgc3ViUHJvcCA9IHByb3BOYW1lLnNsaWNlKDAsIDUpO1xuICAgICAgICAgICAgICBwcm9wTmFtZSA9IHByb3BOYW1lLnNsaWNlKDYpO1xuICAgICAgICAgICAgICBhbmltYXRpbmdDb3VudCArPSBzZWxmLl9hbmltUHJvcChzdGF0ZSwgc3ViUHJvcCwgcHJvcE5hbWUsIHRyYW5zaXRpb25DZmcsIGFuaW1hdGlvbkRvbmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYW5pbWF0aW5nQ291bnQgKz0gc2VsZi5fYW5pbVByb3Aoc3RhdGUsICcnLCBwcm9wTmFtZSwgdHJhbnNpdGlvbkNmZywgYW5pbWF0aW9uRG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIE5vIHRyYW5zaXRpb24gcHJvcGVydGllc1xuXG5cbiAgICAgICAgaWYgKGFuaW1hdGluZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgc2VsZi5zZXRTdGF0ZSh0YXJnZXQpO1xuICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNldFN0YXRlKHRhcmdldCk7XG4gICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzdWJTdGF0ZXMgPSBzZWxmLl9zdWJTdGF0ZXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YlN0YXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgc3ViU3RhdGVzLnRyYW5zaXRpb25TdGF0ZSh0YXJnZXQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRG8gdHJhbnNpdGlvbiBhbmltYXRpb24gb2YgcGFydGljdWxhciBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN1YlByb3BLZXlcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNpdGlvbkNmZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYW5pbVByb3A6IGZ1bmN0aW9uIChzdGF0ZSwgc3ViUHJvcEtleSwga2V5LCB0cmFuc2l0aW9uQ2ZnLCBkb25lKSB7XG4gICAgdmFyIGVsID0gdGhpcy5fZWw7XG4gICAgdmFyIHN0YXRlT2JqID0gc3ViUHJvcEtleSA/IHN0YXRlW3N1YlByb3BLZXldIDogc3RhdGU7XG4gICAgdmFyIGVsT2JqID0gc3ViUHJvcEtleSA/IGVsW3N1YlByb3BLZXldIDogZWw7XG4gICAgdmFyIGF2YWlsYWJsZVByb3AgPSBzdGF0ZU9iaiAmJiBrZXkgaW4gc3RhdGVPYmogJiYgZWxPYmogJiYga2V5IGluIGVsT2JqO1xuICAgIHZhciB0cmFuc2l0aW9uQW5pbWF0b3JzID0gdGhpcy5fdHJhbnNpdGlvbkFuaW1hdG9ycztcblxuICAgIGlmIChhdmFpbGFibGVQcm9wKSB7XG4gICAgICB2YXIgb2JqID0ge307XG5cbiAgICAgIGlmIChzdGF0ZU9ialtrZXldID09PSBlbE9ialtrZXldKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBvYmpba2V5XSA9IHN0YXRlT2JqW2tleV07XG4gICAgICB2YXIgYW5pbWF0b3IgPSBlbC5hbmltYXRlKHN1YlByb3BLZXkpLndoZW4odHJhbnNpdGlvbkNmZy5kdXJhdGlvbiwgb2JqKS5kZWxheSh0cmFuc2l0aW9uQ2ZnLmRlYWx5KS5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkeCA9IHpyVXRpbC5pbmRleE9mKHRyYW5zaXRpb25BbmltYXRvcnMsIDEpO1xuXG4gICAgICAgIGlmIChpZHggPiAwKSB7XG4gICAgICAgICAgdHJhbnNpdGlvbkFuaW1hdG9ycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pLnN0YXJ0KHRyYW5zaXRpb25DZmcuZWFzaW5nKTtcbiAgICAgIHRyYW5zaXRpb25BbmltYXRvcnMucHVzaChhbmltYXRvcik7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgX3N0b3BUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRyYW5zaXRpb25BbmltYXRvcnMgPSB0aGlzLl90cmFuc2l0aW9uQW5pbWF0b3JzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2l0aW9uQW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0cmFuc2l0aW9uQW5pbWF0b3JzW2ldLnN0b3AoKTtcbiAgICB9XG5cbiAgICB0cmFuc2l0aW9uQW5pbWF0b3JzLmxlbmd0aCA9IDA7XG4gIH0sXG4gIHRyYW5zaXRpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNpdGlvbkFuaW1hdG9ycy5sZW5ndGggPiAwO1xuICB9LFxuICBhZGRTdWJTdGF0ZXM6IGZ1bmN0aW9uIChzdGF0ZXMpIHtcbiAgICB0aGlzLl9zdWJTdGF0ZXMucHVzaChzdGF0ZXMpO1xuICB9LFxuICByZW1vdmVTdWJTdGF0ZXM6IGZ1bmN0aW9uIChzdGF0ZXMpIHtcbiAgICB2YXIgaWR4ID0genJVdGlsLmluZGV4T2YodGhpcy5fc3ViU3RhdGVzLCBzdGF0ZXMpO1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICB0aGlzLl9zdWJTdGF0ZXMuc3BsaWNlKHN0YXRlcywgMSk7XG4gICAgfVxuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gR3JhcGhpY1N0YXRlcztcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvU3RhdGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog5LqL5Lu25Yaz562W5aSa6L655b2iXHJcbiAqIEBtb2R1bGUgZmlzaC10b3BvLWJvL25vZGUvRXZlbnREZWNpc2lvbk5vZGVcclxuICogQ3JlYXRlZCBieSBtYWppYW5hbiBvbiAxNi81LzE5LlxyXG4gKi9cclxuXHJcbiAgICB2YXIgQ29uc3QgPSByZXF1aXJlKCcuLi9tb2RlbHMvQ29uc3QnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIG5vZGVPcHRpb25zID0gbnVsbDtcclxuXHJcbiAgICBmdW5jdGlvbiBFdmVudERlY2lzaW9uTm9kZShkYXRhLCBvcHRzKSB7XHJcbiAgICAgICAgbm9kZU9wdGlvbnMgPSBvcHRzO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCT+WxnuaAp+aVsOaNrlxyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6LW35aeL5L2N572u5Z2Q5qCHXHJcbiAgICAgICAgICogQHR5cGUge3N0YXJ0UG9zfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fc3RhcnRQb3MgPSBvcHRzLnN0YXJ0UG9zO1xyXG5cclxuICAgICAgICB0aGlzLl90eXBlID0gb3B0cy50eXBlIHx8ICdib0V2ZW50JztcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5piv5ZCm5pSv5oyB54K55Ye7XHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9jbGlja2FibGUgPSBvcHRzLmNsaWNrYWJsZSB8fCBmYWxzZTtcclxuICAgICAgICB0aGlzLl9wb3B1cE9wdHMgPSBvcHRzLnBvcHVwT3B0cztcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR3JvdXDlrrnlmahcclxuICAgICAgICAgKiBAdHlwZSB6cmVuZGVyL2dyYXBoaWMvR3JvdXBcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2dyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcclxuICAgICAgICB0aGlzLl9ncm91cC5uYW1lID0gdGhpcy5fZGF0YS5pZDtcclxuXHJcbiAgICAgICAgLy/nlJ/miJBCT+WxnuaAp+WbvuW9olxyXG4gICAgICAgIHRoaXMuX3JlbmRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBldmVudFByb3RvID0gRXZlbnREZWNpc2lvbk5vZGUucHJvdG90eXBlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W5YWz57O75pW05L2T5Zu+5b2iXHJcbiAgICAgKiBAcmV0dXJucyB7enJlbmRlci9ncmFwaGljL0dyb3VwfVxyXG4gICAgICovXHJcbiAgICBldmVudFByb3RvLmdldFNoYXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnlJ/miJDkuovku7blhrPnrZblm77lvaJcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGV2ZW50UHJvdG8uX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL+Wkmui+ueW9olxyXG4gICAgICAgIHRoaXMuX2NyZWF0ZUV2ZW50U2hhcGUoKTtcclxuICAgICAgICAvL+aWh+Wtl1xyXG4gICAgICAgIHRoaXMuX2NyZWF0ZUVWZW50TmFtZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOS6i+S7tuWGs+etluWkmui+ueW9olxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZXZlbnRQcm90by5fY3JlYXRlRXZlbnRTaGFwZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgLy/lpJrovrnlvaLpq5jluqZcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gQ29uc3QuQk9fRVZFTlRfSEVJR0hULFxyXG4gICAgICAgICAgICB4ID0gdGhpcy5fc3RhcnRQb3MueCArIDEsXHJcbiAgICAgICAgICAgIHkgPSB0aGlzLl9zdGFydFBvcy55LFxyXG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMuX3R5cGUgPT0gJ2JvRXZlbnQnID8gQ29uc3QuQk9fRVZFTlRfV0lEVEggOiBDb25zdC5CT19BVFRSX0VWRU5UX1dJRFRILFxyXG5cclxuICAgICAgICAgICAgc2hhcGUgPSBuZXcgZ3JhcGhpYy5Qb2x5Z29uKHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuX2RhdGEuaWQsXHJcbiAgICAgICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50czogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBbeCwgeV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFt4ICsgd2lkdGggLSAxMCwgeV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFt4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLyAyXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgW3ggKyB3aWR0aCAtIDEwLCB5ICsgaGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgW3gsIHkgKyBoZWlnaHRdXVxyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6ICcjRkZDQ0NDJyxcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICcjMDAwMDAwJyxcclxuICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzVcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fY2xpY2thYmxlKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLmNsaWNrYWJsZSA9IHRoaXMuX2NsaWNrYWJsZTtcclxuICAgICAgICAgICAgc2hhcGUuX2RhdGEgPSB0aGlzLl9kYXRhO1xyXG4gICAgICAgICAgICBzaGFwZS5fcG9wdXBPcHRzID0gdGhpcy5fcG9wdXBPcHRzO1xyXG4gICAgICAgICAgICBzaGFwZS5vbmNsaWNrID0gdGhpcy5fY2xpY2s7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgdGhpcy5fZ3JvdXAuYWRkKHNoYXBlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDngrnlh7vkuovku7ZcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGV2ZW50UHJvdG8uX2NsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgREFUQTogdGhpcy5fZGF0YVxyXG4gICAgICAgICAgICB9LCB0aGlzLl9wb3B1cE9wdHMpO1xyXG5cclxuICAgICAgICBub2RlT3B0aW9ucy5iaW5kQm9DbGlja0V2ZW50KG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOS6i+S7tuWGs+etluWQjeensFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZXZlbnRQcm90by5fY3JlYXRlRVZlbnROYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB4ID0gdGhpcy5fc3RhcnRQb3MueCArICh0aGlzLl90eXBlID09ICdib0V2ZW50JyA/IENvbnN0LkJPX0FUVFJfUEFERElOR19MRUZUIDogMTUpLFxyXG4gICAgICAgICAgICB5ID0gdGhpcy5fc3RhcnRQb3MueSxcclxuXHJcbiAgICAgICAgICAgIGV2ZW50TmFtZVNoYXBlID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuX2RhdGEubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0Rm9udDogQ29uc3QuQk9fRVZFTlRfRk9OVCxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdsZWZ0JywgIC8v6Z2g5bem5byA5aeL77yM5L6/5LqO6K6h566X5L2N572uXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiAndG9wJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogW3gsIHldXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fY2xpY2thYmxlKSB7XHJcbiAgICAgICAgICAgIGV2ZW50TmFtZVNoYXBlLmNsaWNrYWJsZSA9IHRoaXMuX2NsaWNrYWJsZTtcclxuICAgICAgICAgICAgZXZlbnROYW1lU2hhcGUuX2RhdGEgPSB0aGlzLl9kYXRhO1xyXG4gICAgICAgICAgICBldmVudE5hbWVTaGFwZS5fcG9wdXBPcHRzID0gdGhpcy5fcG9wdXBPcHRzO1xyXG4gICAgICAgICAgICBldmVudE5hbWVTaGFwZS5vbmNsaWNrID0gdGhpcy5fY2xpY2s7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9ncm91cC5hZGQoZXZlbnROYW1lU2hhcGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RGVjaXNpb25Ob2RlO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWJvL2xpYi9ub2RlL0V2ZW50RGVjaXNpb25Ob2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQk/nn6nlvaLlhoXpg6jnmoTmqKrnur/vvIzliIbkuLrlrp7nur/lkozomZrnur/kuKTnp41cclxuICogQG1vZHVsZSBmaXNoLXRvcG8tYm8vbm9kZS9MaW5lTm9kZVxyXG4gKiBDcmVhdGVkIGJ5IG1hamlhbmFuIG9uIDE2LzUvMTkuXHJcbiAqL1xyXG5cclxuXHJcbiAgICB2YXIgQ29uc3QgPSByZXF1aXJlKCcuLi9tb2RlbHMvQ29uc3QnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIC8qKlxyXG4gICAgICogQk/lkI3lrZfkuIvpnaLnmoTlrp7njrBcclxuICAgICAqIEBwYXJhbSB7e3g6ICosIHk6ICp9fSBzdGFydFBvcywg5byA5aeL5Z2Q5qCHXHJcbiAgICAgKiBAcmV0dXJucyB7enJlbmRlci9ncmFwaGljL3NoYXBlL0xpbmV9XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQm9MaW5lKHN0YXJ0UG9zKSB7XHJcblxyXG4gICAgICAgIHZhciBlbmRQb3MgPSB7eDogc3RhcnRQb3MueCArIENvbnN0LkJPX05PREVfV0lEVEgsIHk6IHN0YXJ0UG9zLnl9O1xyXG5cclxuICAgICAgICByZXR1cm4gX2xpbmUoc3RhcnRQb3MsIGVuZFBvcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCT+WxnuaAp+S5i+mXtOeahOiZmue6v1xyXG4gICAgICogQHBhcmFtIHt7eDogKiwgeTogKn19IHN0YXJ0UG9zLCDlvIDlp4vlnZDmoIdcclxuICAgICAqIEByZXR1cm5zIHt6cmVuZGVyL2dyYXBoaWMvc2hhcGUvTGluZX1cclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBBdHRyTGluZShzdGFydFBvcykge1xyXG5cclxuICAgICAgICB2YXIgZW5kUG9zID0ge3g6IHN0YXJ0UG9zLnggKyBDb25zdC5CT19OT0RFX1dJRFRILCB5OiBzdGFydFBvcy55fSxcclxuICAgICAgICAgICAgc3R5bGUgPSB7bGluZURhc2g6IFtDb25zdC5MSU5FX0RBU0hdfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIF9saW5lKHN0YXJ0UG9zLCBlbmRQb3MsIHN0eWxlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJP5bGe5oCn5LiOQk/kuovku7blhrPnrZbkuYvpl7TnmoTlnoLnm7TomZrnur9cclxuICAgICAqIEBwYXJhbSB7e3g6ICosIHk6ICp9fSBzdGFydFBvcywg5byA5aeL5Z2Q5qCHXHJcbiAgICAgKiBAcGFyYW0ge2ludH0gYXR0ckhlaWdodCwg6auY5bqmXHJcbiAgICAgKiBAcmV0dXJucyB7enJlbmRlci9ncmFwaGljL3NoYXBlL0xpbmV9XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQXR0ckV2ZW50TGluZShzdGFydFBvcywgYXR0ckhlaWdodCkge1xyXG4gICAgICAgIHZhciBlbmRQb3MgPSB7eDogc3RhcnRQb3MueCwgeTogc3RhcnRQb3MueSArIGF0dHJIZWlnaHR9LFxyXG4gICAgICAgICAgICBzdHlsZSA9IHtsaW5lRGFzaDogW0NvbnN0LkxJTkVfREFTSF19O1xyXG5cclxuICAgICAgICByZXR1cm4gX2xpbmUoc3RhcnRQb3MsIGVuZFBvcywgc3R5bGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog55S757q/XHJcbiAgICAgKiBAcGFyYW0ge3t4OiAqLCB5OiAqfX0gc3RhcnRQb3MsIOW8gOWni+WdkOagh1xyXG4gICAgICogQHBhcmFtIHt7eDogKiwgeTogKn19IGVuZFBvcywg57uT5p2f5Z2Q5qCHXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGUsIOagt+W8jyzlj6/nqbpcclxuICAgICAqIEByZXR1cm5zIHt6cmVuZGVyL2dyYXBoaWMvc2hhcGUvTGluZX1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9saW5lKHN0YXJ0UG9zLCBlbmRQb3MsIHN0eWxlKSB7XHJcblxyXG4gICAgICAgIHZhciBfc3R5bGUgPSB7XHJcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiAnIzAwMDAwMCcsXHJcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC41LFxyXG4gICAgICAgICAgICBwZXJjZW50OiAxXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdXRpbC5leHRlbmQoX3N0eWxlLCBzdHlsZSk7XHJcblxyXG4gICAgICAgIHZhciBzaGFwZSA9IG5ldyBncmFwaGljLkxpbmUoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgcG9pbnRcclxuICAgICAgICAgICAgICAgIHgxOiBzdGFydFBvcy54LFxyXG4gICAgICAgICAgICAgICAgeTE6IHN0YXJ0UG9zLnksXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRW5kIHBvaW50XHJcbiAgICAgICAgICAgICAgICB4MjogZW5kUG9zLngsXHJcbiAgICAgICAgICAgICAgICB5MjogZW5kUG9zLnksXHJcblxyXG4gICAgICAgICAgICAgICAgcGVyY2VudDogMVxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc3R5bGU6IF9zdHlsZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gc2hhcGU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgICAgIEJvTGluZTogQm9MaW5lLFxyXG4gICAgICAgIEF0dHJMaW5lOiBBdHRyTGluZSxcclxuICAgICAgICBBdHRyRXZlbnRMaW5lOiBBdHRyRXZlbnRMaW5lXHJcbiAgICB9O1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWJvL2xpYi9ub2RlL0xpbmVOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQk/lsZ7mgKdcclxuICogMS5CT+WxnuaAp+WQjeWtl1xyXG4gKiAyLkJP5bGe5oCn5pWw5o2u57G75Z6LXHJcbiAqIDMuQk/lsZ7mgKfkuovku7blhrPnrZZcclxuICogQG1vZHVsZSBmaXNoLXRvcG8tYm8vbm9kZS9Cb0F0dHJOb2RlXHJcbiAqIENyZWF0ZWQgYnkgbWFqaWFuYW4gb24gMTYvNS8xOS5cclxuICovXHJcblxyXG4gICAgdmFyIENvbnN0ID0gcmVxdWlyZSgnLi4vbW9kZWxzL0NvbnN0Jyk7XHJcbiAgICB2YXIgRXZlbnREZWNpc2lvbiA9IHJlcXVpcmUoJy4uL25vZGUvRXZlbnREZWNpc2lvbk5vZGUnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIG5vZGVPcHRpb25zID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3tcclxuICAgICAqICAgICAgICAgIGlkOiBTdHJpbmcgYm/lsZ7mgKfmoIfor4YsXHJcbiAgICAgKiAgICAgICAgICBjb2RlOiBTdHJpbmcgYm/lsZ7mgKfnvJbnoIFcclxuICAgICAqICAgICAgICAgIGtleVZhbHVlOiBib29sZWFuIOaYr+WQpuS4uuS4u+mUrixcclxuICAgICAqICAgICAgICAgIGRhdGFUeXBlOiBTdHJpbmcg5bGe5oCn5pWw5o2u57G75Z6LLFxyXG4gICAgICogICAgICAgICAgYm9BdHRyRXZlbnRBcnI6W10g5bGe5oCn5LqL5Lu25Yaz562W5pWw57uEXHJcbiAgICAgKiAgICAgICAgICB9fSBib0F0dHJEYXRhIEJP5bGe5oCn5pWw5o2u5a+56LGhLFxyXG4gICAgICogQHBhcmFtIHt7XHJcbiAgICAgKiAgICAgICAgICBzdGFydFBvczoge3g6IG51bWJlciwgeTogbnVtYmVyfei1t+Wni+S9jee9rixcclxuICAgICAqICAgICAgICAgIGRpc3BsYXlEYXRhVHlwZTogYm9vbGVhbiDmmK/lkKbmmL7npLrmlbDmja7nsbvlnossXHJcbiAgICAgKiAgICAgICAgICBkaXNwbGF5RXZlbnREZWNpc2lvbjogYm9vbGVhbiDmmK/lkKbmmL7npLrkuovku7blhrPnrZYsXHJcbiAgICAgKiAgICAgICAgICBldmVudENsaWNrYWJsZTogYm9vbGVhbiBCT+WxnuaAp+S6i+S7tuWGs+etluaYr+WQpuaUr+aMgeeCueWHu+S6i+S7tiwg5Y+v56m6IOm7mOiupGZhbHNlLFxyXG4gICAgICogICAgICAgICAgZXZlbnRQb3B1cE9wdHM6IE9iamVjdCDngrnlh7tCT+WxnuaAp+S6i+S7tuWGs+etluW8ueWHuumhtemdouWPguaVsO+8jHVybCx3aWR0aCxoZWlnaHTnrYksXHJcbiAgICAgKiAgICAgICAgICB9fSBvcHRzXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQm9BdHRyKGJvQXR0ckRhdGEsIG9wdHMpIHtcclxuICAgICAgICBub2RlT3B0aW9ucyA9IG9wdHM7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJP5bGe5oCn5pWw5o2uXHJcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2RhdGEgPSBib0F0dHJEYXRhO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDmmK/lkKbkuLrkuLvplK5cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2tleVZhbHVlID0gYm9BdHRyRGF0YS5rZXlWYWx1ZSB8fCBmYWxzZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6LW35aeL5L2N572u5Z2Q5qCHXHJcbiAgICAgICAgICogQHR5cGUge3N0YXJ0UG9zfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fc3RhcnRQb3MgPSBvcHRzLnN0YXJ0UG9zO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDmmK/lkKbmmL7npLrmlbDmja7nsbvlnotcclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2Rpc3BsYXlEYXRhVHlwZSA9IG9wdHMuZGlzcGxheURhdGFUeXBlIHx8IGZhbHNlO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDmmK/lkKbmmL7npLrkuovku7blhrPnrZZcclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2Rpc3BsYXlFdmVudERlY2lzaW9uID0gb3B0cy5kaXNwbGF5RXZlbnREZWNpc2lvbiB8fCBmYWxzZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5piv5ZCm5pSv5oyB54K55Ye7XHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9ldmVudENsaWNrYWJsZSA9IG9wdHMuZXZlbnRDbGlja2FibGUgfHwgZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRQb3B1cE9wdHMgPSBvcHRzLmV2ZW50UG9wdXBPcHRzO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHcm91cOWuueWZqFxyXG4gICAgICAgICAqIEB0eXBlIHpyZW5kZXIvZ3JhcGhpYy9Hcm91cFxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xyXG4gICAgICAgIHRoaXMuX2dyb3VwLm5hbWUgPSB0aGlzLl9kYXRhLmlkO1xyXG5cclxuICAgICAgICAvL+eUn+aIkEJP5bGe5oCn5Zu+5b2iXHJcbiAgICAgICAgdGhpcy5fcmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGJvQXR0clByb3RvID0gQm9BdHRyLnByb3RvdHlwZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluWFs+ezu+aVtOS9k+WbvuW9olxyXG4gICAgICogQHJldHVybnMge3pyZW5kZXIvZ3JhcGhpYy9Hcm91cH1cclxuICAgICAqL1xyXG4gICAgYm9BdHRyUHJvdG8uZ2V0U2hhcGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3VwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnlJ/miJBCT+WxnuaAp+WbvuW9olxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgYm9BdHRyUHJvdG8uX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL+WxnuaAp+WQjeWtl1xyXG4gICAgICAgIHRoaXMuX2NyZWF0ZVRleHQoKTtcclxuXHJcbiAgICAgICAgLy/lsZ7mgKfmlbDmja7nsbvlnotcclxuICAgICAgICB0aGlzLl9jcmVhdGVEYXRhVHlwZSgpO1xyXG5cclxuICAgICAgICAvL+WxnuaAp+S6i+S7tuWGs+etllxyXG4gICAgICAgIHRoaXMuX2NyZWF0ZUV2ZW50RGVjaXNpb24oKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlsZ7mgKflkI3lrZdcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGJvQXR0clByb3RvLl9jcmVhdGVUZXh0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgeCA9IHRoaXMuX3N0YXJ0UG9zLnggKyBDb25zdC5CT19BVFRSX1BBRERJTkdfTEVGVCxcclxuICAgICAgICAgICAgeSA9IHRoaXMuX3N0YXJ0UG9zLnksXHJcblxyXG4gICAgICAgICAgICBhdHRyTmFtZVNoYXBlID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuX2RhdGEubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0Rm9udDogQ29uc3QuQk9fQVRUUl9GT05ULFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2xlZnQnLCAgLy/pnaDlt6blvIDlp4vvvIzkvr/kuo7orqHnrpfkvY3nva5cclxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICd0b3AnLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vbGluZVdpZHRoOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IHRoaXMuX2tleVZhbHVlID8gJ3JlZCcgOiAnYmxhY2snXHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbeCwgeV1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8v6YeN5paw6K6+572u5Zu+5b2i6auY5bqmID0g5paH5pys6auY5bqmICsgcGFkZGluZy10b3AgKyBwYWRkaW5nLWJvdHRvbVxyXG4gICAgICAgIGF0dHJOYW1lU2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0ICs9IENvbnN0LkJPX0FUVFJfUEFERElOR19UT1AgKyBDb25zdC5CT19BVFRSX1BBRERJTkdfQk9UVE9NO1xyXG4gICAgICAgIC8v6YeN5paw6K6+572u5Zu+5b2i6auY5bqmID0gQk/nn6nlvaLlrr3luqbvvIznlKjkuo7lkI7nu61SZWxhdGlvbueUu+Wbvuiuoeeul1xyXG4gICAgICAgIGF0dHJOYW1lU2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggPSBDb25zdC5CT19OT0RFX1dJRFRIO1xyXG5cclxuICAgICAgICAvL+mHjeaWsOiuvue9rkLotbflp4vmsLTlubPlnZDmoIcgPSDlh4/ljrvlgY/np7vph49cclxuICAgICAgICBhdHRyTmFtZVNoYXBlLmdldEJvdW5kaW5nUmVjdCgpLnggKz0gLUNvbnN0LkJPX0FUVFJfUEFERElOR19MRUZUO1xyXG4gICAgICAgIC8vYXR0ck5hbWVTaGFwZS5nZXRCb3VuZGluZ1JlY3QoKS55ID0gKyBhdHRyTmFtZVNoYXBlLnBvc2l0aW9uWzFdO1xyXG5cclxuICAgICAgICB0aGlzLl9ncm91cC5hZGQoYXR0ck5hbWVTaGFwZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5bGe5oCn5pWw5o2u57G75Z6LXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBib0F0dHJQcm90by5fY3JlYXRlRGF0YVR5cGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9kaXNwbGF5RGF0YVR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHggPSB0aGlzLl9zdGFydFBvcy54ICsgQ29uc3QuQk9fTk9ERV9XSURUSCAtIDEwLFxyXG4gICAgICAgICAgICB5ID0gdGhpcy5fc3RhcnRQb3MueSxcclxuICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcclxuXHJcbiAgICAgICAgLy/lpoLmnpzov5jopoHmmL7npLrkuovku7blhrPnrZbvvIzliJnlrr3luqbph43mlrDorqHnrpdcclxuICAgICAgICBpZiAodGhpcy5fZGlzcGxheUV2ZW50RGVjaXNpb24pIHtcclxuICAgICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xyXG4gICAgICAgICAgICB4ID0gdGhpcy5fc3RhcnRQb3MueCArIENvbnN0LkJPX05PREVfV0lEVEggLyAzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIF9kYXRhVHlwZVNoYXBlID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLl9kYXRhLmRhdGFUeXBlIHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgdGV4dEZvbnQ6IENvbnN0LkJPX0FUVFJfRk9OVCxcclxuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLCAgLy/pnaDlt6blvIDlp4vvvIzkvr/kuo7orqHnrpfkvY3nva5cclxuICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogJ3RvcCcsXHJcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDFcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBbeCwgeV1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5fZ3JvdXAuYWRkKF9kYXRhVHlwZVNoYXBlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlsZ7mgKfkuovku7blhrPnrZZcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGJvQXR0clByb3RvLl9jcmVhdGVFdmVudERlY2lzaW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZGlzcGxheUV2ZW50RGVjaXNpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIF9ib0F0dHJFdmVudEFyciA9IHRoaXMuX2RhdGEuYm9BdHRyRXZlbnRBcnIgfHwgW10sXHJcbiAgICAgICAgICAgIF9ib0F0dHJFdmVudExlbiA9IF9ib0F0dHJFdmVudEFyci5sZW5ndGgsXHJcbiAgICAgICAgICAgIHBhZGRpbmcgPSAoX2JvQXR0ckV2ZW50TGVuID4gMSkgPyAxMCA6IDAsXHJcbiAgICAgICAgICAgIF9zdGFydFBvcyA9IHtcclxuICAgICAgICAgICAgICAgIHg6IHRoaXMuX3N0YXJ0UG9zLnggKyBDb25zdC5CT19OT0RFX1dJRFRIIC8gMiArIENvbnN0LkJPX0FUVFJfRVZFTlRfV0lEVEggKiAoX2JvQXR0ckV2ZW50TGVuIC0gMSkgLSBwYWRkaW5nLFxyXG4gICAgICAgICAgICAgICAgeTogdGhpcy5fc3RhcnRQb3MueVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAvL+S7juWPs+WQkeW3pueUu++8jFxyXG4gICAgICAgIGZvciAodmFyIGkgPSBfYm9BdHRyRXZlbnRMZW4gLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB0aGlzLl9ncm91cC5hZGQobmV3IEV2ZW50RGVjaXNpb24oX2JvQXR0ckV2ZW50QXJyW2ldLCB7XHJcbiAgICAgICAgICAgICAgICBzdGFydFBvczogX3N0YXJ0UG9zLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2JvQXR0ckV2ZW50JyxcclxuICAgICAgICAgICAgICAgIGNsaWNrYWJsZTogdGhpcy5fZXZlbnRDbGlja2FibGUsXHJcbiAgICAgICAgICAgICAgICBwb3B1cE9wdHM6IHRoaXMuX2V2ZW50UG9wdXBPcHRzLFxyXG4gICAgICAgICAgICAgICAgYmluZEJvQ2xpY2tFdmVudDogbm9kZU9wdGlvbnMuYmluZEJvQ2xpY2tFdmVudFxyXG4gICAgICAgICAgICB9KS5nZXRTaGFwZSgpKTtcclxuICAgICAgICAgICAgX3N0YXJ0UG9zID0ge3g6IF9zdGFydFBvcy54IC0gQ29uc3QuQk9fQVRUUl9FVkVOVF9XSURUSCArIDEwLCB5OiBfc3RhcnRQb3MueX07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qX3N0YXJ0UG9zID0ge1xyXG4gICAgICAgICB4OiB0aGlzLl9zdGFydFBvcy54ICsgQ29uc3QuQk9fTk9ERV9XSURUSCAvIDIsXHJcbiAgICAgICAgIHk6IHRoaXMuX3N0YXJ0UG9zLnl9O1xyXG5cclxuICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfYm9BdHRyRXZlbnRMZW47IGkrKykge1xyXG4gICAgICAgICB0aGlzLl9ncm91cC5hZGQoZXZlbnQuQm9BdHRyRXZlbnQoX2JvQXR0ckV2ZW50QXJyW2ldLCBfc3RhcnRQb3MsIGkgKyAyKSk7XHJcbiAgICAgICAgIF9zdGFydFBvcyA9IHt4OiBfc3RhcnRQb3MueCArIENvbnN0LkJPX0FUVFJfRVZFTlRfV0lEVEggLSA1LCB5OiBfc3RhcnRQb3MueX07XHJcbiAgICAgICAgIH0qL1xyXG5cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQm9BdHRyO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWJvL2xpYi9ub2RlL0JvQXR0ck5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDnlKjmnaXliJvlu7rlhbPogZTlhbPns7tcclxuICog5YWz6IGU5YWz57O75YyF5ous5oqY57q/44CB566t5aS044CB5YWz57O75paH5a2X6K+05piOXHJcbiAqIEBtb2R1bGUgZmlzaC10b3BvLWJvL25vZGUvUmVsYXRpb25cclxuICogQ3JlYXRlZCBieSBtYWppYW5hbiBvbiAxNi81LzE5LlxyXG4gKi9cclxuXHJcbiAgICB2YXIgQ29uc3QgPSByZXF1aXJlKCcuLi9tb2RlbHMvQ29uc3QnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzb3VyY2VTaGFwZSwg5byA5aeL5Zu+5b2iXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0U2hhcGUsIOebruagh+WbvuW9olxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZVRleHQsIOWFs+ezu+W8gOWni+aWh+Wtl+ivtOaYjizlj6/nqbpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXRUZXh0LCDlhbPns7vnu5PmnZ/mloflrZfor7TmmI4s5Y+v56m6XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZVN0eWxlLCDlhbPogZTnur/moLflvI9cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lSG92ZXJTdHlsZSwg5YWz6IGU57q/aG92ZXLmoLflvI9cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcnJvd1N0eWxlLCDlhbPogZTnur/nrq3lpLTmoLflvI9cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcnJvd0hvdmVyU3R5bGUsIOWFs+iBlOe6v+eureWktGhvdmVy5qC35byPXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVsYXRpb24oc291cmNlU2hhcGUsIHRhcmdldFNoYXBlLCBzb3VyY2VUZXh0LCB0YXJnZXRUZXh0LCBsaW5lU3R5bGUsIGxpbmVIb3ZlclN0eWxlLCBhcnJvd1N0eWxlLCBhcnJvd0hvdmVyU3R5bGUpIHtcclxuICAgICAgICB0aGlzLl9zb3VyY2VUZXh0ID0gc291cmNlVGV4dDtcclxuICAgICAgICB0aGlzLl90YXJnZXRUZXh0ID0gdGFyZ2V0VGV4dDtcclxuXHJcbiAgICAgICAgdGhpcy5fZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xyXG5cclxuICAgICAgICAvL+W3puS+p+W8gOWni+S9jee9rlxyXG4gICAgICAgIHRoaXMuX2xTdGFydFBvcyA9IHtcclxuICAgICAgICAgICAgeDogc291cmNlU2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCkueCAtIENvbnN0LkJPX0FUVFJfUEFERElOR19MRUZULFxyXG4gICAgICAgICAgICB5OiBzb3VyY2VTaGFwZS5nZXRCb3VuZGluZ1JlY3QoKS55ICsgc291cmNlU2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0IC8gMlxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8v5bem5L6n57uT5p2f5L2N572uXHJcbiAgICAgICAgdGhpcy5fbEVuZFBvcyA9IHtcclxuICAgICAgICAgICAgeDogdGFyZ2V0U2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCkueCAtIENvbnN0LkJPX0FUVFJfUEFERElOR19MRUZULFxyXG4gICAgICAgICAgICB5OiB0YXJnZXRTaGFwZS5nZXRCb3VuZGluZ1JlY3QoKS55ICsgdGFyZ2V0U2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0IC8gMlxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8v5Y+z5L6n5byA5aeL5L2N572uXHJcbiAgICAgICAgdGhpcy5fclN0YXJ0UG9zID0ge1xyXG4gICAgICAgICAgICB4OiBzb3VyY2VTaGFwZS5nZXRCb3VuZGluZ1JlY3QoKS54ICsgQ29uc3QuQk9fTk9ERV9XSURUSCAtIENvbnN0LkJPX0FUVFJfUEFERElOR19MRUZULFxyXG4gICAgICAgICAgICB5OiBzb3VyY2VTaGFwZS5nZXRCb3VuZGluZ1JlY3QoKS55ICsgc291cmNlU2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0IC8gMlxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8v5Y+z5L6n57uT5p2f5L2N572uXHJcbiAgICAgICAgdGhpcy5fckVuZFBvcyA9IHtcclxuICAgICAgICAgICAgeDogdGFyZ2V0U2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCkueCArIENvbnN0LkJPX05PREVfV0lEVEggLSBDb25zdC5CT19BVFRSX1BBRERJTkdfTEVGVCxcclxuICAgICAgICAgICAgeTogdGFyZ2V0U2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCkueSArIHRhcmdldFNoYXBlLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCAvIDJcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvL+WIpOaWreeUu+e6v+aWueWQkVxyXG4gICAgICAgIHRoaXMuX2xlZnREaXJlY3Rpb24gPSB0aGlzLl9sU3RhcnRQb3MueCAtIHRoaXMuX2xFbmRQb3MueCA8PSAwO1xyXG5cclxuICAgICAgICAvL+WFs+iBlOe6v+agt+W8j1xyXG4gICAgICAgIHRoaXMuX2xpbmVTdHlsZSA9IGxpbmVTdHlsZTtcclxuXHJcbiAgICAgICAgLy/lhbPogZTnur9ob3Zlcuagt+W8j1xyXG4gICAgICAgIHRoaXMuX2xpbmVIb3ZlclN0eWxlID0gbGluZUhvdmVyU3R5bGU7XHJcblxyXG4gICAgICAgIC8v5YWz6IGU57q/566t5aS05qC35byPXHJcbiAgICAgICAgdGhpcy5fYXJyb3dTdHlsZSA9IGFycm93U3R5bGU7XHJcblxyXG4gICAgICAgIC8v5YWz6IGU57q/566t5aS0aG92ZXLmoLflvI9cclxuICAgICAgICB0aGlzLl9hcnJvd0hvdmVyU3R5bGUgPSBhcnJvd0hvdmVyU3R5bGU7XHJcblxyXG4gICAgICAgIC8v55Sf5oiQ5Zu+5b2iXHJcbiAgICAgICAgdGhpcy5fcmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlbGF0aW9uUHJvdG8gPSBSZWxhdGlvbi5wcm90b3R5cGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5blhbPns7vmlbTkvZPlm77lvaJcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICByZWxhdGlvblByb3RvLmdldFNoYXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnlJ/miJDlhbPns7vmlbTkvZPlm77lvaJcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHJlbGF0aW9uUHJvdG8uX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL+eUu+e6v1xyXG4gICAgICAgIHRoaXMuX2NyZWF0ZUxpbmUoKTtcclxuXHJcbiAgICAgICAgLy/nrq3lpLRcclxuICAgICAgICB0aGlzLl9jcmVhdGVBcnJvdygpO1xyXG5cclxuICAgICAgICAvL+WFs+ezu+ivtOaYjuaWh+Wtl1xyXG4gICAgICAgIHRoaXMuX2NyZWF0ZVRleHQoKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog55Sf5oiQ5YWz57O75oqY57q/XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICByZWxhdGlvblByb3RvLl9jcmVhdGVMaW5lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfbGluZVBvaW50cyA9IFtdO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fbGVmdERpcmVjdGlvbikge1xyXG4gICAgICAgICAgICAvL+esrOS4gOeCuVxyXG4gICAgICAgICAgICBfbGluZVBvaW50cy5wdXNoKFt0aGlzLl9sU3RhcnRQb3MueCwgdGhpcy5fbFN0YXJ0UG9zLnldKTtcclxuICAgICAgICAgICAgLy/nrKzkuozngrlcclxuICAgICAgICAgICAgX2xpbmVQb2ludHMucHVzaChbdGhpcy5fbFN0YXJ0UG9zLnggLSBDb25zdC5SRUxBVElPTl9PRkZTRVQsIHRoaXMuX2xTdGFydFBvcy55XSk7XHJcbiAgICAgICAgICAgIC8v56ys5LiJ54K5XHJcbiAgICAgICAgICAgIF9saW5lUG9pbnRzLnB1c2goW3RoaXMuX2xTdGFydFBvcy54IC0gQ29uc3QuUkVMQVRJT05fT0ZGU0VULCB0aGlzLl9sRW5kUG9zLnldKTtcclxuICAgICAgICAgICAgLy/nrKzlm5vngrlcclxuICAgICAgICAgICAgX2xpbmVQb2ludHMucHVzaChbdGhpcy5fbEVuZFBvcy54LCB0aGlzLl9sRW5kUG9zLnldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8v56ys5LiA54K5XHJcbiAgICAgICAgICAgIF9saW5lUG9pbnRzLnB1c2goW3RoaXMuX3JTdGFydFBvcy54LCB0aGlzLl9yU3RhcnRQb3MueV0pO1xyXG4gICAgICAgICAgICAvL+esrOS6jOeCuVxyXG4gICAgICAgICAgICBfbGluZVBvaW50cy5wdXNoKFt0aGlzLl9yU3RhcnRQb3MueCArIENvbnN0LlJFTEFUSU9OX09GRlNFVCwgdGhpcy5fbFN0YXJ0UG9zLnldKTtcclxuICAgICAgICAgICAgLy/nrKzkuInngrlcclxuICAgICAgICAgICAgX2xpbmVQb2ludHMucHVzaChbdGhpcy5fclN0YXJ0UG9zLnggKyBDb25zdC5SRUxBVElPTl9PRkZTRVQsIHRoaXMuX3JFbmRQb3MueV0pO1xyXG4gICAgICAgICAgICAvL+esrOWbm+eCuVxyXG4gICAgICAgICAgICBfbGluZVBvaW50cy5wdXNoKFt0aGlzLl9yRW5kUG9zLngsIHRoaXMuX3JFbmRQb3MueV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIF9saW5lU2hhcGUgPSBuZXcgZ3JhcGhpYy5Qb2x5bGluZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBwb2ludHM6IF9saW5lUG9pbnRzXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgLy9maWxsOiAnYmx1ZScsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IHRoaXMuX2xpbmVTdHlsZS5zdHJva2UsXHJcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHRoaXMuX2xpbmVTdHlsZS5saW5lV2lkdGgsXHJcbiAgICAgICAgICAgICAgICBsaW5lRGFzaDogdGhpcy5fbGluZVN0eWxlLmxpbmVEYXNoXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuX2dyb3VwLmFkZChfbGluZVNoYXBlKTtcclxuXHJcbiAgICAgICAgLy/nur9ob3ZlclxyXG4gICAgICAgIHRoaXMuX2NyZWF0ZUhvdmVyU3R5bGUoX2xpbmVTaGFwZSwgdGhpcy5fbGluZUhvdmVyU3R5bGUpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnlJ/miJDnrq3lpLTlm77lvaJcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHJlbGF0aW9uUHJvdG8uX2NyZWF0ZUFycm93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYXJyb3dQb2ludHMgPSBbXTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2xlZnREaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgLy/lj7PkvqfnrKzkuIDngrlcclxuICAgICAgICAgICAgX2Fycm93UG9pbnRzLnB1c2goW3RoaXMuX2xFbmRQb3MueCwgdGhpcy5fbEVuZFBvcy55XSk7XHJcbiAgICAgICAgICAgIC8v5LiL6Z2i56ys5LqM54K5XHJcbiAgICAgICAgICAgIF9hcnJvd1BvaW50cy5wdXNoKFt0aGlzLl9sRW5kUG9zLnggLSBDb25zdC5SRUxBVElPTl9BUlJPV19XSURUSCwgdGhpcy5fbEVuZFBvcy55ICsgQ29uc3QuUkVMQVRJT05fQVJST1dfSEVJR0hUXSk7XHJcbiAgICAgICAgICAgIC8v5LiK6Z2i56ys5LiJ54K5XHJcbiAgICAgICAgICAgIF9hcnJvd1BvaW50cy5wdXNoKFt0aGlzLl9sRW5kUG9zLnggLSBDb25zdC5SRUxBVElPTl9BUlJPV19XSURUSCwgdGhpcy5fbEVuZFBvcy55IC0gQ29uc3QuUkVMQVRJT05fQVJST1dfSEVJR0hUXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvL+W3puS+p+esrOS4gOeCuVxyXG4gICAgICAgICAgICBfYXJyb3dQb2ludHMucHVzaChbdGhpcy5fckVuZFBvcy54LCB0aGlzLl9yRW5kUG9zLnldKTtcclxuICAgICAgICAgICAgLy/kuIvpnaLnrKzkuozngrlcclxuICAgICAgICAgICAgX2Fycm93UG9pbnRzLnB1c2goW3RoaXMuX3JFbmRQb3MueCArIENvbnN0LlJFTEFUSU9OX0FSUk9XX1dJRFRILCB0aGlzLl9yRW5kUG9zLnkgKyBDb25zdC5SRUxBVElPTl9BUlJPV19IRUlHSFRdKTtcclxuICAgICAgICAgICAgLy/kuIrpnaLnrKzkuInngrlcclxuICAgICAgICAgICAgX2Fycm93UG9pbnRzLnB1c2goW3RoaXMuX3JFbmRQb3MueCArIENvbnN0LlJFTEFUSU9OX0FSUk9XX1dJRFRILCB0aGlzLl9yRW5kUG9zLnkgLSBDb25zdC5SRUxBVElPTl9BUlJPV19IRUlHSFRdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBfYXJyb3dTaGFwZSA9IG5ldyBncmFwaGljLlBvbHlsaW5lKHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIHBvaW50czogX2Fycm93UG9pbnRzXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogdGhpcy5fYXJyb3dTdHlsZS5maWxsLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiB0aGlzLl9hcnJvd1N0eWxlLnN0cm9rZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuX2dyb3VwLmFkZChfYXJyb3dTaGFwZSk7XHJcblxyXG4gICAgICAgIC8v566t5aS0aG92ZXJcclxuICAgICAgICB0aGlzLl9jcmVhdGVIb3ZlclN0eWxlKF9hcnJvd1NoYXBlLCB0aGlzLl9hcnJvd0hvdmVyU3R5bGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOeUn+aIkOaWh+Wtl+ivtOaYjlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgcmVsYXRpb25Qcm90by5fY3JlYXRlVGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3NvdXJjZVRleHRQb3MsXHJcbiAgICAgICAgICAgIF90YXJnZXRUZXh0UG9zLFxyXG4gICAgICAgICAgICBfdGV4dEFsaWduO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fbGVmdERpcmVjdGlvbikge1xyXG4gICAgICAgICAgICBfc291cmNlVGV4dFBvcyA9IFt0aGlzLl9sU3RhcnRQb3MueCAtIDEwLCB0aGlzLl9sU3RhcnRQb3MueSAtIENvbnN0LlJFTEFUSU9OX1RFWFRfT0ZGU0VUX1ldO1xyXG4gICAgICAgICAgICBfdGFyZ2V0VGV4dFBvcyA9IFt0aGlzLl9sRW5kUG9zLnggLSAxMCAtIENvbnN0LlJFTEFUSU9OX0FSUk9XX1dJRFRILCB0aGlzLl9sRW5kUG9zLnkgLSBDb25zdC5SRUxBVElPTl9URVhUX09GRlNFVF9ZXTtcclxuICAgICAgICAgICAgX3RleHRBbGlnbiA9ICdyaWdodCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBfc291cmNlVGV4dFBvcyA9IFt0aGlzLl9yU3RhcnRQb3MueCArIDEwLCB0aGlzLl9yU3RhcnRQb3MueSAtIENvbnN0LlJFTEFUSU9OX1RFWFRfT0ZGU0VUX1ldO1xyXG4gICAgICAgICAgICBfdGFyZ2V0VGV4dFBvcyA9IFt0aGlzLl9yRW5kUG9zLnggKyAxMCArIENvbnN0LlJFTEFUSU9OX0FSUk9XX1dJRFRILCB0aGlzLl9yRW5kUG9zLnkgLSBDb25zdC5SRUxBVElPTl9URVhUX09GRlNFVF9ZXTtcclxuICAgICAgICAgICAgX3RleHRBbGlnbiA9ICdsZWZ0JztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8v5byA5aeL5paH5a2XXHJcbiAgICAgICAgaWYgKHRoaXMuX3NvdXJjZVRleHQpIHtcclxuICAgICAgICAgICAgdmFyIF9zcmNUZXh0U2hhcGUgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBfc291cmNlVGV4dFBvcyxcclxuXHJcbiAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuX3NvdXJjZVRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEZvbnQ6IENvbnN0LkJPX0FUVFJfRk9OVCxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IF90ZXh0QWxpZ24sXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiAnYnV0dG9tJyxcclxuICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDFcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyb3VwLmFkZChfc3JjVGV4dFNoYXBlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8v57uT5p2f5paH5a2XXHJcbiAgICAgICAgaWYgKHRoaXMuX3RhcmdldFRleHQpIHtcclxuICAgICAgICAgICAgdmFyIF90YXJnZXRUZXh0U2hhcGUgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBfdGFyZ2V0VGV4dFBvcyxcclxuXHJcbiAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuX3RhcmdldFRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEZvbnQ6IENvbnN0LkJPX0FUVFJfRk9OVCxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IF90ZXh0QWxpZ24sXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiAnYnV0dG9tJyxcclxuICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDFcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyb3VwLmFkZChfdGFyZ2V0VGV4dFNoYXBlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWFs+iBlOe6v2hvdmVyXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICByZWxhdGlvblByb3RvLl9jcmVhdGVIb3ZlclN0eWxlID0gZnVuY3Rpb24gKGVsLCBzdHlsZSkge1xyXG4gICAgICAgIGlmIChzdHlsZSkge1xyXG4gICAgICAgICAgICBncmFwaGljLnNldEVsZW1lbnRIb3ZlclN0bChlbCwgc3R5bGUpO1xyXG4gICAgICAgICAgICBlbC5vbignbW91c2VvdmVyJywgenJVdGlsLmJpbmQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljLmRvRW50ZXJIb3ZlcihlbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ncm91cC5lYWNoQ2hpbGQoZnVuY3Rpb24obGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMuZG9FbnRlckhvdmVyKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpKVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgenJVdGlsLmJpbmQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljLmRvTGVhdmVIb3ZlcihlbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ncm91cC5lYWNoQ2hpbGQoZnVuY3Rpb24obGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMuZG9MZWF2ZUhvdmVyKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gUmVsYXRpb247XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1iby9saWIvbm9kZS9SZWxhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbiAgICBpZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIC8vIE11c3QgYmUgd3JpdGFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LCBcImFzc2lnblwiLCB7XHJcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCB2YXJBcmdzKSB7IC8vIC5sZW5ndGggb2YgZnVuY3Rpb24gaXMgMlxyXG4gICAgICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsKSB7IC8vIFR5cGVFcnJvciBpZiB1bmRlZmluZWQgb3IgbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0byA9IE9iamVjdCh0YXJnZXQpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFNvdXJjZSAhPSBudWxsKSB7IC8vIFNraXAgb3ZlciBpZiB1bmRlZmluZWQgb3IgbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5leHRLZXkgaW4gbmV4dFNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBidWdzIHdoZW4gaGFzT3duUHJvcGVydHkgaXMgc2hhZG93ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuZXh0U291cmNlLCBuZXh0S2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvb2JqZWN0QXNzaWduUG9seWZpbGwuanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoXCIuL2dyYXBoaWNcIik7XG5cbnZhciBfenJlbmRlciA9IHJlcXVpcmUoXCIuLi96cmVuZGVyXCIpO1xuXG52YXIgcmVnaXN0ZXJQYWludGVyID0gX3pyZW5kZXIucmVnaXN0ZXJQYWludGVyO1xuXG52YXIgUGFpbnRlciA9IHJlcXVpcmUoXCIuL1BhaW50ZXJcIik7XG5cbnJlZ2lzdGVyUGFpbnRlcigndm1sJywgUGFpbnRlcik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL3ZtbC92bWwuanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBlbnYgPSByZXF1aXJlKFwiLi4vY29yZS9lbnZcIik7XG5cbnZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4uL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgYXBwbHlUcmFuc2Zvcm0gPSBfdmVjdG9yLmFwcGx5VHJhbnNmb3JtO1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4uL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgY29sb3JUb29sID0gcmVxdWlyZShcIi4uL3Rvb2wvY29sb3JcIik7XG5cbnZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoXCIuLi9jb250YWluL3RleHRcIik7XG5cbnZhciB0ZXh0SGVscGVyID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvaGVscGVyL3RleHRcIik7XG5cbnZhciBSZWN0VGV4dCA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL21peGluL1JlY3RUZXh0XCIpO1xuXG52YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9EaXNwbGF5YWJsZVwiKTtcblxudmFyIFpJbWFnZSA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL0ltYWdlXCIpO1xuXG52YXIgVGV4dCA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL1RleHRcIik7XG5cbnZhciBQYXRoID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvUGF0aFwiKTtcblxudmFyIFBhdGhQcm94eSA9IHJlcXVpcmUoXCIuLi9jb3JlL1BhdGhQcm94eVwiKTtcblxudmFyIEdyYWRpZW50ID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvR3JhZGllbnRcIik7XG5cbnZhciB2bWxDb3JlID0gcmVxdWlyZShcIi4vY29yZVwiKTtcblxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvTk9URS1WTUxcbi8vIFRPRE8gVXNlIHByb3h5IGxpa2Ugc3ZnIGluc3RlYWQgb2Ygb3ZlcndyaXRlIGJydXNoIG1ldGhvZHNcbnZhciBDTUQgPSBQYXRoUHJveHkuQ01EO1xudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbnZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIGNvcyA9IE1hdGguY29zO1xudmFyIHNpbiA9IE1hdGguc2luO1xudmFyIG1hdGhNYXggPSBNYXRoLm1heDtcblxuaWYgKCFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gIHZhciBjb21tYSA9ICcsJztcbiAgdmFyIGltYWdlVHJhbnNmb3JtUHJlZml4ID0gJ3Byb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdCc7XG4gIHZhciBaID0gMjE2MDA7XG4gIHZhciBaMiA9IFogLyAyO1xuICB2YXIgWkxFVkVMX0JBU0UgPSAxMDAwMDA7XG4gIHZhciBaX0JBU0UgPSAxMDAwO1xuXG4gIHZhciBpbml0Um9vdEVsU3R5bGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICBlbC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MDt3aWR0aDoxcHg7aGVpZ2h0OjFweDsnO1xuICAgIGVsLmNvb3Jkc2l6ZSA9IFogKyAnLCcgKyBaO1xuICAgIGVsLmNvb3Jkb3JpZ2luID0gJzAsMCc7XG4gIH07XG5cbiAgdmFyIGVuY29kZUh0bWxBdHRyaWJ1dGUgPSBmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBTdHJpbmcocykucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG4gIH07XG5cbiAgdmFyIHJnYjJTdHIgPSBmdW5jdGlvbiAociwgZywgYikge1xuICAgIHJldHVybiAncmdiKCcgKyBbciwgZywgYl0uam9pbignLCcpICsgJyknO1xuICB9O1xuXG4gIHZhciBhcHBlbmQgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCkge1xuICAgIGlmIChjaGlsZCAmJiBwYXJlbnQgJiYgY2hpbGQucGFyZW50Tm9kZSAhPT0gcGFyZW50KSB7XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmVtb3ZlID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgJiYgcGFyZW50ICYmIGNoaWxkLnBhcmVudE5vZGUgPT09IHBhcmVudCkge1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldFpJbmRleCA9IGZ1bmN0aW9uICh6bGV2ZWwsIHosIHoyKSB7XG4gICAgLy8geiDnmoTlj5blgLzojIPlm7TkuLogWzAsIDEwMDBdXG4gICAgcmV0dXJuIChwYXJzZUZsb2F0KHpsZXZlbCkgfHwgMCkgKiBaTEVWRUxfQkFTRSArIChwYXJzZUZsb2F0KHopIHx8IDApICogWl9CQVNFICsgejI7XG4gIH07XG5cbiAgdmFyIHBhcnNlUGVyY2VudCA9IGZ1bmN0aW9uICh2YWx1ZSwgbWF4VmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHZhbHVlLmxhc3RJbmRleE9mKCclJykgPj0gMCkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBtYXhWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBQQVRIXG4gICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gIHZhciBzZXRDb2xvckFuZE9wYWNpdHkgPSBmdW5jdGlvbiAoZWwsIGNvbG9yLCBvcGFjaXR5KSB7XG4gICAgdmFyIGNvbG9yQXJyID0gY29sb3JUb29sLnBhcnNlKGNvbG9yKTtcbiAgICBvcGFjaXR5ID0gK29wYWNpdHk7XG5cbiAgICBpZiAoaXNOYU4ob3BhY2l0eSkpIHtcbiAgICAgIG9wYWNpdHkgPSAxO1xuICAgIH1cblxuICAgIGlmIChjb2xvckFycikge1xuICAgICAgZWwuY29sb3IgPSByZ2IyU3RyKGNvbG9yQXJyWzBdLCBjb2xvckFyclsxXSwgY29sb3JBcnJbMl0pO1xuICAgICAgZWwub3BhY2l0eSA9IG9wYWNpdHkgKiBjb2xvckFyclszXTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldENvbG9yQW5kQWxwaGEgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICB2YXIgY29sb3JBcnIgPSBjb2xvclRvb2wucGFyc2UoY29sb3IpO1xuICAgIHJldHVybiBbcmdiMlN0cihjb2xvckFyclswXSwgY29sb3JBcnJbMV0sIGNvbG9yQXJyWzJdKSwgY29sb3JBcnJbM11dO1xuICB9O1xuXG4gIHZhciB1cGRhdGVGaWxsTm9kZSA9IGZ1bmN0aW9uIChlbCwgc3R5bGUsIHpyRWwpIHtcbiAgICAvLyBUT0RPIHBhdHRlcm5cbiAgICB2YXIgZmlsbCA9IHN0eWxlLmZpbGw7XG5cbiAgICBpZiAoZmlsbCAhPSBudWxsKSB7XG4gICAgICAvLyBNb2RpZmllZCBmcm9tIGV4Y2FudmFzXG4gICAgICBpZiAoZmlsbCBpbnN0YW5jZW9mIEdyYWRpZW50KSB7XG4gICAgICAgIHZhciBncmFkaWVudFR5cGU7XG4gICAgICAgIHZhciBhbmdsZSA9IDA7XG4gICAgICAgIHZhciBmb2N1cyA9IFswLCAwXTsgLy8gYWRkaXRpb25hbCBvZmZzZXRcblxuICAgICAgICB2YXIgc2hpZnQgPSAwOyAvLyBzY2FsZSBmYWN0b3IgZm9yIG9mZnNldFxuXG4gICAgICAgIHZhciBleHBhbnNpb24gPSAxO1xuICAgICAgICB2YXIgcmVjdCA9IHpyRWwuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgIHZhciByZWN0V2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgICB2YXIgcmVjdEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuXG4gICAgICAgIGlmIChmaWxsLnR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgZ3JhZGllbnRUeXBlID0gJ2dyYWRpZW50JztcbiAgICAgICAgICB2YXIgdHJhbnNmb3JtID0genJFbC50cmFuc2Zvcm07XG4gICAgICAgICAgdmFyIHAwID0gW2ZpbGwueCAqIHJlY3RXaWR0aCwgZmlsbC55ICogcmVjdEhlaWdodF07XG4gICAgICAgICAgdmFyIHAxID0gW2ZpbGwueDIgKiByZWN0V2lkdGgsIGZpbGwueTIgKiByZWN0SGVpZ2h0XTtcblxuICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAwLCBwMCwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAxLCBwMSwgdHJhbnNmb3JtKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZHggPSBwMVswXSAtIHAwWzBdO1xuICAgICAgICAgIHZhciBkeSA9IHAxWzFdIC0gcDBbMV07XG4gICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKGR4LCBkeSkgKiAxODAgLyBNYXRoLlBJOyAvLyBUaGUgYW5nbGUgc2hvdWxkIGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci5cblxuICAgICAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgICAgIGFuZ2xlICs9IDM2MDtcbiAgICAgICAgICB9IC8vIFZlcnkgc21hbGwgYW5nbGVzIHByb2R1Y2UgYW4gdW5leHBlY3RlZCByZXN1bHQgYmVjYXVzZSB0aGV5IGFyZVxuICAgICAgICAgIC8vIGNvbnZlcnRlZCB0byBhIHNjaWVudGlmaWMgbm90YXRpb24gc3RyaW5nLlxuXG5cbiAgICAgICAgICBpZiAoYW5nbGUgPCAxZS02KSB7XG4gICAgICAgICAgICBhbmdsZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyYWRpZW50VHlwZSA9ICdncmFkaWVudHJhZGlhbCc7XG4gICAgICAgICAgdmFyIHAwID0gW2ZpbGwueCAqIHJlY3RXaWR0aCwgZmlsbC55ICogcmVjdEhlaWdodF07XG4gICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHpyRWwudHJhbnNmb3JtO1xuICAgICAgICAgIHZhciBzY2FsZSA9IHpyRWwuc2NhbGU7XG4gICAgICAgICAgdmFyIHdpZHRoID0gcmVjdFdpZHRoO1xuICAgICAgICAgIHZhciBoZWlnaHQgPSByZWN0SGVpZ2h0O1xuICAgICAgICAgIGZvY3VzID0gWy8vIFBlcmNlbnQgaW4gYm91bmRpbmcgcmVjdFxuICAgICAgICAgIChwMFswXSAtIHJlY3QueCkgLyB3aWR0aCwgKHAwWzFdIC0gcmVjdC55KSAvIGhlaWdodF07XG5cbiAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMCwgcDAsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2lkdGggLz0gc2NhbGVbMF0gKiBaO1xuICAgICAgICAgIGhlaWdodCAvPSBzY2FsZVsxXSAqIFo7XG4gICAgICAgICAgdmFyIGRpbWVuc2lvbiA9IG1hdGhNYXgod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgc2hpZnQgPSAyICogMCAvIGRpbWVuc2lvbjtcbiAgICAgICAgICBleHBhbnNpb24gPSAyICogZmlsbC5yIC8gZGltZW5zaW9uIC0gc2hpZnQ7XG4gICAgICAgIH0gLy8gV2UgbmVlZCB0byBzb3J0IHRoZSBjb2xvciBzdG9wcyBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgb2Zmc2V0LFxuICAgICAgICAvLyBvdGhlcndpc2UgSUUgd29uJ3QgaW50ZXJwcmV0IGl0IGNvcnJlY3RseS5cblxuXG4gICAgICAgIHZhciBzdG9wcyA9IGZpbGwuY29sb3JTdG9wcy5zbGljZSgpO1xuICAgICAgICBzdG9wcy5zb3J0KGZ1bmN0aW9uIChjczEsIGNzMikge1xuICAgICAgICAgIHJldHVybiBjczEub2Zmc2V0IC0gY3MyLm9mZnNldDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsZW5ndGggPSBzdG9wcy5sZW5ndGg7IC8vIENvbG9yIGFuZCBhbHBoYSBsaXN0IG9mIGZpcnN0IGFuZCBsYXN0IHN0b3BcblxuICAgICAgICB2YXIgY29sb3JBbmRBbHBoYUxpc3QgPSBbXTtcbiAgICAgICAgdmFyIGNvbG9ycyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgc3RvcCA9IHN0b3BzW2ldO1xuICAgICAgICAgIHZhciBjb2xvckFuZEFscGhhID0gZ2V0Q29sb3JBbmRBbHBoYShzdG9wLmNvbG9yKTtcbiAgICAgICAgICBjb2xvcnMucHVzaChzdG9wLm9mZnNldCAqIGV4cGFuc2lvbiArIHNoaWZ0ICsgJyAnICsgY29sb3JBbmRBbHBoYVswXSk7XG5cbiAgICAgICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBjb2xvckFuZEFscGhhTGlzdC5wdXNoKGNvbG9yQW5kQWxwaGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGggPj0gMikge1xuICAgICAgICAgIHZhciBjb2xvcjEgPSBjb2xvckFuZEFscGhhTGlzdFswXVswXTtcbiAgICAgICAgICB2YXIgY29sb3IyID0gY29sb3JBbmRBbHBoYUxpc3RbMV1bMF07XG4gICAgICAgICAgdmFyIG9wYWNpdHkxID0gY29sb3JBbmRBbHBoYUxpc3RbMF1bMV0gKiBzdHlsZS5vcGFjaXR5O1xuICAgICAgICAgIHZhciBvcGFjaXR5MiA9IGNvbG9yQW5kQWxwaGFMaXN0WzFdWzFdICogc3R5bGUub3BhY2l0eTtcbiAgICAgICAgICBlbC50eXBlID0gZ3JhZGllbnRUeXBlO1xuICAgICAgICAgIGVsLm1ldGhvZCA9ICdub25lJztcbiAgICAgICAgICBlbC5mb2N1cyA9ICcxMDAlJztcbiAgICAgICAgICBlbC5hbmdsZSA9IGFuZ2xlO1xuICAgICAgICAgIGVsLmNvbG9yID0gY29sb3IxO1xuICAgICAgICAgIGVsLmNvbG9yMiA9IGNvbG9yMjtcbiAgICAgICAgICBlbC5jb2xvcnMgPSBjb2xvcnMuam9pbignLCcpOyAvLyBXaGVuIGNvbG9ycyBhdHRyaWJ1dGUgaXMgdXNlZCwgdGhlIG1lYW5pbmdzIG9mIG9wYWNpdHkgYW5kIG86b3BhY2l0eTJcbiAgICAgICAgICAvLyBhcmUgcmV2ZXJzZWQuXG5cbiAgICAgICAgICBlbC5vcGFjaXR5ID0gb3BhY2l0eTI7IC8vIEZJWE1FIGdfb186b3BhY2l0eSA/XG5cbiAgICAgICAgICBlbC5vcGFjaXR5MiA9IG9wYWNpdHkxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdyYWRpZW50VHlwZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgICBlbC5mb2N1c3Bvc2l0aW9uID0gZm9jdXMuam9pbignLCcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGSVhNRSBDaGFuZ2UgZnJvbSBHcmFkaWVudCBmaWxsIHRvIGNvbG9yIGZpbGxcbiAgICAgICAgc2V0Q29sb3JBbmRPcGFjaXR5KGVsLCBmaWxsLCBzdHlsZS5vcGFjaXR5KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHVwZGF0ZVN0cm9rZU5vZGUgPSBmdW5jdGlvbiAoZWwsIHN0eWxlKSB7XG4gICAgLy8gaWYgKHN0eWxlLmxpbmVKb2luICE9IG51bGwpIHtcbiAgICAvLyAgICAgZWwuam9pbnN0eWxlID0gc3R5bGUubGluZUpvaW47XG4gICAgLy8gfVxuICAgIC8vIGlmIChzdHlsZS5taXRlckxpbWl0ICE9IG51bGwpIHtcbiAgICAvLyAgICAgZWwubWl0ZXJsaW1pdCA9IHN0eWxlLm1pdGVyTGltaXQgKiBaO1xuICAgIC8vIH1cbiAgICAvLyBpZiAoc3R5bGUubGluZUNhcCAhPSBudWxsKSB7XG4gICAgLy8gICAgIGVsLmVuZGNhcCA9IHN0eWxlLmxpbmVDYXA7XG4gICAgLy8gfVxuICAgIGlmIChzdHlsZS5saW5lRGFzaCAhPSBudWxsKSB7XG4gICAgICBlbC5kYXNoc3R5bGUgPSBzdHlsZS5saW5lRGFzaC5qb2luKCcgJyk7XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlLnN0cm9rZSAhPSBudWxsICYmICEoc3R5bGUuc3Ryb2tlIGluc3RhbmNlb2YgR3JhZGllbnQpKSB7XG4gICAgICBzZXRDb2xvckFuZE9wYWNpdHkoZWwsIHN0eWxlLnN0cm9rZSwgc3R5bGUub3BhY2l0eSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciB1cGRhdGVGaWxsQW5kU3Ryb2tlID0gZnVuY3Rpb24gKHZtbEVsLCB0eXBlLCBzdHlsZSwgenJFbCkge1xuICAgIHZhciBpc0ZpbGwgPSB0eXBlID09ICdmaWxsJztcbiAgICB2YXIgZWwgPSB2bWxFbC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0eXBlKVswXTsgLy8gU3Ryb2tlIG11c3QgaGF2ZSBsaW5lV2lkdGhcblxuICAgIGlmIChzdHlsZVt0eXBlXSAhPSBudWxsICYmIHN0eWxlW3R5cGVdICE9PSAnbm9uZScgJiYgKGlzRmlsbCB8fCAhaXNGaWxsICYmIHN0eWxlLmxpbmVXaWR0aCkpIHtcbiAgICAgIHZtbEVsW2lzRmlsbCA/ICdmaWxsZWQnIDogJ3N0cm9rZWQnXSA9ICd0cnVlJzsgLy8gRklYTUUgUmVtb3ZlIGJlZm9yZSB1cGRhdGluZywgb3Igc2V0IGBjb2xvcnNgIHdpbGwgdGhyb3cgZXJyb3JcblxuICAgICAgaWYgKHN0eWxlW3R5cGVdIGluc3RhbmNlb2YgR3JhZGllbnQpIHtcbiAgICAgICAgcmVtb3ZlKHZtbEVsLCBlbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZWwpIHtcbiAgICAgICAgZWwgPSB2bWxDb3JlLmNyZWF0ZU5vZGUodHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGlzRmlsbCA/IHVwZGF0ZUZpbGxOb2RlKGVsLCBzdHlsZSwgenJFbCkgOiB1cGRhdGVTdHJva2VOb2RlKGVsLCBzdHlsZSk7XG4gICAgICBhcHBlbmQodm1sRWwsIGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm1sRWxbaXNGaWxsID8gJ2ZpbGxlZCcgOiAnc3Ryb2tlZCddID0gJ2ZhbHNlJztcbiAgICAgIHJlbW92ZSh2bWxFbCwgZWwpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcG9pbnRzID0gW1tdLCBbXSwgW11dO1xuXG4gIHZhciBwYXRoRGF0YVRvU3RyaW5nID0gZnVuY3Rpb24gKHBhdGgsIG0pIHtcbiAgICB2YXIgTSA9IENNRC5NO1xuICAgIHZhciBDID0gQ01ELkM7XG4gICAgdmFyIEwgPSBDTUQuTDtcbiAgICB2YXIgQSA9IENNRC5BO1xuICAgIHZhciBRID0gQ01ELlE7XG4gICAgdmFyIHN0ciA9IFtdO1xuICAgIHZhciBuUG9pbnQ7XG4gICAgdmFyIGNtZFN0cjtcbiAgICB2YXIgY21kO1xuICAgIHZhciBpO1xuICAgIHZhciB4aTtcbiAgICB2YXIgeWk7XG4gICAgdmFyIGRhdGEgPSBwYXRoLmRhdGE7XG4gICAgdmFyIGRhdGFMZW5ndGggPSBwYXRoLmxlbigpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7KSB7XG4gICAgICBjbWQgPSBkYXRhW2krK107XG4gICAgICBjbWRTdHIgPSAnJztcbiAgICAgIG5Qb2ludCA9IDA7XG5cbiAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgIGNhc2UgTTpcbiAgICAgICAgICBjbWRTdHIgPSAnIG0gJztcbiAgICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHBvaW50c1swXVswXSA9IHhpO1xuICAgICAgICAgIHBvaW50c1swXVsxXSA9IHlpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgTDpcbiAgICAgICAgICBjbWRTdHIgPSAnIGwgJztcbiAgICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHBvaW50c1swXVswXSA9IHhpO1xuICAgICAgICAgIHBvaW50c1swXVsxXSA9IHlpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUTpcbiAgICAgICAgY2FzZSBDOlxuICAgICAgICAgIGNtZFN0ciA9ICcgYyAnO1xuICAgICAgICAgIG5Qb2ludCA9IDM7XG4gICAgICAgICAgdmFyIHgxID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciB5MSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgeDIgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHkyID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciB4MztcbiAgICAgICAgICB2YXIgeTM7XG5cbiAgICAgICAgICBpZiAoY21kID09PSBRKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHF1YWRyYXRpYyB0byBjdWJpYyB1c2luZyBkZWdyZWUgZWxldmF0aW9uXG4gICAgICAgICAgICB4MyA9IHgyO1xuICAgICAgICAgICAgeTMgPSB5MjtcbiAgICAgICAgICAgIHgyID0gKHgyICsgMiAqIHgxKSAvIDM7XG4gICAgICAgICAgICB5MiA9ICh5MiArIDIgKiB5MSkgLyAzO1xuICAgICAgICAgICAgeDEgPSAoeGkgKyAyICogeDEpIC8gMztcbiAgICAgICAgICAgIHkxID0gKHlpICsgMiAqIHkxKSAvIDM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHgzID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgeTMgPSBkYXRhW2krK107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcG9pbnRzWzBdWzBdID0geDE7XG4gICAgICAgICAgcG9pbnRzWzBdWzFdID0geTE7XG4gICAgICAgICAgcG9pbnRzWzFdWzBdID0geDI7XG4gICAgICAgICAgcG9pbnRzWzFdWzFdID0geTI7XG4gICAgICAgICAgcG9pbnRzWzJdWzBdID0geDM7XG4gICAgICAgICAgcG9pbnRzWzJdWzFdID0geTM7XG4gICAgICAgICAgeGkgPSB4MztcbiAgICAgICAgICB5aSA9IHkzO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQTpcbiAgICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgICAgdmFyIHkgPSAwO1xuICAgICAgICAgIHZhciBzeCA9IDE7XG4gICAgICAgICAgdmFyIHN5ID0gMTtcbiAgICAgICAgICB2YXIgYW5nbGUgPSAwO1xuXG4gICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgU1JUIGZyb20gbWF0cml4XG4gICAgICAgICAgICB4ID0gbVs0XTtcbiAgICAgICAgICAgIHkgPSBtWzVdO1xuICAgICAgICAgICAgc3ggPSBzcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0pO1xuICAgICAgICAgICAgc3kgPSBzcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKC1tWzFdIC8gc3ksIG1bMF0gLyBzeCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGN4ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgcnggPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHJ5ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gZGF0YVtpKytdICsgYW5nbGU7XG4gICAgICAgICAgdmFyIGVuZEFuZ2xlID0gZGF0YVtpKytdICsgc3RhcnRBbmdsZSArIGFuZ2xlOyAvLyBGSVhNRVxuICAgICAgICAgIC8vIHZhciBwc2kgPSBkYXRhW2krK107XG5cbiAgICAgICAgICBpKys7XG4gICAgICAgICAgdmFyIGNsb2Nrd2lzZSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgeDAgPSBjeCArIGNvcyhzdGFydEFuZ2xlKSAqIHJ4O1xuICAgICAgICAgIHZhciB5MCA9IGN5ICsgc2luKHN0YXJ0QW5nbGUpICogcnk7XG4gICAgICAgICAgdmFyIHgxID0gY3ggKyBjb3MoZW5kQW5nbGUpICogcng7XG4gICAgICAgICAgdmFyIHkxID0gY3kgKyBzaW4oZW5kQW5nbGUpICogcnk7XG4gICAgICAgICAgdmFyIHR5cGUgPSBjbG9ja3dpc2UgPyAnIHdhICcgOiAnIGF0ICc7XG5cbiAgICAgICAgICBpZiAoTWF0aC5hYnMoeDAgLSB4MSkgPCAxZS00KSB7XG4gICAgICAgICAgICAvLyBJRSB3b24ndCByZW5kZXIgYXJjaGVzIGRyYXduIGNvdW50ZXIgY2xvY2t3aXNlIGlmIHgwID09IHgxLlxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgPiAxZS0yKSB7XG4gICAgICAgICAgICAgIC8vIE9mZnNldCB4MCBieSAxLzgwIG9mIGEgcGl4ZWwuIFVzZSBzb21ldGhpbmdcbiAgICAgICAgICAgICAgLy8gdGhhdCBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gYmluYXJ5XG4gICAgICAgICAgICAgIGlmIChjbG9ja3dpc2UpIHtcbiAgICAgICAgICAgICAgICB4MCArPSAyNzAgLyBaO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBBdm9pZCBjYXNlIGRyYXcgZnVsbCBjaXJjbGVcbiAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHkwIC0gY3kpIDwgMWUtNCkge1xuICAgICAgICAgICAgICAgIGlmIChjbG9ja3dpc2UgJiYgeDAgPCBjeCB8fCAhY2xvY2t3aXNlICYmIHgwID4gY3gpIHtcbiAgICAgICAgICAgICAgICAgIHkxIC09IDI3MCAvIFo7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHkxICs9IDI3MCAvIFo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNsb2Nrd2lzZSAmJiB5MCA8IGN5IHx8ICFjbG9ja3dpc2UgJiYgeTAgPiBjeSkge1xuICAgICAgICAgICAgICAgIHgxICs9IDI3MCAvIFo7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeDEgLT0gMjcwIC8gWjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0ci5wdXNoKHR5cGUsIHJvdW5kKCgoY3ggLSByeCkgKiBzeCArIHgpICogWiAtIFoyKSwgY29tbWEsIHJvdW5kKCgoY3kgLSByeSkgKiBzeSArIHkpICogWiAtIFoyKSwgY29tbWEsIHJvdW5kKCgoY3ggKyByeCkgKiBzeCArIHgpICogWiAtIFoyKSwgY29tbWEsIHJvdW5kKCgoY3kgKyByeSkgKiBzeSArIHkpICogWiAtIFoyKSwgY29tbWEsIHJvdW5kKCh4MCAqIHN4ICsgeCkgKiBaIC0gWjIpLCBjb21tYSwgcm91bmQoKHkwICogc3kgKyB5KSAqIFogLSBaMiksIGNvbW1hLCByb3VuZCgoeDEgKiBzeCArIHgpICogWiAtIFoyKSwgY29tbWEsIHJvdW5kKCh5MSAqIHN5ICsgeSkgKiBaIC0gWjIpKTtcbiAgICAgICAgICB4aSA9IHgxO1xuICAgICAgICAgIHlpID0geTE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICB2YXIgcDAgPSBwb2ludHNbMF07XG4gICAgICAgICAgdmFyIHAxID0gcG9pbnRzWzFdOyAvLyB4MCwgeTBcblxuICAgICAgICAgIHAwWzBdID0gZGF0YVtpKytdO1xuICAgICAgICAgIHAwWzFdID0gZGF0YVtpKytdOyAvLyB4MSwgeTFcblxuICAgICAgICAgIHAxWzBdID0gcDBbMF0gKyBkYXRhW2krK107XG4gICAgICAgICAgcDFbMV0gPSBwMFsxXSArIGRhdGFbaSsrXTtcblxuICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMCwgcDAsIG0pO1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDEsIHAxLCBtKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwMFswXSA9IHJvdW5kKHAwWzBdICogWiAtIFoyKTtcbiAgICAgICAgICBwMVswXSA9IHJvdW5kKHAxWzBdICogWiAtIFoyKTtcbiAgICAgICAgICBwMFsxXSA9IHJvdW5kKHAwWzFdICogWiAtIFoyKTtcbiAgICAgICAgICBwMVsxXSA9IHJvdW5kKHAxWzFdICogWiAtIFoyKTtcbiAgICAgICAgICBzdHIucHVzaCggLy8geDAsIHkwXG4gICAgICAgICAgJyBtICcsIHAwWzBdLCBjb21tYSwgcDBbMV0sIC8vIHgxLCB5MFxuICAgICAgICAgICcgbCAnLCBwMVswXSwgY29tbWEsIHAwWzFdLCAvLyB4MSwgeTFcbiAgICAgICAgICAnIGwgJywgcDFbMF0sIGNvbW1hLCBwMVsxXSwgLy8geDAsIHkxXG4gICAgICAgICAgJyBsICcsIHAwWzBdLCBjb21tYSwgcDFbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgICAgLy8gRklYTUUgVXBkYXRlIHhpLCB5aVxuICAgICAgICAgIHN0ci5wdXNoKCcgeCAnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5Qb2ludCA+IDApIHtcbiAgICAgICAgc3RyLnB1c2goY21kU3RyKTtcblxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG5Qb2ludDsgaysrKSB7XG4gICAgICAgICAgdmFyIHAgPSBwb2ludHNba107XG4gICAgICAgICAgbSAmJiBhcHBseVRyYW5zZm9ybShwLCBwLCBtKTsgLy8g5LiNIHJvdW5kIOS8mumdnuW4uOaFolxuXG4gICAgICAgICAgc3RyLnB1c2gocm91bmQocFswXSAqIFogLSBaMiksIGNvbW1hLCByb3VuZChwWzFdICogWiAtIFoyKSwgayA8IG5Qb2ludCAtIDEgPyBjb21tYSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHIuam9pbignJyk7XG4gIH07IC8vIFJld3JpdGUgdGhlIG9yaWdpbmFsIHBhdGggbWV0aG9kXG5cblxuICBQYXRoLnByb3RvdHlwZS5icnVzaFZNTCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgdm1sRWwgPSB0aGlzLl92bWxFbDtcblxuICAgIGlmICghdm1sRWwpIHtcbiAgICAgIHZtbEVsID0gdm1sQ29yZS5jcmVhdGVOb2RlKCdzaGFwZScpO1xuICAgICAgaW5pdFJvb3RFbFN0eWxlKHZtbEVsKTtcbiAgICAgIHRoaXMuX3ZtbEVsID0gdm1sRWw7XG4gICAgfVxuXG4gICAgdXBkYXRlRmlsbEFuZFN0cm9rZSh2bWxFbCwgJ2ZpbGwnLCBzdHlsZSwgdGhpcyk7XG4gICAgdXBkYXRlRmlsbEFuZFN0cm9rZSh2bWxFbCwgJ3N0cm9rZScsIHN0eWxlLCB0aGlzKTtcbiAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgIHZhciBuZWVkVHJhbnNmb3JtID0gbSAhPSBudWxsO1xuICAgIHZhciBzdHJva2VFbCA9IHZtbEVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzdHJva2UnKVswXTtcblxuICAgIGlmIChzdHJva2VFbCkge1xuICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDsgLy8gR2V0IHRoZSBsaW5lIHNjYWxlLlxuICAgICAgLy8gRGV0ZXJtaW5hbnQgb2YgdGhpcy5tXyBtZWFucyBob3cgbXVjaCB0aGUgYXJlYSBpcyBlbmxhcmdlZCBieSB0aGVcbiAgICAgIC8vIHRyYW5zZm9ybWF0aW9uLiBTbyBpdHMgc3F1YXJlIHJvb3QgY2FuIGJlIHVzZWQgYXMgYSBzY2FsZSBmYWN0b3JcbiAgICAgIC8vIGZvciB3aWR0aC5cblxuICAgICAgaWYgKG5lZWRUcmFuc2Zvcm0gJiYgIXN0eWxlLnN0cm9rZU5vU2NhbGUpIHtcbiAgICAgICAgdmFyIGRldCA9IG1bMF0gKiBtWzNdIC0gbVsxXSAqIG1bMl07XG4gICAgICAgIGxpbmVXaWR0aCAqPSBzcXJ0KGFicyhkZXQpKTtcbiAgICAgIH1cblxuICAgICAgc3Ryb2tlRWwud2VpZ2h0ID0gbGluZVdpZHRoICsgJ3B4JztcbiAgICB9XG5cbiAgICB2YXIgcGF0aCA9IHRoaXMucGF0aCB8fCAodGhpcy5wYXRoID0gbmV3IFBhdGhQcm94eSgpKTtcblxuICAgIGlmICh0aGlzLl9fZGlydHlQYXRoKSB7XG4gICAgICBwYXRoLmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSk7XG4gICAgICBwYXRoLnRvU3RhdGljKCk7XG4gICAgICB0aGlzLl9fZGlydHlQYXRoID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdm1sRWwucGF0aCA9IHBhdGhEYXRhVG9TdHJpbmcocGF0aCwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIHZtbEVsLnN0eWxlLnpJbmRleCA9IGdldFpJbmRleCh0aGlzLnpsZXZlbCwgdGhpcy56LCB0aGlzLnoyKTsgLy8gQXBwZW5kIHRvIHJvb3RcblxuICAgIGFwcGVuZCh2bWxSb290LCB2bWxFbCk7IC8vIFRleHRcblxuICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KHZtbFJvb3QsIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZVJlY3RUZXh0KHZtbFJvb3QpO1xuICAgIH1cbiAgfTtcblxuICBQYXRoLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgcmVtb3ZlKHZtbFJvb3QsIHRoaXMuX3ZtbEVsKTtcbiAgICB0aGlzLnJlbW92ZVJlY3RUZXh0KHZtbFJvb3QpO1xuICB9O1xuXG4gIFBhdGgucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICBhcHBlbmQodm1sUm9vdCwgdGhpcy5fdm1sRWwpO1xuICAgIHRoaXMuYXBwZW5kUmVjdFRleHQodm1sUm9vdCk7XG4gIH07XG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICogSU1BR0VcbiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgdmFyIGlzSW1hZ2UgPSBmdW5jdGlvbiAoaW1nKSB7XG4gICAgLy8gRklYTUUgaW1nIGluc3RhbmNlb2YgSW1hZ2Ug5aaC5p6cIGltZyDmmK/kuIDkuKrlrZfnrKbkuLLnmoTml7blgJnvvIxJRTgg5LiL5Lya5oql6ZSZXG4gICAgcmV0dXJuIHR5cGVvZiBpbWcgPT09ICdvYmplY3QnICYmIGltZy50YWdOYW1lICYmIGltZy50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdJTUcnOyAvLyByZXR1cm4gaW1nIGluc3RhbmNlb2YgSW1hZ2U7XG4gIH07IC8vIFJld3JpdGUgdGhlIG9yaWdpbmFsIHBhdGggbWV0aG9kXG5cblxuICBaSW1hZ2UucHJvdG90eXBlLmJydXNoVk1MID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHZhciBpbWFnZSA9IHN0eWxlLmltYWdlOyAvLyBJbWFnZSBvcmlnaW5hbCB3aWR0aCwgaGVpZ2h0XG5cbiAgICB2YXIgb3c7XG4gICAgdmFyIG9oO1xuXG4gICAgaWYgKGlzSW1hZ2UoaW1hZ2UpKSB7XG4gICAgICB2YXIgc3JjID0gaW1hZ2Uuc3JjO1xuXG4gICAgICBpZiAoc3JjID09PSB0aGlzLl9pbWFnZVNyYykge1xuICAgICAgICBvdyA9IHRoaXMuX2ltYWdlV2lkdGg7XG4gICAgICAgIG9oID0gdGhpcy5faW1hZ2VIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaW1hZ2VSdW50aW1lU3R5bGUgPSBpbWFnZS5ydW50aW1lU3R5bGU7XG4gICAgICAgIHZhciBvbGRSdW50aW1lV2lkdGggPSBpbWFnZVJ1bnRpbWVTdHlsZS53aWR0aDtcbiAgICAgICAgdmFyIG9sZFJ1bnRpbWVIZWlnaHQgPSBpbWFnZVJ1bnRpbWVTdHlsZS5oZWlnaHQ7XG4gICAgICAgIGltYWdlUnVudGltZVN0eWxlLndpZHRoID0gJ2F1dG8nO1xuICAgICAgICBpbWFnZVJ1bnRpbWVTdHlsZS5oZWlnaHQgPSAnYXV0byc7IC8vIGdldCB0aGUgb3JpZ2luYWwgc2l6ZVxuXG4gICAgICAgIG93ID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgIG9oID0gaW1hZ2UuaGVpZ2h0OyAvLyBhbmQgcmVtb3ZlIG92ZXJpZGVzXG5cbiAgICAgICAgaW1hZ2VSdW50aW1lU3R5bGUud2lkdGggPSBvbGRSdW50aW1lV2lkdGg7XG4gICAgICAgIGltYWdlUnVudGltZVN0eWxlLmhlaWdodCA9IG9sZFJ1bnRpbWVIZWlnaHQ7IC8vIENhY2hpbmcgaW1hZ2Ugb3JpZ2luYWwgd2lkdGgsIGhlaWdodCBhbmQgc3JjXG5cbiAgICAgICAgdGhpcy5faW1hZ2VTcmMgPSBzcmM7XG4gICAgICAgIHRoaXMuX2ltYWdlV2lkdGggPSBvdztcbiAgICAgICAgdGhpcy5faW1hZ2VIZWlnaHQgPSBvaDtcbiAgICAgIH1cblxuICAgICAgaW1hZ2UgPSBzcmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpbWFnZSA9PT0gdGhpcy5faW1hZ2VTcmMpIHtcbiAgICAgICAgb3cgPSB0aGlzLl9pbWFnZVdpZHRoO1xuICAgICAgICBvaCA9IHRoaXMuX2ltYWdlSGVpZ2h0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaW1hZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgeCA9IHN0eWxlLnggfHwgMDtcbiAgICB2YXIgeSA9IHN0eWxlLnkgfHwgMDtcbiAgICB2YXIgZHcgPSBzdHlsZS53aWR0aDtcbiAgICB2YXIgZGggPSBzdHlsZS5oZWlnaHQ7XG4gICAgdmFyIHN3ID0gc3R5bGUuc1dpZHRoO1xuICAgIHZhciBzaCA9IHN0eWxlLnNIZWlnaHQ7XG4gICAgdmFyIHN4ID0gc3R5bGUuc3ggfHwgMDtcbiAgICB2YXIgc3kgPSBzdHlsZS5zeSB8fCAwO1xuICAgIHZhciBoYXNDcm9wID0gc3cgJiYgc2g7XG4gICAgdmFyIHZtbEVsID0gdGhpcy5fdm1sRWw7XG5cbiAgICBpZiAoIXZtbEVsKSB7XG4gICAgICAvLyBGSVhNRSDkvb/nlKggZ3JvdXAg5ZyoIGxlZnQsIHRvcCDpg73kuI3mmK8gMCDnmoTml7blgJnlsLHml6Dms5XmmL7npLrkuobjgIJcbiAgICAgIC8vIHZtbEVsID0gdm1sQ29yZS5jcmVhdGVOb2RlKCdncm91cCcpO1xuICAgICAgdm1sRWwgPSB2bWxDb3JlLmRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGluaXRSb290RWxTdHlsZSh2bWxFbCk7XG4gICAgICB0aGlzLl92bWxFbCA9IHZtbEVsO1xuICAgIH1cblxuICAgIHZhciB2bWxFbFN0eWxlID0gdm1sRWwuc3R5bGU7XG4gICAgdmFyIGhhc1JvdGF0aW9uID0gZmFsc2U7XG4gICAgdmFyIG07XG4gICAgdmFyIHNjYWxlWCA9IDE7XG4gICAgdmFyIHNjYWxlWSA9IDE7XG5cbiAgICBpZiAodGhpcy50cmFuc2Zvcm0pIHtcbiAgICAgIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgIHNjYWxlWCA9IHNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gICAgICBzY2FsZVkgPSBzcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuICAgICAgaGFzUm90YXRpb24gPSBtWzFdIHx8IG1bMl07XG4gICAgfVxuXG4gICAgaWYgKGhhc1JvdGF0aW9uKSB7XG4gICAgICAvLyBJZiBmaWx0ZXJzIGFyZSBuZWNlc3NhcnkgKHJvdGF0aW9uIGV4aXN0cyksIGNyZWF0ZSB0aGVtXG4gICAgICAvLyBmaWx0ZXJzIGFyZSBib2ctc2xvdywgc28gb25seSBjcmVhdGUgdGhlbSBpZiBhYmJzb2x1dGVseSBuZWNlc3NhcnlcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY2hlY2sgZG9lc24ndCBhY2NvdW50IGZvciBza2V3cyAod2hpY2ggZG9uJ3QgZXhpc3RcbiAgICAgIC8vIGluIHRoZSBjYW52YXMgc3BlYyAoeWV0KSBhbnl3YXkuXG4gICAgICAvLyBGcm9tIGV4Y2FudmFzXG4gICAgICB2YXIgcDAgPSBbeCwgeV07XG4gICAgICB2YXIgcDEgPSBbeCArIGR3LCB5XTtcbiAgICAgIHZhciBwMiA9IFt4LCB5ICsgZGhdO1xuICAgICAgdmFyIHAzID0gW3ggKyBkdywgeSArIGRoXTtcbiAgICAgIGFwcGx5VHJhbnNmb3JtKHAwLCBwMCwgbSk7XG4gICAgICBhcHBseVRyYW5zZm9ybShwMSwgcDEsIG0pO1xuICAgICAgYXBwbHlUcmFuc2Zvcm0ocDIsIHAyLCBtKTtcbiAgICAgIGFwcGx5VHJhbnNmb3JtKHAzLCBwMywgbSk7XG4gICAgICB2YXIgbWF4WCA9IG1hdGhNYXgocDBbMF0sIHAxWzBdLCBwMlswXSwgcDNbMF0pO1xuICAgICAgdmFyIG1heFkgPSBtYXRoTWF4KHAwWzFdLCBwMVsxXSwgcDJbMV0sIHAzWzFdKTtcbiAgICAgIHZhciB0cmFuc2Zvcm1GaWx0ZXIgPSBbXTtcbiAgICAgIHRyYW5zZm9ybUZpbHRlci5wdXNoKCdNMTE9JywgbVswXSAvIHNjYWxlWCwgY29tbWEsICdNMTI9JywgbVsyXSAvIHNjYWxlWSwgY29tbWEsICdNMjE9JywgbVsxXSAvIHNjYWxlWCwgY29tbWEsICdNMjI9JywgbVszXSAvIHNjYWxlWSwgY29tbWEsICdEeD0nLCByb3VuZCh4ICogc2NhbGVYICsgbVs0XSksIGNvbW1hLCAnRHk9Jywgcm91bmQoeSAqIHNjYWxlWSArIG1bNV0pKTtcbiAgICAgIHZtbEVsU3R5bGUucGFkZGluZyA9ICcwICcgKyByb3VuZChtYXhYKSArICdweCAnICsgcm91bmQobWF4WSkgKyAncHggMCc7IC8vIEZJWE1FIERYSW1hZ2VUcmFuc2Zvcm0g5ZyoIElFMTEg55qE5YW85a655qih5byP5LiL5LiN6LW35L2c55SoXG5cbiAgICAgIHZtbEVsU3R5bGUuZmlsdGVyID0gaW1hZ2VUcmFuc2Zvcm1QcmVmaXggKyAnLk1hdHJpeCgnICsgdHJhbnNmb3JtRmlsdGVyLmpvaW4oJycpICsgJywgU2l6aW5nTWV0aG9kPWNsaXApJztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG0pIHtcbiAgICAgICAgeCA9IHggKiBzY2FsZVggKyBtWzRdO1xuICAgICAgICB5ID0geSAqIHNjYWxlWSArIG1bNV07XG4gICAgICB9XG5cbiAgICAgIHZtbEVsU3R5bGUuZmlsdGVyID0gJyc7XG4gICAgICB2bWxFbFN0eWxlLmxlZnQgPSByb3VuZCh4KSArICdweCc7XG4gICAgICB2bWxFbFN0eWxlLnRvcCA9IHJvdW5kKHkpICsgJ3B4JztcbiAgICB9XG5cbiAgICB2YXIgaW1hZ2VFbCA9IHRoaXMuX2ltYWdlRWw7XG4gICAgdmFyIGNyb3BFbCA9IHRoaXMuX2Nyb3BFbDtcblxuICAgIGlmICghaW1hZ2VFbCkge1xuICAgICAgaW1hZ2VFbCA9IHZtbENvcmUuZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5faW1hZ2VFbCA9IGltYWdlRWw7XG4gICAgfVxuXG4gICAgdmFyIGltYWdlRUxTdHlsZSA9IGltYWdlRWwuc3R5bGU7XG5cbiAgICBpZiAoaGFzQ3JvcCkge1xuICAgICAgLy8gTmVlZHMga25vdyBpbWFnZSBvcmlnaW5hbCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICBpZiAoIShvdyAmJiBvaCkpIHtcbiAgICAgICAgdmFyIHRtcEltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB0bXBJbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdG1wSW1hZ2Uub25sb2FkID0gbnVsbDtcbiAgICAgICAgICBvdyA9IHRtcEltYWdlLndpZHRoO1xuICAgICAgICAgIG9oID0gdG1wSW1hZ2UuaGVpZ2h0OyAvLyBBZGp1c3QgaW1hZ2Ugd2lkdGggYW5kIGhlaWdodCB0byBmaXQgdGhlIHJhdGlvIGRlc3RpbmF0aW9uU2l6ZSAvIHNvdXJjZVNpemVcblxuICAgICAgICAgIGltYWdlRUxTdHlsZS53aWR0aCA9IHJvdW5kKHNjYWxlWCAqIG93ICogZHcgLyBzdykgKyAncHgnO1xuICAgICAgICAgIGltYWdlRUxTdHlsZS5oZWlnaHQgPSByb3VuZChzY2FsZVkgKiBvaCAqIGRoIC8gc2gpICsgJ3B4JzsgLy8gQ2FjaGluZyBpbWFnZSBvcmlnaW5hbCB3aWR0aCwgaGVpZ2h0IGFuZCBzcmNcblxuICAgICAgICAgIHNlbGYuX2ltYWdlV2lkdGggPSBvdztcbiAgICAgICAgICBzZWxmLl9pbWFnZUhlaWdodCA9IG9oO1xuICAgICAgICAgIHNlbGYuX2ltYWdlU3JjID0gaW1hZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgdG1wSW1hZ2Uuc3JjID0gaW1hZ2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbWFnZUVMU3R5bGUud2lkdGggPSByb3VuZChzY2FsZVggKiBvdyAqIGR3IC8gc3cpICsgJ3B4JztcbiAgICAgICAgaW1hZ2VFTFN0eWxlLmhlaWdodCA9IHJvdW5kKHNjYWxlWSAqIG9oICogZGggLyBzaCkgKyAncHgnO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNyb3BFbCkge1xuICAgICAgICBjcm9wRWwgPSB2bWxDb3JlLmRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY3JvcEVsLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgIHRoaXMuX2Nyb3BFbCA9IGNyb3BFbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNyb3BFbFN0eWxlID0gY3JvcEVsLnN0eWxlO1xuICAgICAgY3JvcEVsU3R5bGUud2lkdGggPSByb3VuZCgoZHcgKyBzeCAqIGR3IC8gc3cpICogc2NhbGVYKTtcbiAgICAgIGNyb3BFbFN0eWxlLmhlaWdodCA9IHJvdW5kKChkaCArIHN5ICogZGggLyBzaCkgKiBzY2FsZVkpO1xuICAgICAgY3JvcEVsU3R5bGUuZmlsdGVyID0gaW1hZ2VUcmFuc2Zvcm1QcmVmaXggKyAnLk1hdHJpeChEeD0nICsgLXN4ICogZHcgLyBzdyAqIHNjYWxlWCArICcsRHk9JyArIC1zeSAqIGRoIC8gc2ggKiBzY2FsZVkgKyAnKSc7XG5cbiAgICAgIGlmICghY3JvcEVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdm1sRWwuYXBwZW5kQ2hpbGQoY3JvcEVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGltYWdlRWwucGFyZW50Tm9kZSAhPSBjcm9wRWwpIHtcbiAgICAgICAgY3JvcEVsLmFwcGVuZENoaWxkKGltYWdlRWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbWFnZUVMU3R5bGUud2lkdGggPSByb3VuZChzY2FsZVggKiBkdykgKyAncHgnO1xuICAgICAgaW1hZ2VFTFN0eWxlLmhlaWdodCA9IHJvdW5kKHNjYWxlWSAqIGRoKSArICdweCc7XG4gICAgICB2bWxFbC5hcHBlbmRDaGlsZChpbWFnZUVsKTtcblxuICAgICAgaWYgKGNyb3BFbCAmJiBjcm9wRWwucGFyZW50Tm9kZSkge1xuICAgICAgICB2bWxFbC5yZW1vdmVDaGlsZChjcm9wRWwpO1xuICAgICAgICB0aGlzLl9jcm9wRWwgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmaWx0ZXJTdHIgPSAnJztcbiAgICB2YXIgYWxwaGEgPSBzdHlsZS5vcGFjaXR5O1xuXG4gICAgaWYgKGFscGhhIDwgMSkge1xuICAgICAgZmlsdGVyU3RyICs9ICcuQWxwaGEob3BhY2l0eT0nICsgcm91bmQoYWxwaGEgKiAxMDApICsgJykgJztcbiAgICB9XG5cbiAgICBmaWx0ZXJTdHIgKz0gaW1hZ2VUcmFuc2Zvcm1QcmVmaXggKyAnLkFscGhhSW1hZ2VMb2FkZXIoc3JjPScgKyBpbWFnZSArICcsIFNpemluZ01ldGhvZD1zY2FsZSknO1xuICAgIGltYWdlRUxTdHlsZS5maWx0ZXIgPSBmaWx0ZXJTdHI7XG4gICAgdm1sRWwuc3R5bGUuekluZGV4ID0gZ2V0WkluZGV4KHRoaXMuemxldmVsLCB0aGlzLnosIHRoaXMuejIpOyAvLyBBcHBlbmQgdG8gcm9vdFxuXG4gICAgYXBwZW5kKHZtbFJvb3QsIHZtbEVsKTsgLy8gVGV4dFxuXG4gICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5kcmF3UmVjdFRleHQodm1sUm9vdCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgfVxuICB9O1xuXG4gIFpJbWFnZS5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIHJlbW92ZSh2bWxSb290LCB0aGlzLl92bWxFbCk7XG4gICAgdGhpcy5fdm1sRWwgPSBudWxsO1xuICAgIHRoaXMuX2Nyb3BFbCA9IG51bGw7XG4gICAgdGhpcy5faW1hZ2VFbCA9IG51bGw7XG4gICAgdGhpcy5yZW1vdmVSZWN0VGV4dCh2bWxSb290KTtcbiAgfTtcblxuICBaSW1hZ2UucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICBhcHBlbmQodm1sUm9vdCwgdGhpcy5fdm1sRWwpO1xuICAgIHRoaXMuYXBwZW5kUmVjdFRleHQodm1sUm9vdCk7XG4gIH07XG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICogVEVYVFxuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICB2YXIgREVGQVVMVF9TVFlMRV9OT1JNQUwgPSAnbm9ybWFsJztcbiAgdmFyIGZvbnRTdHlsZUNhY2hlID0ge307XG4gIHZhciBmb250U3R5bGVDYWNoZUNvdW50ID0gMDtcbiAgdmFyIE1BWF9GT05UX0NBQ0hFX1NJWkUgPSAxMDA7XG4gIHZhciBmb250RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICB2YXIgZ2V0Rm9udFN0eWxlID0gZnVuY3Rpb24gKGZvbnRTdHJpbmcpIHtcbiAgICB2YXIgZm9udFN0eWxlID0gZm9udFN0eWxlQ2FjaGVbZm9udFN0cmluZ107XG5cbiAgICBpZiAoIWZvbnRTdHlsZSkge1xuICAgICAgLy8gQ2xlYXIgY2FjaGVcbiAgICAgIGlmIChmb250U3R5bGVDYWNoZUNvdW50ID4gTUFYX0ZPTlRfQ0FDSEVfU0laRSkge1xuICAgICAgICBmb250U3R5bGVDYWNoZUNvdW50ID0gMDtcbiAgICAgICAgZm9udFN0eWxlQ2FjaGUgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0eWxlID0gZm9udEVsLnN0eWxlO1xuICAgICAgdmFyIGZvbnRGYW1pbHk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHN0eWxlLmZvbnQgPSBmb250U3RyaW5nO1xuICAgICAgICBmb250RmFtaWx5ID0gc3R5bGUuZm9udEZhbWlseS5zcGxpdCgnLCcpWzBdO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgZm9udFN0eWxlID0ge1xuICAgICAgICBzdHlsZTogc3R5bGUuZm9udFN0eWxlIHx8IERFRkFVTFRfU1RZTEVfTk9STUFMLFxuICAgICAgICB2YXJpYW50OiBzdHlsZS5mb250VmFyaWFudCB8fCBERUZBVUxUX1NUWUxFX05PUk1BTCxcbiAgICAgICAgd2VpZ2h0OiBzdHlsZS5mb250V2VpZ2h0IHx8IERFRkFVTFRfU1RZTEVfTk9STUFMLFxuICAgICAgICBzaXplOiBwYXJzZUZsb2F0KHN0eWxlLmZvbnRTaXplIHx8IDEyKSB8IDAsXG4gICAgICAgIGZhbWlseTogZm9udEZhbWlseSB8fCAnTWljcm9zb2Z0IFlhSGVpJ1xuICAgICAgfTtcbiAgICAgIGZvbnRTdHlsZUNhY2hlW2ZvbnRTdHJpbmddID0gZm9udFN0eWxlO1xuICAgICAgZm9udFN0eWxlQ2FjaGVDb3VudCsrO1xuICAgIH1cblxuICAgIHJldHVybiBmb250U3R5bGU7XG4gIH07XG5cbiAgdmFyIHRleHRNZWFzdXJlRWw7IC8vIE92ZXJ3cml0ZSBtZWFzdXJlIHRleHQgbWV0aG9kXG5cbiAgdGV4dENvbnRhaW4uJG92ZXJyaWRlKCdtZWFzdXJlVGV4dCcsIGZ1bmN0aW9uICh0ZXh0LCB0ZXh0Rm9udCkge1xuICAgIHZhciBkb2MgPSB2bWxDb3JlLmRvYztcblxuICAgIGlmICghdGV4dE1lYXN1cmVFbCkge1xuICAgICAgdGV4dE1lYXN1cmVFbCA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRleHRNZWFzdXJlRWwuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTt0b3A6LTIwMDAwcHg7bGVmdDowOycgKyAncGFkZGluZzowO21hcmdpbjowO2JvcmRlcjpub25lO3doaXRlLXNwYWNlOnByZTsnO1xuICAgICAgdm1sQ29yZS5kb2MuYm9keS5hcHBlbmRDaGlsZCh0ZXh0TWVhc3VyZUVsKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGV4dE1lYXN1cmVFbC5zdHlsZS5mb250ID0gdGV4dEZvbnQ7XG4gICAgfSBjYXRjaCAoZXgpIHsvLyBJZ25vcmUgZmFpbHVyZXMgdG8gc2V0IHRvIGludmFsaWQgZm9udC5cbiAgICB9XG5cbiAgICB0ZXh0TWVhc3VyZUVsLmlubmVySFRNTCA9ICcnOyAvLyBEb24ndCB1c2UgaW5uZXJIVE1MIG9yIGlubmVyVGV4dCBiZWNhdXNlIHRoZXkgYWxsb3cgbWFya3VwL3doaXRlc3BhY2UuXG5cbiAgICB0ZXh0TWVhc3VyZUVsLmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB0ZXh0TWVhc3VyZUVsLm9mZnNldFdpZHRoXG4gICAgfTtcbiAgfSk7XG4gIHZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgpO1xuXG4gIHZhciBkcmF3UmVjdFRleHQgPSBmdW5jdGlvbiAodm1sUm9vdCwgcmVjdCwgdGV4dFJlY3QsIGZyb21UZXh0RWwpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlOyAvLyBPcHRpbWl6ZSwgYXZvaWQgbm9ybWFsaXplIGV2ZXJ5IHRpbWUuXG5cbiAgICB0aGlzLl9fZGlydHkgJiYgdGV4dEhlbHBlci5ub3JtYWxpemVUZXh0U3R5bGUoc3R5bGUsIHRydWUpO1xuICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDsgLy8gQ29udmVydCB0byBzdHJpbmdcblxuICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG5cbiAgICBpZiAoIXRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIENvbnZlcnQgcmljaCB0ZXh0IHRvIHBsYWluIHRleHQuIFJpY2ggdGV4dCBpcyBub3Qgc3VwcG9ydGVkIGluXG4gICAgLy8gSUU4LSwgYnV0IHRhZ3MgaW4gcmljaCB0ZXh0IHRlbXBsYXRlIHdpbGwgYmUgcmVtb3ZlZC5cblxuXG4gICAgaWYgKHN0eWxlLnJpY2gpIHtcbiAgICAgIHZhciBjb250ZW50QmxvY2sgPSB0ZXh0Q29udGFpbi5wYXJzZVJpY2hUZXh0KHRleHQsIHN0eWxlKTtcbiAgICAgIHRleHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QmxvY2subGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRva2VucyA9IGNvbnRlbnRCbG9jay5saW5lc1tpXS50b2tlbnM7XG4gICAgICAgIHZhciB0ZXh0TGluZSA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdG9rZW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdGV4dExpbmUucHVzaCh0b2tlbnNbal0udGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0LnB1c2godGV4dExpbmUuam9pbignJykpO1xuICAgICAgfVxuXG4gICAgICB0ZXh0ID0gdGV4dC5qb2luKCdcXG4nKTtcbiAgICB9XG5cbiAgICB2YXIgeDtcbiAgICB2YXIgeTtcbiAgICB2YXIgYWxpZ24gPSBzdHlsZS50ZXh0QWxpZ247XG4gICAgdmFyIHZlcnRpY2FsQWxpZ24gPSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbjtcbiAgICB2YXIgZm9udFN0eWxlID0gZ2V0Rm9udFN0eWxlKHN0eWxlLmZvbnQpOyAvLyBGSVhNRSBlbmNvZGVIdG1sQXR0cmlidXRlID9cblxuICAgIHZhciBmb250ID0gZm9udFN0eWxlLnN0eWxlICsgJyAnICsgZm9udFN0eWxlLnZhcmlhbnQgKyAnICcgKyBmb250U3R5bGUud2VpZ2h0ICsgJyAnICsgZm9udFN0eWxlLnNpemUgKyAncHggXCInICsgZm9udFN0eWxlLmZhbWlseSArICdcIic7XG4gICAgdGV4dFJlY3QgPSB0ZXh0UmVjdCB8fCB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QodGV4dCwgZm9udCwgYWxpZ24sIHZlcnRpY2FsQWxpZ24pOyAvLyBUcmFuc2Zvcm0gcmVjdCB0byB2aWV3IHNwYWNlXG5cbiAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtOyAvLyBJZ25vcmUgdHJhbnNmb3JtIGZvciB0ZXh0IGluIG90aGVyIGVsZW1lbnRcblxuICAgIGlmIChtICYmICFmcm9tVGV4dEVsKSB7XG4gICAgICB0bXBSZWN0LmNvcHkocmVjdCk7XG4gICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKG0pO1xuICAgICAgcmVjdCA9IHRtcFJlY3Q7XG4gICAgfVxuXG4gICAgaWYgKCFmcm9tVGV4dEVsKSB7XG4gICAgICB2YXIgdGV4dFBvc2l0aW9uID0gc3R5bGUudGV4dFBvc2l0aW9uO1xuICAgICAgdmFyIGRpc3RhbmNlID0gc3R5bGUudGV4dERpc3RhbmNlOyAvLyBUZXh0IHBvc2l0aW9uIHJlcHJlc2VudGVkIGJ5IGNvb3JkXG5cbiAgICAgIGlmICh0ZXh0UG9zaXRpb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICB4ID0gcmVjdC54ICsgcGFyc2VQZXJjZW50KHRleHRQb3NpdGlvblswXSwgcmVjdC53aWR0aCk7XG4gICAgICAgIHkgPSByZWN0LnkgKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzFdLCByZWN0LmhlaWdodCk7XG4gICAgICAgIGFsaWduID0gYWxpZ24gfHwgJ2xlZnQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlcyA9IHRleHRDb250YWluLmFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCh0ZXh0UG9zaXRpb24sIHJlY3QsIGRpc3RhbmNlKTtcbiAgICAgICAgeCA9IHJlcy54O1xuICAgICAgICB5ID0gcmVzLnk7IC8vIERlZmF1bHQgYWxpZ24gYW5kIGJhc2VsaW5lIHdoZW4gaGFzIHRleHRQb3NpdGlvblxuXG4gICAgICAgIGFsaWduID0gYWxpZ24gfHwgcmVzLnRleHRBbGlnbjtcbiAgICAgICAgdmVydGljYWxBbGlnbiA9IHZlcnRpY2FsQWxpZ24gfHwgcmVzLnRleHRWZXJ0aWNhbEFsaWduO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gcmVjdC54O1xuICAgICAgeSA9IHJlY3QueTtcbiAgICB9XG5cbiAgICB4ID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFgoeCwgdGV4dFJlY3Qud2lkdGgsIGFsaWduKTtcbiAgICB5ID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFkoeSwgdGV4dFJlY3QuaGVpZ2h0LCB2ZXJ0aWNhbEFsaWduKTsgLy8gRm9yY2UgYmFzZWxpbmUgJ21pZGRsZSdcblxuICAgIHkgKz0gdGV4dFJlY3QuaGVpZ2h0IC8gMjsgLy8gdmFyIGZvbnRTaXplID0gZm9udFN0eWxlLnNpemU7XG4gICAgLy8gMS43NSBpcyBhbiBhcmJpdHJhcnkgbnVtYmVyLCBhcyB0aGVyZSBpcyBubyBpbmZvIGFib3V0IHRoZSB0ZXh0IGJhc2VsaW5lXG4gICAgLy8gc3dpdGNoIChiYXNlbGluZSkge1xuICAgIC8vIGNhc2UgJ2hhbmdpbmcnOlxuICAgIC8vIGNhc2UgJ3RvcCc6XG4gICAgLy8gICAgIHkgKz0gZm9udFNpemUgLyAxLjc1O1xuICAgIC8vICAgICBicmVhaztcbiAgICAvLyAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAvLyAgICAgICAgIGJyZWFrO1xuICAgIC8vICAgICBkZWZhdWx0OlxuICAgIC8vICAgICAvLyBjYXNlIG51bGw6XG4gICAgLy8gICAgIC8vIGNhc2UgJ2FscGhhYmV0aWMnOlxuICAgIC8vICAgICAvLyBjYXNlICdpZGVvZ3JhcGhpYyc6XG4gICAgLy8gICAgIC8vIGNhc2UgJ2JvdHRvbSc6XG4gICAgLy8gICAgICAgICB5IC09IGZvbnRTaXplIC8gMi4yNTtcbiAgICAvLyAgICAgICAgIGJyZWFrO1xuICAgIC8vIH1cbiAgICAvLyBzd2l0Y2ggKGFsaWduKSB7XG4gICAgLy8gICAgIGNhc2UgJ2xlZnQnOlxuICAgIC8vICAgICAgICAgYnJlYWs7XG4gICAgLy8gICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgLy8gICAgICAgICB4IC09IHRleHRSZWN0LndpZHRoIC8gMjtcbiAgICAvLyAgICAgICAgIGJyZWFrO1xuICAgIC8vICAgICBjYXNlICdyaWdodCc6XG4gICAgLy8gICAgICAgICB4IC09IHRleHRSZWN0LndpZHRoO1xuICAgIC8vICAgICAgICAgYnJlYWs7XG4gICAgLy8gY2FzZSAnZW5kJzpcbiAgICAvLyBhbGlnbiA9IGVsZW1lbnRTdHlsZS5kaXJlY3Rpb24gPT0gJ2x0cicgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgIC8vIGJyZWFrO1xuICAgIC8vIGNhc2UgJ3N0YXJ0JzpcbiAgICAvLyBhbGlnbiA9IGVsZW1lbnRTdHlsZS5kaXJlY3Rpb24gPT0gJ3J0bCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgIC8vIGJyZWFrO1xuICAgIC8vIGRlZmF1bHQ6XG4gICAgLy8gICAgIGFsaWduID0gJ2xlZnQnO1xuICAgIC8vIH1cblxuICAgIHZhciBjcmVhdGVOb2RlID0gdm1sQ29yZS5jcmVhdGVOb2RlO1xuICAgIHZhciB0ZXh0Vm1sRWwgPSB0aGlzLl90ZXh0Vm1sRWw7XG4gICAgdmFyIHBhdGhFbDtcbiAgICB2YXIgdGV4dFBhdGhFbDtcbiAgICB2YXIgc2tld0VsO1xuXG4gICAgaWYgKCF0ZXh0Vm1sRWwpIHtcbiAgICAgIHRleHRWbWxFbCA9IGNyZWF0ZU5vZGUoJ2xpbmUnKTtcbiAgICAgIHBhdGhFbCA9IGNyZWF0ZU5vZGUoJ3BhdGgnKTtcbiAgICAgIHRleHRQYXRoRWwgPSBjcmVhdGVOb2RlKCd0ZXh0cGF0aCcpO1xuICAgICAgc2tld0VsID0gY3JlYXRlTm9kZSgnc2tldycpOyAvLyBGSVhNRSBXaHkgaGVyZSBpcyBub3QgY2FtbWVsIGNhc2VcbiAgICAgIC8vIEFsaWduICdjZW50ZXInIHNlZW1zIHdyb25nXG5cbiAgICAgIHRleHRQYXRoRWwuc3R5bGVbJ3YtdGV4dC1hbGlnbiddID0gJ2xlZnQnO1xuICAgICAgaW5pdFJvb3RFbFN0eWxlKHRleHRWbWxFbCk7XG4gICAgICBwYXRoRWwudGV4dHBhdGhvayA9IHRydWU7XG4gICAgICB0ZXh0UGF0aEVsLm9uID0gdHJ1ZTtcbiAgICAgIHRleHRWbWxFbC5mcm9tID0gJzAgMCc7XG4gICAgICB0ZXh0Vm1sRWwudG8gPSAnMTAwMCAwLjA1JztcbiAgICAgIGFwcGVuZCh0ZXh0Vm1sRWwsIHNrZXdFbCk7XG4gICAgICBhcHBlbmQodGV4dFZtbEVsLCBwYXRoRWwpO1xuICAgICAgYXBwZW5kKHRleHRWbWxFbCwgdGV4dFBhdGhFbCk7XG4gICAgICB0aGlzLl90ZXh0Vm1sRWwgPSB0ZXh0Vm1sRWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIOi/memHjOaYr+WcqOWJjemdoiBhcHBlbmRDaGlsZCDkv53or4Hpobrluo/nmoTliY3mj5DkuItcbiAgICAgIHNrZXdFbCA9IHRleHRWbWxFbC5maXJzdENoaWxkO1xuICAgICAgcGF0aEVsID0gc2tld0VsLm5leHRTaWJsaW5nO1xuICAgICAgdGV4dFBhdGhFbCA9IHBhdGhFbC5uZXh0U2libGluZztcbiAgICB9XG5cbiAgICB2YXIgY29vcmRzID0gW3gsIHldO1xuICAgIHZhciB0ZXh0Vm1sRWxTdHlsZSA9IHRleHRWbWxFbC5zdHlsZTsgLy8gSWdub3JlIHRyYW5zZm9ybSBmb3IgdGV4dCBpbiBvdGhlciBlbGVtZW50XG5cbiAgICBpZiAobSAmJiBmcm9tVGV4dEVsKSB7XG4gICAgICBhcHBseVRyYW5zZm9ybShjb29yZHMsIGNvb3JkcywgbSk7XG4gICAgICBza2V3RWwub24gPSB0cnVlO1xuICAgICAgc2tld0VsLm1hdHJpeCA9IG1bMF0udG9GaXhlZCgzKSArIGNvbW1hICsgbVsyXS50b0ZpeGVkKDMpICsgY29tbWEgKyBtWzFdLnRvRml4ZWQoMykgKyBjb21tYSArIG1bM10udG9GaXhlZCgzKSArICcsMCwwJzsgLy8gVGV4dCBwb3NpdGlvblxuXG4gICAgICBza2V3RWwub2Zmc2V0ID0gKHJvdW5kKGNvb3Jkc1swXSkgfHwgMCkgKyAnLCcgKyAocm91bmQoY29vcmRzWzFdKSB8fCAwKTsgLy8gTGVmdCB0b3AgcG9pbnQgYXMgb3JpZ2luXG5cbiAgICAgIHNrZXdFbC5vcmlnaW4gPSAnMCAwJztcbiAgICAgIHRleHRWbWxFbFN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICAgIHRleHRWbWxFbFN0eWxlLnRvcCA9ICcwcHgnO1xuICAgIH0gZWxzZSB7XG4gICAgICBza2V3RWwub24gPSBmYWxzZTtcbiAgICAgIHRleHRWbWxFbFN0eWxlLmxlZnQgPSByb3VuZCh4KSArICdweCc7XG4gICAgICB0ZXh0Vm1sRWxTdHlsZS50b3AgPSByb3VuZCh5KSArICdweCc7XG4gICAgfVxuXG4gICAgdGV4dFBhdGhFbC5zdHJpbmcgPSBlbmNvZGVIdG1sQXR0cmlidXRlKHRleHQpOyAvLyBUT0RPXG5cbiAgICB0cnkge1xuICAgICAgdGV4dFBhdGhFbC5zdHlsZS5mb250ID0gZm9udDtcbiAgICB9IC8vIEVycm9yIGZvbnQgZm9ybWF0XG4gICAgY2F0Y2ggKGUpIHt9XG5cbiAgICB1cGRhdGVGaWxsQW5kU3Ryb2tlKHRleHRWbWxFbCwgJ2ZpbGwnLCB7XG4gICAgICBmaWxsOiBzdHlsZS50ZXh0RmlsbCxcbiAgICAgIG9wYWNpdHk6IHN0eWxlLm9wYWNpdHlcbiAgICB9LCB0aGlzKTtcbiAgICB1cGRhdGVGaWxsQW5kU3Ryb2tlKHRleHRWbWxFbCwgJ3N0cm9rZScsIHtcbiAgICAgIHN0cm9rZTogc3R5bGUudGV4dFN0cm9rZSxcbiAgICAgIG9wYWNpdHk6IHN0eWxlLm9wYWNpdHksXG4gICAgICBsaW5lRGFzaDogc3R5bGUubGluZURhc2hcbiAgICB9LCB0aGlzKTtcbiAgICB0ZXh0Vm1sRWwuc3R5bGUuekluZGV4ID0gZ2V0WkluZGV4KHRoaXMuemxldmVsLCB0aGlzLnosIHRoaXMuejIpOyAvLyBBdHRhY2hlZCB0byByb290XG5cbiAgICBhcHBlbmQodm1sUm9vdCwgdGV4dFZtbEVsKTtcbiAgfTtcblxuICB2YXIgcmVtb3ZlUmVjdFRleHQgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIHJlbW92ZSh2bWxSb290LCB0aGlzLl90ZXh0Vm1sRWwpO1xuICAgIHRoaXMuX3RleHRWbWxFbCA9IG51bGw7XG4gIH07XG5cbiAgdmFyIGFwcGVuZFJlY3RUZXh0ID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICBhcHBlbmQodm1sUm9vdCwgdGhpcy5fdGV4dFZtbEVsKTtcbiAgfTtcblxuICB2YXIgbGlzdCA9IFtSZWN0VGV4dCwgRGlzcGxheWFibGUsIFpJbWFnZSwgUGF0aCwgVGV4dF07IC8vIEluIGNhc2UgRGlzcGxheWFibGUgaGFzIGJlZW4gbWl4ZWQgaW4gUmVjdFRleHRcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvdG8gPSBsaXN0W2ldLnByb3RvdHlwZTtcbiAgICBwcm90by5kcmF3UmVjdFRleHQgPSBkcmF3UmVjdFRleHQ7XG4gICAgcHJvdG8ucmVtb3ZlUmVjdFRleHQgPSByZW1vdmVSZWN0VGV4dDtcbiAgICBwcm90by5hcHBlbmRSZWN0VGV4dCA9IGFwcGVuZFJlY3RUZXh0O1xuICB9XG5cbiAgVGV4dC5wcm90b3R5cGUuYnJ1c2hWTUwgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG5cbiAgICBpZiAoc3R5bGUudGV4dCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmRyYXdSZWN0VGV4dCh2bWxSb290LCB7XG4gICAgICAgIHg6IHN0eWxlLnggfHwgMCxcbiAgICAgICAgeTogc3R5bGUueSB8fCAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVSZWN0VGV4dCh2bWxSb290KTtcbiAgICB9XG4gIH07XG5cbiAgVGV4dC5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gIH07XG5cbiAgVGV4dC5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIHRoaXMuYXBwZW5kUmVjdFRleHQodm1sUm9vdCk7XG4gIH07XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL3ZtbC9ncmFwaGljLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZW52ID0gcmVxdWlyZShcIi4uL2NvcmUvZW52XCIpO1xuXG52YXIgdXJuID0gJ3VybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sJztcbnZhciB3aW4gPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3c7XG52YXIgdm1sSW5pdGVkID0gZmFsc2U7XG52YXIgZG9jID0gd2luICYmIHdpbi5kb2N1bWVudDtcblxuZnVuY3Rpb24gY3JlYXRlTm9kZSh0YWdOYW1lKSB7XG4gIHJldHVybiBkb0NyZWF0ZU5vZGUodGFnTmFtZSk7XG59IC8vIEF2b2lkIGFzc2lnbiB0byBhbiBleHBvcnRlZCB2YXJpYWJsZSwgZm9yIHRyYW5zZm9ybWluZyB0byBjanMuXG5cblxudmFyIGRvQ3JlYXRlTm9kZTtcblxuaWYgKGRvYyAmJiAhZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICB0cnkge1xuICAgICFkb2MubmFtZXNwYWNlcy56cnZtbCAmJiBkb2MubmFtZXNwYWNlcy5hZGQoJ3pydm1sJywgdXJuKTtcblxuICAgIGRvQ3JlYXRlTm9kZSA9IGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gZG9jLmNyZWF0ZUVsZW1lbnQoJzx6cnZtbDonICsgdGFnTmFtZSArICcgY2xhc3M9XCJ6cnZtbFwiPicpO1xuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkb0NyZWF0ZU5vZGUgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgICAgcmV0dXJuIGRvYy5jcmVhdGVFbGVtZW50KCc8JyArIHRhZ05hbWUgKyAnIHhtbG5zPVwiJyArIHVybiArICdcIiBjbGFzcz1cInpydm1sXCI+Jyk7XG4gICAgfTtcbiAgfVxufSAvLyBGcm9tIHJhcGhhZWxcblxuXG5mdW5jdGlvbiBpbml0Vk1MKCkge1xuICBpZiAodm1sSW5pdGVkIHx8ICFkb2MpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2bWxJbml0ZWQgPSB0cnVlO1xuICB2YXIgc3R5bGVTaGVldHMgPSBkb2Muc3R5bGVTaGVldHM7XG5cbiAgaWYgKHN0eWxlU2hlZXRzLmxlbmd0aCA8IDMxKSB7XG4gICAgZG9jLmNyZWF0ZVN0eWxlU2hlZXQoKS5hZGRSdWxlKCcuenJ2bWwnLCAnYmVoYXZpb3I6dXJsKCNkZWZhdWx0I1ZNTCknKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzExOTQlMjhWUy44NSUyOS5hc3B4XG4gICAgc3R5bGVTaGVldHNbMF0uYWRkUnVsZSgnLnpydm1sJywgJ2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpJyk7XG4gIH1cbn1cblxuZXhwb3J0cy5kb2MgPSBkb2M7XG5leHBvcnRzLmNyZWF0ZU5vZGUgPSBjcmVhdGVOb2RlO1xuZXhwb3J0cy5pbml0Vk1MID0gaW5pdFZNTDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvdm1sL2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB6ckxvZyA9IHJlcXVpcmUoXCIuLi9jb3JlL2xvZ1wiKTtcblxudmFyIHZtbENvcmUgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgZWFjaCA9IF91dGlsLmVhY2g7XG5cbi8qKlxuICogVk1MIFBhaW50ZXIuXG4gKlxuICogQG1vZHVsZSB6cmVuZGVyL3ZtbC9QYWludGVyXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSW50MTAodmFsKSB7XG4gIHJldHVybiBwYXJzZUludCh2YWwsIDEwKTtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL3ZtbC9QYWludGVyXG4gKi9cblxuXG5mdW5jdGlvbiBWTUxQYWludGVyKHJvb3QsIHN0b3JhZ2UpIHtcbiAgdm1sQ29yZS5pbml0Vk1MKCk7XG4gIHRoaXMucm9vdCA9IHJvb3Q7XG4gIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gIHZhciB2bWxWaWV3cG9ydCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2YXIgdm1sUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2bWxWaWV3cG9ydC5zdHlsZS5jc3NUZXh0ID0gJ2Rpc3BsYXk6aW5saW5lLWJsb2NrO292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDozMDBweDtoZWlnaHQ6MTUwcHg7JztcbiAgdm1sUm9vdC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MDsnO1xuICByb290LmFwcGVuZENoaWxkKHZtbFZpZXdwb3J0KTtcbiAgdGhpcy5fdm1sUm9vdCA9IHZtbFJvb3Q7XG4gIHRoaXMuX3ZtbFZpZXdwb3J0ID0gdm1sVmlld3BvcnQ7XG4gIHRoaXMucmVzaXplKCk7IC8vIE1vZGlmeSBzdG9yYWdlXG5cbiAgdmFyIG9sZERlbEZyb21TdG9yYWdlID0gc3RvcmFnZS5kZWxGcm9tU3RvcmFnZTtcbiAgdmFyIG9sZEFkZFRvU3RvcmFnZSA9IHN0b3JhZ2UuYWRkVG9TdG9yYWdlO1xuXG4gIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICBvbGREZWxGcm9tU3RvcmFnZS5jYWxsKHN0b3JhZ2UsIGVsKTtcblxuICAgIGlmIChlbCkge1xuICAgICAgZWwub25SZW1vdmUgJiYgZWwub25SZW1vdmUodm1sUm9vdCk7XG4gICAgfVxuICB9O1xuXG4gIHN0b3JhZ2UuYWRkVG9TdG9yYWdlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgLy8gRGlzcGxheWFibGUgYWxyZWFkeSBoYXMgYSB2bWwgbm9kZVxuICAgIGVsLm9uQWRkICYmIGVsLm9uQWRkKHZtbFJvb3QpO1xuICAgIG9sZEFkZFRvU3RvcmFnZS5jYWxsKHN0b3JhZ2UsIGVsKTtcbiAgfTtcblxuICB0aGlzLl9maXJzdFBhaW50ID0gdHJ1ZTtcbn1cblxuVk1MUGFpbnRlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBWTUxQYWludGVyLFxuICBnZXRUeXBlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICd2bWwnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRGl2RWxlbWVudH1cbiAgICovXG4gIGdldFZpZXdwb3J0Um9vdDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl92bWxWaWV3cG9ydDtcbiAgfSxcbiAgZ2V0Vmlld3BvcnRSb290T2Zmc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZpZXdwb3J0Um9vdCA9IHRoaXMuZ2V0Vmlld3BvcnRSb290KCk7XG5cbiAgICBpZiAodmlld3BvcnRSb290KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvZmZzZXRMZWZ0OiB2aWV3cG9ydFJvb3Qub2Zmc2V0TGVmdCB8fCAwLFxuICAgICAgICBvZmZzZXRUb3A6IHZpZXdwb3J0Um9vdC5vZmZzZXRUb3AgfHwgMFxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWIt+aWsFxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBsaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KHRydWUsIHRydWUpO1xuXG4gICAgdGhpcy5fcGFpbnRMaXN0KGxpc3QpO1xuICB9LFxuICBfcGFpbnRMaXN0OiBmdW5jdGlvbiAobGlzdCkge1xuICAgIHZhciB2bWxSb290ID0gdGhpcy5fdm1sUm9vdDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsID0gbGlzdFtpXTtcblxuICAgICAgaWYgKGVsLmludmlzaWJsZSB8fCBlbC5pZ25vcmUpIHtcbiAgICAgICAgaWYgKCFlbC5fX2FscmVhZHlOb3RWaXNpYmxlKSB7XG4gICAgICAgICAgZWwub25SZW1vdmUodm1sUm9vdCk7XG4gICAgICAgIH0gLy8gU2V0IGFzIGFscmVhZHkgaW52aXNpYmxlXG5cblxuICAgICAgICBlbC5fX2FscmVhZHlOb3RWaXNpYmxlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbC5fX2FscmVhZHlOb3RWaXNpYmxlKSB7XG4gICAgICAgICAgZWwub25BZGQodm1sUm9vdCk7XG4gICAgICAgIH1cblxuICAgICAgICBlbC5fX2FscmVhZHlOb3RWaXNpYmxlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGVsLl9fZGlydHkpIHtcbiAgICAgICAgICBlbC5iZWZvcmVCcnVzaCAmJiBlbC5iZWZvcmVCcnVzaCgpO1xuICAgICAgICAgIChlbC5icnVzaFZNTCB8fCBlbC5icnVzaCkuY2FsbChlbCwgdm1sUm9vdCk7XG4gICAgICAgICAgZWwuYWZ0ZXJCcnVzaCAmJiBlbC5hZnRlckJydXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWwuX19kaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9maXJzdFBhaW50KSB7XG4gICAgICAvLyBEZXRhY2hlZCBmcm9tIGRvY3VtZW50IGF0IGZpcnN0IHRpbWVcbiAgICAgIC8vIHRvIGF2b2lkIHBhZ2UgcmVmcmVzaGluZyB0b28gbWFueSB0aW1lc1xuICAgICAgLy8gRklYTUUg5aaC5p6c5q+P5qyh6YO95YWIIHJlbW92ZUNoaWxkIOWPr+iDveS8muWvvOiHtOS4gOS6m+Whq+WFheWSjOaPj+i+ueeahOaViOaenOaUueWPmFxuICAgICAgdGhpcy5fdm1sVmlld3BvcnQuYXBwZW5kQ2hpbGQodm1sUm9vdCk7XG5cbiAgICAgIHRoaXMuX2ZpcnN0UGFpbnQgPSBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgd2lkdGggPSB3aWR0aCA9PSBudWxsID8gdGhpcy5fZ2V0V2lkdGgoKSA6IHdpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBoZWlnaHQgPT0gbnVsbCA/IHRoaXMuX2dldEhlaWdodCgpIDogaGVpZ2h0O1xuXG4gICAgaWYgKHRoaXMuX3dpZHRoICE9IHdpZHRoIHx8IHRoaXMuX2hlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB2YXIgdm1sVmlld3BvcnRTdHlsZSA9IHRoaXMuX3ZtbFZpZXdwb3J0LnN0eWxlO1xuICAgICAgdm1sVmlld3BvcnRTdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgIHZtbFZpZXdwb3J0U3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICB9XG4gIH0sXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJvb3QuaW5uZXJIVE1MID0gJyc7XG4gICAgdGhpcy5fdm1sUm9vdCA9IHRoaXMuX3ZtbFZpZXdwb3J0ID0gdGhpcy5zdG9yYWdlID0gbnVsbDtcbiAgfSxcbiAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gIH0sXG4gIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH0sXG4gIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3ZtbFZpZXdwb3J0KSB7XG4gICAgICB0aGlzLnJvb3QucmVtb3ZlQ2hpbGQodGhpcy5fdm1sVmlld3BvcnQpO1xuICAgIH1cbiAgfSxcbiAgX2dldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgdmFyIHN0bCA9IHJvb3QuY3VycmVudFN0eWxlO1xuICAgIHJldHVybiAocm9vdC5jbGllbnRXaWR0aCB8fCBwYXJzZUludDEwKHN0bC53aWR0aCkpIC0gcGFyc2VJbnQxMChzdGwucGFkZGluZ0xlZnQpIC0gcGFyc2VJbnQxMChzdGwucGFkZGluZ1JpZ2h0KSB8IDA7XG4gIH0sXG4gIF9nZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICB2YXIgc3RsID0gcm9vdC5jdXJyZW50U3R5bGU7XG4gICAgcmV0dXJuIChyb290LmNsaWVudEhlaWdodCB8fCBwYXJzZUludDEwKHN0bC5oZWlnaHQpKSAtIHBhcnNlSW50MTAoc3RsLnBhZGRpbmdUb3ApIC0gcGFyc2VJbnQxMChzdGwucGFkZGluZ0JvdHRvbSkgfCAwO1xuICB9XG59OyAvLyBOb3Qgc3VwcG9ydGVkIG1ldGhvZHNcblxuZnVuY3Rpb24gY3JlYXRlTWV0aG9kTm90U3VwcG9ydChtZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB6ckxvZygnSW4gSUU4LjAgVk1MIG1vZGUgcGFpbnRlciBub3Qgc3VwcG9ydCBtZXRob2QgXCInICsgbWV0aG9kICsgJ1wiJyk7XG4gIH07XG59IC8vIFVuc3VwcG9ydGVkIG1ldGhvZHNcblxuXG5lYWNoKFsnZ2V0TGF5ZXInLCAnaW5zZXJ0TGF5ZXInLCAnZWFjaExheWVyJywgJ2VhY2hCdWlsdGluTGF5ZXInLCAnZWFjaE90aGVyTGF5ZXInLCAnZ2V0TGF5ZXJzJywgJ21vZExheWVyJywgJ2RlbExheWVyJywgJ2NsZWFyTGF5ZXInLCAndG9EYXRhVVJMJywgJ3BhdGhUb0ltYWdlJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gIFZNTFBhaW50ZXIucHJvdG90eXBlW25hbWVdID0gY3JlYXRlTWV0aG9kTm90U3VwcG9ydChuYW1lKTtcbn0pO1xudmFyIF9kZWZhdWx0ID0gVk1MUGFpbnRlcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL3ZtbC9QYWludGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9