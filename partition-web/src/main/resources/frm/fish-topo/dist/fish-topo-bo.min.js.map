{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","fish-topo-bo.js","webpack:/webpack/bootstrap f19dda89bdc4710c95f7","webpack:///index.bo.js","webpack:///lib/fish-topo-bo/lib/FishTopoBo.js","webpack:///~/zrender/lib/zrender.js","webpack:///~/zrender/lib/core/guid.js","webpack:///~/zrender/lib/core/env.js","webpack:///~/zrender/lib/core/util.js","webpack:///~/zrender/lib/Handler.js","webpack:///~/zrender/lib/core/vector.js","webpack:///~/zrender/lib/mixin/Draggable.js","webpack:///~/zrender/lib/mixin/Eventful.js","webpack:///~/zrender/lib/Storage.js","webpack:///~/zrender/lib/container/Group.js","webpack:///~/zrender/lib/Element.js","webpack:///~/zrender/lib/mixin/Transformable.js","webpack:///~/zrender/lib/core/matrix.js","webpack:///~/zrender/lib/mixin/Animatable.js","webpack:///~/zrender/lib/animation/Animator.js","webpack:///~/zrender/lib/animation/Clip.js","webpack:///~/zrender/lib/animation/easing.js","webpack:///~/zrender/lib/tool/color.js","webpack:///~/zrender/lib/core/LRU.js","webpack:///~/zrender/lib/core/log.js","webpack:///~/zrender/lib/config.js","webpack:///~/zrender/lib/core/BoundingRect.js","webpack:///~/zrender/lib/core/timsort.js","webpack:///~/zrender/lib/Painter.js","webpack:///~/zrender/lib/Layer.js","webpack:///~/zrender/lib/graphic/Style.js","webpack:///~/zrender/lib/graphic/Pattern.js","webpack:///~/zrender/lib/animation/requestAnimationFrame.js","webpack:///~/zrender/lib/graphic/Image.js","webpack:///~/zrender/lib/graphic/Displayable.js","webpack:///~/zrender/lib/graphic/mixin/RectText.js","webpack:///~/zrender/lib/graphic/helper/text.js","webpack:///~/zrender/lib/contain/text.js","webpack:///~/zrender/lib/graphic/helper/image.js","webpack:///~/zrender/lib/graphic/helper/roundRect.js","webpack:///~/zrender/lib/animation/Animation.js","webpack:///~/zrender/lib/core/event.js","webpack:///~/zrender/lib/dom/HandlerProxy.js","webpack:///~/zrender/lib/core/GestureMgr.js","webpack:///lib/fish-topo-bo/lib/node/BoNode.js","webpack:///lib/fish-topo-bo/lib/models/Const.js","webpack:///lib/fish-topo-bo/lib/node/BoName.js","webpack:///lib/fish-topo-core/lib/graphic.js","webpack:///~/zrender/lib/tool/path.js","webpack:///~/zrender/lib/graphic/Path.js","webpack:///~/zrender/lib/core/PathProxy.js","webpack:///~/zrender/lib/core/curve.js","webpack:///~/zrender/lib/core/bbox.js","webpack:///~/zrender/lib/contain/path.js","webpack:///~/zrender/lib/contain/line.js","webpack:///~/zrender/lib/contain/cubic.js","webpack:///~/zrender/lib/contain/quadratic.js","webpack:///~/zrender/lib/contain/arc.js","webpack:///~/zrender/lib/contain/util.js","webpack:///~/zrender/lib/contain/windingLine.js","webpack:///~/zrender/lib/tool/transformPath.js","webpack:///~/zrender/lib/graphic/Gradient.js","webpack:///~/zrender/lib/graphic/Text.js","webpack:///~/zrender/lib/graphic/shape/Circle.js","webpack:///~/zrender/lib/graphic/shape/Sector.js","webpack:///~/zrender/lib/graphic/helper/fixClipWithShadow.js","webpack:///~/zrender/lib/graphic/shape/Ring.js","webpack:///~/zrender/lib/graphic/shape/Polygon.js","webpack:///~/zrender/lib/graphic/helper/poly.js","webpack:///~/zrender/lib/graphic/helper/smoothSpline.js","webpack:///~/zrender/lib/graphic/helper/smoothBezier.js","webpack:///~/zrender/lib/graphic/shape/Polyline.js","webpack:///~/zrender/lib/graphic/shape/Rect.js","webpack:///~/zrender/lib/graphic/shape/Line.js","webpack:///~/zrender/lib/graphic/shape/BezierCurve.js","webpack:///~/zrender/lib/graphic/shape/Arc.js","webpack:///~/zrender/lib/graphic/LinearGradient.js","webpack:///~/zrender/lib/graphic/RadialGradient.js","webpack:///~/zrender/lib/graphic/States.js","webpack:///lib/fish-topo-bo/lib/node/EventDecisionNode.js","webpack:///lib/fish-topo-bo/lib/node/LineNode.js","webpack:///lib/fish-topo-bo/lib/node/BoAttrNode.js","webpack:///lib/fish-topo-bo/lib/node/Relation.js","webpack:///lib/fish-topo-core/lib/objectAssignPolyfill.js","webpack:///~/zrender/lib/vml/vml.js","webpack:///~/zrender/lib/vml/graphic.js","webpack:///~/zrender/lib/vml/core.js","webpack:///~/zrender/lib/vml/Painter.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","FishTopoBo","dom","opts","nowZoom","canScale","_zr","zr","init","renderer","devicePixelRatio","util","BoNode","Relation","Const","graphic","eventTool","fishTopoProto","prototype","group","Group","groupDrag","add","zrScale","resize","addBo","boData","_setParent","layout","x","startPos","y","level","_bfs","_moveRightByParent","boNode","getShape","addChildBo","child","childCnt","length","childBoArr","i","parent","next","_levelMaxPos","_queue","push","tmp","shift","BO_NODE_WIDTH","_moveRightByChild","BO_NODE_OFFSET_X","width","moved","_moveRightByPrevious","parentBoNode","boNodeHeight","getBoundingRect","height","getLayout","BO_NODE_OFFSET_Y","getData","relationNode","relation","_relationLen","j","sourceId","targetId","sourceText","targetText","childOfName","lineStyle","lineHoverStyle","arrowStyle","arrowHoverStyle","setCurrentBo","boId","style","childCount","childAt","name","setCurrent","clear","type","zoom","zoomDelta","zoomX","zoomY","that","target","pos","position","scale","newZoom","_zoom","zoomScale","attr","getWidth","getHeight","on","e","stop","event","wheelDelta","offsetX","offsetY","groupDragFunction","moveDrag","gx","gy","min","max","sX","clientX","startX","sY","clientY","startY","nowGroupPosition","groupPositionX","groupPositionY","endDrag","off","moveFunction","upFunction","cancelBubble","drag","node","GroupNode","nodeMessage","shape","nodeXY","movePosition","moveX","moveY","groupNode","reDraw","alarm","newAlarmPosition","ConnectionManager","refreshLineByNode","layoutNode","forceLayoutOption","nodes","allNodes","_","indexOf","alarmPositionX","alarmPositionY","isdraggable","idBase","Date","instances","DOM_ATTRIBUTE_KEY","fishTopoBo","version","dependencies","zrender","Error","defaults","showGridLine","gridLineSpacing","setAttribute","getInstanceByDom","key","getAttribute","dispose","chart","topo","zrUtil","isDom","isDisposed","ZRender","guid","hasOwnProperty","getInstance","registerPainter","Ctor","painterCtors","delInstance","env","Handler","Storage","Painter","Animation","HandlerProxy","useVML","canvasSupported","canvas","self","storage","rendererType","vml","painter","handerProxy","getViewportRoot","handler","animation","stage","update","bind","flush","start","_needsRefresh","oldDelFromStorage","delFromStorage","oldAddToStorage","addToStorage","el","removeSelfFromZr","addSelfToZr","constructor","getId","addRoot","remove","delRoot","configLayer","zLevel","config","refreshImmediately","refresh","_needsRefreshHover","refreshHoverImmediately","addHover","refreshHover","removeHover","clearHover","clearAnimation","pathToImage","dpr","setCursorStyle","cursorStyle","findHover","eventName","eventHandler","context","trigger","_default","idStart","detect","ua","os","browser","firefox","match","ie","edge","weChat","test","document","createElement","getContext","svgSupported","SVGRect","touchEventsSupported","window","pointerEventsSupported","navigator","userAgent","$override","fn","methods","clone","source","result","typeStr","objToString","len","TYPED_ARRAY","from","BUILTIN_OBJECT","isPrimitive","merge","overwrite","isObject","targetProp","sourceProp","isArray","isBuiltInObject","mergeAll","targetAndSources","extend","overlay","_ctx","createCanvas","array","value","inherits","clazz","baseClazz","F","clazzPrototype","prop","superClass","mixin","isArrayLike","data","each","obj","cb","forEach","nativeForEach","map","nativeMap","reduce","memo","nativeReduce","filter","nativeFilter","find","func","args","nativeSlice","arguments","apply","concat","curry","isFunction","isString","nodeType","ownerDocument","eqNaN","retrieve","values","retrieve2","value0","value1","retrieve3","value2","slice","Function","normalizeCssArray","val","assert","condition","message","setAsPrimitive","primitiveKey","HashMap","set","createHashMap","noop","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","[object Canvas]","[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]","Object","toString","arrayProto","Array","HASH_MAP_PREFIX","HASH_MAP_PREFIX_LENGTH","get","prefixedKey","removeKey","makeEventPacket","eveType","targetInfo","topTarget","zrX","zrY","gestureEvent","pinchX","pinchY","pinchScale","zrDelta","zrByTouch","which","EmptyProxy","isHover","displayable","rectHover","isSilent","clipPath","contain","silent","SILENT","vec2","Draggable","Eventful","handlerNames","proxy","painterRoot","_hovered","_lastTouchMoment","_lastX","_lastY","mousemove","lastHovered","lastHoveredTarget","__zr","hovered","hoveredTarget","setCursor","cursor","dispatchToElement","mouseout","innerDom","element","toElement","relatedTarget","parentNode","dispatch","eventArgs","eventPacket","eachOtherLayer","layer","exclude","list","getDisplayList","out","hoverCheckResult","ignore","_downEl","_downPoint","_upEl","dist","create","ArrayCtor","copy","v","a","b","v1","v2","scaleAndAdd","sub","Math","sqrt","lenSquare","mul","div","dot","s","normalize","d","distance","distanceSquare","negate","lerp","t","applyTransform","Float32Array","lengthSquare","distSquare","_dragStart","_drag","_dragEnd","param","draggingTarget","draggable","_draggingTarget","dragging","_x","_y","dx","dy","drift","dropTarget","lastDropTarget","_dropTarget","arrySlice","_$handlers","one","_h","h","ctx","newList","l","argLen","splice","triggerWithContext","shapeCompareFunc","zlevel","z","z2","timsort","_roots","_displayList","_displayListLen","traverse","includeIgnore","updateDisplayList","roots","displayList","_updateAndAddDisplayable","clipPaths","beforeUpdate","__dirty","afterUpdate","userSetClipPath","currentClipPath","parentClipPath","updateTransform","isGroup","children","_children","__clipPaths","__storage","addChildrenToStorage","delChildrenFromStorage","idx","dirty","_renderList","displayableSortFunc","Element","BoundingRect","_doAdd","addBefore","nextSibling","removeAll","eachChild","includeChildren","rect","tmpRect","tmpMat","invisible","childRect","transform","getLocalTransform","union","Transformable","Animatable","decomposeTransform","attrKV","hide","show","setClipPath","removeClipPath","__clipTarget","animators","addAnimator","removeAnimator","isNotAroundZero","EPSILON","matrix","vector","mIdentity","identity","rotation","origin","transformableProto","needLocalTransform","parentHasTransform","invTransform","invert","setTransform","restoreTransform","tmpTransform","sx","sy","atan2","getGlobalScale","transformCoordToLocal","transformCoordToGlobal","rotate","m1","m2","out0","out1","out2","out3","out4","out5","translate","rad","aa","ac","atx","ab","ad","aty","st","sin","ct","cos","vx","vy","det","Animator","log","_util","animate","path","loop","animatingShape","pathSplitted","split","animator","during","done","stopAnimation","forwardToLast","animateTo","time","delay","easing","callback","forceAnimate","count","_animateToShallow","objShallow","propertyCount","props","when","defaultGetter","defaultSetter","interpolateNumber","p0","p1","percent","interpolateString","interpolateArray","arrDim","len2","fillArr","arr0","arr1","arr0Len","arr1Len","isPreviousLarger","arraySlice","isNaN","isArraySame","catmullRomInterpolateArray","p2","p3","t2","t3","catmullRomInterpolate","v0","cloneValue","ret","rgba2String","rgba","floor","join","getArrayDim","keyframes","lastValue","createTrackClip","oneTrackDone","propName","getter","_getter","setter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","sort","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","color","parse","_target","w","lastFrame","lastFramePercent","onframe","frame","range","clip","Clip","life","_loop","_delay","ondestroy","_tracks","_clipCount","_doneList","_onframeList","_clipList","tracks","pause","_paused","resume","isPaused","_doneCallback","doneList","lastClip","clipCount","addClip","oldOnFrame","clipList","removeClip","getClips","options","_life","_initialized","gap","onrestart","_pausedTime","easingFuncs","step","globalTime","deltaTime","_startTime","easingFunc","schedule","fire","restart","_needsRemove","remainder","eventType","arg","linear","k","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","PI","sinusoidalOut","sinusoidalInOut","exponentialIn","pow","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","asin","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","clampCssByte","round","clampCssAngle","clampCssFloat","f","parseCssInt","str","charAt","parseFloat","parseInt","parseCssFloat","cssHueToRgb","lerpNumber","setRgba","r","g","copyRgba","putToCache","colorStr","rgbaArr","lastRemovedArr","colorCache","put","cached","replace","toLowerCase","kCSSColorTable","op","ep","fname","substr","params","alpha","pop","hsla2rgba","iv","hsla","rgba2hsla","H","S","R","G","B","vMin","vMax","delta","L","deltaR","deltaG","deltaB","lift","colorArr","stringify","toHex","fastLerp","normalizedValue","colors","leftIndex","rightIndex","ceil","leftColor","rightColor","dv","fullOutput","modifyHSL","modifyAlpha","arrColor","LRU","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","fastMapToColor","mapToColor","LinkedList","head","tail","_len","linkedListProto","insert","entry","Entry","insertEntry","prev","maxSize","_list","_map","_maxSize","_lastRemovedEntry","LRUProto","removed","leastUsedEntry","_config","debugMode","console","v2ApplyTransform","mathMin","mathMax","other","lt","rb","lb","rt","maxX","maxY","calculateTransform","intersect","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","plain","minRunLength","n","DEFAULT_MIN_MERGE","makeAscendingRun","lo","hi","compare","runHi","reverseRun","binaryInsertionSort","mid","pivot","left","right","gallopLeft","hint","lastOffset","maxOffset","offset","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","length2","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","tmpStorageLength","DEFAULT_TMP_STORAGE_LENGTH","stackLength","remaining","ts","minRun","force","parseInt10","isLayerValid","__builtin__","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","viewRect","isClipPathChanged","prevClipPaths","doClip","beginPath","buildPath","createRoot","domRoot","cssText","Layer","requestAnimationFrame","Image","MAX_PROGRESSIVE_LAYER_NUMBER","singleCanvas","nodeName","toUpperCase","_opts","_singleCanvas","rootStyle","innerHTML","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","initContext","_domRoot","_getSize","appendChild","_progressiveLayers","_hoverlayer","_hoverElements","getType","isSingleCanvas","getViewportRootOffset","viewportRoot","offsetLeft","offsetTop","paintAll","_paintList","_startProgessive","hoverStyle","__hoverMir","elMirror","__from","setStyle","hoverElements","hoverLayer","getLayer","scope","save","originalEl","_doPaintEl","restore","token","_progressiveToken","_doPaintList","_furtherProgressive","_progress","_clearProgressive","_updateLayerStatus","eachBuiltinLayer","flushProgressiveLayer","globalAlpha","shadowBlur","currentLayer","drawImage","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","elZLevel","elFrame","__frame","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","opacity","culling","prevClipLayer","prevElClipPaths","prevEl","beforeBrush","brush","afterBrush","insertLayer","layersMap","prevLayer","virtual","prevDom","insertBefore","firstChild","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","elCount","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","progressive","_clearLayer","layerConfig","delLayer","removeChild","display","clearLayer","getRenderedCanvas","findAndDrawOtherLayer","smaller","larger","Infinity","intermediateLayer","renderToCanvas","imageLayer","pixelRatio","clearColor","backgroundColor","whIdx","wh","cwh","plt","prb","stl","defaultView","getComputedStyle","shadowBlurSize","shadowOffsetX","shadowOffsetY","lineWidth","hasStroke","leftMargin","rightMargin","topMargin","bottomMargin","clearRect","pathTransform","ImageShape","imgShape","image","returnFalse","createDom","newDom","newDomStyle","top","Style","Pattern","domStyle","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","__currentValues","createBackBuffer","clearAll","haveMotionBLur","globalCompositeOperation","clearColorGradientOrPattern","colorStops","__canvasGradient","getGradient","getCanvasPattern","fillStyle","fillRect","createLinearGradient","x2","y2","global","canvasGradient","createRadialGradient","STYLE_COMMON_PROPS","host","extendFrom","fill","stroke","lineDash","lineDashOffset","strokeNoScale","text","font","textFont","fontStyle","fontWeight","fontSize","fontFamily","textTag","textFill","textStroke","textWidth","textHeight","textStrokeWidth","textLineHeight","textPosition","textRect","textOffset","textAlign","textVerticalAlign","textDistance","textShadowColor","textShadowBlur","textShadowOffsetX","textShadowOffsetY","textBoxShadowColor","textBoxShadowBlur","textBoxShadowOffsetX","textBoxShadowOffsetY","transformText","textRotation","textOrigin","textBackgroundColor","textBorderColor","textBorderWidth","textBorderRadius","textPadding","rich","truncate","blend","prevStyle","firstDraw","styleName","strokeStyle","getLineScale","hasFill","otherStyle","newStyle","method","addColorStop","styleProto","repeat","createPattern","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","setTimeout","ZImage","Displayable","imageHelper","src","_image","createOrUpdateImage","onload","isImageReady","aspect","sWidth","sHeight","drawRectText","_rect","RectText","rectContain","coord","animateStyle","useStyle","textHelper","normalizeTextStyle","needDrawText","renderText","normalizeStyle","textContain","makeFont","VALID_TEXT_ALIGN","textBaseline","VALID_TEXT_VERTICAL_ALIGN","hostEl","renderRichText","renderPlainText","setCtx","DEFAULT_FONT","contentBlock","__textCotentBlock","parsePlainText","outerHeight","textLines","lines","lineHeight","boxPos","getBoxPosition","baseX","baseY","applyTextRotation","boxY","adjustTextY","textX","textY","needDrawBg","needDrawBackground","outerWidth","boxX","adjustTextX","drawBackground","getTextXForPadding","getStroke","getFill","strokeText","fillText","parseRichText","drawRichText","contentWidth","xLeft","lineTop","xRight","line","tokens","tokenCount","usedWidth","lineXLeft","lineXRight","placeToken","tokenStyle","isLineHolder","isPlainBg","roundRectHelper","closePath","onBgImageLoaded","blockHeiht","parsePercent","res","adjustTextPositionOnRect","maxValue","lastIndexOf","center","bottom","middle","textWidthCache","measureText","textWidthCacheCounter","TEXT_CACHE_MAX","getRichTextRect","getPlainTextRect","halfHeight","truncateText","containerWidth","ellipsis","prepareTruncateOptions","truncateSingleLine","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","ellipsisWidth","textLine","subLength","estimateLength","charCode","charCodeAt","getLineHeight","padding","truncOuterHeight","truncOuterWidth","lastIndex","STYLE_REG","exec","matchedIndex","index","pushTokens","substring","contentHeight","pendingList","stlPadding","truncateWidth","truncateHeight","tokenHeight","tokenWidth","tokenWidthNotSpecified","percentWidth","bgImg","findExistImage","paddingW","remianTruncWidth","block","isEmptyStr","strs","tokensLen","newImageOrSrc","cachedImgObj","globalImageCache","cbPayload","__zrImageSrc","pendingWrap","pending","imageOnLoad","__cachedImgObj","r1","r2","r3","r4","total","moveTo","lineTo","quadraticCurveTo","_event","Dispatcher","_clips","_running","_time","_pauseStart","clips","_update","getTime","deferredEvents","deferredClips","_startLoop","getBoundingClientRect","clientToLocal","calculate","defaultGetZrXY","layerX","layerY","box","normalizeEvent","isTouch","touch","targetTouches","changedTouches","detail","button","undefined","MOUSE_EVENT_REG","addEventListener","isDomLevel2","attachEvent","removeEventListener","detachEvent","notLeftMouse","preventDefault","stopPropagation","returnValue","eventNameFix","processGesture","gestureMgr","_gestureMgr","gestureInfo","recognize","setTouchTimer","instance","_touching","clearTimeout","_touchTimer","isPointerFromTouch","pointerType","initDomHandler","makeMouseHandler","touchHandlerNames","_handlers","domHandlers","pointerHandlerNames","mouseHandlerNames","HandlerDomProxy","mountHandlers","GestureMgr","TOUCH_CLICK_DELAY","pointerEventNames","pointerdown","pointerup","pointermove","pointerout","nm","touchstart","mousedown","touchmove","touchend","mouseup","click","handlerDomProxyProto","pointPair","eventUtil","_track","_doTrack","_recognize","touches","trackItem","points","recognizers","pinch","track","pinchEnd","pinchPre","isFinite","pinchCenter","BO","nodeOptions","_data","_oriStartPos","_nextStartPos","_displayAttrDataType","displayAttrDataType","_displayAttrEvent","displayAttrEvent","_boClickable","boClickable","_boPopupOpts","boPopupOpts","_boEventClickable","boEventClickable","_boEventPopupOpts","boEventPopupOpts","_attrEventClickable","attrEventClickable","_attrEventPopupOpts","attrEventPopupOpts","_isCurrent","isCurrent","_boShapeHeight","_group","_boShape","assign","_render","BoName","EventDecision","Line","BoAttr","boProto","_createBoName","_createEventDecision","_createBoAttr","_createBoShape","_boNameShape","clickable","onclick","_click","_calNextShapeStartPos","boEventArr","_eventShape","_boEventArr","_boEventLen","_eventOpts","popupOpts","bindBoClickEvent","boAttrArr","_boAttrShape","_lineShape","_boAttrArr","_boAttrLen","_attrEventStartPos","BoLine","AttrLine","displayDataType","displayEventDecision","eventClickable","eventPopupOpts","AttrEventLine","curShape","BO_NODE_DEFAULT_HEIGHT","Rect","brushType","lineCape","DATA","BO_NAME_FONT","BO_NAME_PADDING_TOP","BO_NAME_PADDING_BOTTOM","BO_EVENT_HEIGHT","BO_EVENT_WIDTH","BO_EVENT_FONT","BO_ATTR_FONT","BO_ATTR_PADDING_TOP","BO_ATTR_PADDING_BOTTOM","BO_ATTR_PADDING_LEFT","BO_ATTR_DATA_TYPE_PADDING_RIGHT","BO_ATTR_EVENT_WIDTH","LINE_DASH","RELATION_OFFSET","RELATION_ARROW_WIDTH","RELATION_ARROW_HEIGHT","RELATION_TEXT_OFFSET_X","RELATION_TEXT_OFFSET_Y","Text","doSingleEnterHover","__isHover","__hoverStlDirty","__hoverStl","colorTool","Gradient","normalStyle","__normalStl","doSingleLeaveHover","normalStl","doEnterHover","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","animateOrSetProps","isUpdate","animatableModel","postfix","duration","getShallow","animationEasing","pathTool","Path","Util","Circle","Sector","Ring","Polygon","Polyline","BezierCurve","Arc","LinearGradient","RadialGradient","States","extendShape","extendPath","pathData","extendFromString","makePath","createFromString","boundingRect","cx","cy","resizePath","mergePath","pathRect","subPixelOptimizeLine","subPixelOptimize","x1","y1","subPixelOptimizeRect","originX","originY","originWidth","originHeight","positiveOrNegative","doubledPosition","setHoverStyle","setNormalStyle","setText","textStyle","labelModel","labelPosition","labelColor","textStyleModel","getModel","getFont","getTextColor","updateProps","initProps","getTransform","ancestor","mat","vertex","transformDirection","direction","hBase","abs","vBase","processArc","fa","fs","rx","ry","psiDeg","cmd","psi","xp","mathCos","mathSin","yp","lambda","mathSqrt","cxp","cyp","theta","vAngle","u","dTheta","vRatio","addData","createPathProxyFromString","cs","cc","RegExp","prevCmd","arr","cpx","cpy","PathProxy","CMD","ctlPtx","ctlPty","M","C","Q","A","Z","toStatic","createPathOptions","pathProxy","setData","rebuildPath","transformPath","pathEls","pathList","pathEl","createPathProxy","__dirtyPath","pathBundle","appendPath","vMag","acos","pathContain","pathProxyForDraw","strokeContainThreshold","hasFillGradient","hasStrokeGradient","hasFillPattern","hasStrokePattern","_fillGradient","_strokeGradient","ctxLineDash","setLineDash","setScale","setLineDashOffset","shapeCfg","inBundle","needsUpdateRect","rectWithStroke","_rectWithStroke","lineScale","localPos","containStroke","dirtyPath","animateShape","setShape","Sub","defaultShape","thisShape","curve","bbox","min2","max2","mathAbs","hasTypedArray","notSaveData","_saveData","_xi","_yi","_x0","_y0","_ux","_uy","_lineDash","_dashOffset","_dashIdx","_dashSum","exceedUnit","_needsDash","_dashedLineTo","bezierCurveTo","x3","y3","_dashedBezierTo","_dashedQuadraticTo","arc","startAngle","endAngle","anticlockwise","arcTo","radius","x0","y0","lineDashSum","appendSize","appendPathData","_expandData","_prevCmd","newData","dash","dashSum","nDash","cubicAt","bezierLen","tmpLen","Number","MAX_VALUE","xi","yi","fromLine","fromCubic","fromQuadratic","fromArc","ux","uy","scaleX","scaleY","isEllipse","isAroundZero","onet","cubicDerivativeAt","cubicRootAt","t1","disc","K","discSqrt","Y1","Y2","mathPow","ONE_THIRD","T","ASqrt","THREE_SQRT","cubicExtrema","extrema","cubicSubdivide","p01","p12","p23","p012","p123","p0123","cubicProjectPoint","d1","d2","interval","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","quadraticAt","quadraticDerivativeAt","quadraticRootAt","quadraticExtremum","divider","quadraticSubdivide","quadraticProjectPoint","_vector","v2Create","fromPoints","xDim","yDim","tx","ty","vec2Min","vec2Max","diff","PI2","end","angle","extremity","isAroundEqual","swapExtrema","windingCubic","nRoots","y0_","y1_","nExtrema","unit","x_","windingQuadratic","y_","windingArc","dir","normalizeRadian","containPath","isStroke","windingLine","cubic","quadratic","_l","_a","_b","_s","_curve","nPoint","mathAtan2","shadowColor","fixClipWithShadow","r0","clockwise","unitX","unitY","orignalBrush","modified","shadowTemp","polyHelper","smooth","smoothConstraint","controlPoints","smoothBezier","cp1","cp2","smoothSpline","interpolate","isLoop","v2Distance","segs","w2","w3","constraint","prevPoint","nextPoint","cps","v2Min","v2Max","point","v2Clone","v2Sub","v2Scale","d0","sum","cp0","v2Add","pointAt","someVectorAt","isTangent","cpx2","cpy2","cpx1","cpy1","tangentAt","globalCoord","vec2Copy","transitionProperties","TransitionObject","_fromStr","property","GraphicStates","_states","_el","_subStates","_transitionAnimators","initialState","_initialState","optsStates","states","state","_addState","setState","_currentState","transition","_extendFromInitial","transiting","_stopTransition","prevState","onleave","onenter","getState","transitionState","styleShapeReg","propPathMap","transitionCfg","animatingCount","animationDone","_animProp","subProp","subStates","subPropKey","stateObj","elObj","availableProp","transitionAnimators","dealy","addSubStates","removeSubStates","EventDecisionNode","_startPos","_type","_clickable","_popupOpts","eventProto","_createEventShape","_createEVentName","eventNameShape","endPos","_line","attrHeight","_style","strokeColor","boAttrData","_keyValue","keyValue","_displayDataType","_displayEventDecision","_eventClickable","_eventPopupOpts","boAttrProto","_createText","_createDataType","attrNameShape","_dataTypeShape","dataType","_boAttrEventArr","boAttrEventArr","_boAttrEventLen","sourceShape","targetShape","_sourceText","_targetText","_lStartPos","_lEndPos","_rStartPos","_rEndPos","_leftDirection","_lineStyle","_lineHoverStyle","_arrowStyle","_arrowHoverStyle","relationProto","_createLine","_createArrow","_linePoints","_createHoverStyle","_arrowPoints","_arrowShape","_sourceTextPos","_targetTextPos","_textAlign","_srcTextShape","_targetTextShape","defineProperty","varArgs","TypeError","to","nextSource","nextKey","writable","configurable","_zrender","vmlCore","comma","imageTransformPrefix","Z2","ZLEVEL_BASE","Z_BASE","initRootElStyle","coordsize","coordorigin","encodeHtmlAttribute","String","rgb2Str","append","getZIndex","setColorAndOpacity","getColorAndAlpha","updateFillNode","zrEl","gradientType","focus","expansion","rectWidth","rectHeight","dimension","stops","cs1","cs2","colorAndAlphaList","colorAndAlpha","color1","color2","opacity1","opacity2","focusposition","updateStrokeNode","dashstyle","updateFillAndStroke","vmlEl","isFill","getElementsByTagName","createNode","pathDataToString","cmdStr","dataLength","brushVML","vmlRoot","_vmlEl","needTransform","strokeEl","weight","zIndex","removeRectText","onRemove","onAdd","appendRectText","isImage","img","tagName","ow","oh","_imageSrc","_imageWidth","_imageHeight","imageRuntimeStyle","runtimeStyle","oldRuntimeWidth","oldRuntimeHeight","dw","dh","sw","sh","hasCrop","doc","vmlElStyle","hasRotation","transformFilter","imageEl","_imageEl","cropEl","_cropEl","imageELStyle","tmpImage","overflow","cropElStyle","filterStr","textMeasureEl","DEFAULT_STYLE_NORMAL","fontStyleCache","fontStyleCacheCount","MAX_FONT_CACHE_SIZE","fontEl","getFontStyle","fontString","variant","fontVariant","size","family","body","ex","createTextNode","offsetWidth","fromTextEl","align","verticalAlign","textPathEl","skewEl","textVmlEl","_textVmlEl","textpathok","coords","textVmlElStyle","toFixed","string","proto","doCreateNode","initVML","vmlInited","styleSheets","createStyleSheet","addRule","urn","win","namespaces","zrvml","VMLPainter","vmlViewport","_vmlRoot","_vmlViewport","_firstPaint","createMethodNotSupport","zrLog","__alreadyNotVisible","_getWidth","_getHeight","vmlViewportStyle","currentStyle","clientWidth","paddingLeft","paddingRight","clientHeight","paddingTop","paddingBottom"],"mappings":"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","file":"fish-topo-bo.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fishTopoBo\"] = factory();\n\telse\n\t\troot[\"fishTopoBo\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fishTopoBo\"] = factory();\n\telse\n\t\troot[\"fishTopoBo\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Export fishTopo as CommonJS module\r\n\t */\r\n\tmodule.exports = __webpack_require__(2);\r\n\t//兼容IE8 引入VML 如果不需要兼容IE8请删除\r\n\t__webpack_require__(82);\r\n\t\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Created by majianan on 16/5/19.\r\n\t *\r\n\t */\r\n\t\r\n\t    var zr = __webpack_require__(3);\r\n\t    var util = __webpack_require__(6);\r\n\t    var BoNode = __webpack_require__(42);\r\n\t    var Relation = __webpack_require__(80);\r\n\t    var Const = __webpack_require__(43);\r\n\t    var graphic = __webpack_require__(45);\r\n\t    var eventTool = __webpack_require__(39);\r\n\t    __webpack_require__(81);\r\n\t\r\n\t    function FishTopoBo(dom, opts) {\r\n\t        /**\r\n\t         * 缩放\r\n\t         * @type {number}\r\n\t         */\r\n\t        this.nowZoom = 1;\r\n\t        this.canScale = true;\r\n\t\r\n\t        /**\r\n\t         * 初始化zrender\r\n\t         */\r\n\t        this._zr = zr.init(dom, {\r\n\t            renderer: opts.renderer || 'canvas',\r\n\t            devicePixelRatio: opts.devicePixelRatio\r\n\t        });\r\n\t    }\r\n\t\r\n\t    var fishTopoProto = FishTopoBo.prototype;\r\n\t\r\n\t    /**\r\n\t     * 初始化\r\n\t     */\r\n\t    fishTopoProto.init = function () {\r\n\t        this.group = new graphic.Group();\r\n\t        this.groupDrag(this.group);\r\n\t        this._zr.add(this.group);\r\n\t        this.zrScale();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 调整尺寸  在窗口大小发生改变时需要手工调用\r\n\t     */\r\n\t    fishTopoProto.resize = function () {\r\n\t        this._zr.resize();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 添加BO\r\n\t     * @param {Object} boData, bo数据\r\n\t     * @param {{\r\n\t     *          startPos: {x: number, y: number} 起始位置,\r\n\t     *          displayAttrDataType: boolean 是否显示属性数据类型,\r\n\t     *          displayAttrEvent: boolean 是否显示属性事件决策,\r\n\t     *          boClickable: boolean BO是否支持点击事件, 可空 默认false\r\n\t     *          boPopupUrl: String 点击BO弹出页面地址\r\n\t     *          boEventClickable: boolean BO事件决策是否支持点击事件, 可空 默认false\r\n\t     *          boEventPopupUrl: String 点击BO事件决策弹出页面地址\r\n\t     *          bindBoClickEvent: function(options) BO点击事件，返回函数参数为options，它的属性有DATA等\r\n\t     *          attrEventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false\r\n\t     *          attrEventPopupUrl: String 点击BO属性事件决策弹出页面地址\r\n\t     *          isCurrent: boolean 是否为当前BO\r\n\t     *          lineStyle: {stroke: string, lineWidth: number, lineDash: Array} 关联线样式\r\n\t     *          lineHoverStyle: {stroke: string, lineWidth: number, lineDash: Array} 关联线hover样式\r\n\t     *          arrowStyle: {fill: string, stroke: string} 关联线箭头样式\r\n\t     *          arrowHoverStyle: {fill: string, stroke: string} 关联线箭头hover样式\r\n\t     *          }} opts\r\n\t     * @returns {*}\r\n\t     */\r\n\t    fishTopoProto.addBo = function (boData, opts) {\r\n\t        //设置BO父子关系，便于后续整体移动\r\n\t        this._setParent(boData);\r\n\t\r\n\t        //layout BO的布局信息，x,y左上角起始坐标, level:层级\r\n\t        boData.layout = {\r\n\t            x: opts.startPos.x,\r\n\t            y: opts.startPos.y,\r\n\t            level: 1\r\n\t        };\r\n\t\r\n\t        //计算BO的X坐标\r\n\t        this._bfs(boData);\r\n\t\r\n\t        //按照起始坐标整体左移\r\n\t        this._moveRightByParent(boData, opts.startPos.x - boData.layout.x);\r\n\t\r\n\t        //画BO\r\n\t        var boNode = new BoNode(boData, opts);\r\n\t        this.group.add(boNode.getShape());\r\n\t\r\n\t        //创建子BO\r\n\t        this.addChildBo(boNode, opts);\r\n\t\r\n\t        return boNode;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 设置BO的父子关系\r\n\t     * @param {Object} boData BO数据\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._setParent = function (boData) {\r\n\t        if (boData.child) {\r\n\t            var childCnt = boData.child.length,\r\n\t                childBoArr = boData.child;\r\n\t            for (var i = 0; i < childCnt; i++) {\r\n\t                childBoArr[i].parent = boData;\r\n\t                if (childBoArr[i + 1]) {\r\n\t                    childBoArr[i].next = childBoArr[i + 1];\r\n\t                }\r\n\t                //设置最后子节点的next=下一个父节点的第一个子节点\r\n\t                else if (boData.next && boData.next.child) {\r\n\t                    childBoArr[i].next = boData.next.child[0];\r\n\t                }\r\n\t                this._setParent(childBoArr[i]);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * Breadth-First-Search 计算X坐标\r\n\t     * 由于BO宽度定死，可以在画图之前计算每个BO的起始X坐标\r\n\t     * 每个BO的高度根据显示内容不固定，因此需要根据实际的父BO高度才能计算本身的起始Y坐标\r\n\t     * @param boData\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._bfs = function (boData) {\r\n\t        //用于保存每个level的最大坐标值\r\n\t        this._levelMaxPos = {};\r\n\t\r\n\t        this._queue = [];   //存放BO数据\r\n\t        this._queue.push(boData);\r\n\t\r\n\t        while (this._queue.length > 0) {\r\n\t            var tmp = this._queue.shift();\r\n\t            //console.log('BO[' + tmp.name + '] {x: ' + tmp.layout.x + ', level: ' + tmp.layout.level + '} ');\r\n\t            //console.log('    ***Before this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);\r\n\t\r\n\t            //该level第一个节点\r\n\t            if (!this._levelMaxPos[tmp.layout.level]) {\r\n\t                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n\t            }\r\n\t            //当前就是最右侧的节点\r\n\t            else if (this._levelMaxPos[tmp.layout.level].x + Const.BO_NODE_WIDTH <= tmp.layout.x) {\r\n\t                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n\t            }\r\n\t            //当前节点与之前的节点有交叉，则需要连同父节点整体向右移动\r\n\t            else {\r\n\t                this._moveRightByChild(tmp, this._levelMaxPos[tmp.layout.level].x - tmp.layout.x + Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X)\r\n\t                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n\t            }\r\n\t\r\n\t            //console.log('    ***After this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);\r\n\t\r\n\t            //存在子节点，计算子节点坐标，同时添加到队列中，以便后续计算调整x坐标\r\n\t            if (tmp.child) {\r\n\t                var childCnt = tmp.child.length;\r\n\t\r\n\t                for (var i = 0; i < childCnt; i++) {\r\n\t\r\n\t                    tmp.child[i].layout = {\r\n\t                        x: tmp.layout.x - (Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X) * ((childCnt - 1) / 2 - i),\r\n\t                        level: tmp.layout.level + 1\r\n\t                    };\r\n\t\r\n\t                    this._queue.push(tmp.child[i]);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 子节点右移时，同时下一个子节点，以及父节点都同时移动\r\n\t     * @param boData\r\n\t     * @param width\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._moveRightByChild = function (boData, width) {\r\n\t        if (boData) {\r\n\t\r\n\t            if (!boData.layout.moved) {\r\n\t\r\n\t                if (boData.layout.level == 1) {\r\n\t                    boData.layout.x += width / 2;\r\n\t                } else {\r\n\t                    boData.layout.x += width;\r\n\t                }\r\n\t\r\n\t                boData.layout.moved = true;\r\n\t            }\r\n\t            //当前节点的下一节点整体右移\r\n\t            this._moveRightByPrevious(boData.next, width);\r\n\t            //当前节点的父节点整体右移\r\n\t            this._moveRightByChild(boData.parent, width);\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 前一个节点右移的时候，所有后面的节点整体右移\r\n\t     * @param boData\r\n\t     * @param width\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._moveRightByPrevious = function (boData, width) {\r\n\t        if (boData) {\r\n\t            boData.layout.x += width;\r\n\t            //当前节点的所有后续节点整体右移\r\n\t            this._moveRightByPrevious(boData.next, width);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 父节点右移时，所有子节点整体右移\r\n\t     * @param boData\r\n\t     * @param width\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._moveRightByParent = function (boData, width) {\r\n\t        if (boData) {\r\n\t            boData.layout.x += width;\r\n\t            if (boData.child) {\r\n\t                for (var i = 0; i < boData.child.length; i++) {\r\n\t                    this._moveRightByParent(boData.child[i], width);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 添加子BO\r\n\t     * @param {BoNode} parentBoNode\r\n\t     * @param {Object} opts\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto.addChildBo = function (parentBoNode, opts) {\r\n\t\r\n\t        this._queue = []; //需要根据BO节点的实际高度计算自己点的起始Y坐标，因此存放的是BoNode图形\r\n\t        this._queue.push(parentBoNode);\r\n\t\r\n\t        while (this._queue.length > 0) {\r\n\t            var tmp = this._queue.shift(),\r\n\t                boNodeHeight = tmp.getShape().getBoundingRect().height;\r\n\t            //console.log('Parent BO[' + tmp.getData().name + '] {y: ' + tmp.getLayout().y + ', level: ' + tmp.getLayout().level + ', boNodeHeight:' + boNodeHeight + '} ');\r\n\t            //console.log('    ***Before this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);\r\n\t\r\n\t            //如果是该Level第一个节点，或者当低于原来的节点\r\n\t            if (!this._levelMaxPos[tmp.getLayout().level].y ||\r\n\t                this._levelMaxPos[tmp.getLayout().level].y < tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y) {\r\n\t                this._levelMaxPos[tmp.getLayout().level].y = tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y;\r\n\t            }\r\n\t\r\n\t            //console.log('    ***After this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);\r\n\t\r\n\t            if (tmp.getData().child) {\r\n\t\r\n\t                var childBoArr = tmp.getData().child,\r\n\t                    childCnt = childBoArr.length,\r\n\t                    boNode,\r\n\t                    relationNode;\r\n\t\r\n\t                //该level所有子节点的起始Y坐标都相同\r\n\t                opts.startPos.y = this._levelMaxPos[tmp.getLayout().level].y;\r\n\t                for (var i = 0; i < childCnt; i++) {\r\n\t                    opts.startPos.x = childBoArr[i].layout.x;\r\n\t                    childBoArr[i].layout.y = opts.startPos.y;\r\n\t                    boNode = new BoNode(childBoArr[i], opts);\r\n\t                    //console.log('Child BO[' + boNode.getData().name + '] {y: ' + opts.startPos.y + ', level: ' + boNode.getLayout().level + '} ');\r\n\t\r\n\t                    this.group.add(boNode.getShape());\r\n\t                    this._queue.push(boNode);\r\n\t\r\n\t                    //BO关系\r\n\t                    if (childBoArr[i].relation) {\r\n\t                        var _relationLen = childBoArr[i].relation.length;\r\n\t                        for (var j = 0; j < _relationLen; j++) {\r\n\t                            var sourceId = childBoArr[i].relation[j].sourceId,\r\n\t                                targetId = childBoArr[i].relation[j].targetId,\r\n\t                                sourceText = childBoArr[i].relation[j].sourceText,\r\n\t                                targetText = childBoArr[i].relation[j].targetText;\r\n\t\r\n\t                            relationNode = new Relation(\r\n\t                                boNode.getShape().childOfName(sourceId),\r\n\t                                tmp.getShape().childOfName(targetId),\r\n\t                                sourceText,\r\n\t                                targetText,\r\n\t                                opts.lineStyle,\r\n\t                                opts.lineHoverStyle,\r\n\t                                opts.arrowStyle,\r\n\t                                opts.arrowHoverStyle\r\n\t                            );\r\n\t                            this.group.add(relationNode.getShape());\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 设置当前BO为特殊样式\r\n\t     * @param {String} boId, BO标识\r\n\t     * @param {Object} style, BO特殊样式,可空\r\n\t     */\r\n\t    fishTopoProto.setCurrentBo = function (boId, style) {\r\n\t        var length = this.group.childCount();\r\n\t        for (var i = 0; i < length; i++) {\r\n\t            if (this.group.childAt(i).name == boId) {\r\n\t                this.group.childAt(i).setCurrent(style);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 清空\r\n\t     */\r\n\t    fishTopoProto.clear = function () {\r\n\t        this._zr.clear();\r\n\t        this.group = new graphic.Group();\r\n\t        this._zr.add(this.group);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 缩放功能\r\n\t     * @param type\r\n\t     */\r\n\t    fishTopoProto.zrScale = function (type) {\r\n\t        var that = this;\r\n\t        if (type) {\r\n\t            if (type == \"narrowing\") {\r\n\t                var zoomDelta = 1 / 1.1;\r\n\t                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n\t            }\r\n\t            if (type == \"enlarge\") {\r\n\t                var zoomDelta = 1.1;\r\n\t                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n\t            }\r\n\t        } else {\r\n\t            that._zr.on('mousewheel', function (e) {\r\n\t                eventTool.stop(e.event);\r\n\t                var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;\r\n\t                zoom(zoomDelta, e.offsetX, e.offsetY);\r\n\t            });\r\n\t        }\r\n\t        ;\r\n\t        function zoom(zoomDelta, zoomX, zoomY) {\r\n\t            if (that.canScale == false) {\r\n\t                return;\r\n\t            }\r\n\t            var target = that.group;\r\n\t            if (target) {\r\n\t                var pos = target.position;\r\n\t                var scale = target.scale;\r\n\t                var newZoom = that._zoom = that._zoom || 1;\r\n\t                newZoom *= zoomDelta;\r\n\t                var zoomScale = newZoom / that._zoom;\r\n\t                // if(newZoom>2.6||newZoom<0.38){\r\n\t                //     return;\r\n\t                // };\r\n\t                that._zoom = newZoom;\r\n\t\r\n\t                that.nowZoom = newZoom;\r\n\t                // Keep the mouse center when scaling\r\n\t                pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);\r\n\t                pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);\r\n\t                scale[0] *= zoomScale;\r\n\t                scale[1] *= zoomScale;\r\n\t                target.attr(\"position\", [pos[0], pos[1]]);\r\n\t                target.attr(\"scale\", [scale[0], scale[1]]);\r\n\t                //that.minimap.updateSelectionPosition(pos,zoomScale);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 拖拽Group\r\n\t     */\r\n\t    fishTopoProto.groupDrag = function () {\r\n\t        var that = this;\r\n\t        that._zr.on(\"mousedown\", function (e) {\r\n\t            groupDragFunction(e);\r\n\t            e.cancelBubble = true;\r\n\t        });\r\n\t        function groupDragFunction(e) {\r\n\t            var startX = e.event.clientX;\r\n\t            var startY = e.event.clientY;\r\n\t            var moveFunction = function (e) {\r\n\t                moveDrag(e);\r\n\t            }\r\n\t            var nowGroupPosition = that.group.position;\r\n\t            var groupPositionX = that.group.position[0];\r\n\t            var groupPositionY = that.group.position[1];\r\n\t            var alarmPositionX, alarmPositionY;\r\n\t\r\n\t            function moveDrag(e) {\r\n\t                var width = that.group.getBoundingRect().width * that.nowZoom;\r\n\t                var height = that.group.getBoundingRect().height * that.nowZoom;\r\n\t                var gx = that.group.getBoundingRect().x * that.nowZoom;\r\n\t                var gy = that.group.getBoundingRect().y * that.nowZoom;\r\n\t                var min = [10 - (width + gx), 10 - (height + gy)];\r\n\t                var max = [(that._zr.getWidth() - gx) - 10, (that._zr.getHeight() - gy) - 10];\r\n\t                var sX = (e.event.clientX - startX) * (that.nowZoom);\r\n\t                var sY = (e.event.clientY - startY) * (that.nowZoom);\r\n\t                nowGroupPosition[0] = groupPositionX + (sX);\r\n\t                nowGroupPosition[1] = groupPositionY + (sY);\r\n\t                if (nowGroupPosition[0] > max[0] || nowGroupPosition[1] > max[1] || nowGroupPosition[0] < min[0] || nowGroupPosition[1] < min[1]) {\r\n\t                    return;\r\n\t                } else {\r\n\t                    that.group.attr(\"position\", nowGroupPosition);\r\n\t                }\r\n\t            }\r\n\t\r\n\t            that._zr.on('mousemove', moveFunction);\r\n\t            var upFunction = function (e) {\r\n\t                endDrag(e);\r\n\t            }\r\n\t\r\n\t            function endDrag(e) {\r\n\t                that._zr.off('mousemove', moveFunction);\r\n\t                that._zr.off('mouseup', upFunction);\r\n\t                that._zr.off(\"globalout\", upFunction);\r\n\t            }\r\n\t\r\n\t            that._zr.on('mouseup', upFunction);\r\n\t            that._zr.on(\"globalout\", upFunction);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 拖拽\r\n\t     * @param node\r\n\t     */\r\n\t    fishTopoProto.drag = function (node) {\r\n\t        var that = this;\r\n\t        node.on(\"mousedown\", function (e) {\r\n\t            if (this.isdraggable == false) {\r\n\t                return;\r\n\t            }\r\n\t            groupDragFunction(e);\r\n\t            e.cancelBubble = true;\r\n\t        });\r\n\t        function groupDragFunction(e) {\r\n\t            var startX = e.event.clientX;\r\n\t            var startY = e.event.clientY;\r\n\t            var moveFunction = function (e) {\r\n\t                moveDrag(e);\r\n\t            }\r\n\t            var nowGroupPosition = node.position;\r\n\t            var groupPositionX = node.position[0];\r\n\t            var groupPositionY = node.position[1];\r\n\t            var alarmPositionX, alarmPositionY;\r\n\t            if (node.alarm) {\r\n\t                var newAlarmPosition = node.alarm.position;\r\n\t                alarmPositionX = node.alarm.position[0];\r\n\t                alarmPositionY = node.alarm.position[1];\r\n\t            }\r\n\t            ;\r\n\t            function moveDrag(e) {\r\n\t                var sX = (e.event.clientX - startX) / (that.nowZoom);\r\n\t                var sY = (e.event.clientY - startY) / (that.nowZoom);\r\n\t                if (node.parent && node.parent instanceof GroupNode) {\r\n\t                    //放入node现有数值，用于重绘group\r\n\t                    var nodeMessage = {\r\n\t                        width: node.shape.width,\r\n\t                        height: node.shape.height,\r\n\t                        position: node.position,\r\n\t                        nodeXY: [node.shape.x, node.shape.y],\r\n\t                        movePosition: [groupPositionX, groupPositionY],\r\n\t                        moveX: sX,\r\n\t                        moveY: sY\r\n\t                    };\r\n\t                    var groupNode = node.parent;\r\n\t                    groupNode.reDraw(nodeMessage, node);\r\n\t                } else {\r\n\t                    nowGroupPosition[0] = groupPositionX + (sX);\r\n\t                    nowGroupPosition[1] = groupPositionY + (sY);\r\n\t                    node.attr(\"position\", nowGroupPosition);\r\n\t                    if (node.alarm) {\r\n\t                        var newAlarmPosition = [nowGroupPosition[0] + node.getBoundingRect().width - (node.alarm.getBoundingRect().width - 6), nowGroupPosition[1] - node.alarm.getBoundingRect().height - 3];\r\n\t                        node.alarm.attr(\"position\", newAlarmPosition);\r\n\t                    }\r\n\t                    ;\r\n\t                }\r\n\t                ConnectionManager.refreshLineByNode(node);\r\n\t            }\r\n\t\r\n\t            that._zr.on('mousemove', moveFunction);\r\n\t            var upFunction = function (e) {\r\n\t                endDrag(e);\r\n\t            }\r\n\t            //拖拽结束\r\n\t            function endDrag(e) {\r\n\t                that._zr.off('mousemove', moveFunction);\r\n\t                that._zr.off('mouseup', upFunction);\r\n\t                that._zr.off(\"globalout\", upFunction);\r\n\t                //布局重新计算\r\n\t                if (node.layout) {\r\n\t                    that.layoutNode(\"tree\", {\"node\": node});\r\n\t                }\r\n\t                if (that.forceLayoutOption) {\r\n\t                    var nodes = that.forceLayoutOption.allNodes;\r\n\t                    if (_.indexOf(nodes, node) != -1) {\r\n\t                        that.layoutNode(\"force\", this.forceLayoutOption);\r\n\t                    }\r\n\t                }\r\n\t                ;\r\n\t            }\r\n\t\r\n\t            that._zr.on('mouseup', upFunction);\r\n\t            that._zr.on(\"globalout\", upFunction);\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    // ---------对外暴露fishTopoBo------------------\r\n\t    var idBase = new Date() - 0;\r\n\t    var instances = {};\r\n\t    var DOM_ATTRIBUTE_KEY = '_fishTopoBo_instance_';\r\n\t    var fishTopoBo = {\r\n\t        /**\r\n\t         * @type {number}\r\n\t         */\r\n\t        version: '3.0.0',\r\n\t        dependencies: {\r\n\t            zrender: '3.0.4'\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @param {HTMLDomElement} dom\r\n\t     * @param {Object} opts\r\n\t     */\r\n\t    fishTopoBo.init = function (dom, opts) {\r\n\t        if (!dom) {\r\n\t            throw new Error('Initialize failed: invalid dom.');\r\n\t        }\r\n\t\r\n\t        opts = opts || {};\r\n\t        // Default value\r\n\t        util.defaults(opts,\r\n\t            {\r\n\t                type: \"bpmn\",\r\n\t                showGridLine: true,\r\n\t                devicePixelRatio: 1,\r\n\t                gridLineSpacing:10\r\n\t            }\r\n\t        );\r\n\t\r\n\t        var fishTopoBo = new FishTopoBo(dom, opts);\r\n\t        fishTopoBo.init();\r\n\t\r\n\t        fishTopoBo.id = 'ft_' + idBase++;\r\n\t        instances[fishTopoBo.id] = fishTopoBo;\r\n\t\r\n\t        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoBo.id);\r\n\t\r\n\t        return fishTopoBo;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * @param  {HTMLDomElement} dom\r\n\t     * @return {fishTopo}\r\n\t     */\r\n\t    fishTopoBo.getInstanceByDom = function (dom) {\r\n\t        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\r\n\t        return instances[key];\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Dispose a fishTopo instance\r\n\t     * @param  {module:fishTopo|HTMLDomElement|string} fishTopo\r\n\t     */\r\n\t    fishTopoBo.dispose = function (chart) {\r\n\t        var topo;\r\n\t        if (zrUtil.isDom(chart)) {\r\n\t            topo = fishTopoBo.getInstanceByDom(chart);\r\n\t        }\r\n\t        else if (typeof chart === 'string') {\r\n\t            topo = instances[chart];\r\n\t        }\r\n\t        if ((topo instanceof fishTopoBo) && !topo.isDisposed()) {\r\n\t            topo.dispose();\r\n\t        }\r\n\t    };\r\n\t\r\n\t    module.exports = fishTopoBo;\r\n\t\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar guid = __webpack_require__(4);\n\t\n\tvar env = __webpack_require__(5);\n\t\n\tvar zrUtil = __webpack_require__(6);\n\t\n\tvar Handler = __webpack_require__(7);\n\t\n\tvar Storage = __webpack_require__(11);\n\t\n\tvar Painter = __webpack_require__(26);\n\t\n\tvar Animation = __webpack_require__(38);\n\t\n\tvar HandlerProxy = __webpack_require__(40);\n\t\n\t/*!\n\t* ZRender, a high performance 2d drawing library.\n\t*\n\t* Copyright (c) 2013, Baidu Inc.\n\t* All rights reserved.\n\t*\n\t* LICENSE\n\t* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n\t*/\n\tvar useVML = !env.canvasSupported;\n\tvar painterCtors = {\n\t  canvas: Painter\n\t};\n\tvar instances = {}; // ZRender实例map索引\n\t\n\t/**\n\t * @type {string}\n\t */\n\t\n\tvar version = '3.7.4';\n\t/**\n\t * Initializing a zrender instance\n\t * @param {HTMLElement} dom\n\t * @param {Object} opts\n\t * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t * @param {number} [opts.devicePixelRatio]\n\t * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n\t * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n\t * @return {module:zrender/ZRender}\n\t */\n\t\n\tfunction init(dom, opts) {\n\t  var zr = new ZRender(guid(), dom, opts);\n\t  instances[zr.id] = zr;\n\t  return zr;\n\t}\n\t/**\n\t * Dispose zrender instance\n\t * @param {module:zrender/ZRender} zr\n\t */\n\t\n\t\n\tfunction dispose(zr) {\n\t  if (zr) {\n\t    zr.dispose();\n\t  } else {\n\t    for (var key in instances) {\n\t      if (instances.hasOwnProperty(key)) {\n\t        instances[key].dispose();\n\t      }\n\t    }\n\t\n\t    instances = {};\n\t  }\n\t\n\t  return this;\n\t}\n\t/**\n\t * Get zrender instance by id\n\t * @param {string} id zrender instance id\n\t * @return {module:zrender/ZRender}\n\t */\n\t\n\t\n\tfunction getInstance(id) {\n\t  return instances[id];\n\t}\n\t\n\tfunction registerPainter(name, Ctor) {\n\t  painterCtors[name] = Ctor;\n\t}\n\t\n\tfunction delInstance(id) {\n\t  delete instances[id];\n\t}\n\t/**\n\t * @module zrender/ZRender\n\t */\n\t\n\t/**\n\t * @constructor\n\t * @alias module:zrender/ZRender\n\t * @param {string} id\n\t * @param {HTMLElement} dom\n\t * @param {Object} opts\n\t * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t * @param {number} [opts.devicePixelRatio]\n\t * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n\t * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n\t */\n\t\n\t\n\tvar ZRender = function (id, dom, opts) {\n\t  opts = opts || {};\n\t  /**\n\t   * @type {HTMLDomElement}\n\t   */\n\t\n\t  this.dom = dom;\n\t  /**\n\t   * @type {string}\n\t   */\n\t\n\t  this.id = id;\n\t  var self = this;\n\t  var storage = new Storage();\n\t  var rendererType = opts.renderer; // TODO WebGL\n\t\n\t  if (useVML) {\n\t    if (!painterCtors.vml) {\n\t      throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n\t    }\n\t\n\t    rendererType = 'vml';\n\t  } else if (!rendererType || !painterCtors[rendererType]) {\n\t    rendererType = 'canvas';\n\t  }\n\t\n\t  var painter = new painterCtors[rendererType](dom, storage, opts);\n\t  this.storage = storage;\n\t  this.painter = painter;\n\t  var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n\t  this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\t  /**\n\t   * @type {module:zrender/animation/Animation}\n\t   */\n\t\n\t  this.animation = new Animation({\n\t    stage: {\n\t      update: zrUtil.bind(this.flush, this)\n\t    }\n\t  });\n\t  this.animation.start();\n\t  /**\n\t   * @type {boolean}\n\t   * @private\n\t   */\n\t\n\t  this._needsRefresh; // 修改 storage.delFromStorage, 每次删除元素之前删除动画\n\t  // FIXME 有点ugly\n\t\n\t  var oldDelFromStorage = storage.delFromStorage;\n\t  var oldAddToStorage = storage.addToStorage;\n\t\n\t  storage.delFromStorage = function (el) {\n\t    oldDelFromStorage.call(storage, el);\n\t    el && el.removeSelfFromZr(self);\n\t  };\n\t\n\t  storage.addToStorage = function (el) {\n\t    oldAddToStorage.call(storage, el);\n\t    el.addSelfToZr(self);\n\t  };\n\t};\n\t\n\tZRender.prototype = {\n\t  constructor: ZRender,\n\t\n\t  /**\n\t   * 获取实例唯一标识\n\t   * @return {string}\n\t   */\n\t  getId: function () {\n\t    return this.id;\n\t  },\n\t\n\t  /**\n\t   * 添加元素\n\t   * @param  {module:zrender/Element} el\n\t   */\n\t  add: function (el) {\n\t    this.storage.addRoot(el);\n\t    this._needsRefresh = true;\n\t  },\n\t\n\t  /**\n\t   * 删除元素\n\t   * @param  {module:zrender/Element} el\n\t   */\n\t  remove: function (el) {\n\t    this.storage.delRoot(el);\n\t    this._needsRefresh = true;\n\t  },\n\t\n\t  /**\n\t   * Change configuration of layer\n\t   * @param {string} zLevel\n\t   * @param {Object} config\n\t   * @param {string} [config.clearColor=0] Clear color\n\t   * @param {string} [config.motionBlur=false] If enable motion blur\n\t   * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n\t  */\n\t  configLayer: function (zLevel, config) {\n\t    this.painter.configLayer(zLevel, config);\n\t    this._needsRefresh = true;\n\t  },\n\t\n\t  /**\n\t   * Repaint the canvas immediately\n\t   */\n\t  refreshImmediately: function () {\n\t    // var start = new Date();\n\t    // Clear needsRefresh ahead to avoid something wrong happens in refresh\n\t    // Or it will cause zrender refreshes again and again.\n\t    this._needsRefresh = false;\n\t    this.painter.refresh();\n\t    /**\n\t     * Avoid trigger zr.refresh in Element#beforeUpdate hook\n\t     */\n\t\n\t    this._needsRefresh = false; // var end = new Date();\n\t    // var log = document.getElementById('log');\n\t    // if (log) {\n\t    //     log.innerHTML = log.innerHTML + '<br>' + (end - start);\n\t    // }\n\t  },\n\t\n\t  /**\n\t   * Mark and repaint the canvas in the next frame of browser\n\t   */\n\t  refresh: function () {\n\t    this._needsRefresh = true;\n\t  },\n\t\n\t  /**\n\t   * Perform all refresh\n\t   */\n\t  flush: function () {\n\t    if (this._needsRefresh) {\n\t      this.refreshImmediately();\n\t    }\n\t\n\t    if (this._needsRefreshHover) {\n\t      this.refreshHoverImmediately();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Add element to hover layer\n\t   * @param  {module:zrender/Element} el\n\t   * @param {Object} style\n\t   */\n\t  addHover: function (el, style) {\n\t    if (this.painter.addHover) {\n\t      this.painter.addHover(el, style);\n\t      this.refreshHover();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Add element from hover layer\n\t   * @param  {module:zrender/Element} el\n\t   */\n\t  removeHover: function (el) {\n\t    if (this.painter.removeHover) {\n\t      this.painter.removeHover(el);\n\t      this.refreshHover();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Clear all hover elements in hover layer\n\t   * @param  {module:zrender/Element} el\n\t   */\n\t  clearHover: function () {\n\t    if (this.painter.clearHover) {\n\t      this.painter.clearHover();\n\t      this.refreshHover();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Refresh hover in next frame\n\t   */\n\t  refreshHover: function () {\n\t    this._needsRefreshHover = true;\n\t  },\n\t\n\t  /**\n\t   * Refresh hover immediately\n\t   */\n\t  refreshHoverImmediately: function () {\n\t    this._needsRefreshHover = false;\n\t    this.painter.refreshHover && this.painter.refreshHover();\n\t  },\n\t\n\t  /**\n\t   * Resize the canvas.\n\t   * Should be invoked when container size is changed\n\t   * @param {Object} [opts]\n\t   * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n\t   * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n\t   */\n\t  resize: function (opts) {\n\t    opts = opts || {};\n\t    this.painter.resize(opts.width, opts.height);\n\t    this.handler.resize();\n\t  },\n\t\n\t  /**\n\t   * Stop and clear all animation immediately\n\t   */\n\t  clearAnimation: function () {\n\t    this.animation.clear();\n\t  },\n\t\n\t  /**\n\t   * Get container width\n\t   */\n\t  getWidth: function () {\n\t    return this.painter.getWidth();\n\t  },\n\t\n\t  /**\n\t   * Get container height\n\t   */\n\t  getHeight: function () {\n\t    return this.painter.getHeight();\n\t  },\n\t\n\t  /**\n\t   * Export the canvas as Base64 URL\n\t   * @param {string} type\n\t   * @param {string} [backgroundColor='#fff']\n\t   * @return {string} Base64 URL\n\t   */\n\t  // toDataURL: function(type, backgroundColor) {\n\t  //     return this.painter.getRenderedCanvas({\n\t  //         backgroundColor: backgroundColor\n\t  //     }).toDataURL(type);\n\t  // },\n\t\n\t  /**\n\t   * Converting a path to image.\n\t   * It has much better performance of drawing image rather than drawing a vector path.\n\t   * @param {module:zrender/graphic/Path} e\n\t   * @param {number} width\n\t   * @param {number} height\n\t   */\n\t  pathToImage: function (e, dpr) {\n\t    return this.painter.pathToImage(e, dpr);\n\t  },\n\t\n\t  /**\n\t   * Set default cursor\n\t   * @param {string} [cursorStyle='default'] 例如 crosshair\n\t   */\n\t  setCursorStyle: function (cursorStyle) {\n\t    this.handler.setCursorStyle(cursorStyle);\n\t  },\n\t\n\t  /**\n\t   * Find hovered element\n\t   * @param {number} x\n\t   * @param {number} y\n\t   * @return {Object} {target, topTarget}\n\t   */\n\t  findHover: function (x, y) {\n\t    return this.handler.findHover(x, y);\n\t  },\n\t\n\t  /**\n\t   * Bind event\n\t   *\n\t   * @param {string} eventName Event name\n\t   * @param {Function} eventHandler Handler function\n\t   * @param {Object} [context] Context object\n\t   */\n\t  on: function (eventName, eventHandler, context) {\n\t    this.handler.on(eventName, eventHandler, context);\n\t  },\n\t\n\t  /**\n\t   * Unbind event\n\t   * @param {string} eventName Event name\n\t   * @param {Function} [eventHandler] Handler function\n\t   */\n\t  off: function (eventName, eventHandler) {\n\t    this.handler.off(eventName, eventHandler);\n\t  },\n\t\n\t  /**\n\t   * Trigger event manually\n\t   *\n\t   * @param {string} eventName Event name\n\t   * @param {event=} event Event object\n\t   */\n\t  trigger: function (eventName, event) {\n\t    this.handler.trigger(eventName, event);\n\t  },\n\t\n\t  /**\n\t   * Clear all objects and the canvas.\n\t   */\n\t  clear: function () {\n\t    this.storage.delRoot();\n\t    this.painter.clear();\n\t  },\n\t\n\t  /**\n\t   * Dispose self.\n\t   */\n\t  dispose: function () {\n\t    this.animation.stop();\n\t    this.clear();\n\t    this.storage.dispose();\n\t    this.painter.dispose();\n\t    this.handler.dispose();\n\t    this.animation = this.storage = this.painter = this.handler = null;\n\t    delInstance(this.id);\n\t  }\n\t};\n\texports.version = version;\n\texports.init = init;\n\texports.dispose = dispose;\n\texports.getInstance = getInstance;\n\texports.registerPainter = registerPainter;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * zrender: 生成唯一id\n\t *\n\t * @author errorrik (errorrik@gmail.com)\n\t */\n\tvar idStart = 0x0907;\n\t\n\tfunction _default() {\n\t  return idStart++;\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * echarts设备环境识别\n\t *\n\t * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\n\t * @author firede[firede@firede.us]\n\t * @desc thanks zepto.\n\t */\n\tvar env = {};\n\t\n\tif (typeof navigator === 'undefined') {\n\t  // In node\n\t  env = {\n\t    browser: {},\n\t    os: {},\n\t    node: true,\n\t    // Assume canvas is supported\n\t    canvasSupported: true,\n\t    svgSupported: true\n\t  };\n\t} else {\n\t  env = detect(navigator.userAgent);\n\t}\n\t\n\tvar _default = env; // Zepto.js\n\t// (c) 2010-2013 Thomas Fuchs\n\t// Zepto.js may be freely distributed under the MIT license.\n\t\n\tfunction detect(ua) {\n\t  var os = {};\n\t  var browser = {}; // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n\t  // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n\t  // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n\t  // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n\t  // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n\t  // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n\t  // var touchpad = webos && ua.match(/TouchPad/);\n\t  // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n\t  // var silk = ua.match(/Silk\\/([\\d._]+)/);\n\t  // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n\t  // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n\t  // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n\t  // var playbook = ua.match(/PlayBook/);\n\t  // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\t\n\t  var firefox = ua.match(/Firefox\\/([\\d.]+)/); // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n\t  // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\t\n\t  var ie = ua.match(/MSIE\\s([\\d.]+)/) // IE 11 Trident/7.0; rv:11.0\n\t  || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n\t  var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\t\n\t  var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:\n\t  // - discern (more) between multiple browsers on android\n\t  // - decide if kindle fire in silk mode is android or not\n\t  // - Firefox on Android doesn't specify the Android version\n\t  // - possibly devide in os, device and browser hashes\n\t  // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\t  // if (android) os.android = true, os.version = android[2];\n\t  // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n\t  // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n\t  // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n\t  // if (webos) os.webos = true, os.version = webos[2];\n\t  // if (touchpad) os.touchpad = true;\n\t  // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n\t  // if (bb10) os.bb10 = true, os.version = bb10[2];\n\t  // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n\t  // if (playbook) browser.playbook = true;\n\t  // if (kindle) os.kindle = true, os.version = kindle[1];\n\t  // if (silk) browser.silk = true, browser.version = silk[1];\n\t  // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n\t  // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\t\n\t  if (firefox) {\n\t    browser.firefox = true;\n\t    browser.version = firefox[1];\n\t  } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n\t  // if (webview) browser.webview = true;\n\t\n\t\n\t  if (ie) {\n\t    browser.ie = true;\n\t    browser.version = ie[1];\n\t  }\n\t\n\t  if (edge) {\n\t    browser.edge = true;\n\t    browser.version = edge[1];\n\t  } // It is difficult to detect WeChat in Win Phone precisely, because ua can\n\t  // not be set on win phone. So we do not consider Win Phone.\n\t\n\t\n\t  if (weChat) {\n\t    browser.weChat = true;\n\t  } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n\t  //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n\t  // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n\t  //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n\t  //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\t\n\t\n\t  return {\n\t    browser: browser,\n\t    os: os,\n\t    node: false,\n\t    // 原生canvas支持，改极端点了\n\t    // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n\t    canvasSupported: !!document.createElement('canvas').getContext,\n\t    svgSupported: typeof SVGRect !== 'undefined',\n\t    // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n\t    // works on most browsers\n\t    // IE10/11 does not support touch event, and MS Edge supports them but not by\n\t    // default, so we dont check navigator.maxTouchPoints for them here.\n\t    touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n\t    // <http://caniuse.com/#search=pointer%20event>.\n\t    pointerEventsSupported: 'onpointerdown' in window // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n\t    // events currently. So we dont use that on other browsers unless tested sufficiently.\n\t    // Although IE 10 supports pointer event, it use old style and is different from the\n\t    // standard. So we exclude that. (IE 10 is hardly used on touch device)\n\t    && (browser.edge || browser.ie && browser.version >= 11)\n\t  };\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * @module zrender/core/util\n\t */\n\t// 用于处理merge时无法遍历Date等对象的问题\n\tvar BUILTIN_OBJECT = {\n\t  '[object Function]': 1,\n\t  '[object RegExp]': 1,\n\t  '[object Date]': 1,\n\t  '[object Error]': 1,\n\t  '[object CanvasGradient]': 1,\n\t  '[object CanvasPattern]': 1,\n\t  // For node-canvas\n\t  '[object Image]': 1,\n\t  '[object Canvas]': 1\n\t};\n\tvar TYPED_ARRAY = {\n\t  '[object Int8Array]': 1,\n\t  '[object Uint8Array]': 1,\n\t  '[object Uint8ClampedArray]': 1,\n\t  '[object Int16Array]': 1,\n\t  '[object Uint16Array]': 1,\n\t  '[object Int32Array]': 1,\n\t  '[object Uint32Array]': 1,\n\t  '[object Float32Array]': 1,\n\t  '[object Float64Array]': 1\n\t};\n\tvar objToString = Object.prototype.toString;\n\tvar arrayProto = Array.prototype;\n\tvar nativeForEach = arrayProto.forEach;\n\tvar nativeFilter = arrayProto.filter;\n\tvar nativeSlice = arrayProto.slice;\n\tvar nativeMap = arrayProto.map;\n\tvar nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.\n\t\n\tvar methods = {};\n\t\n\tfunction $override(name, fn) {\n\t  methods[name] = fn;\n\t}\n\t/**\n\t * Those data types can be cloned:\n\t *     Plain object, Array, TypedArray, number, string, null, undefined.\n\t * Those data types will be assgined using the orginal data:\n\t *     BUILTIN_OBJECT\n\t * Instance of user defined class will be cloned to a plain object, without\n\t * properties in prototype.\n\t * Other data types is not supported (not sure what will happen).\n\t *\n\t * Caution: do not support clone Date, for performance consideration.\n\t * (There might be a large number of date in `series.data`).\n\t * So date should not be modified in and out of echarts.\n\t *\n\t * @param {*} source\n\t * @return {*} new\n\t */\n\t\n\t\n\tfunction clone(source) {\n\t  if (source == null || typeof source != 'object') {\n\t    return source;\n\t  }\n\t\n\t  var result = source;\n\t  var typeStr = objToString.call(source);\n\t\n\t  if (typeStr === '[object Array]') {\n\t    result = [];\n\t\n\t    for (var i = 0, len = source.length; i < len; i++) {\n\t      result[i] = clone(source[i]);\n\t    }\n\t  } else if (TYPED_ARRAY[typeStr]) {\n\t    var Ctor = source.constructor;\n\t\n\t    if (source.constructor.from) {\n\t      result = Ctor.from(source);\n\t    } else {\n\t      result = new Ctor(source.length);\n\t\n\t      for (var i = 0, len = source.length; i < len; i++) {\n\t        result[i] = clone(source[i]);\n\t      }\n\t    }\n\t  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n\t    result = {};\n\t\n\t    for (var key in source) {\n\t      if (source.hasOwnProperty(key)) {\n\t        result[key] = clone(source[key]);\n\t      }\n\t    }\n\t  }\n\t\n\t  return result;\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} target\n\t * @param {*} source\n\t * @param {boolean} [overwrite=false]\n\t */\n\t\n\t\n\tfunction merge(target, source, overwrite) {\n\t  // We should escapse that source is string\n\t  // and enter for ... in ...\n\t  if (!isObject(source) || !isObject(target)) {\n\t    return overwrite ? clone(source) : target;\n\t  }\n\t\n\t  for (var key in source) {\n\t    if (source.hasOwnProperty(key)) {\n\t      var targetProp = target[key];\n\t      var sourceProp = source[key];\n\t\n\t      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {\n\t        // 如果需要递归覆盖，就递归调用merge\n\t        merge(targetProp, sourceProp, overwrite);\n\t      } else if (overwrite || !(key in target)) {\n\t        // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n\t        // NOTE，在 target[key] 不存在的时候也是直接覆盖\n\t        target[key] = clone(source[key], true);\n\t      }\n\t    }\n\t  }\n\t\n\t  return target;\n\t}\n\t/**\n\t * @param {Array} targetAndSources The first item is target, and the rests are source.\n\t * @param {boolean} [overwrite=false]\n\t * @return {*} target\n\t */\n\t\n\t\n\tfunction mergeAll(targetAndSources, overwrite) {\n\t  var result = targetAndSources[0];\n\t\n\t  for (var i = 1, len = targetAndSources.length; i < len; i++) {\n\t    result = merge(result, targetAndSources[i], overwrite);\n\t  }\n\t\n\t  return result;\n\t}\n\t/**\n\t * @param {*} target\n\t * @param {*} source\n\t * @memberOf module:zrender/core/util\n\t */\n\t\n\t\n\tfunction extend(target, source) {\n\t  for (var key in source) {\n\t    if (source.hasOwnProperty(key)) {\n\t      target[key] = source[key];\n\t    }\n\t  }\n\t\n\t  return target;\n\t}\n\t/**\n\t * @param {*} target\n\t * @param {*} source\n\t * @param {boolean} [overlay=false]\n\t * @memberOf module:zrender/core/util\n\t */\n\t\n\t\n\tfunction defaults(target, source, overlay) {\n\t  for (var key in source) {\n\t    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {\n\t      target[key] = source[key];\n\t    }\n\t  }\n\t\n\t  return target;\n\t}\n\t\n\tvar createCanvas = function () {\n\t  return methods.createCanvas();\n\t};\n\t\n\tmethods.createCanvas = function () {\n\t  return document.createElement('canvas');\n\t}; // FIXME\n\t\n\t\n\tvar _ctx;\n\t\n\tfunction getContext() {\n\t  if (!_ctx) {\n\t    // Use util.createCanvas instead of createCanvas\n\t    // because createCanvas may be overwritten in different environment\n\t    _ctx = createCanvas().getContext('2d');\n\t  }\n\t\n\t  return _ctx;\n\t}\n\t/**\n\t * 查询数组中元素的index\n\t * @memberOf module:zrender/core/util\n\t */\n\t\n\t\n\tfunction indexOf(array, value) {\n\t  if (array) {\n\t    if (array.indexOf) {\n\t      return array.indexOf(value);\n\t    }\n\t\n\t    for (var i = 0, len = array.length; i < len; i++) {\n\t      if (array[i] === value) {\n\t        return i;\n\t      }\n\t    }\n\t  }\n\t\n\t  return -1;\n\t}\n\t/**\n\t * 构造类继承关系\n\t *\n\t * @memberOf module:zrender/core/util\n\t * @param {Function} clazz 源类\n\t * @param {Function} baseClazz 基类\n\t */\n\t\n\t\n\tfunction inherits(clazz, baseClazz) {\n\t  var clazzPrototype = clazz.prototype;\n\t\n\t  function F() {}\n\t\n\t  F.prototype = baseClazz.prototype;\n\t  clazz.prototype = new F();\n\t\n\t  for (var prop in clazzPrototype) {\n\t    clazz.prototype[prop] = clazzPrototype[prop];\n\t  }\n\t\n\t  clazz.prototype.constructor = clazz;\n\t  clazz.superClass = baseClazz;\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {Object|Function} target\n\t * @param {Object|Function} sorce\n\t * @param {boolean} overlay\n\t */\n\t\n\t\n\tfunction mixin(target, source, overlay) {\n\t  target = 'prototype' in target ? target.prototype : target;\n\t  source = 'prototype' in source ? source.prototype : source;\n\t  defaults(target, source, overlay);\n\t}\n\t/**\n\t * Consider typed array.\n\t * @param {Array|TypedArray} data\n\t */\n\t\n\t\n\tfunction isArrayLike(data) {\n\t  if (!data) {\n\t    return;\n\t  }\n\t\n\t  if (typeof data == 'string') {\n\t    return false;\n\t  }\n\t\n\t  return typeof data.length == 'number';\n\t}\n\t/**\n\t * 数组或对象遍历\n\t * @memberOf module:zrender/core/util\n\t * @param {Object|Array} obj\n\t * @param {Function} cb\n\t * @param {*} [context]\n\t */\n\t\n\t\n\tfunction each(obj, cb, context) {\n\t  if (!(obj && cb)) {\n\t    return;\n\t  }\n\t\n\t  if (obj.forEach && obj.forEach === nativeForEach) {\n\t    obj.forEach(cb, context);\n\t  } else if (obj.length === +obj.length) {\n\t    for (var i = 0, len = obj.length; i < len; i++) {\n\t      cb.call(context, obj[i], i, obj);\n\t    }\n\t  } else {\n\t    for (var key in obj) {\n\t      if (obj.hasOwnProperty(key)) {\n\t        cb.call(context, obj[key], key, obj);\n\t      }\n\t    }\n\t  }\n\t}\n\t/**\n\t * 数组映射\n\t * @memberOf module:zrender/core/util\n\t * @param {Array} obj\n\t * @param {Function} cb\n\t * @param {*} [context]\n\t * @return {Array}\n\t */\n\t\n\t\n\tfunction map(obj, cb, context) {\n\t  if (!(obj && cb)) {\n\t    return;\n\t  }\n\t\n\t  if (obj.map && obj.map === nativeMap) {\n\t    return obj.map(cb, context);\n\t  } else {\n\t    var result = [];\n\t\n\t    for (var i = 0, len = obj.length; i < len; i++) {\n\t      result.push(cb.call(context, obj[i], i, obj));\n\t    }\n\t\n\t    return result;\n\t  }\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {Array} obj\n\t * @param {Function} cb\n\t * @param {Object} [memo]\n\t * @param {*} [context]\n\t * @return {Array}\n\t */\n\t\n\t\n\tfunction reduce(obj, cb, memo, context) {\n\t  if (!(obj && cb)) {\n\t    return;\n\t  }\n\t\n\t  if (obj.reduce && obj.reduce === nativeReduce) {\n\t    return obj.reduce(cb, memo, context);\n\t  } else {\n\t    for (var i = 0, len = obj.length; i < len; i++) {\n\t      memo = cb.call(context, memo, obj[i], i, obj);\n\t    }\n\t\n\t    return memo;\n\t  }\n\t}\n\t/**\n\t * 数组过滤\n\t * @memberOf module:zrender/core/util\n\t * @param {Array} obj\n\t * @param {Function} cb\n\t * @param {*} [context]\n\t * @return {Array}\n\t */\n\t\n\t\n\tfunction filter(obj, cb, context) {\n\t  if (!(obj && cb)) {\n\t    return;\n\t  }\n\t\n\t  if (obj.filter && obj.filter === nativeFilter) {\n\t    return obj.filter(cb, context);\n\t  } else {\n\t    var result = [];\n\t\n\t    for (var i = 0, len = obj.length; i < len; i++) {\n\t      if (cb.call(context, obj[i], i, obj)) {\n\t        result.push(obj[i]);\n\t      }\n\t    }\n\t\n\t    return result;\n\t  }\n\t}\n\t/**\n\t * 数组项查找\n\t * @memberOf module:zrender/core/util\n\t * @param {Array} obj\n\t * @param {Function} cb\n\t * @param {*} [context]\n\t * @return {*}\n\t */\n\t\n\t\n\tfunction find(obj, cb, context) {\n\t  if (!(obj && cb)) {\n\t    return;\n\t  }\n\t\n\t  for (var i = 0, len = obj.length; i < len; i++) {\n\t    if (cb.call(context, obj[i], i, obj)) {\n\t      return obj[i];\n\t    }\n\t  }\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {Function} func\n\t * @param {*} context\n\t * @return {Function}\n\t */\n\t\n\t\n\tfunction bind(func, context) {\n\t  var args = nativeSlice.call(arguments, 2);\n\t  return function () {\n\t    return func.apply(context, args.concat(nativeSlice.call(arguments)));\n\t  };\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {Function} func\n\t * @return {Function}\n\t */\n\t\n\t\n\tfunction curry(func) {\n\t  var args = nativeSlice.call(arguments, 1);\n\t  return function () {\n\t    return func.apply(this, args.concat(nativeSlice.call(arguments)));\n\t  };\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isArray(value) {\n\t  return objToString.call(value) === '[object Array]';\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isFunction(value) {\n\t  return typeof value === 'function';\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isString(value) {\n\t  return objToString.call(value) === '[object String]';\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isObject(value) {\n\t  // Avoid a V8 JIT bug in Chrome 19-20.\n\t  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t  var type = typeof value;\n\t  return type === 'function' || !!value && type == 'object';\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isBuiltInObject(value) {\n\t  return !!BUILTIN_OBJECT[objToString.call(value)];\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isDom(value) {\n\t  return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';\n\t}\n\t/**\n\t * Whether is exactly NaN. Notice isNaN('a') returns true.\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction eqNaN(value) {\n\t  return value !== value;\n\t}\n\t/**\n\t * If value1 is not null, then return value1, otherwise judget rest of values.\n\t * Low performance.\n\t * @memberOf module:zrender/core/util\n\t * @return {*} Final value\n\t */\n\t\n\t\n\tfunction retrieve(values) {\n\t  for (var i = 0, len = arguments.length; i < len; i++) {\n\t    if (arguments[i] != null) {\n\t      return arguments[i];\n\t    }\n\t  }\n\t}\n\t\n\tfunction retrieve2(value0, value1) {\n\t  return value0 != null ? value0 : value1;\n\t}\n\t\n\tfunction retrieve3(value0, value1, value2) {\n\t  return value0 != null ? value0 : value1 != null ? value1 : value2;\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {Array} arr\n\t * @param {number} startIndex\n\t * @param {number} endIndex\n\t * @return {Array}\n\t */\n\t\n\t\n\tfunction slice() {\n\t  return Function.call.apply(nativeSlice, arguments);\n\t}\n\t/**\n\t * Normalize css liked array configuration\n\t * e.g.\n\t *  3 => [3, 3, 3, 3]\n\t *  [4, 2] => [4, 2, 4, 2]\n\t *  [4, 3, 2] => [4, 3, 2, 3]\n\t * @param {number|Array.<number>} val\n\t * @return {Array.<number>}\n\t */\n\t\n\t\n\tfunction normalizeCssArray(val) {\n\t  if (typeof val === 'number') {\n\t    return [val, val, val, val];\n\t  }\n\t\n\t  var len = val.length;\n\t\n\t  if (len === 2) {\n\t    // vertical | horizontal\n\t    return [val[0], val[1], val[0], val[1]];\n\t  } else if (len === 3) {\n\t    // top | horizontal | bottom\n\t    return [val[0], val[1], val[2], val[1]];\n\t  }\n\t\n\t  return val;\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {boolean} condition\n\t * @param {string} message\n\t */\n\t\n\t\n\tfunction assert(condition, message) {\n\t  if (!condition) {\n\t    throw new Error(message);\n\t  }\n\t}\n\t\n\tvar primitiveKey = '__ec_primitive__';\n\t/**\n\t * Set an object as primitive to be ignored traversing children in clone or merge\n\t */\n\t\n\tfunction setAsPrimitive(obj) {\n\t  obj[primitiveKey] = true;\n\t}\n\t\n\tfunction isPrimitive(obj) {\n\t  return obj[primitiveKey];\n\t}\n\t/**\n\t * @constructor\n\t * @param {Object} obj Only apply `ownProperty`.\n\t */\n\t\n\t\n\tfunction HashMap(obj) {\n\t  obj && each(obj, function (value, key) {\n\t    this.set(key, value);\n\t  }, this);\n\t} // Add prefix to avoid conflict with Object.prototype.\n\t\n\t\n\tvar HASH_MAP_PREFIX = '_ec_';\n\tvar HASH_MAP_PREFIX_LENGTH = 4;\n\tHashMap.prototype = {\n\t  constructor: HashMap,\n\t  // Do not provide `has` method to avoid defining what is `has`.\n\t  // (We usually treat `null` and `undefined` as the same, different\n\t  // from ES6 Map).\n\t  get: function (key) {\n\t    return this[HASH_MAP_PREFIX + key];\n\t  },\n\t  set: function (key, value) {\n\t    this[HASH_MAP_PREFIX + key] = value; // Comparing with invocation chaining, `return value` is more commonly\n\t    // used in this case: `var someVal = map.set('a', genVal());`\n\t\n\t    return value;\n\t  },\n\t  // Although util.each can be performed on this hashMap directly, user\n\t  // should not use the exposed keys, who are prefixed.\n\t  each: function (cb, context) {\n\t    context !== void 0 && (cb = bind(cb, context));\n\t\n\t    for (var prefixedKey in this) {\n\t      this.hasOwnProperty(prefixedKey) && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n\t    }\n\t  },\n\t  // Do not use this method if performance sensitive.\n\t  removeKey: function (key) {\n\t    delete this[HASH_MAP_PREFIX + key];\n\t  }\n\t};\n\t\n\tfunction createHashMap(obj) {\n\t  return new HashMap(obj);\n\t}\n\t\n\tfunction noop() {}\n\t\n\texports.$override = $override;\n\texports.clone = clone;\n\texports.merge = merge;\n\texports.mergeAll = mergeAll;\n\texports.extend = extend;\n\texports.defaults = defaults;\n\texports.createCanvas = createCanvas;\n\texports.getContext = getContext;\n\texports.indexOf = indexOf;\n\texports.inherits = inherits;\n\texports.mixin = mixin;\n\texports.isArrayLike = isArrayLike;\n\texports.each = each;\n\texports.map = map;\n\texports.reduce = reduce;\n\texports.filter = filter;\n\texports.find = find;\n\texports.bind = bind;\n\texports.curry = curry;\n\texports.isArray = isArray;\n\texports.isFunction = isFunction;\n\texports.isString = isString;\n\texports.isObject = isObject;\n\texports.isBuiltInObject = isBuiltInObject;\n\texports.isDom = isDom;\n\texports.eqNaN = eqNaN;\n\texports.retrieve = retrieve;\n\texports.retrieve2 = retrieve2;\n\texports.retrieve3 = retrieve3;\n\texports.slice = slice;\n\texports.normalizeCssArray = normalizeCssArray;\n\texports.assert = assert;\n\texports.setAsPrimitive = setAsPrimitive;\n\texports.isPrimitive = isPrimitive;\n\texports.createHashMap = createHashMap;\n\texports.noop = noop;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(6);\n\t\n\tvar vec2 = __webpack_require__(8);\n\t\n\tvar Draggable = __webpack_require__(9);\n\t\n\tvar Eventful = __webpack_require__(10);\n\t\n\t/**\n\t * Handler\n\t * @module zrender/Handler\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (shenyi.914@gmail.com)\n\t */\n\tvar SILENT = 'silent';\n\t\n\tfunction makeEventPacket(eveType, targetInfo, event) {\n\t  return {\n\t    type: eveType,\n\t    event: event,\n\t    // target can only be an element that is not silent.\n\t    target: targetInfo.target,\n\t    // topTarget can be a silent element.\n\t    topTarget: targetInfo.topTarget,\n\t    cancelBubble: false,\n\t    offsetX: event.zrX,\n\t    offsetY: event.zrY,\n\t    gestureEvent: event.gestureEvent,\n\t    pinchX: event.pinchX,\n\t    pinchY: event.pinchY,\n\t    pinchScale: event.pinchScale,\n\t    wheelDelta: event.zrDelta,\n\t    zrByTouch: event.zrByTouch,\n\t    which: event.which\n\t  };\n\t}\n\t\n\tfunction EmptyProxy() {}\n\t\n\tEmptyProxy.prototype.dispose = function () {};\n\t\n\tvar handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n\t/**\n\t * @alias module:zrender/Handler\n\t * @constructor\n\t * @extends module:zrender/mixin/Eventful\n\t * @param {module:zrender/Storage} storage Storage instance.\n\t * @param {module:zrender/Painter} painter Painter instance.\n\t * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n\t * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n\t */\n\t\n\tvar Handler = function (storage, painter, proxy, painterRoot) {\n\t  Eventful.call(this);\n\t  this.storage = storage;\n\t  this.painter = painter;\n\t  this.painterRoot = painterRoot;\n\t  proxy = proxy || new EmptyProxy();\n\t  /**\n\t   * Proxy of event. can be Dom, WebGLSurface, etc.\n\t   */\n\t\n\t  this.proxy = proxy; // Attach handler\n\t\n\t  proxy.handler = this;\n\t  /**\n\t   * {target, topTarget, x, y}\n\t   * @private\n\t   * @type {Object}\n\t   */\n\t\n\t  this._hovered = {};\n\t  /**\n\t   * @private\n\t   * @type {Date}\n\t   */\n\t\n\t  this._lastTouchMoment;\n\t  /**\n\t   * @private\n\t   * @type {number}\n\t   */\n\t\n\t  this._lastX;\n\t  /**\n\t   * @private\n\t   * @type {number}\n\t   */\n\t\n\t  this._lastY;\n\t  Draggable.call(this);\n\t  util.each(handlerNames, function (name) {\n\t    proxy.on && proxy.on(name, this[name], this);\n\t  }, this);\n\t};\n\t\n\tHandler.prototype = {\n\t  constructor: Handler,\n\t  mousemove: function (event) {\n\t    var x = event.zrX;\n\t    var y = event.zrY;\n\t    var lastHovered = this._hovered;\n\t    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call\n\t    // (like 'setOption' or 'dispatchAction') in event handlers, we should find\n\t    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.\n\t    // See #6198.\n\t\n\t    if (lastHoveredTarget && !lastHoveredTarget.__zr) {\n\t      lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n\t      lastHoveredTarget = lastHovered.target;\n\t    }\n\t\n\t    var hovered = this._hovered = this.findHover(x, y);\n\t    var hoveredTarget = hovered.target;\n\t    var proxy = this.proxy;\n\t    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element\n\t\n\t    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n\t      this.dispatchToElement(lastHovered, 'mouseout', event);\n\t    } // Mouse moving on one element\n\t\n\t\n\t    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element\n\t\n\t    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n\t      this.dispatchToElement(hovered, 'mouseover', event);\n\t    }\n\t  },\n\t  mouseout: function (event) {\n\t    this.dispatchToElement(this._hovered, 'mouseout', event); // There might be some doms created by upper layer application\n\t    // at the same level of painter.getViewportRoot() (e.g., tooltip\n\t    // dom created by echarts), where 'globalout' event should not\n\t    // be triggered when mouse enters these doms. (But 'mouseout'\n\t    // should be triggered at the original hovered element as usual).\n\t\n\t    var element = event.toElement || event.relatedTarget;\n\t    var innerDom;\n\t\n\t    do {\n\t      element = element && element.parentNode;\n\t    } while (element && element.nodeType != 9 && !(innerDom = element === this.painterRoot));\n\t\n\t    !innerDom && this.trigger('globalout', {\n\t      event: event\n\t    });\n\t  },\n\t\n\t  /**\n\t   * Resize\n\t   */\n\t  resize: function (event) {\n\t    this._hovered = {};\n\t  },\n\t\n\t  /**\n\t   * Dispatch event\n\t   * @param {string} eventName\n\t   * @param {event=} eventArgs\n\t   */\n\t  dispatch: function (eventName, eventArgs) {\n\t    var handler = this[eventName];\n\t    handler && handler.call(this, eventArgs);\n\t  },\n\t\n\t  /**\n\t   * Dispose\n\t   */\n\t  dispose: function () {\n\t    this.proxy.dispose();\n\t    this.storage = this.proxy = this.painter = null;\n\t  },\n\t\n\t  /**\n\t   * 设置默认的cursor style\n\t   * @param {string} [cursorStyle='default'] 例如 crosshair\n\t   */\n\t  setCursorStyle: function (cursorStyle) {\n\t    var proxy = this.proxy;\n\t    proxy.setCursor && proxy.setCursor(cursorStyle);\n\t  },\n\t\n\t  /**\n\t   * 事件分发代理\n\t   *\n\t   * @private\n\t   * @param {Object} targetInfo {target, topTarget} 目标图形元素\n\t   * @param {string} eventName 事件名称\n\t   * @param {Object} event 事件对象\n\t   */\n\t  dispatchToElement: function (targetInfo, eventName, event) {\n\t    targetInfo = targetInfo || {};\n\t    var el = targetInfo.target;\n\t\n\t    if (el && el.silent) {\n\t      return;\n\t    }\n\t\n\t    var eventHandler = 'on' + eventName;\n\t    var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\t\n\t    while (el) {\n\t      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\t      el.trigger(eventName, eventPacket);\n\t      el = el.parent;\n\t\n\t      if (eventPacket.cancelBubble) {\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (!eventPacket.cancelBubble) {\n\t      // 冒泡到顶级 zrender 对象\n\t      this.trigger(eventName, eventPacket); // 分发事件到用户自定义层\n\t      // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n\t\n\t      this.painter && this.painter.eachOtherLayer(function (layer) {\n\t        if (typeof layer[eventHandler] == 'function') {\n\t          layer[eventHandler].call(layer, eventPacket);\n\t        }\n\t\n\t        if (layer.trigger) {\n\t          layer.trigger(eventName, eventPacket);\n\t        }\n\t      });\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @private\n\t   * @param {number} x\n\t   * @param {number} y\n\t   * @param {module:zrender/graphic/Displayable} exclude\n\t   * @return {model:zrender/Element}\n\t   * @method\n\t   */\n\t  findHover: function (x, y, exclude) {\n\t    var list = this.storage.getDisplayList();\n\t    var out = {\n\t      x: x,\n\t      y: y\n\t    };\n\t\n\t    for (var i = list.length - 1; i >= 0; i--) {\n\t      var hoverCheckResult;\n\t\n\t      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode\n\t      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {\n\t        !out.topTarget && (out.topTarget = list[i]);\n\t\n\t        if (hoverCheckResult !== SILENT) {\n\t          out.target = list[i];\n\t          break;\n\t        }\n\t      }\n\t    }\n\t\n\t    return out;\n\t  }\n\t}; // Common handlers\n\t\n\tutil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n\t  Handler.prototype[name] = function (event) {\n\t    // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n\t    var hovered = this.findHover(event.zrX, event.zrY);\n\t    var hoveredTarget = hovered.target;\n\t\n\t    if (name === 'mousedown') {\n\t      this._downEl = hoveredTarget;\n\t      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup\n\t\n\t      this._upEl = hoveredTarget;\n\t    } else if (name === 'mosueup') {\n\t      this._upEl = hoveredTarget;\n\t    } else if (name === 'click') {\n\t      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,\n\t      // including the case that `mousedown` - `mousemove` - `mouseup`,\n\t      // which should be filtered, otherwise it will bring trouble to\n\t      // pan and zoom.\n\t      || !this._downPoint // Arbitrary value\n\t      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {\n\t        return;\n\t      }\n\t\n\t      this._downPoint = null;\n\t    }\n\t\n\t    this.dispatchToElement(hovered, name, event);\n\t  };\n\t});\n\t\n\tfunction isHover(displayable, x, y) {\n\t  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n\t    var el = displayable;\n\t    var isSilent;\n\t\n\t    while (el) {\n\t      // If clipped by ancestor.\n\t      // FIXME: If clipPath has neither stroke nor fill,\n\t      // el.clipPath.contain(x, y) will always return false.\n\t      if (el.clipPath && !el.clipPath.contain(x, y)) {\n\t        return false;\n\t      }\n\t\n\t      if (el.silent) {\n\t        isSilent = true;\n\t      }\n\t\n\t      el = el.parent;\n\t    }\n\t\n\t    return isSilent ? SILENT : true;\n\t  }\n\t\n\t  return false;\n\t}\n\t\n\tutil.mixin(Handler, Eventful);\n\tutil.mixin(Handler, Draggable);\n\tvar _default = Handler;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n\tvar ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n\t/**\n\t * 创建一个向量\n\t * @param {number} [x=0]\n\t * @param {number} [y=0]\n\t * @return {Vector2}\n\t */\n\t\n\tfunction create(x, y) {\n\t  var out = new ArrayCtor(2);\n\t\n\t  if (x == null) {\n\t    x = 0;\n\t  }\n\t\n\t  if (y == null) {\n\t    y = 0;\n\t  }\n\t\n\t  out[0] = x;\n\t  out[1] = y;\n\t  return out;\n\t}\n\t/**\n\t * 复制向量数据\n\t * @param {Vector2} out\n\t * @param {Vector2} v\n\t * @return {Vector2}\n\t */\n\t\n\t\n\tfunction copy(out, v) {\n\t  out[0] = v[0];\n\t  out[1] = v[1];\n\t  return out;\n\t}\n\t/**\n\t * 克隆一个向量\n\t * @param {Vector2} v\n\t * @return {Vector2}\n\t */\n\t\n\t\n\tfunction clone(v) {\n\t  var out = new ArrayCtor(2);\n\t  out[0] = v[0];\n\t  out[1] = v[1];\n\t  return out;\n\t}\n\t/**\n\t * 设置向量的两个项\n\t * @param {Vector2} out\n\t * @param {number} a\n\t * @param {number} b\n\t * @return {Vector2} 结果\n\t */\n\t\n\t\n\tfunction set(out, a, b) {\n\t  out[0] = a;\n\t  out[1] = b;\n\t  return out;\n\t}\n\t/**\n\t * 向量相加\n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t */\n\t\n\t\n\tfunction add(out, v1, v2) {\n\t  out[0] = v1[0] + v2[0];\n\t  out[1] = v1[1] + v2[1];\n\t  return out;\n\t}\n\t/**\n\t * 向量缩放后相加\n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t * @param {number} a\n\t */\n\t\n\t\n\tfunction scaleAndAdd(out, v1, v2, a) {\n\t  out[0] = v1[0] + v2[0] * a;\n\t  out[1] = v1[1] + v2[1] * a;\n\t  return out;\n\t}\n\t/**\n\t * 向量相减\n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t */\n\t\n\t\n\tfunction sub(out, v1, v2) {\n\t  out[0] = v1[0] - v2[0];\n\t  out[1] = v1[1] - v2[1];\n\t  return out;\n\t}\n\t/**\n\t * 向量长度\n\t * @param {Vector2} v\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction len(v) {\n\t  return Math.sqrt(lenSquare(v));\n\t}\n\t\n\tvar length = len; // jshint ignore:line\n\t\n\t/**\n\t * 向量长度平方\n\t * @param {Vector2} v\n\t * @return {number}\n\t */\n\t\n\tfunction lenSquare(v) {\n\t  return v[0] * v[0] + v[1] * v[1];\n\t}\n\t\n\tvar lengthSquare = lenSquare;\n\t/**\n\t * 向量乘法\n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t */\n\t\n\tfunction mul(out, v1, v2) {\n\t  out[0] = v1[0] * v2[0];\n\t  out[1] = v1[1] * v2[1];\n\t  return out;\n\t}\n\t/**\n\t * 向量除法\n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t */\n\t\n\t\n\tfunction div(out, v1, v2) {\n\t  out[0] = v1[0] / v2[0];\n\t  out[1] = v1[1] / v2[1];\n\t  return out;\n\t}\n\t/**\n\t * 向量点乘\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction dot(v1, v2) {\n\t  return v1[0] * v2[0] + v1[1] * v2[1];\n\t}\n\t/**\n\t * 向量缩放\n\t * @param {Vector2} out\n\t * @param {Vector2} v\n\t * @param {number} s\n\t */\n\t\n\t\n\tfunction scale(out, v, s) {\n\t  out[0] = v[0] * s;\n\t  out[1] = v[1] * s;\n\t  return out;\n\t}\n\t/**\n\t * 向量归一化\n\t * @param {Vector2} out\n\t * @param {Vector2} v\n\t */\n\t\n\t\n\tfunction normalize(out, v) {\n\t  var d = len(v);\n\t\n\t  if (d === 0) {\n\t    out[0] = 0;\n\t    out[1] = 0;\n\t  } else {\n\t    out[0] = v[0] / d;\n\t    out[1] = v[1] / d;\n\t  }\n\t\n\t  return out;\n\t}\n\t/**\n\t * 计算向量间距离\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction distance(v1, v2) {\n\t  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));\n\t}\n\t\n\tvar dist = distance;\n\t/**\n\t * 向量距离平方\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t * @return {number}\n\t */\n\t\n\tfunction distanceSquare(v1, v2) {\n\t  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n\t}\n\t\n\tvar distSquare = distanceSquare;\n\t/**\n\t * 求负向量\n\t * @param {Vector2} out\n\t * @param {Vector2} v\n\t */\n\t\n\tfunction negate(out, v) {\n\t  out[0] = -v[0];\n\t  out[1] = -v[1];\n\t  return out;\n\t}\n\t/**\n\t * 插值两个点\n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t * @param {number} t\n\t */\n\t\n\t\n\tfunction lerp(out, v1, v2, t) {\n\t  out[0] = v1[0] + t * (v2[0] - v1[0]);\n\t  out[1] = v1[1] + t * (v2[1] - v1[1]);\n\t  return out;\n\t}\n\t/**\n\t * 矩阵左乘向量\n\t * @param {Vector2} out\n\t * @param {Vector2} v\n\t * @param {Vector2} m\n\t */\n\t\n\t\n\tfunction applyTransform(out, v, m) {\n\t  var x = v[0];\n\t  var y = v[1];\n\t  out[0] = m[0] * x + m[2] * y + m[4];\n\t  out[1] = m[1] * x + m[3] * y + m[5];\n\t  return out;\n\t}\n\t/**\n\t * 求两个向量最小值\n\t * @param  {Vector2} out\n\t * @param  {Vector2} v1\n\t * @param  {Vector2} v2\n\t */\n\t\n\t\n\tfunction min(out, v1, v2) {\n\t  out[0] = Math.min(v1[0], v2[0]);\n\t  out[1] = Math.min(v1[1], v2[1]);\n\t  return out;\n\t}\n\t/**\n\t * 求两个向量最大值\n\t * @param  {Vector2} out\n\t * @param  {Vector2} v1\n\t * @param  {Vector2} v2\n\t */\n\t\n\t\n\tfunction max(out, v1, v2) {\n\t  out[0] = Math.max(v1[0], v2[0]);\n\t  out[1] = Math.max(v1[1], v2[1]);\n\t  return out;\n\t}\n\t\n\texports.create = create;\n\texports.copy = copy;\n\texports.clone = clone;\n\texports.set = set;\n\texports.add = add;\n\texports.scaleAndAdd = scaleAndAdd;\n\texports.sub = sub;\n\texports.len = len;\n\texports.length = length;\n\texports.lenSquare = lenSquare;\n\texports.lengthSquare = lengthSquare;\n\texports.mul = mul;\n\texports.div = div;\n\texports.dot = dot;\n\texports.scale = scale;\n\texports.normalize = normalize;\n\texports.distance = distance;\n\texports.dist = dist;\n\texports.distanceSquare = distanceSquare;\n\texports.distSquare = distSquare;\n\texports.negate = negate;\n\texports.lerp = lerp;\n\texports.applyTransform = applyTransform;\n\texports.min = min;\n\texports.max = max;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\n\t// TODO Draggable for group\n\t// FIXME Draggable on element which has parent rotation or scale\n\tfunction Draggable() {\n\t  this.on('mousedown', this._dragStart, this);\n\t  this.on('mousemove', this._drag, this);\n\t  this.on('mouseup', this._dragEnd, this);\n\t  this.on('globalout', this._dragEnd, this); // this._dropTarget = null;\n\t  // this._draggingTarget = null;\n\t  // this._x = 0;\n\t  // this._y = 0;\n\t}\n\t\n\tDraggable.prototype = {\n\t  constructor: Draggable,\n\t  _dragStart: function (e) {\n\t    var draggingTarget = e.target;\n\t\n\t    if (draggingTarget && draggingTarget.draggable) {\n\t      this._draggingTarget = draggingTarget;\n\t      draggingTarget.dragging = true;\n\t      this._x = e.offsetX;\n\t      this._y = e.offsetY;\n\t      this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n\t    }\n\t  },\n\t  _drag: function (e) {\n\t    var draggingTarget = this._draggingTarget;\n\t\n\t    if (draggingTarget) {\n\t      var x = e.offsetX;\n\t      var y = e.offsetY;\n\t      var dx = x - this._x;\n\t      var dy = y - this._y;\n\t      this._x = x;\n\t      this._y = y;\n\t      draggingTarget.drift(dx, dy, e);\n\t      this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n\t      var dropTarget = this.findHover(x, y, draggingTarget).target;\n\t      var lastDropTarget = this._dropTarget;\n\t      this._dropTarget = dropTarget;\n\t\n\t      if (draggingTarget !== dropTarget) {\n\t        if (lastDropTarget && dropTarget !== lastDropTarget) {\n\t          this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n\t        }\n\t\n\t        if (dropTarget && dropTarget !== lastDropTarget) {\n\t          this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n\t        }\n\t      }\n\t    }\n\t  },\n\t  _dragEnd: function (e) {\n\t    var draggingTarget = this._draggingTarget;\n\t\n\t    if (draggingTarget) {\n\t      draggingTarget.dragging = false;\n\t    }\n\t\n\t    this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\t\n\t    if (this._dropTarget) {\n\t      this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n\t    }\n\t\n\t    this._draggingTarget = null;\n\t    this._dropTarget = null;\n\t  }\n\t};\n\t\n\tfunction param(target, e) {\n\t  return {\n\t    target: target,\n\t    topTarget: e && e.topTarget\n\t  };\n\t}\n\t\n\tvar _default = Draggable;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * 事件扩展\n\t * @module zrender/mixin/Eventful\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\tvar arrySlice = Array.prototype.slice;\n\t/**\n\t * 事件分发器\n\t * @alias module:zrender/mixin/Eventful\n\t * @constructor\n\t */\n\t\n\tvar Eventful = function () {\n\t  this._$handlers = {};\n\t};\n\t\n\tEventful.prototype = {\n\t  constructor: Eventful,\n\t\n\t  /**\n\t   * 单次触发绑定，trigger后销毁\n\t   *\n\t   * @param {string} event 事件名\n\t   * @param {Function} handler 响应函数\n\t   * @param {Object} context\n\t   */\n\t  one: function (event, handler, context) {\n\t    var _h = this._$handlers;\n\t\n\t    if (!handler || !event) {\n\t      return this;\n\t    }\n\t\n\t    if (!_h[event]) {\n\t      _h[event] = [];\n\t    }\n\t\n\t    for (var i = 0; i < _h[event].length; i++) {\n\t      if (_h[event][i].h === handler) {\n\t        return this;\n\t      }\n\t    }\n\t\n\t    _h[event].push({\n\t      h: handler,\n\t      one: true,\n\t      ctx: context || this\n\t    });\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 绑定事件\n\t   * @param {string} event 事件名\n\t   * @param {Function} handler 事件处理函数\n\t   * @param {Object} [context]\n\t   */\n\t  on: function (event, handler, context) {\n\t    var _h = this._$handlers;\n\t\n\t    if (!handler || !event) {\n\t      return this;\n\t    }\n\t\n\t    if (!_h[event]) {\n\t      _h[event] = [];\n\t    }\n\t\n\t    for (var i = 0; i < _h[event].length; i++) {\n\t      if (_h[event][i].h === handler) {\n\t        return this;\n\t      }\n\t    }\n\t\n\t    _h[event].push({\n\t      h: handler,\n\t      one: false,\n\t      ctx: context || this\n\t    });\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 是否绑定了事件\n\t   * @param  {string}  event\n\t   * @return {boolean}\n\t   */\n\t  isSilent: function (event) {\n\t    var _h = this._$handlers;\n\t    return _h[event] && _h[event].length;\n\t  },\n\t\n\t  /**\n\t   * 解绑事件\n\t   * @param {string} event 事件名\n\t   * @param {Function} [handler] 事件处理函数\n\t   */\n\t  off: function (event, handler) {\n\t    var _h = this._$handlers;\n\t\n\t    if (!event) {\n\t      this._$handlers = {};\n\t      return this;\n\t    }\n\t\n\t    if (handler) {\n\t      if (_h[event]) {\n\t        var newList = [];\n\t\n\t        for (var i = 0, l = _h[event].length; i < l; i++) {\n\t          if (_h[event][i]['h'] != handler) {\n\t            newList.push(_h[event][i]);\n\t          }\n\t        }\n\t\n\t        _h[event] = newList;\n\t      }\n\t\n\t      if (_h[event] && _h[event].length === 0) {\n\t        delete _h[event];\n\t      }\n\t    } else {\n\t      delete _h[event];\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 事件分发\n\t   *\n\t   * @param {string} type 事件类型\n\t   */\n\t  trigger: function (type) {\n\t    if (this._$handlers[type]) {\n\t      var args = arguments;\n\t      var argLen = args.length;\n\t\n\t      if (argLen > 3) {\n\t        args = arrySlice.call(args, 1);\n\t      }\n\t\n\t      var _h = this._$handlers[type];\n\t      var len = _h.length;\n\t\n\t      for (var i = 0; i < len;) {\n\t        // Optimize advise from backbone\n\t        switch (argLen) {\n\t          case 1:\n\t            _h[i]['h'].call(_h[i]['ctx']);\n\t\n\t            break;\n\t\n\t          case 2:\n\t            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\t\n\t            break;\n\t\n\t          case 3:\n\t            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\t\n\t            break;\n\t\n\t          default:\n\t            // have more than 2 given arguments\n\t            _h[i]['h'].apply(_h[i]['ctx'], args);\n\t\n\t            break;\n\t        }\n\t\n\t        if (_h[i]['one']) {\n\t          _h.splice(i, 1);\n\t\n\t          len--;\n\t        } else {\n\t          i++;\n\t        }\n\t      }\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 带有context的事件分发, 最后一个参数是事件回调的context\n\t   * @param {string} type 事件类型\n\t   */\n\t  triggerWithContext: function (type) {\n\t    if (this._$handlers[type]) {\n\t      var args = arguments;\n\t      var argLen = args.length;\n\t\n\t      if (argLen > 4) {\n\t        args = arrySlice.call(args, 1, args.length - 1);\n\t      }\n\t\n\t      var ctx = args[args.length - 1];\n\t      var _h = this._$handlers[type];\n\t      var len = _h.length;\n\t\n\t      for (var i = 0; i < len;) {\n\t        // Optimize advise from backbone\n\t        switch (argLen) {\n\t          case 1:\n\t            _h[i]['h'].call(ctx);\n\t\n\t            break;\n\t\n\t          case 2:\n\t            _h[i]['h'].call(ctx, args[1]);\n\t\n\t            break;\n\t\n\t          case 3:\n\t            _h[i]['h'].call(ctx, args[1], args[2]);\n\t\n\t            break;\n\t\n\t          default:\n\t            // have more than 2 given arguments\n\t            _h[i]['h'].apply(ctx, args);\n\t\n\t            break;\n\t        }\n\t\n\t        if (_h[i]['one']) {\n\t          _h.splice(i, 1);\n\t\n\t          len--;\n\t        } else {\n\t          i++;\n\t        }\n\t      }\n\t    }\n\t\n\t    return this;\n\t  }\n\t}; // 对象可以通过 onxxxx 绑定事件\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onclick\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmouseover\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmouseout\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmousemove\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmousewheel\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmousedown\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmouseup\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondrag\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondragstart\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondragend\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondragenter\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondragleave\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondragover\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondrop\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\tvar _default = Eventful;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(6);\n\t\n\tvar env = __webpack_require__(5);\n\t\n\tvar Group = __webpack_require__(12);\n\t\n\tvar timsort = __webpack_require__(25);\n\t\n\t/**\n\t * Storage内容仓库模块\n\t * @module zrender/Storage\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t * @author errorrik (errorrik@gmail.com)\n\t * @author pissang (https://github.com/pissang/)\n\t */\n\t// Use timsort because in most case elements are partially sorted\n\t// https://jsfiddle.net/pissang/jr4x7mdm/8/\n\tfunction shapeCompareFunc(a, b) {\n\t  if (a.zlevel === b.zlevel) {\n\t    if (a.z === b.z) {\n\t      // if (a.z2 === b.z2) {\n\t      //     // FIXME Slow has renderidx compare\n\t      //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n\t      //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n\t      //     return a.__renderidx - b.__renderidx;\n\t      // }\n\t      return a.z2 - b.z2;\n\t    }\n\t\n\t    return a.z - b.z;\n\t  }\n\t\n\t  return a.zlevel - b.zlevel;\n\t}\n\t/**\n\t * 内容仓库 (M)\n\t * @alias module:zrender/Storage\n\t * @constructor\n\t */\n\t\n\t\n\tvar Storage = function () {\n\t  // jshint ignore:line\n\t  this._roots = [];\n\t  this._displayList = [];\n\t  this._displayListLen = 0;\n\t};\n\t\n\tStorage.prototype = {\n\t  constructor: Storage,\n\t\n\t  /**\n\t   * @param  {Function} cb\n\t   *\n\t   */\n\t  traverse: function (cb, context) {\n\t    for (var i = 0; i < this._roots.length; i++) {\n\t      this._roots[i].traverse(cb, context);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 返回所有图形的绘制队列\n\t   * @param {boolean} [update=false] 是否在返回前更新该数组\n\t   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\n\t   *\n\t   * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n\t   * @return {Array.<module:zrender/graphic/Displayable>}\n\t   */\n\t  getDisplayList: function (update, includeIgnore) {\n\t    includeIgnore = includeIgnore || false;\n\t\n\t    if (update) {\n\t      this.updateDisplayList(includeIgnore);\n\t    }\n\t\n\t    return this._displayList;\n\t  },\n\t\n\t  /**\n\t   * 更新图形的绘制队列。\n\t   * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\n\t   * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\n\t   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\n\t   */\n\t  updateDisplayList: function (includeIgnore) {\n\t    this._displayListLen = 0;\n\t    var roots = this._roots;\n\t    var displayList = this._displayList;\n\t\n\t    for (var i = 0, len = roots.length; i < len; i++) {\n\t      this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n\t    }\n\t\n\t    displayList.length = this._displayListLen; // for (var i = 0, len = displayList.length; i < len; i++) {\n\t    //     displayList[i].__renderidx = i;\n\t    // }\n\t    // displayList.sort(shapeCompareFunc);\n\t\n\t    env.canvasSupported && timsort(displayList, shapeCompareFunc);\n\t  },\n\t  _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\t    if (el.ignore && !includeIgnore) {\n\t      return;\n\t    }\n\t\n\t    el.beforeUpdate();\n\t\n\t    if (el.__dirty) {\n\t      el.update();\n\t    }\n\t\n\t    el.afterUpdate();\n\t    var userSetClipPath = el.clipPath;\n\t\n\t    if (userSetClipPath) {\n\t      // FIXME 效率影响\n\t      if (clipPaths) {\n\t        clipPaths = clipPaths.slice();\n\t      } else {\n\t        clipPaths = [];\n\t      }\n\t\n\t      var currentClipPath = userSetClipPath;\n\t      var parentClipPath = el; // Recursively add clip path\n\t\n\t      while (currentClipPath) {\n\t        // clipPath 的变换是基于使用这个 clipPath 的元素\n\t        currentClipPath.parent = parentClipPath;\n\t        currentClipPath.updateTransform();\n\t        clipPaths.push(currentClipPath);\n\t        parentClipPath = currentClipPath;\n\t        currentClipPath = currentClipPath.clipPath;\n\t      }\n\t    }\n\t\n\t    if (el.isGroup) {\n\t      var children = el._children;\n\t\n\t      for (var i = 0; i < children.length; i++) {\n\t        var child = children[i]; // Force to mark as dirty if group is dirty\n\t        // FIXME __dirtyPath ?\n\t\n\t        if (el.__dirty) {\n\t          child.__dirty = true;\n\t        }\n\t\n\t        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n\t      } // Mark group clean here\n\t\n\t\n\t      el.__dirty = false;\n\t    } else {\n\t      el.__clipPaths = clipPaths;\n\t      this._displayList[this._displayListLen++] = el;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 添加图形(Shape)或者组(Group)到根节点\n\t   * @param {module:zrender/Element} el\n\t   */\n\t  addRoot: function (el) {\n\t    if (el.__storage === this) {\n\t      return;\n\t    }\n\t\n\t    if (el instanceof Group) {\n\t      el.addChildrenToStorage(this);\n\t    }\n\t\n\t    this.addToStorage(el);\n\t\n\t    this._roots.push(el);\n\t  },\n\t\n\t  /**\n\t   * 删除指定的图形(Shape)或者组(Group)\n\t   * @param {string|Array.<string>} [el] 如果为空清空整个Storage\n\t   */\n\t  delRoot: function (el) {\n\t    if (el == null) {\n\t      // 不指定el清空\n\t      for (var i = 0; i < this._roots.length; i++) {\n\t        var root = this._roots[i];\n\t\n\t        if (root instanceof Group) {\n\t          root.delChildrenFromStorage(this);\n\t        }\n\t      }\n\t\n\t      this._roots = [];\n\t      this._displayList = [];\n\t      this._displayListLen = 0;\n\t      return;\n\t    }\n\t\n\t    if (el instanceof Array) {\n\t      for (var i = 0, l = el.length; i < l; i++) {\n\t        this.delRoot(el[i]);\n\t      }\n\t\n\t      return;\n\t    }\n\t\n\t    var idx = util.indexOf(this._roots, el);\n\t\n\t    if (idx >= 0) {\n\t      this.delFromStorage(el);\n\t\n\t      this._roots.splice(idx, 1);\n\t\n\t      if (el instanceof Group) {\n\t        el.delChildrenFromStorage(this);\n\t      }\n\t    }\n\t  },\n\t  addToStorage: function (el) {\n\t    el.__storage = this;\n\t    el.dirty(false);\n\t    return this;\n\t  },\n\t  delFromStorage: function (el) {\n\t    if (el) {\n\t      el.__storage = null;\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 清空并且释放Storage\n\t   */\n\t  dispose: function () {\n\t    this._renderList = this._roots = null;\n\t  },\n\t  displayableSortFunc: shapeCompareFunc\n\t};\n\tvar _default = Storage;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrUtil = __webpack_require__(6);\n\t\n\tvar Element = __webpack_require__(13);\n\t\n\tvar BoundingRect = __webpack_require__(24);\n\t\n\t/**\n\t * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上\n\t * @module zrender/graphic/Group\n\t * @example\n\t *     var Group = require('zrender/container/Group');\n\t *     var Circle = require('zrender/graphic/shape/Circle');\n\t *     var g = new Group();\n\t *     g.position[0] = 100;\n\t *     g.position[1] = 100;\n\t *     g.add(new Circle({\n\t *         style: {\n\t *             x: 100,\n\t *             y: 100,\n\t *             r: 20,\n\t *         }\n\t *     }));\n\t *     zr.add(g);\n\t */\n\t\n\t/**\n\t * @alias module:zrender/graphic/Group\n\t * @constructor\n\t * @extends module:zrender/mixin/Transformable\n\t * @extends module:zrender/mixin/Eventful\n\t */\n\tvar Group = function (opts) {\n\t  opts = opts || {};\n\t  Element.call(this, opts);\n\t\n\t  for (var key in opts) {\n\t    if (opts.hasOwnProperty(key)) {\n\t      this[key] = opts[key];\n\t    }\n\t  }\n\t\n\t  this._children = [];\n\t  this.__storage = null;\n\t  this.__dirty = true;\n\t};\n\t\n\tGroup.prototype = {\n\t  constructor: Group,\n\t  isGroup: true,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  type: 'group',\n\t\n\t  /**\n\t   * 所有子孙元素是否响应鼠标事件\n\t   * @name module:/zrender/container/Group#silent\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  silent: false,\n\t\n\t  /**\n\t   * @return {Array.<module:zrender/Element>}\n\t   */\n\t  children: function () {\n\t    return this._children.slice();\n\t  },\n\t\n\t  /**\n\t   * 获取指定 index 的儿子节点\n\t   * @param  {number} idx\n\t   * @return {module:zrender/Element}\n\t   */\n\t  childAt: function (idx) {\n\t    return this._children[idx];\n\t  },\n\t\n\t  /**\n\t   * 获取指定名字的儿子节点\n\t   * @param  {string} name\n\t   * @return {module:zrender/Element}\n\t   */\n\t  childOfName: function (name) {\n\t    var children = this._children;\n\t\n\t    for (var i = 0; i < children.length; i++) {\n\t      if (children[i].name === name) {\n\t        return children[i];\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @return {number}\n\t   */\n\t  childCount: function () {\n\t    return this._children.length;\n\t  },\n\t\n\t  /**\n\t   * 添加子节点到最后\n\t   * @param {module:zrender/Element} child\n\t   */\n\t  add: function (child) {\n\t    if (child && child !== this && child.parent !== this) {\n\t      this._children.push(child);\n\t\n\t      this._doAdd(child);\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 添加子节点在 nextSibling 之前\n\t   * @param {module:zrender/Element} child\n\t   * @param {module:zrender/Element} nextSibling\n\t   */\n\t  addBefore: function (child, nextSibling) {\n\t    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {\n\t      var children = this._children;\n\t      var idx = children.indexOf(nextSibling);\n\t\n\t      if (idx >= 0) {\n\t        children.splice(idx, 0, child);\n\t\n\t        this._doAdd(child);\n\t      }\n\t    }\n\t\n\t    return this;\n\t  },\n\t  _doAdd: function (child) {\n\t    if (child.parent) {\n\t      child.parent.remove(child);\n\t    }\n\t\n\t    child.parent = this;\n\t    var storage = this.__storage;\n\t    var zr = this.__zr;\n\t\n\t    if (storage && storage !== child.__storage) {\n\t      storage.addToStorage(child);\n\t\n\t      if (child instanceof Group) {\n\t        child.addChildrenToStorage(storage);\n\t      }\n\t    }\n\t\n\t    zr && zr.refresh();\n\t  },\n\t\n\t  /**\n\t   * 移除子节点\n\t   * @param {module:zrender/Element} child\n\t   */\n\t  remove: function (child) {\n\t    var zr = this.__zr;\n\t    var storage = this.__storage;\n\t    var children = this._children;\n\t    var idx = zrUtil.indexOf(children, child);\n\t\n\t    if (idx < 0) {\n\t      return this;\n\t    }\n\t\n\t    children.splice(idx, 1);\n\t    child.parent = null;\n\t\n\t    if (storage) {\n\t      storage.delFromStorage(child);\n\t\n\t      if (child instanceof Group) {\n\t        child.delChildrenFromStorage(storage);\n\t      }\n\t    }\n\t\n\t    zr && zr.refresh();\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 移除所有子节点\n\t   */\n\t  removeAll: function () {\n\t    var children = this._children;\n\t    var storage = this.__storage;\n\t    var child;\n\t    var i;\n\t\n\t    for (i = 0; i < children.length; i++) {\n\t      child = children[i];\n\t\n\t      if (storage) {\n\t        storage.delFromStorage(child);\n\t\n\t        if (child instanceof Group) {\n\t          child.delChildrenFromStorage(storage);\n\t        }\n\t      }\n\t\n\t      child.parent = null;\n\t    }\n\t\n\t    children.length = 0;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 遍历所有子节点\n\t   * @param  {Function} cb\n\t   * @param  {}   context\n\t   */\n\t  eachChild: function (cb, context) {\n\t    var children = this._children;\n\t\n\t    for (var i = 0; i < children.length; i++) {\n\t      var child = children[i];\n\t      cb.call(context, child, i);\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 深度优先遍历所有子孙节点\n\t   * @param  {Function} cb\n\t   * @param  {}   context\n\t   */\n\t  traverse: function (cb, context) {\n\t    for (var i = 0; i < this._children.length; i++) {\n\t      var child = this._children[i];\n\t      cb.call(context, child);\n\t\n\t      if (child.type === 'group') {\n\t        child.traverse(cb, context);\n\t      }\n\t    }\n\t\n\t    return this;\n\t  },\n\t  addChildrenToStorage: function (storage) {\n\t    for (var i = 0; i < this._children.length; i++) {\n\t      var child = this._children[i];\n\t      storage.addToStorage(child);\n\t\n\t      if (child instanceof Group) {\n\t        child.addChildrenToStorage(storage);\n\t      }\n\t    }\n\t  },\n\t  delChildrenFromStorage: function (storage) {\n\t    for (var i = 0; i < this._children.length; i++) {\n\t      var child = this._children[i];\n\t      storage.delFromStorage(child);\n\t\n\t      if (child instanceof Group) {\n\t        child.delChildrenFromStorage(storage);\n\t      }\n\t    }\n\t  },\n\t  dirty: function () {\n\t    this.__dirty = true;\n\t    this.__zr && this.__zr.refresh();\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @return {module:zrender/core/BoundingRect}\n\t   */\n\t  getBoundingRect: function (includeChildren) {\n\t    // TODO Caching\n\t    var rect = null;\n\t    var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t    var children = includeChildren || this._children;\n\t    var tmpMat = [];\n\t\n\t    for (var i = 0; i < children.length; i++) {\n\t      var child = children[i];\n\t\n\t      if (child.ignore || child.invisible) {\n\t        continue;\n\t      }\n\t\n\t      var childRect = child.getBoundingRect();\n\t      var transform = child.getLocalTransform(tmpMat); // TODO\n\t      // The boundingRect cacluated by transforming original\n\t      // rect may be bigger than the actual bundingRect when rotation\n\t      // is used. (Consider a circle rotated aginst its center, where\n\t      // the actual boundingRect should be the same as that not be\n\t      // rotated.) But we can not find better approach to calculate\n\t      // actual boundingRect yet, considering performance.\n\t\n\t      if (transform) {\n\t        tmpRect.copy(childRect);\n\t        tmpRect.applyTransform(transform);\n\t        rect = rect || tmpRect.clone();\n\t        rect.union(tmpRect);\n\t      } else {\n\t        rect = rect || childRect.clone();\n\t        rect.union(childRect);\n\t      }\n\t    }\n\t\n\t    return rect || tmpRect;\n\t  }\n\t};\n\tzrUtil.inherits(Group, Element);\n\tvar _default = Group;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar guid = __webpack_require__(4);\n\t\n\tvar Eventful = __webpack_require__(10);\n\t\n\tvar Transformable = __webpack_require__(14);\n\t\n\tvar Animatable = __webpack_require__(16);\n\t\n\tvar zrUtil = __webpack_require__(6);\n\t\n\t/**\n\t * @alias module:zrender/Element\n\t * @constructor\n\t * @extends {module:zrender/mixin/Animatable}\n\t * @extends {module:zrender/mixin/Transformable}\n\t * @extends {module:zrender/mixin/Eventful}\n\t */\n\tvar Element = function (opts) {\n\t  // jshint ignore:line\n\t  Transformable.call(this, opts);\n\t  Eventful.call(this, opts);\n\t  Animatable.call(this, opts);\n\t  /**\n\t   * 画布元素ID\n\t   * @type {string}\n\t   */\n\t\n\t  this.id = opts.id || guid();\n\t};\n\t\n\tElement.prototype = {\n\t  /**\n\t   * 元素类型\n\t   * Element type\n\t   * @type {string}\n\t   */\n\t  type: 'element',\n\t\n\t  /**\n\t   * 元素名字\n\t   * Element name\n\t   * @type {string}\n\t   */\n\t  name: '',\n\t\n\t  /**\n\t   * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n\t   * ZRender instance will be assigned when element is associated with zrender\n\t   * @name module:/zrender/Element#__zr\n\t   * @type {module:zrender/ZRender}\n\t   */\n\t  __zr: null,\n\t\n\t  /**\n\t   * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n\t   * If ignore drawing and events of the element object\n\t   * @name module:/zrender/Element#ignore\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  ignore: false,\n\t\n\t  /**\n\t   * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n\t   * 该路径会继承被裁减对象的变换\n\t   * @type {module:zrender/graphic/Path}\n\t   * @see http://www.w3.org/TR/2dcontext/#clipping-region\n\t   * @readOnly\n\t   */\n\t  clipPath: null,\n\t\n\t  /**\n\t   * Drift element\n\t   * @param  {number} dx dx on the global space\n\t   * @param  {number} dy dy on the global space\n\t   */\n\t  drift: function (dx, dy) {\n\t    switch (this.draggable) {\n\t      case 'horizontal':\n\t        dy = 0;\n\t        break;\n\t\n\t      case 'vertical':\n\t        dx = 0;\n\t        break;\n\t    }\n\t\n\t    var m = this.transform;\n\t\n\t    if (!m) {\n\t      m = this.transform = [1, 0, 0, 1, 0, 0];\n\t    }\n\t\n\t    m[4] += dx;\n\t    m[5] += dy;\n\t    this.decomposeTransform();\n\t    this.dirty(false);\n\t  },\n\t\n\t  /**\n\t   * Hook before update\n\t   */\n\t  beforeUpdate: function () {},\n\t\n\t  /**\n\t   * Hook after update\n\t   */\n\t  afterUpdate: function () {},\n\t\n\t  /**\n\t   * Update each frame\n\t   */\n\t  update: function () {\n\t    this.updateTransform();\n\t  },\n\t\n\t  /**\n\t   * @param  {Function} cb\n\t   * @param  {}   context\n\t   */\n\t  traverse: function (cb, context) {},\n\t\n\t  /**\n\t   * @protected\n\t   */\n\t  attrKV: function (key, value) {\n\t    if (key === 'position' || key === 'scale' || key === 'origin') {\n\t      // Copy the array\n\t      if (value) {\n\t        var target = this[key];\n\t\n\t        if (!target) {\n\t          target = this[key] = [];\n\t        }\n\t\n\t        target[0] = value[0];\n\t        target[1] = value[1];\n\t      }\n\t    } else {\n\t      this[key] = value;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Hide the element\n\t   */\n\t  hide: function () {\n\t    this.ignore = true;\n\t    this.__zr && this.__zr.refresh();\n\t  },\n\t\n\t  /**\n\t   * Show the element\n\t   */\n\t  show: function () {\n\t    this.ignore = false;\n\t    this.__zr && this.__zr.refresh();\n\t  },\n\t\n\t  /**\n\t   * @param {string|Object} key\n\t   * @param {*} value\n\t   */\n\t  attr: function (key, value) {\n\t    if (typeof key === 'string') {\n\t      this.attrKV(key, value);\n\t    } else if (zrUtil.isObject(key)) {\n\t      for (var name in key) {\n\t        if (key.hasOwnProperty(name)) {\n\t          this.attrKV(name, key[name]);\n\t        }\n\t      }\n\t    }\n\t\n\t    this.dirty(false);\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param {module:zrender/graphic/Path} clipPath\n\t   */\n\t  setClipPath: function (clipPath) {\n\t    var zr = this.__zr;\n\t\n\t    if (zr) {\n\t      clipPath.addSelfToZr(zr);\n\t    } // Remove previous clip path\n\t\n\t\n\t    if (this.clipPath && this.clipPath !== clipPath) {\n\t      this.removeClipPath();\n\t    }\n\t\n\t    this.clipPath = clipPath;\n\t    clipPath.__zr = zr;\n\t    clipPath.__clipTarget = this;\n\t    this.dirty(false);\n\t  },\n\t\n\t  /**\n\t   */\n\t  removeClipPath: function () {\n\t    var clipPath = this.clipPath;\n\t\n\t    if (clipPath) {\n\t      if (clipPath.__zr) {\n\t        clipPath.removeSelfFromZr(clipPath.__zr);\n\t      }\n\t\n\t      clipPath.__zr = null;\n\t      clipPath.__clipTarget = null;\n\t      this.clipPath = null;\n\t      this.dirty(false);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Add self from zrender instance.\n\t   * Not recursively because it will be invoked when element added to storage.\n\t   * @param {module:zrender/ZRender} zr\n\t   */\n\t  addSelfToZr: function (zr) {\n\t    this.__zr = zr; // 添加动画\n\t\n\t    var animators = this.animators;\n\t\n\t    if (animators) {\n\t      for (var i = 0; i < animators.length; i++) {\n\t        zr.animation.addAnimator(animators[i]);\n\t      }\n\t    }\n\t\n\t    if (this.clipPath) {\n\t      this.clipPath.addSelfToZr(zr);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Remove self from zrender instance.\n\t   * Not recursively because it will be invoked when element added to storage.\n\t   * @param {module:zrender/ZRender} zr\n\t   */\n\t  removeSelfFromZr: function (zr) {\n\t    this.__zr = null; // 移除动画\n\t\n\t    var animators = this.animators;\n\t\n\t    if (animators) {\n\t      for (var i = 0; i < animators.length; i++) {\n\t        zr.animation.removeAnimator(animators[i]);\n\t      }\n\t    }\n\t\n\t    if (this.clipPath) {\n\t      this.clipPath.removeSelfFromZr(zr);\n\t    }\n\t  }\n\t};\n\tzrUtil.mixin(Element, Animatable);\n\tzrUtil.mixin(Element, Transformable);\n\tzrUtil.mixin(Element, Eventful);\n\tvar _default = Element;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar matrix = __webpack_require__(15);\n\t\n\tvar vector = __webpack_require__(8);\n\t\n\t/**\n\t * 提供变换扩展\n\t * @module zrender/mixin/Transformable\n\t * @author pissang (https://www.github.com/pissang)\n\t */\n\tvar mIdentity = matrix.identity;\n\tvar EPSILON = 5e-5;\n\t\n\tfunction isNotAroundZero(val) {\n\t  return val > EPSILON || val < -EPSILON;\n\t}\n\t/**\n\t * @alias module:zrender/mixin/Transformable\n\t * @constructor\n\t */\n\t\n\t\n\tvar Transformable = function (opts) {\n\t  opts = opts || {}; // If there are no given position, rotation, scale\n\t\n\t  if (!opts.position) {\n\t    /**\n\t     * 平移\n\t     * @type {Array.<number>}\n\t     * @default [0, 0]\n\t     */\n\t    this.position = [0, 0];\n\t  }\n\t\n\t  if (opts.rotation == null) {\n\t    /**\n\t     * 旋转\n\t     * @type {Array.<number>}\n\t     * @default 0\n\t     */\n\t    this.rotation = 0;\n\t  }\n\t\n\t  if (!opts.scale) {\n\t    /**\n\t     * 缩放\n\t     * @type {Array.<number>}\n\t     * @default [1, 1]\n\t     */\n\t    this.scale = [1, 1];\n\t  }\n\t  /**\n\t   * 旋转和缩放的原点\n\t   * @type {Array.<number>}\n\t   * @default null\n\t   */\n\t\n\t\n\t  this.origin = this.origin || null;\n\t};\n\t\n\tvar transformableProto = Transformable.prototype;\n\ttransformableProto.transform = null;\n\t/**\n\t * 判断是否需要有坐标变换\n\t * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n\t */\n\t\n\ttransformableProto.needLocalTransform = function () {\n\t  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n\t};\n\t\n\ttransformableProto.updateTransform = function () {\n\t  var parent = this.parent;\n\t  var parentHasTransform = parent && parent.transform;\n\t  var needLocalTransform = this.needLocalTransform();\n\t  var m = this.transform;\n\t\n\t  if (!(needLocalTransform || parentHasTransform)) {\n\t    m && mIdentity(m);\n\t    return;\n\t  }\n\t\n\t  m = m || matrix.create();\n\t\n\t  if (needLocalTransform) {\n\t    this.getLocalTransform(m);\n\t  } else {\n\t    mIdentity(m);\n\t  } // 应用父节点变换\n\t\n\t\n\t  if (parentHasTransform) {\n\t    if (needLocalTransform) {\n\t      matrix.mul(m, parent.transform, m);\n\t    } else {\n\t      matrix.copy(m, parent.transform);\n\t    }\n\t  } // 保存这个变换矩阵\n\t\n\t\n\t  this.transform = m;\n\t  this.invTransform = this.invTransform || matrix.create();\n\t  matrix.invert(this.invTransform, m);\n\t};\n\t\n\ttransformableProto.getLocalTransform = function (m) {\n\t  return Transformable.getLocalTransform(this, m);\n\t};\n\t/**\n\t * 将自己的transform应用到context上\n\t * @param {CanvasRenderingContext2D} ctx\n\t */\n\t\n\t\n\ttransformableProto.setTransform = function (ctx) {\n\t  var m = this.transform;\n\t  var dpr = ctx.dpr || 1;\n\t\n\t  if (m) {\n\t    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n\t  } else {\n\t    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t  }\n\t};\n\t\n\ttransformableProto.restoreTransform = function (ctx) {\n\t  var dpr = ctx.dpr || 1;\n\t  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t};\n\t\n\tvar tmpTransform = [];\n\t/**\n\t * 分解`transform`矩阵到`position`, `rotation`, `scale`\n\t */\n\t\n\ttransformableProto.decomposeTransform = function () {\n\t  if (!this.transform) {\n\t    return;\n\t  }\n\t\n\t  var parent = this.parent;\n\t  var m = this.transform;\n\t\n\t  if (parent && parent.transform) {\n\t    // Get local transform and decompose them to position, scale, rotation\n\t    matrix.mul(tmpTransform, parent.invTransform, m);\n\t    m = tmpTransform;\n\t  }\n\t\n\t  var sx = m[0] * m[0] + m[1] * m[1];\n\t  var sy = m[2] * m[2] + m[3] * m[3];\n\t  var position = this.position;\n\t  var scale = this.scale;\n\t\n\t  if (isNotAroundZero(sx - 1)) {\n\t    sx = Math.sqrt(sx);\n\t  }\n\t\n\t  if (isNotAroundZero(sy - 1)) {\n\t    sy = Math.sqrt(sy);\n\t  }\n\t\n\t  if (m[0] < 0) {\n\t    sx = -sx;\n\t  }\n\t\n\t  if (m[3] < 0) {\n\t    sy = -sy;\n\t  }\n\t\n\t  position[0] = m[4];\n\t  position[1] = m[5];\n\t  scale[0] = sx;\n\t  scale[1] = sy;\n\t  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n\t};\n\t/**\n\t * Get global scale\n\t * @return {Array.<number>}\n\t */\n\t\n\t\n\ttransformableProto.getGlobalScale = function () {\n\t  var m = this.transform;\n\t\n\t  if (!m) {\n\t    return [1, 1];\n\t  }\n\t\n\t  var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n\t  var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\t\n\t  if (m[0] < 0) {\n\t    sx = -sx;\n\t  }\n\t\n\t  if (m[3] < 0) {\n\t    sy = -sy;\n\t  }\n\t\n\t  return [sx, sy];\n\t};\n\t/**\n\t * 变换坐标位置到 shape 的局部坐标空间\n\t * @method\n\t * @param {number} x\n\t * @param {number} y\n\t * @return {Array.<number>}\n\t */\n\t\n\t\n\ttransformableProto.transformCoordToLocal = function (x, y) {\n\t  var v2 = [x, y];\n\t  var invTransform = this.invTransform;\n\t\n\t  if (invTransform) {\n\t    vector.applyTransform(v2, v2, invTransform);\n\t  }\n\t\n\t  return v2;\n\t};\n\t/**\n\t * 变换局部坐标位置到全局坐标空间\n\t * @method\n\t * @param {number} x\n\t * @param {number} y\n\t * @return {Array.<number>}\n\t */\n\t\n\t\n\ttransformableProto.transformCoordToGlobal = function (x, y) {\n\t  var v2 = [x, y];\n\t  var transform = this.transform;\n\t\n\t  if (transform) {\n\t    vector.applyTransform(v2, v2, transform);\n\t  }\n\t\n\t  return v2;\n\t};\n\t/**\n\t * @static\n\t * @param {Object} target\n\t * @param {Array.<number>} target.origin\n\t * @param {number} target.rotation\n\t * @param {Array.<number>} target.position\n\t * @param {Array.<number>} [m]\n\t */\n\t\n\t\n\tTransformable.getLocalTransform = function (target, m) {\n\t  m = m || [];\n\t  mIdentity(m);\n\t  var origin = target.origin;\n\t  var scale = target.scale || [1, 1];\n\t  var rotation = target.rotation || 0;\n\t  var position = target.position || [0, 0];\n\t\n\t  if (origin) {\n\t    // Translate to origin\n\t    m[4] -= origin[0];\n\t    m[5] -= origin[1];\n\t  }\n\t\n\t  matrix.scale(m, m, scale);\n\t\n\t  if (rotation) {\n\t    matrix.rotate(m, m, rotation);\n\t  }\n\t\n\t  if (origin) {\n\t    // Translate back from origin\n\t    m[4] += origin[0];\n\t    m[5] += origin[1];\n\t  }\n\t\n\t  m[4] += position[0];\n\t  m[5] += position[1];\n\t  return m;\n\t};\n\t\n\tvar _default = Transformable;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * 3x2矩阵操作类\n\t * @exports zrender/tool/matrix\n\t */\n\tvar ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n\t/**\n\t * 创建一个单位矩阵\n\t * @return {Float32Array|Array.<number>}\n\t */\n\t\n\tfunction create() {\n\t  var out = new ArrayCtor(6);\n\t  identity(out);\n\t  return out;\n\t}\n\t/**\n\t * 设置矩阵为单位矩阵\n\t * @param {Float32Array|Array.<number>} out\n\t */\n\t\n\t\n\tfunction identity(out) {\n\t  out[0] = 1;\n\t  out[1] = 0;\n\t  out[2] = 0;\n\t  out[3] = 1;\n\t  out[4] = 0;\n\t  out[5] = 0;\n\t  return out;\n\t}\n\t/**\n\t * 复制矩阵\n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} m\n\t */\n\t\n\t\n\tfunction copy(out, m) {\n\t  out[0] = m[0];\n\t  out[1] = m[1];\n\t  out[2] = m[2];\n\t  out[3] = m[3];\n\t  out[4] = m[4];\n\t  out[5] = m[5];\n\t  return out;\n\t}\n\t/**\n\t * 矩阵相乘\n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} m1\n\t * @param {Float32Array|Array.<number>} m2\n\t */\n\t\n\t\n\tfunction mul(out, m1, m2) {\n\t  // Consider matrix.mul(m, m2, m);\n\t  // where out is the same as m2.\n\t  // So use temp variable to escape error.\n\t  var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n\t  var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n\t  var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n\t  var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n\t  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n\t  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n\t  out[0] = out0;\n\t  out[1] = out1;\n\t  out[2] = out2;\n\t  out[3] = out3;\n\t  out[4] = out4;\n\t  out[5] = out5;\n\t  return out;\n\t}\n\t/**\n\t * 平移变换\n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} a\n\t * @param {Float32Array|Array.<number>} v\n\t */\n\t\n\t\n\tfunction translate(out, a, v) {\n\t  out[0] = a[0];\n\t  out[1] = a[1];\n\t  out[2] = a[2];\n\t  out[3] = a[3];\n\t  out[4] = a[4] + v[0];\n\t  out[5] = a[5] + v[1];\n\t  return out;\n\t}\n\t/**\n\t * 旋转变换\n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} a\n\t * @param {number} rad\n\t */\n\t\n\t\n\tfunction rotate(out, a, rad) {\n\t  var aa = a[0];\n\t  var ac = a[2];\n\t  var atx = a[4];\n\t  var ab = a[1];\n\t  var ad = a[3];\n\t  var aty = a[5];\n\t  var st = Math.sin(rad);\n\t  var ct = Math.cos(rad);\n\t  out[0] = aa * ct + ab * st;\n\t  out[1] = -aa * st + ab * ct;\n\t  out[2] = ac * ct + ad * st;\n\t  out[3] = -ac * st + ct * ad;\n\t  out[4] = ct * atx + st * aty;\n\t  out[5] = ct * aty - st * atx;\n\t  return out;\n\t}\n\t/**\n\t * 缩放变换\n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} a\n\t * @param {Float32Array|Array.<number>} v\n\t */\n\t\n\t\n\tfunction scale(out, a, v) {\n\t  var vx = v[0];\n\t  var vy = v[1];\n\t  out[0] = a[0] * vx;\n\t  out[1] = a[1] * vy;\n\t  out[2] = a[2] * vx;\n\t  out[3] = a[3] * vy;\n\t  out[4] = a[4] * vx;\n\t  out[5] = a[5] * vy;\n\t  return out;\n\t}\n\t/**\n\t * 求逆矩阵\n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} a\n\t */\n\t\n\t\n\tfunction invert(out, a) {\n\t  var aa = a[0];\n\t  var ac = a[2];\n\t  var atx = a[4];\n\t  var ab = a[1];\n\t  var ad = a[3];\n\t  var aty = a[5];\n\t  var det = aa * ad - ab * ac;\n\t\n\t  if (!det) {\n\t    return null;\n\t  }\n\t\n\t  det = 1.0 / det;\n\t  out[0] = ad * det;\n\t  out[1] = -ab * det;\n\t  out[2] = -ac * det;\n\t  out[3] = aa * det;\n\t  out[4] = (ac * aty - ad * atx) * det;\n\t  out[5] = (ab * atx - aa * aty) * det;\n\t  return out;\n\t}\n\t\n\texports.create = create;\n\texports.identity = identity;\n\texports.copy = copy;\n\texports.mul = mul;\n\texports.translate = translate;\n\texports.rotate = rotate;\n\texports.scale = scale;\n\texports.invert = invert;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Animator = __webpack_require__(17);\n\t\n\tvar log = __webpack_require__(22);\n\t\n\tvar _util = __webpack_require__(6);\n\t\n\tvar isString = _util.isString;\n\tvar isFunction = _util.isFunction;\n\tvar isObject = _util.isObject;\n\tvar isArrayLike = _util.isArrayLike;\n\tvar indexOf = _util.indexOf;\n\t\n\t/**\n\t * @alias modue:zrender/mixin/Animatable\n\t * @constructor\n\t */\n\tvar Animatable = function () {\n\t  /**\n\t   * @type {Array.<module:zrender/animation/Animator>}\n\t   * @readOnly\n\t   */\n\t  this.animators = [];\n\t};\n\t\n\tAnimatable.prototype = {\n\t  constructor: Animatable,\n\t\n\t  /**\n\t   * 动画\n\t   *\n\t   * @param {string} path The path to fetch value from object, like 'a.b.c'.\n\t   * @param {boolean} [loop] Whether to loop animation.\n\t   * @return {module:zrender/animation/Animator}\n\t   * @example:\n\t   *     el.animate('style', false)\n\t   *         .when(1000, {x: 10} )\n\t   *         .done(function(){ // Animation done })\n\t   *         .start()\n\t   */\n\t  animate: function (path, loop) {\n\t    var target;\n\t    var animatingShape = false;\n\t    var el = this;\n\t    var zr = this.__zr;\n\t\n\t    if (path) {\n\t      var pathSplitted = path.split('.');\n\t      var prop = el; // If animating shape\n\t\n\t      animatingShape = pathSplitted[0] === 'shape';\n\t\n\t      for (var i = 0, l = pathSplitted.length; i < l; i++) {\n\t        if (!prop) {\n\t          continue;\n\t        }\n\t\n\t        prop = prop[pathSplitted[i]];\n\t      }\n\t\n\t      if (prop) {\n\t        target = prop;\n\t      }\n\t    } else {\n\t      target = el;\n\t    }\n\t\n\t    if (!target) {\n\t      log('Property \"' + path + '\" is not existed in element ' + el.id);\n\t      return;\n\t    }\n\t\n\t    var animators = el.animators;\n\t    var animator = new Animator(target, loop);\n\t    animator.during(function (target) {\n\t      el.dirty(animatingShape);\n\t    }).done(function () {\n\t      // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n\t      animators.splice(indexOf(animators, animator), 1);\n\t    });\n\t    animators.push(animator); // If animate after added to the zrender\n\t\n\t    if (zr) {\n\t      zr.animation.addAnimator(animator);\n\t    }\n\t\n\t    return animator;\n\t  },\n\t\n\t  /**\n\t   * 停止动画\n\t   * @param {boolean} forwardToLast If move to last frame before stop\n\t   */\n\t  stopAnimation: function (forwardToLast) {\n\t    var animators = this.animators;\n\t    var len = animators.length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      animators[i].stop(forwardToLast);\n\t    }\n\t\n\t    animators.length = 0;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * Caution: this method will stop previous animation.\n\t   * So do not use this method to one element twice before\n\t   * animation starts, unless you know what you are doing.\n\t   * @param {Object} target\n\t   * @param {number} [time=500] Time in ms\n\t   * @param {string} [easing='linear']\n\t   * @param {number} [delay=0]\n\t   * @param {Function} [callback]\n\t   * @param {Function} [forceAnimate] Prevent stop animation and callback\n\t   *        immediently when target values are the same as current values.\n\t   *\n\t   * @example\n\t   *  // Animate position\n\t   *  el.animateTo({\n\t   *      position: [10, 10]\n\t   *  }, function () { // done })\n\t   *\n\t   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n\t   *  el.animateTo({\n\t   *      shape: {\n\t   *          width: 500\n\t   *      },\n\t   *      style: {\n\t   *          fill: 'red'\n\t   *      }\n\t   *      position: [10, 10]\n\t   *  }, 100, 100, 'cubicOut', function () { // done })\n\t   */\n\t  // TODO Return animation key\n\t  animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n\t    // animateTo(target, time, easing, callback);\n\t    if (isString(delay)) {\n\t      callback = easing;\n\t      easing = delay;\n\t      delay = 0;\n\t    } // animateTo(target, time, delay, callback);\n\t    else if (isFunction(easing)) {\n\t        callback = easing;\n\t        easing = 'linear';\n\t        delay = 0;\n\t      } // animateTo(target, time, callback);\n\t      else if (isFunction(delay)) {\n\t          callback = delay;\n\t          delay = 0;\n\t        } // animateTo(target, callback)\n\t        else if (isFunction(time)) {\n\t            callback = time;\n\t            time = 500;\n\t          } // animateTo(target)\n\t          else if (!time) {\n\t              time = 500;\n\t            } // Stop all previous animations\n\t\n\t\n\t    this.stopAnimation();\n\t\n\t    this._animateToShallow('', this, target, time, delay); // Animators may be removed immediately after start\n\t    // if there is nothing to animate\n\t\n\t\n\t    var animators = this.animators.slice();\n\t    var count = animators.length;\n\t\n\t    function done() {\n\t      count--;\n\t\n\t      if (!count) {\n\t        callback && callback();\n\t      }\n\t    } // No animators. This should be checked before animators[i].start(),\n\t    // because 'done' may be executed immediately if no need to animate.\n\t\n\t\n\t    if (!count) {\n\t      callback && callback();\n\t    } // Start after all animators created\n\t    // Incase any animator is done immediately when all animation properties are not changed\n\t\n\t\n\t    for (var i = 0; i < animators.length; i++) {\n\t      animators[i].done(done).start(easing, forceAnimate);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @private\n\t   * @param {string} path=''\n\t   * @param {Object} source=this\n\t   * @param {Object} target\n\t   * @param {number} [time=500]\n\t   * @param {number} [delay=0]\n\t   *\n\t   * @example\n\t   *  // Animate position\n\t   *  el._animateToShallow({\n\t   *      position: [10, 10]\n\t   *  })\n\t   *\n\t   *  // Animate shape, style and position in 100ms, delayed 100ms\n\t   *  el._animateToShallow({\n\t   *      shape: {\n\t   *          width: 500\n\t   *      },\n\t   *      style: {\n\t   *          fill: 'red'\n\t   *      }\n\t   *      position: [10, 10]\n\t   *  }, 100, 100)\n\t   */\n\t  _animateToShallow: function (path, source, target, time, delay) {\n\t    var objShallow = {};\n\t    var propertyCount = 0;\n\t\n\t    for (var name in target) {\n\t      if (!target.hasOwnProperty(name)) {\n\t        continue;\n\t      }\n\t\n\t      if (source[name] != null) {\n\t        if (isObject(target[name]) && !isArrayLike(target[name])) {\n\t          this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);\n\t        } else {\n\t          objShallow[name] = target[name];\n\t          propertyCount++;\n\t        }\n\t      } else if (target[name] != null) {\n\t        // Attr directly if not has property\n\t        // FIXME, if some property not needed for element ?\n\t        if (!path) {\n\t          this.attr(name, target[name]);\n\t        } else {\n\t          // Shape or style\n\t          var props = {};\n\t          props[path] = {};\n\t          props[path][name] = target[name];\n\t          this.attr(props);\n\t        }\n\t      }\n\t    }\n\t\n\t    if (propertyCount > 0) {\n\t      this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n\t    }\n\t\n\t    return this;\n\t  }\n\t};\n\tvar _default = Animatable;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Clip = __webpack_require__(18);\n\t\n\tvar color = __webpack_require__(20);\n\t\n\tvar _util = __webpack_require__(6);\n\t\n\tvar isArrayLike = _util.isArrayLike;\n\t\n\t/**\n\t * @module echarts/animation/Animator\n\t */\n\tvar arraySlice = Array.prototype.slice;\n\t\n\tfunction defaultGetter(target, key) {\n\t  return target[key];\n\t}\n\t\n\tfunction defaultSetter(target, key, value) {\n\t  target[key] = value;\n\t}\n\t/**\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} percent\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction interpolateNumber(p0, p1, percent) {\n\t  return (p1 - p0) * percent + p0;\n\t}\n\t/**\n\t * @param  {string} p0\n\t * @param  {string} p1\n\t * @param  {number} percent\n\t * @return {string}\n\t */\n\t\n\t\n\tfunction interpolateString(p0, p1, percent) {\n\t  return percent > 0.5 ? p1 : p0;\n\t}\n\t/**\n\t * @param  {Array} p0\n\t * @param  {Array} p1\n\t * @param  {number} percent\n\t * @param  {Array} out\n\t * @param  {number} arrDim\n\t */\n\t\n\t\n\tfunction interpolateArray(p0, p1, percent, out, arrDim) {\n\t  var len = p0.length;\n\t\n\t  if (arrDim == 1) {\n\t    for (var i = 0; i < len; i++) {\n\t      out[i] = interpolateNumber(p0[i], p1[i], percent);\n\t    }\n\t  } else {\n\t    var len2 = len && p0[0].length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      for (var j = 0; j < len2; j++) {\n\t        out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n\t      }\n\t    }\n\t  }\n\t} // arr0 is source array, arr1 is target array.\n\t// Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\t\n\t\n\tfunction fillArr(arr0, arr1, arrDim) {\n\t  var arr0Len = arr0.length;\n\t  var arr1Len = arr1.length;\n\t\n\t  if (arr0Len !== arr1Len) {\n\t    // FIXME Not work for TypedArray\n\t    var isPreviousLarger = arr0Len > arr1Len;\n\t\n\t    if (isPreviousLarger) {\n\t      // Cut the previous\n\t      arr0.length = arr1Len;\n\t    } else {\n\t      // Fill the previous\n\t      for (var i = arr0Len; i < arr1Len; i++) {\n\t        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n\t      }\n\t    }\n\t  } // Handling NaN value\n\t\n\t\n\t  var len2 = arr0[0] && arr0[0].length;\n\t\n\t  for (var i = 0; i < arr0.length; i++) {\n\t    if (arrDim === 1) {\n\t      if (isNaN(arr0[i])) {\n\t        arr0[i] = arr1[i];\n\t      }\n\t    } else {\n\t      for (var j = 0; j < len2; j++) {\n\t        if (isNaN(arr0[i][j])) {\n\t          arr0[i][j] = arr1[i][j];\n\t        }\n\t      }\n\t    }\n\t  }\n\t}\n\t/**\n\t * @param  {Array} arr0\n\t * @param  {Array} arr1\n\t * @param  {number} arrDim\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isArraySame(arr0, arr1, arrDim) {\n\t  if (arr0 === arr1) {\n\t    return true;\n\t  }\n\t\n\t  var len = arr0.length;\n\t\n\t  if (len !== arr1.length) {\n\t    return false;\n\t  }\n\t\n\t  if (arrDim === 1) {\n\t    for (var i = 0; i < len; i++) {\n\t      if (arr0[i] !== arr1[i]) {\n\t        return false;\n\t      }\n\t    }\n\t  } else {\n\t    var len2 = arr0[0].length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      for (var j = 0; j < len2; j++) {\n\t        if (arr0[i][j] !== arr1[i][j]) {\n\t          return false;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  return true;\n\t}\n\t/**\n\t * Catmull Rom interpolate array\n\t * @param  {Array} p0\n\t * @param  {Array} p1\n\t * @param  {Array} p2\n\t * @param  {Array} p3\n\t * @param  {number} t\n\t * @param  {number} t2\n\t * @param  {number} t3\n\t * @param  {Array} out\n\t * @param  {number} arrDim\n\t */\n\t\n\t\n\tfunction catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {\n\t  var len = p0.length;\n\t\n\t  if (arrDim == 1) {\n\t    for (var i = 0; i < len; i++) {\n\t      out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);\n\t    }\n\t  } else {\n\t    var len2 = p0[0].length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      for (var j = 0; j < len2; j++) {\n\t        out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);\n\t      }\n\t    }\n\t  }\n\t}\n\t/**\n\t * Catmull Rom interpolate number\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {number} t\n\t * @param  {number} t2\n\t * @param  {number} t3\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n\t  var v0 = (p2 - p0) * 0.5;\n\t  var v1 = (p3 - p1) * 0.5;\n\t  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n\t}\n\t\n\tfunction cloneValue(value) {\n\t  if (isArrayLike(value)) {\n\t    var len = value.length;\n\t\n\t    if (isArrayLike(value[0])) {\n\t      var ret = [];\n\t\n\t      for (var i = 0; i < len; i++) {\n\t        ret.push(arraySlice.call(value[i]));\n\t      }\n\t\n\t      return ret;\n\t    }\n\t\n\t    return arraySlice.call(value);\n\t  }\n\t\n\t  return value;\n\t}\n\t\n\tfunction rgba2String(rgba) {\n\t  rgba[0] = Math.floor(rgba[0]);\n\t  rgba[1] = Math.floor(rgba[1]);\n\t  rgba[2] = Math.floor(rgba[2]);\n\t  return 'rgba(' + rgba.join(',') + ')';\n\t}\n\t\n\tfunction getArrayDim(keyframes) {\n\t  var lastValue = keyframes[keyframes.length - 1].value;\n\t  return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n\t}\n\t\n\tfunction createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {\n\t  var getter = animator._getter;\n\t  var setter = animator._setter;\n\t  var useSpline = easing === 'spline';\n\t  var trackLen = keyframes.length;\n\t\n\t  if (!trackLen) {\n\t    return;\n\t  } // Guess data type\n\t\n\t\n\t  var firstVal = keyframes[0].value;\n\t  var isValueArray = isArrayLike(firstVal);\n\t  var isValueColor = false;\n\t  var isValueString = false; // For vertices morphing\n\t\n\t  var arrDim = isValueArray ? getArrayDim(keyframes) : 0;\n\t  var trackMaxTime; // Sort keyframe as ascending\n\t\n\t  keyframes.sort(function (a, b) {\n\t    return a.time - b.time;\n\t  });\n\t  trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe\n\t\n\t  var kfPercents = []; // Value of each keyframe\n\t\n\t  var kfValues = [];\n\t  var prevValue = keyframes[0].value;\n\t  var isAllValueEqual = true;\n\t\n\t  for (var i = 0; i < trackLen; i++) {\n\t    kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string\n\t\n\t    var value = keyframes[i].value; // Check if value is equal, deep check if value is array\n\t\n\t    if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {\n\t      isAllValueEqual = false;\n\t    }\n\t\n\t    prevValue = value; // Try converting a string to a color array\n\t\n\t    if (typeof value == 'string') {\n\t      var colorArray = color.parse(value);\n\t\n\t      if (colorArray) {\n\t        value = colorArray;\n\t        isValueColor = true;\n\t      } else {\n\t        isValueString = true;\n\t      }\n\t    }\n\t\n\t    kfValues.push(value);\n\t  }\n\t\n\t  if (!forceAnimate && isAllValueEqual) {\n\t    return;\n\t  }\n\t\n\t  var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value\n\t\n\t  for (var i = 0; i < trackLen - 1; i++) {\n\t    if (isValueArray) {\n\t      fillArr(kfValues[i], lastValue, arrDim);\n\t    } else {\n\t      if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n\t        kfValues[i] = lastValue;\n\t      }\n\t    }\n\t  }\n\t\n\t  isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when\n\t  // animation playback is sequency\n\t\n\t  var lastFrame = 0;\n\t  var lastFramePercent = 0;\n\t  var start;\n\t  var w;\n\t  var p0;\n\t  var p1;\n\t  var p2;\n\t  var p3;\n\t\n\t  if (isValueColor) {\n\t    var rgba = [0, 0, 0, 0];\n\t  }\n\t\n\t  var onframe = function (target, percent) {\n\t    // Find the range keyframes\n\t    // kf1-----kf2---------current--------kf3\n\t    // find kf2 and kf3 and do interpolation\n\t    var frame; // In the easing function like elasticOut, percent may less than 0\n\t\n\t    if (percent < 0) {\n\t      frame = 0;\n\t    } else if (percent < lastFramePercent) {\n\t      // Start from next key\n\t      // PENDING start from lastFrame ?\n\t      start = Math.min(lastFrame + 1, trackLen - 1);\n\t\n\t      for (frame = start; frame >= 0; frame--) {\n\t        if (kfPercents[frame] <= percent) {\n\t          break;\n\t        }\n\t      } // PENDING really need to do this ?\n\t\n\t\n\t      frame = Math.min(frame, trackLen - 2);\n\t    } else {\n\t      for (frame = lastFrame; frame < trackLen; frame++) {\n\t        if (kfPercents[frame] > percent) {\n\t          break;\n\t        }\n\t      }\n\t\n\t      frame = Math.min(frame - 1, trackLen - 2);\n\t    }\n\t\n\t    lastFrame = frame;\n\t    lastFramePercent = percent;\n\t    var range = kfPercents[frame + 1] - kfPercents[frame];\n\t\n\t    if (range === 0) {\n\t      return;\n\t    } else {\n\t      w = (percent - kfPercents[frame]) / range;\n\t    }\n\t\n\t    if (useSpline) {\n\t      p1 = kfValues[frame];\n\t      p0 = kfValues[frame === 0 ? frame : frame - 1];\n\t      p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n\t      p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\t\n\t      if (isValueArray) {\n\t        catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);\n\t      } else {\n\t        var value;\n\t\n\t        if (isValueColor) {\n\t          value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);\n\t          value = rgba2String(rgba);\n\t        } else if (isValueString) {\n\t          // String is step(0.5)\n\t          return interpolateString(p1, p2, w);\n\t        } else {\n\t          value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);\n\t        }\n\t\n\t        setter(target, propName, value);\n\t      }\n\t    } else {\n\t      if (isValueArray) {\n\t        interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);\n\t      } else {\n\t        var value;\n\t\n\t        if (isValueColor) {\n\t          interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);\n\t          value = rgba2String(rgba);\n\t        } else if (isValueString) {\n\t          // String is step(0.5)\n\t          return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n\t        } else {\n\t          value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n\t        }\n\t\n\t        setter(target, propName, value);\n\t      }\n\t    }\n\t  };\n\t\n\t  var clip = new Clip({\n\t    target: animator._target,\n\t    life: trackMaxTime,\n\t    loop: animator._loop,\n\t    delay: animator._delay,\n\t    onframe: onframe,\n\t    ondestroy: oneTrackDone\n\t  });\n\t\n\t  if (easing && easing !== 'spline') {\n\t    clip.easing = easing;\n\t  }\n\t\n\t  return clip;\n\t}\n\t/**\n\t * @alias module:zrender/animation/Animator\n\t * @constructor\n\t * @param {Object} target\n\t * @param {boolean} loop\n\t * @param {Function} getter\n\t * @param {Function} setter\n\t */\n\t\n\t\n\tvar Animator = function (target, loop, getter, setter) {\n\t  this._tracks = {};\n\t  this._target = target;\n\t  this._loop = loop || false;\n\t  this._getter = getter || defaultGetter;\n\t  this._setter = setter || defaultSetter;\n\t  this._clipCount = 0;\n\t  this._delay = 0;\n\t  this._doneList = [];\n\t  this._onframeList = [];\n\t  this._clipList = [];\n\t};\n\t\n\tAnimator.prototype = {\n\t  /**\n\t   * 设置动画关键帧\n\t   * @param  {number} time 关键帧时间，单位是ms\n\t   * @param  {Object} props 关键帧的属性值，key-value表示\n\t   * @return {module:zrender/animation/Animator}\n\t   */\n\t  when: function (time\n\t  /* ms */\n\t  , props) {\n\t    var tracks = this._tracks;\n\t\n\t    for (var propName in props) {\n\t      if (!props.hasOwnProperty(propName)) {\n\t        continue;\n\t      }\n\t\n\t      if (!tracks[propName]) {\n\t        tracks[propName] = []; // Invalid value\n\t\n\t        var value = this._getter(this._target, propName);\n\t\n\t        if (value == null) {\n\t          // zrLog('Invalid property ' + propName);\n\t          continue;\n\t        } // If time is 0\n\t        //  Then props is given initialize value\n\t        // Else\n\t        //  Initialize value from current prop value\n\t\n\t\n\t        if (time !== 0) {\n\t          tracks[propName].push({\n\t            time: 0,\n\t            value: cloneValue(value)\n\t          });\n\t        }\n\t      }\n\t\n\t      tracks[propName].push({\n\t        time: time,\n\t        value: props[propName]\n\t      });\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 添加动画每一帧的回调函数\n\t   * @param  {Function} callback\n\t   * @return {module:zrender/animation/Animator}\n\t   */\n\t  during: function (callback) {\n\t    this._onframeList.push(callback);\n\t\n\t    return this;\n\t  },\n\t  pause: function () {\n\t    for (var i = 0; i < this._clipList.length; i++) {\n\t      this._clipList[i].pause();\n\t    }\n\t\n\t    this._paused = true;\n\t  },\n\t  resume: function () {\n\t    for (var i = 0; i < this._clipList.length; i++) {\n\t      this._clipList[i].resume();\n\t    }\n\t\n\t    this._paused = false;\n\t  },\n\t  isPaused: function () {\n\t    return !!this._paused;\n\t  },\n\t  _doneCallback: function () {\n\t    // Clear all tracks\n\t    this._tracks = {}; // Clear all clips\n\t\n\t    this._clipList.length = 0;\n\t    var doneList = this._doneList;\n\t    var len = doneList.length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      doneList[i].call(this);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 开始执行动画\n\t   * @param  {string|Function} [easing]\n\t   *         动画缓动函数，详见{@link module:zrender/animation/easing}\n\t   * @param  {boolean} forceAnimate\n\t   * @return {module:zrender/animation/Animator}\n\t   */\n\t  start: function (easing, forceAnimate) {\n\t    var self = this;\n\t    var clipCount = 0;\n\t\n\t    var oneTrackDone = function () {\n\t      clipCount--;\n\t\n\t      if (!clipCount) {\n\t        self._doneCallback();\n\t      }\n\t    };\n\t\n\t    var lastClip;\n\t\n\t    for (var propName in this._tracks) {\n\t      if (!this._tracks.hasOwnProperty(propName)) {\n\t        continue;\n\t      }\n\t\n\t      var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);\n\t\n\t      if (clip) {\n\t        this._clipList.push(clip);\n\t\n\t        clipCount++; // If start after added to animation\n\t\n\t        if (this.animation) {\n\t          this.animation.addClip(clip);\n\t        }\n\t\n\t        lastClip = clip;\n\t      }\n\t    } // Add during callback on the last clip\n\t\n\t\n\t    if (lastClip) {\n\t      var oldOnFrame = lastClip.onframe;\n\t\n\t      lastClip.onframe = function (target, percent) {\n\t        oldOnFrame(target, percent);\n\t\n\t        for (var i = 0; i < self._onframeList.length; i++) {\n\t          self._onframeList[i](target, percent);\n\t        }\n\t      };\n\t    } // This optimization will help the case that in the upper application\n\t    // the view may be refreshed frequently, where animation will be\n\t    // called repeatly but nothing changed.\n\t\n\t\n\t    if (!clipCount) {\n\t      this._doneCallback();\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 停止动画\n\t   * @param {boolean} forwardToLast If move to last frame before stop\n\t   */\n\t  stop: function (forwardToLast) {\n\t    var clipList = this._clipList;\n\t    var animation = this.animation;\n\t\n\t    for (var i = 0; i < clipList.length; i++) {\n\t      var clip = clipList[i];\n\t\n\t      if (forwardToLast) {\n\t        // Move to last frame before stop\n\t        clip.onframe(this._target, 1);\n\t      }\n\t\n\t      animation && animation.removeClip(clip);\n\t    }\n\t\n\t    clipList.length = 0;\n\t  },\n\t\n\t  /**\n\t   * 设置动画延迟开始的时间\n\t   * @param  {number} time 单位ms\n\t   * @return {module:zrender/animation/Animator}\n\t   */\n\t  delay: function (time) {\n\t    this._delay = time;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 添加动画结束的回调\n\t   * @param  {Function} cb\n\t   * @return {module:zrender/animation/Animator}\n\t   */\n\t  done: function (cb) {\n\t    if (cb) {\n\t      this._doneList.push(cb);\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @return {Array.<module:zrender/animation/Clip>}\n\t   */\n\t  getClips: function () {\n\t    return this._clipList;\n\t  }\n\t};\n\tvar _default = Animator;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar easingFuncs = __webpack_require__(19);\n\t\n\t/**\n\t * 动画主控制器\n\t * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\n\t * @config life(1000) 动画时长\n\t * @config delay(0) 动画延迟时间\n\t * @config loop(true)\n\t * @config gap(0) 循环的间隔时间\n\t * @config onframe\n\t * @config easing(optional)\n\t * @config ondestroy(optional)\n\t * @config onrestart(optional)\n\t *\n\t * TODO pause\n\t */\n\tfunction Clip(options) {\n\t  this._target = options.target; // 生命周期\n\t\n\t  this._life = options.life || 1000; // 延时\n\t\n\t  this._delay = options.delay || 0; // 开始时间\n\t  // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n\t\n\t  this._initialized = false; // 是否循环\n\t\n\t  this.loop = options.loop == null ? false : options.loop;\n\t  this.gap = options.gap || 0;\n\t  this.easing = options.easing || 'Linear';\n\t  this.onframe = options.onframe;\n\t  this.ondestroy = options.ondestroy;\n\t  this.onrestart = options.onrestart;\n\t  this._pausedTime = 0;\n\t  this._paused = false;\n\t}\n\t\n\tClip.prototype = {\n\t  constructor: Clip,\n\t  step: function (globalTime, deltaTime) {\n\t    // Set startTime on first step, or _startTime may has milleseconds different between clips\n\t    // PENDING\n\t    if (!this._initialized) {\n\t      this._startTime = globalTime + this._delay;\n\t      this._initialized = true;\n\t    }\n\t\n\t    if (this._paused) {\n\t      this._pausedTime += deltaTime;\n\t      return;\n\t    }\n\t\n\t    var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // 还没开始\n\t\n\t    if (percent < 0) {\n\t      return;\n\t    }\n\t\n\t    percent = Math.min(percent, 1);\n\t    var easing = this.easing;\n\t    var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n\t    var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;\n\t    this.fire('frame', schedule); // 结束\n\t\n\t    if (percent == 1) {\n\t      if (this.loop) {\n\t        this.restart(globalTime); // 重新开始周期\n\t        // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n\t\n\t        return 'restart';\n\t      } // 动画完成将这个控制器标识为待删除\n\t      // 在Animation.update中进行批量删除\n\t\n\t\n\t      this._needsRemove = true;\n\t      return 'destroy';\n\t    }\n\t\n\t    return null;\n\t  },\n\t  restart: function (globalTime) {\n\t    var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n\t    this._startTime = globalTime - remainder + this.gap;\n\t    this._pausedTime = 0;\n\t    this._needsRemove = false;\n\t  },\n\t  fire: function (eventType, arg) {\n\t    eventType = 'on' + eventType;\n\t\n\t    if (this[eventType]) {\n\t      this[eventType](this._target, arg);\n\t    }\n\t  },\n\t  pause: function () {\n\t    this._paused = true;\n\t  },\n\t  resume: function () {\n\t    this._paused = false;\n\t  }\n\t};\n\tvar _default = Clip;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\n\t * @see http://sole.github.io/tween.js/examples/03_graphs.html\n\t * @exports zrender/animation/easing\n\t */\n\tvar easing = {\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  linear: function (k) {\n\t    return k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quadraticIn: function (k) {\n\t    return k * k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quadraticOut: function (k) {\n\t    return k * (2 - k);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quadraticInOut: function (k) {\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * k * k;\n\t    }\n\t\n\t    return -0.5 * (--k * (k - 2) - 1);\n\t  },\n\t  // 三次方的缓动（t^3）\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  cubicIn: function (k) {\n\t    return k * k * k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  cubicOut: function (k) {\n\t    return --k * k * k + 1;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  cubicInOut: function (k) {\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * k * k * k;\n\t    }\n\t\n\t    return 0.5 * ((k -= 2) * k * k + 2);\n\t  },\n\t  // 四次方的缓动（t^4）\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quarticIn: function (k) {\n\t    return k * k * k * k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quarticOut: function (k) {\n\t    return 1 - --k * k * k * k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quarticInOut: function (k) {\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * k * k * k * k;\n\t    }\n\t\n\t    return -0.5 * ((k -= 2) * k * k * k - 2);\n\t  },\n\t  // 五次方的缓动（t^5）\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quinticIn: function (k) {\n\t    return k * k * k * k * k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quinticOut: function (k) {\n\t    return --k * k * k * k * k + 1;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quinticInOut: function (k) {\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * k * k * k * k * k;\n\t    }\n\t\n\t    return 0.5 * ((k -= 2) * k * k * k * k + 2);\n\t  },\n\t  // 正弦曲线的缓动（sin(t)）\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  sinusoidalIn: function (k) {\n\t    return 1 - Math.cos(k * Math.PI / 2);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  sinusoidalOut: function (k) {\n\t    return Math.sin(k * Math.PI / 2);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  sinusoidalInOut: function (k) {\n\t    return 0.5 * (1 - Math.cos(Math.PI * k));\n\t  },\n\t  // 指数曲线的缓动（2^t）\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  exponentialIn: function (k) {\n\t    return k === 0 ? 0 : Math.pow(1024, k - 1);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  exponentialOut: function (k) {\n\t    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  exponentialInOut: function (k) {\n\t    if (k === 0) {\n\t      return 0;\n\t    }\n\t\n\t    if (k === 1) {\n\t      return 1;\n\t    }\n\t\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * Math.pow(1024, k - 1);\n\t    }\n\t\n\t    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n\t  },\n\t  // 圆形曲线的缓动（sqrt(1-t^2)）\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  circularIn: function (k) {\n\t    return 1 - Math.sqrt(1 - k * k);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  circularOut: function (k) {\n\t    return Math.sqrt(1 - --k * k);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  circularInOut: function (k) {\n\t    if ((k *= 2) < 1) {\n\t      return -0.5 * (Math.sqrt(1 - k * k) - 1);\n\t    }\n\t\n\t    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\t  },\n\t  // 创建类似于弹簧在停止前来回振荡的动画\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  elasticIn: function (k) {\n\t    var s;\n\t    var a = 0.1;\n\t    var p = 0.4;\n\t\n\t    if (k === 0) {\n\t      return 0;\n\t    }\n\t\n\t    if (k === 1) {\n\t      return 1;\n\t    }\n\t\n\t    if (!a || a < 1) {\n\t      a = 1;\n\t      s = p / 4;\n\t    } else {\n\t      s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t    }\n\t\n\t    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  elasticOut: function (k) {\n\t    var s;\n\t    var a = 0.1;\n\t    var p = 0.4;\n\t\n\t    if (k === 0) {\n\t      return 0;\n\t    }\n\t\n\t    if (k === 1) {\n\t      return 1;\n\t    }\n\t\n\t    if (!a || a < 1) {\n\t      a = 1;\n\t      s = p / 4;\n\t    } else {\n\t      s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t    }\n\t\n\t    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  elasticInOut: function (k) {\n\t    var s;\n\t    var a = 0.1;\n\t    var p = 0.4;\n\t\n\t    if (k === 0) {\n\t      return 0;\n\t    }\n\t\n\t    if (k === 1) {\n\t      return 1;\n\t    }\n\t\n\t    if (!a || a < 1) {\n\t      a = 1;\n\t      s = p / 4;\n\t    } else {\n\t      s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t    }\n\t\n\t    if ((k *= 2) < 1) {\n\t      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n\t    }\n\t\n\t    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t  },\n\t  // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  backIn: function (k) {\n\t    var s = 1.70158;\n\t    return k * k * ((s + 1) * k - s);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  backOut: function (k) {\n\t    var s = 1.70158;\n\t    return --k * k * ((s + 1) * k + s) + 1;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  backInOut: function (k) {\n\t    var s = 1.70158 * 1.525;\n\t\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * (k * k * ((s + 1) * k - s));\n\t    }\n\t\n\t    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\t  },\n\t  // 创建弹跳效果\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  bounceIn: function (k) {\n\t    return 1 - easing.bounceOut(1 - k);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  bounceOut: function (k) {\n\t    if (k < 1 / 2.75) {\n\t      return 7.5625 * k * k;\n\t    } else if (k < 2 / 2.75) {\n\t      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n\t    } else if (k < 2.5 / 2.75) {\n\t      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n\t    } else {\n\t      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n\t    }\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  bounceInOut: function (k) {\n\t    if (k < 0.5) {\n\t      return easing.bounceIn(k * 2) * 0.5;\n\t    }\n\t\n\t    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n\t  }\n\t};\n\tvar _default = easing;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar LRU = __webpack_require__(21);\n\t\n\tvar kCSSColorTable = {\n\t  'transparent': [0, 0, 0, 0],\n\t  'aliceblue': [240, 248, 255, 1],\n\t  'antiquewhite': [250, 235, 215, 1],\n\t  'aqua': [0, 255, 255, 1],\n\t  'aquamarine': [127, 255, 212, 1],\n\t  'azure': [240, 255, 255, 1],\n\t  'beige': [245, 245, 220, 1],\n\t  'bisque': [255, 228, 196, 1],\n\t  'black': [0, 0, 0, 1],\n\t  'blanchedalmond': [255, 235, 205, 1],\n\t  'blue': [0, 0, 255, 1],\n\t  'blueviolet': [138, 43, 226, 1],\n\t  'brown': [165, 42, 42, 1],\n\t  'burlywood': [222, 184, 135, 1],\n\t  'cadetblue': [95, 158, 160, 1],\n\t  'chartreuse': [127, 255, 0, 1],\n\t  'chocolate': [210, 105, 30, 1],\n\t  'coral': [255, 127, 80, 1],\n\t  'cornflowerblue': [100, 149, 237, 1],\n\t  'cornsilk': [255, 248, 220, 1],\n\t  'crimson': [220, 20, 60, 1],\n\t  'cyan': [0, 255, 255, 1],\n\t  'darkblue': [0, 0, 139, 1],\n\t  'darkcyan': [0, 139, 139, 1],\n\t  'darkgoldenrod': [184, 134, 11, 1],\n\t  'darkgray': [169, 169, 169, 1],\n\t  'darkgreen': [0, 100, 0, 1],\n\t  'darkgrey': [169, 169, 169, 1],\n\t  'darkkhaki': [189, 183, 107, 1],\n\t  'darkmagenta': [139, 0, 139, 1],\n\t  'darkolivegreen': [85, 107, 47, 1],\n\t  'darkorange': [255, 140, 0, 1],\n\t  'darkorchid': [153, 50, 204, 1],\n\t  'darkred': [139, 0, 0, 1],\n\t  'darksalmon': [233, 150, 122, 1],\n\t  'darkseagreen': [143, 188, 143, 1],\n\t  'darkslateblue': [72, 61, 139, 1],\n\t  'darkslategray': [47, 79, 79, 1],\n\t  'darkslategrey': [47, 79, 79, 1],\n\t  'darkturquoise': [0, 206, 209, 1],\n\t  'darkviolet': [148, 0, 211, 1],\n\t  'deeppink': [255, 20, 147, 1],\n\t  'deepskyblue': [0, 191, 255, 1],\n\t  'dimgray': [105, 105, 105, 1],\n\t  'dimgrey': [105, 105, 105, 1],\n\t  'dodgerblue': [30, 144, 255, 1],\n\t  'firebrick': [178, 34, 34, 1],\n\t  'floralwhite': [255, 250, 240, 1],\n\t  'forestgreen': [34, 139, 34, 1],\n\t  'fuchsia': [255, 0, 255, 1],\n\t  'gainsboro': [220, 220, 220, 1],\n\t  'ghostwhite': [248, 248, 255, 1],\n\t  'gold': [255, 215, 0, 1],\n\t  'goldenrod': [218, 165, 32, 1],\n\t  'gray': [128, 128, 128, 1],\n\t  'green': [0, 128, 0, 1],\n\t  'greenyellow': [173, 255, 47, 1],\n\t  'grey': [128, 128, 128, 1],\n\t  'honeydew': [240, 255, 240, 1],\n\t  'hotpink': [255, 105, 180, 1],\n\t  'indianred': [205, 92, 92, 1],\n\t  'indigo': [75, 0, 130, 1],\n\t  'ivory': [255, 255, 240, 1],\n\t  'khaki': [240, 230, 140, 1],\n\t  'lavender': [230, 230, 250, 1],\n\t  'lavenderblush': [255, 240, 245, 1],\n\t  'lawngreen': [124, 252, 0, 1],\n\t  'lemonchiffon': [255, 250, 205, 1],\n\t  'lightblue': [173, 216, 230, 1],\n\t  'lightcoral': [240, 128, 128, 1],\n\t  'lightcyan': [224, 255, 255, 1],\n\t  'lightgoldenrodyellow': [250, 250, 210, 1],\n\t  'lightgray': [211, 211, 211, 1],\n\t  'lightgreen': [144, 238, 144, 1],\n\t  'lightgrey': [211, 211, 211, 1],\n\t  'lightpink': [255, 182, 193, 1],\n\t  'lightsalmon': [255, 160, 122, 1],\n\t  'lightseagreen': [32, 178, 170, 1],\n\t  'lightskyblue': [135, 206, 250, 1],\n\t  'lightslategray': [119, 136, 153, 1],\n\t  'lightslategrey': [119, 136, 153, 1],\n\t  'lightsteelblue': [176, 196, 222, 1],\n\t  'lightyellow': [255, 255, 224, 1],\n\t  'lime': [0, 255, 0, 1],\n\t  'limegreen': [50, 205, 50, 1],\n\t  'linen': [250, 240, 230, 1],\n\t  'magenta': [255, 0, 255, 1],\n\t  'maroon': [128, 0, 0, 1],\n\t  'mediumaquamarine': [102, 205, 170, 1],\n\t  'mediumblue': [0, 0, 205, 1],\n\t  'mediumorchid': [186, 85, 211, 1],\n\t  'mediumpurple': [147, 112, 219, 1],\n\t  'mediumseagreen': [60, 179, 113, 1],\n\t  'mediumslateblue': [123, 104, 238, 1],\n\t  'mediumspringgreen': [0, 250, 154, 1],\n\t  'mediumturquoise': [72, 209, 204, 1],\n\t  'mediumvioletred': [199, 21, 133, 1],\n\t  'midnightblue': [25, 25, 112, 1],\n\t  'mintcream': [245, 255, 250, 1],\n\t  'mistyrose': [255, 228, 225, 1],\n\t  'moccasin': [255, 228, 181, 1],\n\t  'navajowhite': [255, 222, 173, 1],\n\t  'navy': [0, 0, 128, 1],\n\t  'oldlace': [253, 245, 230, 1],\n\t  'olive': [128, 128, 0, 1],\n\t  'olivedrab': [107, 142, 35, 1],\n\t  'orange': [255, 165, 0, 1],\n\t  'orangered': [255, 69, 0, 1],\n\t  'orchid': [218, 112, 214, 1],\n\t  'palegoldenrod': [238, 232, 170, 1],\n\t  'palegreen': [152, 251, 152, 1],\n\t  'paleturquoise': [175, 238, 238, 1],\n\t  'palevioletred': [219, 112, 147, 1],\n\t  'papayawhip': [255, 239, 213, 1],\n\t  'peachpuff': [255, 218, 185, 1],\n\t  'peru': [205, 133, 63, 1],\n\t  'pink': [255, 192, 203, 1],\n\t  'plum': [221, 160, 221, 1],\n\t  'powderblue': [176, 224, 230, 1],\n\t  'purple': [128, 0, 128, 1],\n\t  'red': [255, 0, 0, 1],\n\t  'rosybrown': [188, 143, 143, 1],\n\t  'royalblue': [65, 105, 225, 1],\n\t  'saddlebrown': [139, 69, 19, 1],\n\t  'salmon': [250, 128, 114, 1],\n\t  'sandybrown': [244, 164, 96, 1],\n\t  'seagreen': [46, 139, 87, 1],\n\t  'seashell': [255, 245, 238, 1],\n\t  'sienna': [160, 82, 45, 1],\n\t  'silver': [192, 192, 192, 1],\n\t  'skyblue': [135, 206, 235, 1],\n\t  'slateblue': [106, 90, 205, 1],\n\t  'slategray': [112, 128, 144, 1],\n\t  'slategrey': [112, 128, 144, 1],\n\t  'snow': [255, 250, 250, 1],\n\t  'springgreen': [0, 255, 127, 1],\n\t  'steelblue': [70, 130, 180, 1],\n\t  'tan': [210, 180, 140, 1],\n\t  'teal': [0, 128, 128, 1],\n\t  'thistle': [216, 191, 216, 1],\n\t  'tomato': [255, 99, 71, 1],\n\t  'turquoise': [64, 224, 208, 1],\n\t  'violet': [238, 130, 238, 1],\n\t  'wheat': [245, 222, 179, 1],\n\t  'white': [255, 255, 255, 1],\n\t  'whitesmoke': [245, 245, 245, 1],\n\t  'yellow': [255, 255, 0, 1],\n\t  'yellowgreen': [154, 205, 50, 1]\n\t};\n\t\n\tfunction clampCssByte(i) {\n\t  // Clamp to integer 0 .. 255.\n\t  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\t\n\t  return i < 0 ? 0 : i > 255 ? 255 : i;\n\t}\n\t\n\tfunction clampCssAngle(i) {\n\t  // Clamp to integer 0 .. 360.\n\t  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\t\n\t  return i < 0 ? 0 : i > 360 ? 360 : i;\n\t}\n\t\n\tfunction clampCssFloat(f) {\n\t  // Clamp to float 0.0 .. 1.0.\n\t  return f < 0 ? 0 : f > 1 ? 1 : f;\n\t}\n\t\n\tfunction parseCssInt(str) {\n\t  // int or percentage.\n\t  if (str.length && str.charAt(str.length - 1) === '%') {\n\t    return clampCssByte(parseFloat(str) / 100 * 255);\n\t  }\n\t\n\t  return clampCssByte(parseInt(str, 10));\n\t}\n\t\n\tfunction parseCssFloat(str) {\n\t  // float or percentage.\n\t  if (str.length && str.charAt(str.length - 1) === '%') {\n\t    return clampCssFloat(parseFloat(str) / 100);\n\t  }\n\t\n\t  return clampCssFloat(parseFloat(str));\n\t}\n\t\n\tfunction cssHueToRgb(m1, m2, h) {\n\t  if (h < 0) {\n\t    h += 1;\n\t  } else if (h > 1) {\n\t    h -= 1;\n\t  }\n\t\n\t  if (h * 6 < 1) {\n\t    return m1 + (m2 - m1) * h * 6;\n\t  }\n\t\n\t  if (h * 2 < 1) {\n\t    return m2;\n\t  }\n\t\n\t  if (h * 3 < 2) {\n\t    return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n\t  }\n\t\n\t  return m1;\n\t}\n\t\n\tfunction lerpNumber(a, b, p) {\n\t  return a + (b - a) * p;\n\t}\n\t\n\tfunction setRgba(out, r, g, b, a) {\n\t  out[0] = r;\n\t  out[1] = g;\n\t  out[2] = b;\n\t  out[3] = a;\n\t  return out;\n\t}\n\t\n\tfunction copyRgba(out, a) {\n\t  out[0] = a[0];\n\t  out[1] = a[1];\n\t  out[2] = a[2];\n\t  out[3] = a[3];\n\t  return out;\n\t}\n\t\n\tvar colorCache = new LRU(20);\n\tvar lastRemovedArr = null;\n\t\n\tfunction putToCache(colorStr, rgbaArr) {\n\t  // Reuse removed array\n\t  if (lastRemovedArr) {\n\t    copyRgba(lastRemovedArr, rgbaArr);\n\t  }\n\t\n\t  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());\n\t}\n\t/**\n\t * @param {string} colorStr\n\t * @param {Array.<number>} out\n\t * @return {Array.<number>}\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\t\n\tfunction parse(colorStr, rgbaArr) {\n\t  if (!colorStr) {\n\t    return;\n\t  }\n\t\n\t  rgbaArr = rgbaArr || [];\n\t  var cached = colorCache.get(colorStr);\n\t\n\t  if (cached) {\n\t    return copyRgba(rgbaArr, cached);\n\t  } // colorStr may be not string\n\t\n\t\n\t  colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.\n\t\n\t  var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.\n\t\n\t  if (str in kCSSColorTable) {\n\t    copyRgba(rgbaArr, kCSSColorTable[str]);\n\t    putToCache(colorStr, rgbaArr);\n\t    return rgbaArr;\n\t  } // #abc and #abc123 syntax.\n\t\n\t\n\t  if (str.charAt(0) === '#') {\n\t    if (str.length === 4) {\n\t      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\t\n\t      if (!(iv >= 0 && iv <= 0xfff)) {\n\t        setRgba(rgbaArr, 0, 0, 0, 1);\n\t        return; // Covers NaN.\n\t      }\n\t\n\t      setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);\n\t      putToCache(colorStr, rgbaArr);\n\t      return rgbaArr;\n\t    } else if (str.length === 7) {\n\t      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\t\n\t      if (!(iv >= 0 && iv <= 0xffffff)) {\n\t        setRgba(rgbaArr, 0, 0, 0, 1);\n\t        return; // Covers NaN.\n\t      }\n\t\n\t      setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);\n\t      putToCache(colorStr, rgbaArr);\n\t      return rgbaArr;\n\t    }\n\t\n\t    return;\n\t  }\n\t\n\t  var op = str.indexOf('('),\n\t      ep = str.indexOf(')');\n\t\n\t  if (op !== -1 && ep + 1 === str.length) {\n\t    var fname = str.substr(0, op);\n\t    var params = str.substr(op + 1, ep - (op + 1)).split(',');\n\t    var alpha = 1; // To allow case fallthrough.\n\t\n\t    switch (fname) {\n\t      case 'rgba':\n\t        if (params.length !== 4) {\n\t          setRgba(rgbaArr, 0, 0, 0, 1);\n\t          return;\n\t        }\n\t\n\t        alpha = parseCssFloat(params.pop());\n\t      // jshint ignore:line\n\t      // Fall through.\n\t\n\t      case 'rgb':\n\t        if (params.length !== 3) {\n\t          setRgba(rgbaArr, 0, 0, 0, 1);\n\t          return;\n\t        }\n\t\n\t        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);\n\t        putToCache(colorStr, rgbaArr);\n\t        return rgbaArr;\n\t\n\t      case 'hsla':\n\t        if (params.length !== 4) {\n\t          setRgba(rgbaArr, 0, 0, 0, 1);\n\t          return;\n\t        }\n\t\n\t        params[3] = parseCssFloat(params[3]);\n\t        hsla2rgba(params, rgbaArr);\n\t        putToCache(colorStr, rgbaArr);\n\t        return rgbaArr;\n\t\n\t      case 'hsl':\n\t        if (params.length !== 3) {\n\t          setRgba(rgbaArr, 0, 0, 0, 1);\n\t          return;\n\t        }\n\t\n\t        hsla2rgba(params, rgbaArr);\n\t        putToCache(colorStr, rgbaArr);\n\t        return rgbaArr;\n\t\n\t      default:\n\t        return;\n\t    }\n\t  }\n\t\n\t  setRgba(rgbaArr, 0, 0, 0, 1);\n\t  return;\n\t}\n\t/**\n\t * @param {Array.<number>} hsla\n\t * @param {Array.<number>} rgba\n\t * @return {Array.<number>} rgba\n\t */\n\t\n\t\n\tfunction hsla2rgba(hsla, rgba) {\n\t  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1\n\t  // NOTE(deanm): According to the CSS spec s/l should only be\n\t  // percentages, but we don't bother and let float or percentage.\n\t\n\t  var s = parseCssFloat(hsla[1]);\n\t  var l = parseCssFloat(hsla[2]);\n\t  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n\t  var m1 = l * 2 - m2;\n\t  rgba = rgba || [];\n\t  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);\n\t\n\t  if (hsla.length === 4) {\n\t    rgba[3] = hsla[3];\n\t  }\n\t\n\t  return rgba;\n\t}\n\t/**\n\t * @param {Array.<number>} rgba\n\t * @return {Array.<number>} hsla\n\t */\n\t\n\t\n\tfunction rgba2hsla(rgba) {\n\t  if (!rgba) {\n\t    return;\n\t  } // RGB from 0 to 255\n\t\n\t\n\t  var R = rgba[0] / 255;\n\t  var G = rgba[1] / 255;\n\t  var B = rgba[2] / 255;\n\t  var vMin = Math.min(R, G, B); // Min. value of RGB\n\t\n\t  var vMax = Math.max(R, G, B); // Max. value of RGB\n\t\n\t  var delta = vMax - vMin; // Delta RGB value\n\t\n\t  var L = (vMax + vMin) / 2;\n\t  var H;\n\t  var S; // HSL results from 0 to 1\n\t\n\t  if (delta === 0) {\n\t    H = 0;\n\t    S = 0;\n\t  } else {\n\t    if (L < 0.5) {\n\t      S = delta / (vMax + vMin);\n\t    } else {\n\t      S = delta / (2 - vMax - vMin);\n\t    }\n\t\n\t    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;\n\t    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;\n\t    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;\n\t\n\t    if (R === vMax) {\n\t      H = deltaB - deltaG;\n\t    } else if (G === vMax) {\n\t      H = 1 / 3 + deltaR - deltaB;\n\t    } else if (B === vMax) {\n\t      H = 2 / 3 + deltaG - deltaR;\n\t    }\n\t\n\t    if (H < 0) {\n\t      H += 1;\n\t    }\n\t\n\t    if (H > 1) {\n\t      H -= 1;\n\t    }\n\t  }\n\t\n\t  var hsla = [H * 360, S, L];\n\t\n\t  if (rgba[3] != null) {\n\t    hsla.push(rgba[3]);\n\t  }\n\t\n\t  return hsla;\n\t}\n\t/**\n\t * @param {string} color\n\t * @param {number} level\n\t * @return {string}\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\t\n\tfunction lift(color, level) {\n\t  var colorArr = parse(color);\n\t\n\t  if (colorArr) {\n\t    for (var i = 0; i < 3; i++) {\n\t      if (level < 0) {\n\t        colorArr[i] = colorArr[i] * (1 - level) | 0;\n\t      } else {\n\t        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;\n\t      }\n\t    }\n\t\n\t    return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n\t  }\n\t}\n\t/**\n\t * @param {string} color\n\t * @return {string}\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\t\n\tfunction toHex(color) {\n\t  var colorArr = parse(color);\n\t\n\t  if (colorArr) {\n\t    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);\n\t  }\n\t}\n\t/**\n\t * Map value to color. Faster than lerp methods because color is represented by rgba array.\n\t * @param {number} normalizedValue A float between 0 and 1.\n\t * @param {Array.<Array.<number>>} colors List of rgba color array\n\t * @param {Array.<number>} [out] Mapped gba color array\n\t * @return {Array.<number>} will be null/undefined if input illegal.\n\t */\n\t\n\t\n\tfunction fastLerp(normalizedValue, colors, out) {\n\t  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n\t    return;\n\t  }\n\t\n\t  out = out || [];\n\t  var value = normalizedValue * (colors.length - 1);\n\t  var leftIndex = Math.floor(value);\n\t  var rightIndex = Math.ceil(value);\n\t  var leftColor = colors[leftIndex];\n\t  var rightColor = colors[rightIndex];\n\t  var dv = value - leftIndex;\n\t  out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));\n\t  out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));\n\t  out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));\n\t  out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));\n\t  return out;\n\t}\n\t/**\n\t * @deprecated\n\t */\n\t\n\t\n\tvar fastMapToColor = fastLerp;\n\t/**\n\t * @param {number} normalizedValue A float between 0 and 1.\n\t * @param {Array.<string>} colors Color list.\n\t * @param {boolean=} fullOutput Default false.\n\t * @return {(string|Object)} Result color. If fullOutput,\n\t *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\tfunction lerp(normalizedValue, colors, fullOutput) {\n\t  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n\t    return;\n\t  }\n\t\n\t  var value = normalizedValue * (colors.length - 1);\n\t  var leftIndex = Math.floor(value);\n\t  var rightIndex = Math.ceil(value);\n\t  var leftColor = parse(colors[leftIndex]);\n\t  var rightColor = parse(colors[rightIndex]);\n\t  var dv = value - leftIndex;\n\t  var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');\n\t  return fullOutput ? {\n\t    color: color,\n\t    leftIndex: leftIndex,\n\t    rightIndex: rightIndex,\n\t    value: value\n\t  } : color;\n\t}\n\t/**\n\t * @deprecated\n\t */\n\t\n\t\n\tvar mapToColor = lerp;\n\t/**\n\t * @param {string} color\n\t * @param {number=} h 0 ~ 360, ignore when null.\n\t * @param {number=} s 0 ~ 1, ignore when null.\n\t * @param {number=} l 0 ~ 1, ignore when null.\n\t * @return {string} Color string in rgba format.\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\tfunction modifyHSL(color, h, s, l) {\n\t  color = parse(color);\n\t\n\t  if (color) {\n\t    color = rgba2hsla(color);\n\t    h != null && (color[0] = clampCssAngle(h));\n\t    s != null && (color[1] = parseCssFloat(s));\n\t    l != null && (color[2] = parseCssFloat(l));\n\t    return stringify(hsla2rgba(color), 'rgba');\n\t  }\n\t}\n\t/**\n\t * @param {string} color\n\t * @param {number=} alpha 0 ~ 1\n\t * @return {string} Color string in rgba format.\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\t\n\tfunction modifyAlpha(color, alpha) {\n\t  color = parse(color);\n\t\n\t  if (color && alpha != null) {\n\t    color[3] = clampCssFloat(alpha);\n\t    return stringify(color, 'rgba');\n\t  }\n\t}\n\t/**\n\t * @param {Array.<number>} arrColor like [12,33,44,0.4]\n\t * @param {string} type 'rgba', 'hsva', ...\n\t * @return {string} Result color. (If input illegal, return undefined).\n\t */\n\t\n\t\n\tfunction stringify(arrColor, type) {\n\t  if (!arrColor || !arrColor.length) {\n\t    return;\n\t  }\n\t\n\t  var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\t\n\t  if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n\t    colorStr += ',' + arrColor[3];\n\t  }\n\t\n\t  return type + '(' + colorStr + ')';\n\t}\n\t\n\texports.parse = parse;\n\texports.lift = lift;\n\texports.toHex = toHex;\n\texports.fastLerp = fastLerp;\n\texports.fastMapToColor = fastMapToColor;\n\texports.lerp = lerp;\n\texports.mapToColor = mapToColor;\n\texports.modifyHSL = modifyHSL;\n\texports.modifyAlpha = modifyAlpha;\n\texports.stringify = stringify;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports) {\n\n\t// Simple LRU cache use doubly linked list\n\t// @module zrender/core/LRU\n\t\n\t/**\n\t * Simple double linked list. Compared with array, it has O(1) remove operation.\n\t * @constructor\n\t */\n\tvar LinkedList = function () {\n\t  /**\n\t   * @type {module:zrender/core/LRU~Entry}\n\t   */\n\t  this.head = null;\n\t  /**\n\t   * @type {module:zrender/core/LRU~Entry}\n\t   */\n\t\n\t  this.tail = null;\n\t  this._len = 0;\n\t};\n\t\n\tvar linkedListProto = LinkedList.prototype;\n\t/**\n\t * Insert a new value at the tail\n\t * @param  {} val\n\t * @return {module:zrender/core/LRU~Entry}\n\t */\n\t\n\tlinkedListProto.insert = function (val) {\n\t  var entry = new Entry(val);\n\t  this.insertEntry(entry);\n\t  return entry;\n\t};\n\t/**\n\t * Insert an entry at the tail\n\t * @param  {module:zrender/core/LRU~Entry} entry\n\t */\n\t\n\t\n\tlinkedListProto.insertEntry = function (entry) {\n\t  if (!this.head) {\n\t    this.head = this.tail = entry;\n\t  } else {\n\t    this.tail.next = entry;\n\t    entry.prev = this.tail;\n\t    entry.next = null;\n\t    this.tail = entry;\n\t  }\n\t\n\t  this._len++;\n\t};\n\t/**\n\t * Remove entry.\n\t * @param  {module:zrender/core/LRU~Entry} entry\n\t */\n\t\n\t\n\tlinkedListProto.remove = function (entry) {\n\t  var prev = entry.prev;\n\t  var next = entry.next;\n\t\n\t  if (prev) {\n\t    prev.next = next;\n\t  } else {\n\t    // Is head\n\t    this.head = next;\n\t  }\n\t\n\t  if (next) {\n\t    next.prev = prev;\n\t  } else {\n\t    // Is tail\n\t    this.tail = prev;\n\t  }\n\t\n\t  entry.next = entry.prev = null;\n\t  this._len--;\n\t};\n\t/**\n\t * @return {number}\n\t */\n\t\n\t\n\tlinkedListProto.len = function () {\n\t  return this._len;\n\t};\n\t/**\n\t * Clear list\n\t */\n\t\n\t\n\tlinkedListProto.clear = function () {\n\t  this.head = this.tail = null;\n\t  this._len = 0;\n\t};\n\t/**\n\t * @constructor\n\t * @param {} val\n\t */\n\t\n\t\n\tvar Entry = function (val) {\n\t  /**\n\t   * @type {}\n\t   */\n\t  this.value = val;\n\t  /**\n\t   * @type {module:zrender/core/LRU~Entry}\n\t   */\n\t\n\t  this.next;\n\t  /**\n\t   * @type {module:zrender/core/LRU~Entry}\n\t   */\n\t\n\t  this.prev;\n\t};\n\t/**\n\t * LRU Cache\n\t * @constructor\n\t * @alias module:zrender/core/LRU\n\t */\n\t\n\t\n\tvar LRU = function (maxSize) {\n\t  this._list = new LinkedList();\n\t  this._map = {};\n\t  this._maxSize = maxSize || 10;\n\t  this._lastRemovedEntry = null;\n\t};\n\t\n\tvar LRUProto = LRU.prototype;\n\t/**\n\t * @param  {string} key\n\t * @param  {} value\n\t * @return {} Removed value\n\t */\n\t\n\tLRUProto.put = function (key, value) {\n\t  var list = this._list;\n\t  var map = this._map;\n\t  var removed = null;\n\t\n\t  if (map[key] == null) {\n\t    var len = list.len(); // Reuse last removed entry\n\t\n\t    var entry = this._lastRemovedEntry;\n\t\n\t    if (len >= this._maxSize && len > 0) {\n\t      // Remove the least recently used\n\t      var leastUsedEntry = list.head;\n\t      list.remove(leastUsedEntry);\n\t      delete map[leastUsedEntry.key];\n\t      removed = leastUsedEntry.value;\n\t      this._lastRemovedEntry = leastUsedEntry;\n\t    }\n\t\n\t    if (entry) {\n\t      entry.value = value;\n\t    } else {\n\t      entry = new Entry(value);\n\t    }\n\t\n\t    entry.key = key;\n\t    list.insertEntry(entry);\n\t    map[key] = entry;\n\t  }\n\t\n\t  return removed;\n\t};\n\t/**\n\t * @param  {string} key\n\t * @return {}\n\t */\n\t\n\t\n\tLRUProto.get = function (key) {\n\t  var entry = this._map[key];\n\t  var list = this._list;\n\t\n\t  if (entry != null) {\n\t    // Put the latest used entry in the tail\n\t    if (entry !== list.tail) {\n\t      list.remove(entry);\n\t      list.insertEntry(entry);\n\t    }\n\t\n\t    return entry.value;\n\t  }\n\t};\n\t/**\n\t * Clear the cache\n\t */\n\t\n\t\n\tLRUProto.clear = function () {\n\t  this._list.clear();\n\t\n\t  this._map = {};\n\t};\n\t\n\tvar _default = LRU;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _config = __webpack_require__(23);\n\t\n\tvar debugMode = _config.debugMode;\n\t\n\tvar log = function () {};\n\t\n\tif (debugMode === 1) {\n\t  log = function () {\n\t    for (var k in arguments) {\n\t      throw new Error(arguments[k]);\n\t    }\n\t  };\n\t} else if (debugMode > 1) {\n\t  log = function () {\n\t    for (var k in arguments) {\n\t      console.log(arguments[k]);\n\t    }\n\t  };\n\t}\n\t\n\tvar _default = log;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports) {\n\n\tvar dpr = 1; // If in browser environment\n\t\n\tif (typeof window !== 'undefined') {\n\t  dpr = Math.max(window.devicePixelRatio || 1, 1);\n\t}\n\t/**\n\t * config默认配置项\n\t * @exports zrender/config\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t */\n\t\n\t/**\n\t * debug日志选项：catchBrushException为true下有效\n\t * 0 : 不生成debug数据，发布用\n\t * 1 : 异常抛出，调试用\n\t * 2 : 控制台输出，调试用\n\t */\n\t\n\t\n\tvar debugMode = 0; // retina 屏幕优化\n\t\n\tvar devicePixelRatio = dpr;\n\texports.debugMode = debugMode;\n\texports.devicePixelRatio = devicePixelRatio;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar vec2 = __webpack_require__(8);\n\t\n\tvar matrix = __webpack_require__(15);\n\t\n\t/**\n\t * @module echarts/core/BoundingRect\n\t */\n\tvar v2ApplyTransform = vec2.applyTransform;\n\tvar mathMin = Math.min;\n\tvar mathMax = Math.max;\n\t/**\n\t * @alias module:echarts/core/BoundingRect\n\t */\n\t\n\tfunction BoundingRect(x, y, width, height) {\n\t  if (width < 0) {\n\t    x = x + width;\n\t    width = -width;\n\t  }\n\t\n\t  if (height < 0) {\n\t    y = y + height;\n\t    height = -height;\n\t  }\n\t  /**\n\t   * @type {number}\n\t   */\n\t\n\t\n\t  this.x = x;\n\t  /**\n\t   * @type {number}\n\t   */\n\t\n\t  this.y = y;\n\t  /**\n\t   * @type {number}\n\t   */\n\t\n\t  this.width = width;\n\t  /**\n\t   * @type {number}\n\t   */\n\t\n\t  this.height = height;\n\t}\n\t\n\tBoundingRect.prototype = {\n\t  constructor: BoundingRect,\n\t\n\t  /**\n\t   * @param {module:echarts/core/BoundingRect} other\n\t   */\n\t  union: function (other) {\n\t    var x = mathMin(other.x, this.x);\n\t    var y = mathMin(other.y, this.y);\n\t    this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n\t    this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n\t    this.x = x;\n\t    this.y = y;\n\t  },\n\t\n\t  /**\n\t   * @param {Array.<number>} m\n\t   * @methods\n\t   */\n\t  applyTransform: function () {\n\t    var lt = [];\n\t    var rb = [];\n\t    var lb = [];\n\t    var rt = [];\n\t    return function (m) {\n\t      // In case usage like this\n\t      // el.getBoundingRect().applyTransform(el.transform)\n\t      // And element has no transform\n\t      if (!m) {\n\t        return;\n\t      }\n\t\n\t      lt[0] = lb[0] = this.x;\n\t      lt[1] = rt[1] = this.y;\n\t      rb[0] = rt[0] = this.x + this.width;\n\t      rb[1] = lb[1] = this.y + this.height;\n\t      v2ApplyTransform(lt, lt, m);\n\t      v2ApplyTransform(rb, rb, m);\n\t      v2ApplyTransform(lb, lb, m);\n\t      v2ApplyTransform(rt, rt, m);\n\t      this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n\t      this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n\t      var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n\t      var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n\t      this.width = maxX - this.x;\n\t      this.height = maxY - this.y;\n\t    };\n\t  }(),\n\t\n\t  /**\n\t   * Calculate matrix of transforming from self to target rect\n\t   * @param  {module:zrender/core/BoundingRect} b\n\t   * @return {Array.<number>}\n\t   */\n\t  calculateTransform: function (b) {\n\t    var a = this;\n\t    var sx = b.width / a.width;\n\t    var sy = b.height / a.height;\n\t    var m = matrix.create(); // 矩阵右乘\n\t\n\t    matrix.translate(m, m, [-a.x, -a.y]);\n\t    matrix.scale(m, m, [sx, sy]);\n\t    matrix.translate(m, m, [b.x, b.y]);\n\t    return m;\n\t  },\n\t\n\t  /**\n\t   * @param {(module:echarts/core/BoundingRect|Object)} b\n\t   * @return {boolean}\n\t   */\n\t  intersect: function (b) {\n\t    if (!b) {\n\t      return false;\n\t    }\n\t\n\t    if (!(b instanceof BoundingRect)) {\n\t      // Normalize negative width/height.\n\t      b = BoundingRect.create(b);\n\t    }\n\t\n\t    var a = this;\n\t    var ax0 = a.x;\n\t    var ax1 = a.x + a.width;\n\t    var ay0 = a.y;\n\t    var ay1 = a.y + a.height;\n\t    var bx0 = b.x;\n\t    var bx1 = b.x + b.width;\n\t    var by0 = b.y;\n\t    var by1 = b.y + b.height;\n\t    return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n\t  },\n\t  contain: function (x, y) {\n\t    var rect = this;\n\t    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n\t  },\n\t\n\t  /**\n\t   * @return {module:echarts/core/BoundingRect}\n\t   */\n\t  clone: function () {\n\t    return new BoundingRect(this.x, this.y, this.width, this.height);\n\t  },\n\t\n\t  /**\n\t   * Copy from another rect\n\t   */\n\t  copy: function (other) {\n\t    this.x = other.x;\n\t    this.y = other.y;\n\t    this.width = other.width;\n\t    this.height = other.height;\n\t  },\n\t  plain: function () {\n\t    return {\n\t      x: this.x,\n\t      y: this.y,\n\t      width: this.width,\n\t      height: this.height\n\t    };\n\t  }\n\t};\n\t/**\n\t * @param {Object|module:zrender/core/BoundingRect} rect\n\t * @param {number} rect.x\n\t * @param {number} rect.y\n\t * @param {number} rect.width\n\t * @param {number} rect.height\n\t * @return {module:zrender/core/BoundingRect}\n\t */\n\t\n\tBoundingRect.create = function (rect) {\n\t  return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n\t};\n\t\n\tvar _default = BoundingRect;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports) {\n\n\t// https://github.com/mziccard/node-timsort\n\tvar DEFAULT_MIN_MERGE = 32;\n\tvar DEFAULT_MIN_GALLOPING = 7;\n\tvar DEFAULT_TMP_STORAGE_LENGTH = 256;\n\t\n\tfunction minRunLength(n) {\n\t  var r = 0;\n\t\n\t  while (n >= DEFAULT_MIN_MERGE) {\n\t    r |= n & 1;\n\t    n >>= 1;\n\t  }\n\t\n\t  return n + r;\n\t}\n\t\n\tfunction makeAscendingRun(array, lo, hi, compare) {\n\t  var runHi = lo + 1;\n\t\n\t  if (runHi === hi) {\n\t    return 1;\n\t  }\n\t\n\t  if (compare(array[runHi++], array[lo]) < 0) {\n\t    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n\t      runHi++;\n\t    }\n\t\n\t    reverseRun(array, lo, runHi);\n\t  } else {\n\t    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n\t      runHi++;\n\t    }\n\t  }\n\t\n\t  return runHi - lo;\n\t}\n\t\n\tfunction reverseRun(array, lo, hi) {\n\t  hi--;\n\t\n\t  while (lo < hi) {\n\t    var t = array[lo];\n\t    array[lo++] = array[hi];\n\t    array[hi--] = t;\n\t  }\n\t}\n\t\n\tfunction binaryInsertionSort(array, lo, hi, start, compare) {\n\t  if (start === lo) {\n\t    start++;\n\t  }\n\t\n\t  for (; start < hi; start++) {\n\t    var pivot = array[start];\n\t    var left = lo;\n\t    var right = start;\n\t    var mid;\n\t\n\t    while (left < right) {\n\t      mid = left + right >>> 1;\n\t\n\t      if (compare(pivot, array[mid]) < 0) {\n\t        right = mid;\n\t      } else {\n\t        left = mid + 1;\n\t      }\n\t    }\n\t\n\t    var n = start - left;\n\t\n\t    switch (n) {\n\t      case 3:\n\t        array[left + 3] = array[left + 2];\n\t\n\t      case 2:\n\t        array[left + 2] = array[left + 1];\n\t\n\t      case 1:\n\t        array[left + 1] = array[left];\n\t        break;\n\t\n\t      default:\n\t        while (n > 0) {\n\t          array[left + n] = array[left + n - 1];\n\t          n--;\n\t        }\n\t\n\t    }\n\t\n\t    array[left] = pivot;\n\t  }\n\t}\n\t\n\tfunction gallopLeft(value, array, start, length, hint, compare) {\n\t  var lastOffset = 0;\n\t  var maxOffset = 0;\n\t  var offset = 1;\n\t\n\t  if (compare(value, array[start + hint]) > 0) {\n\t    maxOffset = length - hint;\n\t\n\t    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n\t      lastOffset = offset;\n\t      offset = (offset << 1) + 1;\n\t\n\t      if (offset <= 0) {\n\t        offset = maxOffset;\n\t      }\n\t    }\n\t\n\t    if (offset > maxOffset) {\n\t      offset = maxOffset;\n\t    }\n\t\n\t    lastOffset += hint;\n\t    offset += hint;\n\t  } else {\n\t    maxOffset = hint + 1;\n\t\n\t    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n\t      lastOffset = offset;\n\t      offset = (offset << 1) + 1;\n\t\n\t      if (offset <= 0) {\n\t        offset = maxOffset;\n\t      }\n\t    }\n\t\n\t    if (offset > maxOffset) {\n\t      offset = maxOffset;\n\t    }\n\t\n\t    var tmp = lastOffset;\n\t    lastOffset = hint - offset;\n\t    offset = hint - tmp;\n\t  }\n\t\n\t  lastOffset++;\n\t\n\t  while (lastOffset < offset) {\n\t    var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t    if (compare(value, array[start + m]) > 0) {\n\t      lastOffset = m + 1;\n\t    } else {\n\t      offset = m;\n\t    }\n\t  }\n\t\n\t  return offset;\n\t}\n\t\n\tfunction gallopRight(value, array, start, length, hint, compare) {\n\t  var lastOffset = 0;\n\t  var maxOffset = 0;\n\t  var offset = 1;\n\t\n\t  if (compare(value, array[start + hint]) < 0) {\n\t    maxOffset = hint + 1;\n\t\n\t    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n\t      lastOffset = offset;\n\t      offset = (offset << 1) + 1;\n\t\n\t      if (offset <= 0) {\n\t        offset = maxOffset;\n\t      }\n\t    }\n\t\n\t    if (offset > maxOffset) {\n\t      offset = maxOffset;\n\t    }\n\t\n\t    var tmp = lastOffset;\n\t    lastOffset = hint - offset;\n\t    offset = hint - tmp;\n\t  } else {\n\t    maxOffset = length - hint;\n\t\n\t    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n\t      lastOffset = offset;\n\t      offset = (offset << 1) + 1;\n\t\n\t      if (offset <= 0) {\n\t        offset = maxOffset;\n\t      }\n\t    }\n\t\n\t    if (offset > maxOffset) {\n\t      offset = maxOffset;\n\t    }\n\t\n\t    lastOffset += hint;\n\t    offset += hint;\n\t  }\n\t\n\t  lastOffset++;\n\t\n\t  while (lastOffset < offset) {\n\t    var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t    if (compare(value, array[start + m]) < 0) {\n\t      offset = m;\n\t    } else {\n\t      lastOffset = m + 1;\n\t    }\n\t  }\n\t\n\t  return offset;\n\t}\n\t\n\tfunction TimSort(array, compare) {\n\t  var minGallop = DEFAULT_MIN_GALLOPING;\n\t  var length = 0;\n\t  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n\t  var stackLength = 0;\n\t  var runStart;\n\t  var runLength;\n\t  var stackSize = 0;\n\t  length = array.length;\n\t\n\t  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n\t    tmpStorageLength = length >>> 1;\n\t  }\n\t\n\t  var tmp = [];\n\t  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\t  runStart = [];\n\t  runLength = [];\n\t\n\t  function pushRun(_runStart, _runLength) {\n\t    runStart[stackSize] = _runStart;\n\t    runLength[stackSize] = _runLength;\n\t    stackSize += 1;\n\t  }\n\t\n\t  function mergeRuns() {\n\t    while (stackSize > 1) {\n\t      var n = stackSize - 2;\n\t\n\t      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n\t        if (runLength[n - 1] < runLength[n + 1]) {\n\t          n--;\n\t        }\n\t      } else if (runLength[n] > runLength[n + 1]) {\n\t        break;\n\t      }\n\t\n\t      mergeAt(n);\n\t    }\n\t  }\n\t\n\t  function forceMergeRuns() {\n\t    while (stackSize > 1) {\n\t      var n = stackSize - 2;\n\t\n\t      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n\t        n--;\n\t      }\n\t\n\t      mergeAt(n);\n\t    }\n\t  }\n\t\n\t  function mergeAt(i) {\n\t    var start1 = runStart[i];\n\t    var length1 = runLength[i];\n\t    var start2 = runStart[i + 1];\n\t    var length2 = runLength[i + 1];\n\t    runLength[i] = length1 + length2;\n\t\n\t    if (i === stackSize - 3) {\n\t      runStart[i + 1] = runStart[i + 2];\n\t      runLength[i + 1] = runLength[i + 2];\n\t    }\n\t\n\t    stackSize--;\n\t    var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n\t    start1 += k;\n\t    length1 -= k;\n\t\n\t    if (length1 === 0) {\n\t      return;\n\t    }\n\t\n\t    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\t\n\t    if (length2 === 0) {\n\t      return;\n\t    }\n\t\n\t    if (length1 <= length2) {\n\t      mergeLow(start1, length1, start2, length2);\n\t    } else {\n\t      mergeHigh(start1, length1, start2, length2);\n\t    }\n\t  }\n\t\n\t  function mergeLow(start1, length1, start2, length2) {\n\t    var i = 0;\n\t\n\t    for (i = 0; i < length1; i++) {\n\t      tmp[i] = array[start1 + i];\n\t    }\n\t\n\t    var cursor1 = 0;\n\t    var cursor2 = start2;\n\t    var dest = start1;\n\t    array[dest++] = array[cursor2++];\n\t\n\t    if (--length2 === 0) {\n\t      for (i = 0; i < length1; i++) {\n\t        array[dest + i] = tmp[cursor1 + i];\n\t      }\n\t\n\t      return;\n\t    }\n\t\n\t    if (length1 === 1) {\n\t      for (i = 0; i < length2; i++) {\n\t        array[dest + i] = array[cursor2 + i];\n\t      }\n\t\n\t      array[dest + length2] = tmp[cursor1];\n\t      return;\n\t    }\n\t\n\t    var _minGallop = minGallop;\n\t    var count1, count2, exit;\n\t\n\t    while (1) {\n\t      count1 = 0;\n\t      count2 = 0;\n\t      exit = false;\n\t\n\t      do {\n\t        if (compare(array[cursor2], tmp[cursor1]) < 0) {\n\t          array[dest++] = array[cursor2++];\n\t          count2++;\n\t          count1 = 0;\n\t\n\t          if (--length2 === 0) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        } else {\n\t          array[dest++] = tmp[cursor1++];\n\t          count1++;\n\t          count2 = 0;\n\t\n\t          if (--length1 === 1) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t      } while ((count1 | count2) < _minGallop);\n\t\n\t      if (exit) {\n\t        break;\n\t      }\n\t\n\t      do {\n\t        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\t\n\t        if (count1 !== 0) {\n\t          for (i = 0; i < count1; i++) {\n\t            array[dest + i] = tmp[cursor1 + i];\n\t          }\n\t\n\t          dest += count1;\n\t          cursor1 += count1;\n\t          length1 -= count1;\n\t\n\t          if (length1 <= 1) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t\n\t        array[dest++] = array[cursor2++];\n\t\n\t        if (--length2 === 0) {\n\t          exit = true;\n\t          break;\n\t        }\n\t\n\t        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\t\n\t        if (count2 !== 0) {\n\t          for (i = 0; i < count2; i++) {\n\t            array[dest + i] = array[cursor2 + i];\n\t          }\n\t\n\t          dest += count2;\n\t          cursor2 += count2;\n\t          length2 -= count2;\n\t\n\t          if (length2 === 0) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t\n\t        array[dest++] = tmp[cursor1++];\n\t\n\t        if (--length1 === 1) {\n\t          exit = true;\n\t          break;\n\t        }\n\t\n\t        _minGallop--;\n\t      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t      if (exit) {\n\t        break;\n\t      }\n\t\n\t      if (_minGallop < 0) {\n\t        _minGallop = 0;\n\t      }\n\t\n\t      _minGallop += 2;\n\t    }\n\t\n\t    minGallop = _minGallop;\n\t    minGallop < 1 && (minGallop = 1);\n\t\n\t    if (length1 === 1) {\n\t      for (i = 0; i < length2; i++) {\n\t        array[dest + i] = array[cursor2 + i];\n\t      }\n\t\n\t      array[dest + length2] = tmp[cursor1];\n\t    } else if (length1 === 0) {\n\t      throw new Error(); // throw new Error('mergeLow preconditions were not respected');\n\t    } else {\n\t      for (i = 0; i < length1; i++) {\n\t        array[dest + i] = tmp[cursor1 + i];\n\t      }\n\t    }\n\t  }\n\t\n\t  function mergeHigh(start1, length1, start2, length2) {\n\t    var i = 0;\n\t\n\t    for (i = 0; i < length2; i++) {\n\t      tmp[i] = array[start2 + i];\n\t    }\n\t\n\t    var cursor1 = start1 + length1 - 1;\n\t    var cursor2 = length2 - 1;\n\t    var dest = start2 + length2 - 1;\n\t    var customCursor = 0;\n\t    var customDest = 0;\n\t    array[dest--] = array[cursor1--];\n\t\n\t    if (--length1 === 0) {\n\t      customCursor = dest - (length2 - 1);\n\t\n\t      for (i = 0; i < length2; i++) {\n\t        array[customCursor + i] = tmp[i];\n\t      }\n\t\n\t      return;\n\t    }\n\t\n\t    if (length2 === 1) {\n\t      dest -= length1;\n\t      cursor1 -= length1;\n\t      customDest = dest + 1;\n\t      customCursor = cursor1 + 1;\n\t\n\t      for (i = length1 - 1; i >= 0; i--) {\n\t        array[customDest + i] = array[customCursor + i];\n\t      }\n\t\n\t      array[dest] = tmp[cursor2];\n\t      return;\n\t    }\n\t\n\t    var _minGallop = minGallop;\n\t\n\t    while (true) {\n\t      var count1 = 0;\n\t      var count2 = 0;\n\t      var exit = false;\n\t\n\t      do {\n\t        if (compare(tmp[cursor2], array[cursor1]) < 0) {\n\t          array[dest--] = array[cursor1--];\n\t          count1++;\n\t          count2 = 0;\n\t\n\t          if (--length1 === 0) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        } else {\n\t          array[dest--] = tmp[cursor2--];\n\t          count2++;\n\t          count1 = 0;\n\t\n\t          if (--length2 === 1) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t      } while ((count1 | count2) < _minGallop);\n\t\n\t      if (exit) {\n\t        break;\n\t      }\n\t\n\t      do {\n\t        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\t\n\t        if (count1 !== 0) {\n\t          dest -= count1;\n\t          cursor1 -= count1;\n\t          length1 -= count1;\n\t          customDest = dest + 1;\n\t          customCursor = cursor1 + 1;\n\t\n\t          for (i = count1 - 1; i >= 0; i--) {\n\t            array[customDest + i] = array[customCursor + i];\n\t          }\n\t\n\t          if (length1 === 0) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t\n\t        array[dest--] = tmp[cursor2--];\n\t\n\t        if (--length2 === 1) {\n\t          exit = true;\n\t          break;\n\t        }\n\t\n\t        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\t\n\t        if (count2 !== 0) {\n\t          dest -= count2;\n\t          cursor2 -= count2;\n\t          length2 -= count2;\n\t          customDest = dest + 1;\n\t          customCursor = cursor2 + 1;\n\t\n\t          for (i = 0; i < count2; i++) {\n\t            array[customDest + i] = tmp[customCursor + i];\n\t          }\n\t\n\t          if (length2 <= 1) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t\n\t        array[dest--] = array[cursor1--];\n\t\n\t        if (--length1 === 0) {\n\t          exit = true;\n\t          break;\n\t        }\n\t\n\t        _minGallop--;\n\t      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t      if (exit) {\n\t        break;\n\t      }\n\t\n\t      if (_minGallop < 0) {\n\t        _minGallop = 0;\n\t      }\n\t\n\t      _minGallop += 2;\n\t    }\n\t\n\t    minGallop = _minGallop;\n\t\n\t    if (minGallop < 1) {\n\t      minGallop = 1;\n\t    }\n\t\n\t    if (length2 === 1) {\n\t      dest -= length1;\n\t      cursor1 -= length1;\n\t      customDest = dest + 1;\n\t      customCursor = cursor1 + 1;\n\t\n\t      for (i = length1 - 1; i >= 0; i--) {\n\t        array[customDest + i] = array[customCursor + i];\n\t      }\n\t\n\t      array[dest] = tmp[cursor2];\n\t    } else if (length2 === 0) {\n\t      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');\n\t    } else {\n\t      customCursor = dest - (length2 - 1);\n\t\n\t      for (i = 0; i < length2; i++) {\n\t        array[customCursor + i] = tmp[i];\n\t      }\n\t    }\n\t  }\n\t\n\t  this.mergeRuns = mergeRuns;\n\t  this.forceMergeRuns = forceMergeRuns;\n\t  this.pushRun = pushRun;\n\t}\n\t\n\tfunction sort(array, compare, lo, hi) {\n\t  if (!lo) {\n\t    lo = 0;\n\t  }\n\t\n\t  if (!hi) {\n\t    hi = array.length;\n\t  }\n\t\n\t  var remaining = hi - lo;\n\t\n\t  if (remaining < 2) {\n\t    return;\n\t  }\n\t\n\t  var runLength = 0;\n\t\n\t  if (remaining < DEFAULT_MIN_MERGE) {\n\t    runLength = makeAscendingRun(array, lo, hi, compare);\n\t    binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n\t    return;\n\t  }\n\t\n\t  var ts = new TimSort(array, compare);\n\t  var minRun = minRunLength(remaining);\n\t\n\t  do {\n\t    runLength = makeAscendingRun(array, lo, hi, compare);\n\t\n\t    if (runLength < minRun) {\n\t      var force = remaining;\n\t\n\t      if (force > minRun) {\n\t        force = minRun;\n\t      }\n\t\n\t      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n\t      runLength = force;\n\t    }\n\t\n\t    ts.pushRun(lo, runLength);\n\t    ts.mergeRuns();\n\t    remaining -= runLength;\n\t    lo += runLength;\n\t  } while (remaining !== 0);\n\t\n\t  ts.forceMergeRuns();\n\t}\n\t\n\tmodule.exports = sort;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _config = __webpack_require__(23);\n\t\n\tvar devicePixelRatio = _config.devicePixelRatio;\n\t\n\tvar util = __webpack_require__(6);\n\t\n\tvar log = __webpack_require__(22);\n\t\n\tvar BoundingRect = __webpack_require__(24);\n\t\n\tvar timsort = __webpack_require__(25);\n\t\n\tvar Layer = __webpack_require__(27);\n\t\n\tvar requestAnimationFrame = __webpack_require__(30);\n\t\n\tvar Image = __webpack_require__(31);\n\t\n\t/**\n\t * Default canvas painter\n\t * @module zrender/Painter\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t// PENDIGN\n\t// Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n\t//\n\t// Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n\tvar MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\t\n\tfunction parseInt10(val) {\n\t  return parseInt(val, 10);\n\t}\n\t\n\tfunction isLayerValid(layer) {\n\t  if (!layer) {\n\t    return false;\n\t  }\n\t\n\t  if (layer.__builtin__) {\n\t    return true;\n\t  }\n\t\n\t  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n\t    return false;\n\t  }\n\t\n\t  return true;\n\t}\n\t\n\tfunction preProcessLayer(layer) {\n\t  layer.__unusedCount++;\n\t}\n\t\n\tfunction postProcessLayer(layer) {\n\t  if (layer.__unusedCount == 1) {\n\t    layer.clear();\n\t  }\n\t}\n\t\n\tvar tmpRect = new BoundingRect(0, 0, 0, 0);\n\tvar viewRect = new BoundingRect(0, 0, 0, 0);\n\t\n\tfunction isDisplayableCulled(el, width, height) {\n\t  tmpRect.copy(el.getBoundingRect());\n\t\n\t  if (el.transform) {\n\t    tmpRect.applyTransform(el.transform);\n\t  }\n\t\n\t  viewRect.width = width;\n\t  viewRect.height = height;\n\t  return !tmpRect.intersect(viewRect);\n\t}\n\t\n\tfunction isClipPathChanged(clipPaths, prevClipPaths) {\n\t  if (clipPaths == prevClipPaths) {\n\t    // Can both be null or undefined\n\t    return false;\n\t  }\n\t\n\t  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n\t    return true;\n\t  }\n\t\n\t  for (var i = 0; i < clipPaths.length; i++) {\n\t    if (clipPaths[i] !== prevClipPaths[i]) {\n\t      return true;\n\t    }\n\t  }\n\t}\n\t\n\tfunction doClip(clipPaths, ctx) {\n\t  for (var i = 0; i < clipPaths.length; i++) {\n\t    var clipPath = clipPaths[i];\n\t    clipPath.setTransform(ctx);\n\t    ctx.beginPath();\n\t    clipPath.buildPath(ctx, clipPath.shape);\n\t    ctx.clip(); // Transform back\n\t\n\t    clipPath.restoreTransform(ctx);\n\t  }\n\t}\n\t\n\tfunction createRoot(width, height) {\n\t  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n\t\n\t  domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';\n\t  return domRoot;\n\t}\n\t/**\n\t * @alias module:zrender/Painter\n\t * @constructor\n\t * @param {HTMLElement} root 绘图容器\n\t * @param {module:zrender/Storage} storage\n\t * @param {Object} opts\n\t */\n\t\n\t\n\tvar Painter = function (root, storage, opts) {\n\t  this.type = 'canvas'; // In node environment using node-canvas\n\t\n\t  var singleCanvas = !root.nodeName // In node ?\n\t  || root.nodeName.toUpperCase() === 'CANVAS';\n\t  this._opts = opts = util.extend({}, opts || {});\n\t  /**\n\t   * @type {number}\n\t   */\n\t\n\t  this.dpr = opts.devicePixelRatio || devicePixelRatio;\n\t  /**\n\t   * @type {boolean}\n\t   * @private\n\t   */\n\t\n\t  this._singleCanvas = singleCanvas;\n\t  /**\n\t   * 绘图容器\n\t   * @type {HTMLElement}\n\t   */\n\t\n\t  this.root = root;\n\t  var rootStyle = root.style;\n\t\n\t  if (rootStyle) {\n\t    rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n\t    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n\t    root.innerHTML = '';\n\t  }\n\t  /**\n\t   * @type {module:zrender/Storage}\n\t   */\n\t\n\t\n\t  this.storage = storage;\n\t  /**\n\t   * @type {Array.<number>}\n\t   * @private\n\t   */\n\t\n\t  var zlevelList = this._zlevelList = [];\n\t  /**\n\t   * @type {Object.<string, module:zrender/Layer>}\n\t   * @private\n\t   */\n\t\n\t  var layers = this._layers = {};\n\t  /**\n\t   * @type {Object.<string, Object>}\n\t   * @type {private}\n\t   */\n\t\n\t  this._layerConfig = {};\n\t\n\t  if (!singleCanvas) {\n\t    this._width = this._getSize(0);\n\t    this._height = this._getSize(1);\n\t    var domRoot = this._domRoot = createRoot(this._width, this._height);\n\t    root.appendChild(domRoot);\n\t  } else {\n\t    if (opts.width != null) {\n\t      root.width = opts.width;\n\t    }\n\t\n\t    if (opts.height != null) {\n\t      root.height = opts.height;\n\t    } // Use canvas width and height directly\n\t\n\t\n\t    var width = root.width;\n\t    var height = root.height;\n\t    this._width = width;\n\t    this._height = height; // Create layer if only one given canvas\n\t    // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\t\n\t    var mainLayer = new Layer(root, this, 1);\n\t    mainLayer.initContext(); // FIXME Use canvas width and height\n\t    // mainLayer.resize(width, height);\n\t\n\t    layers[0] = mainLayer;\n\t    zlevelList.push(0);\n\t    this._domRoot = root;\n\t  } // Layers for progressive rendering\n\t\n\t\n\t  this._progressiveLayers = [];\n\t  /**\n\t   * @type {module:zrender/Layer}\n\t   * @private\n\t   */\n\t\n\t  this._hoverlayer;\n\t  this._hoverElements = [];\n\t};\n\t\n\tPainter.prototype = {\n\t  constructor: Painter,\n\t  getType: function () {\n\t    return 'canvas';\n\t  },\n\t\n\t  /**\n\t   * If painter use a single canvas\n\t   * @return {boolean}\n\t   */\n\t  isSingleCanvas: function () {\n\t    return this._singleCanvas;\n\t  },\n\t\n\t  /**\n\t   * @return {HTMLDivElement}\n\t   */\n\t  getViewportRoot: function () {\n\t    return this._domRoot;\n\t  },\n\t  getViewportRootOffset: function () {\n\t    var viewportRoot = this.getViewportRoot();\n\t\n\t    if (viewportRoot) {\n\t      return {\n\t        offsetLeft: viewportRoot.offsetLeft || 0,\n\t        offsetTop: viewportRoot.offsetTop || 0\n\t      };\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 刷新\n\t   * @param {boolean} [paintAll=false] 强制绘制所有displayable\n\t   */\n\t  refresh: function (paintAll) {\n\t    var list = this.storage.getDisplayList(true);\n\t    var zlevelList = this._zlevelList;\n\t\n\t    this._paintList(list, paintAll); // Paint custum layers\n\t\n\t\n\t    for (var i = 0; i < zlevelList.length; i++) {\n\t      var z = zlevelList[i];\n\t      var layer = this._layers[z];\n\t\n\t      if (!layer.__builtin__ && layer.refresh) {\n\t        layer.refresh();\n\t      }\n\t    }\n\t\n\t    this.refreshHover();\n\t\n\t    if (this._progressiveLayers.length) {\n\t      this._startProgessive();\n\t    }\n\t\n\t    return this;\n\t  },\n\t  addHover: function (el, hoverStyle) {\n\t    if (el.__hoverMir) {\n\t      return;\n\t    }\n\t\n\t    var elMirror = new el.constructor({\n\t      style: el.style,\n\t      shape: el.shape\n\t    });\n\t    elMirror.__from = el;\n\t    el.__hoverMir = elMirror;\n\t    elMirror.setStyle(hoverStyle);\n\t\n\t    this._hoverElements.push(elMirror);\n\t  },\n\t  removeHover: function (el) {\n\t    var elMirror = el.__hoverMir;\n\t    var hoverElements = this._hoverElements;\n\t    var idx = util.indexOf(hoverElements, elMirror);\n\t\n\t    if (idx >= 0) {\n\t      hoverElements.splice(idx, 1);\n\t    }\n\t\n\t    el.__hoverMir = null;\n\t  },\n\t  clearHover: function (el) {\n\t    var hoverElements = this._hoverElements;\n\t\n\t    for (var i = 0; i < hoverElements.length; i++) {\n\t      var from = hoverElements[i].__from;\n\t\n\t      if (from) {\n\t        from.__hoverMir = null;\n\t      }\n\t    }\n\t\n\t    hoverElements.length = 0;\n\t  },\n\t  refreshHover: function () {\n\t    var hoverElements = this._hoverElements;\n\t    var len = hoverElements.length;\n\t    var hoverLayer = this._hoverlayer;\n\t    hoverLayer && hoverLayer.clear();\n\t\n\t    if (!len) {\n\t      return;\n\t    }\n\t\n\t    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel\n\t    // FIXME?\n\t\n\t    if (!hoverLayer) {\n\t      hoverLayer = this._hoverlayer = this.getLayer(1e5);\n\t    }\n\t\n\t    var scope = {};\n\t    hoverLayer.ctx.save();\n\t\n\t    for (var i = 0; i < len;) {\n\t      var el = hoverElements[i];\n\t      var originalEl = el.__from; // Original el is removed\n\t      // PENDING\n\t\n\t      if (!(originalEl && originalEl.__zr)) {\n\t        hoverElements.splice(i, 1);\n\t        originalEl.__hoverMir = null;\n\t        len--;\n\t        continue;\n\t      }\n\t\n\t      i++; // Use transform\n\t      // FIXME style and shape ?\n\t\n\t      if (!originalEl.invisible) {\n\t        el.transform = originalEl.transform;\n\t        el.invTransform = originalEl.invTransform;\n\t        el.__clipPaths = originalEl.__clipPaths; // el.\n\t\n\t        this._doPaintEl(el, hoverLayer, true, scope);\n\t      }\n\t    }\n\t\n\t    hoverLayer.ctx.restore();\n\t  },\n\t  _startProgessive: function () {\n\t    var self = this;\n\t\n\t    if (!self._furtherProgressive) {\n\t      return;\n\t    } // Use a token to stop progress steps triggered by\n\t    // previous zr.refresh calling.\n\t\n\t\n\t    var token = self._progressiveToken = +new Date();\n\t    self._progress++;\n\t    requestAnimationFrame(step);\n\t\n\t    function step() {\n\t      // In case refreshed or disposed\n\t      if (token === self._progressiveToken && self.storage) {\n\t        self._doPaintList(self.storage.getDisplayList());\n\t\n\t        if (self._furtherProgressive) {\n\t          self._progress++;\n\t          requestAnimationFrame(step);\n\t        } else {\n\t          self._progressiveToken = -1;\n\t        }\n\t      }\n\t    }\n\t  },\n\t  _clearProgressive: function () {\n\t    this._progressiveToken = -1;\n\t    this._progress = 0;\n\t    util.each(this._progressiveLayers, function (layer) {\n\t      layer.__dirty && layer.clear();\n\t    });\n\t  },\n\t  _paintList: function (list, paintAll) {\n\t    if (paintAll == null) {\n\t      paintAll = false;\n\t    }\n\t\n\t    this._updateLayerStatus(list);\n\t\n\t    this._clearProgressive();\n\t\n\t    this.eachBuiltinLayer(preProcessLayer);\n\t\n\t    this._doPaintList(list, paintAll);\n\t\n\t    this.eachBuiltinLayer(postProcessLayer);\n\t  },\n\t  _doPaintList: function (list, paintAll) {\n\t    var currentLayer;\n\t    var currentZLevel;\n\t    var ctx; // var invTransform = [];\n\t\n\t    var scope;\n\t    var progressiveLayerIdx = 0;\n\t    var currentProgressiveLayer;\n\t    var width = this._width;\n\t    var height = this._height;\n\t    var layerProgress;\n\t    var frame = this._progress;\n\t\n\t    function flushProgressiveLayer(layer) {\n\t      var dpr = ctx.dpr || 1;\n\t      ctx.save();\n\t      ctx.globalAlpha = 1;\n\t      ctx.shadowBlur = 0; // Avoid layer don't clear in next progressive frame\n\t\n\t      currentLayer.__dirty = true;\n\t      ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t      ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n\t      ctx.restore();\n\t    }\n\t\n\t    for (var i = 0, l = list.length; i < l; i++) {\n\t      var el = list[i];\n\t      var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\t      var elFrame = el.__frame; // Flush at current context\n\t      // PENDING\n\t\n\t      if (elFrame < 0 && currentProgressiveLayer) {\n\t        flushProgressiveLayer(currentProgressiveLayer);\n\t        currentProgressiveLayer = null;\n\t      } // Change draw layer\n\t\n\t\n\t      if (currentZLevel !== elZLevel) {\n\t        if (ctx) {\n\t          ctx.restore();\n\t        } // Reset scope\n\t\n\t\n\t        scope = {}; // Only 0 zlevel if only has one canvas\n\t\n\t        currentZLevel = elZLevel;\n\t        currentLayer = this.getLayer(currentZLevel);\n\t\n\t        if (!currentLayer.__builtin__) {\n\t          log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);\n\t        }\n\t\n\t        ctx = currentLayer.ctx;\n\t        ctx.save(); // Reset the count\n\t\n\t        currentLayer.__unusedCount = 0;\n\t\n\t        if (currentLayer.__dirty || paintAll) {\n\t          currentLayer.clear();\n\t        }\n\t      }\n\t\n\t      if (!(currentLayer.__dirty || paintAll)) {\n\t        continue;\n\t      }\n\t\n\t      if (elFrame >= 0) {\n\t        // Progressive layer changed\n\t        if (!currentProgressiveLayer) {\n\t          currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];\n\t          currentProgressiveLayer.ctx.save();\n\t          currentProgressiveLayer.renderScope = {};\n\t\n\t          if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {\n\t            // flushProgressiveLayer(currentProgressiveLayer);\n\t            // Quick jump all progressive elements\n\t            // All progressive element are not dirty, jump over and flush directly\n\t            i = currentProgressiveLayer.__nextIdxNotProg - 1; // currentProgressiveLayer = null;\n\t\n\t            continue;\n\t          }\n\t\n\t          layerProgress = currentProgressiveLayer.__progress;\n\t\n\t          if (!currentProgressiveLayer.__dirty) {\n\t            // Keep rendering\n\t            frame = layerProgress;\n\t          }\n\t\n\t          currentProgressiveLayer.__progress = frame + 1;\n\t        }\n\t\n\t        if (elFrame === frame) {\n\t          this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n\t        }\n\t      } else {\n\t        this._doPaintEl(el, currentLayer, paintAll, scope);\n\t      }\n\t\n\t      el.__dirty = false;\n\t    }\n\t\n\t    if (currentProgressiveLayer) {\n\t      flushProgressiveLayer(currentProgressiveLayer);\n\t    } // Restore the lastLayer ctx\n\t\n\t\n\t    ctx && ctx.restore(); // If still has clipping state\n\t    // if (scope.prevElClipPaths) {\n\t    //     ctx.restore();\n\t    // }\n\t\n\t    this._furtherProgressive = false;\n\t    util.each(this._progressiveLayers, function (layer) {\n\t      if (layer.__maxProgress >= layer.__progress) {\n\t        this._furtherProgressive = true;\n\t      }\n\t    }, this);\n\t  },\n\t  _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n\t    var ctx = currentLayer.ctx;\n\t    var m = el.transform;\n\t\n\t    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element\n\t    !el.invisible // Ignore transparent element\n\t    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas\n\t    // Draw a scale 0 element can cause all following draw wrong\n\t    // And setTransform with scale 0 will cause set back transform failed.\n\t    && !(m && !m[0] && !m[3]) // Ignore culled element\n\t    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n\t      var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements\n\t\n\t      if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {\n\t        // If has previous clipping state, restore from it\n\t        if (scope.prevElClipPaths) {\n\t          scope.prevClipLayer.ctx.restore();\n\t          scope.prevClipLayer = scope.prevElClipPaths = null; // Reset prevEl since context has been restored\n\t\n\t          scope.prevEl = null;\n\t        } // New clipping state\n\t\n\t\n\t        if (clipPaths) {\n\t          ctx.save();\n\t          doClip(clipPaths, ctx);\n\t          scope.prevClipLayer = currentLayer;\n\t          scope.prevElClipPaths = clipPaths;\n\t        }\n\t      }\n\t\n\t      el.beforeBrush && el.beforeBrush(ctx);\n\t      el.brush(ctx, scope.prevEl || null);\n\t      scope.prevEl = el;\n\t      el.afterBrush && el.afterBrush(ctx);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n\t   * @param {number} zlevel\n\t   * @return {module:zrender/Layer}\n\t   */\n\t  getLayer: function (zlevel) {\n\t    if (this._singleCanvas) {\n\t      return this._layers[0];\n\t    }\n\t\n\t    var layer = this._layers[zlevel];\n\t\n\t    if (!layer) {\n\t      // Create a new layer\n\t      layer = new Layer('zr_' + zlevel, this, this.dpr);\n\t      layer.__builtin__ = true;\n\t\n\t      if (this._layerConfig[zlevel]) {\n\t        util.merge(layer, this._layerConfig[zlevel], true);\n\t      }\n\t\n\t      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document\n\t      // Or excanvas will get 0px clientWidth and clientHeight\n\t\n\t      layer.initContext();\n\t    }\n\t\n\t    return layer;\n\t  },\n\t  insertLayer: function (zlevel, layer) {\n\t    var layersMap = this._layers;\n\t    var zlevelList = this._zlevelList;\n\t    var len = zlevelList.length;\n\t    var prevLayer = null;\n\t    var i = -1;\n\t    var domRoot = this._domRoot;\n\t\n\t    if (layersMap[zlevel]) {\n\t      log('ZLevel ' + zlevel + ' has been used already');\n\t      return;\n\t    } // Check if is a valid layer\n\t\n\t\n\t    if (!isLayerValid(layer)) {\n\t      log('Layer of zlevel ' + zlevel + ' is not valid');\n\t      return;\n\t    }\n\t\n\t    if (len > 0 && zlevel > zlevelList[0]) {\n\t      for (i = 0; i < len - 1; i++) {\n\t        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n\t          break;\n\t        }\n\t      }\n\t\n\t      prevLayer = layersMap[zlevelList[i]];\n\t    }\n\t\n\t    zlevelList.splice(i + 1, 0, zlevel);\n\t    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.\n\t    // (It can be a WebGL layer and assigned to a ZImage element)\n\t    // But it still under management of zrender.\n\t\n\t    if (!layer.virtual) {\n\t      if (prevLayer) {\n\t        var prevDom = prevLayer.dom;\n\t\n\t        if (prevDom.nextSibling) {\n\t          domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n\t        } else {\n\t          domRoot.appendChild(layer.dom);\n\t        }\n\t      } else {\n\t        if (domRoot.firstChild) {\n\t          domRoot.insertBefore(layer.dom, domRoot.firstChild);\n\t        } else {\n\t          domRoot.appendChild(layer.dom);\n\t        }\n\t      }\n\t    }\n\t  },\n\t  // Iterate each layer\n\t  eachLayer: function (cb, context) {\n\t    var zlevelList = this._zlevelList;\n\t    var z;\n\t    var i;\n\t\n\t    for (i = 0; i < zlevelList.length; i++) {\n\t      z = zlevelList[i];\n\t      cb.call(context, this._layers[z], z);\n\t    }\n\t  },\n\t  // Iterate each buildin layer\n\t  eachBuiltinLayer: function (cb, context) {\n\t    var zlevelList = this._zlevelList;\n\t    var layer;\n\t    var z;\n\t    var i;\n\t\n\t    for (i = 0; i < zlevelList.length; i++) {\n\t      z = zlevelList[i];\n\t      layer = this._layers[z];\n\t\n\t      if (layer.__builtin__) {\n\t        cb.call(context, layer, z);\n\t      }\n\t    }\n\t  },\n\t  // Iterate each other layer except buildin layer\n\t  eachOtherLayer: function (cb, context) {\n\t    var zlevelList = this._zlevelList;\n\t    var layer;\n\t    var z;\n\t    var i;\n\t\n\t    for (i = 0; i < zlevelList.length; i++) {\n\t      z = zlevelList[i];\n\t      layer = this._layers[z];\n\t\n\t      if (!layer.__builtin__) {\n\t        cb.call(context, layer, z);\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 获取所有已创建的层\n\t   * @param {Array.<module:zrender/Layer>} [prevLayer]\n\t   */\n\t  getLayers: function () {\n\t    return this._layers;\n\t  },\n\t  _updateLayerStatus: function (list) {\n\t    var layers = this._layers;\n\t    var progressiveLayers = this._progressiveLayers;\n\t    var elCountsLastFrame = {};\n\t    var progressiveElCountsLastFrame = {};\n\t    this.eachBuiltinLayer(function (layer, z) {\n\t      elCountsLastFrame[z] = layer.elCount;\n\t      layer.elCount = 0;\n\t      layer.__dirty = false;\n\t    });\n\t    util.each(progressiveLayers, function (layer, idx) {\n\t      progressiveElCountsLastFrame[idx] = layer.elCount;\n\t      layer.elCount = 0;\n\t      layer.__dirty = false;\n\t    });\n\t    var progressiveLayerCount = 0;\n\t    var currentProgressiveLayer;\n\t    var lastProgressiveKey;\n\t    var frameCount = 0;\n\t\n\t    for (var i = 0, l = list.length; i < l; i++) {\n\t      var el = list[i];\n\t      var zlevel = this._singleCanvas ? 0 : el.zlevel;\n\t      var layer = layers[zlevel];\n\t      var elProgress = el.progressive;\n\t\n\t      if (layer) {\n\t        layer.elCount++;\n\t        layer.__dirty = layer.__dirty || el.__dirty;\n\t      } /////// Update progressive\n\t\n\t\n\t      if (elProgress >= 0) {\n\t        // Fix wrong progressive sequence problem.\n\t        if (lastProgressiveKey !== elProgress) {\n\t          lastProgressiveKey = elProgress;\n\t          frameCount++;\n\t        }\n\t\n\t        var elFrame = el.__frame = frameCount - 1;\n\t\n\t        if (!currentProgressiveLayer) {\n\t          var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n\t          currentProgressiveLayer = progressiveLayers[idx];\n\t\n\t          if (!currentProgressiveLayer) {\n\t            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);\n\t            currentProgressiveLayer.initContext();\n\t          }\n\t\n\t          currentProgressiveLayer.__maxProgress = 0;\n\t        }\n\t\n\t        currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n\t        currentProgressiveLayer.elCount++;\n\t        currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);\n\t\n\t        if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n\t          // Should keep rendering this  layer because progressive rendering is not finished yet\n\t          layer.__dirty = true;\n\t        }\n\t      } else {\n\t        el.__frame = -1;\n\t\n\t        if (currentProgressiveLayer) {\n\t          currentProgressiveLayer.__nextIdxNotProg = i;\n\t          progressiveLayerCount++;\n\t          currentProgressiveLayer = null;\n\t        }\n\t      }\n\t    }\n\t\n\t    if (currentProgressiveLayer) {\n\t      progressiveLayerCount++;\n\t      currentProgressiveLayer.__nextIdxNotProg = i;\n\t    } // 层中的元素数量有发生变化\n\t\n\t\n\t    this.eachBuiltinLayer(function (layer, z) {\n\t      if (elCountsLastFrame[z] !== layer.elCount) {\n\t        layer.__dirty = true;\n\t      }\n\t    });\n\t    progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n\t    util.each(progressiveLayers, function (layer, idx) {\n\t      if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n\t        el.__dirty = true;\n\t      }\n\t\n\t      if (layer.__dirty) {\n\t        layer.__progress = 0;\n\t      }\n\t    });\n\t  },\n\t\n\t  /**\n\t   * 清除hover层外所有内容\n\t   */\n\t  clear: function () {\n\t    this.eachBuiltinLayer(this._clearLayer);\n\t    return this;\n\t  },\n\t  _clearLayer: function (layer) {\n\t    layer.clear();\n\t  },\n\t\n\t  /**\n\t   * 修改指定zlevel的绘制参数\n\t   *\n\t   * @param {string} zlevel\n\t   * @param {Object} config 配置对象\n\t   * @param {string} [config.clearColor=0] 每次清空画布的颜色\n\t   * @param {string} [config.motionBlur=false] 是否开启动态模糊\n\t   * @param {number} [config.lastFrameAlpha=0.7]\n\t   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n\t   */\n\t  configLayer: function (zlevel, config) {\n\t    if (config) {\n\t      var layerConfig = this._layerConfig;\n\t\n\t      if (!layerConfig[zlevel]) {\n\t        layerConfig[zlevel] = config;\n\t      } else {\n\t        util.merge(layerConfig[zlevel], config, true);\n\t      }\n\t\n\t      var layer = this._layers[zlevel];\n\t\n\t      if (layer) {\n\t        util.merge(layer, layerConfig[zlevel], true);\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 删除指定层\n\t   * @param {number} zlevel 层所在的zlevel\n\t   */\n\t  delLayer: function (zlevel) {\n\t    var layers = this._layers;\n\t    var zlevelList = this._zlevelList;\n\t    var layer = layers[zlevel];\n\t\n\t    if (!layer) {\n\t      return;\n\t    }\n\t\n\t    layer.dom.parentNode.removeChild(layer.dom);\n\t    delete layers[zlevel];\n\t    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n\t  },\n\t\n\t  /**\n\t   * 区域大小变化后重绘\n\t   */\n\t  resize: function (width, height) {\n\t    var domRoot = this._domRoot; // FIXME Why ?\n\t\n\t    domRoot.style.display = 'none'; // Save input w/h\n\t\n\t    var opts = this._opts;\n\t    width != null && (opts.width = width);\n\t    height != null && (opts.height = height);\n\t    width = this._getSize(0);\n\t    height = this._getSize(1);\n\t    domRoot.style.display = ''; // 优化没有实际改变的resize\n\t\n\t    if (this._width != width || height != this._height) {\n\t      domRoot.style.width = width + 'px';\n\t      domRoot.style.height = height + 'px';\n\t\n\t      for (var id in this._layers) {\n\t        if (this._layers.hasOwnProperty(id)) {\n\t          this._layers[id].resize(width, height);\n\t        }\n\t      }\n\t\n\t      util.each(this._progressiveLayers, function (layer) {\n\t        layer.resize(width, height);\n\t      });\n\t      this.refresh(true);\n\t    }\n\t\n\t    this._width = width;\n\t    this._height = height;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 清除单独的一个层\n\t   * @param {number} zlevel\n\t   */\n\t  clearLayer: function (zlevel) {\n\t    var layer = this._layers[zlevel];\n\t\n\t    if (layer) {\n\t      layer.clear();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 释放\n\t   */\n\t  dispose: function () {\n\t    this.root.innerHTML = '';\n\t    this.root = this.storage = this._domRoot = this._layers = null;\n\t  },\n\t\n\t  /**\n\t   * Get canvas which has all thing rendered\n\t   * @param {Object} opts\n\t   * @param {string} [opts.backgroundColor]\n\t   * @param {number} [opts.pixelRatio]\n\t   */\n\t  getRenderedCanvas: function (opts) {\n\t    opts = opts || {};\n\t\n\t    if (this._singleCanvas) {\n\t      return this._layers[0].dom;\n\t    }\n\t\n\t    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n\t    imageLayer.initContext();\n\t    imageLayer.clearColor = opts.backgroundColor;\n\t    imageLayer.clear();\n\t    var displayList = this.storage.getDisplayList(true);\n\t    var scope = {};\n\t    var zlevel;\n\t    var self = this;\n\t\n\t    function findAndDrawOtherLayer(smaller, larger) {\n\t      var zlevelList = self._zlevelList;\n\t\n\t      if (smaller == null) {\n\t        smaller = -Infinity;\n\t      }\n\t\n\t      var intermediateLayer;\n\t\n\t      for (var i = 0; i < zlevelList.length; i++) {\n\t        var z = zlevelList[i];\n\t        var layer = self._layers[z];\n\t\n\t        if (!layer.__builtin__ && z > smaller && z < larger) {\n\t          intermediateLayer = layer;\n\t          break;\n\t        }\n\t      }\n\t\n\t      if (intermediateLayer && intermediateLayer.renderToCanvas) {\n\t        imageLayer.ctx.save();\n\t        intermediateLayer.renderToCanvas(imageLayer.ctx);\n\t        imageLayer.ctx.restore();\n\t      }\n\t    }\n\t\n\t    for (var i = 0; i < displayList.length; i++) {\n\t      var el = displayList[i];\n\t\n\t      if (el.zlevel !== zlevel) {\n\t        findAndDrawOtherLayer(zlevel, el.zlevel);\n\t        zlevel = el.zlevel;\n\t      }\n\t\n\t      this._doPaintEl(el, imageLayer, true, scope);\n\t    }\n\t\n\t    findAndDrawOtherLayer(zlevel, Infinity);\n\t    return imageLayer.dom;\n\t  },\n\t\n\t  /**\n\t   * 获取绘图区域宽度\n\t   */\n\t  getWidth: function () {\n\t    return this._width;\n\t  },\n\t\n\t  /**\n\t   * 获取绘图区域高度\n\t   */\n\t  getHeight: function () {\n\t    return this._height;\n\t  },\n\t  _getSize: function (whIdx) {\n\t    var opts = this._opts;\n\t    var wh = ['width', 'height'][whIdx];\n\t    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n\t    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n\t    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\t\n\t    if (opts[wh] != null && opts[wh] !== 'auto') {\n\t      return parseFloat(opts[wh]);\n\t    }\n\t\n\t    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\t\n\t    var stl = document.defaultView.getComputedStyle(root);\n\t    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n\t  },\n\t  pathToImage: function (path, dpr) {\n\t    dpr = dpr || this.dpr;\n\t    var canvas = document.createElement('canvas');\n\t    var ctx = canvas.getContext('2d');\n\t    var rect = path.getBoundingRect();\n\t    var style = path.style;\n\t    var shadowBlurSize = style.shadowBlur;\n\t    var shadowOffsetX = style.shadowOffsetX;\n\t    var shadowOffsetY = style.shadowOffsetY;\n\t    var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n\t    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n\t    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n\t    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n\t    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n\t    var width = rect.width + leftMargin + rightMargin;\n\t    var height = rect.height + topMargin + bottomMargin;\n\t    canvas.width = width * dpr;\n\t    canvas.height = height * dpr;\n\t    ctx.scale(dpr, dpr);\n\t    ctx.clearRect(0, 0, width, height);\n\t    ctx.dpr = dpr;\n\t    var pathTransform = {\n\t      position: path.position,\n\t      rotation: path.rotation,\n\t      scale: path.scale\n\t    };\n\t    path.position = [leftMargin - rect.x, topMargin - rect.y];\n\t    path.rotation = 0;\n\t    path.scale = [1, 1];\n\t    path.updateTransform();\n\t\n\t    if (path) {\n\t      path.brush(ctx);\n\t    }\n\t\n\t    var ImageShape = Image;\n\t    var imgShape = new ImageShape({\n\t      style: {\n\t        x: 0,\n\t        y: 0,\n\t        image: canvas\n\t      }\n\t    });\n\t\n\t    if (pathTransform.position != null) {\n\t      imgShape.position = path.position = pathTransform.position;\n\t    }\n\t\n\t    if (pathTransform.rotation != null) {\n\t      imgShape.rotation = path.rotation = pathTransform.rotation;\n\t    }\n\t\n\t    if (pathTransform.scale != null) {\n\t      imgShape.scale = path.scale = pathTransform.scale;\n\t    }\n\t\n\t    return imgShape;\n\t  }\n\t};\n\tvar _default = Painter;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(6);\n\t\n\tvar _config = __webpack_require__(23);\n\t\n\tvar devicePixelRatio = _config.devicePixelRatio;\n\t\n\tvar Style = __webpack_require__(28);\n\t\n\tvar Pattern = __webpack_require__(29);\n\t\n\t/**\n\t * @module zrender/Layer\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\tfunction returnFalse() {\n\t  return false;\n\t}\n\t/**\n\t * 创建dom\n\t *\n\t * @inner\n\t * @param {string} id dom id 待用\n\t * @param {Painter} painter painter instance\n\t * @param {number} number\n\t */\n\t\n\t\n\tfunction createDom(id, painter, dpr) {\n\t  var newDom = util.createCanvas();\n\t  var width = painter.getWidth();\n\t  var height = painter.getHeight();\n\t  var newDomStyle = newDom.style; // 没append呢，请原谅我这样写，清晰~\n\t\n\t  newDomStyle.position = 'absolute';\n\t  newDomStyle.left = 0;\n\t  newDomStyle.top = 0;\n\t  newDomStyle.width = width + 'px';\n\t  newDomStyle.height = height + 'px';\n\t  newDom.width = width * dpr;\n\t  newDom.height = height * dpr; // id不作为索引用，避免可能造成的重名，定义为私有属性\n\t\n\t  newDom.setAttribute('data-zr-dom-id', id);\n\t  return newDom;\n\t}\n\t/**\n\t * @alias module:zrender/Layer\n\t * @constructor\n\t * @extends module:zrender/mixin/Transformable\n\t * @param {string} id\n\t * @param {module:zrender/Painter} painter\n\t * @param {number} [dpr]\n\t */\n\t\n\t\n\tvar Layer = function (id, painter, dpr) {\n\t  var dom;\n\t  dpr = dpr || devicePixelRatio;\n\t\n\t  if (typeof id === 'string') {\n\t    dom = createDom(id, painter, dpr);\n\t  } // Not using isDom because in node it will return false\n\t  else if (util.isObject(id)) {\n\t      dom = id;\n\t      id = dom.id;\n\t    }\n\t\n\t  this.id = id;\n\t  this.dom = dom;\n\t  var domStyle = dom.style;\n\t\n\t  if (domStyle) {\n\t    // Not in node\n\t    dom.onselectstart = returnFalse; // 避免页面选中的尴尬\n\t\n\t    domStyle['-webkit-user-select'] = 'none';\n\t    domStyle['user-select'] = 'none';\n\t    domStyle['-webkit-touch-callout'] = 'none';\n\t    domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n\t    domStyle['padding'] = 0;\n\t    domStyle['margin'] = 0;\n\t    domStyle['border-width'] = 0;\n\t  }\n\t\n\t  this.domBack = null;\n\t  this.ctxBack = null;\n\t  this.painter = painter;\n\t  this.config = null; // Configs\n\t\n\t  /**\n\t   * 每次清空画布的颜色\n\t   * @type {string}\n\t   * @default 0\n\t   */\n\t\n\t  this.clearColor = 0;\n\t  /**\n\t   * 是否开启动态模糊\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t\n\t  this.motionBlur = false;\n\t  /**\n\t   * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n\t   * @type {number}\n\t   * @default 0.7\n\t   */\n\t\n\t  this.lastFrameAlpha = 0.7;\n\t  /**\n\t   * Layer dpr\n\t   * @type {number}\n\t   */\n\t\n\t  this.dpr = dpr;\n\t};\n\t\n\tLayer.prototype = {\n\t  constructor: Layer,\n\t  elCount: 0,\n\t  __dirty: true,\n\t  initContext: function () {\n\t    this.ctx = this.dom.getContext('2d');\n\t    this.ctx.__currentValues = {};\n\t    this.ctx.dpr = this.dpr;\n\t  },\n\t  createBackBuffer: function () {\n\t    var dpr = this.dpr;\n\t    this.domBack = createDom('back-' + this.id, this.painter, dpr);\n\t    this.ctxBack = this.domBack.getContext('2d');\n\t    this.ctxBack.__currentValues = {};\n\t\n\t    if (dpr != 1) {\n\t      this.ctxBack.scale(dpr, dpr);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @param  {number} width\n\t   * @param  {number} height\n\t   */\n\t  resize: function (width, height) {\n\t    var dpr = this.dpr;\n\t    var dom = this.dom;\n\t    var domStyle = dom.style;\n\t    var domBack = this.domBack;\n\t    domStyle.width = width + 'px';\n\t    domStyle.height = height + 'px';\n\t    dom.width = width * dpr;\n\t    dom.height = height * dpr;\n\t\n\t    if (domBack) {\n\t      domBack.width = width * dpr;\n\t      domBack.height = height * dpr;\n\t\n\t      if (dpr != 1) {\n\t        this.ctxBack.scale(dpr, dpr);\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 清空该层画布\n\t   * @param {boolean} clearAll Clear all with out motion blur\n\t   */\n\t  clear: function (clearAll) {\n\t    var dom = this.dom;\n\t    var ctx = this.ctx;\n\t    var width = dom.width;\n\t    var height = dom.height;\n\t    var clearColor = this.clearColor;\n\t    var haveMotionBLur = this.motionBlur && !clearAll;\n\t    var lastFrameAlpha = this.lastFrameAlpha;\n\t    var dpr = this.dpr;\n\t\n\t    if (haveMotionBLur) {\n\t      if (!this.domBack) {\n\t        this.createBackBuffer();\n\t      }\n\t\n\t      this.ctxBack.globalCompositeOperation = 'copy';\n\t      this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);\n\t    }\n\t\n\t    ctx.clearRect(0, 0, width, height);\n\t\n\t    if (clearColor) {\n\t      var clearColorGradientOrPattern; // Gradient\n\t\n\t      if (clearColor.colorStops) {\n\t        // Cache canvas gradient\n\t        clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n\t          x: 0,\n\t          y: 0,\n\t          width: width,\n\t          height: height\n\t        });\n\t        clearColor.__canvasGradient = clearColorGradientOrPattern;\n\t      } // Pattern\n\t      else if (clearColor.image) {\n\t          clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n\t        }\n\t\n\t      ctx.save();\n\t      ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n\t      ctx.fillRect(0, 0, width, height);\n\t      ctx.restore();\n\t    }\n\t\n\t    if (haveMotionBLur) {\n\t      var domBack = this.domBack;\n\t      ctx.save();\n\t      ctx.globalAlpha = lastFrameAlpha;\n\t      ctx.drawImage(domBack, 0, 0, width, height);\n\t      ctx.restore();\n\t    }\n\t  }\n\t};\n\tvar _default = Layer;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports) {\n\n\tvar STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n\t// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\t\n\tvar Style = function (opts, host) {\n\t  this.extendFrom(opts, false);\n\t  this.host = host;\n\t};\n\t\n\tfunction createLinearGradient(ctx, obj, rect) {\n\t  var x = obj.x == null ? 0 : obj.x;\n\t  var x2 = obj.x2 == null ? 1 : obj.x2;\n\t  var y = obj.y == null ? 0 : obj.y;\n\t  var y2 = obj.y2 == null ? 0 : obj.y2;\n\t\n\t  if (!obj.global) {\n\t    x = x * rect.width + rect.x;\n\t    x2 = x2 * rect.width + rect.x;\n\t    y = y * rect.height + rect.y;\n\t    y2 = y2 * rect.height + rect.y;\n\t  }\n\t\n\t  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\t  return canvasGradient;\n\t}\n\t\n\tfunction createRadialGradient(ctx, obj, rect) {\n\t  var width = rect.width;\n\t  var height = rect.height;\n\t  var min = Math.min(width, height);\n\t  var x = obj.x == null ? 0.5 : obj.x;\n\t  var y = obj.y == null ? 0.5 : obj.y;\n\t  var r = obj.r == null ? 0.5 : obj.r;\n\t\n\t  if (!obj.global) {\n\t    x = x * width + rect.x;\n\t    y = y * height + rect.y;\n\t    r = r * min;\n\t  }\n\t\n\t  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\t  return canvasGradient;\n\t}\n\t\n\tStyle.prototype = {\n\t  constructor: Style,\n\t\n\t  /**\n\t   * @type {module:zrender/graphic/Displayable}\n\t   */\n\t  host: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  fill: '#000',\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  stroke: null,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  opacity: 1,\n\t\n\t  /**\n\t   * @type {Array.<number>}\n\t   */\n\t  lineDash: null,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  lineDashOffset: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  shadowBlur: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  shadowOffsetX: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  shadowOffsetY: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  lineWidth: 1,\n\t\n\t  /**\n\t   * If stroke ignore scale\n\t   * @type {Boolean}\n\t   */\n\t  strokeNoScale: false,\n\t  // Bounding rect text configuration\n\t  // Not affected by element transform\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  text: null,\n\t\n\t  /**\n\t   * If `fontSize` or `fontFamily` exists, `font` will be reset by\n\t   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.\n\t   * So do not visit it directly in upper application (like echarts),\n\t   * but use `contain/text#makeFont` instead.\n\t   * @type {string}\n\t   */\n\t  font: null,\n\t\n\t  /**\n\t   * The same as font. Use font please.\n\t   * @deprecated\n\t   * @type {string}\n\t   */\n\t  textFont: null,\n\t\n\t  /**\n\t   * It helps merging respectively, rather than parsing an entire font string.\n\t   * @type {string}\n\t   */\n\t  fontStyle: null,\n\t\n\t  /**\n\t   * It helps merging respectively, rather than parsing an entire font string.\n\t   * @type {string}\n\t   */\n\t  fontWeight: null,\n\t\n\t  /**\n\t   * It helps merging respectively, rather than parsing an entire font string.\n\t   * Should be 12 but not '12px'.\n\t   * @type {number}\n\t   */\n\t  fontSize: null,\n\t\n\t  /**\n\t   * It helps merging respectively, rather than parsing an entire font string.\n\t   * @type {string}\n\t   */\n\t  fontFamily: null,\n\t\n\t  /**\n\t   * Reserved for special functinality, like 'hr'.\n\t   * @type {string}\n\t   */\n\t  textTag: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textFill: '#000',\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textStroke: null,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textWidth: null,\n\t\n\t  /**\n\t   * Only for textBackground.\n\t   * @type {number}\n\t   */\n\t  textHeight: null,\n\t\n\t  /**\n\t   * textStroke may be set as some color as a default\n\t   * value in upper applicaion, where the default value\n\t   * of textStrokeWidth should be 0 to make sure that\n\t   * user can choose to do not use text stroke.\n\t   * @type {number}\n\t   */\n\t  textStrokeWidth: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textLineHeight: null,\n\t\n\t  /**\n\t   * 'inside', 'left', 'right', 'top', 'bottom'\n\t   * [x, y]\n\t   * Based on x, y of rect.\n\t   * @type {string|Array.<number>}\n\t   * @default 'inside'\n\t   */\n\t  textPosition: 'inside',\n\t\n\t  /**\n\t   * If not specified, use the boundingRect of a `displayable`.\n\t   * @type {Object}\n\t   */\n\t  textRect: null,\n\t\n\t  /**\n\t   * [x, y]\n\t   * @type {Array.<number>}\n\t   */\n\t  textOffset: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textAlign: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textVerticalAlign: null,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textDistance: 5,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textShadowColor: 'transparent',\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textShadowBlur: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textShadowOffsetX: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textShadowOffsetY: 0,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textBoxShadowColor: 'transparent',\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textBoxShadowBlur: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textBoxShadowOffsetX: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textBoxShadowOffsetY: 0,\n\t\n\t  /**\n\t   * Whether transform text.\n\t   * Only useful in Path and Image element\n\t   * @type {boolean}\n\t   */\n\t  transformText: false,\n\t\n\t  /**\n\t   * Text rotate around position of Path or Image\n\t   * Only useful in Path and Image element and transformText is false.\n\t   */\n\t  textRotation: 0,\n\t\n\t  /**\n\t   * Text origin of text rotation, like [10, 40].\n\t   * Based on x, y of rect.\n\t   * Useful in label rotation of circular symbol.\n\t   * By default, this origin is textPosition.\n\t   * Can be 'center'.\n\t   * @type {string|Array.<number>}\n\t   */\n\t  textOrigin: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textBackgroundColor: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textBorderColor: null,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textBorderWidth: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textBorderRadius: 0,\n\t\n\t  /**\n\t   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`\n\t   * @type {number|Array.<number>}\n\t   */\n\t  textPadding: null,\n\t\n\t  /**\n\t   * Text styles for rich text.\n\t   * @type {Object}\n\t   */\n\t  rich: null,\n\t\n\t  /**\n\t   * {outerWidth, outerHeight, ellipsis, placeholder}\n\t   * @type {Object}\n\t   */\n\t  truncate: null,\n\t\n\t  /**\n\t   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n\t   * @type {string}\n\t   */\n\t  blend: null,\n\t\n\t  /**\n\t   * @param {CanvasRenderingContext2D} ctx\n\t   */\n\t  bind: function (ctx, el, prevEl) {\n\t    var style = this;\n\t    var prevStyle = prevEl && prevEl.style;\n\t    var firstDraw = !prevStyle;\n\t\n\t    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t      var prop = STYLE_COMMON_PROPS[i];\n\t      var styleName = prop[0];\n\t\n\t      if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n\t        // FIXME Invalid property value will cause style leak from previous element.\n\t        ctx[styleName] = style[styleName] || prop[1];\n\t      }\n\t    }\n\t\n\t    if (firstDraw || style.fill !== prevStyle.fill) {\n\t      ctx.fillStyle = style.fill;\n\t    }\n\t\n\t    if (firstDraw || style.stroke !== prevStyle.stroke) {\n\t      ctx.strokeStyle = style.stroke;\n\t    }\n\t\n\t    if (firstDraw || style.opacity !== prevStyle.opacity) {\n\t      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n\t    }\n\t\n\t    if (firstDraw || style.blend !== prevStyle.blend) {\n\t      ctx.globalCompositeOperation = style.blend || 'source-over';\n\t    }\n\t\n\t    if (this.hasStroke()) {\n\t      var lineWidth = style.lineWidth;\n\t      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);\n\t    }\n\t  },\n\t  hasFill: function () {\n\t    var fill = this.fill;\n\t    return fill != null && fill !== 'none';\n\t  },\n\t  hasStroke: function () {\n\t    var stroke = this.stroke;\n\t    return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n\t  },\n\t\n\t  /**\n\t   * Extend from other style\n\t   * @param {zrender/graphic/Style} otherStyle\n\t   * @param {boolean} overwrite true: overwrirte any way.\n\t   *                            false: overwrite only when !target.hasOwnProperty\n\t   *                            others: overwrite when property is not null/undefined.\n\t   */\n\t  extendFrom: function (otherStyle, overwrite) {\n\t    if (otherStyle) {\n\t      for (var name in otherStyle) {\n\t        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {\n\t          this[name] = otherStyle[name];\n\t        }\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Batch setting style with a given object\n\t   * @param {Object|string} obj\n\t   * @param {*} [obj]\n\t   */\n\t  set: function (obj, value) {\n\t    if (typeof obj === 'string') {\n\t      this[obj] = value;\n\t    } else {\n\t      this.extendFrom(obj, true);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Clone\n\t   * @return {zrender/graphic/Style} [description]\n\t   */\n\t  clone: function () {\n\t    var newStyle = new this.constructor();\n\t    newStyle.extendFrom(this, true);\n\t    return newStyle;\n\t  },\n\t  getGradient: function (ctx, obj, rect) {\n\t    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n\t    var canvasGradient = method(ctx, obj, rect);\n\t    var colorStops = obj.colorStops;\n\t\n\t    for (var i = 0; i < colorStops.length; i++) {\n\t      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n\t    }\n\t\n\t    return canvasGradient;\n\t  }\n\t};\n\tvar styleProto = Style.prototype;\n\t\n\tfor (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t  var prop = STYLE_COMMON_PROPS[i];\n\t\n\t  if (!(prop[0] in styleProto)) {\n\t    styleProto[prop[0]] = prop[1];\n\t  }\n\t} // Provide for others\n\t\n\t\n\tStyle.getGradient = styleProto.getGradient;\n\tvar _default = Style;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports) {\n\n\tvar Pattern = function (image, repeat) {\n\t  // Should do nothing more in this constructor. Because gradient can be\n\t  // declard by `color: {image: ...}`, where this constructor will not be called.\n\t  this.image = image;\n\t  this.repeat = repeat; // Can be cloned\n\t\n\t  this.type = 'pattern';\n\t};\n\t\n\tPattern.prototype.getCanvasPattern = function (ctx) {\n\t  return ctx.createPattern(this.image, this.repeat || 'repeat');\n\t};\n\t\n\tvar _default = Pattern;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports) {\n\n\tvar _default = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809\n\twindow.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {\n\t  setTimeout(func, 16);\n\t};\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Displayable = __webpack_require__(32);\n\t\n\tvar BoundingRect = __webpack_require__(24);\n\t\n\tvar zrUtil = __webpack_require__(6);\n\t\n\tvar imageHelper = __webpack_require__(36);\n\t\n\t/**\n\t * @alias zrender/graphic/Image\n\t * @extends module:zrender/graphic/Displayable\n\t * @constructor\n\t * @param {Object} opts\n\t */\n\tfunction ZImage(opts) {\n\t  Displayable.call(this, opts);\n\t}\n\t\n\tZImage.prototype = {\n\t  constructor: ZImage,\n\t  type: 'image',\n\t  brush: function (ctx, prevEl) {\n\t    var style = this.style;\n\t    var src = style.image; // Must bind each time\n\t\n\t    style.bind(ctx, this, prevEl);\n\t    var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);\n\t\n\t    if (!image || !imageHelper.isImageReady(image)) {\n\t      return;\n\t    } // 图片已经加载完成\n\t    // if (image.nodeName.toUpperCase() == 'IMG') {\n\t    //     if (!image.complete) {\n\t    //         return;\n\t    //     }\n\t    // }\n\t    // Else is canvas\n\t\n\t\n\t    var x = style.x || 0;\n\t    var y = style.y || 0;\n\t    var width = style.width;\n\t    var height = style.height;\n\t    var aspect = image.width / image.height;\n\t\n\t    if (width == null && height != null) {\n\t      // Keep image/height ratio\n\t      width = height * aspect;\n\t    } else if (height == null && width != null) {\n\t      height = width / aspect;\n\t    } else if (width == null && height == null) {\n\t      width = image.width;\n\t      height = image.height;\n\t    } // 设置transform\n\t\n\t\n\t    this.setTransform(ctx);\n\t\n\t    if (style.sWidth && style.sHeight) {\n\t      var sx = style.sx || 0;\n\t      var sy = style.sy || 0;\n\t      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n\t    } else if (style.sx && style.sy) {\n\t      var sx = style.sx;\n\t      var sy = style.sy;\n\t      var sWidth = width - sx;\n\t      var sHeight = height - sy;\n\t      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n\t    } else {\n\t      ctx.drawImage(image, x, y, width, height);\n\t    }\n\t\n\t    this.restoreTransform(ctx); // Draw rect text\n\t\n\t    if (style.text != null) {\n\t      this.drawRectText(ctx, this.getBoundingRect());\n\t    }\n\t  },\n\t  getBoundingRect: function () {\n\t    var style = this.style;\n\t\n\t    if (!this._rect) {\n\t      this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);\n\t    }\n\t\n\t    return this._rect;\n\t  }\n\t};\n\tzrUtil.inherits(ZImage, Displayable);\n\tvar _default = ZImage;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrUtil = __webpack_require__(6);\n\t\n\tvar Style = __webpack_require__(28);\n\t\n\tvar Element = __webpack_require__(13);\n\t\n\tvar RectText = __webpack_require__(33);\n\t\n\t/**\n\t * 可绘制的图形基类\n\t * Base class of all displayable graphic objects\n\t * @module zrender/graphic/Displayable\n\t */\n\t\n\t/**\n\t * @alias module:zrender/graphic/Displayable\n\t * @extends module:zrender/Element\n\t * @extends module:zrender/graphic/mixin/RectText\n\t */\n\tfunction Displayable(opts) {\n\t  opts = opts || {};\n\t  Element.call(this, opts); // Extend properties\n\t\n\t  for (var name in opts) {\n\t    if (opts.hasOwnProperty(name) && name !== 'style') {\n\t      this[name] = opts[name];\n\t    }\n\t  }\n\t  /**\n\t   * @type {module:zrender/graphic/Style}\n\t   */\n\t\n\t\n\t  this.style = new Style(opts.style, this);\n\t  this._rect = null; // Shapes for cascade clipping.\n\t\n\t  this.__clipPaths = []; // FIXME Stateful must be mixined after style is setted\n\t  // Stateful.call(this, opts);\n\t}\n\t\n\tDisplayable.prototype = {\n\t  constructor: Displayable,\n\t  type: 'displayable',\n\t\n\t  /**\n\t   * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制\n\t   * Dirty flag. From which painter will determine if this displayable object needs brush\n\t   * @name module:zrender/graphic/Displayable#__dirty\n\t   * @type {boolean}\n\t   */\n\t  __dirty: true,\n\t\n\t  /**\n\t   * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\n\t   * If ignore drawing of the displayable object. Mouse event will still be triggered\n\t   * @name module:/zrender/graphic/Displayable#invisible\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  invisible: false,\n\t\n\t  /**\n\t   * @name module:/zrender/graphic/Displayable#z\n\t   * @type {number}\n\t   * @default 0\n\t   */\n\t  z: 0,\n\t\n\t  /**\n\t   * @name module:/zrender/graphic/Displayable#z\n\t   * @type {number}\n\t   * @default 0\n\t   */\n\t  z2: 0,\n\t\n\t  /**\n\t   * z层level，决定绘画在哪层canvas中\n\t   * @name module:/zrender/graphic/Displayable#zlevel\n\t   * @type {number}\n\t   * @default 0\n\t   */\n\t  zlevel: 0,\n\t\n\t  /**\n\t   * 是否可拖拽\n\t   * @name module:/zrender/graphic/Displayable#draggable\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  draggable: false,\n\t\n\t  /**\n\t   * 是否正在拖拽\n\t   * @name module:/zrender/graphic/Displayable#draggable\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  dragging: false,\n\t\n\t  /**\n\t   * 是否相应鼠标事件\n\t   * @name module:/zrender/graphic/Displayable#silent\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  silent: false,\n\t\n\t  /**\n\t   * If enable culling\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  culling: false,\n\t\n\t  /**\n\t   * Mouse cursor when hovered\n\t   * @name module:/zrender/graphic/Displayable#cursor\n\t   * @type {string}\n\t   */\n\t  cursor: 'pointer',\n\t\n\t  /**\n\t   * If hover area is bounding rect\n\t   * @name module:/zrender/graphic/Displayable#rectHover\n\t   * @type {string}\n\t   */\n\t  rectHover: false,\n\t\n\t  /**\n\t   * Render the element progressively when the value >= 0,\n\t   * usefull for large data.\n\t   * @type {number}\n\t   */\n\t  progressive: -1,\n\t  beforeBrush: function (ctx) {},\n\t  afterBrush: function (ctx) {},\n\t\n\t  /**\n\t   * 图形绘制方法\n\t   * @param {CanvasRenderingContext2D} ctx\n\t   */\n\t  // Interface\n\t  brush: function (ctx, prevEl) {},\n\t\n\t  /**\n\t   * 获取最小包围盒\n\t   * @return {module:zrender/core/BoundingRect}\n\t   */\n\t  // Interface\n\t  getBoundingRect: function () {},\n\t\n\t  /**\n\t   * 判断坐标 x, y 是否在图形上\n\t   * If displayable element contain coord x, y\n\t   * @param  {number} x\n\t   * @param  {number} y\n\t   * @return {boolean}\n\t   */\n\t  contain: function (x, y) {\n\t    return this.rectContain(x, y);\n\t  },\n\t\n\t  /**\n\t   * @param  {Function} cb\n\t   * @param  {}   context\n\t   */\n\t  traverse: function (cb, context) {\n\t    cb.call(context, this);\n\t  },\n\t\n\t  /**\n\t   * 判断坐标 x, y 是否在图形的包围盒上\n\t   * If bounding rect of element contain coord x, y\n\t   * @param  {number} x\n\t   * @param  {number} y\n\t   * @return {boolean}\n\t   */\n\t  rectContain: function (x, y) {\n\t    var coord = this.transformCoordToLocal(x, y);\n\t    var rect = this.getBoundingRect();\n\t    return rect.contain(coord[0], coord[1]);\n\t  },\n\t\n\t  /**\n\t   * 标记图形元素为脏，并且在下一帧重绘\n\t   * Mark displayable element dirty and refresh next frame\n\t   */\n\t  dirty: function () {\n\t    this.__dirty = true;\n\t    this._rect = null;\n\t    this.__zr && this.__zr.refresh();\n\t  },\n\t\n\t  /**\n\t   * 图形是否会触发事件\n\t   * If displayable object binded any event\n\t   * @return {boolean}\n\t   */\n\t  // TODO, 通过 bind 绑定的事件\n\t  // isSilent: function () {\n\t  //     return !(\n\t  //         this.hoverable || this.draggable\n\t  //         || this.onmousemove || this.onmouseover || this.onmouseout\n\t  //         || this.onmousedown || this.onmouseup || this.onclick\n\t  //         || this.ondragenter || this.ondragover || this.ondragleave\n\t  //         || this.ondrop\n\t  //     );\n\t  // },\n\t\n\t  /**\n\t   * Alias for animate('style')\n\t   * @param {boolean} loop\n\t   */\n\t  animateStyle: function (loop) {\n\t    return this.animate('style', loop);\n\t  },\n\t  attrKV: function (key, value) {\n\t    if (key !== 'style') {\n\t      Element.prototype.attrKV.call(this, key, value);\n\t    } else {\n\t      this.style.set(value);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @param {Object|string} key\n\t   * @param {*} value\n\t   */\n\t  setStyle: function (key, value) {\n\t    this.style.set(key, value);\n\t    this.dirty(false);\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * Use given style object\n\t   * @param  {Object} obj\n\t   */\n\t  useStyle: function (obj) {\n\t    this.style = new Style(obj, this);\n\t    this.dirty(false);\n\t    return this;\n\t  }\n\t};\n\tzrUtil.inherits(Displayable, Element);\n\tzrUtil.mixin(Displayable, RectText); // zrUtil.mixin(Displayable, Stateful);\n\t\n\tvar _default = Displayable;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar textHelper = __webpack_require__(34);\n\t\n\tvar BoundingRect = __webpack_require__(24);\n\t\n\t/**\n\t * Mixin for drawing text in a element bounding rect\n\t * @module zrender/mixin/RectText\n\t */\n\tvar tmpRect = new BoundingRect();\n\t\n\tvar RectText = function () {};\n\t\n\tRectText.prototype = {\n\t  constructor: RectText,\n\t\n\t  /**\n\t   * Draw text in a rect with specified position.\n\t   * @param  {CanvasRenderingContext2D} ctx\n\t   * @param  {Object} rect Displayable rect\n\t   */\n\t  drawRectText: function (ctx, rect) {\n\t    var style = this.style;\n\t    rect = style.textRect || rect; // Optimize, avoid normalize every time.\n\t\n\t    this.__dirty && textHelper.normalizeTextStyle(style, true);\n\t    var text = style.text; // Convert to string\n\t\n\t    text != null && (text += '');\n\t\n\t    if (!textHelper.needDrawText(text, style)) {\n\t      return;\n\t    } // FIXME\n\t\n\t\n\t    ctx.save(); // Transform rect to view space\n\t\n\t    var transform = this.transform;\n\t\n\t    if (!style.transformText) {\n\t      if (transform) {\n\t        tmpRect.copy(rect);\n\t        tmpRect.applyTransform(transform);\n\t        rect = tmpRect;\n\t      }\n\t    } else {\n\t      this.setTransform(ctx);\n\t    } // transformText and textRotation can not be used at the same time.\n\t\n\t\n\t    textHelper.renderText(this, ctx, text, style, rect);\n\t    ctx.restore();\n\t  }\n\t};\n\tvar _default = RectText;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _util = __webpack_require__(6);\n\t\n\tvar retrieve2 = _util.retrieve2;\n\tvar retrieve3 = _util.retrieve3;\n\tvar each = _util.each;\n\tvar normalizeCssArray = _util.normalizeCssArray;\n\tvar isString = _util.isString;\n\tvar isObject = _util.isObject;\n\t\n\tvar textContain = __webpack_require__(35);\n\t\n\tvar roundRectHelper = __webpack_require__(37);\n\t\n\tvar imageHelper = __webpack_require__(36);\n\t\n\t// TODO: Have not support 'start', 'end' yet.\n\tvar VALID_TEXT_ALIGN = {\n\t  left: 1,\n\t  right: 1,\n\t  center: 1\n\t};\n\tvar VALID_TEXT_VERTICAL_ALIGN = {\n\t  top: 1,\n\t  bottom: 1,\n\t  middle: 1\n\t};\n\t/**\n\t * @param {module:zrender/graphic/Style} style\n\t * @return {module:zrender/graphic/Style} The input style.\n\t */\n\t\n\tfunction normalizeTextStyle(style) {\n\t  normalizeStyle(style);\n\t  each(style.rich, normalizeStyle);\n\t  return style;\n\t}\n\t\n\tfunction normalizeStyle(style) {\n\t  if (style) {\n\t    style.font = textContain.makeFont(style);\n\t    var textAlign = style.textAlign;\n\t    textAlign === 'middle' && (textAlign = 'center');\n\t    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.\n\t\n\t    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n\t    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n\t    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';\n\t    var textPadding = style.textPadding;\n\t\n\t    if (textPadding) {\n\t      style.textPadding = normalizeCssArray(style.textPadding);\n\t    }\n\t  }\n\t}\n\t/**\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {string} text\n\t * @param {module:zrender/graphic/Style} style\n\t * @param {Object|boolean} [rect] {x, y, width, height}\n\t *                  If set false, rect text is not used.\n\t */\n\t\n\t\n\tfunction renderText(hostEl, ctx, text, style, rect) {\n\t  style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);\n\t}\n\t\n\tfunction renderPlainText(hostEl, ctx, text, style, rect) {\n\t  var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);\n\t  var textPadding = style.textPadding;\n\t  var contentBlock = hostEl.__textCotentBlock;\n\t\n\t  if (!contentBlock || hostEl.__dirty) {\n\t    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, font, textPadding, style.truncate);\n\t  }\n\t\n\t  var outerHeight = contentBlock.outerHeight;\n\t  var textLines = contentBlock.lines;\n\t  var lineHeight = contentBlock.lineHeight;\n\t  var boxPos = getBoxPosition(outerHeight, style, rect);\n\t  var baseX = boxPos.baseX;\n\t  var baseY = boxPos.baseY;\n\t  var textAlign = boxPos.textAlign;\n\t  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\t\n\t  applyTextRotation(ctx, style, rect, baseX, baseY);\n\t  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n\t  var textX = baseX;\n\t  var textY = boxY;\n\t  var needDrawBg = needDrawBackground(style);\n\t\n\t  if (needDrawBg || textPadding) {\n\t    // Consider performance, do not call getTextWidth util necessary.\n\t    var textWidth = textContain.getWidth(text, font);\n\t    var outerWidth = textWidth;\n\t    textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n\t    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n\t    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\t\n\t    if (textPadding) {\n\t      textX = getTextXForPadding(baseX, textAlign, textPadding);\n\t      textY += textPadding[0];\n\t    }\n\t  }\n\t\n\t  setCtx(ctx, 'textAlign', textAlign || 'left'); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n\t  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\t\n\t  setCtx(ctx, 'textBaseline', 'middle'); // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\t\n\t  setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);\n\t  setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');\n\t  setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);\n\t  setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0); // `textBaseline` is set as 'middle'.\n\t\n\t  textY += lineHeight / 2;\n\t  var textStrokeWidth = style.textStrokeWidth;\n\t  var textStroke = getStroke(style.textStroke, textStrokeWidth);\n\t  var textFill = getFill(style.textFill);\n\t\n\t  if (textStroke) {\n\t    setCtx(ctx, 'lineWidth', textStrokeWidth);\n\t    setCtx(ctx, 'strokeStyle', textStroke);\n\t  }\n\t\n\t  if (textFill) {\n\t    setCtx(ctx, 'fillStyle', textFill);\n\t  }\n\t\n\t  for (var i = 0; i < textLines.length; i++) {\n\t    // Fill after stroke so the outline will not cover the main part.\n\t    textStroke && ctx.strokeText(textLines[i], textX, textY);\n\t    textFill && ctx.fillText(textLines[i], textX, textY);\n\t    textY += lineHeight;\n\t  }\n\t}\n\t\n\tfunction renderRichText(hostEl, ctx, text, style, rect) {\n\t  var contentBlock = hostEl.__textCotentBlock;\n\t\n\t  if (!contentBlock || hostEl.__dirty) {\n\t    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n\t  }\n\t\n\t  drawRichText(hostEl, ctx, contentBlock, style, rect);\n\t}\n\t\n\tfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n\t  var contentWidth = contentBlock.width;\n\t  var outerWidth = contentBlock.outerWidth;\n\t  var outerHeight = contentBlock.outerHeight;\n\t  var textPadding = style.textPadding;\n\t  var boxPos = getBoxPosition(outerHeight, style, rect);\n\t  var baseX = boxPos.baseX;\n\t  var baseY = boxPos.baseY;\n\t  var textAlign = boxPos.textAlign;\n\t  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\t\n\t  applyTextRotation(ctx, style, rect, baseX, baseY);\n\t  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n\t  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n\t  var xLeft = boxX;\n\t  var lineTop = boxY;\n\t\n\t  if (textPadding) {\n\t    xLeft += textPadding[3];\n\t    lineTop += textPadding[0];\n\t  }\n\t\n\t  var xRight = xLeft + contentWidth;\n\t  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\t\n\t  for (var i = 0; i < contentBlock.lines.length; i++) {\n\t    var line = contentBlock.lines[i];\n\t    var tokens = line.tokens;\n\t    var tokenCount = tokens.length;\n\t    var lineHeight = line.lineHeight;\n\t    var usedWidth = line.width;\n\t    var leftIndex = 0;\n\t    var lineXLeft = xLeft;\n\t    var lineXRight = xRight;\n\t    var rightIndex = tokenCount - 1;\n\t    var token;\n\t\n\t    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {\n\t      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n\t      usedWidth -= token.width;\n\t      lineXLeft += token.width;\n\t      leftIndex++;\n\t    }\n\t\n\t    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {\n\t      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n\t      usedWidth -= token.width;\n\t      lineXRight -= token.width;\n\t      rightIndex--;\n\t    } // The other tokens are placed as textAlign 'center' if there is enough space.\n\t\n\t\n\t    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n\t\n\t    while (leftIndex <= rightIndex) {\n\t      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.\n\t\n\t      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n\t      lineXLeft += token.width;\n\t      leftIndex++;\n\t    }\n\t\n\t    lineTop += lineHeight;\n\t  }\n\t}\n\t\n\tfunction applyTextRotation(ctx, style, rect, x, y) {\n\t  // textRotation only apply in RectText.\n\t  if (rect && style.textRotation) {\n\t    var origin = style.textOrigin;\n\t\n\t    if (origin === 'center') {\n\t      x = rect.width / 2 + rect.x;\n\t      y = rect.height / 2 + rect.y;\n\t    } else if (origin) {\n\t      x = origin[0] + rect.x;\n\t      y = origin[1] + rect.y;\n\t    }\n\t\n\t    ctx.translate(x, y); // Positive: anticlockwise\n\t\n\t    ctx.rotate(-style.textRotation);\n\t    ctx.translate(-x, -y);\n\t  }\n\t}\n\t\n\tfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n\t  var tokenStyle = style.rich[token.styleName] || {}; // 'ctx.textBaseline' is always set as 'middle', for sake of\n\t  // the bias of \"Microsoft YaHei\".\n\t\n\t  var textVerticalAlign = token.textVerticalAlign;\n\t  var y = lineTop + lineHeight / 2;\n\t\n\t  if (textVerticalAlign === 'top') {\n\t    y = lineTop + token.height / 2;\n\t  } else if (textVerticalAlign === 'bottom') {\n\t    y = lineTop + lineHeight - token.height / 2;\n\t  }\n\t\n\t  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);\n\t  var textPadding = token.textPadding;\n\t\n\t  if (textPadding) {\n\t    x = getTextXForPadding(x, textAlign, textPadding);\n\t    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n\t  }\n\t\n\t  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n\t  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n\t  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n\t  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n\t  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n\t  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\t\n\t  setCtx(ctx, 'textBaseline', 'middle');\n\t  setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);\n\t  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n\t  var textFill = getFill(tokenStyle.textFill || style.textFill);\n\t  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.\n\t\n\t  if (textStroke) {\n\t    setCtx(ctx, 'lineWidth', textStrokeWidth);\n\t    setCtx(ctx, 'strokeStyle', textStroke);\n\t    ctx.strokeText(token.text, x, y);\n\t  }\n\t\n\t  if (textFill) {\n\t    setCtx(ctx, 'fillStyle', textFill);\n\t    ctx.fillText(token.text, x, y);\n\t  }\n\t}\n\t\n\tfunction needDrawBackground(style) {\n\t  return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;\n\t} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}\n\t// shape: {x, y, width, height}\n\t\n\t\n\tfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n\t  var textBackgroundColor = style.textBackgroundColor;\n\t  var textBorderWidth = style.textBorderWidth;\n\t  var textBorderColor = style.textBorderColor;\n\t  var isPlainBg = isString(textBackgroundColor);\n\t  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n\t  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n\t  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n\t  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\t\n\t  if (isPlainBg || textBorderWidth && textBorderColor) {\n\t    ctx.beginPath();\n\t    var textBorderRadius = style.textBorderRadius;\n\t\n\t    if (!textBorderRadius) {\n\t      ctx.rect(x, y, width, height);\n\t    } else {\n\t      roundRectHelper.buildPath(ctx, {\n\t        x: x,\n\t        y: y,\n\t        width: width,\n\t        height: height,\n\t        r: textBorderRadius\n\t      });\n\t    }\n\t\n\t    ctx.closePath();\n\t  }\n\t\n\t  if (isPlainBg) {\n\t    setCtx(ctx, 'fillStyle', textBackgroundColor);\n\t    ctx.fill();\n\t  } else if (isObject(textBackgroundColor)) {\n\t    var image = textBackgroundColor.image;\n\t    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);\n\t\n\t    if (image && imageHelper.isImageReady(image)) {\n\t      ctx.drawImage(image, x, y, width, height);\n\t    }\n\t  }\n\t\n\t  if (textBorderWidth && textBorderColor) {\n\t    setCtx(ctx, 'lineWidth', textBorderWidth);\n\t    setCtx(ctx, 'strokeStyle', textBorderColor);\n\t    ctx.stroke();\n\t  }\n\t}\n\t\n\tfunction onBgImageLoaded(image, textBackgroundColor) {\n\t  // Replace image, so that `contain/text.js#parseRichText`\n\t  // will get correct result in next tick.\n\t  textBackgroundColor.image = image;\n\t}\n\t\n\tfunction getBoxPosition(blockHeiht, style, rect) {\n\t  var baseX = style.x || 0;\n\t  var baseY = style.y || 0;\n\t  var textAlign = style.textAlign;\n\t  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord\n\t\n\t  if (rect) {\n\t    var textPosition = style.textPosition;\n\t\n\t    if (textPosition instanceof Array) {\n\t      // Percent\n\t      baseX = rect.x + parsePercent(textPosition[0], rect.width);\n\t      baseY = rect.y + parsePercent(textPosition[1], rect.height);\n\t    } else {\n\t      var res = textContain.adjustTextPositionOnRect(textPosition, rect, style.textDistance);\n\t      baseX = res.x;\n\t      baseY = res.y; // Default align and baseline when has textPosition\n\t\n\t      textAlign = textAlign || res.textAlign;\n\t      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n\t    } // textOffset is only support in RectText, otherwise\n\t    // we have to adjust boundingRect for textOffset.\n\t\n\t\n\t    var textOffset = style.textOffset;\n\t\n\t    if (textOffset) {\n\t      baseX += textOffset[0];\n\t      baseY += textOffset[1];\n\t    }\n\t  }\n\t\n\t  return {\n\t    baseX: baseX,\n\t    baseY: baseY,\n\t    textAlign: textAlign,\n\t    textVerticalAlign: textVerticalAlign\n\t  };\n\t}\n\t\n\tfunction setCtx(ctx, prop, value) {\n\t  // FIXME ??? performance try\n\t  // if (ctx.__currentValues[prop] !== value) {\n\t  // ctx[prop] = ctx.__currentValues[prop] = value;\n\t  ctx[prop] = value; // }\n\t\n\t  return ctx[prop];\n\t}\n\t/**\n\t * @param {string} [stroke] If specified, do not check style.textStroke.\n\t * @param {string} [lineWidth] If specified, do not check style.textStroke.\n\t * @param {number} style\n\t */\n\t\n\t\n\tfunction getStroke(stroke, lineWidth) {\n\t  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?\n\t  : stroke.image || stroke.colorStops ? '#000' : stroke;\n\t}\n\t\n\tfunction getFill(fill) {\n\t  return fill == null || fill === 'none' ? null // TODO pattern and gradient?\n\t  : fill.image || fill.colorStops ? '#000' : fill;\n\t}\n\t\n\tfunction parsePercent(value, maxValue) {\n\t  if (typeof value === 'string') {\n\t    if (value.lastIndexOf('%') >= 0) {\n\t      return parseFloat(value) / 100 * maxValue;\n\t    }\n\t\n\t    return parseFloat(value);\n\t  }\n\t\n\t  return value;\n\t}\n\t\n\tfunction getTextXForPadding(x, textAlign, textPadding) {\n\t  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n\t}\n\t/**\n\t * @param {string} text\n\t * @param {module:zrender/Style} style\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction needDrawText(text, style) {\n\t  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);\n\t}\n\t\n\texports.normalizeTextStyle = normalizeTextStyle;\n\texports.renderText = renderText;\n\texports.getStroke = getStroke;\n\texports.getFill = getFill;\n\texports.needDrawText = needDrawText;\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar BoundingRect = __webpack_require__(24);\n\t\n\tvar imageHelper = __webpack_require__(36);\n\t\n\tvar _util = __webpack_require__(6);\n\t\n\tvar getContext = _util.getContext;\n\tvar extend = _util.extend;\n\tvar retrieve2 = _util.retrieve2;\n\tvar retrieve3 = _util.retrieve3;\n\tvar textWidthCache = {};\n\tvar textWidthCacheCounter = 0;\n\tvar TEXT_CACHE_MAX = 5000;\n\tvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\n\tvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\t\n\tvar methods = {};\n\t\n\tfunction $override(name, fn) {\n\t  methods[name] = fn;\n\t}\n\t/**\n\t * @public\n\t * @param {string} text\n\t * @param {string} font\n\t * @return {number} width\n\t */\n\t\n\t\n\tfunction getWidth(text, font) {\n\t  font = font || DEFAULT_FONT;\n\t  var key = text + ':' + font;\n\t\n\t  if (textWidthCache[key]) {\n\t    return textWidthCache[key];\n\t  }\n\t\n\t  var textLines = (text + '').split('\\n');\n\t  var width = 0;\n\t\n\t  for (var i = 0, l = textLines.length; i < l; i++) {\n\t    // textContain.measureText may be overrided in SVG or VML\n\t    width = Math.max(measureText(textLines[i], font).width, width);\n\t  }\n\t\n\t  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n\t    textWidthCacheCounter = 0;\n\t    textWidthCache = {};\n\t  }\n\t\n\t  textWidthCacheCounter++;\n\t  textWidthCache[key] = width;\n\t  return width;\n\t}\n\t/**\n\t * @public\n\t * @param {string} text\n\t * @param {string} font\n\t * @param {string} [textAlign='left']\n\t * @param {string} [textVerticalAlign='top']\n\t * @param {Array.<number>} [textPadding]\n\t * @param {Object} [rich]\n\t * @param {Object} [truncate]\n\t * @return {Object} {x, y, width, height, lineHeight}\n\t */\n\t\n\t\n\tfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n\t  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);\n\t}\n\t\n\tfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {\n\t  var contentBlock = parsePlainText(text, font, textPadding, truncate);\n\t  var outerWidth = getWidth(text, font);\n\t\n\t  if (textPadding) {\n\t    outerWidth += textPadding[1] + textPadding[3];\n\t  }\n\t\n\t  var outerHeight = contentBlock.outerHeight;\n\t  var x = adjustTextX(0, outerWidth, textAlign);\n\t  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n\t  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n\t  rect.lineHeight = contentBlock.lineHeight;\n\t  return rect;\n\t}\n\t\n\tfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n\t  var contentBlock = parseRichText(text, {\n\t    rich: rich,\n\t    truncate: truncate,\n\t    font: font,\n\t    textAlign: textAlign,\n\t    textPadding: textPadding\n\t  });\n\t  var outerWidth = contentBlock.outerWidth;\n\t  var outerHeight = contentBlock.outerHeight;\n\t  var x = adjustTextX(0, outerWidth, textAlign);\n\t  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n\t  return new BoundingRect(x, y, outerWidth, outerHeight);\n\t}\n\t/**\n\t * @public\n\t * @param {number} x\n\t * @param {number} width\n\t * @param {string} [textAlign='left']\n\t * @return {number} Adjusted x.\n\t */\n\t\n\t\n\tfunction adjustTextX(x, width, textAlign) {\n\t  // FIXME Right to left language\n\t  if (textAlign === 'right') {\n\t    x -= width;\n\t  } else if (textAlign === 'center') {\n\t    x -= width / 2;\n\t  }\n\t\n\t  return x;\n\t}\n\t/**\n\t * @public\n\t * @param {number} y\n\t * @param {number} height\n\t * @param {string} [textVerticalAlign='top']\n\t * @return {number} Adjusted y.\n\t */\n\t\n\t\n\tfunction adjustTextY(y, height, textVerticalAlign) {\n\t  if (textVerticalAlign === 'middle') {\n\t    y -= height / 2;\n\t  } else if (textVerticalAlign === 'bottom') {\n\t    y -= height;\n\t  }\n\t\n\t  return y;\n\t}\n\t/**\n\t * @public\n\t * @param {stirng} textPosition\n\t * @param {Object} rect {x, y, width, height}\n\t * @param {number} distance\n\t * @return {Object} {x, y, textAlign, textVerticalAlign}\n\t */\n\t\n\t\n\tfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n\t  var x = rect.x;\n\t  var y = rect.y;\n\t  var height = rect.height;\n\t  var width = rect.width;\n\t  var halfHeight = height / 2;\n\t  var textAlign = 'left';\n\t  var textVerticalAlign = 'top';\n\t\n\t  switch (textPosition) {\n\t    case 'left':\n\t      x -= distance;\n\t      y += halfHeight;\n\t      textAlign = 'right';\n\t      textVerticalAlign = 'middle';\n\t      break;\n\t\n\t    case 'right':\n\t      x += distance + width;\n\t      y += halfHeight;\n\t      textVerticalAlign = 'middle';\n\t      break;\n\t\n\t    case 'top':\n\t      x += width / 2;\n\t      y -= distance;\n\t      textAlign = 'center';\n\t      textVerticalAlign = 'bottom';\n\t      break;\n\t\n\t    case 'bottom':\n\t      x += width / 2;\n\t      y += height + distance;\n\t      textAlign = 'center';\n\t      break;\n\t\n\t    case 'inside':\n\t      x += width / 2;\n\t      y += halfHeight;\n\t      textAlign = 'center';\n\t      textVerticalAlign = 'middle';\n\t      break;\n\t\n\t    case 'insideLeft':\n\t      x += distance;\n\t      y += halfHeight;\n\t      textVerticalAlign = 'middle';\n\t      break;\n\t\n\t    case 'insideRight':\n\t      x += width - distance;\n\t      y += halfHeight;\n\t      textAlign = 'right';\n\t      textVerticalAlign = 'middle';\n\t      break;\n\t\n\t    case 'insideTop':\n\t      x += width / 2;\n\t      y += distance;\n\t      textAlign = 'center';\n\t      break;\n\t\n\t    case 'insideBottom':\n\t      x += width / 2;\n\t      y += height - distance;\n\t      textAlign = 'center';\n\t      textVerticalAlign = 'bottom';\n\t      break;\n\t\n\t    case 'insideTopLeft':\n\t      x += distance;\n\t      y += distance;\n\t      break;\n\t\n\t    case 'insideTopRight':\n\t      x += width - distance;\n\t      y += distance;\n\t      textAlign = 'right';\n\t      break;\n\t\n\t    case 'insideBottomLeft':\n\t      x += distance;\n\t      y += height - distance;\n\t      textVerticalAlign = 'bottom';\n\t      break;\n\t\n\t    case 'insideBottomRight':\n\t      x += width - distance;\n\t      y += height - distance;\n\t      textAlign = 'right';\n\t      textVerticalAlign = 'bottom';\n\t      break;\n\t  }\n\t\n\t  return {\n\t    x: x,\n\t    y: y,\n\t    textAlign: textAlign,\n\t    textVerticalAlign: textVerticalAlign\n\t  };\n\t}\n\t/**\n\t * Show ellipsis if overflow.\n\t *\n\t * @public\n\t * @param  {string} text\n\t * @param  {string} containerWidth\n\t * @param  {string} font\n\t * @param  {number} [ellipsis='...']\n\t * @param  {Object} [options]\n\t * @param  {number} [options.maxIterations=3]\n\t * @param  {number} [options.minChar=0] If truncate result are less\n\t *                  then minChar, ellipsis will not show, which is\n\t *                  better for user hint in some cases.\n\t * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n\t * @return {string}\n\t */\n\t\n\t\n\tfunction truncateText(text, containerWidth, font, ellipsis, options) {\n\t  if (!containerWidth) {\n\t    return '';\n\t  }\n\t\n\t  var textLines = (text + '').split('\\n');\n\t  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n\t  // It is not appropriate that every line has '...' when truncate multiple lines.\n\t\n\t  for (var i = 0, len = textLines.length; i < len; i++) {\n\t    textLines[i] = truncateSingleLine(textLines[i], options);\n\t  }\n\t\n\t  return textLines.join('\\n');\n\t}\n\t\n\tfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n\t  options = extend({}, options);\n\t  options.font = font;\n\t  var ellipsis = retrieve2(ellipsis, '...');\n\t  options.maxIterations = retrieve2(options.maxIterations, 2);\n\t  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n\t  // Other languages?\n\t\n\t  options.cnCharWidth = getWidth('国', font); // FIXME\n\t  // Consider proportional font?\n\t\n\t  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n\t  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n\t  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\t\n\t  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\t\n\t  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n\t    contentWidth -= ascCharWidth;\n\t  }\n\t\n\t  var ellipsisWidth = getWidth(ellipsis);\n\t\n\t  if (ellipsisWidth > contentWidth) {\n\t    ellipsis = '';\n\t    ellipsisWidth = 0;\n\t  }\n\t\n\t  contentWidth = containerWidth - ellipsisWidth;\n\t  options.ellipsis = ellipsis;\n\t  options.ellipsisWidth = ellipsisWidth;\n\t  options.contentWidth = contentWidth;\n\t  options.containerWidth = containerWidth;\n\t  return options;\n\t}\n\t\n\tfunction truncateSingleLine(textLine, options) {\n\t  var containerWidth = options.containerWidth;\n\t  var font = options.font;\n\t  var contentWidth = options.contentWidth;\n\t\n\t  if (!containerWidth) {\n\t    return '';\n\t  }\n\t\n\t  var lineWidth = getWidth(textLine, font);\n\t\n\t  if (lineWidth <= containerWidth) {\n\t    return textLine;\n\t  }\n\t\n\t  for (var j = 0;; j++) {\n\t    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n\t      textLine += options.ellipsis;\n\t      break;\n\t    }\n\t\n\t    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n\t    textLine = textLine.substr(0, subLength);\n\t    lineWidth = getWidth(textLine, font);\n\t  }\n\t\n\t  if (textLine === '') {\n\t    textLine = options.placeholder;\n\t  }\n\t\n\t  return textLine;\n\t}\n\t\n\tfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n\t  var width = 0;\n\t  var i = 0;\n\t\n\t  for (var len = text.length; i < len && width < contentWidth; i++) {\n\t    var charCode = text.charCodeAt(i);\n\t    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n\t  }\n\t\n\t  return i;\n\t}\n\t/**\n\t * @public\n\t * @param {string} font\n\t * @return {number} line height\n\t */\n\t\n\t\n\tfunction getLineHeight(font) {\n\t  // FIXME A rough approach.\n\t  return getWidth('国', font);\n\t}\n\t/**\n\t * @public\n\t * @param {string} text\n\t * @param {string} font\n\t * @return {Object} width\n\t */\n\t\n\t\n\tfunction measureText(text, font) {\n\t  return methods.measureText(text, font);\n\t} // Avoid assign to an exported variable, for transforming to cjs.\n\t\n\t\n\tmethods.measureText = function (text, font) {\n\t  var ctx = getContext();\n\t  ctx.font = font || DEFAULT_FONT;\n\t  return ctx.measureText(text);\n\t};\n\t/**\n\t * @public\n\t * @param {string} text\n\t * @param {string} font\n\t * @param {Object} [truncate]\n\t * @return {Object} block: {lineHeight, lines, height, outerHeight}\n\t *  Notice: for performance, do not calculate outerWidth util needed.\n\t */\n\t\n\t\n\tfunction parsePlainText(text, font, padding, truncate) {\n\t  text != null && (text += '');\n\t  var lineHeight = getLineHeight(font);\n\t  var lines = text ? text.split('\\n') : [];\n\t  var height = lines.length * lineHeight;\n\t  var outerHeight = height;\n\t\n\t  if (padding) {\n\t    outerHeight += padding[0] + padding[2];\n\t  }\n\t\n\t  if (text && truncate) {\n\t    var truncOuterHeight = truncate.outerHeight;\n\t    var truncOuterWidth = truncate.outerWidth;\n\t\n\t    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n\t      text = '';\n\t      lines = [];\n\t    } else if (truncOuterWidth != null) {\n\t      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n\t        minChar: truncate.minChar,\n\t        placeholder: truncate.placeholder\n\t      }); // FIXME\n\t      // It is not appropriate that every line has '...' when truncate multiple lines.\n\t\n\t      for (var i = 0, len = lines.length; i < len; i++) {\n\t        lines[i] = truncateSingleLine(lines[i], options);\n\t      }\n\t    }\n\t  }\n\t\n\t  return {\n\t    lines: lines,\n\t    height: height,\n\t    outerHeight: outerHeight,\n\t    lineHeight: lineHeight\n\t  };\n\t}\n\t/**\n\t * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n\t * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n\t *\n\t * @public\n\t * @param {string} text\n\t * @param {Object} style\n\t * @return {Object} block\n\t * {\n\t *      width,\n\t *      height,\n\t *      lines: [{\n\t *          lineHeight,\n\t *          width,\n\t *          tokens: [[{\n\t *              styleName,\n\t *              text,\n\t *              width,      // include textPadding\n\t *              height,     // include textPadding\n\t *              textWidth, // pure text width\n\t *              textHeight, // pure text height\n\t *              lineHeihgt,\n\t *              font,\n\t *              textAlign,\n\t *              textVerticalAlign\n\t *          }], [...], ...]\n\t *      }, ...]\n\t * }\n\t * If styleName is undefined, it is plain text.\n\t */\n\t\n\t\n\tfunction parseRichText(text, style) {\n\t  var contentBlock = {\n\t    lines: [],\n\t    width: 0,\n\t    height: 0\n\t  };\n\t  text != null && (text += '');\n\t\n\t  if (!text) {\n\t    return contentBlock;\n\t  }\n\t\n\t  var lastIndex = STYLE_REG.lastIndex = 0;\n\t  var result;\n\t\n\t  while ((result = STYLE_REG.exec(text)) != null) {\n\t    var matchedIndex = result.index;\n\t\n\t    if (matchedIndex > lastIndex) {\n\t      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n\t    }\n\t\n\t    pushTokens(contentBlock, result[2], result[1]);\n\t    lastIndex = STYLE_REG.lastIndex;\n\t  }\n\t\n\t  if (lastIndex < text.length) {\n\t    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n\t  }\n\t\n\t  var lines = contentBlock.lines;\n\t  var contentHeight = 0;\n\t  var contentWidth = 0; // For `textWidth: 100%`\n\t\n\t  var pendingList = [];\n\t  var stlPadding = style.textPadding;\n\t  var truncate = style.truncate;\n\t  var truncateWidth = truncate && truncate.outerWidth;\n\t  var truncateHeight = truncate && truncate.outerHeight;\n\t\n\t  if (stlPadding) {\n\t    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n\t    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n\t  } // Calculate layout info of tokens.\n\t\n\t\n\t  for (var i = 0; i < lines.length; i++) {\n\t    var line = lines[i];\n\t    var lineHeight = 0;\n\t    var lineWidth = 0;\n\t\n\t    for (var j = 0; j < line.tokens.length; j++) {\n\t      var token = line.tokens[j];\n\t      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\t\n\t      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\t\n\t      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\t\n\t      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n\t      // as box height of the block.\n\t      tokenStyle.textHeight, getLineHeight(font));\n\t      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n\t      token.height = tokenHeight;\n\t      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n\t      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n\t      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\t\n\t      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n\t        return {\n\t          lines: [],\n\t          width: 0,\n\t          height: 0\n\t        };\n\t      }\n\t\n\t      token.textWidth = getWidth(token.text, font);\n\t      var tokenWidth = tokenStyle.textWidth;\n\t      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n\t      // line when box width is needed to be auto.\n\t\n\t      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n\t        token.percentWidth = tokenWidth;\n\t        pendingList.push(token);\n\t        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n\t        // and it is too complicated.\n\t      } else {\n\t        if (tokenWidthNotSpecified) {\n\t          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n\t          // `getBoundingRect()` will not get correct result.\n\t\n\t          var textBackgroundColor = tokenStyle.textBackgroundColor;\n\t          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n\t          // (1) If image is not loaded, it will be loaded at render phase and call\n\t          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n\t          // image, and then the right size will be calculated here at the next tick.\n\t          // See `graphic/helper/text.js`.\n\t          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n\t          // use `imageHelper.findExistImage` to find cached image.\n\t          // `imageHelper.findExistImage` will always be called here before\n\t          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n\t          // which ensures that image will not be rendered before correct size calcualted.\n\t\n\t          if (bgImg) {\n\t            bgImg = imageHelper.findExistImage(bgImg);\n\t\n\t            if (imageHelper.isImageReady(bgImg)) {\n\t              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n\t            }\n\t          }\n\t        }\n\t\n\t        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n\t        tokenWidth += paddingW;\n\t        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\t\n\t        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n\t          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n\t            token.text = '';\n\t            token.textWidth = tokenWidth = 0;\n\t          } else {\n\t            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n\t              minChar: truncate.minChar\n\t            });\n\t            token.textWidth = getWidth(token.text, font);\n\t            tokenWidth = token.textWidth + paddingW;\n\t          }\n\t        }\n\t      }\n\t\n\t      lineWidth += token.width = tokenWidth;\n\t      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n\t    }\n\t\n\t    line.width = lineWidth;\n\t    line.lineHeight = lineHeight;\n\t    contentHeight += lineHeight;\n\t    contentWidth = Math.max(contentWidth, lineWidth);\n\t  }\n\t\n\t  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n\t  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\t\n\t  if (stlPadding) {\n\t    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n\t    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n\t  }\n\t\n\t  for (var i = 0; i < pendingList.length; i++) {\n\t    var token = pendingList[i];\n\t    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\t\n\t    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n\t  }\n\t\n\t  return contentBlock;\n\t}\n\t\n\tfunction pushTokens(block, str, styleName) {\n\t  var isEmptyStr = str === '';\n\t  var strs = str.split('\\n');\n\t  var lines = block.lines;\n\t\n\t  for (var i = 0; i < strs.length; i++) {\n\t    var text = strs[i];\n\t    var token = {\n\t      styleName: styleName,\n\t      text: text,\n\t      isLineHolder: !text && !isEmptyStr\n\t    }; // The first token should be appended to the last line.\n\t\n\t    if (!i) {\n\t      var tokens = (lines[lines.length - 1] || (lines[0] = {\n\t        tokens: []\n\t      })).tokens; // Consider cases:\n\t      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n\t      // (which is a placeholder) should be replaced by new token.\n\t      // (2) A image backage, where token likes {a|}.\n\t      // (3) A redundant '' will affect textAlign in line.\n\t      // (4) tokens with the same tplName should not be merged, because\n\t      // they should be displayed in different box (with border and padding).\n\t\n\t      var tokensLen = tokens.length;\n\t      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n\t      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n\t      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n\t    } // Other tokens always start a new line.\n\t    else {\n\t        // If there is '', insert it as a placeholder.\n\t        lines.push({\n\t          tokens: [token]\n\t        });\n\t      }\n\t  }\n\t}\n\t\n\tfunction makeFont(style) {\n\t  // FIXME in node-canvas fontWeight is before fontStyle\n\t  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n\t  return (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n\t  style.fontFamily || 'sans-serif'].join(' ') || style.textFont || style.font;\n\t}\n\t\n\texports.DEFAULT_FONT = DEFAULT_FONT;\n\texports.$override = $override;\n\texports.getWidth = getWidth;\n\texports.getBoundingRect = getBoundingRect;\n\texports.adjustTextX = adjustTextX;\n\texports.adjustTextY = adjustTextY;\n\texports.adjustTextPositionOnRect = adjustTextPositionOnRect;\n\texports.truncateText = truncateText;\n\texports.getLineHeight = getLineHeight;\n\texports.measureText = measureText;\n\texports.parsePlainText = parsePlainText;\n\texports.parseRichText = parseRichText;\n\texports.makeFont = makeFont;\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar LRU = __webpack_require__(21);\n\t\n\tvar globalImageCache = new LRU(50);\n\t/**\n\t * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n\t * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n\t */\n\t\n\tfunction findExistImage(newImageOrSrc) {\n\t  if (typeof newImageOrSrc === 'string') {\n\t    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n\t    return cachedImgObj && cachedImgObj.image;\n\t  } else {\n\t    return newImageOrSrc;\n\t  }\n\t}\n\t/**\n\t * Caution: User should cache loaded images, but not just count on LRU.\n\t * Consider if required images more than LRU size, will dead loop occur?\n\t *\n\t * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n\t * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.\n\t * @param {module:zrender/Element} [hostEl] For calling `dirty`.\n\t * @param {Function} [cb] params: (image, cbPayload)\n\t * @param {Object} [cbPayload] Payload on cb calling.\n\t * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n\t */\n\t\n\t\n\tfunction createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {\n\t  if (!newImageOrSrc) {\n\t    return image;\n\t  } else if (typeof newImageOrSrc === 'string') {\n\t    // Image should not be loaded repeatly.\n\t    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {\n\t      return image;\n\t    } // Only when there is no existent image or existent image src\n\t    // is different, this method is responsible for load.\n\t\n\t\n\t    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n\t    var pendingWrap = {\n\t      hostEl: hostEl,\n\t      cb: cb,\n\t      cbPayload: cbPayload\n\t    };\n\t\n\t    if (cachedImgObj) {\n\t      image = cachedImgObj.image;\n\t      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);\n\t    } else {\n\t      !image && (image = new Image());\n\t      image.onload = imageOnLoad;\n\t      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {\n\t        image: image,\n\t        pending: [pendingWrap]\n\t      });\n\t      image.src = image.__zrImageSrc = newImageOrSrc;\n\t    }\n\t\n\t    return image;\n\t  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas\n\t  else {\n\t      return newImageOrSrc;\n\t    }\n\t}\n\t\n\tfunction imageOnLoad() {\n\t  var cachedImgObj = this.__cachedImgObj;\n\t  this.onload = this.__cachedImgObj = null;\n\t\n\t  for (var i = 0; i < cachedImgObj.pending.length; i++) {\n\t    var pendingWrap = cachedImgObj.pending[i];\n\t    var cb = pendingWrap.cb;\n\t    cb && cb(this, pendingWrap.cbPayload);\n\t    pendingWrap.hostEl.dirty();\n\t  }\n\t\n\t  cachedImgObj.pending.length = 0;\n\t}\n\t\n\tfunction isImageReady(image) {\n\t  return image && image.width && image.height;\n\t}\n\t\n\texports.findExistImage = findExistImage;\n\texports.createOrUpdateImage = createOrUpdateImage;\n\texports.isImageReady = isImageReady;\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports) {\n\n\tfunction buildPath(ctx, shape) {\n\t  var x = shape.x;\n\t  var y = shape.y;\n\t  var width = shape.width;\n\t  var height = shape.height;\n\t  var r = shape.r;\n\t  var r1;\n\t  var r2;\n\t  var r3;\n\t  var r4; // Convert width and height to positive for better borderRadius\n\t\n\t  if (width < 0) {\n\t    x = x + width;\n\t    width = -width;\n\t  }\n\t\n\t  if (height < 0) {\n\t    y = y + height;\n\t    height = -height;\n\t  }\n\t\n\t  if (typeof r === 'number') {\n\t    r1 = r2 = r3 = r4 = r;\n\t  } else if (r instanceof Array) {\n\t    if (r.length === 1) {\n\t      r1 = r2 = r3 = r4 = r[0];\n\t    } else if (r.length === 2) {\n\t      r1 = r3 = r[0];\n\t      r2 = r4 = r[1];\n\t    } else if (r.length === 3) {\n\t      r1 = r[0];\n\t      r2 = r4 = r[1];\n\t      r3 = r[2];\n\t    } else {\n\t      r1 = r[0];\n\t      r2 = r[1];\n\t      r3 = r[2];\n\t      r4 = r[3];\n\t    }\n\t  } else {\n\t    r1 = r2 = r3 = r4 = 0;\n\t  }\n\t\n\t  var total;\n\t\n\t  if (r1 + r2 > width) {\n\t    total = r1 + r2;\n\t    r1 *= width / total;\n\t    r2 *= width / total;\n\t  }\n\t\n\t  if (r3 + r4 > width) {\n\t    total = r3 + r4;\n\t    r3 *= width / total;\n\t    r4 *= width / total;\n\t  }\n\t\n\t  if (r2 + r3 > height) {\n\t    total = r2 + r3;\n\t    r2 *= height / total;\n\t    r3 *= height / total;\n\t  }\n\t\n\t  if (r1 + r4 > height) {\n\t    total = r1 + r4;\n\t    r1 *= height / total;\n\t    r4 *= height / total;\n\t  }\n\t\n\t  ctx.moveTo(x + r1, y);\n\t  ctx.lineTo(x + width - r2, y);\n\t  r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);\n\t  ctx.lineTo(x + width, y + height - r3);\n\t  r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);\n\t  ctx.lineTo(x + r4, y + height);\n\t  r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);\n\t  ctx.lineTo(x, y + r1);\n\t  r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n\t}\n\t\n\texports.buildPath = buildPath;\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(6);\n\t\n\tvar _event = __webpack_require__(39);\n\t\n\tvar Dispatcher = _event.Dispatcher;\n\t\n\tvar requestAnimationFrame = __webpack_require__(30);\n\t\n\tvar Animator = __webpack_require__(17);\n\t\n\t/**\n\t * 动画主类, 调度和管理所有动画控制器\n\t *\n\t * @module zrender/animation/Animation\n\t * @author pissang(https://github.com/pissang)\n\t */\n\t// TODO Additive animation\n\t// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n\t// https://developer.apple.com/videos/wwdc2014/#236\n\t\n\t/**\n\t * @typedef {Object} IZRenderStage\n\t * @property {Function} update\n\t */\n\t\n\t/**\n\t * @alias module:zrender/animation/Animation\n\t * @constructor\n\t * @param {Object} [options]\n\t * @param {Function} [options.onframe]\n\t * @param {IZRenderStage} [options.stage]\n\t * @example\n\t *     var animation = new Animation();\n\t *     var obj = {\n\t *         x: 100,\n\t *         y: 100\n\t *     };\n\t *     animation.animate(node.position)\n\t *         .when(1000, {\n\t *             x: 500,\n\t *             y: 500\n\t *         })\n\t *         .when(2000, {\n\t *             x: 100,\n\t *             y: 100\n\t *         })\n\t *         .start('spline');\n\t */\n\tvar Animation = function (options) {\n\t  options = options || {};\n\t  this.stage = options.stage || {};\n\t\n\t  this.onframe = options.onframe || function () {}; // private properties\n\t\n\t\n\t  this._clips = [];\n\t  this._running = false;\n\t  this._time;\n\t  this._pausedTime;\n\t  this._pauseStart;\n\t  this._paused = false;\n\t  Dispatcher.call(this);\n\t};\n\t\n\tAnimation.prototype = {\n\t  constructor: Animation,\n\t\n\t  /**\n\t   * 添加 clip\n\t   * @param {module:zrender/animation/Clip} clip\n\t   */\n\t  addClip: function (clip) {\n\t    this._clips.push(clip);\n\t  },\n\t\n\t  /**\n\t   * 添加 animator\n\t   * @param {module:zrender/animation/Animator} animator\n\t   */\n\t  addAnimator: function (animator) {\n\t    animator.animation = this;\n\t    var clips = animator.getClips();\n\t\n\t    for (var i = 0; i < clips.length; i++) {\n\t      this.addClip(clips[i]);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 删除动画片段\n\t   * @param {module:zrender/animation/Clip} clip\n\t   */\n\t  removeClip: function (clip) {\n\t    var idx = util.indexOf(this._clips, clip);\n\t\n\t    if (idx >= 0) {\n\t      this._clips.splice(idx, 1);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 删除动画片段\n\t   * @param {module:zrender/animation/Animator} animator\n\t   */\n\t  removeAnimator: function (animator) {\n\t    var clips = animator.getClips();\n\t\n\t    for (var i = 0; i < clips.length; i++) {\n\t      this.removeClip(clips[i]);\n\t    }\n\t\n\t    animator.animation = null;\n\t  },\n\t  _update: function () {\n\t    var time = new Date().getTime() - this._pausedTime;\n\t\n\t    var delta = time - this._time;\n\t    var clips = this._clips;\n\t    var len = clips.length;\n\t    var deferredEvents = [];\n\t    var deferredClips = [];\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      var clip = clips[i];\n\t      var e = clip.step(time, delta); // Throw out the events need to be called after\n\t      // stage.update, like destroy\n\t\n\t      if (e) {\n\t        deferredEvents.push(e);\n\t        deferredClips.push(clip);\n\t      }\n\t    } // Remove the finished clip\n\t\n\t\n\t    for (var i = 0; i < len;) {\n\t      if (clips[i]._needsRemove) {\n\t        clips[i] = clips[len - 1];\n\t        clips.pop();\n\t        len--;\n\t      } else {\n\t        i++;\n\t      }\n\t    }\n\t\n\t    len = deferredEvents.length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      deferredClips[i].fire(deferredEvents[i]);\n\t    }\n\t\n\t    this._time = time;\n\t    this.onframe(delta);\n\t    this.trigger('frame', delta);\n\t\n\t    if (this.stage.update) {\n\t      this.stage.update();\n\t    }\n\t  },\n\t  _startLoop: function () {\n\t    var self = this;\n\t    this._running = true;\n\t\n\t    function step() {\n\t      if (self._running) {\n\t        requestAnimationFrame(step);\n\t        !self._paused && self._update();\n\t      }\n\t    }\n\t\n\t    requestAnimationFrame(step);\n\t  },\n\t\n\t  /**\n\t   * 开始运行动画\n\t   */\n\t  start: function () {\n\t    this._time = new Date().getTime();\n\t    this._pausedTime = 0;\n\t\n\t    this._startLoop();\n\t  },\n\t\n\t  /**\n\t   * 停止运行动画\n\t   */\n\t  stop: function () {\n\t    this._running = false;\n\t  },\n\t\n\t  /**\n\t   * Pause\n\t   */\n\t  pause: function () {\n\t    if (!this._paused) {\n\t      this._pauseStart = new Date().getTime();\n\t      this._paused = true;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Resume\n\t   */\n\t  resume: function () {\n\t    if (this._paused) {\n\t      this._pausedTime += new Date().getTime() - this._pauseStart;\n\t      this._paused = false;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 清除所有动画片段\n\t   */\n\t  clear: function () {\n\t    this._clips = [];\n\t  },\n\t\n\t  /**\n\t   * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画\n\t   * @param  {Object} target\n\t   * @param  {Object} options\n\t   * @param  {boolean} [options.loop=false] 是否循环播放动画\n\t   * @param  {Function} [options.getter=null]\n\t   *         如果指定getter函数，会通过getter函数取属性值\n\t   * @param  {Function} [options.setter=null]\n\t   *         如果指定setter函数，会通过setter函数设置属性值\n\t   * @return {module:zrender/animation/Animation~Animator}\n\t   */\n\t  // TODO Gap\n\t  animate: function (target, options) {\n\t    options = options || {};\n\t    var animator = new Animator(target, options.loop, options.getter, options.setter);\n\t    this.addAnimator(animator);\n\t    return animator;\n\t  }\n\t};\n\tutil.mixin(Animation, Dispatcher);\n\tvar _default = Animation;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Eventful = __webpack_require__(10);\n\t\n\texports.Dispatcher = Eventful;\n\t\n\tvar env = __webpack_require__(5);\n\t\n\t/**\n\t * 事件辅助类\n\t * @module zrender/core/event\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t */\n\tvar isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\n\tvar MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;\n\t\n\tfunction getBoundingClientRect(el) {\n\t  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n\t  return el.getBoundingClientRect ? el.getBoundingClientRect() : {\n\t    left: 0,\n\t    top: 0\n\t  };\n\t} // `calculate` is optional, default false\n\t\n\t\n\tfunction clientToLocal(el, e, out, calculate) {\n\t  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative\n\t  // to the padding edge of the target element. The only browser using this convention\n\t  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n\t  // not support the properties.\n\t  // (see http://www.jacklmoore.com/notes/mouse-position/)\n\t  // In zr painter.dom, padding edge equals to border edge.\n\t  // FIXME\n\t  // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n\t  // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n\t  // is too complex. So css-transfrom dont support in this case temporarily.\n\t\n\t  if (calculate || !env.canvasSupported) {\n\t    defaultGetZrXY(el, e, out);\n\t  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n\t  // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n\t  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n\t  // zoom-factor, overflow / opacity layers, transforms ...)\n\t  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n\t  // <https://bugs.jquery.com/ticket/8523#comment:14>\n\t  // BTW3, In ff, offsetX/offsetY is always 0.\n\t  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n\t      out.zrX = e.layerX;\n\t      out.zrY = e.layerY;\n\t    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n\t    else if (e.offsetX != null) {\n\t        out.zrX = e.offsetX;\n\t        out.zrY = e.offsetY;\n\t      } // For some other device, e.g., IOS safari.\n\t      else {\n\t          defaultGetZrXY(el, e, out);\n\t        }\n\t\n\t  return out;\n\t}\n\t\n\tfunction defaultGetZrXY(el, e, out) {\n\t  // This well-known method below does not support css transform.\n\t  var box = getBoundingClientRect(el);\n\t  out.zrX = e.clientX - box.left;\n\t  out.zrY = e.clientY - box.top;\n\t}\n\t/**\n\t * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.\n\t * `calculate` is optional, default false.\n\t */\n\t\n\t\n\tfunction normalizeEvent(el, e, calculate) {\n\t  e = e || window.event;\n\t\n\t  if (e.zrX != null) {\n\t    return e;\n\t  }\n\t\n\t  var eventType = e.type;\n\t  var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\t\n\t  if (!isTouch) {\n\t    clientToLocal(el, e, e, calculate);\n\t    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n\t  } else {\n\t    var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n\t    touch && clientToLocal(el, touch, e, calculate);\n\t  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;\n\t  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js\n\t  // If e.which has been defined, if may be readonly,\n\t  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which\n\t\n\t\n\t  var button = e.button;\n\t\n\t  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {\n\t    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n\t  }\n\t\n\t  return e;\n\t}\n\t\n\tfunction addEventListener(el, name, handler) {\n\t  if (isDomLevel2) {\n\t    el.addEventListener(name, handler);\n\t  } else {\n\t    el.attachEvent('on' + name, handler);\n\t  }\n\t}\n\t\n\tfunction removeEventListener(el, name, handler) {\n\t  if (isDomLevel2) {\n\t    el.removeEventListener(name, handler);\n\t  } else {\n\t    el.detachEvent('on' + name, handler);\n\t  }\n\t}\n\t/**\n\t * preventDefault and stopPropagation.\n\t * Notice: do not do that in zrender. Upper application\n\t * do that if necessary.\n\t *\n\t * @memberOf module:zrender/core/event\n\t * @method\n\t * @param {Event} e : event对象\n\t */\n\t\n\t\n\tvar stop = isDomLevel2 ? function (e) {\n\t  e.preventDefault();\n\t  e.stopPropagation();\n\t  e.cancelBubble = true;\n\t} : function (e) {\n\t  e.returnValue = false;\n\t  e.cancelBubble = true;\n\t};\n\t\n\tfunction notLeftMouse(e) {\n\t  // If e.which is undefined, considered as left mouse event.\n\t  return e.which > 1;\n\t} // 做向上兼容\n\t\n\t\n\texports.clientToLocal = clientToLocal;\n\texports.normalizeEvent = normalizeEvent;\n\texports.addEventListener = addEventListener;\n\texports.removeEventListener = removeEventListener;\n\texports.stop = stop;\n\texports.notLeftMouse = notLeftMouse;\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _event = __webpack_require__(39);\n\t\n\tvar addEventListener = _event.addEventListener;\n\tvar removeEventListener = _event.removeEventListener;\n\tvar normalizeEvent = _event.normalizeEvent;\n\t\n\tvar zrUtil = __webpack_require__(6);\n\t\n\tvar Eventful = __webpack_require__(10);\n\t\n\tvar env = __webpack_require__(5);\n\t\n\tvar GestureMgr = __webpack_require__(41);\n\t\n\tvar TOUCH_CLICK_DELAY = 300;\n\tvar mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n\tvar touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];\n\tvar pointerEventNames = {\n\t  pointerdown: 1,\n\t  pointerup: 1,\n\t  pointermove: 1,\n\t  pointerout: 1\n\t};\n\tvar pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n\t  var nm = name.replace('mouse', 'pointer');\n\t  return pointerEventNames[nm] ? nm : name;\n\t});\n\t\n\tfunction eventNameFix(name) {\n\t  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n\t}\n\t\n\tfunction processGesture(proxy, event, stage) {\n\t  var gestureMgr = proxy._gestureMgr;\n\t  stage === 'start' && gestureMgr.clear();\n\t  var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null).target, proxy.dom);\n\t  stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.\n\t\n\t  if (gestureInfo) {\n\t    var type = gestureInfo.type;\n\t    event.gestureEvent = type;\n\t    proxy.handler.dispatchToElement({\n\t      target: gestureInfo.target\n\t    }, type, gestureInfo.event);\n\t  }\n\t} // function onMSGestureChange(proxy, event) {\n\t//     if (event.translationX || event.translationY) {\n\t//         // mousemove is carried by MSGesture to reduce the sensitivity.\n\t//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n\t//     }\n\t//     if (event.scale !== 1) {\n\t//         event.pinchX = event.offsetX;\n\t//         event.pinchY = event.offsetY;\n\t//         event.pinchScale = event.scale;\n\t//         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n\t//     }\n\t// }\n\t\n\t/**\n\t * Prevent mouse event from being dispatched after Touch Events action\n\t * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n\t * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n\t * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n\t * Result: Blocking Mouse Events for 700ms.\n\t */\n\t\n\t\n\tfunction setTouchTimer(instance) {\n\t  instance._touching = true;\n\t  clearTimeout(instance._touchTimer);\n\t  instance._touchTimer = setTimeout(function () {\n\t    instance._touching = false;\n\t  }, 700);\n\t}\n\t\n\tvar domHandlers = {\n\t  /**\n\t   * Mouse move handler\n\t   * @inner\n\t   * @param {Event} event\n\t   */\n\t  mousemove: function (event) {\n\t    event = normalizeEvent(this.dom, event);\n\t    this.trigger('mousemove', event);\n\t  },\n\t\n\t  /**\n\t   * Mouse out handler\n\t   * @inner\n\t   * @param {Event} event\n\t   */\n\t  mouseout: function (event) {\n\t    event = normalizeEvent(this.dom, event);\n\t    var element = event.toElement || event.relatedTarget;\n\t\n\t    if (element != this.dom) {\n\t      while (element && element.nodeType != 9) {\n\t        // 忽略包含在root中的dom引起的mouseOut\n\t        if (element === this.dom) {\n\t          return;\n\t        }\n\t\n\t        element = element.parentNode;\n\t      }\n\t    }\n\t\n\t    this.trigger('mouseout', event);\n\t  },\n\t\n\t  /**\n\t   * Touch开始响应函数\n\t   * @inner\n\t   * @param {Event} event\n\t   */\n\t  touchstart: function (event) {\n\t    // Default mouse behaviour should not be disabled here.\n\t    // For example, page may needs to be slided.\n\t    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n\t    // mouse event in upper applicatoin.\n\t\n\t    event.zrByTouch = true;\n\t    this._lastTouchMoment = new Date();\n\t    processGesture(this, event, 'start'); // In touch device, trigger `mousemove`(`mouseover`) should\n\t    // be triggered, and must before `mousedown` triggered.\n\t\n\t    domHandlers.mousemove.call(this, event);\n\t    domHandlers.mousedown.call(this, event);\n\t    setTouchTimer(this);\n\t  },\n\t\n\t  /**\n\t   * Touch移动响应函数\n\t   * @inner\n\t   * @param {Event} event\n\t   */\n\t  touchmove: function (event) {\n\t    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n\t    // mouse event in upper applicatoin.\n\t\n\t    event.zrByTouch = true;\n\t    processGesture(this, event, 'change'); // Mouse move should always be triggered no matter whether\n\t    // there is gestrue event, because mouse move and pinch may\n\t    // be used at the same time.\n\t\n\t    domHandlers.mousemove.call(this, event);\n\t    setTouchTimer(this);\n\t  },\n\t\n\t  /**\n\t   * Touch结束响应函数\n\t   * @inner\n\t   * @param {Event} event\n\t   */\n\t  touchend: function (event) {\n\t    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n\t    // mouse event in upper applicatoin.\n\t\n\t    event.zrByTouch = true;\n\t    processGesture(this, event, 'end');\n\t    domHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n\t    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n\t    // we can conveniently implement \"hover style\" in both PC and touch device just\n\t    // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n\t    // to remove \"hover style\" on an element, without any additional code for\n\t    // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n\t    // style\" will remain for user view)\n\t    // click event should always be triggered no matter whether\n\t    // there is gestrue event. System click can not be prevented.\n\t\n\t    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n\t      domHandlers.click.call(this, event);\n\t    }\n\t\n\t    setTouchTimer(this);\n\t  },\n\t  pointerdown: function (event) {\n\t    domHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {\n\t    //     this._msGesture.addPointer(event.pointerId);\n\t    // }\n\t  },\n\t  pointermove: function (event) {\n\t    // FIXME\n\t    // pointermove is so sensitive that it always triggered when\n\t    // tap(click) on touch screen, which affect some judgement in\n\t    // upper application. So, we dont support mousemove on MS touch\n\t    // device yet.\n\t    if (!isPointerFromTouch(event)) {\n\t      domHandlers.mousemove.call(this, event);\n\t    }\n\t  },\n\t  pointerup: function (event) {\n\t    domHandlers.mouseup.call(this, event);\n\t  },\n\t  pointerout: function (event) {\n\t    // pointerout will be triggered when tap on touch screen\n\t    // (IE11+/Edge on MS Surface) after click event triggered,\n\t    // which is inconsistent with the mousout behavior we defined\n\t    // in touchend. So we unify them.\n\t    // (check domHandlers.touchend for detailed explanation)\n\t    if (!isPointerFromTouch(event)) {\n\t      domHandlers.mouseout.call(this, event);\n\t    }\n\t  }\n\t};\n\t\n\tfunction isPointerFromTouch(event) {\n\t  var pointerType = event.pointerType;\n\t  return pointerType === 'pen' || pointerType === 'touch';\n\t} // function useMSGuesture(handlerProxy, event) {\n\t//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n\t// }\n\t// Common handlers\n\t\n\t\n\tzrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n\t  domHandlers[name] = function (event) {\n\t    event = normalizeEvent(this.dom, event);\n\t    this.trigger(name, event);\n\t  };\n\t});\n\t/**\n\t * 为控制类实例初始化dom 事件处理函数\n\t *\n\t * @inner\n\t * @param {module:zrender/Handler} instance 控制类实例\n\t */\n\t\n\tfunction initDomHandler(instance) {\n\t  zrUtil.each(touchHandlerNames, function (name) {\n\t    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t  });\n\t  zrUtil.each(pointerHandlerNames, function (name) {\n\t    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t  });\n\t  zrUtil.each(mouseHandlerNames, function (name) {\n\t    instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n\t  });\n\t\n\t  function makeMouseHandler(fn, instance) {\n\t    return function () {\n\t      if (instance._touching) {\n\t        return;\n\t      }\n\t\n\t      return fn.apply(instance, arguments);\n\t    };\n\t  }\n\t}\n\t\n\tfunction HandlerDomProxy(dom) {\n\t  Eventful.call(this);\n\t  this.dom = dom;\n\t  /**\n\t   * @private\n\t   * @type {boolean}\n\t   */\n\t\n\t  this._touching = false;\n\t  /**\n\t   * @private\n\t   * @type {number}\n\t   */\n\t\n\t  this._touchTimer;\n\t  /**\n\t   * @private\n\t   * @type {module:zrender/core/GestureMgr}\n\t   */\n\t\n\t  this._gestureMgr = new GestureMgr();\n\t  this._handlers = {};\n\t  initDomHandler(this);\n\t\n\t  if (env.pointerEventsSupported) {\n\t    // Only IE11+/Edge\n\t    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n\t    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n\t    // at the same time.\n\t    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n\t    // screen, which do not occurs in pointer event.\n\t    // So we use pointer event to both detect touch gesture and mouse behavior.\n\t    mountHandlers(pointerHandlerNames, this); // FIXME\n\t    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n\t    // which does not prevent defuault behavior occasionally (which may cause view port\n\t    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n\t    // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n\t    // touch screen. And we only support click behavior on MS touch screen now.\n\t    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n\t    // We dont support touch on IE on win7.\n\t    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n\t    // if (typeof MSGesture === 'function') {\n\t    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n\t    //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n\t    // }\n\t  } else {\n\t    if (env.touchEventsSupported) {\n\t      mountHandlers(touchHandlerNames, this); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n\t      // addEventListener(root, 'mouseout', this._mouseoutHandler);\n\t    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n\t    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n\t    // mouse event can not be handle in those devices.\n\t    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n\t    // mouseevent after touch event triggered, see `setTouchTimer`.\n\t\n\t\n\t    mountHandlers(mouseHandlerNames, this);\n\t  }\n\t\n\t  function mountHandlers(handlerNames, instance) {\n\t    zrUtil.each(handlerNames, function (name) {\n\t      addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n\t    }, instance);\n\t  }\n\t}\n\t\n\tvar handlerDomProxyProto = HandlerDomProxy.prototype;\n\t\n\thandlerDomProxyProto.dispose = function () {\n\t  var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\t\n\t  for (var i = 0; i < handlerNames.length; i++) {\n\t    var name = handlerNames[i];\n\t    removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n\t  }\n\t};\n\t\n\thandlerDomProxyProto.setCursor = function (cursorStyle) {\n\t  this.dom.style.cursor = cursorStyle || 'default';\n\t};\n\t\n\tzrUtil.mixin(HandlerDomProxy, Eventful);\n\tvar _default = HandlerDomProxy;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar eventUtil = __webpack_require__(39);\n\t\n\t/**\n\t * Only implements needed gestures for mobile.\n\t */\n\tvar GestureMgr = function () {\n\t  /**\n\t   * @private\n\t   * @type {Array.<Object>}\n\t   */\n\t  this._track = [];\n\t};\n\t\n\tGestureMgr.prototype = {\n\t  constructor: GestureMgr,\n\t  recognize: function (event, target, root) {\n\t    this._doTrack(event, target, root);\n\t\n\t    return this._recognize(event);\n\t  },\n\t  clear: function () {\n\t    this._track.length = 0;\n\t    return this;\n\t  },\n\t  _doTrack: function (event, target, root) {\n\t    var touches = event.touches;\n\t\n\t    if (!touches) {\n\t      return;\n\t    }\n\t\n\t    var trackItem = {\n\t      points: [],\n\t      touches: [],\n\t      target: target,\n\t      event: event\n\t    };\n\t\n\t    for (var i = 0, len = touches.length; i < len; i++) {\n\t      var touch = touches[i];\n\t      var pos = eventUtil.clientToLocal(root, touch, {});\n\t      trackItem.points.push([pos.zrX, pos.zrY]);\n\t      trackItem.touches.push(touch);\n\t    }\n\t\n\t    this._track.push(trackItem);\n\t  },\n\t  _recognize: function (event) {\n\t    for (var eventName in recognizers) {\n\t      if (recognizers.hasOwnProperty(eventName)) {\n\t        var gestureInfo = recognizers[eventName](this._track, event);\n\t\n\t        if (gestureInfo) {\n\t          return gestureInfo;\n\t        }\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\tfunction dist(pointPair) {\n\t  var dx = pointPair[1][0] - pointPair[0][0];\n\t  var dy = pointPair[1][1] - pointPair[0][1];\n\t  return Math.sqrt(dx * dx + dy * dy);\n\t}\n\t\n\tfunction center(pointPair) {\n\t  return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];\n\t}\n\t\n\tvar recognizers = {\n\t  pinch: function (track, event) {\n\t    var trackLen = track.length;\n\t\n\t    if (!trackLen) {\n\t      return;\n\t    }\n\t\n\t    var pinchEnd = (track[trackLen - 1] || {}).points;\n\t    var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\t\n\t    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {\n\t      var pinchScale = dist(pinchEnd) / dist(pinchPre);\n\t      !isFinite(pinchScale) && (pinchScale = 1);\n\t      event.pinchScale = pinchScale;\n\t      var pinchCenter = center(pinchEnd);\n\t      event.pinchX = pinchCenter[0];\n\t      event.pinchY = pinchCenter[1];\n\t      return {\n\t        type: 'pinch',\n\t        target: track[0].target,\n\t        event: event\n\t      };\n\t    }\n\t  } // Only pinch currently.\n\t\n\t};\n\tvar _default = GestureMgr;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * BO节点\r\n\t * 1.BO是一个矩形\r\n\t * 2.BO有名字\r\n\t * 3.BO有事件决策[]，双击事件决策弹出详情\r\n\t * 4.BO有外键属性[]\r\n\t * 5.BO有子BO\r\n\t * 6.当前BO特殊颜色显示\r\n\t * 7.双击BO弹出BO属性以及属性事件决策页面\r\n\t * @module fish-topo-bo/node/BoNode\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(43);\r\n\t    var BoName = __webpack_require__(44);\r\n\t    var EventDecision = __webpack_require__(77);\r\n\t    var Line = __webpack_require__(78);\r\n\t    var BoAttr = __webpack_require__(79);\r\n\t    var graphic = __webpack_require__(45);\r\n\t    var nodeOptions = null;\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     * @param {{\r\n\t     *          id: String BO主键,\r\n\t     *          name: String BO名字,\r\n\t     *          boEventArr: [] BO事件决策数组,\r\n\t     *          boAttrArr: [] BO属性数组\r\n\t     *          }} boData, bo数据对象\r\n\t     * @param {{\r\n\t     *          startPos: {x: number, y: number} 起始位置,\r\n\t     *          displayAttrDataType: boolean 是否显示属性数据类型,\r\n\t     *          displayAttrEvent: boolean 是否显示属性事件决策,\r\n\t     *          boClickable: boolean BO是否支持点击事件, 可空 默认false\r\n\t     *          boPopupOpts: Object BO弹出页面参数，url,width,height等\r\n\t     *          boEventClickable: boolean BO事件决策是否支持点击事件, 可空 默认false\r\n\t     *          boEventPopupOpts: Object BO事件决策弹出页面参数，url,width,height等\r\n\t     *          bindBoClickEvent: function(options) BO点击事件，返回函数参数为options，它的属性有DATA等\r\n\t     *          attrEventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false\r\n\t     *          attrEventPopupOpts: Object 点击BO属性事件决策弹出页面参数，url,width,height等\r\n\t     *          isCurrent: boolean 是否为当前BO\r\n\t     *          }} opts\r\n\t     * @constructor\r\n\t     */\r\n\t    function BO(boData, opts) {\r\n\t        nodeOptions = opts;\r\n\t\r\n\t        /**\r\n\t         * BO数据\r\n\t         * @type {Object}\r\n\t         * @private\r\n\t         */\r\n\t        this._data = boData;\r\n\t\r\n\t        /**\r\n\t         * 初始坐标，用于最后画BO矩形\r\n\t         * @type {{x: number, y: number}}\r\n\t         * @private\r\n\t         */\r\n\t        this._oriStartPos = opts.startPos;\r\n\t\r\n\t        /**\r\n\t         * 每个控件的起始参照坐标，每个控件画完之后都会重新计算\r\n\t         * @type {{x: number, y: number}}\r\n\t         * @private\r\n\t         */\r\n\t        this._nextStartPos = {\r\n\t            x: opts.startPos.x,\r\n\t            y: opts.startPos.y\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * 是否显示属性数据类型\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._displayAttrDataType = opts.displayAttrDataType || false;\r\n\t\r\n\t        /**\r\n\t         * 是否显示属性事件决策\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._displayAttrEvent = opts.displayAttrEvent || false;\r\n\t\r\n\t        //TODO\r\n\t        if (this._displayAttrEvent) {\r\n\t            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 3;\r\n\t        } else if (this._displayAttrDataType) {\r\n\t            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 1.5;\r\n\t        }\r\n\t\r\n\t        /**\r\n\t         * 是否支持点击\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._boClickable = opts.boClickable || false;\r\n\t        this._boPopupOpts = opts.boPopupOpts;\r\n\t        this._boEventClickable = opts.boEventClickable || false;\r\n\t        this._boEventPopupOpts = opts.boEventPopupOpts;\r\n\t        this._attrEventClickable = opts.attrEventClickable || false;\r\n\t        this._attrEventPopupOpts = opts.attrEventPopupOpts;\r\n\t\r\n\t        /**\r\n\t         * 是否是当前BO，当前BO特殊颜色显示\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._isCurrent = opts.isCurrent || false;\r\n\t\r\n\t\r\n\t        /**\r\n\t         * BO矩形高度，根据实际内容计算\r\n\t         * @type {number}\r\n\t         * @private\r\n\t         */\r\n\t        this._boShapeHeight = 0;\r\n\t\r\n\t        /**\r\n\t         * Group容器\r\n\t         * @type zrender/graphic/Group\r\n\t         * @private\r\n\t         */\r\n\t        this._group = new graphic.Group();\r\n\t        this._group.name = this._data.id;\r\n\t        this._group.setCurrent = function (style) {\r\n\t            //Group最后一个是BO矩形\r\n\t            var _boShape = this.childAt(this.childCount() - 1);\r\n\t\r\n\t            if (style) {\r\n\t                Object.assign(_boShape.style, style);\r\n\t            } else {\r\n\t                //默认效果\r\n\t                _boShape.style.fill = '#66CC99';\r\n\t            }\r\n\t\r\n\t        };\r\n\t\r\n\t        this._render();\r\n\t    }\r\n\t\r\n\t\r\n\t    var boProto = BO.prototype;\r\n\t\r\n\t    /**\r\n\t     * 获取BO整体图形\r\n\t     * @returns {zrender/graphic/Group}\r\n\t     */\r\n\t    boProto.getShape = function () {\r\n\t        return this._group;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 获取数据\r\n\t     * @returns {Object}\r\n\t     */\r\n\t    boProto.getData = function () {\r\n\t        return this._data;\r\n\t    };\r\n\t\r\n\t    boProto.getLayout = function () {\r\n\t        return this._data.layout;\r\n\t    };\r\n\t\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 设置当前BO特殊演示显示\r\n\t     */\r\n\t    boProto.setCurrent = function () {\r\n\t        //BO矩形是最后一个图形\r\n\t        this.childAt(this.childCount - 1).style.fill = '#66CC99'\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成BO整体图形\r\n\t     * @private\r\n\t     */\r\n\t    boProto._render = function () {\r\n\t        //BO名字\r\n\t        this._createBoName();\r\n\t\r\n\t        //BO事件决策\r\n\t        this._createEventDecision();\r\n\t\r\n\t        //BO属性\r\n\t        this._createBoAttr();\r\n\t\r\n\t        //BO矩形\r\n\t        this._createBoShape();\r\n\t\r\n\t        //TODO\r\n\t        Const.BO_NODE_WIDTH = 180;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 生成BO名字文本\r\n\t     * @private\r\n\t     */\r\n\t    boProto._createBoName = function () {\r\n\t        var _boNameShape = BoName(this._data.name, this._nextStartPos);\r\n\t\r\n\t        if (this._boClickable) {\r\n\t            _boNameShape.clickable = this._boClickable;\r\n\t            _boNameShape._data = this._data;\r\n\t            _boNameShape._boPopupOpts = this._boPopupOpts;\r\n\t            _boNameShape.onclick = this._click;\r\n\t        }\r\n\t\r\n\t        this._group.add(_boNameShape);\r\n\t        this._calNextShapeStartPos(_boNameShape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成BO事件决策\r\n\t     * @private\r\n\t     */\r\n\t    boProto._createEventDecision = function () {\r\n\t\r\n\t        //如果没有BO事件决策，则返回\r\n\t        if (!this._data.boEventArr) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var _boEventArr = this._data.boEventArr,\r\n\t            _boEventLen = _boEventArr.length,\r\n\t            _eventShape,\r\n\t            _eventOpts = {\r\n\t                startPos: this._nextStartPos,\r\n\t                clickable: this._boEventClickable,\r\n\t                popupOpts: this._boEventPopupOpts,\r\n\t                bindBoClickEvent: nodeOptions.bindBoClickEvent\r\n\t            };\r\n\t\r\n\t        for (var i = 0; i < _boEventLen; i++) {\r\n\t            _eventShape = new EventDecision(_boEventArr[i], _eventOpts);\r\n\t            this._group.add(_eventShape.getShape());\r\n\t            this._calNextShapeStartPos(_eventShape.getShape());\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成BO属性\r\n\t     * @private\r\n\t     */\r\n\t    boProto._createBoAttr = function () {\r\n\t        //如果没有BO属性，则返回\r\n\t        if (!this._data.boAttrArr) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var _boAttrArr = this._data.boAttrArr,\r\n\t            _boAttrLen = _boAttrArr.length,\r\n\t            _boAttrShape, _lineShape,\r\n\t            _attrEventStartPos = {x: this._nextStartPos.x + Const.BO_NODE_WIDTH / 2, y: this._nextStartPos.y};\r\n\t\r\n\t        for (var i = 0; i < _boAttrLen; i++) {\r\n\t            if (i == 0) {\r\n\t                _lineShape = Line.BoLine(this._nextStartPos); //实线\r\n\t            }\r\n\t            else {\r\n\t                _lineShape = Line.AttrLine(this._nextStartPos);//虚线\r\n\t            }\r\n\t\r\n\t            this._group.add(_lineShape);\r\n\t\r\n\t            this._calNextShapeStartPos(_lineShape);\r\n\t\r\n\t            _boAttrShape = new BoAttr(_boAttrArr[i],\r\n\t                {\r\n\t                    startPos: this._nextStartPos,\r\n\t                    displayDataType: this._displayAttrDataType,\r\n\t                    displayEventDecision: this._displayAttrEvent,\r\n\t                    eventClickable: this._attrEventClickable,\r\n\t                    eventPopupOpts: this._attrEventPopupOpts,\r\n\t                    bindBoClickEvent: nodeOptions.bindBoClickEvent\r\n\t                }\r\n\t            );\r\n\t            this._group.add(_boAttrShape.getShape());\r\n\t            this._calNextShapeStartPos(_boAttrShape.getShape())\r\n\t        }\r\n\t\r\n\t        if (this._displayAttrEvent) {\r\n\t            _lineShape = Line.AttrEventLine(_attrEventStartPos,\r\n\t                this._nextStartPos.y - _attrEventStartPos.y\r\n\t            );\r\n\t            this._group.add(_lineShape);\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 计算下一个图形的开始位置，以及BO矩形的高度\r\n\t     * @param curShape 当前图形\r\n\t     * @private\r\n\t     */\r\n\t    boProto._calNextShapeStartPos = function (curShape) {\r\n\t        //下一图形起始位置\r\n\t        this._nextStartPos.y += curShape.getBoundingRect().height;\r\n\t\r\n\t        //BO矩形高度增加\r\n\t        this._boShapeHeight += curShape.getBoundingRect().height;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 生成BO矩形\r\n\t     * @private\r\n\t     */\r\n\t    boProto._createBoShape = function () {\r\n\t        var height = this._boShapeHeight > Const.BO_NODE_DEFAULT_HEIGHT ?\r\n\t                this._boShapeHeight : Const.BO_NODE_DEFAULT_HEIGHT,\r\n\t            shape = new graphic.Rect({\r\n\t                position: [this._oriStartPos.x, this._oriStartPos.y],\r\n\t\r\n\t                shape: {\r\n\t                    r: 5,\r\n\t                    width: Const.BO_NODE_WIDTH,\r\n\t                    height: height\r\n\t                },\r\n\t\r\n\t                style: {\r\n\t                    brushType: 'both',\r\n\t                    fill: this._isCurrent ? '#66CC99' : 'white',\r\n\t                    stroke: '#000000',\r\n\t                    lineWidth: 1,\r\n\t                    lineCape: 'round'\r\n\t                },\r\n\t\r\n\t                zlevel: -1\r\n\t            });\r\n\t\r\n\t        if (this._boClickable) {\r\n\t            shape._data = this._data;\r\n\t            shape._boPopupOpts = this._boPopupOpts;\r\n\t\r\n\t            shape.clickable = this._boClickable;\r\n\t            shape.onclick = this._click;\r\n\t        }\r\n\t\r\n\t        this._group.add(shape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 点击事件\r\n\t     * @private\r\n\t     */\r\n\t    boProto._click = function () {\r\n\t        var options = Object.assign(\r\n\t            {\r\n\t                DATA: this._data\r\n\t            }, this._boPopupOpts);\r\n\t\r\n\t        nodeOptions.bindBoClickEvent(options);\r\n\t    };\r\n\t\r\n\t    module.exports = BO;\r\n\t\r\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports) {\n\n\t/**\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    module.exports = {\r\n\t        BO_NODE_WIDTH: 180,    //BO矩形宽度\r\n\t        BO_NODE_DEFAULT_HEIGHT: 60,\t//BO矩形默认高度，即只有BO名字的情况\r\n\t        BO_NODE_OFFSET_X: 90, //BO矩形的水平偏移量=矩形宽度的一般\r\n\t        BO_NODE_OFFSET_Y: 50, //BO矩形的垂直偏移量\r\n\t\r\n\t        BO_NAME_FONT: 'bold 18px Arial', //'normal 16px verdana',    //BO名字文本样式,\r\n\t        BO_NAME_PADDING_TOP: 10,   //BO名字与矩形上边框的距离\r\n\t        BO_NAME_PADDING_BOTTOM: 15,   //BO名字与下一个控件（事件决策或者横线）的距离\r\n\t\r\n\t        BO_EVENT_HEIGHT: 20,   //BO事件决策多边形高度\r\n\t        BO_EVENT_WIDTH: 140,   //BO事件决策多边形宽度\r\n\t        BO_EVENT_FONT: 'normal 14px Arial',  //BO事件决策名字文本样式\r\n\t\r\n\t        BO_ATTR_FONT: 'normal 14px Arial',   //BO属性名字文本样式\r\n\t        BO_ATTR_PADDING_TOP: 5,   //BO属性名字与矩形上边框的距离\r\n\t        BO_ATTR_PADDING_BOTTOM: 5,   //BO属性名字与下一个控件（事件决策或者横线）的距离\r\n\t        BO_ATTR_PADDING_LEFT: 5,   //BO属性名字与矩形左边框的距离\r\n\t        BO_ATTR_DATA_TYPE_PADDING_RIGHT: 5, //BO属性数据类型与矩形右边框的距离\r\n\t        BO_ATTR_EVENT_WIDTH: 135,   //BO属性事件决策多边形宽度\r\n\t\r\n\t        LINE_DASH: 10,  //虚线\r\n\t        RELATION_OFFSET: 40,   //关联关系的初始偏移量，即第一段折线宽度\r\n\t        RELATION_ARROW_WIDTH: 10,  //关联关系三角箭头水平宽度\r\n\t        RELATION_ARROW_HEIGHT: 5,  //关联关系三角箭头垂直高度的一半\r\n\t        RELATION_TEXT_OFFSET_X: 10, //关联关系文字说明水平偏移量\r\n\t        RELATION_TEXT_OFFSET_Y: 5 //关联关系文字说明垂直偏移量\r\n\t    };\r\n\t\r\n\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * BO名字\r\n\t * @module fish-topo-bo/node/BoName\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(43);\r\n\t    var graphic = __webpack_require__(45);\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     * @param {String} text, BO名字\r\n\t     * @param {{x: number, y: number}} startPos, 起始位置\r\n\t     * @returns {zrender/graphic/Text}\r\n\t     * @constructor\r\n\t     */\r\n\t    function BoName(text, startPos) {\r\n\t        var x = startPos.x,\r\n\t            y = startPos.y + Const.BO_NAME_PADDING_TOP, //文字到矩形上边框的距离 padding-top=10\r\n\t\r\n\t            shape = new graphic.Text({\r\n\t                style: {\r\n\t                    text: text,\r\n\t                    textFont: Const.BO_NAME_FONT,\r\n\t                    textAlign: 'left',  //靠左开始，便于计算位置\r\n\t                    textBaseline: 'top'\r\n\t                },\r\n\t\r\n\t                position: [x, y]\r\n\t            });\r\n\t\r\n\t        //文字居中显示，重新计算文本水平起始位置 = 矩形水平起始位置 + (BO矩形宽度 - 文本宽度)/2\r\n\t        shape.position[0] += (Const.BO_NODE_WIDTH - shape.getBoundingRect().width) / 2;\r\n\t\r\n\t        //重新设置BO名字图形高度 = 文本高度 + padding-top + padding-bottom\r\n\t        shape.getBoundingRect().height += Const.BO_NAME_PADDING_TOP + Const.BO_NAME_PADDING_BOTTOM;\r\n\t\r\n\t        return shape;\r\n\t    }\r\n\t\r\n\t    module.exports = BoName;\r\n\t\r\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(6);\r\n\t\r\n\t    var pathTool = __webpack_require__(46);\r\n\t    var round = Math.round;\r\n\t    var Path = __webpack_require__(47);\r\n\t    var colorTool = __webpack_require__(20);\r\n\t    var matrix = __webpack_require__(15);\r\n\t    var vector = __webpack_require__(8);\r\n\t    var Gradient = __webpack_require__(59);\r\n\t    var Draggable = __webpack_require__(9);\r\n\t\r\n\t    var graphic = {};\r\n\t    graphic.Util = zrUtil;\r\n\t    graphic.Group = __webpack_require__(12);\r\n\t\r\n\t    graphic.Image = __webpack_require__(31);\r\n\t\r\n\t    graphic.Text = __webpack_require__(60);\r\n\t\r\n\t    graphic.textContain = __webpack_require__(35);\r\n\t\r\n\t    graphic.Circle = __webpack_require__(61);\r\n\t\r\n\t    graphic.Sector = __webpack_require__(62);\r\n\t\r\n\t    graphic.Ring = __webpack_require__(64);\r\n\t\r\n\t    graphic.Polygon = __webpack_require__(65);\r\n\t\r\n\t    graphic.Polyline = __webpack_require__(69);\r\n\t\r\n\t    graphic.Rect = __webpack_require__(70);\r\n\t\r\n\t    graphic.Line = __webpack_require__(71);\r\n\t\r\n\t    graphic.BezierCurve = __webpack_require__(72);\r\n\t\r\n\t    graphic.Arc = __webpack_require__(73);\r\n\t\r\n\t    graphic.LinearGradient = __webpack_require__(74);\r\n\t\r\n\t    graphic.RadialGradient = __webpack_require__(75);\r\n\t\r\n\t    graphic.BoundingRect = __webpack_require__(24);\r\n\t    graphic.States = __webpack_require__(76);\r\n\t    /**\r\n\t     * Extend shape with parameters\r\n\t     */\r\n\t    graphic.extendShape = function (opts) {\r\n\t        return Path.extend(opts);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Extend path\r\n\t     */\r\n\t    graphic.extendPath = function (pathData, opts) {\r\n\t        return pathTool.extendFromString(pathData, opts);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Create a path element from path data string\r\n\t     * @param {string} pathData\r\n\t     * @param {Object} opts\r\n\t     * @param {module:zrender/core/BoundingRect} rect\r\n\t     * @param {string} [layout=cover] 'center' or 'cover'\r\n\t     */\r\n\t    graphic.makePath = function (pathData, opts, rect, layout) {\r\n\t        var path = pathTool.createFromString(pathData, opts);\r\n\t        Draggable.call(path);\r\n\t        var boundingRect = path.getBoundingRect();\r\n\t        if (rect) {\r\n\t            var aspect = boundingRect.width / boundingRect.height;\r\n\t\r\n\t            if (layout === 'center') {\r\n\t                // Set rect to center, keep width / height ratio.\r\n\t                var width = rect.height * aspect;\r\n\t                var height;\r\n\t                if (width <= rect.width) {\r\n\t                    height = rect.height;\r\n\t                }\r\n\t                else {\r\n\t                    width = rect.width;\r\n\t                    height = width / aspect;\r\n\t                }\r\n\t                var cx = rect.x + rect.width / 2;\r\n\t                var cy = rect.y + rect.height / 2;\r\n\t\r\n\t                rect.x = cx - width / 2;\r\n\t                rect.y = cy - height / 2;\r\n\t                rect.width = width;\r\n\t                rect.height = height;\r\n\t            }\r\n\t\r\n\t            this.resizePath(path, rect);\r\n\t        }\r\n\t\r\n\t        zrUtil.inherits(path, Draggable);\r\n\t        return path;\r\n\t    };\r\n\t\r\n\t    graphic.mergePath = pathTool.mergePath;\r\n\t\r\n\t    /**\r\n\t     * Resize a path to fit the rect\r\n\t     * @param {module:zrender/graphic/Path} path\r\n\t     * @param {Object} rect\r\n\t     */\r\n\t    graphic.resizePath = function (path, rect) {\r\n\t        if (!path.applyTransform) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var pathRect = path.getBoundingRect();\r\n\t\r\n\t        var m = pathRect.calculateTransform(rect);\r\n\t\r\n\t        path.applyTransform(m);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize line for canvas\r\n\t     *\r\n\t     * @param {Object} param\r\n\t     * @param {Object} [param.shape]\r\n\t     * @param {number} [param.shape.x1]\r\n\t     * @param {number} [param.shape.y1]\r\n\t     * @param {number} [param.shape.x2]\r\n\t     * @param {number} [param.shape.y2]\r\n\t     * @param {Object} [param.style]\r\n\t     * @param {number} [param.style.lineWidth]\r\n\t     * @return {Object} Modified param\r\n\t     */\r\n\t    graphic.subPixelOptimizeLine = function (param) {\r\n\t        var subPixelOptimize = graphic.subPixelOptimize;\r\n\t        var shape = param.shape;\r\n\t        var lineWidth = param.style.lineWidth;\r\n\t\r\n\t        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\r\n\t            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\r\n\t        }\r\n\t        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\r\n\t            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\r\n\t        }\r\n\t        return param;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize rect for canvas\r\n\t     *\r\n\t     * @param {Object} param\r\n\t     * @param {Object} [param.shape]\r\n\t     * @param {number} [param.shape.x]\r\n\t     * @param {number} [param.shape.y]\r\n\t     * @param {number} [param.shape.width]\r\n\t     * @param {number} [param.shape.height]\r\n\t     * @param {Object} [param.style]\r\n\t     * @param {number} [param.style.lineWidth]\r\n\t     * @return {Object} Modified param\r\n\t     */\r\n\t    graphic.subPixelOptimizeRect = function (param) {\r\n\t        var subPixelOptimize = graphic.subPixelOptimize;\r\n\t        var shape = param.shape;\r\n\t        var lineWidth = param.style.lineWidth;\r\n\t        var originX = shape.x;\r\n\t        var originY = shape.y;\r\n\t        var originWidth = shape.width;\r\n\t        var originHeight = shape.height;\r\n\t        shape.x = subPixelOptimize(shape.x, lineWidth, true);\r\n\t        shape.y = subPixelOptimize(shape.y, lineWidth, true);\r\n\t        shape.width = Math.max(\r\n\t            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\r\n\t            originWidth === 0 ? 0 : 1\r\n\t        );\r\n\t        shape.height = Math.max(\r\n\t            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\r\n\t            originHeight === 0 ? 0 : 1\r\n\t        );\r\n\t        return param;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize for canvas\r\n\t     *\r\n\t     * @param {number} position Coordinate, such as x, y\r\n\t     * @param {number} lineWidth Should be nonnegative integer.\r\n\t     * @param {boolean=} positiveOrNegative Default false (negative).\r\n\t     * @return {number} Optimized position.\r\n\t     */\r\n\t    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\r\n\t        // Assure that (position + lineWidth / 2) is near integer edge,\r\n\t        // otherwise line will be fuzzy in canvas.\r\n\t        var doubledPosition = round(position * 2);\r\n\t        return (doubledPosition + round(lineWidth)) % 2 === 0\r\n\t            ? doubledPosition / 2\r\n\t            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    function doSingleEnterHover(el) {\r\n\t        if (el.__isHover) {\r\n\t            return;\r\n\t        }\r\n\t        if (el.__hoverStlDirty) {\r\n\t            var stroke = el.style.stroke;\r\n\t            var fill = el.style.fill;\r\n\t\r\n\t            // Create hoverStyle on mouseover\r\n\t            var hoverStyle = el.__hoverStl;\r\n\t            var lift = colorTool.lift;\r\n\t            hoverStyle.fill = hoverStyle.fill\r\n\t                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));\r\n\t            hoverStyle.stroke = hoverStyle.stroke\r\n\t                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));\r\n\t\r\n\t            var normalStyle = {};\r\n\t            for (var name in hoverStyle) {\r\n\t                if (hoverStyle.hasOwnProperty(name)) {\r\n\t                    normalStyle[name] = el.style[name];\r\n\t                }\r\n\t            }\r\n\t\r\n\t            el.__normalStl = normalStyle;\r\n\t\r\n\t            el.__hoverStlDirty = false;\r\n\t        }\r\n\t        el.setStyle(el.__hoverStl);\r\n\t        el.z2 += 1;\r\n\t\r\n\t        el.__isHover = true;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function doSingleLeaveHover(el) {\r\n\t        if (!el.__isHover) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var normalStl = el.__normalStl;\r\n\t        normalStl && el.setStyle(normalStl);\r\n\t        el.z2 -= 1;\r\n\t\r\n\t        el.__isHover = false;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function doEnterHover(el) {\r\n\t        (el.type === 'group' || el.type === 'GroupNode')\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    doSingleEnterHover(child);\r\n\t                }\r\n\t            })\r\n\t            : doSingleEnterHover(el);\r\n\t    }\r\n\t    graphic.doEnterHover = doEnterHover;\r\n\t    function doLeaveHover(el) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    doSingleLeaveHover(child);\r\n\t                }\r\n\t            })\r\n\t            : doSingleLeaveHover(el);\r\n\t    }\r\n\t    graphic.doLeaveHover = doLeaveHover;\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function setElementHoverStl(el, hoverStl) {\r\n\t        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\r\n\t        // Often used when item group has a label element and it's hoverStyle is different\r\n\t        el.__hoverStl = el.hoverStyle || hoverStl || {};\r\n\t        el.__hoverStlDirty = true;\r\n\t    }\r\n\t    graphic.setElementHoverStl = setElementHoverStl;\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function onElementMouseOver() {\r\n\t        // Only if element is not in emphasis status\r\n\t        !this.__isEmphasis && doEnterHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function onElementMouseOut() {\r\n\t        // Only if element is not in emphasis status\r\n\t        !this.__isEmphasis && doLeaveHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function enterEmphasis() {\r\n\t        this.__isEmphasis = true;\r\n\t        doEnterHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function leaveEmphasis() {\r\n\t        this.__isEmphasis = false;\r\n\t        doLeaveHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Set hover style of element\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} [hoverStyle]\r\n\t     */\r\n\t    graphic.setHoverStyle = function (el, hoverStyle) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    setElementHoverStl(child, hoverStyle);\r\n\t                }\r\n\t            })\r\n\t            : setElementHoverStl(el, hoverStyle);\r\n\t        // Remove previous bound handlers\r\n\t        el.on('mouseover', onElementMouseOver)\r\n\t          .on('mouseout', onElementMouseOut);\r\n\t\r\n\t        // Emphasis, normal can be triggered manually\r\n\t        el.on('emphasis', enterEmphasis)\r\n\t          .on('normal', leaveEmphasis);\r\n\t    };\r\n\t\r\n\t    graphic.setNormalStyle = function(el, options) {\r\n\t        if (el.__normalStl) {\r\n\t            for (var name in options) {\r\n\t                if (el.__normalStl.hasOwnProperty(name)) {\r\n\t                    el.__normalStl[name] = options[name];\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Set text option in the style\r\n\t     * @param {Object} textStyle\r\n\t     * @param {module:echarts/model/Model} labelModel\r\n\t     * @param {string} color\r\n\t     */\r\n\t    graphic.setText = function (textStyle, labelModel, color) {\r\n\t        var labelPosition = labelModel.getShallow('position') || 'inside';\r\n\t        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\r\n\t        var textStyleModel = labelModel.getModel('textStyle');\r\n\t        zrUtil.extend(textStyle, {\r\n\t            textDistance: labelModel.getShallow('distance') || 5,\r\n\t            textFont: textStyleModel.getFont(),\r\n\t            textPosition: labelPosition,\r\n\t            textFill: textStyleModel.getTextColor() || labelColor\r\n\t        });\r\n\t    };\r\n\t\r\n\t    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {\r\n\t        var postfix = isUpdate ? 'Update' : '';\r\n\t        var duration = animatableModel\r\n\t            && animatableModel.getShallow('animationDuration' + postfix);\r\n\t        var animationEasing = animatableModel\r\n\t            && animatableModel.getShallow('animationEasing' + postfix);\r\n\t\r\n\t        animatableModel && animatableModel.getShallow('animation')\r\n\t            ? el.animateTo(props, duration, animationEasing, cb)\r\n\t            : (el.attr(props), cb && cb());\r\n\t    }\r\n\t    /**\r\n\t     * Update graphic element properties with or without animation according to the configuration in series\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} props\r\n\t     * @param {module:echarts/model/Model} [animatableModel]\r\n\t     * @param {Function} cb\r\n\t     */\r\n\t    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);\r\n\t\r\n\t    /**\r\n\t     * Init graphic element properties with or without animation according to the configuration in series\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} props\r\n\t     * @param {module:echarts/model/Model} [animatableModel]\r\n\t     * @param {Function} cb\r\n\t     */\r\n\t    graphic.initProps = zrUtil.curry(animateOrSetProps, false);\r\n\t\r\n\t    /**\r\n\t     * Get transform matrix of target (param target),\r\n\t     * in coordinate of its ancestor (param ancestor)\r\n\t     *\r\n\t     * @param {module:zrender/mixin/Transformable} target\r\n\t     * @param {module:zrender/mixin/Transformable} ancestor\r\n\t     */\r\n\t    graphic.getTransform = function (target, ancestor) {\r\n\t        var mat = matrix.identity([]);\r\n\t\r\n\t        while (target && target !== ancestor) {\r\n\t            matrix.mul(mat, target.getLocalTransform(), mat);\r\n\t            target = target.parent;\r\n\t        }\r\n\t\r\n\t        return mat;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Apply transform to an vertex.\r\n\t     * @param {Array.<number>} vertex [x, y]\r\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n\t     * @param {boolean=} invert Whether use invert matrix.\r\n\t     * @return {Array.<number>} [x, y]\r\n\t     */\r\n\t    graphic.applyTransform = function (vertex, transform, invert) {\r\n\t        if (invert) {\r\n\t            transform = matrix.invert([], transform);\r\n\t        }\r\n\t        return vector.applyTransform([], vertex, transform);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @param {string} direction 'left' 'right' 'top' 'bottom'\r\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n\t     * @param {boolean=} invert Whether use invert matrix.\r\n\t     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\r\n\t     */\r\n\t    graphic.transformDirection = function (direction, transform, invert) {\r\n\t\r\n\t        // Pick a base, ensure that transform result will not be (0, 0).\r\n\t        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\r\n\t            ? 1 : Math.abs(2 * transform[4] / transform[0]);\r\n\t        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\r\n\t            ? 1 : Math.abs(2 * transform[4] / transform[2]);\r\n\t\r\n\t        var vertex = [\r\n\t            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\r\n\t            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\r\n\t        ];\r\n\t\r\n\t        vertex = graphic.applyTransform(vertex, transform, invert);\r\n\t\r\n\t        return Math.abs(vertex[0]) > Math.abs(vertex[1])\r\n\t            ? (vertex[0] > 0 ? 'right' : 'left')\r\n\t            : (vertex[1] > 0 ? 'bottom' : 'top');\r\n\t    };\r\n\t\r\n\t    module.exports = graphic;\r\n\t\r\n\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(47);\n\t\n\tvar PathProxy = __webpack_require__(48);\n\t\n\tvar transformPath = __webpack_require__(58);\n\t\n\t// command chars\n\tvar cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];\n\tvar mathSqrt = Math.sqrt;\n\tvar mathSin = Math.sin;\n\tvar mathCos = Math.cos;\n\tvar PI = Math.PI;\n\t\n\tvar vMag = function (v) {\n\t  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n\t};\n\t\n\tvar vRatio = function (u, v) {\n\t  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n\t};\n\t\n\tvar vAngle = function (u, v) {\n\t  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n\t};\n\t\n\tfunction processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n\t  var psi = psiDeg * (PI / 180.0);\n\t  var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;\n\t  var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;\n\t  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n\t\n\t  if (lambda > 1) {\n\t    rx *= mathSqrt(lambda);\n\t    ry *= mathSqrt(lambda);\n\t  }\n\t\n\t  var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;\n\t  var cxp = f * rx * yp / ry;\n\t  var cyp = f * -ry * xp / rx;\n\t  var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;\n\t  var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;\n\t  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);\n\t  var u = [(xp - cxp) / rx, (yp - cyp) / ry];\n\t  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\n\t  var dTheta = vAngle(u, v);\n\t\n\t  if (vRatio(u, v) <= -1) {\n\t    dTheta = PI;\n\t  }\n\t\n\t  if (vRatio(u, v) >= 1) {\n\t    dTheta = 0;\n\t  }\n\t\n\t  if (fs === 0 && dTheta > 0) {\n\t    dTheta = dTheta - 2 * PI;\n\t  }\n\t\n\t  if (fs === 1 && dTheta < 0) {\n\t    dTheta = dTheta + 2 * PI;\n\t  }\n\t\n\t  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n\t}\n\t\n\tfunction createPathProxyFromString(data) {\n\t  if (!data) {\n\t    return [];\n\t  } // command string\n\t\n\t\n\t  var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');\n\t  var n; // create pipes so that we can split the data\n\t\n\t  for (n = 0; n < cc.length; n++) {\n\t    cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n\t  } // create array\n\t\n\t\n\t  var arr = cs.split('|'); // init context point\n\t\n\t  var cpx = 0;\n\t  var cpy = 0;\n\t  var path = new PathProxy();\n\t  var CMD = PathProxy.CMD;\n\t  var prevCmd;\n\t\n\t  for (n = 1; n < arr.length; n++) {\n\t    var str = arr[n];\n\t    var c = str.charAt(0);\n\t    var off = 0;\n\t    var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n\t    var cmd;\n\t\n\t    if (p.length > 0 && p[0] === '') {\n\t      p.shift();\n\t    }\n\t\n\t    for (var i = 0; i < p.length; i++) {\n\t      p[i] = parseFloat(p[i]);\n\t    }\n\t\n\t    while (off < p.length && !isNaN(p[off])) {\n\t      if (isNaN(p[0])) {\n\t        break;\n\t      }\n\t\n\t      var ctlPtx;\n\t      var ctlPty;\n\t      var rx;\n\t      var ry;\n\t      var psi;\n\t      var fa;\n\t      var fs;\n\t      var x1 = cpx;\n\t      var y1 = cpy; // convert l, H, h, V, and v to L\n\t\n\t      switch (c) {\n\t        case 'l':\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'L':\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'm':\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          cmd = CMD.M;\n\t          path.addData(cmd, cpx, cpy);\n\t          c = 'l';\n\t          break;\n\t\n\t        case 'M':\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          cmd = CMD.M;\n\t          path.addData(cmd, cpx, cpy);\n\t          c = 'L';\n\t          break;\n\t\n\t        case 'h':\n\t          cpx += p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'H':\n\t          cpx = p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'v':\n\t          cpy += p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'V':\n\t          cpy = p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'C':\n\t          cmd = CMD.C;\n\t          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);\n\t          cpx = p[off - 2];\n\t          cpy = p[off - 1];\n\t          break;\n\t\n\t        case 'c':\n\t          cmd = CMD.C;\n\t          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);\n\t          cpx += p[off - 2];\n\t          cpy += p[off - 1];\n\t          break;\n\t\n\t        case 'S':\n\t          ctlPtx = cpx;\n\t          ctlPty = cpy;\n\t          var len = path.len();\n\t          var pathData = path.data;\n\t\n\t          if (prevCmd === CMD.C) {\n\t            ctlPtx += cpx - pathData[len - 4];\n\t            ctlPty += cpy - pathData[len - 3];\n\t          }\n\t\n\t          cmd = CMD.C;\n\t          x1 = p[off++];\n\t          y1 = p[off++];\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t          break;\n\t\n\t        case 's':\n\t          ctlPtx = cpx;\n\t          ctlPty = cpy;\n\t          var len = path.len();\n\t          var pathData = path.data;\n\t\n\t          if (prevCmd === CMD.C) {\n\t            ctlPtx += cpx - pathData[len - 4];\n\t            ctlPty += cpy - pathData[len - 3];\n\t          }\n\t\n\t          cmd = CMD.C;\n\t          x1 = cpx + p[off++];\n\t          y1 = cpy + p[off++];\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t          break;\n\t\n\t        case 'Q':\n\t          x1 = p[off++];\n\t          y1 = p[off++];\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          cmd = CMD.Q;\n\t          path.addData(cmd, x1, y1, cpx, cpy);\n\t          break;\n\t\n\t        case 'q':\n\t          x1 = p[off++] + cpx;\n\t          y1 = p[off++] + cpy;\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          cmd = CMD.Q;\n\t          path.addData(cmd, x1, y1, cpx, cpy);\n\t          break;\n\t\n\t        case 'T':\n\t          ctlPtx = cpx;\n\t          ctlPty = cpy;\n\t          var len = path.len();\n\t          var pathData = path.data;\n\t\n\t          if (prevCmd === CMD.Q) {\n\t            ctlPtx += cpx - pathData[len - 4];\n\t            ctlPty += cpy - pathData[len - 3];\n\t          }\n\t\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          cmd = CMD.Q;\n\t          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t          break;\n\t\n\t        case 't':\n\t          ctlPtx = cpx;\n\t          ctlPty = cpy;\n\t          var len = path.len();\n\t          var pathData = path.data;\n\t\n\t          if (prevCmd === CMD.Q) {\n\t            ctlPtx += cpx - pathData[len - 4];\n\t            ctlPty += cpy - pathData[len - 3];\n\t          }\n\t\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          cmd = CMD.Q;\n\t          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t          break;\n\t\n\t        case 'A':\n\t          rx = p[off++];\n\t          ry = p[off++];\n\t          psi = p[off++];\n\t          fa = p[off++];\n\t          fs = p[off++];\n\t          x1 = cpx, y1 = cpy;\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          cmd = CMD.A;\n\t          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n\t          break;\n\t\n\t        case 'a':\n\t          rx = p[off++];\n\t          ry = p[off++];\n\t          psi = p[off++];\n\t          fa = p[off++];\n\t          fs = p[off++];\n\t          x1 = cpx, y1 = cpy;\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          cmd = CMD.A;\n\t          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n\t          break;\n\t      }\n\t    }\n\t\n\t    if (c === 'z' || c === 'Z') {\n\t      cmd = CMD.Z;\n\t      path.addData(cmd);\n\t    }\n\t\n\t    prevCmd = cmd;\n\t  }\n\t\n\t  path.toStatic();\n\t  return path;\n\t} // TODO Optimize double memory cost problem\n\t\n\t\n\tfunction createPathOptions(str, opts) {\n\t  var pathProxy = createPathProxyFromString(str);\n\t  opts = opts || {};\n\t\n\t  opts.buildPath = function (path) {\n\t    if (path.setData) {\n\t      path.setData(pathProxy.data); // Svg and vml renderer don't have context\n\t\n\t      var ctx = path.getContext();\n\t\n\t      if (ctx) {\n\t        path.rebuildPath(ctx);\n\t      }\n\t    } else {\n\t      var ctx = path;\n\t      pathProxy.rebuildPath(ctx);\n\t    }\n\t  };\n\t\n\t  opts.applyTransform = function (m) {\n\t    transformPath(pathProxy, m);\n\t    this.dirty(true);\n\t  };\n\t\n\t  return opts;\n\t}\n\t/**\n\t * Create a Path object from path string data\n\t * http://www.w3.org/TR/SVG/paths.html#PathData\n\t * @param  {Object} opts Other options\n\t */\n\t\n\t\n\tfunction createFromString(str, opts) {\n\t  return new Path(createPathOptions(str, opts));\n\t}\n\t/**\n\t * Create a Path class from path string data\n\t * @param  {string} str\n\t * @param  {Object} opts Other options\n\t */\n\t\n\t\n\tfunction extendFromString(str, opts) {\n\t  return Path.extend(createPathOptions(str, opts));\n\t}\n\t/**\n\t * Merge multiple paths\n\t */\n\t// TODO Apply transform\n\t// TODO stroke dash\n\t// TODO Optimize double memory cost problem\n\t\n\t\n\tfunction mergePath(pathEls, opts) {\n\t  var pathList = [];\n\t  var len = pathEls.length;\n\t\n\t  for (var i = 0; i < len; i++) {\n\t    var pathEl = pathEls[i];\n\t\n\t    if (!pathEl.path) {\n\t      pathEl.createPathProxy();\n\t    }\n\t\n\t    if (pathEl.__dirtyPath) {\n\t      pathEl.buildPath(pathEl.path, pathEl.shape, true);\n\t    }\n\t\n\t    pathList.push(pathEl.path);\n\t  }\n\t\n\t  var pathBundle = new Path(opts); // Need path proxy.\n\t\n\t  pathBundle.createPathProxy();\n\t\n\t  pathBundle.buildPath = function (path) {\n\t    path.appendPath(pathList); // Svg and vml renderer don't have context\n\t\n\t    var ctx = path.getContext();\n\t\n\t    if (ctx) {\n\t      path.rebuildPath(ctx);\n\t    }\n\t  };\n\t\n\t  return pathBundle;\n\t}\n\t\n\texports.createFromString = createFromString;\n\texports.extendFromString = extendFromString;\n\texports.mergePath = mergePath;\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Displayable = __webpack_require__(32);\n\t\n\tvar zrUtil = __webpack_require__(6);\n\t\n\tvar PathProxy = __webpack_require__(48);\n\t\n\tvar pathContain = __webpack_require__(51);\n\t\n\tvar Pattern = __webpack_require__(29);\n\t\n\tvar getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\tvar abs = Math.abs;\n\tvar pathProxyForDraw = new PathProxy(true);\n\t/**\n\t * @alias module:zrender/graphic/Path\n\t * @extends module:zrender/graphic/Displayable\n\t * @constructor\n\t * @param {Object} opts\n\t */\n\t\n\tfunction Path(opts) {\n\t  Displayable.call(this, opts);\n\t  /**\n\t   * @type {module:zrender/core/PathProxy}\n\t   * @readOnly\n\t   */\n\t\n\t  this.path = null;\n\t}\n\t\n\tPath.prototype = {\n\t  constructor: Path,\n\t  type: 'path',\n\t  __dirtyPath: true,\n\t  strokeContainThreshold: 5,\n\t  brush: function (ctx, prevEl) {\n\t    var style = this.style;\n\t    var path = this.path || pathProxyForDraw;\n\t    var hasStroke = style.hasStroke();\n\t    var hasFill = style.hasFill();\n\t    var fill = style.fill;\n\t    var stroke = style.stroke;\n\t    var hasFillGradient = hasFill && !!fill.colorStops;\n\t    var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n\t    var hasFillPattern = hasFill && !!fill.image;\n\t    var hasStrokePattern = hasStroke && !!stroke.image;\n\t    style.bind(ctx, this, prevEl);\n\t    this.setTransform(ctx);\n\t\n\t    if (this.__dirty) {\n\t      var rect; // Update gradient because bounding rect may changed\n\t\n\t      if (hasFillGradient) {\n\t        rect = rect || this.getBoundingRect();\n\t        this._fillGradient = style.getGradient(ctx, fill, rect);\n\t      }\n\t\n\t      if (hasStrokeGradient) {\n\t        rect = rect || this.getBoundingRect();\n\t        this._strokeGradient = style.getGradient(ctx, stroke, rect);\n\t      }\n\t    } // Use the gradient or pattern\n\t\n\t\n\t    if (hasFillGradient) {\n\t      // PENDING If may have affect the state\n\t      ctx.fillStyle = this._fillGradient;\n\t    } else if (hasFillPattern) {\n\t      ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n\t    }\n\t\n\t    if (hasStrokeGradient) {\n\t      ctx.strokeStyle = this._strokeGradient;\n\t    } else if (hasStrokePattern) {\n\t      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n\t    }\n\t\n\t    var lineDash = style.lineDash;\n\t    var lineDashOffset = style.lineDashOffset;\n\t    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy\n\t\n\t    var scale = this.getGlobalScale();\n\t    path.setScale(scale[0], scale[1]); // Proxy context\n\t    // Rebuild path in following 2 cases\n\t    // 1. Path is dirty\n\t    // 2. Path needs javascript implemented lineDash stroking.\n\t    //    In this case, lineDash information will not be saved in PathProxy\n\t\n\t    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n\t      path.beginPath(ctx); // Setting line dash before build path\n\t\n\t      if (lineDash && !ctxLineDash) {\n\t        path.setLineDash(lineDash);\n\t        path.setLineDashOffset(lineDashOffset);\n\t      }\n\t\n\t      this.buildPath(path, this.shape, false); // Clear path dirty flag\n\t\n\t      if (this.path) {\n\t        this.__dirtyPath = false;\n\t      }\n\t    } else {\n\t      // Replay path building\n\t      ctx.beginPath();\n\t      this.path.rebuildPath(ctx);\n\t    }\n\t\n\t    hasFill && path.fill(ctx);\n\t\n\t    if (lineDash && ctxLineDash) {\n\t      ctx.setLineDash(lineDash);\n\t      ctx.lineDashOffset = lineDashOffset;\n\t    }\n\t\n\t    hasStroke && path.stroke(ctx);\n\t\n\t    if (lineDash && ctxLineDash) {\n\t      // PENDING\n\t      // Remove lineDash\n\t      ctx.setLineDash([]);\n\t    }\n\t\n\t    this.restoreTransform(ctx); // Draw rect text\n\t\n\t    if (style.text != null) {\n\t      this.drawRectText(ctx, this.getBoundingRect());\n\t    }\n\t  },\n\t  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n\t  // Like in circle\n\t  buildPath: function (ctx, shapeCfg, inBundle) {},\n\t  createPathProxy: function () {\n\t    this.path = new PathProxy();\n\t  },\n\t  getBoundingRect: function () {\n\t    var rect = this._rect;\n\t    var style = this.style;\n\t    var needsUpdateRect = !rect;\n\t\n\t    if (needsUpdateRect) {\n\t      var path = this.path;\n\t\n\t      if (!path) {\n\t        // Create path on demand.\n\t        path = this.path = new PathProxy();\n\t      }\n\t\n\t      if (this.__dirtyPath) {\n\t        path.beginPath();\n\t        this.buildPath(path, this.shape, false);\n\t      }\n\t\n\t      rect = path.getBoundingRect();\n\t    }\n\t\n\t    this._rect = rect;\n\t\n\t    if (style.hasStroke()) {\n\t      // Needs update rect with stroke lineWidth when\n\t      // 1. Element changes scale or lineWidth\n\t      // 2. Shape is changed\n\t      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\t\n\t      if (this.__dirty || needsUpdateRect) {\n\t        rectWithStroke.copy(rect); // FIXME Must after updateTransform\n\t\n\t        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical\n\t\n\t        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill\n\t\n\t        if (!style.hasFill()) {\n\t          w = Math.max(w, this.strokeContainThreshold || 4);\n\t        } // Consider line width\n\t        // Line scale can't be 0;\n\t\n\t\n\t        if (lineScale > 1e-10) {\n\t          rectWithStroke.width += w / lineScale;\n\t          rectWithStroke.height += w / lineScale;\n\t          rectWithStroke.x -= w / lineScale / 2;\n\t          rectWithStroke.y -= w / lineScale / 2;\n\t        }\n\t      } // Return rect with stroke\n\t\n\t\n\t      return rectWithStroke;\n\t    }\n\t\n\t    return rect;\n\t  },\n\t  contain: function (x, y) {\n\t    var localPos = this.transformCoordToLocal(x, y);\n\t    var rect = this.getBoundingRect();\n\t    var style = this.style;\n\t    x = localPos[0];\n\t    y = localPos[1];\n\t\n\t    if (rect.contain(x, y)) {\n\t      var pathData = this.path.data;\n\t\n\t      if (style.hasStroke()) {\n\t        var lineWidth = style.lineWidth;\n\t        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;\n\t\n\t        if (lineScale > 1e-10) {\n\t          // Only add extra hover lineWidth when there are no fill\n\t          if (!style.hasFill()) {\n\t            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n\t          }\n\t\n\t          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n\t            return true;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (style.hasFill()) {\n\t        return pathContain.contain(pathData, x, y);\n\t      }\n\t    }\n\t\n\t    return false;\n\t  },\n\t\n\t  /**\n\t   * @param  {boolean} dirtyPath\n\t   */\n\t  dirty: function (dirtyPath) {\n\t    if (dirtyPath == null) {\n\t      dirtyPath = true;\n\t    } // Only mark dirty, not mark clean\n\t\n\t\n\t    if (dirtyPath) {\n\t      this.__dirtyPath = dirtyPath;\n\t      this._rect = null;\n\t    }\n\t\n\t    this.__dirty = true;\n\t    this.__zr && this.__zr.refresh(); // Used as a clipping path\n\t\n\t    if (this.__clipTarget) {\n\t      this.__clipTarget.dirty();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Alias for animate('shape')\n\t   * @param {boolean} loop\n\t   */\n\t  animateShape: function (loop) {\n\t    return this.animate('shape', loop);\n\t  },\n\t  // Overwrite attrKV\n\t  attrKV: function (key, value) {\n\t    // FIXME\n\t    if (key === 'shape') {\n\t      this.setShape(value);\n\t      this.__dirtyPath = true;\n\t      this._rect = null;\n\t    } else {\n\t      Displayable.prototype.attrKV.call(this, key, value);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @param {Object|string} key\n\t   * @param {*} value\n\t   */\n\t  setShape: function (key, value) {\n\t    var shape = this.shape; // Path from string may not have shape\n\t\n\t    if (shape) {\n\t      if (zrUtil.isObject(key)) {\n\t        for (var name in key) {\n\t          if (key.hasOwnProperty(name)) {\n\t            shape[name] = key[name];\n\t          }\n\t        }\n\t      } else {\n\t        shape[key] = value;\n\t      }\n\t\n\t      this.dirty(true);\n\t    }\n\t\n\t    return this;\n\t  },\n\t  getLineScale: function () {\n\t    var m = this.transform; // Get the line scale.\n\t    // Determinant of `m` means how much the area is enlarged by the\n\t    // transformation. So its square root can be used as a scale factor\n\t    // for width.\n\t\n\t    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n\t  }\n\t};\n\t/**\n\t * 扩展一个 Path element, 比如星形，圆等。\n\t * Extend a path element\n\t * @param {Object} props\n\t * @param {string} props.type Path type\n\t * @param {Function} props.init Initialize\n\t * @param {Function} props.buildPath Overwrite buildPath method\n\t * @param {Object} [props.style] Extended default style config\n\t * @param {Object} [props.shape] Extended default shape config\n\t */\n\t\n\tPath.extend = function (defaults) {\n\t  var Sub = function (opts) {\n\t    Path.call(this, opts);\n\t\n\t    if (defaults.style) {\n\t      // Extend default style\n\t      this.style.extendFrom(defaults.style, false);\n\t    } // Extend default shape\n\t\n\t\n\t    var defaultShape = defaults.shape;\n\t\n\t    if (defaultShape) {\n\t      this.shape = this.shape || {};\n\t      var thisShape = this.shape;\n\t\n\t      for (var name in defaultShape) {\n\t        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n\t          thisShape[name] = defaultShape[name];\n\t        }\n\t      }\n\t    }\n\t\n\t    defaults.init && defaults.init.call(this, opts);\n\t  };\n\t\n\t  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象\n\t\n\t  for (var name in defaults) {\n\t    // Extending prototype values and methods\n\t    if (name !== 'style' && name !== 'shape') {\n\t      Sub.prototype[name] = defaults[name];\n\t    }\n\t  }\n\t\n\t  return Sub;\n\t};\n\t\n\tzrUtil.inherits(Path, Displayable);\n\tvar _default = Path;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar curve = __webpack_require__(49);\n\t\n\tvar vec2 = __webpack_require__(8);\n\t\n\tvar bbox = __webpack_require__(50);\n\t\n\tvar BoundingRect = __webpack_require__(24);\n\t\n\tvar _config = __webpack_require__(23);\n\t\n\tvar dpr = _config.devicePixelRatio;\n\t\n\t/**\n\t * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n\t * 可以用于 isInsidePath 判断以及获取boundingRect\n\t *\n\t * @module zrender/core/PathProxy\n\t * @author Yi Shen (http://www.github.com/pissang)\n\t */\n\t// TODO getTotalLength, getPointAtLength\n\tvar CMD = {\n\t  M: 1,\n\t  L: 2,\n\t  C: 3,\n\t  Q: 4,\n\t  A: 5,\n\t  Z: 6,\n\t  // Rect\n\t  R: 7\n\t}; // var CMD_MEM_SIZE = {\n\t//     M: 3,\n\t//     L: 3,\n\t//     C: 7,\n\t//     Q: 5,\n\t//     A: 9,\n\t//     R: 5,\n\t//     Z: 1\n\t// };\n\t\n\tvar min = [];\n\tvar max = [];\n\tvar min2 = [];\n\tvar max2 = [];\n\tvar mathMin = Math.min;\n\tvar mathMax = Math.max;\n\tvar mathCos = Math.cos;\n\tvar mathSin = Math.sin;\n\tvar mathSqrt = Math.sqrt;\n\tvar mathAbs = Math.abs;\n\tvar hasTypedArray = typeof Float32Array != 'undefined';\n\t/**\n\t * @alias module:zrender/core/PathProxy\n\t * @constructor\n\t */\n\t\n\tvar PathProxy = function (notSaveData) {\n\t  this._saveData = !(notSaveData || false);\n\t\n\t  if (this._saveData) {\n\t    /**\n\t     * Path data. Stored as flat array\n\t     * @type {Array.<Object>}\n\t     */\n\t    this.data = [];\n\t  }\n\t\n\t  this._ctx = null;\n\t};\n\t/**\n\t * 快速计算Path包围盒（并不是最小包围盒）\n\t * @return {Object}\n\t */\n\t\n\t\n\tPathProxy.prototype = {\n\t  constructor: PathProxy,\n\t  _xi: 0,\n\t  _yi: 0,\n\t  _x0: 0,\n\t  _y0: 0,\n\t  // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n\t  _ux: 0,\n\t  _uy: 0,\n\t  _len: 0,\n\t  _lineDash: null,\n\t  _dashOffset: 0,\n\t  _dashIdx: 0,\n\t  _dashSum: 0,\n\t\n\t  /**\n\t   * @readOnly\n\t   */\n\t  setScale: function (sx, sy) {\n\t    this._ux = mathAbs(1 / dpr / sx) || 0;\n\t    this._uy = mathAbs(1 / dpr / sy) || 0;\n\t  },\n\t  getContext: function () {\n\t    return this._ctx;\n\t  },\n\t\n\t  /**\n\t   * @param  {CanvasRenderingContext2D} ctx\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  beginPath: function (ctx) {\n\t    this._ctx = ctx;\n\t    ctx && ctx.beginPath();\n\t    ctx && (this.dpr = ctx.dpr); // Reset\n\t\n\t    if (this._saveData) {\n\t      this._len = 0;\n\t    }\n\t\n\t    if (this._lineDash) {\n\t      this._lineDash = null;\n\t      this._dashOffset = 0;\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param  {number} x\n\t   * @param  {number} y\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  moveTo: function (x, y) {\n\t    this.addData(CMD.M, x, y);\n\t    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n\t    // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n\t    // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n\t    // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n\t\n\t    this._x0 = x;\n\t    this._y0 = y;\n\t    this._xi = x;\n\t    this._yi = y;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param  {number} x\n\t   * @param  {number} y\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  lineTo: function (x, y) {\n\t    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment\n\t    || this._len < 5;\n\t    this.addData(CMD.L, x, y);\n\t\n\t    if (this._ctx && exceedUnit) {\n\t      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n\t    }\n\t\n\t    if (exceedUnit) {\n\t      this._xi = x;\n\t      this._yi = y;\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param  {number} x1\n\t   * @param  {number} y1\n\t   * @param  {number} x2\n\t   * @param  {number} y2\n\t   * @param  {number} x3\n\t   * @param  {number} y3\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n\t    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\t\n\t    if (this._ctx) {\n\t      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n\t    }\n\t\n\t    this._xi = x3;\n\t    this._yi = y3;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param  {number} x1\n\t   * @param  {number} y1\n\t   * @param  {number} x2\n\t   * @param  {number} y2\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  quadraticCurveTo: function (x1, y1, x2, y2) {\n\t    this.addData(CMD.Q, x1, y1, x2, y2);\n\t\n\t    if (this._ctx) {\n\t      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n\t    }\n\t\n\t    this._xi = x2;\n\t    this._yi = y2;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param  {number} cx\n\t   * @param  {number} cy\n\t   * @param  {number} r\n\t   * @param  {number} startAngle\n\t   * @param  {number} endAngle\n\t   * @param  {boolean} anticlockwise\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n\t    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);\n\t    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\t    this._xi = mathCos(endAngle) * r + cx;\n\t    this._yi = mathSin(endAngle) * r + cx;\n\t    return this;\n\t  },\n\t  // TODO\n\t  arcTo: function (x1, y1, x2, y2, radius) {\n\t    if (this._ctx) {\n\t      this._ctx.arcTo(x1, y1, x2, y2, radius);\n\t    }\n\t\n\t    return this;\n\t  },\n\t  // TODO\n\t  rect: function (x, y, w, h) {\n\t    this._ctx && this._ctx.rect(x, y, w, h);\n\t    this.addData(CMD.R, x, y, w, h);\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  closePath: function () {\n\t    this.addData(CMD.Z);\n\t    var ctx = this._ctx;\n\t    var x0 = this._x0;\n\t    var y0 = this._y0;\n\t\n\t    if (ctx) {\n\t      this._needsDash() && this._dashedLineTo(x0, y0);\n\t      ctx.closePath();\n\t    }\n\t\n\t    this._xi = x0;\n\t    this._yi = y0;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n\t   * stroke 同样\n\t   * @param {CanvasRenderingContext2D} ctx\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  fill: function (ctx) {\n\t    ctx && ctx.fill();\n\t    this.toStatic();\n\t  },\n\t\n\t  /**\n\t   * @param {CanvasRenderingContext2D} ctx\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  stroke: function (ctx) {\n\t    ctx && ctx.stroke();\n\t    this.toStatic();\n\t  },\n\t\n\t  /**\n\t   * 必须在其它绘制命令前调用\n\t   * Must be invoked before all other path drawing methods\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  setLineDash: function (lineDash) {\n\t    if (lineDash instanceof Array) {\n\t      this._lineDash = lineDash;\n\t      this._dashIdx = 0;\n\t      var lineDashSum = 0;\n\t\n\t      for (var i = 0; i < lineDash.length; i++) {\n\t        lineDashSum += lineDash[i];\n\t      }\n\t\n\t      this._dashSum = lineDashSum;\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 必须在其它绘制命令前调用\n\t   * Must be invoked before all other path drawing methods\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  setLineDashOffset: function (offset) {\n\t    this._dashOffset = offset;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   *\n\t   * @return {boolean}\n\t   */\n\t  len: function () {\n\t    return this._len;\n\t  },\n\t\n\t  /**\n\t   * 直接设置 Path 数据\n\t   */\n\t  setData: function (data) {\n\t    var len = data.length;\n\t\n\t    if (!(this.data && this.data.length == len) && hasTypedArray) {\n\t      this.data = new Float32Array(len);\n\t    }\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      this.data[i] = data[i];\n\t    }\n\t\n\t    this._len = len;\n\t  },\n\t\n\t  /**\n\t   * 添加子路径\n\t   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n\t   */\n\t  appendPath: function (path) {\n\t    if (!(path instanceof Array)) {\n\t      path = [path];\n\t    }\n\t\n\t    var len = path.length;\n\t    var appendSize = 0;\n\t    var offset = this._len;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      appendSize += path[i].len();\n\t    }\n\t\n\t    if (hasTypedArray && this.data instanceof Float32Array) {\n\t      this.data = new Float32Array(offset + appendSize);\n\t    }\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      var appendPathData = path[i].data;\n\t\n\t      for (var k = 0; k < appendPathData.length; k++) {\n\t        this.data[offset++] = appendPathData[k];\n\t      }\n\t    }\n\t\n\t    this._len = offset;\n\t  },\n\t\n\t  /**\n\t   * 填充 Path 数据。\n\t   * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n\t   */\n\t  addData: function (cmd) {\n\t    if (!this._saveData) {\n\t      return;\n\t    }\n\t\n\t    var data = this.data;\n\t\n\t    if (this._len + arguments.length > data.length) {\n\t      // 因为之前的数组已经转换成静态的 Float32Array\n\t      // 所以不够用时需要扩展一个新的动态数组\n\t      this._expandData();\n\t\n\t      data = this.data;\n\t    }\n\t\n\t    for (var i = 0; i < arguments.length; i++) {\n\t      data[this._len++] = arguments[i];\n\t    }\n\t\n\t    this._prevCmd = cmd;\n\t  },\n\t  _expandData: function () {\n\t    // Only if data is Float32Array\n\t    if (!(this.data instanceof Array)) {\n\t      var newData = [];\n\t\n\t      for (var i = 0; i < this._len; i++) {\n\t        newData[i] = this.data[i];\n\t      }\n\t\n\t      this.data = newData;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * If needs js implemented dashed line\n\t   * @return {boolean}\n\t   * @private\n\t   */\n\t  _needsDash: function () {\n\t    return this._lineDash;\n\t  },\n\t  _dashedLineTo: function (x1, y1) {\n\t    var dashSum = this._dashSum;\n\t    var offset = this._dashOffset;\n\t    var lineDash = this._lineDash;\n\t    var ctx = this._ctx;\n\t    var x0 = this._xi;\n\t    var y0 = this._yi;\n\t    var dx = x1 - x0;\n\t    var dy = y1 - y0;\n\t    var dist = mathSqrt(dx * dx + dy * dy);\n\t    var x = x0;\n\t    var y = y0;\n\t    var dash;\n\t    var nDash = lineDash.length;\n\t    var idx;\n\t    dx /= dist;\n\t    dy /= dist;\n\t\n\t    if (offset < 0) {\n\t      // Convert to positive offset\n\t      offset = dashSum + offset;\n\t    }\n\t\n\t    offset %= dashSum;\n\t    x -= offset * dx;\n\t    y -= offset * dy;\n\t\n\t    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n\t      idx = this._dashIdx;\n\t      dash = lineDash[idx];\n\t      x += dx * dash;\n\t      y += dy * dash;\n\t      this._dashIdx = (idx + 1) % nDash; // Skip positive offset\n\t\n\t      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n\t        continue;\n\t      }\n\t\n\t      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n\t    } // Offset for next lineTo\n\t\n\t\n\t    dx = x - x1;\n\t    dy = y - y1;\n\t    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t  },\n\t  // Not accurate dashed line to\n\t  _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n\t    var dashSum = this._dashSum;\n\t    var offset = this._dashOffset;\n\t    var lineDash = this._lineDash;\n\t    var ctx = this._ctx;\n\t    var x0 = this._xi;\n\t    var y0 = this._yi;\n\t    var t;\n\t    var dx;\n\t    var dy;\n\t    var cubicAt = curve.cubicAt;\n\t    var bezierLen = 0;\n\t    var idx = this._dashIdx;\n\t    var nDash = lineDash.length;\n\t    var x;\n\t    var y;\n\t    var tmpLen = 0;\n\t\n\t    if (offset < 0) {\n\t      // Convert to positive offset\n\t      offset = dashSum + offset;\n\t    }\n\t\n\t    offset %= dashSum; // Bezier approx length\n\t\n\t    for (t = 0; t < 1; t += 0.1) {\n\t      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);\n\t      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);\n\t      bezierLen += mathSqrt(dx * dx + dy * dy);\n\t    } // Find idx after add offset\n\t\n\t\n\t    for (; idx < nDash; idx++) {\n\t      tmpLen += lineDash[idx];\n\t\n\t      if (tmpLen > offset) {\n\t        break;\n\t      }\n\t    }\n\t\n\t    t = (tmpLen - offset) / bezierLen;\n\t\n\t    while (t <= 1) {\n\t      x = cubicAt(x0, x1, x2, x3, t);\n\t      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier\n\t      // Bad result if dash is long\n\t\n\t      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n\t      t += lineDash[idx] / bezierLen;\n\t      idx = (idx + 1) % nDash;\n\t    } // Finish the last segment and calculate the new offset\n\t\n\t\n\t    idx % 2 !== 0 && ctx.lineTo(x3, y3);\n\t    dx = x3 - x;\n\t    dy = y3 - y;\n\t    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t  },\n\t  _dashedQuadraticTo: function (x1, y1, x2, y2) {\n\t    // Convert quadratic to cubic using degree elevation\n\t    var x3 = x2;\n\t    var y3 = y2;\n\t    x2 = (x2 + 2 * x1) / 3;\n\t    y2 = (y2 + 2 * y1) / 3;\n\t    x1 = (this._xi + 2 * x1) / 3;\n\t    y1 = (this._yi + 2 * y1) / 3;\n\t\n\t    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n\t  },\n\t\n\t  /**\n\t   * 转成静态的 Float32Array 减少堆内存占用\n\t   * Convert dynamic array to static Float32Array\n\t   */\n\t  toStatic: function () {\n\t    var data = this.data;\n\t\n\t    if (data instanceof Array) {\n\t      data.length = this._len;\n\t\n\t      if (hasTypedArray) {\n\t        this.data = new Float32Array(data);\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @return {module:zrender/core/BoundingRect}\n\t   */\n\t  getBoundingRect: function () {\n\t    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n\t    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\t    var data = this.data;\n\t    var xi = 0;\n\t    var yi = 0;\n\t    var x0 = 0;\n\t    var y0 = 0;\n\t\n\t    for (var i = 0; i < data.length;) {\n\t      var cmd = data[i++];\n\t\n\t      if (i == 1) {\n\t        // 如果第一个命令是 L, C, Q\n\t        // 则 previous point 同绘制命令的第一个 point\n\t        //\n\t        // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t        xi = data[i];\n\t        yi = data[i + 1];\n\t        x0 = xi;\n\t        y0 = yi;\n\t      }\n\t\n\t      switch (cmd) {\n\t        case CMD.M:\n\t          // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n\t          // 在 closePath 的时候使用\n\t          x0 = data[i++];\n\t          y0 = data[i++];\n\t          xi = x0;\n\t          yi = y0;\n\t          min2[0] = x0;\n\t          min2[1] = y0;\n\t          max2[0] = x0;\n\t          max2[1] = y0;\n\t          break;\n\t\n\t        case CMD.L:\n\t          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n\t          xi = data[i++];\n\t          yi = data[i++];\n\t          break;\n\t\n\t        case CMD.C:\n\t          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n\t          xi = data[i++];\n\t          yi = data[i++];\n\t          break;\n\t\n\t        case CMD.Q:\n\t          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n\t          xi = data[i++];\n\t          yi = data[i++];\n\t          break;\n\t\n\t        case CMD.A:\n\t          // TODO Arc 判断的开销比较大\n\t          var cx = data[i++];\n\t          var cy = data[i++];\n\t          var rx = data[i++];\n\t          var ry = data[i++];\n\t          var startAngle = data[i++];\n\t          var endAngle = data[i++] + startAngle; // TODO Arc 旋转\n\t\n\t          var psi = data[i++];\n\t          var anticlockwise = 1 - data[i++];\n\t\n\t          if (i == 1) {\n\t            // 直接使用 arc 命令\n\t            // 第一个命令起点还未定义\n\t            x0 = mathCos(startAngle) * rx + cx;\n\t            y0 = mathSin(startAngle) * ry + cy;\n\t          }\n\t\n\t          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n\t          xi = mathCos(endAngle) * rx + cx;\n\t          yi = mathSin(endAngle) * ry + cy;\n\t          break;\n\t\n\t        case CMD.R:\n\t          x0 = xi = data[i++];\n\t          y0 = yi = data[i++];\n\t          var width = data[i++];\n\t          var height = data[i++]; // Use fromLine\n\t\n\t          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n\t          break;\n\t\n\t        case CMD.Z:\n\t          xi = x0;\n\t          yi = y0;\n\t          break;\n\t      } // Union\n\t\n\t\n\t      vec2.min(min, min, min2);\n\t      vec2.max(max, max, max2);\n\t    } // No data\n\t\n\t\n\t    if (i === 0) {\n\t      min[0] = min[1] = max[0] = max[1] = 0;\n\t    }\n\t\n\t    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t  },\n\t\n\t  /**\n\t   * Rebuild path from current data\n\t   * Rebuild path will not consider javascript implemented line dash.\n\t   * @param {CanvasRenderingContext2D} ctx\n\t   */\n\t  rebuildPath: function (ctx) {\n\t    var d = this.data;\n\t    var x0, y0;\n\t    var xi, yi;\n\t    var x, y;\n\t    var ux = this._ux;\n\t    var uy = this._uy;\n\t    var len = this._len;\n\t\n\t    for (var i = 0; i < len;) {\n\t      var cmd = d[i++];\n\t\n\t      if (i == 1) {\n\t        // 如果第一个命令是 L, C, Q\n\t        // 则 previous point 同绘制命令的第一个 point\n\t        //\n\t        // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t        xi = d[i];\n\t        yi = d[i + 1];\n\t        x0 = xi;\n\t        y0 = yi;\n\t      }\n\t\n\t      switch (cmd) {\n\t        case CMD.M:\n\t          x0 = xi = d[i++];\n\t          y0 = yi = d[i++];\n\t          ctx.moveTo(xi, yi);\n\t          break;\n\t\n\t        case CMD.L:\n\t          x = d[i++];\n\t          y = d[i++]; // Not draw too small seg between\n\t\n\t          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n\t            ctx.lineTo(x, y);\n\t            xi = x;\n\t            yi = y;\n\t          }\n\t\n\t          break;\n\t\n\t        case CMD.C:\n\t          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);\n\t          xi = d[i - 2];\n\t          yi = d[i - 1];\n\t          break;\n\t\n\t        case CMD.Q:\n\t          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n\t          xi = d[i - 2];\n\t          yi = d[i - 1];\n\t          break;\n\t\n\t        case CMD.A:\n\t          var cx = d[i++];\n\t          var cy = d[i++];\n\t          var rx = d[i++];\n\t          var ry = d[i++];\n\t          var theta = d[i++];\n\t          var dTheta = d[i++];\n\t          var psi = d[i++];\n\t          var fs = d[i++];\n\t          var r = rx > ry ? rx : ry;\n\t          var scaleX = rx > ry ? 1 : rx / ry;\n\t          var scaleY = rx > ry ? ry / rx : 1;\n\t          var isEllipse = Math.abs(rx - ry) > 1e-3;\n\t          var endAngle = theta + dTheta;\n\t\n\t          if (isEllipse) {\n\t            ctx.translate(cx, cy);\n\t            ctx.rotate(psi);\n\t            ctx.scale(scaleX, scaleY);\n\t            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n\t            ctx.scale(1 / scaleX, 1 / scaleY);\n\t            ctx.rotate(-psi);\n\t            ctx.translate(-cx, -cy);\n\t          } else {\n\t            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n\t          }\n\t\n\t          if (i == 1) {\n\t            // 直接使用 arc 命令\n\t            // 第一个命令起点还未定义\n\t            x0 = mathCos(theta) * rx + cx;\n\t            y0 = mathSin(theta) * ry + cy;\n\t          }\n\t\n\t          xi = mathCos(endAngle) * rx + cx;\n\t          yi = mathSin(endAngle) * ry + cy;\n\t          break;\n\t\n\t        case CMD.R:\n\t          x0 = xi = d[i];\n\t          y0 = yi = d[i + 1];\n\t          ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n\t          break;\n\t\n\t        case CMD.Z:\n\t          ctx.closePath();\n\t          xi = x0;\n\t          yi = y0;\n\t      }\n\t    }\n\t  }\n\t};\n\tPathProxy.CMD = CMD;\n\tvar _default = PathProxy;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _vector = __webpack_require__(8);\n\t\n\tvar v2Create = _vector.create;\n\tvar v2DistSquare = _vector.distSquare;\n\t\n\t/**\n\t * 曲线辅助模块\n\t * @module zrender/core/curve\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\tvar mathPow = Math.pow;\n\tvar mathSqrt = Math.sqrt;\n\tvar EPSILON = 1e-8;\n\tvar EPSILON_NUMERIC = 1e-4;\n\tvar THREE_SQRT = mathSqrt(3);\n\tvar ONE_THIRD = 1 / 3; // 临时变量\n\t\n\tvar _v0 = v2Create();\n\t\n\tvar _v1 = v2Create();\n\t\n\tvar _v2 = v2Create();\n\t\n\tfunction isAroundZero(val) {\n\t  return val > -EPSILON && val < EPSILON;\n\t}\n\t\n\tfunction isNotAroundZero(val) {\n\t  return val > EPSILON || val < -EPSILON;\n\t}\n\t/**\n\t * 计算三次贝塞尔值\n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {number} t\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction cubicAt(p0, p1, p2, p3, t) {\n\t  var onet = 1 - t;\n\t  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);\n\t}\n\t/**\n\t * 计算三次贝塞尔导数值\n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {number} t\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction cubicDerivativeAt(p0, p1, p2, p3, t) {\n\t  var onet = 1 - t;\n\t  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);\n\t}\n\t/**\n\t * 计算三次贝塞尔方程根，使用盛金公式\n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {number} val\n\t * @param  {Array.<number>} roots\n\t * @return {number} 有效根数目\n\t */\n\t\n\t\n\tfunction cubicRootAt(p0, p1, p2, p3, val, roots) {\n\t  // Evaluate roots of cubic functions\n\t  var a = p3 + 3 * (p1 - p2) - p0;\n\t  var b = 3 * (p2 - p1 * 2 + p0);\n\t  var c = 3 * (p1 - p0);\n\t  var d = p0 - val;\n\t  var A = b * b - 3 * a * c;\n\t  var B = b * c - 9 * a * d;\n\t  var C = c * c - 3 * b * d;\n\t  var n = 0;\n\t\n\t  if (isAroundZero(A) && isAroundZero(B)) {\n\t    if (isAroundZero(b)) {\n\t      roots[0] = 0;\n\t    } else {\n\t      var t1 = -c / b; //t1, t2, t3, b is not zero\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t    }\n\t  } else {\n\t    var disc = B * B - 4 * A * C;\n\t\n\t    if (isAroundZero(disc)) {\n\t      var K = B / A;\n\t      var t1 = -b / a + K; // t1, a is not zero\n\t\n\t      var t2 = -K / 2; // t2, t3\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t\n\t      if (t2 >= 0 && t2 <= 1) {\n\t        roots[n++] = t2;\n\t      }\n\t    } else if (disc > 0) {\n\t      var discSqrt = mathSqrt(disc);\n\t      var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n\t      var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\t\n\t      if (Y1 < 0) {\n\t        Y1 = -mathPow(-Y1, ONE_THIRD);\n\t      } else {\n\t        Y1 = mathPow(Y1, ONE_THIRD);\n\t      }\n\t\n\t      if (Y2 < 0) {\n\t        Y2 = -mathPow(-Y2, ONE_THIRD);\n\t      } else {\n\t        Y2 = mathPow(Y2, ONE_THIRD);\n\t      }\n\t\n\t      var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t    } else {\n\t      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n\t      var theta = Math.acos(T) / 3;\n\t      var ASqrt = mathSqrt(A);\n\t      var tmp = Math.cos(theta);\n\t      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n\t      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t\n\t      if (t2 >= 0 && t2 <= 1) {\n\t        roots[n++] = t2;\n\t      }\n\t\n\t      if (t3 >= 0 && t3 <= 1) {\n\t        roots[n++] = t3;\n\t      }\n\t    }\n\t  }\n\t\n\t  return n;\n\t}\n\t/**\n\t * 计算三次贝塞尔方程极限值的位置\n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {Array.<number>} extrema\n\t * @return {number} 有效数目\n\t */\n\t\n\t\n\tfunction cubicExtrema(p0, p1, p2, p3, extrema) {\n\t  var b = 6 * p2 - 12 * p1 + 6 * p0;\n\t  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n\t  var c = 3 * p1 - 3 * p0;\n\t  var n = 0;\n\t\n\t  if (isAroundZero(a)) {\n\t    if (isNotAroundZero(b)) {\n\t      var t1 = -c / b;\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        extrema[n++] = t1;\n\t      }\n\t    }\n\t  } else {\n\t    var disc = b * b - 4 * a * c;\n\t\n\t    if (isAroundZero(disc)) {\n\t      extrema[0] = -b / (2 * a);\n\t    } else if (disc > 0) {\n\t      var discSqrt = mathSqrt(disc);\n\t      var t1 = (-b + discSqrt) / (2 * a);\n\t      var t2 = (-b - discSqrt) / (2 * a);\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        extrema[n++] = t1;\n\t      }\n\t\n\t      if (t2 >= 0 && t2 <= 1) {\n\t        extrema[n++] = t2;\n\t      }\n\t    }\n\t  }\n\t\n\t  return n;\n\t}\n\t/**\n\t * 细分三次贝塞尔曲线\n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {number} t\n\t * @param  {Array.<number>} out\n\t */\n\t\n\t\n\tfunction cubicSubdivide(p0, p1, p2, p3, t, out) {\n\t  var p01 = (p1 - p0) * t + p0;\n\t  var p12 = (p2 - p1) * t + p1;\n\t  var p23 = (p3 - p2) * t + p2;\n\t  var p012 = (p12 - p01) * t + p01;\n\t  var p123 = (p23 - p12) * t + p12;\n\t  var p0123 = (p123 - p012) * t + p012; // Seg0\n\t\n\t  out[0] = p0;\n\t  out[1] = p01;\n\t  out[2] = p012;\n\t  out[3] = p0123; // Seg1\n\t\n\t  out[4] = p0123;\n\t  out[5] = p123;\n\t  out[6] = p23;\n\t  out[7] = p3;\n\t}\n\t/**\n\t * 投射点到三次贝塞尔曲线上，返回投射距离。\n\t * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n\t * @param {number} x0\n\t * @param {number} y0\n\t * @param {number} x1\n\t * @param {number} y1\n\t * @param {number} x2\n\t * @param {number} y2\n\t * @param {number} x3\n\t * @param {number} y3\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {Array.<number>} [out] 投射点\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {\n\t  // http://pomax.github.io/bezierinfo/#projections\n\t  var t;\n\t  var interval = 0.005;\n\t  var d = Infinity;\n\t  var prev;\n\t  var next;\n\t  var d1;\n\t  var d2;\n\t  _v0[0] = x;\n\t  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值\n\t  // PENDING\n\t\n\t  for (var _t = 0; _t < 1; _t += 0.05) {\n\t    _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n\t    _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n\t    d1 = v2DistSquare(_v0, _v1);\n\t\n\t    if (d1 < d) {\n\t      t = _t;\n\t      d = d1;\n\t    }\n\t  }\n\t\n\t  d = Infinity; // At most 32 iteration\n\t\n\t  for (var i = 0; i < 32; i++) {\n\t    if (interval < EPSILON_NUMERIC) {\n\t      break;\n\t    }\n\t\n\t    prev = t - interval;\n\t    next = t + interval; // t - interval\n\t\n\t    _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n\t    _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\t    d1 = v2DistSquare(_v1, _v0);\n\t\n\t    if (prev >= 0 && d1 < d) {\n\t      t = prev;\n\t      d = d1;\n\t    } else {\n\t      // t + interval\n\t      _v2[0] = cubicAt(x0, x1, x2, x3, next);\n\t      _v2[1] = cubicAt(y0, y1, y2, y3, next);\n\t      d2 = v2DistSquare(_v2, _v0);\n\t\n\t      if (next <= 1 && d2 < d) {\n\t        t = next;\n\t        d = d2;\n\t      } else {\n\t        interval *= 0.5;\n\t      }\n\t    }\n\t  } // t\n\t\n\t\n\t  if (out) {\n\t    out[0] = cubicAt(x0, x1, x2, x3, t);\n\t    out[1] = cubicAt(y0, y1, y2, y3, t);\n\t  } // console.log(interval, i);\n\t\n\t\n\t  return mathSqrt(d);\n\t}\n\t/**\n\t * 计算二次方贝塞尔值\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} t\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction quadraticAt(p0, p1, p2, t) {\n\t  var onet = 1 - t;\n\t  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n\t}\n\t/**\n\t * 计算二次方贝塞尔导数值\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} t\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction quadraticDerivativeAt(p0, p1, p2, t) {\n\t  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n\t}\n\t/**\n\t * 计算二次方贝塞尔方程根\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} t\n\t * @param  {Array.<number>} roots\n\t * @return {number} 有效根数目\n\t */\n\t\n\t\n\tfunction quadraticRootAt(p0, p1, p2, val, roots) {\n\t  var a = p0 - 2 * p1 + p2;\n\t  var b = 2 * (p1 - p0);\n\t  var c = p0 - val;\n\t  var n = 0;\n\t\n\t  if (isAroundZero(a)) {\n\t    if (isNotAroundZero(b)) {\n\t      var t1 = -c / b;\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t    }\n\t  } else {\n\t    var disc = b * b - 4 * a * c;\n\t\n\t    if (isAroundZero(disc)) {\n\t      var t1 = -b / (2 * a);\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t    } else if (disc > 0) {\n\t      var discSqrt = mathSqrt(disc);\n\t      var t1 = (-b + discSqrt) / (2 * a);\n\t      var t2 = (-b - discSqrt) / (2 * a);\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t\n\t      if (t2 >= 0 && t2 <= 1) {\n\t        roots[n++] = t2;\n\t      }\n\t    }\n\t  }\n\t\n\t  return n;\n\t}\n\t/**\n\t * 计算二次贝塞尔方程极限值\n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction quadraticExtremum(p0, p1, p2) {\n\t  var divider = p0 + p2 - 2 * p1;\n\t\n\t  if (divider === 0) {\n\t    // p1 is center of p0 and p2\n\t    return 0.5;\n\t  } else {\n\t    return (p0 - p1) / divider;\n\t  }\n\t}\n\t/**\n\t * 细分二次贝塞尔曲线\n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} t\n\t * @param  {Array.<number>} out\n\t */\n\t\n\t\n\tfunction quadraticSubdivide(p0, p1, p2, t, out) {\n\t  var p01 = (p1 - p0) * t + p0;\n\t  var p12 = (p2 - p1) * t + p1;\n\t  var p012 = (p12 - p01) * t + p01; // Seg0\n\t\n\t  out[0] = p0;\n\t  out[1] = p01;\n\t  out[2] = p012; // Seg1\n\t\n\t  out[3] = p012;\n\t  out[4] = p12;\n\t  out[5] = p2;\n\t}\n\t/**\n\t * 投射点到二次贝塞尔曲线上，返回投射距离。\n\t * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n\t * @param {number} x0\n\t * @param {number} y0\n\t * @param {number} x1\n\t * @param {number} y1\n\t * @param {number} x2\n\t * @param {number} y2\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {Array.<number>} out 投射点\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {\n\t  // http://pomax.github.io/bezierinfo/#projections\n\t  var t;\n\t  var interval = 0.005;\n\t  var d = Infinity;\n\t  _v0[0] = x;\n\t  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值\n\t  // PENDING\n\t\n\t  for (var _t = 0; _t < 1; _t += 0.05) {\n\t    _v1[0] = quadraticAt(x0, x1, x2, _t);\n\t    _v1[1] = quadraticAt(y0, y1, y2, _t);\n\t    var d1 = v2DistSquare(_v0, _v1);\n\t\n\t    if (d1 < d) {\n\t      t = _t;\n\t      d = d1;\n\t    }\n\t  }\n\t\n\t  d = Infinity; // At most 32 iteration\n\t\n\t  for (var i = 0; i < 32; i++) {\n\t    if (interval < EPSILON_NUMERIC) {\n\t      break;\n\t    }\n\t\n\t    var prev = t - interval;\n\t    var next = t + interval; // t - interval\n\t\n\t    _v1[0] = quadraticAt(x0, x1, x2, prev);\n\t    _v1[1] = quadraticAt(y0, y1, y2, prev);\n\t    var d1 = v2DistSquare(_v1, _v0);\n\t\n\t    if (prev >= 0 && d1 < d) {\n\t      t = prev;\n\t      d = d1;\n\t    } else {\n\t      // t + interval\n\t      _v2[0] = quadraticAt(x0, x1, x2, next);\n\t      _v2[1] = quadraticAt(y0, y1, y2, next);\n\t      var d2 = v2DistSquare(_v2, _v0);\n\t\n\t      if (next <= 1 && d2 < d) {\n\t        t = next;\n\t        d = d2;\n\t      } else {\n\t        interval *= 0.5;\n\t      }\n\t    }\n\t  } // t\n\t\n\t\n\t  if (out) {\n\t    out[0] = quadraticAt(x0, x1, x2, t);\n\t    out[1] = quadraticAt(y0, y1, y2, t);\n\t  } // console.log(interval, i);\n\t\n\t\n\t  return mathSqrt(d);\n\t}\n\t\n\texports.cubicAt = cubicAt;\n\texports.cubicDerivativeAt = cubicDerivativeAt;\n\texports.cubicRootAt = cubicRootAt;\n\texports.cubicExtrema = cubicExtrema;\n\texports.cubicSubdivide = cubicSubdivide;\n\texports.cubicProjectPoint = cubicProjectPoint;\n\texports.quadraticAt = quadraticAt;\n\texports.quadraticDerivativeAt = quadraticDerivativeAt;\n\texports.quadraticRootAt = quadraticRootAt;\n\texports.quadraticExtremum = quadraticExtremum;\n\texports.quadraticSubdivide = quadraticSubdivide;\n\texports.quadraticProjectPoint = quadraticProjectPoint;\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar vec2 = __webpack_require__(8);\n\t\n\tvar curve = __webpack_require__(49);\n\t\n\t/**\n\t * @author Yi Shen(https://github.com/pissang)\n\t */\n\tvar mathMin = Math.min;\n\tvar mathMax = Math.max;\n\tvar mathSin = Math.sin;\n\tvar mathCos = Math.cos;\n\tvar PI2 = Math.PI * 2;\n\tvar start = vec2.create();\n\tvar end = vec2.create();\n\tvar extremity = vec2.create();\n\t/**\n\t * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n\t * @module zrender/core/bbox\n\t * @param {Array<Object>} points 顶点数组\n\t * @param {number} min\n\t * @param {number} max\n\t */\n\t\n\tfunction fromPoints(points, min, max) {\n\t  if (points.length === 0) {\n\t    return;\n\t  }\n\t\n\t  var p = points[0];\n\t  var left = p[0];\n\t  var right = p[0];\n\t  var top = p[1];\n\t  var bottom = p[1];\n\t  var i;\n\t\n\t  for (i = 1; i < points.length; i++) {\n\t    p = points[i];\n\t    left = mathMin(left, p[0]);\n\t    right = mathMax(right, p[0]);\n\t    top = mathMin(top, p[1]);\n\t    bottom = mathMax(bottom, p[1]);\n\t  }\n\t\n\t  min[0] = left;\n\t  min[1] = top;\n\t  max[0] = right;\n\t  max[1] = bottom;\n\t}\n\t/**\n\t * @memberOf module:zrender/core/bbox\n\t * @param {number} x0\n\t * @param {number} y0\n\t * @param {number} x1\n\t * @param {number} y1\n\t * @param {Array.<number>} min\n\t * @param {Array.<number>} max\n\t */\n\t\n\t\n\tfunction fromLine(x0, y0, x1, y1, min, max) {\n\t  min[0] = mathMin(x0, x1);\n\t  min[1] = mathMin(y0, y1);\n\t  max[0] = mathMax(x0, x1);\n\t  max[1] = mathMax(y0, y1);\n\t}\n\t\n\tvar xDim = [];\n\tvar yDim = [];\n\t/**\n\t * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n\t * @memberOf module:zrender/core/bbox\n\t * @param {number} x0\n\t * @param {number} y0\n\t * @param {number} x1\n\t * @param {number} y1\n\t * @param {number} x2\n\t * @param {number} y2\n\t * @param {number} x3\n\t * @param {number} y3\n\t * @param {Array.<number>} min\n\t * @param {Array.<number>} max\n\t */\n\t\n\tfunction fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {\n\t  var cubicExtrema = curve.cubicExtrema;\n\t  var cubicAt = curve.cubicAt;\n\t  var i;\n\t  var n = cubicExtrema(x0, x1, x2, x3, xDim);\n\t  min[0] = Infinity;\n\t  min[1] = Infinity;\n\t  max[0] = -Infinity;\n\t  max[1] = -Infinity;\n\t\n\t  for (i = 0; i < n; i++) {\n\t    var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n\t    min[0] = mathMin(x, min[0]);\n\t    max[0] = mathMax(x, max[0]);\n\t  }\n\t\n\t  n = cubicExtrema(y0, y1, y2, y3, yDim);\n\t\n\t  for (i = 0; i < n; i++) {\n\t    var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n\t    min[1] = mathMin(y, min[1]);\n\t    max[1] = mathMax(y, max[1]);\n\t  }\n\t\n\t  min[0] = mathMin(x0, min[0]);\n\t  max[0] = mathMax(x0, max[0]);\n\t  min[0] = mathMin(x3, min[0]);\n\t  max[0] = mathMax(x3, max[0]);\n\t  min[1] = mathMin(y0, min[1]);\n\t  max[1] = mathMax(y0, max[1]);\n\t  min[1] = mathMin(y3, min[1]);\n\t  max[1] = mathMax(y3, max[1]);\n\t}\n\t/**\n\t * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n\t * @memberOf module:zrender/core/bbox\n\t * @param {number} x0\n\t * @param {number} y0\n\t * @param {number} x1\n\t * @param {number} y1\n\t * @param {number} x2\n\t * @param {number} y2\n\t * @param {Array.<number>} min\n\t * @param {Array.<number>} max\n\t */\n\t\n\t\n\tfunction fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {\n\t  var quadraticExtremum = curve.quadraticExtremum;\n\t  var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero\n\t\n\t  var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);\n\t  var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);\n\t  var x = quadraticAt(x0, x1, x2, tx);\n\t  var y = quadraticAt(y0, y1, y2, ty);\n\t  min[0] = mathMin(x0, x2, x);\n\t  min[1] = mathMin(y0, y2, y);\n\t  max[0] = mathMax(x0, x2, x);\n\t  max[1] = mathMax(y0, y2, y);\n\t}\n\t/**\n\t * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n\t * @method\n\t * @memberOf module:zrender/core/bbox\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {number} rx\n\t * @param {number} ry\n\t * @param {number} startAngle\n\t * @param {number} endAngle\n\t * @param {number} anticlockwise\n\t * @param {Array.<number>} min\n\t * @param {Array.<number>} max\n\t */\n\t\n\t\n\tfunction fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {\n\t  var vec2Min = vec2.min;\n\t  var vec2Max = vec2.max;\n\t  var diff = Math.abs(startAngle - endAngle);\n\t\n\t  if (diff % PI2 < 1e-4 && diff > 1e-4) {\n\t    // Is a circle\n\t    min[0] = x - rx;\n\t    min[1] = y - ry;\n\t    max[0] = x + rx;\n\t    max[1] = y + ry;\n\t    return;\n\t  }\n\t\n\t  start[0] = mathCos(startAngle) * rx + x;\n\t  start[1] = mathSin(startAngle) * ry + y;\n\t  end[0] = mathCos(endAngle) * rx + x;\n\t  end[1] = mathSin(endAngle) * ry + y;\n\t  vec2Min(min, start, end);\n\t  vec2Max(max, start, end); // Thresh to [0, Math.PI * 2]\n\t\n\t  startAngle = startAngle % PI2;\n\t\n\t  if (startAngle < 0) {\n\t    startAngle = startAngle + PI2;\n\t  }\n\t\n\t  endAngle = endAngle % PI2;\n\t\n\t  if (endAngle < 0) {\n\t    endAngle = endAngle + PI2;\n\t  }\n\t\n\t  if (startAngle > endAngle && !anticlockwise) {\n\t    endAngle += PI2;\n\t  } else if (startAngle < endAngle && anticlockwise) {\n\t    startAngle += PI2;\n\t  }\n\t\n\t  if (anticlockwise) {\n\t    var tmp = endAngle;\n\t    endAngle = startAngle;\n\t    startAngle = tmp;\n\t  } // var number = 0;\n\t  // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\t\n\t\n\t  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n\t    if (angle > startAngle) {\n\t      extremity[0] = mathCos(angle) * rx + x;\n\t      extremity[1] = mathSin(angle) * ry + y;\n\t      vec2Min(min, extremity, min);\n\t      vec2Max(max, extremity, max);\n\t    }\n\t  }\n\t}\n\t\n\texports.fromPoints = fromPoints;\n\texports.fromLine = fromLine;\n\texports.fromCubic = fromCubic;\n\texports.fromQuadratic = fromQuadratic;\n\texports.fromArc = fromArc;\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar PathProxy = __webpack_require__(48);\n\t\n\tvar line = __webpack_require__(52);\n\t\n\tvar cubic = __webpack_require__(53);\n\t\n\tvar quadratic = __webpack_require__(54);\n\t\n\tvar arc = __webpack_require__(55);\n\t\n\tvar _util = __webpack_require__(56);\n\t\n\tvar normalizeRadian = _util.normalizeRadian;\n\t\n\tvar curve = __webpack_require__(49);\n\t\n\tvar windingLine = __webpack_require__(57);\n\t\n\tvar CMD = PathProxy.CMD;\n\tvar PI2 = Math.PI * 2;\n\tvar EPSILON = 1e-4;\n\t\n\tfunction isAroundEqual(a, b) {\n\t  return Math.abs(a - b) < EPSILON;\n\t} // 临时数组\n\t\n\t\n\tvar roots = [-1, -1, -1];\n\tvar extrema = [-1, -1];\n\t\n\tfunction swapExtrema() {\n\t  var tmp = extrema[0];\n\t  extrema[0] = extrema[1];\n\t  extrema[1] = tmp;\n\t}\n\t\n\tfunction windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n\t  // Quick reject\n\t  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {\n\t    return 0;\n\t  }\n\t\n\t  var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\t\n\t  if (nRoots === 0) {\n\t    return 0;\n\t  } else {\n\t    var w = 0;\n\t    var nExtrema = -1;\n\t    var y0_, y1_;\n\t\n\t    for (var i = 0; i < nRoots; i++) {\n\t      var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon\n\t\n\t      var unit = t === 0 || t === 1 ? 0.5 : 1;\n\t      var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\t\n\t      if (x_ < x) {\n\t        // Quick reject\n\t        continue;\n\t      }\n\t\n\t      if (nExtrema < 0) {\n\t        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\t\n\t        if (extrema[1] < extrema[0] && nExtrema > 1) {\n\t          swapExtrema();\n\t        }\n\t\n\t        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\t\n\t        if (nExtrema > 1) {\n\t          y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n\t        }\n\t      }\n\t\n\t      if (nExtrema == 2) {\n\t        // 分成三段单调函数\n\t        if (t < extrema[0]) {\n\t          w += y0_ < y0 ? unit : -unit;\n\t        } else if (t < extrema[1]) {\n\t          w += y1_ < y0_ ? unit : -unit;\n\t        } else {\n\t          w += y3 < y1_ ? unit : -unit;\n\t        }\n\t      } else {\n\t        // 分成两段单调函数\n\t        if (t < extrema[0]) {\n\t          w += y0_ < y0 ? unit : -unit;\n\t        } else {\n\t          w += y3 < y0_ ? unit : -unit;\n\t        }\n\t      }\n\t    }\n\t\n\t    return w;\n\t  }\n\t}\n\t\n\tfunction windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n\t  // Quick reject\n\t  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {\n\t    return 0;\n\t  }\n\t\n\t  var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\t\n\t  if (nRoots === 0) {\n\t    return 0;\n\t  } else {\n\t    var t = curve.quadraticExtremum(y0, y1, y2);\n\t\n\t    if (t >= 0 && t <= 1) {\n\t      var w = 0;\n\t      var y_ = curve.quadraticAt(y0, y1, y2, t);\n\t\n\t      for (var i = 0; i < nRoots; i++) {\n\t        // Remove one endpoint.\n\t        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;\n\t        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\t\n\t        if (x_ < x) {\n\t          // Quick reject\n\t          continue;\n\t        }\n\t\n\t        if (roots[i] < t) {\n\t          w += y_ < y0 ? unit : -unit;\n\t        } else {\n\t          w += y2 < y_ ? unit : -unit;\n\t        }\n\t      }\n\t\n\t      return w;\n\t    } else {\n\t      // Remove one endpoint.\n\t      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;\n\t      var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\t\n\t      if (x_ < x) {\n\t        // Quick reject\n\t        return 0;\n\t      }\n\t\n\t      return y2 < y0 ? unit : -unit;\n\t    }\n\t  }\n\t} // TODO\n\t// Arc 旋转\n\t\n\t\n\tfunction windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {\n\t  y -= cy;\n\t\n\t  if (y > r || y < -r) {\n\t    return 0;\n\t  }\n\t\n\t  var tmp = Math.sqrt(r * r - y * y);\n\t  roots[0] = -tmp;\n\t  roots[1] = tmp;\n\t  var diff = Math.abs(startAngle - endAngle);\n\t\n\t  if (diff < 1e-4) {\n\t    return 0;\n\t  }\n\t\n\t  if (diff % PI2 < 1e-4) {\n\t    // Is a circle\n\t    startAngle = 0;\n\t    endAngle = PI2;\n\t    var dir = anticlockwise ? 1 : -1;\n\t\n\t    if (x >= roots[0] + cx && x <= roots[1] + cx) {\n\t      return dir;\n\t    } else {\n\t      return 0;\n\t    }\n\t  }\n\t\n\t  if (anticlockwise) {\n\t    var tmp = startAngle;\n\t    startAngle = normalizeRadian(endAngle);\n\t    endAngle = normalizeRadian(tmp);\n\t  } else {\n\t    startAngle = normalizeRadian(startAngle);\n\t    endAngle = normalizeRadian(endAngle);\n\t  }\n\t\n\t  if (startAngle > endAngle) {\n\t    endAngle += PI2;\n\t  }\n\t\n\t  var w = 0;\n\t\n\t  for (var i = 0; i < 2; i++) {\n\t    var x_ = roots[i];\n\t\n\t    if (x_ + cx > x) {\n\t      var angle = Math.atan2(y, x_);\n\t      var dir = anticlockwise ? 1 : -1;\n\t\n\t      if (angle < 0) {\n\t        angle = PI2 + angle;\n\t      }\n\t\n\t      if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n\t        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n\t          dir = -dir;\n\t        }\n\t\n\t        w += dir;\n\t      }\n\t    }\n\t  }\n\t\n\t  return w;\n\t}\n\t\n\tfunction containPath(data, lineWidth, isStroke, x, y) {\n\t  var w = 0;\n\t  var xi = 0;\n\t  var yi = 0;\n\t  var x0 = 0;\n\t  var y0 = 0;\n\t\n\t  for (var i = 0; i < data.length;) {\n\t    var cmd = data[i++]; // Begin a new subpath\n\t\n\t    if (cmd === CMD.M && i > 1) {\n\t      // Close previous subpath\n\t      if (!isStroke) {\n\t        w += windingLine(xi, yi, x0, y0, x, y);\n\t      } // 如果被任何一个 subpath 包含\n\t      // if (w !== 0) {\n\t      //     return true;\n\t      // }\n\t\n\t    }\n\t\n\t    if (i == 1) {\n\t      // 如果第一个命令是 L, C, Q\n\t      // 则 previous point 同绘制命令的第一个 point\n\t      //\n\t      // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t      xi = data[i];\n\t      yi = data[i + 1];\n\t      x0 = xi;\n\t      y0 = yi;\n\t    }\n\t\n\t    switch (cmd) {\n\t      case CMD.M:\n\t        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n\t        // 在 closePath 的时候使用\n\t        x0 = data[i++];\n\t        y0 = data[i++];\n\t        xi = x0;\n\t        yi = y0;\n\t        break;\n\t\n\t      case CMD.L:\n\t        if (isStroke) {\n\t          if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n\t          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n\t        }\n\t\n\t        xi = data[i++];\n\t        yi = data[i++];\n\t        break;\n\t\n\t      case CMD.C:\n\t        if (isStroke) {\n\t          if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n\t        }\n\t\n\t        xi = data[i++];\n\t        yi = data[i++];\n\t        break;\n\t\n\t      case CMD.Q:\n\t        if (isStroke) {\n\t          if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n\t        }\n\t\n\t        xi = data[i++];\n\t        yi = data[i++];\n\t        break;\n\t\n\t      case CMD.A:\n\t        // TODO Arc 判断的开销比较大\n\t        var cx = data[i++];\n\t        var cy = data[i++];\n\t        var rx = data[i++];\n\t        var ry = data[i++];\n\t        var theta = data[i++];\n\t        var dTheta = data[i++]; // TODO Arc 旋转\n\t\n\t        var psi = data[i++];\n\t        var anticlockwise = 1 - data[i++];\n\t        var x1 = Math.cos(theta) * rx + cx;\n\t        var y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令\n\t\n\t        if (i > 1) {\n\t          w += windingLine(xi, yi, x1, y1, x, y);\n\t        } else {\n\t          // 第一个命令起点还未定义\n\t          x0 = x1;\n\t          y0 = y1;\n\t        } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n\t\n\t\n\t        var _x = (x - cx) * ry / rx + cx;\n\t\n\t        if (isStroke) {\n\t          if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);\n\t        }\n\t\n\t        xi = Math.cos(theta + dTheta) * rx + cx;\n\t        yi = Math.sin(theta + dTheta) * ry + cy;\n\t        break;\n\t\n\t      case CMD.R:\n\t        x0 = xi = data[i++];\n\t        y0 = yi = data[i++];\n\t        var width = data[i++];\n\t        var height = data[i++];\n\t        var x1 = x0 + width;\n\t        var y1 = y0 + height;\n\t\n\t        if (isStroke) {\n\t          if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          // FIXME Clockwise ?\n\t          w += windingLine(x1, y0, x1, y1, x, y);\n\t          w += windingLine(x0, y1, x0, y0, x, y);\n\t        }\n\t\n\t        break;\n\t\n\t      case CMD.Z:\n\t        if (isStroke) {\n\t          if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          // Close a subpath\n\t          w += windingLine(xi, yi, x0, y0, x, y); // 如果被任何一个 subpath 包含\n\t          // FIXME subpaths may overlap\n\t          // if (w !== 0) {\n\t          //     return true;\n\t          // }\n\t        }\n\t\n\t        xi = x0;\n\t        yi = y0;\n\t        break;\n\t    }\n\t  }\n\t\n\t  if (!isStroke && !isAroundEqual(yi, y0)) {\n\t    w += windingLine(xi, yi, x0, y0, x, y) || 0;\n\t  }\n\t\n\t  return w !== 0;\n\t}\n\t\n\tfunction contain(pathData, x, y) {\n\t  return containPath(pathData, 0, false, x, y);\n\t}\n\t\n\tfunction containStroke(pathData, lineWidth, x, y) {\n\t  return containPath(pathData, lineWidth, true, x, y);\n\t}\n\t\n\texports.contain = contain;\n\texports.containStroke = containStroke;\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * 线段包含判断\n\t * @param  {number}  x0\n\t * @param  {number}  y0\n\t * @param  {number}  x1\n\t * @param  {number}  y1\n\t * @param  {number}  lineWidth\n\t * @param  {number}  x\n\t * @param  {number}  y\n\t * @return {boolean}\n\t */\n\tfunction containStroke(x0, y0, x1, y1, lineWidth, x, y) {\n\t  if (lineWidth === 0) {\n\t    return false;\n\t  }\n\t\n\t  var _l = lineWidth;\n\t  var _a = 0;\n\t  var _b = x0; // Quick reject\n\t\n\t  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {\n\t    return false;\n\t  }\n\t\n\t  if (x0 !== x1) {\n\t    _a = (y0 - y1) / (x0 - x1);\n\t    _b = (x0 * y1 - x1 * y0) / (x0 - x1);\n\t  } else {\n\t    return Math.abs(x - x0) <= _l / 2;\n\t  }\n\t\n\t  var tmp = _a * x - y + _b;\n\t\n\t  var _s = tmp * tmp / (_a * _a + 1);\n\t\n\t  return _s <= _l / 2 * _l / 2;\n\t}\n\t\n\texports.containStroke = containStroke;\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar curve = __webpack_require__(49);\n\t\n\t/**\n\t * 三次贝塞尔曲线描边包含判断\n\t * @param  {number}  x0\n\t * @param  {number}  y0\n\t * @param  {number}  x1\n\t * @param  {number}  y1\n\t * @param  {number}  x2\n\t * @param  {number}  y2\n\t * @param  {number}  x3\n\t * @param  {number}  y3\n\t * @param  {number}  lineWidth\n\t * @param  {number}  x\n\t * @param  {number}  y\n\t * @return {boolean}\n\t */\n\tfunction containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n\t  if (lineWidth === 0) {\n\t    return false;\n\t  }\n\t\n\t  var _l = lineWidth; // Quick reject\n\t\n\t  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {\n\t    return false;\n\t  }\n\t\n\t  var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);\n\t  return d <= _l / 2;\n\t}\n\t\n\texports.containStroke = containStroke;\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _curve = __webpack_require__(49);\n\t\n\tvar quadraticProjectPoint = _curve.quadraticProjectPoint;\n\t\n\t/**\n\t * 二次贝塞尔曲线描边包含判断\n\t * @param  {number}  x0\n\t * @param  {number}  y0\n\t * @param  {number}  x1\n\t * @param  {number}  y1\n\t * @param  {number}  x2\n\t * @param  {number}  y2\n\t * @param  {number}  lineWidth\n\t * @param  {number}  x\n\t * @param  {number}  y\n\t * @return {boolean}\n\t */\n\tfunction containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n\t  if (lineWidth === 0) {\n\t    return false;\n\t  }\n\t\n\t  var _l = lineWidth; // Quick reject\n\t\n\t  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {\n\t    return false;\n\t  }\n\t\n\t  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);\n\t  return d <= _l / 2;\n\t}\n\t\n\texports.containStroke = containStroke;\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _util = __webpack_require__(56);\n\t\n\tvar normalizeRadian = _util.normalizeRadian;\n\tvar PI2 = Math.PI * 2;\n\t/**\n\t * 圆弧描边包含判断\n\t * @param  {number}  cx\n\t * @param  {number}  cy\n\t * @param  {number}  r\n\t * @param  {number}  startAngle\n\t * @param  {number}  endAngle\n\t * @param  {boolean}  anticlockwise\n\t * @param  {number} lineWidth\n\t * @param  {number}  x\n\t * @param  {number}  y\n\t * @return {Boolean}\n\t */\n\t\n\tfunction containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {\n\t  if (lineWidth === 0) {\n\t    return false;\n\t  }\n\t\n\t  var _l = lineWidth;\n\t  x -= cx;\n\t  y -= cy;\n\t  var d = Math.sqrt(x * x + y * y);\n\t\n\t  if (d - _l > r || d + _l < r) {\n\t    return false;\n\t  }\n\t\n\t  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n\t    // Is a circle\n\t    return true;\n\t  }\n\t\n\t  if (anticlockwise) {\n\t    var tmp = startAngle;\n\t    startAngle = normalizeRadian(endAngle);\n\t    endAngle = normalizeRadian(tmp);\n\t  } else {\n\t    startAngle = normalizeRadian(startAngle);\n\t    endAngle = normalizeRadian(endAngle);\n\t  }\n\t\n\t  if (startAngle > endAngle) {\n\t    endAngle += PI2;\n\t  }\n\t\n\t  var angle = Math.atan2(y, x);\n\t\n\t  if (angle < 0) {\n\t    angle += PI2;\n\t  }\n\t\n\t  return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;\n\t}\n\t\n\texports.containStroke = containStroke;\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports) {\n\n\tvar PI2 = Math.PI * 2;\n\t\n\tfunction normalizeRadian(angle) {\n\t  angle %= PI2;\n\t\n\t  if (angle < 0) {\n\t    angle += PI2;\n\t  }\n\t\n\t  return angle;\n\t}\n\t\n\texports.normalizeRadian = normalizeRadian;\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports) {\n\n\tfunction windingLine(x0, y0, x1, y1, x, y) {\n\t  if (y > y0 && y > y1 || y < y0 && y < y1) {\n\t    return 0;\n\t  } // Ignore horizontal line\n\t\n\t\n\t  if (y1 === y0) {\n\t    return 0;\n\t  }\n\t\n\t  var dir = y1 < y0 ? 1 : -1;\n\t  var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon\n\t\n\t  if (t === 1 || t === 0) {\n\t    dir = y1 < y0 ? 0.5 : -0.5;\n\t  }\n\t\n\t  var x_ = t * (x1 - x0) + x0;\n\t  return x_ > x ? dir : 0;\n\t}\n\t\n\tmodule.exports = windingLine;\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar PathProxy = __webpack_require__(48);\n\t\n\tvar _vector = __webpack_require__(8);\n\t\n\tvar v2ApplyTransform = _vector.applyTransform;\n\tvar CMD = PathProxy.CMD;\n\tvar points = [[], [], []];\n\tvar mathSqrt = Math.sqrt;\n\tvar mathAtan2 = Math.atan2;\n\t\n\tfunction _default(path, m) {\n\t  var data = path.data;\n\t  var cmd;\n\t  var nPoint;\n\t  var i;\n\t  var j;\n\t  var k;\n\t  var p;\n\t  var M = CMD.M;\n\t  var C = CMD.C;\n\t  var L = CMD.L;\n\t  var R = CMD.R;\n\t  var A = CMD.A;\n\t  var Q = CMD.Q;\n\t\n\t  for (i = 0, j = 0; i < data.length;) {\n\t    cmd = data[i++];\n\t    j = i;\n\t    nPoint = 0;\n\t\n\t    switch (cmd) {\n\t      case M:\n\t        nPoint = 1;\n\t        break;\n\t\n\t      case L:\n\t        nPoint = 1;\n\t        break;\n\t\n\t      case C:\n\t        nPoint = 3;\n\t        break;\n\t\n\t      case Q:\n\t        nPoint = 2;\n\t        break;\n\t\n\t      case A:\n\t        var x = m[4];\n\t        var y = m[5];\n\t        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n\t        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n\t        var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx\n\t\n\t        data[i] *= sx;\n\t        data[i++] += x; // cy\n\t\n\t        data[i] *= sy;\n\t        data[i++] += y; // Scale rx and ry\n\t        // FIXME Assume psi is 0 here\n\t\n\t        data[i++] *= sx;\n\t        data[i++] *= sy; // Start angle\n\t\n\t        data[i++] += angle; // end angle\n\t\n\t        data[i++] += angle; // FIXME psi\n\t\n\t        i += 2;\n\t        j = i;\n\t        break;\n\t\n\t      case R:\n\t        // x0, y0\n\t        p[0] = data[i++];\n\t        p[1] = data[i++];\n\t        v2ApplyTransform(p, p, m);\n\t        data[j++] = p[0];\n\t        data[j++] = p[1]; // x1, y1\n\t\n\t        p[0] += data[i++];\n\t        p[1] += data[i++];\n\t        v2ApplyTransform(p, p, m);\n\t        data[j++] = p[0];\n\t        data[j++] = p[1];\n\t    }\n\t\n\t    for (k = 0; k < nPoint; k++) {\n\t      var p = points[k];\n\t      p[0] = data[i++];\n\t      p[1] = data[i++];\n\t      v2ApplyTransform(p, p, m); // Write back\n\t\n\t      data[j++] = p[0];\n\t      data[j++] = p[1];\n\t    }\n\t  }\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * @param {Array.<Object>} colorStops\n\t */\n\tvar Gradient = function (colorStops) {\n\t  this.colorStops = colorStops || [];\n\t};\n\t\n\tGradient.prototype = {\n\t  constructor: Gradient,\n\t  addColorStop: function (offset, color) {\n\t    this.colorStops.push({\n\t      offset: offset,\n\t      color: color\n\t    });\n\t  }\n\t};\n\tvar _default = Gradient;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Displayable = __webpack_require__(32);\n\t\n\tvar zrUtil = __webpack_require__(6);\n\t\n\tvar textContain = __webpack_require__(35);\n\t\n\tvar textHelper = __webpack_require__(34);\n\t\n\t/**\n\t * @alias zrender/graphic/Text\n\t * @extends module:zrender/graphic/Displayable\n\t * @constructor\n\t * @param {Object} opts\n\t */\n\tvar Text = function (opts) {\n\t  // jshint ignore:line\n\t  Displayable.call(this, opts);\n\t};\n\t\n\tText.prototype = {\n\t  constructor: Text,\n\t  type: 'text',\n\t  brush: function (ctx, prevEl) {\n\t    var style = this.style; // Optimize, avoid normalize every time.\n\t\n\t    this.__dirty && textHelper.normalizeTextStyle(style, true); // Use props with prefix 'text'.\n\t\n\t    style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;\n\t    var text = style.text; // Convert to string\n\t\n\t    text != null && (text += ''); // Always bind style\n\t\n\t    style.bind(ctx, this, prevEl);\n\t\n\t    if (!textHelper.needDrawText(text, style)) {\n\t      return;\n\t    }\n\t\n\t    this.setTransform(ctx);\n\t    textHelper.renderText(this, ctx, text, style);\n\t    this.restoreTransform(ctx);\n\t  },\n\t  getBoundingRect: function () {\n\t    var style = this.style; // Optimize, avoid normalize every time.\n\t\n\t    this.__dirty && textHelper.normalizeTextStyle(style, true);\n\t\n\t    if (!this._rect) {\n\t      var text = style.text;\n\t      text != null ? text += '' : text = '';\n\t      var rect = textContain.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.rich);\n\t      rect.x += style.x || 0;\n\t      rect.y += style.y || 0;\n\t\n\t      if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {\n\t        var w = style.textStrokeWidth;\n\t        rect.x -= w / 2;\n\t        rect.y -= w / 2;\n\t        rect.width += w;\n\t        rect.height += w;\n\t      }\n\t\n\t      this._rect = rect;\n\t    }\n\t\n\t    return this._rect;\n\t  }\n\t};\n\tzrUtil.inherits(Text, Displayable);\n\tvar _default = Text;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(47);\n\t\n\t/**\n\t * 圆形\n\t * @module zrender/shape/Circle\n\t */\n\tvar _default = Path.extend({\n\t  type: 'circle',\n\t  shape: {\n\t    cx: 0,\n\t    cy: 0,\n\t    r: 0\n\t  },\n\t  buildPath: function (ctx, shape, inBundle) {\n\t    // Better stroking in ShapeBundle\n\t    // Always do it may have performence issue ( fill may be 2x more cost)\n\t    if (inBundle) {\n\t      ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t    } // else {\n\t    //     if (ctx.allocate && !ctx.data.length) {\n\t    //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n\t    //     }\n\t    // }\n\t    // Better stroking in ShapeBundle\n\t    // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t\n\t\n\t    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(47);\n\t\n\tvar fixClipWithShadow = __webpack_require__(63);\n\t\n\t/**\n\t * 扇形\n\t * @module zrender/graphic/shape/Sector\n\t */\n\tvar _default = Path.extend({\n\t  type: 'sector',\n\t  shape: {\n\t    cx: 0,\n\t    cy: 0,\n\t    r0: 0,\n\t    r: 0,\n\t    startAngle: 0,\n\t    endAngle: Math.PI * 2,\n\t    clockwise: true\n\t  },\n\t  brush: fixClipWithShadow(Path.prototype.brush),\n\t  buildPath: function (ctx, shape) {\n\t    var x = shape.cx;\n\t    var y = shape.cy;\n\t    var r0 = Math.max(shape.r0 || 0, 0);\n\t    var r = Math.max(shape.r, 0);\n\t    var startAngle = shape.startAngle;\n\t    var endAngle = shape.endAngle;\n\t    var clockwise = shape.clockwise;\n\t    var unitX = Math.cos(startAngle);\n\t    var unitY = Math.sin(startAngle);\n\t    ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\t    ctx.lineTo(unitX * r + x, unitY * r + y);\n\t    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t    ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);\n\t\n\t    if (r0 !== 0) {\n\t      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n\t    }\n\t\n\t    ctx.closePath();\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar env = __webpack_require__(5);\n\t\n\t// Fix weird bug in some version of IE11 (like 11.0.9600.178**),\n\t// where exception \"unexpected call to method or property access\"\n\t// might be thrown when calling ctx.fill or ctx.stroke after a path\n\t// whose area size is zero is drawn and ctx.clip() is called and\n\t// shadowBlur is set. See #4572, #3112, #5777.\n\t// (e.g.,\n\t//  ctx.moveTo(10, 10);\n\t//  ctx.lineTo(20, 10);\n\t//  ctx.closePath();\n\t//  ctx.clip();\n\t//  ctx.shadowBlur = 10;\n\t//  ...\n\t//  ctx.fill();\n\t// )\n\tvar shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];\n\t\n\tfunction _default(orignalBrush) {\n\t  // version string can be: '11.0'\n\t  return env.browser.ie && env.browser.version >= 11 ? function () {\n\t    var clipPaths = this.__clipPaths;\n\t    var style = this.style;\n\t    var modified;\n\t\n\t    if (clipPaths) {\n\t      for (var i = 0; i < clipPaths.length; i++) {\n\t        var clipPath = clipPaths[i];\n\t        var shape = clipPath && clipPath.shape;\n\t        var type = clipPath && clipPath.type;\n\t\n\t        if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {\n\t          for (var j = 0; j < shadowTemp.length; j++) {\n\t            // It is save to put shadowTemp static, because shadowTemp\n\t            // will be all modified each item brush called.\n\t            shadowTemp[j][2] = style[shadowTemp[j][0]];\n\t            style[shadowTemp[j][0]] = shadowTemp[j][1];\n\t          }\n\t\n\t          modified = true;\n\t          break;\n\t        }\n\t      }\n\t    }\n\t\n\t    orignalBrush.apply(this, arguments);\n\t\n\t    if (modified) {\n\t      for (var j = 0; j < shadowTemp.length; j++) {\n\t        style[shadowTemp[j][0]] = shadowTemp[j][2];\n\t      }\n\t    }\n\t  } : orignalBrush;\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(47);\n\t\n\t/**\n\t * 圆环\n\t * @module zrender/graphic/shape/Ring\n\t */\n\tvar _default = Path.extend({\n\t  type: 'ring',\n\t  shape: {\n\t    cx: 0,\n\t    cy: 0,\n\t    r: 0,\n\t    r0: 0\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    var x = shape.cx;\n\t    var y = shape.cy;\n\t    var PI2 = Math.PI * 2;\n\t    ctx.moveTo(x + shape.r, y);\n\t    ctx.arc(x, y, shape.r, 0, PI2, false);\n\t    ctx.moveTo(x + shape.r0, y);\n\t    ctx.arc(x, y, shape.r0, 0, PI2, true);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(47);\n\t\n\tvar polyHelper = __webpack_require__(66);\n\t\n\t/**\n\t * 多边形\n\t * @module zrender/shape/Polygon\n\t */\n\tvar _default = Path.extend({\n\t  type: 'polygon',\n\t  shape: {\n\t    points: null,\n\t    smooth: false,\n\t    smoothConstraint: null\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    polyHelper.buildPath(ctx, shape, true);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar smoothSpline = __webpack_require__(67);\n\t\n\tvar smoothBezier = __webpack_require__(68);\n\t\n\tfunction buildPath(ctx, shape, closePath) {\n\t  var points = shape.points;\n\t  var smooth = shape.smooth;\n\t\n\t  if (points && points.length >= 2) {\n\t    if (smooth && smooth !== 'spline') {\n\t      var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);\n\t      ctx.moveTo(points[0][0], points[0][1]);\n\t      var len = points.length;\n\t\n\t      for (var i = 0; i < (closePath ? len : len - 1); i++) {\n\t        var cp1 = controlPoints[i * 2];\n\t        var cp2 = controlPoints[i * 2 + 1];\n\t        var p = points[(i + 1) % len];\n\t        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);\n\t      }\n\t    } else {\n\t      if (smooth === 'spline') {\n\t        points = smoothSpline(points, closePath);\n\t      }\n\t\n\t      ctx.moveTo(points[0][0], points[0][1]);\n\t\n\t      for (var i = 1, l = points.length; i < l; i++) {\n\t        ctx.lineTo(points[i][0], points[i][1]);\n\t      }\n\t    }\n\t\n\t    closePath && ctx.closePath();\n\t  }\n\t}\n\t\n\texports.buildPath = buildPath;\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _vector = __webpack_require__(8);\n\t\n\tvar v2Distance = _vector.distance;\n\t\n\t/**\n\t * Catmull-Rom spline 插值折线\n\t * @module zrender/shape/util/smoothSpline\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t/**\n\t * @inner\n\t */\n\tfunction interpolate(p0, p1, p2, p3, t, t2, t3) {\n\t  var v0 = (p2 - p0) * 0.5;\n\t  var v1 = (p3 - p1) * 0.5;\n\t  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n\t}\n\t/**\n\t * @alias module:zrender/shape/util/smoothSpline\n\t * @param {Array} points 线段顶点数组\n\t * @param {boolean} isLoop\n\t * @return {Array}\n\t */\n\t\n\t\n\tfunction _default(points, isLoop) {\n\t  var len = points.length;\n\t  var ret = [];\n\t  var distance = 0;\n\t\n\t  for (var i = 1; i < len; i++) {\n\t    distance += v2Distance(points[i - 1], points[i]);\n\t  }\n\t\n\t  var segs = distance / 2;\n\t  segs = segs < len ? len : segs;\n\t\n\t  for (var i = 0; i < segs; i++) {\n\t    var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n\t    var idx = Math.floor(pos);\n\t    var w = pos - idx;\n\t    var p0;\n\t    var p1 = points[idx % len];\n\t    var p2;\n\t    var p3;\n\t\n\t    if (!isLoop) {\n\t      p0 = points[idx === 0 ? idx : idx - 1];\n\t      p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n\t      p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n\t    } else {\n\t      p0 = points[(idx - 1 + len) % len];\n\t      p2 = points[(idx + 1) % len];\n\t      p3 = points[(idx + 2) % len];\n\t    }\n\t\n\t    var w2 = w * w;\n\t    var w3 = w * w2;\n\t    ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);\n\t  }\n\t\n\t  return ret;\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _vector = __webpack_require__(8);\n\t\n\tvar v2Min = _vector.min;\n\tvar v2Max = _vector.max;\n\tvar v2Scale = _vector.scale;\n\tvar v2Distance = _vector.distance;\n\tvar v2Add = _vector.add;\n\tvar v2Clone = _vector.clone;\n\tvar v2Sub = _vector.sub;\n\t\n\t/**\n\t * 贝塞尔平滑曲线\n\t * @module zrender/shape/util/smoothBezier\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t/**\n\t * 贝塞尔平滑曲线\n\t * @alias module:zrender/shape/util/smoothBezier\n\t * @param {Array} points 线段顶点数组\n\t * @param {number} smooth 平滑等级, 0-1\n\t * @param {boolean} isLoop\n\t * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n\t *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n\t *                           整个折线的包围盒做一个并集用来约束控制点。\n\t * @param {Array} 计算出来的控制点数组\n\t */\n\tfunction _default(points, smooth, isLoop, constraint) {\n\t  var cps = [];\n\t  var v = [];\n\t  var v1 = [];\n\t  var v2 = [];\n\t  var prevPoint;\n\t  var nextPoint;\n\t  var min, max;\n\t\n\t  if (constraint) {\n\t    min = [Infinity, Infinity];\n\t    max = [-Infinity, -Infinity];\n\t\n\t    for (var i = 0, len = points.length; i < len; i++) {\n\t      v2Min(min, min, points[i]);\n\t      v2Max(max, max, points[i]);\n\t    } // 与指定的包围盒做并集\n\t\n\t\n\t    v2Min(min, min, constraint[0]);\n\t    v2Max(max, max, constraint[1]);\n\t  }\n\t\n\t  for (var i = 0, len = points.length; i < len; i++) {\n\t    var point = points[i];\n\t\n\t    if (isLoop) {\n\t      prevPoint = points[i ? i - 1 : len - 1];\n\t      nextPoint = points[(i + 1) % len];\n\t    } else {\n\t      if (i === 0 || i === len - 1) {\n\t        cps.push(v2Clone(points[i]));\n\t        continue;\n\t      } else {\n\t        prevPoint = points[i - 1];\n\t        nextPoint = points[i + 1];\n\t      }\n\t    }\n\t\n\t    v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length\n\t\n\t    v2Scale(v, v, smooth);\n\t    var d0 = v2Distance(point, prevPoint);\n\t    var d1 = v2Distance(point, nextPoint);\n\t    var sum = d0 + d1;\n\t\n\t    if (sum !== 0) {\n\t      d0 /= sum;\n\t      d1 /= sum;\n\t    }\n\t\n\t    v2Scale(v1, v, -d0);\n\t    v2Scale(v2, v, d1);\n\t    var cp0 = v2Add([], point, v1);\n\t    var cp1 = v2Add([], point, v2);\n\t\n\t    if (constraint) {\n\t      v2Max(cp0, cp0, min);\n\t      v2Min(cp0, cp0, max);\n\t      v2Max(cp1, cp1, min);\n\t      v2Min(cp1, cp1, max);\n\t    }\n\t\n\t    cps.push(cp0);\n\t    cps.push(cp1);\n\t  }\n\t\n\t  if (isLoop) {\n\t    cps.push(cps.shift());\n\t  }\n\t\n\t  return cps;\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(47);\n\t\n\tvar polyHelper = __webpack_require__(66);\n\t\n\t/**\n\t * @module zrender/graphic/shape/Polyline\n\t */\n\tvar _default = Path.extend({\n\t  type: 'polyline',\n\t  shape: {\n\t    points: null,\n\t    smooth: false,\n\t    smoothConstraint: null\n\t  },\n\t  style: {\n\t    stroke: '#000',\n\t    fill: null\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    polyHelper.buildPath(ctx, shape, false);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(47);\n\t\n\tvar roundRectHelper = __webpack_require__(37);\n\t\n\t/**\n\t * 矩形\n\t * @module zrender/graphic/shape/Rect\n\t */\n\tvar _default = Path.extend({\n\t  type: 'rect',\n\t  shape: {\n\t    // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n\t    // r缩写为1         相当于 [1, 1, 1, 1]\n\t    // r缩写为[1]       相当于 [1, 1, 1, 1]\n\t    // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n\t    // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n\t    r: 0,\n\t    x: 0,\n\t    y: 0,\n\t    width: 0,\n\t    height: 0\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    var x = shape.x;\n\t    var y = shape.y;\n\t    var width = shape.width;\n\t    var height = shape.height;\n\t\n\t    if (!shape.r) {\n\t      ctx.rect(x, y, width, height);\n\t    } else {\n\t      roundRectHelper.buildPath(ctx, shape);\n\t    }\n\t\n\t    ctx.closePath();\n\t    return;\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(47);\n\t\n\t/**\n\t * 直线\n\t * @module zrender/graphic/shape/Line\n\t */\n\tvar _default = Path.extend({\n\t  type: 'line',\n\t  shape: {\n\t    // Start point\n\t    x1: 0,\n\t    y1: 0,\n\t    // End point\n\t    x2: 0,\n\t    y2: 0,\n\t    percent: 1\n\t  },\n\t  style: {\n\t    stroke: '#000',\n\t    fill: null\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    var x1 = shape.x1;\n\t    var y1 = shape.y1;\n\t    var x2 = shape.x2;\n\t    var y2 = shape.y2;\n\t    var percent = shape.percent;\n\t\n\t    if (percent === 0) {\n\t      return;\n\t    }\n\t\n\t    ctx.moveTo(x1, y1);\n\t\n\t    if (percent < 1) {\n\t      x2 = x1 * (1 - percent) + x2 * percent;\n\t      y2 = y1 * (1 - percent) + y2 * percent;\n\t    }\n\t\n\t    ctx.lineTo(x2, y2);\n\t  },\n\t\n\t  /**\n\t   * Get point at percent\n\t   * @param  {number} percent\n\t   * @return {Array.<number>}\n\t   */\n\t  pointAt: function (p) {\n\t    var shape = this.shape;\n\t    return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(47);\n\t\n\tvar vec2 = __webpack_require__(8);\n\t\n\tvar _curve = __webpack_require__(49);\n\t\n\tvar quadraticSubdivide = _curve.quadraticSubdivide;\n\tvar cubicSubdivide = _curve.cubicSubdivide;\n\tvar quadraticAt = _curve.quadraticAt;\n\tvar cubicAt = _curve.cubicAt;\n\tvar quadraticDerivativeAt = _curve.quadraticDerivativeAt;\n\tvar cubicDerivativeAt = _curve.cubicDerivativeAt;\n\t\n\t/**\n\t * 贝塞尔曲线\n\t * @module zrender/shape/BezierCurve\n\t */\n\tvar out = [];\n\t\n\tfunction someVectorAt(shape, t, isTangent) {\n\t  var cpx2 = shape.cpx2;\n\t  var cpy2 = shape.cpy2;\n\t\n\t  if (cpx2 === null || cpy2 === null) {\n\t    return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];\n\t  } else {\n\t    return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];\n\t  }\n\t}\n\t\n\tvar _default = Path.extend({\n\t  type: 'bezier-curve',\n\t  shape: {\n\t    x1: 0,\n\t    y1: 0,\n\t    x2: 0,\n\t    y2: 0,\n\t    cpx1: 0,\n\t    cpy1: 0,\n\t    // cpx2: 0,\n\t    // cpy2: 0\n\t    // Curve show percent, for animating\n\t    percent: 1\n\t  },\n\t  style: {\n\t    stroke: '#000',\n\t    fill: null\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    var x1 = shape.x1;\n\t    var y1 = shape.y1;\n\t    var x2 = shape.x2;\n\t    var y2 = shape.y2;\n\t    var cpx1 = shape.cpx1;\n\t    var cpy1 = shape.cpy1;\n\t    var cpx2 = shape.cpx2;\n\t    var cpy2 = shape.cpy2;\n\t    var percent = shape.percent;\n\t\n\t    if (percent === 0) {\n\t      return;\n\t    }\n\t\n\t    ctx.moveTo(x1, y1);\n\t\n\t    if (cpx2 == null || cpy2 == null) {\n\t      if (percent < 1) {\n\t        quadraticSubdivide(x1, cpx1, x2, percent, out);\n\t        cpx1 = out[1];\n\t        x2 = out[2];\n\t        quadraticSubdivide(y1, cpy1, y2, percent, out);\n\t        cpy1 = out[1];\n\t        y2 = out[2];\n\t      }\n\t\n\t      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n\t    } else {\n\t      if (percent < 1) {\n\t        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n\t        cpx1 = out[1];\n\t        cpx2 = out[2];\n\t        x2 = out[3];\n\t        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n\t        cpy1 = out[1];\n\t        cpy2 = out[2];\n\t        y2 = out[3];\n\t      }\n\t\n\t      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Get point at percent\n\t   * @param  {number} t\n\t   * @return {Array.<number>}\n\t   */\n\t  pointAt: function (t) {\n\t    return someVectorAt(this.shape, t, false);\n\t  },\n\t\n\t  /**\n\t   * Get tangent at percent\n\t   * @param  {number} t\n\t   * @return {Array.<number>}\n\t   */\n\t  tangentAt: function (t) {\n\t    var p = someVectorAt(this.shape, t, true);\n\t    return vec2.normalize(p, p);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(47);\n\t\n\t/**\n\t * 圆弧\n\t * @module zrender/graphic/shape/Arc\n\t */\n\tvar _default = Path.extend({\n\t  type: 'arc',\n\t  shape: {\n\t    cx: 0,\n\t    cy: 0,\n\t    r: 0,\n\t    startAngle: 0,\n\t    endAngle: Math.PI * 2,\n\t    clockwise: true\n\t  },\n\t  style: {\n\t    stroke: '#000',\n\t    fill: null\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    var x = shape.cx;\n\t    var y = shape.cy;\n\t    var r = Math.max(shape.r, 0);\n\t    var startAngle = shape.startAngle;\n\t    var endAngle = shape.endAngle;\n\t    var clockwise = shape.clockwise;\n\t    var unitX = Math.cos(startAngle);\n\t    var unitY = Math.sin(startAngle);\n\t    ctx.moveTo(unitX * r + x, unitY * r + y);\n\t    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrUtil = __webpack_require__(6);\n\t\n\tvar Gradient = __webpack_require__(59);\n\t\n\t/**\n\t * x, y, x2, y2 are all percent from 0 to 1\n\t * @param {number} [x=0]\n\t * @param {number} [y=0]\n\t * @param {number} [x2=1]\n\t * @param {number} [y2=0]\n\t * @param {Array.<Object>} colorStops\n\t * @param {boolean} [globalCoord=false]\n\t */\n\tvar LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n\t  // Should do nothing more in this constructor. Because gradient can be\n\t  // declard by `color: {type: 'linear', colorStops: ...}`, where\n\t  // this constructor will not be called.\n\t  this.x = x == null ? 0 : x;\n\t  this.y = y == null ? 0 : y;\n\t  this.x2 = x2 == null ? 1 : x2;\n\t  this.y2 = y2 == null ? 0 : y2; // Can be cloned\n\t\n\t  this.type = 'linear'; // If use global coord\n\t\n\t  this.global = globalCoord || false;\n\t  Gradient.call(this, colorStops);\n\t};\n\t\n\tLinearGradient.prototype = {\n\t  constructor: LinearGradient\n\t};\n\tzrUtil.inherits(LinearGradient, Gradient);\n\tvar _default = LinearGradient;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrUtil = __webpack_require__(6);\n\t\n\tvar Gradient = __webpack_require__(59);\n\t\n\t/**\n\t * x, y, r are all percent from 0 to 1\n\t * @param {number} [x=0.5]\n\t * @param {number} [y=0.5]\n\t * @param {number} [r=0.5]\n\t * @param {Array.<Object>} [colorStops]\n\t * @param {boolean} [globalCoord=false]\n\t */\n\tvar RadialGradient = function (x, y, r, colorStops, globalCoord) {\n\t  // Should do nothing more in this constructor. Because gradient can be\n\t  // declard by `color: {type: 'radial', colorStops: ...}`, where\n\t  // this constructor will not be called.\n\t  this.x = x == null ? 0.5 : x;\n\t  this.y = y == null ? 0.5 : y;\n\t  this.r = r == null ? 0.5 : r; // Can be cloned\n\t\n\t  this.type = 'radial'; // If use global coord\n\t\n\t  this.global = globalCoord || false;\n\t  Gradient.call(this, colorStops);\n\t};\n\t\n\tRadialGradient.prototype = {\n\t  constructor: RadialGradient\n\t};\n\tzrUtil.inherits(RadialGradient, Gradient);\n\tvar _default = RadialGradient;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrUtil = __webpack_require__(6);\n\t\n\tvar Style = __webpack_require__(28);\n\t\n\tvar _vector = __webpack_require__(8);\n\t\n\tvar vec2Copy = _vector.copy;\n\t\n\t/**\n\t * States machine for managing graphic states\n\t */\n\t\n\t/**\n\t * @typedef {Object} IGraphicState\n\t * @property {number} [zlevel]\n\t * @property {number} [z]\n\t * @property {Array.<number>} {position}\n\t * @property {Array.<number>|number} {rotation}\n\t * @property {Array.<number>} {scale}\n\t * @property {Object} style\n\t *\n\t * @property {Function} onenter\n\t * @property {Function} onleave\n\t * @property {Function} ontransition\n\t * @property {Array.<IGraphicStateTransition|string>} transition\n\t *           Transition object or a string descriptor like '* 30 0 Linear'\n\t */\n\tvar transitionProperties = ['position', 'rotation', 'scale', 'style', 'shape'];\n\t/**\n\t * @module zrender/graphic/States~TransitionObject\n\t */\n\t\n\tvar TransitionObject = function (opts) {\n\t  if (typeof opts == 'string') {\n\t    this._fromStr(opts);\n\t  } else if (opts) {\n\t    opts.property && (this.property = opts.property);\n\t    opts.duration != null && (this.duration = opts.duration);\n\t    opts.easing && (this.easing = opts.easing);\n\t    opts.delay && (this.delay = opts.delay);\n\t  }\n\t\n\t  if (this.property !== '*') {\n\t    this.property = this.property.split(',');\n\t  } else {\n\t    this.property = transitionProperties;\n\t  }\n\t};\n\t\n\tTransitionObject.prototype = {\n\t  constructor: TransitionObject,\n\t\n\t  /**\n\t   * List of all transition properties. Splitted by comma. Must not have spaces in the string.\n\t   * e.g. 'position,style.color'. '*' will match all the valid properties.\n\t   * @type {string}\n\t   * @default *\n\t   */\n\t  property: '*',\n\t\n\t  /**\n\t   * @type {string}\n\t   * @default 'Linear'\n\t   */\n\t  easing: 'Linear',\n\t\n\t  /**\n\t   * @type {number}\n\t   * @default 'number'\n\t   */\n\t  duration: 500,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  delay: 0,\n\t  _fromStr: function (str) {\n\t    var arr = str.split(/\\s+/g);\n\t    this.property = arr[0];\n\t    this.duration = +arr[1];\n\t    this.delay = +arr[2];\n\t    this.easing = arr[3];\n\t  }\n\t};\n\t/**\n\t * @alias module:zrender/graphic/States\n\t */\n\t\n\tvar GraphicStates = function (opts) {\n\t  opts = opts || {};\n\t  this._states = {};\n\t  /**\n\t   * Target element\n\t   * @type {zrender/graphic/Displayable|zrender/container/Group}\n\t   */\n\t\n\t  this._el = opts.el;\n\t  this._subStates = [];\n\t  this._transitionAnimators = [];\n\t\n\t  if (opts.initialState) {\n\t    this._initialState = opts.initialState;\n\t  }\n\t\n\t  var optsStates = opts.states;\n\t\n\t  if (optsStates) {\n\t    for (var name in optsStates) {\n\t      if (optsStates.hasOwnProperty(name)) {\n\t        var state = optsStates[name];\n\t\n\t        this._addState(name, state);\n\t      }\n\t    }\n\t  }\n\t\n\t  this.setState(this._initialState);\n\t};\n\t\n\tGraphicStates.prototype = {\n\t  constructor: GraphicStates,\n\t\n\t  /**\n\t   * All other state will be extended from initial state\n\t   * @type {string}\n\t   * @private\n\t   */\n\t  _initialState: 'normal',\n\t\n\t  /**\n\t   * Current state\n\t   * @type {string}\n\t   * @private\n\t   */\n\t  _currentState: '',\n\t  el: function () {\n\t    return this._el;\n\t  },\n\t  _addState: function (name, state) {\n\t    this._states[name] = state;\n\t\n\t    if (state.transition) {\n\t      state.transition = new TransitionObject(state.transition);\n\t    } // Extend from initial state\n\t\n\t\n\t    if (name !== this._initialState) {\n\t      this._extendFromInitial(state);\n\t    } else {\n\t      var el = this._el; // setState 的时候自带的 style 和 shape 都会被直接覆盖\n\t      // 所以这边先把自带的 style 和 shape 扩展到初始状态中\n\t\n\t      zrUtil.merge(state.style, el.style, false, false);\n\t\n\t      if (state.shape) {\n\t        zrUtil.merge(state.shape, el.shape, false, true);\n\t      } else {\n\t        state.shape = zrUtil.clone(el.shape, true);\n\t      }\n\t\n\t      for (var name in this._states) {\n\t        if (this._states.hasOwnProperty(name)) {\n\t          this._extendFromInitial(this._states[name]);\n\t        }\n\t      }\n\t    }\n\t  },\n\t  _extendFromInitial: function (state) {\n\t    var initialState = this._states[this._initialState];\n\t\n\t    if (initialState && state !== initialState) {\n\t      zrUtil.merge(state, initialState, false, true);\n\t    }\n\t  },\n\t  setState: function (name, silent) {\n\t    if (name === this._currentState && !this.transiting()) {\n\t      return;\n\t    }\n\t\n\t    var state = this._states[name];\n\t\n\t    if (state) {\n\t      this._stopTransition();\n\t\n\t      if (!silent) {\n\t        var prevState = this._states[this._currentState];\n\t\n\t        if (prevState) {\n\t          prevState.onleave && prevState.onleave.call(this);\n\t        }\n\t\n\t        state.onenter && state.onenter.call(this);\n\t      }\n\t\n\t      this._currentState = name;\n\t\n\t      if (this._el) {\n\t        var el = this._el; // Setting attributes\n\t\n\t        if (state.zlevel != null) {\n\t          el.zlevel = state.zlevel;\n\t        }\n\t\n\t        if (state.z != null) {\n\t          el.z = state.z;\n\t        } // SRT\n\t\n\t\n\t        state.position && vec2Copy(el.position, state.position);\n\t        state.scale && vec2Copy(el.scale, state.scale);\n\t\n\t        if (state.rotation != null) {\n\t          el.rotation = state.rotation;\n\t        } // Style\n\t\n\t\n\t        if (state.style) {\n\t          var initialState = this._states[this._initialState];\n\t          el.style = new Style();\n\t\n\t          if (initialState) {\n\t            el.style.extendFrom(initialState.style, false);\n\t          }\n\t\n\t          if ( // Not initial state\n\t          name != this._initialState // Not copied from initial state in _extendFromInitial method\n\t          && initialState.style !== state.style) {\n\t            el.style.extendFrom(state.style, true);\n\t          }\n\t        }\n\t\n\t        if (state.shape) {\n\t          el.shape = zrUtil.clone(state.shape, true);\n\t        }\n\t\n\t        el.dirty();\n\t      }\n\t    }\n\t\n\t    for (var i = 0; i < this._subStates.length; i++) {\n\t      this._subStates.setState(name);\n\t    }\n\t  },\n\t  getState: function () {\n\t    return this._currentState;\n\t  },\n\t  transitionState: function (target, done) {\n\t    if (target === this._currentState && !this.transiting()) {\n\t      return;\n\t    }\n\t\n\t    var state = this._states[target];\n\t    var styleShapeReg = /$[style|shape]\\./;\n\t    var self = this; // Animation 去重\n\t\n\t    var propPathMap = {};\n\t\n\t    if (state) {\n\t      self._stopTransition();\n\t\n\t      var el = self._el;\n\t\n\t      if (state.transition && el && el.__zr) {\n\t        // El can be animated\n\t        var transitionCfg = state.transition;\n\t        var property = transitionCfg.property;\n\t        var animatingCount = 0;\n\t\n\t        var animationDone = function () {\n\t          animatingCount--;\n\t\n\t          if (animatingCount === 0) {\n\t            self.setState(target);\n\t            done && done();\n\t          }\n\t        };\n\t\n\t        for (var i = 0; i < property.length; i++) {\n\t          var propName = property[i]; // Animating all the properties in style or shape\n\t\n\t          if (propName === 'style' || propName === 'shape') {\n\t            if (state[propName]) {\n\t              for (var key in state[propName]) {\n\t                if (!state[propName].hasOwnProperty(key)) {\n\t                  continue;\n\t                }\n\t\n\t                var path = propName + '.' + key;\n\t\n\t                if (propPathMap[path]) {\n\t                  continue;\n\t                }\n\t\n\t                propPathMap[path] = 1;\n\t                animatingCount += self._animProp(state, propName, key, transitionCfg, animationDone);\n\t              }\n\t            }\n\t          } else {\n\t            if (propPathMap[propName]) {\n\t              continue;\n\t            }\n\t\n\t            propPathMap[propName] = 1; // Animating particular property in style or style\n\t\n\t            if (propName.match(styleShapeReg)) {\n\t              // remove 'style.', 'shape.' prefix\n\t              var subProp = propName.slice(0, 5);\n\t              propName = propName.slice(6);\n\t              animatingCount += self._animProp(state, subProp, propName, transitionCfg, animationDone);\n\t            } else {\n\t              animatingCount += self._animProp(state, '', propName, transitionCfg, animationDone);\n\t            }\n\t          }\n\t        } // No transition properties\n\t\n\t\n\t        if (animatingCount === 0) {\n\t          self.setState(target);\n\t          done && done();\n\t        }\n\t      } else {\n\t        self.setState(target);\n\t        done && done();\n\t      }\n\t    }\n\t\n\t    var subStates = self._subStates;\n\t\n\t    for (var i = 0; i < subStates.length; i++) {\n\t      subStates.transitionState(target);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Do transition animation of particular property\n\t   * @param {Object} state\n\t   * @param {string} subPropKey\n\t   * @param {string} key\n\t   * @param {Object} transitionCfg\n\t   * @param {Function} done\n\t   * @private\n\t   */\n\t  _animProp: function (state, subPropKey, key, transitionCfg, done) {\n\t    var el = this._el;\n\t    var stateObj = subPropKey ? state[subPropKey] : state;\n\t    var elObj = subPropKey ? el[subPropKey] : el;\n\t    var availableProp = stateObj && key in stateObj && elObj && key in elObj;\n\t    var transitionAnimators = this._transitionAnimators;\n\t\n\t    if (availableProp) {\n\t      var obj = {};\n\t\n\t      if (stateObj[key] === elObj[key]) {\n\t        return 0;\n\t      }\n\t\n\t      obj[key] = stateObj[key];\n\t      var animator = el.animate(subPropKey).when(transitionCfg.duration, obj).delay(transitionCfg.dealy).done(function () {\n\t        var idx = zrUtil.indexOf(transitionAnimators, 1);\n\t\n\t        if (idx > 0) {\n\t          transitionAnimators.splice(idx, 1);\n\t        }\n\t\n\t        done();\n\t      }).start(transitionCfg.easing);\n\t      transitionAnimators.push(animator);\n\t      return 1;\n\t    }\n\t\n\t    return 0;\n\t  },\n\t  _stopTransition: function () {\n\t    var transitionAnimators = this._transitionAnimators;\n\t\n\t    for (var i = 0; i < transitionAnimators.length; i++) {\n\t      transitionAnimators[i].stop();\n\t    }\n\t\n\t    transitionAnimators.length = 0;\n\t  },\n\t  transiting: function () {\n\t    return this._transitionAnimators.length > 0;\n\t  },\n\t  addSubStates: function (states) {\n\t    this._subStates.push(states);\n\t  },\n\t  removeSubStates: function (states) {\n\t    var idx = zrUtil.indexOf(this._subStates, states);\n\t\n\t    if (idx >= 0) {\n\t      this._subStates.splice(states, 1);\n\t    }\n\t  }\n\t};\n\tvar _default = GraphicStates;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 事件决策多边形\r\n\t * @module fish-topo-bo/node/EventDecisionNode\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(43);\r\n\t    var graphic = __webpack_require__(45);\r\n\t    var nodeOptions = null;\r\n\t\r\n\t    function EventDecisionNode(data, opts) {\r\n\t        nodeOptions = opts;\r\n\t\r\n\t        /**\r\n\t         * BO属性数据\r\n\t         * @type {Object}\r\n\t         * @private\r\n\t         */\r\n\t        this._data = data;\r\n\t\r\n\t        /**\r\n\t         * 起始位置坐标\r\n\t         * @type {startPos}\r\n\t         * @private\r\n\t         */\r\n\t        this._startPos = opts.startPos;\r\n\t\r\n\t        this._type = opts.type || 'boEvent';\r\n\t\r\n\t        /**\r\n\t         * 是否支持点击\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._clickable = opts.clickable || false;\r\n\t        this._popupOpts = opts.popupOpts;\r\n\t\r\n\t        /**\r\n\t         * Group容器\r\n\t         * @type zrender/graphic/Group\r\n\t         * @private\r\n\t         */\r\n\t        this._group = new graphic.Group();\r\n\t        this._group.name = this._data.id;\r\n\t\r\n\t        //生成BO属性图形\r\n\t        this._render();\r\n\t    }\r\n\t\r\n\t    var eventProto = EventDecisionNode.prototype;\r\n\t\r\n\t    /**\r\n\t     * 获取关系整体图形\r\n\t     * @returns {zrender/graphic/Group}\r\n\t     */\r\n\t    eventProto.getShape = function () {\r\n\t        return this._group;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成事件决策图形\r\n\t     * @private\r\n\t     */\r\n\t    eventProto._render = function () {\r\n\t        //多边形\r\n\t        this._createEventShape();\r\n\t        //文字\r\n\t        this._createEVentName();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 事件决策多边形\r\n\t     * @private\r\n\t     */\r\n\t    eventProto._createEventShape = function () {\r\n\t\r\n\t        //多边形高度\r\n\t        var height = Const.BO_EVENT_HEIGHT,\r\n\t            x = this._startPos.x + 1,\r\n\t            y = this._startPos.y,\r\n\t            width = this._type == 'boEvent' ? Const.BO_EVENT_WIDTH : Const.BO_ATTR_EVENT_WIDTH,\r\n\t\r\n\t            shape = new graphic.Polygon({\r\n\t                name: this._data.id,\r\n\t                shape: {\r\n\t                    points: [\r\n\t                        [x, y],\r\n\t                        [x + width - 10, y],\r\n\t                        [x + width, y + height / 2],\r\n\t                        [x + width - 10, y + height],\r\n\t                        [x, y + height]]\r\n\t                },\r\n\t\r\n\t                style: {\r\n\t                    fill: '#FFCCCC',\r\n\t                    stroke: '#000000',\r\n\t                    lineWidth: 0.75\r\n\t                }\r\n\t\r\n\t            });\r\n\t\r\n\t        if (this._clickable) {\r\n\t            shape.clickable = this._clickable;\r\n\t            shape._data = this._data;\r\n\t            shape._popupOpts = this._popupOpts;\r\n\t            shape.onclick = this._click;\r\n\t        }\r\n\t\r\n\t\r\n\t        this._group.add(shape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 点击事件\r\n\t     * @private\r\n\t     */\r\n\t    eventProto._click = function () {\r\n\t        var options = Object.assign(\r\n\t            {\r\n\t                DATA: this._data\r\n\t            }, this._popupOpts);\r\n\t\r\n\t        nodeOptions.bindBoClickEvent(options);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 事件决策名称\r\n\t     * @private\r\n\t     */\r\n\t    eventProto._createEVentName = function () {\r\n\t        var x = this._startPos.x + (this._type == 'boEvent' ? Const.BO_ATTR_PADDING_LEFT : 15),\r\n\t            y = this._startPos.y,\r\n\t\r\n\t            eventNameShape = new graphic.Text({\r\n\t                style: {\r\n\t                    text: this._data.name,\r\n\t                    textFont: Const.BO_EVENT_FONT,\r\n\t                    textAlign: 'left',  //靠左开始，便于计算位置\r\n\t                    textBaseline: 'top'\r\n\t                },\r\n\t\r\n\t                position: [x, y]\r\n\t            });\r\n\t\r\n\t        if (this._clickable) {\r\n\t            eventNameShape.clickable = this._clickable;\r\n\t            eventNameShape._data = this._data;\r\n\t            eventNameShape._popupOpts = this._popupOpts;\r\n\t            eventNameShape.onclick = this._click;\r\n\t        }\r\n\t\r\n\t        this._group.add(eventNameShape);\r\n\t    };\r\n\t\r\n\t    module.exports = EventDecisionNode;\r\n\t\r\n\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * BO矩形内部的横线，分为实线和虚线两种\r\n\t * @module fish-topo-bo/node/LineNode\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t\r\n\t    var Const = __webpack_require__(43);\r\n\t    var graphic = __webpack_require__(45);\r\n\t    var util = __webpack_require__(6);\r\n\t    /**\r\n\t     * BO名字下面的实现\r\n\t     * @param {{x: *, y: *}} startPos, 开始坐标\r\n\t     * @returns {zrender/graphic/shape/Line}\r\n\t     * @constructor\r\n\t     */\r\n\t    function BoLine(startPos) {\r\n\t\r\n\t        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y};\r\n\t\r\n\t        return _line(startPos, endPos);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * BO属性之间的虚线\r\n\t     * @param {{x: *, y: *}} startPos, 开始坐标\r\n\t     * @returns {zrender/graphic/shape/Line}\r\n\t     * @constructor\r\n\t     */\r\n\t    function AttrLine(startPos) {\r\n\t\r\n\t        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y},\r\n\t            style = {lineDash: [Const.LINE_DASH]};\r\n\t\r\n\t        return _line(startPos, endPos, style);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * BO属性与BO事件决策之间的垂直虚线\r\n\t     * @param {{x: *, y: *}} startPos, 开始坐标\r\n\t     * @param {int} attrHeight, 高度\r\n\t     * @returns {zrender/graphic/shape/Line}\r\n\t     * @constructor\r\n\t     */\r\n\t    function AttrEventLine(startPos, attrHeight) {\r\n\t        var endPos = {x: startPos.x, y: startPos.y + attrHeight},\r\n\t            style = {lineDash: [Const.LINE_DASH]};\r\n\t\r\n\t        return _line(startPos, endPos, style);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 画线\r\n\t     * @param {{x: *, y: *}} startPos, 开始坐标\r\n\t     * @param {{x: *, y: *}} endPos, 结束坐标\r\n\t     * @param {Object} style, 样式,可空\r\n\t     * @returns {zrender/graphic/shape/Line}\r\n\t     * @private\r\n\t     */\r\n\t    function _line(startPos, endPos, style) {\r\n\t\r\n\t        var _style = {\r\n\t            strokeColor: '#000000',\r\n\t            lineWidth: 0.5,\r\n\t            percent: 1\r\n\t        };\r\n\t\r\n\t        util.extend(_style, style);\r\n\t\r\n\t        var shape = new graphic.Line({\r\n\t            shape: {\r\n\t                // Start point\r\n\t                x1: startPos.x,\r\n\t                y1: startPos.y,\r\n\t\r\n\t                // End point\r\n\t                x2: endPos.x,\r\n\t                y2: endPos.y,\r\n\t\r\n\t                percent: 1\r\n\t            },\r\n\t\r\n\t            style: _style\r\n\t        });\r\n\t\r\n\t        return shape;\r\n\t    }\r\n\t\r\n\t\r\n\t    module.exports = {\r\n\t        BoLine: BoLine,\r\n\t        AttrLine: AttrLine,\r\n\t        AttrEventLine: AttrEventLine\r\n\t    };\r\n\t\r\n\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * BO属性\r\n\t * 1.BO属性名字\r\n\t * 2.BO属性数据类型\r\n\t * 3.BO属性事件决策\r\n\t * @module fish-topo-bo/node/BoAttrNode\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(43);\r\n\t    var EventDecision = __webpack_require__(77);\r\n\t    var graphic = __webpack_require__(45);\r\n\t    var nodeOptions = null;\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     * @param {{\r\n\t     *          id: String bo属性标识,\r\n\t     *          code: String bo属性编码\r\n\t     *          keyValue: boolean 是否为主键,\r\n\t     *          dataType: String 属性数据类型,\r\n\t     *          boAttrEventArr:[] 属性事件决策数组\r\n\t     *          }} boAttrData BO属性数据对象,\r\n\t     * @param {{\r\n\t     *          startPos: {x: number, y: number}起始位置,\r\n\t     *          displayDataType: boolean 是否显示数据类型,\r\n\t     *          displayEventDecision: boolean 是否显示事件决策,\r\n\t     *          eventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false,\r\n\t     *          eventPopupOpts: Object 点击BO属性事件决策弹出页面参数，url,width,height等,\r\n\t     *          }} opts\r\n\t     * @constructor\r\n\t     */\r\n\t    function BoAttr(boAttrData, opts) {\r\n\t        nodeOptions = opts;\r\n\t\r\n\t        /**\r\n\t         * BO属性数据\r\n\t         * @type {Object}\r\n\t         * @private\r\n\t         */\r\n\t        this._data = boAttrData;\r\n\t\r\n\t        /**\r\n\t         * 是否为主键\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._keyValue = boAttrData.keyValue || false;\r\n\t\r\n\t        /**\r\n\t         * 起始位置坐标\r\n\t         * @type {startPos}\r\n\t         * @private\r\n\t         */\r\n\t        this._startPos = opts.startPos;\r\n\t\r\n\t        /**\r\n\t         * 是否显示数据类型\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._displayDataType = opts.displayDataType || false;\r\n\t\r\n\t        /**\r\n\t         * 是否显示事件决策\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._displayEventDecision = opts.displayEventDecision || false;\r\n\t\r\n\t        /**\r\n\t         * 是否支持点击\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._eventClickable = opts.eventClickable || false;\r\n\t        this._eventPopupOpts = opts.eventPopupOpts;\r\n\t\r\n\t        /**\r\n\t         * Group容器\r\n\t         * @type zrender/graphic/Group\r\n\t         * @private\r\n\t         */\r\n\t        this._group = new graphic.Group();\r\n\t        this._group.name = this._data.id;\r\n\t\r\n\t        //生成BO属性图形\r\n\t        this._render();\r\n\t    }\r\n\t\r\n\t    var boAttrProto = BoAttr.prototype;\r\n\t\r\n\t    /**\r\n\t     * 获取关系整体图形\r\n\t     * @returns {zrender/graphic/Group}\r\n\t     */\r\n\t    boAttrProto.getShape = function () {\r\n\t        return this._group;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 生成BO属性图形\r\n\t     * @private\r\n\t     */\r\n\t    boAttrProto._render = function () {\r\n\t        //属性名字\r\n\t        this._createText();\r\n\t\r\n\t        //属性数据类型\r\n\t        this._createDataType();\r\n\t\r\n\t        //属性事件决策\r\n\t        this._createEventDecision();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 属性名字\r\n\t     * @private\r\n\t     */\r\n\t    boAttrProto._createText = function () {\r\n\t\r\n\t        var x = this._startPos.x + Const.BO_ATTR_PADDING_LEFT,\r\n\t            y = this._startPos.y,\r\n\t\r\n\t            attrNameShape = new graphic.Text({\r\n\t                style: {\r\n\t                    text: this._data.name,\r\n\t                    textFont: Const.BO_ATTR_FONT,\r\n\t                    textAlign: 'left',  //靠左开始，便于计算位置\r\n\t                    textBaseline: 'top',\r\n\t                    //lineWidth: 1,\r\n\t                    fill: this._keyValue ? 'red' : 'black'\r\n\t                },\r\n\t\r\n\t                position: [x, y]\r\n\t            });\r\n\t\r\n\t        //重新设置图形高度 = 文本高度 + padding-top + padding-bottom\r\n\t        attrNameShape.getBoundingRect().height += Const.BO_ATTR_PADDING_TOP + Const.BO_ATTR_PADDING_BOTTOM;\r\n\t        //重新设置图形高度 = BO矩形宽度，用于后续Relation画图计算\r\n\t        attrNameShape.getBoundingRect().width = Const.BO_NODE_WIDTH;\r\n\t\r\n\t        //重新设置B起始水平坐标 = 减去偏移量\r\n\t        attrNameShape.getBoundingRect().x += -Const.BO_ATTR_PADDING_LEFT;\r\n\t        //attrNameShape.getBoundingRect().y = + attrNameShape.position[1];\r\n\t\r\n\t        this._group.add(attrNameShape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 属性数据类型\r\n\t     * @private\r\n\t     */\r\n\t    boAttrProto._createDataType = function () {\r\n\t        if (!this._displayDataType) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var x = this._startPos.x + Const.BO_NODE_WIDTH - 10,\r\n\t            y = this._startPos.y,\r\n\t            textAlign = 'right';\r\n\t\r\n\t        //如果还要显示事件决策，则宽度重新计算\r\n\t        if (this._displayEventDecision) {\r\n\t            textAlign = 'left';\r\n\t            x = this._startPos.x + Const.BO_NODE_WIDTH / 3;\r\n\t        }\r\n\t\r\n\t        var _dataTypeShape = new graphic.Text({\r\n\t            style: {\r\n\t                text: this._data.dataType || '',\r\n\t                textFont: Const.BO_ATTR_FONT,\r\n\t                textAlign: textAlign,  //靠左开始，便于计算位置\r\n\t                textBaseline: 'top',\r\n\t                lineWidth: 1\r\n\t            },\r\n\t\r\n\t            position: [x, y]\r\n\t        });\r\n\t\r\n\t        this._group.add(_dataTypeShape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 属性事件决策\r\n\t     * @private\r\n\t     */\r\n\t    boAttrProto._createEventDecision = function () {\r\n\t        if (!this._displayEventDecision) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var _boAttrEventArr = this._data.boAttrEventArr || [],\r\n\t            _boAttrEventLen = _boAttrEventArr.length,\r\n\t            padding = (_boAttrEventLen > 1) ? 10 : 0,\r\n\t            _startPos = {\r\n\t                x: this._startPos.x + Const.BO_NODE_WIDTH / 2 + Const.BO_ATTR_EVENT_WIDTH * (_boAttrEventLen - 1) - padding,\r\n\t                y: this._startPos.y\r\n\t            };\r\n\t\r\n\t        //从右向左画，\r\n\t        for (var i = _boAttrEventLen - 1; i >= 0; i--) {\r\n\t            this._group.add(new EventDecision(_boAttrEventArr[i], {\r\n\t                startPos: _startPos,\r\n\t                type: 'boAttrEvent',\r\n\t                clickable: this._eventClickable,\r\n\t                popupOpts: this._eventPopupOpts,\r\n\t                bindBoClickEvent: nodeOptions.bindBoClickEvent\r\n\t            }).getShape());\r\n\t            _startPos = {x: _startPos.x - Const.BO_ATTR_EVENT_WIDTH + 10, y: _startPos.y};\r\n\t        }\r\n\t        /*_startPos = {\r\n\t         x: this._startPos.x + Const.BO_NODE_WIDTH / 2,\r\n\t         y: this._startPos.y};\r\n\t\r\n\t         for (var i = 0; i < _boAttrEventLen; i++) {\r\n\t         this._group.add(event.BoAttrEvent(_boAttrEventArr[i], _startPos, i + 2));\r\n\t         _startPos = {x: _startPos.x + Const.BO_ATTR_EVENT_WIDTH - 5, y: _startPos.y};\r\n\t         }*/\r\n\t\r\n\t\r\n\t    };\r\n\t\r\n\t    module.exports = BoAttr;\r\n\t\r\n\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 用来创建关联关系\r\n\t * 关联关系包括折线、箭头、关系文字说明\r\n\t * @module fish-topo-bo/node/Relation\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(43);\r\n\t    var graphic = __webpack_require__(45);\r\n\t    var zrUtil = __webpack_require__(6);\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     * @param sourceShape, 开始图形\r\n\t     * @param targetShape, 目标图形\r\n\t     * @param {String} sourceText, 关系开始文字说明,可空\r\n\t     * @param {String} targetText, 关系结束文字说明,可空\r\n\t     * @param {String} lineStyle, 关联线样式\r\n\t     * @param {String} lineHoverStyle, 关联线hover样式\r\n\t     * @param {String} arrowStyle, 关联线箭头样式\r\n\t     * @param {String} arrowHoverStyle, 关联线箭头hover样式\r\n\t     * @constructor\r\n\t     */\r\n\t    function Relation(sourceShape, targetShape, sourceText, targetText, lineStyle, lineHoverStyle, arrowStyle, arrowHoverStyle) {\r\n\t        this._sourceText = sourceText;\r\n\t        this._targetText = targetText;\r\n\t\r\n\t        this._group = new graphic.Group();\r\n\t\r\n\t        //左侧开始位置\r\n\t        this._lStartPos = {\r\n\t            x: sourceShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,\r\n\t            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2\r\n\t        };\r\n\t\r\n\t        //左侧结束位置\r\n\t        this._lEndPos = {\r\n\t            x: targetShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,\r\n\t            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2\r\n\t        };\r\n\t\r\n\t        //右侧开始位置\r\n\t        this._rStartPos = {\r\n\t            x: sourceShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,\r\n\t            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2\r\n\t        };\r\n\t\r\n\t        //右侧结束位置\r\n\t        this._rEndPos = {\r\n\t            x: targetShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,\r\n\t            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2\r\n\t        };\r\n\t\r\n\t        //判断画线方向\r\n\t        this._leftDirection = this._lStartPos.x - this._lEndPos.x <= 0;\r\n\t\r\n\t        //关联线样式\r\n\t        this._lineStyle = lineStyle;\r\n\t\r\n\t        //关联线hover样式\r\n\t        this._lineHoverStyle = lineHoverStyle;\r\n\t\r\n\t        //关联线箭头样式\r\n\t        this._arrowStyle = arrowStyle;\r\n\t\r\n\t        //关联线箭头hover样式\r\n\t        this._arrowHoverStyle = arrowHoverStyle;\r\n\t\r\n\t        //生成图形\r\n\t        this._render();\r\n\t    }\r\n\t\r\n\t    var relationProto = Relation.prototype;\r\n\t\r\n\t    /**\r\n\t     * 获取关系整体图形\r\n\t     * @returns {*}\r\n\t     */\r\n\t    relationProto.getShape = function () {\r\n\t        return this._group;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成关系整体图形\r\n\t     * @private\r\n\t     */\r\n\t    relationProto._render = function () {\r\n\t        //画线\r\n\t        this._createLine();\r\n\t\r\n\t        //箭头\r\n\t        this._createArrow();\r\n\t\r\n\t        //关系说明文字\r\n\t        this._createText();\r\n\t\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成关系折线\r\n\t     * @private\r\n\t     */\r\n\t    relationProto._createLine = function () {\r\n\t        var _linePoints = [];\r\n\t\r\n\t        if (this._leftDirection) {\r\n\t            //第一点\r\n\t            _linePoints.push([this._lStartPos.x, this._lStartPos.y]);\r\n\t            //第二点\r\n\t            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lStartPos.y]);\r\n\t            //第三点\r\n\t            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lEndPos.y]);\r\n\t            //第四点\r\n\t            _linePoints.push([this._lEndPos.x, this._lEndPos.y]);\r\n\t        }\r\n\t        else {\r\n\t            //第一点\r\n\t            _linePoints.push([this._rStartPos.x, this._rStartPos.y]);\r\n\t            //第二点\r\n\t            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._lStartPos.y]);\r\n\t            //第三点\r\n\t            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._rEndPos.y]);\r\n\t            //第四点\r\n\t            _linePoints.push([this._rEndPos.x, this._rEndPos.y]);\r\n\t        }\r\n\t\r\n\t        var _lineShape = new graphic.Polyline({\r\n\t            shape: {\r\n\t                points: _linePoints\r\n\t            },\r\n\t\r\n\t            style: {\r\n\t                //fill: 'blue',\r\n\t                stroke: this._lineStyle.stroke,\r\n\t                lineWidth: this._lineStyle.lineWidth,\r\n\t                lineDash: this._lineStyle.lineDash\r\n\t            }\r\n\t\r\n\t        });\r\n\t\r\n\t        this._group.add(_lineShape);\r\n\t\r\n\t        //线hover\r\n\t        this._createHoverStyle(_lineShape, this._lineHoverStyle);\r\n\t\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成箭头图形\r\n\t     * @private\r\n\t     */\r\n\t    relationProto._createArrow = function () {\r\n\t        var _arrowPoints = [];\r\n\t\r\n\t        if (this._leftDirection) {\r\n\t            //右侧第一点\r\n\t            _arrowPoints.push([this._lEndPos.x, this._lEndPos.y]);\r\n\t            //下面第二点\r\n\t            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y + Const.RELATION_ARROW_HEIGHT]);\r\n\t            //上面第三点\r\n\t            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_ARROW_HEIGHT]);\r\n\t        }\r\n\t        else {\r\n\t            //左侧第一点\r\n\t            _arrowPoints.push([this._rEndPos.x, this._rEndPos.y]);\r\n\t            //下面第二点\r\n\t            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y + Const.RELATION_ARROW_HEIGHT]);\r\n\t            //上面第三点\r\n\t            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_ARROW_HEIGHT]);\r\n\t        }\r\n\t\r\n\t        var _arrowShape = new graphic.Polyline({\r\n\t            shape: {\r\n\t                points: _arrowPoints\r\n\t            },\r\n\t\r\n\t            style: {\r\n\t                fill: this._arrowStyle.fill,\r\n\t                stroke: this._arrowStyle.stroke\r\n\t            }\r\n\t        });\r\n\t\r\n\t        this._group.add(_arrowShape);\r\n\t\r\n\t        //箭头hover\r\n\t        this._createHoverStyle(_arrowShape, this._arrowHoverStyle);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成文字说明\r\n\t     * @private\r\n\t     */\r\n\t    relationProto._createText = function () {\r\n\t        var _sourceTextPos,\r\n\t            _targetTextPos,\r\n\t            _textAlign;\r\n\t\r\n\t        if (this._leftDirection) {\r\n\t            _sourceTextPos = [this._lStartPos.x - 10, this._lStartPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n\t            _targetTextPos = [this._lEndPos.x - 10 - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n\t            _textAlign = 'right';\r\n\t        }\r\n\t        else {\r\n\t            _sourceTextPos = [this._rStartPos.x + 10, this._rStartPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n\t            _targetTextPos = [this._rEndPos.x + 10 + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n\t            _textAlign = 'left';\r\n\t        }\r\n\t\r\n\t        //开始文字\r\n\t        if (this._sourceText) {\r\n\t            var _srcTextShape = new graphic.Text({\r\n\t                position: _sourceTextPos,\r\n\t\r\n\t                style: {\r\n\t                    text: this._sourceText,\r\n\t                    textFont: Const.BO_ATTR_FONT,\r\n\t                    textAlign: _textAlign,\r\n\t                    textBaseline: 'buttom',\r\n\t                    lineWidth: 1\r\n\t                }\r\n\t            });\r\n\t            this._group.add(_srcTextShape);\r\n\t        }\r\n\t\r\n\t        //结束文字\r\n\t        if (this._targetText) {\r\n\t            var _targetTextShape = new graphic.Text({\r\n\t                position: _targetTextPos,\r\n\t\r\n\t                style: {\r\n\t                    text: this._targetText,\r\n\t                    textFont: Const.BO_ATTR_FONT,\r\n\t                    textAlign: _textAlign,\r\n\t                    textBaseline: 'buttom',\r\n\t                    lineWidth: 1\r\n\t                }\r\n\t            });\r\n\t            this._group.add(_targetTextShape);\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 关联线hover\r\n\t     * @private\r\n\t     */\r\n\t    relationProto._createHoverStyle = function (el, style) {\r\n\t        if (style) {\r\n\t            graphic.setElementHoverStl(el, style);\r\n\t            el.on('mouseover', zrUtil.bind(function() {\r\n\t                graphic.doEnterHover(el);\r\n\t                this._group.eachChild(function(line) {\r\n\t                    graphic.doEnterHover(line);\r\n\t                });\r\n\t            }, this))\r\n\t            .on('mouseout', zrUtil.bind(function() {\r\n\t                graphic.doLeaveHover(el);\r\n\t                this._group.eachChild(function(line) {\r\n\t                    graphic.doLeaveHover(line);\r\n\t                });\r\n\t            }, this));\r\n\t        }\r\n\t    };\r\n\t\r\n\t    module.exports = Relation;\r\n\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports) {\n\n\t\r\n\t    if (typeof Object.assign != 'function') {\r\n\t        // Must be writable: true, enumerable: false, configurable: true\r\n\t        Object.defineProperty(Object, \"assign\", {\r\n\t            value: function assign(target, varArgs) { // .length of function is 2\r\n\t                'use strict';\r\n\t                if (target == null) { // TypeError if undefined or null\r\n\t                    throw new TypeError('Cannot convert undefined or null to object');\r\n\t                }\r\n\t\r\n\t                var to = Object(target);\r\n\t\r\n\t                for (var index = 1; index < arguments.length; index++) {\r\n\t                    var nextSource = arguments[index];\r\n\t\r\n\t                    if (nextSource != null) { // Skip over if undefined or null\r\n\t                    for (var nextKey in nextSource) {\r\n\t                        // Avoid bugs when hasOwnProperty is shadowed\r\n\t                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\r\n\t                        to[nextKey] = nextSource[nextKey];\r\n\t                        }\r\n\t                    }\r\n\t                    }\r\n\t                }\r\n\t                return to;\r\n\t            },\r\n\t            writable: true,\r\n\t            configurable: true\r\n\t        });\r\n\t    }\r\n\t\r\n\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(83);\n\t\n\tvar _zrender = __webpack_require__(3);\n\t\n\tvar registerPainter = _zrender.registerPainter;\n\t\n\tvar Painter = __webpack_require__(85);\n\t\n\tregisterPainter('vml', Painter);\n\n/***/ }),\n/* 83 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar env = __webpack_require__(5);\n\t\n\tvar _vector = __webpack_require__(8);\n\t\n\tvar applyTransform = _vector.applyTransform;\n\t\n\tvar BoundingRect = __webpack_require__(24);\n\t\n\tvar colorTool = __webpack_require__(20);\n\t\n\tvar textContain = __webpack_require__(35);\n\t\n\tvar textHelper = __webpack_require__(34);\n\t\n\tvar RectText = __webpack_require__(33);\n\t\n\tvar Displayable = __webpack_require__(32);\n\t\n\tvar ZImage = __webpack_require__(31);\n\t\n\tvar Text = __webpack_require__(60);\n\t\n\tvar Path = __webpack_require__(47);\n\t\n\tvar PathProxy = __webpack_require__(48);\n\t\n\tvar Gradient = __webpack_require__(59);\n\t\n\tvar vmlCore = __webpack_require__(84);\n\t\n\t// http://www.w3.org/TR/NOTE-VML\n\t// TODO Use proxy like svg instead of overwrite brush methods\n\tvar CMD = PathProxy.CMD;\n\tvar round = Math.round;\n\tvar sqrt = Math.sqrt;\n\tvar abs = Math.abs;\n\tvar cos = Math.cos;\n\tvar sin = Math.sin;\n\tvar mathMax = Math.max;\n\t\n\tif (!env.canvasSupported) {\n\t  var comma = ',';\n\t  var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n\t  var Z = 21600;\n\t  var Z2 = Z / 2;\n\t  var ZLEVEL_BASE = 100000;\n\t  var Z_BASE = 1000;\n\t\n\t  var initRootElStyle = function (el) {\n\t    el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n\t    el.coordsize = Z + ',' + Z;\n\t    el.coordorigin = '0,0';\n\t  };\n\t\n\t  var encodeHtmlAttribute = function (s) {\n\t    return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n\t  };\n\t\n\t  var rgb2Str = function (r, g, b) {\n\t    return 'rgb(' + [r, g, b].join(',') + ')';\n\t  };\n\t\n\t  var append = function (parent, child) {\n\t    if (child && parent && child.parentNode !== parent) {\n\t      parent.appendChild(child);\n\t    }\n\t  };\n\t\n\t  var remove = function (parent, child) {\n\t    if (child && parent && child.parentNode === parent) {\n\t      parent.removeChild(child);\n\t    }\n\t  };\n\t\n\t  var getZIndex = function (zlevel, z, z2) {\n\t    // z 的取值范围为 [0, 1000]\n\t    return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n\t  };\n\t\n\t  var parsePercent = function (value, maxValue) {\n\t    if (typeof value === 'string') {\n\t      if (value.lastIndexOf('%') >= 0) {\n\t        return parseFloat(value) / 100 * maxValue;\n\t      }\n\t\n\t      return parseFloat(value);\n\t    }\n\t\n\t    return value;\n\t  };\n\t  /***************************************************\n\t   * PATH\n\t   **************************************************/\n\t\n\t\n\t  var setColorAndOpacity = function (el, color, opacity) {\n\t    var colorArr = colorTool.parse(color);\n\t    opacity = +opacity;\n\t\n\t    if (isNaN(opacity)) {\n\t      opacity = 1;\n\t    }\n\t\n\t    if (colorArr) {\n\t      el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n\t      el.opacity = opacity * colorArr[3];\n\t    }\n\t  };\n\t\n\t  var getColorAndAlpha = function (color) {\n\t    var colorArr = colorTool.parse(color);\n\t    return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];\n\t  };\n\t\n\t  var updateFillNode = function (el, style, zrEl) {\n\t    // TODO pattern\n\t    var fill = style.fill;\n\t\n\t    if (fill != null) {\n\t      // Modified from excanvas\n\t      if (fill instanceof Gradient) {\n\t        var gradientType;\n\t        var angle = 0;\n\t        var focus = [0, 0]; // additional offset\n\t\n\t        var shift = 0; // scale factor for offset\n\t\n\t        var expansion = 1;\n\t        var rect = zrEl.getBoundingRect();\n\t        var rectWidth = rect.width;\n\t        var rectHeight = rect.height;\n\t\n\t        if (fill.type === 'linear') {\n\t          gradientType = 'gradient';\n\t          var transform = zrEl.transform;\n\t          var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n\t          var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n\t\n\t          if (transform) {\n\t            applyTransform(p0, p0, transform);\n\t            applyTransform(p1, p1, transform);\n\t          }\n\t\n\t          var dx = p1[0] - p0[0];\n\t          var dy = p1[1] - p0[1];\n\t          angle = Math.atan2(dx, dy) * 180 / Math.PI; // The angle should be a non-negative number.\n\t\n\t          if (angle < 0) {\n\t            angle += 360;\n\t          } // Very small angles produce an unexpected result because they are\n\t          // converted to a scientific notation string.\n\t\n\t\n\t          if (angle < 1e-6) {\n\t            angle = 0;\n\t          }\n\t        } else {\n\t          gradientType = 'gradientradial';\n\t          var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n\t          var transform = zrEl.transform;\n\t          var scale = zrEl.scale;\n\t          var width = rectWidth;\n\t          var height = rectHeight;\n\t          focus = [// Percent in bounding rect\n\t          (p0[0] - rect.x) / width, (p0[1] - rect.y) / height];\n\t\n\t          if (transform) {\n\t            applyTransform(p0, p0, transform);\n\t          }\n\t\n\t          width /= scale[0] * Z;\n\t          height /= scale[1] * Z;\n\t          var dimension = mathMax(width, height);\n\t          shift = 2 * 0 / dimension;\n\t          expansion = 2 * fill.r / dimension - shift;\n\t        } // We need to sort the color stops in ascending order by offset,\n\t        // otherwise IE won't interpret it correctly.\n\t\n\t\n\t        var stops = fill.colorStops.slice();\n\t        stops.sort(function (cs1, cs2) {\n\t          return cs1.offset - cs2.offset;\n\t        });\n\t        var length = stops.length; // Color and alpha list of first and last stop\n\t\n\t        var colorAndAlphaList = [];\n\t        var colors = [];\n\t\n\t        for (var i = 0; i < length; i++) {\n\t          var stop = stops[i];\n\t          var colorAndAlpha = getColorAndAlpha(stop.color);\n\t          colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n\t\n\t          if (i === 0 || i === length - 1) {\n\t            colorAndAlphaList.push(colorAndAlpha);\n\t          }\n\t        }\n\t\n\t        if (length >= 2) {\n\t          var color1 = colorAndAlphaList[0][0];\n\t          var color2 = colorAndAlphaList[1][0];\n\t          var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n\t          var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n\t          el.type = gradientType;\n\t          el.method = 'none';\n\t          el.focus = '100%';\n\t          el.angle = angle;\n\t          el.color = color1;\n\t          el.color2 = color2;\n\t          el.colors = colors.join(','); // When colors attribute is used, the meanings of opacity and o:opacity2\n\t          // are reversed.\n\t\n\t          el.opacity = opacity2; // FIXME g_o_:opacity ?\n\t\n\t          el.opacity2 = opacity1;\n\t        }\n\t\n\t        if (gradientType === 'radial') {\n\t          el.focusposition = focus.join(',');\n\t        }\n\t      } else {\n\t        // FIXME Change from Gradient fill to color fill\n\t        setColorAndOpacity(el, fill, style.opacity);\n\t      }\n\t    }\n\t  };\n\t\n\t  var updateStrokeNode = function (el, style) {\n\t    // if (style.lineJoin != null) {\n\t    //     el.joinstyle = style.lineJoin;\n\t    // }\n\t    // if (style.miterLimit != null) {\n\t    //     el.miterlimit = style.miterLimit * Z;\n\t    // }\n\t    // if (style.lineCap != null) {\n\t    //     el.endcap = style.lineCap;\n\t    // }\n\t    if (style.lineDash != null) {\n\t      el.dashstyle = style.lineDash.join(' ');\n\t    }\n\t\n\t    if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n\t      setColorAndOpacity(el, style.stroke, style.opacity);\n\t    }\n\t  };\n\t\n\t  var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n\t    var isFill = type == 'fill';\n\t    var el = vmlEl.getElementsByTagName(type)[0]; // Stroke must have lineWidth\n\t\n\t    if (style[type] != null && style[type] !== 'none' && (isFill || !isFill && style.lineWidth)) {\n\t      vmlEl[isFill ? 'filled' : 'stroked'] = 'true'; // FIXME Remove before updating, or set `colors` will throw error\n\t\n\t      if (style[type] instanceof Gradient) {\n\t        remove(vmlEl, el);\n\t      }\n\t\n\t      if (!el) {\n\t        el = vmlCore.createNode(type);\n\t      }\n\t\n\t      isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n\t      append(vmlEl, el);\n\t    } else {\n\t      vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n\t      remove(vmlEl, el);\n\t    }\n\t  };\n\t\n\t  var points = [[], [], []];\n\t\n\t  var pathDataToString = function (path, m) {\n\t    var M = CMD.M;\n\t    var C = CMD.C;\n\t    var L = CMD.L;\n\t    var A = CMD.A;\n\t    var Q = CMD.Q;\n\t    var str = [];\n\t    var nPoint;\n\t    var cmdStr;\n\t    var cmd;\n\t    var i;\n\t    var xi;\n\t    var yi;\n\t    var data = path.data;\n\t    var dataLength = path.len();\n\t\n\t    for (i = 0; i < dataLength;) {\n\t      cmd = data[i++];\n\t      cmdStr = '';\n\t      nPoint = 0;\n\t\n\t      switch (cmd) {\n\t        case M:\n\t          cmdStr = ' m ';\n\t          nPoint = 1;\n\t          xi = data[i++];\n\t          yi = data[i++];\n\t          points[0][0] = xi;\n\t          points[0][1] = yi;\n\t          break;\n\t\n\t        case L:\n\t          cmdStr = ' l ';\n\t          nPoint = 1;\n\t          xi = data[i++];\n\t          yi = data[i++];\n\t          points[0][0] = xi;\n\t          points[0][1] = yi;\n\t          break;\n\t\n\t        case Q:\n\t        case C:\n\t          cmdStr = ' c ';\n\t          nPoint = 3;\n\t          var x1 = data[i++];\n\t          var y1 = data[i++];\n\t          var x2 = data[i++];\n\t          var y2 = data[i++];\n\t          var x3;\n\t          var y3;\n\t\n\t          if (cmd === Q) {\n\t            // Convert quadratic to cubic using degree elevation\n\t            x3 = x2;\n\t            y3 = y2;\n\t            x2 = (x2 + 2 * x1) / 3;\n\t            y2 = (y2 + 2 * y1) / 3;\n\t            x1 = (xi + 2 * x1) / 3;\n\t            y1 = (yi + 2 * y1) / 3;\n\t          } else {\n\t            x3 = data[i++];\n\t            y3 = data[i++];\n\t          }\n\t\n\t          points[0][0] = x1;\n\t          points[0][1] = y1;\n\t          points[1][0] = x2;\n\t          points[1][1] = y2;\n\t          points[2][0] = x3;\n\t          points[2][1] = y3;\n\t          xi = x3;\n\t          yi = y3;\n\t          break;\n\t\n\t        case A:\n\t          var x = 0;\n\t          var y = 0;\n\t          var sx = 1;\n\t          var sy = 1;\n\t          var angle = 0;\n\t\n\t          if (m) {\n\t            // Extract SRT from matrix\n\t            x = m[4];\n\t            y = m[5];\n\t            sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n\t            sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n\t            angle = Math.atan2(-m[1] / sy, m[0] / sx);\n\t          }\n\t\n\t          var cx = data[i++];\n\t          var cy = data[i++];\n\t          var rx = data[i++];\n\t          var ry = data[i++];\n\t          var startAngle = data[i++] + angle;\n\t          var endAngle = data[i++] + startAngle + angle; // FIXME\n\t          // var psi = data[i++];\n\t\n\t          i++;\n\t          var clockwise = data[i++];\n\t          var x0 = cx + cos(startAngle) * rx;\n\t          var y0 = cy + sin(startAngle) * ry;\n\t          var x1 = cx + cos(endAngle) * rx;\n\t          var y1 = cy + sin(endAngle) * ry;\n\t          var type = clockwise ? ' wa ' : ' at ';\n\t\n\t          if (Math.abs(x0 - x1) < 1e-4) {\n\t            // IE won't render arches drawn counter clockwise if x0 == x1.\n\t            if (Math.abs(endAngle - startAngle) > 1e-2) {\n\t              // Offset x0 by 1/80 of a pixel. Use something\n\t              // that can be represented in binary\n\t              if (clockwise) {\n\t                x0 += 270 / Z;\n\t              }\n\t            } else {\n\t              // Avoid case draw full circle\n\t              if (Math.abs(y0 - cy) < 1e-4) {\n\t                if (clockwise && x0 < cx || !clockwise && x0 > cx) {\n\t                  y1 -= 270 / Z;\n\t                } else {\n\t                  y1 += 270 / Z;\n\t                }\n\t              } else if (clockwise && y0 < cy || !clockwise && y0 > cy) {\n\t                x1 += 270 / Z;\n\t              } else {\n\t                x1 -= 270 / Z;\n\t              }\n\t            }\n\t          }\n\t\n\t          str.push(type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2));\n\t          xi = x1;\n\t          yi = y1;\n\t          break;\n\t\n\t        case CMD.R:\n\t          var p0 = points[0];\n\t          var p1 = points[1]; // x0, y0\n\t\n\t          p0[0] = data[i++];\n\t          p0[1] = data[i++]; // x1, y1\n\t\n\t          p1[0] = p0[0] + data[i++];\n\t          p1[1] = p0[1] + data[i++];\n\t\n\t          if (m) {\n\t            applyTransform(p0, p0, m);\n\t            applyTransform(p1, p1, m);\n\t          }\n\t\n\t          p0[0] = round(p0[0] * Z - Z2);\n\t          p1[0] = round(p1[0] * Z - Z2);\n\t          p0[1] = round(p0[1] * Z - Z2);\n\t          p1[1] = round(p1[1] * Z - Z2);\n\t          str.push( // x0, y0\n\t          ' m ', p0[0], comma, p0[1], // x1, y0\n\t          ' l ', p1[0], comma, p0[1], // x1, y1\n\t          ' l ', p1[0], comma, p1[1], // x0, y1\n\t          ' l ', p0[0], comma, p1[1]);\n\t          break;\n\t\n\t        case CMD.Z:\n\t          // FIXME Update xi, yi\n\t          str.push(' x ');\n\t      }\n\t\n\t      if (nPoint > 0) {\n\t        str.push(cmdStr);\n\t\n\t        for (var k = 0; k < nPoint; k++) {\n\t          var p = points[k];\n\t          m && applyTransform(p, p, m); // 不 round 会非常慢\n\t\n\t          str.push(round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k < nPoint - 1 ? comma : '');\n\t        }\n\t      }\n\t    }\n\t\n\t    return str.join('');\n\t  }; // Rewrite the original path method\n\t\n\t\n\t  Path.prototype.brushVML = function (vmlRoot) {\n\t    var style = this.style;\n\t    var vmlEl = this._vmlEl;\n\t\n\t    if (!vmlEl) {\n\t      vmlEl = vmlCore.createNode('shape');\n\t      initRootElStyle(vmlEl);\n\t      this._vmlEl = vmlEl;\n\t    }\n\t\n\t    updateFillAndStroke(vmlEl, 'fill', style, this);\n\t    updateFillAndStroke(vmlEl, 'stroke', style, this);\n\t    var m = this.transform;\n\t    var needTransform = m != null;\n\t    var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n\t\n\t    if (strokeEl) {\n\t      var lineWidth = style.lineWidth; // Get the line scale.\n\t      // Determinant of this.m_ means how much the area is enlarged by the\n\t      // transformation. So its square root can be used as a scale factor\n\t      // for width.\n\t\n\t      if (needTransform && !style.strokeNoScale) {\n\t        var det = m[0] * m[3] - m[1] * m[2];\n\t        lineWidth *= sqrt(abs(det));\n\t      }\n\t\n\t      strokeEl.weight = lineWidth + 'px';\n\t    }\n\t\n\t    var path = this.path || (this.path = new PathProxy());\n\t\n\t    if (this.__dirtyPath) {\n\t      path.beginPath();\n\t      this.buildPath(path, this.shape);\n\t      path.toStatic();\n\t      this.__dirtyPath = false;\n\t    }\n\t\n\t    vmlEl.path = pathDataToString(path, this.transform);\n\t    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\t\n\t    append(vmlRoot, vmlEl); // Text\n\t\n\t    if (style.text != null) {\n\t      this.drawRectText(vmlRoot, this.getBoundingRect());\n\t    } else {\n\t      this.removeRectText(vmlRoot);\n\t    }\n\t  };\n\t\n\t  Path.prototype.onRemove = function (vmlRoot) {\n\t    remove(vmlRoot, this._vmlEl);\n\t    this.removeRectText(vmlRoot);\n\t  };\n\t\n\t  Path.prototype.onAdd = function (vmlRoot) {\n\t    append(vmlRoot, this._vmlEl);\n\t    this.appendRectText(vmlRoot);\n\t  };\n\t  /***************************************************\n\t   * IMAGE\n\t   **************************************************/\n\t\n\t\n\t  var isImage = function (img) {\n\t    // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错\n\t    return typeof img === 'object' && img.tagName && img.tagName.toUpperCase() === 'IMG'; // return img instanceof Image;\n\t  }; // Rewrite the original path method\n\t\n\t\n\t  ZImage.prototype.brushVML = function (vmlRoot) {\n\t    var style = this.style;\n\t    var image = style.image; // Image original width, height\n\t\n\t    var ow;\n\t    var oh;\n\t\n\t    if (isImage(image)) {\n\t      var src = image.src;\n\t\n\t      if (src === this._imageSrc) {\n\t        ow = this._imageWidth;\n\t        oh = this._imageHeight;\n\t      } else {\n\t        var imageRuntimeStyle = image.runtimeStyle;\n\t        var oldRuntimeWidth = imageRuntimeStyle.width;\n\t        var oldRuntimeHeight = imageRuntimeStyle.height;\n\t        imageRuntimeStyle.width = 'auto';\n\t        imageRuntimeStyle.height = 'auto'; // get the original size\n\t\n\t        ow = image.width;\n\t        oh = image.height; // and remove overides\n\t\n\t        imageRuntimeStyle.width = oldRuntimeWidth;\n\t        imageRuntimeStyle.height = oldRuntimeHeight; // Caching image original width, height and src\n\t\n\t        this._imageSrc = src;\n\t        this._imageWidth = ow;\n\t        this._imageHeight = oh;\n\t      }\n\t\n\t      image = src;\n\t    } else {\n\t      if (image === this._imageSrc) {\n\t        ow = this._imageWidth;\n\t        oh = this._imageHeight;\n\t      }\n\t    }\n\t\n\t    if (!image) {\n\t      return;\n\t    }\n\t\n\t    var x = style.x || 0;\n\t    var y = style.y || 0;\n\t    var dw = style.width;\n\t    var dh = style.height;\n\t    var sw = style.sWidth;\n\t    var sh = style.sHeight;\n\t    var sx = style.sx || 0;\n\t    var sy = style.sy || 0;\n\t    var hasCrop = sw && sh;\n\t    var vmlEl = this._vmlEl;\n\t\n\t    if (!vmlEl) {\n\t      // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。\n\t      // vmlEl = vmlCore.createNode('group');\n\t      vmlEl = vmlCore.doc.createElement('div');\n\t      initRootElStyle(vmlEl);\n\t      this._vmlEl = vmlEl;\n\t    }\n\t\n\t    var vmlElStyle = vmlEl.style;\n\t    var hasRotation = false;\n\t    var m;\n\t    var scaleX = 1;\n\t    var scaleY = 1;\n\t\n\t    if (this.transform) {\n\t      m = this.transform;\n\t      scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n\t      scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n\t      hasRotation = m[1] || m[2];\n\t    }\n\t\n\t    if (hasRotation) {\n\t      // If filters are necessary (rotation exists), create them\n\t      // filters are bog-slow, so only create them if abbsolutely necessary\n\t      // The following check doesn't account for skews (which don't exist\n\t      // in the canvas spec (yet) anyway.\n\t      // From excanvas\n\t      var p0 = [x, y];\n\t      var p1 = [x + dw, y];\n\t      var p2 = [x, y + dh];\n\t      var p3 = [x + dw, y + dh];\n\t      applyTransform(p0, p0, m);\n\t      applyTransform(p1, p1, m);\n\t      applyTransform(p2, p2, m);\n\t      applyTransform(p3, p3, m);\n\t      var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n\t      var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n\t      var transformFilter = [];\n\t      transformFilter.push('M11=', m[0] / scaleX, comma, 'M12=', m[2] / scaleY, comma, 'M21=', m[1] / scaleX, comma, 'M22=', m[3] / scaleY, comma, 'Dx=', round(x * scaleX + m[4]), comma, 'Dy=', round(y * scaleY + m[5]));\n\t      vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0'; // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用\n\t\n\t      vmlElStyle.filter = imageTransformPrefix + '.Matrix(' + transformFilter.join('') + ', SizingMethod=clip)';\n\t    } else {\n\t      if (m) {\n\t        x = x * scaleX + m[4];\n\t        y = y * scaleY + m[5];\n\t      }\n\t\n\t      vmlElStyle.filter = '';\n\t      vmlElStyle.left = round(x) + 'px';\n\t      vmlElStyle.top = round(y) + 'px';\n\t    }\n\t\n\t    var imageEl = this._imageEl;\n\t    var cropEl = this._cropEl;\n\t\n\t    if (!imageEl) {\n\t      imageEl = vmlCore.doc.createElement('div');\n\t      this._imageEl = imageEl;\n\t    }\n\t\n\t    var imageELStyle = imageEl.style;\n\t\n\t    if (hasCrop) {\n\t      // Needs know image original width and height\n\t      if (!(ow && oh)) {\n\t        var tmpImage = new Image();\n\t        var self = this;\n\t\n\t        tmpImage.onload = function () {\n\t          tmpImage.onload = null;\n\t          ow = tmpImage.width;\n\t          oh = tmpImage.height; // Adjust image width and height to fit the ratio destinationSize / sourceSize\n\t\n\t          imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n\t          imageELStyle.height = round(scaleY * oh * dh / sh) + 'px'; // Caching image original width, height and src\n\t\n\t          self._imageWidth = ow;\n\t          self._imageHeight = oh;\n\t          self._imageSrc = image;\n\t        };\n\t\n\t        tmpImage.src = image;\n\t      } else {\n\t        imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n\t        imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n\t      }\n\t\n\t      if (!cropEl) {\n\t        cropEl = vmlCore.doc.createElement('div');\n\t        cropEl.style.overflow = 'hidden';\n\t        this._cropEl = cropEl;\n\t      }\n\t\n\t      var cropElStyle = cropEl.style;\n\t      cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n\t      cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n\t      cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx=' + -sx * dw / sw * scaleX + ',Dy=' + -sy * dh / sh * scaleY + ')';\n\t\n\t      if (!cropEl.parentNode) {\n\t        vmlEl.appendChild(cropEl);\n\t      }\n\t\n\t      if (imageEl.parentNode != cropEl) {\n\t        cropEl.appendChild(imageEl);\n\t      }\n\t    } else {\n\t      imageELStyle.width = round(scaleX * dw) + 'px';\n\t      imageELStyle.height = round(scaleY * dh) + 'px';\n\t      vmlEl.appendChild(imageEl);\n\t\n\t      if (cropEl && cropEl.parentNode) {\n\t        vmlEl.removeChild(cropEl);\n\t        this._cropEl = null;\n\t      }\n\t    }\n\t\n\t    var filterStr = '';\n\t    var alpha = style.opacity;\n\t\n\t    if (alpha < 1) {\n\t      filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n\t    }\n\t\n\t    filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n\t    imageELStyle.filter = filterStr;\n\t    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\t\n\t    append(vmlRoot, vmlEl); // Text\n\t\n\t    if (style.text != null) {\n\t      this.drawRectText(vmlRoot, this.getBoundingRect());\n\t    }\n\t  };\n\t\n\t  ZImage.prototype.onRemove = function (vmlRoot) {\n\t    remove(vmlRoot, this._vmlEl);\n\t    this._vmlEl = null;\n\t    this._cropEl = null;\n\t    this._imageEl = null;\n\t    this.removeRectText(vmlRoot);\n\t  };\n\t\n\t  ZImage.prototype.onAdd = function (vmlRoot) {\n\t    append(vmlRoot, this._vmlEl);\n\t    this.appendRectText(vmlRoot);\n\t  };\n\t  /***************************************************\n\t   * TEXT\n\t   **************************************************/\n\t\n\t\n\t  var DEFAULT_STYLE_NORMAL = 'normal';\n\t  var fontStyleCache = {};\n\t  var fontStyleCacheCount = 0;\n\t  var MAX_FONT_CACHE_SIZE = 100;\n\t  var fontEl = document.createElement('div');\n\t\n\t  var getFontStyle = function (fontString) {\n\t    var fontStyle = fontStyleCache[fontString];\n\t\n\t    if (!fontStyle) {\n\t      // Clear cache\n\t      if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n\t        fontStyleCacheCount = 0;\n\t        fontStyleCache = {};\n\t      }\n\t\n\t      var style = fontEl.style;\n\t      var fontFamily;\n\t\n\t      try {\n\t        style.font = fontString;\n\t        fontFamily = style.fontFamily.split(',')[0];\n\t      } catch (e) {}\n\t\n\t      fontStyle = {\n\t        style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n\t        variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n\t        weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n\t        size: parseFloat(style.fontSize || 12) | 0,\n\t        family: fontFamily || 'Microsoft YaHei'\n\t      };\n\t      fontStyleCache[fontString] = fontStyle;\n\t      fontStyleCacheCount++;\n\t    }\n\t\n\t    return fontStyle;\n\t  };\n\t\n\t  var textMeasureEl; // Overwrite measure text method\n\t\n\t  textContain.$override('measureText', function (text, textFont) {\n\t    var doc = vmlCore.doc;\n\t\n\t    if (!textMeasureEl) {\n\t      textMeasureEl = doc.createElement('div');\n\t      textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;' + 'padding:0;margin:0;border:none;white-space:pre;';\n\t      vmlCore.doc.body.appendChild(textMeasureEl);\n\t    }\n\t\n\t    try {\n\t      textMeasureEl.style.font = textFont;\n\t    } catch (ex) {// Ignore failures to set to invalid font.\n\t    }\n\t\n\t    textMeasureEl.innerHTML = ''; // Don't use innerHTML or innerText because they allow markup/whitespace.\n\t\n\t    textMeasureEl.appendChild(doc.createTextNode(text));\n\t    return {\n\t      width: textMeasureEl.offsetWidth\n\t    };\n\t  });\n\t  var tmpRect = new BoundingRect();\n\t\n\t  var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n\t    var style = this.style; // Optimize, avoid normalize every time.\n\t\n\t    this.__dirty && textHelper.normalizeTextStyle(style, true);\n\t    var text = style.text; // Convert to string\n\t\n\t    text != null && (text += '');\n\t\n\t    if (!text) {\n\t      return;\n\t    } // Convert rich text to plain text. Rich text is not supported in\n\t    // IE8-, but tags in rich text template will be removed.\n\t\n\t\n\t    if (style.rich) {\n\t      var contentBlock = textContain.parseRichText(text, style);\n\t      text = [];\n\t\n\t      for (var i = 0; i < contentBlock.lines.length; i++) {\n\t        var tokens = contentBlock.lines[i].tokens;\n\t        var textLine = [];\n\t\n\t        for (var j = 0; j < tokens.length; j++) {\n\t          textLine.push(tokens[j].text);\n\t        }\n\t\n\t        text.push(textLine.join(''));\n\t      }\n\t\n\t      text = text.join('\\n');\n\t    }\n\t\n\t    var x;\n\t    var y;\n\t    var align = style.textAlign;\n\t    var verticalAlign = style.textVerticalAlign;\n\t    var fontStyle = getFontStyle(style.font); // FIXME encodeHtmlAttribute ?\n\t\n\t    var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' ' + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n\t    textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign); // Transform rect to view space\n\t\n\t    var m = this.transform; // Ignore transform for text in other element\n\t\n\t    if (m && !fromTextEl) {\n\t      tmpRect.copy(rect);\n\t      tmpRect.applyTransform(m);\n\t      rect = tmpRect;\n\t    }\n\t\n\t    if (!fromTextEl) {\n\t      var textPosition = style.textPosition;\n\t      var distance = style.textDistance; // Text position represented by coord\n\t\n\t      if (textPosition instanceof Array) {\n\t        x = rect.x + parsePercent(textPosition[0], rect.width);\n\t        y = rect.y + parsePercent(textPosition[1], rect.height);\n\t        align = align || 'left';\n\t      } else {\n\t        var res = textContain.adjustTextPositionOnRect(textPosition, rect, distance);\n\t        x = res.x;\n\t        y = res.y; // Default align and baseline when has textPosition\n\t\n\t        align = align || res.textAlign;\n\t        verticalAlign = verticalAlign || res.textVerticalAlign;\n\t      }\n\t    } else {\n\t      x = rect.x;\n\t      y = rect.y;\n\t    }\n\t\n\t    x = textContain.adjustTextX(x, textRect.width, align);\n\t    y = textContain.adjustTextY(y, textRect.height, verticalAlign); // Force baseline 'middle'\n\t\n\t    y += textRect.height / 2; // var fontSize = fontStyle.size;\n\t    // 1.75 is an arbitrary number, as there is no info about the text baseline\n\t    // switch (baseline) {\n\t    // case 'hanging':\n\t    // case 'top':\n\t    //     y += fontSize / 1.75;\n\t    //     break;\n\t    //     case 'middle':\n\t    //         break;\n\t    //     default:\n\t    //     // case null:\n\t    //     // case 'alphabetic':\n\t    //     // case 'ideographic':\n\t    //     // case 'bottom':\n\t    //         y -= fontSize / 2.25;\n\t    //         break;\n\t    // }\n\t    // switch (align) {\n\t    //     case 'left':\n\t    //         break;\n\t    //     case 'center':\n\t    //         x -= textRect.width / 2;\n\t    //         break;\n\t    //     case 'right':\n\t    //         x -= textRect.width;\n\t    //         break;\n\t    // case 'end':\n\t    // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n\t    // break;\n\t    // case 'start':\n\t    // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n\t    // break;\n\t    // default:\n\t    //     align = 'left';\n\t    // }\n\t\n\t    var createNode = vmlCore.createNode;\n\t    var textVmlEl = this._textVmlEl;\n\t    var pathEl;\n\t    var textPathEl;\n\t    var skewEl;\n\t\n\t    if (!textVmlEl) {\n\t      textVmlEl = createNode('line');\n\t      pathEl = createNode('path');\n\t      textPathEl = createNode('textpath');\n\t      skewEl = createNode('skew'); // FIXME Why here is not cammel case\n\t      // Align 'center' seems wrong\n\t\n\t      textPathEl.style['v-text-align'] = 'left';\n\t      initRootElStyle(textVmlEl);\n\t      pathEl.textpathok = true;\n\t      textPathEl.on = true;\n\t      textVmlEl.from = '0 0';\n\t      textVmlEl.to = '1000 0.05';\n\t      append(textVmlEl, skewEl);\n\t      append(textVmlEl, pathEl);\n\t      append(textVmlEl, textPathEl);\n\t      this._textVmlEl = textVmlEl;\n\t    } else {\n\t      // 这里是在前面 appendChild 保证顺序的前提下\n\t      skewEl = textVmlEl.firstChild;\n\t      pathEl = skewEl.nextSibling;\n\t      textPathEl = pathEl.nextSibling;\n\t    }\n\t\n\t    var coords = [x, y];\n\t    var textVmlElStyle = textVmlEl.style; // Ignore transform for text in other element\n\t\n\t    if (m && fromTextEl) {\n\t      applyTransform(coords, coords, m);\n\t      skewEl.on = true;\n\t      skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0'; // Text position\n\t\n\t      skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0); // Left top point as origin\n\t\n\t      skewEl.origin = '0 0';\n\t      textVmlElStyle.left = '0px';\n\t      textVmlElStyle.top = '0px';\n\t    } else {\n\t      skewEl.on = false;\n\t      textVmlElStyle.left = round(x) + 'px';\n\t      textVmlElStyle.top = round(y) + 'px';\n\t    }\n\t\n\t    textPathEl.string = encodeHtmlAttribute(text); // TODO\n\t\n\t    try {\n\t      textPathEl.style.font = font;\n\t    } // Error font format\n\t    catch (e) {}\n\t\n\t    updateFillAndStroke(textVmlEl, 'fill', {\n\t      fill: style.textFill,\n\t      opacity: style.opacity\n\t    }, this);\n\t    updateFillAndStroke(textVmlEl, 'stroke', {\n\t      stroke: style.textStroke,\n\t      opacity: style.opacity,\n\t      lineDash: style.lineDash\n\t    }, this);\n\t    textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Attached to root\n\t\n\t    append(vmlRoot, textVmlEl);\n\t  };\n\t\n\t  var removeRectText = function (vmlRoot) {\n\t    remove(vmlRoot, this._textVmlEl);\n\t    this._textVmlEl = null;\n\t  };\n\t\n\t  var appendRectText = function (vmlRoot) {\n\t    append(vmlRoot, this._textVmlEl);\n\t  };\n\t\n\t  var list = [RectText, Displayable, ZImage, Path, Text]; // In case Displayable has been mixed in RectText\n\t\n\t  for (var i = 0; i < list.length; i++) {\n\t    var proto = list[i].prototype;\n\t    proto.drawRectText = drawRectText;\n\t    proto.removeRectText = removeRectText;\n\t    proto.appendRectText = appendRectText;\n\t  }\n\t\n\t  Text.prototype.brushVML = function (vmlRoot) {\n\t    var style = this.style;\n\t\n\t    if (style.text != null) {\n\t      this.drawRectText(vmlRoot, {\n\t        x: style.x || 0,\n\t        y: style.y || 0,\n\t        width: 0,\n\t        height: 0\n\t      }, this.getBoundingRect(), true);\n\t    } else {\n\t      this.removeRectText(vmlRoot);\n\t    }\n\t  };\n\t\n\t  Text.prototype.onRemove = function (vmlRoot) {\n\t    this.removeRectText(vmlRoot);\n\t  };\n\t\n\t  Text.prototype.onAdd = function (vmlRoot) {\n\t    this.appendRectText(vmlRoot);\n\t  };\n\t}\n\n/***/ }),\n/* 84 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar env = __webpack_require__(5);\n\t\n\tvar urn = 'urn:schemas-microsoft-com:vml';\n\tvar win = typeof window === 'undefined' ? null : window;\n\tvar vmlInited = false;\n\tvar doc = win && win.document;\n\t\n\tfunction createNode(tagName) {\n\t  return doCreateNode(tagName);\n\t} // Avoid assign to an exported variable, for transforming to cjs.\n\t\n\t\n\tvar doCreateNode;\n\t\n\tif (doc && !env.canvasSupported) {\n\t  try {\n\t    !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);\n\t\n\t    doCreateNode = function (tagName) {\n\t      return doc.createElement('<zrvml:' + tagName + ' class=\"zrvml\">');\n\t    };\n\t  } catch (e) {\n\t    doCreateNode = function (tagName) {\n\t      return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"zrvml\">');\n\t    };\n\t  }\n\t} // From raphael\n\t\n\t\n\tfunction initVML() {\n\t  if (vmlInited || !doc) {\n\t    return;\n\t  }\n\t\n\t  vmlInited = true;\n\t  var styleSheets = doc.styleSheets;\n\t\n\t  if (styleSheets.length < 31) {\n\t    doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');\n\t  } else {\n\t    // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n\t    styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');\n\t  }\n\t}\n\t\n\texports.doc = doc;\n\texports.createNode = createNode;\n\texports.initVML = initVML;\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrLog = __webpack_require__(22);\n\t\n\tvar vmlCore = __webpack_require__(84);\n\t\n\tvar _util = __webpack_require__(6);\n\t\n\tvar each = _util.each;\n\t\n\t/**\n\t * VML Painter.\n\t *\n\t * @module zrender/vml/Painter\n\t */\n\tfunction parseInt10(val) {\n\t  return parseInt(val, 10);\n\t}\n\t/**\n\t * @alias module:zrender/vml/Painter\n\t */\n\t\n\t\n\tfunction VMLPainter(root, storage) {\n\t  vmlCore.initVML();\n\t  this.root = root;\n\t  this.storage = storage;\n\t  var vmlViewport = document.createElement('div');\n\t  var vmlRoot = document.createElement('div');\n\t  vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n\t  vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n\t  root.appendChild(vmlViewport);\n\t  this._vmlRoot = vmlRoot;\n\t  this._vmlViewport = vmlViewport;\n\t  this.resize(); // Modify storage\n\t\n\t  var oldDelFromStorage = storage.delFromStorage;\n\t  var oldAddToStorage = storage.addToStorage;\n\t\n\t  storage.delFromStorage = function (el) {\n\t    oldDelFromStorage.call(storage, el);\n\t\n\t    if (el) {\n\t      el.onRemove && el.onRemove(vmlRoot);\n\t    }\n\t  };\n\t\n\t  storage.addToStorage = function (el) {\n\t    // Displayable already has a vml node\n\t    el.onAdd && el.onAdd(vmlRoot);\n\t    oldAddToStorage.call(storage, el);\n\t  };\n\t\n\t  this._firstPaint = true;\n\t}\n\t\n\tVMLPainter.prototype = {\n\t  constructor: VMLPainter,\n\t  getType: function () {\n\t    return 'vml';\n\t  },\n\t\n\t  /**\n\t   * @return {HTMLDivElement}\n\t   */\n\t  getViewportRoot: function () {\n\t    return this._vmlViewport;\n\t  },\n\t  getViewportRootOffset: function () {\n\t    var viewportRoot = this.getViewportRoot();\n\t\n\t    if (viewportRoot) {\n\t      return {\n\t        offsetLeft: viewportRoot.offsetLeft || 0,\n\t        offsetTop: viewportRoot.offsetTop || 0\n\t      };\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 刷新\n\t   */\n\t  refresh: function () {\n\t    var list = this.storage.getDisplayList(true, true);\n\t\n\t    this._paintList(list);\n\t  },\n\t  _paintList: function (list) {\n\t    var vmlRoot = this._vmlRoot;\n\t\n\t    for (var i = 0; i < list.length; i++) {\n\t      var el = list[i];\n\t\n\t      if (el.invisible || el.ignore) {\n\t        if (!el.__alreadyNotVisible) {\n\t          el.onRemove(vmlRoot);\n\t        } // Set as already invisible\n\t\n\t\n\t        el.__alreadyNotVisible = true;\n\t      } else {\n\t        if (el.__alreadyNotVisible) {\n\t          el.onAdd(vmlRoot);\n\t        }\n\t\n\t        el.__alreadyNotVisible = false;\n\t\n\t        if (el.__dirty) {\n\t          el.beforeBrush && el.beforeBrush();\n\t          (el.brushVML || el.brush).call(el, vmlRoot);\n\t          el.afterBrush && el.afterBrush();\n\t        }\n\t      }\n\t\n\t      el.__dirty = false;\n\t    }\n\t\n\t    if (this._firstPaint) {\n\t      // Detached from document at first time\n\t      // to avoid page refreshing too many times\n\t      // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变\n\t      this._vmlViewport.appendChild(vmlRoot);\n\t\n\t      this._firstPaint = false;\n\t    }\n\t  },\n\t  resize: function (width, height) {\n\t    var width = width == null ? this._getWidth() : width;\n\t    var height = height == null ? this._getHeight() : height;\n\t\n\t    if (this._width != width || this._height != height) {\n\t      this._width = width;\n\t      this._height = height;\n\t      var vmlViewportStyle = this._vmlViewport.style;\n\t      vmlViewportStyle.width = width + 'px';\n\t      vmlViewportStyle.height = height + 'px';\n\t    }\n\t  },\n\t  dispose: function () {\n\t    this.root.innerHTML = '';\n\t    this._vmlRoot = this._vmlViewport = this.storage = null;\n\t  },\n\t  getWidth: function () {\n\t    return this._width;\n\t  },\n\t  getHeight: function () {\n\t    return this._height;\n\t  },\n\t  clear: function () {\n\t    if (this._vmlViewport) {\n\t      this.root.removeChild(this._vmlViewport);\n\t    }\n\t  },\n\t  _getWidth: function () {\n\t    var root = this.root;\n\t    var stl = root.currentStyle;\n\t    return (root.clientWidth || parseInt10(stl.width)) - parseInt10(stl.paddingLeft) - parseInt10(stl.paddingRight) | 0;\n\t  },\n\t  _getHeight: function () {\n\t    var root = this.root;\n\t    var stl = root.currentStyle;\n\t    return (root.clientHeight || parseInt10(stl.height)) - parseInt10(stl.paddingTop) - parseInt10(stl.paddingBottom) | 0;\n\t  }\n\t}; // Not supported methods\n\t\n\tfunction createMethodNotSupport(method) {\n\t  return function () {\n\t    zrLog('In IE8.0 VML mode painter not support method \"' + method + '\"');\n\t  };\n\t} // Unsupported methods\n\t\n\t\n\teach(['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'], function (name) {\n\t  VMLPainter.prototype[name] = createMethodNotSupport(name);\n\t});\n\tvar _default = VMLPainter;\n\tmodule.exports = _default;\n\n/***/ })\n/******/ ])\n});\n;\n"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f19dda89bdc4710c95f7","/**\r\n * Export fishTopo as CommonJS module\r\n */\r\nmodule.exports = require('./lib/fish-topo-bo/lib/FishTopoBo.js');\r\n//兼容IE8 引入VML 如果不需要兼容IE8请删除\r\nrequire('zrender/lib/vml/vml');\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./index.bo.js\n// module id = 1\n// module chunks = 0","/**\r\n * Created by majianan on 16/5/19.\r\n *\r\n */\r\n\r\n    var zr = require('zrender/lib/zrender');\r\n    var util = require('zrender/lib/core/util');\r\n    var BoNode = require('./node/BoNode');\r\n    var Relation = require('./node/Relation');\r\n    var Const = require('./models/Const');\r\n    var graphic = require(\"../../fish-topo-core/lib/graphic.js\");\r\n    var eventTool = require('zrender/lib/core/event');\r\n    require('../../fish-topo-core/lib/objectAssignPolyfill.js');\r\n\r\n    function FishTopoBo(dom, opts) {\r\n        /**\r\n         * 缩放\r\n         * @type {number}\r\n         */\r\n        this.nowZoom = 1;\r\n        this.canScale = true;\r\n\r\n        /**\r\n         * 初始化zrender\r\n         */\r\n        this._zr = zr.init(dom, {\r\n            renderer: opts.renderer || 'canvas',\r\n            devicePixelRatio: opts.devicePixelRatio\r\n        });\r\n    }\r\n\r\n    var fishTopoProto = FishTopoBo.prototype;\r\n\r\n    /**\r\n     * 初始化\r\n     */\r\n    fishTopoProto.init = function () {\r\n        this.group = new graphic.Group();\r\n        this.groupDrag(this.group);\r\n        this._zr.add(this.group);\r\n        this.zrScale();\r\n    };\r\n\r\n    /**\r\n     * 调整尺寸  在窗口大小发生改变时需要手工调用\r\n     */\r\n    fishTopoProto.resize = function () {\r\n        this._zr.resize();\r\n    };\r\n\r\n    /**\r\n     * 添加BO\r\n     * @param {Object} boData, bo数据\r\n     * @param {{\r\n     *          startPos: {x: number, y: number} 起始位置,\r\n     *          displayAttrDataType: boolean 是否显示属性数据类型,\r\n     *          displayAttrEvent: boolean 是否显示属性事件决策,\r\n     *          boClickable: boolean BO是否支持点击事件, 可空 默认false\r\n     *          boPopupUrl: String 点击BO弹出页面地址\r\n     *          boEventClickable: boolean BO事件决策是否支持点击事件, 可空 默认false\r\n     *          boEventPopupUrl: String 点击BO事件决策弹出页面地址\r\n     *          bindBoClickEvent: function(options) BO点击事件，返回函数参数为options，它的属性有DATA等\r\n     *          attrEventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false\r\n     *          attrEventPopupUrl: String 点击BO属性事件决策弹出页面地址\r\n     *          isCurrent: boolean 是否为当前BO\r\n     *          lineStyle: {stroke: string, lineWidth: number, lineDash: Array} 关联线样式\r\n     *          lineHoverStyle: {stroke: string, lineWidth: number, lineDash: Array} 关联线hover样式\r\n     *          arrowStyle: {fill: string, stroke: string} 关联线箭头样式\r\n     *          arrowHoverStyle: {fill: string, stroke: string} 关联线箭头hover样式\r\n     *          }} opts\r\n     * @returns {*}\r\n     */\r\n    fishTopoProto.addBo = function (boData, opts) {\r\n        //设置BO父子关系，便于后续整体移动\r\n        this._setParent(boData);\r\n\r\n        //layout BO的布局信息，x,y左上角起始坐标, level:层级\r\n        boData.layout = {\r\n            x: opts.startPos.x,\r\n            y: opts.startPos.y,\r\n            level: 1\r\n        };\r\n\r\n        //计算BO的X坐标\r\n        this._bfs(boData);\r\n\r\n        //按照起始坐标整体左移\r\n        this._moveRightByParent(boData, opts.startPos.x - boData.layout.x);\r\n\r\n        //画BO\r\n        var boNode = new BoNode(boData, opts);\r\n        this.group.add(boNode.getShape());\r\n\r\n        //创建子BO\r\n        this.addChildBo(boNode, opts);\r\n\r\n        return boNode;\r\n    };\r\n\r\n    /**\r\n     * 设置BO的父子关系\r\n     * @param {Object} boData BO数据\r\n     * @private\r\n     */\r\n    fishTopoProto._setParent = function (boData) {\r\n        if (boData.child) {\r\n            var childCnt = boData.child.length,\r\n                childBoArr = boData.child;\r\n            for (var i = 0; i < childCnt; i++) {\r\n                childBoArr[i].parent = boData;\r\n                if (childBoArr[i + 1]) {\r\n                    childBoArr[i].next = childBoArr[i + 1];\r\n                }\r\n                //设置最后子节点的next=下一个父节点的第一个子节点\r\n                else if (boData.next && boData.next.child) {\r\n                    childBoArr[i].next = boData.next.child[0];\r\n                }\r\n                this._setParent(childBoArr[i]);\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * Breadth-First-Search 计算X坐标\r\n     * 由于BO宽度定死，可以在画图之前计算每个BO的起始X坐标\r\n     * 每个BO的高度根据显示内容不固定，因此需要根据实际的父BO高度才能计算本身的起始Y坐标\r\n     * @param boData\r\n     * @private\r\n     */\r\n    fishTopoProto._bfs = function (boData) {\r\n        //用于保存每个level的最大坐标值\r\n        this._levelMaxPos = {};\r\n\r\n        this._queue = [];   //存放BO数据\r\n        this._queue.push(boData);\r\n\r\n        while (this._queue.length > 0) {\r\n            var tmp = this._queue.shift();\r\n            //console.log('BO[' + tmp.name + '] {x: ' + tmp.layout.x + ', level: ' + tmp.layout.level + '} ');\r\n            //console.log('    ***Before this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);\r\n\r\n            //该level第一个节点\r\n            if (!this._levelMaxPos[tmp.layout.level]) {\r\n                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n            }\r\n            //当前就是最右侧的节点\r\n            else if (this._levelMaxPos[tmp.layout.level].x + Const.BO_NODE_WIDTH <= tmp.layout.x) {\r\n                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n            }\r\n            //当前节点与之前的节点有交叉，则需要连同父节点整体向右移动\r\n            else {\r\n                this._moveRightByChild(tmp, this._levelMaxPos[tmp.layout.level].x - tmp.layout.x + Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X)\r\n                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n            }\r\n\r\n            //console.log('    ***After this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);\r\n\r\n            //存在子节点，计算子节点坐标，同时添加到队列中，以便后续计算调整x坐标\r\n            if (tmp.child) {\r\n                var childCnt = tmp.child.length;\r\n\r\n                for (var i = 0; i < childCnt; i++) {\r\n\r\n                    tmp.child[i].layout = {\r\n                        x: tmp.layout.x - (Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X) * ((childCnt - 1) / 2 - i),\r\n                        level: tmp.layout.level + 1\r\n                    };\r\n\r\n                    this._queue.push(tmp.child[i]);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 子节点右移时，同时下一个子节点，以及父节点都同时移动\r\n     * @param boData\r\n     * @param width\r\n     * @private\r\n     */\r\n    fishTopoProto._moveRightByChild = function (boData, width) {\r\n        if (boData) {\r\n\r\n            if (!boData.layout.moved) {\r\n\r\n                if (boData.layout.level == 1) {\r\n                    boData.layout.x += width / 2;\r\n                } else {\r\n                    boData.layout.x += width;\r\n                }\r\n\r\n                boData.layout.moved = true;\r\n            }\r\n            //当前节点的下一节点整体右移\r\n            this._moveRightByPrevious(boData.next, width);\r\n            //当前节点的父节点整体右移\r\n            this._moveRightByChild(boData.parent, width);\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * 前一个节点右移的时候，所有后面的节点整体右移\r\n     * @param boData\r\n     * @param width\r\n     * @private\r\n     */\r\n    fishTopoProto._moveRightByPrevious = function (boData, width) {\r\n        if (boData) {\r\n            boData.layout.x += width;\r\n            //当前节点的所有后续节点整体右移\r\n            this._moveRightByPrevious(boData.next, width);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 父节点右移时，所有子节点整体右移\r\n     * @param boData\r\n     * @param width\r\n     * @private\r\n     */\r\n    fishTopoProto._moveRightByParent = function (boData, width) {\r\n        if (boData) {\r\n            boData.layout.x += width;\r\n            if (boData.child) {\r\n                for (var i = 0; i < boData.child.length; i++) {\r\n                    this._moveRightByParent(boData.child[i], width);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 添加子BO\r\n     * @param {BoNode} parentBoNode\r\n     * @param {Object} opts\r\n     * @private\r\n     */\r\n    fishTopoProto.addChildBo = function (parentBoNode, opts) {\r\n\r\n        this._queue = []; //需要根据BO节点的实际高度计算自己点的起始Y坐标，因此存放的是BoNode图形\r\n        this._queue.push(parentBoNode);\r\n\r\n        while (this._queue.length > 0) {\r\n            var tmp = this._queue.shift(),\r\n                boNodeHeight = tmp.getShape().getBoundingRect().height;\r\n            //console.log('Parent BO[' + tmp.getData().name + '] {y: ' + tmp.getLayout().y + ', level: ' + tmp.getLayout().level + ', boNodeHeight:' + boNodeHeight + '} ');\r\n            //console.log('    ***Before this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);\r\n\r\n            //如果是该Level第一个节点，或者当低于原来的节点\r\n            if (!this._levelMaxPos[tmp.getLayout().level].y ||\r\n                this._levelMaxPos[tmp.getLayout().level].y < tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y) {\r\n                this._levelMaxPos[tmp.getLayout().level].y = tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y;\r\n            }\r\n\r\n            //console.log('    ***After this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);\r\n\r\n            if (tmp.getData().child) {\r\n\r\n                var childBoArr = tmp.getData().child,\r\n                    childCnt = childBoArr.length,\r\n                    boNode,\r\n                    relationNode;\r\n\r\n                //该level所有子节点的起始Y坐标都相同\r\n                opts.startPos.y = this._levelMaxPos[tmp.getLayout().level].y;\r\n                for (var i = 0; i < childCnt; i++) {\r\n                    opts.startPos.x = childBoArr[i].layout.x;\r\n                    childBoArr[i].layout.y = opts.startPos.y;\r\n                    boNode = new BoNode(childBoArr[i], opts);\r\n                    //console.log('Child BO[' + boNode.getData().name + '] {y: ' + opts.startPos.y + ', level: ' + boNode.getLayout().level + '} ');\r\n\r\n                    this.group.add(boNode.getShape());\r\n                    this._queue.push(boNode);\r\n\r\n                    //BO关系\r\n                    if (childBoArr[i].relation) {\r\n                        var _relationLen = childBoArr[i].relation.length;\r\n                        for (var j = 0; j < _relationLen; j++) {\r\n                            var sourceId = childBoArr[i].relation[j].sourceId,\r\n                                targetId = childBoArr[i].relation[j].targetId,\r\n                                sourceText = childBoArr[i].relation[j].sourceText,\r\n                                targetText = childBoArr[i].relation[j].targetText;\r\n\r\n                            relationNode = new Relation(\r\n                                boNode.getShape().childOfName(sourceId),\r\n                                tmp.getShape().childOfName(targetId),\r\n                                sourceText,\r\n                                targetText,\r\n                                opts.lineStyle,\r\n                                opts.lineHoverStyle,\r\n                                opts.arrowStyle,\r\n                                opts.arrowHoverStyle\r\n                            );\r\n                            this.group.add(relationNode.getShape());\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 设置当前BO为特殊样式\r\n     * @param {String} boId, BO标识\r\n     * @param {Object} style, BO特殊样式,可空\r\n     */\r\n    fishTopoProto.setCurrentBo = function (boId, style) {\r\n        var length = this.group.childCount();\r\n        for (var i = 0; i < length; i++) {\r\n            if (this.group.childAt(i).name == boId) {\r\n                this.group.childAt(i).setCurrent(style);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 清空\r\n     */\r\n    fishTopoProto.clear = function () {\r\n        this._zr.clear();\r\n        this.group = new graphic.Group();\r\n        this._zr.add(this.group);\r\n    };\r\n\r\n    /**\r\n     * 缩放功能\r\n     * @param type\r\n     */\r\n    fishTopoProto.zrScale = function (type) {\r\n        var that = this;\r\n        if (type) {\r\n            if (type == \"narrowing\") {\r\n                var zoomDelta = 1 / 1.1;\r\n                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n            }\r\n            if (type == \"enlarge\") {\r\n                var zoomDelta = 1.1;\r\n                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n            }\r\n        } else {\r\n            that._zr.on('mousewheel', function (e) {\r\n                eventTool.stop(e.event);\r\n                var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;\r\n                zoom(zoomDelta, e.offsetX, e.offsetY);\r\n            });\r\n        }\r\n        ;\r\n        function zoom(zoomDelta, zoomX, zoomY) {\r\n            if (that.canScale == false) {\r\n                return;\r\n            }\r\n            var target = that.group;\r\n            if (target) {\r\n                var pos = target.position;\r\n                var scale = target.scale;\r\n                var newZoom = that._zoom = that._zoom || 1;\r\n                newZoom *= zoomDelta;\r\n                var zoomScale = newZoom / that._zoom;\r\n                // if(newZoom>2.6||newZoom<0.38){\r\n                //     return;\r\n                // };\r\n                that._zoom = newZoom;\r\n\r\n                that.nowZoom = newZoom;\r\n                // Keep the mouse center when scaling\r\n                pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);\r\n                pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);\r\n                scale[0] *= zoomScale;\r\n                scale[1] *= zoomScale;\r\n                target.attr(\"position\", [pos[0], pos[1]]);\r\n                target.attr(\"scale\", [scale[0], scale[1]]);\r\n                //that.minimap.updateSelectionPosition(pos,zoomScale);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 拖拽Group\r\n     */\r\n    fishTopoProto.groupDrag = function () {\r\n        var that = this;\r\n        that._zr.on(\"mousedown\", function (e) {\r\n            groupDragFunction(e);\r\n            e.cancelBubble = true;\r\n        });\r\n        function groupDragFunction(e) {\r\n            var startX = e.event.clientX;\r\n            var startY = e.event.clientY;\r\n            var moveFunction = function (e) {\r\n                moveDrag(e);\r\n            }\r\n            var nowGroupPosition = that.group.position;\r\n            var groupPositionX = that.group.position[0];\r\n            var groupPositionY = that.group.position[1];\r\n            var alarmPositionX, alarmPositionY;\r\n\r\n            function moveDrag(e) {\r\n                var width = that.group.getBoundingRect().width * that.nowZoom;\r\n                var height = that.group.getBoundingRect().height * that.nowZoom;\r\n                var gx = that.group.getBoundingRect().x * that.nowZoom;\r\n                var gy = that.group.getBoundingRect().y * that.nowZoom;\r\n                var min = [10 - (width + gx), 10 - (height + gy)];\r\n                var max = [(that._zr.getWidth() - gx) - 10, (that._zr.getHeight() - gy) - 10];\r\n                var sX = (e.event.clientX - startX) * (that.nowZoom);\r\n                var sY = (e.event.clientY - startY) * (that.nowZoom);\r\n                nowGroupPosition[0] = groupPositionX + (sX);\r\n                nowGroupPosition[1] = groupPositionY + (sY);\r\n                if (nowGroupPosition[0] > max[0] || nowGroupPosition[1] > max[1] || nowGroupPosition[0] < min[0] || nowGroupPosition[1] < min[1]) {\r\n                    return;\r\n                } else {\r\n                    that.group.attr(\"position\", nowGroupPosition);\r\n                }\r\n            }\r\n\r\n            that._zr.on('mousemove', moveFunction);\r\n            var upFunction = function (e) {\r\n                endDrag(e);\r\n            }\r\n\r\n            function endDrag(e) {\r\n                that._zr.off('mousemove', moveFunction);\r\n                that._zr.off('mouseup', upFunction);\r\n                that._zr.off(\"globalout\", upFunction);\r\n            }\r\n\r\n            that._zr.on('mouseup', upFunction);\r\n            that._zr.on(\"globalout\", upFunction);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 拖拽\r\n     * @param node\r\n     */\r\n    fishTopoProto.drag = function (node) {\r\n        var that = this;\r\n        node.on(\"mousedown\", function (e) {\r\n            if (this.isdraggable == false) {\r\n                return;\r\n            }\r\n            groupDragFunction(e);\r\n            e.cancelBubble = true;\r\n        });\r\n        function groupDragFunction(e) {\r\n            var startX = e.event.clientX;\r\n            var startY = e.event.clientY;\r\n            var moveFunction = function (e) {\r\n                moveDrag(e);\r\n            }\r\n            var nowGroupPosition = node.position;\r\n            var groupPositionX = node.position[0];\r\n            var groupPositionY = node.position[1];\r\n            var alarmPositionX, alarmPositionY;\r\n            if (node.alarm) {\r\n                var newAlarmPosition = node.alarm.position;\r\n                alarmPositionX = node.alarm.position[0];\r\n                alarmPositionY = node.alarm.position[1];\r\n            }\r\n            ;\r\n            function moveDrag(e) {\r\n                var sX = (e.event.clientX - startX) / (that.nowZoom);\r\n                var sY = (e.event.clientY - startY) / (that.nowZoom);\r\n                if (node.parent && node.parent instanceof GroupNode) {\r\n                    //放入node现有数值，用于重绘group\r\n                    var nodeMessage = {\r\n                        width: node.shape.width,\r\n                        height: node.shape.height,\r\n                        position: node.position,\r\n                        nodeXY: [node.shape.x, node.shape.y],\r\n                        movePosition: [groupPositionX, groupPositionY],\r\n                        moveX: sX,\r\n                        moveY: sY\r\n                    };\r\n                    var groupNode = node.parent;\r\n                    groupNode.reDraw(nodeMessage, node);\r\n                } else {\r\n                    nowGroupPosition[0] = groupPositionX + (sX);\r\n                    nowGroupPosition[1] = groupPositionY + (sY);\r\n                    node.attr(\"position\", nowGroupPosition);\r\n                    if (node.alarm) {\r\n                        var newAlarmPosition = [nowGroupPosition[0] + node.getBoundingRect().width - (node.alarm.getBoundingRect().width - 6), nowGroupPosition[1] - node.alarm.getBoundingRect().height - 3];\r\n                        node.alarm.attr(\"position\", newAlarmPosition);\r\n                    }\r\n                    ;\r\n                }\r\n                ConnectionManager.refreshLineByNode(node);\r\n            }\r\n\r\n            that._zr.on('mousemove', moveFunction);\r\n            var upFunction = function (e) {\r\n                endDrag(e);\r\n            }\r\n            //拖拽结束\r\n            function endDrag(e) {\r\n                that._zr.off('mousemove', moveFunction);\r\n                that._zr.off('mouseup', upFunction);\r\n                that._zr.off(\"globalout\", upFunction);\r\n                //布局重新计算\r\n                if (node.layout) {\r\n                    that.layoutNode(\"tree\", {\"node\": node});\r\n                }\r\n                if (that.forceLayoutOption) {\r\n                    var nodes = that.forceLayoutOption.allNodes;\r\n                    if (_.indexOf(nodes, node) != -1) {\r\n                        that.layoutNode(\"force\", this.forceLayoutOption);\r\n                    }\r\n                }\r\n                ;\r\n            }\r\n\r\n            that._zr.on('mouseup', upFunction);\r\n            that._zr.on(\"globalout\", upFunction);\r\n        }\r\n    };\r\n\r\n\r\n    // ---------对外暴露fishTopoBo------------------\r\n    var idBase = new Date() - 0;\r\n    var instances = {};\r\n    var DOM_ATTRIBUTE_KEY = '_fishTopoBo_instance_';\r\n    var fishTopoBo = {\r\n        /**\r\n         * @type {number}\r\n         */\r\n        version: '3.0.0',\r\n        dependencies: {\r\n            zrender: '3.0.4'\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @param {HTMLDomElement} dom\r\n     * @param {Object} opts\r\n     */\r\n    fishTopoBo.init = function (dom, opts) {\r\n        if (!dom) {\r\n            throw new Error('Initialize failed: invalid dom.');\r\n        }\r\n\r\n        opts = opts || {};\r\n        // Default value\r\n        util.defaults(opts,\r\n            {\r\n                type: \"bpmn\",\r\n                showGridLine: true,\r\n                devicePixelRatio: 1,\r\n                gridLineSpacing:10\r\n            }\r\n        );\r\n\r\n        var fishTopoBo = new FishTopoBo(dom, opts);\r\n        fishTopoBo.init();\r\n\r\n        fishTopoBo.id = 'ft_' + idBase++;\r\n        instances[fishTopoBo.id] = fishTopoBo;\r\n\r\n        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoBo.id);\r\n\r\n        return fishTopoBo;\r\n    };\r\n\r\n\r\n    /**\r\n     * @param  {HTMLDomElement} dom\r\n     * @return {fishTopo}\r\n     */\r\n    fishTopoBo.getInstanceByDom = function (dom) {\r\n        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\r\n        return instances[key];\r\n    };\r\n\r\n    /**\r\n     * Dispose a fishTopo instance\r\n     * @param  {module:fishTopo|HTMLDomElement|string} fishTopo\r\n     */\r\n    fishTopoBo.dispose = function (chart) {\r\n        var topo;\r\n        if (zrUtil.isDom(chart)) {\r\n            topo = fishTopoBo.getInstanceByDom(chart);\r\n        }\r\n        else if (typeof chart === 'string') {\r\n            topo = instances[chart];\r\n        }\r\n        if ((topo instanceof fishTopoBo) && !topo.isDisposed()) {\r\n            topo.dispose();\r\n        }\r\n    };\r\n\r\n    module.exports = fishTopoBo;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-bo/lib/FishTopoBo.js\n// module id = 2\n// module chunks = 0","var guid = require(\"./core/guid\");\n\nvar env = require(\"./core/env\");\n\nvar zrUtil = require(\"./core/util\");\n\nvar Handler = require(\"./Handler\");\n\nvar Storage = require(\"./Storage\");\n\nvar Painter = require(\"./Painter\");\n\nvar Animation = require(\"./animation/Animation\");\n\nvar HandlerProxy = require(\"./dom/HandlerProxy\");\n\n/*!\n* ZRender, a high performance 2d drawing library.\n*\n* Copyright (c) 2013, Baidu Inc.\n* All rights reserved.\n*\n* LICENSE\n* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n*/\nvar useVML = !env.canvasSupported;\nvar painterCtors = {\n  canvas: Painter\n};\nvar instances = {}; // ZRender实例map索引\n\n/**\n * @type {string}\n */\n\nvar version = '3.7.4';\n/**\n * Initializing a zrender instance\n * @param {HTMLElement} dom\n * @param {Object} opts\n * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n * @param {number} [opts.devicePixelRatio]\n * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n * @return {module:zrender/ZRender}\n */\n\nfunction init(dom, opts) {\n  var zr = new ZRender(guid(), dom, opts);\n  instances[zr.id] = zr;\n  return zr;\n}\n/**\n * Dispose zrender instance\n * @param {module:zrender/ZRender} zr\n */\n\n\nfunction dispose(zr) {\n  if (zr) {\n    zr.dispose();\n  } else {\n    for (var key in instances) {\n      if (instances.hasOwnProperty(key)) {\n        instances[key].dispose();\n      }\n    }\n\n    instances = {};\n  }\n\n  return this;\n}\n/**\n * Get zrender instance by id\n * @param {string} id zrender instance id\n * @return {module:zrender/ZRender}\n */\n\n\nfunction getInstance(id) {\n  return instances[id];\n}\n\nfunction registerPainter(name, Ctor) {\n  painterCtors[name] = Ctor;\n}\n\nfunction delInstance(id) {\n  delete instances[id];\n}\n/**\n * @module zrender/ZRender\n */\n\n/**\n * @constructor\n * @alias module:zrender/ZRender\n * @param {string} id\n * @param {HTMLElement} dom\n * @param {Object} opts\n * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n * @param {number} [opts.devicePixelRatio]\n * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n */\n\n\nvar ZRender = function (id, dom, opts) {\n  opts = opts || {};\n  /**\n   * @type {HTMLDomElement}\n   */\n\n  this.dom = dom;\n  /**\n   * @type {string}\n   */\n\n  this.id = id;\n  var self = this;\n  var storage = new Storage();\n  var rendererType = opts.renderer; // TODO WebGL\n\n  if (useVML) {\n    if (!painterCtors.vml) {\n      throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n    }\n\n    rendererType = 'vml';\n  } else if (!rendererType || !painterCtors[rendererType]) {\n    rendererType = 'canvas';\n  }\n\n  var painter = new painterCtors[rendererType](dom, storage, opts);\n  this.storage = storage;\n  this.painter = painter;\n  var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n  this.handler = new Handler(storage, painter, handerProxy, painter.root);\n  /**\n   * @type {module:zrender/animation/Animation}\n   */\n\n  this.animation = new Animation({\n    stage: {\n      update: zrUtil.bind(this.flush, this)\n    }\n  });\n  this.animation.start();\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._needsRefresh; // 修改 storage.delFromStorage, 每次删除元素之前删除动画\n  // FIXME 有点ugly\n\n  var oldDelFromStorage = storage.delFromStorage;\n  var oldAddToStorage = storage.addToStorage;\n\n  storage.delFromStorage = function (el) {\n    oldDelFromStorage.call(storage, el);\n    el && el.removeSelfFromZr(self);\n  };\n\n  storage.addToStorage = function (el) {\n    oldAddToStorage.call(storage, el);\n    el.addSelfToZr(self);\n  };\n};\n\nZRender.prototype = {\n  constructor: ZRender,\n\n  /**\n   * 获取实例唯一标识\n   * @return {string}\n   */\n  getId: function () {\n    return this.id;\n  },\n\n  /**\n   * 添加元素\n   * @param  {module:zrender/Element} el\n   */\n  add: function (el) {\n    this.storage.addRoot(el);\n    this._needsRefresh = true;\n  },\n\n  /**\n   * 删除元素\n   * @param  {module:zrender/Element} el\n   */\n  remove: function (el) {\n    this.storage.delRoot(el);\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Change configuration of layer\n   * @param {string} zLevel\n   * @param {Object} config\n   * @param {string} [config.clearColor=0] Clear color\n   * @param {string} [config.motionBlur=false] If enable motion blur\n   * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n  */\n  configLayer: function (zLevel, config) {\n    this.painter.configLayer(zLevel, config);\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Repaint the canvas immediately\n   */\n  refreshImmediately: function () {\n    // var start = new Date();\n    // Clear needsRefresh ahead to avoid something wrong happens in refresh\n    // Or it will cause zrender refreshes again and again.\n    this._needsRefresh = false;\n    this.painter.refresh();\n    /**\n     * Avoid trigger zr.refresh in Element#beforeUpdate hook\n     */\n\n    this._needsRefresh = false; // var end = new Date();\n    // var log = document.getElementById('log');\n    // if (log) {\n    //     log.innerHTML = log.innerHTML + '<br>' + (end - start);\n    // }\n  },\n\n  /**\n   * Mark and repaint the canvas in the next frame of browser\n   */\n  refresh: function () {\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Perform all refresh\n   */\n  flush: function () {\n    if (this._needsRefresh) {\n      this.refreshImmediately();\n    }\n\n    if (this._needsRefreshHover) {\n      this.refreshHoverImmediately();\n    }\n  },\n\n  /**\n   * Add element to hover layer\n   * @param  {module:zrender/Element} el\n   * @param {Object} style\n   */\n  addHover: function (el, style) {\n    if (this.painter.addHover) {\n      this.painter.addHover(el, style);\n      this.refreshHover();\n    }\n  },\n\n  /**\n   * Add element from hover layer\n   * @param  {module:zrender/Element} el\n   */\n  removeHover: function (el) {\n    if (this.painter.removeHover) {\n      this.painter.removeHover(el);\n      this.refreshHover();\n    }\n  },\n\n  /**\n   * Clear all hover elements in hover layer\n   * @param  {module:zrender/Element} el\n   */\n  clearHover: function () {\n    if (this.painter.clearHover) {\n      this.painter.clearHover();\n      this.refreshHover();\n    }\n  },\n\n  /**\n   * Refresh hover in next frame\n   */\n  refreshHover: function () {\n    this._needsRefreshHover = true;\n  },\n\n  /**\n   * Refresh hover immediately\n   */\n  refreshHoverImmediately: function () {\n    this._needsRefreshHover = false;\n    this.painter.refreshHover && this.painter.refreshHover();\n  },\n\n  /**\n   * Resize the canvas.\n   * Should be invoked when container size is changed\n   * @param {Object} [opts]\n   * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n   * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n   */\n  resize: function (opts) {\n    opts = opts || {};\n    this.painter.resize(opts.width, opts.height);\n    this.handler.resize();\n  },\n\n  /**\n   * Stop and clear all animation immediately\n   */\n  clearAnimation: function () {\n    this.animation.clear();\n  },\n\n  /**\n   * Get container width\n   */\n  getWidth: function () {\n    return this.painter.getWidth();\n  },\n\n  /**\n   * Get container height\n   */\n  getHeight: function () {\n    return this.painter.getHeight();\n  },\n\n  /**\n   * Export the canvas as Base64 URL\n   * @param {string} type\n   * @param {string} [backgroundColor='#fff']\n   * @return {string} Base64 URL\n   */\n  // toDataURL: function(type, backgroundColor) {\n  //     return this.painter.getRenderedCanvas({\n  //         backgroundColor: backgroundColor\n  //     }).toDataURL(type);\n  // },\n\n  /**\n   * Converting a path to image.\n   * It has much better performance of drawing image rather than drawing a vector path.\n   * @param {module:zrender/graphic/Path} e\n   * @param {number} width\n   * @param {number} height\n   */\n  pathToImage: function (e, dpr) {\n    return this.painter.pathToImage(e, dpr);\n  },\n\n  /**\n   * Set default cursor\n   * @param {string} [cursorStyle='default'] 例如 crosshair\n   */\n  setCursorStyle: function (cursorStyle) {\n    this.handler.setCursorStyle(cursorStyle);\n  },\n\n  /**\n   * Find hovered element\n   * @param {number} x\n   * @param {number} y\n   * @return {Object} {target, topTarget}\n   */\n  findHover: function (x, y) {\n    return this.handler.findHover(x, y);\n  },\n\n  /**\n   * Bind event\n   *\n   * @param {string} eventName Event name\n   * @param {Function} eventHandler Handler function\n   * @param {Object} [context] Context object\n   */\n  on: function (eventName, eventHandler, context) {\n    this.handler.on(eventName, eventHandler, context);\n  },\n\n  /**\n   * Unbind event\n   * @param {string} eventName Event name\n   * @param {Function} [eventHandler] Handler function\n   */\n  off: function (eventName, eventHandler) {\n    this.handler.off(eventName, eventHandler);\n  },\n\n  /**\n   * Trigger event manually\n   *\n   * @param {string} eventName Event name\n   * @param {event=} event Event object\n   */\n  trigger: function (eventName, event) {\n    this.handler.trigger(eventName, event);\n  },\n\n  /**\n   * Clear all objects and the canvas.\n   */\n  clear: function () {\n    this.storage.delRoot();\n    this.painter.clear();\n  },\n\n  /**\n   * Dispose self.\n   */\n  dispose: function () {\n    this.animation.stop();\n    this.clear();\n    this.storage.dispose();\n    this.painter.dispose();\n    this.handler.dispose();\n    this.animation = this.storage = this.painter = this.handler = null;\n    delInstance(this.id);\n  }\n};\nexports.version = version;\nexports.init = init;\nexports.dispose = dispose;\nexports.getInstance = getInstance;\nexports.registerPainter = registerPainter;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/zrender.js\n// module id = 3\n// module chunks = 0","/**\n * zrender: 生成唯一id\n *\n * @author errorrik (errorrik@gmail.com)\n */\nvar idStart = 0x0907;\n\nfunction _default() {\n  return idStart++;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/guid.js\n// module id = 4\n// module chunks = 0","/**\n * echarts设备环境识别\n *\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\nvar env = {};\n\nif (typeof navigator === 'undefined') {\n  // In node\n  env = {\n    browser: {},\n    os: {},\n    node: true,\n    // Assume canvas is supported\n    canvasSupported: true,\n    svgSupported: true\n  };\n} else {\n  env = detect(navigator.userAgent);\n}\n\nvar _default = env; // Zepto.js\n// (c) 2010-2013 Thomas Fuchs\n// Zepto.js may be freely distributed under the MIT license.\n\nfunction detect(ua) {\n  var os = {};\n  var browser = {}; // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n  // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n  // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n  // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n  // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n  // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n  // var touchpad = webos && ua.match(/TouchPad/);\n  // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n  // var silk = ua.match(/Silk\\/([\\d._]+)/);\n  // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n  // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n  // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n  // var playbook = ua.match(/PlayBook/);\n  // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\n  var firefox = ua.match(/Firefox\\/([\\d.]+)/); // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n  // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\n  var ie = ua.match(/MSIE\\s([\\d.]+)/) // IE 11 Trident/7.0; rv:11.0\n  || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n  var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n  var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:\n  // - discern (more) between multiple browsers on android\n  // - decide if kindle fire in silk mode is android or not\n  // - Firefox on Android doesn't specify the Android version\n  // - possibly devide in os, device and browser hashes\n  // if (browser.webkit = !!webkit) browser.version = webkit[1];\n  // if (android) os.android = true, os.version = android[2];\n  // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n  // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n  // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n  // if (webos) os.webos = true, os.version = webos[2];\n  // if (touchpad) os.touchpad = true;\n  // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n  // if (bb10) os.bb10 = true, os.version = bb10[2];\n  // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n  // if (playbook) browser.playbook = true;\n  // if (kindle) os.kindle = true, os.version = kindle[1];\n  // if (silk) browser.silk = true, browser.version = silk[1];\n  // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n  // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\n  if (firefox) {\n    browser.firefox = true;\n    browser.version = firefox[1];\n  } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n  // if (webview) browser.webview = true;\n\n\n  if (ie) {\n    browser.ie = true;\n    browser.version = ie[1];\n  }\n\n  if (edge) {\n    browser.edge = true;\n    browser.version = edge[1];\n  } // It is difficult to detect WeChat in Win Phone precisely, because ua can\n  // not be set on win phone. So we do not consider Win Phone.\n\n\n  if (weChat) {\n    browser.weChat = true;\n  } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n  //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n  // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n  //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n  //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n\n  return {\n    browser: browser,\n    os: os,\n    node: false,\n    // 原生canvas支持，改极端点了\n    // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n    canvasSupported: !!document.createElement('canvas').getContext,\n    svgSupported: typeof SVGRect !== 'undefined',\n    // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n    // works on most browsers\n    // IE10/11 does not support touch event, and MS Edge supports them but not by\n    // default, so we dont check navigator.maxTouchPoints for them here.\n    touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n    // <http://caniuse.com/#search=pointer%20event>.\n    pointerEventsSupported: 'onpointerdown' in window // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n    // events currently. So we dont use that on other browsers unless tested sufficiently.\n    // Although IE 10 supports pointer event, it use old style and is different from the\n    // standard. So we exclude that. (IE 10 is hardly used on touch device)\n    && (browser.edge || browser.ie && browser.version >= 11)\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/env.js\n// module id = 5\n// module chunks = 0","/**\n * @module zrender/core/util\n */\n// 用于处理merge时无法遍历Date等对象的问题\nvar BUILTIN_OBJECT = {\n  '[object Function]': 1,\n  '[object RegExp]': 1,\n  '[object Date]': 1,\n  '[object Error]': 1,\n  '[object CanvasGradient]': 1,\n  '[object CanvasPattern]': 1,\n  // For node-canvas\n  '[object Image]': 1,\n  '[object Canvas]': 1\n};\nvar TYPED_ARRAY = {\n  '[object Int8Array]': 1,\n  '[object Uint8Array]': 1,\n  '[object Uint8ClampedArray]': 1,\n  '[object Int16Array]': 1,\n  '[object Uint16Array]': 1,\n  '[object Int32Array]': 1,\n  '[object Uint32Array]': 1,\n  '[object Float32Array]': 1,\n  '[object Float64Array]': 1\n};\nvar objToString = Object.prototype.toString;\nvar arrayProto = Array.prototype;\nvar nativeForEach = arrayProto.forEach;\nvar nativeFilter = arrayProto.filter;\nvar nativeSlice = arrayProto.slice;\nvar nativeMap = arrayProto.map;\nvar nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * Those data types can be cloned:\n *     Plain object, Array, TypedArray, number, string, null, undefined.\n * Those data types will be assgined using the orginal data:\n *     BUILTIN_OBJECT\n * Instance of user defined class will be cloned to a plain object, without\n * properties in prototype.\n * Other data types is not supported (not sure what will happen).\n *\n * Caution: do not support clone Date, for performance consideration.\n * (There might be a large number of date in `series.data`).\n * So date should not be modified in and out of echarts.\n *\n * @param {*} source\n * @return {*} new\n */\n\n\nfunction clone(source) {\n  if (source == null || typeof source != 'object') {\n    return source;\n  }\n\n  var result = source;\n  var typeStr = objToString.call(source);\n\n  if (typeStr === '[object Array]') {\n    result = [];\n\n    for (var i = 0, len = source.length; i < len; i++) {\n      result[i] = clone(source[i]);\n    }\n  } else if (TYPED_ARRAY[typeStr]) {\n    var Ctor = source.constructor;\n\n    if (source.constructor.from) {\n      result = Ctor.from(source);\n    } else {\n      result = new Ctor(source.length);\n\n      for (var i = 0, len = source.length; i < len; i++) {\n        result[i] = clone(source[i]);\n      }\n    }\n  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n    result = {};\n\n    for (var key in source) {\n      if (source.hasOwnProperty(key)) {\n        result[key] = clone(source[key]);\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} target\n * @param {*} source\n * @param {boolean} [overwrite=false]\n */\n\n\nfunction merge(target, source, overwrite) {\n  // We should escapse that source is string\n  // and enter for ... in ...\n  if (!isObject(source) || !isObject(target)) {\n    return overwrite ? clone(source) : target;\n  }\n\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      var targetProp = target[key];\n      var sourceProp = source[key];\n\n      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {\n        // 如果需要递归覆盖，就递归调用merge\n        merge(targetProp, sourceProp, overwrite);\n      } else if (overwrite || !(key in target)) {\n        // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n        // NOTE，在 target[key] 不存在的时候也是直接覆盖\n        target[key] = clone(source[key], true);\n      }\n    }\n  }\n\n  return target;\n}\n/**\n * @param {Array} targetAndSources The first item is target, and the rests are source.\n * @param {boolean} [overwrite=false]\n * @return {*} target\n */\n\n\nfunction mergeAll(targetAndSources, overwrite) {\n  var result = targetAndSources[0];\n\n  for (var i = 1, len = targetAndSources.length; i < len; i++) {\n    result = merge(result, targetAndSources[i], overwrite);\n  }\n\n  return result;\n}\n/**\n * @param {*} target\n * @param {*} source\n * @memberOf module:zrender/core/util\n */\n\n\nfunction extend(target, source) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n/**\n * @param {*} target\n * @param {*} source\n * @param {boolean} [overlay=false]\n * @memberOf module:zrender/core/util\n */\n\n\nfunction defaults(target, source, overlay) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nvar createCanvas = function () {\n  return methods.createCanvas();\n};\n\nmethods.createCanvas = function () {\n  return document.createElement('canvas');\n}; // FIXME\n\n\nvar _ctx;\n\nfunction getContext() {\n  if (!_ctx) {\n    // Use util.createCanvas instead of createCanvas\n    // because createCanvas may be overwritten in different environment\n    _ctx = createCanvas().getContext('2d');\n  }\n\n  return _ctx;\n}\n/**\n * 查询数组中元素的index\n * @memberOf module:zrender/core/util\n */\n\n\nfunction indexOf(array, value) {\n  if (array) {\n    if (array.indexOf) {\n      return array.indexOf(value);\n    }\n\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (array[i] === value) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n}\n/**\n * 构造类继承关系\n *\n * @memberOf module:zrender/core/util\n * @param {Function} clazz 源类\n * @param {Function} baseClazz 基类\n */\n\n\nfunction inherits(clazz, baseClazz) {\n  var clazzPrototype = clazz.prototype;\n\n  function F() {}\n\n  F.prototype = baseClazz.prototype;\n  clazz.prototype = new F();\n\n  for (var prop in clazzPrototype) {\n    clazz.prototype[prop] = clazzPrototype[prop];\n  }\n\n  clazz.prototype.constructor = clazz;\n  clazz.superClass = baseClazz;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Object|Function} target\n * @param {Object|Function} sorce\n * @param {boolean} overlay\n */\n\n\nfunction mixin(target, source, overlay) {\n  target = 'prototype' in target ? target.prototype : target;\n  source = 'prototype' in source ? source.prototype : source;\n  defaults(target, source, overlay);\n}\n/**\n * Consider typed array.\n * @param {Array|TypedArray} data\n */\n\n\nfunction isArrayLike(data) {\n  if (!data) {\n    return;\n  }\n\n  if (typeof data == 'string') {\n    return false;\n  }\n\n  return typeof data.length == 'number';\n}\n/**\n * 数组或对象遍历\n * @memberOf module:zrender/core/util\n * @param {Object|Array} obj\n * @param {Function} cb\n * @param {*} [context]\n */\n\n\nfunction each(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.forEach && obj.forEach === nativeForEach) {\n    obj.forEach(cb, context);\n  } else if (obj.length === +obj.length) {\n    for (var i = 0, len = obj.length; i < len; i++) {\n      cb.call(context, obj[i], i, obj);\n    }\n  } else {\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        cb.call(context, obj[key], key, obj);\n      }\n    }\n  }\n}\n/**\n * 数组映射\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction map(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.map && obj.map === nativeMap) {\n    return obj.map(cb, context);\n  } else {\n    var result = [];\n\n    for (var i = 0, len = obj.length; i < len; i++) {\n      result.push(cb.call(context, obj[i], i, obj));\n    }\n\n    return result;\n  }\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {Object} [memo]\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction reduce(obj, cb, memo, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.reduce && obj.reduce === nativeReduce) {\n    return obj.reduce(cb, memo, context);\n  } else {\n    for (var i = 0, len = obj.length; i < len; i++) {\n      memo = cb.call(context, memo, obj[i], i, obj);\n    }\n\n    return memo;\n  }\n}\n/**\n * 数组过滤\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction filter(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.filter && obj.filter === nativeFilter) {\n    return obj.filter(cb, context);\n  } else {\n    var result = [];\n\n    for (var i = 0, len = obj.length; i < len; i++) {\n      if (cb.call(context, obj[i], i, obj)) {\n        result.push(obj[i]);\n      }\n    }\n\n    return result;\n  }\n}\n/**\n * 数组项查找\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {*}\n */\n\n\nfunction find(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  for (var i = 0, len = obj.length; i < len; i++) {\n    if (cb.call(context, obj[i], i, obj)) {\n      return obj[i];\n    }\n  }\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Function} func\n * @param {*} context\n * @return {Function}\n */\n\n\nfunction bind(func, context) {\n  var args = nativeSlice.call(arguments, 2);\n  return function () {\n    return func.apply(context, args.concat(nativeSlice.call(arguments)));\n  };\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Function} func\n * @return {Function}\n */\n\n\nfunction curry(func) {\n  var args = nativeSlice.call(arguments, 1);\n  return function () {\n    return func.apply(this, args.concat(nativeSlice.call(arguments)));\n  };\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isArray(value) {\n  return objToString.call(value) === '[object Array]';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isString(value) {\n  return objToString.call(value) === '[object String]';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return type === 'function' || !!value && type == 'object';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isBuiltInObject(value) {\n  return !!BUILTIN_OBJECT[objToString.call(value)];\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isDom(value) {\n  return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';\n}\n/**\n * Whether is exactly NaN. Notice isNaN('a') returns true.\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction eqNaN(value) {\n  return value !== value;\n}\n/**\n * If value1 is not null, then return value1, otherwise judget rest of values.\n * Low performance.\n * @memberOf module:zrender/core/util\n * @return {*} Final value\n */\n\n\nfunction retrieve(values) {\n  for (var i = 0, len = arguments.length; i < len; i++) {\n    if (arguments[i] != null) {\n      return arguments[i];\n    }\n  }\n}\n\nfunction retrieve2(value0, value1) {\n  return value0 != null ? value0 : value1;\n}\n\nfunction retrieve3(value0, value1, value2) {\n  return value0 != null ? value0 : value1 != null ? value1 : value2;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Array} arr\n * @param {number} startIndex\n * @param {number} endIndex\n * @return {Array}\n */\n\n\nfunction slice() {\n  return Function.call.apply(nativeSlice, arguments);\n}\n/**\n * Normalize css liked array configuration\n * e.g.\n *  3 => [3, 3, 3, 3]\n *  [4, 2] => [4, 2, 4, 2]\n *  [4, 3, 2] => [4, 3, 2, 3]\n * @param {number|Array.<number>} val\n * @return {Array.<number>}\n */\n\n\nfunction normalizeCssArray(val) {\n  if (typeof val === 'number') {\n    return [val, val, val, val];\n  }\n\n  var len = val.length;\n\n  if (len === 2) {\n    // vertical | horizontal\n    return [val[0], val[1], val[0], val[1]];\n  } else if (len === 3) {\n    // top | horizontal | bottom\n    return [val[0], val[1], val[2], val[1]];\n  }\n\n  return val;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {boolean} condition\n * @param {string} message\n */\n\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nvar primitiveKey = '__ec_primitive__';\n/**\n * Set an object as primitive to be ignored traversing children in clone or merge\n */\n\nfunction setAsPrimitive(obj) {\n  obj[primitiveKey] = true;\n}\n\nfunction isPrimitive(obj) {\n  return obj[primitiveKey];\n}\n/**\n * @constructor\n * @param {Object} obj Only apply `ownProperty`.\n */\n\n\nfunction HashMap(obj) {\n  obj && each(obj, function (value, key) {\n    this.set(key, value);\n  }, this);\n} // Add prefix to avoid conflict with Object.prototype.\n\n\nvar HASH_MAP_PREFIX = '_ec_';\nvar HASH_MAP_PREFIX_LENGTH = 4;\nHashMap.prototype = {\n  constructor: HashMap,\n  // Do not provide `has` method to avoid defining what is `has`.\n  // (We usually treat `null` and `undefined` as the same, different\n  // from ES6 Map).\n  get: function (key) {\n    return this[HASH_MAP_PREFIX + key];\n  },\n  set: function (key, value) {\n    this[HASH_MAP_PREFIX + key] = value; // Comparing with invocation chaining, `return value` is more commonly\n    // used in this case: `var someVal = map.set('a', genVal());`\n\n    return value;\n  },\n  // Although util.each can be performed on this hashMap directly, user\n  // should not use the exposed keys, who are prefixed.\n  each: function (cb, context) {\n    context !== void 0 && (cb = bind(cb, context));\n\n    for (var prefixedKey in this) {\n      this.hasOwnProperty(prefixedKey) && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n    }\n  },\n  // Do not use this method if performance sensitive.\n  removeKey: function (key) {\n    delete this[HASH_MAP_PREFIX + key];\n  }\n};\n\nfunction createHashMap(obj) {\n  return new HashMap(obj);\n}\n\nfunction noop() {}\n\nexports.$override = $override;\nexports.clone = clone;\nexports.merge = merge;\nexports.mergeAll = mergeAll;\nexports.extend = extend;\nexports.defaults = defaults;\nexports.createCanvas = createCanvas;\nexports.getContext = getContext;\nexports.indexOf = indexOf;\nexports.inherits = inherits;\nexports.mixin = mixin;\nexports.isArrayLike = isArrayLike;\nexports.each = each;\nexports.map = map;\nexports.reduce = reduce;\nexports.filter = filter;\nexports.find = find;\nexports.bind = bind;\nexports.curry = curry;\nexports.isArray = isArray;\nexports.isFunction = isFunction;\nexports.isString = isString;\nexports.isObject = isObject;\nexports.isBuiltInObject = isBuiltInObject;\nexports.isDom = isDom;\nexports.eqNaN = eqNaN;\nexports.retrieve = retrieve;\nexports.retrieve2 = retrieve2;\nexports.retrieve3 = retrieve3;\nexports.slice = slice;\nexports.normalizeCssArray = normalizeCssArray;\nexports.assert = assert;\nexports.setAsPrimitive = setAsPrimitive;\nexports.isPrimitive = isPrimitive;\nexports.createHashMap = createHashMap;\nexports.noop = noop;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/util.js\n// module id = 6\n// module chunks = 0","var util = require(\"./core/util\");\n\nvar vec2 = require(\"./core/vector\");\n\nvar Draggable = require(\"./mixin/Draggable\");\n\nvar Eventful = require(\"./mixin/Eventful\");\n\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\nvar SILENT = 'silent';\n\nfunction makeEventPacket(eveType, targetInfo, event) {\n  return {\n    type: eveType,\n    event: event,\n    // target can only be an element that is not silent.\n    target: targetInfo.target,\n    // topTarget can be a silent element.\n    topTarget: targetInfo.topTarget,\n    cancelBubble: false,\n    offsetX: event.zrX,\n    offsetY: event.zrY,\n    gestureEvent: event.gestureEvent,\n    pinchX: event.pinchX,\n    pinchY: event.pinchY,\n    pinchScale: event.pinchScale,\n    wheelDelta: event.zrDelta,\n    zrByTouch: event.zrByTouch,\n    which: event.which\n  };\n}\n\nfunction EmptyProxy() {}\n\nEmptyProxy.prototype.dispose = function () {};\n\nvar handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n/**\n * @alias module:zrender/Handler\n * @constructor\n * @extends module:zrender/mixin/Eventful\n * @param {module:zrender/Storage} storage Storage instance.\n * @param {module:zrender/Painter} painter Painter instance.\n * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n */\n\nvar Handler = function (storage, painter, proxy, painterRoot) {\n  Eventful.call(this);\n  this.storage = storage;\n  this.painter = painter;\n  this.painterRoot = painterRoot;\n  proxy = proxy || new EmptyProxy();\n  /**\n   * Proxy of event. can be Dom, WebGLSurface, etc.\n   */\n\n  this.proxy = proxy; // Attach handler\n\n  proxy.handler = this;\n  /**\n   * {target, topTarget, x, y}\n   * @private\n   * @type {Object}\n   */\n\n  this._hovered = {};\n  /**\n   * @private\n   * @type {Date}\n   */\n\n  this._lastTouchMoment;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._lastX;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._lastY;\n  Draggable.call(this);\n  util.each(handlerNames, function (name) {\n    proxy.on && proxy.on(name, this[name], this);\n  }, this);\n};\n\nHandler.prototype = {\n  constructor: Handler,\n  mousemove: function (event) {\n    var x = event.zrX;\n    var y = event.zrY;\n    var lastHovered = this._hovered;\n    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call\n    // (like 'setOption' or 'dispatchAction') in event handlers, we should find\n    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.\n    // See #6198.\n\n    if (lastHoveredTarget && !lastHoveredTarget.__zr) {\n      lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n      lastHoveredTarget = lastHovered.target;\n    }\n\n    var hovered = this._hovered = this.findHover(x, y);\n    var hoveredTarget = hovered.target;\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element\n\n    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(lastHovered, 'mouseout', event);\n    } // Mouse moving on one element\n\n\n    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element\n\n    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(hovered, 'mouseover', event);\n    }\n  },\n  mouseout: function (event) {\n    this.dispatchToElement(this._hovered, 'mouseout', event); // There might be some doms created by upper layer application\n    // at the same level of painter.getViewportRoot() (e.g., tooltip\n    // dom created by echarts), where 'globalout' event should not\n    // be triggered when mouse enters these doms. (But 'mouseout'\n    // should be triggered at the original hovered element as usual).\n\n    var element = event.toElement || event.relatedTarget;\n    var innerDom;\n\n    do {\n      element = element && element.parentNode;\n    } while (element && element.nodeType != 9 && !(innerDom = element === this.painterRoot));\n\n    !innerDom && this.trigger('globalout', {\n      event: event\n    });\n  },\n\n  /**\n   * Resize\n   */\n  resize: function (event) {\n    this._hovered = {};\n  },\n\n  /**\n   * Dispatch event\n   * @param {string} eventName\n   * @param {event=} eventArgs\n   */\n  dispatch: function (eventName, eventArgs) {\n    var handler = this[eventName];\n    handler && handler.call(this, eventArgs);\n  },\n\n  /**\n   * Dispose\n   */\n  dispose: function () {\n    this.proxy.dispose();\n    this.storage = this.proxy = this.painter = null;\n  },\n\n  /**\n   * 设置默认的cursor style\n   * @param {string} [cursorStyle='default'] 例如 crosshair\n   */\n  setCursorStyle: function (cursorStyle) {\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(cursorStyle);\n  },\n\n  /**\n   * 事件分发代理\n   *\n   * @private\n   * @param {Object} targetInfo {target, topTarget} 目标图形元素\n   * @param {string} eventName 事件名称\n   * @param {Object} event 事件对象\n   */\n  dispatchToElement: function (targetInfo, eventName, event) {\n    targetInfo = targetInfo || {};\n    var el = targetInfo.target;\n\n    if (el && el.silent) {\n      return;\n    }\n\n    var eventHandler = 'on' + eventName;\n    var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\n    while (el) {\n      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n      el.trigger(eventName, eventPacket);\n      el = el.parent;\n\n      if (eventPacket.cancelBubble) {\n        break;\n      }\n    }\n\n    if (!eventPacket.cancelBubble) {\n      // 冒泡到顶级 zrender 对象\n      this.trigger(eventName, eventPacket); // 分发事件到用户自定义层\n      // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n\n      this.painter && this.painter.eachOtherLayer(function (layer) {\n        if (typeof layer[eventHandler] == 'function') {\n          layer[eventHandler].call(layer, eventPacket);\n        }\n\n        if (layer.trigger) {\n          layer.trigger(eventName, eventPacket);\n        }\n      });\n    }\n  },\n\n  /**\n   * @private\n   * @param {number} x\n   * @param {number} y\n   * @param {module:zrender/graphic/Displayable} exclude\n   * @return {model:zrender/Element}\n   * @method\n   */\n  findHover: function (x, y, exclude) {\n    var list = this.storage.getDisplayList();\n    var out = {\n      x: x,\n      y: y\n    };\n\n    for (var i = list.length - 1; i >= 0; i--) {\n      var hoverCheckResult;\n\n      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode\n      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {\n        !out.topTarget && (out.topTarget = list[i]);\n\n        if (hoverCheckResult !== SILENT) {\n          out.target = list[i];\n          break;\n        }\n      }\n    }\n\n    return out;\n  }\n}; // Common handlers\n\nutil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  Handler.prototype[name] = function (event) {\n    // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n    var hovered = this.findHover(event.zrX, event.zrY);\n    var hoveredTarget = hovered.target;\n\n    if (name === 'mousedown') {\n      this._downEl = hoveredTarget;\n      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup\n\n      this._upEl = hoveredTarget;\n    } else if (name === 'mosueup') {\n      this._upEl = hoveredTarget;\n    } else if (name === 'click') {\n      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,\n      // including the case that `mousedown` - `mousemove` - `mouseup`,\n      // which should be filtered, otherwise it will bring trouble to\n      // pan and zoom.\n      || !this._downPoint // Arbitrary value\n      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {\n        return;\n      }\n\n      this._downPoint = null;\n    }\n\n    this.dispatchToElement(hovered, name, event);\n  };\n});\n\nfunction isHover(displayable, x, y) {\n  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n    var el = displayable;\n    var isSilent;\n\n    while (el) {\n      // If clipped by ancestor.\n      // FIXME: If clipPath has neither stroke nor fill,\n      // el.clipPath.contain(x, y) will always return false.\n      if (el.clipPath && !el.clipPath.contain(x, y)) {\n        return false;\n      }\n\n      if (el.silent) {\n        isSilent = true;\n      }\n\n      el = el.parent;\n    }\n\n    return isSilent ? SILENT : true;\n  }\n\n  return false;\n}\n\nutil.mixin(Handler, Eventful);\nutil.mixin(Handler, Draggable);\nvar _default = Handler;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Handler.js\n// module id = 7\n// module chunks = 0","var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n/**\n * 创建一个向量\n * @param {number} [x=0]\n * @param {number} [y=0]\n * @return {Vector2}\n */\n\nfunction create(x, y) {\n  var out = new ArrayCtor(2);\n\n  if (x == null) {\n    x = 0;\n  }\n\n  if (y == null) {\n    y = 0;\n  }\n\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * 复制向量数据\n * @param {Vector2} out\n * @param {Vector2} v\n * @return {Vector2}\n */\n\n\nfunction copy(out, v) {\n  out[0] = v[0];\n  out[1] = v[1];\n  return out;\n}\n/**\n * 克隆一个向量\n * @param {Vector2} v\n * @return {Vector2}\n */\n\n\nfunction clone(v) {\n  var out = new ArrayCtor(2);\n  out[0] = v[0];\n  out[1] = v[1];\n  return out;\n}\n/**\n * 设置向量的两个项\n * @param {Vector2} out\n * @param {number} a\n * @param {number} b\n * @return {Vector2} 结果\n */\n\n\nfunction set(out, a, b) {\n  out[0] = a;\n  out[1] = b;\n  return out;\n}\n/**\n * 向量相加\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction add(out, v1, v2) {\n  out[0] = v1[0] + v2[0];\n  out[1] = v1[1] + v2[1];\n  return out;\n}\n/**\n * 向量缩放后相加\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @param {number} a\n */\n\n\nfunction scaleAndAdd(out, v1, v2, a) {\n  out[0] = v1[0] + v2[0] * a;\n  out[1] = v1[1] + v2[1] * a;\n  return out;\n}\n/**\n * 向量相减\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction sub(out, v1, v2) {\n  out[0] = v1[0] - v2[0];\n  out[1] = v1[1] - v2[1];\n  return out;\n}\n/**\n * 向量长度\n * @param {Vector2} v\n * @return {number}\n */\n\n\nfunction len(v) {\n  return Math.sqrt(lenSquare(v));\n}\n\nvar length = len; // jshint ignore:line\n\n/**\n * 向量长度平方\n * @param {Vector2} v\n * @return {number}\n */\n\nfunction lenSquare(v) {\n  return v[0] * v[0] + v[1] * v[1];\n}\n\nvar lengthSquare = lenSquare;\n/**\n * 向量乘法\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\nfunction mul(out, v1, v2) {\n  out[0] = v1[0] * v2[0];\n  out[1] = v1[1] * v2[1];\n  return out;\n}\n/**\n * 向量除法\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction div(out, v1, v2) {\n  out[0] = v1[0] / v2[0];\n  out[1] = v1[1] / v2[1];\n  return out;\n}\n/**\n * 向量点乘\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\n\nfunction dot(v1, v2) {\n  return v1[0] * v2[0] + v1[1] * v2[1];\n}\n/**\n * 向量缩放\n * @param {Vector2} out\n * @param {Vector2} v\n * @param {number} s\n */\n\n\nfunction scale(out, v, s) {\n  out[0] = v[0] * s;\n  out[1] = v[1] * s;\n  return out;\n}\n/**\n * 向量归一化\n * @param {Vector2} out\n * @param {Vector2} v\n */\n\n\nfunction normalize(out, v) {\n  var d = len(v);\n\n  if (d === 0) {\n    out[0] = 0;\n    out[1] = 0;\n  } else {\n    out[0] = v[0] / d;\n    out[1] = v[1] / d;\n  }\n\n  return out;\n}\n/**\n * 计算向量间距离\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\n\nfunction distance(v1, v2) {\n  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));\n}\n\nvar dist = distance;\n/**\n * 向量距离平方\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\nfunction distanceSquare(v1, v2) {\n  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n}\n\nvar distSquare = distanceSquare;\n/**\n * 求负向量\n * @param {Vector2} out\n * @param {Vector2} v\n */\n\nfunction negate(out, v) {\n  out[0] = -v[0];\n  out[1] = -v[1];\n  return out;\n}\n/**\n * 插值两个点\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @param {number} t\n */\n\n\nfunction lerp(out, v1, v2, t) {\n  out[0] = v1[0] + t * (v2[0] - v1[0]);\n  out[1] = v1[1] + t * (v2[1] - v1[1]);\n  return out;\n}\n/**\n * 矩阵左乘向量\n * @param {Vector2} out\n * @param {Vector2} v\n * @param {Vector2} m\n */\n\n\nfunction applyTransform(out, v, m) {\n  var x = v[0];\n  var y = v[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\n * 求两个向量最小值\n * @param  {Vector2} out\n * @param  {Vector2} v1\n * @param  {Vector2} v2\n */\n\n\nfunction min(out, v1, v2) {\n  out[0] = Math.min(v1[0], v2[0]);\n  out[1] = Math.min(v1[1], v2[1]);\n  return out;\n}\n/**\n * 求两个向量最大值\n * @param  {Vector2} out\n * @param  {Vector2} v1\n * @param  {Vector2} v2\n */\n\n\nfunction max(out, v1, v2) {\n  out[0] = Math.max(v1[0], v2[0]);\n  out[1] = Math.max(v1[1], v2[1]);\n  return out;\n}\n\nexports.create = create;\nexports.copy = copy;\nexports.clone = clone;\nexports.set = set;\nexports.add = add;\nexports.scaleAndAdd = scaleAndAdd;\nexports.sub = sub;\nexports.len = len;\nexports.length = length;\nexports.lenSquare = lenSquare;\nexports.lengthSquare = lengthSquare;\nexports.mul = mul;\nexports.div = div;\nexports.dot = dot;\nexports.scale = scale;\nexports.normalize = normalize;\nexports.distance = distance;\nexports.dist = dist;\nexports.distanceSquare = distanceSquare;\nexports.distSquare = distSquare;\nexports.negate = negate;\nexports.lerp = lerp;\nexports.applyTransform = applyTransform;\nexports.min = min;\nexports.max = max;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/vector.js\n// module id = 8\n// module chunks = 0","// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\nfunction Draggable() {\n  this.on('mousedown', this._dragStart, this);\n  this.on('mousemove', this._drag, this);\n  this.on('mouseup', this._dragEnd, this);\n  this.on('globalout', this._dragEnd, this); // this._dropTarget = null;\n  // this._draggingTarget = null;\n  // this._x = 0;\n  // this._y = 0;\n}\n\nDraggable.prototype = {\n  constructor: Draggable,\n  _dragStart: function (e) {\n    var draggingTarget = e.target;\n\n    if (draggingTarget && draggingTarget.draggable) {\n      this._draggingTarget = draggingTarget;\n      draggingTarget.dragging = true;\n      this._x = e.offsetX;\n      this._y = e.offsetY;\n      this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n    }\n  },\n  _drag: function (e) {\n    var draggingTarget = this._draggingTarget;\n\n    if (draggingTarget) {\n      var x = e.offsetX;\n      var y = e.offsetY;\n      var dx = x - this._x;\n      var dy = y - this._y;\n      this._x = x;\n      this._y = y;\n      draggingTarget.drift(dx, dy, e);\n      this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n      var dropTarget = this.findHover(x, y, draggingTarget).target;\n      var lastDropTarget = this._dropTarget;\n      this._dropTarget = dropTarget;\n\n      if (draggingTarget !== dropTarget) {\n        if (lastDropTarget && dropTarget !== lastDropTarget) {\n          this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n        }\n\n        if (dropTarget && dropTarget !== lastDropTarget) {\n          this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n        }\n      }\n    }\n  },\n  _dragEnd: function (e) {\n    var draggingTarget = this._draggingTarget;\n\n    if (draggingTarget) {\n      draggingTarget.dragging = false;\n    }\n\n    this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\n    if (this._dropTarget) {\n      this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n    }\n\n    this._draggingTarget = null;\n    this._dropTarget = null;\n  }\n};\n\nfunction param(target, e) {\n  return {\n    target: target,\n    topTarget: e && e.topTarget\n  };\n}\n\nvar _default = Draggable;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Draggable.js\n// module id = 9\n// module chunks = 0","/**\n * 事件扩展\n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\nvar arrySlice = Array.prototype.slice;\n/**\n * 事件分发器\n * @alias module:zrender/mixin/Eventful\n * @constructor\n */\n\nvar Eventful = function () {\n  this._$handlers = {};\n};\n\nEventful.prototype = {\n  constructor: Eventful,\n\n  /**\n   * 单次触发绑定，trigger后销毁\n   *\n   * @param {string} event 事件名\n   * @param {Function} handler 响应函数\n   * @param {Object} context\n   */\n  one: function (event, handler, context) {\n    var _h = this._$handlers;\n\n    if (!handler || !event) {\n      return this;\n    }\n\n    if (!_h[event]) {\n      _h[event] = [];\n    }\n\n    for (var i = 0; i < _h[event].length; i++) {\n      if (_h[event][i].h === handler) {\n        return this;\n      }\n    }\n\n    _h[event].push({\n      h: handler,\n      one: true,\n      ctx: context || this\n    });\n\n    return this;\n  },\n\n  /**\n   * 绑定事件\n   * @param {string} event 事件名\n   * @param {Function} handler 事件处理函数\n   * @param {Object} [context]\n   */\n  on: function (event, handler, context) {\n    var _h = this._$handlers;\n\n    if (!handler || !event) {\n      return this;\n    }\n\n    if (!_h[event]) {\n      _h[event] = [];\n    }\n\n    for (var i = 0; i < _h[event].length; i++) {\n      if (_h[event][i].h === handler) {\n        return this;\n      }\n    }\n\n    _h[event].push({\n      h: handler,\n      one: false,\n      ctx: context || this\n    });\n\n    return this;\n  },\n\n  /**\n   * 是否绑定了事件\n   * @param  {string}  event\n   * @return {boolean}\n   */\n  isSilent: function (event) {\n    var _h = this._$handlers;\n    return _h[event] && _h[event].length;\n  },\n\n  /**\n   * 解绑事件\n   * @param {string} event 事件名\n   * @param {Function} [handler] 事件处理函数\n   */\n  off: function (event, handler) {\n    var _h = this._$handlers;\n\n    if (!event) {\n      this._$handlers = {};\n      return this;\n    }\n\n    if (handler) {\n      if (_h[event]) {\n        var newList = [];\n\n        for (var i = 0, l = _h[event].length; i < l; i++) {\n          if (_h[event][i]['h'] != handler) {\n            newList.push(_h[event][i]);\n          }\n        }\n\n        _h[event] = newList;\n      }\n\n      if (_h[event] && _h[event].length === 0) {\n        delete _h[event];\n      }\n    } else {\n      delete _h[event];\n    }\n\n    return this;\n  },\n\n  /**\n   * 事件分发\n   *\n   * @param {string} type 事件类型\n   */\n  trigger: function (type) {\n    if (this._$handlers[type]) {\n      var args = arguments;\n      var argLen = args.length;\n\n      if (argLen > 3) {\n        args = arrySlice.call(args, 1);\n      }\n\n      var _h = this._$handlers[type];\n      var len = _h.length;\n\n      for (var i = 0; i < len;) {\n        // Optimize advise from backbone\n        switch (argLen) {\n          case 1:\n            _h[i]['h'].call(_h[i]['ctx']);\n\n            break;\n\n          case 2:\n            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\n            break;\n\n          case 3:\n            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\n            break;\n\n          default:\n            // have more than 2 given arguments\n            _h[i]['h'].apply(_h[i]['ctx'], args);\n\n            break;\n        }\n\n        if (_h[i]['one']) {\n          _h.splice(i, 1);\n\n          len--;\n        } else {\n          i++;\n        }\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * 带有context的事件分发, 最后一个参数是事件回调的context\n   * @param {string} type 事件类型\n   */\n  triggerWithContext: function (type) {\n    if (this._$handlers[type]) {\n      var args = arguments;\n      var argLen = args.length;\n\n      if (argLen > 4) {\n        args = arrySlice.call(args, 1, args.length - 1);\n      }\n\n      var ctx = args[args.length - 1];\n      var _h = this._$handlers[type];\n      var len = _h.length;\n\n      for (var i = 0; i < len;) {\n        // Optimize advise from backbone\n        switch (argLen) {\n          case 1:\n            _h[i]['h'].call(ctx);\n\n            break;\n\n          case 2:\n            _h[i]['h'].call(ctx, args[1]);\n\n            break;\n\n          case 3:\n            _h[i]['h'].call(ctx, args[1], args[2]);\n\n            break;\n\n          default:\n            // have more than 2 given arguments\n            _h[i]['h'].apply(ctx, args);\n\n            break;\n        }\n\n        if (_h[i]['one']) {\n          _h.splice(i, 1);\n\n          len--;\n        } else {\n          i++;\n        }\n      }\n    }\n\n    return this;\n  }\n}; // 对象可以通过 onxxxx 绑定事件\n\n/**\n * @event module:zrender/mixin/Eventful#onclick\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseover\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseout\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousemove\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousewheel\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousedown\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseup\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondrag\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragstart\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragend\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragenter\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragleave\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragover\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondrop\n * @type {Function}\n * @default null\n */\n\nvar _default = Eventful;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Eventful.js\n// module id = 10\n// module chunks = 0","var util = require(\"./core/util\");\n\nvar env = require(\"./core/env\");\n\nvar Group = require(\"./container/Group\");\n\nvar timsort = require(\"./core/timsort\");\n\n/**\n * Storage内容仓库模块\n * @module zrender/Storage\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n// Use timsort because in most case elements are partially sorted\n// https://jsfiddle.net/pissang/jr4x7mdm/8/\nfunction shapeCompareFunc(a, b) {\n  if (a.zlevel === b.zlevel) {\n    if (a.z === b.z) {\n      // if (a.z2 === b.z2) {\n      //     // FIXME Slow has renderidx compare\n      //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n      //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n      //     return a.__renderidx - b.__renderidx;\n      // }\n      return a.z2 - b.z2;\n    }\n\n    return a.z - b.z;\n  }\n\n  return a.zlevel - b.zlevel;\n}\n/**\n * 内容仓库 (M)\n * @alias module:zrender/Storage\n * @constructor\n */\n\n\nvar Storage = function () {\n  // jshint ignore:line\n  this._roots = [];\n  this._displayList = [];\n  this._displayListLen = 0;\n};\n\nStorage.prototype = {\n  constructor: Storage,\n\n  /**\n   * @param  {Function} cb\n   *\n   */\n  traverse: function (cb, context) {\n    for (var i = 0; i < this._roots.length; i++) {\n      this._roots[i].traverse(cb, context);\n    }\n  },\n\n  /**\n   * 返回所有图形的绘制队列\n   * @param {boolean} [update=false] 是否在返回前更新该数组\n   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\n   *\n   * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n   * @return {Array.<module:zrender/graphic/Displayable>}\n   */\n  getDisplayList: function (update, includeIgnore) {\n    includeIgnore = includeIgnore || false;\n\n    if (update) {\n      this.updateDisplayList(includeIgnore);\n    }\n\n    return this._displayList;\n  },\n\n  /**\n   * 更新图形的绘制队列。\n   * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\n   * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\n   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\n   */\n  updateDisplayList: function (includeIgnore) {\n    this._displayListLen = 0;\n    var roots = this._roots;\n    var displayList = this._displayList;\n\n    for (var i = 0, len = roots.length; i < len; i++) {\n      this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n    }\n\n    displayList.length = this._displayListLen; // for (var i = 0, len = displayList.length; i < len; i++) {\n    //     displayList[i].__renderidx = i;\n    // }\n    // displayList.sort(shapeCompareFunc);\n\n    env.canvasSupported && timsort(displayList, shapeCompareFunc);\n  },\n  _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n    if (el.ignore && !includeIgnore) {\n      return;\n    }\n\n    el.beforeUpdate();\n\n    if (el.__dirty) {\n      el.update();\n    }\n\n    el.afterUpdate();\n    var userSetClipPath = el.clipPath;\n\n    if (userSetClipPath) {\n      // FIXME 效率影响\n      if (clipPaths) {\n        clipPaths = clipPaths.slice();\n      } else {\n        clipPaths = [];\n      }\n\n      var currentClipPath = userSetClipPath;\n      var parentClipPath = el; // Recursively add clip path\n\n      while (currentClipPath) {\n        // clipPath 的变换是基于使用这个 clipPath 的元素\n        currentClipPath.parent = parentClipPath;\n        currentClipPath.updateTransform();\n        clipPaths.push(currentClipPath);\n        parentClipPath = currentClipPath;\n        currentClipPath = currentClipPath.clipPath;\n      }\n    }\n\n    if (el.isGroup) {\n      var children = el._children;\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i]; // Force to mark as dirty if group is dirty\n        // FIXME __dirtyPath ?\n\n        if (el.__dirty) {\n          child.__dirty = true;\n        }\n\n        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n      } // Mark group clean here\n\n\n      el.__dirty = false;\n    } else {\n      el.__clipPaths = clipPaths;\n      this._displayList[this._displayListLen++] = el;\n    }\n  },\n\n  /**\n   * 添加图形(Shape)或者组(Group)到根节点\n   * @param {module:zrender/Element} el\n   */\n  addRoot: function (el) {\n    if (el.__storage === this) {\n      return;\n    }\n\n    if (el instanceof Group) {\n      el.addChildrenToStorage(this);\n    }\n\n    this.addToStorage(el);\n\n    this._roots.push(el);\n  },\n\n  /**\n   * 删除指定的图形(Shape)或者组(Group)\n   * @param {string|Array.<string>} [el] 如果为空清空整个Storage\n   */\n  delRoot: function (el) {\n    if (el == null) {\n      // 不指定el清空\n      for (var i = 0; i < this._roots.length; i++) {\n        var root = this._roots[i];\n\n        if (root instanceof Group) {\n          root.delChildrenFromStorage(this);\n        }\n      }\n\n      this._roots = [];\n      this._displayList = [];\n      this._displayListLen = 0;\n      return;\n    }\n\n    if (el instanceof Array) {\n      for (var i = 0, l = el.length; i < l; i++) {\n        this.delRoot(el[i]);\n      }\n\n      return;\n    }\n\n    var idx = util.indexOf(this._roots, el);\n\n    if (idx >= 0) {\n      this.delFromStorage(el);\n\n      this._roots.splice(idx, 1);\n\n      if (el instanceof Group) {\n        el.delChildrenFromStorage(this);\n      }\n    }\n  },\n  addToStorage: function (el) {\n    el.__storage = this;\n    el.dirty(false);\n    return this;\n  },\n  delFromStorage: function (el) {\n    if (el) {\n      el.__storage = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * 清空并且释放Storage\n   */\n  dispose: function () {\n    this._renderList = this._roots = null;\n  },\n  displayableSortFunc: shapeCompareFunc\n};\nvar _default = Storage;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Storage.js\n// module id = 11\n// module chunks = 0","var zrUtil = require(\"../core/util\");\n\nvar Element = require(\"../Element\");\n\nvar BoundingRect = require(\"../core/BoundingRect\");\n\n/**\n * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/container/Group');\n *     var Circle = require('zrender/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n/**\n * @alias module:zrender/graphic/Group\n * @constructor\n * @extends module:zrender/mixin/Transformable\n * @extends module:zrender/mixin/Eventful\n */\nvar Group = function (opts) {\n  opts = opts || {};\n  Element.call(this, opts);\n\n  for (var key in opts) {\n    if (opts.hasOwnProperty(key)) {\n      this[key] = opts[key];\n    }\n  }\n\n  this._children = [];\n  this.__storage = null;\n  this.__dirty = true;\n};\n\nGroup.prototype = {\n  constructor: Group,\n  isGroup: true,\n\n  /**\n   * @type {string}\n   */\n  type: 'group',\n\n  /**\n   * 所有子孙元素是否响应鼠标事件\n   * @name module:/zrender/container/Group#silent\n   * @type {boolean}\n   * @default false\n   */\n  silent: false,\n\n  /**\n   * @return {Array.<module:zrender/Element>}\n   */\n  children: function () {\n    return this._children.slice();\n  },\n\n  /**\n   * 获取指定 index 的儿子节点\n   * @param  {number} idx\n   * @return {module:zrender/Element}\n   */\n  childAt: function (idx) {\n    return this._children[idx];\n  },\n\n  /**\n   * 获取指定名字的儿子节点\n   * @param  {string} name\n   * @return {module:zrender/Element}\n   */\n  childOfName: function (name) {\n    var children = this._children;\n\n    for (var i = 0; i < children.length; i++) {\n      if (children[i].name === name) {\n        return children[i];\n      }\n    }\n  },\n\n  /**\n   * @return {number}\n   */\n  childCount: function () {\n    return this._children.length;\n  },\n\n  /**\n   * 添加子节点到最后\n   * @param {module:zrender/Element} child\n   */\n  add: function (child) {\n    if (child && child !== this && child.parent !== this) {\n      this._children.push(child);\n\n      this._doAdd(child);\n    }\n\n    return this;\n  },\n\n  /**\n   * 添加子节点在 nextSibling 之前\n   * @param {module:zrender/Element} child\n   * @param {module:zrender/Element} nextSibling\n   */\n  addBefore: function (child, nextSibling) {\n    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {\n      var children = this._children;\n      var idx = children.indexOf(nextSibling);\n\n      if (idx >= 0) {\n        children.splice(idx, 0, child);\n\n        this._doAdd(child);\n      }\n    }\n\n    return this;\n  },\n  _doAdd: function (child) {\n    if (child.parent) {\n      child.parent.remove(child);\n    }\n\n    child.parent = this;\n    var storage = this.__storage;\n    var zr = this.__zr;\n\n    if (storage && storage !== child.__storage) {\n      storage.addToStorage(child);\n\n      if (child instanceof Group) {\n        child.addChildrenToStorage(storage);\n      }\n    }\n\n    zr && zr.refresh();\n  },\n\n  /**\n   * 移除子节点\n   * @param {module:zrender/Element} child\n   */\n  remove: function (child) {\n    var zr = this.__zr;\n    var storage = this.__storage;\n    var children = this._children;\n    var idx = zrUtil.indexOf(children, child);\n\n    if (idx < 0) {\n      return this;\n    }\n\n    children.splice(idx, 1);\n    child.parent = null;\n\n    if (storage) {\n      storage.delFromStorage(child);\n\n      if (child instanceof Group) {\n        child.delChildrenFromStorage(storage);\n      }\n    }\n\n    zr && zr.refresh();\n    return this;\n  },\n\n  /**\n   * 移除所有子节点\n   */\n  removeAll: function () {\n    var children = this._children;\n    var storage = this.__storage;\n    var child;\n    var i;\n\n    for (i = 0; i < children.length; i++) {\n      child = children[i];\n\n      if (storage) {\n        storage.delFromStorage(child);\n\n        if (child instanceof Group) {\n          child.delChildrenFromStorage(storage);\n        }\n      }\n\n      child.parent = null;\n    }\n\n    children.length = 0;\n    return this;\n  },\n\n  /**\n   * 遍历所有子节点\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  eachChild: function (cb, context) {\n    var children = this._children;\n\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n      cb.call(context, child, i);\n    }\n\n    return this;\n  },\n\n  /**\n   * 深度优先遍历所有子孙节点\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      cb.call(context, child);\n\n      if (child.type === 'group') {\n        child.traverse(cb, context);\n      }\n    }\n\n    return this;\n  },\n  addChildrenToStorage: function (storage) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      storage.addToStorage(child);\n\n      if (child instanceof Group) {\n        child.addChildrenToStorage(storage);\n      }\n    }\n  },\n  delChildrenFromStorage: function (storage) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      storage.delFromStorage(child);\n\n      if (child instanceof Group) {\n        child.delChildrenFromStorage(storage);\n      }\n    }\n  },\n  dirty: function () {\n    this.__dirty = true;\n    this.__zr && this.__zr.refresh();\n    return this;\n  },\n\n  /**\n   * @return {module:zrender/core/BoundingRect}\n   */\n  getBoundingRect: function (includeChildren) {\n    // TODO Caching\n    var rect = null;\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var children = includeChildren || this._children;\n    var tmpMat = [];\n\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n\n      if (child.ignore || child.invisible) {\n        continue;\n      }\n\n      var childRect = child.getBoundingRect();\n      var transform = child.getLocalTransform(tmpMat); // TODO\n      // The boundingRect cacluated by transforming original\n      // rect may be bigger than the actual bundingRect when rotation\n      // is used. (Consider a circle rotated aginst its center, where\n      // the actual boundingRect should be the same as that not be\n      // rotated.) But we can not find better approach to calculate\n      // actual boundingRect yet, considering performance.\n\n      if (transform) {\n        tmpRect.copy(childRect);\n        tmpRect.applyTransform(transform);\n        rect = rect || tmpRect.clone();\n        rect.union(tmpRect);\n      } else {\n        rect = rect || childRect.clone();\n        rect.union(childRect);\n      }\n    }\n\n    return rect || tmpRect;\n  }\n};\nzrUtil.inherits(Group, Element);\nvar _default = Group;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/container/Group.js\n// module id = 12\n// module chunks = 0","var guid = require(\"./core/guid\");\n\nvar Eventful = require(\"./mixin/Eventful\");\n\nvar Transformable = require(\"./mixin/Transformable\");\n\nvar Animatable = require(\"./mixin/Animatable\");\n\nvar zrUtil = require(\"./core/util\");\n\n/**\n * @alias module:zrender/Element\n * @constructor\n * @extends {module:zrender/mixin/Animatable}\n * @extends {module:zrender/mixin/Transformable}\n * @extends {module:zrender/mixin/Eventful}\n */\nvar Element = function (opts) {\n  // jshint ignore:line\n  Transformable.call(this, opts);\n  Eventful.call(this, opts);\n  Animatable.call(this, opts);\n  /**\n   * 画布元素ID\n   * @type {string}\n   */\n\n  this.id = opts.id || guid();\n};\n\nElement.prototype = {\n  /**\n   * 元素类型\n   * Element type\n   * @type {string}\n   */\n  type: 'element',\n\n  /**\n   * 元素名字\n   * Element name\n   * @type {string}\n   */\n  name: '',\n\n  /**\n   * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n   * ZRender instance will be assigned when element is associated with zrender\n   * @name module:/zrender/Element#__zr\n   * @type {module:zrender/ZRender}\n   */\n  __zr: null,\n\n  /**\n   * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n   * If ignore drawing and events of the element object\n   * @name module:/zrender/Element#ignore\n   * @type {boolean}\n   * @default false\n   */\n  ignore: false,\n\n  /**\n   * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n   * 该路径会继承被裁减对象的变换\n   * @type {module:zrender/graphic/Path}\n   * @see http://www.w3.org/TR/2dcontext/#clipping-region\n   * @readOnly\n   */\n  clipPath: null,\n\n  /**\n   * Drift element\n   * @param  {number} dx dx on the global space\n   * @param  {number} dy dy on the global space\n   */\n  drift: function (dx, dy) {\n    switch (this.draggable) {\n      case 'horizontal':\n        dy = 0;\n        break;\n\n      case 'vertical':\n        dx = 0;\n        break;\n    }\n\n    var m = this.transform;\n\n    if (!m) {\n      m = this.transform = [1, 0, 0, 1, 0, 0];\n    }\n\n    m[4] += dx;\n    m[5] += dy;\n    this.decomposeTransform();\n    this.dirty(false);\n  },\n\n  /**\n   * Hook before update\n   */\n  beforeUpdate: function () {},\n\n  /**\n   * Hook after update\n   */\n  afterUpdate: function () {},\n\n  /**\n   * Update each frame\n   */\n  update: function () {\n    this.updateTransform();\n  },\n\n  /**\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {},\n\n  /**\n   * @protected\n   */\n  attrKV: function (key, value) {\n    if (key === 'position' || key === 'scale' || key === 'origin') {\n      // Copy the array\n      if (value) {\n        var target = this[key];\n\n        if (!target) {\n          target = this[key] = [];\n        }\n\n        target[0] = value[0];\n        target[1] = value[1];\n      }\n    } else {\n      this[key] = value;\n    }\n  },\n\n  /**\n   * Hide the element\n   */\n  hide: function () {\n    this.ignore = true;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * Show the element\n   */\n  show: function () {\n    this.ignore = false;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * @param {string|Object} key\n   * @param {*} value\n   */\n  attr: function (key, value) {\n    if (typeof key === 'string') {\n      this.attrKV(key, value);\n    } else if (zrUtil.isObject(key)) {\n      for (var name in key) {\n        if (key.hasOwnProperty(name)) {\n          this.attrKV(name, key[name]);\n        }\n      }\n    }\n\n    this.dirty(false);\n    return this;\n  },\n\n  /**\n   * @param {module:zrender/graphic/Path} clipPath\n   */\n  setClipPath: function (clipPath) {\n    var zr = this.__zr;\n\n    if (zr) {\n      clipPath.addSelfToZr(zr);\n    } // Remove previous clip path\n\n\n    if (this.clipPath && this.clipPath !== clipPath) {\n      this.removeClipPath();\n    }\n\n    this.clipPath = clipPath;\n    clipPath.__zr = zr;\n    clipPath.__clipTarget = this;\n    this.dirty(false);\n  },\n\n  /**\n   */\n  removeClipPath: function () {\n    var clipPath = this.clipPath;\n\n    if (clipPath) {\n      if (clipPath.__zr) {\n        clipPath.removeSelfFromZr(clipPath.__zr);\n      }\n\n      clipPath.__zr = null;\n      clipPath.__clipTarget = null;\n      this.clipPath = null;\n      this.dirty(false);\n    }\n  },\n\n  /**\n   * Add self from zrender instance.\n   * Not recursively because it will be invoked when element added to storage.\n   * @param {module:zrender/ZRender} zr\n   */\n  addSelfToZr: function (zr) {\n    this.__zr = zr; // 添加动画\n\n    var animators = this.animators;\n\n    if (animators) {\n      for (var i = 0; i < animators.length; i++) {\n        zr.animation.addAnimator(animators[i]);\n      }\n    }\n\n    if (this.clipPath) {\n      this.clipPath.addSelfToZr(zr);\n    }\n  },\n\n  /**\n   * Remove self from zrender instance.\n   * Not recursively because it will be invoked when element added to storage.\n   * @param {module:zrender/ZRender} zr\n   */\n  removeSelfFromZr: function (zr) {\n    this.__zr = null; // 移除动画\n\n    var animators = this.animators;\n\n    if (animators) {\n      for (var i = 0; i < animators.length; i++) {\n        zr.animation.removeAnimator(animators[i]);\n      }\n    }\n\n    if (this.clipPath) {\n      this.clipPath.removeSelfFromZr(zr);\n    }\n  }\n};\nzrUtil.mixin(Element, Animatable);\nzrUtil.mixin(Element, Transformable);\nzrUtil.mixin(Element, Eventful);\nvar _default = Element;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Element.js\n// module id = 13\n// module chunks = 0","var matrix = require(\"../core/matrix\");\n\nvar vector = require(\"../core/vector\");\n\n/**\n * 提供变换扩展\n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\nvar mIdentity = matrix.identity;\nvar EPSILON = 5e-5;\n\nfunction isNotAroundZero(val) {\n  return val > EPSILON || val < -EPSILON;\n}\n/**\n * @alias module:zrender/mixin/Transformable\n * @constructor\n */\n\n\nvar Transformable = function (opts) {\n  opts = opts || {}; // If there are no given position, rotation, scale\n\n  if (!opts.position) {\n    /**\n     * 平移\n     * @type {Array.<number>}\n     * @default [0, 0]\n     */\n    this.position = [0, 0];\n  }\n\n  if (opts.rotation == null) {\n    /**\n     * 旋转\n     * @type {Array.<number>}\n     * @default 0\n     */\n    this.rotation = 0;\n  }\n\n  if (!opts.scale) {\n    /**\n     * 缩放\n     * @type {Array.<number>}\n     * @default [1, 1]\n     */\n    this.scale = [1, 1];\n  }\n  /**\n   * 旋转和缩放的原点\n   * @type {Array.<number>}\n   * @default null\n   */\n\n\n  this.origin = this.origin || null;\n};\n\nvar transformableProto = Transformable.prototype;\ntransformableProto.transform = null;\n/**\n * 判断是否需要有坐标变换\n * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n */\n\ntransformableProto.needLocalTransform = function () {\n  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n};\n\ntransformableProto.updateTransform = function () {\n  var parent = this.parent;\n  var parentHasTransform = parent && parent.transform;\n  var needLocalTransform = this.needLocalTransform();\n  var m = this.transform;\n\n  if (!(needLocalTransform || parentHasTransform)) {\n    m && mIdentity(m);\n    return;\n  }\n\n  m = m || matrix.create();\n\n  if (needLocalTransform) {\n    this.getLocalTransform(m);\n  } else {\n    mIdentity(m);\n  } // 应用父节点变换\n\n\n  if (parentHasTransform) {\n    if (needLocalTransform) {\n      matrix.mul(m, parent.transform, m);\n    } else {\n      matrix.copy(m, parent.transform);\n    }\n  } // 保存这个变换矩阵\n\n\n  this.transform = m;\n  this.invTransform = this.invTransform || matrix.create();\n  matrix.invert(this.invTransform, m);\n};\n\ntransformableProto.getLocalTransform = function (m) {\n  return Transformable.getLocalTransform(this, m);\n};\n/**\n * 将自己的transform应用到context上\n * @param {CanvasRenderingContext2D} ctx\n */\n\n\ntransformableProto.setTransform = function (ctx) {\n  var m = this.transform;\n  var dpr = ctx.dpr || 1;\n\n  if (m) {\n    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n  } else {\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n  }\n};\n\ntransformableProto.restoreTransform = function (ctx) {\n  var dpr = ctx.dpr || 1;\n  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n};\n\nvar tmpTransform = [];\n/**\n * 分解`transform`矩阵到`position`, `rotation`, `scale`\n */\n\ntransformableProto.decomposeTransform = function () {\n  if (!this.transform) {\n    return;\n  }\n\n  var parent = this.parent;\n  var m = this.transform;\n\n  if (parent && parent.transform) {\n    // Get local transform and decompose them to position, scale, rotation\n    matrix.mul(tmpTransform, parent.invTransform, m);\n    m = tmpTransform;\n  }\n\n  var sx = m[0] * m[0] + m[1] * m[1];\n  var sy = m[2] * m[2] + m[3] * m[3];\n  var position = this.position;\n  var scale = this.scale;\n\n  if (isNotAroundZero(sx - 1)) {\n    sx = Math.sqrt(sx);\n  }\n\n  if (isNotAroundZero(sy - 1)) {\n    sy = Math.sqrt(sy);\n  }\n\n  if (m[0] < 0) {\n    sx = -sx;\n  }\n\n  if (m[3] < 0) {\n    sy = -sy;\n  }\n\n  position[0] = m[4];\n  position[1] = m[5];\n  scale[0] = sx;\n  scale[1] = sy;\n  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n};\n/**\n * Get global scale\n * @return {Array.<number>}\n */\n\n\ntransformableProto.getGlobalScale = function () {\n  var m = this.transform;\n\n  if (!m) {\n    return [1, 1];\n  }\n\n  var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n  var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\n  if (m[0] < 0) {\n    sx = -sx;\n  }\n\n  if (m[3] < 0) {\n    sy = -sy;\n  }\n\n  return [sx, sy];\n};\n/**\n * 变换坐标位置到 shape 的局部坐标空间\n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToLocal = function (x, y) {\n  var v2 = [x, y];\n  var invTransform = this.invTransform;\n\n  if (invTransform) {\n    vector.applyTransform(v2, v2, invTransform);\n  }\n\n  return v2;\n};\n/**\n * 变换局部坐标位置到全局坐标空间\n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToGlobal = function (x, y) {\n  var v2 = [x, y];\n  var transform = this.transform;\n\n  if (transform) {\n    vector.applyTransform(v2, v2, transform);\n  }\n\n  return v2;\n};\n/**\n * @static\n * @param {Object} target\n * @param {Array.<number>} target.origin\n * @param {number} target.rotation\n * @param {Array.<number>} target.position\n * @param {Array.<number>} [m]\n */\n\n\nTransformable.getLocalTransform = function (target, m) {\n  m = m || [];\n  mIdentity(m);\n  var origin = target.origin;\n  var scale = target.scale || [1, 1];\n  var rotation = target.rotation || 0;\n  var position = target.position || [0, 0];\n\n  if (origin) {\n    // Translate to origin\n    m[4] -= origin[0];\n    m[5] -= origin[1];\n  }\n\n  matrix.scale(m, m, scale);\n\n  if (rotation) {\n    matrix.rotate(m, m, rotation);\n  }\n\n  if (origin) {\n    // Translate back from origin\n    m[4] += origin[0];\n    m[5] += origin[1];\n  }\n\n  m[4] += position[0];\n  m[5] += position[1];\n  return m;\n};\n\nvar _default = Transformable;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Transformable.js\n// module id = 14\n// module chunks = 0","/**\n * 3x2矩阵操作类\n * @exports zrender/tool/matrix\n */\nvar ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n/**\n * 创建一个单位矩阵\n * @return {Float32Array|Array.<number>}\n */\n\nfunction create() {\n  var out = new ArrayCtor(6);\n  identity(out);\n  return out;\n}\n/**\n * 设置矩阵为单位矩阵\n * @param {Float32Array|Array.<number>} out\n */\n\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\n * 复制矩阵\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} m\n */\n\n\nfunction copy(out, m) {\n  out[0] = m[0];\n  out[1] = m[1];\n  out[2] = m[2];\n  out[3] = m[3];\n  out[4] = m[4];\n  out[5] = m[5];\n  return out;\n}\n/**\n * 矩阵相乘\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} m1\n * @param {Float32Array|Array.<number>} m2\n */\n\n\nfunction mul(out, m1, m2) {\n  // Consider matrix.mul(m, m2, m);\n  // where out is the same as m2.\n  // So use temp variable to escape error.\n  var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n  var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n  var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n  var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = out3;\n  out[4] = out4;\n  out[5] = out5;\n  return out;\n}\n/**\n * 平移变换\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {Float32Array|Array.<number>} v\n */\n\n\nfunction translate(out, a, v) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4] + v[0];\n  out[5] = a[5] + v[1];\n  return out;\n}\n/**\n * 旋转变换\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {number} rad\n */\n\n\nfunction rotate(out, a, rad) {\n  var aa = a[0];\n  var ac = a[2];\n  var atx = a[4];\n  var ab = a[1];\n  var ad = a[3];\n  var aty = a[5];\n  var st = Math.sin(rad);\n  var ct = Math.cos(rad);\n  out[0] = aa * ct + ab * st;\n  out[1] = -aa * st + ab * ct;\n  out[2] = ac * ct + ad * st;\n  out[3] = -ac * st + ct * ad;\n  out[4] = ct * atx + st * aty;\n  out[5] = ct * aty - st * atx;\n  return out;\n}\n/**\n * 缩放变换\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {Float32Array|Array.<number>} v\n */\n\n\nfunction scale(out, a, v) {\n  var vx = v[0];\n  var vy = v[1];\n  out[0] = a[0] * vx;\n  out[1] = a[1] * vy;\n  out[2] = a[2] * vx;\n  out[3] = a[3] * vy;\n  out[4] = a[4] * vx;\n  out[5] = a[5] * vy;\n  return out;\n}\n/**\n * 求逆矩阵\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n */\n\n\nfunction invert(out, a) {\n  var aa = a[0];\n  var ac = a[2];\n  var atx = a[4];\n  var ab = a[1];\n  var ad = a[3];\n  var aty = a[5];\n  var det = aa * ad - ab * ac;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = ad * det;\n  out[1] = -ab * det;\n  out[2] = -ac * det;\n  out[3] = aa * det;\n  out[4] = (ac * aty - ad * atx) * det;\n  out[5] = (ab * atx - aa * aty) * det;\n  return out;\n}\n\nexports.create = create;\nexports.identity = identity;\nexports.copy = copy;\nexports.mul = mul;\nexports.translate = translate;\nexports.rotate = rotate;\nexports.scale = scale;\nexports.invert = invert;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/matrix.js\n// module id = 15\n// module chunks = 0","var Animator = require(\"../animation/Animator\");\n\nvar log = require(\"../core/log\");\n\nvar _util = require(\"../core/util\");\n\nvar isString = _util.isString;\nvar isFunction = _util.isFunction;\nvar isObject = _util.isObject;\nvar isArrayLike = _util.isArrayLike;\nvar indexOf = _util.indexOf;\n\n/**\n * @alias modue:zrender/mixin/Animatable\n * @constructor\n */\nvar Animatable = function () {\n  /**\n   * @type {Array.<module:zrender/animation/Animator>}\n   * @readOnly\n   */\n  this.animators = [];\n};\n\nAnimatable.prototype = {\n  constructor: Animatable,\n\n  /**\n   * 动画\n   *\n   * @param {string} path The path to fetch value from object, like 'a.b.c'.\n   * @param {boolean} [loop] Whether to loop animation.\n   * @return {module:zrender/animation/Animator}\n   * @example:\n   *     el.animate('style', false)\n   *         .when(1000, {x: 10} )\n   *         .done(function(){ // Animation done })\n   *         .start()\n   */\n  animate: function (path, loop) {\n    var target;\n    var animatingShape = false;\n    var el = this;\n    var zr = this.__zr;\n\n    if (path) {\n      var pathSplitted = path.split('.');\n      var prop = el; // If animating shape\n\n      animatingShape = pathSplitted[0] === 'shape';\n\n      for (var i = 0, l = pathSplitted.length; i < l; i++) {\n        if (!prop) {\n          continue;\n        }\n\n        prop = prop[pathSplitted[i]];\n      }\n\n      if (prop) {\n        target = prop;\n      }\n    } else {\n      target = el;\n    }\n\n    if (!target) {\n      log('Property \"' + path + '\" is not existed in element ' + el.id);\n      return;\n    }\n\n    var animators = el.animators;\n    var animator = new Animator(target, loop);\n    animator.during(function (target) {\n      el.dirty(animatingShape);\n    }).done(function () {\n      // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n      animators.splice(indexOf(animators, animator), 1);\n    });\n    animators.push(animator); // If animate after added to the zrender\n\n    if (zr) {\n      zr.animation.addAnimator(animator);\n    }\n\n    return animator;\n  },\n\n  /**\n   * 停止动画\n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stopAnimation: function (forwardToLast) {\n    var animators = this.animators;\n    var len = animators.length;\n\n    for (var i = 0; i < len; i++) {\n      animators[i].stop(forwardToLast);\n    }\n\n    animators.length = 0;\n    return this;\n  },\n\n  /**\n   * Caution: this method will stop previous animation.\n   * So do not use this method to one element twice before\n   * animation starts, unless you know what you are doing.\n   * @param {Object} target\n   * @param {number} [time=500] Time in ms\n   * @param {string} [easing='linear']\n   * @param {number} [delay=0]\n   * @param {Function} [callback]\n   * @param {Function} [forceAnimate] Prevent stop animation and callback\n   *        immediently when target values are the same as current values.\n   *\n   * @example\n   *  // Animate position\n   *  el.animateTo({\n   *      position: [10, 10]\n   *  }, function () { // done })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n   *  el.animateTo({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100, 'cubicOut', function () { // done })\n   */\n  // TODO Return animation key\n  animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n    // animateTo(target, time, easing, callback);\n    if (isString(delay)) {\n      callback = easing;\n      easing = delay;\n      delay = 0;\n    } // animateTo(target, time, delay, callback);\n    else if (isFunction(easing)) {\n        callback = easing;\n        easing = 'linear';\n        delay = 0;\n      } // animateTo(target, time, callback);\n      else if (isFunction(delay)) {\n          callback = delay;\n          delay = 0;\n        } // animateTo(target, callback)\n        else if (isFunction(time)) {\n            callback = time;\n            time = 500;\n          } // animateTo(target)\n          else if (!time) {\n              time = 500;\n            } // Stop all previous animations\n\n\n    this.stopAnimation();\n\n    this._animateToShallow('', this, target, time, delay); // Animators may be removed immediately after start\n    // if there is nothing to animate\n\n\n    var animators = this.animators.slice();\n    var count = animators.length;\n\n    function done() {\n      count--;\n\n      if (!count) {\n        callback && callback();\n      }\n    } // No animators. This should be checked before animators[i].start(),\n    // because 'done' may be executed immediately if no need to animate.\n\n\n    if (!count) {\n      callback && callback();\n    } // Start after all animators created\n    // Incase any animator is done immediately when all animation properties are not changed\n\n\n    for (var i = 0; i < animators.length; i++) {\n      animators[i].done(done).start(easing, forceAnimate);\n    }\n  },\n\n  /**\n   * @private\n   * @param {string} path=''\n   * @param {Object} source=this\n   * @param {Object} target\n   * @param {number} [time=500]\n   * @param {number} [delay=0]\n   *\n   * @example\n   *  // Animate position\n   *  el._animateToShallow({\n   *      position: [10, 10]\n   *  })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms\n   *  el._animateToShallow({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100)\n   */\n  _animateToShallow: function (path, source, target, time, delay) {\n    var objShallow = {};\n    var propertyCount = 0;\n\n    for (var name in target) {\n      if (!target.hasOwnProperty(name)) {\n        continue;\n      }\n\n      if (source[name] != null) {\n        if (isObject(target[name]) && !isArrayLike(target[name])) {\n          this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);\n        } else {\n          objShallow[name] = target[name];\n          propertyCount++;\n        }\n      } else if (target[name] != null) {\n        // Attr directly if not has property\n        // FIXME, if some property not needed for element ?\n        if (!path) {\n          this.attr(name, target[name]);\n        } else {\n          // Shape or style\n          var props = {};\n          props[path] = {};\n          props[path][name] = target[name];\n          this.attr(props);\n        }\n      }\n    }\n\n    if (propertyCount > 0) {\n      this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n    }\n\n    return this;\n  }\n};\nvar _default = Animatable;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Animatable.js\n// module id = 16\n// module chunks = 0","var Clip = require(\"./Clip\");\n\nvar color = require(\"../tool/color\");\n\nvar _util = require(\"../core/util\");\n\nvar isArrayLike = _util.isArrayLike;\n\n/**\n * @module echarts/animation/Animator\n */\nvar arraySlice = Array.prototype.slice;\n\nfunction defaultGetter(target, key) {\n  return target[key];\n}\n\nfunction defaultSetter(target, key, value) {\n  target[key] = value;\n}\n/**\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} percent\n * @return {number}\n */\n\n\nfunction interpolateNumber(p0, p1, percent) {\n  return (p1 - p0) * percent + p0;\n}\n/**\n * @param  {string} p0\n * @param  {string} p1\n * @param  {number} percent\n * @return {string}\n */\n\n\nfunction interpolateString(p0, p1, percent) {\n  return percent > 0.5 ? p1 : p0;\n}\n/**\n * @param  {Array} p0\n * @param  {Array} p1\n * @param  {number} percent\n * @param  {Array} out\n * @param  {number} arrDim\n */\n\n\nfunction interpolateArray(p0, p1, percent, out, arrDim) {\n  var len = p0.length;\n\n  if (arrDim == 1) {\n    for (var i = 0; i < len; i++) {\n      out[i] = interpolateNumber(p0[i], p1[i], percent);\n    }\n  } else {\n    var len2 = len && p0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n      }\n    }\n  }\n} // arr0 is source array, arr1 is target array.\n// Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\n\nfunction fillArr(arr0, arr1, arrDim) {\n  var arr0Len = arr0.length;\n  var arr1Len = arr1.length;\n\n  if (arr0Len !== arr1Len) {\n    // FIXME Not work for TypedArray\n    var isPreviousLarger = arr0Len > arr1Len;\n\n    if (isPreviousLarger) {\n      // Cut the previous\n      arr0.length = arr1Len;\n    } else {\n      // Fill the previous\n      for (var i = arr0Len; i < arr1Len; i++) {\n        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n      }\n    }\n  } // Handling NaN value\n\n\n  var len2 = arr0[0] && arr0[0].length;\n\n  for (var i = 0; i < arr0.length; i++) {\n    if (arrDim === 1) {\n      if (isNaN(arr0[i])) {\n        arr0[i] = arr1[i];\n      }\n    } else {\n      for (var j = 0; j < len2; j++) {\n        if (isNaN(arr0[i][j])) {\n          arr0[i][j] = arr1[i][j];\n        }\n      }\n    }\n  }\n}\n/**\n * @param  {Array} arr0\n * @param  {Array} arr1\n * @param  {number} arrDim\n * @return {boolean}\n */\n\n\nfunction isArraySame(arr0, arr1, arrDim) {\n  if (arr0 === arr1) {\n    return true;\n  }\n\n  var len = arr0.length;\n\n  if (len !== arr1.length) {\n    return false;\n  }\n\n  if (arrDim === 1) {\n    for (var i = 0; i < len; i++) {\n      if (arr0[i] !== arr1[i]) {\n        return false;\n      }\n    }\n  } else {\n    var len2 = arr0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        if (arr0[i][j] !== arr1[i][j]) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Catmull Rom interpolate array\n * @param  {Array} p0\n * @param  {Array} p1\n * @param  {Array} p2\n * @param  {Array} p3\n * @param  {number} t\n * @param  {number} t2\n * @param  {number} t3\n * @param  {Array} out\n * @param  {number} arrDim\n */\n\n\nfunction catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {\n  var len = p0.length;\n\n  if (arrDim == 1) {\n    for (var i = 0; i < len; i++) {\n      out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);\n    }\n  } else {\n    var len2 = p0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);\n      }\n    }\n  }\n}\n/**\n * Catmull Rom interpolate number\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @param  {number} t2\n * @param  {number} t3\n * @return {number}\n */\n\n\nfunction catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n  var v0 = (p2 - p0) * 0.5;\n  var v1 = (p3 - p1) * 0.5;\n  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n}\n\nfunction cloneValue(value) {\n  if (isArrayLike(value)) {\n    var len = value.length;\n\n    if (isArrayLike(value[0])) {\n      var ret = [];\n\n      for (var i = 0; i < len; i++) {\n        ret.push(arraySlice.call(value[i]));\n      }\n\n      return ret;\n    }\n\n    return arraySlice.call(value);\n  }\n\n  return value;\n}\n\nfunction rgba2String(rgba) {\n  rgba[0] = Math.floor(rgba[0]);\n  rgba[1] = Math.floor(rgba[1]);\n  rgba[2] = Math.floor(rgba[2]);\n  return 'rgba(' + rgba.join(',') + ')';\n}\n\nfunction getArrayDim(keyframes) {\n  var lastValue = keyframes[keyframes.length - 1].value;\n  return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n}\n\nfunction createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {\n  var getter = animator._getter;\n  var setter = animator._setter;\n  var useSpline = easing === 'spline';\n  var trackLen = keyframes.length;\n\n  if (!trackLen) {\n    return;\n  } // Guess data type\n\n\n  var firstVal = keyframes[0].value;\n  var isValueArray = isArrayLike(firstVal);\n  var isValueColor = false;\n  var isValueString = false; // For vertices morphing\n\n  var arrDim = isValueArray ? getArrayDim(keyframes) : 0;\n  var trackMaxTime; // Sort keyframe as ascending\n\n  keyframes.sort(function (a, b) {\n    return a.time - b.time;\n  });\n  trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe\n\n  var kfPercents = []; // Value of each keyframe\n\n  var kfValues = [];\n  var prevValue = keyframes[0].value;\n  var isAllValueEqual = true;\n\n  for (var i = 0; i < trackLen; i++) {\n    kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string\n\n    var value = keyframes[i].value; // Check if value is equal, deep check if value is array\n\n    if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {\n      isAllValueEqual = false;\n    }\n\n    prevValue = value; // Try converting a string to a color array\n\n    if (typeof value == 'string') {\n      var colorArray = color.parse(value);\n\n      if (colorArray) {\n        value = colorArray;\n        isValueColor = true;\n      } else {\n        isValueString = true;\n      }\n    }\n\n    kfValues.push(value);\n  }\n\n  if (!forceAnimate && isAllValueEqual) {\n    return;\n  }\n\n  var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value\n\n  for (var i = 0; i < trackLen - 1; i++) {\n    if (isValueArray) {\n      fillArr(kfValues[i], lastValue, arrDim);\n    } else {\n      if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n        kfValues[i] = lastValue;\n      }\n    }\n  }\n\n  isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when\n  // animation playback is sequency\n\n  var lastFrame = 0;\n  var lastFramePercent = 0;\n  var start;\n  var w;\n  var p0;\n  var p1;\n  var p2;\n  var p3;\n\n  if (isValueColor) {\n    var rgba = [0, 0, 0, 0];\n  }\n\n  var onframe = function (target, percent) {\n    // Find the range keyframes\n    // kf1-----kf2---------current--------kf3\n    // find kf2 and kf3 and do interpolation\n    var frame; // In the easing function like elasticOut, percent may less than 0\n\n    if (percent < 0) {\n      frame = 0;\n    } else if (percent < lastFramePercent) {\n      // Start from next key\n      // PENDING start from lastFrame ?\n      start = Math.min(lastFrame + 1, trackLen - 1);\n\n      for (frame = start; frame >= 0; frame--) {\n        if (kfPercents[frame] <= percent) {\n          break;\n        }\n      } // PENDING really need to do this ?\n\n\n      frame = Math.min(frame, trackLen - 2);\n    } else {\n      for (frame = lastFrame; frame < trackLen; frame++) {\n        if (kfPercents[frame] > percent) {\n          break;\n        }\n      }\n\n      frame = Math.min(frame - 1, trackLen - 2);\n    }\n\n    lastFrame = frame;\n    lastFramePercent = percent;\n    var range = kfPercents[frame + 1] - kfPercents[frame];\n\n    if (range === 0) {\n      return;\n    } else {\n      w = (percent - kfPercents[frame]) / range;\n    }\n\n    if (useSpline) {\n      p1 = kfValues[frame];\n      p0 = kfValues[frame === 0 ? frame : frame - 1];\n      p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n      p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\n      if (isValueArray) {\n        catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);\n      } else {\n        var value;\n\n        if (isValueColor) {\n          value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);\n          value = rgba2String(rgba);\n        } else if (isValueString) {\n          // String is step(0.5)\n          return interpolateString(p1, p2, w);\n        } else {\n          value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);\n        }\n\n        setter(target, propName, value);\n      }\n    } else {\n      if (isValueArray) {\n        interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);\n      } else {\n        var value;\n\n        if (isValueColor) {\n          interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);\n          value = rgba2String(rgba);\n        } else if (isValueString) {\n          // String is step(0.5)\n          return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n        } else {\n          value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n        }\n\n        setter(target, propName, value);\n      }\n    }\n  };\n\n  var clip = new Clip({\n    target: animator._target,\n    life: trackMaxTime,\n    loop: animator._loop,\n    delay: animator._delay,\n    onframe: onframe,\n    ondestroy: oneTrackDone\n  });\n\n  if (easing && easing !== 'spline') {\n    clip.easing = easing;\n  }\n\n  return clip;\n}\n/**\n * @alias module:zrender/animation/Animator\n * @constructor\n * @param {Object} target\n * @param {boolean} loop\n * @param {Function} getter\n * @param {Function} setter\n */\n\n\nvar Animator = function (target, loop, getter, setter) {\n  this._tracks = {};\n  this._target = target;\n  this._loop = loop || false;\n  this._getter = getter || defaultGetter;\n  this._setter = setter || defaultSetter;\n  this._clipCount = 0;\n  this._delay = 0;\n  this._doneList = [];\n  this._onframeList = [];\n  this._clipList = [];\n};\n\nAnimator.prototype = {\n  /**\n   * 设置动画关键帧\n   * @param  {number} time 关键帧时间，单位是ms\n   * @param  {Object} props 关键帧的属性值，key-value表示\n   * @return {module:zrender/animation/Animator}\n   */\n  when: function (time\n  /* ms */\n  , props) {\n    var tracks = this._tracks;\n\n    for (var propName in props) {\n      if (!props.hasOwnProperty(propName)) {\n        continue;\n      }\n\n      if (!tracks[propName]) {\n        tracks[propName] = []; // Invalid value\n\n        var value = this._getter(this._target, propName);\n\n        if (value == null) {\n          // zrLog('Invalid property ' + propName);\n          continue;\n        } // If time is 0\n        //  Then props is given initialize value\n        // Else\n        //  Initialize value from current prop value\n\n\n        if (time !== 0) {\n          tracks[propName].push({\n            time: 0,\n            value: cloneValue(value)\n          });\n        }\n      }\n\n      tracks[propName].push({\n        time: time,\n        value: props[propName]\n      });\n    }\n\n    return this;\n  },\n\n  /**\n   * 添加动画每一帧的回调函数\n   * @param  {Function} callback\n   * @return {module:zrender/animation/Animator}\n   */\n  during: function (callback) {\n    this._onframeList.push(callback);\n\n    return this;\n  },\n  pause: function () {\n    for (var i = 0; i < this._clipList.length; i++) {\n      this._clipList[i].pause();\n    }\n\n    this._paused = true;\n  },\n  resume: function () {\n    for (var i = 0; i < this._clipList.length; i++) {\n      this._clipList[i].resume();\n    }\n\n    this._paused = false;\n  },\n  isPaused: function () {\n    return !!this._paused;\n  },\n  _doneCallback: function () {\n    // Clear all tracks\n    this._tracks = {}; // Clear all clips\n\n    this._clipList.length = 0;\n    var doneList = this._doneList;\n    var len = doneList.length;\n\n    for (var i = 0; i < len; i++) {\n      doneList[i].call(this);\n    }\n  },\n\n  /**\n   * 开始执行动画\n   * @param  {string|Function} [easing]\n   *         动画缓动函数，详见{@link module:zrender/animation/easing}\n   * @param  {boolean} forceAnimate\n   * @return {module:zrender/animation/Animator}\n   */\n  start: function (easing, forceAnimate) {\n    var self = this;\n    var clipCount = 0;\n\n    var oneTrackDone = function () {\n      clipCount--;\n\n      if (!clipCount) {\n        self._doneCallback();\n      }\n    };\n\n    var lastClip;\n\n    for (var propName in this._tracks) {\n      if (!this._tracks.hasOwnProperty(propName)) {\n        continue;\n      }\n\n      var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);\n\n      if (clip) {\n        this._clipList.push(clip);\n\n        clipCount++; // If start after added to animation\n\n        if (this.animation) {\n          this.animation.addClip(clip);\n        }\n\n        lastClip = clip;\n      }\n    } // Add during callback on the last clip\n\n\n    if (lastClip) {\n      var oldOnFrame = lastClip.onframe;\n\n      lastClip.onframe = function (target, percent) {\n        oldOnFrame(target, percent);\n\n        for (var i = 0; i < self._onframeList.length; i++) {\n          self._onframeList[i](target, percent);\n        }\n      };\n    } // This optimization will help the case that in the upper application\n    // the view may be refreshed frequently, where animation will be\n    // called repeatly but nothing changed.\n\n\n    if (!clipCount) {\n      this._doneCallback();\n    }\n\n    return this;\n  },\n\n  /**\n   * 停止动画\n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stop: function (forwardToLast) {\n    var clipList = this._clipList;\n    var animation = this.animation;\n\n    for (var i = 0; i < clipList.length; i++) {\n      var clip = clipList[i];\n\n      if (forwardToLast) {\n        // Move to last frame before stop\n        clip.onframe(this._target, 1);\n      }\n\n      animation && animation.removeClip(clip);\n    }\n\n    clipList.length = 0;\n  },\n\n  /**\n   * 设置动画延迟开始的时间\n   * @param  {number} time 单位ms\n   * @return {module:zrender/animation/Animator}\n   */\n  delay: function (time) {\n    this._delay = time;\n    return this;\n  },\n\n  /**\n   * 添加动画结束的回调\n   * @param  {Function} cb\n   * @return {module:zrender/animation/Animator}\n   */\n  done: function (cb) {\n    if (cb) {\n      this._doneList.push(cb);\n    }\n\n    return this;\n  },\n\n  /**\n   * @return {Array.<module:zrender/animation/Clip>}\n   */\n  getClips: function () {\n    return this._clipList;\n  }\n};\nvar _default = Animator;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Animator.js\n// module id = 17\n// module chunks = 0","var easingFuncs = require(\"./easing\");\n\n/**\n * 动画主控制器\n * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\n * @config life(1000) 动画时长\n * @config delay(0) 动画延迟时间\n * @config loop(true)\n * @config gap(0) 循环的间隔时间\n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\nfunction Clip(options) {\n  this._target = options.target; // 生命周期\n\n  this._life = options.life || 1000; // 延时\n\n  this._delay = options.delay || 0; // 开始时间\n  // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n\n  this._initialized = false; // 是否循环\n\n  this.loop = options.loop == null ? false : options.loop;\n  this.gap = options.gap || 0;\n  this.easing = options.easing || 'Linear';\n  this.onframe = options.onframe;\n  this.ondestroy = options.ondestroy;\n  this.onrestart = options.onrestart;\n  this._pausedTime = 0;\n  this._paused = false;\n}\n\nClip.prototype = {\n  constructor: Clip,\n  step: function (globalTime, deltaTime) {\n    // Set startTime on first step, or _startTime may has milleseconds different between clips\n    // PENDING\n    if (!this._initialized) {\n      this._startTime = globalTime + this._delay;\n      this._initialized = true;\n    }\n\n    if (this._paused) {\n      this._pausedTime += deltaTime;\n      return;\n    }\n\n    var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // 还没开始\n\n    if (percent < 0) {\n      return;\n    }\n\n    percent = Math.min(percent, 1);\n    var easing = this.easing;\n    var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n    var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;\n    this.fire('frame', schedule); // 结束\n\n    if (percent == 1) {\n      if (this.loop) {\n        this.restart(globalTime); // 重新开始周期\n        // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n\n        return 'restart';\n      } // 动画完成将这个控制器标识为待删除\n      // 在Animation.update中进行批量删除\n\n\n      this._needsRemove = true;\n      return 'destroy';\n    }\n\n    return null;\n  },\n  restart: function (globalTime) {\n    var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n    this._startTime = globalTime - remainder + this.gap;\n    this._pausedTime = 0;\n    this._needsRemove = false;\n  },\n  fire: function (eventType, arg) {\n    eventType = 'on' + eventType;\n\n    if (this[eventType]) {\n      this[eventType](this._target, arg);\n    }\n  },\n  pause: function () {\n    this._paused = true;\n  },\n  resume: function () {\n    this._paused = false;\n  }\n};\nvar _default = Clip;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Clip.js\n// module id = 18\n// module chunks = 0","/**\n * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\nvar easing = {\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  linear: function (k) {\n    return k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticIn: function (k) {\n    return k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticOut: function (k) {\n    return k * (2 - k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k;\n    }\n\n    return -0.5 * (--k * (k - 2) - 1);\n  },\n  // 三次方的缓动（t^3）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicIn: function (k) {\n    return k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicOut: function (k) {\n    return --k * k * k + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k;\n    }\n\n    return 0.5 * ((k -= 2) * k * k + 2);\n  },\n  // 四次方的缓动（t^4）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticIn: function (k) {\n    return k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticOut: function (k) {\n    return 1 - --k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k * k;\n    }\n\n    return -0.5 * ((k -= 2) * k * k * k - 2);\n  },\n  // 五次方的缓动（t^5）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticIn: function (k) {\n    return k * k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticOut: function (k) {\n    return --k * k * k * k * k + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k * k * k;\n    }\n\n    return 0.5 * ((k -= 2) * k * k * k * k + 2);\n  },\n  // 正弦曲线的缓动（sin(t)）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalIn: function (k) {\n    return 1 - Math.cos(k * Math.PI / 2);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalOut: function (k) {\n    return Math.sin(k * Math.PI / 2);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalInOut: function (k) {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n  },\n  // 指数曲线的缓动（2^t）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialIn: function (k) {\n    return k === 0 ? 0 : Math.pow(1024, k - 1);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialOut: function (k) {\n    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialInOut: function (k) {\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if ((k *= 2) < 1) {\n      return 0.5 * Math.pow(1024, k - 1);\n    }\n\n    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n  },\n  // 圆形曲线的缓动（sqrt(1-t^2)）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularIn: function (k) {\n    return 1 - Math.sqrt(1 - k * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularOut: function (k) {\n    return Math.sqrt(1 - --k * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return -0.5 * (Math.sqrt(1 - k * k) - 1);\n    }\n\n    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n  },\n  // 创建类似于弹簧在停止前来回振荡的动画\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticIn: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticOut: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticInOut: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    if ((k *= 2) < 1) {\n      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n    }\n\n    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n  },\n  // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backIn: function (k) {\n    var s = 1.70158;\n    return k * k * ((s + 1) * k - s);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backOut: function (k) {\n    var s = 1.70158;\n    return --k * k * ((s + 1) * k + s) + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backInOut: function (k) {\n    var s = 1.70158 * 1.525;\n\n    if ((k *= 2) < 1) {\n      return 0.5 * (k * k * ((s + 1) * k - s));\n    }\n\n    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n  },\n  // 创建弹跳效果\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceIn: function (k) {\n    return 1 - easing.bounceOut(1 - k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceOut: function (k) {\n    if (k < 1 / 2.75) {\n      return 7.5625 * k * k;\n    } else if (k < 2 / 2.75) {\n      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n    } else if (k < 2.5 / 2.75) {\n      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n    } else {\n      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n    }\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceInOut: function (k) {\n    if (k < 0.5) {\n      return easing.bounceIn(k * 2) * 0.5;\n    }\n\n    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n  }\n};\nvar _default = easing;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/easing.js\n// module id = 19\n// module chunks = 0","var LRU = require(\"../core/LRU\");\n\nvar kCSSColorTable = {\n  'transparent': [0, 0, 0, 0],\n  'aliceblue': [240, 248, 255, 1],\n  'antiquewhite': [250, 235, 215, 1],\n  'aqua': [0, 255, 255, 1],\n  'aquamarine': [127, 255, 212, 1],\n  'azure': [240, 255, 255, 1],\n  'beige': [245, 245, 220, 1],\n  'bisque': [255, 228, 196, 1],\n  'black': [0, 0, 0, 1],\n  'blanchedalmond': [255, 235, 205, 1],\n  'blue': [0, 0, 255, 1],\n  'blueviolet': [138, 43, 226, 1],\n  'brown': [165, 42, 42, 1],\n  'burlywood': [222, 184, 135, 1],\n  'cadetblue': [95, 158, 160, 1],\n  'chartreuse': [127, 255, 0, 1],\n  'chocolate': [210, 105, 30, 1],\n  'coral': [255, 127, 80, 1],\n  'cornflowerblue': [100, 149, 237, 1],\n  'cornsilk': [255, 248, 220, 1],\n  'crimson': [220, 20, 60, 1],\n  'cyan': [0, 255, 255, 1],\n  'darkblue': [0, 0, 139, 1],\n  'darkcyan': [0, 139, 139, 1],\n  'darkgoldenrod': [184, 134, 11, 1],\n  'darkgray': [169, 169, 169, 1],\n  'darkgreen': [0, 100, 0, 1],\n  'darkgrey': [169, 169, 169, 1],\n  'darkkhaki': [189, 183, 107, 1],\n  'darkmagenta': [139, 0, 139, 1],\n  'darkolivegreen': [85, 107, 47, 1],\n  'darkorange': [255, 140, 0, 1],\n  'darkorchid': [153, 50, 204, 1],\n  'darkred': [139, 0, 0, 1],\n  'darksalmon': [233, 150, 122, 1],\n  'darkseagreen': [143, 188, 143, 1],\n  'darkslateblue': [72, 61, 139, 1],\n  'darkslategray': [47, 79, 79, 1],\n  'darkslategrey': [47, 79, 79, 1],\n  'darkturquoise': [0, 206, 209, 1],\n  'darkviolet': [148, 0, 211, 1],\n  'deeppink': [255, 20, 147, 1],\n  'deepskyblue': [0, 191, 255, 1],\n  'dimgray': [105, 105, 105, 1],\n  'dimgrey': [105, 105, 105, 1],\n  'dodgerblue': [30, 144, 255, 1],\n  'firebrick': [178, 34, 34, 1],\n  'floralwhite': [255, 250, 240, 1],\n  'forestgreen': [34, 139, 34, 1],\n  'fuchsia': [255, 0, 255, 1],\n  'gainsboro': [220, 220, 220, 1],\n  'ghostwhite': [248, 248, 255, 1],\n  'gold': [255, 215, 0, 1],\n  'goldenrod': [218, 165, 32, 1],\n  'gray': [128, 128, 128, 1],\n  'green': [0, 128, 0, 1],\n  'greenyellow': [173, 255, 47, 1],\n  'grey': [128, 128, 128, 1],\n  'honeydew': [240, 255, 240, 1],\n  'hotpink': [255, 105, 180, 1],\n  'indianred': [205, 92, 92, 1],\n  'indigo': [75, 0, 130, 1],\n  'ivory': [255, 255, 240, 1],\n  'khaki': [240, 230, 140, 1],\n  'lavender': [230, 230, 250, 1],\n  'lavenderblush': [255, 240, 245, 1],\n  'lawngreen': [124, 252, 0, 1],\n  'lemonchiffon': [255, 250, 205, 1],\n  'lightblue': [173, 216, 230, 1],\n  'lightcoral': [240, 128, 128, 1],\n  'lightcyan': [224, 255, 255, 1],\n  'lightgoldenrodyellow': [250, 250, 210, 1],\n  'lightgray': [211, 211, 211, 1],\n  'lightgreen': [144, 238, 144, 1],\n  'lightgrey': [211, 211, 211, 1],\n  'lightpink': [255, 182, 193, 1],\n  'lightsalmon': [255, 160, 122, 1],\n  'lightseagreen': [32, 178, 170, 1],\n  'lightskyblue': [135, 206, 250, 1],\n  'lightslategray': [119, 136, 153, 1],\n  'lightslategrey': [119, 136, 153, 1],\n  'lightsteelblue': [176, 196, 222, 1],\n  'lightyellow': [255, 255, 224, 1],\n  'lime': [0, 255, 0, 1],\n  'limegreen': [50, 205, 50, 1],\n  'linen': [250, 240, 230, 1],\n  'magenta': [255, 0, 255, 1],\n  'maroon': [128, 0, 0, 1],\n  'mediumaquamarine': [102, 205, 170, 1],\n  'mediumblue': [0, 0, 205, 1],\n  'mediumorchid': [186, 85, 211, 1],\n  'mediumpurple': [147, 112, 219, 1],\n  'mediumseagreen': [60, 179, 113, 1],\n  'mediumslateblue': [123, 104, 238, 1],\n  'mediumspringgreen': [0, 250, 154, 1],\n  'mediumturquoise': [72, 209, 204, 1],\n  'mediumvioletred': [199, 21, 133, 1],\n  'midnightblue': [25, 25, 112, 1],\n  'mintcream': [245, 255, 250, 1],\n  'mistyrose': [255, 228, 225, 1],\n  'moccasin': [255, 228, 181, 1],\n  'navajowhite': [255, 222, 173, 1],\n  'navy': [0, 0, 128, 1],\n  'oldlace': [253, 245, 230, 1],\n  'olive': [128, 128, 0, 1],\n  'olivedrab': [107, 142, 35, 1],\n  'orange': [255, 165, 0, 1],\n  'orangered': [255, 69, 0, 1],\n  'orchid': [218, 112, 214, 1],\n  'palegoldenrod': [238, 232, 170, 1],\n  'palegreen': [152, 251, 152, 1],\n  'paleturquoise': [175, 238, 238, 1],\n  'palevioletred': [219, 112, 147, 1],\n  'papayawhip': [255, 239, 213, 1],\n  'peachpuff': [255, 218, 185, 1],\n  'peru': [205, 133, 63, 1],\n  'pink': [255, 192, 203, 1],\n  'plum': [221, 160, 221, 1],\n  'powderblue': [176, 224, 230, 1],\n  'purple': [128, 0, 128, 1],\n  'red': [255, 0, 0, 1],\n  'rosybrown': [188, 143, 143, 1],\n  'royalblue': [65, 105, 225, 1],\n  'saddlebrown': [139, 69, 19, 1],\n  'salmon': [250, 128, 114, 1],\n  'sandybrown': [244, 164, 96, 1],\n  'seagreen': [46, 139, 87, 1],\n  'seashell': [255, 245, 238, 1],\n  'sienna': [160, 82, 45, 1],\n  'silver': [192, 192, 192, 1],\n  'skyblue': [135, 206, 235, 1],\n  'slateblue': [106, 90, 205, 1],\n  'slategray': [112, 128, 144, 1],\n  'slategrey': [112, 128, 144, 1],\n  'snow': [255, 250, 250, 1],\n  'springgreen': [0, 255, 127, 1],\n  'steelblue': [70, 130, 180, 1],\n  'tan': [210, 180, 140, 1],\n  'teal': [0, 128, 128, 1],\n  'thistle': [216, 191, 216, 1],\n  'tomato': [255, 99, 71, 1],\n  'turquoise': [64, 224, 208, 1],\n  'violet': [238, 130, 238, 1],\n  'wheat': [245, 222, 179, 1],\n  'white': [255, 255, 255, 1],\n  'whitesmoke': [245, 245, 245, 1],\n  'yellow': [255, 255, 0, 1],\n  'yellowgreen': [154, 205, 50, 1]\n};\n\nfunction clampCssByte(i) {\n  // Clamp to integer 0 .. 255.\n  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\n  return i < 0 ? 0 : i > 255 ? 255 : i;\n}\n\nfunction clampCssAngle(i) {\n  // Clamp to integer 0 .. 360.\n  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\n  return i < 0 ? 0 : i > 360 ? 360 : i;\n}\n\nfunction clampCssFloat(f) {\n  // Clamp to float 0.0 .. 1.0.\n  return f < 0 ? 0 : f > 1 ? 1 : f;\n}\n\nfunction parseCssInt(str) {\n  // int or percentage.\n  if (str.length && str.charAt(str.length - 1) === '%') {\n    return clampCssByte(parseFloat(str) / 100 * 255);\n  }\n\n  return clampCssByte(parseInt(str, 10));\n}\n\nfunction parseCssFloat(str) {\n  // float or percentage.\n  if (str.length && str.charAt(str.length - 1) === '%') {\n    return clampCssFloat(parseFloat(str) / 100);\n  }\n\n  return clampCssFloat(parseFloat(str));\n}\n\nfunction cssHueToRgb(m1, m2, h) {\n  if (h < 0) {\n    h += 1;\n  } else if (h > 1) {\n    h -= 1;\n  }\n\n  if (h * 6 < 1) {\n    return m1 + (m2 - m1) * h * 6;\n  }\n\n  if (h * 2 < 1) {\n    return m2;\n  }\n\n  if (h * 3 < 2) {\n    return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n  }\n\n  return m1;\n}\n\nfunction lerpNumber(a, b, p) {\n  return a + (b - a) * p;\n}\n\nfunction setRgba(out, r, g, b, a) {\n  out[0] = r;\n  out[1] = g;\n  out[2] = b;\n  out[3] = a;\n  return out;\n}\n\nfunction copyRgba(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\nvar colorCache = new LRU(20);\nvar lastRemovedArr = null;\n\nfunction putToCache(colorStr, rgbaArr) {\n  // Reuse removed array\n  if (lastRemovedArr) {\n    copyRgba(lastRemovedArr, rgbaArr);\n  }\n\n  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());\n}\n/**\n * @param {string} colorStr\n * @param {Array.<number>} out\n * @return {Array.<number>}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction parse(colorStr, rgbaArr) {\n  if (!colorStr) {\n    return;\n  }\n\n  rgbaArr = rgbaArr || [];\n  var cached = colorCache.get(colorStr);\n\n  if (cached) {\n    return copyRgba(rgbaArr, cached);\n  } // colorStr may be not string\n\n\n  colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.\n\n  var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.\n\n  if (str in kCSSColorTable) {\n    copyRgba(rgbaArr, kCSSColorTable[str]);\n    putToCache(colorStr, rgbaArr);\n    return rgbaArr;\n  } // #abc and #abc123 syntax.\n\n\n  if (str.charAt(0) === '#') {\n    if (str.length === 4) {\n      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\n      if (!(iv >= 0 && iv <= 0xfff)) {\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return; // Covers NaN.\n      }\n\n      setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);\n      putToCache(colorStr, rgbaArr);\n      return rgbaArr;\n    } else if (str.length === 7) {\n      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\n      if (!(iv >= 0 && iv <= 0xffffff)) {\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return; // Covers NaN.\n      }\n\n      setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);\n      putToCache(colorStr, rgbaArr);\n      return rgbaArr;\n    }\n\n    return;\n  }\n\n  var op = str.indexOf('('),\n      ep = str.indexOf(')');\n\n  if (op !== -1 && ep + 1 === str.length) {\n    var fname = str.substr(0, op);\n    var params = str.substr(op + 1, ep - (op + 1)).split(',');\n    var alpha = 1; // To allow case fallthrough.\n\n    switch (fname) {\n      case 'rgba':\n        if (params.length !== 4) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        alpha = parseCssFloat(params.pop());\n      // jshint ignore:line\n      // Fall through.\n\n      case 'rgb':\n        if (params.length !== 3) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      case 'hsla':\n        if (params.length !== 4) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        params[3] = parseCssFloat(params[3]);\n        hsla2rgba(params, rgbaArr);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      case 'hsl':\n        if (params.length !== 3) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        hsla2rgba(params, rgbaArr);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      default:\n        return;\n    }\n  }\n\n  setRgba(rgbaArr, 0, 0, 0, 1);\n  return;\n}\n/**\n * @param {Array.<number>} hsla\n * @param {Array.<number>} rgba\n * @return {Array.<number>} rgba\n */\n\n\nfunction hsla2rgba(hsla, rgba) {\n  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1\n  // NOTE(deanm): According to the CSS spec s/l should only be\n  // percentages, but we don't bother and let float or percentage.\n\n  var s = parseCssFloat(hsla[1]);\n  var l = parseCssFloat(hsla[2]);\n  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n  var m1 = l * 2 - m2;\n  rgba = rgba || [];\n  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);\n\n  if (hsla.length === 4) {\n    rgba[3] = hsla[3];\n  }\n\n  return rgba;\n}\n/**\n * @param {Array.<number>} rgba\n * @return {Array.<number>} hsla\n */\n\n\nfunction rgba2hsla(rgba) {\n  if (!rgba) {\n    return;\n  } // RGB from 0 to 255\n\n\n  var R = rgba[0] / 255;\n  var G = rgba[1] / 255;\n  var B = rgba[2] / 255;\n  var vMin = Math.min(R, G, B); // Min. value of RGB\n\n  var vMax = Math.max(R, G, B); // Max. value of RGB\n\n  var delta = vMax - vMin; // Delta RGB value\n\n  var L = (vMax + vMin) / 2;\n  var H;\n  var S; // HSL results from 0 to 1\n\n  if (delta === 0) {\n    H = 0;\n    S = 0;\n  } else {\n    if (L < 0.5) {\n      S = delta / (vMax + vMin);\n    } else {\n      S = delta / (2 - vMax - vMin);\n    }\n\n    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;\n    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;\n    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;\n\n    if (R === vMax) {\n      H = deltaB - deltaG;\n    } else if (G === vMax) {\n      H = 1 / 3 + deltaR - deltaB;\n    } else if (B === vMax) {\n      H = 2 / 3 + deltaG - deltaR;\n    }\n\n    if (H < 0) {\n      H += 1;\n    }\n\n    if (H > 1) {\n      H -= 1;\n    }\n  }\n\n  var hsla = [H * 360, S, L];\n\n  if (rgba[3] != null) {\n    hsla.push(rgba[3]);\n  }\n\n  return hsla;\n}\n/**\n * @param {string} color\n * @param {number} level\n * @return {string}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction lift(color, level) {\n  var colorArr = parse(color);\n\n  if (colorArr) {\n    for (var i = 0; i < 3; i++) {\n      if (level < 0) {\n        colorArr[i] = colorArr[i] * (1 - level) | 0;\n      } else {\n        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;\n      }\n    }\n\n    return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n  }\n}\n/**\n * @param {string} color\n * @return {string}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction toHex(color) {\n  var colorArr = parse(color);\n\n  if (colorArr) {\n    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);\n  }\n}\n/**\n * Map value to color. Faster than lerp methods because color is represented by rgba array.\n * @param {number} normalizedValue A float between 0 and 1.\n * @param {Array.<Array.<number>>} colors List of rgba color array\n * @param {Array.<number>} [out] Mapped gba color array\n * @return {Array.<number>} will be null/undefined if input illegal.\n */\n\n\nfunction fastLerp(normalizedValue, colors, out) {\n  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n    return;\n  }\n\n  out = out || [];\n  var value = normalizedValue * (colors.length - 1);\n  var leftIndex = Math.floor(value);\n  var rightIndex = Math.ceil(value);\n  var leftColor = colors[leftIndex];\n  var rightColor = colors[rightIndex];\n  var dv = value - leftIndex;\n  out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));\n  out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));\n  out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));\n  out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));\n  return out;\n}\n/**\n * @deprecated\n */\n\n\nvar fastMapToColor = fastLerp;\n/**\n * @param {number} normalizedValue A float between 0 and 1.\n * @param {Array.<string>} colors Color list.\n * @param {boolean=} fullOutput Default false.\n * @return {(string|Object)} Result color. If fullOutput,\n *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n * @memberOf module:zrender/util/color\n */\n\nfunction lerp(normalizedValue, colors, fullOutput) {\n  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n    return;\n  }\n\n  var value = normalizedValue * (colors.length - 1);\n  var leftIndex = Math.floor(value);\n  var rightIndex = Math.ceil(value);\n  var leftColor = parse(colors[leftIndex]);\n  var rightColor = parse(colors[rightIndex]);\n  var dv = value - leftIndex;\n  var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');\n  return fullOutput ? {\n    color: color,\n    leftIndex: leftIndex,\n    rightIndex: rightIndex,\n    value: value\n  } : color;\n}\n/**\n * @deprecated\n */\n\n\nvar mapToColor = lerp;\n/**\n * @param {string} color\n * @param {number=} h 0 ~ 360, ignore when null.\n * @param {number=} s 0 ~ 1, ignore when null.\n * @param {number=} l 0 ~ 1, ignore when null.\n * @return {string} Color string in rgba format.\n * @memberOf module:zrender/util/color\n */\n\nfunction modifyHSL(color, h, s, l) {\n  color = parse(color);\n\n  if (color) {\n    color = rgba2hsla(color);\n    h != null && (color[0] = clampCssAngle(h));\n    s != null && (color[1] = parseCssFloat(s));\n    l != null && (color[2] = parseCssFloat(l));\n    return stringify(hsla2rgba(color), 'rgba');\n  }\n}\n/**\n * @param {string} color\n * @param {number=} alpha 0 ~ 1\n * @return {string} Color string in rgba format.\n * @memberOf module:zrender/util/color\n */\n\n\nfunction modifyAlpha(color, alpha) {\n  color = parse(color);\n\n  if (color && alpha != null) {\n    color[3] = clampCssFloat(alpha);\n    return stringify(color, 'rgba');\n  }\n}\n/**\n * @param {Array.<number>} arrColor like [12,33,44,0.4]\n * @param {string} type 'rgba', 'hsva', ...\n * @return {string} Result color. (If input illegal, return undefined).\n */\n\n\nfunction stringify(arrColor, type) {\n  if (!arrColor || !arrColor.length) {\n    return;\n  }\n\n  var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\n  if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n    colorStr += ',' + arrColor[3];\n  }\n\n  return type + '(' + colorStr + ')';\n}\n\nexports.parse = parse;\nexports.lift = lift;\nexports.toHex = toHex;\nexports.fastLerp = fastLerp;\nexports.fastMapToColor = fastMapToColor;\nexports.lerp = lerp;\nexports.mapToColor = mapToColor;\nexports.modifyHSL = modifyHSL;\nexports.modifyAlpha = modifyAlpha;\nexports.stringify = stringify;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/color.js\n// module id = 20\n// module chunks = 0","// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n/**\n * Simple double linked list. Compared with array, it has O(1) remove operation.\n * @constructor\n */\nvar LinkedList = function () {\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n  this.head = null;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.tail = null;\n  this._len = 0;\n};\n\nvar linkedListProto = LinkedList.prototype;\n/**\n * Insert a new value at the tail\n * @param  {} val\n * @return {module:zrender/core/LRU~Entry}\n */\n\nlinkedListProto.insert = function (val) {\n  var entry = new Entry(val);\n  this.insertEntry(entry);\n  return entry;\n};\n/**\n * Insert an entry at the tail\n * @param  {module:zrender/core/LRU~Entry} entry\n */\n\n\nlinkedListProto.insertEntry = function (entry) {\n  if (!this.head) {\n    this.head = this.tail = entry;\n  } else {\n    this.tail.next = entry;\n    entry.prev = this.tail;\n    entry.next = null;\n    this.tail = entry;\n  }\n\n  this._len++;\n};\n/**\n * Remove entry.\n * @param  {module:zrender/core/LRU~Entry} entry\n */\n\n\nlinkedListProto.remove = function (entry) {\n  var prev = entry.prev;\n  var next = entry.next;\n\n  if (prev) {\n    prev.next = next;\n  } else {\n    // Is head\n    this.head = next;\n  }\n\n  if (next) {\n    next.prev = prev;\n  } else {\n    // Is tail\n    this.tail = prev;\n  }\n\n  entry.next = entry.prev = null;\n  this._len--;\n};\n/**\n * @return {number}\n */\n\n\nlinkedListProto.len = function () {\n  return this._len;\n};\n/**\n * Clear list\n */\n\n\nlinkedListProto.clear = function () {\n  this.head = this.tail = null;\n  this._len = 0;\n};\n/**\n * @constructor\n * @param {} val\n */\n\n\nvar Entry = function (val) {\n  /**\n   * @type {}\n   */\n  this.value = val;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.next;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.prev;\n};\n/**\n * LRU Cache\n * @constructor\n * @alias module:zrender/core/LRU\n */\n\n\nvar LRU = function (maxSize) {\n  this._list = new LinkedList();\n  this._map = {};\n  this._maxSize = maxSize || 10;\n  this._lastRemovedEntry = null;\n};\n\nvar LRUProto = LRU.prototype;\n/**\n * @param  {string} key\n * @param  {} value\n * @return {} Removed value\n */\n\nLRUProto.put = function (key, value) {\n  var list = this._list;\n  var map = this._map;\n  var removed = null;\n\n  if (map[key] == null) {\n    var len = list.len(); // Reuse last removed entry\n\n    var entry = this._lastRemovedEntry;\n\n    if (len >= this._maxSize && len > 0) {\n      // Remove the least recently used\n      var leastUsedEntry = list.head;\n      list.remove(leastUsedEntry);\n      delete map[leastUsedEntry.key];\n      removed = leastUsedEntry.value;\n      this._lastRemovedEntry = leastUsedEntry;\n    }\n\n    if (entry) {\n      entry.value = value;\n    } else {\n      entry = new Entry(value);\n    }\n\n    entry.key = key;\n    list.insertEntry(entry);\n    map[key] = entry;\n  }\n\n  return removed;\n};\n/**\n * @param  {string} key\n * @return {}\n */\n\n\nLRUProto.get = function (key) {\n  var entry = this._map[key];\n  var list = this._list;\n\n  if (entry != null) {\n    // Put the latest used entry in the tail\n    if (entry !== list.tail) {\n      list.remove(entry);\n      list.insertEntry(entry);\n    }\n\n    return entry.value;\n  }\n};\n/**\n * Clear the cache\n */\n\n\nLRUProto.clear = function () {\n  this._list.clear();\n\n  this._map = {};\n};\n\nvar _default = LRU;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/LRU.js\n// module id = 21\n// module chunks = 0","var _config = require(\"../config\");\n\nvar debugMode = _config.debugMode;\n\nvar log = function () {};\n\nif (debugMode === 1) {\n  log = function () {\n    for (var k in arguments) {\n      throw new Error(arguments[k]);\n    }\n  };\n} else if (debugMode > 1) {\n  log = function () {\n    for (var k in arguments) {\n      console.log(arguments[k]);\n    }\n  };\n}\n\nvar _default = log;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/log.js\n// module id = 22\n// module chunks = 0","var dpr = 1; // If in browser environment\n\nif (typeof window !== 'undefined') {\n  dpr = Math.max(window.devicePixelRatio || 1, 1);\n}\n/**\n * config默认配置项\n * @exports zrender/config\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n */\n\n/**\n * debug日志选项：catchBrushException为true下有效\n * 0 : 不生成debug数据，发布用\n * 1 : 异常抛出，调试用\n * 2 : 控制台输出，调试用\n */\n\n\nvar debugMode = 0; // retina 屏幕优化\n\nvar devicePixelRatio = dpr;\nexports.debugMode = debugMode;\nexports.devicePixelRatio = devicePixelRatio;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/config.js\n// module id = 23\n// module chunks = 0","var vec2 = require(\"./vector\");\n\nvar matrix = require(\"./matrix\");\n\n/**\n * @module echarts/core/BoundingRect\n */\nvar v2ApplyTransform = vec2.applyTransform;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\n/**\n * @alias module:echarts/core/BoundingRect\n */\n\nfunction BoundingRect(x, y, width, height) {\n  if (width < 0) {\n    x = x + width;\n    width = -width;\n  }\n\n  if (height < 0) {\n    y = y + height;\n    height = -height;\n  }\n  /**\n   * @type {number}\n   */\n\n\n  this.x = x;\n  /**\n   * @type {number}\n   */\n\n  this.y = y;\n  /**\n   * @type {number}\n   */\n\n  this.width = width;\n  /**\n   * @type {number}\n   */\n\n  this.height = height;\n}\n\nBoundingRect.prototype = {\n  constructor: BoundingRect,\n\n  /**\n   * @param {module:echarts/core/BoundingRect} other\n   */\n  union: function (other) {\n    var x = mathMin(other.x, this.x);\n    var y = mathMin(other.y, this.y);\n    this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n    this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n    this.x = x;\n    this.y = y;\n  },\n\n  /**\n   * @param {Array.<number>} m\n   * @methods\n   */\n  applyTransform: function () {\n    var lt = [];\n    var rb = [];\n    var lb = [];\n    var rt = [];\n    return function (m) {\n      // In case usage like this\n      // el.getBoundingRect().applyTransform(el.transform)\n      // And element has no transform\n      if (!m) {\n        return;\n      }\n\n      lt[0] = lb[0] = this.x;\n      lt[1] = rt[1] = this.y;\n      rb[0] = rt[0] = this.x + this.width;\n      rb[1] = lb[1] = this.y + this.height;\n      v2ApplyTransform(lt, lt, m);\n      v2ApplyTransform(rb, rb, m);\n      v2ApplyTransform(lb, lb, m);\n      v2ApplyTransform(rt, rt, m);\n      this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n      this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n      var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n      var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n      this.width = maxX - this.x;\n      this.height = maxY - this.y;\n    };\n  }(),\n\n  /**\n   * Calculate matrix of transforming from self to target rect\n   * @param  {module:zrender/core/BoundingRect} b\n   * @return {Array.<number>}\n   */\n  calculateTransform: function (b) {\n    var a = this;\n    var sx = b.width / a.width;\n    var sy = b.height / a.height;\n    var m = matrix.create(); // 矩阵右乘\n\n    matrix.translate(m, m, [-a.x, -a.y]);\n    matrix.scale(m, m, [sx, sy]);\n    matrix.translate(m, m, [b.x, b.y]);\n    return m;\n  },\n\n  /**\n   * @param {(module:echarts/core/BoundingRect|Object)} b\n   * @return {boolean}\n   */\n  intersect: function (b) {\n    if (!b) {\n      return false;\n    }\n\n    if (!(b instanceof BoundingRect)) {\n      // Normalize negative width/height.\n      b = BoundingRect.create(b);\n    }\n\n    var a = this;\n    var ax0 = a.x;\n    var ax1 = a.x + a.width;\n    var ay0 = a.y;\n    var ay1 = a.y + a.height;\n    var bx0 = b.x;\n    var bx1 = b.x + b.width;\n    var by0 = b.y;\n    var by1 = b.y + b.height;\n    return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n  },\n  contain: function (x, y) {\n    var rect = this;\n    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n  },\n\n  /**\n   * @return {module:echarts/core/BoundingRect}\n   */\n  clone: function () {\n    return new BoundingRect(this.x, this.y, this.width, this.height);\n  },\n\n  /**\n   * Copy from another rect\n   */\n  copy: function (other) {\n    this.x = other.x;\n    this.y = other.y;\n    this.width = other.width;\n    this.height = other.height;\n  },\n  plain: function () {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height\n    };\n  }\n};\n/**\n * @param {Object|module:zrender/core/BoundingRect} rect\n * @param {number} rect.x\n * @param {number} rect.y\n * @param {number} rect.width\n * @param {number} rect.height\n * @return {module:zrender/core/BoundingRect}\n */\n\nBoundingRect.create = function (rect) {\n  return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n};\n\nvar _default = BoundingRect;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/BoundingRect.js\n// module id = 24\n// module chunks = 0","// https://github.com/mziccard/node-timsort\nvar DEFAULT_MIN_MERGE = 32;\nvar DEFAULT_MIN_GALLOPING = 7;\nvar DEFAULT_TMP_STORAGE_LENGTH = 256;\n\nfunction minRunLength(n) {\n  var r = 0;\n\n  while (n >= DEFAULT_MIN_MERGE) {\n    r |= n & 1;\n    n >>= 1;\n  }\n\n  return n + r;\n}\n\nfunction makeAscendingRun(array, lo, hi, compare) {\n  var runHi = lo + 1;\n\n  if (runHi === hi) {\n    return 1;\n  }\n\n  if (compare(array[runHi++], array[lo]) < 0) {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n      runHi++;\n    }\n\n    reverseRun(array, lo, runHi);\n  } else {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n      runHi++;\n    }\n  }\n\n  return runHi - lo;\n}\n\nfunction reverseRun(array, lo, hi) {\n  hi--;\n\n  while (lo < hi) {\n    var t = array[lo];\n    array[lo++] = array[hi];\n    array[hi--] = t;\n  }\n}\n\nfunction binaryInsertionSort(array, lo, hi, start, compare) {\n  if (start === lo) {\n    start++;\n  }\n\n  for (; start < hi; start++) {\n    var pivot = array[start];\n    var left = lo;\n    var right = start;\n    var mid;\n\n    while (left < right) {\n      mid = left + right >>> 1;\n\n      if (compare(pivot, array[mid]) < 0) {\n        right = mid;\n      } else {\n        left = mid + 1;\n      }\n    }\n\n    var n = start - left;\n\n    switch (n) {\n      case 3:\n        array[left + 3] = array[left + 2];\n\n      case 2:\n        array[left + 2] = array[left + 1];\n\n      case 1:\n        array[left + 1] = array[left];\n        break;\n\n      default:\n        while (n > 0) {\n          array[left + n] = array[left + n - 1];\n          n--;\n        }\n\n    }\n\n    array[left] = pivot;\n  }\n}\n\nfunction gallopLeft(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) > 0) {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  } else {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) > 0) {\n      lastOffset = m + 1;\n    } else {\n      offset = m;\n    }\n  }\n\n  return offset;\n}\n\nfunction gallopRight(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) < 0) {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  } else {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) < 0) {\n      offset = m;\n    } else {\n      lastOffset = m + 1;\n    }\n  }\n\n  return offset;\n}\n\nfunction TimSort(array, compare) {\n  var minGallop = DEFAULT_MIN_GALLOPING;\n  var length = 0;\n  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n  var stackLength = 0;\n  var runStart;\n  var runLength;\n  var stackSize = 0;\n  length = array.length;\n\n  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n    tmpStorageLength = length >>> 1;\n  }\n\n  var tmp = [];\n  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n  runStart = [];\n  runLength = [];\n\n  function pushRun(_runStart, _runLength) {\n    runStart[stackSize] = _runStart;\n    runLength[stackSize] = _runLength;\n    stackSize += 1;\n  }\n\n  function mergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n        if (runLength[n - 1] < runLength[n + 1]) {\n          n--;\n        }\n      } else if (runLength[n] > runLength[n + 1]) {\n        break;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function forceMergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n        n--;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function mergeAt(i) {\n    var start1 = runStart[i];\n    var length1 = runLength[i];\n    var start2 = runStart[i + 1];\n    var length2 = runLength[i + 1];\n    runLength[i] = length1 + length2;\n\n    if (i === stackSize - 3) {\n      runStart[i + 1] = runStart[i + 2];\n      runLength[i + 1] = runLength[i + 2];\n    }\n\n    stackSize--;\n    var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n    start1 += k;\n    length1 -= k;\n\n    if (length1 === 0) {\n      return;\n    }\n\n    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n    if (length2 === 0) {\n      return;\n    }\n\n    if (length1 <= length2) {\n      mergeLow(start1, length1, start2, length2);\n    } else {\n      mergeHigh(start1, length1, start2, length2);\n    }\n  }\n\n  function mergeLow(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length1; i++) {\n      tmp[i] = array[start1 + i];\n    }\n\n    var cursor1 = 0;\n    var cursor2 = start2;\n    var dest = start1;\n    array[dest++] = array[cursor2++];\n\n    if (--length2 === 0) {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n\n      return;\n    }\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n      return;\n    }\n\n    var _minGallop = minGallop;\n    var count1, count2, exit;\n\n    while (1) {\n      count1 = 0;\n      count2 = 0;\n      exit = false;\n\n      do {\n        if (compare(array[cursor2], tmp[cursor1]) < 0) {\n          array[dest++] = array[cursor2++];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest++] = tmp[cursor1++];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n        if (count1 !== 0) {\n          for (i = 0; i < count1; i++) {\n            array[dest + i] = tmp[cursor1 + i];\n          }\n\n          dest += count1;\n          cursor1 += count1;\n          length1 -= count1;\n\n          if (length1 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = array[cursor2++];\n\n        if (--length2 === 0) {\n          exit = true;\n          break;\n        }\n\n        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n        if (count2 !== 0) {\n          for (i = 0; i < count2; i++) {\n            array[dest + i] = array[cursor2 + i];\n          }\n\n          dest += count2;\n          cursor2 += count2;\n          length2 -= count2;\n\n          if (length2 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = tmp[cursor1++];\n\n        if (--length1 === 1) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n    minGallop < 1 && (minGallop = 1);\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n    } else if (length1 === 0) {\n      throw new Error(); // throw new Error('mergeLow preconditions were not respected');\n    } else {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n    }\n  }\n\n  function mergeHigh(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length2; i++) {\n      tmp[i] = array[start2 + i];\n    }\n\n    var cursor1 = start1 + length1 - 1;\n    var cursor2 = length2 - 1;\n    var dest = start2 + length2 - 1;\n    var customCursor = 0;\n    var customDest = 0;\n    array[dest--] = array[cursor1--];\n\n    if (--length1 === 0) {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n\n      return;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n      return;\n    }\n\n    var _minGallop = minGallop;\n\n    while (true) {\n      var count1 = 0;\n      var count2 = 0;\n      var exit = false;\n\n      do {\n        if (compare(tmp[cursor2], array[cursor1]) < 0) {\n          array[dest--] = array[cursor1--];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest--] = tmp[cursor2--];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n        if (count1 !== 0) {\n          dest -= count1;\n          cursor1 -= count1;\n          length1 -= count1;\n          customDest = dest + 1;\n          customCursor = cursor1 + 1;\n\n          for (i = count1 - 1; i >= 0; i--) {\n            array[customDest + i] = array[customCursor + i];\n          }\n\n          if (length1 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = tmp[cursor2--];\n\n        if (--length2 === 1) {\n          exit = true;\n          break;\n        }\n\n        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n        if (count2 !== 0) {\n          dest -= count2;\n          cursor2 -= count2;\n          length2 -= count2;\n          customDest = dest + 1;\n          customCursor = cursor2 + 1;\n\n          for (i = 0; i < count2; i++) {\n            array[customDest + i] = tmp[customCursor + i];\n          }\n\n          if (length2 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = array[cursor1--];\n\n        if (--length1 === 0) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n\n    if (minGallop < 1) {\n      minGallop = 1;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n    } else if (length2 === 0) {\n      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');\n    } else {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n    }\n  }\n\n  this.mergeRuns = mergeRuns;\n  this.forceMergeRuns = forceMergeRuns;\n  this.pushRun = pushRun;\n}\n\nfunction sort(array, compare, lo, hi) {\n  if (!lo) {\n    lo = 0;\n  }\n\n  if (!hi) {\n    hi = array.length;\n  }\n\n  var remaining = hi - lo;\n\n  if (remaining < 2) {\n    return;\n  }\n\n  var runLength = 0;\n\n  if (remaining < DEFAULT_MIN_MERGE) {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n    binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n    return;\n  }\n\n  var ts = new TimSort(array, compare);\n  var minRun = minRunLength(remaining);\n\n  do {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n\n    if (runLength < minRun) {\n      var force = remaining;\n\n      if (force > minRun) {\n        force = minRun;\n      }\n\n      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n      runLength = force;\n    }\n\n    ts.pushRun(lo, runLength);\n    ts.mergeRuns();\n    remaining -= runLength;\n    lo += runLength;\n  } while (remaining !== 0);\n\n  ts.forceMergeRuns();\n}\n\nmodule.exports = sort;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/timsort.js\n// module id = 25\n// module chunks = 0","var _config = require(\"./config\");\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar util = require(\"./core/util\");\n\nvar log = require(\"./core/log\");\n\nvar BoundingRect = require(\"./core/BoundingRect\");\n\nvar timsort = require(\"./core/timsort\");\n\nvar Layer = require(\"./Layer\");\n\nvar requestAnimationFrame = require(\"./animation/requestAnimationFrame\");\n\nvar Image = require(\"./graphic/Image\");\n\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n// PENDIGN\n// Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n//\n// Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\nvar MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n\nfunction isLayerValid(layer) {\n  if (!layer) {\n    return false;\n  }\n\n  if (layer.__builtin__) {\n    return true;\n  }\n\n  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction preProcessLayer(layer) {\n  layer.__unusedCount++;\n}\n\nfunction postProcessLayer(layer) {\n  if (layer.__unusedCount == 1) {\n    layer.clear();\n  }\n}\n\nvar tmpRect = new BoundingRect(0, 0, 0, 0);\nvar viewRect = new BoundingRect(0, 0, 0, 0);\n\nfunction isDisplayableCulled(el, width, height) {\n  tmpRect.copy(el.getBoundingRect());\n\n  if (el.transform) {\n    tmpRect.applyTransform(el.transform);\n  }\n\n  viewRect.width = width;\n  viewRect.height = height;\n  return !tmpRect.intersect(viewRect);\n}\n\nfunction isClipPathChanged(clipPaths, prevClipPaths) {\n  if (clipPaths == prevClipPaths) {\n    // Can both be null or undefined\n    return false;\n  }\n\n  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n    return true;\n  }\n\n  for (var i = 0; i < clipPaths.length; i++) {\n    if (clipPaths[i] !== prevClipPaths[i]) {\n      return true;\n    }\n  }\n}\n\nfunction doClip(clipPaths, ctx) {\n  for (var i = 0; i < clipPaths.length; i++) {\n    var clipPath = clipPaths[i];\n    clipPath.setTransform(ctx);\n    ctx.beginPath();\n    clipPath.buildPath(ctx, clipPath.shape);\n    ctx.clip(); // Transform back\n\n    clipPath.restoreTransform(ctx);\n  }\n}\n\nfunction createRoot(width, height) {\n  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n\n  domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';\n  return domRoot;\n}\n/**\n * @alias module:zrender/Painter\n * @constructor\n * @param {HTMLElement} root 绘图容器\n * @param {module:zrender/Storage} storage\n * @param {Object} opts\n */\n\n\nvar Painter = function (root, storage, opts) {\n  this.type = 'canvas'; // In node environment using node-canvas\n\n  var singleCanvas = !root.nodeName // In node ?\n  || root.nodeName.toUpperCase() === 'CANVAS';\n  this._opts = opts = util.extend({}, opts || {});\n  /**\n   * @type {number}\n   */\n\n  this.dpr = opts.devicePixelRatio || devicePixelRatio;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._singleCanvas = singleCanvas;\n  /**\n   * 绘图容器\n   * @type {HTMLElement}\n   */\n\n  this.root = root;\n  var rootStyle = root.style;\n\n  if (rootStyle) {\n    rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n    root.innerHTML = '';\n  }\n  /**\n   * @type {module:zrender/Storage}\n   */\n\n\n  this.storage = storage;\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n\n  var zlevelList = this._zlevelList = [];\n  /**\n   * @type {Object.<string, module:zrender/Layer>}\n   * @private\n   */\n\n  var layers = this._layers = {};\n  /**\n   * @type {Object.<string, Object>}\n   * @type {private}\n   */\n\n  this._layerConfig = {};\n\n  if (!singleCanvas) {\n    this._width = this._getSize(0);\n    this._height = this._getSize(1);\n    var domRoot = this._domRoot = createRoot(this._width, this._height);\n    root.appendChild(domRoot);\n  } else {\n    if (opts.width != null) {\n      root.width = opts.width;\n    }\n\n    if (opts.height != null) {\n      root.height = opts.height;\n    } // Use canvas width and height directly\n\n\n    var width = root.width;\n    var height = root.height;\n    this._width = width;\n    this._height = height; // Create layer if only one given canvas\n    // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\n    var mainLayer = new Layer(root, this, 1);\n    mainLayer.initContext(); // FIXME Use canvas width and height\n    // mainLayer.resize(width, height);\n\n    layers[0] = mainLayer;\n    zlevelList.push(0);\n    this._domRoot = root;\n  } // Layers for progressive rendering\n\n\n  this._progressiveLayers = [];\n  /**\n   * @type {module:zrender/Layer}\n   * @private\n   */\n\n  this._hoverlayer;\n  this._hoverElements = [];\n};\n\nPainter.prototype = {\n  constructor: Painter,\n  getType: function () {\n    return 'canvas';\n  },\n\n  /**\n   * If painter use a single canvas\n   * @return {boolean}\n   */\n  isSingleCanvas: function () {\n    return this._singleCanvas;\n  },\n\n  /**\n   * @return {HTMLDivElement}\n   */\n  getViewportRoot: function () {\n    return this._domRoot;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\n   * 刷新\n   * @param {boolean} [paintAll=false] 强制绘制所有displayable\n   */\n  refresh: function (paintAll) {\n    var list = this.storage.getDisplayList(true);\n    var zlevelList = this._zlevelList;\n\n    this._paintList(list, paintAll); // Paint custum layers\n\n\n    for (var i = 0; i < zlevelList.length; i++) {\n      var z = zlevelList[i];\n      var layer = this._layers[z];\n\n      if (!layer.__builtin__ && layer.refresh) {\n        layer.refresh();\n      }\n    }\n\n    this.refreshHover();\n\n    if (this._progressiveLayers.length) {\n      this._startProgessive();\n    }\n\n    return this;\n  },\n  addHover: function (el, hoverStyle) {\n    if (el.__hoverMir) {\n      return;\n    }\n\n    var elMirror = new el.constructor({\n      style: el.style,\n      shape: el.shape\n    });\n    elMirror.__from = el;\n    el.__hoverMir = elMirror;\n    elMirror.setStyle(hoverStyle);\n\n    this._hoverElements.push(elMirror);\n  },\n  removeHover: function (el) {\n    var elMirror = el.__hoverMir;\n    var hoverElements = this._hoverElements;\n    var idx = util.indexOf(hoverElements, elMirror);\n\n    if (idx >= 0) {\n      hoverElements.splice(idx, 1);\n    }\n\n    el.__hoverMir = null;\n  },\n  clearHover: function (el) {\n    var hoverElements = this._hoverElements;\n\n    for (var i = 0; i < hoverElements.length; i++) {\n      var from = hoverElements[i].__from;\n\n      if (from) {\n        from.__hoverMir = null;\n      }\n    }\n\n    hoverElements.length = 0;\n  },\n  refreshHover: function () {\n    var hoverElements = this._hoverElements;\n    var len = hoverElements.length;\n    var hoverLayer = this._hoverlayer;\n    hoverLayer && hoverLayer.clear();\n\n    if (!len) {\n      return;\n    }\n\n    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel\n    // FIXME?\n\n    if (!hoverLayer) {\n      hoverLayer = this._hoverlayer = this.getLayer(1e5);\n    }\n\n    var scope = {};\n    hoverLayer.ctx.save();\n\n    for (var i = 0; i < len;) {\n      var el = hoverElements[i];\n      var originalEl = el.__from; // Original el is removed\n      // PENDING\n\n      if (!(originalEl && originalEl.__zr)) {\n        hoverElements.splice(i, 1);\n        originalEl.__hoverMir = null;\n        len--;\n        continue;\n      }\n\n      i++; // Use transform\n      // FIXME style and shape ?\n\n      if (!originalEl.invisible) {\n        el.transform = originalEl.transform;\n        el.invTransform = originalEl.invTransform;\n        el.__clipPaths = originalEl.__clipPaths; // el.\n\n        this._doPaintEl(el, hoverLayer, true, scope);\n      }\n    }\n\n    hoverLayer.ctx.restore();\n  },\n  _startProgessive: function () {\n    var self = this;\n\n    if (!self._furtherProgressive) {\n      return;\n    } // Use a token to stop progress steps triggered by\n    // previous zr.refresh calling.\n\n\n    var token = self._progressiveToken = +new Date();\n    self._progress++;\n    requestAnimationFrame(step);\n\n    function step() {\n      // In case refreshed or disposed\n      if (token === self._progressiveToken && self.storage) {\n        self._doPaintList(self.storage.getDisplayList());\n\n        if (self._furtherProgressive) {\n          self._progress++;\n          requestAnimationFrame(step);\n        } else {\n          self._progressiveToken = -1;\n        }\n      }\n    }\n  },\n  _clearProgressive: function () {\n    this._progressiveToken = -1;\n    this._progress = 0;\n    util.each(this._progressiveLayers, function (layer) {\n      layer.__dirty && layer.clear();\n    });\n  },\n  _paintList: function (list, paintAll) {\n    if (paintAll == null) {\n      paintAll = false;\n    }\n\n    this._updateLayerStatus(list);\n\n    this._clearProgressive();\n\n    this.eachBuiltinLayer(preProcessLayer);\n\n    this._doPaintList(list, paintAll);\n\n    this.eachBuiltinLayer(postProcessLayer);\n  },\n  _doPaintList: function (list, paintAll) {\n    var currentLayer;\n    var currentZLevel;\n    var ctx; // var invTransform = [];\n\n    var scope;\n    var progressiveLayerIdx = 0;\n    var currentProgressiveLayer;\n    var width = this._width;\n    var height = this._height;\n    var layerProgress;\n    var frame = this._progress;\n\n    function flushProgressiveLayer(layer) {\n      var dpr = ctx.dpr || 1;\n      ctx.save();\n      ctx.globalAlpha = 1;\n      ctx.shadowBlur = 0; // Avoid layer don't clear in next progressive frame\n\n      currentLayer.__dirty = true;\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n      ctx.restore();\n    }\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      var el = list[i];\n      var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n      var elFrame = el.__frame; // Flush at current context\n      // PENDING\n\n      if (elFrame < 0 && currentProgressiveLayer) {\n        flushProgressiveLayer(currentProgressiveLayer);\n        currentProgressiveLayer = null;\n      } // Change draw layer\n\n\n      if (currentZLevel !== elZLevel) {\n        if (ctx) {\n          ctx.restore();\n        } // Reset scope\n\n\n        scope = {}; // Only 0 zlevel if only has one canvas\n\n        currentZLevel = elZLevel;\n        currentLayer = this.getLayer(currentZLevel);\n\n        if (!currentLayer.__builtin__) {\n          log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);\n        }\n\n        ctx = currentLayer.ctx;\n        ctx.save(); // Reset the count\n\n        currentLayer.__unusedCount = 0;\n\n        if (currentLayer.__dirty || paintAll) {\n          currentLayer.clear();\n        }\n      }\n\n      if (!(currentLayer.__dirty || paintAll)) {\n        continue;\n      }\n\n      if (elFrame >= 0) {\n        // Progressive layer changed\n        if (!currentProgressiveLayer) {\n          currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];\n          currentProgressiveLayer.ctx.save();\n          currentProgressiveLayer.renderScope = {};\n\n          if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {\n            // flushProgressiveLayer(currentProgressiveLayer);\n            // Quick jump all progressive elements\n            // All progressive element are not dirty, jump over and flush directly\n            i = currentProgressiveLayer.__nextIdxNotProg - 1; // currentProgressiveLayer = null;\n\n            continue;\n          }\n\n          layerProgress = currentProgressiveLayer.__progress;\n\n          if (!currentProgressiveLayer.__dirty) {\n            // Keep rendering\n            frame = layerProgress;\n          }\n\n          currentProgressiveLayer.__progress = frame + 1;\n        }\n\n        if (elFrame === frame) {\n          this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n        }\n      } else {\n        this._doPaintEl(el, currentLayer, paintAll, scope);\n      }\n\n      el.__dirty = false;\n    }\n\n    if (currentProgressiveLayer) {\n      flushProgressiveLayer(currentProgressiveLayer);\n    } // Restore the lastLayer ctx\n\n\n    ctx && ctx.restore(); // If still has clipping state\n    // if (scope.prevElClipPaths) {\n    //     ctx.restore();\n    // }\n\n    this._furtherProgressive = false;\n    util.each(this._progressiveLayers, function (layer) {\n      if (layer.__maxProgress >= layer.__progress) {\n        this._furtherProgressive = true;\n      }\n    }, this);\n  },\n  _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n    var ctx = currentLayer.ctx;\n    var m = el.transform;\n\n    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element\n    !el.invisible // Ignore transparent element\n    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas\n    // Draw a scale 0 element can cause all following draw wrong\n    // And setTransform with scale 0 will cause set back transform failed.\n    && !(m && !m[0] && !m[3]) // Ignore culled element\n    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n      var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements\n\n      if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {\n        // If has previous clipping state, restore from it\n        if (scope.prevElClipPaths) {\n          scope.prevClipLayer.ctx.restore();\n          scope.prevClipLayer = scope.prevElClipPaths = null; // Reset prevEl since context has been restored\n\n          scope.prevEl = null;\n        } // New clipping state\n\n\n        if (clipPaths) {\n          ctx.save();\n          doClip(clipPaths, ctx);\n          scope.prevClipLayer = currentLayer;\n          scope.prevElClipPaths = clipPaths;\n        }\n      }\n\n      el.beforeBrush && el.beforeBrush(ctx);\n      el.brush(ctx, scope.prevEl || null);\n      scope.prevEl = el;\n      el.afterBrush && el.afterBrush(ctx);\n    }\n  },\n\n  /**\n   * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n   * @param {number} zlevel\n   * @return {module:zrender/Layer}\n   */\n  getLayer: function (zlevel) {\n    if (this._singleCanvas) {\n      return this._layers[0];\n    }\n\n    var layer = this._layers[zlevel];\n\n    if (!layer) {\n      // Create a new layer\n      layer = new Layer('zr_' + zlevel, this, this.dpr);\n      layer.__builtin__ = true;\n\n      if (this._layerConfig[zlevel]) {\n        util.merge(layer, this._layerConfig[zlevel], true);\n      }\n\n      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document\n      // Or excanvas will get 0px clientWidth and clientHeight\n\n      layer.initContext();\n    }\n\n    return layer;\n  },\n  insertLayer: function (zlevel, layer) {\n    var layersMap = this._layers;\n    var zlevelList = this._zlevelList;\n    var len = zlevelList.length;\n    var prevLayer = null;\n    var i = -1;\n    var domRoot = this._domRoot;\n\n    if (layersMap[zlevel]) {\n      log('ZLevel ' + zlevel + ' has been used already');\n      return;\n    } // Check if is a valid layer\n\n\n    if (!isLayerValid(layer)) {\n      log('Layer of zlevel ' + zlevel + ' is not valid');\n      return;\n    }\n\n    if (len > 0 && zlevel > zlevelList[0]) {\n      for (i = 0; i < len - 1; i++) {\n        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n          break;\n        }\n      }\n\n      prevLayer = layersMap[zlevelList[i]];\n    }\n\n    zlevelList.splice(i + 1, 0, zlevel);\n    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.\n    // (It can be a WebGL layer and assigned to a ZImage element)\n    // But it still under management of zrender.\n\n    if (!layer.virtual) {\n      if (prevLayer) {\n        var prevDom = prevLayer.dom;\n\n        if (prevDom.nextSibling) {\n          domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      } else {\n        if (domRoot.firstChild) {\n          domRoot.insertBefore(layer.dom, domRoot.firstChild);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      }\n    }\n  },\n  // Iterate each layer\n  eachLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      cb.call(context, this._layers[z], z);\n    }\n  },\n  // Iterate each buildin layer\n  eachBuiltinLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n  // Iterate each other layer except buildin layer\n  eachOtherLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (!layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n\n  /**\n   * 获取所有已创建的层\n   * @param {Array.<module:zrender/Layer>} [prevLayer]\n   */\n  getLayers: function () {\n    return this._layers;\n  },\n  _updateLayerStatus: function (list) {\n    var layers = this._layers;\n    var progressiveLayers = this._progressiveLayers;\n    var elCountsLastFrame = {};\n    var progressiveElCountsLastFrame = {};\n    this.eachBuiltinLayer(function (layer, z) {\n      elCountsLastFrame[z] = layer.elCount;\n      layer.elCount = 0;\n      layer.__dirty = false;\n    });\n    util.each(progressiveLayers, function (layer, idx) {\n      progressiveElCountsLastFrame[idx] = layer.elCount;\n      layer.elCount = 0;\n      layer.__dirty = false;\n    });\n    var progressiveLayerCount = 0;\n    var currentProgressiveLayer;\n    var lastProgressiveKey;\n    var frameCount = 0;\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      var el = list[i];\n      var zlevel = this._singleCanvas ? 0 : el.zlevel;\n      var layer = layers[zlevel];\n      var elProgress = el.progressive;\n\n      if (layer) {\n        layer.elCount++;\n        layer.__dirty = layer.__dirty || el.__dirty;\n      } /////// Update progressive\n\n\n      if (elProgress >= 0) {\n        // Fix wrong progressive sequence problem.\n        if (lastProgressiveKey !== elProgress) {\n          lastProgressiveKey = elProgress;\n          frameCount++;\n        }\n\n        var elFrame = el.__frame = frameCount - 1;\n\n        if (!currentProgressiveLayer) {\n          var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n          currentProgressiveLayer = progressiveLayers[idx];\n\n          if (!currentProgressiveLayer) {\n            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);\n            currentProgressiveLayer.initContext();\n          }\n\n          currentProgressiveLayer.__maxProgress = 0;\n        }\n\n        currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n        currentProgressiveLayer.elCount++;\n        currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);\n\n        if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n          // Should keep rendering this  layer because progressive rendering is not finished yet\n          layer.__dirty = true;\n        }\n      } else {\n        el.__frame = -1;\n\n        if (currentProgressiveLayer) {\n          currentProgressiveLayer.__nextIdxNotProg = i;\n          progressiveLayerCount++;\n          currentProgressiveLayer = null;\n        }\n      }\n    }\n\n    if (currentProgressiveLayer) {\n      progressiveLayerCount++;\n      currentProgressiveLayer.__nextIdxNotProg = i;\n    } // 层中的元素数量有发生变化\n\n\n    this.eachBuiltinLayer(function (layer, z) {\n      if (elCountsLastFrame[z] !== layer.elCount) {\n        layer.__dirty = true;\n      }\n    });\n    progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n    util.each(progressiveLayers, function (layer, idx) {\n      if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n        el.__dirty = true;\n      }\n\n      if (layer.__dirty) {\n        layer.__progress = 0;\n      }\n    });\n  },\n\n  /**\n   * 清除hover层外所有内容\n   */\n  clear: function () {\n    this.eachBuiltinLayer(this._clearLayer);\n    return this;\n  },\n  _clearLayer: function (layer) {\n    layer.clear();\n  },\n\n  /**\n   * 修改指定zlevel的绘制参数\n   *\n   * @param {string} zlevel\n   * @param {Object} config 配置对象\n   * @param {string} [config.clearColor=0] 每次清空画布的颜色\n   * @param {string} [config.motionBlur=false] 是否开启动态模糊\n   * @param {number} [config.lastFrameAlpha=0.7]\n   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n   */\n  configLayer: function (zlevel, config) {\n    if (config) {\n      var layerConfig = this._layerConfig;\n\n      if (!layerConfig[zlevel]) {\n        layerConfig[zlevel] = config;\n      } else {\n        util.merge(layerConfig[zlevel], config, true);\n      }\n\n      var layer = this._layers[zlevel];\n\n      if (layer) {\n        util.merge(layer, layerConfig[zlevel], true);\n      }\n    }\n  },\n\n  /**\n   * 删除指定层\n   * @param {number} zlevel 层所在的zlevel\n   */\n  delLayer: function (zlevel) {\n    var layers = this._layers;\n    var zlevelList = this._zlevelList;\n    var layer = layers[zlevel];\n\n    if (!layer) {\n      return;\n    }\n\n    layer.dom.parentNode.removeChild(layer.dom);\n    delete layers[zlevel];\n    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n  },\n\n  /**\n   * 区域大小变化后重绘\n   */\n  resize: function (width, height) {\n    var domRoot = this._domRoot; // FIXME Why ?\n\n    domRoot.style.display = 'none'; // Save input w/h\n\n    var opts = this._opts;\n    width != null && (opts.width = width);\n    height != null && (opts.height = height);\n    width = this._getSize(0);\n    height = this._getSize(1);\n    domRoot.style.display = ''; // 优化没有实际改变的resize\n\n    if (this._width != width || height != this._height) {\n      domRoot.style.width = width + 'px';\n      domRoot.style.height = height + 'px';\n\n      for (var id in this._layers) {\n        if (this._layers.hasOwnProperty(id)) {\n          this._layers[id].resize(width, height);\n        }\n      }\n\n      util.each(this._progressiveLayers, function (layer) {\n        layer.resize(width, height);\n      });\n      this.refresh(true);\n    }\n\n    this._width = width;\n    this._height = height;\n    return this;\n  },\n\n  /**\n   * 清除单独的一个层\n   * @param {number} zlevel\n   */\n  clearLayer: function (zlevel) {\n    var layer = this._layers[zlevel];\n\n    if (layer) {\n      layer.clear();\n    }\n  },\n\n  /**\n   * 释放\n   */\n  dispose: function () {\n    this.root.innerHTML = '';\n    this.root = this.storage = this._domRoot = this._layers = null;\n  },\n\n  /**\n   * Get canvas which has all thing rendered\n   * @param {Object} opts\n   * @param {string} [opts.backgroundColor]\n   * @param {number} [opts.pixelRatio]\n   */\n  getRenderedCanvas: function (opts) {\n    opts = opts || {};\n\n    if (this._singleCanvas) {\n      return this._layers[0].dom;\n    }\n\n    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n    imageLayer.initContext();\n    imageLayer.clearColor = opts.backgroundColor;\n    imageLayer.clear();\n    var displayList = this.storage.getDisplayList(true);\n    var scope = {};\n    var zlevel;\n    var self = this;\n\n    function findAndDrawOtherLayer(smaller, larger) {\n      var zlevelList = self._zlevelList;\n\n      if (smaller == null) {\n        smaller = -Infinity;\n      }\n\n      var intermediateLayer;\n\n      for (var i = 0; i < zlevelList.length; i++) {\n        var z = zlevelList[i];\n        var layer = self._layers[z];\n\n        if (!layer.__builtin__ && z > smaller && z < larger) {\n          intermediateLayer = layer;\n          break;\n        }\n      }\n\n      if (intermediateLayer && intermediateLayer.renderToCanvas) {\n        imageLayer.ctx.save();\n        intermediateLayer.renderToCanvas(imageLayer.ctx);\n        imageLayer.ctx.restore();\n      }\n    }\n\n    for (var i = 0; i < displayList.length; i++) {\n      var el = displayList[i];\n\n      if (el.zlevel !== zlevel) {\n        findAndDrawOtherLayer(zlevel, el.zlevel);\n        zlevel = el.zlevel;\n      }\n\n      this._doPaintEl(el, imageLayer, true, scope);\n    }\n\n    findAndDrawOtherLayer(zlevel, Infinity);\n    return imageLayer.dom;\n  },\n\n  /**\n   * 获取绘图区域宽度\n   */\n  getWidth: function () {\n    return this._width;\n  },\n\n  /**\n   * 获取绘图区域高度\n   */\n  getHeight: function () {\n    return this._height;\n  },\n  _getSize: function (whIdx) {\n    var opts = this._opts;\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n      return parseFloat(opts[wh]);\n    }\n\n    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\n    var stl = document.defaultView.getComputedStyle(root);\n    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n  },\n  pathToImage: function (path, dpr) {\n    dpr = dpr || this.dpr;\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    var rect = path.getBoundingRect();\n    var style = path.style;\n    var shadowBlurSize = style.shadowBlur;\n    var shadowOffsetX = style.shadowOffsetX;\n    var shadowOffsetY = style.shadowOffsetY;\n    var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n    var width = rect.width + leftMargin + rightMargin;\n    var height = rect.height + topMargin + bottomMargin;\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    ctx.scale(dpr, dpr);\n    ctx.clearRect(0, 0, width, height);\n    ctx.dpr = dpr;\n    var pathTransform = {\n      position: path.position,\n      rotation: path.rotation,\n      scale: path.scale\n    };\n    path.position = [leftMargin - rect.x, topMargin - rect.y];\n    path.rotation = 0;\n    path.scale = [1, 1];\n    path.updateTransform();\n\n    if (path) {\n      path.brush(ctx);\n    }\n\n    var ImageShape = Image;\n    var imgShape = new ImageShape({\n      style: {\n        x: 0,\n        y: 0,\n        image: canvas\n      }\n    });\n\n    if (pathTransform.position != null) {\n      imgShape.position = path.position = pathTransform.position;\n    }\n\n    if (pathTransform.rotation != null) {\n      imgShape.rotation = path.rotation = pathTransform.rotation;\n    }\n\n    if (pathTransform.scale != null) {\n      imgShape.scale = path.scale = pathTransform.scale;\n    }\n\n    return imgShape;\n  }\n};\nvar _default = Painter;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Painter.js\n// module id = 26\n// module chunks = 0","var util = require(\"./core/util\");\n\nvar _config = require(\"./config\");\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar Style = require(\"./graphic/Style\");\n\nvar Pattern = require(\"./graphic/Pattern\");\n\n/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\nfunction returnFalse() {\n  return false;\n}\n/**\n * 创建dom\n *\n * @inner\n * @param {string} id dom id 待用\n * @param {Painter} painter painter instance\n * @param {number} number\n */\n\n\nfunction createDom(id, painter, dpr) {\n  var newDom = util.createCanvas();\n  var width = painter.getWidth();\n  var height = painter.getHeight();\n  var newDomStyle = newDom.style; // 没append呢，请原谅我这样写，清晰~\n\n  newDomStyle.position = 'absolute';\n  newDomStyle.left = 0;\n  newDomStyle.top = 0;\n  newDomStyle.width = width + 'px';\n  newDomStyle.height = height + 'px';\n  newDom.width = width * dpr;\n  newDom.height = height * dpr; // id不作为索引用，避免可能造成的重名，定义为私有属性\n\n  newDom.setAttribute('data-zr-dom-id', id);\n  return newDom;\n}\n/**\n * @alias module:zrender/Layer\n * @constructor\n * @extends module:zrender/mixin/Transformable\n * @param {string} id\n * @param {module:zrender/Painter} painter\n * @param {number} [dpr]\n */\n\n\nvar Layer = function (id, painter, dpr) {\n  var dom;\n  dpr = dpr || devicePixelRatio;\n\n  if (typeof id === 'string') {\n    dom = createDom(id, painter, dpr);\n  } // Not using isDom because in node it will return false\n  else if (util.isObject(id)) {\n      dom = id;\n      id = dom.id;\n    }\n\n  this.id = id;\n  this.dom = dom;\n  var domStyle = dom.style;\n\n  if (domStyle) {\n    // Not in node\n    dom.onselectstart = returnFalse; // 避免页面选中的尴尬\n\n    domStyle['-webkit-user-select'] = 'none';\n    domStyle['user-select'] = 'none';\n    domStyle['-webkit-touch-callout'] = 'none';\n    domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n    domStyle['padding'] = 0;\n    domStyle['margin'] = 0;\n    domStyle['border-width'] = 0;\n  }\n\n  this.domBack = null;\n  this.ctxBack = null;\n  this.painter = painter;\n  this.config = null; // Configs\n\n  /**\n   * 每次清空画布的颜色\n   * @type {string}\n   * @default 0\n   */\n\n  this.clearColor = 0;\n  /**\n   * 是否开启动态模糊\n   * @type {boolean}\n   * @default false\n   */\n\n  this.motionBlur = false;\n  /**\n   * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n   * @type {number}\n   * @default 0.7\n   */\n\n  this.lastFrameAlpha = 0.7;\n  /**\n   * Layer dpr\n   * @type {number}\n   */\n\n  this.dpr = dpr;\n};\n\nLayer.prototype = {\n  constructor: Layer,\n  elCount: 0,\n  __dirty: true,\n  initContext: function () {\n    this.ctx = this.dom.getContext('2d');\n    this.ctx.__currentValues = {};\n    this.ctx.dpr = this.dpr;\n  },\n  createBackBuffer: function () {\n    var dpr = this.dpr;\n    this.domBack = createDom('back-' + this.id, this.painter, dpr);\n    this.ctxBack = this.domBack.getContext('2d');\n    this.ctxBack.__currentValues = {};\n\n    if (dpr != 1) {\n      this.ctxBack.scale(dpr, dpr);\n    }\n  },\n\n  /**\n   * @param  {number} width\n   * @param  {number} height\n   */\n  resize: function (width, height) {\n    var dpr = this.dpr;\n    var dom = this.dom;\n    var domStyle = dom.style;\n    var domBack = this.domBack;\n    domStyle.width = width + 'px';\n    domStyle.height = height + 'px';\n    dom.width = width * dpr;\n    dom.height = height * dpr;\n\n    if (domBack) {\n      domBack.width = width * dpr;\n      domBack.height = height * dpr;\n\n      if (dpr != 1) {\n        this.ctxBack.scale(dpr, dpr);\n      }\n    }\n  },\n\n  /**\n   * 清空该层画布\n   * @param {boolean} clearAll Clear all with out motion blur\n   */\n  clear: function (clearAll) {\n    var dom = this.dom;\n    var ctx = this.ctx;\n    var width = dom.width;\n    var height = dom.height;\n    var clearColor = this.clearColor;\n    var haveMotionBLur = this.motionBlur && !clearAll;\n    var lastFrameAlpha = this.lastFrameAlpha;\n    var dpr = this.dpr;\n\n    if (haveMotionBLur) {\n      if (!this.domBack) {\n        this.createBackBuffer();\n      }\n\n      this.ctxBack.globalCompositeOperation = 'copy';\n      this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);\n    }\n\n    ctx.clearRect(0, 0, width, height);\n\n    if (clearColor) {\n      var clearColorGradientOrPattern; // Gradient\n\n      if (clearColor.colorStops) {\n        // Cache canvas gradient\n        clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n          x: 0,\n          y: 0,\n          width: width,\n          height: height\n        });\n        clearColor.__canvasGradient = clearColorGradientOrPattern;\n      } // Pattern\n      else if (clearColor.image) {\n          clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n        }\n\n      ctx.save();\n      ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n      ctx.fillRect(0, 0, width, height);\n      ctx.restore();\n    }\n\n    if (haveMotionBLur) {\n      var domBack = this.domBack;\n      ctx.save();\n      ctx.globalAlpha = lastFrameAlpha;\n      ctx.drawImage(domBack, 0, 0, width, height);\n      ctx.restore();\n    }\n  }\n};\nvar _default = Layer;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Layer.js\n// module id = 27\n// module chunks = 0","var STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\nvar Style = function (opts, host) {\n  this.extendFrom(opts, false);\n  this.host = host;\n};\n\nfunction createLinearGradient(ctx, obj, rect) {\n  var x = obj.x == null ? 0 : obj.x;\n  var x2 = obj.x2 == null ? 1 : obj.x2;\n  var y = obj.y == null ? 0 : obj.y;\n  var y2 = obj.y2 == null ? 0 : obj.y2;\n\n  if (!obj.global) {\n    x = x * rect.width + rect.x;\n    x2 = x2 * rect.width + rect.x;\n    y = y * rect.height + rect.y;\n    y2 = y2 * rect.height + rect.y;\n  }\n\n  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n  return canvasGradient;\n}\n\nfunction createRadialGradient(ctx, obj, rect) {\n  var width = rect.width;\n  var height = rect.height;\n  var min = Math.min(width, height);\n  var x = obj.x == null ? 0.5 : obj.x;\n  var y = obj.y == null ? 0.5 : obj.y;\n  var r = obj.r == null ? 0.5 : obj.r;\n\n  if (!obj.global) {\n    x = x * width + rect.x;\n    y = y * height + rect.y;\n    r = r * min;\n  }\n\n  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n  return canvasGradient;\n}\n\nStyle.prototype = {\n  constructor: Style,\n\n  /**\n   * @type {module:zrender/graphic/Displayable}\n   */\n  host: null,\n\n  /**\n   * @type {string}\n   */\n  fill: '#000',\n\n  /**\n   * @type {string}\n   */\n  stroke: null,\n\n  /**\n   * @type {number}\n   */\n  opacity: 1,\n\n  /**\n   * @type {Array.<number>}\n   */\n  lineDash: null,\n\n  /**\n   * @type {number}\n   */\n  lineDashOffset: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowOffsetY: 0,\n\n  /**\n   * @type {number}\n   */\n  lineWidth: 1,\n\n  /**\n   * If stroke ignore scale\n   * @type {Boolean}\n   */\n  strokeNoScale: false,\n  // Bounding rect text configuration\n  // Not affected by element transform\n\n  /**\n   * @type {string}\n   */\n  text: null,\n\n  /**\n   * If `fontSize` or `fontFamily` exists, `font` will be reset by\n   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.\n   * So do not visit it directly in upper application (like echarts),\n   * but use `contain/text#makeFont` instead.\n   * @type {string}\n   */\n  font: null,\n\n  /**\n   * The same as font. Use font please.\n   * @deprecated\n   * @type {string}\n   */\n  textFont: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontStyle: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontWeight: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * Should be 12 but not '12px'.\n   * @type {number}\n   */\n  fontSize: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontFamily: null,\n\n  /**\n   * Reserved for special functinality, like 'hr'.\n   * @type {string}\n   */\n  textTag: null,\n\n  /**\n   * @type {string}\n   */\n  textFill: '#000',\n\n  /**\n   * @type {string}\n   */\n  textStroke: null,\n\n  /**\n   * @type {number}\n   */\n  textWidth: null,\n\n  /**\n   * Only for textBackground.\n   * @type {number}\n   */\n  textHeight: null,\n\n  /**\n   * textStroke may be set as some color as a default\n   * value in upper applicaion, where the default value\n   * of textStrokeWidth should be 0 to make sure that\n   * user can choose to do not use text stroke.\n   * @type {number}\n   */\n  textStrokeWidth: 0,\n\n  /**\n   * @type {number}\n   */\n  textLineHeight: null,\n\n  /**\n   * 'inside', 'left', 'right', 'top', 'bottom'\n   * [x, y]\n   * Based on x, y of rect.\n   * @type {string|Array.<number>}\n   * @default 'inside'\n   */\n  textPosition: 'inside',\n\n  /**\n   * If not specified, use the boundingRect of a `displayable`.\n   * @type {Object}\n   */\n  textRect: null,\n\n  /**\n   * [x, y]\n   * @type {Array.<number>}\n   */\n  textOffset: null,\n\n  /**\n   * @type {string}\n   */\n  textAlign: null,\n\n  /**\n   * @type {string}\n   */\n  textVerticalAlign: null,\n\n  /**\n   * @type {number}\n   */\n  textDistance: 5,\n\n  /**\n   * @type {string}\n   */\n  textShadowColor: 'transparent',\n\n  /**\n   * @type {number}\n   */\n  textShadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  textShadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  textShadowOffsetY: 0,\n\n  /**\n   * @type {string}\n   */\n  textBoxShadowColor: 'transparent',\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowOffsetY: 0,\n\n  /**\n   * Whether transform text.\n   * Only useful in Path and Image element\n   * @type {boolean}\n   */\n  transformText: false,\n\n  /**\n   * Text rotate around position of Path or Image\n   * Only useful in Path and Image element and transformText is false.\n   */\n  textRotation: 0,\n\n  /**\n   * Text origin of text rotation, like [10, 40].\n   * Based on x, y of rect.\n   * Useful in label rotation of circular symbol.\n   * By default, this origin is textPosition.\n   * Can be 'center'.\n   * @type {string|Array.<number>}\n   */\n  textOrigin: null,\n\n  /**\n   * @type {string}\n   */\n  textBackgroundColor: null,\n\n  /**\n   * @type {string}\n   */\n  textBorderColor: null,\n\n  /**\n   * @type {number}\n   */\n  textBorderWidth: 0,\n\n  /**\n   * @type {number}\n   */\n  textBorderRadius: 0,\n\n  /**\n   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`\n   * @type {number|Array.<number>}\n   */\n  textPadding: null,\n\n  /**\n   * Text styles for rich text.\n   * @type {Object}\n   */\n  rich: null,\n\n  /**\n   * {outerWidth, outerHeight, ellipsis, placeholder}\n   * @type {Object}\n   */\n  truncate: null,\n\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n   * @type {string}\n   */\n  blend: null,\n\n  /**\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  bind: function (ctx, el, prevEl) {\n    var style = this;\n    var prevStyle = prevEl && prevEl.style;\n    var firstDraw = !prevStyle;\n\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n      var prop = STYLE_COMMON_PROPS[i];\n      var styleName = prop[0];\n\n      if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n        // FIXME Invalid property value will cause style leak from previous element.\n        ctx[styleName] = style[styleName] || prop[1];\n      }\n    }\n\n    if (firstDraw || style.fill !== prevStyle.fill) {\n      ctx.fillStyle = style.fill;\n    }\n\n    if (firstDraw || style.stroke !== prevStyle.stroke) {\n      ctx.strokeStyle = style.stroke;\n    }\n\n    if (firstDraw || style.opacity !== prevStyle.opacity) {\n      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n    }\n\n    if (firstDraw || style.blend !== prevStyle.blend) {\n      ctx.globalCompositeOperation = style.blend || 'source-over';\n    }\n\n    if (this.hasStroke()) {\n      var lineWidth = style.lineWidth;\n      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);\n    }\n  },\n  hasFill: function () {\n    var fill = this.fill;\n    return fill != null && fill !== 'none';\n  },\n  hasStroke: function () {\n    var stroke = this.stroke;\n    return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n  },\n\n  /**\n   * Extend from other style\n   * @param {zrender/graphic/Style} otherStyle\n   * @param {boolean} overwrite true: overwrirte any way.\n   *                            false: overwrite only when !target.hasOwnProperty\n   *                            others: overwrite when property is not null/undefined.\n   */\n  extendFrom: function (otherStyle, overwrite) {\n    if (otherStyle) {\n      for (var name in otherStyle) {\n        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {\n          this[name] = otherStyle[name];\n        }\n      }\n    }\n  },\n\n  /**\n   * Batch setting style with a given object\n   * @param {Object|string} obj\n   * @param {*} [obj]\n   */\n  set: function (obj, value) {\n    if (typeof obj === 'string') {\n      this[obj] = value;\n    } else {\n      this.extendFrom(obj, true);\n    }\n  },\n\n  /**\n   * Clone\n   * @return {zrender/graphic/Style} [description]\n   */\n  clone: function () {\n    var newStyle = new this.constructor();\n    newStyle.extendFrom(this, true);\n    return newStyle;\n  },\n  getGradient: function (ctx, obj, rect) {\n    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n    var canvasGradient = method(ctx, obj, rect);\n    var colorStops = obj.colorStops;\n\n    for (var i = 0; i < colorStops.length; i++) {\n      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n    }\n\n    return canvasGradient;\n  }\n};\nvar styleProto = Style.prototype;\n\nfor (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n  var prop = STYLE_COMMON_PROPS[i];\n\n  if (!(prop[0] in styleProto)) {\n    styleProto[prop[0]] = prop[1];\n  }\n} // Provide for others\n\n\nStyle.getGradient = styleProto.getGradient;\nvar _default = Style;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Style.js\n// module id = 28\n// module chunks = 0","var Pattern = function (image, repeat) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {image: ...}`, where this constructor will not be called.\n  this.image = image;\n  this.repeat = repeat; // Can be cloned\n\n  this.type = 'pattern';\n};\n\nPattern.prototype.getCanvasPattern = function (ctx) {\n  return ctx.createPattern(this.image, this.repeat || 'repeat');\n};\n\nvar _default = Pattern;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Pattern.js\n// module id = 29\n// module chunks = 0","var _default = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809\nwindow.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {\n  setTimeout(func, 16);\n};\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/requestAnimationFrame.js\n// module id = 30\n// module chunks = 0","var Displayable = require(\"./Displayable\");\n\nvar BoundingRect = require(\"../core/BoundingRect\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar imageHelper = require(\"./helper/image\");\n\n/**\n * @alias zrender/graphic/Image\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\nfunction ZImage(opts) {\n  Displayable.call(this, opts);\n}\n\nZImage.prototype = {\n  constructor: ZImage,\n  type: 'image',\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var src = style.image; // Must bind each time\n\n    style.bind(ctx, this, prevEl);\n    var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);\n\n    if (!image || !imageHelper.isImageReady(image)) {\n      return;\n    } // 图片已经加载完成\n    // if (image.nodeName.toUpperCase() == 'IMG') {\n    //     if (!image.complete) {\n    //         return;\n    //     }\n    // }\n    // Else is canvas\n\n\n    var x = style.x || 0;\n    var y = style.y || 0;\n    var width = style.width;\n    var height = style.height;\n    var aspect = image.width / image.height;\n\n    if (width == null && height != null) {\n      // Keep image/height ratio\n      width = height * aspect;\n    } else if (height == null && width != null) {\n      height = width / aspect;\n    } else if (width == null && height == null) {\n      width = image.width;\n      height = image.height;\n    } // 设置transform\n\n\n    this.setTransform(ctx);\n\n    if (style.sWidth && style.sHeight) {\n      var sx = style.sx || 0;\n      var sy = style.sy || 0;\n      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n    } else if (style.sx && style.sy) {\n      var sx = style.sx;\n      var sy = style.sy;\n      var sWidth = width - sx;\n      var sHeight = height - sy;\n      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n    } else {\n      ctx.drawImage(image, x, y, width, height);\n    }\n\n    this.restoreTransform(ctx); // Draw rect text\n\n    if (style.text != null) {\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  getBoundingRect: function () {\n    var style = this.style;\n\n    if (!this._rect) {\n      this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);\n    }\n\n    return this._rect;\n  }\n};\nzrUtil.inherits(ZImage, Displayable);\nvar _default = ZImage;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Image.js\n// module id = 31\n// module chunks = 0","var zrUtil = require(\"../core/util\");\n\nvar Style = require(\"./Style\");\n\nvar Element = require(\"../Element\");\n\nvar RectText = require(\"./mixin/RectText\");\n\n/**\n * 可绘制的图形基类\n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n/**\n * @alias module:zrender/graphic/Displayable\n * @extends module:zrender/Element\n * @extends module:zrender/graphic/mixin/RectText\n */\nfunction Displayable(opts) {\n  opts = opts || {};\n  Element.call(this, opts); // Extend properties\n\n  for (var name in opts) {\n    if (opts.hasOwnProperty(name) && name !== 'style') {\n      this[name] = opts[name];\n    }\n  }\n  /**\n   * @type {module:zrender/graphic/Style}\n   */\n\n\n  this.style = new Style(opts.style, this);\n  this._rect = null; // Shapes for cascade clipping.\n\n  this.__clipPaths = []; // FIXME Stateful must be mixined after style is setted\n  // Stateful.call(this, opts);\n}\n\nDisplayable.prototype = {\n  constructor: Displayable,\n  type: 'displayable',\n\n  /**\n   * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制\n   * Dirty flag. From which painter will determine if this displayable object needs brush\n   * @name module:zrender/graphic/Displayable#__dirty\n   * @type {boolean}\n   */\n  __dirty: true,\n\n  /**\n   * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\n   * If ignore drawing of the displayable object. Mouse event will still be triggered\n   * @name module:/zrender/graphic/Displayable#invisible\n   * @type {boolean}\n   * @default false\n   */\n  invisible: false,\n\n  /**\n   * @name module:/zrender/graphic/Displayable#z\n   * @type {number}\n   * @default 0\n   */\n  z: 0,\n\n  /**\n   * @name module:/zrender/graphic/Displayable#z\n   * @type {number}\n   * @default 0\n   */\n  z2: 0,\n\n  /**\n   * z层level，决定绘画在哪层canvas中\n   * @name module:/zrender/graphic/Displayable#zlevel\n   * @type {number}\n   * @default 0\n   */\n  zlevel: 0,\n\n  /**\n   * 是否可拖拽\n   * @name module:/zrender/graphic/Displayable#draggable\n   * @type {boolean}\n   * @default false\n   */\n  draggable: false,\n\n  /**\n   * 是否正在拖拽\n   * @name module:/zrender/graphic/Displayable#draggable\n   * @type {boolean}\n   * @default false\n   */\n  dragging: false,\n\n  /**\n   * 是否相应鼠标事件\n   * @name module:/zrender/graphic/Displayable#silent\n   * @type {boolean}\n   * @default false\n   */\n  silent: false,\n\n  /**\n   * If enable culling\n   * @type {boolean}\n   * @default false\n   */\n  culling: false,\n\n  /**\n   * Mouse cursor when hovered\n   * @name module:/zrender/graphic/Displayable#cursor\n   * @type {string}\n   */\n  cursor: 'pointer',\n\n  /**\n   * If hover area is bounding rect\n   * @name module:/zrender/graphic/Displayable#rectHover\n   * @type {string}\n   */\n  rectHover: false,\n\n  /**\n   * Render the element progressively when the value >= 0,\n   * usefull for large data.\n   * @type {number}\n   */\n  progressive: -1,\n  beforeBrush: function (ctx) {},\n  afterBrush: function (ctx) {},\n\n  /**\n   * 图形绘制方法\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  // Interface\n  brush: function (ctx, prevEl) {},\n\n  /**\n   * 获取最小包围盒\n   * @return {module:zrender/core/BoundingRect}\n   */\n  // Interface\n  getBoundingRect: function () {},\n\n  /**\n   * 判断坐标 x, y 是否在图形上\n   * If displayable element contain coord x, y\n   * @param  {number} x\n   * @param  {number} y\n   * @return {boolean}\n   */\n  contain: function (x, y) {\n    return this.rectContain(x, y);\n  },\n\n  /**\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {\n    cb.call(context, this);\n  },\n\n  /**\n   * 判断坐标 x, y 是否在图形的包围盒上\n   * If bounding rect of element contain coord x, y\n   * @param  {number} x\n   * @param  {number} y\n   * @return {boolean}\n   */\n  rectContain: function (x, y) {\n    var coord = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    return rect.contain(coord[0], coord[1]);\n  },\n\n  /**\n   * 标记图形元素为脏，并且在下一帧重绘\n   * Mark displayable element dirty and refresh next frame\n   */\n  dirty: function () {\n    this.__dirty = true;\n    this._rect = null;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * 图形是否会触发事件\n   * If displayable object binded any event\n   * @return {boolean}\n   */\n  // TODO, 通过 bind 绑定的事件\n  // isSilent: function () {\n  //     return !(\n  //         this.hoverable || this.draggable\n  //         || this.onmousemove || this.onmouseover || this.onmouseout\n  //         || this.onmousedown || this.onmouseup || this.onclick\n  //         || this.ondragenter || this.ondragover || this.ondragleave\n  //         || this.ondrop\n  //     );\n  // },\n\n  /**\n   * Alias for animate('style')\n   * @param {boolean} loop\n   */\n  animateStyle: function (loop) {\n    return this.animate('style', loop);\n  },\n  attrKV: function (key, value) {\n    if (key !== 'style') {\n      Element.prototype.attrKV.call(this, key, value);\n    } else {\n      this.style.set(value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setStyle: function (key, value) {\n    this.style.set(key, value);\n    this.dirty(false);\n    return this;\n  },\n\n  /**\n   * Use given style object\n   * @param  {Object} obj\n   */\n  useStyle: function (obj) {\n    this.style = new Style(obj, this);\n    this.dirty(false);\n    return this;\n  }\n};\nzrUtil.inherits(Displayable, Element);\nzrUtil.mixin(Displayable, RectText); // zrUtil.mixin(Displayable, Stateful);\n\nvar _default = Displayable;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Displayable.js\n// module id = 32\n// module chunks = 0","var textHelper = require(\"../helper/text\");\n\nvar BoundingRect = require(\"../../core/BoundingRect\");\n\n/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\nvar tmpRect = new BoundingRect();\n\nvar RectText = function () {};\n\nRectText.prototype = {\n  constructor: RectText,\n\n  /**\n   * Draw text in a rect with specified position.\n   * @param  {CanvasRenderingContext2D} ctx\n   * @param  {Object} rect Displayable rect\n   */\n  drawRectText: function (ctx, rect) {\n    var style = this.style;\n    rect = style.textRect || rect; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true);\n    var text = style.text; // Convert to string\n\n    text != null && (text += '');\n\n    if (!textHelper.needDrawText(text, style)) {\n      return;\n    } // FIXME\n\n\n    ctx.save(); // Transform rect to view space\n\n    var transform = this.transform;\n\n    if (!style.transformText) {\n      if (transform) {\n        tmpRect.copy(rect);\n        tmpRect.applyTransform(transform);\n        rect = tmpRect;\n      }\n    } else {\n      this.setTransform(ctx);\n    } // transformText and textRotation can not be used at the same time.\n\n\n    textHelper.renderText(this, ctx, text, style, rect);\n    ctx.restore();\n  }\n};\nvar _default = RectText;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/mixin/RectText.js\n// module id = 33\n// module chunks = 0","var _util = require(\"../../core/util\");\n\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar each = _util.each;\nvar normalizeCssArray = _util.normalizeCssArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\n\nvar textContain = require(\"../../contain/text\");\n\nvar roundRectHelper = require(\"./roundRect\");\n\nvar imageHelper = require(\"./image\");\n\n// TODO: Have not support 'start', 'end' yet.\nvar VALID_TEXT_ALIGN = {\n  left: 1,\n  right: 1,\n  center: 1\n};\nvar VALID_TEXT_VERTICAL_ALIGN = {\n  top: 1,\n  bottom: 1,\n  middle: 1\n};\n/**\n * @param {module:zrender/graphic/Style} style\n * @return {module:zrender/graphic/Style} The input style.\n */\n\nfunction normalizeTextStyle(style) {\n  normalizeStyle(style);\n  each(style.rich, normalizeStyle);\n  return style;\n}\n\nfunction normalizeStyle(style) {\n  if (style) {\n    style.font = textContain.makeFont(style);\n    var textAlign = style.textAlign;\n    textAlign === 'middle' && (textAlign = 'center');\n    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.\n\n    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';\n    var textPadding = style.textPadding;\n\n    if (textPadding) {\n      style.textPadding = normalizeCssArray(style.textPadding);\n    }\n  }\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {string} text\n * @param {module:zrender/graphic/Style} style\n * @param {Object|boolean} [rect] {x, y, width, height}\n *                  If set false, rect text is not used.\n */\n\n\nfunction renderText(hostEl, ctx, text, style, rect) {\n  style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);\n}\n\nfunction renderPlainText(hostEl, ctx, text, style, rect) {\n  var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);\n  var textPadding = style.textPadding;\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirty) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, font, textPadding, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var textLines = contentBlock.lines;\n  var lineHeight = contentBlock.lineHeight;\n  var boxPos = getBoxPosition(outerHeight, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY;\n  var needDrawBg = needDrawBackground(style);\n\n  if (needDrawBg || textPadding) {\n    // Consider performance, do not call getTextWidth util necessary.\n    var textWidth = textContain.getWidth(text, font);\n    var outerWidth = textWidth;\n    textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n    if (textPadding) {\n      textX = getTextXForPadding(baseX, textAlign, textPadding);\n      textY += textPadding[0];\n    }\n  }\n\n  setCtx(ctx, 'textAlign', textAlign || 'left'); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle'); // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\n  setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0); // `textBaseline` is set as 'middle'.\n\n  textY += lineHeight / 2;\n  var textStrokeWidth = style.textStrokeWidth;\n  var textStroke = getStroke(style.textStroke, textStrokeWidth);\n  var textFill = getFill(style.textFill);\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n  }\n\n  for (var i = 0; i < textLines.length; i++) {\n    // Fill after stroke so the outline will not cover the main part.\n    textStroke && ctx.strokeText(textLines[i], textX, textY);\n    textFill && ctx.fillText(textLines[i], textX, textY);\n    textY += lineHeight;\n  }\n}\n\nfunction renderRichText(hostEl, ctx, text, style, rect) {\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirty) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n  }\n\n  drawRichText(hostEl, ctx, contentBlock, style, rect);\n}\n\nfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n  var contentWidth = contentBlock.width;\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var textPadding = style.textPadding;\n  var boxPos = getBoxPosition(outerHeight, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var xLeft = boxX;\n  var lineTop = boxY;\n\n  if (textPadding) {\n    xLeft += textPadding[3];\n    lineTop += textPadding[0];\n  }\n\n  var xRight = xLeft + contentWidth;\n  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n  for (var i = 0; i < contentBlock.lines.length; i++) {\n    var line = contentBlock.lines[i];\n    var tokens = line.tokens;\n    var tokenCount = tokens.length;\n    var lineHeight = line.lineHeight;\n    var usedWidth = line.width;\n    var leftIndex = 0;\n    var lineXLeft = xLeft;\n    var lineXRight = xRight;\n    var rightIndex = tokenCount - 1;\n    var token;\n\n    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n      usedWidth -= token.width;\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n      usedWidth -= token.width;\n      lineXRight -= token.width;\n      rightIndex--;\n    } // The other tokens are placed as textAlign 'center' if there is enough space.\n\n\n    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n\n    while (leftIndex <= rightIndex) {\n      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.\n\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    lineTop += lineHeight;\n  }\n}\n\nfunction applyTextRotation(ctx, style, rect, x, y) {\n  // textRotation only apply in RectText.\n  if (rect && style.textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      x = rect.width / 2 + rect.x;\n      y = rect.height / 2 + rect.y;\n    } else if (origin) {\n      x = origin[0] + rect.x;\n      y = origin[1] + rect.y;\n    }\n\n    ctx.translate(x, y); // Positive: anticlockwise\n\n    ctx.rotate(-style.textRotation);\n    ctx.translate(-x, -y);\n  }\n}\n\nfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n  var tokenStyle = style.rich[token.styleName] || {}; // 'ctx.textBaseline' is always set as 'middle', for sake of\n  // the bias of \"Microsoft YaHei\".\n\n  var textVerticalAlign = token.textVerticalAlign;\n  var y = lineTop + lineHeight / 2;\n\n  if (textVerticalAlign === 'top') {\n    y = lineTop + token.height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y = lineTop + lineHeight - token.height / 2;\n  }\n\n  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);\n  var textPadding = token.textPadding;\n\n  if (textPadding) {\n    x = getTextXForPadding(x, textAlign, textPadding);\n    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n  }\n\n  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle');\n  setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);\n  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n  var textFill = getFill(tokenStyle.textFill || style.textFill);\n  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n    ctx.strokeText(token.text, x, y);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n    ctx.fillText(token.text, x, y);\n  }\n}\n\nfunction needDrawBackground(style) {\n  return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;\n} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}\n// shape: {x, y, width, height}\n\n\nfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n  var textBackgroundColor = style.textBackgroundColor;\n  var textBorderWidth = style.textBorderWidth;\n  var textBorderColor = style.textBorderColor;\n  var isPlainBg = isString(textBackgroundColor);\n  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\n  if (isPlainBg || textBorderWidth && textBorderColor) {\n    ctx.beginPath();\n    var textBorderRadius = style.textBorderRadius;\n\n    if (!textBorderRadius) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        r: textBorderRadius\n      });\n    }\n\n    ctx.closePath();\n  }\n\n  if (isPlainBg) {\n    setCtx(ctx, 'fillStyle', textBackgroundColor);\n    ctx.fill();\n  } else if (isObject(textBackgroundColor)) {\n    var image = textBackgroundColor.image;\n    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);\n\n    if (image && imageHelper.isImageReady(image)) {\n      ctx.drawImage(image, x, y, width, height);\n    }\n  }\n\n  if (textBorderWidth && textBorderColor) {\n    setCtx(ctx, 'lineWidth', textBorderWidth);\n    setCtx(ctx, 'strokeStyle', textBorderColor);\n    ctx.stroke();\n  }\n}\n\nfunction onBgImageLoaded(image, textBackgroundColor) {\n  // Replace image, so that `contain/text.js#parseRichText`\n  // will get correct result in next tick.\n  textBackgroundColor.image = image;\n}\n\nfunction getBoxPosition(blockHeiht, style, rect) {\n  var baseX = style.x || 0;\n  var baseY = style.y || 0;\n  var textAlign = style.textAlign;\n  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord\n\n  if (rect) {\n    var textPosition = style.textPosition;\n\n    if (textPosition instanceof Array) {\n      // Percent\n      baseX = rect.x + parsePercent(textPosition[0], rect.width);\n      baseY = rect.y + parsePercent(textPosition[1], rect.height);\n    } else {\n      var res = textContain.adjustTextPositionOnRect(textPosition, rect, style.textDistance);\n      baseX = res.x;\n      baseY = res.y; // Default align and baseline when has textPosition\n\n      textAlign = textAlign || res.textAlign;\n      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n    } // textOffset is only support in RectText, otherwise\n    // we have to adjust boundingRect for textOffset.\n\n\n    var textOffset = style.textOffset;\n\n    if (textOffset) {\n      baseX += textOffset[0];\n      baseY += textOffset[1];\n    }\n  }\n\n  return {\n    baseX: baseX,\n    baseY: baseY,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction setCtx(ctx, prop, value) {\n  // FIXME ??? performance try\n  // if (ctx.__currentValues[prop] !== value) {\n  // ctx[prop] = ctx.__currentValues[prop] = value;\n  ctx[prop] = value; // }\n\n  return ctx[prop];\n}\n/**\n * @param {string} [stroke] If specified, do not check style.textStroke.\n * @param {string} [lineWidth] If specified, do not check style.textStroke.\n * @param {number} style\n */\n\n\nfunction getStroke(stroke, lineWidth) {\n  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?\n  : stroke.image || stroke.colorStops ? '#000' : stroke;\n}\n\nfunction getFill(fill) {\n  return fill == null || fill === 'none' ? null // TODO pattern and gradient?\n  : fill.image || fill.colorStops ? '#000' : fill;\n}\n\nfunction parsePercent(value, maxValue) {\n  if (typeof value === 'string') {\n    if (value.lastIndexOf('%') >= 0) {\n      return parseFloat(value) / 100 * maxValue;\n    }\n\n    return parseFloat(value);\n  }\n\n  return value;\n}\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n/**\n * @param {string} text\n * @param {module:zrender/Style} style\n * @return {boolean}\n */\n\n\nfunction needDrawText(text, style) {\n  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);\n}\n\nexports.normalizeTextStyle = normalizeTextStyle;\nexports.renderText = renderText;\nexports.getStroke = getStroke;\nexports.getFill = getFill;\nexports.needDrawText = needDrawText;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/text.js\n// module id = 34\n// module chunks = 0","var BoundingRect = require(\"../core/BoundingRect\");\n\nvar imageHelper = require(\"../graphic/helper/image\");\n\nvar _util = require(\"../core/util\");\n\nvar getContext = _util.getContext;\nvar extend = _util.extend;\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar textWidthCache = {};\nvar textWidthCacheCounter = 0;\nvar TEXT_CACHE_MAX = 5000;\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {number} width\n */\n\n\nfunction getWidth(text, font) {\n  font = font || DEFAULT_FONT;\n  var key = text + ':' + font;\n\n  if (textWidthCache[key]) {\n    return textWidthCache[key];\n  }\n\n  var textLines = (text + '').split('\\n');\n  var width = 0;\n\n  for (var i = 0, l = textLines.length; i < l; i++) {\n    // textContain.measureText may be overrided in SVG or VML\n    width = Math.max(measureText(textLines[i], font).width, width);\n  }\n\n  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n    textWidthCacheCounter = 0;\n    textWidthCache = {};\n  }\n\n  textWidthCacheCounter++;\n  textWidthCache[key] = width;\n  return width;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {string} [textAlign='left']\n * @param {string} [textVerticalAlign='top']\n * @param {Array.<number>} [textPadding]\n * @param {Object} [rich]\n * @param {Object} [truncate]\n * @return {Object} {x, y, width, height, lineHeight}\n */\n\n\nfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);\n}\n\nfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {\n  var contentBlock = parsePlainText(text, font, textPadding, truncate);\n  var outerWidth = getWidth(text, font);\n\n  if (textPadding) {\n    outerWidth += textPadding[1] + textPadding[3];\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n  rect.lineHeight = contentBlock.lineHeight;\n  return rect;\n}\n\nfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n  var contentBlock = parseRichText(text, {\n    rich: rich,\n    truncate: truncate,\n    font: font,\n    textAlign: textAlign,\n    textPadding: textPadding\n  });\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  return new BoundingRect(x, y, outerWidth, outerHeight);\n}\n/**\n * @public\n * @param {number} x\n * @param {number} width\n * @param {string} [textAlign='left']\n * @return {number} Adjusted x.\n */\n\n\nfunction adjustTextX(x, width, textAlign) {\n  // FIXME Right to left language\n  if (textAlign === 'right') {\n    x -= width;\n  } else if (textAlign === 'center') {\n    x -= width / 2;\n  }\n\n  return x;\n}\n/**\n * @public\n * @param {number} y\n * @param {number} height\n * @param {string} [textVerticalAlign='top']\n * @return {number} Adjusted y.\n */\n\n\nfunction adjustTextY(y, height, textVerticalAlign) {\n  if (textVerticalAlign === 'middle') {\n    y -= height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y -= height;\n  }\n\n  return y;\n}\n/**\n * @public\n * @param {stirng} textPosition\n * @param {Object} rect {x, y, width, height}\n * @param {number} distance\n * @return {Object} {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n  var x = rect.x;\n  var y = rect.y;\n  var height = rect.height;\n  var width = rect.width;\n  var halfHeight = height / 2;\n  var textAlign = 'left';\n  var textVerticalAlign = 'top';\n\n  switch (textPosition) {\n    case 'left':\n      x -= distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'right':\n      x += distance + width;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'top':\n      x += width / 2;\n      y -= distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'bottom':\n      x += width / 2;\n      y += height + distance;\n      textAlign = 'center';\n      break;\n\n    case 'inside':\n      x += width / 2;\n      y += halfHeight;\n      textAlign = 'center';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideLeft':\n      x += distance;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideRight':\n      x += width - distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideTop':\n      x += width / 2;\n      y += distance;\n      textAlign = 'center';\n      break;\n\n    case 'insideBottom':\n      x += width / 2;\n      y += height - distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideTopLeft':\n      x += distance;\n      y += distance;\n      break;\n\n    case 'insideTopRight':\n      x += width - distance;\n      y += distance;\n      textAlign = 'right';\n      break;\n\n    case 'insideBottomLeft':\n      x += distance;\n      y += height - distance;\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideBottomRight':\n      x += width - distance;\n      y += height - distance;\n      textAlign = 'right';\n      textVerticalAlign = 'bottom';\n      break;\n  }\n\n  return {\n    x: x,\n    y: y,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n/**\n * Show ellipsis if overflow.\n *\n * @public\n * @param  {string} text\n * @param  {string} containerWidth\n * @param  {string} font\n * @param  {number} [ellipsis='...']\n * @param  {Object} [options]\n * @param  {number} [options.maxIterations=3]\n * @param  {number} [options.minChar=0] If truncate result are less\n *                  then minChar, ellipsis will not show, which is\n *                  better for user hint in some cases.\n * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n * @return {string}\n */\n\n\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    return '';\n  }\n\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n  // It is not appropriate that every line has '...' when truncate multiple lines.\n\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    textLines[i] = truncateSingleLine(textLines[i], options);\n  }\n\n  return textLines.join('\\n');\n}\n\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = extend({}, options);\n  options.font = font;\n  var ellipsis = retrieve2(ellipsis, '...');\n  options.maxIterations = retrieve2(options.maxIterations, 2);\n  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n  // Other languages?\n\n  options.cnCharWidth = getWidth('国', font); // FIXME\n  // Consider proportional font?\n\n  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\n  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n\n  var ellipsisWidth = getWidth(ellipsis);\n\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n\n  contentWidth = containerWidth - ellipsisWidth;\n  options.ellipsis = ellipsis;\n  options.ellipsisWidth = ellipsisWidth;\n  options.contentWidth = contentWidth;\n  options.containerWidth = containerWidth;\n  return options;\n}\n\nfunction truncateSingleLine(textLine, options) {\n  var containerWidth = options.containerWidth;\n  var font = options.font;\n  var contentWidth = options.contentWidth;\n\n  if (!containerWidth) {\n    return '';\n  }\n\n  var lineWidth = getWidth(textLine, font);\n\n  if (lineWidth <= containerWidth) {\n    return textLine;\n  }\n\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = getWidth(textLine, font);\n  }\n\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n\n  return textLine;\n}\n\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n  var width = 0;\n  var i = 0;\n\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    var charCode = text.charCodeAt(i);\n    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n  }\n\n  return i;\n}\n/**\n * @public\n * @param {string} font\n * @return {number} line height\n */\n\n\nfunction getLineHeight(font) {\n  // FIXME A rough approach.\n  return getWidth('国', font);\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {Object} width\n */\n\n\nfunction measureText(text, font) {\n  return methods.measureText(text, font);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nmethods.measureText = function (text, font) {\n  var ctx = getContext();\n  ctx.font = font || DEFAULT_FONT;\n  return ctx.measureText(text);\n};\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {Object} [truncate]\n * @return {Object} block: {lineHeight, lines, height, outerHeight}\n *  Notice: for performance, do not calculate outerWidth util needed.\n */\n\n\nfunction parsePlainText(text, font, padding, truncate) {\n  text != null && (text += '');\n  var lineHeight = getLineHeight(font);\n  var lines = text ? text.split('\\n') : [];\n  var height = lines.length * lineHeight;\n  var outerHeight = height;\n\n  if (padding) {\n    outerHeight += padding[0] + padding[2];\n  }\n\n  if (text && truncate) {\n    var truncOuterHeight = truncate.outerHeight;\n    var truncOuterWidth = truncate.outerWidth;\n\n    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n      text = '';\n      lines = [];\n    } else if (truncOuterWidth != null) {\n      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n        minChar: truncate.minChar,\n        placeholder: truncate.placeholder\n      }); // FIXME\n      // It is not appropriate that every line has '...' when truncate multiple lines.\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        lines[i] = truncateSingleLine(lines[i], options);\n      }\n    }\n  }\n\n  return {\n    lines: lines,\n    height: height,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight\n  };\n}\n/**\n * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n *\n * @public\n * @param {string} text\n * @param {Object} style\n * @return {Object} block\n * {\n *      width,\n *      height,\n *      lines: [{\n *          lineHeight,\n *          width,\n *          tokens: [[{\n *              styleName,\n *              text,\n *              width,      // include textPadding\n *              height,     // include textPadding\n *              textWidth, // pure text width\n *              textHeight, // pure text height\n *              lineHeihgt,\n *              font,\n *              textAlign,\n *              textVerticalAlign\n *          }], [...], ...]\n *      }, ...]\n * }\n * If styleName is undefined, it is plain text.\n */\n\n\nfunction parseRichText(text, style) {\n  var contentBlock = {\n    lines: [],\n    width: 0,\n    height: 0\n  };\n  text != null && (text += '');\n\n  if (!text) {\n    return contentBlock;\n  }\n\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n    }\n\n    pushTokens(contentBlock, result[2], result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n  }\n\n  var lines = contentBlock.lines;\n  var contentHeight = 0;\n  var contentWidth = 0; // For `textWidth: 100%`\n\n  var pendingList = [];\n  var stlPadding = style.textPadding;\n  var truncate = style.truncate;\n  var truncateWidth = truncate && truncate.outerWidth;\n  var truncateHeight = truncate && truncate.outerHeight;\n\n  if (stlPadding) {\n    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n  } // Calculate layout info of tokens.\n\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\n      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\n      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\n      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n      // as box height of the block.\n      tokenStyle.textHeight, getLineHeight(font));\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n        return {\n          lines: [],\n          width: 0,\n          height: 0\n        };\n      }\n\n      token.textWidth = getWidth(token.text, font);\n      var tokenWidth = tokenStyle.textWidth;\n      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n      // line when box width is needed to be auto.\n\n      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n        token.percentWidth = tokenWidth;\n        pendingList.push(token);\n        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n        // and it is too complicated.\n      } else {\n        if (tokenWidthNotSpecified) {\n          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n          // `getBoundingRect()` will not get correct result.\n\n          var textBackgroundColor = tokenStyle.textBackgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n          // (1) If image is not loaded, it will be loaded at render phase and call\n          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n          // image, and then the right size will be calculated here at the next tick.\n          // See `graphic/helper/text.js`.\n          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n          // use `imageHelper.findExistImage` to find cached image.\n          // `imageHelper.findExistImage` will always be called here before\n          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n          // which ensures that image will not be rendered before correct size calcualted.\n\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n\n            if (imageHelper.isImageReady(bgImg)) {\n              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n\n        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n        tokenWidth += paddingW;\n        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n            token.text = '';\n            token.textWidth = tokenWidth = 0;\n          } else {\n            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n              minChar: truncate.minChar\n            });\n            token.textWidth = getWidth(token.text, font);\n            tokenWidth = token.textWidth + paddingW;\n          }\n        }\n      }\n\n      lineWidth += token.width = tokenWidth;\n      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n    }\n\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    contentHeight += lineHeight;\n    contentWidth = Math.max(contentWidth, lineWidth);\n  }\n\n  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n  if (stlPadding) {\n    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n  }\n\n  for (var i = 0; i < pendingList.length; i++) {\n    var token = pendingList[i];\n    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\n    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n  }\n\n  return contentBlock;\n}\n\nfunction pushTokens(block, str, styleName) {\n  var isEmptyStr = str === '';\n  var strs = str.split('\\n');\n  var lines = block.lines;\n\n  for (var i = 0; i < strs.length; i++) {\n    var text = strs[i];\n    var token = {\n      styleName: styleName,\n      text: text,\n      isLineHolder: !text && !isEmptyStr\n    }; // The first token should be appended to the last line.\n\n    if (!i) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = {\n        tokens: []\n      })).tokens; // Consider cases:\n      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n      // (which is a placeholder) should be replaced by new token.\n      // (2) A image backage, where token likes {a|}.\n      // (3) A redundant '' will affect textAlign in line.\n      // (4) tokens with the same tplName should not be merged, because\n      // they should be displayed in different box (with border and padding).\n\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } // Other tokens always start a new line.\n    else {\n        // If there is '', insert it as a placeholder.\n        lines.push({\n          tokens: [token]\n        });\n      }\n  }\n}\n\nfunction makeFont(style) {\n  // FIXME in node-canvas fontWeight is before fontStyle\n  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n  return (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n  style.fontFamily || 'sans-serif'].join(' ') || style.textFont || style.font;\n}\n\nexports.DEFAULT_FONT = DEFAULT_FONT;\nexports.$override = $override;\nexports.getWidth = getWidth;\nexports.getBoundingRect = getBoundingRect;\nexports.adjustTextX = adjustTextX;\nexports.adjustTextY = adjustTextY;\nexports.adjustTextPositionOnRect = adjustTextPositionOnRect;\nexports.truncateText = truncateText;\nexports.getLineHeight = getLineHeight;\nexports.measureText = measureText;\nexports.parsePlainText = parsePlainText;\nexports.parseRichText = parseRichText;\nexports.makeFont = makeFont;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/text.js\n// module id = 35\n// module chunks = 0","var LRU = require(\"../../core/LRU\");\n\nvar globalImageCache = new LRU(50);\n/**\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n */\n\nfunction findExistImage(newImageOrSrc) {\n  if (typeof newImageOrSrc === 'string') {\n    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n    return cachedImgObj && cachedImgObj.image;\n  } else {\n    return newImageOrSrc;\n  }\n}\n/**\n * Caution: User should cache loaded images, but not just count on LRU.\n * Consider if required images more than LRU size, will dead loop occur?\n *\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.\n * @param {module:zrender/Element} [hostEl] For calling `dirty`.\n * @param {Function} [cb] params: (image, cbPayload)\n * @param {Object} [cbPayload] Payload on cb calling.\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n */\n\n\nfunction createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {\n  if (!newImageOrSrc) {\n    return image;\n  } else if (typeof newImageOrSrc === 'string') {\n    // Image should not be loaded repeatly.\n    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {\n      return image;\n    } // Only when there is no existent image or existent image src\n    // is different, this method is responsible for load.\n\n\n    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n    var pendingWrap = {\n      hostEl: hostEl,\n      cb: cb,\n      cbPayload: cbPayload\n    };\n\n    if (cachedImgObj) {\n      image = cachedImgObj.image;\n      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);\n    } else {\n      !image && (image = new Image());\n      image.onload = imageOnLoad;\n      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {\n        image: image,\n        pending: [pendingWrap]\n      });\n      image.src = image.__zrImageSrc = newImageOrSrc;\n    }\n\n    return image;\n  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas\n  else {\n      return newImageOrSrc;\n    }\n}\n\nfunction imageOnLoad() {\n  var cachedImgObj = this.__cachedImgObj;\n  this.onload = this.__cachedImgObj = null;\n\n  for (var i = 0; i < cachedImgObj.pending.length; i++) {\n    var pendingWrap = cachedImgObj.pending[i];\n    var cb = pendingWrap.cb;\n    cb && cb(this, pendingWrap.cbPayload);\n    pendingWrap.hostEl.dirty();\n  }\n\n  cachedImgObj.pending.length = 0;\n}\n\nfunction isImageReady(image) {\n  return image && image.width && image.height;\n}\n\nexports.findExistImage = findExistImage;\nexports.createOrUpdateImage = createOrUpdateImage;\nexports.isImageReady = isImageReady;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/image.js\n// module id = 36\n// module chunks = 0","function buildPath(ctx, shape) {\n  var x = shape.x;\n  var y = shape.y;\n  var width = shape.width;\n  var height = shape.height;\n  var r = shape.r;\n  var r1;\n  var r2;\n  var r3;\n  var r4; // Convert width and height to positive for better borderRadius\n\n  if (width < 0) {\n    x = x + width;\n    width = -width;\n  }\n\n  if (height < 0) {\n    y = y + height;\n    height = -height;\n  }\n\n  if (typeof r === 'number') {\n    r1 = r2 = r3 = r4 = r;\n  } else if (r instanceof Array) {\n    if (r.length === 1) {\n      r1 = r2 = r3 = r4 = r[0];\n    } else if (r.length === 2) {\n      r1 = r3 = r[0];\n      r2 = r4 = r[1];\n    } else if (r.length === 3) {\n      r1 = r[0];\n      r2 = r4 = r[1];\n      r3 = r[2];\n    } else {\n      r1 = r[0];\n      r2 = r[1];\n      r3 = r[2];\n      r4 = r[3];\n    }\n  } else {\n    r1 = r2 = r3 = r4 = 0;\n  }\n\n  var total;\n\n  if (r1 + r2 > width) {\n    total = r1 + r2;\n    r1 *= width / total;\n    r2 *= width / total;\n  }\n\n  if (r3 + r4 > width) {\n    total = r3 + r4;\n    r3 *= width / total;\n    r4 *= width / total;\n  }\n\n  if (r2 + r3 > height) {\n    total = r2 + r3;\n    r2 *= height / total;\n    r3 *= height / total;\n  }\n\n  if (r1 + r4 > height) {\n    total = r1 + r4;\n    r1 *= height / total;\n    r4 *= height / total;\n  }\n\n  ctx.moveTo(x + r1, y);\n  ctx.lineTo(x + width - r2, y);\n  r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);\n  ctx.lineTo(x + width, y + height - r3);\n  r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);\n  ctx.lineTo(x + r4, y + height);\n  r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);\n  ctx.lineTo(x, y + r1);\n  r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n}\n\nexports.buildPath = buildPath;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/roundRect.js\n// module id = 37\n// module chunks = 0","var util = require(\"../core/util\");\n\nvar _event = require(\"../core/event\");\n\nvar Dispatcher = _event.Dispatcher;\n\nvar requestAnimationFrame = require(\"./requestAnimationFrame\");\n\nvar Animator = require(\"./Animator\");\n\n/**\n * 动画主类, 调度和管理所有动画控制器\n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n/**\n * @typedef {Object} IZRenderStage\n * @property {Function} update\n */\n\n/**\n * @alias module:zrender/animation/Animation\n * @constructor\n * @param {Object} [options]\n * @param {Function} [options.onframe]\n * @param {IZRenderStage} [options.stage]\n * @example\n *     var animation = new Animation();\n *     var obj = {\n *         x: 100,\n *         y: 100\n *     };\n *     animation.animate(node.position)\n *         .when(1000, {\n *             x: 500,\n *             y: 500\n *         })\n *         .when(2000, {\n *             x: 100,\n *             y: 100\n *         })\n *         .start('spline');\n */\nvar Animation = function (options) {\n  options = options || {};\n  this.stage = options.stage || {};\n\n  this.onframe = options.onframe || function () {}; // private properties\n\n\n  this._clips = [];\n  this._running = false;\n  this._time;\n  this._pausedTime;\n  this._pauseStart;\n  this._paused = false;\n  Dispatcher.call(this);\n};\n\nAnimation.prototype = {\n  constructor: Animation,\n\n  /**\n   * 添加 clip\n   * @param {module:zrender/animation/Clip} clip\n   */\n  addClip: function (clip) {\n    this._clips.push(clip);\n  },\n\n  /**\n   * 添加 animator\n   * @param {module:zrender/animation/Animator} animator\n   */\n  addAnimator: function (animator) {\n    animator.animation = this;\n    var clips = animator.getClips();\n\n    for (var i = 0; i < clips.length; i++) {\n      this.addClip(clips[i]);\n    }\n  },\n\n  /**\n   * 删除动画片段\n   * @param {module:zrender/animation/Clip} clip\n   */\n  removeClip: function (clip) {\n    var idx = util.indexOf(this._clips, clip);\n\n    if (idx >= 0) {\n      this._clips.splice(idx, 1);\n    }\n  },\n\n  /**\n   * 删除动画片段\n   * @param {module:zrender/animation/Animator} animator\n   */\n  removeAnimator: function (animator) {\n    var clips = animator.getClips();\n\n    for (var i = 0; i < clips.length; i++) {\n      this.removeClip(clips[i]);\n    }\n\n    animator.animation = null;\n  },\n  _update: function () {\n    var time = new Date().getTime() - this._pausedTime;\n\n    var delta = time - this._time;\n    var clips = this._clips;\n    var len = clips.length;\n    var deferredEvents = [];\n    var deferredClips = [];\n\n    for (var i = 0; i < len; i++) {\n      var clip = clips[i];\n      var e = clip.step(time, delta); // Throw out the events need to be called after\n      // stage.update, like destroy\n\n      if (e) {\n        deferredEvents.push(e);\n        deferredClips.push(clip);\n      }\n    } // Remove the finished clip\n\n\n    for (var i = 0; i < len;) {\n      if (clips[i]._needsRemove) {\n        clips[i] = clips[len - 1];\n        clips.pop();\n        len--;\n      } else {\n        i++;\n      }\n    }\n\n    len = deferredEvents.length;\n\n    for (var i = 0; i < len; i++) {\n      deferredClips[i].fire(deferredEvents[i]);\n    }\n\n    this._time = time;\n    this.onframe(delta);\n    this.trigger('frame', delta);\n\n    if (this.stage.update) {\n      this.stage.update();\n    }\n  },\n  _startLoop: function () {\n    var self = this;\n    this._running = true;\n\n    function step() {\n      if (self._running) {\n        requestAnimationFrame(step);\n        !self._paused && self._update();\n      }\n    }\n\n    requestAnimationFrame(step);\n  },\n\n  /**\n   * 开始运行动画\n   */\n  start: function () {\n    this._time = new Date().getTime();\n    this._pausedTime = 0;\n\n    this._startLoop();\n  },\n\n  /**\n   * 停止运行动画\n   */\n  stop: function () {\n    this._running = false;\n  },\n\n  /**\n   * Pause\n   */\n  pause: function () {\n    if (!this._paused) {\n      this._pauseStart = new Date().getTime();\n      this._paused = true;\n    }\n  },\n\n  /**\n   * Resume\n   */\n  resume: function () {\n    if (this._paused) {\n      this._pausedTime += new Date().getTime() - this._pauseStart;\n      this._paused = false;\n    }\n  },\n\n  /**\n   * 清除所有动画片段\n   */\n  clear: function () {\n    this._clips = [];\n  },\n\n  /**\n   * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画\n   * @param  {Object} target\n   * @param  {Object} options\n   * @param  {boolean} [options.loop=false] 是否循环播放动画\n   * @param  {Function} [options.getter=null]\n   *         如果指定getter函数，会通过getter函数取属性值\n   * @param  {Function} [options.setter=null]\n   *         如果指定setter函数，会通过setter函数设置属性值\n   * @return {module:zrender/animation/Animation~Animator}\n   */\n  // TODO Gap\n  animate: function (target, options) {\n    options = options || {};\n    var animator = new Animator(target, options.loop, options.getter, options.setter);\n    this.addAnimator(animator);\n    return animator;\n  }\n};\nutil.mixin(Animation, Dispatcher);\nvar _default = Animation;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Animation.js\n// module id = 38\n// module chunks = 0","var Eventful = require(\"../mixin/Eventful\");\n\nexports.Dispatcher = Eventful;\n\nvar env = require(\"./env\");\n\n/**\n * 事件辅助类\n * @module zrender/core/event\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n */\nvar isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\nvar MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;\n\nfunction getBoundingClientRect(el) {\n  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n  return el.getBoundingClientRect ? el.getBoundingClientRect() : {\n    left: 0,\n    top: 0\n  };\n} // `calculate` is optional, default false\n\n\nfunction clientToLocal(el, e, out, calculate) {\n  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative\n  // to the padding edge of the target element. The only browser using this convention\n  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n  // not support the properties.\n  // (see http://www.jacklmoore.com/notes/mouse-position/)\n  // In zr painter.dom, padding edge equals to border edge.\n  // FIXME\n  // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n  // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n  // is too complex. So css-transfrom dont support in this case temporarily.\n\n  if (calculate || !env.canvasSupported) {\n    defaultGetZrXY(el, e, out);\n  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n  // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n  // zoom-factor, overflow / opacity layers, transforms ...)\n  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n  // <https://bugs.jquery.com/ticket/8523#comment:14>\n  // BTW3, In ff, offsetX/offsetY is always 0.\n  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n      out.zrX = e.layerX;\n      out.zrY = e.layerY;\n    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n    else if (e.offsetX != null) {\n        out.zrX = e.offsetX;\n        out.zrY = e.offsetY;\n      } // For some other device, e.g., IOS safari.\n      else {\n          defaultGetZrXY(el, e, out);\n        }\n\n  return out;\n}\n\nfunction defaultGetZrXY(el, e, out) {\n  // This well-known method below does not support css transform.\n  var box = getBoundingClientRect(el);\n  out.zrX = e.clientX - box.left;\n  out.zrY = e.clientY - box.top;\n}\n/**\n * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.\n * `calculate` is optional, default false.\n */\n\n\nfunction normalizeEvent(el, e, calculate) {\n  e = e || window.event;\n\n  if (e.zrX != null) {\n    return e;\n  }\n\n  var eventType = e.type;\n  var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n  if (!isTouch) {\n    clientToLocal(el, e, e, calculate);\n    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n  } else {\n    var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n    touch && clientToLocal(el, touch, e, calculate);\n  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;\n  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js\n  // If e.which has been defined, if may be readonly,\n  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which\n\n\n  var button = e.button;\n\n  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {\n    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n  }\n\n  return e;\n}\n\nfunction addEventListener(el, name, handler) {\n  if (isDomLevel2) {\n    el.addEventListener(name, handler);\n  } else {\n    el.attachEvent('on' + name, handler);\n  }\n}\n\nfunction removeEventListener(el, name, handler) {\n  if (isDomLevel2) {\n    el.removeEventListener(name, handler);\n  } else {\n    el.detachEvent('on' + name, handler);\n  }\n}\n/**\n * preventDefault and stopPropagation.\n * Notice: do not do that in zrender. Upper application\n * do that if necessary.\n *\n * @memberOf module:zrender/core/event\n * @method\n * @param {Event} e : event对象\n */\n\n\nvar stop = isDomLevel2 ? function (e) {\n  e.preventDefault();\n  e.stopPropagation();\n  e.cancelBubble = true;\n} : function (e) {\n  e.returnValue = false;\n  e.cancelBubble = true;\n};\n\nfunction notLeftMouse(e) {\n  // If e.which is undefined, considered as left mouse event.\n  return e.which > 1;\n} // 做向上兼容\n\n\nexports.clientToLocal = clientToLocal;\nexports.normalizeEvent = normalizeEvent;\nexports.addEventListener = addEventListener;\nexports.removeEventListener = removeEventListener;\nexports.stop = stop;\nexports.notLeftMouse = notLeftMouse;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/event.js\n// module id = 39\n// module chunks = 0","var _event = require(\"../core/event\");\n\nvar addEventListener = _event.addEventListener;\nvar removeEventListener = _event.removeEventListener;\nvar normalizeEvent = _event.normalizeEvent;\n\nvar zrUtil = require(\"../core/util\");\n\nvar Eventful = require(\"../mixin/Eventful\");\n\nvar env = require(\"../core/env\");\n\nvar GestureMgr = require(\"../core/GestureMgr\");\n\nvar TOUCH_CLICK_DELAY = 300;\nvar mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\nvar touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];\nvar pointerEventNames = {\n  pointerdown: 1,\n  pointerup: 1,\n  pointermove: 1,\n  pointerout: 1\n};\nvar pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n  var nm = name.replace('mouse', 'pointer');\n  return pointerEventNames[nm] ? nm : name;\n});\n\nfunction eventNameFix(name) {\n  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n}\n\nfunction processGesture(proxy, event, stage) {\n  var gestureMgr = proxy._gestureMgr;\n  stage === 'start' && gestureMgr.clear();\n  var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null).target, proxy.dom);\n  stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.\n\n  if (gestureInfo) {\n    var type = gestureInfo.type;\n    event.gestureEvent = type;\n    proxy.handler.dispatchToElement({\n      target: gestureInfo.target\n    }, type, gestureInfo.event);\n  }\n} // function onMSGestureChange(proxy, event) {\n//     if (event.translationX || event.translationY) {\n//         // mousemove is carried by MSGesture to reduce the sensitivity.\n//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n//     }\n//     if (event.scale !== 1) {\n//         event.pinchX = event.offsetX;\n//         event.pinchY = event.offsetY;\n//         event.pinchScale = event.scale;\n//         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n//     }\n// }\n\n/**\n * Prevent mouse event from being dispatched after Touch Events action\n * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n * Result: Blocking Mouse Events for 700ms.\n */\n\n\nfunction setTouchTimer(instance) {\n  instance._touching = true;\n  clearTimeout(instance._touchTimer);\n  instance._touchTimer = setTimeout(function () {\n    instance._touching = false;\n  }, 700);\n}\n\nvar domHandlers = {\n  /**\n   * Mouse move handler\n   * @inner\n   * @param {Event} event\n   */\n  mousemove: function (event) {\n    event = normalizeEvent(this.dom, event);\n    this.trigger('mousemove', event);\n  },\n\n  /**\n   * Mouse out handler\n   * @inner\n   * @param {Event} event\n   */\n  mouseout: function (event) {\n    event = normalizeEvent(this.dom, event);\n    var element = event.toElement || event.relatedTarget;\n\n    if (element != this.dom) {\n      while (element && element.nodeType != 9) {\n        // 忽略包含在root中的dom引起的mouseOut\n        if (element === this.dom) {\n          return;\n        }\n\n        element = element.parentNode;\n      }\n    }\n\n    this.trigger('mouseout', event);\n  },\n\n  /**\n   * Touch开始响应函数\n   * @inner\n   * @param {Event} event\n   */\n  touchstart: function (event) {\n    // Default mouse behaviour should not be disabled here.\n    // For example, page may needs to be slided.\n    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n    // mouse event in upper applicatoin.\n\n    event.zrByTouch = true;\n    this._lastTouchMoment = new Date();\n    processGesture(this, event, 'start'); // In touch device, trigger `mousemove`(`mouseover`) should\n    // be triggered, and must before `mousedown` triggered.\n\n    domHandlers.mousemove.call(this, event);\n    domHandlers.mousedown.call(this, event);\n    setTouchTimer(this);\n  },\n\n  /**\n   * Touch移动响应函数\n   * @inner\n   * @param {Event} event\n   */\n  touchmove: function (event) {\n    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n    // mouse event in upper applicatoin.\n\n    event.zrByTouch = true;\n    processGesture(this, event, 'change'); // Mouse move should always be triggered no matter whether\n    // there is gestrue event, because mouse move and pinch may\n    // be used at the same time.\n\n    domHandlers.mousemove.call(this, event);\n    setTouchTimer(this);\n  },\n\n  /**\n   * Touch结束响应函数\n   * @inner\n   * @param {Event} event\n   */\n  touchend: function (event) {\n    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n    // mouse event in upper applicatoin.\n\n    event.zrByTouch = true;\n    processGesture(this, event, 'end');\n    domHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n    // we can conveniently implement \"hover style\" in both PC and touch device just\n    // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n    // to remove \"hover style\" on an element, without any additional code for\n    // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n    // style\" will remain for user view)\n    // click event should always be triggered no matter whether\n    // there is gestrue event. System click can not be prevented.\n\n    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n      domHandlers.click.call(this, event);\n    }\n\n    setTouchTimer(this);\n  },\n  pointerdown: function (event) {\n    domHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {\n    //     this._msGesture.addPointer(event.pointerId);\n    // }\n  },\n  pointermove: function (event) {\n    // FIXME\n    // pointermove is so sensitive that it always triggered when\n    // tap(click) on touch screen, which affect some judgement in\n    // upper application. So, we dont support mousemove on MS touch\n    // device yet.\n    if (!isPointerFromTouch(event)) {\n      domHandlers.mousemove.call(this, event);\n    }\n  },\n  pointerup: function (event) {\n    domHandlers.mouseup.call(this, event);\n  },\n  pointerout: function (event) {\n    // pointerout will be triggered when tap on touch screen\n    // (IE11+/Edge on MS Surface) after click event triggered,\n    // which is inconsistent with the mousout behavior we defined\n    // in touchend. So we unify them.\n    // (check domHandlers.touchend for detailed explanation)\n    if (!isPointerFromTouch(event)) {\n      domHandlers.mouseout.call(this, event);\n    }\n  }\n};\n\nfunction isPointerFromTouch(event) {\n  var pointerType = event.pointerType;\n  return pointerType === 'pen' || pointerType === 'touch';\n} // function useMSGuesture(handlerProxy, event) {\n//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n// }\n// Common handlers\n\n\nzrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  domHandlers[name] = function (event) {\n    event = normalizeEvent(this.dom, event);\n    this.trigger(name, event);\n  };\n});\n/**\n * 为控制类实例初始化dom 事件处理函数\n *\n * @inner\n * @param {module:zrender/Handler} instance 控制类实例\n */\n\nfunction initDomHandler(instance) {\n  zrUtil.each(touchHandlerNames, function (name) {\n    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n  });\n  zrUtil.each(pointerHandlerNames, function (name) {\n    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n  });\n  zrUtil.each(mouseHandlerNames, function (name) {\n    instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n  });\n\n  function makeMouseHandler(fn, instance) {\n    return function () {\n      if (instance._touching) {\n        return;\n      }\n\n      return fn.apply(instance, arguments);\n    };\n  }\n}\n\nfunction HandlerDomProxy(dom) {\n  Eventful.call(this);\n  this.dom = dom;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._touching = false;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._touchTimer;\n  /**\n   * @private\n   * @type {module:zrender/core/GestureMgr}\n   */\n\n  this._gestureMgr = new GestureMgr();\n  this._handlers = {};\n  initDomHandler(this);\n\n  if (env.pointerEventsSupported) {\n    // Only IE11+/Edge\n    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n    // at the same time.\n    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n    // screen, which do not occurs in pointer event.\n    // So we use pointer event to both detect touch gesture and mouse behavior.\n    mountHandlers(pointerHandlerNames, this); // FIXME\n    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n    // which does not prevent defuault behavior occasionally (which may cause view port\n    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n    // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n    // touch screen. And we only support click behavior on MS touch screen now.\n    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n    // We dont support touch on IE on win7.\n    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n    // if (typeof MSGesture === 'function') {\n    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n    //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n    // }\n  } else {\n    if (env.touchEventsSupported) {\n      mountHandlers(touchHandlerNames, this); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n      // addEventListener(root, 'mouseout', this._mouseoutHandler);\n    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n    // mouse event can not be handle in those devices.\n    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n    // mouseevent after touch event triggered, see `setTouchTimer`.\n\n\n    mountHandlers(mouseHandlerNames, this);\n  }\n\n  function mountHandlers(handlerNames, instance) {\n    zrUtil.each(handlerNames, function (name) {\n      addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n    }, instance);\n  }\n}\n\nvar handlerDomProxyProto = HandlerDomProxy.prototype;\n\nhandlerDomProxyProto.dispose = function () {\n  var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n  for (var i = 0; i < handlerNames.length; i++) {\n    var name = handlerNames[i];\n    removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n  }\n};\n\nhandlerDomProxyProto.setCursor = function (cursorStyle) {\n  this.dom.style.cursor = cursorStyle || 'default';\n};\n\nzrUtil.mixin(HandlerDomProxy, Eventful);\nvar _default = HandlerDomProxy;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/dom/HandlerProxy.js\n// module id = 40\n// module chunks = 0","var eventUtil = require(\"./event\");\n\n/**\n * Only implements needed gestures for mobile.\n */\nvar GestureMgr = function () {\n  /**\n   * @private\n   * @type {Array.<Object>}\n   */\n  this._track = [];\n};\n\nGestureMgr.prototype = {\n  constructor: GestureMgr,\n  recognize: function (event, target, root) {\n    this._doTrack(event, target, root);\n\n    return this._recognize(event);\n  },\n  clear: function () {\n    this._track.length = 0;\n    return this;\n  },\n  _doTrack: function (event, target, root) {\n    var touches = event.touches;\n\n    if (!touches) {\n      return;\n    }\n\n    var trackItem = {\n      points: [],\n      touches: [],\n      target: target,\n      event: event\n    };\n\n    for (var i = 0, len = touches.length; i < len; i++) {\n      var touch = touches[i];\n      var pos = eventUtil.clientToLocal(root, touch, {});\n      trackItem.points.push([pos.zrX, pos.zrY]);\n      trackItem.touches.push(touch);\n    }\n\n    this._track.push(trackItem);\n  },\n  _recognize: function (event) {\n    for (var eventName in recognizers) {\n      if (recognizers.hasOwnProperty(eventName)) {\n        var gestureInfo = recognizers[eventName](this._track, event);\n\n        if (gestureInfo) {\n          return gestureInfo;\n        }\n      }\n    }\n  }\n};\n\nfunction dist(pointPair) {\n  var dx = pointPair[1][0] - pointPair[0][0];\n  var dy = pointPair[1][1] - pointPair[0][1];\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction center(pointPair) {\n  return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];\n}\n\nvar recognizers = {\n  pinch: function (track, event) {\n    var trackLen = track.length;\n\n    if (!trackLen) {\n      return;\n    }\n\n    var pinchEnd = (track[trackLen - 1] || {}).points;\n    var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {\n      var pinchScale = dist(pinchEnd) / dist(pinchPre);\n      !isFinite(pinchScale) && (pinchScale = 1);\n      event.pinchScale = pinchScale;\n      var pinchCenter = center(pinchEnd);\n      event.pinchX = pinchCenter[0];\n      event.pinchY = pinchCenter[1];\n      return {\n        type: 'pinch',\n        target: track[0].target,\n        event: event\n      };\n    }\n  } // Only pinch currently.\n\n};\nvar _default = GestureMgr;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/GestureMgr.js\n// module id = 41\n// module chunks = 0","/**\r\n * BO节点\r\n * 1.BO是一个矩形\r\n * 2.BO有名字\r\n * 3.BO有事件决策[]，双击事件决策弹出详情\r\n * 4.BO有外键属性[]\r\n * 5.BO有子BO\r\n * 6.当前BO特殊颜色显示\r\n * 7.双击BO弹出BO属性以及属性事件决策页面\r\n * @module fish-topo-bo/node/BoNode\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var BoName = require('../node/BoName');\r\n    var EventDecision = require('../node/EventDecisionNode');\r\n    var Line = require('../node/LineNode');\r\n    var BoAttr = require('../node/BoAttrNode');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n    var nodeOptions = null;\r\n\r\n    /**\r\n     *\r\n     * @param {{\r\n     *          id: String BO主键,\r\n     *          name: String BO名字,\r\n     *          boEventArr: [] BO事件决策数组,\r\n     *          boAttrArr: [] BO属性数组\r\n     *          }} boData, bo数据对象\r\n     * @param {{\r\n     *          startPos: {x: number, y: number} 起始位置,\r\n     *          displayAttrDataType: boolean 是否显示属性数据类型,\r\n     *          displayAttrEvent: boolean 是否显示属性事件决策,\r\n     *          boClickable: boolean BO是否支持点击事件, 可空 默认false\r\n     *          boPopupOpts: Object BO弹出页面参数，url,width,height等\r\n     *          boEventClickable: boolean BO事件决策是否支持点击事件, 可空 默认false\r\n     *          boEventPopupOpts: Object BO事件决策弹出页面参数，url,width,height等\r\n     *          bindBoClickEvent: function(options) BO点击事件，返回函数参数为options，它的属性有DATA等\r\n     *          attrEventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false\r\n     *          attrEventPopupOpts: Object 点击BO属性事件决策弹出页面参数，url,width,height等\r\n     *          isCurrent: boolean 是否为当前BO\r\n     *          }} opts\r\n     * @constructor\r\n     */\r\n    function BO(boData, opts) {\r\n        nodeOptions = opts;\r\n\r\n        /**\r\n         * BO数据\r\n         * @type {Object}\r\n         * @private\r\n         */\r\n        this._data = boData;\r\n\r\n        /**\r\n         * 初始坐标，用于最后画BO矩形\r\n         * @type {{x: number, y: number}}\r\n         * @private\r\n         */\r\n        this._oriStartPos = opts.startPos;\r\n\r\n        /**\r\n         * 每个控件的起始参照坐标，每个控件画完之后都会重新计算\r\n         * @type {{x: number, y: number}}\r\n         * @private\r\n         */\r\n        this._nextStartPos = {\r\n            x: opts.startPos.x,\r\n            y: opts.startPos.y\r\n        };\r\n\r\n        /**\r\n         * 是否显示属性数据类型\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._displayAttrDataType = opts.displayAttrDataType || false;\r\n\r\n        /**\r\n         * 是否显示属性事件决策\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._displayAttrEvent = opts.displayAttrEvent || false;\r\n\r\n        //TODO\r\n        if (this._displayAttrEvent) {\r\n            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 3;\r\n        } else if (this._displayAttrDataType) {\r\n            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 1.5;\r\n        }\r\n\r\n        /**\r\n         * 是否支持点击\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._boClickable = opts.boClickable || false;\r\n        this._boPopupOpts = opts.boPopupOpts;\r\n        this._boEventClickable = opts.boEventClickable || false;\r\n        this._boEventPopupOpts = opts.boEventPopupOpts;\r\n        this._attrEventClickable = opts.attrEventClickable || false;\r\n        this._attrEventPopupOpts = opts.attrEventPopupOpts;\r\n\r\n        /**\r\n         * 是否是当前BO，当前BO特殊颜色显示\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._isCurrent = opts.isCurrent || false;\r\n\r\n\r\n        /**\r\n         * BO矩形高度，根据实际内容计算\r\n         * @type {number}\r\n         * @private\r\n         */\r\n        this._boShapeHeight = 0;\r\n\r\n        /**\r\n         * Group容器\r\n         * @type zrender/graphic/Group\r\n         * @private\r\n         */\r\n        this._group = new graphic.Group();\r\n        this._group.name = this._data.id;\r\n        this._group.setCurrent = function (style) {\r\n            //Group最后一个是BO矩形\r\n            var _boShape = this.childAt(this.childCount() - 1);\r\n\r\n            if (style) {\r\n                Object.assign(_boShape.style, style);\r\n            } else {\r\n                //默认效果\r\n                _boShape.style.fill = '#66CC99';\r\n            }\r\n\r\n        };\r\n\r\n        this._render();\r\n    }\r\n\r\n\r\n    var boProto = BO.prototype;\r\n\r\n    /**\r\n     * 获取BO整体图形\r\n     * @returns {zrender/graphic/Group}\r\n     */\r\n    boProto.getShape = function () {\r\n        return this._group;\r\n    };\r\n\r\n    /**\r\n     * 获取数据\r\n     * @returns {Object}\r\n     */\r\n    boProto.getData = function () {\r\n        return this._data;\r\n    };\r\n\r\n    boProto.getLayout = function () {\r\n        return this._data.layout;\r\n    };\r\n\r\n\r\n\r\n    /**\r\n     * 设置当前BO特殊演示显示\r\n     */\r\n    boProto.setCurrent = function () {\r\n        //BO矩形是最后一个图形\r\n        this.childAt(this.childCount - 1).style.fill = '#66CC99'\r\n    };\r\n\r\n    /**\r\n     * 生成BO整体图形\r\n     * @private\r\n     */\r\n    boProto._render = function () {\r\n        //BO名字\r\n        this._createBoName();\r\n\r\n        //BO事件决策\r\n        this._createEventDecision();\r\n\r\n        //BO属性\r\n        this._createBoAttr();\r\n\r\n        //BO矩形\r\n        this._createBoShape();\r\n\r\n        //TODO\r\n        Const.BO_NODE_WIDTH = 180;\r\n    };\r\n\r\n\r\n    /**\r\n     * 生成BO名字文本\r\n     * @private\r\n     */\r\n    boProto._createBoName = function () {\r\n        var _boNameShape = BoName(this._data.name, this._nextStartPos);\r\n\r\n        if (this._boClickable) {\r\n            _boNameShape.clickable = this._boClickable;\r\n            _boNameShape._data = this._data;\r\n            _boNameShape._boPopupOpts = this._boPopupOpts;\r\n            _boNameShape.onclick = this._click;\r\n        }\r\n\r\n        this._group.add(_boNameShape);\r\n        this._calNextShapeStartPos(_boNameShape);\r\n    };\r\n\r\n    /**\r\n     * 生成BO事件决策\r\n     * @private\r\n     */\r\n    boProto._createEventDecision = function () {\r\n\r\n        //如果没有BO事件决策，则返回\r\n        if (!this._data.boEventArr) {\r\n            return;\r\n        }\r\n\r\n        var _boEventArr = this._data.boEventArr,\r\n            _boEventLen = _boEventArr.length,\r\n            _eventShape,\r\n            _eventOpts = {\r\n                startPos: this._nextStartPos,\r\n                clickable: this._boEventClickable,\r\n                popupOpts: this._boEventPopupOpts,\r\n                bindBoClickEvent: nodeOptions.bindBoClickEvent\r\n            };\r\n\r\n        for (var i = 0; i < _boEventLen; i++) {\r\n            _eventShape = new EventDecision(_boEventArr[i], _eventOpts);\r\n            this._group.add(_eventShape.getShape());\r\n            this._calNextShapeStartPos(_eventShape.getShape());\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * 生成BO属性\r\n     * @private\r\n     */\r\n    boProto._createBoAttr = function () {\r\n        //如果没有BO属性，则返回\r\n        if (!this._data.boAttrArr) {\r\n            return;\r\n        }\r\n\r\n        var _boAttrArr = this._data.boAttrArr,\r\n            _boAttrLen = _boAttrArr.length,\r\n            _boAttrShape, _lineShape,\r\n            _attrEventStartPos = {x: this._nextStartPos.x + Const.BO_NODE_WIDTH / 2, y: this._nextStartPos.y};\r\n\r\n        for (var i = 0; i < _boAttrLen; i++) {\r\n            if (i == 0) {\r\n                _lineShape = Line.BoLine(this._nextStartPos); //实线\r\n            }\r\n            else {\r\n                _lineShape = Line.AttrLine(this._nextStartPos);//虚线\r\n            }\r\n\r\n            this._group.add(_lineShape);\r\n\r\n            this._calNextShapeStartPos(_lineShape);\r\n\r\n            _boAttrShape = new BoAttr(_boAttrArr[i],\r\n                {\r\n                    startPos: this._nextStartPos,\r\n                    displayDataType: this._displayAttrDataType,\r\n                    displayEventDecision: this._displayAttrEvent,\r\n                    eventClickable: this._attrEventClickable,\r\n                    eventPopupOpts: this._attrEventPopupOpts,\r\n                    bindBoClickEvent: nodeOptions.bindBoClickEvent\r\n                }\r\n            );\r\n            this._group.add(_boAttrShape.getShape());\r\n            this._calNextShapeStartPos(_boAttrShape.getShape())\r\n        }\r\n\r\n        if (this._displayAttrEvent) {\r\n            _lineShape = Line.AttrEventLine(_attrEventStartPos,\r\n                this._nextStartPos.y - _attrEventStartPos.y\r\n            );\r\n            this._group.add(_lineShape);\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * 计算下一个图形的开始位置，以及BO矩形的高度\r\n     * @param curShape 当前图形\r\n     * @private\r\n     */\r\n    boProto._calNextShapeStartPos = function (curShape) {\r\n        //下一图形起始位置\r\n        this._nextStartPos.y += curShape.getBoundingRect().height;\r\n\r\n        //BO矩形高度增加\r\n        this._boShapeHeight += curShape.getBoundingRect().height;\r\n    };\r\n\r\n\r\n    /**\r\n     * 生成BO矩形\r\n     * @private\r\n     */\r\n    boProto._createBoShape = function () {\r\n        var height = this._boShapeHeight > Const.BO_NODE_DEFAULT_HEIGHT ?\r\n                this._boShapeHeight : Const.BO_NODE_DEFAULT_HEIGHT,\r\n            shape = new graphic.Rect({\r\n                position: [this._oriStartPos.x, this._oriStartPos.y],\r\n\r\n                shape: {\r\n                    r: 5,\r\n                    width: Const.BO_NODE_WIDTH,\r\n                    height: height\r\n                },\r\n\r\n                style: {\r\n                    brushType: 'both',\r\n                    fill: this._isCurrent ? '#66CC99' : 'white',\r\n                    stroke: '#000000',\r\n                    lineWidth: 1,\r\n                    lineCape: 'round'\r\n                },\r\n\r\n                zlevel: -1\r\n            });\r\n\r\n        if (this._boClickable) {\r\n            shape._data = this._data;\r\n            shape._boPopupOpts = this._boPopupOpts;\r\n\r\n            shape.clickable = this._boClickable;\r\n            shape.onclick = this._click;\r\n        }\r\n\r\n        this._group.add(shape);\r\n    };\r\n\r\n    /**\r\n     * 点击事件\r\n     * @private\r\n     */\r\n    boProto._click = function () {\r\n        var options = Object.assign(\r\n            {\r\n                DATA: this._data\r\n            }, this._boPopupOpts);\r\n\r\n        nodeOptions.bindBoClickEvent(options);\r\n    };\r\n\r\n    module.exports = BO;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-bo/lib/node/BoNode.js\n// module id = 42\n// module chunks = 0","/**\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    module.exports = {\r\n        BO_NODE_WIDTH: 180,    //BO矩形宽度\r\n        BO_NODE_DEFAULT_HEIGHT: 60,\t//BO矩形默认高度，即只有BO名字的情况\r\n        BO_NODE_OFFSET_X: 90, //BO矩形的水平偏移量=矩形宽度的一般\r\n        BO_NODE_OFFSET_Y: 50, //BO矩形的垂直偏移量\r\n\r\n        BO_NAME_FONT: 'bold 18px Arial', //'normal 16px verdana',    //BO名字文本样式,\r\n        BO_NAME_PADDING_TOP: 10,   //BO名字与矩形上边框的距离\r\n        BO_NAME_PADDING_BOTTOM: 15,   //BO名字与下一个控件（事件决策或者横线）的距离\r\n\r\n        BO_EVENT_HEIGHT: 20,   //BO事件决策多边形高度\r\n        BO_EVENT_WIDTH: 140,   //BO事件决策多边形宽度\r\n        BO_EVENT_FONT: 'normal 14px Arial',  //BO事件决策名字文本样式\r\n\r\n        BO_ATTR_FONT: 'normal 14px Arial',   //BO属性名字文本样式\r\n        BO_ATTR_PADDING_TOP: 5,   //BO属性名字与矩形上边框的距离\r\n        BO_ATTR_PADDING_BOTTOM: 5,   //BO属性名字与下一个控件（事件决策或者横线）的距离\r\n        BO_ATTR_PADDING_LEFT: 5,   //BO属性名字与矩形左边框的距离\r\n        BO_ATTR_DATA_TYPE_PADDING_RIGHT: 5, //BO属性数据类型与矩形右边框的距离\r\n        BO_ATTR_EVENT_WIDTH: 135,   //BO属性事件决策多边形宽度\r\n\r\n        LINE_DASH: 10,  //虚线\r\n        RELATION_OFFSET: 40,   //关联关系的初始偏移量，即第一段折线宽度\r\n        RELATION_ARROW_WIDTH: 10,  //关联关系三角箭头水平宽度\r\n        RELATION_ARROW_HEIGHT: 5,  //关联关系三角箭头垂直高度的一半\r\n        RELATION_TEXT_OFFSET_X: 10, //关联关系文字说明水平偏移量\r\n        RELATION_TEXT_OFFSET_Y: 5 //关联关系文字说明垂直偏移量\r\n    };\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-bo/lib/models/Const.js\n// module id = 43\n// module chunks = 0","/**\r\n * BO名字\r\n * @module fish-topo-bo/node/BoName\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n\r\n    /**\r\n     *\r\n     * @param {String} text, BO名字\r\n     * @param {{x: number, y: number}} startPos, 起始位置\r\n     * @returns {zrender/graphic/Text}\r\n     * @constructor\r\n     */\r\n    function BoName(text, startPos) {\r\n        var x = startPos.x,\r\n            y = startPos.y + Const.BO_NAME_PADDING_TOP, //文字到矩形上边框的距离 padding-top=10\r\n\r\n            shape = new graphic.Text({\r\n                style: {\r\n                    text: text,\r\n                    textFont: Const.BO_NAME_FONT,\r\n                    textAlign: 'left',  //靠左开始，便于计算位置\r\n                    textBaseline: 'top'\r\n                },\r\n\r\n                position: [x, y]\r\n            });\r\n\r\n        //文字居中显示，重新计算文本水平起始位置 = 矩形水平起始位置 + (BO矩形宽度 - 文本宽度)/2\r\n        shape.position[0] += (Const.BO_NODE_WIDTH - shape.getBoundingRect().width) / 2;\r\n\r\n        //重新设置BO名字图形高度 = 文本高度 + padding-top + padding-bottom\r\n        shape.getBoundingRect().height += Const.BO_NAME_PADDING_TOP + Const.BO_NAME_PADDING_BOTTOM;\r\n\r\n        return shape;\r\n    }\r\n\r\n    module.exports = BoName;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-bo/lib/node/BoName.js\n// module id = 44\n// module chunks = 0","'use strict';\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    var pathTool = require('zrender/lib/tool/path');\r\n    var round = Math.round;\r\n    var Path = require('zrender/lib/graphic/Path');\r\n    var colorTool = require('zrender/lib/tool/color');\r\n    var matrix = require('zrender/lib/core/matrix');\r\n    var vector = require('zrender/lib/core/vector');\r\n    var Gradient = require('zrender/lib/graphic/Gradient');\r\n    var Draggable = require('zrender/lib/mixin/Draggable');\r\n\r\n    var graphic = {};\r\n    graphic.Util = zrUtil;\r\n    graphic.Group = require('zrender/lib/container/Group');\r\n\r\n    graphic.Image = require('zrender/lib/graphic/Image');\r\n\r\n    graphic.Text = require('zrender/lib/graphic/Text');\r\n\r\n    graphic.textContain = require('zrender/lib/contain/text');\r\n\r\n    graphic.Circle = require('zrender/lib/graphic/shape/Circle');\r\n\r\n    graphic.Sector = require('zrender/lib/graphic/shape/Sector');\r\n\r\n    graphic.Ring = require('zrender/lib/graphic/shape/Ring');\r\n\r\n    graphic.Polygon = require('zrender/lib/graphic/shape/Polygon');\r\n\r\n    graphic.Polyline = require('zrender/lib/graphic/shape/Polyline');\r\n\r\n    graphic.Rect = require('zrender/lib/graphic/shape/Rect');\r\n\r\n    graphic.Line = require('zrender/lib/graphic/shape/Line');\r\n\r\n    graphic.BezierCurve = require('zrender/lib/graphic/shape/BezierCurve');\r\n\r\n    graphic.Arc = require('zrender/lib/graphic/shape/Arc');\r\n\r\n    graphic.LinearGradient = require('zrender/lib/graphic/LinearGradient');\r\n\r\n    graphic.RadialGradient = require('zrender/lib/graphic/RadialGradient');\r\n\r\n    graphic.BoundingRect = require('zrender/lib/core/BoundingRect');\r\n    graphic.States = require(\"zrender/lib/graphic/States.js\");\r\n    /**\r\n     * Extend shape with parameters\r\n     */\r\n    graphic.extendShape = function (opts) {\r\n        return Path.extend(opts);\r\n    };\r\n\r\n    /**\r\n     * Extend path\r\n     */\r\n    graphic.extendPath = function (pathData, opts) {\r\n        return pathTool.extendFromString(pathData, opts);\r\n    };\r\n\r\n    /**\r\n     * Create a path element from path data string\r\n     * @param {string} pathData\r\n     * @param {Object} opts\r\n     * @param {module:zrender/core/BoundingRect} rect\r\n     * @param {string} [layout=cover] 'center' or 'cover'\r\n     */\r\n    graphic.makePath = function (pathData, opts, rect, layout) {\r\n        var path = pathTool.createFromString(pathData, opts);\r\n        Draggable.call(path);\r\n        var boundingRect = path.getBoundingRect();\r\n        if (rect) {\r\n            var aspect = boundingRect.width / boundingRect.height;\r\n\r\n            if (layout === 'center') {\r\n                // Set rect to center, keep width / height ratio.\r\n                var width = rect.height * aspect;\r\n                var height;\r\n                if (width <= rect.width) {\r\n                    height = rect.height;\r\n                }\r\n                else {\r\n                    width = rect.width;\r\n                    height = width / aspect;\r\n                }\r\n                var cx = rect.x + rect.width / 2;\r\n                var cy = rect.y + rect.height / 2;\r\n\r\n                rect.x = cx - width / 2;\r\n                rect.y = cy - height / 2;\r\n                rect.width = width;\r\n                rect.height = height;\r\n            }\r\n\r\n            this.resizePath(path, rect);\r\n        }\r\n\r\n        zrUtil.inherits(path, Draggable);\r\n        return path;\r\n    };\r\n\r\n    graphic.mergePath = pathTool.mergePath;\r\n\r\n    /**\r\n     * Resize a path to fit the rect\r\n     * @param {module:zrender/graphic/Path} path\r\n     * @param {Object} rect\r\n     */\r\n    graphic.resizePath = function (path, rect) {\r\n        if (!path.applyTransform) {\r\n            return;\r\n        }\r\n\r\n        var pathRect = path.getBoundingRect();\r\n\r\n        var m = pathRect.calculateTransform(rect);\r\n\r\n        path.applyTransform(m);\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize line for canvas\r\n     *\r\n     * @param {Object} param\r\n     * @param {Object} [param.shape]\r\n     * @param {number} [param.shape.x1]\r\n     * @param {number} [param.shape.y1]\r\n     * @param {number} [param.shape.x2]\r\n     * @param {number} [param.shape.y2]\r\n     * @param {Object} [param.style]\r\n     * @param {number} [param.style.lineWidth]\r\n     * @return {Object} Modified param\r\n     */\r\n    graphic.subPixelOptimizeLine = function (param) {\r\n        var subPixelOptimize = graphic.subPixelOptimize;\r\n        var shape = param.shape;\r\n        var lineWidth = param.style.lineWidth;\r\n\r\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\r\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\r\n        }\r\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\r\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\r\n        }\r\n        return param;\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize rect for canvas\r\n     *\r\n     * @param {Object} param\r\n     * @param {Object} [param.shape]\r\n     * @param {number} [param.shape.x]\r\n     * @param {number} [param.shape.y]\r\n     * @param {number} [param.shape.width]\r\n     * @param {number} [param.shape.height]\r\n     * @param {Object} [param.style]\r\n     * @param {number} [param.style.lineWidth]\r\n     * @return {Object} Modified param\r\n     */\r\n    graphic.subPixelOptimizeRect = function (param) {\r\n        var subPixelOptimize = graphic.subPixelOptimize;\r\n        var shape = param.shape;\r\n        var lineWidth = param.style.lineWidth;\r\n        var originX = shape.x;\r\n        var originY = shape.y;\r\n        var originWidth = shape.width;\r\n        var originHeight = shape.height;\r\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\r\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\r\n        shape.width = Math.max(\r\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\r\n            originWidth === 0 ? 0 : 1\r\n        );\r\n        shape.height = Math.max(\r\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\r\n            originHeight === 0 ? 0 : 1\r\n        );\r\n        return param;\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize for canvas\r\n     *\r\n     * @param {number} position Coordinate, such as x, y\r\n     * @param {number} lineWidth Should be nonnegative integer.\r\n     * @param {boolean=} positiveOrNegative Default false (negative).\r\n     * @return {number} Optimized position.\r\n     */\r\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\r\n        // Assure that (position + lineWidth / 2) is near integer edge,\r\n        // otherwise line will be fuzzy in canvas.\r\n        var doubledPosition = round(position * 2);\r\n        return (doubledPosition + round(lineWidth)) % 2 === 0\r\n            ? doubledPosition / 2\r\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    function doSingleEnterHover(el) {\r\n        if (el.__isHover) {\r\n            return;\r\n        }\r\n        if (el.__hoverStlDirty) {\r\n            var stroke = el.style.stroke;\r\n            var fill = el.style.fill;\r\n\r\n            // Create hoverStyle on mouseover\r\n            var hoverStyle = el.__hoverStl;\r\n            var lift = colorTool.lift;\r\n            hoverStyle.fill = hoverStyle.fill\r\n                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));\r\n            hoverStyle.stroke = hoverStyle.stroke\r\n                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));\r\n\r\n            var normalStyle = {};\r\n            for (var name in hoverStyle) {\r\n                if (hoverStyle.hasOwnProperty(name)) {\r\n                    normalStyle[name] = el.style[name];\r\n                }\r\n            }\r\n\r\n            el.__normalStl = normalStyle;\r\n\r\n            el.__hoverStlDirty = false;\r\n        }\r\n        el.setStyle(el.__hoverStl);\r\n        el.z2 += 1;\r\n\r\n        el.__isHover = true;\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function doSingleLeaveHover(el) {\r\n        if (!el.__isHover) {\r\n            return;\r\n        }\r\n\r\n        var normalStl = el.__normalStl;\r\n        normalStl && el.setStyle(normalStl);\r\n        el.z2 -= 1;\r\n\r\n        el.__isHover = false;\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function doEnterHover(el) {\r\n        (el.type === 'group' || el.type === 'GroupNode')\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    doSingleEnterHover(child);\r\n                }\r\n            })\r\n            : doSingleEnterHover(el);\r\n    }\r\n    graphic.doEnterHover = doEnterHover;\r\n    function doLeaveHover(el) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    doSingleLeaveHover(child);\r\n                }\r\n            })\r\n            : doSingleLeaveHover(el);\r\n    }\r\n    graphic.doLeaveHover = doLeaveHover;\r\n    /**\r\n     * @inner\r\n     */\r\n    function setElementHoverStl(el, hoverStl) {\r\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\r\n        // Often used when item group has a label element and it's hoverStyle is different\r\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\r\n        el.__hoverStlDirty = true;\r\n    }\r\n    graphic.setElementHoverStl = setElementHoverStl;\r\n    /**\r\n     * @inner\r\n     */\r\n    function onElementMouseOver() {\r\n        // Only if element is not in emphasis status\r\n        !this.__isEmphasis && doEnterHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function onElementMouseOut() {\r\n        // Only if element is not in emphasis status\r\n        !this.__isEmphasis && doLeaveHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function enterEmphasis() {\r\n        this.__isEmphasis = true;\r\n        doEnterHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function leaveEmphasis() {\r\n        this.__isEmphasis = false;\r\n        doLeaveHover(this);\r\n    }\r\n\r\n    /**\r\n     * Set hover style of element\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} [hoverStyle]\r\n     */\r\n    graphic.setHoverStyle = function (el, hoverStyle) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    setElementHoverStl(child, hoverStyle);\r\n                }\r\n            })\r\n            : setElementHoverStl(el, hoverStyle);\r\n        // Remove previous bound handlers\r\n        el.on('mouseover', onElementMouseOver)\r\n          .on('mouseout', onElementMouseOut);\r\n\r\n        // Emphasis, normal can be triggered manually\r\n        el.on('emphasis', enterEmphasis)\r\n          .on('normal', leaveEmphasis);\r\n    };\r\n\r\n    graphic.setNormalStyle = function(el, options) {\r\n        if (el.__normalStl) {\r\n            for (var name in options) {\r\n                if (el.__normalStl.hasOwnProperty(name)) {\r\n                    el.__normalStl[name] = options[name];\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Set text option in the style\r\n     * @param {Object} textStyle\r\n     * @param {module:echarts/model/Model} labelModel\r\n     * @param {string} color\r\n     */\r\n    graphic.setText = function (textStyle, labelModel, color) {\r\n        var labelPosition = labelModel.getShallow('position') || 'inside';\r\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\r\n        var textStyleModel = labelModel.getModel('textStyle');\r\n        zrUtil.extend(textStyle, {\r\n            textDistance: labelModel.getShallow('distance') || 5,\r\n            textFont: textStyleModel.getFont(),\r\n            textPosition: labelPosition,\r\n            textFill: textStyleModel.getTextColor() || labelColor\r\n        });\r\n    };\r\n\r\n    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {\r\n        var postfix = isUpdate ? 'Update' : '';\r\n        var duration = animatableModel\r\n            && animatableModel.getShallow('animationDuration' + postfix);\r\n        var animationEasing = animatableModel\r\n            && animatableModel.getShallow('animationEasing' + postfix);\r\n\r\n        animatableModel && animatableModel.getShallow('animation')\r\n            ? el.animateTo(props, duration, animationEasing, cb)\r\n            : (el.attr(props), cb && cb());\r\n    }\r\n    /**\r\n     * Update graphic element properties with or without animation according to the configuration in series\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} props\r\n     * @param {module:echarts/model/Model} [animatableModel]\r\n     * @param {Function} cb\r\n     */\r\n    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);\r\n\r\n    /**\r\n     * Init graphic element properties with or without animation according to the configuration in series\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} props\r\n     * @param {module:echarts/model/Model} [animatableModel]\r\n     * @param {Function} cb\r\n     */\r\n    graphic.initProps = zrUtil.curry(animateOrSetProps, false);\r\n\r\n    /**\r\n     * Get transform matrix of target (param target),\r\n     * in coordinate of its ancestor (param ancestor)\r\n     *\r\n     * @param {module:zrender/mixin/Transformable} target\r\n     * @param {module:zrender/mixin/Transformable} ancestor\r\n     */\r\n    graphic.getTransform = function (target, ancestor) {\r\n        var mat = matrix.identity([]);\r\n\r\n        while (target && target !== ancestor) {\r\n            matrix.mul(mat, target.getLocalTransform(), mat);\r\n            target = target.parent;\r\n        }\r\n\r\n        return mat;\r\n    };\r\n\r\n    /**\r\n     * Apply transform to an vertex.\r\n     * @param {Array.<number>} vertex [x, y]\r\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n     * @param {boolean=} invert Whether use invert matrix.\r\n     * @return {Array.<number>} [x, y]\r\n     */\r\n    graphic.applyTransform = function (vertex, transform, invert) {\r\n        if (invert) {\r\n            transform = matrix.invert([], transform);\r\n        }\r\n        return vector.applyTransform([], vertex, transform);\r\n    };\r\n\r\n    /**\r\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\r\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n     * @param {boolean=} invert Whether use invert matrix.\r\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\r\n     */\r\n    graphic.transformDirection = function (direction, transform, invert) {\r\n\r\n        // Pick a base, ensure that transform result will not be (0, 0).\r\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\r\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\r\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\r\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\r\n\r\n        var vertex = [\r\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\r\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\r\n        ];\r\n\r\n        vertex = graphic.applyTransform(vertex, transform, invert);\r\n\r\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\r\n            ? (vertex[0] > 0 ? 'right' : 'left')\r\n            : (vertex[1] > 0 ? 'bottom' : 'top');\r\n    };\r\n\r\n    module.exports = graphic;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/graphic.js\n// module id = 45\n// module chunks = 0","var Path = require(\"../graphic/Path\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar transformPath = require(\"./transformPath\");\n\n// command chars\nvar cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];\nvar mathSqrt = Math.sqrt;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI = Math.PI;\n\nvar vMag = function (v) {\n  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n};\n\nvar vRatio = function (u, v) {\n  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n};\n\nvar vAngle = function (u, v) {\n  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n};\n\nfunction processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n  var psi = psiDeg * (PI / 180.0);\n  var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;\n  var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;\n  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n\n  if (lambda > 1) {\n    rx *= mathSqrt(lambda);\n    ry *= mathSqrt(lambda);\n  }\n\n  var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;\n  var cxp = f * rx * yp / ry;\n  var cyp = f * -ry * xp / rx;\n  var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;\n  var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;\n  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);\n  var u = [(xp - cxp) / rx, (yp - cyp) / ry];\n  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\n  var dTheta = vAngle(u, v);\n\n  if (vRatio(u, v) <= -1) {\n    dTheta = PI;\n  }\n\n  if (vRatio(u, v) >= 1) {\n    dTheta = 0;\n  }\n\n  if (fs === 0 && dTheta > 0) {\n    dTheta = dTheta - 2 * PI;\n  }\n\n  if (fs === 1 && dTheta < 0) {\n    dTheta = dTheta + 2 * PI;\n  }\n\n  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n}\n\nfunction createPathProxyFromString(data) {\n  if (!data) {\n    return [];\n  } // command string\n\n\n  var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');\n  var n; // create pipes so that we can split the data\n\n  for (n = 0; n < cc.length; n++) {\n    cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n  } // create array\n\n\n  var arr = cs.split('|'); // init context point\n\n  var cpx = 0;\n  var cpy = 0;\n  var path = new PathProxy();\n  var CMD = PathProxy.CMD;\n  var prevCmd;\n\n  for (n = 1; n < arr.length; n++) {\n    var str = arr[n];\n    var c = str.charAt(0);\n    var off = 0;\n    var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n    var cmd;\n\n    if (p.length > 0 && p[0] === '') {\n      p.shift();\n    }\n\n    for (var i = 0; i < p.length; i++) {\n      p[i] = parseFloat(p[i]);\n    }\n\n    while (off < p.length && !isNaN(p[off])) {\n      if (isNaN(p[0])) {\n        break;\n      }\n\n      var ctlPtx;\n      var ctlPty;\n      var rx;\n      var ry;\n      var psi;\n      var fa;\n      var fs;\n      var x1 = cpx;\n      var y1 = cpy; // convert l, H, h, V, and v to L\n\n      switch (c) {\n        case 'l':\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'L':\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'm':\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.M;\n          path.addData(cmd, cpx, cpy);\n          c = 'l';\n          break;\n\n        case 'M':\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.M;\n          path.addData(cmd, cpx, cpy);\n          c = 'L';\n          break;\n\n        case 'h':\n          cpx += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'H':\n          cpx = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'v':\n          cpy += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'V':\n          cpy = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'C':\n          cmd = CMD.C;\n          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);\n          cpx = p[off - 2];\n          cpy = p[off - 1];\n          break;\n\n        case 'c':\n          cmd = CMD.C;\n          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);\n          cpx += p[off - 2];\n          cpy += p[off - 1];\n          break;\n\n        case 'S':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.C) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cmd = CMD.C;\n          x1 = p[off++];\n          y1 = p[off++];\n          cpx = p[off++];\n          cpy = p[off++];\n          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n          break;\n\n        case 's':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.C) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cmd = CMD.C;\n          x1 = cpx + p[off++];\n          y1 = cpy + p[off++];\n          cpx += p[off++];\n          cpy += p[off++];\n          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n          break;\n\n        case 'Q':\n          x1 = p[off++];\n          y1 = p[off++];\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, x1, y1, cpx, cpy);\n          break;\n\n        case 'q':\n          x1 = p[off++] + cpx;\n          y1 = p[off++] + cpy;\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, x1, y1, cpx, cpy);\n          break;\n\n        case 'T':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.Q) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n          break;\n\n        case 't':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.Q) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n          break;\n\n        case 'A':\n          rx = p[off++];\n          ry = p[off++];\n          psi = p[off++];\n          fa = p[off++];\n          fs = p[off++];\n          x1 = cpx, y1 = cpy;\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.A;\n          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n          break;\n\n        case 'a':\n          rx = p[off++];\n          ry = p[off++];\n          psi = p[off++];\n          fa = p[off++];\n          fs = p[off++];\n          x1 = cpx, y1 = cpy;\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.A;\n          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n          break;\n      }\n    }\n\n    if (c === 'z' || c === 'Z') {\n      cmd = CMD.Z;\n      path.addData(cmd);\n    }\n\n    prevCmd = cmd;\n  }\n\n  path.toStatic();\n  return path;\n} // TODO Optimize double memory cost problem\n\n\nfunction createPathOptions(str, opts) {\n  var pathProxy = createPathProxyFromString(str);\n  opts = opts || {};\n\n  opts.buildPath = function (path) {\n    if (path.setData) {\n      path.setData(pathProxy.data); // Svg and vml renderer don't have context\n\n      var ctx = path.getContext();\n\n      if (ctx) {\n        path.rebuildPath(ctx);\n      }\n    } else {\n      var ctx = path;\n      pathProxy.rebuildPath(ctx);\n    }\n  };\n\n  opts.applyTransform = function (m) {\n    transformPath(pathProxy, m);\n    this.dirty(true);\n  };\n\n  return opts;\n}\n/**\n * Create a Path object from path string data\n * http://www.w3.org/TR/SVG/paths.html#PathData\n * @param  {Object} opts Other options\n */\n\n\nfunction createFromString(str, opts) {\n  return new Path(createPathOptions(str, opts));\n}\n/**\n * Create a Path class from path string data\n * @param  {string} str\n * @param  {Object} opts Other options\n */\n\n\nfunction extendFromString(str, opts) {\n  return Path.extend(createPathOptions(str, opts));\n}\n/**\n * Merge multiple paths\n */\n// TODO Apply transform\n// TODO stroke dash\n// TODO Optimize double memory cost problem\n\n\nfunction mergePath(pathEls, opts) {\n  var pathList = [];\n  var len = pathEls.length;\n\n  for (var i = 0; i < len; i++) {\n    var pathEl = pathEls[i];\n\n    if (!pathEl.path) {\n      pathEl.createPathProxy();\n    }\n\n    if (pathEl.__dirtyPath) {\n      pathEl.buildPath(pathEl.path, pathEl.shape, true);\n    }\n\n    pathList.push(pathEl.path);\n  }\n\n  var pathBundle = new Path(opts); // Need path proxy.\n\n  pathBundle.createPathProxy();\n\n  pathBundle.buildPath = function (path) {\n    path.appendPath(pathList); // Svg and vml renderer don't have context\n\n    var ctx = path.getContext();\n\n    if (ctx) {\n      path.rebuildPath(ctx);\n    }\n  };\n\n  return pathBundle;\n}\n\nexports.createFromString = createFromString;\nexports.extendFromString = extendFromString;\nexports.mergePath = mergePath;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/path.js\n// module id = 46\n// module chunks = 0","var Displayable = require(\"./Displayable\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar pathContain = require(\"../contain/path\");\n\nvar Pattern = require(\"./Pattern\");\n\nvar getCanvasPattern = Pattern.prototype.getCanvasPattern;\nvar abs = Math.abs;\nvar pathProxyForDraw = new PathProxy(true);\n/**\n * @alias module:zrender/graphic/Path\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\n\nfunction Path(opts) {\n  Displayable.call(this, opts);\n  /**\n   * @type {module:zrender/core/PathProxy}\n   * @readOnly\n   */\n\n  this.path = null;\n}\n\nPath.prototype = {\n  constructor: Path,\n  type: 'path',\n  __dirtyPath: true,\n  strokeContainThreshold: 5,\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var path = this.path || pathProxyForDraw;\n    var hasStroke = style.hasStroke();\n    var hasFill = style.hasFill();\n    var fill = style.fill;\n    var stroke = style.stroke;\n    var hasFillGradient = hasFill && !!fill.colorStops;\n    var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n    var hasFillPattern = hasFill && !!fill.image;\n    var hasStrokePattern = hasStroke && !!stroke.image;\n    style.bind(ctx, this, prevEl);\n    this.setTransform(ctx);\n\n    if (this.__dirty) {\n      var rect; // Update gradient because bounding rect may changed\n\n      if (hasFillGradient) {\n        rect = rect || this.getBoundingRect();\n        this._fillGradient = style.getGradient(ctx, fill, rect);\n      }\n\n      if (hasStrokeGradient) {\n        rect = rect || this.getBoundingRect();\n        this._strokeGradient = style.getGradient(ctx, stroke, rect);\n      }\n    } // Use the gradient or pattern\n\n\n    if (hasFillGradient) {\n      // PENDING If may have affect the state\n      ctx.fillStyle = this._fillGradient;\n    } else if (hasFillPattern) {\n      ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n    }\n\n    if (hasStrokeGradient) {\n      ctx.strokeStyle = this._strokeGradient;\n    } else if (hasStrokePattern) {\n      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n    }\n\n    var lineDash = style.lineDash;\n    var lineDashOffset = style.lineDashOffset;\n    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy\n\n    var scale = this.getGlobalScale();\n    path.setScale(scale[0], scale[1]); // Proxy context\n    // Rebuild path in following 2 cases\n    // 1. Path is dirty\n    // 2. Path needs javascript implemented lineDash stroking.\n    //    In this case, lineDash information will not be saved in PathProxy\n\n    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n      path.beginPath(ctx); // Setting line dash before build path\n\n      if (lineDash && !ctxLineDash) {\n        path.setLineDash(lineDash);\n        path.setLineDashOffset(lineDashOffset);\n      }\n\n      this.buildPath(path, this.shape, false); // Clear path dirty flag\n\n      if (this.path) {\n        this.__dirtyPath = false;\n      }\n    } else {\n      // Replay path building\n      ctx.beginPath();\n      this.path.rebuildPath(ctx);\n    }\n\n    hasFill && path.fill(ctx);\n\n    if (lineDash && ctxLineDash) {\n      ctx.setLineDash(lineDash);\n      ctx.lineDashOffset = lineDashOffset;\n    }\n\n    hasStroke && path.stroke(ctx);\n\n    if (lineDash && ctxLineDash) {\n      // PENDING\n      // Remove lineDash\n      ctx.setLineDash([]);\n    }\n\n    this.restoreTransform(ctx); // Draw rect text\n\n    if (style.text != null) {\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n  // Like in circle\n  buildPath: function (ctx, shapeCfg, inBundle) {},\n  createPathProxy: function () {\n    this.path = new PathProxy();\n  },\n  getBoundingRect: function () {\n    var rect = this._rect;\n    var style = this.style;\n    var needsUpdateRect = !rect;\n\n    if (needsUpdateRect) {\n      var path = this.path;\n\n      if (!path) {\n        // Create path on demand.\n        path = this.path = new PathProxy();\n      }\n\n      if (this.__dirtyPath) {\n        path.beginPath();\n        this.buildPath(path, this.shape, false);\n      }\n\n      rect = path.getBoundingRect();\n    }\n\n    this._rect = rect;\n\n    if (style.hasStroke()) {\n      // Needs update rect with stroke lineWidth when\n      // 1. Element changes scale or lineWidth\n      // 2. Shape is changed\n      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\n      if (this.__dirty || needsUpdateRect) {\n        rectWithStroke.copy(rect); // FIXME Must after updateTransform\n\n        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical\n\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill\n\n        if (!style.hasFill()) {\n          w = Math.max(w, this.strokeContainThreshold || 4);\n        } // Consider line width\n        // Line scale can't be 0;\n\n\n        if (lineScale > 1e-10) {\n          rectWithStroke.width += w / lineScale;\n          rectWithStroke.height += w / lineScale;\n          rectWithStroke.x -= w / lineScale / 2;\n          rectWithStroke.y -= w / lineScale / 2;\n        }\n      } // Return rect with stroke\n\n\n      return rectWithStroke;\n    }\n\n    return rect;\n  },\n  contain: function (x, y) {\n    var localPos = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    var style = this.style;\n    x = localPos[0];\n    y = localPos[1];\n\n    if (rect.contain(x, y)) {\n      var pathData = this.path.data;\n\n      if (style.hasStroke()) {\n        var lineWidth = style.lineWidth;\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;\n\n        if (lineScale > 1e-10) {\n          // Only add extra hover lineWidth when there are no fill\n          if (!style.hasFill()) {\n            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n          }\n\n          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n            return true;\n          }\n        }\n      }\n\n      if (style.hasFill()) {\n        return pathContain.contain(pathData, x, y);\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * @param  {boolean} dirtyPath\n   */\n  dirty: function (dirtyPath) {\n    if (dirtyPath == null) {\n      dirtyPath = true;\n    } // Only mark dirty, not mark clean\n\n\n    if (dirtyPath) {\n      this.__dirtyPath = dirtyPath;\n      this._rect = null;\n    }\n\n    this.__dirty = true;\n    this.__zr && this.__zr.refresh(); // Used as a clipping path\n\n    if (this.__clipTarget) {\n      this.__clipTarget.dirty();\n    }\n  },\n\n  /**\n   * Alias for animate('shape')\n   * @param {boolean} loop\n   */\n  animateShape: function (loop) {\n    return this.animate('shape', loop);\n  },\n  // Overwrite attrKV\n  attrKV: function (key, value) {\n    // FIXME\n    if (key === 'shape') {\n      this.setShape(value);\n      this.__dirtyPath = true;\n      this._rect = null;\n    } else {\n      Displayable.prototype.attrKV.call(this, key, value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setShape: function (key, value) {\n    var shape = this.shape; // Path from string may not have shape\n\n    if (shape) {\n      if (zrUtil.isObject(key)) {\n        for (var name in key) {\n          if (key.hasOwnProperty(name)) {\n            shape[name] = key[name];\n          }\n        }\n      } else {\n        shape[key] = value;\n      }\n\n      this.dirty(true);\n    }\n\n    return this;\n  },\n  getLineScale: function () {\n    var m = this.transform; // Get the line scale.\n    // Determinant of `m` means how much the area is enlarged by the\n    // transformation. So its square root can be used as a scale factor\n    // for width.\n\n    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n  }\n};\n/**\n * 扩展一个 Path element, 比如星形，圆等。\n * Extend a path element\n * @param {Object} props\n * @param {string} props.type Path type\n * @param {Function} props.init Initialize\n * @param {Function} props.buildPath Overwrite buildPath method\n * @param {Object} [props.style] Extended default style config\n * @param {Object} [props.shape] Extended default shape config\n */\n\nPath.extend = function (defaults) {\n  var Sub = function (opts) {\n    Path.call(this, opts);\n\n    if (defaults.style) {\n      // Extend default style\n      this.style.extendFrom(defaults.style, false);\n    } // Extend default shape\n\n\n    var defaultShape = defaults.shape;\n\n    if (defaultShape) {\n      this.shape = this.shape || {};\n      var thisShape = this.shape;\n\n      for (var name in defaultShape) {\n        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n          thisShape[name] = defaultShape[name];\n        }\n      }\n    }\n\n    defaults.init && defaults.init.call(this, opts);\n  };\n\n  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象\n\n  for (var name in defaults) {\n    // Extending prototype values and methods\n    if (name !== 'style' && name !== 'shape') {\n      Sub.prototype[name] = defaults[name];\n    }\n  }\n\n  return Sub;\n};\n\nzrUtil.inherits(Path, Displayable);\nvar _default = Path;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Path.js\n// module id = 47\n// module chunks = 0","var curve = require(\"./curve\");\n\nvar vec2 = require(\"./vector\");\n\nvar bbox = require(\"./bbox\");\n\nvar BoundingRect = require(\"./BoundingRect\");\n\nvar _config = require(\"../config\");\n\nvar dpr = _config.devicePixelRatio;\n\n/**\n * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n * 可以用于 isInsidePath 判断以及获取boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n// TODO getTotalLength, getPointAtLength\nvar CMD = {\n  M: 1,\n  L: 2,\n  C: 3,\n  Q: 4,\n  A: 5,\n  Z: 6,\n  // Rect\n  R: 7\n}; // var CMD_MEM_SIZE = {\n//     M: 3,\n//     L: 3,\n//     C: 7,\n//     Q: 5,\n//     A: 9,\n//     R: 5,\n//     Z: 1\n// };\n\nvar min = [];\nvar max = [];\nvar min2 = [];\nvar max2 = [];\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathCos = Math.cos;\nvar mathSin = Math.sin;\nvar mathSqrt = Math.sqrt;\nvar mathAbs = Math.abs;\nvar hasTypedArray = typeof Float32Array != 'undefined';\n/**\n * @alias module:zrender/core/PathProxy\n * @constructor\n */\n\nvar PathProxy = function (notSaveData) {\n  this._saveData = !(notSaveData || false);\n\n  if (this._saveData) {\n    /**\n     * Path data. Stored as flat array\n     * @type {Array.<Object>}\n     */\n    this.data = [];\n  }\n\n  this._ctx = null;\n};\n/**\n * 快速计算Path包围盒（并不是最小包围盒）\n * @return {Object}\n */\n\n\nPathProxy.prototype = {\n  constructor: PathProxy,\n  _xi: 0,\n  _yi: 0,\n  _x0: 0,\n  _y0: 0,\n  // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n  _ux: 0,\n  _uy: 0,\n  _len: 0,\n  _lineDash: null,\n  _dashOffset: 0,\n  _dashIdx: 0,\n  _dashSum: 0,\n\n  /**\n   * @readOnly\n   */\n  setScale: function (sx, sy) {\n    this._ux = mathAbs(1 / dpr / sx) || 0;\n    this._uy = mathAbs(1 / dpr / sy) || 0;\n  },\n  getContext: function () {\n    return this._ctx;\n  },\n\n  /**\n   * @param  {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  beginPath: function (ctx) {\n    this._ctx = ctx;\n    ctx && ctx.beginPath();\n    ctx && (this.dpr = ctx.dpr); // Reset\n\n    if (this._saveData) {\n      this._len = 0;\n    }\n\n    if (this._lineDash) {\n      this._lineDash = null;\n      this._dashOffset = 0;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param  {number} x\n   * @param  {number} y\n   * @return {module:zrender/core/PathProxy}\n   */\n  moveTo: function (x, y) {\n    this.addData(CMD.M, x, y);\n    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n    // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n    // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n    // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n\n    this._x0 = x;\n    this._y0 = y;\n    this._xi = x;\n    this._yi = y;\n    return this;\n  },\n\n  /**\n   * @param  {number} x\n   * @param  {number} y\n   * @return {module:zrender/core/PathProxy}\n   */\n  lineTo: function (x, y) {\n    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment\n    || this._len < 5;\n    this.addData(CMD.L, x, y);\n\n    if (this._ctx && exceedUnit) {\n      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n    }\n\n    if (exceedUnit) {\n      this._xi = x;\n      this._yi = y;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param  {number} x1\n   * @param  {number} y1\n   * @param  {number} x2\n   * @param  {number} y2\n   * @param  {number} x3\n   * @param  {number} y3\n   * @return {module:zrender/core/PathProxy}\n   */\n  bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\n    if (this._ctx) {\n      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n    }\n\n    this._xi = x3;\n    this._yi = y3;\n    return this;\n  },\n\n  /**\n   * @param  {number} x1\n   * @param  {number} y1\n   * @param  {number} x2\n   * @param  {number} y2\n   * @return {module:zrender/core/PathProxy}\n   */\n  quadraticCurveTo: function (x1, y1, x2, y2) {\n    this.addData(CMD.Q, x1, y1, x2, y2);\n\n    if (this._ctx) {\n      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n    }\n\n    this._xi = x2;\n    this._yi = y2;\n    return this;\n  },\n\n  /**\n   * @param  {number} cx\n   * @param  {number} cy\n   * @param  {number} r\n   * @param  {number} startAngle\n   * @param  {number} endAngle\n   * @param  {boolean} anticlockwise\n   * @return {module:zrender/core/PathProxy}\n   */\n  arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);\n    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n    this._xi = mathCos(endAngle) * r + cx;\n    this._yi = mathSin(endAngle) * r + cx;\n    return this;\n  },\n  // TODO\n  arcTo: function (x1, y1, x2, y2, radius) {\n    if (this._ctx) {\n      this._ctx.arcTo(x1, y1, x2, y2, radius);\n    }\n\n    return this;\n  },\n  // TODO\n  rect: function (x, y, w, h) {\n    this._ctx && this._ctx.rect(x, y, w, h);\n    this.addData(CMD.R, x, y, w, h);\n    return this;\n  },\n\n  /**\n   * @return {module:zrender/core/PathProxy}\n   */\n  closePath: function () {\n    this.addData(CMD.Z);\n    var ctx = this._ctx;\n    var x0 = this._x0;\n    var y0 = this._y0;\n\n    if (ctx) {\n      this._needsDash() && this._dashedLineTo(x0, y0);\n      ctx.closePath();\n    }\n\n    this._xi = x0;\n    this._yi = y0;\n    return this;\n  },\n\n  /**\n   * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n   * stroke 同样\n   * @param {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  fill: function (ctx) {\n    ctx && ctx.fill();\n    this.toStatic();\n  },\n\n  /**\n   * @param {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  stroke: function (ctx) {\n    ctx && ctx.stroke();\n    this.toStatic();\n  },\n\n  /**\n   * 必须在其它绘制命令前调用\n   * Must be invoked before all other path drawing methods\n   * @return {module:zrender/core/PathProxy}\n   */\n  setLineDash: function (lineDash) {\n    if (lineDash instanceof Array) {\n      this._lineDash = lineDash;\n      this._dashIdx = 0;\n      var lineDashSum = 0;\n\n      for (var i = 0; i < lineDash.length; i++) {\n        lineDashSum += lineDash[i];\n      }\n\n      this._dashSum = lineDashSum;\n    }\n\n    return this;\n  },\n\n  /**\n   * 必须在其它绘制命令前调用\n   * Must be invoked before all other path drawing methods\n   * @return {module:zrender/core/PathProxy}\n   */\n  setLineDashOffset: function (offset) {\n    this._dashOffset = offset;\n    return this;\n  },\n\n  /**\n   *\n   * @return {boolean}\n   */\n  len: function () {\n    return this._len;\n  },\n\n  /**\n   * 直接设置 Path 数据\n   */\n  setData: function (data) {\n    var len = data.length;\n\n    if (!(this.data && this.data.length == len) && hasTypedArray) {\n      this.data = new Float32Array(len);\n    }\n\n    for (var i = 0; i < len; i++) {\n      this.data[i] = data[i];\n    }\n\n    this._len = len;\n  },\n\n  /**\n   * 添加子路径\n   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n   */\n  appendPath: function (path) {\n    if (!(path instanceof Array)) {\n      path = [path];\n    }\n\n    var len = path.length;\n    var appendSize = 0;\n    var offset = this._len;\n\n    for (var i = 0; i < len; i++) {\n      appendSize += path[i].len();\n    }\n\n    if (hasTypedArray && this.data instanceof Float32Array) {\n      this.data = new Float32Array(offset + appendSize);\n    }\n\n    for (var i = 0; i < len; i++) {\n      var appendPathData = path[i].data;\n\n      for (var k = 0; k < appendPathData.length; k++) {\n        this.data[offset++] = appendPathData[k];\n      }\n    }\n\n    this._len = offset;\n  },\n\n  /**\n   * 填充 Path 数据。\n   * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n   */\n  addData: function (cmd) {\n    if (!this._saveData) {\n      return;\n    }\n\n    var data = this.data;\n\n    if (this._len + arguments.length > data.length) {\n      // 因为之前的数组已经转换成静态的 Float32Array\n      // 所以不够用时需要扩展一个新的动态数组\n      this._expandData();\n\n      data = this.data;\n    }\n\n    for (var i = 0; i < arguments.length; i++) {\n      data[this._len++] = arguments[i];\n    }\n\n    this._prevCmd = cmd;\n  },\n  _expandData: function () {\n    // Only if data is Float32Array\n    if (!(this.data instanceof Array)) {\n      var newData = [];\n\n      for (var i = 0; i < this._len; i++) {\n        newData[i] = this.data[i];\n      }\n\n      this.data = newData;\n    }\n  },\n\n  /**\n   * If needs js implemented dashed line\n   * @return {boolean}\n   * @private\n   */\n  _needsDash: function () {\n    return this._lineDash;\n  },\n  _dashedLineTo: function (x1, y1) {\n    var dashSum = this._dashSum;\n    var offset = this._dashOffset;\n    var lineDash = this._lineDash;\n    var ctx = this._ctx;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n    var dist = mathSqrt(dx * dx + dy * dy);\n    var x = x0;\n    var y = y0;\n    var dash;\n    var nDash = lineDash.length;\n    var idx;\n    dx /= dist;\n    dy /= dist;\n\n    if (offset < 0) {\n      // Convert to positive offset\n      offset = dashSum + offset;\n    }\n\n    offset %= dashSum;\n    x -= offset * dx;\n    y -= offset * dy;\n\n    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n      idx = this._dashIdx;\n      dash = lineDash[idx];\n      x += dx * dash;\n      y += dy * dash;\n      this._dashIdx = (idx + 1) % nDash; // Skip positive offset\n\n      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n        continue;\n      }\n\n      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n    } // Offset for next lineTo\n\n\n    dx = x - x1;\n    dy = y - y1;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  },\n  // Not accurate dashed line to\n  _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n    var dashSum = this._dashSum;\n    var offset = this._dashOffset;\n    var lineDash = this._lineDash;\n    var ctx = this._ctx;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var t;\n    var dx;\n    var dy;\n    var cubicAt = curve.cubicAt;\n    var bezierLen = 0;\n    var idx = this._dashIdx;\n    var nDash = lineDash.length;\n    var x;\n    var y;\n    var tmpLen = 0;\n\n    if (offset < 0) {\n      // Convert to positive offset\n      offset = dashSum + offset;\n    }\n\n    offset %= dashSum; // Bezier approx length\n\n    for (t = 0; t < 1; t += 0.1) {\n      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);\n      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);\n      bezierLen += mathSqrt(dx * dx + dy * dy);\n    } // Find idx after add offset\n\n\n    for (; idx < nDash; idx++) {\n      tmpLen += lineDash[idx];\n\n      if (tmpLen > offset) {\n        break;\n      }\n    }\n\n    t = (tmpLen - offset) / bezierLen;\n\n    while (t <= 1) {\n      x = cubicAt(x0, x1, x2, x3, t);\n      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier\n      // Bad result if dash is long\n\n      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n      t += lineDash[idx] / bezierLen;\n      idx = (idx + 1) % nDash;\n    } // Finish the last segment and calculate the new offset\n\n\n    idx % 2 !== 0 && ctx.lineTo(x3, y3);\n    dx = x3 - x;\n    dy = y3 - y;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  },\n  _dashedQuadraticTo: function (x1, y1, x2, y2) {\n    // Convert quadratic to cubic using degree elevation\n    var x3 = x2;\n    var y3 = y2;\n    x2 = (x2 + 2 * x1) / 3;\n    y2 = (y2 + 2 * y1) / 3;\n    x1 = (this._xi + 2 * x1) / 3;\n    y1 = (this._yi + 2 * y1) / 3;\n\n    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n  },\n\n  /**\n   * 转成静态的 Float32Array 减少堆内存占用\n   * Convert dynamic array to static Float32Array\n   */\n  toStatic: function () {\n    var data = this.data;\n\n    if (data instanceof Array) {\n      data.length = this._len;\n\n      if (hasTypedArray) {\n        this.data = new Float32Array(data);\n      }\n    }\n  },\n\n  /**\n   * @return {module:zrender/core/BoundingRect}\n   */\n  getBoundingRect: function () {\n    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n    var data = this.data;\n    var xi = 0;\n    var yi = 0;\n    var x0 = 0;\n    var y0 = 0;\n\n    for (var i = 0; i < data.length;) {\n      var cmd = data[i++];\n\n      if (i == 1) {\n        // 如果第一个命令是 L, C, Q\n        // 则 previous point 同绘制命令的第一个 point\n        //\n        // 第一个命令为 Arc 的情况下会在后面特殊处理\n        xi = data[i];\n        yi = data[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n\n      switch (cmd) {\n        case CMD.M:\n          // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n          // 在 closePath 的时候使用\n          x0 = data[i++];\n          y0 = data[i++];\n          xi = x0;\n          yi = y0;\n          min2[0] = x0;\n          min2[1] = y0;\n          max2[0] = x0;\n          max2[1] = y0;\n          break;\n\n        case CMD.L:\n          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.C:\n          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.Q:\n          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.A:\n          // TODO Arc 判断的开销比较大\n          var cx = data[i++];\n          var cy = data[i++];\n          var rx = data[i++];\n          var ry = data[i++];\n          var startAngle = data[i++];\n          var endAngle = data[i++] + startAngle; // TODO Arc 旋转\n\n          var psi = data[i++];\n          var anticlockwise = 1 - data[i++];\n\n          if (i == 1) {\n            // 直接使用 arc 命令\n            // 第一个命令起点还未定义\n            x0 = mathCos(startAngle) * rx + cx;\n            y0 = mathSin(startAngle) * ry + cy;\n          }\n\n          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n\n        case CMD.R:\n          x0 = xi = data[i++];\n          y0 = yi = data[i++];\n          var width = data[i++];\n          var height = data[i++]; // Use fromLine\n\n          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n          break;\n\n        case CMD.Z:\n          xi = x0;\n          yi = y0;\n          break;\n      } // Union\n\n\n      vec2.min(min, min, min2);\n      vec2.max(max, max, max2);\n    } // No data\n\n\n    if (i === 0) {\n      min[0] = min[1] = max[0] = max[1] = 0;\n    }\n\n    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n  },\n\n  /**\n   * Rebuild path from current data\n   * Rebuild path will not consider javascript implemented line dash.\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  rebuildPath: function (ctx) {\n    var d = this.data;\n    var x0, y0;\n    var xi, yi;\n    var x, y;\n    var ux = this._ux;\n    var uy = this._uy;\n    var len = this._len;\n\n    for (var i = 0; i < len;) {\n      var cmd = d[i++];\n\n      if (i == 1) {\n        // 如果第一个命令是 L, C, Q\n        // 则 previous point 同绘制命令的第一个 point\n        //\n        // 第一个命令为 Arc 的情况下会在后面特殊处理\n        xi = d[i];\n        yi = d[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n\n      switch (cmd) {\n        case CMD.M:\n          x0 = xi = d[i++];\n          y0 = yi = d[i++];\n          ctx.moveTo(xi, yi);\n          break;\n\n        case CMD.L:\n          x = d[i++];\n          y = d[i++]; // Not draw too small seg between\n\n          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n            ctx.lineTo(x, y);\n            xi = x;\n            yi = y;\n          }\n\n          break;\n\n        case CMD.C:\n          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);\n          xi = d[i - 2];\n          yi = d[i - 1];\n          break;\n\n        case CMD.Q:\n          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n          xi = d[i - 2];\n          yi = d[i - 1];\n          break;\n\n        case CMD.A:\n          var cx = d[i++];\n          var cy = d[i++];\n          var rx = d[i++];\n          var ry = d[i++];\n          var theta = d[i++];\n          var dTheta = d[i++];\n          var psi = d[i++];\n          var fs = d[i++];\n          var r = rx > ry ? rx : ry;\n          var scaleX = rx > ry ? 1 : rx / ry;\n          var scaleY = rx > ry ? ry / rx : 1;\n          var isEllipse = Math.abs(rx - ry) > 1e-3;\n          var endAngle = theta + dTheta;\n\n          if (isEllipse) {\n            ctx.translate(cx, cy);\n            ctx.rotate(psi);\n            ctx.scale(scaleX, scaleY);\n            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n            ctx.scale(1 / scaleX, 1 / scaleY);\n            ctx.rotate(-psi);\n            ctx.translate(-cx, -cy);\n          } else {\n            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n          }\n\n          if (i == 1) {\n            // 直接使用 arc 命令\n            // 第一个命令起点还未定义\n            x0 = mathCos(theta) * rx + cx;\n            y0 = mathSin(theta) * ry + cy;\n          }\n\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n\n        case CMD.R:\n          x0 = xi = d[i];\n          y0 = yi = d[i + 1];\n          ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n          break;\n\n        case CMD.Z:\n          ctx.closePath();\n          xi = x0;\n          yi = y0;\n      }\n    }\n  }\n};\nPathProxy.CMD = CMD;\nvar _default = PathProxy;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/PathProxy.js\n// module id = 48\n// module chunks = 0","var _vector = require(\"./vector\");\n\nvar v2Create = _vector.create;\nvar v2DistSquare = _vector.distSquare;\n\n/**\n * 曲线辅助模块\n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\nvar mathPow = Math.pow;\nvar mathSqrt = Math.sqrt;\nvar EPSILON = 1e-8;\nvar EPSILON_NUMERIC = 1e-4;\nvar THREE_SQRT = mathSqrt(3);\nvar ONE_THIRD = 1 / 3; // 临时变量\n\nvar _v0 = v2Create();\n\nvar _v1 = v2Create();\n\nvar _v2 = v2Create();\n\nfunction isAroundZero(val) {\n  return val > -EPSILON && val < EPSILON;\n}\n\nfunction isNotAroundZero(val) {\n  return val > EPSILON || val < -EPSILON;\n}\n/**\n * 计算三次贝塞尔值\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction cubicAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t;\n  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);\n}\n/**\n * 计算三次贝塞尔导数值\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction cubicDerivativeAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t;\n  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);\n}\n/**\n * 计算三次贝塞尔方程根，使用盛金公式\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} val\n * @param  {Array.<number>} roots\n * @return {number} 有效根数目\n */\n\n\nfunction cubicRootAt(p0, p1, p2, p3, val, roots) {\n  // Evaluate roots of cubic functions\n  var a = p3 + 3 * (p1 - p2) - p0;\n  var b = 3 * (p2 - p1 * 2 + p0);\n  var c = 3 * (p1 - p0);\n  var d = p0 - val;\n  var A = b * b - 3 * a * c;\n  var B = b * c - 9 * a * d;\n  var C = c * c - 3 * b * d;\n  var n = 0;\n\n  if (isAroundZero(A) && isAroundZero(B)) {\n    if (isAroundZero(b)) {\n      roots[0] = 0;\n    } else {\n      var t1 = -c / b; //t1, t2, t3, b is not zero\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    }\n  } else {\n    var disc = B * B - 4 * A * C;\n\n    if (isAroundZero(disc)) {\n      var K = B / A;\n      var t1 = -b / a + K; // t1, a is not zero\n\n      var t2 = -K / 2; // t2, t3\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n      var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\n      if (Y1 < 0) {\n        Y1 = -mathPow(-Y1, ONE_THIRD);\n      } else {\n        Y1 = mathPow(Y1, ONE_THIRD);\n      }\n\n      if (Y2 < 0) {\n        Y2 = -mathPow(-Y2, ONE_THIRD);\n      } else {\n        Y2 = mathPow(Y2, ONE_THIRD);\n      }\n\n      var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    } else {\n      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n      var theta = Math.acos(T) / 3;\n      var ASqrt = mathSqrt(A);\n      var tmp = Math.cos(theta);\n      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n\n      if (t3 >= 0 && t3 <= 1) {\n        roots[n++] = t3;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * 计算三次贝塞尔方程极限值的位置\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {Array.<number>} extrema\n * @return {number} 有效数目\n */\n\n\nfunction cubicExtrema(p0, p1, p2, p3, extrema) {\n  var b = 6 * p2 - 12 * p1 + 6 * p0;\n  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n  var c = 3 * p1 - 3 * p0;\n  var n = 0;\n\n  if (isAroundZero(a)) {\n    if (isNotAroundZero(b)) {\n      var t1 = -c / b;\n\n      if (t1 >= 0 && t1 <= 1) {\n        extrema[n++] = t1;\n      }\n    }\n  } else {\n    var disc = b * b - 4 * a * c;\n\n    if (isAroundZero(disc)) {\n      extrema[0] = -b / (2 * a);\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var t1 = (-b + discSqrt) / (2 * a);\n      var t2 = (-b - discSqrt) / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        extrema[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        extrema[n++] = t2;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * 细分三次贝塞尔曲线\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @param  {Array.<number>} out\n */\n\n\nfunction cubicSubdivide(p0, p1, p2, p3, t, out) {\n  var p01 = (p1 - p0) * t + p0;\n  var p12 = (p2 - p1) * t + p1;\n  var p23 = (p3 - p2) * t + p2;\n  var p012 = (p12 - p01) * t + p01;\n  var p123 = (p23 - p12) * t + p12;\n  var p0123 = (p123 - p012) * t + p012; // Seg0\n\n  out[0] = p0;\n  out[1] = p01;\n  out[2] = p012;\n  out[3] = p0123; // Seg1\n\n  out[4] = p0123;\n  out[5] = p123;\n  out[6] = p23;\n  out[7] = p3;\n}\n/**\n * 投射点到三次贝塞尔曲线上，返回投射距离。\n * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x3\n * @param {number} y3\n * @param {number} x\n * @param {number} y\n * @param {Array.<number>} [out] 投射点\n * @return {number}\n */\n\n\nfunction cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {\n  // http://pomax.github.io/bezierinfo/#projections\n  var t;\n  var interval = 0.005;\n  var d = Infinity;\n  var prev;\n  var next;\n  var d1;\n  var d2;\n  _v0[0] = x;\n  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值\n  // PENDING\n\n  for (var _t = 0; _t < 1; _t += 0.05) {\n    _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n    _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n    d1 = v2DistSquare(_v0, _v1);\n\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n\n  d = Infinity; // At most 32 iteration\n\n  for (var i = 0; i < 32; i++) {\n    if (interval < EPSILON_NUMERIC) {\n      break;\n    }\n\n    prev = t - interval;\n    next = t + interval; // t - interval\n\n    _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n    _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n    d1 = v2DistSquare(_v1, _v0);\n\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      // t + interval\n      _v2[0] = cubicAt(x0, x1, x2, x3, next);\n      _v2[1] = cubicAt(y0, y1, y2, y3, next);\n      d2 = v2DistSquare(_v2, _v0);\n\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  } // t\n\n\n  if (out) {\n    out[0] = cubicAt(x0, x1, x2, x3, t);\n    out[1] = cubicAt(y0, y1, y2, y3, t);\n  } // console.log(interval, i);\n\n\n  return mathSqrt(d);\n}\n/**\n * 计算二次方贝塞尔值\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction quadraticAt(p0, p1, p2, t) {\n  var onet = 1 - t;\n  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n}\n/**\n * 计算二次方贝塞尔导数值\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction quadraticDerivativeAt(p0, p1, p2, t) {\n  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n}\n/**\n * 计算二次方贝塞尔方程根\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @param  {Array.<number>} roots\n * @return {number} 有效根数目\n */\n\n\nfunction quadraticRootAt(p0, p1, p2, val, roots) {\n  var a = p0 - 2 * p1 + p2;\n  var b = 2 * (p1 - p0);\n  var c = p0 - val;\n  var n = 0;\n\n  if (isAroundZero(a)) {\n    if (isNotAroundZero(b)) {\n      var t1 = -c / b;\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    }\n  } else {\n    var disc = b * b - 4 * a * c;\n\n    if (isAroundZero(disc)) {\n      var t1 = -b / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var t1 = (-b + discSqrt) / (2 * a);\n      var t2 = (-b - discSqrt) / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * 计算二次贝塞尔方程极限值\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @return {number}\n */\n\n\nfunction quadraticExtremum(p0, p1, p2) {\n  var divider = p0 + p2 - 2 * p1;\n\n  if (divider === 0) {\n    // p1 is center of p0 and p2\n    return 0.5;\n  } else {\n    return (p0 - p1) / divider;\n  }\n}\n/**\n * 细分二次贝塞尔曲线\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @param  {Array.<number>} out\n */\n\n\nfunction quadraticSubdivide(p0, p1, p2, t, out) {\n  var p01 = (p1 - p0) * t + p0;\n  var p12 = (p2 - p1) * t + p1;\n  var p012 = (p12 - p01) * t + p01; // Seg0\n\n  out[0] = p0;\n  out[1] = p01;\n  out[2] = p012; // Seg1\n\n  out[3] = p012;\n  out[4] = p12;\n  out[5] = p2;\n}\n/**\n * 投射点到二次贝塞尔曲线上，返回投射距离。\n * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x\n * @param {number} y\n * @param {Array.<number>} out 投射点\n * @return {number}\n */\n\n\nfunction quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {\n  // http://pomax.github.io/bezierinfo/#projections\n  var t;\n  var interval = 0.005;\n  var d = Infinity;\n  _v0[0] = x;\n  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值\n  // PENDING\n\n  for (var _t = 0; _t < 1; _t += 0.05) {\n    _v1[0] = quadraticAt(x0, x1, x2, _t);\n    _v1[1] = quadraticAt(y0, y1, y2, _t);\n    var d1 = v2DistSquare(_v0, _v1);\n\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n\n  d = Infinity; // At most 32 iteration\n\n  for (var i = 0; i < 32; i++) {\n    if (interval < EPSILON_NUMERIC) {\n      break;\n    }\n\n    var prev = t - interval;\n    var next = t + interval; // t - interval\n\n    _v1[0] = quadraticAt(x0, x1, x2, prev);\n    _v1[1] = quadraticAt(y0, y1, y2, prev);\n    var d1 = v2DistSquare(_v1, _v0);\n\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      // t + interval\n      _v2[0] = quadraticAt(x0, x1, x2, next);\n      _v2[1] = quadraticAt(y0, y1, y2, next);\n      var d2 = v2DistSquare(_v2, _v0);\n\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  } // t\n\n\n  if (out) {\n    out[0] = quadraticAt(x0, x1, x2, t);\n    out[1] = quadraticAt(y0, y1, y2, t);\n  } // console.log(interval, i);\n\n\n  return mathSqrt(d);\n}\n\nexports.cubicAt = cubicAt;\nexports.cubicDerivativeAt = cubicDerivativeAt;\nexports.cubicRootAt = cubicRootAt;\nexports.cubicExtrema = cubicExtrema;\nexports.cubicSubdivide = cubicSubdivide;\nexports.cubicProjectPoint = cubicProjectPoint;\nexports.quadraticAt = quadraticAt;\nexports.quadraticDerivativeAt = quadraticDerivativeAt;\nexports.quadraticRootAt = quadraticRootAt;\nexports.quadraticExtremum = quadraticExtremum;\nexports.quadraticSubdivide = quadraticSubdivide;\nexports.quadraticProjectPoint = quadraticProjectPoint;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/curve.js\n// module id = 49\n// module chunks = 0","var vec2 = require(\"./vector\");\n\nvar curve = require(\"./curve\");\n\n/**\n * @author Yi Shen(https://github.com/pissang)\n */\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI2 = Math.PI * 2;\nvar start = vec2.create();\nvar end = vec2.create();\nvar extremity = vec2.create();\n/**\n * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n * @module zrender/core/bbox\n * @param {Array<Object>} points 顶点数组\n * @param {number} min\n * @param {number} max\n */\n\nfunction fromPoints(points, min, max) {\n  if (points.length === 0) {\n    return;\n  }\n\n  var p = points[0];\n  var left = p[0];\n  var right = p[0];\n  var top = p[1];\n  var bottom = p[1];\n  var i;\n\n  for (i = 1; i < points.length; i++) {\n    p = points[i];\n    left = mathMin(left, p[0]);\n    right = mathMax(right, p[0]);\n    top = mathMin(top, p[1]);\n    bottom = mathMax(bottom, p[1]);\n  }\n\n  min[0] = left;\n  min[1] = top;\n  max[0] = right;\n  max[1] = bottom;\n}\n/**\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromLine(x0, y0, x1, y1, min, max) {\n  min[0] = mathMin(x0, x1);\n  min[1] = mathMin(y0, y1);\n  max[0] = mathMax(x0, x1);\n  max[1] = mathMax(y0, y1);\n}\n\nvar xDim = [];\nvar yDim = [];\n/**\n * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x3\n * @param {number} y3\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\nfunction fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {\n  var cubicExtrema = curve.cubicExtrema;\n  var cubicAt = curve.cubicAt;\n  var i;\n  var n = cubicExtrema(x0, x1, x2, x3, xDim);\n  min[0] = Infinity;\n  min[1] = Infinity;\n  max[0] = -Infinity;\n  max[1] = -Infinity;\n\n  for (i = 0; i < n; i++) {\n    var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n    min[0] = mathMin(x, min[0]);\n    max[0] = mathMax(x, max[0]);\n  }\n\n  n = cubicExtrema(y0, y1, y2, y3, yDim);\n\n  for (i = 0; i < n; i++) {\n    var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n    min[1] = mathMin(y, min[1]);\n    max[1] = mathMax(y, max[1]);\n  }\n\n  min[0] = mathMin(x0, min[0]);\n  max[0] = mathMax(x0, max[0]);\n  min[0] = mathMin(x3, min[0]);\n  max[0] = mathMax(x3, max[0]);\n  min[1] = mathMin(y0, min[1]);\n  max[1] = mathMax(y0, max[1]);\n  min[1] = mathMin(y3, min[1]);\n  max[1] = mathMax(y3, max[1]);\n}\n/**\n * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {\n  var quadraticExtremum = curve.quadraticExtremum;\n  var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero\n\n  var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);\n  var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);\n  var x = quadraticAt(x0, x1, x2, tx);\n  var y = quadraticAt(y0, y1, y2, ty);\n  min[0] = mathMin(x0, x2, x);\n  min[1] = mathMin(y0, y2, y);\n  max[0] = mathMax(x0, x2, x);\n  max[1] = mathMax(y0, y2, y);\n}\n/**\n * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n * @method\n * @memberOf module:zrender/core/bbox\n * @param {number} x\n * @param {number} y\n * @param {number} rx\n * @param {number} ry\n * @param {number} startAngle\n * @param {number} endAngle\n * @param {number} anticlockwise\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {\n  var vec2Min = vec2.min;\n  var vec2Max = vec2.max;\n  var diff = Math.abs(startAngle - endAngle);\n\n  if (diff % PI2 < 1e-4 && diff > 1e-4) {\n    // Is a circle\n    min[0] = x - rx;\n    min[1] = y - ry;\n    max[0] = x + rx;\n    max[1] = y + ry;\n    return;\n  }\n\n  start[0] = mathCos(startAngle) * rx + x;\n  start[1] = mathSin(startAngle) * ry + y;\n  end[0] = mathCos(endAngle) * rx + x;\n  end[1] = mathSin(endAngle) * ry + y;\n  vec2Min(min, start, end);\n  vec2Max(max, start, end); // Thresh to [0, Math.PI * 2]\n\n  startAngle = startAngle % PI2;\n\n  if (startAngle < 0) {\n    startAngle = startAngle + PI2;\n  }\n\n  endAngle = endAngle % PI2;\n\n  if (endAngle < 0) {\n    endAngle = endAngle + PI2;\n  }\n\n  if (startAngle > endAngle && !anticlockwise) {\n    endAngle += PI2;\n  } else if (startAngle < endAngle && anticlockwise) {\n    startAngle += PI2;\n  }\n\n  if (anticlockwise) {\n    var tmp = endAngle;\n    endAngle = startAngle;\n    startAngle = tmp;\n  } // var number = 0;\n  // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\n\n  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n    if (angle > startAngle) {\n      extremity[0] = mathCos(angle) * rx + x;\n      extremity[1] = mathSin(angle) * ry + y;\n      vec2Min(min, extremity, min);\n      vec2Max(max, extremity, max);\n    }\n  }\n}\n\nexports.fromPoints = fromPoints;\nexports.fromLine = fromLine;\nexports.fromCubic = fromCubic;\nexports.fromQuadratic = fromQuadratic;\nexports.fromArc = fromArc;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/bbox.js\n// module id = 50\n// module chunks = 0","var PathProxy = require(\"../core/PathProxy\");\n\nvar line = require(\"./line\");\n\nvar cubic = require(\"./cubic\");\n\nvar quadratic = require(\"./quadratic\");\n\nvar arc = require(\"./arc\");\n\nvar _util = require(\"./util\");\n\nvar normalizeRadian = _util.normalizeRadian;\n\nvar curve = require(\"../core/curve\");\n\nvar windingLine = require(\"./windingLine\");\n\nvar CMD = PathProxy.CMD;\nvar PI2 = Math.PI * 2;\nvar EPSILON = 1e-4;\n\nfunction isAroundEqual(a, b) {\n  return Math.abs(a - b) < EPSILON;\n} // 临时数组\n\n\nvar roots = [-1, -1, -1];\nvar extrema = [-1, -1];\n\nfunction swapExtrema() {\n  var tmp = extrema[0];\n  extrema[0] = extrema[1];\n  extrema[1] = tmp;\n}\n\nfunction windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n  // Quick reject\n  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {\n    return 0;\n  }\n\n  var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\n  if (nRoots === 0) {\n    return 0;\n  } else {\n    var w = 0;\n    var nExtrema = -1;\n    var y0_, y1_;\n\n    for (var i = 0; i < nRoots; i++) {\n      var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon\n\n      var unit = t === 0 || t === 1 ? 0.5 : 1;\n      var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\n      if (x_ < x) {\n        // Quick reject\n        continue;\n      }\n\n      if (nExtrema < 0) {\n        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\n        if (extrema[1] < extrema[0] && nExtrema > 1) {\n          swapExtrema();\n        }\n\n        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\n        if (nExtrema > 1) {\n          y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n        }\n      }\n\n      if (nExtrema == 2) {\n        // 分成三段单调函数\n        if (t < extrema[0]) {\n          w += y0_ < y0 ? unit : -unit;\n        } else if (t < extrema[1]) {\n          w += y1_ < y0_ ? unit : -unit;\n        } else {\n          w += y3 < y1_ ? unit : -unit;\n        }\n      } else {\n        // 分成两段单调函数\n        if (t < extrema[0]) {\n          w += y0_ < y0 ? unit : -unit;\n        } else {\n          w += y3 < y0_ ? unit : -unit;\n        }\n      }\n    }\n\n    return w;\n  }\n}\n\nfunction windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n  // Quick reject\n  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {\n    return 0;\n  }\n\n  var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\n  if (nRoots === 0) {\n    return 0;\n  } else {\n    var t = curve.quadraticExtremum(y0, y1, y2);\n\n    if (t >= 0 && t <= 1) {\n      var w = 0;\n      var y_ = curve.quadraticAt(y0, y1, y2, t);\n\n      for (var i = 0; i < nRoots; i++) {\n        // Remove one endpoint.\n        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;\n        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\n        if (x_ < x) {\n          // Quick reject\n          continue;\n        }\n\n        if (roots[i] < t) {\n          w += y_ < y0 ? unit : -unit;\n        } else {\n          w += y2 < y_ ? unit : -unit;\n        }\n      }\n\n      return w;\n    } else {\n      // Remove one endpoint.\n      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;\n      var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\n      if (x_ < x) {\n        // Quick reject\n        return 0;\n      }\n\n      return y2 < y0 ? unit : -unit;\n    }\n  }\n} // TODO\n// Arc 旋转\n\n\nfunction windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {\n  y -= cy;\n\n  if (y > r || y < -r) {\n    return 0;\n  }\n\n  var tmp = Math.sqrt(r * r - y * y);\n  roots[0] = -tmp;\n  roots[1] = tmp;\n  var diff = Math.abs(startAngle - endAngle);\n\n  if (diff < 1e-4) {\n    return 0;\n  }\n\n  if (diff % PI2 < 1e-4) {\n    // Is a circle\n    startAngle = 0;\n    endAngle = PI2;\n    var dir = anticlockwise ? 1 : -1;\n\n    if (x >= roots[0] + cx && x <= roots[1] + cx) {\n      return dir;\n    } else {\n      return 0;\n    }\n  }\n\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = normalizeRadian(endAngle);\n    endAngle = normalizeRadian(tmp);\n  } else {\n    startAngle = normalizeRadian(startAngle);\n    endAngle = normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var w = 0;\n\n  for (var i = 0; i < 2; i++) {\n    var x_ = roots[i];\n\n    if (x_ + cx > x) {\n      var angle = Math.atan2(y, x_);\n      var dir = anticlockwise ? 1 : -1;\n\n      if (angle < 0) {\n        angle = PI2 + angle;\n      }\n\n      if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n          dir = -dir;\n        }\n\n        w += dir;\n      }\n    }\n  }\n\n  return w;\n}\n\nfunction containPath(data, lineWidth, isStroke, x, y) {\n  var w = 0;\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n\n  for (var i = 0; i < data.length;) {\n    var cmd = data[i++]; // Begin a new subpath\n\n    if (cmd === CMD.M && i > 1) {\n      // Close previous subpath\n      if (!isStroke) {\n        w += windingLine(xi, yi, x0, y0, x, y);\n      } // 如果被任何一个 subpath 包含\n      // if (w !== 0) {\n      //     return true;\n      // }\n\n    }\n\n    if (i == 1) {\n      // 如果第一个命令是 L, C, Q\n      // 则 previous point 同绘制命令的第一个 point\n      //\n      // 第一个命令为 Arc 的情况下会在后面特殊处理\n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n    }\n\n    switch (cmd) {\n      case CMD.M:\n        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n        // 在 closePath 的时候使用\n        x0 = data[i++];\n        y0 = data[i++];\n        xi = x0;\n        yi = y0;\n        break;\n\n      case CMD.L:\n        if (isStroke) {\n          if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.C:\n        if (isStroke) {\n          if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.Q:\n        if (isStroke) {\n          if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.A:\n        // TODO Arc 判断的开销比较大\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++]; // TODO Arc 旋转\n\n        var psi = data[i++];\n        var anticlockwise = 1 - data[i++];\n        var x1 = Math.cos(theta) * rx + cx;\n        var y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令\n\n        if (i > 1) {\n          w += windingLine(xi, yi, x1, y1, x, y);\n        } else {\n          // 第一个命令起点还未定义\n          x0 = x1;\n          y0 = y1;\n        } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n\n\n        var _x = (x - cx) * ry / rx + cx;\n\n        if (isStroke) {\n          if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {\n            return true;\n          }\n        } else {\n          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);\n        }\n\n        xi = Math.cos(theta + dTheta) * rx + cx;\n        yi = Math.sin(theta + dTheta) * ry + cy;\n        break;\n\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        var width = data[i++];\n        var height = data[i++];\n        var x1 = x0 + width;\n        var y1 = y0 + height;\n\n        if (isStroke) {\n          if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // FIXME Clockwise ?\n          w += windingLine(x1, y0, x1, y1, x, y);\n          w += windingLine(x0, y1, x0, y0, x, y);\n        }\n\n        break;\n\n      case CMD.Z:\n        if (isStroke) {\n          if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // Close a subpath\n          w += windingLine(xi, yi, x0, y0, x, y); // 如果被任何一个 subpath 包含\n          // FIXME subpaths may overlap\n          // if (w !== 0) {\n          //     return true;\n          // }\n        }\n\n        xi = x0;\n        yi = y0;\n        break;\n    }\n  }\n\n  if (!isStroke && !isAroundEqual(yi, y0)) {\n    w += windingLine(xi, yi, x0, y0, x, y) || 0;\n  }\n\n  return w !== 0;\n}\n\nfunction contain(pathData, x, y) {\n  return containPath(pathData, 0, false, x, y);\n}\n\nfunction containStroke(pathData, lineWidth, x, y) {\n  return containPath(pathData, lineWidth, true, x, y);\n}\n\nexports.contain = contain;\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/path.js\n// module id = 51\n// module chunks = 0","/**\n * 线段包含判断\n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth;\n  var _a = 0;\n  var _b = x0; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {\n    return false;\n  }\n\n  if (x0 !== x1) {\n    _a = (y0 - y1) / (x0 - x1);\n    _b = (x0 * y1 - x1 * y0) / (x0 - x1);\n  } else {\n    return Math.abs(x - x0) <= _l / 2;\n  }\n\n  var tmp = _a * x - y + _b;\n\n  var _s = tmp * tmp / (_a * _a + 1);\n\n  return _s <= _l / 2 * _l / 2;\n}\n\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/line.js\n// module id = 52\n// module chunks = 0","var curve = require(\"../core/curve\");\n\n/**\n * 三次贝塞尔曲线描边包含判断\n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  x2\n * @param  {number}  y2\n * @param  {number}  x3\n * @param  {number}  y3\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {\n    return false;\n  }\n\n  var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);\n  return d <= _l / 2;\n}\n\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/cubic.js\n// module id = 53\n// module chunks = 0","var _curve = require(\"../core/curve\");\n\nvar quadraticProjectPoint = _curve.quadraticProjectPoint;\n\n/**\n * 二次贝塞尔曲线描边包含判断\n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  x2\n * @param  {number}  y2\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {\n    return false;\n  }\n\n  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);\n  return d <= _l / 2;\n}\n\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/quadratic.js\n// module id = 54\n// module chunks = 0","var _util = require(\"./util\");\n\nvar normalizeRadian = _util.normalizeRadian;\nvar PI2 = Math.PI * 2;\n/**\n * 圆弧描边包含判断\n * @param  {number}  cx\n * @param  {number}  cy\n * @param  {number}  r\n * @param  {number}  startAngle\n * @param  {number}  endAngle\n * @param  {boolean}  anticlockwise\n * @param  {number} lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {Boolean}\n */\n\nfunction containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth;\n  x -= cx;\n  y -= cy;\n  var d = Math.sqrt(x * x + y * y);\n\n  if (d - _l > r || d + _l < r) {\n    return false;\n  }\n\n  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n    // Is a circle\n    return true;\n  }\n\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = normalizeRadian(endAngle);\n    endAngle = normalizeRadian(tmp);\n  } else {\n    startAngle = normalizeRadian(startAngle);\n    endAngle = normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var angle = Math.atan2(y, x);\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;\n}\n\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/arc.js\n// module id = 55\n// module chunks = 0","var PI2 = Math.PI * 2;\n\nfunction normalizeRadian(angle) {\n  angle %= PI2;\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  return angle;\n}\n\nexports.normalizeRadian = normalizeRadian;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/util.js\n// module id = 56\n// module chunks = 0","function windingLine(x0, y0, x1, y1, x, y) {\n  if (y > y0 && y > y1 || y < y0 && y < y1) {\n    return 0;\n  } // Ignore horizontal line\n\n\n  if (y1 === y0) {\n    return 0;\n  }\n\n  var dir = y1 < y0 ? 1 : -1;\n  var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon\n\n  if (t === 1 || t === 0) {\n    dir = y1 < y0 ? 0.5 : -0.5;\n  }\n\n  var x_ = t * (x1 - x0) + x0;\n  return x_ > x ? dir : 0;\n}\n\nmodule.exports = windingLine;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/windingLine.js\n// module id = 57\n// module chunks = 0","var PathProxy = require(\"../core/PathProxy\");\n\nvar _vector = require(\"../core/vector\");\n\nvar v2ApplyTransform = _vector.applyTransform;\nvar CMD = PathProxy.CMD;\nvar points = [[], [], []];\nvar mathSqrt = Math.sqrt;\nvar mathAtan2 = Math.atan2;\n\nfunction _default(path, m) {\n  var data = path.data;\n  var cmd;\n  var nPoint;\n  var i;\n  var j;\n  var k;\n  var p;\n  var M = CMD.M;\n  var C = CMD.C;\n  var L = CMD.L;\n  var R = CMD.R;\n  var A = CMD.A;\n  var Q = CMD.Q;\n\n  for (i = 0, j = 0; i < data.length;) {\n    cmd = data[i++];\n    j = i;\n    nPoint = 0;\n\n    switch (cmd) {\n      case M:\n        nPoint = 1;\n        break;\n\n      case L:\n        nPoint = 1;\n        break;\n\n      case C:\n        nPoint = 3;\n        break;\n\n      case Q:\n        nPoint = 2;\n        break;\n\n      case A:\n        var x = m[4];\n        var y = m[5];\n        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n        var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx\n\n        data[i] *= sx;\n        data[i++] += x; // cy\n\n        data[i] *= sy;\n        data[i++] += y; // Scale rx and ry\n        // FIXME Assume psi is 0 here\n\n        data[i++] *= sx;\n        data[i++] *= sy; // Start angle\n\n        data[i++] += angle; // end angle\n\n        data[i++] += angle; // FIXME psi\n\n        i += 2;\n        j = i;\n        break;\n\n      case R:\n        // x0, y0\n        p[0] = data[i++];\n        p[1] = data[i++];\n        v2ApplyTransform(p, p, m);\n        data[j++] = p[0];\n        data[j++] = p[1]; // x1, y1\n\n        p[0] += data[i++];\n        p[1] += data[i++];\n        v2ApplyTransform(p, p, m);\n        data[j++] = p[0];\n        data[j++] = p[1];\n    }\n\n    for (k = 0; k < nPoint; k++) {\n      var p = points[k];\n      p[0] = data[i++];\n      p[1] = data[i++];\n      v2ApplyTransform(p, p, m); // Write back\n\n      data[j++] = p[0];\n      data[j++] = p[1];\n    }\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/transformPath.js\n// module id = 58\n// module chunks = 0","/**\n * @param {Array.<Object>} colorStops\n */\nvar Gradient = function (colorStops) {\n  this.colorStops = colorStops || [];\n};\n\nGradient.prototype = {\n  constructor: Gradient,\n  addColorStop: function (offset, color) {\n    this.colorStops.push({\n      offset: offset,\n      color: color\n    });\n  }\n};\nvar _default = Gradient;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Gradient.js\n// module id = 59\n// module chunks = 0","var Displayable = require(\"./Displayable\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar textContain = require(\"../contain/text\");\n\nvar textHelper = require(\"./helper/text\");\n\n/**\n * @alias zrender/graphic/Text\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\nvar Text = function (opts) {\n  // jshint ignore:line\n  Displayable.call(this, opts);\n};\n\nText.prototype = {\n  constructor: Text,\n  type: 'text',\n  brush: function (ctx, prevEl) {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true); // Use props with prefix 'text'.\n\n    style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;\n    var text = style.text; // Convert to string\n\n    text != null && (text += ''); // Always bind style\n\n    style.bind(ctx, this, prevEl);\n\n    if (!textHelper.needDrawText(text, style)) {\n      return;\n    }\n\n    this.setTransform(ctx);\n    textHelper.renderText(this, ctx, text, style);\n    this.restoreTransform(ctx);\n  },\n  getBoundingRect: function () {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true);\n\n    if (!this._rect) {\n      var text = style.text;\n      text != null ? text += '' : text = '';\n      var rect = textContain.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.rich);\n      rect.x += style.x || 0;\n      rect.y += style.y || 0;\n\n      if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {\n        var w = style.textStrokeWidth;\n        rect.x -= w / 2;\n        rect.y -= w / 2;\n        rect.width += w;\n        rect.height += w;\n      }\n\n      this._rect = rect;\n    }\n\n    return this._rect;\n  }\n};\nzrUtil.inherits(Text, Displayable);\nvar _default = Text;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Text.js\n// module id = 60\n// module chunks = 0","var Path = require(\"../Path\");\n\n/**\n * 圆形\n * @module zrender/shape/Circle\n */\nvar _default = Path.extend({\n  type: 'circle',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0\n  },\n  buildPath: function (ctx, shape, inBundle) {\n    // Better stroking in ShapeBundle\n    // Always do it may have performence issue ( fill may be 2x more cost)\n    if (inBundle) {\n      ctx.moveTo(shape.cx + shape.r, shape.cy);\n    } // else {\n    //     if (ctx.allocate && !ctx.data.length) {\n    //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n    //     }\n    // }\n    // Better stroking in ShapeBundle\n    // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\n\n    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Circle.js\n// module id = 61\n// module chunks = 0","var Path = require(\"../Path\");\n\nvar fixClipWithShadow = require(\"../helper/fixClipWithShadow\");\n\n/**\n * 扇形\n * @module zrender/graphic/shape/Sector\n */\nvar _default = Path.extend({\n  type: 'sector',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r0: 0,\n    r: 0,\n    startAngle: 0,\n    endAngle: Math.PI * 2,\n    clockwise: true\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var r0 = Math.max(shape.r0 || 0, 0);\n    var r = Math.max(shape.r, 0);\n    var startAngle = shape.startAngle;\n    var endAngle = shape.endAngle;\n    var clockwise = shape.clockwise;\n    var unitX = Math.cos(startAngle);\n    var unitY = Math.sin(startAngle);\n    ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n    ctx.lineTo(unitX * r + x, unitY * r + y);\n    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n    ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);\n\n    if (r0 !== 0) {\n      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n    }\n\n    ctx.closePath();\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Sector.js\n// module id = 62\n// module chunks = 0","var env = require(\"../../core/env\");\n\n// Fix weird bug in some version of IE11 (like 11.0.9600.178**),\n// where exception \"unexpected call to method or property access\"\n// might be thrown when calling ctx.fill or ctx.stroke after a path\n// whose area size is zero is drawn and ctx.clip() is called and\n// shadowBlur is set. See #4572, #3112, #5777.\n// (e.g.,\n//  ctx.moveTo(10, 10);\n//  ctx.lineTo(20, 10);\n//  ctx.closePath();\n//  ctx.clip();\n//  ctx.shadowBlur = 10;\n//  ...\n//  ctx.fill();\n// )\nvar shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];\n\nfunction _default(orignalBrush) {\n  // version string can be: '11.0'\n  return env.browser.ie && env.browser.version >= 11 ? function () {\n    var clipPaths = this.__clipPaths;\n    var style = this.style;\n    var modified;\n\n    if (clipPaths) {\n      for (var i = 0; i < clipPaths.length; i++) {\n        var clipPath = clipPaths[i];\n        var shape = clipPath && clipPath.shape;\n        var type = clipPath && clipPath.type;\n\n        if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {\n          for (var j = 0; j < shadowTemp.length; j++) {\n            // It is save to put shadowTemp static, because shadowTemp\n            // will be all modified each item brush called.\n            shadowTemp[j][2] = style[shadowTemp[j][0]];\n            style[shadowTemp[j][0]] = shadowTemp[j][1];\n          }\n\n          modified = true;\n          break;\n        }\n      }\n    }\n\n    orignalBrush.apply(this, arguments);\n\n    if (modified) {\n      for (var j = 0; j < shadowTemp.length; j++) {\n        style[shadowTemp[j][0]] = shadowTemp[j][2];\n      }\n    }\n  } : orignalBrush;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/fixClipWithShadow.js\n// module id = 63\n// module chunks = 0","var Path = require(\"../Path\");\n\n/**\n * 圆环\n * @module zrender/graphic/shape/Ring\n */\nvar _default = Path.extend({\n  type: 'ring',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0,\n    r0: 0\n  },\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var PI2 = Math.PI * 2;\n    ctx.moveTo(x + shape.r, y);\n    ctx.arc(x, y, shape.r, 0, PI2, false);\n    ctx.moveTo(x + shape.r0, y);\n    ctx.arc(x, y, shape.r0, 0, PI2, true);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Ring.js\n// module id = 64\n// module chunks = 0","var Path = require(\"../Path\");\n\nvar polyHelper = require(\"../helper/poly\");\n\n/**\n * 多边形\n * @module zrender/shape/Polygon\n */\nvar _default = Path.extend({\n  type: 'polygon',\n  shape: {\n    points: null,\n    smooth: false,\n    smoothConstraint: null\n  },\n  buildPath: function (ctx, shape) {\n    polyHelper.buildPath(ctx, shape, true);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Polygon.js\n// module id = 65\n// module chunks = 0","var smoothSpline = require(\"./smoothSpline\");\n\nvar smoothBezier = require(\"./smoothBezier\");\n\nfunction buildPath(ctx, shape, closePath) {\n  var points = shape.points;\n  var smooth = shape.smooth;\n\n  if (points && points.length >= 2) {\n    if (smooth && smooth !== 'spline') {\n      var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);\n      ctx.moveTo(points[0][0], points[0][1]);\n      var len = points.length;\n\n      for (var i = 0; i < (closePath ? len : len - 1); i++) {\n        var cp1 = controlPoints[i * 2];\n        var cp2 = controlPoints[i * 2 + 1];\n        var p = points[(i + 1) % len];\n        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);\n      }\n    } else {\n      if (smooth === 'spline') {\n        points = smoothSpline(points, closePath);\n      }\n\n      ctx.moveTo(points[0][0], points[0][1]);\n\n      for (var i = 1, l = points.length; i < l; i++) {\n        ctx.lineTo(points[i][0], points[i][1]);\n      }\n    }\n\n    closePath && ctx.closePath();\n  }\n}\n\nexports.buildPath = buildPath;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/poly.js\n// module id = 66\n// module chunks = 0","var _vector = require(\"../../core/vector\");\n\nvar v2Distance = _vector.distance;\n\n/**\n * Catmull-Rom spline 插值折线\n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n/**\n * @inner\n */\nfunction interpolate(p0, p1, p2, p3, t, t2, t3) {\n  var v0 = (p2 - p0) * 0.5;\n  var v1 = (p3 - p1) * 0.5;\n  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n}\n/**\n * @alias module:zrender/shape/util/smoothSpline\n * @param {Array} points 线段顶点数组\n * @param {boolean} isLoop\n * @return {Array}\n */\n\n\nfunction _default(points, isLoop) {\n  var len = points.length;\n  var ret = [];\n  var distance = 0;\n\n  for (var i = 1; i < len; i++) {\n    distance += v2Distance(points[i - 1], points[i]);\n  }\n\n  var segs = distance / 2;\n  segs = segs < len ? len : segs;\n\n  for (var i = 0; i < segs; i++) {\n    var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n    var idx = Math.floor(pos);\n    var w = pos - idx;\n    var p0;\n    var p1 = points[idx % len];\n    var p2;\n    var p3;\n\n    if (!isLoop) {\n      p0 = points[idx === 0 ? idx : idx - 1];\n      p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n      p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n    } else {\n      p0 = points[(idx - 1 + len) % len];\n      p2 = points[(idx + 1) % len];\n      p3 = points[(idx + 2) % len];\n    }\n\n    var w2 = w * w;\n    var w3 = w * w2;\n    ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);\n  }\n\n  return ret;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/smoothSpline.js\n// module id = 67\n// module chunks = 0","var _vector = require(\"../../core/vector\");\n\nvar v2Min = _vector.min;\nvar v2Max = _vector.max;\nvar v2Scale = _vector.scale;\nvar v2Distance = _vector.distance;\nvar v2Add = _vector.add;\nvar v2Clone = _vector.clone;\nvar v2Sub = _vector.sub;\n\n/**\n * 贝塞尔平滑曲线\n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n/**\n * 贝塞尔平滑曲线\n * @alias module:zrender/shape/util/smoothBezier\n * @param {Array} points 线段顶点数组\n * @param {number} smooth 平滑等级, 0-1\n * @param {boolean} isLoop\n * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n *                           整个折线的包围盒做一个并集用来约束控制点。\n * @param {Array} 计算出来的控制点数组\n */\nfunction _default(points, smooth, isLoop, constraint) {\n  var cps = [];\n  var v = [];\n  var v1 = [];\n  var v2 = [];\n  var prevPoint;\n  var nextPoint;\n  var min, max;\n\n  if (constraint) {\n    min = [Infinity, Infinity];\n    max = [-Infinity, -Infinity];\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      v2Min(min, min, points[i]);\n      v2Max(max, max, points[i]);\n    } // 与指定的包围盒做并集\n\n\n    v2Min(min, min, constraint[0]);\n    v2Max(max, max, constraint[1]);\n  }\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n\n    if (isLoop) {\n      prevPoint = points[i ? i - 1 : len - 1];\n      nextPoint = points[(i + 1) % len];\n    } else {\n      if (i === 0 || i === len - 1) {\n        cps.push(v2Clone(points[i]));\n        continue;\n      } else {\n        prevPoint = points[i - 1];\n        nextPoint = points[i + 1];\n      }\n    }\n\n    v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length\n\n    v2Scale(v, v, smooth);\n    var d0 = v2Distance(point, prevPoint);\n    var d1 = v2Distance(point, nextPoint);\n    var sum = d0 + d1;\n\n    if (sum !== 0) {\n      d0 /= sum;\n      d1 /= sum;\n    }\n\n    v2Scale(v1, v, -d0);\n    v2Scale(v2, v, d1);\n    var cp0 = v2Add([], point, v1);\n    var cp1 = v2Add([], point, v2);\n\n    if (constraint) {\n      v2Max(cp0, cp0, min);\n      v2Min(cp0, cp0, max);\n      v2Max(cp1, cp1, min);\n      v2Min(cp1, cp1, max);\n    }\n\n    cps.push(cp0);\n    cps.push(cp1);\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n\n  return cps;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/smoothBezier.js\n// module id = 68\n// module chunks = 0","var Path = require(\"../Path\");\n\nvar polyHelper = require(\"../helper/poly\");\n\n/**\n * @module zrender/graphic/shape/Polyline\n */\nvar _default = Path.extend({\n  type: 'polyline',\n  shape: {\n    points: null,\n    smooth: false,\n    smoothConstraint: null\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    polyHelper.buildPath(ctx, shape, false);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Polyline.js\n// module id = 69\n// module chunks = 0","var Path = require(\"../Path\");\n\nvar roundRectHelper = require(\"../helper/roundRect\");\n\n/**\n * 矩形\n * @module zrender/graphic/shape/Rect\n */\nvar _default = Path.extend({\n  type: 'rect',\n  shape: {\n    // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n    // r缩写为1         相当于 [1, 1, 1, 1]\n    // r缩写为[1]       相当于 [1, 1, 1, 1]\n    // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n    // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n    r: 0,\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (ctx, shape) {\n    var x = shape.x;\n    var y = shape.y;\n    var width = shape.width;\n    var height = shape.height;\n\n    if (!shape.r) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, shape);\n    }\n\n    ctx.closePath();\n    return;\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Rect.js\n// module id = 70\n// module chunks = 0","var Path = require(\"../Path\");\n\n/**\n * 直线\n * @module zrender/graphic/shape/Line\n */\nvar _default = Path.extend({\n  type: 'line',\n  shape: {\n    // Start point\n    x1: 0,\n    y1: 0,\n    // End point\n    x2: 0,\n    y2: 0,\n    percent: 1\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x1 = shape.x1;\n    var y1 = shape.y1;\n    var x2 = shape.x2;\n    var y2 = shape.y2;\n    var percent = shape.percent;\n\n    if (percent === 0) {\n      return;\n    }\n\n    ctx.moveTo(x1, y1);\n\n    if (percent < 1) {\n      x2 = x1 * (1 - percent) + x2 * percent;\n      y2 = y1 * (1 - percent) + y2 * percent;\n    }\n\n    ctx.lineTo(x2, y2);\n  },\n\n  /**\n   * Get point at percent\n   * @param  {number} percent\n   * @return {Array.<number>}\n   */\n  pointAt: function (p) {\n    var shape = this.shape;\n    return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Line.js\n// module id = 71\n// module chunks = 0","var Path = require(\"../Path\");\n\nvar vec2 = require(\"../../core/vector\");\n\nvar _curve = require(\"../../core/curve\");\n\nvar quadraticSubdivide = _curve.quadraticSubdivide;\nvar cubicSubdivide = _curve.cubicSubdivide;\nvar quadraticAt = _curve.quadraticAt;\nvar cubicAt = _curve.cubicAt;\nvar quadraticDerivativeAt = _curve.quadraticDerivativeAt;\nvar cubicDerivativeAt = _curve.cubicDerivativeAt;\n\n/**\n * 贝塞尔曲线\n * @module zrender/shape/BezierCurve\n */\nvar out = [];\n\nfunction someVectorAt(shape, t, isTangent) {\n  var cpx2 = shape.cpx2;\n  var cpy2 = shape.cpy2;\n\n  if (cpx2 === null || cpy2 === null) {\n    return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];\n  } else {\n    return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];\n  }\n}\n\nvar _default = Path.extend({\n  type: 'bezier-curve',\n  shape: {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0,\n    cpx1: 0,\n    cpy1: 0,\n    // cpx2: 0,\n    // cpy2: 0\n    // Curve show percent, for animating\n    percent: 1\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x1 = shape.x1;\n    var y1 = shape.y1;\n    var x2 = shape.x2;\n    var y2 = shape.y2;\n    var cpx1 = shape.cpx1;\n    var cpy1 = shape.cpy1;\n    var cpx2 = shape.cpx2;\n    var cpy2 = shape.cpy2;\n    var percent = shape.percent;\n\n    if (percent === 0) {\n      return;\n    }\n\n    ctx.moveTo(x1, y1);\n\n    if (cpx2 == null || cpy2 == null) {\n      if (percent < 1) {\n        quadraticSubdivide(x1, cpx1, x2, percent, out);\n        cpx1 = out[1];\n        x2 = out[2];\n        quadraticSubdivide(y1, cpy1, y2, percent, out);\n        cpy1 = out[1];\n        y2 = out[2];\n      }\n\n      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n    } else {\n      if (percent < 1) {\n        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n        cpx1 = out[1];\n        cpx2 = out[2];\n        x2 = out[3];\n        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n        cpy1 = out[1];\n        cpy2 = out[2];\n        y2 = out[3];\n      }\n\n      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n    }\n  },\n\n  /**\n   * Get point at percent\n   * @param  {number} t\n   * @return {Array.<number>}\n   */\n  pointAt: function (t) {\n    return someVectorAt(this.shape, t, false);\n  },\n\n  /**\n   * Get tangent at percent\n   * @param  {number} t\n   * @return {Array.<number>}\n   */\n  tangentAt: function (t) {\n    var p = someVectorAt(this.shape, t, true);\n    return vec2.normalize(p, p);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/BezierCurve.js\n// module id = 72\n// module chunks = 0","var Path = require(\"../Path\");\n\n/**\n * 圆弧\n * @module zrender/graphic/shape/Arc\n */\nvar _default = Path.extend({\n  type: 'arc',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0,\n    startAngle: 0,\n    endAngle: Math.PI * 2,\n    clockwise: true\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var r = Math.max(shape.r, 0);\n    var startAngle = shape.startAngle;\n    var endAngle = shape.endAngle;\n    var clockwise = shape.clockwise;\n    var unitX = Math.cos(startAngle);\n    var unitY = Math.sin(startAngle);\n    ctx.moveTo(unitX * r + x, unitY * r + y);\n    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Arc.js\n// module id = 73\n// module chunks = 0","var zrUtil = require(\"../core/util\");\n\nvar Gradient = require(\"./Gradient\");\n\n/**\n * x, y, x2, y2 are all percent from 0 to 1\n * @param {number} [x=0]\n * @param {number} [y=0]\n * @param {number} [x2=1]\n * @param {number} [y2=0]\n * @param {Array.<Object>} colorStops\n * @param {boolean} [globalCoord=false]\n */\nvar LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {type: 'linear', colorStops: ...}`, where\n  // this constructor will not be called.\n  this.x = x == null ? 0 : x;\n  this.y = y == null ? 0 : y;\n  this.x2 = x2 == null ? 1 : x2;\n  this.y2 = y2 == null ? 0 : y2; // Can be cloned\n\n  this.type = 'linear'; // If use global coord\n\n  this.global = globalCoord || false;\n  Gradient.call(this, colorStops);\n};\n\nLinearGradient.prototype = {\n  constructor: LinearGradient\n};\nzrUtil.inherits(LinearGradient, Gradient);\nvar _default = LinearGradient;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/LinearGradient.js\n// module id = 74\n// module chunks = 0","var zrUtil = require(\"../core/util\");\n\nvar Gradient = require(\"./Gradient\");\n\n/**\n * x, y, r are all percent from 0 to 1\n * @param {number} [x=0.5]\n * @param {number} [y=0.5]\n * @param {number} [r=0.5]\n * @param {Array.<Object>} [colorStops]\n * @param {boolean} [globalCoord=false]\n */\nvar RadialGradient = function (x, y, r, colorStops, globalCoord) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {type: 'radial', colorStops: ...}`, where\n  // this constructor will not be called.\n  this.x = x == null ? 0.5 : x;\n  this.y = y == null ? 0.5 : y;\n  this.r = r == null ? 0.5 : r; // Can be cloned\n\n  this.type = 'radial'; // If use global coord\n\n  this.global = globalCoord || false;\n  Gradient.call(this, colorStops);\n};\n\nRadialGradient.prototype = {\n  constructor: RadialGradient\n};\nzrUtil.inherits(RadialGradient, Gradient);\nvar _default = RadialGradient;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/RadialGradient.js\n// module id = 75\n// module chunks = 0","var zrUtil = require(\"../core/util\");\n\nvar Style = require(\"./Style\");\n\nvar _vector = require(\"../core/vector\");\n\nvar vec2Copy = _vector.copy;\n\n/**\n * States machine for managing graphic states\n */\n\n/**\n * @typedef {Object} IGraphicState\n * @property {number} [zlevel]\n * @property {number} [z]\n * @property {Array.<number>} {position}\n * @property {Array.<number>|number} {rotation}\n * @property {Array.<number>} {scale}\n * @property {Object} style\n *\n * @property {Function} onenter\n * @property {Function} onleave\n * @property {Function} ontransition\n * @property {Array.<IGraphicStateTransition|string>} transition\n *           Transition object or a string descriptor like '* 30 0 Linear'\n */\nvar transitionProperties = ['position', 'rotation', 'scale', 'style', 'shape'];\n/**\n * @module zrender/graphic/States~TransitionObject\n */\n\nvar TransitionObject = function (opts) {\n  if (typeof opts == 'string') {\n    this._fromStr(opts);\n  } else if (opts) {\n    opts.property && (this.property = opts.property);\n    opts.duration != null && (this.duration = opts.duration);\n    opts.easing && (this.easing = opts.easing);\n    opts.delay && (this.delay = opts.delay);\n  }\n\n  if (this.property !== '*') {\n    this.property = this.property.split(',');\n  } else {\n    this.property = transitionProperties;\n  }\n};\n\nTransitionObject.prototype = {\n  constructor: TransitionObject,\n\n  /**\n   * List of all transition properties. Splitted by comma. Must not have spaces in the string.\n   * e.g. 'position,style.color'. '*' will match all the valid properties.\n   * @type {string}\n   * @default *\n   */\n  property: '*',\n\n  /**\n   * @type {string}\n   * @default 'Linear'\n   */\n  easing: 'Linear',\n\n  /**\n   * @type {number}\n   * @default 'number'\n   */\n  duration: 500,\n\n  /**\n   * @type {number}\n   */\n  delay: 0,\n  _fromStr: function (str) {\n    var arr = str.split(/\\s+/g);\n    this.property = arr[0];\n    this.duration = +arr[1];\n    this.delay = +arr[2];\n    this.easing = arr[3];\n  }\n};\n/**\n * @alias module:zrender/graphic/States\n */\n\nvar GraphicStates = function (opts) {\n  opts = opts || {};\n  this._states = {};\n  /**\n   * Target element\n   * @type {zrender/graphic/Displayable|zrender/container/Group}\n   */\n\n  this._el = opts.el;\n  this._subStates = [];\n  this._transitionAnimators = [];\n\n  if (opts.initialState) {\n    this._initialState = opts.initialState;\n  }\n\n  var optsStates = opts.states;\n\n  if (optsStates) {\n    for (var name in optsStates) {\n      if (optsStates.hasOwnProperty(name)) {\n        var state = optsStates[name];\n\n        this._addState(name, state);\n      }\n    }\n  }\n\n  this.setState(this._initialState);\n};\n\nGraphicStates.prototype = {\n  constructor: GraphicStates,\n\n  /**\n   * All other state will be extended from initial state\n   * @type {string}\n   * @private\n   */\n  _initialState: 'normal',\n\n  /**\n   * Current state\n   * @type {string}\n   * @private\n   */\n  _currentState: '',\n  el: function () {\n    return this._el;\n  },\n  _addState: function (name, state) {\n    this._states[name] = state;\n\n    if (state.transition) {\n      state.transition = new TransitionObject(state.transition);\n    } // Extend from initial state\n\n\n    if (name !== this._initialState) {\n      this._extendFromInitial(state);\n    } else {\n      var el = this._el; // setState 的时候自带的 style 和 shape 都会被直接覆盖\n      // 所以这边先把自带的 style 和 shape 扩展到初始状态中\n\n      zrUtil.merge(state.style, el.style, false, false);\n\n      if (state.shape) {\n        zrUtil.merge(state.shape, el.shape, false, true);\n      } else {\n        state.shape = zrUtil.clone(el.shape, true);\n      }\n\n      for (var name in this._states) {\n        if (this._states.hasOwnProperty(name)) {\n          this._extendFromInitial(this._states[name]);\n        }\n      }\n    }\n  },\n  _extendFromInitial: function (state) {\n    var initialState = this._states[this._initialState];\n\n    if (initialState && state !== initialState) {\n      zrUtil.merge(state, initialState, false, true);\n    }\n  },\n  setState: function (name, silent) {\n    if (name === this._currentState && !this.transiting()) {\n      return;\n    }\n\n    var state = this._states[name];\n\n    if (state) {\n      this._stopTransition();\n\n      if (!silent) {\n        var prevState = this._states[this._currentState];\n\n        if (prevState) {\n          prevState.onleave && prevState.onleave.call(this);\n        }\n\n        state.onenter && state.onenter.call(this);\n      }\n\n      this._currentState = name;\n\n      if (this._el) {\n        var el = this._el; // Setting attributes\n\n        if (state.zlevel != null) {\n          el.zlevel = state.zlevel;\n        }\n\n        if (state.z != null) {\n          el.z = state.z;\n        } // SRT\n\n\n        state.position && vec2Copy(el.position, state.position);\n        state.scale && vec2Copy(el.scale, state.scale);\n\n        if (state.rotation != null) {\n          el.rotation = state.rotation;\n        } // Style\n\n\n        if (state.style) {\n          var initialState = this._states[this._initialState];\n          el.style = new Style();\n\n          if (initialState) {\n            el.style.extendFrom(initialState.style, false);\n          }\n\n          if ( // Not initial state\n          name != this._initialState // Not copied from initial state in _extendFromInitial method\n          && initialState.style !== state.style) {\n            el.style.extendFrom(state.style, true);\n          }\n        }\n\n        if (state.shape) {\n          el.shape = zrUtil.clone(state.shape, true);\n        }\n\n        el.dirty();\n      }\n    }\n\n    for (var i = 0; i < this._subStates.length; i++) {\n      this._subStates.setState(name);\n    }\n  },\n  getState: function () {\n    return this._currentState;\n  },\n  transitionState: function (target, done) {\n    if (target === this._currentState && !this.transiting()) {\n      return;\n    }\n\n    var state = this._states[target];\n    var styleShapeReg = /$[style|shape]\\./;\n    var self = this; // Animation 去重\n\n    var propPathMap = {};\n\n    if (state) {\n      self._stopTransition();\n\n      var el = self._el;\n\n      if (state.transition && el && el.__zr) {\n        // El can be animated\n        var transitionCfg = state.transition;\n        var property = transitionCfg.property;\n        var animatingCount = 0;\n\n        var animationDone = function () {\n          animatingCount--;\n\n          if (animatingCount === 0) {\n            self.setState(target);\n            done && done();\n          }\n        };\n\n        for (var i = 0; i < property.length; i++) {\n          var propName = property[i]; // Animating all the properties in style or shape\n\n          if (propName === 'style' || propName === 'shape') {\n            if (state[propName]) {\n              for (var key in state[propName]) {\n                if (!state[propName].hasOwnProperty(key)) {\n                  continue;\n                }\n\n                var path = propName + '.' + key;\n\n                if (propPathMap[path]) {\n                  continue;\n                }\n\n                propPathMap[path] = 1;\n                animatingCount += self._animProp(state, propName, key, transitionCfg, animationDone);\n              }\n            }\n          } else {\n            if (propPathMap[propName]) {\n              continue;\n            }\n\n            propPathMap[propName] = 1; // Animating particular property in style or style\n\n            if (propName.match(styleShapeReg)) {\n              // remove 'style.', 'shape.' prefix\n              var subProp = propName.slice(0, 5);\n              propName = propName.slice(6);\n              animatingCount += self._animProp(state, subProp, propName, transitionCfg, animationDone);\n            } else {\n              animatingCount += self._animProp(state, '', propName, transitionCfg, animationDone);\n            }\n          }\n        } // No transition properties\n\n\n        if (animatingCount === 0) {\n          self.setState(target);\n          done && done();\n        }\n      } else {\n        self.setState(target);\n        done && done();\n      }\n    }\n\n    var subStates = self._subStates;\n\n    for (var i = 0; i < subStates.length; i++) {\n      subStates.transitionState(target);\n    }\n  },\n\n  /**\n   * Do transition animation of particular property\n   * @param {Object} state\n   * @param {string} subPropKey\n   * @param {string} key\n   * @param {Object} transitionCfg\n   * @param {Function} done\n   * @private\n   */\n  _animProp: function (state, subPropKey, key, transitionCfg, done) {\n    var el = this._el;\n    var stateObj = subPropKey ? state[subPropKey] : state;\n    var elObj = subPropKey ? el[subPropKey] : el;\n    var availableProp = stateObj && key in stateObj && elObj && key in elObj;\n    var transitionAnimators = this._transitionAnimators;\n\n    if (availableProp) {\n      var obj = {};\n\n      if (stateObj[key] === elObj[key]) {\n        return 0;\n      }\n\n      obj[key] = stateObj[key];\n      var animator = el.animate(subPropKey).when(transitionCfg.duration, obj).delay(transitionCfg.dealy).done(function () {\n        var idx = zrUtil.indexOf(transitionAnimators, 1);\n\n        if (idx > 0) {\n          transitionAnimators.splice(idx, 1);\n        }\n\n        done();\n      }).start(transitionCfg.easing);\n      transitionAnimators.push(animator);\n      return 1;\n    }\n\n    return 0;\n  },\n  _stopTransition: function () {\n    var transitionAnimators = this._transitionAnimators;\n\n    for (var i = 0; i < transitionAnimators.length; i++) {\n      transitionAnimators[i].stop();\n    }\n\n    transitionAnimators.length = 0;\n  },\n  transiting: function () {\n    return this._transitionAnimators.length > 0;\n  },\n  addSubStates: function (states) {\n    this._subStates.push(states);\n  },\n  removeSubStates: function (states) {\n    var idx = zrUtil.indexOf(this._subStates, states);\n\n    if (idx >= 0) {\n      this._subStates.splice(states, 1);\n    }\n  }\n};\nvar _default = GraphicStates;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/States.js\n// module id = 76\n// module chunks = 0","/**\r\n * 事件决策多边形\r\n * @module fish-topo-bo/node/EventDecisionNode\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n    var nodeOptions = null;\r\n\r\n    function EventDecisionNode(data, opts) {\r\n        nodeOptions = opts;\r\n\r\n        /**\r\n         * BO属性数据\r\n         * @type {Object}\r\n         * @private\r\n         */\r\n        this._data = data;\r\n\r\n        /**\r\n         * 起始位置坐标\r\n         * @type {startPos}\r\n         * @private\r\n         */\r\n        this._startPos = opts.startPos;\r\n\r\n        this._type = opts.type || 'boEvent';\r\n\r\n        /**\r\n         * 是否支持点击\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._clickable = opts.clickable || false;\r\n        this._popupOpts = opts.popupOpts;\r\n\r\n        /**\r\n         * Group容器\r\n         * @type zrender/graphic/Group\r\n         * @private\r\n         */\r\n        this._group = new graphic.Group();\r\n        this._group.name = this._data.id;\r\n\r\n        //生成BO属性图形\r\n        this._render();\r\n    }\r\n\r\n    var eventProto = EventDecisionNode.prototype;\r\n\r\n    /**\r\n     * 获取关系整体图形\r\n     * @returns {zrender/graphic/Group}\r\n     */\r\n    eventProto.getShape = function () {\r\n        return this._group;\r\n    };\r\n\r\n    /**\r\n     * 生成事件决策图形\r\n     * @private\r\n     */\r\n    eventProto._render = function () {\r\n        //多边形\r\n        this._createEventShape();\r\n        //文字\r\n        this._createEVentName();\r\n    };\r\n\r\n    /**\r\n     * 事件决策多边形\r\n     * @private\r\n     */\r\n    eventProto._createEventShape = function () {\r\n\r\n        //多边形高度\r\n        var height = Const.BO_EVENT_HEIGHT,\r\n            x = this._startPos.x + 1,\r\n            y = this._startPos.y,\r\n            width = this._type == 'boEvent' ? Const.BO_EVENT_WIDTH : Const.BO_ATTR_EVENT_WIDTH,\r\n\r\n            shape = new graphic.Polygon({\r\n                name: this._data.id,\r\n                shape: {\r\n                    points: [\r\n                        [x, y],\r\n                        [x + width - 10, y],\r\n                        [x + width, y + height / 2],\r\n                        [x + width - 10, y + height],\r\n                        [x, y + height]]\r\n                },\r\n\r\n                style: {\r\n                    fill: '#FFCCCC',\r\n                    stroke: '#000000',\r\n                    lineWidth: 0.75\r\n                }\r\n\r\n            });\r\n\r\n        if (this._clickable) {\r\n            shape.clickable = this._clickable;\r\n            shape._data = this._data;\r\n            shape._popupOpts = this._popupOpts;\r\n            shape.onclick = this._click;\r\n        }\r\n\r\n\r\n        this._group.add(shape);\r\n    };\r\n\r\n    /**\r\n     * 点击事件\r\n     * @private\r\n     */\r\n    eventProto._click = function () {\r\n        var options = Object.assign(\r\n            {\r\n                DATA: this._data\r\n            }, this._popupOpts);\r\n\r\n        nodeOptions.bindBoClickEvent(options);\r\n    };\r\n\r\n    /**\r\n     * 事件决策名称\r\n     * @private\r\n     */\r\n    eventProto._createEVentName = function () {\r\n        var x = this._startPos.x + (this._type == 'boEvent' ? Const.BO_ATTR_PADDING_LEFT : 15),\r\n            y = this._startPos.y,\r\n\r\n            eventNameShape = new graphic.Text({\r\n                style: {\r\n                    text: this._data.name,\r\n                    textFont: Const.BO_EVENT_FONT,\r\n                    textAlign: 'left',  //靠左开始，便于计算位置\r\n                    textBaseline: 'top'\r\n                },\r\n\r\n                position: [x, y]\r\n            });\r\n\r\n        if (this._clickable) {\r\n            eventNameShape.clickable = this._clickable;\r\n            eventNameShape._data = this._data;\r\n            eventNameShape._popupOpts = this._popupOpts;\r\n            eventNameShape.onclick = this._click;\r\n        }\r\n\r\n        this._group.add(eventNameShape);\r\n    };\r\n\r\n    module.exports = EventDecisionNode;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-bo/lib/node/EventDecisionNode.js\n// module id = 77\n// module chunks = 0","/**\r\n * BO矩形内部的横线，分为实线和虚线两种\r\n * @module fish-topo-bo/node/LineNode\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n\r\n    var Const = require('../models/Const');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n    var util = require('zrender/lib/core/util');\r\n    /**\r\n     * BO名字下面的实现\r\n     * @param {{x: *, y: *}} startPos, 开始坐标\r\n     * @returns {zrender/graphic/shape/Line}\r\n     * @constructor\r\n     */\r\n    function BoLine(startPos) {\r\n\r\n        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y};\r\n\r\n        return _line(startPos, endPos);\r\n    }\r\n\r\n    /**\r\n     * BO属性之间的虚线\r\n     * @param {{x: *, y: *}} startPos, 开始坐标\r\n     * @returns {zrender/graphic/shape/Line}\r\n     * @constructor\r\n     */\r\n    function AttrLine(startPos) {\r\n\r\n        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y},\r\n            style = {lineDash: [Const.LINE_DASH]};\r\n\r\n        return _line(startPos, endPos, style);\r\n    }\r\n\r\n    /**\r\n     * BO属性与BO事件决策之间的垂直虚线\r\n     * @param {{x: *, y: *}} startPos, 开始坐标\r\n     * @param {int} attrHeight, 高度\r\n     * @returns {zrender/graphic/shape/Line}\r\n     * @constructor\r\n     */\r\n    function AttrEventLine(startPos, attrHeight) {\r\n        var endPos = {x: startPos.x, y: startPos.y + attrHeight},\r\n            style = {lineDash: [Const.LINE_DASH]};\r\n\r\n        return _line(startPos, endPos, style);\r\n    }\r\n\r\n    /**\r\n     * 画线\r\n     * @param {{x: *, y: *}} startPos, 开始坐标\r\n     * @param {{x: *, y: *}} endPos, 结束坐标\r\n     * @param {Object} style, 样式,可空\r\n     * @returns {zrender/graphic/shape/Line}\r\n     * @private\r\n     */\r\n    function _line(startPos, endPos, style) {\r\n\r\n        var _style = {\r\n            strokeColor: '#000000',\r\n            lineWidth: 0.5,\r\n            percent: 1\r\n        };\r\n\r\n        util.extend(_style, style);\r\n\r\n        var shape = new graphic.Line({\r\n            shape: {\r\n                // Start point\r\n                x1: startPos.x,\r\n                y1: startPos.y,\r\n\r\n                // End point\r\n                x2: endPos.x,\r\n                y2: endPos.y,\r\n\r\n                percent: 1\r\n            },\r\n\r\n            style: _style\r\n        });\r\n\r\n        return shape;\r\n    }\r\n\r\n\r\n    module.exports = {\r\n        BoLine: BoLine,\r\n        AttrLine: AttrLine,\r\n        AttrEventLine: AttrEventLine\r\n    };\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-bo/lib/node/LineNode.js\n// module id = 78\n// module chunks = 0","/**\r\n * BO属性\r\n * 1.BO属性名字\r\n * 2.BO属性数据类型\r\n * 3.BO属性事件决策\r\n * @module fish-topo-bo/node/BoAttrNode\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var EventDecision = require('../node/EventDecisionNode');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n    var nodeOptions = null;\r\n\r\n    /**\r\n     *\r\n     * @param {{\r\n     *          id: String bo属性标识,\r\n     *          code: String bo属性编码\r\n     *          keyValue: boolean 是否为主键,\r\n     *          dataType: String 属性数据类型,\r\n     *          boAttrEventArr:[] 属性事件决策数组\r\n     *          }} boAttrData BO属性数据对象,\r\n     * @param {{\r\n     *          startPos: {x: number, y: number}起始位置,\r\n     *          displayDataType: boolean 是否显示数据类型,\r\n     *          displayEventDecision: boolean 是否显示事件决策,\r\n     *          eventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false,\r\n     *          eventPopupOpts: Object 点击BO属性事件决策弹出页面参数，url,width,height等,\r\n     *          }} opts\r\n     * @constructor\r\n     */\r\n    function BoAttr(boAttrData, opts) {\r\n        nodeOptions = opts;\r\n\r\n        /**\r\n         * BO属性数据\r\n         * @type {Object}\r\n         * @private\r\n         */\r\n        this._data = boAttrData;\r\n\r\n        /**\r\n         * 是否为主键\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._keyValue = boAttrData.keyValue || false;\r\n\r\n        /**\r\n         * 起始位置坐标\r\n         * @type {startPos}\r\n         * @private\r\n         */\r\n        this._startPos = opts.startPos;\r\n\r\n        /**\r\n         * 是否显示数据类型\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._displayDataType = opts.displayDataType || false;\r\n\r\n        /**\r\n         * 是否显示事件决策\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._displayEventDecision = opts.displayEventDecision || false;\r\n\r\n        /**\r\n         * 是否支持点击\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._eventClickable = opts.eventClickable || false;\r\n        this._eventPopupOpts = opts.eventPopupOpts;\r\n\r\n        /**\r\n         * Group容器\r\n         * @type zrender/graphic/Group\r\n         * @private\r\n         */\r\n        this._group = new graphic.Group();\r\n        this._group.name = this._data.id;\r\n\r\n        //生成BO属性图形\r\n        this._render();\r\n    }\r\n\r\n    var boAttrProto = BoAttr.prototype;\r\n\r\n    /**\r\n     * 获取关系整体图形\r\n     * @returns {zrender/graphic/Group}\r\n     */\r\n    boAttrProto.getShape = function () {\r\n        return this._group;\r\n    };\r\n\r\n\r\n    /**\r\n     * 生成BO属性图形\r\n     * @private\r\n     */\r\n    boAttrProto._render = function () {\r\n        //属性名字\r\n        this._createText();\r\n\r\n        //属性数据类型\r\n        this._createDataType();\r\n\r\n        //属性事件决策\r\n        this._createEventDecision();\r\n    };\r\n\r\n    /**\r\n     * 属性名字\r\n     * @private\r\n     */\r\n    boAttrProto._createText = function () {\r\n\r\n        var x = this._startPos.x + Const.BO_ATTR_PADDING_LEFT,\r\n            y = this._startPos.y,\r\n\r\n            attrNameShape = new graphic.Text({\r\n                style: {\r\n                    text: this._data.name,\r\n                    textFont: Const.BO_ATTR_FONT,\r\n                    textAlign: 'left',  //靠左开始，便于计算位置\r\n                    textBaseline: 'top',\r\n                    //lineWidth: 1,\r\n                    fill: this._keyValue ? 'red' : 'black'\r\n                },\r\n\r\n                position: [x, y]\r\n            });\r\n\r\n        //重新设置图形高度 = 文本高度 + padding-top + padding-bottom\r\n        attrNameShape.getBoundingRect().height += Const.BO_ATTR_PADDING_TOP + Const.BO_ATTR_PADDING_BOTTOM;\r\n        //重新设置图形高度 = BO矩形宽度，用于后续Relation画图计算\r\n        attrNameShape.getBoundingRect().width = Const.BO_NODE_WIDTH;\r\n\r\n        //重新设置B起始水平坐标 = 减去偏移量\r\n        attrNameShape.getBoundingRect().x += -Const.BO_ATTR_PADDING_LEFT;\r\n        //attrNameShape.getBoundingRect().y = + attrNameShape.position[1];\r\n\r\n        this._group.add(attrNameShape);\r\n    };\r\n\r\n    /**\r\n     * 属性数据类型\r\n     * @private\r\n     */\r\n    boAttrProto._createDataType = function () {\r\n        if (!this._displayDataType) {\r\n            return;\r\n        }\r\n\r\n        var x = this._startPos.x + Const.BO_NODE_WIDTH - 10,\r\n            y = this._startPos.y,\r\n            textAlign = 'right';\r\n\r\n        //如果还要显示事件决策，则宽度重新计算\r\n        if (this._displayEventDecision) {\r\n            textAlign = 'left';\r\n            x = this._startPos.x + Const.BO_NODE_WIDTH / 3;\r\n        }\r\n\r\n        var _dataTypeShape = new graphic.Text({\r\n            style: {\r\n                text: this._data.dataType || '',\r\n                textFont: Const.BO_ATTR_FONT,\r\n                textAlign: textAlign,  //靠左开始，便于计算位置\r\n                textBaseline: 'top',\r\n                lineWidth: 1\r\n            },\r\n\r\n            position: [x, y]\r\n        });\r\n\r\n        this._group.add(_dataTypeShape);\r\n    };\r\n\r\n    /**\r\n     * 属性事件决策\r\n     * @private\r\n     */\r\n    boAttrProto._createEventDecision = function () {\r\n        if (!this._displayEventDecision) {\r\n            return;\r\n        }\r\n\r\n        var _boAttrEventArr = this._data.boAttrEventArr || [],\r\n            _boAttrEventLen = _boAttrEventArr.length,\r\n            padding = (_boAttrEventLen > 1) ? 10 : 0,\r\n            _startPos = {\r\n                x: this._startPos.x + Const.BO_NODE_WIDTH / 2 + Const.BO_ATTR_EVENT_WIDTH * (_boAttrEventLen - 1) - padding,\r\n                y: this._startPos.y\r\n            };\r\n\r\n        //从右向左画，\r\n        for (var i = _boAttrEventLen - 1; i >= 0; i--) {\r\n            this._group.add(new EventDecision(_boAttrEventArr[i], {\r\n                startPos: _startPos,\r\n                type: 'boAttrEvent',\r\n                clickable: this._eventClickable,\r\n                popupOpts: this._eventPopupOpts,\r\n                bindBoClickEvent: nodeOptions.bindBoClickEvent\r\n            }).getShape());\r\n            _startPos = {x: _startPos.x - Const.BO_ATTR_EVENT_WIDTH + 10, y: _startPos.y};\r\n        }\r\n        /*_startPos = {\r\n         x: this._startPos.x + Const.BO_NODE_WIDTH / 2,\r\n         y: this._startPos.y};\r\n\r\n         for (var i = 0; i < _boAttrEventLen; i++) {\r\n         this._group.add(event.BoAttrEvent(_boAttrEventArr[i], _startPos, i + 2));\r\n         _startPos = {x: _startPos.x + Const.BO_ATTR_EVENT_WIDTH - 5, y: _startPos.y};\r\n         }*/\r\n\r\n\r\n    };\r\n\r\n    module.exports = BoAttr;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-bo/lib/node/BoAttrNode.js\n// module id = 79\n// module chunks = 0","/**\r\n * 用来创建关联关系\r\n * 关联关系包括折线、箭头、关系文字说明\r\n * @module fish-topo-bo/node/Relation\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    /**\r\n     *\r\n     * @param sourceShape, 开始图形\r\n     * @param targetShape, 目标图形\r\n     * @param {String} sourceText, 关系开始文字说明,可空\r\n     * @param {String} targetText, 关系结束文字说明,可空\r\n     * @param {String} lineStyle, 关联线样式\r\n     * @param {String} lineHoverStyle, 关联线hover样式\r\n     * @param {String} arrowStyle, 关联线箭头样式\r\n     * @param {String} arrowHoverStyle, 关联线箭头hover样式\r\n     * @constructor\r\n     */\r\n    function Relation(sourceShape, targetShape, sourceText, targetText, lineStyle, lineHoverStyle, arrowStyle, arrowHoverStyle) {\r\n        this._sourceText = sourceText;\r\n        this._targetText = targetText;\r\n\r\n        this._group = new graphic.Group();\r\n\r\n        //左侧开始位置\r\n        this._lStartPos = {\r\n            x: sourceShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,\r\n            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2\r\n        };\r\n\r\n        //左侧结束位置\r\n        this._lEndPos = {\r\n            x: targetShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,\r\n            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2\r\n        };\r\n\r\n        //右侧开始位置\r\n        this._rStartPos = {\r\n            x: sourceShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,\r\n            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2\r\n        };\r\n\r\n        //右侧结束位置\r\n        this._rEndPos = {\r\n            x: targetShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,\r\n            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2\r\n        };\r\n\r\n        //判断画线方向\r\n        this._leftDirection = this._lStartPos.x - this._lEndPos.x <= 0;\r\n\r\n        //关联线样式\r\n        this._lineStyle = lineStyle;\r\n\r\n        //关联线hover样式\r\n        this._lineHoverStyle = lineHoverStyle;\r\n\r\n        //关联线箭头样式\r\n        this._arrowStyle = arrowStyle;\r\n\r\n        //关联线箭头hover样式\r\n        this._arrowHoverStyle = arrowHoverStyle;\r\n\r\n        //生成图形\r\n        this._render();\r\n    }\r\n\r\n    var relationProto = Relation.prototype;\r\n\r\n    /**\r\n     * 获取关系整体图形\r\n     * @returns {*}\r\n     */\r\n    relationProto.getShape = function () {\r\n        return this._group;\r\n    };\r\n\r\n    /**\r\n     * 生成关系整体图形\r\n     * @private\r\n     */\r\n    relationProto._render = function () {\r\n        //画线\r\n        this._createLine();\r\n\r\n        //箭头\r\n        this._createArrow();\r\n\r\n        //关系说明文字\r\n        this._createText();\r\n\r\n    };\r\n\r\n    /**\r\n     * 生成关系折线\r\n     * @private\r\n     */\r\n    relationProto._createLine = function () {\r\n        var _linePoints = [];\r\n\r\n        if (this._leftDirection) {\r\n            //第一点\r\n            _linePoints.push([this._lStartPos.x, this._lStartPos.y]);\r\n            //第二点\r\n            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lStartPos.y]);\r\n            //第三点\r\n            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lEndPos.y]);\r\n            //第四点\r\n            _linePoints.push([this._lEndPos.x, this._lEndPos.y]);\r\n        }\r\n        else {\r\n            //第一点\r\n            _linePoints.push([this._rStartPos.x, this._rStartPos.y]);\r\n            //第二点\r\n            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._lStartPos.y]);\r\n            //第三点\r\n            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._rEndPos.y]);\r\n            //第四点\r\n            _linePoints.push([this._rEndPos.x, this._rEndPos.y]);\r\n        }\r\n\r\n        var _lineShape = new graphic.Polyline({\r\n            shape: {\r\n                points: _linePoints\r\n            },\r\n\r\n            style: {\r\n                //fill: 'blue',\r\n                stroke: this._lineStyle.stroke,\r\n                lineWidth: this._lineStyle.lineWidth,\r\n                lineDash: this._lineStyle.lineDash\r\n            }\r\n\r\n        });\r\n\r\n        this._group.add(_lineShape);\r\n\r\n        //线hover\r\n        this._createHoverStyle(_lineShape, this._lineHoverStyle);\r\n\r\n    };\r\n\r\n    /**\r\n     * 生成箭头图形\r\n     * @private\r\n     */\r\n    relationProto._createArrow = function () {\r\n        var _arrowPoints = [];\r\n\r\n        if (this._leftDirection) {\r\n            //右侧第一点\r\n            _arrowPoints.push([this._lEndPos.x, this._lEndPos.y]);\r\n            //下面第二点\r\n            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y + Const.RELATION_ARROW_HEIGHT]);\r\n            //上面第三点\r\n            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_ARROW_HEIGHT]);\r\n        }\r\n        else {\r\n            //左侧第一点\r\n            _arrowPoints.push([this._rEndPos.x, this._rEndPos.y]);\r\n            //下面第二点\r\n            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y + Const.RELATION_ARROW_HEIGHT]);\r\n            //上面第三点\r\n            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_ARROW_HEIGHT]);\r\n        }\r\n\r\n        var _arrowShape = new graphic.Polyline({\r\n            shape: {\r\n                points: _arrowPoints\r\n            },\r\n\r\n            style: {\r\n                fill: this._arrowStyle.fill,\r\n                stroke: this._arrowStyle.stroke\r\n            }\r\n        });\r\n\r\n        this._group.add(_arrowShape);\r\n\r\n        //箭头hover\r\n        this._createHoverStyle(_arrowShape, this._arrowHoverStyle);\r\n    };\r\n\r\n    /**\r\n     * 生成文字说明\r\n     * @private\r\n     */\r\n    relationProto._createText = function () {\r\n        var _sourceTextPos,\r\n            _targetTextPos,\r\n            _textAlign;\r\n\r\n        if (this._leftDirection) {\r\n            _sourceTextPos = [this._lStartPos.x - 10, this._lStartPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n            _targetTextPos = [this._lEndPos.x - 10 - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n            _textAlign = 'right';\r\n        }\r\n        else {\r\n            _sourceTextPos = [this._rStartPos.x + 10, this._rStartPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n            _targetTextPos = [this._rEndPos.x + 10 + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n            _textAlign = 'left';\r\n        }\r\n\r\n        //开始文字\r\n        if (this._sourceText) {\r\n            var _srcTextShape = new graphic.Text({\r\n                position: _sourceTextPos,\r\n\r\n                style: {\r\n                    text: this._sourceText,\r\n                    textFont: Const.BO_ATTR_FONT,\r\n                    textAlign: _textAlign,\r\n                    textBaseline: 'buttom',\r\n                    lineWidth: 1\r\n                }\r\n            });\r\n            this._group.add(_srcTextShape);\r\n        }\r\n\r\n        //结束文字\r\n        if (this._targetText) {\r\n            var _targetTextShape = new graphic.Text({\r\n                position: _targetTextPos,\r\n\r\n                style: {\r\n                    text: this._targetText,\r\n                    textFont: Const.BO_ATTR_FONT,\r\n                    textAlign: _textAlign,\r\n                    textBaseline: 'buttom',\r\n                    lineWidth: 1\r\n                }\r\n            });\r\n            this._group.add(_targetTextShape);\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * 关联线hover\r\n     * @private\r\n     */\r\n    relationProto._createHoverStyle = function (el, style) {\r\n        if (style) {\r\n            graphic.setElementHoverStl(el, style);\r\n            el.on('mouseover', zrUtil.bind(function() {\r\n                graphic.doEnterHover(el);\r\n                this._group.eachChild(function(line) {\r\n                    graphic.doEnterHover(line);\r\n                });\r\n            }, this))\r\n            .on('mouseout', zrUtil.bind(function() {\r\n                graphic.doLeaveHover(el);\r\n                this._group.eachChild(function(line) {\r\n                    graphic.doLeaveHover(line);\r\n                });\r\n            }, this));\r\n        }\r\n    };\r\n\r\n    module.exports = Relation;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-bo/lib/node/Relation.js\n// module id = 80\n// module chunks = 0","\r\n    if (typeof Object.assign != 'function') {\r\n        // Must be writable: true, enumerable: false, configurable: true\r\n        Object.defineProperty(Object, \"assign\", {\r\n            value: function assign(target, varArgs) { // .length of function is 2\r\n                'use strict';\r\n                if (target == null) { // TypeError if undefined or null\r\n                    throw new TypeError('Cannot convert undefined or null to object');\r\n                }\r\n\r\n                var to = Object(target);\r\n\r\n                for (var index = 1; index < arguments.length; index++) {\r\n                    var nextSource = arguments[index];\r\n\r\n                    if (nextSource != null) { // Skip over if undefined or null\r\n                    for (var nextKey in nextSource) {\r\n                        // Avoid bugs when hasOwnProperty is shadowed\r\n                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\r\n                        to[nextKey] = nextSource[nextKey];\r\n                        }\r\n                    }\r\n                    }\r\n                }\r\n                return to;\r\n            },\r\n            writable: true,\r\n            configurable: true\r\n        });\r\n    }\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/objectAssignPolyfill.js\n// module id = 81\n// module chunks = 0","require(\"./graphic\");\n\nvar _zrender = require(\"../zrender\");\n\nvar registerPainter = _zrender.registerPainter;\n\nvar Painter = require(\"./Painter\");\n\nregisterPainter('vml', Painter);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/vml/vml.js\n// module id = 82\n// module chunks = 0","var env = require(\"../core/env\");\n\nvar _vector = require(\"../core/vector\");\n\nvar applyTransform = _vector.applyTransform;\n\nvar BoundingRect = require(\"../core/BoundingRect\");\n\nvar colorTool = require(\"../tool/color\");\n\nvar textContain = require(\"../contain/text\");\n\nvar textHelper = require(\"../graphic/helper/text\");\n\nvar RectText = require(\"../graphic/mixin/RectText\");\n\nvar Displayable = require(\"../graphic/Displayable\");\n\nvar ZImage = require(\"../graphic/Image\");\n\nvar Text = require(\"../graphic/Text\");\n\nvar Path = require(\"../graphic/Path\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar Gradient = require(\"../graphic/Gradient\");\n\nvar vmlCore = require(\"./core\");\n\n// http://www.w3.org/TR/NOTE-VML\n// TODO Use proxy like svg instead of overwrite brush methods\nvar CMD = PathProxy.CMD;\nvar round = Math.round;\nvar sqrt = Math.sqrt;\nvar abs = Math.abs;\nvar cos = Math.cos;\nvar sin = Math.sin;\nvar mathMax = Math.max;\n\nif (!env.canvasSupported) {\n  var comma = ',';\n  var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n  var Z = 21600;\n  var Z2 = Z / 2;\n  var ZLEVEL_BASE = 100000;\n  var Z_BASE = 1000;\n\n  var initRootElStyle = function (el) {\n    el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n    el.coordsize = Z + ',' + Z;\n    el.coordorigin = '0,0';\n  };\n\n  var encodeHtmlAttribute = function (s) {\n    return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n  };\n\n  var rgb2Str = function (r, g, b) {\n    return 'rgb(' + [r, g, b].join(',') + ')';\n  };\n\n  var append = function (parent, child) {\n    if (child && parent && child.parentNode !== parent) {\n      parent.appendChild(child);\n    }\n  };\n\n  var remove = function (parent, child) {\n    if (child && parent && child.parentNode === parent) {\n      parent.removeChild(child);\n    }\n  };\n\n  var getZIndex = function (zlevel, z, z2) {\n    // z 的取值范围为 [0, 1000]\n    return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n  };\n\n  var parsePercent = function (value, maxValue) {\n    if (typeof value === 'string') {\n      if (value.lastIndexOf('%') >= 0) {\n        return parseFloat(value) / 100 * maxValue;\n      }\n\n      return parseFloat(value);\n    }\n\n    return value;\n  };\n  /***************************************************\n   * PATH\n   **************************************************/\n\n\n  var setColorAndOpacity = function (el, color, opacity) {\n    var colorArr = colorTool.parse(color);\n    opacity = +opacity;\n\n    if (isNaN(opacity)) {\n      opacity = 1;\n    }\n\n    if (colorArr) {\n      el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n      el.opacity = opacity * colorArr[3];\n    }\n  };\n\n  var getColorAndAlpha = function (color) {\n    var colorArr = colorTool.parse(color);\n    return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];\n  };\n\n  var updateFillNode = function (el, style, zrEl) {\n    // TODO pattern\n    var fill = style.fill;\n\n    if (fill != null) {\n      // Modified from excanvas\n      if (fill instanceof Gradient) {\n        var gradientType;\n        var angle = 0;\n        var focus = [0, 0]; // additional offset\n\n        var shift = 0; // scale factor for offset\n\n        var expansion = 1;\n        var rect = zrEl.getBoundingRect();\n        var rectWidth = rect.width;\n        var rectHeight = rect.height;\n\n        if (fill.type === 'linear') {\n          gradientType = 'gradient';\n          var transform = zrEl.transform;\n          var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n          var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n\n          if (transform) {\n            applyTransform(p0, p0, transform);\n            applyTransform(p1, p1, transform);\n          }\n\n          var dx = p1[0] - p0[0];\n          var dy = p1[1] - p0[1];\n          angle = Math.atan2(dx, dy) * 180 / Math.PI; // The angle should be a non-negative number.\n\n          if (angle < 0) {\n            angle += 360;\n          } // Very small angles produce an unexpected result because they are\n          // converted to a scientific notation string.\n\n\n          if (angle < 1e-6) {\n            angle = 0;\n          }\n        } else {\n          gradientType = 'gradientradial';\n          var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n          var transform = zrEl.transform;\n          var scale = zrEl.scale;\n          var width = rectWidth;\n          var height = rectHeight;\n          focus = [// Percent in bounding rect\n          (p0[0] - rect.x) / width, (p0[1] - rect.y) / height];\n\n          if (transform) {\n            applyTransform(p0, p0, transform);\n          }\n\n          width /= scale[0] * Z;\n          height /= scale[1] * Z;\n          var dimension = mathMax(width, height);\n          shift = 2 * 0 / dimension;\n          expansion = 2 * fill.r / dimension - shift;\n        } // We need to sort the color stops in ascending order by offset,\n        // otherwise IE won't interpret it correctly.\n\n\n        var stops = fill.colorStops.slice();\n        stops.sort(function (cs1, cs2) {\n          return cs1.offset - cs2.offset;\n        });\n        var length = stops.length; // Color and alpha list of first and last stop\n\n        var colorAndAlphaList = [];\n        var colors = [];\n\n        for (var i = 0; i < length; i++) {\n          var stop = stops[i];\n          var colorAndAlpha = getColorAndAlpha(stop.color);\n          colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n\n          if (i === 0 || i === length - 1) {\n            colorAndAlphaList.push(colorAndAlpha);\n          }\n        }\n\n        if (length >= 2) {\n          var color1 = colorAndAlphaList[0][0];\n          var color2 = colorAndAlphaList[1][0];\n          var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n          var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n          el.type = gradientType;\n          el.method = 'none';\n          el.focus = '100%';\n          el.angle = angle;\n          el.color = color1;\n          el.color2 = color2;\n          el.colors = colors.join(','); // When colors attribute is used, the meanings of opacity and o:opacity2\n          // are reversed.\n\n          el.opacity = opacity2; // FIXME g_o_:opacity ?\n\n          el.opacity2 = opacity1;\n        }\n\n        if (gradientType === 'radial') {\n          el.focusposition = focus.join(',');\n        }\n      } else {\n        // FIXME Change from Gradient fill to color fill\n        setColorAndOpacity(el, fill, style.opacity);\n      }\n    }\n  };\n\n  var updateStrokeNode = function (el, style) {\n    // if (style.lineJoin != null) {\n    //     el.joinstyle = style.lineJoin;\n    // }\n    // if (style.miterLimit != null) {\n    //     el.miterlimit = style.miterLimit * Z;\n    // }\n    // if (style.lineCap != null) {\n    //     el.endcap = style.lineCap;\n    // }\n    if (style.lineDash != null) {\n      el.dashstyle = style.lineDash.join(' ');\n    }\n\n    if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n      setColorAndOpacity(el, style.stroke, style.opacity);\n    }\n  };\n\n  var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n    var isFill = type == 'fill';\n    var el = vmlEl.getElementsByTagName(type)[0]; // Stroke must have lineWidth\n\n    if (style[type] != null && style[type] !== 'none' && (isFill || !isFill && style.lineWidth)) {\n      vmlEl[isFill ? 'filled' : 'stroked'] = 'true'; // FIXME Remove before updating, or set `colors` will throw error\n\n      if (style[type] instanceof Gradient) {\n        remove(vmlEl, el);\n      }\n\n      if (!el) {\n        el = vmlCore.createNode(type);\n      }\n\n      isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n      append(vmlEl, el);\n    } else {\n      vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n      remove(vmlEl, el);\n    }\n  };\n\n  var points = [[], [], []];\n\n  var pathDataToString = function (path, m) {\n    var M = CMD.M;\n    var C = CMD.C;\n    var L = CMD.L;\n    var A = CMD.A;\n    var Q = CMD.Q;\n    var str = [];\n    var nPoint;\n    var cmdStr;\n    var cmd;\n    var i;\n    var xi;\n    var yi;\n    var data = path.data;\n    var dataLength = path.len();\n\n    for (i = 0; i < dataLength;) {\n      cmd = data[i++];\n      cmdStr = '';\n      nPoint = 0;\n\n      switch (cmd) {\n        case M:\n          cmdStr = ' m ';\n          nPoint = 1;\n          xi = data[i++];\n          yi = data[i++];\n          points[0][0] = xi;\n          points[0][1] = yi;\n          break;\n\n        case L:\n          cmdStr = ' l ';\n          nPoint = 1;\n          xi = data[i++];\n          yi = data[i++];\n          points[0][0] = xi;\n          points[0][1] = yi;\n          break;\n\n        case Q:\n        case C:\n          cmdStr = ' c ';\n          nPoint = 3;\n          var x1 = data[i++];\n          var y1 = data[i++];\n          var x2 = data[i++];\n          var y2 = data[i++];\n          var x3;\n          var y3;\n\n          if (cmd === Q) {\n            // Convert quadratic to cubic using degree elevation\n            x3 = x2;\n            y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (xi + 2 * x1) / 3;\n            y1 = (yi + 2 * y1) / 3;\n          } else {\n            x3 = data[i++];\n            y3 = data[i++];\n          }\n\n          points[0][0] = x1;\n          points[0][1] = y1;\n          points[1][0] = x2;\n          points[1][1] = y2;\n          points[2][0] = x3;\n          points[2][1] = y3;\n          xi = x3;\n          yi = y3;\n          break;\n\n        case A:\n          var x = 0;\n          var y = 0;\n          var sx = 1;\n          var sy = 1;\n          var angle = 0;\n\n          if (m) {\n            // Extract SRT from matrix\n            x = m[4];\n            y = m[5];\n            sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n            sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n            angle = Math.atan2(-m[1] / sy, m[0] / sx);\n          }\n\n          var cx = data[i++];\n          var cy = data[i++];\n          var rx = data[i++];\n          var ry = data[i++];\n          var startAngle = data[i++] + angle;\n          var endAngle = data[i++] + startAngle + angle; // FIXME\n          // var psi = data[i++];\n\n          i++;\n          var clockwise = data[i++];\n          var x0 = cx + cos(startAngle) * rx;\n          var y0 = cy + sin(startAngle) * ry;\n          var x1 = cx + cos(endAngle) * rx;\n          var y1 = cy + sin(endAngle) * ry;\n          var type = clockwise ? ' wa ' : ' at ';\n\n          if (Math.abs(x0 - x1) < 1e-4) {\n            // IE won't render arches drawn counter clockwise if x0 == x1.\n            if (Math.abs(endAngle - startAngle) > 1e-2) {\n              // Offset x0 by 1/80 of a pixel. Use something\n              // that can be represented in binary\n              if (clockwise) {\n                x0 += 270 / Z;\n              }\n            } else {\n              // Avoid case draw full circle\n              if (Math.abs(y0 - cy) < 1e-4) {\n                if (clockwise && x0 < cx || !clockwise && x0 > cx) {\n                  y1 -= 270 / Z;\n                } else {\n                  y1 += 270 / Z;\n                }\n              } else if (clockwise && y0 < cy || !clockwise && y0 > cy) {\n                x1 += 270 / Z;\n              } else {\n                x1 -= 270 / Z;\n              }\n            }\n          }\n\n          str.push(type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2));\n          xi = x1;\n          yi = y1;\n          break;\n\n        case CMD.R:\n          var p0 = points[0];\n          var p1 = points[1]; // x0, y0\n\n          p0[0] = data[i++];\n          p0[1] = data[i++]; // x1, y1\n\n          p1[0] = p0[0] + data[i++];\n          p1[1] = p0[1] + data[i++];\n\n          if (m) {\n            applyTransform(p0, p0, m);\n            applyTransform(p1, p1, m);\n          }\n\n          p0[0] = round(p0[0] * Z - Z2);\n          p1[0] = round(p1[0] * Z - Z2);\n          p0[1] = round(p0[1] * Z - Z2);\n          p1[1] = round(p1[1] * Z - Z2);\n          str.push( // x0, y0\n          ' m ', p0[0], comma, p0[1], // x1, y0\n          ' l ', p1[0], comma, p0[1], // x1, y1\n          ' l ', p1[0], comma, p1[1], // x0, y1\n          ' l ', p0[0], comma, p1[1]);\n          break;\n\n        case CMD.Z:\n          // FIXME Update xi, yi\n          str.push(' x ');\n      }\n\n      if (nPoint > 0) {\n        str.push(cmdStr);\n\n        for (var k = 0; k < nPoint; k++) {\n          var p = points[k];\n          m && applyTransform(p, p, m); // 不 round 会非常慢\n\n          str.push(round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k < nPoint - 1 ? comma : '');\n        }\n      }\n    }\n\n    return str.join('');\n  }; // Rewrite the original path method\n\n\n  Path.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n    var vmlEl = this._vmlEl;\n\n    if (!vmlEl) {\n      vmlEl = vmlCore.createNode('shape');\n      initRootElStyle(vmlEl);\n      this._vmlEl = vmlEl;\n    }\n\n    updateFillAndStroke(vmlEl, 'fill', style, this);\n    updateFillAndStroke(vmlEl, 'stroke', style, this);\n    var m = this.transform;\n    var needTransform = m != null;\n    var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n\n    if (strokeEl) {\n      var lineWidth = style.lineWidth; // Get the line scale.\n      // Determinant of this.m_ means how much the area is enlarged by the\n      // transformation. So its square root can be used as a scale factor\n      // for width.\n\n      if (needTransform && !style.strokeNoScale) {\n        var det = m[0] * m[3] - m[1] * m[2];\n        lineWidth *= sqrt(abs(det));\n      }\n\n      strokeEl.weight = lineWidth + 'px';\n    }\n\n    var path = this.path || (this.path = new PathProxy());\n\n    if (this.__dirtyPath) {\n      path.beginPath();\n      this.buildPath(path, this.shape);\n      path.toStatic();\n      this.__dirtyPath = false;\n    }\n\n    vmlEl.path = pathDataToString(path, this.transform);\n    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\n    append(vmlRoot, vmlEl); // Text\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, this.getBoundingRect());\n    } else {\n      this.removeRectText(vmlRoot);\n    }\n  };\n\n  Path.prototype.onRemove = function (vmlRoot) {\n    remove(vmlRoot, this._vmlEl);\n    this.removeRectText(vmlRoot);\n  };\n\n  Path.prototype.onAdd = function (vmlRoot) {\n    append(vmlRoot, this._vmlEl);\n    this.appendRectText(vmlRoot);\n  };\n  /***************************************************\n   * IMAGE\n   **************************************************/\n\n\n  var isImage = function (img) {\n    // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错\n    return typeof img === 'object' && img.tagName && img.tagName.toUpperCase() === 'IMG'; // return img instanceof Image;\n  }; // Rewrite the original path method\n\n\n  ZImage.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n    var image = style.image; // Image original width, height\n\n    var ow;\n    var oh;\n\n    if (isImage(image)) {\n      var src = image.src;\n\n      if (src === this._imageSrc) {\n        ow = this._imageWidth;\n        oh = this._imageHeight;\n      } else {\n        var imageRuntimeStyle = image.runtimeStyle;\n        var oldRuntimeWidth = imageRuntimeStyle.width;\n        var oldRuntimeHeight = imageRuntimeStyle.height;\n        imageRuntimeStyle.width = 'auto';\n        imageRuntimeStyle.height = 'auto'; // get the original size\n\n        ow = image.width;\n        oh = image.height; // and remove overides\n\n        imageRuntimeStyle.width = oldRuntimeWidth;\n        imageRuntimeStyle.height = oldRuntimeHeight; // Caching image original width, height and src\n\n        this._imageSrc = src;\n        this._imageWidth = ow;\n        this._imageHeight = oh;\n      }\n\n      image = src;\n    } else {\n      if (image === this._imageSrc) {\n        ow = this._imageWidth;\n        oh = this._imageHeight;\n      }\n    }\n\n    if (!image) {\n      return;\n    }\n\n    var x = style.x || 0;\n    var y = style.y || 0;\n    var dw = style.width;\n    var dh = style.height;\n    var sw = style.sWidth;\n    var sh = style.sHeight;\n    var sx = style.sx || 0;\n    var sy = style.sy || 0;\n    var hasCrop = sw && sh;\n    var vmlEl = this._vmlEl;\n\n    if (!vmlEl) {\n      // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。\n      // vmlEl = vmlCore.createNode('group');\n      vmlEl = vmlCore.doc.createElement('div');\n      initRootElStyle(vmlEl);\n      this._vmlEl = vmlEl;\n    }\n\n    var vmlElStyle = vmlEl.style;\n    var hasRotation = false;\n    var m;\n    var scaleX = 1;\n    var scaleY = 1;\n\n    if (this.transform) {\n      m = this.transform;\n      scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n      scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n      hasRotation = m[1] || m[2];\n    }\n\n    if (hasRotation) {\n      // If filters are necessary (rotation exists), create them\n      // filters are bog-slow, so only create them if abbsolutely necessary\n      // The following check doesn't account for skews (which don't exist\n      // in the canvas spec (yet) anyway.\n      // From excanvas\n      var p0 = [x, y];\n      var p1 = [x + dw, y];\n      var p2 = [x, y + dh];\n      var p3 = [x + dw, y + dh];\n      applyTransform(p0, p0, m);\n      applyTransform(p1, p1, m);\n      applyTransform(p2, p2, m);\n      applyTransform(p3, p3, m);\n      var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n      var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n      var transformFilter = [];\n      transformFilter.push('M11=', m[0] / scaleX, comma, 'M12=', m[2] / scaleY, comma, 'M21=', m[1] / scaleX, comma, 'M22=', m[3] / scaleY, comma, 'Dx=', round(x * scaleX + m[4]), comma, 'Dy=', round(y * scaleY + m[5]));\n      vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0'; // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用\n\n      vmlElStyle.filter = imageTransformPrefix + '.Matrix(' + transformFilter.join('') + ', SizingMethod=clip)';\n    } else {\n      if (m) {\n        x = x * scaleX + m[4];\n        y = y * scaleY + m[5];\n      }\n\n      vmlElStyle.filter = '';\n      vmlElStyle.left = round(x) + 'px';\n      vmlElStyle.top = round(y) + 'px';\n    }\n\n    var imageEl = this._imageEl;\n    var cropEl = this._cropEl;\n\n    if (!imageEl) {\n      imageEl = vmlCore.doc.createElement('div');\n      this._imageEl = imageEl;\n    }\n\n    var imageELStyle = imageEl.style;\n\n    if (hasCrop) {\n      // Needs know image original width and height\n      if (!(ow && oh)) {\n        var tmpImage = new Image();\n        var self = this;\n\n        tmpImage.onload = function () {\n          tmpImage.onload = null;\n          ow = tmpImage.width;\n          oh = tmpImage.height; // Adjust image width and height to fit the ratio destinationSize / sourceSize\n\n          imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n          imageELStyle.height = round(scaleY * oh * dh / sh) + 'px'; // Caching image original width, height and src\n\n          self._imageWidth = ow;\n          self._imageHeight = oh;\n          self._imageSrc = image;\n        };\n\n        tmpImage.src = image;\n      } else {\n        imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n        imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n      }\n\n      if (!cropEl) {\n        cropEl = vmlCore.doc.createElement('div');\n        cropEl.style.overflow = 'hidden';\n        this._cropEl = cropEl;\n      }\n\n      var cropElStyle = cropEl.style;\n      cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n      cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n      cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx=' + -sx * dw / sw * scaleX + ',Dy=' + -sy * dh / sh * scaleY + ')';\n\n      if (!cropEl.parentNode) {\n        vmlEl.appendChild(cropEl);\n      }\n\n      if (imageEl.parentNode != cropEl) {\n        cropEl.appendChild(imageEl);\n      }\n    } else {\n      imageELStyle.width = round(scaleX * dw) + 'px';\n      imageELStyle.height = round(scaleY * dh) + 'px';\n      vmlEl.appendChild(imageEl);\n\n      if (cropEl && cropEl.parentNode) {\n        vmlEl.removeChild(cropEl);\n        this._cropEl = null;\n      }\n    }\n\n    var filterStr = '';\n    var alpha = style.opacity;\n\n    if (alpha < 1) {\n      filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n    }\n\n    filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n    imageELStyle.filter = filterStr;\n    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\n    append(vmlRoot, vmlEl); // Text\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, this.getBoundingRect());\n    }\n  };\n\n  ZImage.prototype.onRemove = function (vmlRoot) {\n    remove(vmlRoot, this._vmlEl);\n    this._vmlEl = null;\n    this._cropEl = null;\n    this._imageEl = null;\n    this.removeRectText(vmlRoot);\n  };\n\n  ZImage.prototype.onAdd = function (vmlRoot) {\n    append(vmlRoot, this._vmlEl);\n    this.appendRectText(vmlRoot);\n  };\n  /***************************************************\n   * TEXT\n   **************************************************/\n\n\n  var DEFAULT_STYLE_NORMAL = 'normal';\n  var fontStyleCache = {};\n  var fontStyleCacheCount = 0;\n  var MAX_FONT_CACHE_SIZE = 100;\n  var fontEl = document.createElement('div');\n\n  var getFontStyle = function (fontString) {\n    var fontStyle = fontStyleCache[fontString];\n\n    if (!fontStyle) {\n      // Clear cache\n      if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n        fontStyleCacheCount = 0;\n        fontStyleCache = {};\n      }\n\n      var style = fontEl.style;\n      var fontFamily;\n\n      try {\n        style.font = fontString;\n        fontFamily = style.fontFamily.split(',')[0];\n      } catch (e) {}\n\n      fontStyle = {\n        style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n        variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n        weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n        size: parseFloat(style.fontSize || 12) | 0,\n        family: fontFamily || 'Microsoft YaHei'\n      };\n      fontStyleCache[fontString] = fontStyle;\n      fontStyleCacheCount++;\n    }\n\n    return fontStyle;\n  };\n\n  var textMeasureEl; // Overwrite measure text method\n\n  textContain.$override('measureText', function (text, textFont) {\n    var doc = vmlCore.doc;\n\n    if (!textMeasureEl) {\n      textMeasureEl = doc.createElement('div');\n      textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;' + 'padding:0;margin:0;border:none;white-space:pre;';\n      vmlCore.doc.body.appendChild(textMeasureEl);\n    }\n\n    try {\n      textMeasureEl.style.font = textFont;\n    } catch (ex) {// Ignore failures to set to invalid font.\n    }\n\n    textMeasureEl.innerHTML = ''; // Don't use innerHTML or innerText because they allow markup/whitespace.\n\n    textMeasureEl.appendChild(doc.createTextNode(text));\n    return {\n      width: textMeasureEl.offsetWidth\n    };\n  });\n  var tmpRect = new BoundingRect();\n\n  var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true);\n    var text = style.text; // Convert to string\n\n    text != null && (text += '');\n\n    if (!text) {\n      return;\n    } // Convert rich text to plain text. Rich text is not supported in\n    // IE8-, but tags in rich text template will be removed.\n\n\n    if (style.rich) {\n      var contentBlock = textContain.parseRichText(text, style);\n      text = [];\n\n      for (var i = 0; i < contentBlock.lines.length; i++) {\n        var tokens = contentBlock.lines[i].tokens;\n        var textLine = [];\n\n        for (var j = 0; j < tokens.length; j++) {\n          textLine.push(tokens[j].text);\n        }\n\n        text.push(textLine.join(''));\n      }\n\n      text = text.join('\\n');\n    }\n\n    var x;\n    var y;\n    var align = style.textAlign;\n    var verticalAlign = style.textVerticalAlign;\n    var fontStyle = getFontStyle(style.font); // FIXME encodeHtmlAttribute ?\n\n    var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' ' + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n    textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign); // Transform rect to view space\n\n    var m = this.transform; // Ignore transform for text in other element\n\n    if (m && !fromTextEl) {\n      tmpRect.copy(rect);\n      tmpRect.applyTransform(m);\n      rect = tmpRect;\n    }\n\n    if (!fromTextEl) {\n      var textPosition = style.textPosition;\n      var distance = style.textDistance; // Text position represented by coord\n\n      if (textPosition instanceof Array) {\n        x = rect.x + parsePercent(textPosition[0], rect.width);\n        y = rect.y + parsePercent(textPosition[1], rect.height);\n        align = align || 'left';\n      } else {\n        var res = textContain.adjustTextPositionOnRect(textPosition, rect, distance);\n        x = res.x;\n        y = res.y; // Default align and baseline when has textPosition\n\n        align = align || res.textAlign;\n        verticalAlign = verticalAlign || res.textVerticalAlign;\n      }\n    } else {\n      x = rect.x;\n      y = rect.y;\n    }\n\n    x = textContain.adjustTextX(x, textRect.width, align);\n    y = textContain.adjustTextY(y, textRect.height, verticalAlign); // Force baseline 'middle'\n\n    y += textRect.height / 2; // var fontSize = fontStyle.size;\n    // 1.75 is an arbitrary number, as there is no info about the text baseline\n    // switch (baseline) {\n    // case 'hanging':\n    // case 'top':\n    //     y += fontSize / 1.75;\n    //     break;\n    //     case 'middle':\n    //         break;\n    //     default:\n    //     // case null:\n    //     // case 'alphabetic':\n    //     // case 'ideographic':\n    //     // case 'bottom':\n    //         y -= fontSize / 2.25;\n    //         break;\n    // }\n    // switch (align) {\n    //     case 'left':\n    //         break;\n    //     case 'center':\n    //         x -= textRect.width / 2;\n    //         break;\n    //     case 'right':\n    //         x -= textRect.width;\n    //         break;\n    // case 'end':\n    // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n    // break;\n    // case 'start':\n    // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n    // break;\n    // default:\n    //     align = 'left';\n    // }\n\n    var createNode = vmlCore.createNode;\n    var textVmlEl = this._textVmlEl;\n    var pathEl;\n    var textPathEl;\n    var skewEl;\n\n    if (!textVmlEl) {\n      textVmlEl = createNode('line');\n      pathEl = createNode('path');\n      textPathEl = createNode('textpath');\n      skewEl = createNode('skew'); // FIXME Why here is not cammel case\n      // Align 'center' seems wrong\n\n      textPathEl.style['v-text-align'] = 'left';\n      initRootElStyle(textVmlEl);\n      pathEl.textpathok = true;\n      textPathEl.on = true;\n      textVmlEl.from = '0 0';\n      textVmlEl.to = '1000 0.05';\n      append(textVmlEl, skewEl);\n      append(textVmlEl, pathEl);\n      append(textVmlEl, textPathEl);\n      this._textVmlEl = textVmlEl;\n    } else {\n      // 这里是在前面 appendChild 保证顺序的前提下\n      skewEl = textVmlEl.firstChild;\n      pathEl = skewEl.nextSibling;\n      textPathEl = pathEl.nextSibling;\n    }\n\n    var coords = [x, y];\n    var textVmlElStyle = textVmlEl.style; // Ignore transform for text in other element\n\n    if (m && fromTextEl) {\n      applyTransform(coords, coords, m);\n      skewEl.on = true;\n      skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0'; // Text position\n\n      skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0); // Left top point as origin\n\n      skewEl.origin = '0 0';\n      textVmlElStyle.left = '0px';\n      textVmlElStyle.top = '0px';\n    } else {\n      skewEl.on = false;\n      textVmlElStyle.left = round(x) + 'px';\n      textVmlElStyle.top = round(y) + 'px';\n    }\n\n    textPathEl.string = encodeHtmlAttribute(text); // TODO\n\n    try {\n      textPathEl.style.font = font;\n    } // Error font format\n    catch (e) {}\n\n    updateFillAndStroke(textVmlEl, 'fill', {\n      fill: style.textFill,\n      opacity: style.opacity\n    }, this);\n    updateFillAndStroke(textVmlEl, 'stroke', {\n      stroke: style.textStroke,\n      opacity: style.opacity,\n      lineDash: style.lineDash\n    }, this);\n    textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Attached to root\n\n    append(vmlRoot, textVmlEl);\n  };\n\n  var removeRectText = function (vmlRoot) {\n    remove(vmlRoot, this._textVmlEl);\n    this._textVmlEl = null;\n  };\n\n  var appendRectText = function (vmlRoot) {\n    append(vmlRoot, this._textVmlEl);\n  };\n\n  var list = [RectText, Displayable, ZImage, Path, Text]; // In case Displayable has been mixed in RectText\n\n  for (var i = 0; i < list.length; i++) {\n    var proto = list[i].prototype;\n    proto.drawRectText = drawRectText;\n    proto.removeRectText = removeRectText;\n    proto.appendRectText = appendRectText;\n  }\n\n  Text.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, {\n        x: style.x || 0,\n        y: style.y || 0,\n        width: 0,\n        height: 0\n      }, this.getBoundingRect(), true);\n    } else {\n      this.removeRectText(vmlRoot);\n    }\n  };\n\n  Text.prototype.onRemove = function (vmlRoot) {\n    this.removeRectText(vmlRoot);\n  };\n\n  Text.prototype.onAdd = function (vmlRoot) {\n    this.appendRectText(vmlRoot);\n  };\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/vml/graphic.js\n// module id = 83\n// module chunks = 0","var env = require(\"../core/env\");\n\nvar urn = 'urn:schemas-microsoft-com:vml';\nvar win = typeof window === 'undefined' ? null : window;\nvar vmlInited = false;\nvar doc = win && win.document;\n\nfunction createNode(tagName) {\n  return doCreateNode(tagName);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nvar doCreateNode;\n\nif (doc && !env.canvasSupported) {\n  try {\n    !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);\n\n    doCreateNode = function (tagName) {\n      return doc.createElement('<zrvml:' + tagName + ' class=\"zrvml\">');\n    };\n  } catch (e) {\n    doCreateNode = function (tagName) {\n      return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"zrvml\">');\n    };\n  }\n} // From raphael\n\n\nfunction initVML() {\n  if (vmlInited || !doc) {\n    return;\n  }\n\n  vmlInited = true;\n  var styleSheets = doc.styleSheets;\n\n  if (styleSheets.length < 31) {\n    doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');\n  } else {\n    // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n    styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');\n  }\n}\n\nexports.doc = doc;\nexports.createNode = createNode;\nexports.initVML = initVML;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/vml/core.js\n// module id = 84\n// module chunks = 0","var zrLog = require(\"../core/log\");\n\nvar vmlCore = require(\"./core\");\n\nvar _util = require(\"../core/util\");\n\nvar each = _util.each;\n\n/**\n * VML Painter.\n *\n * @module zrender/vml/Painter\n */\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n/**\n * @alias module:zrender/vml/Painter\n */\n\n\nfunction VMLPainter(root, storage) {\n  vmlCore.initVML();\n  this.root = root;\n  this.storage = storage;\n  var vmlViewport = document.createElement('div');\n  var vmlRoot = document.createElement('div');\n  vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n  vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n  root.appendChild(vmlViewport);\n  this._vmlRoot = vmlRoot;\n  this._vmlViewport = vmlViewport;\n  this.resize(); // Modify storage\n\n  var oldDelFromStorage = storage.delFromStorage;\n  var oldAddToStorage = storage.addToStorage;\n\n  storage.delFromStorage = function (el) {\n    oldDelFromStorage.call(storage, el);\n\n    if (el) {\n      el.onRemove && el.onRemove(vmlRoot);\n    }\n  };\n\n  storage.addToStorage = function (el) {\n    // Displayable already has a vml node\n    el.onAdd && el.onAdd(vmlRoot);\n    oldAddToStorage.call(storage, el);\n  };\n\n  this._firstPaint = true;\n}\n\nVMLPainter.prototype = {\n  constructor: VMLPainter,\n  getType: function () {\n    return 'vml';\n  },\n\n  /**\n   * @return {HTMLDivElement}\n   */\n  getViewportRoot: function () {\n    return this._vmlViewport;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\n   * 刷新\n   */\n  refresh: function () {\n    var list = this.storage.getDisplayList(true, true);\n\n    this._paintList(list);\n  },\n  _paintList: function (list) {\n    var vmlRoot = this._vmlRoot;\n\n    for (var i = 0; i < list.length; i++) {\n      var el = list[i];\n\n      if (el.invisible || el.ignore) {\n        if (!el.__alreadyNotVisible) {\n          el.onRemove(vmlRoot);\n        } // Set as already invisible\n\n\n        el.__alreadyNotVisible = true;\n      } else {\n        if (el.__alreadyNotVisible) {\n          el.onAdd(vmlRoot);\n        }\n\n        el.__alreadyNotVisible = false;\n\n        if (el.__dirty) {\n          el.beforeBrush && el.beforeBrush();\n          (el.brushVML || el.brush).call(el, vmlRoot);\n          el.afterBrush && el.afterBrush();\n        }\n      }\n\n      el.__dirty = false;\n    }\n\n    if (this._firstPaint) {\n      // Detached from document at first time\n      // to avoid page refreshing too many times\n      // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变\n      this._vmlViewport.appendChild(vmlRoot);\n\n      this._firstPaint = false;\n    }\n  },\n  resize: function (width, height) {\n    var width = width == null ? this._getWidth() : width;\n    var height = height == null ? this._getHeight() : height;\n\n    if (this._width != width || this._height != height) {\n      this._width = width;\n      this._height = height;\n      var vmlViewportStyle = this._vmlViewport.style;\n      vmlViewportStyle.width = width + 'px';\n      vmlViewportStyle.height = height + 'px';\n    }\n  },\n  dispose: function () {\n    this.root.innerHTML = '';\n    this._vmlRoot = this._vmlViewport = this.storage = null;\n  },\n  getWidth: function () {\n    return this._width;\n  },\n  getHeight: function () {\n    return this._height;\n  },\n  clear: function () {\n    if (this._vmlViewport) {\n      this.root.removeChild(this._vmlViewport);\n    }\n  },\n  _getWidth: function () {\n    var root = this.root;\n    var stl = root.currentStyle;\n    return (root.clientWidth || parseInt10(stl.width)) - parseInt10(stl.paddingLeft) - parseInt10(stl.paddingRight) | 0;\n  },\n  _getHeight: function () {\n    var root = this.root;\n    var stl = root.currentStyle;\n    return (root.clientHeight || parseInt10(stl.height)) - parseInt10(stl.paddingTop) - parseInt10(stl.paddingBottom) | 0;\n  }\n}; // Not supported methods\n\nfunction createMethodNotSupport(method) {\n  return function () {\n    zrLog('In IE8.0 VML mode painter not support method \"' + method + '\"');\n  };\n} // Unsupported methods\n\n\neach(['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'], function (name) {\n  VMLPainter.prototype[name] = createMethodNotSupport(name);\n});\nvar _default = VMLPainter;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/vml/Painter.js\n// module id = 85\n// module chunks = 0"]}