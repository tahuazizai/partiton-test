{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","fish-topo-link.js","webpack:/webpack/bootstrap 506eeb1e17483ee3fa0b","webpack:///index.link.js","webpack:///lib/fish-topo-link/lib/FishTopoLink.js","webpack:///lib/fish-topo-core/lib/graphic.js","webpack:///~/zrender/lib/core/util.js","webpack:///~/zrender/lib/tool/path.js","webpack:///~/zrender/lib/graphic/Path.js","webpack:///~/zrender/lib/graphic/Displayable.js","webpack:///~/zrender/lib/graphic/Style.js","webpack:///~/zrender/lib/Element.js","webpack:///~/zrender/lib/core/guid.js","webpack:///~/zrender/lib/mixin/Eventful.js","webpack:///~/zrender/lib/mixin/Transformable.js","webpack:///~/zrender/lib/core/matrix.js","webpack:///~/zrender/lib/core/vector.js","webpack:///~/zrender/lib/mixin/Animatable.js","webpack:///~/zrender/lib/animation/Animator.js","webpack:///~/zrender/lib/animation/Clip.js","webpack:///~/zrender/lib/animation/easing.js","webpack:///~/zrender/lib/tool/color.js","webpack:///~/zrender/lib/core/LRU.js","webpack:///~/zrender/lib/core/log.js","webpack:///~/zrender/lib/config.js","webpack:///~/zrender/lib/graphic/mixin/RectText.js","webpack:///~/zrender/lib/graphic/helper/text.js","webpack:///~/zrender/lib/contain/text.js","webpack:///~/zrender/lib/core/BoundingRect.js","webpack:///~/zrender/lib/graphic/helper/image.js","webpack:///~/zrender/lib/graphic/helper/roundRect.js","webpack:///~/zrender/lib/core/PathProxy.js","webpack:///~/zrender/lib/core/curve.js","webpack:///~/zrender/lib/core/bbox.js","webpack:///~/zrender/lib/contain/path.js","webpack:///~/zrender/lib/contain/line.js","webpack:///~/zrender/lib/contain/cubic.js","webpack:///~/zrender/lib/contain/quadratic.js","webpack:///~/zrender/lib/contain/arc.js","webpack:///~/zrender/lib/contain/util.js","webpack:///~/zrender/lib/contain/windingLine.js","webpack:///~/zrender/lib/graphic/Pattern.js","webpack:///~/zrender/lib/tool/transformPath.js","webpack:///~/zrender/lib/graphic/Gradient.js","webpack:///~/zrender/lib/mixin/Draggable.js","webpack:///~/zrender/lib/container/Group.js","webpack:///~/zrender/lib/graphic/Image.js","webpack:///~/zrender/lib/graphic/Text.js","webpack:///~/zrender/lib/graphic/shape/Circle.js","webpack:///~/zrender/lib/graphic/shape/Sector.js","webpack:///~/zrender/lib/graphic/helper/fixClipWithShadow.js","webpack:///~/zrender/lib/core/env.js","webpack:///~/zrender/lib/graphic/shape/Ring.js","webpack:///~/zrender/lib/graphic/shape/Polygon.js","webpack:///~/zrender/lib/graphic/helper/poly.js","webpack:///~/zrender/lib/graphic/helper/smoothSpline.js","webpack:///~/zrender/lib/graphic/helper/smoothBezier.js","webpack:///~/zrender/lib/graphic/shape/Polyline.js","webpack:///~/zrender/lib/graphic/shape/Rect.js","webpack:///~/zrender/lib/graphic/shape/Line.js","webpack:///~/zrender/lib/graphic/shape/BezierCurve.js","webpack:///~/zrender/lib/graphic/shape/Arc.js","webpack:///~/zrender/lib/graphic/LinearGradient.js","webpack:///~/zrender/lib/graphic/RadialGradient.js","webpack:///~/zrender/lib/graphic/States.js","webpack:///lib/fish-topo-core/lib/util.js","webpack:///lib/fish-topo-core/lib/Point.js","webpack:///lib/fish-topo-core/lib/LineStruct.js","webpack:///lib/fish-topo-link/lib/ExtensionApi.js","webpack:///~/zrender/lib/zrender.js","webpack:///~/zrender/lib/Handler.js","webpack:///~/zrender/lib/Storage.js","webpack:///~/zrender/lib/core/timsort.js","webpack:///~/zrender/lib/Painter.js","webpack:///~/zrender/lib/Layer.js","webpack:///~/zrender/lib/animation/requestAnimationFrame.js","webpack:///~/zrender/lib/animation/Animation.js","webpack:///~/zrender/lib/core/event.js","webpack:///~/zrender/lib/dom/HandlerProxy.js","webpack:///~/zrender/lib/core/GestureMgr.js","webpack:///lib/fish-topo-core/lib/manager/OperationNode.js","webpack:///lib/fish-topo-core/lib/Node.js","webpack:///lib/fish-topo-core/lib/shapes/Connector.js","webpack:///lib/fish-topo-core/lib/shapes/Symbol.js","webpack:///lib/fish-topo-core/lib/shapes/Handle.js","webpack:///lib/fish-topo-core/lib/shapes/EffectLine.js","webpack:///lib/fish-topo-core/lib/shapes/ConnectionPoint.js","webpack:///lib/fish-topo-core/lib/model.js","webpack:///lib/fish-topo-core/lib/clazz.js","webpack:///lib/fish-topo-core/lib/manager/IconOperation.js","webpack:///lib/fish-topo-link/lib/manager/LinkConnectionManager.js","webpack:///lib/fish-topo-core/lib/manager/ConnectionManager.js","webpack:///lib/fish-topo-core/lib/Log.js","webpack:///lib/fish-topo-link/lib/util/LinkConstants.js","webpack:///lib/fish-topo-link/lib/util/LinkUtil.js","webpack:///lib/fish-topo-core/lib/manager/LineOperationManager.js","webpack:///lib/fish-topo-link/lib/Link.js","webpack:///lib/fish-topo-core/lib/ImagePool.js","webpack:///lib/fish-topo-core/lib/polyfill.js","webpack:///~/zrender/lib/vml/vml.js","webpack:///~/zrender/lib/vml/graphic.js","webpack:///~/zrender/lib/vml/core.js","webpack:///~/zrender/lib/vml/Painter.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","FishTopoLink","dom","opts","group","_dom","nowZoom","canScale","eagleEye","eagleEyeNode","initScaleRatio","operationNode","selectedNode","allNodes","linkConnectionManager","LinkConnectionManager","lineOperationManager","LineOperationManager","minimap","_layoutTimeout","_zr","zrender","init","renderer","devicePixelRatio","_api","ExtensionAPI","Shape","graphic","model","Model","set","Constants","ELEMENT_TYPE","MODE","options","Eventful","zrUtil","LinkUtil","Connector","Link","ImagePool","fishTopoProto","prototype","getDom","getZr","getWidth","getHeight","isDisposed","_disposed","dispose","instances","resize","clearSelect","e","that","remove","shape","target","isLink","connector","clearSelectCon","operation","hideAllLineOperation","Group","isBg","add","connectors","on","nodeTarget","isNode","params","event","type","trigger","argument","bindOperation","lineNode","toJson","fromJson","json","clear","setBackground","get","BACKGROUND","layoutRootNode","CHILDS","i","length","parentZr","parent","deleteSelectCon","connectorMap","removeNode","splice","_triggerDeleteEvent","eventParams","_createConnectorByNodes","startNode","endNode","lineType","connectorCreate","style","bind","connectorForbidEdit","linkModify","isAllowEdit","connectorEdit","_triggerCreateEvent","addNode","node","childOfName","name","arrResult","childrenNode","childrenLine","push","j","findElements","cb","context","arr","child","childL","imageUrl","substr","document","createElement","getContext","imageShape","Rect","width","height","fill","cursor","z","backgroundColor","gridLineGroup","gridLine","imageShape1","Image","position","scale","x","y","image","backgroundImage","backgroundRepeat","opacity","pixel","widthLen","parseInt","lineX","Line","x1","y1","x2","y2","lineDash","draggable","heightLen","lineY","createLinkOfPoints","userData","isEdit","connectorCreateOfPoints","USERDATA","clone","text","toDataURL","mixin","idBase","Date","DOM_ATTRIBUTE_KEY","fishTopoLink","version","dependencies","Error","defaults","setAttribute","getInstanceByDom","key","getAttribute","chart","topo","isDom","clearTimeout","util","initImagePool","each","doSingleEnterHover","el","__isHover","__hoverStlDirty","stroke","hoverStyle","__hoverStl","lift","colorTool","Gradient","normalStyle","hasOwnProperty","__normalStl","setStyle","z2","doSingleLeaveHover","normalStl","doEnterHover","traverse","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","animateOrSetProps","isUpdate","props","animatableModel","postfix","duration","getShallow","animationEasing","animateTo","attr","pathTool","round","Math","Path","matrix","vector","Draggable","Util","Text","textContain","Circle","Sector","Ring","Polygon","Polyline","BezierCurve","Arc","LinearGradient","RadialGradient","BoundingRect","States","extendShape","extend","extendPath","pathData","extendFromString","makePath","rect","layout","path","createFromString","boundingRect","getBoundingRect","aspect","cx","cy","resizePath","inherits","mergePath","applyTransform","pathRect","calculateTransform","subPixelOptimizeLine","param","subPixelOptimize","lineWidth","subPixelOptimizeRect","originX","originY","originWidth","originHeight","max","positiveOrNegative","doubledPosition","setHoverStyle","setNormalStyle","setText","textStyle","labelModel","color","labelPosition","labelColor","indexOf","textStyleModel","getModel","textDistance","textFont","getFont","textPosition","textFill","getTextColor","updateProps","curry","initProps","getTransform","ancestor","mat","identity","mul","getLocalTransform","vertex","transform","invert","transformDirection","direction","hBase","abs","vBase","$override","fn","methods","source","result","typeStr","objToString","len","TYPED_ARRAY","Ctor","constructor","from","BUILTIN_OBJECT","isPrimitive","merge","overwrite","isObject","targetProp","sourceProp","isArray","isBuiltInObject","mergeAll","targetAndSources","overlay","_ctx","createCanvas","array","value","clazz","baseClazz","F","clazzPrototype","prop","superClass","isArrayLike","data","obj","forEach","nativeForEach","map","nativeMap","reduce","memo","nativeReduce","filter","nativeFilter","find","func","args","nativeSlice","arguments","apply","concat","isFunction","isString","nodeType","ownerDocument","eqNaN","retrieve","values","retrieve2","value0","value1","retrieve3","value2","slice","Function","normalizeCssArray","val","assert","condition","message","setAsPrimitive","primitiveKey","HashMap","createHashMap","noop","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","[object Canvas]","[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]","Object","toString","arrayProto","Array","HASH_MAP_PREFIX","HASH_MAP_PREFIX_LENGTH","prefixedKey","removeKey","processArc","fa","fs","rx","ry","psiDeg","cmd","psi","PI","xp","mathCos","mathSin","yp","lambda","mathSqrt","f","cxp","cyp","theta","vAngle","u","v","dTheta","vRatio","addData","createPathProxyFromString","n","cs","replace","cc","RegExp","prevCmd","split","cpx","cpy","PathProxy","CMD","str","charAt","off","shift","parseFloat","isNaN","ctlPtx","ctlPty","L","M","C","Q","A","Z","toStatic","createPathOptions","pathProxy","buildPath","setData","ctx","rebuildPath","transformPath","dirty","pathEls","pathList","pathEl","createPathProxy","__dirtyPath","pathBundle","appendPath","sqrt","sin","cos","vMag","acos","Displayable","pathContain","Pattern","getCanvasPattern","pathProxyForDraw","strokeContainThreshold","brush","prevEl","hasStroke","hasFill","hasFillGradient","colorStops","hasStrokeGradient","hasFillPattern","hasStrokePattern","setTransform","__dirty","_fillGradient","getGradient","_strokeGradient","fillStyle","strokeStyle","lineDashOffset","ctxLineDash","setLineDash","getGlobalScale","setScale","beginPath","setLineDashOffset","restoreTransform","drawRectText","shapeCfg","inBundle","_rect","needsUpdateRect","rectWithStroke","_rectWithStroke","copy","w","lineScale","strokeNoScale","getLineScale","contain","localPos","transformCoordToLocal","containStroke","dirtyPath","__zr","refresh","__clipTarget","animateShape","loop","animate","attrKV","setShape","Sub","extendFrom","defaultShape","thisShape","_default","Element","Style","__clipPaths","RectText","invisible","zlevel","dragging","silent","culling","rectHover","progressive","beforeBrush","afterBrush","rectContain","coord","animateStyle","useStyle","createLinearGradient","global","canvasGradient","createRadialGradient","min","r","STYLE_COMMON_PROPS","host","shadowBlur","shadowOffsetX","shadowOffsetY","font","fontStyle","fontWeight","fontSize","fontFamily","textTag","textStroke","textWidth","textHeight","textStrokeWidth","textLineHeight","textRect","textOffset","textAlign","textVerticalAlign","textShadowColor","textShadowBlur","textShadowOffsetX","textShadowOffsetY","textBoxShadowColor","textBoxShadowBlur","textBoxShadowOffsetX","textBoxShadowOffsetY","transformText","textRotation","textOrigin","textBackgroundColor","textBorderColor","textBorderWidth","textBorderRadius","textPadding","rich","truncate","blend","prevStyle","firstDraw","styleName","globalAlpha","globalCompositeOperation","otherStyle","newStyle","method","addColorStop","offset","styleProto","guid","Transformable","Animatable","ignore","clipPath","drift","dx","dy","decomposeTransform","beforeUpdate","afterUpdate","update","updateTransform","hide","show","setClipPath","zr","addSelfToZr","removeClipPath","removeSelfFromZr","animators","animation","addAnimator","removeAnimator","idStart","arrySlice","_$handlers","one","handler","_h","h","isSilent","newList","l","argLen","triggerWithContext","isNotAroundZero","EPSILON","mIdentity","rotation","origin","transformableProto","needLocalTransform","parentHasTransform","create","invTransform","dpr","tmpTransform","sx","sy","atan2","v2","transformCoordToGlobal","rotate","out","ArrayCtor","m1","m2","out0","out1","out2","out3","out4","out5","translate","a","rad","aa","ac","atx","ab","ad","aty","st","ct","vx","vy","det","Float32Array","b","v1","scaleAndAdd","sub","lenSquare","div","dot","s","normalize","d","distance","distanceSquare","negate","lerp","t","lengthSquare","dist","distSquare","Animator","log","_util","animatingShape","pathSplitted","animator","during","done","stopAnimation","forwardToLast","stop","time","delay","easing","callback","forceAnimate","count","_animateToShallow","start","objShallow","propertyCount","when","defaultGetter","defaultSetter","interpolateNumber","p0","p1","percent","interpolateString","interpolateArray","arrDim","len2","fillArr","arr0","arr1","arr0Len","arr1Len","isPreviousLarger","arraySlice","isArraySame","catmullRomInterpolateArray","p2","p3","t2","t3","catmullRomInterpolate","v0","cloneValue","ret","rgba2String","rgba","floor","join","getArrayDim","keyframes","lastValue","createTrackClip","oneTrackDone","propName","getter","_getter","setter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","sort","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","parse","_target","lastFrame","lastFramePercent","onframe","frame","range","clip","Clip","life","_loop","_delay","ondestroy","_tracks","_clipCount","_doneList","_onframeList","_clipList","tracks","pause","_paused","resume","isPaused","_doneCallback","doneList","lastClip","self","clipCount","addClip","oldOnFrame","clipList","removeClip","getClips","_life","_initialized","gap","onrestart","_pausedTime","easingFuncs","step","globalTime","deltaTime","_startTime","easingFunc","schedule","fire","restart","_needsRemove","remainder","eventType","arg","linear","k","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","sinusoidalOut","sinusoidalInOut","exponentialIn","pow","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","asin","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","clampCssByte","clampCssAngle","clampCssFloat","parseCssInt","parseCssFloat","cssHueToRgb","lerpNumber","setRgba","g","copyRgba","putToCache","colorStr","rgbaArr","lastRemovedArr","colorCache","put","cached","toLowerCase","kCSSColorTable","op","ep","fname","alpha","pop","hsla2rgba","iv","hsla","rgba2hsla","H","S","R","G","B","vMin","vMax","delta","deltaR","deltaG","deltaB","level","colorArr","stringify","toHex","fastLerp","normalizedValue","colors","leftIndex","rightIndex","ceil","leftColor","rightColor","dv","fullOutput","modifyHSL","modifyAlpha","arrColor","LRU","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","fastMapToColor","mapToColor","LinkedList","head","tail","_len","linkedListProto","insert","entry","Entry","insertEntry","next","prev","maxSize","_list","_map","_maxSize","_lastRemovedEntry","LRUProto","list","removed","leastUsedEntry","_config","debugMode","console","window","textHelper","tmpRect","normalizeTextStyle","needDrawText","save","renderText","restore","normalizeStyle","makeFont","VALID_TEXT_ALIGN","textBaseline","VALID_TEXT_VERTICAL_ALIGN","hostEl","renderRichText","renderPlainText","setCtx","DEFAULT_FONT","contentBlock","__textCotentBlock","parsePlainText","outerHeight","textLines","lines","lineHeight","boxPos","getBoxPosition","baseX","baseY","applyTextRotation","boxY","adjustTextY","textX","textY","needDrawBg","needDrawBackground","outerWidth","boxX","adjustTextX","drawBackground","getTextXForPadding","getStroke","getFill","strokeText","fillText","parseRichText","drawRichText","contentWidth","xLeft","lineTop","xRight","token","line","tokens","tokenCount","usedWidth","lineXLeft","lineXRight","placeToken","tokenStyle","isLineHolder","isPlainBg","roundRectHelper","closePath","imageHelper","createOrUpdateImage","onBgImageLoaded","isImageReady","drawImage","blockHeiht","parsePercent","res","adjustTextPositionOnRect","maxValue","lastIndexOf","left","right","center","top","bottom","middle","textWidthCache","measureText","textWidthCacheCounter","TEXT_CACHE_MAX","getRichTextRect","getPlainTextRect","halfHeight","truncateText","containerWidth","ellipsis","prepareTruncateOptions","truncateSingleLine","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","ellipsisWidth","textLine","subLength","estimateLength","charCode","charCodeAt","getLineHeight","padding","truncOuterHeight","truncOuterWidth","lastIndex","STYLE_REG","exec","matchedIndex","index","pushTokens","substring","contentHeight","pendingList","stlPadding","truncateWidth","truncateHeight","tokenHeight","tokenWidth","tokenWidthNotSpecified","percentWidth","bgImg","findExistImage","paddingW","remianTruncWidth","block","isEmptyStr","strs","tokensLen","vec2","v2ApplyTransform","mathMin","mathMax","union","other","lt","rb","lb","rt","maxX","maxY","intersect","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","plain","newImageOrSrc","cachedImgObj","globalImageCache","cbPayload","__zrImageSrc","pendingWrap","pending","onload","imageOnLoad","__cachedImgObj","src","r1","r2","r3","r4","total","moveTo","lineTo","quadraticCurveTo","curve","bbox","min2","max2","mathAbs","hasTypedArray","notSaveData","_saveData","_xi","_yi","_x0","_y0","_ux","_uy","_lineDash","_dashOffset","_dashIdx","_dashSum","exceedUnit","_needsDash","_dashedLineTo","bezierCurveTo","x3","y3","_dashedBezierTo","_dashedQuadraticTo","arc","startAngle","endAngle","anticlockwise","arcTo","radius","x0","y0","lineDashSum","appendSize","appendPathData","_expandData","_prevCmd","newData","dash","idx","dashSum","nDash","cubicAt","bezierLen","tmpLen","Number","MAX_VALUE","xi","yi","fromLine","fromCubic","fromQuadratic","fromArc","ux","uy","scaleX","scaleY","isEllipse","isAroundZero","onet","cubicDerivativeAt","cubicRootAt","roots","t1","disc","K","discSqrt","Y1","Y2","mathPow","ONE_THIRD","T","ASqrt","tmp","THREE_SQRT","cubicExtrema","extrema","cubicSubdivide","p01","p12","p23","p012","p123","p0123","cubicProjectPoint","d1","d2","interval","Infinity","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","quadraticAt","quadraticDerivativeAt","quadraticRootAt","quadraticExtremum","divider","quadraticSubdivide","quadraticProjectPoint","_vector","v2Create","fromPoints","points","xDim","yDim","tx","ty","vec2Min","vec2Max","diff","PI2","end","angle","extremity","isAroundEqual","swapExtrema","windingCubic","nRoots","y0_","y1_","nExtrema","unit","x_","windingQuadratic","y_","windingArc","dir","normalizeRadian","containPath","isStroke","windingLine","cubic","quadratic","_x","_l","_a","_b","_s","_curve","repeat","createPattern","nPoint","mathAtan2","_dragStart","_drag","_dragEnd","topTarget","draggingTarget","_draggingTarget","offsetX","_y","offsetY","dispatchToElement","dropTarget","findHover","lastDropTarget","_dropTarget","_children","__storage","isGroup","children","childAt","childCount","_doAdd","addBefore","nextSibling","storage","addToStorage","addChildrenToStorage","delFromStorage","delChildrenFromStorage","removeAll","eachChild","includeChildren","tmpMat","childRect","ZImage","_image","sWidth","sHeight","shadowColor","fixClipWithShadow","r0","clockwise","unitX","unitY","orignalBrush","env","browser","ie","modified","clipPaths","shadowTemp","detect","ua","os","firefox","match","edge","weChat","test","canvasSupported","svgSupported","SVGRect","touchEventsSupported","pointerEventsSupported","navigator","userAgent","polyHelper","smooth","smoothConstraint","controlPoints","smoothBezier","cp1","cp2","smoothSpline","interpolate","isLoop","v2Distance","segs","pos","w2","w3","constraint","prevPoint","nextPoint","cps","v2Min","v2Max","point","v2Clone","v2Sub","v2Scale","d0","sum","cp0","v2Add","pointAt","someVectorAt","isTangent","cpx2","cpy2","cpx1","cpy1","tangentAt","globalCoord","vec2Copy","transitionProperties","TransitionObject","_fromStr","property","GraphicStates","_states","_el","_subStates","_transitionAnimators","initialState","_initialState","optsStates","states","state","_addState","setState","_currentState","transition","_extendFromInitial","transiting","_stopTransition","prevState","onleave","onenter","getState","transitionState","styleShapeReg","propPathMap","transitionCfg","animatingCount","animationDone","_animProp","subProp","subStates","subPropKey","stateObj","elObj","availableProp","transitionAnimators","dealy","addSubStates","removeSubStates","getUUID","chars","uuid","rnd","random","getMaxLineLength","getPolylineLength","lenght","NaN","orthogonalPath","lineIntersectsLine","l1","l2","startPoint","endPoint","contains","a1","b1","a2","b2","polylineIntersectsRectangle","bounds","closedPolyline","Point","tempLine","tempLine1","scorePath","score","signum","forwardPath","traslatePoints","isRevert","newPoints","point1","rotationMatrix","mReturn","translationMatrix","scaleMatrix","getEndPoint","getConnectorPoints","getSoltPoints","getRect","tangentRotation","collinearity","precission","determinant","enhancedRound","number","decimals","getLength","getAngle","centerPoint","outsidePoint","atan","isCalcParent","positionX","positionY","boundRect","randomColor","arrHex","strHex","isUndefined","collinearReduction","cloneArray","template","settings","oldSettings","templateSettings","matcher","escape","noMatch","evaluate","escaper","escapeChar","variable","render","isEmpty","mergeOpt","exclude","Class","StackedMap","createNew","stack","arrKey","keys","removeItem","item","removeTop","escapes","'","\\","\r","\n"," "," ","proto","member","base","subclass","load","o","newPoint","loadArray","oldX","oldY","equals","anotherPoint","near","getPoints","oType","newLine","contructor","anotherLine","startX","startY","endX","endY","closestX","closestY","getPoint","Xp","Yp","instance","apiList","ZRender","getInstance","registerPainter","painterCtors","delInstance","Handler","Storage","Painter","Animation","HandlerProxy","useVML","canvas","rendererType","vml","painter","handerProxy","getViewportRoot","stage","flush","_needsRefresh","oldDelFromStorage","oldAddToStorage","getId","addRoot","delRoot","configLayer","zLevel","config","refreshImmediately","_needsRefreshHover","refreshHoverImmediately","addHover","refreshHover","removeHover","clearHover","clearAnimation","pathToImage","setCursorStyle","cursorStyle","eventName","eventHandler","makeEventPacket","eveType","targetInfo","cancelBubble","zrX","zrY","gestureEvent","pinchX","pinchY","pinchScale","wheelDelta","zrDelta","zrByTouch","which","EmptyProxy","isHover","displayable","SILENT","handlerNames","proxy","painterRoot","_hovered","_lastTouchMoment","_lastX","_lastY","mousemove","lastHovered","lastHoveredTarget","hovered","hoveredTarget","setCursor","mouseout","innerDom","element","toElement","relatedTarget","parentNode","dispatch","eventArgs","eventPacket","eachOtherLayer","layer","getDisplayList","hoverCheckResult","_downEl","_downPoint","_upEl","shapeCompareFunc","timsort","_roots","_displayList","_displayListLen","includeIgnore","updateDisplayList","displayList","_updateAndAddDisplayable","userSetClipPath","currentClipPath","parentClipPath","_renderList","displayableSortFunc","minRunLength","DEFAULT_MIN_MERGE","makeAscendingRun","lo","hi","compare","runHi","reverseRun","binaryInsertionSort","mid","pivot","gallopLeft","hint","lastOffset","maxOffset","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","length2","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","tmpStorageLength","DEFAULT_TMP_STORAGE_LENGTH","stackLength","remaining","ts","minRun","force","parseInt10","isLayerValid","__builtin__","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","viewRect","isClipPathChanged","prevClipPaths","doClip","createRoot","domRoot","cssText","Layer","requestAnimationFrame","MAX_PROGRESSIVE_LAYER_NUMBER","singleCanvas","nodeName","toUpperCase","_opts","_singleCanvas","rootStyle","innerHTML","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","initContext","_domRoot","_getSize","appendChild","_progressiveLayers","_hoverlayer","_hoverElements","getType","isSingleCanvas","getViewportRootOffset","viewportRoot","offsetLeft","offsetTop","paintAll","_paintList","_startProgessive","__hoverMir","elMirror","__from","hoverElements","hoverLayer","getLayer","scope","originalEl","_doPaintEl","_progressiveToken","_doPaintList","_furtherProgressive","_progress","_clearProgressive","_updateLayerStatus","eachBuiltinLayer","flushProgressiveLayer","currentLayer","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","elZLevel","elFrame","__frame","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","prevClipLayer","prevElClipPaths","insertLayer","layersMap","prevLayer","virtual","prevDom","insertBefore","firstChild","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","elCount","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","_clearLayer","layerConfig","delLayer","removeChild","display","clearLayer","getRenderedCanvas","findAndDrawOtherLayer","smaller","larger","intermediateLayer","renderToCanvas","imageLayer","pixelRatio","clearColor","whIdx","wh","cwh","plt","prb","stl","defaultView","getComputedStyle","shadowBlurSize","leftMargin","rightMargin","topMargin","bottomMargin","clearRect","pathTransform","ImageShape","imgShape","returnFalse","createDom","newDom","newDomStyle","domStyle","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","__currentValues","createBackBuffer","clearAll","haveMotionBLur","clearColorGradientOrPattern","__canvasGradient","fillRect","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","setTimeout","_event","Dispatcher","_clips","_running","_time","_pauseStart","clips","_update","getTime","deferredEvents","deferredClips","_startLoop","getBoundingClientRect","clientToLocal","calculate","defaultGetZrXY","layerX","layerY","box","clientX","clientY","normalizeEvent","isTouch","touch","targetTouches","changedTouches","detail","button","undefined","MOUSE_EVENT_REG","addEventListener","isDomLevel2","attachEvent","removeEventListener","detachEvent","notLeftMouse","preventDefault","stopPropagation","returnValue","eventNameFix","processGesture","gestureMgr","_gestureMgr","gestureInfo","recognize","setTouchTimer","_touching","_touchTimer","isPointerFromTouch","pointerType","initDomHandler","makeMouseHandler","touchHandlerNames","_handlers","domHandlers","pointerHandlerNames","mouseHandlerNames","HandlerDomProxy","mountHandlers","GestureMgr","TOUCH_CLICK_DELAY","pointerEventNames","pointerdown","pointerup","pointermove","pointerout","nm","touchstart","mousedown","touchmove","touchend","mouseup","click","handlerDomProxyProto","pointPair","eventUtil","_track","_doTrack","_recognize","touches","trackItem","recognizers","pinch","track","pinchEnd","pinchPre","isFinite","pinchCenter","OperationNode","api","forbidEdit","Node","icon","symbolUtil","ARROW_DRAGEND","ARROW_DRAG","ARROW_DRAGSTART","DELETE_CLICK","DEL","COMMENT_CLICK","COMMENT","opicons","STRAIGHT","STRAIGHT_SVG","JAGGED","JAGGED_SVG","CURVE","CURVE_SVG","DEL_SVG","COMMENT_SVG","renderBase","renderOther","createOperation","me","selectStyle","_zCloneStyle","setOrCancelSelectStyle","virtualRect","isSelfComputePos","operationIcons","opIconInstance","operationIcon","hidden","rectOther","MOUSE_EVENT_NAMES","eveName","createSymbol","iconPath","refreshPostion","nodeRect","rbPoint","nodeItem","refreshPositionOther","nodeShapeX","nodeSahpeY","cleanup","resourceId","drawText","textName","bpmnInfo","refreshText","toJSON","opt","option","defaultOptions","symbol","size","NORMAL_COLOR","both","TYPE_STRAIGHT","SELECTED_COLOR","arrowHoverStyle","startPos","endPos","startOffset","endOffset","escapeDistance","autoChangePosition","textContextMenu","textPos","textRotateable","handles","conPointsGroup","groupCurve","icons","Handle","EffectLine","ConnectionPoint","TYPE_JAGGED","TYPE_CURVE","TYPE_CHAIN","RADIUS","START_NODE","END_NODE","LEFT","RIGHT","TOP","BOTTOM","SEPERATOR","arrPoints","turningPoints","modifyCurve","lineText","lineTextArr","cnt","textPoint","getTextPostion","way","rate","getTextRotation","deg","refreshFromToSymbol","renderFromToSymbol","curveLine","polyLine","createHoverStyle","createAllconnectionPoint","shapeSetHandle","content","textId","buildMenu","symbolTo","symbolFrom","effect","distanceFrom","notSaveModel","textPostion","arrOffset","midPoint","connectionPointCreate","TYPE_CONNECTOR","conPoint","clearHandles","handleShape","isCollineaityFirst","isCollineaitySecond","symbolType","symbolSize","symbolZIndex","symbolPath","middleX","middleY","ellapsedDistance","segment","missingDistance","error","walked","rest","currentSegmentLength","segmentPercent","refreshModel","iconNode","sol","getCurvePoint","willDelCurves","cntCurve","cure","P","divide","nr","callee","multiply","q1","q_01","q_02","q_03","q0","q2","q_31","q_32","q_33","q3","Triangle","Diamond","Pin","tanX","tanY","cpLen","cpLen2","Arrow","symbolCtors","roundRect","square","circle","diamond","pin","arrow","triangle","symbolShapeMakers","symbolBuildProxies","Symbol","proxySymbol","symbolPathSetColor","symbolStyle","symbolShape","__isEmptyBrush","setColor","visible","actionConnector","anotherHandle","newX","newY","deltaY","deltaX","_lastFrame","_lastFramePercent","initSymbol","curveUtil","EffectLineProto","period","__t","groupCurveAnimate","updateSymbolPositionPolyline","setAnimationPointsPolyline","setAnimationPointsBezierCurve","updateSymbolPositionBezierCurve","__p1","__p2","__cp1","__cp2","_points","accLenArr","_offsets","_length","__lastFramePercent","offsets","OVER_COLOR","CONNECTED_COLOR","TYPE_FIGURE","anotherConnectionPoint","parentModel","extraOpt","clazzUtil","getDefaultOption","optList","defaultOption","__defaultOption","mergeOption","ignoreParent","fieldName","fieldArray","currentRef","thisParentModel","restoreData","enableClassExtend","superCall","methodName","superApply","TYPE_DELIMITER","IS_CONTAINER","parseClassType","componentType","main","RootClass","preConstruct","ExtendedClass","enableClassManagement","entity","makeContainer","container","registerClass","Clazz","getClass","componentTypeMain","subType","throwWhenNotFound","getClassesByMainType","hasClass","getAllClassMainTypes","types","hasSubTypes","registerWhenExtend","originalExtend","IconOperation","CHANGE_LINE_TYPE_SVG","ConnectionManager","LineOperations","bundleOffset","bundleGap","startDemoId","endDemoId","sPos","ePos","arrSplit","refreshConnector","selConnector","selected","dockers","CONNECTION","OPTIONS","DOCKERS","STYLE_LINETYPE","getTwoNodeId","refreshCons","arrCons","refreshConsStraight","half","arrConnectResult","sRect","eRect","sConnectorPoint","eConnectorPoint","secondPoint","thirdPoint","upHalf","boundOffsetXY","isPositive","resultPoint","setModel","originLineType","refreshLineByNode","tempConnector","Log","startNodeOutgoing","removeLine","deleteLine","arrStartEndPoint","getStartEndPoint","solutions","connector2Points","isNotInSameGroup","sBounds","eBounds","posArr","calcPointExpression","expression","manageTempConnector","rEndPoint","manageReverseTempConnector","removeTempConnector","figureEscapeDistance","info","startExitPoint","endExitPoint","potentialExits","gapIndex","s0","s1","s1_1","s1_2","s2_1","s2_1_1","s2_1_2","s2_2","s2_2_1","s2_2_2","s2_3","eastExits","eastExit","s2_3_1","s2_3_2","s2_4","northExits","northExit","s2_4_1","s2_4_2","s2_5","westExits","westExit","s2_5_1","s2_5_2","s2_6","southExits","southExit","s2_6_1","s2_6_2","orthogonalSolution","solution","forwardSolutions","temp","nonIntersectionSolutions","innerLines","firstSolution","nrOfPoints","sameNrPointsSolution","solIndex","smoothCurve","groupEnd","solTurningPoints","startMiddlePoint","getMiddle","a3","a4","endMiddlePoint","solType","reducedSolution","LOG_LEVEL_NONE","LOG_LEVEL_DEBUG","LOG_LEVEL_INFO","LOG_LEVEL_ERROR","debug","title","ID","START_ID","END_ID","ALARM","RELATIONID","RELATION_IMAGE","GROUP","TREE_ROOT","LINEOPERATIONICON","jsonArr","fishTopolink","childShapes","isChild","link","url","connectionManager","lineOperations","addIcon","lineOperationIcon","lineOperation","creatOperation","_getParentZr","_isLineOperationIcon","elementType","parentX","parentY","posX","posY","pointPosition","arrLength","totalLength","previousValue","currentValue","connectorPosition","attachLine","addDeleteIcon","addChangeLineTypeIcon","changeSelectConnectorType","Flow","FLOW_TYPE","LINK","RECT","IMAGE","TEXT","CIRCLE","SECTOR","RING","POLYGON","POLYLINE","LINE","BEZIERCURVE","ARC","SCENE","setUserData","getUserData","config_default","thread","linkHead","linkNode","pool","emptyFn","tries","_helpers","setAttr","img","dataset","getAttr","initPool","notice","getNode","executeLink","onerror","appendNode","createNode","free","status","setSrc","shiftNode","getFree","setNode","_load","srcs","once","success","_info","task","tr","oThis","TypeError","aArgs","fToBind","fNOP","fBound","String","endsWith","searchString","subjectString","_zrender","vmlCore","comma","imageTransformPrefix","Z2","ZLEVEL_BASE","Z_BASE","initRootElStyle","coordsize","coordorigin","encodeHtmlAttribute","rgb2Str","append","getZIndex","setColorAndOpacity","getColorAndAlpha","updateFillNode","zrEl","gradientType","focus","expansion","rectWidth","rectHeight","dimension","stops","cs1","cs2","colorAndAlphaList","colorAndAlpha","color1","color2","opacity1","opacity2","focusposition","updateStrokeNode","dashstyle","updateFillAndStroke","vmlEl","isFill","getElementsByTagName","pathDataToString","cmdStr","dataLength","brushVML","vmlRoot","_vmlEl","needTransform","strokeEl","weight","zIndex","removeRectText","onRemove","onAdd","appendRectText","isImage","tagName","ow","oh","_imageSrc","_imageWidth","_imageHeight","imageRuntimeStyle","runtimeStyle","oldRuntimeWidth","oldRuntimeHeight","dw","dh","sw","sh","hasCrop","doc","vmlElStyle","hasRotation","transformFilter","imageEl","_imageEl","cropEl","_cropEl","imageELStyle","tmpImage","overflow","cropElStyle","filterStr","textMeasureEl","DEFAULT_STYLE_NORMAL","fontStyleCache","fontStyleCacheCount","MAX_FONT_CACHE_SIZE","fontEl","getFontStyle","fontString","variant","fontVariant","family","body","ex","createTextNode","offsetWidth","fromTextEl","align","verticalAlign","textPathEl","skewEl","textVmlEl","_textVmlEl","textpathok","to","coords","textVmlElStyle","toFixed","string","doCreateNode","initVML","vmlInited","styleSheets","createStyleSheet","addRule","urn","win","namespaces","zrvml","VMLPainter","vmlViewport","_vmlRoot","_vmlViewport","_firstPaint","createMethodNotSupport","zrLog","__alreadyNotVisible","_getWidth","_getHeight","vmlViewportStyle","currentStyle","clientWidth","paddingLeft","paddingRight","clientHeight","paddingTop","paddingBottom"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,SAAAA,OAAAC,IACAD,UAAAH,GACA,gBAAAC,SACAA,QAAA,aAAAD,IAEAD,EAAA,aAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAP,WACAS,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,EAAAA,EAAAD,QAAAM,GAGAL,EAAAS,QAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDgBM,SAAUL,EAAQD,EAASM,GAEhCL,EAAOD,QAAUM,EAAoB,IAKhC,SAAUL,EAAQD,EAASM,GE1DjCL,EAAAD,QAAAM,EAAA,GAEAA,EAAA,KFqEM,SAAUL,EAAQD,EAASM,GGlDjC,QAAAS,GAAAC,EAAAC,GACAb,KAAAK,GACAL,KAAAc,MACAd,KAAAe,KAAAH,EACAZ,KAAAgB,QAAA,EACAhB,KAAAiB,UAAA,EACAjB,KAAAkB,UAAA,EACAlB,KAAAmB,aACAnB,KAAAoB,eACApB,KAAAqB,cACArB,KAAAsB,aAAA,KACAtB,KAAAuB,YACAvB,KAAAwB,sBAAA,GAAAC,GACAzB,KAAA0B,qBAAA,GAAAC,GAAA3B,KAAAwB,uBACAxB,KAAA4B,QACA5B,KAAA6B,eAAA,KACA7B,KAAA8B,IAAAC,EAAAC,KAAApB,GACAqB,SAAApB,EAAAoB,UAAA,SACAC,iBAAArB,EAAAqB,mBAGAlC,KAAAmC,KAAA,GAAAC,GAAApC,MACAA,KAAAqC,MAAAC,EACAtC,KAAAuC,MAAA,GAAAC,OACAxC,KAAAuC,MAAAE,IAAAC,EAAAC,aAAA,SACA3C,KAAAuC,MAAAE,IAAAC,EAAAE,KAAA,UACA5C,KAAA6C,QAAAhC,EACAiC,EAAAvC,KAAAP,MA9CA,GAAAsC,GAAApC,EAAA,GAGAkC,GAFAlC,EAAA,IACAA,EAAA,IACAA,EAAA,KACA4C,EAAA5C,EAAA,IACA6B,EAAA7B,EAAA,IACA6C,EAAA7C,EAAA,GAEAuB,GADAvB,EAAA,IACAA,EAAA,KACA8C,EAAA9C,EAAA,IACAwC,EAAAxC,EAAA,IACAsC,EAAAtC,EAAA,IAEA+C,GADA/C,EAAA,IACAA,EAAA,KACAyB,EAAAzB,EAAA,IACAgD,EAAAhD,EAAA,IAEAiD,GADAjD,EAAA,IACAA,EAAA,IACAA,GAAA,GA+BA,IAAAkD,GAAAzC,EAAA0C,SAMAD,GAAAE,OAAA,WACA,MAAAtD,MAAAe,MAMAqC,EAAAG,MAAA,WACA,MAAAvD,MAAA8B,KAMAsB,EAAAI,SAAA,WACA,MAAAxD,MAAA8B,IAAA0B,YAOAJ,EAAAK,UAAA,WACA,MAAAzD,MAAA8B,IAAA2B,aAQAL,EAAAM,WAAA,WACA,MAAA1D,MAAA2D,WAMAP,EAAAQ,QAAA,WACA5D,KAAA2D,WAAA,EAEA3D,KAAA8B,IAAA8B,UAEAC,EAAA7D,KAAAK,IAAA,MASA+C,EAAAU,OAAA,WACA9D,KAAA8B,IAAAgC,UAQAV,EAAApB,KAAA,WAaA,QAAA+B,GAAAC,GACAC,EAAA5C,gBACA4C,EAAAnD,MAAAoD,OAAAD,EAAA5C,eACA4C,EAAA5C,cAAA,KAEA,IAAA8C,GAAAH,EAAAI,MACAD,IAAAA,EAAA5B,OAAAW,EAAAmB,OAAAF,EAAA5B,QAGA4B,GAAAA,EAAAG,oBAAArB,KAGAgB,EAAAzC,sBAAA+C,iBACAJ,GAAAA,EAAAK,WAAA,GAAAL,EAAAK,WAGAP,EAAAvC,qBAAA+C,wBA5BA,GAAAR,GAAAjE,IACAA,MAAAc,MAAA,GAAAwB,GAAAoC,MACA1E,KAAAc,MAAA6D,MAAA,EACA3E,KAAA8B,IAAA8C,IAAA5E,KAAAc,OACAd,KAAAwB,sBAAAqD,cAEA7E,KAAA8B,IAAAgD,GAAA,UAAA,SAAAd,GACAD,EAAAC,KAEAC,EAAAnC,IAAAgD,GAAA,YAAA,SAAAd,GACAD,EAAAC,KAoBAhE,KAAA8B,IAAAgD,GAAA,QAAA,SAAAd,GACA,GACAG,GADAY,EAAAf,EAAAI,MAKA,IAHAW,IACAZ,EAAAY,EAAAxC,SAEAwC,GAAAZ,GAAAjB,EAAAmB,OAAAF,IAAAY,GAAAZ,GAAAjB,EAAA8B,OAAAb,IAAA,CAGA,GAAAc,KACAA,GAAAC,MAAAlB,EACAiB,EAAAE,KAAA,QACAF,EAAAb,OAAAH,EACAA,EAAA9B,KAAAiD,QAAAH,EAAAE,KAAAF,MAEAjF,KAAA8E,GAAA,uBAAA,SAAAO,GACApB,EAAAzC,sBAAA8D,cAAAD,EAAAE,aAQAnC,EAAAoC,OAAA,WACA,MAAAxC,GAAAwC,OAAAxF,KAAAuC,MAAAvC,KAAAc,QAOAsC,EAAAqC,SAAA,SAAAC,GACA1F,KAAA2F,OACA,IAAApD,GAAA,GAAAC,GAAAkD,EACA1F,MAAA4F,cAAArD,EAAAsD,IAAAnD,EAAAoD,YACA,IAAAC,KACA/C,GAAAyC,SAAAzF,KAAAA,KAAAc,MAAAyB,EAAAsD,IAAAnD,EAAAsD,SAAA,EAAAD,IAOA3C,EAAAuC,MAAA,WACA,IAAA,GAAAM,GAAA,EAAuBA,EAAAjG,KAAAuB,SAAA2E,OAA0BD,IAAA,CACjD,GAAAE,EAEAA,GADAnG,KAAAuB,SAAA6E,OACApG,KAAAuB,SAAA6E,OAEApG,KAAA8B,IAEA9B,KAAAwB,sBAAA6E,gBAAArG,KAAAuB,SAAA0E,GAAAE,GAEAnG,KAAAwB,sBAAA8E,aAAAX,QACA3F,KAAAuB,YACAvB,KAAAqB,cAAA,KACArB,KAAAsB,aAAA,KACAtB,KAAAwB,sBAAAqD,cACA7E,KAAA8B,IAAA6D,QACA3F,KAAAc,MAAA,GAAAwB,GAAAoC,MACA1E,KAAAc,MAAA6D,MAAA,EACA3E,KAAA8B,IAAA8C,IAAA5E,KAAAc,QAQAsC,EAAAmD,WAAA,SAAAjF,GACA,GAAA2C,GAAAjE,IAEAsB,GAAA8E,OACA9E,EAAA8E,OAAAlC,OAAA5C,GAEA2C,EAAAnD,MAAAoD,OAAA5C,EAGA,KAAA,GAAA2E,GAAA,EAAuBA,EAAAhC,EAAA1C,SAAA2E,OAA0BD,IACjD3E,EAAAjB,IAAA4D,EAAA1C,SAAA0E,GAAA5F,IACA4D,EAAA1C,SAAAiF,OAAAP,EAAA,EAGAjG,MAAAwB,sBAAA6E,gBAAA/E,EAAA2C,EAAAnD,QAOAsC,EAAAqD,oBAAA,SAAArC,GACA,GAAAsC,KACAA,GAAAvB,KAAA,SACAuB,EAAAtC,OAAAA,EACApE,KAAAmC,KAAAiD,QAAAsB,EAAAvB,KAAAuB,IAMAtD,EAAAuD,wBAAA,SAAAC,EAAAC,EAAAC,GACA,GAAA7C,GAAAjE,KACAsE,EAAAtE,KAAAwB,sBAAAuF,gBAAAH,EAAAC,GACAG,OACAF,SAAAA,IAES9G,KAAAmC,KAkBT,OAjBAyE,GAAAR,QAAAS,EAAAT,OACAS,EAAAT,OAAAxB,IAAAN,GAEAtE,KAAAc,MAAA8D,IAAAN,GAGAA,EAAAQ,GAAA,YAAA/B,EAAAkE,KAAA,WACAjH,KAAAwB,sBAAA0F,qBAAAlH,KAAA6C,QAAAsE,YACAnH,KAAAgF,QAAA,GACShF,OACTsE,EAAAQ,GAAA,WAAA,WACAb,EAAApB,QAAAuE,aACAnD,EAAAoD,cAAArH,QAIAA,KAAAsH,oBAAAhD,GACAA,GAOAlB,EAAAkE,oBAAA,SAAAlD,GACA,GAAAsC,KACAA,GAAAvB,KAAA,SACAuB,EAAAtC,OAAAA,EACApE,KAAAmC,KAAAiD,QAAAsB,EAAAvB,KAAAuB,IAOAtD,EAAAmE,QAAA,SAAAC,GACAxH,KAAAc,MAAA8D,IAAA4C,IAQApE,EAAAqE,YAAA,SAAAC,GAIA,IAAA,GAHAC,MACAC,EAAA5H,KAAAuB,SACAsG,EAAA7H,KAAAwB,sBAAAqD,WACAoB,EAAA,EAAuBA,EAAA2B,EAAA1B,OAAyBD,IAChD2B,EAAA3B,GAAA1D,MAAAsD,IAAA,iBAAA+B,EAAA3B,GAAA1D,MAAAsD,IAAA,iBAAA6B,EACAC,EAAAG,KAAAF,EAAA3B,IACa2B,EAAA3B,GAAA1D,MAAAsD,IAAA,kBAAA6B,GACbC,EAAAG,KAAAF,EAAA3B,GAGA,KAAA,GAAA8B,GAAA,EAAuBA,EAAAF,EAAA3B,OAAyB6B,IAChDF,EAAAE,GAAAxF,MAAAsD,IAAA,iBAAAgC,EAAAE,GAAAxF,MAAAsD,IAAA,iBAAA6B,EACAC,EAAAG,KAAAD,EAAAE,IACaF,EAAAE,GAAAxF,MAAAsD,IAAA,kBAAA6B,GACbC,EAAAG,KAAAD,EAAAE,GAGA,OAAAJ,GAAAzB,OAAA,EACAyB,EAEAA,EAAA,IAUAvE,EAAA4E,aAAA,SAAAC,EAAAC,GAIA,IAAA,GAHAN,GAAA5H,KAAAuB,SACAsG,EAAA7H,KAAAwB,sBAAAqD,WACAsD,KACAlC,EAAA,EAAuBA,EAAA2B,EAAA1B,OAAyBD,IAAA,CAChD,GAAAmC,GAAAR,EAAA3B,EACAgC,GAAA1H,KAAA2H,EAAAE,EAAAnC,IACAkC,EAAAL,KAAAM,GAGA,IAAA,GAAAL,GAAA,EAAuBA,EAAAF,EAAA3B,OAAyB6B,IAAA,CAChD,GAAAM,GAAAR,EAAAE,EACAE,GAAA1H,KAAA2H,EAAAG,EAAAN,IACAI,EAAAL,KAAAO,GAGA,MAAAF,IAOA/E,EAAAwC,cAAA,SAAA0C,GACA,GAAArE,GAAAjE,IACA,IAAAsI,GAAAA,EAAApC,OAAA,EAEA,GADAlG,KAAAuC,MAAAE,IAAAC,EAAAoD,WAAAwC,GACA,KAAAA,EAAAC,OAAA,EAAA,IAAA,QAAAD,EAAAC,OAAA,EAAA,GACA,GAAAC,SAAAC,cAAA,UAAAC,WAEiB,CACjB,GAAAC,GAAA,GAAA3I,MAAAqC,MAAAuG,MACAzE,OACA0E,MAAA5E,EAAAnC,IAAA0B,WACAsF,OAAA7E,EAAAnC,IAAA2B,aAEAuD,OACA+B,KAAAT,GAEAU,OAAA,UACAC,MAEAhF,GAAAnC,IAAA8C,IAAA+D,OAbA1E,GAAAlD,KAAAiG,MAAAkC,gBAAAZ,MAgBa,IAAA,YAAAA,EACbtI,KAAAmJ,cAAA,GAAA7G,GAAAoC,MACA1E,KAAAoJ,SAAA,IACApJ,KAAA8B,IAAA8C,IAAA5E,KAAAmJ,mBAEA,IAAAX,SAAAC,cAAA,UAAAC,WAGiB,CACjB,GAAAW,GAAA,GAAArJ,MAAAqC,MAAAiH,OACAC,UAAA,EAAA,GACAC,OAAA,EAAA,GACAxC,OACAyC,EAAA,EACAC,EAAA,EACAC,MAAArB,EACAO,MAAA7I,KAAA8B,IAAA0B,WACAsF,OAAA9I,KAAA8B,IAAA2B,aAEAuF,OAAA,UACAC,MAEAhF,GAAAnC,IAAA8C,IAAAyE,OAhBApF,GAAAlD,KAAAiG,MAAA4C,gBAAA,OAAAtB,EAAA,IACArE,EAAAlD,KAAAiG,MAAA6C,iBAAA,UAwBAzG,EAAAgG,SAAA,SAAAU,GAGA,IAAA,GAFAC,GAAA,GACAC,EAAAC,SAAAjK,KAAAwD,WAAAuG,GACAN,EAAA,EAAuBA,GAAAO,EAAeP,IAAA,CACtC,GAAAS,GAAA,GAAA5H,GAAA6H,MACAhG,OACAiG,GAAAX,EAAAM,EACAM,GAAA,EACAC,GAAAb,EAAAM,EACAQ,GAAAvK,KAAAyD,aAEAuD,OACAwD,UAAA,GACAV,QAAAA,GAEAb,EAAA,EACAwB,WAAA,EACAzB,OAAA,WAEAhJ,MAAAmJ,cAAAvE,IAAAsF,GAIA,IAAA,GADAQ,GAAAT,SAAAjK,KAAAyD,YAAAsG,EAAAA,GACAL,EAAA,EAAuBA,GAAAgB,EAAgBhB,IAAA,CACvC,GAAAiB,GAAA,GAAArI,GAAA6H,MACAhG,OACAiG,GAAA,EACAC,GAAAX,EAAAK,EACAO,GAAAtK,KAAAwD,WACA+G,GAAAb,EAAAK,GAEA/C,OACAwD,UAAA,GACAV,QAAAA,GAEAb,EAAA,EACAwB,WAAA,EACAzB,OAAA,WAEAhJ,MAAAmJ,cAAAvE,IAAA+F,KAsDAvH,EAAAwH,mBAAA,SAAA/H,EAAAgI,GACA,GAAA5G,GAAAjE,IACA6C,GAAAiI,SAAA9K,KAAA6C,QAAAsE,UACA,IAAA7C,GAAAtE,KAAAwB,sBAAAuJ,wBAAAlI,EAAA7C,KAAAmC,KAaA,OAZAmC,GAAA/B,MAAAE,IAAAC,EAAAsI,SAAAjI,EAAAkI,MAAAJ,IACAvG,EAAAQ,GAAA,WAAA,WACA,mBAAA9E,MAAA6C,QAAAqI,KAAA9D,YACAnD,EAAApB,QAAAuE,aACAnD,EAAAoD,cAAArH,MAGAA,KAAA6C,QAAAqI,KAAA9D,aACAnD,EAAAoD,cAAArH,QAIAsE,GAQAlB,EAAA+H,UAAA,SAAAtK,GACA,MAAAmC,GAAAmI,UAAAnL,KAAA8B,IAAAjB,IAGAkC,EAAAqI,MAAAzK,EAAAmC,EAGA,IAAAuI,GAAA,GAAAC,MAAA,EACAzH,KACA0H,EAAA,0BAOAC,GAKAC,QAAA,QACAC,cACA3J,QAAA,SAcAyJ,GAAAxJ,KAAA,SAAApB,EAAAC,GACA,IAAAD,EACA,KAAA,IAAA+K,OAAA,kCAGA9K,GAAAA,MAEAkC,EAAA6I,SAAA/K,GACAsE,KAAA,OACAjD,iBAAA,EACAiF,YAAA,EACAC,aAAA,GAGA,IAAAoE,GAAA,GAAA7K,GAAAC,EAAAC,EAQA,OAPA2K,GAAAxJ,OACAwJ,EAAAtI,KAAAA,EACAsI,EAAAnL,GAAA,MAAAgL,IACAxH,EAAA2H,EAAAnL,IAAAmL,EAEA5K,EAAAiL,cAAAjL,EAAAiL,aAAAN,EAAAC,EAAAnL,IAEAmL,GAUAA,EAAAM,iBAAA,SAAAlL,GACA,GAAAmL,GAAAnL,EAAAoL,aAAAT,EACA,OAAA1H,GAAAkI,IASAP,EAAA5H,QAAA,SAAAqI,GACA,GAAAC,EACAnJ,GAAAoJ,MAAAF,GACAC,EAAAV,EAAAM,iBAAAG,GACS,gBAAAA,KACTC,EAAArI,EAAAoI,IAEAC,YAAAV,KAAAU,EAAAxI,cACAwI,EAAAtI,UAEAwI,aAAApM,KAAA6B,iBAIA2J,EAAAa,QACAb,EAAAa,KAAA,cAAAlJ,EAAAmJ,cACAvJ,EAAAwJ,MACA,MAAA,OAAA,SAAA,UAAA,WACA,SAAA,SAAA,OAAA,QAAA,UACA,WAAA,WAAA,aAAA,UAEA,SAAA7E,GACA8D,EAAAa,KAAA3E,GAAA3E,EAAA2E,KAIA7H,EAAAD,QAAA4L,GHkFM,SAAU3L,EAAQD,EAASM,GI5sBjC,YA2MA,SAAAsM,GAAAC,GACA,IAAAA,EAAAC,UAAA,CAGA,GAAAD,EAAAE,gBAAA,CACA,GAAAC,GAAAH,EAAAzF,MAAA4F,OACA7D,EAAA0D,EAAAzF,MAAA+B,KAGA8D,EAAAJ,EAAAK,WACAC,EAAAC,EAAAD,IACAF,GAAA9D,KAAA8D,EAAA9D,MACAA,IAAAA,YAAAkE,GAAAlE,EAAAgE,EAAAhE,QACA8D,EAAAD,OAAAC,EAAAD,QACAA,IAAAA,YAAAK,GAAAL,EAAAG,EAAAH,OAEA,IAAAM,KACA,KAAA,GAAAxF,KAAAmF,GACAA,EAAAM,eAAAzF,KACAwF,EAAAxF,GAAA+E,EAAAzF,MAAAU,GAIA+E,GAAAW,YAAAF,EAEAT,EAAAE,iBAAA,EAEAF,EAAAY,SAAAZ,EAAAK,YACAL,EAAAa,IAAA,EAEAb,EAAAC,WAAA,GAMA,QAAAa,GAAAd,GACA,GAAAA,EAAAC,UAAA,CAIA,GAAAc,GAAAf,EAAAW,WACAI,IAAAf,EAAAY,SAAAG,GACAf,EAAAa,IAAA,EAEAb,EAAAC,WAAA,GAMA,QAAAe,GAAAhB,GACA,UAAAA,EAAAtH,MAAA,cAAAsH,EAAAtH,KACAsH,EAAAiB,SAAA,SAAAtF,GACA,UAAAA,EAAAjD,MACAqH,EAAApE,KAGAoE,EAAAC,GAGA,QAAAkB,GAAAlB,GACA,UAAAA,EAAAtH,KACAsH,EAAAiB,SAAA,SAAAtF,GACA,UAAAA,EAAAjD,MACAoI,EAAAnF,KAGAmF,EAAAd,GAMA,QAAAmB,GAAAnB,EAAAoB,GAGApB,EAAAK,WAAAL,EAAAI,YAAAgB,MACApB,EAAAE,iBAAA,EAMA,QAAAmB,MAEA9N,KAAA+N,cAAAN,EAAAzN,MAMA,QAAAgO,MAEAhO,KAAA+N,cAAAJ,EAAA3N,MAMA,QAAAiO,KACAjO,KAAA+N,cAAA,EACAN,EAAAzN,MAMA,QAAAkO,KACAlO,KAAA+N,cAAA,EACAJ,EAAA3N,MAqDA,QAAAmO,GAAAC,EAAA3B,EAAA4B,EAAAC,EAAArG,GACA,GAAAsG,GAAAH,EAAA,SAAA,GACAI,EAAAF,GACAA,EAAAG,WAAA,oBAAAF,GACAG,EAAAJ,GACAA,EAAAG,WAAA,kBAAAF,EAEAD,IAAAA,EAAAG,WAAA,aACAhC,EAAAkC,UAAAN,EAAAG,EAAAE,EAAAzG,IACAwE,EAAAmC,KAAAP,GAAApG,GAAAA,KApXA,GAAAlF,GAAA7C,EAAA,GAEA2O,EAAA3O,EAAA,GACA4O,EAAAC,KAAAD,MACAE,EAAA9O,EAAA,GACA8M,EAAA9M,EAAA,IACA+O,EAAA/O,EAAA,IACAgP,EAAAhP,EAAA,IACA+M,EAAA/M,EAAA,IACAiP,EAAAjP,EAAA,IAEAoC,IACAA,GAAA8M,KAAArM,EACAT,EAAAoC,MAAAxE,EAAA,IAEAoC,EAAAgH,MAAApJ,EAAA,IAEAoC,EAAA+M,KAAAnP,EAAA,IAEAoC,EAAAgN,YAAApP,EAAA,IAEAoC,EAAAiN,OAAArP,EAAA,IAEAoC,EAAAkN,OAAAtP,EAAA,IAEAoC,EAAAmN,KAAAvP,EAAA,IAEAoC,EAAAoN,QAAAxP,EAAA,IAEAoC,EAAAqN,SAAAzP,EAAA,IAEAoC,EAAAsG,KAAA1I,EAAA,IAEAoC,EAAA6H,KAAAjK,EAAA,IAEAoC,EAAAsN,YAAA1P,EAAA,IAEAoC,EAAAuN,IAAA3P,EAAA,IAEAoC,EAAAwN,eAAA5P,EAAA,IAEAoC,EAAAyN,eAAA7P,EAAA,IAEAoC,EAAA0N,aAAA9P,EAAA,IACAoC,EAAA2N,OAAA/P,EAAA,IAIAoC,EAAA4N,YAAA,SAAArP,GACA,MAAAmO,GAAAmB,OAAAtP,IAMAyB,EAAA8N,WAAA,SAAAC,EAAAxP,GACA,MAAAgO,GAAAyB,iBAAAD,EAAAxP,IAUAyB,EAAAiO,SAAA,SAAAF,EAAAxP,EAAA2P,EAAAC,GACA,GAAAC,GAAA7B,EAAA8B,iBAAAN,EAAAxP,EACAsO,GAAA5O,KAAAmQ,EACA,IAAAE,GAAAF,EAAAG,iBACA,IAAAL,EAAA,CACA,GAAAM,GAAAF,EAAA/H,MAAA+H,EAAA9H,MAEA,IAAA,WAAA2H,EAAA,CAEA,GACA3H,GADAD,EAAA2H,EAAA1H,OAAAgI,CAEAjI,IAAA2H,EAAA3H,MACAC,EAAA0H,EAAA1H,QAGAD,EAAA2H,EAAA3H,MACAC,EAAAD,EAAAiI,EAEA,IAAAC,GAAAP,EAAA/G,EAAA+G,EAAA3H,MAAA,EACAmI,EAAAR,EAAA9G,EAAA8G,EAAA1H,OAAA,CAEA0H,GAAA/G,EAAAsH,EAAAlI,EAAA,EACA2H,EAAA9G,EAAAsH,EAAAlI,EAAA,EACA0H,EAAA3H,MAAAA,EACA2H,EAAA1H,OAAAA,EAGA9I,KAAAiR,WAAAP,EAAAF,GAIA,MADAzN,GAAAmO,SAAAR,EAAAvB,GACAuB,GAGApO,EAAA6O,UAAAtC,EAAAsC,UAOA7O,EAAA2O,WAAA,SAAAP,EAAAF,GACA,GAAAE,EAAAU,eAAA,CAIA,GAAAC,GAAAX,EAAAG,kBAEArQ,EAAA6Q,EAAAC,mBAAAd,EAEAE,GAAAU,eAAA5Q,KAgBA8B,EAAAiP,qBAAA,SAAAC,GACA,GAAAC,GAAAnP,EAAAmP,iBACAtN,EAAAqN,EAAArN,MACAuN,EAAAF,EAAAxK,MAAA0K,SAQA,OANA5C,GAAA,EAAA3K,EAAAiG,MAAA0E,EAAA,EAAA3K,EAAAmG,MACAnG,EAAAiG,GAAAjG,EAAAmG,GAAAmH,EAAAtN,EAAAiG,GAAAsH,GAAA,IAEA5C,EAAA,EAAA3K,EAAAkG,MAAAyE,EAAA,EAAA3K,EAAAoG,MACApG,EAAAkG,GAAAlG,EAAAoG,GAAAkH,EAAAtN,EAAAkG,GAAAqH,GAAA,IAEAF,GAgBAlP,EAAAqP,qBAAA,SAAAH,GACA,GAAAC,GAAAnP,EAAAmP,iBACAtN,EAAAqN,EAAArN,MACAuN,EAAAF,EAAAxK,MAAA0K,UACAE,EAAAzN,EAAAsF,EACAoI,EAAA1N,EAAAuF,EACAoI,EAAA3N,EAAA0E,MACAkJ,EAAA5N,EAAA2E,MAWA,OAVA3E,GAAAsF,EAAAgI,EAAAtN,EAAAsF,EAAAiI,GAAA,GACAvN,EAAAuF,EAAA+H,EAAAtN,EAAAuF,EAAAgI,GAAA,GACAvN,EAAA0E,MAAAkG,KAAAiD,IACAP,EAAAG,EAAAE,EAAAJ,GAAA,GAAAvN,EAAAsF,EACA,IAAAqI,EAAA,EAAA,GAEA3N,EAAA2E,OAAAiG,KAAAiD,IACAP,EAAAI,EAAAE,EAAAL,GAAA,GAAAvN,EAAAuF,EACA,IAAAqI,EAAA,EAAA,GAEAP,GAWAlP,EAAAmP,iBAAA,SAAAlI,EAAAmI,EAAAO,GAGA,GAAAC,GAAApD,EAAA,EAAAvF,EACA,QAAA2I,EAAApD,EAAA4C,IAAA,IAAA,EACAQ,EAAA,GACAA,GAAAD,EAAA,OAAA,GAkEA3P,EAAAmL,aAAAA,EAUAnL,EAAAqL,aAAAA,EAUArL,EAAAsL,mBAAAA,EAsCAtL,EAAA6P,cAAA,SAAA1F,EAAAI,GACA,UAAAJ,EAAAtH,KACAsH,EAAAiB,SAAA,SAAAtF,GACA,UAAAA,EAAAjD,MACAyI,EAAAxF,EAAAyE,KAGAe,EAAAnB,EAAAI,GAEAJ,EAAA3H,GAAA,YAAAgJ,GACAhJ,GAAA,WAAAkJ,GAGAvB,EAAA3H,GAAA,WAAAmJ,GACAnJ,GAAA,SAAAoJ,IAGA5L,EAAA8P,eAAA,SAAA3F,EAAA5J,GACA,GAAA4J,EAAAW,YACA,IAAA,GAAA1F,KAAA7E,GACA4J,EAAAW,YAAAD,eAAAzF,KACA+E,EAAAW,YAAA1F,GAAA7E,EAAA6E,KAYApF,EAAA+P,QAAA,SAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAAF,EAAA9D,WAAA,aAAA,SACAiE,EAAAD,EAAAE,QAAA,WAAA,EAAA,QAAAH,EACAI,EAAAL,EAAAM,SAAA,YACA9P,GAAAoN,OAAAmC,GACAQ,aAAAP,EAAA9D,WAAA,aAAA,EACAsE,SAAAH,EAAAI,UACAC,aAAAR,EACAS,SAAAN,EAAAO,gBAAAT,KAsBApQ,EAAA8Q,YAAArQ,EAAAsQ,MAAAlF,GAAA,GASA7L,EAAAgR,UAAAvQ,EAAAsQ,MAAAlF,GAAA,GASA7L,EAAAiR,aAAA,SAAAnP,EAAAoP,GAGA,IAFA,GAAAC,GAAAxE,EAAAyE,aAEAtP,GAAAA,IAAAoP,GACAvE,EAAA0E,IAAAF,EAAArP,EAAAwP,oBAAAH,GACArP,EAAAA,EAAAgC,MAGA,OAAAqN,IAUAnR,EAAA8O,eAAA,SAAAyC,EAAAC,EAAAC,GAIA,MAHAA,KACAD,EAAA7E,EAAA8E,UAAAD,IAEA5E,EAAAkC,kBAAAyC,EAAAC,IASAxR,EAAA0R,mBAAA,SAAAC,EAAAH,EAAAC,GAGA,GAAAG,GAAA,IAAAJ,EAAA,IAAA,IAAAA,EAAA,IAAA,IAAAA,EAAA,GACA,EAAA/E,KAAAoF,IAAA,EAAAL,EAAA,GAAAA,EAAA,IACAM,EAAA,IAAAN,EAAA,IAAA,IAAAA,EAAA,IAAA,IAAAA,EAAA,GACA,EAAA/E,KAAAoF,IAAA,EAAAL,EAAA,GAAAA,EAAA,IAEAD,GACA,SAAAI,GAAAC,EAAA,UAAAD,EAAAC,EAAA,EACA,QAAAD,GAAAG,EAAA,WAAAH,EAAAG,EAAA,EAKA,OAFAP,GAAAvR,EAAA8O,eAAAyC,EAAAC,EAAAC,GAEAhF,KAAAoF,IAAAN,EAAA,IAAA9E,KAAAoF,IAAAN,EAAA,IACAA,EAAA,GAAA,EAAA,QAAA,OACAA,EAAA,GAAA,EAAA,SAAA,OAGAhU,EAAAD,QAAA0C,GJotBM,SAAUzC,EAAQD,GKrnCxB,QAAAyU,GAAA3M,EAAA4M,GACAC,EAAA7M,GAAA4M,EAoBA,QAAArJ,GAAAuJ,GACA,GAAA,MAAAA,GAAA,gBAAAA,GACA,MAAAA,EAGA,IAAAC,GAAAD,EACAE,EAAAC,EAAApU,KAAAiU,EAEA,IAAA,mBAAAE,EAAA,CACAD,IAEA,KAAA,GAAAxO,GAAA,EAAA2O,EAAAJ,EAAAtO,OAAwCD,EAAA2O,EAAS3O,IACjDwO,EAAAxO,GAAAgF,EAAAuJ,EAAAvO,QAEG,IAAA4O,EAAAH,GAAA,CACH,GAAAI,GAAAN,EAAAO,WAEA,IAAAP,EAAAO,YAAAC,KACAP,EAAAK,EAAAE,KAAAR,OACK,CACLC,EAAA,GAAAK,GAAAN,EAAAtO,OAEA,KAAA,GAAAD,GAAA,EAAA2O,EAAAJ,EAAAtO,OAA0CD,EAAA2O,EAAS3O,IACnDwO,EAAAxO,GAAAgF,EAAAuJ,EAAAvO,SAGG,KAAAgP,EAAAP,KAAAQ,EAAAV,KAAArI,EAAAqI,GAAA,CACHC,IAEA,KAAA,GAAA1I,KAAAyI,GACAA,EAAArH,eAAApB,KACA0I,EAAA1I,GAAAd,EAAAuJ,EAAAzI,KAKA,MAAA0I,GAUA,QAAAU,GAAA/Q,EAAAoQ,EAAAY,GAGA,IAAAC,EAAAb,KAAAa,EAAAjR,GACA,MAAAgR,GAAAnK,EAAAuJ,GAAApQ,CAGA,KAAA,GAAA2H,KAAAyI,GACA,GAAAA,EAAArH,eAAApB,GAAA,CACA,GAAAuJ,GAAAlR,EAAA2H,GACAwJ,EAAAf,EAAAzI,IAEAsJ,EAAAE,KAAAF,EAAAC,IAAAE,EAAAD,IAAAC,EAAAF,IAAAnJ,EAAAoJ,IAAApJ,EAAAmJ,IAAAG,EAAAF,IAAAE,EAAAH,IAAAJ,EAAAK,IAAAL,EAAAI,IAGOF,GAAArJ,IAAA3H,KAGPA,EAAA2H,GAAAd,EAAAuJ,EAAAzI,IAAA,IAJAoJ,EAAAG,EAAAC,EAAAH,GASA,MAAAhR,GASA,QAAAsR,GAAAC,EAAAP,GAGA,IAAA,GAFAX,GAAAkB,EAAA,GAEA1P,EAAA,EAAA2O,EAAAe,EAAAzP,OAAgDD,EAAA2O,EAAS3O,IACzDwO,EAAAU,EAAAV,EAAAkB,EAAA1P,GAAAmP,EAGA,OAAAX,GASA,QAAAtE,GAAA/L,EAAAoQ,GACA,IAAA,GAAAzI,KAAAyI,GACAA,EAAArH,eAAApB,KACA3H,EAAA2H,GAAAyI,EAAAzI,GAIA,OAAA3H,GAUA,QAAAwH,GAAAxH,EAAAoQ,EAAAoB,GACA,IAAA,GAAA7J,KAAAyI,GACAA,EAAArH,eAAApB,KAAA6J,EAAA,MAAApB,EAAAzI,GAAA,MAAA3H,EAAA2H,MACA3H,EAAA2H,GAAAyI,EAAAzI,GAIA,OAAA3H,GAcA,QAAAsE,KAOA,MANAmN,KAGAA,EAAAC,IAAApN,WAAA,OAGAmN,EAQA,QAAAlD,GAAAoD,EAAAC,GACA,GAAAD,EAAA,CACA,GAAAA,EAAApD,QACA,MAAAoD,GAAApD,QAAAqD,EAGA,KAAA,GAAA/P,GAAA,EAAA2O,EAAAmB,EAAA7P,OAAuCD,EAAA2O,EAAS3O,IAChD,GAAA8P,EAAA9P,KAAA+P,EACA,MAAA/P,GAKA,SAWA,QAAAiL,GAAA+E,EAAAC,GAGA,QAAAC,MAFA,GAAAC,GAAAH,EAAA5S,SAIA8S,GAAA9S,UAAA6S,EAAA7S,UACA4S,EAAA5S,UAAA,GAAA8S,EAEA,KAAA,GAAAE,KAAAD,GACAH,EAAA5S,UAAAgT,GAAAD,EAAAC,EAGAJ,GAAA5S,UAAA0R,YAAAkB,EACAA,EAAAK,WAAAJ,EAUA,QAAA9K,GAAAhH,EAAAoQ,EAAAoB,GACAxR,EAAA,aAAAA,GAAAA,EAAAf,UAAAe,EACAoQ,EAAA,aAAAA,GAAAA,EAAAnR,UAAAmR,EACA5I,EAAAxH,EAAAoQ,EAAAoB,GAQA,QAAAW,GAAAC,GACA,GAAAA,EAIA,MAAA,gBAAAA,IAIA,gBAAAA,GAAAtQ,OAWA,QAAAqG,GAAAkK,EAAAxO,EAAAC,GACA,GAAAuO,GAAAxO,EAIA,GAAAwO,EAAAC,SAAAD,EAAAC,UAAAC,EACAF,EAAAC,QAAAzO,EAAAC,OACG,IAAAuO,EAAAvQ,UAAAuQ,EAAAvQ,OACH,IAAA,GAAAD,GAAA,EAAA2O,EAAA6B,EAAAvQ,OAAqCD,EAAA2O,EAAS3O,IAC9CgC,EAAA1H,KAAA2H,EAAAuO,EAAAxQ,GAAAA,EAAAwQ,OAGA,KAAA,GAAA1K,KAAA0K,GACAA,EAAAtJ,eAAApB,IACA9D,EAAA1H,KAAA2H,EAAAuO,EAAA1K,GAAAA,EAAA0K,GAeA,QAAAG,GAAAH,EAAAxO,EAAAC,GACA,GAAAuO,GAAAxO,EAAA,CAIA,GAAAwO,EAAAG,KAAAH,EAAAG,MAAAC,EACA,MAAAJ,GAAAG,IAAA3O,EAAAC,EAIA,KAAA,GAFAuM,MAEAxO,EAAA,EAAA2O,EAAA6B,EAAAvQ,OAAqCD,EAAA2O,EAAS3O,IAC9CwO,EAAA3M,KAAAG,EAAA1H,KAAA2H,EAAAuO,EAAAxQ,GAAAA,EAAAwQ,GAGA,OAAAhC,IAaA,QAAAqC,GAAAL,EAAAxO,EAAA8O,EAAA7O,GACA,GAAAuO,GAAAxO,EAAA,CAIA,GAAAwO,EAAAK,QAAAL,EAAAK,SAAAE,EACA,MAAAP,GAAAK,OAAA7O,EAAA8O,EAAA7O,EAEA,KAAA,GAAAjC,GAAA,EAAA2O,EAAA6B,EAAAvQ,OAAqCD,EAAA2O,EAAS3O,IAC9C8Q,EAAA9O,EAAA1H,KAAA2H,EAAA6O,EAAAN,EAAAxQ,GAAAA,EAAAwQ,EAGA,OAAAM,IAaA,QAAAE,GAAAR,EAAAxO,EAAAC,GACA,GAAAuO,GAAAxO,EAAA,CAIA,GAAAwO,EAAAQ,QAAAR,EAAAQ,SAAAC,EACA,MAAAT,GAAAQ,OAAAhP,EAAAC,EAIA,KAAA,GAFAuM,MAEAxO,EAAA,EAAA2O,EAAA6B,EAAAvQ,OAAqCD,EAAA2O,EAAS3O,IAC9CgC,EAAA1H,KAAA2H,EAAAuO,EAAAxQ,GAAAA,EAAAwQ,IACAhC,EAAA3M,KAAA2O,EAAAxQ,GAIA,OAAAwO,IAaA,QAAA0C,GAAAV,EAAAxO,EAAAC,GACA,GAAAuO,GAAAxO,EAIA,IAAA,GAAAhC,GAAA,EAAA2O,EAAA6B,EAAAvQ,OAAmCD,EAAA2O,EAAS3O,IAC5C,GAAAgC,EAAA1H,KAAA2H,EAAAuO,EAAAxQ,GAAAA,EAAAwQ,GACA,MAAAA,GAAAxQ,GAYA,QAAAgB,GAAAmQ,EAAAlP,GACA,GAAAmP,GAAAC,EAAA/W,KAAAgX,UAAA,EACA,OAAA,YACA,MAAAH,GAAAI,MAAAtP,EAAAmP,EAAAI,OAAAH,EAAA/W,KAAAgX,cAUA,QAAAlE,GAAA+D,GACA,GAAAC,GAAAC,EAAA/W,KAAAgX,UAAA,EACA,OAAA,YACA,MAAAH,GAAAI,MAAAxX,KAAAqX,EAAAI,OAAAH,EAAA/W,KAAAgX,cAUA,QAAA/B,GAAAQ,GACA,MAAA,mBAAArB,EAAApU,KAAAyV,GASA,QAAA0B,GAAA1B,GACA,MAAA,kBAAAA,GASA,QAAA2B,GAAA3B,GACA,MAAA,oBAAArB,EAAApU,KAAAyV,GASA,QAAAX,GAAAW,GAGA,GAAA7Q,SAAA6Q,EACA,OAAA,aAAA7Q,KAAA6Q,GAAA,UAAA7Q,EASA,QAAAsQ,GAAAO,GACA,QAAAf,EAAAN,EAAApU,KAAAyV,IASA,QAAA7J,GAAA6J,GACA,MAAA,gBAAAA,IAAA,gBAAAA,GAAA4B,UAAA,gBAAA5B,GAAA6B,cASA,QAAAC,GAAA9B,GACA,MAAAA,KAAAA,EAUA,QAAA+B,GAAAC,GACA,IAAA,GAAA/R,GAAA,EAAA2O,EAAA2C,UAAArR,OAAyCD,EAAA2O,EAAS3O,IAClD,GAAA,MAAAsR,UAAAtR,GACA,MAAAsR,WAAAtR,GAKA,QAAAgS,GAAAC,EAAAC,GACA,MAAA,OAAAD,EAAAA,EAAAC,EAGA,QAAAC,GAAAF,EAAAC,EAAAE,GACA,MAAA,OAAAH,EAAAA,EAAA,MAAAC,EAAAA,EAAAE,EAWA,QAAAC,KACA,MAAAC,UAAAhY,KAAAiX,MAAAF,EAAAC,WAaA,QAAAiB,GAAAC,GACA,GAAA,gBAAAA,GACA,OAAAA,EAAAA,EAAAA,EAAAA,EAGA,IAAA7D,GAAA6D,EAAAvS,MAEA,OAAA,KAAA0O,GAEA6D,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACG,IAAA7D,GAEH6D,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAGAA,EASA,QAAAC,GAAAC,EAAAC,GACA,IAAAD,EACA,KAAA,IAAAhN,OAAAiN,GASA,QAAAC,GAAApC,GACAA,EAAAqC,IAAA,EAGA,QAAA5D,GAAAuB,GACA,MAAAA,GAAAqC,GAQA,QAAAC,GAAAtC,GACAA,GAAAlK,EAAAkK,EAAA,SAAAT,EAAAjK,GACA/L,KAAAyC,IAAAsJ,EAAAiK,IACGhW,MAmCH,QAAAgZ,GAAAvC,GACA,MAAA,IAAAsC,GAAAtC,GAGA,QAAAwC,MA3nBA,GAAAhE,IACAiE,oBAAA,EACAC,kBAAA,EACAC,gBAAA,EACAC,iBAAA,EACAC,0BAAA,EACAC,yBAAA,EAEAC,iBAAA,EACAC,kBAAA,GAEA5E,GACA6E,qBAAA,EACAC,sBAAA,EACAC,6BAAA,EACAC,sBAAA,EACAC,uBAAA,EACAC,sBAAA,EACAC,uBAAA,EACAC,wBAAA,EACAC,wBAAA,GAEAvF,EAAAwF,OAAA9W,UAAA+W,SACAC,EAAAC,MAAAjX,UACAsT,EAAA0D,EAAA3D,QACAQ,EAAAmD,EAAApD,OACAK,EAAA+C,EAAA/B,MACAzB,EAAAwD,EAAAzD,IACAI,EAAAqD,EAAAvD,OAEAvC,KAgJAuB,EAAA,WACA,MAAAvB,GAAAuB,eAGAvB,GAAAuB,aAAA,WACA,MAAAtN,UAAAC,cAAA,UAIA,IAAAoN,GAwYAiD,EAAA,mBAyBAyB,EAAA,OACAC,EAAA,CACAzB,GAAA1V,WACA0R,YAAAgE,EAIAlT,IAAA,SAAAkG,GACA,MAAA/L,MAAAua,EAAAxO,IAEAtJ,IAAA,SAAAsJ,EAAAiK,GAIA,MAHAhW,MAAAua,EAAAxO,GAAAiK,EAGAA,GAIAzJ,KAAA,SAAAtE,EAAAC,GACA,SAAAA,IAAAD,EAAAhB,EAAAgB,EAAAC,GAEA,KAAA,GAAAuS,KAAAza,MACAA,KAAAmN,eAAAsN,IAAAxS,EAAAjI,KAAAya,GAAAA,EAAAnC,MAAAkC,KAIAE,UAAA,SAAA3O,SACA/L,MAAAua,EAAAxO,KAUAnM,EAAAyU,UAAAA,EACAzU,EAAAqL,MAAAA,EACArL,EAAAuV,MAAAA,EACAvV,EAAA8V,SAAAA,EACA9V,EAAAuQ,OAAAA,EACAvQ,EAAAgM,SAAAA,EACAhM,EAAAkW,aAAAA,EACAlW,EAAA8I,WAAAA,EACA9I,EAAA+S,QAAAA,EACA/S,EAAAsR,SAAAA,EACAtR,EAAAwL,MAAAA,EACAxL,EAAA2W,YAAAA,EACA3W,EAAA2M,KAAAA,EACA3M,EAAAgX,IAAAA,EACAhX,EAAAkX,OAAAA,EACAlX,EAAAqX,OAAAA,EACArX,EAAAuX,KAAAA,EACAvX,EAAAqH,KAAAA,EACArH,EAAAyT,MAAAA,EACAzT,EAAA4V,QAAAA,EACA5V,EAAA8X,WAAAA,EACA9X,EAAA+X,SAAAA,EACA/X,EAAAyV,SAAAA,EACAzV,EAAA6V,gBAAAA,EACA7V,EAAAuM,MAAAA,EACAvM,EAAAkY,MAAAA,EACAlY,EAAAmY,SAAAA,EACAnY,EAAAqY,UAAAA,EACArY,EAAAwY,UAAAA,EACAxY,EAAA0Y,MAAAA,EACA1Y,EAAA4Y,kBAAAA,EACA5Y,EAAA8Y,OAAAA,EACA9Y,EAAAiZ,eAAAA,EACAjZ,EAAAsV,YAAAA,EACAtV,EAAAoZ,cAAAA,EACApZ,EAAAqZ,KAAAA,GL+pCM,SAAUpZ,EAAQD,EAASM,GM1yDjC,QAAAya,GAAAvQ,EAAAC,EAAAC,EAAAC,EAAAqQ,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAvK,GACA,GAAAwK,GAAAF,GAAAG,EAAA,KACAC,EAAAC,EAAAH,IAAA9Q,EAAAE,GAAA,EAAAgR,EAAAJ,IAAA7Q,EAAAE,GAAA,EACAgR,KAAAD,EAAAJ,IAAA9Q,EAAAE,GAAA,EAAA+Q,EAAAH,IAAA7Q,EAAAE,GAAA,EACAiR,EAAAJ,EAAAA,GAAAN,EAAAA,GAAAS,EAAAA,GAAAR,EAAAA,EAEAS,GAAA,IACAV,GAAAW,EAAAD,GACAT,GAAAU,EAAAD,GAGA,IAAAE,IAAAd,IAAAC,KAAA,GAAAY,GAAAX,EAAAA,GAAAC,EAAAA,GAAAD,EAAAA,GAAAS,EAAAA,GAAAR,EAAAA,GAAAK,EAAAA,KAAAN,EAAAA,GAAAS,EAAAA,GAAAR,EAAAA,GAAAK,EAAAA,MAAA,EACAO,EAAAD,EAAAZ,EAAAS,EAAAR,EACAa,EAAAF,GAAAX,EAAAK,EAAAN,EACA/J,GAAA3G,EAAAE,GAAA,EAAA+Q,EAAAH,GAAAS,EAAAL,EAAAJ,GAAAU,EACA5K,GAAA3G,EAAAE,GAAA,EAAA+Q,EAAAJ,GAAAS,EAAAN,EAAAH,GAAAU,EACAC,EAAAC,GAAA,EAAA,KAAAV,EAAAO,GAAAb,GAAAS,EAAAK,GAAAb,IACAgB,IAAAX,EAAAO,GAAAb,GAAAS,EAAAK,GAAAb,GACAiB,OAAAZ,EAAAO,GAAAb,MAAAS,EAAAK,GAAAb,GACAkB,EAAAH,EAAAC,EAAAC,EAEAE,GAAAH,EAAAC,SACAC,EAAAd,GAGAe,EAAAH,EAAAC,IAAA,IACAC,EAAA,GAGA,IAAApB,GAAAoB,EAAA,IACAA,GAAA,EAAAd,GAGA,IAAAN,GAAAoB,EAAA,IACAA,GAAA,EAAAd,GAGAzK,EAAAyL,QAAAlB,EAAAlK,EAAAC,EAAA8J,EAAAC,EAAAc,EAAAI,EAAAf,EAAAL,GAGA,QAAAuB,GAAA5F,GACA,IAAAA,EACA,QAIA,IACA6F,GADAC,EAAA9F,EAAA+F,QAAA,KAAA,MAAAA,QAAA,MAAA,KAAAA,QAAA,KAAA,KAAAA,QAAA,MAAA,IAGA,KAAAF,EAAA,EAAaA,EAAAG,EAAAtW,OAAemW,IAC5BC,EAAAA,EAAAC,QAAA,GAAAE,QAAAD,EAAAH,GAAA,KAAA,IAAAG,EAAAH,GAIA,IAMAK,GANAvU,EAAAmU,EAAAK,MAAA,KAEAC,EAAA,EACAC,EAAA,EACAnM,EAAA,GAAAoM,GACAC,EAAAD,EAAAC,GAGA,KAAAV,EAAA,EAAaA,EAAAlU,EAAAjC,OAAgBmW,IAAA,CAC7B,GAIApB,GAJA+B,EAAA7U,EAAAkU,GACA5b,EAAAuc,EAAAC,OAAA,GACAC,EAAA,EACAxc,EAAAsc,EAAA1E,MAAA,GAAAiE,QAAA,OAAA,MAAAI,MAAA,IAGAjc,GAAAwF,OAAA,GAAA,KAAAxF,EAAA,IACAA,EAAAyc,OAGA,KAAA,GAAAlX,GAAA,EAAmBA,EAAAvF,EAAAwF,OAAcD,IACjCvF,EAAAuF,GAAAmX,WAAA1c,EAAAuF,GAGA,MAAAiX,EAAAxc,EAAAwF,SAAAmX,MAAA3c,EAAAwc,MACAG,MAAA3c,EAAA,KADA,CAKA,GAAA4c,GACAC,EACAzC,EACAC,EACAG,EACAN,EACAC,EACAzQ,EAAAwS,EACAvS,EAAAwS,CAEA,QAAApc,GACA,IAAA,IACAmc,GAAAlc,EAAAwc,KACAL,GAAAnc,EAAAwc,KACAjC,EAAA8B,EAAAS,EACA9M,EAAAyL,QAAAlB,EAAA2B,EAAAC,EACA,MAEA,KAAA,IACAD,EAAAlc,EAAAwc,KACAL,EAAAnc,EAAAwc,KACAjC,EAAA8B,EAAAS,EACA9M,EAAAyL,QAAAlB,EAAA2B,EAAAC,EACA,MAEA,KAAA,IACAD,GAAAlc,EAAAwc,KACAL,GAAAnc,EAAAwc,KACAjC,EAAA8B,EAAAU,EACA/M,EAAAyL,QAAAlB,EAAA2B,EAAAC,GACApc,EAAA,GACA,MAEA,KAAA,IACAmc,EAAAlc,EAAAwc,KACAL,EAAAnc,EAAAwc,KACAjC,EAAA8B,EAAAU,EACA/M,EAAAyL,QAAAlB,EAAA2B,EAAAC,GACApc,EAAA,GACA,MAEA,KAAA,IACAmc,GAAAlc,EAAAwc,KACAjC,EAAA8B,EAAAS,EACA9M,EAAAyL,QAAAlB,EAAA2B,EAAAC,EACA,MAEA,KAAA,IACAD,EAAAlc,EAAAwc,KACAjC,EAAA8B,EAAAS,EACA9M,EAAAyL,QAAAlB,EAAA2B,EAAAC,EACA,MAEA,KAAA,IACAA,GAAAnc,EAAAwc,KACAjC,EAAA8B,EAAAS,EACA9M,EAAAyL,QAAAlB,EAAA2B,EAAAC,EACA,MAEA,KAAA,IACAA,EAAAnc,EAAAwc,KACAjC,EAAA8B,EAAAS,EACA9M,EAAAyL,QAAAlB,EAAA2B,EAAAC,EACA,MAEA,KAAA,IACA5B,EAAA8B,EAAAW,EACAhN,EAAAyL,QAAAlB,EAAAva,EAAAwc,KAAAxc,EAAAwc,KAAAxc,EAAAwc,KAAAxc,EAAAwc,KAAAxc,EAAAwc,KAAAxc,EAAAwc,MACAN,EAAAlc,EAAAwc,EAAA,GACAL,EAAAnc,EAAAwc,EAAA,EACA,MAEA,KAAA,IACAjC,EAAA8B,EAAAW,EACAhN,EAAAyL,QAAAlB,EAAAva,EAAAwc,KAAAN,EAAAlc,EAAAwc,KAAAL,EAAAnc,EAAAwc,KAAAN,EAAAlc,EAAAwc,KAAAL,EAAAnc,EAAAwc,KAAAN,EAAAlc,EAAAwc,KAAAL,GACAD,GAAAlc,EAAAwc,EAAA,GACAL,GAAAnc,EAAAwc,EAAA,EACA,MAEA,KAAA,IACAI,EAAAV,EACAW,EAAAV,CACA,IAAAjI,GAAAlE,EAAAkE,MACAvE,EAAAK,EAAA8F,IAEAkG,KAAAK,EAAAW,IACAJ,GAAAV,EAAAvM,EAAAuE,EAAA,GACA2I,GAAAV,EAAAxM,EAAAuE,EAAA,IAGAqG,EAAA8B,EAAAW,EACAtT,EAAA1J,EAAAwc,KACA7S,EAAA3J,EAAAwc,KACAN,EAAAlc,EAAAwc,KACAL,EAAAnc,EAAAwc,KACAxM,EAAAyL,QAAAlB,EAAAqC,EAAAC,EAAAnT,EAAAC,EAAAuS,EAAAC,EACA,MAEA,KAAA,IACAS,EAAAV,EACAW,EAAAV,CACA,IAAAjI,GAAAlE,EAAAkE,MACAvE,EAAAK,EAAA8F,IAEAkG,KAAAK,EAAAW,IACAJ,GAAAV,EAAAvM,EAAAuE,EAAA,GACA2I,GAAAV,EAAAxM,EAAAuE,EAAA,IAGAqG,EAAA8B,EAAAW,EACAtT,EAAAwS,EAAAlc,EAAAwc,KACA7S,EAAAwS,EAAAnc,EAAAwc,KACAN,GAAAlc,EAAAwc,KACAL,GAAAnc,EAAAwc,KACAxM,EAAAyL,QAAAlB,EAAAqC,EAAAC,EAAAnT,EAAAC,EAAAuS,EAAAC,EACA,MAEA,KAAA,IACAzS,EAAA1J,EAAAwc,KACA7S,EAAA3J,EAAAwc,KACAN,EAAAlc,EAAAwc,KACAL,EAAAnc,EAAAwc,KACAjC,EAAA8B,EAAAY,EACAjN,EAAAyL,QAAAlB,EAAA7Q,EAAAC,EAAAuS,EAAAC,EACA,MAEA,KAAA,IACAzS,EAAA1J,EAAAwc,KAAAN,EACAvS,EAAA3J,EAAAwc,KAAAL,EACAD,GAAAlc,EAAAwc,KACAL,GAAAnc,EAAAwc,KACAjC,EAAA8B,EAAAY,EACAjN,EAAAyL,QAAAlB,EAAA7Q,EAAAC,EAAAuS,EAAAC,EACA,MAEA,KAAA,IACAS,EAAAV,EACAW,EAAAV,CACA,IAAAjI,GAAAlE,EAAAkE,MACAvE,EAAAK,EAAA8F,IAEAkG,KAAAK,EAAAY,IACAL,GAAAV,EAAAvM,EAAAuE,EAAA,GACA2I,GAAAV,EAAAxM,EAAAuE,EAAA,IAGAgI,EAAAlc,EAAAwc,KACAL,EAAAnc,EAAAwc,KACAjC,EAAA8B,EAAAY,EACAjN,EAAAyL,QAAAlB,EAAAqC,EAAAC,EAAAX,EAAAC,EACA,MAEA,KAAA,IACAS,EAAAV,EACAW,EAAAV,CACA,IAAAjI,GAAAlE,EAAAkE,MACAvE,EAAAK,EAAA8F,IAEAkG,KAAAK,EAAAY,IACAL,GAAAV,EAAAvM,EAAAuE,EAAA,GACA2I,GAAAV,EAAAxM,EAAAuE,EAAA,IAGAgI,GAAAlc,EAAAwc,KACAL,GAAAnc,EAAAwc,KACAjC,EAAA8B,EAAAY,EACAjN,EAAAyL,QAAAlB,EAAAqC,EAAAC,EAAAX,EAAAC,EACA,MAEA,KAAA,IACA/B,EAAApa,EAAAwc,KACAnC,EAAAra,EAAAwc,KACAhC,EAAAxa,EAAAwc,KACAtC,EAAAla,EAAAwc,KACArC,EAAAna,EAAAwc,KACA9S,EAAAwS,EAAAvS,EAAAwS,EACAD,EAAAlc,EAAAwc,KACAL,EAAAnc,EAAAwc,KACAjC,EAAA8B,EAAAa,EACAjD,EAAAvQ,EAAAC,EAAAuS,EAAAC,EAAAjC,EAAAC,EAAAC,EAAAC,EAAAG,EAAAD,EAAAvK,EACA,MAEA,KAAA,IACAoK,EAAApa,EAAAwc,KACAnC,EAAAra,EAAAwc,KACAhC,EAAAxa,EAAAwc,KACAtC,EAAAla,EAAAwc,KACArC,EAAAna,EAAAwc,KACA9S,EAAAwS,EAAAvS,EAAAwS,EACAD,GAAAlc,EAAAwc,KACAL,GAAAnc,EAAAwc,KACAjC,EAAA8B,EAAAa,EACAjD,EAAAvQ,EAAAC,EAAAuS,EAAAC,EAAAjC,EAAAC,EAAAC,EAAAC,EAAAG,EAAAD,EAAAvK,IAKA,MAAAjQ,GAAA,MAAAA,IACAwa,EAAA8B,EAAAc,EACAnN,EAAAyL,QAAAlB,IAGAyB,EAAAzB,EAIA,MADAvK,GAAAoN,WACApN,EAIA,QAAAqN,GAAAf,EAAAnc,GACA,GAAAmd,GAAA5B,EAAAY,EAuBA,OAtBAnc,GAAAA,MAEAA,EAAAod,UAAA,SAAAvN,GACA,GAAAA,EAAAwN,QAAA,CACAxN,EAAAwN,QAAAF,EAAAxH,KAEA,IAAA2H,GAAAzN,EAAAhI,YAEAyV,IACAzN,EAAA0N,YAAAD,OAEK,CACL,GAAAA,GAAAzN,CACAsN,GAAAI,YAAAD,KAIAtd,EAAAuQ,eAAA,SAAA5Q,GACA6d,EAAAL,EAAAxd,GACAR,KAAAse,OAAA,IAGAzd,EASA,QAAA8P,GAAAqM,EAAAnc,GACA,MAAA,IAAAmO,GAAA+O,EAAAf,EAAAnc,IASA,QAAAyP,GAAA0M,EAAAnc,GACA,MAAAmO,GAAAmB,OAAA4N,EAAAf,EAAAnc,IAUA,QAAAsQ,GAAAoN,EAAA1d,GAIA,IAAA,GAHA2d,MACA5J,EAAA2J,EAAArY,OAEAD,EAAA,EAAiBA,EAAA2O,EAAS3O,IAAA,CAC1B,GAAAwY,GAAAF,EAAAtY,EAEAwY,GAAA/N,MACA+N,EAAAC,kBAGAD,EAAAE,aACAF,EAAAR,UAAAQ,EAAA/N,KAAA+N,EAAAta,OAAA,GAGAqa,EAAA1W,KAAA2W,EAAA/N,MAGA,GAAAkO,GAAA,GAAA5P,GAAAnO,EAcA,OAZA+d,GAAAF,kBAEAE,EAAAX,UAAA,SAAAvN,GACAA,EAAAmO,WAAAL,EAEA,IAAAL,GAAAzN,EAAAhI,YAEAyV,IACAzN,EAAA0N,YAAAD,IAIAS,EAnZA,GAAA5P,GAAA9O,EAAA,GAEA4c,EAAA5c,EAAA,IAEAme,EAAAne,EAAA,IAGAsc,GAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,KACAf,EAAA1M,KAAA+P,KACAxD,EAAAvM,KAAAgQ,IACA1D,EAAAtM,KAAAiQ,IACA7D,EAAApM,KAAAoM,GAEA8D,EAAA,SAAAjD,GACA,MAAAjN,MAAA+P,KAAA9C,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,KAGAE,EAAA,SAAAH,EAAAC,GACA,OAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,KAAAiD,EAAAlD,GAAAkD,EAAAjD,KAGAF,EAAA,SAAAC,EAAAC,GACA,OAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,MAAA,GAAAjN,KAAAmQ,KAAAhD,EAAAH,EAAAC,IAgYApc,GAAA+Q,iBAAAA,EACA/Q,EAAA0Q,iBAAAA,EACA1Q,EAAAuR,UAAAA,GNy0DM,SAAUtR,EAAQD,EAASM,GO7sEjC,QAAA8O,GAAAnO,GACAse,EAAA5e,KAAAP,KAAAa,GAMAb,KAAA0Q,KAAA,KA3BA,GAAAyO,GAAAjf,EAAA,GAEA6C,EAAA7C,EAAA,GAEA4c,EAAA5c,EAAA,IAEAkf,EAAAlf,EAAA,IAEAmf,EAAAnf,EAAA,IAEAof,EAAAD,EAAAhc,UAAAic,iBACAnL,EAAApF,KAAAoF,IACAoL,EAAA,GAAAzC,KAAA,GAkBA9N,GAAA3L,WACA0R,YAAA/F,EACA7J,KAAA,OACAwZ,aAAA,EACAa,uBAAA,EACAC,MAAA,SAAAtB,EAAAuB,GACA,GAAA1Y,GAAAhH,KAAAgH,MACA0J,EAAA1Q,KAAA0Q,MAAA6O,EACAI,EAAA3Y,EAAA2Y,YACAC,EAAA5Y,EAAA4Y,UACA7W,EAAA/B,EAAA+B,KACA6D,EAAA5F,EAAA4F,OACAiT,EAAAD,KAAA7W,EAAA+W,WACAC,EAAAJ,KAAA/S,EAAAkT,WACAE,EAAAJ,KAAA7W,EAAAY,MACAsW,EAAAN,KAAA/S,EAAAjD,KAIA,IAHA3C,EAAAC,KAAAkX,EAAAne,KAAA0f,GACA1f,KAAAkgB,aAAA/B,GAEAne,KAAAmgB,QAAA,CACA,GAAA3P,EAEAqP,KACArP,EAAAA,GAAAxQ,KAAA6Q,kBACA7Q,KAAAogB,cAAApZ,EAAAqZ,YAAAlC,EAAApV,EAAAyH,IAGAuP,IACAvP,EAAAA,GAAAxQ,KAAA6Q,kBACA7Q,KAAAsgB,gBAAAtZ,EAAAqZ,YAAAlC,EAAAvR,EAAA4D,IAKAqP,EAEA1B,EAAAoC,UAAAvgB,KAAAogB,cACKJ,IACL7B,EAAAoC,UAAAjB,EAAA/e,KAAAwI,EAAAoV,IAGA4B,EACA5B,EAAAqC,YAAAxgB,KAAAsgB,gBACKL,IACL9B,EAAAqC,YAAAlB,EAAA/e,KAAAqM,EAAAuR,GAGA,IAAA3T,GAAAxD,EAAAwD,SACAiW,EAAAzZ,EAAAyZ,eACAC,IAAAvC,EAAAwC,YAEAnX,EAAAxJ,KAAA4gB,gBACAlQ,GAAAmQ,SAAArX,EAAA,GAAAA,EAAA,IAMAxJ,KAAA2e,aAAAnU,IAAAkW,GAAAf,GACAjP,EAAAoQ,UAAA3C,GAEA3T,IAAAkW,IACAhQ,EAAAiQ,YAAAnW,GACAkG,EAAAqQ,kBAAAN,IAGAzgB,KAAAie,UAAAvN,EAAA1Q,KAAAmE,OAAA,GAEAnE,KAAA0Q,OACA1Q,KAAA2e,aAAA,KAIAR,EAAA2C,YACA9gB,KAAA0Q,KAAA0N,YAAAD,IAGAyB,GAAAlP,EAAA3H,KAAAoV,GAEA3T,GAAAkW,IACAvC,EAAAwC,YAAAnW,GACA2T,EAAAsC,eAAAA,GAGAd,GAAAjP,EAAA9D,OAAAuR,GAEA3T,GAAAkW,GAGAvC,EAAAwC,gBAGA3gB,KAAAghB,iBAAA7C,GAEA,MAAAnX,EAAAkE,MACAlL,KAAAihB,aAAA9C,EAAAne,KAAA6Q,oBAKAoN,UAAA,SAAAE,EAAA+C,EAAAC,KACAzC,gBAAA,WACA1e,KAAA0Q,KAAA,GAAAoM,IAEAjM,gBAAA,WACA,GAAAL,GAAAxQ,KAAAohB,MACApa,EAAAhH,KAAAgH,MACAqa,GAAA7Q,CAEA,IAAA6Q,EAAA,CACA,GAAA3Q,GAAA1Q,KAAA0Q,IAEAA,KAEAA,EAAA1Q,KAAA0Q,KAAA,GAAAoM,IAGA9c,KAAA2e,cACAjO,EAAAoQ,YACA9gB,KAAAie,UAAAvN,EAAA1Q,KAAAmE,OAAA,IAGAqM,EAAAE,EAAAG,kBAKA,GAFA7Q,KAAAohB,MAAA5Q,EAEAxJ,EAAA2Y,YAAA,CAIA,GAAA2B,GAAAthB,KAAAuhB,kBAAAvhB,KAAAuhB,gBAAA/Q,EAAAvF,QAEA,IAAAjL,KAAAmgB,SAAAkB,EAAA,CACAC,EAAAE,KAAAhR,EAEA,IAAAiR,GAAAza,EAAA0K,UAEAgQ,EAAA1a,EAAA2a,cAAA3hB,KAAA4hB,eAAA,CAEA5a,GAAA4Y,YACA6B,EAAA1S,KAAAiD,IAAAyP,EAAAzhB,KAAAwf,wBAAA,IAKAkC,EAAA,QACAJ,EAAAzY,OAAA4Y,EAAAC,EACAJ,EAAAxY,QAAA2Y,EAAAC,EACAJ,EAAA7X,GAAAgY,EAAAC,EAAA,EACAJ,EAAA5X,GAAA+X,EAAAC,EAAA,GAKA,MAAAJ,GAGA,MAAA9Q,IAEAqR,QAAA,SAAApY,EAAAC,GACA,GAAAoY,GAAA9hB,KAAA+hB,sBAAAtY,EAAAC,GACA8G,EAAAxQ,KAAA6Q,kBACA7J,EAAAhH,KAAAgH,KAIA,IAHAyC,EAAAqY,EAAA,GACApY,EAAAoY,EAAA,GAEAtR,EAAAqR,QAAApY,EAAAC,GAAA,CACA,GAAA2G,GAAArQ,KAAA0Q,KAAA8F,IAEA,IAAAxP,EAAA2Y,YAAA,CACA,GAAAjO,GAAA1K,EAAA0K,UACAgQ,EAAA1a,EAAA2a,cAAA3hB,KAAA4hB,eAAA,CAEA,IAAAF,EAAA,QAEA1a,EAAA4Y,YACAlO,EAAA3C,KAAAiD,IAAAN,EAAA1R,KAAAwf,yBAGAJ,EAAA4C,cAAA3R,EAAAqB,EAAAgQ,EAAAjY,EAAAC,IACA,OAAA,EAKA,GAAA1C,EAAA4Y,UACA,MAAAR,GAAAyC,QAAAxR,EAAA5G,EAAAC,GAIA,OAAA,GAMA4U,MAAA,SAAA2D,GACA,MAAAA,IACAA,GAAA,GAIAA,IACAjiB,KAAA2e,YAAAsD,EACAjiB,KAAAohB,MAAA,MAGAphB,KAAAmgB,SAAA,EACAngB,KAAAkiB,MAAAliB,KAAAkiB,KAAAC,UAEAniB,KAAAoiB,cACApiB,KAAAoiB,aAAA9D,SAQA+D,aAAA,SAAAC,GACA,MAAAtiB,MAAAuiB,QAAA,QAAAD,IAGAE,OAAA,SAAAzW,EAAAiK,GAEA,UAAAjK,GACA/L,KAAAyiB,SAAAzM,GACAhW,KAAA2e,aAAA,EACA3e,KAAAohB,MAAA,MAEAjC,EAAA9b,UAAAmf,OAAAjiB,KAAAP,KAAA+L,EAAAiK,IAQAyM,SAAA,SAAA1W,EAAAiK,GACA,GAAA7R,GAAAnE,KAAAmE,KAEA,IAAAA,EAAA,CACA,GAAApB,EAAAsS,SAAAtJ,GACA,IAAA,GAAArE,KAAAqE,GACAA,EAAAoB,eAAAzF,KACAvD,EAAAuD,GAAAqE,EAAArE,QAIAvD,GAAA4H,GAAAiK,CAGAhW,MAAAse,OAAA,GAGA,MAAAte,OAEA4hB,aAAA,WACA,GAAAphB,GAAAR,KAAA8T,SAKA,OAAAtT,IAAA2T,EAAA3T,EAAA,GAAA,GAAA,OAAA2T,EAAA3T,EAAA,GAAA,GAAA,MAAAuO,KAAA+P,KAAA3K,EAAA3T,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,KAAA,IAcAwO,EAAAmB,OAAA,SAAAvE,GACA,GAAA8W,GAAA,SAAA7hB,GACAmO,EAAAzO,KAAAP,KAAAa,GAEA+K,EAAA5E,OAEAhH,KAAAgH,MAAA2b,WAAA/W,EAAA5E,OAAA,EAIA,IAAA4b,GAAAhX,EAAAzH,KAEA,IAAAye,EAAA,CACA5iB,KAAAmE,MAAAnE,KAAAmE,SACA,IAAA0e,GAAA7iB,KAAAmE,KAEA,KAAA,GAAAuD,KAAAkb,IACAC,EAAA1V,eAAAzF,IAAAkb,EAAAzV,eAAAzF,KACAmb,EAAAnb,GAAAkb,EAAAlb,IAKAkE,EAAA5J,MAAA4J,EAAA5J,KAAAzB,KAAAP,KAAAa,GAGAkC,GAAAmO,SAAAwR,EAAA1T,EAEA,KAAA,GAAAtH,KAAAkE,GAEA,UAAAlE,GAAA,UAAAA,IACAgb,EAAArf,UAAAqE,GAAAkE,EAAAlE,GAIA,OAAAgb,IAGA3f,EAAAmO,SAAAlC,EAAAmQ,EACA,IAAA2D,GAAA9T,CACAnP,GAAAD,QAAAkjB,GPuuEM,SAAUjjB,EAAQD,EAASM,GQhjFjC,QAAAif,GAAAte,GACAA,EAAAA,MACAkiB,EAAAxiB,KAAAP,KAAAa,EAEA,KAAA,GAAA6G,KAAA7G,GACAA,EAAAsM,eAAAzF,IAAA,UAAAA,IACA1H,KAAA0H,GAAA7G,EAAA6G,GAQA1H,MAAAgH,MAAA,GAAAgc,GAAAniB,EAAAmG,MAAAhH,MACAA,KAAAohB,MAAA,KAEAphB,KAAAijB,eApCA,GAAAlgB,GAAA7C,EAAA,GAEA8iB,EAAA9iB,EAAA,GAEA6iB,EAAA7iB,EAAA,GAEAgjB,EAAAhjB,EAAA,GAkCAif,GAAA9b,WACA0R,YAAAoK,EACAha,KAAA,cAQAgb,SAAA,EASAgD,WAAA,EAOAla,EAAA,EAOAqE,GAAA,EAQA8V,OAAA,EAQA3Y,WAAA,EAQA4Y,UAAA,EAQAC,QAAA,EAOAC,SAAA,EAOAva,OAAA,UAOAwa,WAAA,EAOAC,eACAC,YAAA,SAAAvF,KACAwF,WAAA,SAAAxF,KAOAsB,MAAA,SAAAtB,EAAAuB,KAOA7O,gBAAA,aASAgR,QAAA,SAAApY,EAAAC,GACA,MAAA1J,MAAA4jB,YAAAna,EAAAC,IAOAgE,SAAA,SAAAzF,EAAAC,GACAD,EAAA1H,KAAA2H,EAAAlI,OAUA4jB,YAAA,SAAAna,EAAAC,GACA,GAAAma,GAAA7jB,KAAA+hB,sBAAAtY,EAAAC,GACA8G,EAAAxQ,KAAA6Q,iBACA,OAAAL,GAAAqR,QAAAgC,EAAA,GAAAA,EAAA,KAOAvF,MAAA,WACAte,KAAAmgB,SAAA,EACAngB,KAAAohB,MAAA,KACAphB,KAAAkiB,MAAAliB,KAAAkiB,KAAAC,WAuBA2B,aAAA,SAAAxB,GACA,MAAAtiB,MAAAuiB,QAAA,QAAAD,IAEAE,OAAA,SAAAzW,EAAAiK,GACA,UAAAjK,EACAgX,EAAA1f,UAAAmf,OAAAjiB,KAAAP,KAAA+L,EAAAiK,GAEAhW,KAAAgH,MAAAvE,IAAAuT,IAQA3I,SAAA,SAAAtB,EAAAiK,GAGA,MAFAhW,MAAAgH,MAAAvE,IAAAsJ,EAAAiK,GACAhW,KAAAse,OAAA,GACAte,MAOA+jB,SAAA,SAAAtN,GAGA,MAFAzW,MAAAgH,MAAA,GAAAgc,GAAAvM,EAAAzW,MACAA,KAAAse,OAAA,GACAte,OAGA+C,EAAAmO,SAAAiO,EAAA4D,GACAhgB,EAAAqI,MAAA+T,EAAA+D,EAEA,IAAAJ,GAAA3D,CACAtf,GAAAD,QAAAkjB,GRykFM,SAAUjjB,EAAQD,GSzzFxB,QAAAokB,GAAA7F,EAAA1H,EAAAjG,GACA,GAAA/G,GAAA,MAAAgN,EAAAhN,EAAA,EAAAgN,EAAAhN,EACAa,EAAA,MAAAmM,EAAAnM,GAAA,EAAAmM,EAAAnM,GACAZ,EAAA,MAAA+M,EAAA/M,EAAA,EAAA+M,EAAA/M,EACAa,EAAA,MAAAkM,EAAAlM,GAAA,EAAAkM,EAAAlM,EAEAkM,GAAAwN,SACAxa,EAAAA,EAAA+G,EAAA3H,MAAA2H,EAAA/G,EACAa,EAAAA,EAAAkG,EAAA3H,MAAA2H,EAAA/G,EACAC,EAAAA,EAAA8G,EAAA1H,OAAA0H,EAAA9G,EACAa,EAAAA,EAAAiG,EAAA1H,OAAA0H,EAAA9G,EAGA,IAAAwa,GAAA/F,EAAA6F,qBAAAva,EAAAC,EAAAY,EAAAC,EACA,OAAA2Z,GAGA,QAAAC,GAAAhG,EAAA1H,EAAAjG,GACA,GAAA3H,GAAA2H,EAAA3H,MACAC,EAAA0H,EAAA1H,OACAsb,EAAArV,KAAAqV,IAAAvb,EAAAC,GACAW,EAAA,MAAAgN,EAAAhN,EAAA,GAAAgN,EAAAhN,EACAC,EAAA,MAAA+M,EAAA/M,EAAA,GAAA+M,EAAA/M,EACA2a,EAAA,MAAA5N,EAAA4N,EAAA,GAAA5N,EAAA4N,CAEA5N,GAAAwN,SACAxa,EAAAA,EAAAZ,EAAA2H,EAAA/G,EACAC,EAAAA,EAAAZ,EAAA0H,EAAA9G,EACA2a,GAAAD,EAGA,IAAAF,GAAA/F,EAAAgG,qBAAA1a,EAAAC,EAAA,EAAAD,EAAAC,EAAA2a,EACA,OAAAH,GAxCA,GAAAI,KAAA,aAAA,IAAA,gBAAA,IAAA,gBAAA,IAAA,cAAA,SAAA,UAAA,SAAA,WAAA,UAAA,aAAA,KAGAtB,EAAA,SAAAniB,EAAA0jB,GACAvkB,KAAA2iB,WAAA9hB,GAAA,GACAb,KAAAukB,KAAAA,EAsCAvB,GAAA3f,WACA0R,YAAAiO,EAKAuB,KAAA,KAKAxb,KAAA,OAKA6D,OAAA,KAKA9C,QAAA,EAKAU,SAAA,KAKAiW,eAAA,EAKA+D,WAAA,EAKAC,cAAA,EAKAC,cAAA,EAKAhT,UAAA,EAMAiQ,eAAA,EAOAzW,KAAA,KASAyZ,KAAA,KAOA5R,SAAA,KAMA6R,UAAA,KAMAC,WAAA,KAOAC,SAAA,KAMAC,WAAA,KAMAC,QAAA,KAKA9R,SAAA,OAKA+R,WAAA,KAKAC,UAAA,KAMAC,WAAA,KASAC,gBAAA,EAKAC,eAAA,KASApS,aAAA,SAMAqS,SAAA,KAMAC,WAAA,KAKAC,UAAA,KAKAC,kBAAA,KAKA3S,aAAA,EAKA4S,gBAAA,cAKAC,eAAA,EAKAC,kBAAA,EAKAC,kBAAA,EAKAC,mBAAA,cAKAC,kBAAA,EAKAC,qBAAA,EAKAC,qBAAA,EAOAC,eAAA,EAMAC,aAAA,EAUAC,WAAA,KAKAC,oBAAA,KAKAC,gBAAA,KAKAC,gBAAA,EAKAC,iBAAA,EAMAC,YAAA,KAMAC,KAAA,KAMAC,SAAA,KAMAC,MAAA,KAKA3f,KAAA,SAAAkX,EAAA1R,EAAAiT,GAKA,IAAA,GAJA1Y,GAAAhH,KACA6mB,EAAAnH,GAAAA,EAAA1Y,MACA8f,GAAAD,EAEA5gB,EAAA,EAAmBA,EAAAqe,EAAApe,OAA+BD,IAAA,CAClD,GAAAoQ,GAAAiO,EAAAre,GACA8gB,EAAA1Q,EAAA,IAEAyQ,GAAA9f,EAAA+f,KAAAF,EAAAE,MAEA5I,EAAA4I,GAAA/f,EAAA+f,IAAA1Q,EAAA,IAoBA,IAhBAyQ,GAAA9f,EAAA+B,OAAA8d,EAAA9d,QACAoV,EAAAoC,UAAAvZ,EAAA+B,OAGA+d,GAAA9f,EAAA4F,SAAAia,EAAAja,UACAuR,EAAAqC,YAAAxZ,EAAA4F,SAGAka,GAAA9f,EAAA8C,UAAA+c,EAAA/c,WACAqU,EAAA6I,YAAA,MAAAhgB,EAAA8C,QAAA,EAAA9C,EAAA8C,UAGAgd,GAAA9f,EAAA4f,QAAAC,EAAAD,SACAzI,EAAA8I,yBAAAjgB,EAAA4f,OAAA,eAGA5mB,KAAA2f,YAAA,CACA,GAAAjO,GAAA1K,EAAA0K,SACAyM,GAAAzM,UAAAA,GAAA1R,KAAA2hB,eAAAlV,GAAAA,EAAAmV,aAAAnV,EAAAmV,eAAA,KAGAhC,QAAA,WACA,GAAA7W,GAAA/I,KAAA+I,IACA,OAAA,OAAAA,GAAA,SAAAA,GAEA4W,UAAA,WACA,GAAA/S,GAAA5M,KAAA4M,MACA,OAAA,OAAAA,GAAA,SAAAA,GAAA5M,KAAA0R,UAAA,GAUAiR,WAAA,SAAAuE,EAAA9R,GACA,GAAA8R,EACA,IAAA,GAAAxf,KAAAwf,IACAA,EAAA/Z,eAAAzF,IAAA0N,KAAA,IAAAA,KAAA,EAAApV,KAAAmN,eAAAzF,GAAA,MAAAwf,EAAAxf,MACA1H,KAAA0H,GAAAwf,EAAAxf,KAWAjF,IAAA,SAAAgU,EAAAT,GACA,gBAAAS,GACAzW,KAAAyW,GAAAT,EAEAhW,KAAA2iB,WAAAlM,GAAA,IAQAxL,MAAA,WACA,GAAAkc,GAAA,GAAAnnB,MAAA+U,WAEA,OADAoS,GAAAxE,WAAA3iB,MAAA,GACAmnB,GAEA9G,YAAA,SAAAlC,EAAA1H,EAAAjG,GAKA,IAAA,GAJA4W,GAAA,WAAA3Q,EAAAtR,KAAAgf,EAAAH,EACAE,EAAAkD,EAAAjJ,EAAA1H,EAAAjG,GACAsP,EAAArJ,EAAAqJ,WAEA7Z,EAAA,EAAmBA,EAAA6Z,EAAA5Z,OAAuBD,IAC1Cie,EAAAmD,aAAAvH,EAAA7Z,GAAAqhB,OAAAxH,EAAA7Z,GAAAuM,MAGA,OAAA0R,IAKA,KAAA,GAFAqD,GAAAvE,EAAA3f,UAEA4C,EAAA,EAAeA,EAAAqe,EAAApe,OAA+BD,IAAA,CAC9C,GAAAoQ,GAAAiO,EAAAre,EAEAoQ,GAAA,IAAAkR,KACAA,EAAAlR,EAAA,IAAAA,EAAA,IAKA2M,EAAA3C,YAAAkH,EAAAlH,WACA,IAAAyC,GAAAE,CACAnjB,GAAAD,QAAAkjB,GTu0FM,SAAUjjB,EAAQD,EAASM,GUrwGjC,GAAAsnB,GAAAtnB,EAAA,IAEA4C,EAAA5C,EAAA,IAEAunB,EAAAvnB,EAAA,IAEAwnB,EAAAxnB,EAAA,IAEA6C,EAAA7C,EAAA,GASA6iB,EAAA,SAAAliB,GAEA4mB,EAAAlnB,KAAAP,KAAAa,GACAiC,EAAAvC,KAAAP,KAAAa,GACA6mB,EAAAnnB,KAAAP,KAAAa,GAMAb,KAAAK,GAAAQ,EAAAR,IAAAmnB,IAGAzE,GAAA1f,WAMA8B,KAAA,UAOAuC,KAAA,GAQAwa,KAAA,KASAyF,QAAA,EASAC,SAAA,KAOAC,MAAA,SAAAC,EAAAC,GACA,OAAA/nB,KAAAyK,WACA,IAAA,aACAsd,EAAA,CACA,MAEA,KAAA,WACAD,EAAA,EAIA,GAAAtnB,GAAAR,KAAA8T,SAEAtT,KACAA,EAAAR,KAAA8T,WAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAGAtT,EAAA,IAAAsnB,EACAtnB,EAAA,IAAAunB,EACA/nB,KAAAgoB,qBACAhoB,KAAAse,OAAA,IAMA2J,aAAA,aAKAC,YAAA,aAKAC,OAAA,WACAnoB,KAAAooB,mBAOA1a,SAAA,SAAAzF,EAAAC,KAKAsa,OAAA,SAAAzW,EAAAiK,GACA,GAAA,aAAAjK,GAAA,UAAAA,GAAA,WAAAA,GAEA,GAAAiK,EAAA,CACA,GAAA5R,GAAApE,KAAA+L,EAEA3H,KACAA,EAAApE,KAAA+L,OAGA3H,EAAA,GAAA4R,EAAA,GACA5R,EAAA,GAAA4R,EAAA,QAGAhW,MAAA+L,GAAAiK,GAOAqS,KAAA,WACAroB,KAAA2nB,QAAA,EACA3nB,KAAAkiB,MAAAliB,KAAAkiB,KAAAC,WAMAmG,KAAA,WACAtoB,KAAA2nB,QAAA,EACA3nB,KAAAkiB,MAAAliB,KAAAkiB,KAAAC,WAOAvT,KAAA,SAAA7C,EAAAiK,GACA,GAAA,gBAAAjK,GACA/L,KAAAwiB,OAAAzW,EAAAiK,OACK,IAAAjT,EAAAsS,SAAAtJ,GACL,IAAA,GAAArE,KAAAqE,GACAA,EAAAoB,eAAAzF,IACA1H,KAAAwiB,OAAA9a,EAAAqE,EAAArE,GAMA,OADA1H,MAAAse,OAAA,GACAte,MAMAuoB,YAAA,SAAAX,GACA,GAAAY,GAAAxoB,KAAAkiB,IAEAsG,IACAZ,EAAAa,YAAAD,GAIAxoB,KAAA4nB,UAAA5nB,KAAA4nB,WAAAA,GACA5nB,KAAA0oB,iBAGA1oB,KAAA4nB,SAAAA,EACAA,EAAA1F,KAAAsG,EACAZ,EAAAxF,aAAApiB,KACAA,KAAAse,OAAA,IAKAoK,eAAA,WACA,GAAAd,GAAA5nB,KAAA4nB,QAEAA,KACAA,EAAA1F,MACA0F,EAAAe,iBAAAf,EAAA1F,MAGA0F,EAAA1F,KAAA,KACA0F,EAAAxF,aAAA,KACApiB,KAAA4nB,SAAA,KACA5nB,KAAAse,OAAA,KASAmK,YAAA,SAAAD,GACAxoB,KAAAkiB,KAAAsG,CAEA,IAAAI,GAAA5oB,KAAA4oB,SAEA,IAAAA,EACA,IAAA,GAAA3iB,GAAA,EAAqBA,EAAA2iB,EAAA1iB,OAAsBD,IAC3CuiB,EAAAK,UAAAC,YAAAF,EAAA3iB,GAIAjG,MAAA4nB,UACA5nB,KAAA4nB,SAAAa,YAAAD,IASAG,iBAAA,SAAAH,GACAxoB,KAAAkiB,KAAA,IAEA,IAAA0G,GAAA5oB,KAAA4oB,SAEA,IAAAA,EACA,IAAA,GAAA3iB,GAAA,EAAqBA,EAAA2iB,EAAA1iB,OAAsBD,IAC3CuiB,EAAAK,UAAAE,eAAAH,EAAA3iB,GAIAjG,MAAA4nB,UACA5nB,KAAA4nB,SAAAe,iBAAAH,KAIAzlB,EAAAqI,MAAA2X,EAAA2E,GACA3kB,EAAAqI,MAAA2X,EAAA0E,GACA1kB,EAAAqI,MAAA2X,EAAAjgB,EACA,IAAAggB,GAAAC,CACAljB,GAAAD,QAAAkjB,GV2wGM,SAAUjjB,EAAQD,GW1gHxB,QAAAkjB,KACA,MAAAkG,KAHA,GAAAA,GAAA,IAMAnpB,GAAAD,QAAAkjB,GXuhHM,SAAUjjB,EAAQD,GY5hHxB,GAAAqpB,GAAA3O,MAAAjX,UAAAiV,MAOAxV,EAAA,WACA9C,KAAAkpB,cAGApmB,GAAAO,WACA0R,YAAAjS,EASAqmB,IAAA,SAAAjkB,EAAAkkB,EAAAlhB,GACA,GAAAmhB,GAAArpB,KAAAkpB,UAEA,KAAAE,IAAAlkB,EACA,MAAAlF,KAGAqpB,GAAAnkB,KACAmkB,EAAAnkB,MAGA,KAAA,GAAAe,GAAA,EAAmBA,EAAAojB,EAAAnkB,GAAAgB,OAAsBD,IACzC,GAAAojB,EAAAnkB,GAAAe,GAAAqjB,IAAAF,EACA,MAAAppB,KAUA,OANAqpB,GAAAnkB,GAAA4C,MACAwhB,EAAAF,EACAD,KAAA,EACAhL,IAAAjW,GAAAlI,OAGAA,MASA8E,GAAA,SAAAI,EAAAkkB,EAAAlhB,GACA,GAAAmhB,GAAArpB,KAAAkpB,UAEA,KAAAE,IAAAlkB,EACA,MAAAlF,KAGAqpB,GAAAnkB,KACAmkB,EAAAnkB,MAGA,KAAA,GAAAe,GAAA,EAAmBA,EAAAojB,EAAAnkB,GAAAgB,OAAsBD,IACzC,GAAAojB,EAAAnkB,GAAAe,GAAAqjB,IAAAF,EACA,MAAAppB,KAUA,OANAqpB,GAAAnkB,GAAA4C,MACAwhB,EAAAF,EACAD,KAAA,EACAhL,IAAAjW,GAAAlI,OAGAA,MAQAupB,SAAA,SAAArkB,GACA,GAAAmkB,GAAArpB,KAAAkpB,UACA,OAAAG,GAAAnkB,IAAAmkB,EAAAnkB,GAAAgB,QAQAgX,IAAA,SAAAhY,EAAAkkB,GACA,GAAAC,GAAArpB,KAAAkpB,UAEA,KAAAhkB,EAEA,MADAlF,MAAAkpB,cACAlpB,IAGA,IAAAopB,EAAA,CACA,GAAAC,EAAAnkB,GAAA,CAGA,IAAA,GAFAskB,MAEAvjB,EAAA,EAAAwjB,EAAAJ,EAAAnkB,GAAAgB,OAA6CD,EAAAwjB,EAAOxjB,IACpDojB,EAAAnkB,GAAAe,GAAA,GAAAmjB,GACAI,EAAA1hB,KAAAuhB,EAAAnkB,GAAAe,GAIAojB,GAAAnkB,GAAAskB,EAGAH,EAAAnkB,IAAA,IAAAmkB,EAAAnkB,GAAAgB,cACAmjB,GAAAnkB,cAGAmkB,GAAAnkB,EAGA,OAAAlF,OAQAoF,QAAA,SAAAD,GACA,GAAAnF,KAAAkpB,WAAA/jB,GAAA,CACA,GAAAkS,GAAAE,UACAmS,EAAArS,EAAAnR,MAEAwjB,GAAA,IACArS,EAAA4R,EAAA1oB,KAAA8W,EAAA,GAMA,KAAA,GAHAgS,GAAArpB,KAAAkpB,WAAA/jB,GACAyP,EAAAyU,EAAAnjB,OAEAD,EAAA,EAAqBA,EAAA2O,GAAS,CAE9B,OAAA8U,GACA,IAAA,GACAL,EAAApjB,GAAA,EAAA1F,KAAA8oB,EAAApjB,GAAA,IAEA,MAEA,KAAA,GACAojB,EAAApjB,GAAA,EAAA1F,KAAA8oB,EAAApjB,GAAA,IAAAoR,EAAA,GAEA,MAEA,KAAA,GACAgS,EAAApjB,GAAA,EAAA1F,KAAA8oB,EAAApjB,GAAA,IAAAoR,EAAA,GAAAA,EAAA,GAEA,MAEA,SAEAgS,EAAApjB,GAAA,EAAAuR,MAAA6R,EAAApjB,GAAA,IAAAoR,GAKAgS,EAAApjB,GAAA,KACAojB,EAAA7iB,OAAAP,EAAA,GAEA2O,KAEA3O,KAKA,MAAAjG,OAOA2pB,mBAAA,SAAAxkB,GACA,GAAAnF,KAAAkpB,WAAA/jB,GAAA,CACA,GAAAkS,GAAAE,UACAmS,EAAArS,EAAAnR,MAEAwjB,GAAA,IACArS,EAAA4R,EAAA1oB,KAAA8W,EAAA,EAAAA,EAAAnR,OAAA,GAOA,KAAA,GAJAiY,GAAA9G,EAAAA,EAAAnR,OAAA,GACAmjB,EAAArpB,KAAAkpB,WAAA/jB,GACAyP,EAAAyU,EAAAnjB,OAEAD,EAAA,EAAqBA,EAAA2O,GAAS,CAE9B,OAAA8U,GACA,IAAA,GACAL,EAAApjB,GAAA,EAAA1F,KAAA4d,EAEA,MAEA,KAAA,GACAkL,EAAApjB,GAAA,EAAA1F,KAAA4d,EAAA9G,EAAA,GAEA,MAEA,KAAA,GACAgS,EAAApjB,GAAA,EAAA1F,KAAA4d,EAAA9G,EAAA,GAAAA,EAAA,GAEA,MAEA,SAEAgS,EAAApjB,GAAA,EAAAuR,MAAA2G,EAAA9G,GAKAgS,EAAApjB,GAAA,KACAojB,EAAA7iB,OAAAP,EAAA,GAEA2O,KAEA3O,KAKA,MAAAjG,OAwFA,IAAA8iB,GAAAhgB,CACAjD,GAAAD,QAAAkjB,GZwiHM,SAAUjjB,EAAQD,EAASM,Gan2HjC,QAAA0pB,GAAAnR,GACA,MAAAA,GAAAoR,GAAApR,GAAAoR,EAbA,GAAA5a,GAAA/O,EAAA,IAEAgP,EAAAhP,EAAA,IAOA4pB,EAAA7a,EAAAyE,SACAmW,EAAA,KAWApC,EAAA,SAAA5mB,GACAA,EAAAA,MAEAA,EAAA0I,WAMAvJ,KAAAuJ,UAAA,EAAA,IAGA,MAAA1I,EAAAkpB,WAMA/pB,KAAA+pB,SAAA,GAGAlpB,EAAA2I,QAMAxJ,KAAAwJ,OAAA,EAAA,IASAxJ,KAAAgqB,OAAAhqB,KAAAgqB,QAAA,MAGAC,EAAAxC,EAAApkB,SACA4mB,GAAAnW,UAAA,KAMAmW,EAAAC,mBAAA,WACA,MAAAN,GAAA5pB,KAAA+pB,WAAAH,EAAA5pB,KAAAuJ,SAAA,KAAAqgB,EAAA5pB,KAAAuJ,SAAA,KAAAqgB,EAAA5pB,KAAAwJ,MAAA,GAAA,IAAAogB,EAAA5pB,KAAAwJ,MAAA,GAAA,IAGAygB,EAAA7B,gBAAA,WACA,GAAAhiB,GAAApG,KAAAoG,OACA+jB,EAAA/jB,GAAAA,EAAA0N,UACAoW,EAAAlqB,KAAAkqB,qBACA1pB,EAAAR,KAAA8T,SAEA,OAAAoW,IAAAC,GAKA3pB,EAAAA,GAAAyO,EAAAmb,SAEAF,EACAlqB,KAAA4T,kBAAApT,GAEAspB,EAAAtpB,GAIA2pB,IACAD,EACAjb,EAAA0E,IAAAnT,EAAA4F,EAAA0N,UAAAtT,GAEAyO,EAAAuS,KAAAhhB,EAAA4F,EAAA0N,YAKA9T,KAAA8T,UAAAtT,EACAR,KAAAqqB,aAAArqB,KAAAqqB,cAAApb,EAAAmb,aACAnb,GAAA8E,OAAA/T,KAAAqqB,aAAA7pB,SAxBAA,GAAAspB,EAAAtpB,KA2BAypB,EAAArW,kBAAA,SAAApT,GACA,MAAAinB,GAAA7T,kBAAA5T,KAAAQ,IAQAypB,EAAA/J,aAAA,SAAA/B,GACA,GAAA3d,GAAAR,KAAA8T,UACAwW,EAAAnM,EAAAmM,KAAA,CAEA9pB,GACA2d,EAAA+B,aAAAoK,EAAA9pB,EAAA,GAAA8pB,EAAA9pB,EAAA,GAAA8pB,EAAA9pB,EAAA,GAAA8pB,EAAA9pB,EAAA,GAAA8pB,EAAA9pB,EAAA,GAAA8pB,EAAA9pB,EAAA,IAEA2d,EAAA+B,aAAAoK,EAAA,EAAA,EAAAA,EAAA,EAAA,IAIAL,EAAAjJ,iBAAA,SAAA7C,GACA,GAAAmM,GAAAnM,EAAAmM,KAAA,CACAnM,GAAA+B,aAAAoK,EAAA,EAAA,EAAAA,EAAA,EAAA,GAGA,IAAAC,KAKAN,GAAAjC,mBAAA,WACA,GAAAhoB,KAAA8T,UAAA,CAIA,GAAA1N,GAAApG,KAAAoG,OACA5F,EAAAR,KAAA8T,SAEA1N,IAAAA,EAAA0N,YAEA7E,EAAA0E,IAAA4W,EAAAnkB,EAAAikB,aAAA7pB,GACAA,EAAA+pB,EAGA,IAAAC,GAAAhqB,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACAiqB,EAAAjqB,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACA+I,EAAAvJ,KAAAuJ,SACAC,EAAAxJ,KAAAwJ,KAEAogB,GAAAY,EAAA,KACAA,EAAAzb,KAAA+P,KAAA0L,IAGAZ,EAAAa,EAAA,KACAA,EAAA1b,KAAA+P,KAAA2L,IAGAjqB,EAAA,GAAA,IACAgqB,GAAAA,GAGAhqB,EAAA,GAAA,IACAiqB,GAAAA,GAGAlhB,EAAA,GAAA/I,EAAA,GACA+I,EAAA,GAAA/I,EAAA,GACAgJ,EAAA,GAAAghB,EACAhhB,EAAA,GAAAihB,EACAzqB,KAAA+pB,SAAAhb,KAAA2b,OAAAlqB,EAAA,GAAAiqB,EAAAjqB,EAAA,GAAAgqB,KAQAP,EAAArJ,eAAA,WACA,GAAApgB,GAAAR,KAAA8T,SAEA,KAAAtT,EACA,OAAA,EAAA,EAGA,IAAAgqB,GAAAzb,KAAA+P,KAAAte,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACAiqB,EAAA1b,KAAA+P,KAAAte,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAUA,OARAA,GAAA,GAAA,IACAgqB,GAAAA,GAGAhqB,EAAA,GAAA,IACAiqB,GAAAA,IAGAD,EAAAC,IAWAR,EAAAlI,sBAAA,SAAAtY,EAAAC,GACA,GAAAihB,IAAAlhB,EAAAC,GACA2gB,EAAArqB,KAAAqqB,YAMA,OAJAA,IACAnb,EAAAkC,eAAAuZ,EAAAA,EAAAN,GAGAM,GAWAV,EAAAW,uBAAA,SAAAnhB,EAAAC,GACA,GAAAihB,IAAAlhB,EAAAC,GACAoK,EAAA9T,KAAA8T,SAMA,OAJAA,IACA5E,EAAAkC,eAAAuZ,EAAAA,EAAA7W,GAGA6W,GAYAlD,EAAA7T,kBAAA,SAAAxP,EAAA5D,GACAA,EAAAA,MACAspB,EAAAtpB,EACA,IAAAwpB,GAAA5lB,EAAA4lB,OACAxgB,EAAApF,EAAAoF,QAAA,EAAA,GACAugB,EAAA3lB,EAAA2lB,UAAA,EACAxgB,EAAAnF,EAAAmF,WAAA,EAAA,EAsBA,OApBAygB,KAEAxpB,EAAA,IAAAwpB,EAAA,GACAxpB,EAAA,IAAAwpB,EAAA,IAGA/a,EAAAzF,MAAAhJ,EAAAA,EAAAgJ,GAEAugB,GACA9a,EAAA4b,OAAArqB,EAAAA,EAAAupB,GAGAC,IAEAxpB,EAAA,IAAAwpB,EAAA,GACAxpB,EAAA,IAAAwpB,EAAA,IAGAxpB,EAAA,IAAA+I,EAAA,GACA/I,EAAA,IAAA+I,EAAA,GACA/I,EAGA,IAAAsiB,GAAA2E,CACA5nB,GAAAD,QAAAkjB,Gbq3HM,SAAUjjB,EAAQD,GcroIxB,QAAAwqB,KACA,GAAAU,GAAA,GAAAC,GAAA,EAEA,OADArX,GAAAoX,GACAA,EAQA,QAAApX,GAAAoX,GAOA,MANAA,GAAA,GAAA,EACAA,EAAA,GAAA,EACAA,EAAA,GAAA,EACAA,EAAA,GAAA,EACAA,EAAA,GAAA,EACAA,EAAA,GAAA,EACAA,EASA,QAAAtJ,GAAAsJ,EAAAtqB,GAOA,MANAsqB,GAAA,GAAAtqB,EAAA,GACAsqB,EAAA,GAAAtqB,EAAA,GACAsqB,EAAA,GAAAtqB,EAAA,GACAsqB,EAAA,GAAAtqB,EAAA,GACAsqB,EAAA,GAAAtqB,EAAA,GACAsqB,EAAA,GAAAtqB,EAAA,GACAsqB,EAUA,QAAAnX,GAAAmX,EAAAE,EAAAC,GAIA,GAAAC,GAAAF,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GACAE,EAAAH,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GACAG,EAAAJ,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GACAI,EAAAL,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GACAK,EAAAN,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,GACAO,EAAAP,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,EAOA,OANAF,GAAA,GAAAI,EACAJ,EAAA,GAAAK,EACAL,EAAA,GAAAM,EACAN,EAAA,GAAAO,EACAP,EAAA,GAAAQ,EACAR,EAAA,GAAAS,EACAT,EAUA,QAAAU,GAAAV,EAAAW,EAAAzP,GAOA,MANA8O,GAAA,GAAAW,EAAA,GACAX,EAAA,GAAAW,EAAA,GACAX,EAAA,GAAAW,EAAA,GACAX,EAAA,GAAAW,EAAA,GACAX,EAAA,GAAAW,EAAA,GAAAzP,EAAA,GACA8O,EAAA,GAAAW,EAAA,GAAAzP,EAAA,GACA8O,EAUA,QAAAD,GAAAC,EAAAW,EAAAC,GACA,GAAAC,GAAAF,EAAA,GACAG,EAAAH,EAAA,GACAI,EAAAJ,EAAA,GACAK,EAAAL,EAAA,GACAM,EAAAN,EAAA,GACAO,EAAAP,EAAA,GACAQ,EAAAld,KAAAgQ,IAAA2M,GACAQ,EAAAnd,KAAAiQ,IAAA0M,EAOA,OANAZ,GAAA,GAAAa,EAAAO,EAAAJ,EAAAG;AACAnB,EAAA,IAAAa,EAAAM,EAAAH,EAAAI,EACApB,EAAA,GAAAc,EAAAM,EAAAH,EAAAE,EACAnB,EAAA,IAAAc,EAAAK,EAAAC,EAAAH,EACAjB,EAAA,GAAAoB,EAAAL,EAAAI,EAAAD,EACAlB,EAAA,GAAAoB,EAAAF,EAAAC,EAAAJ,EACAf,EAUA,QAAAthB,GAAAshB,EAAAW,EAAAzP,GACA,GAAAmQ,GAAAnQ,EAAA,GACAoQ,EAAApQ,EAAA,EAOA,OANA8O,GAAA,GAAAW,EAAA,GAAAU,EACArB,EAAA,GAAAW,EAAA,GAAAW,EACAtB,EAAA,GAAAW,EAAA,GAAAU,EACArB,EAAA,GAAAW,EAAA,GAAAW,EACAtB,EAAA,GAAAW,EAAA,GAAAU,EACArB,EAAA,GAAAW,EAAA,GAAAW,EACAtB,EASA,QAAA/W,GAAA+W,EAAAW,GACA,GAAAE,GAAAF,EAAA,GACAG,EAAAH,EAAA,GACAI,EAAAJ,EAAA,GACAK,EAAAL,EAAA,GACAM,EAAAN,EAAA,GACAO,EAAAP,EAAA,GACAY,EAAAV,EAAAI,EAAAD,EAAAF,CAEA,OAAAS,IAIAA,EAAA,EAAAA,EACAvB,EAAA,GAAAiB,EAAAM,EACAvB,EAAA,IAAAgB,EAAAO,EACAvB,EAAA,IAAAc,EAAAS,EACAvB,EAAA,GAAAa,EAAAU,EACAvB,EAAA,IAAAc,EAAAI,EAAAD,EAAAF,GAAAQ,EACAvB,EAAA,IAAAgB,EAAAD,EAAAF,EAAAK,GAAAK,EACAvB,GAVA,KAlJA,GAAAC,GAAA,mBAAAuB,cAAAhS,MAAAgS,YA+JA1sB,GAAAwqB,OAAAA,EACAxqB,EAAA8T,SAAAA,EACA9T,EAAA4hB,KAAAA,EACA5hB,EAAA+T,IAAAA,EACA/T,EAAA4rB,UAAAA,EACA5rB,EAAAirB,OAAAA,EACAjrB,EAAA4J,MAAAA,EACA5J,EAAAmU,OAAAA,GdqpIM,SAAUlU,EAAQD,GevzIxB,QAAAwqB,GAAA3gB,EAAAC,GACA,GAAAohB,GAAA,GAAAC,GAAA,EAYA,OAVA,OAAAthB,IACAA,EAAA,GAGA,MAAAC,IACAA,EAAA,GAGAohB,EAAA,GAAArhB,EACAqhB,EAAA,GAAAphB,EACAohB,EAUA,QAAAtJ,GAAAsJ,EAAA9O,GAGA,MAFA8O,GAAA,GAAA9O,EAAA,GACA8O,EAAA,GAAA9O,EAAA,GACA8O,EASA,QAAA7f,GAAA+Q,GACA,GAAA8O,GAAA,GAAAC,GAAA,EAGA,OAFAD,GAAA,GAAA9O,EAAA,GACA8O,EAAA,GAAA9O,EAAA,GACA8O,EAWA,QAAAroB,GAAAqoB,EAAAW,EAAAc,GAGA,MAFAzB,GAAA,GAAAW,EACAX,EAAA,GAAAyB,EACAzB,EAUA,QAAAlmB,GAAAkmB,EAAA0B,EAAA7B,GAGA,MAFAG,GAAA,GAAA0B,EAAA,GAAA7B,EAAA,GACAG,EAAA,GAAA0B,EAAA,GAAA7B,EAAA,GACAG,EAWA,QAAA2B,GAAA3B,EAAA0B,EAAA7B,EAAAc,GAGA,MAFAX,GAAA,GAAA0B,EAAA,GAAA7B,EAAA,GAAAc,EACAX,EAAA,GAAA0B,EAAA,GAAA7B,EAAA,GAAAc,EACAX,EAUA,QAAA4B,GAAA5B,EAAA0B,EAAA7B,GAGA,MAFAG,GAAA,GAAA0B,EAAA,GAAA7B,EAAA,GACAG,EAAA,GAAA0B,EAAA,GAAA7B,EAAA,GACAG,EASA,QAAAlW,GAAAoH,GACA,MAAAjN,MAAA+P,KAAA6N,EAAA3Q,IAWA,QAAA2Q,GAAA3Q,GACA,MAAAA,GAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAWA,QAAArI,GAAAmX,EAAA0B,EAAA7B,GAGA,MAFAG,GAAA,GAAA0B,EAAA,GAAA7B,EAAA,GACAG,EAAA,GAAA0B,EAAA,GAAA7B,EAAA,GACAG,EAUA,QAAA8B,GAAA9B,EAAA0B,EAAA7B,GAGA,MAFAG,GAAA,GAAA0B,EAAA,GAAA7B,EAAA,GACAG,EAAA,GAAA0B,EAAA,GAAA7B,EAAA,GACAG,EAUA,QAAA+B,GAAAL,EAAA7B,GACA,MAAA6B,GAAA,GAAA7B,EAAA,GAAA6B,EAAA,GAAA7B,EAAA,GAUA,QAAAnhB,GAAAshB,EAAA9O,EAAA8Q,GAGA,MAFAhC,GAAA,GAAA9O,EAAA,GAAA8Q,EACAhC,EAAA,GAAA9O,EAAA,GAAA8Q,EACAhC,EASA,QAAAiC,GAAAjC,EAAA9O,GACA,GAAAgR,GAAApY,EAAAoH,EAUA,OARA,KAAAgR,GACAlC,EAAA,GAAA,EACAA,EAAA,GAAA,IAEAA,EAAA,GAAA9O,EAAA,GAAAgR,EACAlC,EAAA,GAAA9O,EAAA,GAAAgR,GAGAlC,EAUA,QAAAmC,GAAAT,EAAA7B,GACA,MAAA5b,MAAA+P,MAAA0N,EAAA,GAAA7B,EAAA,KAAA6B,EAAA,GAAA7B,EAAA,KAAA6B,EAAA,GAAA7B,EAAA,KAAA6B,EAAA,GAAA7B,EAAA,KAWA,QAAAuC,GAAAV,EAAA7B,GACA,OAAA6B,EAAA,GAAA7B,EAAA,KAAA6B,EAAA,GAAA7B,EAAA,KAAA6B,EAAA,GAAA7B,EAAA,KAAA6B,EAAA,GAAA7B,EAAA,IAUA,QAAAwC,GAAArC,EAAA9O,GAGA,MAFA8O,GAAA,IAAA9O,EAAA,GACA8O,EAAA,IAAA9O,EAAA,GACA8O,EAWA,QAAAsC,GAAAtC,EAAA0B,EAAA7B,EAAA0C,GAGA,MAFAvC,GAAA,GAAA0B,EAAA,GAAAa,GAAA1C,EAAA,GAAA6B,EAAA,IACA1B,EAAA,GAAA0B,EAAA,GAAAa,GAAA1C,EAAA,GAAA6B,EAAA,IACA1B,EAUA,QAAA1Z,GAAA0Z,EAAA9O,EAAAxb,GACA,GAAAiJ,GAAAuS,EAAA,GACAtS,EAAAsS,EAAA,EAGA,OAFA8O,GAAA,GAAAtqB,EAAA,GAAAiJ,EAAAjJ,EAAA,GAAAkJ,EAAAlJ,EAAA,GACAsqB,EAAA,GAAAtqB,EAAA,GAAAiJ,EAAAjJ,EAAA,GAAAkJ,EAAAlJ,EAAA,GACAsqB,EAUA,QAAA1G,GAAA0G,EAAA0B,EAAA7B,GAGA,MAFAG,GAAA,GAAA/b,KAAAqV,IAAAoI,EAAA,GAAA7B,EAAA,IACAG,EAAA,GAAA/b,KAAAqV,IAAAoI,EAAA,GAAA7B,EAAA,IACAG,EAUA,QAAA9Y,GAAA8Y,EAAA0B,EAAA7B,GAGA,MAFAG,GAAA,GAAA/b,KAAAiD,IAAAwa,EAAA,GAAA7B,EAAA,IACAG,EAAA,GAAA/b,KAAAiD,IAAAwa,EAAA,GAAA7B,EAAA,IACAG,EA7RA,GAAAC,GAAA,mBAAAuB,cAAAhS,MAAAgS,aAkHApmB,EAAA0O,EAYA0Y,EAAAX,EAkFAY,EAAAN,EAYAO,EAAAN,CAoEAttB,GAAAwqB,OAAAA,EACAxqB,EAAA4hB,KAAAA,EACA5hB,EAAAqL,MAAAA,EACArL,EAAA6C,IAAAA,EACA7C,EAAAgF,IAAAA,EACAhF,EAAA6sB,YAAAA,EACA7sB,EAAA8sB,IAAAA,EACA9sB,EAAAgV,IAAAA,EACAhV,EAAAsG,OAAAA,EACAtG,EAAA+sB,UAAAA,EACA/sB,EAAA0tB,aAAAA,EACA1tB,EAAA+T,IAAAA,EACA/T,EAAAgtB,IAAAA,EACAhtB,EAAAitB,IAAAA,EACAjtB,EAAA4J,MAAAA,EACA5J,EAAAmtB,UAAAA,EACAntB,EAAAqtB,SAAAA,EACArtB,EAAA2tB,KAAAA,EACA3tB,EAAAstB,eAAAA,EACAttB,EAAA4tB,WAAAA,EACA5tB,EAAAutB,OAAAA,EACAvtB,EAAAwtB,KAAAA,EACAxtB,EAAAwR,eAAAA,EACAxR,EAAAwkB,IAAAA,EACAxkB,EAAAoS,IAAAA,Gfq0IM,SAAUnS,EAAQD,EAASM,GgB7nJjC,GAAAutB,GAAAvtB,EAAA,IAEAwtB,EAAAxtB,EAAA,IAEAytB,EAAAztB,EAAA,GAEAyX,EAAAgW,EAAAhW,SACAD,EAAAiW,EAAAjW,WACArC,EAAAsY,EAAAtY,SACAkB,EAAAoX,EAAApX,YACA5D,EAAAgb,EAAAhb,QAMA+U,EAAA,WAKA1nB,KAAA4oB,aAGAlB,GAAArkB,WACA0R,YAAA2S,EAcAnF,QAAA,SAAA7R,EAAA4R,GACA,GAAAle,GACAwpB,GAAA,EACAnhB,EAAAzM,KACAwoB,EAAAxoB,KAAAkiB,IAEA,IAAAxR,EAAA,CACA,GAAAmd,GAAAnd,EAAAiM,MAAA,KACAtG,EAAA5J,CAEAmhB,GAAA,UAAAC,EAAA,EAEA,KAAA,GAAA5nB,GAAA,EAAAwjB,EAAAoE,EAAA3nB,OAA8CD,EAAAwjB,EAAOxjB,IACrDoQ,IAIAA,EAAAA,EAAAwX,EAAA5nB,IAGAoQ,KACAjS,EAAAiS,OAGAjS,GAAAqI,CAGA,KAAArI,EAEA,WADAspB,GAAA,aAAAhd,EAAA,+BAAAjE,EAAApM,GAIA,IAAAuoB,GAAAnc,EAAAmc,UACAkF,EAAA,GAAAL,GAAArpB,EAAAke,EAaA,OAZAwL,GAAAC,OAAA,SAAA3pB,GACAqI,EAAA6R,MAAAsP,KACKI,KAAA,WAELpF,EAAApiB,OAAAmM,EAAAiW,EAAAkF,GAAA,KAEAlF,EAAA9gB,KAAAgmB,GAEAtF,GACAA,EAAAK,UAAAC,YAAAgF,GAGAA,GAOAG,cAAA,SAAAC,GAIA,IAAA,GAHAtF,GAAA5oB,KAAA4oB,UACAhU,EAAAgU,EAAA1iB,OAEAD,EAAA,EAAmBA,EAAA2O,EAAS3O,IAC5B2iB,EAAA3iB,GAAAkoB,KAAAD,EAIA,OADAtF,GAAA1iB,OAAA,EACAlG,MAiCA2O,UAAA,SAAAvK,EAAAgqB,EAAAC,EAAAC,EAAAC,EAAAC,GAkCA,QAAAR,KACAS,IAEAA,GACAF,GAAAA,IApCA5W,EAAA0W,IACAE,EAAAD,EACAA,EAAAD,EACAA,EAAA,GAEA3W,EAAA4W,IACAC,EAAAD,EACAA,EAAA,SACAD,EAAA,GAEA3W,EAAA2W,IACAE,EAAAF,EACAA,EAAA,GAEA3W,EAAA0W,IACAG,EAAAH,EACAA,EAAA,KAEAA,IACAA,EAAA,KAIApuB,KAAAiuB,gBAEAjuB,KAAA0uB,kBAAA,GAAA1uB,KAAAoE,EAAAgqB,EAAAC,EAIA,IAAAzF,GAAA5oB,KAAA4oB,UAAAtQ,QACAmW,EAAA7F,EAAA1iB,MAYAuoB,IACAF,GAAAA,GAKA,KAAA,GAAAtoB,GAAA,EAAmBA,EAAA2iB,EAAA1iB,OAAsBD,IACzC2iB,EAAA3iB,GAAA+nB,KAAAA,GAAAW,MAAAL,EAAAE,IA6BAE,kBAAA,SAAAhe,EAAA8D,EAAApQ,EAAAgqB,EAAAC,GACA,GAAAO,MACAC,EAAA,CAEA,KAAA,GAAAnnB,KAAAtD,GACA,GAAAA,EAAA+I,eAAAzF,GAIA,GAAA,MAAA8M,EAAA9M,GACA2N,EAAAjR,EAAAsD,MAAA6O,EAAAnS,EAAAsD,IACA1H,KAAA0uB,kBAAAhe,EAAAA,EAAA,IAAAhJ,EAAAA,EAAA8M,EAAA9M,GAAAtD,EAAAsD,GAAA0mB,EAAAC,IAEAO,EAAAlnB,GAAAtD,EAAAsD,GACAmnB,SAEO,IAAA,MAAAzqB,EAAAsD,GAGP,GAAAgJ,EAES,CAET,GAAArC,KACAA,GAAAqC,MACArC,EAAAqC,GAAAhJ,GAAAtD,EAAAsD,GACA1H,KAAA4O,KAAAP,OANArO,MAAA4O,KAAAlH,EAAAtD,EAAAsD,GAeA,OAJAmnB,GAAA,GACA7uB,KAAAuiB,QAAA7R,GAAA,GAAAoe,KAAA,MAAAV,EAAA,IAAAA,EAAAQ,GAAAP,MAAAA,GAAA,GAGAruB,MAGA,IAAA8iB,GAAA4E,CACA7nB,GAAAD,QAAAkjB,GhBmoJM,SAAUjjB,EAAQD,EAASM,GiBn3JjC,QAAA6uB,GAAA3qB,EAAA2H,GACA,MAAA3H,GAAA2H,GAGA,QAAAijB,GAAA5qB,EAAA2H,EAAAiK,GACA5R,EAAA2H,GAAAiK,EAUA,QAAAiZ,GAAAC,EAAAC,EAAAC,GACA,OAAAD,EAAAD,GAAAE,EAAAF,EAUA,QAAAG,GAAAH,EAAAC,EAAAC,GACA,MAAAA,GAAA,GAAAD,EAAAD,EAWA,QAAAI,GAAAJ,EAAAC,EAAAC,EAAAtE,EAAAyE,GACA,GAAA3a,GAAAsa,EAAAhpB,MAEA,IAAA,GAAAqpB,EACA,IAAA,GAAAtpB,GAAA,EAAmBA,EAAA2O,EAAS3O,IAC5B6kB,EAAA7kB,GAAAgpB,EAAAC,EAAAjpB,GAAAkpB,EAAAlpB,GAAAmpB,OAKA,KAAA,GAFAI,GAAA5a,GAAAsa,EAAA,GAAAhpB,OAEAD,EAAA,EAAmBA,EAAA2O,EAAS3O,IAC5B,IAAA,GAAA8B,GAAA,EAAqBA,EAAAynB,EAAUznB,IAC/B+iB,EAAA7kB,GAAA8B,GAAAknB,EAAAC,EAAAjpB,GAAA8B,GAAAonB,EAAAlpB,GAAA8B,GAAAqnB,GAQA,QAAAK,GAAAC,EAAAC,EAAAJ,GACA,GAAAK,GAAAF,EAAAxpB,OACA2pB,EAAAF,EAAAzpB,MAEA,IAAA0pB,IAAAC,EAAA,CAEA,GAAAC,GAAAF,EAAAC,CAEA,IAAAC,EAEAJ,EAAAxpB,OAAA2pB,MAGA,KAAA,GAAA5pB,GAAA2pB,EAA2B3pB,EAAA4pB,EAAa5pB,IACxCypB,EAAA5nB,KAAA,IAAAynB,EAAAI,EAAA1pB,GAAA8pB,EAAAxvB,KAAAovB,EAAA1pB,KAQA,IAAA,GAFAupB,GAAAE,EAAA,IAAAA,EAAA,GAAAxpB,OAEAD,EAAA,EAAiBA,EAAAypB,EAAAxpB,OAAiBD,IAClC,GAAA,IAAAspB,EACAlS,MAAAqS,EAAAzpB,MACAypB,EAAAzpB,GAAA0pB,EAAA1pB,QAGA,KAAA,GAAA8B,GAAA,EAAqBA,EAAAynB,EAAUznB,IAC/BsV,MAAAqS,EAAAzpB,GAAA8B,MACA2nB,EAAAzpB,GAAA8B,GAAA4nB,EAAA1pB,GAAA8B,IAcA,QAAAioB,GAAAN,EAAAC,EAAAJ,GACA,GAAAG,IAAAC,EACA,OAAA,CAGA,IAAA/a,GAAA8a,EAAAxpB,MAEA,IAAA0O,IAAA+a,EAAAzpB,OACA,OAAA,CAGA,IAAA,IAAAqpB,GACA,IAAA,GAAAtpB,GAAA,EAAmBA,EAAA2O,EAAS3O,IAC5B,GAAAypB,EAAAzpB,KAAA0pB,EAAA1pB,GACA,OAAA,MAMA,KAAA,GAFAupB,GAAAE,EAAA,GAAAxpB,OAEAD,EAAA,EAAmBA,EAAA2O,EAAS3O,IAC5B,IAAA,GAAA8B,GAAA,EAAqBA,EAAAynB,EAAUznB,IAC/B,GAAA2nB,EAAAzpB,GAAA8B,KAAA4nB,EAAA1pB,GAAA8B,GACA,OAAA,CAMA,QAAA,EAgBA,QAAAkoB,GAAAf,EAAAC,EAAAe,EAAAC,EAAA9C,EAAA+C,EAAAC,EAAAvF,EAAAyE,GACA,GAAA3a,GAAAsa,EAAAhpB,MAEA,IAAA,GAAAqpB,EACA,IAAA,GAAAtpB,GAAA,EAAmBA,EAAA2O,EAAS3O,IAC5B6kB,EAAA7kB,GAAAqqB,EAAApB,EAAAjpB,GAAAkpB,EAAAlpB,GAAAiqB,EAAAjqB,GAAAkqB,EAAAlqB,GAAAonB,EAAA+C,EAAAC,OAKA,KAAA,GAFAb,GAAAN,EAAA,GAAAhpB,OAEAD,EAAA,EAAmBA,EAAA2O,EAAS3O,IAC5B,IAAA,GAAA8B,GAAA,EAAqBA,EAAAynB,EAAUznB,IAC/B+iB,EAAA7kB,GAAA8B,GAAAuoB,EAAApB,EAAAjpB,GAAA8B,GAAAonB,EAAAlpB,GAAA8B,GAAAmoB,EAAAjqB,GAAA8B,GAAAooB,EAAAlqB,GAAA8B,GAAAslB,EAAA+C,EAAAC,GAkBA,QAAAC,GAAApB,EAAAC,EAAAe,EAAAC,EAAA9C,EAAA+C,EAAAC,GACA,GAAAE,GAAA,IAAAL,EAAAhB,GACA1C,EAAA,IAAA2D,EAAAhB,EACA,QAAA,GAAAA,EAAAe,GAAAK,EAAA/D,GAAA6D,OAAAlB,EAAAe,GAAA,EAAAK,EAAA/D,GAAA4D,EAAAG,EAAAlD,EAAA8B,EAGA,QAAAqB,GAAAxa,GACA,GAAAO,EAAAP,GAAA,CACA,GAAApB,GAAAoB,EAAA9P,MAEA,IAAAqQ,EAAAP,EAAA,IAAA,CAGA,IAAA,GAFAya,MAEAxqB,EAAA,EAAqBA,EAAA2O,EAAS3O,IAC9BwqB,EAAA3oB,KAAAioB,EAAAxvB,KAAAyV,EAAA/P,IAGA,OAAAwqB,GAGA,MAAAV,GAAAxvB,KAAAyV,GAGA,MAAAA,GAGA,QAAA0a,GAAAC,GAIA,MAHAA,GAAA,GAAA5hB,KAAA6hB,MAAAD,EAAA,IACAA,EAAA,GAAA5hB,KAAA6hB,MAAAD,EAAA,IACAA,EAAA,GAAA5hB,KAAA6hB,MAAAD,EAAA,IACA,QAAAA,EAAAE,KAAA,KAAA,IAGA,QAAAC,GAAAC,GACA,GAAAC,GAAAD,EAAAA,EAAA7qB,OAAA,GAAA8P,KACA,OAAAO,GAAAya,GAAAA,EAAA,IAAA,EAAA,EAGA,QAAAC,GAAAnD,EAAAQ,EAAA4C,EAAAH,EAAAI,EAAA3C,GACA,GAAA4C,GAAAtD,EAAAuD,QACAC,EAAAxD,EAAAyD,QACAC,EAAA,WAAAlD,EACAmD,EAAAV,EAAA7qB,MAEA,IAAAurB,EAAA,CAKA,GAMAC,GANAC,EAAAZ,EAAA,GAAA/a,MACA4b,EAAArb,EAAAob,GACAE,GAAA,EACAC,GAAA,EAEAvC,EAAAqC,EAAAd,EAAAC,GAAA,CAGAA,GAAAgB,KAAA,SAAAtG,EAAAc,GACA,MAAAd,GAAA2C,KAAA7B,EAAA6B,OAEAsD,EAAAX,EAAAU,EAAA,GAAArD,IAQA,KAAA,GANA4D,MAEAC,KACAC,EAAAnB,EAAA,GAAA/a,MACAmc,GAAA,EAEAlsB,EAAA,EAAiBA,EAAAwrB,EAAcxrB,IAAA,CAC/B+rB,EAAAlqB,KAAAipB,EAAA9qB,GAAAmoB,KAAAsD,EAEA,IAAA1b,GAAA+a,EAAA9qB,GAAA+P,KAQA,IANA4b,GAAA5B,EAAAha,EAAAkc,EAAA3C,KAAAqC,GAAA5b,IAAAkc,IACAC,GAAA,GAGAD,EAAAlc,EAEA,gBAAAA,GAAA,CACA,GAAAoc,GAAA5f,EAAA6f,MAAArc,EAEAoc,IACApc,EAAAoc,EACAP,GAAA,GAEAC,GAAA,EAIAG,EAAAnqB,KAAAkO,GAGA,GAAAwY,IAAA2D,EAAA,CAMA,IAAA,GAFAnB,GAAAiB,EAAAR,EAAA,GAEAxrB,EAAA,EAAiBA,EAAAwrB,EAAA,EAAkBxrB,IACnC2rB,EACAnC,EAAAwC,EAAAhsB,GAAA+qB,EAAAzB,IAEAlS,MAAA4U,EAAAhsB,KAAAoX,MAAA2T,IAAAc,GAAAD,IACAI,EAAAhsB,GAAA+qB,EAKAY,IAAAnC,EAAA2B,EAAAtD,EAAAwE,QAAAnB,GAAAH,EAAAzB,EAGA,IAEAZ,GACAlN,EACAyN,EACAC,EACAe,EACAC,EAPAoC,EAAA,EACAC,EAAA,CAQA,IAAAX,EACA,GAAAlB,IAAA,EAAA,EAAA,EAAA,EAGA,IAAA8B,GAAA,SAAAruB,EAAAgrB,GAIA,GAAAsD,EAEA,IAAAtD,EAAA,EACAsD,EAAA,MACK,IAAAtD,EAAAoD,EAAA,CAKL,IAFA7D,EAAA5f,KAAAqV,IAAAmO,EAAA,EAAAd,EAAA,GAEAiB,EAAA/D,EAAyB+D,GAAA,KACzBV,EAAAU,IAAAtD,GADqCsD,KAOrCA,EAAA3jB,KAAAqV,IAAAsO,EAAAjB,EAAA,OACK,CACL,IAAAiB,EAAAH,EAA6BG,EAAAjB,KAC7BO,EAAAU,GAAAtD,GAD+CsD,KAM/CA,EAAA3jB,KAAAqV,IAAAsO,EAAA,EAAAjB,EAAA,GAGAc,EAAAG,EACAF,EAAApD,CACA,IAAAuD,GAAAX,EAAAU,EAAA,GAAAV,EAAAU,EAEA,IAAA,IAAAC,EAMA,GAHAlR,GAAA2N,EAAA4C,EAAAU,IAAAC,EAGAnB,EAMA,GALArC,EAAA8C,EAAAS,GACAxD,EAAA+C,EAAA,IAAAS,EAAAA,EAAAA,EAAA,GACAxC,EAAA+B,EAAAS,EAAAjB,EAAA,EAAAA,EAAA,EAAAiB,EAAA,GACAvC,EAAA8B,EAAAS,EAAAjB,EAAA,EAAAA,EAAA,EAAAiB,EAAA,GAEAd,EACA3B,EAAAf,EAAAC,EAAAe,EAAAC,EAAA1O,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAAA2P,EAAAhtB,EAAA+sB,GAAA5B,OACO,CACP,GAAAvZ,EAEA,IAAA6b,EACA7b,EAAAia,EAAAf,EAAAC,EAAAe,EAAAC,EAAA1O,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAAAkP,EAAA,GACA3a,EAAA0a,EAAAC,OACS,CAAA,GAAAmB,EAET,MAAAzC,GAAAF,EAAAe,EAAAzO,EAEAzL,GAAAsa,EAAApB,EAAAC,EAAAe,EAAAC,EAAA1O,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,GAGA6P,EAAAltB,EAAA+sB,EAAAnb,OAGA,IAAA4b,EACAtC,EAAA2C,EAAAS,GAAAT,EAAAS,EAAA,GAAAjR,EAAA2P,EAAAhtB,EAAA+sB,GAAA5B,OACO,CACP,GAAAvZ,EAEA,IAAA6b,EACAvC,EAAA2C,EAAAS,GAAAT,EAAAS,EAAA,GAAAjR,EAAAkP,EAAA,GACA3a,EAAA0a,EAAAC,OACS,CAAA,GAAAmB,EAET,MAAAzC,GAAA4C,EAAAS,GAAAT,EAAAS,EAAA,GAAAjR,EAEAzL,GAAAiZ,EAAAgD,EAAAS,GAAAT,EAAAS,EAAA,GAAAjR,GAGA6P,EAAAltB,EAAA+sB,EAAAnb,KAKA4c,EAAA,GAAAC,IACAzuB,OAAA0pB,EAAAwE,QACAQ,KAAApB,EACApP,KAAAwL,EAAAiF,MACA1E,MAAAP,EAAAkF,OACAP,QAAAA,EACAQ,UAAA/B,GAOA,OAJA5C,IAAA,WAAAA,IACAsE,EAAAtE,OAAAA,GAGAsE,IA7ZA,GAAAC,GAAA3yB,EAAA,IAEAsS,EAAAtS,EAAA,IAEAytB,EAAAztB,EAAA,GAEAqW,EAAAoX,EAAApX,YAKAwZ,EAAAzV,MAAAjX,UAAAiV,MA8ZAmV,EAAA,SAAArpB,EAAAke,EAAA8O,EAAAE,GACAtxB,KAAAkzB,WACAlzB,KAAAsyB,QAAAluB,EACApE,KAAA+yB,MAAAzQ,IAAA,EACAtiB,KAAAqxB,QAAAD,GAAArC,EACA/uB,KAAAuxB,QAAAD,GAAAtC,EACAhvB,KAAAmzB,WAAA,EACAnzB,KAAAgzB,OAAA,EACAhzB,KAAAozB,aACApzB,KAAAqzB,gBACArzB,KAAAszB,aAGA7F,GAAApqB,WAOAyrB,KAAA,SAAAV,EAEA/f,GACA,GAAAklB,GAAAvzB,KAAAkzB,OAEA,KAAA,GAAA/B,KAAA9iB,GACA,GAAAA,EAAAlB,eAAAgkB,GAAA,CAIA,IAAAoC,EAAApC,GAAA,CACAoC,EAAApC,KAEA,IAAAnb,GAAAhW,KAAAqxB,QAAArxB,KAAAsyB,QAAAnB,EAEA,IAAA,MAAAnb,EAEA,QAOA,KAAAoY,GACAmF,EAAApC,GAAArpB,MACAsmB,KAAA,EACApY,MAAAwa,EAAAxa,KAKAud,EAAApC,GAAArpB,MACAsmB,KAAAA,EACApY,MAAA3H,EAAA8iB,KAIA,MAAAnxB,OAQA+tB,OAAA,SAAAQ,GAGA,MAFAvuB,MAAAqzB,aAAAvrB,KAAAymB,GAEAvuB,MAEAwzB,MAAA,WACA,IAAA,GAAAvtB,GAAA,EAAmBA,EAAAjG,KAAAszB,UAAAptB,OAA2BD,IAC9CjG,KAAAszB,UAAArtB,GAAAutB,OAGAxzB,MAAAyzB,SAAA,GAEAC,OAAA,WACA,IAAA,GAAAztB,GAAA,EAAmBA,EAAAjG,KAAAszB,UAAAptB,OAA2BD,IAC9CjG,KAAAszB,UAAArtB,GAAAytB,QAGA1zB,MAAAyzB,SAAA,GAEAE,SAAA,WACA,QAAA3zB,KAAAyzB,SAEAG,cAAA,WAEA5zB,KAAAkzB,WAEAlzB,KAAAszB,UAAAptB,OAAA,CAIA,KAAA,GAHA2tB,GAAA7zB,KAAAozB,UACAxe,EAAAif,EAAA3tB,OAEAD,EAAA,EAAmBA,EAAA2O,EAAS3O,IAC5B4tB,EAAA5tB,GAAA1F,KAAAP,OAWA2uB,MAAA,SAAAL,EAAAE,GACA,GAWAsF,GAXAC,EAAA/zB,KACAg0B,EAAA,EAEA9C,EAAA,WACA8C,IAEAA,GACAD,EAAAH,gBAMA,KAAA,GAAAzC,KAAAnxB,MAAAkzB,QACA,GAAAlzB,KAAAkzB,QAAA/lB,eAAAgkB,GAAA,CAIA,GAAAyB,GAAA3B,EAAAjxB,KAAAsuB,EAAA4C,EAAAlxB,KAAAkzB,QAAA/B,GAAAA,EAAA3C,EAEAoE,KACA5yB,KAAAszB,UAAAxrB,KAAA8qB,GAEAoB,IAEAh0B,KAAA6oB,WACA7oB,KAAA6oB,UAAAoL,QAAArB,GAGAkB,EAAAlB,GAKA,GAAAkB,EAAA,CACA,GAAAI,GAAAJ,EAAArB,OAEAqB,GAAArB,QAAA,SAAAruB,EAAAgrB,GACA8E,EAAA9vB,EAAAgrB,EAEA,KAAA,GAAAnpB,GAAA,EAAuBA,EAAA8tB,EAAAV,aAAAntB,OAA8BD,IACrD8tB,EAAAV,aAAAptB,GAAA7B,EAAAgrB,IAYA,MAJA4E,IACAh0B,KAAA4zB,gBAGA5zB,MAOAmuB,KAAA,SAAAD,GAIA,IAAA,GAHAiG,GAAAn0B,KAAAszB,UACAzK,EAAA7oB,KAAA6oB,UAEA5iB,EAAA,EAAmBA,EAAAkuB,EAAAjuB,OAAqBD,IAAA,CACxC,GAAA2sB,GAAAuB,EAAAluB,EAEAioB,IAEA0E,EAAAH,QAAAzyB,KAAAsyB,QAAA,GAGAzJ,GAAAA,EAAAuL,WAAAxB,GAGAuB,EAAAjuB,OAAA,GAQAmoB,MAAA,SAAAD,GAEA,MADApuB,MAAAgzB,OAAA5E,EACApuB,MAQAguB,KAAA,SAAA/lB,GAKA,MAJAA,IACAjI,KAAAozB,UAAAtrB,KAAAG,GAGAjI,MAMAq0B,SAAA,WACA,MAAAr0B,MAAAszB,WAGA,IAAAxQ,GAAA2K,CACA5tB,GAAAD,QAAAkjB,GjBs4JM,SAAUjjB,EAAQD,EAASM,GkBz/KjC,QAAA2yB,GAAAhwB,GACA7C,KAAAsyB,QAAAzvB,EAAAuB,OAEApE,KAAAs0B,MAAAzxB,EAAAiwB,MAAA,IAEA9yB,KAAAgzB,OAAAnwB,EAAAwrB,OAAA,EAGAruB,KAAAu0B,cAAA,EAEAv0B,KAAAsiB,KAAA,MAAAzf,EAAAyf,MAAAzf,EAAAyf,KACAtiB,KAAAw0B,IAAA3xB,EAAA2xB,KAAA,EACAx0B,KAAAsuB,OAAAzrB,EAAAyrB,QAAA,SACAtuB,KAAAyyB,QAAA5vB,EAAA4vB,QACAzyB,KAAAizB,UAAApwB,EAAAowB,UACAjzB,KAAAy0B,UAAA5xB,EAAA4xB,UACAz0B,KAAA00B,YAAA,EACA10B,KAAAyzB,SAAA,EAjCA,GAAAkB,GAAAz0B,EAAA,GAoCA2yB,GAAAxvB,WACA0R,YAAA8d,EACA+B,KAAA,SAAAC,EAAAC,GAQA,GALA90B,KAAAu0B,eACAv0B,KAAA+0B,WAAAF,EAAA70B,KAAAgzB,OACAhzB,KAAAu0B,cAAA,GAGAv0B,KAAAyzB,QAEA,YADAzzB,KAAA00B,aAAAI,EAIA,IAAA1F,IAAAyF,EAAA70B,KAAA+0B,WAAA/0B,KAAA00B,aAAA10B,KAAAs0B,KAEA,MAAAlF,EAAA,GAAA,CAIAA,EAAArgB,KAAAqV,IAAAgL,EAAA,EACA,IAAAd,GAAAtuB,KAAAsuB,OACA0G,EAAA,gBAAA1G,GAAAqG,EAAArG,GAAAA,EACA2G,EAAA,kBAAAD,GAAAA,EAAA5F,GAAAA,CAGA,OAFApvB,MAAAk1B,KAAA,QAAAD,GAEA,GAAA7F,EACApvB,KAAAsiB,MACAtiB,KAAAm1B,QAAAN,GAGA,YAKA70B,KAAAo1B,cAAA,EACA,WAGA,OAEAD,QAAA,SAAAN,GACA,GAAAQ,IAAAR,EAAA70B,KAAA+0B,WAAA/0B,KAAA00B,aAAA10B,KAAAs0B,KACAt0B,MAAA+0B,WAAAF,EAAAQ,EAAAr1B,KAAAw0B,IACAx0B,KAAA00B,YAAA,EACA10B,KAAAo1B,cAAA,GAEAF,KAAA,SAAAI,EAAAC,GACAD,EAAA,KAAAA,EAEAt1B,KAAAs1B,IACAt1B,KAAAs1B,GAAAt1B,KAAAsyB,QAAAiD,IAGA/B,MAAA,WACAxzB,KAAAyzB,SAAA,GAEAC,OAAA,WACA1zB,KAAAyzB,SAAA,GAGA,IAAA3Q,GAAA+P,CACAhzB,GAAAD,QAAAkjB,GlB+gLM,SAAUjjB,EAAQD,GmB9mLxB,GAAA0uB,IAKAkH,OAAA,SAAAC,GACA,MAAAA,IAOAC,YAAA,SAAAD,GACA,MAAAA,GAAAA,GAOAE,aAAA,SAAAF,GACA,MAAAA,IAAA,EAAAA,IAOAG,eAAA,SAAAH,GACA,OAAAA,GAAA,GAAA,EACA,GAAAA,EAAAA,SAGAA,GAAAA,EAAA,GAAA,IAQAI,QAAA,SAAAJ,GACA,MAAAA,GAAAA,EAAAA,GAOAK,SAAA,SAAAL,GACA,QAAAA,EAAAA,EAAAA,EAAA,GAOAM,WAAA,SAAAN,GACA,OAAAA,GAAA,GAAA,EACA,GAAAA,EAAAA,EAAAA,EAGA,KAAAA,GAAA,GAAAA,EAAAA,EAAA,IAQAO,UAAA,SAAAP,GACA,MAAAA,GAAAA,EAAAA,EAAAA,GAOAQ,WAAA,SAAAR,GACA,MAAA,MAAAA,EAAAA,EAAAA,EAAAA,GAOAS,aAAA,SAAAT,GACA,OAAAA,GAAA,GAAA,EACA,GAAAA,EAAAA,EAAAA,EAAAA,QAGAA,GAAA,GAAAA,EAAAA,EAAAA,EAAA,IAQAU,UAAA,SAAAV,GACA,MAAAA,GAAAA,EAAAA,EAAAA,EAAAA,GAOAW,WAAA,SAAAX,GACA,QAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAAA,GAOAY,aAAA,SAAAZ,GACA,OAAAA,GAAA,GAAA,EACA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAGA,KAAAA,GAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAA,IAQAa,aAAA,SAAAb,GACA,MAAA,GAAA1mB,KAAAiQ,IAAAyW,EAAA1mB,KAAAoM,GAAA,IAOAob,cAAA,SAAAd,GACA,MAAA1mB,MAAAgQ,IAAA0W,EAAA1mB,KAAAoM,GAAA,IAOAqb,gBAAA,SAAAf,GACA,MAAA,IAAA,EAAA1mB,KAAAiQ,IAAAjQ,KAAAoM,GAAAsa,KAQAgB,cAAA,SAAAhB,GACA,MAAA,KAAAA,EAAA,EAAA1mB,KAAA2nB,IAAA,KAAAjB,EAAA,IAOAkB,eAAA,SAAAlB,GACA,MAAA,KAAAA,EAAA,EAAA,EAAA1mB,KAAA2nB,IAAA,MAAAjB,IAOAmB,iBAAA,SAAAnB,GACA,MAAA,KAAAA,EACA,EAGA,IAAAA,EACA,GAGAA,GAAA,GAAA,EACA,GAAA1mB,KAAA2nB,IAAA,KAAAjB,EAAA,GAGA,KAAA1mB,KAAA2nB,IAAA,OAAAjB,EAAA,IAAA,IAQAoB,WAAA,SAAApB,GACA,MAAA,GAAA1mB,KAAA+P,KAAA,EAAA2W,EAAAA,IAOAqB,YAAA,SAAArB,GACA,MAAA1mB,MAAA+P,KAAA,KAAA2W,EAAAA,IAOAsB,cAAA,SAAAtB,GACA,OAAAA,GAAA,GAAA,OACA1mB,KAAA+P,KAAA,EAAA2W,EAAAA,GAAA,GAGA,IAAA1mB,KAAA+P,KAAA,GAAA2W,GAAA,GAAAA,GAAA,IAQAuB,UAAA,SAAAvB,GACA,GAAA3I,GACArB,EAAA,GACA/qB,EAAA,EAEA,OAAA,KAAA+0B,EACA,EAGA,IAAAA,EACA,IAGAhK,GAAAA,EAAA,GACAA,EAAA,EACAqB,EAAApsB,EAAA,GAEAosB,EAAApsB,EAAAqO,KAAAkoB,KAAA,EAAAxL,IAAA,EAAA1c,KAAAoM,MAGAsQ,EAAA1c,KAAA2nB,IAAA,EAAA,IAAAjB,GAAA,IAAA1mB,KAAAgQ,KAAA0W,EAAA3I,IAAA,EAAA/d,KAAAoM,IAAAza,MAOAw2B,WAAA,SAAAzB,GACA,GAAA3I,GACArB,EAAA,GACA/qB,EAAA,EAEA,OAAA,KAAA+0B,EACA,EAGA,IAAAA,EACA,IAGAhK,GAAAA,EAAA,GACAA,EAAA,EACAqB,EAAApsB,EAAA,GAEAosB,EAAApsB,EAAAqO,KAAAkoB,KAAA,EAAAxL,IAAA,EAAA1c,KAAAoM,IAGAsQ,EAAA1c,KAAA2nB,IAAA,MAAAjB,GAAA1mB,KAAAgQ,KAAA0W,EAAA3I,IAAA,EAAA/d,KAAAoM,IAAAza,GAAA,IAOAy2B,aAAA,SAAA1B,GACA,GAAA3I,GACArB,EAAA,GACA/qB,EAAA,EAEA,OAAA,KAAA+0B,EACA,EAGA,IAAAA,EACA,IAGAhK,GAAAA,EAAA,GACAA,EAAA,EACAqB,EAAApsB,EAAA,GAEAosB,EAAApsB,EAAAqO,KAAAkoB,KAAA,EAAAxL,IAAA,EAAA1c,KAAAoM,KAGAsa,GAAA,GAAA,OACAhK,EAAA1c,KAAA2nB,IAAA,EAAA,IAAAjB,GAAA,IAAA1mB,KAAAgQ,KAAA0W,EAAA3I,IAAA,EAAA/d,KAAAoM,IAAAza,IAGA+qB,EAAA1c,KAAA2nB,IAAA,OAAAjB,GAAA,IAAA1mB,KAAAgQ,KAAA0W,EAAA3I,IAAA,EAAA/d,KAAAoM,IAAAza,GAAA,GAAA,IAQA02B,OAAA,SAAA3B,GACA,GAAA3I,GAAA,OACA,OAAA2I,GAAAA,IAAA3I,EAAA,GAAA2I,EAAA3I,IAOAuK,QAAA,SAAA5B,GACA,GAAA3I,GAAA,OACA,SAAA2I,EAAAA,IAAA3I,EAAA,GAAA2I,EAAA3I,GAAA,GAOAwK,UAAA,SAAA7B,GACA,GAAA3I,GAAA,SAEA,QAAA2I,GAAA,GAAA,EACA,IAAAA,EAAAA,IAAA3I,EAAA,GAAA2I,EAAA3I,IAGA,KAAA2I,GAAA,GAAAA,IAAA3I,EAAA,GAAA2I,EAAA3I,GAAA,IAQAyK,SAAA,SAAA9B,GACA,MAAA,GAAAnH,EAAAkJ,UAAA,EAAA/B,IAOA+B,UAAA,SAAA/B,GACA,MAAAA,GAAA,EAAA,KACA,OAAAA,EAAAA,EACKA,EAAA,EAAA,KACL,QAAAA,GAAA,IAAA,MAAAA,EAAA,IACKA,EAAA,IAAA,KACL,QAAAA,GAAA,KAAA,MAAAA,EAAA,MAEA,QAAAA,GAAA,MAAA,MAAAA,EAAA,SAQAgC,YAAA,SAAAhC,GACA,MAAAA,GAAA,GACA,GAAAnH,EAAAiJ,SAAA,EAAA9B,GAGA,GAAAnH,EAAAkJ,UAAA,EAAA/B,EAAA,GAAA,KAGA3S,EAAAwL,CACAzuB,GAAAD,QAAAkjB,GnBynLM,SAAUjjB,EAAQD,EAASM,GoBz1LjC,QAAAw3B,GAAAzxB,GAIA,MAFAA,GAAA8I,KAAAD,MAAA7I,GAEAA,EAAA,EAAA,EAAAA,EAAA,IAAA,IAAAA,EAGA,QAAA0xB,GAAA1xB,GAIA,MAFAA,GAAA8I,KAAAD,MAAA7I,GAEAA,EAAA,EAAA,EAAAA,EAAA,IAAA,IAAAA,EAGA,QAAA2xB,GAAAlc,GAEA,MAAAA,GAAA,EAAA,EAAAA,EAAA,EAAA,EAAAA,EAGA,QAAAmc,GAAA7a,GAEA,MACA0a,GADA1a,EAAA9W,QAAA,MAAA8W,EAAAC,OAAAD,EAAA9W,OAAA,GACAkX,WAAAJ,GAAA,IAAA,IAGA/S,SAAA+S,EAAA,KAGA,QAAA8a,GAAA9a,GAEA,MACA4a,GADA5a,EAAA9W,QAAA,MAAA8W,EAAAC,OAAAD,EAAA9W,OAAA,GACAkX,WAAAJ,GAAA,IAGAI,WAAAJ,IAGA,QAAA+a,GAAA/M,EAAAC,EAAA3B,GAOA,MANAA,GAAA,EACAA,GAAA,EACGA,EAAA,IACHA,GAAA,GAGA,EAAAA,EAAA,EACA0B,GAAAC,EAAAD,GAAA1B,EAAA,EAGA,EAAAA,EAAA,EACA2B,EAGA,EAAA3B,EAAA,EACA0B,GAAAC,EAAAD,IAAA,EAAA,EAAA1B,GAAA,EAGA0B,EAGA,QAAAgN,GAAAvM,EAAAc,EAAA7rB,GACA,MAAA+qB,IAAAc,EAAAd,GAAA/qB,EAGA,QAAAu3B,GAAAnN,EAAAzG,EAAA6T,EAAA3L,EAAAd,GAKA,MAJAX,GAAA,GAAAzG,EACAyG,EAAA,GAAAoN,EACApN,EAAA,GAAAyB,EACAzB,EAAA,GAAAW,EACAX,EAGA,QAAAqN,GAAArN,EAAAW,GAKA,MAJAX,GAAA,GAAAW,EAAA,GACAX,EAAA,GAAAW,EAAA,GACAX,EAAA,GAAAW,EAAA,GACAX,EAAA,GAAAW,EAAA,GACAX,EAMA,QAAAsN,GAAAC,EAAAC,GAEAC,GACAJ,EAAAI,EAAAD,GAGAC,EAAAC,EAAAC,IAAAJ,EAAAE,GAAAD,EAAAhgB,SAUA,QAAA+Z,GAAAgG,EAAAC,GACA,GAAAD,EAAA,CAIAC,EAAAA,KACA,IAAAI,GAAAF,EAAA3yB,IAAAwyB,EAEA,IAAAK,EACA,MAAAP,GAAAG,EAAAI,EAIAL,IAAA,EAEA,IAAArb,GAAAqb,EAAA9b,QAAA,KAAA,IAAAoc,aAEA,IAAA3b,IAAA4b,GAGA,MAFAT,GAAAG,EAAAM,EAAA5b,IACAob,EAAAC,EAAAC,GACAA,CAIA,IAAA,MAAAtb,EAAAC,OAAA,GAAA,CA4BA,GAAA4b,GAAA7b,EAAArK,QAAA,KACAmmB,EAAA9b,EAAArK,QAAA,IAEA,IAAAkmB,QAAAC,EAAA,IAAA9b,EAAA9W,OAAA,CACA,GAAA6yB,GAAA/b,EAAAzU,OAAA,EAAAswB,GACA5zB,EAAA+X,EAAAzU,OAAAswB,EAAA,EAAAC,GAAAD,EAAA,IAAAlc,MAAA,KACAqc,EAAA,CAEA,QAAAD,GACA,IAAA,OACA,GAAA,IAAA9zB,EAAAiB,OAEA,WADA+xB,GAAAK,EAAA,EAAA,EAAA,EAAA,EAIAU,GAAAlB,EAAA7yB,EAAAg0B,MAIA,KAAA,MACA,MAAA,KAAAh0B,EAAAiB,WACA+xB,GAAAK,EAAA,EAAA,EAAA,EAAA,IAIAL,EAAAK,EAAAT,EAAA5yB,EAAA,IAAA4yB,EAAA5yB,EAAA,IAAA4yB,EAAA5yB,EAAA,IAAA+zB,GACAZ,EAAAC,EAAAC,GACAA,EAEA,KAAA,OACA,MAAA,KAAArzB,EAAAiB,WACA+xB,GAAAK,EAAA,EAAA,EAAA,EAAA,IAIArzB,EAAA,GAAA6yB,EAAA7yB,EAAA,IACAi0B,EAAAj0B,EAAAqzB,GACAF,EAAAC,EAAAC,GACAA,EAEA,KAAA,MACA,MAAA,KAAArzB,EAAAiB,WACA+xB,GAAAK,EAAA,EAAA,EAAA,EAAA,IAIAY,EAAAj0B,EAAAqzB,GACAF,EAAAC,EAAAC,GACAA,EAEA,SACA,QAIAL,EAAAK,EAAA,EAAA,EAAA,EAAA,OAnFA,CACA,GAAA,IAAAtb,EAAA9W,OAAA,CACA,GAAAizB,GAAAlvB,SAAA+S,EAAAzU,OAAA,GAAA,GAEA,OAAA4wB,IAAA,GAAAA,GAAA,MAKAlB,EAAAK,GAAA,KAAAa,IAAA,GAAA,KAAAA,IAAA,EAAA,IAAAA,GAAA,IAAAA,IAAA,EAAA,GAAAA,GAAA,GAAAA,IAAA,EAAA,GACAf,EAAAC,EAAAC,GACAA,OANAL,GAAAK,EAAA,EAAA,EAAA,EAAA,GAOK,GAAA,IAAAtb,EAAA9W,OAAA,CACL,GAAAizB,GAAAlvB,SAAA+S,EAAAzU,OAAA,GAAA,GAEA,OAAA4wB,IAAA,GAAAA,GAAA,UAKAlB,EAAAK,GAAA,SAAAa,IAAA,IAAA,MAAAA,IAAA,EAAA,IAAAA,EAAA,GACAf,EAAAC,EAAAC,GACAA,OANAL,GAAAK,EAAA,EAAA,EAAA,EAAA,MA6EA,QAAAY,GAAAE,EAAAzI,GACA,GAAArH,IAAAlM,WAAAgc,EAAA,IAAA,IAAA,KAAA,IAAA,IAIAtM,EAAAgL,EAAAsB,EAAA,IACA3P,EAAAqO,EAAAsB,EAAA,IACAnO,EAAAxB,GAAA,GAAAA,GAAAqD,EAAA,GAAArD,EAAAqD,EAAArD,EAAAqD,EACA9B,EAAA,EAAAvB,EAAAwB,CAQA,OAPA0F,GAAAA,MACAsH,EAAAtH,EAAA+G,EAAA,IAAAK,EAAA/M,EAAAC,EAAA3B,EAAA,EAAA,IAAAoO,EAAA,IAAAK,EAAA/M,EAAAC,EAAA3B,IAAAoO,EAAA,IAAAK,EAAA/M,EAAAC,EAAA3B,EAAA,EAAA,IAAA,GAEA,IAAA8P,EAAAlzB,SACAyqB,EAAA,GAAAyI,EAAA,IAGAzI,EAQA,QAAA0I,GAAA1I,GACA,GAAAA,EAAA,CAKA,GAUA2I,GACAC,EAXAC,EAAA7I,EAAA,GAAA,IACA8I,EAAA9I,EAAA,GAAA,IACA+I,EAAA/I,EAAA,GAAA,IACAgJ,EAAA5qB,KAAAqV,IAAAoV,EAAAC,EAAAC,GAEAE,EAAA7qB,KAAAiD,IAAAwnB,EAAAC,EAAAC,GAEAG,EAAAD,EAAAD,EAEAnc,GAAAoc,EAAAD,GAAA,CAIA,IAAA,IAAAE,EACAP,EAAA,EACAC,EAAA,MACG,CAEHA,EADA/b,EAAA,GACAqc,GAAAD,EAAAD,GAEAE,GAAA,EAAAD,EAAAD,EAGA,IAAAG,KAAAF,EAAAJ,GAAA,EAAAK,EAAA,GAAAA,EACAE,IAAAH,EAAAH,GAAA,EAAAI,EAAA,GAAAA,EACAG,IAAAJ,EAAAF,GAAA,EAAAG,EAAA,GAAAA,CAEAL,KAAAI,EACAN,EAAAU,EAAAD,EACKN,IAAAG,EACLN,EAAA,EAAA,EAAAQ,EAAAE,EACKN,IAAAE,IACLN,EAAA,EAAA,EAAAS,EAAAD,GAGAR,EAAA,IACAA,GAAA,GAGAA,EAAA,IACAA,GAAA,GAIA,GAAAF,IAAA,IAAAE,EAAAC,EAAA/b,EAMA,OAJA,OAAAmT,EAAA,IACAyI,EAAAtxB,KAAA6oB,EAAA,IAGAyI,GAUA,QAAArsB,GAAAyF,EAAAynB,GACA,GAAAC,GAAA7H,EAAA7f,EAEA,IAAA0nB,EAAA,CACA,IAAA,GAAAj0B,GAAA,EAAmBA,EAAA,EAAOA,IAC1Bg0B,EAAA,EACAC,EAAAj0B,GAAAi0B,EAAAj0B,IAAA,EAAAg0B,GAAA,EAEAC,EAAAj0B,IAAA,IAAAi0B,EAAAj0B,IAAAg0B,EAAAC,EAAAj0B,GAAA,CAIA,OAAAk0B,GAAAD,EAAA,IAAAA,EAAAh0B,OAAA,OAAA,QAUA,QAAAk0B,GAAA5nB,GACA,GAAA0nB,GAAA7H,EAAA7f,EAEA,IAAA0nB,EACA,QAAA,GAAA,KAAAA,EAAA,IAAA,KAAAA,EAAA,IAAA,KAAAA,EAAA,IAAA9f,SAAA,IAAA9B,MAAA,GAYA,QAAA+hB,GAAAC,EAAAC,EAAAzP,GACA,GAAAyP,GAAAA,EAAAr0B,QAAAo0B,GAAA,GAAAA,GAAA,EAAA,CAIAxP,EAAAA,KACA,IAAA9U,GAAAskB,GAAAC,EAAAr0B,OAAA,GACAs0B,EAAAzrB,KAAA6hB,MAAA5a,GACAykB,EAAA1rB,KAAA2rB,KAAA1kB,GACA2kB,EAAAJ,EAAAC,GACAI,EAAAL,EAAAE,GACAI,EAAA7kB,EAAAwkB,CAKA,OAJA1P,GAAA,GAAA4M,EAAAM,EAAA2C,EAAA,GAAAC,EAAA,GAAAC,IACA/P,EAAA,GAAA4M,EAAAM,EAAA2C,EAAA,GAAAC,EAAA,GAAAC,IACA/P,EAAA,GAAA4M,EAAAM,EAAA2C,EAAA,GAAAC,EAAA,GAAAC,IACA/P,EAAA,GAAA8M,EAAAI,EAAA2C,EAAA,GAAAC,EAAA,GAAAC,IACA/P,GAiBA,QAAAsC,GAAAkN,EAAAC,EAAAO,GACA,GAAAP,GAAAA,EAAAr0B,QAAAo0B,GAAA,GAAAA,GAAA,EAAA,CAIA,GAAAtkB,GAAAskB,GAAAC,EAAAr0B,OAAA,GACAs0B,EAAAzrB,KAAA6hB,MAAA5a,GACAykB,EAAA1rB,KAAA2rB,KAAA1kB,GACA2kB,EAAAtI,EAAAkI,EAAAC,IACAI,EAAAvI,EAAAkI,EAAAE,IACAI,EAAA7kB,EAAAwkB,EACAhoB,EAAA2nB,GAAAzC,EAAAM,EAAA2C,EAAA,GAAAC,EAAA,GAAAC,IAAAnD,EAAAM,EAAA2C,EAAA,GAAAC,EAAA,GAAAC,IAAAnD,EAAAM,EAAA2C,EAAA,GAAAC,EAAA,GAAAC,IAAAjD,EAAAI,EAAA2C,EAAA,GAAAC,EAAA,GAAAC,KAAA,OACA,OAAAC,IACAtoB,MAAAA,EACAgoB,UAAAA,EACAC,WAAAA,EACAzkB,MAAAA,GACGxD,GAiBH,QAAAuoB,GAAAvoB,EAAA8W,EAAAwD,EAAArD,GAGA,GAFAjX,EAAA6f,EAAA7f,GAOA,MAJAA,GAAA6mB,EAAA7mB,GACA,MAAA8W,IAAA9W,EAAA,GAAAmlB,EAAArO,IACA,MAAAwD,IAAAta,EAAA,GAAAslB,EAAAhL,IACA,MAAArD,IAAAjX,EAAA,GAAAslB,EAAArO,IACA0Q,EAAAjB,EAAA1mB,GAAA,QAWA,QAAAwoB,GAAAxoB,EAAAwmB,GAGA,GAFAxmB,EAAA6f,EAAA7f,GAEAA,GAAA,MAAAwmB,EAEA,MADAxmB,GAAA,GAAAolB,EAAAoB,GACAmB,EAAA3nB,EAAA,QAUA,QAAA2nB,GAAAc,EAAA91B,GACA,GAAA81B,GAAAA,EAAA/0B,OAAA,CAIA,GAAAmyB,GAAA4C,EAAA,GAAA,IAAAA,EAAA,GAAA,IAAAA,EAAA,EAMA,OAJA,SAAA91B,GAAA,SAAAA,GAAA,SAAAA,IACAkzB,GAAA,IAAA4C,EAAA,IAGA91B,EAAA,IAAAkzB,EAAA,KAhmBA,GAAA6C,GAAAh7B,EAAA,IAEA04B,GACAuC,aAAA,EAAA,EAAA,EAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,cAAA,IAAA,IAAA,IAAA,GACAC,MAAA,EAAA,IAAA,IAAA,GACAC,YAAA,IAAA,IAAA,IAAA,GACAC,OAAA,IAAA,IAAA,IAAA,GACAC,OAAA,IAAA,IAAA,IAAA,GACAC,QAAA,IAAA,IAAA,IAAA,GACAC,OAAA,EAAA,EAAA,EAAA,GACAC,gBAAA,IAAA,IAAA,IAAA,GACAC,MAAA,EAAA,EAAA,IAAA,GACAC,YAAA,IAAA,GAAA,IAAA,GACAC,OAAA,IAAA,GAAA,GAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,WAAA,GAAA,IAAA,IAAA,GACAC,YAAA,IAAA,IAAA,EAAA,GACAC,WAAA,IAAA,IAAA,GAAA,GACAC,OAAA,IAAA,IAAA,GAAA,GACAC,gBAAA,IAAA,IAAA,IAAA,GACAC,UAAA,IAAA,IAAA,IAAA,GACAC,SAAA,IAAA,GAAA,GAAA,GACAC,MAAA,EAAA,IAAA,IAAA,GACAC,UAAA,EAAA,EAAA,IAAA,GACAC,UAAA,EAAA,IAAA,IAAA,GACAC,eAAA,IAAA,IAAA,GAAA,GACAC,UAAA,IAAA,IAAA,IAAA,GACAC,WAAA,EAAA,IAAA,EAAA,GACAC,UAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,aAAA,IAAA,EAAA,IAAA,GACAC,gBAAA,GAAA,IAAA,GAAA,GACAC,YAAA,IAAA,IAAA,EAAA,GACAC,YAAA,IAAA,GAAA,IAAA,GACAC,SAAA,IAAA,EAAA,EAAA,GACAC,YAAA,IAAA,IAAA,IAAA,GACAC,cAAA,IAAA,IAAA,IAAA,GACAC,eAAA,GAAA,GAAA,IAAA,GACAC,eAAA,GAAA,GAAA,GAAA,GACAC,eAAA,GAAA,GAAA,GAAA,GACAC,eAAA,EAAA,IAAA,IAAA,GACAC,YAAA,IAAA,EAAA,IAAA,GACAC,UAAA,IAAA,GAAA,IAAA,GACAC,aAAA,EAAA,IAAA,IAAA,GACAC,SAAA,IAAA,IAAA,IAAA,GACAC,SAAA,IAAA,IAAA,IAAA,GACAC,YAAA,GAAA,IAAA,IAAA,GACAC,WAAA,IAAA,GAAA,GAAA,GACAC,aAAA,IAAA,IAAA,IAAA,GACAC,aAAA,GAAA,IAAA,GAAA,GACAC,SAAA,IAAA,EAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,YAAA,IAAA,IAAA,IAAA,GACAC,MAAA,IAAA,IAAA,EAAA,GACAC,WAAA,IAAA,IAAA,GAAA,GACAC,MAAA,IAAA,IAAA,IAAA,GACAC,OAAA,EAAA,IAAA,EAAA,GACAC,aAAA,IAAA,IAAA,GAAA,GACAC,MAAA,IAAA,IAAA,IAAA,GACAC,UAAA,IAAA,IAAA,IAAA,GACAC,SAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,GAAA,GAAA,GACAC,QAAA,GAAA,EAAA,IAAA,GACAC,OAAA,IAAA,IAAA,IAAA,GACAC,OAAA,IAAA,IAAA,IAAA,GACAC,UAAA,IAAA,IAAA,IAAA,GACAC,eAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,EAAA,GACAC,cAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,YAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,sBAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,YAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,aAAA,IAAA,IAAA,IAAA,GACAC,eAAA,GAAA,IAAA,IAAA,GACAC,cAAA,IAAA,IAAA,IAAA,GACAC,gBAAA,IAAA,IAAA,IAAA,GACAC,gBAAA,IAAA,IAAA,IAAA,GACAC,gBAAA,IAAA,IAAA,IAAA,GACAC,aAAA,IAAA,IAAA,IAAA,GACAC,MAAA,EAAA,IAAA,EAAA,GACAC,WAAA,GAAA,IAAA,GAAA,GACAC,OAAA,IAAA,IAAA,IAAA,GACAC,SAAA,IAAA,EAAA,IAAA,GACAC,QAAA,IAAA,EAAA,EAAA,GACAC,kBAAA,IAAA,IAAA,IAAA,GACAC,YAAA,EAAA,EAAA,IAAA,GACAC,cAAA,IAAA,GAAA,IAAA,GACAC,cAAA,IAAA,IAAA,IAAA,GACAC,gBAAA,GAAA,IAAA,IAAA,GACAC,iBAAA,IAAA,IAAA,IAAA,GACAC,mBAAA,EAAA,IAAA,IAAA,GACAC,iBAAA,GAAA,IAAA,IAAA,GACAC,iBAAA,IAAA,GAAA,IAAA,GACAC,cAAA,GAAA,GAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,UAAA,IAAA,IAAA,IAAA,GACAC,aAAA,IAAA,IAAA,IAAA,GACAC,MAAA,EAAA,EAAA,IAAA,GACAC,SAAA,IAAA,IAAA,IAAA,GACAC,OAAA,IAAA,IAAA,EAAA,GACAC,WAAA,IAAA,IAAA,GAAA,GACAC,QAAA,IAAA,IAAA,EAAA,GACAC,WAAA,IAAA,GAAA,EAAA,GACAC,QAAA,IAAA,IAAA,IAAA,GACAC,eAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,eAAA,IAAA,IAAA,IAAA,GACAC,eAAA,IAAA,IAAA,IAAA,GACAC,YAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,MAAA,IAAA,IAAA,GAAA,GACAC,MAAA,IAAA,IAAA,IAAA,GACAC,MAAA,IAAA,IAAA,IAAA,GACAC,YAAA,IAAA,IAAA,IAAA,GACAC,QAAA,IAAA,EAAA,IAAA,GACAC,KAAA,IAAA,EAAA,EAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,WAAA,GAAA,IAAA,IAAA,GACAC,aAAA,IAAA,GAAA,GAAA,GACAC,QAAA,IAAA,IAAA,IAAA,GACAC,YAAA,IAAA,IAAA,GAAA,GACAC,UAAA,GAAA,IAAA,GAAA,GACAC,UAAA,IAAA,IAAA,IAAA,GACAC,QAAA,IAAA,GAAA,GAAA,GACAC,QAAA,IAAA,IAAA,IAAA,GACAC,SAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,GAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GACAC,MAAA,IAAA,IAAA,IAAA,GACAC,aAAA,EAAA,IAAA,IAAA,GACAC,WAAA,GAAA,IAAA,IAAA,GACAC,KAAA,IAAA,IAAA,IAAA,GACAC,MAAA,EAAA,IAAA,IAAA,GACAC,SAAA,IAAA,IAAA,IAAA,GACAC,QAAA,IAAA,GAAA,GAAA,GACAC,WAAA,GAAA,IAAA,IAAA,GACAC,QAAA,IAAA,IAAA,IAAA,GACAC,OAAA,IAAA,IAAA,IAAA,GACAC,OAAA,IAAA,IAAA,IAAA,GACAC,YAAA,IAAA,IAAA,IAAA,GACAC,QAAA,IAAA,IAAA,EAAA,GACAC,aAAA,IAAA,IAAA,GAAA,IAkFA9L,EAAA,GAAA0C,GAAA,IACA3C,EAAA,KA8RAgM,EAAAlK,EAkCAmK,EAAApX,CA0DAxtB,GAAAyyB,MAAAA,EACAzyB,EAAAmN,KAAAA,EACAnN,EAAAw6B,MAAAA,EACAx6B,EAAAy6B,SAAAA,EACAz6B,EAAA2kC,eAAAA,EACA3kC,EAAAwtB,KAAAA,EACAxtB,EAAA4kC,WAAAA,EACA5kC,EAAAm7B,UAAAA,EACAn7B,EAAAo7B,YAAAA,EACAp7B,EAAAu6B,UAAAA,GpBw/LM,SAAUt6B,EAAQD,GqB7lNxB,GAAA6kC,GAAA,WAIAzkC,KAAA0kC,KAAA,KAKA1kC,KAAA2kC,KAAA,KACA3kC,KAAA4kC,KAAA,GAGAC,EAAAJ,EAAAphC,SAOAwhC,GAAAC,OAAA,SAAArsB,GACA,GAAAssB,GAAA,GAAAC,GAAAvsB,EAEA,OADAzY,MAAAilC,YAAAF,GACAA,GAQAF,EAAAI,YAAA,SAAAF,GACA/kC,KAAA0kC,MAGA1kC,KAAA2kC,KAAAO,KAAAH,EACAA,EAAAI,KAAAnlC,KAAA2kC,KACAI,EAAAG,KAAA,KACAllC,KAAA2kC,KAAAI,GALA/kC,KAAA0kC,KAAA1kC,KAAA2kC,KAAAI,EAQA/kC,KAAA4kC,QAQAC,EAAA3gC,OAAA,SAAA6gC,GACA,GAAAI,GAAAJ,EAAAI,KACAD,EAAAH,EAAAG,IAEAC,GACAA,EAAAD,KAAAA,EAGAllC,KAAA0kC,KAAAQ,EAGAA,EACAA,EAAAC,KAAAA,EAGAnlC,KAAA2kC,KAAAQ,EAGAJ,EAAAG,KAAAH,EAAAI,KAAA,KACAnlC,KAAA4kC,QAOAC,EAAAjwB,IAAA,WACA,MAAA5U,MAAA4kC,MAOAC,EAAAl/B,MAAA,WACA3F,KAAA0kC,KAAA1kC,KAAA2kC,KAAA,KACA3kC,KAAA4kC,KAAA,EAQA,IAAAI,GAAA,SAAAvsB,GAIAzY,KAAAgW,MAAAyC,EAKAzY,KAAAklC,KAKAllC,KAAAmlC,MASAjK,EAAA,SAAAkK,GACAplC,KAAAqlC,MAAA,GAAAZ,GACAzkC,KAAAslC,QACAtlC,KAAAulC,SAAAH,GAAA,GACAplC,KAAAwlC,kBAAA,MAGAC,EAAAvK,EAAA73B,SAOAoiC,GAAAhN,IAAA,SAAA1sB,EAAAiK,GACA,GAAA0vB,GAAA1lC,KAAAqlC,MACAzuB,EAAA5W,KAAAslC,KACAK,EAAA,IAEA,IAAA,MAAA/uB,EAAA7K,GAAA,CACA,GAAA6I,GAAA8wB,EAAA9wB,MAEAmwB,EAAA/kC,KAAAwlC,iBAEA,IAAA5wB,GAAA5U,KAAAulC,UAAA3wB,EAAA,EAAA,CAEA,GAAAgxB,GAAAF,EAAAhB,IACAgB,GAAAxhC,OAAA0hC,SACAhvB,GAAAgvB,EAAA75B,KACA45B,EAAAC,EAAA5vB,MACAhW,KAAAwlC,kBAAAI,EAGAb,EACAA,EAAA/uB,MAAAA,EAEA+uB,EAAA,GAAAC,GAAAhvB,GAGA+uB,EAAAh5B,IAAAA,EACA25B,EAAAT,YAAAF,GACAnuB,EAAA7K,GAAAg5B,EAGA,MAAAY,IAQAF,EAAA5/B,IAAA,SAAAkG,GACA,GAAAg5B,GAAA/kC,KAAAslC,KAAAv5B,GACA25B,EAAA1lC,KAAAqlC,KAEA,IAAA,MAAAN,EAOA,MALAA,KAAAW,EAAAf,OACAe,EAAAxhC,OAAA6gC,GACAW,EAAAT,YAAAF,IAGAA,EAAA/uB,OAQAyvB,EAAA9/B,MAAA,WACA3F,KAAAqlC,MAAA1/B,QAEA3F,KAAAslC,QAGA,IAAAxiB,GAAAoY,CACAr7B,GAAAD,QAAAkjB,GrB0mNM,SAAUjjB,EAAQD,EAASM,GsBnzNjC,GAAA2lC,GAAA3lC,EAAA,IAEA4lC,EAAAD,EAAAC,UAEApY,EAAA,YAEA,KAAAoY,EACApY,EAAA,WACA,IAAA,GAAA+H,KAAAle,WACA,KAAA,IAAA5L,OAAA4L,UAAAke,KAGCqQ,EAAA,IACDpY,EAAA,WACA,IAAA,GAAA+H,KAAAle,WACAwuB,QAAArY,IAAAnW,UAAAke,KAKA,IAAA3S,GAAA4K,CACA7tB,GAAAD,QAAAkjB,GtByzNM,SAAUjjB,EAAQD,GuB90NxB,GAAA0qB,GAAA,CAEA,oBAAA0b,UACA1b,EAAAvb,KAAAiD,IAAAg0B,OAAA9jC,kBAAA,EAAA,GAgBA,IAAA4jC,GAAA,EAEA5jC,EAAAooB,CACA1qB,GAAAkmC,UAAAA,EACAlmC,EAAAsC,iBAAAA,GvBo1NM,SAAUrC,EAAQD,EAASM,GwB32NjC,GAAA+lC,GAAA/lC,EAAA,IAEA8P,EAAA9P,EAAA,IAMAgmC,EAAA,GAAAl2B,GAEAkT,EAAA,YAEAA,GAAA7f,WACA0R,YAAAmO,EAOAjC,aAAA,SAAA9C,EAAA3N,GACA,GAAAxJ,GAAAhH,KAAAgH,KACAwJ,GAAAxJ,EAAAse,UAAA9U,EAEAxQ,KAAAmgB,SAAA8lB,EAAAE,mBAAAn/B,GAAA,EACA,IAAAkE,GAAAlE,EAAAkE,IAIA,IAFA,MAAAA,IAAAA,GAAA,IAEA+6B,EAAAG,aAAAl7B,EAAAlE,GAAA,CAKAmX,EAAAkoB,MAEA,IAAAvyB,GAAA9T,KAAA8T,SAEA9M,GAAAkf,cAOAlmB,KAAAkgB,aAAA/B,GANArK,IACAoyB,EAAA1kB,KAAAhR,GACA01B,EAAA90B,eAAA0C,GACAtD,EAAA01B,GAOAD,EAAAK,WAAAtmC,KAAAme,EAAAjT,EAAAlE,EAAAwJ,GACA2N,EAAAooB,YAGA,IAAAzjB,GAAAI,CACArjB,GAAAD,QAAAkjB,GxBi3NM,SAAUjjB,EAAQD,EAASM,GyBx4NjC,QAAAimC,GAAAn/B,GAGA,MAFAw/B,GAAAx/B,GACAuF,EAAAvF,EAAA0f,KAAA8f,GACAx/B,EAGA,QAAAw/B,GAAAx/B,GACA,GAAAA,EAAA,CACAA,EAAA2d,KAAArV,EAAAm3B,SAAAz/B,EACA,IAAAwe,GAAAxe,EAAAwe,SACA,YAAAA,IAAAA,EAAA,UACAxe,EAAAwe,UAAA,MAAAA,GAAAkhB,EAAAlhB,GAAAA,EAAA,MAEA,IAAAC,GAAAze,EAAAye,mBAAAze,EAAA2/B,YACA,YAAAlhB,IAAAA,EAAA,UACAze,EAAAye,kBAAA,MAAAA,GAAAmhB,EAAAnhB,GAAAA,EAAA,KACA,IAAAgB,GAAAzf,EAAAyf,WAEAA,KACAzf,EAAAyf,YAAAjO,EAAAxR,EAAAyf,eAaA,QAAA6f,GAAAO,EAAA1oB,EAAAjT,EAAAlE,EAAAwJ,GACAxJ,EAAA0f,KAAAogB,EAAAD,EAAA1oB,EAAAjT,EAAAlE,EAAAwJ,GAAAu2B,EAAAF,EAAA1oB,EAAAjT,EAAAlE,EAAAwJ,GAGA,QAAAu2B,GAAAF,EAAA1oB,EAAAjT,EAAAlE,EAAAwJ,GACA,GAAAmU,GAAAqiB,EAAA7oB,EAAA,OAAAnX,EAAA2d,MAAArV,EAAA23B,cACAxgB,EAAAzf,EAAAyf,YACAygB,EAAAL,EAAAM,iBAEAD,KAAAL,EAAA1mB,UACA+mB,EAAAL,EAAAM,kBAAA73B,EAAA83B,eAAAl8B,EAAAyZ,EAAA8B,EAAAzf,EAAA2f,UAGA,IAAA0gB,GAAAH,EAAAG,YACAC,EAAAJ,EAAAK,MACAC,EAAAN,EAAAM,WACAC,EAAAC,EAAAL,EAAArgC,EAAAwJ,GACAm3B,EAAAF,EAAAE,MACAC,EAAAH,EAAAG,MACApiB,EAAAiiB,EAAAjiB,UACAC,EAAAgiB,EAAAhiB,iBAEAoiB,GAAA1pB,EAAAnX,EAAAwJ,EAAAm3B,EAAAC,EACA,IAAAE,GAAAx4B,EAAAy4B,YAAAH,EAAAP,EAAA5hB,GACAuiB,EAAAL,EACAM,EAAAH,EACAI,EAAAC,EAAAnhC,EAEA,IAAAkhC,GAAAzhB,EAAA,CAEA,GAAAvB,GAAA5V,EAAA9L,SAAA0H,EAAAyZ,GACAyjB,EAAAljB,CACAuB,KAAA2hB,GAAA3hB,EAAA,GAAAA,EAAA,GACA,IAAA4hB,GAAA/4B,EAAAg5B,YAAAX,EAAAS,EAAA5iB,EACA0iB,IAAAK,EAAA1B,EAAA1oB,EAAAnX,EAAAqhC,EAAAP,EAAAM,EAAAf,GAEA5gB,IACAuhB,EAAAQ,EAAAb,EAAAniB,EAAAiB,GACAwhB,GAAAxhB,EAAA,IAIAugB,EAAA7oB,EAAA,YAAAqH,GAAA,QAGAwhB,EAAA7oB,EAAA,eAAA,UAEA6oB,EAAA7oB,EAAA,aAAAnX,EAAA2e,gBAAA,GACAqhB,EAAA7oB,EAAA,cAAAnX,EAAA0e,iBAAA,eACAshB,EAAA7oB,EAAA,gBAAAnX,EAAA4e,mBAAA,GACAohB,EAAA7oB,EAAA,gBAAAnX,EAAA6e,mBAAA,GAEAoiB,GAAAT,EAAA,CACA,IAAApiB,GAAApe,EAAAoe,gBACAH,EAAAwjB,EAAAzhC,EAAAie,WAAAG,GACAlS,EAAAw1B,EAAA1hC,EAAAkM,SAEA+R,KACA+hB,EAAA7oB,EAAA,YAAAiH,GACA4hB,EAAA7oB,EAAA,cAAA8G,IAGA/R,GACA8zB,EAAA7oB,EAAA,YAAAjL,EAGA,KAAA,GAAAjN,GAAA,EAAiBA,EAAAqhC,EAAAphC,OAAsBD,IAEvCgf,GAAA9G,EAAAwqB,WAAArB,EAAArhC,GAAA+hC,EAAAC,GACA/0B,GAAAiL,EAAAyqB,SAAAtB,EAAArhC,GAAA+hC,EAAAC,GACAA,GAAAT,EAIA,QAAAV,GAAAD,EAAA1oB,EAAAjT,EAAAlE,EAAAwJ,GACA,GAAA02B,GAAAL,EAAAM,iBAEAD,KAAAL,EAAA1mB,UACA+mB,EAAAL,EAAAM,kBAAA73B,EAAAu5B,cAAA39B,EAAAlE,IAGA8hC,EAAAjC,EAAA1oB,EAAA+oB,EAAAlgC,EAAAwJ,GAGA,QAAAs4B,GAAAjC,EAAA1oB,EAAA+oB,EAAAlgC,EAAAwJ,GACA,GAAAu4B,GAAA7B,EAAAr+B,MACAu/B,EAAAlB,EAAAkB,WACAf,EAAAH,EAAAG,YACA5gB,EAAAzf,EAAAyf,YACAghB,EAAAC,EAAAL,EAAArgC,EAAAwJ,GACAm3B,EAAAF,EAAAE,MACAC,EAAAH,EAAAG,MACApiB,EAAAiiB,EAAAjiB,UACAC,EAAAgiB,EAAAhiB,iBAEAoiB,GAAA1pB,EAAAnX,EAAAwJ,EAAAm3B,EAAAC,EACA,IAAAS,GAAA/4B,EAAAg5B,YAAAX,EAAAS,EAAA5iB,GACAsiB,EAAAx4B,EAAAy4B,YAAAH,EAAAP,EAAA5hB,GACAujB,EAAAX,EACAY,EAAAnB,CAEArhB,KACAuiB,GAAAviB,EAAA,GACAwiB,GAAAxiB,EAAA,GAGA,IAAAyiB,GAAAF,EAAAD,CACAZ,GAAAnhC,IAAAuhC,EAAA1B,EAAA1oB,EAAAnX,EAAAqhC,EAAAP,EAAAM,EAAAf,EAEA,KAAA,GAAAphC,GAAA,EAAiBA,EAAAihC,EAAAK,MAAArhC,OAA+BD,IAAA,CAYhD,IAXA,GASAkjC,GATAC,EAAAlC,EAAAK,MAAAthC,GACAojC,EAAAD,EAAAC,OACAC,EAAAD,EAAAnjC,OACAshC,EAAA4B,EAAA5B,WACA+B,EAAAH,EAAAvgC,MACA2xB,EAAA,EACAgP,EAAAR,EACAS,EAAAP,EACAzO,EAAA6O,EAAA,EAGA9O,EAAA8O,IAAAH,EAAAE,EAAA7O,IAAA2O,EAAA3jB,WAAA,SAAA2jB,EAAA3jB,YACAkkB,EAAA7C,EAAA1oB,EAAAgrB,EAAAniC,EAAAwgC,EAAAyB,EAAAO,EAAA,QACAD,GAAAJ,EAAAtgC,MACA2gC,GAAAL,EAAAtgC,MACA2xB,GAGA,MAAAC,GAAA,IAAA0O,EAAAE,EAAA5O,GAAA,UAAA0O,EAAA3jB,YACAkkB,EAAA7C,EAAA1oB,EAAAgrB,EAAAniC,EAAAwgC,EAAAyB,EAAAQ,EAAA,SACAF,GAAAJ,EAAAtgC,MACA4gC,GAAAN,EAAAtgC,MACA4xB,GAMA,KAFA+O,IAAAT,GAAAS,EAAAR,IAAAE,EAAAO,GAAAF,GAAA,EAEA/O,GAAAC,GACA0O,EAAAE,EAAA7O,GAEAkP,EAAA7C,EAAA1oB,EAAAgrB,EAAAniC,EAAAwgC,EAAAyB,EAAAO,EAAAL,EAAAtgC,MAAA,EAAA,UACA2gC,GAAAL,EAAAtgC,MACA2xB,GAGAyO,IAAAzB,GAIA,QAAAK,GAAA1pB,EAAAnX,EAAAwJ,EAAA/G,EAAAC,GAEA,GAAA8G,GAAAxJ,EAAAmf,aAAA,CACA,GAAA6D,GAAAhjB,EAAAof,UAEA,YAAA4D,GACAvgB,EAAA+G,EAAA3H,MAAA,EAAA2H,EAAA/G,EACAC,EAAA8G,EAAA1H,OAAA,EAAA0H,EAAA9G,GACKsgB,IACLvgB,EAAAugB,EAAA,GAAAxZ,EAAA/G,EACAC,EAAAsgB,EAAA,GAAAxZ,EAAA9G,GAGAyU,EAAAqN,UAAA/hB,EAAAC,GAEAyU,EAAA0M,QAAA7jB,EAAAmf,cACAhI,EAAAqN,WAAA/hB,GAAAC,IAIA,QAAAggC,GAAA7C,EAAA1oB,EAAAgrB,EAAAniC,EAAAwgC,EAAAyB,EAAAx/B,EAAA+b,GACA,GAAAmkB,GAAA3iC,EAAA0f,KAAAyiB,EAAApiB,eAGAtB,EAAA0jB,EAAA1jB,kBACA/b,EAAAu/B,EAAAzB,EAAA,CAEA,SAAA/hB,EACA/b,EAAAu/B,EAAAE,EAAArgC,OAAA,EACG,WAAA2c,IACH/b,EAAAu/B,EAAAzB,EAAA2B,EAAArgC,OAAA,IAGAqgC,EAAAS,cAAAzB,EAAAwB,IAAApB,EAAA1B,EAAA1oB,EAAAwrB,EAAA,UAAAnkB,EAAA/b,EAAA0/B,EAAAtgC,MAAA,WAAA2c,EAAA/b,EAAA0/B,EAAAtgC,MAAA,EAAAY,EAAAC,EAAAy/B,EAAArgC,OAAA,EAAAqgC,EAAAtgC,MAAAsgC,EAAArgC,OACA,IAAA2d,GAAA0iB,EAAA1iB,WAEAA,KACAhd,EAAA++B,EAAA/+B,EAAA+b,EAAAiB,GACA/c,GAAAy/B,EAAArgC,OAAA,EAAA2d,EAAA,GAAA0iB,EAAAhkB,WAAA,GAGA6hB,EAAA7oB,EAAA,aAAA/F,EAAAuxB,EAAAhkB,eAAA3e,EAAA2e,eAAA,IACAqhB,EAAA7oB,EAAA,cAAAwrB,EAAAjkB,iBAAA1e,EAAA0e,iBAAA,eACAshB,EAAA7oB,EAAA,gBAAA/F,EAAAuxB,EAAA/jB,kBAAA5e,EAAA4e,kBAAA,IACAohB,EAAA7oB,EAAA,gBAAA/F,EAAAuxB,EAAA9jB,kBAAA7e,EAAA6e,kBAAA,IACAmhB,EAAA7oB,EAAA,YAAAqH,GAGAwhB,EAAA7oB,EAAA,eAAA,UACA6oB,EAAA7oB,EAAA,OAAAgrB,EAAAxkB,MAAArV,EAAA23B,aACA,IAAAhiB,GAAAwjB,EAAAkB,EAAA1kB,YAAAje,EAAAie,WAAAG,GACAlS,EAAAw1B,EAAAiB,EAAAz2B,UAAAlM,EAAAkM,UACAkS,EAAAnN,EAAA0xB,EAAAvkB,gBAAApe,EAAAoe,gBAEAH,KACA+hB,EAAA7oB,EAAA,YAAAiH,GACA4hB,EAAA7oB,EAAA,cAAA8G,GACA9G,EAAAwqB,WAAAQ,EAAAj+B,KAAAzB,EAAAC,IAGAwJ,IACA8zB,EAAA7oB,EAAA,YAAAjL,GACAiL,EAAAyqB,SAAAO,EAAAj+B,KAAAzB,EAAAC,IAIA,QAAAy+B,GAAAnhC,GACA,MAAAA,GAAAqf,qBAAArf,EAAAuf,iBAAAvf,EAAAsf,gBAKA,QAAAiiB,GAAA1B,EAAA1oB,EAAAnX,EAAAyC,EAAAC,EAAAb,EAAAC,GACA,GAAAud,GAAArf,EAAAqf,oBACAE,EAAAvf,EAAAuf,gBACAD,EAAAtf,EAAAsf,gBACAujB,EAAAlyB,EAAA0O,EAMA,IALA2gB,EAAA7oB,EAAA,aAAAnX,EAAA+e,mBAAA,GACAihB,EAAA7oB,EAAA,cAAAnX,EAAA8e,oBAAA,eACAkhB,EAAA7oB,EAAA,gBAAAnX,EAAAgf,sBAAA,GACAghB,EAAA7oB,EAAA,gBAAAnX,EAAAif,sBAAA,GAEA4jB,GAAAtjB,GAAAD,EAAA,CACAnI,EAAA2C,WACA,IAAA0F,GAAAxf,EAAAwf,gBAEAA,GAGAsjB,EAAA7rB,UAAAE,GACA1U,EAAAA,EACAC,EAAAA,EACAb,MAAAA,EACAC,OAAAA,EACAub,EAAAmC,IAPArI,EAAA3N,KAAA/G,EAAAC,EAAAb,EAAAC,GAWAqV,EAAA4rB,YAGA,GAAAF,EACA7C,EAAA7oB,EAAA,YAAAkI,GACAlI,EAAApV,WACG,IAAAsM,EAAAgR,GAAA,CACH,GAAA1c,GAAA0c,EAAA1c,KACAA,GAAAqgC,EAAAC,oBAAAtgC,EAAA,KAAAk9B,EAAAqD,EAAA7jB,GAEA1c,GAAAqgC,EAAAG,aAAAxgC,IACAwU,EAAAisB,UAAAzgC,EAAAF,EAAAC,EAAAb,EAAAC,GAIAyd,GAAAD,IACA0gB,EAAA7oB,EAAA,YAAAoI,GACAygB,EAAA7oB,EAAA,cAAAmI,GACAnI,EAAAvR,UAIA,QAAAs9B,GAAAvgC,EAAA0c,GAGAA,EAAA1c,MAAAA,EAGA,QAAA+9B,GAAA2C,EAAArjC,EAAAwJ,GACA,GAAAm3B,GAAA3gC,EAAAyC,GAAA,EACAm+B,EAAA5gC,EAAA0C,GAAA,EACA8b,EAAAxe,EAAAwe,UACAC,EAAAze,EAAAye,iBAEA,IAAAjV,EAAA,CACA,GAAAyC,GAAAjM,EAAAiM,YAEA,IAAAA,YAAAqH,OAEAqtB,EAAAn3B,EAAA/G,EAAA6gC,EAAAr3B,EAAA,GAAAzC,EAAA3H,OACA++B,EAAAp3B,EAAA9G,EAAA4gC,EAAAr3B,EAAA,GAAAzC,EAAA1H,YACK,CACL,GAAAyhC,GAAAj7B,EAAAk7B,yBAAAv3B,EAAAzC,EAAAxJ,EAAA8L,aACA60B,GAAA4C,EAAA9gC,EACAm+B,EAAA2C,EAAA7gC,EAEA8b,EAAAA,GAAA+kB,EAAA/kB,UACAC,EAAAA,GAAA8kB,EAAA9kB,kBAKA,GAAAF,GAAAve,EAAAue,UAEAA,KACAoiB,GAAApiB,EAAA,GACAqiB,GAAAriB,EAAA,IAIA,OACAoiB,MAAAA,EACAC,MAAAA,EACApiB,UAAAA,EACAC,kBAAAA,GAIA,QAAAuhB,GAAA7oB,EAAA9H,EAAAL,GAMA,MAFAmI,GAAA9H,GAAAL,EAEAmI,EAAA9H,GASA,QAAAoyB,GAAA77B,EAAA8E,GACA,MAAA,OAAA9E,GAAA8E,GAAA,GAAA,gBAAA9E,GAAA,SAAAA,EAAA,KACAA,EAAAjD,OAAAiD,EAAAkT,WAAA,OAAAlT,EAGA,QAAA87B,GAAA3/B,GACA,MAAA,OAAAA,GAAA,SAAAA,EAAA,KACAA,EAAAY,OAAAZ,EAAA+W,WAAA,OAAA/W,EAGA,QAAAuhC,GAAAt0B,EAAAy0B,GACA,MAAA,gBAAAz0B,GACAA,EAAA00B,YAAA,MAAA,EACAttB,WAAApH,GAAA,IAAAy0B,EAGArtB,WAAApH,GAGAA,EAGA,QAAAwyB,GAAA/+B,EAAA+b,EAAAiB,GACA,MAAA,UAAAjB,EAAA/b,EAAAgd,EAAA,GAAA,WAAAjB,EAAA/b,EAAAgd,EAAA,GAAA,EAAAA,EAAA,GAAA,EAAAhd,EAAAgd,EAAA,GASA,QAAA2f,GAAAl7B,EAAAlE,GACA,MAAA,OAAAkE,IAAAA,GAAAlE,EAAAqf,qBAAArf,EAAAuf,iBAAAvf,EAAAsf,iBAAAtf,EAAAyf,aA3aA,GAAAkH,GAAAztB,EAAA,GAEA+X,EAAA0V,EAAA1V,UACAG,EAAAuV,EAAAvV,UACA7L,EAAAohB,EAAAphB,KACAiM,EAAAmV,EAAAnV,kBACAb,EAAAgW,EAAAhW,SACAtC,EAAAsY,EAAAtY,SAEA/F,EAAApP,EAAA,IAEA4pC,EAAA5pC,EAAA,IAEA8pC,EAAA9pC,EAAA,IAGAwmC,GACAiE,KAAA,EACAC,MAAA,EACAC,OAAA,GAEAjE,GACAkE,IAAA,EACAC,OAAA,EACAC,OAAA,EAsZAprC,GAAAumC,mBAAAA,EACAvmC,EAAA0mC,WAAAA,EACA1mC,EAAA6oC,UAAAA,EACA7oC,EAAA8oC,QAAAA,EACA9oC,EAAAwmC,aAAAA,GzB66NM,SAAUvmC,EAAQD,EAASM,G0B70OjC,QAAAmU,GAAA3M,EAAA4M,GACAC,EAAA7M,GAAA4M,EAUA,QAAA9Q,GAAA0H,EAAAyZ,GACAA,EAAAA,GAAAsiB,CACA,IAAAl7B,GAAAb,EAAA,IAAAyZ,CAEA,IAAAsmB,EAAAl/B,GACA,MAAAk/B,GAAAl/B,EAMA,KAAA,GAHAu7B,IAAAp8B,EAAA,IAAAyR,MAAA,MACA9T,EAAA,EAEA5C,EAAA,EAAAwjB,EAAA6d,EAAAphC,OAAuCD,EAAAwjB,EAAOxjB,IAE9C4C,EAAAkG,KAAAiD,IAAAk5B,EAAA5D,EAAArhC,GAAA0e,GAAA9b,MAAAA,EAUA,OAPAsiC,GAAAC,IACAD,EAAA,EACAF,MAGAE,IACAF,EAAAl/B,GAAAlD,EACAA,EAeA,QAAAgI,GAAA3F,EAAAyZ,EAAAa,EAAAC,EAAAgB,EAAAC,EAAAC,GACA,MAAAD,GAAA2kB,EAAAngC,EAAAyZ,EAAAa,EAAAC,EAAAgB,EAAAC,EAAAC,GAAA2kB,EAAApgC,EAAAyZ,EAAAa,EAAAC,EAAAgB,EAAAE,GAGA,QAAA2kB,GAAApgC,EAAAyZ,EAAAa,EAAAC,EAAAgB,EAAAE,GACA,GAAAugB,GAAAE,EAAAl8B,EAAAyZ,EAAA8B,EAAAE,GACAyhB,EAAA5kC,EAAA0H,EAAAyZ,EAEA8B,KACA2hB,GAAA3hB,EAAA,GAAAA,EAAA,GAGA,IAAA4gB,GAAAH,EAAAG,YACA59B,EAAA6+B,EAAA,EAAAF,EAAA5iB,GACA9b,EAAAq+B,EAAA,EAAAV,EAAA5hB,GACAjV,EAAA,GAAAR,GAAAvG,EAAAC,EAAA0+B,EAAAf,EAEA,OADA72B,GAAAg3B,WAAAN,EAAAM,WACAh3B,EAGA,QAAA66B,GAAAngC,EAAAyZ,EAAAa,EAAAC,EAAAgB,EAAAC,EAAAC,GACA,GAAAugB,GAAA2B,EAAA39B,GACAwb,KAAAA,EACAC,SAAAA,EACAhC,KAAAA,EACAa,UAAAA,EACAiB,YAAAA,IAEA2hB,EAAAlB,EAAAkB,WACAf,EAAAH,EAAAG,YACA59B,EAAA6+B,EAAA,EAAAF,EAAA5iB,GACA9b,EAAAq+B,EAAA,EAAAV,EAAA5hB,EACA,OAAA,IAAAzV,GAAAvG,EAAAC,EAAA0+B,EAAAf,GAWA,QAAAiB,GAAA7+B,EAAAZ,EAAA2c,GAQA,MANA,UAAAA,EACA/b,GAAAZ,EACG,WAAA2c,IACH/b,GAAAZ,EAAA,GAGAY,EAWA,QAAAs+B,GAAAr+B,EAAAZ,EAAA2c,GAOA,MANA,WAAAA,EACA/b,GAAAZ,EAAA,EACG,WAAA2c,IACH/b,GAAAZ,GAGAY,EAWA,QAAA8gC,GAAAv3B,EAAAzC,EAAAyc,GACA,GAAAxjB,GAAA+G,EAAA/G,EACAC,EAAA8G,EAAA9G,EACAZ,EAAA0H,EAAA1H,OACAD,EAAA2H,EAAA3H,MACA0iC,EAAAziC,EAAA,EACA0c,EAAA,OACAC,EAAA,KAEA,QAAAxS,GACA,IAAA,OACAxJ,GAAAwjB,EACAvjB,GAAA6hC,EACA/lB,EAAA,QACAC,EAAA,QACA,MAEA,KAAA,QACAhc,GAAAwjB,EAAApkB,EACAa,GAAA6hC,EACA9lB,EAAA,QACA,MAEA,KAAA,MACAhc,GAAAZ,EAAA,EACAa,GAAAujB,EACAzH,EAAA,SACAC,EAAA,QACA,MAEA,KAAA,SACAhc,GAAAZ,EAAA,EACAa,GAAAZ,EAAAmkB,EACAzH,EAAA,QACA,MAEA,KAAA,SACA/b,GAAAZ,EAAA,EACAa,GAAA6hC,EACA/lB,EAAA,SACAC,EAAA,QACA,MAEA,KAAA,aACAhc,GAAAwjB,EACAvjB,GAAA6hC,EACA9lB,EAAA,QACA,MAEA,KAAA,cACAhc,GAAAZ,EAAAokB,EACAvjB,GAAA6hC,EACA/lB,EAAA,QACAC,EAAA,QACA,MAEA,KAAA,YACAhc,GAAAZ,EAAA,EACAa,GAAAujB,EACAzH,EAAA,QACA,MAEA,KAAA,eACA/b,GAAAZ,EAAA,EACAa,GAAAZ,EAAAmkB,EACAzH,EAAA,SACAC,EAAA,QACA,MAEA,KAAA,gBACAhc,GAAAwjB,EACAvjB,GAAAujB,CACA,MAEA,KAAA,iBACAxjB,GAAAZ,EAAAokB,EACAvjB,GAAAujB,EACAzH,EAAA,OACA,MAEA,KAAA,mBACA/b,GAAAwjB,EACAvjB,GAAAZ,EAAAmkB,EACAxH,EAAA,QACA,MAEA,KAAA,oBACAhc,GAAAZ,EAAAokB,EACAvjB,GAAAZ,EAAAmkB,EACAzH,EAAA,QACAC,EAAA,SAIA,OACAhc,EAAAA,EACAC,EAAAA,EACA8b,UAAAA,EACAC,kBAAAA,GAqBA,QAAA+lB,GAAAtgC,EAAAugC,EAAA9mB,EAAA+mB,EAAA7oC,GACA,IAAA4oC,EACA,MAAA,EAGA,IAAAnE,IAAAp8B,EAAA,IAAAyR,MAAA,KACA9Z,GAAA8oC,EAAAF,EAAA9mB,EAAA+mB,EAAA7oC,EAGA,KAAA,GAAAoD,GAAA,EAAA2O,EAAA0yB,EAAAphC,OAAyCD,EAAA2O,EAAS3O,IAClDqhC,EAAArhC,GAAA2lC,EAAAtE,EAAArhC,GAAApD,EAGA,OAAAykC,GAAAzW,KAAA,MAGA,QAAA8a,GAAAF,EAAA9mB,EAAA+mB,EAAA7oC,GACAA,EAAAsN,KAAqBtN,GACrBA,EAAA8hB,KAAAA,CACA,IAAA+mB,GAAAzzB,EAAAyzB,EAAA,MACA7oC,GAAAgpC,cAAA5zB,EAAApV,EAAAgpC,cAAA,EACA,IAAAC,GAAAjpC,EAAAipC,QAAA7zB,EAAApV,EAAAipC,QAAA,EAGAjpC,GAAAkpC,YAAAvoC,EAAA,IAAAmhB,EAGA,IAAAqnB,GAAAnpC,EAAAmpC,aAAAxoC,EAAA,IAAAmhB,EACA9hB,GAAAopC,YAAAh0B,EAAApV,EAAAopC,YAAA,GAKA,KAAA,GAFAlD,GAAA0C,EAAA18B,KAAAiD,IAAA,EAAAy5B,EAAA,GAEAxlC,EAAA,EAAiBA,EAAA6lC,GAAA/C,GAAAiD,EAA6C/lC,IAC9D8iC,GAAAiD,CAGA,IAAAE,GAAA1oC,EAAAkoC,EAYA,OAVAQ,GAAAnD,IACA2C,EAAA,GACAQ,EAAA,GAGAnD,EAAA0C,EAAAS,EACArpC,EAAA6oC,SAAAA,EACA7oC,EAAAqpC,cAAAA,EACArpC,EAAAkmC,aAAAA,EACAlmC,EAAA4oC,eAAAA,EACA5oC,EAGA,QAAA+oC,GAAAO,EAAAtpC,GACA,GAAA4oC,GAAA5oC,EAAA4oC,eACA9mB,EAAA9hB,EAAA8hB,KACAokB,EAAAlmC,EAAAkmC,YAEA,KAAA0C,EACA,MAAA,EAGA,IAAA/5B,GAAAlO,EAAA2oC,EAAAxnB,EAEA,IAAAjT,GAAA+5B,EACA,MAAAU,EAGA,KAAA,GAAApkC,GAAA,GAAkBA,IAAA,CAClB,GAAA2J,GAAAq3B,GAAAhhC,GAAAlF,EAAAgpC,cAAA,CACAM,GAAAtpC,EAAA6oC,QACA,OAGA,GAAAU,GAAA,IAAArkC,EAAAskC,EAAAF,EAAApD,EAAAlmC,EAAAmpC,aAAAnpC,EAAAkpC,aAAAr6B,EAAA,EAAA3C,KAAA6hB,MAAAub,EAAAjmC,OAAA6iC,EAAAr3B,GAAA,CACAy6B,GAAAA,EAAA5jC,OAAA,EAAA6jC,GACA16B,EAAAlO,EAAA2oC,EAAAxnB,GAOA,MAJA,KAAAwnB,IACAA,EAAAtpC,EAAAopC,aAGAE,EAGA,QAAAE,GAAAnhC,EAAA69B,EAAAiD,EAAAD,GAIA,IAAA,GAHAljC,GAAA,EACA5C,EAAA,EAEA2O,EAAA1J,EAAAhF,OAA6BD,EAAA2O,GAAA/L,EAAAkgC,EAAiC9iC,IAAA,CAC9D,GAAAqmC,GAAAphC,EAAAqhC,WAAAtmC,EACA4C,IAAA,GAAAyjC,GAAAA,GAAA,IAAAN,EAAAD,EAGA,MAAA9lC,GASA,QAAAumC,GAAA7nB,GAEA,MAAAnhB,GAAA,IAAAmhB,GAUA,QAAAumB,GAAAhgC,EAAAyZ,GACA,MAAApQ,GAAA22B,YAAAhgC,EAAAyZ,GAmBA,QAAAyiB,GAAAl8B,EAAAyZ,EAAA8nB,EAAA9lB,GACA,MAAAzb,IAAAA,GAAA,GACA,IAAAs8B,GAAAgF,EAAA7nB,GACA4iB,EAAAr8B,EAAAA,EAAAyR,MAAA,SACA7T,EAAAy+B,EAAArhC,OAAAshC,EACAH,EAAAv+B,CAMA,IAJA2jC,IACApF,GAAAoF,EAAA,GAAAA,EAAA,IAGAvhC,GAAAyb,EAAA,CACA,GAAA+lB,GAAA/lB,EAAA0gB,YACAsF,EAAAhmB,EAAAyhB,UAEA,IAAA,MAAAsE,GAAArF,EAAAqF,EACAxhC,EAAA,GACAq8B,SACK,IAAA,MAAAoF,EAOL,IAAA,GANA9pC,GAAA8oC,EAAAgB,GAAAF,EAAAA,EAAA,GAAAA,EAAA,GAAA,GAAA9nB,EAAAgC,EAAA+kB,UACAI,QAAAnlB,EAAAmlB,QACAG,YAAAtlB,EAAAslB,cAIAhmC,EAAA,EAAA2O,EAAA2yB,EAAArhC,OAAyCD,EAAA2O,EAAS3O,IAClDshC,EAAAthC,GAAA2lC,EAAArE,EAAAthC,GAAApD,GAKA,OACA0kC,MAAAA,EACAz+B,OAAAA,EACAu+B,YAAAA,EACAG,WAAAA,GAmCA,QAAAqB,GAAA39B,EAAAlE,GACA,GAAAkgC,IACAK,SACA1+B,MAAA,EACAC,OAAA,EAIA,IAFA,MAAAoC,IAAAA,GAAA,KAEAA,EACA,MAAAg8B,EAMA,KAHA,GACAzyB,GADAm4B,EAAAC,EAAAD,UAAA,EAGA,OAAAn4B,EAAAo4B,EAAAC,KAAA5hC,KAAA,CACA,GAAA6hC,GAAAt4B,EAAAu4B,KAEAD,GAAAH,GACAK,EAAA/F,EAAAh8B,EAAAgiC,UAAAN,EAAAG,IAGAE,EAAA/F,EAAAzyB,EAAA,GAAAA,EAAA,IACAm4B,EAAAC,EAAAD,UAGAA,EAAA1hC,EAAAhF,QACA+mC,EAAA/F,EAAAh8B,EAAAgiC,UAAAN,EAAA1hC,EAAAhF,QAGA,IAAAqhC,GAAAL,EAAAK,MACA4F,EAAA,EACApE,EAAA,EAEAqE,KACAC,EAAArmC,EAAAyf,YACAE,EAAA3f,EAAA2f,SACA2mB,EAAA3mB,GAAAA,EAAAyhB,WACAmF,EAAA5mB,GAAAA,EAAA0gB,WAEAgG,KACA,MAAAC,IAAAA,GAAAD,EAAA,GAAAA,EAAA,IACA,MAAAE,IAAAA,GAAAF,EAAA,GAAAA,EAAA,IAIA,KAAA,GAAApnC,GAAA,EAAiBA,EAAAshC,EAAArhC,OAAkBD,IAAA,CAKnC,IAAA,GAJAmjC,GAAA7B,EAAAthC,GACAuhC,EAAA,EACA91B,EAAA,EAEA3J,EAAA,EAAmBA,EAAAqhC,EAAAC,OAAAnjC,OAAwB6B,IAAA,CAC3C,GAAAohC,GAAAC,EAAAC,OAAAthC,GACA4hC,EAAAR,EAAApiB,WAAA/f,EAAA0f,KAAAyiB,EAAApiB,eAEAN,EAAA0iB,EAAA1iB,YAAAkjB,EAAAljB,YAEA9B,EAAAwkB,EAAAxkB,KAAAglB,EAAAhlB,MAAA3d,EAAA2d,KAEA6oB,EAAArE,EAAAhkB,WAAAlN,EAEA0xB,EAAAxkB,WAAAqnB,EAAA7nB,GAOA,IANA8B,IAAA+mB,GAAA/mB,EAAA,GAAAA,EAAA,IACA0iB,EAAArgC,OAAA0kC,EACArE,EAAA3B,WAAApvB,EAAAuxB,EAAAtkB,eAAAre,EAAAqe,eAAAmoB,GACArE,EAAA3jB,UAAAmkB,GAAAA,EAAAnkB,WAAAxe,EAAAwe,UACA2jB,EAAA1jB,kBAAAkkB,GAAAA,EAAAlkB,mBAAA,SAEA,MAAA8nB,GAAAJ,EAAAhE,EAAA3B,WAAA+F,EACA,OACAhG,SACA1+B,MAAA,EACAC,OAAA,EAIAqgC,GAAAjkB,UAAA1hB,EAAA2lC,EAAAj+B,KAAAyZ,EACA,IAAA8oB,GAAA9D,EAAAzkB,UACAwoB,EAAA,MAAAD,GAAA,SAAAA,CAGA,IAAA,gBAAAA,IAAA,MAAAA,EAAAxwB,OAAAwwB,EAAAvnC,OAAA,GACAijC,EAAAwE,aAAAF,EACAL,EAAAtlC,KAAAqhC,GACAsE,EAAA,MAEO,CACP,GAAAC,EAAA,CACAD,EAAAtE,EAAAjkB,SAGA,IAAAmB,GAAAsjB,EAAAtjB,oBACAunB,EAAAvnB,GAAAA,EAAA1c,KAWAikC,KACAA,EAAA5D,EAAA6D,eAAAD,GAEA5D,EAAAG,aAAAyD,KACAH,EAAA1+B,KAAAiD,IAAAy7B,EAAAG,EAAA/kC,MAAA2kC,EAAAI,EAAA9kC,UAKA,GAAAglC,GAAArnB,EAAAA,EAAA,GAAAA,EAAA,GAAA,CACAgnB,IAAAK,CACA,IAAAC,GAAA,MAAAT,EAAAA,EAAA57B,EAAA,IAEA,OAAAq8B,GAAAA,EAAAN,KACAC,GAAAK,EAAAD,GACA3E,EAAAj+B,KAAA,GACAi+B,EAAAjkB,UAAAuoB,EAAA,IAEAtE,EAAAj+B,KAAAsgC,EAAArC,EAAAj+B,KAAA6iC,EAAAD,EAAAnpB,EAAAgC,EAAA+kB,UACAI,QAAAnlB,EAAAmlB,UAEA3C,EAAAjkB,UAAA1hB,EAAA2lC,EAAAj+B,KAAAyZ,GACA8oB,EAAAtE,EAAAjkB,UAAA4oB,IAKAp8B,GAAAy3B,EAAAtgC,MAAA4kC,EACA9D,IAAAnC,EAAAz4B,KAAAiD,IAAAw1B,EAAA2B,EAAA3B,aAGA4B,EAAAvgC,MAAA6I,EACA03B,EAAA5B,WAAAA,EACA2F,GAAA3F,EACAuB,EAAAh6B,KAAAiD,IAAA+2B,EAAAr3B,GAGAw1B,EAAAkB,WAAAlB,EAAAr+B,MAAAoP,EAAAjR,EAAAke,UAAA6jB,GACA7B,EAAAG,YAAAH,EAAAp+B,OAAAmP,EAAAjR,EAAAme,WAAAgoB,GAEAE,IACAnG,EAAAkB,YAAAiF,EAAA,GAAAA,EAAA,GACAnG,EAAAG,aAAAgG,EAAA,GAAAA,EAAA,GAGA,KAAA,GAAApnC,GAAA,EAAiBA,EAAAmnC,EAAAlnC,OAAwBD,IAAA,CACzC,GAAAkjC,GAAAiE,EAAAnnC,GACA0nC,EAAAxE,EAAAwE,YAEAxE,GAAAtgC,MAAAoB,SAAA0jC,EAAA,IAAA,IAAA5E,EAGA,MAAA7B,GAGA,QAAA+F,GAAAe,EAAAhxB,EAAA+J,GAKA,IAAA,GAJAknB,GAAA,KAAAjxB,EACAkxB,EAAAlxB,EAAAL,MAAA,MACA4qB,EAAAyG,EAAAzG,MAEAthC,EAAA,EAAiBA,EAAAioC,EAAAhoC,OAAiBD,IAAA,CAClC,GAAAiF,GAAAgjC,EAAAjoC,GACAkjC,GACApiB,UAAAA,EACA7b,KAAAA,EACA0+B,cAAA1+B,IAAA+iC,EAGA,IAAAhoC,EAkBAshC,EAAAz/B,MACAuhC,QAAAF,SAnBA,CACA,GAAAE,IAAA9B,EAAAA,EAAArhC,OAAA,KAAAqhC,EAAA,IACA8B,aACOA,OAQP8E,EAAA9E,EAAAnjC,MACA,KAAAioC,GAAA9E,EAAA,GAAAO,aAAAP,EAAA,GAAAF,GAEAj+B,IAAAijC,GAAAF,IAAA5E,EAAAvhC,KAAAqhC,KAWA,QAAA1C,GAAAz/B,GAGA,OAAAA,EAAA8d,UAAA9d,EAAA+d,cAAA/d,EAAA4d,UAAA5d,EAAA6d,YAAA7d,EAAA8d,UAAA,IAAA,KACA9d,EAAA+d,YAAA,cAAA8L,KAAA,MAAA7pB,EAAA+L,UAAA/L,EAAA2d,KA/pBA,GAAA3U,GAAA9P,EAAA,IAEA8pC,EAAA9pC,EAAA,IAEAytB,EAAAztB,EAAA,GAEAwI,EAAAilB,EAAAjlB,WACAyH,EAAAwd,EAAAxd,OACA8H,EAAA0V,EAAA1V,UACAG,EAAAuV,EAAAvV,UACA6yB,KACAE,EAAA,EACAC,EAAA,IACAyB,EAAA,gCACA5F,EAAA,kBAEA1yB,IAkXAA,GAAA22B,YAAA,SAAAhgC,EAAAyZ,GACA,GAAAxG,GAAAzV,GAEA,OADAyV,GAAAwG,KAAAA,GAAAsiB,EACA9oB,EAAA+sB,YAAAhgC,IA6RAtL,EAAAqnC,aAAAA,EACArnC,EAAAyU,UAAAA,EACAzU,EAAA4D,SAAAA,EACA5D,EAAAiR,gBAAAA,EACAjR,EAAA0oC,YAAAA,EACA1oC,EAAAmoC,YAAAA,EACAnoC,EAAA4qC,yBAAAA,EACA5qC,EAAA4rC,aAAAA,EACA5rC,EAAA4sC,cAAAA,EACA5sC,EAAAsrC,YAAAA,EACAtrC,EAAAwnC,eAAAA,EACAxnC,EAAAipC,cAAAA,EACAjpC,EAAA6mC,SAAAA,G1Bq2OM,SAAU5mC,EAAQD,EAASM,G2BrgQjC,QAAA8P,GAAAvG,EAAAC,EAAAb,EAAAC,GACAD,EAAA,IACAY,GAAAZ,EACAA,GAAAA,GAGAC,EAAA,IACAY,GAAAZ,EACAA,GAAAA,GAOA9I,KAAAyJ,EAAAA,EAKAzJ,KAAA0J,EAAAA,EAKA1J,KAAA6I,MAAAA,EAKA7I,KAAA8I,OAAAA,EA5CA,GAAAslC,GAAAluC,EAAA,IAEA+O,EAAA/O,EAAA,IAKAmuC,EAAAD,EAAAh9B,eACAk9B,EAAAv/B,KAAAqV,IACAmqB,EAAAx/B,KAAAiD,GAsCAhC,GAAA3M,WACA0R,YAAA/E,EAKAw+B,MAAA,SAAAC,GACA,GAAAhlC,GAAA6kC,EAAAG,EAAAhlC,EAAAzJ,KAAAyJ,GACAC,EAAA4kC,EAAAG,EAAA/kC,EAAA1J,KAAA0J,EACA1J,MAAA6I,MAAA0lC,EAAAE,EAAAhlC,EAAAglC,EAAA5lC,MAAA7I,KAAAyJ,EAAAzJ,KAAA6I,OAAAY,EACAzJ,KAAA8I,OAAAylC,EAAAE,EAAA/kC,EAAA+kC,EAAA3lC,OAAA9I,KAAA0J,EAAA1J,KAAA8I,QAAAY,EACA1J,KAAAyJ,EAAAA,EACAzJ,KAAA0J,EAAAA,GAOA0H,eAAA,WACA,GAAAs9B,MACAC,KACAC,KACAC,IACA,OAAA,UAAAruC,GAIA,GAAAA,EAAA,CAIAkuC,EAAA,GAAAE,EAAA,GAAA5uC,KAAAyJ,EACAilC,EAAA,GAAAG,EAAA,GAAA7uC,KAAA0J,EACAilC,EAAA,GAAAE,EAAA,GAAA7uC,KAAAyJ,EAAAzJ,KAAA6I,MACA8lC,EAAA,GAAAC,EAAA,GAAA5uC,KAAA0J,EAAA1J,KAAA8I,OACAulC,EAAAK,EAAAA,EAAAluC,GACA6tC,EAAAM,EAAAA,EAAAnuC,GACA6tC,EAAAO,EAAAA,EAAApuC,GACA6tC,EAAAQ,EAAAA,EAAAruC,GACAR,KAAAyJ,EAAA6kC,EAAAI,EAAA,GAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,IACA7uC,KAAA0J,EAAA4kC,EAAAI,EAAA,GAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,GACA,IAAAC,GAAAP,EAAAG,EAAA,GAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,IACAE,EAAAR,EAAAG,EAAA,GAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,GACA7uC,MAAA6I,MAAAimC,EAAA9uC,KAAAyJ,EACAzJ,KAAA8I,OAAAimC,EAAA/uC,KAAA0J,OASA4H,mBAAA,SAAAib,GACA,GAAAd,GAAAzrB,KACAwqB,EAAA+B,EAAA1jB,MAAA4iB,EAAA5iB,MACA4hB,EAAA8B,EAAAzjB,OAAA2iB,EAAA3iB,OACAtI,EAAAyO,EAAAmb,QAKA,OAHAnb,GAAAuc,UAAAhrB,EAAAA,IAAAirB,EAAAhiB,GAAAgiB,EAAA/hB,IACAuF,EAAAzF,MAAAhJ,EAAAA,GAAAgqB,EAAAC,IACAxb,EAAAuc,UAAAhrB,EAAAA,GAAA+rB,EAAA9iB,EAAA8iB,EAAA7iB,IACAlJ,GAOAwuC,UAAA,SAAAziB,GACA,IAAAA,EACA,OAAA,CAGAA,aAAAvc,KAEAuc,EAAAvc,EAAAoa,OAAAmC,GAGA,IAAAd,GAAAzrB,KACAivC,EAAAxjB,EAAAhiB,EACAylC,EAAAzjB,EAAAhiB,EAAAgiB,EAAA5iB,MACAsmC,EAAA1jB,EAAA/hB,EACA0lC,EAAA3jB,EAAA/hB,EAAA+hB,EAAA3iB,OACAumC,EAAA9iB,EAAA9iB,EACA6lC,EAAA/iB,EAAA9iB,EAAA8iB,EAAA1jB,MACA0mC,EAAAhjB,EAAA7iB,EACA8lC,EAAAjjB,EAAA7iB,EAAA6iB,EAAAzjB,MACA,SAAAomC,EAAAG,GAAAC,EAAAL,GAAAG,EAAAG,GAAAC,EAAAL,IAEAttB,QAAA,SAAApY,EAAAC,GACA,GAAA8G,GAAAxQ,IACA,OAAAyJ,IAAA+G,EAAA/G,GAAAA,GAAA+G,EAAA/G,EAAA+G,EAAA3H,OAAAa,GAAA8G,EAAA9G,GAAAA,GAAA8G,EAAA9G,EAAA8G,EAAA1H,QAMAmC,MAAA,WACA,MAAA,IAAA+E,GAAAhQ,KAAAyJ,EAAAzJ,KAAA0J,EAAA1J,KAAA6I,MAAA7I,KAAA8I;EAMA0Y,KAAA,SAAAitB,GACAzuC,KAAAyJ,EAAAglC,EAAAhlC,EACAzJ,KAAA0J,EAAA+kC,EAAA/kC,EACA1J,KAAA6I,MAAA4lC,EAAA5lC,MACA7I,KAAA8I,OAAA2lC,EAAA3lC,QAEA2mC,MAAA,WACA,OACAhmC,EAAAzJ,KAAAyJ,EACAC,EAAA1J,KAAA0J,EACAb,MAAA7I,KAAA6I,MACAC,OAAA9I,KAAA8I,UAaAkH,EAAAoa,OAAA,SAAA5Z,GACA,MAAA,IAAAR,GAAAQ,EAAA/G,EAAA+G,EAAA9G,EAAA8G,EAAA3H,MAAA2H,EAAA1H,QAGA,IAAAga,GAAA9S,CACAnQ,GAAAD,QAAAkjB,G3ByhQM,SAAUjjB,EAAQD,EAASM,G4BvsQjC,QAAA2tC,GAAA6B,GACA,GAAA,gBAAAA,GAAA,CACA,GAAAC,GAAAC,EAAA/pC,IAAA6pC,EACA,OAAAC,IAAAA,EAAAhmC,MAEA,MAAA+lC,GAgBA,QAAAzF,GAAAyF,EAAA/lC,EAAAk9B,EAAA5+B,EAAA4nC,GACA,GAAAH,EAEG,CAAA,GAAA,gBAAAA,GAAA,CAEH,GAAA/lC,GAAAA,EAAAmmC,eAAAJ,IAAA7I,EACA,MAAAl9B,EAKA,IAAAgmC,GAAAC,EAAA/pC,IAAA6pC,GACAK,GACAlJ,OAAAA,EACA5+B,GAAAA,EACA4nC,UAAAA,EAgBA,OAbAF,IACAhmC,EAAAgmC,EAAAhmC,OACAwgC,EAAAxgC,IAAAgmC,EAAAK,QAAAloC,KAAAioC,MAEApmC,IAAAA,EAAA,GAAAL,QACAK,EAAAsmC,OAAAC,EACAN,EAAAnX,IAAAiX,EAAA/lC,EAAAwmC,gBACAxmC,MAAAA,EACAqmC,SAAAD,KAEApmC,EAAAymC,IAAAzmC,EAAAmmC,aAAAJ,GAGA/lC,EAGA,MAAA+lC,GAhCA,MAAA/lC,GAoCA,QAAAumC,KACA,GAAAP,GAAA3vC,KAAAmwC,cACAnwC,MAAAiwC,OAAAjwC,KAAAmwC,eAAA,IAEA,KAAA,GAAAlqC,GAAA,EAAiBA,EAAA0pC,EAAAK,QAAA9pC,OAAiCD,IAAA,CAClD,GAAA8pC,GAAAJ,EAAAK,QAAA/pC,GACAgC,EAAA8nC,EAAA9nC,EACAA,IAAAA,EAAAjI,KAAA+vC,EAAAF,WACAE,EAAAlJ,OAAAvoB,QAGAqxB,EAAAK,QAAA9pC,OAAA,EAGA,QAAAikC,GAAAxgC,GACA,MAAAA,IAAAA,EAAAd,OAAAc,EAAAb,OAlFA,GAAAoyB,GAAAh7B,EAAA,IAEA0vC,EAAA,GAAA1U,GAAA,GAmFAt7B,GAAAiuC,eAAAA,EACAjuC,EAAAqqC,oBAAAA,EACArqC,EAAAuqC,aAAAA,G5BqtQM,SAAUtqC,EAAQD,G6B5yQxB,QAAAqe,GAAAE,EAAAha,GACA,GAKAksC,GACAC,EACAC,EACAC,EARA/mC,EAAAtF,EAAAsF,EACAC,EAAAvF,EAAAuF,EACAb,EAAA1E,EAAA0E,MACAC,EAAA3E,EAAA2E,OACAub,EAAAlgB,EAAAkgB,CAMAxb,GAAA,IACAY,GAAAZ,EACAA,GAAAA,GAGAC,EAAA,IACAY,GAAAZ,EACAA,GAAAA,GAGA,gBAAAub,GACAgsB,EAAAC,EAAAC,EAAAC,EAAAnsB,EACGA,YAAA/J,OACH,IAAA+J,EAAAne,OACAmqC,EAAAC,EAAAC,EAAAC,EAAAnsB,EAAA,GACK,IAAAA,EAAAne,QACLmqC,EAAAE,EAAAlsB,EAAA,GACAisB,EAAAE,EAAAnsB,EAAA,IACK,IAAAA,EAAAne,QACLmqC,EAAAhsB,EAAA,GACAisB,EAAAE,EAAAnsB,EAAA,GACAksB,EAAAlsB,EAAA,KAEAgsB,EAAAhsB,EAAA,GACAisB,EAAAjsB,EAAA,GACAksB,EAAAlsB,EAAA,GACAmsB,EAAAnsB,EAAA,IAGAgsB,EAAAC,EAAAC,EAAAC,EAAA,CAGA,IAAAC,EAEAJ,GAAAC,EAAAznC,IACA4nC,EAAAJ,EAAAC,EACAD,GAAAxnC,EAAA4nC,EACAH,GAAAznC,EAAA4nC,GAGAF,EAAAC,EAAA3nC,IACA4nC,EAAAF,EAAAC,EACAD,GAAA1nC,EAAA4nC,EACAD,GAAA3nC,EAAA4nC,GAGAH,EAAAC,EAAAznC,IACA2nC,EAAAH,EAAAC,EACAD,GAAAxnC,EAAA2nC,EACAF,GAAAznC,EAAA2nC,GAGAJ,EAAAG,EAAA1nC,IACA2nC,EAAAJ,EAAAG,EACAH,GAAAvnC,EAAA2nC,EACAD,GAAA1nC,EAAA2nC,GAGAtyB,EAAAuyB,OAAAjnC,EAAA4mC,EAAA3mC,GACAyU,EAAAwyB,OAAAlnC,EAAAZ,EAAAynC,EAAA5mC,GACA,IAAA4mC,GAAAnyB,EAAAyyB,iBAAAnnC,EAAAZ,EAAAa,EAAAD,EAAAZ,EAAAa,EAAA4mC,GACAnyB,EAAAwyB,OAAAlnC,EAAAZ,EAAAa,EAAAZ,EAAAynC,GACA,IAAAA,GAAApyB,EAAAyyB,iBAAAnnC,EAAAZ,EAAAa,EAAAZ,EAAAW,EAAAZ,EAAA0nC,EAAA7mC,EAAAZ,GACAqV,EAAAwyB,OAAAlnC,EAAA+mC,EAAA9mC,EAAAZ,GACA,IAAA0nC,GAAAryB,EAAAyyB,iBAAAnnC,EAAAC,EAAAZ,EAAAW,EAAAC,EAAAZ,EAAA0nC,GACAryB,EAAAwyB,OAAAlnC,EAAAC,EAAA2mC,GACA,IAAAA,GAAAlyB,EAAAyyB,iBAAAnnC,EAAAC,EAAAD,EAAA4mC,EAAA3mC,GAGA9J,EAAAqe,UAAAA,G7BkzQM,SAAUpe,EAAQD,EAASM,G8Bl4QjC,GAAA2wC,GAAA3wC,EAAA,IAEAkuC,EAAAluC,EAAA,IAEA4wC,EAAA5wC,EAAA,IAEA8P,EAAA9P,EAAA,IAEA2lC,EAAA3lC,EAAA,IAEAoqB,EAAAub,EAAA3jC,iBAUA6a,GACAU,EAAA,EACAD,EAAA,EACAE,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EAEA2b,EAAA,GAWApV,KACApS,KACA++B,KACAC,KACA1C,EAAAv/B,KAAAqV,IACAmqB,EAAAx/B,KAAAiD,IACAqJ,EAAAtM,KAAAiQ,IACA1D,EAAAvM,KAAAgQ,IACAtD,EAAA1M,KAAA+P,KACAmyB,EAAAliC,KAAAoF,IACA+8B,EAAA,mBAAA5kB,cAMAxP,EAAA,SAAAq0B,GACAnxC,KAAAoxC,WAAAD,EAEAnxC,KAAAoxC,YAKApxC,KAAAwW,SAGAxW,KAAA6V,KAAA,KAQAiH,GAAAzZ,WACA0R,YAAA+H,EACAu0B,IAAA,EACAC,IAAA,EACAC,IAAA,EACAC,IAAA,EAEAC,IAAA,EACAC,IAAA,EACA9M,KAAA,EACA+M,UAAA,KACAC,YAAA,EACAC,SAAA,EACAC,SAAA,EAKAjxB,SAAA,SAAA2J,EAAAC,GACAzqB,KAAAyxC,IAAAR,EAAA,EAAA3mB,EAAAE,IAAA,EACAxqB,KAAA0xC,IAAAT,EAAA,EAAA3mB,EAAAG,IAAA,GAEA/hB,WAAA,WACA,MAAA1I,MAAA6V,MAOAiL,UAAA,SAAA3C,GAcA,MAbAne,MAAA6V,KAAAsI,EACAA,GAAAA,EAAA2C,YACA3C,IAAAne,KAAAsqB,IAAAnM,EAAAmM,KAEAtqB,KAAAoxC,YACApxC,KAAA4kC,KAAA,GAGA5kC,KAAA2xC,YACA3xC,KAAA2xC,UAAA,KACA3xC,KAAA4xC,YAAA,GAGA5xC,MAQA0wC,OAAA,SAAAjnC,EAAAC,GAWA,MAVA1J,MAAAmc,QAAAY,EAAAU,EAAAhU,EAAAC,GACA1J,KAAA6V,MAAA7V,KAAA6V,KAAA66B,OAAAjnC,EAAAC,GAKA1J,KAAAuxC,IAAA9nC,EACAzJ,KAAAwxC,IAAA9nC,EACA1J,KAAAqxC,IAAA5nC,EACAzJ,KAAAsxC,IAAA5nC,EACA1J,MAQA2wC,OAAA,SAAAlnC,EAAAC,GACA,GAAAqoC,GAAAd,EAAAxnC,EAAAzJ,KAAAqxC,KAAArxC,KAAAyxC,KAAAR,EAAAvnC,EAAA1J,KAAAsxC,KAAAtxC,KAAA0xC,KACA1xC,KAAA4kC,KAAA,CAYA,OAXA5kC,MAAAmc,QAAAY,EAAAS,EAAA/T,EAAAC,GAEA1J,KAAA6V,MAAAk8B,IACA/xC,KAAAgyC,aAAAhyC,KAAAiyC,cAAAxoC,EAAAC,GAAA1J,KAAA6V,KAAA86B,OAAAlnC,EAAAC,IAGAqoC,IACA/xC,KAAAqxC,IAAA5nC,EACAzJ,KAAAsxC,IAAA5nC,GAGA1J,MAYAkyC,cAAA,SAAA9nC,EAAAC,EAAAC,EAAAC,EAAA4nC,EAAAC,GASA,MARApyC,MAAAmc,QAAAY,EAAAW,EAAAtT,EAAAC,EAAAC,EAAAC,EAAA4nC,EAAAC,GAEApyC,KAAA6V,OACA7V,KAAAgyC,aAAAhyC,KAAAqyC,gBAAAjoC,EAAAC,EAAAC,EAAAC,EAAA4nC,EAAAC,GAAApyC,KAAA6V,KAAAq8B,cAAA9nC,EAAAC,EAAAC,EAAAC,EAAA4nC,EAAAC,IAGApyC,KAAAqxC,IAAAc,EACAnyC,KAAAsxC,IAAAc,EACApyC,MAUA4wC,iBAAA,SAAAxmC,EAAAC,EAAAC,EAAAC,GASA,MARAvK,MAAAmc,QAAAY,EAAAY,EAAAvT,EAAAC,EAAAC,EAAAC,GAEAvK,KAAA6V,OACA7V,KAAAgyC,aAAAhyC,KAAAsyC,mBAAAloC,EAAAC,EAAAC,EAAAC,GAAAvK,KAAA6V,KAAA+6B,iBAAAxmC,EAAAC,EAAAC,EAAAC,IAGAvK,KAAAqxC,IAAA/mC,EACAtK,KAAAsxC,IAAA/mC,EACAvK,MAYAuyC,IAAA,SAAAxhC,EAAAC,EAAAqT,EAAAmuB,EAAAC,EAAAC,GAKA,MAJA1yC,MAAAmc,QAAAY,EAAAa,EAAA7M,EAAAC,EAAAqT,EAAAA,EAAAmuB,EAAAC,EAAAD,EAAA,EAAAE,EAAA,EAAA,GACA1yC,KAAA6V,MAAA7V,KAAA6V,KAAA08B,IAAAxhC,EAAAC,EAAAqT,EAAAmuB,EAAAC,EAAAC,GACA1yC,KAAAqxC,IAAAh2B,EAAAo3B,GAAApuB,EAAAtT,EACA/Q,KAAAsxC,IAAAh2B,EAAAm3B,GAAApuB,EAAAtT,EACA/Q,MAGA2yC,MAAA,SAAAvoC,EAAAC,EAAAC,EAAAC,EAAAqoC,GAKA,MAJA5yC,MAAA6V,MACA7V,KAAA6V,KAAA88B,MAAAvoC,EAAAC,EAAAC,EAAAC,EAAAqoC,GAGA5yC,MAGAwQ,KAAA,SAAA/G,EAAAC,EAAA+X,EAAA6H,GAGA,MAFAtpB,MAAA6V,MAAA7V,KAAA6V,KAAArF,KAAA/G,EAAAC,EAAA+X,EAAA6H,GACAtpB,KAAAmc,QAAAY,EAAAyc,EAAA/vB,EAAAC,EAAA+X,EAAA6H,GACAtpB,MAMA+pC,UAAA,WACA/pC,KAAAmc,QAAAY,EAAAc,EACA,IAAAM,GAAAne,KAAA6V,KACAg9B,EAAA7yC,KAAAuxC,IACAuB,EAAA9yC,KAAAwxC,GASA,OAPArzB,KACAne,KAAAgyC,cAAAhyC,KAAAiyC,cAAAY,EAAAC,GACA30B,EAAA4rB,aAGA/pC,KAAAqxC,IAAAwB,EACA7yC,KAAAsxC,IAAAwB,EACA9yC,MASA+I,KAAA,SAAAoV,GACAA,GAAAA,EAAApV,OACA/I,KAAA8d,YAOAlR,OAAA,SAAAuR,GACAA,GAAAA,EAAAvR,SACA5M,KAAA8d,YAQA6C,YAAA,SAAAnW,GACA,GAAAA,YAAA8P,OAAA,CACAta,KAAA2xC,UAAAnnC,EACAxK,KAAA6xC,SAAA,CAGA,KAAA,GAFAkB,GAAA,EAEA9sC,EAAA,EAAqBA,EAAAuE,EAAAtE,OAAqBD,IAC1C8sC,GAAAvoC,EAAAvE,EAGAjG,MAAA8xC,SAAAiB,EAGA,MAAA/yC,OAQA+gB,kBAAA,SAAAuG,GAEA,MADAtnB,MAAA4xC,YAAAtqB,EACAtnB,MAOA4U,IAAA,WACA,MAAA5U,MAAA4kC,MAMA1mB,QAAA,SAAA1H,GACA,GAAA5B,GAAA4B,EAAAtQ,MAEAlG,MAAAwW,MAAAxW,KAAAwW,KAAAtQ,QAAA0O,IAAAs8B,IACAlxC,KAAAwW,KAAA,GAAA8V,cAAA1X,GAGA,KAAA,GAAA3O,GAAA,EAAmBA,EAAA2O,EAAS3O,IAC5BjG,KAAAwW,KAAAvQ,GAAAuQ,EAAAvQ,EAGAjG,MAAA4kC,KAAAhwB,GAOAiK,WAAA,SAAAnO,GACAA,YAAA4J,SACA5J,GAAAA,GAOA,KAAA,GAJAkE,GAAAlE,EAAAxK,OACA8sC,EAAA,EACA1rB,EAAAtnB,KAAA4kC,KAEA3+B,EAAA,EAAmBA,EAAA2O,EAAS3O,IAC5B+sC,GAAAtiC,EAAAzK,GAAA2O,KAGAs8B,IAAAlxC,KAAAwW,eAAA8V,gBACAtsB,KAAAwW,KAAA,GAAA8V,cAAAhF,EAAA0rB,GAGA,KAAA,GAAA/sC,GAAA,EAAmBA,EAAA2O,EAAS3O,IAG5B,IAAA,GAFAgtC,GAAAviC,EAAAzK,GAAAuQ,KAEAif,EAAA,EAAqBA,EAAAwd,EAAA/sC,OAA2BuvB,IAChDz1B,KAAAwW,KAAA8Q,KAAA2rB,EAAAxd,EAIAz1B,MAAA4kC,KAAAtd,GAOAnL,QAAA,SAAAlB,GACA,GAAAjb,KAAAoxC,UAAA,CAIA,GAAA56B,GAAAxW,KAAAwW,IAEAxW,MAAA4kC,KAAArtB,UAAArR,OAAAsQ,EAAAtQ,SAGAlG,KAAAkzC,cAEA18B,EAAAxW,KAAAwW,KAGA,KAAA,GAAAvQ,GAAA,EAAmBA,EAAAsR,UAAArR,OAAsBD,IACzCuQ,EAAAxW,KAAA4kC,QAAArtB,UAAAtR,EAGAjG,MAAAmzC,SAAAl4B,IAEAi4B,YAAA,WAEA,KAAAlzC,KAAAwW,eAAA8D,QAAA,CAGA,IAAA,GAFA84B,MAEAntC,EAAA,EAAqBA,EAAAjG,KAAA4kC,KAAe3+B,IACpCmtC,EAAAntC,GAAAjG,KAAAwW,KAAAvQ,EAGAjG,MAAAwW,KAAA48B,IASApB,WAAA,WACA,MAAAhyC,MAAA2xC,WAEAM,cAAA,SAAA7nC,EAAAC,GACA,GAWAgpC,GAEAC,EAbAC,EAAAvzC,KAAA8xC,SACAxqB,EAAAtnB,KAAA4xC,YACApnC,EAAAxK,KAAA2xC,UACAxzB,EAAAne,KAAA6V,KACAg9B,EAAA7yC,KAAAqxC,IACAyB,EAAA9yC,KAAAsxC,IACAxpB,EAAA1d,EAAAyoC,EACA9qB,EAAA1d,EAAAyoC,EACAvlB,EAAA9R,EAAAqM,EAAAA,EAAAC,EAAAA,GACAte,EAAAopC,EACAnpC,EAAAopC,EAEAU,EAAAhpC,EAAAtE,MAcA,KAZA4hB,GAAAyF,EACAxF,GAAAwF,EAEAjG,EAAA,IAEAA,EAAAisB,EAAAjsB,GAGAA,GAAAisB,EACA9pC,GAAA6d,EAAAQ,EACApe,GAAA4d,EAAAS,EAEAD,EAAA,GAAAre,GAAAW,GAAA0d,EAAA,GAAAre,GAAAW,GAAA,GAAA0d,IAAAC,EAAA,GAAAre,GAAAW,GAAA0d,EAAA,GAAAre,GAAAW,IACAipC,EAAAtzC,KAAA6xC,SACAwB,EAAA7oC,EAAA8oC,GACA7pC,GAAAqe,EAAAurB,EACA3pC,GAAAqe,EAAAsrB,EACArzC,KAAA6xC,UAAAyB,EAAA,GAAAE,EAEA1rB,EAAA,GAAAre,EAAAopC,GAAA/qB,EAAA,GAAAre,EAAAopC,GAAA9qB,EAAA,GAAAre,EAAAopC,GAAA/qB,EAAA,GAAAre,EAAAopC,GAIA30B,EAAAm1B,EAAA,EAAA,SAAA,UAAAxrB,GAAA,EAAAwmB,EAAA7kC,EAAAW,GAAAmkC,EAAA9kC,EAAAW,GAAA2d,GAAA,EAAAumB,EAAA5kC,EAAAW,GAAAkkC,EAAA7kC,EAAAW,GAIAyd,GAAAre,EAAAW,EACA2d,EAAAre,EAAAW,EACArK,KAAA4xC,aAAAn2B,EAAAqM,EAAAA,EAAAC,EAAAA,IAGAsqB,gBAAA,SAAAjoC,EAAAC,EAAAC,EAAAC,EAAA4nC,EAAAC,GACA,GAMA/kB,GACAvF,EACAC,EAKAte,EACAC,EAdA6pC,EAAAvzC,KAAA8xC,SACAxqB,EAAAtnB,KAAA4xC,YACApnC,EAAAxK,KAAA2xC,UACAxzB,EAAAne,KAAA6V,KACAg9B,EAAA7yC,KAAAqxC,IACAyB,EAAA9yC,KAAAsxC,IAIAmC,EAAA5C,EAAA4C,QACAC,EAAA,EACAJ,EAAAtzC,KAAA6xC,SACA2B,EAAAhpC,EAAAtE,OAGAytC,EAAA,CASA,KAPArsB,EAAA,IAEAA,EAAAisB,EAAAjsB,GAGAA,GAAAisB,EAEAlmB,EAAA,EAAeA,EAAA,EAAOA,GAAA,GACtBvF,EAAA2rB,EAAAZ,EAAAzoC,EAAAE,EAAA6nC,EAAA9kB,EAAA,IAAAomB,EAAAZ,EAAAzoC,EAAAE,EAAA6nC,EAAA9kB,GACAtF,EAAA0rB,EAAAX,EAAAzoC,EAAAE,EAAA6nC,EAAA/kB,EAAA,IAAAomB,EAAAX,EAAAzoC,EAAAE,EAAA6nC,EAAA/kB,GACAqmB,GAAAj4B,EAAAqM,EAAAA,EAAAC,EAAAA,EAIA,MAAUurB,EAAAE,IACVG,GAAAnpC,EAAA8oC,KAEAK,EAAArsB,IAHuBgsB,KAUvB,IAFAjmB,GAAAsmB,EAAArsB,GAAAosB,EAEArmB,GAAA,GACA5jB,EAAAgqC,EAAAZ,EAAAzoC,EAAAE,EAAA6nC,EAAA9kB,GACA3jB,EAAA+pC,EAAAX,EAAAzoC,EAAAE,EAAA6nC,EAAA/kB,GAGAimB,EAAA,EAAAn1B,EAAAuyB,OAAAjnC,EAAAC,GAAAyU,EAAAwyB,OAAAlnC,EAAAC,GACA2jB,GAAA7iB,EAAA8oC,GAAAI,EACAJ,GAAAA,EAAA,GAAAE,CAIAF,GAAA,IAAA,GAAAn1B,EAAAwyB,OAAAwB,EAAAC,GACAtqB,EAAAqqB,EAAA1oC,EACAse,EAAAqqB,EAAA1oC,EACA1J,KAAA4xC,aAAAn2B,EAAAqM,EAAAA,EAAAC,EAAAA,IAEAuqB,mBAAA,SAAAloC,EAAAC,EAAAC,EAAAC,GAEA,GAAA4nC,GAAA7nC,EACA8nC,EAAA7nC,CACAD,IAAAA,EAAA,EAAAF,GAAA,EACAG,GAAAA,EAAA,EAAAF,GAAA,EACAD,GAAApK,KAAAqxC,IAAA,EAAAjnC,GAAA,EACAC,GAAArK,KAAAsxC,IAAA,EAAAjnC,GAAA,EAEArK,KAAAqyC,gBAAAjoC,EAAAC,EAAAC,EAAAC,EAAA4nC,EAAAC,IAOAt0B,SAAA,WACA,GAAAtH,GAAAxW,KAAAwW,IAEAA,aAAA8D,SACA9D,EAAAtQ,OAAAlG,KAAA4kC,KAEAsM,IACAlxC,KAAAwW,KAAA,GAAA8V,cAAA9V,MAQA3F,gBAAA,WACAuT,EAAA,GAAAA,EAAA,GAAA2sB,EAAA,GAAAA,EAAA,GAAA6C,OAAAC,UACA7hC,EAAA,GAAAA,EAAA,GAAAg/B,EAAA,GAAAA,EAAA,IAAA4C,OAAAC,SAOA,KAAA,GANAr9B,GAAAxW,KAAAwW,KACAs9B,EAAA,EACAC,EAAA,EACAlB,EAAA,EACAC,EAAA,EAEA7sC,EAAA,EAAmBA,EAAAuQ,EAAAtQ,QAAiB,CACpC,GAAA+U,GAAAzE,EAAAvQ,IAaA,QAXA,GAAAA,IAKA6tC,EAAAt9B,EAAAvQ,GACA8tC,EAAAv9B,EAAAvQ,EAAA,GACA4sC,EAAAiB,EACAhB,EAAAiB,GAGA94B,GACA,IAAA8B,GAAAU,EAGAo1B,EAAAr8B,EAAAvQ,KACA6sC,EAAAt8B,EAAAvQ,KACA6tC,EAAAjB,EACAkB,EAAAjB,EACA/B,EAAA,GAAA8B,EACA9B,EAAA,GAAA+B,EACA9B,EAAA,GAAA6B,EACA7B,EAAA,GAAA8B,CACA,MAEA,KAAA/1B,GAAAS,EACAszB,EAAAkD,SAAAF,EAAAC,EAAAv9B,EAAAvQ,GAAAuQ,EAAAvQ,EAAA,GAAA8qC,EAAAC,GACA8C,EAAAt9B,EAAAvQ,KACA8tC,EAAAv9B,EAAAvQ,IACA,MAEA,KAAA8W,GAAAW,EACAozB,EAAAmD,UAAAH,EAAAC,EAAAv9B,EAAAvQ,KAAAuQ,EAAAvQ,KAAAuQ,EAAAvQ,KAAAuQ,EAAAvQ,KAAAuQ,EAAAvQ,GAAAuQ,EAAAvQ,EAAA,GAAA8qC,EAAAC,GACA8C,EAAAt9B,EAAAvQ,KACA8tC,EAAAv9B,EAAAvQ,IACA,MAEA,KAAA8W,GAAAY,EACAmzB,EAAAoD,cAAAJ,EAAAC,EAAAv9B,EAAAvQ,KAAAuQ,EAAAvQ,KAAAuQ,EAAAvQ,GAAAuQ,EAAAvQ,EAAA,GAAA8qC,EAAAC,GACA8C,EAAAt9B,EAAAvQ,KACA8tC,EAAAv9B,EAAAvQ,IACA,MAEA,KAAA8W,GAAAa,EAEA,GAAA7M,GAAAyF,EAAAvQ,KACA+K,EAAAwF,EAAAvQ,KACA6U,EAAAtE,EAAAvQ,KACA8U,EAAAvE,EAAAvQ,KACAusC,EAAAh8B,EAAAvQ,KACAwsC,EAAAj8B,EAAAvQ,KAAAusC,EAGAE,GADAl8B,EAAAvQ,KACA,EAAAuQ,EAAAvQ,KAEA,IAAAA,IAGA4sC,EAAAx3B,EAAAm3B,GAAA13B,EAAA/J,EACA+hC,EAAAx3B,EAAAk3B,GAAAz3B,EAAA/J,GAGA8/B,EAAAqD,QAAApjC,EAAAC,EAAA8J,EAAAC,EAAAy3B,EAAAC,EAAAC,EAAA3B,EAAAC,GACA8C,EAAAz4B,EAAAo3B,GAAA33B,EAAA/J,EACAgjC,EAAAz4B,EAAAm3B,GAAA13B,EAAA/J,CACA,MAEA,KAAA+L,GAAAyc,EACAqZ,EAAAiB,EAAAt9B,EAAAvQ,KACA6sC,EAAAiB,EAAAv9B,EAAAvQ,IACA,IAAA4C,GAAA2N,EAAAvQ,KACA6C,EAAA0N,EAAAvQ,IAEA6qC,GAAAkD,SAAAnB,EAAAC,EAAAD,EAAAhqC,EAAAiqC,EAAAhqC,EAAAioC,EAAAC,EACA,MAEA,KAAAj0B,GAAAc,EACAi2B,EAAAjB,EACAkB,EAAAjB,EAKA1E,EAAAhqB,IAAAA,EAAAA,EAAA2sB,GACA3C,EAAAp8B,IAAAA,EAAAA,EAAAg/B,GAQA,MAJA,KAAA/qC,IACAme,EAAA,GAAAA,EAAA,GAAApS,EAAA,GAAAA,EAAA,GAAA,GAGA,GAAAhC,GAAAoU,EAAA,GAAAA,EAAA,GAAApS,EAAA,GAAAoS,EAAA,GAAApS,EAAA,GAAAoS,EAAA,KAQAhG,YAAA,SAAAD,GASA,IAAA,GAPA00B,GAAAC,EACAgB,EAAAC,EACAtqC,EAAAC,EAHAsjB,EAAAhtB,KAAAwW,KAIA49B,EAAAp0C,KAAAyxC,IACA4C,EAAAr0C,KAAA0xC,IACA98B,EAAA5U,KAAA4kC,KAEA3+B,EAAA,EAAmBA,EAAA2O,GAAS,CAC5B,GAAAqG,GAAA+R,EAAA/mB,IAaA,QAXA,GAAAA,IAKA6tC,EAAA9mB,EAAA/mB,GACA8tC,EAAA/mB,EAAA/mB,EAAA,GACA4sC,EAAAiB,EACAhB,EAAAiB,GAGA94B,GACA,IAAA8B,GAAAU,EACAo1B,EAAAiB,EAAA9mB,EAAA/mB,KACA6sC,EAAAiB,EAAA/mB,EAAA/mB,KACAkY,EAAAuyB,OAAAoD,EAAAC,EACA,MAEA,KAAAh3B,GAAAS,EACA/T,EAAAujB,EAAA/mB,KACAyD,EAAAsjB,EAAA/mB,MAEAgrC,EAAAxnC,EAAAqqC,GAAAM,GAAAnD,EAAAvnC,EAAAqqC,GAAAM,GAAApuC,IAAA2O,EAAA,KACAuJ,EAAAwyB,OAAAlnC,EAAAC,GACAoqC,EAAArqC,EACAsqC,EAAArqC,EAGA,MAEA,KAAAqT,GAAAW,EACAS,EAAA+zB,cAAAllB,EAAA/mB,KAAA+mB,EAAA/mB,KAAA+mB,EAAA/mB,KAAA+mB,EAAA/mB,KAAA+mB,EAAA/mB,KAAA+mB,EAAA/mB,MACA6tC,EAAA9mB,EAAA/mB,EAAA,GACA8tC,EAAA/mB,EAAA/mB,EAAA,EACA,MAEA,KAAA8W,GAAAY,EACAQ,EAAAyyB,iBAAA5jB,EAAA/mB,KAAA+mB,EAAA/mB,KAAA+mB,EAAA/mB,KAAA+mB,EAAA/mB,MACA6tC,EAAA9mB,EAAA/mB,EAAA,GACA8tC,EAAA/mB,EAAA/mB,EAAA,EACA,MAEA,KAAA8W,GAAAa,EACA,GAAA7M,GAAAic,EAAA/mB,KACA+K,EAAAgc,EAAA/mB,KACA6U,EAAAkS,EAAA/mB,KACA8U,EAAAiS,EAAA/mB,KACA4V,EAAAmR,EAAA/mB,KACAgW,EAAA+Q,EAAA/mB,KACAiV,EAAA8R,EAAA/mB,KACA4U,EAAAmS,EAAA/mB,KACAoe,EAAAvJ,EAAAC,EAAAD,EAAAC,EACAu5B,EAAAx5B,EAAAC,EAAA,EAAAD,EAAAC,EACAw5B,EAAAz5B,EAAAC,EAAAA,EAAAD,EAAA,EACA05B,EAAAzlC,KAAAoF,IAAA2G,EAAAC,GAAA,KACA03B,EAAA52B,EAAAI,CAEAu4B,IACAr2B,EAAAqN,UAAAza,EAAAC,GACAmN,EAAA0M,OAAA3P,GACAiD,EAAA3U,MAAA8qC,EAAAC,GACAp2B,EAAAo0B,IAAA,EAAA,EAAAluB,EAAAxI,EAAA42B,EAAA,EAAA53B,GACAsD,EAAA3U,MAAA,EAAA8qC,EAAA,EAAAC,GACAp2B,EAAA0M,QAAA3P,GACAiD,EAAAqN,WAAAza,GAAAC,IAEAmN,EAAAo0B,IAAAxhC,EAAAC,EAAAqT,EAAAxI,EAAA42B,EAAA,EAAA53B,GAGA,GAAA5U,IAGA4sC,EAAAx3B,EAAAQ,GAAAf,EAAA/J,EACA+hC,EAAAx3B,EAAAO,GAAAd,EAAA/J,GAGA8iC,EAAAz4B,EAAAo3B,GAAA33B,EAAA/J,EACAgjC,EAAAz4B,EAAAm3B,GAAA13B,EAAA/J,CACA,MAEA,KAAA+L,GAAAyc,EACAqZ,EAAAiB,EAAA9mB,EAAA/mB,GACA6sC,EAAAiB,EAAA/mB,EAAA/mB,EAAA,GACAkY,EAAA3N,KAAAwc,EAAA/mB,KAAA+mB,EAAA/mB,KAAA+mB,EAAA/mB,KAAA+mB,EAAA/mB,KACA,MAEA,KAAA8W,GAAAc,EACAM,EAAA4rB,YACA+J,EAAAjB,EACAkB,EAAAjB,MAKAh2B,EAAAC,IAAAA,CACA,IAAA+F,GAAAhG,CACAjd,GAAAD,QAAAkjB,G9Bw4QM,SAAUjjB,EAAQD,EAASM,G+B3mSjC,QAAAu0C,GAAAh8B,GACA,MAAAA,IAAAoR,GAAApR,EAAAoR,EAGA,QAAAD,GAAAnR,GACA,MAAAA,GAAAoR,GAAApR,GAAAoR,EAcA,QAAA4pB,GAAAvkB,EAAAC,EAAAe,EAAAC,EAAA9C,GACA,GAAAqnB,GAAA,EAAArnB,CACA,OAAAqnB,GAAAA,GAAAA,EAAAxlB,EAAA,EAAA7B,EAAA8B,GAAA9B,EAAAA,GAAAA,EAAA8C,EAAA,EAAAukB,EAAAxkB,GAcA,QAAAykB,GAAAzlB,EAAAC,EAAAe,EAAAC,EAAA9C,GACA,GAAAqnB,GAAA,EAAArnB,CACA,OAAA,MAAA8B,EAAAD,GAAAwlB,EAAA,GAAAxkB,EAAAf,GAAA9B,GAAAqnB,GAAAvkB,EAAAD,GAAA7C,EAAAA,GAeA,QAAAunB,GAAA1lB,EAAAC,EAAAe,EAAAC,EAAA1X,EAAAo8B,GAEA,GAAAppB,GAAA0E,EAAA,GAAAhB,EAAAe,GAAAhB,EACA3C,EAAA,GAAA2D,EAAA,EAAAf,EAAAD,GACAzuB,EAAA,GAAA0uB,EAAAD,GACAlC,EAAAkC,EAAAzW,EACAmF,EAAA2O,EAAAA,EAAA,EAAAd,EAAAhrB,EACAi5B,EAAAnN,EAAA9rB,EAAA,EAAAgrB,EAAAuB,EACAtP,EAAAjd,EAAAA,EAAA,EAAA8rB,EAAAS,EACA3Q,EAAA,CAEA,IAAAo4B,EAAA72B,IAAA62B,EAAA/a,GACA,GAAA+a,EAAAloB,GACAsoB,EAAA,GAAA,MACK,CACL,GAAAC,IAAAr0C,EAAA8rB,CAEAuoB,IAAA,GAAAA,GAAA,IACAD,EAAAx4B,KAAAy4B,OAGG,CACH,GAAAC,GAAArb,EAAAA,EAAA,EAAA9b,EAAAF,CAEA,IAAA+2B,EAAAM,GAAA,CACA,GAAAC,GAAAtb,EAAA9b,EACAk3B,GAAAvoB,EAAAd,EAAAupB,EAEA5kB,GAAA4kB,EAAA,CAEAF,IAAA,GAAAA,GAAA,IACAD,EAAAx4B,KAAAy4B,GAGA1kB,GAAA,GAAAA,GAAA,IACAykB,EAAAx4B,KAAA+T,OAEK,IAAA2kB,EAAA,EAAA,CACL,GAAAE,GAAAx5B,EAAAs5B,GACAG,EAAAt3B,EAAA2O,EAAA,IAAAd,IAAAiO,EAAAub,GACAE,EAAAv3B,EAAA2O,EAAA,IAAAd,IAAAiO,EAAAub,EAGAC,GADAA,EAAA,GACAE,GAAAF,EAAAG,GAEAD,EAAAF,EAAAG,GAIAF,EADAA,EAAA,GACAC,GAAAD,EAAAE,GAEAD,EAAAD,EAAAE,EAGA,IAAAP,KAAAvoB,GAAA2oB,EAAAC,KAAA,EAAA1pB,EAEAqpB,IAAA,GAAAA,GAAA,IACAD,EAAAx4B,KAAAy4B,OAEK,CACL,GAAAQ,IAAA,EAAA13B,EAAA2O,EAAA,EAAAd,EAAAiO,IAAA,EAAAje,EAAAmC,EAAAA,EAAAA,IACA/B,EAAA9M,KAAAmQ,KAAAo2B,GAAA,EACAC,EAAA95B,EAAAmC,GACA43B,EAAAzmC,KAAAiQ,IAAAnD,GACAi5B,IAAAvoB,EAAA,EAAAgpB,EAAAC,IAAA,EAAA/pB,GACA2E,IAAA7D,EAAAgpB,GAAAC,EAAAC,EAAA1mC,KAAAgQ,IAAAlD,MAAA,EAAA4P,GACA4E,IAAA9D,EAAAgpB,GAAAC,EAAAC,EAAA1mC,KAAAgQ,IAAAlD,MAAA,EAAA4P,EAEAqpB,IAAA,GAAAA,GAAA,IACAD,EAAAx4B,KAAAy4B,GAGA1kB,GAAA,GAAAA,GAAA,IACAykB,EAAAx4B,KAAA+T,GAGAC,GAAA,GAAAA,GAAA,IACAwkB,EAAAx4B,KAAAgU,IAKA,MAAAhU,GAcA,QAAAq5B,GAAAxmB,EAAAC,EAAAe,EAAAC,EAAAwlB,GACA,GAAAppB,GAAA,EAAA2D,EAAA,GAAAf,EAAA,EAAAD,EACAzD,EAAA,EAAA0D,EAAA,EAAAgB,EAAA,EAAAjB,EAAA,EAAAgB,EACAzvB,EAAA,EAAA0uB,EAAA,EAAAD,EACA7S,EAAA,CAEA,IAAAo4B,EAAAhpB,IACA,GAAA7B,EAAA2C,GAAA,CACA,GAAAuoB,IAAAr0C,EAAA8rB,CAEAuoB,IAAA,GAAAA,GAAA,IACAa,EAAAt5B,KAAAy4B,QAGG,CACH,GAAAC,GAAAxoB,EAAAA,EAAA,EAAAd,EAAAhrB,CAEA,IAAAg0C,EAAAM,GACAY,EAAA,IAAAppB,GAAA,EAAAd,OACK,IAAAspB,EAAA,EAAA,CACL,GAAAE,GAAAx5B,EAAAs5B,GACAD,IAAAvoB,EAAA0oB,IAAA,EAAAxpB,GACA2E,IAAA7D,EAAA0oB,IAAA,EAAAxpB,EAEAqpB,IAAA,GAAAA,GAAA,IACAa,EAAAt5B,KAAAy4B,GAGA1kB,GAAA,GAAAA,GAAA,IACAulB,EAAAt5B,KAAA+T,IAKA,MAAA/T,GAcA,QAAAu5B,GAAA1mB,EAAAC,EAAAe,EAAAC,EAAA9C,EAAAvC,GACA,GAAA+qB,IAAA1mB,EAAAD,GAAA7B,EAAA6B,EACA4mB,GAAA5lB,EAAAf,GAAA9B,EAAA8B,EACA4mB,GAAA5lB,EAAAD,GAAA7C,EAAA6C,EACA8lB,GAAAF,EAAAD,GAAAxoB,EAAAwoB,EACAI,GAAAF,EAAAD,GAAAzoB,EAAAyoB,EACAI,GAAAD,EAAAD,GAAA3oB,EAAA2oB,CAEAlrB,GAAA,GAAAoE,EACApE,EAAA,GAAA+qB,EACA/qB,EAAA,GAAAkrB,EACAlrB,EAAA,GAAAorB,EAEAprB,EAAA,GAAAorB,EACAprB,EAAA,GAAAmrB,EACAnrB,EAAA,GAAAirB,EACAjrB,EAAA,GAAAqF,EAoBA,QAAAgmB,GAAAtD,EAAAC,EAAA1oC,EAAAC,EAAAC,EAAAC,EAAA4nC,EAAAC,EAAA3oC,EAAAC,EAAAohB,GAEA,GAAAuC,GAGA8X,EACAD,EACAkR,EACAC,EALAC,EAAA,KACAtpB,EAAAupB,EAAAA,CAKAC,GAAA,GAAA/sC,EACA+sC,EAAA,GAAA9sC,CAGA,KAAA,GAAA+sC,GAAA,EAAkBA,EAAA,EAAQA,GAAA,IAC1BC,EAAA,GAAAjD,EAAAZ,EAAAzoC,EAAAE,EAAA6nC,EAAAsE,GACAC,EAAA,GAAAjD,EAAAX,EAAAzoC,EAAAE,EAAA6nC,EAAAqE,GACAL,EAAAO,EAAAH,EAAAE,GAEAN,EAAAppB,IACAK,EAAAopB,EACAzpB,EAAAopB,EAIAppB,GAAAupB,EAAAA,CAEA,KAAA,GAAAtwC,GAAA,EAAiBA,EAAA,MACjBqwC,EAAAM,GADyB3wC,IAKzBk/B,EAAA9X,EAAAipB,EACApR,EAAA7X,EAAAipB,EAEAI,EAAA,GAAAjD,EAAAZ,EAAAzoC,EAAAE,EAAA6nC,EAAAhN,GACAuR,EAAA,GAAAjD,EAAAX,EAAAzoC,EAAAE,EAAA6nC,EAAAjN,GACAiR,EAAAO,EAAAD,EAAAF,GAEArR,GAAA,GAAAiR,EAAAppB,GACAK,EAAA8X,EACAnY,EAAAopB,IAGAS,EAAA,GAAApD,EAAAZ,EAAAzoC,EAAAE,EAAA6nC,EAAAjN,GACA2R,EAAA,GAAApD,EAAAX,EAAAzoC,EAAAE,EAAA6nC,EAAAlN,GACAmR,EAAAM,EAAAE,EAAAL,GAEAtR,GAAA,GAAAmR,EAAArpB,GACAK,EAAA6X,EACAlY,EAAAqpB,GAEAC,GAAA,GAYA,OANAxrB,KACAA,EAAA,GAAA2oB,EAAAZ,EAAAzoC,EAAAE,EAAA6nC,EAAA9kB,GACAvC,EAAA,GAAA2oB,EAAAX,EAAAzoC,EAAAE,EAAA6nC,EAAA/kB,IAIA5R,EAAAuR,GAYA,QAAA8pB,GAAA5nB,EAAAC,EAAAe,EAAA7C,GACA,GAAAqnB,GAAA,EAAArnB,CACA,OAAAqnB,IAAAA,EAAAxlB,EAAA,EAAA7B,EAAA8B,GAAA9B,EAAAA,EAAA6C,EAYA,QAAA6mB,GAAA7nB,EAAAC,EAAAe,EAAA7C,GACA,MAAA,KAAA,EAAAA,IAAA8B,EAAAD,GAAA7B,GAAA6C,EAAAf,IAaA,QAAA6nB,GAAA9nB,EAAAC,EAAAe,EAAAzX,EAAAo8B,GACA,GAAAppB,GAAAyD,EAAA,EAAAC,EAAAe,EACA3D,EAAA,GAAA4C,EAAAD,GACAzuB,EAAAyuB,EAAAzW,EACA4D,EAAA,CAEA,IAAAo4B,EAAAhpB,IACA,GAAA7B,EAAA2C,GAAA,CACA,GAAAuoB,IAAAr0C,EAAA8rB,CAEAuoB,IAAA,GAAAA,GAAA,IACAD,EAAAx4B,KAAAy4B,QAGG,CACH,GAAAC,GAAAxoB,EAAAA,EAAA,EAAAd,EAAAhrB,CAEA,IAAAg0C,EAAAM,GAAA,CACA,GAAAD,IAAAvoB,GAAA,EAAAd,EAEAqpB,IAAA,GAAAA,GAAA,IACAD,EAAAx4B,KAAAy4B,OAEK,IAAAC,EAAA,EAAA,CACL,GAAAE,GAAAx5B,EAAAs5B,GACAD,IAAAvoB,EAAA0oB,IAAA,EAAAxpB,GACA2E,IAAA7D,EAAA0oB,IAAA,EAAAxpB,EAEAqpB,IAAA,GAAAA,GAAA,IACAD,EAAAx4B,KAAAy4B,GAGA1kB,GAAA,GAAAA,GAAA,IACAykB,EAAAx4B,KAAA+T,IAKA,MAAA/T,GAYA,QAAA46B,GAAA/nB,EAAAC,EAAAe,GACA,GAAAgnB,GAAAhoB,EAAAgB,EAAA,EAAAf,CAEA,OAAA,KAAA+nB,EAEA,IAEAhoB,EAAAC,GAAA+nB,EAcA,QAAAC,GAAAjoB,EAAAC,EAAAe,EAAA7C,EAAAvC,GACA,GAAA+qB,IAAA1mB,EAAAD,GAAA7B,EAAA6B,EACA4mB,GAAA5lB,EAAAf,GAAA9B,EAAA8B,EACA6mB,GAAAF,EAAAD,GAAAxoB,EAAAwoB,CAEA/qB,GAAA,GAAAoE,EACApE,EAAA,GAAA+qB,EACA/qB,EAAA,GAAAkrB,EAEAlrB,EAAA,GAAAkrB,EACAlrB,EAAA,GAAAgrB,EACAhrB,EAAA,GAAAoF,EAkBA,QAAAknB,GAAAvE,EAAAC,EAAA1oC,EAAAC,EAAAC,EAAAC,EAAAd,EAAAC,EAAAohB,GAEA,GAAAuC,GACAipB,EAAA,KACAtpB,EAAAupB,EAAAA,CACAC,GAAA,GAAA/sC,EACA+sC,EAAA,GAAA9sC,CAGA,KAAA,GAAA+sC,GAAA,EAAkBA,EAAA,EAAQA,GAAA,IAAA,CAC1BC,EAAA,GAAAI,EAAAjE,EAAAzoC,EAAAE,EAAAmsC,GACAC,EAAA,GAAAI,EAAAhE,EAAAzoC,EAAAE,EAAAksC,EACA,IAAAL,GAAAO,EAAAH,EAAAE,EAEAN,GAAAppB,IACAK,EAAAopB,EACAzpB,EAAAopB,GAIAppB,EAAAupB,EAAAA,CAEA,KAAA,GAAAtwC,GAAA,EAAiBA,EAAA,MACjBqwC,EAAAM,GADyB3wC,IAAA,CAKzB,GAAAk/B,GAAA9X,EAAAipB,EACApR,EAAA7X,EAAAipB,CAEAI,GAAA,GAAAI,EAAAjE,EAAAzoC,EAAAE,EAAA66B,GACAuR,EAAA,GAAAI,EAAAhE,EAAAzoC,EAAAE,EAAA46B,EACA,IAAAiR,GAAAO,EAAAD,EAAAF,EAEA,IAAArR,GAAA,GAAAiR,EAAAppB,EACAK,EAAA8X,EACAnY,EAAAopB,MACK,CAELS,EAAA,GAAAC,EAAAjE,EAAAzoC,EAAAE,EAAA46B,GACA2R,EAAA,GAAAC,EAAAhE,EAAAzoC,EAAAE,EAAA26B,EACA,IAAAmR,GAAAM,EAAAE,EAAAL,EAEAtR,IAAA,GAAAmR,EAAArpB,GACAK,EAAA6X,EACAlY,EAAAqpB,GAEAC,GAAA,IAYA,MANAxrB,KACAA,EAAA,GAAAgsB,EAAAjE,EAAAzoC,EAAAE,EAAA+iB,GACAvC,EAAA,GAAAgsB,EAAAhE,EAAAzoC,EAAAE,EAAA8iB,IAIA5R,EAAAuR,GArgBA,GAAAqqB,GAAAn3C,EAAA,IAEAo3C,EAAAD,EAAAjtB,OACAusB,EAAAU,EAAA7pB,WAOA4nB,EAAArmC,KAAA2nB,IACAjb,EAAA1M,KAAA+P,KACA+K,EAAA,KACA+sB,EAAA,KACAnB,EAAAh6B,EAAA,GACA45B,EAAA,EAAA,EAEAmB,EAAAc,IAEAZ,EAAAY,IAEAT,EAAAS,GAmfA13C,GAAA6zC,QAAAA,EACA7zC,EAAA+0C,kBAAAA,EACA/0C,EAAAg1C,YAAAA,EACAh1C,EAAA81C,aAAAA,EACA91C,EAAAg2C,eAAAA,EACAh2C,EAAAu2C,kBAAAA,EACAv2C,EAAAk3C,YAAAA,EACAl3C,EAAAm3C,sBAAAA,EACAn3C,EAAAo3C,gBAAAA,EACAp3C,EAAAq3C,kBAAAA,EACAr3C,EAAAu3C,mBAAAA,EACAv3C,EAAAw3C,sBAAAA,G/BwoSM,SAAUv3C,EAAQD,EAASM,GgCpoTjC,QAAAq3C,GAAAC,EAAApzB,EAAApS,GACA,GAAA,IAAAwlC,EAAAtxC,OAAA,CAIA,GAKAD,GALAvF,EAAA82C,EAAA,GACA7M,EAAAjqC,EAAA,GACAkqC,EAAAlqC,EAAA,GACAoqC,EAAApqC,EAAA,GACAqqC,EAAArqC,EAAA,EAGA,KAAAuF,EAAA,EAAaA,EAAAuxC,EAAAtxC,OAAmBD,IAChCvF,EAAA82C,EAAAvxC,GACA0kC,EAAA2D,EAAA3D,EAAAjqC,EAAA,IACAkqC,EAAA2D,EAAA3D,EAAAlqC,EAAA,IACAoqC,EAAAwD,EAAAxD,EAAApqC,EAAA,IACAqqC,EAAAwD,EAAAxD,EAAArqC,EAAA,GAGA0jB,GAAA,GAAAumB,EACAvmB,EAAA,GAAA0mB,EACA94B,EAAA,GAAA44B,EACA54B,EAAA,GAAA+4B,GAaA,QAAAiJ,GAAAnB,EAAAC,EAAA1oC,EAAAC,EAAA+Z,EAAApS,GACAoS,EAAA,GAAAkqB,EAAAuE,EAAAzoC,GACAga,EAAA,GAAAkqB,EAAAwE,EAAAzoC,GACA2H,EAAA,GAAAu8B,EAAAsE,EAAAzoC,GACA4H,EAAA,GAAAu8B,EAAAuE,EAAAzoC,GAoBA,QAAA4pC,GAAApB,EAAAC,EAAA1oC,EAAAC,EAAAC,EAAAC,EAAA4nC,EAAAC,EAAAhuB,EAAApS,GACA,GAEA/L,GAFAyvC,EAAA7E,EAAA6E,aACAjC,EAAA5C,EAAA4C,QAEAp3B,EAAAq5B,EAAA7C,EAAAzoC,EAAAE,EAAA6nC,EAAAsF,EAMA,KALArzB,EAAA,GAAAmyB,EAAAA,EACAnyB,EAAA,GAAAmyB,EAAAA,EACAvkC,EAAA,KAAAukC,EAAAA,GACAvkC,EAAA,KAAAukC,EAAAA,GAEAtwC,EAAA,EAAaA,EAAAoW,EAAOpW,IAAA,CACpB,GAAAwD,GAAAgqC,EAAAZ,EAAAzoC,EAAAE,EAAA6nC,EAAAsF,EAAAxxC,GACAme,GAAA,GAAAkqB,EAAA7kC,EAAA2a,EAAA,IACApS,EAAA,GAAAu8B,EAAA9kC,EAAAuI,EAAA,IAKA,IAFAqK,EAAAq5B,EAAA5C,EAAAzoC,EAAAE,EAAA6nC,EAAAsF,GAEAzxC,EAAA,EAAaA,EAAAoW,EAAOpW,IAAA,CACpB,GAAAyD,GAAA+pC,EAAAX,EAAAzoC,EAAAE,EAAA6nC,EAAAsF,EAAAzxC,GACAme,GAAA,GAAAkqB,EAAA5kC,EAAA0a,EAAA,IACApS,EAAA,GAAAu8B,EAAA7kC,EAAAsI,EAAA,IAGAoS,EAAA,GAAAkqB,EAAAuE,EAAAzuB,EAAA,IACApS,EAAA,GAAAu8B,EAAAsE,EAAA7gC,EAAA,IACAoS,EAAA,GAAAkqB,EAAA6D,EAAA/tB,EAAA,IACApS,EAAA,GAAAu8B,EAAA4D,EAAAngC,EAAA,IACAoS,EAAA,GAAAkqB,EAAAwE,EAAA1uB,EAAA,IACApS,EAAA,GAAAu8B,EAAAuE,EAAA9gC,EAAA,IACAoS,EAAA,GAAAkqB,EAAA8D,EAAAhuB,EAAA,IACApS,EAAA,GAAAu8B,EAAA6D,EAAApgC,EAAA,IAgBA,QAAAkiC,GAAArB,EAAAC,EAAA1oC,EAAAC,EAAAC,EAAAC,EAAA6Z,EAAApS,GACA,GAAAilC,GAAApG,EAAAoG,kBACAH,EAAAjG,EAAAiG,YAEAa,EAAApJ,EAAAD,EAAA2I,EAAApE,EAAAzoC,EAAAE,GAAA,GAAA,GACAstC,EAAArJ,EAAAD,EAAA2I,EAAAnE,EAAAzoC,EAAAE,GAAA,GAAA,GACAd,EAAAqtC,EAAAjE,EAAAzoC,EAAAE,EAAAqtC,GACAjuC,EAAAotC,EAAAhE,EAAAzoC,EAAAE,EAAAqtC,EACAxzB,GAAA,GAAAkqB,EAAAuE,EAAAvoC,EAAAb,GACA2a,EAAA,GAAAkqB,EAAAwE,EAAAvoC,EAAAb,GACAsI,EAAA,GAAAu8B,EAAAsE,EAAAvoC,EAAAb,GACAuI,EAAA,GAAAu8B,EAAAuE,EAAAvoC,EAAAb,GAkBA,QAAAyqC,GAAA1qC,EAAAC,EAAAoR,EAAAC,EAAAy3B,EAAAC,EAAAC,EAAAtuB,EAAApS,GACA,GAAA6lC,GAAAzJ,EAAAhqB,IACA0zB,EAAA1J,EAAAp8B,IACA+lC,EAAAhpC,KAAAoF,IAAAq+B,EAAAC,EAEA,IAAAsF,EAAAC,EAAA,MAAAD,EAAA,KAMA,MAJA3zB,GAAA,GAAA3a,EAAAqR,EACAsJ,EAAA,GAAA1a,EAAAqR,EACA/I,EAAA,GAAAvI,EAAAqR,OACA9I,EAAA,GAAAtI,EAAAqR,EA6BA,IAzBA4T,EAAA,GAAAtT,EAAAm3B,GAAA13B,EAAArR,EACAklB,EAAA,GAAArT,EAAAk3B,GAAAz3B,EAAArR,EACAuuC,EAAA,GAAA58B,EAAAo3B,GAAA33B,EAAArR,EACAwuC,EAAA,GAAA38B,EAAAm3B,GAAA13B,EAAArR,EACAmuC,EAAAzzB,EAAAuK,EAAAspB,GACAH,EAAA9lC,EAAA2c,EAAAspB,GAEAzF,GAAAwF,EAEAxF,EAAA,IACAA,GAAAwF,GAGAvF,GAAAuF,EAEAvF,EAAA,IACAA,GAAAuF,GAGAxF,EAAAC,IAAAC,EACAD,GAAAuF,EACGxF,EAAAC,GAAAC,IACHF,GAAAwF,GAGAtF,EAAA,CACA,GAAA8C,GAAA/C,CACAA,GAAAD,EACAA,EAAAgD,EAKA,IAAA,GAAA0C,GAAA,EAAqBA,EAAAzF,EAAkByF,GAAAnpC,KAAAoM,GAAA,EACvC+8B,EAAA1F,IACA2F,EAAA,GAAA98B,EAAA68B,GAAAp9B,EAAArR,EACA0uC,EAAA,GAAA78B,EAAA48B,GAAAn9B,EAAArR,EACAmuC,EAAAzzB,EAAA+zB,EAAA/zB,GACA0zB,EAAA9lC,EAAAmmC,EAAAnmC,IAnNA,GAAAo8B,GAAAluC,EAAA,IAEA2wC,EAAA3wC,EAAA,IAKAouC,EAAAv/B,KAAAqV,IACAmqB,EAAAx/B,KAAAiD,IACAsJ,EAAAvM,KAAAgQ,IACA1D,EAAAtM,KAAAiQ,IACAg5B,EAAA,EAAAjpC,KAAAoM,GACAwT,EAAAyf,EAAAhkB,SACA6tB,EAAA7J,EAAAhkB,SACA+tB,EAAA/J,EAAAhkB,SAoDAqtB,KACAC,IAqJA93C,GAAA23C,WAAAA,EACA33C,EAAAo0C,SAAAA,EACAp0C,EAAAq0C,UAAAA,EACAr0C,EAAAs0C,cAAAA,EACAt0C,EAAAu0C,QAAAA,GhCiqTM,SAAUt0C,EAAQD,EAASM,GiCv2TjC,QAAAk4C,GAAA3sB,EAAAc,GACA,MAAAxd,MAAAoF,IAAAsX,EAAAc,GAAA1C,EAOA,QAAAwuB,KACA,GAAA7C,GAAAG,EAAA,EACAA,GAAA,GAAAA,EAAA,GACAA,EAAA,GAAAH,EAGA,QAAA8C,GAAAzF,EAAAC,EAAA1oC,EAAAC,EAAAC,EAAAC,EAAA4nC,EAAAC,EAAA3oC,EAAAC,GAEA,GAAAA,EAAAopC,GAAAppC,EAAAW,GAAAX,EAAAa,GAAAb,EAAA0oC,GAAA1oC,EAAAopC,GAAAppC,EAAAW,GAAAX,EAAAa,GAAAb,EAAA0oC,EACA,MAAA,EAGA,IAAAmG,GAAA1H,EAAA+D,YAAA9B,EAAAzoC,EAAAE,EAAA6nC,EAAA1oC,EAAAmrC,EAEA,IAAA,IAAA0D,EACA,MAAA,EAMA,KAAA,GAFAC,GAAAC,EAFAh3B,EAAA,EACAi3B,KAGAzyC,EAAA,EAAmBA,EAAAsyC,EAAYtyC,IAAA,CAC/B,GAAAonB,GAAAwnB,EAAA5uC,GAEA0yC,EAAA,IAAAtrB,GAAA,IAAAA,EAAA,GAAA,EACAurB,EAAA/H,EAAA4C,QAAAZ,EAAAzoC,EAAAE,EAAA6nC,EAAA9kB,EAEAurB,GAAAnvC,IAKAivC,EAAA,IACAA,EAAA7H,EAAA6E,aAAA5C,EAAAzoC,EAAAE,EAAA6nC,EAAAuD,GAEAA,EAAA,GAAAA,EAAA,IAAA+C,EAAA,GACAL,IAGAG,EAAA3H,EAAA4C,QAAAX,EAAAzoC,EAAAE,EAAA6nC,EAAAuD,EAAA,IAEA+C,EAAA,IACAD,EAAA5H,EAAA4C,QAAAX,EAAAzoC,EAAAE,EAAA6nC,EAAAuD,EAAA,MAOAl0B,GAHA,GAAAi3B,EAEArrB,EAAAsoB,EAAA,GACA6C,EAAA1F,EAAA6F,GAAAA,EACStrB,EAAAsoB,EAAA,GACT8C,EAAAD,EAAAG,GAAAA,EAEAvG,EAAAqG,EAAAE,GAAAA,EAIAtrB,EAAAsoB,EAAA,GACA6C,EAAA1F,EAAA6F,GAAAA,EAEAvG,EAAAoG,EAAAG,GAAAA,GAKA,MAAAl3B,GAIA,QAAAo3B,GAAAhG,EAAAC,EAAA1oC,EAAAC,EAAAC,EAAAC,EAAAd,EAAAC,GAEA,GAAAA,EAAAopC,GAAAppC,EAAAW,GAAAX,EAAAa,GAAAb,EAAAopC,GAAAppC,EAAAW,GAAAX,EAAAa,EACA,MAAA,EAGA,IAAAguC,GAAA1H,EAAAmG,gBAAAlE,EAAAzoC,EAAAE,EAAAb,EAAAmrC,EAEA,IAAA,IAAA0D,EACA,MAAA,EAEA,IAAAlrB,GAAAwjB,EAAAoG,kBAAAnE,EAAAzoC,EAAAE,EAEA,IAAA8iB,GAAA,GAAAA,GAAA,EAAA,CAIA,IAAA,GAHA5L,GAAA,EACAq3B,EAAAjI,EAAAiG,YAAAhE,EAAAzoC,EAAAE,EAAA8iB,GAEApnB,EAAA,EAAqBA,EAAAsyC,EAAYtyC,IAAA,CAEjC,GAAA0yC,GAAA,IAAA9D,EAAA5uC,IAAA,IAAA4uC,EAAA5uC,GAAA,GAAA,EACA2yC,EAAA/H,EAAAiG,YAAAjE,EAAAzoC,EAAAE,EAAAuqC,EAAA5uC,GAEA2yC,GAAAnvC,IAMAgY,GADAozB,EAAA5uC,GAAAonB,EACAyrB,EAAAhG,EAAA6F,GAAAA,EAEApuC,EAAAuuC,EAAAH,GAAAA,GAIA,MAAAl3B,GAGA,GAAAk3B,GAAA,IAAA9D,EAAA,IAAA,IAAAA,EAAA,GAAA,GAAA,EACA+D,EAAA/H,EAAAiG,YAAAjE,EAAAzoC,EAAAE,EAAAuqC,EAAA,GAEA,OAAA+D,GAAAnvC,EAEA,EAGAc,EAAAuoC,EAAA6F,GAAAA,EAOA,QAAAI,GAAAhoC,EAAAC,EAAAqT,EAAAmuB,EAAAC,EAAAC,EAAAjpC,EAAAC,GAGA,GAFAA,GAAAsH,EAEAtH,EAAA2a,GAAA3a,GAAA2a,EACA,MAAA,EAGA,IAAAmxB,GAAAzmC,KAAA+P,KAAAuF,EAAAA,EAAA3a,EAAAA,EACAmrC,GAAA,IAAAW,EACAX,EAAA,GAAAW,CACA,IAAAuC,GAAAhpC,KAAAoF,IAAAq+B,EAAAC,EAEA,IAAAsF,EAAA,KACA,MAAA,EAGA,IAAAA,EAAAC,EAAA,KAAA,CAEAxF,EAAA,EACAC,EAAAuF,CACA,IAAAgB,GAAAtG,EAAA,IAEA,OAAAjpC,IAAAorC,EAAA,GAAA9jC,GAAAtH,GAAAorC,EAAA,GAAA9jC,EACAioC,EAEA,EAIA,GAAAtG,EAAA,CACA,GAAA8C,GAAAhD,CACAA,GAAAyG,EAAAxG,GACAA,EAAAwG,EAAAzD,OAEAhD,GAAAyG,EAAAzG,GACAC,EAAAwG,EAAAxG,EAGAD,GAAAC,IACAA,GAAAuF,EAKA,KAAA,GAFAv2B,GAAA,EAEAxb,EAAA,EAAiBA,EAAA,EAAOA,IAAA,CACxB,GAAA2yC,GAAA/D,EAAA5uC,EAEA,IAAA2yC,EAAA7nC,EAAAtH,EAAA,CACA,GAAAyuC,GAAAnpC,KAAA2b,MAAAhhB,EAAAkvC,GACAI,EAAAtG,EAAA,IAEAwF,GAAA,IACAA,EAAAF,EAAAE,IAGAA,GAAA1F,GAAA0F,GAAAzF,GAAAyF,EAAAF,GAAAxF,GAAA0F,EAAAF,GAAAvF,KACAyF,EAAAnpC,KAAAoM,GAAA,GAAA+8B,EAAA,IAAAnpC,KAAAoM,KACA69B,GAAAA,GAGAv3B,GAAAu3B,IAKA,MAAAv3B,GAGA,QAAAy3B,GAAA1iC,EAAA9E,EAAAynC,EAAA1vC,EAAAC,GAOA,IAAA,GANA+X,GAAA,EACAqyB,EAAA,EACAC,EAAA,EACAlB,EAAA,EACAC,EAAA,EAEA7sC,EAAA,EAAiBA,EAAAuQ,EAAAtQ,QAAiB,CAClC,GAAA+U,GAAAzE,EAAAvQ,IAwBA,QAtBAgV,IAAA8B,EAAAU,GAAAxX,EAAA,IAEAkzC,IACA13B,GAAA23B,EAAAtF,EAAAC,EAAAlB,EAAAC,EAAArpC,EAAAC,KAQA,GAAAzD,IAKA6tC,EAAAt9B,EAAAvQ,GACA8tC,EAAAv9B,EAAAvQ,EAAA,GACA4sC,EAAAiB,EACAhB,EAAAiB,GAGA94B,GACA,IAAA8B,GAAAU,EAGAo1B,EAAAr8B,EAAAvQ,KACA6sC,EAAAt8B,EAAAvQ,KACA6tC,EAAAjB,EACAkB,EAAAjB,CACA,MAEA,KAAA/1B,GAAAS,EACA,GAAA27B,GACA,GAAA/P,EAAApnB,cAAA8xB,EAAAC,EAAAv9B,EAAAvQ,GAAAuQ,EAAAvQ,EAAA,GAAAyL,EAAAjI,EAAAC,GACA,OAAA,MAIA+X,IAAA23B,EAAAtF,EAAAC,EAAAv9B,EAAAvQ,GAAAuQ,EAAAvQ,EAAA,GAAAwD,EAAAC,IAAA,CAGAoqC,GAAAt9B,EAAAvQ,KACA8tC,EAAAv9B,EAAAvQ,IACA,MAEA,KAAA8W,GAAAW,EACA,GAAAy7B,GACA,GAAAE,EAAAr3B,cAAA8xB,EAAAC,EAAAv9B,EAAAvQ,KAAAuQ,EAAAvQ,KAAAuQ,EAAAvQ,KAAAuQ,EAAAvQ,KAAAuQ,EAAAvQ,GAAAuQ,EAAAvQ,EAAA,GAAAyL,EAAAjI,EAAAC,GACA,OAAA,MAGA+X,IAAA62B,EAAAxE,EAAAC,EAAAv9B,EAAAvQ,KAAAuQ,EAAAvQ,KAAAuQ,EAAAvQ,KAAAuQ,EAAAvQ,KAAAuQ,EAAAvQ,GAAAuQ,EAAAvQ,EAAA,GAAAwD,EAAAC,IAAA,CAGAoqC,GAAAt9B,EAAAvQ,KACA8tC,EAAAv9B,EAAAvQ,IACA,MAEA,KAAA8W,GAAAY,EACA,GAAAw7B,GACA,GAAAG,EAAAt3B,cAAA8xB,EAAAC,EAAAv9B,EAAAvQ,KAAAuQ,EAAAvQ,KAAAuQ,EAAAvQ,GAAAuQ,EAAAvQ,EAAA,GAAAyL,EAAAjI,EAAAC,GACA,OAAA,MAGA+X,IAAAo3B,EAAA/E,EAAAC,EAAAv9B,EAAAvQ,KAAAuQ,EAAAvQ,KAAAuQ,EAAAvQ,GAAAuQ,EAAAvQ,EAAA,GAAAwD,EAAAC,IAAA,CAGAoqC,GAAAt9B,EAAAvQ,KACA8tC,EAAAv9B,EAAAvQ,IACA,MAEA,KAAA8W,GAAAa,EAEA,GAAA7M,GAAAyF,EAAAvQ,KACA+K,EAAAwF,EAAAvQ,KACA6U,EAAAtE,EAAAvQ,KACA8U,EAAAvE,EAAAvQ,KACA4V,EAAArF,EAAAvQ,KACAgW,EAAAzF,EAAAvQ,KAGAysC,GADAl8B,EAAAvQ,KACA,EAAAuQ,EAAAvQ,MACAmE,EAAA2E,KAAAiQ,IAAAnD,GAAAf,EAAA/J,EACA1G,EAAA0E,KAAAgQ,IAAAlD,GAAAd,EAAA/J,CAEA/K,GAAA,EACAwb,GAAA23B,EAAAtF,EAAAC,EAAA3pC,EAAAC,EAAAZ,EAAAC,IAGAmpC,EAAAzoC,EACA0oC,EAAAzoC,EAIA,IAAAkvC,IAAA9vC,EAAAsH,GAAAgK,EAAAD,EAAA/J,CAEA,IAAAooC,GACA,GAAA5G,EAAAvwB,cAAAjR,EAAAC,EAAA+J,EAAAc,EAAAA,EAAAI,EAAAy2B,EAAAhhC,EAAA6nC,EAAA7vC,GACA,OAAA,MAGA+X,IAAAs3B,EAAAhoC,EAAAC,EAAA+J,EAAAc,EAAAA,EAAAI,EAAAy2B,EAAA6G,EAAA7vC,EAGAoqC,GAAA/kC,KAAAiQ,IAAAnD,EAAAI,GAAAnB,EAAA/J,EACAgjC,EAAAhlC,KAAAgQ,IAAAlD,EAAAI,GAAAlB,EAAA/J,CACA,MAEA,KAAA+L,GAAAyc,EACAqZ,EAAAiB,EAAAt9B,EAAAvQ,KACA6sC,EAAAiB,EAAAv9B,EAAAvQ,IACA,IAAA4C,GAAA2N,EAAAvQ,KACA6C,EAAA0N,EAAAvQ,KACAmE,EAAAyoC,EAAAhqC,EACAwB,EAAAyoC,EAAAhqC,CAEA,IAAAqwC,GACA,GAAA/P,EAAApnB,cAAA6wB,EAAAC,EAAA1oC,EAAA0oC,EAAAphC,EAAAjI,EAAAC,IAAA0/B,EAAApnB,cAAA5X,EAAA0oC,EAAA1oC,EAAAC,EAAAqH,EAAAjI,EAAAC,IAAA0/B,EAAApnB,cAAA5X,EAAAC,EAAAwoC,EAAAxoC,EAAAqH,EAAAjI,EAAAC,IAAA0/B,EAAApnB,cAAA6wB,EAAAxoC,EAAAwoC,EAAAC,EAAAphC,EAAAjI,EAAAC,GACA,OAAA,MAIA+X,IAAA23B,EAAAhvC,EAAA0oC,EAAA1oC,EAAAC,EAAAZ,EAAAC,GACA+X,GAAA23B,EAAAvG,EAAAxoC,EAAAwoC,EAAAC,EAAArpC,EAAAC,EAGA,MAEA,KAAAqT,GAAAc,EACA,GAAAs7B,GACA,GAAA/P,EAAApnB,cAAA8xB,EAAAC,EAAAlB,EAAAC,EAAAphC,EAAAjI,EAAAC,GACA,OAAA,MAIA+X,IAAA23B,EAAAtF,EAAAC,EAAAlB,EAAAC,EAAArpC,EAAAC,EAOAoqC,GAAAjB,EACAkB,EAAAjB,GASA,MAJAqG,IAAAf,EAAArE,EAAAjB,KACArxB,GAAA23B,EAAAtF,EAAAC,EAAAlB,EAAAC,EAAArpC,EAAAC,IAAA,GAGA,IAAA+X,EAGA,QAAAI,GAAAxR,EAAA5G,EAAAC,GACA,MAAAwvC,GAAA7oC,EAAA,GAAA,EAAA5G,EAAAC,GAGA,QAAAsY,GAAA3R,EAAAqB,EAAAjI,EAAAC,GACA,MAAAwvC,GAAA7oC,EAAAqB,GAAA,EAAAjI,EAAAC,GAtYA,GAAAoT,GAAA5c,EAAA,IAEAkpC,EAAAlpC,EAAA,IAEAm5C,EAAAn5C,EAAA,IAEAo5C,EAAAp5C,EAAA,IAEAqyC,EAAAryC,EAAA,IAEAytB,EAAAztB,EAAA,IAEA+4C,EAAAtrB,EAAAsrB,gBAEApI,EAAA3wC,EAAA,IAEAk5C,EAAAl5C,EAAA,IAEA6c,EAAAD,EAAAC,IACAi7B,EAAA,EAAAjpC,KAAAoM,GACA0O,EAAA,KAOAgrB,aACAc,SA6WA/1C,GAAAiiB,QAAAA,EACAjiB,EAAAoiB,cAAAA,GjCm4TM,SAAUniB,EAAQD,GkClwUxB,QAAAoiB,GAAA6wB,EAAAC,EAAA1oC,EAAAC,EAAAqH,EAAAjI,EAAAC,GACA,GAAA,IAAAgI,EACA,OAAA,CAGA,IAAA8nC,GAAA9nC,EACA+nC,EAAA,EACAC,EAAA7G,CAEA,IAAAnpC,EAAAopC,EAAA0G,GAAA9vC,EAAAW,EAAAmvC,GAAA9vC,EAAAopC,EAAA0G,GAAA9vC,EAAAW,EAAAmvC,GAAA/vC,EAAAopC,EAAA2G,GAAA/vC,EAAAW,EAAAovC,GAAA/vC,EAAAopC,EAAA2G,GAAA/vC,EAAAW,EAAAovC,EACA,OAAA,CAGA,IAAA3G,IAAAzoC,EAIA,MAAA2E,MAAAoF,IAAA1K,EAAAopC,IAAA2G,EAAA,CAHAC,IAAA3G,EAAAzoC,IAAAwoC,EAAAzoC,GACAsvC,GAAA7G,EAAAxoC,EAAAD,EAAA0oC,IAAAD,EAAAzoC,EAKA,IAAAorC,GAAAiE,EAAAhwC,EAAAC,EAAAgwC,EAEAC,EAAAnE,EAAAA,GAAAiE,EAAAA,EAAA,EAEA,OAAAE,IAAAH,EAAA,EAAAA,EAAA,EAGA55C,EAAAoiB,cAAAA,GlCmxUM,SAAUniB,EAAQD,EAASM,GmCxyUjC,QAAA8hB,GAAA6wB,EAAAC,EAAA1oC,EAAAC,EAAAC,EAAAC,EAAA4nC,EAAAC,EAAA1gC,EAAAjI,EAAAC,GACA,GAAA,IAAAgI,EACA,OAAA,CAGA,IAAA8nC,GAAA9nC,CAEA,IAAAhI,EAAAopC,EAAA0G,GAAA9vC,EAAAW,EAAAmvC,GAAA9vC,EAAAa,EAAAivC,GAAA9vC,EAAA0oC,EAAAoH,GAAA9vC,EAAAopC,EAAA0G,GAAA9vC,EAAAW,EAAAmvC,GAAA9vC,EAAAa,EAAAivC,GAAA9vC,EAAA0oC,EAAAoH,GAAA/vC,EAAAopC,EAAA2G,GAAA/vC,EAAAW,EAAAovC,GAAA/vC,EAAAa,EAAAkvC,GAAA/vC,EAAA0oC,EAAAqH,GAAA/vC,EAAAopC,EAAA2G,GAAA/vC,EAAAW,EAAAovC,GAAA/vC,EAAAa,EAAAkvC,GAAA/vC,EAAA0oC,EAAAqH,EACA,OAAA,CAGA,IAAAxsB,GAAA6jB,EAAAsF,kBAAAtD,EAAAC,EAAA1oC,EAAAC,EAAAC,EAAAC,EAAA4nC,EAAAC,EAAA3oC,EAAAC,EAAA,KACA,OAAAsjB,IAAAwsB,EAAA,EA7BA,GAAA3I,GAAA3wC,EAAA,GAgCAN,GAAAoiB,cAAAA,GnC+zUM,SAAUniB,EAAQD,EAASM,GoC90UjC,QAAA8hB,GAAA6wB,EAAAC,EAAA1oC,EAAAC,EAAAC,EAAAC,EAAAmH,EAAAjI,EAAAC,GACA,GAAA,IAAAgI,EACA,OAAA,CAGA,IAAA8nC,GAAA9nC,CAEA,IAAAhI,EAAAopC,EAAA0G,GAAA9vC,EAAAW,EAAAmvC,GAAA9vC,EAAAa,EAAAivC,GAAA9vC,EAAAopC,EAAA0G,GAAA9vC,EAAAW,EAAAmvC,GAAA9vC,EAAAa,EAAAivC,GAAA/vC,EAAAopC,EAAA2G,GAAA/vC,EAAAW,EAAAovC,GAAA/vC,EAAAa,EAAAkvC,GAAA/vC,EAAAopC,EAAA2G,GAAA/vC,EAAAW,EAAAovC,GAAA/vC,EAAAa,EAAAkvC,EACA,OAAA,CAGA,IAAAxsB,GAAAoqB,EAAAvE,EAAAC,EAAA1oC,EAAAC,EAAAC,EAAAC,EAAAd,EAAAC,EAAA,KACA,OAAAsjB,IAAAwsB,EAAA,EA7BA,GAAAI,GAAA15C,EAAA,IAEAk3C,EAAAwC,EAAAxC,qBA8BAx3C,GAAAoiB,cAAAA,GpCq2UM,SAAUniB,EAAQD,EAASM,GqCn3UjC,QAAA8hB,GAAAjR,EAAAC,EAAAqT,EAAAmuB,EAAAC,EAAAC,EAAAhhC,EAAAjI,EAAAC,GACA,GAAA,IAAAgI,EACA,OAAA,CAGA,IAAA8nC,GAAA9nC,CACAjI,IAAAsH,EACArH,GAAAsH,CACA,IAAAgc,GAAAje,KAAA+P,KAAArV,EAAAA,EAAAC,EAAAA,EAEA,IAAAsjB,EAAAwsB,EAAAn1B,GAAA2I,EAAAwsB,EAAAn1B,EACA,OAAA,CAGA,IAAAtV,KAAAoF,IAAAq+B,EAAAC,GAAAuF,EAAA,KAEA,OAAA,CAGA,IAAAtF,EAAA,CACA,GAAA8C,GAAAhD,CACAA,GAAAyG,EAAAxG,GACAA,EAAAwG,EAAAzD,OAEAhD,GAAAyG,EAAAzG,GACAC,EAAAwG,EAAAxG,EAGAD,GAAAC,IACAA,GAAAuF,EAGA,IAAAE,GAAAnpC,KAAA2b,MAAAhhB,EAAAD,EAMA,OAJAyuC,GAAA,IACAA,GAAAF,GAGAE,GAAA1F,GAAA0F,GAAAzF,GAAAyF,EAAAF,GAAAxF,GAAA0F,EAAAF,GAAAvF,EAxDA,GAAA9kB,GAAAztB,EAAA,IAEA+4C,EAAAtrB,EAAAsrB,gBACAjB,EAAA,EAAAjpC,KAAAoM,EAwDAvb,GAAAoiB,cAAAA,GrC24UM,SAAUniB,EAAQD,GsCp8UxB,QAAAq5C,GAAAf,GAOA,MANAA,IAAAF,EAEAE,EAAA,IACAA,GAAAF,GAGAE,EATA,GAAAF,GAAA,EAAAjpC,KAAAoM,EAYAvb,GAAAq5C,gBAAAA,GtC48UM,SAAUp5C,EAAQD,GuCx9UxB,QAAAw5C,GAAAvG,EAAAC,EAAA1oC,EAAAC,EAAAZ,EAAAC,GACA,GAAAA,EAAAopC,GAAAppC,EAAAW,GAAAX,EAAAopC,GAAAppC,EAAAW,EACA,MAAA,EAIA,IAAAA,IAAAyoC,EACA,MAAA,EAGA,IAAAkG,GAAA3uC,EAAAyoC,EAAA,KACAzlB,GAAA3jB,EAAAopC,IAAAzoC,EAAAyoC,EAEA,KAAAzlB,GAAA,IAAAA,IACA2rB,EAAA3uC,EAAAyoC,EAAA,OAGA,IAAA8F,GAAAvrB,GAAAjjB,EAAAyoC,GAAAA,CACA,OAAA+F,GAAAnvC,EAAAuvC,EAAA,EAGAn5C,EAAAD,QAAAw5C,GvC89UM,SAAUv5C,EAAQD,GwCn/UxB,GAAAyf,GAAA,SAAA1V,EAAAkwC,GAGA75C,KAAA2J,MAAAA,EACA3J,KAAA65C,OAAAA,EAEA75C,KAAAmF,KAAA,UAGAka,GAAAhc,UAAAic,iBAAA,SAAAnB,GACA,MAAAA,GAAA27B,cAAA95C,KAAA2J,MAAA3J,KAAA65C,QAAA,UAGA,IAAA/2B,GAAAzD,CACAxf,GAAAD,QAAAkjB,GxCy/UM,SAAUjjB,EAAQD,EAASM,GyC7/UjC,QAAA4iB,GAAApS,EAAAlQ,GACA,GACAya,GACA8+B,EACA9zC,EACA8B,EACA0tB,EACA/0B,EANA8V,EAAA9F,EAAA8F,KAOAiH,EAAAV,EAAAU,EACAC,EAAAX,EAAAW,EACAF,EAAAT,EAAAS,EACAgc,EAAAzc,EAAAyc,EACA5b,EAAAb,EAAAa,EACAD,EAAAZ,EAAAY,CAEA,KAAA1X,EAAA,EAAA8B,EAAA,EAAoB9B,EAAAuQ,EAAAtQ,QAAiB,CAKrC,OAJA+U,EAAAzE,EAAAvQ,KACA8B,EAAA9B,EACA8zC,EAAA,EAEA9+B,GACA,IAAAwC,GACAs8B,EAAA,CACA,MAEA,KAAAv8B,GACAu8B,EAAA,CACA,MAEA,KAAAr8B,GACAq8B,EAAA,CACA,MAEA,KAAAp8B,GACAo8B,EAAA,CACA,MAEA,KAAAn8B,GACA,GAAAnU,GAAAjJ,EAAA,GACAkJ,EAAAlJ,EAAA,GACAgqB,EAAA/O,EAAAjb,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACAiqB,EAAAhP,EAAAjb,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACA03C,EAAA8B,GAAAx5C,EAAA,GAAAiqB,EAAAjqB,EAAA,GAAAgqB,EAEAhU,GAAAvQ,IAAAukB,EACAhU,EAAAvQ,MAAAwD,EAEA+M,EAAAvQ,IAAAwkB,EACAjU,EAAAvQ,MAAAyD,EAGA8M,EAAAvQ,MAAAukB,EACAhU,EAAAvQ,MAAAwkB,EAEAjU,EAAAvQ,MAAAiyC,EAEA1hC,EAAAvQ,MAAAiyC,EAEAjyC,GAAA,EACA8B,EAAA9B,CACA,MAEA,KAAAuzB,GAEA94B,EAAA,GAAA8V,EAAAvQ,KACAvF,EAAA,GAAA8V,EAAAvQ,KACAooC,EAAA3tC,EAAAA,EAAAF,GACAgW,EAAAzO,KAAArH,EAAA,GACA8V,EAAAzO,KAAArH,EAAA,GAEAA,EAAA,IAAA8V,EAAAvQ,KACAvF,EAAA,IAAA8V,EAAAvQ,KACAooC,EAAA3tC,EAAAA,EAAAF,GACAgW,EAAAzO,KAAArH,EAAA,GACA8V,EAAAzO,KAAArH,EAAA,GAGA,IAAA+0B,EAAA,EAAeA,EAAAskB,EAAYtkB,IAAA,CAC3B,GAAA/0B,GAAA82C,EAAA/hB,EACA/0B,GAAA,GAAA8V,EAAAvQ,KACAvF,EAAA,GAAA8V,EAAAvQ,KACAooC,EAAA3tC,EAAAA,EAAAF,GAEAgW,EAAAzO,KAAArH,EAAA,GACA8V,EAAAzO,KAAArH,EAAA,KA9FA,GAAAoc,GAAA5c,EAAA,IAEAm3C,EAAAn3C,EAAA,IAEAmuC,EAAAgJ,EAAAjmC,eACA2L,EAAAD,EAAAC,IACAy6B,aACA/7B,EAAA1M,KAAA+P,KACAk7B,EAAAjrC,KAAA2b,KA2FA7qB,GAAAD,QAAAkjB,GzC6gVM,SAAUjjB,EAAQD,G0C7mVxB,GAAAqN,GAAA,SAAA6S,GACA9f,KAAA8f,WAAAA,MAGA7S,GAAA5J,WACA0R,YAAA9H,EACAoa,aAAA,SAAAC,EAAA9U,GACAxS,KAAA8f,WAAAhY,MACAwf,OAAAA,EACA9U,MAAAA,KAIA,IAAAsQ,GAAA7V,CACApN,GAAAD,QAAAkjB,G1CsnVM,SAAUjjB,EAAQD,G2CroVxB,QAAAuP,KACAnP,KAAA8E,GAAA,YAAA9E,KAAAi6C,WAAAj6C,MACAA,KAAA8E,GAAA,YAAA9E,KAAAk6C,MAAAl6C,MACAA,KAAA8E,GAAA,UAAA9E,KAAAm6C,SAAAn6C,MACAA,KAAA8E,GAAA,YAAA9E,KAAAm6C,SAAAn6C,MAgEA,QAAAwR,GAAApN,EAAAJ,GACA,OACAI,OAAAA,EACAg2C,UAAAp2C,GAAAA,EAAAo2C,WA7DAjrC,EAAA9L,WACA0R,YAAA5F,EACA8qC,WAAA,SAAAj2C,GACA,GAAAq2C,GAAAr2C,EAAAI,MAEAi2C,IAAAA,EAAA5vC,YACAzK,KAAAs6C,gBAAAD,EACAA,EAAAh3B,UAAA,EACArjB,KAAAu5C,GAAAv1C,EAAAu2C,QACAv6C,KAAAw6C,GAAAx2C,EAAAy2C,QACAz6C,KAAA06C,kBAAAlpC,EAAA6oC,EAAAr2C,GAAA,YAAAA,EAAAkB,SAGAg1C,MAAA,SAAAl2C,GACA,GAAAq2C,GAAAr6C,KAAAs6C,eAEA,IAAAD,EAAA,CACA,GAAA5wC,GAAAzF,EAAAu2C,QACA7wC,EAAA1F,EAAAy2C,QACA3yB,EAAAre,EAAAzJ,KAAAu5C,GACAxxB,EAAAre,EAAA1J,KAAAw6C,EACAx6C,MAAAu5C,GAAA9vC,EACAzJ,KAAAw6C,GAAA9wC,EACA2wC,EAAAxyB,MAAAC,EAAAC,EAAA/jB,GACAhE,KAAA06C,kBAAAlpC,EAAA6oC,EAAAr2C,GAAA,OAAAA,EAAAkB,MACA,IAAAy1C,GAAA36C,KAAA46C,UAAAnxC,EAAAC,EAAA2wC,GAAAj2C,OACAy2C,EAAA76C,KAAA86C,WACA96C,MAAA86C,YAAAH,EAEAN,IAAAM,IACAE,GAAAF,IAAAE,GACA76C,KAAA06C,kBAAAlpC,EAAAqpC,EAAA72C,GAAA,YAAAA,EAAAkB,OAGAy1C,GAAAA,IAAAE,GACA76C,KAAA06C,kBAAAlpC,EAAAmpC,EAAA32C,GAAA,YAAAA,EAAAkB,UAKAi1C,SAAA,SAAAn2C,GACA,GAAAq2C,GAAAr6C,KAAAs6C,eAEAD,KACAA,EAAAh3B,UAAA,GAGArjB,KAAA06C,kBAAAlpC,EAAA6oC,EAAAr2C,GAAA,UAAAA,EAAAkB,OAEAlF,KAAA86C,aACA96C,KAAA06C,kBAAAlpC,EAAAxR,KAAA86C,YAAA92C,GAAA,OAAAA,EAAAkB,OAGAlF,KAAAs6C,gBAAA,KACAt6C,KAAA86C,YAAA,MAWA,IAAAh4B,GAAA3T,CACAtP,GAAAD,QAAAkjB,G3C6oVM,SAAUjjB,EAAQD,EAASM,G4C3tVjC,GAAA6C,GAAA7C,EAAA,GAEA6iB,EAAA7iB,EAAA,GAEA8P,EAAA9P,EAAA,IA2BAwE,EAAA,SAAA7D,GACAA,EAAAA,MACAkiB,EAAAxiB,KAAAP,KAAAa,EAEA,KAAA,GAAAkL,KAAAlL,GACAA,EAAAsM,eAAApB,KACA/L,KAAA+L,GAAAlL,EAAAkL,GAIA/L,MAAA+6C,aACA/6C,KAAAg7C,UAAA,KACAh7C,KAAAmgB,SAAA,EAGAzb,GAAArB,WACA0R,YAAArQ,EACAu2C,SAAA,EAKA91C,KAAA,QAQAme,QAAA,EAKA43B,SAAA,WACA,MAAAl7C,MAAA+6C,UAAAziC,SAQA6iC,QAAA,SAAA7H,GACA,MAAAtzC,MAAA+6C,UAAAzH,IAQA7rC,YAAA,SAAAC,GAGA,IAAA,GAFAwzC,GAAAl7C,KAAA+6C,UAEA90C,EAAA,EAAmBA,EAAAi1C,EAAAh1C,OAAqBD,IACxC,GAAAi1C,EAAAj1C,GAAAyB,OAAAA,EACA,MAAAwzC,GAAAj1C,IAQAm1C,WAAA,WACA,MAAAp7C,MAAA+6C,UAAA70C,QAOAtB,IAAA,SAAAwD,GAOA,MANAA,IAAAA,IAAApI,MAAAoI,EAAAhC,SAAApG,OACAA,KAAA+6C,UAAAjzC,KAAAM,GAEApI,KAAAq7C,OAAAjzC,IAGApI,MAQAs7C,UAAA,SAAAlzC,EAAAmzC,GACA,GAAAnzC,GAAAA,IAAApI,MAAAoI,EAAAhC,SAAApG,MAAAu7C,GAAAA,EAAAn1C,SAAApG,KAAA,CACA,GAAAk7C,GAAAl7C,KAAA+6C,UACAzH,EAAA4H,EAAAvoC,QAAA4oC,EAEAjI,IAAA,IACA4H,EAAA10C,OAAA8sC,EAAA,EAAAlrC,GAEApI,KAAAq7C,OAAAjzC,IAIA,MAAApI,OAEAq7C,OAAA,SAAAjzC,GACAA,EAAAhC,QACAgC,EAAAhC,OAAAlC,OAAAkE,GAGAA,EAAAhC,OAAApG,IACA,IAAAw7C,GAAAx7C,KAAAg7C,UACAxyB,EAAAxoB,KAAAkiB,IAEAs5B,IAAAA,IAAApzC,EAAA4yC,YACAQ,EAAAC,aAAArzC,GAEAA,YAAA1D,IACA0D,EAAAszC,qBAAAF,IAIAhzB,GAAAA,EAAArG,WAOAje,OAAA,SAAAkE,GACA,GAAAogB,GAAAxoB,KAAAkiB,KACAs5B,EAAAx7C,KAAAg7C,UACAE,EAAAl7C,KAAA+6C,UACAzH,EAAAvwC,EAAA4P,QAAAuoC,EAAA9yC,EAEA,OAAAkrC,GAAA,EACAtzC,MAGAk7C,EAAA10C,OAAA8sC,EAAA,GACAlrC,EAAAhC,OAAA,KAEAo1C,IACAA,EAAAG,eAAAvzC,GAEAA,YAAA1D,IACA0D,EAAAwzC,uBAAAJ,IAIAhzB,GAAAA,EAAArG,UACAniB,OAMA67C,UAAA,WACA,GAEAzzC,GACAnC,EAHAi1C,EAAAl7C,KAAA+6C,UACAS,EAAAx7C,KAAAg7C,SAIA,KAAA/0C,EAAA,EAAeA,EAAAi1C,EAAAh1C,OAAqBD,IACpCmC,EAAA8yC,EAAAj1C,GAEAu1C,IACAA,EAAAG,eAAAvzC,GAEAA,YAAA1D,IACA0D,EAAAwzC,uBAAAJ,IAIApzC,EAAAhC,OAAA,IAIA,OADA80C,GAAAh1C,OAAA,EACAlG,MAQA87C,UAAA,SAAA7zC,EAAAC,GAGA,IAAA,GAFAgzC,GAAAl7C,KAAA+6C,UAEA90C,EAAA,EAAmBA,EAAAi1C,EAAAh1C,OAAqBD,IAAA,CACxC,GAAAmC,GAAA8yC,EAAAj1C,EACAgC,GAAA1H,KAAA2H,EAAAE,EAAAnC,GAGA,MAAAjG,OAQA0N,SAAA,SAAAzF,EAAAC,GACA,IAAA,GAAAjC,GAAA,EAAmBA,EAAAjG,KAAA+6C,UAAA70C,OAA2BD,IAAA,CAC9C,GAAAmC,GAAApI,KAAA+6C,UAAA90C,EACAgC,GAAA1H,KAAA2H,EAAAE,GAEA,UAAAA,EAAAjD,MACAiD,EAAAsF,SAAAzF,EAAAC,GAIA,MAAAlI,OAEA07C,qBAAA,SAAAF,GACA,IAAA,GAAAv1C,GAAA,EAAmBA,EAAAjG,KAAA+6C,UAAA70C,OAA2BD,IAAA,CAC9C,GAAAmC,GAAApI,KAAA+6C,UAAA90C,EACAu1C,GAAAC,aAAArzC,GAEAA,YAAA1D,IACA0D,EAAAszC,qBAAAF,KAIAI,uBAAA,SAAAJ,GACA,IAAA,GAAAv1C,GAAA,EAAmBA,EAAAjG,KAAA+6C,UAAA70C,OAA2BD,IAAA,CAC9C,GAAAmC,GAAApI,KAAA+6C,UAAA90C,EACAu1C,GAAAG,eAAAvzC,GAEAA,YAAA1D,IACA0D,EAAAwzC,uBAAAJ,KAIAl9B,MAAA,WAGA,MAFAte,MAAAmgB,SAAA,EACAngB,KAAAkiB,MAAAliB,KAAAkiB,KAAAC,UACAniB,MAMA6Q,gBAAA,SAAAkrC,GAOA,IAAA,GALAvrC,GAAA,KACA01B,EAAA,GAAAl2B,GAAA,EAAA,EAAA,EAAA,GACAkrC,EAAAa,GAAA/7C,KAAA+6C,UACAiB,KAEA/1C,EAAA,EAAmBA,EAAAi1C,EAAAh1C,OAAqBD,IAAA,CACxC,GAAAmC,GAAA8yC,EAAAj1C,EAEA,KAAAmC,EAAAuf,SAAAvf,EAAA+a,UAAA,CAIA,GAAA84B,GAAA7zC,EAAAyI,kBACAiD,EAAA1L,EAAAwL,kBAAAooC,EAQAloC,IACAoyB,EAAA1kB,KAAAy6B,GACA/V,EAAA90B,eAAA0C,GACAtD,EAAAA,GAAA01B,EAAAj7B,QACAuF,EAAAg+B,MAAAtI,KAEA11B,EAAAA,GAAAyrC,EAAAhxC,QACAuF,EAAAg+B,MAAAyN,KAIA,MAAAzrC,IAAA01B,IAGAnjC,EAAAmO,SAAAxM,EAAAqe,EACA,IAAAD,GAAApe,CACA7E,GAAAD,QAAAkjB,G5CiuVM,SAAUjjB,EAAQD,EAASM,G6C1gWjC,QAAAg8C,GAAAr7C,GACAse,EAAA5e,KAAAP,KAAAa,GAfA,GAAAse,GAAAjf,EAAA,GAEA8P,EAAA9P,EAAA,IAEA6C,EAAA7C,EAAA,GAEA8pC,EAAA9pC,EAAA,GAYAg8C,GAAA74C,WACA0R,YAAAmnC,EACA/2C,KAAA,QACAsa,MAAA,SAAAtB,EAAAuB,GACA,GAAA1Y,GAAAhH,KAAAgH,MACAopC,EAAAppC,EAAA2C,KAEA3C,GAAAC,KAAAkX,EAAAne,KAAA0f,EACA,IAAA/V,GAAA3J,KAAAm8C,OAAAnS,EAAAC,oBAAAmG,EAAApwC,KAAAm8C,OAAAn8C,KAAAA,KAAAiwC,OAEA,IAAAtmC,GAAAqgC,EAAAG,aAAAxgC,GAAA,CAWA,GAAAF,GAAAzC,EAAAyC,GAAA,EACAC,EAAA1C,EAAA0C,GAAA,EACAb,EAAA7B,EAAA6B,MACAC,EAAA9B,EAAA8B,OACAgI,EAAAnH,EAAAd,MAAAc,EAAAb,MAeA,IAbA,MAAAD,GAAA,MAAAC,EAEAD,EAAAC,EAAAgI,EACK,MAAAhI,GAAA,MAAAD,EACLC,EAAAD,EAAAiI,EACK,MAAAjI,GAAA,MAAAC,IACLD,EAAAc,EAAAd,MACAC,EAAAa,EAAAb,QAIA9I,KAAAkgB,aAAA/B,GAEAnX,EAAAo1C,QAAAp1C,EAAAq1C,QAAA,CACA,GAAA7xB,GAAAxjB,EAAAwjB,IAAA,EACAC,EAAAzjB,EAAAyjB,IAAA,CACAtM,GAAAisB,UAAAzgC,EAAA6gB,EAAAC,EAAAzjB,EAAAo1C,OAAAp1C,EAAAq1C,QAAA5yC,EAAAC,EAAAb,EAAAC,OACK,IAAA9B,EAAAwjB,IAAAxjB,EAAAyjB,GAAA,CACL,GAAAD,GAAAxjB,EAAAwjB,GACAC,EAAAzjB,EAAAyjB,GACA2xB,EAAAvzC,EAAA2hB,EACA6xB,EAAAvzC,EAAA2hB,CACAtM,GAAAisB,UAAAzgC,EAAA6gB,EAAAC,EAAA2xB,EAAAC,EAAA5yC,EAAAC,EAAAb,EAAAC,OAEAqV,GAAAisB,UAAAzgC,EAAAF,EAAAC,EAAAb,EAAAC,EAGA9I,MAAAghB,iBAAA7C,GAEA,MAAAnX,EAAAkE,MACAlL,KAAAihB,aAAA9C,EAAAne,KAAA6Q,qBAGAA,gBAAA,WACA,GAAA7J,GAAAhH,KAAAgH,KAMA,OAJAhH,MAAAohB,QACAphB,KAAAohB,MAAA,GAAApR,GAAAhJ,EAAAyC,GAAA,EAAAzC,EAAA0C,GAAA,EAAA1C,EAAA6B,OAAA,EAAA7B,EAAA8B,QAAA,IAGA9I,KAAAohB,QAGAre,EAAAmO,SAAAgrC,EAAA/8B,EACA,IAAA2D,GAAAo5B,CACAr8C,GAAAD,QAAAkjB,G7C8hWM,SAAUjjB,EAAQD,EAASM,G8CxnWjC,GAAAif,GAAAjf,EAAA,GAEA6C,EAAA7C,EAAA,GAEAoP,EAAApP,EAAA,IAEA+lC,EAAA/lC,EAAA,IAQAmP,EAAA,SAAAxO,GAEAse,EAAA5e,KAAAP,KAAAa,GAGAwO,GAAAhM,WACA0R,YAAA1F,EACAlK,KAAA,OACAsa,MAAA,SAAAtB,EAAAuB,GACA,GAAA1Y,GAAAhH,KAAAgH,KAEAhH,MAAAmgB,SAAA8lB,EAAAE,mBAAAn/B,GAAA,GAEAA,EAAA+B,KAAA/B,EAAA4F,OAAA5F,EAAAwd,WAAAxd,EAAAs1C,YAAAt1C,EAAAyd,cAAAzd,EAAA0d,cAAA,IACA,IAAAxZ,GAAAlE,EAAAkE,IAEA,OAAAA,IAAAA,GAAA,IAEAlE,EAAAC,KAAAkX,EAAAne,KAAA0f,GAEAumB,EAAAG,aAAAl7B,EAAAlE,KAIAhH,KAAAkgB,aAAA/B,GACA8nB,EAAAK,WAAAtmC,KAAAme,EAAAjT,EAAAlE,GACAhH,KAAAghB,iBAAA7C,KAEAtN,gBAAA,WACA,GAAA7J,GAAAhH,KAAAgH,KAIA,IAFAhH,KAAAmgB,SAAA8lB,EAAAE,mBAAAn/B,GAAA,IAEAhH,KAAAohB,MAAA,CACA,GAAAlW,GAAAlE,EAAAkE,IACA,OAAAA,EAAAA,GAAA,GAAAA,EAAA,EACA,IAAAsF,GAAAlB,EAAAuB,gBAAA7J,EAAAkE,KAAA,GAAAlE,EAAA2d,KAAA3d,EAAAwe,UAAAxe,EAAAye,kBAAAze,EAAAyf,YAAAzf,EAAA0f,KAIA,IAHAlW,EAAA/G,GAAAzC,EAAAyC,GAAA,EACA+G,EAAA9G,GAAA1C,EAAA0C,GAAA,EAEAu8B,EAAAwC,UAAAzhC,EAAAie,WAAAje,EAAAoe,iBAAA,CACA,GAAA3D,GAAAza,EAAAoe,eACA5U,GAAA/G,GAAAgY,EAAA,EACAjR,EAAA9G,GAAA+X,EAAA,EACAjR,EAAA3H,OAAA4Y,EACAjR,EAAA1H,QAAA2Y,EAGAzhB,KAAAohB,MAAA5Q,EAGA,MAAAxQ,MAAAohB,QAGAre,EAAAmO,SAAA7B,EAAA8P,EACA,IAAA2D,GAAAzT,CACAxP,GAAAD,QAAAkjB,G9C8nWM,SAAUjjB,EAAQD,EAASM,G+CpsWjC,GAAA8O,GAAA9O,EAAA,GAMA4iB,EAAA9T,EAAAmB,QACAhL,KAAA,SACAhB,OACA4M,GAAA,EACAC,GAAA,EACAqT,EAAA,GAEApG,UAAA,SAAAE,EAAAha,EAAAgd,GAGAA,GACAhD,EAAAuyB,OAAAvsC,EAAA4M,GAAA5M,EAAAkgB,EAAAlgB,EAAA6M,IAUAmN,EAAAo0B,IAAApuC,EAAA4M,GAAA5M,EAAA6M,GAAA7M,EAAAkgB,EAAA,EAAA,EAAAtV,KAAAoM,IAAA,KAIAtb,GAAAD,QAAAkjB,G/C0sWM,SAAUjjB,EAAQD,EAASM,GgDzuWjC,GAAA8O,GAAA9O,EAAA,GAEAq8C,EAAAr8C,EAAA,IAMA4iB,EAAA9T,EAAAmB,QACAhL,KAAA,SACAhB,OACA4M,GAAA,EACAC,GAAA,EACAwrC,GAAA,EACAn4B,EAAA,EACAmuB,WAAA,EACAC,SAAA,EAAA1jC,KAAAoM,GACAshC,WAAA,GAEAh9B,MAAA88B,EAAAvtC,EAAA3L,UAAAoc,OACAxB,UAAA,SAAAE,EAAAha,GACA,GAAAsF,GAAAtF,EAAA4M,GACArH,EAAAvF,EAAA6M,GACAwrC,EAAAztC,KAAAiD,IAAA7N,EAAAq4C,IAAA,EAAA,GACAn4B,EAAAtV,KAAAiD,IAAA7N,EAAAkgB,EAAA,GACAmuB,EAAAruC,EAAAquC,WACAC,EAAAtuC,EAAAsuC,SACAgK,EAAAt4C,EAAAs4C,UACAC,EAAA3tC,KAAAiQ,IAAAwzB,GACAmK,EAAA5tC,KAAAgQ,IAAAyzB,EACAr0B,GAAAuyB,OAAAgM,EAAAF,EAAA/yC,EAAAkzC,EAAAH,EAAA9yC,GACAyU,EAAAwyB,OAAA+L,EAAAr4B,EAAA5a,EAAAkzC,EAAAt4B,EAAA3a,GACAyU,EAAAo0B,IAAA9oC,EAAAC,EAAA2a,EAAAmuB,EAAAC,GAAAgK,GACAt+B,EAAAwyB,OAAA5hC,KAAAiQ,IAAAyzB,GAAA+J,EAAA/yC,EAAAsF,KAAAgQ,IAAA0zB,GAAA+J,EAAA9yC,GAEA,IAAA8yC,GACAr+B,EAAAo0B,IAAA9oC,EAAAC,EAAA8yC,EAAA/J,EAAAD,EAAAiK,GAGAt+B,EAAA4rB,cAIAlqC,GAAAD,QAAAkjB,GhD+uWM,SAAUjjB,EAAQD,EAASM,GiDxwWjC,QAAA4iB,GAAA85B,GAEA,MAAAC,GAAAC,QAAAC,IAAAF,EAAAC,QAAArxC,SAAA,GAAA,WACA,GAEAuxC,GAFAC,EAAAj9C,KAAAijB,YACAjc,EAAAhH,KAAAgH,KAGA,IAAAi2C,EACA,IAAA,GAAAh3C,GAAA,EAAqBA,EAAAg3C,EAAA/2C,OAAsBD,IAAA,CAC3C,GAAA2hB,GAAAq1B,EAAAh3C,GACA9B,EAAAyjB,GAAAA,EAAAzjB,MACAgB,EAAAyiB,GAAAA,EAAAziB,IAEA,IAAAhB,IAAA,WAAAgB,GAAAhB,EAAAquC,aAAAruC,EAAAsuC,UAAA,SAAAttC,KAAAhB,EAAA0E,QAAA1E,EAAA2E,SAAA,CACA,IAAA,GAAAf,GAAA,EAAyBA,EAAAm1C,EAAAh3C,OAAuB6B,IAGhDm1C,EAAAn1C,GAAA,GAAAf,EAAAk2C,EAAAn1C,GAAA,IACAf,EAAAk2C,EAAAn1C,GAAA,IAAAm1C,EAAAn1C,GAAA,EAGAi1C,IAAA,CACA,QAOA,GAFAJ,EAAAplC,MAAAxX,KAAAuX,WAEAylC,EACA,IAAA,GAAAj1C,GAAA,EAAqBA,EAAAm1C,EAAAh3C,OAAuB6B,IAC5Cf,EAAAk2C,EAAAn1C,GAAA,IAAAm1C,EAAAn1C,GAAA,IAGG60C,EApDH,GAAAC,GAAA38C,EAAA,IAgBAg9C,IAAA,aAAA,IAAA,cAAA,SAAA,gBAAA,IAAA,gBAAA,GAuCAr9C,GAAAD,QAAAkjB,GjDgyWM,SAAUjjB,EAAQD,GkD5zWxB,QAAAu9C,GAAAC,GACA,GAAAC,MACAP,KAeAQ,EAAAF,EAAAG,MAAA,qBAGAR,EAAAK,EAAAG,MAAA,mBACAH,EAAAG,MAAA,6BACAC,EAAAJ,EAAAG,MAAA,kBAEAE,EAAA,kBAAAC,KAAAN,EAiDA,OA5BAE,KACAR,EAAAQ,SAAA,EACAR,EAAArxC,QAAA6xC,EAAA,IAKAP,IACAD,EAAAC,IAAA,EACAD,EAAArxC,QAAAsxC,EAAA,IAGAS,IACAV,EAAAU,MAAA,EACAV,EAAArxC,QAAA+xC,EAAA,IAKAC,IACAX,EAAAW,QAAA,IASAX,QAAAA,EACAO,GAAAA,EACA71C,MAAA,EAGAm2C,kBAAAn1C,SAAAC,cAAA,UAAAC,WACAk1C,aAAA,mBAAAC,SAKAC,qBAAA,gBAAA9X,UAAA8W,EAAAC,KAAAD,EAAAU,KAEAO,uBAAA,iBAAA/X,UAIA8W,EAAAU,MAAAV,EAAAC,IAAAD,EAAArxC,SAAA,KA/GA,GAAAoxC,KAIAA,GAFA,mBAAAmB,YAGAlB,WACAO,MACA71C,MAAA,EAEAm2C,iBAAA,EACAC,cAAA,GAGAT,EAAAa,UAAAC,UAGA,IAAAn7B,GAAA+5B,CAmGAh9C,GAAAD,QAAAkjB,GlD61WM,SAAUjjB,EAAQD,EAASM,GmDv9WjC,GAAA8O,GAAA9O,EAAA,GAMA4iB,EAAA9T,EAAAmB,QACAhL,KAAA,OACAhB,OACA4M,GAAA,EACAC,GAAA,EACAqT,EAAA,EACAm4B,GAAA,GAEAv+B,UAAA,SAAAE,EAAAha,GACA,GAAAsF,GAAAtF,EAAA4M,GACArH,EAAAvF,EAAA6M,GACAgnC,EAAA,EAAAjpC,KAAAoM,EACAgD,GAAAuyB,OAAAjnC,EAAAtF,EAAAkgB,EAAA3a,GACAyU,EAAAo0B,IAAA9oC,EAAAC,EAAAvF,EAAAkgB,EAAA,EAAA2zB,GAAA,GACA75B,EAAAuyB,OAAAjnC,EAAAtF,EAAAq4C,GAAA9yC,GACAyU,EAAAo0B,IAAA9oC,EAAAC,EAAAvF,EAAAq4C,GAAA,EAAAxE,GAAA,KAIAn4C,GAAAD,QAAAkjB,GnD69WM,SAAUjjB,EAAQD,EAASM,GoDt/WjC,GAAA8O,GAAA9O,EAAA,GAEAg+C,EAAAh+C,EAAA,IAMA4iB,EAAA9T,EAAAmB,QACAhL,KAAA,UACAhB,OACAqzC,OAAA,KACA2G,QAAA,EACAC,iBAAA,MAEAngC,UAAA,SAAAE,EAAAha,GACA+5C,EAAAjgC,UAAAE,EAAAha,GAAA,KAIAtE,GAAAD,QAAAkjB,GpD4/WM,SAAUjjB,EAAQD,EAASM,GqD5gXjC,QAAA+d,GAAAE,EAAAha,EAAA4lC,GACA,GAAAyN,GAAArzC,EAAAqzC,OACA2G,EAAAh6C,EAAAg6C,MAEA,IAAA3G,GAAAA,EAAAtxC,QAAA,EAAA,CACA,GAAAi4C,GAAA,WAAAA,EAAA,CACA,GAAAE,GAAAC,EAAA9G,EAAA2G,EAAApU,EAAA5lC,EAAAi6C,iBACAjgC,GAAAuyB,OAAA8G,EAAA,GAAA,GAAAA,EAAA,GAAA,GAGA,KAAA,GAFA5iC,GAAA4iC,EAAAtxC,OAEAD,EAAA,EAAqBA,GAAA8jC,EAAAn1B,EAAAA,EAAA,GAAiC3O,IAAA,CACtD,GAAAs4C,GAAAF,EAAA,EAAAp4C,GACAu4C,EAAAH,EAAA,EAAAp4C,EAAA,GACAvF,EAAA82C,GAAAvxC,EAAA,GAAA2O,EACAuJ,GAAA+zB,cAAAqM,EAAA,GAAAA,EAAA,GAAAC,EAAA,GAAAA,EAAA,GAAA99C,EAAA,GAAAA,EAAA,SAEK,CACL,WAAAy9C,IACA3G,EAAAiH,EAAAjH,EAAAzN,IAGA5rB,EAAAuyB,OAAA8G,EAAA,GAAA,GAAAA,EAAA,GAAA,GAEA,KAAA,GAAAvxC,GAAA,EAAAwjB,EAAA+tB,EAAAtxC,OAAwCD,EAAAwjB,EAAOxjB,IAC/CkY,EAAAwyB,OAAA6G,EAAAvxC,GAAA,GAAAuxC,EAAAvxC,GAAA,IAIA8jC,GAAA5rB,EAAA4rB,aAhCA,GAAA0U,GAAAv+C,EAAA,IAEAo+C,EAAAp+C,EAAA,GAkCAN,GAAAqe,UAAAA,GrDshXM,SAAUpe,EAAQD,EAASM,GsD3iXjC,QAAAw+C,GAAAxvB,EAAAC,EAAAe,EAAAC,EAAA9C,EAAA+C,EAAAC,GACA,GAAAE,GAAA,IAAAL,EAAAhB,GACA1C,EAAA,IAAA2D,EAAAhB,EACA,QAAA,GAAAA,EAAAe,GAAAK,EAAA/D,GAAA6D,OAAAlB,EAAAe,GAAA,EAAAK,EAAA/D,GAAA4D,EAAAG,EAAAlD,EAAA8B,EAUA,QAAArM,GAAA00B,EAAAmH,GAKA,IAAA,GAJA/pC,GAAA4iC,EAAAtxC,OACAuqB,KACAxD,EAAA,EAEAhnB,EAAA,EAAiBA,EAAA2O,EAAS3O,IAC1BgnB,GAAA2xB,EAAApH,EAAAvxC,EAAA,GAAAuxC,EAAAvxC,GAGA,IAAA44C,GAAA5xB,EAAA,CACA4xB,GAAAA,EAAAjqC,EAAAA,EAAAiqC,CAEA,KAAA,GAAA54C,GAAA,EAAiBA,EAAA44C,EAAU54C,IAAA,CAC3B,GAGAipB,GAEAgB,EACAC,EANA2uB,EAAA74C,GAAA44C,EAAA,IAAAF,EAAA/pC,EAAAA,EAAA,GACA0+B,EAAAvkC,KAAA6hB,MAAAkuB,GACAr9B,EAAAq9B,EAAAxL,EAEAnkB,EAAAqoB,EAAAlE,EAAA1+B,EAIA+pC,IAKAzvB,EAAAsoB,GAAAlE,EAAA,EAAA1+B,GAAAA,GACAsb,EAAAsnB,GAAAlE,EAAA,GAAA1+B,GACAub,EAAAqnB,GAAAlE,EAAA,GAAA1+B,KANAsa,EAAAsoB,EAAA,IAAAlE,EAAAA,EAAAA,EAAA,GACApjB,EAAAsnB,EAAAlE,EAAA1+B,EAAA,EAAAA,EAAA,EAAA0+B,EAAA,GACAnjB,EAAAqnB,EAAAlE,EAAA1+B,EAAA,EAAAA,EAAA,EAAA0+B,EAAA,GAOA,IAAAyL,GAAAt9B,EAAAA,EACAu9B,EAAAv9B,EAAAs9B,CACAtuB,GAAA3oB,MAAA42C,EAAAxvB,EAAA,GAAAC,EAAA,GAAAe,EAAA,GAAAC,EAAA,GAAA1O,EAAAs9B,EAAAC,GAAAN,EAAAxvB,EAAA,GAAAC,EAAA,GAAAe,EAAA,GAAAC,EAAA,GAAA1O,EAAAs9B,EAAAC,KAGA,MAAAvuB,GAhEA,GAAA4mB,GAAAn3C,EAAA,IAEA0+C,EAAAvH,EAAApqB,QAiEAptB,GAAAD,QAAAkjB,GtDgkXM,SAAUjjB,EAAQD,EAASM,GuDtmXjC,QAAA4iB,GAAA00B,EAAA2G,EAAAQ,EAAAM,GACA,GAIAC,GACAC,EACA/6B,EAAApS,EANAotC,KACApjC,KACAwQ,KACA7B,IAKA,IAAAs0B,EAAA,CACA76B,GAAAmyB,EAAAA,EAAAA,EAAAA,GACAvkC,KAAAukC,EAAAA,KAAAA,EAAAA,GAEA,KAAA,GAAAtwC,GAAA,EAAA2O,EAAA4iC,EAAAtxC,OAAwCD,EAAA2O,EAAS3O,IACjDo5C,EAAAj7B,EAAAA,EAAAozB,EAAAvxC,IACAq5C,EAAAttC,EAAAA,EAAAwlC,EAAAvxC,GAIAo5C,GAAAj7B,EAAAA,EAAA66B,EAAA,IACAK,EAAAttC,EAAAA,EAAAitC,EAAA,IAGA,IAAA,GAAAh5C,GAAA,EAAA2O,EAAA4iC,EAAAtxC,OAAsCD,EAAA2O,EAAS3O,IAAA,CAC/C,GAAAs5C,GAAA/H,EAAAvxC,EAEA,IAAA04C,EACAO,EAAA1H,EAAAvxC,EAAAA,EAAA,EAAA2O,EAAA,GACAuqC,EAAA3H,GAAAvxC,EAAA,GAAA2O,OACK,CACL,GAAA,IAAA3O,GAAAA,IAAA2O,EAAA,EAAA,CACAwqC,EAAAt3C,KAAA03C,EAAAhI,EAAAvxC,IACA,UAEAi5C,EAAA1H,EAAAvxC,EAAA,GACAk5C,EAAA3H,EAAAvxC,EAAA,GAIAw5C,EAAAzjC,EAAAmjC,EAAAD,GAEAQ,EAAA1jC,EAAAA,EAAAmiC,EACA,IAAAwB,GAAAf,EAAAW,EAAAL,GACA9I,EAAAwI,EAAAW,EAAAJ,GACAS,EAAAD,EAAAvJ,CAEA,KAAAwJ,IACAD,GAAAC,EACAxJ,GAAAwJ,GAGAF,EAAAlzB,EAAAxQ,GAAA2jC,GACAD,EAAA/0B,EAAA3O,EAAAo6B,EACA,IAAAyJ,GAAAC,KAAAP,EAAA/yB,GACA+xB,EAAAuB,KAAAP,EAAA50B,EAEAs0B,KACAK,EAAAO,EAAAA,EAAAz7B,GACAi7B,EAAAQ,EAAAA,EAAA7tC,GACAstC,EAAAf,EAAAA,EAAAn6B,GACAi7B,EAAAd,EAAAA,EAAAvsC,IAGAotC,EAAAt3C,KAAA+3C,GACAT,EAAAt3C,KAAAy2C,GAOA,MAJAI,IACAS,EAAAt3C,KAAAs3C,EAAAjiC,SAGAiiC,EApGA,GAAA/H,GAAAn3C,EAAA,IAEAm/C,EAAAhI,EAAAjzB,IACAk7B,EAAAjI,EAAArlC,IACA0tC,EAAArI,EAAA7tC,MACAo1C,EAAAvH,EAAApqB,SACA6yB,EAAAzI,EAAAzyC,IACA46C,EAAAnI,EAAApsC,MACAw0C,EAAApI,EAAA3qB,GA+FA7sB,GAAAD,QAAAkjB,GvDyoXM,SAAUjjB,EAAQD,EAASM,GwDhvXjC,GAAA8O,GAAA9O,EAAA,GAEAg+C,EAAAh+C,EAAA,IAKA4iB,EAAA9T,EAAAmB,QACAhL,KAAA,WACAhB,OACAqzC,OAAA,KACA2G,QAAA,EACAC,iBAAA,MAEAp3C,OACA4F,OAAA,OACA7D,KAAA,MAEAkV,UAAA,SAAAE,EAAAha,GACA+5C,EAAAjgC,UAAAE,EAAAha,GAAA,KAIAtE,GAAAD,QAAAkjB,GxDsvXM,SAAUjjB,EAAQD,EAASM,GyD7wXjC,GAAA8O,GAAA9O,EAAA,GAEA4pC,EAAA5pC,EAAA,IAMA4iB,EAAA9T,EAAAmB,QACAhL,KAAA,OACAhB,OAMAkgB,EAAA,EACA5a,EAAA,EACAC,EAAA,EACAb,MAAA,EACAC,OAAA,GAEAmV,UAAA,SAAAE,EAAAha,GACA,GAAAsF,GAAAtF,EAAAsF,EACAC,EAAAvF,EAAAuF,EACAb,EAAA1E,EAAA0E,MACAC,EAAA3E,EAAA2E,MAEA3E,GAAAkgB,EAGAylB,EAAA7rB,UAAAE,EAAAha,GAFAga,EAAA3N,KAAA/G,EAAAC,EAAAb,EAAAC,GAKAqV,EAAA4rB,cAKAlqC,GAAAD,QAAAkjB,GzDmxXM,SAAUjjB,EAAQD,EAASM,G0D1zXjC,GAAA8O,GAAA9O,EAAA,GAMA4iB,EAAA9T,EAAAmB,QACAhL,KAAA,OACAhB,OAEAiG,GAAA,EACAC,GAAA,EAEAC,GAAA,EACAC,GAAA,EACA6kB,QAAA,GAEApoB,OACA4F,OAAA,OACA7D,KAAA,MAEAkV,UAAA,SAAAE,EAAAha,GACA,GAAAiG,GAAAjG,EAAAiG,GACAC,EAAAlG,EAAAkG,GACAC,EAAAnG,EAAAmG,GACAC,EAAApG,EAAAoG,GACA6kB,EAAAjrB,EAAAirB,OAEA,KAAAA,IAIAjR,EAAAuyB,OAAAtmC,EAAAC,GAEA+kB,EAAA,IACA9kB,EAAAF,GAAA,EAAAglB,GAAA9kB,EAAA8kB,EACA7kB,EAAAF,GAAA,EAAA+kB,GAAA7kB,EAAA6kB,GAGAjR,EAAAwyB,OAAArmC,EAAAC,KAQAw1C,QAAA,SAAAr/C,GACA,GAAAyD,GAAAnE,KAAAmE,KACA,QAAAA,EAAAiG,IAAA,EAAA1J,GAAAyD,EAAAmG,GAAA5J,EAAAyD,EAAAkG,IAAA,EAAA3J,GAAAyD,EAAAoG,GAAA7J,KAIAb,GAAAD,QAAAkjB,G1Dg0XM,SAAUjjB,EAAQD,EAASM,G2Dl2XjC,QAAA8/C,GAAA77C,EAAAkpB,EAAA4yB,GACA,GAAAC,GAAA/7C,EAAA+7C,KACAC,EAAAh8C,EAAAg8C,IAEA,OAAA,QAAAD,GAAA,OAAAC,IACAF,EAAAtL,EAAAlB,GAAAtvC,EAAAiG,GAAAjG,EAAAi8C,KAAAj8C,EAAA+7C,KAAA/7C,EAAAmG,GAAA+iB,IAAA4yB,EAAAtL,EAAAlB,GAAAtvC,EAAAkG,GAAAlG,EAAAk8C,KAAAl8C,EAAAg8C,KAAAh8C,EAAAoG,GAAA8iB,MAEA4yB,EAAAlJ,EAAAD,GAAA3yC,EAAAiG,GAAAjG,EAAAi8C,KAAAj8C,EAAAmG,GAAA+iB,IAAA4yB,EAAAlJ,EAAAD,GAAA3yC,EAAAkG,GAAAlG,EAAAk8C,KAAAl8C,EAAAoG,GAAA8iB,IA1BA,GAAAre,GAAA9O,EAAA,GAEAkuC,EAAAluC,EAAA,IAEA05C,EAAA15C,EAAA,IAEAi3C,EAAAyC,EAAAzC,mBACAvB,EAAAgE,EAAAhE,eACAkB,EAAA8C,EAAA9C,YACArD,EAAAmG,EAAAnG,QACAsD,EAAA6C,EAAA7C,sBACApC,EAAAiF,EAAAjF,kBAMA7pB,KAaAhI,EAAA9T,EAAAmB,QACAhL,KAAA,eACAhB,OACAiG,GAAA,EACAC,GAAA,EACAC,GAAA,EACAC,GAAA,EACA61C,KAAA,EACAC,KAAA,EAIAjxB,QAAA,GAEApoB,OACA4F,OAAA,OACA7D,KAAA,MAEAkV,UAAA,SAAAE,EAAAha,GACA,GAAAiG,GAAAjG,EAAAiG,GACAC,EAAAlG,EAAAkG,GACAC,EAAAnG,EAAAmG,GACAC,EAAApG,EAAAoG,GACA61C,EAAAj8C,EAAAi8C,KACAC,EAAAl8C,EAAAk8C,KACAH,EAAA/7C,EAAA+7C,KACAC,EAAAh8C,EAAAg8C,KACA/wB,EAAAjrB,EAAAirB,OAEA,KAAAA,IAIAjR,EAAAuyB,OAAAtmC,EAAAC,GAEA,MAAA61C,GAAA,MAAAC,GACA/wB,EAAA,IACA+nB,EAAA/sC,EAAAg2C,EAAA91C,EAAA8kB,EAAAtE,GACAs1B,EAAAt1B,EAAA,GACAxgB,EAAAwgB,EAAA,GACAqsB,EAAA9sC,EAAAg2C,EAAA91C,EAAA6kB,EAAAtE,GACAu1B,EAAAv1B,EAAA,GACAvgB,EAAAugB,EAAA,IAGA3M,EAAAyyB,iBAAAwP,EAAAC,EAAA/1C,EAAAC,KAEA6kB,EAAA,IACAwmB,EAAAxrC,EAAAg2C,EAAAF,EAAA51C,EAAA8kB,EAAAtE,GACAs1B,EAAAt1B,EAAA,GACAo1B,EAAAp1B,EAAA,GACAxgB,EAAAwgB,EAAA,GACA8qB,EAAAvrC,EAAAg2C,EAAAF,EAAA51C,EAAA6kB,EAAAtE,GACAu1B,EAAAv1B,EAAA,GACAq1B,EAAAr1B,EAAA,GACAvgB,EAAAugB,EAAA,IAGA3M,EAAA+zB,cAAAkO,EAAAC,EAAAH,EAAAC,EAAA71C,EAAAC,MASAw1C,QAAA,SAAA1yB,GACA,MAAA2yB,GAAAhgD,KAAAmE,MAAAkpB,GAAA,IAQAizB,UAAA,SAAAjzB,GACA,GAAA3sB,GAAAs/C,EAAAhgD,KAAAmE,MAAAkpB,GAAA,EACA,OAAA+gB,GAAArhB,UAAArsB,EAAAA,KAIAb,GAAAD,QAAAkjB,G3D23XM,SAAUjjB,EAAQD,EAASM,G4D3+XjC,GAAA8O,GAAA9O,EAAA,GAMA4iB,EAAA9T,EAAAmB,QACAhL,KAAA,MACAhB,OACA4M,GAAA,EACAC,GAAA,EACAqT,EAAA,EACAmuB,WAAA,EACAC,SAAA,EAAA1jC,KAAAoM,GACAshC,WAAA,GAEAz1C,OACA4F,OAAA,OACA7D,KAAA,MAEAkV,UAAA,SAAAE,EAAAha,GACA,GAAAsF,GAAAtF,EAAA4M,GACArH,EAAAvF,EAAA6M,GACAqT,EAAAtV,KAAAiD,IAAA7N,EAAAkgB,EAAA,GACAmuB,EAAAruC,EAAAquC,WACAC,EAAAtuC,EAAAsuC,SACAgK,EAAAt4C,EAAAs4C,UACAC,EAAA3tC,KAAAiQ,IAAAwzB,GACAmK,EAAA5tC,KAAAgQ,IAAAyzB,EACAr0B,GAAAuyB,OAAAgM,EAAAr4B,EAAA5a,EAAAkzC,EAAAt4B,EAAA3a,GACAyU,EAAAo0B,IAAA9oC,EAAAC,EAAA2a,EAAAmuB,EAAAC,GAAAgK,KAIA58C,GAAAD,QAAAkjB,G5Di/XM,SAAUjjB,EAAQD,EAASM,G6DnhYjC,GAAA6C,GAAA7C,EAAA,GAEA+M,EAAA/M,EAAA,IAWA4P,EAAA,SAAArG,EAAAC,EAAAY,EAAAC,EAAAuV,EAAAygC,GAIAvgD,KAAAyJ,EAAA,MAAAA,EAAA,EAAAA,EACAzJ,KAAA0J,EAAA,MAAAA,EAAA,EAAAA,EACA1J,KAAAsK,GAAA,MAAAA,EAAA,EAAAA,EACAtK,KAAAuK,GAAA,MAAAA,EAAA,EAAAA,EAEAvK,KAAAmF,KAAA,SAEAnF,KAAAikB,OAAAs8B,IAAA,EACAtzC,EAAA1M,KAAAP,KAAA8f,GAGAhQ,GAAAzM,WACA0R,YAAAjF,GAEA/M,EAAAmO,SAAApB,EAAA7C,EACA,IAAA6V,GAAAhT,CACAjQ,GAAAD,QAAAkjB,G7DyhYM,SAAUjjB,EAAQD,EAASM,G8D1jYjC,GAAA6C,GAAA7C,EAAA,GAEA+M,EAAA/M,EAAA,IAUA6P,EAAA,SAAAtG,EAAAC,EAAA2a,EAAAvE,EAAAygC,GAIAvgD,KAAAyJ,EAAA,MAAAA,EAAA,GAAAA,EACAzJ,KAAA0J,EAAA,MAAAA,EAAA,GAAAA,EACA1J,KAAAqkB,EAAA,MAAAA,EAAA,GAAAA,EAEArkB,KAAAmF,KAAA,SAEAnF,KAAAikB,OAAAs8B,IAAA,EACAtzC,EAAA1M,KAAAP,KAAA8f,GAGA/P,GAAA1M,WACA0R,YAAAhF,GAEAhN,EAAAmO,SAAAnB,EAAA9C,EACA,IAAA6V,GAAA/S,CACAlQ,GAAAD,QAAAkjB,G9DgkYM,SAAUjjB,EAAQD,EAASM,G+D/lYjC,GAAA6C,GAAA7C,EAAA,GAEA8iB,EAAA9iB,EAAA,GAEAm3C,EAAAn3C,EAAA,IAEAsgD,EAAAnJ,EAAA71B,KAqBAi/B,GAAA,WAAA,WAAA,QAAA,QAAA,SAKAC,EAAA,SAAA7/C,GACA,gBAAAA,GACAb,KAAA2gD,SAAA9/C,GACGA,IACHA,EAAA+/C,WAAA5gD,KAAA4gD,SAAA//C,EAAA+/C,UACA,MAAA//C,EAAA2N,WAAAxO,KAAAwO,SAAA3N,EAAA2N,UACA3N,EAAAytB,SAAAtuB,KAAAsuB,OAAAztB,EAAAytB,QACAztB,EAAAwtB,QAAAruB,KAAAquB,MAAAxtB,EAAAwtB,QAGA,MAAAruB,KAAA4gD,SACA5gD,KAAA4gD,SAAA5gD,KAAA4gD,SAAAjkC,MAAA,KAEA3c,KAAA4gD,SAAAH,EAIAC,GAAAr9C,WACA0R,YAAA2rC,EAQAE,SAAA,IAMAtyB,OAAA,SAMA9f,SAAA,IAKA6f,MAAA,EACAsyB,SAAA,SAAA3jC,GACA,GAAA7U,GAAA6U,EAAAL,MAAA,OACA3c,MAAA4gD,SAAAz4C,EAAA,GACAnI,KAAAwO,UAAArG,EAAA,GACAnI,KAAAquB,OAAAlmB,EAAA,GACAnI,KAAAsuB,OAAAnmB,EAAA,IAOA,IAAA04C,GAAA,SAAAhgD,GACAA,EAAAA,MACAb,KAAA8gD,WAMA9gD,KAAA+gD,IAAAlgD,EAAA4L,GACAzM,KAAAghD,cACAhhD,KAAAihD,wBAEApgD,EAAAqgD,eACAlhD,KAAAmhD,cAAAtgD,EAAAqgD,aAGA,IAAAE,GAAAvgD,EAAAwgD,MAEA,IAAAD,EACA,IAAA,GAAA15C,KAAA05C,GACA,GAAAA,EAAAj0C,eAAAzF,GAAA,CACA,GAAA45C,GAAAF,EAAA15C,EAEA1H,MAAAuhD,UAAA75C,EAAA45C,GAKAthD,KAAAwhD,SAAAxhD,KAAAmhD,eAGAN,GAAAx9C,WACA0R,YAAA8rC,EAOAM,cAAA,SAOAM,cAAA,GACAh1C,GAAA,WACA,MAAAzM,MAAA+gD,KAEAQ,UAAA,SAAA75C,EAAA45C,GAQA,GAPAthD,KAAA8gD,QAAAp5C,GAAA45C,EAEAA,EAAAI,aACAJ,EAAAI,WAAA,GAAAhB,GAAAY,EAAAI,aAIAh6C,IAAA1H,KAAAmhD,cACAnhD,KAAA2hD,mBAAAL,OACK,CACL,GAAA70C,GAAAzM,KAAA+gD,GAGAh+C,GAAAoS,MAAAmsC,EAAAt6C,MAAAyF,EAAAzF,OAAA,GAAA,GAEAs6C,EAAAn9C,MACApB,EAAAoS,MAAAmsC,EAAAn9C,MAAAsI,EAAAtI,OAAA,GAAA,GAEAm9C,EAAAn9C,MAAApB,EAAAkI,MAAAwB,EAAAtI,OAAA,EAGA,KAAA,GAAAuD,KAAA1H,MAAA8gD,QACA9gD,KAAA8gD,QAAA3zC,eAAAzF,IACA1H,KAAA2hD,mBAAA3hD,KAAA8gD,QAAAp5C,MAKAi6C,mBAAA,SAAAL,GACA,GAAAJ,GAAAlhD,KAAA8gD,QAAA9gD,KAAAmhD,cAEAD,IAAAI,IAAAJ,GACAn+C,EAAAoS,MAAAmsC,EAAAJ,GAAA,GAAA,IAGAM,SAAA,SAAA95C,EAAA4b,GACA,GAAA5b,IAAA1H,KAAAyhD,eAAAzhD,KAAA4hD,aAAA,CAIA,GAAAN,GAAAthD,KAAA8gD,QAAAp5C,EAEA,IAAA45C,EAAA,CAGA,GAFAthD,KAAA6hD,mBAEAv+B,EAAA,CACA,GAAAw+B,GAAA9hD,KAAA8gD,QAAA9gD,KAAAyhD,cAEAK,IACAA,EAAAC,SAAAD,EAAAC,QAAAxhD,KAAAP,MAGAshD,EAAAU,SAAAV,EAAAU,QAAAzhD,KAAAP,MAKA,GAFAA,KAAAyhD,cAAA/5C,EAEA1H,KAAA+gD,IAAA,CACA,GAAAt0C,GAAAzM,KAAA+gD,GAmBA,IAjBA,MAAAO,EAAAl+B,SACA3W,EAAA2W,OAAAk+B,EAAAl+B,QAGA,MAAAk+B,EAAAr4C,IACAwD,EAAAxD,EAAAq4C,EAAAr4C,GAIAq4C,EAAA/3C,UAAAi3C,EAAA/zC,EAAAlD,SAAA+3C,EAAA/3C,UACA+3C,EAAA93C,OAAAg3C,EAAA/zC,EAAAjD,MAAA83C,EAAA93C,OAEA,MAAA83C,EAAAv3B,WACAtd,EAAAsd,SAAAu3B,EAAAv3B,UAIAu3B,EAAAt6C,MAAA,CACA,GAAAk6C,GAAAlhD,KAAA8gD,QAAA9gD,KAAAmhD,cACA10C,GAAAzF,MAAA,GAAAgc,GAEAk+B,GACAz0C,EAAAzF,MAAA2b,WAAAu+B,EAAAl6C,OAAA,GAIAU,GAAA1H,KAAAmhD,eACAD,EAAAl6C,QAAAs6C,EAAAt6C,OACAyF,EAAAzF,MAAA2b,WAAA2+B,EAAAt6C,OAAA,GAIAs6C,EAAAn9C,QACAsI,EAAAtI,MAAApB,EAAAkI,MAAAq2C,EAAAn9C,OAAA,IAGAsI,EAAA6R,SAIA,IAAA,GAAArY,GAAA,EAAmBA,EAAAjG,KAAAghD,WAAA96C,OAA4BD,IAC/CjG,KAAAghD,WAAAQ,SAAA95C,KAGAu6C,SAAA,WACA,MAAAjiD,MAAAyhD,eAEAS,gBAAA,SAAA99C,EAAA4pB,GACA,GAAA5pB,IAAApE,KAAAyhD,eAAAzhD,KAAA4hD,aAAA,CAIA,GAAAN,GAAAthD,KAAA8gD,QAAA18C,GACA+9C,EAAA,mBACApuB,EAAA/zB,KAEAoiD,IAEA,IAAAd,EAAA,CACAvtB,EAAA8tB,iBAEA,IAAAp1C,GAAAsnB,EAAAgtB,GAEA,IAAAO,EAAAI,YAAAj1C,GAAAA,EAAAyV,KAAA,CAeA,IAAA,GAbAmgC,GAAAf,EAAAI,WACAd,EAAAyB,EAAAzB,SACA0B,EAAA,EAEAC,EAAA,WACAD,IAEA,IAAAA,IACAvuB,EAAAytB,SAAAp9C;AACA4pB,GAAAA,MAIA/nB,EAAA,EAAuBA,EAAA26C,EAAA16C,OAAqBD,IAAA,CAC5C,GAAAkrB,GAAAyvB,EAAA36C,EAEA,IAAA,UAAAkrB,GAAA,UAAAA,GACA,GAAAmwB,EAAAnwB,GACA,IAAA,GAAAplB,KAAAu1C,GAAAnwB,GACA,GAAAmwB,EAAAnwB,GAAAhkB,eAAApB,GAAA,CAIA,GAAA2E,GAAAygB,EAAA,IAAAplB,CAEAq2C,GAAA1xC,KAIA0xC,EAAA1xC,GAAA,EACA4xC,GAAAvuB,EAAAyuB,UAAAlB,EAAAnwB,EAAAplB,EAAAs2C,EAAAE,SAGW,CACX,GAAAH,EAAAjxB,GACA,QAKA,IAFAixB,EAAAjxB,GAAA,EAEAA,EAAAosB,MAAA4E,GAAA,CAEA,GAAAM,GAAAtxB,EAAA7Y,MAAA,EAAA,EACA6Y,GAAAA,EAAA7Y,MAAA,GACAgqC,GAAAvuB,EAAAyuB,UAAAlB,EAAAmB,EAAAtxB,EAAAkxB,EAAAE,OAEAD,IAAAvuB,EAAAyuB,UAAAlB,EAAA,GAAAnwB,EAAAkxB,EAAAE,IAMA,IAAAD,IACAvuB,EAAAytB,SAAAp9C,GACA4pB,GAAAA,SAGA+F,GAAAytB,SAAAp9C,GACA4pB,GAAAA,IAMA,IAAA,GAFA00B,GAAA3uB,EAAAitB,WAEA/6C,EAAA,EAAmBA,EAAAy8C,EAAAx8C,OAAsBD,IACzCy8C,EAAAR,gBAAA99C,KAaAo+C,UAAA,SAAAlB,EAAAqB,EAAA52C,EAAAs2C,EAAAr0B,GACA,GAAAvhB,GAAAzM,KAAA+gD,IACA6B,EAAAD,EAAArB,EAAAqB,GAAArB,EACAuB,EAAAF,EAAAl2C,EAAAk2C,GAAAl2C,EACAq2C,EAAAF,GAAA72C,IAAA62C,IAAAC,GAAA92C,IAAA82C,GACAE,EAAA/iD,KAAAihD,oBAEA,IAAA6B,EAAA,CACA,GAAArsC,KAEA,IAAAmsC,EAAA72C,KAAA82C,EAAA92C,GACA,MAAA,EAGA0K,GAAA1K,GAAA62C,EAAA72C,EACA,IAAA+hB,GAAArhB,EAAA8V,QAAAogC,GAAA7zB,KAAAuzB,EAAA7zC,SAAAiI,GAAA4X,MAAAg0B,EAAAW,OAAAh1B,KAAA,WACA,GAAAslB,GAAAvwC,EAAA4P,QAAAowC,EAAA,EAEAzP,GAAA,GACAyP,EAAAv8C,OAAA8sC,EAAA,GAGAtlB,MACOW,MAAA0zB,EAAA/zB,OAEP,OADAy0B,GAAAj7C,KAAAgmB,GACA,EAGA,MAAA,IAEA+zB,gBAAA,WAGA,IAAA,GAFAkB,GAAA/iD,KAAAihD,qBAEAh7C,EAAA,EAAmBA,EAAA88C,EAAA78C,OAAgCD,IACnD88C,EAAA98C,GAAAkoB,MAGA40B,GAAA78C,OAAA,GAEA07C,WAAA,WACA,MAAA5hD,MAAAihD,qBAAA/6C,OAAA,GAEA+8C,aAAA,SAAA5B,GACArhD,KAAAghD,WAAAl5C,KAAAu5C,IAEA6B,gBAAA,SAAA7B,GACA,GAAA/N,GAAAvwC,EAAA4P,QAAA3S,KAAAghD,WAAAK,EAEA/N,IAAA,GACAtzC,KAAAghD,WAAAx6C,OAAA66C,EAAA,IAIA,IAAAv+B,GAAA+9B,CACAhhD,GAAAD,QAAAkjB,G/DqmYM,SAAUjjB,EAAQD,EAASM,GgEl+YjC,QAAAgR,GAAA+E,EAAAC,GAGA,QAAAC,MAFA,GAAAC,GAAAH,EAAA5S,SAGA8S,GAAA9S,UAAA6S,EAAA7S,UACA4S,EAAA5S,UAAA,GAAA8S,EAEA,KAAA,GAAAE,KAAAD,GACAH,EAAA5S,UAAAgT,GAAAD,EAAAC,EAEAJ,GAAA5S,UAAA0R,YAAAkB,EACAA,EAAAK,WAAAJ,EAGA,QAAAitC,KAKA,IAAA,GADA9+B,GAHA++B,EAAA,iEAAAzmC,MAAA,IACA0mC,EAAA,GAAA/oC,OAAA,IACAgpC,EAAA,EAEAr9C,EAAA,EAAuBA,EAAA,GAAQA,IAC/B,GAAAA,GAAA,IAAAA,GAAA,IAAAA,GAAA,IAAAA,EACAo9C,EAAAp9C,GAAA,IACa,IAAAA,EACbo9C,EAAAp9C,GAAA,KAEAq9C,GAAA,IAAAA,EAAA,SAAA,SAAAv0C,KAAAw0C,SAAA,GACAl/B,EAAA,GAAAi/B,EACAA,IAAA,EACAD,EAAAp9C,GAAAm9C,EAAA,IAAAn9C,EAAA,EAAAoe,EAAA,EAAAA,GAGA,OAAA,OAAAg/B,EAAAxyB,KAAA,IAUA,QAAA5D,GAAAkC,EAAAe,GACA,MAAAnhB,MAAA+P,KAAA/P,KAAA2nB,IAAAvH,EAAA1lB,EAAAymB,EAAAzmB,EAAA,GAAAsF,KAAA2nB,IAAAvH,EAAAzlB,EAAAwmB,EAAAxmB,EAAA,IAQA,QAAA85C,GAAAhM,GAGA,IAAA,GAFAh3C,GAAAysB,EAAAuqB,EAAA,GAAAA,EAAA,IACA/iC,GAAA+iC,EAAA,GAAAA,EAAA,IACAvxC,EAAA,EAAuBA,EAAAuxC,EAAAtxC,OAAA,EAAuBD,IAE9CzF,EAAAysB,EAAAuqB,EAAAvxC,GAAAuxC,EAAAvxC,EAAA,MACAzF,EAAAysB,EAAAuqB,EAAAvxC,GAAAuxC,EAAAvxC,EAAA,IACAwO,GAAA+iC,EAAAvxC,GAAAuxC,EAAAvxC,EAAA,IAIA,OAAAwO,GAMA,QAAAgvC,GAAAznC,GAEA,IAAA,GADAyN,GAAA,EACAxjB,EAAA,EAAuBA,EAAA+V,EAAA9V,OAAA,EAAkBD,IACzCwjB,GAAAwD,EAAAjR,EAAA/V,GAAA+V,EAAA/V,EAAA,GAGA,OAAAwjB,GAQA,QAAAzX,GAAAgK,GACA,GAAA,GAAAA,EAAA0nC,OACA,MAAAC,IAGA,KAAA,GADAnjD,GAAAwb,EAAA,GACA/V,EAAA,EAA2BA,EAAA+V,EAAA9V,OAAcD,IACzCzF,EAAAwb,EAAA/V,KACAzF,EAAAwb,EAAA/V,GAIA,OAAAzF,GAUA,QAAA4jB,GAAApI,GACA,GAAA,GAAAA,EAAA0nC,OACA,MAAAC,IAGA,KAAA,GADAnjD,GAAAwb,EAAA,GACA/V,EAAA,EAA2BA,EAAA+V,EAAA9V,OAAcD,IACzCzF,EAAAwb,EAAA/V,KACAzF,EAAAwb,EAAA/V,GAIA,OAAAzF,GAUA,QAAAojD,GAAA5nC,GACA,GAAAA,EAAA9V,QAAA,EACA,OAAA,CAGA,KAAA,GAAAD,GAAA,EAAuBA,EAAA+V,EAAA9V,OAAA,EAAkBD,IACzC,GAAA+V,EAAA/V,GAAAwD,GAAAuS,EAAA/V,EAAA,GAAAwD,GAAAuS,EAAA/V,GAAAyD,GAAAsS,EAAA/V,EAAA,GAAAyD,EACA,OAAA,CAIA,QAAA,EAWA,QAAAm6C,GAAAC,EAAAC,GAEA,GAAAD,EAAAE,WAAAv6C,GAAAq6C,EAAAG,SAAAx6C,GAAAs6C,EAAAC,WAAAv6C,GAAAs6C,EAAAE,SAAAx6C,EACA,MAAAq6C,GAAAE,WAAAv6C,GAAAs6C,EAAAC,WAAAv6C,IAEAq6C,EAAAI,SAAAH,EAAAC,WAAAv6C,EAAAs6C,EAAAC,WAAAt6C,IACAo6C,EAAAI,SAAAH,EAAAE,SAAAx6C,EAAAs6C,EAAAE,SAAAv6C,GAKA,IAAAo6C,EAAAE,WAAAv6C,GAAAq6C,EAAAG,SAAAx6C,GAAAs6C,EAAAC,WAAAv6C,GAAAs6C,EAAAE,SAAAx6C,EAAA,CAEA,GAAAq6C,EAAAE,WAAAv6C,GAAAq6C,EAAAG,SAAAx6C,EAAA,CACA,GAAAggB,GAAAq6B,CACAA,GAAAC,EACAA,EAAAt6B,EAIA,GAAAgC,IAAAq4B,EAAAG,SAAAv6C,EAAAo6C,EAAAE,WAAAt6C,IAAAo6C,EAAAG,SAAAx6C,EAAAq6C,EAAAE,WAAAv6C,GACA8iB,EAAAu3B,EAAAE,WAAAt6C,EAAA+hB,EAAAq4B,EAAAE,WAAAv6C,EACAopC,EAAAkR,EAAAC,WAAAv6C,EACAqpC,EAAArnB,EAAAonB,EAAAtmB,CACA,OAAAu3B,GAAAI,SAAArR,EAAAC,IAAAiR,EAAAG,SAAArR,EAAAC,GAMA,GAAAqR,IAAAL,EAAAG,SAAAv6C,EAAAo6C,EAAAE,WAAAt6C,IAAAo6C,EAAAG,SAAAx6C,EAAAq6C,EAAAE,WAAAv6C,GACA26C,EAAAN,EAAAE,WAAAt6C,EAAAy6C,EAAAL,EAAAE,WAAAv6C,EAEA46C,GAAAN,EAAAE,SAAAv6C,EAAAq6C,EAAAC,WAAAt6C,IAAAq6C,EAAAE,SAAAx6C,EAAAs6C,EAAAC,WAAAv6C,GACA66C,EAAAP,EAAAC,WAAAt6C,EAAA26C,EAAAN,EAAAC,WAAAv6C,CAEA,OAAA06C,IAAAE,EACAD,GAAAE,IAEAR,EAAAI,SAAAH,EAAAC,WAAAv6C,EAAAs6C,EAAAC,WAAAt6C,IAAAo6C,EAAAI,SAAAH,EAAAE,SAAAx6C,EAAAs6C,EAAAE,SAAAv6C,KAaAmpC,GAAAyR,EAAAF,IAAAD,EAAAE,GACAvR,EAAAqR,EAAAtR,EAAAuR,EACAN,EAAAI,SAAArR,EAAAC,IAAAiR,EAAAG,SAAArR,EAAAC,IAcA,QAAAyR,GAAA/M,EAAAgN,EAAAC,GAIA,GAAAld,KACAA,GAAAz/B,KAAA,GAAAqC,GAAA,GAAAu6C,GAAAF,EAAA,GAAAA,EAAA,IAAA,GAAAE,GAAAF,EAAA,GAAAA,EAAA,MACAjd,EAAAz/B,KAAA,GAAAqC,GAAA,GAAAu6C,GAAAF,EAAA,GAAAA,EAAA,IAAA,GAAAE,GAAAF,EAAA,GAAAA,EAAA,MACAjd,EAAAz/B,KAAA,GAAAqC,GAAA,GAAAu6C,GAAAF,EAAA,GAAAA,EAAA,IAAA,GAAAE,GAAAF,EAAA,GAAAA,EAAA,MACAjd,EAAAz/B,KAAA,GAAAqC,GAAA,GAAAu6C,GAAAF,EAAA,GAAAA,EAAA,IAAA,GAAAE,GAAAF,EAAA,GAAAA,EAAA,KAEA,KAAA,GAAA/uB,GAAA,EAAuBA,EAAA+hB,EAAAtxC,OAAA,EAAuBuvB,IAK9C,IAAA,GAHAkvB,GAAA,GAAAx6C,GAAAqtC,EAAA/hB,GAAA+hB,EAAA/hB,EAAA,IAGAxvB,EAAA,EAA2BA,EAAAshC,EAAArhC,OAAkBD,IAC7C,GAAA49C,EAAAc,EAAApd,EAAAthC,IACA,OAAA,CAMA,IAAAw+C,EAKA,IAAA,GAHAG,GAAA,GAAAz6C,GAAAqtC,EAAAA,EAAAtxC,OAAA,GAAAsxC,EAAA,IAGAzvC,EAAA,EAA2BA,EAAAw/B,EAAArhC,OAAkB6B,IAC7C,GAAA87C,EAAAe,EAAArd,EAAAx/B,IACA,OAAA,CAKA,QAAA,EAeA,QAAA88C,GAAA7oC,GACA,GAAAA,EAAA9V,QAAA,EACA,QAIA,KAAA,GADA4+C,GAAA,EACA7+C,EAAA,EAAuBA,EAAA+V,EAAA9V,OAAA,EAAkBD,IACzC,GAAA+V,EAAA/V,EAAA,GAAAwD,GAAAuS,EAAA/V,GAAAwD,GAAAuS,EAAA/V,GAAAwD,GAAAuS,EAAA/V,EAAA,GAAAwD,EAAA,CACA,GAAAs7C,EAAA/oC,EAAA/V,EAAA,GAAAyD,EAAAsS,EAAA/V,GAAAyD,IAAAq7C,EAAA/oC,EAAA/V,GAAAyD,EAAAsS,EAAA/V,EAAA,GAAAyD,GAGA,QAFAo7C,SAIa,IAAA9oC,EAAA/V,EAAA,GAAAyD,GAAAsS,EAAA/V,GAAAyD,GAAAsS,EAAA/V,GAAAyD,GAAAsS,EAAA/V,EAAA,GAAAyD,EAAA,CACb,GAAAq7C,EAAA/oC,EAAA/V,EAAA,GAAAwD,EAAAuS,EAAA/V,GAAAwD,IAAAs7C,EAAA/oC,EAAA/V,GAAAwD,EAAAuS,EAAA/V,EAAA,GAAAwD,GAGA,QAFAq7C,SAKAA,IAIA,OAAAA,GAUA,QAAAC,GAAAt7C,GACA,MAAAA,GAAA,EACA,EACAA,EAAA,KAGA,EAUA,QAAAu7C,GAAAhpC,GACA,GAAAA,EAAA9V,QAAA,EACA,OAAA,CAGA,KAAA,GAAAD,GAAA,EAAuBA,EAAA+V,EAAA9V,OAAA,EAAkBD,IACzC,GAAA+V,EAAA/V,GAAAwD,GAAAuS,EAAA/V,EAAA,GAAAwD,GAAAuS,EAAA/V,EAAA,GAAAwD,GAAAuS,EAAA/V,EAAA,GAAAwD,GACA,GAAA,GAAAs7C,EAAA/oC,EAAA/V,EAAA,GAAAyD,EAAAsS,EAAA/V,GAAAyD,IACAq7C,EAAA/oC,EAAA/V,EAAA,GAAAyD,EAAAsS,EAAA/V,GAAAyD,OAAAq7C,EAAA/oC,EAAA/V,EAAA,GAAAyD,EAAAsS,EAAA/V,EAAA,GAAAyD,GACA,OAAA,MAGa,IAAAsS,EAAA/V,GAAAyD,GAAAsS,EAAA/V,EAAA,GAAAyD,GAAAsS,EAAA/V,EAAA,GAAAyD,GAAAsS,EAAA/V,EAAA,GAAAyD,GACb,GAAAq7C,EAAA/oC,EAAA/V,EAAA,GAAAwD,EAAAuS,EAAA/V,GAAAwD,IACAs7C,EAAA/oC,EAAA/V,EAAA,GAAAwD,EAAAuS,EAAA/V,GAAAwD,OAAAs7C,EAAA/oC,EAAA/V,EAAA,GAAAwD,EAAAuS,EAAA/V,EAAA,GAAAwD,GACA,OAAA,CAMA,QAAA,EASA,QAAAw7C,GAAAzN,EAAA0N,GACA,GAAAC,KACA,IAAAD,EAAA,CACA,IAAA,GAAAj/C,GAAA,EAA2BA,EAAAuxC,EAAAtxC,OAAmBD,IAAA,CAC9C,GAAAs5C,GAAA/H,EAAAvxC,EACAk/C,GAAAr9C,KAAA,GAAA48C,GAAAnF,EAAA,GAAAA,EAAA,KAEA,MAAA4F,GAEA,IAAA,GAAAp9C,GAAA,EAA2BA,EAAAyvC,EAAAtxC,OAAmB6B,IAAA,CAC9C,GAAAq9C,GAAA5N,EAAAzvC,EACAo9C,GAAAr9C,MAAAs9C,EAAA37C,EAAA27C,EAAA17C,IAEA,MAAAy7C,GAMA,QAAAE,GAAAnN,GACA,GAAAoN,KACAv2C,KAAAiQ,IAAAk5B,IAAAnpC,KAAAgQ,IAAAm5B,GAAA,IACAnpC,KAAAgQ,IAAAm5B,GAAAnpC,KAAAiQ,IAAAk5B,GAAA,IACA,EAAA,EAAA,GAEA,OAAAoN,GAGA,QAAAC,GAAAz9B,EAAAC,GACA,QACA,EAAA,EAAAD,IACA,EAAA,EAAAC,IACA,EAAA,EAAA,IAIA,QAAAy9B,GAAAh7B,EAAAC,GAIA,MAHA,OAAAA,IACAA,EAAAD,KAGAA,EAAA,EAAA,IACA,EAAAC,EAAA,IACA,EAAA,EAAA,IAUA,QAAAg7B,GAAAzB,EAAA99C,EAAAgyC,GACA,GAAA+L,GAAAD,EAAA/4C,OAKA,OAJAg5C,GAAAnwC,UAAAyxC,GAAAvB,EAAAv6C,GAAAu6C,EAAAt6C,IACAu6C,EAAAv6C,GAAAxD,EACA+9C,EAAAnwC,UAAAuxC,EAAAnN,IACA+L,EAAAnwC,UAAAyxC,EAAAvB,EAAAv6C,EAAAu6C,EAAAt6C,IACAu6C,EAQA,QAAAyB,GAAAl+C,GACA,OACAmjC,KAAA,GAAA+Z,GAAAl9C,EAAAiC,EAAAjC,EAAAkC,EAAAlC,EAAAsB,OAAA,GACAgiC,IAAA,GAAA4Z,GAAAl9C,EAAAiC,EAAAjC,EAAAqB,MAAA,EAAArB,EAAAkC,GACAkhC,MAAA,GAAA8Z,GAAAl9C,EAAAiC,EAAAjC,EAAAqB,MAAArB,EAAAkC,EAAAlC,EAAAsB,OAAA,GACAiiC,OAAA,GAAA2Z,GAAAl9C,EAAAiC,EAAAjC,EAAAqB,MAAA,EAAArB,EAAAkC,EAAAlC,EAAAsB,QACA+hC,OAAA,GAAA6Z,GAAAl9C,EAAAiC,EAAAjC,EAAAqB,MAAA,EAAArB,EAAAkC,EAAAlC,EAAAsB,OAAA,IAUA,QAAA68C,GAAAn+C,GACA,QAEA,GAAAuH,KAAAD,MAAAtH,EAAAo+C,UAAA/8C,MAAA,EAAA,IAAA,IACA,GAAAkG,KAAAD,MAAA,EAAAtH,EAAAo+C,UAAA/8C,MAAA,EAAA,IAAA,IAEArB,EAAAo+C,UAAA/8C,MAAA,GAAAkG,KAAAD,MAAAtH,EAAAo+C,UAAA98C,OAAA,EAAA,MACAtB,EAAAo+C,UAAA/8C,MAAA,GAAAkG,KAAAD,MAAA,EAAAtH,EAAAo+C,UAAA98C,OAAA,EAAA,MAEA,GAAAiG,KAAAD,MAAAtH,EAAAo+C,UAAA/8C,MAAA,EAAA,IAAArB,EAAAo+C,UAAA98C,SACA,GAAAiG,KAAAD,MAAA,EAAAtH,EAAAo+C,UAAA/8C,MAAA,EAAA,IAAArB,EAAAo+C,UAAA98C,SAEA,EAAA,GAAAiG,KAAAD,MAAAtH,EAAAo+C,UAAA98C,OAAA,EAAA,MACA,EAAA,GAAAiG,KAAAD,MAAA,EAAAtH,EAAAo+C,UAAA98C,OAAA,EAAA,MAWA,QAAA+8C,GAAA12B,EAAAe,GACA,OAAAnhB,KAAAoM,GAAA,EAAApM,KAAA2b,MACAwF,EAAAxmB,EAAAylB,EAAAzlB,EAAAwmB,EAAAzmB,EAAA0lB,EAAA1lB,GAuBA,QAAAq8C,GAAA32B,EAAAe,EAAAC,EAAA41B,GACA,GAAAC,GAAA72B,EAAA1lB,EAAAymB,EAAAxmB,EAAAylB,EAAAzlB,EAAAymB,EAAA1mB,EAAAymB,EAAAzmB,EAAA0mB,EAAAzmB,GAAAwmB,EAAAxmB,EAAAymB,EAAA1mB,EAAA0lB,EAAAzlB,EAAAwmB,EAAAzmB,EAAA0lB,EAAA1lB,EAAA0mB,EAAAzmB,EAEA,OAAAq8C,GACAh3C,KAAAoF,IAAA6xC,IAAAD,EAEA,IAAAC,EAQA,QAAAC,GAAAC,EAAAC,GACA,MAAAp3C,MAAAD,MAAAo3C,EAAAn3C,KAAA2nB,IAAA,GAAAyvB,IAAAp3C,KAAA2nB,IAAA,GAAAyvB,GAMA,QAAAC,GAAApC,EAAAC,GACA,MAAAl1C,MAAA+P,KAAA/P,KAAA2nB,IAAAstB,EAAAv6C,EAAAw6C,EAAAx6C,EAAA,GAAAsF,KAAA2nB,IAAAstB,EAAAt6C,EAAAu6C,EAAAv6C,EAAA,IAUA,QAAA28C,GAAAC,EAAAC,EAAAz3C,GACAw3C,EAAA78C,EAAAw8C,EAAAK,EAAA78C,EAAA,GACA68C,EAAA58C,EAAAu8C,EAAAK,EAAA58C,EAAA,GACA68C,EAAA98C,EAAAw8C,EAAAM,EAAA98C,EAAA,GACA88C,EAAA78C,EAAAu8C,EAAAM,EAAA78C,EAAA,EACA,IAAAwuC,GAAAnpC,KAAAy3C,MAAAD,EAAA98C,EAAA68C,EAAA78C,IAAA88C,EAAA78C,EAAA48C,EAAA58C,GAWA,KAVAwuC,GAAAA,EAGAqO,EAAA98C,GAAA68C,EAAA78C,GAAA88C,EAAA78C,GAAA48C,EAAA58C,EACAwuC,GAAAnpC,KAAAoM,GACSorC,EAAA98C,GAAA68C,EAAA78C,GAAA88C,EAAA78C,GAAA48C,EAAA58C,EACTwuC,GAAAnpC,KAAAoM,GACSorC,EAAA98C,GAAA68C,EAAA78C,GAAA88C,EAAA78C,GAAA48C,EAAA58C,IACTwuC,GAAA,EAAAnpC,KAAAoM,IAEA+8B,GAAA,EAAAnpC,KAAAoM,IACA+8B,GAAA,EAAAnpC,KAAAoM,EAQA,OANAkC,OAAA66B,KACAA,EAAA,GAEAppC,IACAopC,EAAAnpC,KAAAD,MAAAopC,EAAAppC,GAAAA,GAEAopC,EAGA,QAAA0N,GAAAp+C,EAAAi/C,GACA,GAAA71C,GAAApJ,EAAAqJ,kBAEA2mC,IACAA,GAAA,KAAA5mC,EAAA/H,MAAA,GAAA+H,EAAA9H,OAAA,GACA0uC,EAAA,IAAA5mC,EAAA/H,MAAA,GAAA+H,EAAA9H,OAAA,GACA0uC,EAAA,IAAA5mC,EAAA/H,MAAA,EAAA+H,EAAA9H,OAAA,GACA0uC,EAAA,KAAA5mC,EAAA/H,MAAA,EAAA+H,EAAA9H,OAAA,GACA0uC,EAAA,KAAA5mC,EAAA/H,MAAA,GAAA+H,EAAA9H,OAAA,EAEA,IAAA49C,GAAAl/C,EAAA+B,SAAA,GACAo9C,EAAAn/C,EAAA+B,SAAA,EAEA/B,GAAApB,QAAA,cAAAoB,EAAApB,OAAAjB,MAAAshD,IACAC,GAAAl/C,EAAApB,OAAAmD,SAAA,GACAo9C,GAAAn/C,EAAApB,OAAAmD,SAAA,GAGA,IAAAq9C,GAAA,GAAA52C,GACA4jC,OAAA8S,EAAA91C,EAAAnH,GACAmqC,OAAA+S,EAAA/1C,EAAAlH,GACAkqC,OAAAhjC,EAAA/H,OACA+qC,OAAAhjC,EAAA9H,SAGAiI,EAAA6iC,OAAA8S,GAAA9S,OAAAhjC,EAAA/H,OAAA,EAAA+qC,OAAAhjC,EAAAnH,GACAuH,EAAA4iC,OAAA+S,GAAA/S,OAAAhjC,EAAA9H,QAAA,EAAA8qC,OAAAhjC,EAAAlH,EACA,QACAD,EAAAmqC,OAAA7iC,GACArH,EAAAkqC,OAAA5iC,GACAnI,MAAA+qC,OAAAhjC,EAAA/H,OACAC,OAAA8qC,OAAAhjC,EAAA9H,QACA0uC,OAAAA,EACA5mC,aAAAg2C,GAgEA,QAAAC,KAIA,IAAA,GADA7Z,GAFA8Z,GAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,KACAC,EAAA,IAEA9gD,EAAA,EAAuBA,EAAA,EAAOA,IAC9B+mC,EAAAj+B,KAAAD,MAAA,GAAAC,KAAAw0C,UACAwD,GAAAD,EAAA9Z,EAEA,OAAA+Z,GAGA,QAAAC,GAAAvwC,GACA,MAAA,UAAAA,EAGA,QAAAwwC,GAAAjrC,GACA,GAAAqI,KAEA,IAAArI,EAAA9V,OAAA,EACA,MAAAw+C,GAAAwC,WAAAlrC,EAGAqI,GAAAvc,KAAAkU,EAAA,GAAA/Q,QACA,KAAA,GAAAhF,GAAA,EAAoBA,EAAA+V,EAAA9V,OAAA,EAAgBD,IACpC+V,EAAA/V,EAAA,GAAAwD,GAAAuS,EAAA/V,GAAAwD,GAAAuS,EAAA/V,GAAAwD,GAAAuS,EAAA/V,EAAA,GAAAwD,GAAAuS,EAAA/V,EAAA,GAAAyD,GAAAsS,EAAA/V,GAAAyD,GAAAsS,EAAA/V,GAAAyD,GAAAsS,EAAA/V,EAAA,GAAAyD,GAKA2a,EAAAvc,KAAAkU,EAAA/V,GAAAgF,QAKA,OAFAoZ,GAAAvc,KAAAkU,EAAAA,EAAA9V,OAAA,GAAA+E,SAEAoZ,EAqCA,QAAA8iC,GAAAj8C,EAAAk8C,EAAAC,IACAD,GAAAC,IAAAD,EAAAC,GACAD,EAAAA,MACAA,EAAArkD,EAAA6I,SAAAw7C,EAAAE,GAAA,EAGA,IAAAC,GAAA9qC,SACA2qC,EAAAI,QAAAC,GAAAjzC,QACA4yC,EAAA1I,aAAA+I,GAAAjzC,QACA4yC,EAAAM,UAAAD,GAAAjzC,QACAqc,KAAA,KAAA,KAAA,KAGAmc,EAAA,EACAx4B,EAAA,QACAtJ,GAAAqR,QAAAgrC,EAAA,SAAAhK,EAAAiK,EAAA9I,EAAAgJ,EAAApgC,GAaA,MAZA9S,IAAAtJ,EAAAoN,MAAA00B,EAAA1lB,GAAA/K,QAAAorC,EAAAC,GACA5a,EAAA1lB,EAAAi2B,EAAAr3C,OAEAshD,EACAhzC,GAAA,cAAAgzC,EAAA,iCACa9I,EACblqC,GAAA,cAAAkqC,EAAA,uBACagJ,IACblzC,GAAA,OAA6BkzC,EAAA,YAI7BnK,IAEA/oC,GAAA,OAGA4yC,EAAAS,WAAArzC,EAAA,mBAAwDA,EAAA,OAExDA,EAAA,4FAEAA,EAAA,eAEA,KACA,GAAAszC,GAAA,GAAAvvC,UAAA6uC,EAAAS,UAAA,MAAArzC,GACS,MAAAxQ,GAET,KADAA,GAAAwQ,OAAAA,EACAxQ,EAGA,GAAAmjD,GAAA,SAAA3wC,GACA,MAAAsxC,GAAAvnD,KAAAP,KAAAwW,IAIAnR,EAAA+hD,EAAAS,UAAA,KAGA,OAFAV,GAAA3yC,OAAA,YAAAnP,EAAA,OAAsDmP,EAAA,IAEtD2yC,EAGA,QAAAY,GAAAtxC,GACA,MAAA,OAAAA,IACA1T,EAAAwT,YAAAE,KAAA1T,EAAAyS,QAAAiB,IAAA1T,EAAA4U,SAAAlB,IAAA,IAAAA,EAAAvQ,OAAA,QAEA,QAAA8hD,GAAA5jD,EAAAoQ,EAAAY,EAAA6yC,GAGA,IAAAllD,EAAAsS,SAAAb,KAAAzR,EAAAsS,SAAAjR,GACA,MAAAgR,GAAArS,EAAAkI,MAAAuJ,GAAApQ,CAGA,KAAA,GAAA2H,KAAAyI,GACA,GAAAA,EAAArH,eAAApB,GAAA,CACA,GAAAuJ,GAAAlR,EAAA2H,GACAwJ,EAAAf,EAAAzI,IAEAhJ,EAAAsS,SAAAE,KAAAxS,EAAAsS,SAAAC,IAAAvS,EAAAyS,QAAAD,IAAAxS,EAAAyS,QAAAF,IAAAvS,EAAAoJ,MAAAoJ,IAAAxS,EAAAoJ,MAAAmJ,IAAAvS,EAAA0S,gBAAAF,IAAAxS,EAAA0S,gBAAAH,IAAAvS,EAAAmS,YAAAK,IAAAxS,EAAAmS,YAAAI,IAGaF,GAAArJ,IAAA3H,IAGb2H,IAAAk8C,IACA7jD,EAAA2H,GAAAhJ,EAAAkI,MAAAuJ,EAAAzI,IAAA,IALAi8C,EAAA1yC,EAAAC,EAAAH,EAAA6yC,GAUA,MAAA7jD,GAEA,QAAA8jD,MAhyBA,GAAAxD,GAAAxkD,EAAA,IACAiK,EAAAjK,EAAA,IACA8P,EAAA9P,EAAA,IACA6C,EAAA7C,EAAA,GAmkBAioD,GACAC,UAAA,WACA,GAAAC,KAEA,QACAzjD,IAAA,SAAAmH,EAAAiK,GACA,GAAAsyC,GAAAtoD,KAAA6F,IAAAkG,EACAu8C,GAAAxgD,KAAAkO,IAGAnQ,IAAA,SAAAkG,GACA,IAAA,GAAA9F,GAAA,EAAmCA,EAAAoiD,EAAAniD,OAAkBD,IACrD,GAAA8F,GAAAs8C,EAAApiD,GAAA8F,IACA,MAAAs8C,GAAApiD,GAAA+P,KAIA,IAAAA,KAEA,OADAqyC,GAAAvgD,MAAgCiE,IAAAA,EAAAiK,MAAAA,IAChCA,GAEAuyC,KAAA,WAEA,IAAA,GADAA,MACAtiD,EAAA,EAAmCA,EAAAoiD,EAAAniD,OAAkBD,IACrDsiD,EAAAzgD,KAAAugD,EAAApiD,GAAA8F,IAEA,OAAAw8C,IAEAzd,IAAA,WACA,MAAAud,GAAAA,EAAAniD,OAAA,IAEAhC,OAAA,SAAA6H,GAEA,IAAA,GADAunC,MACArtC,EAAA,EAAmCA,EAAAoiD,EAAAniD,OAAkBD,IACrD,GAAA8F,GAAAs8C,EAAApiD,GAAA8F,IAAA,CACAunC,EAAArtC,CACA,OAGA,MAAAoiD,GAAA7hD,OAAA8sC,EAAA,GAAA,IAEAkV,WAAA,SAAAz8C,EAAA08C,GACA,GAAAH,GAAAtoD,KAAA6F,IAAAkG,GACAihC,EAAAjqC,EAAA4P,QAAA21C,EAAAG,EACAH,GAAA9hD,OAAAwmC,EAAA,IAGA0b,UAAA,WACA,MAAAL,GAAA7hD,OAAA6hD,EAAAniD,OAAA,EAAA,GAAA,IAEAA,OAAA,WACA,MAAAmiD,GAAAniD,QAEAP,MAAA,WACA0iD,EAAA7hD,OAAA,EAAA6hD,EAAAniD,YA6CAohD,GACAI,SAAA,kBACAhJ,YAAA,mBACA8I,OAAA,oBAMAC,EAAA,OAIAkB,GACAC,IAAA,IACAC,KAAA,KACAC,KAAA,IACAC,KAAA,IACAC,SAAA,QACAC,SAAA,SAGAtB,EAAA,4BAEAC,EAAA,SAAArK,GACA,MAAA,KAAAoL,EAAApL,GA+FA2K,GAAA/3C,OAAA,SAAA+4C,GACA,GACAC,GAKA70C,EANA80C,EAAA,aAEAnlD,EAAAjE,KACAqpD,EAAAH,GAAAA,EAAAlnD,KAAAknD,EAAAlnD,KAAA,WACAiC,EAAAuT,MAAAxX,KAAAuX,WAIA6xC,GAAA/lD,UAAAY,EAAAZ,UACAiR,EAAA+0C,EAAA/0C,GAAA+0C,EAAAhmD,UAAA,GAAA+lD,EAEA,KAAAD,IAAAD,GACA,MAAAA,EAAAC,IAAAD,EAAAC,GAAAp0C,cAAAoF,OAEA7F,EAAA60C,GAAApmD,EAAA2S,aAAgD0zC,EAAA/lD,UAAA8lD,GAAAD,EAAAC,KAAA,GAEhD70C,EAAA60C,GAAAD,EAAAC,EAOA,OAHA70C,GAAAS,YAAAs0C,EACAA,EAAAl5C,OAAAlM,EAAAkM,OAEAk5C,GAGAxpD,EAAAD,SACAsR,SAAAA,EACAiyC,QAAAA,EACAl2B,SAAAA,EACAw2B,kBAAAA,EACAzxC,IAAAA,EACAoS,IAAAA,EACA2jC,QAAAA,EACAC,SAAAA,EACApE,eAAAA,EACAW,4BAAAA,EACAM,UAAAA,EACAG,YAAAA,EACAC,eAAAA,EACAQ,YAAAA,EACAC,mBAAAA,EACAG,gBAAAA,EACAC,aAAAA,EACAP,kBAAAA,EACAC,YAAAA,EACA12C,MAAAm3C,EACAG,UAAAA,EACAC,SAAAA,EACAT,QAAAA,EACAuC,WAAAA,EACA3E,iBAAAA,EACAqD,YAAAA,EACAM,SAAAA,EACAH,YAAAA,EACArB,cAAAA,EACAsB,mBAAAA,EACAiB,MAAAA,IhE0/YM,SAAUroD,EAAQD,GiE70axB,QAAA8kD,GAAAj7C,EAAAC,GAEA1J,KAAAyJ,EAAAA,EAGAzJ,KAAA0J,EAAAA,EASAg7C,EAAA4E,KAAA,SAAAC,GACA,GAAAC,GAAA,GAAA9E,GAAA9Q,OAAA2V,EAAA9/C,GAAAmqC,OAAA2V,EAAA7/C,GACA,OAAA8/C,IAQA9E,EAAA+E,UAAA,SAAAztC,GAEA,IAAA,GADAmpC,MACAl/C,EAAA,EAAoBA,EAAA+V,EAAA9V,OAAaD,IACjCk/C,EAAAr9C,KAAA48C,EAAA4E,KAAAttC,EAAA/V,IAEA,OAAAk/C,IAQAT,EAAAwC,WAAA,SAAAlrC,GAEA,IAAA,GADAmpC,MACAl/C,EAAA,EAAoBA,EAAA+V,EAAA9V,OAAaD,IACjCk/C,EAAAr9C,KAAAkU,EAAA/V,GAAAgF,QAEA,OAAAk6C,IAGAT,EAAArhD,WACA0R,YAAA2vC,EAEA5wC,UAAA,SAAA7E,GACA,GAAAy6C,GAAA1pD,KAAAyJ,EACAkgD,EAAA3pD,KAAA0J,CACA1J,MAAAyJ,EAAAwF,EAAA,GAAA,GAAAy6C,EAAAz6C,EAAA,GAAA,GAAA06C,EAAA16C,EAAA,GAAA,GACAjP,KAAA0J,EAAAuF,EAAA,GAAA,GAAAy6C,EAAAz6C,EAAA,GAAA,GAAA06C,EAAA16C,EAAA,GAAA,IAMA26C,OAAA,SAAAC,GACA,MAAAA,aAAAnF,KAGA1kD,KAAAyJ,GAAAogD,EAAApgD,GACAzJ,KAAA0J,GAAAmgD,EAAAngD,IAKAuB,MAAA,WACA,GAAAu+C,GAAA,GAAA9E,GAAA1kD,KAAAyJ,EAAAzJ,KAAA0J,EACA,OAAA8/C,IAGA5kD,IAAA,SAAA26C,GAGA,MAFAv/C,MAAAyJ,EAAAzJ,KAAAyJ,EAAA81C,EAAA91C,EACAzJ,KAAA0J,EAAA1J,KAAA0J,EAAA61C,EAAA71C,EACA1J,MAQA8pD,KAAA,SAAArgD,EAAAC,EAAAkpC,GACA,GAAA3lB,GAAAle,KAAA+P,KAAA/P,KAAA2nB,IAAA12B,KAAAyJ,EAAAA,EAAA,GAAAsF,KAAA2nB,IAAA12B,KAAA0J,EAAAA,EAAA,GAEA,OAAAujB,IAAA2lB,GAGAsR,SAAA,SAAAz6C,EAAAC,GACA,MAAA1J,MAAAyJ,GAAAA,GAAAzJ,KAAA0J,GAAAA,GAGA0Q,SAAA,WACA,MAAA,IAAApa,KAAAyJ,EAAA,IAAAzJ,KAAA0J,EAAA,KAGAqgD,UAAA,WACA,OAAA/pD,QAGAH,EAAAD,QAAA8kD,GjEi2aM,SAAU7kD,EAAQD,GkEz8axB,QAAAuK,GAAA65C,EAAAC,GAEAjkD,KAAAgkD,WAAAA,EAGAhkD,KAAAikD,SAAAA,EAGAjkD,KAAAgqD,MAAA,OAOA7/C,EAAAm/C,KAAA,SAAAC,GACA,GAAAU,GAAA,GAAA9/C,GACAu6C,MAAA4E,KAAAC,EAAAvF,YACAU,MAAA4E,KAAAC,EAAAtF,UAGA,OAAAgG,IAGA9/C,EAAA9G,WACA6mD,WAAA//C,EAIAc,MAAA,WACA,GAAAwlB,GAAA,GAAAtmB,GAAAnK,KAAAgkD,WAAA/4C,QAAAjL,KAAAikD,SAAAh5C,QACA,OAAAwlB,IAGAm5B,OAAA,SAAAO,GACA,SAAAA,YAAAhgD,MAGAnK,KAAAgkD,WAAA4F,OAAAO,EAAAnG,aACAhkD,KAAAikD,SAAA2F,OAAAO,EAAAlG,YAQAC,SAAA,SAAAz6C,EAAAC,GAEA,GAAAqF,KAAAqV,IAAApkB,KAAAgkD,WAAAv6C,EAAAzJ,KAAAikD,SAAAx6C,IAAAA,GACAA,GAAAsF,KAAAiD,IAAAhS,KAAAgkD,WAAAv6C,EAAAzJ,KAAAikD,SAAAx6C,IACAsF,KAAAqV,IAAApkB,KAAAgkD,WAAAt6C,EAAA1J,KAAAikD,SAAAv6C,IAAAA,GACAA,GAAAqF,KAAAiD,IAAAhS,KAAAgkD,WAAAt6C,EAAA1J,KAAAikD,SAAAv6C,GAAA,CAGA,GAAA1J,KAAAgkD,WAAAv6C,GAAAzJ,KAAAikD,SAAAx6C,EACA,MAAAA,IAAAzJ,KAAAgkD,WAAAv6C,CAEA,IAAAgiB,IAAAzrB,KAAAikD,SAAAv6C,EAAA1J,KAAAgkD,WAAAt6C,IAAA1J,KAAAikD,SAAAx6C,EAAAzJ,KAAAgkD,WAAAv6C,GACA8iB,EAAAvsB,KAAAgkD,WAAAt6C,EAAA+hB,EAAAzrB,KAAAgkD,WAAAv6C,CACA,OAAAC,IAAA+hB,EAAAhiB,EAAA8iB,EAGA,OAAA,GAYAu9B,KAAA,SAAArgD,EAAAC,EAAAkpC,GAEA,GAAA5yC,KAAAikD,SAAAx6C,IAAAzJ,KAAAgkD,WAAAv6C,EACA,OAAAzJ,KAAAgkD,WAAAt6C,EAAAkpC,GAAAlpC,GAAA1J,KAAAikD,SAAAv6C,EAAAkpC,GAAAlpC,GACA1J,KAAAikD,SAAAv6C,EAAAkpC,GAAAlpC,GAAA1J,KAAAgkD,WAAAt6C,EAAAkpC,GAAAlpC,IACAD,EAAAzJ,KAAAgkD,WAAAv6C,EAAAmpC,GAAAnpC,EAAAzJ,KAAAgkD,WAAAv6C,EAAAmpC,CAGA,IAAA5yC,KAAAgkD,WAAAt6C,IAAA1J,KAAAikD,SAAAv6C,EACA,OAAA1J,KAAAgkD,WAAAv6C,EAAAmpC,GAAAnpC,GAAAzJ,KAAAikD,SAAAx6C,EAAAmpC,GAAAnpC,GACAzJ,KAAAikD,SAAAx6C,EAAAmpC,GAAAnpC,GAAAzJ,KAAAgkD,WAAAv6C,EAAAmpC,GAAAnpC,IACAC,EAAA1J,KAAAgkD,WAAAt6C,EAAAkpC,GAAAlpC,EAAA1J,KAAAgkD,WAAAt6C,EAAAkpC,CAIA,IAAAwX,GAAAr7C,KAAAqV,IAAApkB,KAAAikD,SAAAx6C,EAAAzJ,KAAAgkD,WAAAv6C,GACA4gD,EAAAt7C,KAAAqV,IAAApkB,KAAAikD,SAAAv6C,EAAA1J,KAAAgkD,WAAAt6C,GACA4gD,EAAAv7C,KAAAiD,IAAAhS,KAAAikD,SAAAx6C,EAAAzJ,KAAAgkD,WAAAv6C,GACA8gD,EAAAx7C,KAAAiD,IAAAhS,KAAAikD,SAAAv6C,EAAA1J,KAAAgkD,WAAAt6C,GAQA+hB,EAAAzrB,KAAAikD,SAAAv6C,EAAA1J,KAAAgkD,WAAAt6C,EACA6iB,EAAAvsB,KAAAgkD,WAAAv6C,EAAAzJ,KAAAikD,SAAAx6C,EACAhJ,IAAAT,KAAAgkD,WAAAv6C,EAAAzJ,KAAAikD,SAAAv6C,EAAA1J,KAAAikD,SAAAx6C,EAAAzJ,KAAAgkD,WAAAt6C,GAGAsjB,EAAAje,KAAAoF,KAAAsX,EAAAhiB,EAAA8iB,EAAA7iB,EAAAjJ,GAAAsO,KAAA+P,KAAA/P,KAAA2nB,IAAAjL,EAAA,GAAA1c,KAAA2nB,IAAAnK,EAAA,KAIAi+B,GAAAj+B,GAAAA,EAAA9iB,EAAAgiB,EAAA/hB,GAAA+hB,EAAAhrB,IAAAsO,KAAA2nB,IAAAjL,EAAA,GAAA1c,KAAA2nB,IAAAnK,EAAA,IACAk+B,GAAAh/B,IAAAc,EAAA9iB,EAAAgiB,EAAA/hB,GAAA6iB,EAAA9rB,IAAAsO,KAAA2nB,IAAAjL,EAAA,GAAA1c,KAAA2nB,IAAAnK,EAAA,IAEAlI,EAAA2I,GAAA4lB,GAAA0X,GAAAE,GAAAA,GAAAJ,GAAAG,GAAAE,GAAAA,GAAAJ,GACArqD,KAAAgkD,WAAA8F,KAAArgD,EAAAC,EAAAkpC,IAAA5yC,KAAAikD,SAAA6F,KAAArgD,EAAAC,EAAAkpC,EAEA,OAAAvuB,IAKA0lC,UAAA,WACA,GAAAvS,KAGA,OAFAA,GAAA1vC,KAAA9H,KAAAgkD,YACAxM,EAAA1vC,KAAA9H,KAAAikD,UACAzM,GAKAkT,SAAA,SAAAr9B,GACA,GAAAs9B,GAAAt9B,GAAArtB,KAAAikD,SAAAx6C,EAAAzJ,KAAAgkD,WAAAv6C,GAAAzJ,KAAAgkD,WAAAv6C,EACAmhD,EAAAv9B,GAAArtB,KAAAikD,SAAAv6C,EAAA1J,KAAAgkD,WAAAt6C,GAAA1J,KAAAgkD,WAAAt6C,CAEA,OAAA,IAAAg7C,OAAAiG,EAAAC,IAyBAxwC,SAAA,WACA,MAAA,QAAApa,KAAAgkD,WAAA,IAAAhkD,KAAAikD,SAAA,MAGApkD,EAAAD,QAAAuK,GlE69aM,SAAUtK,EAAQD,EAASM,GmE3objC,YAUA,SAAAkC,GAAAyoD,GACA9nD,EAAAwJ,KAAAu+C,EAAA,SAAApjD,GACA1H,KAAA0H,GAAA3E,EAAAkE,KAAA4jD,EAAAnjD,GAAAmjD,IACS7qD,MAVT,GAAA+C,GAAA7C,EAAA,GAEA4qD,GACA,SAAA,QAAA,WAAA,YAAA,iBACA,KAAA,MAAA,UAAA,aAAA,sBAAA,WAAA,YASAjrD,GAAAD,QAAAwC,GnEmpbM,SAAUvC,EAAQD,EAASM,GoEpnbjC,QAAA8B,GAAApB,EAAAC,GACA,GAAA2nB,GAAA,GAAAuiC,GAAAvjC,IAAA5mB,EAAAC,EAEA,OADAgD,GAAA2kB,EAAAnoB,IAAAmoB,EACAA,EAQA,QAAA5kB,GAAA4kB,GACA,GAAAA,EACAA,EAAA5kB,cACG,CACH,IAAA,GAAAmI,KAAAlI,GACAA,EAAAsJ,eAAApB,IACAlI,EAAAkI,GAAAnI,SAIAC,MAGA,MAAA7D,MASA,QAAAgrD,GAAA3qD,GACA,MAAAwD,GAAAxD,GAGA,QAAA4qD,GAAAvjD,EAAAoN,GACAo2C,EAAAxjD,GAAAoN,EAGA,QAAAq2C,GAAA9qD,SACAwD,GAAAxD,GAzFA,GAAAmnB,GAAAtnB,EAAA,IAEA28C,EAAA38C,EAAA,IAEA6C,EAAA7C,EAAA,GAEAkrD,EAAAlrD,EAAA,IAEAmrD,EAAAnrD,EAAA,IAEAorD,EAAAprD,EAAA,IAEAqrD,EAAArrD,EAAA,IAEAsrD,EAAAtrD,EAAA,IAWAurD,GAAA5O,EAAAc,gBACAuN,GACAQ,OAAAJ,GAEAznD,KAMA4H,EAAA,QAyEAs/C,EAAA,SAAA1qD,EAAAO,EAAAC,GACAA,EAAAA,MAKAb,KAAAY,IAAAA,EAKAZ,KAAAK,GAAAA,CACA,IAAA0zB,GAAA/zB,KACAw7C,EAAA,GAAA6P,GACAM,EAAA9qD,EAAAoB,QAEA,IAAAwpD,EAAA,CACA,IAAAP,EAAAU,IACA,KAAA,IAAAjgD,OAAA,uDAGAggD,GAAA,UACGA,IAAAT,EAAAS,KACHA,EAAA,SAGA,IAAAE,GAAA,GAAAX,GAAAS,GAAA/qD,EAAA46C,EAAA36C,EACAb,MAAAw7C,QAAAA,EACAx7C,KAAA6rD,QAAAA,CACA,IAAAC,GAAAjP,EAAAr1C,KAAA,KAAA,GAAAgkD,GAAAK,EAAAE,kBACA/rD,MAAAopB,QAAA,GAAAgiC,GAAA5P,EAAAqQ,EAAAC,EAAAD,EAAAnsD,MAKAM,KAAA6oB,UAAA,GAAA0iC,IACAS,OACA7jC,OAAAplB,EAAAkE,KAAAjH,KAAAisD,MAAAjsD,SAGAA,KAAA6oB,UAAA8F,QAMA3uB,KAAAksD,aAGA,IAAAC,GAAA3Q,EAAAG,eACAyQ,EAAA5Q,EAAAC,YAEAD,GAAAG,eAAA,SAAAlvC,GACA0/C,EAAA5rD,KAAAi7C,EAAA/uC,GACAA,GAAAA,EAAAkc,iBAAAoL,IAGAynB,EAAAC,aAAA,SAAAhvC,GACA2/C,EAAA7rD,KAAAi7C,EAAA/uC,GACAA,EAAAgc,YAAAsL,IAIAg3B,GAAA1nD,WACA0R,YAAAg2C,EAMAsB,MAAA,WACA,MAAArsD,MAAAK,IAOAuE,IAAA,SAAA6H,GACAzM,KAAAw7C,QAAA8Q,QAAA7/C,GACAzM,KAAAksD,eAAA,GAOAhoD,OAAA,SAAAuI,GACAzM,KAAAw7C,QAAA+Q,QAAA9/C,GACAzM,KAAAksD,eAAA,GAWAM,YAAA,SAAAC,EAAAC,GACA1sD,KAAA6rD,QAAAW,YAAAC,EAAAC,GACA1sD,KAAAksD,eAAA,GAMAS,mBAAA,WAIA3sD,KAAAksD,eAAA,EACAlsD,KAAA6rD,QAAA1pC,UAKAniB,KAAAksD,eAAA,GAUA/pC,QAAA,WACAniB,KAAAksD,eAAA,GAMAD,MAAA,WACAjsD,KAAAksD,eACAlsD,KAAA2sD,qBAGA3sD,KAAA4sD,oBACA5sD,KAAA6sD,2BASAC,SAAA,SAAArgD,EAAAzF,GACAhH,KAAA6rD,QAAAiB,WACA9sD,KAAA6rD,QAAAiB,SAAArgD,EAAAzF,GACAhH,KAAA+sD,iBAQAC,YAAA,SAAAvgD,GACAzM,KAAA6rD,QAAAmB,cACAhtD,KAAA6rD,QAAAmB,YAAAvgD,GACAzM,KAAA+sD,iBAQAE,WAAA,WACAjtD,KAAA6rD,QAAAoB,aACAjtD,KAAA6rD,QAAAoB,aACAjtD,KAAA+sD,iBAOAA,aAAA,WACA/sD,KAAA4sD,oBAAA,GAMAC,wBAAA,WACA7sD,KAAA4sD,oBAAA,EACA5sD,KAAA6rD,QAAAkB,cAAA/sD,KAAA6rD,QAAAkB,gBAUAjpD,OAAA,SAAAjD,GACAA,EAAAA,MACAb,KAAA6rD,QAAA/nD,OAAAjD,EAAAgI,MAAAhI,EAAAiI,QACA9I,KAAAopB,QAAAtlB,UAMAopD,eAAA,WACAltD,KAAA6oB,UAAAljB,SAMAnC,SAAA,WACA,MAAAxD,MAAA6rD,QAAAroD,YAMAC,UAAA,WACA,MAAAzD,MAAA6rD,QAAApoD,aAsBA0pD,YAAA,SAAAnpD,EAAAsmB,GACA,MAAAtqB,MAAA6rD,QAAAsB,YAAAnpD,EAAAsmB,IAOA8iC,eAAA,SAAAC,GACArtD,KAAAopB,QAAAgkC,eAAAC,IASAzS,UAAA,SAAAnxC,EAAAC,GACA,MAAA1J,MAAAopB,QAAAwxB,UAAAnxC,EAAAC,IAUA5E,GAAA,SAAAwoD,EAAAC,EAAArlD,GACAlI,KAAAopB,QAAAtkB,GAAAwoD,EAAAC,EAAArlD,IAQAgV,IAAA,SAAAowC,EAAAC,GACAvtD,KAAAopB,QAAAlM,IAAAowC,EAAAC,IASAnoD,QAAA,SAAAkoD,EAAApoD,GACAlF,KAAAopB,QAAAhkB,QAAAkoD,EAAApoD,IAMAS,MAAA,WACA3F,KAAAw7C,QAAA+Q,UACAvsD,KAAA6rD,QAAAlmD,SAMA/B,QAAA,WACA5D,KAAA6oB,UAAAsF,OACAnuB,KAAA2F,QACA3F,KAAAw7C,QAAA53C,UACA5D,KAAA6rD,QAAAjoD,UACA5D,KAAAopB,QAAAxlB,UACA5D,KAAA6oB,UAAA7oB,KAAAw7C,QAAAx7C,KAAA6rD,QAAA7rD,KAAAopB,QAAA,KACA+hC,EAAAnrD,KAAAK,MAGAT,EAAA6L,QAAAA,EACA7L,EAAAoC,KAAAA,EACApC,EAAAgE,QAAAA,EACAhE,EAAAorD,YAAAA,EACAprD,EAAAqrD,gBAAAA,GpEyqbM,SAAUprD,EAAQD,EAASM,GqExkcjC,QAAAstD,GAAAC,EAAAC,EAAAxoD,GACA,OACAC,KAAAsoD,EACAvoD,MAAAA,EAEAd,OAAAspD,EAAAtpD,OAEAg2C,UAAAsT,EAAAtT,UACAuT,cAAA,EACApT,QAAAr1C,EAAA0oD,IACAnT,QAAAv1C,EAAA2oD,IACAC,aAAA5oD,EAAA4oD,aACAC,OAAA7oD,EAAA6oD,OACAC,OAAA9oD,EAAA8oD,OACAC,WAAA/oD,EAAA+oD,WACAC,WAAAhpD,EAAAipD,QACAC,UAAAlpD,EAAAkpD,UACAC,MAAAnpD,EAAAmpD,OAIA,QAAAC,MA6PA,QAAAC,GAAAC,EAAA/kD,EAAAC,GACA,GAAA8kD,EAAAA,EAAAhrC,UAAA,cAAA,WAAA/Z,EAAAC,GAAA,CAIA,IAHA,GACA6f,GADA9c,EAAA+hD,EAGA/hD,GAAA,CAIA,GAAAA,EAAAmb,WAAAnb,EAAAmb,SAAA/F,QAAApY,EAAAC,GACA,OAAA,CAGA+C,GAAA6W,SACAiG,GAAA,GAGA9c,EAAAA,EAAArG,OAGA,OAAAmjB,GAAAklC,EAGA,OAAA,EA1TA,GAAApiD,GAAAnM,EAAA,GAEAkuC,EAAAluC,EAAA,IAEAiP,EAAAjP,EAAA,IAEA4C,EAAA5C,EAAA,IASAuuD,EAAA,QAyBAH,GAAAjrD,UAAAO,QAAA,YAEA,IAAA8qD,IAAA,QAAA,WAAA,aAAA,WAAA,UAAA,YAAA,YAAA,eAWAtD,EAAA,SAAA5P,EAAAqQ,EAAA8C,EAAAC,GACA9rD,EAAAvC,KAAAP,MACAA,KAAAw7C,QAAAA,EACAx7C,KAAA6rD,QAAAA,EACA7rD,KAAA4uD,YAAAA,EACAD,EAAAA,GAAA,GAAAL,GAKAtuD,KAAA2uD,MAAAA,EAEAA,EAAAvlC,QAAAppB,KAOAA,KAAA6uD,YAMA7uD,KAAA8uD,iBAMA9uD,KAAA+uD,OAMA/uD,KAAAgvD,OACA7/C,EAAA5O,KAAAP,MACAqM,EAAAE,KAAAmiD,EAAA,SAAAhnD,GACAinD,EAAA7pD,IAAA6pD,EAAA7pD,GAAA4C,EAAA1H,KAAA0H,GAAA1H,OACGA,MAGHorD,GAAA/nD,WACA0R,YAAAq2C,EACA6D,UAAA,SAAA/pD,GACA,GAAAuE,GAAAvE,EAAA0oD,IACAlkD,EAAAxE,EAAA2oD,IACAqB,EAAAlvD,KAAA6uD,SACAM,EAAAD,EAAA9qD,MAKA+qD,KAAAA,EAAAjtC,OACAgtC,EAAAlvD,KAAA46C,UAAAsU,EAAAzlD,EAAAylD,EAAAxlD,GACAylD,EAAAD,EAAA9qD,OAGA,IAAAgrD,GAAApvD,KAAA6uD,SAAA7uD,KAAA46C,UAAAnxC,EAAAC,GACA2lD,EAAAD,EAAAhrD,OACAuqD,EAAA3uD,KAAA2uD,KACAA,GAAAW,WAAAX,EAAAW,UAAAD,EAAAA,EAAArmD,OAAA,WAEAmmD,GAAAE,IAAAF,GACAnvD,KAAA06C,kBAAAwU,EAAA,WAAAhqD,GAIAlF,KAAA06C,kBAAA0U,EAAA,YAAAlqD,GAEAmqD,GAAAA,IAAAF,GACAnvD,KAAA06C,kBAAA0U,EAAA,YAAAlqD,IAGAqqD,SAAA,SAAArqD,GACAlF,KAAA06C,kBAAA16C,KAAA6uD,SAAA,WAAA3pD,EAMA,IACAsqD,GADAC,EAAAvqD,EAAAwqD,WAAAxqD,EAAAyqD,aAGA,GACAF,GAAAA,GAAAA,EAAAG,iBACKH,GAAA,GAAAA,EAAA73C,YAAA43C,EAAAC,IAAAzvD,KAAA4uD,eAELY,GAAAxvD,KAAAoF,QAAA,aACAF,MAAAA,KAOApB,OAAA,SAAAoB,GACAlF,KAAA6uD,aAQAgB,SAAA,SAAAvC,EAAAwC,GACA,GAAA1mC,GAAAppB,KAAAstD,EACAlkC,IAAAA,EAAA7oB,KAAAP,KAAA8vD,IAMAlsD,QAAA,WACA5D,KAAA2uD,MAAA/qD,UACA5D,KAAAw7C,QAAAx7C,KAAA2uD,MAAA3uD,KAAA6rD,QAAA,MAOAuB,eAAA,SAAAC,GACA,GAAAsB,GAAA3uD,KAAA2uD,KACAA,GAAAW,WAAAX,EAAAW,UAAAjC,IAWA3S,kBAAA,SAAAgT,EAAAJ,EAAApoD,GACAwoD,EAAAA,KACA,IAAAjhD,GAAAihD,EAAAtpD,MAEA,KAAAqI,IAAAA,EAAA6W,OAAA,CAOA,IAHA,GAAAiqC,GAAA,KAAAD,EACAyC,EAAAvC,EAAAF,EAAAI,EAAAxoD,GAEAuH,IACAA,EAAA8gD,KAAAwC,EAAApC,aAAAlhD,EAAA8gD,GAAAhtD,KAAAkM,EAAAsjD,IACAtjD,EAAArH,QAAAkoD,EAAAyC,GACAtjD,EAAAA,EAAArG,QAEA2pD,EAAApC,gBAKAoC,EAAApC,eAEA3tD,KAAAoF,QAAAkoD,EAAAyC,GAGA/vD,KAAA6rD,SAAA7rD,KAAA6rD,QAAAmE,eAAA,SAAAC,GACA,kBAAAA,GAAA1C,IACA0C,EAAA1C,GAAAhtD,KAAA0vD,EAAAF,GAGAE,EAAA7qD,SACA6qD,EAAA7qD,QAAAkoD,EAAAyC,QAcAnV,UAAA,SAAAnxC,EAAAC,EAAAu+C,GAOA,IAAA,GANAviB,GAAA1lC,KAAAw7C,QAAA0U,iBACAplC,GACArhB,EAAAA,EACAC,EAAAA,GAGAzD,EAAAy/B,EAAAx/B,OAAA,EAAiCD,GAAA,EAAQA,IAAA,CACzC,GAAAkqD,EAEA,IAAAzqB,EAAAz/B,KAAAgiD,IACAviB,EAAAz/B,GAAA0hB,SAAAwoC,EAAA5B,EAAA7oB,EAAAz/B,GAAAwD,EAAAC,OACAohB,EAAAsvB,YAAAtvB,EAAAsvB,UAAA1U,EAAAz/B,IAEAkqD,IAAA1B,GAAA,CACA3jC,EAAA1mB,OAAAshC,EAAAz/B,EACA,QAKA,MAAA6kB,KAIAze,EAAAE,MAAA,QAAA,YAAA,UAAA,aAAA,WAAA,eAAA,SAAA7E,GACA0jD,EAAA/nD,UAAAqE,GAAA,SAAAxC,GAEA,GAAAkqD,GAAApvD,KAAA46C,UAAA11C,EAAA0oD,IAAA1oD,EAAA2oD,KACAwB,EAAAD,EAAAhrD,MAEA,IAAA,cAAAsD,EACA1H,KAAAowD,QAAAf,EACArvD,KAAAqwD,YAAAnrD,EAAA0oD,IAAA1oD,EAAA2oD,KAEA7tD,KAAAswD,MAAAjB,MACK,IAAA,YAAA3nD,EACL1H,KAAAswD,MAAAjB,MACK,IAAA,UAAA3nD,EAAA,CACL,GAAA1H,KAAAowD,UAAApwD,KAAAswD,QAIAtwD,KAAAqwD,YACAjiB,EAAA7gB,KAAAvtB,KAAAqwD,YAAAnrD,EAAA0oD,IAAA1oD,EAAA2oD,MAAA,EACA,MAGA7tD,MAAAqwD,WAAA,KAGArwD,KAAA06C,kBAAA0U,EAAA1nD,EAAAxC,MA8BAmH,EAAAjB,MAAAggD,EAAAtoD,GACAuJ,EAAAjB,MAAAggD,EAAAj8C,EACA,IAAA2T,GAAAsoC,CACAvrD,GAAAD,QAAAkjB,GrE+lcM,SAAUjjB,EAAQD,EAASM,GsE94cjC,QAAAqwD,GAAA9kC,EAAAc,GACA,MAAAd,GAAArI,SAAAmJ,EAAAnJ,OACAqI,EAAAxiB,IAAAsjB,EAAAtjB,EAOAwiB,EAAAne,GAAAif,EAAAjf,GAGAme,EAAAxiB,EAAAsjB,EAAAtjB,EAGAwiB,EAAArI,OAAAmJ,EAAAnJ,OAhCA,GAAA/W,GAAAnM,EAAA,GAEA28C,EAAA38C,EAAA,IAEAwE,EAAAxE,EAAA,IAEAswD,EAAAtwD,EAAA,IAmCAmrD,EAAA,WAEArrD,KAAAywD,UACAzwD,KAAA0wD,gBACA1wD,KAAA2wD,gBAAA,EAGAtF,GAAAhoD,WACA0R,YAAAs2C,EAMA39C,SAAA,SAAAzF,EAAAC,GACA,IAAA,GAAAjC,GAAA,EAAmBA,EAAAjG,KAAAywD,OAAAvqD,OAAwBD,IAC3CjG,KAAAywD,OAAAxqD,GAAAyH,SAAAzF,EAAAC,IAYAgoD,eAAA,SAAA/nC,EAAAyoC,GAOA,MANAA,GAAAA,IAAA,EAEAzoC,GACAnoB,KAAA6wD,kBAAAD,GAGA5wD,KAAA0wD,cASAG,kBAAA,SAAAD,GACA5wD,KAAA2wD,gBAAA,CAIA,KAAA,GAHA9b,GAAA70C,KAAAywD,OACAK,EAAA9wD,KAAA0wD,aAEAzqD,EAAA,EAAA2O,EAAAigC,EAAA3uC,OAAuCD,EAAA2O,EAAS3O,IAChDjG,KAAA+wD,yBAAAlc,EAAA5uC,GAAA,KAAA2qD,EAGAE,GAAA5qD,OAAAlG,KAAA2wD,gBAKA9T,EAAAc,iBAAA6S,EAAAM,EAAAP,IAEAQ,yBAAA,SAAAtkD,EAAAwwC,EAAA2T,GACA,IAAAnkD,EAAAkb,QAAAipC,EAAA,CAIAnkD,EAAAwb,eAEAxb,EAAA0T,SACA1T,EAAA0b,SAGA1b,EAAAyb,aACA,IAAA8oC,GAAAvkD,EAAAmb,QAEA,IAAAopC,EAAA,CAGA/T,EADAA,EACAA,EAAA3kC,UAQA,KAHA,GAAA24C,GAAAD,EACAE,EAAAzkD,EAEAwkD,GAEAA,EAAA7qD,OAAA8qD,EACAD,EAAA7oC,kBACA60B,EAAAn1C,KAAAmpD,GACAC,EAAAD,EACAA,EAAAA,EAAArpC,SAIA,GAAAnb,EAAAwuC,QAAA,CAGA,IAAA,GAFAC,GAAAzuC,EAAAsuC,UAEA90C,EAAA,EAAqBA,EAAAi1C,EAAAh1C,OAAqBD,IAAA,CAC1C,GAAAmC,GAAA8yC,EAAAj1C,EAGAwG,GAAA0T,UACA/X,EAAA+X,SAAA,GAGAngB,KAAA+wD,yBAAA3oD,EAAA60C,EAAA2T,GAIAnkD,EAAA0T,SAAA,MAEA1T,GAAAwW,YAAAg6B,EACAj9C,KAAA0wD,aAAA1wD,KAAA2wD,mBAAAlkD,IAQA6/C,QAAA,SAAA7/C,GACAA,EAAAuuC,YAAAh7C,OAIAyM,YAAA/H,IACA+H,EAAAivC,qBAAA17C,MAGAA,KAAAy7C,aAAAhvC,GAEAzM,KAAAywD,OAAA3oD,KAAA2E,KAOA8/C,QAAA,SAAA9/C,GACA,GAAA,MAAAA,EAAA,CAEA,IAAA,GAAAxG,GAAA,EAAqBA,EAAAjG,KAAAywD,OAAAvqD,OAAwBD,IAAA,CAC7C,GAAAvG,GAAAM,KAAAywD,OAAAxqD,EAEAvG,aAAAgF,IACAhF,EAAAk8C,uBAAA57C,MAOA,MAHAA,MAAAywD,UACAzwD,KAAA0wD,qBACA1wD,KAAA2wD,gBAAA,GAIA,GAAAlkD,YAAA6N,OACA,IAAA,GAAArU,GAAA,EAAAwjB,EAAAhd,EAAAvG,OAAoCD,EAAAwjB,EAAOxjB,IAC3CjG,KAAAusD,QAAA9/C,EAAAxG,QAFA,CAQA,GAAAqtC,GAAAjnC,EAAAsG,QAAA3S,KAAAywD,OAAAhkD,EAEA6mC,IAAA,IACAtzC,KAAA27C,eAAAlvC,GAEAzM,KAAAywD,OAAAjqD,OAAA8sC,EAAA,GAEA7mC,YAAA/H,IACA+H,EAAAmvC,uBAAA57C,SAIAy7C,aAAA,SAAAhvC,GAGA,MAFAA,GAAAuuC,UAAAh7C,KACAyM,EAAA6R,OAAA,GACAte,MAEA27C,eAAA,SAAAlvC,GAKA,MAJAA,KACAA,EAAAuuC,UAAA,MAGAh7C,MAMA4D,QAAA,WACA5D,KAAAmxD,YAAAnxD,KAAAywD,OAAA,MAEAW,oBAAAb,EAEA,IAAAztC,GAAAuoC,CACAxrD,GAAAD,QAAAkjB,GtEq6cM,SAAUjjB,EAAQD,GuE/odxB,QAAAyxD,GAAAh1C,GAGA,IAFA,GAAAgI,GAAA,EAEAhI,GAAAi1C,GACAjtC,GAAA,EAAAhI,EACAA,IAAA,CAGA,OAAAA,GAAAgI,EAGA,QAAAktC,GAAAx7C,EAAAy7C,EAAAC,EAAAC,GACA,GAAAC,GAAAH,EAAA,CAEA,IAAAG,IAAAF,EACA,MAAA,EAGA,IAAAC,EAAA37C,EAAA47C,KAAA57C,EAAAy7C,IAAA,EAAA,CACA,KAAAG,EAAAF,GAAAC,EAAA37C,EAAA47C,GAAA57C,EAAA47C,EAAA,IAAA,GACAA,GAGAC,GAAA77C,EAAAy7C,EAAAG,OAEA,MAAAA,EAAAF,GAAAC,EAAA37C,EAAA47C,GAAA57C,EAAA47C,EAAA,KAAA,GACAA,GAIA,OAAAA,GAAAH,EAGA,QAAAI,GAAA77C,EAAAy7C,EAAAC,GAGA,IAFAA,IAEAD,EAAAC,GAAA,CACA,GAAApkC,GAAAtX,EAAAy7C,EACAz7C,GAAAy7C,KAAAz7C,EAAA07C,GACA17C,EAAA07C,KAAApkC,GAIA,QAAAwkC,GAAA97C,EAAAy7C,EAAAC,EAAA9iC,EAAA+iC,GAKA,IAJA/iC,IAAA6iC,GACA7iC,IAGQA,EAAA8iC,EAAY9iC,IAAA,CAMpB,IALA,GAGAmjC,GAHAC,EAAAh8C,EAAA4Y,GACAgc,EAAA6mB,EACA5mB,EAAAjc,EAGAgc,EAAAC,GACAknB,EAAAnnB,EAAAC,IAAA,EAEA8mB,EAAAK,EAAAh8C,EAAA+7C,IAAA,EACAlnB,EAAAknB,EAEAnnB,EAAAmnB,EAAA,CAIA,IAAAz1C,GAAAsS,EAAAgc,CAEA,QAAAtuB,GACA,IAAA,GACAtG,EAAA40B,EAAA,GAAA50B,EAAA40B,EAAA,EAEA,KAAA,GACA50B,EAAA40B,EAAA,GAAA50B,EAAA40B,EAAA,EAEA,KAAA,GACA50B,EAAA40B,EAAA,GAAA50B,EAAA40B,EACA,MAEA,SACA,KAAAtuB,EAAA,GACAtG,EAAA40B,EAAAtuB,GAAAtG,EAAA40B,EAAAtuB,EAAA,GACAA,IAKAtG,EAAA40B,GAAAonB,GAIA,QAAAC,GAAAh8C,EAAAD,EAAA4Y,EAAAzoB,EAAA+rD,EAAAP,GACA,GAAAQ,GAAA,EACAC,EAAA,EACA7qC,EAAA,CAEA,IAAAoqC,EAAA17C,EAAAD,EAAA4Y,EAAAsjC,IAAA,EAAA,CAGA,IAFAE,EAAAjsD,EAAA+rD,EAEA3qC,EAAA6qC,GAAAT,EAAA17C,EAAAD,EAAA4Y,EAAAsjC,EAAA3qC,IAAA,GACA4qC,EAAA5qC,EACAA,GAAAA,GAAA,GAAA,EAEAA,GAAA,IACAA,EAAA6qC,EAIA7qC,GAAA6qC,IACA7qC,EAAA6qC,GAGAD,GAAAD,EACA3qC,GAAA2qC,MACG,CAGH,IAFAE,EAAAF,EAAA,EAEA3qC,EAAA6qC,GAAAT,EAAA17C,EAAAD,EAAA4Y,EAAAsjC,EAAA3qC,KAAA,GACA4qC,EAAA5qC,EACAA,GAAAA,GAAA,GAAA,EAEAA,GAAA,IACAA,EAAA6qC,EAIA7qC,GAAA6qC,IACA7qC,EAAA6qC,EAGA,IAAA3c,GAAA0c,CACAA,GAAAD,EAAA3qC,EACAA,EAAA2qC,EAAAzc,EAKA,IAFA0c,IAEAA,EAAA5qC,GAAA,CACA,GAAA9mB,GAAA0xD,GAAA5qC,EAAA4qC,IAAA,EAEAR,GAAA17C,EAAAD,EAAA4Y,EAAAnuB,IAAA,EACA0xD,EAAA1xD,EAAA,EAEA8mB,EAAA9mB,EAIA,MAAA8mB,GAGA,QAAA8qC,GAAAp8C,EAAAD,EAAA4Y,EAAAzoB,EAAA+rD,EAAAP,GACA,GAAAQ,GAAA,EACAC,EAAA,EACA7qC,EAAA,CAEA,IAAAoqC,EAAA17C,EAAAD,EAAA4Y,EAAAsjC,IAAA,EAAA,CAGA,IAFAE,EAAAF,EAAA,EAEA3qC,EAAA6qC,GAAAT,EAAA17C,EAAAD,EAAA4Y,EAAAsjC,EAAA3qC,IAAA,GACA4qC,EAAA5qC,EACAA,GAAAA,GAAA,GAAA,EAEAA,GAAA,IACAA,EAAA6qC,EAIA7qC,GAAA6qC,IACA7qC,EAAA6qC,EAGA,IAAA3c,GAAA0c,CACAA,GAAAD,EAAA3qC,EACAA,EAAA2qC,EAAAzc,MACG,CAGH,IAFA2c,EAAAjsD,EAAA+rD,EAEA3qC,EAAA6qC,GAAAT,EAAA17C,EAAAD,EAAA4Y,EAAAsjC,EAAA3qC,KAAA,GACA4qC,EAAA5qC,EACAA,GAAAA,GAAA,GAAA,EAEAA,GAAA,IACAA,EAAA6qC,EAIA7qC,GAAA6qC,IACA7qC,EAAA6qC,GAGAD,GAAAD,EACA3qC,GAAA2qC,EAKA,IAFAC,IAEAA,EAAA5qC,GAAA,CACA,GAAA9mB,GAAA0xD,GAAA5qC,EAAA4qC,IAAA,EAEAR,GAAA17C,EAAAD,EAAA4Y,EAAAnuB,IAAA,EACA8mB,EAAA9mB,EAEA0xD,EAAA1xD,EAAA,EAIA,MAAA8mB,GAGA,QAAA+qC,GAAAt8C,EAAA27C,GAmBA,QAAAY,GAAAC,EAAAC,GACAC,EAAAC,GAAAH,EACAI,EAAAD,GAAAF,EACAE,GAAA,EAGA,QAAAE,KACA,KAAAF,EAAA,GAAA,CACA,GAAAr2C,GAAAq2C,EAAA,CAEA,IAAAr2C,GAAA,GAAAs2C,EAAAt2C,EAAA,IAAAs2C,EAAAt2C,GAAAs2C,EAAAt2C,EAAA,IAAAA,GAAA,GAAAs2C,EAAAt2C,EAAA,IAAAs2C,EAAAt2C,GAAAs2C,EAAAt2C,EAAA,GACAs2C,EAAAt2C,EAAA,GAAAs2C,EAAAt2C,EAAA,IACAA,QAEO,IAAAs2C,EAAAt2C,GAAAs2C,EAAAt2C,EAAA,GACP,KAGAw2C,GAAAx2C,IAIA,QAAAy2C,KACA,KAAAJ,EAAA,GAAA,CACA,GAAAr2C,GAAAq2C,EAAA,CAEAr2C,GAAA,GAAAs2C,EAAAt2C,EAAA,GAAAs2C,EAAAt2C,EAAA,IACAA,IAGAw2C,EAAAx2C,IAIA,QAAAw2C,GAAA5sD,GACA,GAAA8sD,GAAAN,EAAAxsD,GACA+sD,EAAAL,EAAA1sD,GACAgtD,EAAAR,EAAAxsD,EAAA,GACAitD,EAAAP,EAAA1sD,EAAA,EACA0sD,GAAA1sD,GAAA+sD,EAAAE,EAEAjtD,IAAAysD,EAAA,IACAD,EAAAxsD,EAAA,GAAAwsD,EAAAxsD,EAAA,GACA0sD,EAAA1sD,EAAA,GAAA0sD,EAAA1sD,EAAA,IAGAysD,GACA,IAAAj9B,GAAA28B,EAAAr8C,EAAAk9C,GAAAl9C,EAAAg9C,EAAAC,EAAA,EAAAtB,EACAqB,IAAAt9B,EACAu9B,GAAAv9B,EAEA,IAAAu9B,IAIAE,EAAAlB,EAAAj8C,EAAAg9C,EAAAC,EAAA,GAAAj9C,EAAAk9C,EAAAC,EAAAA,EAAA,EAAAxB,GAEA,IAAAwB,IAIAF,GAAAE,EACAC,EAAAJ,EAAAC,EAAAC,EAAAC,GAEAE,EAAAL,EAAAC,EAAAC,EAAAC,KAIA,QAAAC,GAAAJ,EAAAC,EAAAC,EAAAC,GACA,GAAAjtD,GAAA,CAEA,KAAAA,EAAA,EAAeA,EAAA+sD,EAAa/sD,IAC5BuvC,EAAAvvC,GAAA8P,EAAAg9C,EAAA9sD,EAGA,IAAAotD,GAAA,EACAC,EAAAL,EACAM,EAAAR,CAGA,IAFAh9C,EAAAw9C,KAAAx9C,EAAAu9C,KAEA,MAAAJ,EAAA,CAQA,GAAA,IAAAF,EAAA,CACA,IAAA/sD,EAAA,EAAiBA,EAAAitD,EAAajtD,IAC9B8P,EAAAw9C,EAAAttD,GAAA8P,EAAAu9C,EAAArtD,EAIA,aADA8P,EAAAw9C,EAAAL,GAAA1d,EAAA6d,IAOA,IAHA,GACAG,GAAAC,EAAAC,EADAC,EAAAC,IAGA,CACAJ,EAAA,EACAC,EAAA,EACAC,GAAA,CAEA,GACA,IAAAhC,EAAA37C,EAAAu9C,GAAA9d,EAAA6d,IAAA,GAKA,GAJAt9C,EAAAw9C,KAAAx9C,EAAAu9C,KACAG,IACAD,EAAA,EAEA,MAAAN,EAAA,CACAQ,GAAA,CACA,YAOA,IAJA39C,EAAAw9C,KAAA/d,EAAA6d,KACAG,IACAC,EAAA,EAEA,MAAAT,EAAA,CACAU,GAAA,CACA,cAGOF,EAAAC,GAAAE,EAEP,IAAAD,EACA,KAGA,GAAA,CAGA,GAFAF,EAAApB,EAAAr8C,EAAAu9C,GAAA9d,EAAA6d,EAAAL,EAAA,EAAAtB,GAEA,IAAA8B,EAAA,CACA,IAAAvtD,EAAA,EAAqBA,EAAAutD,EAAYvtD,IACjC8P,EAAAw9C,EAAAttD,GAAAuvC,EAAA6d,EAAAptD,EAOA,IAJAstD,GAAAC,EACAH,GAAAG,EACAR,GAAAQ,EAEAR,GAAA,EAAA,CACAU,GAAA,CACA,QAMA,GAFA39C,EAAAw9C,KAAAx9C,EAAAu9C,KAEA,MAAAJ,EAAA,CACAQ,GAAA,CACA,OAKA,GAFAD,EAAAzB,EAAAxc,EAAA6d,GAAAt9C,EAAAu9C,EAAAJ,EAAA,EAAAxB,GAEA,IAAA+B,EAAA,CACA,IAAAxtD,EAAA,EAAqBA,EAAAwtD,EAAYxtD,IACjC8P,EAAAw9C,EAAAttD,GAAA8P,EAAAu9C,EAAArtD,EAOA,IAJAstD,GAAAE,EACAH,GAAAG,EACAP,GAAAO,EAEA,IAAAP,EAAA,CACAQ,GAAA,CACA,QAMA,GAFA39C,EAAAw9C,KAAA/d,EAAA6d,KAEA,MAAAL,EAAA,CACAU,GAAA,CACA,OAGAC,UACOH,GAAAK,GAAAJ,GAAAI,EAEP,IAAAH,EACA,KAGAC,GAAA,IACAA,EAAA,GAGAA,GAAA,EAMA,GAHAC,EAAAD,EACAC,EAAA,IAAAA,EAAA,GAEA,IAAAZ,EAAA,CACA,IAAA/sD,EAAA,EAAiBA,EAAAitD,EAAajtD,IAC9B8P,EAAAw9C,EAAAttD,GAAA8P,EAAAu9C,EAAArtD,EAGA8P,GAAAw9C,EAAAL,GAAA1d,EAAA6d,OACK,CAAA,GAAA,IAAAL,EACL,KAAA,IAAArnD,MAEA,KAAA1F,EAAA,EAAiBA,EAAA+sD,EAAa/sD,IAC9B8P,EAAAw9C,EAAAttD,GAAAuvC,EAAA6d,EAAAptD,QA9HA,KAAAA,EAAA,EAAiBA,EAAA+sD,EAAa/sD,IAC9B8P,EAAAw9C,EAAAttD,GAAAuvC,EAAA6d,EAAAptD,GAkIA,QAAAmtD,GAAAL,EAAAC,EAAAC,EAAAC,GACA,GAAAjtD,GAAA,CAEA,KAAAA,EAAA,EAAeA,EAAAitD,EAAajtD,IAC5BuvC,EAAAvvC,GAAA8P,EAAAk9C,EAAAhtD,EAGA,IAAAotD,GAAAN,EAAAC,EAAA,EACAM,EAAAJ,EAAA,EACAK,EAAAN,EAAAC,EAAA,EACAY,EAAA,EACAC,EAAA,CAGA,IAFAh+C,EAAAw9C,KAAAx9C,EAAAs9C,KAEA,MAAAL,EAAA,CAUA,GAAA,IAAAE,EAAA,CAMA,IALAK,GAAAP,EACAK,GAAAL,EACAe,EAAAR,EAAA,EACAO,EAAAT,EAAA,EAEAptD,EAAA+sD,EAAA,EAA2B/sD,GAAA,EAAQA,IACnC8P,EAAAg+C,EAAA9tD,GAAA8P,EAAA+9C,EAAA7tD,EAIA,aADA8P,EAAAw9C,GAAA/d,EAAA8d,IAMA,IAFA,GAAAK,GAAAC,IAEA,CACA,GAAAJ,GAAA,EACAC,EAAA,EACAC,GAAA,CAEA,GACA,IAAAhC,EAAAlc,EAAA8d,GAAAv9C,EAAAs9C,IAAA,GAKA,GAJAt9C,EAAAw9C,KAAAx9C,EAAAs9C,KACAG,IACAC,EAAA,EAEA,MAAAT,EAAA,CACAU,GAAA,CACA,YAOA,IAJA39C,EAAAw9C,KAAA/d,EAAA8d,KACAG,IACAD,EAAA,EAEA,MAAAN,EAAA,CACAQ,GAAA,CACA,cAGOF,EAAAC,GAAAE,EAEP,IAAAD,EACA,KAGA,GAAA,CAGA,GAFAF,EAAAR,EAAAZ,EAAA5c,EAAA8d,GAAAv9C,EAAAg9C,EAAAC,EAAAA,EAAA,EAAAtB,GAEA,IAAA8B,EAAA,CAOA,IANAD,GAAAC,EACAH,GAAAG,EACAR,GAAAQ,EACAO,EAAAR,EAAA,EACAO,EAAAT,EAAA,EAEAptD,EAAAutD,EAAA,EAA8BvtD,GAAA,EAAQA,IACtC8P,EAAAg+C,EAAA9tD,GAAA8P,EAAA+9C,EAAA7tD,EAGA,IAAA,IAAA+sD,EAAA,CACAU,GAAA,CACA,QAMA,GAFA39C,EAAAw9C,KAAA/d,EAAA8d,KAEA,MAAAJ,EAAA,CACAQ,GAAA,CACA,OAKA,GAFAD,EAAAP,EAAAlB,EAAAj8C,EAAAs9C,GAAA7d,EAAA,EAAA0d,EAAAA,EAAA,EAAAxB,GAEA,IAAA+B,EAAA,CAOA,IANAF,GAAAE,EACAH,GAAAG,EACAP,GAAAO,EACAM,EAAAR,EAAA,EACAO,EAAAR,EAAA,EAEArtD,EAAA,EAAqBA,EAAAwtD,EAAYxtD,IACjC8P,EAAAg+C,EAAA9tD,GAAAuvC,EAAAse,EAAA7tD,EAGA,IAAAitD,GAAA,EAAA,CACAQ,GAAA,CACA,QAMA,GAFA39C,EAAAw9C,KAAAx9C,EAAAs9C,KAEA,MAAAL,EAAA,CACAU,GAAA,CACA,OAGAC,UACOH,GAAAK,GAAAJ,GAAAI,EAEP,IAAAH,EACA,KAGAC,GAAA,IACAA,EAAA,GAGAA,GAAA,EASA,GANAC,EAAAD,EAEAC,EAAA,IACAA,EAAA,GAGA,IAAAV,EAAA,CAMA,IALAK,GAAAP,EACAK,GAAAL,EACAe,EAAAR,EAAA,EACAO,EAAAT,EAAA,EAEAptD,EAAA+sD,EAAA,EAA2B/sD,GAAA,EAAQA,IACnC8P,EAAAg+C,EAAA9tD,GAAA8P,EAAA+9C,EAAA7tD,EAGA8P,GAAAw9C,GAAA/d,EAAA8d,OACK,CAAA,GAAA,IAAAJ,EACL,KAAA,IAAAvnD,MAIA,KAFAmoD,EAAAP,GAAAL,EAAA,GAEAjtD,EAAA,EAAiBA,EAAAitD,EAAajtD,IAC9B8P,EAAA+9C,EAAA7tD,GAAAuvC,EAAAvvC,QAhJA,KAFA6tD,EAAAP,GAAAL,EAAA,GAEAjtD,EAAA,EAAiBA,EAAAitD,EAAajtD,IAC9B8P,EAAA+9C,EAAA7tD,GAAAuvC,EAAAvvC,GAxPA,GAIAwsD,GACAE,EALAiB,EAAAC,EACA3tD,EAAA,EACA8tD,EAAAC,EACAC,EAAA,EAGAxB,EAAA,CACAxsD,GAAA6P,EAAA7P,OAEAA,EAAA,EAAA+tD,IACAD,EAAA9tD,IAAA,EAGA,IAAAsvC,KACA0e,GAAAhuD,EAAA,IAAA,EAAAA,EAAA,KAAA,GAAAA,EAAA,OAAA,GAAA,GACAusD,KACAE,KA4XA3yD,KAAA4yD,UAAAA,EACA5yD,KAAA8yD,eAAAA,EACA9yD,KAAAsyD,QAAAA,EAGA,QAAAvgC,GAAAhc,EAAA27C,EAAAF,EAAAC,GACAD,IACAA,EAAA,GAGAC,IACAA,EAAA17C,EAAA7P,OAGA,IAAAiuD,GAAA1C,EAAAD,CAEA,MAAA2C,EAAA,GAAA,CAIA,GAAAxB,GAAA,CAEA,IAAAwB,EAAA7C,EAGA,MAFAqB,GAAApB,EAAAx7C,EAAAy7C,EAAAC,EAAAC,OACAG,GAAA97C,EAAAy7C,EAAAC,EAAAD,EAAAmB,EAAAjB,EAIA,IAAA0C,GAAA,GAAA/B,GAAAt8C,EAAA27C,GACA2C,EAAAhD,EAAA8C,EAEA,GAAA,CAGA,GAFAxB,EAAApB,EAAAx7C,EAAAy7C,EAAAC,EAAAC,GAEAiB,EAAA0B,EAAA,CACA,GAAAC,GAAAH,CAEAG,GAAAD,IACAC,EAAAD,GAGAxC,EAAA97C,EAAAy7C,EAAAA,EAAA8C,EAAA9C,EAAAmB,EAAAjB,GACAiB,EAAA2B,EAGAF,EAAA9B,QAAAd,EAAAmB,GACAyB,EAAAxB,YACAuB,GAAAxB,EACAnB,GAAAmB,QACG,IAAAwB,EAEHC,GAAAtB,kBAnpBA,GAAAxB,GAAA,GACAuC,EAAA,EACAI,EAAA,GAopBAp0D,GAAAD,QAAAmyB,GvE0pdM,SAAUlyB,EAAQD,EAASM,GwElxejC,QAAAq0D,GAAA97C,GACA,MAAAxO,UAAAwO,EAAA,IAGA,QAAA+7C,GAAAvE,GACA,QAAAA,MAIAA,EAAAwE,aAIA,kBAAAxE,GAAAnsD,QAAA,kBAAAmsD,GAAA9tC,SAOA,QAAAuyC,GAAAzE,GACAA,EAAA0E,gBAGA,QAAAC,GAAA3E,GACA,GAAAA,EAAA0E,eACA1E,EAAAtqD,QAOA,QAAAkvD,GAAApoD,EAAA5D,EAAAC,GASA,MARAo9B,GAAA1kB,KAAA/U,EAAAoE,mBAEApE,EAAAqH,WACAoyB,EAAA90B,eAAA3E,EAAAqH,WAGAghD,EAAAjsD,MAAAA,EACAisD,EAAAhsD,OAAAA,GACAo9B,EAAA8I,UAAA8lB,GAGA,QAAAC,GAAA9X,EAAA+X,GACA,GAAA/X,GAAA+X,EAEA,OAAA,CAGA,KAAA/X,IAAA+X,GAAA/X,EAAA/2C,SAAA8uD,EAAA9uD,OACA,OAAA,CAGA,KAAA,GAAAD,GAAA,EAAiBA,EAAAg3C,EAAA/2C,OAAsBD,IACvC,GAAAg3C,EAAAh3C,KAAA+uD,EAAA/uD,GACA,OAAA,EAKA,QAAAgvD,GAAAhY,EAAA9+B,GACA,IAAA,GAAAlY,GAAA,EAAiBA,EAAAg3C,EAAA/2C,OAAsBD,IAAA,CACvC,GAAA2hB,GAAAq1B,EAAAh3C,EACA2hB,GAAA1H,aAAA/B,GACAA,EAAA2C,YACA8G,EAAA3J,UAAAE,EAAAyJ,EAAAzjB,OACAga,EAAAyU,OAEAhL,EAAA5G,iBAAA7C,IAIA,QAAA+2C,GAAArsD,EAAAC,GACA,GAAAqsD,GAAA3sD,SAAAC,cAAA,MAGA,OADA0sD,GAAAnuD,MAAAouD,SAAA,oBAAA,kBAAA,SAAAvsD,EAAA,KAAA,UAAAC,EAAA,KAAA,YAAA,WAAA,kBAAA+nB,KAAA,KAAyK,IACzKskC,EA7GA,GAAAtvB,GAAA3lC,EAAA,IAEAgC,EAAA2jC,EAAA3jC,iBAEAmK,EAAAnM,EAAA,GAEAwtB,EAAAxtB,EAAA,IAEA8P,EAAA9P,EAAA,IAEAswD,EAAAtwD,EAAA,IAEAm1D,EAAAn1D,EAAA,IAEAo1D,EAAAp1D,EAAA,IAEAoJ,EAAApJ,EAAA,IAaAq1D,EAAA,EAgCArvB,EAAA,GAAAl2B,GAAA,EAAA,EAAA,EAAA,GACA8kD,EAAA,GAAA9kD,GAAA,EAAA,EAAA,EAAA,GA0DAs7C,EAAA,SAAA5rD,EAAA87C,EAAA36C,GACAb,KAAAmF,KAAA,QAEA,IAAAqwD,IAAA91D,EAAA+1D,UACA,WAAA/1D,EAAA+1D,SAAAC,aACA11D,MAAA21D,MAAA90D,EAAAwL,EAAA8D,UAAoCtP,OAKpCb,KAAAsqB,IAAAzpB,EAAAqB,kBAAAA,EAMAlC,KAAA41D,cAAAJ,EAMAx1D,KAAAN,KAAAA,CACA,IAAAm2D,GAAAn2D,EAAAsH,KAEA6uD,KACAA,EAAA,+BAAA,cACAA,EAAA,uBAAAA,EAAA,eAAAA,EAAA,yBAAA,OACAn2D,EAAAo2D,UAAA,IAOA91D,KAAAw7C,QAAAA,CAMA,IAAAua,GAAA/1D,KAAAg2D,eAMAC,EAAAj2D,KAAAk2D,UAQA,IAFAl2D,KAAAm2D,gBAEAX,EAKG,CACH,MAAA30D,EAAAgI,QACAnJ,EAAAmJ,MAAAhI,EAAAgI,OAGA,MAAAhI,EAAAiI,SACApJ,EAAAoJ,OAAAjI,EAAAiI,OAIA,IAAAD,GAAAnJ,EAAAmJ,MACAC,EAAApJ,EAAAoJ,MACA9I,MAAAo2D,OAAAvtD,EACA7I,KAAAq2D,QAAAvtD,CAGA,IAAAwtD,GAAA,GAAAjB,GAAA31D,EAAAM,KAAA,EACAs2D,GAAAC,cAGAN,EAAA,GAAAK,EACAP,EAAAjuD,KAAA,GACA9H,KAAAw2D,SAAA92D,MA3BA,CACAM,KAAAo2D,OAAAp2D,KAAAy2D,SAAA,GACAz2D,KAAAq2D,QAAAr2D,KAAAy2D,SAAA,EACA,IAAAtB,GAAAn1D,KAAAw2D,SAAAtB,EAAAl1D,KAAAo2D,OAAAp2D,KAAAq2D,QACA32D,GAAAg3D,YAAAvB,GA2BAn1D,KAAA22D,sBAMA32D,KAAA42D,YACA52D,KAAA62D,kBAGAvL,GAAAjoD,WACA0R,YAAAu2C,EACAwL,QAAA,WACA,MAAA,UAOAC,eAAA,WACA,MAAA/2D,MAAA41D,eAMA7J,gBAAA,WACA,MAAA/rD,MAAAw2D,UAEAQ,sBAAA,WACA,GAAAC,GAAAj3D,KAAA+rD,iBAEA,IAAAkL,EACA,OACAC,WAAAD,EAAAC,YAAA,EACAC,UAAAF,EAAAE,WAAA,IASAh1C,QAAA,SAAAi1C,GACA,GAAA1xB,GAAA1lC,KAAAw7C,QAAA0U,gBAAA,GACA6F,EAAA/1D,KAAAg2D,WAEAh2D,MAAAq3D,WAAA3xB,EAAA0xB,EAGA,KAAA,GAAAnxD,GAAA,EAAmBA,EAAA8vD,EAAA7vD,OAAuBD,IAAA,CAC1C,GAAAgD,GAAA8sD,EAAA9vD,GACAgqD,EAAAjwD,KAAAk2D,QAAAjtD,IAEAgnD,EAAAwE,aAAAxE,EAAA9tC,SACA8tC,EAAA9tC,UAUA,MANAniB,MAAA+sD,eAEA/sD,KAAA22D,mBAAAzwD,QACAlG,KAAAs3D,mBAGAt3D,MAEA8sD,SAAA,SAAArgD,EAAAI,GACA,IAAAJ,EAAA8qD,WAAA,CAIA,GAAAC,GAAA,GAAA/qD,GAAAsI,aACA/N,MAAAyF,EAAAzF,MACA7C,MAAAsI,EAAAtI,OAEAqzD,GAAAC,OAAAhrD,EACAA,EAAA8qD,WAAAC,EACAA,EAAAnqD,SAAAR,GAEA7M,KAAA62D,eAAA/uD,KAAA0vD,KAEAxK,YAAA,SAAAvgD,GACA,GAAA+qD,GAAA/qD,EAAA8qD,WACAG,EAAA13D,KAAA62D,eACAvjB,EAAAjnC,EAAAsG,QAAA+kD,EAAAF,EAEAlkB,IAAA,GACAokB,EAAAlxD,OAAA8sC,EAAA,GAGA7mC,EAAA8qD,WAAA,MAEAtK,WAAA,SAAAxgD,GAGA,IAAA,GAFAirD,GAAA13D,KAAA62D,eAEA5wD,EAAA,EAAmBA,EAAAyxD,EAAAxxD,OAA0BD,IAAA,CAC7C,GAAA+O,GAAA0iD,EAAAzxD,GAAAwxD,MAEAziD,KACAA,EAAAuiD,WAAA,MAIAG,EAAAxxD,OAAA,GAEA6mD,aAAA,WACA,GAAA2K,GAAA13D,KAAA62D,eACAjiD,EAAA8iD,EAAAxxD,OACAyxD,EAAA33D,KAAA42D,WAGA,IAFAe,GAAAA,EAAAhyD,QAEAiP,EAAA,CAIA47C,EAAAkH,EAAA13D,KAAAw7C,QAAA4V,qBAGAuG,IACAA,EAAA33D,KAAA42D,YAAA52D,KAAA43D,SAAA,KAGA,IAAAC,KACAF,GAAAx5C,IAAAkoB,MAEA,KAAA,GAAApgC,GAAA,EAAmBA,EAAA2O,GAAS,CAC5B,GAAAnI,GAAAirD,EAAAzxD,GACA6xD,EAAArrD,EAAAgrD,MAGAK,IAAAA,EAAA51C,MAOAjc,IAGA6xD,EAAA30C,YACA1W,EAAAqH,UAAAgkD,EAAAhkD,UACArH,EAAA4d,aAAAytC,EAAAztC,aACA5d,EAAAwW,YAAA60C,EAAA70C,YAEAjjB,KAAA+3D,WAAAtrD,EAAAkrD,GAAA,EAAAE,MAdAH,EAAAlxD,OAAAP,EAAA,GACA6xD,EAAAP,WAAA,KACA3iD,KAgBA+iD,EAAAx5C,IAAAooB,YAEA+wB,iBAAA,WAaA,QAAA1iC,KAEAuU,IAAApV,EAAAikC,mBAAAjkC,EAAAynB,UACAznB,EAAAkkC,aAAAlkC,EAAAynB,QAAA0U,kBAEAn8B,EAAAmkC,qBACAnkC,EAAAokC,YACA7C,EAAA1gC,IAEAb,EAAAikC,sBArBA,GAAAjkC,GAAA/zB,IAEA,IAAA+zB,EAAAmkC,oBAAA,CAMA,GAAA/uB,GAAApV,EAAAikC,mBAAA,GAAA1sD,KACAyoB,GAAAokC,YACA7C,EAAA1gC,KAgBAwjC,kBAAA,WACAp4D,KAAAg4D,qBACAh4D,KAAAm4D,UAAA,EACA9rD,EAAAE,KAAAvM,KAAA22D,mBAAA,SAAA1G,GACAA,EAAA9vC,SAAA8vC,EAAAtqD,WAGA0xD,WAAA,SAAA3xB,EAAA0xB,GACA,MAAAA,IACAA,GAAA,GAGAp3D,KAAAq4D,mBAAA3yB,GAEA1lC,KAAAo4D,oBAEAp4D,KAAAs4D,iBAAA5D,GAEA10D,KAAAi4D,aAAAvyB,EAAA0xB,GAEAp3D,KAAAs4D,iBAAA1D,IAEAqD,aAAA,SAAAvyB,EAAA0xB,GAaA,QAAAmB,GAAAtI,GACA,GAAA3lC,GAAAnM,EAAAmM,KAAA,CACAnM,GAAAkoB,OACAloB,EAAA6I,YAAA,EACA7I,EAAAqG,WAAA,EAEAg0C,EAAAr4C,SAAA,EACAhC,EAAA+B,aAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA/B,EAAAisB,UAAA6lB,EAAArvD,IAAA,EAAA,EAAAiI,EAAAyhB,EAAAxhB,EAAAwhB,GACAnM,EAAAooB,UAGA,IAAA,GAxBAiyB,GACAC,EACAt6C,EAEA05C,EAEAa,EAGAC,EAJAC,EAAA,EAEA/vD,EAAA7I,KAAAo2D,OACAttD,EAAA9I,KAAAq2D,QAEA3jC,EAAA1yB,KAAAm4D,UAcAlyD,EAAA,EAAAwjB,EAAAic,EAAAx/B,OAAoCD,EAAAwjB,EAAOxjB,IAAA,CAC3C,GAAAwG,GAAAi5B,EAAAz/B,GACA4yD,EAAA74D,KAAA41D,cAAA,EAAAnpD,EAAA2W,OACA01C,EAAArsD,EAAAssD,OAkCA,IA/BAD,EAAA,GAAAJ,IACAH,EAAAG,GACAA,EAAA,MAIAD,IAAAI,IACA16C,GACAA,EAAAooB,UAIAsxB,KAEAY,EAAAI,EACAL,EAAAx4D,KAAA43D,SAAAa,GAEAD,EAAA/D,aACA/mC,EAAA,UAAA+qC,EAAA,kCAAAD,EAAAn4D,IAGA8d,EAAAq6C,EAAAr6C,IACAA,EAAAkoB,OAEAmyB,EAAA7D,cAAA,GAEA6D,EAAAr4C,SAAAi3C,IACAoB,EAAA7yD,SAIA6yD,EAAAr4C,SAAAi3C,EAAA,CAIA,GAAA0B,GAAA,EAAA,CAEA,IAAAJ,EAAA,CAKA,GAJAA,EAAA14D,KAAA22D,mBAAA5nD,KAAAqV,IAAAw0C,IAAArD,EAAA,IACAmD,EAAAv6C,IAAAkoB,OACAqyB,EAAAM,eAEAN,GAAAA,EAAAO,WAAAP,EAAAQ,cAAA,CAIAjzD,EAAAyyD,EAAAS,iBAAA,CAEA,UAGAR,EAAAD,EAAAO,WAEAP,EAAAv4C,UAEAuS,EAAAimC,GAGAD,EAAAO,WAAAvmC,EAAA,EAGAomC,IAAApmC,GACA1yB,KAAA+3D,WAAAtrD,EAAAisD,GAAA,EAAAA,EAAAM,iBAGAh5D,MAAA+3D,WAAAtrD,EAAA+rD,EAAApB,EAAAS,EAGAprD,GAAA0T,SAAA,GAGAu4C,GACAH,EAAAG,GAIAv6C,GAAAA,EAAAooB,UAKAvmC,KAAAk4D,qBAAA,EACA7rD,EAAAE,KAAAvM,KAAA22D,mBAAA,SAAA1G,GACAA,EAAAiJ,eAAAjJ,EAAAgJ,aACAj5D,KAAAk4D,qBAAA,IAEKl4D,OAEL+3D,WAAA,SAAAtrD,EAAA+rD,EAAAY,EAAAvB,GACA,GAAA15C,GAAAq6C,EAAAr6C,IACA3d,EAAAiM,EAAAqH,SAEA,KAAA0kD,EAAAr4C,SAAAi5C,KACA3sD,EAAA0W,WACA,IAAA1W,EAAAzF,MAAA8C,WAGAtJ,GAAAA,EAAA,IAAAA,EAAA,OACAiM,EAAA8W,UAAAsxC,EAAApoD,EAAAzM,KAAAo2D,OAAAp2D,KAAAq2D,UAAA,CACA,GAAApZ,GAAAxwC,EAAAwW,aAEA40C,EAAAwB,gBAAAb,GAAAzD,EAAA9X,EAAA4a,EAAAyB,oBAEAzB,EAAAyB,kBACAzB,EAAAwB,cAAAl7C,IAAAooB,UACAsxB,EAAAwB,cAAAxB,EAAAyB,gBAAA,KAEAzB,EAAAn4C,OAAA,MAIAu9B,IACA9+B,EAAAkoB,OACA4uB,EAAAhY,EAAA9+B,GACA05C,EAAAwB,cAAAb,EACAX,EAAAyB,gBAAArc,IAIAxwC,EAAAiX,aAAAjX,EAAAiX,YAAAvF,GACA1R,EAAAgT,MAAAtB,EAAA05C,EAAAn4C,QAAA,MACAm4C,EAAAn4C,OAAAjT,EACAA,EAAAkX,YAAAlX,EAAAkX,WAAAxF,KASAy5C,SAAA,SAAAx0C,GACA,GAAApjB,KAAA41D,cACA,MAAA51D,MAAAk2D,QAAA,EAGA,IAAAjG,GAAAjwD,KAAAk2D,QAAA9yC,EAiBA,OAfA6sC,KAEAA,EAAA,GAAAoF,GAAA,MAAAjyC,EAAApjB,KAAAA,KAAAsqB,KACA2lC,EAAAwE,aAAA,EAEAz0D,KAAAm2D,aAAA/yC,IACA/W,EAAA8I,MAAA86C,EAAAjwD,KAAAm2D,aAAA/yC,IAAA,GAGApjB,KAAAu5D,YAAAn2C,EAAA6sC,GAGAA,EAAAsG,eAGAtG,GAEAsJ,YAAA,SAAAn2C,EAAA6sC,GACA,GAAAuJ,GAAAx5D,KAAAk2D,QACAH,EAAA/1D,KAAAg2D,YACAphD,EAAAmhD,EAAA7vD,OACAuzD,EAAA,KACAxzD,KACAkvD,EAAAn1D,KAAAw2D,QAEA,IAAAgD,EAAAp2C,GAEA,WADAsK,GAAA,UAAAtK,EAAA,yBAKA,KAAAoxC,EAAAvE,GAEA,WADAviC,GAAA,mBAAAtK,EAAA,gBAIA,IAAAxO,EAAA,GAAAwO,EAAA2yC,EAAA,GAAA,CACA,IAAA9vD,EAAA,EAAiBA,EAAA2O,EAAA,KACjBmhD,EAAA9vD,GAAAmd,GAAA2yC,EAAA9vD,EAAA,GAAAmd,GAD8Bnd,KAM9BwzD,EAAAD,EAAAzD,EAAA9vD,IAQA,GALA8vD,EAAAvvD,OAAAP,EAAA,EAAA,EAAAmd,GACAo2C,EAAAp2C,GAAA6sC,GAIAA,EAAAyJ,QACA,GAAAD,EAAA,CACA,GAAAE,GAAAF,EAAA74D,GAEA+4D,GAAApe,YACA4Z,EAAAyE,aAAA3J,EAAArvD,IAAA+4D,EAAApe,aAEA4Z,EAAAuB,YAAAzG,EAAArvD,SAGAu0D,GAAA0E,WACA1E,EAAAyE,aAAA3J,EAAArvD,IAAAu0D,EAAA0E,YAEA1E,EAAAuB,YAAAzG,EAAArvD,MAMAk5D,UAAA,SAAA7xD,EAAAC,GACA,GACAe,GACAhD,EAFA8vD,EAAA/1D,KAAAg2D,WAIA,KAAA/vD,EAAA,EAAeA,EAAA8vD,EAAA7vD,OAAuBD,IACtCgD,EAAA8sD,EAAA9vD,GACAgC,EAAA1H,KAAA2H,EAAAlI,KAAAk2D,QAAAjtD,GAAAA,IAIAqvD,iBAAA,SAAArwD,EAAAC,GACA,GACA+nD,GACAhnD,EACAhD,EAHA8vD,EAAA/1D,KAAAg2D,WAKA,KAAA/vD,EAAA,EAAeA,EAAA8vD,EAAA7vD,OAAuBD,IACtCgD,EAAA8sD,EAAA9vD,GACAgqD,EAAAjwD,KAAAk2D,QAAAjtD,GAEAgnD,EAAAwE,aACAxsD,EAAA1H,KAAA2H,EAAA+nD,EAAAhnD,IAKA+mD,eAAA,SAAA/nD,EAAAC,GACA,GACA+nD,GACAhnD,EACAhD,EAHA8vD,EAAA/1D,KAAAg2D,WAKA,KAAA/vD,EAAA,EAAeA,EAAA8vD,EAAA7vD,OAAuBD,IACtCgD,EAAA8sD,EAAA9vD,GACAgqD,EAAAjwD,KAAAk2D,QAAAjtD,GAEAgnD,EAAAwE,aACAxsD,EAAA1H,KAAA2H,EAAA+nD,EAAAhnD,IASA8wD,UAAA,WACA,MAAA/5D,MAAAk2D,SAEAmC,mBAAA,SAAA3yB,GACA,GAAAuwB,GAAAj2D,KAAAk2D,QACA8D,EAAAh6D,KAAA22D,mBACAsD,KACAC,IACAl6D,MAAAs4D,iBAAA,SAAArI,EAAAhnD,GACAgxD,EAAAhxD,GAAAgnD,EAAAkK,QACAlK,EAAAkK,QAAA,EACAlK,EAAA9vC,SAAA,IAEA9T,EAAAE,KAAAytD,EAAA,SAAA/J,EAAA3c,GACA4mB,EAAA5mB,GAAA2c,EAAAkK,QACAlK,EAAAkK,QAAA,EACAlK,EAAA9vC,SAAA,GAOA,KAAA,GAJAu4C,GACA0B,EAFAC,EAAA,EAGAC,EAAA,EAEAr0D,EAAA,EAAAwjB,EAAAic,EAAAx/B,OAAoCD,EAAAwjB,EAAOxjB,IAAA,CAC3C,GAAAwG,GAAAi5B,EAAAz/B,GACAmd,EAAApjB,KAAA41D,cAAA,EAAAnpD,EAAA2W,OACA6sC,EAAAgG,EAAA7yC,GACAm3C,EAAA9tD,EAAAgX,WAQA,IANAwsC,IACAA,EAAAkK,UACAlK,EAAA9vC,QAAA8vC,EAAA9vC,SAAA1T,EAAA0T,SAIAo6C,GAAA,EAAA,CAEAH,IAAAG,IACAH,EAAAG,EACAD,IAGA,IAAAxB,GAAArsD,EAAAssD,QAAAuB,EAAA,CAEA,KAAA5B,EAAA,CACA,GAAAplB,GAAAvkC,KAAAqV,IAAAi2C,EAAA9E,EAAA,EACAmD,GAAAsB,EAAA1mB,GAEAolB,IACAA,EAAAsB,EAAA1mB,GAAA,GAAA+hB,GAAA,cAAAr1D,KAAAA,KAAAsqB,KACAouC,EAAAnC,eAGAmC,EAAAQ,cAAA,EAGAR,EAAAv4C,QAAAu4C,EAAAv4C,SAAA1T,EAAA0T,QACAu4C,EAAAyB,UACAzB,EAAAQ,cAAAnqD,KAAAiD,IAAA0mD,EAAAQ,cAAAJ,GAEAJ,EAAAQ,eAAAR,EAAAO,aAEAhJ,EAAA9vC,SAAA,OAGA1T,GAAAssD,WAEAL,IACAA,EAAAS,iBAAAlzD,EACAo0D,IACA3B,EAAA,MAKAA,IACA2B,IACA3B,EAAAS,iBAAAlzD,GAIAjG,KAAAs4D,iBAAA,SAAArI,EAAAhnD,GACAgxD,EAAAhxD,KAAAgnD,EAAAkK,UACAlK,EAAA9vC,SAAA,KAGA65C,EAAA9zD,OAAA6I,KAAAqV,IAAAi2C,EAAA9E,GACAlpD,EAAAE,KAAAytD,EAAA,SAAA/J,EAAA3c,GACA4mB,EAAA5mB,KAAA2c,EAAAkK,UACA1tD,EAAA0T,SAAA,GAGA8vC,EAAA9vC,UACA8vC,EAAAgJ,WAAA,MAQAtzD,MAAA,WAEA,MADA3F,MAAAs4D,iBAAAt4D,KAAAw6D,aACAx6D,MAEAw6D,YAAA,SAAAvK,GACAA,EAAAtqD,SAaA6mD,YAAA,SAAAppC,EAAAspC,GACA,GAAAA,EAAA,CACA,GAAA+N,GAAAz6D,KAAAm2D,YAEAsE,GAAAr3C,GAGA/W,EAAA8I,MAAAslD,EAAAr3C,GAAAspC,GAAA,GAFA+N,EAAAr3C,GAAAspC,CAKA,IAAAuD,GAAAjwD,KAAAk2D,QAAA9yC,EAEA6sC,IACA5jD,EAAA8I,MAAA86C,EAAAwK,EAAAr3C,IAAA,KASAs3C,SAAA,SAAAt3C,GACA,GAAA6yC,GAAAj2D,KAAAk2D,QACAH,EAAA/1D,KAAAg2D,YACA/F,EAAAgG,EAAA7yC;AAEA6sC,IAIAA,EAAArvD,IAAAgvD,WAAA+K,YAAA1K,EAAArvD,WACAq1D,GAAA7yC,GACA2yC,EAAAvvD,OAAA6F,EAAAsG,QAAAojD,EAAA3yC,GAAA,KAMAtf,OAAA,SAAA+E,EAAAC,GACA,GAAAqsD,GAAAn1D,KAAAw2D,QAEArB,GAAAnuD,MAAA4zD,QAAA,MAEA,IAAA/5D,GAAAb,KAAA21D,KAOA,IANA,MAAA9sD,IAAAhI,EAAAgI,MAAAA,GACA,MAAAC,IAAAjI,EAAAiI,OAAAA,GACAD,EAAA7I,KAAAy2D,SAAA,GACA3tD,EAAA9I,KAAAy2D,SAAA,GACAtB,EAAAnuD,MAAA4zD,QAAA,GAEA56D,KAAAo2D,QAAAvtD,GAAAC,GAAA9I,KAAAq2D,QAAA,CACAlB,EAAAnuD,MAAA6B,MAAAA,EAAA,KACAssD,EAAAnuD,MAAA8B,OAAAA,EAAA,IAEA,KAAA,GAAAzI,KAAAL,MAAAk2D,QACAl2D,KAAAk2D,QAAA/oD,eAAA9M,IACAL,KAAAk2D,QAAA71D,GAAAyD,OAAA+E,EAAAC,EAIAuD,GAAAE,KAAAvM,KAAA22D,mBAAA,SAAA1G,GACAA,EAAAnsD,OAAA+E,EAAAC,KAEA9I,KAAAmiB,SAAA,GAKA,MAFAniB,MAAAo2D,OAAAvtD,EACA7I,KAAAq2D,QAAAvtD,EACA9I,MAOA66D,WAAA,SAAAz3C,GACA,GAAA6sC,GAAAjwD,KAAAk2D,QAAA9yC,EAEA6sC,IACAA,EAAAtqD,SAOA/B,QAAA,WACA5D,KAAAN,KAAAo2D,UAAA,GACA91D,KAAAN,KAAAM,KAAAw7C,QAAAx7C,KAAAw2D,SAAAx2D,KAAAk2D,QAAA,MASA4E,kBAAA,SAAAj6D,GAgBA,QAAAk6D,GAAAC,EAAAC,GACA,GAAAlF,GAAAhiC,EAAAiiC,WAEA,OAAAgF,IACAA,IAAAzkB,EAAAA,GAKA,KAAA,GAFA2kB,GAEAj1D,EAAA,EAAqBA,EAAA8vD,EAAA7vD,OAAuBD,IAAA,CAC5C,GAAAgD,GAAA8sD,EAAA9vD,GACAgqD,EAAAl8B,EAAAmiC,QAAAjtD,EAEA,KAAAgnD,EAAAwE,aAAAxrD,EAAA+xD,GAAA/xD,EAAAgyD,EAAA,CACAC,EAAAjL,CACA,QAIAiL,GAAAA,EAAAC,iBACAC,EAAAj9C,IAAAkoB,OACA60B,EAAAC,eAAAC,EAAAj9C,KACAi9C,EAAAj9C,IAAAooB,WAnCA,GAFA1lC,EAAAA,MAEAb,KAAA41D,cACA,MAAA51D,MAAAk2D,QAAA,GAAAt1D,GAGA,IAAAw6D,GAAA,GAAA/F,GAAA,QAAAr1D,KAAAa,EAAAw6D,YAAAr7D,KAAAsqB,IACA8wC,GAAA7E,cACA6E,EAAAE,WAAAz6D,EAAAqI,gBACAkyD,EAAAz1D,OAgCA,KAAA,GA7BAyd,GAFA0tC,EAAA9wD,KAAAw7C,QAAA0U,gBAAA,GACA2H,KAEA9jC,EAAA/zB,KA4BAiG,EAAA,EAAmBA,EAAA6qD,EAAA5qD,OAAwBD,IAAA,CAC3C,GAAAwG,GAAAqkD,EAAA7qD,EAEAwG,GAAA2W,SAAAA,IACA23C,EAAA33C,EAAA3W,EAAA2W,QACAA,EAAA3W,EAAA2W,QAGApjB,KAAA+3D,WAAAtrD,EAAA2uD,GAAA,EAAAvD,GAIA,MADAkD,GAAA33C,EAAAmzB,EAAAA,GACA6kB,EAAAx6D,KAMA4C,SAAA,WACA,MAAAxD,MAAAo2D,QAMA3yD,UAAA,WACA,MAAAzD,MAAAq2D,SAEAI,SAAA,SAAA8E,GACA,GAAA16D,GAAAb,KAAA21D,MACA6F,GAAA,QAAA,UAAAD,GACAE,GAAA,cAAA,gBAAAF,GACAG,GAAA,cAAA,cAAAH,GACAI,GAAA,eAAA,iBAAAJ,EAEA,IAAA,MAAA16D,EAAA26D,IAAA,SAAA36D,EAAA26D,GACA,MAAAp+C,YAAAvc,EAAA26D,GAGA,IAAA97D,GAAAM,KAAAN,KAEAk8D,EAAApzD,SAAAqzD,YAAAC,iBAAAp8D,EACA,QAAAA,EAAA+7D,IAAAlH,EAAAqH,EAAAJ,KAAAjH,EAAA70D,EAAAsH,MAAAw0D,MAAAjH,EAAAqH,EAAAF,KAAA,IAAAnH,EAAAqH,EAAAD,KAAA,GAAA,GAEAxO,YAAA,SAAAz8C,EAAA4Z,GACAA,EAAAA,GAAAtqB,KAAAsqB,GACA,IAAAohC,GAAAljD,SAAAC,cAAA,UACA0V,EAAAutC,EAAAhjD,WAAA,MACA8H,EAAAE,EAAAG,kBACA7J,EAAA0J,EAAA1J,MACA+0D,EAAA/0D,EAAAwd,WACAC,EAAAzd,EAAAyd,cACAC,EAAA1d,EAAA0d,cACAhT,EAAA1K,EAAA2Y,YAAA3Y,EAAA0K,UAAA,EACAsqD,EAAAjtD,KAAAiD,IAAAN,EAAA,GAAA+S,EAAAs3C,GACAE,EAAAltD,KAAAiD,IAAAN,EAAA,EAAA+S,EAAAs3C,GACAG,EAAAntD,KAAAiD,IAAAN,EAAA,GAAAgT,EAAAq3C,GACAI,EAAAptD,KAAAiD,IAAAN,EAAA,EAAAgT,EAAAq3C,GACAlzD,EAAA2H,EAAA3H,MAAAmzD,EAAAC,EACAnzD,EAAA0H,EAAA1H,OAAAozD,EAAAC,CACAzQ,GAAA7iD,MAAAA,EAAAyhB,EACAohC,EAAA5iD,OAAAA,EAAAwhB,EACAnM,EAAA3U,MAAA8gB,EAAAA,GACAnM,EAAAi+C,UAAA,EAAA,EAAAvzD,EAAAC,GACAqV,EAAAmM,IAAAA,CACA,IAAA+xC,IACA9yD,SAAAmH,EAAAnH,SACAwgB,SAAArZ,EAAAqZ,SACAvgB,MAAAkH,EAAAlH,MAEAkH,GAAAnH,UAAAyyD,EAAAxrD,EAAA/G,EAAAyyD,EAAA1rD,EAAA9G,GACAgH,EAAAqZ,SAAA,EACArZ,EAAAlH,OAAA,EAAA,GACAkH,EAAA0X,kBAEA1X,GACAA,EAAA+O,MAAAtB,EAGA,IAAAm+C,GAAAhzD,EACAizD,EAAA,GAAAD,IACAt1D,OACAyC,EAAA,EACAC,EAAA,EACAC,MAAA+hD,IAgBA,OAZA,OAAA2Q,EAAA9yD,WACAgzD,EAAAhzD,SAAAmH,EAAAnH,SAAA8yD,EAAA9yD,UAGA,MAAA8yD,EAAAtyC,WACAwyC,EAAAxyC,SAAArZ,EAAAqZ,SAAAsyC,EAAAtyC,UAGA,MAAAsyC,EAAA7yD,QACA+yD,EAAA/yD,MAAAkH,EAAAlH,MAAA6yD,EAAA7yD,OAGA+yD,GAGA,IAAAz5C,GAAAwoC,CACAzrD,GAAAD,QAAAkjB,GxEuzeM,SAAUjjB,EAAQD,EAASM,GyE30gBjC,QAAAs8D,KACA,OAAA,EAYA,QAAAC,GAAAp8D,EAAAwrD,EAAAvhC,GACA,GAAAoyC,GAAArwD,EAAAyJ,eACAjN,EAAAgjD,EAAAroD,WACAsF,EAAA+iD,EAAApoD,YACAk5D,EAAAD,EAAA11D,KAWA,OATA21D,GAAApzD,SAAA,WACAozD,EAAAhyB,KAAA,EACAgyB,EAAA7xB,IAAA,EACA6xB,EAAA9zD,MAAAA,EAAA,KACA8zD,EAAA7zD,OAAAA,EAAA,KACA4zD,EAAA7zD,MAAAA,EAAAyhB,EACAoyC,EAAA5zD,OAAAA,EAAAwhB,EAEAoyC,EAAA7wD,aAAA,iBAAAxL,GACAq8D,EA1CA,GAAArwD,GAAAnM,EAAA,GAEA2lC,EAAA3lC,EAAA,IAEAgC,EAAA2jC,EAAA3jC,iBAEA8gB,EAAA9iB,EAAA,GAEAmf,EAAAnf,EAAA,IA8CAm1D,EAAA,SAAAh1D,EAAAwrD,EAAAvhC,GACA,GAAA1pB,EACA0pB,GAAAA,GAAApoB,EAEA,gBAAA7B,GACAO,EAAA67D,EAAAp8D,EAAAwrD,EAAAvhC,GAEAje,EAAAgJ,SAAAhV,KACAO,EAAAP,EACAA,EAAAO,EAAAP,IAGAL,KAAAK,GAAAA,EACAL,KAAAY,IAAAA,CACA,IAAAg8D,GAAAh8D,EAAAoG,KAEA41D,KAEAh8D,EAAAi8D,cAAAL,EAEAI,EAAA,uBAAA,OACAA,EAAA,eAAA,OACAA,EAAA,yBAAA,OACAA,EAAA,+BAAA,gBACAA,EAAA,QAAA,EACAA,EAAA,OAAA,EACAA,EAAA,gBAAA,GAGA58D,KAAA88D,QAAA,KACA98D,KAAA+8D,QAAA,KACA/8D,KAAA6rD,QAAAA,EACA7rD,KAAA0sD,OAAA,KAQA1sD,KAAAs7D,WAAA,EAOAt7D,KAAAg9D,YAAA,EAOAh9D,KAAAi9D,eAAA,GAMAj9D,KAAAsqB,IAAAA,EAGA+qC,GAAAhyD,WACA0R,YAAAsgD,EACA8E,QAAA,EACAh6C,SAAA,EACAo2C,YAAA,WACAv2D,KAAAme,IAAAne,KAAAY,IAAA8H,WAAA,MACA1I,KAAAme,IAAA++C,mBACAl9D,KAAAme,IAAAmM,IAAAtqB,KAAAsqB,KAEA6yC,iBAAA,WACA,GAAA7yC,GAAAtqB,KAAAsqB,GACAtqB,MAAA88D,QAAAL,EAAA,QAAAz8D,KAAAK,GAAAL,KAAA6rD,QAAAvhC,GACAtqB,KAAA+8D,QAAA/8D,KAAA88D,QAAAp0D,WAAA,MACA1I,KAAA+8D,QAAAG,mBAEA,GAAA5yC,GACAtqB,KAAA+8D,QAAAvzD,MAAA8gB,EAAAA,IAQAxmB,OAAA,SAAA+E,EAAAC,GACA,GAAAwhB,GAAAtqB,KAAAsqB,IACA1pB,EAAAZ,KAAAY,IACAg8D,EAAAh8D,EAAAoG,MACA81D,EAAA98D,KAAA88D,OACAF,GAAA/zD,MAAAA,EAAA,KACA+zD,EAAA9zD,OAAAA,EAAA,KACAlI,EAAAiI,MAAAA,EAAAyhB,EACA1pB,EAAAkI,OAAAA,EAAAwhB,EAEAwyC,IACAA,EAAAj0D,MAAAA,EAAAyhB,EACAwyC,EAAAh0D,OAAAA,EAAAwhB,EAEA,GAAAA,GACAtqB,KAAA+8D,QAAAvzD,MAAA8gB,EAAAA,KASA3kB,MAAA,SAAAy3D,GACA,GAAAx8D,GAAAZ,KAAAY,IACAud,EAAAne,KAAAme,IACAtV,EAAAjI,EAAAiI,MACAC,EAAAlI,EAAAkI,OACAwyD,EAAAt7D,KAAAs7D,WACA+B,EAAAr9D,KAAAg9D,aAAAI,EACAH,EAAAj9D,KAAAi9D,eACA3yC,EAAAtqB,KAAAsqB,GAaA,IAXA+yC,IACAr9D,KAAA88D,SACA98D,KAAAm9D,mBAGAn9D,KAAA+8D,QAAA91C,yBAAA,OACAjnB,KAAA+8D,QAAA3yB,UAAAxpC,EAAA,EAAA,EAAAiI,EAAAyhB,EAAAxhB,EAAAwhB,IAGAnM,EAAAi+C,UAAA,EAAA,EAAAvzD,EAAAC,GAEAwyD,EAAA,CACA,GAAAgC,EAEAhC,GAAAx7C,YAEAw9C,EAAAhC,EAAAiC,kBAAAv6C,EAAA3C,YAAAlC,EAAAm9C,GACA7xD,EAAA,EACAC,EAAA,EACAb,MAAAA,EACAC,OAAAA,IAEAwyD,EAAAiC,iBAAAD,GAEAhC,EAAA3xD,QACA2zD,EAAAj+C,EAAAhc,UAAAic,iBAAA/e,KAAA+6D,EAAAn9C,IAGAA,EAAAkoB,OACAloB,EAAAoC,UAAA+8C,GAAAhC,EACAn9C,EAAAq/C,SAAA,EAAA,EAAA30D,EAAAC,GACAqV,EAAAooB,UAGA,GAAA82B,EAAA,CACA,GAAAP,GAAA98D,KAAA88D,OACA3+C,GAAAkoB,OACAloB,EAAA6I,YAAAi2C,EACA9+C,EAAAisB,UAAA0yB,EAAA,EAAA,EAAAj0D,EAAAC,GACAqV,EAAAooB,YAIA,IAAAzjB,GAAAuyC,CACAx1D,GAAAD,QAAAkjB,GzE+1gBM,SAAUjjB,EAAQD,G0E1jhBxB,GAAAkjB,GAAA,mBAAAkjB,UAAAA,OAAAsvB,uBAAAtvB,OAAAsvB,sBAAAruD,KAAA++B,SACAA,OAAAy3B,yBAAAz3B,OAAAy3B,wBAAAx2D,KAAA++B,SAAAA,OAAA03B,0BAAA13B,OAAA23B,8BAAA,SAAAvmD,GACAwmD,WAAAxmD,EAAA,IAGAvX,GAAAD,QAAAkjB,G1EgkhBM,SAAUjjB,EAAQD,EAASM,G2ErkhBjC,GAAAmM,GAAAnM,EAAA,GAEA29D,EAAA39D,EAAA,IAEA49D,EAAAD,EAAAC,WAEAxI,EAAAp1D,EAAA,IAEAutB,EAAAvtB,EAAA,IAwCAqrD,EAAA,SAAA1oD,GACAA,EAAAA,MACA7C,KAAAgsD,MAAAnpD,EAAAmpD,UAEAhsD,KAAAyyB,QAAA5vB,EAAA4vB,SAAA,aAGAzyB,KAAA+9D,UACA/9D,KAAAg+D,UAAA,EACAh+D,KAAAi+D,MACAj+D,KAAA00B,YACA10B,KAAAk+D,YACAl+D,KAAAyzB,SAAA,EACAqqC,EAAAv9D,KAAAP,MAGAurD,GAAAloD,WACA0R,YAAAw2C,EAMAt3B,QAAA,SAAArB,GACA5yB,KAAA+9D,OAAAj2D,KAAA8qB,IAOA9J,YAAA,SAAAgF,GACAA,EAAAjF,UAAA7oB,IAGA,KAAA,GAFAm+D,GAAArwC,EAAAuG,WAEApuB,EAAA,EAAmBA,EAAAk4D,EAAAj4D,OAAkBD,IACrCjG,KAAAi0B,QAAAkqC,EAAAl4D,KAQAmuB,WAAA,SAAAxB,GACA,GAAA0gB,GAAAjnC,EAAAsG,QAAA3S,KAAA+9D,OAAAnrC,EAEA0gB,IAAA,GACAtzC,KAAA+9D,OAAAv3D,OAAA8sC,EAAA,IAQAvqB,eAAA,SAAA+E,GAGA,IAAA,GAFAqwC,GAAArwC,EAAAuG,WAEApuB,EAAA,EAAmBA,EAAAk4D,EAAAj4D,OAAkBD,IACrCjG,KAAAo0B,WAAA+pC,EAAAl4D,GAGA6nB,GAAAjF,UAAA,MAEAu1C,QAAA,WASA,IAAA,GARAhwC,IAAA,GAAA9iB,OAAA+yD,UAAAr+D,KAAA00B,YAEAmF,EAAAzL,EAAApuB,KAAAi+D,MACAE,EAAAn+D,KAAA+9D,OACAnpD,EAAAupD,EAAAj4D,OACAo4D,KACAC,KAEAt4D,EAAA,EAAmBA,EAAA2O,EAAS3O,IAAA,CAC5B,GAAA2sB,GAAAurC,EAAAl4D,GACAjC,EAAA4uB,EAAAgC,KAAAxG,EAAAyL,EAGA71B,KACAs6D,EAAAx2D,KAAA9D,GACAu6D,EAAAz2D,KAAA8qB,IAKA,IAAA,GAAA3sB,GAAA,EAAmBA,EAAA2O,GACnBupD,EAAAl4D,GAAAmvB,cACA+oC,EAAAl4D,GAAAk4D,EAAAvpD,EAAA,GACAupD,EAAAllC,MACArkB,KAEA3O,GAIA2O,GAAA0pD,EAAAp4D,MAEA,KAAA,GAAAD,GAAA,EAAmBA,EAAA2O,EAAS3O,IAC5Bs4D,EAAAt4D,GAAAivB,KAAAopC,EAAAr4D,GAGAjG,MAAAi+D,MAAA7vC,EACApuB,KAAAyyB,QAAAoH,GACA75B,KAAAoF,QAAA,QAAAy0B,GAEA75B,KAAAgsD,MAAA7jC,QACAnoB,KAAAgsD,MAAA7jC,UAGAq2C,WAAA,WAIA,QAAA5pC,KACAb,EAAAiqC,WACA1I,EAAA1gC,IACAb,EAAAN,SAAAM,EAAAqqC,WANA,GAAArqC,GAAA/zB,IACAA,MAAAg+D,UAAA,EASA1I,EAAA1gC,IAMAjG,MAAA,WACA3uB,KAAAi+D,OAAA,GAAA3yD,OAAA+yD,UACAr+D,KAAA00B,YAAA,EAEA10B,KAAAw+D,cAMArwC,KAAA,WACAnuB,KAAAg+D,UAAA,GAMAxqC,MAAA,WACAxzB,KAAAyzB,UACAzzB,KAAAk+D,aAAA,GAAA5yD,OAAA+yD,UACAr+D,KAAAyzB,SAAA,IAOAC,OAAA,WACA1zB,KAAAyzB,UACAzzB,KAAA00B,cAAA,GAAAppB,OAAA+yD,UAAAr+D,KAAAk+D,YACAl+D,KAAAyzB,SAAA,IAOA9tB,MAAA,WACA3F,KAAA+9D,WAeAx7C,QAAA,SAAAne,EAAAvB,GACAA,EAAAA,KACA,IAAAirB,GAAA,GAAAL,GAAArpB,EAAAvB,EAAAyf,KAAAzf,EAAAuuB,OAAAvuB,EAAAyuB,OAEA,OADAtxB,MAAA8oB,YAAAgF,GACAA,IAGAzhB,EAAAjB,MAAAmgD,EAAAuS,EACA,IAAAh7C,GAAAyoC,CACA1rD,GAAAD,QAAAkjB,G3E2khBM,SAAUjjB,EAAQD,EAASM,G4E1yhBjC,QAAAu+D,GAAAhyD,GAEA,MAAAA,GAAAgyD,sBAAAhyD,EAAAgyD,yBACA9zB,KAAA,EACAG,IAAA,GAKA,QAAA4zB,GAAAjyD,EAAAzI,EAAA8mB,EAAA6zC,GAiCA,MAhCA7zC,GAAAA,MAWA6zC,IAAA9hB,EAAAc,gBACAihB,EAAAnyD,EAAAzI,EAAA8mB,GAQA+xB,EAAAC,QAAAQ,SAAA,MAAAt5C,EAAA66D,QAAA76D,EAAA66D,SAAA76D,EAAAu2C,SACAzvB,EAAA8iC,IAAA5pD,EAAA66D,OACA/zC,EAAA+iC,IAAA7pD,EAAA86D,QAEA,MAAA96D,EAAAu2C,SACAzvB,EAAA8iC,IAAA5pD,EAAAu2C,QACAzvB,EAAA+iC,IAAA7pD,EAAAy2C,SAGAmkB,EAAAnyD,EAAAzI,EAAA8mB,GAGAA,EAGA,QAAA8zC,GAAAnyD,EAAAzI,EAAA8mB,GAEA,GAAAi0C,GAAAN,EAAAhyD,EACAqe,GAAA8iC,IAAA5pD,EAAAg7D,QAAAD,EAAAp0B,KACA7f,EAAA+iC,IAAA7pD,EAAAi7D,QAAAF,EAAAj0B,IAQA,QAAAo0B,GAAAzyD,EAAAzI,EAAA26D,GAGA,GAFA36D,EAAAA,GAAAgiC,OAAA9gC,MAEA,MAAAlB,EAAA4pD,IACA,MAAA5pD,EAGA,IAAAsxB,GAAAtxB,EAAAmB,KACAg6D,EAAA7pC,GAAAA,EAAA3iB,QAAA,UAAA,CAEA,IAAAwsD,EAGG,CACH,GAAAC,GAAA,YAAA9pC,EAAAtxB,EAAAq7D,cAAA,GAAAr7D,EAAAs7D,eAAA,EACAF,IAAAV,EAAAjyD,EAAA2yD,EAAAp7D,EAAA26D,OAJAD,GAAAjyD,EAAAzI,EAAAA,EAAA26D,GACA36D,EAAAmqD,QAAAnqD,EAAAkqD,WAAAlqD,EAAAkqD,WAAA,MAAAlqD,EAAAu7D,QAAA,GAAA,CAUA,IAAAC,GAAAx7D,EAAAw7D,MAMA,OAJA,OAAAx7D,EAAAqqD,OAAAoR,SAAAD,GAAAE,EAAAhiB,KAAA15C,EAAAmB,QACAnB,EAAAqqD,MAAA,EAAAmR,EAAA,EAAA,EAAAA,EAAA,EAAA,EAAAA,EAAA,EAAA,GAGAx7D,EAGA,QAAA27D,GAAAlzD,EAAA/E,EAAA0hB,GACAw2C,EACAnzD,EAAAkzD,iBAAAj4D,EAAA0hB,GAEA3c,EAAAozD,YAAA,KAAAn4D,EAAA0hB,GAIA,QAAA02C,GAAArzD,EAAA/E,EAAA0hB,GACAw2C,EACAnzD,EAAAqzD,oBAAAp4D,EAAA0hB,GAEA3c,EAAAszD,YAAA,KAAAr4D,EAAA0hB,GAuBA,QAAA42C,GAAAh8D,GAEA,MAAAA,GAAAqqD,MAAA,EA3IA,GAAAvrD,GAAA5C,EAAA,GAEAN,GAAAk+D,WAAAh7D,CAEA,IAAA+5C,GAAA38C,EAAA,IAOA0/D,EAAA,mBAAA55B,WAAAA,OAAA25B,iBACAD,EAAA,iDAoHAvxC,EAAAyxC,EAAA,SAAA57D,GACAA,EAAAi8D,iBACAj8D,EAAAk8D,kBACAl8D,EAAA2pD,cAAA,GACC,SAAA3pD,GACDA,EAAAm8D,aAAA,EACAn8D,EAAA2pD,cAAA,EASA/tD,GAAA8+D,cAAAA,EACA9+D,EAAAs/D,eAAAA,EACAt/D,EAAA+/D,iBAAAA,EACA//D,EAAAkgE,oBAAAA,EACAlgE,EAAAuuB,KAAAA,EACAvuB,EAAAogE,aAAAA,G5E8zhBM,SAAUngE,EAAQD,EAASM,G6Et7hBjC,QAAAkgE,GAAA14D,GACA,MAAA,eAAAA,GAAAm1C,EAAAC,QAAAQ,QAAA,iBAAA51C,EAGA,QAAA24D,GAAA1R,EAAAzpD,EAAA8mD,GACA,GAAAsU,GAAA3R,EAAA4R,WACA,WAAAvU,GAAAsU,EAAA36D,OACA,IAAA66D,GAAAF,EAAAG,UAAAv7D,EAAAypD,EAAAvlC,QAAAwxB,UAAA11C,EAAA0oD,IAAA1oD,EAAA2oD,IAAA,MAAAzpD,OAAAuqD,EAAA/tD,IAGA,IAFA,QAAAorD,GAAAsU,EAAA36D,QAEA66D,EAAA,CACA,GAAAr7D,GAAAq7D,EAAAr7D,IACAD,GAAA4oD,aAAA3oD,EACAwpD,EAAAvlC,QAAAsxB,mBACAt2C,OAAAo8D,EAAAp8D,QACKe,EAAAq7D,EAAAt7D,QAwBL,QAAAw7D,GAAA7V,GACAA,EAAA8V,WAAA,EACAv0D,aAAAy+C,EAAA+V,aACA/V,EAAA+V,YAAAhD,WAAA,WACA/S,EAAA8V,WAAA,GACG,KAqIH,QAAAE,GAAA37D,GACA,GAAA47D,GAAA57D,EAAA47D,WACA,OAAA,QAAAA,GAAA,UAAAA,EAoBA,QAAAC,GAAAlW,GAWA,QAAAmW,GAAA1sD,EAAAu2C,GACA,MAAA,YACA,IAAAA,EAAA8V,UAIA,MAAArsD,GAAAkD,MAAAqzC,EAAAtzC,YAhBAxU,EAAAwJ,KAAA00D,EAAA,SAAAv5D,GACAmjD,EAAAqW,UAAAx5D,GAAA3E,EAAAkE,KAAAk6D,EAAAz5D,GAAAmjD,KAEA9nD,EAAAwJ,KAAA60D,EAAA,SAAA15D,GACAmjD,EAAAqW,UAAAx5D,GAAA3E,EAAAkE,KAAAk6D,EAAAz5D,GAAAmjD,KAEA9nD,EAAAwJ,KAAA80D,EAAA,SAAA35D,GACAmjD,EAAAqW,UAAAx5D,GAAAs5D,EAAAG,EAAAz5D,GAAAmjD,KAcA,QAAAyW,GAAA1gE,GA2DA,QAAA2gE,GAAA7S,EAAA7D,GACA9nD,EAAAwJ,KAAAmiD,EAAA,SAAAhnD,GACAi4D,EAAA/+D,EAAAw/D,EAAA14D,GAAAmjD,EAAAqW,UAAAx5D,KACKmjD,GA7DL/nD,EAAAvC,KAAAP,MACAA,KAAAY,IAAAA,EAMAZ,KAAA2gE,WAAA,EAMA3gE,KAAA4gE,YAMA5gE,KAAAugE,YAAA,GAAAiB,GACAxhE,KAAAkhE,aACAH,EAAA/gE,MAEA68C,EAAAkB,uBAQAwjB,EAAAH,EAAAphE,OAcA68C,EAAAiB,sBACAyjB,EAAAN,EAAAjhE,MASAuhE,EAAAF,EAAArhE,OAjTA,GAAA69D,GAAA39D,EAAA,IAEAy/D,EAAA9B,EAAA8B,iBACAG,EAAAjC,EAAAiC,oBACAZ,EAAArB,EAAAqB,eAEAn8D,EAAA7C,EAAA,GAEA4C,EAAA5C,EAAA,IAEA28C,EAAA38C,EAAA,IAEAshE,EAAAthE,EAAA,IAEAuhE,EAAA,IACAJ,GAAA,QAAA,WAAA,aAAA,WAAA,UAAA,YAAA,YAAA,eACAJ,GAAA,aAAA,WAAA,aACAS,GACAC,YAAA,EACAC,UAAA,EACAC,YAAA,EACAC,WAAA,GAEAV,EAAAr+D,EAAA6T,IAAAyqD,EAAA,SAAA35D,GACA,GAAAq6D,GAAAr6D,EAAA6U,QAAA,QAAA,UACA,OAAAmlD,GAAAK,GAAAA,EAAAr6D,IAkDAy5D,GAMAlS,UAAA,SAAA/pD,GACAA,EAAAg6D,EAAAl/D,KAAAY,IAAAsE,GACAlF,KAAAoF,QAAA,YAAAF,IAQAqqD,SAAA,SAAArqD,GACAA,EAAAg6D,EAAAl/D,KAAAY,IAAAsE,EACA,IAAAuqD,GAAAvqD,EAAAwqD,WAAAxqD,EAAAyqD,aAEA,IAAAF,GAAAzvD,KAAAY,IACA,KAAA6uD,GAAA,GAAAA,EAAA73C,UAAA,CAEA,GAAA63C,IAAAzvD,KAAAY,IACA,MAGA6uD,GAAAA,EAAAG,WAIA5vD,KAAAoF,QAAA,WAAAF,IAQA88D,WAAA,SAAA98D,GAGAA,EAAAg6D,EAAAl/D,KAAAY,IAAAsE,GAGAA,EAAAkpD,WAAA,EACApuD,KAAA8uD,iBAAA,GAAAxjD,MACA+0D,EAAArgE,KAAAkF,EAAA,SAGAi8D,EAAAlS,UAAA1uD,KAAAP,KAAAkF,GACAi8D,EAAAc,UAAA1hE,KAAAP,KAAAkF,GACAw7D,EAAA1gE,OAQAkiE,UAAA,SAAAh9D,GACAA,EAAAg6D,EAAAl/D,KAAAY,IAAAsE,GAGAA,EAAAkpD,WAAA,EACAiS,EAAArgE,KAAAkF,EAAA,UAIAi8D,EAAAlS,UAAA1uD,KAAAP,KAAAkF,GACAw7D,EAAA1gE,OAQAmiE,SAAA,SAAAj9D,GACAA,EAAAg6D,EAAAl/D,KAAAY,IAAAsE,GAGAA,EAAAkpD,WAAA,EACAiS,EAAArgE,KAAAkF,EAAA,OACAi8D,EAAAiB,QAAA7hE,KAAAP,KAAAkF,IAUA,GAAAoG,MAAAtL,KAAA8uD,iBAAA2S,GACAN,EAAAkB,MAAA9hE,KAAAP,KAAAkF,GAGAw7D,EAAA1gE,OAEA2hE,YAAA,SAAAz8D,GACAi8D,EAAAc,UAAA1hE,KAAAP,KAAAkF,IAIA28D,YAAA,SAAA38D,GAMA27D,EAAA37D,IACAi8D,EAAAlS,UAAA1uD,KAAAP,KAAAkF,IAGA08D,UAAA,SAAA18D,GACAi8D,EAAAiB,QAAA7hE,KAAAP,KAAAkF,IAEA48D,WAAA,SAAA58D,GAMA27D,EAAA37D,IACAi8D,EAAA5R,SAAAhvD,KAAAP,KAAAkF,IAcAnC,GAAAwJ,MAAA,QAAA,YAAA,UAAA,aAAA,WAAA,eAAA,SAAA7E,GACAy5D,EAAAz5D,GAAA,SAAAxC,GACAA,EAAAg6D,EAAAl/D,KAAAY,IAAAsE,GACAlF,KAAAoF,QAAAsC,EAAAxC,KAkGA,IAAAo9D,GAAAhB,EAAAj+D,SAEAi/D,GAAA1+D,QAAA,WAGA,IAAA,GAFA8qD,GAAA2S,EAAA5pD,OAAAwpD,GAEAh7D,EAAA,EAAiBA,EAAAyoD,EAAAxoD,OAAyBD,IAAA,CAC1C,GAAAyB,GAAAgnD,EAAAzoD,EACA65D,GAAA9/D,KAAAY,IAAAw/D,EAAA14D,GAAA1H,KAAAkhE,UAAAx5D,MAIA46D,EAAAhT,UAAA,SAAAjC,GACArtD,KAAAY,IAAAoG,MAAAgC,OAAAqkD,GAAA,WAGAtqD,EAAAqI,MAAAk2D,EAAAx+D,EACA,IAAAggB,GAAAw+C,CACAzhE,GAAAD,QAAAkjB,G7Ew9hBM,SAAUjjB,EAAQD,EAASM,G8ExuiBjC,QAAAqtB,GAAAg1C,GACA,GAAAz6C,GAAAy6C,EAAA,GAAA,GAAAA,EAAA,GAAA,GACAx6C,EAAAw6C,EAAA,GAAA,GAAAA,EAAA,GAAA,EACA,OAAAxzD,MAAA+P,KAAAgJ,EAAAA,EAAAC,EAAAA,GAGA,QAAA8iB,GAAA03B,GACA,QAAAA,EAAA,GAAA,GAAAA,EAAA,GAAA,IAAA,GAAAA,EAAA,GAAA,GAAAA,EAAA,GAAA,IAAA,GAnEA,GAAAC,GAAAtiE,EAAA,IAKAshE,EAAA,WAKAxhE,KAAAyiE,UAGAjB,GAAAn+D,WACA0R,YAAAysD,EACAf,UAAA,SAAAv7D,EAAAd,EAAA1E,GAGA,MAFAM,MAAA0iE,SAAAx9D,EAAAd,EAAA1E,GAEAM,KAAA2iE,WAAAz9D,IAEAS,MAAA,WAEA,MADA3F,MAAAyiE,OAAAv8D,OAAA,EACAlG,MAEA0iE,SAAA,SAAAx9D,EAAAd,EAAA1E,GACA,GAAAkjE,GAAA19D,EAAA09D,OAEA,IAAAA,EAAA,CAWA,IAAA,GAPAC,IACArrB,UACAorB,WACAx+D,OAAAA,EACAc,MAAAA,GAGAe,EAAA,EAAA2O,EAAAguD,EAAA18D,OAAyCD,EAAA2O,EAAS3O,IAAA,CAClD,GAAAm5D,GAAAwD,EAAA38D,GACA64C,EAAA0jB,EAAA9D,cAAAh/D,EAAA0/D,KACAyD,GAAArrB,OAAA1vC,MAAAg3C,EAAA8O,IAAA9O,EAAA+O,MACAgV,EAAAD,QAAA96D,KAAAs3D,GAGAp/D,KAAAyiE,OAAA36D,KAAA+6D,KAEAF,WAAA,SAAAz9D,GACA,IAAA,GAAAooD,KAAAwV,GACA,GAAAA,EAAA31D,eAAAmgD,GAAA,CACA,GAAAkT,GAAAsC,EAAAxV,GAAAttD,KAAAyiE,OAAAv9D,EAEA,IAAAs7D,EACA,MAAAA,KAiBA,IAAAsC,IACAC,MAAA,SAAAC,EAAA99D,GACA,GAAAusB,GAAAuxC,EAAA98D,MAEA,IAAAurB,EAAA,CAIA,GAAAwxC,IAAAD,EAAAvxC,EAAA,QAA6C+lB,OAC7C0rB,GAAAF,EAAAvxC,EAAA,QAA6C+lB,QAAAyrB,CAE7C,IAAAC,GAAAA,EAAAh9D,OAAA,GAAA+8D,GAAAA,EAAA/8D,OAAA,EAAA,CACA,GAAA+nD,GAAA1gC,EAAA01C,GAAA11C,EAAA21C,IACAC,SAAAlV,KAAAA,EAAA,GACA/oD,EAAA+oD,WAAAA,CACA,IAAAmV,GAAAv4B,EAAAo4B,EAGA,OAFA/9D,GAAA6oD,OAAAqV,EAAA,GACAl+D,EAAA8oD,OAAAoV,EAAA,IAEAj+D,KAAA,QACAf,OAAA4+D,EAAA,GAAA5+D,OACAc,MAAAA,OAMA4d,EAAA0+C,CACA3hE,GAAAD,QAAAkjB,G9E0yiBM,SAAUjjB,EAAQD,EAASM,G+Eh4iBjC,QAAAmjE,GAAA77D,EAAAghB,EAAA86C,EAAAC,GACAC,EAAAjjE,KAAAP,MACAA,KAAAwH,KAAAA,EACAxH,KAAAwoB,GAAAA,EACAxoB,KAAAujE,WAAAA,EACAvjE,KAAAmC,KAAAmhE,EACAtjE,KAAA8nD,SAbA,GAAA0b,GAAAtjE,EAAA,IACA6C,EAAA7C,EAAA,GACAoC,EAAApC,EAAA,GACA+C,EAAA/C,EAAA,IAEAujE,GADAvjE,EAAA,IACAA,EAAA,KACAwjE,EAAAxjE,EAAA,GAWAmjE,GAAAM,cAAA,6BACAN,EAAAO,WAAA,0BACAP,EAAAQ,gBAAA,+BACAR,EAAAS,aAAA,4BACAT,EAAAU,IAAA,MACAV,EAAAW,cAAA,6BACAX,EAAAY,QAAA,UAEAZ,EAAAa,SACAC,SAAAV,EAAAW,aACAC,OAAAZ,EAAAa,WACAC,MAAAd,EAAAe,UACAT,IAAAN,EAAAgB,QACAR,QAAAR,EAAAiB,aAGArB,EAAAhgE,UAAAykD,OAAA,WACA9nD,KAAA2kE,aACA3kE,KAAAujE,YACAvjE,KAAA4kE,eAIAvB,EAAAhgE,UAAAshE,WAAA,WACA3kE,KAAA6kE,mBAGAxB,EAAAhgE,UAAAwhE,gBAAA,WACA,GAAAC,GAAA9kE,IACAA,MAAAwH,KAAAu9D,YAKA,UAAA/kE,KAAAwH,KAAArC,MACAnF,KAAAwH,KAAAw9D,aAAAhlE,KAAAwH,KAAAR,MAAAiE,QACAjL,KAAAwH,KAAA6F,SAAArN,KAAAwH,KAAAu9D,cACc/kE,KAAAwH,KAAAy9D,uBACdjlE,KAAAwH,KAAAy9D,wBAAA,GAEAjlE,KAAAmC,KAAAoB,QAAAupD,SAAA9sD,KAAAwH,KAAAxH,KAAAwH,KAAAu9D,cAVA/kE,KAAAklE,YAAA,GAAA5iE,GAAAqN,UAAqD3I,OAASwD,UAAA,MAC9DxK,KAAAklE,YAAAC,kBAAA,EACAnlE,KAAA4E,IAAA5E,KAAAklE,cAaAllE,KAAAwH,KAAA49D,gBACAriE,EAAAwJ,KAAAvM,KAAAwH,KAAA49D,eAAA,SAAA3c,GAEA,GAAA4c,GAAA,KACAC,EAAAjC,EAAAa,QAAAzb,EAAA/gD,KAAAguD,cAAA,GACA,IAAA4P,EAAA,CAEA,GAAAtlE,KAAAujE,WACA,MAEA,IAAA9a,EAAA8c,OACA,MAEA,IAAA9c,EAAA/gD,MAAA27D,EAAAU,IAEAsB,EAAA/iE,EAAAiO,SAAA+0D,GAA0Et+D,OAAS+B,KAAA,WAAkBE,EAAA67D,EAAAt9D,KAAAyB,EAAA,EAAAua,WAAA,IAAmC/Z,EAAA,EAAAC,EAAA,EAAAb,MAAA,GAAAC,OAAA,KAExI2/C,EAAAl6B,SACA82C,EAAAvgE,GAAA,QAAA,SAAAd,GACAA,EAAAwS,KAAAiyC,EACAzkD,EAAAwD,KAAAs9D,EAAAt9D,KACAihD,EAAAl6B,UACAk6B,EAAAl6B,SAAAvqB,KAIAqhE,EAAAvgE,GAAA,QAAA,SAAAd,GACA,GAAAiB,KACAA,GAAAC,MAAAlB,EACAiB,EAAAb,OAAApE,KACAiF,EAAAE,KAAAk+D,EAAAS,aACAgB,EAAA1/D,QAAAH,EAAAE,KAAAF,SAGqB,IAAAwjD,EAAA/gD,MAAA27D,EAAAY,QAAA,CACrB,GAAAzzD,IAAoC/G,EAAA,EAAAC,EAAA,EAAAb,MAAA,GAAAC,OAAA,GACpCu8D,GAAA/iE,EAAAiO,SAAA+0D,GAA0Et+D,OAAS+B,KAAA,WAAkBE,EAAA67D,EAAAt9D,KAAAyB,EAAA,EAAAua,WAAA,GAAkChT,GACvI60D,EAAAvgE,GAAA,QAAA,SAAAd,GACA,GAAAiB,KACAA,GAAAC,MAAAlB,EACAiB,EAAAb,OAAApE,KACAiF,EAAAE,KAAAk+D,EAAAW,cACAc,EAAA1/D,QAAAH,EAAAE,KAAAF,SAEqB,CACrB,GAAAugE,IAAyC/7D,EAAA,EAAAC,EAAA,EAAAb,MAAA,GAAAC,OAAA,GACzCu8D,GAAA/iE,EAAAiO,SAAA+0D,GAA0Et+D,OAAS+B,KAAA,WAAkB0B,WAAA,EAAAxB,EAAA67D,EAAAt9D,KAAAyB,EAAA,EAAAnC,SAAA7D,EAAA,QAAAwlD,EAAA/gD,KAAAguD,eAAAlyC,WAAA,GAAsGgiD,EAC3M,IAAAC,IAAA,YAAA,OAAA,UACA1iE,GAAAwJ,KAAAk5D,EAAA,SAAAC,GACAL,EAAAvgE,GAAA4gE,EAAA,SAAA1hE,GACA,GAAAiB,KACAA,GAAAC,MAAAlB,EACAiB,EAAAuR,KAAAiyC,EAAA5lD,QACAoC,EAAAE,KAAA,iBAAAugE,EAAA,QACAZ,EAAA1/D,QAAAH,EAAAE,KAAAF,YAMAogE,GAAA3B,EAAAiC,aAAAld,EAAAmd,SAAA,EAAA,EAAAnd,EAAA5/C,OAAA,GAAA4/C,EAAA3/C,QAAA,GAAAg8D,EAAAt9D,KAAAyB,EAAA,EAAAw/C,EAAAj2C,OAAA,QACA6yD,EAAAvgE,GAAA,QAAA,SAAAd,GACAA,EAAAwS,KAAAiyC,EACAzkD,EAAAwD,KAAAs9D,EAAAt9D,KACAihD,EAAAl6B,UACAk6B,EAAAl6B,SAAAvqB,EAEA,IAAAwN,IAAqCtM,MAAAlB,EAAAmB,KAAA,iBAAAsjD,EAAA/gD,KAAA,QACrCo9D,GAAA3iE,KAAAiD,QAAAoM,EAAArM,KAAAqM,IAGA6zD,GAAA39D,KAAA+gD,EAAA/gD,KACAo9D,EAAAlgE,IAAAygE,MAKAhC,EAAAhgE,UAAAwiE,eAAA,SAAAr+D,EAAAs+D,GACA,GAAA7/D,GAAA,EACA8/D,EAAAD,EAAAtuB,OAAA,EAEAx3C,MAAAklE,aAAAllE,KAAAklE,YAAAziD,UAAuD+0B,OAAAsuB,EAAAtuB,SAEvDx3C,KAAA87C,UAAA,SAAAkqB,GACAA,EAAAb,kBAEAa,EAAAp3D,KAAA,YAAAm3D,EAAA,GAAA,EAAA,GAAA9/D,IAAA8/D,EAAA,GAAA,OAIA/lE,KAAAimE,qBAAAz+D,EAAAs+D,IAGAzC,EAAAhgE,UAAAuhE,YAAA,aAGAvB,EAAAhgE,UAAA4iE,qBAAA,SAAAz+D,EAAAs+D,GAGA,GAAAt+D,EAAApB,QAAAoB,EAAApB,OAAAzB,MAAA,GAAA6C,EAAApB,OAAAzB,MAAA,cAAA6C,EAAApB,OAAAjB,KACAnF,KAAA4O,KAAA,YAAAk3D,EAAAr8D,EAAAq8D,EAAAp8D,QACS,CACT,GAAAw8D,GAAA1+D,EAAArD,MAAAqD,EAAArD,MAAAsF,EAAA,EACA08D,EAAA3+D,EAAArD,MAAAqD,EAAArD,MAAAuF,EAAA,CACA1J,MAAA4O,KAAA,YAAAk3D,EAAAr8D,EAAAjC,EAAApB,OAAAmD,SAAA,GAAA28D,EAAAJ,EAAAp8D,EAAAlC,EAAApB,OAAAmD,SAAA,GAAA48D,MAIA9C,EAAAhgE,UAAA+iE,QAAA,WACApmE,KAAAwH,KAAAu9D,cACA,UAAA/kE,KAAAwH,KAAArC,KACAnF,KAAAwH,KAAA6F,SAAArN,KAAAwH,KAAAw9D,cACahlE,KAAAwH,KAAAy9D,uBACbjlE,KAAAwH,KAAAy9D,wBAAA,GAEAjlE,KAAAmC,KAAAoB,QAAAypD,YAAAhtD,KAAAwH,QAMAzE,EAAAmO,SAAAmyD,EAAAG,GACA3jE,EAAAD,QAAAyjE,G/Eo5iBM,SAAUxjE,EAAQD,EAASM,GgF7kjBjC,QAAAsjE,KACAxjE,KAAAqmE,WAAAh6D,EAAA82C,UACA7gD,EAAAoC,MAAAnE,KAAAP,MALA,GAAAsC,GAAApC,EAAA,GACAmM,EAAAnM,EAAA,GAWAsjE,GAAAngE,UAAAykD,OAAA,aAOA0b,EAAAngE,UAAAuiD,QAAA,SAAAlgD,KAQA89D,EAAAngE,UAAAijE,SAAA,SAAA5+D,EAAA8K,EAAAjJ,GACA,GAAAE,GAAAC,EAAA68D,EAAAvmE,KAAAwmE,SAAA9+D,IACA,OAAAA,IACA6+D,EAAA7+D,EAEA,IAAAwD,GAAA,GAAA5I,GAAA+M,MACArI,OACAkE,KAAAq7D,EACA/zD,MAAAA,EAAAA,EAAAxS,KAAA6C,QAAAqI,KAAAsH,MACAO,SAAA,wBAEAqQ,OAAA,IAIA,QADA7Z,EAAAA,EAAAA,EAAA,QAGA,IAAA,OAEAE,EAAAzJ,KAAA4lD,UAAAn8C,EAAAzJ,KAAAuJ,SAAA,GAAA2B,EAAA2F,kBAAAhI,MAAA,EAEAa,EAAA1J,KAAA4lD,UAAAl8C,EAAA1J,KAAAuJ,SAAA,GAAAvJ,KAAA6Q,kBAAA/H,OAAA,EAAA,CACA,MAEA,KAAA,SACAW,EAAAzJ,KAAA4lD,UAAAn8C,EAAAzJ,KAAAuJ,SAAA,GAAA2B,EAAA2F,kBAAAhI,MAAA,EACAa,EAAA1J,KAAA4lD,UAAAl8C,EAAA1J,KAAAuJ,SAAA,GAAA,CACA,MAEA,KAAA,OACAE,EAAAzJ,KAAA4lD,UAAAn8C,EAAAzJ,KAAAuJ,SAAA,GAAA2B,EAAA2F,kBAAAhI,MAAA,EACAa,EAAA1J,KAAA4lD,UAAAl8C,EAAA1J,KAAAuJ,SAAA,GAAA,EAKA,MADA2B,GAAA0D,KAAA,SAA4BnF,EAAAA,EAAAC,EAAAA,KAE5BwB,KAAAA,EACAsF,KAAAtF,EAAA2F,oBAOA2yD,EAAAngE,UAAAojE,YAAA,SAAA3nB,GACA,GAAAr1C,GAAAC,EAAAwB,EAAAlL,KAAAyH,YAAA,QAEA,QADAq3C,EAAAA,EAAAA,EAAA,QAEA,IAAA,OACAr1C,EAAAzJ,KAAA4lD,UAAAn8C,EAAAzJ,KAAAuJ,SAAA,GAAA2B,EAAA2F,kBAAAhI,MAAA,EACAa,EAAA1J,KAAA4lD,UAAAl8C,EAAA1J,KAAAuJ,SAAA,GAAAvJ,KAAA6Q,kBAAA/H,OAAA,EAAA,CACA,MACA,KAAA,SACAW,EAAAzJ,KAAA4lD,UAAAn8C,EAAAzJ,KAAAuJ,SAAA,GAAA2B,EAAA2F,kBAAAhI,MAAA,EACAa,EAAA1J,KAAA4lD,UAAAl8C,EAAA1J,KAAAuJ,SAAA,GAAA,CACA,MACA,KAAA,OACAE,EAAA,EACAC,EAAA1J,KAAA4lD,UAAAl8C,EAAA1J,KAAAuJ,SAAA,GAAA,EAIA2B,EAAA0D,KAAA,SAA4BnF,EAAAA,EAAAC,EAAAA,KAM5B85D,EAAAngE,UAAAqjE,OAAA,aAEApkE,EAAA8M,KAAA8B,SAAAsyD,EAAAlhE,EAAAoC,OACA7E,EAAAD,QAAA4jE,GhFyljBM,SAAU3jE,EAAQD,EAASM,GiFzpjBjC,QAAA+C,GAAAJ,GACA2gE,EAAAjjE,KAAAP,MACAA,KAAA2mE,IAAA9jE,MACA7C,KAAA2mE,IAAApkE,OACAvC,KAAAqmE,WAAArmE,KAAA2mE,IAAApkE,MAAAsD,IAAA,cACA7F,KAAAuC,MAAAvC,KAAA2mE,IAAApkE,MACAvC,KAAA2mE,IAAA3mE,KAAA2mE,IAAApkE,MAAAqkE,SAEA5mE,KAAAqmE,WAAAj3D,EAAA+zC,UACAnjD,KAAAuC,MAAA,GAAAC,OAEA,IAAAqkE,IACAC,QAAqB3hE,KAAA,QAAA4hE,KAAA,GAAAv0D,MAAAvP,EAAA+jE,aAAAC,MAAA,EAAA3/C,OAAA,GACrBtgB,OAAoB0K,UAAA,EAAA9E,OAAA3J,EAAA+jE,aAAAlgE,SAAA7D,EAAAikE,eACpBr6D,YAAyB6E,UAAA,EAAA9E,OAAA3J,EAAAkkE,gBACzBC,iBAA8Br+D,KAAA9F,EAAAkkE,gBAC9BhjE,OAAoBqzC,OAAA,KAAA2G,QAAA,EAAAC,iBAAA,MACpB70C,UAAuB89D,SAAA,KAAAC,OAAA,KACvBC,aAAA,EAAA,GACAC,WAAA,EAAA,GACAC,gBAAA,GAAA,IACAjwB,OAAA,MAEAkwB,oBAAA,EACAC,gBAAA,KACA78D,QAAA,EACAI,MACAA,KAAA,KACAgI,SAAA,UACAH,SAAA,uBACA60D,QAAA,SACAC,gBAAA,GAEA5+D,EAAA,EAGAjJ,MAAA6C,QAAAuM,EAAA44C,SAAA6e,EAAA7mE,KAAA2mE,KAAA,EAAA,mBACA3mE,KAAA8nE,WACA9nE,KAAA+nE,eAAA,GAAAzlE,GAAAoC,MACA1E,KAAA4G,UAAA,KACA5G,KAAA6G,QAAA,KACA7G,KAAAopC,KAAA,KACAppC,KAAAgoE,WAAA,GAAA1lE,GAAAoC,MACA1E,KAAAioE,SACAjoE,KAAA8nD,SA3EA,GAAA14C,GAAAlP,EAAA,IACA6C,EAAA7C,EAAA,GACAkuC,EAAAluC,EAAA,IACAoC,EAAApC,EAAA,GACAsjE,EAAAtjE,EAAA,IACAwjE,EAAAxjE,EAAA,IACAgoE,EAAAhoE,EAAA,IACAioE,EAAAjoE,EAAA,IACAkoE,EAAAloE,EAAA,IACAwkD,EAAAxkD,EAAA,IACAsC,EAAAtC,EAAA,GAEA+C,GAAAikE,cAAA,WACAjkE,EAAAolE,YAAA,SACAplE,EAAAqlE,WAAA,QACArlE,EAAAslE,WAAA,QACAtlE,EAAAulE,OAAA,EACAvlE,EAAAwlE,WAAA,YACAxlE,EAAAylE,SAAA,UACAzlE,EAAA0lE,KAAA,OACA1lE,EAAA2lE,MAAA,QACA3lE,EAAA4lE,IAAA,MACA5lE,EAAA6lE,OAAA,SACA7lE,EAAA6lE,OAAA,SACA7lE,EAAA8lE,UAAA,IACA9lE,EAAA+jE,aAAA,OACA/jE,EAAAkkE,eAAA,UA0DAlkE,EAAAI,UAAA8e,QAAA,SAAA6mD,GACAA,IACAhpE,KAAAipE,cAAAD,EAGA,IAAAxxB,GAAApoC,EAAA61C,eAAAjlD,KAAAipE,cAEAjpE,MAAA6C,QAAAmE,MAAAF,UAAA7D,EAAAqlE,YAAA9wB,EAAAtxC,OAAA,EACAlG,KAAAkpE,YAAAlpE,KAAAipE,eAEAjpE,KAAAopC,KAAAx6B,KAAA,SAAqC4oC,OAAAA,GAGrC,IAAA2xB,GAAAnpE,KAAAyH,YAAA,YACAssB,EAAA/zB,KAAAopE,IACA,IAAAppE,KAAA6C,QAAAmE,MAAAF,UAAA7D,EAAAslE,YAAAxlE,EAAAyS,QAAAxV,KAAA6C,QAAAqI,KAAAA,MACAlL,KAAA6C,QAAAqI,KAAAA,KAAAwL,QAAA,SAAAsF,EAAA/V,GACAmjE,EAAAthE,KAAAisB,EAAAtsB,YAAA,YAAAxB,UAES,KAAAkjE,GAAAnpE,KAAA6C,QAAAqI,KAAAA,KAAA,CACT,GAAAA,GAAAlL,KAAAsmE,SAAA,WAAAtmE,KAAA6C,QAAAqI,KAAAA,KAAA,EAAA,EACAlL,MAAA4E,IAAAsG,EAAAA,MACAi+D,EAAAnpE,KAAAyH,YAAA,YAEA,GAAA2hE,EAAAljE,OAAA,EAAA,CACA,GAAAmjE,GAAAD,EAAAljE,OACA+mB,EAAAjtB,KAAAipE,cAAA,GAAAx/D,EAAAzJ,KAAAipE,cAAA,GAAAx/D,EACA+qB,EAAAvqB,SAAAgjB,EAAAo8C,GACAvqB,GAAA,EAAA70C,SAAAo/D,EAAA,EAEAD,GAAA1yD,QAAA,SAAAsF,EAAA/V,GACA,GAAAqjE,GAAAv1C,EAAAw1C,eAAAx1C,EAAAlxB,QAAAqI,MAAAs+D,EAAA,GAEAC,EAAA11C,EAAA21C,gBAAAJ,EACAG,SAAA,IAAAA,EACAA,EAAA,EAEAD,EAAAC,EAAA,EAAA,OAAA,QAEAA,EAAA16D,KAAAoF,IAAAs1D,EACA,IAAAE,GAAA,IAAAF,EAAA16D,KAAAoM,GACA4O,EAAA,KAAA7jB,EAAA,IACA8V,GAAA3O,SAAA,OAAAtK,EAAA4U,SAAAoc,EAAAlxB,QAAAqI,KAAAA,KAAAjF,IAAA8tB,EAAAlxB,QAAAqI,KAAAA,KAAAjF,GAAA8tB,EAAAlxB,QAAAqI,KAAAA,KAAAjF,GAAAiF,MAEAs+D,GACAz/C,EAAA4/C,EAAA,IAAAA,EAAA,IAAA56D,KAAAoM,GAAA,KAAA,GAAAwuD,GAAA56D,KAAAoM,GAAA,IACA4O,EAAA,UAAAy/C,GAAA,EAAAz/C,GAEAA,EAAA,GAAAhb,KAAAoM,GAAA,IAEAa,EAAApN,KAAA,WAAAmb,GAEA,KAAA4/C,EACAL,EAAA,IAAAxqB,GAEAwqB,EAAA,IAAAxqB,EACA,IAAA2qB,IACAvjE,EAAA6I,KAAA60B,IAAA+lC,EAAA56D,KAAAoM,GAAA,KAAA2jC,EACAA,EAAA,EACAwqB,EAAA,IAAA,SAAAE,EAAAtjE,GAAA,EAEAojE,EAAA,IAAA,SAAAE,GAAA,EAAA,IAKAxtD,EAAApN,KAAA,WAAA06D,GACAxqB,GAAAtqB,IAGA,GAAA20C,EAAA,CACAA,EAAA97D,SAAA,OAAArN,KAAA6C,QAAAqI,KAAAA,KACA,IAAAo+D,GAAAtpE,KAAAupE,eAAAvpE,KAAA6C,QAAAqI,KACAlL,MAAA6C,QAAAmE,MAAAF,UAAA7D,EAAAikE,eAAAlnE,KAAA6C,QAAAqI,KAAA28D,gBACAsB,EAAAv6D,KAAA,WAAA5O,KAAA0pE,gBAAAJ,IAEAH,EAAAv6D,KAAA,WAAA06D,GAEAtpE,KAAA4pE,oBAAApyB,IAMAv0C,EAAAI,UAAAykD,OAAA,WACA,GAAA7jD,GAAAjE,IAEAA,MAAA6pE,qBAGA7pE,KAAA8pE,UAAA,GAAAxnE,GAAAsN,aAEA5I,MAAAhH,KAAA6C,QAAAmE,MACAiC,EAAAjJ,KAAA6C,QAAAoG,IAEAjJ,KAAAgoE,WAAApjE,IAAA5E,KAAA8pE,WACA9pE,KAAA4E,IAAA5E,KAAAgoE,YACAhoE,KAAA4E,IAAA5E,KAAA+nE,gBAEA/nE,KAAA+pE,SAAA,GAAAznE,GAAAqN,UAEAxL,MAAAnE,KAAA6C,QAAAsB,MACA6C,MAAAhH,KAAA6C,QAAAmE,MACAiC,EAAAjJ,KAAA6C,QAAAoG,IAEAjJ,KAAA4E,IAAA5E,KAAA+pE,UAEA/pE,KAAA6C,QAAAmE,MAAAF,UAAA7D,EAAAqlE,YACAtoE,KAAAopC,KAAAppC,KAAAgoE,WACAhoE,KAAAgqE,iBAAAhqE,KAAA8pE,WACA9pE,KAAA+pE,SAAA1hD,SAEAroB,KAAAopC,KAAAppC,KAAA+pE,SACA/pE,KAAAgqE,iBAAAhqE,KAAA+pE,UACA/pE,KAAA8pE,UAAAzhD,OAIA,IAAAo9C,IAAA,WAAA,QAwBA,IAvBA1iE,EAAAwJ,KAAAk5D,EAAA,SAAAC,GACA1lE,KAAAopC,KAAAtkC,GAAA4gE,EAAA3iE,EAAAkE,KAAA,SAAAjD,GACAA,EAAA2pD,cAAA,CACA,IAAA1oD,KACAA,GAAAC,MAAAlB,EACAiB,EAAAE,KAAA,aAAAugE,EACAzgE,EAAAb,OAAAH,EACAjE,KAAAoF,QAAAH,EAAAE,KAAAF,GACAjF,KAAAqN,UAA+BmF,MAAAvP,EAAAkkE,iBAA+B,GAC9D,GAAAnnE,KAAA6C,QAAAiI,SAGA9K,KAAA6C,QAAAiI,QAAA9K,KAAAipE,cAAA/iE,QAAA,GACAlG,KAAAiqE,2BAEAjqE,KAAA8nE,QAAA5hE,OAAA,GACAlG,KAAAkqE,mBAGalqE,QACJA,MAGTA,KAAA6C,QAAAqI,KAAAA,KAAA,CACA,GAAAA,GAAA,IA0BA,IAzBAnI,EAAAyS,QAAAxV,KAAA6C,QAAAqI,KAAAA,OAAAlL,KAAA6C,QAAAmE,MAAAF,UAAA7D,EAAAslE,WACAvoE,KAAA6C,QAAAqI,KAAAA,KAAAwL,QAAA,SAAAsF,EAAA/V,GACA,GAAAkkE,GAAAlmE,EAAAqiE,SAAA,YAAArgE,EAAA+V,EAAA,EAAA,EACA,IAAAjZ,EAAA4U,SAAAqE,GAAA,CACA,GAAAvF,KACAA,GAAAvL,KAAA8Q,EACAvF,EAAA2zD,OAAAD,EAAAj/D,KAAA7K,GACA4D,EAAApB,QAAAqI,KAAAA,KAAAjF,GAAAwQ,MAEAxS,GAAApB,QAAAqI,KAAAA,KAAAjF,GAAAmkE,OAAAD,EAAAj/D,KAAA7K,EAGA,IADA4D,EAAAW,IAAAulE,EAAAj/D,MACAi/D,GAAAlmE,EAAA0iE,IAAAgB,gBAAA,CACA,GAAAA,GAAA1jE,EAAA0iE,IAAAgB,eACAwC,GAAAj/D,KAAApG,GAAA,cAAA,SAAAd,GACAA,EAAAkB,MAAA+6D,iBACAj8D,EAAAkB,MAAAg7D,kBACAyH,EAAA0C,UAAArmE,EAAAkB,MAAAlF,YAKAkL,EAAAlL,KAAAsmE,SAAA,WAAAtmE,KAAA6C,QAAAqI,KAAAA,KAAA,EAAA,GACAlL,KAAA4E,IAAAsG,EAAAA,OAEAA,GAAAlL,KAAA2mE,IAAAgB,gBAAA,CACA,GAAAA,GAAA3nE,KAAA2mE,IAAAgB,eACAz8D,GAAAA,KAAApG,GAAA,cAAA,SAAAd,GACAA,EAAAkB,MAAA+6D,iBACAj8D,EAAAkB,MAAAg7D,kBACAyH,EAAA0C,UAAArmE,EAAAkB,MAAAlF,WAMAiD,EAAAI,UAAAwmE,mBAAA,SAAAhnE,GACA,GAAAynE,GAAAtqE,KAAA2lE,aAAA,WAAA3lE,KAAA6C,QAKA,IAJAynE,GACAtqE,KAAA4E,IAAA0lE,GAGAtqE,KAAA6C,QAAAikE,OAAAG,KAAA,CACA,GAAAsD,GAAAvqE,KAAA2lE,aAAA,aAAA3lE,KAAA6C,QACA0nE,IACAvqE,KAAA4E,IAAA2lE,KAKAtnE,EAAAI,UAAAumE,oBAAA,SAAApyB,GACA,GAAA8yB,GAAAtqE,KAAAyH,YAAA,YACA8iE,EAAAvqE,KAAAyH,YAAA,cACA8B,KAAA+d,EAAAtnB,KAAA6C,QAAAikE,OAAAx/C,MACA,IAAAgjD,EACA,GAAAtqE,KAAA6C,QAAA2nE,QAAAxqE,KAAA6C,QAAA2nE,OAAAliD,KACA,GAAA6/C,GAAAmC,EAAAtqE,KAAA6C,QAAA7C,KAAAgoE,WAAAhoE,KAAA+pE,cACa,CAEb,GADAxgE,EAAAiuC,EAAAA,EAAAtxC,OAAA,GACAlG,KAAA6C,QAAAmE,MAAAF,WAAA7D,EAAAqlE,WAAA,CACA,GAAAr7C,GAAAmhB,EAAAnhB,SAAAuqB,EAAAA,EAAAtxC,OAAA,GAAAsxC,EAAAA,EAAAtxC,OAAA,GAEAqD,GADA+d,GAAA2F,EACAmhB,EAAAhhB,QACAoqB,EAAAA,EAAAtxC,OAAA,GAAAsxC,EAAAA,EAAAtxC,OAAA,GACAohB,EAAA2F,GAEAuqB,EAAAA,EAAAtxC,OAAA,GAGAokE,EAAA17D,KAAA,WAAArF,GACA+gE,EAAA17D,KAAA,WAAAQ,EAAAy2C,gBAAA7lD,KAAAipE,cAAAjpE,KAAAipE,cAAA/iE,OAAA,GAAAlG,KAAAipE,cAAAjpE,KAAAipE,cAAA/iE,OAAA,KAIA,GAAAqkE,EAAA,CAEA,GADAhhE,EAAAiuC,EAAA,GACAx3C,KAAA6C,QAAAmE,MAAAF,WAAA7D,EAAAqlE,WAAA,CACA,GAAAmC,GAAAr8B,EAAAnhB,SAAAuqB,EAAA,GAAAA,EAAA,GAEAjuC,GADA+d,GAAAmjD,EACAr8B,EAAAhhB,QACAoqB,EAAA,GAAAA,EAAA,GACAlwB,EAAAmjD,GAEAjzB,EAAA,GAGA+yB,EAAA37D,KAAA,WAAArF,GACAghE,EAAA37D,KAAA,WAAAQ,EAAAy2C,gBAAA7lD,KAAAipE,cAAA,GAAAjpE,KAAAipE,cAAA,OAQAhmE,EAAAI,UAAAgK,SAAA,SAAAxK,EAAA6nE,GACA,GAAAJ,GAAA,IAwBA,IAvBAznE,EAAA2P,QACAxS,KAAA6C,QAAAmE,MAAAF,UAAA7D,EAAAqlE,WACAtoE,KAAAgoE,WAAAlsB,UAAA,SAAAjL,GACAA,EAAAjiC,KAAA,SAAyChC,OAAA/J,EAAA2P,QACzClQ,EAAA8P,eAAAy+B,GAAmDjkC,OAAA/J,EAAA2P,WAGnDxS,KAAA+pE,SAAAn7D,KAAA,SAA6ChC,OAAA/J,EAAA2P,QAC7ClQ,EAAA8P,eAAApS,KAAA+pE,UAAuDn9D,OAAA/J,EAAA2P,SAEvD83D,EAAAtqE,KAAAyH,YAAA,YACA6iE,IACAA,EAAA17D,KAAA,SAAwC7F,KAAAlG,EAAA2P,QACxClQ,EAAA8P,eAAAk4D,GAAkDvhE,KAAAlG,EAAA2P,SAElDk4D,IACA1qE,KAAA6C,QAAAmE,MAAA4F,OAAA/J,EAAA2P,MACAxS,KAAAuC,MAAAE,IAAA,uBAAAI,EAAA2P,OACAxS,KAAAuC,MAAAE,IAAA,uBAAAI,EAAA2P,OACAxS,KAAA6C,QAAAikE,OAAAt0D,MAAA3P,EAAA2P,QAIA3P,EAAAqI,KAAA,CACA,GAAAi+D,GAAAnpE,KAAAyH,YAAA,WAEA,KAAA0hE,GAAAtmE,EAAAqI,KAAAA,KAAA,CACA,GAAAA,GAAAlL,KAAAsmE,SAAA,WAAAzjE,EAAAqI,KAAAA,KAAA,EAAA,EACAlL,MAAA4E,IAAAsG,EAAAA,MACAi+D,EAAAnpE,KAAAyH,YAAA,aAGA5E,EAAAqI,KAAAA,MAAA,IAAArI,EAAAqI,KAAAA,QACAi+D,EAAA97D,SAAA,OAAAxK,EAAAqI,KAAAA,MACAlL,KAAA6C,QAAAqI,KAAAA,KAAArI,EAAAqI,KAAAA,KAEA,IAAAo+D,GAAAtpE,KAAAupE,eAAA1mE,EAAAqI,KACAi+D,GAAAv6D,KAAA,WAAA06D,GACAzmE,EAAAqI,KAAA08D,UACA5nE,KAAA6C,QAAAqI,KAAA08D,QAAA/kE,EAAAqI,KAAA08D,SAEA/kE,EAAAqI,KAAAoc,SACAtnB,KAAA6C,QAAAqI,KAAAoc,OAAAzkB,EAAAqI,KAAAoc,QAGAzkB,EAAAqI,KAAAgI,WACAi2D,EAAAv6D,KAAA,SACAsE,SAAArQ,EAAAqI,KAAAgI,WAEAlT,KAAA6C,QAAAqI,KAAAgI,SAAArQ,EAAAqI,KAAAgI,UAEAlT,KAAAuC,MAAAE,IAAA,eAAAI,EAAAqI,MAGA,GAAArI,EAAAikE,OAAA,CACAjkE,EAAAikE,OAAA3hE,OACAnF,KAAA6C,QAAAikE,OAAA3hE,KAAAtC,EAAAikE,OAAA3hE,KACAnF,KAAAuC,MAAAE,IAAA,sBAAAI,EAAAikE,OAAA3hE,OAEAtC,EAAAikE,OAAAC,OACA/mE,KAAA6C,QAAAikE,OAAAC,KAAAlkE,EAAAikE,OAAAC,KACA/mE,KAAAuC,MAAAE,IAAA,sBAAAI,EAAAikE,OAAAC,OAEAlkE,EAAAikE,OAAAt0D,QACAxS,KAAA6C,QAAAikE,OAAAt0D,MAAA3P,EAAAikE,OAAAt0D,MACAxS,KAAAuC,MAAAE,IAAA,uBAAAI,EAAAikE,OAAAt0D,QAEA3P,EAAAikE,OAAA79D,IACAjJ,KAAA6C,QAAAikE,OAAA79D,EAAApG,EAAAikE,OAAA79D,EACAjJ,KAAAuC,MAAAE,IAAA,mBAAAI,EAAAikE,OAAA79D,IAGAqhE,EAAAtqE,KAAAyH,YAAA,YACA6iE,GACAtqE,KAAAkE,OAAAomE,EAEA,IAAAxD,GAAA9mE,KAAA2lE,aAAA,WAAA3lE,KAAAuC,MAAAsD,IAAA,WACAihE,IACA9mE,KAAA4E,IAAAkiE,GAEA9mE,KAAAmiB,YASAlf,EAAAI,UAAAkmE,eAAA,SAAAr+D,GACA,GAAAy/D,MACAzlD,EAAA5iB,EAAAgN,YAAA9L,SAAA0H,EAAAA,KAAAA,EAAA6H,SACA,IAAA7H,GAAAA,EAAA08D,QAAA,CACA,GAAAtgD,GAAApc,EAAAoc,QAAA,EACAsjD,EAAAtjD,CAIA,IAHAvkB,EAAAyS,QAAA8R,KACAsjD,GAAAtjD,EAAA,IAEA,SAAApc,EAAA08D,QACA+C,GAAA3qE,KAAAipE,cAAA,GAAAx/D,EAAAmhE,EAAA,GAAA5qE,KAAAipE,cAAA,GAAAv/D,EAAAkhE,EAAA,QACa,IAAA,OAAA1/D,EAAA08D,QAAA,CACb,GAAApwB,GAAApoC,EAAAo0C,kBAAAxjD,KAAAipE,cAAAjpE,KAAAipE,cAAA/iE,OAAA,GAAAlG,KAAAipE,cAAAjpE,KAAAipE,cAAA/iE,OAAA,KACAgyC,EAAA9oC,EAAAi3C,SAAA7O,EAAA,GAAAA,EAAA,IACAtxC,EAAAkJ,EAAA6d,SAAAuqB,EAAA,GAAAA,EAAA,IAAAtyB,EACAskC,EAAAp6C,EAAAq2C,YAAAjO,EAAA,GAAAtxC,EAAAgyC,EACAyyB,IAAAnhB,EAAA//C,EAAAmhE,EAAA,GAAAphB,EAAA9/C,EAAAkhE,EAAA,QACa,CACb,GAAAC,GAAA7qE,KAAAgrC,OAAA9/B,EACAy/D,IAAAE,EAAA,GAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,SAES,CACT,GAAArhE,GAAAvJ,KAAAgrC,OAAA9/B,EACAy/D,IAAAphE,EAAA,GAAA2b,EAAA,EAAA3b,EAAA,IAGA,MAAAohE,IAQA1nE,EAAAI,UAAAqmE,gBAAA,SAAAiB,GAEA,GAAAnzB,GAAApoC,EAAAo0C,iBAAAxjD,KAAAipE,eACA/wB,GAAAnpC,KAAA2b,MAAA8sB,EAAA,GAAA9tC,EAAAihE,EAAA,GAAAnzB,EAAA,GAAA/tC,EAAAkhE,EAAA,GACA,OAAAzyB,IAGAj1C,EAAAI,UAAA2mE,iBAAA,SAAAv9D,GACA,GAAAzM,KAAA6C,QAAAgK,WAAA,CACAvK,EAAAsL,mBAAAnB,EAAAzM,KAAA6C,QAAAgK,WAEA,IAAAy9D,GAAAtqE,KAAAyH,YAAA,WACA6iE,IAA2BhoE,EAAAsL,mBAAA08D,EAAAtqE,KAAA6C,QAAAukE,iBAE3B36D,EAAA3H,GAAA,YAAA/B,EAAAkE,KAAA,WACA3E,EAAAmL,aAAAhB,GACA69D,GAAmChoE,EAAAmL,aAAA68D,GAEnCtqE,KAAAgoE,WAAAlsB,UAAA,SAAA1S,GACA9mC,EAAAmL,aAAA27B,MAEiBppC,OACjB8E,GAAA,WAAA/B,EAAAkE,KAAA,WACA3E,EAAAqL,aAAAlB,GACA69D,GAAmChoE,EAAAqL,aAAA28D,GACnCtqE,KAAAgoE,WAAAlsB,UAAA,SAAA1S,GACA9mC,EAAAqL,aAAAy7B,MAEiBppC,SASjBiD,EAAAI,UAAA4mE,yBAAA,WACAjqE,KAAA8qE,sBAAA9qE,KAAAA,KAAAipE,cAAA,GAAAh+D,QAAAm9D,EAAA2C,gBACA/qE,KAAA8qE,sBAAA9qE,KAAAA,KAAAipE,cAAAjpE,KAAAipE,cAAA/iE,OAAA,GAAA+E,QAAAm9D,EAAA2C,iBAWA9nE,EAAAI,UAAAynE,sBAAA,SAAA3mE,EAAAo7C,EAAAp6C,GACA,GAAA6lE,GAAA,GAAA5C,GAAApoE,KAAAu/C,EAAAp6C,EAAAnF,KAAA6C,QACA7C,MAAA+nE,eAAAnjE,IAAAomE,EAAA7mE,QAOAlB,EAAAI,UAAA4nE,aAAA,WACA,IAAA,GAAAhlE,GAAA,EAAuBA,EAAAjG,KAAA8nE,QAAA5hE,OAAyBD,IAChDjG,KAAAkE,OAAAlE,KAAA8nE,QAAA7hE,GAAAilE,YAEAlrE,MAAA8nE,WACA9nE,KAAA+nE,gBACA/nE,KAAA+nE,eAAAlsB,YAGA77C,KAAAqN,UAAuBmF,MAAAxS,KAAA6C,QAAAmE,MAAA4F,SAAgC,IAOvD3J,EAAAI,UAAA6mE,eAAA,WACA,IAAA,GAAAjkE,GAAA,EAAuBA,EAAAjG,KAAAipE,cAAA/iE,OAAA,EAAmCD,IAAA,CAC1D,GAAAqjB,GACA7f,EAAAC,EAEAyhE,EAAA/7D,EAAA02C,aAAA9lD,KAAAipE,cAAAhjE,EAAA,GAAAjG,KAAAipE,cAAAhjE,GAAAjG,KAAAipE,cAAAhjE,EAAA,IACAmlE,EAAAh8D,EAAA02C,aAAA9lD,KAAAipE,cAAAhjE,GAAAjG,KAAAipE,cAAAhjE,EAAA,GAAAjG,KAAAipE,cAAAhjE,EAAA,KACAklE,GAAAC,IAAAprE,KAAAipE,cAAAhjE,EAAA,GAAA2jD,OAAA5pD,KAAAipE,cAAAhjE,EAAA,OAAAklE,IAAAnrE,KAAAipE,cAAAhjE,EAAA,GAAA2jD,OAAA5pD,KAAAipE,cAAAhjE,KAAAmlE,KAEAprE,KAAAipE,cAAAhjE,GAAAwD,IAAAzJ,KAAAipE,cAAAhjE,EAAA,GAAAwD,GACAA,EAAAzJ,KAAAipE,cAAAhjE,GAAAwD,EACAC,GAAA1J,KAAAipE,cAAAhjE,GAAAyD,EAAA1J,KAAAipE,cAAAhjE,EAAA,GAAAyD,GAAA,EAEA4f,EAAA,GAAA4+C,GAAA,IAAAz+D,EAAAC,EAAA1J,OAGiBA,KAAAipE,cAAAhjE,GAAAyD,IAAA1J,KAAAipE,cAAAhjE,EAAA,GAAAyD,IACjBD,GAAAzJ,KAAAipE,cAAAhjE,GAAAwD,EAAAzJ,KAAAipE,cAAAhjE,EAAA,GAAAwD,GAAA,EACAC,EAAA1J,KAAAipE,cAAAhjE,GAAAyD,EACA4f,EAAA,GAAA4+C,GAAA,IAAAz+D,EAAAC,EAAA1J,OAEAspB,IACAtpB,KAAA4E,IAAA0kB,EAAA4hD,aACAlrE,KAAA8nE,QAAAhgE,KAAAwhB,OAcArmB,EAAAI,UAAAsiE,aAAA,SAAAj+D,EAAA7E,GACA,GAAAwoE,GAAAxoE,EAAAikE,OAAA3hE,KACAmmE,EAAAzoE,EAAAikE,OAAAC,IACA,IAAA,SAAAsE,EAAA,CAIAtoE,EAAAyS,QAAA81D,KACAA,GAAAA,EAAAA,GAGA,IAAAC,GAAA1oE,EAAAoG,CAEApG,GAAAikE,OAAA79D,IAA+BsiE,EAAA1oE,EAAAikE,OAAA79D,EAE/B,IAAAuiE,GAAA9H,EAAAiC,aACA0F,GAAAC,EAAA,GAAA,GAAAA,EAAA,GAAA,EACAA,EAAA,GAAAA,EAAA,GAAAC,EAAA1oE,EAAAikE,OAAAt0D,MAIA,OAFAg5D,GAAA9jE,KAAAA,EAEA8jE,IAYAvoE,EAAAI,UAAAijE,SAAA,SAAA5+D,EAAAyiE,EAAA1gE,EAAAC,EAAA8I,GACA,GAAAm0D,GAAA5jE,EAAA4U,SAAAwyD,IAA8Cj/D,KAAAi/D,EAAA1gE,EAAAA,EAAAC,EAAAA,EAAAX,KAAAyJ,GAC9CzP,EAAA6I,UAA8DnC,EAAAA,EAAAC,EAAAA,EAAAX,KAAAyJ,GAAqB23D,GAAA,GAEnF73D,EAAAvP,EAAA6I,SAAA7I,EAAAkI,MAAAjL,KAAA6C,QAAAqI,MAAAy7D,GAAA,GACAz7D,EAAA,GAAA5I,GAAA+M,MACArI,MAAAsL,EACA8Q,OAAA,GACA1b,KAAAA,GAEA,QACAwD,KAAAA,EACAsF,KAAAtF,EAAA2F,oBAQA5N,EAAAI,UAAA2nC,OAAA,WAEA,GAAAhrC,KAAA6C,QAAAmE,MAAAF,UAAA7D,EAAAikE,eAAAlnE,KAAA6C,QAAAmE,MAAAF,UAAA7D,EAAAslE,WAAA,CACA,GAAA/wB,GAAApoC,EAAAo0C,iBAAAxjD,KAAAipE,eAcAwC,GAAAj0B,EAAA,GAAA/tC,EAAA+tC,EAAA,GAAA/tC,GAAA,EACAiiE,GAAAl0B,EAAA,GAAA9tC,EAAA8tC,EAAA,GAAA9tC,GAAA,CACA,QAAA+hE,EAAAC,GACS,GAAA1rE,KAAA6C,QAAAmE,MAAAF,UAAA7D,EAAAolE,YAAA,CAQT,IAAA,GALAp7C,GAAAjtB,KAAAomD,YAGApZ,KACA2+B,EAAA,EACA1lE,EAAA,EAA2BA,EAAAjG,KAAAipE,cAAA/iE,OAAA,EAAmCD,IAAA,CAC9D+mC,EAAA/mC,CACA,IAAA2lE,GAAAx8D,EAAAg3C,UAAApmD,KAAAipE,cAAAhjE,GAAAjG,KAAAipE,cAAAhjE,EAAA,GACA,MAAA0lE,EAAAC,EAAA3+C,EAAA,GAGA,KAFA0+C,IAAAC,EAOA,GAAA5+B,MAAA,CACA,GAAA6+B,GAAA5+C,EAAA,EAAA0+C,CACA,IAAAv8D,EAAAN,MAAA9O,KAAAipE,cAAAj8B,GAAAvjC,EAAA,IAAA2F,EAAAN,MAAA9O,KAAAipE,cAAAj8B,EAAA,GAAAvjC,EAAA,GACA,OAAAzJ,KAAAipE,cAAAj8B,GAAAvjC,EAAAsF,KAAAqV,IAAApkB,KAAAipE,cAAAj8B,GAAAtjC,EAAA1J,KAAAipE,cAAAj8B,EAAA,GAAAtjC,GAAAmiE,EACiB,IAAAz8D,EAAAN,MAAA9O,KAAAipE,cAAAj8B,GAAAtjC,EAAA,IAAA0F,EAAAN,MAAA9O,KAAAipE,cAAAj8B,EAAA,GAAAtjC,EAAA,GACjB,OAAAqF,KAAAqV,IAAApkB,KAAAipE,cAAAj8B,GAAAvjC,EAAAzJ,KAAAipE,cAAAj8B,EAAA,GAAAvjC,GAAAoiE,EAAA7rE,KAAAipE,cAAAj8B,GAAAtjC,EAEAq8B,SAAA+lC,MAAA,iDAAA9rE,KAAAipE,cAAAj8B,GAAA,IAAAhtC,KAAAipE,cAAAj8B,EAAA,GAAA,iBAAAhtC,KAAAipE,cAAA/iE,aAIS,IAAAlG,KAAA6C,QAAAmE,MAAAF,UAAA7D,EAAAqlE,WAAA,CAKT,IAAA,GAJAj7C,GAAA,GACA5D,EAAAzpB,KAAAomD,YAEA2lB,EAAA,EACAhkE,EAAA,EAA2BA,EAAA/H,KAAAipE,cAAA/iE,OAAA,KAC3B6lE,EAAA38D,EAAA6d,SAAAjtB,KAAAipE,cAAAlhE,GAAA/H,KAAAipE,cAAAlhE,EAAA,IAAA0hB,EAAA4D,GAD8DtlB,IAK9DgkE,GAAA38D,EAAA6d,SAAAjtB,KAAAipE,cAAAlhE,GAAA/H,KAAAipE,cAAAlhE,EAAA,GAGA,IAAAikE,GAAAviD,EAAA4D,EAAA0+C,EACAE,EAAA78D,EAAA6d,SAAAjtB,KAAAipE,cAAAlhE,GAAA/H,KAAAipE,cAAAlhE,EAAA,IAGAmkE,EAAAF,EAAAC,EAEAthB,EAAAuhB,GAAAlsE,KAAAipE,cAAAlhE,EAAA,GAAA0B,EAAAzJ,KAAAipE,cAAAlhE,GAAA0B,GAAAzJ,KAAAipE,cAAAlhE,GAAA0B,EACAmhD,EAAAshB,GAAAlsE,KAAAipE,cAAAlhE,EAAA,GAAA2B,EAAA1J,KAAAipE,cAAAlhE,GAAA2B,GAAA1J,KAAAipE,cAAAlhE,GAAA2B,CAEA,QAAAihD,EAAAC,GAIA,MAAA,OAOA3nD,EAAAI,UAAA+iD,UAAA,WAGA,IAAA,GADAn5B,GAAA,EACAhnB,EAAA,EAAuBA,EAAAjG,KAAAipE,cAAA/iE,OAAA,EAAmCD,IAC1DgnB,GAAA7d,EAAAg3C,UAAApmD,KAAAipE,cAAAhjE,GAAAjG,KAAAipE,cAAAhjE,EAAA,GAEA,OAAAgnB,IAOAhqB,EAAAI,UAAAqjE,OAAA,WAeA,MAbA1mE,MAAAuC,MAAAE,IAAA,aAAAzC,KAAAqmE,YACArmE,KAAAuC,MAAAE,IAAA,kBAAA,IAEAzC,KAAAuC,MAAAE,IAAA,qBAAAzC,KAAAuJ,SAAA,IACAvJ,KAAAuC,MAAAE,IAAA,qBAAAzC,KAAAuJ,SAAA,IACAvJ,KAAAuC,MAAAE,IAAA,sBAAAwH,SAAAjK,KAAAuJ,SAAA,GAAAvJ,KAAA6Q,kBAAAhI,QACA7I,KAAAuC,MAAAE,IAAA,sBAAAwH,SAAAjK,KAAAuJ,SAAA,GAAAvJ,KAAA6Q,kBAAA/H,SACA9I,KAAAuC,MAAAE,IAAA,aAAAzC,KAAA6C,QAAA0G,SAAA89D,UACArnE,KAAAuC,MAAAE,IAAA,aAAAzC,KAAA6C,QAAA0G,SAAA+9D,QACAtnE,KAAAuC,MAAAE,IAAA,iBAAAzC,KAAA6C,QAAAmE,MAAAwD,UACAxK,KAAAuC,MAAAE,IAAA,eAAAzC,KAAA6C,QAAAmE,MAAA4F,QACA5M,KAAAuC,MAAAE,IAAA,cAAAzC,KAAA6C,QAAAikE,OAAA3hE,MACAnF,KAAAuC,MAAAE,IAAA,UAAAzC,KAAAipE,eACAjpE,KAAAuC,MAAAqkE,QAOA3jE,EAAAI,UAAA8oE,aAAA,WACAnsE,KAAAuC,MAAAE,IAAA,UAAAM,EAAAkI,MAAAjL,KAAA6C,UACA7C,KAAAuC,MAAAE,IAAA,kBAAAzC,KAAAipE,cAEA,KAAA,GADAhB,MACAhiE,EAAA,EAAuBA,EAAAjG,KAAAioE,MAAA/hE,OAAuBD,IAAA,CAC9C,GAAAmmE,GAAApsE,KAAAioE,MAAAhiE,GACA2gE,GAAAwF,EAAArgE,KACA03D,KAAA2I,EAAAplE,MAAA2C,MACAd,MAAAujE,EAAAplE,MAAA6B,MACAC,OAAAsjE,EAAAplE,MAAA8B,QAEAm/D,GAAAngE,KAAA8+D,GAEA5mE,KAAAuC,MAAAE,IAAA,QAAAwlE,IAQAhlE,EAAAI,UAAA6lE,YAAA,SAAA1xB,GAKA,IAAA,GAJA60B,GAAArsE,KAAAssE,cAAA90B,GAGA+0B,KACAxkE,EAAAskE,EAAAnmE,OAAAsmE,EAAAxsE,KAAAgoE,WAAA5sB,aAAyErzC,EAAAykE,EAAczkE,IACvFwkE,EAAAzkE,KAAA9H,KAAAgoE,WAAA7sB,QAAApzC,GAEAhF,GAAAwJ,KAAAggE,EAAA,SAAA17B,GACA7wC,KAAAgoE,WAAA9jE,OAAA2sC,IACS7wC,KAET,KAAA,GAAAiG,GAAA,EAAuBA,EAAAomE,EAAAnmE,OAAgBD,IAAA,CACvC,GAAAmjC,GAAAppC,KAAAgoE,WAAA7sB,QAAAl1C,EACA,IAAAmjC,EACAA,EAAAx6B,KAAA,QAAAy9D,EAAApmE,QACa,CACb,GAAAwmE,GAAA,GAAAnqE,GAAAsN,aAEA5I,MAAAhH,KAAA6C,QAAAmE,MACA7C,MAAAkoE,EAAApmE,GACAgD,EAAAjJ,KAAA6C,QAAAoG,GAEAjJ,MAAAgoE,WAAApjE,IAAA6nE,GACAzsE,KAAAgqE,iBAAAyC,MAWAxpE,EAAAI,UAAAipE,cAAA,SAAAI,GAiCA,QAAA9sB,GAAAzwB,EAAAe,GACA,MAAA,IAAAw0B,GAAAv1B,EAAA1lB,EAAAymB,EAAAzmB,EAAA0lB,EAAAzlB,EAAAwmB,EAAAxmB,GASA,QAAAijE,GAAAjsE,EAAAksE,GACA,GAAA,GAAAA,EACA,KAAA,wCAAA5sE,KAAA6sE,MAEA,OAAA,IAAAnoB,GAAAhkD,EAAA+I,EAAAmjE,EAAAlsE,EAAAgJ,EAAAkjE,GAQA,QAAAE,GAAApsE,EAAAksE,GACA,MAAA,IAAAloB,GAAAhkD,EAAA+I,EAAAmjE,EAAAlsE,EAAAgJ,EAAAkjE,GAvDA,GAAAvwD,GAAAqwD,EAAAxmE,OACAmmE,IACA,IAAA,IAAAhwD,EASA,MARAgwD,GAAAvkE,MACAsC,GAAAsiE,EAAA,GAAAjjE,EACAY,GAAAqiE,EAAA,GAAAhjE,EACA02C,KAAAssB,EAAA,GAAAjjE,EACA42C,KAAAqsB,EAAA,GAAAhjE,EACAY,GAAAoiE,EAAA,GAAAjjE,EACAc,GAAAmiE,EAAA,GAAAhjE,IAEA2iE,CACS,IAAA,IAAAhwD,EAWT,MAVAgwD,GAAAvkE,MACAsC,GAAAsiE,EAAA,GAAAjjE,EACAY,GAAAqiE,EAAA,GAAAhjE,EACA02C,KAAAssB,EAAA,GAAAjjE,EACA42C,KAAAqsB,EAAA,GAAAhjE,EACAw2C,KAAAwsB,EAAA,GAAAjjE,EACA02C,KAAAusB,EAAA,GAAAhjE,EACAY,GAAAoiE,EAAA,GAAAjjE,EACAc,GAAAmiE,EAAA,GAAAhjE,IAEA2iE,CA0CA,IAEAtkE,GAFA0tB,GAAA,EAAA,EAAA,EAGA,KAAA1tB,EAAA,EAAmBA,GAAAsU,EAAA,EAAYtU,IAC/B0tB,EAAA3tB,KAAAC,EAGA0tB,GAAA3tB,KAAAuU,EAAA,EAAAA,EAAA,EAIA,KAAA,GAAApW,GAAA,EAAuBA,GAAAoW,EAAA,EAAYpW,IAAA,CAEnC,GAAA8mE,GAAAJ,EAAA/sB,EAAAktB,EAAAJ,EAAAzmE,GAAAwvB,EAAAxvB,EAAA,GAAAwvB,EAAAxvB,EAAA,IAAA6mE,EAAAJ,EAAAzmE,EAAA,GAAAwvB,EAAAxvB,EAAA,GAAAwvB,EAAAxvB,EAAA,KAAAwvB,EAAAxvB,EAAA,GAAAwvB,EAAAxvB,EAAA,IAGA+mE,GAAAv3C,EAAAxvB,EAAA,GAAAwvB,EAAAxvB,EAAA,KAAAwvB,EAAAxvB,EAAA,GAAAwvB,EAAAxvB,EAAA,IACAgnE,EAAAN,EAAA/sB,EAAAktB,EAAAJ,EAAAzmE,EAAA,GAAAwvB,EAAAxvB,EAAA,GAAAwvB,EAAAxvB,EAAA,IAAA6mE,EAAAJ,EAAAzmE,GAAAwvB,EAAAxvB,EAAA,GAAAwvB,EAAAxvB,KAAAwvB,EAAAxvB,EAAA,GAAAwvB,EAAAxvB,IACAinE,EAAAJ,EAAAC,GAAAt3C,EAAAxvB,EAAA,GAAAwvB,EAAAxvB,EAAA,KAAAwvB,EAAAxvB,EAAA,GAAAwvB,EAAAxvB,EAAA,KACAknE,EAAAvtB,EAAAktB,EAAAG,EAAAD,GAAAE,GAGAE,EAAAT,EAAA/sB,EAAAktB,EAAAJ,EAAAzmE,GAAAwvB,EAAAxvB,EAAA,GAAAwvB,EAAAxvB,EAAA,IAAA6mE,EAAAJ,EAAAzmE,EAAA,GAAAwvB,EAAAxvB,EAAA,GAAAwvB,EAAAxvB,EAAA,KAAAwvB,EAAAxvB,EAAA,GAAAwvB,EAAAxvB,EAAA,IAGAonE,GAAA53C,EAAAxvB,EAAA,GAAAwvB,EAAAxvB,EAAA,KAAAwvB,EAAAxvB,EAAA,GAAAwvB,EAAAxvB,EAAA,IACAqnE,EAAAX,EAAA/sB,EAAAktB,EAAAJ,EAAAzmE,EAAA,GAAAwvB,EAAAxvB,EAAA,GAAAwvB,EAAAxvB,EAAA,IAAA6mE,EAAAJ,EAAAzmE,EAAA,GAAAwvB,EAAAxvB,EAAA,GAAAwvB,EAAAxvB,EAAA,KAAAwvB,EAAAxvB,EAAA,GAAAwvB,EAAAxvB,EAAA,IACAsnE,EAAAT,EAAAM,GAAA33C,EAAAxvB,EAAA,GAAAwvB,EAAAxvB,EAAA,KAAAwvB,EAAAxvB,EAAA,GAAAwvB,EAAAxvB,EAAA,KACAunE,EAAA5tB,EAAAktB,EAAAQ,EAAAD,GAAAE,EAIAlB,GAAAvkE,MACAsC,GAAA+iE,EAAA1jE,EACAY,GAAA8iE,EAAAzjE,EACA02C,KAAA2sB,EAAAtjE,EACA42C,KAAA0sB,EAAArjE,EACAw2C,KAAAktB,EAAA3jE,EACA02C,KAAAitB,EAAA1jE,EACAY,GAAAkjE,EAAA/jE,EACAc,GAAAijE,EAAA9jE,IAIA,MAAA2iE,IAIAj9D,EAAA8B,SAAAjO,EAAAugE,GAEA3jE,EAAAD,QAAAqD,GjFssjBM,SAAUpD,EAAQD,EAASM,GkFlllBjC,YAIA,IAAAoC,GAAApC,EAAA,GACA8P,EAAA9P,EAAA,IAKAutE,EAAAnrE,EAAA4N,aACA/K,KAAA,WACAhB,OACA4M,GAAA,EACAC,GAAA,EACAnI,MAAA,EACAC,OAAA,GAEAmV,UAAA,SAAAvN,EAAAvM,GACA,GAAA4M,GAAA5M,EAAA4M,GACAC,EAAA7M,EAAA6M,GACAnI,EAAA1E,EAAA0E,MAAA,EACAC,EAAA3E,EAAA2E,OAAA,CACA4H,GAAAggC,OAAA3/B,EAAAC,EAAAlI,GACA4H,EAAAigC,OAAA5/B,EAAAlI,EAAAmI,EAAAlI,GACA4H,EAAAigC,OAAA5/B,EAAAlI,EAAAmI,EAAAlI,GACA4H,EAAAq5B,eAOA2jC,EAAAprE,EAAA4N,aACA/K,KAAA,UACAhB,OACA4M,GAAA,EACAC,GAAA,EACAnI,MAAA,EACAC,OAAA,GAEAmV,UAAA,SAAAvN,EAAAvM,GACA,GAAA4M,GAAA5M,EAAA4M,GACAC,EAAA7M,EAAA6M,GACAnI,EAAA1E,EAAA0E,MAAA,EACAC,EAAA3E,EAAA2E,OAAA,CACA4H,GAAAggC,OAAA3/B,EAAAC,EAAAlI,GACA4H,EAAAigC,OAAA5/B,EAAAlI,EAAAmI,GACAN,EAAAigC,OAAA5/B,EAAAC,EAAAlI,GACA4H,EAAAigC,OAAA5/B,EAAAlI,EAAAmI,GACAN,EAAAq5B,eAQA4jC,EAAArrE,EAAA4N,aACA/K,KAAA,MACAhB,OAEAsF,EAAA,EACAC,EAAA,EACAb,MAAA,EACAC,OAAA,GAGAmV,UAAA,SAAAvN,EAAAvM,GACA,GAAAsF,GAAAtF,EAAAsF,EACAC,EAAAvF,EAAAuF,EACA+X,EAAAtd,EAAA0E,MAAA,EAAA,EAEAygB,EAAAva,KAAAiD,IAAAyP,EAAAtd,EAAA2E,QACAub,EAAA5C,EAAA,EAGAsG,EAAA1D,EAAAA,GAAAiF,EAAAjF,GACArT,EAAAtH,EAAA4f,EAAAjF,EAAA0D,EACAmwB,EAAAnpC,KAAAkoB,KAAAlP,EAAA1D,GAEAyD,EAAA/Y,KAAAiQ,IAAAk5B,GAAA7zB,EAEAupD,EAAA7+D,KAAAgQ,IAAAm5B,GACA21B,EAAA9+D,KAAAiQ,IAAAk5B,EAEAxnC,GAAA6hC,IACA9oC,EAAAuH,EAAAqT,EACAtV,KAAAoM,GAAA+8B,EACA,EAAAnpC,KAAAoM,GAAA+8B,EAGA,IAAA41B,GAAA,GAAAzpD,EACA0pD,EAAA,GAAA1pD,CACA3T,GAAAwhC,cACAzoC,EAAAqe,EAAA8lD,EAAAE,EAAA98D,EAAA+W,EAAA8lD,EAAAC,EACArkE,EAAAC,EAAAqkE,EACAtkE,EAAAC,GAEAgH,EAAAwhC,cACAzoC,EAAAC,EAAAqkE,EACAtkE,EAAAqe,EAAA8lD,EAAAE,EAAA98D,EAAA+W,EAAA8lD,EAAAC,EACArkE,EAAAqe,EAAA9W,EAAA+W,GAEArX,EAAAq5B,eAQAikC,EAAA1rE,EAAA4N,aAEA/K,KAAA,QAEAhB,OACAsF,EAAA,EACAC,EAAA,EACAb,MAAA,EACAC,OAAA,GAGAmV,UAAA,SAAAE,EAAAha,GACA,GAAA2E,GAAA3E,EAAA2E,OACAD,EAAA1E,EAAA0E,MACAY,EAAAtF,EAAAsF,EACAC,EAAAvF,EAAAuF,EACAoe,EAAAjf,EAAA,EAAA,CACAsV,GAAAuyB,OAAAjnC,EAAAC,GACAyU,EAAAwyB,OAAAlnC,EAAAqe,EAAApe,EAAAZ,GACAqV,EAAAwyB,OAAAlnC,EAAAC,EAAAZ,EAAA,EAAA,GACAqV,EAAAwyB,OAAAlnC,EAAAqe,EAAApe,EAAAZ,GACAqV,EAAAwyB,OAAAlnC,EAAAC,GACAyU,EAAA4rB,eAQAkkC,GACA7kC,KAAA9mC,EAAA6H,KAEAqG,KAAAlO,EAAAsG,KAEAslE,UAAA5rE,EAAAsG,KAEAulE,OAAA7rE,EAAAsG,KAEAwlE,OAAA9rE,EAAAiN,OAEA8+D,QAAAX,EAEAY,IAAAX,EAEAY,MAAAP,EAEAQ,SAAAf,GAGAgB,GAEArlC,KAAA,SAAA3/B,EAAAC,EAAA+X,EAAA6H,EAAAnlB,GAEAA,EAAAiG,GAAAX,EACAtF,EAAAkG,GAAAX,EAAA4f,EAAA,EACAnlB,EAAAmG,GAAAb,EAAAgY,EACAtd,EAAAoG,GAAAb,EAAA4f,EAAA,GAGA9Y,KAAA,SAAA/G,EAAAC,EAAA+X,EAAA6H,EAAAnlB,GACAA,EAAAsF,EAAAA,EACAtF,EAAAuF,EAAAA,EACAvF,EAAA0E,MAAA4Y,EACAtd,EAAA2E,OAAAwgB,GAGA4kD,UAAA,SAAAzkE,EAAAC,EAAA+X,EAAA6H,EAAAnlB,GACAA,EAAAsF,EAAAA,EACAtF,EAAAuF,EAAAA,EACAvF,EAAA0E,MAAA4Y,EACAtd,EAAA2E,OAAAwgB,EACAnlB,EAAAkgB,EAAAtV,KAAAqV,IAAA3C,EAAA6H,GAAA,GAGA6kD,OAAA,SAAA1kE,EAAAC,EAAA+X,EAAA6H,EAAAnlB,GACA,GAAA4iE,GAAAh4D,KAAAqV,IAAA3C,EAAA6H,EACAnlB,GAAAsF,EAAAA,EACAtF,EAAAuF,EAAAA,EACAvF,EAAA0E,MAAAk+D;AACA5iE,EAAA2E,OAAAi+D,GAGAqH,OAAA,SAAA3kE,EAAAC,EAAA+X,EAAA6H,EAAAnlB,GAEAA,EAAA4M,GAAAtH,EAAAgY,EAAA,EACAtd,EAAA6M,GAAAtH,EAAA4f,EAAA,EACAnlB,EAAAkgB,EAAAtV,KAAAqV,IAAA3C,EAAA6H,GAAA,GAGA+kD,QAAA,SAAA5kE,EAAAC,EAAA+X,EAAA6H,EAAAnlB,GACAA,EAAA4M,GAAAtH,EAAAgY,EAAA,EACAtd,EAAA6M,GAAAtH,EAAA4f,EAAA,EACAnlB,EAAA0E,MAAA4Y,EACAtd,EAAA2E,OAAAwgB,GAGAglD,IAAA,SAAA7kE,EAAAC,EAAA+X,EAAA6H,EAAAnlB,GACAA,EAAAsF,EAAAA,EAAAgY,EAAA,EACAtd,EAAAuF,EAAAA,EAAA4f,EAAA,EACAnlB,EAAA0E,MAAA4Y,EACAtd,EAAA2E,OAAAwgB,GAGAilD,MAAA,SAAA9kE,EAAAC,EAAA+X,EAAA6H,EAAAnlB,GACAA,EAAAsF,EAAAA,EAAAgY,EAAA,EACAtd,EAAAuF,EAAAA,EAAA4f,EAAA,EACAnlB,EAAA0E,MAAA4Y,EACAtd,EAAA2E,OAAAwgB,GAGAklD,SAAA,SAAA/kE,EAAAC,EAAA+X,EAAA6H,EAAAnlB,GACAA,EAAA4M,GAAAtH,EAAAgY,EAAA,EACAtd,EAAA6M,GAAAtH,EAAA4f,EAAA,EACAnlB,EAAA0E,MAAA4Y,EACAtd,EAAA2E,OAAAwgB,IAIAolD,IACA,KAAA,GAAAhnE,KAAAumE,GACAS,EAAAhnE,GAAA,GAAAumE,GAAAvmE,EAGA,IAAAinE,GAAArsE,EAAA4N,aAEA/K,KAAA,SAEAhB,OACAknE,WAAA,GACA5hE,EAAA,EACAC,EAAA,EACAb,MAAA,EACAC,OAAA,GAGA4a,YAAA,WACA,GAAA1c,GAAAhH,KAAAgH,MACA7C,EAAAnE,KAAAmE,KAEA,SAAAA,EAAAknE,YAAA,WAAArkE,EAAAiM,eACAjM,EAAAiM,cAAA,MAAA,OACAjM,EAAAwe,UAAA,SACAxe,EAAAye,kBAAA,WAIAxH,UAAA,SAAAE,EAAAha,GACA,GAAAknE,GAAAlnE,EAAAknE,WACAuD,EAAAF,EAAArD,EACA,UAAAlnE,EAAAknE,aACAuD,IAEAvD,EAAA,OACAuD,EAAAF,EAAArD,IAEAoD,EAAApD,GACAlnE,EAAAsF,EAAAtF,EAAAuF,EAAAvF,EAAA0E,MAAA1E,EAAA2E,OAAA8lE,EAAAzqE,OAEAyqE,EAAA3wD,UAAAE,EAAAywD,EAAAzqE,WAMA0qE,EAAA,SAAAr8D,GACA,GAAA,UAAAxS,KAAAmF,KAAA,CACA,GAAA2pE,GAAA9uE,KAAAgH,MACA+nE,EAAA/uE,KAAAmE,KACA4qE,IAAA,SAAAA,EAAA1D,WACAyD,EAAAliE,OAAA4F,EAEAxS,KAAAgvE,gBACAF,EAAAliE,OAAA4F,EACAs8D,EAAA/lE,KAAA,SAIA+lE,EAAA/lE,OAAA+lE,EAAA/lE,KAAAyJ,GACAs8D,EAAAliE,SAAAkiE,EAAAliE,OAAA4F,IAEAxS,KAAAse,UAIAolD,GAWAiC,aAAA,SAAA0F,EAAA5hE,EAAAC,EAAA+X,EAAA6H,EAAArgB,EAAAuJ,GACA,GAAAu1C,GAAA,IAAAsjB,EAAA14D,QAAA,QACAo1C,KACAsjB,EAAAA,EAAA9iE,OAAA,EAAA,GAAAowB,cAAA0yC,EAAA9iE,OAAA,GAEA,IAAAijE,EAoCA,OAjCAA,GADA,IAAAH,EAAA14D,QAAA,YACA,GAAArQ,GAAAgH,OACAtC,OACA2C,MAAA0hE,EAAA/yD,MAAA,GACA7O,EAAAA,EACAC,EAAAA,EACAb,MAAA4Y,EACA3Y,OAAAwgB,GAEArgB,EAAAA,IAGA,IAAAoiE,EAAA14D,QAAA,WACArQ,EAAAiO,SAAA86D,EAAA/yD,MAAA,IAAoErP,EAAAA,EAAAua,WAAA,GAAsB,GAAAxT,GAAAvG,EAAAC,EAAA+X,EAAA6H,IAG1F,GAAAqlD,IACAxqE,OACAknE,WAAAA,EACA5hE,EAAAA,EACAC,EAAAA,EACAb,MAAA4Y,EACA3Y,OAAAwgB,GAEArgB,EAAAA,IAIAuiE,EAAAwD,eAAAjnB,EAEAyjB,EAAAyD,SAAAJ,EAEArD,EAAAyD,SAAAz8D,GAEAg5D,GAIA3rE,GAAAD,QAAA8jE,GlF0llBM,SAAU7jE,EAAQD,EAASM,GmFp7lBjC,QAAAgoE,GAAA/iE,EAAAsE,EAAAC,EAAApF,GACAtE,KAAAmF,KAAAA,EAEAnF,KAAAyJ,EAAAA,EAEAzJ,KAAA0J,EAAAA,EAEA1J,KAAAkvE,SAAA,EAEAlvE,KAAAsE,UAAAA,EAEAtE,KAAAkrE,YAAA,GAAA5oE,GAAAiN,QACApL,OACA4M,GAAAtH,EACAuH,GAAAtH,EACA2a,EAAA6jD,EAAAM,QAGAxhE,OACA+B,KAAA,eACA6D,OAAA,cAEA3D,EAAA3E,EAAAzB,QAAAoG,EAAA,EACAwB,WAAA,GAGA,IAAAxG,GAAAjE,IACAA,MAAAkrE,YAAApmE,GAAA,OAAA,SAAAd,GACAC,EAAAkrE,gBAAAnrE,EAAAu2C,QAAAv2C,EAAAy2C,WA9BA,GAAAn4C,GAAApC,EAAA,GACAkP,EAAAlP,EAAA,GAkCAgoE,GAAAM,OAAA,EAEAN,EAAA7kE,WAEA0R,YAAAmzD,EAEAte,OAAA,SAAAwlB,GACA,SAAAA,YAAAlH,MAIAloE,KAAAmF,MAAAiqE,EAAAjqE,MACAnF,KAAAyJ,GAAA2lE,EAAA3lE,GACAzJ,KAAA0J,GAAA0lE,EAAA1lE,GACA1J,KAAAkvE,SAAAE,EAAAF,UASAC,gBAAA,SAAAE,EAAAC,GACA,OAAAtvE,KAAAmF,MACA,IAAA,IAGA,IAAA,GAFA6nC,GAEA/mC,EAAA,EAAkCA,EAAAjG,KAAAsE,UAAA2kE,cAAA/iE,OAAA,EAA2CD,IAC7EjG,KAAAsE,UAAA2kE,cAAAhjE,EAAA,GAAAyD,GAAA1J,KAAAsE,UAAA2kE,cAAAhjE,GAAAyD,GACA1J,KAAAsE,UAAA2kE,cAAAhjE,GAAAyD,GAAA1J,KAAA0J,GACAqF,KAAAqV,IAAApkB,KAAAsE,UAAA2kE,cAAAhjE,GAAAwD,EAAAzJ,KAAAsE,UAAA2kE,cAAAhjE,EAAA,GAAAwD,IAAAzJ,KAAAyJ,GACAsF,KAAAiD,IAAAhS,KAAAsE,UAAA2kE,cAAAhjE,GAAAwD,EAAAzJ,KAAAsE,UAAA2kE,cAAAhjE,EAAA,GAAAwD,IAAAzJ,KAAAyJ,IAEAujC,EAAA/mC,EAGA,IAAAspE,GAAAD,EAAAtvE,KAAA0J,EACA67C,EAAAn2C,EAAAm2C,kBAAA,EAAAgqB,EAEAvvE,MAAAsE,UAAA2kE,cAAAj8B,EAAA,GAAAl5B,UAAAyxC,GACAvlD,KAAAsE,UAAA2kE,cAAAj8B,GAAAl5B,UAAAyxC,GACAvlD,KAAAsE,UAAA6d,UACAniB,KAAA0J,EAAA4lE,CAEA,MAEA,KAAA,IAGA,IAAA,GAFAtiC,GAEA/mC,EAAA,EAAkCA,EAAAjG,KAAAsE,UAAA2kE,cAAA/iE,OAAA,EAA2CD,IAC7EjG,KAAAsE,UAAA2kE,cAAAhjE,EAAA,GAAAwD,GAAAzJ,KAAAsE,UAAA2kE,cAAAhjE,GAAAwD,GACAzJ,KAAAsE,UAAA2kE,cAAAhjE,GAAAwD,GAAAzJ,KAAAyJ,GACAsF,KAAAqV,IAAApkB,KAAAsE,UAAA2kE,cAAAhjE,GAAAyD,EAAA1J,KAAAsE,UAAA2kE,cAAAhjE,EAAA,GAAAyD,IAAA1J,KAAA0J,GACAqF,KAAAiD,IAAAhS,KAAAsE,UAAA2kE,cAAAhjE,GAAAyD,EAAA1J,KAAAsE,UAAA2kE,cAAAhjE,EAAA,GAAAyD,IAAA1J,KAAA0J,IAEAsjC,EAAA/mC,EAGA,IAAAupE,GAAAH,EAAArvE,KAAAyJ,EACA87C,EAAAn2C,EAAAm2C,kBAAAiqB,EAAA,EACAxvE,MAAAsE,UAAA2kE,cAAAj8B,EAAA,GAAAl5B,UAAAyxC,GACAvlD,KAAAsE,UAAA2kE,cAAAj8B,GAAAl5B,UAAAyxC,GACAvlD,KAAAsE,UAAA6d,UACAniB,KAAAyJ,EAAA4lE,KAOAxvE,EAAAD,QAAAsoE,GnFq8lBM,SAAUroE,EAAQD,EAASM,GoF1imBjC,QAAAioE,GAAArB,EAAAjkE,EAAAmlE,EAAA+B,GACA/pE,KAAAyvE,WAAA,EACAzvE,KAAA0vE,kBAAA,EACA1vE,KAAA8mE,OAAAA,EACA9mE,KAAAgoE,WAAAA,EACAhoE,KAAA2vE,WAAA9sE,EAAAknE,GAVA,GACA37B,IADAluC,EAAA,GACAA,EAAA,KACA0vE,EAAA1vE,EAAA,IAUA2vE,GATA3vE,EAAA,IASAioE,EAAA9kE,UAEAwsE,GAAAF,WAAA,SAAA9sE,EAAAknE,GACA,GAAA9lE,GAAAjE,IACAA,MAAA8mE,OAAAx5D,GAAA,IACAtN,KAAA8mE,OAAAvjD,SAAA,CACA,IAAAusD,GAAA,IAAAjtE,EAAA2nE,OAAAsF,MAGA,IAFA9vE,KAAA8mE,OAAAiJ,IAAA,EACA/vE,KAAA8mE,OAAA74C,gBACA,SAAAprB,EAAAmE,MAAAF,UACA,GAAA9G,KAAAgoE,WAAA,CACA,GAAA/hE,GAAA,CACA6pE,IAAA9vE,KAAAgoE,WAAAjtB,UAAA70C,OACAlG,KAAAgwE,kBAAAhwE,KAAAgoE,WAAAjtB,UAAA,GAAA90C,EAAA6pE,QAIA9vE,MAAA8mE,OAAAvkD,QAAA,IAAA,GACAuM,KAAAghD,GACAC,IAAA,IAEA1hD,MAAA,GACAN,OAAA,WACA9pB,EAAAgsE,iCAEAthD,QACA3uB,KAAAkwE,2BAAAnG,EAAA5lE,MAAAqzC,SAKAq4B,EAAAG,kBAAA,SAAAlG,EAAA7jE,EAAA6pE,GACA,GAAA7rE,GAAAjE,IACAy/D,SAAAqK,IACAA,EAAA9pE,KAAAgoE,WAAAjtB,UAAA,GACA90C,EAAA,EAEA,IAAAuxC,GACAsH,EAAAgrB,EAAA3lE,KACAqzC,KACAsH,EAAA10C,GAAA00C,EAAAz0C,KACAy0C,EAAAx0C,GAAAw0C,EAAAv0C,KACAu0C,EAAAsB,KAAAtB,EAAAuB,OACAvB,EAAAoB,KAAApB,EAAAqB,OAEAngD,KAAAmwE,8BAAA34B,GACAx3C,KAAA8mE,OAAAvkD,QAAA,IACAuM,KAAAghD,GACAC,IAAA,IAEA1hD,MAAA,GACAN,OAAA,WACA9pB,EAAAmsE,oCAEApiD,KAAA,WACA/pB,EAAA6iE,OAAAiJ,IAAA,EACA9rE,EAAA+rE,kBAAA/rE,EAAA+jE,WAAAjtB,UAAA90C,EAAA,GAAAA,EAAA,EAAA6pE,KAEAnhD,SAKAkhD,EAAAM,8BAAA,SAAA34B,GACAx3C,KAAA8mE,OAAAuJ,KAAA74B,EAAA,GACAx3C,KAAA8mE,OAAAwJ,KAAA94B,EAAA,GACAx3C,KAAA8mE,OAAAyJ,MAAA/4B,EAAA,MACAA,EAAA,GAAA,GAAAA,EAAA,GAAA,IAAA,GACAA,EAAA,GAAA,GAAAA,EAAA,GAAA,IAAA,GAEAx3C,KAAA8mE,OAAA0J,MAAAh5B,EAAA,IAGAq4B,EAAAO,gCAAA,WACA,GAMAz4B,GAAAC,EANAzoB,EAAAnvB,KAAA8mE,OAAAuJ,KACAngD,EAAAlwB,KAAA8mE,OAAAwJ,KACA/xB,EAAAv+C,KAAA8mE,OAAAyJ,MACA/xB,EAAAx+C,KAAA8mE,OAAA0J,MACAnjD,EAAArtB,KAAA8mE,OAAAiJ,IACAjxB,EAAA9+C,KAAA8mE,OAAAv9D,QAEA,IAAAk2D,QAAAjhB,EAAA,GAAA,CACA,GAAA/K,GAAAm8B,EAAAn8B,QACAkB,EAAAi7B,EAAAj7B,iBACAmK,GAAA,GAAArL,EAAAtkB,EAAA,GAAAovB,EAAA,GAAAC,EAAA,GAAAtuB,EAAA,GAAA7C,GACAyxB,EAAA,GAAArL,EAAAtkB,EAAA,GAAAovB,EAAA,GAAAC,EAAA,GAAAtuB,EAAA,GAAA7C,GAEAsqB,EAAAhD,EAAAxlB,EAAA,GAAAovB,EAAA,GAAAC,EAAA,GAAAtuB,EAAA,GAAA7C,GACAuqB,EAAAjD,EAAAxlB,EAAA,GAAAovB,EAAA,GAAAC,EAAA,GAAAtuB,EAAA,GAAA7C,OACS,CACT,GAAAypB,GAAA84B,EAAA94B,YACAC,EAAA64B,EAAA74B,qBACA+H,GAAA,GAAAhI,EAAA3nB,EAAA,GAAAovB,EAAA,GAAAruB,EAAA,GAAA7C,GACAyxB,EAAA,GAAAhI,EAAA3nB,EAAA,GAAAovB,EAAA,GAAAruB,EAAA,GAAA7C,GAEAsqB,EAAAZ,EAAA5nB,EAAA,GAAAovB,EAAA,GAAAruB,EAAA,GAAA7C,GACAuqB,EAAAb,EAAA5nB,EAAA,GAAAovB,EAAA,GAAAruB,EAAA,GAAA7C,GAEArtB,KAAA8mE,OAAA/8C,UAAAhb,KAAA2b,MAAAktB,EAAAD,GAAA5oC,KAAAoM,GAAA,EAEAnb,KAAA8mE,OAAAn/C,QAAA,GAGAkoD,EAAAK,2BAAA,SAAA14B,GACAx3C,KAAAywE,QAAAj5B,CAGA,KAAA,GAFAk5B,IAAA,GACA97D,EAAA,EACA3O,EAAA,EAAuBA,EAAAuxC,EAAAtxC,OAAmBD,IAAA,CAC1C,GAAAkpB,GAAAqoB,EAAAvxC,EAAA,GACAiqB,EAAAsnB,EAAAvxC,EACA2O,IAAAw5B,EAAA7gB,KAAA4B,EAAAe,GACAwgD,EAAA5oE,KAAA8M,GAEA,GAAA,IAAAA,EAAA,CAIA,IAAA,GAAA7M,GAAA,EAAuBA,EAAA2oE,EAAAxqE,OAAsB6B,IAC7C2oE,EAAA3oE,IAAA6M,CAEA5U,MAAA2wE,SAAAD,EACA1wE,KAAA4wE,QAAAh8D,EACA5U,KAAA8mE,OAAA2I,WAAA,EACAzvE,KAAA8mE,OAAA+J,mBAAA,IAGAhB,EAAAI,6BAAA,WACA,GAAA5iD,GAAArtB,KAAA8mE,OAAAiJ,IACAv4B,EAAAx3C,KAAAywE,QACAK,EAAA9wE,KAAA2wE,SACA/7D,EAAA4iC,EAAAtxC,MAEA,IAAA4qE,EAAA,CAKA,GACAp+C,GADAH,EAAAvyB,KAAAyvE,UAGA,IAAApiD,EAAArtB,KAAA0vE,kBAAA,CAGA,GAAA/gD,GAAA5f,KAAAqV,IAAAmO,EAAA,EAAA3d,EAAA,EACA,KAAA8d,EAAA/D,EAA+B+D,GAAA,KAC/Bo+C,EAAAp+C,IAAArF,GAD2CqF,KAM3CA,EAAA3jB,KAAAqV,IAAAsO,EAAA9d,EAAA,OACS,CACT,IAAA,GAAA8d,GAAAH,EAAuCG,EAAA9d,KACvCk8D,EAAAp+C,GAAArF,GADoDqF,KAKpDA,EAAA3jB,KAAAqV,IAAAsO,EAAA,EAAA9d,EAAA,GAEAw5B,EAAAhhB,KACAptB,KAAA8mE,OAAAv9D,SAAAiuC,EAAA9kB,GAAA8kB,EAAA9kB,EAAA,IACArF,EAAAyjD,EAAAp+C,KAAAo+C,EAAAp+C,EAAA,GAAAo+C,EAAAp+C,KAGA1yB,KAAAyvE,WAAA/8C,EACA1yB,KAAA0vE,kBAAAriD,CACA,IAAA6qB,IAAAnpC,KAAA2b,MAAA8sB,EAAA9kB,EAAA,GAAA,GAAA8kB,EAAA9kB,GAAA,GAAA8kB,EAAA9kB,EAAA,GAAA,GAAA8kB,EAAA9kB,GAAA,GACA1yB,MAAA8mE,OAAA/8C,SAAAmuB,EAAAnpC,KAAAoM,GAAA,EACAnb,KAAA8mE,OAAAn/C,QAAA,IAEA9nB,EAAAD,QAAAuoE,GpF4jmBM,SAAUtoE,EAAQD,EAASM,GqFjvmBjC,QAAAkoE,GAAA9jE,EAAAi7C,EAAAp6C,EAAAtC,GACA7C,KAAAsE,UAAAA,EAEAtE,KAAAu/C,MAAAA,EAAAt0C,QAEAjL,KAAAmF,KAAAA,EAEAnF,KAAAwS,MAAA41D,EAAApB,aAEAhnE,KAAAgqD,MAAA,kBAEAhqD,KAAAmE,MAAA,GAAA7B,GAAAiN,QACApL,OACA4M,GAAA/Q,KAAAu/C,MAAA91C,EACAuH,GAAAhR,KAAAu/C,MAAA71C,EACA2a,EAAA+jD,EAAAI,QAGAxhE,OACA+B,KAAA/I,KAAAwS,MACA5F,OAAA,WAEA3D,EAAApG,EAAAoG,EAAA,IAEAjJ,KAAAmE,MAAAgB,KAAAnF,KAAAmF,KAEAnF,KAAAmE,MAAAG,UAAAA,EA3BA,GAAAhC,GAAApC,EAAA,EA+BAkoE,GAAApB,aAAA,UAEAoB,EAAA2I,WAAA,UAEA3I,EAAA4I,gBAAA,UAEA5I,EAAAI,OAAA,EAEAJ,EAAA6I,YAAA,SAEA7I,EAAA2C,eAAA,YAEA3C,EAAA/kE,WAEA0R,YAAAqzD,EAEAxe,OAAA,SAAAsnB,GACA,MAAAlxE,MAAAu/C,MAAAqK,OAAAsnB,EAAA3xB,QACAv/C,KAAAsE,WAAA4sE,EAAA5sE,WACAtE,KAAAmF,MAAA+rE,EAAA/rE,MACAnF,KAAAwS,OAAA0+D,EAAA1+D,OACAxS,KAAA4yC,QAAAs+B,EAAAt+B,SAKA/yC,EAAAD,QAAAwoE,GrFiwmBM,SAAUvoE,EAAQD,EAASM,GsFrzmBjC,QAAAsC,GAAAokE,EAAAuK,EAAAC,GACApxE,KAAAmxE,YAAAA,EACAnxE,KAAA4mE,OAAAA,EAGA5mE,KAAAgC,OACAuV,UAAArR,QAAA,EACAlG,KAAAgC,KAAA4kE,EAAAuK,EAAAC,GAGApxE,KAAAgC,KAAAwV,MAAAxX,KAAAuX,YAbA,GAAAxU,GAAA7C,EAAA,GACAmxE,EAAAnxE,EAAA,GAiBAsC,GAAAa,WAEA0R,YAAAvS,EAOAR,KAAA,SAAA4kE,GACA7jE,EAAAoS,MAAAyxD,EAAA5mE,KAAAsxE,qBAGAA,iBAAA,WACA,IAAAtxE,KAAAmN,eAAA,mBAAA,CAGA,IAFA,GAAAokE,MACArpB,EAAAloD,KAAA+U,YACAmzC,GAAA,CACA,GAAAye,GAAAze,EAAA7kD,UAAAmuE,aACA7K,IAAA4K,EAAAzpE,KAAA6+D,GACAze,EAAAA,EAAA5xC,WAIA,IAAA,GADAk7D,MACAvrE,EAAAsrE,EAAArrE,OAAA,EAAgDD,GAAA,EAAQA,IACxDurE,EAAAzuE,EAAAoS,MAAAq8D,EAAAD,EAAAtrE,IAAA,EAEAjG,MAAAyxE,gBAAAD,EAEA,MAAAxxE,MAAAyxE,iBAMAC,YAAA,SAAA9K,GACA7jE,EAAAoS,MAAAnV,KAAA4mE,OAAAA,GAAA,IAaA/gE,IAAA,SAAA6K,EAAAihE,GACA,IAAAjhE,EACA,MAAA1Q,MAAA4mE,MAGA,iBAAAl2D,KACAA,EAAAA,EAAAiM,MAAA,KAKA,KAAA,GAFAlG,GAAAzW,KAAA4mE,OACAuK,EAAAnxE,KAAAmxE,YACAlrE,EAAA,EAA2BA,EAAAyK,EAAAxK,SAE3BuQ,EAAAA,GAAA,gBAAAA,GAAAA,EAAA/F,EAAAzK,IAAA,KACA,MAAAwQ,GAH4CxQ,KAU5C,MAHA,OAAAwQ,GAAA06D,IAAAQ,IACAl7D,EAAA06D,EAAAtrE,IAAA6K,IAEA+F,GAcAhU,IAAA,SAAAiO,EAAAsF,GACA,GAAAS,GAAAzW,KAAA4mE,MAEA,IAAAl2D,EAAAiC,QAAA,SACA8D,EAAA/F,GAAAsF,MACa,CAMb,IAAA,GAFA47D,GAHAC,EAAAnhE,EAAAiM,MAAA,KACAN,EAAAw1D,EAAA3rE,OACA4rE,EAAAr7D,EAGAxQ,EAAA,EAA+BA,EAAAoW,EAAA,EAAWpW,IAC1C2rE,EAAAC,EAAA5rE,GACA,MAAA6rE,EAAAF,KACAE,EAAAF,OAEAE,EAAAA,EAAAF,EAEAA,GAAAC,EAAAx1D,EAAA,GACAy1D,EAAAF,GAAA57D,IAOAvH,WAAA,SAAA1C,EAAA4lE,GACA,GAAA/K,GAAA5mE,KAAA4mE,OACAnuD,EAAAmuD,GAAAA,EAAA76D,GACAolE,EAAAnxE,KAAAmxE,WAIA,OAHA,OAAA14D,GAAA04D,IAAAQ,IACAl5D,EAAA04D,EAAA1iE,WAAA1C,IAEA0M,GAMA5F,SAAA,SAAAnC,EAAAygE,GACA,GAAA16D,GAAAzW,KAAA6F,IAAA6K,GAAA,GACAqhE,EAAA/xE,KAAAmxE,YACA5uE,EAAA,GAAAC,GACAiU,EAAA06D,GAAAY,GAAAA,EAAAl/D,SAAAnC,GAEA,OAAAnO,IAOAwlD,QAAA,WACA,MAAA,OAAA/nD,KAAA4mE,QAGAoL,YAAA,aAKA/mE,MAAA,WACA,GAAA6J,GAAA9U,KAAA+U,WACA,OAAA,IAAAD,GAAA/R,EAAAkI,MAAAjL,KAAA4mE,WAKAyK,EAAAY,kBAAAzvE,GAEA3C,EAAAD,QAAA4C,GtFu0mBM,SAAU3C,EAAQD,EAASM,GuF18mBjC,QAAAgyE,GAAAhqE,EAAAiqE,GACA,GAAA96D,GAAAtU,EAAAuV,MAAAf,UAAA,EACA,OAAAvX,MAAAsW,WAAAjT,UAAA8uE,GAAA36D,MAAAtP,EAAAmP,GAGA,QAAA+6D,GAAAlqE,EAAAiqE,EAAA96D,GACA,MAAArX,MAAAsW,WAAAjT,UAAA8uE,GAAA36D,MAAAtP,EAAAmP,GApDA,GAAAtU,GAAA7C,EAAA,GAEA+V,KAEAo8D,EAAA,IACAC,EAAA,iCAIAC,EAAAt8D,EAAAs8D,eAAA,SAAAC,GACA,GAAA/hD,IAAmBgiD,KAAA,GAAA/lD,IAAA,GAMnB,OALA8lD,KACAA,EAAAA,EAAA71D,MAAA01D,GACA5hD,EAAAgiD,KAAAD,EAAA,IAAA,GACA/hD,EAAA/D,IAAA8lD,EAAA,IAAA,IAEA/hD,EAKAxa,GAAAg8D,kBAAA,SAAAS,EAAAC,GACAD,EAAAviE,OAAA,SAAA+4C,GACA,GAAA0pB,GAAA,WACAD,GAAAA,EAAAn7D,MAAAxX,KAAAuX,WACAm7D,EAAAl7D,MAAAxX,KAAAuX,WAWA,OARAxU,GAAAoN,OAAAyiE,EAAAvvE,UAAA6lD,GAEA0pB,EAAAziE,OAAAnQ,KAAAmQ,OACAyiE,EAAAV,UAAAA,EACAU,EAAAR,WAAAA,EACArvE,EAAAmO,SAAA0hE,EAAA5yE,MACA4yE,EAAAt8D,WAAAtW,KAEA4yE,IAyBA38D,EAAA48D,sBAAA,SAAAC,EAAAjwE,GAgGA,QAAAkwE,GAAAP,GACA,GAAAQ,GAAAx3B,EAAAg3B,EAAAC,KAKA,OAJAO,IAAAA,EAAAV,KACAU,EAAAx3B,EAAAg3B,EAAAC,SACAO,EAAAV,IAAA,GAEAU,EArGAnwE,EAAAA,KAUA,IAAA24C,KA8FA,IA5FAs3B,EAAAG,cAAA,SAAAC,EAAAV,GACA,GAAAA,EAGA,GAFAA,EAAAD,EAAAC,GAEAA,EAAA9lD,KAOA,GAAA8lD,EAAA9lD,MAAA4lD,EAAA,CACA,GAAAU,GAAAD,EAAAP,EACAQ,GAAAR,EAAA9lD,KAAAwmD,OATA,CACA,GAAA13B,EAAAg3B,EAAAC,MAEA,MAEAj3B,GAAAg3B,EAAAC,MAAAS,EAOA,MAAAA,IAGAJ,EAAAK,SAAA,SAAAC,EAAAC,EAAAC,GACA,GAAAJ,GAAA13B,EAAA43B,EAMA,IAJAF,GAAAA,EAAAZ,KACAY,EAAAG,EAAAH,EAAAG,GAAA,MAGAC,IAAAJ,EACA,KAAA,IAAAvnE,OACA,aAAAynE,EAAA,KAAAC,GAAA,IAAA,8BAIA,OAAAH,IAGAJ,EAAAS,qBAAA,SAAAf,GACAA,EAAAD,EAAAC,EAEA,IAAA/9D,MACAgC,EAAA+kC,EAAAg3B,EAAAC,KAWA,OATAh8D,IAAAA,EAAA67D,GACAvvE,EAAAwJ,KAAAkK,EAAA,SAAA8yC,EAAApkD,GACAA,IAAAmtE,GAAA79D,EAAA3M,KAAAyhD,KAIA90C,EAAA3M,KAAA2O,GAGAhC,GAGAq+D,EAAAU,SAAA,SAAAhB,GAGA,MADAA,GAAAD,EAAAC,KACAh3B,EAAAg3B,EAAAC,OAMAK,EAAAW,qBAAA,WACA,GAAAC,KAIA,OAHA3wE,GAAAwJ,KAAAivC,EAAA,SAAA/kC,EAAAtR,GACAuuE,EAAA5rE,KAAA3C,KAEAuuE,GAQAZ,EAAAa,YAAA,SAAAnB,GACAA,EAAAD,EAAAC,EACA,IAAA/7D,GAAA+kC,EAAAg3B,EAAAC,KACA,OAAAh8D,IAAAA,EAAA67D,IAGAQ,EAAAP,eAAAA,EAWA1vE,EAAA+wE,mBAAA,CACA,GAAAC,GAAAf,EAAA3iE,MACA0jE,KACAf,EAAA3iE,OAAA,SAAA+4C,GACA,GAAA0pB,GAAAiB,EAAAtzE,KAAAP,KAAAkpD,EACA,OAAA4pB,GAAAG,cAAAL,EAAA1pB,EAAA/jD,QAKA,MAAA2tE,IAGAjzE,EAAAD,QAAAqW,GvFkgnBM,SAAUpW,EAAQD,GwFjrnBxB,GAAAk0E,IACA1P,aAAA,srCACAE,WAAA,o0BACAE,UAAA,mrCACAC,QAAA,i9BACAC,YAAA,+tDACAqP,qBAAA,kzBAEAl0E,GAAAD,QAAAk0E,GxF8rnBM,SAAUj0E,EAAQD,EAASM,GyF7rnBjC,QAAAuB,KACAuyE,EAAAzzE,KAAAP,MACAA,KAAAi0E,kBACAj0E,KAAAk0E,aAAA,GACAl0E,KAAAm0E,UAAA,GACAn0E,KAAAsG,aAAA8I,EAAA+4C,WAAAC,YAfA,GAAArlD,GAAA7C,EAAA,GACA8zE,EAAA9zE,EAAA,IACA+C,EAAA/C,EAAA,IACAkP,EAAAlP,EAAA,IAEAwkD,GADAxkD,EAAA,GACAA,EAAA,KACAwC,EAAAxC,EAAA,IACAsC,EAAAtC,EAAA,GACAA,GAAA,GAgBAuB,GAAA4B,UAAA0H,wBAAA,SAAAlI,EAAAygE,GACA,GAAAr/D,GAAAjE,KACAuC,EAAAM,EAAAN,MAEA+B,EAAA,GAAArB,GAAAJ,EAKA,IAJAA,EAAAuxE,aAAAvxE,EAAAwxE,YACA/vE,EAAA8vE,YAAAvxE,EAAAuxE,YACA9vE,EAAA+vE,UAAAxxE,EAAAwxE,WAEAxxE,EAAAi8C,IAAA,CACA,GAAAA,GAAAj8C,EAAAi8C,IAAAniC,MAAA,IACArY,GAAAgwE,KAAAx1B,EAAA,GACAx6C,EAAAiwE,KAAAz1B,EAAA,GAEA9+C,KAAA6E,WAAAiD,KAAAxD,GAEAA,EAAAyjE,gBACAzjE,EAAAyjE,eAAAjjE,GAAA,QAAA,SAAAd,GACA,GAAAwwE,GAAAxwE,EAAAI,OAAAe,KAAAwX,MAAA1Z,EAAA8lE,WACAzkE,EAAAN,EAAAI,OAAAE,SACAkwE,GAAA,KAAAvxE,EAAAwlE,WACAnkE,EAAAgwE,KAAAE,EAAA,GACiBA,EAAA,KAAAvxE,EAAAylE,WACjBpkE,EAAAiwE,KAAAC,EAAA,IAEAvwE,EAAAwwE,iBAAAnwE,GAAA,GACAN,EAAA2pD,cAAA,CACA,IAAA1oD,KACAA,GAAAC,MAAAlB,EACAiB,EAAAE,KAAA,uBACAF,EAAAM,SAAAtB,EAAAywE,aACApR,EAAAl+D,QAAAH,EAAAE,KAAAF,IAKA,IAAAwgE,IAAA,QAAA,WACA1iE,GAAAwJ,KAAAk5D,EAAA,SAAAC,GACAphE,EAAAQ,GAAA,aAAA4gE,EAAA,SAAA1hE,GAEA,GAAA2wE,GAAA3wE,EAAAI,MAEAH,GAAAywE,eAAAC,IACA1wE,EAAAywE,cAAAzwE,EAAAwwE,iBAAAxwE,EAAAywE,cACAzwE,EAAAywE,aAAAC,GAEA3wE,EAAA2pD,cAAA,CACA,IAAA1oD,KACAA,GAAAC,MAAAlB,EACAiB,EAAAE,KAAAugE,EACAzgE,EAAAb,OAAAH,EAAAywE,aACApR,EAAAl+D,QAAAH,EAAAE,KAAAF,OAIAjF,KAAAk0E,aAAArxE,EAAAqxE,cAAAl0E,KAAAk0E,aACAl0E,KAAAm0E,UAAAtxE,EAAAsxE,WAAAn0E,KAAAm0E,SACA,IAAAS,GAAA/xE,EAAA+xE,OACA,IAAAA,GAAAA,EAAA1uE,QAAA,EAAA,CACA,GAAAsxC,GAAAkN,EAAA+E,UAAAmrB,EACAtwE,GAAA6d,QAAAq1B,OAEA,IAAA30C,EAAA0G,UAAA1G,EAAA0G,SAAAiuC,OAAA,CACA,GAAAA,GAAA30C,EAAA0G,SAAAiuC,MACAlzC,GAAA6d,QAAAq1B,GAKA,GAAAj1C,GAAA,GAAAC,MAMA,OALAD,GAAAE,IAAAC,EAAAC,aAAAD,EAAAmyE,YACAtyE,EAAAE,IAAAC,EAAAoyE,QAAA/xE,EAAAkI,MAAApI,IACAN,EAAAE,IAAAC,EAAAqyE,QAAAzwE,EAAA2kE,eACA1mE,EAAAE,IAAAC,EAAAsyE,eAAAnyE,EAAAmE,MAAAF,UACAxC,EAAA/B,MAAAA,EACA+B,GAEA7C,EAAA4B,UAAA4xE,aAAA,SAAAruE,EAAAC,GACA,MAAAD,GAAAvG,GAAA,IAAAwG,EAAAxG,IAGAoB,EAAA4B,UAAA6xE,YAAA,SAAAC,GAEA,GAAAA,EAAA,GAAAtyE,QAAAmE,MAAAF,UAAA7D,EAAAolE,YACA,IAAA,GAAApiE,GAAA,EAA2BA,EAAAkvE,EAAAjvE,OAAoBD,IAC/CjG,KAAAy0E,iBAAAU,EAAAlvE,IAAA,OAGAjG,MAAAo1E,oBAAAD,IAKA1zE,EAAA4B,UAAA+xE,oBAAA,SAAAD,GACA,GAAAE,GAAAprE,SAAAkrE,EAAAjvE,OAAA,GACAovE,KAEA1uE,EAAAuuE,EAAA,GAAAvuE,UACAC,EAAAsuE,EAAA,GAAAtuE,QACA0uE,EAAAnmE,EAAAw2C,QAAAh/C,GAAAgK,aACA4kE,EAAApmE,EAAAw2C,QAAA/+C,GAAA+J,aACA6kE,EAAArmE,EAAAs2C,mBAAA6vB,GACAG,EAAAtmE,EAAAs2C,mBAAA8vB,EAGAL,GAAA,GAAAb,MAAAa,EAAA,GAAAZ,OACAgB,EAAA9rE,EAAA+rE,EAAA/rE,GACA0rE,EAAA,GAAAb,KAAA,QACAa,EAAA,GAAAZ,KAAA,SAEAY,EAAA,GAAAb,KAAA,OACAa,EAAA,GAAAZ,KAAA,SAMA,KAAA,GAHAvwB,GAAAyxB,EAAAN,EAAA,GAAAb,MACArwB,EAAAyxB,EAAAP,EAAA,GAAAZ,MACAr8B,EAAAnpC,KAAA2b,MAAAu5B,EAAAv6C,EAAAs6C,EAAAt6C,EAAAu6C,EAAAx6C,EAAAu6C,EAAAv6C,GACAxD,EAAAovE,EAA0BpvE,GAAA,EAAQA,IAAA,CAClC,GAAAuxC,KACAA,GAAA1vC,KAAAk8C,EAGA,IAAA2xB,GAAA3xB,EAAA/4C,OAGA0qE,GAAA7hE,UAAA1E,EAAAm2C,kBAAA,EAAAvlD,KAAAm0E,UAAAluE,IAOA0vE,EAAAlsE,EAAAksE,EAAAlsE,EAAAzJ,KAAAk0E,aAAAnlE,KAAAiQ,IAAAk5B,GACAy9B,EAAAjsE,EAAAisE,EAAAjsE,EAAA1J,KAAAk0E,aAAAnlE,KAAAgQ,IAAAm5B,GAKAV,EAAA1vC,KAAA6tE,EAEA,IAAAC,GAAA3xB,EAAAh5C,OAKA2qE,GAAA9hE,UAAA1E,EAAAm2C,kBAAA,EAAAvlD,KAAAm0E,UAAAluE,IAOA2vE,EAAAnsE,EAAAmsE,EAAAnsE,EAAAzJ,KAAAk0E,aAAAnlE,KAAAiQ,IAAAk5B,GACA09B,EAAAlsE,EAAAksE,EAAAlsE,EAAA1J,KAAAk0E,aAAAnlE,KAAAgQ,IAAAm5B,GAEAV,EAAA1vC,KAAA8tE,GAEAp+B,EAAA1vC,KAAAm8C,GACAqxB,EAAAxtE,KAAA0vC,GAGA89B,EAAAxtE,MAAAk8C,EAAAC,GAGA,KAAA,GADA4xB,GAAA9mE,KAAA2rB,KAAAy6C,EAAAjvE,OAAA,GACAD,EAAA,EAAuBA,EAAA4vE,EAAY5vE,IAAA,CACnC,GAAAuxC,KACAA,GAAA1vC,KAAAk8C,EACA,IAAA2xB,GAAA3xB,EAAA/4C,OAEA0qE,GAAA7hE,UAAA1E,EAAAm2C,kBAAA,GAAAvlD,KAAAm0E,UAAAluE,IACA0vE,EAAAlsE,EAAAksE,EAAAlsE,EAAAzJ,KAAAk0E,aAAAnlE,KAAAiQ,IAAAk5B,GACAy9B,EAAAjsE,EAAAisE,EAAAjsE,EAAA1J,KAAAk0E,aAAAnlE,KAAAgQ,IAAAm5B,GACAV,EAAA1vC,KAAA6tE,EAEA,IAAAC,GAAA3xB,EAAAh5C,OAEA2qE,GAAA9hE,UAAA1E,EAAAm2C,kBAAA,GAAAvlD,KAAAm0E,UAAAluE,IAEA2vE,EAAAnsE,EAAAmsE,EAAAnsE,EAAAzJ,KAAAk0E,aAAAnlE,KAAAiQ,IAAAk5B,GACA09B,EAAAlsE,EAAAksE,EAAAlsE,EAAA1J,KAAAk0E,aAAAnlE,KAAAgQ,IAAAm5B,GAEAV,EAAA1vC,KAAA8tE,GAEAp+B,EAAA1vC,KAAAm8C,GACAqxB,EAAAxtE,KAAA0vC,GAIA,IAAA,GAAAvxC,GAAA,EAAuBA,EAAAqvE,EAAApvE,OAA6BD,IACpDkvE,EAAAlvE,GAAAkc,QAAAmzD,EAAArvE,KAIAxE,EAAA4B,UAAAyyE,cAAA,SAAAv2B,EAAAw2B,GACA,GAAAC,GAAAz2B,EAAAt0C,QAEAitC,EAAAnpC,KAAA2b,MAAAsrD,EAAAtsE,EAAAssE,EAAAvsE,GACA4a,EAAAtV,KAAA+P,KAAA/P,KAAA2nB,IAAAs/C,EAAAvsE,EAAA,GAAAsF,KAAA2nB,IAAAs/C,EAAAtsE,EAAA,GAWA,OAVAqsE,GACA1xD,GAAArkB,KAAAk0E,aAEA7vD,GAAArkB,KAAAk0E,aAKA8B,EAAAvsE,EAAA4a,EAAAtV,KAAAiQ,IAAAk5B,GACA89B,EAAAtsE,EAAA2a,EAAAtV,KAAAgQ,IAAAm5B,GACA89B,GAQAv0E,EAAA4B,UAAA4yE,SAAA,SAAA3xE,EAAAsiE,GACA,GAAAsP,GAAA5xE,EAAA/B,MAAAsD,IAAA,iBACAvB,GAAA/B,MAAAmvE,YAAA9K,GACAsP,IAAAtP,EAAA5/D,MAAAF,UACA9G,KAAAy0E,iBAAAnwE,GAAA,IAUA7C,EAAA4B,UAAA8yE,kBAAA,SAAA3uE,GAGA,IAAA,GADA+gD,GAAAvoD,KAAAsG,aAAAiiD,OACAtiD,EAAA,EAAuBA,EAAAsiD,EAAAriD,OAAiBD,IAAA,CACxC,GAAA8F,GAAAw8C,EAAAtiD,EACA,IAAA8F,EAAA4G,QAAAnL,EAAAnH,QAAA,CACA,GAAA80E,GAAAn1E,KAAAsG,aAAAT,IAAAkG,EACA,IAAAopE,EAAAjvE,OAEAlG,KAAAy0E,iBAAAU,EAAA,IAAA,GACiBA,EAAAjvE,OAAA,GAEjBlG,KAAAk1E,YAAAC,MAMApyE,EAAAmO,SAAAzP,EAAAuyE,GACAn0E,EAAAD,QAAA6B,GzFotnBM,SAAU5B,EAAQD,EAASM,G0F/9nBjC,QAAA8zE,KACAh0E,KAAA6E,cACA7E,KAAA00E,aAAA,KACA10E,KAAAo2E,cAAA,KATA,GAAAhnE,GAAAlP,EAAA,IACAwkD,EAAAxkD,EAAA,IACA+C,EAAA/C,EAAA,IACAm2E,EAAAn2E,EAAA,IACA6C,EAAA7C,EAAA,EAaA8zE,GAAA3wE,UAAA6D,oBAAA,SAAAq8D,GACA,IAAA,GAAAt9D,GAAA,EAAuBA,EAAAjG,KAAA6E,WAAAqB,OAA4BD,IACnDjG,KAAA6E,WAAAoB,GAAApD,QAAAiI,QAAAy4D,GASAyQ,EAAA3wE,UAAAkB,eAAA,WACA,MAAAvE,KAAA00E,cACA10E,KAAAy0E,iBAAAz0E,KAAA00E,eAOAV,EAAA3wE,UAAAgD,gBAAA,SAAAmB,EAAA1F,GACA,IAAA,GAAAmE,GAAA,EAAuBA,EAAAjG,KAAA6E,WAAAqB,OAA4BD,IACnD,GAAAjG,KAAA6E,WAAAoB,GAAAW,WAAAY,GAAAxH,KAAA6E,WAAAoB,GAAAY,SAAAW,EAAA,CAEA,GAAA8uE,GAAAt2E,KAAA6E,WAAAoB,GAAAW,UAAArE,MAAAsD,IAAA,YACAmnC,EAAAjqC,EAAA4P,QAAA2jE,EAAAt2E,KAAA6E,WAAAoB,GAAAogE,WACAr5B,QACAspC,EAAA9vE,OAAAwmC,EAAA,GAGAlrC,EAAAoC,OAAAlE,KAAA6E,WAAAoB,IACAjG,KAAA6E,WAAA2B,OAAAP,EAAA,GACAA,IACAjG,KAAA00E,aAAA,OAIAV,EAAA3wE,UAAAkzE,WAAA,SAAAntC,EAAA5gB,GACAxoB,KAAA00E,aAAAtrC,EACAppC,KAAAw2E,WAAAhuD,IAMAwrD,EAAA3wE,UAAAmzE,WAAA,SAAA10E,GAEA,GAAA9B,KAAA00E,aAAA9tE,UAAA,CACA,GAAA0vE,GAAAt2E,KAAA00E,aAAA9tE,UAAArE,MAAAsD,IAAA,WAMA,IALAmnC,EAAAjqC,EAAA4P,QAAA2jE,EAAAt2E,KAAA00E,aAAArO,YACAr5B,OACAspC,EAAA9vE,OAAAwmC,EAAA,GAGAhtC,KAAAsG,aAAA,CACA,GAAAyF,GAAA/L,KAAAi1E,aAAAj1E,KAAA00E,aAAA9tE,UAAA5G,KAAA00E,aAAA7tE,QAAA7G,KAAA00E,aAAA7xE,QAAA0G,SACAvJ,MAAAsG,aAAAkiD,WAAAz8C,EAAA/L,KAAA00E,eAMA5yE,EAAAoC,OAAAlE,KAAA00E,aAIA,IAAA1nC,GAAAjqC,EAAA4P,QAAA3S,KAAA6E,WAAA7E,KAAA00E,aACA1nC,QACAhtC,KAAA6E,WAAA2B,OAAAwmC,EAAA,GAEAhtC,KAAA00E,aAAA,MASAV,EAAA3wE,UAAAoxE,iBAAA,SAAAnwE,EAAAgwD,GAEA,GAAAA,IAAAhwD,EAAA2kE,eAAA3kE,EAAA2kE,cAAA/iE,OAAA,EAAA,CACA5B,EAAA/B,OAAA+B,EAAA/B,MAAAsD,IAAA,oBACAvB,EAAAzB,QAAAmE,MAAAF,SAAAxC,EAAA/B,MAAAsD,IAAA,kBAEA,IAAA4wE,GAAAz2E,KAAA02E,iBAAApyE,GACAmjE,EAAA,IACAnjE,GAAAzB,QAAA0G,UAAAjF,EAAAzB,QAAA0G,SAAAk+D,iBACAA,EAAAnjE,EAAAzB,QAAA0G,SAAAk+D,eAEA,IAAAkP,GAAA32E,KAAA42E,iBAAAtyE,EAAAzB,QAAAmE,MAAAF,SAAA2vE,EAAA,GACAA,EAAA,GACAA,EAAA,GAAAA,EAAA,GAAAhP,EAEAnjE,GAAA6d,QAAAw0D,EAAA,GAAA,IAGAryE,EAAA2mE,gBAIA+I,EAAA3wE,UAAAqzE,iBAAA,SAAApyE,GACA,GAAAsC,GAAAtC,EAAAsC,UACAC,EAAAvC,EAAAuC,QACAgwE,GAAA,CACAA,GAAAjwE,EAAAR,SAAAS,EAAAT,MAEA,IAAAmvE,GAAA3uE,EAAAg/C,QAAAh/C,EAAAg/C,UAAAh1C,aAAAxB,EAAAw2C,QAAAh/C,EAAAiwE,GAAAjmE,aACAkmE,GAAAljC,OAAA2hC,EAAA9rE,GAAAmqC,OAAA2hC,EAAA7rE,GAAAkqC,OAAA2hC,EAAA9rE,GAAAmqC,OAAA2hC,EAAA1sE,OAAA+qC,OACA2hC,EAAA7rE,GAAAkqC,OAAA2hC,EAAAzsE,SAEA0sE,EAAA3uE,EAAA++C,QAAA/+C,EAAA++C,UAAAh1C,aAAAxB,EAAAw2C,QAAA/+C,EAAAgwE,GAAAjmE,aACAmmE,GAAAnjC,OAAA4hC,EAAA/rE,GAAAmqC,OAAA4hC,EAAA9rE,GAAAkqC,OAAA4hC,EAAA/rE,GAAAmqC,OAAA4hC,EAAA3sE,OAAA+qC,OACA4hC,EAAA9rE,GAAAkqC,OAAA4hC,EAAA1sE,SAGA2sE,EAAArmE,EAAAs2C,mBAAA6vB,GACAG,EAAAtmE,EAAAs2C,mBAAA8vB,GAGAjsE,EAAAjF,EAAAzB,QAAA0G,QACA,IAAAA,EAAA0K,UAAA,CACA,GAAA+iE,GAAAztE,EAAA0K,UAAA0I,MAAA,IACApT,GAAA89D,SAAA2P,EAAA,GACAztE,EAAA+9D,OAAA0P,EAAA,GAEAztE,EAAA89D,UAAA99D,EAAA+9D,SACAiO,EAAA9rE,EAAA+rE,EAAA/rE,GACAF,EAAA89D,SAAA,QACA99D,EAAA+9D,OAAA,SAEA/9D,EAAA89D,SAAA,OACA99D,EAAA+9D,OAAA,SAGA,IAAAtjB,GAAAhkD,KAAAi3E,oBAAA1tE,EAAA89D,SAAAoO,GACAxxB,EAAAjkD,KAAAi3E,oBAAA1tE,EAAA+9D,OAAAoO,EAGA,OAFA1xB,GAAAp/C,IAAA,GAAA8/C,GAAAn7C,EAAAg+D,YAAA,GAAAh+D,EAAAg+D,YAAA,KACAtjB,EAAAr/C,IAAA,GAAA8/C,GAAAn7C,EAAAi+D,UAAA,GAAAj+D,EAAAi+D,UAAA,MACAxjB,EAAAC,EAAA6yB,EAAAC,IAGA/C,EAAA3wE,UAAA4zE,oBAAA,SAAAn4B,EAAAS,GACA,GAAAsI,IACA/c,IAAAyU,EAAAzU,IAAArhC,EACAkhC,KAAA4U,EAAA5U,KAAAjhC,EACAkhC,MAAA2U,EAAA3U,MAAAlhC,EACAqhC,OAAAwU,EAAAxU,OAAAthC,EACAohC,OAAA0U,EAAA1U,OAAAphC,GAGAytE,EAAA,YAAAp4B,EAAA,OACArmC,EAAAxO,SAAAmF,EAAA+3C,SAAA+vB,GAAArvB,GACA,IAAA/I,EAAAnsC,QAAA,WACA,MAAA,IAAA+xC,GAAAjsC,EAAA8mC,EAAAzU,IAAAphC,EACS,IAAAo1C,EAAAnsC,QAAA,YACT,MAAA,IAAA+xC,GAAAnF,EAAA5U,KAAAlhC,EAAAgP,EACS,IAAAqmC,EAAAnsC,QAAA,aACT,MAAA,IAAA+xC,GAAAnF,EAAA3U,MAAAnhC,EAAAgP,EACS,IAAAqmC,EAAAnsC,QAAA,cACT,MAAA,IAAA+xC,GAAAjsC,EAAA8mC,EAAAxU,OAAArhC,EACS,IAAAo1C,EAAAnsC,QAAA,cACT,MAAA,IAAA+xC,GAAAjsC,EAAA8mC,EAAAxU,OAAArhC,EAEA,MAAA,IAAAiC,OAAA,YAYAqoE,EAAA3wE,UAAA8zE,oBAAA,SAAAvwE,EAAAwwE,EAAAtwE,EAAAugE,GAEA,GAAAkO,GAAA3uE,EAAAg/C,QAAAh/C,EAAAg/C,UAAAh1C,aAAAxB,EAAAw2C,QAAAh/C,GAAA,GAAAgK,aAEAkmE,GAAAvB,EAAA9rE,EAAA8rE,EAAA7rE,EAAA6rE,EAAA9rE,EAAA8rE,EAAA1sE,MAAA0sE,EAAA7rE,EAAA6rE,EAAAzsE,QACA2sE,EAAArmE,EAAAs2C,mBAAA6vB,EAEAv1E,MAAAo2E,gBACAp2E,KAAAo2E,cAAA,GAAAnzE,IACA6H,QAAA,EACA9D,OACAF,SAAAA,KAKA,IAAAxC,GAAAtE,KAAAo2E,cAEA7sE,EAAAjF,EAAAzB,QAAA0G,QACAA,GAAA89D,SAAAA,EAAAA,EAAAkO,EAAA9rE,EAAA2tE,EAAA3tE,EAAA,QAAA,OACAF,EAAA+9D,OAAAiO,EAAA9rE,EAAA2tE,EAAA3tE,EAAA,OAAA,QAEAnF,EAAAzB,QAAAmE,MAAAF,SAAAA,CACA,IAAA6vE,GAAA32E,KAAA42E,iBAAA9vE,EAAA2uE,EAAAlsE,EAAA89D,UAAA+P,EACAN,EAAA,KAGA,OADAxyE,GAAA6d,QAAAw0D,EAAA,GAAA,IACAryE,GAWA0vE,EAAA3wE,UAAAg0E,2BAAA,SAAArzB,EAAAn9C,EAAAC,EAAAwgE,GACA,GAAAkO,GAAA3uE,EAAA++C,QAAA/+C,EAAA++C,UAAAh1C,aAAAxB,EAAAw2C,QAAA/+C,GAAA,GAAA+J,aACAmmE,GAAAvB,EAAA/rE,EAAA+rE,EAAA9rE,EAAA8rE,EAAA/rE,EAAA+rE,EAAA3sE,MAAA2sE,EAAA9rE,EAAA8rE,EAAA1sE,QACA4sE,EAAAtmE,EAAAs2C,mBAAA8vB,EACAx1E,MAAAo2E,gBACAp2E,KAAAo2E,cAAA,GAAAnzE,IACA6H,QAAA,EACA9D,OACAF,SAAAA,KAIA,IAAAxC,GAAAtE,KAAAo2E,cACA7sE,EAAAjF,EAAAzB,QAAA0G,QACAA,GAAA+9D,OAAAA,EAAAA,EAAAkO,EAAA/rE,EAAAu6C,EAAAv6C,EAAA,QAAA,OACAF,EAAA89D,SAAAmO,EAAA/rE,EAAAu6C,EAAAv6C,EAAA,OAAA,QAEAnF,EAAAzB,QAAAmE,MAAAF,SAAAA,CACA,IAAA6vE,GAAA32E,KAAA42E,iBAAA9vE,EAAAk9C,EAAA0xB,EAAAnsE,EAAA+9D,QACAyP,EAAA,KAGA,OADAzyE,GAAA6d,QAAAw0D,EAAA,GAAA,IACAryE,GAOA0vE,EAAA3wE,UAAAi0E,oBAAA,SAAA9uD,GACAxoB,KAAAo2E,gBACA5tD,EAAAtkB,OAAAlE,KAAAo2E,eACAp2E,KAAAo2E,cAAA,OAcApC,EAAA3wE,UAAAuzE,iBAAA,SAAAzxE,EAAA6+C,EAAAC,EAAA6yB,EAAAC,EACAtP,GACA,GAAA8P,IAAA,GAAA,GACA9P,KAIA8P,EAHAx0E,EAAAyS,QAAAiyD,GAGAA,GAFAA,EAAAA,IAMA4O,EAAAv1E,MAAA,uCAGAu1E,EAAAmB,KAAA,wCAAAryE,EAAA,KAAA6+C,EAAA,KAAAC,EACA,KAAA6yB,EAAA,KAAAC,EAAA,IACA,IAAAJ,KAIA,QAAAxxE,GACA,IAAAlC,GAAAslE,WAEA,IAAAtlE,GAAAikE,cACA,GAAA1vB,IAAAwM,EAAA/4C,QAAAg5C,EAAAh5C,QACA0rE,GAAA7uE,MAAA,WAAA,WAAA0vC,GACA,MAEA,KAAAv0C,GAAAqlE,WAEA,IAAArlE,GAAAolE,YACA,GAAAoP,GAAA,KACAC,EAAA,IAGA,IAAA,MAAAZ,EAAA,CACA,GAAAa,KAEAA,GAAA7vE,KAAA,GAAA48C,GAAAV,EAAAv6C,EAAAqtE,EAAA,GAAAS,EAAA,KACAI,EAAA7vE,KAAA,GAAA48C,GAAAoyB,EAAA,GAAAS,EAAA,GAAAvzB,EAAAt6C,IACAiuE,EAAA7vE,KAAA,GAAA48C,GAAAV,EAAAv6C,EAAAqtE,EAAA,GAAAS,EAAA,KACAI,EAAA7vE,KAAA,GAAA48C,GAAAoyB,EAAA,GAAAS,EAAA,GAAAvzB,EAAAt6C,IAGA+tE,EAAAE,EAAA,EACA,KAAA,GAAA1xE,GAAA,EAAmCA,EAAA0xE,EAAAzxE,OAA2BD,IAC9DmJ,EAAA6d,SAAA+2B,EAAA2zB,EAAA1xE,IAAAmJ,EAAA6d,SAAA+2B,EACAyzB,KACAA,EAAAE,EAAA1xE,IAOA,GAAA,MAAA8wE,EAAA,CACA,GAAAY,KAEAA,GAAA7vE,KAAA,GAAA48C,GAAAT,EAAAx6C,EAAAstE,EAAA,GAAAQ,EAAA,KACAI,EAAA7vE,KAAA,GAAA48C,GAAAqyB,EAAA,GAAAQ,EAAA,GAAAtzB,EAAAv6C,IACAiuE,EAAA7vE,KAAA,GAAA48C,GAAAT,EAAAx6C,EAAAstE,EAAA,GAAAQ,EAAA,KACAI,EAAA7vE,KAAA,GAAA48C,GAAAqyB,EAAA,GAAAQ,EAAA,GAAAtzB,EAAAv6C,IAGAguE,EAAAC,EAAA,EACA,KAAA,GAAA1xE,GAAA,EAAmCA,EAAA0xE,EAAAzxE,OAA2BD,IAC9DmJ,EAAA6d,SAAAg3B,EAAA0zB,EAAA1xE,IAAAmJ,EAAA6d,SAAAg3B,EACAyzB,KACAA,EAAAC,EAAA1xE,IAMA,GAAA6mB,IAAAk3B,GACA4zB,EAAA,CACAH,KACA3qD,EAAAhlB,KAAA2vE,GACAG,EAAA,GAEAF,GACA5qD,EAAAhlB,KAAA4vE,GAEA5qD,EAAAhlB,KAAAm8C,EAKA,IAAA4zB,GAAAnzB,EAAAwC,WAAAp6B,EACA6pD,GAAA7uE,MAAA,KAAA,KAAA+vE,GAKA,IAAAC,GAAApzB,EAAAwC,WAAAp6B,GAGAirD,EAAArzB,EAAAwC,WAAA4wB,EACAC,GAAAvxE,OAAAoxE,EAAA,EAAA,EAAA,GAAAlzB,GAAAqzB,EAAAH,GAAAnuE,EAAAsuE,EAAAH,EAAA,GAAAluE,IACAitE,EAAA7uE,MAAA,KAAA,OAAAiwE,GAGA,IAAAC,GAAAtzB,EAAAwC,WAAA4wB,EACAE,GAAAxxE,OAAAoxE,EAAA,EAAA,EAAA,GAAAlzB,GAAAszB,EAAAJ,EAAA,GAAAnuE,EAAAuuE,EAAAJ,GAAAluE,IACAitE,EAAA7uE,MAAA,KAAA,OAAAkwE,GAMA,IAAAC,GAAAvzB,EAAAwC,WAAAp6B,GACAorD,EAAA,GAAAxzB,IAAAuzB,EAAAL,GAAAnuE,EAAAwuE,EAAAL,EAAA,GAAAnuE,GAAA,EAAAwuE,EAAAL,GAAAluE,GACAyuE,EAAA,GAAAzzB,IAAAuzB,EAAAL,GAAAnuE,EAAAwuE,EAAAL,EAAA,GAAAnuE,GAAA,EAAAwuE,EAAAL,EAAA,GAAAluE,EACAuuE,GAAAzxE,OAAAoxE,EAAA,EAAA,EAAAM,EAAAC,GACAxB,EAAA7uE,MAAA,KAAA,OAAAmwE,GAKA,IAAAG,GAAA1zB,EAAAwC,WAAAp6B,GACAurD,EAAA,GAAA3zB,GAAA0zB,EAAAR,GAAAnuE,GAAA2uE,EAAAR,GAAAluE,EAAA0uE,EAAAR,EAAA,GAAAluE,GAAA,GACA4uE,EAAA,GAAA5zB,GAAA0zB,EAAAR,EAAA,GAAAnuE,GAAA2uE,EAAAR,GAAAluE,EAAA0uE,EAAAR,EAAA,GAAAluE,GAAA,EACA0uE,GAAA5xE,OAAAoxE,EAAA,EAAA,EAAAS,EAAAC,GACA3B,EAAA7uE,MAAA,KAAA,OAAAswE,GAIA,IAAAG,GAAA7zB,EAAAwC,WAAAp6B,GAIA0rD,GAAAD,EAAAX,GAAAnuE,EAAA,GAAA8uE,EAAAX,EAAA,GAAAnuE,EAAA,GAEAqtE,IACA0B,EAAA1wE,KAAAgvE,EAAA,GAAA,IAGAC,GACAyB,EAAA1wE,KAAAivE,EAAA,GAAA,GAGA,IAAA0B,GAAArpE,EAAA4C,IAAAwmE,GACAE,EAAA,GAAAh0B,GAAA+zB,EAAAF,EAAAX,GAAAluE,GACAivE,EAAA,GAAAj0B,GAAA+zB,EAAAF,EAAAX,EAAA,GAAAluE,EACA6uE,GAAA/xE,OAAAoxE,EAAA,EAAA,EAAAc,EAAAC,GACAhC,EAAA7uE,MAAA,KAAA,OAAAywE,GAIA,IAAAK,GAAAl0B,EAAAwC,WAAAp6B,GAIA+rD,GAAAD,EAAAhB,GAAAluE,EAAA,GAAAkvE,EAAAhB,EAAA,GAAAluE,EAAA,GAEAotE,IACA+B,EAAA/wE,KAAAgvE,EAAA,GAAA,IAGAC,GACA8B,EAAA/wE,KAAAivE,EAAA,GAAA,GAGA,IAAA+B,GAAA1pE,EAAAgV,IAAAy0D,GACAE,EAAA,GAAAr0B,GAAAk0B,EAAAhB,GAAAnuE,EAAAqvE,GACAE,EAAA,GAAAt0B,GAAAk0B,EAAAhB,EAAA,GAAAnuE,EAAAqvE,EACAF,GAAApyE,OAAAoxE,EAAA,EAAA,EAAAmB,EAAAC,GACArC,EAAA7uE,MAAA,KAAA,OAAA8wE,GAIA,IAAAK,GAAAv0B,EAAAwC,WAAAp6B,GAIAosD,GAAAD,EAAArB,GAAAnuE,EAAA,GAAAwvE,EAAArB,EAAA,GAAAnuE,EAAA,GAEAqtE,IACAoC,EAAApxE,KAAAgvE,EAAA,GAAA,IAGAC,GACAmC,EAAApxE,KAAAivE,EAAA,GAAA,GAGA,IAAAoC,GAAA/pE,EAAAgV,IAAA80D,GACAE,EAAA,GAAA10B,GAAAy0B,EAAAF,EAAArB,GAAAluE,GACA2vE,EAAA,GAAA30B,GAAAy0B,EAAAF,EAAArB,EAAA,GAAAluE,EACAuvE,GAAAzyE,OAAAoxE,EAAA,EAAA,EAAAwB,EAAAC,GACA1C,EAAA7uE,MAAA,KAAA,OAAAmxE,GAIA,IAAAK,GAAA50B,EAAAwC,WAAAp6B,GAIAysD,GAAAD,EAAA1B,GAAAluE,EAAA,GAAA4vE,EAAA1B,EAAA,GAAAluE,EAAA,GAEAotE,IACAyC,EAAAzxE,KAAAgvE,EAAA,GAAA,IAGAC,GACAwC,EAAAzxE,KAAAivE,EAAA,GAAA,GAGA,IAAAyC,GAAApqE,EAAA4C,IAAAunE,GACAE,EAAA,GAAA/0B,GAAA40B,EAAA1B,GAAAnuE,EAAA+vE,GACAE,EAAA,GAAAh1B,GAAA40B,EAAA1B,EAAA,GAAAnuE,EAAA+vE,EACAF,GAAA9yE,OAAAoxE,EAAA,EAAA,EAAA6B,EAAAC,GACA/C,EAAA7uE,MAAA,KAAA,OAAAwxE,IAiBAjD,EAAAmB,KAAA,8DAAAb,EAAAzwE,OAEA,KAAA,GADAyzE,MACAlwD,EAAA,EAA+BA,EAAAktD,EAAAzwE,OAAsBujB,IAAA,CACrD,GAAAmwD,GAAAjD,EAAAltD,GAAA,EACAra,GAAAw0C,eAAAg2B,IACAD,EAAA7xE,KAAA6uE,EAAAltD,IAQA,GALAktD,EAAAgD,EACAtD,EAAAmB,KAAA,6BAAAb,EAAAzwE,QAIA89C,EAAA4F,OAAA3F,GACAoyB,EAAAmB,KACA,iGAEiB,CACjBnB,EAAAmB,KAAA,4DAAAb,EAAAzwE,OAGA,KAAA,GAFA2zE,MACAC,GAAA,GACArwD,EAAA,EAAmCA,EAAAktD,EAAAzwE,OAAsBujB,IAAA,CACzD,GAAAmwD,GAAAjD,EAAAltD,GAAA,EACAra,GAAA41C,YAAA40B,GACAC,EAAA/xE,KAAA6uE,EAAAltD,IAEAqwD,GAAAA,GAAA,OAAAF,EAGAjD,EAAAkD,EACAxD,EAAAmB,KAAA,2BAAAb,EAAAzwE,QACA,GAAAywE,EAAAzwE,QACAmwE,EAAAmB,KAAA,wBAAAsC,IAMAzD,EAAAmB,KAAA,oEAAAb,EAAAzwE,OAEA,KAAA,GADA6zE,OACAtwD,EAAA,EAA+BA,EAAAktD,EAAAzwE,OAAsBujB,IAAA,CACrD,GAAAmwD,GAAAjD,EAAAltD,GAAA,GAEAulB,IAAA,EAEAgrC,GAAAJ,EAAAthE,SAIAy+D,GAAAD,KAEAkD,GAAAA,GAAA1hE,MAAA,EAAA0hE,GAAA9zE,OAAA,IAOA4wE,IACA9nC,GAAAA,IAAA5/B,EAAAm1C,4BAAAy1B,GAAAlD,IAEAC,IACA/nC,GAAAA,IAAA5/B,EAAAm1C,4BAAAy1B,GAAAjD,IAGA/nC,IACA+qC,GAAAjyE,KAAA6uE,EAAAltD,IAKA,GAAAswD,GAAA7zE,SAEAywE,EAAAoD,IAGA1D,EAAAmB,KAAA,mCAAAb,EAAAzwE,QAIAmwE,EAAAmB,KAAA,uDACA,GAAAb,EAAAzwE,QACAmwE,EAAAmB,KAAA,uBAOA,KAAA,GAJAyC,IAAAtD,EAAA,GAAA,GACAuD,GAAAD,GAAA/zE,OACAi0E,MAEA1wD,EAAA,EAA+BA,EAAAktD,EAAAzwE,OAAsBujB,IAAA,CACrD,GAAAmwD,GAAAjD,EAAAltD,GAAA,EACAmwD,GAAA1zE,QAAAg0E,IACAC,GAAAryE,KAAA6uE,EAAAltD,IAIAktD,EAAAwD,GASA9D,EAAAmB,KAAA,mEAEA,KAAA,GADA4C,IAAA,EACA3wD,EAAA,EAA+BA,EAAAktD,EAAAzwE,OAAsBujB,IAAA,CACrD,GAAAmwD,GAAAjD,EAAAltD,GAAA,EACAra,GAAAy1C,UAAA8xB,EAAAyD,IAAA,IAAAhrE,EAAAy1C,UAAA8xB,EAAAltD,GAAA,MACA2wD,GAAA3wD,GAGAktD,GAAAA,EAAAyD,KAcA,MAPAj1E,KAAAlC,EAAAqlE,YACAtoE,KAAAq6E,YAAA1D,GAIAN,EAAAiE,WAEA3D,GAGA3C,EAAA3wE,UAAAg3E,YAAA,SAAA1D,GACA,GAAA/P,GAAA,CAEA,QAAAA,GACA,IAAA,GAEA,KAEA,KAAA,GAIA,IAAA,GAAA95C,GAAA,EAA+BA,EAAA6pD,EAAAzwE,OAAsB4mB,IAAA,CACrD,GAAAytD,GAAA5D,EAAA7pD,GAAA,GAGAq3B,EAAAo2B,EAAA,GACAl2B,EAAAk2B,EAAA,GACAC,EAAAprE,EAAAqrE,UAAAt2B,EAAAE,EACAk2B,GAAA/zE,OAAA,EAAA,EAAAg0E,EAGA,IAAAE,GAAAH,EAAAA,EAAAr0E,OAAA,GACAy0E,EAAAJ,EAAAA,EAAAr0E,OAAA,GACA00E,EAAAxrE,EAAAqrE,UAAAC,EAAAC,EACAJ,GAAA/zE,OAAA+zE,EAAAr0E,OAAA,EAAA,EAAA00E,GAEA,KAEA,KAAA,GAEA73E,EAAAwJ,KAAAoqE,EAAA,SAAAiD,GACA,GAAAiB,GAAAjB,EAAA,EACA,IAAA,MAAAiB,GAAA,MAAAA,EAAA,CACA,GAAAN,GAAAX,EAAA,EACAW,GAAA/zE,OAAA,EAAA,GACA+zE,EAAA/zE,OAAA+zE,EAAAr0E,OAAA,EAAA,KAGA,MAEA,KAAA,GAGAnD,EAAAwJ,KAAAoqE,EAAA,SAAAiD,GACA,GAAAiB,GAAAjB,EAAA,EACA,IAAA,MAAAiB,EAAA,CACA,GAAAN,GAAAX,EAAA,GACAkB,EAAA1rE,EAAA63C,mBAAAszB,EACAX,GAAA,GAAAkB,OAQAj7E,EAAAD,QAAAo0E,G1Fi/nBM,SAAUn0E,EAAQD,G2FpqpBxB,GAAAy2E,IACA0E,eAAA,EAEAC,gBAAA,EAEAC,eAAA,EAEAC,gBAAA,EAEAjhD,MAAAj6B,KAAAk7E,gBAMAC,MAAA,SAAAviE,GACA,mBAAAmtB,UACA/lC,KAAAi6B,OAAAj6B,KAAAg7E,iBAGA,kBAAAj1C,SAAAo1C,OACAp1C,QAAAo1C,MAAAviE,IAcA4+D,KAAA,SAAA5+D,GACA,mBAAAmtB,UACA/lC,KAAAi6B,OAAAj6B,KAAAi7E,gBACAl1C,QAAAyxC,KAAA5+D,IASAkzD,MAAA,SAAAlzD,GACA,mBAAAmtB,UACA/lC,KAAAi6B,OAAAj6B,KAAAk7E,iBACAn1C,QAAA+lC,MAAAlzD,IAUA9X,MAAA,SAAAs6E,GACAp7E,KAAAi6B,OAAAj6B,KAAAi7E,gBACA,mBAAAl1C,UAGA,kBAAAA,SAAAjlC,OACAilC,QAAAjlC,MAAAs6E,IAOAd,SAAA,WACAt6E,KAAAi6B,OAAAj6B,KAAAi7E,gBACA,mBAAAl1C,UAGA,kBAAAA,SAAAu0C,UACAv0C,QAAAu0C,YASAjE,GAAAp8C,MAAAo8C,EAAA6E,gBAGAr7E,EAAAD,QAAAy2E,G3FkrpBM,SAAUx2E,EAAQD,G4F/wpBxBC,EAAAD,SACA+C,aAAA,cACAC,KAAA,OACAkD,WAAA,YACAgvE,QAAA,UACA9pE,SAAA,WACAqwE,GAAA,KACAC,SAAA,cACAC,OAAA,YACAC,MAAA,QACAC,WAAA,aACAC,eAAA,gBACAC,MAAA,QACA9G,WAAA,aACA7uE,OAAA,SACA41E,UAAA,WACA7G,QAAA,kBACAC,eAAA,iBACA6G,kBAAA,sB5F4xpBM,SAAUh8E,EAAQD,EAASM,G6FpypBjC,QAAAsF,GAAAjD,EAAAzB,GACA,GAAAg7E,KAaA,OAZAh7E,GAAAg7C,UAAA,SAAAt0C,GACAA,EAAAjF,QACAiF,YAAAvE,IACAuE,EAAA2kE,eAEA2P,EAAAh0E,KAAAN,EAAAjF,MAAAqkE,WAMArkE,EAAAE,IAAAC,EAAAsD,OAAA81E,GACAv5E,EAAAqkE,OASA,QAAAnhE,GAAAs2E,EAAAj7E,EAAAk7E,EAAAC,EAAAl2E,GAOA,IAAA,GAAAE,GAAA,EAAuBA,EAAA+1E,EAAA91E,OAAwBD,IAAA,CAC/C,GAAAmjC,GAAA4yC,EAAA/1E,GACAi2E,EAAAH,EAAAnxE,mBAAAw+B,EAAAvmC,QAAAumC,EAAAv+B,SACAoxE,GACAn7E,EAAA8D,IAAAs3E,GAEAH,EAAAx0E,QAAA20E,IA2BA,QAAAphB,GAAAtyC,EAAA3nB,GACAA,EAAAA,MACAA,EAAAw6D,WAAAx6D,EAAAw6D,YAAA,EACAx6D,EAAAqI,gBAAArI,EAAAqI,iBACA,SACA,IAAAw8B,GAAAld,EAAAgzB,QAAA0U,gBAKA,OAHAntD,GAAAwJ,KAAAm5B,EAAA,SAAAj5B,GACAA,EAAAwhB,eAAA,KAEAzF,EAAAqjC,QAAAiP,kBAAAj6D,GAGA,QAAAsK,GAAAqd,EAAA3nB,GACAA,EAAAA,KACA,IAAAs7E,GAAArhB,EAAAtyC,EAAA3nB,GAAAsK,UACA,UAAAtK,GAAAA,EAAAsE,MAAA,OAEA,OAAAg3E,GA3FA,GACAz5E,IADAxC,EAAA,IACAA,EAAA,KACA6C,EAAA7C,EAAA,GACA+C,EAAA/C,EAAA,GA2GAL,GAAAD,SACA4F,OAAAA,EACAC,SAAAA,EACA0F,UAAAA,I7F2zpBM,SAAUtL,EAAQD,EAASM,G8Fx6pBjC,QAAAyB,GAAAy6E,EAAA9Y,GACAtjE,KAAAq8E,kBACAr8E,KAAA8K,QAAA,EACA9K,KAAAo8E,kBAAAA,EACAp8E,KAAAmC,KAAAmhE,EAPA,GAAAI,GAAAxjE,EAAA,IACA6C,EAAA7C,EAAA,GACAujE,EAAAvjE,EAAA,GAWAyB,GAAA0B,UAAAi5E,QAAA,SAAAvwE,EAAAlJ,GAEA,GAAA05E,GAAAx5E,EAAAoU,KAAAtU,EAAA0C,SAAA0iE,MAAA,SAAAxE,GACA,MAAAA,GAAA13D,MAAAA,GAGA,IAAAwwE,EAEA,WADAv8E,MAAAsF,cAAAzC,EAAA0C,SAGA,IAAAi3E,GAAAx8E,KAAAy8E,eAAA1wE,EAAAlJ,EAGA,OAFA7C,MAAAmC,KAAAu6E,eAAA93E,IAAA43E,GACAx8E,KAAAsF,cAAAzC,EAAA0C,UACAi3E,GAKA76E,EAAA0B,UAAAo5E,eAAA,SAAA1wE,EAAAlJ,GACA,GAAA25E,GAAA9Y,EAAAiC,aAAA9iE,EAAA+iE,SAAA,EAAA,EAAA/iE,EAAAgG,OAAA,GAAAhG,EAAAiG,QAAA,GAAA,EAAAjG,EAAA2P,OAAA,UAsBA,OArBAgqE,GAAAzwE,IAAAA,EACAywE,EAAApmB,OAAAvzD,EAAAgG,OAAA,GACA2zE,EAAAG,sBAAA,EACAH,EAAAn0D,OACAxlB,EAAA0C,SAAA0iE,MAAAngE,KAAA00E,GACAx8E,KAAAq8E,eAAAv0E,KAAA00E,GAGAA,EAAA13E,GAAA,QAAA,SAAAI,GACA,GAAArC,EAAA0rB,SACArpB,EAAAsR,KAAA3T,EACAqC,EAAAK,SAAA1C,EAAA0C,SACA1C,EAAA0rB,SAAArpB,OACa,CACb,GAAAD,KACAA,GAAAC,MAAAA,EACAD,EAAAE,KAAA,QACAF,EAAA23E,YAAA,oBACA58E,KAAAmC,KAAAiD,QAAAH,EAAAE,KAAAF,KAESgC,KAAAjH,OACTw8E,GAQA76E,EAAA0B,UAAAiC,cAAA,SAAAhB,GACA,QAAAu4E,GAAAr1E,GACA,MAAAA,GAAApB,QAAA,cAAAoB,EAAApB,OAAAwR,SACApQ,EAAA+B,SAAA,GAAAszE,EAAAr1E,EAAApB,QAEAoB,EAAA+B,SAAA,GAIA,QAAAuzE,GAAAt1E,GACA,MAAAA,GAAApB,QAAA,cAAAoB,EAAApB,OAAAwR,SACApQ,EAAA+B,SAAA,GAAAuzE,EAAAt1E,EAAApB,QAEAoB,EAAA+B,SAAA,GAIA,GAAA,GAAAvJ,KAAA8K,OAAA,CAGA,GAAAiyE,GAAAC,EAAAC,EAAA34E,EAAA0mC,QACA1mC,GAAA8B,QAAA,cAAA9B,EAAA8B,OAAAwR,UACAmlE,EAAAE,EAAA,GAAAJ,EAAAv4E,EAAA8B,QACA42E,EAAAC,EAAA,GAAAH,EAAAx4E,EAAA8B,UAEA22E,EAAAE,EAAA,GACAD,EAAAC,EAAA,GAGA,IAAAC,GAAAn6E,EAAA6T,IAAAtS,EAAA2jE,MAAA,SAAAxE,GACA,MAAAA,GAAArN,SAGA+mB,EAAAp6E,EAAA+T,OAAAomE,EAAA,SAAAE,EAAAC,GACA,MAAAD,GAAAC,EAAA,IACS,EAETt6E,GAAAwJ,KAAAjI,EAAA2jE,MAAA,SAAAxE,EAAAz2B,GAEA,IAAA,GADAswC,GAAA,EACA7nD,EAAA,EAA2BA,EAAAuX,EAAWvX,IACtC6nD,GAAAJ,EAAAznD,GAAA,EAEAguC,GAAA70D,KAAA,YAAAmuE,EAAAO,EAAAH,EAAA,EAAAH,EAAA,IACAvZ,EAAAn7C,OACAm7C,EAAA8Z,WAAAj5E,MAIA3C,EAAA0B,UAAAoB,qBAAA,WACA1B,EAAAwJ,KAAAvM,KAAAq8E,eAAA,SAAAG,GACAA,EAAAn0D,UAIA1mB,EAAA0B,UAAAm6E,cAAA,SAAAj4E,EAAA1C,GACA,GAAAhC,GAAAkC,EAAA6I,UACAg6D,SAAA,UAAAnC,EAAAgB,QACA57D,MAAA,GACAC,OAAA,GACAvD,SAAAA,EACAgpB,SAAA,SAAAvqB,GACAhE,KAAAmC,KAAA+B,OAAAF,EAAAI,OAAAm5E,aACat2E,KAAAjH,OACJ6C,GAAA,EAET7C,MAAAs8E,QAAA,SAAAz7E,IAGAc,EAAA0B,UAAAo6E,sBAAA,SAAAl4E,EAAA1C,GACA,GAAAhC,GAAAkC,EAAA6I,UACAg6D,SAAA,UAAAnC,EAAAsQ,qBACAlrE,MAAA,GACAC,OAAA,GACAvD,SAAAA,EACAgpB,SAAA,WACAvuB,KAAAmC,KAAAu7E,6BACaz2E,KAAAjH,OACJ6C,GAAA,EAET7C,MAAAs8E,QAAA,SAAAz7E,IAGAhB,EAAAD,QAAA+B,G9Fw7pBM,SAAU9B,EAAQD,EAASM,G+FvkqBjC,GAAAwC,GAAAxC,EAAA,IACAy9E,GACAC,UAAA,cACAC,KAAA,aACAC,KAAA,OACAp5E,MAAA,QACAq5E,MAAA,QACAC,KAAA,OACAC,OAAA,SACAC,OAAA,SACAC,KAAA,OACAC,QAAA,UACAC,SAAA,WACAC,KAAA,OACAC,YAAA;AACAC,IAAA,MACAC,MAAA,QAaAC,YAAA,SAAAl3E,EAAAiP,GACAjP,EAAAjF,MAAAE,IAAAC,EAAAsI,SAAAyL,IAYAkoE,YAAA,SAAAn3E,GACA,MAAAA,GAAAjF,MAAAsD,IAAAnD,EAAAsI,WAaA3G,OAAA,SAAA9B,GACA,GAAAq6E,GAAAr6E,EAAAsD,IAAA83E,EAAAC,UACA,OAAAhB,IAAAe,EAAAE,MAYA/mB,QAAA,SAAAv0D,GACA,GAAAq6E,GAAAr6E,EAAAsD,IAAA83E,EAAAC,UACA,OAAAhB,IAIA/8E,GAAAD,QAAA+9E,G/FqlqBM,SAAU99E,EAAQD,GgGrlqBxB,QAAAuD,GAAA6O,GAEAhS,KAAAgS,IAAAA,GAAA4sE,EAAAC,OACA7+E,KAAA8+E,SAAA,KACA9+E,KAAA++E,SAAA,KAKA/+E,KAAAg/E,QA5DA,GAAAC,GAAA,aAEAL,GAEAC,OAAA,EAGAK,MAAA,GAGAC,GAEAC,QAAA,WACA,GAAAC,GAAA,GAAA/1E,MAEA,OAAA+1E,GAAAC,QACA,SAAA1+E,EAAA8G,EAAAsO,GAEA,MADApV,GAAA0+E,QAAA53E,GAAAsO,EACAA,GAGA,SAAApV,EAAA8G,EAAAsO,GAEA,MADApV,GAAAiL,aAAA,QAAAnE,EAAAsO,GACAA,MAKAupE,QAAA,WACA,GAAAF,GAAA,GAAA/1E,MAEA,OAAA+1E,GAAAC,QACA,SAAA1+E,EAAA8G,GACA,MAAA9G,GAAA0+E,QAAA53E,GAGA9G,EAAA0+E,QAAA53E,GAFA9G,EAAAoL,aAAA,QAAAtE,IAMA,SAAA9G,EAAA8G,GACA,MAAA9G,GAAAoL,aAAA,QAAAtE,OAyBAvE,GAAAE,UAAAm8E,SAAA,WACA,GAAAv5E,GAAAo5E,EAAA5oE,EAAAkjC,CAEA,KADAA,EAAA35C,KACAiG,EAAA,EAAmBA,EAAAjG,KAAAgS,IAAc/L,IACjCwQ,KACA4oE,EAAA,GAAA/1E,OACA61E,EAAAC,QAAAC,EAAA,KAAAp5E,GACAo5E,EAAApvC,OAAA,WAEA0J,EAAA8lC,OAAA9lC,EAAA+lC,QAAA1/E,MAAA,UAAAA,MAEA25C,EAAAgmC,YAAA3/E,OAEAq/E,EAAAO,QAAA,WACA,GAAAp4E,GAAAmyC,EAAA+lC,QAAA1/E,KAEAwH,GAAA03E,MAAAN,EAAAM,OACA13E,EAAA03E,MAAA13E,EAAA03E,MAAA,EAEAvlC,EAAAkmC,WAAAlmC,EAAAmmC,WAAAt4E,EAAA4oC,IAAA5oC,EAAA3E,QAAA2E,EAAAi4E,OAAAj4E,EAAA1G,MAAA0G,EAAA03E,SAIAvlC,EAAA8lC,OAAAj4E,EAAA,QAAAxH,MAGA25C,EAAAgmC,YAAA3/E,OAEAyW,EAAA4oE,IAAAA,EACA5oE,EAAAspE,MAAA,EACA//E,KAAAg/E,KAAAl3E,KAAA2O,IAUAtT,EAAAE,UAAAo8E,OAAA,SAAAj4E,EAAAw4E,EAAAX,GACA73E,EAAAi4E,OAAAO,EAAAX,IAOAl8E,EAAAE,UAAAs8E,YAAA,SAAA/+E,GAEAZ,KAAA8+E,UAEA9+E,KAAAigF,OAAAr/E,EAAAZ,KAAA8+E,UAEA9+E,KAAAkgF,aAGAlgF,KAAAggF,OAAAp/E,GAAA,IAOAuC,EAAAE,UAAA88E,QAAA,WACA,GAAAj6E,GAAAD,CACA,KAAAA,EAAA,EAAAC,EAAAlG,KAAAg/E,KAAA94E,OAA8CD,EAAAC,EAAYD,IAC1D,GAAAjG,KAAAg/E,KAAA/4E,GAAA85E,KACA,MAAA//E,MAAAg/E,KAAA/4E,EAGA,OAAA,OASA9C,EAAAE,UAAA48E,OAAA,SAAAr/E,EAAA4G,GAEAxH,KAAAggF,OAAAp/E,GAAA,GAEAZ,KAAAogF,QAAAx/E,EAAA4G,GAEA5G,EAAAwvC,IAAA5oC,EAAA4oC,KAQAjtC,EAAAE,UAAA28E,OAAA,SAAAp/E,EAAAo/E,GACA,GAAA3/E,GAAA8+E,EAAAI,QAAA3+E,EAAA,KACAP,KACAL,KAAAg/E,KAAA3+E,GAAA0/E,KAAAC,GAIAA,IACAhgF,KAAAg/E,KAAA3+E,GAAAmH,KAAA,OASArE,EAAAE,UAAA+8E,QAAA,SAAAx/E,EAAA4G,GACA,GAAAnH,GAAA8+E,EAAAI,QAAA3+E,EAAA,KACA,IAAAP,EAEA,MADAL,MAAAg/E,KAAA3+E,GAAAmH,KAAAA,EACAxH,KAAAg/E,KAAA3+E,GAAAmH,OAAAA,GASArE,EAAAE,UAAAq8E,QAAA,SAAA9+E,GACA,GAAAP,GAAA8+E,EAAAI,QAAA3+E,EAAA,KACA,IAAAP,EACA,MAAAL,MAAAg/E,KAAA3+E,GAAAmH,MAUArE,EAAAE,UAAAg9E,MAAA,SAAAjwC,EAAAvtC,GACA,GAAAy9E,MACAP,EAAA,KACA75E,EAAA,EACAD,EAAA,EAEAw5E,EAAA,WACA,MAAA58E,GAAA09E,KACA,SAAAP,EAAAX,GACA,GAAAnnD,GAAAl4B,KAAAc,MACAyoD,EAAAvpD,KAAA6C,OAEAq1B,GAAA8nD,GAAAl4E,KAAAu3E,GAEAnnD,EAAAsoD,QAAAt6E,OAAAgyB,EAAA4zC,MAAA5lE,SAAAgyB,EAAAzJ,OAGAmvC,WAAA,WACArU,EAAAi3B,QAAAjgF,KAAA,KAAA23B,EAAAsoD,QAAAtoD,EAAA4zC,MAAA5zC,EAAAzJ,QAC6B,IAI7B,SAAAuxD,EAAAX,GACA,GAAA91B,GAAAvpD,KAAA6C,OAEA+6D,YAAA,WACArU,EAAAy2B,GAAAz/E,KAAA,KAAA8+E,IACyB,OAIzBv+E,GACA2tB,MAAA,EACA+xD,WACA1U,UAEAtkE,EAAA,IAQA,KAPA3E,EAAAA,MACAA,EAAA29E,QAAA39E,EAAA29E,SAAAvB,EACAp8E,EAAAipE,MAAAjpE,EAAAipE,OAAAmT,EACAqB,EAAAA,EAAA7oE,OAAA24B,GAEAtvC,EAAA2tB,MAAA6xD,EAAAp6E,OAEAD,EAAA,EAAAC,EAAAo6E,EAAAp6E,OAAyCD,EAAAC,EAAYD,IAErDuB,EAAAxH,KAAA8/E,WAAAQ,EAAAr6E,GAAApD,EAAA48E,EAAA3+E,GAEAi/E,EAAA//E,KAAAmgF,UACAJ,EAEA//E,KAAAigF,OAAAF,EAAAV,IAAA73E,GAGAxH,KAAA6/E,WAAAr4E,IASArE,EAAAE,UAAAo9E,MAAA,WACA,GAAAjJ,MACAtxE,EAAA,EACAD,EAAA,EACAuB,EAAA,IAYA,KAVAgwE,EAAAqH,UAEArH,EAAAqH,OAAApwD,MAAAzuB,KAAAg/E,KAAA94E,OAEAsxE,EAAAqH,OAAAkB,KAAA,EAEAvI,EAAAkJ,QAEAlJ,EAAAkJ,KAAAjyD,MAAA,EAEAxoB,EAAA,EAAAC,EAAAlG,KAAAg/E,KAAA94E,OAA8CD,EAAAC,EAAYD,IAC1DjG,KAAAg/E,KAAA/4E,GAAA85E,OACAvI,EAAAqH,OAAAkB,KAAAvI,EAAAqH,OAAAkB,KAAA,EAKA,IADAv4E,EAAAxH,KAAA8+E,SAGA,IADAtH,EAAAkJ,KAAAjyD,MAAA+oD,EAAAkJ,KAAAjyD,MAAA,EACAjnB,EAAA09B,MACAsyC,EAAAkJ,KAAAjyD,MAAA+oD,EAAAkJ,KAAAjyD,MAAA,EACAjnB,EAAAA,EAAA09B,IAGA,OAAAsyC,IAaAr0E,EAAAE,UAAAy8E,WAAA,SAAA1vC,EAAAvtC,EAAA48E,EAAA3+E,EAAA6/E,GACA,GAAAn5E,KAMA,OALAA,GAAA4oC,IAAAA,EACA5oC,EAAA3E,QAAAA,EACA2E,EAAAi4E,OAAAA,EACAj4E,EAAA1G,MAAAA,EACA0G,EAAA03E,MAAAyB,GAAA,EACAn5E,GAOArE,EAAAE,UAAAw8E,WAAA,SAAAr4E,GAEAxH,KAAA8+E,UAIA9+E,KAAA++E,SAAA75C,KAAA19B,EACAxH,KAAA++E,SAAAv3E,IAJAxH,KAAA8+E,SAAAt3E,EACAxH,KAAA++E,SAAAv3E,IAUArE,EAAAE,UAAA68E,UAAA,WAEAlgF,KAAA8+E,WAEA9+E,KAAA8+E,SAAA9+E,KAAA8+E,SAAA55C,MAAA,MAQA,IAAA54B,GAAA,SAAA0F,GACA,GAAA64C,GAAA,GAAA1nD,GAAA6O,EAEA,OADA64C,GAAA20B,YAUAl2B,KAAA,WACAuB,EAAAw1B,MAAA7oE,MAAAqzC,EAAAtzC,YAMAigE,KAAA,WACA,MAAA3sB,GAAA41B,MAAAlgF,KAAAsqD,KAKAhrD,GAAAD,SAAsB0M,cAAAA,IhG+qqBhB,SAAUzM,EAAQD,GiGnkrBxB2Y,SAAAlV,UAAA4D,OACAsR,SAAAlV,UAAA4D,KAAA,SAAA25E,GACA,GAAA,kBAAA5gF,MAEA,KAAA,IAAA6gF,WAAA,uEAGA,IAAAC,GAAAxmE,MAAAjX,UAAAiV,MAAA/X,KAAAgX,UAAA,GACAwpE,EAAA/gF,KACAghF,EAAA,aACAC,EAAA,WACA,MAAAF,GAAAvpE,MAAAxX,eAAAghF,IAAAJ,EAAA5gF,KAAA4gF,GAAA56C,OACA86C,EAAArpE,OAAA6C,MAAAjX,UAAAiV,MAAA/X,KAAAgX,aAMA,OAHAypE,GAAA39E,UAAArD,KAAAqD,UACA49E,EAAA59E,UAAA,GAAA29E,GAEAC,IAKA,UAAAl+D,SAAA1f,YACA0f,QAAA1f,UAAAa,OAAA,WACAlE,KAAA4vD,YACA5vD,KAAA4vD,WAAA+K,YAAA36D,QAKAkhF,OAAA79E,UAAA89E,WACAD,OAAA79E,UAAA89E,SAAA,SAAAC,EAAA73E,GACA,GAAA83E,GAAArhF,KAAAoa,YACA,gBAAA7Q,KAAA45D,SAAA55D,IAAAwF,KAAA6hB,MAAArnB,KAAAA,GAAAA,EAAA83E,EAAAn7E,UACAqD,EAAA83E,EAAAn7E,QAEAqD,GAAA63E,EAAAl7E,MACA,IAAA0mC,GAAAy0C,EAAA1uE,QAAAyuE,EAAA73E,EACA,OAAAqjC,SAAAA,IAAArjC,KjG+krBM,SAAU1J,EAAQD,EAASM,GkGxnrBjCA,EAAA,GAEA,IAAAohF,GAAAphF,EAAA,IAEA+qD,EAAAq2B,EAAAr2B,gBAEAK,EAAAprD,EAAA,IAEA+qD,GAAA,MAAAK,IlG8nrBM,SAAUzrD,EAAQD,EAASM,GmGtorBjC,GAAA28C,GAAA38C,EAAA,IAEAm3C,EAAAn3C,EAAA,IAEAkR,EAAAimC,EAAAjmC,eAEApB,EAAA9P,EAAA,IAEA8M,EAAA9M,EAAA,IAEAoP,EAAApP,EAAA,IAEA+lC,EAAA/lC,EAAA,IAEAgjB,EAAAhjB,EAAA,IAEAif,EAAAjf,EAAA,GAEAg8C,EAAAh8C,EAAA,IAEAmP,EAAAnP,EAAA,IAEA8O,EAAA9O,EAAA,GAEA4c,EAAA5c,EAAA,IAEA+M,EAAA/M,EAAA,IAEAqhF,EAAArhF,EAAA,IAIA6c,EAAAD,EAAAC,IACAjO,EAAAC,KAAAD,MACAgQ,EAAA/P,KAAA+P,KACA3K,EAAApF,KAAAoF,IACA6K,EAAAjQ,KAAAiQ,IACAD,EAAAhQ,KAAAgQ,IACAwvB,EAAAx/B,KAAAiD,GAEA,KAAA6qC,EAAAc,gBAAA,CACA,GAAA6jC,GAAA,IACAC,EAAA,oCACA5jE,EAAA,MACA6jE,EAAA7jE,EAAA,EACA8jE,EAAA,IACAC,EAAA,IAEAC,EAAA,SAAAp1E,GACAA,EAAAzF,MAAAouD,QAAA,uDACA3oD,EAAAq1E,UAAAjkE,EAAA,IAAAA,EACApR,EAAAs1E,YAAA,OAGAC,EAAA,SAAAl1D,GACA,MAAAo0D,QAAAp0D,GAAAvQ,QAAA,KAAA,SAAyCA,QAAA,KAAA,WAGzC0lE,EAAA,SAAA59D,EAAA6T,EAAA3L,GACA,MAAA,QAAAlI,EAAA6T,EAAA3L,GAAAsE,KAAA,KAAA,KAGAqxD,EAAA,SAAA97E,EAAAgC,GACAA,GAAAhC,GAAAgC,EAAAwnD,aAAAxpD,GACAA,EAAAswD,YAAAtuD,IAIAlE,EAAA,SAAAkC,EAAAgC,GACAA,GAAAhC,GAAAgC,EAAAwnD,aAAAxpD,GACAA,EAAAu0D,YAAAvyD,IAIA+5E,EAAA,SAAA/+D,EAAAna,EAAAqE,GAEA,OAAA8P,WAAAgG,IAAA,GAAAu+D,GAAAvkE,WAAAnU,IAAA,GAAA24E,EAAAt0E,GAGAg9B,EAAA,SAAAt0B,EAAAy0B,GACA,MAAA,gBAAAz0B,GACAA,EAAA00B,YAAA,MAAA,EACAttB,WAAApH,GAAA,IAAAy0B,EAGArtB,WAAApH,GAGAA,GAOAosE,EAAA,SAAA31E,EAAA+F,EAAA1I,GACA,GAAAowB,GAAAltB,EAAAqlB,MAAA7f,EACA1I,IAAAA,EAEAuT,MAAAvT,KACAA,EAAA,GAGAowB,IACAztB,EAAA+F,MAAAyvE,EAAA/nD,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACAztB,EAAA3C,QAAAA,EAAAowB,EAAA,KAIAmoD,EAAA,SAAA7vE,GACA,GAAA0nB,GAAAltB,EAAAqlB,MAAA7f,EACA,QAAAyvE,EAAA/nD,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAAAA,EAAA,KAGAooD,EAAA,SAAA71E,EAAAzF,EAAAu7E,GAEA,GAAAx5E,GAAA/B,EAAA+B,IAEA,IAAA,MAAAA,EAEA,GAAAA,YAAAkE,GAAA,CACA,GAAAu1E,GACAtqC,EAAA,EACAuqC,GAAA,EAAA,GAEAtlE,EAAA,EAEAulE,EAAA,EACAlyE,EAAA+xE,EAAA1xE,kBACA8xE,EAAAnyE,EAAA3H,MACA+5E,EAAApyE,EAAA1H,MAEA,IAAA,WAAAC,EAAA5D,KAAA,CACAq9E,EAAA,UACA,IAAA1uE,GAAAyuE,EAAAzuE,UACAob,GAAAnmB,EAAAU,EAAAk5E,EAAA55E,EAAAW,EAAAk5E,GACAzzD,GAAApmB,EAAAuB,GAAAq4E,EAAA55E,EAAAwB,GAAAq4E,EAEA9uE,KACA1C,EAAA8d,EAAAA,EAAApb,GACA1C,EAAA+d,EAAAA,EAAArb,GAGA,IAAAgU,GAAAqH,EAAA,GAAAD,EAAA,GACAnH,EAAAoH,EAAA,GAAAD,EAAA,EACAgpB,GAAA,IAAAnpC,KAAA2b,MAAA5C,EAAAC,GAAAhZ,KAAAoM,GAEA+8B,EAAA,IACAA,GAAA,KAKAA,EAAA,OACAA,EAAA,OAES,CACTsqC,EAAA,gBACA,IAAAtzD,IAAAnmB,EAAAU,EAAAk5E,EAAA55E,EAAAW,EAAAk5E,GACA9uE,EAAAyuE,EAAAzuE,UACAtK,EAAA+4E,EAAA/4E,MACAX,EAAA85E,EACA75E,EAAA85E,CACAH,KACAvzD,EAAA,GAAA1e,EAAA/G,GAAAZ,GAAAqmB,EAAA,GAAA1e,EAAA9G,GAAAZ,GAEAgL,GACA1C,EAAA8d,EAAAA,EAAApb,GAGAjL,GAAAW,EAAA,GAAAqU,EACA/U,GAAAU,EAAA,GAAAqU,CACA,IAAAglE,GAAAt0C,EAAA1lC,EAAAC,EACAqU,GAAA,EAAA0lE,EACAH,EAAA,EAAA35E,EAAAsb,EAAAw+D,EAAA1lE,EAKA,GAAA2lE,GAAA/5E,EAAA+W,WAAAxH,OACAwqE,GAAA/wD,KAAA,SAAAgxD,EAAAC,GACA,MAAAD,GAAAz7D,OAAA07D,EAAA17D,QAOA,KAAA,GALAphB,GAAA48E,EAAA58E,OAEA+8E,KACA1oD,KAEAt0B,EAAA,EAAuBA,EAAAC,EAAYD,IAAA,CACnC,GAAAkoB,GAAA20D,EAAA78E,GACAi9E,EAAAb,EAAAl0D,EAAA3b,MACA+nB,GAAAzyB,KAAAqmB,EAAA7G,OAAAo7D,EAAAvlE,EAAA,IAAA+lE,EAAA,IAEA,IAAAj9E,GAAAA,IAAAC,EAAA,GACA+8E,EAAAn7E,KAAAo7E,GAIA,GAAAh9E,GAAA,EAAA,CACA,GAAAi9E,GAAAF,EAAA,GAAA,GACAG,EAAAH,EAAA,GAAA,GACAI,EAAAJ,EAAA,GAAA,GAAAj8E,EAAA8C,QACAw5E,EAAAL,EAAA,GAAA,GAAAj8E,EAAA8C,OACA2C,GAAAtH,KAAAq9E,EACA/1E,EAAA2a,OAAA,OACA3a,EAAAg2E,MAAA,OACAh2E,EAAAyrC,MAAAA,EACAzrC,EAAA+F,MAAA2wE,EACA12E,EAAA22E,OAAAA,EACA32E,EAAA8tB,OAAAA,EAAA1J,KAAA,KAGApkB,EAAA3C,QAAAw5E,EAEA72E,EAAA62E,SAAAD,EAGA,WAAAb,IACA/1E,EAAA82E,cAAAd,EAAA5xD,KAAA,UAIAuxD,GAAA31E,EAAA1D,EAAA/B,EAAA8C,UAKA05E,EAAA,SAAA/2E,EAAAzF,GAUA,MAAAA,EAAAwD,WACAiC,EAAAg3E,UAAAz8E,EAAAwD,SAAAqmB,KAAA,MAGA,MAAA7pB,EAAA4F,QAAA5F,EAAA4F,iBAAAK,IACAm1E,EAAA31E,EAAAzF,EAAA4F,OAAA5F,EAAA8C,UAIA45E,EAAA,SAAAC,EAAAx+E,EAAA6B,EAAAu7E,GACA,GAAAqB,GAAA,QAAAz+E,EACAsH,EAAAk3E,EAAAE,qBAAA1+E,GAAA,EAEA,OAAA6B,EAAA7B,IAAA,SAAA6B,EAAA7B,KAAAy+E,IAAAA,GAAA58E,EAAA0K,YACAiyE,EAAAC,EAAA,SAAA,WAAA,OAEA58E,EAAA7B,YAAA8H,IACA/I,EAAAy/E,EAAAl3E,GAGAA,IACAA,EAAA80E,EAAAzB,WAAA36E,IAGAy+E,EAAAtB,EAAA71E,EAAAzF,EAAAu7E,GAAAiB,EAAA/2E,EAAAzF,GACAk7E,EAAAyB,EAAAl3E,KAEAk3E,EAAAC,EAAA,SAAA,WAAA,QACA1/E,EAAAy/E,EAAAl3E,KAIA+qC,aAEAssC,EAAA,SAAApzE,EAAAlQ,GACA,GAMAu5C,GACAgqC,EACA9oE,EACAhV,EACA6tC,EACAC,EAXAt2B,EAAAV,EAAAU,EACAC,EAAAX,EAAAW,EACAF,EAAAT,EAAAS,EACAI,EAAAb,EAAAa,EACAD,EAAAZ,EAAAY,EACAX,KAOAxG,EAAA9F,EAAA8F,KACAwtE,EAAAtzE,EAAAkE,KAEA,KAAA3O,EAAA,EAAeA,EAAA+9E,GAAgB,CAK/B,OAJA/oE,EAAAzE,EAAAvQ,KACA89E,EAAA,GACAhqC,EAAA,EAEA9+B,GACA,IAAAwC,GACAsmE,EAAA,MACAhqC,EAAA,EACAjG,EAAAt9B,EAAAvQ,KACA8tC,EAAAv9B,EAAAvQ,KACAuxC,EAAA,GAAA,GAAA1D,EACA0D,EAAA,GAAA,GAAAzD,CACA,MAEA,KAAAv2B,GACAumE,EAAA,MACAhqC,EAAA,EACAjG,EAAAt9B,EAAAvQ,KACA8tC,EAAAv9B,EAAAvQ,KACAuxC,EAAA,GAAA,GAAA1D,EACA0D,EAAA,GAAA,GAAAzD,CACA,MAEA,KAAAp2B,GACA,IAAAD,GACAqmE,EAAA,MACAhqC,EAAA,CACA,IAIA5H,GACAC,EALAhoC,EAAAoM,EAAAvQ,KACAoE,EAAAmM,EAAAvQ,KACAqE,EAAAkM,EAAAvQ,KACAsE,EAAAiM,EAAAvQ,IAIAgV,KAAA0C,GAEAw0B,EAAA7nC,EACA8nC,EAAA7nC,EACAD,GAAAA,EAAA,EAAAF,GAAA,EACAG,GAAAA,EAAA,EAAAF,GAAA,EACAD,GAAA0pC,EAAA,EAAA1pC,GAAA,EACAC,GAAA0pC,EAAA,EAAA1pC,GAAA,IAEA8nC,EAAA37B,EAAAvQ,KACAmsC,EAAA57B,EAAAvQ,MAGAuxC,EAAA,GAAA,GAAAptC,EACAotC,EAAA,GAAA,GAAAntC,EACAmtC,EAAA,GAAA,GAAAltC,EACAktC,EAAA,GAAA,GAAAjtC,EACAitC,EAAA,GAAA,GAAArF,EACAqF,EAAA,GAAA,GAAApF,EACA0B,EAAA3B,EACA4B,EAAA3B,CACA,MAEA,KAAAx0B,GACA,GAAAnU,GAAA,EACAC,EAAA,EACA8gB,EAAA,EACAC,EAAA,EACAytB,EAAA,CAEA13C,KAEAiJ,EAAAjJ,EAAA,GACAkJ,EAAAlJ,EAAA,GACAgqB,EAAA1L,EAAAte,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACAiqB,EAAA3L,EAAAte,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACA03C,EAAAnpC,KAAA2b,OAAAlqB,EAAA,GAAAiqB,EAAAjqB,EAAA,GAAAgqB,GAGA,IAAAzZ,GAAAyF,EAAAvQ,KACA+K,EAAAwF,EAAAvQ,KACA6U,EAAAtE,EAAAvQ,KACA8U,EAAAvE,EAAAvQ,KACAusC,EAAAh8B,EAAAvQ,KAAAiyC,EACAzF,EAAAj8B,EAAAvQ,KAAAusC,EAAA0F,CAGAjyC,IACA,IAAAw2C,GAAAjmC,EAAAvQ,KACA4sC,EAAA9hC,EAAAiO,EAAAwzB,GAAA13B,EACAg4B,EAAA9hC,EAAA+N,EAAAyzB,GAAAz3B,EACA3Q,EAAA2G,EAAAiO,EAAAyzB,GAAA33B,EACAzQ,EAAA2G,EAAA+N,EAAA0zB,GAAA13B,EACA5V,EAAAs3C,EAAA,OAAA,MAEA1tC,MAAAoF,IAAA0+B,EAAAzoC,GAAA,OAEA2E,KAAAoF,IAAAs+B,EAAAD,GAAA,IAGAiK,IACA5J,GAAA,IAAAh1B,GAIA9O,KAAAoF,IAAA2+B,EAAA9hC,GAAA,KACAyrC,GAAA5J,EAAA9hC,IAAA0rC,GAAA5J,EAAA9hC,EACA1G,GAAA,IAAAwT,EAEAxT,GAAA,IAAAwT,EAEe4+B,GAAA3J,EAAA9hC,IAAAyrC,GAAA3J,EAAA9hC,EACf5G,GAAA,IAAAyT,EAEAzT,GAAA,IAAAyT,GAKAb,EAAAlV,KAAA3C,EAAA2J,IAAAiC,EAAA+J,GAAA0P,EAAA/gB,GAAAoU,EAAA6jE,GAAAF,EAAA1yE,IAAAkC,EAAA+J,GAAA0P,EAAA/gB,GAAAmU,EAAA6jE,GAAAF,EAAA1yE,IAAAiC,EAAA+J,GAAA0P,EAAA/gB,GAAAoU,EAAA6jE,GAAAF,EAAA1yE,IAAAkC,EAAA+J,GAAA0P,EAAA/gB,GAAAmU,EAAA6jE,GAAAF,EAAA1yE,GAAA+jC,EAAAroB,EAAA/gB,GAAAoU,EAAA6jE,GAAAF,EAAA1yE,GAAAgkC,EAAAroB,EAAA/gB,GAAAmU,EAAA6jE,GAAAF,EAAA1yE,GAAA1E,EAAAogB,EAAA/gB,GAAAoU,EAAA6jE,GAAAF,EAAA1yE,GAAAzE,EAAAogB,EAAA/gB,GAAAmU,EAAA6jE,IACA5tC,EAAA1pC,EACA2pC,EAAA1pC,CACA,MAEA,KAAA0S,GAAAyc,EACA,GAAAtK,GAAAsoB,EAAA,GACAroB,EAAAqoB,EAAA,EAEAtoB,GAAA,GAAA1Y,EAAAvQ,KACAipB,EAAA,GAAA1Y,EAAAvQ,KAEAkpB,EAAA,GAAAD,EAAA,GAAA1Y,EAAAvQ,KACAkpB,EAAA,GAAAD,EAAA,GAAA1Y,EAAAvQ,KAEAzF,IACA4Q,EAAA8d,EAAAA,EAAA1uB,GACA4Q,EAAA+d,EAAAA,EAAA3uB,IAGA0uB,EAAA,GAAApgB,EAAAogB,EAAA,GAAArR,EAAA6jE,GACAvyD,EAAA,GAAArgB,EAAAqgB,EAAA,GAAAtR,EAAA6jE,GACAxyD,EAAA,GAAApgB,EAAAogB,EAAA,GAAArR,EAAA6jE,GACAvyD,EAAA,GAAArgB,EAAAqgB,EAAA,GAAAtR,EAAA6jE,GACA1kE,EAAAlV,KACA,MAAAonB,EAAA,GAAAsyD,EAAAtyD,EAAA,GACA,MAAAC,EAAA,GAAAqyD,EAAAtyD,EAAA,GACA,MAAAC,EAAA,GAAAqyD,EAAAryD,EAAA,GACA,MAAAD,EAAA,GAAAsyD,EAAAryD,EAAA,GACA,MAEA,KAAApS,GAAAc,EAEAb,EAAAlV,KAAA,OAGA,GAAAiyC,EAAA,EAAA,CACA/8B,EAAAlV,KAAAi8E,EAEA,KAAA,GAAAtuD,GAAA,EAAuBA,EAAAskB,EAAYtkB,IAAA,CACnC,GAAA/0B,GAAA82C,EAAA/hB,EACAj1B,IAAA4Q,EAAA1Q,EAAAA,EAAAF,GAEAwc,EAAAlV,KAAAgH,EAAApO,EAAA,GAAAmd,EAAA6jE,GAAAF,EAAA1yE,EAAApO,EAAA,GAAAmd,EAAA6jE,GAAAjsD,EAAAskB,EAAA,EAAAynC,EAAA,MAKA,MAAAxkE,GAAA6T,KAAA,IAIA7hB,GAAA3L,UAAA4gF,SAAA,SAAAC,GACA,GAAAl9E,GAAAhH,KAAAgH,MACA28E,EAAA3jF,KAAAmkF,MAEAR,KACAA,EAAApC,EAAAzB,WAAA,SACA+B,EAAA8B,GACA3jF,KAAAmkF,OAAAR,GAGAD,EAAAC,EAAA,OAAA38E,EAAAhH,MACA0jF,EAAAC,EAAA,SAAA38E,EAAAhH,KACA,IAAAQ,GAAAR,KAAA8T,UACAswE,EAAA,MAAA5jF,EACA6jF,EAAAV,EAAAE,qBAAA,UAAA,EAEA,IAAAQ,EAAA,CACA,GAAA3yE,GAAA1K,EAAA0K,SAKA,IAAA0yE,IAAAp9E,EAAA2a,cAAA,CACA,GAAA0K,GAAA7rB,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,EACAkR,IAAAoN,EAAA3K,EAAAkY,IAGAg4D,EAAAC,OAAA5yE,EAAA,KAGA,GAAAhB,GAAA1Q,KAAA0Q,OAAA1Q,KAAA0Q,KAAA,GAAAoM,GAEA9c,MAAA2e,cACAjO,EAAAoQ,YACA9gB,KAAAie,UAAAvN,EAAA1Q,KAAAmE,OACAuM,EAAAoN,WACA9d,KAAA2e,aAAA,GAGAglE,EAAAjzE,KAAAozE,EAAApzE,EAAA1Q,KAAA8T,WACA6vE,EAAA38E,MAAAu9E,OAAApC,EAAAniF,KAAAojB,OAAApjB,KAAAiJ,EAAAjJ,KAAAsN,IAEA40E,EAAAgC,EAAAP,GAEA,MAAA38E,EAAAkE,KACAlL,KAAAihB,aAAAijE,EAAAlkF,KAAA6Q,mBAEA7Q,KAAAwkF,eAAAN,IAIAl1E,EAAA3L,UAAAohF,SAAA,SAAAP,GACAhgF,EAAAggF,EAAAlkF,KAAAmkF,QACAnkF,KAAAwkF,eAAAN,IAGAl1E,EAAA3L,UAAAqhF,MAAA,SAAAR,GACAhC,EAAAgC,EAAAlkF,KAAAmkF,QACAnkF,KAAA2kF,eAAAT,GAOA,IAAAU,GAAA,SAAAvF,GAEA,MAAA,gBAAAA,IAAAA,EAAAwF,SAAA,QAAAxF,EAAAwF,QAAAnvB,cAIAxZ,GAAA74C,UAAA4gF,SAAA,SAAAC,GACA,GAGAY,GACAC,EAJA/9E,EAAAhH,KAAAgH,MACA2C,EAAA3C,EAAA2C,KAKA,IAAAi7E,EAAAj7E,GAAA,CACA,GAAAymC,GAAAzmC,EAAAymC,GAEA,IAAAA,IAAApwC,KAAAglF,UACAF,EAAA9kF,KAAAilF,YACAF,EAAA/kF,KAAAklF,iBACO,CACP,GAAAC,GAAAx7E,EAAAy7E,aACAC,EAAAF,EAAAt8E,MACAy8E,EAAAH,EAAAr8E,MACAq8E,GAAAt8E,MAAA,OACAs8E,EAAAr8E,OAAA,OAEAg8E,EAAAn7E,EAAAd,MACAk8E,EAAAp7E,EAAAb,OAEAq8E,EAAAt8E,MAAAw8E,EACAF,EAAAr8E,OAAAw8E,EAEAtlF,KAAAglF,UAAA50C,EACApwC,KAAAilF,YAAAH,EACA9kF,KAAAklF,aAAAH,EAGAp7E,EAAAymC,MAEAzmC,KAAA3J,KAAAglF,YACAF,EAAA9kF,KAAAilF,YACAF,EAAA/kF,KAAAklF,aAIA,IAAAv7E,EAAA,CAIA,GAAAF,GAAAzC,EAAAyC,GAAA,EACAC,EAAA1C,EAAA0C,GAAA,EACA67E,EAAAv+E,EAAA6B,MACA28E,EAAAx+E,EAAA8B,OACA28E,EAAAz+E,EAAAo1C,OACAspC,EAAA1+E,EAAAq1C,QACA7xB,EAAAxjB,EAAAwjB,IAAA,EACAC,EAAAzjB,EAAAyjB,IAAA,EACAk7D,EAAAF,GAAAC,EACA/B,EAAA3jF,KAAAmkF,MAEAR,KAGAA,EAAApC,EAAAqE,IAAAn9E,cAAA,OACAo5E,EAAA8B,GACA3jF,KAAAmkF,OAAAR,EAGA,IAEAnjF,GAFAqlF,EAAAlC,EAAA38E,MACA8+E,GAAA,EAEAxxC,EAAA,EACAC,EAAA,CASA,IAPAv0C,KAAA8T,YACAtT,EAAAR,KAAA8T,UACAwgC,EAAAx1B,EAAAte,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACA+zC,EAAAz1B,EAAAte,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACAslF,EAAAtlF,EAAA,IAAAA,EAAA,IAGAslF,EAAA,CAMA,GAAA52D,IAAAzlB,EAAAC,GACAylB,GAAA1lB,EAAA87E,EAAA77E,GACAwmB,GAAAzmB,EAAAC,EAAA87E,GACAr1D,GAAA1mB,EAAA87E,EAAA77E,EAAA87E,EACAp0E,GAAA8d,EAAAA,EAAA1uB,GACA4Q,EAAA+d,EAAAA,EAAA3uB,GACA4Q,EAAA8e,EAAAA,EAAA1vB,GACA4Q,EAAA+e,EAAAA,EAAA3vB,EACA,IAAAsuC,GAAAP,EAAArf,EAAA,GAAAC,EAAA,GAAAe,EAAA,GAAAC,EAAA,IACA4e,EAAAR,EAAArf,EAAA,GAAAC,EAAA,GAAAe,EAAA,GAAAC,EAAA,IACA41D,IACAA,GAAAj+E,KAAA,OAAAtH,EAAA,GAAA8zC,EAAAktC,EAAA,OAAAhhF,EAAA,GAAA+zC,EAAAitC,EAAA,OAAAhhF,EAAA,GAAA8zC,EAAAktC,EAAA,OAAAhhF,EAAA,GAAA+zC,EAAAitC,EAAA,MAAA1yE,EAAArF,EAAA6qC,EAAA9zC,EAAA,IAAAghF,EAAA,MAAA1yE,EAAApF,EAAA6qC,EAAA/zC,EAAA,KACAqlF,EAAAp5C,QAAA,KAAA39B,EAAAggC,GAAA,MAAAhgC,EAAAigC,GAAA,OAEA82C,EAAA5uE,OAAAwqE,EAAA,WAAAsE,EAAAl1D,KAAA,IAAA,2BAEArwB,KACAiJ,EAAAA,EAAA6qC,EAAA9zC,EAAA,GACAkJ,EAAAA,EAAA6qC,EAAA/zC,EAAA,IAGAqlF,EAAA5uE,OAAA,GACA4uE,EAAAl7C,KAAA77B,EAAArF,GAAA,KACAo8E,EAAA/6C,IAAAh8B,EAAApF,GAAA,IAGA,IAAAs8E,GAAAhmF,KAAAimF,SACAC,EAAAlmF,KAAAmmF,OAEAH,KACAA,EAAAzE,EAAAqE,IAAAn9E,cAAA,OACAzI,KAAAimF,SAAAD,EAGA,IAAAI,GAAAJ,EAAAh/E,KAEA,IAAA2+E,EAAA,CAEA,GAAAb,GAAAC,EAmBAqB,EAAAv9E,MAAAiG,EAAAwlC,EAAAwwC,EAAAS,EAAAE,GAAA,KACAW,EAAAt9E,OAAAgG,EAAAylC,EAAAwwC,EAAAS,EAAAE,GAAA,SApBA,CACA,GAAAW,GAAA,GAAA/8E,OACAyqB,EAAA/zB,IAEAqmF,GAAAp2C,OAAA,WACAo2C,EAAAp2C,OAAA,KACA60C,EAAAuB,EAAAx9E,MACAk8E,EAAAsB,EAAAv9E,OAEAs9E,EAAAv9E,MAAAiG,EAAAwlC,EAAAwwC,EAAAS,EAAAE,GAAA,KACAW,EAAAt9E,OAAAgG,EAAAylC,EAAAwwC,EAAAS,EAAAE,GAAA,KAEA3xD,EAAAkxD,YAAAH,EACA/wD,EAAAmxD,aAAAH,EACAhxD,EAAAixD,UAAAr7E,GAGA08E,EAAAj2C,IAAAzmC,EAMAu8E,IACAA,EAAA3E,EAAAqE,IAAAn9E,cAAA,OACAy9E,EAAAl/E,MAAAs/E,SAAA,SACAtmF,KAAAmmF,QAAAD,EAGA,IAAAK,GAAAL,EAAAl/E,KACAu/E,GAAA19E,MAAAiG,GAAAy2E,EAAA/6D,EAAA+6D,EAAAE,GAAAnxC,GACAiyC,EAAAz9E,OAAAgG,GAAA02E,EAAA/6D,EAAA+6D,EAAAE,GAAAnxC,GACAgyC,EAAAtvE,OAAAwqE,EAAA,eAAAj3D,EAAA+6D,EAAAE,EAAAnxC,EAAA,QAAA7pB,EAAA+6D,EAAAE,EAAAnxC,EAAA,IAEA2xC,EAAAt2B,YACA+zB,EAAAjtB,YAAAwvB,GAGAF,EAAAp2B,YAAAs2B,GACAA,EAAAxvB,YAAAsvB,OAGAI,GAAAv9E,MAAAiG,EAAAwlC,EAAAixC,GAAA,KACAa,EAAAt9E,OAAAgG,EAAAylC,EAAAixC,GAAA,KACA7B,EAAAjtB,YAAAsvB,GAEAE,GAAAA,EAAAt2B,aACA+zB,EAAAhpB,YAAAurB,GACAlmF,KAAAmmF,QAAA,KAIA,IAAAK,GAAA,GACAxtD,EAAAhyB,EAAA8C,OAEAkvB,GAAA,IACAwtD,GAAA,kBAAA13E,EAAA,IAAAkqB,GAAA,MAGAwtD,GAAA/E,EAAA,yBAAA93E,EAAA,wBACAy8E,EAAAnvE,OAAAuvE,EACA7C,EAAA38E,MAAAu9E,OAAApC,EAAAniF,KAAAojB,OAAApjB,KAAAiJ,EAAAjJ,KAAAsN,IAEA40E,EAAAgC,EAAAP,GAEA,MAAA38E,EAAAkE,MACAlL,KAAAihB,aAAAijE,EAAAlkF,KAAA6Q,qBAIAqrC,EAAA74C,UAAAohF,SAAA,SAAAP,GACAhgF,EAAAggF,EAAAlkF,KAAAmkF,QACAnkF,KAAAmkF,OAAA,KACAnkF,KAAAmmF,QAAA,KACAnmF,KAAAimF,SAAA,KACAjmF,KAAAwkF,eAAAN,IAGAhoC,EAAA74C,UAAAqhF,MAAA,SAAAR,GACAhC,EAAAgC,EAAAlkF,KAAAmkF,QACAnkF,KAAA2kF,eAAAT,GAOA,IAsCAuC,GAtCAC,EAAA,SACAC,KACAC,EAAA,EACAC,EAAA,IACAC,EAAAt+E,SAAAC,cAAA,OAEAs+E,EAAA,SAAAC,GACA,GAAApiE,GAAA+hE,EAAAK,EAEA,KAAApiE,EAAA,CAEAgiE,EAAAC,IACAD,EAAA,EACAD,KAGA,IACA5hE,GADA/d,EAAA8/E,EAAA9/E,KAGA,KACAA,EAAA2d,KAAAqiE,EACAjiE,EAAA/d,EAAA+d,WAAApI,MAAA,KAAA,GACO,MAAA3Y,IAEP4gB,GACA5d,MAAAA,EAAA4d,WAAA8hE,EACAO,QAAAjgF,EAAAkgF,aAAAR,EACApC,OAAAt9E,EAAA6d,YAAA6hE,EACA3f,KAAA,EAAA3pD,WAAApW,EAAA8d,UAAA,IACAqiE,OAAApiE,GAAA,mBAEA4hE,EAAAK,GAAApiE,EACAgiE,IAGA,MAAAhiE,GAKAtV,GAAA+E,UAAA,cAAA,SAAAnJ,EAAA6H,GACA,GAAA6yE,GAAArE,EAAAqE,GAEAa,KACAA,EAAAb,EAAAn9E,cAAA,OACAg+E,EAAAz/E,MAAAouD,QAAA,wFACAmsB,EAAAqE,IAAAwB,KAAA1wB,YAAA+vB,GAGA,KACAA,EAAAz/E,MAAA2d,KAAA5R,EACK,MAAAs0E,IAML,MAHAZ,GAAA3wB,UAAA,GAEA2wB,EAAA/vB,YAAAkvB,EAAA0B,eAAAp8E,KAEArC,MAAA49E,EAAAc,cAmMA,KAAA,GAhMArhD,GAAA,GAAAl2B,GAEAiR,GAAA,SAAAijE,EAAA1zE,EAAA8U,EAAAkiE,GACA,GAAAxgF,GAAAhH,KAAAgH,KAEAhH,MAAAmgB,SAAA8lB,EAAAE,mBAAAn/B,GAAA,EACA,IAAAkE,GAAAlE,EAAAkE,IAIA,IAFA,MAAAA,IAAAA,GAAA,IAEAA,EAAA,CAMA,GAAAlE,EAAA0f,KAAA,CACA,GAAAwgB,GAAA53B,EAAAu5B,cAAA39B,EAAAlE,EACAkE,KAEA,KAAA,GAAAjF,GAAA,EAAqBA,EAAAihC,EAAAK,MAAArhC,OAA+BD,IAAA,CAIpD,IAAA,GAHAojC,GAAAnC,EAAAK,MAAAthC,GAAAojC,OACA8C,KAEApkC,EAAA,EAAuBA,EAAAshC,EAAAnjC,OAAmB6B,IAC1CokC,EAAArkC,KAAAuhC,EAAAthC,GAAAmD,KAGAA,GAAApD,KAAAqkC,EAAAtb,KAAA,KAGA3lB,EAAAA,EAAA2lB,KAAA,MAGA,GAAApnB,GACAC,EACA+9E,EAAAzgF,EAAAwe,UACAkiE,EAAA1gF,EAAAye,kBACAb,EAAAmiE,EAAA//E,EAAA2d,MAEAA,EAAAC,EAAA5d,MAAA,IAAA4d,EAAAqiE,QAAA,IAAAriE,EAAA0/D,OAAA,IAAA1/D,EAAAmiD,KAAA,OAAAniD,EAAAuiE,OAAA,GACA7hE,GAAAA,GAAAhW,EAAAuB,gBAAA3F,EAAAyZ,EAAA8iE,EAAAC,EAEA,IAAAlnF,GAAAR,KAAA8T,SAQA,IANAtT,IAAAgnF,IACAthD,EAAA1kB,KAAAhR,GACA01B,EAAA90B,eAAA5Q,GACAgQ,EAAA01B,GAGAshD,EAiBA/9E,EAAA+G,EAAA/G,EACAC,EAAA8G,EAAA9G,MAlBA,CACA,GAAAuJ,GAAAjM,EAAAiM,aACAga,EAAAjmB,EAAA8L,YAEA,IAAAG,YAAAqH,OACA7Q,EAAA+G,EAAA/G,EAAA6gC,EAAAr3B,EAAA,GAAAzC,EAAA3H,OACAa,EAAA8G,EAAA9G,EAAA4gC,EAAAr3B,EAAA,GAAAzC,EAAA1H,QACA2+E,EAAAA,GAAA,WACO,CACP,GAAAl9C,GAAAj7B,EAAAk7B,yBAAAv3B,EAAAzC,EAAAyc,EACAxjB,GAAA8gC,EAAA9gC,EACAC,EAAA6gC,EAAA7gC,EAEA+9E,EAAAA,GAAAl9C,EAAA/kB,UACAkiE,EAAAA,GAAAn9C,EAAA9kB,mBAOAhc,EAAA6F,EAAAg5B,YAAA7+B,EAAA6b,EAAAzc,MAAA4+E,GACA/9E,EAAA4F,EAAAy4B,YAAAr+B,EAAA4b,EAAAxc,OAAA4+E,GAEAh+E,GAAA4b,EAAAxc,OAAA,CAoCA,IAEA2V,GACAkpE,EACAC,EAJA9H,EAAAyB,EAAAzB,WACA+H,EAAA7nF,KAAA8nF,UAKAD,IAmBAD,EAAAC,EAAAhuB,WACAp7C,EAAAmpE,EAAArsC,YACAosC,EAAAlpE,EAAA88B,cApBAssC,EAAA/H,EAAA,QACArhE,EAAAqhE,EAAA,QACA6H,EAAA7H,EAAA,YACA8H,EAAA9H,EAAA,QAGA6H,EAAA3gF,MAAA,gBAAA,OACA66E,EAAAgG,GACAppE,EAAAspE,YAAA,EACAJ,EAAA7iF,IAAA,EACA+iF,EAAA7yE,KAAA,MACA6yE,EAAAG,GAAA,YACA9F,EAAA2F,EAAAD,GACA1F,EAAA2F,EAAAppE,GACAyjE,EAAA2F,EAAAF,GACA3nF,KAAA8nF,WAAAD,EAQA,IAAAI,IAAAx+E,EAAAC,GACAw+E,EAAAL,EAAA7gF,KAEAxG,IAAAgnF,GACAp2E,EAAA62E,EAAAA,EAAAznF,GACAonF,EAAA9iF,IAAA,EACA8iF,EAAA34E,OAAAzO,EAAA,GAAA2nF,QAAA,GAAA3G,EAAAhhF,EAAA,GAAA2nF,QAAA,GAAA3G,EAAAhhF,EAAA,GAAA2nF,QAAA,GAAA3G,EAAAhhF,EAAA,GAAA2nF,QAAA,GAAA,OAEAP,EAAAtgE,QAAAxY,EAAAm5E,EAAA,KAAA,GAAA,KAAAn5E,EAAAm5E,EAAA,KAAA,GAEAL,EAAA59D,OAAA,MACAk+D,EAAAv9C,KAAA,MACAu9C,EAAAp9C,IAAA,QAEA88C,EAAA9iF,IAAA,EACAojF,EAAAv9C,KAAA77B,EAAArF,GAAA,KACAy+E,EAAAp9C,IAAAh8B,EAAApF,GAAA,MAGAi+E,EAAAS,OAAApG,EAAA92E,EAEA,KACAy8E,EAAA3gF,MAAA2d,KAAAA,EAEA,MAAA3gB,IAEA0/E,EAAAmE,EAAA,QACA9+E,KAAA/B,EAAAkM,SACApJ,QAAA9C,EAAA8C,SACK9J,MACL0jF,EAAAmE,EAAA,UACAj7E,OAAA5F,EAAAie,WACAnb,QAAA9C,EAAA8C,QACAU,SAAAxD,EAAAwD,UACKxK,MACL6nF,EAAA7gF,MAAAu9E,OAAApC,EAAAniF,KAAAojB,OAAApjB,KAAAiJ,EAAAjJ,KAAAsN,IAEA40E,EAAAgC,EAAA2D,KAGArD,GAAA,SAAAN,GACAhgF,EAAAggF,EAAAlkF,KAAA8nF,YACA9nF,KAAA8nF,WAAA,MAGAnD,GAAA,SAAAT,GACAhC,EAAAgC,EAAAlkF,KAAA8nF,aAGApiD,IAAAxiB,EAAA/D,EAAA+8B,EAAAltC,EAAAK,GAEApJ,GAAA,EAAiBA,GAAAy/B,GAAAx/B,OAAiBD,KAAA,CAClC,GAAAijD,IAAAxjB,GAAAz/B,IAAA5C,SACA6lD,IAAAjoC,aAAAA,GACAioC,GAAAs7B,eAAAA,GACAt7B,GAAAy7B,eAAAA,GAGAt1E,EAAAhM,UAAA4gF,SAAA,SAAAC,GACA,GAAAl9E,GAAAhH,KAAAgH,KAEA,OAAAA,EAAAkE,KACAlL,KAAAihB,aAAAijE,GACAz6E,EAAAzC,EAAAyC,GAAA,EACAC,EAAA1C,EAAA0C,GAAA,EACAb,MAAA,EACAC,OAAA,GACO9I,KAAA6Q,mBAAA,GAEP7Q,KAAAwkF,eAAAN,IAIA70E,EAAAhM,UAAAohF,SAAA,SAAAP,GACAlkF,KAAAwkF,eAAAN,IAGA70E,EAAAhM,UAAAqhF,MAAA,SAAAR,GACAlkF,KAAA2kF,eAAAT,MnG8orBM,SAAUrkF,EAAQD,EAASM,GoGzntBjC,QAAA4/E,GAAA+E,GACA,MAAAwD,GAAAxD,GAqBA,QAAAyD,KACA,IAAAC,GAAA3C,EAAA,CAIA2C,GAAA,CACA,IAAAC,GAAA5C,EAAA4C,WAEAA,GAAAtiF,OAAA,GACA0/E,EAAA6C,mBAAAC,QAAA,SAAA,8BAGAF,EAAA,GAAAE,QAAA,SAAA,+BAzCA,GAYAL,GAZAxrC,EAAA38C,EAAA,IAEAyoF,EAAA,gCACAC,EAAA,mBAAA5iD,QAAA,KAAAA,OACAuiD,GAAA,EACA3C,EAAAgD,GAAAA,EAAApgF,QASA,IAAAo9E,IAAA/oC,EAAAc,gBACA,KACAioC,EAAAiD,WAAAC,OAAAlD,EAAAiD,WAAAjkF,IAAA,QAAA+jF,GAEAN,EAAA,SAAAxD,GACA,MAAAe,GAAAn9E,cAAA,UAAAo8E,EAAA,oBAEG,MAAA7gF,GACHqkF,EAAA,SAAAxD,GACA,MAAAe,GAAAn9E,cAAA,IAAAo8E,EAAA,WAAA8D,EAAA,qBAsBA/oF,EAAAgmF,IAAAA,EACAhmF,EAAAkgF,WAAAA,EACAlgF,EAAA0oF,QAAAA,GpGsotBM,SAAUzoF,EAAQD,EAASM,GqGxqtBjC,QAAAq0D,GAAA97C,GACA,MAAAxO,UAAAwO,EAAA,IAOA,QAAAswE,GAAArpF,EAAA87C,GACA+lC,EAAA+G,UACAtoF,KAAAN,KAAAA,EACAM,KAAAw7C,QAAAA,CACA,IAAAwtC,GAAAxgF,SAAAC,cAAA,OACAy7E,EAAA17E,SAAAC,cAAA,MACAugF,GAAAhiF,MAAAouD,QAAA,mFACA8uB,EAAAl9E,MAAAouD,QAAA,kCACA11D,EAAAg3D,YAAAsyB,GACAhpF,KAAAipF,SAAA/E,EACAlkF,KAAAkpF,aAAAF,EACAhpF,KAAA8D,QAEA,IAAAqoD,GAAA3Q,EAAAG,eACAyQ,EAAA5Q,EAAAC,YAEAD,GAAAG,eAAA,SAAAlvC,GACA0/C,EAAA5rD,KAAAi7C,EAAA/uC,GAEAA,GACAA,EAAAg4E,UAAAh4E,EAAAg4E,SAAAP,IAIA1oC,EAAAC,aAAA,SAAAhvC,GAEAA,EAAAi4E,OAAAj4E,EAAAi4E,MAAAR,GACA93B,EAAA7rD,KAAAi7C,EAAA/uC,IAGAzM,KAAAmpF,aAAA,EAgHA,QAAAC,GAAAhiE,GACA,MAAA,YACAiiE,EAAA,iDAAAjiE,EAAA,MArKA,GAAAiiE,GAAAnpF,EAAA,IAEAqhF,EAAArhF,EAAA,IAEAytB,EAAAztB,EAAA,GAEAqM,EAAAohB,EAAAphB,IAgDAw8E,GAAA1lF,WACA0R,YAAAg0E,EACAjyB,QAAA,WACA,MAAA,OAMA/K,gBAAA,WACA,MAAA/rD,MAAAkpF,cAEAlyB,sBAAA,WACA,GAAAC,GAAAj3D,KAAA+rD,iBAEA,IAAAkL,EACA,OACAC,WAAAD,EAAAC,YAAA,EACAC,UAAAF,EAAAE,WAAA,IAQAh1C,QAAA,WACA,GAAAujB,GAAA1lC,KAAAw7C,QAAA0U,gBAAA,GAAA,EAEAlwD,MAAAq3D,WAAA3xB,IAEA2xB,WAAA,SAAA3xB,GAGA,IAAA,GAFAw+C,GAAAlkF,KAAAipF,SAEAhjF,EAAA,EAAmBA,EAAAy/B,EAAAx/B,OAAiBD,IAAA,CACpC,GAAAwG,GAAAi5B,EAAAz/B,EAEAwG,GAAA0W,WAAA1W,EAAAkb,QACAlb,EAAA68E,qBACA78E,EAAAg4E,SAAAP,GAIAz3E,EAAA68E,qBAAA,IAEA78E,EAAA68E,qBACA78E,EAAAi4E,MAAAR,GAGAz3E,EAAA68E,qBAAA,EAEA78E,EAAA0T,UACA1T,EAAAiX,aAAAjX,EAAAiX,eACAjX,EAAAw3E,UAAAx3E,EAAAgT,OAAAlf,KAAAkM,EAAAy3E,GACAz3E,EAAAkX,YAAAlX,EAAAkX,eAIAlX,EAAA0T,SAAA,EAGAngB,KAAAmpF,cAIAnpF,KAAAkpF,aAAAxyB,YAAAwtB,GAEAlkF,KAAAmpF,aAAA,IAGArlF,OAAA,SAAA+E,EAAAC,GACA,GAAAD,GAAA,MAAAA,EAAA7I,KAAAupF,YAAA1gF,EACAC,EAAA,MAAAA,EAAA9I,KAAAwpF,aAAA1gF,CAEA,IAAA9I,KAAAo2D,QAAAvtD,GAAA7I,KAAAq2D,SAAAvtD,EAAA,CACA9I,KAAAo2D,OAAAvtD,EACA7I,KAAAq2D,QAAAvtD,CACA,IAAA2gF,GAAAzpF,KAAAkpF,aAAAliF,KACAyiF,GAAA5gF,MAAAA,EAAA,KACA4gF,EAAA3gF,OAAAA,EAAA,OAGAlF,QAAA,WACA5D,KAAAN,KAAAo2D,UAAA,GACA91D,KAAAipF,SAAAjpF,KAAAkpF,aAAAlpF,KAAAw7C,QAAA,MAEAh4C,SAAA,WACA,MAAAxD,MAAAo2D,QAEA3yD,UAAA,WACA,MAAAzD,MAAAq2D,SAEA1wD,MAAA,WACA3F,KAAAkpF,cACAlpF,KAAAN,KAAAi7D,YAAA36D,KAAAkpF,eAGAK,UAAA,WACA,GAAA7pF,GAAAM,KAAAN,KACAk8D,EAAAl8D,EAAAgqF,YACA,QAAAhqF,EAAAiqF,aAAAp1B,EAAAqH,EAAA/yD,QAAA0rD,EAAAqH,EAAAguB,aAAAr1B,EAAAqH,EAAAiuB,cAAA,GAEAL,WAAA,WACA,GAAA9pF,GAAAM,KAAAN,KACAk8D,EAAAl8D,EAAAgqF,YACA,QAAAhqF,EAAAoqF,cAAAv1B,EAAAqH,EAAA9yD,SAAAyrD,EAAAqH,EAAAmuB,YAAAx1B,EAAAqH,EAAAouB,eAAA,IAWAz9E,GAAA,WAAA,cAAA,YAAA,mBAAA,iBAAA,YAAA,WAAA,WAAA,aAAA,YAAA,eAAA,SAAA7E,GACAqhF,EAAA1lF,UAAAqE,GAAA0hF,EAAA1hF,IAEA,IAAAob,GAAAimE,CACAlpF,GAAAD,QAAAkjB","file":"fish-topo-link.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fishTopoLink\"] = factory();\n\telse\n\t\troot[\"fishTopoLink\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fishTopoLink\"] = factory();\n\telse\n\t\troot[\"fishTopoLink\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Export fishTopo as CommonJS module\r\n\t */\r\n\tmodule.exports = __webpack_require__(2);\r\n\t//兼容IE8 引入VML 如果不需要兼容IE8请删除\r\n\t__webpack_require__(97);\r\n\t\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 流程对象\r\n\t * @class fish.topo.FishTopoLink\r\n\t */\r\n\t\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var util = __webpack_require__(63);\r\n\t    var Point = __webpack_require__(64);\r\n\t    var ExtensionAPI = __webpack_require__(66);\r\n\t    var Eventful = __webpack_require__(11);\r\n\t    var zrender = __webpack_require__(67);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var OperationNode = __webpack_require__(78);\r\n\t    var LinkConnectionManager = __webpack_require__(88);\r\n\t    var LinkUtil = __webpack_require__(92);\r\n\t    var Constants = __webpack_require__(91);\r\n\t    var Model = __webpack_require__(85);\r\n\t    var eventTool = __webpack_require__(75);\r\n\t    var Connector = __webpack_require__(80);\r\n\t    var LineOperationManager = __webpack_require__(93);\r\n\t    var Link = __webpack_require__(94);\r\n\t    var textContain = __webpack_require__(25);\r\n\t    var ImagePool = __webpack_require__(95);\r\n\t    __webpack_require__(96);\r\n\t    function FishTopoLink(dom, opts) {\r\n\t        this.id;\r\n\t        this.group;\r\n\t        this._dom = dom;\r\n\t        this.nowZoom = 1;\r\n\t        this.canScale = true;\r\n\t        this.eagleEye = false;\r\n\t        this.eagleEyeNode;\r\n\t        this.initScaleRatio;\r\n\t        this.operationNode;\r\n\t        this.selectedNode = null;\r\n\t        this.allNodes = [];\r\n\t        this.linkConnectionManager = new LinkConnectionManager();\r\n\t        this.lineOperationManager = new LineOperationManager(this.linkConnectionManager);\r\n\t        this.minimap;\r\n\t        this._layoutTimeout = null;\r\n\t        this._zr = zrender.init(dom, {\r\n\t            renderer: opts.renderer || 'canvas',\r\n\t            devicePixelRatio: opts.devicePixelRatio\r\n\t        });\r\n\t\r\n\t        this._api = new ExtensionAPI(this);\r\n\t        this.Shape = graphic;\r\n\t        this.model = new Model({});\r\n\t        this.model.set(Constants.ELEMENT_TYPE, \"scene\");\r\n\t        this.model.set(Constants.MODE, \"normal\");\r\n\t        this.options = opts;\r\n\t        Eventful.call(this);\r\n\t    }\r\n\t\r\n\t    var fishTopoProto = FishTopoLink.prototype;\r\n\t\r\n\t    /**\r\n\t     * 获取 fishTopo 实例容器的 dom 节点\r\n\t     * @return {HTMLElement}\r\n\t     */\r\n\t    fishTopoProto.getDom = function() {\r\n\t        return this._dom;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto.getZr = function() {\r\n\t        return this._zr;\r\n\t    };\r\n\t    /**\r\n\t     * 获取 fishTopo 实例容器的宽度。\r\n\t     * @return {number}\r\n\t     */\r\n\t    fishTopoProto.getWidth = function() {\r\n\t        return this._zr.getWidth();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 获取 fishTopo 实例容器的高度。\r\n\t     * @return {number}\r\n\t     */\r\n\t    fishTopoProto.getHeight = function() {\r\n\t        return this._zr.getHeight();\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 当前实例是否已经被释放。\r\n\t     * @return {boolean}\r\n\t     */\r\n\t    fishTopoProto.isDisposed = function() {\r\n\t        return this._disposed;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Dispose instance\r\n\t     */\r\n\t    fishTopoProto.dispose = function() {\r\n\t        this._disposed = true;\r\n\t\r\n\t        this._zr.dispose();\r\n\t\r\n\t        instances[this.id] = null;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 调整尺寸  在窗口大小发生改变时需要手工调用\r\n\t     * @param {number} width 宽度\r\n\t     * @param {number} height 高度\r\n\t     */\r\n\t    fishTopoProto.resize = function() {\r\n\t        this._zr.resize();\r\n\t\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 初始化\r\n\t     */\r\n\t    fishTopoProto.init = function() {\r\n\t        var that = this;\r\n\t        this.group = new graphic.Group();\r\n\t        this.group.isBg = true;\r\n\t        this._zr.add(this.group);\r\n\t        this.linkConnectionManager.connectors = [];\r\n\t        //mouseup 会在各个node或线的click事件之点执行  在选中节点或线前 先清空选中效果\r\n\t        this._zr.on(\"mouseup\", function(e) {\r\n\t            clearSelect(e);\r\n\t        });\r\n\t        that._zr.on(\"globalout\", function(e) {\r\n\t            clearSelect(e);\r\n\t        });\r\n\t        function clearSelect(e){\r\n\t            if (that.operationNode) {\r\n\t                that.group.remove(that.operationNode);\r\n\t                that.operationNode = null;\r\n\t            }\r\n\t            var shape = e.target;\r\n\t            if (shape && shape.model && Link.isLink(shape.model)) {\r\n\t                return;\r\n\t            }\r\n\t            if (shape && shape.connector instanceof Connector) {\r\n\t                return;\r\n\t            }\r\n\t            that.linkConnectionManager.clearSelectCon();\r\n\t            if (shape && shape.operation && shape.operation == true) {\r\n\t                return;\r\n\t            }\r\n\t            that.lineOperationManager.hideAllLineOperation();\r\n\t        }\r\n\t        this._zr.on(\"click\", function(e) {\r\n\t            var nodeTarget = e.target;\r\n\t            var shape;\r\n\t            if(nodeTarget){\r\n\t                shape = nodeTarget.model;\r\n\t            }\r\n\t            if ((nodeTarget && shape && Link.isLink(shape)) || (nodeTarget && shape && Link.isNode(shape))) {\r\n\t                return;\r\n\t            }\r\n\t            var params = {};\r\n\t            params.event = e;\r\n\t            params.type = \"click\";\r\n\t            params.target = that;\r\n\t            that._api.trigger(params.type, params);\r\n\t        });\r\n\t        this.on('conPointsGroup:click', function(argument) {\r\n\t            that.linkConnectionManager.bindOperation(argument.lineNode);\r\n\t        });\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 导出json\r\n\t     * @return {Object} json对象\r\n\t     */\r\n\t    fishTopoProto.toJson = function() {\r\n\t        return LinkUtil.toJson(this.model, this.group);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 导入json\r\n\t     * @param  {Object} json对象\r\n\t     */\r\n\t    fishTopoProto.fromJson = function(json) {\r\n\t        this.clear();\r\n\t        var model = new Model(json);\r\n\t        this.setBackground(model.get(Constants.BACKGROUND));\r\n\t        var layoutRootNode = [];\r\n\t        LinkUtil.fromJson(this, this.group, model.get(Constants.CHILDS), false, layoutRootNode);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 清空当前实例，会移除实例中所有的节点与线\r\n\t     * @method clear\r\n\t     */\r\n\t    fishTopoProto.clear = function() {\r\n\t        for (var i = 0; i < this.allNodes.length; i++) {\r\n\t            var parentZr;\r\n\t            if (this.allNodes.parent) {\r\n\t                parentZr = this.allNodes.parent;\r\n\t            } else {\r\n\t                parentZr = this._zr;\r\n\t            }\r\n\t            this.linkConnectionManager.deleteSelectCon(this.allNodes[i], parentZr)\r\n\t        }\r\n\t        this.linkConnectionManager.connectorMap.clear();\r\n\t        this.allNodes = [];\r\n\t        this.operationNode = null;\r\n\t        this.selectedNode = null;\r\n\t        this.linkConnectionManager.connectors = [];\r\n\t        this._zr.clear();\r\n\t        this.group = new graphic.Group();\r\n\t        this.group.isBg = true;\r\n\t        this._zr.add(this.group);\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 移除场景中的某个节点\r\n\t     * @param  {Object} selectedNode 待删除的节点\r\n\t     */\r\n\t    fishTopoProto.removeNode = function(selectedNode) {\r\n\t        var that = this;\r\n\t        //1.如果是子节点 内 节点  则 调用子节点的删除\r\n\t        if (selectedNode.parent) {\r\n\t            selectedNode.parent.remove(selectedNode);\r\n\t        } else {\r\n\t            that.group.remove(selectedNode);\r\n\t        }\r\n\t        //2.从allNodes数组中删除\r\n\t        for (var i = 0; i < that.allNodes.length; i++) {\r\n\t            if (selectedNode.id == that.allNodes[i].id) {\r\n\t                that.allNodes.splice(i, 1);\r\n\t            }\r\n\t        }\r\n\t        this.linkConnectionManager.deleteSelectCon(selectedNode, that.group);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 派发delete事件\r\n\t     */\r\n\t    fishTopoProto._triggerDeleteEvent = function(target) {\r\n\t        var eventParams = {};\r\n\t        eventParams.type = \"delete\";\r\n\t        eventParams.target = target;\r\n\t        this._api.trigger(eventParams.type, eventParams);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._createConnectorByNodes = function(startNode, endNode, lineType) {\r\n\t        var that = this;\r\n\t        var connector = this.linkConnectionManager.connectorCreate(startNode, endNode, {\r\n\t            style: {\r\n\t                lineType: lineType\r\n\t            }\r\n\t        }, this._api);\r\n\t        if (startNode.parent && endNode.parent) {\r\n\t            endNode.parent.add(connector);\r\n\t        } else {\r\n\t            this.group.add(connector);\r\n\t        }\r\n\t\r\n\t        connector.on(\"mousedown\", zrUtil.bind(function() {\r\n\t            this.linkConnectionManager.connectorForbidEdit(!this.options.linkModify);\r\n\t            this.isNode = false;\r\n\t        }, this));\r\n\t        connector.on(\"dblclick\", function() {\r\n\t            if (that.options.isAllowEdit) {\r\n\t                that.connectorEdit(this);\r\n\t            }\r\n\t        });\r\n\t\r\n\t        this._triggerCreateEvent(connector);\r\n\t        return connector;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 派发创建完成事件\r\n\t     */\r\n\t    fishTopoProto._triggerCreateEvent = function(target) {\r\n\t        var eventParams = {};\r\n\t        eventParams.type = \"create\";\r\n\t        eventParams.target = target;\r\n\t        this._api.trigger(eventParams.type, eventParams);\r\n\t    };\r\n\t    /**\r\n\t     * 添加节点\r\n\t     * @method addNode\r\n\t     * @param {Object} node createNode返回的对象\r\n\t     */\r\n\t    fishTopoProto.addNode = function(node) {\r\n\t        this.group.add(node);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 根据name获取节点\r\n\t     * @param  {String} name 在创建节点中  name属性设置的值\r\n\t     * @return {Object}      name对应的节点\r\n\t     */\r\n\t    fishTopoProto.childOfName = function(name) {\r\n\t        var arrResult = [];\r\n\t        var childrenNode = this.allNodes;\r\n\t        var childrenLine = this.linkConnectionManager.connectors;\r\n\t        for (var i = 0; i < childrenNode.length; i++) {\r\n\t            if (childrenNode[i].model.get(\"options.name\") && childrenNode[i].model.get(\"options.name\") == name) {\r\n\t                arrResult.push(childrenNode[i]);\r\n\t            } else if (childrenNode[i].model.get(\"userData.name\") == name) {\r\n\t                arrResult.push(childrenNode[i]);\r\n\t            }\r\n\t        }\r\n\t        for (var j = 0; j < childrenLine.length; j++) {\r\n\t            if (childrenLine[j].model.get(\"options.name\") && childrenLine[j].model.get(\"options.name\") == name) {\r\n\t                arrResult.push(childrenLine[j]);\r\n\t            } else if (childrenLine[j].model.get(\"userData.name\") == name) {\r\n\t                arrResult.push(childrenLine[j]);\r\n\t            }\r\n\t        }\r\n\t        if (arrResult.length > 1) {\r\n\t            return arrResult;\r\n\t        } else {\r\n\t            return arrResult[0];\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 查找场景中的对象   例如: x坐标大于100的节点 findElements(function(e){ return e.position[0] > 100; });\r\n\t     * @param  {Function} cb      回调函数\r\n\t     * @param  {Object}   context 回调函数执行的上下文\r\n\t     * @return {Array}           返回查找到的对象\r\n\t     */\r\n\t    fishTopoProto.findElements = function(cb, context) {\r\n\t        var childrenNode = this.allNodes;\r\n\t        var childrenLine = this.linkConnectionManager.connectors;\r\n\t        var arr = [];\r\n\t        for (var i = 0; i < childrenNode.length; i++) {\r\n\t            var child = childrenNode[i];\r\n\t            if (cb.call(context, child, i)) {\r\n\t                arr.push(child);\r\n\t            }\r\n\t        }\r\n\t        for (var j = 0; j < childrenLine.length; j++) {\r\n\t            var childL = childrenLine[j];\r\n\t            if (cb.call(context, childL, j)) {\r\n\t                arr.push(childL);\r\n\t            }\r\n\t        }\r\n\t        return arr;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 设置背景色  或 背景图片\r\n\t     * @param {string} imageUrl 背景色  或 背景图片 eg. 'img/bg.jpg'，为‘gridLine’时网格背景\r\n\t     */\r\n\t    fishTopoProto.setBackground = function(imageUrl) {\r\n\t        var that = this;\r\n\t        if (imageUrl && imageUrl.length > 0) {\r\n\t            this.model.set(Constants.BACKGROUND, imageUrl);\r\n\t            if (imageUrl.substr(0, 1) == \"#\" || imageUrl.substr(0, 4) == \"rgba\") { //如果是颜色创建rect为背景\r\n\t                if (!document.createElement('canvas').getContext) {\r\n\t                    that._dom.style.backgroundColor = imageUrl;\r\n\t                } else {\r\n\t                    var imageShape = new this.Shape.Rect({\r\n\t                        shape: {\r\n\t                            width: that._zr.getWidth(),\r\n\t                            height: that._zr.getHeight()\r\n\t                        },\r\n\t                        style: {\r\n\t                            fill: imageUrl\r\n\t                        },\r\n\t                        cursor: 'default',\r\n\t                        z: -1\r\n\t                    });\r\n\t                    that._zr.add(imageShape);\r\n\t                }\r\n\t\r\n\t            } else if(imageUrl == \"gridLine\" ){\r\n\t                this.gridLineGroup = new graphic.Group();\r\n\t                this.gridLine(0.2);\r\n\t                this._zr.add(this.gridLineGroup);\r\n\t            }else{\r\n\t                if (!document.createElement('canvas').getContext) {\r\n\t                    that._dom.style.backgroundImage = \"url(\" + imageUrl + \")\";\r\n\t                    that._dom.style.backgroundRepeat = \"repeat\";\r\n\t                } else {\r\n\t                    var imageShape1 = new this.Shape.Image({ //如果是图片创建image为背景\r\n\t                        position: [0, 0],\r\n\t                        scale: [1, 1],\r\n\t                        style: {\r\n\t                            x: 0,\r\n\t                            y: 0,\r\n\t                            image: imageUrl,\r\n\t                            width: this._zr.getWidth(),\r\n\t                            height: this._zr.getHeight()\r\n\t                        },\r\n\t                        cursor: 'default',\r\n\t                        z: -1\r\n\t                    });\r\n\t                    that._zr.add(imageShape1);\r\n\t                }\r\n\t\r\n\t            }\r\n\t\r\n\t        }\r\n\t\r\n\t    };\r\n\t    //背景网格线\r\n\t    fishTopoProto.gridLine = function(opacity) {\r\n\t        var pixel = 10;\r\n\t        var widthLen = parseInt(this.getWidth() / pixel);\r\n\t        for (var x = 0; x <= widthLen; x++) {\r\n\t            var lineX = new graphic.Line({\r\n\t                shape: {\r\n\t                    x1: x * pixel,\r\n\t                    y1: 0,\r\n\t                    x2: x * pixel,\r\n\t                    y2: this.getHeight()\r\n\t                },\r\n\t                style: {\r\n\t                    lineDash: [1],\r\n\t                    opacity: opacity\r\n\t                },\r\n\t                z: 0,\r\n\t                draggable: false,\r\n\t                cursor: 'default'\r\n\t            });\r\n\t            this.gridLineGroup.add(lineX);\r\n\t        }\r\n\t\r\n\t        var heightLen = parseInt(this.getHeight() / pixel, pixel);\r\n\t        for (var y = 0; y <= heightLen; y++) {\r\n\t            var lineY = new graphic.Line({\r\n\t                shape: {\r\n\t                    x1: 0,\r\n\t                    y1: y * pixel,\r\n\t                    x2: this.getWidth(),\r\n\t                    y2: y * pixel\r\n\t                },\r\n\t                style: {\r\n\t                    lineDash: [1],\r\n\t                    opacity: opacity\r\n\t                },\r\n\t                z: 0,\r\n\t                draggable: false,\r\n\t                cursor: 'default'\r\n\t            });\r\n\t            this.gridLineGroup.add(lineY);\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 根据点数组创建线段\r\n\t     * @method createLinkOfPoints\r\n\t     * @param  {Object} options 线段选项\r\n\t     * @param {Object} [options.style] 节点的样式\r\n\t     * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n\t     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n\t     * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n\t     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n\t     * @param {Object} [options.symbol] 线段的箭头\r\n\t     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n\t     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n\t     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n\t     * @param {Object} [options.text] 线段上的文字\r\n\t     * @param {String} [options.text.text] 线段上的文字内容\r\n\t     * @param {String} [options.text.color] 线段上的文字颜色\r\n\t     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n\t     * @param {String} [options.text.xOffset] 文字位置x偏移量\r\n\t     * @param {String} [options.pos] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t     * @param {String} [options.position] 指定线段位置\r\n\t     * @param {Object} [options.effect] 线上动态效果\r\n\t     * @param {String} [options.effect.show] 是否显示箭头动效\r\n\t     * @param {Number} [options.effect.period] 动效移动速度\r\n\t     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组\r\n\t     * @param {Object} userData 用户传递的业务数据\r\n\t     * @return {Object} 创建的线段对象\r\n\t     *\r\n\t     * **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *      var link = me.fishTopo.createLinkOfPoints({\r\n\t     *              symbol: { type: 'arrow', size: 10, color: \"rgb(0,200,255)\" }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n\t     *              style: { lineWidth: 3, stroke: \"rgb(0,200,255)\", lineDash: [3,3], lineType: \"jagged\"  }, //样式\r\n\t     *              text: {\r\n\t     *                  text: text,\r\n\t     *                  color: '#ffffff',\r\n\t     *                  textPos:textPos,//文字位置可选值 'start','center','end',默认值为center\r\n\t     *                  xOffset:10, //文字位置x偏移量\r\n\t     *              }\r\n\t     *              position:{\r\n\t                        points:[\r\n\t                            {x:0,y:0},\r\n\t                            {x:50,y:0},\r\n\t                            {x:that.fishTopoLink.getWidth()-50, y:50},\r\n\t                            {x:that.fishTopoLink.getWidth(), y:50}\r\n\t                        ]  //不使用自动计算 指定连线的位置数组\r\n\t                    }\r\n\t     *          });\r\n\t     */\r\n\t    fishTopoProto.createLinkOfPoints = function(options, userData) {\r\n\t        var that = this;\r\n\t        options.isEdit = !!this.options.linkModify;\r\n\t        var connector = this.linkConnectionManager.connectorCreateOfPoints(options, this._api);\r\n\t        connector.model.set(Constants.USERDATA, zrUtil.clone(userData));\r\n\t        connector.on(\"dblclick\", function() {\r\n\t            if (typeof this.options.text.isAllowEdit == \"undefined\") {\r\n\t                if (that.options.isAllowEdit) {\r\n\t                    that.connectorEdit(this);\r\n\t                }\r\n\t            } else {\r\n\t                if (this.options.text.isAllowEdit) {\r\n\t                    that.connectorEdit(this);\r\n\t                }\r\n\t            }\r\n\t        });\r\n\t        return connector;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 返回当前画布的数据\r\n\t     */\r\n\t    fishTopoProto.toDataURL = function(opts) {\r\n\t        return LinkUtil.toDataURL(this._zr, opts);\r\n\t    };\r\n\t\r\n\t    zrUtil.mixin(FishTopoLink, Eventful);\r\n\t\r\n\t    // ---------对外暴露fishTopoLink------------------\r\n\t    var idBase = new Date() - 0;\r\n\t    var instances = {};\r\n\t    var DOM_ATTRIBUTE_KEY = '_fishTopoLink_instance_';\r\n\t\r\n\t    /**\r\n\t     * fishTopoLink全局对象，如果是amd方式加载，则直接返回\r\n\t     * @class fishTopoLink\r\n\t     * @singleton\r\n\t     */\r\n\t    var fishTopoLink = {\r\n\t        /**\r\n\t         * 版本号\r\n\t         * @type {String}\r\n\t         */\r\n\t        version: '3.0.0',\r\n\t        dependencies: {\r\n\t            zrender: '3.0.4'\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 初始化dom元素为 flow对象\r\n\t     * @member fishTopoLink\r\n\t     * @param {HTMLElement} dom  一个div元素\r\n\t     * @param {Object} opts  传递的选项参数\r\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg' or 'vml'\r\n\t     * @param {number} [opts.devicePixelRatio=1] retina 屏幕优化\r\n\t     * @param {number} [opts.linkModify=false] 是否允许调整线段\r\n\t     * @return {fish.topo.FishTopoLink}\r\n\t     */\r\n\t    fishTopoLink.init = function(dom, opts) {\r\n\t        if (!dom) {\r\n\t            throw new Error('Initialize failed: invalid dom.');\r\n\t        }\r\n\t\r\n\t        opts = opts || {};\r\n\t        // Default value\r\n\t        zrUtil.defaults(opts, {\r\n\t            type: \"flow\",\r\n\t            devicePixelRatio: 1,\r\n\t            linkModify: false,\r\n\t            isAllowEdit: false\r\n\t        });\r\n\t\r\n\t        var fishTopoLink = new FishTopoLink(dom, opts);\r\n\t        fishTopoLink.init();\r\n\t        fishTopoLink.Link = Link;\r\n\t        fishTopoLink.id = 'ft_' + idBase++;\r\n\t        instances[fishTopoLink.id] = fishTopoLink;\r\n\t\r\n\t        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoLink.id);\r\n\t\r\n\t        return fishTopoLink;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 获取 dom 容器上的实例。\r\n\t     * @member fishTopoLink\r\n\t     * @param  {HTMLElement} dom 一个div元素\r\n\t     * @return {fish.topo.FishTopoLink}\r\n\t     */\r\n\t    fishTopoLink.getInstanceByDom = function(dom) {\r\n\t        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\r\n\t        return instances[key];\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 销毁实例，实例销毁后无法再被使用。\r\n\t     *\r\n\t     * @member fishTopoLink\r\n\t     * @param  {Object|string} chart fishTopoLink实例 或 fishTopoLink的id\r\n\t     */\r\n\t    fishTopoLink.dispose = function(chart) {\r\n\t        var topo;\r\n\t        if (zrUtil.isDom(chart)) {\r\n\t            topo = fishTopoLink.getInstanceByDom(chart);\r\n\t        } else if (typeof chart === 'string') {\r\n\t            topo = instances[chart];\r\n\t        }\r\n\t        if ((topo instanceof fishTopoLink) && !topo.isDisposed()) {\r\n\t            topo.dispose();\r\n\t        }\r\n\t        clearTimeout(this._layoutTimeout);\r\n\t    };\r\n\t\r\n\t    //暴露出去的类\r\n\t    fishTopoLink.util = {};\r\n\t    fishTopoLink.util['initImagePool'] = ImagePool.initImagePool;\r\n\t    zrUtil.each([\r\n\t            'map', 'each', 'filter', 'indexOf', 'inherits',\r\n\t            'reduce', 'filter', 'bind', 'curry', 'isArray',\r\n\t            'isString', 'isObject', 'isFunction', 'extend'\r\n\t        ],\r\n\t        function(name) {\r\n\t            fishTopoLink.util[name] = zrUtil[name];\r\n\t        }\r\n\t    );\r\n\t\r\n\t    module.exports = fishTopoLink;\r\n\t\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t\r\n\t    var pathTool = __webpack_require__(5);\r\n\t    var round = Math.round;\r\n\t    var Path = __webpack_require__(6);\r\n\t    var colorTool = __webpack_require__(19);\r\n\t    var matrix = __webpack_require__(13);\r\n\t    var vector = __webpack_require__(14);\r\n\t    var Gradient = __webpack_require__(41);\r\n\t    var Draggable = __webpack_require__(42);\r\n\t\r\n\t    var graphic = {};\r\n\t    graphic.Util = zrUtil;\r\n\t    graphic.Group = __webpack_require__(43);\r\n\t\r\n\t    graphic.Image = __webpack_require__(44);\r\n\t\r\n\t    graphic.Text = __webpack_require__(45);\r\n\t\r\n\t    graphic.textContain = __webpack_require__(25);\r\n\t\r\n\t    graphic.Circle = __webpack_require__(46);\r\n\t\r\n\t    graphic.Sector = __webpack_require__(47);\r\n\t\r\n\t    graphic.Ring = __webpack_require__(50);\r\n\t\r\n\t    graphic.Polygon = __webpack_require__(51);\r\n\t\r\n\t    graphic.Polyline = __webpack_require__(55);\r\n\t\r\n\t    graphic.Rect = __webpack_require__(56);\r\n\t\r\n\t    graphic.Line = __webpack_require__(57);\r\n\t\r\n\t    graphic.BezierCurve = __webpack_require__(58);\r\n\t\r\n\t    graphic.Arc = __webpack_require__(59);\r\n\t\r\n\t    graphic.LinearGradient = __webpack_require__(60);\r\n\t\r\n\t    graphic.RadialGradient = __webpack_require__(61);\r\n\t\r\n\t    graphic.BoundingRect = __webpack_require__(26);\r\n\t    graphic.States = __webpack_require__(62);\r\n\t    /**\r\n\t     * Extend shape with parameters\r\n\t     */\r\n\t    graphic.extendShape = function (opts) {\r\n\t        return Path.extend(opts);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Extend path\r\n\t     */\r\n\t    graphic.extendPath = function (pathData, opts) {\r\n\t        return pathTool.extendFromString(pathData, opts);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Create a path element from path data string\r\n\t     * @param {string} pathData\r\n\t     * @param {Object} opts\r\n\t     * @param {module:zrender/core/BoundingRect} rect\r\n\t     * @param {string} [layout=cover] 'center' or 'cover'\r\n\t     */\r\n\t    graphic.makePath = function (pathData, opts, rect, layout) {\r\n\t        var path = pathTool.createFromString(pathData, opts);\r\n\t        Draggable.call(path);\r\n\t        var boundingRect = path.getBoundingRect();\r\n\t        if (rect) {\r\n\t            var aspect = boundingRect.width / boundingRect.height;\r\n\t\r\n\t            if (layout === 'center') {\r\n\t                // Set rect to center, keep width / height ratio.\r\n\t                var width = rect.height * aspect;\r\n\t                var height;\r\n\t                if (width <= rect.width) {\r\n\t                    height = rect.height;\r\n\t                }\r\n\t                else {\r\n\t                    width = rect.width;\r\n\t                    height = width / aspect;\r\n\t                }\r\n\t                var cx = rect.x + rect.width / 2;\r\n\t                var cy = rect.y + rect.height / 2;\r\n\t\r\n\t                rect.x = cx - width / 2;\r\n\t                rect.y = cy - height / 2;\r\n\t                rect.width = width;\r\n\t                rect.height = height;\r\n\t            }\r\n\t\r\n\t            this.resizePath(path, rect);\r\n\t        }\r\n\t\r\n\t        zrUtil.inherits(path, Draggable);\r\n\t        return path;\r\n\t    };\r\n\t\r\n\t    graphic.mergePath = pathTool.mergePath;\r\n\t\r\n\t    /**\r\n\t     * Resize a path to fit the rect\r\n\t     * @param {module:zrender/graphic/Path} path\r\n\t     * @param {Object} rect\r\n\t     */\r\n\t    graphic.resizePath = function (path, rect) {\r\n\t        if (!path.applyTransform) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var pathRect = path.getBoundingRect();\r\n\t\r\n\t        var m = pathRect.calculateTransform(rect);\r\n\t\r\n\t        path.applyTransform(m);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize line for canvas\r\n\t     *\r\n\t     * @param {Object} param\r\n\t     * @param {Object} [param.shape]\r\n\t     * @param {number} [param.shape.x1]\r\n\t     * @param {number} [param.shape.y1]\r\n\t     * @param {number} [param.shape.x2]\r\n\t     * @param {number} [param.shape.y2]\r\n\t     * @param {Object} [param.style]\r\n\t     * @param {number} [param.style.lineWidth]\r\n\t     * @return {Object} Modified param\r\n\t     */\r\n\t    graphic.subPixelOptimizeLine = function (param) {\r\n\t        var subPixelOptimize = graphic.subPixelOptimize;\r\n\t        var shape = param.shape;\r\n\t        var lineWidth = param.style.lineWidth;\r\n\t\r\n\t        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\r\n\t            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\r\n\t        }\r\n\t        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\r\n\t            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\r\n\t        }\r\n\t        return param;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize rect for canvas\r\n\t     *\r\n\t     * @param {Object} param\r\n\t     * @param {Object} [param.shape]\r\n\t     * @param {number} [param.shape.x]\r\n\t     * @param {number} [param.shape.y]\r\n\t     * @param {number} [param.shape.width]\r\n\t     * @param {number} [param.shape.height]\r\n\t     * @param {Object} [param.style]\r\n\t     * @param {number} [param.style.lineWidth]\r\n\t     * @return {Object} Modified param\r\n\t     */\r\n\t    graphic.subPixelOptimizeRect = function (param) {\r\n\t        var subPixelOptimize = graphic.subPixelOptimize;\r\n\t        var shape = param.shape;\r\n\t        var lineWidth = param.style.lineWidth;\r\n\t        var originX = shape.x;\r\n\t        var originY = shape.y;\r\n\t        var originWidth = shape.width;\r\n\t        var originHeight = shape.height;\r\n\t        shape.x = subPixelOptimize(shape.x, lineWidth, true);\r\n\t        shape.y = subPixelOptimize(shape.y, lineWidth, true);\r\n\t        shape.width = Math.max(\r\n\t            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\r\n\t            originWidth === 0 ? 0 : 1\r\n\t        );\r\n\t        shape.height = Math.max(\r\n\t            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\r\n\t            originHeight === 0 ? 0 : 1\r\n\t        );\r\n\t        return param;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize for canvas\r\n\t     *\r\n\t     * @param {number} position Coordinate, such as x, y\r\n\t     * @param {number} lineWidth Should be nonnegative integer.\r\n\t     * @param {boolean=} positiveOrNegative Default false (negative).\r\n\t     * @return {number} Optimized position.\r\n\t     */\r\n\t    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\r\n\t        // Assure that (position + lineWidth / 2) is near integer edge,\r\n\t        // otherwise line will be fuzzy in canvas.\r\n\t        var doubledPosition = round(position * 2);\r\n\t        return (doubledPosition + round(lineWidth)) % 2 === 0\r\n\t            ? doubledPosition / 2\r\n\t            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    function doSingleEnterHover(el) {\r\n\t        if (el.__isHover) {\r\n\t            return;\r\n\t        }\r\n\t        if (el.__hoverStlDirty) {\r\n\t            var stroke = el.style.stroke;\r\n\t            var fill = el.style.fill;\r\n\t\r\n\t            // Create hoverStyle on mouseover\r\n\t            var hoverStyle = el.__hoverStl;\r\n\t            var lift = colorTool.lift;\r\n\t            hoverStyle.fill = hoverStyle.fill\r\n\t                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));\r\n\t            hoverStyle.stroke = hoverStyle.stroke\r\n\t                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));\r\n\t\r\n\t            var normalStyle = {};\r\n\t            for (var name in hoverStyle) {\r\n\t                if (hoverStyle.hasOwnProperty(name)) {\r\n\t                    normalStyle[name] = el.style[name];\r\n\t                }\r\n\t            }\r\n\t\r\n\t            el.__normalStl = normalStyle;\r\n\t\r\n\t            el.__hoverStlDirty = false;\r\n\t        }\r\n\t        el.setStyle(el.__hoverStl);\r\n\t        el.z2 += 1;\r\n\t\r\n\t        el.__isHover = true;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function doSingleLeaveHover(el) {\r\n\t        if (!el.__isHover) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var normalStl = el.__normalStl;\r\n\t        normalStl && el.setStyle(normalStl);\r\n\t        el.z2 -= 1;\r\n\t\r\n\t        el.__isHover = false;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function doEnterHover(el) {\r\n\t        (el.type === 'group' || el.type === 'GroupNode')\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    doSingleEnterHover(child);\r\n\t                }\r\n\t            })\r\n\t            : doSingleEnterHover(el);\r\n\t    }\r\n\t    graphic.doEnterHover = doEnterHover;\r\n\t    function doLeaveHover(el) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    doSingleLeaveHover(child);\r\n\t                }\r\n\t            })\r\n\t            : doSingleLeaveHover(el);\r\n\t    }\r\n\t    graphic.doLeaveHover = doLeaveHover;\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function setElementHoverStl(el, hoverStl) {\r\n\t        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\r\n\t        // Often used when item group has a label element and it's hoverStyle is different\r\n\t        el.__hoverStl = el.hoverStyle || hoverStl || {};\r\n\t        el.__hoverStlDirty = true;\r\n\t    }\r\n\t    graphic.setElementHoverStl = setElementHoverStl;\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function onElementMouseOver() {\r\n\t        // Only if element is not in emphasis status\r\n\t        !this.__isEmphasis && doEnterHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function onElementMouseOut() {\r\n\t        // Only if element is not in emphasis status\r\n\t        !this.__isEmphasis && doLeaveHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function enterEmphasis() {\r\n\t        this.__isEmphasis = true;\r\n\t        doEnterHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function leaveEmphasis() {\r\n\t        this.__isEmphasis = false;\r\n\t        doLeaveHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Set hover style of element\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} [hoverStyle]\r\n\t     */\r\n\t    graphic.setHoverStyle = function (el, hoverStyle) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    setElementHoverStl(child, hoverStyle);\r\n\t                }\r\n\t            })\r\n\t            : setElementHoverStl(el, hoverStyle);\r\n\t        // Remove previous bound handlers\r\n\t        el.on('mouseover', onElementMouseOver)\r\n\t          .on('mouseout', onElementMouseOut);\r\n\t\r\n\t        // Emphasis, normal can be triggered manually\r\n\t        el.on('emphasis', enterEmphasis)\r\n\t          .on('normal', leaveEmphasis);\r\n\t    };\r\n\t\r\n\t    graphic.setNormalStyle = function(el, options) {\r\n\t        if (el.__normalStl) {\r\n\t            for (var name in options) {\r\n\t                if (el.__normalStl.hasOwnProperty(name)) {\r\n\t                    el.__normalStl[name] = options[name];\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Set text option in the style\r\n\t     * @param {Object} textStyle\r\n\t     * @param {module:echarts/model/Model} labelModel\r\n\t     * @param {string} color\r\n\t     */\r\n\t    graphic.setText = function (textStyle, labelModel, color) {\r\n\t        var labelPosition = labelModel.getShallow('position') || 'inside';\r\n\t        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\r\n\t        var textStyleModel = labelModel.getModel('textStyle');\r\n\t        zrUtil.extend(textStyle, {\r\n\t            textDistance: labelModel.getShallow('distance') || 5,\r\n\t            textFont: textStyleModel.getFont(),\r\n\t            textPosition: labelPosition,\r\n\t            textFill: textStyleModel.getTextColor() || labelColor\r\n\t        });\r\n\t    };\r\n\t\r\n\t    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {\r\n\t        var postfix = isUpdate ? 'Update' : '';\r\n\t        var duration = animatableModel\r\n\t            && animatableModel.getShallow('animationDuration' + postfix);\r\n\t        var animationEasing = animatableModel\r\n\t            && animatableModel.getShallow('animationEasing' + postfix);\r\n\t\r\n\t        animatableModel && animatableModel.getShallow('animation')\r\n\t            ? el.animateTo(props, duration, animationEasing, cb)\r\n\t            : (el.attr(props), cb && cb());\r\n\t    }\r\n\t    /**\r\n\t     * Update graphic element properties with or without animation according to the configuration in series\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} props\r\n\t     * @param {module:echarts/model/Model} [animatableModel]\r\n\t     * @param {Function} cb\r\n\t     */\r\n\t    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);\r\n\t\r\n\t    /**\r\n\t     * Init graphic element properties with or without animation according to the configuration in series\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} props\r\n\t     * @param {module:echarts/model/Model} [animatableModel]\r\n\t     * @param {Function} cb\r\n\t     */\r\n\t    graphic.initProps = zrUtil.curry(animateOrSetProps, false);\r\n\t\r\n\t    /**\r\n\t     * Get transform matrix of target (param target),\r\n\t     * in coordinate of its ancestor (param ancestor)\r\n\t     *\r\n\t     * @param {module:zrender/mixin/Transformable} target\r\n\t     * @param {module:zrender/mixin/Transformable} ancestor\r\n\t     */\r\n\t    graphic.getTransform = function (target, ancestor) {\r\n\t        var mat = matrix.identity([]);\r\n\t\r\n\t        while (target && target !== ancestor) {\r\n\t            matrix.mul(mat, target.getLocalTransform(), mat);\r\n\t            target = target.parent;\r\n\t        }\r\n\t\r\n\t        return mat;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Apply transform to an vertex.\r\n\t     * @param {Array.<number>} vertex [x, y]\r\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n\t     * @param {boolean=} invert Whether use invert matrix.\r\n\t     * @return {Array.<number>} [x, y]\r\n\t     */\r\n\t    graphic.applyTransform = function (vertex, transform, invert) {\r\n\t        if (invert) {\r\n\t            transform = matrix.invert([], transform);\r\n\t        }\r\n\t        return vector.applyTransform([], vertex, transform);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @param {string} direction 'left' 'right' 'top' 'bottom'\r\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n\t     * @param {boolean=} invert Whether use invert matrix.\r\n\t     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\r\n\t     */\r\n\t    graphic.transformDirection = function (direction, transform, invert) {\r\n\t\r\n\t        // Pick a base, ensure that transform result will not be (0, 0).\r\n\t        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\r\n\t            ? 1 : Math.abs(2 * transform[4] / transform[0]);\r\n\t        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\r\n\t            ? 1 : Math.abs(2 * transform[4] / transform[2]);\r\n\t\r\n\t        var vertex = [\r\n\t            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\r\n\t            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\r\n\t        ];\r\n\t\r\n\t        vertex = graphic.applyTransform(vertex, transform, invert);\r\n\t\r\n\t        return Math.abs(vertex[0]) > Math.abs(vertex[1])\r\n\t            ? (vertex[0] > 0 ? 'right' : 'left')\r\n\t            : (vertex[1] > 0 ? 'bottom' : 'top');\r\n\t    };\r\n\t\r\n\t    module.exports = graphic;\r\n\t\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * @module zrender/core/util\n\t */\n\t// 用于处理merge时无法遍历Date等对象的问题\n\tvar BUILTIN_OBJECT = {\n\t  '[object Function]': 1,\n\t  '[object RegExp]': 1,\n\t  '[object Date]': 1,\n\t  '[object Error]': 1,\n\t  '[object CanvasGradient]': 1,\n\t  '[object CanvasPattern]': 1,\n\t  // For node-canvas\n\t  '[object Image]': 1,\n\t  '[object Canvas]': 1\n\t};\n\tvar TYPED_ARRAY = {\n\t  '[object Int8Array]': 1,\n\t  '[object Uint8Array]': 1,\n\t  '[object Uint8ClampedArray]': 1,\n\t  '[object Int16Array]': 1,\n\t  '[object Uint16Array]': 1,\n\t  '[object Int32Array]': 1,\n\t  '[object Uint32Array]': 1,\n\t  '[object Float32Array]': 1,\n\t  '[object Float64Array]': 1\n\t};\n\tvar objToString = Object.prototype.toString;\n\tvar arrayProto = Array.prototype;\n\tvar nativeForEach = arrayProto.forEach;\n\tvar nativeFilter = arrayProto.filter;\n\tvar nativeSlice = arrayProto.slice;\n\tvar nativeMap = arrayProto.map;\n\tvar nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.\n\t\n\tvar methods = {};\n\t\n\tfunction $override(name, fn) {\n\t  methods[name] = fn;\n\t}\n\t/**\n\t * Those data types can be cloned:\n\t *     Plain object, Array, TypedArray, number, string, null, undefined.\n\t * Those data types will be assgined using the orginal data:\n\t *     BUILTIN_OBJECT\n\t * Instance of user defined class will be cloned to a plain object, without\n\t * properties in prototype.\n\t * Other data types is not supported (not sure what will happen).\n\t *\n\t * Caution: do not support clone Date, for performance consideration.\n\t * (There might be a large number of date in `series.data`).\n\t * So date should not be modified in and out of echarts.\n\t *\n\t * @param {*} source\n\t * @return {*} new\n\t */\n\t\n\t\n\tfunction clone(source) {\n\t  if (source == null || typeof source != 'object') {\n\t    return source;\n\t  }\n\t\n\t  var result = source;\n\t  var typeStr = objToString.call(source);\n\t\n\t  if (typeStr === '[object Array]') {\n\t    result = [];\n\t\n\t    for (var i = 0, len = source.length; i < len; i++) {\n\t      result[i] = clone(source[i]);\n\t    }\n\t  } else if (TYPED_ARRAY[typeStr]) {\n\t    var Ctor = source.constructor;\n\t\n\t    if (source.constructor.from) {\n\t      result = Ctor.from(source);\n\t    } else {\n\t      result = new Ctor(source.length);\n\t\n\t      for (var i = 0, len = source.length; i < len; i++) {\n\t        result[i] = clone(source[i]);\n\t      }\n\t    }\n\t  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n\t    result = {};\n\t\n\t    for (var key in source) {\n\t      if (source.hasOwnProperty(key)) {\n\t        result[key] = clone(source[key]);\n\t      }\n\t    }\n\t  }\n\t\n\t  return result;\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} target\n\t * @param {*} source\n\t * @param {boolean} [overwrite=false]\n\t */\n\t\n\t\n\tfunction merge(target, source, overwrite) {\n\t  // We should escapse that source is string\n\t  // and enter for ... in ...\n\t  if (!isObject(source) || !isObject(target)) {\n\t    return overwrite ? clone(source) : target;\n\t  }\n\t\n\t  for (var key in source) {\n\t    if (source.hasOwnProperty(key)) {\n\t      var targetProp = target[key];\n\t      var sourceProp = source[key];\n\t\n\t      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {\n\t        // 如果需要递归覆盖，就递归调用merge\n\t        merge(targetProp, sourceProp, overwrite);\n\t      } else if (overwrite || !(key in target)) {\n\t        // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n\t        // NOTE，在 target[key] 不存在的时候也是直接覆盖\n\t        target[key] = clone(source[key], true);\n\t      }\n\t    }\n\t  }\n\t\n\t  return target;\n\t}\n\t/**\n\t * @param {Array} targetAndSources The first item is target, and the rests are source.\n\t * @param {boolean} [overwrite=false]\n\t * @return {*} target\n\t */\n\t\n\t\n\tfunction mergeAll(targetAndSources, overwrite) {\n\t  var result = targetAndSources[0];\n\t\n\t  for (var i = 1, len = targetAndSources.length; i < len; i++) {\n\t    result = merge(result, targetAndSources[i], overwrite);\n\t  }\n\t\n\t  return result;\n\t}\n\t/**\n\t * @param {*} target\n\t * @param {*} source\n\t * @memberOf module:zrender/core/util\n\t */\n\t\n\t\n\tfunction extend(target, source) {\n\t  for (var key in source) {\n\t    if (source.hasOwnProperty(key)) {\n\t      target[key] = source[key];\n\t    }\n\t  }\n\t\n\t  return target;\n\t}\n\t/**\n\t * @param {*} target\n\t * @param {*} source\n\t * @param {boolean} [overlay=false]\n\t * @memberOf module:zrender/core/util\n\t */\n\t\n\t\n\tfunction defaults(target, source, overlay) {\n\t  for (var key in source) {\n\t    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {\n\t      target[key] = source[key];\n\t    }\n\t  }\n\t\n\t  return target;\n\t}\n\t\n\tvar createCanvas = function () {\n\t  return methods.createCanvas();\n\t};\n\t\n\tmethods.createCanvas = function () {\n\t  return document.createElement('canvas');\n\t}; // FIXME\n\t\n\t\n\tvar _ctx;\n\t\n\tfunction getContext() {\n\t  if (!_ctx) {\n\t    // Use util.createCanvas instead of createCanvas\n\t    // because createCanvas may be overwritten in different environment\n\t    _ctx = createCanvas().getContext('2d');\n\t  }\n\t\n\t  return _ctx;\n\t}\n\t/**\n\t * 查询数组中元素的index\n\t * @memberOf module:zrender/core/util\n\t */\n\t\n\t\n\tfunction indexOf(array, value) {\n\t  if (array) {\n\t    if (array.indexOf) {\n\t      return array.indexOf(value);\n\t    }\n\t\n\t    for (var i = 0, len = array.length; i < len; i++) {\n\t      if (array[i] === value) {\n\t        return i;\n\t      }\n\t    }\n\t  }\n\t\n\t  return -1;\n\t}\n\t/**\n\t * 构造类继承关系\n\t *\n\t * @memberOf module:zrender/core/util\n\t * @param {Function} clazz 源类\n\t * @param {Function} baseClazz 基类\n\t */\n\t\n\t\n\tfunction inherits(clazz, baseClazz) {\n\t  var clazzPrototype = clazz.prototype;\n\t\n\t  function F() {}\n\t\n\t  F.prototype = baseClazz.prototype;\n\t  clazz.prototype = new F();\n\t\n\t  for (var prop in clazzPrototype) {\n\t    clazz.prototype[prop] = clazzPrototype[prop];\n\t  }\n\t\n\t  clazz.prototype.constructor = clazz;\n\t  clazz.superClass = baseClazz;\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {Object|Function} target\n\t * @param {Object|Function} sorce\n\t * @param {boolean} overlay\n\t */\n\t\n\t\n\tfunction mixin(target, source, overlay) {\n\t  target = 'prototype' in target ? target.prototype : target;\n\t  source = 'prototype' in source ? source.prototype : source;\n\t  defaults(target, source, overlay);\n\t}\n\t/**\n\t * Consider typed array.\n\t * @param {Array|TypedArray} data\n\t */\n\t\n\t\n\tfunction isArrayLike(data) {\n\t  if (!data) {\n\t    return;\n\t  }\n\t\n\t  if (typeof data == 'string') {\n\t    return false;\n\t  }\n\t\n\t  return typeof data.length == 'number';\n\t}\n\t/**\n\t * 数组或对象遍历\n\t * @memberOf module:zrender/core/util\n\t * @param {Object|Array} obj\n\t * @param {Function} cb\n\t * @param {*} [context]\n\t */\n\t\n\t\n\tfunction each(obj, cb, context) {\n\t  if (!(obj && cb)) {\n\t    return;\n\t  }\n\t\n\t  if (obj.forEach && obj.forEach === nativeForEach) {\n\t    obj.forEach(cb, context);\n\t  } else if (obj.length === +obj.length) {\n\t    for (var i = 0, len = obj.length; i < len; i++) {\n\t      cb.call(context, obj[i], i, obj);\n\t    }\n\t  } else {\n\t    for (var key in obj) {\n\t      if (obj.hasOwnProperty(key)) {\n\t        cb.call(context, obj[key], key, obj);\n\t      }\n\t    }\n\t  }\n\t}\n\t/**\n\t * 数组映射\n\t * @memberOf module:zrender/core/util\n\t * @param {Array} obj\n\t * @param {Function} cb\n\t * @param {*} [context]\n\t * @return {Array}\n\t */\n\t\n\t\n\tfunction map(obj, cb, context) {\n\t  if (!(obj && cb)) {\n\t    return;\n\t  }\n\t\n\t  if (obj.map && obj.map === nativeMap) {\n\t    return obj.map(cb, context);\n\t  } else {\n\t    var result = [];\n\t\n\t    for (var i = 0, len = obj.length; i < len; i++) {\n\t      result.push(cb.call(context, obj[i], i, obj));\n\t    }\n\t\n\t    return result;\n\t  }\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {Array} obj\n\t * @param {Function} cb\n\t * @param {Object} [memo]\n\t * @param {*} [context]\n\t * @return {Array}\n\t */\n\t\n\t\n\tfunction reduce(obj, cb, memo, context) {\n\t  if (!(obj && cb)) {\n\t    return;\n\t  }\n\t\n\t  if (obj.reduce && obj.reduce === nativeReduce) {\n\t    return obj.reduce(cb, memo, context);\n\t  } else {\n\t    for (var i = 0, len = obj.length; i < len; i++) {\n\t      memo = cb.call(context, memo, obj[i], i, obj);\n\t    }\n\t\n\t    return memo;\n\t  }\n\t}\n\t/**\n\t * 数组过滤\n\t * @memberOf module:zrender/core/util\n\t * @param {Array} obj\n\t * @param {Function} cb\n\t * @param {*} [context]\n\t * @return {Array}\n\t */\n\t\n\t\n\tfunction filter(obj, cb, context) {\n\t  if (!(obj && cb)) {\n\t    return;\n\t  }\n\t\n\t  if (obj.filter && obj.filter === nativeFilter) {\n\t    return obj.filter(cb, context);\n\t  } else {\n\t    var result = [];\n\t\n\t    for (var i = 0, len = obj.length; i < len; i++) {\n\t      if (cb.call(context, obj[i], i, obj)) {\n\t        result.push(obj[i]);\n\t      }\n\t    }\n\t\n\t    return result;\n\t  }\n\t}\n\t/**\n\t * 数组项查找\n\t * @memberOf module:zrender/core/util\n\t * @param {Array} obj\n\t * @param {Function} cb\n\t * @param {*} [context]\n\t * @return {*}\n\t */\n\t\n\t\n\tfunction find(obj, cb, context) {\n\t  if (!(obj && cb)) {\n\t    return;\n\t  }\n\t\n\t  for (var i = 0, len = obj.length; i < len; i++) {\n\t    if (cb.call(context, obj[i], i, obj)) {\n\t      return obj[i];\n\t    }\n\t  }\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {Function} func\n\t * @param {*} context\n\t * @return {Function}\n\t */\n\t\n\t\n\tfunction bind(func, context) {\n\t  var args = nativeSlice.call(arguments, 2);\n\t  return function () {\n\t    return func.apply(context, args.concat(nativeSlice.call(arguments)));\n\t  };\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {Function} func\n\t * @return {Function}\n\t */\n\t\n\t\n\tfunction curry(func) {\n\t  var args = nativeSlice.call(arguments, 1);\n\t  return function () {\n\t    return func.apply(this, args.concat(nativeSlice.call(arguments)));\n\t  };\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isArray(value) {\n\t  return objToString.call(value) === '[object Array]';\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isFunction(value) {\n\t  return typeof value === 'function';\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isString(value) {\n\t  return objToString.call(value) === '[object String]';\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isObject(value) {\n\t  // Avoid a V8 JIT bug in Chrome 19-20.\n\t  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t  var type = typeof value;\n\t  return type === 'function' || !!value && type == 'object';\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isBuiltInObject(value) {\n\t  return !!BUILTIN_OBJECT[objToString.call(value)];\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isDom(value) {\n\t  return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';\n\t}\n\t/**\n\t * Whether is exactly NaN. Notice isNaN('a') returns true.\n\t * @param {*} value\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction eqNaN(value) {\n\t  return value !== value;\n\t}\n\t/**\n\t * If value1 is not null, then return value1, otherwise judget rest of values.\n\t * Low performance.\n\t * @memberOf module:zrender/core/util\n\t * @return {*} Final value\n\t */\n\t\n\t\n\tfunction retrieve(values) {\n\t  for (var i = 0, len = arguments.length; i < len; i++) {\n\t    if (arguments[i] != null) {\n\t      return arguments[i];\n\t    }\n\t  }\n\t}\n\t\n\tfunction retrieve2(value0, value1) {\n\t  return value0 != null ? value0 : value1;\n\t}\n\t\n\tfunction retrieve3(value0, value1, value2) {\n\t  return value0 != null ? value0 : value1 != null ? value1 : value2;\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {Array} arr\n\t * @param {number} startIndex\n\t * @param {number} endIndex\n\t * @return {Array}\n\t */\n\t\n\t\n\tfunction slice() {\n\t  return Function.call.apply(nativeSlice, arguments);\n\t}\n\t/**\n\t * Normalize css liked array configuration\n\t * e.g.\n\t *  3 => [3, 3, 3, 3]\n\t *  [4, 2] => [4, 2, 4, 2]\n\t *  [4, 3, 2] => [4, 3, 2, 3]\n\t * @param {number|Array.<number>} val\n\t * @return {Array.<number>}\n\t */\n\t\n\t\n\tfunction normalizeCssArray(val) {\n\t  if (typeof val === 'number') {\n\t    return [val, val, val, val];\n\t  }\n\t\n\t  var len = val.length;\n\t\n\t  if (len === 2) {\n\t    // vertical | horizontal\n\t    return [val[0], val[1], val[0], val[1]];\n\t  } else if (len === 3) {\n\t    // top | horizontal | bottom\n\t    return [val[0], val[1], val[2], val[1]];\n\t  }\n\t\n\t  return val;\n\t}\n\t/**\n\t * @memberOf module:zrender/core/util\n\t * @param {boolean} condition\n\t * @param {string} message\n\t */\n\t\n\t\n\tfunction assert(condition, message) {\n\t  if (!condition) {\n\t    throw new Error(message);\n\t  }\n\t}\n\t\n\tvar primitiveKey = '__ec_primitive__';\n\t/**\n\t * Set an object as primitive to be ignored traversing children in clone or merge\n\t */\n\t\n\tfunction setAsPrimitive(obj) {\n\t  obj[primitiveKey] = true;\n\t}\n\t\n\tfunction isPrimitive(obj) {\n\t  return obj[primitiveKey];\n\t}\n\t/**\n\t * @constructor\n\t * @param {Object} obj Only apply `ownProperty`.\n\t */\n\t\n\t\n\tfunction HashMap(obj) {\n\t  obj && each(obj, function (value, key) {\n\t    this.set(key, value);\n\t  }, this);\n\t} // Add prefix to avoid conflict with Object.prototype.\n\t\n\t\n\tvar HASH_MAP_PREFIX = '_ec_';\n\tvar HASH_MAP_PREFIX_LENGTH = 4;\n\tHashMap.prototype = {\n\t  constructor: HashMap,\n\t  // Do not provide `has` method to avoid defining what is `has`.\n\t  // (We usually treat `null` and `undefined` as the same, different\n\t  // from ES6 Map).\n\t  get: function (key) {\n\t    return this[HASH_MAP_PREFIX + key];\n\t  },\n\t  set: function (key, value) {\n\t    this[HASH_MAP_PREFIX + key] = value; // Comparing with invocation chaining, `return value` is more commonly\n\t    // used in this case: `var someVal = map.set('a', genVal());`\n\t\n\t    return value;\n\t  },\n\t  // Although util.each can be performed on this hashMap directly, user\n\t  // should not use the exposed keys, who are prefixed.\n\t  each: function (cb, context) {\n\t    context !== void 0 && (cb = bind(cb, context));\n\t\n\t    for (var prefixedKey in this) {\n\t      this.hasOwnProperty(prefixedKey) && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n\t    }\n\t  },\n\t  // Do not use this method if performance sensitive.\n\t  removeKey: function (key) {\n\t    delete this[HASH_MAP_PREFIX + key];\n\t  }\n\t};\n\t\n\tfunction createHashMap(obj) {\n\t  return new HashMap(obj);\n\t}\n\t\n\tfunction noop() {}\n\t\n\texports.$override = $override;\n\texports.clone = clone;\n\texports.merge = merge;\n\texports.mergeAll = mergeAll;\n\texports.extend = extend;\n\texports.defaults = defaults;\n\texports.createCanvas = createCanvas;\n\texports.getContext = getContext;\n\texports.indexOf = indexOf;\n\texports.inherits = inherits;\n\texports.mixin = mixin;\n\texports.isArrayLike = isArrayLike;\n\texports.each = each;\n\texports.map = map;\n\texports.reduce = reduce;\n\texports.filter = filter;\n\texports.find = find;\n\texports.bind = bind;\n\texports.curry = curry;\n\texports.isArray = isArray;\n\texports.isFunction = isFunction;\n\texports.isString = isString;\n\texports.isObject = isObject;\n\texports.isBuiltInObject = isBuiltInObject;\n\texports.isDom = isDom;\n\texports.eqNaN = eqNaN;\n\texports.retrieve = retrieve;\n\texports.retrieve2 = retrieve2;\n\texports.retrieve3 = retrieve3;\n\texports.slice = slice;\n\texports.normalizeCssArray = normalizeCssArray;\n\texports.assert = assert;\n\texports.setAsPrimitive = setAsPrimitive;\n\texports.isPrimitive = isPrimitive;\n\texports.createHashMap = createHashMap;\n\texports.noop = noop;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(6);\n\t\n\tvar PathProxy = __webpack_require__(29);\n\t\n\tvar transformPath = __webpack_require__(40);\n\t\n\t// command chars\n\tvar cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];\n\tvar mathSqrt = Math.sqrt;\n\tvar mathSin = Math.sin;\n\tvar mathCos = Math.cos;\n\tvar PI = Math.PI;\n\t\n\tvar vMag = function (v) {\n\t  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n\t};\n\t\n\tvar vRatio = function (u, v) {\n\t  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n\t};\n\t\n\tvar vAngle = function (u, v) {\n\t  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n\t};\n\t\n\tfunction processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n\t  var psi = psiDeg * (PI / 180.0);\n\t  var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;\n\t  var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;\n\t  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n\t\n\t  if (lambda > 1) {\n\t    rx *= mathSqrt(lambda);\n\t    ry *= mathSqrt(lambda);\n\t  }\n\t\n\t  var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;\n\t  var cxp = f * rx * yp / ry;\n\t  var cyp = f * -ry * xp / rx;\n\t  var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;\n\t  var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;\n\t  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);\n\t  var u = [(xp - cxp) / rx, (yp - cyp) / ry];\n\t  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\n\t  var dTheta = vAngle(u, v);\n\t\n\t  if (vRatio(u, v) <= -1) {\n\t    dTheta = PI;\n\t  }\n\t\n\t  if (vRatio(u, v) >= 1) {\n\t    dTheta = 0;\n\t  }\n\t\n\t  if (fs === 0 && dTheta > 0) {\n\t    dTheta = dTheta - 2 * PI;\n\t  }\n\t\n\t  if (fs === 1 && dTheta < 0) {\n\t    dTheta = dTheta + 2 * PI;\n\t  }\n\t\n\t  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n\t}\n\t\n\tfunction createPathProxyFromString(data) {\n\t  if (!data) {\n\t    return [];\n\t  } // command string\n\t\n\t\n\t  var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');\n\t  var n; // create pipes so that we can split the data\n\t\n\t  for (n = 0; n < cc.length; n++) {\n\t    cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n\t  } // create array\n\t\n\t\n\t  var arr = cs.split('|'); // init context point\n\t\n\t  var cpx = 0;\n\t  var cpy = 0;\n\t  var path = new PathProxy();\n\t  var CMD = PathProxy.CMD;\n\t  var prevCmd;\n\t\n\t  for (n = 1; n < arr.length; n++) {\n\t    var str = arr[n];\n\t    var c = str.charAt(0);\n\t    var off = 0;\n\t    var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n\t    var cmd;\n\t\n\t    if (p.length > 0 && p[0] === '') {\n\t      p.shift();\n\t    }\n\t\n\t    for (var i = 0; i < p.length; i++) {\n\t      p[i] = parseFloat(p[i]);\n\t    }\n\t\n\t    while (off < p.length && !isNaN(p[off])) {\n\t      if (isNaN(p[0])) {\n\t        break;\n\t      }\n\t\n\t      var ctlPtx;\n\t      var ctlPty;\n\t      var rx;\n\t      var ry;\n\t      var psi;\n\t      var fa;\n\t      var fs;\n\t      var x1 = cpx;\n\t      var y1 = cpy; // convert l, H, h, V, and v to L\n\t\n\t      switch (c) {\n\t        case 'l':\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'L':\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'm':\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          cmd = CMD.M;\n\t          path.addData(cmd, cpx, cpy);\n\t          c = 'l';\n\t          break;\n\t\n\t        case 'M':\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          cmd = CMD.M;\n\t          path.addData(cmd, cpx, cpy);\n\t          c = 'L';\n\t          break;\n\t\n\t        case 'h':\n\t          cpx += p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'H':\n\t          cpx = p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'v':\n\t          cpy += p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'V':\n\t          cpy = p[off++];\n\t          cmd = CMD.L;\n\t          path.addData(cmd, cpx, cpy);\n\t          break;\n\t\n\t        case 'C':\n\t          cmd = CMD.C;\n\t          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);\n\t          cpx = p[off - 2];\n\t          cpy = p[off - 1];\n\t          break;\n\t\n\t        case 'c':\n\t          cmd = CMD.C;\n\t          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);\n\t          cpx += p[off - 2];\n\t          cpy += p[off - 1];\n\t          break;\n\t\n\t        case 'S':\n\t          ctlPtx = cpx;\n\t          ctlPty = cpy;\n\t          var len = path.len();\n\t          var pathData = path.data;\n\t\n\t          if (prevCmd === CMD.C) {\n\t            ctlPtx += cpx - pathData[len - 4];\n\t            ctlPty += cpy - pathData[len - 3];\n\t          }\n\t\n\t          cmd = CMD.C;\n\t          x1 = p[off++];\n\t          y1 = p[off++];\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t          break;\n\t\n\t        case 's':\n\t          ctlPtx = cpx;\n\t          ctlPty = cpy;\n\t          var len = path.len();\n\t          var pathData = path.data;\n\t\n\t          if (prevCmd === CMD.C) {\n\t            ctlPtx += cpx - pathData[len - 4];\n\t            ctlPty += cpy - pathData[len - 3];\n\t          }\n\t\n\t          cmd = CMD.C;\n\t          x1 = cpx + p[off++];\n\t          y1 = cpy + p[off++];\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t          break;\n\t\n\t        case 'Q':\n\t          x1 = p[off++];\n\t          y1 = p[off++];\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          cmd = CMD.Q;\n\t          path.addData(cmd, x1, y1, cpx, cpy);\n\t          break;\n\t\n\t        case 'q':\n\t          x1 = p[off++] + cpx;\n\t          y1 = p[off++] + cpy;\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          cmd = CMD.Q;\n\t          path.addData(cmd, x1, y1, cpx, cpy);\n\t          break;\n\t\n\t        case 'T':\n\t          ctlPtx = cpx;\n\t          ctlPty = cpy;\n\t          var len = path.len();\n\t          var pathData = path.data;\n\t\n\t          if (prevCmd === CMD.Q) {\n\t            ctlPtx += cpx - pathData[len - 4];\n\t            ctlPty += cpy - pathData[len - 3];\n\t          }\n\t\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          cmd = CMD.Q;\n\t          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t          break;\n\t\n\t        case 't':\n\t          ctlPtx = cpx;\n\t          ctlPty = cpy;\n\t          var len = path.len();\n\t          var pathData = path.data;\n\t\n\t          if (prevCmd === CMD.Q) {\n\t            ctlPtx += cpx - pathData[len - 4];\n\t            ctlPty += cpy - pathData[len - 3];\n\t          }\n\t\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          cmd = CMD.Q;\n\t          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t          break;\n\t\n\t        case 'A':\n\t          rx = p[off++];\n\t          ry = p[off++];\n\t          psi = p[off++];\n\t          fa = p[off++];\n\t          fs = p[off++];\n\t          x1 = cpx, y1 = cpy;\n\t          cpx = p[off++];\n\t          cpy = p[off++];\n\t          cmd = CMD.A;\n\t          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n\t          break;\n\t\n\t        case 'a':\n\t          rx = p[off++];\n\t          ry = p[off++];\n\t          psi = p[off++];\n\t          fa = p[off++];\n\t          fs = p[off++];\n\t          x1 = cpx, y1 = cpy;\n\t          cpx += p[off++];\n\t          cpy += p[off++];\n\t          cmd = CMD.A;\n\t          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n\t          break;\n\t      }\n\t    }\n\t\n\t    if (c === 'z' || c === 'Z') {\n\t      cmd = CMD.Z;\n\t      path.addData(cmd);\n\t    }\n\t\n\t    prevCmd = cmd;\n\t  }\n\t\n\t  path.toStatic();\n\t  return path;\n\t} // TODO Optimize double memory cost problem\n\t\n\t\n\tfunction createPathOptions(str, opts) {\n\t  var pathProxy = createPathProxyFromString(str);\n\t  opts = opts || {};\n\t\n\t  opts.buildPath = function (path) {\n\t    if (path.setData) {\n\t      path.setData(pathProxy.data); // Svg and vml renderer don't have context\n\t\n\t      var ctx = path.getContext();\n\t\n\t      if (ctx) {\n\t        path.rebuildPath(ctx);\n\t      }\n\t    } else {\n\t      var ctx = path;\n\t      pathProxy.rebuildPath(ctx);\n\t    }\n\t  };\n\t\n\t  opts.applyTransform = function (m) {\n\t    transformPath(pathProxy, m);\n\t    this.dirty(true);\n\t  };\n\t\n\t  return opts;\n\t}\n\t/**\n\t * Create a Path object from path string data\n\t * http://www.w3.org/TR/SVG/paths.html#PathData\n\t * @param  {Object} opts Other options\n\t */\n\t\n\t\n\tfunction createFromString(str, opts) {\n\t  return new Path(createPathOptions(str, opts));\n\t}\n\t/**\n\t * Create a Path class from path string data\n\t * @param  {string} str\n\t * @param  {Object} opts Other options\n\t */\n\t\n\t\n\tfunction extendFromString(str, opts) {\n\t  return Path.extend(createPathOptions(str, opts));\n\t}\n\t/**\n\t * Merge multiple paths\n\t */\n\t// TODO Apply transform\n\t// TODO stroke dash\n\t// TODO Optimize double memory cost problem\n\t\n\t\n\tfunction mergePath(pathEls, opts) {\n\t  var pathList = [];\n\t  var len = pathEls.length;\n\t\n\t  for (var i = 0; i < len; i++) {\n\t    var pathEl = pathEls[i];\n\t\n\t    if (!pathEl.path) {\n\t      pathEl.createPathProxy();\n\t    }\n\t\n\t    if (pathEl.__dirtyPath) {\n\t      pathEl.buildPath(pathEl.path, pathEl.shape, true);\n\t    }\n\t\n\t    pathList.push(pathEl.path);\n\t  }\n\t\n\t  var pathBundle = new Path(opts); // Need path proxy.\n\t\n\t  pathBundle.createPathProxy();\n\t\n\t  pathBundle.buildPath = function (path) {\n\t    path.appendPath(pathList); // Svg and vml renderer don't have context\n\t\n\t    var ctx = path.getContext();\n\t\n\t    if (ctx) {\n\t      path.rebuildPath(ctx);\n\t    }\n\t  };\n\t\n\t  return pathBundle;\n\t}\n\t\n\texports.createFromString = createFromString;\n\texports.extendFromString = extendFromString;\n\texports.mergePath = mergePath;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Displayable = __webpack_require__(7);\n\t\n\tvar zrUtil = __webpack_require__(4);\n\t\n\tvar PathProxy = __webpack_require__(29);\n\t\n\tvar pathContain = __webpack_require__(32);\n\t\n\tvar Pattern = __webpack_require__(39);\n\t\n\tvar getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\tvar abs = Math.abs;\n\tvar pathProxyForDraw = new PathProxy(true);\n\t/**\n\t * @alias module:zrender/graphic/Path\n\t * @extends module:zrender/graphic/Displayable\n\t * @constructor\n\t * @param {Object} opts\n\t */\n\t\n\tfunction Path(opts) {\n\t  Displayable.call(this, opts);\n\t  /**\n\t   * @type {module:zrender/core/PathProxy}\n\t   * @readOnly\n\t   */\n\t\n\t  this.path = null;\n\t}\n\t\n\tPath.prototype = {\n\t  constructor: Path,\n\t  type: 'path',\n\t  __dirtyPath: true,\n\t  strokeContainThreshold: 5,\n\t  brush: function (ctx, prevEl) {\n\t    var style = this.style;\n\t    var path = this.path || pathProxyForDraw;\n\t    var hasStroke = style.hasStroke();\n\t    var hasFill = style.hasFill();\n\t    var fill = style.fill;\n\t    var stroke = style.stroke;\n\t    var hasFillGradient = hasFill && !!fill.colorStops;\n\t    var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n\t    var hasFillPattern = hasFill && !!fill.image;\n\t    var hasStrokePattern = hasStroke && !!stroke.image;\n\t    style.bind(ctx, this, prevEl);\n\t    this.setTransform(ctx);\n\t\n\t    if (this.__dirty) {\n\t      var rect; // Update gradient because bounding rect may changed\n\t\n\t      if (hasFillGradient) {\n\t        rect = rect || this.getBoundingRect();\n\t        this._fillGradient = style.getGradient(ctx, fill, rect);\n\t      }\n\t\n\t      if (hasStrokeGradient) {\n\t        rect = rect || this.getBoundingRect();\n\t        this._strokeGradient = style.getGradient(ctx, stroke, rect);\n\t      }\n\t    } // Use the gradient or pattern\n\t\n\t\n\t    if (hasFillGradient) {\n\t      // PENDING If may have affect the state\n\t      ctx.fillStyle = this._fillGradient;\n\t    } else if (hasFillPattern) {\n\t      ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n\t    }\n\t\n\t    if (hasStrokeGradient) {\n\t      ctx.strokeStyle = this._strokeGradient;\n\t    } else if (hasStrokePattern) {\n\t      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n\t    }\n\t\n\t    var lineDash = style.lineDash;\n\t    var lineDashOffset = style.lineDashOffset;\n\t    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy\n\t\n\t    var scale = this.getGlobalScale();\n\t    path.setScale(scale[0], scale[1]); // Proxy context\n\t    // Rebuild path in following 2 cases\n\t    // 1. Path is dirty\n\t    // 2. Path needs javascript implemented lineDash stroking.\n\t    //    In this case, lineDash information will not be saved in PathProxy\n\t\n\t    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n\t      path.beginPath(ctx); // Setting line dash before build path\n\t\n\t      if (lineDash && !ctxLineDash) {\n\t        path.setLineDash(lineDash);\n\t        path.setLineDashOffset(lineDashOffset);\n\t      }\n\t\n\t      this.buildPath(path, this.shape, false); // Clear path dirty flag\n\t\n\t      if (this.path) {\n\t        this.__dirtyPath = false;\n\t      }\n\t    } else {\n\t      // Replay path building\n\t      ctx.beginPath();\n\t      this.path.rebuildPath(ctx);\n\t    }\n\t\n\t    hasFill && path.fill(ctx);\n\t\n\t    if (lineDash && ctxLineDash) {\n\t      ctx.setLineDash(lineDash);\n\t      ctx.lineDashOffset = lineDashOffset;\n\t    }\n\t\n\t    hasStroke && path.stroke(ctx);\n\t\n\t    if (lineDash && ctxLineDash) {\n\t      // PENDING\n\t      // Remove lineDash\n\t      ctx.setLineDash([]);\n\t    }\n\t\n\t    this.restoreTransform(ctx); // Draw rect text\n\t\n\t    if (style.text != null) {\n\t      this.drawRectText(ctx, this.getBoundingRect());\n\t    }\n\t  },\n\t  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n\t  // Like in circle\n\t  buildPath: function (ctx, shapeCfg, inBundle) {},\n\t  createPathProxy: function () {\n\t    this.path = new PathProxy();\n\t  },\n\t  getBoundingRect: function () {\n\t    var rect = this._rect;\n\t    var style = this.style;\n\t    var needsUpdateRect = !rect;\n\t\n\t    if (needsUpdateRect) {\n\t      var path = this.path;\n\t\n\t      if (!path) {\n\t        // Create path on demand.\n\t        path = this.path = new PathProxy();\n\t      }\n\t\n\t      if (this.__dirtyPath) {\n\t        path.beginPath();\n\t        this.buildPath(path, this.shape, false);\n\t      }\n\t\n\t      rect = path.getBoundingRect();\n\t    }\n\t\n\t    this._rect = rect;\n\t\n\t    if (style.hasStroke()) {\n\t      // Needs update rect with stroke lineWidth when\n\t      // 1. Element changes scale or lineWidth\n\t      // 2. Shape is changed\n\t      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\t\n\t      if (this.__dirty || needsUpdateRect) {\n\t        rectWithStroke.copy(rect); // FIXME Must after updateTransform\n\t\n\t        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical\n\t\n\t        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill\n\t\n\t        if (!style.hasFill()) {\n\t          w = Math.max(w, this.strokeContainThreshold || 4);\n\t        } // Consider line width\n\t        // Line scale can't be 0;\n\t\n\t\n\t        if (lineScale > 1e-10) {\n\t          rectWithStroke.width += w / lineScale;\n\t          rectWithStroke.height += w / lineScale;\n\t          rectWithStroke.x -= w / lineScale / 2;\n\t          rectWithStroke.y -= w / lineScale / 2;\n\t        }\n\t      } // Return rect with stroke\n\t\n\t\n\t      return rectWithStroke;\n\t    }\n\t\n\t    return rect;\n\t  },\n\t  contain: function (x, y) {\n\t    var localPos = this.transformCoordToLocal(x, y);\n\t    var rect = this.getBoundingRect();\n\t    var style = this.style;\n\t    x = localPos[0];\n\t    y = localPos[1];\n\t\n\t    if (rect.contain(x, y)) {\n\t      var pathData = this.path.data;\n\t\n\t      if (style.hasStroke()) {\n\t        var lineWidth = style.lineWidth;\n\t        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;\n\t\n\t        if (lineScale > 1e-10) {\n\t          // Only add extra hover lineWidth when there are no fill\n\t          if (!style.hasFill()) {\n\t            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n\t          }\n\t\n\t          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n\t            return true;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (style.hasFill()) {\n\t        return pathContain.contain(pathData, x, y);\n\t      }\n\t    }\n\t\n\t    return false;\n\t  },\n\t\n\t  /**\n\t   * @param  {boolean} dirtyPath\n\t   */\n\t  dirty: function (dirtyPath) {\n\t    if (dirtyPath == null) {\n\t      dirtyPath = true;\n\t    } // Only mark dirty, not mark clean\n\t\n\t\n\t    if (dirtyPath) {\n\t      this.__dirtyPath = dirtyPath;\n\t      this._rect = null;\n\t    }\n\t\n\t    this.__dirty = true;\n\t    this.__zr && this.__zr.refresh(); // Used as a clipping path\n\t\n\t    if (this.__clipTarget) {\n\t      this.__clipTarget.dirty();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Alias for animate('shape')\n\t   * @param {boolean} loop\n\t   */\n\t  animateShape: function (loop) {\n\t    return this.animate('shape', loop);\n\t  },\n\t  // Overwrite attrKV\n\t  attrKV: function (key, value) {\n\t    // FIXME\n\t    if (key === 'shape') {\n\t      this.setShape(value);\n\t      this.__dirtyPath = true;\n\t      this._rect = null;\n\t    } else {\n\t      Displayable.prototype.attrKV.call(this, key, value);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @param {Object|string} key\n\t   * @param {*} value\n\t   */\n\t  setShape: function (key, value) {\n\t    var shape = this.shape; // Path from string may not have shape\n\t\n\t    if (shape) {\n\t      if (zrUtil.isObject(key)) {\n\t        for (var name in key) {\n\t          if (key.hasOwnProperty(name)) {\n\t            shape[name] = key[name];\n\t          }\n\t        }\n\t      } else {\n\t        shape[key] = value;\n\t      }\n\t\n\t      this.dirty(true);\n\t    }\n\t\n\t    return this;\n\t  },\n\t  getLineScale: function () {\n\t    var m = this.transform; // Get the line scale.\n\t    // Determinant of `m` means how much the area is enlarged by the\n\t    // transformation. So its square root can be used as a scale factor\n\t    // for width.\n\t\n\t    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n\t  }\n\t};\n\t/**\n\t * 扩展一个 Path element, 比如星形，圆等。\n\t * Extend a path element\n\t * @param {Object} props\n\t * @param {string} props.type Path type\n\t * @param {Function} props.init Initialize\n\t * @param {Function} props.buildPath Overwrite buildPath method\n\t * @param {Object} [props.style] Extended default style config\n\t * @param {Object} [props.shape] Extended default shape config\n\t */\n\t\n\tPath.extend = function (defaults) {\n\t  var Sub = function (opts) {\n\t    Path.call(this, opts);\n\t\n\t    if (defaults.style) {\n\t      // Extend default style\n\t      this.style.extendFrom(defaults.style, false);\n\t    } // Extend default shape\n\t\n\t\n\t    var defaultShape = defaults.shape;\n\t\n\t    if (defaultShape) {\n\t      this.shape = this.shape || {};\n\t      var thisShape = this.shape;\n\t\n\t      for (var name in defaultShape) {\n\t        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n\t          thisShape[name] = defaultShape[name];\n\t        }\n\t      }\n\t    }\n\t\n\t    defaults.init && defaults.init.call(this, opts);\n\t  };\n\t\n\t  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象\n\t\n\t  for (var name in defaults) {\n\t    // Extending prototype values and methods\n\t    if (name !== 'style' && name !== 'shape') {\n\t      Sub.prototype[name] = defaults[name];\n\t    }\n\t  }\n\t\n\t  return Sub;\n\t};\n\t\n\tzrUtil.inherits(Path, Displayable);\n\tvar _default = Path;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrUtil = __webpack_require__(4);\n\t\n\tvar Style = __webpack_require__(8);\n\t\n\tvar Element = __webpack_require__(9);\n\t\n\tvar RectText = __webpack_require__(23);\n\t\n\t/**\n\t * 可绘制的图形基类\n\t * Base class of all displayable graphic objects\n\t * @module zrender/graphic/Displayable\n\t */\n\t\n\t/**\n\t * @alias module:zrender/graphic/Displayable\n\t * @extends module:zrender/Element\n\t * @extends module:zrender/graphic/mixin/RectText\n\t */\n\tfunction Displayable(opts) {\n\t  opts = opts || {};\n\t  Element.call(this, opts); // Extend properties\n\t\n\t  for (var name in opts) {\n\t    if (opts.hasOwnProperty(name) && name !== 'style') {\n\t      this[name] = opts[name];\n\t    }\n\t  }\n\t  /**\n\t   * @type {module:zrender/graphic/Style}\n\t   */\n\t\n\t\n\t  this.style = new Style(opts.style, this);\n\t  this._rect = null; // Shapes for cascade clipping.\n\t\n\t  this.__clipPaths = []; // FIXME Stateful must be mixined after style is setted\n\t  // Stateful.call(this, opts);\n\t}\n\t\n\tDisplayable.prototype = {\n\t  constructor: Displayable,\n\t  type: 'displayable',\n\t\n\t  /**\n\t   * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制\n\t   * Dirty flag. From which painter will determine if this displayable object needs brush\n\t   * @name module:zrender/graphic/Displayable#__dirty\n\t   * @type {boolean}\n\t   */\n\t  __dirty: true,\n\t\n\t  /**\n\t   * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\n\t   * If ignore drawing of the displayable object. Mouse event will still be triggered\n\t   * @name module:/zrender/graphic/Displayable#invisible\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  invisible: false,\n\t\n\t  /**\n\t   * @name module:/zrender/graphic/Displayable#z\n\t   * @type {number}\n\t   * @default 0\n\t   */\n\t  z: 0,\n\t\n\t  /**\n\t   * @name module:/zrender/graphic/Displayable#z\n\t   * @type {number}\n\t   * @default 0\n\t   */\n\t  z2: 0,\n\t\n\t  /**\n\t   * z层level，决定绘画在哪层canvas中\n\t   * @name module:/zrender/graphic/Displayable#zlevel\n\t   * @type {number}\n\t   * @default 0\n\t   */\n\t  zlevel: 0,\n\t\n\t  /**\n\t   * 是否可拖拽\n\t   * @name module:/zrender/graphic/Displayable#draggable\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  draggable: false,\n\t\n\t  /**\n\t   * 是否正在拖拽\n\t   * @name module:/zrender/graphic/Displayable#draggable\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  dragging: false,\n\t\n\t  /**\n\t   * 是否相应鼠标事件\n\t   * @name module:/zrender/graphic/Displayable#silent\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  silent: false,\n\t\n\t  /**\n\t   * If enable culling\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  culling: false,\n\t\n\t  /**\n\t   * Mouse cursor when hovered\n\t   * @name module:/zrender/graphic/Displayable#cursor\n\t   * @type {string}\n\t   */\n\t  cursor: 'pointer',\n\t\n\t  /**\n\t   * If hover area is bounding rect\n\t   * @name module:/zrender/graphic/Displayable#rectHover\n\t   * @type {string}\n\t   */\n\t  rectHover: false,\n\t\n\t  /**\n\t   * Render the element progressively when the value >= 0,\n\t   * usefull for large data.\n\t   * @type {number}\n\t   */\n\t  progressive: -1,\n\t  beforeBrush: function (ctx) {},\n\t  afterBrush: function (ctx) {},\n\t\n\t  /**\n\t   * 图形绘制方法\n\t   * @param {CanvasRenderingContext2D} ctx\n\t   */\n\t  // Interface\n\t  brush: function (ctx, prevEl) {},\n\t\n\t  /**\n\t   * 获取最小包围盒\n\t   * @return {module:zrender/core/BoundingRect}\n\t   */\n\t  // Interface\n\t  getBoundingRect: function () {},\n\t\n\t  /**\n\t   * 判断坐标 x, y 是否在图形上\n\t   * If displayable element contain coord x, y\n\t   * @param  {number} x\n\t   * @param  {number} y\n\t   * @return {boolean}\n\t   */\n\t  contain: function (x, y) {\n\t    return this.rectContain(x, y);\n\t  },\n\t\n\t  /**\n\t   * @param  {Function} cb\n\t   * @param  {}   context\n\t   */\n\t  traverse: function (cb, context) {\n\t    cb.call(context, this);\n\t  },\n\t\n\t  /**\n\t   * 判断坐标 x, y 是否在图形的包围盒上\n\t   * If bounding rect of element contain coord x, y\n\t   * @param  {number} x\n\t   * @param  {number} y\n\t   * @return {boolean}\n\t   */\n\t  rectContain: function (x, y) {\n\t    var coord = this.transformCoordToLocal(x, y);\n\t    var rect = this.getBoundingRect();\n\t    return rect.contain(coord[0], coord[1]);\n\t  },\n\t\n\t  /**\n\t   * 标记图形元素为脏，并且在下一帧重绘\n\t   * Mark displayable element dirty and refresh next frame\n\t   */\n\t  dirty: function () {\n\t    this.__dirty = true;\n\t    this._rect = null;\n\t    this.__zr && this.__zr.refresh();\n\t  },\n\t\n\t  /**\n\t   * 图形是否会触发事件\n\t   * If displayable object binded any event\n\t   * @return {boolean}\n\t   */\n\t  // TODO, 通过 bind 绑定的事件\n\t  // isSilent: function () {\n\t  //     return !(\n\t  //         this.hoverable || this.draggable\n\t  //         || this.onmousemove || this.onmouseover || this.onmouseout\n\t  //         || this.onmousedown || this.onmouseup || this.onclick\n\t  //         || this.ondragenter || this.ondragover || this.ondragleave\n\t  //         || this.ondrop\n\t  //     );\n\t  // },\n\t\n\t  /**\n\t   * Alias for animate('style')\n\t   * @param {boolean} loop\n\t   */\n\t  animateStyle: function (loop) {\n\t    return this.animate('style', loop);\n\t  },\n\t  attrKV: function (key, value) {\n\t    if (key !== 'style') {\n\t      Element.prototype.attrKV.call(this, key, value);\n\t    } else {\n\t      this.style.set(value);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @param {Object|string} key\n\t   * @param {*} value\n\t   */\n\t  setStyle: function (key, value) {\n\t    this.style.set(key, value);\n\t    this.dirty(false);\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * Use given style object\n\t   * @param  {Object} obj\n\t   */\n\t  useStyle: function (obj) {\n\t    this.style = new Style(obj, this);\n\t    this.dirty(false);\n\t    return this;\n\t  }\n\t};\n\tzrUtil.inherits(Displayable, Element);\n\tzrUtil.mixin(Displayable, RectText); // zrUtil.mixin(Displayable, Stateful);\n\t\n\tvar _default = Displayable;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n\tvar STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n\t// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\t\n\tvar Style = function (opts, host) {\n\t  this.extendFrom(opts, false);\n\t  this.host = host;\n\t};\n\t\n\tfunction createLinearGradient(ctx, obj, rect) {\n\t  var x = obj.x == null ? 0 : obj.x;\n\t  var x2 = obj.x2 == null ? 1 : obj.x2;\n\t  var y = obj.y == null ? 0 : obj.y;\n\t  var y2 = obj.y2 == null ? 0 : obj.y2;\n\t\n\t  if (!obj.global) {\n\t    x = x * rect.width + rect.x;\n\t    x2 = x2 * rect.width + rect.x;\n\t    y = y * rect.height + rect.y;\n\t    y2 = y2 * rect.height + rect.y;\n\t  }\n\t\n\t  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\t  return canvasGradient;\n\t}\n\t\n\tfunction createRadialGradient(ctx, obj, rect) {\n\t  var width = rect.width;\n\t  var height = rect.height;\n\t  var min = Math.min(width, height);\n\t  var x = obj.x == null ? 0.5 : obj.x;\n\t  var y = obj.y == null ? 0.5 : obj.y;\n\t  var r = obj.r == null ? 0.5 : obj.r;\n\t\n\t  if (!obj.global) {\n\t    x = x * width + rect.x;\n\t    y = y * height + rect.y;\n\t    r = r * min;\n\t  }\n\t\n\t  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\t  return canvasGradient;\n\t}\n\t\n\tStyle.prototype = {\n\t  constructor: Style,\n\t\n\t  /**\n\t   * @type {module:zrender/graphic/Displayable}\n\t   */\n\t  host: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  fill: '#000',\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  stroke: null,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  opacity: 1,\n\t\n\t  /**\n\t   * @type {Array.<number>}\n\t   */\n\t  lineDash: null,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  lineDashOffset: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  shadowBlur: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  shadowOffsetX: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  shadowOffsetY: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  lineWidth: 1,\n\t\n\t  /**\n\t   * If stroke ignore scale\n\t   * @type {Boolean}\n\t   */\n\t  strokeNoScale: false,\n\t  // Bounding rect text configuration\n\t  // Not affected by element transform\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  text: null,\n\t\n\t  /**\n\t   * If `fontSize` or `fontFamily` exists, `font` will be reset by\n\t   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.\n\t   * So do not visit it directly in upper application (like echarts),\n\t   * but use `contain/text#makeFont` instead.\n\t   * @type {string}\n\t   */\n\t  font: null,\n\t\n\t  /**\n\t   * The same as font. Use font please.\n\t   * @deprecated\n\t   * @type {string}\n\t   */\n\t  textFont: null,\n\t\n\t  /**\n\t   * It helps merging respectively, rather than parsing an entire font string.\n\t   * @type {string}\n\t   */\n\t  fontStyle: null,\n\t\n\t  /**\n\t   * It helps merging respectively, rather than parsing an entire font string.\n\t   * @type {string}\n\t   */\n\t  fontWeight: null,\n\t\n\t  /**\n\t   * It helps merging respectively, rather than parsing an entire font string.\n\t   * Should be 12 but not '12px'.\n\t   * @type {number}\n\t   */\n\t  fontSize: null,\n\t\n\t  /**\n\t   * It helps merging respectively, rather than parsing an entire font string.\n\t   * @type {string}\n\t   */\n\t  fontFamily: null,\n\t\n\t  /**\n\t   * Reserved for special functinality, like 'hr'.\n\t   * @type {string}\n\t   */\n\t  textTag: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textFill: '#000',\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textStroke: null,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textWidth: null,\n\t\n\t  /**\n\t   * Only for textBackground.\n\t   * @type {number}\n\t   */\n\t  textHeight: null,\n\t\n\t  /**\n\t   * textStroke may be set as some color as a default\n\t   * value in upper applicaion, where the default value\n\t   * of textStrokeWidth should be 0 to make sure that\n\t   * user can choose to do not use text stroke.\n\t   * @type {number}\n\t   */\n\t  textStrokeWidth: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textLineHeight: null,\n\t\n\t  /**\n\t   * 'inside', 'left', 'right', 'top', 'bottom'\n\t   * [x, y]\n\t   * Based on x, y of rect.\n\t   * @type {string|Array.<number>}\n\t   * @default 'inside'\n\t   */\n\t  textPosition: 'inside',\n\t\n\t  /**\n\t   * If not specified, use the boundingRect of a `displayable`.\n\t   * @type {Object}\n\t   */\n\t  textRect: null,\n\t\n\t  /**\n\t   * [x, y]\n\t   * @type {Array.<number>}\n\t   */\n\t  textOffset: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textAlign: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textVerticalAlign: null,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textDistance: 5,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textShadowColor: 'transparent',\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textShadowBlur: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textShadowOffsetX: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textShadowOffsetY: 0,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textBoxShadowColor: 'transparent',\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textBoxShadowBlur: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textBoxShadowOffsetX: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textBoxShadowOffsetY: 0,\n\t\n\t  /**\n\t   * Whether transform text.\n\t   * Only useful in Path and Image element\n\t   * @type {boolean}\n\t   */\n\t  transformText: false,\n\t\n\t  /**\n\t   * Text rotate around position of Path or Image\n\t   * Only useful in Path and Image element and transformText is false.\n\t   */\n\t  textRotation: 0,\n\t\n\t  /**\n\t   * Text origin of text rotation, like [10, 40].\n\t   * Based on x, y of rect.\n\t   * Useful in label rotation of circular symbol.\n\t   * By default, this origin is textPosition.\n\t   * Can be 'center'.\n\t   * @type {string|Array.<number>}\n\t   */\n\t  textOrigin: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textBackgroundColor: null,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  textBorderColor: null,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textBorderWidth: 0,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  textBorderRadius: 0,\n\t\n\t  /**\n\t   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`\n\t   * @type {number|Array.<number>}\n\t   */\n\t  textPadding: null,\n\t\n\t  /**\n\t   * Text styles for rich text.\n\t   * @type {Object}\n\t   */\n\t  rich: null,\n\t\n\t  /**\n\t   * {outerWidth, outerHeight, ellipsis, placeholder}\n\t   * @type {Object}\n\t   */\n\t  truncate: null,\n\t\n\t  /**\n\t   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n\t   * @type {string}\n\t   */\n\t  blend: null,\n\t\n\t  /**\n\t   * @param {CanvasRenderingContext2D} ctx\n\t   */\n\t  bind: function (ctx, el, prevEl) {\n\t    var style = this;\n\t    var prevStyle = prevEl && prevEl.style;\n\t    var firstDraw = !prevStyle;\n\t\n\t    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t      var prop = STYLE_COMMON_PROPS[i];\n\t      var styleName = prop[0];\n\t\n\t      if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n\t        // FIXME Invalid property value will cause style leak from previous element.\n\t        ctx[styleName] = style[styleName] || prop[1];\n\t      }\n\t    }\n\t\n\t    if (firstDraw || style.fill !== prevStyle.fill) {\n\t      ctx.fillStyle = style.fill;\n\t    }\n\t\n\t    if (firstDraw || style.stroke !== prevStyle.stroke) {\n\t      ctx.strokeStyle = style.stroke;\n\t    }\n\t\n\t    if (firstDraw || style.opacity !== prevStyle.opacity) {\n\t      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n\t    }\n\t\n\t    if (firstDraw || style.blend !== prevStyle.blend) {\n\t      ctx.globalCompositeOperation = style.blend || 'source-over';\n\t    }\n\t\n\t    if (this.hasStroke()) {\n\t      var lineWidth = style.lineWidth;\n\t      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);\n\t    }\n\t  },\n\t  hasFill: function () {\n\t    var fill = this.fill;\n\t    return fill != null && fill !== 'none';\n\t  },\n\t  hasStroke: function () {\n\t    var stroke = this.stroke;\n\t    return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n\t  },\n\t\n\t  /**\n\t   * Extend from other style\n\t   * @param {zrender/graphic/Style} otherStyle\n\t   * @param {boolean} overwrite true: overwrirte any way.\n\t   *                            false: overwrite only when !target.hasOwnProperty\n\t   *                            others: overwrite when property is not null/undefined.\n\t   */\n\t  extendFrom: function (otherStyle, overwrite) {\n\t    if (otherStyle) {\n\t      for (var name in otherStyle) {\n\t        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {\n\t          this[name] = otherStyle[name];\n\t        }\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Batch setting style with a given object\n\t   * @param {Object|string} obj\n\t   * @param {*} [obj]\n\t   */\n\t  set: function (obj, value) {\n\t    if (typeof obj === 'string') {\n\t      this[obj] = value;\n\t    } else {\n\t      this.extendFrom(obj, true);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Clone\n\t   * @return {zrender/graphic/Style} [description]\n\t   */\n\t  clone: function () {\n\t    var newStyle = new this.constructor();\n\t    newStyle.extendFrom(this, true);\n\t    return newStyle;\n\t  },\n\t  getGradient: function (ctx, obj, rect) {\n\t    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n\t    var canvasGradient = method(ctx, obj, rect);\n\t    var colorStops = obj.colorStops;\n\t\n\t    for (var i = 0; i < colorStops.length; i++) {\n\t      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n\t    }\n\t\n\t    return canvasGradient;\n\t  }\n\t};\n\tvar styleProto = Style.prototype;\n\t\n\tfor (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t  var prop = STYLE_COMMON_PROPS[i];\n\t\n\t  if (!(prop[0] in styleProto)) {\n\t    styleProto[prop[0]] = prop[1];\n\t  }\n\t} // Provide for others\n\t\n\t\n\tStyle.getGradient = styleProto.getGradient;\n\tvar _default = Style;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar guid = __webpack_require__(10);\n\t\n\tvar Eventful = __webpack_require__(11);\n\t\n\tvar Transformable = __webpack_require__(12);\n\t\n\tvar Animatable = __webpack_require__(15);\n\t\n\tvar zrUtil = __webpack_require__(4);\n\t\n\t/**\n\t * @alias module:zrender/Element\n\t * @constructor\n\t * @extends {module:zrender/mixin/Animatable}\n\t * @extends {module:zrender/mixin/Transformable}\n\t * @extends {module:zrender/mixin/Eventful}\n\t */\n\tvar Element = function (opts) {\n\t  // jshint ignore:line\n\t  Transformable.call(this, opts);\n\t  Eventful.call(this, opts);\n\t  Animatable.call(this, opts);\n\t  /**\n\t   * 画布元素ID\n\t   * @type {string}\n\t   */\n\t\n\t  this.id = opts.id || guid();\n\t};\n\t\n\tElement.prototype = {\n\t  /**\n\t   * 元素类型\n\t   * Element type\n\t   * @type {string}\n\t   */\n\t  type: 'element',\n\t\n\t  /**\n\t   * 元素名字\n\t   * Element name\n\t   * @type {string}\n\t   */\n\t  name: '',\n\t\n\t  /**\n\t   * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n\t   * ZRender instance will be assigned when element is associated with zrender\n\t   * @name module:/zrender/Element#__zr\n\t   * @type {module:zrender/ZRender}\n\t   */\n\t  __zr: null,\n\t\n\t  /**\n\t   * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n\t   * If ignore drawing and events of the element object\n\t   * @name module:/zrender/Element#ignore\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  ignore: false,\n\t\n\t  /**\n\t   * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n\t   * 该路径会继承被裁减对象的变换\n\t   * @type {module:zrender/graphic/Path}\n\t   * @see http://www.w3.org/TR/2dcontext/#clipping-region\n\t   * @readOnly\n\t   */\n\t  clipPath: null,\n\t\n\t  /**\n\t   * Drift element\n\t   * @param  {number} dx dx on the global space\n\t   * @param  {number} dy dy on the global space\n\t   */\n\t  drift: function (dx, dy) {\n\t    switch (this.draggable) {\n\t      case 'horizontal':\n\t        dy = 0;\n\t        break;\n\t\n\t      case 'vertical':\n\t        dx = 0;\n\t        break;\n\t    }\n\t\n\t    var m = this.transform;\n\t\n\t    if (!m) {\n\t      m = this.transform = [1, 0, 0, 1, 0, 0];\n\t    }\n\t\n\t    m[4] += dx;\n\t    m[5] += dy;\n\t    this.decomposeTransform();\n\t    this.dirty(false);\n\t  },\n\t\n\t  /**\n\t   * Hook before update\n\t   */\n\t  beforeUpdate: function () {},\n\t\n\t  /**\n\t   * Hook after update\n\t   */\n\t  afterUpdate: function () {},\n\t\n\t  /**\n\t   * Update each frame\n\t   */\n\t  update: function () {\n\t    this.updateTransform();\n\t  },\n\t\n\t  /**\n\t   * @param  {Function} cb\n\t   * @param  {}   context\n\t   */\n\t  traverse: function (cb, context) {},\n\t\n\t  /**\n\t   * @protected\n\t   */\n\t  attrKV: function (key, value) {\n\t    if (key === 'position' || key === 'scale' || key === 'origin') {\n\t      // Copy the array\n\t      if (value) {\n\t        var target = this[key];\n\t\n\t        if (!target) {\n\t          target = this[key] = [];\n\t        }\n\t\n\t        target[0] = value[0];\n\t        target[1] = value[1];\n\t      }\n\t    } else {\n\t      this[key] = value;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Hide the element\n\t   */\n\t  hide: function () {\n\t    this.ignore = true;\n\t    this.__zr && this.__zr.refresh();\n\t  },\n\t\n\t  /**\n\t   * Show the element\n\t   */\n\t  show: function () {\n\t    this.ignore = false;\n\t    this.__zr && this.__zr.refresh();\n\t  },\n\t\n\t  /**\n\t   * @param {string|Object} key\n\t   * @param {*} value\n\t   */\n\t  attr: function (key, value) {\n\t    if (typeof key === 'string') {\n\t      this.attrKV(key, value);\n\t    } else if (zrUtil.isObject(key)) {\n\t      for (var name in key) {\n\t        if (key.hasOwnProperty(name)) {\n\t          this.attrKV(name, key[name]);\n\t        }\n\t      }\n\t    }\n\t\n\t    this.dirty(false);\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param {module:zrender/graphic/Path} clipPath\n\t   */\n\t  setClipPath: function (clipPath) {\n\t    var zr = this.__zr;\n\t\n\t    if (zr) {\n\t      clipPath.addSelfToZr(zr);\n\t    } // Remove previous clip path\n\t\n\t\n\t    if (this.clipPath && this.clipPath !== clipPath) {\n\t      this.removeClipPath();\n\t    }\n\t\n\t    this.clipPath = clipPath;\n\t    clipPath.__zr = zr;\n\t    clipPath.__clipTarget = this;\n\t    this.dirty(false);\n\t  },\n\t\n\t  /**\n\t   */\n\t  removeClipPath: function () {\n\t    var clipPath = this.clipPath;\n\t\n\t    if (clipPath) {\n\t      if (clipPath.__zr) {\n\t        clipPath.removeSelfFromZr(clipPath.__zr);\n\t      }\n\t\n\t      clipPath.__zr = null;\n\t      clipPath.__clipTarget = null;\n\t      this.clipPath = null;\n\t      this.dirty(false);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Add self from zrender instance.\n\t   * Not recursively because it will be invoked when element added to storage.\n\t   * @param {module:zrender/ZRender} zr\n\t   */\n\t  addSelfToZr: function (zr) {\n\t    this.__zr = zr; // 添加动画\n\t\n\t    var animators = this.animators;\n\t\n\t    if (animators) {\n\t      for (var i = 0; i < animators.length; i++) {\n\t        zr.animation.addAnimator(animators[i]);\n\t      }\n\t    }\n\t\n\t    if (this.clipPath) {\n\t      this.clipPath.addSelfToZr(zr);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Remove self from zrender instance.\n\t   * Not recursively because it will be invoked when element added to storage.\n\t   * @param {module:zrender/ZRender} zr\n\t   */\n\t  removeSelfFromZr: function (zr) {\n\t    this.__zr = null; // 移除动画\n\t\n\t    var animators = this.animators;\n\t\n\t    if (animators) {\n\t      for (var i = 0; i < animators.length; i++) {\n\t        zr.animation.removeAnimator(animators[i]);\n\t      }\n\t    }\n\t\n\t    if (this.clipPath) {\n\t      this.clipPath.removeSelfFromZr(zr);\n\t    }\n\t  }\n\t};\n\tzrUtil.mixin(Element, Animatable);\n\tzrUtil.mixin(Element, Transformable);\n\tzrUtil.mixin(Element, Eventful);\n\tvar _default = Element;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * zrender: 生成唯一id\n\t *\n\t * @author errorrik (errorrik@gmail.com)\n\t */\n\tvar idStart = 0x0907;\n\t\n\tfunction _default() {\n\t  return idStart++;\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * 事件扩展\n\t * @module zrender/mixin/Eventful\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\tvar arrySlice = Array.prototype.slice;\n\t/**\n\t * 事件分发器\n\t * @alias module:zrender/mixin/Eventful\n\t * @constructor\n\t */\n\t\n\tvar Eventful = function () {\n\t  this._$handlers = {};\n\t};\n\t\n\tEventful.prototype = {\n\t  constructor: Eventful,\n\t\n\t  /**\n\t   * 单次触发绑定，trigger后销毁\n\t   *\n\t   * @param {string} event 事件名\n\t   * @param {Function} handler 响应函数\n\t   * @param {Object} context\n\t   */\n\t  one: function (event, handler, context) {\n\t    var _h = this._$handlers;\n\t\n\t    if (!handler || !event) {\n\t      return this;\n\t    }\n\t\n\t    if (!_h[event]) {\n\t      _h[event] = [];\n\t    }\n\t\n\t    for (var i = 0; i < _h[event].length; i++) {\n\t      if (_h[event][i].h === handler) {\n\t        return this;\n\t      }\n\t    }\n\t\n\t    _h[event].push({\n\t      h: handler,\n\t      one: true,\n\t      ctx: context || this\n\t    });\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 绑定事件\n\t   * @param {string} event 事件名\n\t   * @param {Function} handler 事件处理函数\n\t   * @param {Object} [context]\n\t   */\n\t  on: function (event, handler, context) {\n\t    var _h = this._$handlers;\n\t\n\t    if (!handler || !event) {\n\t      return this;\n\t    }\n\t\n\t    if (!_h[event]) {\n\t      _h[event] = [];\n\t    }\n\t\n\t    for (var i = 0; i < _h[event].length; i++) {\n\t      if (_h[event][i].h === handler) {\n\t        return this;\n\t      }\n\t    }\n\t\n\t    _h[event].push({\n\t      h: handler,\n\t      one: false,\n\t      ctx: context || this\n\t    });\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 是否绑定了事件\n\t   * @param  {string}  event\n\t   * @return {boolean}\n\t   */\n\t  isSilent: function (event) {\n\t    var _h = this._$handlers;\n\t    return _h[event] && _h[event].length;\n\t  },\n\t\n\t  /**\n\t   * 解绑事件\n\t   * @param {string} event 事件名\n\t   * @param {Function} [handler] 事件处理函数\n\t   */\n\t  off: function (event, handler) {\n\t    var _h = this._$handlers;\n\t\n\t    if (!event) {\n\t      this._$handlers = {};\n\t      return this;\n\t    }\n\t\n\t    if (handler) {\n\t      if (_h[event]) {\n\t        var newList = [];\n\t\n\t        for (var i = 0, l = _h[event].length; i < l; i++) {\n\t          if (_h[event][i]['h'] != handler) {\n\t            newList.push(_h[event][i]);\n\t          }\n\t        }\n\t\n\t        _h[event] = newList;\n\t      }\n\t\n\t      if (_h[event] && _h[event].length === 0) {\n\t        delete _h[event];\n\t      }\n\t    } else {\n\t      delete _h[event];\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 事件分发\n\t   *\n\t   * @param {string} type 事件类型\n\t   */\n\t  trigger: function (type) {\n\t    if (this._$handlers[type]) {\n\t      var args = arguments;\n\t      var argLen = args.length;\n\t\n\t      if (argLen > 3) {\n\t        args = arrySlice.call(args, 1);\n\t      }\n\t\n\t      var _h = this._$handlers[type];\n\t      var len = _h.length;\n\t\n\t      for (var i = 0; i < len;) {\n\t        // Optimize advise from backbone\n\t        switch (argLen) {\n\t          case 1:\n\t            _h[i]['h'].call(_h[i]['ctx']);\n\t\n\t            break;\n\t\n\t          case 2:\n\t            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\t\n\t            break;\n\t\n\t          case 3:\n\t            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\t\n\t            break;\n\t\n\t          default:\n\t            // have more than 2 given arguments\n\t            _h[i]['h'].apply(_h[i]['ctx'], args);\n\t\n\t            break;\n\t        }\n\t\n\t        if (_h[i]['one']) {\n\t          _h.splice(i, 1);\n\t\n\t          len--;\n\t        } else {\n\t          i++;\n\t        }\n\t      }\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 带有context的事件分发, 最后一个参数是事件回调的context\n\t   * @param {string} type 事件类型\n\t   */\n\t  triggerWithContext: function (type) {\n\t    if (this._$handlers[type]) {\n\t      var args = arguments;\n\t      var argLen = args.length;\n\t\n\t      if (argLen > 4) {\n\t        args = arrySlice.call(args, 1, args.length - 1);\n\t      }\n\t\n\t      var ctx = args[args.length - 1];\n\t      var _h = this._$handlers[type];\n\t      var len = _h.length;\n\t\n\t      for (var i = 0; i < len;) {\n\t        // Optimize advise from backbone\n\t        switch (argLen) {\n\t          case 1:\n\t            _h[i]['h'].call(ctx);\n\t\n\t            break;\n\t\n\t          case 2:\n\t            _h[i]['h'].call(ctx, args[1]);\n\t\n\t            break;\n\t\n\t          case 3:\n\t            _h[i]['h'].call(ctx, args[1], args[2]);\n\t\n\t            break;\n\t\n\t          default:\n\t            // have more than 2 given arguments\n\t            _h[i]['h'].apply(ctx, args);\n\t\n\t            break;\n\t        }\n\t\n\t        if (_h[i]['one']) {\n\t          _h.splice(i, 1);\n\t\n\t          len--;\n\t        } else {\n\t          i++;\n\t        }\n\t      }\n\t    }\n\t\n\t    return this;\n\t  }\n\t}; // 对象可以通过 onxxxx 绑定事件\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onclick\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmouseover\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmouseout\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmousemove\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmousewheel\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmousedown\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#onmouseup\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondrag\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondragstart\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondragend\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondragenter\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondragleave\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondragover\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\t/**\n\t * @event module:zrender/mixin/Eventful#ondrop\n\t * @type {Function}\n\t * @default null\n\t */\n\t\n\tvar _default = Eventful;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar matrix = __webpack_require__(13);\n\t\n\tvar vector = __webpack_require__(14);\n\t\n\t/**\n\t * 提供变换扩展\n\t * @module zrender/mixin/Transformable\n\t * @author pissang (https://www.github.com/pissang)\n\t */\n\tvar mIdentity = matrix.identity;\n\tvar EPSILON = 5e-5;\n\t\n\tfunction isNotAroundZero(val) {\n\t  return val > EPSILON || val < -EPSILON;\n\t}\n\t/**\n\t * @alias module:zrender/mixin/Transformable\n\t * @constructor\n\t */\n\t\n\t\n\tvar Transformable = function (opts) {\n\t  opts = opts || {}; // If there are no given position, rotation, scale\n\t\n\t  if (!opts.position) {\n\t    /**\n\t     * 平移\n\t     * @type {Array.<number>}\n\t     * @default [0, 0]\n\t     */\n\t    this.position = [0, 0];\n\t  }\n\t\n\t  if (opts.rotation == null) {\n\t    /**\n\t     * 旋转\n\t     * @type {Array.<number>}\n\t     * @default 0\n\t     */\n\t    this.rotation = 0;\n\t  }\n\t\n\t  if (!opts.scale) {\n\t    /**\n\t     * 缩放\n\t     * @type {Array.<number>}\n\t     * @default [1, 1]\n\t     */\n\t    this.scale = [1, 1];\n\t  }\n\t  /**\n\t   * 旋转和缩放的原点\n\t   * @type {Array.<number>}\n\t   * @default null\n\t   */\n\t\n\t\n\t  this.origin = this.origin || null;\n\t};\n\t\n\tvar transformableProto = Transformable.prototype;\n\ttransformableProto.transform = null;\n\t/**\n\t * 判断是否需要有坐标变换\n\t * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n\t */\n\t\n\ttransformableProto.needLocalTransform = function () {\n\t  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n\t};\n\t\n\ttransformableProto.updateTransform = function () {\n\t  var parent = this.parent;\n\t  var parentHasTransform = parent && parent.transform;\n\t  var needLocalTransform = this.needLocalTransform();\n\t  var m = this.transform;\n\t\n\t  if (!(needLocalTransform || parentHasTransform)) {\n\t    m && mIdentity(m);\n\t    return;\n\t  }\n\t\n\t  m = m || matrix.create();\n\t\n\t  if (needLocalTransform) {\n\t    this.getLocalTransform(m);\n\t  } else {\n\t    mIdentity(m);\n\t  } // 应用父节点变换\n\t\n\t\n\t  if (parentHasTransform) {\n\t    if (needLocalTransform) {\n\t      matrix.mul(m, parent.transform, m);\n\t    } else {\n\t      matrix.copy(m, parent.transform);\n\t    }\n\t  } // 保存这个变换矩阵\n\t\n\t\n\t  this.transform = m;\n\t  this.invTransform = this.invTransform || matrix.create();\n\t  matrix.invert(this.invTransform, m);\n\t};\n\t\n\ttransformableProto.getLocalTransform = function (m) {\n\t  return Transformable.getLocalTransform(this, m);\n\t};\n\t/**\n\t * 将自己的transform应用到context上\n\t * @param {CanvasRenderingContext2D} ctx\n\t */\n\t\n\t\n\ttransformableProto.setTransform = function (ctx) {\n\t  var m = this.transform;\n\t  var dpr = ctx.dpr || 1;\n\t\n\t  if (m) {\n\t    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n\t  } else {\n\t    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t  }\n\t};\n\t\n\ttransformableProto.restoreTransform = function (ctx) {\n\t  var dpr = ctx.dpr || 1;\n\t  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t};\n\t\n\tvar tmpTransform = [];\n\t/**\n\t * 分解`transform`矩阵到`position`, `rotation`, `scale`\n\t */\n\t\n\ttransformableProto.decomposeTransform = function () {\n\t  if (!this.transform) {\n\t    return;\n\t  }\n\t\n\t  var parent = this.parent;\n\t  var m = this.transform;\n\t\n\t  if (parent && parent.transform) {\n\t    // Get local transform and decompose them to position, scale, rotation\n\t    matrix.mul(tmpTransform, parent.invTransform, m);\n\t    m = tmpTransform;\n\t  }\n\t\n\t  var sx = m[0] * m[0] + m[1] * m[1];\n\t  var sy = m[2] * m[2] + m[3] * m[3];\n\t  var position = this.position;\n\t  var scale = this.scale;\n\t\n\t  if (isNotAroundZero(sx - 1)) {\n\t    sx = Math.sqrt(sx);\n\t  }\n\t\n\t  if (isNotAroundZero(sy - 1)) {\n\t    sy = Math.sqrt(sy);\n\t  }\n\t\n\t  if (m[0] < 0) {\n\t    sx = -sx;\n\t  }\n\t\n\t  if (m[3] < 0) {\n\t    sy = -sy;\n\t  }\n\t\n\t  position[0] = m[4];\n\t  position[1] = m[5];\n\t  scale[0] = sx;\n\t  scale[1] = sy;\n\t  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n\t};\n\t/**\n\t * Get global scale\n\t * @return {Array.<number>}\n\t */\n\t\n\t\n\ttransformableProto.getGlobalScale = function () {\n\t  var m = this.transform;\n\t\n\t  if (!m) {\n\t    return [1, 1];\n\t  }\n\t\n\t  var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n\t  var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\t\n\t  if (m[0] < 0) {\n\t    sx = -sx;\n\t  }\n\t\n\t  if (m[3] < 0) {\n\t    sy = -sy;\n\t  }\n\t\n\t  return [sx, sy];\n\t};\n\t/**\n\t * 变换坐标位置到 shape 的局部坐标空间\n\t * @method\n\t * @param {number} x\n\t * @param {number} y\n\t * @return {Array.<number>}\n\t */\n\t\n\t\n\ttransformableProto.transformCoordToLocal = function (x, y) {\n\t  var v2 = [x, y];\n\t  var invTransform = this.invTransform;\n\t\n\t  if (invTransform) {\n\t    vector.applyTransform(v2, v2, invTransform);\n\t  }\n\t\n\t  return v2;\n\t};\n\t/**\n\t * 变换局部坐标位置到全局坐标空间\n\t * @method\n\t * @param {number} x\n\t * @param {number} y\n\t * @return {Array.<number>}\n\t */\n\t\n\t\n\ttransformableProto.transformCoordToGlobal = function (x, y) {\n\t  var v2 = [x, y];\n\t  var transform = this.transform;\n\t\n\t  if (transform) {\n\t    vector.applyTransform(v2, v2, transform);\n\t  }\n\t\n\t  return v2;\n\t};\n\t/**\n\t * @static\n\t * @param {Object} target\n\t * @param {Array.<number>} target.origin\n\t * @param {number} target.rotation\n\t * @param {Array.<number>} target.position\n\t * @param {Array.<number>} [m]\n\t */\n\t\n\t\n\tTransformable.getLocalTransform = function (target, m) {\n\t  m = m || [];\n\t  mIdentity(m);\n\t  var origin = target.origin;\n\t  var scale = target.scale || [1, 1];\n\t  var rotation = target.rotation || 0;\n\t  var position = target.position || [0, 0];\n\t\n\t  if (origin) {\n\t    // Translate to origin\n\t    m[4] -= origin[0];\n\t    m[5] -= origin[1];\n\t  }\n\t\n\t  matrix.scale(m, m, scale);\n\t\n\t  if (rotation) {\n\t    matrix.rotate(m, m, rotation);\n\t  }\n\t\n\t  if (origin) {\n\t    // Translate back from origin\n\t    m[4] += origin[0];\n\t    m[5] += origin[1];\n\t  }\n\t\n\t  m[4] += position[0];\n\t  m[5] += position[1];\n\t  return m;\n\t};\n\t\n\tvar _default = Transformable;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * 3x2矩阵操作类\n\t * @exports zrender/tool/matrix\n\t */\n\tvar ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n\t/**\n\t * 创建一个单位矩阵\n\t * @return {Float32Array|Array.<number>}\n\t */\n\t\n\tfunction create() {\n\t  var out = new ArrayCtor(6);\n\t  identity(out);\n\t  return out;\n\t}\n\t/**\n\t * 设置矩阵为单位矩阵\n\t * @param {Float32Array|Array.<number>} out\n\t */\n\t\n\t\n\tfunction identity(out) {\n\t  out[0] = 1;\n\t  out[1] = 0;\n\t  out[2] = 0;\n\t  out[3] = 1;\n\t  out[4] = 0;\n\t  out[5] = 0;\n\t  return out;\n\t}\n\t/**\n\t * 复制矩阵\n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} m\n\t */\n\t\n\t\n\tfunction copy(out, m) {\n\t  out[0] = m[0];\n\t  out[1] = m[1];\n\t  out[2] = m[2];\n\t  out[3] = m[3];\n\t  out[4] = m[4];\n\t  out[5] = m[5];\n\t  return out;\n\t}\n\t/**\n\t * 矩阵相乘\n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} m1\n\t * @param {Float32Array|Array.<number>} m2\n\t */\n\t\n\t\n\tfunction mul(out, m1, m2) {\n\t  // Consider matrix.mul(m, m2, m);\n\t  // where out is the same as m2.\n\t  // So use temp variable to escape error.\n\t  var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n\t  var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n\t  var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n\t  var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n\t  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n\t  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n\t  out[0] = out0;\n\t  out[1] = out1;\n\t  out[2] = out2;\n\t  out[3] = out3;\n\t  out[4] = out4;\n\t  out[5] = out5;\n\t  return out;\n\t}\n\t/**\n\t * 平移变换\n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} a\n\t * @param {Float32Array|Array.<number>} v\n\t */\n\t\n\t\n\tfunction translate(out, a, v) {\n\t  out[0] = a[0];\n\t  out[1] = a[1];\n\t  out[2] = a[2];\n\t  out[3] = a[3];\n\t  out[4] = a[4] + v[0];\n\t  out[5] = a[5] + v[1];\n\t  return out;\n\t}\n\t/**\n\t * 旋转变换\n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} a\n\t * @param {number} rad\n\t */\n\t\n\t\n\tfunction rotate(out, a, rad) {\n\t  var aa = a[0];\n\t  var ac = a[2];\n\t  var atx = a[4];\n\t  var ab = a[1];\n\t  var ad = a[3];\n\t  var aty = a[5];\n\t  var st = Math.sin(rad);\n\t  var ct = Math.cos(rad);\n\t  out[0] = aa * ct + ab * st;\n\t  out[1] = -aa * st + ab * ct;\n\t  out[2] = ac * ct + ad * st;\n\t  out[3] = -ac * st + ct * ad;\n\t  out[4] = ct * atx + st * aty;\n\t  out[5] = ct * aty - st * atx;\n\t  return out;\n\t}\n\t/**\n\t * 缩放变换\n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} a\n\t * @param {Float32Array|Array.<number>} v\n\t */\n\t\n\t\n\tfunction scale(out, a, v) {\n\t  var vx = v[0];\n\t  var vy = v[1];\n\t  out[0] = a[0] * vx;\n\t  out[1] = a[1] * vy;\n\t  out[2] = a[2] * vx;\n\t  out[3] = a[3] * vy;\n\t  out[4] = a[4] * vx;\n\t  out[5] = a[5] * vy;\n\t  return out;\n\t}\n\t/**\n\t * 求逆矩阵\n\t * @param {Float32Array|Array.<number>} out\n\t * @param {Float32Array|Array.<number>} a\n\t */\n\t\n\t\n\tfunction invert(out, a) {\n\t  var aa = a[0];\n\t  var ac = a[2];\n\t  var atx = a[4];\n\t  var ab = a[1];\n\t  var ad = a[3];\n\t  var aty = a[5];\n\t  var det = aa * ad - ab * ac;\n\t\n\t  if (!det) {\n\t    return null;\n\t  }\n\t\n\t  det = 1.0 / det;\n\t  out[0] = ad * det;\n\t  out[1] = -ab * det;\n\t  out[2] = -ac * det;\n\t  out[3] = aa * det;\n\t  out[4] = (ac * aty - ad * atx) * det;\n\t  out[5] = (ab * atx - aa * aty) * det;\n\t  return out;\n\t}\n\t\n\texports.create = create;\n\texports.identity = identity;\n\texports.copy = copy;\n\texports.mul = mul;\n\texports.translate = translate;\n\texports.rotate = rotate;\n\texports.scale = scale;\n\texports.invert = invert;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\n\tvar ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n\t/**\n\t * 创建一个向量\n\t * @param {number} [x=0]\n\t * @param {number} [y=0]\n\t * @return {Vector2}\n\t */\n\t\n\tfunction create(x, y) {\n\t  var out = new ArrayCtor(2);\n\t\n\t  if (x == null) {\n\t    x = 0;\n\t  }\n\t\n\t  if (y == null) {\n\t    y = 0;\n\t  }\n\t\n\t  out[0] = x;\n\t  out[1] = y;\n\t  return out;\n\t}\n\t/**\n\t * 复制向量数据\n\t * @param {Vector2} out\n\t * @param {Vector2} v\n\t * @return {Vector2}\n\t */\n\t\n\t\n\tfunction copy(out, v) {\n\t  out[0] = v[0];\n\t  out[1] = v[1];\n\t  return out;\n\t}\n\t/**\n\t * 克隆一个向量\n\t * @param {Vector2} v\n\t * @return {Vector2}\n\t */\n\t\n\t\n\tfunction clone(v) {\n\t  var out = new ArrayCtor(2);\n\t  out[0] = v[0];\n\t  out[1] = v[1];\n\t  return out;\n\t}\n\t/**\n\t * 设置向量的两个项\n\t * @param {Vector2} out\n\t * @param {number} a\n\t * @param {number} b\n\t * @return {Vector2} 结果\n\t */\n\t\n\t\n\tfunction set(out, a, b) {\n\t  out[0] = a;\n\t  out[1] = b;\n\t  return out;\n\t}\n\t/**\n\t * 向量相加\n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t */\n\t\n\t\n\tfunction add(out, v1, v2) {\n\t  out[0] = v1[0] + v2[0];\n\t  out[1] = v1[1] + v2[1];\n\t  return out;\n\t}\n\t/**\n\t * 向量缩放后相加\n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t * @param {number} a\n\t */\n\t\n\t\n\tfunction scaleAndAdd(out, v1, v2, a) {\n\t  out[0] = v1[0] + v2[0] * a;\n\t  out[1] = v1[1] + v2[1] * a;\n\t  return out;\n\t}\n\t/**\n\t * 向量相减\n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t */\n\t\n\t\n\tfunction sub(out, v1, v2) {\n\t  out[0] = v1[0] - v2[0];\n\t  out[1] = v1[1] - v2[1];\n\t  return out;\n\t}\n\t/**\n\t * 向量长度\n\t * @param {Vector2} v\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction len(v) {\n\t  return Math.sqrt(lenSquare(v));\n\t}\n\t\n\tvar length = len; // jshint ignore:line\n\t\n\t/**\n\t * 向量长度平方\n\t * @param {Vector2} v\n\t * @return {number}\n\t */\n\t\n\tfunction lenSquare(v) {\n\t  return v[0] * v[0] + v[1] * v[1];\n\t}\n\t\n\tvar lengthSquare = lenSquare;\n\t/**\n\t * 向量乘法\n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t */\n\t\n\tfunction mul(out, v1, v2) {\n\t  out[0] = v1[0] * v2[0];\n\t  out[1] = v1[1] * v2[1];\n\t  return out;\n\t}\n\t/**\n\t * 向量除法\n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t */\n\t\n\t\n\tfunction div(out, v1, v2) {\n\t  out[0] = v1[0] / v2[0];\n\t  out[1] = v1[1] / v2[1];\n\t  return out;\n\t}\n\t/**\n\t * 向量点乘\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction dot(v1, v2) {\n\t  return v1[0] * v2[0] + v1[1] * v2[1];\n\t}\n\t/**\n\t * 向量缩放\n\t * @param {Vector2} out\n\t * @param {Vector2} v\n\t * @param {number} s\n\t */\n\t\n\t\n\tfunction scale(out, v, s) {\n\t  out[0] = v[0] * s;\n\t  out[1] = v[1] * s;\n\t  return out;\n\t}\n\t/**\n\t * 向量归一化\n\t * @param {Vector2} out\n\t * @param {Vector2} v\n\t */\n\t\n\t\n\tfunction normalize(out, v) {\n\t  var d = len(v);\n\t\n\t  if (d === 0) {\n\t    out[0] = 0;\n\t    out[1] = 0;\n\t  } else {\n\t    out[0] = v[0] / d;\n\t    out[1] = v[1] / d;\n\t  }\n\t\n\t  return out;\n\t}\n\t/**\n\t * 计算向量间距离\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction distance(v1, v2) {\n\t  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));\n\t}\n\t\n\tvar dist = distance;\n\t/**\n\t * 向量距离平方\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t * @return {number}\n\t */\n\t\n\tfunction distanceSquare(v1, v2) {\n\t  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n\t}\n\t\n\tvar distSquare = distanceSquare;\n\t/**\n\t * 求负向量\n\t * @param {Vector2} out\n\t * @param {Vector2} v\n\t */\n\t\n\tfunction negate(out, v) {\n\t  out[0] = -v[0];\n\t  out[1] = -v[1];\n\t  return out;\n\t}\n\t/**\n\t * 插值两个点\n\t * @param {Vector2} out\n\t * @param {Vector2} v1\n\t * @param {Vector2} v2\n\t * @param {number} t\n\t */\n\t\n\t\n\tfunction lerp(out, v1, v2, t) {\n\t  out[0] = v1[0] + t * (v2[0] - v1[0]);\n\t  out[1] = v1[1] + t * (v2[1] - v1[1]);\n\t  return out;\n\t}\n\t/**\n\t * 矩阵左乘向量\n\t * @param {Vector2} out\n\t * @param {Vector2} v\n\t * @param {Vector2} m\n\t */\n\t\n\t\n\tfunction applyTransform(out, v, m) {\n\t  var x = v[0];\n\t  var y = v[1];\n\t  out[0] = m[0] * x + m[2] * y + m[4];\n\t  out[1] = m[1] * x + m[3] * y + m[5];\n\t  return out;\n\t}\n\t/**\n\t * 求两个向量最小值\n\t * @param  {Vector2} out\n\t * @param  {Vector2} v1\n\t * @param  {Vector2} v2\n\t */\n\t\n\t\n\tfunction min(out, v1, v2) {\n\t  out[0] = Math.min(v1[0], v2[0]);\n\t  out[1] = Math.min(v1[1], v2[1]);\n\t  return out;\n\t}\n\t/**\n\t * 求两个向量最大值\n\t * @param  {Vector2} out\n\t * @param  {Vector2} v1\n\t * @param  {Vector2} v2\n\t */\n\t\n\t\n\tfunction max(out, v1, v2) {\n\t  out[0] = Math.max(v1[0], v2[0]);\n\t  out[1] = Math.max(v1[1], v2[1]);\n\t  return out;\n\t}\n\t\n\texports.create = create;\n\texports.copy = copy;\n\texports.clone = clone;\n\texports.set = set;\n\texports.add = add;\n\texports.scaleAndAdd = scaleAndAdd;\n\texports.sub = sub;\n\texports.len = len;\n\texports.length = length;\n\texports.lenSquare = lenSquare;\n\texports.lengthSquare = lengthSquare;\n\texports.mul = mul;\n\texports.div = div;\n\texports.dot = dot;\n\texports.scale = scale;\n\texports.normalize = normalize;\n\texports.distance = distance;\n\texports.dist = dist;\n\texports.distanceSquare = distanceSquare;\n\texports.distSquare = distSquare;\n\texports.negate = negate;\n\texports.lerp = lerp;\n\texports.applyTransform = applyTransform;\n\texports.min = min;\n\texports.max = max;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Animator = __webpack_require__(16);\n\t\n\tvar log = __webpack_require__(21);\n\t\n\tvar _util = __webpack_require__(4);\n\t\n\tvar isString = _util.isString;\n\tvar isFunction = _util.isFunction;\n\tvar isObject = _util.isObject;\n\tvar isArrayLike = _util.isArrayLike;\n\tvar indexOf = _util.indexOf;\n\t\n\t/**\n\t * @alias modue:zrender/mixin/Animatable\n\t * @constructor\n\t */\n\tvar Animatable = function () {\n\t  /**\n\t   * @type {Array.<module:zrender/animation/Animator>}\n\t   * @readOnly\n\t   */\n\t  this.animators = [];\n\t};\n\t\n\tAnimatable.prototype = {\n\t  constructor: Animatable,\n\t\n\t  /**\n\t   * 动画\n\t   *\n\t   * @param {string} path The path to fetch value from object, like 'a.b.c'.\n\t   * @param {boolean} [loop] Whether to loop animation.\n\t   * @return {module:zrender/animation/Animator}\n\t   * @example:\n\t   *     el.animate('style', false)\n\t   *         .when(1000, {x: 10} )\n\t   *         .done(function(){ // Animation done })\n\t   *         .start()\n\t   */\n\t  animate: function (path, loop) {\n\t    var target;\n\t    var animatingShape = false;\n\t    var el = this;\n\t    var zr = this.__zr;\n\t\n\t    if (path) {\n\t      var pathSplitted = path.split('.');\n\t      var prop = el; // If animating shape\n\t\n\t      animatingShape = pathSplitted[0] === 'shape';\n\t\n\t      for (var i = 0, l = pathSplitted.length; i < l; i++) {\n\t        if (!prop) {\n\t          continue;\n\t        }\n\t\n\t        prop = prop[pathSplitted[i]];\n\t      }\n\t\n\t      if (prop) {\n\t        target = prop;\n\t      }\n\t    } else {\n\t      target = el;\n\t    }\n\t\n\t    if (!target) {\n\t      log('Property \"' + path + '\" is not existed in element ' + el.id);\n\t      return;\n\t    }\n\t\n\t    var animators = el.animators;\n\t    var animator = new Animator(target, loop);\n\t    animator.during(function (target) {\n\t      el.dirty(animatingShape);\n\t    }).done(function () {\n\t      // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n\t      animators.splice(indexOf(animators, animator), 1);\n\t    });\n\t    animators.push(animator); // If animate after added to the zrender\n\t\n\t    if (zr) {\n\t      zr.animation.addAnimator(animator);\n\t    }\n\t\n\t    return animator;\n\t  },\n\t\n\t  /**\n\t   * 停止动画\n\t   * @param {boolean} forwardToLast If move to last frame before stop\n\t   */\n\t  stopAnimation: function (forwardToLast) {\n\t    var animators = this.animators;\n\t    var len = animators.length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      animators[i].stop(forwardToLast);\n\t    }\n\t\n\t    animators.length = 0;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * Caution: this method will stop previous animation.\n\t   * So do not use this method to one element twice before\n\t   * animation starts, unless you know what you are doing.\n\t   * @param {Object} target\n\t   * @param {number} [time=500] Time in ms\n\t   * @param {string} [easing='linear']\n\t   * @param {number} [delay=0]\n\t   * @param {Function} [callback]\n\t   * @param {Function} [forceAnimate] Prevent stop animation and callback\n\t   *        immediently when target values are the same as current values.\n\t   *\n\t   * @example\n\t   *  // Animate position\n\t   *  el.animateTo({\n\t   *      position: [10, 10]\n\t   *  }, function () { // done })\n\t   *\n\t   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n\t   *  el.animateTo({\n\t   *      shape: {\n\t   *          width: 500\n\t   *      },\n\t   *      style: {\n\t   *          fill: 'red'\n\t   *      }\n\t   *      position: [10, 10]\n\t   *  }, 100, 100, 'cubicOut', function () { // done })\n\t   */\n\t  // TODO Return animation key\n\t  animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n\t    // animateTo(target, time, easing, callback);\n\t    if (isString(delay)) {\n\t      callback = easing;\n\t      easing = delay;\n\t      delay = 0;\n\t    } // animateTo(target, time, delay, callback);\n\t    else if (isFunction(easing)) {\n\t        callback = easing;\n\t        easing = 'linear';\n\t        delay = 0;\n\t      } // animateTo(target, time, callback);\n\t      else if (isFunction(delay)) {\n\t          callback = delay;\n\t          delay = 0;\n\t        } // animateTo(target, callback)\n\t        else if (isFunction(time)) {\n\t            callback = time;\n\t            time = 500;\n\t          } // animateTo(target)\n\t          else if (!time) {\n\t              time = 500;\n\t            } // Stop all previous animations\n\t\n\t\n\t    this.stopAnimation();\n\t\n\t    this._animateToShallow('', this, target, time, delay); // Animators may be removed immediately after start\n\t    // if there is nothing to animate\n\t\n\t\n\t    var animators = this.animators.slice();\n\t    var count = animators.length;\n\t\n\t    function done() {\n\t      count--;\n\t\n\t      if (!count) {\n\t        callback && callback();\n\t      }\n\t    } // No animators. This should be checked before animators[i].start(),\n\t    // because 'done' may be executed immediately if no need to animate.\n\t\n\t\n\t    if (!count) {\n\t      callback && callback();\n\t    } // Start after all animators created\n\t    // Incase any animator is done immediately when all animation properties are not changed\n\t\n\t\n\t    for (var i = 0; i < animators.length; i++) {\n\t      animators[i].done(done).start(easing, forceAnimate);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @private\n\t   * @param {string} path=''\n\t   * @param {Object} source=this\n\t   * @param {Object} target\n\t   * @param {number} [time=500]\n\t   * @param {number} [delay=0]\n\t   *\n\t   * @example\n\t   *  // Animate position\n\t   *  el._animateToShallow({\n\t   *      position: [10, 10]\n\t   *  })\n\t   *\n\t   *  // Animate shape, style and position in 100ms, delayed 100ms\n\t   *  el._animateToShallow({\n\t   *      shape: {\n\t   *          width: 500\n\t   *      },\n\t   *      style: {\n\t   *          fill: 'red'\n\t   *      }\n\t   *      position: [10, 10]\n\t   *  }, 100, 100)\n\t   */\n\t  _animateToShallow: function (path, source, target, time, delay) {\n\t    var objShallow = {};\n\t    var propertyCount = 0;\n\t\n\t    for (var name in target) {\n\t      if (!target.hasOwnProperty(name)) {\n\t        continue;\n\t      }\n\t\n\t      if (source[name] != null) {\n\t        if (isObject(target[name]) && !isArrayLike(target[name])) {\n\t          this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);\n\t        } else {\n\t          objShallow[name] = target[name];\n\t          propertyCount++;\n\t        }\n\t      } else if (target[name] != null) {\n\t        // Attr directly if not has property\n\t        // FIXME, if some property not needed for element ?\n\t        if (!path) {\n\t          this.attr(name, target[name]);\n\t        } else {\n\t          // Shape or style\n\t          var props = {};\n\t          props[path] = {};\n\t          props[path][name] = target[name];\n\t          this.attr(props);\n\t        }\n\t      }\n\t    }\n\t\n\t    if (propertyCount > 0) {\n\t      this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n\t    }\n\t\n\t    return this;\n\t  }\n\t};\n\tvar _default = Animatable;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Clip = __webpack_require__(17);\n\t\n\tvar color = __webpack_require__(19);\n\t\n\tvar _util = __webpack_require__(4);\n\t\n\tvar isArrayLike = _util.isArrayLike;\n\t\n\t/**\n\t * @module echarts/animation/Animator\n\t */\n\tvar arraySlice = Array.prototype.slice;\n\t\n\tfunction defaultGetter(target, key) {\n\t  return target[key];\n\t}\n\t\n\tfunction defaultSetter(target, key, value) {\n\t  target[key] = value;\n\t}\n\t/**\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} percent\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction interpolateNumber(p0, p1, percent) {\n\t  return (p1 - p0) * percent + p0;\n\t}\n\t/**\n\t * @param  {string} p0\n\t * @param  {string} p1\n\t * @param  {number} percent\n\t * @return {string}\n\t */\n\t\n\t\n\tfunction interpolateString(p0, p1, percent) {\n\t  return percent > 0.5 ? p1 : p0;\n\t}\n\t/**\n\t * @param  {Array} p0\n\t * @param  {Array} p1\n\t * @param  {number} percent\n\t * @param  {Array} out\n\t * @param  {number} arrDim\n\t */\n\t\n\t\n\tfunction interpolateArray(p0, p1, percent, out, arrDim) {\n\t  var len = p0.length;\n\t\n\t  if (arrDim == 1) {\n\t    for (var i = 0; i < len; i++) {\n\t      out[i] = interpolateNumber(p0[i], p1[i], percent);\n\t    }\n\t  } else {\n\t    var len2 = len && p0[0].length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      for (var j = 0; j < len2; j++) {\n\t        out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n\t      }\n\t    }\n\t  }\n\t} // arr0 is source array, arr1 is target array.\n\t// Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\t\n\t\n\tfunction fillArr(arr0, arr1, arrDim) {\n\t  var arr0Len = arr0.length;\n\t  var arr1Len = arr1.length;\n\t\n\t  if (arr0Len !== arr1Len) {\n\t    // FIXME Not work for TypedArray\n\t    var isPreviousLarger = arr0Len > arr1Len;\n\t\n\t    if (isPreviousLarger) {\n\t      // Cut the previous\n\t      arr0.length = arr1Len;\n\t    } else {\n\t      // Fill the previous\n\t      for (var i = arr0Len; i < arr1Len; i++) {\n\t        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n\t      }\n\t    }\n\t  } // Handling NaN value\n\t\n\t\n\t  var len2 = arr0[0] && arr0[0].length;\n\t\n\t  for (var i = 0; i < arr0.length; i++) {\n\t    if (arrDim === 1) {\n\t      if (isNaN(arr0[i])) {\n\t        arr0[i] = arr1[i];\n\t      }\n\t    } else {\n\t      for (var j = 0; j < len2; j++) {\n\t        if (isNaN(arr0[i][j])) {\n\t          arr0[i][j] = arr1[i][j];\n\t        }\n\t      }\n\t    }\n\t  }\n\t}\n\t/**\n\t * @param  {Array} arr0\n\t * @param  {Array} arr1\n\t * @param  {number} arrDim\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction isArraySame(arr0, arr1, arrDim) {\n\t  if (arr0 === arr1) {\n\t    return true;\n\t  }\n\t\n\t  var len = arr0.length;\n\t\n\t  if (len !== arr1.length) {\n\t    return false;\n\t  }\n\t\n\t  if (arrDim === 1) {\n\t    for (var i = 0; i < len; i++) {\n\t      if (arr0[i] !== arr1[i]) {\n\t        return false;\n\t      }\n\t    }\n\t  } else {\n\t    var len2 = arr0[0].length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      for (var j = 0; j < len2; j++) {\n\t        if (arr0[i][j] !== arr1[i][j]) {\n\t          return false;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  return true;\n\t}\n\t/**\n\t * Catmull Rom interpolate array\n\t * @param  {Array} p0\n\t * @param  {Array} p1\n\t * @param  {Array} p2\n\t * @param  {Array} p3\n\t * @param  {number} t\n\t * @param  {number} t2\n\t * @param  {number} t3\n\t * @param  {Array} out\n\t * @param  {number} arrDim\n\t */\n\t\n\t\n\tfunction catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {\n\t  var len = p0.length;\n\t\n\t  if (arrDim == 1) {\n\t    for (var i = 0; i < len; i++) {\n\t      out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);\n\t    }\n\t  } else {\n\t    var len2 = p0[0].length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      for (var j = 0; j < len2; j++) {\n\t        out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);\n\t      }\n\t    }\n\t  }\n\t}\n\t/**\n\t * Catmull Rom interpolate number\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {number} t\n\t * @param  {number} t2\n\t * @param  {number} t3\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n\t  var v0 = (p2 - p0) * 0.5;\n\t  var v1 = (p3 - p1) * 0.5;\n\t  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n\t}\n\t\n\tfunction cloneValue(value) {\n\t  if (isArrayLike(value)) {\n\t    var len = value.length;\n\t\n\t    if (isArrayLike(value[0])) {\n\t      var ret = [];\n\t\n\t      for (var i = 0; i < len; i++) {\n\t        ret.push(arraySlice.call(value[i]));\n\t      }\n\t\n\t      return ret;\n\t    }\n\t\n\t    return arraySlice.call(value);\n\t  }\n\t\n\t  return value;\n\t}\n\t\n\tfunction rgba2String(rgba) {\n\t  rgba[0] = Math.floor(rgba[0]);\n\t  rgba[1] = Math.floor(rgba[1]);\n\t  rgba[2] = Math.floor(rgba[2]);\n\t  return 'rgba(' + rgba.join(',') + ')';\n\t}\n\t\n\tfunction getArrayDim(keyframes) {\n\t  var lastValue = keyframes[keyframes.length - 1].value;\n\t  return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n\t}\n\t\n\tfunction createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {\n\t  var getter = animator._getter;\n\t  var setter = animator._setter;\n\t  var useSpline = easing === 'spline';\n\t  var trackLen = keyframes.length;\n\t\n\t  if (!trackLen) {\n\t    return;\n\t  } // Guess data type\n\t\n\t\n\t  var firstVal = keyframes[0].value;\n\t  var isValueArray = isArrayLike(firstVal);\n\t  var isValueColor = false;\n\t  var isValueString = false; // For vertices morphing\n\t\n\t  var arrDim = isValueArray ? getArrayDim(keyframes) : 0;\n\t  var trackMaxTime; // Sort keyframe as ascending\n\t\n\t  keyframes.sort(function (a, b) {\n\t    return a.time - b.time;\n\t  });\n\t  trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe\n\t\n\t  var kfPercents = []; // Value of each keyframe\n\t\n\t  var kfValues = [];\n\t  var prevValue = keyframes[0].value;\n\t  var isAllValueEqual = true;\n\t\n\t  for (var i = 0; i < trackLen; i++) {\n\t    kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string\n\t\n\t    var value = keyframes[i].value; // Check if value is equal, deep check if value is array\n\t\n\t    if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {\n\t      isAllValueEqual = false;\n\t    }\n\t\n\t    prevValue = value; // Try converting a string to a color array\n\t\n\t    if (typeof value == 'string') {\n\t      var colorArray = color.parse(value);\n\t\n\t      if (colorArray) {\n\t        value = colorArray;\n\t        isValueColor = true;\n\t      } else {\n\t        isValueString = true;\n\t      }\n\t    }\n\t\n\t    kfValues.push(value);\n\t  }\n\t\n\t  if (!forceAnimate && isAllValueEqual) {\n\t    return;\n\t  }\n\t\n\t  var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value\n\t\n\t  for (var i = 0; i < trackLen - 1; i++) {\n\t    if (isValueArray) {\n\t      fillArr(kfValues[i], lastValue, arrDim);\n\t    } else {\n\t      if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n\t        kfValues[i] = lastValue;\n\t      }\n\t    }\n\t  }\n\t\n\t  isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when\n\t  // animation playback is sequency\n\t\n\t  var lastFrame = 0;\n\t  var lastFramePercent = 0;\n\t  var start;\n\t  var w;\n\t  var p0;\n\t  var p1;\n\t  var p2;\n\t  var p3;\n\t\n\t  if (isValueColor) {\n\t    var rgba = [0, 0, 0, 0];\n\t  }\n\t\n\t  var onframe = function (target, percent) {\n\t    // Find the range keyframes\n\t    // kf1-----kf2---------current--------kf3\n\t    // find kf2 and kf3 and do interpolation\n\t    var frame; // In the easing function like elasticOut, percent may less than 0\n\t\n\t    if (percent < 0) {\n\t      frame = 0;\n\t    } else if (percent < lastFramePercent) {\n\t      // Start from next key\n\t      // PENDING start from lastFrame ?\n\t      start = Math.min(lastFrame + 1, trackLen - 1);\n\t\n\t      for (frame = start; frame >= 0; frame--) {\n\t        if (kfPercents[frame] <= percent) {\n\t          break;\n\t        }\n\t      } // PENDING really need to do this ?\n\t\n\t\n\t      frame = Math.min(frame, trackLen - 2);\n\t    } else {\n\t      for (frame = lastFrame; frame < trackLen; frame++) {\n\t        if (kfPercents[frame] > percent) {\n\t          break;\n\t        }\n\t      }\n\t\n\t      frame = Math.min(frame - 1, trackLen - 2);\n\t    }\n\t\n\t    lastFrame = frame;\n\t    lastFramePercent = percent;\n\t    var range = kfPercents[frame + 1] - kfPercents[frame];\n\t\n\t    if (range === 0) {\n\t      return;\n\t    } else {\n\t      w = (percent - kfPercents[frame]) / range;\n\t    }\n\t\n\t    if (useSpline) {\n\t      p1 = kfValues[frame];\n\t      p0 = kfValues[frame === 0 ? frame : frame - 1];\n\t      p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n\t      p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\t\n\t      if (isValueArray) {\n\t        catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);\n\t      } else {\n\t        var value;\n\t\n\t        if (isValueColor) {\n\t          value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);\n\t          value = rgba2String(rgba);\n\t        } else if (isValueString) {\n\t          // String is step(0.5)\n\t          return interpolateString(p1, p2, w);\n\t        } else {\n\t          value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);\n\t        }\n\t\n\t        setter(target, propName, value);\n\t      }\n\t    } else {\n\t      if (isValueArray) {\n\t        interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);\n\t      } else {\n\t        var value;\n\t\n\t        if (isValueColor) {\n\t          interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);\n\t          value = rgba2String(rgba);\n\t        } else if (isValueString) {\n\t          // String is step(0.5)\n\t          return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n\t        } else {\n\t          value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n\t        }\n\t\n\t        setter(target, propName, value);\n\t      }\n\t    }\n\t  };\n\t\n\t  var clip = new Clip({\n\t    target: animator._target,\n\t    life: trackMaxTime,\n\t    loop: animator._loop,\n\t    delay: animator._delay,\n\t    onframe: onframe,\n\t    ondestroy: oneTrackDone\n\t  });\n\t\n\t  if (easing && easing !== 'spline') {\n\t    clip.easing = easing;\n\t  }\n\t\n\t  return clip;\n\t}\n\t/**\n\t * @alias module:zrender/animation/Animator\n\t * @constructor\n\t * @param {Object} target\n\t * @param {boolean} loop\n\t * @param {Function} getter\n\t * @param {Function} setter\n\t */\n\t\n\t\n\tvar Animator = function (target, loop, getter, setter) {\n\t  this._tracks = {};\n\t  this._target = target;\n\t  this._loop = loop || false;\n\t  this._getter = getter || defaultGetter;\n\t  this._setter = setter || defaultSetter;\n\t  this._clipCount = 0;\n\t  this._delay = 0;\n\t  this._doneList = [];\n\t  this._onframeList = [];\n\t  this._clipList = [];\n\t};\n\t\n\tAnimator.prototype = {\n\t  /**\n\t   * 设置动画关键帧\n\t   * @param  {number} time 关键帧时间，单位是ms\n\t   * @param  {Object} props 关键帧的属性值，key-value表示\n\t   * @return {module:zrender/animation/Animator}\n\t   */\n\t  when: function (time\n\t  /* ms */\n\t  , props) {\n\t    var tracks = this._tracks;\n\t\n\t    for (var propName in props) {\n\t      if (!props.hasOwnProperty(propName)) {\n\t        continue;\n\t      }\n\t\n\t      if (!tracks[propName]) {\n\t        tracks[propName] = []; // Invalid value\n\t\n\t        var value = this._getter(this._target, propName);\n\t\n\t        if (value == null) {\n\t          // zrLog('Invalid property ' + propName);\n\t          continue;\n\t        } // If time is 0\n\t        //  Then props is given initialize value\n\t        // Else\n\t        //  Initialize value from current prop value\n\t\n\t\n\t        if (time !== 0) {\n\t          tracks[propName].push({\n\t            time: 0,\n\t            value: cloneValue(value)\n\t          });\n\t        }\n\t      }\n\t\n\t      tracks[propName].push({\n\t        time: time,\n\t        value: props[propName]\n\t      });\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 添加动画每一帧的回调函数\n\t   * @param  {Function} callback\n\t   * @return {module:zrender/animation/Animator}\n\t   */\n\t  during: function (callback) {\n\t    this._onframeList.push(callback);\n\t\n\t    return this;\n\t  },\n\t  pause: function () {\n\t    for (var i = 0; i < this._clipList.length; i++) {\n\t      this._clipList[i].pause();\n\t    }\n\t\n\t    this._paused = true;\n\t  },\n\t  resume: function () {\n\t    for (var i = 0; i < this._clipList.length; i++) {\n\t      this._clipList[i].resume();\n\t    }\n\t\n\t    this._paused = false;\n\t  },\n\t  isPaused: function () {\n\t    return !!this._paused;\n\t  },\n\t  _doneCallback: function () {\n\t    // Clear all tracks\n\t    this._tracks = {}; // Clear all clips\n\t\n\t    this._clipList.length = 0;\n\t    var doneList = this._doneList;\n\t    var len = doneList.length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      doneList[i].call(this);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 开始执行动画\n\t   * @param  {string|Function} [easing]\n\t   *         动画缓动函数，详见{@link module:zrender/animation/easing}\n\t   * @param  {boolean} forceAnimate\n\t   * @return {module:zrender/animation/Animator}\n\t   */\n\t  start: function (easing, forceAnimate) {\n\t    var self = this;\n\t    var clipCount = 0;\n\t\n\t    var oneTrackDone = function () {\n\t      clipCount--;\n\t\n\t      if (!clipCount) {\n\t        self._doneCallback();\n\t      }\n\t    };\n\t\n\t    var lastClip;\n\t\n\t    for (var propName in this._tracks) {\n\t      if (!this._tracks.hasOwnProperty(propName)) {\n\t        continue;\n\t      }\n\t\n\t      var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);\n\t\n\t      if (clip) {\n\t        this._clipList.push(clip);\n\t\n\t        clipCount++; // If start after added to animation\n\t\n\t        if (this.animation) {\n\t          this.animation.addClip(clip);\n\t        }\n\t\n\t        lastClip = clip;\n\t      }\n\t    } // Add during callback on the last clip\n\t\n\t\n\t    if (lastClip) {\n\t      var oldOnFrame = lastClip.onframe;\n\t\n\t      lastClip.onframe = function (target, percent) {\n\t        oldOnFrame(target, percent);\n\t\n\t        for (var i = 0; i < self._onframeList.length; i++) {\n\t          self._onframeList[i](target, percent);\n\t        }\n\t      };\n\t    } // This optimization will help the case that in the upper application\n\t    // the view may be refreshed frequently, where animation will be\n\t    // called repeatly but nothing changed.\n\t\n\t\n\t    if (!clipCount) {\n\t      this._doneCallback();\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 停止动画\n\t   * @param {boolean} forwardToLast If move to last frame before stop\n\t   */\n\t  stop: function (forwardToLast) {\n\t    var clipList = this._clipList;\n\t    var animation = this.animation;\n\t\n\t    for (var i = 0; i < clipList.length; i++) {\n\t      var clip = clipList[i];\n\t\n\t      if (forwardToLast) {\n\t        // Move to last frame before stop\n\t        clip.onframe(this._target, 1);\n\t      }\n\t\n\t      animation && animation.removeClip(clip);\n\t    }\n\t\n\t    clipList.length = 0;\n\t  },\n\t\n\t  /**\n\t   * 设置动画延迟开始的时间\n\t   * @param  {number} time 单位ms\n\t   * @return {module:zrender/animation/Animator}\n\t   */\n\t  delay: function (time) {\n\t    this._delay = time;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 添加动画结束的回调\n\t   * @param  {Function} cb\n\t   * @return {module:zrender/animation/Animator}\n\t   */\n\t  done: function (cb) {\n\t    if (cb) {\n\t      this._doneList.push(cb);\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @return {Array.<module:zrender/animation/Clip>}\n\t   */\n\t  getClips: function () {\n\t    return this._clipList;\n\t  }\n\t};\n\tvar _default = Animator;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar easingFuncs = __webpack_require__(18);\n\t\n\t/**\n\t * 动画主控制器\n\t * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\n\t * @config life(1000) 动画时长\n\t * @config delay(0) 动画延迟时间\n\t * @config loop(true)\n\t * @config gap(0) 循环的间隔时间\n\t * @config onframe\n\t * @config easing(optional)\n\t * @config ondestroy(optional)\n\t * @config onrestart(optional)\n\t *\n\t * TODO pause\n\t */\n\tfunction Clip(options) {\n\t  this._target = options.target; // 生命周期\n\t\n\t  this._life = options.life || 1000; // 延时\n\t\n\t  this._delay = options.delay || 0; // 开始时间\n\t  // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n\t\n\t  this._initialized = false; // 是否循环\n\t\n\t  this.loop = options.loop == null ? false : options.loop;\n\t  this.gap = options.gap || 0;\n\t  this.easing = options.easing || 'Linear';\n\t  this.onframe = options.onframe;\n\t  this.ondestroy = options.ondestroy;\n\t  this.onrestart = options.onrestart;\n\t  this._pausedTime = 0;\n\t  this._paused = false;\n\t}\n\t\n\tClip.prototype = {\n\t  constructor: Clip,\n\t  step: function (globalTime, deltaTime) {\n\t    // Set startTime on first step, or _startTime may has milleseconds different between clips\n\t    // PENDING\n\t    if (!this._initialized) {\n\t      this._startTime = globalTime + this._delay;\n\t      this._initialized = true;\n\t    }\n\t\n\t    if (this._paused) {\n\t      this._pausedTime += deltaTime;\n\t      return;\n\t    }\n\t\n\t    var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // 还没开始\n\t\n\t    if (percent < 0) {\n\t      return;\n\t    }\n\t\n\t    percent = Math.min(percent, 1);\n\t    var easing = this.easing;\n\t    var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n\t    var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;\n\t    this.fire('frame', schedule); // 结束\n\t\n\t    if (percent == 1) {\n\t      if (this.loop) {\n\t        this.restart(globalTime); // 重新开始周期\n\t        // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n\t\n\t        return 'restart';\n\t      } // 动画完成将这个控制器标识为待删除\n\t      // 在Animation.update中进行批量删除\n\t\n\t\n\t      this._needsRemove = true;\n\t      return 'destroy';\n\t    }\n\t\n\t    return null;\n\t  },\n\t  restart: function (globalTime) {\n\t    var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n\t    this._startTime = globalTime - remainder + this.gap;\n\t    this._pausedTime = 0;\n\t    this._needsRemove = false;\n\t  },\n\t  fire: function (eventType, arg) {\n\t    eventType = 'on' + eventType;\n\t\n\t    if (this[eventType]) {\n\t      this[eventType](this._target, arg);\n\t    }\n\t  },\n\t  pause: function () {\n\t    this._paused = true;\n\t  },\n\t  resume: function () {\n\t    this._paused = false;\n\t  }\n\t};\n\tvar _default = Clip;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\n\t * @see http://sole.github.io/tween.js/examples/03_graphs.html\n\t * @exports zrender/animation/easing\n\t */\n\tvar easing = {\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  linear: function (k) {\n\t    return k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quadraticIn: function (k) {\n\t    return k * k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quadraticOut: function (k) {\n\t    return k * (2 - k);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quadraticInOut: function (k) {\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * k * k;\n\t    }\n\t\n\t    return -0.5 * (--k * (k - 2) - 1);\n\t  },\n\t  // 三次方的缓动（t^3）\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  cubicIn: function (k) {\n\t    return k * k * k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  cubicOut: function (k) {\n\t    return --k * k * k + 1;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  cubicInOut: function (k) {\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * k * k * k;\n\t    }\n\t\n\t    return 0.5 * ((k -= 2) * k * k + 2);\n\t  },\n\t  // 四次方的缓动（t^4）\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quarticIn: function (k) {\n\t    return k * k * k * k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quarticOut: function (k) {\n\t    return 1 - --k * k * k * k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quarticInOut: function (k) {\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * k * k * k * k;\n\t    }\n\t\n\t    return -0.5 * ((k -= 2) * k * k * k - 2);\n\t  },\n\t  // 五次方的缓动（t^5）\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quinticIn: function (k) {\n\t    return k * k * k * k * k;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quinticOut: function (k) {\n\t    return --k * k * k * k * k + 1;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  quinticInOut: function (k) {\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * k * k * k * k * k;\n\t    }\n\t\n\t    return 0.5 * ((k -= 2) * k * k * k * k + 2);\n\t  },\n\t  // 正弦曲线的缓动（sin(t)）\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  sinusoidalIn: function (k) {\n\t    return 1 - Math.cos(k * Math.PI / 2);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  sinusoidalOut: function (k) {\n\t    return Math.sin(k * Math.PI / 2);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  sinusoidalInOut: function (k) {\n\t    return 0.5 * (1 - Math.cos(Math.PI * k));\n\t  },\n\t  // 指数曲线的缓动（2^t）\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  exponentialIn: function (k) {\n\t    return k === 0 ? 0 : Math.pow(1024, k - 1);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  exponentialOut: function (k) {\n\t    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  exponentialInOut: function (k) {\n\t    if (k === 0) {\n\t      return 0;\n\t    }\n\t\n\t    if (k === 1) {\n\t      return 1;\n\t    }\n\t\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * Math.pow(1024, k - 1);\n\t    }\n\t\n\t    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n\t  },\n\t  // 圆形曲线的缓动（sqrt(1-t^2)）\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  circularIn: function (k) {\n\t    return 1 - Math.sqrt(1 - k * k);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  circularOut: function (k) {\n\t    return Math.sqrt(1 - --k * k);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  circularInOut: function (k) {\n\t    if ((k *= 2) < 1) {\n\t      return -0.5 * (Math.sqrt(1 - k * k) - 1);\n\t    }\n\t\n\t    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\t  },\n\t  // 创建类似于弹簧在停止前来回振荡的动画\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  elasticIn: function (k) {\n\t    var s;\n\t    var a = 0.1;\n\t    var p = 0.4;\n\t\n\t    if (k === 0) {\n\t      return 0;\n\t    }\n\t\n\t    if (k === 1) {\n\t      return 1;\n\t    }\n\t\n\t    if (!a || a < 1) {\n\t      a = 1;\n\t      s = p / 4;\n\t    } else {\n\t      s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t    }\n\t\n\t    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  elasticOut: function (k) {\n\t    var s;\n\t    var a = 0.1;\n\t    var p = 0.4;\n\t\n\t    if (k === 0) {\n\t      return 0;\n\t    }\n\t\n\t    if (k === 1) {\n\t      return 1;\n\t    }\n\t\n\t    if (!a || a < 1) {\n\t      a = 1;\n\t      s = p / 4;\n\t    } else {\n\t      s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t    }\n\t\n\t    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  elasticInOut: function (k) {\n\t    var s;\n\t    var a = 0.1;\n\t    var p = 0.4;\n\t\n\t    if (k === 0) {\n\t      return 0;\n\t    }\n\t\n\t    if (k === 1) {\n\t      return 1;\n\t    }\n\t\n\t    if (!a || a < 1) {\n\t      a = 1;\n\t      s = p / 4;\n\t    } else {\n\t      s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t    }\n\t\n\t    if ((k *= 2) < 1) {\n\t      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n\t    }\n\t\n\t    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t  },\n\t  // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  backIn: function (k) {\n\t    var s = 1.70158;\n\t    return k * k * ((s + 1) * k - s);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  backOut: function (k) {\n\t    var s = 1.70158;\n\t    return --k * k * ((s + 1) * k + s) + 1;\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  backInOut: function (k) {\n\t    var s = 1.70158 * 1.525;\n\t\n\t    if ((k *= 2) < 1) {\n\t      return 0.5 * (k * k * ((s + 1) * k - s));\n\t    }\n\t\n\t    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\t  },\n\t  // 创建弹跳效果\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  bounceIn: function (k) {\n\t    return 1 - easing.bounceOut(1 - k);\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  bounceOut: function (k) {\n\t    if (k < 1 / 2.75) {\n\t      return 7.5625 * k * k;\n\t    } else if (k < 2 / 2.75) {\n\t      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n\t    } else if (k < 2.5 / 2.75) {\n\t      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n\t    } else {\n\t      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n\t    }\n\t  },\n\t\n\t  /**\n\t  * @param {number} k\n\t  * @return {number}\n\t  */\n\t  bounceInOut: function (k) {\n\t    if (k < 0.5) {\n\t      return easing.bounceIn(k * 2) * 0.5;\n\t    }\n\t\n\t    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n\t  }\n\t};\n\tvar _default = easing;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar LRU = __webpack_require__(20);\n\t\n\tvar kCSSColorTable = {\n\t  'transparent': [0, 0, 0, 0],\n\t  'aliceblue': [240, 248, 255, 1],\n\t  'antiquewhite': [250, 235, 215, 1],\n\t  'aqua': [0, 255, 255, 1],\n\t  'aquamarine': [127, 255, 212, 1],\n\t  'azure': [240, 255, 255, 1],\n\t  'beige': [245, 245, 220, 1],\n\t  'bisque': [255, 228, 196, 1],\n\t  'black': [0, 0, 0, 1],\n\t  'blanchedalmond': [255, 235, 205, 1],\n\t  'blue': [0, 0, 255, 1],\n\t  'blueviolet': [138, 43, 226, 1],\n\t  'brown': [165, 42, 42, 1],\n\t  'burlywood': [222, 184, 135, 1],\n\t  'cadetblue': [95, 158, 160, 1],\n\t  'chartreuse': [127, 255, 0, 1],\n\t  'chocolate': [210, 105, 30, 1],\n\t  'coral': [255, 127, 80, 1],\n\t  'cornflowerblue': [100, 149, 237, 1],\n\t  'cornsilk': [255, 248, 220, 1],\n\t  'crimson': [220, 20, 60, 1],\n\t  'cyan': [0, 255, 255, 1],\n\t  'darkblue': [0, 0, 139, 1],\n\t  'darkcyan': [0, 139, 139, 1],\n\t  'darkgoldenrod': [184, 134, 11, 1],\n\t  'darkgray': [169, 169, 169, 1],\n\t  'darkgreen': [0, 100, 0, 1],\n\t  'darkgrey': [169, 169, 169, 1],\n\t  'darkkhaki': [189, 183, 107, 1],\n\t  'darkmagenta': [139, 0, 139, 1],\n\t  'darkolivegreen': [85, 107, 47, 1],\n\t  'darkorange': [255, 140, 0, 1],\n\t  'darkorchid': [153, 50, 204, 1],\n\t  'darkred': [139, 0, 0, 1],\n\t  'darksalmon': [233, 150, 122, 1],\n\t  'darkseagreen': [143, 188, 143, 1],\n\t  'darkslateblue': [72, 61, 139, 1],\n\t  'darkslategray': [47, 79, 79, 1],\n\t  'darkslategrey': [47, 79, 79, 1],\n\t  'darkturquoise': [0, 206, 209, 1],\n\t  'darkviolet': [148, 0, 211, 1],\n\t  'deeppink': [255, 20, 147, 1],\n\t  'deepskyblue': [0, 191, 255, 1],\n\t  'dimgray': [105, 105, 105, 1],\n\t  'dimgrey': [105, 105, 105, 1],\n\t  'dodgerblue': [30, 144, 255, 1],\n\t  'firebrick': [178, 34, 34, 1],\n\t  'floralwhite': [255, 250, 240, 1],\n\t  'forestgreen': [34, 139, 34, 1],\n\t  'fuchsia': [255, 0, 255, 1],\n\t  'gainsboro': [220, 220, 220, 1],\n\t  'ghostwhite': [248, 248, 255, 1],\n\t  'gold': [255, 215, 0, 1],\n\t  'goldenrod': [218, 165, 32, 1],\n\t  'gray': [128, 128, 128, 1],\n\t  'green': [0, 128, 0, 1],\n\t  'greenyellow': [173, 255, 47, 1],\n\t  'grey': [128, 128, 128, 1],\n\t  'honeydew': [240, 255, 240, 1],\n\t  'hotpink': [255, 105, 180, 1],\n\t  'indianred': [205, 92, 92, 1],\n\t  'indigo': [75, 0, 130, 1],\n\t  'ivory': [255, 255, 240, 1],\n\t  'khaki': [240, 230, 140, 1],\n\t  'lavender': [230, 230, 250, 1],\n\t  'lavenderblush': [255, 240, 245, 1],\n\t  'lawngreen': [124, 252, 0, 1],\n\t  'lemonchiffon': [255, 250, 205, 1],\n\t  'lightblue': [173, 216, 230, 1],\n\t  'lightcoral': [240, 128, 128, 1],\n\t  'lightcyan': [224, 255, 255, 1],\n\t  'lightgoldenrodyellow': [250, 250, 210, 1],\n\t  'lightgray': [211, 211, 211, 1],\n\t  'lightgreen': [144, 238, 144, 1],\n\t  'lightgrey': [211, 211, 211, 1],\n\t  'lightpink': [255, 182, 193, 1],\n\t  'lightsalmon': [255, 160, 122, 1],\n\t  'lightseagreen': [32, 178, 170, 1],\n\t  'lightskyblue': [135, 206, 250, 1],\n\t  'lightslategray': [119, 136, 153, 1],\n\t  'lightslategrey': [119, 136, 153, 1],\n\t  'lightsteelblue': [176, 196, 222, 1],\n\t  'lightyellow': [255, 255, 224, 1],\n\t  'lime': [0, 255, 0, 1],\n\t  'limegreen': [50, 205, 50, 1],\n\t  'linen': [250, 240, 230, 1],\n\t  'magenta': [255, 0, 255, 1],\n\t  'maroon': [128, 0, 0, 1],\n\t  'mediumaquamarine': [102, 205, 170, 1],\n\t  'mediumblue': [0, 0, 205, 1],\n\t  'mediumorchid': [186, 85, 211, 1],\n\t  'mediumpurple': [147, 112, 219, 1],\n\t  'mediumseagreen': [60, 179, 113, 1],\n\t  'mediumslateblue': [123, 104, 238, 1],\n\t  'mediumspringgreen': [0, 250, 154, 1],\n\t  'mediumturquoise': [72, 209, 204, 1],\n\t  'mediumvioletred': [199, 21, 133, 1],\n\t  'midnightblue': [25, 25, 112, 1],\n\t  'mintcream': [245, 255, 250, 1],\n\t  'mistyrose': [255, 228, 225, 1],\n\t  'moccasin': [255, 228, 181, 1],\n\t  'navajowhite': [255, 222, 173, 1],\n\t  'navy': [0, 0, 128, 1],\n\t  'oldlace': [253, 245, 230, 1],\n\t  'olive': [128, 128, 0, 1],\n\t  'olivedrab': [107, 142, 35, 1],\n\t  'orange': [255, 165, 0, 1],\n\t  'orangered': [255, 69, 0, 1],\n\t  'orchid': [218, 112, 214, 1],\n\t  'palegoldenrod': [238, 232, 170, 1],\n\t  'palegreen': [152, 251, 152, 1],\n\t  'paleturquoise': [175, 238, 238, 1],\n\t  'palevioletred': [219, 112, 147, 1],\n\t  'papayawhip': [255, 239, 213, 1],\n\t  'peachpuff': [255, 218, 185, 1],\n\t  'peru': [205, 133, 63, 1],\n\t  'pink': [255, 192, 203, 1],\n\t  'plum': [221, 160, 221, 1],\n\t  'powderblue': [176, 224, 230, 1],\n\t  'purple': [128, 0, 128, 1],\n\t  'red': [255, 0, 0, 1],\n\t  'rosybrown': [188, 143, 143, 1],\n\t  'royalblue': [65, 105, 225, 1],\n\t  'saddlebrown': [139, 69, 19, 1],\n\t  'salmon': [250, 128, 114, 1],\n\t  'sandybrown': [244, 164, 96, 1],\n\t  'seagreen': [46, 139, 87, 1],\n\t  'seashell': [255, 245, 238, 1],\n\t  'sienna': [160, 82, 45, 1],\n\t  'silver': [192, 192, 192, 1],\n\t  'skyblue': [135, 206, 235, 1],\n\t  'slateblue': [106, 90, 205, 1],\n\t  'slategray': [112, 128, 144, 1],\n\t  'slategrey': [112, 128, 144, 1],\n\t  'snow': [255, 250, 250, 1],\n\t  'springgreen': [0, 255, 127, 1],\n\t  'steelblue': [70, 130, 180, 1],\n\t  'tan': [210, 180, 140, 1],\n\t  'teal': [0, 128, 128, 1],\n\t  'thistle': [216, 191, 216, 1],\n\t  'tomato': [255, 99, 71, 1],\n\t  'turquoise': [64, 224, 208, 1],\n\t  'violet': [238, 130, 238, 1],\n\t  'wheat': [245, 222, 179, 1],\n\t  'white': [255, 255, 255, 1],\n\t  'whitesmoke': [245, 245, 245, 1],\n\t  'yellow': [255, 255, 0, 1],\n\t  'yellowgreen': [154, 205, 50, 1]\n\t};\n\t\n\tfunction clampCssByte(i) {\n\t  // Clamp to integer 0 .. 255.\n\t  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\t\n\t  return i < 0 ? 0 : i > 255 ? 255 : i;\n\t}\n\t\n\tfunction clampCssAngle(i) {\n\t  // Clamp to integer 0 .. 360.\n\t  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\t\n\t  return i < 0 ? 0 : i > 360 ? 360 : i;\n\t}\n\t\n\tfunction clampCssFloat(f) {\n\t  // Clamp to float 0.0 .. 1.0.\n\t  return f < 0 ? 0 : f > 1 ? 1 : f;\n\t}\n\t\n\tfunction parseCssInt(str) {\n\t  // int or percentage.\n\t  if (str.length && str.charAt(str.length - 1) === '%') {\n\t    return clampCssByte(parseFloat(str) / 100 * 255);\n\t  }\n\t\n\t  return clampCssByte(parseInt(str, 10));\n\t}\n\t\n\tfunction parseCssFloat(str) {\n\t  // float or percentage.\n\t  if (str.length && str.charAt(str.length - 1) === '%') {\n\t    return clampCssFloat(parseFloat(str) / 100);\n\t  }\n\t\n\t  return clampCssFloat(parseFloat(str));\n\t}\n\t\n\tfunction cssHueToRgb(m1, m2, h) {\n\t  if (h < 0) {\n\t    h += 1;\n\t  } else if (h > 1) {\n\t    h -= 1;\n\t  }\n\t\n\t  if (h * 6 < 1) {\n\t    return m1 + (m2 - m1) * h * 6;\n\t  }\n\t\n\t  if (h * 2 < 1) {\n\t    return m2;\n\t  }\n\t\n\t  if (h * 3 < 2) {\n\t    return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n\t  }\n\t\n\t  return m1;\n\t}\n\t\n\tfunction lerpNumber(a, b, p) {\n\t  return a + (b - a) * p;\n\t}\n\t\n\tfunction setRgba(out, r, g, b, a) {\n\t  out[0] = r;\n\t  out[1] = g;\n\t  out[2] = b;\n\t  out[3] = a;\n\t  return out;\n\t}\n\t\n\tfunction copyRgba(out, a) {\n\t  out[0] = a[0];\n\t  out[1] = a[1];\n\t  out[2] = a[2];\n\t  out[3] = a[3];\n\t  return out;\n\t}\n\t\n\tvar colorCache = new LRU(20);\n\tvar lastRemovedArr = null;\n\t\n\tfunction putToCache(colorStr, rgbaArr) {\n\t  // Reuse removed array\n\t  if (lastRemovedArr) {\n\t    copyRgba(lastRemovedArr, rgbaArr);\n\t  }\n\t\n\t  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());\n\t}\n\t/**\n\t * @param {string} colorStr\n\t * @param {Array.<number>} out\n\t * @return {Array.<number>}\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\t\n\tfunction parse(colorStr, rgbaArr) {\n\t  if (!colorStr) {\n\t    return;\n\t  }\n\t\n\t  rgbaArr = rgbaArr || [];\n\t  var cached = colorCache.get(colorStr);\n\t\n\t  if (cached) {\n\t    return copyRgba(rgbaArr, cached);\n\t  } // colorStr may be not string\n\t\n\t\n\t  colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.\n\t\n\t  var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.\n\t\n\t  if (str in kCSSColorTable) {\n\t    copyRgba(rgbaArr, kCSSColorTable[str]);\n\t    putToCache(colorStr, rgbaArr);\n\t    return rgbaArr;\n\t  } // #abc and #abc123 syntax.\n\t\n\t\n\t  if (str.charAt(0) === '#') {\n\t    if (str.length === 4) {\n\t      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\t\n\t      if (!(iv >= 0 && iv <= 0xfff)) {\n\t        setRgba(rgbaArr, 0, 0, 0, 1);\n\t        return; // Covers NaN.\n\t      }\n\t\n\t      setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);\n\t      putToCache(colorStr, rgbaArr);\n\t      return rgbaArr;\n\t    } else if (str.length === 7) {\n\t      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\t\n\t      if (!(iv >= 0 && iv <= 0xffffff)) {\n\t        setRgba(rgbaArr, 0, 0, 0, 1);\n\t        return; // Covers NaN.\n\t      }\n\t\n\t      setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);\n\t      putToCache(colorStr, rgbaArr);\n\t      return rgbaArr;\n\t    }\n\t\n\t    return;\n\t  }\n\t\n\t  var op = str.indexOf('('),\n\t      ep = str.indexOf(')');\n\t\n\t  if (op !== -1 && ep + 1 === str.length) {\n\t    var fname = str.substr(0, op);\n\t    var params = str.substr(op + 1, ep - (op + 1)).split(',');\n\t    var alpha = 1; // To allow case fallthrough.\n\t\n\t    switch (fname) {\n\t      case 'rgba':\n\t        if (params.length !== 4) {\n\t          setRgba(rgbaArr, 0, 0, 0, 1);\n\t          return;\n\t        }\n\t\n\t        alpha = parseCssFloat(params.pop());\n\t      // jshint ignore:line\n\t      // Fall through.\n\t\n\t      case 'rgb':\n\t        if (params.length !== 3) {\n\t          setRgba(rgbaArr, 0, 0, 0, 1);\n\t          return;\n\t        }\n\t\n\t        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);\n\t        putToCache(colorStr, rgbaArr);\n\t        return rgbaArr;\n\t\n\t      case 'hsla':\n\t        if (params.length !== 4) {\n\t          setRgba(rgbaArr, 0, 0, 0, 1);\n\t          return;\n\t        }\n\t\n\t        params[3] = parseCssFloat(params[3]);\n\t        hsla2rgba(params, rgbaArr);\n\t        putToCache(colorStr, rgbaArr);\n\t        return rgbaArr;\n\t\n\t      case 'hsl':\n\t        if (params.length !== 3) {\n\t          setRgba(rgbaArr, 0, 0, 0, 1);\n\t          return;\n\t        }\n\t\n\t        hsla2rgba(params, rgbaArr);\n\t        putToCache(colorStr, rgbaArr);\n\t        return rgbaArr;\n\t\n\t      default:\n\t        return;\n\t    }\n\t  }\n\t\n\t  setRgba(rgbaArr, 0, 0, 0, 1);\n\t  return;\n\t}\n\t/**\n\t * @param {Array.<number>} hsla\n\t * @param {Array.<number>} rgba\n\t * @return {Array.<number>} rgba\n\t */\n\t\n\t\n\tfunction hsla2rgba(hsla, rgba) {\n\t  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1\n\t  // NOTE(deanm): According to the CSS spec s/l should only be\n\t  // percentages, but we don't bother and let float or percentage.\n\t\n\t  var s = parseCssFloat(hsla[1]);\n\t  var l = parseCssFloat(hsla[2]);\n\t  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n\t  var m1 = l * 2 - m2;\n\t  rgba = rgba || [];\n\t  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);\n\t\n\t  if (hsla.length === 4) {\n\t    rgba[3] = hsla[3];\n\t  }\n\t\n\t  return rgba;\n\t}\n\t/**\n\t * @param {Array.<number>} rgba\n\t * @return {Array.<number>} hsla\n\t */\n\t\n\t\n\tfunction rgba2hsla(rgba) {\n\t  if (!rgba) {\n\t    return;\n\t  } // RGB from 0 to 255\n\t\n\t\n\t  var R = rgba[0] / 255;\n\t  var G = rgba[1] / 255;\n\t  var B = rgba[2] / 255;\n\t  var vMin = Math.min(R, G, B); // Min. value of RGB\n\t\n\t  var vMax = Math.max(R, G, B); // Max. value of RGB\n\t\n\t  var delta = vMax - vMin; // Delta RGB value\n\t\n\t  var L = (vMax + vMin) / 2;\n\t  var H;\n\t  var S; // HSL results from 0 to 1\n\t\n\t  if (delta === 0) {\n\t    H = 0;\n\t    S = 0;\n\t  } else {\n\t    if (L < 0.5) {\n\t      S = delta / (vMax + vMin);\n\t    } else {\n\t      S = delta / (2 - vMax - vMin);\n\t    }\n\t\n\t    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;\n\t    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;\n\t    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;\n\t\n\t    if (R === vMax) {\n\t      H = deltaB - deltaG;\n\t    } else if (G === vMax) {\n\t      H = 1 / 3 + deltaR - deltaB;\n\t    } else if (B === vMax) {\n\t      H = 2 / 3 + deltaG - deltaR;\n\t    }\n\t\n\t    if (H < 0) {\n\t      H += 1;\n\t    }\n\t\n\t    if (H > 1) {\n\t      H -= 1;\n\t    }\n\t  }\n\t\n\t  var hsla = [H * 360, S, L];\n\t\n\t  if (rgba[3] != null) {\n\t    hsla.push(rgba[3]);\n\t  }\n\t\n\t  return hsla;\n\t}\n\t/**\n\t * @param {string} color\n\t * @param {number} level\n\t * @return {string}\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\t\n\tfunction lift(color, level) {\n\t  var colorArr = parse(color);\n\t\n\t  if (colorArr) {\n\t    for (var i = 0; i < 3; i++) {\n\t      if (level < 0) {\n\t        colorArr[i] = colorArr[i] * (1 - level) | 0;\n\t      } else {\n\t        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;\n\t      }\n\t    }\n\t\n\t    return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n\t  }\n\t}\n\t/**\n\t * @param {string} color\n\t * @return {string}\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\t\n\tfunction toHex(color) {\n\t  var colorArr = parse(color);\n\t\n\t  if (colorArr) {\n\t    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);\n\t  }\n\t}\n\t/**\n\t * Map value to color. Faster than lerp methods because color is represented by rgba array.\n\t * @param {number} normalizedValue A float between 0 and 1.\n\t * @param {Array.<Array.<number>>} colors List of rgba color array\n\t * @param {Array.<number>} [out] Mapped gba color array\n\t * @return {Array.<number>} will be null/undefined if input illegal.\n\t */\n\t\n\t\n\tfunction fastLerp(normalizedValue, colors, out) {\n\t  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n\t    return;\n\t  }\n\t\n\t  out = out || [];\n\t  var value = normalizedValue * (colors.length - 1);\n\t  var leftIndex = Math.floor(value);\n\t  var rightIndex = Math.ceil(value);\n\t  var leftColor = colors[leftIndex];\n\t  var rightColor = colors[rightIndex];\n\t  var dv = value - leftIndex;\n\t  out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));\n\t  out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));\n\t  out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));\n\t  out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));\n\t  return out;\n\t}\n\t/**\n\t * @deprecated\n\t */\n\t\n\t\n\tvar fastMapToColor = fastLerp;\n\t/**\n\t * @param {number} normalizedValue A float between 0 and 1.\n\t * @param {Array.<string>} colors Color list.\n\t * @param {boolean=} fullOutput Default false.\n\t * @return {(string|Object)} Result color. If fullOutput,\n\t *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\tfunction lerp(normalizedValue, colors, fullOutput) {\n\t  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n\t    return;\n\t  }\n\t\n\t  var value = normalizedValue * (colors.length - 1);\n\t  var leftIndex = Math.floor(value);\n\t  var rightIndex = Math.ceil(value);\n\t  var leftColor = parse(colors[leftIndex]);\n\t  var rightColor = parse(colors[rightIndex]);\n\t  var dv = value - leftIndex;\n\t  var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');\n\t  return fullOutput ? {\n\t    color: color,\n\t    leftIndex: leftIndex,\n\t    rightIndex: rightIndex,\n\t    value: value\n\t  } : color;\n\t}\n\t/**\n\t * @deprecated\n\t */\n\t\n\t\n\tvar mapToColor = lerp;\n\t/**\n\t * @param {string} color\n\t * @param {number=} h 0 ~ 360, ignore when null.\n\t * @param {number=} s 0 ~ 1, ignore when null.\n\t * @param {number=} l 0 ~ 1, ignore when null.\n\t * @return {string} Color string in rgba format.\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\tfunction modifyHSL(color, h, s, l) {\n\t  color = parse(color);\n\t\n\t  if (color) {\n\t    color = rgba2hsla(color);\n\t    h != null && (color[0] = clampCssAngle(h));\n\t    s != null && (color[1] = parseCssFloat(s));\n\t    l != null && (color[2] = parseCssFloat(l));\n\t    return stringify(hsla2rgba(color), 'rgba');\n\t  }\n\t}\n\t/**\n\t * @param {string} color\n\t * @param {number=} alpha 0 ~ 1\n\t * @return {string} Color string in rgba format.\n\t * @memberOf module:zrender/util/color\n\t */\n\t\n\t\n\tfunction modifyAlpha(color, alpha) {\n\t  color = parse(color);\n\t\n\t  if (color && alpha != null) {\n\t    color[3] = clampCssFloat(alpha);\n\t    return stringify(color, 'rgba');\n\t  }\n\t}\n\t/**\n\t * @param {Array.<number>} arrColor like [12,33,44,0.4]\n\t * @param {string} type 'rgba', 'hsva', ...\n\t * @return {string} Result color. (If input illegal, return undefined).\n\t */\n\t\n\t\n\tfunction stringify(arrColor, type) {\n\t  if (!arrColor || !arrColor.length) {\n\t    return;\n\t  }\n\t\n\t  var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\t\n\t  if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n\t    colorStr += ',' + arrColor[3];\n\t  }\n\t\n\t  return type + '(' + colorStr + ')';\n\t}\n\t\n\texports.parse = parse;\n\texports.lift = lift;\n\texports.toHex = toHex;\n\texports.fastLerp = fastLerp;\n\texports.fastMapToColor = fastMapToColor;\n\texports.lerp = lerp;\n\texports.mapToColor = mapToColor;\n\texports.modifyHSL = modifyHSL;\n\texports.modifyAlpha = modifyAlpha;\n\texports.stringify = stringify;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports) {\n\n\t// Simple LRU cache use doubly linked list\n\t// @module zrender/core/LRU\n\t\n\t/**\n\t * Simple double linked list. Compared with array, it has O(1) remove operation.\n\t * @constructor\n\t */\n\tvar LinkedList = function () {\n\t  /**\n\t   * @type {module:zrender/core/LRU~Entry}\n\t   */\n\t  this.head = null;\n\t  /**\n\t   * @type {module:zrender/core/LRU~Entry}\n\t   */\n\t\n\t  this.tail = null;\n\t  this._len = 0;\n\t};\n\t\n\tvar linkedListProto = LinkedList.prototype;\n\t/**\n\t * Insert a new value at the tail\n\t * @param  {} val\n\t * @return {module:zrender/core/LRU~Entry}\n\t */\n\t\n\tlinkedListProto.insert = function (val) {\n\t  var entry = new Entry(val);\n\t  this.insertEntry(entry);\n\t  return entry;\n\t};\n\t/**\n\t * Insert an entry at the tail\n\t * @param  {module:zrender/core/LRU~Entry} entry\n\t */\n\t\n\t\n\tlinkedListProto.insertEntry = function (entry) {\n\t  if (!this.head) {\n\t    this.head = this.tail = entry;\n\t  } else {\n\t    this.tail.next = entry;\n\t    entry.prev = this.tail;\n\t    entry.next = null;\n\t    this.tail = entry;\n\t  }\n\t\n\t  this._len++;\n\t};\n\t/**\n\t * Remove entry.\n\t * @param  {module:zrender/core/LRU~Entry} entry\n\t */\n\t\n\t\n\tlinkedListProto.remove = function (entry) {\n\t  var prev = entry.prev;\n\t  var next = entry.next;\n\t\n\t  if (prev) {\n\t    prev.next = next;\n\t  } else {\n\t    // Is head\n\t    this.head = next;\n\t  }\n\t\n\t  if (next) {\n\t    next.prev = prev;\n\t  } else {\n\t    // Is tail\n\t    this.tail = prev;\n\t  }\n\t\n\t  entry.next = entry.prev = null;\n\t  this._len--;\n\t};\n\t/**\n\t * @return {number}\n\t */\n\t\n\t\n\tlinkedListProto.len = function () {\n\t  return this._len;\n\t};\n\t/**\n\t * Clear list\n\t */\n\t\n\t\n\tlinkedListProto.clear = function () {\n\t  this.head = this.tail = null;\n\t  this._len = 0;\n\t};\n\t/**\n\t * @constructor\n\t * @param {} val\n\t */\n\t\n\t\n\tvar Entry = function (val) {\n\t  /**\n\t   * @type {}\n\t   */\n\t  this.value = val;\n\t  /**\n\t   * @type {module:zrender/core/LRU~Entry}\n\t   */\n\t\n\t  this.next;\n\t  /**\n\t   * @type {module:zrender/core/LRU~Entry}\n\t   */\n\t\n\t  this.prev;\n\t};\n\t/**\n\t * LRU Cache\n\t * @constructor\n\t * @alias module:zrender/core/LRU\n\t */\n\t\n\t\n\tvar LRU = function (maxSize) {\n\t  this._list = new LinkedList();\n\t  this._map = {};\n\t  this._maxSize = maxSize || 10;\n\t  this._lastRemovedEntry = null;\n\t};\n\t\n\tvar LRUProto = LRU.prototype;\n\t/**\n\t * @param  {string} key\n\t * @param  {} value\n\t * @return {} Removed value\n\t */\n\t\n\tLRUProto.put = function (key, value) {\n\t  var list = this._list;\n\t  var map = this._map;\n\t  var removed = null;\n\t\n\t  if (map[key] == null) {\n\t    var len = list.len(); // Reuse last removed entry\n\t\n\t    var entry = this._lastRemovedEntry;\n\t\n\t    if (len >= this._maxSize && len > 0) {\n\t      // Remove the least recently used\n\t      var leastUsedEntry = list.head;\n\t      list.remove(leastUsedEntry);\n\t      delete map[leastUsedEntry.key];\n\t      removed = leastUsedEntry.value;\n\t      this._lastRemovedEntry = leastUsedEntry;\n\t    }\n\t\n\t    if (entry) {\n\t      entry.value = value;\n\t    } else {\n\t      entry = new Entry(value);\n\t    }\n\t\n\t    entry.key = key;\n\t    list.insertEntry(entry);\n\t    map[key] = entry;\n\t  }\n\t\n\t  return removed;\n\t};\n\t/**\n\t * @param  {string} key\n\t * @return {}\n\t */\n\t\n\t\n\tLRUProto.get = function (key) {\n\t  var entry = this._map[key];\n\t  var list = this._list;\n\t\n\t  if (entry != null) {\n\t    // Put the latest used entry in the tail\n\t    if (entry !== list.tail) {\n\t      list.remove(entry);\n\t      list.insertEntry(entry);\n\t    }\n\t\n\t    return entry.value;\n\t  }\n\t};\n\t/**\n\t * Clear the cache\n\t */\n\t\n\t\n\tLRUProto.clear = function () {\n\t  this._list.clear();\n\t\n\t  this._map = {};\n\t};\n\t\n\tvar _default = LRU;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _config = __webpack_require__(22);\n\t\n\tvar debugMode = _config.debugMode;\n\t\n\tvar log = function () {};\n\t\n\tif (debugMode === 1) {\n\t  log = function () {\n\t    for (var k in arguments) {\n\t      throw new Error(arguments[k]);\n\t    }\n\t  };\n\t} else if (debugMode > 1) {\n\t  log = function () {\n\t    for (var k in arguments) {\n\t      console.log(arguments[k]);\n\t    }\n\t  };\n\t}\n\t\n\tvar _default = log;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\n\tvar dpr = 1; // If in browser environment\n\t\n\tif (typeof window !== 'undefined') {\n\t  dpr = Math.max(window.devicePixelRatio || 1, 1);\n\t}\n\t/**\n\t * config默认配置项\n\t * @exports zrender/config\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t */\n\t\n\t/**\n\t * debug日志选项：catchBrushException为true下有效\n\t * 0 : 不生成debug数据，发布用\n\t * 1 : 异常抛出，调试用\n\t * 2 : 控制台输出，调试用\n\t */\n\t\n\t\n\tvar debugMode = 0; // retina 屏幕优化\n\t\n\tvar devicePixelRatio = dpr;\n\texports.debugMode = debugMode;\n\texports.devicePixelRatio = devicePixelRatio;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar textHelper = __webpack_require__(24);\n\t\n\tvar BoundingRect = __webpack_require__(26);\n\t\n\t/**\n\t * Mixin for drawing text in a element bounding rect\n\t * @module zrender/mixin/RectText\n\t */\n\tvar tmpRect = new BoundingRect();\n\t\n\tvar RectText = function () {};\n\t\n\tRectText.prototype = {\n\t  constructor: RectText,\n\t\n\t  /**\n\t   * Draw text in a rect with specified position.\n\t   * @param  {CanvasRenderingContext2D} ctx\n\t   * @param  {Object} rect Displayable rect\n\t   */\n\t  drawRectText: function (ctx, rect) {\n\t    var style = this.style;\n\t    rect = style.textRect || rect; // Optimize, avoid normalize every time.\n\t\n\t    this.__dirty && textHelper.normalizeTextStyle(style, true);\n\t    var text = style.text; // Convert to string\n\t\n\t    text != null && (text += '');\n\t\n\t    if (!textHelper.needDrawText(text, style)) {\n\t      return;\n\t    } // FIXME\n\t\n\t\n\t    ctx.save(); // Transform rect to view space\n\t\n\t    var transform = this.transform;\n\t\n\t    if (!style.transformText) {\n\t      if (transform) {\n\t        tmpRect.copy(rect);\n\t        tmpRect.applyTransform(transform);\n\t        rect = tmpRect;\n\t      }\n\t    } else {\n\t      this.setTransform(ctx);\n\t    } // transformText and textRotation can not be used at the same time.\n\t\n\t\n\t    textHelper.renderText(this, ctx, text, style, rect);\n\t    ctx.restore();\n\t  }\n\t};\n\tvar _default = RectText;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _util = __webpack_require__(4);\n\t\n\tvar retrieve2 = _util.retrieve2;\n\tvar retrieve3 = _util.retrieve3;\n\tvar each = _util.each;\n\tvar normalizeCssArray = _util.normalizeCssArray;\n\tvar isString = _util.isString;\n\tvar isObject = _util.isObject;\n\t\n\tvar textContain = __webpack_require__(25);\n\t\n\tvar roundRectHelper = __webpack_require__(28);\n\t\n\tvar imageHelper = __webpack_require__(27);\n\t\n\t// TODO: Have not support 'start', 'end' yet.\n\tvar VALID_TEXT_ALIGN = {\n\t  left: 1,\n\t  right: 1,\n\t  center: 1\n\t};\n\tvar VALID_TEXT_VERTICAL_ALIGN = {\n\t  top: 1,\n\t  bottom: 1,\n\t  middle: 1\n\t};\n\t/**\n\t * @param {module:zrender/graphic/Style} style\n\t * @return {module:zrender/graphic/Style} The input style.\n\t */\n\t\n\tfunction normalizeTextStyle(style) {\n\t  normalizeStyle(style);\n\t  each(style.rich, normalizeStyle);\n\t  return style;\n\t}\n\t\n\tfunction normalizeStyle(style) {\n\t  if (style) {\n\t    style.font = textContain.makeFont(style);\n\t    var textAlign = style.textAlign;\n\t    textAlign === 'middle' && (textAlign = 'center');\n\t    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.\n\t\n\t    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n\t    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n\t    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';\n\t    var textPadding = style.textPadding;\n\t\n\t    if (textPadding) {\n\t      style.textPadding = normalizeCssArray(style.textPadding);\n\t    }\n\t  }\n\t}\n\t/**\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {string} text\n\t * @param {module:zrender/graphic/Style} style\n\t * @param {Object|boolean} [rect] {x, y, width, height}\n\t *                  If set false, rect text is not used.\n\t */\n\t\n\t\n\tfunction renderText(hostEl, ctx, text, style, rect) {\n\t  style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);\n\t}\n\t\n\tfunction renderPlainText(hostEl, ctx, text, style, rect) {\n\t  var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);\n\t  var textPadding = style.textPadding;\n\t  var contentBlock = hostEl.__textCotentBlock;\n\t\n\t  if (!contentBlock || hostEl.__dirty) {\n\t    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, font, textPadding, style.truncate);\n\t  }\n\t\n\t  var outerHeight = contentBlock.outerHeight;\n\t  var textLines = contentBlock.lines;\n\t  var lineHeight = contentBlock.lineHeight;\n\t  var boxPos = getBoxPosition(outerHeight, style, rect);\n\t  var baseX = boxPos.baseX;\n\t  var baseY = boxPos.baseY;\n\t  var textAlign = boxPos.textAlign;\n\t  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\t\n\t  applyTextRotation(ctx, style, rect, baseX, baseY);\n\t  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n\t  var textX = baseX;\n\t  var textY = boxY;\n\t  var needDrawBg = needDrawBackground(style);\n\t\n\t  if (needDrawBg || textPadding) {\n\t    // Consider performance, do not call getTextWidth util necessary.\n\t    var textWidth = textContain.getWidth(text, font);\n\t    var outerWidth = textWidth;\n\t    textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n\t    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n\t    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\t\n\t    if (textPadding) {\n\t      textX = getTextXForPadding(baseX, textAlign, textPadding);\n\t      textY += textPadding[0];\n\t    }\n\t  }\n\t\n\t  setCtx(ctx, 'textAlign', textAlign || 'left'); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n\t  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\t\n\t  setCtx(ctx, 'textBaseline', 'middle'); // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\t\n\t  setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);\n\t  setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');\n\t  setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);\n\t  setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0); // `textBaseline` is set as 'middle'.\n\t\n\t  textY += lineHeight / 2;\n\t  var textStrokeWidth = style.textStrokeWidth;\n\t  var textStroke = getStroke(style.textStroke, textStrokeWidth);\n\t  var textFill = getFill(style.textFill);\n\t\n\t  if (textStroke) {\n\t    setCtx(ctx, 'lineWidth', textStrokeWidth);\n\t    setCtx(ctx, 'strokeStyle', textStroke);\n\t  }\n\t\n\t  if (textFill) {\n\t    setCtx(ctx, 'fillStyle', textFill);\n\t  }\n\t\n\t  for (var i = 0; i < textLines.length; i++) {\n\t    // Fill after stroke so the outline will not cover the main part.\n\t    textStroke && ctx.strokeText(textLines[i], textX, textY);\n\t    textFill && ctx.fillText(textLines[i], textX, textY);\n\t    textY += lineHeight;\n\t  }\n\t}\n\t\n\tfunction renderRichText(hostEl, ctx, text, style, rect) {\n\t  var contentBlock = hostEl.__textCotentBlock;\n\t\n\t  if (!contentBlock || hostEl.__dirty) {\n\t    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n\t  }\n\t\n\t  drawRichText(hostEl, ctx, contentBlock, style, rect);\n\t}\n\t\n\tfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n\t  var contentWidth = contentBlock.width;\n\t  var outerWidth = contentBlock.outerWidth;\n\t  var outerHeight = contentBlock.outerHeight;\n\t  var textPadding = style.textPadding;\n\t  var boxPos = getBoxPosition(outerHeight, style, rect);\n\t  var baseX = boxPos.baseX;\n\t  var baseY = boxPos.baseY;\n\t  var textAlign = boxPos.textAlign;\n\t  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\t\n\t  applyTextRotation(ctx, style, rect, baseX, baseY);\n\t  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n\t  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n\t  var xLeft = boxX;\n\t  var lineTop = boxY;\n\t\n\t  if (textPadding) {\n\t    xLeft += textPadding[3];\n\t    lineTop += textPadding[0];\n\t  }\n\t\n\t  var xRight = xLeft + contentWidth;\n\t  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\t\n\t  for (var i = 0; i < contentBlock.lines.length; i++) {\n\t    var line = contentBlock.lines[i];\n\t    var tokens = line.tokens;\n\t    var tokenCount = tokens.length;\n\t    var lineHeight = line.lineHeight;\n\t    var usedWidth = line.width;\n\t    var leftIndex = 0;\n\t    var lineXLeft = xLeft;\n\t    var lineXRight = xRight;\n\t    var rightIndex = tokenCount - 1;\n\t    var token;\n\t\n\t    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {\n\t      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n\t      usedWidth -= token.width;\n\t      lineXLeft += token.width;\n\t      leftIndex++;\n\t    }\n\t\n\t    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {\n\t      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n\t      usedWidth -= token.width;\n\t      lineXRight -= token.width;\n\t      rightIndex--;\n\t    } // The other tokens are placed as textAlign 'center' if there is enough space.\n\t\n\t\n\t    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n\t\n\t    while (leftIndex <= rightIndex) {\n\t      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.\n\t\n\t      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n\t      lineXLeft += token.width;\n\t      leftIndex++;\n\t    }\n\t\n\t    lineTop += lineHeight;\n\t  }\n\t}\n\t\n\tfunction applyTextRotation(ctx, style, rect, x, y) {\n\t  // textRotation only apply in RectText.\n\t  if (rect && style.textRotation) {\n\t    var origin = style.textOrigin;\n\t\n\t    if (origin === 'center') {\n\t      x = rect.width / 2 + rect.x;\n\t      y = rect.height / 2 + rect.y;\n\t    } else if (origin) {\n\t      x = origin[0] + rect.x;\n\t      y = origin[1] + rect.y;\n\t    }\n\t\n\t    ctx.translate(x, y); // Positive: anticlockwise\n\t\n\t    ctx.rotate(-style.textRotation);\n\t    ctx.translate(-x, -y);\n\t  }\n\t}\n\t\n\tfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n\t  var tokenStyle = style.rich[token.styleName] || {}; // 'ctx.textBaseline' is always set as 'middle', for sake of\n\t  // the bias of \"Microsoft YaHei\".\n\t\n\t  var textVerticalAlign = token.textVerticalAlign;\n\t  var y = lineTop + lineHeight / 2;\n\t\n\t  if (textVerticalAlign === 'top') {\n\t    y = lineTop + token.height / 2;\n\t  } else if (textVerticalAlign === 'bottom') {\n\t    y = lineTop + lineHeight - token.height / 2;\n\t  }\n\t\n\t  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);\n\t  var textPadding = token.textPadding;\n\t\n\t  if (textPadding) {\n\t    x = getTextXForPadding(x, textAlign, textPadding);\n\t    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n\t  }\n\t\n\t  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n\t  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n\t  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n\t  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n\t  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n\t  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\t\n\t  setCtx(ctx, 'textBaseline', 'middle');\n\t  setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);\n\t  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n\t  var textFill = getFill(tokenStyle.textFill || style.textFill);\n\t  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.\n\t\n\t  if (textStroke) {\n\t    setCtx(ctx, 'lineWidth', textStrokeWidth);\n\t    setCtx(ctx, 'strokeStyle', textStroke);\n\t    ctx.strokeText(token.text, x, y);\n\t  }\n\t\n\t  if (textFill) {\n\t    setCtx(ctx, 'fillStyle', textFill);\n\t    ctx.fillText(token.text, x, y);\n\t  }\n\t}\n\t\n\tfunction needDrawBackground(style) {\n\t  return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;\n\t} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}\n\t// shape: {x, y, width, height}\n\t\n\t\n\tfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n\t  var textBackgroundColor = style.textBackgroundColor;\n\t  var textBorderWidth = style.textBorderWidth;\n\t  var textBorderColor = style.textBorderColor;\n\t  var isPlainBg = isString(textBackgroundColor);\n\t  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n\t  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n\t  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n\t  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\t\n\t  if (isPlainBg || textBorderWidth && textBorderColor) {\n\t    ctx.beginPath();\n\t    var textBorderRadius = style.textBorderRadius;\n\t\n\t    if (!textBorderRadius) {\n\t      ctx.rect(x, y, width, height);\n\t    } else {\n\t      roundRectHelper.buildPath(ctx, {\n\t        x: x,\n\t        y: y,\n\t        width: width,\n\t        height: height,\n\t        r: textBorderRadius\n\t      });\n\t    }\n\t\n\t    ctx.closePath();\n\t  }\n\t\n\t  if (isPlainBg) {\n\t    setCtx(ctx, 'fillStyle', textBackgroundColor);\n\t    ctx.fill();\n\t  } else if (isObject(textBackgroundColor)) {\n\t    var image = textBackgroundColor.image;\n\t    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);\n\t\n\t    if (image && imageHelper.isImageReady(image)) {\n\t      ctx.drawImage(image, x, y, width, height);\n\t    }\n\t  }\n\t\n\t  if (textBorderWidth && textBorderColor) {\n\t    setCtx(ctx, 'lineWidth', textBorderWidth);\n\t    setCtx(ctx, 'strokeStyle', textBorderColor);\n\t    ctx.stroke();\n\t  }\n\t}\n\t\n\tfunction onBgImageLoaded(image, textBackgroundColor) {\n\t  // Replace image, so that `contain/text.js#parseRichText`\n\t  // will get correct result in next tick.\n\t  textBackgroundColor.image = image;\n\t}\n\t\n\tfunction getBoxPosition(blockHeiht, style, rect) {\n\t  var baseX = style.x || 0;\n\t  var baseY = style.y || 0;\n\t  var textAlign = style.textAlign;\n\t  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord\n\t\n\t  if (rect) {\n\t    var textPosition = style.textPosition;\n\t\n\t    if (textPosition instanceof Array) {\n\t      // Percent\n\t      baseX = rect.x + parsePercent(textPosition[0], rect.width);\n\t      baseY = rect.y + parsePercent(textPosition[1], rect.height);\n\t    } else {\n\t      var res = textContain.adjustTextPositionOnRect(textPosition, rect, style.textDistance);\n\t      baseX = res.x;\n\t      baseY = res.y; // Default align and baseline when has textPosition\n\t\n\t      textAlign = textAlign || res.textAlign;\n\t      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n\t    } // textOffset is only support in RectText, otherwise\n\t    // we have to adjust boundingRect for textOffset.\n\t\n\t\n\t    var textOffset = style.textOffset;\n\t\n\t    if (textOffset) {\n\t      baseX += textOffset[0];\n\t      baseY += textOffset[1];\n\t    }\n\t  }\n\t\n\t  return {\n\t    baseX: baseX,\n\t    baseY: baseY,\n\t    textAlign: textAlign,\n\t    textVerticalAlign: textVerticalAlign\n\t  };\n\t}\n\t\n\tfunction setCtx(ctx, prop, value) {\n\t  // FIXME ??? performance try\n\t  // if (ctx.__currentValues[prop] !== value) {\n\t  // ctx[prop] = ctx.__currentValues[prop] = value;\n\t  ctx[prop] = value; // }\n\t\n\t  return ctx[prop];\n\t}\n\t/**\n\t * @param {string} [stroke] If specified, do not check style.textStroke.\n\t * @param {string} [lineWidth] If specified, do not check style.textStroke.\n\t * @param {number} style\n\t */\n\t\n\t\n\tfunction getStroke(stroke, lineWidth) {\n\t  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?\n\t  : stroke.image || stroke.colorStops ? '#000' : stroke;\n\t}\n\t\n\tfunction getFill(fill) {\n\t  return fill == null || fill === 'none' ? null // TODO pattern and gradient?\n\t  : fill.image || fill.colorStops ? '#000' : fill;\n\t}\n\t\n\tfunction parsePercent(value, maxValue) {\n\t  if (typeof value === 'string') {\n\t    if (value.lastIndexOf('%') >= 0) {\n\t      return parseFloat(value) / 100 * maxValue;\n\t    }\n\t\n\t    return parseFloat(value);\n\t  }\n\t\n\t  return value;\n\t}\n\t\n\tfunction getTextXForPadding(x, textAlign, textPadding) {\n\t  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n\t}\n\t/**\n\t * @param {string} text\n\t * @param {module:zrender/Style} style\n\t * @return {boolean}\n\t */\n\t\n\t\n\tfunction needDrawText(text, style) {\n\t  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);\n\t}\n\t\n\texports.normalizeTextStyle = normalizeTextStyle;\n\texports.renderText = renderText;\n\texports.getStroke = getStroke;\n\texports.getFill = getFill;\n\texports.needDrawText = needDrawText;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar BoundingRect = __webpack_require__(26);\n\t\n\tvar imageHelper = __webpack_require__(27);\n\t\n\tvar _util = __webpack_require__(4);\n\t\n\tvar getContext = _util.getContext;\n\tvar extend = _util.extend;\n\tvar retrieve2 = _util.retrieve2;\n\tvar retrieve3 = _util.retrieve3;\n\tvar textWidthCache = {};\n\tvar textWidthCacheCounter = 0;\n\tvar TEXT_CACHE_MAX = 5000;\n\tvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\n\tvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\t\n\tvar methods = {};\n\t\n\tfunction $override(name, fn) {\n\t  methods[name] = fn;\n\t}\n\t/**\n\t * @public\n\t * @param {string} text\n\t * @param {string} font\n\t * @return {number} width\n\t */\n\t\n\t\n\tfunction getWidth(text, font) {\n\t  font = font || DEFAULT_FONT;\n\t  var key = text + ':' + font;\n\t\n\t  if (textWidthCache[key]) {\n\t    return textWidthCache[key];\n\t  }\n\t\n\t  var textLines = (text + '').split('\\n');\n\t  var width = 0;\n\t\n\t  for (var i = 0, l = textLines.length; i < l; i++) {\n\t    // textContain.measureText may be overrided in SVG or VML\n\t    width = Math.max(measureText(textLines[i], font).width, width);\n\t  }\n\t\n\t  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n\t    textWidthCacheCounter = 0;\n\t    textWidthCache = {};\n\t  }\n\t\n\t  textWidthCacheCounter++;\n\t  textWidthCache[key] = width;\n\t  return width;\n\t}\n\t/**\n\t * @public\n\t * @param {string} text\n\t * @param {string} font\n\t * @param {string} [textAlign='left']\n\t * @param {string} [textVerticalAlign='top']\n\t * @param {Array.<number>} [textPadding]\n\t * @param {Object} [rich]\n\t * @param {Object} [truncate]\n\t * @return {Object} {x, y, width, height, lineHeight}\n\t */\n\t\n\t\n\tfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n\t  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);\n\t}\n\t\n\tfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {\n\t  var contentBlock = parsePlainText(text, font, textPadding, truncate);\n\t  var outerWidth = getWidth(text, font);\n\t\n\t  if (textPadding) {\n\t    outerWidth += textPadding[1] + textPadding[3];\n\t  }\n\t\n\t  var outerHeight = contentBlock.outerHeight;\n\t  var x = adjustTextX(0, outerWidth, textAlign);\n\t  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n\t  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n\t  rect.lineHeight = contentBlock.lineHeight;\n\t  return rect;\n\t}\n\t\n\tfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n\t  var contentBlock = parseRichText(text, {\n\t    rich: rich,\n\t    truncate: truncate,\n\t    font: font,\n\t    textAlign: textAlign,\n\t    textPadding: textPadding\n\t  });\n\t  var outerWidth = contentBlock.outerWidth;\n\t  var outerHeight = contentBlock.outerHeight;\n\t  var x = adjustTextX(0, outerWidth, textAlign);\n\t  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n\t  return new BoundingRect(x, y, outerWidth, outerHeight);\n\t}\n\t/**\n\t * @public\n\t * @param {number} x\n\t * @param {number} width\n\t * @param {string} [textAlign='left']\n\t * @return {number} Adjusted x.\n\t */\n\t\n\t\n\tfunction adjustTextX(x, width, textAlign) {\n\t  // FIXME Right to left language\n\t  if (textAlign === 'right') {\n\t    x -= width;\n\t  } else if (textAlign === 'center') {\n\t    x -= width / 2;\n\t  }\n\t\n\t  return x;\n\t}\n\t/**\n\t * @public\n\t * @param {number} y\n\t * @param {number} height\n\t * @param {string} [textVerticalAlign='top']\n\t * @return {number} Adjusted y.\n\t */\n\t\n\t\n\tfunction adjustTextY(y, height, textVerticalAlign) {\n\t  if (textVerticalAlign === 'middle') {\n\t    y -= height / 2;\n\t  } else if (textVerticalAlign === 'bottom') {\n\t    y -= height;\n\t  }\n\t\n\t  return y;\n\t}\n\t/**\n\t * @public\n\t * @param {stirng} textPosition\n\t * @param {Object} rect {x, y, width, height}\n\t * @param {number} distance\n\t * @return {Object} {x, y, textAlign, textVerticalAlign}\n\t */\n\t\n\t\n\tfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n\t  var x = rect.x;\n\t  var y = rect.y;\n\t  var height = rect.height;\n\t  var width = rect.width;\n\t  var halfHeight = height / 2;\n\t  var textAlign = 'left';\n\t  var textVerticalAlign = 'top';\n\t\n\t  switch (textPosition) {\n\t    case 'left':\n\t      x -= distance;\n\t      y += halfHeight;\n\t      textAlign = 'right';\n\t      textVerticalAlign = 'middle';\n\t      break;\n\t\n\t    case 'right':\n\t      x += distance + width;\n\t      y += halfHeight;\n\t      textVerticalAlign = 'middle';\n\t      break;\n\t\n\t    case 'top':\n\t      x += width / 2;\n\t      y -= distance;\n\t      textAlign = 'center';\n\t      textVerticalAlign = 'bottom';\n\t      break;\n\t\n\t    case 'bottom':\n\t      x += width / 2;\n\t      y += height + distance;\n\t      textAlign = 'center';\n\t      break;\n\t\n\t    case 'inside':\n\t      x += width / 2;\n\t      y += halfHeight;\n\t      textAlign = 'center';\n\t      textVerticalAlign = 'middle';\n\t      break;\n\t\n\t    case 'insideLeft':\n\t      x += distance;\n\t      y += halfHeight;\n\t      textVerticalAlign = 'middle';\n\t      break;\n\t\n\t    case 'insideRight':\n\t      x += width - distance;\n\t      y += halfHeight;\n\t      textAlign = 'right';\n\t      textVerticalAlign = 'middle';\n\t      break;\n\t\n\t    case 'insideTop':\n\t      x += width / 2;\n\t      y += distance;\n\t      textAlign = 'center';\n\t      break;\n\t\n\t    case 'insideBottom':\n\t      x += width / 2;\n\t      y += height - distance;\n\t      textAlign = 'center';\n\t      textVerticalAlign = 'bottom';\n\t      break;\n\t\n\t    case 'insideTopLeft':\n\t      x += distance;\n\t      y += distance;\n\t      break;\n\t\n\t    case 'insideTopRight':\n\t      x += width - distance;\n\t      y += distance;\n\t      textAlign = 'right';\n\t      break;\n\t\n\t    case 'insideBottomLeft':\n\t      x += distance;\n\t      y += height - distance;\n\t      textVerticalAlign = 'bottom';\n\t      break;\n\t\n\t    case 'insideBottomRight':\n\t      x += width - distance;\n\t      y += height - distance;\n\t      textAlign = 'right';\n\t      textVerticalAlign = 'bottom';\n\t      break;\n\t  }\n\t\n\t  return {\n\t    x: x,\n\t    y: y,\n\t    textAlign: textAlign,\n\t    textVerticalAlign: textVerticalAlign\n\t  };\n\t}\n\t/**\n\t * Show ellipsis if overflow.\n\t *\n\t * @public\n\t * @param  {string} text\n\t * @param  {string} containerWidth\n\t * @param  {string} font\n\t * @param  {number} [ellipsis='...']\n\t * @param  {Object} [options]\n\t * @param  {number} [options.maxIterations=3]\n\t * @param  {number} [options.minChar=0] If truncate result are less\n\t *                  then minChar, ellipsis will not show, which is\n\t *                  better for user hint in some cases.\n\t * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n\t * @return {string}\n\t */\n\t\n\t\n\tfunction truncateText(text, containerWidth, font, ellipsis, options) {\n\t  if (!containerWidth) {\n\t    return '';\n\t  }\n\t\n\t  var textLines = (text + '').split('\\n');\n\t  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n\t  // It is not appropriate that every line has '...' when truncate multiple lines.\n\t\n\t  for (var i = 0, len = textLines.length; i < len; i++) {\n\t    textLines[i] = truncateSingleLine(textLines[i], options);\n\t  }\n\t\n\t  return textLines.join('\\n');\n\t}\n\t\n\tfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n\t  options = extend({}, options);\n\t  options.font = font;\n\t  var ellipsis = retrieve2(ellipsis, '...');\n\t  options.maxIterations = retrieve2(options.maxIterations, 2);\n\t  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n\t  // Other languages?\n\t\n\t  options.cnCharWidth = getWidth('国', font); // FIXME\n\t  // Consider proportional font?\n\t\n\t  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n\t  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n\t  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\t\n\t  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\t\n\t  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n\t    contentWidth -= ascCharWidth;\n\t  }\n\t\n\t  var ellipsisWidth = getWidth(ellipsis);\n\t\n\t  if (ellipsisWidth > contentWidth) {\n\t    ellipsis = '';\n\t    ellipsisWidth = 0;\n\t  }\n\t\n\t  contentWidth = containerWidth - ellipsisWidth;\n\t  options.ellipsis = ellipsis;\n\t  options.ellipsisWidth = ellipsisWidth;\n\t  options.contentWidth = contentWidth;\n\t  options.containerWidth = containerWidth;\n\t  return options;\n\t}\n\t\n\tfunction truncateSingleLine(textLine, options) {\n\t  var containerWidth = options.containerWidth;\n\t  var font = options.font;\n\t  var contentWidth = options.contentWidth;\n\t\n\t  if (!containerWidth) {\n\t    return '';\n\t  }\n\t\n\t  var lineWidth = getWidth(textLine, font);\n\t\n\t  if (lineWidth <= containerWidth) {\n\t    return textLine;\n\t  }\n\t\n\t  for (var j = 0;; j++) {\n\t    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n\t      textLine += options.ellipsis;\n\t      break;\n\t    }\n\t\n\t    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n\t    textLine = textLine.substr(0, subLength);\n\t    lineWidth = getWidth(textLine, font);\n\t  }\n\t\n\t  if (textLine === '') {\n\t    textLine = options.placeholder;\n\t  }\n\t\n\t  return textLine;\n\t}\n\t\n\tfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n\t  var width = 0;\n\t  var i = 0;\n\t\n\t  for (var len = text.length; i < len && width < contentWidth; i++) {\n\t    var charCode = text.charCodeAt(i);\n\t    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n\t  }\n\t\n\t  return i;\n\t}\n\t/**\n\t * @public\n\t * @param {string} font\n\t * @return {number} line height\n\t */\n\t\n\t\n\tfunction getLineHeight(font) {\n\t  // FIXME A rough approach.\n\t  return getWidth('国', font);\n\t}\n\t/**\n\t * @public\n\t * @param {string} text\n\t * @param {string} font\n\t * @return {Object} width\n\t */\n\t\n\t\n\tfunction measureText(text, font) {\n\t  return methods.measureText(text, font);\n\t} // Avoid assign to an exported variable, for transforming to cjs.\n\t\n\t\n\tmethods.measureText = function (text, font) {\n\t  var ctx = getContext();\n\t  ctx.font = font || DEFAULT_FONT;\n\t  return ctx.measureText(text);\n\t};\n\t/**\n\t * @public\n\t * @param {string} text\n\t * @param {string} font\n\t * @param {Object} [truncate]\n\t * @return {Object} block: {lineHeight, lines, height, outerHeight}\n\t *  Notice: for performance, do not calculate outerWidth util needed.\n\t */\n\t\n\t\n\tfunction parsePlainText(text, font, padding, truncate) {\n\t  text != null && (text += '');\n\t  var lineHeight = getLineHeight(font);\n\t  var lines = text ? text.split('\\n') : [];\n\t  var height = lines.length * lineHeight;\n\t  var outerHeight = height;\n\t\n\t  if (padding) {\n\t    outerHeight += padding[0] + padding[2];\n\t  }\n\t\n\t  if (text && truncate) {\n\t    var truncOuterHeight = truncate.outerHeight;\n\t    var truncOuterWidth = truncate.outerWidth;\n\t\n\t    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n\t      text = '';\n\t      lines = [];\n\t    } else if (truncOuterWidth != null) {\n\t      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n\t        minChar: truncate.minChar,\n\t        placeholder: truncate.placeholder\n\t      }); // FIXME\n\t      // It is not appropriate that every line has '...' when truncate multiple lines.\n\t\n\t      for (var i = 0, len = lines.length; i < len; i++) {\n\t        lines[i] = truncateSingleLine(lines[i], options);\n\t      }\n\t    }\n\t  }\n\t\n\t  return {\n\t    lines: lines,\n\t    height: height,\n\t    outerHeight: outerHeight,\n\t    lineHeight: lineHeight\n\t  };\n\t}\n\t/**\n\t * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n\t * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n\t *\n\t * @public\n\t * @param {string} text\n\t * @param {Object} style\n\t * @return {Object} block\n\t * {\n\t *      width,\n\t *      height,\n\t *      lines: [{\n\t *          lineHeight,\n\t *          width,\n\t *          tokens: [[{\n\t *              styleName,\n\t *              text,\n\t *              width,      // include textPadding\n\t *              height,     // include textPadding\n\t *              textWidth, // pure text width\n\t *              textHeight, // pure text height\n\t *              lineHeihgt,\n\t *              font,\n\t *              textAlign,\n\t *              textVerticalAlign\n\t *          }], [...], ...]\n\t *      }, ...]\n\t * }\n\t * If styleName is undefined, it is plain text.\n\t */\n\t\n\t\n\tfunction parseRichText(text, style) {\n\t  var contentBlock = {\n\t    lines: [],\n\t    width: 0,\n\t    height: 0\n\t  };\n\t  text != null && (text += '');\n\t\n\t  if (!text) {\n\t    return contentBlock;\n\t  }\n\t\n\t  var lastIndex = STYLE_REG.lastIndex = 0;\n\t  var result;\n\t\n\t  while ((result = STYLE_REG.exec(text)) != null) {\n\t    var matchedIndex = result.index;\n\t\n\t    if (matchedIndex > lastIndex) {\n\t      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n\t    }\n\t\n\t    pushTokens(contentBlock, result[2], result[1]);\n\t    lastIndex = STYLE_REG.lastIndex;\n\t  }\n\t\n\t  if (lastIndex < text.length) {\n\t    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n\t  }\n\t\n\t  var lines = contentBlock.lines;\n\t  var contentHeight = 0;\n\t  var contentWidth = 0; // For `textWidth: 100%`\n\t\n\t  var pendingList = [];\n\t  var stlPadding = style.textPadding;\n\t  var truncate = style.truncate;\n\t  var truncateWidth = truncate && truncate.outerWidth;\n\t  var truncateHeight = truncate && truncate.outerHeight;\n\t\n\t  if (stlPadding) {\n\t    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n\t    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n\t  } // Calculate layout info of tokens.\n\t\n\t\n\t  for (var i = 0; i < lines.length; i++) {\n\t    var line = lines[i];\n\t    var lineHeight = 0;\n\t    var lineWidth = 0;\n\t\n\t    for (var j = 0; j < line.tokens.length; j++) {\n\t      var token = line.tokens[j];\n\t      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\t\n\t      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\t\n\t      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\t\n\t      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n\t      // as box height of the block.\n\t      tokenStyle.textHeight, getLineHeight(font));\n\t      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n\t      token.height = tokenHeight;\n\t      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n\t      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n\t      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\t\n\t      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n\t        return {\n\t          lines: [],\n\t          width: 0,\n\t          height: 0\n\t        };\n\t      }\n\t\n\t      token.textWidth = getWidth(token.text, font);\n\t      var tokenWidth = tokenStyle.textWidth;\n\t      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n\t      // line when box width is needed to be auto.\n\t\n\t      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n\t        token.percentWidth = tokenWidth;\n\t        pendingList.push(token);\n\t        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n\t        // and it is too complicated.\n\t      } else {\n\t        if (tokenWidthNotSpecified) {\n\t          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n\t          // `getBoundingRect()` will not get correct result.\n\t\n\t          var textBackgroundColor = tokenStyle.textBackgroundColor;\n\t          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n\t          // (1) If image is not loaded, it will be loaded at render phase and call\n\t          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n\t          // image, and then the right size will be calculated here at the next tick.\n\t          // See `graphic/helper/text.js`.\n\t          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n\t          // use `imageHelper.findExistImage` to find cached image.\n\t          // `imageHelper.findExistImage` will always be called here before\n\t          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n\t          // which ensures that image will not be rendered before correct size calcualted.\n\t\n\t          if (bgImg) {\n\t            bgImg = imageHelper.findExistImage(bgImg);\n\t\n\t            if (imageHelper.isImageReady(bgImg)) {\n\t              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n\t            }\n\t          }\n\t        }\n\t\n\t        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n\t        tokenWidth += paddingW;\n\t        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\t\n\t        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n\t          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n\t            token.text = '';\n\t            token.textWidth = tokenWidth = 0;\n\t          } else {\n\t            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n\t              minChar: truncate.minChar\n\t            });\n\t            token.textWidth = getWidth(token.text, font);\n\t            tokenWidth = token.textWidth + paddingW;\n\t          }\n\t        }\n\t      }\n\t\n\t      lineWidth += token.width = tokenWidth;\n\t      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n\t    }\n\t\n\t    line.width = lineWidth;\n\t    line.lineHeight = lineHeight;\n\t    contentHeight += lineHeight;\n\t    contentWidth = Math.max(contentWidth, lineWidth);\n\t  }\n\t\n\t  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n\t  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\t\n\t  if (stlPadding) {\n\t    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n\t    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n\t  }\n\t\n\t  for (var i = 0; i < pendingList.length; i++) {\n\t    var token = pendingList[i];\n\t    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\t\n\t    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n\t  }\n\t\n\t  return contentBlock;\n\t}\n\t\n\tfunction pushTokens(block, str, styleName) {\n\t  var isEmptyStr = str === '';\n\t  var strs = str.split('\\n');\n\t  var lines = block.lines;\n\t\n\t  for (var i = 0; i < strs.length; i++) {\n\t    var text = strs[i];\n\t    var token = {\n\t      styleName: styleName,\n\t      text: text,\n\t      isLineHolder: !text && !isEmptyStr\n\t    }; // The first token should be appended to the last line.\n\t\n\t    if (!i) {\n\t      var tokens = (lines[lines.length - 1] || (lines[0] = {\n\t        tokens: []\n\t      })).tokens; // Consider cases:\n\t      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n\t      // (which is a placeholder) should be replaced by new token.\n\t      // (2) A image backage, where token likes {a|}.\n\t      // (3) A redundant '' will affect textAlign in line.\n\t      // (4) tokens with the same tplName should not be merged, because\n\t      // they should be displayed in different box (with border and padding).\n\t\n\t      var tokensLen = tokens.length;\n\t      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n\t      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n\t      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n\t    } // Other tokens always start a new line.\n\t    else {\n\t        // If there is '', insert it as a placeholder.\n\t        lines.push({\n\t          tokens: [token]\n\t        });\n\t      }\n\t  }\n\t}\n\t\n\tfunction makeFont(style) {\n\t  // FIXME in node-canvas fontWeight is before fontStyle\n\t  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n\t  return (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n\t  style.fontFamily || 'sans-serif'].join(' ') || style.textFont || style.font;\n\t}\n\t\n\texports.DEFAULT_FONT = DEFAULT_FONT;\n\texports.$override = $override;\n\texports.getWidth = getWidth;\n\texports.getBoundingRect = getBoundingRect;\n\texports.adjustTextX = adjustTextX;\n\texports.adjustTextY = adjustTextY;\n\texports.adjustTextPositionOnRect = adjustTextPositionOnRect;\n\texports.truncateText = truncateText;\n\texports.getLineHeight = getLineHeight;\n\texports.measureText = measureText;\n\texports.parsePlainText = parsePlainText;\n\texports.parseRichText = parseRichText;\n\texports.makeFont = makeFont;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar vec2 = __webpack_require__(14);\n\t\n\tvar matrix = __webpack_require__(13);\n\t\n\t/**\n\t * @module echarts/core/BoundingRect\n\t */\n\tvar v2ApplyTransform = vec2.applyTransform;\n\tvar mathMin = Math.min;\n\tvar mathMax = Math.max;\n\t/**\n\t * @alias module:echarts/core/BoundingRect\n\t */\n\t\n\tfunction BoundingRect(x, y, width, height) {\n\t  if (width < 0) {\n\t    x = x + width;\n\t    width = -width;\n\t  }\n\t\n\t  if (height < 0) {\n\t    y = y + height;\n\t    height = -height;\n\t  }\n\t  /**\n\t   * @type {number}\n\t   */\n\t\n\t\n\t  this.x = x;\n\t  /**\n\t   * @type {number}\n\t   */\n\t\n\t  this.y = y;\n\t  /**\n\t   * @type {number}\n\t   */\n\t\n\t  this.width = width;\n\t  /**\n\t   * @type {number}\n\t   */\n\t\n\t  this.height = height;\n\t}\n\t\n\tBoundingRect.prototype = {\n\t  constructor: BoundingRect,\n\t\n\t  /**\n\t   * @param {module:echarts/core/BoundingRect} other\n\t   */\n\t  union: function (other) {\n\t    var x = mathMin(other.x, this.x);\n\t    var y = mathMin(other.y, this.y);\n\t    this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n\t    this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n\t    this.x = x;\n\t    this.y = y;\n\t  },\n\t\n\t  /**\n\t   * @param {Array.<number>} m\n\t   * @methods\n\t   */\n\t  applyTransform: function () {\n\t    var lt = [];\n\t    var rb = [];\n\t    var lb = [];\n\t    var rt = [];\n\t    return function (m) {\n\t      // In case usage like this\n\t      // el.getBoundingRect().applyTransform(el.transform)\n\t      // And element has no transform\n\t      if (!m) {\n\t        return;\n\t      }\n\t\n\t      lt[0] = lb[0] = this.x;\n\t      lt[1] = rt[1] = this.y;\n\t      rb[0] = rt[0] = this.x + this.width;\n\t      rb[1] = lb[1] = this.y + this.height;\n\t      v2ApplyTransform(lt, lt, m);\n\t      v2ApplyTransform(rb, rb, m);\n\t      v2ApplyTransform(lb, lb, m);\n\t      v2ApplyTransform(rt, rt, m);\n\t      this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n\t      this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n\t      var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n\t      var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n\t      this.width = maxX - this.x;\n\t      this.height = maxY - this.y;\n\t    };\n\t  }(),\n\t\n\t  /**\n\t   * Calculate matrix of transforming from self to target rect\n\t   * @param  {module:zrender/core/BoundingRect} b\n\t   * @return {Array.<number>}\n\t   */\n\t  calculateTransform: function (b) {\n\t    var a = this;\n\t    var sx = b.width / a.width;\n\t    var sy = b.height / a.height;\n\t    var m = matrix.create(); // 矩阵右乘\n\t\n\t    matrix.translate(m, m, [-a.x, -a.y]);\n\t    matrix.scale(m, m, [sx, sy]);\n\t    matrix.translate(m, m, [b.x, b.y]);\n\t    return m;\n\t  },\n\t\n\t  /**\n\t   * @param {(module:echarts/core/BoundingRect|Object)} b\n\t   * @return {boolean}\n\t   */\n\t  intersect: function (b) {\n\t    if (!b) {\n\t      return false;\n\t    }\n\t\n\t    if (!(b instanceof BoundingRect)) {\n\t      // Normalize negative width/height.\n\t      b = BoundingRect.create(b);\n\t    }\n\t\n\t    var a = this;\n\t    var ax0 = a.x;\n\t    var ax1 = a.x + a.width;\n\t    var ay0 = a.y;\n\t    var ay1 = a.y + a.height;\n\t    var bx0 = b.x;\n\t    var bx1 = b.x + b.width;\n\t    var by0 = b.y;\n\t    var by1 = b.y + b.height;\n\t    return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n\t  },\n\t  contain: function (x, y) {\n\t    var rect = this;\n\t    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n\t  },\n\t\n\t  /**\n\t   * @return {module:echarts/core/BoundingRect}\n\t   */\n\t  clone: function () {\n\t    return new BoundingRect(this.x, this.y, this.width, this.height);\n\t  },\n\t\n\t  /**\n\t   * Copy from another rect\n\t   */\n\t  copy: function (other) {\n\t    this.x = other.x;\n\t    this.y = other.y;\n\t    this.width = other.width;\n\t    this.height = other.height;\n\t  },\n\t  plain: function () {\n\t    return {\n\t      x: this.x,\n\t      y: this.y,\n\t      width: this.width,\n\t      height: this.height\n\t    };\n\t  }\n\t};\n\t/**\n\t * @param {Object|module:zrender/core/BoundingRect} rect\n\t * @param {number} rect.x\n\t * @param {number} rect.y\n\t * @param {number} rect.width\n\t * @param {number} rect.height\n\t * @return {module:zrender/core/BoundingRect}\n\t */\n\t\n\tBoundingRect.create = function (rect) {\n\t  return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n\t};\n\t\n\tvar _default = BoundingRect;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar LRU = __webpack_require__(20);\n\t\n\tvar globalImageCache = new LRU(50);\n\t/**\n\t * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n\t * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n\t */\n\t\n\tfunction findExistImage(newImageOrSrc) {\n\t  if (typeof newImageOrSrc === 'string') {\n\t    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n\t    return cachedImgObj && cachedImgObj.image;\n\t  } else {\n\t    return newImageOrSrc;\n\t  }\n\t}\n\t/**\n\t * Caution: User should cache loaded images, but not just count on LRU.\n\t * Consider if required images more than LRU size, will dead loop occur?\n\t *\n\t * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n\t * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.\n\t * @param {module:zrender/Element} [hostEl] For calling `dirty`.\n\t * @param {Function} [cb] params: (image, cbPayload)\n\t * @param {Object} [cbPayload] Payload on cb calling.\n\t * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n\t */\n\t\n\t\n\tfunction createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {\n\t  if (!newImageOrSrc) {\n\t    return image;\n\t  } else if (typeof newImageOrSrc === 'string') {\n\t    // Image should not be loaded repeatly.\n\t    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {\n\t      return image;\n\t    } // Only when there is no existent image or existent image src\n\t    // is different, this method is responsible for load.\n\t\n\t\n\t    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n\t    var pendingWrap = {\n\t      hostEl: hostEl,\n\t      cb: cb,\n\t      cbPayload: cbPayload\n\t    };\n\t\n\t    if (cachedImgObj) {\n\t      image = cachedImgObj.image;\n\t      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);\n\t    } else {\n\t      !image && (image = new Image());\n\t      image.onload = imageOnLoad;\n\t      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {\n\t        image: image,\n\t        pending: [pendingWrap]\n\t      });\n\t      image.src = image.__zrImageSrc = newImageOrSrc;\n\t    }\n\t\n\t    return image;\n\t  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas\n\t  else {\n\t      return newImageOrSrc;\n\t    }\n\t}\n\t\n\tfunction imageOnLoad() {\n\t  var cachedImgObj = this.__cachedImgObj;\n\t  this.onload = this.__cachedImgObj = null;\n\t\n\t  for (var i = 0; i < cachedImgObj.pending.length; i++) {\n\t    var pendingWrap = cachedImgObj.pending[i];\n\t    var cb = pendingWrap.cb;\n\t    cb && cb(this, pendingWrap.cbPayload);\n\t    pendingWrap.hostEl.dirty();\n\t  }\n\t\n\t  cachedImgObj.pending.length = 0;\n\t}\n\t\n\tfunction isImageReady(image) {\n\t  return image && image.width && image.height;\n\t}\n\t\n\texports.findExistImage = findExistImage;\n\texports.createOrUpdateImage = createOrUpdateImage;\n\texports.isImageReady = isImageReady;\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports) {\n\n\tfunction buildPath(ctx, shape) {\n\t  var x = shape.x;\n\t  var y = shape.y;\n\t  var width = shape.width;\n\t  var height = shape.height;\n\t  var r = shape.r;\n\t  var r1;\n\t  var r2;\n\t  var r3;\n\t  var r4; // Convert width and height to positive for better borderRadius\n\t\n\t  if (width < 0) {\n\t    x = x + width;\n\t    width = -width;\n\t  }\n\t\n\t  if (height < 0) {\n\t    y = y + height;\n\t    height = -height;\n\t  }\n\t\n\t  if (typeof r === 'number') {\n\t    r1 = r2 = r3 = r4 = r;\n\t  } else if (r instanceof Array) {\n\t    if (r.length === 1) {\n\t      r1 = r2 = r3 = r4 = r[0];\n\t    } else if (r.length === 2) {\n\t      r1 = r3 = r[0];\n\t      r2 = r4 = r[1];\n\t    } else if (r.length === 3) {\n\t      r1 = r[0];\n\t      r2 = r4 = r[1];\n\t      r3 = r[2];\n\t    } else {\n\t      r1 = r[0];\n\t      r2 = r[1];\n\t      r3 = r[2];\n\t      r4 = r[3];\n\t    }\n\t  } else {\n\t    r1 = r2 = r3 = r4 = 0;\n\t  }\n\t\n\t  var total;\n\t\n\t  if (r1 + r2 > width) {\n\t    total = r1 + r2;\n\t    r1 *= width / total;\n\t    r2 *= width / total;\n\t  }\n\t\n\t  if (r3 + r4 > width) {\n\t    total = r3 + r4;\n\t    r3 *= width / total;\n\t    r4 *= width / total;\n\t  }\n\t\n\t  if (r2 + r3 > height) {\n\t    total = r2 + r3;\n\t    r2 *= height / total;\n\t    r3 *= height / total;\n\t  }\n\t\n\t  if (r1 + r4 > height) {\n\t    total = r1 + r4;\n\t    r1 *= height / total;\n\t    r4 *= height / total;\n\t  }\n\t\n\t  ctx.moveTo(x + r1, y);\n\t  ctx.lineTo(x + width - r2, y);\n\t  r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);\n\t  ctx.lineTo(x + width, y + height - r3);\n\t  r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);\n\t  ctx.lineTo(x + r4, y + height);\n\t  r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);\n\t  ctx.lineTo(x, y + r1);\n\t  r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n\t}\n\t\n\texports.buildPath = buildPath;\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar curve = __webpack_require__(30);\n\t\n\tvar vec2 = __webpack_require__(14);\n\t\n\tvar bbox = __webpack_require__(31);\n\t\n\tvar BoundingRect = __webpack_require__(26);\n\t\n\tvar _config = __webpack_require__(22);\n\t\n\tvar dpr = _config.devicePixelRatio;\n\t\n\t/**\n\t * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n\t * 可以用于 isInsidePath 判断以及获取boundingRect\n\t *\n\t * @module zrender/core/PathProxy\n\t * @author Yi Shen (http://www.github.com/pissang)\n\t */\n\t// TODO getTotalLength, getPointAtLength\n\tvar CMD = {\n\t  M: 1,\n\t  L: 2,\n\t  C: 3,\n\t  Q: 4,\n\t  A: 5,\n\t  Z: 6,\n\t  // Rect\n\t  R: 7\n\t}; // var CMD_MEM_SIZE = {\n\t//     M: 3,\n\t//     L: 3,\n\t//     C: 7,\n\t//     Q: 5,\n\t//     A: 9,\n\t//     R: 5,\n\t//     Z: 1\n\t// };\n\t\n\tvar min = [];\n\tvar max = [];\n\tvar min2 = [];\n\tvar max2 = [];\n\tvar mathMin = Math.min;\n\tvar mathMax = Math.max;\n\tvar mathCos = Math.cos;\n\tvar mathSin = Math.sin;\n\tvar mathSqrt = Math.sqrt;\n\tvar mathAbs = Math.abs;\n\tvar hasTypedArray = typeof Float32Array != 'undefined';\n\t/**\n\t * @alias module:zrender/core/PathProxy\n\t * @constructor\n\t */\n\t\n\tvar PathProxy = function (notSaveData) {\n\t  this._saveData = !(notSaveData || false);\n\t\n\t  if (this._saveData) {\n\t    /**\n\t     * Path data. Stored as flat array\n\t     * @type {Array.<Object>}\n\t     */\n\t    this.data = [];\n\t  }\n\t\n\t  this._ctx = null;\n\t};\n\t/**\n\t * 快速计算Path包围盒（并不是最小包围盒）\n\t * @return {Object}\n\t */\n\t\n\t\n\tPathProxy.prototype = {\n\t  constructor: PathProxy,\n\t  _xi: 0,\n\t  _yi: 0,\n\t  _x0: 0,\n\t  _y0: 0,\n\t  // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n\t  _ux: 0,\n\t  _uy: 0,\n\t  _len: 0,\n\t  _lineDash: null,\n\t  _dashOffset: 0,\n\t  _dashIdx: 0,\n\t  _dashSum: 0,\n\t\n\t  /**\n\t   * @readOnly\n\t   */\n\t  setScale: function (sx, sy) {\n\t    this._ux = mathAbs(1 / dpr / sx) || 0;\n\t    this._uy = mathAbs(1 / dpr / sy) || 0;\n\t  },\n\t  getContext: function () {\n\t    return this._ctx;\n\t  },\n\t\n\t  /**\n\t   * @param  {CanvasRenderingContext2D} ctx\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  beginPath: function (ctx) {\n\t    this._ctx = ctx;\n\t    ctx && ctx.beginPath();\n\t    ctx && (this.dpr = ctx.dpr); // Reset\n\t\n\t    if (this._saveData) {\n\t      this._len = 0;\n\t    }\n\t\n\t    if (this._lineDash) {\n\t      this._lineDash = null;\n\t      this._dashOffset = 0;\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param  {number} x\n\t   * @param  {number} y\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  moveTo: function (x, y) {\n\t    this.addData(CMD.M, x, y);\n\t    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n\t    // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n\t    // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n\t    // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n\t\n\t    this._x0 = x;\n\t    this._y0 = y;\n\t    this._xi = x;\n\t    this._yi = y;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param  {number} x\n\t   * @param  {number} y\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  lineTo: function (x, y) {\n\t    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment\n\t    || this._len < 5;\n\t    this.addData(CMD.L, x, y);\n\t\n\t    if (this._ctx && exceedUnit) {\n\t      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n\t    }\n\t\n\t    if (exceedUnit) {\n\t      this._xi = x;\n\t      this._yi = y;\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param  {number} x1\n\t   * @param  {number} y1\n\t   * @param  {number} x2\n\t   * @param  {number} y2\n\t   * @param  {number} x3\n\t   * @param  {number} y3\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n\t    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\t\n\t    if (this._ctx) {\n\t      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n\t    }\n\t\n\t    this._xi = x3;\n\t    this._yi = y3;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param  {number} x1\n\t   * @param  {number} y1\n\t   * @param  {number} x2\n\t   * @param  {number} y2\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  quadraticCurveTo: function (x1, y1, x2, y2) {\n\t    this.addData(CMD.Q, x1, y1, x2, y2);\n\t\n\t    if (this._ctx) {\n\t      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n\t    }\n\t\n\t    this._xi = x2;\n\t    this._yi = y2;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @param  {number} cx\n\t   * @param  {number} cy\n\t   * @param  {number} r\n\t   * @param  {number} startAngle\n\t   * @param  {number} endAngle\n\t   * @param  {boolean} anticlockwise\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n\t    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);\n\t    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\t    this._xi = mathCos(endAngle) * r + cx;\n\t    this._yi = mathSin(endAngle) * r + cx;\n\t    return this;\n\t  },\n\t  // TODO\n\t  arcTo: function (x1, y1, x2, y2, radius) {\n\t    if (this._ctx) {\n\t      this._ctx.arcTo(x1, y1, x2, y2, radius);\n\t    }\n\t\n\t    return this;\n\t  },\n\t  // TODO\n\t  rect: function (x, y, w, h) {\n\t    this._ctx && this._ctx.rect(x, y, w, h);\n\t    this.addData(CMD.R, x, y, w, h);\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  closePath: function () {\n\t    this.addData(CMD.Z);\n\t    var ctx = this._ctx;\n\t    var x0 = this._x0;\n\t    var y0 = this._y0;\n\t\n\t    if (ctx) {\n\t      this._needsDash() && this._dashedLineTo(x0, y0);\n\t      ctx.closePath();\n\t    }\n\t\n\t    this._xi = x0;\n\t    this._yi = y0;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n\t   * stroke 同样\n\t   * @param {CanvasRenderingContext2D} ctx\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  fill: function (ctx) {\n\t    ctx && ctx.fill();\n\t    this.toStatic();\n\t  },\n\t\n\t  /**\n\t   * @param {CanvasRenderingContext2D} ctx\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  stroke: function (ctx) {\n\t    ctx && ctx.stroke();\n\t    this.toStatic();\n\t  },\n\t\n\t  /**\n\t   * 必须在其它绘制命令前调用\n\t   * Must be invoked before all other path drawing methods\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  setLineDash: function (lineDash) {\n\t    if (lineDash instanceof Array) {\n\t      this._lineDash = lineDash;\n\t      this._dashIdx = 0;\n\t      var lineDashSum = 0;\n\t\n\t      for (var i = 0; i < lineDash.length; i++) {\n\t        lineDashSum += lineDash[i];\n\t      }\n\t\n\t      this._dashSum = lineDashSum;\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 必须在其它绘制命令前调用\n\t   * Must be invoked before all other path drawing methods\n\t   * @return {module:zrender/core/PathProxy}\n\t   */\n\t  setLineDashOffset: function (offset) {\n\t    this._dashOffset = offset;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   *\n\t   * @return {boolean}\n\t   */\n\t  len: function () {\n\t    return this._len;\n\t  },\n\t\n\t  /**\n\t   * 直接设置 Path 数据\n\t   */\n\t  setData: function (data) {\n\t    var len = data.length;\n\t\n\t    if (!(this.data && this.data.length == len) && hasTypedArray) {\n\t      this.data = new Float32Array(len);\n\t    }\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      this.data[i] = data[i];\n\t    }\n\t\n\t    this._len = len;\n\t  },\n\t\n\t  /**\n\t   * 添加子路径\n\t   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n\t   */\n\t  appendPath: function (path) {\n\t    if (!(path instanceof Array)) {\n\t      path = [path];\n\t    }\n\t\n\t    var len = path.length;\n\t    var appendSize = 0;\n\t    var offset = this._len;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      appendSize += path[i].len();\n\t    }\n\t\n\t    if (hasTypedArray && this.data instanceof Float32Array) {\n\t      this.data = new Float32Array(offset + appendSize);\n\t    }\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      var appendPathData = path[i].data;\n\t\n\t      for (var k = 0; k < appendPathData.length; k++) {\n\t        this.data[offset++] = appendPathData[k];\n\t      }\n\t    }\n\t\n\t    this._len = offset;\n\t  },\n\t\n\t  /**\n\t   * 填充 Path 数据。\n\t   * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n\t   */\n\t  addData: function (cmd) {\n\t    if (!this._saveData) {\n\t      return;\n\t    }\n\t\n\t    var data = this.data;\n\t\n\t    if (this._len + arguments.length > data.length) {\n\t      // 因为之前的数组已经转换成静态的 Float32Array\n\t      // 所以不够用时需要扩展一个新的动态数组\n\t      this._expandData();\n\t\n\t      data = this.data;\n\t    }\n\t\n\t    for (var i = 0; i < arguments.length; i++) {\n\t      data[this._len++] = arguments[i];\n\t    }\n\t\n\t    this._prevCmd = cmd;\n\t  },\n\t  _expandData: function () {\n\t    // Only if data is Float32Array\n\t    if (!(this.data instanceof Array)) {\n\t      var newData = [];\n\t\n\t      for (var i = 0; i < this._len; i++) {\n\t        newData[i] = this.data[i];\n\t      }\n\t\n\t      this.data = newData;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * If needs js implemented dashed line\n\t   * @return {boolean}\n\t   * @private\n\t   */\n\t  _needsDash: function () {\n\t    return this._lineDash;\n\t  },\n\t  _dashedLineTo: function (x1, y1) {\n\t    var dashSum = this._dashSum;\n\t    var offset = this._dashOffset;\n\t    var lineDash = this._lineDash;\n\t    var ctx = this._ctx;\n\t    var x0 = this._xi;\n\t    var y0 = this._yi;\n\t    var dx = x1 - x0;\n\t    var dy = y1 - y0;\n\t    var dist = mathSqrt(dx * dx + dy * dy);\n\t    var x = x0;\n\t    var y = y0;\n\t    var dash;\n\t    var nDash = lineDash.length;\n\t    var idx;\n\t    dx /= dist;\n\t    dy /= dist;\n\t\n\t    if (offset < 0) {\n\t      // Convert to positive offset\n\t      offset = dashSum + offset;\n\t    }\n\t\n\t    offset %= dashSum;\n\t    x -= offset * dx;\n\t    y -= offset * dy;\n\t\n\t    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n\t      idx = this._dashIdx;\n\t      dash = lineDash[idx];\n\t      x += dx * dash;\n\t      y += dy * dash;\n\t      this._dashIdx = (idx + 1) % nDash; // Skip positive offset\n\t\n\t      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n\t        continue;\n\t      }\n\t\n\t      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n\t    } // Offset for next lineTo\n\t\n\t\n\t    dx = x - x1;\n\t    dy = y - y1;\n\t    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t  },\n\t  // Not accurate dashed line to\n\t  _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n\t    var dashSum = this._dashSum;\n\t    var offset = this._dashOffset;\n\t    var lineDash = this._lineDash;\n\t    var ctx = this._ctx;\n\t    var x0 = this._xi;\n\t    var y0 = this._yi;\n\t    var t;\n\t    var dx;\n\t    var dy;\n\t    var cubicAt = curve.cubicAt;\n\t    var bezierLen = 0;\n\t    var idx = this._dashIdx;\n\t    var nDash = lineDash.length;\n\t    var x;\n\t    var y;\n\t    var tmpLen = 0;\n\t\n\t    if (offset < 0) {\n\t      // Convert to positive offset\n\t      offset = dashSum + offset;\n\t    }\n\t\n\t    offset %= dashSum; // Bezier approx length\n\t\n\t    for (t = 0; t < 1; t += 0.1) {\n\t      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);\n\t      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);\n\t      bezierLen += mathSqrt(dx * dx + dy * dy);\n\t    } // Find idx after add offset\n\t\n\t\n\t    for (; idx < nDash; idx++) {\n\t      tmpLen += lineDash[idx];\n\t\n\t      if (tmpLen > offset) {\n\t        break;\n\t      }\n\t    }\n\t\n\t    t = (tmpLen - offset) / bezierLen;\n\t\n\t    while (t <= 1) {\n\t      x = cubicAt(x0, x1, x2, x3, t);\n\t      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier\n\t      // Bad result if dash is long\n\t\n\t      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n\t      t += lineDash[idx] / bezierLen;\n\t      idx = (idx + 1) % nDash;\n\t    } // Finish the last segment and calculate the new offset\n\t\n\t\n\t    idx % 2 !== 0 && ctx.lineTo(x3, y3);\n\t    dx = x3 - x;\n\t    dy = y3 - y;\n\t    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t  },\n\t  _dashedQuadraticTo: function (x1, y1, x2, y2) {\n\t    // Convert quadratic to cubic using degree elevation\n\t    var x3 = x2;\n\t    var y3 = y2;\n\t    x2 = (x2 + 2 * x1) / 3;\n\t    y2 = (y2 + 2 * y1) / 3;\n\t    x1 = (this._xi + 2 * x1) / 3;\n\t    y1 = (this._yi + 2 * y1) / 3;\n\t\n\t    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n\t  },\n\t\n\t  /**\n\t   * 转成静态的 Float32Array 减少堆内存占用\n\t   * Convert dynamic array to static Float32Array\n\t   */\n\t  toStatic: function () {\n\t    var data = this.data;\n\t\n\t    if (data instanceof Array) {\n\t      data.length = this._len;\n\t\n\t      if (hasTypedArray) {\n\t        this.data = new Float32Array(data);\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @return {module:zrender/core/BoundingRect}\n\t   */\n\t  getBoundingRect: function () {\n\t    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n\t    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\t    var data = this.data;\n\t    var xi = 0;\n\t    var yi = 0;\n\t    var x0 = 0;\n\t    var y0 = 0;\n\t\n\t    for (var i = 0; i < data.length;) {\n\t      var cmd = data[i++];\n\t\n\t      if (i == 1) {\n\t        // 如果第一个命令是 L, C, Q\n\t        // 则 previous point 同绘制命令的第一个 point\n\t        //\n\t        // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t        xi = data[i];\n\t        yi = data[i + 1];\n\t        x0 = xi;\n\t        y0 = yi;\n\t      }\n\t\n\t      switch (cmd) {\n\t        case CMD.M:\n\t          // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n\t          // 在 closePath 的时候使用\n\t          x0 = data[i++];\n\t          y0 = data[i++];\n\t          xi = x0;\n\t          yi = y0;\n\t          min2[0] = x0;\n\t          min2[1] = y0;\n\t          max2[0] = x0;\n\t          max2[1] = y0;\n\t          break;\n\t\n\t        case CMD.L:\n\t          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n\t          xi = data[i++];\n\t          yi = data[i++];\n\t          break;\n\t\n\t        case CMD.C:\n\t          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n\t          xi = data[i++];\n\t          yi = data[i++];\n\t          break;\n\t\n\t        case CMD.Q:\n\t          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n\t          xi = data[i++];\n\t          yi = data[i++];\n\t          break;\n\t\n\t        case CMD.A:\n\t          // TODO Arc 判断的开销比较大\n\t          var cx = data[i++];\n\t          var cy = data[i++];\n\t          var rx = data[i++];\n\t          var ry = data[i++];\n\t          var startAngle = data[i++];\n\t          var endAngle = data[i++] + startAngle; // TODO Arc 旋转\n\t\n\t          var psi = data[i++];\n\t          var anticlockwise = 1 - data[i++];\n\t\n\t          if (i == 1) {\n\t            // 直接使用 arc 命令\n\t            // 第一个命令起点还未定义\n\t            x0 = mathCos(startAngle) * rx + cx;\n\t            y0 = mathSin(startAngle) * ry + cy;\n\t          }\n\t\n\t          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n\t          xi = mathCos(endAngle) * rx + cx;\n\t          yi = mathSin(endAngle) * ry + cy;\n\t          break;\n\t\n\t        case CMD.R:\n\t          x0 = xi = data[i++];\n\t          y0 = yi = data[i++];\n\t          var width = data[i++];\n\t          var height = data[i++]; // Use fromLine\n\t\n\t          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n\t          break;\n\t\n\t        case CMD.Z:\n\t          xi = x0;\n\t          yi = y0;\n\t          break;\n\t      } // Union\n\t\n\t\n\t      vec2.min(min, min, min2);\n\t      vec2.max(max, max, max2);\n\t    } // No data\n\t\n\t\n\t    if (i === 0) {\n\t      min[0] = min[1] = max[0] = max[1] = 0;\n\t    }\n\t\n\t    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t  },\n\t\n\t  /**\n\t   * Rebuild path from current data\n\t   * Rebuild path will not consider javascript implemented line dash.\n\t   * @param {CanvasRenderingContext2D} ctx\n\t   */\n\t  rebuildPath: function (ctx) {\n\t    var d = this.data;\n\t    var x0, y0;\n\t    var xi, yi;\n\t    var x, y;\n\t    var ux = this._ux;\n\t    var uy = this._uy;\n\t    var len = this._len;\n\t\n\t    for (var i = 0; i < len;) {\n\t      var cmd = d[i++];\n\t\n\t      if (i == 1) {\n\t        // 如果第一个命令是 L, C, Q\n\t        // 则 previous point 同绘制命令的第一个 point\n\t        //\n\t        // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t        xi = d[i];\n\t        yi = d[i + 1];\n\t        x0 = xi;\n\t        y0 = yi;\n\t      }\n\t\n\t      switch (cmd) {\n\t        case CMD.M:\n\t          x0 = xi = d[i++];\n\t          y0 = yi = d[i++];\n\t          ctx.moveTo(xi, yi);\n\t          break;\n\t\n\t        case CMD.L:\n\t          x = d[i++];\n\t          y = d[i++]; // Not draw too small seg between\n\t\n\t          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n\t            ctx.lineTo(x, y);\n\t            xi = x;\n\t            yi = y;\n\t          }\n\t\n\t          break;\n\t\n\t        case CMD.C:\n\t          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);\n\t          xi = d[i - 2];\n\t          yi = d[i - 1];\n\t          break;\n\t\n\t        case CMD.Q:\n\t          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n\t          xi = d[i - 2];\n\t          yi = d[i - 1];\n\t          break;\n\t\n\t        case CMD.A:\n\t          var cx = d[i++];\n\t          var cy = d[i++];\n\t          var rx = d[i++];\n\t          var ry = d[i++];\n\t          var theta = d[i++];\n\t          var dTheta = d[i++];\n\t          var psi = d[i++];\n\t          var fs = d[i++];\n\t          var r = rx > ry ? rx : ry;\n\t          var scaleX = rx > ry ? 1 : rx / ry;\n\t          var scaleY = rx > ry ? ry / rx : 1;\n\t          var isEllipse = Math.abs(rx - ry) > 1e-3;\n\t          var endAngle = theta + dTheta;\n\t\n\t          if (isEllipse) {\n\t            ctx.translate(cx, cy);\n\t            ctx.rotate(psi);\n\t            ctx.scale(scaleX, scaleY);\n\t            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n\t            ctx.scale(1 / scaleX, 1 / scaleY);\n\t            ctx.rotate(-psi);\n\t            ctx.translate(-cx, -cy);\n\t          } else {\n\t            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n\t          }\n\t\n\t          if (i == 1) {\n\t            // 直接使用 arc 命令\n\t            // 第一个命令起点还未定义\n\t            x0 = mathCos(theta) * rx + cx;\n\t            y0 = mathSin(theta) * ry + cy;\n\t          }\n\t\n\t          xi = mathCos(endAngle) * rx + cx;\n\t          yi = mathSin(endAngle) * ry + cy;\n\t          break;\n\t\n\t        case CMD.R:\n\t          x0 = xi = d[i];\n\t          y0 = yi = d[i + 1];\n\t          ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n\t          break;\n\t\n\t        case CMD.Z:\n\t          ctx.closePath();\n\t          xi = x0;\n\t          yi = y0;\n\t      }\n\t    }\n\t  }\n\t};\n\tPathProxy.CMD = CMD;\n\tvar _default = PathProxy;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _vector = __webpack_require__(14);\n\t\n\tvar v2Create = _vector.create;\n\tvar v2DistSquare = _vector.distSquare;\n\t\n\t/**\n\t * 曲线辅助模块\n\t * @module zrender/core/curve\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\tvar mathPow = Math.pow;\n\tvar mathSqrt = Math.sqrt;\n\tvar EPSILON = 1e-8;\n\tvar EPSILON_NUMERIC = 1e-4;\n\tvar THREE_SQRT = mathSqrt(3);\n\tvar ONE_THIRD = 1 / 3; // 临时变量\n\t\n\tvar _v0 = v2Create();\n\t\n\tvar _v1 = v2Create();\n\t\n\tvar _v2 = v2Create();\n\t\n\tfunction isAroundZero(val) {\n\t  return val > -EPSILON && val < EPSILON;\n\t}\n\t\n\tfunction isNotAroundZero(val) {\n\t  return val > EPSILON || val < -EPSILON;\n\t}\n\t/**\n\t * 计算三次贝塞尔值\n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {number} t\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction cubicAt(p0, p1, p2, p3, t) {\n\t  var onet = 1 - t;\n\t  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);\n\t}\n\t/**\n\t * 计算三次贝塞尔导数值\n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {number} t\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction cubicDerivativeAt(p0, p1, p2, p3, t) {\n\t  var onet = 1 - t;\n\t  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);\n\t}\n\t/**\n\t * 计算三次贝塞尔方程根，使用盛金公式\n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {number} val\n\t * @param  {Array.<number>} roots\n\t * @return {number} 有效根数目\n\t */\n\t\n\t\n\tfunction cubicRootAt(p0, p1, p2, p3, val, roots) {\n\t  // Evaluate roots of cubic functions\n\t  var a = p3 + 3 * (p1 - p2) - p0;\n\t  var b = 3 * (p2 - p1 * 2 + p0);\n\t  var c = 3 * (p1 - p0);\n\t  var d = p0 - val;\n\t  var A = b * b - 3 * a * c;\n\t  var B = b * c - 9 * a * d;\n\t  var C = c * c - 3 * b * d;\n\t  var n = 0;\n\t\n\t  if (isAroundZero(A) && isAroundZero(B)) {\n\t    if (isAroundZero(b)) {\n\t      roots[0] = 0;\n\t    } else {\n\t      var t1 = -c / b; //t1, t2, t3, b is not zero\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t    }\n\t  } else {\n\t    var disc = B * B - 4 * A * C;\n\t\n\t    if (isAroundZero(disc)) {\n\t      var K = B / A;\n\t      var t1 = -b / a + K; // t1, a is not zero\n\t\n\t      var t2 = -K / 2; // t2, t3\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t\n\t      if (t2 >= 0 && t2 <= 1) {\n\t        roots[n++] = t2;\n\t      }\n\t    } else if (disc > 0) {\n\t      var discSqrt = mathSqrt(disc);\n\t      var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n\t      var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\t\n\t      if (Y1 < 0) {\n\t        Y1 = -mathPow(-Y1, ONE_THIRD);\n\t      } else {\n\t        Y1 = mathPow(Y1, ONE_THIRD);\n\t      }\n\t\n\t      if (Y2 < 0) {\n\t        Y2 = -mathPow(-Y2, ONE_THIRD);\n\t      } else {\n\t        Y2 = mathPow(Y2, ONE_THIRD);\n\t      }\n\t\n\t      var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t    } else {\n\t      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n\t      var theta = Math.acos(T) / 3;\n\t      var ASqrt = mathSqrt(A);\n\t      var tmp = Math.cos(theta);\n\t      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n\t      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t\n\t      if (t2 >= 0 && t2 <= 1) {\n\t        roots[n++] = t2;\n\t      }\n\t\n\t      if (t3 >= 0 && t3 <= 1) {\n\t        roots[n++] = t3;\n\t      }\n\t    }\n\t  }\n\t\n\t  return n;\n\t}\n\t/**\n\t * 计算三次贝塞尔方程极限值的位置\n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {Array.<number>} extrema\n\t * @return {number} 有效数目\n\t */\n\t\n\t\n\tfunction cubicExtrema(p0, p1, p2, p3, extrema) {\n\t  var b = 6 * p2 - 12 * p1 + 6 * p0;\n\t  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n\t  var c = 3 * p1 - 3 * p0;\n\t  var n = 0;\n\t\n\t  if (isAroundZero(a)) {\n\t    if (isNotAroundZero(b)) {\n\t      var t1 = -c / b;\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        extrema[n++] = t1;\n\t      }\n\t    }\n\t  } else {\n\t    var disc = b * b - 4 * a * c;\n\t\n\t    if (isAroundZero(disc)) {\n\t      extrema[0] = -b / (2 * a);\n\t    } else if (disc > 0) {\n\t      var discSqrt = mathSqrt(disc);\n\t      var t1 = (-b + discSqrt) / (2 * a);\n\t      var t2 = (-b - discSqrt) / (2 * a);\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        extrema[n++] = t1;\n\t      }\n\t\n\t      if (t2 >= 0 && t2 <= 1) {\n\t        extrema[n++] = t2;\n\t      }\n\t    }\n\t  }\n\t\n\t  return n;\n\t}\n\t/**\n\t * 细分三次贝塞尔曲线\n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {number} t\n\t * @param  {Array.<number>} out\n\t */\n\t\n\t\n\tfunction cubicSubdivide(p0, p1, p2, p3, t, out) {\n\t  var p01 = (p1 - p0) * t + p0;\n\t  var p12 = (p2 - p1) * t + p1;\n\t  var p23 = (p3 - p2) * t + p2;\n\t  var p012 = (p12 - p01) * t + p01;\n\t  var p123 = (p23 - p12) * t + p12;\n\t  var p0123 = (p123 - p012) * t + p012; // Seg0\n\t\n\t  out[0] = p0;\n\t  out[1] = p01;\n\t  out[2] = p012;\n\t  out[3] = p0123; // Seg1\n\t\n\t  out[4] = p0123;\n\t  out[5] = p123;\n\t  out[6] = p23;\n\t  out[7] = p3;\n\t}\n\t/**\n\t * 投射点到三次贝塞尔曲线上，返回投射距离。\n\t * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n\t * @param {number} x0\n\t * @param {number} y0\n\t * @param {number} x1\n\t * @param {number} y1\n\t * @param {number} x2\n\t * @param {number} y2\n\t * @param {number} x3\n\t * @param {number} y3\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {Array.<number>} [out] 投射点\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {\n\t  // http://pomax.github.io/bezierinfo/#projections\n\t  var t;\n\t  var interval = 0.005;\n\t  var d = Infinity;\n\t  var prev;\n\t  var next;\n\t  var d1;\n\t  var d2;\n\t  _v0[0] = x;\n\t  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值\n\t  // PENDING\n\t\n\t  for (var _t = 0; _t < 1; _t += 0.05) {\n\t    _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n\t    _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n\t    d1 = v2DistSquare(_v0, _v1);\n\t\n\t    if (d1 < d) {\n\t      t = _t;\n\t      d = d1;\n\t    }\n\t  }\n\t\n\t  d = Infinity; // At most 32 iteration\n\t\n\t  for (var i = 0; i < 32; i++) {\n\t    if (interval < EPSILON_NUMERIC) {\n\t      break;\n\t    }\n\t\n\t    prev = t - interval;\n\t    next = t + interval; // t - interval\n\t\n\t    _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n\t    _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\t    d1 = v2DistSquare(_v1, _v0);\n\t\n\t    if (prev >= 0 && d1 < d) {\n\t      t = prev;\n\t      d = d1;\n\t    } else {\n\t      // t + interval\n\t      _v2[0] = cubicAt(x0, x1, x2, x3, next);\n\t      _v2[1] = cubicAt(y0, y1, y2, y3, next);\n\t      d2 = v2DistSquare(_v2, _v0);\n\t\n\t      if (next <= 1 && d2 < d) {\n\t        t = next;\n\t        d = d2;\n\t      } else {\n\t        interval *= 0.5;\n\t      }\n\t    }\n\t  } // t\n\t\n\t\n\t  if (out) {\n\t    out[0] = cubicAt(x0, x1, x2, x3, t);\n\t    out[1] = cubicAt(y0, y1, y2, y3, t);\n\t  } // console.log(interval, i);\n\t\n\t\n\t  return mathSqrt(d);\n\t}\n\t/**\n\t * 计算二次方贝塞尔值\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} t\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction quadraticAt(p0, p1, p2, t) {\n\t  var onet = 1 - t;\n\t  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n\t}\n\t/**\n\t * 计算二次方贝塞尔导数值\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} t\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction quadraticDerivativeAt(p0, p1, p2, t) {\n\t  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n\t}\n\t/**\n\t * 计算二次方贝塞尔方程根\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} t\n\t * @param  {Array.<number>} roots\n\t * @return {number} 有效根数目\n\t */\n\t\n\t\n\tfunction quadraticRootAt(p0, p1, p2, val, roots) {\n\t  var a = p0 - 2 * p1 + p2;\n\t  var b = 2 * (p1 - p0);\n\t  var c = p0 - val;\n\t  var n = 0;\n\t\n\t  if (isAroundZero(a)) {\n\t    if (isNotAroundZero(b)) {\n\t      var t1 = -c / b;\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t    }\n\t  } else {\n\t    var disc = b * b - 4 * a * c;\n\t\n\t    if (isAroundZero(disc)) {\n\t      var t1 = -b / (2 * a);\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t    } else if (disc > 0) {\n\t      var discSqrt = mathSqrt(disc);\n\t      var t1 = (-b + discSqrt) / (2 * a);\n\t      var t2 = (-b - discSqrt) / (2 * a);\n\t\n\t      if (t1 >= 0 && t1 <= 1) {\n\t        roots[n++] = t1;\n\t      }\n\t\n\t      if (t2 >= 0 && t2 <= 1) {\n\t        roots[n++] = t2;\n\t      }\n\t    }\n\t  }\n\t\n\t  return n;\n\t}\n\t/**\n\t * 计算二次贝塞尔方程极限值\n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction quadraticExtremum(p0, p1, p2) {\n\t  var divider = p0 + p2 - 2 * p1;\n\t\n\t  if (divider === 0) {\n\t    // p1 is center of p0 and p2\n\t    return 0.5;\n\t  } else {\n\t    return (p0 - p1) / divider;\n\t  }\n\t}\n\t/**\n\t * 细分二次贝塞尔曲线\n\t * @memberOf module:zrender/core/curve\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} t\n\t * @param  {Array.<number>} out\n\t */\n\t\n\t\n\tfunction quadraticSubdivide(p0, p1, p2, t, out) {\n\t  var p01 = (p1 - p0) * t + p0;\n\t  var p12 = (p2 - p1) * t + p1;\n\t  var p012 = (p12 - p01) * t + p01; // Seg0\n\t\n\t  out[0] = p0;\n\t  out[1] = p01;\n\t  out[2] = p012; // Seg1\n\t\n\t  out[3] = p012;\n\t  out[4] = p12;\n\t  out[5] = p2;\n\t}\n\t/**\n\t * 投射点到二次贝塞尔曲线上，返回投射距离。\n\t * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n\t * @param {number} x0\n\t * @param {number} y0\n\t * @param {number} x1\n\t * @param {number} y1\n\t * @param {number} x2\n\t * @param {number} y2\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {Array.<number>} out 投射点\n\t * @return {number}\n\t */\n\t\n\t\n\tfunction quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {\n\t  // http://pomax.github.io/bezierinfo/#projections\n\t  var t;\n\t  var interval = 0.005;\n\t  var d = Infinity;\n\t  _v0[0] = x;\n\t  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值\n\t  // PENDING\n\t\n\t  for (var _t = 0; _t < 1; _t += 0.05) {\n\t    _v1[0] = quadraticAt(x0, x1, x2, _t);\n\t    _v1[1] = quadraticAt(y0, y1, y2, _t);\n\t    var d1 = v2DistSquare(_v0, _v1);\n\t\n\t    if (d1 < d) {\n\t      t = _t;\n\t      d = d1;\n\t    }\n\t  }\n\t\n\t  d = Infinity; // At most 32 iteration\n\t\n\t  for (var i = 0; i < 32; i++) {\n\t    if (interval < EPSILON_NUMERIC) {\n\t      break;\n\t    }\n\t\n\t    var prev = t - interval;\n\t    var next = t + interval; // t - interval\n\t\n\t    _v1[0] = quadraticAt(x0, x1, x2, prev);\n\t    _v1[1] = quadraticAt(y0, y1, y2, prev);\n\t    var d1 = v2DistSquare(_v1, _v0);\n\t\n\t    if (prev >= 0 && d1 < d) {\n\t      t = prev;\n\t      d = d1;\n\t    } else {\n\t      // t + interval\n\t      _v2[0] = quadraticAt(x0, x1, x2, next);\n\t      _v2[1] = quadraticAt(y0, y1, y2, next);\n\t      var d2 = v2DistSquare(_v2, _v0);\n\t\n\t      if (next <= 1 && d2 < d) {\n\t        t = next;\n\t        d = d2;\n\t      } else {\n\t        interval *= 0.5;\n\t      }\n\t    }\n\t  } // t\n\t\n\t\n\t  if (out) {\n\t    out[0] = quadraticAt(x0, x1, x2, t);\n\t    out[1] = quadraticAt(y0, y1, y2, t);\n\t  } // console.log(interval, i);\n\t\n\t\n\t  return mathSqrt(d);\n\t}\n\t\n\texports.cubicAt = cubicAt;\n\texports.cubicDerivativeAt = cubicDerivativeAt;\n\texports.cubicRootAt = cubicRootAt;\n\texports.cubicExtrema = cubicExtrema;\n\texports.cubicSubdivide = cubicSubdivide;\n\texports.cubicProjectPoint = cubicProjectPoint;\n\texports.quadraticAt = quadraticAt;\n\texports.quadraticDerivativeAt = quadraticDerivativeAt;\n\texports.quadraticRootAt = quadraticRootAt;\n\texports.quadraticExtremum = quadraticExtremum;\n\texports.quadraticSubdivide = quadraticSubdivide;\n\texports.quadraticProjectPoint = quadraticProjectPoint;\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar vec2 = __webpack_require__(14);\n\t\n\tvar curve = __webpack_require__(30);\n\t\n\t/**\n\t * @author Yi Shen(https://github.com/pissang)\n\t */\n\tvar mathMin = Math.min;\n\tvar mathMax = Math.max;\n\tvar mathSin = Math.sin;\n\tvar mathCos = Math.cos;\n\tvar PI2 = Math.PI * 2;\n\tvar start = vec2.create();\n\tvar end = vec2.create();\n\tvar extremity = vec2.create();\n\t/**\n\t * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n\t * @module zrender/core/bbox\n\t * @param {Array<Object>} points 顶点数组\n\t * @param {number} min\n\t * @param {number} max\n\t */\n\t\n\tfunction fromPoints(points, min, max) {\n\t  if (points.length === 0) {\n\t    return;\n\t  }\n\t\n\t  var p = points[0];\n\t  var left = p[0];\n\t  var right = p[0];\n\t  var top = p[1];\n\t  var bottom = p[1];\n\t  var i;\n\t\n\t  for (i = 1; i < points.length; i++) {\n\t    p = points[i];\n\t    left = mathMin(left, p[0]);\n\t    right = mathMax(right, p[0]);\n\t    top = mathMin(top, p[1]);\n\t    bottom = mathMax(bottom, p[1]);\n\t  }\n\t\n\t  min[0] = left;\n\t  min[1] = top;\n\t  max[0] = right;\n\t  max[1] = bottom;\n\t}\n\t/**\n\t * @memberOf module:zrender/core/bbox\n\t * @param {number} x0\n\t * @param {number} y0\n\t * @param {number} x1\n\t * @param {number} y1\n\t * @param {Array.<number>} min\n\t * @param {Array.<number>} max\n\t */\n\t\n\t\n\tfunction fromLine(x0, y0, x1, y1, min, max) {\n\t  min[0] = mathMin(x0, x1);\n\t  min[1] = mathMin(y0, y1);\n\t  max[0] = mathMax(x0, x1);\n\t  max[1] = mathMax(y0, y1);\n\t}\n\t\n\tvar xDim = [];\n\tvar yDim = [];\n\t/**\n\t * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n\t * @memberOf module:zrender/core/bbox\n\t * @param {number} x0\n\t * @param {number} y0\n\t * @param {number} x1\n\t * @param {number} y1\n\t * @param {number} x2\n\t * @param {number} y2\n\t * @param {number} x3\n\t * @param {number} y3\n\t * @param {Array.<number>} min\n\t * @param {Array.<number>} max\n\t */\n\t\n\tfunction fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {\n\t  var cubicExtrema = curve.cubicExtrema;\n\t  var cubicAt = curve.cubicAt;\n\t  var i;\n\t  var n = cubicExtrema(x0, x1, x2, x3, xDim);\n\t  min[0] = Infinity;\n\t  min[1] = Infinity;\n\t  max[0] = -Infinity;\n\t  max[1] = -Infinity;\n\t\n\t  for (i = 0; i < n; i++) {\n\t    var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n\t    min[0] = mathMin(x, min[0]);\n\t    max[0] = mathMax(x, max[0]);\n\t  }\n\t\n\t  n = cubicExtrema(y0, y1, y2, y3, yDim);\n\t\n\t  for (i = 0; i < n; i++) {\n\t    var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n\t    min[1] = mathMin(y, min[1]);\n\t    max[1] = mathMax(y, max[1]);\n\t  }\n\t\n\t  min[0] = mathMin(x0, min[0]);\n\t  max[0] = mathMax(x0, max[0]);\n\t  min[0] = mathMin(x3, min[0]);\n\t  max[0] = mathMax(x3, max[0]);\n\t  min[1] = mathMin(y0, min[1]);\n\t  max[1] = mathMax(y0, max[1]);\n\t  min[1] = mathMin(y3, min[1]);\n\t  max[1] = mathMax(y3, max[1]);\n\t}\n\t/**\n\t * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n\t * @memberOf module:zrender/core/bbox\n\t * @param {number} x0\n\t * @param {number} y0\n\t * @param {number} x1\n\t * @param {number} y1\n\t * @param {number} x2\n\t * @param {number} y2\n\t * @param {Array.<number>} min\n\t * @param {Array.<number>} max\n\t */\n\t\n\t\n\tfunction fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {\n\t  var quadraticExtremum = curve.quadraticExtremum;\n\t  var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero\n\t\n\t  var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);\n\t  var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);\n\t  var x = quadraticAt(x0, x1, x2, tx);\n\t  var y = quadraticAt(y0, y1, y2, ty);\n\t  min[0] = mathMin(x0, x2, x);\n\t  min[1] = mathMin(y0, y2, y);\n\t  max[0] = mathMax(x0, x2, x);\n\t  max[1] = mathMax(y0, y2, y);\n\t}\n\t/**\n\t * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n\t * @method\n\t * @memberOf module:zrender/core/bbox\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {number} rx\n\t * @param {number} ry\n\t * @param {number} startAngle\n\t * @param {number} endAngle\n\t * @param {number} anticlockwise\n\t * @param {Array.<number>} min\n\t * @param {Array.<number>} max\n\t */\n\t\n\t\n\tfunction fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {\n\t  var vec2Min = vec2.min;\n\t  var vec2Max = vec2.max;\n\t  var diff = Math.abs(startAngle - endAngle);\n\t\n\t  if (diff % PI2 < 1e-4 && diff > 1e-4) {\n\t    // Is a circle\n\t    min[0] = x - rx;\n\t    min[1] = y - ry;\n\t    max[0] = x + rx;\n\t    max[1] = y + ry;\n\t    return;\n\t  }\n\t\n\t  start[0] = mathCos(startAngle) * rx + x;\n\t  start[1] = mathSin(startAngle) * ry + y;\n\t  end[0] = mathCos(endAngle) * rx + x;\n\t  end[1] = mathSin(endAngle) * ry + y;\n\t  vec2Min(min, start, end);\n\t  vec2Max(max, start, end); // Thresh to [0, Math.PI * 2]\n\t\n\t  startAngle = startAngle % PI2;\n\t\n\t  if (startAngle < 0) {\n\t    startAngle = startAngle + PI2;\n\t  }\n\t\n\t  endAngle = endAngle % PI2;\n\t\n\t  if (endAngle < 0) {\n\t    endAngle = endAngle + PI2;\n\t  }\n\t\n\t  if (startAngle > endAngle && !anticlockwise) {\n\t    endAngle += PI2;\n\t  } else if (startAngle < endAngle && anticlockwise) {\n\t    startAngle += PI2;\n\t  }\n\t\n\t  if (anticlockwise) {\n\t    var tmp = endAngle;\n\t    endAngle = startAngle;\n\t    startAngle = tmp;\n\t  } // var number = 0;\n\t  // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\t\n\t\n\t  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n\t    if (angle > startAngle) {\n\t      extremity[0] = mathCos(angle) * rx + x;\n\t      extremity[1] = mathSin(angle) * ry + y;\n\t      vec2Min(min, extremity, min);\n\t      vec2Max(max, extremity, max);\n\t    }\n\t  }\n\t}\n\t\n\texports.fromPoints = fromPoints;\n\texports.fromLine = fromLine;\n\texports.fromCubic = fromCubic;\n\texports.fromQuadratic = fromQuadratic;\n\texports.fromArc = fromArc;\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar PathProxy = __webpack_require__(29);\n\t\n\tvar line = __webpack_require__(33);\n\t\n\tvar cubic = __webpack_require__(34);\n\t\n\tvar quadratic = __webpack_require__(35);\n\t\n\tvar arc = __webpack_require__(36);\n\t\n\tvar _util = __webpack_require__(37);\n\t\n\tvar normalizeRadian = _util.normalizeRadian;\n\t\n\tvar curve = __webpack_require__(30);\n\t\n\tvar windingLine = __webpack_require__(38);\n\t\n\tvar CMD = PathProxy.CMD;\n\tvar PI2 = Math.PI * 2;\n\tvar EPSILON = 1e-4;\n\t\n\tfunction isAroundEqual(a, b) {\n\t  return Math.abs(a - b) < EPSILON;\n\t} // 临时数组\n\t\n\t\n\tvar roots = [-1, -1, -1];\n\tvar extrema = [-1, -1];\n\t\n\tfunction swapExtrema() {\n\t  var tmp = extrema[0];\n\t  extrema[0] = extrema[1];\n\t  extrema[1] = tmp;\n\t}\n\t\n\tfunction windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n\t  // Quick reject\n\t  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {\n\t    return 0;\n\t  }\n\t\n\t  var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\t\n\t  if (nRoots === 0) {\n\t    return 0;\n\t  } else {\n\t    var w = 0;\n\t    var nExtrema = -1;\n\t    var y0_, y1_;\n\t\n\t    for (var i = 0; i < nRoots; i++) {\n\t      var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon\n\t\n\t      var unit = t === 0 || t === 1 ? 0.5 : 1;\n\t      var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\t\n\t      if (x_ < x) {\n\t        // Quick reject\n\t        continue;\n\t      }\n\t\n\t      if (nExtrema < 0) {\n\t        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\t\n\t        if (extrema[1] < extrema[0] && nExtrema > 1) {\n\t          swapExtrema();\n\t        }\n\t\n\t        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\t\n\t        if (nExtrema > 1) {\n\t          y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n\t        }\n\t      }\n\t\n\t      if (nExtrema == 2) {\n\t        // 分成三段单调函数\n\t        if (t < extrema[0]) {\n\t          w += y0_ < y0 ? unit : -unit;\n\t        } else if (t < extrema[1]) {\n\t          w += y1_ < y0_ ? unit : -unit;\n\t        } else {\n\t          w += y3 < y1_ ? unit : -unit;\n\t        }\n\t      } else {\n\t        // 分成两段单调函数\n\t        if (t < extrema[0]) {\n\t          w += y0_ < y0 ? unit : -unit;\n\t        } else {\n\t          w += y3 < y0_ ? unit : -unit;\n\t        }\n\t      }\n\t    }\n\t\n\t    return w;\n\t  }\n\t}\n\t\n\tfunction windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n\t  // Quick reject\n\t  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {\n\t    return 0;\n\t  }\n\t\n\t  var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\t\n\t  if (nRoots === 0) {\n\t    return 0;\n\t  } else {\n\t    var t = curve.quadraticExtremum(y0, y1, y2);\n\t\n\t    if (t >= 0 && t <= 1) {\n\t      var w = 0;\n\t      var y_ = curve.quadraticAt(y0, y1, y2, t);\n\t\n\t      for (var i = 0; i < nRoots; i++) {\n\t        // Remove one endpoint.\n\t        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;\n\t        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\t\n\t        if (x_ < x) {\n\t          // Quick reject\n\t          continue;\n\t        }\n\t\n\t        if (roots[i] < t) {\n\t          w += y_ < y0 ? unit : -unit;\n\t        } else {\n\t          w += y2 < y_ ? unit : -unit;\n\t        }\n\t      }\n\t\n\t      return w;\n\t    } else {\n\t      // Remove one endpoint.\n\t      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;\n\t      var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\t\n\t      if (x_ < x) {\n\t        // Quick reject\n\t        return 0;\n\t      }\n\t\n\t      return y2 < y0 ? unit : -unit;\n\t    }\n\t  }\n\t} // TODO\n\t// Arc 旋转\n\t\n\t\n\tfunction windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {\n\t  y -= cy;\n\t\n\t  if (y > r || y < -r) {\n\t    return 0;\n\t  }\n\t\n\t  var tmp = Math.sqrt(r * r - y * y);\n\t  roots[0] = -tmp;\n\t  roots[1] = tmp;\n\t  var diff = Math.abs(startAngle - endAngle);\n\t\n\t  if (diff < 1e-4) {\n\t    return 0;\n\t  }\n\t\n\t  if (diff % PI2 < 1e-4) {\n\t    // Is a circle\n\t    startAngle = 0;\n\t    endAngle = PI2;\n\t    var dir = anticlockwise ? 1 : -1;\n\t\n\t    if (x >= roots[0] + cx && x <= roots[1] + cx) {\n\t      return dir;\n\t    } else {\n\t      return 0;\n\t    }\n\t  }\n\t\n\t  if (anticlockwise) {\n\t    var tmp = startAngle;\n\t    startAngle = normalizeRadian(endAngle);\n\t    endAngle = normalizeRadian(tmp);\n\t  } else {\n\t    startAngle = normalizeRadian(startAngle);\n\t    endAngle = normalizeRadian(endAngle);\n\t  }\n\t\n\t  if (startAngle > endAngle) {\n\t    endAngle += PI2;\n\t  }\n\t\n\t  var w = 0;\n\t\n\t  for (var i = 0; i < 2; i++) {\n\t    var x_ = roots[i];\n\t\n\t    if (x_ + cx > x) {\n\t      var angle = Math.atan2(y, x_);\n\t      var dir = anticlockwise ? 1 : -1;\n\t\n\t      if (angle < 0) {\n\t        angle = PI2 + angle;\n\t      }\n\t\n\t      if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n\t        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n\t          dir = -dir;\n\t        }\n\t\n\t        w += dir;\n\t      }\n\t    }\n\t  }\n\t\n\t  return w;\n\t}\n\t\n\tfunction containPath(data, lineWidth, isStroke, x, y) {\n\t  var w = 0;\n\t  var xi = 0;\n\t  var yi = 0;\n\t  var x0 = 0;\n\t  var y0 = 0;\n\t\n\t  for (var i = 0; i < data.length;) {\n\t    var cmd = data[i++]; // Begin a new subpath\n\t\n\t    if (cmd === CMD.M && i > 1) {\n\t      // Close previous subpath\n\t      if (!isStroke) {\n\t        w += windingLine(xi, yi, x0, y0, x, y);\n\t      } // 如果被任何一个 subpath 包含\n\t      // if (w !== 0) {\n\t      //     return true;\n\t      // }\n\t\n\t    }\n\t\n\t    if (i == 1) {\n\t      // 如果第一个命令是 L, C, Q\n\t      // 则 previous point 同绘制命令的第一个 point\n\t      //\n\t      // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t      xi = data[i];\n\t      yi = data[i + 1];\n\t      x0 = xi;\n\t      y0 = yi;\n\t    }\n\t\n\t    switch (cmd) {\n\t      case CMD.M:\n\t        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n\t        // 在 closePath 的时候使用\n\t        x0 = data[i++];\n\t        y0 = data[i++];\n\t        xi = x0;\n\t        yi = y0;\n\t        break;\n\t\n\t      case CMD.L:\n\t        if (isStroke) {\n\t          if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n\t          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n\t        }\n\t\n\t        xi = data[i++];\n\t        yi = data[i++];\n\t        break;\n\t\n\t      case CMD.C:\n\t        if (isStroke) {\n\t          if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n\t        }\n\t\n\t        xi = data[i++];\n\t        yi = data[i++];\n\t        break;\n\t\n\t      case CMD.Q:\n\t        if (isStroke) {\n\t          if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n\t        }\n\t\n\t        xi = data[i++];\n\t        yi = data[i++];\n\t        break;\n\t\n\t      case CMD.A:\n\t        // TODO Arc 判断的开销比较大\n\t        var cx = data[i++];\n\t        var cy = data[i++];\n\t        var rx = data[i++];\n\t        var ry = data[i++];\n\t        var theta = data[i++];\n\t        var dTheta = data[i++]; // TODO Arc 旋转\n\t\n\t        var psi = data[i++];\n\t        var anticlockwise = 1 - data[i++];\n\t        var x1 = Math.cos(theta) * rx + cx;\n\t        var y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令\n\t\n\t        if (i > 1) {\n\t          w += windingLine(xi, yi, x1, y1, x, y);\n\t        } else {\n\t          // 第一个命令起点还未定义\n\t          x0 = x1;\n\t          y0 = y1;\n\t        } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n\t\n\t\n\t        var _x = (x - cx) * ry / rx + cx;\n\t\n\t        if (isStroke) {\n\t          if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);\n\t        }\n\t\n\t        xi = Math.cos(theta + dTheta) * rx + cx;\n\t        yi = Math.sin(theta + dTheta) * ry + cy;\n\t        break;\n\t\n\t      case CMD.R:\n\t        x0 = xi = data[i++];\n\t        y0 = yi = data[i++];\n\t        var width = data[i++];\n\t        var height = data[i++];\n\t        var x1 = x0 + width;\n\t        var y1 = y0 + height;\n\t\n\t        if (isStroke) {\n\t          if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          // FIXME Clockwise ?\n\t          w += windingLine(x1, y0, x1, y1, x, y);\n\t          w += windingLine(x0, y1, x0, y0, x, y);\n\t        }\n\t\n\t        break;\n\t\n\t      case CMD.Z:\n\t        if (isStroke) {\n\t          if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {\n\t            return true;\n\t          }\n\t        } else {\n\t          // Close a subpath\n\t          w += windingLine(xi, yi, x0, y0, x, y); // 如果被任何一个 subpath 包含\n\t          // FIXME subpaths may overlap\n\t          // if (w !== 0) {\n\t          //     return true;\n\t          // }\n\t        }\n\t\n\t        xi = x0;\n\t        yi = y0;\n\t        break;\n\t    }\n\t  }\n\t\n\t  if (!isStroke && !isAroundEqual(yi, y0)) {\n\t    w += windingLine(xi, yi, x0, y0, x, y) || 0;\n\t  }\n\t\n\t  return w !== 0;\n\t}\n\t\n\tfunction contain(pathData, x, y) {\n\t  return containPath(pathData, 0, false, x, y);\n\t}\n\t\n\tfunction containStroke(pathData, lineWidth, x, y) {\n\t  return containPath(pathData, lineWidth, true, x, y);\n\t}\n\t\n\texports.contain = contain;\n\texports.containStroke = containStroke;\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * 线段包含判断\n\t * @param  {number}  x0\n\t * @param  {number}  y0\n\t * @param  {number}  x1\n\t * @param  {number}  y1\n\t * @param  {number}  lineWidth\n\t * @param  {number}  x\n\t * @param  {number}  y\n\t * @return {boolean}\n\t */\n\tfunction containStroke(x0, y0, x1, y1, lineWidth, x, y) {\n\t  if (lineWidth === 0) {\n\t    return false;\n\t  }\n\t\n\t  var _l = lineWidth;\n\t  var _a = 0;\n\t  var _b = x0; // Quick reject\n\t\n\t  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {\n\t    return false;\n\t  }\n\t\n\t  if (x0 !== x1) {\n\t    _a = (y0 - y1) / (x0 - x1);\n\t    _b = (x0 * y1 - x1 * y0) / (x0 - x1);\n\t  } else {\n\t    return Math.abs(x - x0) <= _l / 2;\n\t  }\n\t\n\t  var tmp = _a * x - y + _b;\n\t\n\t  var _s = tmp * tmp / (_a * _a + 1);\n\t\n\t  return _s <= _l / 2 * _l / 2;\n\t}\n\t\n\texports.containStroke = containStroke;\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar curve = __webpack_require__(30);\n\t\n\t/**\n\t * 三次贝塞尔曲线描边包含判断\n\t * @param  {number}  x0\n\t * @param  {number}  y0\n\t * @param  {number}  x1\n\t * @param  {number}  y1\n\t * @param  {number}  x2\n\t * @param  {number}  y2\n\t * @param  {number}  x3\n\t * @param  {number}  y3\n\t * @param  {number}  lineWidth\n\t * @param  {number}  x\n\t * @param  {number}  y\n\t * @return {boolean}\n\t */\n\tfunction containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n\t  if (lineWidth === 0) {\n\t    return false;\n\t  }\n\t\n\t  var _l = lineWidth; // Quick reject\n\t\n\t  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {\n\t    return false;\n\t  }\n\t\n\t  var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);\n\t  return d <= _l / 2;\n\t}\n\t\n\texports.containStroke = containStroke;\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _curve = __webpack_require__(30);\n\t\n\tvar quadraticProjectPoint = _curve.quadraticProjectPoint;\n\t\n\t/**\n\t * 二次贝塞尔曲线描边包含判断\n\t * @param  {number}  x0\n\t * @param  {number}  y0\n\t * @param  {number}  x1\n\t * @param  {number}  y1\n\t * @param  {number}  x2\n\t * @param  {number}  y2\n\t * @param  {number}  lineWidth\n\t * @param  {number}  x\n\t * @param  {number}  y\n\t * @return {boolean}\n\t */\n\tfunction containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n\t  if (lineWidth === 0) {\n\t    return false;\n\t  }\n\t\n\t  var _l = lineWidth; // Quick reject\n\t\n\t  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {\n\t    return false;\n\t  }\n\t\n\t  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);\n\t  return d <= _l / 2;\n\t}\n\t\n\texports.containStroke = containStroke;\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _util = __webpack_require__(37);\n\t\n\tvar normalizeRadian = _util.normalizeRadian;\n\tvar PI2 = Math.PI * 2;\n\t/**\n\t * 圆弧描边包含判断\n\t * @param  {number}  cx\n\t * @param  {number}  cy\n\t * @param  {number}  r\n\t * @param  {number}  startAngle\n\t * @param  {number}  endAngle\n\t * @param  {boolean}  anticlockwise\n\t * @param  {number} lineWidth\n\t * @param  {number}  x\n\t * @param  {number}  y\n\t * @return {Boolean}\n\t */\n\t\n\tfunction containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {\n\t  if (lineWidth === 0) {\n\t    return false;\n\t  }\n\t\n\t  var _l = lineWidth;\n\t  x -= cx;\n\t  y -= cy;\n\t  var d = Math.sqrt(x * x + y * y);\n\t\n\t  if (d - _l > r || d + _l < r) {\n\t    return false;\n\t  }\n\t\n\t  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n\t    // Is a circle\n\t    return true;\n\t  }\n\t\n\t  if (anticlockwise) {\n\t    var tmp = startAngle;\n\t    startAngle = normalizeRadian(endAngle);\n\t    endAngle = normalizeRadian(tmp);\n\t  } else {\n\t    startAngle = normalizeRadian(startAngle);\n\t    endAngle = normalizeRadian(endAngle);\n\t  }\n\t\n\t  if (startAngle > endAngle) {\n\t    endAngle += PI2;\n\t  }\n\t\n\t  var angle = Math.atan2(y, x);\n\t\n\t  if (angle < 0) {\n\t    angle += PI2;\n\t  }\n\t\n\t  return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;\n\t}\n\t\n\texports.containStroke = containStroke;\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports) {\n\n\tvar PI2 = Math.PI * 2;\n\t\n\tfunction normalizeRadian(angle) {\n\t  angle %= PI2;\n\t\n\t  if (angle < 0) {\n\t    angle += PI2;\n\t  }\n\t\n\t  return angle;\n\t}\n\t\n\texports.normalizeRadian = normalizeRadian;\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports) {\n\n\tfunction windingLine(x0, y0, x1, y1, x, y) {\n\t  if (y > y0 && y > y1 || y < y0 && y < y1) {\n\t    return 0;\n\t  } // Ignore horizontal line\n\t\n\t\n\t  if (y1 === y0) {\n\t    return 0;\n\t  }\n\t\n\t  var dir = y1 < y0 ? 1 : -1;\n\t  var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon\n\t\n\t  if (t === 1 || t === 0) {\n\t    dir = y1 < y0 ? 0.5 : -0.5;\n\t  }\n\t\n\t  var x_ = t * (x1 - x0) + x0;\n\t  return x_ > x ? dir : 0;\n\t}\n\t\n\tmodule.exports = windingLine;\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports) {\n\n\tvar Pattern = function (image, repeat) {\n\t  // Should do nothing more in this constructor. Because gradient can be\n\t  // declard by `color: {image: ...}`, where this constructor will not be called.\n\t  this.image = image;\n\t  this.repeat = repeat; // Can be cloned\n\t\n\t  this.type = 'pattern';\n\t};\n\t\n\tPattern.prototype.getCanvasPattern = function (ctx) {\n\t  return ctx.createPattern(this.image, this.repeat || 'repeat');\n\t};\n\t\n\tvar _default = Pattern;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar PathProxy = __webpack_require__(29);\n\t\n\tvar _vector = __webpack_require__(14);\n\t\n\tvar v2ApplyTransform = _vector.applyTransform;\n\tvar CMD = PathProxy.CMD;\n\tvar points = [[], [], []];\n\tvar mathSqrt = Math.sqrt;\n\tvar mathAtan2 = Math.atan2;\n\t\n\tfunction _default(path, m) {\n\t  var data = path.data;\n\t  var cmd;\n\t  var nPoint;\n\t  var i;\n\t  var j;\n\t  var k;\n\t  var p;\n\t  var M = CMD.M;\n\t  var C = CMD.C;\n\t  var L = CMD.L;\n\t  var R = CMD.R;\n\t  var A = CMD.A;\n\t  var Q = CMD.Q;\n\t\n\t  for (i = 0, j = 0; i < data.length;) {\n\t    cmd = data[i++];\n\t    j = i;\n\t    nPoint = 0;\n\t\n\t    switch (cmd) {\n\t      case M:\n\t        nPoint = 1;\n\t        break;\n\t\n\t      case L:\n\t        nPoint = 1;\n\t        break;\n\t\n\t      case C:\n\t        nPoint = 3;\n\t        break;\n\t\n\t      case Q:\n\t        nPoint = 2;\n\t        break;\n\t\n\t      case A:\n\t        var x = m[4];\n\t        var y = m[5];\n\t        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n\t        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n\t        var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx\n\t\n\t        data[i] *= sx;\n\t        data[i++] += x; // cy\n\t\n\t        data[i] *= sy;\n\t        data[i++] += y; // Scale rx and ry\n\t        // FIXME Assume psi is 0 here\n\t\n\t        data[i++] *= sx;\n\t        data[i++] *= sy; // Start angle\n\t\n\t        data[i++] += angle; // end angle\n\t\n\t        data[i++] += angle; // FIXME psi\n\t\n\t        i += 2;\n\t        j = i;\n\t        break;\n\t\n\t      case R:\n\t        // x0, y0\n\t        p[0] = data[i++];\n\t        p[1] = data[i++];\n\t        v2ApplyTransform(p, p, m);\n\t        data[j++] = p[0];\n\t        data[j++] = p[1]; // x1, y1\n\t\n\t        p[0] += data[i++];\n\t        p[1] += data[i++];\n\t        v2ApplyTransform(p, p, m);\n\t        data[j++] = p[0];\n\t        data[j++] = p[1];\n\t    }\n\t\n\t    for (k = 0; k < nPoint; k++) {\n\t      var p = points[k];\n\t      p[0] = data[i++];\n\t      p[1] = data[i++];\n\t      v2ApplyTransform(p, p, m); // Write back\n\t\n\t      data[j++] = p[0];\n\t      data[j++] = p[1];\n\t    }\n\t  }\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * @param {Array.<Object>} colorStops\n\t */\n\tvar Gradient = function (colorStops) {\n\t  this.colorStops = colorStops || [];\n\t};\n\t\n\tGradient.prototype = {\n\t  constructor: Gradient,\n\t  addColorStop: function (offset, color) {\n\t    this.colorStops.push({\n\t      offset: offset,\n\t      color: color\n\t    });\n\t  }\n\t};\n\tvar _default = Gradient;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports) {\n\n\t// TODO Draggable for group\n\t// FIXME Draggable on element which has parent rotation or scale\n\tfunction Draggable() {\n\t  this.on('mousedown', this._dragStart, this);\n\t  this.on('mousemove', this._drag, this);\n\t  this.on('mouseup', this._dragEnd, this);\n\t  this.on('globalout', this._dragEnd, this); // this._dropTarget = null;\n\t  // this._draggingTarget = null;\n\t  // this._x = 0;\n\t  // this._y = 0;\n\t}\n\t\n\tDraggable.prototype = {\n\t  constructor: Draggable,\n\t  _dragStart: function (e) {\n\t    var draggingTarget = e.target;\n\t\n\t    if (draggingTarget && draggingTarget.draggable) {\n\t      this._draggingTarget = draggingTarget;\n\t      draggingTarget.dragging = true;\n\t      this._x = e.offsetX;\n\t      this._y = e.offsetY;\n\t      this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n\t    }\n\t  },\n\t  _drag: function (e) {\n\t    var draggingTarget = this._draggingTarget;\n\t\n\t    if (draggingTarget) {\n\t      var x = e.offsetX;\n\t      var y = e.offsetY;\n\t      var dx = x - this._x;\n\t      var dy = y - this._y;\n\t      this._x = x;\n\t      this._y = y;\n\t      draggingTarget.drift(dx, dy, e);\n\t      this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n\t      var dropTarget = this.findHover(x, y, draggingTarget).target;\n\t      var lastDropTarget = this._dropTarget;\n\t      this._dropTarget = dropTarget;\n\t\n\t      if (draggingTarget !== dropTarget) {\n\t        if (lastDropTarget && dropTarget !== lastDropTarget) {\n\t          this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n\t        }\n\t\n\t        if (dropTarget && dropTarget !== lastDropTarget) {\n\t          this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n\t        }\n\t      }\n\t    }\n\t  },\n\t  _dragEnd: function (e) {\n\t    var draggingTarget = this._draggingTarget;\n\t\n\t    if (draggingTarget) {\n\t      draggingTarget.dragging = false;\n\t    }\n\t\n\t    this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\t\n\t    if (this._dropTarget) {\n\t      this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n\t    }\n\t\n\t    this._draggingTarget = null;\n\t    this._dropTarget = null;\n\t  }\n\t};\n\t\n\tfunction param(target, e) {\n\t  return {\n\t    target: target,\n\t    topTarget: e && e.topTarget\n\t  };\n\t}\n\t\n\tvar _default = Draggable;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrUtil = __webpack_require__(4);\n\t\n\tvar Element = __webpack_require__(9);\n\t\n\tvar BoundingRect = __webpack_require__(26);\n\t\n\t/**\n\t * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上\n\t * @module zrender/graphic/Group\n\t * @example\n\t *     var Group = require('zrender/container/Group');\n\t *     var Circle = require('zrender/graphic/shape/Circle');\n\t *     var g = new Group();\n\t *     g.position[0] = 100;\n\t *     g.position[1] = 100;\n\t *     g.add(new Circle({\n\t *         style: {\n\t *             x: 100,\n\t *             y: 100,\n\t *             r: 20,\n\t *         }\n\t *     }));\n\t *     zr.add(g);\n\t */\n\t\n\t/**\n\t * @alias module:zrender/graphic/Group\n\t * @constructor\n\t * @extends module:zrender/mixin/Transformable\n\t * @extends module:zrender/mixin/Eventful\n\t */\n\tvar Group = function (opts) {\n\t  opts = opts || {};\n\t  Element.call(this, opts);\n\t\n\t  for (var key in opts) {\n\t    if (opts.hasOwnProperty(key)) {\n\t      this[key] = opts[key];\n\t    }\n\t  }\n\t\n\t  this._children = [];\n\t  this.__storage = null;\n\t  this.__dirty = true;\n\t};\n\t\n\tGroup.prototype = {\n\t  constructor: Group,\n\t  isGroup: true,\n\t\n\t  /**\n\t   * @type {string}\n\t   */\n\t  type: 'group',\n\t\n\t  /**\n\t   * 所有子孙元素是否响应鼠标事件\n\t   * @name module:/zrender/container/Group#silent\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t  silent: false,\n\t\n\t  /**\n\t   * @return {Array.<module:zrender/Element>}\n\t   */\n\t  children: function () {\n\t    return this._children.slice();\n\t  },\n\t\n\t  /**\n\t   * 获取指定 index 的儿子节点\n\t   * @param  {number} idx\n\t   * @return {module:zrender/Element}\n\t   */\n\t  childAt: function (idx) {\n\t    return this._children[idx];\n\t  },\n\t\n\t  /**\n\t   * 获取指定名字的儿子节点\n\t   * @param  {string} name\n\t   * @return {module:zrender/Element}\n\t   */\n\t  childOfName: function (name) {\n\t    var children = this._children;\n\t\n\t    for (var i = 0; i < children.length; i++) {\n\t      if (children[i].name === name) {\n\t        return children[i];\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @return {number}\n\t   */\n\t  childCount: function () {\n\t    return this._children.length;\n\t  },\n\t\n\t  /**\n\t   * 添加子节点到最后\n\t   * @param {module:zrender/Element} child\n\t   */\n\t  add: function (child) {\n\t    if (child && child !== this && child.parent !== this) {\n\t      this._children.push(child);\n\t\n\t      this._doAdd(child);\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 添加子节点在 nextSibling 之前\n\t   * @param {module:zrender/Element} child\n\t   * @param {module:zrender/Element} nextSibling\n\t   */\n\t  addBefore: function (child, nextSibling) {\n\t    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {\n\t      var children = this._children;\n\t      var idx = children.indexOf(nextSibling);\n\t\n\t      if (idx >= 0) {\n\t        children.splice(idx, 0, child);\n\t\n\t        this._doAdd(child);\n\t      }\n\t    }\n\t\n\t    return this;\n\t  },\n\t  _doAdd: function (child) {\n\t    if (child.parent) {\n\t      child.parent.remove(child);\n\t    }\n\t\n\t    child.parent = this;\n\t    var storage = this.__storage;\n\t    var zr = this.__zr;\n\t\n\t    if (storage && storage !== child.__storage) {\n\t      storage.addToStorage(child);\n\t\n\t      if (child instanceof Group) {\n\t        child.addChildrenToStorage(storage);\n\t      }\n\t    }\n\t\n\t    zr && zr.refresh();\n\t  },\n\t\n\t  /**\n\t   * 移除子节点\n\t   * @param {module:zrender/Element} child\n\t   */\n\t  remove: function (child) {\n\t    var zr = this.__zr;\n\t    var storage = this.__storage;\n\t    var children = this._children;\n\t    var idx = zrUtil.indexOf(children, child);\n\t\n\t    if (idx < 0) {\n\t      return this;\n\t    }\n\t\n\t    children.splice(idx, 1);\n\t    child.parent = null;\n\t\n\t    if (storage) {\n\t      storage.delFromStorage(child);\n\t\n\t      if (child instanceof Group) {\n\t        child.delChildrenFromStorage(storage);\n\t      }\n\t    }\n\t\n\t    zr && zr.refresh();\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 移除所有子节点\n\t   */\n\t  removeAll: function () {\n\t    var children = this._children;\n\t    var storage = this.__storage;\n\t    var child;\n\t    var i;\n\t\n\t    for (i = 0; i < children.length; i++) {\n\t      child = children[i];\n\t\n\t      if (storage) {\n\t        storage.delFromStorage(child);\n\t\n\t        if (child instanceof Group) {\n\t          child.delChildrenFromStorage(storage);\n\t        }\n\t      }\n\t\n\t      child.parent = null;\n\t    }\n\t\n\t    children.length = 0;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 遍历所有子节点\n\t   * @param  {Function} cb\n\t   * @param  {}   context\n\t   */\n\t  eachChild: function (cb, context) {\n\t    var children = this._children;\n\t\n\t    for (var i = 0; i < children.length; i++) {\n\t      var child = children[i];\n\t      cb.call(context, child, i);\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 深度优先遍历所有子孙节点\n\t   * @param  {Function} cb\n\t   * @param  {}   context\n\t   */\n\t  traverse: function (cb, context) {\n\t    for (var i = 0; i < this._children.length; i++) {\n\t      var child = this._children[i];\n\t      cb.call(context, child);\n\t\n\t      if (child.type === 'group') {\n\t        child.traverse(cb, context);\n\t      }\n\t    }\n\t\n\t    return this;\n\t  },\n\t  addChildrenToStorage: function (storage) {\n\t    for (var i = 0; i < this._children.length; i++) {\n\t      var child = this._children[i];\n\t      storage.addToStorage(child);\n\t\n\t      if (child instanceof Group) {\n\t        child.addChildrenToStorage(storage);\n\t      }\n\t    }\n\t  },\n\t  delChildrenFromStorage: function (storage) {\n\t    for (var i = 0; i < this._children.length; i++) {\n\t      var child = this._children[i];\n\t      storage.delFromStorage(child);\n\t\n\t      if (child instanceof Group) {\n\t        child.delChildrenFromStorage(storage);\n\t      }\n\t    }\n\t  },\n\t  dirty: function () {\n\t    this.__dirty = true;\n\t    this.__zr && this.__zr.refresh();\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * @return {module:zrender/core/BoundingRect}\n\t   */\n\t  getBoundingRect: function (includeChildren) {\n\t    // TODO Caching\n\t    var rect = null;\n\t    var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t    var children = includeChildren || this._children;\n\t    var tmpMat = [];\n\t\n\t    for (var i = 0; i < children.length; i++) {\n\t      var child = children[i];\n\t\n\t      if (child.ignore || child.invisible) {\n\t        continue;\n\t      }\n\t\n\t      var childRect = child.getBoundingRect();\n\t      var transform = child.getLocalTransform(tmpMat); // TODO\n\t      // The boundingRect cacluated by transforming original\n\t      // rect may be bigger than the actual bundingRect when rotation\n\t      // is used. (Consider a circle rotated aginst its center, where\n\t      // the actual boundingRect should be the same as that not be\n\t      // rotated.) But we can not find better approach to calculate\n\t      // actual boundingRect yet, considering performance.\n\t\n\t      if (transform) {\n\t        tmpRect.copy(childRect);\n\t        tmpRect.applyTransform(transform);\n\t        rect = rect || tmpRect.clone();\n\t        rect.union(tmpRect);\n\t      } else {\n\t        rect = rect || childRect.clone();\n\t        rect.union(childRect);\n\t      }\n\t    }\n\t\n\t    return rect || tmpRect;\n\t  }\n\t};\n\tzrUtil.inherits(Group, Element);\n\tvar _default = Group;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Displayable = __webpack_require__(7);\n\t\n\tvar BoundingRect = __webpack_require__(26);\n\t\n\tvar zrUtil = __webpack_require__(4);\n\t\n\tvar imageHelper = __webpack_require__(27);\n\t\n\t/**\n\t * @alias zrender/graphic/Image\n\t * @extends module:zrender/graphic/Displayable\n\t * @constructor\n\t * @param {Object} opts\n\t */\n\tfunction ZImage(opts) {\n\t  Displayable.call(this, opts);\n\t}\n\t\n\tZImage.prototype = {\n\t  constructor: ZImage,\n\t  type: 'image',\n\t  brush: function (ctx, prevEl) {\n\t    var style = this.style;\n\t    var src = style.image; // Must bind each time\n\t\n\t    style.bind(ctx, this, prevEl);\n\t    var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);\n\t\n\t    if (!image || !imageHelper.isImageReady(image)) {\n\t      return;\n\t    } // 图片已经加载完成\n\t    // if (image.nodeName.toUpperCase() == 'IMG') {\n\t    //     if (!image.complete) {\n\t    //         return;\n\t    //     }\n\t    // }\n\t    // Else is canvas\n\t\n\t\n\t    var x = style.x || 0;\n\t    var y = style.y || 0;\n\t    var width = style.width;\n\t    var height = style.height;\n\t    var aspect = image.width / image.height;\n\t\n\t    if (width == null && height != null) {\n\t      // Keep image/height ratio\n\t      width = height * aspect;\n\t    } else if (height == null && width != null) {\n\t      height = width / aspect;\n\t    } else if (width == null && height == null) {\n\t      width = image.width;\n\t      height = image.height;\n\t    } // 设置transform\n\t\n\t\n\t    this.setTransform(ctx);\n\t\n\t    if (style.sWidth && style.sHeight) {\n\t      var sx = style.sx || 0;\n\t      var sy = style.sy || 0;\n\t      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n\t    } else if (style.sx && style.sy) {\n\t      var sx = style.sx;\n\t      var sy = style.sy;\n\t      var sWidth = width - sx;\n\t      var sHeight = height - sy;\n\t      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n\t    } else {\n\t      ctx.drawImage(image, x, y, width, height);\n\t    }\n\t\n\t    this.restoreTransform(ctx); // Draw rect text\n\t\n\t    if (style.text != null) {\n\t      this.drawRectText(ctx, this.getBoundingRect());\n\t    }\n\t  },\n\t  getBoundingRect: function () {\n\t    var style = this.style;\n\t\n\t    if (!this._rect) {\n\t      this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);\n\t    }\n\t\n\t    return this._rect;\n\t  }\n\t};\n\tzrUtil.inherits(ZImage, Displayable);\n\tvar _default = ZImage;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Displayable = __webpack_require__(7);\n\t\n\tvar zrUtil = __webpack_require__(4);\n\t\n\tvar textContain = __webpack_require__(25);\n\t\n\tvar textHelper = __webpack_require__(24);\n\t\n\t/**\n\t * @alias zrender/graphic/Text\n\t * @extends module:zrender/graphic/Displayable\n\t * @constructor\n\t * @param {Object} opts\n\t */\n\tvar Text = function (opts) {\n\t  // jshint ignore:line\n\t  Displayable.call(this, opts);\n\t};\n\t\n\tText.prototype = {\n\t  constructor: Text,\n\t  type: 'text',\n\t  brush: function (ctx, prevEl) {\n\t    var style = this.style; // Optimize, avoid normalize every time.\n\t\n\t    this.__dirty && textHelper.normalizeTextStyle(style, true); // Use props with prefix 'text'.\n\t\n\t    style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;\n\t    var text = style.text; // Convert to string\n\t\n\t    text != null && (text += ''); // Always bind style\n\t\n\t    style.bind(ctx, this, prevEl);\n\t\n\t    if (!textHelper.needDrawText(text, style)) {\n\t      return;\n\t    }\n\t\n\t    this.setTransform(ctx);\n\t    textHelper.renderText(this, ctx, text, style);\n\t    this.restoreTransform(ctx);\n\t  },\n\t  getBoundingRect: function () {\n\t    var style = this.style; // Optimize, avoid normalize every time.\n\t\n\t    this.__dirty && textHelper.normalizeTextStyle(style, true);\n\t\n\t    if (!this._rect) {\n\t      var text = style.text;\n\t      text != null ? text += '' : text = '';\n\t      var rect = textContain.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.rich);\n\t      rect.x += style.x || 0;\n\t      rect.y += style.y || 0;\n\t\n\t      if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {\n\t        var w = style.textStrokeWidth;\n\t        rect.x -= w / 2;\n\t        rect.y -= w / 2;\n\t        rect.width += w;\n\t        rect.height += w;\n\t      }\n\t\n\t      this._rect = rect;\n\t    }\n\t\n\t    return this._rect;\n\t  }\n\t};\n\tzrUtil.inherits(Text, Displayable);\n\tvar _default = Text;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(6);\n\t\n\t/**\n\t * 圆形\n\t * @module zrender/shape/Circle\n\t */\n\tvar _default = Path.extend({\n\t  type: 'circle',\n\t  shape: {\n\t    cx: 0,\n\t    cy: 0,\n\t    r: 0\n\t  },\n\t  buildPath: function (ctx, shape, inBundle) {\n\t    // Better stroking in ShapeBundle\n\t    // Always do it may have performence issue ( fill may be 2x more cost)\n\t    if (inBundle) {\n\t      ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t    } // else {\n\t    //     if (ctx.allocate && !ctx.data.length) {\n\t    //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n\t    //     }\n\t    // }\n\t    // Better stroking in ShapeBundle\n\t    // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t\n\t\n\t    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(6);\n\t\n\tvar fixClipWithShadow = __webpack_require__(48);\n\t\n\t/**\n\t * 扇形\n\t * @module zrender/graphic/shape/Sector\n\t */\n\tvar _default = Path.extend({\n\t  type: 'sector',\n\t  shape: {\n\t    cx: 0,\n\t    cy: 0,\n\t    r0: 0,\n\t    r: 0,\n\t    startAngle: 0,\n\t    endAngle: Math.PI * 2,\n\t    clockwise: true\n\t  },\n\t  brush: fixClipWithShadow(Path.prototype.brush),\n\t  buildPath: function (ctx, shape) {\n\t    var x = shape.cx;\n\t    var y = shape.cy;\n\t    var r0 = Math.max(shape.r0 || 0, 0);\n\t    var r = Math.max(shape.r, 0);\n\t    var startAngle = shape.startAngle;\n\t    var endAngle = shape.endAngle;\n\t    var clockwise = shape.clockwise;\n\t    var unitX = Math.cos(startAngle);\n\t    var unitY = Math.sin(startAngle);\n\t    ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\t    ctx.lineTo(unitX * r + x, unitY * r + y);\n\t    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t    ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);\n\t\n\t    if (r0 !== 0) {\n\t      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n\t    }\n\t\n\t    ctx.closePath();\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar env = __webpack_require__(49);\n\t\n\t// Fix weird bug in some version of IE11 (like 11.0.9600.178**),\n\t// where exception \"unexpected call to method or property access\"\n\t// might be thrown when calling ctx.fill or ctx.stroke after a path\n\t// whose area size is zero is drawn and ctx.clip() is called and\n\t// shadowBlur is set. See #4572, #3112, #5777.\n\t// (e.g.,\n\t//  ctx.moveTo(10, 10);\n\t//  ctx.lineTo(20, 10);\n\t//  ctx.closePath();\n\t//  ctx.clip();\n\t//  ctx.shadowBlur = 10;\n\t//  ...\n\t//  ctx.fill();\n\t// )\n\tvar shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];\n\t\n\tfunction _default(orignalBrush) {\n\t  // version string can be: '11.0'\n\t  return env.browser.ie && env.browser.version >= 11 ? function () {\n\t    var clipPaths = this.__clipPaths;\n\t    var style = this.style;\n\t    var modified;\n\t\n\t    if (clipPaths) {\n\t      for (var i = 0; i < clipPaths.length; i++) {\n\t        var clipPath = clipPaths[i];\n\t        var shape = clipPath && clipPath.shape;\n\t        var type = clipPath && clipPath.type;\n\t\n\t        if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {\n\t          for (var j = 0; j < shadowTemp.length; j++) {\n\t            // It is save to put shadowTemp static, because shadowTemp\n\t            // will be all modified each item brush called.\n\t            shadowTemp[j][2] = style[shadowTemp[j][0]];\n\t            style[shadowTemp[j][0]] = shadowTemp[j][1];\n\t          }\n\t\n\t          modified = true;\n\t          break;\n\t        }\n\t      }\n\t    }\n\t\n\t    orignalBrush.apply(this, arguments);\n\t\n\t    if (modified) {\n\t      for (var j = 0; j < shadowTemp.length; j++) {\n\t        style[shadowTemp[j][0]] = shadowTemp[j][2];\n\t      }\n\t    }\n\t  } : orignalBrush;\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * echarts设备环境识别\n\t *\n\t * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\n\t * @author firede[firede@firede.us]\n\t * @desc thanks zepto.\n\t */\n\tvar env = {};\n\t\n\tif (typeof navigator === 'undefined') {\n\t  // In node\n\t  env = {\n\t    browser: {},\n\t    os: {},\n\t    node: true,\n\t    // Assume canvas is supported\n\t    canvasSupported: true,\n\t    svgSupported: true\n\t  };\n\t} else {\n\t  env = detect(navigator.userAgent);\n\t}\n\t\n\tvar _default = env; // Zepto.js\n\t// (c) 2010-2013 Thomas Fuchs\n\t// Zepto.js may be freely distributed under the MIT license.\n\t\n\tfunction detect(ua) {\n\t  var os = {};\n\t  var browser = {}; // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n\t  // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n\t  // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n\t  // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n\t  // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n\t  // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n\t  // var touchpad = webos && ua.match(/TouchPad/);\n\t  // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n\t  // var silk = ua.match(/Silk\\/([\\d._]+)/);\n\t  // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n\t  // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n\t  // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n\t  // var playbook = ua.match(/PlayBook/);\n\t  // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\t\n\t  var firefox = ua.match(/Firefox\\/([\\d.]+)/); // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n\t  // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\t\n\t  var ie = ua.match(/MSIE\\s([\\d.]+)/) // IE 11 Trident/7.0; rv:11.0\n\t  || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n\t  var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\t\n\t  var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:\n\t  // - discern (more) between multiple browsers on android\n\t  // - decide if kindle fire in silk mode is android or not\n\t  // - Firefox on Android doesn't specify the Android version\n\t  // - possibly devide in os, device and browser hashes\n\t  // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\t  // if (android) os.android = true, os.version = android[2];\n\t  // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n\t  // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n\t  // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n\t  // if (webos) os.webos = true, os.version = webos[2];\n\t  // if (touchpad) os.touchpad = true;\n\t  // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n\t  // if (bb10) os.bb10 = true, os.version = bb10[2];\n\t  // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n\t  // if (playbook) browser.playbook = true;\n\t  // if (kindle) os.kindle = true, os.version = kindle[1];\n\t  // if (silk) browser.silk = true, browser.version = silk[1];\n\t  // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n\t  // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\t\n\t  if (firefox) {\n\t    browser.firefox = true;\n\t    browser.version = firefox[1];\n\t  } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n\t  // if (webview) browser.webview = true;\n\t\n\t\n\t  if (ie) {\n\t    browser.ie = true;\n\t    browser.version = ie[1];\n\t  }\n\t\n\t  if (edge) {\n\t    browser.edge = true;\n\t    browser.version = edge[1];\n\t  } // It is difficult to detect WeChat in Win Phone precisely, because ua can\n\t  // not be set on win phone. So we do not consider Win Phone.\n\t\n\t\n\t  if (weChat) {\n\t    browser.weChat = true;\n\t  } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n\t  //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n\t  // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n\t  //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n\t  //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\t\n\t\n\t  return {\n\t    browser: browser,\n\t    os: os,\n\t    node: false,\n\t    // 原生canvas支持，改极端点了\n\t    // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n\t    canvasSupported: !!document.createElement('canvas').getContext,\n\t    svgSupported: typeof SVGRect !== 'undefined',\n\t    // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n\t    // works on most browsers\n\t    // IE10/11 does not support touch event, and MS Edge supports them but not by\n\t    // default, so we dont check navigator.maxTouchPoints for them here.\n\t    touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n\t    // <http://caniuse.com/#search=pointer%20event>.\n\t    pointerEventsSupported: 'onpointerdown' in window // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n\t    // events currently. So we dont use that on other browsers unless tested sufficiently.\n\t    // Although IE 10 supports pointer event, it use old style and is different from the\n\t    // standard. So we exclude that. (IE 10 is hardly used on touch device)\n\t    && (browser.edge || browser.ie && browser.version >= 11)\n\t  };\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(6);\n\t\n\t/**\n\t * 圆环\n\t * @module zrender/graphic/shape/Ring\n\t */\n\tvar _default = Path.extend({\n\t  type: 'ring',\n\t  shape: {\n\t    cx: 0,\n\t    cy: 0,\n\t    r: 0,\n\t    r0: 0\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    var x = shape.cx;\n\t    var y = shape.cy;\n\t    var PI2 = Math.PI * 2;\n\t    ctx.moveTo(x + shape.r, y);\n\t    ctx.arc(x, y, shape.r, 0, PI2, false);\n\t    ctx.moveTo(x + shape.r0, y);\n\t    ctx.arc(x, y, shape.r0, 0, PI2, true);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(6);\n\t\n\tvar polyHelper = __webpack_require__(52);\n\t\n\t/**\n\t * 多边形\n\t * @module zrender/shape/Polygon\n\t */\n\tvar _default = Path.extend({\n\t  type: 'polygon',\n\t  shape: {\n\t    points: null,\n\t    smooth: false,\n\t    smoothConstraint: null\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    polyHelper.buildPath(ctx, shape, true);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar smoothSpline = __webpack_require__(53);\n\t\n\tvar smoothBezier = __webpack_require__(54);\n\t\n\tfunction buildPath(ctx, shape, closePath) {\n\t  var points = shape.points;\n\t  var smooth = shape.smooth;\n\t\n\t  if (points && points.length >= 2) {\n\t    if (smooth && smooth !== 'spline') {\n\t      var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);\n\t      ctx.moveTo(points[0][0], points[0][1]);\n\t      var len = points.length;\n\t\n\t      for (var i = 0; i < (closePath ? len : len - 1); i++) {\n\t        var cp1 = controlPoints[i * 2];\n\t        var cp2 = controlPoints[i * 2 + 1];\n\t        var p = points[(i + 1) % len];\n\t        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);\n\t      }\n\t    } else {\n\t      if (smooth === 'spline') {\n\t        points = smoothSpline(points, closePath);\n\t      }\n\t\n\t      ctx.moveTo(points[0][0], points[0][1]);\n\t\n\t      for (var i = 1, l = points.length; i < l; i++) {\n\t        ctx.lineTo(points[i][0], points[i][1]);\n\t      }\n\t    }\n\t\n\t    closePath && ctx.closePath();\n\t  }\n\t}\n\t\n\texports.buildPath = buildPath;\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _vector = __webpack_require__(14);\n\t\n\tvar v2Distance = _vector.distance;\n\t\n\t/**\n\t * Catmull-Rom spline 插值折线\n\t * @module zrender/shape/util/smoothSpline\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t/**\n\t * @inner\n\t */\n\tfunction interpolate(p0, p1, p2, p3, t, t2, t3) {\n\t  var v0 = (p2 - p0) * 0.5;\n\t  var v1 = (p3 - p1) * 0.5;\n\t  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n\t}\n\t/**\n\t * @alias module:zrender/shape/util/smoothSpline\n\t * @param {Array} points 线段顶点数组\n\t * @param {boolean} isLoop\n\t * @return {Array}\n\t */\n\t\n\t\n\tfunction _default(points, isLoop) {\n\t  var len = points.length;\n\t  var ret = [];\n\t  var distance = 0;\n\t\n\t  for (var i = 1; i < len; i++) {\n\t    distance += v2Distance(points[i - 1], points[i]);\n\t  }\n\t\n\t  var segs = distance / 2;\n\t  segs = segs < len ? len : segs;\n\t\n\t  for (var i = 0; i < segs; i++) {\n\t    var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n\t    var idx = Math.floor(pos);\n\t    var w = pos - idx;\n\t    var p0;\n\t    var p1 = points[idx % len];\n\t    var p2;\n\t    var p3;\n\t\n\t    if (!isLoop) {\n\t      p0 = points[idx === 0 ? idx : idx - 1];\n\t      p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n\t      p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n\t    } else {\n\t      p0 = points[(idx - 1 + len) % len];\n\t      p2 = points[(idx + 1) % len];\n\t      p3 = points[(idx + 2) % len];\n\t    }\n\t\n\t    var w2 = w * w;\n\t    var w3 = w * w2;\n\t    ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);\n\t  }\n\t\n\t  return ret;\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _vector = __webpack_require__(14);\n\t\n\tvar v2Min = _vector.min;\n\tvar v2Max = _vector.max;\n\tvar v2Scale = _vector.scale;\n\tvar v2Distance = _vector.distance;\n\tvar v2Add = _vector.add;\n\tvar v2Clone = _vector.clone;\n\tvar v2Sub = _vector.sub;\n\t\n\t/**\n\t * 贝塞尔平滑曲线\n\t * @module zrender/shape/util/smoothBezier\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t/**\n\t * 贝塞尔平滑曲线\n\t * @alias module:zrender/shape/util/smoothBezier\n\t * @param {Array} points 线段顶点数组\n\t * @param {number} smooth 平滑等级, 0-1\n\t * @param {boolean} isLoop\n\t * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n\t *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n\t *                           整个折线的包围盒做一个并集用来约束控制点。\n\t * @param {Array} 计算出来的控制点数组\n\t */\n\tfunction _default(points, smooth, isLoop, constraint) {\n\t  var cps = [];\n\t  var v = [];\n\t  var v1 = [];\n\t  var v2 = [];\n\t  var prevPoint;\n\t  var nextPoint;\n\t  var min, max;\n\t\n\t  if (constraint) {\n\t    min = [Infinity, Infinity];\n\t    max = [-Infinity, -Infinity];\n\t\n\t    for (var i = 0, len = points.length; i < len; i++) {\n\t      v2Min(min, min, points[i]);\n\t      v2Max(max, max, points[i]);\n\t    } // 与指定的包围盒做并集\n\t\n\t\n\t    v2Min(min, min, constraint[0]);\n\t    v2Max(max, max, constraint[1]);\n\t  }\n\t\n\t  for (var i = 0, len = points.length; i < len; i++) {\n\t    var point = points[i];\n\t\n\t    if (isLoop) {\n\t      prevPoint = points[i ? i - 1 : len - 1];\n\t      nextPoint = points[(i + 1) % len];\n\t    } else {\n\t      if (i === 0 || i === len - 1) {\n\t        cps.push(v2Clone(points[i]));\n\t        continue;\n\t      } else {\n\t        prevPoint = points[i - 1];\n\t        nextPoint = points[i + 1];\n\t      }\n\t    }\n\t\n\t    v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length\n\t\n\t    v2Scale(v, v, smooth);\n\t    var d0 = v2Distance(point, prevPoint);\n\t    var d1 = v2Distance(point, nextPoint);\n\t    var sum = d0 + d1;\n\t\n\t    if (sum !== 0) {\n\t      d0 /= sum;\n\t      d1 /= sum;\n\t    }\n\t\n\t    v2Scale(v1, v, -d0);\n\t    v2Scale(v2, v, d1);\n\t    var cp0 = v2Add([], point, v1);\n\t    var cp1 = v2Add([], point, v2);\n\t\n\t    if (constraint) {\n\t      v2Max(cp0, cp0, min);\n\t      v2Min(cp0, cp0, max);\n\t      v2Max(cp1, cp1, min);\n\t      v2Min(cp1, cp1, max);\n\t    }\n\t\n\t    cps.push(cp0);\n\t    cps.push(cp1);\n\t  }\n\t\n\t  if (isLoop) {\n\t    cps.push(cps.shift());\n\t  }\n\t\n\t  return cps;\n\t}\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(6);\n\t\n\tvar polyHelper = __webpack_require__(52);\n\t\n\t/**\n\t * @module zrender/graphic/shape/Polyline\n\t */\n\tvar _default = Path.extend({\n\t  type: 'polyline',\n\t  shape: {\n\t    points: null,\n\t    smooth: false,\n\t    smoothConstraint: null\n\t  },\n\t  style: {\n\t    stroke: '#000',\n\t    fill: null\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    polyHelper.buildPath(ctx, shape, false);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(6);\n\t\n\tvar roundRectHelper = __webpack_require__(28);\n\t\n\t/**\n\t * 矩形\n\t * @module zrender/graphic/shape/Rect\n\t */\n\tvar _default = Path.extend({\n\t  type: 'rect',\n\t  shape: {\n\t    // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n\t    // r缩写为1         相当于 [1, 1, 1, 1]\n\t    // r缩写为[1]       相当于 [1, 1, 1, 1]\n\t    // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n\t    // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n\t    r: 0,\n\t    x: 0,\n\t    y: 0,\n\t    width: 0,\n\t    height: 0\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    var x = shape.x;\n\t    var y = shape.y;\n\t    var width = shape.width;\n\t    var height = shape.height;\n\t\n\t    if (!shape.r) {\n\t      ctx.rect(x, y, width, height);\n\t    } else {\n\t      roundRectHelper.buildPath(ctx, shape);\n\t    }\n\t\n\t    ctx.closePath();\n\t    return;\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(6);\n\t\n\t/**\n\t * 直线\n\t * @module zrender/graphic/shape/Line\n\t */\n\tvar _default = Path.extend({\n\t  type: 'line',\n\t  shape: {\n\t    // Start point\n\t    x1: 0,\n\t    y1: 0,\n\t    // End point\n\t    x2: 0,\n\t    y2: 0,\n\t    percent: 1\n\t  },\n\t  style: {\n\t    stroke: '#000',\n\t    fill: null\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    var x1 = shape.x1;\n\t    var y1 = shape.y1;\n\t    var x2 = shape.x2;\n\t    var y2 = shape.y2;\n\t    var percent = shape.percent;\n\t\n\t    if (percent === 0) {\n\t      return;\n\t    }\n\t\n\t    ctx.moveTo(x1, y1);\n\t\n\t    if (percent < 1) {\n\t      x2 = x1 * (1 - percent) + x2 * percent;\n\t      y2 = y1 * (1 - percent) + y2 * percent;\n\t    }\n\t\n\t    ctx.lineTo(x2, y2);\n\t  },\n\t\n\t  /**\n\t   * Get point at percent\n\t   * @param  {number} percent\n\t   * @return {Array.<number>}\n\t   */\n\t  pointAt: function (p) {\n\t    var shape = this.shape;\n\t    return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(6);\n\t\n\tvar vec2 = __webpack_require__(14);\n\t\n\tvar _curve = __webpack_require__(30);\n\t\n\tvar quadraticSubdivide = _curve.quadraticSubdivide;\n\tvar cubicSubdivide = _curve.cubicSubdivide;\n\tvar quadraticAt = _curve.quadraticAt;\n\tvar cubicAt = _curve.cubicAt;\n\tvar quadraticDerivativeAt = _curve.quadraticDerivativeAt;\n\tvar cubicDerivativeAt = _curve.cubicDerivativeAt;\n\t\n\t/**\n\t * 贝塞尔曲线\n\t * @module zrender/shape/BezierCurve\n\t */\n\tvar out = [];\n\t\n\tfunction someVectorAt(shape, t, isTangent) {\n\t  var cpx2 = shape.cpx2;\n\t  var cpy2 = shape.cpy2;\n\t\n\t  if (cpx2 === null || cpy2 === null) {\n\t    return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];\n\t  } else {\n\t    return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];\n\t  }\n\t}\n\t\n\tvar _default = Path.extend({\n\t  type: 'bezier-curve',\n\t  shape: {\n\t    x1: 0,\n\t    y1: 0,\n\t    x2: 0,\n\t    y2: 0,\n\t    cpx1: 0,\n\t    cpy1: 0,\n\t    // cpx2: 0,\n\t    // cpy2: 0\n\t    // Curve show percent, for animating\n\t    percent: 1\n\t  },\n\t  style: {\n\t    stroke: '#000',\n\t    fill: null\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    var x1 = shape.x1;\n\t    var y1 = shape.y1;\n\t    var x2 = shape.x2;\n\t    var y2 = shape.y2;\n\t    var cpx1 = shape.cpx1;\n\t    var cpy1 = shape.cpy1;\n\t    var cpx2 = shape.cpx2;\n\t    var cpy2 = shape.cpy2;\n\t    var percent = shape.percent;\n\t\n\t    if (percent === 0) {\n\t      return;\n\t    }\n\t\n\t    ctx.moveTo(x1, y1);\n\t\n\t    if (cpx2 == null || cpy2 == null) {\n\t      if (percent < 1) {\n\t        quadraticSubdivide(x1, cpx1, x2, percent, out);\n\t        cpx1 = out[1];\n\t        x2 = out[2];\n\t        quadraticSubdivide(y1, cpy1, y2, percent, out);\n\t        cpy1 = out[1];\n\t        y2 = out[2];\n\t      }\n\t\n\t      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n\t    } else {\n\t      if (percent < 1) {\n\t        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n\t        cpx1 = out[1];\n\t        cpx2 = out[2];\n\t        x2 = out[3];\n\t        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n\t        cpy1 = out[1];\n\t        cpy2 = out[2];\n\t        y2 = out[3];\n\t      }\n\t\n\t      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Get point at percent\n\t   * @param  {number} t\n\t   * @return {Array.<number>}\n\t   */\n\t  pointAt: function (t) {\n\t    return someVectorAt(this.shape, t, false);\n\t  },\n\t\n\t  /**\n\t   * Get tangent at percent\n\t   * @param  {number} t\n\t   * @return {Array.<number>}\n\t   */\n\t  tangentAt: function (t) {\n\t    var p = someVectorAt(this.shape, t, true);\n\t    return vec2.normalize(p, p);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Path = __webpack_require__(6);\n\t\n\t/**\n\t * 圆弧\n\t * @module zrender/graphic/shape/Arc\n\t */\n\tvar _default = Path.extend({\n\t  type: 'arc',\n\t  shape: {\n\t    cx: 0,\n\t    cy: 0,\n\t    r: 0,\n\t    startAngle: 0,\n\t    endAngle: Math.PI * 2,\n\t    clockwise: true\n\t  },\n\t  style: {\n\t    stroke: '#000',\n\t    fill: null\n\t  },\n\t  buildPath: function (ctx, shape) {\n\t    var x = shape.cx;\n\t    var y = shape.cy;\n\t    var r = Math.max(shape.r, 0);\n\t    var startAngle = shape.startAngle;\n\t    var endAngle = shape.endAngle;\n\t    var clockwise = shape.clockwise;\n\t    var unitX = Math.cos(startAngle);\n\t    var unitY = Math.sin(startAngle);\n\t    ctx.moveTo(unitX * r + x, unitY * r + y);\n\t    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t  }\n\t});\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrUtil = __webpack_require__(4);\n\t\n\tvar Gradient = __webpack_require__(41);\n\t\n\t/**\n\t * x, y, x2, y2 are all percent from 0 to 1\n\t * @param {number} [x=0]\n\t * @param {number} [y=0]\n\t * @param {number} [x2=1]\n\t * @param {number} [y2=0]\n\t * @param {Array.<Object>} colorStops\n\t * @param {boolean} [globalCoord=false]\n\t */\n\tvar LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n\t  // Should do nothing more in this constructor. Because gradient can be\n\t  // declard by `color: {type: 'linear', colorStops: ...}`, where\n\t  // this constructor will not be called.\n\t  this.x = x == null ? 0 : x;\n\t  this.y = y == null ? 0 : y;\n\t  this.x2 = x2 == null ? 1 : x2;\n\t  this.y2 = y2 == null ? 0 : y2; // Can be cloned\n\t\n\t  this.type = 'linear'; // If use global coord\n\t\n\t  this.global = globalCoord || false;\n\t  Gradient.call(this, colorStops);\n\t};\n\t\n\tLinearGradient.prototype = {\n\t  constructor: LinearGradient\n\t};\n\tzrUtil.inherits(LinearGradient, Gradient);\n\tvar _default = LinearGradient;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrUtil = __webpack_require__(4);\n\t\n\tvar Gradient = __webpack_require__(41);\n\t\n\t/**\n\t * x, y, r are all percent from 0 to 1\n\t * @param {number} [x=0.5]\n\t * @param {number} [y=0.5]\n\t * @param {number} [r=0.5]\n\t * @param {Array.<Object>} [colorStops]\n\t * @param {boolean} [globalCoord=false]\n\t */\n\tvar RadialGradient = function (x, y, r, colorStops, globalCoord) {\n\t  // Should do nothing more in this constructor. Because gradient can be\n\t  // declard by `color: {type: 'radial', colorStops: ...}`, where\n\t  // this constructor will not be called.\n\t  this.x = x == null ? 0.5 : x;\n\t  this.y = y == null ? 0.5 : y;\n\t  this.r = r == null ? 0.5 : r; // Can be cloned\n\t\n\t  this.type = 'radial'; // If use global coord\n\t\n\t  this.global = globalCoord || false;\n\t  Gradient.call(this, colorStops);\n\t};\n\t\n\tRadialGradient.prototype = {\n\t  constructor: RadialGradient\n\t};\n\tzrUtil.inherits(RadialGradient, Gradient);\n\tvar _default = RadialGradient;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrUtil = __webpack_require__(4);\n\t\n\tvar Style = __webpack_require__(8);\n\t\n\tvar _vector = __webpack_require__(14);\n\t\n\tvar vec2Copy = _vector.copy;\n\t\n\t/**\n\t * States machine for managing graphic states\n\t */\n\t\n\t/**\n\t * @typedef {Object} IGraphicState\n\t * @property {number} [zlevel]\n\t * @property {number} [z]\n\t * @property {Array.<number>} {position}\n\t * @property {Array.<number>|number} {rotation}\n\t * @property {Array.<number>} {scale}\n\t * @property {Object} style\n\t *\n\t * @property {Function} onenter\n\t * @property {Function} onleave\n\t * @property {Function} ontransition\n\t * @property {Array.<IGraphicStateTransition|string>} transition\n\t *           Transition object or a string descriptor like '* 30 0 Linear'\n\t */\n\tvar transitionProperties = ['position', 'rotation', 'scale', 'style', 'shape'];\n\t/**\n\t * @module zrender/graphic/States~TransitionObject\n\t */\n\t\n\tvar TransitionObject = function (opts) {\n\t  if (typeof opts == 'string') {\n\t    this._fromStr(opts);\n\t  } else if (opts) {\n\t    opts.property && (this.property = opts.property);\n\t    opts.duration != null && (this.duration = opts.duration);\n\t    opts.easing && (this.easing = opts.easing);\n\t    opts.delay && (this.delay = opts.delay);\n\t  }\n\t\n\t  if (this.property !== '*') {\n\t    this.property = this.property.split(',');\n\t  } else {\n\t    this.property = transitionProperties;\n\t  }\n\t};\n\t\n\tTransitionObject.prototype = {\n\t  constructor: TransitionObject,\n\t\n\t  /**\n\t   * List of all transition properties. Splitted by comma. Must not have spaces in the string.\n\t   * e.g. 'position,style.color'. '*' will match all the valid properties.\n\t   * @type {string}\n\t   * @default *\n\t   */\n\t  property: '*',\n\t\n\t  /**\n\t   * @type {string}\n\t   * @default 'Linear'\n\t   */\n\t  easing: 'Linear',\n\t\n\t  /**\n\t   * @type {number}\n\t   * @default 'number'\n\t   */\n\t  duration: 500,\n\t\n\t  /**\n\t   * @type {number}\n\t   */\n\t  delay: 0,\n\t  _fromStr: function (str) {\n\t    var arr = str.split(/\\s+/g);\n\t    this.property = arr[0];\n\t    this.duration = +arr[1];\n\t    this.delay = +arr[2];\n\t    this.easing = arr[3];\n\t  }\n\t};\n\t/**\n\t * @alias module:zrender/graphic/States\n\t */\n\t\n\tvar GraphicStates = function (opts) {\n\t  opts = opts || {};\n\t  this._states = {};\n\t  /**\n\t   * Target element\n\t   * @type {zrender/graphic/Displayable|zrender/container/Group}\n\t   */\n\t\n\t  this._el = opts.el;\n\t  this._subStates = [];\n\t  this._transitionAnimators = [];\n\t\n\t  if (opts.initialState) {\n\t    this._initialState = opts.initialState;\n\t  }\n\t\n\t  var optsStates = opts.states;\n\t\n\t  if (optsStates) {\n\t    for (var name in optsStates) {\n\t      if (optsStates.hasOwnProperty(name)) {\n\t        var state = optsStates[name];\n\t\n\t        this._addState(name, state);\n\t      }\n\t    }\n\t  }\n\t\n\t  this.setState(this._initialState);\n\t};\n\t\n\tGraphicStates.prototype = {\n\t  constructor: GraphicStates,\n\t\n\t  /**\n\t   * All other state will be extended from initial state\n\t   * @type {string}\n\t   * @private\n\t   */\n\t  _initialState: 'normal',\n\t\n\t  /**\n\t   * Current state\n\t   * @type {string}\n\t   * @private\n\t   */\n\t  _currentState: '',\n\t  el: function () {\n\t    return this._el;\n\t  },\n\t  _addState: function (name, state) {\n\t    this._states[name] = state;\n\t\n\t    if (state.transition) {\n\t      state.transition = new TransitionObject(state.transition);\n\t    } // Extend from initial state\n\t\n\t\n\t    if (name !== this._initialState) {\n\t      this._extendFromInitial(state);\n\t    } else {\n\t      var el = this._el; // setState 的时候自带的 style 和 shape 都会被直接覆盖\n\t      // 所以这边先把自带的 style 和 shape 扩展到初始状态中\n\t\n\t      zrUtil.merge(state.style, el.style, false, false);\n\t\n\t      if (state.shape) {\n\t        zrUtil.merge(state.shape, el.shape, false, true);\n\t      } else {\n\t        state.shape = zrUtil.clone(el.shape, true);\n\t      }\n\t\n\t      for (var name in this._states) {\n\t        if (this._states.hasOwnProperty(name)) {\n\t          this._extendFromInitial(this._states[name]);\n\t        }\n\t      }\n\t    }\n\t  },\n\t  _extendFromInitial: function (state) {\n\t    var initialState = this._states[this._initialState];\n\t\n\t    if (initialState && state !== initialState) {\n\t      zrUtil.merge(state, initialState, false, true);\n\t    }\n\t  },\n\t  setState: function (name, silent) {\n\t    if (name === this._currentState && !this.transiting()) {\n\t      return;\n\t    }\n\t\n\t    var state = this._states[name];\n\t\n\t    if (state) {\n\t      this._stopTransition();\n\t\n\t      if (!silent) {\n\t        var prevState = this._states[this._currentState];\n\t\n\t        if (prevState) {\n\t          prevState.onleave && prevState.onleave.call(this);\n\t        }\n\t\n\t        state.onenter && state.onenter.call(this);\n\t      }\n\t\n\t      this._currentState = name;\n\t\n\t      if (this._el) {\n\t        var el = this._el; // Setting attributes\n\t\n\t        if (state.zlevel != null) {\n\t          el.zlevel = state.zlevel;\n\t        }\n\t\n\t        if (state.z != null) {\n\t          el.z = state.z;\n\t        } // SRT\n\t\n\t\n\t        state.position && vec2Copy(el.position, state.position);\n\t        state.scale && vec2Copy(el.scale, state.scale);\n\t\n\t        if (state.rotation != null) {\n\t          el.rotation = state.rotation;\n\t        } // Style\n\t\n\t\n\t        if (state.style) {\n\t          var initialState = this._states[this._initialState];\n\t          el.style = new Style();\n\t\n\t          if (initialState) {\n\t            el.style.extendFrom(initialState.style, false);\n\t          }\n\t\n\t          if ( // Not initial state\n\t          name != this._initialState // Not copied from initial state in _extendFromInitial method\n\t          && initialState.style !== state.style) {\n\t            el.style.extendFrom(state.style, true);\n\t          }\n\t        }\n\t\n\t        if (state.shape) {\n\t          el.shape = zrUtil.clone(state.shape, true);\n\t        }\n\t\n\t        el.dirty();\n\t      }\n\t    }\n\t\n\t    for (var i = 0; i < this._subStates.length; i++) {\n\t      this._subStates.setState(name);\n\t    }\n\t  },\n\t  getState: function () {\n\t    return this._currentState;\n\t  },\n\t  transitionState: function (target, done) {\n\t    if (target === this._currentState && !this.transiting()) {\n\t      return;\n\t    }\n\t\n\t    var state = this._states[target];\n\t    var styleShapeReg = /$[style|shape]\\./;\n\t    var self = this; // Animation 去重\n\t\n\t    var propPathMap = {};\n\t\n\t    if (state) {\n\t      self._stopTransition();\n\t\n\t      var el = self._el;\n\t\n\t      if (state.transition && el && el.__zr) {\n\t        // El can be animated\n\t        var transitionCfg = state.transition;\n\t        var property = transitionCfg.property;\n\t        var animatingCount = 0;\n\t\n\t        var animationDone = function () {\n\t          animatingCount--;\n\t\n\t          if (animatingCount === 0) {\n\t            self.setState(target);\n\t            done && done();\n\t          }\n\t        };\n\t\n\t        for (var i = 0; i < property.length; i++) {\n\t          var propName = property[i]; // Animating all the properties in style or shape\n\t\n\t          if (propName === 'style' || propName === 'shape') {\n\t            if (state[propName]) {\n\t              for (var key in state[propName]) {\n\t                if (!state[propName].hasOwnProperty(key)) {\n\t                  continue;\n\t                }\n\t\n\t                var path = propName + '.' + key;\n\t\n\t                if (propPathMap[path]) {\n\t                  continue;\n\t                }\n\t\n\t                propPathMap[path] = 1;\n\t                animatingCount += self._animProp(state, propName, key, transitionCfg, animationDone);\n\t              }\n\t            }\n\t          } else {\n\t            if (propPathMap[propName]) {\n\t              continue;\n\t            }\n\t\n\t            propPathMap[propName] = 1; // Animating particular property in style or style\n\t\n\t            if (propName.match(styleShapeReg)) {\n\t              // remove 'style.', 'shape.' prefix\n\t              var subProp = propName.slice(0, 5);\n\t              propName = propName.slice(6);\n\t              animatingCount += self._animProp(state, subProp, propName, transitionCfg, animationDone);\n\t            } else {\n\t              animatingCount += self._animProp(state, '', propName, transitionCfg, animationDone);\n\t            }\n\t          }\n\t        } // No transition properties\n\t\n\t\n\t        if (animatingCount === 0) {\n\t          self.setState(target);\n\t          done && done();\n\t        }\n\t      } else {\n\t        self.setState(target);\n\t        done && done();\n\t      }\n\t    }\n\t\n\t    var subStates = self._subStates;\n\t\n\t    for (var i = 0; i < subStates.length; i++) {\n\t      subStates.transitionState(target);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Do transition animation of particular property\n\t   * @param {Object} state\n\t   * @param {string} subPropKey\n\t   * @param {string} key\n\t   * @param {Object} transitionCfg\n\t   * @param {Function} done\n\t   * @private\n\t   */\n\t  _animProp: function (state, subPropKey, key, transitionCfg, done) {\n\t    var el = this._el;\n\t    var stateObj = subPropKey ? state[subPropKey] : state;\n\t    var elObj = subPropKey ? el[subPropKey] : el;\n\t    var availableProp = stateObj && key in stateObj && elObj && key in elObj;\n\t    var transitionAnimators = this._transitionAnimators;\n\t\n\t    if (availableProp) {\n\t      var obj = {};\n\t\n\t      if (stateObj[key] === elObj[key]) {\n\t        return 0;\n\t      }\n\t\n\t      obj[key] = stateObj[key];\n\t      var animator = el.animate(subPropKey).when(transitionCfg.duration, obj).delay(transitionCfg.dealy).done(function () {\n\t        var idx = zrUtil.indexOf(transitionAnimators, 1);\n\t\n\t        if (idx > 0) {\n\t          transitionAnimators.splice(idx, 1);\n\t        }\n\t\n\t        done();\n\t      }).start(transitionCfg.easing);\n\t      transitionAnimators.push(animator);\n\t      return 1;\n\t    }\n\t\n\t    return 0;\n\t  },\n\t  _stopTransition: function () {\n\t    var transitionAnimators = this._transitionAnimators;\n\t\n\t    for (var i = 0; i < transitionAnimators.length; i++) {\n\t      transitionAnimators[i].stop();\n\t    }\n\t\n\t    transitionAnimators.length = 0;\n\t  },\n\t  transiting: function () {\n\t    return this._transitionAnimators.length > 0;\n\t  },\n\t  addSubStates: function (states) {\n\t    this._subStates.push(states);\n\t  },\n\t  removeSubStates: function (states) {\n\t    var idx = zrUtil.indexOf(this._subStates, states);\n\t\n\t    if (idx >= 0) {\n\t      this._subStates.splice(states, 1);\n\t    }\n\t  }\n\t};\n\tvar _default = GraphicStates;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 工具方法类\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var Point = __webpack_require__(64);\r\n\t    var Line = __webpack_require__(65);\r\n\t    var BoundingRect = __webpack_require__(26);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    /**\r\n\t     * 构造类继承关系\r\n\t     *\r\n\t     * @param {Function} clazz 源类\r\n\t     * @param {Function} baseClazz 基类\r\n\t     */\r\n\t    function inherits(clazz, baseClazz) {\r\n\t        var clazzPrototype = clazz.prototype;\r\n\t\r\n\t        function F() {}\r\n\t        F.prototype = baseClazz.prototype;\r\n\t        clazz.prototype = new F();\r\n\t\r\n\t        for (var prop in clazzPrototype) {\r\n\t            clazz.prototype[prop] = clazzPrototype[prop];\r\n\t        }\r\n\t        clazz.prototype.constructor = clazz;\r\n\t        clazz.superClass = baseClazz;\r\n\t    }\r\n\t\r\n\t    function getUUID() {\r\n\t        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),\r\n\t            uuid = new Array(36),\r\n\t            rnd = 0,\r\n\t            r;\r\n\t        for (var i = 0; i < 36; i++) {\r\n\t            if (i == 8 || i == 13 || i == 18 || i == 23) {\r\n\t                uuid[i] = '-';\r\n\t            } else if (i == 14) {\r\n\t                uuid[i] = '4';\r\n\t            } else {\r\n\t                if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;\r\n\t                r = rnd & 0xf;\r\n\t                rnd = rnd >> 4;\r\n\t                uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\r\n\t            }\r\n\t        }\r\n\t        return \"sid-\" + uuid.join('');\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 计算两点之间的距离\r\n\t     *@param {Point} p1 - first {Point}\r\n\t     *@param {Point} p2 - second {Point}\r\n\t     *@return {Number} - the distance between those 2 points. It is always positive.\r\n\t     **/\r\n\t    function distance(p1, p2) {\r\n\t        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 返回一条折线 最长的两个点\r\n\t     * @param  {[type]} points [description]\r\n\t     * @return {[type]}        [description]\r\n\t     */\r\n\t    function getMaxLineLength(points) {\r\n\t        var m = distance(points[0], points[1]);\r\n\t        var result = [points[0], points[1]];\r\n\t        for (var i = 1; i < points.length - 1; i++) {\r\n\t\r\n\t            if (m < distance(points[i], points[i + 1])) {\r\n\t                m = distance(points[i], points[i + 1])\r\n\t                result = [points[i], points[i + 1]];\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return result;\r\n\t    }\r\n\t\r\n\t    /**Returns the length of a Polyline that would be created with a set of points\r\n\t     *@param {Array} v - an {Array} of {Points}\r\n\t     *@return {Number} - a positive number equal with total length*/\r\n\t    function getPolylineLength(v) {\r\n\t        var l = 0;\r\n\t        for (var i = 0; i < v.length - 1; i++) {\r\n\t            l += distance(v[i], v[i + 1]);\r\n\t        }\r\n\t\r\n\t        return l;\r\n\t    }\r\n\t\r\n\t\r\n\t    /**Returns the max of a vector\r\n\t     *@param {Array} v - vector of {Number}s\r\n\t     *@return {Number} - the maximum number from the vector or NaN if vector is empty\r\n\t     **/\r\n\t    function max(v) {\r\n\t        if (v.lenght == 0) {\r\n\t            return NaN;\r\n\t        } else {\r\n\t            var m = v[0];\r\n\t            for (var i = 0; i < v.length; i++) {\r\n\t                if (m < v[i]) {\r\n\t                    m = v[i];\r\n\t                }\r\n\t            }\r\n\t\r\n\t            return m;\r\n\t        }\r\n\t    }\r\n\t\r\n\t\r\n\t    /**Returns the min of a vector\r\n\t     *@param {Array} v - vector of {Number}s\r\n\t     *@return {Number} - the minimum number from the vector or NaN if vector is empty\r\n\t     *@author alex@scriptoid.com\r\n\t     **/\r\n\t    function min(v) {\r\n\t        if (v.lenght == 0) {\r\n\t            return NaN;\r\n\t        } else {\r\n\t            var m = v[0];\r\n\t            for (var i = 0; i < v.length; i++) {\r\n\t                if (m > v[i]) {\r\n\t                    m = v[i];\r\n\t                }\r\n\t            }\r\n\t\r\n\t            return m;\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 判断 点数组 是否正交直线路径\r\n\t     *Tests if a vector of points is an orthogonal path (moving in multiples of 90 degrees)\r\n\t     *@param {Array} v - an {Array} of {Point}s\r\n\t     *@return {Boolean} - true if path is valid, false otherwise\r\n\t     **/\r\n\t    function orthogonalPath(v) {\r\n\t        if (v.length <= 1) {\r\n\t            return true;\r\n\t        }\r\n\t\r\n\t        for (var i = 0; i < v.length - 1; i++) {\r\n\t            if (v[i].x != v[i + 1].x && v[i].y != v[i + 1].y) {\r\n\t                return false;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return true;\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     *Test to see if 2 {Line}s intersects. They are considered finite segments\r\n\t     *and not the infinite lines from geometry\r\n\t     *@param {Line} l1 - fist line/segment\r\n\t     *@param {Line} l2 - last line/segment\r\n\t     *@return {Boolean} true - if the lines intersect or false if not\r\n\t     **/\r\n\t    function lineIntersectsLine(l1, l2) {\r\n\t        // check for two vertical lines\r\n\t        if (l1.startPoint.x == l1.endPoint.x && l2.startPoint.x == l2.endPoint.x) {\r\n\t            return l1.startPoint.x == l2.startPoint.x ? // if 'infinite 'lines do coincide,\r\n\t                // then check segment bounds for overlapping\r\n\t                l1.contains(l2.startPoint.x, l2.startPoint.y) ||\r\n\t                l1.contains(l2.endPoint.x, l2.endPoint.y) :\r\n\t                // lines are paralel\r\n\t                false;\r\n\t        }\r\n\t        // if one line is vertical, and another line is not vertical\r\n\t        else if (l1.startPoint.x == l1.endPoint.x || l2.startPoint.x == l2.endPoint.x) {\r\n\t            // let assume l2 is vertical, otherwise exchange them\r\n\t            if (l1.startPoint.x == l1.endPoint.x) {\r\n\t                var l = l1;\r\n\t                l1 = l2;\r\n\t                l2 = l;\r\n\t            }\r\n\t            // finding intersection of 'infinite' lines\r\n\t            // equation of the first line is y = ax + b, second: x = c\r\n\t            var a = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);\r\n\t            var b = l1.startPoint.y - a * l1.startPoint.x;\r\n\t            var x0 = l2.startPoint.x;\r\n\t            var y0 = a * x0 + b;\r\n\t            return l1.contains(x0, y0) && l2.contains(x0, y0);\r\n\t        }\r\n\t\r\n\t        // check normal case - both lines are not vertical\r\n\t        else {\r\n\t            //line equation is : y = a*x + b, b = y - a * x\r\n\t            var a1 = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);\r\n\t            var b1 = l1.startPoint.y - a1 * l1.startPoint.x;\r\n\t\r\n\t            var a2 = (l2.endPoint.y - l2.startPoint.y) / (l2.endPoint.x - l2.startPoint.x);\r\n\t            var b2 = l2.startPoint.y - a2 * l2.startPoint.x;\r\n\t\r\n\t            if (a1 == a2) { //paralel lines\r\n\t                return b1 == b2 ?\r\n\t                    // for coincide lines, check for segment bounds overlapping\r\n\t                    l1.contains(l2.startPoint.x, l2.startPoint.y) || l1.contains(l2.endPoint.x, l2.endPoint.y) :\r\n\t                    // not coincide paralel lines have no chance to intersect\r\n\t                    false;\r\n\t            } else { //usual case - non paralel, the 'infinite' lines intersects...we only need to know if inside the segment\r\n\t\r\n\t                /*\r\n\t                 * if one of the lines are vertical, then x0 is equal to their x,\r\n\t                 * otherwise:\r\n\t                 * y1 = a1 * x + b1\r\n\t                 * y2 = a2 * x + b2\r\n\t                 * => x0 = (b2 - b1) / (a1 - a2)\r\n\t                 * => y0 = a1 * x0 + b1\r\n\t                 **/\r\n\t                x0 = (b2 - b1) / (a1 - a2);\r\n\t                y0 = a1 * x0 + b1;\r\n\t                return l1.contains(x0, y0) && l2.contains(x0, y0);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     *Tests if a a polyline defined by a set of points intersects a rectangle\r\n\t     *@param {Array} points - and {Array} of {Point}s\r\n\t     *@param {Array} bounds - the bounds of the rectangle defined by (x1, y1, x2, y2)\r\n\t     *@param {Boolean} closedPolyline - incase polyline is closed figure then true, else false\r\n\t     *\r\n\t     *@return true - if line intersects the rectangle, false - if not\r\n\t     **/\r\n\t    function polylineIntersectsRectangle(points, bounds, closedPolyline) {\r\n\t\r\n\t\r\n\t        //get the 4 lines/segments represented by the bounds\r\n\t        var lines = [];\r\n\t        lines.push(new Line(new Point(bounds[0], bounds[1]), new Point(bounds[2], bounds[1])));\r\n\t        lines.push(new Line(new Point(bounds[2], bounds[1]), new Point(bounds[2], bounds[3])));\r\n\t        lines.push(new Line(new Point(bounds[2], bounds[3]), new Point(bounds[0], bounds[3])));\r\n\t        lines.push(new Line(new Point(bounds[0], bounds[3]), new Point(bounds[0], bounds[1])));\r\n\t\r\n\t        for (var k = 0; k < points.length - 1; k++) {\r\n\t            //create a line out of each 2 consecutive points\r\n\t            var tempLine = new Line(points[k], points[k + 1]);\r\n\t\r\n\t            //see if that line intersect any of the line on bounds border\r\n\t            for (var i = 0; i < lines.length; i++) {\r\n\t                if (lineIntersectsLine(tempLine, lines[i])) {\r\n\t                    return true;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        //check the closed figure - that is last point connected to the first\r\n\t        if (closedPolyline) {\r\n\t            //create a line out of each 2 consecutive points\r\n\t            var tempLine1 = new Line(points[points.length - 1], points[0]);\r\n\t\r\n\t            //see if that line intersect any of the line on bounds border\r\n\t            for (var j = 0; j < lines.length; j++) {\r\n\t                if (lineIntersectsLine(tempLine1, lines[j])) {\r\n\t                    return true;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return false;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 计算路径的分数\r\n\t     * Score a ortogonal path made out of Points\r\n\t     *Iterates over a set of points (minimum 3)\r\n\t     *For each 3 points (i, i+1, i+2) :\r\n\t     *  - if the 3rd one is after the 2nd on the same line we add +1\r\n\t     *  - if the 3rd is up or down related to the 2nd we do not do anything +0\r\n\t     *  - if the 3rd goes back we imediatelly return -1\r\n\t     *@param {Array} v - an array of {Point}s\r\n\t     *@return {Number} - -1 if the path is wrong (goes back) or something >= 0 if is fine\r\n\t     *  The bigger the number the smooth the path is\r\n\t     **/\r\n\t    function scorePath(v) {\r\n\t        if (v.length <= 2) {\r\n\t            return -1;\r\n\t        }\r\n\t\r\n\t        var score = 0;\r\n\t        for (var i = 1; i < v.length - 1; i++) {\r\n\t            if (v[i - 1].x == v[i].x && v[i].x == v[i + 1].x) { //on the same vertical\r\n\t                if (signum(v[i + 1].y - v[i].y) == signum(v[i].y - v[i - 1].y)) { //same direction\r\n\t                    score++;\r\n\t                } else { //going back - no good\r\n\t                    return -1;\r\n\t                }\r\n\t            } else if (v[i - 1].y == v[i].y && v[i].y == v[i + 1].y) { //on the same horizontal\r\n\t                if (signum(v[i + 1].x - v[i].x) == signum(v[i].x - v[i - 1].x)) { //same direction\r\n\t                    score++;\r\n\t                } else { //going back - no good\r\n\t                    return -1;\r\n\t                }\r\n\t            } else { //not on same vertical nor horizontal\r\n\t                score--;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return score;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 返回数字符号（+ -)\r\n\t     * Returns the sign of a number\r\n\t     *@param {Number} x - the number\r\n\t     *@returns {Number}\r\n\t     *@see <a href=\"http://en.wikipedia.org/wiki/Sign_function\">http://en.wikipedia.org/wiki/Sign_function</a>\r\n\t     **/\r\n\t    function signum(x) {\r\n\t        if (x > 0)\r\n\t            return 1;\r\n\t        else if (x < 0)\r\n\t            return -1;\r\n\t        else\r\n\t            return 0;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 判断 点数组 是不是有效路径（没有回路）\r\n\t     *Tests if a vector of points is a valid path (not going back)\r\n\t     *There are a few problems here. If you have p1, p2, p3 and p4 and p2 = p3 you need to ignore that\r\n\t     *@param {Array} v - an {Array} of {Point}s\r\n\t     *@return {Boolean} - true if path is valid, false otherwise\r\n\t     **/\r\n\t    function forwardPath(v) {\r\n\t        if (v.length <= 2) {\r\n\t            return true;\r\n\t        }\r\n\t\r\n\t        for (var i = 0; i < v.length - 2; i++) {\r\n\t            if (v[i].x == v[i + 1].x && v[i + 1].x == v[i + 2].x) { //on the same vertical\r\n\t                if (signum(v[i + 1].y - v[i].y) != 0) { //test only we have a progressing path\r\n\t                    if (signum(v[i + 1].y - v[i].y) == -1 * signum(v[i + 2].y - v[i + 1].y)) { //going back (ignore zero)\r\n\t                        return false;\r\n\t                    }\r\n\t                }\r\n\t            } else if (v[i].y == v[i + 1].y && v[i + 1].y == v[i + 2].y) { //on the same horizontal\r\n\t                if (signum(v[i + 1].x - v[i].x) != 0) { //test only we have a progressing path\r\n\t                    if (signum(v[i + 1].x - v[i].x) == -1 * signum(v[i + 2].x - v[i + 1].x)) { //going back (ignore zero)\r\n\t                        return false;\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return true;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 将[x:0,y:0]转化为[0, 0]  给zrender使用\r\n\t     * @param  {[type]} points [description]\r\n\t     * @param  {[type]} isRevert [description]\r\n\t     * @return {[type]}        [description]\r\n\t     */\r\n\t    function traslatePoints(points, isRevert) {\r\n\t        var newPoints = [];\r\n\t        if (isRevert) {\r\n\t            for (var i = 0; i < points.length; i++) {\r\n\t                var point = points[i];\r\n\t                newPoints.push(new Point(point[0], point[1]));\r\n\t            }\r\n\t            return newPoints;\r\n\t        } else {\r\n\t            for (var j = 0; j < points.length; j++) {\r\n\t                var point1 = points[j];\r\n\t                newPoints.push([point1.x, point1.y]);\r\n\t            }\r\n\t            return newPoints;\r\n\t        }\r\n\t\r\n\t\r\n\t    }\r\n\t\r\n\t    function rotationMatrix(angle) {\r\n\t        var mReturn = [\r\n\t            [Math.cos(angle), -Math.sin(angle), 0],\r\n\t            [Math.sin(angle), Math.cos(angle), 0],\r\n\t            [0, 0, 1]\r\n\t        ];\r\n\t        return mReturn;\r\n\t    }\r\n\t\r\n\t    function translationMatrix(dx, dy) {\r\n\t        return [\r\n\t            [1, 0, dx],\r\n\t            [0, 1, dy],\r\n\t            [0, 0, 1]\r\n\t        ];\r\n\t    }\r\n\t\r\n\t    function scaleMatrix(sx, sy) {\r\n\t        if (sy == null) {\r\n\t            sy = sx;\r\n\t        }\r\n\t        return [\r\n\t            [sx, 0, 0],\r\n\t            [0, sy, 0],\r\n\t            [0, 0, 1]\r\n\t        ];\r\n\t    }\r\n\t\r\n\t    /** It will return the end point of a line on a given angle (clockwise).\r\n\t     * @param {Point} startPoint - the start of the line\r\n\t     * @param {Number} length - the length of the line\r\n\t     * @param {Number} angle - the angle of the line in radians\r\n\t     * @return {Point} - the endPoint of the line\r\n\t     */\r\n\t    function getEndPoint(startPoint, length, angle) {\r\n\t        var endPoint = startPoint.clone();\r\n\t        endPoint.transform(translationMatrix(-startPoint.x, -startPoint.y));\r\n\t        endPoint.y -= length;\r\n\t        endPoint.transform(rotationMatrix(angle));\r\n\t        endPoint.transform(translationMatrix(startPoint.x, startPoint.y));\r\n\t        return endPoint;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 获取获取两个图形的外面四个连接点\r\n\t     * @param  {[type]} node [description]\r\n\t     * @return {[type]}      [description]\r\n\t     */\r\n\t    function getConnectorPoints(node) {\r\n\t        return {\r\n\t            left: new Point(node.x, node.y + node.height / 2), //矩形 左中的位置\r\n\t            top: new Point(node.x + node.width / 2, node.y), //矩形 上中的位置\r\n\t            right: new Point(node.x + node.width, node.y + node.height / 2), //矩形 右中的位置\r\n\t            bottom: new Point(node.x + node.width / 2, node.y + node.height), //矩形 下中的位置\r\n\t            center: new Point(node.x + node.width / 2, node.y + node.height / 2) //中间位置\r\n\t\r\n\t        };\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 获取获取两个图形的外面四个连接点\r\n\t     * @param  {[type]} node [description]\r\n\t     * @return {[type]}      [description]\r\n\t     */\r\n\t    function getSoltPoints(node) {\r\n\t        return [\r\n\t            //top\r\n\t            [Math.round(node.getRect().width / 3 /10)*10, 0 ],\r\n\t            [Math.round(2*node.getRect().width / 3 /10)*10, 0 ],\r\n\t            //right\r\n\t            [node.getRect().width, Math.round(node.getRect().height / 3 /10)*10 ],\r\n\t            [node.getRect().width, Math.round(2*node.getRect().height / 3 /10)*10 ],\r\n\t            //bottom\r\n\t            [Math.round(node.getRect().width / 3 /10)*10, node.getRect().height ],\r\n\t            [Math.round(2*node.getRect().width / 3 /10)*10, node.getRect().height ],\r\n\t            //left\r\n\t            [0, Math.round(node.getRect().height / 3 /10)*10 ],\r\n\t            [0, Math.round(2*node.getRect().height / 3 /10)*10 ]\r\n\t\r\n\t        ]\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 计算 p1 p2两点所连接的直线的角度\r\n\t     * @param  {[type]} p1 [description]\r\n\t     * @param  {[type]} p2 [description]\r\n\t     * @return {[type]}    [description]\r\n\t     */\r\n\t    function tangentRotation(p1, p2) {\r\n\t        return -Math.PI / 2 - Math.atan2(\r\n\t            p2.y - p1.y, p2.x - p1.x\r\n\t        );\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 判断3点是否在一条直线上\r\n\t     * Tests if 3 points are coliniar with matrix determinants.\r\n\t     * If the determinat of matrix\r\n\t     * /         \\\r\n\t     * | x1 y1 1 |\r\n\t     * | x2 y2 1 |\r\n\t     * | x3 y3 1 |\r\n\t     * \\         /\r\n\t     * is zero it means that the points are colinear\r\n\t     *@param {Point} p1 - first point\r\n\t     *@param {Point} p2 - second point\r\n\t     *@param {Point} p3 - third point\r\n\t     * @param {Number} precission\r\n\t     *@return {Boolean} - true if coliniar and false if not\r\n\t     *@author Alex\r\n\t     *@see http://en.wikipedia.org/wiki/Determinant\r\n\t     *@see https://people.richland.edu/james/lecture/m116/matrices/applications.html\r\n\t     **/\r\n\t    function collinearity(p1, p2, p3, precission) {\r\n\t        var determinant = (p1.x * p2.y + p1.y * p3.x + p2.x * p3.y) - (p2.y * p3.x + p1.y * p2.x + p1.x * p3.y);\r\n\t\r\n\t        if (precission) {\r\n\t            return Math.abs(determinant) <= precission;\r\n\t        } else {\r\n\t            return determinant === 0;\r\n\t        }\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 四舍五入 保存decimals的小数\r\n\t     **/\r\n\t    function enhancedRound(number, decimals) {\r\n\t        return Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 获取两点之间的长度\r\n\t     **/\r\n\t    function getLength(startPoint, endPoint) {\r\n\t        return Math.sqrt(Math.pow(startPoint.x - endPoint.x, 2) + Math.pow(startPoint.y - endPoint.y, 2));\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 获取角度\r\n\t     * @param  {[type]} centerPoint  [description]\r\n\t     * @param  {[type]} outsidePoint [description]\r\n\t     * @param  {[type]} round        [description]\r\n\t     * @return {[type]}              [description]\r\n\t     */\r\n\t    function getAngle(centerPoint, outsidePoint, round) {\r\n\t        centerPoint.x = enhancedRound(centerPoint.x, 5);\r\n\t        centerPoint.y = enhancedRound(centerPoint.y, 5);\r\n\t        outsidePoint.x = enhancedRound(outsidePoint.x, 5);\r\n\t        outsidePoint.y = enhancedRound(outsidePoint.y, 5);\r\n\t        var angle = Math.atan((outsidePoint.x - centerPoint.x) / (outsidePoint.y - centerPoint.y));\r\n\t        angle = -angle;\r\n\t\r\n\t        //endAngle+=90;\r\n\t        if (outsidePoint.x >= centerPoint.x && outsidePoint.y >= centerPoint.y) {\r\n\t            angle += Math.PI;\r\n\t        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y >= centerPoint.y) {\r\n\t            angle += Math.PI;\r\n\t        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y <= centerPoint.y) {\r\n\t            angle += Math.PI * 2;\r\n\t        }\r\n\t        while (angle >= Math.PI * 2) {\r\n\t            angle -= Math.PI * 2;\r\n\t        }\r\n\t        if (isNaN(angle)) { //Nan\r\n\t            angle = 0; //we are at center point;\r\n\t        }\r\n\t        if (round) {\r\n\t            angle = Math.round(angle / round) * round\r\n\t        }\r\n\t        return angle;\r\n\t    }\r\n\t\r\n\t    function getRect(node, isCalcParent) {\r\n\t        var boundingRect = node.getBoundingRect();\r\n\t        //创建最小包围盒虚线\r\n\t        var points = [];\r\n\t        points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n\t        points[1] = [boundingRect.width / 2, -boundingRect.height / 2];\r\n\t        points[2] = [boundingRect.width / 2, boundingRect.height / 2];\r\n\t        points[3] = [-boundingRect.width / 2, boundingRect.height / 2];\r\n\t        points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n\t\r\n\t        var positionX = node.position[0];\r\n\t        var positionY = node.position[1];\r\n\t        //这里要循环判断一把 有没有父节点 并且父节点不是根节点 然后进行相加\r\n\t        if (node.parent && node.parent.type === \"GroupNode\" && isCalcParent) {\r\n\t            positionX = positionX + node.parent.position[0];\r\n\t            positionY = positionY + node.parent.position[1];\r\n\t        }\r\n\t\r\n\t        var boundRect = new BoundingRect(\r\n\t                Number(positionX + boundingRect.x),   //注: 因事件为圆形  所以 x y 为圆心的位置  包围矩形要减去宽度一半\r\n\t                Number(positionY + boundingRect.y),\r\n\t                Number(boundingRect.width),\r\n\t                Number(boundingRect.height)\r\n\t            );\r\n\t        //中心点\r\n\t        var cx = Number(positionX) + Number(boundingRect.width) / 2 + Number(boundingRect.x);\r\n\t        var cy = Number(positionY) + Number(boundingRect.height) / 2 + Number(boundingRect.y);\r\n\t        return {\r\n\t            x: Number(cx),\r\n\t            y: Number(cy),\r\n\t            width: Number(boundingRect.width),\r\n\t            height: Number(boundingRect.height),\r\n\t            points: points,\r\n\t            boundingRect: boundRect\r\n\t        };\r\n\t    }\r\n\t\r\n\t    var StackedMap = {\r\n\t        createNew: function() {\r\n\t            var stack = [];\r\n\t\r\n\t            return {\r\n\t                add: function(key, value) {\r\n\t                    var arrKey = this.get(key);\r\n\t                    arrKey.push(value)\r\n\t\r\n\t                },\r\n\t                get: function(key) {\r\n\t                    for (var i = 0; i < stack.length; i++) {\r\n\t                        if (key == stack[i].key) {\r\n\t                            return stack[i].value;\r\n\t                        }\r\n\t                    }\r\n\t                    //如果没有找到的话，则创建一个新的数组\r\n\t                    var value = [];\r\n\t                    stack.push({ key: key, value: value });\r\n\t                    return value;\r\n\t                },\r\n\t                keys: function() {\r\n\t                    var keys = [];\r\n\t                    for (var i = 0; i < stack.length; i++) {\r\n\t                        keys.push(stack[i].key);\r\n\t                    }\r\n\t                    return keys;\r\n\t                },\r\n\t                top: function() {\r\n\t                    return stack[stack.length - 1];\r\n\t                },\r\n\t                remove: function(key) {\r\n\t                    var idx = -1;\r\n\t                    for (var i = 0; i < stack.length; i++) {\r\n\t                        if (key == stack[i].key) {\r\n\t                            idx = i;\r\n\t                            break;\r\n\t                        }\r\n\t                    }\r\n\t                    return stack.splice(idx, 1)[0];\r\n\t                },\r\n\t                removeItem: function(key, item) {\r\n\t                    var arrKey = this.get(key);\r\n\t                    var index = zrUtil.indexOf(arrKey, item);\r\n\t                    arrKey.splice(index, 1);\r\n\t\r\n\t                },\r\n\t                removeTop: function() {\r\n\t                    return stack.splice(stack.length - 1, 1)[0];\r\n\t                },\r\n\t                length: function() {\r\n\t                    return stack.length;\r\n\t                },\r\n\t                clear: function() {\r\n\t                    stack.splice(0, stack.length);\r\n\t                }\r\n\t            };\r\n\t        }\r\n\t    };\r\n\t\r\n\t    function randomColor() {\r\n\t        var arrHex = [\"0\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\"],\r\n\t            strHex = \"#\",\r\n\t            index;\r\n\t        for (var i = 0; i < 6; i++) {\r\n\t            index = Math.round(Math.random() * 15);\r\n\t            strHex += arrHex[index];\r\n\t        }\r\n\t        return strHex;\r\n\t    }\r\n\t\r\n\t    function isUndefined(obj) {\r\n\t        return obj === void 0;\r\n\t    }\r\n\t\r\n\t    function collinearReduction (v) {\r\n\t        var r = [];\r\n\t\r\n\t        if(v.length < 3){\r\n\t            return Point.cloneArray(v);\r\n\t        }\r\n\t\r\n\t        r.push( v[0].clone() );\r\n\t        for(var i=1; i < v.length-1; i++){\r\n\t            if( (v[i-1].x == v[i].x && v[i].x == v[i+1].x)  ||  (v[i-1].y == v[i].y && v[i].y == v[i+1].y) )\r\n\t            {\r\n\t                continue;\r\n\t            }\r\n\t            else{\r\n\t                r.push( v[i].clone() );\r\n\t            }\r\n\t        }\r\n\t        r.push( v[v.length-1].clone() );\r\n\t\r\n\t        return r;\r\n\t    }\r\n\t\r\n\t    // By default, Underscore uses ERB-style template delimiters, change the\r\n\t    // following template settings to use alternative delimiters.\r\n\t    var templateSettings = {\r\n\t        evaluate: /<%([\\s\\S]+?)%>/g,\r\n\t        interpolate: /<%=([\\s\\S]+?)%>/g,\r\n\t        escape: /<%-([\\s\\S]+?)%>/g\r\n\t    };\r\n\t\r\n\t    // When customizing `templateSettings`, if you don't want to define an\r\n\t    // interpolation, evaluation or escaping regex, we need one that is\r\n\t    // guaranteed not to match.\r\n\t    var noMatch = /(.)^/;\r\n\t\r\n\t    // Certain characters need to be escaped so that they can be put into a\r\n\t    // string literal.\r\n\t    var escapes = {\r\n\t        \"'\": \"'\",\r\n\t        '\\\\': '\\\\',\r\n\t        '\\r': 'r',\r\n\t        '\\n': 'n',\r\n\t        '\\u2028': 'u2028',\r\n\t        '\\u2029': 'u2029'\r\n\t    };\r\n\t\r\n\t    var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\r\n\t\r\n\t    var escapeChar = function(match) {\r\n\t        return '\\\\' + escapes[match];\r\n\t    };\r\n\t\r\n\t    // JavaScript micro-templating, similar to John Resig's implementation.\r\n\t    // Underscore templating handles arbitrary delimiters, preserves whitespace,\r\n\t    // and correctly escapes quotes within interpolated code.\r\n\t    // NB: `oldSettings` only exists for backwards compatibility.\r\n\t    function template(text, settings, oldSettings) {\r\n\t        if (!settings && oldSettings) settings = oldSettings;\r\n\t        settings = settings || {};\r\n\t        settings = zrUtil.defaults(settings, templateSettings, true);\r\n\t\r\n\t        // Combine delimiters into one regular expression via alternation.\r\n\t        var matcher = RegExp([\r\n\t            (settings.escape || noMatch).source,\r\n\t            (settings.interpolate || noMatch).source,\r\n\t            (settings.evaluate || noMatch).source\r\n\t        ].join('|') + '|$', 'g');\r\n\t\r\n\t        // Compile the template source, escaping string literals appropriately.\r\n\t        var index = 0;\r\n\t        var source = \"__p+='\";\r\n\t        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\r\n\t            source += text.slice(index, offset).replace(escaper, escapeChar);\r\n\t            index = offset + match.length;\r\n\t\r\n\t            if (escape) {\r\n\t                source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\r\n\t            } else if (interpolate) {\r\n\t                source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\r\n\t            } else if (evaluate) {\r\n\t                source += \"';\\n\" + evaluate + \"\\n__p+='\";\r\n\t            }\r\n\t\r\n\t            // Adobe VMs need the match returned to produce the correct offest.\r\n\t            return match;\r\n\t        });\r\n\t        source += \"';\\n\";\r\n\t\r\n\t        // If a variable is not specified, place data values in local scope.\r\n\t        if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\r\n\t\r\n\t        source = \"var __t,__p='',__j=Array.prototype.join,\" +\r\n\t            \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\r\n\t            source + 'return __p;\\n';\r\n\t\r\n\t        try {\r\n\t            var render = new Function(settings.variable || 'obj', source);\r\n\t        } catch (e) {\r\n\t            e.source = source;\r\n\t            throw e;\r\n\t        }\r\n\t\r\n\t        var template = function(data) {\r\n\t            return render.call(this, data);\r\n\t        };\r\n\t\r\n\t        // Provide the compiled source as a convenience for precompilation.\r\n\t        var argument = settings.variable || 'obj';\r\n\t        template.source = 'function(' + argument + '){\\n' + source + '}';\r\n\t\r\n\t        return template;\r\n\t    }\r\n\t\r\n\t    function isEmpty(obj) {\r\n\t        if (obj == null) return true;\r\n\t        if (zrUtil.isArrayLike(obj) && (zrUtil.isArray(obj) || zrUtil.isString(obj))) return obj.length === 0;\r\n\t    }\r\n\t    function mergeOpt(target, source, overwrite, exclude) {\r\n\t        // We should escapse that source is string\r\n\t        // and enter for ... in ...\r\n\t        if (!zrUtil.isObject(source) || !zrUtil.isObject(target)) {\r\n\t          return overwrite ? zrUtil.clone(source) : target;\r\n\t        }\r\n\t      \r\n\t        for (var key in source) {\r\n\t          if (source.hasOwnProperty(key)) {\r\n\t            var targetProp = target[key];\r\n\t            var sourceProp = source[key];\r\n\t      \r\n\t            if (zrUtil.isObject(sourceProp) && zrUtil.isObject(targetProp) && !zrUtil.isArray(sourceProp) && !zrUtil.isArray(targetProp) && !zrUtil.isDom(sourceProp) && !zrUtil.isDom(targetProp) && !zrUtil.isBuiltInObject(sourceProp) && !zrUtil.isBuiltInObject(targetProp) && !zrUtil.isPrimitive(sourceProp) && !zrUtil.isPrimitive(targetProp)) {\r\n\t              // 如果需要递归覆盖，就递归调用merge\r\n\t              mergeOpt(targetProp, sourceProp, overwrite, exclude);\r\n\t            } else if (overwrite || !(key in target)) {\r\n\t              // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\r\n\t              // NOTE，在 target[key] 不存在的时候也是直接覆盖\r\n\t                if (key !== exclude) {\r\n\t                    target[key] = zrUtil.clone(source[key], true);\r\n\t                }\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t        return target;\r\n\t    }\r\n\t    function Class() {}\r\n\t    Class.extend = function(proto) {\r\n\t        var base = function() {},\r\n\t            member,\r\n\t            that = this,\r\n\t            subclass = proto && proto.init ? proto.init : function () {\r\n\t                that.apply(this, arguments);\r\n\t            },\r\n\t            fn;\r\n\t\r\n\t        base.prototype = that.prototype;\r\n\t        fn = subclass.fn = subclass.prototype = new base();\r\n\t\r\n\t        for (member in proto) {\r\n\t            if (proto[member] != null && proto[member].constructor === Object) {\r\n\t                // Merge object members\r\n\t                fn[member] = zrUtil.mergeAll([{}, base.prototype[member], proto[member]],true);\r\n\t            } else {\r\n\t                fn[member] = proto[member];\r\n\t            }\r\n\t        }\r\n\t\r\n\t        fn.constructor = subclass;\r\n\t        subclass.extend = that.extend;\r\n\t\r\n\t        return subclass;\r\n\t    };\r\n\t\r\n\t    module.exports = {\r\n\t        inherits: inherits,\r\n\t        getUUID: getUUID,\r\n\t        distance: distance,\r\n\t        getPolylineLength: getPolylineLength,\r\n\t        max: max,\r\n\t        min: min,\r\n\t        isEmpty: isEmpty,\r\n\t        mergeOpt: mergeOpt,\r\n\t        orthogonalPath: orthogonalPath,\r\n\t        polylineIntersectsRectangle: polylineIntersectsRectangle,\r\n\t        scorePath: scorePath,\r\n\t        forwardPath: forwardPath,\r\n\t        traslatePoints: traslatePoints,\r\n\t        getEndPoint: getEndPoint,\r\n\t        getConnectorPoints: getConnectorPoints,\r\n\t        tangentRotation: tangentRotation,\r\n\t        collinearity: collinearity,\r\n\t        translationMatrix: translationMatrix,\r\n\t        scaleMatrix: scaleMatrix,\r\n\t        round: enhancedRound,\r\n\t        getLength: getLength,\r\n\t        getAngle: getAngle,\r\n\t        getRect: getRect,\r\n\t        StackedMap: StackedMap,\r\n\t        getMaxLineLength: getMaxLineLength,\r\n\t        randomColor: randomColor,\r\n\t        template: template,\r\n\t        isUndefined: isUndefined,\r\n\t        getSoltPoints:getSoltPoints,\r\n\t        collinearReduction: collinearReduction,\r\n\t        Class:Class\r\n\t    };\r\n\t\r\n\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports) {\n\n\t\r\n\t\r\n\t    /**\r\n\t      * Creates an instance of Point\r\n\t      *\r\n\t      *\r\n\t      * @constructor\r\n\t      * @this {Point}\r\n\t      * @param {Number} x The x coordinate of point.\r\n\t      * @param {Number} y The y coordinate of point.\r\n\t      * Note: Even if it is named Point this class should be named Dot as Dot is closer\r\n\t      * then Point from math perspective.\r\n\t      **/\r\n\t    function Point(x, y){\r\n\t        /**The x coordinate of point*/\r\n\t        this.x = x;\r\n\t\r\n\t        /**The y coordinate of point*/\r\n\t        this.y = y;\r\n\t\r\n\t\r\n\t    }\r\n\t\r\n\t    /**Creates a {Point} out of JSON parsed object\r\n\t     *@param {JSONObject} o - the JSON parsed object\r\n\t     *@return {Point} a newly constructed Point\r\n\t     **/\r\n\t    Point.load = function(o){\r\n\t        var newPoint = new Point(Number(o.x), Number(o.y));\r\n\t        return newPoint;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**Creates an array of points from an array of {JSONObject}s\r\n\t     *@param {Array} v - the array of JSONObjects\r\n\t     *@return an {Array} of {Point}s\r\n\t     **/\r\n\t    Point.loadArray = function(v){\r\n\t        var newPoints = [];\r\n\t        for(var i=0; i< v.length; i++){\r\n\t            newPoints.push(Point.load(v[i]));\r\n\t        }\r\n\t        return newPoints;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**Clones an array of points\r\n\t     *@param {Array} v - the array of {Point}s\r\n\t     *@return an {Array} of {Point}s\r\n\t     **/\r\n\t    Point.cloneArray = function(v){\r\n\t        var newPoints = [];\r\n\t        for(var i=0; i< v.length; i++){\r\n\t            newPoints.push(v[i].clone());\r\n\t        }\r\n\t        return newPoints;\r\n\t    };\r\n\t\r\n\t    Point.prototype = {\r\n\t        constructor : Point,\r\n\t\r\n\t        transform:function(matrix){\r\n\t            var oldX = this.x;\r\n\t            var oldY = this.y;\r\n\t            this.x = matrix[0][0] * oldX + matrix[0][1] * oldY + matrix[0][2];\r\n\t            this.y = matrix[1][0] * oldX + matrix[1][1] * oldY + matrix[1][2];\r\n\t        },\r\n\t\r\n\t        /**Tests if this point is similar to other point\r\n\t         *@param {Point} anotherPoint - the other point\r\n\t         **/\r\n\t        equals:function(anotherPoint){\r\n\t            if(! (anotherPoint instanceof Point) ){\r\n\t                return false;\r\n\t            }\r\n\t            return (this.x == anotherPoint.x)\r\n\t            && (this.y == anotherPoint.y)\r\n\t        },\r\n\t\r\n\t        /**Clone current Point\r\n\t         **/\r\n\t        clone: function(){\r\n\t            var newPoint = new Point(this.x, this.y);\r\n\t            return newPoint;\r\n\t        },\r\n\t\r\n\t        add: function(point) {\r\n\t            this.x = this.x + point.x;\r\n\t            this.y = this.y + point.y;\r\n\t            return this;\r\n\t        },\r\n\t\r\n\t        /**Tests to see if a point (x, y) is within a range of current Point\r\n\t         *@param {Numeric} x - the x coordinate of tested point\r\n\t         *@param {Numeric} y - the x coordinate of tested point\r\n\t         *@param {Numeric} radius - the radius of the vicinity\r\n\t         **/\r\n\t        near:function(x, y, radius){\r\n\t            var distance = Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));\r\n\t\r\n\t            return (distance <= radius);\r\n\t        },\r\n\t\r\n\t        contains: function(x,y){\r\n\t            return this.x == x && this.y == y;\r\n\t        },\r\n\t\r\n\t        toString:function(){\r\n\t            return '[' + this.x + ',' + this.y + ']';\r\n\t        },\r\n\t\r\n\t        getPoints:function(){\r\n\t            return [this];\r\n\t        }\r\n\t    };\r\n\t    module.exports = Point;\r\n\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports) {\n\n\t\r\n\t\r\n\t    /**\r\n\t      * Creates an instance of a Line. A Line is actually a segment and not a pure\r\n\t      * geometrical Line\r\n\t      *\r\n\t      * @constructor\r\n\t      * @this {Line}\r\n\t      * @param {Point} startPoint - starting point of the line\r\n\t      * @param {Point} endPoint - the ending point of the line\r\n\t      **/\r\n\t    function Line(startPoint, endPoint){\r\n\t        /**Starting {@link Point} of the line*/\r\n\t        this.startPoint = startPoint;\r\n\t\r\n\t        /**Ending {@link Point} of the line*/\r\n\t        this.endPoint = endPoint;\r\n\t\r\n\t        /**Serialization type*/\r\n\t        this.oType = 'Line'; //object type used for JSON deserialization\r\n\t    }\r\n\t\r\n\t    /**Creates a {Line} out of JSON parsed object\r\n\t     *@param {JSONObject} o - the JSON parsed object\r\n\t     *@return {Line} a newly constructed Line\r\n\t     **/\r\n\t    Line.load = function(o){\r\n\t        var newLine = new Line(\r\n\t            Point.load(o.startPoint),\r\n\t            Point.load(o.endPoint)\r\n\t        );\r\n\t\r\n\t        return newLine;\r\n\t    };\r\n\t\r\n\t    Line.prototype = {\r\n\t        contructor: Line,\r\n\t\r\n\t\r\n\t\r\n\t        clone:function(){\r\n\t            var ret = new Line(this.startPoint.clone(), this.endPoint.clone());\r\n\t            return ret;\r\n\t        },\r\n\t\r\n\t        equals:function(anotherLine){\r\n\t            if(!anotherLine instanceof Line){\r\n\t                return false;\r\n\t            }\r\n\t            return this.startPoint.equals(anotherLine.startPoint)\r\n\t            && this.endPoint.equals(anotherLine.endPoint)\r\n\t        },\r\n\t\r\n\t        /** Tests to see if a point belongs to this line (not as infinite line but more like a segment)\r\n\t         * Algorithm: Compute line's equation and see if (x, y) verifies it.\r\n\t         * @param {Number} x - the X coordinates\r\n\t         * @param {Number} y - the Y coordinates\r\n\t         **/\r\n\t        contains: function(x, y){\r\n\t            // if the point is inside rectangle bounds of the segment\r\n\t            if (Math.min(this.startPoint.x, this.endPoint.x) <= x\r\n\t                && x <= Math.max(this.startPoint.x, this.endPoint.x)\r\n\t                && Math.min(this.startPoint.y, this.endPoint.y) <= y\r\n\t                && y <= Math.max(this.startPoint.y, this.endPoint.y)) {\r\n\t\r\n\t                // check for vertical line\r\n\t                if (this.startPoint.x == this.endPoint.x) {\r\n\t                    return x == this.startPoint.x;\r\n\t                } else { // usual (not vertical) line can be represented as y = a * x + b\r\n\t                    var a = (this.endPoint.y - this.startPoint.y) / (this.endPoint.x - this.startPoint.x);\r\n\t                    var b = this.startPoint.y - a * this.startPoint.x;\r\n\t                    return y == a * x + b;\r\n\t                }\r\n\t            } else {\r\n\t                return false;\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /*\r\n\t         *See if we are near a {Line} by a certain radius (also includes the extremities into computation)\r\n\t         *@param {Number} x - the x coordinates\r\n\t         *@param {Number} y - the y coordinates\r\n\t         *@param {Number} radius - the radius to search for\r\n\t         *@see http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n\t         *@see \"Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227\"\r\n\t         **/\r\n\t        near:function(x,y,radius){\r\n\t\r\n\t            if(this.endPoint.x === this.startPoint.x){ //Vertical line, so the vicinity area is a rectangle\r\n\t                return ( (this.startPoint.y-radius<=y && this.endPoint.y+radius>=y)\r\n\t                        || (this.endPoint.y-radius<=y && this.startPoint.y+radius>=y))\r\n\t                && x > this.startPoint.x - radius && x < this.startPoint.x + radius ;\r\n\t            }\r\n\t\r\n\t            if(this.startPoint.y === this.endPoint.y){ //Horizontal line, so the vicinity area is a rectangle\r\n\t                return ( (this.startPoint.x - radius<=x && this.endPoint.x+radius>=x)\r\n\t                        || (this.endPoint.x-radius<=x && this.startPoint.x+radius>=x))\r\n\t                        && y>this.startPoint.y-radius && y<this.startPoint.y+radius ;\r\n\t            }\r\n\t\r\n\t\r\n\t            var startX = Math.min(this.endPoint.x,this.startPoint.x);\r\n\t            var startY = Math.min(this.endPoint.y,this.startPoint.y);\r\n\t            var endX = Math.max(this.endPoint.x,this.startPoint.x);\r\n\t            var endY = Math.max(this.endPoint.y,this.startPoint.y);\r\n\t\r\n\t            /*We will compute the distance from point to the line\r\n\t             * by using the algorithm from\r\n\t             * http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n\t             * */\r\n\t\r\n\t            //First we need to find a,b,c of the line equation ax + by + c = 0\r\n\t            var a = this.endPoint.y - this.startPoint.y;\r\n\t            var b = this.startPoint.x - this.endPoint.x;\r\n\t            var c = -(this.startPoint.x * this.endPoint.y - this.endPoint.x * this.startPoint.y);\r\n\t\r\n\t            //Secondly we get the distance \"Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227\"\r\n\t            var d = Math.abs( (a*x + b*y + c) / Math.sqrt(Math.pow(a,2) + Math.pow(b,2)) );\r\n\t\r\n\t            //Thirdly we get coordinates of closest line's point to target point\r\n\t            //http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Cartesian_coordinates\r\n\t            var closestX = (b * (b*x - a*y) - a*c) / ( Math.pow(a,2) + Math.pow(b,2) );\r\n\t            var closestY = (a * (-b*x + a*y) - b*c) / ( Math.pow(a,2) + Math.pow(b,2) );\r\n\t\r\n\t            var r = ( d <= radius && endX>=closestX && closestX>=startX && endY>=closestY && closestY>=startY ) //the projection of the point falls INSIDE of the segment\r\n\t                || this.startPoint.near(x,y,radius) || this.endPoint.near(x,y,radius); //the projection of the point falls OUTSIDE of the segment\r\n\t\r\n\t            return  r;\r\n\t\r\n\t        },\r\n\t\r\n\t        /**we need to create a new array each time, or we will affect the actual shape*/\r\n\t        getPoints:function(){\r\n\t            var points = [];\r\n\t            points.push(this.startPoint);\r\n\t            points.push(this.endPoint);\r\n\t            return points;\r\n\t        },\r\n\t\r\n\t        /**Return the {Point} corresponding the t certain t value\r\n\t         * @param {Number} t the value of parameter t, where t in [0,1], t is like a percent*/\r\n\t        getPoint: function(t){\r\n\t            var Xp = t * (this.endPoint.x - this.startPoint.x) + this.startPoint.x;\r\n\t            var Yp = t * (this.endPoint.y - this.startPoint.y) + this.startPoint.y;\r\n\t\r\n\t            return new Point(Xp, Yp);\r\n\t        },\r\n\t\r\n\t        // /**\r\n\t        //  * Returns the middle of the line\r\n\t        //  * @return {Point} the middle point\r\n\t        //  * */\r\n\t        // getMiddle : function(){\r\n\t        //     return Util.getMiddle(this.startPoint, this.endPoint);\r\n\t        // },\r\n\t\r\n\t\r\n\t        // getLength : function(){\r\n\t        //     return Util.getLength(this.startPoint, this.endPoint);\r\n\t        // },\r\n\t\r\n\t        // /**\r\n\t        //  *Get bounds for this line\r\n\t        //  *@author Alex Gheorghiu <alex@scriptoid.com>\r\n\t        //  **/\r\n\t        // getBounds:function(){\r\n\t        //     return Util.getBounds(this.getPoints());\r\n\t        // },\r\n\t\r\n\t        /**String representation*/\r\n\t        toString:function(){\r\n\t            return 'line(' + this.startPoint + ',' + this.endPoint + ')';\r\n\t        }\r\n\t    };\r\n\t    module.exports = Line;\r\n\t\r\n\t\r\n\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t\r\n\t    var apiList = [\r\n\t        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction',\r\n\t        'on', 'off', 'trigger', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption'\r\n\t    ];\r\n\t\r\n\t    function ExtensionAPI(instance) {\r\n\t        zrUtil.each(apiList, function (name) {\r\n\t            this[name] = zrUtil.bind(instance[name], instance);\r\n\t        }, this);\r\n\t    }\r\n\t\r\n\t    module.exports = ExtensionAPI;\r\n\t\r\n\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar guid = __webpack_require__(10);\n\t\n\tvar env = __webpack_require__(49);\n\t\n\tvar zrUtil = __webpack_require__(4);\n\t\n\tvar Handler = __webpack_require__(68);\n\t\n\tvar Storage = __webpack_require__(69);\n\t\n\tvar Painter = __webpack_require__(71);\n\t\n\tvar Animation = __webpack_require__(74);\n\t\n\tvar HandlerProxy = __webpack_require__(76);\n\t\n\t/*!\n\t* ZRender, a high performance 2d drawing library.\n\t*\n\t* Copyright (c) 2013, Baidu Inc.\n\t* All rights reserved.\n\t*\n\t* LICENSE\n\t* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n\t*/\n\tvar useVML = !env.canvasSupported;\n\tvar painterCtors = {\n\t  canvas: Painter\n\t};\n\tvar instances = {}; // ZRender实例map索引\n\t\n\t/**\n\t * @type {string}\n\t */\n\t\n\tvar version = '3.7.4';\n\t/**\n\t * Initializing a zrender instance\n\t * @param {HTMLElement} dom\n\t * @param {Object} opts\n\t * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t * @param {number} [opts.devicePixelRatio]\n\t * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n\t * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n\t * @return {module:zrender/ZRender}\n\t */\n\t\n\tfunction init(dom, opts) {\n\t  var zr = new ZRender(guid(), dom, opts);\n\t  instances[zr.id] = zr;\n\t  return zr;\n\t}\n\t/**\n\t * Dispose zrender instance\n\t * @param {module:zrender/ZRender} zr\n\t */\n\t\n\t\n\tfunction dispose(zr) {\n\t  if (zr) {\n\t    zr.dispose();\n\t  } else {\n\t    for (var key in instances) {\n\t      if (instances.hasOwnProperty(key)) {\n\t        instances[key].dispose();\n\t      }\n\t    }\n\t\n\t    instances = {};\n\t  }\n\t\n\t  return this;\n\t}\n\t/**\n\t * Get zrender instance by id\n\t * @param {string} id zrender instance id\n\t * @return {module:zrender/ZRender}\n\t */\n\t\n\t\n\tfunction getInstance(id) {\n\t  return instances[id];\n\t}\n\t\n\tfunction registerPainter(name, Ctor) {\n\t  painterCtors[name] = Ctor;\n\t}\n\t\n\tfunction delInstance(id) {\n\t  delete instances[id];\n\t}\n\t/**\n\t * @module zrender/ZRender\n\t */\n\t\n\t/**\n\t * @constructor\n\t * @alias module:zrender/ZRender\n\t * @param {string} id\n\t * @param {HTMLElement} dom\n\t * @param {Object} opts\n\t * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t * @param {number} [opts.devicePixelRatio]\n\t * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n\t * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n\t */\n\t\n\t\n\tvar ZRender = function (id, dom, opts) {\n\t  opts = opts || {};\n\t  /**\n\t   * @type {HTMLDomElement}\n\t   */\n\t\n\t  this.dom = dom;\n\t  /**\n\t   * @type {string}\n\t   */\n\t\n\t  this.id = id;\n\t  var self = this;\n\t  var storage = new Storage();\n\t  var rendererType = opts.renderer; // TODO WebGL\n\t\n\t  if (useVML) {\n\t    if (!painterCtors.vml) {\n\t      throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n\t    }\n\t\n\t    rendererType = 'vml';\n\t  } else if (!rendererType || !painterCtors[rendererType]) {\n\t    rendererType = 'canvas';\n\t  }\n\t\n\t  var painter = new painterCtors[rendererType](dom, storage, opts);\n\t  this.storage = storage;\n\t  this.painter = painter;\n\t  var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n\t  this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\t  /**\n\t   * @type {module:zrender/animation/Animation}\n\t   */\n\t\n\t  this.animation = new Animation({\n\t    stage: {\n\t      update: zrUtil.bind(this.flush, this)\n\t    }\n\t  });\n\t  this.animation.start();\n\t  /**\n\t   * @type {boolean}\n\t   * @private\n\t   */\n\t\n\t  this._needsRefresh; // 修改 storage.delFromStorage, 每次删除元素之前删除动画\n\t  // FIXME 有点ugly\n\t\n\t  var oldDelFromStorage = storage.delFromStorage;\n\t  var oldAddToStorage = storage.addToStorage;\n\t\n\t  storage.delFromStorage = function (el) {\n\t    oldDelFromStorage.call(storage, el);\n\t    el && el.removeSelfFromZr(self);\n\t  };\n\t\n\t  storage.addToStorage = function (el) {\n\t    oldAddToStorage.call(storage, el);\n\t    el.addSelfToZr(self);\n\t  };\n\t};\n\t\n\tZRender.prototype = {\n\t  constructor: ZRender,\n\t\n\t  /**\n\t   * 获取实例唯一标识\n\t   * @return {string}\n\t   */\n\t  getId: function () {\n\t    return this.id;\n\t  },\n\t\n\t  /**\n\t   * 添加元素\n\t   * @param  {module:zrender/Element} el\n\t   */\n\t  add: function (el) {\n\t    this.storage.addRoot(el);\n\t    this._needsRefresh = true;\n\t  },\n\t\n\t  /**\n\t   * 删除元素\n\t   * @param  {module:zrender/Element} el\n\t   */\n\t  remove: function (el) {\n\t    this.storage.delRoot(el);\n\t    this._needsRefresh = true;\n\t  },\n\t\n\t  /**\n\t   * Change configuration of layer\n\t   * @param {string} zLevel\n\t   * @param {Object} config\n\t   * @param {string} [config.clearColor=0] Clear color\n\t   * @param {string} [config.motionBlur=false] If enable motion blur\n\t   * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n\t  */\n\t  configLayer: function (zLevel, config) {\n\t    this.painter.configLayer(zLevel, config);\n\t    this._needsRefresh = true;\n\t  },\n\t\n\t  /**\n\t   * Repaint the canvas immediately\n\t   */\n\t  refreshImmediately: function () {\n\t    // var start = new Date();\n\t    // Clear needsRefresh ahead to avoid something wrong happens in refresh\n\t    // Or it will cause zrender refreshes again and again.\n\t    this._needsRefresh = false;\n\t    this.painter.refresh();\n\t    /**\n\t     * Avoid trigger zr.refresh in Element#beforeUpdate hook\n\t     */\n\t\n\t    this._needsRefresh = false; // var end = new Date();\n\t    // var log = document.getElementById('log');\n\t    // if (log) {\n\t    //     log.innerHTML = log.innerHTML + '<br>' + (end - start);\n\t    // }\n\t  },\n\t\n\t  /**\n\t   * Mark and repaint the canvas in the next frame of browser\n\t   */\n\t  refresh: function () {\n\t    this._needsRefresh = true;\n\t  },\n\t\n\t  /**\n\t   * Perform all refresh\n\t   */\n\t  flush: function () {\n\t    if (this._needsRefresh) {\n\t      this.refreshImmediately();\n\t    }\n\t\n\t    if (this._needsRefreshHover) {\n\t      this.refreshHoverImmediately();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Add element to hover layer\n\t   * @param  {module:zrender/Element} el\n\t   * @param {Object} style\n\t   */\n\t  addHover: function (el, style) {\n\t    if (this.painter.addHover) {\n\t      this.painter.addHover(el, style);\n\t      this.refreshHover();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Add element from hover layer\n\t   * @param  {module:zrender/Element} el\n\t   */\n\t  removeHover: function (el) {\n\t    if (this.painter.removeHover) {\n\t      this.painter.removeHover(el);\n\t      this.refreshHover();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Clear all hover elements in hover layer\n\t   * @param  {module:zrender/Element} el\n\t   */\n\t  clearHover: function () {\n\t    if (this.painter.clearHover) {\n\t      this.painter.clearHover();\n\t      this.refreshHover();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Refresh hover in next frame\n\t   */\n\t  refreshHover: function () {\n\t    this._needsRefreshHover = true;\n\t  },\n\t\n\t  /**\n\t   * Refresh hover immediately\n\t   */\n\t  refreshHoverImmediately: function () {\n\t    this._needsRefreshHover = false;\n\t    this.painter.refreshHover && this.painter.refreshHover();\n\t  },\n\t\n\t  /**\n\t   * Resize the canvas.\n\t   * Should be invoked when container size is changed\n\t   * @param {Object} [opts]\n\t   * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n\t   * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n\t   */\n\t  resize: function (opts) {\n\t    opts = opts || {};\n\t    this.painter.resize(opts.width, opts.height);\n\t    this.handler.resize();\n\t  },\n\t\n\t  /**\n\t   * Stop and clear all animation immediately\n\t   */\n\t  clearAnimation: function () {\n\t    this.animation.clear();\n\t  },\n\t\n\t  /**\n\t   * Get container width\n\t   */\n\t  getWidth: function () {\n\t    return this.painter.getWidth();\n\t  },\n\t\n\t  /**\n\t   * Get container height\n\t   */\n\t  getHeight: function () {\n\t    return this.painter.getHeight();\n\t  },\n\t\n\t  /**\n\t   * Export the canvas as Base64 URL\n\t   * @param {string} type\n\t   * @param {string} [backgroundColor='#fff']\n\t   * @return {string} Base64 URL\n\t   */\n\t  // toDataURL: function(type, backgroundColor) {\n\t  //     return this.painter.getRenderedCanvas({\n\t  //         backgroundColor: backgroundColor\n\t  //     }).toDataURL(type);\n\t  // },\n\t\n\t  /**\n\t   * Converting a path to image.\n\t   * It has much better performance of drawing image rather than drawing a vector path.\n\t   * @param {module:zrender/graphic/Path} e\n\t   * @param {number} width\n\t   * @param {number} height\n\t   */\n\t  pathToImage: function (e, dpr) {\n\t    return this.painter.pathToImage(e, dpr);\n\t  },\n\t\n\t  /**\n\t   * Set default cursor\n\t   * @param {string} [cursorStyle='default'] 例如 crosshair\n\t   */\n\t  setCursorStyle: function (cursorStyle) {\n\t    this.handler.setCursorStyle(cursorStyle);\n\t  },\n\t\n\t  /**\n\t   * Find hovered element\n\t   * @param {number} x\n\t   * @param {number} y\n\t   * @return {Object} {target, topTarget}\n\t   */\n\t  findHover: function (x, y) {\n\t    return this.handler.findHover(x, y);\n\t  },\n\t\n\t  /**\n\t   * Bind event\n\t   *\n\t   * @param {string} eventName Event name\n\t   * @param {Function} eventHandler Handler function\n\t   * @param {Object} [context] Context object\n\t   */\n\t  on: function (eventName, eventHandler, context) {\n\t    this.handler.on(eventName, eventHandler, context);\n\t  },\n\t\n\t  /**\n\t   * Unbind event\n\t   * @param {string} eventName Event name\n\t   * @param {Function} [eventHandler] Handler function\n\t   */\n\t  off: function (eventName, eventHandler) {\n\t    this.handler.off(eventName, eventHandler);\n\t  },\n\t\n\t  /**\n\t   * Trigger event manually\n\t   *\n\t   * @param {string} eventName Event name\n\t   * @param {event=} event Event object\n\t   */\n\t  trigger: function (eventName, event) {\n\t    this.handler.trigger(eventName, event);\n\t  },\n\t\n\t  /**\n\t   * Clear all objects and the canvas.\n\t   */\n\t  clear: function () {\n\t    this.storage.delRoot();\n\t    this.painter.clear();\n\t  },\n\t\n\t  /**\n\t   * Dispose self.\n\t   */\n\t  dispose: function () {\n\t    this.animation.stop();\n\t    this.clear();\n\t    this.storage.dispose();\n\t    this.painter.dispose();\n\t    this.handler.dispose();\n\t    this.animation = this.storage = this.painter = this.handler = null;\n\t    delInstance(this.id);\n\t  }\n\t};\n\texports.version = version;\n\texports.init = init;\n\texports.dispose = dispose;\n\texports.getInstance = getInstance;\n\texports.registerPainter = registerPainter;\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(4);\n\t\n\tvar vec2 = __webpack_require__(14);\n\t\n\tvar Draggable = __webpack_require__(42);\n\t\n\tvar Eventful = __webpack_require__(11);\n\t\n\t/**\n\t * Handler\n\t * @module zrender/Handler\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (shenyi.914@gmail.com)\n\t */\n\tvar SILENT = 'silent';\n\t\n\tfunction makeEventPacket(eveType, targetInfo, event) {\n\t  return {\n\t    type: eveType,\n\t    event: event,\n\t    // target can only be an element that is not silent.\n\t    target: targetInfo.target,\n\t    // topTarget can be a silent element.\n\t    topTarget: targetInfo.topTarget,\n\t    cancelBubble: false,\n\t    offsetX: event.zrX,\n\t    offsetY: event.zrY,\n\t    gestureEvent: event.gestureEvent,\n\t    pinchX: event.pinchX,\n\t    pinchY: event.pinchY,\n\t    pinchScale: event.pinchScale,\n\t    wheelDelta: event.zrDelta,\n\t    zrByTouch: event.zrByTouch,\n\t    which: event.which\n\t  };\n\t}\n\t\n\tfunction EmptyProxy() {}\n\t\n\tEmptyProxy.prototype.dispose = function () {};\n\t\n\tvar handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n\t/**\n\t * @alias module:zrender/Handler\n\t * @constructor\n\t * @extends module:zrender/mixin/Eventful\n\t * @param {module:zrender/Storage} storage Storage instance.\n\t * @param {module:zrender/Painter} painter Painter instance.\n\t * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n\t * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n\t */\n\t\n\tvar Handler = function (storage, painter, proxy, painterRoot) {\n\t  Eventful.call(this);\n\t  this.storage = storage;\n\t  this.painter = painter;\n\t  this.painterRoot = painterRoot;\n\t  proxy = proxy || new EmptyProxy();\n\t  /**\n\t   * Proxy of event. can be Dom, WebGLSurface, etc.\n\t   */\n\t\n\t  this.proxy = proxy; // Attach handler\n\t\n\t  proxy.handler = this;\n\t  /**\n\t   * {target, topTarget, x, y}\n\t   * @private\n\t   * @type {Object}\n\t   */\n\t\n\t  this._hovered = {};\n\t  /**\n\t   * @private\n\t   * @type {Date}\n\t   */\n\t\n\t  this._lastTouchMoment;\n\t  /**\n\t   * @private\n\t   * @type {number}\n\t   */\n\t\n\t  this._lastX;\n\t  /**\n\t   * @private\n\t   * @type {number}\n\t   */\n\t\n\t  this._lastY;\n\t  Draggable.call(this);\n\t  util.each(handlerNames, function (name) {\n\t    proxy.on && proxy.on(name, this[name], this);\n\t  }, this);\n\t};\n\t\n\tHandler.prototype = {\n\t  constructor: Handler,\n\t  mousemove: function (event) {\n\t    var x = event.zrX;\n\t    var y = event.zrY;\n\t    var lastHovered = this._hovered;\n\t    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call\n\t    // (like 'setOption' or 'dispatchAction') in event handlers, we should find\n\t    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.\n\t    // See #6198.\n\t\n\t    if (lastHoveredTarget && !lastHoveredTarget.__zr) {\n\t      lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n\t      lastHoveredTarget = lastHovered.target;\n\t    }\n\t\n\t    var hovered = this._hovered = this.findHover(x, y);\n\t    var hoveredTarget = hovered.target;\n\t    var proxy = this.proxy;\n\t    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element\n\t\n\t    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n\t      this.dispatchToElement(lastHovered, 'mouseout', event);\n\t    } // Mouse moving on one element\n\t\n\t\n\t    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element\n\t\n\t    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n\t      this.dispatchToElement(hovered, 'mouseover', event);\n\t    }\n\t  },\n\t  mouseout: function (event) {\n\t    this.dispatchToElement(this._hovered, 'mouseout', event); // There might be some doms created by upper layer application\n\t    // at the same level of painter.getViewportRoot() (e.g., tooltip\n\t    // dom created by echarts), where 'globalout' event should not\n\t    // be triggered when mouse enters these doms. (But 'mouseout'\n\t    // should be triggered at the original hovered element as usual).\n\t\n\t    var element = event.toElement || event.relatedTarget;\n\t    var innerDom;\n\t\n\t    do {\n\t      element = element && element.parentNode;\n\t    } while (element && element.nodeType != 9 && !(innerDom = element === this.painterRoot));\n\t\n\t    !innerDom && this.trigger('globalout', {\n\t      event: event\n\t    });\n\t  },\n\t\n\t  /**\n\t   * Resize\n\t   */\n\t  resize: function (event) {\n\t    this._hovered = {};\n\t  },\n\t\n\t  /**\n\t   * Dispatch event\n\t   * @param {string} eventName\n\t   * @param {event=} eventArgs\n\t   */\n\t  dispatch: function (eventName, eventArgs) {\n\t    var handler = this[eventName];\n\t    handler && handler.call(this, eventArgs);\n\t  },\n\t\n\t  /**\n\t   * Dispose\n\t   */\n\t  dispose: function () {\n\t    this.proxy.dispose();\n\t    this.storage = this.proxy = this.painter = null;\n\t  },\n\t\n\t  /**\n\t   * 设置默认的cursor style\n\t   * @param {string} [cursorStyle='default'] 例如 crosshair\n\t   */\n\t  setCursorStyle: function (cursorStyle) {\n\t    var proxy = this.proxy;\n\t    proxy.setCursor && proxy.setCursor(cursorStyle);\n\t  },\n\t\n\t  /**\n\t   * 事件分发代理\n\t   *\n\t   * @private\n\t   * @param {Object} targetInfo {target, topTarget} 目标图形元素\n\t   * @param {string} eventName 事件名称\n\t   * @param {Object} event 事件对象\n\t   */\n\t  dispatchToElement: function (targetInfo, eventName, event) {\n\t    targetInfo = targetInfo || {};\n\t    var el = targetInfo.target;\n\t\n\t    if (el && el.silent) {\n\t      return;\n\t    }\n\t\n\t    var eventHandler = 'on' + eventName;\n\t    var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\t\n\t    while (el) {\n\t      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\t      el.trigger(eventName, eventPacket);\n\t      el = el.parent;\n\t\n\t      if (eventPacket.cancelBubble) {\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (!eventPacket.cancelBubble) {\n\t      // 冒泡到顶级 zrender 对象\n\t      this.trigger(eventName, eventPacket); // 分发事件到用户自定义层\n\t      // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n\t\n\t      this.painter && this.painter.eachOtherLayer(function (layer) {\n\t        if (typeof layer[eventHandler] == 'function') {\n\t          layer[eventHandler].call(layer, eventPacket);\n\t        }\n\t\n\t        if (layer.trigger) {\n\t          layer.trigger(eventName, eventPacket);\n\t        }\n\t      });\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @private\n\t   * @param {number} x\n\t   * @param {number} y\n\t   * @param {module:zrender/graphic/Displayable} exclude\n\t   * @return {model:zrender/Element}\n\t   * @method\n\t   */\n\t  findHover: function (x, y, exclude) {\n\t    var list = this.storage.getDisplayList();\n\t    var out = {\n\t      x: x,\n\t      y: y\n\t    };\n\t\n\t    for (var i = list.length - 1; i >= 0; i--) {\n\t      var hoverCheckResult;\n\t\n\t      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode\n\t      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {\n\t        !out.topTarget && (out.topTarget = list[i]);\n\t\n\t        if (hoverCheckResult !== SILENT) {\n\t          out.target = list[i];\n\t          break;\n\t        }\n\t      }\n\t    }\n\t\n\t    return out;\n\t  }\n\t}; // Common handlers\n\t\n\tutil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n\t  Handler.prototype[name] = function (event) {\n\t    // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n\t    var hovered = this.findHover(event.zrX, event.zrY);\n\t    var hoveredTarget = hovered.target;\n\t\n\t    if (name === 'mousedown') {\n\t      this._downEl = hoveredTarget;\n\t      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup\n\t\n\t      this._upEl = hoveredTarget;\n\t    } else if (name === 'mosueup') {\n\t      this._upEl = hoveredTarget;\n\t    } else if (name === 'click') {\n\t      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,\n\t      // including the case that `mousedown` - `mousemove` - `mouseup`,\n\t      // which should be filtered, otherwise it will bring trouble to\n\t      // pan and zoom.\n\t      || !this._downPoint // Arbitrary value\n\t      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {\n\t        return;\n\t      }\n\t\n\t      this._downPoint = null;\n\t    }\n\t\n\t    this.dispatchToElement(hovered, name, event);\n\t  };\n\t});\n\t\n\tfunction isHover(displayable, x, y) {\n\t  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n\t    var el = displayable;\n\t    var isSilent;\n\t\n\t    while (el) {\n\t      // If clipped by ancestor.\n\t      // FIXME: If clipPath has neither stroke nor fill,\n\t      // el.clipPath.contain(x, y) will always return false.\n\t      if (el.clipPath && !el.clipPath.contain(x, y)) {\n\t        return false;\n\t      }\n\t\n\t      if (el.silent) {\n\t        isSilent = true;\n\t      }\n\t\n\t      el = el.parent;\n\t    }\n\t\n\t    return isSilent ? SILENT : true;\n\t  }\n\t\n\t  return false;\n\t}\n\t\n\tutil.mixin(Handler, Eventful);\n\tutil.mixin(Handler, Draggable);\n\tvar _default = Handler;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(4);\n\t\n\tvar env = __webpack_require__(49);\n\t\n\tvar Group = __webpack_require__(43);\n\t\n\tvar timsort = __webpack_require__(70);\n\t\n\t/**\n\t * Storage内容仓库模块\n\t * @module zrender/Storage\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t * @author errorrik (errorrik@gmail.com)\n\t * @author pissang (https://github.com/pissang/)\n\t */\n\t// Use timsort because in most case elements are partially sorted\n\t// https://jsfiddle.net/pissang/jr4x7mdm/8/\n\tfunction shapeCompareFunc(a, b) {\n\t  if (a.zlevel === b.zlevel) {\n\t    if (a.z === b.z) {\n\t      // if (a.z2 === b.z2) {\n\t      //     // FIXME Slow has renderidx compare\n\t      //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n\t      //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n\t      //     return a.__renderidx - b.__renderidx;\n\t      // }\n\t      return a.z2 - b.z2;\n\t    }\n\t\n\t    return a.z - b.z;\n\t  }\n\t\n\t  return a.zlevel - b.zlevel;\n\t}\n\t/**\n\t * 内容仓库 (M)\n\t * @alias module:zrender/Storage\n\t * @constructor\n\t */\n\t\n\t\n\tvar Storage = function () {\n\t  // jshint ignore:line\n\t  this._roots = [];\n\t  this._displayList = [];\n\t  this._displayListLen = 0;\n\t};\n\t\n\tStorage.prototype = {\n\t  constructor: Storage,\n\t\n\t  /**\n\t   * @param  {Function} cb\n\t   *\n\t   */\n\t  traverse: function (cb, context) {\n\t    for (var i = 0; i < this._roots.length; i++) {\n\t      this._roots[i].traverse(cb, context);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 返回所有图形的绘制队列\n\t   * @param {boolean} [update=false] 是否在返回前更新该数组\n\t   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\n\t   *\n\t   * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n\t   * @return {Array.<module:zrender/graphic/Displayable>}\n\t   */\n\t  getDisplayList: function (update, includeIgnore) {\n\t    includeIgnore = includeIgnore || false;\n\t\n\t    if (update) {\n\t      this.updateDisplayList(includeIgnore);\n\t    }\n\t\n\t    return this._displayList;\n\t  },\n\t\n\t  /**\n\t   * 更新图形的绘制队列。\n\t   * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\n\t   * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\n\t   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\n\t   */\n\t  updateDisplayList: function (includeIgnore) {\n\t    this._displayListLen = 0;\n\t    var roots = this._roots;\n\t    var displayList = this._displayList;\n\t\n\t    for (var i = 0, len = roots.length; i < len; i++) {\n\t      this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n\t    }\n\t\n\t    displayList.length = this._displayListLen; // for (var i = 0, len = displayList.length; i < len; i++) {\n\t    //     displayList[i].__renderidx = i;\n\t    // }\n\t    // displayList.sort(shapeCompareFunc);\n\t\n\t    env.canvasSupported && timsort(displayList, shapeCompareFunc);\n\t  },\n\t  _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\t    if (el.ignore && !includeIgnore) {\n\t      return;\n\t    }\n\t\n\t    el.beforeUpdate();\n\t\n\t    if (el.__dirty) {\n\t      el.update();\n\t    }\n\t\n\t    el.afterUpdate();\n\t    var userSetClipPath = el.clipPath;\n\t\n\t    if (userSetClipPath) {\n\t      // FIXME 效率影响\n\t      if (clipPaths) {\n\t        clipPaths = clipPaths.slice();\n\t      } else {\n\t        clipPaths = [];\n\t      }\n\t\n\t      var currentClipPath = userSetClipPath;\n\t      var parentClipPath = el; // Recursively add clip path\n\t\n\t      while (currentClipPath) {\n\t        // clipPath 的变换是基于使用这个 clipPath 的元素\n\t        currentClipPath.parent = parentClipPath;\n\t        currentClipPath.updateTransform();\n\t        clipPaths.push(currentClipPath);\n\t        parentClipPath = currentClipPath;\n\t        currentClipPath = currentClipPath.clipPath;\n\t      }\n\t    }\n\t\n\t    if (el.isGroup) {\n\t      var children = el._children;\n\t\n\t      for (var i = 0; i < children.length; i++) {\n\t        var child = children[i]; // Force to mark as dirty if group is dirty\n\t        // FIXME __dirtyPath ?\n\t\n\t        if (el.__dirty) {\n\t          child.__dirty = true;\n\t        }\n\t\n\t        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n\t      } // Mark group clean here\n\t\n\t\n\t      el.__dirty = false;\n\t    } else {\n\t      el.__clipPaths = clipPaths;\n\t      this._displayList[this._displayListLen++] = el;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 添加图形(Shape)或者组(Group)到根节点\n\t   * @param {module:zrender/Element} el\n\t   */\n\t  addRoot: function (el) {\n\t    if (el.__storage === this) {\n\t      return;\n\t    }\n\t\n\t    if (el instanceof Group) {\n\t      el.addChildrenToStorage(this);\n\t    }\n\t\n\t    this.addToStorage(el);\n\t\n\t    this._roots.push(el);\n\t  },\n\t\n\t  /**\n\t   * 删除指定的图形(Shape)或者组(Group)\n\t   * @param {string|Array.<string>} [el] 如果为空清空整个Storage\n\t   */\n\t  delRoot: function (el) {\n\t    if (el == null) {\n\t      // 不指定el清空\n\t      for (var i = 0; i < this._roots.length; i++) {\n\t        var root = this._roots[i];\n\t\n\t        if (root instanceof Group) {\n\t          root.delChildrenFromStorage(this);\n\t        }\n\t      }\n\t\n\t      this._roots = [];\n\t      this._displayList = [];\n\t      this._displayListLen = 0;\n\t      return;\n\t    }\n\t\n\t    if (el instanceof Array) {\n\t      for (var i = 0, l = el.length; i < l; i++) {\n\t        this.delRoot(el[i]);\n\t      }\n\t\n\t      return;\n\t    }\n\t\n\t    var idx = util.indexOf(this._roots, el);\n\t\n\t    if (idx >= 0) {\n\t      this.delFromStorage(el);\n\t\n\t      this._roots.splice(idx, 1);\n\t\n\t      if (el instanceof Group) {\n\t        el.delChildrenFromStorage(this);\n\t      }\n\t    }\n\t  },\n\t  addToStorage: function (el) {\n\t    el.__storage = this;\n\t    el.dirty(false);\n\t    return this;\n\t  },\n\t  delFromStorage: function (el) {\n\t    if (el) {\n\t      el.__storage = null;\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 清空并且释放Storage\n\t   */\n\t  dispose: function () {\n\t    this._renderList = this._roots = null;\n\t  },\n\t  displayableSortFunc: shapeCompareFunc\n\t};\n\tvar _default = Storage;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports) {\n\n\t// https://github.com/mziccard/node-timsort\n\tvar DEFAULT_MIN_MERGE = 32;\n\tvar DEFAULT_MIN_GALLOPING = 7;\n\tvar DEFAULT_TMP_STORAGE_LENGTH = 256;\n\t\n\tfunction minRunLength(n) {\n\t  var r = 0;\n\t\n\t  while (n >= DEFAULT_MIN_MERGE) {\n\t    r |= n & 1;\n\t    n >>= 1;\n\t  }\n\t\n\t  return n + r;\n\t}\n\t\n\tfunction makeAscendingRun(array, lo, hi, compare) {\n\t  var runHi = lo + 1;\n\t\n\t  if (runHi === hi) {\n\t    return 1;\n\t  }\n\t\n\t  if (compare(array[runHi++], array[lo]) < 0) {\n\t    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n\t      runHi++;\n\t    }\n\t\n\t    reverseRun(array, lo, runHi);\n\t  } else {\n\t    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n\t      runHi++;\n\t    }\n\t  }\n\t\n\t  return runHi - lo;\n\t}\n\t\n\tfunction reverseRun(array, lo, hi) {\n\t  hi--;\n\t\n\t  while (lo < hi) {\n\t    var t = array[lo];\n\t    array[lo++] = array[hi];\n\t    array[hi--] = t;\n\t  }\n\t}\n\t\n\tfunction binaryInsertionSort(array, lo, hi, start, compare) {\n\t  if (start === lo) {\n\t    start++;\n\t  }\n\t\n\t  for (; start < hi; start++) {\n\t    var pivot = array[start];\n\t    var left = lo;\n\t    var right = start;\n\t    var mid;\n\t\n\t    while (left < right) {\n\t      mid = left + right >>> 1;\n\t\n\t      if (compare(pivot, array[mid]) < 0) {\n\t        right = mid;\n\t      } else {\n\t        left = mid + 1;\n\t      }\n\t    }\n\t\n\t    var n = start - left;\n\t\n\t    switch (n) {\n\t      case 3:\n\t        array[left + 3] = array[left + 2];\n\t\n\t      case 2:\n\t        array[left + 2] = array[left + 1];\n\t\n\t      case 1:\n\t        array[left + 1] = array[left];\n\t        break;\n\t\n\t      default:\n\t        while (n > 0) {\n\t          array[left + n] = array[left + n - 1];\n\t          n--;\n\t        }\n\t\n\t    }\n\t\n\t    array[left] = pivot;\n\t  }\n\t}\n\t\n\tfunction gallopLeft(value, array, start, length, hint, compare) {\n\t  var lastOffset = 0;\n\t  var maxOffset = 0;\n\t  var offset = 1;\n\t\n\t  if (compare(value, array[start + hint]) > 0) {\n\t    maxOffset = length - hint;\n\t\n\t    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n\t      lastOffset = offset;\n\t      offset = (offset << 1) + 1;\n\t\n\t      if (offset <= 0) {\n\t        offset = maxOffset;\n\t      }\n\t    }\n\t\n\t    if (offset > maxOffset) {\n\t      offset = maxOffset;\n\t    }\n\t\n\t    lastOffset += hint;\n\t    offset += hint;\n\t  } else {\n\t    maxOffset = hint + 1;\n\t\n\t    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n\t      lastOffset = offset;\n\t      offset = (offset << 1) + 1;\n\t\n\t      if (offset <= 0) {\n\t        offset = maxOffset;\n\t      }\n\t    }\n\t\n\t    if (offset > maxOffset) {\n\t      offset = maxOffset;\n\t    }\n\t\n\t    var tmp = lastOffset;\n\t    lastOffset = hint - offset;\n\t    offset = hint - tmp;\n\t  }\n\t\n\t  lastOffset++;\n\t\n\t  while (lastOffset < offset) {\n\t    var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t    if (compare(value, array[start + m]) > 0) {\n\t      lastOffset = m + 1;\n\t    } else {\n\t      offset = m;\n\t    }\n\t  }\n\t\n\t  return offset;\n\t}\n\t\n\tfunction gallopRight(value, array, start, length, hint, compare) {\n\t  var lastOffset = 0;\n\t  var maxOffset = 0;\n\t  var offset = 1;\n\t\n\t  if (compare(value, array[start + hint]) < 0) {\n\t    maxOffset = hint + 1;\n\t\n\t    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n\t      lastOffset = offset;\n\t      offset = (offset << 1) + 1;\n\t\n\t      if (offset <= 0) {\n\t        offset = maxOffset;\n\t      }\n\t    }\n\t\n\t    if (offset > maxOffset) {\n\t      offset = maxOffset;\n\t    }\n\t\n\t    var tmp = lastOffset;\n\t    lastOffset = hint - offset;\n\t    offset = hint - tmp;\n\t  } else {\n\t    maxOffset = length - hint;\n\t\n\t    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n\t      lastOffset = offset;\n\t      offset = (offset << 1) + 1;\n\t\n\t      if (offset <= 0) {\n\t        offset = maxOffset;\n\t      }\n\t    }\n\t\n\t    if (offset > maxOffset) {\n\t      offset = maxOffset;\n\t    }\n\t\n\t    lastOffset += hint;\n\t    offset += hint;\n\t  }\n\t\n\t  lastOffset++;\n\t\n\t  while (lastOffset < offset) {\n\t    var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t    if (compare(value, array[start + m]) < 0) {\n\t      offset = m;\n\t    } else {\n\t      lastOffset = m + 1;\n\t    }\n\t  }\n\t\n\t  return offset;\n\t}\n\t\n\tfunction TimSort(array, compare) {\n\t  var minGallop = DEFAULT_MIN_GALLOPING;\n\t  var length = 0;\n\t  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n\t  var stackLength = 0;\n\t  var runStart;\n\t  var runLength;\n\t  var stackSize = 0;\n\t  length = array.length;\n\t\n\t  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n\t    tmpStorageLength = length >>> 1;\n\t  }\n\t\n\t  var tmp = [];\n\t  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\t  runStart = [];\n\t  runLength = [];\n\t\n\t  function pushRun(_runStart, _runLength) {\n\t    runStart[stackSize] = _runStart;\n\t    runLength[stackSize] = _runLength;\n\t    stackSize += 1;\n\t  }\n\t\n\t  function mergeRuns() {\n\t    while (stackSize > 1) {\n\t      var n = stackSize - 2;\n\t\n\t      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n\t        if (runLength[n - 1] < runLength[n + 1]) {\n\t          n--;\n\t        }\n\t      } else if (runLength[n] > runLength[n + 1]) {\n\t        break;\n\t      }\n\t\n\t      mergeAt(n);\n\t    }\n\t  }\n\t\n\t  function forceMergeRuns() {\n\t    while (stackSize > 1) {\n\t      var n = stackSize - 2;\n\t\n\t      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n\t        n--;\n\t      }\n\t\n\t      mergeAt(n);\n\t    }\n\t  }\n\t\n\t  function mergeAt(i) {\n\t    var start1 = runStart[i];\n\t    var length1 = runLength[i];\n\t    var start2 = runStart[i + 1];\n\t    var length2 = runLength[i + 1];\n\t    runLength[i] = length1 + length2;\n\t\n\t    if (i === stackSize - 3) {\n\t      runStart[i + 1] = runStart[i + 2];\n\t      runLength[i + 1] = runLength[i + 2];\n\t    }\n\t\n\t    stackSize--;\n\t    var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n\t    start1 += k;\n\t    length1 -= k;\n\t\n\t    if (length1 === 0) {\n\t      return;\n\t    }\n\t\n\t    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\t\n\t    if (length2 === 0) {\n\t      return;\n\t    }\n\t\n\t    if (length1 <= length2) {\n\t      mergeLow(start1, length1, start2, length2);\n\t    } else {\n\t      mergeHigh(start1, length1, start2, length2);\n\t    }\n\t  }\n\t\n\t  function mergeLow(start1, length1, start2, length2) {\n\t    var i = 0;\n\t\n\t    for (i = 0; i < length1; i++) {\n\t      tmp[i] = array[start1 + i];\n\t    }\n\t\n\t    var cursor1 = 0;\n\t    var cursor2 = start2;\n\t    var dest = start1;\n\t    array[dest++] = array[cursor2++];\n\t\n\t    if (--length2 === 0) {\n\t      for (i = 0; i < length1; i++) {\n\t        array[dest + i] = tmp[cursor1 + i];\n\t      }\n\t\n\t      return;\n\t    }\n\t\n\t    if (length1 === 1) {\n\t      for (i = 0; i < length2; i++) {\n\t        array[dest + i] = array[cursor2 + i];\n\t      }\n\t\n\t      array[dest + length2] = tmp[cursor1];\n\t      return;\n\t    }\n\t\n\t    var _minGallop = minGallop;\n\t    var count1, count2, exit;\n\t\n\t    while (1) {\n\t      count1 = 0;\n\t      count2 = 0;\n\t      exit = false;\n\t\n\t      do {\n\t        if (compare(array[cursor2], tmp[cursor1]) < 0) {\n\t          array[dest++] = array[cursor2++];\n\t          count2++;\n\t          count1 = 0;\n\t\n\t          if (--length2 === 0) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        } else {\n\t          array[dest++] = tmp[cursor1++];\n\t          count1++;\n\t          count2 = 0;\n\t\n\t          if (--length1 === 1) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t      } while ((count1 | count2) < _minGallop);\n\t\n\t      if (exit) {\n\t        break;\n\t      }\n\t\n\t      do {\n\t        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\t\n\t        if (count1 !== 0) {\n\t          for (i = 0; i < count1; i++) {\n\t            array[dest + i] = tmp[cursor1 + i];\n\t          }\n\t\n\t          dest += count1;\n\t          cursor1 += count1;\n\t          length1 -= count1;\n\t\n\t          if (length1 <= 1) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t\n\t        array[dest++] = array[cursor2++];\n\t\n\t        if (--length2 === 0) {\n\t          exit = true;\n\t          break;\n\t        }\n\t\n\t        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\t\n\t        if (count2 !== 0) {\n\t          for (i = 0; i < count2; i++) {\n\t            array[dest + i] = array[cursor2 + i];\n\t          }\n\t\n\t          dest += count2;\n\t          cursor2 += count2;\n\t          length2 -= count2;\n\t\n\t          if (length2 === 0) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t\n\t        array[dest++] = tmp[cursor1++];\n\t\n\t        if (--length1 === 1) {\n\t          exit = true;\n\t          break;\n\t        }\n\t\n\t        _minGallop--;\n\t      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t      if (exit) {\n\t        break;\n\t      }\n\t\n\t      if (_minGallop < 0) {\n\t        _minGallop = 0;\n\t      }\n\t\n\t      _minGallop += 2;\n\t    }\n\t\n\t    minGallop = _minGallop;\n\t    minGallop < 1 && (minGallop = 1);\n\t\n\t    if (length1 === 1) {\n\t      for (i = 0; i < length2; i++) {\n\t        array[dest + i] = array[cursor2 + i];\n\t      }\n\t\n\t      array[dest + length2] = tmp[cursor1];\n\t    } else if (length1 === 0) {\n\t      throw new Error(); // throw new Error('mergeLow preconditions were not respected');\n\t    } else {\n\t      for (i = 0; i < length1; i++) {\n\t        array[dest + i] = tmp[cursor1 + i];\n\t      }\n\t    }\n\t  }\n\t\n\t  function mergeHigh(start1, length1, start2, length2) {\n\t    var i = 0;\n\t\n\t    for (i = 0; i < length2; i++) {\n\t      tmp[i] = array[start2 + i];\n\t    }\n\t\n\t    var cursor1 = start1 + length1 - 1;\n\t    var cursor2 = length2 - 1;\n\t    var dest = start2 + length2 - 1;\n\t    var customCursor = 0;\n\t    var customDest = 0;\n\t    array[dest--] = array[cursor1--];\n\t\n\t    if (--length1 === 0) {\n\t      customCursor = dest - (length2 - 1);\n\t\n\t      for (i = 0; i < length2; i++) {\n\t        array[customCursor + i] = tmp[i];\n\t      }\n\t\n\t      return;\n\t    }\n\t\n\t    if (length2 === 1) {\n\t      dest -= length1;\n\t      cursor1 -= length1;\n\t      customDest = dest + 1;\n\t      customCursor = cursor1 + 1;\n\t\n\t      for (i = length1 - 1; i >= 0; i--) {\n\t        array[customDest + i] = array[customCursor + i];\n\t      }\n\t\n\t      array[dest] = tmp[cursor2];\n\t      return;\n\t    }\n\t\n\t    var _minGallop = minGallop;\n\t\n\t    while (true) {\n\t      var count1 = 0;\n\t      var count2 = 0;\n\t      var exit = false;\n\t\n\t      do {\n\t        if (compare(tmp[cursor2], array[cursor1]) < 0) {\n\t          array[dest--] = array[cursor1--];\n\t          count1++;\n\t          count2 = 0;\n\t\n\t          if (--length1 === 0) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        } else {\n\t          array[dest--] = tmp[cursor2--];\n\t          count2++;\n\t          count1 = 0;\n\t\n\t          if (--length2 === 1) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t      } while ((count1 | count2) < _minGallop);\n\t\n\t      if (exit) {\n\t        break;\n\t      }\n\t\n\t      do {\n\t        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\t\n\t        if (count1 !== 0) {\n\t          dest -= count1;\n\t          cursor1 -= count1;\n\t          length1 -= count1;\n\t          customDest = dest + 1;\n\t          customCursor = cursor1 + 1;\n\t\n\t          for (i = count1 - 1; i >= 0; i--) {\n\t            array[customDest + i] = array[customCursor + i];\n\t          }\n\t\n\t          if (length1 === 0) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t\n\t        array[dest--] = tmp[cursor2--];\n\t\n\t        if (--length2 === 1) {\n\t          exit = true;\n\t          break;\n\t        }\n\t\n\t        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\t\n\t        if (count2 !== 0) {\n\t          dest -= count2;\n\t          cursor2 -= count2;\n\t          length2 -= count2;\n\t          customDest = dest + 1;\n\t          customCursor = cursor2 + 1;\n\t\n\t          for (i = 0; i < count2; i++) {\n\t            array[customDest + i] = tmp[customCursor + i];\n\t          }\n\t\n\t          if (length2 <= 1) {\n\t            exit = true;\n\t            break;\n\t          }\n\t        }\n\t\n\t        array[dest--] = array[cursor1--];\n\t\n\t        if (--length1 === 0) {\n\t          exit = true;\n\t          break;\n\t        }\n\t\n\t        _minGallop--;\n\t      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t      if (exit) {\n\t        break;\n\t      }\n\t\n\t      if (_minGallop < 0) {\n\t        _minGallop = 0;\n\t      }\n\t\n\t      _minGallop += 2;\n\t    }\n\t\n\t    minGallop = _minGallop;\n\t\n\t    if (minGallop < 1) {\n\t      minGallop = 1;\n\t    }\n\t\n\t    if (length2 === 1) {\n\t      dest -= length1;\n\t      cursor1 -= length1;\n\t      customDest = dest + 1;\n\t      customCursor = cursor1 + 1;\n\t\n\t      for (i = length1 - 1; i >= 0; i--) {\n\t        array[customDest + i] = array[customCursor + i];\n\t      }\n\t\n\t      array[dest] = tmp[cursor2];\n\t    } else if (length2 === 0) {\n\t      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');\n\t    } else {\n\t      customCursor = dest - (length2 - 1);\n\t\n\t      for (i = 0; i < length2; i++) {\n\t        array[customCursor + i] = tmp[i];\n\t      }\n\t    }\n\t  }\n\t\n\t  this.mergeRuns = mergeRuns;\n\t  this.forceMergeRuns = forceMergeRuns;\n\t  this.pushRun = pushRun;\n\t}\n\t\n\tfunction sort(array, compare, lo, hi) {\n\t  if (!lo) {\n\t    lo = 0;\n\t  }\n\t\n\t  if (!hi) {\n\t    hi = array.length;\n\t  }\n\t\n\t  var remaining = hi - lo;\n\t\n\t  if (remaining < 2) {\n\t    return;\n\t  }\n\t\n\t  var runLength = 0;\n\t\n\t  if (remaining < DEFAULT_MIN_MERGE) {\n\t    runLength = makeAscendingRun(array, lo, hi, compare);\n\t    binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n\t    return;\n\t  }\n\t\n\t  var ts = new TimSort(array, compare);\n\t  var minRun = minRunLength(remaining);\n\t\n\t  do {\n\t    runLength = makeAscendingRun(array, lo, hi, compare);\n\t\n\t    if (runLength < minRun) {\n\t      var force = remaining;\n\t\n\t      if (force > minRun) {\n\t        force = minRun;\n\t      }\n\t\n\t      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n\t      runLength = force;\n\t    }\n\t\n\t    ts.pushRun(lo, runLength);\n\t    ts.mergeRuns();\n\t    remaining -= runLength;\n\t    lo += runLength;\n\t  } while (remaining !== 0);\n\t\n\t  ts.forceMergeRuns();\n\t}\n\t\n\tmodule.exports = sort;\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _config = __webpack_require__(22);\n\t\n\tvar devicePixelRatio = _config.devicePixelRatio;\n\t\n\tvar util = __webpack_require__(4);\n\t\n\tvar log = __webpack_require__(21);\n\t\n\tvar BoundingRect = __webpack_require__(26);\n\t\n\tvar timsort = __webpack_require__(70);\n\t\n\tvar Layer = __webpack_require__(72);\n\t\n\tvar requestAnimationFrame = __webpack_require__(73);\n\t\n\tvar Image = __webpack_require__(44);\n\t\n\t/**\n\t * Default canvas painter\n\t * @module zrender/Painter\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t// PENDIGN\n\t// Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n\t//\n\t// Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n\tvar MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\t\n\tfunction parseInt10(val) {\n\t  return parseInt(val, 10);\n\t}\n\t\n\tfunction isLayerValid(layer) {\n\t  if (!layer) {\n\t    return false;\n\t  }\n\t\n\t  if (layer.__builtin__) {\n\t    return true;\n\t  }\n\t\n\t  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n\t    return false;\n\t  }\n\t\n\t  return true;\n\t}\n\t\n\tfunction preProcessLayer(layer) {\n\t  layer.__unusedCount++;\n\t}\n\t\n\tfunction postProcessLayer(layer) {\n\t  if (layer.__unusedCount == 1) {\n\t    layer.clear();\n\t  }\n\t}\n\t\n\tvar tmpRect = new BoundingRect(0, 0, 0, 0);\n\tvar viewRect = new BoundingRect(0, 0, 0, 0);\n\t\n\tfunction isDisplayableCulled(el, width, height) {\n\t  tmpRect.copy(el.getBoundingRect());\n\t\n\t  if (el.transform) {\n\t    tmpRect.applyTransform(el.transform);\n\t  }\n\t\n\t  viewRect.width = width;\n\t  viewRect.height = height;\n\t  return !tmpRect.intersect(viewRect);\n\t}\n\t\n\tfunction isClipPathChanged(clipPaths, prevClipPaths) {\n\t  if (clipPaths == prevClipPaths) {\n\t    // Can both be null or undefined\n\t    return false;\n\t  }\n\t\n\t  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n\t    return true;\n\t  }\n\t\n\t  for (var i = 0; i < clipPaths.length; i++) {\n\t    if (clipPaths[i] !== prevClipPaths[i]) {\n\t      return true;\n\t    }\n\t  }\n\t}\n\t\n\tfunction doClip(clipPaths, ctx) {\n\t  for (var i = 0; i < clipPaths.length; i++) {\n\t    var clipPath = clipPaths[i];\n\t    clipPath.setTransform(ctx);\n\t    ctx.beginPath();\n\t    clipPath.buildPath(ctx, clipPath.shape);\n\t    ctx.clip(); // Transform back\n\t\n\t    clipPath.restoreTransform(ctx);\n\t  }\n\t}\n\t\n\tfunction createRoot(width, height) {\n\t  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n\t\n\t  domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';\n\t  return domRoot;\n\t}\n\t/**\n\t * @alias module:zrender/Painter\n\t * @constructor\n\t * @param {HTMLElement} root 绘图容器\n\t * @param {module:zrender/Storage} storage\n\t * @param {Object} opts\n\t */\n\t\n\t\n\tvar Painter = function (root, storage, opts) {\n\t  this.type = 'canvas'; // In node environment using node-canvas\n\t\n\t  var singleCanvas = !root.nodeName // In node ?\n\t  || root.nodeName.toUpperCase() === 'CANVAS';\n\t  this._opts = opts = util.extend({}, opts || {});\n\t  /**\n\t   * @type {number}\n\t   */\n\t\n\t  this.dpr = opts.devicePixelRatio || devicePixelRatio;\n\t  /**\n\t   * @type {boolean}\n\t   * @private\n\t   */\n\t\n\t  this._singleCanvas = singleCanvas;\n\t  /**\n\t   * 绘图容器\n\t   * @type {HTMLElement}\n\t   */\n\t\n\t  this.root = root;\n\t  var rootStyle = root.style;\n\t\n\t  if (rootStyle) {\n\t    rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n\t    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n\t    root.innerHTML = '';\n\t  }\n\t  /**\n\t   * @type {module:zrender/Storage}\n\t   */\n\t\n\t\n\t  this.storage = storage;\n\t  /**\n\t   * @type {Array.<number>}\n\t   * @private\n\t   */\n\t\n\t  var zlevelList = this._zlevelList = [];\n\t  /**\n\t   * @type {Object.<string, module:zrender/Layer>}\n\t   * @private\n\t   */\n\t\n\t  var layers = this._layers = {};\n\t  /**\n\t   * @type {Object.<string, Object>}\n\t   * @type {private}\n\t   */\n\t\n\t  this._layerConfig = {};\n\t\n\t  if (!singleCanvas) {\n\t    this._width = this._getSize(0);\n\t    this._height = this._getSize(1);\n\t    var domRoot = this._domRoot = createRoot(this._width, this._height);\n\t    root.appendChild(domRoot);\n\t  } else {\n\t    if (opts.width != null) {\n\t      root.width = opts.width;\n\t    }\n\t\n\t    if (opts.height != null) {\n\t      root.height = opts.height;\n\t    } // Use canvas width and height directly\n\t\n\t\n\t    var width = root.width;\n\t    var height = root.height;\n\t    this._width = width;\n\t    this._height = height; // Create layer if only one given canvas\n\t    // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\t\n\t    var mainLayer = new Layer(root, this, 1);\n\t    mainLayer.initContext(); // FIXME Use canvas width and height\n\t    // mainLayer.resize(width, height);\n\t\n\t    layers[0] = mainLayer;\n\t    zlevelList.push(0);\n\t    this._domRoot = root;\n\t  } // Layers for progressive rendering\n\t\n\t\n\t  this._progressiveLayers = [];\n\t  /**\n\t   * @type {module:zrender/Layer}\n\t   * @private\n\t   */\n\t\n\t  this._hoverlayer;\n\t  this._hoverElements = [];\n\t};\n\t\n\tPainter.prototype = {\n\t  constructor: Painter,\n\t  getType: function () {\n\t    return 'canvas';\n\t  },\n\t\n\t  /**\n\t   * If painter use a single canvas\n\t   * @return {boolean}\n\t   */\n\t  isSingleCanvas: function () {\n\t    return this._singleCanvas;\n\t  },\n\t\n\t  /**\n\t   * @return {HTMLDivElement}\n\t   */\n\t  getViewportRoot: function () {\n\t    return this._domRoot;\n\t  },\n\t  getViewportRootOffset: function () {\n\t    var viewportRoot = this.getViewportRoot();\n\t\n\t    if (viewportRoot) {\n\t      return {\n\t        offsetLeft: viewportRoot.offsetLeft || 0,\n\t        offsetTop: viewportRoot.offsetTop || 0\n\t      };\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 刷新\n\t   * @param {boolean} [paintAll=false] 强制绘制所有displayable\n\t   */\n\t  refresh: function (paintAll) {\n\t    var list = this.storage.getDisplayList(true);\n\t    var zlevelList = this._zlevelList;\n\t\n\t    this._paintList(list, paintAll); // Paint custum layers\n\t\n\t\n\t    for (var i = 0; i < zlevelList.length; i++) {\n\t      var z = zlevelList[i];\n\t      var layer = this._layers[z];\n\t\n\t      if (!layer.__builtin__ && layer.refresh) {\n\t        layer.refresh();\n\t      }\n\t    }\n\t\n\t    this.refreshHover();\n\t\n\t    if (this._progressiveLayers.length) {\n\t      this._startProgessive();\n\t    }\n\t\n\t    return this;\n\t  },\n\t  addHover: function (el, hoverStyle) {\n\t    if (el.__hoverMir) {\n\t      return;\n\t    }\n\t\n\t    var elMirror = new el.constructor({\n\t      style: el.style,\n\t      shape: el.shape\n\t    });\n\t    elMirror.__from = el;\n\t    el.__hoverMir = elMirror;\n\t    elMirror.setStyle(hoverStyle);\n\t\n\t    this._hoverElements.push(elMirror);\n\t  },\n\t  removeHover: function (el) {\n\t    var elMirror = el.__hoverMir;\n\t    var hoverElements = this._hoverElements;\n\t    var idx = util.indexOf(hoverElements, elMirror);\n\t\n\t    if (idx >= 0) {\n\t      hoverElements.splice(idx, 1);\n\t    }\n\t\n\t    el.__hoverMir = null;\n\t  },\n\t  clearHover: function (el) {\n\t    var hoverElements = this._hoverElements;\n\t\n\t    for (var i = 0; i < hoverElements.length; i++) {\n\t      var from = hoverElements[i].__from;\n\t\n\t      if (from) {\n\t        from.__hoverMir = null;\n\t      }\n\t    }\n\t\n\t    hoverElements.length = 0;\n\t  },\n\t  refreshHover: function () {\n\t    var hoverElements = this._hoverElements;\n\t    var len = hoverElements.length;\n\t    var hoverLayer = this._hoverlayer;\n\t    hoverLayer && hoverLayer.clear();\n\t\n\t    if (!len) {\n\t      return;\n\t    }\n\t\n\t    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel\n\t    // FIXME?\n\t\n\t    if (!hoverLayer) {\n\t      hoverLayer = this._hoverlayer = this.getLayer(1e5);\n\t    }\n\t\n\t    var scope = {};\n\t    hoverLayer.ctx.save();\n\t\n\t    for (var i = 0; i < len;) {\n\t      var el = hoverElements[i];\n\t      var originalEl = el.__from; // Original el is removed\n\t      // PENDING\n\t\n\t      if (!(originalEl && originalEl.__zr)) {\n\t        hoverElements.splice(i, 1);\n\t        originalEl.__hoverMir = null;\n\t        len--;\n\t        continue;\n\t      }\n\t\n\t      i++; // Use transform\n\t      // FIXME style and shape ?\n\t\n\t      if (!originalEl.invisible) {\n\t        el.transform = originalEl.transform;\n\t        el.invTransform = originalEl.invTransform;\n\t        el.__clipPaths = originalEl.__clipPaths; // el.\n\t\n\t        this._doPaintEl(el, hoverLayer, true, scope);\n\t      }\n\t    }\n\t\n\t    hoverLayer.ctx.restore();\n\t  },\n\t  _startProgessive: function () {\n\t    var self = this;\n\t\n\t    if (!self._furtherProgressive) {\n\t      return;\n\t    } // Use a token to stop progress steps triggered by\n\t    // previous zr.refresh calling.\n\t\n\t\n\t    var token = self._progressiveToken = +new Date();\n\t    self._progress++;\n\t    requestAnimationFrame(step);\n\t\n\t    function step() {\n\t      // In case refreshed or disposed\n\t      if (token === self._progressiveToken && self.storage) {\n\t        self._doPaintList(self.storage.getDisplayList());\n\t\n\t        if (self._furtherProgressive) {\n\t          self._progress++;\n\t          requestAnimationFrame(step);\n\t        } else {\n\t          self._progressiveToken = -1;\n\t        }\n\t      }\n\t    }\n\t  },\n\t  _clearProgressive: function () {\n\t    this._progressiveToken = -1;\n\t    this._progress = 0;\n\t    util.each(this._progressiveLayers, function (layer) {\n\t      layer.__dirty && layer.clear();\n\t    });\n\t  },\n\t  _paintList: function (list, paintAll) {\n\t    if (paintAll == null) {\n\t      paintAll = false;\n\t    }\n\t\n\t    this._updateLayerStatus(list);\n\t\n\t    this._clearProgressive();\n\t\n\t    this.eachBuiltinLayer(preProcessLayer);\n\t\n\t    this._doPaintList(list, paintAll);\n\t\n\t    this.eachBuiltinLayer(postProcessLayer);\n\t  },\n\t  _doPaintList: function (list, paintAll) {\n\t    var currentLayer;\n\t    var currentZLevel;\n\t    var ctx; // var invTransform = [];\n\t\n\t    var scope;\n\t    var progressiveLayerIdx = 0;\n\t    var currentProgressiveLayer;\n\t    var width = this._width;\n\t    var height = this._height;\n\t    var layerProgress;\n\t    var frame = this._progress;\n\t\n\t    function flushProgressiveLayer(layer) {\n\t      var dpr = ctx.dpr || 1;\n\t      ctx.save();\n\t      ctx.globalAlpha = 1;\n\t      ctx.shadowBlur = 0; // Avoid layer don't clear in next progressive frame\n\t\n\t      currentLayer.__dirty = true;\n\t      ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t      ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n\t      ctx.restore();\n\t    }\n\t\n\t    for (var i = 0, l = list.length; i < l; i++) {\n\t      var el = list[i];\n\t      var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\t      var elFrame = el.__frame; // Flush at current context\n\t      // PENDING\n\t\n\t      if (elFrame < 0 && currentProgressiveLayer) {\n\t        flushProgressiveLayer(currentProgressiveLayer);\n\t        currentProgressiveLayer = null;\n\t      } // Change draw layer\n\t\n\t\n\t      if (currentZLevel !== elZLevel) {\n\t        if (ctx) {\n\t          ctx.restore();\n\t        } // Reset scope\n\t\n\t\n\t        scope = {}; // Only 0 zlevel if only has one canvas\n\t\n\t        currentZLevel = elZLevel;\n\t        currentLayer = this.getLayer(currentZLevel);\n\t\n\t        if (!currentLayer.__builtin__) {\n\t          log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);\n\t        }\n\t\n\t        ctx = currentLayer.ctx;\n\t        ctx.save(); // Reset the count\n\t\n\t        currentLayer.__unusedCount = 0;\n\t\n\t        if (currentLayer.__dirty || paintAll) {\n\t          currentLayer.clear();\n\t        }\n\t      }\n\t\n\t      if (!(currentLayer.__dirty || paintAll)) {\n\t        continue;\n\t      }\n\t\n\t      if (elFrame >= 0) {\n\t        // Progressive layer changed\n\t        if (!currentProgressiveLayer) {\n\t          currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];\n\t          currentProgressiveLayer.ctx.save();\n\t          currentProgressiveLayer.renderScope = {};\n\t\n\t          if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {\n\t            // flushProgressiveLayer(currentProgressiveLayer);\n\t            // Quick jump all progressive elements\n\t            // All progressive element are not dirty, jump over and flush directly\n\t            i = currentProgressiveLayer.__nextIdxNotProg - 1; // currentProgressiveLayer = null;\n\t\n\t            continue;\n\t          }\n\t\n\t          layerProgress = currentProgressiveLayer.__progress;\n\t\n\t          if (!currentProgressiveLayer.__dirty) {\n\t            // Keep rendering\n\t            frame = layerProgress;\n\t          }\n\t\n\t          currentProgressiveLayer.__progress = frame + 1;\n\t        }\n\t\n\t        if (elFrame === frame) {\n\t          this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n\t        }\n\t      } else {\n\t        this._doPaintEl(el, currentLayer, paintAll, scope);\n\t      }\n\t\n\t      el.__dirty = false;\n\t    }\n\t\n\t    if (currentProgressiveLayer) {\n\t      flushProgressiveLayer(currentProgressiveLayer);\n\t    } // Restore the lastLayer ctx\n\t\n\t\n\t    ctx && ctx.restore(); // If still has clipping state\n\t    // if (scope.prevElClipPaths) {\n\t    //     ctx.restore();\n\t    // }\n\t\n\t    this._furtherProgressive = false;\n\t    util.each(this._progressiveLayers, function (layer) {\n\t      if (layer.__maxProgress >= layer.__progress) {\n\t        this._furtherProgressive = true;\n\t      }\n\t    }, this);\n\t  },\n\t  _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n\t    var ctx = currentLayer.ctx;\n\t    var m = el.transform;\n\t\n\t    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element\n\t    !el.invisible // Ignore transparent element\n\t    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas\n\t    // Draw a scale 0 element can cause all following draw wrong\n\t    // And setTransform with scale 0 will cause set back transform failed.\n\t    && !(m && !m[0] && !m[3]) // Ignore culled element\n\t    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n\t      var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements\n\t\n\t      if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {\n\t        // If has previous clipping state, restore from it\n\t        if (scope.prevElClipPaths) {\n\t          scope.prevClipLayer.ctx.restore();\n\t          scope.prevClipLayer = scope.prevElClipPaths = null; // Reset prevEl since context has been restored\n\t\n\t          scope.prevEl = null;\n\t        } // New clipping state\n\t\n\t\n\t        if (clipPaths) {\n\t          ctx.save();\n\t          doClip(clipPaths, ctx);\n\t          scope.prevClipLayer = currentLayer;\n\t          scope.prevElClipPaths = clipPaths;\n\t        }\n\t      }\n\t\n\t      el.beforeBrush && el.beforeBrush(ctx);\n\t      el.brush(ctx, scope.prevEl || null);\n\t      scope.prevEl = el;\n\t      el.afterBrush && el.afterBrush(ctx);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n\t   * @param {number} zlevel\n\t   * @return {module:zrender/Layer}\n\t   */\n\t  getLayer: function (zlevel) {\n\t    if (this._singleCanvas) {\n\t      return this._layers[0];\n\t    }\n\t\n\t    var layer = this._layers[zlevel];\n\t\n\t    if (!layer) {\n\t      // Create a new layer\n\t      layer = new Layer('zr_' + zlevel, this, this.dpr);\n\t      layer.__builtin__ = true;\n\t\n\t      if (this._layerConfig[zlevel]) {\n\t        util.merge(layer, this._layerConfig[zlevel], true);\n\t      }\n\t\n\t      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document\n\t      // Or excanvas will get 0px clientWidth and clientHeight\n\t\n\t      layer.initContext();\n\t    }\n\t\n\t    return layer;\n\t  },\n\t  insertLayer: function (zlevel, layer) {\n\t    var layersMap = this._layers;\n\t    var zlevelList = this._zlevelList;\n\t    var len = zlevelList.length;\n\t    var prevLayer = null;\n\t    var i = -1;\n\t    var domRoot = this._domRoot;\n\t\n\t    if (layersMap[zlevel]) {\n\t      log('ZLevel ' + zlevel + ' has been used already');\n\t      return;\n\t    } // Check if is a valid layer\n\t\n\t\n\t    if (!isLayerValid(layer)) {\n\t      log('Layer of zlevel ' + zlevel + ' is not valid');\n\t      return;\n\t    }\n\t\n\t    if (len > 0 && zlevel > zlevelList[0]) {\n\t      for (i = 0; i < len - 1; i++) {\n\t        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n\t          break;\n\t        }\n\t      }\n\t\n\t      prevLayer = layersMap[zlevelList[i]];\n\t    }\n\t\n\t    zlevelList.splice(i + 1, 0, zlevel);\n\t    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.\n\t    // (It can be a WebGL layer and assigned to a ZImage element)\n\t    // But it still under management of zrender.\n\t\n\t    if (!layer.virtual) {\n\t      if (prevLayer) {\n\t        var prevDom = prevLayer.dom;\n\t\n\t        if (prevDom.nextSibling) {\n\t          domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n\t        } else {\n\t          domRoot.appendChild(layer.dom);\n\t        }\n\t      } else {\n\t        if (domRoot.firstChild) {\n\t          domRoot.insertBefore(layer.dom, domRoot.firstChild);\n\t        } else {\n\t          domRoot.appendChild(layer.dom);\n\t        }\n\t      }\n\t    }\n\t  },\n\t  // Iterate each layer\n\t  eachLayer: function (cb, context) {\n\t    var zlevelList = this._zlevelList;\n\t    var z;\n\t    var i;\n\t\n\t    for (i = 0; i < zlevelList.length; i++) {\n\t      z = zlevelList[i];\n\t      cb.call(context, this._layers[z], z);\n\t    }\n\t  },\n\t  // Iterate each buildin layer\n\t  eachBuiltinLayer: function (cb, context) {\n\t    var zlevelList = this._zlevelList;\n\t    var layer;\n\t    var z;\n\t    var i;\n\t\n\t    for (i = 0; i < zlevelList.length; i++) {\n\t      z = zlevelList[i];\n\t      layer = this._layers[z];\n\t\n\t      if (layer.__builtin__) {\n\t        cb.call(context, layer, z);\n\t      }\n\t    }\n\t  },\n\t  // Iterate each other layer except buildin layer\n\t  eachOtherLayer: function (cb, context) {\n\t    var zlevelList = this._zlevelList;\n\t    var layer;\n\t    var z;\n\t    var i;\n\t\n\t    for (i = 0; i < zlevelList.length; i++) {\n\t      z = zlevelList[i];\n\t      layer = this._layers[z];\n\t\n\t      if (!layer.__builtin__) {\n\t        cb.call(context, layer, z);\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 获取所有已创建的层\n\t   * @param {Array.<module:zrender/Layer>} [prevLayer]\n\t   */\n\t  getLayers: function () {\n\t    return this._layers;\n\t  },\n\t  _updateLayerStatus: function (list) {\n\t    var layers = this._layers;\n\t    var progressiveLayers = this._progressiveLayers;\n\t    var elCountsLastFrame = {};\n\t    var progressiveElCountsLastFrame = {};\n\t    this.eachBuiltinLayer(function (layer, z) {\n\t      elCountsLastFrame[z] = layer.elCount;\n\t      layer.elCount = 0;\n\t      layer.__dirty = false;\n\t    });\n\t    util.each(progressiveLayers, function (layer, idx) {\n\t      progressiveElCountsLastFrame[idx] = layer.elCount;\n\t      layer.elCount = 0;\n\t      layer.__dirty = false;\n\t    });\n\t    var progressiveLayerCount = 0;\n\t    var currentProgressiveLayer;\n\t    var lastProgressiveKey;\n\t    var frameCount = 0;\n\t\n\t    for (var i = 0, l = list.length; i < l; i++) {\n\t      var el = list[i];\n\t      var zlevel = this._singleCanvas ? 0 : el.zlevel;\n\t      var layer = layers[zlevel];\n\t      var elProgress = el.progressive;\n\t\n\t      if (layer) {\n\t        layer.elCount++;\n\t        layer.__dirty = layer.__dirty || el.__dirty;\n\t      } /////// Update progressive\n\t\n\t\n\t      if (elProgress >= 0) {\n\t        // Fix wrong progressive sequence problem.\n\t        if (lastProgressiveKey !== elProgress) {\n\t          lastProgressiveKey = elProgress;\n\t          frameCount++;\n\t        }\n\t\n\t        var elFrame = el.__frame = frameCount - 1;\n\t\n\t        if (!currentProgressiveLayer) {\n\t          var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n\t          currentProgressiveLayer = progressiveLayers[idx];\n\t\n\t          if (!currentProgressiveLayer) {\n\t            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);\n\t            currentProgressiveLayer.initContext();\n\t          }\n\t\n\t          currentProgressiveLayer.__maxProgress = 0;\n\t        }\n\t\n\t        currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n\t        currentProgressiveLayer.elCount++;\n\t        currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);\n\t\n\t        if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n\t          // Should keep rendering this  layer because progressive rendering is not finished yet\n\t          layer.__dirty = true;\n\t        }\n\t      } else {\n\t        el.__frame = -1;\n\t\n\t        if (currentProgressiveLayer) {\n\t          currentProgressiveLayer.__nextIdxNotProg = i;\n\t          progressiveLayerCount++;\n\t          currentProgressiveLayer = null;\n\t        }\n\t      }\n\t    }\n\t\n\t    if (currentProgressiveLayer) {\n\t      progressiveLayerCount++;\n\t      currentProgressiveLayer.__nextIdxNotProg = i;\n\t    } // 层中的元素数量有发生变化\n\t\n\t\n\t    this.eachBuiltinLayer(function (layer, z) {\n\t      if (elCountsLastFrame[z] !== layer.elCount) {\n\t        layer.__dirty = true;\n\t      }\n\t    });\n\t    progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n\t    util.each(progressiveLayers, function (layer, idx) {\n\t      if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n\t        el.__dirty = true;\n\t      }\n\t\n\t      if (layer.__dirty) {\n\t        layer.__progress = 0;\n\t      }\n\t    });\n\t  },\n\t\n\t  /**\n\t   * 清除hover层外所有内容\n\t   */\n\t  clear: function () {\n\t    this.eachBuiltinLayer(this._clearLayer);\n\t    return this;\n\t  },\n\t  _clearLayer: function (layer) {\n\t    layer.clear();\n\t  },\n\t\n\t  /**\n\t   * 修改指定zlevel的绘制参数\n\t   *\n\t   * @param {string} zlevel\n\t   * @param {Object} config 配置对象\n\t   * @param {string} [config.clearColor=0] 每次清空画布的颜色\n\t   * @param {string} [config.motionBlur=false] 是否开启动态模糊\n\t   * @param {number} [config.lastFrameAlpha=0.7]\n\t   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n\t   */\n\t  configLayer: function (zlevel, config) {\n\t    if (config) {\n\t      var layerConfig = this._layerConfig;\n\t\n\t      if (!layerConfig[zlevel]) {\n\t        layerConfig[zlevel] = config;\n\t      } else {\n\t        util.merge(layerConfig[zlevel], config, true);\n\t      }\n\t\n\t      var layer = this._layers[zlevel];\n\t\n\t      if (layer) {\n\t        util.merge(layer, layerConfig[zlevel], true);\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 删除指定层\n\t   * @param {number} zlevel 层所在的zlevel\n\t   */\n\t  delLayer: function (zlevel) {\n\t    var layers = this._layers;\n\t    var zlevelList = this._zlevelList;\n\t    var layer = layers[zlevel];\n\t\n\t    if (!layer) {\n\t      return;\n\t    }\n\t\n\t    layer.dom.parentNode.removeChild(layer.dom);\n\t    delete layers[zlevel];\n\t    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n\t  },\n\t\n\t  /**\n\t   * 区域大小变化后重绘\n\t   */\n\t  resize: function (width, height) {\n\t    var domRoot = this._domRoot; // FIXME Why ?\n\t\n\t    domRoot.style.display = 'none'; // Save input w/h\n\t\n\t    var opts = this._opts;\n\t    width != null && (opts.width = width);\n\t    height != null && (opts.height = height);\n\t    width = this._getSize(0);\n\t    height = this._getSize(1);\n\t    domRoot.style.display = ''; // 优化没有实际改变的resize\n\t\n\t    if (this._width != width || height != this._height) {\n\t      domRoot.style.width = width + 'px';\n\t      domRoot.style.height = height + 'px';\n\t\n\t      for (var id in this._layers) {\n\t        if (this._layers.hasOwnProperty(id)) {\n\t          this._layers[id].resize(width, height);\n\t        }\n\t      }\n\t\n\t      util.each(this._progressiveLayers, function (layer) {\n\t        layer.resize(width, height);\n\t      });\n\t      this.refresh(true);\n\t    }\n\t\n\t    this._width = width;\n\t    this._height = height;\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * 清除单独的一个层\n\t   * @param {number} zlevel\n\t   */\n\t  clearLayer: function (zlevel) {\n\t    var layer = this._layers[zlevel];\n\t\n\t    if (layer) {\n\t      layer.clear();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 释放\n\t   */\n\t  dispose: function () {\n\t    this.root.innerHTML = '';\n\t    this.root = this.storage = this._domRoot = this._layers = null;\n\t  },\n\t\n\t  /**\n\t   * Get canvas which has all thing rendered\n\t   * @param {Object} opts\n\t   * @param {string} [opts.backgroundColor]\n\t   * @param {number} [opts.pixelRatio]\n\t   */\n\t  getRenderedCanvas: function (opts) {\n\t    opts = opts || {};\n\t\n\t    if (this._singleCanvas) {\n\t      return this._layers[0].dom;\n\t    }\n\t\n\t    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n\t    imageLayer.initContext();\n\t    imageLayer.clearColor = opts.backgroundColor;\n\t    imageLayer.clear();\n\t    var displayList = this.storage.getDisplayList(true);\n\t    var scope = {};\n\t    var zlevel;\n\t    var self = this;\n\t\n\t    function findAndDrawOtherLayer(smaller, larger) {\n\t      var zlevelList = self._zlevelList;\n\t\n\t      if (smaller == null) {\n\t        smaller = -Infinity;\n\t      }\n\t\n\t      var intermediateLayer;\n\t\n\t      for (var i = 0; i < zlevelList.length; i++) {\n\t        var z = zlevelList[i];\n\t        var layer = self._layers[z];\n\t\n\t        if (!layer.__builtin__ && z > smaller && z < larger) {\n\t          intermediateLayer = layer;\n\t          break;\n\t        }\n\t      }\n\t\n\t      if (intermediateLayer && intermediateLayer.renderToCanvas) {\n\t        imageLayer.ctx.save();\n\t        intermediateLayer.renderToCanvas(imageLayer.ctx);\n\t        imageLayer.ctx.restore();\n\t      }\n\t    }\n\t\n\t    for (var i = 0; i < displayList.length; i++) {\n\t      var el = displayList[i];\n\t\n\t      if (el.zlevel !== zlevel) {\n\t        findAndDrawOtherLayer(zlevel, el.zlevel);\n\t        zlevel = el.zlevel;\n\t      }\n\t\n\t      this._doPaintEl(el, imageLayer, true, scope);\n\t    }\n\t\n\t    findAndDrawOtherLayer(zlevel, Infinity);\n\t    return imageLayer.dom;\n\t  },\n\t\n\t  /**\n\t   * 获取绘图区域宽度\n\t   */\n\t  getWidth: function () {\n\t    return this._width;\n\t  },\n\t\n\t  /**\n\t   * 获取绘图区域高度\n\t   */\n\t  getHeight: function () {\n\t    return this._height;\n\t  },\n\t  _getSize: function (whIdx) {\n\t    var opts = this._opts;\n\t    var wh = ['width', 'height'][whIdx];\n\t    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n\t    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n\t    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\t\n\t    if (opts[wh] != null && opts[wh] !== 'auto') {\n\t      return parseFloat(opts[wh]);\n\t    }\n\t\n\t    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\t\n\t    var stl = document.defaultView.getComputedStyle(root);\n\t    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n\t  },\n\t  pathToImage: function (path, dpr) {\n\t    dpr = dpr || this.dpr;\n\t    var canvas = document.createElement('canvas');\n\t    var ctx = canvas.getContext('2d');\n\t    var rect = path.getBoundingRect();\n\t    var style = path.style;\n\t    var shadowBlurSize = style.shadowBlur;\n\t    var shadowOffsetX = style.shadowOffsetX;\n\t    var shadowOffsetY = style.shadowOffsetY;\n\t    var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n\t    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n\t    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n\t    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n\t    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n\t    var width = rect.width + leftMargin + rightMargin;\n\t    var height = rect.height + topMargin + bottomMargin;\n\t    canvas.width = width * dpr;\n\t    canvas.height = height * dpr;\n\t    ctx.scale(dpr, dpr);\n\t    ctx.clearRect(0, 0, width, height);\n\t    ctx.dpr = dpr;\n\t    var pathTransform = {\n\t      position: path.position,\n\t      rotation: path.rotation,\n\t      scale: path.scale\n\t    };\n\t    path.position = [leftMargin - rect.x, topMargin - rect.y];\n\t    path.rotation = 0;\n\t    path.scale = [1, 1];\n\t    path.updateTransform();\n\t\n\t    if (path) {\n\t      path.brush(ctx);\n\t    }\n\t\n\t    var ImageShape = Image;\n\t    var imgShape = new ImageShape({\n\t      style: {\n\t        x: 0,\n\t        y: 0,\n\t        image: canvas\n\t      }\n\t    });\n\t\n\t    if (pathTransform.position != null) {\n\t      imgShape.position = path.position = pathTransform.position;\n\t    }\n\t\n\t    if (pathTransform.rotation != null) {\n\t      imgShape.rotation = path.rotation = pathTransform.rotation;\n\t    }\n\t\n\t    if (pathTransform.scale != null) {\n\t      imgShape.scale = path.scale = pathTransform.scale;\n\t    }\n\t\n\t    return imgShape;\n\t  }\n\t};\n\tvar _default = Painter;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(4);\n\t\n\tvar _config = __webpack_require__(22);\n\t\n\tvar devicePixelRatio = _config.devicePixelRatio;\n\t\n\tvar Style = __webpack_require__(8);\n\t\n\tvar Pattern = __webpack_require__(39);\n\t\n\t/**\n\t * @module zrender/Layer\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\tfunction returnFalse() {\n\t  return false;\n\t}\n\t/**\n\t * 创建dom\n\t *\n\t * @inner\n\t * @param {string} id dom id 待用\n\t * @param {Painter} painter painter instance\n\t * @param {number} number\n\t */\n\t\n\t\n\tfunction createDom(id, painter, dpr) {\n\t  var newDom = util.createCanvas();\n\t  var width = painter.getWidth();\n\t  var height = painter.getHeight();\n\t  var newDomStyle = newDom.style; // 没append呢，请原谅我这样写，清晰~\n\t\n\t  newDomStyle.position = 'absolute';\n\t  newDomStyle.left = 0;\n\t  newDomStyle.top = 0;\n\t  newDomStyle.width = width + 'px';\n\t  newDomStyle.height = height + 'px';\n\t  newDom.width = width * dpr;\n\t  newDom.height = height * dpr; // id不作为索引用，避免可能造成的重名，定义为私有属性\n\t\n\t  newDom.setAttribute('data-zr-dom-id', id);\n\t  return newDom;\n\t}\n\t/**\n\t * @alias module:zrender/Layer\n\t * @constructor\n\t * @extends module:zrender/mixin/Transformable\n\t * @param {string} id\n\t * @param {module:zrender/Painter} painter\n\t * @param {number} [dpr]\n\t */\n\t\n\t\n\tvar Layer = function (id, painter, dpr) {\n\t  var dom;\n\t  dpr = dpr || devicePixelRatio;\n\t\n\t  if (typeof id === 'string') {\n\t    dom = createDom(id, painter, dpr);\n\t  } // Not using isDom because in node it will return false\n\t  else if (util.isObject(id)) {\n\t      dom = id;\n\t      id = dom.id;\n\t    }\n\t\n\t  this.id = id;\n\t  this.dom = dom;\n\t  var domStyle = dom.style;\n\t\n\t  if (domStyle) {\n\t    // Not in node\n\t    dom.onselectstart = returnFalse; // 避免页面选中的尴尬\n\t\n\t    domStyle['-webkit-user-select'] = 'none';\n\t    domStyle['user-select'] = 'none';\n\t    domStyle['-webkit-touch-callout'] = 'none';\n\t    domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n\t    domStyle['padding'] = 0;\n\t    domStyle['margin'] = 0;\n\t    domStyle['border-width'] = 0;\n\t  }\n\t\n\t  this.domBack = null;\n\t  this.ctxBack = null;\n\t  this.painter = painter;\n\t  this.config = null; // Configs\n\t\n\t  /**\n\t   * 每次清空画布的颜色\n\t   * @type {string}\n\t   * @default 0\n\t   */\n\t\n\t  this.clearColor = 0;\n\t  /**\n\t   * 是否开启动态模糊\n\t   * @type {boolean}\n\t   * @default false\n\t   */\n\t\n\t  this.motionBlur = false;\n\t  /**\n\t   * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n\t   * @type {number}\n\t   * @default 0.7\n\t   */\n\t\n\t  this.lastFrameAlpha = 0.7;\n\t  /**\n\t   * Layer dpr\n\t   * @type {number}\n\t   */\n\t\n\t  this.dpr = dpr;\n\t};\n\t\n\tLayer.prototype = {\n\t  constructor: Layer,\n\t  elCount: 0,\n\t  __dirty: true,\n\t  initContext: function () {\n\t    this.ctx = this.dom.getContext('2d');\n\t    this.ctx.__currentValues = {};\n\t    this.ctx.dpr = this.dpr;\n\t  },\n\t  createBackBuffer: function () {\n\t    var dpr = this.dpr;\n\t    this.domBack = createDom('back-' + this.id, this.painter, dpr);\n\t    this.ctxBack = this.domBack.getContext('2d');\n\t    this.ctxBack.__currentValues = {};\n\t\n\t    if (dpr != 1) {\n\t      this.ctxBack.scale(dpr, dpr);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * @param  {number} width\n\t   * @param  {number} height\n\t   */\n\t  resize: function (width, height) {\n\t    var dpr = this.dpr;\n\t    var dom = this.dom;\n\t    var domStyle = dom.style;\n\t    var domBack = this.domBack;\n\t    domStyle.width = width + 'px';\n\t    domStyle.height = height + 'px';\n\t    dom.width = width * dpr;\n\t    dom.height = height * dpr;\n\t\n\t    if (domBack) {\n\t      domBack.width = width * dpr;\n\t      domBack.height = height * dpr;\n\t\n\t      if (dpr != 1) {\n\t        this.ctxBack.scale(dpr, dpr);\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 清空该层画布\n\t   * @param {boolean} clearAll Clear all with out motion blur\n\t   */\n\t  clear: function (clearAll) {\n\t    var dom = this.dom;\n\t    var ctx = this.ctx;\n\t    var width = dom.width;\n\t    var height = dom.height;\n\t    var clearColor = this.clearColor;\n\t    var haveMotionBLur = this.motionBlur && !clearAll;\n\t    var lastFrameAlpha = this.lastFrameAlpha;\n\t    var dpr = this.dpr;\n\t\n\t    if (haveMotionBLur) {\n\t      if (!this.domBack) {\n\t        this.createBackBuffer();\n\t      }\n\t\n\t      this.ctxBack.globalCompositeOperation = 'copy';\n\t      this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);\n\t    }\n\t\n\t    ctx.clearRect(0, 0, width, height);\n\t\n\t    if (clearColor) {\n\t      var clearColorGradientOrPattern; // Gradient\n\t\n\t      if (clearColor.colorStops) {\n\t        // Cache canvas gradient\n\t        clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n\t          x: 0,\n\t          y: 0,\n\t          width: width,\n\t          height: height\n\t        });\n\t        clearColor.__canvasGradient = clearColorGradientOrPattern;\n\t      } // Pattern\n\t      else if (clearColor.image) {\n\t          clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n\t        }\n\t\n\t      ctx.save();\n\t      ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n\t      ctx.fillRect(0, 0, width, height);\n\t      ctx.restore();\n\t    }\n\t\n\t    if (haveMotionBLur) {\n\t      var domBack = this.domBack;\n\t      ctx.save();\n\t      ctx.globalAlpha = lastFrameAlpha;\n\t      ctx.drawImage(domBack, 0, 0, width, height);\n\t      ctx.restore();\n\t    }\n\t  }\n\t};\n\tvar _default = Layer;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports) {\n\n\tvar _default = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809\n\twindow.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {\n\t  setTimeout(func, 16);\n\t};\n\t\n\tmodule.exports = _default;\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(4);\n\t\n\tvar _event = __webpack_require__(75);\n\t\n\tvar Dispatcher = _event.Dispatcher;\n\t\n\tvar requestAnimationFrame = __webpack_require__(73);\n\t\n\tvar Animator = __webpack_require__(16);\n\t\n\t/**\n\t * 动画主类, 调度和管理所有动画控制器\n\t *\n\t * @module zrender/animation/Animation\n\t * @author pissang(https://github.com/pissang)\n\t */\n\t// TODO Additive animation\n\t// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n\t// https://developer.apple.com/videos/wwdc2014/#236\n\t\n\t/**\n\t * @typedef {Object} IZRenderStage\n\t * @property {Function} update\n\t */\n\t\n\t/**\n\t * @alias module:zrender/animation/Animation\n\t * @constructor\n\t * @param {Object} [options]\n\t * @param {Function} [options.onframe]\n\t * @param {IZRenderStage} [options.stage]\n\t * @example\n\t *     var animation = new Animation();\n\t *     var obj = {\n\t *         x: 100,\n\t *         y: 100\n\t *     };\n\t *     animation.animate(node.position)\n\t *         .when(1000, {\n\t *             x: 500,\n\t *             y: 500\n\t *         })\n\t *         .when(2000, {\n\t *             x: 100,\n\t *             y: 100\n\t *         })\n\t *         .start('spline');\n\t */\n\tvar Animation = function (options) {\n\t  options = options || {};\n\t  this.stage = options.stage || {};\n\t\n\t  this.onframe = options.onframe || function () {}; // private properties\n\t\n\t\n\t  this._clips = [];\n\t  this._running = false;\n\t  this._time;\n\t  this._pausedTime;\n\t  this._pauseStart;\n\t  this._paused = false;\n\t  Dispatcher.call(this);\n\t};\n\t\n\tAnimation.prototype = {\n\t  constructor: Animation,\n\t\n\t  /**\n\t   * 添加 clip\n\t   * @param {module:zrender/animation/Clip} clip\n\t   */\n\t  addClip: function (clip) {\n\t    this._clips.push(clip);\n\t  },\n\t\n\t  /**\n\t   * 添加 animator\n\t   * @param {module:zrender/animation/Animator} animator\n\t   */\n\t  addAnimator: function (animator) {\n\t    animator.animation = this;\n\t    var clips = animator.getClips();\n\t\n\t    for (var i = 0; i < clips.length; i++) {\n\t      this.addClip(clips[i]);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 删除动画片段\n\t   * @param {module:zrender/animation/Clip} clip\n\t   */\n\t  removeClip: function (clip) {\n\t    var idx = util.indexOf(this._clips, clip);\n\t\n\t    if (idx >= 0) {\n\t      this._clips.splice(idx, 1);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 删除动画片段\n\t   * @param {module:zrender/animation/Animator} animator\n\t   */\n\t  removeAnimator: function (animator) {\n\t    var clips = animator.getClips();\n\t\n\t    for (var i = 0; i < clips.length; i++) {\n\t      this.removeClip(clips[i]);\n\t    }\n\t\n\t    animator.animation = null;\n\t  },\n\t  _update: function () {\n\t    var time = new Date().getTime() - this._pausedTime;\n\t\n\t    var delta = time - this._time;\n\t    var clips = this._clips;\n\t    var len = clips.length;\n\t    var deferredEvents = [];\n\t    var deferredClips = [];\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      var clip = clips[i];\n\t      var e = clip.step(time, delta); // Throw out the events need to be called after\n\t      // stage.update, like destroy\n\t\n\t      if (e) {\n\t        deferredEvents.push(e);\n\t        deferredClips.push(clip);\n\t      }\n\t    } // Remove the finished clip\n\t\n\t\n\t    for (var i = 0; i < len;) {\n\t      if (clips[i]._needsRemove) {\n\t        clips[i] = clips[len - 1];\n\t        clips.pop();\n\t        len--;\n\t      } else {\n\t        i++;\n\t      }\n\t    }\n\t\n\t    len = deferredEvents.length;\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      deferredClips[i].fire(deferredEvents[i]);\n\t    }\n\t\n\t    this._time = time;\n\t    this.onframe(delta);\n\t    this.trigger('frame', delta);\n\t\n\t    if (this.stage.update) {\n\t      this.stage.update();\n\t    }\n\t  },\n\t  _startLoop: function () {\n\t    var self = this;\n\t    this._running = true;\n\t\n\t    function step() {\n\t      if (self._running) {\n\t        requestAnimationFrame(step);\n\t        !self._paused && self._update();\n\t      }\n\t    }\n\t\n\t    requestAnimationFrame(step);\n\t  },\n\t\n\t  /**\n\t   * 开始运行动画\n\t   */\n\t  start: function () {\n\t    this._time = new Date().getTime();\n\t    this._pausedTime = 0;\n\t\n\t    this._startLoop();\n\t  },\n\t\n\t  /**\n\t   * 停止运行动画\n\t   */\n\t  stop: function () {\n\t    this._running = false;\n\t  },\n\t\n\t  /**\n\t   * Pause\n\t   */\n\t  pause: function () {\n\t    if (!this._paused) {\n\t      this._pauseStart = new Date().getTime();\n\t      this._paused = true;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Resume\n\t   */\n\t  resume: function () {\n\t    if (this._paused) {\n\t      this._pausedTime += new Date().getTime() - this._pauseStart;\n\t      this._paused = false;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 清除所有动画片段\n\t   */\n\t  clear: function () {\n\t    this._clips = [];\n\t  },\n\t\n\t  /**\n\t   * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画\n\t   * @param  {Object} target\n\t   * @param  {Object} options\n\t   * @param  {boolean} [options.loop=false] 是否循环播放动画\n\t   * @param  {Function} [options.getter=null]\n\t   *         如果指定getter函数，会通过getter函数取属性值\n\t   * @param  {Function} [options.setter=null]\n\t   *         如果指定setter函数，会通过setter函数设置属性值\n\t   * @return {module:zrender/animation/Animation~Animator}\n\t   */\n\t  // TODO Gap\n\t  animate: function (target, options) {\n\t    options = options || {};\n\t    var animator = new Animator(target, options.loop, options.getter, options.setter);\n\t    this.addAnimator(animator);\n\t    return animator;\n\t  }\n\t};\n\tutil.mixin(Animation, Dispatcher);\n\tvar _default = Animation;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Eventful = __webpack_require__(11);\n\t\n\texports.Dispatcher = Eventful;\n\t\n\tvar env = __webpack_require__(49);\n\t\n\t/**\n\t * 事件辅助类\n\t * @module zrender/core/event\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t */\n\tvar isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\n\tvar MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;\n\t\n\tfunction getBoundingClientRect(el) {\n\t  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n\t  return el.getBoundingClientRect ? el.getBoundingClientRect() : {\n\t    left: 0,\n\t    top: 0\n\t  };\n\t} // `calculate` is optional, default false\n\t\n\t\n\tfunction clientToLocal(el, e, out, calculate) {\n\t  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative\n\t  // to the padding edge of the target element. The only browser using this convention\n\t  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n\t  // not support the properties.\n\t  // (see http://www.jacklmoore.com/notes/mouse-position/)\n\t  // In zr painter.dom, padding edge equals to border edge.\n\t  // FIXME\n\t  // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n\t  // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n\t  // is too complex. So css-transfrom dont support in this case temporarily.\n\t\n\t  if (calculate || !env.canvasSupported) {\n\t    defaultGetZrXY(el, e, out);\n\t  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n\t  // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n\t  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n\t  // zoom-factor, overflow / opacity layers, transforms ...)\n\t  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n\t  // <https://bugs.jquery.com/ticket/8523#comment:14>\n\t  // BTW3, In ff, offsetX/offsetY is always 0.\n\t  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n\t      out.zrX = e.layerX;\n\t      out.zrY = e.layerY;\n\t    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n\t    else if (e.offsetX != null) {\n\t        out.zrX = e.offsetX;\n\t        out.zrY = e.offsetY;\n\t      } // For some other device, e.g., IOS safari.\n\t      else {\n\t          defaultGetZrXY(el, e, out);\n\t        }\n\t\n\t  return out;\n\t}\n\t\n\tfunction defaultGetZrXY(el, e, out) {\n\t  // This well-known method below does not support css transform.\n\t  var box = getBoundingClientRect(el);\n\t  out.zrX = e.clientX - box.left;\n\t  out.zrY = e.clientY - box.top;\n\t}\n\t/**\n\t * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.\n\t * `calculate` is optional, default false.\n\t */\n\t\n\t\n\tfunction normalizeEvent(el, e, calculate) {\n\t  e = e || window.event;\n\t\n\t  if (e.zrX != null) {\n\t    return e;\n\t  }\n\t\n\t  var eventType = e.type;\n\t  var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\t\n\t  if (!isTouch) {\n\t    clientToLocal(el, e, e, calculate);\n\t    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n\t  } else {\n\t    var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n\t    touch && clientToLocal(el, touch, e, calculate);\n\t  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;\n\t  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js\n\t  // If e.which has been defined, if may be readonly,\n\t  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which\n\t\n\t\n\t  var button = e.button;\n\t\n\t  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {\n\t    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n\t  }\n\t\n\t  return e;\n\t}\n\t\n\tfunction addEventListener(el, name, handler) {\n\t  if (isDomLevel2) {\n\t    el.addEventListener(name, handler);\n\t  } else {\n\t    el.attachEvent('on' + name, handler);\n\t  }\n\t}\n\t\n\tfunction removeEventListener(el, name, handler) {\n\t  if (isDomLevel2) {\n\t    el.removeEventListener(name, handler);\n\t  } else {\n\t    el.detachEvent('on' + name, handler);\n\t  }\n\t}\n\t/**\n\t * preventDefault and stopPropagation.\n\t * Notice: do not do that in zrender. Upper application\n\t * do that if necessary.\n\t *\n\t * @memberOf module:zrender/core/event\n\t * @method\n\t * @param {Event} e : event对象\n\t */\n\t\n\t\n\tvar stop = isDomLevel2 ? function (e) {\n\t  e.preventDefault();\n\t  e.stopPropagation();\n\t  e.cancelBubble = true;\n\t} : function (e) {\n\t  e.returnValue = false;\n\t  e.cancelBubble = true;\n\t};\n\t\n\tfunction notLeftMouse(e) {\n\t  // If e.which is undefined, considered as left mouse event.\n\t  return e.which > 1;\n\t} // 做向上兼容\n\t\n\t\n\texports.clientToLocal = clientToLocal;\n\texports.normalizeEvent = normalizeEvent;\n\texports.addEventListener = addEventListener;\n\texports.removeEventListener = removeEventListener;\n\texports.stop = stop;\n\texports.notLeftMouse = notLeftMouse;\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _event = __webpack_require__(75);\n\t\n\tvar addEventListener = _event.addEventListener;\n\tvar removeEventListener = _event.removeEventListener;\n\tvar normalizeEvent = _event.normalizeEvent;\n\t\n\tvar zrUtil = __webpack_require__(4);\n\t\n\tvar Eventful = __webpack_require__(11);\n\t\n\tvar env = __webpack_require__(49);\n\t\n\tvar GestureMgr = __webpack_require__(77);\n\t\n\tvar TOUCH_CLICK_DELAY = 300;\n\tvar mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n\tvar touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];\n\tvar pointerEventNames = {\n\t  pointerdown: 1,\n\t  pointerup: 1,\n\t  pointermove: 1,\n\t  pointerout: 1\n\t};\n\tvar pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n\t  var nm = name.replace('mouse', 'pointer');\n\t  return pointerEventNames[nm] ? nm : name;\n\t});\n\t\n\tfunction eventNameFix(name) {\n\t  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n\t}\n\t\n\tfunction processGesture(proxy, event, stage) {\n\t  var gestureMgr = proxy._gestureMgr;\n\t  stage === 'start' && gestureMgr.clear();\n\t  var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null).target, proxy.dom);\n\t  stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.\n\t\n\t  if (gestureInfo) {\n\t    var type = gestureInfo.type;\n\t    event.gestureEvent = type;\n\t    proxy.handler.dispatchToElement({\n\t      target: gestureInfo.target\n\t    }, type, gestureInfo.event);\n\t  }\n\t} // function onMSGestureChange(proxy, event) {\n\t//     if (event.translationX || event.translationY) {\n\t//         // mousemove is carried by MSGesture to reduce the sensitivity.\n\t//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n\t//     }\n\t//     if (event.scale !== 1) {\n\t//         event.pinchX = event.offsetX;\n\t//         event.pinchY = event.offsetY;\n\t//         event.pinchScale = event.scale;\n\t//         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n\t//     }\n\t// }\n\t\n\t/**\n\t * Prevent mouse event from being dispatched after Touch Events action\n\t * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n\t * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n\t * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n\t * Result: Blocking Mouse Events for 700ms.\n\t */\n\t\n\t\n\tfunction setTouchTimer(instance) {\n\t  instance._touching = true;\n\t  clearTimeout(instance._touchTimer);\n\t  instance._touchTimer = setTimeout(function () {\n\t    instance._touching = false;\n\t  }, 700);\n\t}\n\t\n\tvar domHandlers = {\n\t  /**\n\t   * Mouse move handler\n\t   * @inner\n\t   * @param {Event} event\n\t   */\n\t  mousemove: function (event) {\n\t    event = normalizeEvent(this.dom, event);\n\t    this.trigger('mousemove', event);\n\t  },\n\t\n\t  /**\n\t   * Mouse out handler\n\t   * @inner\n\t   * @param {Event} event\n\t   */\n\t  mouseout: function (event) {\n\t    event = normalizeEvent(this.dom, event);\n\t    var element = event.toElement || event.relatedTarget;\n\t\n\t    if (element != this.dom) {\n\t      while (element && element.nodeType != 9) {\n\t        // 忽略包含在root中的dom引起的mouseOut\n\t        if (element === this.dom) {\n\t          return;\n\t        }\n\t\n\t        element = element.parentNode;\n\t      }\n\t    }\n\t\n\t    this.trigger('mouseout', event);\n\t  },\n\t\n\t  /**\n\t   * Touch开始响应函数\n\t   * @inner\n\t   * @param {Event} event\n\t   */\n\t  touchstart: function (event) {\n\t    // Default mouse behaviour should not be disabled here.\n\t    // For example, page may needs to be slided.\n\t    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n\t    // mouse event in upper applicatoin.\n\t\n\t    event.zrByTouch = true;\n\t    this._lastTouchMoment = new Date();\n\t    processGesture(this, event, 'start'); // In touch device, trigger `mousemove`(`mouseover`) should\n\t    // be triggered, and must before `mousedown` triggered.\n\t\n\t    domHandlers.mousemove.call(this, event);\n\t    domHandlers.mousedown.call(this, event);\n\t    setTouchTimer(this);\n\t  },\n\t\n\t  /**\n\t   * Touch移动响应函数\n\t   * @inner\n\t   * @param {Event} event\n\t   */\n\t  touchmove: function (event) {\n\t    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n\t    // mouse event in upper applicatoin.\n\t\n\t    event.zrByTouch = true;\n\t    processGesture(this, event, 'change'); // Mouse move should always be triggered no matter whether\n\t    // there is gestrue event, because mouse move and pinch may\n\t    // be used at the same time.\n\t\n\t    domHandlers.mousemove.call(this, event);\n\t    setTouchTimer(this);\n\t  },\n\t\n\t  /**\n\t   * Touch结束响应函数\n\t   * @inner\n\t   * @param {Event} event\n\t   */\n\t  touchend: function (event) {\n\t    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n\t    // mouse event in upper applicatoin.\n\t\n\t    event.zrByTouch = true;\n\t    processGesture(this, event, 'end');\n\t    domHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n\t    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n\t    // we can conveniently implement \"hover style\" in both PC and touch device just\n\t    // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n\t    // to remove \"hover style\" on an element, without any additional code for\n\t    // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n\t    // style\" will remain for user view)\n\t    // click event should always be triggered no matter whether\n\t    // there is gestrue event. System click can not be prevented.\n\t\n\t    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n\t      domHandlers.click.call(this, event);\n\t    }\n\t\n\t    setTouchTimer(this);\n\t  },\n\t  pointerdown: function (event) {\n\t    domHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {\n\t    //     this._msGesture.addPointer(event.pointerId);\n\t    // }\n\t  },\n\t  pointermove: function (event) {\n\t    // FIXME\n\t    // pointermove is so sensitive that it always triggered when\n\t    // tap(click) on touch screen, which affect some judgement in\n\t    // upper application. So, we dont support mousemove on MS touch\n\t    // device yet.\n\t    if (!isPointerFromTouch(event)) {\n\t      domHandlers.mousemove.call(this, event);\n\t    }\n\t  },\n\t  pointerup: function (event) {\n\t    domHandlers.mouseup.call(this, event);\n\t  },\n\t  pointerout: function (event) {\n\t    // pointerout will be triggered when tap on touch screen\n\t    // (IE11+/Edge on MS Surface) after click event triggered,\n\t    // which is inconsistent with the mousout behavior we defined\n\t    // in touchend. So we unify them.\n\t    // (check domHandlers.touchend for detailed explanation)\n\t    if (!isPointerFromTouch(event)) {\n\t      domHandlers.mouseout.call(this, event);\n\t    }\n\t  }\n\t};\n\t\n\tfunction isPointerFromTouch(event) {\n\t  var pointerType = event.pointerType;\n\t  return pointerType === 'pen' || pointerType === 'touch';\n\t} // function useMSGuesture(handlerProxy, event) {\n\t//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n\t// }\n\t// Common handlers\n\t\n\t\n\tzrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n\t  domHandlers[name] = function (event) {\n\t    event = normalizeEvent(this.dom, event);\n\t    this.trigger(name, event);\n\t  };\n\t});\n\t/**\n\t * 为控制类实例初始化dom 事件处理函数\n\t *\n\t * @inner\n\t * @param {module:zrender/Handler} instance 控制类实例\n\t */\n\t\n\tfunction initDomHandler(instance) {\n\t  zrUtil.each(touchHandlerNames, function (name) {\n\t    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t  });\n\t  zrUtil.each(pointerHandlerNames, function (name) {\n\t    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t  });\n\t  zrUtil.each(mouseHandlerNames, function (name) {\n\t    instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n\t  });\n\t\n\t  function makeMouseHandler(fn, instance) {\n\t    return function () {\n\t      if (instance._touching) {\n\t        return;\n\t      }\n\t\n\t      return fn.apply(instance, arguments);\n\t    };\n\t  }\n\t}\n\t\n\tfunction HandlerDomProxy(dom) {\n\t  Eventful.call(this);\n\t  this.dom = dom;\n\t  /**\n\t   * @private\n\t   * @type {boolean}\n\t   */\n\t\n\t  this._touching = false;\n\t  /**\n\t   * @private\n\t   * @type {number}\n\t   */\n\t\n\t  this._touchTimer;\n\t  /**\n\t   * @private\n\t   * @type {module:zrender/core/GestureMgr}\n\t   */\n\t\n\t  this._gestureMgr = new GestureMgr();\n\t  this._handlers = {};\n\t  initDomHandler(this);\n\t\n\t  if (env.pointerEventsSupported) {\n\t    // Only IE11+/Edge\n\t    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n\t    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n\t    // at the same time.\n\t    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n\t    // screen, which do not occurs in pointer event.\n\t    // So we use pointer event to both detect touch gesture and mouse behavior.\n\t    mountHandlers(pointerHandlerNames, this); // FIXME\n\t    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n\t    // which does not prevent defuault behavior occasionally (which may cause view port\n\t    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n\t    // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n\t    // touch screen. And we only support click behavior on MS touch screen now.\n\t    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n\t    // We dont support touch on IE on win7.\n\t    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n\t    // if (typeof MSGesture === 'function') {\n\t    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n\t    //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n\t    // }\n\t  } else {\n\t    if (env.touchEventsSupported) {\n\t      mountHandlers(touchHandlerNames, this); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n\t      // addEventListener(root, 'mouseout', this._mouseoutHandler);\n\t    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n\t    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n\t    // mouse event can not be handle in those devices.\n\t    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n\t    // mouseevent after touch event triggered, see `setTouchTimer`.\n\t\n\t\n\t    mountHandlers(mouseHandlerNames, this);\n\t  }\n\t\n\t  function mountHandlers(handlerNames, instance) {\n\t    zrUtil.each(handlerNames, function (name) {\n\t      addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n\t    }, instance);\n\t  }\n\t}\n\t\n\tvar handlerDomProxyProto = HandlerDomProxy.prototype;\n\t\n\thandlerDomProxyProto.dispose = function () {\n\t  var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\t\n\t  for (var i = 0; i < handlerNames.length; i++) {\n\t    var name = handlerNames[i];\n\t    removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n\t  }\n\t};\n\t\n\thandlerDomProxyProto.setCursor = function (cursorStyle) {\n\t  this.dom.style.cursor = cursorStyle || 'default';\n\t};\n\t\n\tzrUtil.mixin(HandlerDomProxy, Eventful);\n\tvar _default = HandlerDomProxy;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar eventUtil = __webpack_require__(75);\n\t\n\t/**\n\t * Only implements needed gestures for mobile.\n\t */\n\tvar GestureMgr = function () {\n\t  /**\n\t   * @private\n\t   * @type {Array.<Object>}\n\t   */\n\t  this._track = [];\n\t};\n\t\n\tGestureMgr.prototype = {\n\t  constructor: GestureMgr,\n\t  recognize: function (event, target, root) {\n\t    this._doTrack(event, target, root);\n\t\n\t    return this._recognize(event);\n\t  },\n\t  clear: function () {\n\t    this._track.length = 0;\n\t    return this;\n\t  },\n\t  _doTrack: function (event, target, root) {\n\t    var touches = event.touches;\n\t\n\t    if (!touches) {\n\t      return;\n\t    }\n\t\n\t    var trackItem = {\n\t      points: [],\n\t      touches: [],\n\t      target: target,\n\t      event: event\n\t    };\n\t\n\t    for (var i = 0, len = touches.length; i < len; i++) {\n\t      var touch = touches[i];\n\t      var pos = eventUtil.clientToLocal(root, touch, {});\n\t      trackItem.points.push([pos.zrX, pos.zrY]);\n\t      trackItem.touches.push(touch);\n\t    }\n\t\n\t    this._track.push(trackItem);\n\t  },\n\t  _recognize: function (event) {\n\t    for (var eventName in recognizers) {\n\t      if (recognizers.hasOwnProperty(eventName)) {\n\t        var gestureInfo = recognizers[eventName](this._track, event);\n\t\n\t        if (gestureInfo) {\n\t          return gestureInfo;\n\t        }\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\tfunction dist(pointPair) {\n\t  var dx = pointPair[1][0] - pointPair[0][0];\n\t  var dy = pointPair[1][1] - pointPair[0][1];\n\t  return Math.sqrt(dx * dx + dy * dy);\n\t}\n\t\n\tfunction center(pointPair) {\n\t  return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];\n\t}\n\t\n\tvar recognizers = {\n\t  pinch: function (track, event) {\n\t    var trackLen = track.length;\n\t\n\t    if (!trackLen) {\n\t      return;\n\t    }\n\t\n\t    var pinchEnd = (track[trackLen - 1] || {}).points;\n\t    var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\t\n\t    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {\n\t      var pinchScale = dist(pinchEnd) / dist(pinchPre);\n\t      !isFinite(pinchScale) && (pinchScale = 1);\n\t      event.pinchScale = pinchScale;\n\t      var pinchCenter = center(pinchEnd);\n\t      event.pinchX = pinchCenter[0];\n\t      event.pinchY = pinchCenter[1];\n\t      return {\n\t        type: 'pinch',\n\t        target: track[0].target,\n\t        event: event\n\t      };\n\t    }\n\t  } // Only pinch currently.\n\t\n\t};\n\tvar _default = GestureMgr;\n\tmodule.exports = _default;\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 选中节点后，出现的操作框及按钮\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var Node = __webpack_require__(79);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var Connector = __webpack_require__(80);\r\n\t    var env = __webpack_require__(49);\r\n\t    var icon = __webpack_require__(87);\r\n\t    var symbolUtil = __webpack_require__(81);\r\n\t    function OperationNode(node, zr, api,forbidEdit) {\r\n\t        Node.call(this);\r\n\t        this.node = node;\r\n\t        this.zr = zr;\r\n\t        this.forbidEdit = forbidEdit;\r\n\t        this._api = api;\r\n\t        this.render();\r\n\t    }\r\n\t\r\n\t    //事件\r\n\t    OperationNode.ARROW_DRAGEND = \"OperationNode:dragendArrow\";\r\n\t    OperationNode.ARROW_DRAG = \"OperationNode:dragArrow\";\r\n\t    OperationNode.ARROW_DRAGSTART = \"OperationNode:dragstartArrow\";\r\n\t    OperationNode.DELETE_CLICK = \"OperationNode:deleteClick\";\r\n\t    OperationNode.DEL = \"DEL\";\r\n\t    OperationNode.COMMENT_CLICK = \"OperationNode:commentClick\";\r\n\t    OperationNode.COMMENT = \"COMMENT\";\r\n\t        //内置操作图标的图像\r\n\t    OperationNode.opicons = {\r\n\t        STRAIGHT: icon.STRAIGHT_SVG,\r\n\t        JAGGED: icon.JAGGED_SVG,\r\n\t        CURVE: icon.CURVE_SVG,\r\n\t        DEL: icon.DEL_SVG,\r\n\t        COMMENT: icon.COMMENT_SVG\r\n\t    };\r\n\t\r\n\t    OperationNode.prototype.render = function() {\r\n\t        this.renderBase();\r\n\t        if (!this.forbidEdit) {\r\n\t            this.renderOther();\r\n\t        }\r\n\t    };\r\n\t\r\n\t    OperationNode.prototype.renderBase = function() {\r\n\t        this.createOperation();\r\n\t    };\r\n\t\r\n\t    OperationNode.prototype.createOperation = function() {\r\n\t        var me = this;\r\n\t        if (!this.node.selectStyle) {\r\n\t            this.virtualRect = new graphic.Polyline({ style: { lineDash: [2] } });\r\n\t            this.virtualRect.isSelfComputePos = true;  // 自己计算位置\r\n\t            this.add(this.virtualRect);\r\n\t        } else {\r\n\t             if (this.node.type === 'ZPath') {  //addHover需要从它自身的构造函数中创建。1.Painter中addHover源码是根据shape与style创建 2.path中的构造函数是返回另一个元素\r\n\t                this.node._zCloneStyle = this.node.style.clone();\r\n\t                 this.node.setStyle(this.node.selectStyle); \r\n\t             } else if(this.node.setOrCancelSelectStyle) {\r\n\t                this.node.setOrCancelSelectStyle(true);\r\n\t             } else {\r\n\t                this._api.getZr().addHover(this.node, this.node.selectStyle);\r\n\t             }\r\n\t            \r\n\t        }\r\n\t\r\n\t        if (this.node.operationIcons) {\r\n\t            zrUtil.each(this.node.operationIcons, function(item) {\r\n\t                //检查是否是内置图标\r\n\t                var opIconInstance = null;\r\n\t                var operationIcon = OperationNode.opicons[item.name.toUpperCase() + \"\"]\r\n\t                if (operationIcon) {\r\n\t\r\n\t                    if (this.forbidEdit) {\r\n\t                        return;\r\n\t                    }\r\n\t                    if (item.hidden) {\r\n\t                        return;\r\n\t                    }\r\n\t                    if (item.name == OperationNode.DEL) {\r\n\t                        //垃圾桶\r\n\t                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' },z:me.node.z+1,rectHover: true }, { x: 0, y: 0, width: 10, height: 15 });\r\n\t\r\n\t                        if(item.callback){\r\n\t                            opIconInstance.on(\"click\", function(e) {\r\n\t                                e.data = item;\r\n\t                                e.node = me.node;  // 将所附的节点也传递出去\r\n\t                                if (item.callback) {\r\n\t                                    item.callback(e);\r\n\t                                }\r\n\t                            });\r\n\t                        }else{\r\n\t                            opIconInstance.on(\"click\", function(e) {\r\n\t                                var params = {};\r\n\t                                params.event = e;\r\n\t                                params.target = this;\r\n\t                                params.type = OperationNode.DELETE_CLICK;\r\n\t                                me.trigger(params.type, params);\r\n\t                            });\r\n\t                        }\r\n\t                    } else if (item.name == OperationNode.COMMENT) {\r\n\t                        var rect = { x: 0, y: 0, width: 16, height: 16 };\r\n\t                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' }, z:me.node.z+2, rectHover: true }, rect);\r\n\t                        opIconInstance.on(\"click\", function(e) {\r\n\t                            var params = {};\r\n\t                            params.event = e;\r\n\t                            params.target = this;\r\n\t                            params.type = OperationNode.COMMENT_CLICK;\r\n\t                            me.trigger(params.type, params);\r\n\t                        });\r\n\t                    } else {\r\n\t                        var rectOther = { x: 0, y: 0, width: 15, height: 15 };\r\n\t                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' },draggable:true,z:me.node.z+2,lineType: Connector[\"TYPE_\" + item.name.toUpperCase()],rectHover: true }, rectOther);\r\n\t                        var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];\r\n\t                        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n\t                            opIconInstance.on(eveName, function(e) {\r\n\t                                var params = {};\r\n\t                                params.event = e;\r\n\t                                params.data = item.options\r\n\t                                params.type = \"OperationNode:\" + eveName + \"Arrow\";\r\n\t                                me.trigger(params.type, params);\r\n\t                            });\r\n\t                        });\r\n\t                    }\r\n\t\r\n\t                } else {\r\n\t                    opIconInstance = symbolUtil.createSymbol(item.iconPath, 0, 0, item.width || 15, item.height || 15, me.node.z+1, item.color||'#000');\r\n\t                    opIconInstance.on(\"click\", function(e) {\r\n\t                        e.data = item;\r\n\t                        e.node = me.node;  // 将所附的节点也传递出去\r\n\t                        if (item.callback) {\r\n\t                            item.callback(e);\r\n\t                        }\r\n\t                        var param = {event:e, type:\"OperationNode:\" + item.name + \"Click\"};\r\n\t                        me._api.trigger(param.type, param);\r\n\t                    });\r\n\t                }\r\n\t                opIconInstance.name = item.name;\r\n\t                me.add(opIconInstance);\r\n\t            });\r\n\t        }\r\n\t    };\r\n\t\r\n\t    OperationNode.prototype.refreshPostion = function(node,nodeRect) {\r\n\t        var i = 0;\r\n\t        var rbPoint = nodeRect.points[2]; //取右下角坐标\r\n\t        //1.定位虚框\r\n\t        this.virtualRect && this.virtualRect.setShape({ points: nodeRect.points });\r\n\t        //2.定位每个小图标\r\n\t        this.eachChild(function(nodeItem) {\r\n\t            if (!nodeItem.isSelfComputePos) {\r\n\t                // 8px是第一个操作按钮图标的距离 靠太近不好看    20px是每个图标的间隔  10px是图标向偏的距离\r\n\t                nodeItem.attr(\"position\", [rbPoint[0] + 8 + (i++ * 20), rbPoint[1] - 10]);\r\n\t            }\r\n\t        });\r\n\t\r\n\t        this.refreshPositionOther(node,nodeRect);\r\n\t    };\r\n\t\r\n\t    OperationNode.prototype.renderOther = function() {\r\n\t        //留给扩展使用\r\n\t    };\r\n\t    OperationNode.prototype.refreshPositionOther = function(node,nodeRect) {\r\n\t        //留给扩展使用\r\n\t        //3.定位整个operationNode\r\n\t        if ((node.parent && node.parent.isBg && node.parent.isBg == true) || (node.parent.type === \"GroupNode\")) {\r\n\t            this.attr(\"position\", [nodeRect.x, nodeRect.y])\r\n\t        } else {\r\n\t            var nodeShapeX = node.shape? node.shape.x:0;\r\n\t            var nodeSahpeY = node.shape? node.shape.y:0;\r\n\t            this.attr(\"position\", [nodeRect.x + node.parent.position[0]+nodeShapeX, nodeRect.y + node.parent.position[1]+nodeSahpeY])\r\n\t        }\r\n\t    };\r\n\t\r\n\t    OperationNode.prototype.cleanup = function() {\r\n\t        if(this.node.selectStyle) {\r\n\t            if (this.node.type === 'ZPath') {\r\n\t                this.node.setStyle(this.node._zCloneStyle);\r\n\t            } else if(this.node.setOrCancelSelectStyle) {\r\n\t                this.node.setOrCancelSelectStyle(false);\r\n\t             } else {\r\n\t                this._api.getZr().removeHover(this.node);\r\n\t            }\r\n\t            \r\n\t        }\r\n\t    };\r\n\t\r\n\t    zrUtil.inherits(OperationNode, Node);\r\n\t    module.exports = OperationNode;\r\n\t\r\n\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var util = __webpack_require__(63)\r\n\t    //创建Node类 所有形状都继承Node  包括fromJSON toJSON\r\n\t    function Node() {\r\n\t        this.resourceId = util.getUUID(); // 生成节点ID\r\n\t        graphic.Group.call(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 由父类实现\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Node.prototype.render = function() {};\r\n\t\r\n\t    /**\r\n\t     * 由父类实现\r\n\t     * @param  {[type]} json [description]\r\n\t     * @return {[type]}      [description]\r\n\t     */\r\n\t    Node.prototype.getRect = function(json) {};\r\n\t\r\n\t    /**\r\n\t     * drawText\r\n\t     * @description 画一个文本\r\n\t     * @param {string} name\r\n\t     * @param {string} color\r\n\t     */\r\n\t    Node.prototype.drawText = function(name, color, position) {\r\n\t        var textName = this.bpmnInfo.name, x, y;\r\n\t        if(name != null){\r\n\t            textName = name;\r\n\t        }\r\n\t        var text = new graphic.Text({\r\n\t            style: {\r\n\t                text: textName,\r\n\t                color: color ? color : this.options.text.color,\r\n\t                textFont: '12px Microsoft YaHei'\r\n\t            },\r\n\t            zlevel: 20\r\n\t        });\r\n\t        //文字绘制的位置 \r\n\t        position = position ? position : 'init';\r\n\t        switch (position) {\r\n\t            //节点下方居中位置\r\n\t            case 'init': \r\n\t                //x = 中心点.x - 起始位置.x - 文字宽度的一半\r\n\t                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n\t                //y = 中心点.y - 起始位置.y + 偏移值（6）\r\n\t                y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + 6;\r\n\t                break;\r\n\t            //节点内部居中位置\r\n\t            case 'center':\r\n\t                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n\t                y = this.getRect().y - this.position[1] - 6;\r\n\t                break;\r\n\t            //节点内部居左位置\r\n\t            case 'left': \r\n\t                x = this.getRect().x - this.position[0] - text.getBoundingRect().width + 6;\r\n\t                y = this.getRect().y - this.position[1] - 6;\r\n\t                break;\r\n\t            default: break;\r\n\t        }\r\n\t        text.attr(\"style\", { x: x, y: y });\r\n\t        return {\r\n\t            text: text,\r\n\t            rect: text.getBoundingRect()\r\n\t        };\r\n\t    };\r\n\t    /**\r\n\t     * refreshText\r\n\t     * @description 刷新文本\r\n\t     */\r\n\t    Node.prototype.refreshText = function(pos) {\r\n\t        var text = this.childOfName(\"Title\"), x, y;\r\n\t        pos = pos ? pos : 'init';\r\n\t        switch (pos) {\r\n\t            case 'init': \r\n\t                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n\t                y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + 6;\r\n\t                break;\r\n\t            case 'center':\r\n\t                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n\t                y = this.getRect().y - this.position[1] - 6;\r\n\t                break;\r\n\t            case 'left':\r\n\t                x = 2;\r\n\t                y = this.getRect().y - this.position[1] - 6;\r\n\t                break;\r\n\t            default: break;\r\n\t        }\r\n\t        text.attr(\"style\", { x: x, y: y });\r\n\t    };\r\n\t    /**\r\n\t     * 由父类实现\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Node.prototype.toJSON = function() {};\r\n\t\r\n\t    graphic.Util.inherits(Node, graphic.Group);\r\n\t    module.exports = Node;\r\n\t\r\n\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 连接线\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var Util = __webpack_require__(63);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var vec2 = __webpack_require__(14);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var Node = __webpack_require__(79);\r\n\t    var symbolUtil = __webpack_require__(81);\r\n\t    var Handle = __webpack_require__(82);\r\n\t    var EffectLine = __webpack_require__(83);\r\n\t    var ConnectionPoint = __webpack_require__(84);\r\n\t    var Point = __webpack_require__(64);\r\n\t    var Model = __webpack_require__(85);\r\n\t\r\n\t    Connector.TYPE_STRAIGHT = 'straight';\r\n\t    Connector.TYPE_JAGGED = 'jagged';\r\n\t    Connector.TYPE_CURVE = 'curve';\r\n\t    Connector.TYPE_CHAIN = 'chain';\r\n\t    Connector.RADIUS = 3;\r\n\t    Connector.START_NODE = \"startNode\";\r\n\t    Connector.END_NODE = \"endNode\";\r\n\t    Connector.LEFT = \"left\";\r\n\t    Connector.RIGHT = \"right\";\r\n\t    Connector.TOP = \"top\";\r\n\t    Connector.BOTTOM = \"bottom\";\r\n\t    Connector.BOTTOM = \"bottom\";\r\n\t    Connector.SEPERATOR = \"-\";\r\n\t    Connector.NORMAL_COLOR = \"#000\";\r\n\t    Connector.SELECTED_COLOR = '#74B7E0';\r\n\t    /**\r\n\t     * 构造函数\r\n\t     * @param {[type]} options [description]\r\n\t     */\r\n\t    function Connector(options) {\r\n\t        Node.call(this);\r\n\t        this.opt = options || {};\r\n\t        if (this.opt.model) {\r\n\t            this.resourceId = this.opt.model.get(\"resourceId\");\r\n\t            this.model = this.opt.model;\r\n\t            this.opt = this.opt.model.option;\r\n\t        } else {\r\n\t            this.resourceId = Util.getUUID(); // 生成节点ID\r\n\t            this.model = new Model({});\r\n\t        }\r\n\t        var defaultOptions = {\r\n\t            symbol: { type: \"arrow\", size: 10, color: Connector.NORMAL_COLOR, both:false, offset:0 }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n\t            style: { lineWidth: 1, stroke: Connector.NORMAL_COLOR, lineType: Connector.TYPE_STRAIGHT }, //样式\r\n\t            hoverStyle: { lineWidth: 2, stroke: Connector.SELECTED_COLOR }, //移上去的样式\r\n\t            arrowHoverStyle: { fill: Connector.SELECTED_COLOR},\r\n\t            shape: { points: null, smooth: false, smoothConstraint: null }, //形状\r\n\t            position: { startPos:null, endPos:null,  //指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t                        startOffset:[0,0],  // 起始线段离节点的偏移\r\n\t                        endOffset:[0,0],    // 终止线段离节点的偏移\r\n\t                        escapeDistance:[30,30], // 第一条折线的长度，最后一条折线的长度\r\n\t                        points:null    //不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n\t                    },\r\n\t            autoChangePosition: false,\r\n\t            textContextMenu: null,\r\n\t            isEdit: true, //是否可编辑\r\n\t            text: {\r\n\t                text: null,\r\n\t                textFill: '#000000', // 文本颜色\r\n\t                textFont: '12px Microsoft YaHei',\r\n\t                textPos: 'center',\r\n\t                textRotateable: true\r\n\t            },\r\n\t            z: 0\r\n\t        }\r\n\t\r\n\t        this.options = Util.mergeOpt(defaultOptions, this.opt, true, 'textContextMenu');\r\n\t        this.handles = [];\r\n\t        this.conPointsGroup = new graphic.Group();\r\n\t        this.startNode = null;\r\n\t        this.endNode = null;\r\n\t        this.line = null;\r\n\t        this.groupCurve = new graphic.Group();\r\n\t        this.icons = []; // 用于存储线段上面的操作图标\r\n\t        this.render();\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 重新画线，如果传空则根据turningPoints 重新画线\r\n\t     * @param  {[type]} points [description]\r\n\t     * @return {[type]}        [description]\r\n\t     */\r\n\t    Connector.prototype.refresh = function(arrPoints) {\r\n\t        if (arrPoints) {\r\n\t            this.turningPoints = arrPoints;\r\n\t        }\r\n\t        //将[x:0,y:0]转化为[0, 0]  给zrender使用\r\n\t        var points = Util.traslatePoints(this.turningPoints);\r\n\t\r\n\t        if ((this.options.style.lineType == Connector.TYPE_CURVE) && (points.length > 2)) {\r\n\t            this.modifyCurve(this.turningPoints);\r\n\t        } else {\r\n\t            this.line.attr('shape', { points: points });\r\n\t        }\r\n\t\r\n\t        var lineText = this.childOfName('lineText');\r\n\t        var self = this, lineTextArr = [];\r\n\t        if (this.options.style.lineType == Connector.TYPE_CHAIN && zrUtil.isArray(this.options.text.text)) {\r\n\t            this.options.text.text.forEach(function (v, i) {\r\n\t                lineTextArr.push(self.childOfName('lineText-'+i));\r\n\t            });\r\n\t        } else if (!lineText && this.options.text.text) {\r\n\t            var text = this.drawText(\"lineText\", this.options.text.text, 0, 0);\r\n\t            this.add(text.text);\r\n\t            lineText = this.childOfName('lineText');\r\n\t        }\r\n\t        if (lineTextArr.length > 0) {\r\n\t            var cnt = lineTextArr.length,\r\n\t                distance = this.turningPoints[1].x - this.turningPoints[0].x,\r\n\t                gap = parseInt(distance/cnt),\r\n\t                pos = -(gap) * parseInt(cnt/2);\r\n\t\r\n\t            lineTextArr.forEach(function (v, i) {\r\n\t                var textPoint = self.getTextPostion(self.options.text), way = '';\r\n\t\r\n\t                var rate = self.getTextRotation(textPoint);\r\n\t                if (rate === -0 || rate === 0) {\r\n\t                    rate = 0;\r\n\t                } else {\r\n\t                    way = rate > 0 ? 'plus' : 'minus';\r\n\t                }\r\n\t                rate = Math.abs(rate);\r\n\t                var deg = (180*rate)/Math.PI;\r\n\t                var rotation = null, length = null;\r\n\t                v.setStyle(\"text\", zrUtil.isString(self.options.text.text[i]) ? self.options.text.text[i] : self.options.text.text[i].text);\r\n\t\r\n\t                if (way) {\r\n\t                    rotation = deg > 90 ? ((deg-45)*Math.PI)/180 : ((45+deg)*Math.PI)/180;\r\n\t                    rotation = way === 'minus' ? -(rotation) : rotation;\r\n\t                } else {\r\n\t                    rotation = (45*Math.PI)/180\r\n\t                }\r\n\t                v.attr('rotation', rotation);\r\n\t\r\n\t                if (deg === 90) {\r\n\t                    textPoint[1] -= pos;\r\n\t                } else {\r\n\t                    textPoint[0] += pos;\r\n\t                    if (rate !== 0) {\r\n\t                        length = Math.tan(deg*Math.PI/180)*pos;\r\n\t                        if (pos > 0) {\r\n\t                            textPoint[1] -= way === 'plus' ? length : -(length);\r\n\t                        } else {\r\n\t                            textPoint[1] += way === 'plus' ? -(length) : (length);\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                v.attr(\"position\", textPoint);\r\n\t                pos += gap;\r\n\t            });\r\n\t        }\r\n\t        if (lineText) {\r\n\t            lineText.setStyle(\"text\", this.options.text.text);\r\n\t            var textPoint = this.getTextPostion(this.options.text);\r\n\t            if (this.options.style.lineType == Connector.TYPE_STRAIGHT && this.options.text.textRotateable) { //#187\r\n\t                lineText.attr('rotation', this.getTextRotation(textPoint));\r\n\t            }\r\n\t            lineText.attr(\"position\", textPoint);\r\n\t        }\r\n\t        this.refreshFromToSymbol(points);\r\n\t    };\r\n\t    /**\r\n\t     * 渲染\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.render = function() {\r\n\t        var that = this;\r\n\t        //1.创建箭头\r\n\t        this.renderFromToSymbol();\r\n\t\r\n\t        //2.创建线\r\n\t        this.curveLine = new graphic.BezierCurve({\r\n\t            //position: this.options.position,\r\n\t            style: this.options.style,\r\n\t            z: this.options.z\r\n\t        });\r\n\t        this.groupCurve.add(this.curveLine);\r\n\t        this.add(this.groupCurve);\r\n\t        this.add(this.conPointsGroup);\r\n\t\r\n\t        this.polyLine = new graphic.Polyline({\r\n\t            //position: this.options.position,\r\n\t            shape: this.options.shape,\r\n\t            style: this.options.style,\r\n\t            z: this.options.z\r\n\t        });\r\n\t        this.add(this.polyLine);\r\n\t\r\n\t        if ((this.options.style.lineType == Connector.TYPE_CURVE)) {\r\n\t            this.line = this.groupCurve;\r\n\t            this.createHoverStyle(this.curveLine);\r\n\t            this.polyLine.hide();\r\n\t        } else {\r\n\t            this.line = this.polyLine;\r\n\t            this.createHoverStyle(this.polyLine);\r\n\t            this.curveLine.hide();\r\n\t        }\r\n\t\r\n\t        //3.侦听线事件\r\n\t        var MOUSE_EVENT_NAMES = ['dblclick', 'click']; //'click', 'dblclick', 'mouseover', 'mouseout'\r\n\t        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n\t            this.line.on(eveName, zrUtil.bind(function(e) {\r\n\t                e.cancelBubble = true;\r\n\t                var params = {};\r\n\t                params.event = e;\r\n\t                params.type = \"Connector:\" + eveName;\r\n\t                params.target = that;\r\n\t                this.trigger(params.type, params);\r\n\t                this.setStyle({color:Connector.SELECTED_COLOR},true);\r\n\t                if (this.options.isEdit == false) {\r\n\t                    return; }\r\n\t\r\n\t                if (this.options.isEdit && this.turningPoints.length >= 2) {\r\n\t                    this.createAllconnectionPoint()\r\n\t                }\r\n\t                if (this.handles.length < 1) {\r\n\t                    this.shapeSetHandle();\r\n\t                }\r\n\t\r\n\t            }, this));\r\n\t        }, this);\r\n\t\r\n\t        //4.创建线上文本\r\n\t        if (this.options.text.text) {\r\n\t            var text = null;\r\n\t            if (zrUtil.isArray(this.options.text.text) && this.options.style.lineType == Connector.TYPE_CHAIN) {\r\n\t                this.options.text.text.forEach(function (v, i) {\r\n\t                    var content = that.drawText(\"lineText-\"+i, v, 0, 0);\r\n\t                    if (zrUtil.isString(v)) {\r\n\t                        var obj = {};\r\n\t                        obj.text = v;\r\n\t                        obj.textId = content.text.id;\r\n\t                        that.options.text.text[i] = obj;\r\n\t                    } else {\r\n\t                        that.options.text.text[i].textId = content.text.id;\r\n\t                    }\r\n\t                    that.add(content.text);\r\n\t                    if(content && that.opt.textContextMenu) {\r\n\t                        var textContextMenu = that.opt.textContextMenu;\r\n\t                        content.text.on(\"contextmenu\",function(e) {\r\n\t                            e.event.preventDefault();\r\n\t                            e.event.stopPropagation();\r\n\t                            textContextMenu.buildMenu(e.event,this);\r\n\t                        })\r\n\t                    }\r\n\t                });\r\n\t            } else {\r\n\t                text = this.drawText(\"lineText\", this.options.text.text, 0, 0);\r\n\t                this.add(text.text);\r\n\t            }\r\n\t            if(text && this.opt.textContextMenu) {\r\n\t                var textContextMenu = this.opt.textContextMenu;\r\n\t                text.text.on(\"contextmenu\",function(e) {\r\n\t                    e.event.preventDefault();\r\n\t                    e.event.stopPropagation();\r\n\t                    textContextMenu.buildMenu(e.event,this);\r\n\t                })\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    Connector.prototype.renderFromToSymbol = function(options) {\r\n\t        var symbolTo = this.createSymbol('toSymbol', this.options); //arrow,triangle\r\n\t        if (symbolTo) {\r\n\t            this.add(symbolTo);\r\n\t        }\r\n\t        //如果双向箭头 则再创建首箭头\r\n\t        if (this.options.symbol.both) {\r\n\t            var symbolFrom = this.createSymbol('fromSymbol', this.options); //arrow,triangle\r\n\t            if (symbolFrom) {\r\n\t                this.add(symbolFrom);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    Connector.prototype.refreshFromToSymbol = function(points) {\r\n\t        var symbolTo = this.childOfName('toSymbol');\r\n\t        var symbolFrom = this.childOfName('fromSymbol');\r\n\t        var position = [], offset = this.options.symbol.offset;\r\n\t        if (symbolTo) {\r\n\t            if (this.options.effect && this.options.effect.show) {\r\n\t                new EffectLine(symbolTo, this.options, this.groupCurve, this.polyLine);\r\n\t            } else {\r\n\t                position = points[points.length - 1];\r\n\t                if (this.options.style.lineType !== Connector.TYPE_CURVE) {\r\n\t                    var distance = vec2.distance(points[points.length - 1], points[points.length - 2]);\r\n\t                    if (offset <= distance) {\r\n\t                        position = vec2.lerp(\r\n\t                            [], points[points.length - 1], points[points.length - 2],\r\n\t                            offset / distance);\r\n\t                    } else {\r\n\t                        position = points[points.length - 1];\r\n\t                    }\r\n\t                }\r\n\t                symbolTo.attr('position', position);\r\n\t                symbolTo.attr('rotation', Util.tangentRotation(this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]));\r\n\t            }\r\n\t        }\r\n\t\r\n\t        if (symbolFrom) {\r\n\t            position = points[0];\r\n\t            if (this.options.style.lineType !== Connector.TYPE_CURVE) {\r\n\t                var distanceFrom = vec2.distance(points[0], points[1]);\r\n\t                if (offset <= distanceFrom) {\r\n\t                    position = vec2.lerp(\r\n\t                        [], points[0], points[1],\r\n\t                        offset / distanceFrom);\r\n\t                } else {\r\n\t                    position = points[0];\r\n\t                }\r\n\t            }\r\n\t            symbolFrom.attr('position', position);\r\n\t            symbolFrom.attr('rotation', Util.tangentRotation(this.turningPoints[1], this.turningPoints[0]));\r\n\t        }\r\n\t    }\r\n\t    /**\r\n\t     * 设置style\r\n\t     * @param {object} options 样式对象\r\n\t     * @param {boolean} notSaveModel 设置样式是否保存到模型中,默认是false\r\n\t     */\r\n\t    Connector.prototype.setStyle = function(options,notSaveModel) {\r\n\t        var symbolTo = null;\r\n\t        if (options.color) {\r\n\t            if (this.options.style.lineType == Connector.TYPE_CURVE) {\r\n\t                this.groupCurve.eachChild(function(curve) {\r\n\t                    curve.attr(\"style\", { stroke: options.color });\r\n\t                    graphic.setNormalStyle(curve, { stroke: options.color });\r\n\t                });\r\n\t            } else {\r\n\t                this.polyLine.attr(\"style\", { stroke: options.color });\r\n\t                graphic.setNormalStyle(this.polyLine, { stroke: options.color });\r\n\t            }\r\n\t            symbolTo = this.childOfName('toSymbol');\r\n\t            if (symbolTo) {\r\n\t                symbolTo.attr(\"style\", { fill: options.color });\r\n\t                graphic.setNormalStyle(symbolTo, { fill: options.color });\r\n\t            }\r\n\t            if(!notSaveModel) {\r\n\t                this.options.style.stroke = options.color;\r\n\t                this.model.set(\"options.style.stroke\", options.color);\r\n\t                this.model.set(\"options.symbol.color\", options.color);\r\n\t                this.options.symbol.color = options.color;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        if (options.text) {\r\n\t            var lineText = this.childOfName('lineText');\r\n\t            //开始没有创建文本，后来传进来text了，需要先创建文本\r\n\t            if (!lineText && options.text.text) {\r\n\t                var text = this.drawText(\"lineText\", options.text.text, 0, 0);\r\n\t                this.add(text.text);\r\n\t                lineText = this.childOfName('lineText');\r\n\t            }\r\n\t\r\n\t            if (options.text.text || options.text.text == \"\") {\r\n\t                lineText.setStyle(\"text\", options.text.text);\r\n\t                this.options.text.text = options.text.text;\r\n\t            }\r\n\t            var textPoint = this.getTextPostion(options.text);\r\n\t            lineText.attr(\"position\", textPoint);\r\n\t            if (options.text.textPos) {\r\n\t                this.options.text.textPos = options.text.textPos;\r\n\t            }\r\n\t            if (options.text.offset) { //#187\r\n\t                this.options.text.offset = options.text.offset;\r\n\t            }\r\n\t\r\n\t            if (options.text.textFill) {\r\n\t                lineText.attr(\"style\", {\r\n\t                    textFill: options.text.textFill\r\n\t                });\r\n\t                this.options.text.textFill = options.text.textFill;\r\n\t            }\r\n\t            this.model.set(\"options.text\", options.text);\r\n\t        }\r\n\t\r\n\t        if (options.symbol) {\r\n\t            if (options.symbol.type) {\r\n\t                this.options.symbol.type = options.symbol.type;\r\n\t                this.model.set(\"options.symbol.type\", options.symbol.type);\r\n\t            }\r\n\t            if (options.symbol.size) {\r\n\t                this.options.symbol.size = options.symbol.size;\r\n\t                this.model.set(\"options.symbol.size\", options.symbol.size);\r\n\t            }\r\n\t            if (options.symbol.color) {\r\n\t                this.options.symbol.color = options.symbol.color;\r\n\t                this.model.set(\"options.symbol.color\", options.symbol.color);\r\n\t            }\r\n\t            if (options.symbol.z) {\r\n\t                this.options.symbol.z = options.symbol.z;\r\n\t                this.model.set(\"options.symbol.z\", options.symbol.z);\r\n\t            }\r\n\t\r\n\t            symbolTo = this.childOfName('toSymbol');\r\n\t            if (symbolTo) {\r\n\t                this.remove(symbolTo);\r\n\t            }\r\n\t            var symbol = this.createSymbol(\"toSymbol\", this.model.get(\"options\"))\r\n\t            if (symbol) {\r\n\t                this.add(symbol);\r\n\t            }\r\n\t            this.refresh();\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 获取线段的位置\r\n\t     * @param  {Object} text {text:'', color:'', textPos:''}\r\n\t     * @return {Object}      {x,y}\r\n\t     */\r\n\t    Connector.prototype.getTextPostion = function(text) {\r\n\t        var textPostion = [];\r\n\t        var textWidth = graphic.textContain.getWidth(text.text, text.textFont);\r\n\t        if (text && text.textPos) {\r\n\t            var offset = text.offset || 0;\r\n\t            var arrOffset = offset;\r\n\t            if (!zrUtil.isArray(offset)) {\r\n\t                arrOffset = [offset, 0];\r\n\t            }\r\n\t            if (text.textPos == 'start') {\r\n\t                textPostion = [this.turningPoints[0].x + arrOffset[0], this.turningPoints[0].y + arrOffset[1]];\r\n\t            } else if (text.textPos == 'end') {\r\n\t                var points = Util.getMaxLineLength([this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]]);\r\n\t                var angle = Util.getAngle(points[0], points[1]);\r\n\t                var length = Util.distance(points[0], points[1]) - textWidth;\r\n\t                var newPoint = Util.getEndPoint(points[0], length, angle);\r\n\t                textPostion = [newPoint.x + arrOffset[0], newPoint.y + arrOffset[1]];\r\n\t            } else {\r\n\t                var midPoint = this.middle(text);\r\n\t                textPostion = [midPoint[0] + arrOffset[0], midPoint[1] + arrOffset[1]];\r\n\t            }\r\n\t        } else {\r\n\t            var position = this.middle(text);\r\n\t            textPostion = [position[0] - textWidth / 2, position[1]];\r\n\t        }\r\n\t\r\n\t        return textPostion;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 获取线段的旋转角度\r\n\t     * @param  {Object} textPostion {x,y}\r\n\t     * @return {Number}             角度值\r\n\t     */\r\n\t    Connector.prototype.getTextRotation = function(textPostion) {\r\n\t        //计算出极坐标的角度\r\n\t        var points = Util.getMaxLineLength(this.turningPoints);\r\n\t        var angle = -Math.atan2(points[1].y - textPostion[1], points[1].x - textPostion[0]); //,Math.PI/2\r\n\t        return angle;\r\n\t    };\r\n\t\r\n\t    Connector.prototype.createHoverStyle = function(el) {\r\n\t        if (this.options.hoverStyle) {\r\n\t            graphic.setElementHoverStl(el, this.options.hoverStyle);\r\n\t\r\n\t            var symbolTo = this.childOfName('toSymbol');\r\n\t            if (symbolTo) { graphic.setElementHoverStl(symbolTo, this.options.arrowHoverStyle); }\r\n\t\r\n\t            el.on('mouseover', zrUtil.bind(function() {\r\n\t                    graphic.doEnterHover(el);\r\n\t                    if (symbolTo) { graphic.doEnterHover(symbolTo); }\r\n\t\r\n\t                    this.groupCurve.eachChild(function(line) {\r\n\t                        graphic.doEnterHover(line);\r\n\t                    });\r\n\t                }, this))\r\n\t                .on('mouseout', zrUtil.bind(function() {\r\n\t                    graphic.doLeaveHover(el);\r\n\t                    if (symbolTo) { graphic.doLeaveHover(symbolTo); }\r\n\t                    this.groupCurve.eachChild(function(line) {\r\n\t                        graphic.doLeaveHover(line);\r\n\t                    });\r\n\t                }, this));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 创建Node的连接点\r\n\t     * @private\r\n\t     *\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.createAllconnectionPoint = function() {\r\n\t        this.connectionPointCreate(this, this.turningPoints[0].clone(), ConnectionPoint.TYPE_CONNECTOR);\r\n\t        this.connectionPointCreate(this, this.turningPoints[this.turningPoints.length - 1].clone(), ConnectionPoint.TYPE_CONNECTOR);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建连接点\r\n\t     * @private\r\n\t     * @param  {[type]} shape [description]\r\n\t     * @param  {[type]} point [description]\r\n\t     * @param  {[type]} type  [description]\r\n\t     * @return {[type]}       [description]\r\n\t     */\r\n\t    Connector.prototype.connectionPointCreate = function(shape, point, type) {\r\n\t        var conPoint = new ConnectionPoint(this, point, type, this.options);\r\n\t        this.conPointsGroup.add(conPoint.shape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 清空控制点\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.clearHandles = function() {\r\n\t        for (var i = 0; i < this.handles.length; i++) {\r\n\t            this.remove(this.handles[i].handleShape);\r\n\t        }\r\n\t        this.handles = [];\r\n\t        if (this.conPointsGroup) {\r\n\t            this.conPointsGroup.removeAll();\r\n\t        }\r\n\t        //恢复原来的颜色\r\n\t        this.setStyle({color:this.options.style.stroke},true);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建拆线 线断的控制点\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.shapeSetHandle = function() {\r\n\t        for (var i = 1; i < this.turningPoints.length - 2; i++) {\r\n\t            var h;\r\n\t            var x, y;\r\n\t            //是否在一条线上\r\n\t            var isCollineaityFirst = Util.collinearity(this.turningPoints[i - 1], this.turningPoints[i], this.turningPoints[i + 1]);\r\n\t            var isCollineaitySecond = Util.collinearity(this.turningPoints[i], this.turningPoints[i + 1], this.turningPoints[i + 2]);\r\n\t            if ((!isCollineaityFirst && (!isCollineaitySecond || this.turningPoints[i + 1].equals(this.turningPoints[i + 2]))) || ((!isCollineaityFirst || this.turningPoints[i - 1].equals(this.turningPoints[i])) && !isCollineaitySecond)) {\r\n\t\r\n\t                if (this.turningPoints[i].x === this.turningPoints[i + 1].x) { //same vertical\r\n\t                    x = this.turningPoints[i].x;\r\n\t                    y = (this.turningPoints[i].y + this.turningPoints[i + 1].y) / 2;\r\n\t\r\n\t                    h = new Handle('h', x, y, this);\r\n\t\r\n\t\r\n\t                } else if (this.turningPoints[i].y === this.turningPoints[i + 1].y) { // same horizontal\r\n\t                    x = (this.turningPoints[i].x + this.turningPoints[i + 1].x) / 2;\r\n\t                    y = this.turningPoints[i].y;\r\n\t                    h = new Handle('v', x, y, this);\r\n\t                }\r\n\t                if (h) {\r\n\t                    this.add(h.handleShape);\r\n\t                    this.handles.push(h);\r\n\t                }\r\n\t\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 创建箭头\r\n\t     * @param  {[type]} name       [description]\r\n\t     * @param  {[type]} options [description]\r\n\t     * @return {[type]}            [description]\r\n\t     */\r\n\t    Connector.prototype.createSymbol = function(name, options) {\r\n\t        var symbolType = options.symbol.type;\r\n\t        var symbolSize = options.symbol.size;\r\n\t        if (symbolType === 'none') {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        if (!zrUtil.isArray(symbolSize)) {\r\n\t            symbolSize = [symbolSize, symbolSize];\r\n\t        }\r\n\t\r\n\t        var symbolZIndex = options.z;\r\n\t\r\n\t        if (options.symbol.z) { symbolZIndex = options.symbol.z }\r\n\t\r\n\t        var symbolPath = symbolUtil.createSymbol(\r\n\t            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,\r\n\t            symbolSize[0], symbolSize[1], symbolZIndex, options.symbol.color\r\n\t        );\r\n\t        symbolPath.name = name;\r\n\t\r\n\t        return symbolPath;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 绘制线段上的文本\r\n\t     * @param  {[type]} content [description]\r\n\t     * @param  {[type]} name [description]\r\n\t     * @param  {[type]} x       [description]\r\n\t     * @param  {[type]} y       [description]\r\n\t     * @param  {[type]} color   [description]\r\n\t     * @return {[type]}         [description]\r\n\t     */\r\n\t    Connector.prototype.drawText = function(name, content, x, y, color) {\r\n\t        var opt = zrUtil.isString(content) ? {text:content, x:x, y:y, fill:color}\r\n\t                                           : zrUtil.defaults({x:x, y:y, fill:color}, content, true);\r\n\t\r\n\t        var textStyle = zrUtil.defaults(zrUtil.clone(this.options.text), opt, true);\r\n\t        var text = new graphic.Text({\r\n\t            style: textStyle,\r\n\t            zlevel: 20,\r\n\t            name : name\r\n\t        });\r\n\t        return {\r\n\t            text: text,\r\n\t            rect: text.getBoundingRect()\r\n\t        };\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 获取线段的中间值\r\n\t     * @return {[type]} text\r\n\t     */\r\n\t    Connector.prototype.middle = function() {\r\n\t\r\n\t        if (this.options.style.lineType == Connector.TYPE_STRAIGHT || this.options.style.lineType == Connector.TYPE_CHAIN) {\r\n\t            var points = Util.getMaxLineLength(this.turningPoints);\r\n\t            //如果是求线段上的文字的中间值\r\n\t            // if(text) {\r\n\t            //     //取出字的长度，计算角度，\r\n\t            //     var textWidth = graphic.textContain.getWidth(text.text, text.textFont);\r\n\t            //     var angle = Util.getAngle(points[0],points[1]);\r\n\t            //     var length =  Util.distance(points[0],points[1])/2 - textWidth/2;\r\n\t            //     var newPoint = Util.getEndPoint(points[0], length, angle);\r\n\t            //     return [newPoint.x, newPoint.y];\r\n\t            // } else {\r\n\t            //     var middleX = (points[0].x + points[1].x)/2;\r\n\t            //     var middleY = (points[0].y + points[1].y) /2;\r\n\t            //     return [middleX, middleY];\r\n\t            // }\r\n\t            var middleX = (points[0].x + points[1].x) / 2;\r\n\t            var middleY = (points[0].y + points[1].y) / 2;\r\n\t            return [middleX, middleY];\r\n\t        } else if (this.options.style.lineType == Connector.TYPE_JAGGED) {\r\n\t\r\n\t            //find total distance\r\n\t            var distance = this.getLength();\r\n\t\r\n\t            //find between what turning points the half distance is\r\n\t            var index = -1;\r\n\t            var ellapsedDistance = 0;\r\n\t            for (var i = 0; i < this.turningPoints.length - 1; i++) {\r\n\t                index = i;\r\n\t                var segment = Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);\r\n\t                if (ellapsedDistance + segment < distance / 2) {\r\n\t                    ellapsedDistance += segment;\r\n\t                } else {\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t\r\n\t            //we have the middle distance somewhere between i(ndex) and i(ndex)+1\r\n\t            if (index != -1) {\r\n\t                var missingDistance = distance / 2 - ellapsedDistance;\r\n\t                if (Util.round(this.turningPoints[index].x, 3) == Util.round(this.turningPoints[index + 1].x, 3)) { //vertical segment (same x)\r\n\t                    return [this.turningPoints[index].x, Math.min(this.turningPoints[index].y, this.turningPoints[index + 1].y) + missingDistance];\r\n\t                } else if (Util.round(this.turningPoints[index].y, 3) == Util.round(this.turningPoints[index + 1].y, 3)) { //horizontal segment (same y)\r\n\t                    return [Math.min(this.turningPoints[index].x, this.turningPoints[index + 1].x) + missingDistance, this.turningPoints[index].y];\r\n\t                } else {\r\n\t                    console.error(\"Connector:middle() - this should never happen \" + this.turningPoints[index] + \" \" + this.turningPoints[index + 1] + \" nr of points \" + this.turningPoints.length);\r\n\t                }\r\n\t\r\n\t            }\r\n\t        } else if (this.options.style.lineType == Connector.TYPE_CURVE) {\r\n\t            var t = 0.5;\r\n\t            var l = this.getLength();\r\n\t\r\n\t            var walked = 0;\r\n\t            for (var j = 0; j < this.turningPoints.length - 1; j++) {\r\n\t                if (walked + Util.distance(this.turningPoints[j], this.turningPoints[j + 1]) > l * t) {\r\n\t                    break;\r\n\t                }\r\n\t\r\n\t                walked += Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);\r\n\t            }\r\n\t\r\n\t            var rest = l * t - walked;\r\n\t            var currentSegmentLength = Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);\r\n\t\r\n\t            //find the position/ration of the middle of Polyline on current segment\r\n\t            var segmentPercent = rest / currentSegmentLength;\r\n\t\r\n\t            var Xp = segmentPercent * (this.turningPoints[j + 1].x - this.turningPoints[j].x) + this.turningPoints[j].x;\r\n\t            var Yp = segmentPercent * (this.turningPoints[j + 1].y - this.turningPoints[j].y) + this.turningPoints[j].y;\r\n\t\r\n\t            return [Xp, Yp];\r\n\t\r\n\t        }\r\n\t\r\n\t        return null;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * find total distance\r\n\t     * @return {Number} [description]\r\n\t     */\r\n\t    Connector.prototype.getLength = function() {\r\n\t        //find total distance\r\n\t        var distance = 0;\r\n\t        for (var i = 0; i < this.turningPoints.length - 1; i++) {\r\n\t            distance += Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);\r\n\t        }\r\n\t        return distance;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 转JSON对象 bpmn使用\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.toJSON = function() {\r\n\t\r\n\t        this.model.set(\"resourceId\", this.resourceId);\r\n\t        this.model.set(\"properties.type\", 14);\r\n\t\r\n\t        this.model.set(\"bounds.upperLeft.x\", this.position[0]);\r\n\t        this.model.set(\"bounds.upperLeft.y\", this.position[1]);\r\n\t        this.model.set(\"bounds.lowerRight.x\", parseInt(this.position[0] + this.getBoundingRect().width));\r\n\t        this.model.set(\"bounds.lowerRight.y\", parseInt(this.position[1] + this.getBoundingRect().height));\r\n\t        this.model.set(\"style.sPos\", this.options.position.startPos);\r\n\t        this.model.set(\"style.ePos\", this.options.position.endPos);\r\n\t        this.model.set(\"style.lineDash\", this.options.style.lineDash);\r\n\t        this.model.set(\"style.stroke\", this.options.style.stroke);\r\n\t        this.model.set(\"symbol.type\", this.options.symbol.type);\r\n\t        this.model.set(\"dockers\", this.turningPoints);\r\n\t        return this.model.option;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * refreshModel  flow当序列化的时候调用 更新线段的位置 及线上的icons\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.refreshModel = function() {\r\n\t        this.model.set(\"options\", zrUtil.clone(this.options));\r\n\t        this.model.set(\"options.dockers\", this.turningPoints);\r\n\t        var icons = [];\r\n\t        for (var i = 0; i < this.icons.length; i++) {\r\n\t            var iconNode = this.icons[i];\r\n\t            var option = [iconNode.key, {\r\n\t                icon: iconNode.style.image,\r\n\t                width: iconNode.style.width,\r\n\t                height: iconNode.style.height\r\n\t            }];\r\n\t            icons.push(option);\r\n\t        }\r\n\t        this.model.set(\"icons\", icons);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 调整曲线的形状\r\n\t     * @param  {array} points 点数组\r\n\t     * @return {void}\r\n\t     */\r\n\t    Connector.prototype.modifyCurve = function(points) {\r\n\t        var sol = this.getCurvePoint(points);\r\n\t\r\n\t        // 1. 如果曲线的数量 比数量的中数量要少 则删除多余的线段\r\n\t        var willDelCurves = [];\r\n\t        for (var j = sol.length, cntCurve = this.groupCurve.childCount(); j < cntCurve; j++) {\r\n\t            willDelCurves.push(this.groupCurve.childAt(j));\r\n\t        }\r\n\t        zrUtil.each(willDelCurves, function(curve) {\r\n\t            this.groupCurve.remove(curve);\r\n\t        }, this);\r\n\t        // 2. 遍历曲线   如果存在则直接设置形状，否则创建\r\n\t        for (var i = 0; i < sol.length; i++) {\r\n\t            var line = this.groupCurve.childAt(i);\r\n\t            if (line) {\r\n\t                line.attr('shape', sol[i]);\r\n\t            } else {\r\n\t                var cure = new graphic.BezierCurve({\r\n\t                   // position: this.options.position,\r\n\t                    style: this.options.style,\r\n\t                    shape: sol[i],\r\n\t                    z: this.options.z\r\n\t                });\r\n\t                this.groupCurve.add(cure);\r\n\t                this.createHoverStyle(cure);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 根据传入的点数组计算曲线的点\r\n\t     * @param  {array} P 点数组\r\n\t     * @return {object}        曲线的点数组\r\n\t     */\r\n\t    Connector.prototype.getCurvePoint = function(P) {\r\n\t        var n = P.length;\r\n\t        var sol = [];\r\n\t        if (n === 3) {\r\n\t            sol.push({\r\n\t                x1: P[0].x,\r\n\t                y1: P[0].y,\r\n\t                cpx1: P[1].x,\r\n\t                cpy1: P[1].y,\r\n\t                x2: P[2].x,\r\n\t                y2: P[2].y\r\n\t            });\r\n\t            return sol;\r\n\t        } else if (n === 4) {\r\n\t            sol.push({\r\n\t                x1: P[0].x,\r\n\t                y1: P[0].y,\r\n\t                cpx1: P[1].x,\r\n\t                cpy1: P[1].y,\r\n\t                cpx2: P[2].x,\r\n\t                cpy2: P[2].y,\r\n\t                x2: P[3].x,\r\n\t                y2: P[3].y\r\n\t            });\r\n\t            return sol;\r\n\t        }\r\n\t\r\n\t\r\n\t        /**Computes the sum between two point\r\n\t         *@param p1 - {Point}\r\n\t         *@param p2 - {Point}\r\n\t         *@return {Point} the sum of initial points\r\n\t         **/\r\n\t        function sum(p1, p2) {\r\n\t            return new Point(p1.x + p2.x, p1.y + p2.y);\r\n\t        }\r\n\t\r\n\t\r\n\t        /**Computes the division of a {Point} by a number\r\n\t         *@param p - {Point}\r\n\t         *@param nr - {Number}\r\n\t         *@return {Point}\r\n\t         **/\r\n\t        function divide(p, nr) {\r\n\t            if (nr == 0) {\r\n\t                throw \"Division by zero not allowed (yet :) \" + this.callee;\r\n\t            }\r\n\t            return new Point(p.x / nr, p.y / nr);\r\n\t        }\r\n\t\r\n\t        /**Computes the multiplication of a {Point} by a number\r\n\t         *@param p - {Point}\r\n\t         *@param nr - {Number}\r\n\t         *@return {Point}\r\n\t         **/\r\n\t        function multiply(p, nr) {\r\n\t            return new Point(p.x * nr, p.y * nr);\r\n\t        }\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t        /*\r\n\t         *I do not get why first 4 must be 0 and last 3 of same value.....\r\n\t         *but otherwise we will get division by zero\r\n\t         */\r\n\t        var k = [0, 0, 0];\r\n\t\r\n\t        var j;\r\n\t        for (j = 0; j <= n - 3; j++) {\r\n\t            k.push(j);\r\n\t        }\r\n\t\r\n\t        k.push(n - 3, n - 3);\r\n\t\r\n\t\r\n\t\r\n\t        for (var i = 1; i <= n - 3; i++) {\r\n\t            //q1 - compute start point\r\n\t            var q1 = divide(sum(multiply(P[i], k[i + 4] - k[i + 2]), multiply(P[i + 1], k[i + 2] - k[i + 1])), k[i + 4] - k[i + 1]);\r\n\t\r\n\t            //q0 - compute 1st controll point\r\n\t            var q_01 = (k[i + 3] - k[i + 2]) / (k[i + 3] - k[i + 1]);\r\n\t            var q_02 = divide(sum(multiply(P[i - 1], k[i + 3] - k[i + 2]), multiply(P[i], k[i + 2] - k[i])), k[i + 3] - k[i]);\r\n\t            var q_03 = multiply(q1, (k[i + 2] - k[i + 1]) / (k[i + 3] - k[i + 1]));\r\n\t            var q0 = sum(multiply(q_02, q_01), q_03);\r\n\t\r\n\t            //q2 - compute 2nd controll point\r\n\t            var q2 = divide(sum(multiply(P[i], k[i + 4] - k[i + 3]), multiply(P[i + 1], k[i + 3] - k[i + 1])), k[i + 4] - k[i + 1]);\r\n\t\r\n\t            //q3 - compute end point\r\n\t            var q_31 = (k[i + 3] - k[i + 2]) / (k[i + 4] - k[i + 2]);\r\n\t            var q_32 = divide(sum(multiply(P[i + 1], k[i + 5] - k[i + 3]), multiply(P[i + 2], k[i + 3] - k[i + 2])), k[i + 5] - k[i + 2]);\r\n\t            var q_33 = multiply(q2, (k[i + 4] - k[i + 3]) / (k[i + 4] - k[i + 2]));\r\n\t            var q3 = sum(multiply(q_32, q_31), q_33);\r\n\t\r\n\t            //store solution\r\n\t            //\r\n\t            sol.push({\r\n\t                x1: q0.x,\r\n\t                y1: q0.y,\r\n\t                cpx1: q1.x,\r\n\t                cpy1: q1.y,\r\n\t                cpx2: q2.x,\r\n\t                cpy2: q2.y,\r\n\t                x2: q3.x,\r\n\t                y2: q3.y\r\n\t            });\r\n\t        }\r\n\t\r\n\t        return sol;\r\n\t    };\r\n\t\r\n\t\r\n\t    Util.inherits(Connector, Node);\r\n\t\r\n\t    module.exports = Connector;\r\n\t\r\n\t\r\n\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// Symbol factory\r\n\t\r\n\t\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var BoundingRect = __webpack_require__(26);\r\n\t    /**\r\n\t     * Triangle shape\r\n\t     * @inner\r\n\t     */\r\n\t    var Triangle = graphic.extendShape({\r\n\t        type: 'triangle',\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t            cy: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t        buildPath: function (path, shape) {\r\n\t            var cx = shape.cx;\r\n\t            var cy = shape.cy;\r\n\t            var width = shape.width / 2;\r\n\t            var height = shape.height / 2;\r\n\t            path.moveTo(cx, cy - height);\r\n\t            path.lineTo(cx + width, cy + height);\r\n\t            path.lineTo(cx - width, cy + height);\r\n\t            path.closePath();\r\n\t        }\r\n\t    });\r\n\t    /**\r\n\t     * Diamond shape\r\n\t     * @inner\r\n\t     */\r\n\t    var Diamond = graphic.extendShape({\r\n\t        type: 'diamond',\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t            cy: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t        buildPath: function (path, shape) {\r\n\t            var cx = shape.cx;\r\n\t            var cy = shape.cy;\r\n\t            var width = shape.width / 2;\r\n\t            var height = shape.height / 2;\r\n\t            path.moveTo(cx, cy - height);\r\n\t            path.lineTo(cx + width, cy);\r\n\t            path.lineTo(cx, cy + height);\r\n\t            path.lineTo(cx - width, cy);\r\n\t            path.closePath();\r\n\t        }\r\n\t    });\r\n\t\r\n\t    /**\r\n\t     * Pin shape\r\n\t     * @inner\r\n\t     */\r\n\t    var Pin = graphic.extendShape({\r\n\t        type: 'pin',\r\n\t        shape: {\r\n\t            // x, y on the cusp\r\n\t            x: 0,\r\n\t            y: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t\r\n\t        buildPath: function (path, shape) {\r\n\t            var x = shape.x;\r\n\t            var y = shape.y;\r\n\t            var w = shape.width / 5 * 3;\r\n\t            // Height must be larger than width\r\n\t            var h = Math.max(w, shape.height);\r\n\t            var r = w / 2;\r\n\t\r\n\t            // Dist on y with tangent point and circle center\r\n\t            var dy = r * r / (h - r);\r\n\t            var cy = y - h + r + dy;\r\n\t            var angle = Math.asin(dy / r);\r\n\t            // Dist on x with tangent point and circle center\r\n\t            var dx = Math.cos(angle) * r;\r\n\t\r\n\t            var tanX = Math.sin(angle);\r\n\t            var tanY = Math.cos(angle);\r\n\t\r\n\t            path.arc(\r\n\t                x, cy, r,\r\n\t                Math.PI - angle,\r\n\t                Math.PI * 2 + angle\r\n\t            );\r\n\t\r\n\t            var cpLen = r * 0.6;\r\n\t            var cpLen2 = r * 0.7;\r\n\t            path.bezierCurveTo(\r\n\t                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\r\n\t                x, y - cpLen2,\r\n\t                x, y\r\n\t            );\r\n\t            path.bezierCurveTo(\r\n\t                x, y - cpLen2,\r\n\t                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\r\n\t                x - dx, cy + dy\r\n\t            );\r\n\t            path.closePath();\r\n\t        }\r\n\t    });\r\n\t\r\n\t    /**\r\n\t     * Arrow shape\r\n\t     * @inner\r\n\t     */\r\n\t    var Arrow = graphic.extendShape({\r\n\t\r\n\t        type: 'arrow',\r\n\t\r\n\t        shape: {\r\n\t            x: 0,\r\n\t            y: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var height = shape.height;\r\n\t            var width = shape.width;\r\n\t            var x = shape.x;\r\n\t            var y = shape.y;\r\n\t            var dx = width / 3 * 2;\r\n\t            ctx.moveTo(x, y);\r\n\t            ctx.lineTo(x + dx, y + height);\r\n\t            ctx.lineTo(x, y + height / 4 * 3);\r\n\t            ctx.lineTo(x - dx, y + height);\r\n\t            ctx.lineTo(x, y);\r\n\t            ctx.closePath();\r\n\t        }\r\n\t    });\r\n\t\r\n\t    /**\r\n\t     * Map of path contructors\r\n\t     * @type {Object.<string, module:zrender/graphic/Path>}\r\n\t     */\r\n\t    var symbolCtors = {\r\n\t        line: graphic.Line,\r\n\t\r\n\t        rect: graphic.Rect,\r\n\t\r\n\t        roundRect: graphic.Rect,\r\n\t\r\n\t        square: graphic.Rect,\r\n\t\r\n\t        circle: graphic.Circle,\r\n\t\r\n\t        diamond: Diamond,\r\n\t\r\n\t        pin: Pin,\r\n\t\r\n\t        arrow: Arrow,\r\n\t\r\n\t        triangle: Triangle\r\n\t    };\r\n\t\r\n\t    var symbolShapeMakers = {\r\n\t\r\n\t        line: function (x, y, w, h, shape) {\r\n\t            // FIXME\r\n\t            shape.x1 = x;\r\n\t            shape.y1 = y + h / 2;\r\n\t            shape.x2 = x + w;\r\n\t            shape.y2 = y + h / 2;\r\n\t        },\r\n\t\r\n\t        rect: function (x, y, w, h, shape) {\r\n\t            shape.x = x;\r\n\t            shape.y = y;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        },\r\n\t\r\n\t        roundRect: function (x, y, w, h, shape) {\r\n\t            shape.x = x;\r\n\t            shape.y = y;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t            shape.r = Math.min(w, h) / 4;\r\n\t        },\r\n\t\r\n\t        square: function (x, y, w, h, shape) {\r\n\t            var size = Math.min(w, h);\r\n\t            shape.x = x;\r\n\t            shape.y = y;\r\n\t            shape.width = size;\r\n\t            shape.height = size;\r\n\t        },\r\n\t\r\n\t        circle: function (x, y, w, h, shape) {\r\n\t            // Put circle in the center of square\r\n\t            shape.cx = x + w / 2;\r\n\t            shape.cy = y + h / 2;\r\n\t            shape.r = Math.min(w, h) / 2;\r\n\t        },\r\n\t\r\n\t        diamond: function (x, y, w, h, shape) {\r\n\t            shape.cx = x + w / 2;\r\n\t            shape.cy = y + h / 2;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        },\r\n\t\r\n\t        pin: function (x, y, w, h, shape) {\r\n\t            shape.x = x + w / 2;\r\n\t            shape.y = y + h / 2;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        },\r\n\t\r\n\t        arrow: function (x, y, w, h, shape) {\r\n\t            shape.x = x + w / 2;\r\n\t            shape.y = y + h / 2;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        },\r\n\t\r\n\t        triangle: function (x, y, w, h, shape) {\r\n\t            shape.cx = x + w / 2;\r\n\t            shape.cy = y + h / 2;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    var symbolBuildProxies = {};\r\n\t    for (var name in symbolCtors) {\r\n\t        symbolBuildProxies[name] = new symbolCtors[name]();\r\n\t    }\r\n\t\r\n\t    var Symbol = graphic.extendShape({\r\n\t\r\n\t        type: 'symbol',\r\n\t\r\n\t        shape: {\r\n\t            symbolType: '',\r\n\t            x: 0,\r\n\t            y: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t\r\n\t        beforeBrush: function () {\r\n\t            var style = this.style;\r\n\t            var shape = this.shape;\r\n\t            // FIXME\r\n\t            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\r\n\t                style.textPosition = ['50%', '40%'];\r\n\t                style.textAlign = 'center';\r\n\t                style.textVerticalAlign = 'middle';\r\n\t            }\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var symbolType = shape.symbolType;\r\n\t            var proxySymbol = symbolBuildProxies[symbolType];\r\n\t            if (shape.symbolType !== 'none') {\r\n\t                if (!proxySymbol) {\r\n\t                    // Default rect\r\n\t                    symbolType = 'rect';\r\n\t                    proxySymbol = symbolBuildProxies[symbolType];\r\n\t                }\r\n\t                symbolShapeMakers[symbolType](\r\n\t                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\r\n\t                );\r\n\t                proxySymbol.buildPath(ctx, proxySymbol.shape);\r\n\t            }\r\n\t        }\r\n\t    });\r\n\t\r\n\t    // Provide setColor helper method to avoid determine if set the fill or stroke outside\r\n\t    var symbolPathSetColor = function (color) {\r\n\t        if (this.type !== 'image') {\r\n\t            var symbolStyle = this.style;\r\n\t            var symbolShape = this.shape;\r\n\t            if (symbolShape && symbolShape.symbolType === 'line') {\r\n\t                symbolStyle.stroke = color;\r\n\t            }\r\n\t            else if (this.__isEmptyBrush) {\r\n\t                symbolStyle.stroke = color;\r\n\t                symbolStyle.fill = '#fff';\r\n\t            }\r\n\t            else {\r\n\t                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?\r\n\t                symbolStyle.fill && (symbolStyle.fill = color);\r\n\t                symbolStyle.stroke && (symbolStyle.stroke = color);\r\n\t            }\r\n\t            this.dirty();\r\n\t        }\r\n\t    };\r\n\t\r\n\t    var symbolUtil = {\r\n\t        /**\r\n\t         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\r\n\t         * @param {string} symbolType\r\n\t         * @param {number} x\r\n\t         * @param {number} y\r\n\t         * @param {number} w\r\n\t         * @param {number} h\r\n\t         * @param {number} z\r\n\t         * @param {string} color\r\n\t         */\r\n\t        createSymbol: function (symbolType, x, y, w, h, z, color) {\r\n\t            var isEmpty = symbolType.indexOf('empty') === 0;\r\n\t            if (isEmpty) {\r\n\t                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\r\n\t            }\r\n\t            var symbolPath;\r\n\t\r\n\t            if (symbolType.indexOf('image://') === 0) {\r\n\t                symbolPath = new graphic.Image({\r\n\t                    style: {\r\n\t                        image: symbolType.slice(8),\r\n\t                        x: x,\r\n\t                        y: y,\r\n\t                        width: w,\r\n\t                        height: h\r\n\t                    },\r\n\t                    z: z\r\n\t                });\r\n\t            }\r\n\t            else if (symbolType.indexOf('path://') === 0) {\r\n\t                symbolPath = graphic.makePath(symbolType.slice(7), {z: z, rectHover: true}, new BoundingRect(x, y, w, h));\r\n\t            }\r\n\t            else {\r\n\t                symbolPath = new Symbol({\r\n\t                    shape: {\r\n\t                        symbolType: symbolType,\r\n\t                        x: x,\r\n\t                        y: y,\r\n\t                        width: w,\r\n\t                        height: h\r\n\t                    },\r\n\t                    z: z\r\n\t                });\r\n\t            }\r\n\t\r\n\t            symbolPath.__isEmptyBrush = isEmpty;\r\n\t\r\n\t            symbolPath.setColor = symbolPathSetColor;\r\n\t\r\n\t            symbolPath.setColor(color);\r\n\t\r\n\t            return symbolPath;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    module.exports = symbolUtil;\r\n\t\r\n\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 画句柄\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var Util = __webpack_require__(63);\r\n\t    function Handle(type, x, y, connector){\r\n\t        this.type = type;\r\n\t\r\n\t        this.x = x;\r\n\t\r\n\t        this.y = y;\r\n\t\r\n\t        this.visible = true;\r\n\t\r\n\t        this.connector = connector;\r\n\t\r\n\t        this.handleShape = new graphic.Circle({\r\n\t            shape: {\r\n\t                cx: x,\r\n\t                cy: y,\r\n\t                r: Handle.RADIUS\r\n\t            },\r\n\t\r\n\t            style: {\r\n\t                fill: \"rgb(0,255,0)\",\r\n\t                stroke:\"rgb(0,0,0)\"\r\n\t            },\r\n\t            z : connector.options.z + 2,  //节点Z为1 线段为0;\r\n\t            draggable:true\r\n\t        });\r\n\t\r\n\t        var that = this;\r\n\t        this.handleShape.on(\"drag\", function(e) {\r\n\t            that.actionConnector(e.offsetX,e.offsetY);\r\n\t        });\r\n\t       // return this.circle;\r\n\t    }\r\n\t\r\n\t    Handle.RADIUS = 4;\r\n\t\r\n\t    Handle.prototype = {\r\n\t\r\n\t        constructor : Handle,\r\n\t\r\n\t        equals : function(anotherHandle){\r\n\t            if(!anotherHandle instanceof Handle){\r\n\t                return false;\r\n\t            }\r\n\t\r\n\t            return this.type == anotherHandle.type\r\n\t            && this.x == anotherHandle.x\r\n\t            && this.y == anotherHandle.y\r\n\t            && this.visible == anotherHandle.visible;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 移动句柄\r\n\t         * @param  {[type]} newX [description]\r\n\t         * @param  {[type]} newY [description]\r\n\t         * @return {[type]}      [description]\r\n\t         */\r\n\t        actionConnector: function(newX, newY){\r\n\t            switch(this.type){\r\n\t                case 'v':\r\n\t                    var index;\r\n\t                    // 找出两个转折点（可移动句柄在这两个转折点中间）\r\n\t                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){\r\n\t                        if(this.connector.turningPoints[i-1].y == this.connector.turningPoints[i].y\r\n\t                            && this.connector.turningPoints[i].y == this.y\r\n\t                            && Math.min(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) <= this.x\r\n\t                            && Math.max(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) >= this.x)\r\n\t                        {\r\n\t                            index = i;\r\n\t                        }\r\n\t                    }\r\n\t                    var deltaY = newY - this.y;\r\n\t                    var translationMatrix = Util.translationMatrix(0, deltaY);\r\n\t\r\n\t                    this.connector.turningPoints[index-1].transform(translationMatrix);\r\n\t                    this.connector.turningPoints[index].transform(translationMatrix);\r\n\t                    this.connector.refresh();\r\n\t                    this.y = newY;  //将句柄新的位置赋值给y\r\n\t\r\n\t                    break;\r\n\t\r\n\t                case 'h':\r\n\t                    var index;\r\n\t                    // 找出两个转折点（可移动句柄在这两个转折点中间）\r\n\t                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){\r\n\t                        if(this.connector.turningPoints[i-1].x == this.connector.turningPoints[i].x\r\n\t                            && this.connector.turningPoints[i].x == this.x\r\n\t                            && Math.min(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) <= this.y\r\n\t                            && Math.max(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) >= this.y)\r\n\t                            {\r\n\t                            index = i;\r\n\t                        }\r\n\t                    }\r\n\t                    var deltaX = newX-this.x;\r\n\t                    var translationMatrix = Util.translationMatrix(deltaX, 0);\r\n\t                    this.connector.turningPoints[index-1].transform(translationMatrix);\r\n\t                    this.connector.turningPoints[index].transform(translationMatrix);\r\n\t                    this.connector.refresh();\r\n\t                    this.x = newX; //将句柄新的位置赋值给x\r\n\t\r\n\t                    break;\r\n\t            }\r\n\t           //. this.shape.updateMiddleText();\r\n\t        }\r\n\t    };\r\n\t    module.exports = Handle;\r\n\t\r\n\t\r\n\t\r\n\n\n/***/ }),\n/* 83 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 连线动态效果\r\n\t * @author miao.cunzhi\r\n\t */\r\n\t\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var vec2 = __webpack_require__(14);\r\n\t    var curveUtil = __webpack_require__(30);\r\n\t    var symbolUtil = __webpack_require__(81);\r\n\t\r\n\t    function EffectLine(symbol, options, groupCurve, polyLine) {\r\n\t        this._lastFrame = 0;\r\n\t        this._lastFramePercent = 0;\r\n\t        this.symbol = symbol;\r\n\t        this.groupCurve = groupCurve;\r\n\t        this.initSymbol(options, polyLine);\r\n\t    }\r\n\t    var EffectLineProto = EffectLine.prototype;\r\n\t\r\n\t    EffectLineProto.initSymbol = function(options, polyLine) {\r\n\t        var that = this;\r\n\t        this.symbol.z2 = 100;\r\n\t        this.symbol.culling = true;\r\n\t        var period = options.effect.period * 1000;\r\n\t        this.symbol.__t = 0;\r\n\t        this.symbol.stopAnimation();\r\n\t        if ((options.style.lineType == \"curve\")) {\r\n\t            if (this.groupCurve) {\r\n\t                var i = 0;\r\n\t                period = period / this.groupCurve._children.length;\r\n\t                this.groupCurveAnimate(this.groupCurve._children[0], i, period);\r\n\t            }\r\n\t\r\n\t        } else {\r\n\t            this.symbol.animate('', true)\r\n\t                .when(period, {\r\n\t                    __t: 1\r\n\t                })\r\n\t                .delay(0)\r\n\t                .during(function() {\r\n\t                    that.updateSymbolPositionPolyline();\r\n\t                })\r\n\t                .start();\r\n\t            this.setAnimationPointsPolyline(polyLine.shape.points);\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    EffectLineProto.groupCurveAnimate = function(curveLine, i, period) {\r\n\t        var that = this;\r\n\t        if (curveLine == undefined) {\r\n\t            curveLine = this.groupCurve._children[0];\r\n\t            i = 0;\r\n\t        }\r\n\t        var points;\r\n\t        var pos = curveLine.shape;\r\n\t        points = [\r\n\t            [pos.x1, pos.y1],\r\n\t            [pos.x2, pos.y2],\r\n\t            [pos.cpx1, pos.cpy1],\r\n\t            [pos.cpx2, pos.cpy2]\r\n\t        ];\r\n\t        this.setAnimationPointsBezierCurve(points);\r\n\t        this.symbol.animate('')\r\n\t            .when(period, {\r\n\t                __t: 1\r\n\t            })\r\n\t            .delay(0)\r\n\t            .during(function() {\r\n\t                that.updateSymbolPositionBezierCurve();\r\n\t            })\r\n\t            .done(function() {\r\n\t                that.symbol.__t = 0;\r\n\t                that.groupCurveAnimate(that.groupCurve._children[i + 1], i + 1, period);\r\n\t            })\r\n\t            .start();\r\n\t\r\n\t    };\r\n\t\r\n\t\r\n\t    EffectLineProto.setAnimationPointsBezierCurve = function(points) {\r\n\t        this.symbol.__p1 = points[0];\r\n\t        this.symbol.__p2 = points[1];\r\n\t        this.symbol.__cp1 = points[2] || [\r\n\t            (points[0][0] + points[1][0]) / 2,\r\n\t            (points[0][1] + points[1][1]) / 2\r\n\t        ];\r\n\t        this.symbol.__cp2 = points[3];\r\n\t    };\r\n\t\r\n\t    EffectLineProto.updateSymbolPositionBezierCurve = function() {\r\n\t        var p1 = this.symbol.__p1;\r\n\t        var p2 = this.symbol.__p2;\r\n\t        var cp1 = this.symbol.__cp1;\r\n\t        var cp2 = this.symbol.__cp2;\r\n\t        var t = this.symbol.__t;\r\n\t        var pos = this.symbol.position;\r\n\t        var tx, ty;\r\n\t        if (cp2[0] != undefined) {\r\n\t            var cubicAt = curveUtil.cubicAt;\r\n\t            var cubicDerivativeAt = curveUtil.cubicDerivativeAt;\r\n\t            pos[0] = cubicAt(p1[0], cp1[0], cp2[0], p2[0], t);\r\n\t            pos[1] = cubicAt(p1[1], cp1[1], cp2[1], p2[1], t);\r\n\t            // Tangent\r\n\t            tx = cubicDerivativeAt(p1[0], cp1[0], cp2[0], p2[0], t);\r\n\t            ty = cubicDerivativeAt(p1[1], cp1[1], cp2[1], p2[1], t);\r\n\t        } else {\r\n\t            var quadraticAt = curveUtil.quadraticAt;\r\n\t            var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;\r\n\t            pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);\r\n\t            pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);\r\n\t            // Tangent\r\n\t            tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);\r\n\t            ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);\r\n\t        }\r\n\t        this.symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;\r\n\t\r\n\t        this.symbol.ignore = false;\r\n\t    };\r\n\t\r\n\t    EffectLineProto.setAnimationPointsPolyline = function(points) {\r\n\t        this._points = points;\r\n\t        var accLenArr = [0];\r\n\t        var len = 0;\r\n\t        for (var i = 1; i < points.length; i++) {\r\n\t            var p1 = points[i - 1];\r\n\t            var p2 = points[i];\r\n\t            len += vec2.dist(p1, p2);\r\n\t            accLenArr.push(len);\r\n\t        }\r\n\t        if (len === 0) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        for (var j = 0; j < accLenArr.length; j++) {\r\n\t            accLenArr[j] /= len;\r\n\t        }\r\n\t        this._offsets = accLenArr;\r\n\t        this._length = len;\r\n\t        this.symbol._lastFrame = 0;\r\n\t        this.symbol.__lastFramePercent = 0;\r\n\t    };\r\n\t\r\n\t    EffectLineProto.updateSymbolPositionPolyline = function() {\r\n\t        var t = this.symbol.__t;\r\n\t        var points = this._points;\r\n\t        var offsets = this._offsets;\r\n\t        var len = points.length;\r\n\t\r\n\t        if (!offsets) {\r\n\t            // Has length 0\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var lastFrame = this._lastFrame;\r\n\t        var frame;\r\n\t\r\n\t        if (t < this._lastFramePercent) {\r\n\t            // Start from the next frame\r\n\t            // PENDING start from lastFrame ?\r\n\t            var start = Math.min(lastFrame + 1, len - 1);\r\n\t            for (frame = start; frame >= 0; frame--) {\r\n\t                if (offsets[frame] <= t) {\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t            // PENDING really need to do this ?\r\n\t            frame = Math.min(frame, len - 2);\r\n\t        } else {\r\n\t            for (var frame = lastFrame; frame < len; frame++) {\r\n\t                if (offsets[frame] > t) {\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t            frame = Math.min(frame - 1, len - 2);\r\n\t        }\r\n\t        vec2.lerp(\r\n\t            this.symbol.position, points[frame], points[frame + 1],\r\n\t            (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame])\r\n\t        );\r\n\t\r\n\t        this._lastFrame = frame;\r\n\t        this._lastFramePercent = t;\r\n\t        var angle = -Math.atan2(points[frame + 1][1] - points[frame][1], points[frame + 1][0] - points[frame][0]);\r\n\t        this.symbol.rotation = angle - Math.PI / 2;\r\n\t        this.symbol.ignore = false;\r\n\t    };\r\n\t    module.exports = EffectLine;\r\n\t\r\n\n\n/***/ }),\n/* 84 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 控制点\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var graphic = __webpack_require__(3);\r\n\t    function ConnectionPoint(connector, point, type, options){\r\n\t        this.connector = connector;\r\n\t\r\n\t        this.point = point.clone();\r\n\t\r\n\t        this.type = type;\r\n\t\r\n\t        this.color = ConnectionPoint.NORMAL_COLOR;\r\n\t\r\n\t        this.oType = 'ConnectionPoint';\r\n\t\r\n\t        this.shape = new graphic.Circle({\r\n\t            shape: {\r\n\t                cx: this.point.x,\r\n\t                cy: this.point.y,\r\n\t                r: ConnectionPoint.RADIUS\r\n\t            },\r\n\t\r\n\t            style: {\r\n\t                fill: this.color,\r\n\t                stroke:'#000000'\r\n\t            },\r\n\t            z : options.z + 2  //节点Z为1 线段为0;\r\n\t        });\r\n\t        this.shape.type =  this.type;\r\n\t\r\n\t        this.shape.connector = connector;\r\n\t        //return this.circle;\r\n\t    }\r\n\t\r\n\t    ConnectionPoint.NORMAL_COLOR = \"#FFFF33\"; //yellow.\r\n\t\r\n\t    ConnectionPoint.OVER_COLOR = \"#FF9900\"; //orange\r\n\t\r\n\t    ConnectionPoint.CONNECTED_COLOR = \"#ff0000\"; //red\r\n\t\r\n\t    ConnectionPoint.RADIUS = 4;\r\n\t\r\n\t    ConnectionPoint.TYPE_FIGURE = 'figure';\r\n\t\r\n\t    ConnectionPoint.TYPE_CONNECTOR = 'connector';\r\n\t\r\n\t    ConnectionPoint.prototype = {\r\n\t\r\n\t        constructor : ConnectionPoint,\r\n\t\r\n\t        equals : function(anotherConnectionPoint){\r\n\t            return this.point.equals(anotherConnectionPoint.point)\r\n\t            && this.connector == anotherConnectionPoint.connector\r\n\t            && this.type == anotherConnectionPoint.type\r\n\t            && this.color == anotherConnectionPoint.color\r\n\t            && this.radius == anotherConnectionPoint.radius;\r\n\t        }\r\n\t\r\n\t\r\n\t    };\r\n\t    module.exports = ConnectionPoint;\r\n\t\r\n\t\r\n\t\r\n\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 节点等的模型\r\n\t * 里面存的数据用来处理序列化和反序列化\r\n\t * @class fish.topo.model\r\n\t */\r\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var clazzUtil = __webpack_require__(86);\r\n\t\r\n\t    function Model(option, parentModel,  extraOpt) {\r\n\t        this.parentModel = parentModel;\r\n\t        this.option = option;\r\n\t\r\n\t        // Simple optimization\r\n\t        if (this.init) {\r\n\t            if (arguments.length <= 3) {\r\n\t                this.init(option, parentModel,  extraOpt);\r\n\t            }\r\n\t            else {\r\n\t                this.init.apply(this, arguments);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    Model.prototype = {\r\n\t\r\n\t        constructor: Model,\r\n\t\r\n\t        /**\r\n\t         * Model 的初始化函数\r\n\t         * @private\r\n\t         * @param {Object} option\r\n\t         */\r\n\t        init: function (option) {\r\n\t            zrUtil.merge(option, this.getDefaultOption());\r\n\t        },\r\n\t\r\n\t        getDefaultOption: function () {\r\n\t            if (!this.hasOwnProperty('__defaultOption')) {\r\n\t                var optList = [];\r\n\t                var Class = this.constructor;\r\n\t                while (Class) {\r\n\t                    var opt = Class.prototype.defaultOption;\r\n\t                    opt && optList.push(opt);\r\n\t                    Class = Class.superClass;\r\n\t                }\r\n\t\r\n\t                var defaultOption = {};\r\n\t                for (var i = optList.length - 1; i >= 0; i--) {\r\n\t                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\r\n\t                }\r\n\t                this.__defaultOption = defaultOption;\r\n\t            }\r\n\t            return this.__defaultOption;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         */\r\n\t        mergeOption: function (option) {\r\n\t            zrUtil.merge(this.option, option, true);\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 获取model的某个属性的值\r\n\t         * @param {string} path model中的属性\r\n\t         * @return {String}\r\n\t         *\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *          node.model.get(\"options.text\");\r\n\t         */\r\n\t        get: function (path, ignoreParent) {\r\n\t            if (!path) {\r\n\t                return this.option;\r\n\t            }\r\n\t\r\n\t            if (typeof path === 'string') {\r\n\t                path = path.split('.');\r\n\t            }\r\n\t\r\n\t            var obj = this.option;\r\n\t            var parentModel = this.parentModel;\r\n\t            for (var i = 0; i < path.length; i++) {\r\n\t                // obj could be number/string/... (like 0)\r\n\t                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;\r\n\t                if (obj == null) {\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t            if (obj == null && parentModel && !ignoreParent) {\r\n\t                obj = parentModel.get(path);\r\n\t            }\r\n\t            return obj;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 设置model的某个属性的值\r\n\t         * @param {string} path model中的属性\r\n\t         * @param {String} value 所需要设置的值\r\n\t         * @return {String}\r\n\t         *\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *          node.model.set(\"options.text\",\"例子\");\r\n\t         */\r\n\t        set: function (path, value) {\r\n\t            var obj = this.option;\r\n\t\r\n\t            if (path.indexOf(\".\") == -1) {\r\n\t                obj[path] = value;\r\n\t            } else {\r\n\t                var fieldArray  = path.split('.');\r\n\t                var n = fieldArray.length;\r\n\t                var currentRef = obj;\r\n\t                var fieldName;\r\n\t\r\n\t                for (var i = 0; i < n - 1; i++) {\r\n\t                    fieldName = fieldArray[i];\r\n\t                    if(currentRef[fieldName] == null) {\r\n\t                        currentRef[fieldName] = {};\r\n\t                    }\r\n\t                    currentRef = currentRef[fieldName];\r\n\t                }\r\n\t                fieldName = fieldArray[n-1];\r\n\t                currentRef[fieldName] = value;\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         */\r\n\t        getShallow: function (key, ignoreParent) {\r\n\t            var option = this.option;\r\n\t            var val = option && option[key];\r\n\t            var parentModel = this.parentModel;\r\n\t            if (val == null && parentModel && !ignoreParent) {\r\n\t                val = parentModel.getShallow(key);\r\n\t            }\r\n\t            return val;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         */\r\n\t        getModel: function (path, parentModel) {\r\n\t            var obj = this.get(path, true);\r\n\t            var thisParentModel = this.parentModel;\r\n\t            var model = new Model(\r\n\t                obj, parentModel || (thisParentModel && thisParentModel.getModel(path))\r\n\t            );\r\n\t            return model;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         *清空model的option\r\n\t         * @private\r\n\t         */\r\n\t        isEmpty: function () {\r\n\t            return this.option == null;\r\n\t        },\r\n\t\r\n\t        restoreData: function () {},\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         */\r\n\t        clone: function () {\r\n\t            var Ctor = this.constructor;\r\n\t            return new Ctor(zrUtil.clone(this.option));\r\n\t        }\r\n\t    };\r\n\t\r\n\t    // Enable Model.extend.\r\n\t    clazzUtil.enableClassExtend(Model);\r\n\t\r\n\t    module.exports = Model;\r\n\t\r\n\n\n/***/ }),\n/* 86 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t\r\n\t    var clazz = {};\r\n\t\r\n\t    var TYPE_DELIMITER = '.';\r\n\t    var IS_CONTAINER = '___FT__COMPONENT__CONTAINER___';\r\n\t    /**\r\n\t     * @public\r\n\t     */\r\n\t    var parseClassType = clazz.parseClassType = function (componentType) {\r\n\t        var ret = {main: '', sub: ''};\r\n\t        if (componentType) {\r\n\t            componentType = componentType.split(TYPE_DELIMITER);\r\n\t            ret.main = componentType[0] || '';\r\n\t            ret.sub = componentType[1] || '';\r\n\t        }\r\n\t        return ret;\r\n\t    };\r\n\t    /**\r\n\t     * @public  相比 直接用zrUtil.inherits 好处是  可以直接调用父类的构造函数\r\n\t     */\r\n\t    clazz.enableClassExtend = function (RootClass, preConstruct) {\r\n\t        RootClass.extend = function (proto) {\r\n\t            var ExtendedClass = function () {\r\n\t                preConstruct && preConstruct.apply(this, arguments);\r\n\t                RootClass.apply(this, arguments);\r\n\t            };\r\n\t\r\n\t            zrUtil.extend(ExtendedClass.prototype, proto);\r\n\t\r\n\t            ExtendedClass.extend = this.extend;\r\n\t            ExtendedClass.superCall = superCall;\r\n\t            ExtendedClass.superApply = superApply;\r\n\t            zrUtil.inherits(ExtendedClass, this);\r\n\t            ExtendedClass.superClass = this;\r\n\t\r\n\t            return ExtendedClass;\r\n\t        };\r\n\t    };\r\n\t\r\n\t    // superCall should have class info, which can not be fetch from 'this'.\r\n\t    // Consider this case:\r\n\t    // class A has method f,\r\n\t    // class B inherits class A, overrides method f, f call superApply('f'),\r\n\t    // class C inherits class B, do not overrides method f,\r\n\t    // then when method of class C is called, dead loop occured.\r\n\t    function superCall(context, methodName) {\r\n\t        var args = zrUtil.slice(arguments, 2);\r\n\t        return this.superClass.prototype[methodName].apply(context, args);\r\n\t    }\r\n\t\r\n\t    function superApply(context, methodName, args) {\r\n\t        return this.superClass.prototype[methodName].apply(context, args);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @param {Object} entity\r\n\t     * @param {Object} options\r\n\t     * @param {boolean} [options.registerWhenExtend]\r\n\t     * @public\r\n\t     */\r\n\t    clazz.enableClassManagement = function (entity, options) {\r\n\t        options = options || {};\r\n\t\r\n\t        /**\r\n\t         * Component model classes\r\n\t         * key: componentType,\r\n\t         * value:\r\n\t         *     componentClass, when componentType is 'xxx'\r\n\t         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\r\n\t         * @type {Object}\r\n\t         */\r\n\t        var storage = {};\r\n\t\r\n\t        entity.registerClass = function (Clazz, componentType) {\r\n\t            if (componentType) {\r\n\t                componentType = parseClassType(componentType);\r\n\t\r\n\t                if (!componentType.sub) {\r\n\t                    if (storage[componentType.main]) {\r\n\t                        //已经注册过了，直接返回\r\n\t                        return;\r\n\t                    }\r\n\t                    storage[componentType.main] = Clazz;\r\n\t                }\r\n\t                else if (componentType.sub !== IS_CONTAINER) {\r\n\t                    var container = makeContainer(componentType);\r\n\t                    container[componentType.sub] = Clazz;\r\n\t                }\r\n\t            }\r\n\t            return Clazz;\r\n\t        };\r\n\t\r\n\t        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\r\n\t            var Clazz = storage[componentTypeMain];\r\n\t\r\n\t            if (Clazz && Clazz[IS_CONTAINER]) {\r\n\t                Clazz = subType ? Clazz[subType] : null;\r\n\t            }\r\n\t\r\n\t            if (throwWhenNotFound && !Clazz) {\r\n\t                throw new Error(\r\n\t                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'\r\n\t                );\r\n\t            }\r\n\t\r\n\t            return Clazz;\r\n\t        };\r\n\t\r\n\t        entity.getClassesByMainType = function (componentType) {\r\n\t            componentType = parseClassType(componentType);\r\n\t\r\n\t            var result = [];\r\n\t            var obj = storage[componentType.main];\r\n\t\r\n\t            if (obj && obj[IS_CONTAINER]) {\r\n\t                zrUtil.each(obj, function (o, type) {\r\n\t                    type !== IS_CONTAINER && result.push(o);\r\n\t                });\r\n\t            }\r\n\t            else {\r\n\t                result.push(obj);\r\n\t            }\r\n\t\r\n\t            return result;\r\n\t        };\r\n\t\r\n\t        entity.hasClass = function (componentType) {\r\n\t            // Just consider componentType.main.\r\n\t            componentType = parseClassType(componentType);\r\n\t            return !!storage[componentType.main];\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\r\n\t         */\r\n\t        entity.getAllClassMainTypes = function () {\r\n\t            var types = [];\r\n\t            zrUtil.each(storage, function (obj, type) {\r\n\t                types.push(type);\r\n\t            });\r\n\t            return types;\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * If a main type is container and has sub types\r\n\t         * @param  {string}  componentType\r\n\t         * @return {boolean}\r\n\t         */\r\n\t        entity.hasSubTypes = function (componentType) {\r\n\t            componentType = parseClassType(componentType);\r\n\t            var obj = storage[componentType.main];\r\n\t            return obj && obj[IS_CONTAINER];\r\n\t        };\r\n\t\r\n\t        entity.parseClassType = parseClassType;\r\n\t\r\n\t        function makeContainer(componentType) {\r\n\t            var container = storage[componentType.main];\r\n\t            if (!container || !container[IS_CONTAINER]) {\r\n\t                container = storage[componentType.main] = {};\r\n\t                container[IS_CONTAINER] = true;\r\n\t            }\r\n\t            return container;\r\n\t        }\r\n\t\r\n\t        if (options.registerWhenExtend) {\r\n\t            var originalExtend = entity.extend;\r\n\t            if (originalExtend) {\r\n\t                entity.extend = function (proto) {\r\n\t                    var ExtendedClass = originalExtend.call(this, proto);\r\n\t                    return entity.registerClass(ExtendedClass, proto.type);\r\n\t                };\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return entity;\r\n\t    };\r\n\t\r\n\t    module.exports = clazz;\r\n\t\r\n\n\n/***/ }),\n/* 87 */\n/***/ (function(module, exports) {\n\n\t/**\r\n\t * 操作图标类\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t\r\n\t    var IconOperation = {\r\n\t        STRAIGHT_SVG: 'M937.353846 724.676923C882.215385 669.538462 795.569231 661.661538 732.553846 701.046154L362.338462 330.830769C401.723077 267.815385 393.846154 181.169231 338.707692 126.030769 267.815385 55.138462 165.415385 55.138462 94.523077 126.030769 23.630769 196.923077 23.630769 299.323077 94.523077 370.215385 149.661538 425.353846 236.307692 433.230769 299.323077 393.846154L669.538462 764.061538C630.153846 827.076923 638.030769 913.723077 693.169231 968.861538 764.061538 1039.753846 866.461538 1039.753846 937.353846 968.861538 1000.369231 897.969231 1000.369231 795.569231 937.353846 724.676923L937.353846 724.676923ZM275.692308 307.2C244.184615 338.707692 189.046154 338.707692 157.538462 307.2 126.030769 275.692308 126.030769 220.553846 157.538462 189.046154 189.046154 157.538462 244.184615 157.538462 275.692308 189.046154 307.2 220.553846 307.2 267.815385 275.692308 307.2L275.692308 307.2ZM874.338462 913.723077C842.830769 945.230769 787.692308 945.230769 756.184615 913.723077 724.676923 882.215385 724.676923 827.076923 756.184615 795.569231 787.692308 764.061538 842.830769 764.061538 874.338462 795.569231 905.846154 827.076923 905.846154 874.338462 874.338462 913.723077L874.338462 913.723077Z',\r\n\t        JAGGED_SVG: 'M204.8 819.2l-51.2-102.4 204.8-307.2 51.2 102.4-204.8 307.2zM409.6 512l51.2-102.4 153.6 204.8-51.2 102.4-153.6-204.8zM819.2 204.8l51.2 102.4-204.8 409.6-51.2-102.4 204.8-409.6z                                    M153.6 716.8c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8H102.4v-102.4h102.4v102.4zM409.6 204.8C322.56 204.8 256 271.36 256 358.4s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8H358.4V307.2h102.4v102.4zM614.4 614.4c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8h-102.4v-102.4h102.4v102.4zM870.4 0c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8h-102.4V102.4h102.4v102.4z',\r\n\t        CURVE_SVG: 'M1014.285039 824.024234l-145.168428-144.37205c-12.969593-12.855825-37.543559-14.505466-44.597197 2.332252-1.877178 4.550734-2.275367 17.179022-2.275368 17.179022v97.556369H330.935383a118.319095 118.319095 0 0 1-118.546632-117.920905A118.319095 118.319095 0 0 1 330.992267 560.878016h445.516899c121.561493 0 220.426198-98.352747 220.426198-219.23163s-98.864705-219.174746-220.426198-219.174746H340.491925A174.236244 174.236244 0 0 0 174.105698 0 173.78117 173.78117 0 0 0 0.040107 173.09856a173.78117 173.78117 0 0 0 174.065591 173.09856 174.236244 174.236244 0 0 0 166.386227-122.471639h436.017241c65.416807 0 118.603516 52.902288 118.603515 117.920905A118.319095 118.319095 0 0 1 776.509166 459.624176H330.992267c-121.504609 0-220.369314 98.352747-220.369314 219.23163s98.864705 219.174746 220.369314 219.174746h491.194895v92.550561s0 14.221045 2.332252 19.795695c7.053638 16.894602 31.627604 17.577212 44.597197 4.664502l145.111543-144.315165a32.879056 32.879056 0 0 0 0-46.645027zM174.105698 244.94328c-39.818926 0-72.242909-32.25333-72.242909-71.84472s32.423983-71.787835 72.242909-71.787835c39.818926 0 72.186025 32.196446 72.186025 71.787835 0 39.591389-32.423983 71.787835-72.242909 71.787836z',\r\n\t        DEL_SVG: 'M980.992 256h-84.992v683.008c0 47.104-37.888 84.992-84.992 84.992H212.992c-47.104 0-84.992-37.888-84.992-84.992V256H43.008C19.456 256 0 236.544 0 212.992c0-23.552 19.456-43.008 43.008-43.008H256V84.992C256 37.888 293.888 0 340.992 0h340.992C730.112 0 768 37.888 768 84.992v84.992h214.016c23.552 0 43.008 19.456 43.008 43.008-1.024 23.552-20.48 43.008-44.032 43.008zM683.008 84.992H340.992v84.992h340.992V84.992zM212.992 939.008h596.992V256H212.992v683.008z m171.008-470.016v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-23.552 19.456-43.008 43.008-43.008 23.552 1.024 43.008 19.456 43.008 43.008zM512 427.008c23.552 0 43.008 19.456 43.008 43.008v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-24.576 19.456-43.008 43.008-43.008z m171.008 0c23.552 0 43.008 19.456 43.008 43.008v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-24.576 19.456-43.008 43.008-43.008z',\r\n\t        COMMENT_SVG: 'M209.92 152.064l572.416 1.536c12.8 0 23.04 10.24 23.04 23.04v237.568c0 12.8 10.24 23.04 23.04 23.04s23.04-10.24 23.04-23.04V125.44c0-12.8-10.24-23.04-23.04-23.04H158.72c-12.8 0-23.04 10.24-23.04 23.04v773.12c0 12.8 10.24 23.04 23.04 23.04h236.032c12.8 0 23.04-10.24 23.04-23.04s-10.24-22.528-22.528-23.04l-185.856-1.536c-12.8 0-22.528-10.24-22.528-23.04V174.592c0-12.288 10.24-22.528 23.04-22.528z                                            M268.8 570.368h159.232c13.312 0 24.064 10.752 24.576 24.064v2.56c0 13.312-10.752 24.576-24.576 24.576H268.8c-13.312 0-24.064-10.752-24.576-24.064v-2.56c0.512-13.312 11.264-24.576 24.576-24.576z m0-312.32h441.344c13.312 0 24.576 10.752 24.576 24.576v2.56c0 13.312-10.752 24.576-24.576 24.576H268.8c-13.312 0-24.576-10.752-24.576-24.576v-2.56c0.512-13.312 11.264-24.576 24.576-24.576z m0.512 155.648h269.312c13.312 0 24.576 10.752 24.576 24.064v2.56c0 13.312-10.752 24.576-24.576 24.576H269.312c-13.312 0-24.576-10.752-24.576-24.064v-2.56c0-13.824 10.752-24.576 24.576-24.576z m471.04 13.312l-246.784 339.456c-1.536 2.56-2.56 5.632-2.56 8.704l-1.536 132.096c0 9.728 9.728 16.896 18.944 14.336l122.88-37.888c3.072-1.024 5.632-3.072 7.68-5.632l246.784-338.944c4.608-6.144 3.584-15.36-2.56-19.968l-121.344-94.72c-7.168-5.632-16.896-4.096-21.504 2.56z m23.04 67.584l51.2 39.936c2.048 1.536 2.56 5.12 1.024 7.168l-26.112 35.84c-1.536 2.56-5.12 3.072-7.68 1.024l-51.712-38.912c-2.048-1.536-2.56-4.608-1.024-7.168l26.624-37.376c2.048-1.536 5.632-2.048 7.68-0.512z m-165.888 341.504l-35.328 10.752c-9.216 3.072-18.944-4.096-18.944-13.824l0.512-40.96c0-3.072 1.024-6.144 2.56-8.704l137.216-187.904c1.536-2.56 5.12-2.56 7.168-1.024l51.2 38.4c2.56 2.048 3.072 5.12 1.024 7.68l-137.728 189.952c-2.048 2.56-4.608 4.608-7.68 5.632z',\r\n\t        CHANGE_LINE_TYPE_SVG: 'M1008 335.2 1008 335.2l-160 144 0 0c-8.8 8-20 12.8-32 12.8-26.4 0-48-21.6-48-48 0-14.4 6.4-26.4 16-35.2l0 0 67.2-60L560 348.8c0 0 0 0 0 0L464 348.8l0 0L352 348.8 48 348.8c-26.4 0-48-21.6-48-48 0-26.4 21.6-48 48-48l124.8 0 0 0L416 252.8l0 0 208 0 0 0 227.2 0L784 192l0 0c-9.6-8.8-16-21.6-16-35.2 0-26.4 21.6-48 48-48 12 0 23.2 4.8 32 12.8l0 0 160 144 0 0c9.6 8.8 16 21.6 16 35.2C1024 314.4 1017.6 326.4 1008 335.2zM16 680.8 16 680.8l160-144 0 0c8.8-8 20-12.8 32-12.8 26.4 0 48 21.6 48 48 0 14.4-6.4 26.4-16 35.2l0 0-67.2 60L400 667.2l0 0 208 0 0 0 243.2 0 0 0L976 667.2c26.4 0 48 21.6 48 48 0 26.4-21.6 48-48 48L672 763.2 560 763.2c0 0 0 0 0 0L464 763.2l0 0L172.8 763.2 240 824l0 0c9.6 8.8 16 21.6 16 35.2 0 26.4-21.6 48-48 48-12 0-23.2-4.8-32-12.8l0 0L16 752l0 0c-9.6-8.8-16-21.6-16-35.2C0 701.6 6.4 689.6 16 680.8z'\r\n\t    }\r\n\t    module.exports = IconOperation;\r\n\n\n/***/ }),\n/* 88 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * flow连线管理类\r\n\t * @author miao.cunzhi\r\n\t */\r\n\t\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var ConnectionManager = __webpack_require__(89);\r\n\t    var Connector = __webpack_require__(80);\r\n\t    var Util = __webpack_require__(63);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var Point = __webpack_require__(64);\r\n\t    var Constants = __webpack_require__(91);\r\n\t    var Model = __webpack_require__(85);\r\n\t    var Log = __webpack_require__(90);\r\n\t\r\n\t    function LinkConnectionManager() {\r\n\t        ConnectionManager.call(this);\r\n\t        this.LineOperations = []; //存放线的操作按钮\r\n\t        this.bundleOffset = 30; //多线段的偏移\r\n\t        this.bundleGap = 20; // 多线段的间隔\r\n\t        this.connectorMap = Util.StackedMap.createNew(); //存放多线段\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 根据起始点创建连线\r\n\t     * @param  {[type]} options      [类型]\r\n\t     * @param {[type]} [api] [description]\r\n\t     * @return {[type]}           [返回连线]\r\n\t     */\r\n\t    LinkConnectionManager.prototype.connectorCreateOfPoints = function(options, api) {\r\n\t        var that = this;\r\n\t        var model = options.model;\r\n\t        //1.创建线段\r\n\t        var connector = new Connector(options);\r\n\t        if (options.startDemoId && options.endDemoId) {\r\n\t            connector.startDemoId = options.startDemoId;\r\n\t            connector.endDemoId = options.endDemoId;\r\n\t        }\r\n\t        if (options.pos) {\r\n\t            var pos = options.pos.split(\",\");\r\n\t            connector.sPos = pos[0];\r\n\t            connector.ePos = pos[1];\r\n\t        };\r\n\t        this.connectors.push(connector);\r\n\t\r\n\t        if (connector.conPointsGroup) {\r\n\t            connector.conPointsGroup.on(\"click\", function(e) {\r\n\t                var arrSplit = e.target.type.split(Connector.SEPERATOR);\r\n\t                var connector = e.target.connector;\r\n\t                if (arrSplit[0] === Connector.START_NODE) {\r\n\t                    connector.sPos = arrSplit[1];\r\n\t                } else if (arrSplit[0] === Connector.END_NODE) {\r\n\t                    connector.ePos = arrSplit[1];\r\n\t                };\r\n\t                that.refreshConnector(connector, true);\r\n\t                e.cancelBubble = true;\r\n\t                var params = {};\r\n\t                params.event = e;\r\n\t                params.type = \"conPointsGroup:click\";\r\n\t                params.lineNode = that.selConnector;\r\n\t                api.trigger(params.type, params);\r\n\t            });\r\n\t        }\r\n\t\r\n\t\r\n\t        var MOUSE_EVENT_NAMES = ['click', 'dblclick'];\r\n\t        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n\t            connector.on(\"Connector:\" + eveName, function(e) {\r\n\t\r\n\t                var selected = e.target;\r\n\t\r\n\t                if (that.selConnector !== selected) {\r\n\t                    that.selConnector && that.refreshConnector(that.selConnector);\r\n\t                    that.selConnector = selected;\r\n\t                };\r\n\t                e.cancelBubble = true;\r\n\t                var params = {};\r\n\t                params.event = e;\r\n\t                params.type = eveName;\r\n\t                params.target = that.selConnector;\r\n\t                api.trigger(params.type, params);\r\n\t            });\r\n\t        });\r\n\t\r\n\t        this.bundleOffset = options.bundleOffset || this.bundleOffset;\r\n\t        this.bundleGap = options.bundleGap || this.bundleGap;\r\n\t        var dockers = options.dockers;\r\n\t        if (dockers && dockers.length >= 2) {\r\n\t            var points = Point.loadArray(dockers);\r\n\t            connector.refresh(points);\r\n\t        } else {\r\n\t            if (options.position && options.position.points) {\r\n\t                var points = options.position.points;\r\n\t                connector.refresh(points);\r\n\t            }\r\n\t        }\r\n\t\r\n\t        //3.设置模型\r\n\t        var model = new Model({});\r\n\t        model.set(Constants.ELEMENT_TYPE, Constants.CONNECTION);\r\n\t        model.set(Constants.OPTIONS, zrUtil.clone(options));\r\n\t        model.set(Constants.DOCKERS, connector.turningPoints);\r\n\t        model.set(Constants.STYLE_LINETYPE, options.style.lineType);\r\n\t        connector.model = model;\r\n\t        return connector;\r\n\t    }\r\n\t    LinkConnectionManager.prototype.getTwoNodeId = function(startNode, endNode) {\r\n\t            return startNode.id + \",\" + endNode.id;\r\n\t        }\r\n\t        //处理多条线段\r\n\t    LinkConnectionManager.prototype.refreshCons = function(arrCons) {\r\n\t        //如果是折线的话\r\n\t        if (arrCons[0].options.style.lineType == Connector.TYPE_JAGGED) {\r\n\t            for (var i = 0; i < arrCons.length; i++) {\r\n\t                this.refreshConnector(arrCons[i], true);\r\n\t            };\r\n\t        } else {\r\n\t            this.refreshConsStraight(arrCons);\r\n\t        };\r\n\t    }\r\n\t\r\n\t    //处理多条线段(直线)\r\n\t    LinkConnectionManager.prototype.refreshConsStraight = function(arrCons) {\r\n\t        var half = parseInt(arrCons.length / 2);\r\n\t        var arrConnectResult = []\r\n\t\r\n\t        var startNode = arrCons[0].startNode;\r\n\t        var endNode = arrCons[0].endNode;\r\n\t        var sRect = Util.getRect(startNode).boundingRect;\r\n\t        var eRect = Util.getRect(endNode).boundingRect;\r\n\t        var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n\t        var eConnectorPoint = Util.getConnectorPoints(eRect);\r\n\t        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n\t\r\n\t        if (!arrCons[0].sPos || !arrCons[0].ePos) {\r\n\t            if (sRect.x < eRect.x) {\r\n\t                arrCons[0].sPos = \"right\";\r\n\t                arrCons[0].ePos = \"left\";\r\n\t            } else {\r\n\t                arrCons[0].sPos = \"left\";\r\n\t                arrCons[0].ePos = \"right\";\r\n\t            }\r\n\t        }\r\n\t        var startPoint = sConnectorPoint[arrCons[0].sPos];\r\n\t        var endPoint = eConnectorPoint[arrCons[0].ePos];\r\n\t        var angle = Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x);\r\n\t        for (var i = half; i >= 1; i--) {\r\n\t            var points = [];\r\n\t            points.push(startPoint); //\r\n\t            // points.push(new Point(startPoint.x + bundleOffset , startPoint.y + i * bundleGap));\r\n\t            // points.push(new Point(endPoint.x - bundleOffset , startPoint.y + i * bundleGap)); //startPoint.x + bundleOffset\r\n\t            var secondPoint = startPoint.clone();\r\n\t\r\n\t            //secondPoint.x =  secondPoint.x + this.bundleOffset;\r\n\t            secondPoint.transform(Util.translationMatrix(0, this.bundleGap * i));\r\n\t            //secondPoint = this.boundOffsetXY(secondPoint, true);\r\n\t            //\r\n\t            //直角坐标 x, 和 y, 计算出极坐标\r\n\t\r\n\t\r\n\t            //从极坐标计算出直角坐标\r\n\t            secondPoint.x = secondPoint.x + this.bundleOffset * Math.cos(angle);\r\n\t            secondPoint.y = secondPoint.y + this.bundleOffset * Math.sin(angle);\r\n\t\r\n\t\r\n\t\r\n\t            //secondPoint.transform(Util.scaleMatrix(0.5));\r\n\t            points.push(secondPoint);\r\n\t\r\n\t            var thirdPoint = endPoint.clone();\r\n\t            //thirdPoint.x =  thirdPoint.x - this.bundleOffset;\r\n\t\r\n\t\r\n\t\r\n\t            thirdPoint.transform(Util.translationMatrix(0, this.bundleGap * i));\r\n\t            //thirdPoint = this.boundOffsetXY(thirdPoint, false);\r\n\t            //secondPoint.transform(Util.scaleMatrix(0.5));\r\n\t            //\r\n\t            //直角坐标 x, 和 y, 计算出极坐标\r\n\t\r\n\t            //从极坐标计算出直角坐标\r\n\t            thirdPoint.x = thirdPoint.x - this.bundleOffset * Math.cos(angle);\r\n\t            thirdPoint.y = thirdPoint.y - this.bundleOffset * Math.sin(angle);\r\n\t\r\n\t            points.push(thirdPoint);\r\n\t\r\n\t            points.push(endPoint);\r\n\t            arrConnectResult.push(points);\r\n\t        };\r\n\t\r\n\t        arrConnectResult.push([startPoint, endPoint]);\r\n\t\r\n\t        var upHalf = Math.ceil(arrCons.length / 2);\r\n\t        for (var i = 1; i < upHalf; i++) {\r\n\t            var points = [];\r\n\t            points.push(startPoint);\r\n\t            var secondPoint = startPoint.clone();\r\n\t            //secondPoint.x =  secondPoint.x + this.bundleOffset;\r\n\t            secondPoint.transform(Util.translationMatrix(0, -this.bundleGap * i));\r\n\t            secondPoint.x = secondPoint.x + this.bundleOffset * Math.cos(angle);\r\n\t            secondPoint.y = secondPoint.y + this.bundleOffset * Math.sin(angle);\r\n\t            points.push(secondPoint);\r\n\t\r\n\t            var thirdPoint = endPoint.clone();\r\n\t            //thirdPoint.x =  thirdPoint.x - this.bundleOffset;\r\n\t            thirdPoint.transform(Util.translationMatrix(0, -this.bundleGap * i));\r\n\t            //从极坐标计算出直角坐标\r\n\t            thirdPoint.x = thirdPoint.x - this.bundleOffset * Math.cos(angle);\r\n\t            thirdPoint.y = thirdPoint.y - this.bundleOffset * Math.sin(angle);\r\n\t            //secondPoint.transform(Util.scaleMatrix(0.5));\r\n\t            points.push(thirdPoint);\r\n\t\r\n\t            points.push(endPoint);\r\n\t            arrConnectResult.push(points);\r\n\t        };\r\n\t\r\n\t\r\n\t        for (var i = 0; i < arrConnectResult.length; i++) {\r\n\t            arrCons[i].refresh(arrConnectResult[i]);\r\n\t        };\r\n\t\r\n\t    }\r\n\t    LinkConnectionManager.prototype.boundOffsetXY = function(point, isPositive) {\r\n\t        var resultPoint = point.clone();\r\n\t        //直角坐标 x, 和 y, 计算出极坐标\r\n\t        var angle = Math.atan2(resultPoint.y, resultPoint.x);\r\n\t        var r = Math.sqrt(Math.pow(resultPoint.x, 2) + Math.pow(resultPoint.y, 2));\r\n\t        if (isPositive) {\r\n\t            r = r + this.bundleOffset;\r\n\t        } else {\r\n\t            r = r - this.bundleOffset;\r\n\t        }\r\n\t\r\n\t\r\n\t        //从极坐标计算出直角坐标\r\n\t        resultPoint.x = r * Math.cos(angle);\r\n\t        resultPoint.y = r * Math.sin(angle);\r\n\t        return resultPoint;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 设置线段的模型数据  (类型 文字)\r\n\t     * @param {[type]} connector [description]\r\n\t     * @param {[type]} option    [description]\r\n\t     */\r\n\t    LinkConnectionManager.prototype.setModel = function(connector, option) {\r\n\t        var originLineType = connector.model.get(\"style.lineType\");\r\n\t        connector.model.mergeOption(option);\r\n\t        if (originLineType !== option.style.lineType) {\r\n\t            this.refreshConnector(connector, true);\r\n\t        };\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 刷新连接线\r\n\t     * @param  {[type]} node [description]\r\n\t     * @return {[type]}      [description]\r\n\t     */\r\n\t    LinkConnectionManager.prototype.refreshLineByNode = function(node) {\r\n\t        // 判断这个节点是否有多条线段\r\n\t        var keys = this.connectorMap.keys();\r\n\t        for (var i = 0; i < keys.length; i++) {\r\n\t            var key = keys[i];\r\n\t            if (key.indexOf(node.id) != -1) {\r\n\t                var arrCons = this.connectorMap.get(key);\r\n\t                if (arrCons.length == 1) {\r\n\t                    //两个节点只有一个连线的情况\r\n\t                    this.refreshConnector(arrCons[0], true);\r\n\t                } else if (arrCons.length > 1) {\r\n\t                    //两个节点有多个连线的情况\r\n\t                    this.refreshCons(arrCons);\r\n\t                };\r\n\t            };\r\n\t        };\r\n\t    }\r\n\t\r\n\t    zrUtil.inherits(LinkConnectionManager, ConnectionManager);\r\n\t    module.exports = LinkConnectionManager;\r\n\t\r\n\n\n/***/ }),\n/* 89 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 连线管理类\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var Util = __webpack_require__(63);\r\n\t    var Point = __webpack_require__(64);\r\n\t    var Connector = __webpack_require__(80);\r\n\t    var Log = __webpack_require__(90);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t\r\n\t    function ConnectionManager() {\r\n\t        this.connectors = []; //当前画布所有的线段\r\n\t        this.selConnector = null; //当前选中的线段\r\n\t        this.tempConnector = null; //临时线段\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 设置线的不可编辑\r\n\t     * @param  {[type]} forbidEdit [description]\r\n\t     * @return {[type]}            [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.connectorForbidEdit = function (forbidEdit) {\r\n\t        for (var i = 0; i < this.connectors.length; i++) {\r\n\t            this.connectors[i].options.isEdit = !forbidEdit;\r\n\t        }\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 清空连接线上的调整位置按钮\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.clearSelectCon = function () {\r\n\t        if (this.selConnector != null) {\r\n\t            this.refreshConnector(this.selConnector);\r\n\t        }\r\n\t    }\r\n\t    /**\r\n\t     * 删除和节点相关联的连接线\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.deleteSelectCon = function (node, _zr) {\r\n\t        for (var i = 0; i < this.connectors.length; i++) {\r\n\t            if (this.connectors[i].startNode == node || this.connectors[i].endNode == node) {\r\n\t                //1.将线 所联的startNode的outgoing数据删除\r\n\t                var startNodeOutgoing = this.connectors[i].startNode.model.get(\"outgoing\");\r\n\t                var index = zrUtil.indexOf(startNodeOutgoing, this.connectors[i].resourceId);\r\n\t                if (index != -1) {\r\n\t                    startNodeOutgoing.splice(index, 1);\r\n\t                }\r\n\t                //2.从_zr上删除\r\n\t                _zr.remove(this.connectors[i]);\r\n\t                this.connectors.splice(i, 1);\r\n\t                i--;\r\n\t                this.selConnector = null;\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    ConnectionManager.prototype.removeLine = function (line, zr) {\r\n\t        this.selConnector = line;\r\n\t        this.deleteLine(zr);\r\n\t    }\r\n\t    /**\r\n\t     * 删除选定的线\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.deleteLine = function (_zr) {\r\n\t        //1.将线 所联的startNode的outgoing数据删除\r\n\t        if(this.selConnector.startNode){\r\n\t            var startNodeOutgoing = this.selConnector.startNode.model.get(\"outgoing\");\r\n\t            index = zrUtil.indexOf(startNodeOutgoing, this.selConnector.resourceId);\r\n\t            if (index != -1) {\r\n\t                startNodeOutgoing.splice(index, 1);\r\n\t            }\r\n\t\r\n\t            if (this.connectorMap) {\r\n\t                var key = this.getTwoNodeId(this.selConnector.startNode, this.selConnector.endNode, this.selConnector.options.position);\r\n\t                this.connectorMap.removeItem(key, this.selConnector);\r\n\t            }\r\n\t        }\r\n\t\r\n\t\r\n\t        //2.从_zr上删除\r\n\t        _zr.remove(this.selConnector);\r\n\t\r\n\t\r\n\t        //3.从线数据中删除\r\n\t        var index = zrUtil.indexOf(this.connectors, this.selConnector);\r\n\t        if (index != -1) {\r\n\t            this.connectors.splice(index, 1);\r\n\t        }\r\n\t        this.selConnector = null;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 重新画线\r\n\t     * @param  {[type]} connector          [description]\r\n\t     * @param  {[type]} force\r\n\t     * @return {[type]}                    [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.refreshConnector = function (connector, force) {\r\n\t        // 只有需要强制刷新  或者 连线为空（<2)时 才进行重新计算重绘\r\n\t        if (force || (!connector.turningPoints) || (connector.turningPoints.length < 2)) {\r\n\t            if (connector.model && connector.model.get(\"style.lineType\")) {\r\n\t                connector.options.style.lineType = connector.model.get(\"style.lineType\");\r\n\t            }\r\n\t            var arrStartEndPoint = this.getStartEndPoint(connector);\r\n\t            var escapeDistance = null;\r\n\t            if (connector.options.position && connector.options.position.escapeDistance) {\r\n\t                escapeDistance = connector.options.position.escapeDistance;\r\n\t            }\r\n\t            var solutions = this.connector2Points(connector.options.style.lineType, arrStartEndPoint[0],\r\n\t                arrStartEndPoint[1],\r\n\t                arrStartEndPoint[2], arrStartEndPoint[3], escapeDistance); // TYPE_STRAIGHT TYPE_JAGGED\r\n\t\r\n\t            connector.refresh(solutions[0][2]);\r\n\t        }\r\n\t\r\n\t        connector.clearHandles(); //清空handle\r\n\t    }\r\n\t\r\n\t\r\n\t    ConnectionManager.prototype.getStartEndPoint = function (connector) {\r\n\t        var startNode = connector.startNode;\r\n\t        var endNode = connector.endNode;\r\n\t        var isNotInSameGroup = true;\r\n\t        isNotInSameGroup = startNode.parent !== endNode.parent;\r\n\t\r\n\t        var sRect = startNode.getRect ? startNode.getRect().boundingRect : Util.getRect(startNode, isNotInSameGroup).boundingRect;\r\n\t        var sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(\r\n\t            sRect.y) + Number(sRect.height)];\r\n\t\r\n\t        var eRect = endNode.getRect ? endNode.getRect().boundingRect : Util.getRect(endNode, isNotInSameGroup).boundingRect;\r\n\t        var eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(\r\n\t            eRect.y) + Number(eRect.height)];\r\n\t\r\n\t\r\n\t        var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n\t        var eConnectorPoint = Util.getConnectorPoints(eRect);\r\n\t\r\n\t        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n\t        var position = connector.options.position;\r\n\t        if (position.direction) {\r\n\t            var posArr = position.direction.split(',');\r\n\t            position.startPos = posArr[0];\r\n\t            position.endPos = posArr[1];\r\n\t        }\r\n\t        if (!position.startPos || !position.endPos) {\r\n\t            if (sRect.x < eRect.x) {\r\n\t                position.startPos = \"right\";\r\n\t                position.endPos = \"left\";\r\n\t            } else {\r\n\t                position.startPos = \"left\";\r\n\t                position.endPos = \"right\";\r\n\t            }\r\n\t        }\r\n\t        var startPoint = this.calcPointExpression(position.startPos, sConnectorPoint);\r\n\t        var endPoint = this.calcPointExpression(position.endPos, eConnectorPoint);\r\n\t        startPoint.add(new Point(position.startOffset[0], position.startOffset[1]));\r\n\t        endPoint.add(new Point(position.endOffset[0], position.endOffset[1]));\r\n\t        return [startPoint, endPoint, sBounds, eBounds];\r\n\t    }\r\n\t\r\n\t    ConnectionManager.prototype.calcPointExpression = function (pos, point) {\r\n\t        var variable = {\r\n\t            top: point.top.x,\r\n\t            left: point.left.y,\r\n\t            right: point.right.y,\r\n\t            bottom: point.bottom.x,\r\n\t            center: point.center.x\r\n\t        };\r\n\t\r\n\t        var expression = \"<% print(\" + pos + \") %>\";\r\n\t        var val = parseInt(Util.template(expression)(variable));\r\n\t        if (pos.indexOf(\"top\") != -1) {\r\n\t            return new Point(val, point.top.y);\r\n\t        } else if (pos.indexOf(\"left\") != -1) {\r\n\t            return new Point(point.left.x, val);\r\n\t        } else if (pos.indexOf(\"right\") != -1) {\r\n\t            return new Point(point.right.x, val);\r\n\t        } else if (pos.indexOf(\"bottom\") != -1) {\r\n\t            return new Point(val, point.bottom.y);\r\n\t        } else if (pos.indexOf(\"center\") != -1) {\r\n\t            return new Point(val, point.bottom.y);\r\n\t        } else {\r\n\t            throw new Error(\"pos参数错误\");\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 创建或修改临时线\r\n\t     * @param  {[type]} startNode             [description]\r\n\t     * @param  {[type]} rEndPoint             [description]\r\n\t     * @param  {[type]} lineType              [description]\r\n\t     * @param  {[type]} startPos              [description]\r\n\t     * @return {[type]}                       [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.manageTempConnector = function (startNode, rEndPoint, lineType, startPos) {\r\n\t\r\n\t        var sRect = startNode.getRect ? startNode.getRect().boundingRect : Util.getRect(startNode,true).boundingRect;\r\n\t\r\n\t        var sBounds = [sRect.x, sRect.y, sRect.x + sRect.width, sRect.y + sRect.height];\r\n\t        var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n\t\r\n\t        if (!this.tempConnector) {\r\n\t            this.tempConnector = new Connector({\r\n\t                isEdit: false,\r\n\t                style: {\r\n\t                    lineType: lineType\r\n\t                }\r\n\t            });\r\n\t        }\r\n\t\r\n\t        var connector = this.tempConnector;\r\n\t        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n\t        var position = connector.options.position;\r\n\t        position.startPos = startPos ? startPos : (sRect.x < rEndPoint.x ? \"right\" : \"left\");\r\n\t        position.endPos = sRect.x < rEndPoint.x ? \"left\" : \"right\";\r\n\t        \r\n\t        connector.options.style.lineType = lineType;\r\n\t        var solutions = this.connector2Points(lineType, sConnectorPoint[position.startPos], rEndPoint,\r\n\t            sBounds, null); // TYPE_STRAIGHT TYPE_JAGGED\r\n\t\r\n\t        connector.refresh(solutions[0][2]);\r\n\t        return connector;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 创建或修改临时反转线\r\n\t     * @param  {[type]} startPoint              [description]\r\n\t     * @param  {[type]} endNode                 [description]\r\n\t     * @param  {[type]} lineType                [description]\r\n\t     * @param  {[type]} endPos                  [description]\r\n\t     * @return {[type]}                         [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.manageReverseTempConnector = function (startPoint, endNode, lineType, endPos) {\r\n\t        var eRect = endNode.getRect ? endNode.getRect().boundingRect : Util.getRect(endNode,true).boundingRect;\r\n\t        var eBounds = [eRect.x, eRect.y, eRect.x + eRect.width, eRect.y + eRect.height];\r\n\t        var eConnectorPoint = Util.getConnectorPoints(eRect);\r\n\t        if (!this.tempConnector) {\r\n\t            this.tempConnector = new Connector({\r\n\t                isEdit: false,\r\n\t                style: {\r\n\t                    lineType: lineType\r\n\t                }\r\n\t            });\r\n\t        }\r\n\t        var connector = this.tempConnector;\r\n\t        var position = connector.options.position;\r\n\t        position.endPos = endPos ? endPos : (eRect.x < startPoint.x ? \"right\" : \"left\");\r\n\t        position.startPos = eRect.x < startPoint.x ? \"left\" : \"right\";\r\n\t        \r\n\t        connector.options.style.lineType = lineType;\r\n\t        var solutions = this.connector2Points(lineType, startPoint, eConnectorPoint[position.endPos],\r\n\t            eBounds, null); // TYPE_STRAIGHT TYPE_JAGGED\r\n\t\r\n\t        connector.refresh(solutions[0][2]);\r\n\t        return connector;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 删除临时线\r\n\t     * @param  {[type]} zr             [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.removeTempConnector = function (zr) {\r\n\t        if (this.tempConnector) {\r\n\t            zr.remove(this.tempConnector);\r\n\t            this.tempConnector = null;\r\n\t        }\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 算出 两个节点 指定两个点如何联线\r\n\t     * @param  {[type]} type       [description]\r\n\t     * @param  {[type]} startPoint [description]\r\n\t     * @param  {[type]} endPoint   [description]\r\n\t     * @param  {[type]} sBounds    [description]\r\n\t     * @param  {[type]} eBounds    [description]\r\n\t     * @return {[type]}            [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.connector2Points = function (type, startPoint, endPoint, sBounds, eBounds,\r\n\t        escapeDistance) {\r\n\t        var figureEscapeDistance = [30, 30];\r\n\t        if (escapeDistance) {\r\n\t            if (!zrUtil.isArray(escapeDistance)) {\r\n\t                figureEscapeDistance = [escapeDistance, escapeDistance];\r\n\t            } else {\r\n\t                figureEscapeDistance = escapeDistance;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        Log.group(\"connectionManager: connector2Points\");\r\n\t\r\n\t\r\n\t        Log.info(\"ConnectionManager: connector2Points (\" + type + \", \" + startPoint + \", \" + endPoint +\r\n\t            \", \" + sBounds + \", \" + eBounds + ')');\r\n\t        var solutions = [];\r\n\t\r\n\t\r\n\t\r\n\t        switch (type) {\r\n\t            case Connector.TYPE_CHAIN:\r\n\t            \r\n\t            case Connector.TYPE_STRAIGHT: //直线\r\n\t                var points = [startPoint.clone(), endPoint.clone()];\r\n\t                solutions.push(['straight', 'straight', points]);\r\n\t                break;\r\n\t\r\n\t            case Connector.TYPE_CURVE: //曲线\r\n\t\r\n\t            case Connector.TYPE_JAGGED: //折线\r\n\t                var startExitPoint = null;\r\n\t                var endExitPoint = null;\r\n\t\r\n\t                //find start exit point  寻找开始出口\r\n\t                if (sBounds != null) {\r\n\t                    var potentialExits = [];\r\n\t\r\n\t                    potentialExits.push(new Point(startPoint.x, sBounds[1] - figureEscapeDistance[0])); //north 北\r\n\t                    potentialExits.push(new Point(sBounds[2] + figureEscapeDistance[0], startPoint.y)); //east  东\r\n\t                    potentialExits.push(new Point(startPoint.x, sBounds[3] + figureEscapeDistance[0])); //south  南\r\n\t                    potentialExits.push(new Point(sBounds[0] - figureEscapeDistance[0], startPoint.y)); //west  西\r\n\t\r\n\t                    //pick closest exit point  寻找与 startPoint 最靠近的出口点\r\n\t                    startExitPoint = potentialExits[0];\r\n\t                    for (var i = 1; i < potentialExits.length; i++) {\r\n\t                        if (Util.distance(startPoint, potentialExits[i]) < Util.distance(startPoint,\r\n\t                                startExitPoint)) {\r\n\t                            startExitPoint = potentialExits[i];\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t\r\n\t\r\n\t                //find end exit point  寻找结束出口\r\n\t                if (eBounds != null) {\r\n\t                    var potentialExits = [];\r\n\t\r\n\t                    potentialExits.push(new Point(endPoint.x, eBounds[1] - figureEscapeDistance[1])); //north\r\n\t                    potentialExits.push(new Point(eBounds[2] + figureEscapeDistance[1], endPoint.y)); //east\r\n\t                    potentialExits.push(new Point(endPoint.x, eBounds[3] + figureEscapeDistance[1])); //south\r\n\t                    potentialExits.push(new Point(eBounds[0] - figureEscapeDistance[1], endPoint.y)); //west\r\n\t\r\n\t                    //pick closest exit point  寻找与 endPoint 最靠近的出口点\r\n\t                    endExitPoint = potentialExits[0];\r\n\t                    for (var i = 1; i < potentialExits.length; i++) {\r\n\t                        if (Util.distance(endPoint, potentialExits[i]) < Util.distance(endPoint,\r\n\t                                endExitPoint)) {\r\n\t                            endExitPoint = potentialExits[i];\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                //Basic solution 最基本的解决方案   为其他解决方案做准备\r\n\t                var s = [startPoint];\r\n\t                var gapIndex = 0; //the index of the gap (where do we need to insert new points) DO NOT CHANGE IT\r\n\t                if (startExitPoint) {\r\n\t                    s.push(startExitPoint);\r\n\t                    gapIndex = 1;\r\n\t                }\r\n\t                if (endExitPoint) {\r\n\t                    s.push(endExitPoint);\r\n\t                }\r\n\t                s.push(endPoint);\r\n\t\r\n\t\r\n\t\r\n\t                //SO - no additional points     S0 解决方案 不添加任何点  基本不会被采用\r\n\t                var s0 = Point.cloneArray(s);\r\n\t                solutions.push(['s0', 's0', s0]);\r\n\t\r\n\t\r\n\t\r\n\t                //S1   S1 解决方案  只有一个折点\r\n\t                var s1 = Point.cloneArray(s);\r\n\t\r\n\t                //first variant   第一个变体 s1 s1_1方案  折线点在 startExitPoint的X 与 endExitPoint的 Y位置\r\n\t                var s1_1 = Point.cloneArray(s1);\r\n\t                s1_1.splice(gapIndex + 1, 0, new Point(s1_1[gapIndex].x, s1_1[gapIndex + 1].y));\r\n\t                solutions.push(['s1', 's1_1', s1_1]);\r\n\t\r\n\t                //second variant  第二变体 s1 s1-2方案  折线点在 endExitPoint的X 与  startExitPoint的Y位置\r\n\t                var s1_2 = Point.cloneArray(s1);\r\n\t                s1_2.splice(gapIndex + 1, 0, new Point(s1_2[gapIndex + 1].x, s1_2[gapIndex].y));\r\n\t                solutions.push(['s1', 's1_2', s1_2]);\r\n\t\r\n\t\r\n\t                //S2  S2 解决方案  添加两个折点\r\n\t\r\n\t                //Variant I   s2_1方案\r\n\t                var s2_1 = Point.cloneArray(s);\r\n\t                var s2_1_1 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex].y);\r\n\t                var s2_1_2 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex + 1].y);\r\n\t                s2_1.splice(gapIndex + 1, 0, s2_1_1, s2_1_2);\r\n\t                solutions.push(['s2', 's2_1', s2_1]);\r\n\t\r\n\t\r\n\t                //Variant II  s2_1方案  1折线点 x: startExitPoint的X 位置 y: startExitPoint的y+endExitPoint的y/2\r\n\t                //1折线点 x:endExitPoint的x  y:startExitPoint的y+endExitPoint的y/2\r\n\t                var s2_2 = Point.cloneArray(s);\r\n\t                var s2_2_1 = new Point(s2_2[gapIndex].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);\r\n\t                var s2_2_2 = new Point(s2_2[gapIndex + 1].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);\r\n\t                s2_2.splice(gapIndex + 1, 0, s2_2_1, s2_2_2);\r\n\t                solutions.push(['s2', 's2_2', s2_2]);\r\n\t\r\n\t\r\n\t                //Variant III\r\n\t                var s2_3 = Point.cloneArray(s);\r\n\t                //find the amount (stored in delta) of pixels we need to move right so no intersection with a figure will be present\r\n\t                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\t\r\n\t                var eastExits = [s2_3[gapIndex].x + 20, s2_3[gapIndex + 1].x + 20]; //add points X coordinates to be able to generate Variant III even in the absence of figures :p\r\n\t\r\n\t                if (sBounds) {\r\n\t                    eastExits.push(sBounds[2] + 20);\r\n\t                }\r\n\t\r\n\t                if (eBounds) {\r\n\t                    eastExits.push(eBounds[2] + 20);\r\n\t                }\r\n\t\r\n\t                var eastExit = Util.max(eastExits);\r\n\t                var s2_3_1 = new Point(eastExit, s2_3[gapIndex].y);\r\n\t                var s2_3_2 = new Point(eastExit, s2_3[gapIndex + 1].y);\r\n\t                s2_3.splice(gapIndex + 1, 0, s2_3_1, s2_3_2);\r\n\t                solutions.push(['s2', 's2_3', s2_3]);\r\n\t\r\n\t\r\n\t                //Variant IV  s2_4方案\r\n\t                var s2_4 = Point.cloneArray(s);\r\n\t                //find the amount (stored in delta) of pixels we need to move up so no intersection with a figure will be present\r\n\t                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\t\r\n\t                var northExits = [s2_4[gapIndex].y - 20, s2_4[gapIndex + 1].y - 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p\r\n\t\r\n\t                if (sBounds) {\r\n\t                    northExits.push(sBounds[1] - 20);\r\n\t                }\r\n\t\r\n\t                if (eBounds) {\r\n\t                    northExits.push(eBounds[1] - 20);\r\n\t                }\r\n\t\r\n\t                var northExit = Util.min(northExits);\r\n\t                var s2_4_1 = new Point(s2_4[gapIndex].x, northExit);\r\n\t                var s2_4_2 = new Point(s2_4[gapIndex + 1].x, northExit);\r\n\t                s2_4.splice(gapIndex + 1, 0, s2_4_1, s2_4_2);\r\n\t                solutions.push(['s2', 's2_4', s2_4]);\r\n\t\r\n\t\r\n\t                //Variant V\r\n\t                var s2_5 = Point.cloneArray(s);\r\n\t                //find the amount (stored in delta) of pixels we need to move left so no intersection with a figure will be present\r\n\t                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\t\r\n\t                var westExits = [s2_5[gapIndex].x - 20, s2_5[gapIndex + 1].x - 20]; //add points x coordinates to be able to generate Variant III even in the absence of figures :p\r\n\t\r\n\t                if (sBounds) {\r\n\t                    westExits.push(sBounds[0] - 20);\r\n\t                }\r\n\t\r\n\t                if (eBounds) {\r\n\t                    westExits.push(eBounds[0] - 20);\r\n\t                }\r\n\t\r\n\t                var westExit = Util.min(westExits);\r\n\t                var s2_5_1 = new Point(westExit, s2_5[gapIndex].y);\r\n\t                var s2_5_2 = new Point(westExit, s2_5[gapIndex + 1].y);\r\n\t                s2_5.splice(gapIndex + 1, 0, s2_5_1, s2_5_2);\r\n\t                solutions.push(['s2', 's2_5', s2_5]);\r\n\t\r\n\t\r\n\t                //Variant VI\r\n\t                var s2_6 = Point.cloneArray(s);\r\n\t                //find the amount (stored in delta) of pixels we need to move down so no intersection with a figure will be present\r\n\t                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\t\r\n\t                var southExits = [s2_6[gapIndex].y + 20, s2_6[gapIndex + 1].y + 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p\r\n\t\r\n\t                if (sBounds) {\r\n\t                    southExits.push(sBounds[3] + 20);\r\n\t                }\r\n\t\r\n\t                if (eBounds) {\r\n\t                    southExits.push(eBounds[3] + 20);\r\n\t                }\r\n\t\r\n\t                var southExit = Util.max(southExits);\r\n\t                var s2_6_1 = new Point(s2_6[gapIndex].x, southExit);\r\n\t                var s2_6_2 = new Point(s2_6[gapIndex + 1].x, southExit);\r\n\t                s2_6.splice(gapIndex + 1, 0, s2_6_1, s2_6_2);\r\n\t                solutions.push(['s2', 's2_6', s2_6]);\r\n\t\r\n\t\r\n\t\r\n\t                //FILTER solutions\r\n\t\r\n\t                /*Algorithm\r\n\t                 * 0. solutions are ordered from minimmun nr of points to maximum >:)\r\n\t                 * 1. remove all solutions that are not orthogonal (mainly s0 solution)\r\n\t                 * 2. remove all solutions that go backward (we will not need them ever)\r\n\t                 * 3. remove all solutions with intersections\r\n\t                 * 4. pick first class of solutions with same nr of points (ex: 2)\r\n\t                 * 5. pick the first solution with 90 degree angles (less turnarounds)\r\n\t                 * (not interesteted) sort by length :p\r\n\t                 */\r\n\t\r\n\t                //1. filter non ortogonal solutions 删除不是正交直线的方案\r\n\t                Log.info(\"Filter orthogonal solutions. Initial number of solutions = \" + solutions.length);\r\n\t                var orthogonalSolution = [];\r\n\t                for (var l = 0; l < solutions.length; l++) {\r\n\t                    var solution = solutions[l][2];\r\n\t                    if (Util.orthogonalPath(solution)) {\r\n\t                        orthogonalSolution.push(solutions[l]);\r\n\t                    }\r\n\t                }\r\n\t                solutions = orthogonalSolution;\r\n\t                Log.info(\"\\n\\tOrthogonalSolutions = \" + solutions.length);\r\n\t\r\n\t                //2. filter backward solutions  过滤 倒退的方案\r\n\t                //do not allow start and end points to coincide - ignore them\r\n\t                if (startPoint.equals(endPoint)) {\r\n\t                    Log.info(\r\n\t                        \"Start and end point coincide...skip backward solution. I think we will just fall on s0 :)\"\r\n\t                    );\r\n\t                } else {\r\n\t                    Log.info(\"Filter backward solutions. Initial number of solutions = \" + solutions.length);\r\n\t                    var forwardSolutions = [];\r\n\t                    var temp = '';\r\n\t                    for (var l = 0; l < solutions.length; l++) {\r\n\t                        var solution = solutions[l][2];\r\n\t                        if (Util.forwardPath(solution)) {\r\n\t                            forwardSolutions.push(solutions[l]);\r\n\t                        } else {\r\n\t                            temp = temp + \"\\n\\t\" + solution;\r\n\t                        }\r\n\t                    }\r\n\t                    solutions = forwardSolutions;\r\n\t                    Log.info(\"\\n\\t ForwardSolutions = \" + solutions.length);\r\n\t                    if (solutions.length == 0) {\r\n\t                        Log.info(\"Discarded solutions: \" + temp);\r\n\t                    }\r\n\t                }\r\n\t\r\n\t\r\n\t                //3. Filter non intersecting solutions  去除没有交集()的方案\r\n\t                Log.info(\"Filter non intersecting solutions. Initial number of solutions = \" + solutions.length);\r\n\t                var nonIntersectionSolutions = []\r\n\t                for (var l = 0; l < solutions.length; l++) {\r\n\t                    var solution = solutions[l][2];\r\n\t                    //Log.info(\"Solution id= \" + solutions[l][1] + ' nr points = ' + solution.length + \", points = \" + solution);\r\n\t                    var intersect = false;\r\n\t\r\n\t                    var innerLines = solution.slice(); //just a shallow copy\r\n\t\r\n\t                    /*If any bounds just trim the solution. So we avoid the strange case when a connection\r\n\t                     *startes from a point on a figure and ends inside of the same figure, but not on a connection point*/\r\n\t                    if (eBounds || sBounds) {\r\n\t                        //i0nnerLines = innerLines.slice(0, innerLines.length - 1);\r\n\t                        innerLines = innerLines.slice(1, innerLines.length - 1);\r\n\t                        //Log.info(\"\\t eBounds present,innerLines nr. points = \" + innerLines.length + \", points = \" + innerLines);\r\n\t                    }\r\n\t\r\n\t\r\n\t\r\n\t                    //now test for intersection\r\n\t                    if (sBounds) {\r\n\t                        intersect = intersect || Util.polylineIntersectsRectangle(innerLines, sBounds);\r\n\t                    }\r\n\t                    if (eBounds) {\r\n\t                        intersect = intersect || Util.polylineIntersectsRectangle(innerLines, eBounds);\r\n\t                    }\r\n\t\r\n\t                    if (!intersect) {\r\n\t                        nonIntersectionSolutions.push(solutions[l]);\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                //If all solutions intersect than this is destiny  :) and just ignore the intersection filter\r\n\t                if (nonIntersectionSolutions.length != 0) {\r\n\t                    //reasign to solutions\r\n\t                    solutions = nonIntersectionSolutions;\r\n\t                }\r\n\t\r\n\t                Log.info(\"\\n\\t nonIntersectionSolutions = \" + solutions.length);\r\n\t\r\n\t\r\n\t                //4. get first class of solutions with same nr of points 选择与第一个方案点数一样多的方案（因为第一个方案点数最少）\r\n\t                Log.info(\"Get first class of solutions with same nr of points\");\r\n\t                if (solutions.length == 0) {\r\n\t                    Log.info(\"This is not possible\");\r\n\t                }\r\n\t\r\n\t                var firstSolution = solutions[0][2]; //pick first solution\r\n\t                var nrOfPoints = firstSolution.length;\r\n\t                var sameNrPointsSolution = [];\r\n\t\r\n\t                for (var l = 0; l < solutions.length; l++) {\r\n\t                    var solution = solutions[l][2];\r\n\t                    if (solution.length == nrOfPoints) {\r\n\t                        sameNrPointsSolution.push(solutions[l]);\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                solutions = sameNrPointsSolution;\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t                /*5.  计算路径分数 ，取最分数高的\r\n\t                 Pick the first solution with 90 degree angles (less turnarounds)\r\n\t                 *in case we have more than one solution in our class\r\n\t                 */\r\n\t                Log.info(\"pick the first solution with 90 degree angles (less turnarounds)\");\r\n\t                var solIndex = 0;\r\n\t                for (var l = 0; l < solutions.length; l++) {\r\n\t                    var solution = solutions[l][2];\r\n\t                    if (Util.scorePath(solutions[solIndex][2]) < Util.scorePath(solutions[l][2])) {\r\n\t                        solIndex = l;\r\n\t                    }\r\n\t                }\r\n\t                solutions = [solutions[solIndex]];\r\n\t\r\n\t\r\n\t                break;\r\n\t        }\r\n\t\r\n\t        //SMOOTHING curve\r\n\t        if (type === Connector.TYPE_CURVE) {\r\n\t            this.smoothCurve(solutions);\r\n\t        }\r\n\t        //END SMOOTHING curve\r\n\t\r\n\t        Log.groupEnd();\r\n\t\r\n\t        return solutions;\r\n\t    }\r\n\t\r\n\t    ConnectionManager.prototype.smoothCurve = function (solutions) {\r\n\t        var option = 3;\r\n\t\r\n\t        switch (option) {\r\n\t            case 0:\r\n\t                //do nothing\r\n\t                break;\r\n\t\r\n\t            case 1: //add intermediate points\r\n\t                //Add the middle point for start and end segment so that we \"force\" the\r\n\t                //curve to both come \"perpendicular\" on bounds and also make the curve\r\n\t                //\"flee\" more from bounds (on exit)\r\n\t                for (var s = 0; s < solutions.length; s++) {\r\n\t                    var solTurningPoints = solutions[s][2];\r\n\t\r\n\t                    //first segment\r\n\t                    var a1 = solTurningPoints[0];\r\n\t                    var a2 = solTurningPoints[1];\r\n\t                    var startMiddlePoint = Util.getMiddle(a1, a2);\r\n\t                    solTurningPoints.splice(1, 0, startMiddlePoint);\r\n\t\r\n\t                    //last segment\r\n\t                    var a3 = solTurningPoints[solTurningPoints.length - 2];\r\n\t                    var a4 = solTurningPoints[solTurningPoints.length - 1];\r\n\t                    var endMiddlePoint = Util.getMiddle(a3, a4);\r\n\t                    solTurningPoints.splice(solTurningPoints.length - 1, 0, endMiddlePoint);\r\n\t                }\r\n\t                break;\r\n\t\r\n\t            case 2: //remove points\r\n\t\r\n\t                zrUtil.each(solutions, function(solution) {\r\n\t                    var solType = solution[0];\r\n\t                    if (solType == 's1' || solType == 's2') {\r\n\t                        var solTurningPoints = solution[2];\r\n\t                        solTurningPoints.splice(1, 1);\r\n\t                        solTurningPoints.splice(solTurningPoints.length - 2, 1);\r\n\t                    }\r\n\t                });\r\n\t                break;\r\n\t\r\n\t            case 3:\r\n\t                /*remove colinear point for s1 as it seems that more colinear points do not look good\r\n\t                 * on organic solutions >:D*/\r\n\t                zrUtil.each(solutions, function(solution) {\r\n\t                    var solType = solution[0];\r\n\t                    if (solType == 's1') {\r\n\t                        var solTurningPoints = solution[2];\r\n\t                        var reducedSolution = Util.collinearReduction(solTurningPoints);\r\n\t                        solution[2] = reducedSolution;\r\n\t                    }\r\n\t                });\r\n\t                break;\r\n\t        } //end switch\r\n\t\r\n\t    }\r\n\t\r\n\t    module.exports = ConnectionManager;\r\n\n\n/***/ }),\n/* 90 */\n/***/ (function(module, exports) {\n\n\t/**\r\n\t * 日志类\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t\r\n\t    var Log  = {\r\n\t        LOG_LEVEL_NONE  : 0,\r\n\t\r\n\t        LOG_LEVEL_DEBUG : 1,\r\n\t\r\n\t        LOG_LEVEL_INFO : 2,\r\n\t\r\n\t        LOG_LEVEL_ERROR : 3,\r\n\t\r\n\t        level : this.LOG_LEVEL_ERROR,\r\n\t        \r\n\t        /**\r\n\t        * The less important of all messages\r\n\t        * @param {String} message - the message to be logged\r\n\t        **/\r\n\t        debug: function (message){\r\n\t            if(typeof console !== 'undefined'){\r\n\t                if(this.level <= this.LOG_LEVEL_DEBUG){\r\n\t                    \r\n\t                    //in FF is debug\r\n\t                    if(typeof console.debug == 'function'){\r\n\t                        console.debug(message);\r\n\t                    }\r\n\t                    else{//TODO: in IE is log\r\n\t    //                    console.info(message);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t\r\n\t\r\n\t        /**\r\n\t        * The commonly used log message\r\n\t        * @param {String} message - the message to be logged\r\n\t        **/\r\n\t        info : function (message){\r\n\t            if(typeof console !== 'undefined'){\r\n\t                if(this.level <= this.LOG_LEVEL_INFO){\r\n\t                    console.info(message);\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /**\r\n\t        * The worse kind of message. Usually a crash\r\n\t        * @param {String} message - the message to be logged\r\n\t        **/\r\n\t        error : function (message){\r\n\t            if(typeof console !== 'undefined'){\r\n\t                if(this.level <= this.LOG_LEVEL_ERROR){\r\n\t                    console.error(message);\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         *Start grouping the log messages\r\n\t         *@param {String} title - the title of the group\r\n\t         *@see <a href=\"http://getfirebug.com/logging\">http://getfirebug.com/logging</a>\r\n\t         **/\r\n\t        group : function(title){\r\n\t            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info\r\n\t                if(typeof console !== 'undefined'){           \r\n\t                    /**If we do not test for group() function you will get an error in Opera\r\n\t                     *as Opera has it's own console...which does not have a group() function*/\r\n\t                    if(typeof console.group === 'function'){\r\n\t                        console.group(title);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /**Ends current message grouping*/\r\n\t        groupEnd : function(){\r\n\t            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info\r\n\t                if(typeof console !== 'undefined'){\r\n\t                    /**If we do not test for groupEnd() function you will get an error in Opera\r\n\t                     *as Opera has it's own console...which does not have a group() function*/\r\n\t                    if(typeof console.groupEnd === 'function'){\r\n\t                        console.groupEnd();\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    //Log.level = Log.LOG_LEVEL_DEBUG; \r\n\t    Log.level = Log.LOG_LEVEL_ERROR; \r\n\t    //Log.level = Log.LOG_LEVEL_ERROR;\r\n\t    //Log.level = Log.LOG_LEVEL_NONE;\r\n\t    module.exports = Log;\r\n\t    \r\n\n\n/***/ }),\n/* 91 */\n/***/ (function(module, exports) {\n\n\t/**\r\n\t * 常量定义\r\n\t */\r\n\t\r\n\t\tmodule.exports = \t{\r\n\t\t\tELEMENT_TYPE: \"elementType\",\r\n\t\t\tMODE: \"mode\",\r\n\t\t\tBACKGROUND: \"backgroud\",\r\n\t\t\tOPTIONS: \"options\",\r\n\t\t\tUSERDATA: \"userData\",\r\n\t\t\tID: \"id\",\r\n\t\t\tSTART_ID: \"startNodeId\",\r\n\t\t\tEND_ID: \"endNodeId\",\r\n\t\t\tALARM: \"Alarm\",\r\n\t\t\tRELATIONID:\"relationId\",\r\n\t\t\tRELATION_IMAGE:\"relationImage\",\r\n\t\t\tGROUP: \"Group\",\r\n\t\t\tCONNECTION: \"connection\",\r\n\t\t\tCHILDS: \"childs\",\r\n\t\t\tTREE_ROOT: \"treeRoot\",\r\n\t\t\tDOCKERS:\"options.dockers\",\r\n\t\t\tSTYLE_LINETYPE:\"style.lineType\",\r\n\t\t\tLINEOPERATIONICON:\"LineOperationIcon\",\r\n\t\t};\r\n\t\r\n\n\n/***/ }),\n/* 92 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Link工具类\r\n\t */\r\n\t\r\n\t    var Model = __webpack_require__(85);\r\n\t    var Constants = __webpack_require__(91);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var Connector = __webpack_require__(80);\r\n\t    /**\r\n\t     * 根据结点数组 导出JSON格式的数据\r\n\t     *\r\n\t     * @param {Array} model 总的模型\r\n\t     * @return {JSON} JSON格式的数据\r\n\t     */\r\n\t    function toJson(model, group) {\r\n\t        var jsonArr = [];\r\n\t        group.eachChild(function(node) {\r\n\t            if (node.model) {\r\n\t                if (node instanceof Connector) {\r\n\t                    node.refreshModel();\r\n\t                };\r\n\t                jsonArr.push(node.model.option);\r\n\t\r\n\t            }\r\n\t\r\n\t\r\n\t        })\r\n\t        model.set(Constants.CHILDS, jsonArr);\r\n\t        return model.option;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 根据 JSON 生成节点\r\n\t     * @param  {[type]} fishTopolink [description]\r\n\t     * @param  {[type]} json         [description]\r\n\t     * @return {[type]}              [description]\r\n\t     */\r\n\t    function fromJson(fishTopolink, group, childShapes, isChild, layoutRootNode) {\r\n\t        // 1.清空画布\r\n\t\r\n\t        var connectors = [];\r\n\t        // 2.先创建节点  遍历形状 获取模型\r\n\t\r\n\t\r\n\t        for (var i = 0; i < childShapes.length; i++) {\r\n\t            var line = childShapes[i];\r\n\t            var link = fishTopolink.createLinkOfPoints(line.options,line.userData);\r\n\t            if (isChild) {\r\n\t                group.add(link);\r\n\t            } else {\r\n\t                fishTopolink.addNode(link);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 根据id在group中查找\r\n\t     * @param  {[type]} group  [description]\r\n\t     * @param  {[type]} nodeId [description]\r\n\t     * @return {[type]}        [description]\r\n\t     */\r\n\t    function findNodeById (group, nodeId) {\r\n\t        var retNode = null;\r\n\t        group.eachChild(function(node) {\r\n\t            if (node.model && node.model.get(Constants.ID) === nodeId) {\r\n\t                retNode = node;\r\n\t            };\r\n\t        })\r\n\t        return retNode;\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * Get canvas which has all thing rendered\r\n\t     * @param {Object} opts\r\n\t     * @param {string} [opts.backgroundColor]\r\n\t     */\r\n\t    function getRenderedCanvas(zr, opts) {\r\n\t        opts = opts || {};\r\n\t        opts.pixelRatio = opts.pixelRatio || 1;\r\n\t        opts.backgroundColor = opts.backgroundColor\r\n\t            || \"#FFFFFF\";\r\n\t        var list = zr.storage.getDisplayList();\r\n\t        // Stop animations\r\n\t        zrUtil.each(list, function (el) {\r\n\t            el.stopAnimation(true);\r\n\t        });\r\n\t        return zr.painter.getRenderedCanvas(opts);\r\n\t    }\r\n\t\r\n\t    function toDataURL (zr, opts) {\r\n\t        opts = opts || {};\r\n\t        var url = getRenderedCanvas(zr, opts).toDataURL(\r\n\t            'image/' + (opts && opts.type || 'png')\r\n\t        );\r\n\t        return url;\r\n\t    }\r\n\t\r\n\t\r\n\t    function initNodeEvent (node, api) {\r\n\t        var MOUSE_EVENT_NAMES = ['dblclick', 'click'];//'click', 'dblclick', 'mouseover', 'mouseout'\r\n\t\r\n\t\r\n\t        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n\t            node.on(eveName, function (e) {\r\n\t                var params = {};\r\n\t                params.event = e;\r\n\t                params.type = eveName;\r\n\t                params.target = node;\r\n\t                api.trigger(eveName, params);\r\n\t            });\r\n\t        });\r\n\t    }\r\n\t\r\n\t    module.exports = {\r\n\t        toJson: toJson,\r\n\t        fromJson: fromJson,\r\n\t        toDataURL:toDataURL\r\n\t    };\r\n\t\r\n\n\n/***/ }),\n/* 93 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 连线操作类\r\n\t * @author miao.cunzhi\r\n\t */\r\n\t\r\n\t    var symbolUtil = __webpack_require__(81);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var icon = __webpack_require__(87);\r\n\t    function LineOperationManager(connectionManager, api) {\r\n\t        this.lineOperations = [],\r\n\t        this.isEdit = true;\r\n\t        this.connectionManager = connectionManager;\r\n\t        this._api = api;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     *  this.lineOperationManager.addIcon(key, options);\r\n\t     */\r\n\t    LineOperationManager.prototype.addIcon = function(key, options) {\r\n\t        //判断是小图标否存在 ，存在则直接返回\r\n\t        var lineOperationIcon = zrUtil.find(options.lineNode.icons, function(icon) {\r\n\t            return icon.key === key;\r\n\t        });\r\n\t\r\n\t        if (lineOperationIcon) {\r\n\t            this.bindOperation(options.lineNode);\r\n\t            return;\r\n\t        }else {\r\n\t            var lineOperation = this.creatOperation(key, options);\r\n\t            this._api._getParentZr().add(lineOperation);\r\n\t            this.bindOperation(options.lineNode);\r\n\t            return lineOperation;\r\n\t        }\r\n\t    }\r\n\t\r\n\t\r\n\t    LineOperationManager.prototype.creatOperation = function(key, options) {\r\n\t        var lineOperation = symbolUtil.createSymbol(options.iconPath, 0, 0, options.width || 15, options.height || 15, 0, options.color||'#aaaaac');\r\n\t        lineOperation.key = key;\r\n\t        lineOperation._width =  options.width || 15;  // path情况下无法计算\r\n\t        lineOperation._isLineOperationIcon = true;\r\n\t        lineOperation.hide();\r\n\t        options.lineNode.icons.push(lineOperation);\r\n\t        this.lineOperations.push(lineOperation);\r\n\t\r\n\t        //小图标 点击事件  如果有回调则调用回调，否则派发事件\r\n\t        lineOperation.on(\"click\", function(event) {\r\n\t            if (options.callback) {\r\n\t                event.data = options;\r\n\t                event.lineNode = options.lineNode;\r\n\t                options.callback(event);\r\n\t            } else {\r\n\t                var params = {};\r\n\t                params.event = event;\r\n\t                params.type = \"click\";\r\n\t                params.elementType = \"LineOperationIcon\";\r\n\t                this._api.trigger(params.type, params);\r\n\t            }\r\n\t        }.bind(this));\r\n\t        return lineOperation;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 计算小图标的位置，并显示\r\n\t     * @param  {[type]} connector [description]\r\n\t     * @return {[type]}           [description]\r\n\t     */\r\n\t    LineOperationManager.prototype.bindOperation = function(connector) {\r\n\t        function parentX(node) {\r\n\t            if (node.parent && node.parent.nodeType == \"SubProcess\") {\r\n\t                return node.position[0] + parentX(node.parent)\r\n\t            } else {\r\n\t                return node.position[0]\r\n\t            }\r\n\t        }\r\n\t    \r\n\t        function parentY(node) {\r\n\t            if (node.parent && node.parent.nodeType == \"SubProcess\") {\r\n\t                return node.position[1] + parentY(node.parent)\r\n\t            } else {\r\n\t                return node.position[1]\r\n\t            }\r\n\t        }\r\n\t\r\n\t        if (this.isEdit == false) {\r\n\t            return;\r\n\t        }\r\n\t        var pointPosition = connector.middle(), posX, posY;\r\n\t        if (connector.parent && connector.parent.nodeType == \"SubProcess\") {\r\n\t            posX = pointPosition[0] + parentX(connector.parent);\r\n\t            posY = pointPosition[1] + parentY(connector.parent);\r\n\t        } else {\r\n\t            posX = pointPosition[0];\r\n\t            posY = pointPosition[1];\r\n\t        }\r\n\t\r\n\t        var arrLength = zrUtil.map(connector.icons, function(icon) {\r\n\t            return icon._width;\r\n\t        });\r\n\t\r\n\t        var totalLength = zrUtil.reduce(arrLength, function(previousValue,currentValue) {\r\n\t            return previousValue + currentValue + 10;\r\n\t        }, 0 );\r\n\t\r\n\t        zrUtil.each(connector.icons, function(icon, index) {\r\n\t            var connectorPosition = 0;\r\n\t            for (var k = 0; k < index; k++) {\r\n\t                connectorPosition += arrLength[k] + 10;\r\n\t            }\r\n\t            icon.attr(\"position\", [posX + connectorPosition - totalLength / 2, posY + 5]);\r\n\t            icon.show();\r\n\t            icon.attachLine = connector;\r\n\t        })\r\n\t    }\r\n\t\r\n\t    LineOperationManager.prototype.hideAllLineOperation = function() {\r\n\t        zrUtil.each(this.lineOperations, function(lineOperation) {\r\n\t            lineOperation.hide();\r\n\t        });\r\n\t    }\r\n\t\r\n\t    LineOperationManager.prototype.addDeleteIcon = function(lineNode,options) {\r\n\t        var opts = zrUtil.defaults({\r\n\t            iconPath: 'path://' + icon.DEL_SVG,\r\n\t            width: 12,\r\n\t            height: 14,\r\n\t            lineNode: lineNode,\r\n\t            callback: function(e) {\r\n\t                this._api.remove(e.target.attachLine);//this.connectionManager.selConnector);\r\n\t            }.bind(this)\r\n\t        }, options,true);\r\n\t\r\n\t        this.addIcon(\"delete\", opts);\r\n\t    }\r\n\t\r\n\t    LineOperationManager.prototype.addChangeLineTypeIcon = function(lineNode,options) {\r\n\t        var opts = zrUtil.defaults({\r\n\t            iconPath: 'path://' + icon.CHANGE_LINE_TYPE_SVG,\r\n\t            width: 15,\r\n\t            height: 15,\r\n\t            lineNode: lineNode,\r\n\t            callback: function () {\r\n\t                this._api.changeSelectConnectorType();\r\n\t            }.bind(this)\r\n\t        }, options,true);\r\n\t\r\n\t        this.addIcon(\"change\", opts)\r\n\t    }\r\n\t\r\n\t    module.exports = LineOperationManager;\r\n\t\r\n\n\n/***/ }),\n/* 94 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Link静态方法类\r\n\t * @class fish.topo.FishTopoLink.Link\r\n\t */\r\n\t\r\n\t\r\n\t    var Constants = __webpack_require__(91);\r\n\t    var Flow = {\r\n\t        FLOW_TYPE: \"elementType\",\r\n\t        LINK: \"connection\",\r\n\t        RECT: \"Rect\",\r\n\t        Group: 'Group',\r\n\t        IMAGE: 'Image',\r\n\t        TEXT: 'Text',\r\n\t        CIRCLE: 'Circle',\r\n\t        SECTOR: 'Sector',\r\n\t        RING: 'Ring',\r\n\t        POLYGON: 'Polygon',\r\n\t        POLYLINE: 'Polyline',\r\n\t        LINE: 'Line',\r\n\t        BEZIERCURVE: 'Beziercurve',\r\n\t        ARC: 'Arc',\r\n\t        SCENE:'scene',\r\n\t\r\n\t        /**\r\n\t         * @method setUserData\r\n\t         * 设置用户数据\r\n\t         * @param {Object} node 需要设置数据的节点\r\n\t         * @param {Object} obj 数据\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //设置自定义数据\r\n\t         *      this.fishTopo.Flow.setUserData(rect, { customObj: \"rect\" });\r\n\t         */\r\n\t        setUserData: function(node, obj) {\r\n\t            node.model.set(Constants.USERDATA, obj);\r\n\t        },\r\n\t        /**\r\n\t         * 获取设置的用户数据\r\n\t         * @param {Object} node 需要获取数据的节点\r\n\t         * @return {String}      数据\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //获取自定义数据\r\n\t         *      this.fishTopo.Flow.getUserData(rect);\r\n\t         */\r\n\t        getUserData: function(node) {\r\n\t            return node.model.get(Constants.USERDATA);\r\n\t        },\r\n\t        /**\r\n\t         * 判断是否是连线\r\n\t         * @param {Object} model 对象的model\r\n\t         * @return {Boolean}      是 否\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //判断是否是连线\r\n\t         *      var nodeModel = e.target.model;\r\n\t         *      if (this.fishTopo.Flow.isLink(nodeModel)) { return true;}\r\n\t         */\r\n\t        isLink: function(model) {\r\n\t            var elementType = model.get(Flow.FLOW_TYPE);\r\n\t            return elementType == Flow.LINK;\r\n\t        },\r\n\t        /**\r\n\t         * 获取节点的类型\r\n\t         * @param {Object} model 节点的model\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //获取节点类型\r\n\t         *      var nodeModel = e.target.model;\r\n\t         *      return this.fishTopo.Flow.getType(nodeModel);\r\n\t         */\r\n\t        getType: function(model) {\r\n\t            var elementType = model.get(Flow.FLOW_TYPE);\r\n\t            return elementType;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    module.exports = Flow;\r\n\t\r\n\n\n/***/ }),\n/* 95 */\n/***/ (function(module, exports) {\n\n\t/**\r\n\t * 工具类\r\n\t * @class fishTopoFlow.util\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method initImagePool\r\n\t * 初始化图片池  用于对图片加载进行管理\r\n\t * @param {number} max 最大连接数。数值。\r\n\t * @returns {{load: Function, info: Function}}\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t        var imagepool = fishTopoFlow.util.initImagePool(100);\r\n\t        imagepool.load(grayArray, {\r\n\t            success: function(imgs) {\r\n\t            },\r\n\t            once: true\r\n\t        });\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method inherits\r\n\t * 构造类继承关系\r\n\t *\r\n\t * @param {Function} clazz 源类\r\n\t * @param {Function} baseClazz 基类\r\n\t */\r\n\t\r\n\t\r\n\t    var emptyFn = function() {};\r\n\t    //初始默认配置\r\n\t    var config_default = {\r\n\t        //线程池\"线程\"数量\r\n\t        thread: 5,\r\n\t        //图片加载失败重试次数\r\n\t        //重试2次，加上原有的一次，总共是3次\r\n\t        \"tries\": 2\r\n\t    };\r\n\t    //工具\r\n\t    var _helpers = {\r\n\t        //设置dom属性\r\n\t        setAttr: (function() {\r\n\t            var img = new Image();\r\n\t            //判断浏览器是否支持HTML5 dataset\r\n\t            if (img.dataset) {\r\n\t                return function(dom, name, value) {\r\n\t                    dom.dataset[name] = value;\r\n\t                    return value;\r\n\t                };\r\n\t            } else {\r\n\t                return function(dom, name, value) {\r\n\t                    dom.setAttribute(\"data-\" + name, value);\r\n\t                    return value;\r\n\t                };\r\n\t            }\r\n\t        }()),\r\n\t        //获取dom属性\r\n\t        getAttr: (function() {\r\n\t            var img = new Image();\r\n\t            //判断浏览器是否支持HTML5 dataset\r\n\t            if (img.dataset) {\r\n\t                return function(dom, name) {\r\n\t                    if(!dom.dataset[name]){\r\n\t                        return dom.getAttribute(\"data-\" + name);\r\n\t                    }else{\r\n\t                        return dom.dataset[name];\r\n\t                    }\r\n\t                };\r\n\t            } else {\r\n\t                return function(dom, name) {\r\n\t                    return dom.getAttribute(\"data-\" + name);\r\n\t                };\r\n\t            }\r\n\t        }())\r\n\t    };\r\n\t    /**\r\n\t     * 构造方法\r\n\t     * @private\r\n\t     * @param max 最大连接数。数值。\r\n\t     */\r\n\t    function ImagePool(max) {\r\n\t        //最大并发数量\r\n\t        this.max = max || config_default.thread;\r\n\t        this.linkHead = null;\r\n\t        this.linkNode = null;\r\n\t        //加载池\r\n\t        //[{img: dom,free: true, node: node}]\r\n\t        //node\r\n\t        //{src: \"\", options: {success: \"fn\",error: \"fn\", once: true}, tries: 0}\r\n\t        this.pool = [];\r\n\t    }\r\n\t    /**\r\n\t     * 初始化\r\n\t     * @private\r\n\t     */\r\n\t    ImagePool.prototype.initPool = function() {\r\n\t        var i, img, obj, _s;\r\n\t        _s = this;\r\n\t        for (i = 0; i < this.max; i++) {\r\n\t            obj = {};\r\n\t            img = new Image();\r\n\t            _helpers.setAttr(img, \"id\", i);\r\n\t            img.onload = function() {\r\n\t                //回调\r\n\t                _s.notice(_s.getNode(this), \"success\", this);\r\n\t                //处理任务\r\n\t                _s.executeLink(this);\r\n\t            };\r\n\t            img.onerror = function() {\r\n\t                var node = _s.getNode(this);\r\n\t                //判断尝试次数\r\n\t                if (node.tries < config_default.tries) {\r\n\t                    node.tries = node.tries+1;\r\n\t                    //再次追加到任务链表末尾\r\n\t                    _s.appendNode(_s.createNode(node.src, node.options, node.notice, node.group, node.tries));\r\n\t                } else {\r\n\t                    //error回调\r\n\t                    //node.options.error.call(null, this.src);\r\n\t                    _s.notice(node, \"error\", this);\r\n\t                }\r\n\t                //处理任务\r\n\t                _s.executeLink(this);\r\n\t            };\r\n\t            obj.img = img;\r\n\t            obj.free = true;\r\n\t            this.pool.push(obj);\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 回调封装\r\n\t     * @private\r\n\t     * @param node 节点。对象。\r\n\t     * @param status 状态。字符串。可选值：success(成功)|error(失败)\r\n\t     * @param img 图片。\r\n\t     */\r\n\t    ImagePool.prototype.notice = function(node, status, img) {\r\n\t        node.notice(status, img);\r\n\t    };\r\n\t    /**\r\n\t     * 处理链表任务\r\n\t     * @private\r\n\t     * @param dom 图像dom对象。对象。\r\n\t     */\r\n\t    ImagePool.prototype.executeLink = function(dom) {\r\n\t        //判断链表是否存在节点\r\n\t        if (this.linkHead) {\r\n\t            //加载下一个图片\r\n\t            this.setSrc(dom, this.linkHead);\r\n\t            //去除链表头\r\n\t            this.shiftNode();\r\n\t        } else {\r\n\t            //设置自身状态为空闲\r\n\t            this.status(dom, true);\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 获取空闲\"线程\"\r\n\t     * @private\r\n\t     */\r\n\t    ImagePool.prototype.getFree = function() {\r\n\t        var length, i;\r\n\t        for (i = 0, length = this.pool.length; i < length; i++) {\r\n\t            if (this.pool[i].free) {\r\n\t                return this.pool[i];\r\n\t            }\r\n\t        }\r\n\t        return null;\r\n\t    };\r\n\t    /**\r\n\t     * 封装src属性设置\r\n\t     * 因为改变src属性相当于加载图片，所以把操作封装起来\r\n\t     * @private\r\n\t     * @param dom 图像dom对象。对象。\r\n\t     * @param node 节点。对象。\r\n\t     */\r\n\t    ImagePool.prototype.setSrc = function(dom, node) {\r\n\t        //设置池中的\"线程\"为非空闲状态\r\n\t        this.status(dom, false);\r\n\t        //关联节点\r\n\t        this.setNode(dom, node);\r\n\t        //加载图片\r\n\t        dom.src = node.src;\r\n\t    };\r\n\t    /**\r\n\t     * 更新池中的\"线程\"状态\r\n\t     * @private\r\n\t     * @param dom 图像dom对象。对象。\r\n\t     * @param status 状态。布尔。可选值：true(空闲)|false(非空闲)\r\n\t     */\r\n\t    ImagePool.prototype.status = function(dom, status) {\r\n\t        var id = _helpers.getAttr(dom, \"id\");\r\n\t        if(id){\r\n\t            this.pool[id].free = status;\r\n\t        }\r\n\t\r\n\t        //空闲状态，清除关联的节点\r\n\t        if (status) {\r\n\t            this.pool[id].node = null;\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 更新池中的\"线程\"的关联节点\r\n\t     * @private\r\n\t     * @param dom 图像dom对象。对象。\r\n\t     * @param node 节点。对象。\r\n\t     */\r\n\t    ImagePool.prototype.setNode = function(dom, node) {\r\n\t        var id = _helpers.getAttr(dom, \"id\");\r\n\t        if(id){\r\n\t            this.pool[id].node = node;\r\n\t            return this.pool[id].node === node;\r\n\t        }\r\n\t\r\n\t    };\r\n\t    /**\r\n\t     * 获取池中的\"线程\"的关联节点\r\n\t     * @private\r\n\t     * @param dom 图像dom对象。对象。\r\n\t     */\r\n\t    ImagePool.prototype.getNode = function(dom) {\r\n\t        var id = _helpers.getAttr(dom, \"id\");\r\n\t        if(id){\r\n\t            return this.pool[id].node;\r\n\t        }\r\n\t\r\n\t    };\r\n\t    /**\r\n\t     * 对外接口，加载图片\r\n\t     * @private\r\n\t     * @param src 可以是src字符串，也可以是src字符串数组。\r\n\t     * @param options 用户自定义参数。包含：success回调、error回调、once标识。\r\n\t     */\r\n\t    ImagePool.prototype._load = function(src, options) {\r\n\t        var srcs = [],\r\n\t            free = null,\r\n\t            length = 0,\r\n\t            i = 0,\r\n\t            //只初始化一次回调策略\r\n\t            notice = (function() {\r\n\t                if (options.once) {\r\n\t                    return function(status, img) {\r\n\t                        var g = this.group,\r\n\t                            o = this.options;\r\n\t                        //记录\r\n\t                        g[status].push(img);\r\n\t                        //判断改组是否全部处理完成\r\n\t                        if (g.success.length + g.error.length === g.count) {\r\n\t                            //异步\r\n\t                            //实际上是作为另一个任务单独执行，防止回调函数执行时间过长影响图片加载速度\r\n\t                            setTimeout(function() {\r\n\t                                o.success.call(null, g.success, g.error, g.count);\r\n\t                            }, 1);\r\n\t                        }\r\n\t                    };\r\n\t                } else {\r\n\t                    return function(status, img) {\r\n\t                        var o = this.options;\r\n\t                        //直接回调\r\n\t                        setTimeout(function() {\r\n\t                            o[status].call(null, img);\r\n\t                        }, 1);\r\n\t                    };\r\n\t                }\r\n\t            }()),\r\n\t            group = {\r\n\t                count: 0,\r\n\t                success: [],\r\n\t                error: []\r\n\t            },\r\n\t            node = null;\r\n\t        options = options || {};\r\n\t        options.success = options.success || emptyFn;\r\n\t        options.error = options.error || emptyFn;\r\n\t        srcs = srcs.concat(src);\r\n\t        //设置组元素个数\r\n\t        group.count = srcs.length;\r\n\t        //遍历需要加载的图片\r\n\t        for (i = 0, length = srcs.length; i < length; i++) {\r\n\t            //创建节点\r\n\t            node = this.createNode(srcs[i], options, notice, group);\r\n\t            //判断线程池是否有空闲\r\n\t            free = this.getFree();\r\n\t            if (free) {\r\n\t                //有空闲，则立即加载图片\r\n\t                this.setSrc(free.img, node);\r\n\t            } else {\r\n\t                //没有空闲，将任务添加到链表\r\n\t                this.appendNode(node);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 获取内部状态信息\r\n\t     * @private\r\n\t     * @returns {Object}\r\n\t     */\r\n\t    ImagePool.prototype._info = function() {\r\n\t        var info = {},\r\n\t            length = 0,\r\n\t            i = 0,\r\n\t            node = null;\r\n\t        //线程\r\n\t        info.thread = {};\r\n\t        //线程总数量\r\n\t        info.thread.count = this.pool.length;\r\n\t        //空闲线程数量\r\n\t        info.thread.free = 0;\r\n\t        //任务\r\n\t        info.task = {};\r\n\t        //待处理任务数量\r\n\t        info.task.count = 0;\r\n\t        //获取空闲\"线程\"数量\r\n\t        for (i = 0, length = this.pool.length; i < length; i++) {\r\n\t            if (this.pool[i].free) {\r\n\t                info.thread.free = info.thread.free + 1;\r\n\t            }\r\n\t        }\r\n\t        //获取任务数量(任务链长度)\r\n\t        node = this.linkHead;\r\n\t        if (node) {\r\n\t            info.task.count = info.task.count + 1;\r\n\t            while (node.next) {\r\n\t                info.task.count = info.task.count + 1;\r\n\t                node = node.next;\r\n\t            }\r\n\t        }\r\n\t        return info;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建节点\r\n\t     * @private\r\n\t     * @param src 图片路径。字符串。\r\n\t     * @param options 用户自定义参数。包含：success回调、error回调、once标识。\r\n\t     * @param notice 回调策略。 函数。\r\n\t     * @param group 组信息。对象。{count: 0, success: [], error: []}\r\n\t     * @param tr 出错重试次数。数值。默认为0。\r\n\t     * @returns {Object}\r\n\t     */\r\n\t    ImagePool.prototype.createNode = function(src, options, notice, group, tr) {\r\n\t        var node = {};\r\n\t        node.src = src;\r\n\t        node.options = options;\r\n\t        node.notice = notice;\r\n\t        node.group = group;\r\n\t        node.tries = tr || 0;\r\n\t        return node;\r\n\t    };\r\n\t    /**\r\n\t     * 向任务链表末尾追加节点\r\n\t     * @private\r\n\t     * @param node 节点。对象。\r\n\t     */\r\n\t    ImagePool.prototype.appendNode = function(node) {\r\n\t        //判断链表是否为空\r\n\t        if (!this.linkHead) {\r\n\t            this.linkHead = node;\r\n\t            this.linkNode = node;\r\n\t        } else {\r\n\t            this.linkNode.next = node;\r\n\t            this.linkNode = node;\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 删除链表头\r\n\t     * @private\r\n\t     */\r\n\t    ImagePool.prototype.shiftNode = function() {\r\n\t        //判断链表是否存在节点\r\n\t        if (this.linkHead) {\r\n\t            //修改链表头\r\n\t            this.linkHead = this.linkHead.next || null;\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 初始化图片池\r\n\t     * @param {number} max 最大连接数。数值。\r\n\t     * @returns {{load: Function, info: Function}}\r\n\t     */\r\n\t    var initImagePool = function(max) {\r\n\t        var instance = new ImagePool(max);\r\n\t        instance.initPool();\r\n\t        return {\r\n\t            /**\r\n\t             * 加载图片\r\n\t             * @param {string|Array} src 可以是src字符串，也可以是src字符串数组。\r\n\t             * @param {Object} options 用户自定义参数。包含：success回调、error回调、once标识。\r\n\t             * @param {Function} [options.success] success回调\r\n\t             * @param {Function} [options.error] error回调\r\n\t             * @param {boolean} [options.once] 是否全部加载完毕后，一次回调\r\n\t             */\r\n\t            load: function() {\r\n\t                instance._load.apply(instance, arguments);\r\n\t            },\r\n\t            /**\r\n\t             * 获取内部状态信息\r\n\t             * @returns {Object}\r\n\t             */\r\n\t            info: function() {\r\n\t                return instance._info.call(instance);\r\n\t            }\r\n\t        };\r\n\t    };\r\n\t\r\n\t    module.exports = { initImagePool: initImagePool }\r\n\t\r\n\n\n/***/ }),\n/* 96 */\n/***/ (function(module, exports) {\n\n\t\r\n\t    //polyfill bind\r\n\t    if (!Function.prototype.bind) {\r\n\t        Function.prototype.bind = function(oThis) {\r\n\t            if (typeof this !== \"function\") {\r\n\t                // closest thing possible to the ECMAScript 5 internal IsCallable function\r\n\t                throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\r\n\t            }\r\n\t\r\n\t            var aArgs = Array.prototype.slice.call(arguments, 1),\r\n\t                fToBind = this,\r\n\t                fNOP = function() {},\r\n\t                fBound = function() {\r\n\t                    return fToBind.apply(this instanceof fNOP && oThis ? this : oThis || window,\r\n\t                        aArgs.concat(Array.prototype.slice.call(arguments)));\r\n\t                };\r\n\t\r\n\t            fNOP.prototype = this.prototype;\r\n\t            fBound.prototype = new fNOP();\r\n\t\r\n\t            return fBound;\r\n\t        };\r\n\t    }\r\n\t\r\n\t    //polyfill remove\r\n\t    if (!('remove' in Element.prototype)) {\r\n\t        Element.prototype.remove = function() {\r\n\t            if (this.parentNode) {\r\n\t                this.parentNode.removeChild(this);\r\n\t            }\r\n\t        };\r\n\t    }\r\n\t\r\n\t    if (!String.prototype.endsWith) {\r\n\t    String.prototype.endsWith = function(searchString, position) {\r\n\t        var subjectString = this.toString();\r\n\t        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {\r\n\t            position = subjectString.length;\r\n\t        }\r\n\t        position -= searchString.length;\r\n\t        var lastIndex = subjectString.indexOf(searchString, position);\r\n\t        return lastIndex !== -1 && lastIndex === position;\r\n\t    };\r\n\t    }\r\n\t\r\n\n\n/***/ }),\n/* 97 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(98);\n\t\n\tvar _zrender = __webpack_require__(67);\n\t\n\tvar registerPainter = _zrender.registerPainter;\n\t\n\tvar Painter = __webpack_require__(100);\n\t\n\tregisterPainter('vml', Painter);\n\n/***/ }),\n/* 98 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar env = __webpack_require__(49);\n\t\n\tvar _vector = __webpack_require__(14);\n\t\n\tvar applyTransform = _vector.applyTransform;\n\t\n\tvar BoundingRect = __webpack_require__(26);\n\t\n\tvar colorTool = __webpack_require__(19);\n\t\n\tvar textContain = __webpack_require__(25);\n\t\n\tvar textHelper = __webpack_require__(24);\n\t\n\tvar RectText = __webpack_require__(23);\n\t\n\tvar Displayable = __webpack_require__(7);\n\t\n\tvar ZImage = __webpack_require__(44);\n\t\n\tvar Text = __webpack_require__(45);\n\t\n\tvar Path = __webpack_require__(6);\n\t\n\tvar PathProxy = __webpack_require__(29);\n\t\n\tvar Gradient = __webpack_require__(41);\n\t\n\tvar vmlCore = __webpack_require__(99);\n\t\n\t// http://www.w3.org/TR/NOTE-VML\n\t// TODO Use proxy like svg instead of overwrite brush methods\n\tvar CMD = PathProxy.CMD;\n\tvar round = Math.round;\n\tvar sqrt = Math.sqrt;\n\tvar abs = Math.abs;\n\tvar cos = Math.cos;\n\tvar sin = Math.sin;\n\tvar mathMax = Math.max;\n\t\n\tif (!env.canvasSupported) {\n\t  var comma = ',';\n\t  var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n\t  var Z = 21600;\n\t  var Z2 = Z / 2;\n\t  var ZLEVEL_BASE = 100000;\n\t  var Z_BASE = 1000;\n\t\n\t  var initRootElStyle = function (el) {\n\t    el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n\t    el.coordsize = Z + ',' + Z;\n\t    el.coordorigin = '0,0';\n\t  };\n\t\n\t  var encodeHtmlAttribute = function (s) {\n\t    return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n\t  };\n\t\n\t  var rgb2Str = function (r, g, b) {\n\t    return 'rgb(' + [r, g, b].join(',') + ')';\n\t  };\n\t\n\t  var append = function (parent, child) {\n\t    if (child && parent && child.parentNode !== parent) {\n\t      parent.appendChild(child);\n\t    }\n\t  };\n\t\n\t  var remove = function (parent, child) {\n\t    if (child && parent && child.parentNode === parent) {\n\t      parent.removeChild(child);\n\t    }\n\t  };\n\t\n\t  var getZIndex = function (zlevel, z, z2) {\n\t    // z 的取值范围为 [0, 1000]\n\t    return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n\t  };\n\t\n\t  var parsePercent = function (value, maxValue) {\n\t    if (typeof value === 'string') {\n\t      if (value.lastIndexOf('%') >= 0) {\n\t        return parseFloat(value) / 100 * maxValue;\n\t      }\n\t\n\t      return parseFloat(value);\n\t    }\n\t\n\t    return value;\n\t  };\n\t  /***************************************************\n\t   * PATH\n\t   **************************************************/\n\t\n\t\n\t  var setColorAndOpacity = function (el, color, opacity) {\n\t    var colorArr = colorTool.parse(color);\n\t    opacity = +opacity;\n\t\n\t    if (isNaN(opacity)) {\n\t      opacity = 1;\n\t    }\n\t\n\t    if (colorArr) {\n\t      el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n\t      el.opacity = opacity * colorArr[3];\n\t    }\n\t  };\n\t\n\t  var getColorAndAlpha = function (color) {\n\t    var colorArr = colorTool.parse(color);\n\t    return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];\n\t  };\n\t\n\t  var updateFillNode = function (el, style, zrEl) {\n\t    // TODO pattern\n\t    var fill = style.fill;\n\t\n\t    if (fill != null) {\n\t      // Modified from excanvas\n\t      if (fill instanceof Gradient) {\n\t        var gradientType;\n\t        var angle = 0;\n\t        var focus = [0, 0]; // additional offset\n\t\n\t        var shift = 0; // scale factor for offset\n\t\n\t        var expansion = 1;\n\t        var rect = zrEl.getBoundingRect();\n\t        var rectWidth = rect.width;\n\t        var rectHeight = rect.height;\n\t\n\t        if (fill.type === 'linear') {\n\t          gradientType = 'gradient';\n\t          var transform = zrEl.transform;\n\t          var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n\t          var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n\t\n\t          if (transform) {\n\t            applyTransform(p0, p0, transform);\n\t            applyTransform(p1, p1, transform);\n\t          }\n\t\n\t          var dx = p1[0] - p0[0];\n\t          var dy = p1[1] - p0[1];\n\t          angle = Math.atan2(dx, dy) * 180 / Math.PI; // The angle should be a non-negative number.\n\t\n\t          if (angle < 0) {\n\t            angle += 360;\n\t          } // Very small angles produce an unexpected result because they are\n\t          // converted to a scientific notation string.\n\t\n\t\n\t          if (angle < 1e-6) {\n\t            angle = 0;\n\t          }\n\t        } else {\n\t          gradientType = 'gradientradial';\n\t          var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n\t          var transform = zrEl.transform;\n\t          var scale = zrEl.scale;\n\t          var width = rectWidth;\n\t          var height = rectHeight;\n\t          focus = [// Percent in bounding rect\n\t          (p0[0] - rect.x) / width, (p0[1] - rect.y) / height];\n\t\n\t          if (transform) {\n\t            applyTransform(p0, p0, transform);\n\t          }\n\t\n\t          width /= scale[0] * Z;\n\t          height /= scale[1] * Z;\n\t          var dimension = mathMax(width, height);\n\t          shift = 2 * 0 / dimension;\n\t          expansion = 2 * fill.r / dimension - shift;\n\t        } // We need to sort the color stops in ascending order by offset,\n\t        // otherwise IE won't interpret it correctly.\n\t\n\t\n\t        var stops = fill.colorStops.slice();\n\t        stops.sort(function (cs1, cs2) {\n\t          return cs1.offset - cs2.offset;\n\t        });\n\t        var length = stops.length; // Color and alpha list of first and last stop\n\t\n\t        var colorAndAlphaList = [];\n\t        var colors = [];\n\t\n\t        for (var i = 0; i < length; i++) {\n\t          var stop = stops[i];\n\t          var colorAndAlpha = getColorAndAlpha(stop.color);\n\t          colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n\t\n\t          if (i === 0 || i === length - 1) {\n\t            colorAndAlphaList.push(colorAndAlpha);\n\t          }\n\t        }\n\t\n\t        if (length >= 2) {\n\t          var color1 = colorAndAlphaList[0][0];\n\t          var color2 = colorAndAlphaList[1][0];\n\t          var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n\t          var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n\t          el.type = gradientType;\n\t          el.method = 'none';\n\t          el.focus = '100%';\n\t          el.angle = angle;\n\t          el.color = color1;\n\t          el.color2 = color2;\n\t          el.colors = colors.join(','); // When colors attribute is used, the meanings of opacity and o:opacity2\n\t          // are reversed.\n\t\n\t          el.opacity = opacity2; // FIXME g_o_:opacity ?\n\t\n\t          el.opacity2 = opacity1;\n\t        }\n\t\n\t        if (gradientType === 'radial') {\n\t          el.focusposition = focus.join(',');\n\t        }\n\t      } else {\n\t        // FIXME Change from Gradient fill to color fill\n\t        setColorAndOpacity(el, fill, style.opacity);\n\t      }\n\t    }\n\t  };\n\t\n\t  var updateStrokeNode = function (el, style) {\n\t    // if (style.lineJoin != null) {\n\t    //     el.joinstyle = style.lineJoin;\n\t    // }\n\t    // if (style.miterLimit != null) {\n\t    //     el.miterlimit = style.miterLimit * Z;\n\t    // }\n\t    // if (style.lineCap != null) {\n\t    //     el.endcap = style.lineCap;\n\t    // }\n\t    if (style.lineDash != null) {\n\t      el.dashstyle = style.lineDash.join(' ');\n\t    }\n\t\n\t    if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n\t      setColorAndOpacity(el, style.stroke, style.opacity);\n\t    }\n\t  };\n\t\n\t  var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n\t    var isFill = type == 'fill';\n\t    var el = vmlEl.getElementsByTagName(type)[0]; // Stroke must have lineWidth\n\t\n\t    if (style[type] != null && style[type] !== 'none' && (isFill || !isFill && style.lineWidth)) {\n\t      vmlEl[isFill ? 'filled' : 'stroked'] = 'true'; // FIXME Remove before updating, or set `colors` will throw error\n\t\n\t      if (style[type] instanceof Gradient) {\n\t        remove(vmlEl, el);\n\t      }\n\t\n\t      if (!el) {\n\t        el = vmlCore.createNode(type);\n\t      }\n\t\n\t      isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n\t      append(vmlEl, el);\n\t    } else {\n\t      vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n\t      remove(vmlEl, el);\n\t    }\n\t  };\n\t\n\t  var points = [[], [], []];\n\t\n\t  var pathDataToString = function (path, m) {\n\t    var M = CMD.M;\n\t    var C = CMD.C;\n\t    var L = CMD.L;\n\t    var A = CMD.A;\n\t    var Q = CMD.Q;\n\t    var str = [];\n\t    var nPoint;\n\t    var cmdStr;\n\t    var cmd;\n\t    var i;\n\t    var xi;\n\t    var yi;\n\t    var data = path.data;\n\t    var dataLength = path.len();\n\t\n\t    for (i = 0; i < dataLength;) {\n\t      cmd = data[i++];\n\t      cmdStr = '';\n\t      nPoint = 0;\n\t\n\t      switch (cmd) {\n\t        case M:\n\t          cmdStr = ' m ';\n\t          nPoint = 1;\n\t          xi = data[i++];\n\t          yi = data[i++];\n\t          points[0][0] = xi;\n\t          points[0][1] = yi;\n\t          break;\n\t\n\t        case L:\n\t          cmdStr = ' l ';\n\t          nPoint = 1;\n\t          xi = data[i++];\n\t          yi = data[i++];\n\t          points[0][0] = xi;\n\t          points[0][1] = yi;\n\t          break;\n\t\n\t        case Q:\n\t        case C:\n\t          cmdStr = ' c ';\n\t          nPoint = 3;\n\t          var x1 = data[i++];\n\t          var y1 = data[i++];\n\t          var x2 = data[i++];\n\t          var y2 = data[i++];\n\t          var x3;\n\t          var y3;\n\t\n\t          if (cmd === Q) {\n\t            // Convert quadratic to cubic using degree elevation\n\t            x3 = x2;\n\t            y3 = y2;\n\t            x2 = (x2 + 2 * x1) / 3;\n\t            y2 = (y2 + 2 * y1) / 3;\n\t            x1 = (xi + 2 * x1) / 3;\n\t            y1 = (yi + 2 * y1) / 3;\n\t          } else {\n\t            x3 = data[i++];\n\t            y3 = data[i++];\n\t          }\n\t\n\t          points[0][0] = x1;\n\t          points[0][1] = y1;\n\t          points[1][0] = x2;\n\t          points[1][1] = y2;\n\t          points[2][0] = x3;\n\t          points[2][1] = y3;\n\t          xi = x3;\n\t          yi = y3;\n\t          break;\n\t\n\t        case A:\n\t          var x = 0;\n\t          var y = 0;\n\t          var sx = 1;\n\t          var sy = 1;\n\t          var angle = 0;\n\t\n\t          if (m) {\n\t            // Extract SRT from matrix\n\t            x = m[4];\n\t            y = m[5];\n\t            sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n\t            sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n\t            angle = Math.atan2(-m[1] / sy, m[0] / sx);\n\t          }\n\t\n\t          var cx = data[i++];\n\t          var cy = data[i++];\n\t          var rx = data[i++];\n\t          var ry = data[i++];\n\t          var startAngle = data[i++] + angle;\n\t          var endAngle = data[i++] + startAngle + angle; // FIXME\n\t          // var psi = data[i++];\n\t\n\t          i++;\n\t          var clockwise = data[i++];\n\t          var x0 = cx + cos(startAngle) * rx;\n\t          var y0 = cy + sin(startAngle) * ry;\n\t          var x1 = cx + cos(endAngle) * rx;\n\t          var y1 = cy + sin(endAngle) * ry;\n\t          var type = clockwise ? ' wa ' : ' at ';\n\t\n\t          if (Math.abs(x0 - x1) < 1e-4) {\n\t            // IE won't render arches drawn counter clockwise if x0 == x1.\n\t            if (Math.abs(endAngle - startAngle) > 1e-2) {\n\t              // Offset x0 by 1/80 of a pixel. Use something\n\t              // that can be represented in binary\n\t              if (clockwise) {\n\t                x0 += 270 / Z;\n\t              }\n\t            } else {\n\t              // Avoid case draw full circle\n\t              if (Math.abs(y0 - cy) < 1e-4) {\n\t                if (clockwise && x0 < cx || !clockwise && x0 > cx) {\n\t                  y1 -= 270 / Z;\n\t                } else {\n\t                  y1 += 270 / Z;\n\t                }\n\t              } else if (clockwise && y0 < cy || !clockwise && y0 > cy) {\n\t                x1 += 270 / Z;\n\t              } else {\n\t                x1 -= 270 / Z;\n\t              }\n\t            }\n\t          }\n\t\n\t          str.push(type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2));\n\t          xi = x1;\n\t          yi = y1;\n\t          break;\n\t\n\t        case CMD.R:\n\t          var p0 = points[0];\n\t          var p1 = points[1]; // x0, y0\n\t\n\t          p0[0] = data[i++];\n\t          p0[1] = data[i++]; // x1, y1\n\t\n\t          p1[0] = p0[0] + data[i++];\n\t          p1[1] = p0[1] + data[i++];\n\t\n\t          if (m) {\n\t            applyTransform(p0, p0, m);\n\t            applyTransform(p1, p1, m);\n\t          }\n\t\n\t          p0[0] = round(p0[0] * Z - Z2);\n\t          p1[0] = round(p1[0] * Z - Z2);\n\t          p0[1] = round(p0[1] * Z - Z2);\n\t          p1[1] = round(p1[1] * Z - Z2);\n\t          str.push( // x0, y0\n\t          ' m ', p0[0], comma, p0[1], // x1, y0\n\t          ' l ', p1[0], comma, p0[1], // x1, y1\n\t          ' l ', p1[0], comma, p1[1], // x0, y1\n\t          ' l ', p0[0], comma, p1[1]);\n\t          break;\n\t\n\t        case CMD.Z:\n\t          // FIXME Update xi, yi\n\t          str.push(' x ');\n\t      }\n\t\n\t      if (nPoint > 0) {\n\t        str.push(cmdStr);\n\t\n\t        for (var k = 0; k < nPoint; k++) {\n\t          var p = points[k];\n\t          m && applyTransform(p, p, m); // 不 round 会非常慢\n\t\n\t          str.push(round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k < nPoint - 1 ? comma : '');\n\t        }\n\t      }\n\t    }\n\t\n\t    return str.join('');\n\t  }; // Rewrite the original path method\n\t\n\t\n\t  Path.prototype.brushVML = function (vmlRoot) {\n\t    var style = this.style;\n\t    var vmlEl = this._vmlEl;\n\t\n\t    if (!vmlEl) {\n\t      vmlEl = vmlCore.createNode('shape');\n\t      initRootElStyle(vmlEl);\n\t      this._vmlEl = vmlEl;\n\t    }\n\t\n\t    updateFillAndStroke(vmlEl, 'fill', style, this);\n\t    updateFillAndStroke(vmlEl, 'stroke', style, this);\n\t    var m = this.transform;\n\t    var needTransform = m != null;\n\t    var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n\t\n\t    if (strokeEl) {\n\t      var lineWidth = style.lineWidth; // Get the line scale.\n\t      // Determinant of this.m_ means how much the area is enlarged by the\n\t      // transformation. So its square root can be used as a scale factor\n\t      // for width.\n\t\n\t      if (needTransform && !style.strokeNoScale) {\n\t        var det = m[0] * m[3] - m[1] * m[2];\n\t        lineWidth *= sqrt(abs(det));\n\t      }\n\t\n\t      strokeEl.weight = lineWidth + 'px';\n\t    }\n\t\n\t    var path = this.path || (this.path = new PathProxy());\n\t\n\t    if (this.__dirtyPath) {\n\t      path.beginPath();\n\t      this.buildPath(path, this.shape);\n\t      path.toStatic();\n\t      this.__dirtyPath = false;\n\t    }\n\t\n\t    vmlEl.path = pathDataToString(path, this.transform);\n\t    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\t\n\t    append(vmlRoot, vmlEl); // Text\n\t\n\t    if (style.text != null) {\n\t      this.drawRectText(vmlRoot, this.getBoundingRect());\n\t    } else {\n\t      this.removeRectText(vmlRoot);\n\t    }\n\t  };\n\t\n\t  Path.prototype.onRemove = function (vmlRoot) {\n\t    remove(vmlRoot, this._vmlEl);\n\t    this.removeRectText(vmlRoot);\n\t  };\n\t\n\t  Path.prototype.onAdd = function (vmlRoot) {\n\t    append(vmlRoot, this._vmlEl);\n\t    this.appendRectText(vmlRoot);\n\t  };\n\t  /***************************************************\n\t   * IMAGE\n\t   **************************************************/\n\t\n\t\n\t  var isImage = function (img) {\n\t    // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错\n\t    return typeof img === 'object' && img.tagName && img.tagName.toUpperCase() === 'IMG'; // return img instanceof Image;\n\t  }; // Rewrite the original path method\n\t\n\t\n\t  ZImage.prototype.brushVML = function (vmlRoot) {\n\t    var style = this.style;\n\t    var image = style.image; // Image original width, height\n\t\n\t    var ow;\n\t    var oh;\n\t\n\t    if (isImage(image)) {\n\t      var src = image.src;\n\t\n\t      if (src === this._imageSrc) {\n\t        ow = this._imageWidth;\n\t        oh = this._imageHeight;\n\t      } else {\n\t        var imageRuntimeStyle = image.runtimeStyle;\n\t        var oldRuntimeWidth = imageRuntimeStyle.width;\n\t        var oldRuntimeHeight = imageRuntimeStyle.height;\n\t        imageRuntimeStyle.width = 'auto';\n\t        imageRuntimeStyle.height = 'auto'; // get the original size\n\t\n\t        ow = image.width;\n\t        oh = image.height; // and remove overides\n\t\n\t        imageRuntimeStyle.width = oldRuntimeWidth;\n\t        imageRuntimeStyle.height = oldRuntimeHeight; // Caching image original width, height and src\n\t\n\t        this._imageSrc = src;\n\t        this._imageWidth = ow;\n\t        this._imageHeight = oh;\n\t      }\n\t\n\t      image = src;\n\t    } else {\n\t      if (image === this._imageSrc) {\n\t        ow = this._imageWidth;\n\t        oh = this._imageHeight;\n\t      }\n\t    }\n\t\n\t    if (!image) {\n\t      return;\n\t    }\n\t\n\t    var x = style.x || 0;\n\t    var y = style.y || 0;\n\t    var dw = style.width;\n\t    var dh = style.height;\n\t    var sw = style.sWidth;\n\t    var sh = style.sHeight;\n\t    var sx = style.sx || 0;\n\t    var sy = style.sy || 0;\n\t    var hasCrop = sw && sh;\n\t    var vmlEl = this._vmlEl;\n\t\n\t    if (!vmlEl) {\n\t      // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。\n\t      // vmlEl = vmlCore.createNode('group');\n\t      vmlEl = vmlCore.doc.createElement('div');\n\t      initRootElStyle(vmlEl);\n\t      this._vmlEl = vmlEl;\n\t    }\n\t\n\t    var vmlElStyle = vmlEl.style;\n\t    var hasRotation = false;\n\t    var m;\n\t    var scaleX = 1;\n\t    var scaleY = 1;\n\t\n\t    if (this.transform) {\n\t      m = this.transform;\n\t      scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n\t      scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n\t      hasRotation = m[1] || m[2];\n\t    }\n\t\n\t    if (hasRotation) {\n\t      // If filters are necessary (rotation exists), create them\n\t      // filters are bog-slow, so only create them if abbsolutely necessary\n\t      // The following check doesn't account for skews (which don't exist\n\t      // in the canvas spec (yet) anyway.\n\t      // From excanvas\n\t      var p0 = [x, y];\n\t      var p1 = [x + dw, y];\n\t      var p2 = [x, y + dh];\n\t      var p3 = [x + dw, y + dh];\n\t      applyTransform(p0, p0, m);\n\t      applyTransform(p1, p1, m);\n\t      applyTransform(p2, p2, m);\n\t      applyTransform(p3, p3, m);\n\t      var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n\t      var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n\t      var transformFilter = [];\n\t      transformFilter.push('M11=', m[0] / scaleX, comma, 'M12=', m[2] / scaleY, comma, 'M21=', m[1] / scaleX, comma, 'M22=', m[3] / scaleY, comma, 'Dx=', round(x * scaleX + m[4]), comma, 'Dy=', round(y * scaleY + m[5]));\n\t      vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0'; // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用\n\t\n\t      vmlElStyle.filter = imageTransformPrefix + '.Matrix(' + transformFilter.join('') + ', SizingMethod=clip)';\n\t    } else {\n\t      if (m) {\n\t        x = x * scaleX + m[4];\n\t        y = y * scaleY + m[5];\n\t      }\n\t\n\t      vmlElStyle.filter = '';\n\t      vmlElStyle.left = round(x) + 'px';\n\t      vmlElStyle.top = round(y) + 'px';\n\t    }\n\t\n\t    var imageEl = this._imageEl;\n\t    var cropEl = this._cropEl;\n\t\n\t    if (!imageEl) {\n\t      imageEl = vmlCore.doc.createElement('div');\n\t      this._imageEl = imageEl;\n\t    }\n\t\n\t    var imageELStyle = imageEl.style;\n\t\n\t    if (hasCrop) {\n\t      // Needs know image original width and height\n\t      if (!(ow && oh)) {\n\t        var tmpImage = new Image();\n\t        var self = this;\n\t\n\t        tmpImage.onload = function () {\n\t          tmpImage.onload = null;\n\t          ow = tmpImage.width;\n\t          oh = tmpImage.height; // Adjust image width and height to fit the ratio destinationSize / sourceSize\n\t\n\t          imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n\t          imageELStyle.height = round(scaleY * oh * dh / sh) + 'px'; // Caching image original width, height and src\n\t\n\t          self._imageWidth = ow;\n\t          self._imageHeight = oh;\n\t          self._imageSrc = image;\n\t        };\n\t\n\t        tmpImage.src = image;\n\t      } else {\n\t        imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n\t        imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n\t      }\n\t\n\t      if (!cropEl) {\n\t        cropEl = vmlCore.doc.createElement('div');\n\t        cropEl.style.overflow = 'hidden';\n\t        this._cropEl = cropEl;\n\t      }\n\t\n\t      var cropElStyle = cropEl.style;\n\t      cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n\t      cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n\t      cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx=' + -sx * dw / sw * scaleX + ',Dy=' + -sy * dh / sh * scaleY + ')';\n\t\n\t      if (!cropEl.parentNode) {\n\t        vmlEl.appendChild(cropEl);\n\t      }\n\t\n\t      if (imageEl.parentNode != cropEl) {\n\t        cropEl.appendChild(imageEl);\n\t      }\n\t    } else {\n\t      imageELStyle.width = round(scaleX * dw) + 'px';\n\t      imageELStyle.height = round(scaleY * dh) + 'px';\n\t      vmlEl.appendChild(imageEl);\n\t\n\t      if (cropEl && cropEl.parentNode) {\n\t        vmlEl.removeChild(cropEl);\n\t        this._cropEl = null;\n\t      }\n\t    }\n\t\n\t    var filterStr = '';\n\t    var alpha = style.opacity;\n\t\n\t    if (alpha < 1) {\n\t      filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n\t    }\n\t\n\t    filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n\t    imageELStyle.filter = filterStr;\n\t    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\t\n\t    append(vmlRoot, vmlEl); // Text\n\t\n\t    if (style.text != null) {\n\t      this.drawRectText(vmlRoot, this.getBoundingRect());\n\t    }\n\t  };\n\t\n\t  ZImage.prototype.onRemove = function (vmlRoot) {\n\t    remove(vmlRoot, this._vmlEl);\n\t    this._vmlEl = null;\n\t    this._cropEl = null;\n\t    this._imageEl = null;\n\t    this.removeRectText(vmlRoot);\n\t  };\n\t\n\t  ZImage.prototype.onAdd = function (vmlRoot) {\n\t    append(vmlRoot, this._vmlEl);\n\t    this.appendRectText(vmlRoot);\n\t  };\n\t  /***************************************************\n\t   * TEXT\n\t   **************************************************/\n\t\n\t\n\t  var DEFAULT_STYLE_NORMAL = 'normal';\n\t  var fontStyleCache = {};\n\t  var fontStyleCacheCount = 0;\n\t  var MAX_FONT_CACHE_SIZE = 100;\n\t  var fontEl = document.createElement('div');\n\t\n\t  var getFontStyle = function (fontString) {\n\t    var fontStyle = fontStyleCache[fontString];\n\t\n\t    if (!fontStyle) {\n\t      // Clear cache\n\t      if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n\t        fontStyleCacheCount = 0;\n\t        fontStyleCache = {};\n\t      }\n\t\n\t      var style = fontEl.style;\n\t      var fontFamily;\n\t\n\t      try {\n\t        style.font = fontString;\n\t        fontFamily = style.fontFamily.split(',')[0];\n\t      } catch (e) {}\n\t\n\t      fontStyle = {\n\t        style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n\t        variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n\t        weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n\t        size: parseFloat(style.fontSize || 12) | 0,\n\t        family: fontFamily || 'Microsoft YaHei'\n\t      };\n\t      fontStyleCache[fontString] = fontStyle;\n\t      fontStyleCacheCount++;\n\t    }\n\t\n\t    return fontStyle;\n\t  };\n\t\n\t  var textMeasureEl; // Overwrite measure text method\n\t\n\t  textContain.$override('measureText', function (text, textFont) {\n\t    var doc = vmlCore.doc;\n\t\n\t    if (!textMeasureEl) {\n\t      textMeasureEl = doc.createElement('div');\n\t      textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;' + 'padding:0;margin:0;border:none;white-space:pre;';\n\t      vmlCore.doc.body.appendChild(textMeasureEl);\n\t    }\n\t\n\t    try {\n\t      textMeasureEl.style.font = textFont;\n\t    } catch (ex) {// Ignore failures to set to invalid font.\n\t    }\n\t\n\t    textMeasureEl.innerHTML = ''; // Don't use innerHTML or innerText because they allow markup/whitespace.\n\t\n\t    textMeasureEl.appendChild(doc.createTextNode(text));\n\t    return {\n\t      width: textMeasureEl.offsetWidth\n\t    };\n\t  });\n\t  var tmpRect = new BoundingRect();\n\t\n\t  var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n\t    var style = this.style; // Optimize, avoid normalize every time.\n\t\n\t    this.__dirty && textHelper.normalizeTextStyle(style, true);\n\t    var text = style.text; // Convert to string\n\t\n\t    text != null && (text += '');\n\t\n\t    if (!text) {\n\t      return;\n\t    } // Convert rich text to plain text. Rich text is not supported in\n\t    // IE8-, but tags in rich text template will be removed.\n\t\n\t\n\t    if (style.rich) {\n\t      var contentBlock = textContain.parseRichText(text, style);\n\t      text = [];\n\t\n\t      for (var i = 0; i < contentBlock.lines.length; i++) {\n\t        var tokens = contentBlock.lines[i].tokens;\n\t        var textLine = [];\n\t\n\t        for (var j = 0; j < tokens.length; j++) {\n\t          textLine.push(tokens[j].text);\n\t        }\n\t\n\t        text.push(textLine.join(''));\n\t      }\n\t\n\t      text = text.join('\\n');\n\t    }\n\t\n\t    var x;\n\t    var y;\n\t    var align = style.textAlign;\n\t    var verticalAlign = style.textVerticalAlign;\n\t    var fontStyle = getFontStyle(style.font); // FIXME encodeHtmlAttribute ?\n\t\n\t    var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' ' + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n\t    textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign); // Transform rect to view space\n\t\n\t    var m = this.transform; // Ignore transform for text in other element\n\t\n\t    if (m && !fromTextEl) {\n\t      tmpRect.copy(rect);\n\t      tmpRect.applyTransform(m);\n\t      rect = tmpRect;\n\t    }\n\t\n\t    if (!fromTextEl) {\n\t      var textPosition = style.textPosition;\n\t      var distance = style.textDistance; // Text position represented by coord\n\t\n\t      if (textPosition instanceof Array) {\n\t        x = rect.x + parsePercent(textPosition[0], rect.width);\n\t        y = rect.y + parsePercent(textPosition[1], rect.height);\n\t        align = align || 'left';\n\t      } else {\n\t        var res = textContain.adjustTextPositionOnRect(textPosition, rect, distance);\n\t        x = res.x;\n\t        y = res.y; // Default align and baseline when has textPosition\n\t\n\t        align = align || res.textAlign;\n\t        verticalAlign = verticalAlign || res.textVerticalAlign;\n\t      }\n\t    } else {\n\t      x = rect.x;\n\t      y = rect.y;\n\t    }\n\t\n\t    x = textContain.adjustTextX(x, textRect.width, align);\n\t    y = textContain.adjustTextY(y, textRect.height, verticalAlign); // Force baseline 'middle'\n\t\n\t    y += textRect.height / 2; // var fontSize = fontStyle.size;\n\t    // 1.75 is an arbitrary number, as there is no info about the text baseline\n\t    // switch (baseline) {\n\t    // case 'hanging':\n\t    // case 'top':\n\t    //     y += fontSize / 1.75;\n\t    //     break;\n\t    //     case 'middle':\n\t    //         break;\n\t    //     default:\n\t    //     // case null:\n\t    //     // case 'alphabetic':\n\t    //     // case 'ideographic':\n\t    //     // case 'bottom':\n\t    //         y -= fontSize / 2.25;\n\t    //         break;\n\t    // }\n\t    // switch (align) {\n\t    //     case 'left':\n\t    //         break;\n\t    //     case 'center':\n\t    //         x -= textRect.width / 2;\n\t    //         break;\n\t    //     case 'right':\n\t    //         x -= textRect.width;\n\t    //         break;\n\t    // case 'end':\n\t    // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n\t    // break;\n\t    // case 'start':\n\t    // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n\t    // break;\n\t    // default:\n\t    //     align = 'left';\n\t    // }\n\t\n\t    var createNode = vmlCore.createNode;\n\t    var textVmlEl = this._textVmlEl;\n\t    var pathEl;\n\t    var textPathEl;\n\t    var skewEl;\n\t\n\t    if (!textVmlEl) {\n\t      textVmlEl = createNode('line');\n\t      pathEl = createNode('path');\n\t      textPathEl = createNode('textpath');\n\t      skewEl = createNode('skew'); // FIXME Why here is not cammel case\n\t      // Align 'center' seems wrong\n\t\n\t      textPathEl.style['v-text-align'] = 'left';\n\t      initRootElStyle(textVmlEl);\n\t      pathEl.textpathok = true;\n\t      textPathEl.on = true;\n\t      textVmlEl.from = '0 0';\n\t      textVmlEl.to = '1000 0.05';\n\t      append(textVmlEl, skewEl);\n\t      append(textVmlEl, pathEl);\n\t      append(textVmlEl, textPathEl);\n\t      this._textVmlEl = textVmlEl;\n\t    } else {\n\t      // 这里是在前面 appendChild 保证顺序的前提下\n\t      skewEl = textVmlEl.firstChild;\n\t      pathEl = skewEl.nextSibling;\n\t      textPathEl = pathEl.nextSibling;\n\t    }\n\t\n\t    var coords = [x, y];\n\t    var textVmlElStyle = textVmlEl.style; // Ignore transform for text in other element\n\t\n\t    if (m && fromTextEl) {\n\t      applyTransform(coords, coords, m);\n\t      skewEl.on = true;\n\t      skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0'; // Text position\n\t\n\t      skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0); // Left top point as origin\n\t\n\t      skewEl.origin = '0 0';\n\t      textVmlElStyle.left = '0px';\n\t      textVmlElStyle.top = '0px';\n\t    } else {\n\t      skewEl.on = false;\n\t      textVmlElStyle.left = round(x) + 'px';\n\t      textVmlElStyle.top = round(y) + 'px';\n\t    }\n\t\n\t    textPathEl.string = encodeHtmlAttribute(text); // TODO\n\t\n\t    try {\n\t      textPathEl.style.font = font;\n\t    } // Error font format\n\t    catch (e) {}\n\t\n\t    updateFillAndStroke(textVmlEl, 'fill', {\n\t      fill: style.textFill,\n\t      opacity: style.opacity\n\t    }, this);\n\t    updateFillAndStroke(textVmlEl, 'stroke', {\n\t      stroke: style.textStroke,\n\t      opacity: style.opacity,\n\t      lineDash: style.lineDash\n\t    }, this);\n\t    textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Attached to root\n\t\n\t    append(vmlRoot, textVmlEl);\n\t  };\n\t\n\t  var removeRectText = function (vmlRoot) {\n\t    remove(vmlRoot, this._textVmlEl);\n\t    this._textVmlEl = null;\n\t  };\n\t\n\t  var appendRectText = function (vmlRoot) {\n\t    append(vmlRoot, this._textVmlEl);\n\t  };\n\t\n\t  var list = [RectText, Displayable, ZImage, Path, Text]; // In case Displayable has been mixed in RectText\n\t\n\t  for (var i = 0; i < list.length; i++) {\n\t    var proto = list[i].prototype;\n\t    proto.drawRectText = drawRectText;\n\t    proto.removeRectText = removeRectText;\n\t    proto.appendRectText = appendRectText;\n\t  }\n\t\n\t  Text.prototype.brushVML = function (vmlRoot) {\n\t    var style = this.style;\n\t\n\t    if (style.text != null) {\n\t      this.drawRectText(vmlRoot, {\n\t        x: style.x || 0,\n\t        y: style.y || 0,\n\t        width: 0,\n\t        height: 0\n\t      }, this.getBoundingRect(), true);\n\t    } else {\n\t      this.removeRectText(vmlRoot);\n\t    }\n\t  };\n\t\n\t  Text.prototype.onRemove = function (vmlRoot) {\n\t    this.removeRectText(vmlRoot);\n\t  };\n\t\n\t  Text.prototype.onAdd = function (vmlRoot) {\n\t    this.appendRectText(vmlRoot);\n\t  };\n\t}\n\n/***/ }),\n/* 99 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar env = __webpack_require__(49);\n\t\n\tvar urn = 'urn:schemas-microsoft-com:vml';\n\tvar win = typeof window === 'undefined' ? null : window;\n\tvar vmlInited = false;\n\tvar doc = win && win.document;\n\t\n\tfunction createNode(tagName) {\n\t  return doCreateNode(tagName);\n\t} // Avoid assign to an exported variable, for transforming to cjs.\n\t\n\t\n\tvar doCreateNode;\n\t\n\tif (doc && !env.canvasSupported) {\n\t  try {\n\t    !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);\n\t\n\t    doCreateNode = function (tagName) {\n\t      return doc.createElement('<zrvml:' + tagName + ' class=\"zrvml\">');\n\t    };\n\t  } catch (e) {\n\t    doCreateNode = function (tagName) {\n\t      return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"zrvml\">');\n\t    };\n\t  }\n\t} // From raphael\n\t\n\t\n\tfunction initVML() {\n\t  if (vmlInited || !doc) {\n\t    return;\n\t  }\n\t\n\t  vmlInited = true;\n\t  var styleSheets = doc.styleSheets;\n\t\n\t  if (styleSheets.length < 31) {\n\t    doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');\n\t  } else {\n\t    // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n\t    styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');\n\t  }\n\t}\n\t\n\texports.doc = doc;\n\texports.createNode = createNode;\n\texports.initVML = initVML;\n\n/***/ }),\n/* 100 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar zrLog = __webpack_require__(21);\n\t\n\tvar vmlCore = __webpack_require__(99);\n\t\n\tvar _util = __webpack_require__(4);\n\t\n\tvar each = _util.each;\n\t\n\t/**\n\t * VML Painter.\n\t *\n\t * @module zrender/vml/Painter\n\t */\n\tfunction parseInt10(val) {\n\t  return parseInt(val, 10);\n\t}\n\t/**\n\t * @alias module:zrender/vml/Painter\n\t */\n\t\n\t\n\tfunction VMLPainter(root, storage) {\n\t  vmlCore.initVML();\n\t  this.root = root;\n\t  this.storage = storage;\n\t  var vmlViewport = document.createElement('div');\n\t  var vmlRoot = document.createElement('div');\n\t  vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n\t  vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n\t  root.appendChild(vmlViewport);\n\t  this._vmlRoot = vmlRoot;\n\t  this._vmlViewport = vmlViewport;\n\t  this.resize(); // Modify storage\n\t\n\t  var oldDelFromStorage = storage.delFromStorage;\n\t  var oldAddToStorage = storage.addToStorage;\n\t\n\t  storage.delFromStorage = function (el) {\n\t    oldDelFromStorage.call(storage, el);\n\t\n\t    if (el) {\n\t      el.onRemove && el.onRemove(vmlRoot);\n\t    }\n\t  };\n\t\n\t  storage.addToStorage = function (el) {\n\t    // Displayable already has a vml node\n\t    el.onAdd && el.onAdd(vmlRoot);\n\t    oldAddToStorage.call(storage, el);\n\t  };\n\t\n\t  this._firstPaint = true;\n\t}\n\t\n\tVMLPainter.prototype = {\n\t  constructor: VMLPainter,\n\t  getType: function () {\n\t    return 'vml';\n\t  },\n\t\n\t  /**\n\t   * @return {HTMLDivElement}\n\t   */\n\t  getViewportRoot: function () {\n\t    return this._vmlViewport;\n\t  },\n\t  getViewportRootOffset: function () {\n\t    var viewportRoot = this.getViewportRoot();\n\t\n\t    if (viewportRoot) {\n\t      return {\n\t        offsetLeft: viewportRoot.offsetLeft || 0,\n\t        offsetTop: viewportRoot.offsetTop || 0\n\t      };\n\t    }\n\t  },\n\t\n\t  /**\n\t   * 刷新\n\t   */\n\t  refresh: function () {\n\t    var list = this.storage.getDisplayList(true, true);\n\t\n\t    this._paintList(list);\n\t  },\n\t  _paintList: function (list) {\n\t    var vmlRoot = this._vmlRoot;\n\t\n\t    for (var i = 0; i < list.length; i++) {\n\t      var el = list[i];\n\t\n\t      if (el.invisible || el.ignore) {\n\t        if (!el.__alreadyNotVisible) {\n\t          el.onRemove(vmlRoot);\n\t        } // Set as already invisible\n\t\n\t\n\t        el.__alreadyNotVisible = true;\n\t      } else {\n\t        if (el.__alreadyNotVisible) {\n\t          el.onAdd(vmlRoot);\n\t        }\n\t\n\t        el.__alreadyNotVisible = false;\n\t\n\t        if (el.__dirty) {\n\t          el.beforeBrush && el.beforeBrush();\n\t          (el.brushVML || el.brush).call(el, vmlRoot);\n\t          el.afterBrush && el.afterBrush();\n\t        }\n\t      }\n\t\n\t      el.__dirty = false;\n\t    }\n\t\n\t    if (this._firstPaint) {\n\t      // Detached from document at first time\n\t      // to avoid page refreshing too many times\n\t      // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变\n\t      this._vmlViewport.appendChild(vmlRoot);\n\t\n\t      this._firstPaint = false;\n\t    }\n\t  },\n\t  resize: function (width, height) {\n\t    var width = width == null ? this._getWidth() : width;\n\t    var height = height == null ? this._getHeight() : height;\n\t\n\t    if (this._width != width || this._height != height) {\n\t      this._width = width;\n\t      this._height = height;\n\t      var vmlViewportStyle = this._vmlViewport.style;\n\t      vmlViewportStyle.width = width + 'px';\n\t      vmlViewportStyle.height = height + 'px';\n\t    }\n\t  },\n\t  dispose: function () {\n\t    this.root.innerHTML = '';\n\t    this._vmlRoot = this._vmlViewport = this.storage = null;\n\t  },\n\t  getWidth: function () {\n\t    return this._width;\n\t  },\n\t  getHeight: function () {\n\t    return this._height;\n\t  },\n\t  clear: function () {\n\t    if (this._vmlViewport) {\n\t      this.root.removeChild(this._vmlViewport);\n\t    }\n\t  },\n\t  _getWidth: function () {\n\t    var root = this.root;\n\t    var stl = root.currentStyle;\n\t    return (root.clientWidth || parseInt10(stl.width)) - parseInt10(stl.paddingLeft) - parseInt10(stl.paddingRight) | 0;\n\t  },\n\t  _getHeight: function () {\n\t    var root = this.root;\n\t    var stl = root.currentStyle;\n\t    return (root.clientHeight || parseInt10(stl.height)) - parseInt10(stl.paddingTop) - parseInt10(stl.paddingBottom) | 0;\n\t  }\n\t}; // Not supported methods\n\t\n\tfunction createMethodNotSupport(method) {\n\t  return function () {\n\t    zrLog('In IE8.0 VML mode painter not support method \"' + method + '\"');\n\t  };\n\t} // Unsupported methods\n\t\n\t\n\teach(['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'], function (name) {\n\t  VMLPainter.prototype[name] = createMethodNotSupport(name);\n\t});\n\tvar _default = VMLPainter;\n\tmodule.exports = _default;\n\n/***/ })\n/******/ ])\n});\n;\n"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 506eeb1e17483ee3fa0b","/**\r\n * Export fishTopo as CommonJS module\r\n */\r\nmodule.exports = require('./lib/fish-topo-link/lib/FishTopoLink.js');\r\n//兼容IE8 引入VML 如果不需要兼容IE8请删除\r\nrequire('zrender/lib/vml/vml');\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./index.link.js\n// module id = 1\n// module chunks = 0","/**\r\n * 流程对象\r\n * @class fish.topo.FishTopoLink\r\n */\r\n\r\n    var graphic = require(\"../../fish-topo-core/lib/graphic.js\");\r\n    var util = require(\"../../fish-topo-core/lib/util.js\");\r\n    var Point = require(\"../../fish-topo-core/lib/Point.js\");\r\n    var ExtensionAPI = require('./ExtensionApi');\r\n    var Eventful = require('zrender/lib/mixin/Eventful');\r\n    var zrender = require('zrender/lib/zrender');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var OperationNode = require(\"../../fish-topo-core/lib/manager/OperationNode.js\");\r\n    var LinkConnectionManager = require(\"./manager/LinkConnectionManager.js\");\r\n    var LinkUtil = require(\"./util/LinkUtil.js\");\r\n    var Constants = require(\"./util/LinkConstants.js\");\r\n    var Model = require(\"../../fish-topo-core/lib/model.js\");\r\n    var eventTool = require('zrender/lib/core/event');\r\n    var Connector = require(\"../../fish-topo-core/lib/shapes/Connector.js\");\r\n    var LineOperationManager = require(\"../../fish-topo-core/lib/manager/LineOperationManager.js\");\r\n    var Link = require(\"./Link.js\");\r\n    var textContain = require('zrender/lib/contain/text');\r\n    var ImagePool = require(\"../../fish-topo-core/lib/ImagePool.js\");\r\n    require(\"../../fish-topo-core/lib/polyfill.js\");\r\n    function FishTopoLink(dom, opts) {\r\n        this.id;\r\n        this.group;\r\n        this._dom = dom;\r\n        this.nowZoom = 1;\r\n        this.canScale = true;\r\n        this.eagleEye = false;\r\n        this.eagleEyeNode;\r\n        this.initScaleRatio;\r\n        this.operationNode;\r\n        this.selectedNode = null;\r\n        this.allNodes = [];\r\n        this.linkConnectionManager = new LinkConnectionManager();\r\n        this.lineOperationManager = new LineOperationManager(this.linkConnectionManager);\r\n        this.minimap;\r\n        this._layoutTimeout = null;\r\n        this._zr = zrender.init(dom, {\r\n            renderer: opts.renderer || 'canvas',\r\n            devicePixelRatio: opts.devicePixelRatio\r\n        });\r\n\r\n        this._api = new ExtensionAPI(this);\r\n        this.Shape = graphic;\r\n        this.model = new Model({});\r\n        this.model.set(Constants.ELEMENT_TYPE, \"scene\");\r\n        this.model.set(Constants.MODE, \"normal\");\r\n        this.options = opts;\r\n        Eventful.call(this);\r\n    }\r\n\r\n    var fishTopoProto = FishTopoLink.prototype;\r\n\r\n    /**\r\n     * 获取 fishTopo 实例容器的 dom 节点\r\n     * @return {HTMLElement}\r\n     */\r\n    fishTopoProto.getDom = function() {\r\n        return this._dom;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    fishTopoProto.getZr = function() {\r\n        return this._zr;\r\n    };\r\n    /**\r\n     * 获取 fishTopo 实例容器的宽度。\r\n     * @return {number}\r\n     */\r\n    fishTopoProto.getWidth = function() {\r\n        return this._zr.getWidth();\r\n    };\r\n\r\n    /**\r\n     * 获取 fishTopo 实例容器的高度。\r\n     * @return {number}\r\n     */\r\n    fishTopoProto.getHeight = function() {\r\n        return this._zr.getHeight();\r\n    };\r\n\r\n\r\n    /**\r\n     * 当前实例是否已经被释放。\r\n     * @return {boolean}\r\n     */\r\n    fishTopoProto.isDisposed = function() {\r\n        return this._disposed;\r\n    };\r\n\r\n    /**\r\n     * Dispose instance\r\n     */\r\n    fishTopoProto.dispose = function() {\r\n        this._disposed = true;\r\n\r\n        this._zr.dispose();\r\n\r\n        instances[this.id] = null;\r\n    };\r\n\r\n\r\n    /**\r\n     * 调整尺寸  在窗口大小发生改变时需要手工调用\r\n     * @param {number} width 宽度\r\n     * @param {number} height 高度\r\n     */\r\n    fishTopoProto.resize = function() {\r\n        this._zr.resize();\r\n\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 初始化\r\n     */\r\n    fishTopoProto.init = function() {\r\n        var that = this;\r\n        this.group = new graphic.Group();\r\n        this.group.isBg = true;\r\n        this._zr.add(this.group);\r\n        this.linkConnectionManager.connectors = [];\r\n        //mouseup 会在各个node或线的click事件之点执行  在选中节点或线前 先清空选中效果\r\n        this._zr.on(\"mouseup\", function(e) {\r\n            clearSelect(e);\r\n        });\r\n        that._zr.on(\"globalout\", function(e) {\r\n            clearSelect(e);\r\n        });\r\n        function clearSelect(e){\r\n            if (that.operationNode) {\r\n                that.group.remove(that.operationNode);\r\n                that.operationNode = null;\r\n            }\r\n            var shape = e.target;\r\n            if (shape && shape.model && Link.isLink(shape.model)) {\r\n                return;\r\n            }\r\n            if (shape && shape.connector instanceof Connector) {\r\n                return;\r\n            }\r\n            that.linkConnectionManager.clearSelectCon();\r\n            if (shape && shape.operation && shape.operation == true) {\r\n                return;\r\n            }\r\n            that.lineOperationManager.hideAllLineOperation();\r\n        }\r\n        this._zr.on(\"click\", function(e) {\r\n            var nodeTarget = e.target;\r\n            var shape;\r\n            if(nodeTarget){\r\n                shape = nodeTarget.model;\r\n            }\r\n            if ((nodeTarget && shape && Link.isLink(shape)) || (nodeTarget && shape && Link.isNode(shape))) {\r\n                return;\r\n            }\r\n            var params = {};\r\n            params.event = e;\r\n            params.type = \"click\";\r\n            params.target = that;\r\n            that._api.trigger(params.type, params);\r\n        });\r\n        this.on('conPointsGroup:click', function(argument) {\r\n            that.linkConnectionManager.bindOperation(argument.lineNode);\r\n        });\r\n    };\r\n\r\n    /**\r\n     * 导出json\r\n     * @return {Object} json对象\r\n     */\r\n    fishTopoProto.toJson = function() {\r\n        return LinkUtil.toJson(this.model, this.group);\r\n    };\r\n\r\n    /**\r\n     * 导入json\r\n     * @param  {Object} json对象\r\n     */\r\n    fishTopoProto.fromJson = function(json) {\r\n        this.clear();\r\n        var model = new Model(json);\r\n        this.setBackground(model.get(Constants.BACKGROUND));\r\n        var layoutRootNode = [];\r\n        LinkUtil.fromJson(this, this.group, model.get(Constants.CHILDS), false, layoutRootNode);\r\n    };\r\n\r\n    /**\r\n     * 清空当前实例，会移除实例中所有的节点与线\r\n     * @method clear\r\n     */\r\n    fishTopoProto.clear = function() {\r\n        for (var i = 0; i < this.allNodes.length; i++) {\r\n            var parentZr;\r\n            if (this.allNodes.parent) {\r\n                parentZr = this.allNodes.parent;\r\n            } else {\r\n                parentZr = this._zr;\r\n            }\r\n            this.linkConnectionManager.deleteSelectCon(this.allNodes[i], parentZr)\r\n        }\r\n        this.linkConnectionManager.connectorMap.clear();\r\n        this.allNodes = [];\r\n        this.operationNode = null;\r\n        this.selectedNode = null;\r\n        this.linkConnectionManager.connectors = [];\r\n        this._zr.clear();\r\n        this.group = new graphic.Group();\r\n        this.group.isBg = true;\r\n        this._zr.add(this.group);\r\n    };\r\n\r\n\r\n    /**\r\n     * 移除场景中的某个节点\r\n     * @param  {Object} selectedNode 待删除的节点\r\n     */\r\n    fishTopoProto.removeNode = function(selectedNode) {\r\n        var that = this;\r\n        //1.如果是子节点 内 节点  则 调用子节点的删除\r\n        if (selectedNode.parent) {\r\n            selectedNode.parent.remove(selectedNode);\r\n        } else {\r\n            that.group.remove(selectedNode);\r\n        }\r\n        //2.从allNodes数组中删除\r\n        for (var i = 0; i < that.allNodes.length; i++) {\r\n            if (selectedNode.id == that.allNodes[i].id) {\r\n                that.allNodes.splice(i, 1);\r\n            }\r\n        }\r\n        this.linkConnectionManager.deleteSelectCon(selectedNode, that.group);\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 派发delete事件\r\n     */\r\n    fishTopoProto._triggerDeleteEvent = function(target) {\r\n        var eventParams = {};\r\n        eventParams.type = \"delete\";\r\n        eventParams.target = target;\r\n        this._api.trigger(eventParams.type, eventParams);\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    fishTopoProto._createConnectorByNodes = function(startNode, endNode, lineType) {\r\n        var that = this;\r\n        var connector = this.linkConnectionManager.connectorCreate(startNode, endNode, {\r\n            style: {\r\n                lineType: lineType\r\n            }\r\n        }, this._api);\r\n        if (startNode.parent && endNode.parent) {\r\n            endNode.parent.add(connector);\r\n        } else {\r\n            this.group.add(connector);\r\n        }\r\n\r\n        connector.on(\"mousedown\", zrUtil.bind(function() {\r\n            this.linkConnectionManager.connectorForbidEdit(!this.options.linkModify);\r\n            this.isNode = false;\r\n        }, this));\r\n        connector.on(\"dblclick\", function() {\r\n            if (that.options.isAllowEdit) {\r\n                that.connectorEdit(this);\r\n            }\r\n        });\r\n\r\n        this._triggerCreateEvent(connector);\r\n        return connector;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 派发创建完成事件\r\n     */\r\n    fishTopoProto._triggerCreateEvent = function(target) {\r\n        var eventParams = {};\r\n        eventParams.type = \"create\";\r\n        eventParams.target = target;\r\n        this._api.trigger(eventParams.type, eventParams);\r\n    };\r\n    /**\r\n     * 添加节点\r\n     * @method addNode\r\n     * @param {Object} node createNode返回的对象\r\n     */\r\n    fishTopoProto.addNode = function(node) {\r\n        this.group.add(node);\r\n    };\r\n\r\n    /**\r\n     * 根据name获取节点\r\n     * @param  {String} name 在创建节点中  name属性设置的值\r\n     * @return {Object}      name对应的节点\r\n     */\r\n    fishTopoProto.childOfName = function(name) {\r\n        var arrResult = [];\r\n        var childrenNode = this.allNodes;\r\n        var childrenLine = this.linkConnectionManager.connectors;\r\n        for (var i = 0; i < childrenNode.length; i++) {\r\n            if (childrenNode[i].model.get(\"options.name\") && childrenNode[i].model.get(\"options.name\") == name) {\r\n                arrResult.push(childrenNode[i]);\r\n            } else if (childrenNode[i].model.get(\"userData.name\") == name) {\r\n                arrResult.push(childrenNode[i]);\r\n            }\r\n        }\r\n        for (var j = 0; j < childrenLine.length; j++) {\r\n            if (childrenLine[j].model.get(\"options.name\") && childrenLine[j].model.get(\"options.name\") == name) {\r\n                arrResult.push(childrenLine[j]);\r\n            } else if (childrenLine[j].model.get(\"userData.name\") == name) {\r\n                arrResult.push(childrenLine[j]);\r\n            }\r\n        }\r\n        if (arrResult.length > 1) {\r\n            return arrResult;\r\n        } else {\r\n            return arrResult[0];\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 查找场景中的对象   例如: x坐标大于100的节点 findElements(function(e){ return e.position[0] > 100; });\r\n     * @param  {Function} cb      回调函数\r\n     * @param  {Object}   context 回调函数执行的上下文\r\n     * @return {Array}           返回查找到的对象\r\n     */\r\n    fishTopoProto.findElements = function(cb, context) {\r\n        var childrenNode = this.allNodes;\r\n        var childrenLine = this.linkConnectionManager.connectors;\r\n        var arr = [];\r\n        for (var i = 0; i < childrenNode.length; i++) {\r\n            var child = childrenNode[i];\r\n            if (cb.call(context, child, i)) {\r\n                arr.push(child);\r\n            }\r\n        }\r\n        for (var j = 0; j < childrenLine.length; j++) {\r\n            var childL = childrenLine[j];\r\n            if (cb.call(context, childL, j)) {\r\n                arr.push(childL);\r\n            }\r\n        }\r\n        return arr;\r\n    };\r\n\r\n    /**\r\n     * 设置背景色  或 背景图片\r\n     * @param {string} imageUrl 背景色  或 背景图片 eg. 'img/bg.jpg'，为‘gridLine’时网格背景\r\n     */\r\n    fishTopoProto.setBackground = function(imageUrl) {\r\n        var that = this;\r\n        if (imageUrl && imageUrl.length > 0) {\r\n            this.model.set(Constants.BACKGROUND, imageUrl);\r\n            if (imageUrl.substr(0, 1) == \"#\" || imageUrl.substr(0, 4) == \"rgba\") { //如果是颜色创建rect为背景\r\n                if (!document.createElement('canvas').getContext) {\r\n                    that._dom.style.backgroundColor = imageUrl;\r\n                } else {\r\n                    var imageShape = new this.Shape.Rect({\r\n                        shape: {\r\n                            width: that._zr.getWidth(),\r\n                            height: that._zr.getHeight()\r\n                        },\r\n                        style: {\r\n                            fill: imageUrl\r\n                        },\r\n                        cursor: 'default',\r\n                        z: -1\r\n                    });\r\n                    that._zr.add(imageShape);\r\n                }\r\n\r\n            } else if(imageUrl == \"gridLine\" ){\r\n                this.gridLineGroup = new graphic.Group();\r\n                this.gridLine(0.2);\r\n                this._zr.add(this.gridLineGroup);\r\n            }else{\r\n                if (!document.createElement('canvas').getContext) {\r\n                    that._dom.style.backgroundImage = \"url(\" + imageUrl + \")\";\r\n                    that._dom.style.backgroundRepeat = \"repeat\";\r\n                } else {\r\n                    var imageShape1 = new this.Shape.Image({ //如果是图片创建image为背景\r\n                        position: [0, 0],\r\n                        scale: [1, 1],\r\n                        style: {\r\n                            x: 0,\r\n                            y: 0,\r\n                            image: imageUrl,\r\n                            width: this._zr.getWidth(),\r\n                            height: this._zr.getHeight()\r\n                        },\r\n                        cursor: 'default',\r\n                        z: -1\r\n                    });\r\n                    that._zr.add(imageShape1);\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n    };\r\n    //背景网格线\r\n    fishTopoProto.gridLine = function(opacity) {\r\n        var pixel = 10;\r\n        var widthLen = parseInt(this.getWidth() / pixel);\r\n        for (var x = 0; x <= widthLen; x++) {\r\n            var lineX = new graphic.Line({\r\n                shape: {\r\n                    x1: x * pixel,\r\n                    y1: 0,\r\n                    x2: x * pixel,\r\n                    y2: this.getHeight()\r\n                },\r\n                style: {\r\n                    lineDash: [1],\r\n                    opacity: opacity\r\n                },\r\n                z: 0,\r\n                draggable: false,\r\n                cursor: 'default'\r\n            });\r\n            this.gridLineGroup.add(lineX);\r\n        }\r\n\r\n        var heightLen = parseInt(this.getHeight() / pixel, pixel);\r\n        for (var y = 0; y <= heightLen; y++) {\r\n            var lineY = new graphic.Line({\r\n                shape: {\r\n                    x1: 0,\r\n                    y1: y * pixel,\r\n                    x2: this.getWidth(),\r\n                    y2: y * pixel\r\n                },\r\n                style: {\r\n                    lineDash: [1],\r\n                    opacity: opacity\r\n                },\r\n                z: 0,\r\n                draggable: false,\r\n                cursor: 'default'\r\n            });\r\n            this.gridLineGroup.add(lineY);\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * 根据点数组创建线段\r\n     * @method createLinkOfPoints\r\n     * @param  {Object} options 线段选项\r\n     * @param {Object} [options.style] 节点的样式\r\n     * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n     * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n     * @param {Object} [options.symbol] 线段的箭头\r\n     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n     * @param {Object} [options.text] 线段上的文字\r\n     * @param {String} [options.text.text] 线段上的文字内容\r\n     * @param {String} [options.text.color] 线段上的文字颜色\r\n     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n     * @param {String} [options.text.xOffset] 文字位置x偏移量\r\n     * @param {String} [options.pos] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n     * @param {String} [options.position] 指定线段位置\r\n     * @param {Object} [options.effect] 线上动态效果\r\n     * @param {String} [options.effect.show] 是否显示箭头动效\r\n     * @param {Number} [options.effect.period] 动效移动速度\r\n     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组\r\n     * @param {Object} userData 用户传递的业务数据\r\n     * @return {Object} 创建的线段对象\r\n     *\r\n     * **使用范例**：\r\n     *\r\n     *      @example\r\n     *      var link = me.fishTopo.createLinkOfPoints({\r\n     *              symbol: { type: 'arrow', size: 10, color: \"rgb(0,200,255)\" }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n     *              style: { lineWidth: 3, stroke: \"rgb(0,200,255)\", lineDash: [3,3], lineType: \"jagged\"  }, //样式\r\n     *              text: {\r\n     *                  text: text,\r\n     *                  color: '#ffffff',\r\n     *                  textPos:textPos,//文字位置可选值 'start','center','end',默认值为center\r\n     *                  xOffset:10, //文字位置x偏移量\r\n     *              }\r\n     *              position:{\r\n                        points:[\r\n                            {x:0,y:0},\r\n                            {x:50,y:0},\r\n                            {x:that.fishTopoLink.getWidth()-50, y:50},\r\n                            {x:that.fishTopoLink.getWidth(), y:50}\r\n                        ]  //不使用自动计算 指定连线的位置数组\r\n                    }\r\n     *          });\r\n     */\r\n    fishTopoProto.createLinkOfPoints = function(options, userData) {\r\n        var that = this;\r\n        options.isEdit = !!this.options.linkModify;\r\n        var connector = this.linkConnectionManager.connectorCreateOfPoints(options, this._api);\r\n        connector.model.set(Constants.USERDATA, zrUtil.clone(userData));\r\n        connector.on(\"dblclick\", function() {\r\n            if (typeof this.options.text.isAllowEdit == \"undefined\") {\r\n                if (that.options.isAllowEdit) {\r\n                    that.connectorEdit(this);\r\n                }\r\n            } else {\r\n                if (this.options.text.isAllowEdit) {\r\n                    that.connectorEdit(this);\r\n                }\r\n            }\r\n        });\r\n        return connector;\r\n    };\r\n\r\n\r\n    /**\r\n     * @private\r\n     * 返回当前画布的数据\r\n     */\r\n    fishTopoProto.toDataURL = function(opts) {\r\n        return LinkUtil.toDataURL(this._zr, opts);\r\n    };\r\n\r\n    zrUtil.mixin(FishTopoLink, Eventful);\r\n\r\n    // ---------对外暴露fishTopoLink------------------\r\n    var idBase = new Date() - 0;\r\n    var instances = {};\r\n    var DOM_ATTRIBUTE_KEY = '_fishTopoLink_instance_';\r\n\r\n    /**\r\n     * fishTopoLink全局对象，如果是amd方式加载，则直接返回\r\n     * @class fishTopoLink\r\n     * @singleton\r\n     */\r\n    var fishTopoLink = {\r\n        /**\r\n         * 版本号\r\n         * @type {String}\r\n         */\r\n        version: '3.0.0',\r\n        dependencies: {\r\n            zrender: '3.0.4'\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 初始化dom元素为 flow对象\r\n     * @member fishTopoLink\r\n     * @param {HTMLElement} dom  一个div元素\r\n     * @param {Object} opts  传递的选项参数\r\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg' or 'vml'\r\n     * @param {number} [opts.devicePixelRatio=1] retina 屏幕优化\r\n     * @param {number} [opts.linkModify=false] 是否允许调整线段\r\n     * @return {fish.topo.FishTopoLink}\r\n     */\r\n    fishTopoLink.init = function(dom, opts) {\r\n        if (!dom) {\r\n            throw new Error('Initialize failed: invalid dom.');\r\n        }\r\n\r\n        opts = opts || {};\r\n        // Default value\r\n        zrUtil.defaults(opts, {\r\n            type: \"flow\",\r\n            devicePixelRatio: 1,\r\n            linkModify: false,\r\n            isAllowEdit: false\r\n        });\r\n\r\n        var fishTopoLink = new FishTopoLink(dom, opts);\r\n        fishTopoLink.init();\r\n        fishTopoLink.Link = Link;\r\n        fishTopoLink.id = 'ft_' + idBase++;\r\n        instances[fishTopoLink.id] = fishTopoLink;\r\n\r\n        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoLink.id);\r\n\r\n        return fishTopoLink;\r\n    };\r\n\r\n\r\n    /**\r\n     * 获取 dom 容器上的实例。\r\n     * @member fishTopoLink\r\n     * @param  {HTMLElement} dom 一个div元素\r\n     * @return {fish.topo.FishTopoLink}\r\n     */\r\n    fishTopoLink.getInstanceByDom = function(dom) {\r\n        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\r\n        return instances[key];\r\n    };\r\n\r\n    /**\r\n     * 销毁实例，实例销毁后无法再被使用。\r\n     *\r\n     * @member fishTopoLink\r\n     * @param  {Object|string} chart fishTopoLink实例 或 fishTopoLink的id\r\n     */\r\n    fishTopoLink.dispose = function(chart) {\r\n        var topo;\r\n        if (zrUtil.isDom(chart)) {\r\n            topo = fishTopoLink.getInstanceByDom(chart);\r\n        } else if (typeof chart === 'string') {\r\n            topo = instances[chart];\r\n        }\r\n        if ((topo instanceof fishTopoLink) && !topo.isDisposed()) {\r\n            topo.dispose();\r\n        }\r\n        clearTimeout(this._layoutTimeout);\r\n    };\r\n\r\n    //暴露出去的类\r\n    fishTopoLink.util = {};\r\n    fishTopoLink.util['initImagePool'] = ImagePool.initImagePool;\r\n    zrUtil.each([\r\n            'map', 'each', 'filter', 'indexOf', 'inherits',\r\n            'reduce', 'filter', 'bind', 'curry', 'isArray',\r\n            'isString', 'isObject', 'isFunction', 'extend'\r\n        ],\r\n        function(name) {\r\n            fishTopoLink.util[name] = zrUtil[name];\r\n        }\r\n    );\r\n\r\n    module.exports = fishTopoLink;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-link/lib/FishTopoLink.js\n// module id = 2\n// module chunks = 0","'use strict';\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    var pathTool = require('zrender/lib/tool/path');\r\n    var round = Math.round;\r\n    var Path = require('zrender/lib/graphic/Path');\r\n    var colorTool = require('zrender/lib/tool/color');\r\n    var matrix = require('zrender/lib/core/matrix');\r\n    var vector = require('zrender/lib/core/vector');\r\n    var Gradient = require('zrender/lib/graphic/Gradient');\r\n    var Draggable = require('zrender/lib/mixin/Draggable');\r\n\r\n    var graphic = {};\r\n    graphic.Util = zrUtil;\r\n    graphic.Group = require('zrender/lib/container/Group');\r\n\r\n    graphic.Image = require('zrender/lib/graphic/Image');\r\n\r\n    graphic.Text = require('zrender/lib/graphic/Text');\r\n\r\n    graphic.textContain = require('zrender/lib/contain/text');\r\n\r\n    graphic.Circle = require('zrender/lib/graphic/shape/Circle');\r\n\r\n    graphic.Sector = require('zrender/lib/graphic/shape/Sector');\r\n\r\n    graphic.Ring = require('zrender/lib/graphic/shape/Ring');\r\n\r\n    graphic.Polygon = require('zrender/lib/graphic/shape/Polygon');\r\n\r\n    graphic.Polyline = require('zrender/lib/graphic/shape/Polyline');\r\n\r\n    graphic.Rect = require('zrender/lib/graphic/shape/Rect');\r\n\r\n    graphic.Line = require('zrender/lib/graphic/shape/Line');\r\n\r\n    graphic.BezierCurve = require('zrender/lib/graphic/shape/BezierCurve');\r\n\r\n    graphic.Arc = require('zrender/lib/graphic/shape/Arc');\r\n\r\n    graphic.LinearGradient = require('zrender/lib/graphic/LinearGradient');\r\n\r\n    graphic.RadialGradient = require('zrender/lib/graphic/RadialGradient');\r\n\r\n    graphic.BoundingRect = require('zrender/lib/core/BoundingRect');\r\n    graphic.States = require(\"zrender/lib/graphic/States.js\");\r\n    /**\r\n     * Extend shape with parameters\r\n     */\r\n    graphic.extendShape = function (opts) {\r\n        return Path.extend(opts);\r\n    };\r\n\r\n    /**\r\n     * Extend path\r\n     */\r\n    graphic.extendPath = function (pathData, opts) {\r\n        return pathTool.extendFromString(pathData, opts);\r\n    };\r\n\r\n    /**\r\n     * Create a path element from path data string\r\n     * @param {string} pathData\r\n     * @param {Object} opts\r\n     * @param {module:zrender/core/BoundingRect} rect\r\n     * @param {string} [layout=cover] 'center' or 'cover'\r\n     */\r\n    graphic.makePath = function (pathData, opts, rect, layout) {\r\n        var path = pathTool.createFromString(pathData, opts);\r\n        Draggable.call(path);\r\n        var boundingRect = path.getBoundingRect();\r\n        if (rect) {\r\n            var aspect = boundingRect.width / boundingRect.height;\r\n\r\n            if (layout === 'center') {\r\n                // Set rect to center, keep width / height ratio.\r\n                var width = rect.height * aspect;\r\n                var height;\r\n                if (width <= rect.width) {\r\n                    height = rect.height;\r\n                }\r\n                else {\r\n                    width = rect.width;\r\n                    height = width / aspect;\r\n                }\r\n                var cx = rect.x + rect.width / 2;\r\n                var cy = rect.y + rect.height / 2;\r\n\r\n                rect.x = cx - width / 2;\r\n                rect.y = cy - height / 2;\r\n                rect.width = width;\r\n                rect.height = height;\r\n            }\r\n\r\n            this.resizePath(path, rect);\r\n        }\r\n\r\n        zrUtil.inherits(path, Draggable);\r\n        return path;\r\n    };\r\n\r\n    graphic.mergePath = pathTool.mergePath;\r\n\r\n    /**\r\n     * Resize a path to fit the rect\r\n     * @param {module:zrender/graphic/Path} path\r\n     * @param {Object} rect\r\n     */\r\n    graphic.resizePath = function (path, rect) {\r\n        if (!path.applyTransform) {\r\n            return;\r\n        }\r\n\r\n        var pathRect = path.getBoundingRect();\r\n\r\n        var m = pathRect.calculateTransform(rect);\r\n\r\n        path.applyTransform(m);\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize line for canvas\r\n     *\r\n     * @param {Object} param\r\n     * @param {Object} [param.shape]\r\n     * @param {number} [param.shape.x1]\r\n     * @param {number} [param.shape.y1]\r\n     * @param {number} [param.shape.x2]\r\n     * @param {number} [param.shape.y2]\r\n     * @param {Object} [param.style]\r\n     * @param {number} [param.style.lineWidth]\r\n     * @return {Object} Modified param\r\n     */\r\n    graphic.subPixelOptimizeLine = function (param) {\r\n        var subPixelOptimize = graphic.subPixelOptimize;\r\n        var shape = param.shape;\r\n        var lineWidth = param.style.lineWidth;\r\n\r\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\r\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\r\n        }\r\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\r\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\r\n        }\r\n        return param;\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize rect for canvas\r\n     *\r\n     * @param {Object} param\r\n     * @param {Object} [param.shape]\r\n     * @param {number} [param.shape.x]\r\n     * @param {number} [param.shape.y]\r\n     * @param {number} [param.shape.width]\r\n     * @param {number} [param.shape.height]\r\n     * @param {Object} [param.style]\r\n     * @param {number} [param.style.lineWidth]\r\n     * @return {Object} Modified param\r\n     */\r\n    graphic.subPixelOptimizeRect = function (param) {\r\n        var subPixelOptimize = graphic.subPixelOptimize;\r\n        var shape = param.shape;\r\n        var lineWidth = param.style.lineWidth;\r\n        var originX = shape.x;\r\n        var originY = shape.y;\r\n        var originWidth = shape.width;\r\n        var originHeight = shape.height;\r\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\r\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\r\n        shape.width = Math.max(\r\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\r\n            originWidth === 0 ? 0 : 1\r\n        );\r\n        shape.height = Math.max(\r\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\r\n            originHeight === 0 ? 0 : 1\r\n        );\r\n        return param;\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize for canvas\r\n     *\r\n     * @param {number} position Coordinate, such as x, y\r\n     * @param {number} lineWidth Should be nonnegative integer.\r\n     * @param {boolean=} positiveOrNegative Default false (negative).\r\n     * @return {number} Optimized position.\r\n     */\r\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\r\n        // Assure that (position + lineWidth / 2) is near integer edge,\r\n        // otherwise line will be fuzzy in canvas.\r\n        var doubledPosition = round(position * 2);\r\n        return (doubledPosition + round(lineWidth)) % 2 === 0\r\n            ? doubledPosition / 2\r\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    function doSingleEnterHover(el) {\r\n        if (el.__isHover) {\r\n            return;\r\n        }\r\n        if (el.__hoverStlDirty) {\r\n            var stroke = el.style.stroke;\r\n            var fill = el.style.fill;\r\n\r\n            // Create hoverStyle on mouseover\r\n            var hoverStyle = el.__hoverStl;\r\n            var lift = colorTool.lift;\r\n            hoverStyle.fill = hoverStyle.fill\r\n                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));\r\n            hoverStyle.stroke = hoverStyle.stroke\r\n                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));\r\n\r\n            var normalStyle = {};\r\n            for (var name in hoverStyle) {\r\n                if (hoverStyle.hasOwnProperty(name)) {\r\n                    normalStyle[name] = el.style[name];\r\n                }\r\n            }\r\n\r\n            el.__normalStl = normalStyle;\r\n\r\n            el.__hoverStlDirty = false;\r\n        }\r\n        el.setStyle(el.__hoverStl);\r\n        el.z2 += 1;\r\n\r\n        el.__isHover = true;\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function doSingleLeaveHover(el) {\r\n        if (!el.__isHover) {\r\n            return;\r\n        }\r\n\r\n        var normalStl = el.__normalStl;\r\n        normalStl && el.setStyle(normalStl);\r\n        el.z2 -= 1;\r\n\r\n        el.__isHover = false;\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function doEnterHover(el) {\r\n        (el.type === 'group' || el.type === 'GroupNode')\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    doSingleEnterHover(child);\r\n                }\r\n            })\r\n            : doSingleEnterHover(el);\r\n    }\r\n    graphic.doEnterHover = doEnterHover;\r\n    function doLeaveHover(el) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    doSingleLeaveHover(child);\r\n                }\r\n            })\r\n            : doSingleLeaveHover(el);\r\n    }\r\n    graphic.doLeaveHover = doLeaveHover;\r\n    /**\r\n     * @inner\r\n     */\r\n    function setElementHoverStl(el, hoverStl) {\r\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\r\n        // Often used when item group has a label element and it's hoverStyle is different\r\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\r\n        el.__hoverStlDirty = true;\r\n    }\r\n    graphic.setElementHoverStl = setElementHoverStl;\r\n    /**\r\n     * @inner\r\n     */\r\n    function onElementMouseOver() {\r\n        // Only if element is not in emphasis status\r\n        !this.__isEmphasis && doEnterHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function onElementMouseOut() {\r\n        // Only if element is not in emphasis status\r\n        !this.__isEmphasis && doLeaveHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function enterEmphasis() {\r\n        this.__isEmphasis = true;\r\n        doEnterHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function leaveEmphasis() {\r\n        this.__isEmphasis = false;\r\n        doLeaveHover(this);\r\n    }\r\n\r\n    /**\r\n     * Set hover style of element\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} [hoverStyle]\r\n     */\r\n    graphic.setHoverStyle = function (el, hoverStyle) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    setElementHoverStl(child, hoverStyle);\r\n                }\r\n            })\r\n            : setElementHoverStl(el, hoverStyle);\r\n        // Remove previous bound handlers\r\n        el.on('mouseover', onElementMouseOver)\r\n          .on('mouseout', onElementMouseOut);\r\n\r\n        // Emphasis, normal can be triggered manually\r\n        el.on('emphasis', enterEmphasis)\r\n          .on('normal', leaveEmphasis);\r\n    };\r\n\r\n    graphic.setNormalStyle = function(el, options) {\r\n        if (el.__normalStl) {\r\n            for (var name in options) {\r\n                if (el.__normalStl.hasOwnProperty(name)) {\r\n                    el.__normalStl[name] = options[name];\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Set text option in the style\r\n     * @param {Object} textStyle\r\n     * @param {module:echarts/model/Model} labelModel\r\n     * @param {string} color\r\n     */\r\n    graphic.setText = function (textStyle, labelModel, color) {\r\n        var labelPosition = labelModel.getShallow('position') || 'inside';\r\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\r\n        var textStyleModel = labelModel.getModel('textStyle');\r\n        zrUtil.extend(textStyle, {\r\n            textDistance: labelModel.getShallow('distance') || 5,\r\n            textFont: textStyleModel.getFont(),\r\n            textPosition: labelPosition,\r\n            textFill: textStyleModel.getTextColor() || labelColor\r\n        });\r\n    };\r\n\r\n    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {\r\n        var postfix = isUpdate ? 'Update' : '';\r\n        var duration = animatableModel\r\n            && animatableModel.getShallow('animationDuration' + postfix);\r\n        var animationEasing = animatableModel\r\n            && animatableModel.getShallow('animationEasing' + postfix);\r\n\r\n        animatableModel && animatableModel.getShallow('animation')\r\n            ? el.animateTo(props, duration, animationEasing, cb)\r\n            : (el.attr(props), cb && cb());\r\n    }\r\n    /**\r\n     * Update graphic element properties with or without animation according to the configuration in series\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} props\r\n     * @param {module:echarts/model/Model} [animatableModel]\r\n     * @param {Function} cb\r\n     */\r\n    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);\r\n\r\n    /**\r\n     * Init graphic element properties with or without animation according to the configuration in series\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} props\r\n     * @param {module:echarts/model/Model} [animatableModel]\r\n     * @param {Function} cb\r\n     */\r\n    graphic.initProps = zrUtil.curry(animateOrSetProps, false);\r\n\r\n    /**\r\n     * Get transform matrix of target (param target),\r\n     * in coordinate of its ancestor (param ancestor)\r\n     *\r\n     * @param {module:zrender/mixin/Transformable} target\r\n     * @param {module:zrender/mixin/Transformable} ancestor\r\n     */\r\n    graphic.getTransform = function (target, ancestor) {\r\n        var mat = matrix.identity([]);\r\n\r\n        while (target && target !== ancestor) {\r\n            matrix.mul(mat, target.getLocalTransform(), mat);\r\n            target = target.parent;\r\n        }\r\n\r\n        return mat;\r\n    };\r\n\r\n    /**\r\n     * Apply transform to an vertex.\r\n     * @param {Array.<number>} vertex [x, y]\r\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n     * @param {boolean=} invert Whether use invert matrix.\r\n     * @return {Array.<number>} [x, y]\r\n     */\r\n    graphic.applyTransform = function (vertex, transform, invert) {\r\n        if (invert) {\r\n            transform = matrix.invert([], transform);\r\n        }\r\n        return vector.applyTransform([], vertex, transform);\r\n    };\r\n\r\n    /**\r\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\r\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n     * @param {boolean=} invert Whether use invert matrix.\r\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\r\n     */\r\n    graphic.transformDirection = function (direction, transform, invert) {\r\n\r\n        // Pick a base, ensure that transform result will not be (0, 0).\r\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\r\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\r\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\r\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\r\n\r\n        var vertex = [\r\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\r\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\r\n        ];\r\n\r\n        vertex = graphic.applyTransform(vertex, transform, invert);\r\n\r\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\r\n            ? (vertex[0] > 0 ? 'right' : 'left')\r\n            : (vertex[1] > 0 ? 'bottom' : 'top');\r\n    };\r\n\r\n    module.exports = graphic;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/graphic.js\n// module id = 3\n// module chunks = 0","/**\n * @module zrender/core/util\n */\n// 用于处理merge时无法遍历Date等对象的问题\nvar BUILTIN_OBJECT = {\n  '[object Function]': 1,\n  '[object RegExp]': 1,\n  '[object Date]': 1,\n  '[object Error]': 1,\n  '[object CanvasGradient]': 1,\n  '[object CanvasPattern]': 1,\n  // For node-canvas\n  '[object Image]': 1,\n  '[object Canvas]': 1\n};\nvar TYPED_ARRAY = {\n  '[object Int8Array]': 1,\n  '[object Uint8Array]': 1,\n  '[object Uint8ClampedArray]': 1,\n  '[object Int16Array]': 1,\n  '[object Uint16Array]': 1,\n  '[object Int32Array]': 1,\n  '[object Uint32Array]': 1,\n  '[object Float32Array]': 1,\n  '[object Float64Array]': 1\n};\nvar objToString = Object.prototype.toString;\nvar arrayProto = Array.prototype;\nvar nativeForEach = arrayProto.forEach;\nvar nativeFilter = arrayProto.filter;\nvar nativeSlice = arrayProto.slice;\nvar nativeMap = arrayProto.map;\nvar nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * Those data types can be cloned:\n *     Plain object, Array, TypedArray, number, string, null, undefined.\n * Those data types will be assgined using the orginal data:\n *     BUILTIN_OBJECT\n * Instance of user defined class will be cloned to a plain object, without\n * properties in prototype.\n * Other data types is not supported (not sure what will happen).\n *\n * Caution: do not support clone Date, for performance consideration.\n * (There might be a large number of date in `series.data`).\n * So date should not be modified in and out of echarts.\n *\n * @param {*} source\n * @return {*} new\n */\n\n\nfunction clone(source) {\n  if (source == null || typeof source != 'object') {\n    return source;\n  }\n\n  var result = source;\n  var typeStr = objToString.call(source);\n\n  if (typeStr === '[object Array]') {\n    result = [];\n\n    for (var i = 0, len = source.length; i < len; i++) {\n      result[i] = clone(source[i]);\n    }\n  } else if (TYPED_ARRAY[typeStr]) {\n    var Ctor = source.constructor;\n\n    if (source.constructor.from) {\n      result = Ctor.from(source);\n    } else {\n      result = new Ctor(source.length);\n\n      for (var i = 0, len = source.length; i < len; i++) {\n        result[i] = clone(source[i]);\n      }\n    }\n  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n    result = {};\n\n    for (var key in source) {\n      if (source.hasOwnProperty(key)) {\n        result[key] = clone(source[key]);\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} target\n * @param {*} source\n * @param {boolean} [overwrite=false]\n */\n\n\nfunction merge(target, source, overwrite) {\n  // We should escapse that source is string\n  // and enter for ... in ...\n  if (!isObject(source) || !isObject(target)) {\n    return overwrite ? clone(source) : target;\n  }\n\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      var targetProp = target[key];\n      var sourceProp = source[key];\n\n      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {\n        // 如果需要递归覆盖，就递归调用merge\n        merge(targetProp, sourceProp, overwrite);\n      } else if (overwrite || !(key in target)) {\n        // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n        // NOTE，在 target[key] 不存在的时候也是直接覆盖\n        target[key] = clone(source[key], true);\n      }\n    }\n  }\n\n  return target;\n}\n/**\n * @param {Array} targetAndSources The first item is target, and the rests are source.\n * @param {boolean} [overwrite=false]\n * @return {*} target\n */\n\n\nfunction mergeAll(targetAndSources, overwrite) {\n  var result = targetAndSources[0];\n\n  for (var i = 1, len = targetAndSources.length; i < len; i++) {\n    result = merge(result, targetAndSources[i], overwrite);\n  }\n\n  return result;\n}\n/**\n * @param {*} target\n * @param {*} source\n * @memberOf module:zrender/core/util\n */\n\n\nfunction extend(target, source) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n/**\n * @param {*} target\n * @param {*} source\n * @param {boolean} [overlay=false]\n * @memberOf module:zrender/core/util\n */\n\n\nfunction defaults(target, source, overlay) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nvar createCanvas = function () {\n  return methods.createCanvas();\n};\n\nmethods.createCanvas = function () {\n  return document.createElement('canvas');\n}; // FIXME\n\n\nvar _ctx;\n\nfunction getContext() {\n  if (!_ctx) {\n    // Use util.createCanvas instead of createCanvas\n    // because createCanvas may be overwritten in different environment\n    _ctx = createCanvas().getContext('2d');\n  }\n\n  return _ctx;\n}\n/**\n * 查询数组中元素的index\n * @memberOf module:zrender/core/util\n */\n\n\nfunction indexOf(array, value) {\n  if (array) {\n    if (array.indexOf) {\n      return array.indexOf(value);\n    }\n\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (array[i] === value) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n}\n/**\n * 构造类继承关系\n *\n * @memberOf module:zrender/core/util\n * @param {Function} clazz 源类\n * @param {Function} baseClazz 基类\n */\n\n\nfunction inherits(clazz, baseClazz) {\n  var clazzPrototype = clazz.prototype;\n\n  function F() {}\n\n  F.prototype = baseClazz.prototype;\n  clazz.prototype = new F();\n\n  for (var prop in clazzPrototype) {\n    clazz.prototype[prop] = clazzPrototype[prop];\n  }\n\n  clazz.prototype.constructor = clazz;\n  clazz.superClass = baseClazz;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Object|Function} target\n * @param {Object|Function} sorce\n * @param {boolean} overlay\n */\n\n\nfunction mixin(target, source, overlay) {\n  target = 'prototype' in target ? target.prototype : target;\n  source = 'prototype' in source ? source.prototype : source;\n  defaults(target, source, overlay);\n}\n/**\n * Consider typed array.\n * @param {Array|TypedArray} data\n */\n\n\nfunction isArrayLike(data) {\n  if (!data) {\n    return;\n  }\n\n  if (typeof data == 'string') {\n    return false;\n  }\n\n  return typeof data.length == 'number';\n}\n/**\n * 数组或对象遍历\n * @memberOf module:zrender/core/util\n * @param {Object|Array} obj\n * @param {Function} cb\n * @param {*} [context]\n */\n\n\nfunction each(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.forEach && obj.forEach === nativeForEach) {\n    obj.forEach(cb, context);\n  } else if (obj.length === +obj.length) {\n    for (var i = 0, len = obj.length; i < len; i++) {\n      cb.call(context, obj[i], i, obj);\n    }\n  } else {\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        cb.call(context, obj[key], key, obj);\n      }\n    }\n  }\n}\n/**\n * 数组映射\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction map(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.map && obj.map === nativeMap) {\n    return obj.map(cb, context);\n  } else {\n    var result = [];\n\n    for (var i = 0, len = obj.length; i < len; i++) {\n      result.push(cb.call(context, obj[i], i, obj));\n    }\n\n    return result;\n  }\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {Object} [memo]\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction reduce(obj, cb, memo, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.reduce && obj.reduce === nativeReduce) {\n    return obj.reduce(cb, memo, context);\n  } else {\n    for (var i = 0, len = obj.length; i < len; i++) {\n      memo = cb.call(context, memo, obj[i], i, obj);\n    }\n\n    return memo;\n  }\n}\n/**\n * 数组过滤\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction filter(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.filter && obj.filter === nativeFilter) {\n    return obj.filter(cb, context);\n  } else {\n    var result = [];\n\n    for (var i = 0, len = obj.length; i < len; i++) {\n      if (cb.call(context, obj[i], i, obj)) {\n        result.push(obj[i]);\n      }\n    }\n\n    return result;\n  }\n}\n/**\n * 数组项查找\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {*}\n */\n\n\nfunction find(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  for (var i = 0, len = obj.length; i < len; i++) {\n    if (cb.call(context, obj[i], i, obj)) {\n      return obj[i];\n    }\n  }\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Function} func\n * @param {*} context\n * @return {Function}\n */\n\n\nfunction bind(func, context) {\n  var args = nativeSlice.call(arguments, 2);\n  return function () {\n    return func.apply(context, args.concat(nativeSlice.call(arguments)));\n  };\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Function} func\n * @return {Function}\n */\n\n\nfunction curry(func) {\n  var args = nativeSlice.call(arguments, 1);\n  return function () {\n    return func.apply(this, args.concat(nativeSlice.call(arguments)));\n  };\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isArray(value) {\n  return objToString.call(value) === '[object Array]';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isString(value) {\n  return objToString.call(value) === '[object String]';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return type === 'function' || !!value && type == 'object';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isBuiltInObject(value) {\n  return !!BUILTIN_OBJECT[objToString.call(value)];\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isDom(value) {\n  return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';\n}\n/**\n * Whether is exactly NaN. Notice isNaN('a') returns true.\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction eqNaN(value) {\n  return value !== value;\n}\n/**\n * If value1 is not null, then return value1, otherwise judget rest of values.\n * Low performance.\n * @memberOf module:zrender/core/util\n * @return {*} Final value\n */\n\n\nfunction retrieve(values) {\n  for (var i = 0, len = arguments.length; i < len; i++) {\n    if (arguments[i] != null) {\n      return arguments[i];\n    }\n  }\n}\n\nfunction retrieve2(value0, value1) {\n  return value0 != null ? value0 : value1;\n}\n\nfunction retrieve3(value0, value1, value2) {\n  return value0 != null ? value0 : value1 != null ? value1 : value2;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Array} arr\n * @param {number} startIndex\n * @param {number} endIndex\n * @return {Array}\n */\n\n\nfunction slice() {\n  return Function.call.apply(nativeSlice, arguments);\n}\n/**\n * Normalize css liked array configuration\n * e.g.\n *  3 => [3, 3, 3, 3]\n *  [4, 2] => [4, 2, 4, 2]\n *  [4, 3, 2] => [4, 3, 2, 3]\n * @param {number|Array.<number>} val\n * @return {Array.<number>}\n */\n\n\nfunction normalizeCssArray(val) {\n  if (typeof val === 'number') {\n    return [val, val, val, val];\n  }\n\n  var len = val.length;\n\n  if (len === 2) {\n    // vertical | horizontal\n    return [val[0], val[1], val[0], val[1]];\n  } else if (len === 3) {\n    // top | horizontal | bottom\n    return [val[0], val[1], val[2], val[1]];\n  }\n\n  return val;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {boolean} condition\n * @param {string} message\n */\n\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nvar primitiveKey = '__ec_primitive__';\n/**\n * Set an object as primitive to be ignored traversing children in clone or merge\n */\n\nfunction setAsPrimitive(obj) {\n  obj[primitiveKey] = true;\n}\n\nfunction isPrimitive(obj) {\n  return obj[primitiveKey];\n}\n/**\n * @constructor\n * @param {Object} obj Only apply `ownProperty`.\n */\n\n\nfunction HashMap(obj) {\n  obj && each(obj, function (value, key) {\n    this.set(key, value);\n  }, this);\n} // Add prefix to avoid conflict with Object.prototype.\n\n\nvar HASH_MAP_PREFIX = '_ec_';\nvar HASH_MAP_PREFIX_LENGTH = 4;\nHashMap.prototype = {\n  constructor: HashMap,\n  // Do not provide `has` method to avoid defining what is `has`.\n  // (We usually treat `null` and `undefined` as the same, different\n  // from ES6 Map).\n  get: function (key) {\n    return this[HASH_MAP_PREFIX + key];\n  },\n  set: function (key, value) {\n    this[HASH_MAP_PREFIX + key] = value; // Comparing with invocation chaining, `return value` is more commonly\n    // used in this case: `var someVal = map.set('a', genVal());`\n\n    return value;\n  },\n  // Although util.each can be performed on this hashMap directly, user\n  // should not use the exposed keys, who are prefixed.\n  each: function (cb, context) {\n    context !== void 0 && (cb = bind(cb, context));\n\n    for (var prefixedKey in this) {\n      this.hasOwnProperty(prefixedKey) && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n    }\n  },\n  // Do not use this method if performance sensitive.\n  removeKey: function (key) {\n    delete this[HASH_MAP_PREFIX + key];\n  }\n};\n\nfunction createHashMap(obj) {\n  return new HashMap(obj);\n}\n\nfunction noop() {}\n\nexports.$override = $override;\nexports.clone = clone;\nexports.merge = merge;\nexports.mergeAll = mergeAll;\nexports.extend = extend;\nexports.defaults = defaults;\nexports.createCanvas = createCanvas;\nexports.getContext = getContext;\nexports.indexOf = indexOf;\nexports.inherits = inherits;\nexports.mixin = mixin;\nexports.isArrayLike = isArrayLike;\nexports.each = each;\nexports.map = map;\nexports.reduce = reduce;\nexports.filter = filter;\nexports.find = find;\nexports.bind = bind;\nexports.curry = curry;\nexports.isArray = isArray;\nexports.isFunction = isFunction;\nexports.isString = isString;\nexports.isObject = isObject;\nexports.isBuiltInObject = isBuiltInObject;\nexports.isDom = isDom;\nexports.eqNaN = eqNaN;\nexports.retrieve = retrieve;\nexports.retrieve2 = retrieve2;\nexports.retrieve3 = retrieve3;\nexports.slice = slice;\nexports.normalizeCssArray = normalizeCssArray;\nexports.assert = assert;\nexports.setAsPrimitive = setAsPrimitive;\nexports.isPrimitive = isPrimitive;\nexports.createHashMap = createHashMap;\nexports.noop = noop;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/util.js\n// module id = 4\n// module chunks = 0","var Path = require(\"../graphic/Path\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar transformPath = require(\"./transformPath\");\n\n// command chars\nvar cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];\nvar mathSqrt = Math.sqrt;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI = Math.PI;\n\nvar vMag = function (v) {\n  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n};\n\nvar vRatio = function (u, v) {\n  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n};\n\nvar vAngle = function (u, v) {\n  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n};\n\nfunction processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n  var psi = psiDeg * (PI / 180.0);\n  var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;\n  var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;\n  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n\n  if (lambda > 1) {\n    rx *= mathSqrt(lambda);\n    ry *= mathSqrt(lambda);\n  }\n\n  var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;\n  var cxp = f * rx * yp / ry;\n  var cyp = f * -ry * xp / rx;\n  var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;\n  var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;\n  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);\n  var u = [(xp - cxp) / rx, (yp - cyp) / ry];\n  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\n  var dTheta = vAngle(u, v);\n\n  if (vRatio(u, v) <= -1) {\n    dTheta = PI;\n  }\n\n  if (vRatio(u, v) >= 1) {\n    dTheta = 0;\n  }\n\n  if (fs === 0 && dTheta > 0) {\n    dTheta = dTheta - 2 * PI;\n  }\n\n  if (fs === 1 && dTheta < 0) {\n    dTheta = dTheta + 2 * PI;\n  }\n\n  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n}\n\nfunction createPathProxyFromString(data) {\n  if (!data) {\n    return [];\n  } // command string\n\n\n  var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');\n  var n; // create pipes so that we can split the data\n\n  for (n = 0; n < cc.length; n++) {\n    cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n  } // create array\n\n\n  var arr = cs.split('|'); // init context point\n\n  var cpx = 0;\n  var cpy = 0;\n  var path = new PathProxy();\n  var CMD = PathProxy.CMD;\n  var prevCmd;\n\n  for (n = 1; n < arr.length; n++) {\n    var str = arr[n];\n    var c = str.charAt(0);\n    var off = 0;\n    var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n    var cmd;\n\n    if (p.length > 0 && p[0] === '') {\n      p.shift();\n    }\n\n    for (var i = 0; i < p.length; i++) {\n      p[i] = parseFloat(p[i]);\n    }\n\n    while (off < p.length && !isNaN(p[off])) {\n      if (isNaN(p[0])) {\n        break;\n      }\n\n      var ctlPtx;\n      var ctlPty;\n      var rx;\n      var ry;\n      var psi;\n      var fa;\n      var fs;\n      var x1 = cpx;\n      var y1 = cpy; // convert l, H, h, V, and v to L\n\n      switch (c) {\n        case 'l':\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'L':\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'm':\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.M;\n          path.addData(cmd, cpx, cpy);\n          c = 'l';\n          break;\n\n        case 'M':\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.M;\n          path.addData(cmd, cpx, cpy);\n          c = 'L';\n          break;\n\n        case 'h':\n          cpx += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'H':\n          cpx = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'v':\n          cpy += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'V':\n          cpy = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'C':\n          cmd = CMD.C;\n          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);\n          cpx = p[off - 2];\n          cpy = p[off - 1];\n          break;\n\n        case 'c':\n          cmd = CMD.C;\n          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);\n          cpx += p[off - 2];\n          cpy += p[off - 1];\n          break;\n\n        case 'S':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.C) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cmd = CMD.C;\n          x1 = p[off++];\n          y1 = p[off++];\n          cpx = p[off++];\n          cpy = p[off++];\n          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n          break;\n\n        case 's':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.C) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cmd = CMD.C;\n          x1 = cpx + p[off++];\n          y1 = cpy + p[off++];\n          cpx += p[off++];\n          cpy += p[off++];\n          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n          break;\n\n        case 'Q':\n          x1 = p[off++];\n          y1 = p[off++];\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, x1, y1, cpx, cpy);\n          break;\n\n        case 'q':\n          x1 = p[off++] + cpx;\n          y1 = p[off++] + cpy;\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, x1, y1, cpx, cpy);\n          break;\n\n        case 'T':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.Q) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n          break;\n\n        case 't':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.Q) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n          break;\n\n        case 'A':\n          rx = p[off++];\n          ry = p[off++];\n          psi = p[off++];\n          fa = p[off++];\n          fs = p[off++];\n          x1 = cpx, y1 = cpy;\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.A;\n          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n          break;\n\n        case 'a':\n          rx = p[off++];\n          ry = p[off++];\n          psi = p[off++];\n          fa = p[off++];\n          fs = p[off++];\n          x1 = cpx, y1 = cpy;\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.A;\n          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n          break;\n      }\n    }\n\n    if (c === 'z' || c === 'Z') {\n      cmd = CMD.Z;\n      path.addData(cmd);\n    }\n\n    prevCmd = cmd;\n  }\n\n  path.toStatic();\n  return path;\n} // TODO Optimize double memory cost problem\n\n\nfunction createPathOptions(str, opts) {\n  var pathProxy = createPathProxyFromString(str);\n  opts = opts || {};\n\n  opts.buildPath = function (path) {\n    if (path.setData) {\n      path.setData(pathProxy.data); // Svg and vml renderer don't have context\n\n      var ctx = path.getContext();\n\n      if (ctx) {\n        path.rebuildPath(ctx);\n      }\n    } else {\n      var ctx = path;\n      pathProxy.rebuildPath(ctx);\n    }\n  };\n\n  opts.applyTransform = function (m) {\n    transformPath(pathProxy, m);\n    this.dirty(true);\n  };\n\n  return opts;\n}\n/**\n * Create a Path object from path string data\n * http://www.w3.org/TR/SVG/paths.html#PathData\n * @param  {Object} opts Other options\n */\n\n\nfunction createFromString(str, opts) {\n  return new Path(createPathOptions(str, opts));\n}\n/**\n * Create a Path class from path string data\n * @param  {string} str\n * @param  {Object} opts Other options\n */\n\n\nfunction extendFromString(str, opts) {\n  return Path.extend(createPathOptions(str, opts));\n}\n/**\n * Merge multiple paths\n */\n// TODO Apply transform\n// TODO stroke dash\n// TODO Optimize double memory cost problem\n\n\nfunction mergePath(pathEls, opts) {\n  var pathList = [];\n  var len = pathEls.length;\n\n  for (var i = 0; i < len; i++) {\n    var pathEl = pathEls[i];\n\n    if (!pathEl.path) {\n      pathEl.createPathProxy();\n    }\n\n    if (pathEl.__dirtyPath) {\n      pathEl.buildPath(pathEl.path, pathEl.shape, true);\n    }\n\n    pathList.push(pathEl.path);\n  }\n\n  var pathBundle = new Path(opts); // Need path proxy.\n\n  pathBundle.createPathProxy();\n\n  pathBundle.buildPath = function (path) {\n    path.appendPath(pathList); // Svg and vml renderer don't have context\n\n    var ctx = path.getContext();\n\n    if (ctx) {\n      path.rebuildPath(ctx);\n    }\n  };\n\n  return pathBundle;\n}\n\nexports.createFromString = createFromString;\nexports.extendFromString = extendFromString;\nexports.mergePath = mergePath;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/path.js\n// module id = 5\n// module chunks = 0","var Displayable = require(\"./Displayable\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar pathContain = require(\"../contain/path\");\n\nvar Pattern = require(\"./Pattern\");\n\nvar getCanvasPattern = Pattern.prototype.getCanvasPattern;\nvar abs = Math.abs;\nvar pathProxyForDraw = new PathProxy(true);\n/**\n * @alias module:zrender/graphic/Path\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\n\nfunction Path(opts) {\n  Displayable.call(this, opts);\n  /**\n   * @type {module:zrender/core/PathProxy}\n   * @readOnly\n   */\n\n  this.path = null;\n}\n\nPath.prototype = {\n  constructor: Path,\n  type: 'path',\n  __dirtyPath: true,\n  strokeContainThreshold: 5,\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var path = this.path || pathProxyForDraw;\n    var hasStroke = style.hasStroke();\n    var hasFill = style.hasFill();\n    var fill = style.fill;\n    var stroke = style.stroke;\n    var hasFillGradient = hasFill && !!fill.colorStops;\n    var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n    var hasFillPattern = hasFill && !!fill.image;\n    var hasStrokePattern = hasStroke && !!stroke.image;\n    style.bind(ctx, this, prevEl);\n    this.setTransform(ctx);\n\n    if (this.__dirty) {\n      var rect; // Update gradient because bounding rect may changed\n\n      if (hasFillGradient) {\n        rect = rect || this.getBoundingRect();\n        this._fillGradient = style.getGradient(ctx, fill, rect);\n      }\n\n      if (hasStrokeGradient) {\n        rect = rect || this.getBoundingRect();\n        this._strokeGradient = style.getGradient(ctx, stroke, rect);\n      }\n    } // Use the gradient or pattern\n\n\n    if (hasFillGradient) {\n      // PENDING If may have affect the state\n      ctx.fillStyle = this._fillGradient;\n    } else if (hasFillPattern) {\n      ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n    }\n\n    if (hasStrokeGradient) {\n      ctx.strokeStyle = this._strokeGradient;\n    } else if (hasStrokePattern) {\n      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n    }\n\n    var lineDash = style.lineDash;\n    var lineDashOffset = style.lineDashOffset;\n    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy\n\n    var scale = this.getGlobalScale();\n    path.setScale(scale[0], scale[1]); // Proxy context\n    // Rebuild path in following 2 cases\n    // 1. Path is dirty\n    // 2. Path needs javascript implemented lineDash stroking.\n    //    In this case, lineDash information will not be saved in PathProxy\n\n    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n      path.beginPath(ctx); // Setting line dash before build path\n\n      if (lineDash && !ctxLineDash) {\n        path.setLineDash(lineDash);\n        path.setLineDashOffset(lineDashOffset);\n      }\n\n      this.buildPath(path, this.shape, false); // Clear path dirty flag\n\n      if (this.path) {\n        this.__dirtyPath = false;\n      }\n    } else {\n      // Replay path building\n      ctx.beginPath();\n      this.path.rebuildPath(ctx);\n    }\n\n    hasFill && path.fill(ctx);\n\n    if (lineDash && ctxLineDash) {\n      ctx.setLineDash(lineDash);\n      ctx.lineDashOffset = lineDashOffset;\n    }\n\n    hasStroke && path.stroke(ctx);\n\n    if (lineDash && ctxLineDash) {\n      // PENDING\n      // Remove lineDash\n      ctx.setLineDash([]);\n    }\n\n    this.restoreTransform(ctx); // Draw rect text\n\n    if (style.text != null) {\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n  // Like in circle\n  buildPath: function (ctx, shapeCfg, inBundle) {},\n  createPathProxy: function () {\n    this.path = new PathProxy();\n  },\n  getBoundingRect: function () {\n    var rect = this._rect;\n    var style = this.style;\n    var needsUpdateRect = !rect;\n\n    if (needsUpdateRect) {\n      var path = this.path;\n\n      if (!path) {\n        // Create path on demand.\n        path = this.path = new PathProxy();\n      }\n\n      if (this.__dirtyPath) {\n        path.beginPath();\n        this.buildPath(path, this.shape, false);\n      }\n\n      rect = path.getBoundingRect();\n    }\n\n    this._rect = rect;\n\n    if (style.hasStroke()) {\n      // Needs update rect with stroke lineWidth when\n      // 1. Element changes scale or lineWidth\n      // 2. Shape is changed\n      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\n      if (this.__dirty || needsUpdateRect) {\n        rectWithStroke.copy(rect); // FIXME Must after updateTransform\n\n        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical\n\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill\n\n        if (!style.hasFill()) {\n          w = Math.max(w, this.strokeContainThreshold || 4);\n        } // Consider line width\n        // Line scale can't be 0;\n\n\n        if (lineScale > 1e-10) {\n          rectWithStroke.width += w / lineScale;\n          rectWithStroke.height += w / lineScale;\n          rectWithStroke.x -= w / lineScale / 2;\n          rectWithStroke.y -= w / lineScale / 2;\n        }\n      } // Return rect with stroke\n\n\n      return rectWithStroke;\n    }\n\n    return rect;\n  },\n  contain: function (x, y) {\n    var localPos = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    var style = this.style;\n    x = localPos[0];\n    y = localPos[1];\n\n    if (rect.contain(x, y)) {\n      var pathData = this.path.data;\n\n      if (style.hasStroke()) {\n        var lineWidth = style.lineWidth;\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;\n\n        if (lineScale > 1e-10) {\n          // Only add extra hover lineWidth when there are no fill\n          if (!style.hasFill()) {\n            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n          }\n\n          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n            return true;\n          }\n        }\n      }\n\n      if (style.hasFill()) {\n        return pathContain.contain(pathData, x, y);\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * @param  {boolean} dirtyPath\n   */\n  dirty: function (dirtyPath) {\n    if (dirtyPath == null) {\n      dirtyPath = true;\n    } // Only mark dirty, not mark clean\n\n\n    if (dirtyPath) {\n      this.__dirtyPath = dirtyPath;\n      this._rect = null;\n    }\n\n    this.__dirty = true;\n    this.__zr && this.__zr.refresh(); // Used as a clipping path\n\n    if (this.__clipTarget) {\n      this.__clipTarget.dirty();\n    }\n  },\n\n  /**\n   * Alias for animate('shape')\n   * @param {boolean} loop\n   */\n  animateShape: function (loop) {\n    return this.animate('shape', loop);\n  },\n  // Overwrite attrKV\n  attrKV: function (key, value) {\n    // FIXME\n    if (key === 'shape') {\n      this.setShape(value);\n      this.__dirtyPath = true;\n      this._rect = null;\n    } else {\n      Displayable.prototype.attrKV.call(this, key, value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setShape: function (key, value) {\n    var shape = this.shape; // Path from string may not have shape\n\n    if (shape) {\n      if (zrUtil.isObject(key)) {\n        for (var name in key) {\n          if (key.hasOwnProperty(name)) {\n            shape[name] = key[name];\n          }\n        }\n      } else {\n        shape[key] = value;\n      }\n\n      this.dirty(true);\n    }\n\n    return this;\n  },\n  getLineScale: function () {\n    var m = this.transform; // Get the line scale.\n    // Determinant of `m` means how much the area is enlarged by the\n    // transformation. So its square root can be used as a scale factor\n    // for width.\n\n    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n  }\n};\n/**\n * 扩展一个 Path element, 比如星形，圆等。\n * Extend a path element\n * @param {Object} props\n * @param {string} props.type Path type\n * @param {Function} props.init Initialize\n * @param {Function} props.buildPath Overwrite buildPath method\n * @param {Object} [props.style] Extended default style config\n * @param {Object} [props.shape] Extended default shape config\n */\n\nPath.extend = function (defaults) {\n  var Sub = function (opts) {\n    Path.call(this, opts);\n\n    if (defaults.style) {\n      // Extend default style\n      this.style.extendFrom(defaults.style, false);\n    } // Extend default shape\n\n\n    var defaultShape = defaults.shape;\n\n    if (defaultShape) {\n      this.shape = this.shape || {};\n      var thisShape = this.shape;\n\n      for (var name in defaultShape) {\n        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n          thisShape[name] = defaultShape[name];\n        }\n      }\n    }\n\n    defaults.init && defaults.init.call(this, opts);\n  };\n\n  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象\n\n  for (var name in defaults) {\n    // Extending prototype values and methods\n    if (name !== 'style' && name !== 'shape') {\n      Sub.prototype[name] = defaults[name];\n    }\n  }\n\n  return Sub;\n};\n\nzrUtil.inherits(Path, Displayable);\nvar _default = Path;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Path.js\n// module id = 6\n// module chunks = 0","var zrUtil = require(\"../core/util\");\n\nvar Style = require(\"./Style\");\n\nvar Element = require(\"../Element\");\n\nvar RectText = require(\"./mixin/RectText\");\n\n/**\n * 可绘制的图形基类\n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n/**\n * @alias module:zrender/graphic/Displayable\n * @extends module:zrender/Element\n * @extends module:zrender/graphic/mixin/RectText\n */\nfunction Displayable(opts) {\n  opts = opts || {};\n  Element.call(this, opts); // Extend properties\n\n  for (var name in opts) {\n    if (opts.hasOwnProperty(name) && name !== 'style') {\n      this[name] = opts[name];\n    }\n  }\n  /**\n   * @type {module:zrender/graphic/Style}\n   */\n\n\n  this.style = new Style(opts.style, this);\n  this._rect = null; // Shapes for cascade clipping.\n\n  this.__clipPaths = []; // FIXME Stateful must be mixined after style is setted\n  // Stateful.call(this, opts);\n}\n\nDisplayable.prototype = {\n  constructor: Displayable,\n  type: 'displayable',\n\n  /**\n   * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制\n   * Dirty flag. From which painter will determine if this displayable object needs brush\n   * @name module:zrender/graphic/Displayable#__dirty\n   * @type {boolean}\n   */\n  __dirty: true,\n\n  /**\n   * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\n   * If ignore drawing of the displayable object. Mouse event will still be triggered\n   * @name module:/zrender/graphic/Displayable#invisible\n   * @type {boolean}\n   * @default false\n   */\n  invisible: false,\n\n  /**\n   * @name module:/zrender/graphic/Displayable#z\n   * @type {number}\n   * @default 0\n   */\n  z: 0,\n\n  /**\n   * @name module:/zrender/graphic/Displayable#z\n   * @type {number}\n   * @default 0\n   */\n  z2: 0,\n\n  /**\n   * z层level，决定绘画在哪层canvas中\n   * @name module:/zrender/graphic/Displayable#zlevel\n   * @type {number}\n   * @default 0\n   */\n  zlevel: 0,\n\n  /**\n   * 是否可拖拽\n   * @name module:/zrender/graphic/Displayable#draggable\n   * @type {boolean}\n   * @default false\n   */\n  draggable: false,\n\n  /**\n   * 是否正在拖拽\n   * @name module:/zrender/graphic/Displayable#draggable\n   * @type {boolean}\n   * @default false\n   */\n  dragging: false,\n\n  /**\n   * 是否相应鼠标事件\n   * @name module:/zrender/graphic/Displayable#silent\n   * @type {boolean}\n   * @default false\n   */\n  silent: false,\n\n  /**\n   * If enable culling\n   * @type {boolean}\n   * @default false\n   */\n  culling: false,\n\n  /**\n   * Mouse cursor when hovered\n   * @name module:/zrender/graphic/Displayable#cursor\n   * @type {string}\n   */\n  cursor: 'pointer',\n\n  /**\n   * If hover area is bounding rect\n   * @name module:/zrender/graphic/Displayable#rectHover\n   * @type {string}\n   */\n  rectHover: false,\n\n  /**\n   * Render the element progressively when the value >= 0,\n   * usefull for large data.\n   * @type {number}\n   */\n  progressive: -1,\n  beforeBrush: function (ctx) {},\n  afterBrush: function (ctx) {},\n\n  /**\n   * 图形绘制方法\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  // Interface\n  brush: function (ctx, prevEl) {},\n\n  /**\n   * 获取最小包围盒\n   * @return {module:zrender/core/BoundingRect}\n   */\n  // Interface\n  getBoundingRect: function () {},\n\n  /**\n   * 判断坐标 x, y 是否在图形上\n   * If displayable element contain coord x, y\n   * @param  {number} x\n   * @param  {number} y\n   * @return {boolean}\n   */\n  contain: function (x, y) {\n    return this.rectContain(x, y);\n  },\n\n  /**\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {\n    cb.call(context, this);\n  },\n\n  /**\n   * 判断坐标 x, y 是否在图形的包围盒上\n   * If bounding rect of element contain coord x, y\n   * @param  {number} x\n   * @param  {number} y\n   * @return {boolean}\n   */\n  rectContain: function (x, y) {\n    var coord = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    return rect.contain(coord[0], coord[1]);\n  },\n\n  /**\n   * 标记图形元素为脏，并且在下一帧重绘\n   * Mark displayable element dirty and refresh next frame\n   */\n  dirty: function () {\n    this.__dirty = true;\n    this._rect = null;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * 图形是否会触发事件\n   * If displayable object binded any event\n   * @return {boolean}\n   */\n  // TODO, 通过 bind 绑定的事件\n  // isSilent: function () {\n  //     return !(\n  //         this.hoverable || this.draggable\n  //         || this.onmousemove || this.onmouseover || this.onmouseout\n  //         || this.onmousedown || this.onmouseup || this.onclick\n  //         || this.ondragenter || this.ondragover || this.ondragleave\n  //         || this.ondrop\n  //     );\n  // },\n\n  /**\n   * Alias for animate('style')\n   * @param {boolean} loop\n   */\n  animateStyle: function (loop) {\n    return this.animate('style', loop);\n  },\n  attrKV: function (key, value) {\n    if (key !== 'style') {\n      Element.prototype.attrKV.call(this, key, value);\n    } else {\n      this.style.set(value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setStyle: function (key, value) {\n    this.style.set(key, value);\n    this.dirty(false);\n    return this;\n  },\n\n  /**\n   * Use given style object\n   * @param  {Object} obj\n   */\n  useStyle: function (obj) {\n    this.style = new Style(obj, this);\n    this.dirty(false);\n    return this;\n  }\n};\nzrUtil.inherits(Displayable, Element);\nzrUtil.mixin(Displayable, RectText); // zrUtil.mixin(Displayable, Stateful);\n\nvar _default = Displayable;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Displayable.js\n// module id = 7\n// module chunks = 0","var STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\nvar Style = function (opts, host) {\n  this.extendFrom(opts, false);\n  this.host = host;\n};\n\nfunction createLinearGradient(ctx, obj, rect) {\n  var x = obj.x == null ? 0 : obj.x;\n  var x2 = obj.x2 == null ? 1 : obj.x2;\n  var y = obj.y == null ? 0 : obj.y;\n  var y2 = obj.y2 == null ? 0 : obj.y2;\n\n  if (!obj.global) {\n    x = x * rect.width + rect.x;\n    x2 = x2 * rect.width + rect.x;\n    y = y * rect.height + rect.y;\n    y2 = y2 * rect.height + rect.y;\n  }\n\n  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n  return canvasGradient;\n}\n\nfunction createRadialGradient(ctx, obj, rect) {\n  var width = rect.width;\n  var height = rect.height;\n  var min = Math.min(width, height);\n  var x = obj.x == null ? 0.5 : obj.x;\n  var y = obj.y == null ? 0.5 : obj.y;\n  var r = obj.r == null ? 0.5 : obj.r;\n\n  if (!obj.global) {\n    x = x * width + rect.x;\n    y = y * height + rect.y;\n    r = r * min;\n  }\n\n  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n  return canvasGradient;\n}\n\nStyle.prototype = {\n  constructor: Style,\n\n  /**\n   * @type {module:zrender/graphic/Displayable}\n   */\n  host: null,\n\n  /**\n   * @type {string}\n   */\n  fill: '#000',\n\n  /**\n   * @type {string}\n   */\n  stroke: null,\n\n  /**\n   * @type {number}\n   */\n  opacity: 1,\n\n  /**\n   * @type {Array.<number>}\n   */\n  lineDash: null,\n\n  /**\n   * @type {number}\n   */\n  lineDashOffset: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowOffsetY: 0,\n\n  /**\n   * @type {number}\n   */\n  lineWidth: 1,\n\n  /**\n   * If stroke ignore scale\n   * @type {Boolean}\n   */\n  strokeNoScale: false,\n  // Bounding rect text configuration\n  // Not affected by element transform\n\n  /**\n   * @type {string}\n   */\n  text: null,\n\n  /**\n   * If `fontSize` or `fontFamily` exists, `font` will be reset by\n   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.\n   * So do not visit it directly in upper application (like echarts),\n   * but use `contain/text#makeFont` instead.\n   * @type {string}\n   */\n  font: null,\n\n  /**\n   * The same as font. Use font please.\n   * @deprecated\n   * @type {string}\n   */\n  textFont: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontStyle: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontWeight: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * Should be 12 but not '12px'.\n   * @type {number}\n   */\n  fontSize: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontFamily: null,\n\n  /**\n   * Reserved for special functinality, like 'hr'.\n   * @type {string}\n   */\n  textTag: null,\n\n  /**\n   * @type {string}\n   */\n  textFill: '#000',\n\n  /**\n   * @type {string}\n   */\n  textStroke: null,\n\n  /**\n   * @type {number}\n   */\n  textWidth: null,\n\n  /**\n   * Only for textBackground.\n   * @type {number}\n   */\n  textHeight: null,\n\n  /**\n   * textStroke may be set as some color as a default\n   * value in upper applicaion, where the default value\n   * of textStrokeWidth should be 0 to make sure that\n   * user can choose to do not use text stroke.\n   * @type {number}\n   */\n  textStrokeWidth: 0,\n\n  /**\n   * @type {number}\n   */\n  textLineHeight: null,\n\n  /**\n   * 'inside', 'left', 'right', 'top', 'bottom'\n   * [x, y]\n   * Based on x, y of rect.\n   * @type {string|Array.<number>}\n   * @default 'inside'\n   */\n  textPosition: 'inside',\n\n  /**\n   * If not specified, use the boundingRect of a `displayable`.\n   * @type {Object}\n   */\n  textRect: null,\n\n  /**\n   * [x, y]\n   * @type {Array.<number>}\n   */\n  textOffset: null,\n\n  /**\n   * @type {string}\n   */\n  textAlign: null,\n\n  /**\n   * @type {string}\n   */\n  textVerticalAlign: null,\n\n  /**\n   * @type {number}\n   */\n  textDistance: 5,\n\n  /**\n   * @type {string}\n   */\n  textShadowColor: 'transparent',\n\n  /**\n   * @type {number}\n   */\n  textShadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  textShadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  textShadowOffsetY: 0,\n\n  /**\n   * @type {string}\n   */\n  textBoxShadowColor: 'transparent',\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowOffsetY: 0,\n\n  /**\n   * Whether transform text.\n   * Only useful in Path and Image element\n   * @type {boolean}\n   */\n  transformText: false,\n\n  /**\n   * Text rotate around position of Path or Image\n   * Only useful in Path and Image element and transformText is false.\n   */\n  textRotation: 0,\n\n  /**\n   * Text origin of text rotation, like [10, 40].\n   * Based on x, y of rect.\n   * Useful in label rotation of circular symbol.\n   * By default, this origin is textPosition.\n   * Can be 'center'.\n   * @type {string|Array.<number>}\n   */\n  textOrigin: null,\n\n  /**\n   * @type {string}\n   */\n  textBackgroundColor: null,\n\n  /**\n   * @type {string}\n   */\n  textBorderColor: null,\n\n  /**\n   * @type {number}\n   */\n  textBorderWidth: 0,\n\n  /**\n   * @type {number}\n   */\n  textBorderRadius: 0,\n\n  /**\n   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`\n   * @type {number|Array.<number>}\n   */\n  textPadding: null,\n\n  /**\n   * Text styles for rich text.\n   * @type {Object}\n   */\n  rich: null,\n\n  /**\n   * {outerWidth, outerHeight, ellipsis, placeholder}\n   * @type {Object}\n   */\n  truncate: null,\n\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n   * @type {string}\n   */\n  blend: null,\n\n  /**\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  bind: function (ctx, el, prevEl) {\n    var style = this;\n    var prevStyle = prevEl && prevEl.style;\n    var firstDraw = !prevStyle;\n\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n      var prop = STYLE_COMMON_PROPS[i];\n      var styleName = prop[0];\n\n      if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n        // FIXME Invalid property value will cause style leak from previous element.\n        ctx[styleName] = style[styleName] || prop[1];\n      }\n    }\n\n    if (firstDraw || style.fill !== prevStyle.fill) {\n      ctx.fillStyle = style.fill;\n    }\n\n    if (firstDraw || style.stroke !== prevStyle.stroke) {\n      ctx.strokeStyle = style.stroke;\n    }\n\n    if (firstDraw || style.opacity !== prevStyle.opacity) {\n      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n    }\n\n    if (firstDraw || style.blend !== prevStyle.blend) {\n      ctx.globalCompositeOperation = style.blend || 'source-over';\n    }\n\n    if (this.hasStroke()) {\n      var lineWidth = style.lineWidth;\n      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);\n    }\n  },\n  hasFill: function () {\n    var fill = this.fill;\n    return fill != null && fill !== 'none';\n  },\n  hasStroke: function () {\n    var stroke = this.stroke;\n    return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n  },\n\n  /**\n   * Extend from other style\n   * @param {zrender/graphic/Style} otherStyle\n   * @param {boolean} overwrite true: overwrirte any way.\n   *                            false: overwrite only when !target.hasOwnProperty\n   *                            others: overwrite when property is not null/undefined.\n   */\n  extendFrom: function (otherStyle, overwrite) {\n    if (otherStyle) {\n      for (var name in otherStyle) {\n        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {\n          this[name] = otherStyle[name];\n        }\n      }\n    }\n  },\n\n  /**\n   * Batch setting style with a given object\n   * @param {Object|string} obj\n   * @param {*} [obj]\n   */\n  set: function (obj, value) {\n    if (typeof obj === 'string') {\n      this[obj] = value;\n    } else {\n      this.extendFrom(obj, true);\n    }\n  },\n\n  /**\n   * Clone\n   * @return {zrender/graphic/Style} [description]\n   */\n  clone: function () {\n    var newStyle = new this.constructor();\n    newStyle.extendFrom(this, true);\n    return newStyle;\n  },\n  getGradient: function (ctx, obj, rect) {\n    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n    var canvasGradient = method(ctx, obj, rect);\n    var colorStops = obj.colorStops;\n\n    for (var i = 0; i < colorStops.length; i++) {\n      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n    }\n\n    return canvasGradient;\n  }\n};\nvar styleProto = Style.prototype;\n\nfor (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n  var prop = STYLE_COMMON_PROPS[i];\n\n  if (!(prop[0] in styleProto)) {\n    styleProto[prop[0]] = prop[1];\n  }\n} // Provide for others\n\n\nStyle.getGradient = styleProto.getGradient;\nvar _default = Style;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Style.js\n// module id = 8\n// module chunks = 0","var guid = require(\"./core/guid\");\n\nvar Eventful = require(\"./mixin/Eventful\");\n\nvar Transformable = require(\"./mixin/Transformable\");\n\nvar Animatable = require(\"./mixin/Animatable\");\n\nvar zrUtil = require(\"./core/util\");\n\n/**\n * @alias module:zrender/Element\n * @constructor\n * @extends {module:zrender/mixin/Animatable}\n * @extends {module:zrender/mixin/Transformable}\n * @extends {module:zrender/mixin/Eventful}\n */\nvar Element = function (opts) {\n  // jshint ignore:line\n  Transformable.call(this, opts);\n  Eventful.call(this, opts);\n  Animatable.call(this, opts);\n  /**\n   * 画布元素ID\n   * @type {string}\n   */\n\n  this.id = opts.id || guid();\n};\n\nElement.prototype = {\n  /**\n   * 元素类型\n   * Element type\n   * @type {string}\n   */\n  type: 'element',\n\n  /**\n   * 元素名字\n   * Element name\n   * @type {string}\n   */\n  name: '',\n\n  /**\n   * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n   * ZRender instance will be assigned when element is associated with zrender\n   * @name module:/zrender/Element#__zr\n   * @type {module:zrender/ZRender}\n   */\n  __zr: null,\n\n  /**\n   * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n   * If ignore drawing and events of the element object\n   * @name module:/zrender/Element#ignore\n   * @type {boolean}\n   * @default false\n   */\n  ignore: false,\n\n  /**\n   * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n   * 该路径会继承被裁减对象的变换\n   * @type {module:zrender/graphic/Path}\n   * @see http://www.w3.org/TR/2dcontext/#clipping-region\n   * @readOnly\n   */\n  clipPath: null,\n\n  /**\n   * Drift element\n   * @param  {number} dx dx on the global space\n   * @param  {number} dy dy on the global space\n   */\n  drift: function (dx, dy) {\n    switch (this.draggable) {\n      case 'horizontal':\n        dy = 0;\n        break;\n\n      case 'vertical':\n        dx = 0;\n        break;\n    }\n\n    var m = this.transform;\n\n    if (!m) {\n      m = this.transform = [1, 0, 0, 1, 0, 0];\n    }\n\n    m[4] += dx;\n    m[5] += dy;\n    this.decomposeTransform();\n    this.dirty(false);\n  },\n\n  /**\n   * Hook before update\n   */\n  beforeUpdate: function () {},\n\n  /**\n   * Hook after update\n   */\n  afterUpdate: function () {},\n\n  /**\n   * Update each frame\n   */\n  update: function () {\n    this.updateTransform();\n  },\n\n  /**\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {},\n\n  /**\n   * @protected\n   */\n  attrKV: function (key, value) {\n    if (key === 'position' || key === 'scale' || key === 'origin') {\n      // Copy the array\n      if (value) {\n        var target = this[key];\n\n        if (!target) {\n          target = this[key] = [];\n        }\n\n        target[0] = value[0];\n        target[1] = value[1];\n      }\n    } else {\n      this[key] = value;\n    }\n  },\n\n  /**\n   * Hide the element\n   */\n  hide: function () {\n    this.ignore = true;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * Show the element\n   */\n  show: function () {\n    this.ignore = false;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * @param {string|Object} key\n   * @param {*} value\n   */\n  attr: function (key, value) {\n    if (typeof key === 'string') {\n      this.attrKV(key, value);\n    } else if (zrUtil.isObject(key)) {\n      for (var name in key) {\n        if (key.hasOwnProperty(name)) {\n          this.attrKV(name, key[name]);\n        }\n      }\n    }\n\n    this.dirty(false);\n    return this;\n  },\n\n  /**\n   * @param {module:zrender/graphic/Path} clipPath\n   */\n  setClipPath: function (clipPath) {\n    var zr = this.__zr;\n\n    if (zr) {\n      clipPath.addSelfToZr(zr);\n    } // Remove previous clip path\n\n\n    if (this.clipPath && this.clipPath !== clipPath) {\n      this.removeClipPath();\n    }\n\n    this.clipPath = clipPath;\n    clipPath.__zr = zr;\n    clipPath.__clipTarget = this;\n    this.dirty(false);\n  },\n\n  /**\n   */\n  removeClipPath: function () {\n    var clipPath = this.clipPath;\n\n    if (clipPath) {\n      if (clipPath.__zr) {\n        clipPath.removeSelfFromZr(clipPath.__zr);\n      }\n\n      clipPath.__zr = null;\n      clipPath.__clipTarget = null;\n      this.clipPath = null;\n      this.dirty(false);\n    }\n  },\n\n  /**\n   * Add self from zrender instance.\n   * Not recursively because it will be invoked when element added to storage.\n   * @param {module:zrender/ZRender} zr\n   */\n  addSelfToZr: function (zr) {\n    this.__zr = zr; // 添加动画\n\n    var animators = this.animators;\n\n    if (animators) {\n      for (var i = 0; i < animators.length; i++) {\n        zr.animation.addAnimator(animators[i]);\n      }\n    }\n\n    if (this.clipPath) {\n      this.clipPath.addSelfToZr(zr);\n    }\n  },\n\n  /**\n   * Remove self from zrender instance.\n   * Not recursively because it will be invoked when element added to storage.\n   * @param {module:zrender/ZRender} zr\n   */\n  removeSelfFromZr: function (zr) {\n    this.__zr = null; // 移除动画\n\n    var animators = this.animators;\n\n    if (animators) {\n      for (var i = 0; i < animators.length; i++) {\n        zr.animation.removeAnimator(animators[i]);\n      }\n    }\n\n    if (this.clipPath) {\n      this.clipPath.removeSelfFromZr(zr);\n    }\n  }\n};\nzrUtil.mixin(Element, Animatable);\nzrUtil.mixin(Element, Transformable);\nzrUtil.mixin(Element, Eventful);\nvar _default = Element;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Element.js\n// module id = 9\n// module chunks = 0","/**\n * zrender: 生成唯一id\n *\n * @author errorrik (errorrik@gmail.com)\n */\nvar idStart = 0x0907;\n\nfunction _default() {\n  return idStart++;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/guid.js\n// module id = 10\n// module chunks = 0","/**\n * 事件扩展\n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\nvar arrySlice = Array.prototype.slice;\n/**\n * 事件分发器\n * @alias module:zrender/mixin/Eventful\n * @constructor\n */\n\nvar Eventful = function () {\n  this._$handlers = {};\n};\n\nEventful.prototype = {\n  constructor: Eventful,\n\n  /**\n   * 单次触发绑定，trigger后销毁\n   *\n   * @param {string} event 事件名\n   * @param {Function} handler 响应函数\n   * @param {Object} context\n   */\n  one: function (event, handler, context) {\n    var _h = this._$handlers;\n\n    if (!handler || !event) {\n      return this;\n    }\n\n    if (!_h[event]) {\n      _h[event] = [];\n    }\n\n    for (var i = 0; i < _h[event].length; i++) {\n      if (_h[event][i].h === handler) {\n        return this;\n      }\n    }\n\n    _h[event].push({\n      h: handler,\n      one: true,\n      ctx: context || this\n    });\n\n    return this;\n  },\n\n  /**\n   * 绑定事件\n   * @param {string} event 事件名\n   * @param {Function} handler 事件处理函数\n   * @param {Object} [context]\n   */\n  on: function (event, handler, context) {\n    var _h = this._$handlers;\n\n    if (!handler || !event) {\n      return this;\n    }\n\n    if (!_h[event]) {\n      _h[event] = [];\n    }\n\n    for (var i = 0; i < _h[event].length; i++) {\n      if (_h[event][i].h === handler) {\n        return this;\n      }\n    }\n\n    _h[event].push({\n      h: handler,\n      one: false,\n      ctx: context || this\n    });\n\n    return this;\n  },\n\n  /**\n   * 是否绑定了事件\n   * @param  {string}  event\n   * @return {boolean}\n   */\n  isSilent: function (event) {\n    var _h = this._$handlers;\n    return _h[event] && _h[event].length;\n  },\n\n  /**\n   * 解绑事件\n   * @param {string} event 事件名\n   * @param {Function} [handler] 事件处理函数\n   */\n  off: function (event, handler) {\n    var _h = this._$handlers;\n\n    if (!event) {\n      this._$handlers = {};\n      return this;\n    }\n\n    if (handler) {\n      if (_h[event]) {\n        var newList = [];\n\n        for (var i = 0, l = _h[event].length; i < l; i++) {\n          if (_h[event][i]['h'] != handler) {\n            newList.push(_h[event][i]);\n          }\n        }\n\n        _h[event] = newList;\n      }\n\n      if (_h[event] && _h[event].length === 0) {\n        delete _h[event];\n      }\n    } else {\n      delete _h[event];\n    }\n\n    return this;\n  },\n\n  /**\n   * 事件分发\n   *\n   * @param {string} type 事件类型\n   */\n  trigger: function (type) {\n    if (this._$handlers[type]) {\n      var args = arguments;\n      var argLen = args.length;\n\n      if (argLen > 3) {\n        args = arrySlice.call(args, 1);\n      }\n\n      var _h = this._$handlers[type];\n      var len = _h.length;\n\n      for (var i = 0; i < len;) {\n        // Optimize advise from backbone\n        switch (argLen) {\n          case 1:\n            _h[i]['h'].call(_h[i]['ctx']);\n\n            break;\n\n          case 2:\n            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\n            break;\n\n          case 3:\n            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\n            break;\n\n          default:\n            // have more than 2 given arguments\n            _h[i]['h'].apply(_h[i]['ctx'], args);\n\n            break;\n        }\n\n        if (_h[i]['one']) {\n          _h.splice(i, 1);\n\n          len--;\n        } else {\n          i++;\n        }\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * 带有context的事件分发, 最后一个参数是事件回调的context\n   * @param {string} type 事件类型\n   */\n  triggerWithContext: function (type) {\n    if (this._$handlers[type]) {\n      var args = arguments;\n      var argLen = args.length;\n\n      if (argLen > 4) {\n        args = arrySlice.call(args, 1, args.length - 1);\n      }\n\n      var ctx = args[args.length - 1];\n      var _h = this._$handlers[type];\n      var len = _h.length;\n\n      for (var i = 0; i < len;) {\n        // Optimize advise from backbone\n        switch (argLen) {\n          case 1:\n            _h[i]['h'].call(ctx);\n\n            break;\n\n          case 2:\n            _h[i]['h'].call(ctx, args[1]);\n\n            break;\n\n          case 3:\n            _h[i]['h'].call(ctx, args[1], args[2]);\n\n            break;\n\n          default:\n            // have more than 2 given arguments\n            _h[i]['h'].apply(ctx, args);\n\n            break;\n        }\n\n        if (_h[i]['one']) {\n          _h.splice(i, 1);\n\n          len--;\n        } else {\n          i++;\n        }\n      }\n    }\n\n    return this;\n  }\n}; // 对象可以通过 onxxxx 绑定事件\n\n/**\n * @event module:zrender/mixin/Eventful#onclick\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseover\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseout\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousemove\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousewheel\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousedown\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseup\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondrag\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragstart\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragend\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragenter\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragleave\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragover\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondrop\n * @type {Function}\n * @default null\n */\n\nvar _default = Eventful;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Eventful.js\n// module id = 11\n// module chunks = 0","var matrix = require(\"../core/matrix\");\n\nvar vector = require(\"../core/vector\");\n\n/**\n * 提供变换扩展\n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\nvar mIdentity = matrix.identity;\nvar EPSILON = 5e-5;\n\nfunction isNotAroundZero(val) {\n  return val > EPSILON || val < -EPSILON;\n}\n/**\n * @alias module:zrender/mixin/Transformable\n * @constructor\n */\n\n\nvar Transformable = function (opts) {\n  opts = opts || {}; // If there are no given position, rotation, scale\n\n  if (!opts.position) {\n    /**\n     * 平移\n     * @type {Array.<number>}\n     * @default [0, 0]\n     */\n    this.position = [0, 0];\n  }\n\n  if (opts.rotation == null) {\n    /**\n     * 旋转\n     * @type {Array.<number>}\n     * @default 0\n     */\n    this.rotation = 0;\n  }\n\n  if (!opts.scale) {\n    /**\n     * 缩放\n     * @type {Array.<number>}\n     * @default [1, 1]\n     */\n    this.scale = [1, 1];\n  }\n  /**\n   * 旋转和缩放的原点\n   * @type {Array.<number>}\n   * @default null\n   */\n\n\n  this.origin = this.origin || null;\n};\n\nvar transformableProto = Transformable.prototype;\ntransformableProto.transform = null;\n/**\n * 判断是否需要有坐标变换\n * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n */\n\ntransformableProto.needLocalTransform = function () {\n  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n};\n\ntransformableProto.updateTransform = function () {\n  var parent = this.parent;\n  var parentHasTransform = parent && parent.transform;\n  var needLocalTransform = this.needLocalTransform();\n  var m = this.transform;\n\n  if (!(needLocalTransform || parentHasTransform)) {\n    m && mIdentity(m);\n    return;\n  }\n\n  m = m || matrix.create();\n\n  if (needLocalTransform) {\n    this.getLocalTransform(m);\n  } else {\n    mIdentity(m);\n  } // 应用父节点变换\n\n\n  if (parentHasTransform) {\n    if (needLocalTransform) {\n      matrix.mul(m, parent.transform, m);\n    } else {\n      matrix.copy(m, parent.transform);\n    }\n  } // 保存这个变换矩阵\n\n\n  this.transform = m;\n  this.invTransform = this.invTransform || matrix.create();\n  matrix.invert(this.invTransform, m);\n};\n\ntransformableProto.getLocalTransform = function (m) {\n  return Transformable.getLocalTransform(this, m);\n};\n/**\n * 将自己的transform应用到context上\n * @param {CanvasRenderingContext2D} ctx\n */\n\n\ntransformableProto.setTransform = function (ctx) {\n  var m = this.transform;\n  var dpr = ctx.dpr || 1;\n\n  if (m) {\n    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n  } else {\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n  }\n};\n\ntransformableProto.restoreTransform = function (ctx) {\n  var dpr = ctx.dpr || 1;\n  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n};\n\nvar tmpTransform = [];\n/**\n * 分解`transform`矩阵到`position`, `rotation`, `scale`\n */\n\ntransformableProto.decomposeTransform = function () {\n  if (!this.transform) {\n    return;\n  }\n\n  var parent = this.parent;\n  var m = this.transform;\n\n  if (parent && parent.transform) {\n    // Get local transform and decompose them to position, scale, rotation\n    matrix.mul(tmpTransform, parent.invTransform, m);\n    m = tmpTransform;\n  }\n\n  var sx = m[0] * m[0] + m[1] * m[1];\n  var sy = m[2] * m[2] + m[3] * m[3];\n  var position = this.position;\n  var scale = this.scale;\n\n  if (isNotAroundZero(sx - 1)) {\n    sx = Math.sqrt(sx);\n  }\n\n  if (isNotAroundZero(sy - 1)) {\n    sy = Math.sqrt(sy);\n  }\n\n  if (m[0] < 0) {\n    sx = -sx;\n  }\n\n  if (m[3] < 0) {\n    sy = -sy;\n  }\n\n  position[0] = m[4];\n  position[1] = m[5];\n  scale[0] = sx;\n  scale[1] = sy;\n  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n};\n/**\n * Get global scale\n * @return {Array.<number>}\n */\n\n\ntransformableProto.getGlobalScale = function () {\n  var m = this.transform;\n\n  if (!m) {\n    return [1, 1];\n  }\n\n  var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n  var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\n  if (m[0] < 0) {\n    sx = -sx;\n  }\n\n  if (m[3] < 0) {\n    sy = -sy;\n  }\n\n  return [sx, sy];\n};\n/**\n * 变换坐标位置到 shape 的局部坐标空间\n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToLocal = function (x, y) {\n  var v2 = [x, y];\n  var invTransform = this.invTransform;\n\n  if (invTransform) {\n    vector.applyTransform(v2, v2, invTransform);\n  }\n\n  return v2;\n};\n/**\n * 变换局部坐标位置到全局坐标空间\n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToGlobal = function (x, y) {\n  var v2 = [x, y];\n  var transform = this.transform;\n\n  if (transform) {\n    vector.applyTransform(v2, v2, transform);\n  }\n\n  return v2;\n};\n/**\n * @static\n * @param {Object} target\n * @param {Array.<number>} target.origin\n * @param {number} target.rotation\n * @param {Array.<number>} target.position\n * @param {Array.<number>} [m]\n */\n\n\nTransformable.getLocalTransform = function (target, m) {\n  m = m || [];\n  mIdentity(m);\n  var origin = target.origin;\n  var scale = target.scale || [1, 1];\n  var rotation = target.rotation || 0;\n  var position = target.position || [0, 0];\n\n  if (origin) {\n    // Translate to origin\n    m[4] -= origin[0];\n    m[5] -= origin[1];\n  }\n\n  matrix.scale(m, m, scale);\n\n  if (rotation) {\n    matrix.rotate(m, m, rotation);\n  }\n\n  if (origin) {\n    // Translate back from origin\n    m[4] += origin[0];\n    m[5] += origin[1];\n  }\n\n  m[4] += position[0];\n  m[5] += position[1];\n  return m;\n};\n\nvar _default = Transformable;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Transformable.js\n// module id = 12\n// module chunks = 0","/**\n * 3x2矩阵操作类\n * @exports zrender/tool/matrix\n */\nvar ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n/**\n * 创建一个单位矩阵\n * @return {Float32Array|Array.<number>}\n */\n\nfunction create() {\n  var out = new ArrayCtor(6);\n  identity(out);\n  return out;\n}\n/**\n * 设置矩阵为单位矩阵\n * @param {Float32Array|Array.<number>} out\n */\n\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\n * 复制矩阵\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} m\n */\n\n\nfunction copy(out, m) {\n  out[0] = m[0];\n  out[1] = m[1];\n  out[2] = m[2];\n  out[3] = m[3];\n  out[4] = m[4];\n  out[5] = m[5];\n  return out;\n}\n/**\n * 矩阵相乘\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} m1\n * @param {Float32Array|Array.<number>} m2\n */\n\n\nfunction mul(out, m1, m2) {\n  // Consider matrix.mul(m, m2, m);\n  // where out is the same as m2.\n  // So use temp variable to escape error.\n  var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n  var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n  var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n  var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = out3;\n  out[4] = out4;\n  out[5] = out5;\n  return out;\n}\n/**\n * 平移变换\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {Float32Array|Array.<number>} v\n */\n\n\nfunction translate(out, a, v) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4] + v[0];\n  out[5] = a[5] + v[1];\n  return out;\n}\n/**\n * 旋转变换\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {number} rad\n */\n\n\nfunction rotate(out, a, rad) {\n  var aa = a[0];\n  var ac = a[2];\n  var atx = a[4];\n  var ab = a[1];\n  var ad = a[3];\n  var aty = a[5];\n  var st = Math.sin(rad);\n  var ct = Math.cos(rad);\n  out[0] = aa * ct + ab * st;\n  out[1] = -aa * st + ab * ct;\n  out[2] = ac * ct + ad * st;\n  out[3] = -ac * st + ct * ad;\n  out[4] = ct * atx + st * aty;\n  out[5] = ct * aty - st * atx;\n  return out;\n}\n/**\n * 缩放变换\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {Float32Array|Array.<number>} v\n */\n\n\nfunction scale(out, a, v) {\n  var vx = v[0];\n  var vy = v[1];\n  out[0] = a[0] * vx;\n  out[1] = a[1] * vy;\n  out[2] = a[2] * vx;\n  out[3] = a[3] * vy;\n  out[4] = a[4] * vx;\n  out[5] = a[5] * vy;\n  return out;\n}\n/**\n * 求逆矩阵\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n */\n\n\nfunction invert(out, a) {\n  var aa = a[0];\n  var ac = a[2];\n  var atx = a[4];\n  var ab = a[1];\n  var ad = a[3];\n  var aty = a[5];\n  var det = aa * ad - ab * ac;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = ad * det;\n  out[1] = -ab * det;\n  out[2] = -ac * det;\n  out[3] = aa * det;\n  out[4] = (ac * aty - ad * atx) * det;\n  out[5] = (ab * atx - aa * aty) * det;\n  return out;\n}\n\nexports.create = create;\nexports.identity = identity;\nexports.copy = copy;\nexports.mul = mul;\nexports.translate = translate;\nexports.rotate = rotate;\nexports.scale = scale;\nexports.invert = invert;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/matrix.js\n// module id = 13\n// module chunks = 0","var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n/**\n * 创建一个向量\n * @param {number} [x=0]\n * @param {number} [y=0]\n * @return {Vector2}\n */\n\nfunction create(x, y) {\n  var out = new ArrayCtor(2);\n\n  if (x == null) {\n    x = 0;\n  }\n\n  if (y == null) {\n    y = 0;\n  }\n\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * 复制向量数据\n * @param {Vector2} out\n * @param {Vector2} v\n * @return {Vector2}\n */\n\n\nfunction copy(out, v) {\n  out[0] = v[0];\n  out[1] = v[1];\n  return out;\n}\n/**\n * 克隆一个向量\n * @param {Vector2} v\n * @return {Vector2}\n */\n\n\nfunction clone(v) {\n  var out = new ArrayCtor(2);\n  out[0] = v[0];\n  out[1] = v[1];\n  return out;\n}\n/**\n * 设置向量的两个项\n * @param {Vector2} out\n * @param {number} a\n * @param {number} b\n * @return {Vector2} 结果\n */\n\n\nfunction set(out, a, b) {\n  out[0] = a;\n  out[1] = b;\n  return out;\n}\n/**\n * 向量相加\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction add(out, v1, v2) {\n  out[0] = v1[0] + v2[0];\n  out[1] = v1[1] + v2[1];\n  return out;\n}\n/**\n * 向量缩放后相加\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @param {number} a\n */\n\n\nfunction scaleAndAdd(out, v1, v2, a) {\n  out[0] = v1[0] + v2[0] * a;\n  out[1] = v1[1] + v2[1] * a;\n  return out;\n}\n/**\n * 向量相减\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction sub(out, v1, v2) {\n  out[0] = v1[0] - v2[0];\n  out[1] = v1[1] - v2[1];\n  return out;\n}\n/**\n * 向量长度\n * @param {Vector2} v\n * @return {number}\n */\n\n\nfunction len(v) {\n  return Math.sqrt(lenSquare(v));\n}\n\nvar length = len; // jshint ignore:line\n\n/**\n * 向量长度平方\n * @param {Vector2} v\n * @return {number}\n */\n\nfunction lenSquare(v) {\n  return v[0] * v[0] + v[1] * v[1];\n}\n\nvar lengthSquare = lenSquare;\n/**\n * 向量乘法\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\nfunction mul(out, v1, v2) {\n  out[0] = v1[0] * v2[0];\n  out[1] = v1[1] * v2[1];\n  return out;\n}\n/**\n * 向量除法\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction div(out, v1, v2) {\n  out[0] = v1[0] / v2[0];\n  out[1] = v1[1] / v2[1];\n  return out;\n}\n/**\n * 向量点乘\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\n\nfunction dot(v1, v2) {\n  return v1[0] * v2[0] + v1[1] * v2[1];\n}\n/**\n * 向量缩放\n * @param {Vector2} out\n * @param {Vector2} v\n * @param {number} s\n */\n\n\nfunction scale(out, v, s) {\n  out[0] = v[0] * s;\n  out[1] = v[1] * s;\n  return out;\n}\n/**\n * 向量归一化\n * @param {Vector2} out\n * @param {Vector2} v\n */\n\n\nfunction normalize(out, v) {\n  var d = len(v);\n\n  if (d === 0) {\n    out[0] = 0;\n    out[1] = 0;\n  } else {\n    out[0] = v[0] / d;\n    out[1] = v[1] / d;\n  }\n\n  return out;\n}\n/**\n * 计算向量间距离\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\n\nfunction distance(v1, v2) {\n  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));\n}\n\nvar dist = distance;\n/**\n * 向量距离平方\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\nfunction distanceSquare(v1, v2) {\n  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n}\n\nvar distSquare = distanceSquare;\n/**\n * 求负向量\n * @param {Vector2} out\n * @param {Vector2} v\n */\n\nfunction negate(out, v) {\n  out[0] = -v[0];\n  out[1] = -v[1];\n  return out;\n}\n/**\n * 插值两个点\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @param {number} t\n */\n\n\nfunction lerp(out, v1, v2, t) {\n  out[0] = v1[0] + t * (v2[0] - v1[0]);\n  out[1] = v1[1] + t * (v2[1] - v1[1]);\n  return out;\n}\n/**\n * 矩阵左乘向量\n * @param {Vector2} out\n * @param {Vector2} v\n * @param {Vector2} m\n */\n\n\nfunction applyTransform(out, v, m) {\n  var x = v[0];\n  var y = v[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\n * 求两个向量最小值\n * @param  {Vector2} out\n * @param  {Vector2} v1\n * @param  {Vector2} v2\n */\n\n\nfunction min(out, v1, v2) {\n  out[0] = Math.min(v1[0], v2[0]);\n  out[1] = Math.min(v1[1], v2[1]);\n  return out;\n}\n/**\n * 求两个向量最大值\n * @param  {Vector2} out\n * @param  {Vector2} v1\n * @param  {Vector2} v2\n */\n\n\nfunction max(out, v1, v2) {\n  out[0] = Math.max(v1[0], v2[0]);\n  out[1] = Math.max(v1[1], v2[1]);\n  return out;\n}\n\nexports.create = create;\nexports.copy = copy;\nexports.clone = clone;\nexports.set = set;\nexports.add = add;\nexports.scaleAndAdd = scaleAndAdd;\nexports.sub = sub;\nexports.len = len;\nexports.length = length;\nexports.lenSquare = lenSquare;\nexports.lengthSquare = lengthSquare;\nexports.mul = mul;\nexports.div = div;\nexports.dot = dot;\nexports.scale = scale;\nexports.normalize = normalize;\nexports.distance = distance;\nexports.dist = dist;\nexports.distanceSquare = distanceSquare;\nexports.distSquare = distSquare;\nexports.negate = negate;\nexports.lerp = lerp;\nexports.applyTransform = applyTransform;\nexports.min = min;\nexports.max = max;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/vector.js\n// module id = 14\n// module chunks = 0","var Animator = require(\"../animation/Animator\");\n\nvar log = require(\"../core/log\");\n\nvar _util = require(\"../core/util\");\n\nvar isString = _util.isString;\nvar isFunction = _util.isFunction;\nvar isObject = _util.isObject;\nvar isArrayLike = _util.isArrayLike;\nvar indexOf = _util.indexOf;\n\n/**\n * @alias modue:zrender/mixin/Animatable\n * @constructor\n */\nvar Animatable = function () {\n  /**\n   * @type {Array.<module:zrender/animation/Animator>}\n   * @readOnly\n   */\n  this.animators = [];\n};\n\nAnimatable.prototype = {\n  constructor: Animatable,\n\n  /**\n   * 动画\n   *\n   * @param {string} path The path to fetch value from object, like 'a.b.c'.\n   * @param {boolean} [loop] Whether to loop animation.\n   * @return {module:zrender/animation/Animator}\n   * @example:\n   *     el.animate('style', false)\n   *         .when(1000, {x: 10} )\n   *         .done(function(){ // Animation done })\n   *         .start()\n   */\n  animate: function (path, loop) {\n    var target;\n    var animatingShape = false;\n    var el = this;\n    var zr = this.__zr;\n\n    if (path) {\n      var pathSplitted = path.split('.');\n      var prop = el; // If animating shape\n\n      animatingShape = pathSplitted[0] === 'shape';\n\n      for (var i = 0, l = pathSplitted.length; i < l; i++) {\n        if (!prop) {\n          continue;\n        }\n\n        prop = prop[pathSplitted[i]];\n      }\n\n      if (prop) {\n        target = prop;\n      }\n    } else {\n      target = el;\n    }\n\n    if (!target) {\n      log('Property \"' + path + '\" is not existed in element ' + el.id);\n      return;\n    }\n\n    var animators = el.animators;\n    var animator = new Animator(target, loop);\n    animator.during(function (target) {\n      el.dirty(animatingShape);\n    }).done(function () {\n      // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n      animators.splice(indexOf(animators, animator), 1);\n    });\n    animators.push(animator); // If animate after added to the zrender\n\n    if (zr) {\n      zr.animation.addAnimator(animator);\n    }\n\n    return animator;\n  },\n\n  /**\n   * 停止动画\n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stopAnimation: function (forwardToLast) {\n    var animators = this.animators;\n    var len = animators.length;\n\n    for (var i = 0; i < len; i++) {\n      animators[i].stop(forwardToLast);\n    }\n\n    animators.length = 0;\n    return this;\n  },\n\n  /**\n   * Caution: this method will stop previous animation.\n   * So do not use this method to one element twice before\n   * animation starts, unless you know what you are doing.\n   * @param {Object} target\n   * @param {number} [time=500] Time in ms\n   * @param {string} [easing='linear']\n   * @param {number} [delay=0]\n   * @param {Function} [callback]\n   * @param {Function} [forceAnimate] Prevent stop animation and callback\n   *        immediently when target values are the same as current values.\n   *\n   * @example\n   *  // Animate position\n   *  el.animateTo({\n   *      position: [10, 10]\n   *  }, function () { // done })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n   *  el.animateTo({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100, 'cubicOut', function () { // done })\n   */\n  // TODO Return animation key\n  animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n    // animateTo(target, time, easing, callback);\n    if (isString(delay)) {\n      callback = easing;\n      easing = delay;\n      delay = 0;\n    } // animateTo(target, time, delay, callback);\n    else if (isFunction(easing)) {\n        callback = easing;\n        easing = 'linear';\n        delay = 0;\n      } // animateTo(target, time, callback);\n      else if (isFunction(delay)) {\n          callback = delay;\n          delay = 0;\n        } // animateTo(target, callback)\n        else if (isFunction(time)) {\n            callback = time;\n            time = 500;\n          } // animateTo(target)\n          else if (!time) {\n              time = 500;\n            } // Stop all previous animations\n\n\n    this.stopAnimation();\n\n    this._animateToShallow('', this, target, time, delay); // Animators may be removed immediately after start\n    // if there is nothing to animate\n\n\n    var animators = this.animators.slice();\n    var count = animators.length;\n\n    function done() {\n      count--;\n\n      if (!count) {\n        callback && callback();\n      }\n    } // No animators. This should be checked before animators[i].start(),\n    // because 'done' may be executed immediately if no need to animate.\n\n\n    if (!count) {\n      callback && callback();\n    } // Start after all animators created\n    // Incase any animator is done immediately when all animation properties are not changed\n\n\n    for (var i = 0; i < animators.length; i++) {\n      animators[i].done(done).start(easing, forceAnimate);\n    }\n  },\n\n  /**\n   * @private\n   * @param {string} path=''\n   * @param {Object} source=this\n   * @param {Object} target\n   * @param {number} [time=500]\n   * @param {number} [delay=0]\n   *\n   * @example\n   *  // Animate position\n   *  el._animateToShallow({\n   *      position: [10, 10]\n   *  })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms\n   *  el._animateToShallow({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100)\n   */\n  _animateToShallow: function (path, source, target, time, delay) {\n    var objShallow = {};\n    var propertyCount = 0;\n\n    for (var name in target) {\n      if (!target.hasOwnProperty(name)) {\n        continue;\n      }\n\n      if (source[name] != null) {\n        if (isObject(target[name]) && !isArrayLike(target[name])) {\n          this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);\n        } else {\n          objShallow[name] = target[name];\n          propertyCount++;\n        }\n      } else if (target[name] != null) {\n        // Attr directly if not has property\n        // FIXME, if some property not needed for element ?\n        if (!path) {\n          this.attr(name, target[name]);\n        } else {\n          // Shape or style\n          var props = {};\n          props[path] = {};\n          props[path][name] = target[name];\n          this.attr(props);\n        }\n      }\n    }\n\n    if (propertyCount > 0) {\n      this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n    }\n\n    return this;\n  }\n};\nvar _default = Animatable;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Animatable.js\n// module id = 15\n// module chunks = 0","var Clip = require(\"./Clip\");\n\nvar color = require(\"../tool/color\");\n\nvar _util = require(\"../core/util\");\n\nvar isArrayLike = _util.isArrayLike;\n\n/**\n * @module echarts/animation/Animator\n */\nvar arraySlice = Array.prototype.slice;\n\nfunction defaultGetter(target, key) {\n  return target[key];\n}\n\nfunction defaultSetter(target, key, value) {\n  target[key] = value;\n}\n/**\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} percent\n * @return {number}\n */\n\n\nfunction interpolateNumber(p0, p1, percent) {\n  return (p1 - p0) * percent + p0;\n}\n/**\n * @param  {string} p0\n * @param  {string} p1\n * @param  {number} percent\n * @return {string}\n */\n\n\nfunction interpolateString(p0, p1, percent) {\n  return percent > 0.5 ? p1 : p0;\n}\n/**\n * @param  {Array} p0\n * @param  {Array} p1\n * @param  {number} percent\n * @param  {Array} out\n * @param  {number} arrDim\n */\n\n\nfunction interpolateArray(p0, p1, percent, out, arrDim) {\n  var len = p0.length;\n\n  if (arrDim == 1) {\n    for (var i = 0; i < len; i++) {\n      out[i] = interpolateNumber(p0[i], p1[i], percent);\n    }\n  } else {\n    var len2 = len && p0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n      }\n    }\n  }\n} // arr0 is source array, arr1 is target array.\n// Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\n\nfunction fillArr(arr0, arr1, arrDim) {\n  var arr0Len = arr0.length;\n  var arr1Len = arr1.length;\n\n  if (arr0Len !== arr1Len) {\n    // FIXME Not work for TypedArray\n    var isPreviousLarger = arr0Len > arr1Len;\n\n    if (isPreviousLarger) {\n      // Cut the previous\n      arr0.length = arr1Len;\n    } else {\n      // Fill the previous\n      for (var i = arr0Len; i < arr1Len; i++) {\n        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n      }\n    }\n  } // Handling NaN value\n\n\n  var len2 = arr0[0] && arr0[0].length;\n\n  for (var i = 0; i < arr0.length; i++) {\n    if (arrDim === 1) {\n      if (isNaN(arr0[i])) {\n        arr0[i] = arr1[i];\n      }\n    } else {\n      for (var j = 0; j < len2; j++) {\n        if (isNaN(arr0[i][j])) {\n          arr0[i][j] = arr1[i][j];\n        }\n      }\n    }\n  }\n}\n/**\n * @param  {Array} arr0\n * @param  {Array} arr1\n * @param  {number} arrDim\n * @return {boolean}\n */\n\n\nfunction isArraySame(arr0, arr1, arrDim) {\n  if (arr0 === arr1) {\n    return true;\n  }\n\n  var len = arr0.length;\n\n  if (len !== arr1.length) {\n    return false;\n  }\n\n  if (arrDim === 1) {\n    for (var i = 0; i < len; i++) {\n      if (arr0[i] !== arr1[i]) {\n        return false;\n      }\n    }\n  } else {\n    var len2 = arr0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        if (arr0[i][j] !== arr1[i][j]) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Catmull Rom interpolate array\n * @param  {Array} p0\n * @param  {Array} p1\n * @param  {Array} p2\n * @param  {Array} p3\n * @param  {number} t\n * @param  {number} t2\n * @param  {number} t3\n * @param  {Array} out\n * @param  {number} arrDim\n */\n\n\nfunction catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {\n  var len = p0.length;\n\n  if (arrDim == 1) {\n    for (var i = 0; i < len; i++) {\n      out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);\n    }\n  } else {\n    var len2 = p0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);\n      }\n    }\n  }\n}\n/**\n * Catmull Rom interpolate number\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @param  {number} t2\n * @param  {number} t3\n * @return {number}\n */\n\n\nfunction catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n  var v0 = (p2 - p0) * 0.5;\n  var v1 = (p3 - p1) * 0.5;\n  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n}\n\nfunction cloneValue(value) {\n  if (isArrayLike(value)) {\n    var len = value.length;\n\n    if (isArrayLike(value[0])) {\n      var ret = [];\n\n      for (var i = 0; i < len; i++) {\n        ret.push(arraySlice.call(value[i]));\n      }\n\n      return ret;\n    }\n\n    return arraySlice.call(value);\n  }\n\n  return value;\n}\n\nfunction rgba2String(rgba) {\n  rgba[0] = Math.floor(rgba[0]);\n  rgba[1] = Math.floor(rgba[1]);\n  rgba[2] = Math.floor(rgba[2]);\n  return 'rgba(' + rgba.join(',') + ')';\n}\n\nfunction getArrayDim(keyframes) {\n  var lastValue = keyframes[keyframes.length - 1].value;\n  return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n}\n\nfunction createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {\n  var getter = animator._getter;\n  var setter = animator._setter;\n  var useSpline = easing === 'spline';\n  var trackLen = keyframes.length;\n\n  if (!trackLen) {\n    return;\n  } // Guess data type\n\n\n  var firstVal = keyframes[0].value;\n  var isValueArray = isArrayLike(firstVal);\n  var isValueColor = false;\n  var isValueString = false; // For vertices morphing\n\n  var arrDim = isValueArray ? getArrayDim(keyframes) : 0;\n  var trackMaxTime; // Sort keyframe as ascending\n\n  keyframes.sort(function (a, b) {\n    return a.time - b.time;\n  });\n  trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe\n\n  var kfPercents = []; // Value of each keyframe\n\n  var kfValues = [];\n  var prevValue = keyframes[0].value;\n  var isAllValueEqual = true;\n\n  for (var i = 0; i < trackLen; i++) {\n    kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string\n\n    var value = keyframes[i].value; // Check if value is equal, deep check if value is array\n\n    if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {\n      isAllValueEqual = false;\n    }\n\n    prevValue = value; // Try converting a string to a color array\n\n    if (typeof value == 'string') {\n      var colorArray = color.parse(value);\n\n      if (colorArray) {\n        value = colorArray;\n        isValueColor = true;\n      } else {\n        isValueString = true;\n      }\n    }\n\n    kfValues.push(value);\n  }\n\n  if (!forceAnimate && isAllValueEqual) {\n    return;\n  }\n\n  var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value\n\n  for (var i = 0; i < trackLen - 1; i++) {\n    if (isValueArray) {\n      fillArr(kfValues[i], lastValue, arrDim);\n    } else {\n      if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n        kfValues[i] = lastValue;\n      }\n    }\n  }\n\n  isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when\n  // animation playback is sequency\n\n  var lastFrame = 0;\n  var lastFramePercent = 0;\n  var start;\n  var w;\n  var p0;\n  var p1;\n  var p2;\n  var p3;\n\n  if (isValueColor) {\n    var rgba = [0, 0, 0, 0];\n  }\n\n  var onframe = function (target, percent) {\n    // Find the range keyframes\n    // kf1-----kf2---------current--------kf3\n    // find kf2 and kf3 and do interpolation\n    var frame; // In the easing function like elasticOut, percent may less than 0\n\n    if (percent < 0) {\n      frame = 0;\n    } else if (percent < lastFramePercent) {\n      // Start from next key\n      // PENDING start from lastFrame ?\n      start = Math.min(lastFrame + 1, trackLen - 1);\n\n      for (frame = start; frame >= 0; frame--) {\n        if (kfPercents[frame] <= percent) {\n          break;\n        }\n      } // PENDING really need to do this ?\n\n\n      frame = Math.min(frame, trackLen - 2);\n    } else {\n      for (frame = lastFrame; frame < trackLen; frame++) {\n        if (kfPercents[frame] > percent) {\n          break;\n        }\n      }\n\n      frame = Math.min(frame - 1, trackLen - 2);\n    }\n\n    lastFrame = frame;\n    lastFramePercent = percent;\n    var range = kfPercents[frame + 1] - kfPercents[frame];\n\n    if (range === 0) {\n      return;\n    } else {\n      w = (percent - kfPercents[frame]) / range;\n    }\n\n    if (useSpline) {\n      p1 = kfValues[frame];\n      p0 = kfValues[frame === 0 ? frame : frame - 1];\n      p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n      p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\n      if (isValueArray) {\n        catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);\n      } else {\n        var value;\n\n        if (isValueColor) {\n          value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);\n          value = rgba2String(rgba);\n        } else if (isValueString) {\n          // String is step(0.5)\n          return interpolateString(p1, p2, w);\n        } else {\n          value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);\n        }\n\n        setter(target, propName, value);\n      }\n    } else {\n      if (isValueArray) {\n        interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);\n      } else {\n        var value;\n\n        if (isValueColor) {\n          interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);\n          value = rgba2String(rgba);\n        } else if (isValueString) {\n          // String is step(0.5)\n          return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n        } else {\n          value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n        }\n\n        setter(target, propName, value);\n      }\n    }\n  };\n\n  var clip = new Clip({\n    target: animator._target,\n    life: trackMaxTime,\n    loop: animator._loop,\n    delay: animator._delay,\n    onframe: onframe,\n    ondestroy: oneTrackDone\n  });\n\n  if (easing && easing !== 'spline') {\n    clip.easing = easing;\n  }\n\n  return clip;\n}\n/**\n * @alias module:zrender/animation/Animator\n * @constructor\n * @param {Object} target\n * @param {boolean} loop\n * @param {Function} getter\n * @param {Function} setter\n */\n\n\nvar Animator = function (target, loop, getter, setter) {\n  this._tracks = {};\n  this._target = target;\n  this._loop = loop || false;\n  this._getter = getter || defaultGetter;\n  this._setter = setter || defaultSetter;\n  this._clipCount = 0;\n  this._delay = 0;\n  this._doneList = [];\n  this._onframeList = [];\n  this._clipList = [];\n};\n\nAnimator.prototype = {\n  /**\n   * 设置动画关键帧\n   * @param  {number} time 关键帧时间，单位是ms\n   * @param  {Object} props 关键帧的属性值，key-value表示\n   * @return {module:zrender/animation/Animator}\n   */\n  when: function (time\n  /* ms */\n  , props) {\n    var tracks = this._tracks;\n\n    for (var propName in props) {\n      if (!props.hasOwnProperty(propName)) {\n        continue;\n      }\n\n      if (!tracks[propName]) {\n        tracks[propName] = []; // Invalid value\n\n        var value = this._getter(this._target, propName);\n\n        if (value == null) {\n          // zrLog('Invalid property ' + propName);\n          continue;\n        } // If time is 0\n        //  Then props is given initialize value\n        // Else\n        //  Initialize value from current prop value\n\n\n        if (time !== 0) {\n          tracks[propName].push({\n            time: 0,\n            value: cloneValue(value)\n          });\n        }\n      }\n\n      tracks[propName].push({\n        time: time,\n        value: props[propName]\n      });\n    }\n\n    return this;\n  },\n\n  /**\n   * 添加动画每一帧的回调函数\n   * @param  {Function} callback\n   * @return {module:zrender/animation/Animator}\n   */\n  during: function (callback) {\n    this._onframeList.push(callback);\n\n    return this;\n  },\n  pause: function () {\n    for (var i = 0; i < this._clipList.length; i++) {\n      this._clipList[i].pause();\n    }\n\n    this._paused = true;\n  },\n  resume: function () {\n    for (var i = 0; i < this._clipList.length; i++) {\n      this._clipList[i].resume();\n    }\n\n    this._paused = false;\n  },\n  isPaused: function () {\n    return !!this._paused;\n  },\n  _doneCallback: function () {\n    // Clear all tracks\n    this._tracks = {}; // Clear all clips\n\n    this._clipList.length = 0;\n    var doneList = this._doneList;\n    var len = doneList.length;\n\n    for (var i = 0; i < len; i++) {\n      doneList[i].call(this);\n    }\n  },\n\n  /**\n   * 开始执行动画\n   * @param  {string|Function} [easing]\n   *         动画缓动函数，详见{@link module:zrender/animation/easing}\n   * @param  {boolean} forceAnimate\n   * @return {module:zrender/animation/Animator}\n   */\n  start: function (easing, forceAnimate) {\n    var self = this;\n    var clipCount = 0;\n\n    var oneTrackDone = function () {\n      clipCount--;\n\n      if (!clipCount) {\n        self._doneCallback();\n      }\n    };\n\n    var lastClip;\n\n    for (var propName in this._tracks) {\n      if (!this._tracks.hasOwnProperty(propName)) {\n        continue;\n      }\n\n      var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);\n\n      if (clip) {\n        this._clipList.push(clip);\n\n        clipCount++; // If start after added to animation\n\n        if (this.animation) {\n          this.animation.addClip(clip);\n        }\n\n        lastClip = clip;\n      }\n    } // Add during callback on the last clip\n\n\n    if (lastClip) {\n      var oldOnFrame = lastClip.onframe;\n\n      lastClip.onframe = function (target, percent) {\n        oldOnFrame(target, percent);\n\n        for (var i = 0; i < self._onframeList.length; i++) {\n          self._onframeList[i](target, percent);\n        }\n      };\n    } // This optimization will help the case that in the upper application\n    // the view may be refreshed frequently, where animation will be\n    // called repeatly but nothing changed.\n\n\n    if (!clipCount) {\n      this._doneCallback();\n    }\n\n    return this;\n  },\n\n  /**\n   * 停止动画\n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stop: function (forwardToLast) {\n    var clipList = this._clipList;\n    var animation = this.animation;\n\n    for (var i = 0; i < clipList.length; i++) {\n      var clip = clipList[i];\n\n      if (forwardToLast) {\n        // Move to last frame before stop\n        clip.onframe(this._target, 1);\n      }\n\n      animation && animation.removeClip(clip);\n    }\n\n    clipList.length = 0;\n  },\n\n  /**\n   * 设置动画延迟开始的时间\n   * @param  {number} time 单位ms\n   * @return {module:zrender/animation/Animator}\n   */\n  delay: function (time) {\n    this._delay = time;\n    return this;\n  },\n\n  /**\n   * 添加动画结束的回调\n   * @param  {Function} cb\n   * @return {module:zrender/animation/Animator}\n   */\n  done: function (cb) {\n    if (cb) {\n      this._doneList.push(cb);\n    }\n\n    return this;\n  },\n\n  /**\n   * @return {Array.<module:zrender/animation/Clip>}\n   */\n  getClips: function () {\n    return this._clipList;\n  }\n};\nvar _default = Animator;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Animator.js\n// module id = 16\n// module chunks = 0","var easingFuncs = require(\"./easing\");\n\n/**\n * 动画主控制器\n * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\n * @config life(1000) 动画时长\n * @config delay(0) 动画延迟时间\n * @config loop(true)\n * @config gap(0) 循环的间隔时间\n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\nfunction Clip(options) {\n  this._target = options.target; // 生命周期\n\n  this._life = options.life || 1000; // 延时\n\n  this._delay = options.delay || 0; // 开始时间\n  // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n\n  this._initialized = false; // 是否循环\n\n  this.loop = options.loop == null ? false : options.loop;\n  this.gap = options.gap || 0;\n  this.easing = options.easing || 'Linear';\n  this.onframe = options.onframe;\n  this.ondestroy = options.ondestroy;\n  this.onrestart = options.onrestart;\n  this._pausedTime = 0;\n  this._paused = false;\n}\n\nClip.prototype = {\n  constructor: Clip,\n  step: function (globalTime, deltaTime) {\n    // Set startTime on first step, or _startTime may has milleseconds different between clips\n    // PENDING\n    if (!this._initialized) {\n      this._startTime = globalTime + this._delay;\n      this._initialized = true;\n    }\n\n    if (this._paused) {\n      this._pausedTime += deltaTime;\n      return;\n    }\n\n    var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // 还没开始\n\n    if (percent < 0) {\n      return;\n    }\n\n    percent = Math.min(percent, 1);\n    var easing = this.easing;\n    var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n    var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;\n    this.fire('frame', schedule); // 结束\n\n    if (percent == 1) {\n      if (this.loop) {\n        this.restart(globalTime); // 重新开始周期\n        // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n\n        return 'restart';\n      } // 动画完成将这个控制器标识为待删除\n      // 在Animation.update中进行批量删除\n\n\n      this._needsRemove = true;\n      return 'destroy';\n    }\n\n    return null;\n  },\n  restart: function (globalTime) {\n    var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n    this._startTime = globalTime - remainder + this.gap;\n    this._pausedTime = 0;\n    this._needsRemove = false;\n  },\n  fire: function (eventType, arg) {\n    eventType = 'on' + eventType;\n\n    if (this[eventType]) {\n      this[eventType](this._target, arg);\n    }\n  },\n  pause: function () {\n    this._paused = true;\n  },\n  resume: function () {\n    this._paused = false;\n  }\n};\nvar _default = Clip;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Clip.js\n// module id = 17\n// module chunks = 0","/**\n * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\nvar easing = {\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  linear: function (k) {\n    return k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticIn: function (k) {\n    return k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticOut: function (k) {\n    return k * (2 - k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k;\n    }\n\n    return -0.5 * (--k * (k - 2) - 1);\n  },\n  // 三次方的缓动（t^3）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicIn: function (k) {\n    return k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicOut: function (k) {\n    return --k * k * k + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k;\n    }\n\n    return 0.5 * ((k -= 2) * k * k + 2);\n  },\n  // 四次方的缓动（t^4）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticIn: function (k) {\n    return k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticOut: function (k) {\n    return 1 - --k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k * k;\n    }\n\n    return -0.5 * ((k -= 2) * k * k * k - 2);\n  },\n  // 五次方的缓动（t^5）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticIn: function (k) {\n    return k * k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticOut: function (k) {\n    return --k * k * k * k * k + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k * k * k;\n    }\n\n    return 0.5 * ((k -= 2) * k * k * k * k + 2);\n  },\n  // 正弦曲线的缓动（sin(t)）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalIn: function (k) {\n    return 1 - Math.cos(k * Math.PI / 2);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalOut: function (k) {\n    return Math.sin(k * Math.PI / 2);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalInOut: function (k) {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n  },\n  // 指数曲线的缓动（2^t）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialIn: function (k) {\n    return k === 0 ? 0 : Math.pow(1024, k - 1);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialOut: function (k) {\n    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialInOut: function (k) {\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if ((k *= 2) < 1) {\n      return 0.5 * Math.pow(1024, k - 1);\n    }\n\n    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n  },\n  // 圆形曲线的缓动（sqrt(1-t^2)）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularIn: function (k) {\n    return 1 - Math.sqrt(1 - k * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularOut: function (k) {\n    return Math.sqrt(1 - --k * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return -0.5 * (Math.sqrt(1 - k * k) - 1);\n    }\n\n    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n  },\n  // 创建类似于弹簧在停止前来回振荡的动画\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticIn: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticOut: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticInOut: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    if ((k *= 2) < 1) {\n      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n    }\n\n    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n  },\n  // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backIn: function (k) {\n    var s = 1.70158;\n    return k * k * ((s + 1) * k - s);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backOut: function (k) {\n    var s = 1.70158;\n    return --k * k * ((s + 1) * k + s) + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backInOut: function (k) {\n    var s = 1.70158 * 1.525;\n\n    if ((k *= 2) < 1) {\n      return 0.5 * (k * k * ((s + 1) * k - s));\n    }\n\n    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n  },\n  // 创建弹跳效果\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceIn: function (k) {\n    return 1 - easing.bounceOut(1 - k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceOut: function (k) {\n    if (k < 1 / 2.75) {\n      return 7.5625 * k * k;\n    } else if (k < 2 / 2.75) {\n      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n    } else if (k < 2.5 / 2.75) {\n      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n    } else {\n      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n    }\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceInOut: function (k) {\n    if (k < 0.5) {\n      return easing.bounceIn(k * 2) * 0.5;\n    }\n\n    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n  }\n};\nvar _default = easing;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/easing.js\n// module id = 18\n// module chunks = 0","var LRU = require(\"../core/LRU\");\n\nvar kCSSColorTable = {\n  'transparent': [0, 0, 0, 0],\n  'aliceblue': [240, 248, 255, 1],\n  'antiquewhite': [250, 235, 215, 1],\n  'aqua': [0, 255, 255, 1],\n  'aquamarine': [127, 255, 212, 1],\n  'azure': [240, 255, 255, 1],\n  'beige': [245, 245, 220, 1],\n  'bisque': [255, 228, 196, 1],\n  'black': [0, 0, 0, 1],\n  'blanchedalmond': [255, 235, 205, 1],\n  'blue': [0, 0, 255, 1],\n  'blueviolet': [138, 43, 226, 1],\n  'brown': [165, 42, 42, 1],\n  'burlywood': [222, 184, 135, 1],\n  'cadetblue': [95, 158, 160, 1],\n  'chartreuse': [127, 255, 0, 1],\n  'chocolate': [210, 105, 30, 1],\n  'coral': [255, 127, 80, 1],\n  'cornflowerblue': [100, 149, 237, 1],\n  'cornsilk': [255, 248, 220, 1],\n  'crimson': [220, 20, 60, 1],\n  'cyan': [0, 255, 255, 1],\n  'darkblue': [0, 0, 139, 1],\n  'darkcyan': [0, 139, 139, 1],\n  'darkgoldenrod': [184, 134, 11, 1],\n  'darkgray': [169, 169, 169, 1],\n  'darkgreen': [0, 100, 0, 1],\n  'darkgrey': [169, 169, 169, 1],\n  'darkkhaki': [189, 183, 107, 1],\n  'darkmagenta': [139, 0, 139, 1],\n  'darkolivegreen': [85, 107, 47, 1],\n  'darkorange': [255, 140, 0, 1],\n  'darkorchid': [153, 50, 204, 1],\n  'darkred': [139, 0, 0, 1],\n  'darksalmon': [233, 150, 122, 1],\n  'darkseagreen': [143, 188, 143, 1],\n  'darkslateblue': [72, 61, 139, 1],\n  'darkslategray': [47, 79, 79, 1],\n  'darkslategrey': [47, 79, 79, 1],\n  'darkturquoise': [0, 206, 209, 1],\n  'darkviolet': [148, 0, 211, 1],\n  'deeppink': [255, 20, 147, 1],\n  'deepskyblue': [0, 191, 255, 1],\n  'dimgray': [105, 105, 105, 1],\n  'dimgrey': [105, 105, 105, 1],\n  'dodgerblue': [30, 144, 255, 1],\n  'firebrick': [178, 34, 34, 1],\n  'floralwhite': [255, 250, 240, 1],\n  'forestgreen': [34, 139, 34, 1],\n  'fuchsia': [255, 0, 255, 1],\n  'gainsboro': [220, 220, 220, 1],\n  'ghostwhite': [248, 248, 255, 1],\n  'gold': [255, 215, 0, 1],\n  'goldenrod': [218, 165, 32, 1],\n  'gray': [128, 128, 128, 1],\n  'green': [0, 128, 0, 1],\n  'greenyellow': [173, 255, 47, 1],\n  'grey': [128, 128, 128, 1],\n  'honeydew': [240, 255, 240, 1],\n  'hotpink': [255, 105, 180, 1],\n  'indianred': [205, 92, 92, 1],\n  'indigo': [75, 0, 130, 1],\n  'ivory': [255, 255, 240, 1],\n  'khaki': [240, 230, 140, 1],\n  'lavender': [230, 230, 250, 1],\n  'lavenderblush': [255, 240, 245, 1],\n  'lawngreen': [124, 252, 0, 1],\n  'lemonchiffon': [255, 250, 205, 1],\n  'lightblue': [173, 216, 230, 1],\n  'lightcoral': [240, 128, 128, 1],\n  'lightcyan': [224, 255, 255, 1],\n  'lightgoldenrodyellow': [250, 250, 210, 1],\n  'lightgray': [211, 211, 211, 1],\n  'lightgreen': [144, 238, 144, 1],\n  'lightgrey': [211, 211, 211, 1],\n  'lightpink': [255, 182, 193, 1],\n  'lightsalmon': [255, 160, 122, 1],\n  'lightseagreen': [32, 178, 170, 1],\n  'lightskyblue': [135, 206, 250, 1],\n  'lightslategray': [119, 136, 153, 1],\n  'lightslategrey': [119, 136, 153, 1],\n  'lightsteelblue': [176, 196, 222, 1],\n  'lightyellow': [255, 255, 224, 1],\n  'lime': [0, 255, 0, 1],\n  'limegreen': [50, 205, 50, 1],\n  'linen': [250, 240, 230, 1],\n  'magenta': [255, 0, 255, 1],\n  'maroon': [128, 0, 0, 1],\n  'mediumaquamarine': [102, 205, 170, 1],\n  'mediumblue': [0, 0, 205, 1],\n  'mediumorchid': [186, 85, 211, 1],\n  'mediumpurple': [147, 112, 219, 1],\n  'mediumseagreen': [60, 179, 113, 1],\n  'mediumslateblue': [123, 104, 238, 1],\n  'mediumspringgreen': [0, 250, 154, 1],\n  'mediumturquoise': [72, 209, 204, 1],\n  'mediumvioletred': [199, 21, 133, 1],\n  'midnightblue': [25, 25, 112, 1],\n  'mintcream': [245, 255, 250, 1],\n  'mistyrose': [255, 228, 225, 1],\n  'moccasin': [255, 228, 181, 1],\n  'navajowhite': [255, 222, 173, 1],\n  'navy': [0, 0, 128, 1],\n  'oldlace': [253, 245, 230, 1],\n  'olive': [128, 128, 0, 1],\n  'olivedrab': [107, 142, 35, 1],\n  'orange': [255, 165, 0, 1],\n  'orangered': [255, 69, 0, 1],\n  'orchid': [218, 112, 214, 1],\n  'palegoldenrod': [238, 232, 170, 1],\n  'palegreen': [152, 251, 152, 1],\n  'paleturquoise': [175, 238, 238, 1],\n  'palevioletred': [219, 112, 147, 1],\n  'papayawhip': [255, 239, 213, 1],\n  'peachpuff': [255, 218, 185, 1],\n  'peru': [205, 133, 63, 1],\n  'pink': [255, 192, 203, 1],\n  'plum': [221, 160, 221, 1],\n  'powderblue': [176, 224, 230, 1],\n  'purple': [128, 0, 128, 1],\n  'red': [255, 0, 0, 1],\n  'rosybrown': [188, 143, 143, 1],\n  'royalblue': [65, 105, 225, 1],\n  'saddlebrown': [139, 69, 19, 1],\n  'salmon': [250, 128, 114, 1],\n  'sandybrown': [244, 164, 96, 1],\n  'seagreen': [46, 139, 87, 1],\n  'seashell': [255, 245, 238, 1],\n  'sienna': [160, 82, 45, 1],\n  'silver': [192, 192, 192, 1],\n  'skyblue': [135, 206, 235, 1],\n  'slateblue': [106, 90, 205, 1],\n  'slategray': [112, 128, 144, 1],\n  'slategrey': [112, 128, 144, 1],\n  'snow': [255, 250, 250, 1],\n  'springgreen': [0, 255, 127, 1],\n  'steelblue': [70, 130, 180, 1],\n  'tan': [210, 180, 140, 1],\n  'teal': [0, 128, 128, 1],\n  'thistle': [216, 191, 216, 1],\n  'tomato': [255, 99, 71, 1],\n  'turquoise': [64, 224, 208, 1],\n  'violet': [238, 130, 238, 1],\n  'wheat': [245, 222, 179, 1],\n  'white': [255, 255, 255, 1],\n  'whitesmoke': [245, 245, 245, 1],\n  'yellow': [255, 255, 0, 1],\n  'yellowgreen': [154, 205, 50, 1]\n};\n\nfunction clampCssByte(i) {\n  // Clamp to integer 0 .. 255.\n  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\n  return i < 0 ? 0 : i > 255 ? 255 : i;\n}\n\nfunction clampCssAngle(i) {\n  // Clamp to integer 0 .. 360.\n  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\n  return i < 0 ? 0 : i > 360 ? 360 : i;\n}\n\nfunction clampCssFloat(f) {\n  // Clamp to float 0.0 .. 1.0.\n  return f < 0 ? 0 : f > 1 ? 1 : f;\n}\n\nfunction parseCssInt(str) {\n  // int or percentage.\n  if (str.length && str.charAt(str.length - 1) === '%') {\n    return clampCssByte(parseFloat(str) / 100 * 255);\n  }\n\n  return clampCssByte(parseInt(str, 10));\n}\n\nfunction parseCssFloat(str) {\n  // float or percentage.\n  if (str.length && str.charAt(str.length - 1) === '%') {\n    return clampCssFloat(parseFloat(str) / 100);\n  }\n\n  return clampCssFloat(parseFloat(str));\n}\n\nfunction cssHueToRgb(m1, m2, h) {\n  if (h < 0) {\n    h += 1;\n  } else if (h > 1) {\n    h -= 1;\n  }\n\n  if (h * 6 < 1) {\n    return m1 + (m2 - m1) * h * 6;\n  }\n\n  if (h * 2 < 1) {\n    return m2;\n  }\n\n  if (h * 3 < 2) {\n    return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n  }\n\n  return m1;\n}\n\nfunction lerpNumber(a, b, p) {\n  return a + (b - a) * p;\n}\n\nfunction setRgba(out, r, g, b, a) {\n  out[0] = r;\n  out[1] = g;\n  out[2] = b;\n  out[3] = a;\n  return out;\n}\n\nfunction copyRgba(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\nvar colorCache = new LRU(20);\nvar lastRemovedArr = null;\n\nfunction putToCache(colorStr, rgbaArr) {\n  // Reuse removed array\n  if (lastRemovedArr) {\n    copyRgba(lastRemovedArr, rgbaArr);\n  }\n\n  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());\n}\n/**\n * @param {string} colorStr\n * @param {Array.<number>} out\n * @return {Array.<number>}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction parse(colorStr, rgbaArr) {\n  if (!colorStr) {\n    return;\n  }\n\n  rgbaArr = rgbaArr || [];\n  var cached = colorCache.get(colorStr);\n\n  if (cached) {\n    return copyRgba(rgbaArr, cached);\n  } // colorStr may be not string\n\n\n  colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.\n\n  var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.\n\n  if (str in kCSSColorTable) {\n    copyRgba(rgbaArr, kCSSColorTable[str]);\n    putToCache(colorStr, rgbaArr);\n    return rgbaArr;\n  } // #abc and #abc123 syntax.\n\n\n  if (str.charAt(0) === '#') {\n    if (str.length === 4) {\n      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\n      if (!(iv >= 0 && iv <= 0xfff)) {\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return; // Covers NaN.\n      }\n\n      setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);\n      putToCache(colorStr, rgbaArr);\n      return rgbaArr;\n    } else if (str.length === 7) {\n      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\n      if (!(iv >= 0 && iv <= 0xffffff)) {\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return; // Covers NaN.\n      }\n\n      setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);\n      putToCache(colorStr, rgbaArr);\n      return rgbaArr;\n    }\n\n    return;\n  }\n\n  var op = str.indexOf('('),\n      ep = str.indexOf(')');\n\n  if (op !== -1 && ep + 1 === str.length) {\n    var fname = str.substr(0, op);\n    var params = str.substr(op + 1, ep - (op + 1)).split(',');\n    var alpha = 1; // To allow case fallthrough.\n\n    switch (fname) {\n      case 'rgba':\n        if (params.length !== 4) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        alpha = parseCssFloat(params.pop());\n      // jshint ignore:line\n      // Fall through.\n\n      case 'rgb':\n        if (params.length !== 3) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      case 'hsla':\n        if (params.length !== 4) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        params[3] = parseCssFloat(params[3]);\n        hsla2rgba(params, rgbaArr);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      case 'hsl':\n        if (params.length !== 3) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        hsla2rgba(params, rgbaArr);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      default:\n        return;\n    }\n  }\n\n  setRgba(rgbaArr, 0, 0, 0, 1);\n  return;\n}\n/**\n * @param {Array.<number>} hsla\n * @param {Array.<number>} rgba\n * @return {Array.<number>} rgba\n */\n\n\nfunction hsla2rgba(hsla, rgba) {\n  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1\n  // NOTE(deanm): According to the CSS spec s/l should only be\n  // percentages, but we don't bother and let float or percentage.\n\n  var s = parseCssFloat(hsla[1]);\n  var l = parseCssFloat(hsla[2]);\n  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n  var m1 = l * 2 - m2;\n  rgba = rgba || [];\n  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);\n\n  if (hsla.length === 4) {\n    rgba[3] = hsla[3];\n  }\n\n  return rgba;\n}\n/**\n * @param {Array.<number>} rgba\n * @return {Array.<number>} hsla\n */\n\n\nfunction rgba2hsla(rgba) {\n  if (!rgba) {\n    return;\n  } // RGB from 0 to 255\n\n\n  var R = rgba[0] / 255;\n  var G = rgba[1] / 255;\n  var B = rgba[2] / 255;\n  var vMin = Math.min(R, G, B); // Min. value of RGB\n\n  var vMax = Math.max(R, G, B); // Max. value of RGB\n\n  var delta = vMax - vMin; // Delta RGB value\n\n  var L = (vMax + vMin) / 2;\n  var H;\n  var S; // HSL results from 0 to 1\n\n  if (delta === 0) {\n    H = 0;\n    S = 0;\n  } else {\n    if (L < 0.5) {\n      S = delta / (vMax + vMin);\n    } else {\n      S = delta / (2 - vMax - vMin);\n    }\n\n    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;\n    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;\n    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;\n\n    if (R === vMax) {\n      H = deltaB - deltaG;\n    } else if (G === vMax) {\n      H = 1 / 3 + deltaR - deltaB;\n    } else if (B === vMax) {\n      H = 2 / 3 + deltaG - deltaR;\n    }\n\n    if (H < 0) {\n      H += 1;\n    }\n\n    if (H > 1) {\n      H -= 1;\n    }\n  }\n\n  var hsla = [H * 360, S, L];\n\n  if (rgba[3] != null) {\n    hsla.push(rgba[3]);\n  }\n\n  return hsla;\n}\n/**\n * @param {string} color\n * @param {number} level\n * @return {string}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction lift(color, level) {\n  var colorArr = parse(color);\n\n  if (colorArr) {\n    for (var i = 0; i < 3; i++) {\n      if (level < 0) {\n        colorArr[i] = colorArr[i] * (1 - level) | 0;\n      } else {\n        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;\n      }\n    }\n\n    return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n  }\n}\n/**\n * @param {string} color\n * @return {string}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction toHex(color) {\n  var colorArr = parse(color);\n\n  if (colorArr) {\n    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);\n  }\n}\n/**\n * Map value to color. Faster than lerp methods because color is represented by rgba array.\n * @param {number} normalizedValue A float between 0 and 1.\n * @param {Array.<Array.<number>>} colors List of rgba color array\n * @param {Array.<number>} [out] Mapped gba color array\n * @return {Array.<number>} will be null/undefined if input illegal.\n */\n\n\nfunction fastLerp(normalizedValue, colors, out) {\n  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n    return;\n  }\n\n  out = out || [];\n  var value = normalizedValue * (colors.length - 1);\n  var leftIndex = Math.floor(value);\n  var rightIndex = Math.ceil(value);\n  var leftColor = colors[leftIndex];\n  var rightColor = colors[rightIndex];\n  var dv = value - leftIndex;\n  out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));\n  out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));\n  out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));\n  out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));\n  return out;\n}\n/**\n * @deprecated\n */\n\n\nvar fastMapToColor = fastLerp;\n/**\n * @param {number} normalizedValue A float between 0 and 1.\n * @param {Array.<string>} colors Color list.\n * @param {boolean=} fullOutput Default false.\n * @return {(string|Object)} Result color. If fullOutput,\n *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n * @memberOf module:zrender/util/color\n */\n\nfunction lerp(normalizedValue, colors, fullOutput) {\n  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n    return;\n  }\n\n  var value = normalizedValue * (colors.length - 1);\n  var leftIndex = Math.floor(value);\n  var rightIndex = Math.ceil(value);\n  var leftColor = parse(colors[leftIndex]);\n  var rightColor = parse(colors[rightIndex]);\n  var dv = value - leftIndex;\n  var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');\n  return fullOutput ? {\n    color: color,\n    leftIndex: leftIndex,\n    rightIndex: rightIndex,\n    value: value\n  } : color;\n}\n/**\n * @deprecated\n */\n\n\nvar mapToColor = lerp;\n/**\n * @param {string} color\n * @param {number=} h 0 ~ 360, ignore when null.\n * @param {number=} s 0 ~ 1, ignore when null.\n * @param {number=} l 0 ~ 1, ignore when null.\n * @return {string} Color string in rgba format.\n * @memberOf module:zrender/util/color\n */\n\nfunction modifyHSL(color, h, s, l) {\n  color = parse(color);\n\n  if (color) {\n    color = rgba2hsla(color);\n    h != null && (color[0] = clampCssAngle(h));\n    s != null && (color[1] = parseCssFloat(s));\n    l != null && (color[2] = parseCssFloat(l));\n    return stringify(hsla2rgba(color), 'rgba');\n  }\n}\n/**\n * @param {string} color\n * @param {number=} alpha 0 ~ 1\n * @return {string} Color string in rgba format.\n * @memberOf module:zrender/util/color\n */\n\n\nfunction modifyAlpha(color, alpha) {\n  color = parse(color);\n\n  if (color && alpha != null) {\n    color[3] = clampCssFloat(alpha);\n    return stringify(color, 'rgba');\n  }\n}\n/**\n * @param {Array.<number>} arrColor like [12,33,44,0.4]\n * @param {string} type 'rgba', 'hsva', ...\n * @return {string} Result color. (If input illegal, return undefined).\n */\n\n\nfunction stringify(arrColor, type) {\n  if (!arrColor || !arrColor.length) {\n    return;\n  }\n\n  var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\n  if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n    colorStr += ',' + arrColor[3];\n  }\n\n  return type + '(' + colorStr + ')';\n}\n\nexports.parse = parse;\nexports.lift = lift;\nexports.toHex = toHex;\nexports.fastLerp = fastLerp;\nexports.fastMapToColor = fastMapToColor;\nexports.lerp = lerp;\nexports.mapToColor = mapToColor;\nexports.modifyHSL = modifyHSL;\nexports.modifyAlpha = modifyAlpha;\nexports.stringify = stringify;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/color.js\n// module id = 19\n// module chunks = 0","// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n/**\n * Simple double linked list. Compared with array, it has O(1) remove operation.\n * @constructor\n */\nvar LinkedList = function () {\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n  this.head = null;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.tail = null;\n  this._len = 0;\n};\n\nvar linkedListProto = LinkedList.prototype;\n/**\n * Insert a new value at the tail\n * @param  {} val\n * @return {module:zrender/core/LRU~Entry}\n */\n\nlinkedListProto.insert = function (val) {\n  var entry = new Entry(val);\n  this.insertEntry(entry);\n  return entry;\n};\n/**\n * Insert an entry at the tail\n * @param  {module:zrender/core/LRU~Entry} entry\n */\n\n\nlinkedListProto.insertEntry = function (entry) {\n  if (!this.head) {\n    this.head = this.tail = entry;\n  } else {\n    this.tail.next = entry;\n    entry.prev = this.tail;\n    entry.next = null;\n    this.tail = entry;\n  }\n\n  this._len++;\n};\n/**\n * Remove entry.\n * @param  {module:zrender/core/LRU~Entry} entry\n */\n\n\nlinkedListProto.remove = function (entry) {\n  var prev = entry.prev;\n  var next = entry.next;\n\n  if (prev) {\n    prev.next = next;\n  } else {\n    // Is head\n    this.head = next;\n  }\n\n  if (next) {\n    next.prev = prev;\n  } else {\n    // Is tail\n    this.tail = prev;\n  }\n\n  entry.next = entry.prev = null;\n  this._len--;\n};\n/**\n * @return {number}\n */\n\n\nlinkedListProto.len = function () {\n  return this._len;\n};\n/**\n * Clear list\n */\n\n\nlinkedListProto.clear = function () {\n  this.head = this.tail = null;\n  this._len = 0;\n};\n/**\n * @constructor\n * @param {} val\n */\n\n\nvar Entry = function (val) {\n  /**\n   * @type {}\n   */\n  this.value = val;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.next;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.prev;\n};\n/**\n * LRU Cache\n * @constructor\n * @alias module:zrender/core/LRU\n */\n\n\nvar LRU = function (maxSize) {\n  this._list = new LinkedList();\n  this._map = {};\n  this._maxSize = maxSize || 10;\n  this._lastRemovedEntry = null;\n};\n\nvar LRUProto = LRU.prototype;\n/**\n * @param  {string} key\n * @param  {} value\n * @return {} Removed value\n */\n\nLRUProto.put = function (key, value) {\n  var list = this._list;\n  var map = this._map;\n  var removed = null;\n\n  if (map[key] == null) {\n    var len = list.len(); // Reuse last removed entry\n\n    var entry = this._lastRemovedEntry;\n\n    if (len >= this._maxSize && len > 0) {\n      // Remove the least recently used\n      var leastUsedEntry = list.head;\n      list.remove(leastUsedEntry);\n      delete map[leastUsedEntry.key];\n      removed = leastUsedEntry.value;\n      this._lastRemovedEntry = leastUsedEntry;\n    }\n\n    if (entry) {\n      entry.value = value;\n    } else {\n      entry = new Entry(value);\n    }\n\n    entry.key = key;\n    list.insertEntry(entry);\n    map[key] = entry;\n  }\n\n  return removed;\n};\n/**\n * @param  {string} key\n * @return {}\n */\n\n\nLRUProto.get = function (key) {\n  var entry = this._map[key];\n  var list = this._list;\n\n  if (entry != null) {\n    // Put the latest used entry in the tail\n    if (entry !== list.tail) {\n      list.remove(entry);\n      list.insertEntry(entry);\n    }\n\n    return entry.value;\n  }\n};\n/**\n * Clear the cache\n */\n\n\nLRUProto.clear = function () {\n  this._list.clear();\n\n  this._map = {};\n};\n\nvar _default = LRU;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/LRU.js\n// module id = 20\n// module chunks = 0","var _config = require(\"../config\");\n\nvar debugMode = _config.debugMode;\n\nvar log = function () {};\n\nif (debugMode === 1) {\n  log = function () {\n    for (var k in arguments) {\n      throw new Error(arguments[k]);\n    }\n  };\n} else if (debugMode > 1) {\n  log = function () {\n    for (var k in arguments) {\n      console.log(arguments[k]);\n    }\n  };\n}\n\nvar _default = log;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/log.js\n// module id = 21\n// module chunks = 0","var dpr = 1; // If in browser environment\n\nif (typeof window !== 'undefined') {\n  dpr = Math.max(window.devicePixelRatio || 1, 1);\n}\n/**\n * config默认配置项\n * @exports zrender/config\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n */\n\n/**\n * debug日志选项：catchBrushException为true下有效\n * 0 : 不生成debug数据，发布用\n * 1 : 异常抛出，调试用\n * 2 : 控制台输出，调试用\n */\n\n\nvar debugMode = 0; // retina 屏幕优化\n\nvar devicePixelRatio = dpr;\nexports.debugMode = debugMode;\nexports.devicePixelRatio = devicePixelRatio;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/config.js\n// module id = 22\n// module chunks = 0","var textHelper = require(\"../helper/text\");\n\nvar BoundingRect = require(\"../../core/BoundingRect\");\n\n/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\nvar tmpRect = new BoundingRect();\n\nvar RectText = function () {};\n\nRectText.prototype = {\n  constructor: RectText,\n\n  /**\n   * Draw text in a rect with specified position.\n   * @param  {CanvasRenderingContext2D} ctx\n   * @param  {Object} rect Displayable rect\n   */\n  drawRectText: function (ctx, rect) {\n    var style = this.style;\n    rect = style.textRect || rect; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true);\n    var text = style.text; // Convert to string\n\n    text != null && (text += '');\n\n    if (!textHelper.needDrawText(text, style)) {\n      return;\n    } // FIXME\n\n\n    ctx.save(); // Transform rect to view space\n\n    var transform = this.transform;\n\n    if (!style.transformText) {\n      if (transform) {\n        tmpRect.copy(rect);\n        tmpRect.applyTransform(transform);\n        rect = tmpRect;\n      }\n    } else {\n      this.setTransform(ctx);\n    } // transformText and textRotation can not be used at the same time.\n\n\n    textHelper.renderText(this, ctx, text, style, rect);\n    ctx.restore();\n  }\n};\nvar _default = RectText;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/mixin/RectText.js\n// module id = 23\n// module chunks = 0","var _util = require(\"../../core/util\");\n\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar each = _util.each;\nvar normalizeCssArray = _util.normalizeCssArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\n\nvar textContain = require(\"../../contain/text\");\n\nvar roundRectHelper = require(\"./roundRect\");\n\nvar imageHelper = require(\"./image\");\n\n// TODO: Have not support 'start', 'end' yet.\nvar VALID_TEXT_ALIGN = {\n  left: 1,\n  right: 1,\n  center: 1\n};\nvar VALID_TEXT_VERTICAL_ALIGN = {\n  top: 1,\n  bottom: 1,\n  middle: 1\n};\n/**\n * @param {module:zrender/graphic/Style} style\n * @return {module:zrender/graphic/Style} The input style.\n */\n\nfunction normalizeTextStyle(style) {\n  normalizeStyle(style);\n  each(style.rich, normalizeStyle);\n  return style;\n}\n\nfunction normalizeStyle(style) {\n  if (style) {\n    style.font = textContain.makeFont(style);\n    var textAlign = style.textAlign;\n    textAlign === 'middle' && (textAlign = 'center');\n    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.\n\n    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';\n    var textPadding = style.textPadding;\n\n    if (textPadding) {\n      style.textPadding = normalizeCssArray(style.textPadding);\n    }\n  }\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {string} text\n * @param {module:zrender/graphic/Style} style\n * @param {Object|boolean} [rect] {x, y, width, height}\n *                  If set false, rect text is not used.\n */\n\n\nfunction renderText(hostEl, ctx, text, style, rect) {\n  style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);\n}\n\nfunction renderPlainText(hostEl, ctx, text, style, rect) {\n  var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);\n  var textPadding = style.textPadding;\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirty) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, font, textPadding, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var textLines = contentBlock.lines;\n  var lineHeight = contentBlock.lineHeight;\n  var boxPos = getBoxPosition(outerHeight, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY;\n  var needDrawBg = needDrawBackground(style);\n\n  if (needDrawBg || textPadding) {\n    // Consider performance, do not call getTextWidth util necessary.\n    var textWidth = textContain.getWidth(text, font);\n    var outerWidth = textWidth;\n    textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n    if (textPadding) {\n      textX = getTextXForPadding(baseX, textAlign, textPadding);\n      textY += textPadding[0];\n    }\n  }\n\n  setCtx(ctx, 'textAlign', textAlign || 'left'); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle'); // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\n  setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0); // `textBaseline` is set as 'middle'.\n\n  textY += lineHeight / 2;\n  var textStrokeWidth = style.textStrokeWidth;\n  var textStroke = getStroke(style.textStroke, textStrokeWidth);\n  var textFill = getFill(style.textFill);\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n  }\n\n  for (var i = 0; i < textLines.length; i++) {\n    // Fill after stroke so the outline will not cover the main part.\n    textStroke && ctx.strokeText(textLines[i], textX, textY);\n    textFill && ctx.fillText(textLines[i], textX, textY);\n    textY += lineHeight;\n  }\n}\n\nfunction renderRichText(hostEl, ctx, text, style, rect) {\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirty) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n  }\n\n  drawRichText(hostEl, ctx, contentBlock, style, rect);\n}\n\nfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n  var contentWidth = contentBlock.width;\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var textPadding = style.textPadding;\n  var boxPos = getBoxPosition(outerHeight, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var xLeft = boxX;\n  var lineTop = boxY;\n\n  if (textPadding) {\n    xLeft += textPadding[3];\n    lineTop += textPadding[0];\n  }\n\n  var xRight = xLeft + contentWidth;\n  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n  for (var i = 0; i < contentBlock.lines.length; i++) {\n    var line = contentBlock.lines[i];\n    var tokens = line.tokens;\n    var tokenCount = tokens.length;\n    var lineHeight = line.lineHeight;\n    var usedWidth = line.width;\n    var leftIndex = 0;\n    var lineXLeft = xLeft;\n    var lineXRight = xRight;\n    var rightIndex = tokenCount - 1;\n    var token;\n\n    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n      usedWidth -= token.width;\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n      usedWidth -= token.width;\n      lineXRight -= token.width;\n      rightIndex--;\n    } // The other tokens are placed as textAlign 'center' if there is enough space.\n\n\n    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n\n    while (leftIndex <= rightIndex) {\n      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.\n\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    lineTop += lineHeight;\n  }\n}\n\nfunction applyTextRotation(ctx, style, rect, x, y) {\n  // textRotation only apply in RectText.\n  if (rect && style.textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      x = rect.width / 2 + rect.x;\n      y = rect.height / 2 + rect.y;\n    } else if (origin) {\n      x = origin[0] + rect.x;\n      y = origin[1] + rect.y;\n    }\n\n    ctx.translate(x, y); // Positive: anticlockwise\n\n    ctx.rotate(-style.textRotation);\n    ctx.translate(-x, -y);\n  }\n}\n\nfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n  var tokenStyle = style.rich[token.styleName] || {}; // 'ctx.textBaseline' is always set as 'middle', for sake of\n  // the bias of \"Microsoft YaHei\".\n\n  var textVerticalAlign = token.textVerticalAlign;\n  var y = lineTop + lineHeight / 2;\n\n  if (textVerticalAlign === 'top') {\n    y = lineTop + token.height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y = lineTop + lineHeight - token.height / 2;\n  }\n\n  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);\n  var textPadding = token.textPadding;\n\n  if (textPadding) {\n    x = getTextXForPadding(x, textAlign, textPadding);\n    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n  }\n\n  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle');\n  setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);\n  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n  var textFill = getFill(tokenStyle.textFill || style.textFill);\n  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n    ctx.strokeText(token.text, x, y);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n    ctx.fillText(token.text, x, y);\n  }\n}\n\nfunction needDrawBackground(style) {\n  return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;\n} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}\n// shape: {x, y, width, height}\n\n\nfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n  var textBackgroundColor = style.textBackgroundColor;\n  var textBorderWidth = style.textBorderWidth;\n  var textBorderColor = style.textBorderColor;\n  var isPlainBg = isString(textBackgroundColor);\n  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\n  if (isPlainBg || textBorderWidth && textBorderColor) {\n    ctx.beginPath();\n    var textBorderRadius = style.textBorderRadius;\n\n    if (!textBorderRadius) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        r: textBorderRadius\n      });\n    }\n\n    ctx.closePath();\n  }\n\n  if (isPlainBg) {\n    setCtx(ctx, 'fillStyle', textBackgroundColor);\n    ctx.fill();\n  } else if (isObject(textBackgroundColor)) {\n    var image = textBackgroundColor.image;\n    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);\n\n    if (image && imageHelper.isImageReady(image)) {\n      ctx.drawImage(image, x, y, width, height);\n    }\n  }\n\n  if (textBorderWidth && textBorderColor) {\n    setCtx(ctx, 'lineWidth', textBorderWidth);\n    setCtx(ctx, 'strokeStyle', textBorderColor);\n    ctx.stroke();\n  }\n}\n\nfunction onBgImageLoaded(image, textBackgroundColor) {\n  // Replace image, so that `contain/text.js#parseRichText`\n  // will get correct result in next tick.\n  textBackgroundColor.image = image;\n}\n\nfunction getBoxPosition(blockHeiht, style, rect) {\n  var baseX = style.x || 0;\n  var baseY = style.y || 0;\n  var textAlign = style.textAlign;\n  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord\n\n  if (rect) {\n    var textPosition = style.textPosition;\n\n    if (textPosition instanceof Array) {\n      // Percent\n      baseX = rect.x + parsePercent(textPosition[0], rect.width);\n      baseY = rect.y + parsePercent(textPosition[1], rect.height);\n    } else {\n      var res = textContain.adjustTextPositionOnRect(textPosition, rect, style.textDistance);\n      baseX = res.x;\n      baseY = res.y; // Default align and baseline when has textPosition\n\n      textAlign = textAlign || res.textAlign;\n      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n    } // textOffset is only support in RectText, otherwise\n    // we have to adjust boundingRect for textOffset.\n\n\n    var textOffset = style.textOffset;\n\n    if (textOffset) {\n      baseX += textOffset[0];\n      baseY += textOffset[1];\n    }\n  }\n\n  return {\n    baseX: baseX,\n    baseY: baseY,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction setCtx(ctx, prop, value) {\n  // FIXME ??? performance try\n  // if (ctx.__currentValues[prop] !== value) {\n  // ctx[prop] = ctx.__currentValues[prop] = value;\n  ctx[prop] = value; // }\n\n  return ctx[prop];\n}\n/**\n * @param {string} [stroke] If specified, do not check style.textStroke.\n * @param {string} [lineWidth] If specified, do not check style.textStroke.\n * @param {number} style\n */\n\n\nfunction getStroke(stroke, lineWidth) {\n  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?\n  : stroke.image || stroke.colorStops ? '#000' : stroke;\n}\n\nfunction getFill(fill) {\n  return fill == null || fill === 'none' ? null // TODO pattern and gradient?\n  : fill.image || fill.colorStops ? '#000' : fill;\n}\n\nfunction parsePercent(value, maxValue) {\n  if (typeof value === 'string') {\n    if (value.lastIndexOf('%') >= 0) {\n      return parseFloat(value) / 100 * maxValue;\n    }\n\n    return parseFloat(value);\n  }\n\n  return value;\n}\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n/**\n * @param {string} text\n * @param {module:zrender/Style} style\n * @return {boolean}\n */\n\n\nfunction needDrawText(text, style) {\n  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);\n}\n\nexports.normalizeTextStyle = normalizeTextStyle;\nexports.renderText = renderText;\nexports.getStroke = getStroke;\nexports.getFill = getFill;\nexports.needDrawText = needDrawText;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/text.js\n// module id = 24\n// module chunks = 0","var BoundingRect = require(\"../core/BoundingRect\");\n\nvar imageHelper = require(\"../graphic/helper/image\");\n\nvar _util = require(\"../core/util\");\n\nvar getContext = _util.getContext;\nvar extend = _util.extend;\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar textWidthCache = {};\nvar textWidthCacheCounter = 0;\nvar TEXT_CACHE_MAX = 5000;\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {number} width\n */\n\n\nfunction getWidth(text, font) {\n  font = font || DEFAULT_FONT;\n  var key = text + ':' + font;\n\n  if (textWidthCache[key]) {\n    return textWidthCache[key];\n  }\n\n  var textLines = (text + '').split('\\n');\n  var width = 0;\n\n  for (var i = 0, l = textLines.length; i < l; i++) {\n    // textContain.measureText may be overrided in SVG or VML\n    width = Math.max(measureText(textLines[i], font).width, width);\n  }\n\n  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n    textWidthCacheCounter = 0;\n    textWidthCache = {};\n  }\n\n  textWidthCacheCounter++;\n  textWidthCache[key] = width;\n  return width;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {string} [textAlign='left']\n * @param {string} [textVerticalAlign='top']\n * @param {Array.<number>} [textPadding]\n * @param {Object} [rich]\n * @param {Object} [truncate]\n * @return {Object} {x, y, width, height, lineHeight}\n */\n\n\nfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);\n}\n\nfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {\n  var contentBlock = parsePlainText(text, font, textPadding, truncate);\n  var outerWidth = getWidth(text, font);\n\n  if (textPadding) {\n    outerWidth += textPadding[1] + textPadding[3];\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n  rect.lineHeight = contentBlock.lineHeight;\n  return rect;\n}\n\nfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n  var contentBlock = parseRichText(text, {\n    rich: rich,\n    truncate: truncate,\n    font: font,\n    textAlign: textAlign,\n    textPadding: textPadding\n  });\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  return new BoundingRect(x, y, outerWidth, outerHeight);\n}\n/**\n * @public\n * @param {number} x\n * @param {number} width\n * @param {string} [textAlign='left']\n * @return {number} Adjusted x.\n */\n\n\nfunction adjustTextX(x, width, textAlign) {\n  // FIXME Right to left language\n  if (textAlign === 'right') {\n    x -= width;\n  } else if (textAlign === 'center') {\n    x -= width / 2;\n  }\n\n  return x;\n}\n/**\n * @public\n * @param {number} y\n * @param {number} height\n * @param {string} [textVerticalAlign='top']\n * @return {number} Adjusted y.\n */\n\n\nfunction adjustTextY(y, height, textVerticalAlign) {\n  if (textVerticalAlign === 'middle') {\n    y -= height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y -= height;\n  }\n\n  return y;\n}\n/**\n * @public\n * @param {stirng} textPosition\n * @param {Object} rect {x, y, width, height}\n * @param {number} distance\n * @return {Object} {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n  var x = rect.x;\n  var y = rect.y;\n  var height = rect.height;\n  var width = rect.width;\n  var halfHeight = height / 2;\n  var textAlign = 'left';\n  var textVerticalAlign = 'top';\n\n  switch (textPosition) {\n    case 'left':\n      x -= distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'right':\n      x += distance + width;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'top':\n      x += width / 2;\n      y -= distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'bottom':\n      x += width / 2;\n      y += height + distance;\n      textAlign = 'center';\n      break;\n\n    case 'inside':\n      x += width / 2;\n      y += halfHeight;\n      textAlign = 'center';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideLeft':\n      x += distance;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideRight':\n      x += width - distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideTop':\n      x += width / 2;\n      y += distance;\n      textAlign = 'center';\n      break;\n\n    case 'insideBottom':\n      x += width / 2;\n      y += height - distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideTopLeft':\n      x += distance;\n      y += distance;\n      break;\n\n    case 'insideTopRight':\n      x += width - distance;\n      y += distance;\n      textAlign = 'right';\n      break;\n\n    case 'insideBottomLeft':\n      x += distance;\n      y += height - distance;\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideBottomRight':\n      x += width - distance;\n      y += height - distance;\n      textAlign = 'right';\n      textVerticalAlign = 'bottom';\n      break;\n  }\n\n  return {\n    x: x,\n    y: y,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n/**\n * Show ellipsis if overflow.\n *\n * @public\n * @param  {string} text\n * @param  {string} containerWidth\n * @param  {string} font\n * @param  {number} [ellipsis='...']\n * @param  {Object} [options]\n * @param  {number} [options.maxIterations=3]\n * @param  {number} [options.minChar=0] If truncate result are less\n *                  then minChar, ellipsis will not show, which is\n *                  better for user hint in some cases.\n * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n * @return {string}\n */\n\n\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    return '';\n  }\n\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n  // It is not appropriate that every line has '...' when truncate multiple lines.\n\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    textLines[i] = truncateSingleLine(textLines[i], options);\n  }\n\n  return textLines.join('\\n');\n}\n\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = extend({}, options);\n  options.font = font;\n  var ellipsis = retrieve2(ellipsis, '...');\n  options.maxIterations = retrieve2(options.maxIterations, 2);\n  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n  // Other languages?\n\n  options.cnCharWidth = getWidth('国', font); // FIXME\n  // Consider proportional font?\n\n  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\n  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n\n  var ellipsisWidth = getWidth(ellipsis);\n\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n\n  contentWidth = containerWidth - ellipsisWidth;\n  options.ellipsis = ellipsis;\n  options.ellipsisWidth = ellipsisWidth;\n  options.contentWidth = contentWidth;\n  options.containerWidth = containerWidth;\n  return options;\n}\n\nfunction truncateSingleLine(textLine, options) {\n  var containerWidth = options.containerWidth;\n  var font = options.font;\n  var contentWidth = options.contentWidth;\n\n  if (!containerWidth) {\n    return '';\n  }\n\n  var lineWidth = getWidth(textLine, font);\n\n  if (lineWidth <= containerWidth) {\n    return textLine;\n  }\n\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = getWidth(textLine, font);\n  }\n\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n\n  return textLine;\n}\n\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n  var width = 0;\n  var i = 0;\n\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    var charCode = text.charCodeAt(i);\n    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n  }\n\n  return i;\n}\n/**\n * @public\n * @param {string} font\n * @return {number} line height\n */\n\n\nfunction getLineHeight(font) {\n  // FIXME A rough approach.\n  return getWidth('国', font);\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {Object} width\n */\n\n\nfunction measureText(text, font) {\n  return methods.measureText(text, font);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nmethods.measureText = function (text, font) {\n  var ctx = getContext();\n  ctx.font = font || DEFAULT_FONT;\n  return ctx.measureText(text);\n};\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {Object} [truncate]\n * @return {Object} block: {lineHeight, lines, height, outerHeight}\n *  Notice: for performance, do not calculate outerWidth util needed.\n */\n\n\nfunction parsePlainText(text, font, padding, truncate) {\n  text != null && (text += '');\n  var lineHeight = getLineHeight(font);\n  var lines = text ? text.split('\\n') : [];\n  var height = lines.length * lineHeight;\n  var outerHeight = height;\n\n  if (padding) {\n    outerHeight += padding[0] + padding[2];\n  }\n\n  if (text && truncate) {\n    var truncOuterHeight = truncate.outerHeight;\n    var truncOuterWidth = truncate.outerWidth;\n\n    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n      text = '';\n      lines = [];\n    } else if (truncOuterWidth != null) {\n      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n        minChar: truncate.minChar,\n        placeholder: truncate.placeholder\n      }); // FIXME\n      // It is not appropriate that every line has '...' when truncate multiple lines.\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        lines[i] = truncateSingleLine(lines[i], options);\n      }\n    }\n  }\n\n  return {\n    lines: lines,\n    height: height,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight\n  };\n}\n/**\n * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n *\n * @public\n * @param {string} text\n * @param {Object} style\n * @return {Object} block\n * {\n *      width,\n *      height,\n *      lines: [{\n *          lineHeight,\n *          width,\n *          tokens: [[{\n *              styleName,\n *              text,\n *              width,      // include textPadding\n *              height,     // include textPadding\n *              textWidth, // pure text width\n *              textHeight, // pure text height\n *              lineHeihgt,\n *              font,\n *              textAlign,\n *              textVerticalAlign\n *          }], [...], ...]\n *      }, ...]\n * }\n * If styleName is undefined, it is plain text.\n */\n\n\nfunction parseRichText(text, style) {\n  var contentBlock = {\n    lines: [],\n    width: 0,\n    height: 0\n  };\n  text != null && (text += '');\n\n  if (!text) {\n    return contentBlock;\n  }\n\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n    }\n\n    pushTokens(contentBlock, result[2], result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n  }\n\n  var lines = contentBlock.lines;\n  var contentHeight = 0;\n  var contentWidth = 0; // For `textWidth: 100%`\n\n  var pendingList = [];\n  var stlPadding = style.textPadding;\n  var truncate = style.truncate;\n  var truncateWidth = truncate && truncate.outerWidth;\n  var truncateHeight = truncate && truncate.outerHeight;\n\n  if (stlPadding) {\n    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n  } // Calculate layout info of tokens.\n\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\n      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\n      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\n      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n      // as box height of the block.\n      tokenStyle.textHeight, getLineHeight(font));\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n        return {\n          lines: [],\n          width: 0,\n          height: 0\n        };\n      }\n\n      token.textWidth = getWidth(token.text, font);\n      var tokenWidth = tokenStyle.textWidth;\n      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n      // line when box width is needed to be auto.\n\n      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n        token.percentWidth = tokenWidth;\n        pendingList.push(token);\n        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n        // and it is too complicated.\n      } else {\n        if (tokenWidthNotSpecified) {\n          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n          // `getBoundingRect()` will not get correct result.\n\n          var textBackgroundColor = tokenStyle.textBackgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n          // (1) If image is not loaded, it will be loaded at render phase and call\n          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n          // image, and then the right size will be calculated here at the next tick.\n          // See `graphic/helper/text.js`.\n          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n          // use `imageHelper.findExistImage` to find cached image.\n          // `imageHelper.findExistImage` will always be called here before\n          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n          // which ensures that image will not be rendered before correct size calcualted.\n\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n\n            if (imageHelper.isImageReady(bgImg)) {\n              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n\n        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n        tokenWidth += paddingW;\n        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n            token.text = '';\n            token.textWidth = tokenWidth = 0;\n          } else {\n            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n              minChar: truncate.minChar\n            });\n            token.textWidth = getWidth(token.text, font);\n            tokenWidth = token.textWidth + paddingW;\n          }\n        }\n      }\n\n      lineWidth += token.width = tokenWidth;\n      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n    }\n\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    contentHeight += lineHeight;\n    contentWidth = Math.max(contentWidth, lineWidth);\n  }\n\n  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n  if (stlPadding) {\n    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n  }\n\n  for (var i = 0; i < pendingList.length; i++) {\n    var token = pendingList[i];\n    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\n    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n  }\n\n  return contentBlock;\n}\n\nfunction pushTokens(block, str, styleName) {\n  var isEmptyStr = str === '';\n  var strs = str.split('\\n');\n  var lines = block.lines;\n\n  for (var i = 0; i < strs.length; i++) {\n    var text = strs[i];\n    var token = {\n      styleName: styleName,\n      text: text,\n      isLineHolder: !text && !isEmptyStr\n    }; // The first token should be appended to the last line.\n\n    if (!i) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = {\n        tokens: []\n      })).tokens; // Consider cases:\n      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n      // (which is a placeholder) should be replaced by new token.\n      // (2) A image backage, where token likes {a|}.\n      // (3) A redundant '' will affect textAlign in line.\n      // (4) tokens with the same tplName should not be merged, because\n      // they should be displayed in different box (with border and padding).\n\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } // Other tokens always start a new line.\n    else {\n        // If there is '', insert it as a placeholder.\n        lines.push({\n          tokens: [token]\n        });\n      }\n  }\n}\n\nfunction makeFont(style) {\n  // FIXME in node-canvas fontWeight is before fontStyle\n  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n  return (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n  style.fontFamily || 'sans-serif'].join(' ') || style.textFont || style.font;\n}\n\nexports.DEFAULT_FONT = DEFAULT_FONT;\nexports.$override = $override;\nexports.getWidth = getWidth;\nexports.getBoundingRect = getBoundingRect;\nexports.adjustTextX = adjustTextX;\nexports.adjustTextY = adjustTextY;\nexports.adjustTextPositionOnRect = adjustTextPositionOnRect;\nexports.truncateText = truncateText;\nexports.getLineHeight = getLineHeight;\nexports.measureText = measureText;\nexports.parsePlainText = parsePlainText;\nexports.parseRichText = parseRichText;\nexports.makeFont = makeFont;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/text.js\n// module id = 25\n// module chunks = 0","var vec2 = require(\"./vector\");\n\nvar matrix = require(\"./matrix\");\n\n/**\n * @module echarts/core/BoundingRect\n */\nvar v2ApplyTransform = vec2.applyTransform;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\n/**\n * @alias module:echarts/core/BoundingRect\n */\n\nfunction BoundingRect(x, y, width, height) {\n  if (width < 0) {\n    x = x + width;\n    width = -width;\n  }\n\n  if (height < 0) {\n    y = y + height;\n    height = -height;\n  }\n  /**\n   * @type {number}\n   */\n\n\n  this.x = x;\n  /**\n   * @type {number}\n   */\n\n  this.y = y;\n  /**\n   * @type {number}\n   */\n\n  this.width = width;\n  /**\n   * @type {number}\n   */\n\n  this.height = height;\n}\n\nBoundingRect.prototype = {\n  constructor: BoundingRect,\n\n  /**\n   * @param {module:echarts/core/BoundingRect} other\n   */\n  union: function (other) {\n    var x = mathMin(other.x, this.x);\n    var y = mathMin(other.y, this.y);\n    this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n    this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n    this.x = x;\n    this.y = y;\n  },\n\n  /**\n   * @param {Array.<number>} m\n   * @methods\n   */\n  applyTransform: function () {\n    var lt = [];\n    var rb = [];\n    var lb = [];\n    var rt = [];\n    return function (m) {\n      // In case usage like this\n      // el.getBoundingRect().applyTransform(el.transform)\n      // And element has no transform\n      if (!m) {\n        return;\n      }\n\n      lt[0] = lb[0] = this.x;\n      lt[1] = rt[1] = this.y;\n      rb[0] = rt[0] = this.x + this.width;\n      rb[1] = lb[1] = this.y + this.height;\n      v2ApplyTransform(lt, lt, m);\n      v2ApplyTransform(rb, rb, m);\n      v2ApplyTransform(lb, lb, m);\n      v2ApplyTransform(rt, rt, m);\n      this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n      this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n      var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n      var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n      this.width = maxX - this.x;\n      this.height = maxY - this.y;\n    };\n  }(),\n\n  /**\n   * Calculate matrix of transforming from self to target rect\n   * @param  {module:zrender/core/BoundingRect} b\n   * @return {Array.<number>}\n   */\n  calculateTransform: function (b) {\n    var a = this;\n    var sx = b.width / a.width;\n    var sy = b.height / a.height;\n    var m = matrix.create(); // 矩阵右乘\n\n    matrix.translate(m, m, [-a.x, -a.y]);\n    matrix.scale(m, m, [sx, sy]);\n    matrix.translate(m, m, [b.x, b.y]);\n    return m;\n  },\n\n  /**\n   * @param {(module:echarts/core/BoundingRect|Object)} b\n   * @return {boolean}\n   */\n  intersect: function (b) {\n    if (!b) {\n      return false;\n    }\n\n    if (!(b instanceof BoundingRect)) {\n      // Normalize negative width/height.\n      b = BoundingRect.create(b);\n    }\n\n    var a = this;\n    var ax0 = a.x;\n    var ax1 = a.x + a.width;\n    var ay0 = a.y;\n    var ay1 = a.y + a.height;\n    var bx0 = b.x;\n    var bx1 = b.x + b.width;\n    var by0 = b.y;\n    var by1 = b.y + b.height;\n    return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n  },\n  contain: function (x, y) {\n    var rect = this;\n    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n  },\n\n  /**\n   * @return {module:echarts/core/BoundingRect}\n   */\n  clone: function () {\n    return new BoundingRect(this.x, this.y, this.width, this.height);\n  },\n\n  /**\n   * Copy from another rect\n   */\n  copy: function (other) {\n    this.x = other.x;\n    this.y = other.y;\n    this.width = other.width;\n    this.height = other.height;\n  },\n  plain: function () {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height\n    };\n  }\n};\n/**\n * @param {Object|module:zrender/core/BoundingRect} rect\n * @param {number} rect.x\n * @param {number} rect.y\n * @param {number} rect.width\n * @param {number} rect.height\n * @return {module:zrender/core/BoundingRect}\n */\n\nBoundingRect.create = function (rect) {\n  return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n};\n\nvar _default = BoundingRect;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/BoundingRect.js\n// module id = 26\n// module chunks = 0","var LRU = require(\"../../core/LRU\");\n\nvar globalImageCache = new LRU(50);\n/**\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n */\n\nfunction findExistImage(newImageOrSrc) {\n  if (typeof newImageOrSrc === 'string') {\n    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n    return cachedImgObj && cachedImgObj.image;\n  } else {\n    return newImageOrSrc;\n  }\n}\n/**\n * Caution: User should cache loaded images, but not just count on LRU.\n * Consider if required images more than LRU size, will dead loop occur?\n *\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.\n * @param {module:zrender/Element} [hostEl] For calling `dirty`.\n * @param {Function} [cb] params: (image, cbPayload)\n * @param {Object} [cbPayload] Payload on cb calling.\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n */\n\n\nfunction createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {\n  if (!newImageOrSrc) {\n    return image;\n  } else if (typeof newImageOrSrc === 'string') {\n    // Image should not be loaded repeatly.\n    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {\n      return image;\n    } // Only when there is no existent image or existent image src\n    // is different, this method is responsible for load.\n\n\n    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n    var pendingWrap = {\n      hostEl: hostEl,\n      cb: cb,\n      cbPayload: cbPayload\n    };\n\n    if (cachedImgObj) {\n      image = cachedImgObj.image;\n      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);\n    } else {\n      !image && (image = new Image());\n      image.onload = imageOnLoad;\n      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {\n        image: image,\n        pending: [pendingWrap]\n      });\n      image.src = image.__zrImageSrc = newImageOrSrc;\n    }\n\n    return image;\n  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas\n  else {\n      return newImageOrSrc;\n    }\n}\n\nfunction imageOnLoad() {\n  var cachedImgObj = this.__cachedImgObj;\n  this.onload = this.__cachedImgObj = null;\n\n  for (var i = 0; i < cachedImgObj.pending.length; i++) {\n    var pendingWrap = cachedImgObj.pending[i];\n    var cb = pendingWrap.cb;\n    cb && cb(this, pendingWrap.cbPayload);\n    pendingWrap.hostEl.dirty();\n  }\n\n  cachedImgObj.pending.length = 0;\n}\n\nfunction isImageReady(image) {\n  return image && image.width && image.height;\n}\n\nexports.findExistImage = findExistImage;\nexports.createOrUpdateImage = createOrUpdateImage;\nexports.isImageReady = isImageReady;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/image.js\n// module id = 27\n// module chunks = 0","function buildPath(ctx, shape) {\n  var x = shape.x;\n  var y = shape.y;\n  var width = shape.width;\n  var height = shape.height;\n  var r = shape.r;\n  var r1;\n  var r2;\n  var r3;\n  var r4; // Convert width and height to positive for better borderRadius\n\n  if (width < 0) {\n    x = x + width;\n    width = -width;\n  }\n\n  if (height < 0) {\n    y = y + height;\n    height = -height;\n  }\n\n  if (typeof r === 'number') {\n    r1 = r2 = r3 = r4 = r;\n  } else if (r instanceof Array) {\n    if (r.length === 1) {\n      r1 = r2 = r3 = r4 = r[0];\n    } else if (r.length === 2) {\n      r1 = r3 = r[0];\n      r2 = r4 = r[1];\n    } else if (r.length === 3) {\n      r1 = r[0];\n      r2 = r4 = r[1];\n      r3 = r[2];\n    } else {\n      r1 = r[0];\n      r2 = r[1];\n      r3 = r[2];\n      r4 = r[3];\n    }\n  } else {\n    r1 = r2 = r3 = r4 = 0;\n  }\n\n  var total;\n\n  if (r1 + r2 > width) {\n    total = r1 + r2;\n    r1 *= width / total;\n    r2 *= width / total;\n  }\n\n  if (r3 + r4 > width) {\n    total = r3 + r4;\n    r3 *= width / total;\n    r4 *= width / total;\n  }\n\n  if (r2 + r3 > height) {\n    total = r2 + r3;\n    r2 *= height / total;\n    r3 *= height / total;\n  }\n\n  if (r1 + r4 > height) {\n    total = r1 + r4;\n    r1 *= height / total;\n    r4 *= height / total;\n  }\n\n  ctx.moveTo(x + r1, y);\n  ctx.lineTo(x + width - r2, y);\n  r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);\n  ctx.lineTo(x + width, y + height - r3);\n  r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);\n  ctx.lineTo(x + r4, y + height);\n  r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);\n  ctx.lineTo(x, y + r1);\n  r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n}\n\nexports.buildPath = buildPath;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/roundRect.js\n// module id = 28\n// module chunks = 0","var curve = require(\"./curve\");\n\nvar vec2 = require(\"./vector\");\n\nvar bbox = require(\"./bbox\");\n\nvar BoundingRect = require(\"./BoundingRect\");\n\nvar _config = require(\"../config\");\n\nvar dpr = _config.devicePixelRatio;\n\n/**\n * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n * 可以用于 isInsidePath 判断以及获取boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n// TODO getTotalLength, getPointAtLength\nvar CMD = {\n  M: 1,\n  L: 2,\n  C: 3,\n  Q: 4,\n  A: 5,\n  Z: 6,\n  // Rect\n  R: 7\n}; // var CMD_MEM_SIZE = {\n//     M: 3,\n//     L: 3,\n//     C: 7,\n//     Q: 5,\n//     A: 9,\n//     R: 5,\n//     Z: 1\n// };\n\nvar min = [];\nvar max = [];\nvar min2 = [];\nvar max2 = [];\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathCos = Math.cos;\nvar mathSin = Math.sin;\nvar mathSqrt = Math.sqrt;\nvar mathAbs = Math.abs;\nvar hasTypedArray = typeof Float32Array != 'undefined';\n/**\n * @alias module:zrender/core/PathProxy\n * @constructor\n */\n\nvar PathProxy = function (notSaveData) {\n  this._saveData = !(notSaveData || false);\n\n  if (this._saveData) {\n    /**\n     * Path data. Stored as flat array\n     * @type {Array.<Object>}\n     */\n    this.data = [];\n  }\n\n  this._ctx = null;\n};\n/**\n * 快速计算Path包围盒（并不是最小包围盒）\n * @return {Object}\n */\n\n\nPathProxy.prototype = {\n  constructor: PathProxy,\n  _xi: 0,\n  _yi: 0,\n  _x0: 0,\n  _y0: 0,\n  // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n  _ux: 0,\n  _uy: 0,\n  _len: 0,\n  _lineDash: null,\n  _dashOffset: 0,\n  _dashIdx: 0,\n  _dashSum: 0,\n\n  /**\n   * @readOnly\n   */\n  setScale: function (sx, sy) {\n    this._ux = mathAbs(1 / dpr / sx) || 0;\n    this._uy = mathAbs(1 / dpr / sy) || 0;\n  },\n  getContext: function () {\n    return this._ctx;\n  },\n\n  /**\n   * @param  {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  beginPath: function (ctx) {\n    this._ctx = ctx;\n    ctx && ctx.beginPath();\n    ctx && (this.dpr = ctx.dpr); // Reset\n\n    if (this._saveData) {\n      this._len = 0;\n    }\n\n    if (this._lineDash) {\n      this._lineDash = null;\n      this._dashOffset = 0;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param  {number} x\n   * @param  {number} y\n   * @return {module:zrender/core/PathProxy}\n   */\n  moveTo: function (x, y) {\n    this.addData(CMD.M, x, y);\n    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n    // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n    // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n    // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n\n    this._x0 = x;\n    this._y0 = y;\n    this._xi = x;\n    this._yi = y;\n    return this;\n  },\n\n  /**\n   * @param  {number} x\n   * @param  {number} y\n   * @return {module:zrender/core/PathProxy}\n   */\n  lineTo: function (x, y) {\n    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment\n    || this._len < 5;\n    this.addData(CMD.L, x, y);\n\n    if (this._ctx && exceedUnit) {\n      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n    }\n\n    if (exceedUnit) {\n      this._xi = x;\n      this._yi = y;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param  {number} x1\n   * @param  {number} y1\n   * @param  {number} x2\n   * @param  {number} y2\n   * @param  {number} x3\n   * @param  {number} y3\n   * @return {module:zrender/core/PathProxy}\n   */\n  bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\n    if (this._ctx) {\n      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n    }\n\n    this._xi = x3;\n    this._yi = y3;\n    return this;\n  },\n\n  /**\n   * @param  {number} x1\n   * @param  {number} y1\n   * @param  {number} x2\n   * @param  {number} y2\n   * @return {module:zrender/core/PathProxy}\n   */\n  quadraticCurveTo: function (x1, y1, x2, y2) {\n    this.addData(CMD.Q, x1, y1, x2, y2);\n\n    if (this._ctx) {\n      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n    }\n\n    this._xi = x2;\n    this._yi = y2;\n    return this;\n  },\n\n  /**\n   * @param  {number} cx\n   * @param  {number} cy\n   * @param  {number} r\n   * @param  {number} startAngle\n   * @param  {number} endAngle\n   * @param  {boolean} anticlockwise\n   * @return {module:zrender/core/PathProxy}\n   */\n  arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);\n    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n    this._xi = mathCos(endAngle) * r + cx;\n    this._yi = mathSin(endAngle) * r + cx;\n    return this;\n  },\n  // TODO\n  arcTo: function (x1, y1, x2, y2, radius) {\n    if (this._ctx) {\n      this._ctx.arcTo(x1, y1, x2, y2, radius);\n    }\n\n    return this;\n  },\n  // TODO\n  rect: function (x, y, w, h) {\n    this._ctx && this._ctx.rect(x, y, w, h);\n    this.addData(CMD.R, x, y, w, h);\n    return this;\n  },\n\n  /**\n   * @return {module:zrender/core/PathProxy}\n   */\n  closePath: function () {\n    this.addData(CMD.Z);\n    var ctx = this._ctx;\n    var x0 = this._x0;\n    var y0 = this._y0;\n\n    if (ctx) {\n      this._needsDash() && this._dashedLineTo(x0, y0);\n      ctx.closePath();\n    }\n\n    this._xi = x0;\n    this._yi = y0;\n    return this;\n  },\n\n  /**\n   * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n   * stroke 同样\n   * @param {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  fill: function (ctx) {\n    ctx && ctx.fill();\n    this.toStatic();\n  },\n\n  /**\n   * @param {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  stroke: function (ctx) {\n    ctx && ctx.stroke();\n    this.toStatic();\n  },\n\n  /**\n   * 必须在其它绘制命令前调用\n   * Must be invoked before all other path drawing methods\n   * @return {module:zrender/core/PathProxy}\n   */\n  setLineDash: function (lineDash) {\n    if (lineDash instanceof Array) {\n      this._lineDash = lineDash;\n      this._dashIdx = 0;\n      var lineDashSum = 0;\n\n      for (var i = 0; i < lineDash.length; i++) {\n        lineDashSum += lineDash[i];\n      }\n\n      this._dashSum = lineDashSum;\n    }\n\n    return this;\n  },\n\n  /**\n   * 必须在其它绘制命令前调用\n   * Must be invoked before all other path drawing methods\n   * @return {module:zrender/core/PathProxy}\n   */\n  setLineDashOffset: function (offset) {\n    this._dashOffset = offset;\n    return this;\n  },\n\n  /**\n   *\n   * @return {boolean}\n   */\n  len: function () {\n    return this._len;\n  },\n\n  /**\n   * 直接设置 Path 数据\n   */\n  setData: function (data) {\n    var len = data.length;\n\n    if (!(this.data && this.data.length == len) && hasTypedArray) {\n      this.data = new Float32Array(len);\n    }\n\n    for (var i = 0; i < len; i++) {\n      this.data[i] = data[i];\n    }\n\n    this._len = len;\n  },\n\n  /**\n   * 添加子路径\n   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n   */\n  appendPath: function (path) {\n    if (!(path instanceof Array)) {\n      path = [path];\n    }\n\n    var len = path.length;\n    var appendSize = 0;\n    var offset = this._len;\n\n    for (var i = 0; i < len; i++) {\n      appendSize += path[i].len();\n    }\n\n    if (hasTypedArray && this.data instanceof Float32Array) {\n      this.data = new Float32Array(offset + appendSize);\n    }\n\n    for (var i = 0; i < len; i++) {\n      var appendPathData = path[i].data;\n\n      for (var k = 0; k < appendPathData.length; k++) {\n        this.data[offset++] = appendPathData[k];\n      }\n    }\n\n    this._len = offset;\n  },\n\n  /**\n   * 填充 Path 数据。\n   * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n   */\n  addData: function (cmd) {\n    if (!this._saveData) {\n      return;\n    }\n\n    var data = this.data;\n\n    if (this._len + arguments.length > data.length) {\n      // 因为之前的数组已经转换成静态的 Float32Array\n      // 所以不够用时需要扩展一个新的动态数组\n      this._expandData();\n\n      data = this.data;\n    }\n\n    for (var i = 0; i < arguments.length; i++) {\n      data[this._len++] = arguments[i];\n    }\n\n    this._prevCmd = cmd;\n  },\n  _expandData: function () {\n    // Only if data is Float32Array\n    if (!(this.data instanceof Array)) {\n      var newData = [];\n\n      for (var i = 0; i < this._len; i++) {\n        newData[i] = this.data[i];\n      }\n\n      this.data = newData;\n    }\n  },\n\n  /**\n   * If needs js implemented dashed line\n   * @return {boolean}\n   * @private\n   */\n  _needsDash: function () {\n    return this._lineDash;\n  },\n  _dashedLineTo: function (x1, y1) {\n    var dashSum = this._dashSum;\n    var offset = this._dashOffset;\n    var lineDash = this._lineDash;\n    var ctx = this._ctx;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n    var dist = mathSqrt(dx * dx + dy * dy);\n    var x = x0;\n    var y = y0;\n    var dash;\n    var nDash = lineDash.length;\n    var idx;\n    dx /= dist;\n    dy /= dist;\n\n    if (offset < 0) {\n      // Convert to positive offset\n      offset = dashSum + offset;\n    }\n\n    offset %= dashSum;\n    x -= offset * dx;\n    y -= offset * dy;\n\n    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n      idx = this._dashIdx;\n      dash = lineDash[idx];\n      x += dx * dash;\n      y += dy * dash;\n      this._dashIdx = (idx + 1) % nDash; // Skip positive offset\n\n      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n        continue;\n      }\n\n      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n    } // Offset for next lineTo\n\n\n    dx = x - x1;\n    dy = y - y1;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  },\n  // Not accurate dashed line to\n  _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n    var dashSum = this._dashSum;\n    var offset = this._dashOffset;\n    var lineDash = this._lineDash;\n    var ctx = this._ctx;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var t;\n    var dx;\n    var dy;\n    var cubicAt = curve.cubicAt;\n    var bezierLen = 0;\n    var idx = this._dashIdx;\n    var nDash = lineDash.length;\n    var x;\n    var y;\n    var tmpLen = 0;\n\n    if (offset < 0) {\n      // Convert to positive offset\n      offset = dashSum + offset;\n    }\n\n    offset %= dashSum; // Bezier approx length\n\n    for (t = 0; t < 1; t += 0.1) {\n      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);\n      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);\n      bezierLen += mathSqrt(dx * dx + dy * dy);\n    } // Find idx after add offset\n\n\n    for (; idx < nDash; idx++) {\n      tmpLen += lineDash[idx];\n\n      if (tmpLen > offset) {\n        break;\n      }\n    }\n\n    t = (tmpLen - offset) / bezierLen;\n\n    while (t <= 1) {\n      x = cubicAt(x0, x1, x2, x3, t);\n      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier\n      // Bad result if dash is long\n\n      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n      t += lineDash[idx] / bezierLen;\n      idx = (idx + 1) % nDash;\n    } // Finish the last segment and calculate the new offset\n\n\n    idx % 2 !== 0 && ctx.lineTo(x3, y3);\n    dx = x3 - x;\n    dy = y3 - y;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  },\n  _dashedQuadraticTo: function (x1, y1, x2, y2) {\n    // Convert quadratic to cubic using degree elevation\n    var x3 = x2;\n    var y3 = y2;\n    x2 = (x2 + 2 * x1) / 3;\n    y2 = (y2 + 2 * y1) / 3;\n    x1 = (this._xi + 2 * x1) / 3;\n    y1 = (this._yi + 2 * y1) / 3;\n\n    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n  },\n\n  /**\n   * 转成静态的 Float32Array 减少堆内存占用\n   * Convert dynamic array to static Float32Array\n   */\n  toStatic: function () {\n    var data = this.data;\n\n    if (data instanceof Array) {\n      data.length = this._len;\n\n      if (hasTypedArray) {\n        this.data = new Float32Array(data);\n      }\n    }\n  },\n\n  /**\n   * @return {module:zrender/core/BoundingRect}\n   */\n  getBoundingRect: function () {\n    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n    var data = this.data;\n    var xi = 0;\n    var yi = 0;\n    var x0 = 0;\n    var y0 = 0;\n\n    for (var i = 0; i < data.length;) {\n      var cmd = data[i++];\n\n      if (i == 1) {\n        // 如果第一个命令是 L, C, Q\n        // 则 previous point 同绘制命令的第一个 point\n        //\n        // 第一个命令为 Arc 的情况下会在后面特殊处理\n        xi = data[i];\n        yi = data[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n\n      switch (cmd) {\n        case CMD.M:\n          // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n          // 在 closePath 的时候使用\n          x0 = data[i++];\n          y0 = data[i++];\n          xi = x0;\n          yi = y0;\n          min2[0] = x0;\n          min2[1] = y0;\n          max2[0] = x0;\n          max2[1] = y0;\n          break;\n\n        case CMD.L:\n          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.C:\n          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.Q:\n          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.A:\n          // TODO Arc 判断的开销比较大\n          var cx = data[i++];\n          var cy = data[i++];\n          var rx = data[i++];\n          var ry = data[i++];\n          var startAngle = data[i++];\n          var endAngle = data[i++] + startAngle; // TODO Arc 旋转\n\n          var psi = data[i++];\n          var anticlockwise = 1 - data[i++];\n\n          if (i == 1) {\n            // 直接使用 arc 命令\n            // 第一个命令起点还未定义\n            x0 = mathCos(startAngle) * rx + cx;\n            y0 = mathSin(startAngle) * ry + cy;\n          }\n\n          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n\n        case CMD.R:\n          x0 = xi = data[i++];\n          y0 = yi = data[i++];\n          var width = data[i++];\n          var height = data[i++]; // Use fromLine\n\n          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n          break;\n\n        case CMD.Z:\n          xi = x0;\n          yi = y0;\n          break;\n      } // Union\n\n\n      vec2.min(min, min, min2);\n      vec2.max(max, max, max2);\n    } // No data\n\n\n    if (i === 0) {\n      min[0] = min[1] = max[0] = max[1] = 0;\n    }\n\n    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n  },\n\n  /**\n   * Rebuild path from current data\n   * Rebuild path will not consider javascript implemented line dash.\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  rebuildPath: function (ctx) {\n    var d = this.data;\n    var x0, y0;\n    var xi, yi;\n    var x, y;\n    var ux = this._ux;\n    var uy = this._uy;\n    var len = this._len;\n\n    for (var i = 0; i < len;) {\n      var cmd = d[i++];\n\n      if (i == 1) {\n        // 如果第一个命令是 L, C, Q\n        // 则 previous point 同绘制命令的第一个 point\n        //\n        // 第一个命令为 Arc 的情况下会在后面特殊处理\n        xi = d[i];\n        yi = d[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n\n      switch (cmd) {\n        case CMD.M:\n          x0 = xi = d[i++];\n          y0 = yi = d[i++];\n          ctx.moveTo(xi, yi);\n          break;\n\n        case CMD.L:\n          x = d[i++];\n          y = d[i++]; // Not draw too small seg between\n\n          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n            ctx.lineTo(x, y);\n            xi = x;\n            yi = y;\n          }\n\n          break;\n\n        case CMD.C:\n          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);\n          xi = d[i - 2];\n          yi = d[i - 1];\n          break;\n\n        case CMD.Q:\n          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n          xi = d[i - 2];\n          yi = d[i - 1];\n          break;\n\n        case CMD.A:\n          var cx = d[i++];\n          var cy = d[i++];\n          var rx = d[i++];\n          var ry = d[i++];\n          var theta = d[i++];\n          var dTheta = d[i++];\n          var psi = d[i++];\n          var fs = d[i++];\n          var r = rx > ry ? rx : ry;\n          var scaleX = rx > ry ? 1 : rx / ry;\n          var scaleY = rx > ry ? ry / rx : 1;\n          var isEllipse = Math.abs(rx - ry) > 1e-3;\n          var endAngle = theta + dTheta;\n\n          if (isEllipse) {\n            ctx.translate(cx, cy);\n            ctx.rotate(psi);\n            ctx.scale(scaleX, scaleY);\n            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n            ctx.scale(1 / scaleX, 1 / scaleY);\n            ctx.rotate(-psi);\n            ctx.translate(-cx, -cy);\n          } else {\n            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n          }\n\n          if (i == 1) {\n            // 直接使用 arc 命令\n            // 第一个命令起点还未定义\n            x0 = mathCos(theta) * rx + cx;\n            y0 = mathSin(theta) * ry + cy;\n          }\n\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n\n        case CMD.R:\n          x0 = xi = d[i];\n          y0 = yi = d[i + 1];\n          ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n          break;\n\n        case CMD.Z:\n          ctx.closePath();\n          xi = x0;\n          yi = y0;\n      }\n    }\n  }\n};\nPathProxy.CMD = CMD;\nvar _default = PathProxy;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/PathProxy.js\n// module id = 29\n// module chunks = 0","var _vector = require(\"./vector\");\n\nvar v2Create = _vector.create;\nvar v2DistSquare = _vector.distSquare;\n\n/**\n * 曲线辅助模块\n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\nvar mathPow = Math.pow;\nvar mathSqrt = Math.sqrt;\nvar EPSILON = 1e-8;\nvar EPSILON_NUMERIC = 1e-4;\nvar THREE_SQRT = mathSqrt(3);\nvar ONE_THIRD = 1 / 3; // 临时变量\n\nvar _v0 = v2Create();\n\nvar _v1 = v2Create();\n\nvar _v2 = v2Create();\n\nfunction isAroundZero(val) {\n  return val > -EPSILON && val < EPSILON;\n}\n\nfunction isNotAroundZero(val) {\n  return val > EPSILON || val < -EPSILON;\n}\n/**\n * 计算三次贝塞尔值\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction cubicAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t;\n  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);\n}\n/**\n * 计算三次贝塞尔导数值\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction cubicDerivativeAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t;\n  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);\n}\n/**\n * 计算三次贝塞尔方程根，使用盛金公式\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} val\n * @param  {Array.<number>} roots\n * @return {number} 有效根数目\n */\n\n\nfunction cubicRootAt(p0, p1, p2, p3, val, roots) {\n  // Evaluate roots of cubic functions\n  var a = p3 + 3 * (p1 - p2) - p0;\n  var b = 3 * (p2 - p1 * 2 + p0);\n  var c = 3 * (p1 - p0);\n  var d = p0 - val;\n  var A = b * b - 3 * a * c;\n  var B = b * c - 9 * a * d;\n  var C = c * c - 3 * b * d;\n  var n = 0;\n\n  if (isAroundZero(A) && isAroundZero(B)) {\n    if (isAroundZero(b)) {\n      roots[0] = 0;\n    } else {\n      var t1 = -c / b; //t1, t2, t3, b is not zero\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    }\n  } else {\n    var disc = B * B - 4 * A * C;\n\n    if (isAroundZero(disc)) {\n      var K = B / A;\n      var t1 = -b / a + K; // t1, a is not zero\n\n      var t2 = -K / 2; // t2, t3\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n      var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\n      if (Y1 < 0) {\n        Y1 = -mathPow(-Y1, ONE_THIRD);\n      } else {\n        Y1 = mathPow(Y1, ONE_THIRD);\n      }\n\n      if (Y2 < 0) {\n        Y2 = -mathPow(-Y2, ONE_THIRD);\n      } else {\n        Y2 = mathPow(Y2, ONE_THIRD);\n      }\n\n      var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    } else {\n      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n      var theta = Math.acos(T) / 3;\n      var ASqrt = mathSqrt(A);\n      var tmp = Math.cos(theta);\n      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n\n      if (t3 >= 0 && t3 <= 1) {\n        roots[n++] = t3;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * 计算三次贝塞尔方程极限值的位置\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {Array.<number>} extrema\n * @return {number} 有效数目\n */\n\n\nfunction cubicExtrema(p0, p1, p2, p3, extrema) {\n  var b = 6 * p2 - 12 * p1 + 6 * p0;\n  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n  var c = 3 * p1 - 3 * p0;\n  var n = 0;\n\n  if (isAroundZero(a)) {\n    if (isNotAroundZero(b)) {\n      var t1 = -c / b;\n\n      if (t1 >= 0 && t1 <= 1) {\n        extrema[n++] = t1;\n      }\n    }\n  } else {\n    var disc = b * b - 4 * a * c;\n\n    if (isAroundZero(disc)) {\n      extrema[0] = -b / (2 * a);\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var t1 = (-b + discSqrt) / (2 * a);\n      var t2 = (-b - discSqrt) / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        extrema[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        extrema[n++] = t2;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * 细分三次贝塞尔曲线\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @param  {Array.<number>} out\n */\n\n\nfunction cubicSubdivide(p0, p1, p2, p3, t, out) {\n  var p01 = (p1 - p0) * t + p0;\n  var p12 = (p2 - p1) * t + p1;\n  var p23 = (p3 - p2) * t + p2;\n  var p012 = (p12 - p01) * t + p01;\n  var p123 = (p23 - p12) * t + p12;\n  var p0123 = (p123 - p012) * t + p012; // Seg0\n\n  out[0] = p0;\n  out[1] = p01;\n  out[2] = p012;\n  out[3] = p0123; // Seg1\n\n  out[4] = p0123;\n  out[5] = p123;\n  out[6] = p23;\n  out[7] = p3;\n}\n/**\n * 投射点到三次贝塞尔曲线上，返回投射距离。\n * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x3\n * @param {number} y3\n * @param {number} x\n * @param {number} y\n * @param {Array.<number>} [out] 投射点\n * @return {number}\n */\n\n\nfunction cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {\n  // http://pomax.github.io/bezierinfo/#projections\n  var t;\n  var interval = 0.005;\n  var d = Infinity;\n  var prev;\n  var next;\n  var d1;\n  var d2;\n  _v0[0] = x;\n  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值\n  // PENDING\n\n  for (var _t = 0; _t < 1; _t += 0.05) {\n    _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n    _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n    d1 = v2DistSquare(_v0, _v1);\n\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n\n  d = Infinity; // At most 32 iteration\n\n  for (var i = 0; i < 32; i++) {\n    if (interval < EPSILON_NUMERIC) {\n      break;\n    }\n\n    prev = t - interval;\n    next = t + interval; // t - interval\n\n    _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n    _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n    d1 = v2DistSquare(_v1, _v0);\n\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      // t + interval\n      _v2[0] = cubicAt(x0, x1, x2, x3, next);\n      _v2[1] = cubicAt(y0, y1, y2, y3, next);\n      d2 = v2DistSquare(_v2, _v0);\n\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  } // t\n\n\n  if (out) {\n    out[0] = cubicAt(x0, x1, x2, x3, t);\n    out[1] = cubicAt(y0, y1, y2, y3, t);\n  } // console.log(interval, i);\n\n\n  return mathSqrt(d);\n}\n/**\n * 计算二次方贝塞尔值\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction quadraticAt(p0, p1, p2, t) {\n  var onet = 1 - t;\n  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n}\n/**\n * 计算二次方贝塞尔导数值\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction quadraticDerivativeAt(p0, p1, p2, t) {\n  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n}\n/**\n * 计算二次方贝塞尔方程根\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @param  {Array.<number>} roots\n * @return {number} 有效根数目\n */\n\n\nfunction quadraticRootAt(p0, p1, p2, val, roots) {\n  var a = p0 - 2 * p1 + p2;\n  var b = 2 * (p1 - p0);\n  var c = p0 - val;\n  var n = 0;\n\n  if (isAroundZero(a)) {\n    if (isNotAroundZero(b)) {\n      var t1 = -c / b;\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    }\n  } else {\n    var disc = b * b - 4 * a * c;\n\n    if (isAroundZero(disc)) {\n      var t1 = -b / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var t1 = (-b + discSqrt) / (2 * a);\n      var t2 = (-b - discSqrt) / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * 计算二次贝塞尔方程极限值\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @return {number}\n */\n\n\nfunction quadraticExtremum(p0, p1, p2) {\n  var divider = p0 + p2 - 2 * p1;\n\n  if (divider === 0) {\n    // p1 is center of p0 and p2\n    return 0.5;\n  } else {\n    return (p0 - p1) / divider;\n  }\n}\n/**\n * 细分二次贝塞尔曲线\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @param  {Array.<number>} out\n */\n\n\nfunction quadraticSubdivide(p0, p1, p2, t, out) {\n  var p01 = (p1 - p0) * t + p0;\n  var p12 = (p2 - p1) * t + p1;\n  var p012 = (p12 - p01) * t + p01; // Seg0\n\n  out[0] = p0;\n  out[1] = p01;\n  out[2] = p012; // Seg1\n\n  out[3] = p012;\n  out[4] = p12;\n  out[5] = p2;\n}\n/**\n * 投射点到二次贝塞尔曲线上，返回投射距离。\n * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x\n * @param {number} y\n * @param {Array.<number>} out 投射点\n * @return {number}\n */\n\n\nfunction quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {\n  // http://pomax.github.io/bezierinfo/#projections\n  var t;\n  var interval = 0.005;\n  var d = Infinity;\n  _v0[0] = x;\n  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值\n  // PENDING\n\n  for (var _t = 0; _t < 1; _t += 0.05) {\n    _v1[0] = quadraticAt(x0, x1, x2, _t);\n    _v1[1] = quadraticAt(y0, y1, y2, _t);\n    var d1 = v2DistSquare(_v0, _v1);\n\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n\n  d = Infinity; // At most 32 iteration\n\n  for (var i = 0; i < 32; i++) {\n    if (interval < EPSILON_NUMERIC) {\n      break;\n    }\n\n    var prev = t - interval;\n    var next = t + interval; // t - interval\n\n    _v1[0] = quadraticAt(x0, x1, x2, prev);\n    _v1[1] = quadraticAt(y0, y1, y2, prev);\n    var d1 = v2DistSquare(_v1, _v0);\n\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      // t + interval\n      _v2[0] = quadraticAt(x0, x1, x2, next);\n      _v2[1] = quadraticAt(y0, y1, y2, next);\n      var d2 = v2DistSquare(_v2, _v0);\n\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  } // t\n\n\n  if (out) {\n    out[0] = quadraticAt(x0, x1, x2, t);\n    out[1] = quadraticAt(y0, y1, y2, t);\n  } // console.log(interval, i);\n\n\n  return mathSqrt(d);\n}\n\nexports.cubicAt = cubicAt;\nexports.cubicDerivativeAt = cubicDerivativeAt;\nexports.cubicRootAt = cubicRootAt;\nexports.cubicExtrema = cubicExtrema;\nexports.cubicSubdivide = cubicSubdivide;\nexports.cubicProjectPoint = cubicProjectPoint;\nexports.quadraticAt = quadraticAt;\nexports.quadraticDerivativeAt = quadraticDerivativeAt;\nexports.quadraticRootAt = quadraticRootAt;\nexports.quadraticExtremum = quadraticExtremum;\nexports.quadraticSubdivide = quadraticSubdivide;\nexports.quadraticProjectPoint = quadraticProjectPoint;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/curve.js\n// module id = 30\n// module chunks = 0","var vec2 = require(\"./vector\");\n\nvar curve = require(\"./curve\");\n\n/**\n * @author Yi Shen(https://github.com/pissang)\n */\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI2 = Math.PI * 2;\nvar start = vec2.create();\nvar end = vec2.create();\nvar extremity = vec2.create();\n/**\n * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n * @module zrender/core/bbox\n * @param {Array<Object>} points 顶点数组\n * @param {number} min\n * @param {number} max\n */\n\nfunction fromPoints(points, min, max) {\n  if (points.length === 0) {\n    return;\n  }\n\n  var p = points[0];\n  var left = p[0];\n  var right = p[0];\n  var top = p[1];\n  var bottom = p[1];\n  var i;\n\n  for (i = 1; i < points.length; i++) {\n    p = points[i];\n    left = mathMin(left, p[0]);\n    right = mathMax(right, p[0]);\n    top = mathMin(top, p[1]);\n    bottom = mathMax(bottom, p[1]);\n  }\n\n  min[0] = left;\n  min[1] = top;\n  max[0] = right;\n  max[1] = bottom;\n}\n/**\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromLine(x0, y0, x1, y1, min, max) {\n  min[0] = mathMin(x0, x1);\n  min[1] = mathMin(y0, y1);\n  max[0] = mathMax(x0, x1);\n  max[1] = mathMax(y0, y1);\n}\n\nvar xDim = [];\nvar yDim = [];\n/**\n * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x3\n * @param {number} y3\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\nfunction fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {\n  var cubicExtrema = curve.cubicExtrema;\n  var cubicAt = curve.cubicAt;\n  var i;\n  var n = cubicExtrema(x0, x1, x2, x3, xDim);\n  min[0] = Infinity;\n  min[1] = Infinity;\n  max[0] = -Infinity;\n  max[1] = -Infinity;\n\n  for (i = 0; i < n; i++) {\n    var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n    min[0] = mathMin(x, min[0]);\n    max[0] = mathMax(x, max[0]);\n  }\n\n  n = cubicExtrema(y0, y1, y2, y3, yDim);\n\n  for (i = 0; i < n; i++) {\n    var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n    min[1] = mathMin(y, min[1]);\n    max[1] = mathMax(y, max[1]);\n  }\n\n  min[0] = mathMin(x0, min[0]);\n  max[0] = mathMax(x0, max[0]);\n  min[0] = mathMin(x3, min[0]);\n  max[0] = mathMax(x3, max[0]);\n  min[1] = mathMin(y0, min[1]);\n  max[1] = mathMax(y0, max[1]);\n  min[1] = mathMin(y3, min[1]);\n  max[1] = mathMax(y3, max[1]);\n}\n/**\n * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {\n  var quadraticExtremum = curve.quadraticExtremum;\n  var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero\n\n  var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);\n  var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);\n  var x = quadraticAt(x0, x1, x2, tx);\n  var y = quadraticAt(y0, y1, y2, ty);\n  min[0] = mathMin(x0, x2, x);\n  min[1] = mathMin(y0, y2, y);\n  max[0] = mathMax(x0, x2, x);\n  max[1] = mathMax(y0, y2, y);\n}\n/**\n * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n * @method\n * @memberOf module:zrender/core/bbox\n * @param {number} x\n * @param {number} y\n * @param {number} rx\n * @param {number} ry\n * @param {number} startAngle\n * @param {number} endAngle\n * @param {number} anticlockwise\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {\n  var vec2Min = vec2.min;\n  var vec2Max = vec2.max;\n  var diff = Math.abs(startAngle - endAngle);\n\n  if (diff % PI2 < 1e-4 && diff > 1e-4) {\n    // Is a circle\n    min[0] = x - rx;\n    min[1] = y - ry;\n    max[0] = x + rx;\n    max[1] = y + ry;\n    return;\n  }\n\n  start[0] = mathCos(startAngle) * rx + x;\n  start[1] = mathSin(startAngle) * ry + y;\n  end[0] = mathCos(endAngle) * rx + x;\n  end[1] = mathSin(endAngle) * ry + y;\n  vec2Min(min, start, end);\n  vec2Max(max, start, end); // Thresh to [0, Math.PI * 2]\n\n  startAngle = startAngle % PI2;\n\n  if (startAngle < 0) {\n    startAngle = startAngle + PI2;\n  }\n\n  endAngle = endAngle % PI2;\n\n  if (endAngle < 0) {\n    endAngle = endAngle + PI2;\n  }\n\n  if (startAngle > endAngle && !anticlockwise) {\n    endAngle += PI2;\n  } else if (startAngle < endAngle && anticlockwise) {\n    startAngle += PI2;\n  }\n\n  if (anticlockwise) {\n    var tmp = endAngle;\n    endAngle = startAngle;\n    startAngle = tmp;\n  } // var number = 0;\n  // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\n\n  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n    if (angle > startAngle) {\n      extremity[0] = mathCos(angle) * rx + x;\n      extremity[1] = mathSin(angle) * ry + y;\n      vec2Min(min, extremity, min);\n      vec2Max(max, extremity, max);\n    }\n  }\n}\n\nexports.fromPoints = fromPoints;\nexports.fromLine = fromLine;\nexports.fromCubic = fromCubic;\nexports.fromQuadratic = fromQuadratic;\nexports.fromArc = fromArc;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/bbox.js\n// module id = 31\n// module chunks = 0","var PathProxy = require(\"../core/PathProxy\");\n\nvar line = require(\"./line\");\n\nvar cubic = require(\"./cubic\");\n\nvar quadratic = require(\"./quadratic\");\n\nvar arc = require(\"./arc\");\n\nvar _util = require(\"./util\");\n\nvar normalizeRadian = _util.normalizeRadian;\n\nvar curve = require(\"../core/curve\");\n\nvar windingLine = require(\"./windingLine\");\n\nvar CMD = PathProxy.CMD;\nvar PI2 = Math.PI * 2;\nvar EPSILON = 1e-4;\n\nfunction isAroundEqual(a, b) {\n  return Math.abs(a - b) < EPSILON;\n} // 临时数组\n\n\nvar roots = [-1, -1, -1];\nvar extrema = [-1, -1];\n\nfunction swapExtrema() {\n  var tmp = extrema[0];\n  extrema[0] = extrema[1];\n  extrema[1] = tmp;\n}\n\nfunction windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n  // Quick reject\n  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {\n    return 0;\n  }\n\n  var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\n  if (nRoots === 0) {\n    return 0;\n  } else {\n    var w = 0;\n    var nExtrema = -1;\n    var y0_, y1_;\n\n    for (var i = 0; i < nRoots; i++) {\n      var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon\n\n      var unit = t === 0 || t === 1 ? 0.5 : 1;\n      var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\n      if (x_ < x) {\n        // Quick reject\n        continue;\n      }\n\n      if (nExtrema < 0) {\n        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\n        if (extrema[1] < extrema[0] && nExtrema > 1) {\n          swapExtrema();\n        }\n\n        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\n        if (nExtrema > 1) {\n          y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n        }\n      }\n\n      if (nExtrema == 2) {\n        // 分成三段单调函数\n        if (t < extrema[0]) {\n          w += y0_ < y0 ? unit : -unit;\n        } else if (t < extrema[1]) {\n          w += y1_ < y0_ ? unit : -unit;\n        } else {\n          w += y3 < y1_ ? unit : -unit;\n        }\n      } else {\n        // 分成两段单调函数\n        if (t < extrema[0]) {\n          w += y0_ < y0 ? unit : -unit;\n        } else {\n          w += y3 < y0_ ? unit : -unit;\n        }\n      }\n    }\n\n    return w;\n  }\n}\n\nfunction windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n  // Quick reject\n  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {\n    return 0;\n  }\n\n  var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\n  if (nRoots === 0) {\n    return 0;\n  } else {\n    var t = curve.quadraticExtremum(y0, y1, y2);\n\n    if (t >= 0 && t <= 1) {\n      var w = 0;\n      var y_ = curve.quadraticAt(y0, y1, y2, t);\n\n      for (var i = 0; i < nRoots; i++) {\n        // Remove one endpoint.\n        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;\n        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\n        if (x_ < x) {\n          // Quick reject\n          continue;\n        }\n\n        if (roots[i] < t) {\n          w += y_ < y0 ? unit : -unit;\n        } else {\n          w += y2 < y_ ? unit : -unit;\n        }\n      }\n\n      return w;\n    } else {\n      // Remove one endpoint.\n      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;\n      var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\n      if (x_ < x) {\n        // Quick reject\n        return 0;\n      }\n\n      return y2 < y0 ? unit : -unit;\n    }\n  }\n} // TODO\n// Arc 旋转\n\n\nfunction windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {\n  y -= cy;\n\n  if (y > r || y < -r) {\n    return 0;\n  }\n\n  var tmp = Math.sqrt(r * r - y * y);\n  roots[0] = -tmp;\n  roots[1] = tmp;\n  var diff = Math.abs(startAngle - endAngle);\n\n  if (diff < 1e-4) {\n    return 0;\n  }\n\n  if (diff % PI2 < 1e-4) {\n    // Is a circle\n    startAngle = 0;\n    endAngle = PI2;\n    var dir = anticlockwise ? 1 : -1;\n\n    if (x >= roots[0] + cx && x <= roots[1] + cx) {\n      return dir;\n    } else {\n      return 0;\n    }\n  }\n\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = normalizeRadian(endAngle);\n    endAngle = normalizeRadian(tmp);\n  } else {\n    startAngle = normalizeRadian(startAngle);\n    endAngle = normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var w = 0;\n\n  for (var i = 0; i < 2; i++) {\n    var x_ = roots[i];\n\n    if (x_ + cx > x) {\n      var angle = Math.atan2(y, x_);\n      var dir = anticlockwise ? 1 : -1;\n\n      if (angle < 0) {\n        angle = PI2 + angle;\n      }\n\n      if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n          dir = -dir;\n        }\n\n        w += dir;\n      }\n    }\n  }\n\n  return w;\n}\n\nfunction containPath(data, lineWidth, isStroke, x, y) {\n  var w = 0;\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n\n  for (var i = 0; i < data.length;) {\n    var cmd = data[i++]; // Begin a new subpath\n\n    if (cmd === CMD.M && i > 1) {\n      // Close previous subpath\n      if (!isStroke) {\n        w += windingLine(xi, yi, x0, y0, x, y);\n      } // 如果被任何一个 subpath 包含\n      // if (w !== 0) {\n      //     return true;\n      // }\n\n    }\n\n    if (i == 1) {\n      // 如果第一个命令是 L, C, Q\n      // 则 previous point 同绘制命令的第一个 point\n      //\n      // 第一个命令为 Arc 的情况下会在后面特殊处理\n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n    }\n\n    switch (cmd) {\n      case CMD.M:\n        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n        // 在 closePath 的时候使用\n        x0 = data[i++];\n        y0 = data[i++];\n        xi = x0;\n        yi = y0;\n        break;\n\n      case CMD.L:\n        if (isStroke) {\n          if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.C:\n        if (isStroke) {\n          if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.Q:\n        if (isStroke) {\n          if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.A:\n        // TODO Arc 判断的开销比较大\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++]; // TODO Arc 旋转\n\n        var psi = data[i++];\n        var anticlockwise = 1 - data[i++];\n        var x1 = Math.cos(theta) * rx + cx;\n        var y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令\n\n        if (i > 1) {\n          w += windingLine(xi, yi, x1, y1, x, y);\n        } else {\n          // 第一个命令起点还未定义\n          x0 = x1;\n          y0 = y1;\n        } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n\n\n        var _x = (x - cx) * ry / rx + cx;\n\n        if (isStroke) {\n          if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {\n            return true;\n          }\n        } else {\n          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);\n        }\n\n        xi = Math.cos(theta + dTheta) * rx + cx;\n        yi = Math.sin(theta + dTheta) * ry + cy;\n        break;\n\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        var width = data[i++];\n        var height = data[i++];\n        var x1 = x0 + width;\n        var y1 = y0 + height;\n\n        if (isStroke) {\n          if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // FIXME Clockwise ?\n          w += windingLine(x1, y0, x1, y1, x, y);\n          w += windingLine(x0, y1, x0, y0, x, y);\n        }\n\n        break;\n\n      case CMD.Z:\n        if (isStroke) {\n          if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // Close a subpath\n          w += windingLine(xi, yi, x0, y0, x, y); // 如果被任何一个 subpath 包含\n          // FIXME subpaths may overlap\n          // if (w !== 0) {\n          //     return true;\n          // }\n        }\n\n        xi = x0;\n        yi = y0;\n        break;\n    }\n  }\n\n  if (!isStroke && !isAroundEqual(yi, y0)) {\n    w += windingLine(xi, yi, x0, y0, x, y) || 0;\n  }\n\n  return w !== 0;\n}\n\nfunction contain(pathData, x, y) {\n  return containPath(pathData, 0, false, x, y);\n}\n\nfunction containStroke(pathData, lineWidth, x, y) {\n  return containPath(pathData, lineWidth, true, x, y);\n}\n\nexports.contain = contain;\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/path.js\n// module id = 32\n// module chunks = 0","/**\n * 线段包含判断\n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth;\n  var _a = 0;\n  var _b = x0; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {\n    return false;\n  }\n\n  if (x0 !== x1) {\n    _a = (y0 - y1) / (x0 - x1);\n    _b = (x0 * y1 - x1 * y0) / (x0 - x1);\n  } else {\n    return Math.abs(x - x0) <= _l / 2;\n  }\n\n  var tmp = _a * x - y + _b;\n\n  var _s = tmp * tmp / (_a * _a + 1);\n\n  return _s <= _l / 2 * _l / 2;\n}\n\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/line.js\n// module id = 33\n// module chunks = 0","var curve = require(\"../core/curve\");\n\n/**\n * 三次贝塞尔曲线描边包含判断\n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  x2\n * @param  {number}  y2\n * @param  {number}  x3\n * @param  {number}  y3\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {\n    return false;\n  }\n\n  var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);\n  return d <= _l / 2;\n}\n\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/cubic.js\n// module id = 34\n// module chunks = 0","var _curve = require(\"../core/curve\");\n\nvar quadraticProjectPoint = _curve.quadraticProjectPoint;\n\n/**\n * 二次贝塞尔曲线描边包含判断\n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  x2\n * @param  {number}  y2\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {\n    return false;\n  }\n\n  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);\n  return d <= _l / 2;\n}\n\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/quadratic.js\n// module id = 35\n// module chunks = 0","var _util = require(\"./util\");\n\nvar normalizeRadian = _util.normalizeRadian;\nvar PI2 = Math.PI * 2;\n/**\n * 圆弧描边包含判断\n * @param  {number}  cx\n * @param  {number}  cy\n * @param  {number}  r\n * @param  {number}  startAngle\n * @param  {number}  endAngle\n * @param  {boolean}  anticlockwise\n * @param  {number} lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {Boolean}\n */\n\nfunction containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth;\n  x -= cx;\n  y -= cy;\n  var d = Math.sqrt(x * x + y * y);\n\n  if (d - _l > r || d + _l < r) {\n    return false;\n  }\n\n  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n    // Is a circle\n    return true;\n  }\n\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = normalizeRadian(endAngle);\n    endAngle = normalizeRadian(tmp);\n  } else {\n    startAngle = normalizeRadian(startAngle);\n    endAngle = normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var angle = Math.atan2(y, x);\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;\n}\n\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/arc.js\n// module id = 36\n// module chunks = 0","var PI2 = Math.PI * 2;\n\nfunction normalizeRadian(angle) {\n  angle %= PI2;\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  return angle;\n}\n\nexports.normalizeRadian = normalizeRadian;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/util.js\n// module id = 37\n// module chunks = 0","function windingLine(x0, y0, x1, y1, x, y) {\n  if (y > y0 && y > y1 || y < y0 && y < y1) {\n    return 0;\n  } // Ignore horizontal line\n\n\n  if (y1 === y0) {\n    return 0;\n  }\n\n  var dir = y1 < y0 ? 1 : -1;\n  var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon\n\n  if (t === 1 || t === 0) {\n    dir = y1 < y0 ? 0.5 : -0.5;\n  }\n\n  var x_ = t * (x1 - x0) + x0;\n  return x_ > x ? dir : 0;\n}\n\nmodule.exports = windingLine;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/windingLine.js\n// module id = 38\n// module chunks = 0","var Pattern = function (image, repeat) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {image: ...}`, where this constructor will not be called.\n  this.image = image;\n  this.repeat = repeat; // Can be cloned\n\n  this.type = 'pattern';\n};\n\nPattern.prototype.getCanvasPattern = function (ctx) {\n  return ctx.createPattern(this.image, this.repeat || 'repeat');\n};\n\nvar _default = Pattern;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Pattern.js\n// module id = 39\n// module chunks = 0","var PathProxy = require(\"../core/PathProxy\");\n\nvar _vector = require(\"../core/vector\");\n\nvar v2ApplyTransform = _vector.applyTransform;\nvar CMD = PathProxy.CMD;\nvar points = [[], [], []];\nvar mathSqrt = Math.sqrt;\nvar mathAtan2 = Math.atan2;\n\nfunction _default(path, m) {\n  var data = path.data;\n  var cmd;\n  var nPoint;\n  var i;\n  var j;\n  var k;\n  var p;\n  var M = CMD.M;\n  var C = CMD.C;\n  var L = CMD.L;\n  var R = CMD.R;\n  var A = CMD.A;\n  var Q = CMD.Q;\n\n  for (i = 0, j = 0; i < data.length;) {\n    cmd = data[i++];\n    j = i;\n    nPoint = 0;\n\n    switch (cmd) {\n      case M:\n        nPoint = 1;\n        break;\n\n      case L:\n        nPoint = 1;\n        break;\n\n      case C:\n        nPoint = 3;\n        break;\n\n      case Q:\n        nPoint = 2;\n        break;\n\n      case A:\n        var x = m[4];\n        var y = m[5];\n        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n        var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx\n\n        data[i] *= sx;\n        data[i++] += x; // cy\n\n        data[i] *= sy;\n        data[i++] += y; // Scale rx and ry\n        // FIXME Assume psi is 0 here\n\n        data[i++] *= sx;\n        data[i++] *= sy; // Start angle\n\n        data[i++] += angle; // end angle\n\n        data[i++] += angle; // FIXME psi\n\n        i += 2;\n        j = i;\n        break;\n\n      case R:\n        // x0, y0\n        p[0] = data[i++];\n        p[1] = data[i++];\n        v2ApplyTransform(p, p, m);\n        data[j++] = p[0];\n        data[j++] = p[1]; // x1, y1\n\n        p[0] += data[i++];\n        p[1] += data[i++];\n        v2ApplyTransform(p, p, m);\n        data[j++] = p[0];\n        data[j++] = p[1];\n    }\n\n    for (k = 0; k < nPoint; k++) {\n      var p = points[k];\n      p[0] = data[i++];\n      p[1] = data[i++];\n      v2ApplyTransform(p, p, m); // Write back\n\n      data[j++] = p[0];\n      data[j++] = p[1];\n    }\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/transformPath.js\n// module id = 40\n// module chunks = 0","/**\n * @param {Array.<Object>} colorStops\n */\nvar Gradient = function (colorStops) {\n  this.colorStops = colorStops || [];\n};\n\nGradient.prototype = {\n  constructor: Gradient,\n  addColorStop: function (offset, color) {\n    this.colorStops.push({\n      offset: offset,\n      color: color\n    });\n  }\n};\nvar _default = Gradient;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Gradient.js\n// module id = 41\n// module chunks = 0","// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\nfunction Draggable() {\n  this.on('mousedown', this._dragStart, this);\n  this.on('mousemove', this._drag, this);\n  this.on('mouseup', this._dragEnd, this);\n  this.on('globalout', this._dragEnd, this); // this._dropTarget = null;\n  // this._draggingTarget = null;\n  // this._x = 0;\n  // this._y = 0;\n}\n\nDraggable.prototype = {\n  constructor: Draggable,\n  _dragStart: function (e) {\n    var draggingTarget = e.target;\n\n    if (draggingTarget && draggingTarget.draggable) {\n      this._draggingTarget = draggingTarget;\n      draggingTarget.dragging = true;\n      this._x = e.offsetX;\n      this._y = e.offsetY;\n      this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n    }\n  },\n  _drag: function (e) {\n    var draggingTarget = this._draggingTarget;\n\n    if (draggingTarget) {\n      var x = e.offsetX;\n      var y = e.offsetY;\n      var dx = x - this._x;\n      var dy = y - this._y;\n      this._x = x;\n      this._y = y;\n      draggingTarget.drift(dx, dy, e);\n      this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n      var dropTarget = this.findHover(x, y, draggingTarget).target;\n      var lastDropTarget = this._dropTarget;\n      this._dropTarget = dropTarget;\n\n      if (draggingTarget !== dropTarget) {\n        if (lastDropTarget && dropTarget !== lastDropTarget) {\n          this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n        }\n\n        if (dropTarget && dropTarget !== lastDropTarget) {\n          this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n        }\n      }\n    }\n  },\n  _dragEnd: function (e) {\n    var draggingTarget = this._draggingTarget;\n\n    if (draggingTarget) {\n      draggingTarget.dragging = false;\n    }\n\n    this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\n    if (this._dropTarget) {\n      this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n    }\n\n    this._draggingTarget = null;\n    this._dropTarget = null;\n  }\n};\n\nfunction param(target, e) {\n  return {\n    target: target,\n    topTarget: e && e.topTarget\n  };\n}\n\nvar _default = Draggable;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Draggable.js\n// module id = 42\n// module chunks = 0","var zrUtil = require(\"../core/util\");\n\nvar Element = require(\"../Element\");\n\nvar BoundingRect = require(\"../core/BoundingRect\");\n\n/**\n * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/container/Group');\n *     var Circle = require('zrender/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n/**\n * @alias module:zrender/graphic/Group\n * @constructor\n * @extends module:zrender/mixin/Transformable\n * @extends module:zrender/mixin/Eventful\n */\nvar Group = function (opts) {\n  opts = opts || {};\n  Element.call(this, opts);\n\n  for (var key in opts) {\n    if (opts.hasOwnProperty(key)) {\n      this[key] = opts[key];\n    }\n  }\n\n  this._children = [];\n  this.__storage = null;\n  this.__dirty = true;\n};\n\nGroup.prototype = {\n  constructor: Group,\n  isGroup: true,\n\n  /**\n   * @type {string}\n   */\n  type: 'group',\n\n  /**\n   * 所有子孙元素是否响应鼠标事件\n   * @name module:/zrender/container/Group#silent\n   * @type {boolean}\n   * @default false\n   */\n  silent: false,\n\n  /**\n   * @return {Array.<module:zrender/Element>}\n   */\n  children: function () {\n    return this._children.slice();\n  },\n\n  /**\n   * 获取指定 index 的儿子节点\n   * @param  {number} idx\n   * @return {module:zrender/Element}\n   */\n  childAt: function (idx) {\n    return this._children[idx];\n  },\n\n  /**\n   * 获取指定名字的儿子节点\n   * @param  {string} name\n   * @return {module:zrender/Element}\n   */\n  childOfName: function (name) {\n    var children = this._children;\n\n    for (var i = 0; i < children.length; i++) {\n      if (children[i].name === name) {\n        return children[i];\n      }\n    }\n  },\n\n  /**\n   * @return {number}\n   */\n  childCount: function () {\n    return this._children.length;\n  },\n\n  /**\n   * 添加子节点到最后\n   * @param {module:zrender/Element} child\n   */\n  add: function (child) {\n    if (child && child !== this && child.parent !== this) {\n      this._children.push(child);\n\n      this._doAdd(child);\n    }\n\n    return this;\n  },\n\n  /**\n   * 添加子节点在 nextSibling 之前\n   * @param {module:zrender/Element} child\n   * @param {module:zrender/Element} nextSibling\n   */\n  addBefore: function (child, nextSibling) {\n    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {\n      var children = this._children;\n      var idx = children.indexOf(nextSibling);\n\n      if (idx >= 0) {\n        children.splice(idx, 0, child);\n\n        this._doAdd(child);\n      }\n    }\n\n    return this;\n  },\n  _doAdd: function (child) {\n    if (child.parent) {\n      child.parent.remove(child);\n    }\n\n    child.parent = this;\n    var storage = this.__storage;\n    var zr = this.__zr;\n\n    if (storage && storage !== child.__storage) {\n      storage.addToStorage(child);\n\n      if (child instanceof Group) {\n        child.addChildrenToStorage(storage);\n      }\n    }\n\n    zr && zr.refresh();\n  },\n\n  /**\n   * 移除子节点\n   * @param {module:zrender/Element} child\n   */\n  remove: function (child) {\n    var zr = this.__zr;\n    var storage = this.__storage;\n    var children = this._children;\n    var idx = zrUtil.indexOf(children, child);\n\n    if (idx < 0) {\n      return this;\n    }\n\n    children.splice(idx, 1);\n    child.parent = null;\n\n    if (storage) {\n      storage.delFromStorage(child);\n\n      if (child instanceof Group) {\n        child.delChildrenFromStorage(storage);\n      }\n    }\n\n    zr && zr.refresh();\n    return this;\n  },\n\n  /**\n   * 移除所有子节点\n   */\n  removeAll: function () {\n    var children = this._children;\n    var storage = this.__storage;\n    var child;\n    var i;\n\n    for (i = 0; i < children.length; i++) {\n      child = children[i];\n\n      if (storage) {\n        storage.delFromStorage(child);\n\n        if (child instanceof Group) {\n          child.delChildrenFromStorage(storage);\n        }\n      }\n\n      child.parent = null;\n    }\n\n    children.length = 0;\n    return this;\n  },\n\n  /**\n   * 遍历所有子节点\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  eachChild: function (cb, context) {\n    var children = this._children;\n\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n      cb.call(context, child, i);\n    }\n\n    return this;\n  },\n\n  /**\n   * 深度优先遍历所有子孙节点\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      cb.call(context, child);\n\n      if (child.type === 'group') {\n        child.traverse(cb, context);\n      }\n    }\n\n    return this;\n  },\n  addChildrenToStorage: function (storage) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      storage.addToStorage(child);\n\n      if (child instanceof Group) {\n        child.addChildrenToStorage(storage);\n      }\n    }\n  },\n  delChildrenFromStorage: function (storage) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      storage.delFromStorage(child);\n\n      if (child instanceof Group) {\n        child.delChildrenFromStorage(storage);\n      }\n    }\n  },\n  dirty: function () {\n    this.__dirty = true;\n    this.__zr && this.__zr.refresh();\n    return this;\n  },\n\n  /**\n   * @return {module:zrender/core/BoundingRect}\n   */\n  getBoundingRect: function (includeChildren) {\n    // TODO Caching\n    var rect = null;\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var children = includeChildren || this._children;\n    var tmpMat = [];\n\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n\n      if (child.ignore || child.invisible) {\n        continue;\n      }\n\n      var childRect = child.getBoundingRect();\n      var transform = child.getLocalTransform(tmpMat); // TODO\n      // The boundingRect cacluated by transforming original\n      // rect may be bigger than the actual bundingRect when rotation\n      // is used. (Consider a circle rotated aginst its center, where\n      // the actual boundingRect should be the same as that not be\n      // rotated.) But we can not find better approach to calculate\n      // actual boundingRect yet, considering performance.\n\n      if (transform) {\n        tmpRect.copy(childRect);\n        tmpRect.applyTransform(transform);\n        rect = rect || tmpRect.clone();\n        rect.union(tmpRect);\n      } else {\n        rect = rect || childRect.clone();\n        rect.union(childRect);\n      }\n    }\n\n    return rect || tmpRect;\n  }\n};\nzrUtil.inherits(Group, Element);\nvar _default = Group;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/container/Group.js\n// module id = 43\n// module chunks = 0","var Displayable = require(\"./Displayable\");\n\nvar BoundingRect = require(\"../core/BoundingRect\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar imageHelper = require(\"./helper/image\");\n\n/**\n * @alias zrender/graphic/Image\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\nfunction ZImage(opts) {\n  Displayable.call(this, opts);\n}\n\nZImage.prototype = {\n  constructor: ZImage,\n  type: 'image',\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var src = style.image; // Must bind each time\n\n    style.bind(ctx, this, prevEl);\n    var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);\n\n    if (!image || !imageHelper.isImageReady(image)) {\n      return;\n    } // 图片已经加载完成\n    // if (image.nodeName.toUpperCase() == 'IMG') {\n    //     if (!image.complete) {\n    //         return;\n    //     }\n    // }\n    // Else is canvas\n\n\n    var x = style.x || 0;\n    var y = style.y || 0;\n    var width = style.width;\n    var height = style.height;\n    var aspect = image.width / image.height;\n\n    if (width == null && height != null) {\n      // Keep image/height ratio\n      width = height * aspect;\n    } else if (height == null && width != null) {\n      height = width / aspect;\n    } else if (width == null && height == null) {\n      width = image.width;\n      height = image.height;\n    } // 设置transform\n\n\n    this.setTransform(ctx);\n\n    if (style.sWidth && style.sHeight) {\n      var sx = style.sx || 0;\n      var sy = style.sy || 0;\n      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n    } else if (style.sx && style.sy) {\n      var sx = style.sx;\n      var sy = style.sy;\n      var sWidth = width - sx;\n      var sHeight = height - sy;\n      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n    } else {\n      ctx.drawImage(image, x, y, width, height);\n    }\n\n    this.restoreTransform(ctx); // Draw rect text\n\n    if (style.text != null) {\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  getBoundingRect: function () {\n    var style = this.style;\n\n    if (!this._rect) {\n      this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);\n    }\n\n    return this._rect;\n  }\n};\nzrUtil.inherits(ZImage, Displayable);\nvar _default = ZImage;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Image.js\n// module id = 44\n// module chunks = 0","var Displayable = require(\"./Displayable\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar textContain = require(\"../contain/text\");\n\nvar textHelper = require(\"./helper/text\");\n\n/**\n * @alias zrender/graphic/Text\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\nvar Text = function (opts) {\n  // jshint ignore:line\n  Displayable.call(this, opts);\n};\n\nText.prototype = {\n  constructor: Text,\n  type: 'text',\n  brush: function (ctx, prevEl) {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true); // Use props with prefix 'text'.\n\n    style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;\n    var text = style.text; // Convert to string\n\n    text != null && (text += ''); // Always bind style\n\n    style.bind(ctx, this, prevEl);\n\n    if (!textHelper.needDrawText(text, style)) {\n      return;\n    }\n\n    this.setTransform(ctx);\n    textHelper.renderText(this, ctx, text, style);\n    this.restoreTransform(ctx);\n  },\n  getBoundingRect: function () {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true);\n\n    if (!this._rect) {\n      var text = style.text;\n      text != null ? text += '' : text = '';\n      var rect = textContain.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.rich);\n      rect.x += style.x || 0;\n      rect.y += style.y || 0;\n\n      if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {\n        var w = style.textStrokeWidth;\n        rect.x -= w / 2;\n        rect.y -= w / 2;\n        rect.width += w;\n        rect.height += w;\n      }\n\n      this._rect = rect;\n    }\n\n    return this._rect;\n  }\n};\nzrUtil.inherits(Text, Displayable);\nvar _default = Text;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Text.js\n// module id = 45\n// module chunks = 0","var Path = require(\"../Path\");\n\n/**\n * 圆形\n * @module zrender/shape/Circle\n */\nvar _default = Path.extend({\n  type: 'circle',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0\n  },\n  buildPath: function (ctx, shape, inBundle) {\n    // Better stroking in ShapeBundle\n    // Always do it may have performence issue ( fill may be 2x more cost)\n    if (inBundle) {\n      ctx.moveTo(shape.cx + shape.r, shape.cy);\n    } // else {\n    //     if (ctx.allocate && !ctx.data.length) {\n    //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n    //     }\n    // }\n    // Better stroking in ShapeBundle\n    // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\n\n    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Circle.js\n// module id = 46\n// module chunks = 0","var Path = require(\"../Path\");\n\nvar fixClipWithShadow = require(\"../helper/fixClipWithShadow\");\n\n/**\n * 扇形\n * @module zrender/graphic/shape/Sector\n */\nvar _default = Path.extend({\n  type: 'sector',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r0: 0,\n    r: 0,\n    startAngle: 0,\n    endAngle: Math.PI * 2,\n    clockwise: true\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var r0 = Math.max(shape.r0 || 0, 0);\n    var r = Math.max(shape.r, 0);\n    var startAngle = shape.startAngle;\n    var endAngle = shape.endAngle;\n    var clockwise = shape.clockwise;\n    var unitX = Math.cos(startAngle);\n    var unitY = Math.sin(startAngle);\n    ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n    ctx.lineTo(unitX * r + x, unitY * r + y);\n    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n    ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);\n\n    if (r0 !== 0) {\n      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n    }\n\n    ctx.closePath();\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Sector.js\n// module id = 47\n// module chunks = 0","var env = require(\"../../core/env\");\n\n// Fix weird bug in some version of IE11 (like 11.0.9600.178**),\n// where exception \"unexpected call to method or property access\"\n// might be thrown when calling ctx.fill or ctx.stroke after a path\n// whose area size is zero is drawn and ctx.clip() is called and\n// shadowBlur is set. See #4572, #3112, #5777.\n// (e.g.,\n//  ctx.moveTo(10, 10);\n//  ctx.lineTo(20, 10);\n//  ctx.closePath();\n//  ctx.clip();\n//  ctx.shadowBlur = 10;\n//  ...\n//  ctx.fill();\n// )\nvar shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];\n\nfunction _default(orignalBrush) {\n  // version string can be: '11.0'\n  return env.browser.ie && env.browser.version >= 11 ? function () {\n    var clipPaths = this.__clipPaths;\n    var style = this.style;\n    var modified;\n\n    if (clipPaths) {\n      for (var i = 0; i < clipPaths.length; i++) {\n        var clipPath = clipPaths[i];\n        var shape = clipPath && clipPath.shape;\n        var type = clipPath && clipPath.type;\n\n        if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {\n          for (var j = 0; j < shadowTemp.length; j++) {\n            // It is save to put shadowTemp static, because shadowTemp\n            // will be all modified each item brush called.\n            shadowTemp[j][2] = style[shadowTemp[j][0]];\n            style[shadowTemp[j][0]] = shadowTemp[j][1];\n          }\n\n          modified = true;\n          break;\n        }\n      }\n    }\n\n    orignalBrush.apply(this, arguments);\n\n    if (modified) {\n      for (var j = 0; j < shadowTemp.length; j++) {\n        style[shadowTemp[j][0]] = shadowTemp[j][2];\n      }\n    }\n  } : orignalBrush;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/fixClipWithShadow.js\n// module id = 48\n// module chunks = 0","/**\n * echarts设备环境识别\n *\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\nvar env = {};\n\nif (typeof navigator === 'undefined') {\n  // In node\n  env = {\n    browser: {},\n    os: {},\n    node: true,\n    // Assume canvas is supported\n    canvasSupported: true,\n    svgSupported: true\n  };\n} else {\n  env = detect(navigator.userAgent);\n}\n\nvar _default = env; // Zepto.js\n// (c) 2010-2013 Thomas Fuchs\n// Zepto.js may be freely distributed under the MIT license.\n\nfunction detect(ua) {\n  var os = {};\n  var browser = {}; // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n  // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n  // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n  // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n  // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n  // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n  // var touchpad = webos && ua.match(/TouchPad/);\n  // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n  // var silk = ua.match(/Silk\\/([\\d._]+)/);\n  // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n  // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n  // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n  // var playbook = ua.match(/PlayBook/);\n  // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\n  var firefox = ua.match(/Firefox\\/([\\d.]+)/); // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n  // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\n  var ie = ua.match(/MSIE\\s([\\d.]+)/) // IE 11 Trident/7.0; rv:11.0\n  || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n  var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n  var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:\n  // - discern (more) between multiple browsers on android\n  // - decide if kindle fire in silk mode is android or not\n  // - Firefox on Android doesn't specify the Android version\n  // - possibly devide in os, device and browser hashes\n  // if (browser.webkit = !!webkit) browser.version = webkit[1];\n  // if (android) os.android = true, os.version = android[2];\n  // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n  // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n  // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n  // if (webos) os.webos = true, os.version = webos[2];\n  // if (touchpad) os.touchpad = true;\n  // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n  // if (bb10) os.bb10 = true, os.version = bb10[2];\n  // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n  // if (playbook) browser.playbook = true;\n  // if (kindle) os.kindle = true, os.version = kindle[1];\n  // if (silk) browser.silk = true, browser.version = silk[1];\n  // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n  // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\n  if (firefox) {\n    browser.firefox = true;\n    browser.version = firefox[1];\n  } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n  // if (webview) browser.webview = true;\n\n\n  if (ie) {\n    browser.ie = true;\n    browser.version = ie[1];\n  }\n\n  if (edge) {\n    browser.edge = true;\n    browser.version = edge[1];\n  } // It is difficult to detect WeChat in Win Phone precisely, because ua can\n  // not be set on win phone. So we do not consider Win Phone.\n\n\n  if (weChat) {\n    browser.weChat = true;\n  } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n  //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n  // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n  //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n  //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n\n  return {\n    browser: browser,\n    os: os,\n    node: false,\n    // 原生canvas支持，改极端点了\n    // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n    canvasSupported: !!document.createElement('canvas').getContext,\n    svgSupported: typeof SVGRect !== 'undefined',\n    // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n    // works on most browsers\n    // IE10/11 does not support touch event, and MS Edge supports them but not by\n    // default, so we dont check navigator.maxTouchPoints for them here.\n    touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n    // <http://caniuse.com/#search=pointer%20event>.\n    pointerEventsSupported: 'onpointerdown' in window // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n    // events currently. So we dont use that on other browsers unless tested sufficiently.\n    // Although IE 10 supports pointer event, it use old style and is different from the\n    // standard. So we exclude that. (IE 10 is hardly used on touch device)\n    && (browser.edge || browser.ie && browser.version >= 11)\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/env.js\n// module id = 49\n// module chunks = 0","var Path = require(\"../Path\");\n\n/**\n * 圆环\n * @module zrender/graphic/shape/Ring\n */\nvar _default = Path.extend({\n  type: 'ring',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0,\n    r0: 0\n  },\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var PI2 = Math.PI * 2;\n    ctx.moveTo(x + shape.r, y);\n    ctx.arc(x, y, shape.r, 0, PI2, false);\n    ctx.moveTo(x + shape.r0, y);\n    ctx.arc(x, y, shape.r0, 0, PI2, true);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Ring.js\n// module id = 50\n// module chunks = 0","var Path = require(\"../Path\");\n\nvar polyHelper = require(\"../helper/poly\");\n\n/**\n * 多边形\n * @module zrender/shape/Polygon\n */\nvar _default = Path.extend({\n  type: 'polygon',\n  shape: {\n    points: null,\n    smooth: false,\n    smoothConstraint: null\n  },\n  buildPath: function (ctx, shape) {\n    polyHelper.buildPath(ctx, shape, true);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Polygon.js\n// module id = 51\n// module chunks = 0","var smoothSpline = require(\"./smoothSpline\");\n\nvar smoothBezier = require(\"./smoothBezier\");\n\nfunction buildPath(ctx, shape, closePath) {\n  var points = shape.points;\n  var smooth = shape.smooth;\n\n  if (points && points.length >= 2) {\n    if (smooth && smooth !== 'spline') {\n      var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);\n      ctx.moveTo(points[0][0], points[0][1]);\n      var len = points.length;\n\n      for (var i = 0; i < (closePath ? len : len - 1); i++) {\n        var cp1 = controlPoints[i * 2];\n        var cp2 = controlPoints[i * 2 + 1];\n        var p = points[(i + 1) % len];\n        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);\n      }\n    } else {\n      if (smooth === 'spline') {\n        points = smoothSpline(points, closePath);\n      }\n\n      ctx.moveTo(points[0][0], points[0][1]);\n\n      for (var i = 1, l = points.length; i < l; i++) {\n        ctx.lineTo(points[i][0], points[i][1]);\n      }\n    }\n\n    closePath && ctx.closePath();\n  }\n}\n\nexports.buildPath = buildPath;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/poly.js\n// module id = 52\n// module chunks = 0","var _vector = require(\"../../core/vector\");\n\nvar v2Distance = _vector.distance;\n\n/**\n * Catmull-Rom spline 插值折线\n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n/**\n * @inner\n */\nfunction interpolate(p0, p1, p2, p3, t, t2, t3) {\n  var v0 = (p2 - p0) * 0.5;\n  var v1 = (p3 - p1) * 0.5;\n  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n}\n/**\n * @alias module:zrender/shape/util/smoothSpline\n * @param {Array} points 线段顶点数组\n * @param {boolean} isLoop\n * @return {Array}\n */\n\n\nfunction _default(points, isLoop) {\n  var len = points.length;\n  var ret = [];\n  var distance = 0;\n\n  for (var i = 1; i < len; i++) {\n    distance += v2Distance(points[i - 1], points[i]);\n  }\n\n  var segs = distance / 2;\n  segs = segs < len ? len : segs;\n\n  for (var i = 0; i < segs; i++) {\n    var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n    var idx = Math.floor(pos);\n    var w = pos - idx;\n    var p0;\n    var p1 = points[idx % len];\n    var p2;\n    var p3;\n\n    if (!isLoop) {\n      p0 = points[idx === 0 ? idx : idx - 1];\n      p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n      p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n    } else {\n      p0 = points[(idx - 1 + len) % len];\n      p2 = points[(idx + 1) % len];\n      p3 = points[(idx + 2) % len];\n    }\n\n    var w2 = w * w;\n    var w3 = w * w2;\n    ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);\n  }\n\n  return ret;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/smoothSpline.js\n// module id = 53\n// module chunks = 0","var _vector = require(\"../../core/vector\");\n\nvar v2Min = _vector.min;\nvar v2Max = _vector.max;\nvar v2Scale = _vector.scale;\nvar v2Distance = _vector.distance;\nvar v2Add = _vector.add;\nvar v2Clone = _vector.clone;\nvar v2Sub = _vector.sub;\n\n/**\n * 贝塞尔平滑曲线\n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n/**\n * 贝塞尔平滑曲线\n * @alias module:zrender/shape/util/smoothBezier\n * @param {Array} points 线段顶点数组\n * @param {number} smooth 平滑等级, 0-1\n * @param {boolean} isLoop\n * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n *                           整个折线的包围盒做一个并集用来约束控制点。\n * @param {Array} 计算出来的控制点数组\n */\nfunction _default(points, smooth, isLoop, constraint) {\n  var cps = [];\n  var v = [];\n  var v1 = [];\n  var v2 = [];\n  var prevPoint;\n  var nextPoint;\n  var min, max;\n\n  if (constraint) {\n    min = [Infinity, Infinity];\n    max = [-Infinity, -Infinity];\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      v2Min(min, min, points[i]);\n      v2Max(max, max, points[i]);\n    } // 与指定的包围盒做并集\n\n\n    v2Min(min, min, constraint[0]);\n    v2Max(max, max, constraint[1]);\n  }\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n\n    if (isLoop) {\n      prevPoint = points[i ? i - 1 : len - 1];\n      nextPoint = points[(i + 1) % len];\n    } else {\n      if (i === 0 || i === len - 1) {\n        cps.push(v2Clone(points[i]));\n        continue;\n      } else {\n        prevPoint = points[i - 1];\n        nextPoint = points[i + 1];\n      }\n    }\n\n    v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length\n\n    v2Scale(v, v, smooth);\n    var d0 = v2Distance(point, prevPoint);\n    var d1 = v2Distance(point, nextPoint);\n    var sum = d0 + d1;\n\n    if (sum !== 0) {\n      d0 /= sum;\n      d1 /= sum;\n    }\n\n    v2Scale(v1, v, -d0);\n    v2Scale(v2, v, d1);\n    var cp0 = v2Add([], point, v1);\n    var cp1 = v2Add([], point, v2);\n\n    if (constraint) {\n      v2Max(cp0, cp0, min);\n      v2Min(cp0, cp0, max);\n      v2Max(cp1, cp1, min);\n      v2Min(cp1, cp1, max);\n    }\n\n    cps.push(cp0);\n    cps.push(cp1);\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n\n  return cps;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/smoothBezier.js\n// module id = 54\n// module chunks = 0","var Path = require(\"../Path\");\n\nvar polyHelper = require(\"../helper/poly\");\n\n/**\n * @module zrender/graphic/shape/Polyline\n */\nvar _default = Path.extend({\n  type: 'polyline',\n  shape: {\n    points: null,\n    smooth: false,\n    smoothConstraint: null\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    polyHelper.buildPath(ctx, shape, false);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Polyline.js\n// module id = 55\n// module chunks = 0","var Path = require(\"../Path\");\n\nvar roundRectHelper = require(\"../helper/roundRect\");\n\n/**\n * 矩形\n * @module zrender/graphic/shape/Rect\n */\nvar _default = Path.extend({\n  type: 'rect',\n  shape: {\n    // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n    // r缩写为1         相当于 [1, 1, 1, 1]\n    // r缩写为[1]       相当于 [1, 1, 1, 1]\n    // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n    // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n    r: 0,\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (ctx, shape) {\n    var x = shape.x;\n    var y = shape.y;\n    var width = shape.width;\n    var height = shape.height;\n\n    if (!shape.r) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, shape);\n    }\n\n    ctx.closePath();\n    return;\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Rect.js\n// module id = 56\n// module chunks = 0","var Path = require(\"../Path\");\n\n/**\n * 直线\n * @module zrender/graphic/shape/Line\n */\nvar _default = Path.extend({\n  type: 'line',\n  shape: {\n    // Start point\n    x1: 0,\n    y1: 0,\n    // End point\n    x2: 0,\n    y2: 0,\n    percent: 1\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x1 = shape.x1;\n    var y1 = shape.y1;\n    var x2 = shape.x2;\n    var y2 = shape.y2;\n    var percent = shape.percent;\n\n    if (percent === 0) {\n      return;\n    }\n\n    ctx.moveTo(x1, y1);\n\n    if (percent < 1) {\n      x2 = x1 * (1 - percent) + x2 * percent;\n      y2 = y1 * (1 - percent) + y2 * percent;\n    }\n\n    ctx.lineTo(x2, y2);\n  },\n\n  /**\n   * Get point at percent\n   * @param  {number} percent\n   * @return {Array.<number>}\n   */\n  pointAt: function (p) {\n    var shape = this.shape;\n    return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Line.js\n// module id = 57\n// module chunks = 0","var Path = require(\"../Path\");\n\nvar vec2 = require(\"../../core/vector\");\n\nvar _curve = require(\"../../core/curve\");\n\nvar quadraticSubdivide = _curve.quadraticSubdivide;\nvar cubicSubdivide = _curve.cubicSubdivide;\nvar quadraticAt = _curve.quadraticAt;\nvar cubicAt = _curve.cubicAt;\nvar quadraticDerivativeAt = _curve.quadraticDerivativeAt;\nvar cubicDerivativeAt = _curve.cubicDerivativeAt;\n\n/**\n * 贝塞尔曲线\n * @module zrender/shape/BezierCurve\n */\nvar out = [];\n\nfunction someVectorAt(shape, t, isTangent) {\n  var cpx2 = shape.cpx2;\n  var cpy2 = shape.cpy2;\n\n  if (cpx2 === null || cpy2 === null) {\n    return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];\n  } else {\n    return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];\n  }\n}\n\nvar _default = Path.extend({\n  type: 'bezier-curve',\n  shape: {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0,\n    cpx1: 0,\n    cpy1: 0,\n    // cpx2: 0,\n    // cpy2: 0\n    // Curve show percent, for animating\n    percent: 1\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x1 = shape.x1;\n    var y1 = shape.y1;\n    var x2 = shape.x2;\n    var y2 = shape.y2;\n    var cpx1 = shape.cpx1;\n    var cpy1 = shape.cpy1;\n    var cpx2 = shape.cpx2;\n    var cpy2 = shape.cpy2;\n    var percent = shape.percent;\n\n    if (percent === 0) {\n      return;\n    }\n\n    ctx.moveTo(x1, y1);\n\n    if (cpx2 == null || cpy2 == null) {\n      if (percent < 1) {\n        quadraticSubdivide(x1, cpx1, x2, percent, out);\n        cpx1 = out[1];\n        x2 = out[2];\n        quadraticSubdivide(y1, cpy1, y2, percent, out);\n        cpy1 = out[1];\n        y2 = out[2];\n      }\n\n      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n    } else {\n      if (percent < 1) {\n        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n        cpx1 = out[1];\n        cpx2 = out[2];\n        x2 = out[3];\n        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n        cpy1 = out[1];\n        cpy2 = out[2];\n        y2 = out[3];\n      }\n\n      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n    }\n  },\n\n  /**\n   * Get point at percent\n   * @param  {number} t\n   * @return {Array.<number>}\n   */\n  pointAt: function (t) {\n    return someVectorAt(this.shape, t, false);\n  },\n\n  /**\n   * Get tangent at percent\n   * @param  {number} t\n   * @return {Array.<number>}\n   */\n  tangentAt: function (t) {\n    var p = someVectorAt(this.shape, t, true);\n    return vec2.normalize(p, p);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/BezierCurve.js\n// module id = 58\n// module chunks = 0","var Path = require(\"../Path\");\n\n/**\n * 圆弧\n * @module zrender/graphic/shape/Arc\n */\nvar _default = Path.extend({\n  type: 'arc',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0,\n    startAngle: 0,\n    endAngle: Math.PI * 2,\n    clockwise: true\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var r = Math.max(shape.r, 0);\n    var startAngle = shape.startAngle;\n    var endAngle = shape.endAngle;\n    var clockwise = shape.clockwise;\n    var unitX = Math.cos(startAngle);\n    var unitY = Math.sin(startAngle);\n    ctx.moveTo(unitX * r + x, unitY * r + y);\n    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Arc.js\n// module id = 59\n// module chunks = 0","var zrUtil = require(\"../core/util\");\n\nvar Gradient = require(\"./Gradient\");\n\n/**\n * x, y, x2, y2 are all percent from 0 to 1\n * @param {number} [x=0]\n * @param {number} [y=0]\n * @param {number} [x2=1]\n * @param {number} [y2=0]\n * @param {Array.<Object>} colorStops\n * @param {boolean} [globalCoord=false]\n */\nvar LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {type: 'linear', colorStops: ...}`, where\n  // this constructor will not be called.\n  this.x = x == null ? 0 : x;\n  this.y = y == null ? 0 : y;\n  this.x2 = x2 == null ? 1 : x2;\n  this.y2 = y2 == null ? 0 : y2; // Can be cloned\n\n  this.type = 'linear'; // If use global coord\n\n  this.global = globalCoord || false;\n  Gradient.call(this, colorStops);\n};\n\nLinearGradient.prototype = {\n  constructor: LinearGradient\n};\nzrUtil.inherits(LinearGradient, Gradient);\nvar _default = LinearGradient;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/LinearGradient.js\n// module id = 60\n// module chunks = 0","var zrUtil = require(\"../core/util\");\n\nvar Gradient = require(\"./Gradient\");\n\n/**\n * x, y, r are all percent from 0 to 1\n * @param {number} [x=0.5]\n * @param {number} [y=0.5]\n * @param {number} [r=0.5]\n * @param {Array.<Object>} [colorStops]\n * @param {boolean} [globalCoord=false]\n */\nvar RadialGradient = function (x, y, r, colorStops, globalCoord) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {type: 'radial', colorStops: ...}`, where\n  // this constructor will not be called.\n  this.x = x == null ? 0.5 : x;\n  this.y = y == null ? 0.5 : y;\n  this.r = r == null ? 0.5 : r; // Can be cloned\n\n  this.type = 'radial'; // If use global coord\n\n  this.global = globalCoord || false;\n  Gradient.call(this, colorStops);\n};\n\nRadialGradient.prototype = {\n  constructor: RadialGradient\n};\nzrUtil.inherits(RadialGradient, Gradient);\nvar _default = RadialGradient;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/RadialGradient.js\n// module id = 61\n// module chunks = 0","var zrUtil = require(\"../core/util\");\n\nvar Style = require(\"./Style\");\n\nvar _vector = require(\"../core/vector\");\n\nvar vec2Copy = _vector.copy;\n\n/**\n * States machine for managing graphic states\n */\n\n/**\n * @typedef {Object} IGraphicState\n * @property {number} [zlevel]\n * @property {number} [z]\n * @property {Array.<number>} {position}\n * @property {Array.<number>|number} {rotation}\n * @property {Array.<number>} {scale}\n * @property {Object} style\n *\n * @property {Function} onenter\n * @property {Function} onleave\n * @property {Function} ontransition\n * @property {Array.<IGraphicStateTransition|string>} transition\n *           Transition object or a string descriptor like '* 30 0 Linear'\n */\nvar transitionProperties = ['position', 'rotation', 'scale', 'style', 'shape'];\n/**\n * @module zrender/graphic/States~TransitionObject\n */\n\nvar TransitionObject = function (opts) {\n  if (typeof opts == 'string') {\n    this._fromStr(opts);\n  } else if (opts) {\n    opts.property && (this.property = opts.property);\n    opts.duration != null && (this.duration = opts.duration);\n    opts.easing && (this.easing = opts.easing);\n    opts.delay && (this.delay = opts.delay);\n  }\n\n  if (this.property !== '*') {\n    this.property = this.property.split(',');\n  } else {\n    this.property = transitionProperties;\n  }\n};\n\nTransitionObject.prototype = {\n  constructor: TransitionObject,\n\n  /**\n   * List of all transition properties. Splitted by comma. Must not have spaces in the string.\n   * e.g. 'position,style.color'. '*' will match all the valid properties.\n   * @type {string}\n   * @default *\n   */\n  property: '*',\n\n  /**\n   * @type {string}\n   * @default 'Linear'\n   */\n  easing: 'Linear',\n\n  /**\n   * @type {number}\n   * @default 'number'\n   */\n  duration: 500,\n\n  /**\n   * @type {number}\n   */\n  delay: 0,\n  _fromStr: function (str) {\n    var arr = str.split(/\\s+/g);\n    this.property = arr[0];\n    this.duration = +arr[1];\n    this.delay = +arr[2];\n    this.easing = arr[3];\n  }\n};\n/**\n * @alias module:zrender/graphic/States\n */\n\nvar GraphicStates = function (opts) {\n  opts = opts || {};\n  this._states = {};\n  /**\n   * Target element\n   * @type {zrender/graphic/Displayable|zrender/container/Group}\n   */\n\n  this._el = opts.el;\n  this._subStates = [];\n  this._transitionAnimators = [];\n\n  if (opts.initialState) {\n    this._initialState = opts.initialState;\n  }\n\n  var optsStates = opts.states;\n\n  if (optsStates) {\n    for (var name in optsStates) {\n      if (optsStates.hasOwnProperty(name)) {\n        var state = optsStates[name];\n\n        this._addState(name, state);\n      }\n    }\n  }\n\n  this.setState(this._initialState);\n};\n\nGraphicStates.prototype = {\n  constructor: GraphicStates,\n\n  /**\n   * All other state will be extended from initial state\n   * @type {string}\n   * @private\n   */\n  _initialState: 'normal',\n\n  /**\n   * Current state\n   * @type {string}\n   * @private\n   */\n  _currentState: '',\n  el: function () {\n    return this._el;\n  },\n  _addState: function (name, state) {\n    this._states[name] = state;\n\n    if (state.transition) {\n      state.transition = new TransitionObject(state.transition);\n    } // Extend from initial state\n\n\n    if (name !== this._initialState) {\n      this._extendFromInitial(state);\n    } else {\n      var el = this._el; // setState 的时候自带的 style 和 shape 都会被直接覆盖\n      // 所以这边先把自带的 style 和 shape 扩展到初始状态中\n\n      zrUtil.merge(state.style, el.style, false, false);\n\n      if (state.shape) {\n        zrUtil.merge(state.shape, el.shape, false, true);\n      } else {\n        state.shape = zrUtil.clone(el.shape, true);\n      }\n\n      for (var name in this._states) {\n        if (this._states.hasOwnProperty(name)) {\n          this._extendFromInitial(this._states[name]);\n        }\n      }\n    }\n  },\n  _extendFromInitial: function (state) {\n    var initialState = this._states[this._initialState];\n\n    if (initialState && state !== initialState) {\n      zrUtil.merge(state, initialState, false, true);\n    }\n  },\n  setState: function (name, silent) {\n    if (name === this._currentState && !this.transiting()) {\n      return;\n    }\n\n    var state = this._states[name];\n\n    if (state) {\n      this._stopTransition();\n\n      if (!silent) {\n        var prevState = this._states[this._currentState];\n\n        if (prevState) {\n          prevState.onleave && prevState.onleave.call(this);\n        }\n\n        state.onenter && state.onenter.call(this);\n      }\n\n      this._currentState = name;\n\n      if (this._el) {\n        var el = this._el; // Setting attributes\n\n        if (state.zlevel != null) {\n          el.zlevel = state.zlevel;\n        }\n\n        if (state.z != null) {\n          el.z = state.z;\n        } // SRT\n\n\n        state.position && vec2Copy(el.position, state.position);\n        state.scale && vec2Copy(el.scale, state.scale);\n\n        if (state.rotation != null) {\n          el.rotation = state.rotation;\n        } // Style\n\n\n        if (state.style) {\n          var initialState = this._states[this._initialState];\n          el.style = new Style();\n\n          if (initialState) {\n            el.style.extendFrom(initialState.style, false);\n          }\n\n          if ( // Not initial state\n          name != this._initialState // Not copied from initial state in _extendFromInitial method\n          && initialState.style !== state.style) {\n            el.style.extendFrom(state.style, true);\n          }\n        }\n\n        if (state.shape) {\n          el.shape = zrUtil.clone(state.shape, true);\n        }\n\n        el.dirty();\n      }\n    }\n\n    for (var i = 0; i < this._subStates.length; i++) {\n      this._subStates.setState(name);\n    }\n  },\n  getState: function () {\n    return this._currentState;\n  },\n  transitionState: function (target, done) {\n    if (target === this._currentState && !this.transiting()) {\n      return;\n    }\n\n    var state = this._states[target];\n    var styleShapeReg = /$[style|shape]\\./;\n    var self = this; // Animation 去重\n\n    var propPathMap = {};\n\n    if (state) {\n      self._stopTransition();\n\n      var el = self._el;\n\n      if (state.transition && el && el.__zr) {\n        // El can be animated\n        var transitionCfg = state.transition;\n        var property = transitionCfg.property;\n        var animatingCount = 0;\n\n        var animationDone = function () {\n          animatingCount--;\n\n          if (animatingCount === 0) {\n            self.setState(target);\n            done && done();\n          }\n        };\n\n        for (var i = 0; i < property.length; i++) {\n          var propName = property[i]; // Animating all the properties in style or shape\n\n          if (propName === 'style' || propName === 'shape') {\n            if (state[propName]) {\n              for (var key in state[propName]) {\n                if (!state[propName].hasOwnProperty(key)) {\n                  continue;\n                }\n\n                var path = propName + '.' + key;\n\n                if (propPathMap[path]) {\n                  continue;\n                }\n\n                propPathMap[path] = 1;\n                animatingCount += self._animProp(state, propName, key, transitionCfg, animationDone);\n              }\n            }\n          } else {\n            if (propPathMap[propName]) {\n              continue;\n            }\n\n            propPathMap[propName] = 1; // Animating particular property in style or style\n\n            if (propName.match(styleShapeReg)) {\n              // remove 'style.', 'shape.' prefix\n              var subProp = propName.slice(0, 5);\n              propName = propName.slice(6);\n              animatingCount += self._animProp(state, subProp, propName, transitionCfg, animationDone);\n            } else {\n              animatingCount += self._animProp(state, '', propName, transitionCfg, animationDone);\n            }\n          }\n        } // No transition properties\n\n\n        if (animatingCount === 0) {\n          self.setState(target);\n          done && done();\n        }\n      } else {\n        self.setState(target);\n        done && done();\n      }\n    }\n\n    var subStates = self._subStates;\n\n    for (var i = 0; i < subStates.length; i++) {\n      subStates.transitionState(target);\n    }\n  },\n\n  /**\n   * Do transition animation of particular property\n   * @param {Object} state\n   * @param {string} subPropKey\n   * @param {string} key\n   * @param {Object} transitionCfg\n   * @param {Function} done\n   * @private\n   */\n  _animProp: function (state, subPropKey, key, transitionCfg, done) {\n    var el = this._el;\n    var stateObj = subPropKey ? state[subPropKey] : state;\n    var elObj = subPropKey ? el[subPropKey] : el;\n    var availableProp = stateObj && key in stateObj && elObj && key in elObj;\n    var transitionAnimators = this._transitionAnimators;\n\n    if (availableProp) {\n      var obj = {};\n\n      if (stateObj[key] === elObj[key]) {\n        return 0;\n      }\n\n      obj[key] = stateObj[key];\n      var animator = el.animate(subPropKey).when(transitionCfg.duration, obj).delay(transitionCfg.dealy).done(function () {\n        var idx = zrUtil.indexOf(transitionAnimators, 1);\n\n        if (idx > 0) {\n          transitionAnimators.splice(idx, 1);\n        }\n\n        done();\n      }).start(transitionCfg.easing);\n      transitionAnimators.push(animator);\n      return 1;\n    }\n\n    return 0;\n  },\n  _stopTransition: function () {\n    var transitionAnimators = this._transitionAnimators;\n\n    for (var i = 0; i < transitionAnimators.length; i++) {\n      transitionAnimators[i].stop();\n    }\n\n    transitionAnimators.length = 0;\n  },\n  transiting: function () {\n    return this._transitionAnimators.length > 0;\n  },\n  addSubStates: function (states) {\n    this._subStates.push(states);\n  },\n  removeSubStates: function (states) {\n    var idx = zrUtil.indexOf(this._subStates, states);\n\n    if (idx >= 0) {\n      this._subStates.splice(states, 1);\n    }\n  }\n};\nvar _default = GraphicStates;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/States.js\n// module id = 62\n// module chunks = 0","/**\r\n * 工具方法类\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var Point = require(\"./Point.js\");\r\n    var Line = require(\"./LineStruct.js\");\r\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    /**\r\n     * 构造类继承关系\r\n     *\r\n     * @param {Function} clazz 源类\r\n     * @param {Function} baseClazz 基类\r\n     */\r\n    function inherits(clazz, baseClazz) {\r\n        var clazzPrototype = clazz.prototype;\r\n\r\n        function F() {}\r\n        F.prototype = baseClazz.prototype;\r\n        clazz.prototype = new F();\r\n\r\n        for (var prop in clazzPrototype) {\r\n            clazz.prototype[prop] = clazzPrototype[prop];\r\n        }\r\n        clazz.prototype.constructor = clazz;\r\n        clazz.superClass = baseClazz;\r\n    }\r\n\r\n    function getUUID() {\r\n        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),\r\n            uuid = new Array(36),\r\n            rnd = 0,\r\n            r;\r\n        for (var i = 0; i < 36; i++) {\r\n            if (i == 8 || i == 13 || i == 18 || i == 23) {\r\n                uuid[i] = '-';\r\n            } else if (i == 14) {\r\n                uuid[i] = '4';\r\n            } else {\r\n                if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;\r\n                r = rnd & 0xf;\r\n                rnd = rnd >> 4;\r\n                uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\r\n            }\r\n        }\r\n        return \"sid-\" + uuid.join('');\r\n    }\r\n\r\n\r\n    /**\r\n     * 计算两点之间的距离\r\n     *@param {Point} p1 - first {Point}\r\n     *@param {Point} p2 - second {Point}\r\n     *@return {Number} - the distance between those 2 points. It is always positive.\r\n     **/\r\n    function distance(p1, p2) {\r\n        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\r\n    }\r\n\r\n    /**\r\n     * 返回一条折线 最长的两个点\r\n     * @param  {[type]} points [description]\r\n     * @return {[type]}        [description]\r\n     */\r\n    function getMaxLineLength(points) {\r\n        var m = distance(points[0], points[1]);\r\n        var result = [points[0], points[1]];\r\n        for (var i = 1; i < points.length - 1; i++) {\r\n\r\n            if (m < distance(points[i], points[i + 1])) {\r\n                m = distance(points[i], points[i + 1])\r\n                result = [points[i], points[i + 1]];\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**Returns the length of a Polyline that would be created with a set of points\r\n     *@param {Array} v - an {Array} of {Points}\r\n     *@return {Number} - a positive number equal with total length*/\r\n    function getPolylineLength(v) {\r\n        var l = 0;\r\n        for (var i = 0; i < v.length - 1; i++) {\r\n            l += distance(v[i], v[i + 1]);\r\n        }\r\n\r\n        return l;\r\n    }\r\n\r\n\r\n    /**Returns the max of a vector\r\n     *@param {Array} v - vector of {Number}s\r\n     *@return {Number} - the maximum number from the vector or NaN if vector is empty\r\n     **/\r\n    function max(v) {\r\n        if (v.lenght == 0) {\r\n            return NaN;\r\n        } else {\r\n            var m = v[0];\r\n            for (var i = 0; i < v.length; i++) {\r\n                if (m < v[i]) {\r\n                    m = v[i];\r\n                }\r\n            }\r\n\r\n            return m;\r\n        }\r\n    }\r\n\r\n\r\n    /**Returns the min of a vector\r\n     *@param {Array} v - vector of {Number}s\r\n     *@return {Number} - the minimum number from the vector or NaN if vector is empty\r\n     *@author alex@scriptoid.com\r\n     **/\r\n    function min(v) {\r\n        if (v.lenght == 0) {\r\n            return NaN;\r\n        } else {\r\n            var m = v[0];\r\n            for (var i = 0; i < v.length; i++) {\r\n                if (m > v[i]) {\r\n                    m = v[i];\r\n                }\r\n            }\r\n\r\n            return m;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 判断 点数组 是否正交直线路径\r\n     *Tests if a vector of points is an orthogonal path (moving in multiples of 90 degrees)\r\n     *@param {Array} v - an {Array} of {Point}s\r\n     *@return {Boolean} - true if path is valid, false otherwise\r\n     **/\r\n    function orthogonalPath(v) {\r\n        if (v.length <= 1) {\r\n            return true;\r\n        }\r\n\r\n        for (var i = 0; i < v.length - 1; i++) {\r\n            if (v[i].x != v[i + 1].x && v[i].y != v[i + 1].y) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     *Test to see if 2 {Line}s intersects. They are considered finite segments\r\n     *and not the infinite lines from geometry\r\n     *@param {Line} l1 - fist line/segment\r\n     *@param {Line} l2 - last line/segment\r\n     *@return {Boolean} true - if the lines intersect or false if not\r\n     **/\r\n    function lineIntersectsLine(l1, l2) {\r\n        // check for two vertical lines\r\n        if (l1.startPoint.x == l1.endPoint.x && l2.startPoint.x == l2.endPoint.x) {\r\n            return l1.startPoint.x == l2.startPoint.x ? // if 'infinite 'lines do coincide,\r\n                // then check segment bounds for overlapping\r\n                l1.contains(l2.startPoint.x, l2.startPoint.y) ||\r\n                l1.contains(l2.endPoint.x, l2.endPoint.y) :\r\n                // lines are paralel\r\n                false;\r\n        }\r\n        // if one line is vertical, and another line is not vertical\r\n        else if (l1.startPoint.x == l1.endPoint.x || l2.startPoint.x == l2.endPoint.x) {\r\n            // let assume l2 is vertical, otherwise exchange them\r\n            if (l1.startPoint.x == l1.endPoint.x) {\r\n                var l = l1;\r\n                l1 = l2;\r\n                l2 = l;\r\n            }\r\n            // finding intersection of 'infinite' lines\r\n            // equation of the first line is y = ax + b, second: x = c\r\n            var a = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);\r\n            var b = l1.startPoint.y - a * l1.startPoint.x;\r\n            var x0 = l2.startPoint.x;\r\n            var y0 = a * x0 + b;\r\n            return l1.contains(x0, y0) && l2.contains(x0, y0);\r\n        }\r\n\r\n        // check normal case - both lines are not vertical\r\n        else {\r\n            //line equation is : y = a*x + b, b = y - a * x\r\n            var a1 = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);\r\n            var b1 = l1.startPoint.y - a1 * l1.startPoint.x;\r\n\r\n            var a2 = (l2.endPoint.y - l2.startPoint.y) / (l2.endPoint.x - l2.startPoint.x);\r\n            var b2 = l2.startPoint.y - a2 * l2.startPoint.x;\r\n\r\n            if (a1 == a2) { //paralel lines\r\n                return b1 == b2 ?\r\n                    // for coincide lines, check for segment bounds overlapping\r\n                    l1.contains(l2.startPoint.x, l2.startPoint.y) || l1.contains(l2.endPoint.x, l2.endPoint.y) :\r\n                    // not coincide paralel lines have no chance to intersect\r\n                    false;\r\n            } else { //usual case - non paralel, the 'infinite' lines intersects...we only need to know if inside the segment\r\n\r\n                /*\r\n                 * if one of the lines are vertical, then x0 is equal to their x,\r\n                 * otherwise:\r\n                 * y1 = a1 * x + b1\r\n                 * y2 = a2 * x + b2\r\n                 * => x0 = (b2 - b1) / (a1 - a2)\r\n                 * => y0 = a1 * x0 + b1\r\n                 **/\r\n                x0 = (b2 - b1) / (a1 - a2);\r\n                y0 = a1 * x0 + b1;\r\n                return l1.contains(x0, y0) && l2.contains(x0, y0);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     *Tests if a a polyline defined by a set of points intersects a rectangle\r\n     *@param {Array} points - and {Array} of {Point}s\r\n     *@param {Array} bounds - the bounds of the rectangle defined by (x1, y1, x2, y2)\r\n     *@param {Boolean} closedPolyline - incase polyline is closed figure then true, else false\r\n     *\r\n     *@return true - if line intersects the rectangle, false - if not\r\n     **/\r\n    function polylineIntersectsRectangle(points, bounds, closedPolyline) {\r\n\r\n\r\n        //get the 4 lines/segments represented by the bounds\r\n        var lines = [];\r\n        lines.push(new Line(new Point(bounds[0], bounds[1]), new Point(bounds[2], bounds[1])));\r\n        lines.push(new Line(new Point(bounds[2], bounds[1]), new Point(bounds[2], bounds[3])));\r\n        lines.push(new Line(new Point(bounds[2], bounds[3]), new Point(bounds[0], bounds[3])));\r\n        lines.push(new Line(new Point(bounds[0], bounds[3]), new Point(bounds[0], bounds[1])));\r\n\r\n        for (var k = 0; k < points.length - 1; k++) {\r\n            //create a line out of each 2 consecutive points\r\n            var tempLine = new Line(points[k], points[k + 1]);\r\n\r\n            //see if that line intersect any of the line on bounds border\r\n            for (var i = 0; i < lines.length; i++) {\r\n                if (lineIntersectsLine(tempLine, lines[i])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        //check the closed figure - that is last point connected to the first\r\n        if (closedPolyline) {\r\n            //create a line out of each 2 consecutive points\r\n            var tempLine1 = new Line(points[points.length - 1], points[0]);\r\n\r\n            //see if that line intersect any of the line on bounds border\r\n            for (var j = 0; j < lines.length; j++) {\r\n                if (lineIntersectsLine(tempLine1, lines[j])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * 计算路径的分数\r\n     * Score a ortogonal path made out of Points\r\n     *Iterates over a set of points (minimum 3)\r\n     *For each 3 points (i, i+1, i+2) :\r\n     *  - if the 3rd one is after the 2nd on the same line we add +1\r\n     *  - if the 3rd is up or down related to the 2nd we do not do anything +0\r\n     *  - if the 3rd goes back we imediatelly return -1\r\n     *@param {Array} v - an array of {Point}s\r\n     *@return {Number} - -1 if the path is wrong (goes back) or something >= 0 if is fine\r\n     *  The bigger the number the smooth the path is\r\n     **/\r\n    function scorePath(v) {\r\n        if (v.length <= 2) {\r\n            return -1;\r\n        }\r\n\r\n        var score = 0;\r\n        for (var i = 1; i < v.length - 1; i++) {\r\n            if (v[i - 1].x == v[i].x && v[i].x == v[i + 1].x) { //on the same vertical\r\n                if (signum(v[i + 1].y - v[i].y) == signum(v[i].y - v[i - 1].y)) { //same direction\r\n                    score++;\r\n                } else { //going back - no good\r\n                    return -1;\r\n                }\r\n            } else if (v[i - 1].y == v[i].y && v[i].y == v[i + 1].y) { //on the same horizontal\r\n                if (signum(v[i + 1].x - v[i].x) == signum(v[i].x - v[i - 1].x)) { //same direction\r\n                    score++;\r\n                } else { //going back - no good\r\n                    return -1;\r\n                }\r\n            } else { //not on same vertical nor horizontal\r\n                score--;\r\n            }\r\n        }\r\n\r\n        return score;\r\n    }\r\n\r\n    /**\r\n     * 返回数字符号（+ -)\r\n     * Returns the sign of a number\r\n     *@param {Number} x - the number\r\n     *@returns {Number}\r\n     *@see <a href=\"http://en.wikipedia.org/wiki/Sign_function\">http://en.wikipedia.org/wiki/Sign_function</a>\r\n     **/\r\n    function signum(x) {\r\n        if (x > 0)\r\n            return 1;\r\n        else if (x < 0)\r\n            return -1;\r\n        else\r\n            return 0;\r\n    }\r\n\r\n    /**\r\n     * 判断 点数组 是不是有效路径（没有回路）\r\n     *Tests if a vector of points is a valid path (not going back)\r\n     *There are a few problems here. If you have p1, p2, p3 and p4 and p2 = p3 you need to ignore that\r\n     *@param {Array} v - an {Array} of {Point}s\r\n     *@return {Boolean} - true if path is valid, false otherwise\r\n     **/\r\n    function forwardPath(v) {\r\n        if (v.length <= 2) {\r\n            return true;\r\n        }\r\n\r\n        for (var i = 0; i < v.length - 2; i++) {\r\n            if (v[i].x == v[i + 1].x && v[i + 1].x == v[i + 2].x) { //on the same vertical\r\n                if (signum(v[i + 1].y - v[i].y) != 0) { //test only we have a progressing path\r\n                    if (signum(v[i + 1].y - v[i].y) == -1 * signum(v[i + 2].y - v[i + 1].y)) { //going back (ignore zero)\r\n                        return false;\r\n                    }\r\n                }\r\n            } else if (v[i].y == v[i + 1].y && v[i + 1].y == v[i + 2].y) { //on the same horizontal\r\n                if (signum(v[i + 1].x - v[i].x) != 0) { //test only we have a progressing path\r\n                    if (signum(v[i + 1].x - v[i].x) == -1 * signum(v[i + 2].x - v[i + 1].x)) { //going back (ignore zero)\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * 将[x:0,y:0]转化为[0, 0]  给zrender使用\r\n     * @param  {[type]} points [description]\r\n     * @param  {[type]} isRevert [description]\r\n     * @return {[type]}        [description]\r\n     */\r\n    function traslatePoints(points, isRevert) {\r\n        var newPoints = [];\r\n        if (isRevert) {\r\n            for (var i = 0; i < points.length; i++) {\r\n                var point = points[i];\r\n                newPoints.push(new Point(point[0], point[1]));\r\n            }\r\n            return newPoints;\r\n        } else {\r\n            for (var j = 0; j < points.length; j++) {\r\n                var point1 = points[j];\r\n                newPoints.push([point1.x, point1.y]);\r\n            }\r\n            return newPoints;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    function rotationMatrix(angle) {\r\n        var mReturn = [\r\n            [Math.cos(angle), -Math.sin(angle), 0],\r\n            [Math.sin(angle), Math.cos(angle), 0],\r\n            [0, 0, 1]\r\n        ];\r\n        return mReturn;\r\n    }\r\n\r\n    function translationMatrix(dx, dy) {\r\n        return [\r\n            [1, 0, dx],\r\n            [0, 1, dy],\r\n            [0, 0, 1]\r\n        ];\r\n    }\r\n\r\n    function scaleMatrix(sx, sy) {\r\n        if (sy == null) {\r\n            sy = sx;\r\n        }\r\n        return [\r\n            [sx, 0, 0],\r\n            [0, sy, 0],\r\n            [0, 0, 1]\r\n        ];\r\n    }\r\n\r\n    /** It will return the end point of a line on a given angle (clockwise).\r\n     * @param {Point} startPoint - the start of the line\r\n     * @param {Number} length - the length of the line\r\n     * @param {Number} angle - the angle of the line in radians\r\n     * @return {Point} - the endPoint of the line\r\n     */\r\n    function getEndPoint(startPoint, length, angle) {\r\n        var endPoint = startPoint.clone();\r\n        endPoint.transform(translationMatrix(-startPoint.x, -startPoint.y));\r\n        endPoint.y -= length;\r\n        endPoint.transform(rotationMatrix(angle));\r\n        endPoint.transform(translationMatrix(startPoint.x, startPoint.y));\r\n        return endPoint;\r\n    }\r\n\r\n    /**\r\n     * 获取获取两个图形的外面四个连接点\r\n     * @param  {[type]} node [description]\r\n     * @return {[type]}      [description]\r\n     */\r\n    function getConnectorPoints(node) {\r\n        return {\r\n            left: new Point(node.x, node.y + node.height / 2), //矩形 左中的位置\r\n            top: new Point(node.x + node.width / 2, node.y), //矩形 上中的位置\r\n            right: new Point(node.x + node.width, node.y + node.height / 2), //矩形 右中的位置\r\n            bottom: new Point(node.x + node.width / 2, node.y + node.height), //矩形 下中的位置\r\n            center: new Point(node.x + node.width / 2, node.y + node.height / 2) //中间位置\r\n\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 获取获取两个图形的外面四个连接点\r\n     * @param  {[type]} node [description]\r\n     * @return {[type]}      [description]\r\n     */\r\n    function getSoltPoints(node) {\r\n        return [\r\n            //top\r\n            [Math.round(node.getRect().width / 3 /10)*10, 0 ],\r\n            [Math.round(2*node.getRect().width / 3 /10)*10, 0 ],\r\n            //right\r\n            [node.getRect().width, Math.round(node.getRect().height / 3 /10)*10 ],\r\n            [node.getRect().width, Math.round(2*node.getRect().height / 3 /10)*10 ],\r\n            //bottom\r\n            [Math.round(node.getRect().width / 3 /10)*10, node.getRect().height ],\r\n            [Math.round(2*node.getRect().width / 3 /10)*10, node.getRect().height ],\r\n            //left\r\n            [0, Math.round(node.getRect().height / 3 /10)*10 ],\r\n            [0, Math.round(2*node.getRect().height / 3 /10)*10 ]\r\n\r\n        ]\r\n    }\r\n\r\n    /**\r\n     * 计算 p1 p2两点所连接的直线的角度\r\n     * @param  {[type]} p1 [description]\r\n     * @param  {[type]} p2 [description]\r\n     * @return {[type]}    [description]\r\n     */\r\n    function tangentRotation(p1, p2) {\r\n        return -Math.PI / 2 - Math.atan2(\r\n            p2.y - p1.y, p2.x - p1.x\r\n        );\r\n    }\r\n\r\n    /**\r\n     * 判断3点是否在一条直线上\r\n     * Tests if 3 points are coliniar with matrix determinants.\r\n     * If the determinat of matrix\r\n     * /         \\\r\n     * | x1 y1 1 |\r\n     * | x2 y2 1 |\r\n     * | x3 y3 1 |\r\n     * \\         /\r\n     * is zero it means that the points are colinear\r\n     *@param {Point} p1 - first point\r\n     *@param {Point} p2 - second point\r\n     *@param {Point} p3 - third point\r\n     * @param {Number} precission\r\n     *@return {Boolean} - true if coliniar and false if not\r\n     *@author Alex\r\n     *@see http://en.wikipedia.org/wiki/Determinant\r\n     *@see https://people.richland.edu/james/lecture/m116/matrices/applications.html\r\n     **/\r\n    function collinearity(p1, p2, p3, precission) {\r\n        var determinant = (p1.x * p2.y + p1.y * p3.x + p2.x * p3.y) - (p2.y * p3.x + p1.y * p2.x + p1.x * p3.y);\r\n\r\n        if (precission) {\r\n            return Math.abs(determinant) <= precission;\r\n        } else {\r\n            return determinant === 0;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 四舍五入 保存decimals的小数\r\n     **/\r\n    function enhancedRound(number, decimals) {\r\n        return Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);\r\n    }\r\n\r\n    /**\r\n     * 获取两点之间的长度\r\n     **/\r\n    function getLength(startPoint, endPoint) {\r\n        return Math.sqrt(Math.pow(startPoint.x - endPoint.x, 2) + Math.pow(startPoint.y - endPoint.y, 2));\r\n    }\r\n\r\n    /**\r\n     * 获取角度\r\n     * @param  {[type]} centerPoint  [description]\r\n     * @param  {[type]} outsidePoint [description]\r\n     * @param  {[type]} round        [description]\r\n     * @return {[type]}              [description]\r\n     */\r\n    function getAngle(centerPoint, outsidePoint, round) {\r\n        centerPoint.x = enhancedRound(centerPoint.x, 5);\r\n        centerPoint.y = enhancedRound(centerPoint.y, 5);\r\n        outsidePoint.x = enhancedRound(outsidePoint.x, 5);\r\n        outsidePoint.y = enhancedRound(outsidePoint.y, 5);\r\n        var angle = Math.atan((outsidePoint.x - centerPoint.x) / (outsidePoint.y - centerPoint.y));\r\n        angle = -angle;\r\n\r\n        //endAngle+=90;\r\n        if (outsidePoint.x >= centerPoint.x && outsidePoint.y >= centerPoint.y) {\r\n            angle += Math.PI;\r\n        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y >= centerPoint.y) {\r\n            angle += Math.PI;\r\n        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y <= centerPoint.y) {\r\n            angle += Math.PI * 2;\r\n        }\r\n        while (angle >= Math.PI * 2) {\r\n            angle -= Math.PI * 2;\r\n        }\r\n        if (isNaN(angle)) { //Nan\r\n            angle = 0; //we are at center point;\r\n        }\r\n        if (round) {\r\n            angle = Math.round(angle / round) * round\r\n        }\r\n        return angle;\r\n    }\r\n\r\n    function getRect(node, isCalcParent) {\r\n        var boundingRect = node.getBoundingRect();\r\n        //创建最小包围盒虚线\r\n        var points = [];\r\n        points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n        points[1] = [boundingRect.width / 2, -boundingRect.height / 2];\r\n        points[2] = [boundingRect.width / 2, boundingRect.height / 2];\r\n        points[3] = [-boundingRect.width / 2, boundingRect.height / 2];\r\n        points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n\r\n        var positionX = node.position[0];\r\n        var positionY = node.position[1];\r\n        //这里要循环判断一把 有没有父节点 并且父节点不是根节点 然后进行相加\r\n        if (node.parent && node.parent.type === \"GroupNode\" && isCalcParent) {\r\n            positionX = positionX + node.parent.position[0];\r\n            positionY = positionY + node.parent.position[1];\r\n        }\r\n\r\n        var boundRect = new BoundingRect(\r\n                Number(positionX + boundingRect.x),   //注: 因事件为圆形  所以 x y 为圆心的位置  包围矩形要减去宽度一半\r\n                Number(positionY + boundingRect.y),\r\n                Number(boundingRect.width),\r\n                Number(boundingRect.height)\r\n            );\r\n        //中心点\r\n        var cx = Number(positionX) + Number(boundingRect.width) / 2 + Number(boundingRect.x);\r\n        var cy = Number(positionY) + Number(boundingRect.height) / 2 + Number(boundingRect.y);\r\n        return {\r\n            x: Number(cx),\r\n            y: Number(cy),\r\n            width: Number(boundingRect.width),\r\n            height: Number(boundingRect.height),\r\n            points: points,\r\n            boundingRect: boundRect\r\n        };\r\n    }\r\n\r\n    var StackedMap = {\r\n        createNew: function() {\r\n            var stack = [];\r\n\r\n            return {\r\n                add: function(key, value) {\r\n                    var arrKey = this.get(key);\r\n                    arrKey.push(value)\r\n\r\n                },\r\n                get: function(key) {\r\n                    for (var i = 0; i < stack.length; i++) {\r\n                        if (key == stack[i].key) {\r\n                            return stack[i].value;\r\n                        }\r\n                    }\r\n                    //如果没有找到的话，则创建一个新的数组\r\n                    var value = [];\r\n                    stack.push({ key: key, value: value });\r\n                    return value;\r\n                },\r\n                keys: function() {\r\n                    var keys = [];\r\n                    for (var i = 0; i < stack.length; i++) {\r\n                        keys.push(stack[i].key);\r\n                    }\r\n                    return keys;\r\n                },\r\n                top: function() {\r\n                    return stack[stack.length - 1];\r\n                },\r\n                remove: function(key) {\r\n                    var idx = -1;\r\n                    for (var i = 0; i < stack.length; i++) {\r\n                        if (key == stack[i].key) {\r\n                            idx = i;\r\n                            break;\r\n                        }\r\n                    }\r\n                    return stack.splice(idx, 1)[0];\r\n                },\r\n                removeItem: function(key, item) {\r\n                    var arrKey = this.get(key);\r\n                    var index = zrUtil.indexOf(arrKey, item);\r\n                    arrKey.splice(index, 1);\r\n\r\n                },\r\n                removeTop: function() {\r\n                    return stack.splice(stack.length - 1, 1)[0];\r\n                },\r\n                length: function() {\r\n                    return stack.length;\r\n                },\r\n                clear: function() {\r\n                    stack.splice(0, stack.length);\r\n                }\r\n            };\r\n        }\r\n    };\r\n\r\n    function randomColor() {\r\n        var arrHex = [\"0\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\"],\r\n            strHex = \"#\",\r\n            index;\r\n        for (var i = 0; i < 6; i++) {\r\n            index = Math.round(Math.random() * 15);\r\n            strHex += arrHex[index];\r\n        }\r\n        return strHex;\r\n    }\r\n\r\n    function isUndefined(obj) {\r\n        return obj === void 0;\r\n    }\r\n\r\n    function collinearReduction (v) {\r\n        var r = [];\r\n\r\n        if(v.length < 3){\r\n            return Point.cloneArray(v);\r\n        }\r\n\r\n        r.push( v[0].clone() );\r\n        for(var i=1; i < v.length-1; i++){\r\n            if( (v[i-1].x == v[i].x && v[i].x == v[i+1].x)  ||  (v[i-1].y == v[i].y && v[i].y == v[i+1].y) )\r\n            {\r\n                continue;\r\n            }\r\n            else{\r\n                r.push( v[i].clone() );\r\n            }\r\n        }\r\n        r.push( v[v.length-1].clone() );\r\n\r\n        return r;\r\n    }\r\n\r\n    // By default, Underscore uses ERB-style template delimiters, change the\r\n    // following template settings to use alternative delimiters.\r\n    var templateSettings = {\r\n        evaluate: /<%([\\s\\S]+?)%>/g,\r\n        interpolate: /<%=([\\s\\S]+?)%>/g,\r\n        escape: /<%-([\\s\\S]+?)%>/g\r\n    };\r\n\r\n    // When customizing `templateSettings`, if you don't want to define an\r\n    // interpolation, evaluation or escaping regex, we need one that is\r\n    // guaranteed not to match.\r\n    var noMatch = /(.)^/;\r\n\r\n    // Certain characters need to be escaped so that they can be put into a\r\n    // string literal.\r\n    var escapes = {\r\n        \"'\": \"'\",\r\n        '\\\\': '\\\\',\r\n        '\\r': 'r',\r\n        '\\n': 'n',\r\n        '\\u2028': 'u2028',\r\n        '\\u2029': 'u2029'\r\n    };\r\n\r\n    var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\r\n\r\n    var escapeChar = function(match) {\r\n        return '\\\\' + escapes[match];\r\n    };\r\n\r\n    // JavaScript micro-templating, similar to John Resig's implementation.\r\n    // Underscore templating handles arbitrary delimiters, preserves whitespace,\r\n    // and correctly escapes quotes within interpolated code.\r\n    // NB: `oldSettings` only exists for backwards compatibility.\r\n    function template(text, settings, oldSettings) {\r\n        if (!settings && oldSettings) settings = oldSettings;\r\n        settings = settings || {};\r\n        settings = zrUtil.defaults(settings, templateSettings, true);\r\n\r\n        // Combine delimiters into one regular expression via alternation.\r\n        var matcher = RegExp([\r\n            (settings.escape || noMatch).source,\r\n            (settings.interpolate || noMatch).source,\r\n            (settings.evaluate || noMatch).source\r\n        ].join('|') + '|$', 'g');\r\n\r\n        // Compile the template source, escaping string literals appropriately.\r\n        var index = 0;\r\n        var source = \"__p+='\";\r\n        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\r\n            source += text.slice(index, offset).replace(escaper, escapeChar);\r\n            index = offset + match.length;\r\n\r\n            if (escape) {\r\n                source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\r\n            } else if (interpolate) {\r\n                source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\r\n            } else if (evaluate) {\r\n                source += \"';\\n\" + evaluate + \"\\n__p+='\";\r\n            }\r\n\r\n            // Adobe VMs need the match returned to produce the correct offest.\r\n            return match;\r\n        });\r\n        source += \"';\\n\";\r\n\r\n        // If a variable is not specified, place data values in local scope.\r\n        if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\r\n\r\n        source = \"var __t,__p='',__j=Array.prototype.join,\" +\r\n            \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\r\n            source + 'return __p;\\n';\r\n\r\n        try {\r\n            var render = new Function(settings.variable || 'obj', source);\r\n        } catch (e) {\r\n            e.source = source;\r\n            throw e;\r\n        }\r\n\r\n        var template = function(data) {\r\n            return render.call(this, data);\r\n        };\r\n\r\n        // Provide the compiled source as a convenience for precompilation.\r\n        var argument = settings.variable || 'obj';\r\n        template.source = 'function(' + argument + '){\\n' + source + '}';\r\n\r\n        return template;\r\n    }\r\n\r\n    function isEmpty(obj) {\r\n        if (obj == null) return true;\r\n        if (zrUtil.isArrayLike(obj) && (zrUtil.isArray(obj) || zrUtil.isString(obj))) return obj.length === 0;\r\n    }\r\n    function mergeOpt(target, source, overwrite, exclude) {\r\n        // We should escapse that source is string\r\n        // and enter for ... in ...\r\n        if (!zrUtil.isObject(source) || !zrUtil.isObject(target)) {\r\n          return overwrite ? zrUtil.clone(source) : target;\r\n        }\r\n      \r\n        for (var key in source) {\r\n          if (source.hasOwnProperty(key)) {\r\n            var targetProp = target[key];\r\n            var sourceProp = source[key];\r\n      \r\n            if (zrUtil.isObject(sourceProp) && zrUtil.isObject(targetProp) && !zrUtil.isArray(sourceProp) && !zrUtil.isArray(targetProp) && !zrUtil.isDom(sourceProp) && !zrUtil.isDom(targetProp) && !zrUtil.isBuiltInObject(sourceProp) && !zrUtil.isBuiltInObject(targetProp) && !zrUtil.isPrimitive(sourceProp) && !zrUtil.isPrimitive(targetProp)) {\r\n              // 如果需要递归覆盖，就递归调用merge\r\n              mergeOpt(targetProp, sourceProp, overwrite, exclude);\r\n            } else if (overwrite || !(key in target)) {\r\n              // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\r\n              // NOTE，在 target[key] 不存在的时候也是直接覆盖\r\n                if (key !== exclude) {\r\n                    target[key] = zrUtil.clone(source[key], true);\r\n                }\r\n            }\r\n          }\r\n        }\r\n        return target;\r\n    }\r\n    function Class() {}\r\n    Class.extend = function(proto) {\r\n        var base = function() {},\r\n            member,\r\n            that = this,\r\n            subclass = proto && proto.init ? proto.init : function () {\r\n                that.apply(this, arguments);\r\n            },\r\n            fn;\r\n\r\n        base.prototype = that.prototype;\r\n        fn = subclass.fn = subclass.prototype = new base();\r\n\r\n        for (member in proto) {\r\n            if (proto[member] != null && proto[member].constructor === Object) {\r\n                // Merge object members\r\n                fn[member] = zrUtil.mergeAll([{}, base.prototype[member], proto[member]],true);\r\n            } else {\r\n                fn[member] = proto[member];\r\n            }\r\n        }\r\n\r\n        fn.constructor = subclass;\r\n        subclass.extend = that.extend;\r\n\r\n        return subclass;\r\n    };\r\n\r\n    module.exports = {\r\n        inherits: inherits,\r\n        getUUID: getUUID,\r\n        distance: distance,\r\n        getPolylineLength: getPolylineLength,\r\n        max: max,\r\n        min: min,\r\n        isEmpty: isEmpty,\r\n        mergeOpt: mergeOpt,\r\n        orthogonalPath: orthogonalPath,\r\n        polylineIntersectsRectangle: polylineIntersectsRectangle,\r\n        scorePath: scorePath,\r\n        forwardPath: forwardPath,\r\n        traslatePoints: traslatePoints,\r\n        getEndPoint: getEndPoint,\r\n        getConnectorPoints: getConnectorPoints,\r\n        tangentRotation: tangentRotation,\r\n        collinearity: collinearity,\r\n        translationMatrix: translationMatrix,\r\n        scaleMatrix: scaleMatrix,\r\n        round: enhancedRound,\r\n        getLength: getLength,\r\n        getAngle: getAngle,\r\n        getRect: getRect,\r\n        StackedMap: StackedMap,\r\n        getMaxLineLength: getMaxLineLength,\r\n        randomColor: randomColor,\r\n        template: template,\r\n        isUndefined: isUndefined,\r\n        getSoltPoints:getSoltPoints,\r\n        collinearReduction: collinearReduction,\r\n        Class:Class\r\n    };\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/util.js\n// module id = 63\n// module chunks = 0","\r\n\r\n    /**\r\n      * Creates an instance of Point\r\n      *\r\n      *\r\n      * @constructor\r\n      * @this {Point}\r\n      * @param {Number} x The x coordinate of point.\r\n      * @param {Number} y The y coordinate of point.\r\n      * Note: Even if it is named Point this class should be named Dot as Dot is closer\r\n      * then Point from math perspective.\r\n      **/\r\n    function Point(x, y){\r\n        /**The x coordinate of point*/\r\n        this.x = x;\r\n\r\n        /**The y coordinate of point*/\r\n        this.y = y;\r\n\r\n\r\n    }\r\n\r\n    /**Creates a {Point} out of JSON parsed object\r\n     *@param {JSONObject} o - the JSON parsed object\r\n     *@return {Point} a newly constructed Point\r\n     **/\r\n    Point.load = function(o){\r\n        var newPoint = new Point(Number(o.x), Number(o.y));\r\n        return newPoint;\r\n    };\r\n\r\n\r\n    /**Creates an array of points from an array of {JSONObject}s\r\n     *@param {Array} v - the array of JSONObjects\r\n     *@return an {Array} of {Point}s\r\n     **/\r\n    Point.loadArray = function(v){\r\n        var newPoints = [];\r\n        for(var i=0; i< v.length; i++){\r\n            newPoints.push(Point.load(v[i]));\r\n        }\r\n        return newPoints;\r\n    };\r\n\r\n\r\n    /**Clones an array of points\r\n     *@param {Array} v - the array of {Point}s\r\n     *@return an {Array} of {Point}s\r\n     **/\r\n    Point.cloneArray = function(v){\r\n        var newPoints = [];\r\n        for(var i=0; i< v.length; i++){\r\n            newPoints.push(v[i].clone());\r\n        }\r\n        return newPoints;\r\n    };\r\n\r\n    Point.prototype = {\r\n        constructor : Point,\r\n\r\n        transform:function(matrix){\r\n            var oldX = this.x;\r\n            var oldY = this.y;\r\n            this.x = matrix[0][0] * oldX + matrix[0][1] * oldY + matrix[0][2];\r\n            this.y = matrix[1][0] * oldX + matrix[1][1] * oldY + matrix[1][2];\r\n        },\r\n\r\n        /**Tests if this point is similar to other point\r\n         *@param {Point} anotherPoint - the other point\r\n         **/\r\n        equals:function(anotherPoint){\r\n            if(! (anotherPoint instanceof Point) ){\r\n                return false;\r\n            }\r\n            return (this.x == anotherPoint.x)\r\n            && (this.y == anotherPoint.y)\r\n        },\r\n\r\n        /**Clone current Point\r\n         **/\r\n        clone: function(){\r\n            var newPoint = new Point(this.x, this.y);\r\n            return newPoint;\r\n        },\r\n\r\n        add: function(point) {\r\n            this.x = this.x + point.x;\r\n            this.y = this.y + point.y;\r\n            return this;\r\n        },\r\n\r\n        /**Tests to see if a point (x, y) is within a range of current Point\r\n         *@param {Numeric} x - the x coordinate of tested point\r\n         *@param {Numeric} y - the x coordinate of tested point\r\n         *@param {Numeric} radius - the radius of the vicinity\r\n         **/\r\n        near:function(x, y, radius){\r\n            var distance = Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));\r\n\r\n            return (distance <= radius);\r\n        },\r\n\r\n        contains: function(x,y){\r\n            return this.x == x && this.y == y;\r\n        },\r\n\r\n        toString:function(){\r\n            return '[' + this.x + ',' + this.y + ']';\r\n        },\r\n\r\n        getPoints:function(){\r\n            return [this];\r\n        }\r\n    };\r\n    module.exports = Point;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/Point.js\n// module id = 64\n// module chunks = 0","\r\n\r\n    /**\r\n      * Creates an instance of a Line. A Line is actually a segment and not a pure\r\n      * geometrical Line\r\n      *\r\n      * @constructor\r\n      * @this {Line}\r\n      * @param {Point} startPoint - starting point of the line\r\n      * @param {Point} endPoint - the ending point of the line\r\n      **/\r\n    function Line(startPoint, endPoint){\r\n        /**Starting {@link Point} of the line*/\r\n        this.startPoint = startPoint;\r\n\r\n        /**Ending {@link Point} of the line*/\r\n        this.endPoint = endPoint;\r\n\r\n        /**Serialization type*/\r\n        this.oType = 'Line'; //object type used for JSON deserialization\r\n    }\r\n\r\n    /**Creates a {Line} out of JSON parsed object\r\n     *@param {JSONObject} o - the JSON parsed object\r\n     *@return {Line} a newly constructed Line\r\n     **/\r\n    Line.load = function(o){\r\n        var newLine = new Line(\r\n            Point.load(o.startPoint),\r\n            Point.load(o.endPoint)\r\n        );\r\n\r\n        return newLine;\r\n    };\r\n\r\n    Line.prototype = {\r\n        contructor: Line,\r\n\r\n\r\n\r\n        clone:function(){\r\n            var ret = new Line(this.startPoint.clone(), this.endPoint.clone());\r\n            return ret;\r\n        },\r\n\r\n        equals:function(anotherLine){\r\n            if(!anotherLine instanceof Line){\r\n                return false;\r\n            }\r\n            return this.startPoint.equals(anotherLine.startPoint)\r\n            && this.endPoint.equals(anotherLine.endPoint)\r\n        },\r\n\r\n        /** Tests to see if a point belongs to this line (not as infinite line but more like a segment)\r\n         * Algorithm: Compute line's equation and see if (x, y) verifies it.\r\n         * @param {Number} x - the X coordinates\r\n         * @param {Number} y - the Y coordinates\r\n         **/\r\n        contains: function(x, y){\r\n            // if the point is inside rectangle bounds of the segment\r\n            if (Math.min(this.startPoint.x, this.endPoint.x) <= x\r\n                && x <= Math.max(this.startPoint.x, this.endPoint.x)\r\n                && Math.min(this.startPoint.y, this.endPoint.y) <= y\r\n                && y <= Math.max(this.startPoint.y, this.endPoint.y)) {\r\n\r\n                // check for vertical line\r\n                if (this.startPoint.x == this.endPoint.x) {\r\n                    return x == this.startPoint.x;\r\n                } else { // usual (not vertical) line can be represented as y = a * x + b\r\n                    var a = (this.endPoint.y - this.startPoint.y) / (this.endPoint.x - this.startPoint.x);\r\n                    var b = this.startPoint.y - a * this.startPoint.x;\r\n                    return y == a * x + b;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        },\r\n\r\n        /*\r\n         *See if we are near a {Line} by a certain radius (also includes the extremities into computation)\r\n         *@param {Number} x - the x coordinates\r\n         *@param {Number} y - the y coordinates\r\n         *@param {Number} radius - the radius to search for\r\n         *@see http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n         *@see \"Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227\"\r\n         **/\r\n        near:function(x,y,radius){\r\n\r\n            if(this.endPoint.x === this.startPoint.x){ //Vertical line, so the vicinity area is a rectangle\r\n                return ( (this.startPoint.y-radius<=y && this.endPoint.y+radius>=y)\r\n                        || (this.endPoint.y-radius<=y && this.startPoint.y+radius>=y))\r\n                && x > this.startPoint.x - radius && x < this.startPoint.x + radius ;\r\n            }\r\n\r\n            if(this.startPoint.y === this.endPoint.y){ //Horizontal line, so the vicinity area is a rectangle\r\n                return ( (this.startPoint.x - radius<=x && this.endPoint.x+radius>=x)\r\n                        || (this.endPoint.x-radius<=x && this.startPoint.x+radius>=x))\r\n                        && y>this.startPoint.y-radius && y<this.startPoint.y+radius ;\r\n            }\r\n\r\n\r\n            var startX = Math.min(this.endPoint.x,this.startPoint.x);\r\n            var startY = Math.min(this.endPoint.y,this.startPoint.y);\r\n            var endX = Math.max(this.endPoint.x,this.startPoint.x);\r\n            var endY = Math.max(this.endPoint.y,this.startPoint.y);\r\n\r\n            /*We will compute the distance from point to the line\r\n             * by using the algorithm from\r\n             * http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n             * */\r\n\r\n            //First we need to find a,b,c of the line equation ax + by + c = 0\r\n            var a = this.endPoint.y - this.startPoint.y;\r\n            var b = this.startPoint.x - this.endPoint.x;\r\n            var c = -(this.startPoint.x * this.endPoint.y - this.endPoint.x * this.startPoint.y);\r\n\r\n            //Secondly we get the distance \"Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227\"\r\n            var d = Math.abs( (a*x + b*y + c) / Math.sqrt(Math.pow(a,2) + Math.pow(b,2)) );\r\n\r\n            //Thirdly we get coordinates of closest line's point to target point\r\n            //http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Cartesian_coordinates\r\n            var closestX = (b * (b*x - a*y) - a*c) / ( Math.pow(a,2) + Math.pow(b,2) );\r\n            var closestY = (a * (-b*x + a*y) - b*c) / ( Math.pow(a,2) + Math.pow(b,2) );\r\n\r\n            var r = ( d <= radius && endX>=closestX && closestX>=startX && endY>=closestY && closestY>=startY ) //the projection of the point falls INSIDE of the segment\r\n                || this.startPoint.near(x,y,radius) || this.endPoint.near(x,y,radius); //the projection of the point falls OUTSIDE of the segment\r\n\r\n            return  r;\r\n\r\n        },\r\n\r\n        /**we need to create a new array each time, or we will affect the actual shape*/\r\n        getPoints:function(){\r\n            var points = [];\r\n            points.push(this.startPoint);\r\n            points.push(this.endPoint);\r\n            return points;\r\n        },\r\n\r\n        /**Return the {Point} corresponding the t certain t value\r\n         * @param {Number} t the value of parameter t, where t in [0,1], t is like a percent*/\r\n        getPoint: function(t){\r\n            var Xp = t * (this.endPoint.x - this.startPoint.x) + this.startPoint.x;\r\n            var Yp = t * (this.endPoint.y - this.startPoint.y) + this.startPoint.y;\r\n\r\n            return new Point(Xp, Yp);\r\n        },\r\n\r\n        // /**\r\n        //  * Returns the middle of the line\r\n        //  * @return {Point} the middle point\r\n        //  * */\r\n        // getMiddle : function(){\r\n        //     return Util.getMiddle(this.startPoint, this.endPoint);\r\n        // },\r\n\r\n\r\n        // getLength : function(){\r\n        //     return Util.getLength(this.startPoint, this.endPoint);\r\n        // },\r\n\r\n        // /**\r\n        //  *Get bounds for this line\r\n        //  *@author Alex Gheorghiu <alex@scriptoid.com>\r\n        //  **/\r\n        // getBounds:function(){\r\n        //     return Util.getBounds(this.getPoints());\r\n        // },\r\n\r\n        /**String representation*/\r\n        toString:function(){\r\n            return 'line(' + this.startPoint + ',' + this.endPoint + ')';\r\n        }\r\n    };\r\n    module.exports = Line;\r\n\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/LineStruct.js\n// module id = 65\n// module chunks = 0","'use strict';\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    var apiList = [\r\n        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction',\r\n        'on', 'off', 'trigger', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption'\r\n    ];\r\n\r\n    function ExtensionAPI(instance) {\r\n        zrUtil.each(apiList, function (name) {\r\n            this[name] = zrUtil.bind(instance[name], instance);\r\n        }, this);\r\n    }\r\n\r\n    module.exports = ExtensionAPI;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-link/lib/ExtensionApi.js\n// module id = 66\n// module chunks = 0","var guid = require(\"./core/guid\");\n\nvar env = require(\"./core/env\");\n\nvar zrUtil = require(\"./core/util\");\n\nvar Handler = require(\"./Handler\");\n\nvar Storage = require(\"./Storage\");\n\nvar Painter = require(\"./Painter\");\n\nvar Animation = require(\"./animation/Animation\");\n\nvar HandlerProxy = require(\"./dom/HandlerProxy\");\n\n/*!\n* ZRender, a high performance 2d drawing library.\n*\n* Copyright (c) 2013, Baidu Inc.\n* All rights reserved.\n*\n* LICENSE\n* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n*/\nvar useVML = !env.canvasSupported;\nvar painterCtors = {\n  canvas: Painter\n};\nvar instances = {}; // ZRender实例map索引\n\n/**\n * @type {string}\n */\n\nvar version = '3.7.4';\n/**\n * Initializing a zrender instance\n * @param {HTMLElement} dom\n * @param {Object} opts\n * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n * @param {number} [opts.devicePixelRatio]\n * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n * @return {module:zrender/ZRender}\n */\n\nfunction init(dom, opts) {\n  var zr = new ZRender(guid(), dom, opts);\n  instances[zr.id] = zr;\n  return zr;\n}\n/**\n * Dispose zrender instance\n * @param {module:zrender/ZRender} zr\n */\n\n\nfunction dispose(zr) {\n  if (zr) {\n    zr.dispose();\n  } else {\n    for (var key in instances) {\n      if (instances.hasOwnProperty(key)) {\n        instances[key].dispose();\n      }\n    }\n\n    instances = {};\n  }\n\n  return this;\n}\n/**\n * Get zrender instance by id\n * @param {string} id zrender instance id\n * @return {module:zrender/ZRender}\n */\n\n\nfunction getInstance(id) {\n  return instances[id];\n}\n\nfunction registerPainter(name, Ctor) {\n  painterCtors[name] = Ctor;\n}\n\nfunction delInstance(id) {\n  delete instances[id];\n}\n/**\n * @module zrender/ZRender\n */\n\n/**\n * @constructor\n * @alias module:zrender/ZRender\n * @param {string} id\n * @param {HTMLElement} dom\n * @param {Object} opts\n * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n * @param {number} [opts.devicePixelRatio]\n * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n */\n\n\nvar ZRender = function (id, dom, opts) {\n  opts = opts || {};\n  /**\n   * @type {HTMLDomElement}\n   */\n\n  this.dom = dom;\n  /**\n   * @type {string}\n   */\n\n  this.id = id;\n  var self = this;\n  var storage = new Storage();\n  var rendererType = opts.renderer; // TODO WebGL\n\n  if (useVML) {\n    if (!painterCtors.vml) {\n      throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n    }\n\n    rendererType = 'vml';\n  } else if (!rendererType || !painterCtors[rendererType]) {\n    rendererType = 'canvas';\n  }\n\n  var painter = new painterCtors[rendererType](dom, storage, opts);\n  this.storage = storage;\n  this.painter = painter;\n  var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n  this.handler = new Handler(storage, painter, handerProxy, painter.root);\n  /**\n   * @type {module:zrender/animation/Animation}\n   */\n\n  this.animation = new Animation({\n    stage: {\n      update: zrUtil.bind(this.flush, this)\n    }\n  });\n  this.animation.start();\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._needsRefresh; // 修改 storage.delFromStorage, 每次删除元素之前删除动画\n  // FIXME 有点ugly\n\n  var oldDelFromStorage = storage.delFromStorage;\n  var oldAddToStorage = storage.addToStorage;\n\n  storage.delFromStorage = function (el) {\n    oldDelFromStorage.call(storage, el);\n    el && el.removeSelfFromZr(self);\n  };\n\n  storage.addToStorage = function (el) {\n    oldAddToStorage.call(storage, el);\n    el.addSelfToZr(self);\n  };\n};\n\nZRender.prototype = {\n  constructor: ZRender,\n\n  /**\n   * 获取实例唯一标识\n   * @return {string}\n   */\n  getId: function () {\n    return this.id;\n  },\n\n  /**\n   * 添加元素\n   * @param  {module:zrender/Element} el\n   */\n  add: function (el) {\n    this.storage.addRoot(el);\n    this._needsRefresh = true;\n  },\n\n  /**\n   * 删除元素\n   * @param  {module:zrender/Element} el\n   */\n  remove: function (el) {\n    this.storage.delRoot(el);\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Change configuration of layer\n   * @param {string} zLevel\n   * @param {Object} config\n   * @param {string} [config.clearColor=0] Clear color\n   * @param {string} [config.motionBlur=false] If enable motion blur\n   * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n  */\n  configLayer: function (zLevel, config) {\n    this.painter.configLayer(zLevel, config);\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Repaint the canvas immediately\n   */\n  refreshImmediately: function () {\n    // var start = new Date();\n    // Clear needsRefresh ahead to avoid something wrong happens in refresh\n    // Or it will cause zrender refreshes again and again.\n    this._needsRefresh = false;\n    this.painter.refresh();\n    /**\n     * Avoid trigger zr.refresh in Element#beforeUpdate hook\n     */\n\n    this._needsRefresh = false; // var end = new Date();\n    // var log = document.getElementById('log');\n    // if (log) {\n    //     log.innerHTML = log.innerHTML + '<br>' + (end - start);\n    // }\n  },\n\n  /**\n   * Mark and repaint the canvas in the next frame of browser\n   */\n  refresh: function () {\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Perform all refresh\n   */\n  flush: function () {\n    if (this._needsRefresh) {\n      this.refreshImmediately();\n    }\n\n    if (this._needsRefreshHover) {\n      this.refreshHoverImmediately();\n    }\n  },\n\n  /**\n   * Add element to hover layer\n   * @param  {module:zrender/Element} el\n   * @param {Object} style\n   */\n  addHover: function (el, style) {\n    if (this.painter.addHover) {\n      this.painter.addHover(el, style);\n      this.refreshHover();\n    }\n  },\n\n  /**\n   * Add element from hover layer\n   * @param  {module:zrender/Element} el\n   */\n  removeHover: function (el) {\n    if (this.painter.removeHover) {\n      this.painter.removeHover(el);\n      this.refreshHover();\n    }\n  },\n\n  /**\n   * Clear all hover elements in hover layer\n   * @param  {module:zrender/Element} el\n   */\n  clearHover: function () {\n    if (this.painter.clearHover) {\n      this.painter.clearHover();\n      this.refreshHover();\n    }\n  },\n\n  /**\n   * Refresh hover in next frame\n   */\n  refreshHover: function () {\n    this._needsRefreshHover = true;\n  },\n\n  /**\n   * Refresh hover immediately\n   */\n  refreshHoverImmediately: function () {\n    this._needsRefreshHover = false;\n    this.painter.refreshHover && this.painter.refreshHover();\n  },\n\n  /**\n   * Resize the canvas.\n   * Should be invoked when container size is changed\n   * @param {Object} [opts]\n   * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n   * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n   */\n  resize: function (opts) {\n    opts = opts || {};\n    this.painter.resize(opts.width, opts.height);\n    this.handler.resize();\n  },\n\n  /**\n   * Stop and clear all animation immediately\n   */\n  clearAnimation: function () {\n    this.animation.clear();\n  },\n\n  /**\n   * Get container width\n   */\n  getWidth: function () {\n    return this.painter.getWidth();\n  },\n\n  /**\n   * Get container height\n   */\n  getHeight: function () {\n    return this.painter.getHeight();\n  },\n\n  /**\n   * Export the canvas as Base64 URL\n   * @param {string} type\n   * @param {string} [backgroundColor='#fff']\n   * @return {string} Base64 URL\n   */\n  // toDataURL: function(type, backgroundColor) {\n  //     return this.painter.getRenderedCanvas({\n  //         backgroundColor: backgroundColor\n  //     }).toDataURL(type);\n  // },\n\n  /**\n   * Converting a path to image.\n   * It has much better performance of drawing image rather than drawing a vector path.\n   * @param {module:zrender/graphic/Path} e\n   * @param {number} width\n   * @param {number} height\n   */\n  pathToImage: function (e, dpr) {\n    return this.painter.pathToImage(e, dpr);\n  },\n\n  /**\n   * Set default cursor\n   * @param {string} [cursorStyle='default'] 例如 crosshair\n   */\n  setCursorStyle: function (cursorStyle) {\n    this.handler.setCursorStyle(cursorStyle);\n  },\n\n  /**\n   * Find hovered element\n   * @param {number} x\n   * @param {number} y\n   * @return {Object} {target, topTarget}\n   */\n  findHover: function (x, y) {\n    return this.handler.findHover(x, y);\n  },\n\n  /**\n   * Bind event\n   *\n   * @param {string} eventName Event name\n   * @param {Function} eventHandler Handler function\n   * @param {Object} [context] Context object\n   */\n  on: function (eventName, eventHandler, context) {\n    this.handler.on(eventName, eventHandler, context);\n  },\n\n  /**\n   * Unbind event\n   * @param {string} eventName Event name\n   * @param {Function} [eventHandler] Handler function\n   */\n  off: function (eventName, eventHandler) {\n    this.handler.off(eventName, eventHandler);\n  },\n\n  /**\n   * Trigger event manually\n   *\n   * @param {string} eventName Event name\n   * @param {event=} event Event object\n   */\n  trigger: function (eventName, event) {\n    this.handler.trigger(eventName, event);\n  },\n\n  /**\n   * Clear all objects and the canvas.\n   */\n  clear: function () {\n    this.storage.delRoot();\n    this.painter.clear();\n  },\n\n  /**\n   * Dispose self.\n   */\n  dispose: function () {\n    this.animation.stop();\n    this.clear();\n    this.storage.dispose();\n    this.painter.dispose();\n    this.handler.dispose();\n    this.animation = this.storage = this.painter = this.handler = null;\n    delInstance(this.id);\n  }\n};\nexports.version = version;\nexports.init = init;\nexports.dispose = dispose;\nexports.getInstance = getInstance;\nexports.registerPainter = registerPainter;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/zrender.js\n// module id = 67\n// module chunks = 0","var util = require(\"./core/util\");\n\nvar vec2 = require(\"./core/vector\");\n\nvar Draggable = require(\"./mixin/Draggable\");\n\nvar Eventful = require(\"./mixin/Eventful\");\n\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\nvar SILENT = 'silent';\n\nfunction makeEventPacket(eveType, targetInfo, event) {\n  return {\n    type: eveType,\n    event: event,\n    // target can only be an element that is not silent.\n    target: targetInfo.target,\n    // topTarget can be a silent element.\n    topTarget: targetInfo.topTarget,\n    cancelBubble: false,\n    offsetX: event.zrX,\n    offsetY: event.zrY,\n    gestureEvent: event.gestureEvent,\n    pinchX: event.pinchX,\n    pinchY: event.pinchY,\n    pinchScale: event.pinchScale,\n    wheelDelta: event.zrDelta,\n    zrByTouch: event.zrByTouch,\n    which: event.which\n  };\n}\n\nfunction EmptyProxy() {}\n\nEmptyProxy.prototype.dispose = function () {};\n\nvar handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n/**\n * @alias module:zrender/Handler\n * @constructor\n * @extends module:zrender/mixin/Eventful\n * @param {module:zrender/Storage} storage Storage instance.\n * @param {module:zrender/Painter} painter Painter instance.\n * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n */\n\nvar Handler = function (storage, painter, proxy, painterRoot) {\n  Eventful.call(this);\n  this.storage = storage;\n  this.painter = painter;\n  this.painterRoot = painterRoot;\n  proxy = proxy || new EmptyProxy();\n  /**\n   * Proxy of event. can be Dom, WebGLSurface, etc.\n   */\n\n  this.proxy = proxy; // Attach handler\n\n  proxy.handler = this;\n  /**\n   * {target, topTarget, x, y}\n   * @private\n   * @type {Object}\n   */\n\n  this._hovered = {};\n  /**\n   * @private\n   * @type {Date}\n   */\n\n  this._lastTouchMoment;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._lastX;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._lastY;\n  Draggable.call(this);\n  util.each(handlerNames, function (name) {\n    proxy.on && proxy.on(name, this[name], this);\n  }, this);\n};\n\nHandler.prototype = {\n  constructor: Handler,\n  mousemove: function (event) {\n    var x = event.zrX;\n    var y = event.zrY;\n    var lastHovered = this._hovered;\n    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call\n    // (like 'setOption' or 'dispatchAction') in event handlers, we should find\n    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.\n    // See #6198.\n\n    if (lastHoveredTarget && !lastHoveredTarget.__zr) {\n      lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n      lastHoveredTarget = lastHovered.target;\n    }\n\n    var hovered = this._hovered = this.findHover(x, y);\n    var hoveredTarget = hovered.target;\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element\n\n    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(lastHovered, 'mouseout', event);\n    } // Mouse moving on one element\n\n\n    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element\n\n    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(hovered, 'mouseover', event);\n    }\n  },\n  mouseout: function (event) {\n    this.dispatchToElement(this._hovered, 'mouseout', event); // There might be some doms created by upper layer application\n    // at the same level of painter.getViewportRoot() (e.g., tooltip\n    // dom created by echarts), where 'globalout' event should not\n    // be triggered when mouse enters these doms. (But 'mouseout'\n    // should be triggered at the original hovered element as usual).\n\n    var element = event.toElement || event.relatedTarget;\n    var innerDom;\n\n    do {\n      element = element && element.parentNode;\n    } while (element && element.nodeType != 9 && !(innerDom = element === this.painterRoot));\n\n    !innerDom && this.trigger('globalout', {\n      event: event\n    });\n  },\n\n  /**\n   * Resize\n   */\n  resize: function (event) {\n    this._hovered = {};\n  },\n\n  /**\n   * Dispatch event\n   * @param {string} eventName\n   * @param {event=} eventArgs\n   */\n  dispatch: function (eventName, eventArgs) {\n    var handler = this[eventName];\n    handler && handler.call(this, eventArgs);\n  },\n\n  /**\n   * Dispose\n   */\n  dispose: function () {\n    this.proxy.dispose();\n    this.storage = this.proxy = this.painter = null;\n  },\n\n  /**\n   * 设置默认的cursor style\n   * @param {string} [cursorStyle='default'] 例如 crosshair\n   */\n  setCursorStyle: function (cursorStyle) {\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(cursorStyle);\n  },\n\n  /**\n   * 事件分发代理\n   *\n   * @private\n   * @param {Object} targetInfo {target, topTarget} 目标图形元素\n   * @param {string} eventName 事件名称\n   * @param {Object} event 事件对象\n   */\n  dispatchToElement: function (targetInfo, eventName, event) {\n    targetInfo = targetInfo || {};\n    var el = targetInfo.target;\n\n    if (el && el.silent) {\n      return;\n    }\n\n    var eventHandler = 'on' + eventName;\n    var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\n    while (el) {\n      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n      el.trigger(eventName, eventPacket);\n      el = el.parent;\n\n      if (eventPacket.cancelBubble) {\n        break;\n      }\n    }\n\n    if (!eventPacket.cancelBubble) {\n      // 冒泡到顶级 zrender 对象\n      this.trigger(eventName, eventPacket); // 分发事件到用户自定义层\n      // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n\n      this.painter && this.painter.eachOtherLayer(function (layer) {\n        if (typeof layer[eventHandler] == 'function') {\n          layer[eventHandler].call(layer, eventPacket);\n        }\n\n        if (layer.trigger) {\n          layer.trigger(eventName, eventPacket);\n        }\n      });\n    }\n  },\n\n  /**\n   * @private\n   * @param {number} x\n   * @param {number} y\n   * @param {module:zrender/graphic/Displayable} exclude\n   * @return {model:zrender/Element}\n   * @method\n   */\n  findHover: function (x, y, exclude) {\n    var list = this.storage.getDisplayList();\n    var out = {\n      x: x,\n      y: y\n    };\n\n    for (var i = list.length - 1; i >= 0; i--) {\n      var hoverCheckResult;\n\n      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode\n      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {\n        !out.topTarget && (out.topTarget = list[i]);\n\n        if (hoverCheckResult !== SILENT) {\n          out.target = list[i];\n          break;\n        }\n      }\n    }\n\n    return out;\n  }\n}; // Common handlers\n\nutil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  Handler.prototype[name] = function (event) {\n    // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n    var hovered = this.findHover(event.zrX, event.zrY);\n    var hoveredTarget = hovered.target;\n\n    if (name === 'mousedown') {\n      this._downEl = hoveredTarget;\n      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup\n\n      this._upEl = hoveredTarget;\n    } else if (name === 'mosueup') {\n      this._upEl = hoveredTarget;\n    } else if (name === 'click') {\n      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,\n      // including the case that `mousedown` - `mousemove` - `mouseup`,\n      // which should be filtered, otherwise it will bring trouble to\n      // pan and zoom.\n      || !this._downPoint // Arbitrary value\n      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {\n        return;\n      }\n\n      this._downPoint = null;\n    }\n\n    this.dispatchToElement(hovered, name, event);\n  };\n});\n\nfunction isHover(displayable, x, y) {\n  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n    var el = displayable;\n    var isSilent;\n\n    while (el) {\n      // If clipped by ancestor.\n      // FIXME: If clipPath has neither stroke nor fill,\n      // el.clipPath.contain(x, y) will always return false.\n      if (el.clipPath && !el.clipPath.contain(x, y)) {\n        return false;\n      }\n\n      if (el.silent) {\n        isSilent = true;\n      }\n\n      el = el.parent;\n    }\n\n    return isSilent ? SILENT : true;\n  }\n\n  return false;\n}\n\nutil.mixin(Handler, Eventful);\nutil.mixin(Handler, Draggable);\nvar _default = Handler;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Handler.js\n// module id = 68\n// module chunks = 0","var util = require(\"./core/util\");\n\nvar env = require(\"./core/env\");\n\nvar Group = require(\"./container/Group\");\n\nvar timsort = require(\"./core/timsort\");\n\n/**\n * Storage内容仓库模块\n * @module zrender/Storage\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n// Use timsort because in most case elements are partially sorted\n// https://jsfiddle.net/pissang/jr4x7mdm/8/\nfunction shapeCompareFunc(a, b) {\n  if (a.zlevel === b.zlevel) {\n    if (a.z === b.z) {\n      // if (a.z2 === b.z2) {\n      //     // FIXME Slow has renderidx compare\n      //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n      //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n      //     return a.__renderidx - b.__renderidx;\n      // }\n      return a.z2 - b.z2;\n    }\n\n    return a.z - b.z;\n  }\n\n  return a.zlevel - b.zlevel;\n}\n/**\n * 内容仓库 (M)\n * @alias module:zrender/Storage\n * @constructor\n */\n\n\nvar Storage = function () {\n  // jshint ignore:line\n  this._roots = [];\n  this._displayList = [];\n  this._displayListLen = 0;\n};\n\nStorage.prototype = {\n  constructor: Storage,\n\n  /**\n   * @param  {Function} cb\n   *\n   */\n  traverse: function (cb, context) {\n    for (var i = 0; i < this._roots.length; i++) {\n      this._roots[i].traverse(cb, context);\n    }\n  },\n\n  /**\n   * 返回所有图形的绘制队列\n   * @param {boolean} [update=false] 是否在返回前更新该数组\n   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\n   *\n   * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n   * @return {Array.<module:zrender/graphic/Displayable>}\n   */\n  getDisplayList: function (update, includeIgnore) {\n    includeIgnore = includeIgnore || false;\n\n    if (update) {\n      this.updateDisplayList(includeIgnore);\n    }\n\n    return this._displayList;\n  },\n\n  /**\n   * 更新图形的绘制队列。\n   * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\n   * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\n   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\n   */\n  updateDisplayList: function (includeIgnore) {\n    this._displayListLen = 0;\n    var roots = this._roots;\n    var displayList = this._displayList;\n\n    for (var i = 0, len = roots.length; i < len; i++) {\n      this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n    }\n\n    displayList.length = this._displayListLen; // for (var i = 0, len = displayList.length; i < len; i++) {\n    //     displayList[i].__renderidx = i;\n    // }\n    // displayList.sort(shapeCompareFunc);\n\n    env.canvasSupported && timsort(displayList, shapeCompareFunc);\n  },\n  _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n    if (el.ignore && !includeIgnore) {\n      return;\n    }\n\n    el.beforeUpdate();\n\n    if (el.__dirty) {\n      el.update();\n    }\n\n    el.afterUpdate();\n    var userSetClipPath = el.clipPath;\n\n    if (userSetClipPath) {\n      // FIXME 效率影响\n      if (clipPaths) {\n        clipPaths = clipPaths.slice();\n      } else {\n        clipPaths = [];\n      }\n\n      var currentClipPath = userSetClipPath;\n      var parentClipPath = el; // Recursively add clip path\n\n      while (currentClipPath) {\n        // clipPath 的变换是基于使用这个 clipPath 的元素\n        currentClipPath.parent = parentClipPath;\n        currentClipPath.updateTransform();\n        clipPaths.push(currentClipPath);\n        parentClipPath = currentClipPath;\n        currentClipPath = currentClipPath.clipPath;\n      }\n    }\n\n    if (el.isGroup) {\n      var children = el._children;\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i]; // Force to mark as dirty if group is dirty\n        // FIXME __dirtyPath ?\n\n        if (el.__dirty) {\n          child.__dirty = true;\n        }\n\n        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n      } // Mark group clean here\n\n\n      el.__dirty = false;\n    } else {\n      el.__clipPaths = clipPaths;\n      this._displayList[this._displayListLen++] = el;\n    }\n  },\n\n  /**\n   * 添加图形(Shape)或者组(Group)到根节点\n   * @param {module:zrender/Element} el\n   */\n  addRoot: function (el) {\n    if (el.__storage === this) {\n      return;\n    }\n\n    if (el instanceof Group) {\n      el.addChildrenToStorage(this);\n    }\n\n    this.addToStorage(el);\n\n    this._roots.push(el);\n  },\n\n  /**\n   * 删除指定的图形(Shape)或者组(Group)\n   * @param {string|Array.<string>} [el] 如果为空清空整个Storage\n   */\n  delRoot: function (el) {\n    if (el == null) {\n      // 不指定el清空\n      for (var i = 0; i < this._roots.length; i++) {\n        var root = this._roots[i];\n\n        if (root instanceof Group) {\n          root.delChildrenFromStorage(this);\n        }\n      }\n\n      this._roots = [];\n      this._displayList = [];\n      this._displayListLen = 0;\n      return;\n    }\n\n    if (el instanceof Array) {\n      for (var i = 0, l = el.length; i < l; i++) {\n        this.delRoot(el[i]);\n      }\n\n      return;\n    }\n\n    var idx = util.indexOf(this._roots, el);\n\n    if (idx >= 0) {\n      this.delFromStorage(el);\n\n      this._roots.splice(idx, 1);\n\n      if (el instanceof Group) {\n        el.delChildrenFromStorage(this);\n      }\n    }\n  },\n  addToStorage: function (el) {\n    el.__storage = this;\n    el.dirty(false);\n    return this;\n  },\n  delFromStorage: function (el) {\n    if (el) {\n      el.__storage = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * 清空并且释放Storage\n   */\n  dispose: function () {\n    this._renderList = this._roots = null;\n  },\n  displayableSortFunc: shapeCompareFunc\n};\nvar _default = Storage;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Storage.js\n// module id = 69\n// module chunks = 0","// https://github.com/mziccard/node-timsort\nvar DEFAULT_MIN_MERGE = 32;\nvar DEFAULT_MIN_GALLOPING = 7;\nvar DEFAULT_TMP_STORAGE_LENGTH = 256;\n\nfunction minRunLength(n) {\n  var r = 0;\n\n  while (n >= DEFAULT_MIN_MERGE) {\n    r |= n & 1;\n    n >>= 1;\n  }\n\n  return n + r;\n}\n\nfunction makeAscendingRun(array, lo, hi, compare) {\n  var runHi = lo + 1;\n\n  if (runHi === hi) {\n    return 1;\n  }\n\n  if (compare(array[runHi++], array[lo]) < 0) {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n      runHi++;\n    }\n\n    reverseRun(array, lo, runHi);\n  } else {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n      runHi++;\n    }\n  }\n\n  return runHi - lo;\n}\n\nfunction reverseRun(array, lo, hi) {\n  hi--;\n\n  while (lo < hi) {\n    var t = array[lo];\n    array[lo++] = array[hi];\n    array[hi--] = t;\n  }\n}\n\nfunction binaryInsertionSort(array, lo, hi, start, compare) {\n  if (start === lo) {\n    start++;\n  }\n\n  for (; start < hi; start++) {\n    var pivot = array[start];\n    var left = lo;\n    var right = start;\n    var mid;\n\n    while (left < right) {\n      mid = left + right >>> 1;\n\n      if (compare(pivot, array[mid]) < 0) {\n        right = mid;\n      } else {\n        left = mid + 1;\n      }\n    }\n\n    var n = start - left;\n\n    switch (n) {\n      case 3:\n        array[left + 3] = array[left + 2];\n\n      case 2:\n        array[left + 2] = array[left + 1];\n\n      case 1:\n        array[left + 1] = array[left];\n        break;\n\n      default:\n        while (n > 0) {\n          array[left + n] = array[left + n - 1];\n          n--;\n        }\n\n    }\n\n    array[left] = pivot;\n  }\n}\n\nfunction gallopLeft(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) > 0) {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  } else {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) > 0) {\n      lastOffset = m + 1;\n    } else {\n      offset = m;\n    }\n  }\n\n  return offset;\n}\n\nfunction gallopRight(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) < 0) {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  } else {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) < 0) {\n      offset = m;\n    } else {\n      lastOffset = m + 1;\n    }\n  }\n\n  return offset;\n}\n\nfunction TimSort(array, compare) {\n  var minGallop = DEFAULT_MIN_GALLOPING;\n  var length = 0;\n  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n  var stackLength = 0;\n  var runStart;\n  var runLength;\n  var stackSize = 0;\n  length = array.length;\n\n  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n    tmpStorageLength = length >>> 1;\n  }\n\n  var tmp = [];\n  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n  runStart = [];\n  runLength = [];\n\n  function pushRun(_runStart, _runLength) {\n    runStart[stackSize] = _runStart;\n    runLength[stackSize] = _runLength;\n    stackSize += 1;\n  }\n\n  function mergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n        if (runLength[n - 1] < runLength[n + 1]) {\n          n--;\n        }\n      } else if (runLength[n] > runLength[n + 1]) {\n        break;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function forceMergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n        n--;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function mergeAt(i) {\n    var start1 = runStart[i];\n    var length1 = runLength[i];\n    var start2 = runStart[i + 1];\n    var length2 = runLength[i + 1];\n    runLength[i] = length1 + length2;\n\n    if (i === stackSize - 3) {\n      runStart[i + 1] = runStart[i + 2];\n      runLength[i + 1] = runLength[i + 2];\n    }\n\n    stackSize--;\n    var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n    start1 += k;\n    length1 -= k;\n\n    if (length1 === 0) {\n      return;\n    }\n\n    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n    if (length2 === 0) {\n      return;\n    }\n\n    if (length1 <= length2) {\n      mergeLow(start1, length1, start2, length2);\n    } else {\n      mergeHigh(start1, length1, start2, length2);\n    }\n  }\n\n  function mergeLow(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length1; i++) {\n      tmp[i] = array[start1 + i];\n    }\n\n    var cursor1 = 0;\n    var cursor2 = start2;\n    var dest = start1;\n    array[dest++] = array[cursor2++];\n\n    if (--length2 === 0) {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n\n      return;\n    }\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n      return;\n    }\n\n    var _minGallop = minGallop;\n    var count1, count2, exit;\n\n    while (1) {\n      count1 = 0;\n      count2 = 0;\n      exit = false;\n\n      do {\n        if (compare(array[cursor2], tmp[cursor1]) < 0) {\n          array[dest++] = array[cursor2++];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest++] = tmp[cursor1++];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n        if (count1 !== 0) {\n          for (i = 0; i < count1; i++) {\n            array[dest + i] = tmp[cursor1 + i];\n          }\n\n          dest += count1;\n          cursor1 += count1;\n          length1 -= count1;\n\n          if (length1 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = array[cursor2++];\n\n        if (--length2 === 0) {\n          exit = true;\n          break;\n        }\n\n        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n        if (count2 !== 0) {\n          for (i = 0; i < count2; i++) {\n            array[dest + i] = array[cursor2 + i];\n          }\n\n          dest += count2;\n          cursor2 += count2;\n          length2 -= count2;\n\n          if (length2 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = tmp[cursor1++];\n\n        if (--length1 === 1) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n    minGallop < 1 && (minGallop = 1);\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n    } else if (length1 === 0) {\n      throw new Error(); // throw new Error('mergeLow preconditions were not respected');\n    } else {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n    }\n  }\n\n  function mergeHigh(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length2; i++) {\n      tmp[i] = array[start2 + i];\n    }\n\n    var cursor1 = start1 + length1 - 1;\n    var cursor2 = length2 - 1;\n    var dest = start2 + length2 - 1;\n    var customCursor = 0;\n    var customDest = 0;\n    array[dest--] = array[cursor1--];\n\n    if (--length1 === 0) {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n\n      return;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n      return;\n    }\n\n    var _minGallop = minGallop;\n\n    while (true) {\n      var count1 = 0;\n      var count2 = 0;\n      var exit = false;\n\n      do {\n        if (compare(tmp[cursor2], array[cursor1]) < 0) {\n          array[dest--] = array[cursor1--];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest--] = tmp[cursor2--];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n        if (count1 !== 0) {\n          dest -= count1;\n          cursor1 -= count1;\n          length1 -= count1;\n          customDest = dest + 1;\n          customCursor = cursor1 + 1;\n\n          for (i = count1 - 1; i >= 0; i--) {\n            array[customDest + i] = array[customCursor + i];\n          }\n\n          if (length1 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = tmp[cursor2--];\n\n        if (--length2 === 1) {\n          exit = true;\n          break;\n        }\n\n        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n        if (count2 !== 0) {\n          dest -= count2;\n          cursor2 -= count2;\n          length2 -= count2;\n          customDest = dest + 1;\n          customCursor = cursor2 + 1;\n\n          for (i = 0; i < count2; i++) {\n            array[customDest + i] = tmp[customCursor + i];\n          }\n\n          if (length2 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = array[cursor1--];\n\n        if (--length1 === 0) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n\n    if (minGallop < 1) {\n      minGallop = 1;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n    } else if (length2 === 0) {\n      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');\n    } else {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n    }\n  }\n\n  this.mergeRuns = mergeRuns;\n  this.forceMergeRuns = forceMergeRuns;\n  this.pushRun = pushRun;\n}\n\nfunction sort(array, compare, lo, hi) {\n  if (!lo) {\n    lo = 0;\n  }\n\n  if (!hi) {\n    hi = array.length;\n  }\n\n  var remaining = hi - lo;\n\n  if (remaining < 2) {\n    return;\n  }\n\n  var runLength = 0;\n\n  if (remaining < DEFAULT_MIN_MERGE) {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n    binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n    return;\n  }\n\n  var ts = new TimSort(array, compare);\n  var minRun = minRunLength(remaining);\n\n  do {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n\n    if (runLength < minRun) {\n      var force = remaining;\n\n      if (force > minRun) {\n        force = minRun;\n      }\n\n      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n      runLength = force;\n    }\n\n    ts.pushRun(lo, runLength);\n    ts.mergeRuns();\n    remaining -= runLength;\n    lo += runLength;\n  } while (remaining !== 0);\n\n  ts.forceMergeRuns();\n}\n\nmodule.exports = sort;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/timsort.js\n// module id = 70\n// module chunks = 0","var _config = require(\"./config\");\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar util = require(\"./core/util\");\n\nvar log = require(\"./core/log\");\n\nvar BoundingRect = require(\"./core/BoundingRect\");\n\nvar timsort = require(\"./core/timsort\");\n\nvar Layer = require(\"./Layer\");\n\nvar requestAnimationFrame = require(\"./animation/requestAnimationFrame\");\n\nvar Image = require(\"./graphic/Image\");\n\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n// PENDIGN\n// Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n//\n// Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\nvar MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n\nfunction isLayerValid(layer) {\n  if (!layer) {\n    return false;\n  }\n\n  if (layer.__builtin__) {\n    return true;\n  }\n\n  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction preProcessLayer(layer) {\n  layer.__unusedCount++;\n}\n\nfunction postProcessLayer(layer) {\n  if (layer.__unusedCount == 1) {\n    layer.clear();\n  }\n}\n\nvar tmpRect = new BoundingRect(0, 0, 0, 0);\nvar viewRect = new BoundingRect(0, 0, 0, 0);\n\nfunction isDisplayableCulled(el, width, height) {\n  tmpRect.copy(el.getBoundingRect());\n\n  if (el.transform) {\n    tmpRect.applyTransform(el.transform);\n  }\n\n  viewRect.width = width;\n  viewRect.height = height;\n  return !tmpRect.intersect(viewRect);\n}\n\nfunction isClipPathChanged(clipPaths, prevClipPaths) {\n  if (clipPaths == prevClipPaths) {\n    // Can both be null or undefined\n    return false;\n  }\n\n  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n    return true;\n  }\n\n  for (var i = 0; i < clipPaths.length; i++) {\n    if (clipPaths[i] !== prevClipPaths[i]) {\n      return true;\n    }\n  }\n}\n\nfunction doClip(clipPaths, ctx) {\n  for (var i = 0; i < clipPaths.length; i++) {\n    var clipPath = clipPaths[i];\n    clipPath.setTransform(ctx);\n    ctx.beginPath();\n    clipPath.buildPath(ctx, clipPath.shape);\n    ctx.clip(); // Transform back\n\n    clipPath.restoreTransform(ctx);\n  }\n}\n\nfunction createRoot(width, height) {\n  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n\n  domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';\n  return domRoot;\n}\n/**\n * @alias module:zrender/Painter\n * @constructor\n * @param {HTMLElement} root 绘图容器\n * @param {module:zrender/Storage} storage\n * @param {Object} opts\n */\n\n\nvar Painter = function (root, storage, opts) {\n  this.type = 'canvas'; // In node environment using node-canvas\n\n  var singleCanvas = !root.nodeName // In node ?\n  || root.nodeName.toUpperCase() === 'CANVAS';\n  this._opts = opts = util.extend({}, opts || {});\n  /**\n   * @type {number}\n   */\n\n  this.dpr = opts.devicePixelRatio || devicePixelRatio;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._singleCanvas = singleCanvas;\n  /**\n   * 绘图容器\n   * @type {HTMLElement}\n   */\n\n  this.root = root;\n  var rootStyle = root.style;\n\n  if (rootStyle) {\n    rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n    root.innerHTML = '';\n  }\n  /**\n   * @type {module:zrender/Storage}\n   */\n\n\n  this.storage = storage;\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n\n  var zlevelList = this._zlevelList = [];\n  /**\n   * @type {Object.<string, module:zrender/Layer>}\n   * @private\n   */\n\n  var layers = this._layers = {};\n  /**\n   * @type {Object.<string, Object>}\n   * @type {private}\n   */\n\n  this._layerConfig = {};\n\n  if (!singleCanvas) {\n    this._width = this._getSize(0);\n    this._height = this._getSize(1);\n    var domRoot = this._domRoot = createRoot(this._width, this._height);\n    root.appendChild(domRoot);\n  } else {\n    if (opts.width != null) {\n      root.width = opts.width;\n    }\n\n    if (opts.height != null) {\n      root.height = opts.height;\n    } // Use canvas width and height directly\n\n\n    var width = root.width;\n    var height = root.height;\n    this._width = width;\n    this._height = height; // Create layer if only one given canvas\n    // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\n    var mainLayer = new Layer(root, this, 1);\n    mainLayer.initContext(); // FIXME Use canvas width and height\n    // mainLayer.resize(width, height);\n\n    layers[0] = mainLayer;\n    zlevelList.push(0);\n    this._domRoot = root;\n  } // Layers for progressive rendering\n\n\n  this._progressiveLayers = [];\n  /**\n   * @type {module:zrender/Layer}\n   * @private\n   */\n\n  this._hoverlayer;\n  this._hoverElements = [];\n};\n\nPainter.prototype = {\n  constructor: Painter,\n  getType: function () {\n    return 'canvas';\n  },\n\n  /**\n   * If painter use a single canvas\n   * @return {boolean}\n   */\n  isSingleCanvas: function () {\n    return this._singleCanvas;\n  },\n\n  /**\n   * @return {HTMLDivElement}\n   */\n  getViewportRoot: function () {\n    return this._domRoot;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\n   * 刷新\n   * @param {boolean} [paintAll=false] 强制绘制所有displayable\n   */\n  refresh: function (paintAll) {\n    var list = this.storage.getDisplayList(true);\n    var zlevelList = this._zlevelList;\n\n    this._paintList(list, paintAll); // Paint custum layers\n\n\n    for (var i = 0; i < zlevelList.length; i++) {\n      var z = zlevelList[i];\n      var layer = this._layers[z];\n\n      if (!layer.__builtin__ && layer.refresh) {\n        layer.refresh();\n      }\n    }\n\n    this.refreshHover();\n\n    if (this._progressiveLayers.length) {\n      this._startProgessive();\n    }\n\n    return this;\n  },\n  addHover: function (el, hoverStyle) {\n    if (el.__hoverMir) {\n      return;\n    }\n\n    var elMirror = new el.constructor({\n      style: el.style,\n      shape: el.shape\n    });\n    elMirror.__from = el;\n    el.__hoverMir = elMirror;\n    elMirror.setStyle(hoverStyle);\n\n    this._hoverElements.push(elMirror);\n  },\n  removeHover: function (el) {\n    var elMirror = el.__hoverMir;\n    var hoverElements = this._hoverElements;\n    var idx = util.indexOf(hoverElements, elMirror);\n\n    if (idx >= 0) {\n      hoverElements.splice(idx, 1);\n    }\n\n    el.__hoverMir = null;\n  },\n  clearHover: function (el) {\n    var hoverElements = this._hoverElements;\n\n    for (var i = 0; i < hoverElements.length; i++) {\n      var from = hoverElements[i].__from;\n\n      if (from) {\n        from.__hoverMir = null;\n      }\n    }\n\n    hoverElements.length = 0;\n  },\n  refreshHover: function () {\n    var hoverElements = this._hoverElements;\n    var len = hoverElements.length;\n    var hoverLayer = this._hoverlayer;\n    hoverLayer && hoverLayer.clear();\n\n    if (!len) {\n      return;\n    }\n\n    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel\n    // FIXME?\n\n    if (!hoverLayer) {\n      hoverLayer = this._hoverlayer = this.getLayer(1e5);\n    }\n\n    var scope = {};\n    hoverLayer.ctx.save();\n\n    for (var i = 0; i < len;) {\n      var el = hoverElements[i];\n      var originalEl = el.__from; // Original el is removed\n      // PENDING\n\n      if (!(originalEl && originalEl.__zr)) {\n        hoverElements.splice(i, 1);\n        originalEl.__hoverMir = null;\n        len--;\n        continue;\n      }\n\n      i++; // Use transform\n      // FIXME style and shape ?\n\n      if (!originalEl.invisible) {\n        el.transform = originalEl.transform;\n        el.invTransform = originalEl.invTransform;\n        el.__clipPaths = originalEl.__clipPaths; // el.\n\n        this._doPaintEl(el, hoverLayer, true, scope);\n      }\n    }\n\n    hoverLayer.ctx.restore();\n  },\n  _startProgessive: function () {\n    var self = this;\n\n    if (!self._furtherProgressive) {\n      return;\n    } // Use a token to stop progress steps triggered by\n    // previous zr.refresh calling.\n\n\n    var token = self._progressiveToken = +new Date();\n    self._progress++;\n    requestAnimationFrame(step);\n\n    function step() {\n      // In case refreshed or disposed\n      if (token === self._progressiveToken && self.storage) {\n        self._doPaintList(self.storage.getDisplayList());\n\n        if (self._furtherProgressive) {\n          self._progress++;\n          requestAnimationFrame(step);\n        } else {\n          self._progressiveToken = -1;\n        }\n      }\n    }\n  },\n  _clearProgressive: function () {\n    this._progressiveToken = -1;\n    this._progress = 0;\n    util.each(this._progressiveLayers, function (layer) {\n      layer.__dirty && layer.clear();\n    });\n  },\n  _paintList: function (list, paintAll) {\n    if (paintAll == null) {\n      paintAll = false;\n    }\n\n    this._updateLayerStatus(list);\n\n    this._clearProgressive();\n\n    this.eachBuiltinLayer(preProcessLayer);\n\n    this._doPaintList(list, paintAll);\n\n    this.eachBuiltinLayer(postProcessLayer);\n  },\n  _doPaintList: function (list, paintAll) {\n    var currentLayer;\n    var currentZLevel;\n    var ctx; // var invTransform = [];\n\n    var scope;\n    var progressiveLayerIdx = 0;\n    var currentProgressiveLayer;\n    var width = this._width;\n    var height = this._height;\n    var layerProgress;\n    var frame = this._progress;\n\n    function flushProgressiveLayer(layer) {\n      var dpr = ctx.dpr || 1;\n      ctx.save();\n      ctx.globalAlpha = 1;\n      ctx.shadowBlur = 0; // Avoid layer don't clear in next progressive frame\n\n      currentLayer.__dirty = true;\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n      ctx.restore();\n    }\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      var el = list[i];\n      var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n      var elFrame = el.__frame; // Flush at current context\n      // PENDING\n\n      if (elFrame < 0 && currentProgressiveLayer) {\n        flushProgressiveLayer(currentProgressiveLayer);\n        currentProgressiveLayer = null;\n      } // Change draw layer\n\n\n      if (currentZLevel !== elZLevel) {\n        if (ctx) {\n          ctx.restore();\n        } // Reset scope\n\n\n        scope = {}; // Only 0 zlevel if only has one canvas\n\n        currentZLevel = elZLevel;\n        currentLayer = this.getLayer(currentZLevel);\n\n        if (!currentLayer.__builtin__) {\n          log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);\n        }\n\n        ctx = currentLayer.ctx;\n        ctx.save(); // Reset the count\n\n        currentLayer.__unusedCount = 0;\n\n        if (currentLayer.__dirty || paintAll) {\n          currentLayer.clear();\n        }\n      }\n\n      if (!(currentLayer.__dirty || paintAll)) {\n        continue;\n      }\n\n      if (elFrame >= 0) {\n        // Progressive layer changed\n        if (!currentProgressiveLayer) {\n          currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];\n          currentProgressiveLayer.ctx.save();\n          currentProgressiveLayer.renderScope = {};\n\n          if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {\n            // flushProgressiveLayer(currentProgressiveLayer);\n            // Quick jump all progressive elements\n            // All progressive element are not dirty, jump over and flush directly\n            i = currentProgressiveLayer.__nextIdxNotProg - 1; // currentProgressiveLayer = null;\n\n            continue;\n          }\n\n          layerProgress = currentProgressiveLayer.__progress;\n\n          if (!currentProgressiveLayer.__dirty) {\n            // Keep rendering\n            frame = layerProgress;\n          }\n\n          currentProgressiveLayer.__progress = frame + 1;\n        }\n\n        if (elFrame === frame) {\n          this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n        }\n      } else {\n        this._doPaintEl(el, currentLayer, paintAll, scope);\n      }\n\n      el.__dirty = false;\n    }\n\n    if (currentProgressiveLayer) {\n      flushProgressiveLayer(currentProgressiveLayer);\n    } // Restore the lastLayer ctx\n\n\n    ctx && ctx.restore(); // If still has clipping state\n    // if (scope.prevElClipPaths) {\n    //     ctx.restore();\n    // }\n\n    this._furtherProgressive = false;\n    util.each(this._progressiveLayers, function (layer) {\n      if (layer.__maxProgress >= layer.__progress) {\n        this._furtherProgressive = true;\n      }\n    }, this);\n  },\n  _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n    var ctx = currentLayer.ctx;\n    var m = el.transform;\n\n    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element\n    !el.invisible // Ignore transparent element\n    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas\n    // Draw a scale 0 element can cause all following draw wrong\n    // And setTransform with scale 0 will cause set back transform failed.\n    && !(m && !m[0] && !m[3]) // Ignore culled element\n    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n      var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements\n\n      if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {\n        // If has previous clipping state, restore from it\n        if (scope.prevElClipPaths) {\n          scope.prevClipLayer.ctx.restore();\n          scope.prevClipLayer = scope.prevElClipPaths = null; // Reset prevEl since context has been restored\n\n          scope.prevEl = null;\n        } // New clipping state\n\n\n        if (clipPaths) {\n          ctx.save();\n          doClip(clipPaths, ctx);\n          scope.prevClipLayer = currentLayer;\n          scope.prevElClipPaths = clipPaths;\n        }\n      }\n\n      el.beforeBrush && el.beforeBrush(ctx);\n      el.brush(ctx, scope.prevEl || null);\n      scope.prevEl = el;\n      el.afterBrush && el.afterBrush(ctx);\n    }\n  },\n\n  /**\n   * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n   * @param {number} zlevel\n   * @return {module:zrender/Layer}\n   */\n  getLayer: function (zlevel) {\n    if (this._singleCanvas) {\n      return this._layers[0];\n    }\n\n    var layer = this._layers[zlevel];\n\n    if (!layer) {\n      // Create a new layer\n      layer = new Layer('zr_' + zlevel, this, this.dpr);\n      layer.__builtin__ = true;\n\n      if (this._layerConfig[zlevel]) {\n        util.merge(layer, this._layerConfig[zlevel], true);\n      }\n\n      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document\n      // Or excanvas will get 0px clientWidth and clientHeight\n\n      layer.initContext();\n    }\n\n    return layer;\n  },\n  insertLayer: function (zlevel, layer) {\n    var layersMap = this._layers;\n    var zlevelList = this._zlevelList;\n    var len = zlevelList.length;\n    var prevLayer = null;\n    var i = -1;\n    var domRoot = this._domRoot;\n\n    if (layersMap[zlevel]) {\n      log('ZLevel ' + zlevel + ' has been used already');\n      return;\n    } // Check if is a valid layer\n\n\n    if (!isLayerValid(layer)) {\n      log('Layer of zlevel ' + zlevel + ' is not valid');\n      return;\n    }\n\n    if (len > 0 && zlevel > zlevelList[0]) {\n      for (i = 0; i < len - 1; i++) {\n        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n          break;\n        }\n      }\n\n      prevLayer = layersMap[zlevelList[i]];\n    }\n\n    zlevelList.splice(i + 1, 0, zlevel);\n    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.\n    // (It can be a WebGL layer and assigned to a ZImage element)\n    // But it still under management of zrender.\n\n    if (!layer.virtual) {\n      if (prevLayer) {\n        var prevDom = prevLayer.dom;\n\n        if (prevDom.nextSibling) {\n          domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      } else {\n        if (domRoot.firstChild) {\n          domRoot.insertBefore(layer.dom, domRoot.firstChild);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      }\n    }\n  },\n  // Iterate each layer\n  eachLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      cb.call(context, this._layers[z], z);\n    }\n  },\n  // Iterate each buildin layer\n  eachBuiltinLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n  // Iterate each other layer except buildin layer\n  eachOtherLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (!layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n\n  /**\n   * 获取所有已创建的层\n   * @param {Array.<module:zrender/Layer>} [prevLayer]\n   */\n  getLayers: function () {\n    return this._layers;\n  },\n  _updateLayerStatus: function (list) {\n    var layers = this._layers;\n    var progressiveLayers = this._progressiveLayers;\n    var elCountsLastFrame = {};\n    var progressiveElCountsLastFrame = {};\n    this.eachBuiltinLayer(function (layer, z) {\n      elCountsLastFrame[z] = layer.elCount;\n      layer.elCount = 0;\n      layer.__dirty = false;\n    });\n    util.each(progressiveLayers, function (layer, idx) {\n      progressiveElCountsLastFrame[idx] = layer.elCount;\n      layer.elCount = 0;\n      layer.__dirty = false;\n    });\n    var progressiveLayerCount = 0;\n    var currentProgressiveLayer;\n    var lastProgressiveKey;\n    var frameCount = 0;\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      var el = list[i];\n      var zlevel = this._singleCanvas ? 0 : el.zlevel;\n      var layer = layers[zlevel];\n      var elProgress = el.progressive;\n\n      if (layer) {\n        layer.elCount++;\n        layer.__dirty = layer.__dirty || el.__dirty;\n      } /////// Update progressive\n\n\n      if (elProgress >= 0) {\n        // Fix wrong progressive sequence problem.\n        if (lastProgressiveKey !== elProgress) {\n          lastProgressiveKey = elProgress;\n          frameCount++;\n        }\n\n        var elFrame = el.__frame = frameCount - 1;\n\n        if (!currentProgressiveLayer) {\n          var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n          currentProgressiveLayer = progressiveLayers[idx];\n\n          if (!currentProgressiveLayer) {\n            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);\n            currentProgressiveLayer.initContext();\n          }\n\n          currentProgressiveLayer.__maxProgress = 0;\n        }\n\n        currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n        currentProgressiveLayer.elCount++;\n        currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);\n\n        if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n          // Should keep rendering this  layer because progressive rendering is not finished yet\n          layer.__dirty = true;\n        }\n      } else {\n        el.__frame = -1;\n\n        if (currentProgressiveLayer) {\n          currentProgressiveLayer.__nextIdxNotProg = i;\n          progressiveLayerCount++;\n          currentProgressiveLayer = null;\n        }\n      }\n    }\n\n    if (currentProgressiveLayer) {\n      progressiveLayerCount++;\n      currentProgressiveLayer.__nextIdxNotProg = i;\n    } // 层中的元素数量有发生变化\n\n\n    this.eachBuiltinLayer(function (layer, z) {\n      if (elCountsLastFrame[z] !== layer.elCount) {\n        layer.__dirty = true;\n      }\n    });\n    progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n    util.each(progressiveLayers, function (layer, idx) {\n      if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n        el.__dirty = true;\n      }\n\n      if (layer.__dirty) {\n        layer.__progress = 0;\n      }\n    });\n  },\n\n  /**\n   * 清除hover层外所有内容\n   */\n  clear: function () {\n    this.eachBuiltinLayer(this._clearLayer);\n    return this;\n  },\n  _clearLayer: function (layer) {\n    layer.clear();\n  },\n\n  /**\n   * 修改指定zlevel的绘制参数\n   *\n   * @param {string} zlevel\n   * @param {Object} config 配置对象\n   * @param {string} [config.clearColor=0] 每次清空画布的颜色\n   * @param {string} [config.motionBlur=false] 是否开启动态模糊\n   * @param {number} [config.lastFrameAlpha=0.7]\n   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n   */\n  configLayer: function (zlevel, config) {\n    if (config) {\n      var layerConfig = this._layerConfig;\n\n      if (!layerConfig[zlevel]) {\n        layerConfig[zlevel] = config;\n      } else {\n        util.merge(layerConfig[zlevel], config, true);\n      }\n\n      var layer = this._layers[zlevel];\n\n      if (layer) {\n        util.merge(layer, layerConfig[zlevel], true);\n      }\n    }\n  },\n\n  /**\n   * 删除指定层\n   * @param {number} zlevel 层所在的zlevel\n   */\n  delLayer: function (zlevel) {\n    var layers = this._layers;\n    var zlevelList = this._zlevelList;\n    var layer = layers[zlevel];\n\n    if (!layer) {\n      return;\n    }\n\n    layer.dom.parentNode.removeChild(layer.dom);\n    delete layers[zlevel];\n    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n  },\n\n  /**\n   * 区域大小变化后重绘\n   */\n  resize: function (width, height) {\n    var domRoot = this._domRoot; // FIXME Why ?\n\n    domRoot.style.display = 'none'; // Save input w/h\n\n    var opts = this._opts;\n    width != null && (opts.width = width);\n    height != null && (opts.height = height);\n    width = this._getSize(0);\n    height = this._getSize(1);\n    domRoot.style.display = ''; // 优化没有实际改变的resize\n\n    if (this._width != width || height != this._height) {\n      domRoot.style.width = width + 'px';\n      domRoot.style.height = height + 'px';\n\n      for (var id in this._layers) {\n        if (this._layers.hasOwnProperty(id)) {\n          this._layers[id].resize(width, height);\n        }\n      }\n\n      util.each(this._progressiveLayers, function (layer) {\n        layer.resize(width, height);\n      });\n      this.refresh(true);\n    }\n\n    this._width = width;\n    this._height = height;\n    return this;\n  },\n\n  /**\n   * 清除单独的一个层\n   * @param {number} zlevel\n   */\n  clearLayer: function (zlevel) {\n    var layer = this._layers[zlevel];\n\n    if (layer) {\n      layer.clear();\n    }\n  },\n\n  /**\n   * 释放\n   */\n  dispose: function () {\n    this.root.innerHTML = '';\n    this.root = this.storage = this._domRoot = this._layers = null;\n  },\n\n  /**\n   * Get canvas which has all thing rendered\n   * @param {Object} opts\n   * @param {string} [opts.backgroundColor]\n   * @param {number} [opts.pixelRatio]\n   */\n  getRenderedCanvas: function (opts) {\n    opts = opts || {};\n\n    if (this._singleCanvas) {\n      return this._layers[0].dom;\n    }\n\n    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n    imageLayer.initContext();\n    imageLayer.clearColor = opts.backgroundColor;\n    imageLayer.clear();\n    var displayList = this.storage.getDisplayList(true);\n    var scope = {};\n    var zlevel;\n    var self = this;\n\n    function findAndDrawOtherLayer(smaller, larger) {\n      var zlevelList = self._zlevelList;\n\n      if (smaller == null) {\n        smaller = -Infinity;\n      }\n\n      var intermediateLayer;\n\n      for (var i = 0; i < zlevelList.length; i++) {\n        var z = zlevelList[i];\n        var layer = self._layers[z];\n\n        if (!layer.__builtin__ && z > smaller && z < larger) {\n          intermediateLayer = layer;\n          break;\n        }\n      }\n\n      if (intermediateLayer && intermediateLayer.renderToCanvas) {\n        imageLayer.ctx.save();\n        intermediateLayer.renderToCanvas(imageLayer.ctx);\n        imageLayer.ctx.restore();\n      }\n    }\n\n    for (var i = 0; i < displayList.length; i++) {\n      var el = displayList[i];\n\n      if (el.zlevel !== zlevel) {\n        findAndDrawOtherLayer(zlevel, el.zlevel);\n        zlevel = el.zlevel;\n      }\n\n      this._doPaintEl(el, imageLayer, true, scope);\n    }\n\n    findAndDrawOtherLayer(zlevel, Infinity);\n    return imageLayer.dom;\n  },\n\n  /**\n   * 获取绘图区域宽度\n   */\n  getWidth: function () {\n    return this._width;\n  },\n\n  /**\n   * 获取绘图区域高度\n   */\n  getHeight: function () {\n    return this._height;\n  },\n  _getSize: function (whIdx) {\n    var opts = this._opts;\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n      return parseFloat(opts[wh]);\n    }\n\n    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\n    var stl = document.defaultView.getComputedStyle(root);\n    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n  },\n  pathToImage: function (path, dpr) {\n    dpr = dpr || this.dpr;\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    var rect = path.getBoundingRect();\n    var style = path.style;\n    var shadowBlurSize = style.shadowBlur;\n    var shadowOffsetX = style.shadowOffsetX;\n    var shadowOffsetY = style.shadowOffsetY;\n    var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n    var width = rect.width + leftMargin + rightMargin;\n    var height = rect.height + topMargin + bottomMargin;\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    ctx.scale(dpr, dpr);\n    ctx.clearRect(0, 0, width, height);\n    ctx.dpr = dpr;\n    var pathTransform = {\n      position: path.position,\n      rotation: path.rotation,\n      scale: path.scale\n    };\n    path.position = [leftMargin - rect.x, topMargin - rect.y];\n    path.rotation = 0;\n    path.scale = [1, 1];\n    path.updateTransform();\n\n    if (path) {\n      path.brush(ctx);\n    }\n\n    var ImageShape = Image;\n    var imgShape = new ImageShape({\n      style: {\n        x: 0,\n        y: 0,\n        image: canvas\n      }\n    });\n\n    if (pathTransform.position != null) {\n      imgShape.position = path.position = pathTransform.position;\n    }\n\n    if (pathTransform.rotation != null) {\n      imgShape.rotation = path.rotation = pathTransform.rotation;\n    }\n\n    if (pathTransform.scale != null) {\n      imgShape.scale = path.scale = pathTransform.scale;\n    }\n\n    return imgShape;\n  }\n};\nvar _default = Painter;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Painter.js\n// module id = 71\n// module chunks = 0","var util = require(\"./core/util\");\n\nvar _config = require(\"./config\");\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar Style = require(\"./graphic/Style\");\n\nvar Pattern = require(\"./graphic/Pattern\");\n\n/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\nfunction returnFalse() {\n  return false;\n}\n/**\n * 创建dom\n *\n * @inner\n * @param {string} id dom id 待用\n * @param {Painter} painter painter instance\n * @param {number} number\n */\n\n\nfunction createDom(id, painter, dpr) {\n  var newDom = util.createCanvas();\n  var width = painter.getWidth();\n  var height = painter.getHeight();\n  var newDomStyle = newDom.style; // 没append呢，请原谅我这样写，清晰~\n\n  newDomStyle.position = 'absolute';\n  newDomStyle.left = 0;\n  newDomStyle.top = 0;\n  newDomStyle.width = width + 'px';\n  newDomStyle.height = height + 'px';\n  newDom.width = width * dpr;\n  newDom.height = height * dpr; // id不作为索引用，避免可能造成的重名，定义为私有属性\n\n  newDom.setAttribute('data-zr-dom-id', id);\n  return newDom;\n}\n/**\n * @alias module:zrender/Layer\n * @constructor\n * @extends module:zrender/mixin/Transformable\n * @param {string} id\n * @param {module:zrender/Painter} painter\n * @param {number} [dpr]\n */\n\n\nvar Layer = function (id, painter, dpr) {\n  var dom;\n  dpr = dpr || devicePixelRatio;\n\n  if (typeof id === 'string') {\n    dom = createDom(id, painter, dpr);\n  } // Not using isDom because in node it will return false\n  else if (util.isObject(id)) {\n      dom = id;\n      id = dom.id;\n    }\n\n  this.id = id;\n  this.dom = dom;\n  var domStyle = dom.style;\n\n  if (domStyle) {\n    // Not in node\n    dom.onselectstart = returnFalse; // 避免页面选中的尴尬\n\n    domStyle['-webkit-user-select'] = 'none';\n    domStyle['user-select'] = 'none';\n    domStyle['-webkit-touch-callout'] = 'none';\n    domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n    domStyle['padding'] = 0;\n    domStyle['margin'] = 0;\n    domStyle['border-width'] = 0;\n  }\n\n  this.domBack = null;\n  this.ctxBack = null;\n  this.painter = painter;\n  this.config = null; // Configs\n\n  /**\n   * 每次清空画布的颜色\n   * @type {string}\n   * @default 0\n   */\n\n  this.clearColor = 0;\n  /**\n   * 是否开启动态模糊\n   * @type {boolean}\n   * @default false\n   */\n\n  this.motionBlur = false;\n  /**\n   * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n   * @type {number}\n   * @default 0.7\n   */\n\n  this.lastFrameAlpha = 0.7;\n  /**\n   * Layer dpr\n   * @type {number}\n   */\n\n  this.dpr = dpr;\n};\n\nLayer.prototype = {\n  constructor: Layer,\n  elCount: 0,\n  __dirty: true,\n  initContext: function () {\n    this.ctx = this.dom.getContext('2d');\n    this.ctx.__currentValues = {};\n    this.ctx.dpr = this.dpr;\n  },\n  createBackBuffer: function () {\n    var dpr = this.dpr;\n    this.domBack = createDom('back-' + this.id, this.painter, dpr);\n    this.ctxBack = this.domBack.getContext('2d');\n    this.ctxBack.__currentValues = {};\n\n    if (dpr != 1) {\n      this.ctxBack.scale(dpr, dpr);\n    }\n  },\n\n  /**\n   * @param  {number} width\n   * @param  {number} height\n   */\n  resize: function (width, height) {\n    var dpr = this.dpr;\n    var dom = this.dom;\n    var domStyle = dom.style;\n    var domBack = this.domBack;\n    domStyle.width = width + 'px';\n    domStyle.height = height + 'px';\n    dom.width = width * dpr;\n    dom.height = height * dpr;\n\n    if (domBack) {\n      domBack.width = width * dpr;\n      domBack.height = height * dpr;\n\n      if (dpr != 1) {\n        this.ctxBack.scale(dpr, dpr);\n      }\n    }\n  },\n\n  /**\n   * 清空该层画布\n   * @param {boolean} clearAll Clear all with out motion blur\n   */\n  clear: function (clearAll) {\n    var dom = this.dom;\n    var ctx = this.ctx;\n    var width = dom.width;\n    var height = dom.height;\n    var clearColor = this.clearColor;\n    var haveMotionBLur = this.motionBlur && !clearAll;\n    var lastFrameAlpha = this.lastFrameAlpha;\n    var dpr = this.dpr;\n\n    if (haveMotionBLur) {\n      if (!this.domBack) {\n        this.createBackBuffer();\n      }\n\n      this.ctxBack.globalCompositeOperation = 'copy';\n      this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);\n    }\n\n    ctx.clearRect(0, 0, width, height);\n\n    if (clearColor) {\n      var clearColorGradientOrPattern; // Gradient\n\n      if (clearColor.colorStops) {\n        // Cache canvas gradient\n        clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n          x: 0,\n          y: 0,\n          width: width,\n          height: height\n        });\n        clearColor.__canvasGradient = clearColorGradientOrPattern;\n      } // Pattern\n      else if (clearColor.image) {\n          clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n        }\n\n      ctx.save();\n      ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n      ctx.fillRect(0, 0, width, height);\n      ctx.restore();\n    }\n\n    if (haveMotionBLur) {\n      var domBack = this.domBack;\n      ctx.save();\n      ctx.globalAlpha = lastFrameAlpha;\n      ctx.drawImage(domBack, 0, 0, width, height);\n      ctx.restore();\n    }\n  }\n};\nvar _default = Layer;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Layer.js\n// module id = 72\n// module chunks = 0","var _default = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809\nwindow.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {\n  setTimeout(func, 16);\n};\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/requestAnimationFrame.js\n// module id = 73\n// module chunks = 0","var util = require(\"../core/util\");\n\nvar _event = require(\"../core/event\");\n\nvar Dispatcher = _event.Dispatcher;\n\nvar requestAnimationFrame = require(\"./requestAnimationFrame\");\n\nvar Animator = require(\"./Animator\");\n\n/**\n * 动画主类, 调度和管理所有动画控制器\n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n/**\n * @typedef {Object} IZRenderStage\n * @property {Function} update\n */\n\n/**\n * @alias module:zrender/animation/Animation\n * @constructor\n * @param {Object} [options]\n * @param {Function} [options.onframe]\n * @param {IZRenderStage} [options.stage]\n * @example\n *     var animation = new Animation();\n *     var obj = {\n *         x: 100,\n *         y: 100\n *     };\n *     animation.animate(node.position)\n *         .when(1000, {\n *             x: 500,\n *             y: 500\n *         })\n *         .when(2000, {\n *             x: 100,\n *             y: 100\n *         })\n *         .start('spline');\n */\nvar Animation = function (options) {\n  options = options || {};\n  this.stage = options.stage || {};\n\n  this.onframe = options.onframe || function () {}; // private properties\n\n\n  this._clips = [];\n  this._running = false;\n  this._time;\n  this._pausedTime;\n  this._pauseStart;\n  this._paused = false;\n  Dispatcher.call(this);\n};\n\nAnimation.prototype = {\n  constructor: Animation,\n\n  /**\n   * 添加 clip\n   * @param {module:zrender/animation/Clip} clip\n   */\n  addClip: function (clip) {\n    this._clips.push(clip);\n  },\n\n  /**\n   * 添加 animator\n   * @param {module:zrender/animation/Animator} animator\n   */\n  addAnimator: function (animator) {\n    animator.animation = this;\n    var clips = animator.getClips();\n\n    for (var i = 0; i < clips.length; i++) {\n      this.addClip(clips[i]);\n    }\n  },\n\n  /**\n   * 删除动画片段\n   * @param {module:zrender/animation/Clip} clip\n   */\n  removeClip: function (clip) {\n    var idx = util.indexOf(this._clips, clip);\n\n    if (idx >= 0) {\n      this._clips.splice(idx, 1);\n    }\n  },\n\n  /**\n   * 删除动画片段\n   * @param {module:zrender/animation/Animator} animator\n   */\n  removeAnimator: function (animator) {\n    var clips = animator.getClips();\n\n    for (var i = 0; i < clips.length; i++) {\n      this.removeClip(clips[i]);\n    }\n\n    animator.animation = null;\n  },\n  _update: function () {\n    var time = new Date().getTime() - this._pausedTime;\n\n    var delta = time - this._time;\n    var clips = this._clips;\n    var len = clips.length;\n    var deferredEvents = [];\n    var deferredClips = [];\n\n    for (var i = 0; i < len; i++) {\n      var clip = clips[i];\n      var e = clip.step(time, delta); // Throw out the events need to be called after\n      // stage.update, like destroy\n\n      if (e) {\n        deferredEvents.push(e);\n        deferredClips.push(clip);\n      }\n    } // Remove the finished clip\n\n\n    for (var i = 0; i < len;) {\n      if (clips[i]._needsRemove) {\n        clips[i] = clips[len - 1];\n        clips.pop();\n        len--;\n      } else {\n        i++;\n      }\n    }\n\n    len = deferredEvents.length;\n\n    for (var i = 0; i < len; i++) {\n      deferredClips[i].fire(deferredEvents[i]);\n    }\n\n    this._time = time;\n    this.onframe(delta);\n    this.trigger('frame', delta);\n\n    if (this.stage.update) {\n      this.stage.update();\n    }\n  },\n  _startLoop: function () {\n    var self = this;\n    this._running = true;\n\n    function step() {\n      if (self._running) {\n        requestAnimationFrame(step);\n        !self._paused && self._update();\n      }\n    }\n\n    requestAnimationFrame(step);\n  },\n\n  /**\n   * 开始运行动画\n   */\n  start: function () {\n    this._time = new Date().getTime();\n    this._pausedTime = 0;\n\n    this._startLoop();\n  },\n\n  /**\n   * 停止运行动画\n   */\n  stop: function () {\n    this._running = false;\n  },\n\n  /**\n   * Pause\n   */\n  pause: function () {\n    if (!this._paused) {\n      this._pauseStart = new Date().getTime();\n      this._paused = true;\n    }\n  },\n\n  /**\n   * Resume\n   */\n  resume: function () {\n    if (this._paused) {\n      this._pausedTime += new Date().getTime() - this._pauseStart;\n      this._paused = false;\n    }\n  },\n\n  /**\n   * 清除所有动画片段\n   */\n  clear: function () {\n    this._clips = [];\n  },\n\n  /**\n   * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画\n   * @param  {Object} target\n   * @param  {Object} options\n   * @param  {boolean} [options.loop=false] 是否循环播放动画\n   * @param  {Function} [options.getter=null]\n   *         如果指定getter函数，会通过getter函数取属性值\n   * @param  {Function} [options.setter=null]\n   *         如果指定setter函数，会通过setter函数设置属性值\n   * @return {module:zrender/animation/Animation~Animator}\n   */\n  // TODO Gap\n  animate: function (target, options) {\n    options = options || {};\n    var animator = new Animator(target, options.loop, options.getter, options.setter);\n    this.addAnimator(animator);\n    return animator;\n  }\n};\nutil.mixin(Animation, Dispatcher);\nvar _default = Animation;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Animation.js\n// module id = 74\n// module chunks = 0","var Eventful = require(\"../mixin/Eventful\");\n\nexports.Dispatcher = Eventful;\n\nvar env = require(\"./env\");\n\n/**\n * 事件辅助类\n * @module zrender/core/event\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n */\nvar isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\nvar MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;\n\nfunction getBoundingClientRect(el) {\n  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n  return el.getBoundingClientRect ? el.getBoundingClientRect() : {\n    left: 0,\n    top: 0\n  };\n} // `calculate` is optional, default false\n\n\nfunction clientToLocal(el, e, out, calculate) {\n  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative\n  // to the padding edge of the target element. The only browser using this convention\n  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n  // not support the properties.\n  // (see http://www.jacklmoore.com/notes/mouse-position/)\n  // In zr painter.dom, padding edge equals to border edge.\n  // FIXME\n  // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n  // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n  // is too complex. So css-transfrom dont support in this case temporarily.\n\n  if (calculate || !env.canvasSupported) {\n    defaultGetZrXY(el, e, out);\n  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n  // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n  // zoom-factor, overflow / opacity layers, transforms ...)\n  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n  // <https://bugs.jquery.com/ticket/8523#comment:14>\n  // BTW3, In ff, offsetX/offsetY is always 0.\n  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n      out.zrX = e.layerX;\n      out.zrY = e.layerY;\n    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n    else if (e.offsetX != null) {\n        out.zrX = e.offsetX;\n        out.zrY = e.offsetY;\n      } // For some other device, e.g., IOS safari.\n      else {\n          defaultGetZrXY(el, e, out);\n        }\n\n  return out;\n}\n\nfunction defaultGetZrXY(el, e, out) {\n  // This well-known method below does not support css transform.\n  var box = getBoundingClientRect(el);\n  out.zrX = e.clientX - box.left;\n  out.zrY = e.clientY - box.top;\n}\n/**\n * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.\n * `calculate` is optional, default false.\n */\n\n\nfunction normalizeEvent(el, e, calculate) {\n  e = e || window.event;\n\n  if (e.zrX != null) {\n    return e;\n  }\n\n  var eventType = e.type;\n  var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n  if (!isTouch) {\n    clientToLocal(el, e, e, calculate);\n    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n  } else {\n    var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n    touch && clientToLocal(el, touch, e, calculate);\n  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;\n  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js\n  // If e.which has been defined, if may be readonly,\n  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which\n\n\n  var button = e.button;\n\n  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {\n    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n  }\n\n  return e;\n}\n\nfunction addEventListener(el, name, handler) {\n  if (isDomLevel2) {\n    el.addEventListener(name, handler);\n  } else {\n    el.attachEvent('on' + name, handler);\n  }\n}\n\nfunction removeEventListener(el, name, handler) {\n  if (isDomLevel2) {\n    el.removeEventListener(name, handler);\n  } else {\n    el.detachEvent('on' + name, handler);\n  }\n}\n/**\n * preventDefault and stopPropagation.\n * Notice: do not do that in zrender. Upper application\n * do that if necessary.\n *\n * @memberOf module:zrender/core/event\n * @method\n * @param {Event} e : event对象\n */\n\n\nvar stop = isDomLevel2 ? function (e) {\n  e.preventDefault();\n  e.stopPropagation();\n  e.cancelBubble = true;\n} : function (e) {\n  e.returnValue = false;\n  e.cancelBubble = true;\n};\n\nfunction notLeftMouse(e) {\n  // If e.which is undefined, considered as left mouse event.\n  return e.which > 1;\n} // 做向上兼容\n\n\nexports.clientToLocal = clientToLocal;\nexports.normalizeEvent = normalizeEvent;\nexports.addEventListener = addEventListener;\nexports.removeEventListener = removeEventListener;\nexports.stop = stop;\nexports.notLeftMouse = notLeftMouse;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/event.js\n// module id = 75\n// module chunks = 0","var _event = require(\"../core/event\");\n\nvar addEventListener = _event.addEventListener;\nvar removeEventListener = _event.removeEventListener;\nvar normalizeEvent = _event.normalizeEvent;\n\nvar zrUtil = require(\"../core/util\");\n\nvar Eventful = require(\"../mixin/Eventful\");\n\nvar env = require(\"../core/env\");\n\nvar GestureMgr = require(\"../core/GestureMgr\");\n\nvar TOUCH_CLICK_DELAY = 300;\nvar mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\nvar touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];\nvar pointerEventNames = {\n  pointerdown: 1,\n  pointerup: 1,\n  pointermove: 1,\n  pointerout: 1\n};\nvar pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n  var nm = name.replace('mouse', 'pointer');\n  return pointerEventNames[nm] ? nm : name;\n});\n\nfunction eventNameFix(name) {\n  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n}\n\nfunction processGesture(proxy, event, stage) {\n  var gestureMgr = proxy._gestureMgr;\n  stage === 'start' && gestureMgr.clear();\n  var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null).target, proxy.dom);\n  stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.\n\n  if (gestureInfo) {\n    var type = gestureInfo.type;\n    event.gestureEvent = type;\n    proxy.handler.dispatchToElement({\n      target: gestureInfo.target\n    }, type, gestureInfo.event);\n  }\n} // function onMSGestureChange(proxy, event) {\n//     if (event.translationX || event.translationY) {\n//         // mousemove is carried by MSGesture to reduce the sensitivity.\n//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n//     }\n//     if (event.scale !== 1) {\n//         event.pinchX = event.offsetX;\n//         event.pinchY = event.offsetY;\n//         event.pinchScale = event.scale;\n//         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n//     }\n// }\n\n/**\n * Prevent mouse event from being dispatched after Touch Events action\n * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n * Result: Blocking Mouse Events for 700ms.\n */\n\n\nfunction setTouchTimer(instance) {\n  instance._touching = true;\n  clearTimeout(instance._touchTimer);\n  instance._touchTimer = setTimeout(function () {\n    instance._touching = false;\n  }, 700);\n}\n\nvar domHandlers = {\n  /**\n   * Mouse move handler\n   * @inner\n   * @param {Event} event\n   */\n  mousemove: function (event) {\n    event = normalizeEvent(this.dom, event);\n    this.trigger('mousemove', event);\n  },\n\n  /**\n   * Mouse out handler\n   * @inner\n   * @param {Event} event\n   */\n  mouseout: function (event) {\n    event = normalizeEvent(this.dom, event);\n    var element = event.toElement || event.relatedTarget;\n\n    if (element != this.dom) {\n      while (element && element.nodeType != 9) {\n        // 忽略包含在root中的dom引起的mouseOut\n        if (element === this.dom) {\n          return;\n        }\n\n        element = element.parentNode;\n      }\n    }\n\n    this.trigger('mouseout', event);\n  },\n\n  /**\n   * Touch开始响应函数\n   * @inner\n   * @param {Event} event\n   */\n  touchstart: function (event) {\n    // Default mouse behaviour should not be disabled here.\n    // For example, page may needs to be slided.\n    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n    // mouse event in upper applicatoin.\n\n    event.zrByTouch = true;\n    this._lastTouchMoment = new Date();\n    processGesture(this, event, 'start'); // In touch device, trigger `mousemove`(`mouseover`) should\n    // be triggered, and must before `mousedown` triggered.\n\n    domHandlers.mousemove.call(this, event);\n    domHandlers.mousedown.call(this, event);\n    setTouchTimer(this);\n  },\n\n  /**\n   * Touch移动响应函数\n   * @inner\n   * @param {Event} event\n   */\n  touchmove: function (event) {\n    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n    // mouse event in upper applicatoin.\n\n    event.zrByTouch = true;\n    processGesture(this, event, 'change'); // Mouse move should always be triggered no matter whether\n    // there is gestrue event, because mouse move and pinch may\n    // be used at the same time.\n\n    domHandlers.mousemove.call(this, event);\n    setTouchTimer(this);\n  },\n\n  /**\n   * Touch结束响应函数\n   * @inner\n   * @param {Event} event\n   */\n  touchend: function (event) {\n    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n    // mouse event in upper applicatoin.\n\n    event.zrByTouch = true;\n    processGesture(this, event, 'end');\n    domHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n    // we can conveniently implement \"hover style\" in both PC and touch device just\n    // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n    // to remove \"hover style\" on an element, without any additional code for\n    // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n    // style\" will remain for user view)\n    // click event should always be triggered no matter whether\n    // there is gestrue event. System click can not be prevented.\n\n    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n      domHandlers.click.call(this, event);\n    }\n\n    setTouchTimer(this);\n  },\n  pointerdown: function (event) {\n    domHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {\n    //     this._msGesture.addPointer(event.pointerId);\n    // }\n  },\n  pointermove: function (event) {\n    // FIXME\n    // pointermove is so sensitive that it always triggered when\n    // tap(click) on touch screen, which affect some judgement in\n    // upper application. So, we dont support mousemove on MS touch\n    // device yet.\n    if (!isPointerFromTouch(event)) {\n      domHandlers.mousemove.call(this, event);\n    }\n  },\n  pointerup: function (event) {\n    domHandlers.mouseup.call(this, event);\n  },\n  pointerout: function (event) {\n    // pointerout will be triggered when tap on touch screen\n    // (IE11+/Edge on MS Surface) after click event triggered,\n    // which is inconsistent with the mousout behavior we defined\n    // in touchend. So we unify them.\n    // (check domHandlers.touchend for detailed explanation)\n    if (!isPointerFromTouch(event)) {\n      domHandlers.mouseout.call(this, event);\n    }\n  }\n};\n\nfunction isPointerFromTouch(event) {\n  var pointerType = event.pointerType;\n  return pointerType === 'pen' || pointerType === 'touch';\n} // function useMSGuesture(handlerProxy, event) {\n//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n// }\n// Common handlers\n\n\nzrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  domHandlers[name] = function (event) {\n    event = normalizeEvent(this.dom, event);\n    this.trigger(name, event);\n  };\n});\n/**\n * 为控制类实例初始化dom 事件处理函数\n *\n * @inner\n * @param {module:zrender/Handler} instance 控制类实例\n */\n\nfunction initDomHandler(instance) {\n  zrUtil.each(touchHandlerNames, function (name) {\n    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n  });\n  zrUtil.each(pointerHandlerNames, function (name) {\n    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n  });\n  zrUtil.each(mouseHandlerNames, function (name) {\n    instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n  });\n\n  function makeMouseHandler(fn, instance) {\n    return function () {\n      if (instance._touching) {\n        return;\n      }\n\n      return fn.apply(instance, arguments);\n    };\n  }\n}\n\nfunction HandlerDomProxy(dom) {\n  Eventful.call(this);\n  this.dom = dom;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._touching = false;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._touchTimer;\n  /**\n   * @private\n   * @type {module:zrender/core/GestureMgr}\n   */\n\n  this._gestureMgr = new GestureMgr();\n  this._handlers = {};\n  initDomHandler(this);\n\n  if (env.pointerEventsSupported) {\n    // Only IE11+/Edge\n    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n    // at the same time.\n    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n    // screen, which do not occurs in pointer event.\n    // So we use pointer event to both detect touch gesture and mouse behavior.\n    mountHandlers(pointerHandlerNames, this); // FIXME\n    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n    // which does not prevent defuault behavior occasionally (which may cause view port\n    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n    // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n    // touch screen. And we only support click behavior on MS touch screen now.\n    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n    // We dont support touch on IE on win7.\n    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n    // if (typeof MSGesture === 'function') {\n    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n    //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n    // }\n  } else {\n    if (env.touchEventsSupported) {\n      mountHandlers(touchHandlerNames, this); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n      // addEventListener(root, 'mouseout', this._mouseoutHandler);\n    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n    // mouse event can not be handle in those devices.\n    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n    // mouseevent after touch event triggered, see `setTouchTimer`.\n\n\n    mountHandlers(mouseHandlerNames, this);\n  }\n\n  function mountHandlers(handlerNames, instance) {\n    zrUtil.each(handlerNames, function (name) {\n      addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n    }, instance);\n  }\n}\n\nvar handlerDomProxyProto = HandlerDomProxy.prototype;\n\nhandlerDomProxyProto.dispose = function () {\n  var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n  for (var i = 0; i < handlerNames.length; i++) {\n    var name = handlerNames[i];\n    removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n  }\n};\n\nhandlerDomProxyProto.setCursor = function (cursorStyle) {\n  this.dom.style.cursor = cursorStyle || 'default';\n};\n\nzrUtil.mixin(HandlerDomProxy, Eventful);\nvar _default = HandlerDomProxy;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/dom/HandlerProxy.js\n// module id = 76\n// module chunks = 0","var eventUtil = require(\"./event\");\n\n/**\n * Only implements needed gestures for mobile.\n */\nvar GestureMgr = function () {\n  /**\n   * @private\n   * @type {Array.<Object>}\n   */\n  this._track = [];\n};\n\nGestureMgr.prototype = {\n  constructor: GestureMgr,\n  recognize: function (event, target, root) {\n    this._doTrack(event, target, root);\n\n    return this._recognize(event);\n  },\n  clear: function () {\n    this._track.length = 0;\n    return this;\n  },\n  _doTrack: function (event, target, root) {\n    var touches = event.touches;\n\n    if (!touches) {\n      return;\n    }\n\n    var trackItem = {\n      points: [],\n      touches: [],\n      target: target,\n      event: event\n    };\n\n    for (var i = 0, len = touches.length; i < len; i++) {\n      var touch = touches[i];\n      var pos = eventUtil.clientToLocal(root, touch, {});\n      trackItem.points.push([pos.zrX, pos.zrY]);\n      trackItem.touches.push(touch);\n    }\n\n    this._track.push(trackItem);\n  },\n  _recognize: function (event) {\n    for (var eventName in recognizers) {\n      if (recognizers.hasOwnProperty(eventName)) {\n        var gestureInfo = recognizers[eventName](this._track, event);\n\n        if (gestureInfo) {\n          return gestureInfo;\n        }\n      }\n    }\n  }\n};\n\nfunction dist(pointPair) {\n  var dx = pointPair[1][0] - pointPair[0][0];\n  var dy = pointPair[1][1] - pointPair[0][1];\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction center(pointPair) {\n  return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];\n}\n\nvar recognizers = {\n  pinch: function (track, event) {\n    var trackLen = track.length;\n\n    if (!trackLen) {\n      return;\n    }\n\n    var pinchEnd = (track[trackLen - 1] || {}).points;\n    var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {\n      var pinchScale = dist(pinchEnd) / dist(pinchPre);\n      !isFinite(pinchScale) && (pinchScale = 1);\n      event.pinchScale = pinchScale;\n      var pinchCenter = center(pinchEnd);\n      event.pinchX = pinchCenter[0];\n      event.pinchY = pinchCenter[1];\n      return {\n        type: 'pinch',\n        target: track[0].target,\n        event: event\n      };\n    }\n  } // Only pinch currently.\n\n};\nvar _default = GestureMgr;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/GestureMgr.js\n// module id = 77\n// module chunks = 0","/**\r\n * 选中节点后，出现的操作框及按钮\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var Node = require(\"../Node\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../graphic.js\");\r\n    var Connector = require(\"../shapes/Connector.js\");\r\n    var env = require('zrender/lib/core/env');\r\n    var icon = require('./IconOperation');\r\n    var symbolUtil = require('../shapes/Symbol');\r\n    function OperationNode(node, zr, api,forbidEdit) {\r\n        Node.call(this);\r\n        this.node = node;\r\n        this.zr = zr;\r\n        this.forbidEdit = forbidEdit;\r\n        this._api = api;\r\n        this.render();\r\n    }\r\n\r\n    //事件\r\n    OperationNode.ARROW_DRAGEND = \"OperationNode:dragendArrow\";\r\n    OperationNode.ARROW_DRAG = \"OperationNode:dragArrow\";\r\n    OperationNode.ARROW_DRAGSTART = \"OperationNode:dragstartArrow\";\r\n    OperationNode.DELETE_CLICK = \"OperationNode:deleteClick\";\r\n    OperationNode.DEL = \"DEL\";\r\n    OperationNode.COMMENT_CLICK = \"OperationNode:commentClick\";\r\n    OperationNode.COMMENT = \"COMMENT\";\r\n        //内置操作图标的图像\r\n    OperationNode.opicons = {\r\n        STRAIGHT: icon.STRAIGHT_SVG,\r\n        JAGGED: icon.JAGGED_SVG,\r\n        CURVE: icon.CURVE_SVG,\r\n        DEL: icon.DEL_SVG,\r\n        COMMENT: icon.COMMENT_SVG\r\n    };\r\n\r\n    OperationNode.prototype.render = function() {\r\n        this.renderBase();\r\n        if (!this.forbidEdit) {\r\n            this.renderOther();\r\n        }\r\n    };\r\n\r\n    OperationNode.prototype.renderBase = function() {\r\n        this.createOperation();\r\n    };\r\n\r\n    OperationNode.prototype.createOperation = function() {\r\n        var me = this;\r\n        if (!this.node.selectStyle) {\r\n            this.virtualRect = new graphic.Polyline({ style: { lineDash: [2] } });\r\n            this.virtualRect.isSelfComputePos = true;  // 自己计算位置\r\n            this.add(this.virtualRect);\r\n        } else {\r\n             if (this.node.type === 'ZPath') {  //addHover需要从它自身的构造函数中创建。1.Painter中addHover源码是根据shape与style创建 2.path中的构造函数是返回另一个元素\r\n                this.node._zCloneStyle = this.node.style.clone();\r\n                 this.node.setStyle(this.node.selectStyle); \r\n             } else if(this.node.setOrCancelSelectStyle) {\r\n                this.node.setOrCancelSelectStyle(true);\r\n             } else {\r\n                this._api.getZr().addHover(this.node, this.node.selectStyle);\r\n             }\r\n            \r\n        }\r\n\r\n        if (this.node.operationIcons) {\r\n            zrUtil.each(this.node.operationIcons, function(item) {\r\n                //检查是否是内置图标\r\n                var opIconInstance = null;\r\n                var operationIcon = OperationNode.opicons[item.name.toUpperCase() + \"\"]\r\n                if (operationIcon) {\r\n\r\n                    if (this.forbidEdit) {\r\n                        return;\r\n                    }\r\n                    if (item.hidden) {\r\n                        return;\r\n                    }\r\n                    if (item.name == OperationNode.DEL) {\r\n                        //垃圾桶\r\n                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' },z:me.node.z+1,rectHover: true }, { x: 0, y: 0, width: 10, height: 15 });\r\n\r\n                        if(item.callback){\r\n                            opIconInstance.on(\"click\", function(e) {\r\n                                e.data = item;\r\n                                e.node = me.node;  // 将所附的节点也传递出去\r\n                                if (item.callback) {\r\n                                    item.callback(e);\r\n                                }\r\n                            });\r\n                        }else{\r\n                            opIconInstance.on(\"click\", function(e) {\r\n                                var params = {};\r\n                                params.event = e;\r\n                                params.target = this;\r\n                                params.type = OperationNode.DELETE_CLICK;\r\n                                me.trigger(params.type, params);\r\n                            });\r\n                        }\r\n                    } else if (item.name == OperationNode.COMMENT) {\r\n                        var rect = { x: 0, y: 0, width: 16, height: 16 };\r\n                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' }, z:me.node.z+2, rectHover: true }, rect);\r\n                        opIconInstance.on(\"click\", function(e) {\r\n                            var params = {};\r\n                            params.event = e;\r\n                            params.target = this;\r\n                            params.type = OperationNode.COMMENT_CLICK;\r\n                            me.trigger(params.type, params);\r\n                        });\r\n                    } else {\r\n                        var rectOther = { x: 0, y: 0, width: 15, height: 15 };\r\n                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' },draggable:true,z:me.node.z+2,lineType: Connector[\"TYPE_\" + item.name.toUpperCase()],rectHover: true }, rectOther);\r\n                        var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];\r\n                        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n                            opIconInstance.on(eveName, function(e) {\r\n                                var params = {};\r\n                                params.event = e;\r\n                                params.data = item.options\r\n                                params.type = \"OperationNode:\" + eveName + \"Arrow\";\r\n                                me.trigger(params.type, params);\r\n                            });\r\n                        });\r\n                    }\r\n\r\n                } else {\r\n                    opIconInstance = symbolUtil.createSymbol(item.iconPath, 0, 0, item.width || 15, item.height || 15, me.node.z+1, item.color||'#000');\r\n                    opIconInstance.on(\"click\", function(e) {\r\n                        e.data = item;\r\n                        e.node = me.node;  // 将所附的节点也传递出去\r\n                        if (item.callback) {\r\n                            item.callback(e);\r\n                        }\r\n                        var param = {event:e, type:\"OperationNode:\" + item.name + \"Click\"};\r\n                        me._api.trigger(param.type, param);\r\n                    });\r\n                }\r\n                opIconInstance.name = item.name;\r\n                me.add(opIconInstance);\r\n            });\r\n        }\r\n    };\r\n\r\n    OperationNode.prototype.refreshPostion = function(node,nodeRect) {\r\n        var i = 0;\r\n        var rbPoint = nodeRect.points[2]; //取右下角坐标\r\n        //1.定位虚框\r\n        this.virtualRect && this.virtualRect.setShape({ points: nodeRect.points });\r\n        //2.定位每个小图标\r\n        this.eachChild(function(nodeItem) {\r\n            if (!nodeItem.isSelfComputePos) {\r\n                // 8px是第一个操作按钮图标的距离 靠太近不好看    20px是每个图标的间隔  10px是图标向偏的距离\r\n                nodeItem.attr(\"position\", [rbPoint[0] + 8 + (i++ * 20), rbPoint[1] - 10]);\r\n            }\r\n        });\r\n\r\n        this.refreshPositionOther(node,nodeRect);\r\n    };\r\n\r\n    OperationNode.prototype.renderOther = function() {\r\n        //留给扩展使用\r\n    };\r\n    OperationNode.prototype.refreshPositionOther = function(node,nodeRect) {\r\n        //留给扩展使用\r\n        //3.定位整个operationNode\r\n        if ((node.parent && node.parent.isBg && node.parent.isBg == true) || (node.parent.type === \"GroupNode\")) {\r\n            this.attr(\"position\", [nodeRect.x, nodeRect.y])\r\n        } else {\r\n            var nodeShapeX = node.shape? node.shape.x:0;\r\n            var nodeSahpeY = node.shape? node.shape.y:0;\r\n            this.attr(\"position\", [nodeRect.x + node.parent.position[0]+nodeShapeX, nodeRect.y + node.parent.position[1]+nodeSahpeY])\r\n        }\r\n    };\r\n\r\n    OperationNode.prototype.cleanup = function() {\r\n        if(this.node.selectStyle) {\r\n            if (this.node.type === 'ZPath') {\r\n                this.node.setStyle(this.node._zCloneStyle);\r\n            } else if(this.node.setOrCancelSelectStyle) {\r\n                this.node.setOrCancelSelectStyle(false);\r\n             } else {\r\n                this._api.getZr().removeHover(this.node);\r\n            }\r\n            \r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(OperationNode, Node);\r\n    module.exports = OperationNode;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/manager/OperationNode.js\n// module id = 78\n// module chunks = 0","\r\n    var graphic = require('./graphic');\r\n    var util = require(\"./util.js\")\r\n    //创建Node类 所有形状都继承Node  包括fromJSON toJSON\r\n    function Node() {\r\n        this.resourceId = util.getUUID(); // 生成节点ID\r\n        graphic.Group.call(this);\r\n    }\r\n\r\n    /**\r\n     * 由父类实现\r\n     * @return {[type]} [description]\r\n     */\r\n    Node.prototype.render = function() {};\r\n\r\n    /**\r\n     * 由父类实现\r\n     * @param  {[type]} json [description]\r\n     * @return {[type]}      [description]\r\n     */\r\n    Node.prototype.getRect = function(json) {};\r\n\r\n    /**\r\n     * drawText\r\n     * @description 画一个文本\r\n     * @param {string} name\r\n     * @param {string} color\r\n     */\r\n    Node.prototype.drawText = function(name, color, position) {\r\n        var textName = this.bpmnInfo.name, x, y;\r\n        if(name != null){\r\n            textName = name;\r\n        }\r\n        var text = new graphic.Text({\r\n            style: {\r\n                text: textName,\r\n                color: color ? color : this.options.text.color,\r\n                textFont: '12px Microsoft YaHei'\r\n            },\r\n            zlevel: 20\r\n        });\r\n        //文字绘制的位置 \r\n        position = position ? position : 'init';\r\n        switch (position) {\r\n            //节点下方居中位置\r\n            case 'init': \r\n                //x = 中心点.x - 起始位置.x - 文字宽度的一半\r\n                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n                //y = 中心点.y - 起始位置.y + 偏移值（6）\r\n                y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + 6;\r\n                break;\r\n            //节点内部居中位置\r\n            case 'center':\r\n                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n                y = this.getRect().y - this.position[1] - 6;\r\n                break;\r\n            //节点内部居左位置\r\n            case 'left': \r\n                x = this.getRect().x - this.position[0] - text.getBoundingRect().width + 6;\r\n                y = this.getRect().y - this.position[1] - 6;\r\n                break;\r\n            default: break;\r\n        }\r\n        text.attr(\"style\", { x: x, y: y });\r\n        return {\r\n            text: text,\r\n            rect: text.getBoundingRect()\r\n        };\r\n    };\r\n    /**\r\n     * refreshText\r\n     * @description 刷新文本\r\n     */\r\n    Node.prototype.refreshText = function(pos) {\r\n        var text = this.childOfName(\"Title\"), x, y;\r\n        pos = pos ? pos : 'init';\r\n        switch (pos) {\r\n            case 'init': \r\n                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n                y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + 6;\r\n                break;\r\n            case 'center':\r\n                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n                y = this.getRect().y - this.position[1] - 6;\r\n                break;\r\n            case 'left':\r\n                x = 2;\r\n                y = this.getRect().y - this.position[1] - 6;\r\n                break;\r\n            default: break;\r\n        }\r\n        text.attr(\"style\", { x: x, y: y });\r\n    };\r\n    /**\r\n     * 由父类实现\r\n     * @return {[type]} [description]\r\n     */\r\n    Node.prototype.toJSON = function() {};\r\n\r\n    graphic.Util.inherits(Node, graphic.Group);\r\n    module.exports = Node;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/Node.js\n// module id = 79\n// module chunks = 0","/**\r\n * 连接线\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var Util = require(\"../util.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var vec2 = require('zrender/lib/core/vector');\r\n    var graphic = require(\"../graphic.js\");\r\n    var Node = require(\"../Node.js\");\r\n    var symbolUtil = require(\"./Symbol.js\");\r\n    var Handle = require(\"./Handle.js\");\r\n    var EffectLine = require(\"./EffectLine.js\");\r\n    var ConnectionPoint = require(\"./ConnectionPoint.js\");\r\n    var Point = require(\"../Point.js\");\r\n    var Model = require(\"../model.js\");\r\n\r\n    Connector.TYPE_STRAIGHT = 'straight';\r\n    Connector.TYPE_JAGGED = 'jagged';\r\n    Connector.TYPE_CURVE = 'curve';\r\n    Connector.TYPE_CHAIN = 'chain';\r\n    Connector.RADIUS = 3;\r\n    Connector.START_NODE = \"startNode\";\r\n    Connector.END_NODE = \"endNode\";\r\n    Connector.LEFT = \"left\";\r\n    Connector.RIGHT = \"right\";\r\n    Connector.TOP = \"top\";\r\n    Connector.BOTTOM = \"bottom\";\r\n    Connector.BOTTOM = \"bottom\";\r\n    Connector.SEPERATOR = \"-\";\r\n    Connector.NORMAL_COLOR = \"#000\";\r\n    Connector.SELECTED_COLOR = '#74B7E0';\r\n    /**\r\n     * 构造函数\r\n     * @param {[type]} options [description]\r\n     */\r\n    function Connector(options) {\r\n        Node.call(this);\r\n        this.opt = options || {};\r\n        if (this.opt.model) {\r\n            this.resourceId = this.opt.model.get(\"resourceId\");\r\n            this.model = this.opt.model;\r\n            this.opt = this.opt.model.option;\r\n        } else {\r\n            this.resourceId = Util.getUUID(); // 生成节点ID\r\n            this.model = new Model({});\r\n        }\r\n        var defaultOptions = {\r\n            symbol: { type: \"arrow\", size: 10, color: Connector.NORMAL_COLOR, both:false, offset:0 }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n            style: { lineWidth: 1, stroke: Connector.NORMAL_COLOR, lineType: Connector.TYPE_STRAIGHT }, //样式\r\n            hoverStyle: { lineWidth: 2, stroke: Connector.SELECTED_COLOR }, //移上去的样式\r\n            arrowHoverStyle: { fill: Connector.SELECTED_COLOR},\r\n            shape: { points: null, smooth: false, smoothConstraint: null }, //形状\r\n            position: { startPos:null, endPos:null,  //指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n                        startOffset:[0,0],  // 起始线段离节点的偏移\r\n                        endOffset:[0,0],    // 终止线段离节点的偏移\r\n                        escapeDistance:[30,30], // 第一条折线的长度，最后一条折线的长度\r\n                        points:null    //不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n                    },\r\n            autoChangePosition: false,\r\n            textContextMenu: null,\r\n            isEdit: true, //是否可编辑\r\n            text: {\r\n                text: null,\r\n                textFill: '#000000', // 文本颜色\r\n                textFont: '12px Microsoft YaHei',\r\n                textPos: 'center',\r\n                textRotateable: true\r\n            },\r\n            z: 0\r\n        }\r\n\r\n        this.options = Util.mergeOpt(defaultOptions, this.opt, true, 'textContextMenu');\r\n        this.handles = [];\r\n        this.conPointsGroup = new graphic.Group();\r\n        this.startNode = null;\r\n        this.endNode = null;\r\n        this.line = null;\r\n        this.groupCurve = new graphic.Group();\r\n        this.icons = []; // 用于存储线段上面的操作图标\r\n        this.render();\r\n    }\r\n\r\n\r\n    /**\r\n     * 重新画线，如果传空则根据turningPoints 重新画线\r\n     * @param  {[type]} points [description]\r\n     * @return {[type]}        [description]\r\n     */\r\n    Connector.prototype.refresh = function(arrPoints) {\r\n        if (arrPoints) {\r\n            this.turningPoints = arrPoints;\r\n        }\r\n        //将[x:0,y:0]转化为[0, 0]  给zrender使用\r\n        var points = Util.traslatePoints(this.turningPoints);\r\n\r\n        if ((this.options.style.lineType == Connector.TYPE_CURVE) && (points.length > 2)) {\r\n            this.modifyCurve(this.turningPoints);\r\n        } else {\r\n            this.line.attr('shape', { points: points });\r\n        }\r\n\r\n        var lineText = this.childOfName('lineText');\r\n        var self = this, lineTextArr = [];\r\n        if (this.options.style.lineType == Connector.TYPE_CHAIN && zrUtil.isArray(this.options.text.text)) {\r\n            this.options.text.text.forEach(function (v, i) {\r\n                lineTextArr.push(self.childOfName('lineText-'+i));\r\n            });\r\n        } else if (!lineText && this.options.text.text) {\r\n            var text = this.drawText(\"lineText\", this.options.text.text, 0, 0);\r\n            this.add(text.text);\r\n            lineText = this.childOfName('lineText');\r\n        }\r\n        if (lineTextArr.length > 0) {\r\n            var cnt = lineTextArr.length,\r\n                distance = this.turningPoints[1].x - this.turningPoints[0].x,\r\n                gap = parseInt(distance/cnt),\r\n                pos = -(gap) * parseInt(cnt/2);\r\n\r\n            lineTextArr.forEach(function (v, i) {\r\n                var textPoint = self.getTextPostion(self.options.text), way = '';\r\n\r\n                var rate = self.getTextRotation(textPoint);\r\n                if (rate === -0 || rate === 0) {\r\n                    rate = 0;\r\n                } else {\r\n                    way = rate > 0 ? 'plus' : 'minus';\r\n                }\r\n                rate = Math.abs(rate);\r\n                var deg = (180*rate)/Math.PI;\r\n                var rotation = null, length = null;\r\n                v.setStyle(\"text\", zrUtil.isString(self.options.text.text[i]) ? self.options.text.text[i] : self.options.text.text[i].text);\r\n\r\n                if (way) {\r\n                    rotation = deg > 90 ? ((deg-45)*Math.PI)/180 : ((45+deg)*Math.PI)/180;\r\n                    rotation = way === 'minus' ? -(rotation) : rotation;\r\n                } else {\r\n                    rotation = (45*Math.PI)/180\r\n                }\r\n                v.attr('rotation', rotation);\r\n\r\n                if (deg === 90) {\r\n                    textPoint[1] -= pos;\r\n                } else {\r\n                    textPoint[0] += pos;\r\n                    if (rate !== 0) {\r\n                        length = Math.tan(deg*Math.PI/180)*pos;\r\n                        if (pos > 0) {\r\n                            textPoint[1] -= way === 'plus' ? length : -(length);\r\n                        } else {\r\n                            textPoint[1] += way === 'plus' ? -(length) : (length);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                v.attr(\"position\", textPoint);\r\n                pos += gap;\r\n            });\r\n        }\r\n        if (lineText) {\r\n            lineText.setStyle(\"text\", this.options.text.text);\r\n            var textPoint = this.getTextPostion(this.options.text);\r\n            if (this.options.style.lineType == Connector.TYPE_STRAIGHT && this.options.text.textRotateable) { //#187\r\n                lineText.attr('rotation', this.getTextRotation(textPoint));\r\n            }\r\n            lineText.attr(\"position\", textPoint);\r\n        }\r\n        this.refreshFromToSymbol(points);\r\n    };\r\n    /**\r\n     * 渲染\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.render = function() {\r\n        var that = this;\r\n        //1.创建箭头\r\n        this.renderFromToSymbol();\r\n\r\n        //2.创建线\r\n        this.curveLine = new graphic.BezierCurve({\r\n            //position: this.options.position,\r\n            style: this.options.style,\r\n            z: this.options.z\r\n        });\r\n        this.groupCurve.add(this.curveLine);\r\n        this.add(this.groupCurve);\r\n        this.add(this.conPointsGroup);\r\n\r\n        this.polyLine = new graphic.Polyline({\r\n            //position: this.options.position,\r\n            shape: this.options.shape,\r\n            style: this.options.style,\r\n            z: this.options.z\r\n        });\r\n        this.add(this.polyLine);\r\n\r\n        if ((this.options.style.lineType == Connector.TYPE_CURVE)) {\r\n            this.line = this.groupCurve;\r\n            this.createHoverStyle(this.curveLine);\r\n            this.polyLine.hide();\r\n        } else {\r\n            this.line = this.polyLine;\r\n            this.createHoverStyle(this.polyLine);\r\n            this.curveLine.hide();\r\n        }\r\n\r\n        //3.侦听线事件\r\n        var MOUSE_EVENT_NAMES = ['dblclick', 'click']; //'click', 'dblclick', 'mouseover', 'mouseout'\r\n        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n            this.line.on(eveName, zrUtil.bind(function(e) {\r\n                e.cancelBubble = true;\r\n                var params = {};\r\n                params.event = e;\r\n                params.type = \"Connector:\" + eveName;\r\n                params.target = that;\r\n                this.trigger(params.type, params);\r\n                this.setStyle({color:Connector.SELECTED_COLOR},true);\r\n                if (this.options.isEdit == false) {\r\n                    return; }\r\n\r\n                if (this.options.isEdit && this.turningPoints.length >= 2) {\r\n                    this.createAllconnectionPoint()\r\n                }\r\n                if (this.handles.length < 1) {\r\n                    this.shapeSetHandle();\r\n                }\r\n\r\n            }, this));\r\n        }, this);\r\n\r\n        //4.创建线上文本\r\n        if (this.options.text.text) {\r\n            var text = null;\r\n            if (zrUtil.isArray(this.options.text.text) && this.options.style.lineType == Connector.TYPE_CHAIN) {\r\n                this.options.text.text.forEach(function (v, i) {\r\n                    var content = that.drawText(\"lineText-\"+i, v, 0, 0);\r\n                    if (zrUtil.isString(v)) {\r\n                        var obj = {};\r\n                        obj.text = v;\r\n                        obj.textId = content.text.id;\r\n                        that.options.text.text[i] = obj;\r\n                    } else {\r\n                        that.options.text.text[i].textId = content.text.id;\r\n                    }\r\n                    that.add(content.text);\r\n                    if(content && that.opt.textContextMenu) {\r\n                        var textContextMenu = that.opt.textContextMenu;\r\n                        content.text.on(\"contextmenu\",function(e) {\r\n                            e.event.preventDefault();\r\n                            e.event.stopPropagation();\r\n                            textContextMenu.buildMenu(e.event,this);\r\n                        })\r\n                    }\r\n                });\r\n            } else {\r\n                text = this.drawText(\"lineText\", this.options.text.text, 0, 0);\r\n                this.add(text.text);\r\n            }\r\n            if(text && this.opt.textContextMenu) {\r\n                var textContextMenu = this.opt.textContextMenu;\r\n                text.text.on(\"contextmenu\",function(e) {\r\n                    e.event.preventDefault();\r\n                    e.event.stopPropagation();\r\n                    textContextMenu.buildMenu(e.event,this);\r\n                })\r\n            }\r\n        }\r\n    };\r\n\r\n    Connector.prototype.renderFromToSymbol = function(options) {\r\n        var symbolTo = this.createSymbol('toSymbol', this.options); //arrow,triangle\r\n        if (symbolTo) {\r\n            this.add(symbolTo);\r\n        }\r\n        //如果双向箭头 则再创建首箭头\r\n        if (this.options.symbol.both) {\r\n            var symbolFrom = this.createSymbol('fromSymbol', this.options); //arrow,triangle\r\n            if (symbolFrom) {\r\n                this.add(symbolFrom);\r\n            }\r\n        }\r\n    }\r\n\r\n    Connector.prototype.refreshFromToSymbol = function(points) {\r\n        var symbolTo = this.childOfName('toSymbol');\r\n        var symbolFrom = this.childOfName('fromSymbol');\r\n        var position = [], offset = this.options.symbol.offset;\r\n        if (symbolTo) {\r\n            if (this.options.effect && this.options.effect.show) {\r\n                new EffectLine(symbolTo, this.options, this.groupCurve, this.polyLine);\r\n            } else {\r\n                position = points[points.length - 1];\r\n                if (this.options.style.lineType !== Connector.TYPE_CURVE) {\r\n                    var distance = vec2.distance(points[points.length - 1], points[points.length - 2]);\r\n                    if (offset <= distance) {\r\n                        position = vec2.lerp(\r\n                            [], points[points.length - 1], points[points.length - 2],\r\n                            offset / distance);\r\n                    } else {\r\n                        position = points[points.length - 1];\r\n                    }\r\n                }\r\n                symbolTo.attr('position', position);\r\n                symbolTo.attr('rotation', Util.tangentRotation(this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]));\r\n            }\r\n        }\r\n\r\n        if (symbolFrom) {\r\n            position = points[0];\r\n            if (this.options.style.lineType !== Connector.TYPE_CURVE) {\r\n                var distanceFrom = vec2.distance(points[0], points[1]);\r\n                if (offset <= distanceFrom) {\r\n                    position = vec2.lerp(\r\n                        [], points[0], points[1],\r\n                        offset / distanceFrom);\r\n                } else {\r\n                    position = points[0];\r\n                }\r\n            }\r\n            symbolFrom.attr('position', position);\r\n            symbolFrom.attr('rotation', Util.tangentRotation(this.turningPoints[1], this.turningPoints[0]));\r\n        }\r\n    }\r\n    /**\r\n     * 设置style\r\n     * @param {object} options 样式对象\r\n     * @param {boolean} notSaveModel 设置样式是否保存到模型中,默认是false\r\n     */\r\n    Connector.prototype.setStyle = function(options,notSaveModel) {\r\n        var symbolTo = null;\r\n        if (options.color) {\r\n            if (this.options.style.lineType == Connector.TYPE_CURVE) {\r\n                this.groupCurve.eachChild(function(curve) {\r\n                    curve.attr(\"style\", { stroke: options.color });\r\n                    graphic.setNormalStyle(curve, { stroke: options.color });\r\n                });\r\n            } else {\r\n                this.polyLine.attr(\"style\", { stroke: options.color });\r\n                graphic.setNormalStyle(this.polyLine, { stroke: options.color });\r\n            }\r\n            symbolTo = this.childOfName('toSymbol');\r\n            if (symbolTo) {\r\n                symbolTo.attr(\"style\", { fill: options.color });\r\n                graphic.setNormalStyle(symbolTo, { fill: options.color });\r\n            }\r\n            if(!notSaveModel) {\r\n                this.options.style.stroke = options.color;\r\n                this.model.set(\"options.style.stroke\", options.color);\r\n                this.model.set(\"options.symbol.color\", options.color);\r\n                this.options.symbol.color = options.color;\r\n            }\r\n        }\r\n\r\n        if (options.text) {\r\n            var lineText = this.childOfName('lineText');\r\n            //开始没有创建文本，后来传进来text了，需要先创建文本\r\n            if (!lineText && options.text.text) {\r\n                var text = this.drawText(\"lineText\", options.text.text, 0, 0);\r\n                this.add(text.text);\r\n                lineText = this.childOfName('lineText');\r\n            }\r\n\r\n            if (options.text.text || options.text.text == \"\") {\r\n                lineText.setStyle(\"text\", options.text.text);\r\n                this.options.text.text = options.text.text;\r\n            }\r\n            var textPoint = this.getTextPostion(options.text);\r\n            lineText.attr(\"position\", textPoint);\r\n            if (options.text.textPos) {\r\n                this.options.text.textPos = options.text.textPos;\r\n            }\r\n            if (options.text.offset) { //#187\r\n                this.options.text.offset = options.text.offset;\r\n            }\r\n\r\n            if (options.text.textFill) {\r\n                lineText.attr(\"style\", {\r\n                    textFill: options.text.textFill\r\n                });\r\n                this.options.text.textFill = options.text.textFill;\r\n            }\r\n            this.model.set(\"options.text\", options.text);\r\n        }\r\n\r\n        if (options.symbol) {\r\n            if (options.symbol.type) {\r\n                this.options.symbol.type = options.symbol.type;\r\n                this.model.set(\"options.symbol.type\", options.symbol.type);\r\n            }\r\n            if (options.symbol.size) {\r\n                this.options.symbol.size = options.symbol.size;\r\n                this.model.set(\"options.symbol.size\", options.symbol.size);\r\n            }\r\n            if (options.symbol.color) {\r\n                this.options.symbol.color = options.symbol.color;\r\n                this.model.set(\"options.symbol.color\", options.symbol.color);\r\n            }\r\n            if (options.symbol.z) {\r\n                this.options.symbol.z = options.symbol.z;\r\n                this.model.set(\"options.symbol.z\", options.symbol.z);\r\n            }\r\n\r\n            symbolTo = this.childOfName('toSymbol');\r\n            if (symbolTo) {\r\n                this.remove(symbolTo);\r\n            }\r\n            var symbol = this.createSymbol(\"toSymbol\", this.model.get(\"options\"))\r\n            if (symbol) {\r\n                this.add(symbol);\r\n            }\r\n            this.refresh();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 获取线段的位置\r\n     * @param  {Object} text {text:'', color:'', textPos:''}\r\n     * @return {Object}      {x,y}\r\n     */\r\n    Connector.prototype.getTextPostion = function(text) {\r\n        var textPostion = [];\r\n        var textWidth = graphic.textContain.getWidth(text.text, text.textFont);\r\n        if (text && text.textPos) {\r\n            var offset = text.offset || 0;\r\n            var arrOffset = offset;\r\n            if (!zrUtil.isArray(offset)) {\r\n                arrOffset = [offset, 0];\r\n            }\r\n            if (text.textPos == 'start') {\r\n                textPostion = [this.turningPoints[0].x + arrOffset[0], this.turningPoints[0].y + arrOffset[1]];\r\n            } else if (text.textPos == 'end') {\r\n                var points = Util.getMaxLineLength([this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]]);\r\n                var angle = Util.getAngle(points[0], points[1]);\r\n                var length = Util.distance(points[0], points[1]) - textWidth;\r\n                var newPoint = Util.getEndPoint(points[0], length, angle);\r\n                textPostion = [newPoint.x + arrOffset[0], newPoint.y + arrOffset[1]];\r\n            } else {\r\n                var midPoint = this.middle(text);\r\n                textPostion = [midPoint[0] + arrOffset[0], midPoint[1] + arrOffset[1]];\r\n            }\r\n        } else {\r\n            var position = this.middle(text);\r\n            textPostion = [position[0] - textWidth / 2, position[1]];\r\n        }\r\n\r\n        return textPostion;\r\n    };\r\n\r\n    /**\r\n     * 获取线段的旋转角度\r\n     * @param  {Object} textPostion {x,y}\r\n     * @return {Number}             角度值\r\n     */\r\n    Connector.prototype.getTextRotation = function(textPostion) {\r\n        //计算出极坐标的角度\r\n        var points = Util.getMaxLineLength(this.turningPoints);\r\n        var angle = -Math.atan2(points[1].y - textPostion[1], points[1].x - textPostion[0]); //,Math.PI/2\r\n        return angle;\r\n    };\r\n\r\n    Connector.prototype.createHoverStyle = function(el) {\r\n        if (this.options.hoverStyle) {\r\n            graphic.setElementHoverStl(el, this.options.hoverStyle);\r\n\r\n            var symbolTo = this.childOfName('toSymbol');\r\n            if (symbolTo) { graphic.setElementHoverStl(symbolTo, this.options.arrowHoverStyle); }\r\n\r\n            el.on('mouseover', zrUtil.bind(function() {\r\n                    graphic.doEnterHover(el);\r\n                    if (symbolTo) { graphic.doEnterHover(symbolTo); }\r\n\r\n                    this.groupCurve.eachChild(function(line) {\r\n                        graphic.doEnterHover(line);\r\n                    });\r\n                }, this))\r\n                .on('mouseout', zrUtil.bind(function() {\r\n                    graphic.doLeaveHover(el);\r\n                    if (symbolTo) { graphic.doLeaveHover(symbolTo); }\r\n                    this.groupCurve.eachChild(function(line) {\r\n                        graphic.doLeaveHover(line);\r\n                    });\r\n                }, this));\r\n        }\r\n    };\r\n    /**\r\n     * 创建Node的连接点\r\n     * @private\r\n     *\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.createAllconnectionPoint = function() {\r\n        this.connectionPointCreate(this, this.turningPoints[0].clone(), ConnectionPoint.TYPE_CONNECTOR);\r\n        this.connectionPointCreate(this, this.turningPoints[this.turningPoints.length - 1].clone(), ConnectionPoint.TYPE_CONNECTOR);\r\n    };\r\n\r\n    /**\r\n     * 创建连接点\r\n     * @private\r\n     * @param  {[type]} shape [description]\r\n     * @param  {[type]} point [description]\r\n     * @param  {[type]} type  [description]\r\n     * @return {[type]}       [description]\r\n     */\r\n    Connector.prototype.connectionPointCreate = function(shape, point, type) {\r\n        var conPoint = new ConnectionPoint(this, point, type, this.options);\r\n        this.conPointsGroup.add(conPoint.shape);\r\n    };\r\n\r\n    /**\r\n     * 清空控制点\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.clearHandles = function() {\r\n        for (var i = 0; i < this.handles.length; i++) {\r\n            this.remove(this.handles[i].handleShape);\r\n        }\r\n        this.handles = [];\r\n        if (this.conPointsGroup) {\r\n            this.conPointsGroup.removeAll();\r\n        }\r\n        //恢复原来的颜色\r\n        this.setStyle({color:this.options.style.stroke},true);\r\n    };\r\n\r\n    /**\r\n     * 创建拆线 线断的控制点\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.shapeSetHandle = function() {\r\n        for (var i = 1; i < this.turningPoints.length - 2; i++) {\r\n            var h;\r\n            var x, y;\r\n            //是否在一条线上\r\n            var isCollineaityFirst = Util.collinearity(this.turningPoints[i - 1], this.turningPoints[i], this.turningPoints[i + 1]);\r\n            var isCollineaitySecond = Util.collinearity(this.turningPoints[i], this.turningPoints[i + 1], this.turningPoints[i + 2]);\r\n            if ((!isCollineaityFirst && (!isCollineaitySecond || this.turningPoints[i + 1].equals(this.turningPoints[i + 2]))) || ((!isCollineaityFirst || this.turningPoints[i - 1].equals(this.turningPoints[i])) && !isCollineaitySecond)) {\r\n\r\n                if (this.turningPoints[i].x === this.turningPoints[i + 1].x) { //same vertical\r\n                    x = this.turningPoints[i].x;\r\n                    y = (this.turningPoints[i].y + this.turningPoints[i + 1].y) / 2;\r\n\r\n                    h = new Handle('h', x, y, this);\r\n\r\n\r\n                } else if (this.turningPoints[i].y === this.turningPoints[i + 1].y) { // same horizontal\r\n                    x = (this.turningPoints[i].x + this.turningPoints[i + 1].x) / 2;\r\n                    y = this.turningPoints[i].y;\r\n                    h = new Handle('v', x, y, this);\r\n                }\r\n                if (h) {\r\n                    this.add(h.handleShape);\r\n                    this.handles.push(h);\r\n                }\r\n\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * 创建箭头\r\n     * @param  {[type]} name       [description]\r\n     * @param  {[type]} options [description]\r\n     * @return {[type]}            [description]\r\n     */\r\n    Connector.prototype.createSymbol = function(name, options) {\r\n        var symbolType = options.symbol.type;\r\n        var symbolSize = options.symbol.size;\r\n        if (symbolType === 'none') {\r\n            return;\r\n        }\r\n\r\n        if (!zrUtil.isArray(symbolSize)) {\r\n            symbolSize = [symbolSize, symbolSize];\r\n        }\r\n\r\n        var symbolZIndex = options.z;\r\n\r\n        if (options.symbol.z) { symbolZIndex = options.symbol.z }\r\n\r\n        var symbolPath = symbolUtil.createSymbol(\r\n            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,\r\n            symbolSize[0], symbolSize[1], symbolZIndex, options.symbol.color\r\n        );\r\n        symbolPath.name = name;\r\n\r\n        return symbolPath;\r\n    };\r\n\r\n    /**\r\n     * 绘制线段上的文本\r\n     * @param  {[type]} content [description]\r\n     * @param  {[type]} name [description]\r\n     * @param  {[type]} x       [description]\r\n     * @param  {[type]} y       [description]\r\n     * @param  {[type]} color   [description]\r\n     * @return {[type]}         [description]\r\n     */\r\n    Connector.prototype.drawText = function(name, content, x, y, color) {\r\n        var opt = zrUtil.isString(content) ? {text:content, x:x, y:y, fill:color}\r\n                                           : zrUtil.defaults({x:x, y:y, fill:color}, content, true);\r\n\r\n        var textStyle = zrUtil.defaults(zrUtil.clone(this.options.text), opt, true);\r\n        var text = new graphic.Text({\r\n            style: textStyle,\r\n            zlevel: 20,\r\n            name : name\r\n        });\r\n        return {\r\n            text: text,\r\n            rect: text.getBoundingRect()\r\n        };\r\n    };\r\n\r\n    /**\r\n     * 获取线段的中间值\r\n     * @return {[type]} text\r\n     */\r\n    Connector.prototype.middle = function() {\r\n\r\n        if (this.options.style.lineType == Connector.TYPE_STRAIGHT || this.options.style.lineType == Connector.TYPE_CHAIN) {\r\n            var points = Util.getMaxLineLength(this.turningPoints);\r\n            //如果是求线段上的文字的中间值\r\n            // if(text) {\r\n            //     //取出字的长度，计算角度，\r\n            //     var textWidth = graphic.textContain.getWidth(text.text, text.textFont);\r\n            //     var angle = Util.getAngle(points[0],points[1]);\r\n            //     var length =  Util.distance(points[0],points[1])/2 - textWidth/2;\r\n            //     var newPoint = Util.getEndPoint(points[0], length, angle);\r\n            //     return [newPoint.x, newPoint.y];\r\n            // } else {\r\n            //     var middleX = (points[0].x + points[1].x)/2;\r\n            //     var middleY = (points[0].y + points[1].y) /2;\r\n            //     return [middleX, middleY];\r\n            // }\r\n            var middleX = (points[0].x + points[1].x) / 2;\r\n            var middleY = (points[0].y + points[1].y) / 2;\r\n            return [middleX, middleY];\r\n        } else if (this.options.style.lineType == Connector.TYPE_JAGGED) {\r\n\r\n            //find total distance\r\n            var distance = this.getLength();\r\n\r\n            //find between what turning points the half distance is\r\n            var index = -1;\r\n            var ellapsedDistance = 0;\r\n            for (var i = 0; i < this.turningPoints.length - 1; i++) {\r\n                index = i;\r\n                var segment = Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);\r\n                if (ellapsedDistance + segment < distance / 2) {\r\n                    ellapsedDistance += segment;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            //we have the middle distance somewhere between i(ndex) and i(ndex)+1\r\n            if (index != -1) {\r\n                var missingDistance = distance / 2 - ellapsedDistance;\r\n                if (Util.round(this.turningPoints[index].x, 3) == Util.round(this.turningPoints[index + 1].x, 3)) { //vertical segment (same x)\r\n                    return [this.turningPoints[index].x, Math.min(this.turningPoints[index].y, this.turningPoints[index + 1].y) + missingDistance];\r\n                } else if (Util.round(this.turningPoints[index].y, 3) == Util.round(this.turningPoints[index + 1].y, 3)) { //horizontal segment (same y)\r\n                    return [Math.min(this.turningPoints[index].x, this.turningPoints[index + 1].x) + missingDistance, this.turningPoints[index].y];\r\n                } else {\r\n                    console.error(\"Connector:middle() - this should never happen \" + this.turningPoints[index] + \" \" + this.turningPoints[index + 1] + \" nr of points \" + this.turningPoints.length);\r\n                }\r\n\r\n            }\r\n        } else if (this.options.style.lineType == Connector.TYPE_CURVE) {\r\n            var t = 0.5;\r\n            var l = this.getLength();\r\n\r\n            var walked = 0;\r\n            for (var j = 0; j < this.turningPoints.length - 1; j++) {\r\n                if (walked + Util.distance(this.turningPoints[j], this.turningPoints[j + 1]) > l * t) {\r\n                    break;\r\n                }\r\n\r\n                walked += Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);\r\n            }\r\n\r\n            var rest = l * t - walked;\r\n            var currentSegmentLength = Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);\r\n\r\n            //find the position/ration of the middle of Polyline on current segment\r\n            var segmentPercent = rest / currentSegmentLength;\r\n\r\n            var Xp = segmentPercent * (this.turningPoints[j + 1].x - this.turningPoints[j].x) + this.turningPoints[j].x;\r\n            var Yp = segmentPercent * (this.turningPoints[j + 1].y - this.turningPoints[j].y) + this.turningPoints[j].y;\r\n\r\n            return [Xp, Yp];\r\n\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * find total distance\r\n     * @return {Number} [description]\r\n     */\r\n    Connector.prototype.getLength = function() {\r\n        //find total distance\r\n        var distance = 0;\r\n        for (var i = 0; i < this.turningPoints.length - 1; i++) {\r\n            distance += Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);\r\n        }\r\n        return distance;\r\n    };\r\n\r\n    /**\r\n     * 转JSON对象 bpmn使用\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.toJSON = function() {\r\n\r\n        this.model.set(\"resourceId\", this.resourceId);\r\n        this.model.set(\"properties.type\", 14);\r\n\r\n        this.model.set(\"bounds.upperLeft.x\", this.position[0]);\r\n        this.model.set(\"bounds.upperLeft.y\", this.position[1]);\r\n        this.model.set(\"bounds.lowerRight.x\", parseInt(this.position[0] + this.getBoundingRect().width));\r\n        this.model.set(\"bounds.lowerRight.y\", parseInt(this.position[1] + this.getBoundingRect().height));\r\n        this.model.set(\"style.sPos\", this.options.position.startPos);\r\n        this.model.set(\"style.ePos\", this.options.position.endPos);\r\n        this.model.set(\"style.lineDash\", this.options.style.lineDash);\r\n        this.model.set(\"style.stroke\", this.options.style.stroke);\r\n        this.model.set(\"symbol.type\", this.options.symbol.type);\r\n        this.model.set(\"dockers\", this.turningPoints);\r\n        return this.model.option;\r\n    };\r\n\r\n    /**\r\n     * refreshModel  flow当序列化的时候调用 更新线段的位置 及线上的icons\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.refreshModel = function() {\r\n        this.model.set(\"options\", zrUtil.clone(this.options));\r\n        this.model.set(\"options.dockers\", this.turningPoints);\r\n        var icons = [];\r\n        for (var i = 0; i < this.icons.length; i++) {\r\n            var iconNode = this.icons[i];\r\n            var option = [iconNode.key, {\r\n                icon: iconNode.style.image,\r\n                width: iconNode.style.width,\r\n                height: iconNode.style.height\r\n            }];\r\n            icons.push(option);\r\n        }\r\n        this.model.set(\"icons\", icons);\r\n    };\r\n\r\n    /**\r\n     * 调整曲线的形状\r\n     * @param  {array} points 点数组\r\n     * @return {void}\r\n     */\r\n    Connector.prototype.modifyCurve = function(points) {\r\n        var sol = this.getCurvePoint(points);\r\n\r\n        // 1. 如果曲线的数量 比数量的中数量要少 则删除多余的线段\r\n        var willDelCurves = [];\r\n        for (var j = sol.length, cntCurve = this.groupCurve.childCount(); j < cntCurve; j++) {\r\n            willDelCurves.push(this.groupCurve.childAt(j));\r\n        }\r\n        zrUtil.each(willDelCurves, function(curve) {\r\n            this.groupCurve.remove(curve);\r\n        }, this);\r\n        // 2. 遍历曲线   如果存在则直接设置形状，否则创建\r\n        for (var i = 0; i < sol.length; i++) {\r\n            var line = this.groupCurve.childAt(i);\r\n            if (line) {\r\n                line.attr('shape', sol[i]);\r\n            } else {\r\n                var cure = new graphic.BezierCurve({\r\n                   // position: this.options.position,\r\n                    style: this.options.style,\r\n                    shape: sol[i],\r\n                    z: this.options.z\r\n                });\r\n                this.groupCurve.add(cure);\r\n                this.createHoverStyle(cure);\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * 根据传入的点数组计算曲线的点\r\n     * @param  {array} P 点数组\r\n     * @return {object}        曲线的点数组\r\n     */\r\n    Connector.prototype.getCurvePoint = function(P) {\r\n        var n = P.length;\r\n        var sol = [];\r\n        if (n === 3) {\r\n            sol.push({\r\n                x1: P[0].x,\r\n                y1: P[0].y,\r\n                cpx1: P[1].x,\r\n                cpy1: P[1].y,\r\n                x2: P[2].x,\r\n                y2: P[2].y\r\n            });\r\n            return sol;\r\n        } else if (n === 4) {\r\n            sol.push({\r\n                x1: P[0].x,\r\n                y1: P[0].y,\r\n                cpx1: P[1].x,\r\n                cpy1: P[1].y,\r\n                cpx2: P[2].x,\r\n                cpy2: P[2].y,\r\n                x2: P[3].x,\r\n                y2: P[3].y\r\n            });\r\n            return sol;\r\n        }\r\n\r\n\r\n        /**Computes the sum between two point\r\n         *@param p1 - {Point}\r\n         *@param p2 - {Point}\r\n         *@return {Point} the sum of initial points\r\n         **/\r\n        function sum(p1, p2) {\r\n            return new Point(p1.x + p2.x, p1.y + p2.y);\r\n        }\r\n\r\n\r\n        /**Computes the division of a {Point} by a number\r\n         *@param p - {Point}\r\n         *@param nr - {Number}\r\n         *@return {Point}\r\n         **/\r\n        function divide(p, nr) {\r\n            if (nr == 0) {\r\n                throw \"Division by zero not allowed (yet :) \" + this.callee;\r\n            }\r\n            return new Point(p.x / nr, p.y / nr);\r\n        }\r\n\r\n        /**Computes the multiplication of a {Point} by a number\r\n         *@param p - {Point}\r\n         *@param nr - {Number}\r\n         *@return {Point}\r\n         **/\r\n        function multiply(p, nr) {\r\n            return new Point(p.x * nr, p.y * nr);\r\n        }\r\n\r\n\r\n\r\n\r\n        /*\r\n         *I do not get why first 4 must be 0 and last 3 of same value.....\r\n         *but otherwise we will get division by zero\r\n         */\r\n        var k = [0, 0, 0];\r\n\r\n        var j;\r\n        for (j = 0; j <= n - 3; j++) {\r\n            k.push(j);\r\n        }\r\n\r\n        k.push(n - 3, n - 3);\r\n\r\n\r\n\r\n        for (var i = 1; i <= n - 3; i++) {\r\n            //q1 - compute start point\r\n            var q1 = divide(sum(multiply(P[i], k[i + 4] - k[i + 2]), multiply(P[i + 1], k[i + 2] - k[i + 1])), k[i + 4] - k[i + 1]);\r\n\r\n            //q0 - compute 1st controll point\r\n            var q_01 = (k[i + 3] - k[i + 2]) / (k[i + 3] - k[i + 1]);\r\n            var q_02 = divide(sum(multiply(P[i - 1], k[i + 3] - k[i + 2]), multiply(P[i], k[i + 2] - k[i])), k[i + 3] - k[i]);\r\n            var q_03 = multiply(q1, (k[i + 2] - k[i + 1]) / (k[i + 3] - k[i + 1]));\r\n            var q0 = sum(multiply(q_02, q_01), q_03);\r\n\r\n            //q2 - compute 2nd controll point\r\n            var q2 = divide(sum(multiply(P[i], k[i + 4] - k[i + 3]), multiply(P[i + 1], k[i + 3] - k[i + 1])), k[i + 4] - k[i + 1]);\r\n\r\n            //q3 - compute end point\r\n            var q_31 = (k[i + 3] - k[i + 2]) / (k[i + 4] - k[i + 2]);\r\n            var q_32 = divide(sum(multiply(P[i + 1], k[i + 5] - k[i + 3]), multiply(P[i + 2], k[i + 3] - k[i + 2])), k[i + 5] - k[i + 2]);\r\n            var q_33 = multiply(q2, (k[i + 4] - k[i + 3]) / (k[i + 4] - k[i + 2]));\r\n            var q3 = sum(multiply(q_32, q_31), q_33);\r\n\r\n            //store solution\r\n            //\r\n            sol.push({\r\n                x1: q0.x,\r\n                y1: q0.y,\r\n                cpx1: q1.x,\r\n                cpy1: q1.y,\r\n                cpx2: q2.x,\r\n                cpy2: q2.y,\r\n                x2: q3.x,\r\n                y2: q3.y\r\n            });\r\n        }\r\n\r\n        return sol;\r\n    };\r\n\r\n\r\n    Util.inherits(Connector, Node);\r\n\r\n    module.exports = Connector;\r\n\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/shapes/Connector.js\n// module id = 80\n// module chunks = 0","'use strict';\n// Symbol factory\r\n\r\n\r\n    var graphic = require('../graphic');\r\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\r\n    /**\r\n     * Triangle shape\r\n     * @inner\r\n     */\r\n    var Triangle = graphic.extendShape({\r\n        type: 'triangle',\r\n        shape: {\r\n            cx: 0,\r\n            cy: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n        buildPath: function (path, shape) {\r\n            var cx = shape.cx;\r\n            var cy = shape.cy;\r\n            var width = shape.width / 2;\r\n            var height = shape.height / 2;\r\n            path.moveTo(cx, cy - height);\r\n            path.lineTo(cx + width, cy + height);\r\n            path.lineTo(cx - width, cy + height);\r\n            path.closePath();\r\n        }\r\n    });\r\n    /**\r\n     * Diamond shape\r\n     * @inner\r\n     */\r\n    var Diamond = graphic.extendShape({\r\n        type: 'diamond',\r\n        shape: {\r\n            cx: 0,\r\n            cy: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n        buildPath: function (path, shape) {\r\n            var cx = shape.cx;\r\n            var cy = shape.cy;\r\n            var width = shape.width / 2;\r\n            var height = shape.height / 2;\r\n            path.moveTo(cx, cy - height);\r\n            path.lineTo(cx + width, cy);\r\n            path.lineTo(cx, cy + height);\r\n            path.lineTo(cx - width, cy);\r\n            path.closePath();\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Pin shape\r\n     * @inner\r\n     */\r\n    var Pin = graphic.extendShape({\r\n        type: 'pin',\r\n        shape: {\r\n            // x, y on the cusp\r\n            x: 0,\r\n            y: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n\r\n        buildPath: function (path, shape) {\r\n            var x = shape.x;\r\n            var y = shape.y;\r\n            var w = shape.width / 5 * 3;\r\n            // Height must be larger than width\r\n            var h = Math.max(w, shape.height);\r\n            var r = w / 2;\r\n\r\n            // Dist on y with tangent point and circle center\r\n            var dy = r * r / (h - r);\r\n            var cy = y - h + r + dy;\r\n            var angle = Math.asin(dy / r);\r\n            // Dist on x with tangent point and circle center\r\n            var dx = Math.cos(angle) * r;\r\n\r\n            var tanX = Math.sin(angle);\r\n            var tanY = Math.cos(angle);\r\n\r\n            path.arc(\r\n                x, cy, r,\r\n                Math.PI - angle,\r\n                Math.PI * 2 + angle\r\n            );\r\n\r\n            var cpLen = r * 0.6;\r\n            var cpLen2 = r * 0.7;\r\n            path.bezierCurveTo(\r\n                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\r\n                x, y - cpLen2,\r\n                x, y\r\n            );\r\n            path.bezierCurveTo(\r\n                x, y - cpLen2,\r\n                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\r\n                x - dx, cy + dy\r\n            );\r\n            path.closePath();\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Arrow shape\r\n     * @inner\r\n     */\r\n    var Arrow = graphic.extendShape({\r\n\r\n        type: 'arrow',\r\n\r\n        shape: {\r\n            x: 0,\r\n            y: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var height = shape.height;\r\n            var width = shape.width;\r\n            var x = shape.x;\r\n            var y = shape.y;\r\n            var dx = width / 3 * 2;\r\n            ctx.moveTo(x, y);\r\n            ctx.lineTo(x + dx, y + height);\r\n            ctx.lineTo(x, y + height / 4 * 3);\r\n            ctx.lineTo(x - dx, y + height);\r\n            ctx.lineTo(x, y);\r\n            ctx.closePath();\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Map of path contructors\r\n     * @type {Object.<string, module:zrender/graphic/Path>}\r\n     */\r\n    var symbolCtors = {\r\n        line: graphic.Line,\r\n\r\n        rect: graphic.Rect,\r\n\r\n        roundRect: graphic.Rect,\r\n\r\n        square: graphic.Rect,\r\n\r\n        circle: graphic.Circle,\r\n\r\n        diamond: Diamond,\r\n\r\n        pin: Pin,\r\n\r\n        arrow: Arrow,\r\n\r\n        triangle: Triangle\r\n    };\r\n\r\n    var symbolShapeMakers = {\r\n\r\n        line: function (x, y, w, h, shape) {\r\n            // FIXME\r\n            shape.x1 = x;\r\n            shape.y1 = y + h / 2;\r\n            shape.x2 = x + w;\r\n            shape.y2 = y + h / 2;\r\n        },\r\n\r\n        rect: function (x, y, w, h, shape) {\r\n            shape.x = x;\r\n            shape.y = y;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        },\r\n\r\n        roundRect: function (x, y, w, h, shape) {\r\n            shape.x = x;\r\n            shape.y = y;\r\n            shape.width = w;\r\n            shape.height = h;\r\n            shape.r = Math.min(w, h) / 4;\r\n        },\r\n\r\n        square: function (x, y, w, h, shape) {\r\n            var size = Math.min(w, h);\r\n            shape.x = x;\r\n            shape.y = y;\r\n            shape.width = size;\r\n            shape.height = size;\r\n        },\r\n\r\n        circle: function (x, y, w, h, shape) {\r\n            // Put circle in the center of square\r\n            shape.cx = x + w / 2;\r\n            shape.cy = y + h / 2;\r\n            shape.r = Math.min(w, h) / 2;\r\n        },\r\n\r\n        diamond: function (x, y, w, h, shape) {\r\n            shape.cx = x + w / 2;\r\n            shape.cy = y + h / 2;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        },\r\n\r\n        pin: function (x, y, w, h, shape) {\r\n            shape.x = x + w / 2;\r\n            shape.y = y + h / 2;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        },\r\n\r\n        arrow: function (x, y, w, h, shape) {\r\n            shape.x = x + w / 2;\r\n            shape.y = y + h / 2;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        },\r\n\r\n        triangle: function (x, y, w, h, shape) {\r\n            shape.cx = x + w / 2;\r\n            shape.cy = y + h / 2;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        }\r\n    };\r\n\r\n    var symbolBuildProxies = {};\r\n    for (var name in symbolCtors) {\r\n        symbolBuildProxies[name] = new symbolCtors[name]();\r\n    }\r\n\r\n    var Symbol = graphic.extendShape({\r\n\r\n        type: 'symbol',\r\n\r\n        shape: {\r\n            symbolType: '',\r\n            x: 0,\r\n            y: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n\r\n        beforeBrush: function () {\r\n            var style = this.style;\r\n            var shape = this.shape;\r\n            // FIXME\r\n            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\r\n                style.textPosition = ['50%', '40%'];\r\n                style.textAlign = 'center';\r\n                style.textVerticalAlign = 'middle';\r\n            }\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var symbolType = shape.symbolType;\r\n            var proxySymbol = symbolBuildProxies[symbolType];\r\n            if (shape.symbolType !== 'none') {\r\n                if (!proxySymbol) {\r\n                    // Default rect\r\n                    symbolType = 'rect';\r\n                    proxySymbol = symbolBuildProxies[symbolType];\r\n                }\r\n                symbolShapeMakers[symbolType](\r\n                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\r\n                );\r\n                proxySymbol.buildPath(ctx, proxySymbol.shape);\r\n            }\r\n        }\r\n    });\r\n\r\n    // Provide setColor helper method to avoid determine if set the fill or stroke outside\r\n    var symbolPathSetColor = function (color) {\r\n        if (this.type !== 'image') {\r\n            var symbolStyle = this.style;\r\n            var symbolShape = this.shape;\r\n            if (symbolShape && symbolShape.symbolType === 'line') {\r\n                symbolStyle.stroke = color;\r\n            }\r\n            else if (this.__isEmptyBrush) {\r\n                symbolStyle.stroke = color;\r\n                symbolStyle.fill = '#fff';\r\n            }\r\n            else {\r\n                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?\r\n                symbolStyle.fill && (symbolStyle.fill = color);\r\n                symbolStyle.stroke && (symbolStyle.stroke = color);\r\n            }\r\n            this.dirty();\r\n        }\r\n    };\r\n\r\n    var symbolUtil = {\r\n        /**\r\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\r\n         * @param {string} symbolType\r\n         * @param {number} x\r\n         * @param {number} y\r\n         * @param {number} w\r\n         * @param {number} h\r\n         * @param {number} z\r\n         * @param {string} color\r\n         */\r\n        createSymbol: function (symbolType, x, y, w, h, z, color) {\r\n            var isEmpty = symbolType.indexOf('empty') === 0;\r\n            if (isEmpty) {\r\n                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\r\n            }\r\n            var symbolPath;\r\n\r\n            if (symbolType.indexOf('image://') === 0) {\r\n                symbolPath = new graphic.Image({\r\n                    style: {\r\n                        image: symbolType.slice(8),\r\n                        x: x,\r\n                        y: y,\r\n                        width: w,\r\n                        height: h\r\n                    },\r\n                    z: z\r\n                });\r\n            }\r\n            else if (symbolType.indexOf('path://') === 0) {\r\n                symbolPath = graphic.makePath(symbolType.slice(7), {z: z, rectHover: true}, new BoundingRect(x, y, w, h));\r\n            }\r\n            else {\r\n                symbolPath = new Symbol({\r\n                    shape: {\r\n                        symbolType: symbolType,\r\n                        x: x,\r\n                        y: y,\r\n                        width: w,\r\n                        height: h\r\n                    },\r\n                    z: z\r\n                });\r\n            }\r\n\r\n            symbolPath.__isEmptyBrush = isEmpty;\r\n\r\n            symbolPath.setColor = symbolPathSetColor;\r\n\r\n            symbolPath.setColor(color);\r\n\r\n            return symbolPath;\r\n        }\r\n    };\r\n\r\n    module.exports = symbolUtil;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/shapes/Symbol.js\n// module id = 81\n// module chunks = 0","/**\r\n * 画句柄\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var graphic = require(\"../graphic.js\");\r\n    var Util = require(\"../util.js\");\r\n    function Handle(type, x, y, connector){\r\n        this.type = type;\r\n\r\n        this.x = x;\r\n\r\n        this.y = y;\r\n\r\n        this.visible = true;\r\n\r\n        this.connector = connector;\r\n\r\n        this.handleShape = new graphic.Circle({\r\n            shape: {\r\n                cx: x,\r\n                cy: y,\r\n                r: Handle.RADIUS\r\n            },\r\n\r\n            style: {\r\n                fill: \"rgb(0,255,0)\",\r\n                stroke:\"rgb(0,0,0)\"\r\n            },\r\n            z : connector.options.z + 2,  //节点Z为1 线段为0;\r\n            draggable:true\r\n        });\r\n\r\n        var that = this;\r\n        this.handleShape.on(\"drag\", function(e) {\r\n            that.actionConnector(e.offsetX,e.offsetY);\r\n        });\r\n       // return this.circle;\r\n    }\r\n\r\n    Handle.RADIUS = 4;\r\n\r\n    Handle.prototype = {\r\n\r\n        constructor : Handle,\r\n\r\n        equals : function(anotherHandle){\r\n            if(!anotherHandle instanceof Handle){\r\n                return false;\r\n            }\r\n\r\n            return this.type == anotherHandle.type\r\n            && this.x == anotherHandle.x\r\n            && this.y == anotherHandle.y\r\n            && this.visible == anotherHandle.visible;\r\n        },\r\n\r\n        /**\r\n         * 移动句柄\r\n         * @param  {[type]} newX [description]\r\n         * @param  {[type]} newY [description]\r\n         * @return {[type]}      [description]\r\n         */\r\n        actionConnector: function(newX, newY){\r\n            switch(this.type){\r\n                case 'v':\r\n                    var index;\r\n                    // 找出两个转折点（可移动句柄在这两个转折点中间）\r\n                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){\r\n                        if(this.connector.turningPoints[i-1].y == this.connector.turningPoints[i].y\r\n                            && this.connector.turningPoints[i].y == this.y\r\n                            && Math.min(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) <= this.x\r\n                            && Math.max(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) >= this.x)\r\n                        {\r\n                            index = i;\r\n                        }\r\n                    }\r\n                    var deltaY = newY - this.y;\r\n                    var translationMatrix = Util.translationMatrix(0, deltaY);\r\n\r\n                    this.connector.turningPoints[index-1].transform(translationMatrix);\r\n                    this.connector.turningPoints[index].transform(translationMatrix);\r\n                    this.connector.refresh();\r\n                    this.y = newY;  //将句柄新的位置赋值给y\r\n\r\n                    break;\r\n\r\n                case 'h':\r\n                    var index;\r\n                    // 找出两个转折点（可移动句柄在这两个转折点中间）\r\n                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){\r\n                        if(this.connector.turningPoints[i-1].x == this.connector.turningPoints[i].x\r\n                            && this.connector.turningPoints[i].x == this.x\r\n                            && Math.min(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) <= this.y\r\n                            && Math.max(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) >= this.y)\r\n                            {\r\n                            index = i;\r\n                        }\r\n                    }\r\n                    var deltaX = newX-this.x;\r\n                    var translationMatrix = Util.translationMatrix(deltaX, 0);\r\n                    this.connector.turningPoints[index-1].transform(translationMatrix);\r\n                    this.connector.turningPoints[index].transform(translationMatrix);\r\n                    this.connector.refresh();\r\n                    this.x = newX; //将句柄新的位置赋值给x\r\n\r\n                    break;\r\n            }\r\n           //. this.shape.updateMiddleText();\r\n        }\r\n    };\r\n    module.exports = Handle;\r\n\r\n\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/shapes/Handle.js\n// module id = 82\n// module chunks = 0","/**\r\n * 连线动态效果\r\n * @author miao.cunzhi\r\n */\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var vec2 = require('zrender/lib/core/vector');\r\n    var curveUtil = require('zrender/lib/core/curve');\r\n    var symbolUtil = require('./Symbol.js');\r\n\r\n    function EffectLine(symbol, options, groupCurve, polyLine) {\r\n        this._lastFrame = 0;\r\n        this._lastFramePercent = 0;\r\n        this.symbol = symbol;\r\n        this.groupCurve = groupCurve;\r\n        this.initSymbol(options, polyLine);\r\n    }\r\n    var EffectLineProto = EffectLine.prototype;\r\n\r\n    EffectLineProto.initSymbol = function(options, polyLine) {\r\n        var that = this;\r\n        this.symbol.z2 = 100;\r\n        this.symbol.culling = true;\r\n        var period = options.effect.period * 1000;\r\n        this.symbol.__t = 0;\r\n        this.symbol.stopAnimation();\r\n        if ((options.style.lineType == \"curve\")) {\r\n            if (this.groupCurve) {\r\n                var i = 0;\r\n                period = period / this.groupCurve._children.length;\r\n                this.groupCurveAnimate(this.groupCurve._children[0], i, period);\r\n            }\r\n\r\n        } else {\r\n            this.symbol.animate('', true)\r\n                .when(period, {\r\n                    __t: 1\r\n                })\r\n                .delay(0)\r\n                .during(function() {\r\n                    that.updateSymbolPositionPolyline();\r\n                })\r\n                .start();\r\n            this.setAnimationPointsPolyline(polyLine.shape.points);\r\n        }\r\n\r\n    };\r\n\r\n    EffectLineProto.groupCurveAnimate = function(curveLine, i, period) {\r\n        var that = this;\r\n        if (curveLine == undefined) {\r\n            curveLine = this.groupCurve._children[0];\r\n            i = 0;\r\n        }\r\n        var points;\r\n        var pos = curveLine.shape;\r\n        points = [\r\n            [pos.x1, pos.y1],\r\n            [pos.x2, pos.y2],\r\n            [pos.cpx1, pos.cpy1],\r\n            [pos.cpx2, pos.cpy2]\r\n        ];\r\n        this.setAnimationPointsBezierCurve(points);\r\n        this.symbol.animate('')\r\n            .when(period, {\r\n                __t: 1\r\n            })\r\n            .delay(0)\r\n            .during(function() {\r\n                that.updateSymbolPositionBezierCurve();\r\n            })\r\n            .done(function() {\r\n                that.symbol.__t = 0;\r\n                that.groupCurveAnimate(that.groupCurve._children[i + 1], i + 1, period);\r\n            })\r\n            .start();\r\n\r\n    };\r\n\r\n\r\n    EffectLineProto.setAnimationPointsBezierCurve = function(points) {\r\n        this.symbol.__p1 = points[0];\r\n        this.symbol.__p2 = points[1];\r\n        this.symbol.__cp1 = points[2] || [\r\n            (points[0][0] + points[1][0]) / 2,\r\n            (points[0][1] + points[1][1]) / 2\r\n        ];\r\n        this.symbol.__cp2 = points[3];\r\n    };\r\n\r\n    EffectLineProto.updateSymbolPositionBezierCurve = function() {\r\n        var p1 = this.symbol.__p1;\r\n        var p2 = this.symbol.__p2;\r\n        var cp1 = this.symbol.__cp1;\r\n        var cp2 = this.symbol.__cp2;\r\n        var t = this.symbol.__t;\r\n        var pos = this.symbol.position;\r\n        var tx, ty;\r\n        if (cp2[0] != undefined) {\r\n            var cubicAt = curveUtil.cubicAt;\r\n            var cubicDerivativeAt = curveUtil.cubicDerivativeAt;\r\n            pos[0] = cubicAt(p1[0], cp1[0], cp2[0], p2[0], t);\r\n            pos[1] = cubicAt(p1[1], cp1[1], cp2[1], p2[1], t);\r\n            // Tangent\r\n            tx = cubicDerivativeAt(p1[0], cp1[0], cp2[0], p2[0], t);\r\n            ty = cubicDerivativeAt(p1[1], cp1[1], cp2[1], p2[1], t);\r\n        } else {\r\n            var quadraticAt = curveUtil.quadraticAt;\r\n            var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;\r\n            pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);\r\n            pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);\r\n            // Tangent\r\n            tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);\r\n            ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);\r\n        }\r\n        this.symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;\r\n\r\n        this.symbol.ignore = false;\r\n    };\r\n\r\n    EffectLineProto.setAnimationPointsPolyline = function(points) {\r\n        this._points = points;\r\n        var accLenArr = [0];\r\n        var len = 0;\r\n        for (var i = 1; i < points.length; i++) {\r\n            var p1 = points[i - 1];\r\n            var p2 = points[i];\r\n            len += vec2.dist(p1, p2);\r\n            accLenArr.push(len);\r\n        }\r\n        if (len === 0) {\r\n            return;\r\n        }\r\n\r\n        for (var j = 0; j < accLenArr.length; j++) {\r\n            accLenArr[j] /= len;\r\n        }\r\n        this._offsets = accLenArr;\r\n        this._length = len;\r\n        this.symbol._lastFrame = 0;\r\n        this.symbol.__lastFramePercent = 0;\r\n    };\r\n\r\n    EffectLineProto.updateSymbolPositionPolyline = function() {\r\n        var t = this.symbol.__t;\r\n        var points = this._points;\r\n        var offsets = this._offsets;\r\n        var len = points.length;\r\n\r\n        if (!offsets) {\r\n            // Has length 0\r\n            return;\r\n        }\r\n\r\n        var lastFrame = this._lastFrame;\r\n        var frame;\r\n\r\n        if (t < this._lastFramePercent) {\r\n            // Start from the next frame\r\n            // PENDING start from lastFrame ?\r\n            var start = Math.min(lastFrame + 1, len - 1);\r\n            for (frame = start; frame >= 0; frame--) {\r\n                if (offsets[frame] <= t) {\r\n                    break;\r\n                }\r\n            }\r\n            // PENDING really need to do this ?\r\n            frame = Math.min(frame, len - 2);\r\n        } else {\r\n            for (var frame = lastFrame; frame < len; frame++) {\r\n                if (offsets[frame] > t) {\r\n                    break;\r\n                }\r\n            }\r\n            frame = Math.min(frame - 1, len - 2);\r\n        }\r\n        vec2.lerp(\r\n            this.symbol.position, points[frame], points[frame + 1],\r\n            (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame])\r\n        );\r\n\r\n        this._lastFrame = frame;\r\n        this._lastFramePercent = t;\r\n        var angle = -Math.atan2(points[frame + 1][1] - points[frame][1], points[frame + 1][0] - points[frame][0]);\r\n        this.symbol.rotation = angle - Math.PI / 2;\r\n        this.symbol.ignore = false;\r\n    };\r\n    module.exports = EffectLine;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/shapes/EffectLine.js\n// module id = 83\n// module chunks = 0","/**\r\n * 控制点\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var graphic = require(\"../graphic.js\");\r\n    function ConnectionPoint(connector, point, type, options){\r\n        this.connector = connector;\r\n\r\n        this.point = point.clone();\r\n\r\n        this.type = type;\r\n\r\n        this.color = ConnectionPoint.NORMAL_COLOR;\r\n\r\n        this.oType = 'ConnectionPoint';\r\n\r\n        this.shape = new graphic.Circle({\r\n            shape: {\r\n                cx: this.point.x,\r\n                cy: this.point.y,\r\n                r: ConnectionPoint.RADIUS\r\n            },\r\n\r\n            style: {\r\n                fill: this.color,\r\n                stroke:'#000000'\r\n            },\r\n            z : options.z + 2  //节点Z为1 线段为0;\r\n        });\r\n        this.shape.type =  this.type;\r\n\r\n        this.shape.connector = connector;\r\n        //return this.circle;\r\n    }\r\n\r\n    ConnectionPoint.NORMAL_COLOR = \"#FFFF33\"; //yellow.\r\n\r\n    ConnectionPoint.OVER_COLOR = \"#FF9900\"; //orange\r\n\r\n    ConnectionPoint.CONNECTED_COLOR = \"#ff0000\"; //red\r\n\r\n    ConnectionPoint.RADIUS = 4;\r\n\r\n    ConnectionPoint.TYPE_FIGURE = 'figure';\r\n\r\n    ConnectionPoint.TYPE_CONNECTOR = 'connector';\r\n\r\n    ConnectionPoint.prototype = {\r\n\r\n        constructor : ConnectionPoint,\r\n\r\n        equals : function(anotherConnectionPoint){\r\n            return this.point.equals(anotherConnectionPoint.point)\r\n            && this.connector == anotherConnectionPoint.connector\r\n            && this.type == anotherConnectionPoint.type\r\n            && this.color == anotherConnectionPoint.color\r\n            && this.radius == anotherConnectionPoint.radius;\r\n        }\r\n\r\n\r\n    };\r\n    module.exports = ConnectionPoint;\r\n\r\n\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/shapes/ConnectionPoint.js\n// module id = 84\n// module chunks = 0","/**\r\n * 节点等的模型\r\n * 里面存的数据用来处理序列化和反序列化\r\n * @class fish.topo.model\r\n */\r\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var clazzUtil = require('./clazz');\r\n\r\n    function Model(option, parentModel,  extraOpt) {\r\n        this.parentModel = parentModel;\r\n        this.option = option;\r\n\r\n        // Simple optimization\r\n        if (this.init) {\r\n            if (arguments.length <= 3) {\r\n                this.init(option, parentModel,  extraOpt);\r\n            }\r\n            else {\r\n                this.init.apply(this, arguments);\r\n            }\r\n        }\r\n    }\r\n\r\n    Model.prototype = {\r\n\r\n        constructor: Model,\r\n\r\n        /**\r\n         * Model 的初始化函数\r\n         * @private\r\n         * @param {Object} option\r\n         */\r\n        init: function (option) {\r\n            zrUtil.merge(option, this.getDefaultOption());\r\n        },\r\n\r\n        getDefaultOption: function () {\r\n            if (!this.hasOwnProperty('__defaultOption')) {\r\n                var optList = [];\r\n                var Class = this.constructor;\r\n                while (Class) {\r\n                    var opt = Class.prototype.defaultOption;\r\n                    opt && optList.push(opt);\r\n                    Class = Class.superClass;\r\n                }\r\n\r\n                var defaultOption = {};\r\n                for (var i = optList.length - 1; i >= 0; i--) {\r\n                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\r\n                }\r\n                this.__defaultOption = defaultOption;\r\n            }\r\n            return this.__defaultOption;\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        mergeOption: function (option) {\r\n            zrUtil.merge(this.option, option, true);\r\n        },\r\n\r\n        /**\r\n         * 获取model的某个属性的值\r\n         * @param {string} path model中的属性\r\n         * @return {String}\r\n         *\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *          node.model.get(\"options.text\");\r\n         */\r\n        get: function (path, ignoreParent) {\r\n            if (!path) {\r\n                return this.option;\r\n            }\r\n\r\n            if (typeof path === 'string') {\r\n                path = path.split('.');\r\n            }\r\n\r\n            var obj = this.option;\r\n            var parentModel = this.parentModel;\r\n            for (var i = 0; i < path.length; i++) {\r\n                // obj could be number/string/... (like 0)\r\n                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;\r\n                if (obj == null) {\r\n                    break;\r\n                }\r\n            }\r\n            if (obj == null && parentModel && !ignoreParent) {\r\n                obj = parentModel.get(path);\r\n            }\r\n            return obj;\r\n        },\r\n\r\n        /**\r\n         * 设置model的某个属性的值\r\n         * @param {string} path model中的属性\r\n         * @param {String} value 所需要设置的值\r\n         * @return {String}\r\n         *\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *          node.model.set(\"options.text\",\"例子\");\r\n         */\r\n        set: function (path, value) {\r\n            var obj = this.option;\r\n\r\n            if (path.indexOf(\".\") == -1) {\r\n                obj[path] = value;\r\n            } else {\r\n                var fieldArray  = path.split('.');\r\n                var n = fieldArray.length;\r\n                var currentRef = obj;\r\n                var fieldName;\r\n\r\n                for (var i = 0; i < n - 1; i++) {\r\n                    fieldName = fieldArray[i];\r\n                    if(currentRef[fieldName] == null) {\r\n                        currentRef[fieldName] = {};\r\n                    }\r\n                    currentRef = currentRef[fieldName];\r\n                }\r\n                fieldName = fieldArray[n-1];\r\n                currentRef[fieldName] = value;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        getShallow: function (key, ignoreParent) {\r\n            var option = this.option;\r\n            var val = option && option[key];\r\n            var parentModel = this.parentModel;\r\n            if (val == null && parentModel && !ignoreParent) {\r\n                val = parentModel.getShallow(key);\r\n            }\r\n            return val;\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        getModel: function (path, parentModel) {\r\n            var obj = this.get(path, true);\r\n            var thisParentModel = this.parentModel;\r\n            var model = new Model(\r\n                obj, parentModel || (thisParentModel && thisParentModel.getModel(path))\r\n            );\r\n            return model;\r\n        },\r\n\r\n        /**\r\n         *清空model的option\r\n         * @private\r\n         */\r\n        isEmpty: function () {\r\n            return this.option == null;\r\n        },\r\n\r\n        restoreData: function () {},\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        clone: function () {\r\n            var Ctor = this.constructor;\r\n            return new Ctor(zrUtil.clone(this.option));\r\n        }\r\n    };\r\n\r\n    // Enable Model.extend.\r\n    clazzUtil.enableClassExtend(Model);\r\n\r\n    module.exports = Model;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/model.js\n// module id = 85\n// module chunks = 0","\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    var clazz = {};\r\n\r\n    var TYPE_DELIMITER = '.';\r\n    var IS_CONTAINER = '___FT__COMPONENT__CONTAINER___';\r\n    /**\r\n     * @public\r\n     */\r\n    var parseClassType = clazz.parseClassType = function (componentType) {\r\n        var ret = {main: '', sub: ''};\r\n        if (componentType) {\r\n            componentType = componentType.split(TYPE_DELIMITER);\r\n            ret.main = componentType[0] || '';\r\n            ret.sub = componentType[1] || '';\r\n        }\r\n        return ret;\r\n    };\r\n    /**\r\n     * @public  相比 直接用zrUtil.inherits 好处是  可以直接调用父类的构造函数\r\n     */\r\n    clazz.enableClassExtend = function (RootClass, preConstruct) {\r\n        RootClass.extend = function (proto) {\r\n            var ExtendedClass = function () {\r\n                preConstruct && preConstruct.apply(this, arguments);\r\n                RootClass.apply(this, arguments);\r\n            };\r\n\r\n            zrUtil.extend(ExtendedClass.prototype, proto);\r\n\r\n            ExtendedClass.extend = this.extend;\r\n            ExtendedClass.superCall = superCall;\r\n            ExtendedClass.superApply = superApply;\r\n            zrUtil.inherits(ExtendedClass, this);\r\n            ExtendedClass.superClass = this;\r\n\r\n            return ExtendedClass;\r\n        };\r\n    };\r\n\r\n    // superCall should have class info, which can not be fetch from 'this'.\r\n    // Consider this case:\r\n    // class A has method f,\r\n    // class B inherits class A, overrides method f, f call superApply('f'),\r\n    // class C inherits class B, do not overrides method f,\r\n    // then when method of class C is called, dead loop occured.\r\n    function superCall(context, methodName) {\r\n        var args = zrUtil.slice(arguments, 2);\r\n        return this.superClass.prototype[methodName].apply(context, args);\r\n    }\r\n\r\n    function superApply(context, methodName, args) {\r\n        return this.superClass.prototype[methodName].apply(context, args);\r\n    }\r\n\r\n    /**\r\n     * @param {Object} entity\r\n     * @param {Object} options\r\n     * @param {boolean} [options.registerWhenExtend]\r\n     * @public\r\n     */\r\n    clazz.enableClassManagement = function (entity, options) {\r\n        options = options || {};\r\n\r\n        /**\r\n         * Component model classes\r\n         * key: componentType,\r\n         * value:\r\n         *     componentClass, when componentType is 'xxx'\r\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\r\n         * @type {Object}\r\n         */\r\n        var storage = {};\r\n\r\n        entity.registerClass = function (Clazz, componentType) {\r\n            if (componentType) {\r\n                componentType = parseClassType(componentType);\r\n\r\n                if (!componentType.sub) {\r\n                    if (storage[componentType.main]) {\r\n                        //已经注册过了，直接返回\r\n                        return;\r\n                    }\r\n                    storage[componentType.main] = Clazz;\r\n                }\r\n                else if (componentType.sub !== IS_CONTAINER) {\r\n                    var container = makeContainer(componentType);\r\n                    container[componentType.sub] = Clazz;\r\n                }\r\n            }\r\n            return Clazz;\r\n        };\r\n\r\n        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\r\n            var Clazz = storage[componentTypeMain];\r\n\r\n            if (Clazz && Clazz[IS_CONTAINER]) {\r\n                Clazz = subType ? Clazz[subType] : null;\r\n            }\r\n\r\n            if (throwWhenNotFound && !Clazz) {\r\n                throw new Error(\r\n                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'\r\n                );\r\n            }\r\n\r\n            return Clazz;\r\n        };\r\n\r\n        entity.getClassesByMainType = function (componentType) {\r\n            componentType = parseClassType(componentType);\r\n\r\n            var result = [];\r\n            var obj = storage[componentType.main];\r\n\r\n            if (obj && obj[IS_CONTAINER]) {\r\n                zrUtil.each(obj, function (o, type) {\r\n                    type !== IS_CONTAINER && result.push(o);\r\n                });\r\n            }\r\n            else {\r\n                result.push(obj);\r\n            }\r\n\r\n            return result;\r\n        };\r\n\r\n        entity.hasClass = function (componentType) {\r\n            // Just consider componentType.main.\r\n            componentType = parseClassType(componentType);\r\n            return !!storage[componentType.main];\r\n        };\r\n\r\n        /**\r\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\r\n         */\r\n        entity.getAllClassMainTypes = function () {\r\n            var types = [];\r\n            zrUtil.each(storage, function (obj, type) {\r\n                types.push(type);\r\n            });\r\n            return types;\r\n        };\r\n\r\n        /**\r\n         * If a main type is container and has sub types\r\n         * @param  {string}  componentType\r\n         * @return {boolean}\r\n         */\r\n        entity.hasSubTypes = function (componentType) {\r\n            componentType = parseClassType(componentType);\r\n            var obj = storage[componentType.main];\r\n            return obj && obj[IS_CONTAINER];\r\n        };\r\n\r\n        entity.parseClassType = parseClassType;\r\n\r\n        function makeContainer(componentType) {\r\n            var container = storage[componentType.main];\r\n            if (!container || !container[IS_CONTAINER]) {\r\n                container = storage[componentType.main] = {};\r\n                container[IS_CONTAINER] = true;\r\n            }\r\n            return container;\r\n        }\r\n\r\n        if (options.registerWhenExtend) {\r\n            var originalExtend = entity.extend;\r\n            if (originalExtend) {\r\n                entity.extend = function (proto) {\r\n                    var ExtendedClass = originalExtend.call(this, proto);\r\n                    return entity.registerClass(ExtendedClass, proto.type);\r\n                };\r\n            }\r\n        }\r\n\r\n        return entity;\r\n    };\r\n\r\n    module.exports = clazz;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/clazz.js\n// module id = 86\n// module chunks = 0","/**\r\n * 操作图标类\r\n * @author wang.xiaohu\r\n */\r\n\r\n\r\n    var IconOperation = {\r\n        STRAIGHT_SVG: 'M937.353846 724.676923C882.215385 669.538462 795.569231 661.661538 732.553846 701.046154L362.338462 330.830769C401.723077 267.815385 393.846154 181.169231 338.707692 126.030769 267.815385 55.138462 165.415385 55.138462 94.523077 126.030769 23.630769 196.923077 23.630769 299.323077 94.523077 370.215385 149.661538 425.353846 236.307692 433.230769 299.323077 393.846154L669.538462 764.061538C630.153846 827.076923 638.030769 913.723077 693.169231 968.861538 764.061538 1039.753846 866.461538 1039.753846 937.353846 968.861538 1000.369231 897.969231 1000.369231 795.569231 937.353846 724.676923L937.353846 724.676923ZM275.692308 307.2C244.184615 338.707692 189.046154 338.707692 157.538462 307.2 126.030769 275.692308 126.030769 220.553846 157.538462 189.046154 189.046154 157.538462 244.184615 157.538462 275.692308 189.046154 307.2 220.553846 307.2 267.815385 275.692308 307.2L275.692308 307.2ZM874.338462 913.723077C842.830769 945.230769 787.692308 945.230769 756.184615 913.723077 724.676923 882.215385 724.676923 827.076923 756.184615 795.569231 787.692308 764.061538 842.830769 764.061538 874.338462 795.569231 905.846154 827.076923 905.846154 874.338462 874.338462 913.723077L874.338462 913.723077Z',\r\n        JAGGED_SVG: 'M204.8 819.2l-51.2-102.4 204.8-307.2 51.2 102.4-204.8 307.2zM409.6 512l51.2-102.4 153.6 204.8-51.2 102.4-153.6-204.8zM819.2 204.8l51.2 102.4-204.8 409.6-51.2-102.4 204.8-409.6z                                    M153.6 716.8c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8H102.4v-102.4h102.4v102.4zM409.6 204.8C322.56 204.8 256 271.36 256 358.4s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8H358.4V307.2h102.4v102.4zM614.4 614.4c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8h-102.4v-102.4h102.4v102.4zM870.4 0c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8h-102.4V102.4h102.4v102.4z',\r\n        CURVE_SVG: 'M1014.285039 824.024234l-145.168428-144.37205c-12.969593-12.855825-37.543559-14.505466-44.597197 2.332252-1.877178 4.550734-2.275367 17.179022-2.275368 17.179022v97.556369H330.935383a118.319095 118.319095 0 0 1-118.546632-117.920905A118.319095 118.319095 0 0 1 330.992267 560.878016h445.516899c121.561493 0 220.426198-98.352747 220.426198-219.23163s-98.864705-219.174746-220.426198-219.174746H340.491925A174.236244 174.236244 0 0 0 174.105698 0 173.78117 173.78117 0 0 0 0.040107 173.09856a173.78117 173.78117 0 0 0 174.065591 173.09856 174.236244 174.236244 0 0 0 166.386227-122.471639h436.017241c65.416807 0 118.603516 52.902288 118.603515 117.920905A118.319095 118.319095 0 0 1 776.509166 459.624176H330.992267c-121.504609 0-220.369314 98.352747-220.369314 219.23163s98.864705 219.174746 220.369314 219.174746h491.194895v92.550561s0 14.221045 2.332252 19.795695c7.053638 16.894602 31.627604 17.577212 44.597197 4.664502l145.111543-144.315165a32.879056 32.879056 0 0 0 0-46.645027zM174.105698 244.94328c-39.818926 0-72.242909-32.25333-72.242909-71.84472s32.423983-71.787835 72.242909-71.787835c39.818926 0 72.186025 32.196446 72.186025 71.787835 0 39.591389-32.423983 71.787835-72.242909 71.787836z',\r\n        DEL_SVG: 'M980.992 256h-84.992v683.008c0 47.104-37.888 84.992-84.992 84.992H212.992c-47.104 0-84.992-37.888-84.992-84.992V256H43.008C19.456 256 0 236.544 0 212.992c0-23.552 19.456-43.008 43.008-43.008H256V84.992C256 37.888 293.888 0 340.992 0h340.992C730.112 0 768 37.888 768 84.992v84.992h214.016c23.552 0 43.008 19.456 43.008 43.008-1.024 23.552-20.48 43.008-44.032 43.008zM683.008 84.992H340.992v84.992h340.992V84.992zM212.992 939.008h596.992V256H212.992v683.008z m171.008-470.016v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-23.552 19.456-43.008 43.008-43.008 23.552 1.024 43.008 19.456 43.008 43.008zM512 427.008c23.552 0 43.008 19.456 43.008 43.008v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-24.576 19.456-43.008 43.008-43.008z m171.008 0c23.552 0 43.008 19.456 43.008 43.008v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-24.576 19.456-43.008 43.008-43.008z',\r\n        COMMENT_SVG: 'M209.92 152.064l572.416 1.536c12.8 0 23.04 10.24 23.04 23.04v237.568c0 12.8 10.24 23.04 23.04 23.04s23.04-10.24 23.04-23.04V125.44c0-12.8-10.24-23.04-23.04-23.04H158.72c-12.8 0-23.04 10.24-23.04 23.04v773.12c0 12.8 10.24 23.04 23.04 23.04h236.032c12.8 0 23.04-10.24 23.04-23.04s-10.24-22.528-22.528-23.04l-185.856-1.536c-12.8 0-22.528-10.24-22.528-23.04V174.592c0-12.288 10.24-22.528 23.04-22.528z                                            M268.8 570.368h159.232c13.312 0 24.064 10.752 24.576 24.064v2.56c0 13.312-10.752 24.576-24.576 24.576H268.8c-13.312 0-24.064-10.752-24.576-24.064v-2.56c0.512-13.312 11.264-24.576 24.576-24.576z m0-312.32h441.344c13.312 0 24.576 10.752 24.576 24.576v2.56c0 13.312-10.752 24.576-24.576 24.576H268.8c-13.312 0-24.576-10.752-24.576-24.576v-2.56c0.512-13.312 11.264-24.576 24.576-24.576z m0.512 155.648h269.312c13.312 0 24.576 10.752 24.576 24.064v2.56c0 13.312-10.752 24.576-24.576 24.576H269.312c-13.312 0-24.576-10.752-24.576-24.064v-2.56c0-13.824 10.752-24.576 24.576-24.576z m471.04 13.312l-246.784 339.456c-1.536 2.56-2.56 5.632-2.56 8.704l-1.536 132.096c0 9.728 9.728 16.896 18.944 14.336l122.88-37.888c3.072-1.024 5.632-3.072 7.68-5.632l246.784-338.944c4.608-6.144 3.584-15.36-2.56-19.968l-121.344-94.72c-7.168-5.632-16.896-4.096-21.504 2.56z m23.04 67.584l51.2 39.936c2.048 1.536 2.56 5.12 1.024 7.168l-26.112 35.84c-1.536 2.56-5.12 3.072-7.68 1.024l-51.712-38.912c-2.048-1.536-2.56-4.608-1.024-7.168l26.624-37.376c2.048-1.536 5.632-2.048 7.68-0.512z m-165.888 341.504l-35.328 10.752c-9.216 3.072-18.944-4.096-18.944-13.824l0.512-40.96c0-3.072 1.024-6.144 2.56-8.704l137.216-187.904c1.536-2.56 5.12-2.56 7.168-1.024l51.2 38.4c2.56 2.048 3.072 5.12 1.024 7.68l-137.728 189.952c-2.048 2.56-4.608 4.608-7.68 5.632z',\r\n        CHANGE_LINE_TYPE_SVG: 'M1008 335.2 1008 335.2l-160 144 0 0c-8.8 8-20 12.8-32 12.8-26.4 0-48-21.6-48-48 0-14.4 6.4-26.4 16-35.2l0 0 67.2-60L560 348.8c0 0 0 0 0 0L464 348.8l0 0L352 348.8 48 348.8c-26.4 0-48-21.6-48-48 0-26.4 21.6-48 48-48l124.8 0 0 0L416 252.8l0 0 208 0 0 0 227.2 0L784 192l0 0c-9.6-8.8-16-21.6-16-35.2 0-26.4 21.6-48 48-48 12 0 23.2 4.8 32 12.8l0 0 160 144 0 0c9.6 8.8 16 21.6 16 35.2C1024 314.4 1017.6 326.4 1008 335.2zM16 680.8 16 680.8l160-144 0 0c8.8-8 20-12.8 32-12.8 26.4 0 48 21.6 48 48 0 14.4-6.4 26.4-16 35.2l0 0-67.2 60L400 667.2l0 0 208 0 0 0 243.2 0 0 0L976 667.2c26.4 0 48 21.6 48 48 0 26.4-21.6 48-48 48L672 763.2 560 763.2c0 0 0 0 0 0L464 763.2l0 0L172.8 763.2 240 824l0 0c9.6 8.8 16 21.6 16 35.2 0 26.4-21.6 48-48 48-12 0-23.2-4.8-32-12.8l0 0L16 752l0 0c-9.6-8.8-16-21.6-16-35.2C0 701.6 6.4 689.6 16 680.8z'\r\n    }\r\n    module.exports = IconOperation;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/manager/IconOperation.js\n// module id = 87\n// module chunks = 0","/**\r\n * flow连线管理类\r\n * @author miao.cunzhi\r\n */\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var ConnectionManager = require(\"../../../fish-topo-core/lib/manager/ConnectionManager.js\");\r\n    var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n    var Util = require('../../../fish-topo-core/lib/util');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n    var Point = require(\"../../../fish-topo-core/lib/Point.js\");\r\n    var Constants = require(\"../util/LinkConstants.js\");\r\n    var Model = require(\"../../../fish-topo-core/lib/model.js\");\r\n    var Log = require(\"../../../fish-topo-core/lib/Log.js\");\r\n\r\n    function LinkConnectionManager() {\r\n        ConnectionManager.call(this);\r\n        this.LineOperations = []; //存放线的操作按钮\r\n        this.bundleOffset = 30; //多线段的偏移\r\n        this.bundleGap = 20; // 多线段的间隔\r\n        this.connectorMap = Util.StackedMap.createNew(); //存放多线段\r\n    }\r\n\r\n    /**\r\n     * 根据起始点创建连线\r\n     * @param  {[type]} options      [类型]\r\n     * @param {[type]} [api] [description]\r\n     * @return {[type]}           [返回连线]\r\n     */\r\n    LinkConnectionManager.prototype.connectorCreateOfPoints = function(options, api) {\r\n        var that = this;\r\n        var model = options.model;\r\n        //1.创建线段\r\n        var connector = new Connector(options);\r\n        if (options.startDemoId && options.endDemoId) {\r\n            connector.startDemoId = options.startDemoId;\r\n            connector.endDemoId = options.endDemoId;\r\n        }\r\n        if (options.pos) {\r\n            var pos = options.pos.split(\",\");\r\n            connector.sPos = pos[0];\r\n            connector.ePos = pos[1];\r\n        };\r\n        this.connectors.push(connector);\r\n\r\n        if (connector.conPointsGroup) {\r\n            connector.conPointsGroup.on(\"click\", function(e) {\r\n                var arrSplit = e.target.type.split(Connector.SEPERATOR);\r\n                var connector = e.target.connector;\r\n                if (arrSplit[0] === Connector.START_NODE) {\r\n                    connector.sPos = arrSplit[1];\r\n                } else if (arrSplit[0] === Connector.END_NODE) {\r\n                    connector.ePos = arrSplit[1];\r\n                };\r\n                that.refreshConnector(connector, true);\r\n                e.cancelBubble = true;\r\n                var params = {};\r\n                params.event = e;\r\n                params.type = \"conPointsGroup:click\";\r\n                params.lineNode = that.selConnector;\r\n                api.trigger(params.type, params);\r\n            });\r\n        }\r\n\r\n\r\n        var MOUSE_EVENT_NAMES = ['click', 'dblclick'];\r\n        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n            connector.on(\"Connector:\" + eveName, function(e) {\r\n\r\n                var selected = e.target;\r\n\r\n                if (that.selConnector !== selected) {\r\n                    that.selConnector && that.refreshConnector(that.selConnector);\r\n                    that.selConnector = selected;\r\n                };\r\n                e.cancelBubble = true;\r\n                var params = {};\r\n                params.event = e;\r\n                params.type = eveName;\r\n                params.target = that.selConnector;\r\n                api.trigger(params.type, params);\r\n            });\r\n        });\r\n\r\n        this.bundleOffset = options.bundleOffset || this.bundleOffset;\r\n        this.bundleGap = options.bundleGap || this.bundleGap;\r\n        var dockers = options.dockers;\r\n        if (dockers && dockers.length >= 2) {\r\n            var points = Point.loadArray(dockers);\r\n            connector.refresh(points);\r\n        } else {\r\n            if (options.position && options.position.points) {\r\n                var points = options.position.points;\r\n                connector.refresh(points);\r\n            }\r\n        }\r\n\r\n        //3.设置模型\r\n        var model = new Model({});\r\n        model.set(Constants.ELEMENT_TYPE, Constants.CONNECTION);\r\n        model.set(Constants.OPTIONS, zrUtil.clone(options));\r\n        model.set(Constants.DOCKERS, connector.turningPoints);\r\n        model.set(Constants.STYLE_LINETYPE, options.style.lineType);\r\n        connector.model = model;\r\n        return connector;\r\n    }\r\n    LinkConnectionManager.prototype.getTwoNodeId = function(startNode, endNode) {\r\n            return startNode.id + \",\" + endNode.id;\r\n        }\r\n        //处理多条线段\r\n    LinkConnectionManager.prototype.refreshCons = function(arrCons) {\r\n        //如果是折线的话\r\n        if (arrCons[0].options.style.lineType == Connector.TYPE_JAGGED) {\r\n            for (var i = 0; i < arrCons.length; i++) {\r\n                this.refreshConnector(arrCons[i], true);\r\n            };\r\n        } else {\r\n            this.refreshConsStraight(arrCons);\r\n        };\r\n    }\r\n\r\n    //处理多条线段(直线)\r\n    LinkConnectionManager.prototype.refreshConsStraight = function(arrCons) {\r\n        var half = parseInt(arrCons.length / 2);\r\n        var arrConnectResult = []\r\n\r\n        var startNode = arrCons[0].startNode;\r\n        var endNode = arrCons[0].endNode;\r\n        var sRect = Util.getRect(startNode).boundingRect;\r\n        var eRect = Util.getRect(endNode).boundingRect;\r\n        var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n        var eConnectorPoint = Util.getConnectorPoints(eRect);\r\n        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n\r\n        if (!arrCons[0].sPos || !arrCons[0].ePos) {\r\n            if (sRect.x < eRect.x) {\r\n                arrCons[0].sPos = \"right\";\r\n                arrCons[0].ePos = \"left\";\r\n            } else {\r\n                arrCons[0].sPos = \"left\";\r\n                arrCons[0].ePos = \"right\";\r\n            }\r\n        }\r\n        var startPoint = sConnectorPoint[arrCons[0].sPos];\r\n        var endPoint = eConnectorPoint[arrCons[0].ePos];\r\n        var angle = Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x);\r\n        for (var i = half; i >= 1; i--) {\r\n            var points = [];\r\n            points.push(startPoint); //\r\n            // points.push(new Point(startPoint.x + bundleOffset , startPoint.y + i * bundleGap));\r\n            // points.push(new Point(endPoint.x - bundleOffset , startPoint.y + i * bundleGap)); //startPoint.x + bundleOffset\r\n            var secondPoint = startPoint.clone();\r\n\r\n            //secondPoint.x =  secondPoint.x + this.bundleOffset;\r\n            secondPoint.transform(Util.translationMatrix(0, this.bundleGap * i));\r\n            //secondPoint = this.boundOffsetXY(secondPoint, true);\r\n            //\r\n            //直角坐标 x, 和 y, 计算出极坐标\r\n\r\n\r\n            //从极坐标计算出直角坐标\r\n            secondPoint.x = secondPoint.x + this.bundleOffset * Math.cos(angle);\r\n            secondPoint.y = secondPoint.y + this.bundleOffset * Math.sin(angle);\r\n\r\n\r\n\r\n            //secondPoint.transform(Util.scaleMatrix(0.5));\r\n            points.push(secondPoint);\r\n\r\n            var thirdPoint = endPoint.clone();\r\n            //thirdPoint.x =  thirdPoint.x - this.bundleOffset;\r\n\r\n\r\n\r\n            thirdPoint.transform(Util.translationMatrix(0, this.bundleGap * i));\r\n            //thirdPoint = this.boundOffsetXY(thirdPoint, false);\r\n            //secondPoint.transform(Util.scaleMatrix(0.5));\r\n            //\r\n            //直角坐标 x, 和 y, 计算出极坐标\r\n\r\n            //从极坐标计算出直角坐标\r\n            thirdPoint.x = thirdPoint.x - this.bundleOffset * Math.cos(angle);\r\n            thirdPoint.y = thirdPoint.y - this.bundleOffset * Math.sin(angle);\r\n\r\n            points.push(thirdPoint);\r\n\r\n            points.push(endPoint);\r\n            arrConnectResult.push(points);\r\n        };\r\n\r\n        arrConnectResult.push([startPoint, endPoint]);\r\n\r\n        var upHalf = Math.ceil(arrCons.length / 2);\r\n        for (var i = 1; i < upHalf; i++) {\r\n            var points = [];\r\n            points.push(startPoint);\r\n            var secondPoint = startPoint.clone();\r\n            //secondPoint.x =  secondPoint.x + this.bundleOffset;\r\n            secondPoint.transform(Util.translationMatrix(0, -this.bundleGap * i));\r\n            secondPoint.x = secondPoint.x + this.bundleOffset * Math.cos(angle);\r\n            secondPoint.y = secondPoint.y + this.bundleOffset * Math.sin(angle);\r\n            points.push(secondPoint);\r\n\r\n            var thirdPoint = endPoint.clone();\r\n            //thirdPoint.x =  thirdPoint.x - this.bundleOffset;\r\n            thirdPoint.transform(Util.translationMatrix(0, -this.bundleGap * i));\r\n            //从极坐标计算出直角坐标\r\n            thirdPoint.x = thirdPoint.x - this.bundleOffset * Math.cos(angle);\r\n            thirdPoint.y = thirdPoint.y - this.bundleOffset * Math.sin(angle);\r\n            //secondPoint.transform(Util.scaleMatrix(0.5));\r\n            points.push(thirdPoint);\r\n\r\n            points.push(endPoint);\r\n            arrConnectResult.push(points);\r\n        };\r\n\r\n\r\n        for (var i = 0; i < arrConnectResult.length; i++) {\r\n            arrCons[i].refresh(arrConnectResult[i]);\r\n        };\r\n\r\n    }\r\n    LinkConnectionManager.prototype.boundOffsetXY = function(point, isPositive) {\r\n        var resultPoint = point.clone();\r\n        //直角坐标 x, 和 y, 计算出极坐标\r\n        var angle = Math.atan2(resultPoint.y, resultPoint.x);\r\n        var r = Math.sqrt(Math.pow(resultPoint.x, 2) + Math.pow(resultPoint.y, 2));\r\n        if (isPositive) {\r\n            r = r + this.bundleOffset;\r\n        } else {\r\n            r = r - this.bundleOffset;\r\n        }\r\n\r\n\r\n        //从极坐标计算出直角坐标\r\n        resultPoint.x = r * Math.cos(angle);\r\n        resultPoint.y = r * Math.sin(angle);\r\n        return resultPoint;\r\n    }\r\n\r\n    /**\r\n     * 设置线段的模型数据  (类型 文字)\r\n     * @param {[type]} connector [description]\r\n     * @param {[type]} option    [description]\r\n     */\r\n    LinkConnectionManager.prototype.setModel = function(connector, option) {\r\n        var originLineType = connector.model.get(\"style.lineType\");\r\n        connector.model.mergeOption(option);\r\n        if (originLineType !== option.style.lineType) {\r\n            this.refreshConnector(connector, true);\r\n        };\r\n    }\r\n\r\n\r\n    /**\r\n     * 刷新连接线\r\n     * @param  {[type]} node [description]\r\n     * @return {[type]}      [description]\r\n     */\r\n    LinkConnectionManager.prototype.refreshLineByNode = function(node) {\r\n        // 判断这个节点是否有多条线段\r\n        var keys = this.connectorMap.keys();\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var key = keys[i];\r\n            if (key.indexOf(node.id) != -1) {\r\n                var arrCons = this.connectorMap.get(key);\r\n                if (arrCons.length == 1) {\r\n                    //两个节点只有一个连线的情况\r\n                    this.refreshConnector(arrCons[0], true);\r\n                } else if (arrCons.length > 1) {\r\n                    //两个节点有多个连线的情况\r\n                    this.refreshCons(arrCons);\r\n                };\r\n            };\r\n        };\r\n    }\r\n\r\n    zrUtil.inherits(LinkConnectionManager, ConnectionManager);\r\n    module.exports = LinkConnectionManager;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-link/lib/manager/LinkConnectionManager.js\n// module id = 88\n// module chunks = 0","/**\r\n * 连线管理类\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var Util = require('../util');\r\n    var Point = require(\"../Point.js\");\r\n    var Connector = require(\"../shapes/Connector.js\");\r\n    var Log = require(\"../Log.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    function ConnectionManager() {\r\n        this.connectors = []; //当前画布所有的线段\r\n        this.selConnector = null; //当前选中的线段\r\n        this.tempConnector = null; //临时线段\r\n    }\r\n\r\n    /**\r\n     * 设置线的不可编辑\r\n     * @param  {[type]} forbidEdit [description]\r\n     * @return {[type]}            [description]\r\n     */\r\n    ConnectionManager.prototype.connectorForbidEdit = function (forbidEdit) {\r\n        for (var i = 0; i < this.connectors.length; i++) {\r\n            this.connectors[i].options.isEdit = !forbidEdit;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 清空连接线上的调整位置按钮\r\n     * @return {[type]} [description]\r\n     */\r\n    ConnectionManager.prototype.clearSelectCon = function () {\r\n        if (this.selConnector != null) {\r\n            this.refreshConnector(this.selConnector);\r\n        }\r\n    }\r\n    /**\r\n     * 删除和节点相关联的连接线\r\n     * @return {[type]} [description]\r\n     */\r\n    ConnectionManager.prototype.deleteSelectCon = function (node, _zr) {\r\n        for (var i = 0; i < this.connectors.length; i++) {\r\n            if (this.connectors[i].startNode == node || this.connectors[i].endNode == node) {\r\n                //1.将线 所联的startNode的outgoing数据删除\r\n                var startNodeOutgoing = this.connectors[i].startNode.model.get(\"outgoing\");\r\n                var index = zrUtil.indexOf(startNodeOutgoing, this.connectors[i].resourceId);\r\n                if (index != -1) {\r\n                    startNodeOutgoing.splice(index, 1);\r\n                }\r\n                //2.从_zr上删除\r\n                _zr.remove(this.connectors[i]);\r\n                this.connectors.splice(i, 1);\r\n                i--;\r\n                this.selConnector = null;\r\n            }\r\n        }\r\n    }\r\n    ConnectionManager.prototype.removeLine = function (line, zr) {\r\n        this.selConnector = line;\r\n        this.deleteLine(zr);\r\n    }\r\n    /**\r\n     * 删除选定的线\r\n     * @return {[type]} [description]\r\n     */\r\n    ConnectionManager.prototype.deleteLine = function (_zr) {\r\n        //1.将线 所联的startNode的outgoing数据删除\r\n        if(this.selConnector.startNode){\r\n            var startNodeOutgoing = this.selConnector.startNode.model.get(\"outgoing\");\r\n            index = zrUtil.indexOf(startNodeOutgoing, this.selConnector.resourceId);\r\n            if (index != -1) {\r\n                startNodeOutgoing.splice(index, 1);\r\n            }\r\n\r\n            if (this.connectorMap) {\r\n                var key = this.getTwoNodeId(this.selConnector.startNode, this.selConnector.endNode, this.selConnector.options.position);\r\n                this.connectorMap.removeItem(key, this.selConnector);\r\n            }\r\n        }\r\n\r\n\r\n        //2.从_zr上删除\r\n        _zr.remove(this.selConnector);\r\n\r\n\r\n        //3.从线数据中删除\r\n        var index = zrUtil.indexOf(this.connectors, this.selConnector);\r\n        if (index != -1) {\r\n            this.connectors.splice(index, 1);\r\n        }\r\n        this.selConnector = null;\r\n    }\r\n\r\n    /**\r\n     * 重新画线\r\n     * @param  {[type]} connector          [description]\r\n     * @param  {[type]} force\r\n     * @return {[type]}                    [description]\r\n     */\r\n    ConnectionManager.prototype.refreshConnector = function (connector, force) {\r\n        // 只有需要强制刷新  或者 连线为空（<2)时 才进行重新计算重绘\r\n        if (force || (!connector.turningPoints) || (connector.turningPoints.length < 2)) {\r\n            if (connector.model && connector.model.get(\"style.lineType\")) {\r\n                connector.options.style.lineType = connector.model.get(\"style.lineType\");\r\n            }\r\n            var arrStartEndPoint = this.getStartEndPoint(connector);\r\n            var escapeDistance = null;\r\n            if (connector.options.position && connector.options.position.escapeDistance) {\r\n                escapeDistance = connector.options.position.escapeDistance;\r\n            }\r\n            var solutions = this.connector2Points(connector.options.style.lineType, arrStartEndPoint[0],\r\n                arrStartEndPoint[1],\r\n                arrStartEndPoint[2], arrStartEndPoint[3], escapeDistance); // TYPE_STRAIGHT TYPE_JAGGED\r\n\r\n            connector.refresh(solutions[0][2]);\r\n        }\r\n\r\n        connector.clearHandles(); //清空handle\r\n    }\r\n\r\n\r\n    ConnectionManager.prototype.getStartEndPoint = function (connector) {\r\n        var startNode = connector.startNode;\r\n        var endNode = connector.endNode;\r\n        var isNotInSameGroup = true;\r\n        isNotInSameGroup = startNode.parent !== endNode.parent;\r\n\r\n        var sRect = startNode.getRect ? startNode.getRect().boundingRect : Util.getRect(startNode, isNotInSameGroup).boundingRect;\r\n        var sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(\r\n            sRect.y) + Number(sRect.height)];\r\n\r\n        var eRect = endNode.getRect ? endNode.getRect().boundingRect : Util.getRect(endNode, isNotInSameGroup).boundingRect;\r\n        var eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(\r\n            eRect.y) + Number(eRect.height)];\r\n\r\n\r\n        var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n        var eConnectorPoint = Util.getConnectorPoints(eRect);\r\n\r\n        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n        var position = connector.options.position;\r\n        if (position.direction) {\r\n            var posArr = position.direction.split(',');\r\n            position.startPos = posArr[0];\r\n            position.endPos = posArr[1];\r\n        }\r\n        if (!position.startPos || !position.endPos) {\r\n            if (sRect.x < eRect.x) {\r\n                position.startPos = \"right\";\r\n                position.endPos = \"left\";\r\n            } else {\r\n                position.startPos = \"left\";\r\n                position.endPos = \"right\";\r\n            }\r\n        }\r\n        var startPoint = this.calcPointExpression(position.startPos, sConnectorPoint);\r\n        var endPoint = this.calcPointExpression(position.endPos, eConnectorPoint);\r\n        startPoint.add(new Point(position.startOffset[0], position.startOffset[1]));\r\n        endPoint.add(new Point(position.endOffset[0], position.endOffset[1]));\r\n        return [startPoint, endPoint, sBounds, eBounds];\r\n    }\r\n\r\n    ConnectionManager.prototype.calcPointExpression = function (pos, point) {\r\n        var variable = {\r\n            top: point.top.x,\r\n            left: point.left.y,\r\n            right: point.right.y,\r\n            bottom: point.bottom.x,\r\n            center: point.center.x\r\n        };\r\n\r\n        var expression = \"<% print(\" + pos + \") %>\";\r\n        var val = parseInt(Util.template(expression)(variable));\r\n        if (pos.indexOf(\"top\") != -1) {\r\n            return new Point(val, point.top.y);\r\n        } else if (pos.indexOf(\"left\") != -1) {\r\n            return new Point(point.left.x, val);\r\n        } else if (pos.indexOf(\"right\") != -1) {\r\n            return new Point(point.right.x, val);\r\n        } else if (pos.indexOf(\"bottom\") != -1) {\r\n            return new Point(val, point.bottom.y);\r\n        } else if (pos.indexOf(\"center\") != -1) {\r\n            return new Point(val, point.bottom.y);\r\n        } else {\r\n            throw new Error(\"pos参数错误\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 创建或修改临时线\r\n     * @param  {[type]} startNode             [description]\r\n     * @param  {[type]} rEndPoint             [description]\r\n     * @param  {[type]} lineType              [description]\r\n     * @param  {[type]} startPos              [description]\r\n     * @return {[type]}                       [description]\r\n     */\r\n    ConnectionManager.prototype.manageTempConnector = function (startNode, rEndPoint, lineType, startPos) {\r\n\r\n        var sRect = startNode.getRect ? startNode.getRect().boundingRect : Util.getRect(startNode,true).boundingRect;\r\n\r\n        var sBounds = [sRect.x, sRect.y, sRect.x + sRect.width, sRect.y + sRect.height];\r\n        var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n\r\n        if (!this.tempConnector) {\r\n            this.tempConnector = new Connector({\r\n                isEdit: false,\r\n                style: {\r\n                    lineType: lineType\r\n                }\r\n            });\r\n        }\r\n\r\n        var connector = this.tempConnector;\r\n        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n        var position = connector.options.position;\r\n        position.startPos = startPos ? startPos : (sRect.x < rEndPoint.x ? \"right\" : \"left\");\r\n        position.endPos = sRect.x < rEndPoint.x ? \"left\" : \"right\";\r\n        \r\n        connector.options.style.lineType = lineType;\r\n        var solutions = this.connector2Points(lineType, sConnectorPoint[position.startPos], rEndPoint,\r\n            sBounds, null); // TYPE_STRAIGHT TYPE_JAGGED\r\n\r\n        connector.refresh(solutions[0][2]);\r\n        return connector;\r\n    }\r\n\r\n    /**\r\n     * 创建或修改临时反转线\r\n     * @param  {[type]} startPoint              [description]\r\n     * @param  {[type]} endNode                 [description]\r\n     * @param  {[type]} lineType                [description]\r\n     * @param  {[type]} endPos                  [description]\r\n     * @return {[type]}                         [description]\r\n     */\r\n    ConnectionManager.prototype.manageReverseTempConnector = function (startPoint, endNode, lineType, endPos) {\r\n        var eRect = endNode.getRect ? endNode.getRect().boundingRect : Util.getRect(endNode,true).boundingRect;\r\n        var eBounds = [eRect.x, eRect.y, eRect.x + eRect.width, eRect.y + eRect.height];\r\n        var eConnectorPoint = Util.getConnectorPoints(eRect);\r\n        if (!this.tempConnector) {\r\n            this.tempConnector = new Connector({\r\n                isEdit: false,\r\n                style: {\r\n                    lineType: lineType\r\n                }\r\n            });\r\n        }\r\n        var connector = this.tempConnector;\r\n        var position = connector.options.position;\r\n        position.endPos = endPos ? endPos : (eRect.x < startPoint.x ? \"right\" : \"left\");\r\n        position.startPos = eRect.x < startPoint.x ? \"left\" : \"right\";\r\n        \r\n        connector.options.style.lineType = lineType;\r\n        var solutions = this.connector2Points(lineType, startPoint, eConnectorPoint[position.endPos],\r\n            eBounds, null); // TYPE_STRAIGHT TYPE_JAGGED\r\n\r\n        connector.refresh(solutions[0][2]);\r\n        return connector;\r\n    }\r\n\r\n    /**\r\n     * 删除临时线\r\n     * @param  {[type]} zr             [description]\r\n     */\r\n    ConnectionManager.prototype.removeTempConnector = function (zr) {\r\n        if (this.tempConnector) {\r\n            zr.remove(this.tempConnector);\r\n            this.tempConnector = null;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 算出 两个节点 指定两个点如何联线\r\n     * @param  {[type]} type       [description]\r\n     * @param  {[type]} startPoint [description]\r\n     * @param  {[type]} endPoint   [description]\r\n     * @param  {[type]} sBounds    [description]\r\n     * @param  {[type]} eBounds    [description]\r\n     * @return {[type]}            [description]\r\n     */\r\n    ConnectionManager.prototype.connector2Points = function (type, startPoint, endPoint, sBounds, eBounds,\r\n        escapeDistance) {\r\n        var figureEscapeDistance = [30, 30];\r\n        if (escapeDistance) {\r\n            if (!zrUtil.isArray(escapeDistance)) {\r\n                figureEscapeDistance = [escapeDistance, escapeDistance];\r\n            } else {\r\n                figureEscapeDistance = escapeDistance;\r\n            }\r\n        }\r\n\r\n        Log.group(\"connectionManager: connector2Points\");\r\n\r\n\r\n        Log.info(\"ConnectionManager: connector2Points (\" + type + \", \" + startPoint + \", \" + endPoint +\r\n            \", \" + sBounds + \", \" + eBounds + ')');\r\n        var solutions = [];\r\n\r\n\r\n\r\n        switch (type) {\r\n            case Connector.TYPE_CHAIN:\r\n            \r\n            case Connector.TYPE_STRAIGHT: //直线\r\n                var points = [startPoint.clone(), endPoint.clone()];\r\n                solutions.push(['straight', 'straight', points]);\r\n                break;\r\n\r\n            case Connector.TYPE_CURVE: //曲线\r\n\r\n            case Connector.TYPE_JAGGED: //折线\r\n                var startExitPoint = null;\r\n                var endExitPoint = null;\r\n\r\n                //find start exit point  寻找开始出口\r\n                if (sBounds != null) {\r\n                    var potentialExits = [];\r\n\r\n                    potentialExits.push(new Point(startPoint.x, sBounds[1] - figureEscapeDistance[0])); //north 北\r\n                    potentialExits.push(new Point(sBounds[2] + figureEscapeDistance[0], startPoint.y)); //east  东\r\n                    potentialExits.push(new Point(startPoint.x, sBounds[3] + figureEscapeDistance[0])); //south  南\r\n                    potentialExits.push(new Point(sBounds[0] - figureEscapeDistance[0], startPoint.y)); //west  西\r\n\r\n                    //pick closest exit point  寻找与 startPoint 最靠近的出口点\r\n                    startExitPoint = potentialExits[0];\r\n                    for (var i = 1; i < potentialExits.length; i++) {\r\n                        if (Util.distance(startPoint, potentialExits[i]) < Util.distance(startPoint,\r\n                                startExitPoint)) {\r\n                            startExitPoint = potentialExits[i];\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n                //find end exit point  寻找结束出口\r\n                if (eBounds != null) {\r\n                    var potentialExits = [];\r\n\r\n                    potentialExits.push(new Point(endPoint.x, eBounds[1] - figureEscapeDistance[1])); //north\r\n                    potentialExits.push(new Point(eBounds[2] + figureEscapeDistance[1], endPoint.y)); //east\r\n                    potentialExits.push(new Point(endPoint.x, eBounds[3] + figureEscapeDistance[1])); //south\r\n                    potentialExits.push(new Point(eBounds[0] - figureEscapeDistance[1], endPoint.y)); //west\r\n\r\n                    //pick closest exit point  寻找与 endPoint 最靠近的出口点\r\n                    endExitPoint = potentialExits[0];\r\n                    for (var i = 1; i < potentialExits.length; i++) {\r\n                        if (Util.distance(endPoint, potentialExits[i]) < Util.distance(endPoint,\r\n                                endExitPoint)) {\r\n                            endExitPoint = potentialExits[i];\r\n                        }\r\n                    }\r\n                }\r\n\r\n                //Basic solution 最基本的解决方案   为其他解决方案做准备\r\n                var s = [startPoint];\r\n                var gapIndex = 0; //the index of the gap (where do we need to insert new points) DO NOT CHANGE IT\r\n                if (startExitPoint) {\r\n                    s.push(startExitPoint);\r\n                    gapIndex = 1;\r\n                }\r\n                if (endExitPoint) {\r\n                    s.push(endExitPoint);\r\n                }\r\n                s.push(endPoint);\r\n\r\n\r\n\r\n                //SO - no additional points     S0 解决方案 不添加任何点  基本不会被采用\r\n                var s0 = Point.cloneArray(s);\r\n                solutions.push(['s0', 's0', s0]);\r\n\r\n\r\n\r\n                //S1   S1 解决方案  只有一个折点\r\n                var s1 = Point.cloneArray(s);\r\n\r\n                //first variant   第一个变体 s1 s1_1方案  折线点在 startExitPoint的X 与 endExitPoint的 Y位置\r\n                var s1_1 = Point.cloneArray(s1);\r\n                s1_1.splice(gapIndex + 1, 0, new Point(s1_1[gapIndex].x, s1_1[gapIndex + 1].y));\r\n                solutions.push(['s1', 's1_1', s1_1]);\r\n\r\n                //second variant  第二变体 s1 s1-2方案  折线点在 endExitPoint的X 与  startExitPoint的Y位置\r\n                var s1_2 = Point.cloneArray(s1);\r\n                s1_2.splice(gapIndex + 1, 0, new Point(s1_2[gapIndex + 1].x, s1_2[gapIndex].y));\r\n                solutions.push(['s1', 's1_2', s1_2]);\r\n\r\n\r\n                //S2  S2 解决方案  添加两个折点\r\n\r\n                //Variant I   s2_1方案\r\n                var s2_1 = Point.cloneArray(s);\r\n                var s2_1_1 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex].y);\r\n                var s2_1_2 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex + 1].y);\r\n                s2_1.splice(gapIndex + 1, 0, s2_1_1, s2_1_2);\r\n                solutions.push(['s2', 's2_1', s2_1]);\r\n\r\n\r\n                //Variant II  s2_1方案  1折线点 x: startExitPoint的X 位置 y: startExitPoint的y+endExitPoint的y/2\r\n                //1折线点 x:endExitPoint的x  y:startExitPoint的y+endExitPoint的y/2\r\n                var s2_2 = Point.cloneArray(s);\r\n                var s2_2_1 = new Point(s2_2[gapIndex].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);\r\n                var s2_2_2 = new Point(s2_2[gapIndex + 1].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);\r\n                s2_2.splice(gapIndex + 1, 0, s2_2_1, s2_2_2);\r\n                solutions.push(['s2', 's2_2', s2_2]);\r\n\r\n\r\n                //Variant III\r\n                var s2_3 = Point.cloneArray(s);\r\n                //find the amount (stored in delta) of pixels we need to move right so no intersection with a figure will be present\r\n                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\r\n                var eastExits = [s2_3[gapIndex].x + 20, s2_3[gapIndex + 1].x + 20]; //add points X coordinates to be able to generate Variant III even in the absence of figures :p\r\n\r\n                if (sBounds) {\r\n                    eastExits.push(sBounds[2] + 20);\r\n                }\r\n\r\n                if (eBounds) {\r\n                    eastExits.push(eBounds[2] + 20);\r\n                }\r\n\r\n                var eastExit = Util.max(eastExits);\r\n                var s2_3_1 = new Point(eastExit, s2_3[gapIndex].y);\r\n                var s2_3_2 = new Point(eastExit, s2_3[gapIndex + 1].y);\r\n                s2_3.splice(gapIndex + 1, 0, s2_3_1, s2_3_2);\r\n                solutions.push(['s2', 's2_3', s2_3]);\r\n\r\n\r\n                //Variant IV  s2_4方案\r\n                var s2_4 = Point.cloneArray(s);\r\n                //find the amount (stored in delta) of pixels we need to move up so no intersection with a figure will be present\r\n                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\r\n                var northExits = [s2_4[gapIndex].y - 20, s2_4[gapIndex + 1].y - 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p\r\n\r\n                if (sBounds) {\r\n                    northExits.push(sBounds[1] - 20);\r\n                }\r\n\r\n                if (eBounds) {\r\n                    northExits.push(eBounds[1] - 20);\r\n                }\r\n\r\n                var northExit = Util.min(northExits);\r\n                var s2_4_1 = new Point(s2_4[gapIndex].x, northExit);\r\n                var s2_4_2 = new Point(s2_4[gapIndex + 1].x, northExit);\r\n                s2_4.splice(gapIndex + 1, 0, s2_4_1, s2_4_2);\r\n                solutions.push(['s2', 's2_4', s2_4]);\r\n\r\n\r\n                //Variant V\r\n                var s2_5 = Point.cloneArray(s);\r\n                //find the amount (stored in delta) of pixels we need to move left so no intersection with a figure will be present\r\n                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\r\n                var westExits = [s2_5[gapIndex].x - 20, s2_5[gapIndex + 1].x - 20]; //add points x coordinates to be able to generate Variant III even in the absence of figures :p\r\n\r\n                if (sBounds) {\r\n                    westExits.push(sBounds[0] - 20);\r\n                }\r\n\r\n                if (eBounds) {\r\n                    westExits.push(eBounds[0] - 20);\r\n                }\r\n\r\n                var westExit = Util.min(westExits);\r\n                var s2_5_1 = new Point(westExit, s2_5[gapIndex].y);\r\n                var s2_5_2 = new Point(westExit, s2_5[gapIndex + 1].y);\r\n                s2_5.splice(gapIndex + 1, 0, s2_5_1, s2_5_2);\r\n                solutions.push(['s2', 's2_5', s2_5]);\r\n\r\n\r\n                //Variant VI\r\n                var s2_6 = Point.cloneArray(s);\r\n                //find the amount (stored in delta) of pixels we need to move down so no intersection with a figure will be present\r\n                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\r\n                var southExits = [s2_6[gapIndex].y + 20, s2_6[gapIndex + 1].y + 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p\r\n\r\n                if (sBounds) {\r\n                    southExits.push(sBounds[3] + 20);\r\n                }\r\n\r\n                if (eBounds) {\r\n                    southExits.push(eBounds[3] + 20);\r\n                }\r\n\r\n                var southExit = Util.max(southExits);\r\n                var s2_6_1 = new Point(s2_6[gapIndex].x, southExit);\r\n                var s2_6_2 = new Point(s2_6[gapIndex + 1].x, southExit);\r\n                s2_6.splice(gapIndex + 1, 0, s2_6_1, s2_6_2);\r\n                solutions.push(['s2', 's2_6', s2_6]);\r\n\r\n\r\n\r\n                //FILTER solutions\r\n\r\n                /*Algorithm\r\n                 * 0. solutions are ordered from minimmun nr of points to maximum >:)\r\n                 * 1. remove all solutions that are not orthogonal (mainly s0 solution)\r\n                 * 2. remove all solutions that go backward (we will not need them ever)\r\n                 * 3. remove all solutions with intersections\r\n                 * 4. pick first class of solutions with same nr of points (ex: 2)\r\n                 * 5. pick the first solution with 90 degree angles (less turnarounds)\r\n                 * (not interesteted) sort by length :p\r\n                 */\r\n\r\n                //1. filter non ortogonal solutions 删除不是正交直线的方案\r\n                Log.info(\"Filter orthogonal solutions. Initial number of solutions = \" + solutions.length);\r\n                var orthogonalSolution = [];\r\n                for (var l = 0; l < solutions.length; l++) {\r\n                    var solution = solutions[l][2];\r\n                    if (Util.orthogonalPath(solution)) {\r\n                        orthogonalSolution.push(solutions[l]);\r\n                    }\r\n                }\r\n                solutions = orthogonalSolution;\r\n                Log.info(\"\\n\\tOrthogonalSolutions = \" + solutions.length);\r\n\r\n                //2. filter backward solutions  过滤 倒退的方案\r\n                //do not allow start and end points to coincide - ignore them\r\n                if (startPoint.equals(endPoint)) {\r\n                    Log.info(\r\n                        \"Start and end point coincide...skip backward solution. I think we will just fall on s0 :)\"\r\n                    );\r\n                } else {\r\n                    Log.info(\"Filter backward solutions. Initial number of solutions = \" + solutions.length);\r\n                    var forwardSolutions = [];\r\n                    var temp = '';\r\n                    for (var l = 0; l < solutions.length; l++) {\r\n                        var solution = solutions[l][2];\r\n                        if (Util.forwardPath(solution)) {\r\n                            forwardSolutions.push(solutions[l]);\r\n                        } else {\r\n                            temp = temp + \"\\n\\t\" + solution;\r\n                        }\r\n                    }\r\n                    solutions = forwardSolutions;\r\n                    Log.info(\"\\n\\t ForwardSolutions = \" + solutions.length);\r\n                    if (solutions.length == 0) {\r\n                        Log.info(\"Discarded solutions: \" + temp);\r\n                    }\r\n                }\r\n\r\n\r\n                //3. Filter non intersecting solutions  去除没有交集()的方案\r\n                Log.info(\"Filter non intersecting solutions. Initial number of solutions = \" + solutions.length);\r\n                var nonIntersectionSolutions = []\r\n                for (var l = 0; l < solutions.length; l++) {\r\n                    var solution = solutions[l][2];\r\n                    //Log.info(\"Solution id= \" + solutions[l][1] + ' nr points = ' + solution.length + \", points = \" + solution);\r\n                    var intersect = false;\r\n\r\n                    var innerLines = solution.slice(); //just a shallow copy\r\n\r\n                    /*If any bounds just trim the solution. So we avoid the strange case when a connection\r\n                     *startes from a point on a figure and ends inside of the same figure, but not on a connection point*/\r\n                    if (eBounds || sBounds) {\r\n                        //i0nnerLines = innerLines.slice(0, innerLines.length - 1);\r\n                        innerLines = innerLines.slice(1, innerLines.length - 1);\r\n                        //Log.info(\"\\t eBounds present,innerLines nr. points = \" + innerLines.length + \", points = \" + innerLines);\r\n                    }\r\n\r\n\r\n\r\n                    //now test for intersection\r\n                    if (sBounds) {\r\n                        intersect = intersect || Util.polylineIntersectsRectangle(innerLines, sBounds);\r\n                    }\r\n                    if (eBounds) {\r\n                        intersect = intersect || Util.polylineIntersectsRectangle(innerLines, eBounds);\r\n                    }\r\n\r\n                    if (!intersect) {\r\n                        nonIntersectionSolutions.push(solutions[l]);\r\n                    }\r\n                }\r\n\r\n                //If all solutions intersect than this is destiny  :) and just ignore the intersection filter\r\n                if (nonIntersectionSolutions.length != 0) {\r\n                    //reasign to solutions\r\n                    solutions = nonIntersectionSolutions;\r\n                }\r\n\r\n                Log.info(\"\\n\\t nonIntersectionSolutions = \" + solutions.length);\r\n\r\n\r\n                //4. get first class of solutions with same nr of points 选择与第一个方案点数一样多的方案（因为第一个方案点数最少）\r\n                Log.info(\"Get first class of solutions with same nr of points\");\r\n                if (solutions.length == 0) {\r\n                    Log.info(\"This is not possible\");\r\n                }\r\n\r\n                var firstSolution = solutions[0][2]; //pick first solution\r\n                var nrOfPoints = firstSolution.length;\r\n                var sameNrPointsSolution = [];\r\n\r\n                for (var l = 0; l < solutions.length; l++) {\r\n                    var solution = solutions[l][2];\r\n                    if (solution.length == nrOfPoints) {\r\n                        sameNrPointsSolution.push(solutions[l]);\r\n                    }\r\n                }\r\n\r\n                solutions = sameNrPointsSolution;\r\n\r\n\r\n\r\n\r\n                /*5.  计算路径分数 ，取最分数高的\r\n                 Pick the first solution with 90 degree angles (less turnarounds)\r\n                 *in case we have more than one solution in our class\r\n                 */\r\n                Log.info(\"pick the first solution with 90 degree angles (less turnarounds)\");\r\n                var solIndex = 0;\r\n                for (var l = 0; l < solutions.length; l++) {\r\n                    var solution = solutions[l][2];\r\n                    if (Util.scorePath(solutions[solIndex][2]) < Util.scorePath(solutions[l][2])) {\r\n                        solIndex = l;\r\n                    }\r\n                }\r\n                solutions = [solutions[solIndex]];\r\n\r\n\r\n                break;\r\n        }\r\n\r\n        //SMOOTHING curve\r\n        if (type === Connector.TYPE_CURVE) {\r\n            this.smoothCurve(solutions);\r\n        }\r\n        //END SMOOTHING curve\r\n\r\n        Log.groupEnd();\r\n\r\n        return solutions;\r\n    }\r\n\r\n    ConnectionManager.prototype.smoothCurve = function (solutions) {\r\n        var option = 3;\r\n\r\n        switch (option) {\r\n            case 0:\r\n                //do nothing\r\n                break;\r\n\r\n            case 1: //add intermediate points\r\n                //Add the middle point for start and end segment so that we \"force\" the\r\n                //curve to both come \"perpendicular\" on bounds and also make the curve\r\n                //\"flee\" more from bounds (on exit)\r\n                for (var s = 0; s < solutions.length; s++) {\r\n                    var solTurningPoints = solutions[s][2];\r\n\r\n                    //first segment\r\n                    var a1 = solTurningPoints[0];\r\n                    var a2 = solTurningPoints[1];\r\n                    var startMiddlePoint = Util.getMiddle(a1, a2);\r\n                    solTurningPoints.splice(1, 0, startMiddlePoint);\r\n\r\n                    //last segment\r\n                    var a3 = solTurningPoints[solTurningPoints.length - 2];\r\n                    var a4 = solTurningPoints[solTurningPoints.length - 1];\r\n                    var endMiddlePoint = Util.getMiddle(a3, a4);\r\n                    solTurningPoints.splice(solTurningPoints.length - 1, 0, endMiddlePoint);\r\n                }\r\n                break;\r\n\r\n            case 2: //remove points\r\n\r\n                zrUtil.each(solutions, function(solution) {\r\n                    var solType = solution[0];\r\n                    if (solType == 's1' || solType == 's2') {\r\n                        var solTurningPoints = solution[2];\r\n                        solTurningPoints.splice(1, 1);\r\n                        solTurningPoints.splice(solTurningPoints.length - 2, 1);\r\n                    }\r\n                });\r\n                break;\r\n\r\n            case 3:\r\n                /*remove colinear point for s1 as it seems that more colinear points do not look good\r\n                 * on organic solutions >:D*/\r\n                zrUtil.each(solutions, function(solution) {\r\n                    var solType = solution[0];\r\n                    if (solType == 's1') {\r\n                        var solTurningPoints = solution[2];\r\n                        var reducedSolution = Util.collinearReduction(solTurningPoints);\r\n                        solution[2] = reducedSolution;\r\n                    }\r\n                });\r\n                break;\r\n        } //end switch\r\n\r\n    }\r\n\r\n    module.exports = ConnectionManager;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/manager/ConnectionManager.js\n// module id = 89\n// module chunks = 0","/**\r\n * 日志类\r\n * @author wang.xiaohu\r\n */\r\n\r\n\r\n    var Log  = {\r\n        LOG_LEVEL_NONE  : 0,\r\n\r\n        LOG_LEVEL_DEBUG : 1,\r\n\r\n        LOG_LEVEL_INFO : 2,\r\n\r\n        LOG_LEVEL_ERROR : 3,\r\n\r\n        level : this.LOG_LEVEL_ERROR,\r\n        \r\n        /**\r\n        * The less important of all messages\r\n        * @param {String} message - the message to be logged\r\n        **/\r\n        debug: function (message){\r\n            if(typeof console !== 'undefined'){\r\n                if(this.level <= this.LOG_LEVEL_DEBUG){\r\n                    \r\n                    //in FF is debug\r\n                    if(typeof console.debug == 'function'){\r\n                        console.debug(message);\r\n                    }\r\n                    else{//TODO: in IE is log\r\n    //                    console.info(message);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n\r\n        /**\r\n        * The commonly used log message\r\n        * @param {String} message - the message to be logged\r\n        **/\r\n        info : function (message){\r\n            if(typeof console !== 'undefined'){\r\n                if(this.level <= this.LOG_LEVEL_INFO){\r\n                    console.info(message);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n        * The worse kind of message. Usually a crash\r\n        * @param {String} message - the message to be logged\r\n        **/\r\n        error : function (message){\r\n            if(typeof console !== 'undefined'){\r\n                if(this.level <= this.LOG_LEVEL_ERROR){\r\n                    console.error(message);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         *Start grouping the log messages\r\n         *@param {String} title - the title of the group\r\n         *@see <a href=\"http://getfirebug.com/logging\">http://getfirebug.com/logging</a>\r\n         **/\r\n        group : function(title){\r\n            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info\r\n                if(typeof console !== 'undefined'){           \r\n                    /**If we do not test for group() function you will get an error in Opera\r\n                     *as Opera has it's own console...which does not have a group() function*/\r\n                    if(typeof console.group === 'function'){\r\n                        console.group(title);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        /**Ends current message grouping*/\r\n        groupEnd : function(){\r\n            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info\r\n                if(typeof console !== 'undefined'){\r\n                    /**If we do not test for groupEnd() function you will get an error in Opera\r\n                     *as Opera has it's own console...which does not have a group() function*/\r\n                    if(typeof console.groupEnd === 'function'){\r\n                        console.groupEnd();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    };\r\n\r\n    //Log.level = Log.LOG_LEVEL_DEBUG; \r\n    Log.level = Log.LOG_LEVEL_ERROR; \r\n    //Log.level = Log.LOG_LEVEL_ERROR;\r\n    //Log.level = Log.LOG_LEVEL_NONE;\r\n    module.exports = Log;\r\n    \r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/Log.js\n// module id = 90\n// module chunks = 0","/**\r\n * 常量定义\r\n */\r\n\r\n\tmodule.exports = \t{\r\n\t\tELEMENT_TYPE: \"elementType\",\r\n\t\tMODE: \"mode\",\r\n\t\tBACKGROUND: \"backgroud\",\r\n\t\tOPTIONS: \"options\",\r\n\t\tUSERDATA: \"userData\",\r\n\t\tID: \"id\",\r\n\t\tSTART_ID: \"startNodeId\",\r\n\t\tEND_ID: \"endNodeId\",\r\n\t\tALARM: \"Alarm\",\r\n\t\tRELATIONID:\"relationId\",\r\n\t\tRELATION_IMAGE:\"relationImage\",\r\n\t\tGROUP: \"Group\",\r\n\t\tCONNECTION: \"connection\",\r\n\t\tCHILDS: \"childs\",\r\n\t\tTREE_ROOT: \"treeRoot\",\r\n\t\tDOCKERS:\"options.dockers\",\r\n\t\tSTYLE_LINETYPE:\"style.lineType\",\r\n\t\tLINEOPERATIONICON:\"LineOperationIcon\",\r\n\t};\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-link/lib/util/LinkConstants.js\n// module id = 91\n// module chunks = 0","/**\r\n * Link工具类\r\n */\r\n\r\n    var Model = require(\"../../../fish-topo-core/lib/model.js\");\r\n    var Constants = require(\"./LinkConstants.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n    /**\r\n     * 根据结点数组 导出JSON格式的数据\r\n     *\r\n     * @param {Array} model 总的模型\r\n     * @return {JSON} JSON格式的数据\r\n     */\r\n    function toJson(model, group) {\r\n        var jsonArr = [];\r\n        group.eachChild(function(node) {\r\n            if (node.model) {\r\n                if (node instanceof Connector) {\r\n                    node.refreshModel();\r\n                };\r\n                jsonArr.push(node.model.option);\r\n\r\n            }\r\n\r\n\r\n        })\r\n        model.set(Constants.CHILDS, jsonArr);\r\n        return model.option;\r\n    }\r\n\r\n    /**\r\n     * 根据 JSON 生成节点\r\n     * @param  {[type]} fishTopolink [description]\r\n     * @param  {[type]} json         [description]\r\n     * @return {[type]}              [description]\r\n     */\r\n    function fromJson(fishTopolink, group, childShapes, isChild, layoutRootNode) {\r\n        // 1.清空画布\r\n\r\n        var connectors = [];\r\n        // 2.先创建节点  遍历形状 获取模型\r\n\r\n\r\n        for (var i = 0; i < childShapes.length; i++) {\r\n            var line = childShapes[i];\r\n            var link = fishTopolink.createLinkOfPoints(line.options,line.userData);\r\n            if (isChild) {\r\n                group.add(link);\r\n            } else {\r\n                fishTopolink.addNode(link);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 根据id在group中查找\r\n     * @param  {[type]} group  [description]\r\n     * @param  {[type]} nodeId [description]\r\n     * @return {[type]}        [description]\r\n     */\r\n    function findNodeById (group, nodeId) {\r\n        var retNode = null;\r\n        group.eachChild(function(node) {\r\n            if (node.model && node.model.get(Constants.ID) === nodeId) {\r\n                retNode = node;\r\n            };\r\n        })\r\n        return retNode;\r\n    }\r\n\r\n\r\n    /**\r\n     * Get canvas which has all thing rendered\r\n     * @param {Object} opts\r\n     * @param {string} [opts.backgroundColor]\r\n     */\r\n    function getRenderedCanvas(zr, opts) {\r\n        opts = opts || {};\r\n        opts.pixelRatio = opts.pixelRatio || 1;\r\n        opts.backgroundColor = opts.backgroundColor\r\n            || \"#FFFFFF\";\r\n        var list = zr.storage.getDisplayList();\r\n        // Stop animations\r\n        zrUtil.each(list, function (el) {\r\n            el.stopAnimation(true);\r\n        });\r\n        return zr.painter.getRenderedCanvas(opts);\r\n    }\r\n\r\n    function toDataURL (zr, opts) {\r\n        opts = opts || {};\r\n        var url = getRenderedCanvas(zr, opts).toDataURL(\r\n            'image/' + (opts && opts.type || 'png')\r\n        );\r\n        return url;\r\n    }\r\n\r\n\r\n    function initNodeEvent (node, api) {\r\n        var MOUSE_EVENT_NAMES = ['dblclick', 'click'];//'click', 'dblclick', 'mouseover', 'mouseout'\r\n\r\n\r\n        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n            node.on(eveName, function (e) {\r\n                var params = {};\r\n                params.event = e;\r\n                params.type = eveName;\r\n                params.target = node;\r\n                api.trigger(eveName, params);\r\n            });\r\n        });\r\n    }\r\n\r\n    module.exports = {\r\n        toJson: toJson,\r\n        fromJson: fromJson,\r\n        toDataURL:toDataURL\r\n    };\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-link/lib/util/LinkUtil.js\n// module id = 92\n// module chunks = 0","/**\r\n * 连线操作类\r\n * @author miao.cunzhi\r\n */\r\n\r\n    var symbolUtil = require('../shapes/Symbol');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var icon = require('./IconOperation');\r\n    function LineOperationManager(connectionManager, api) {\r\n        this.lineOperations = [],\r\n        this.isEdit = true;\r\n        this.connectionManager = connectionManager;\r\n        this._api = api;\r\n    }\r\n\r\n    /**\r\n     *  this.lineOperationManager.addIcon(key, options);\r\n     */\r\n    LineOperationManager.prototype.addIcon = function(key, options) {\r\n        //判断是小图标否存在 ，存在则直接返回\r\n        var lineOperationIcon = zrUtil.find(options.lineNode.icons, function(icon) {\r\n            return icon.key === key;\r\n        });\r\n\r\n        if (lineOperationIcon) {\r\n            this.bindOperation(options.lineNode);\r\n            return;\r\n        }else {\r\n            var lineOperation = this.creatOperation(key, options);\r\n            this._api._getParentZr().add(lineOperation);\r\n            this.bindOperation(options.lineNode);\r\n            return lineOperation;\r\n        }\r\n    }\r\n\r\n\r\n    LineOperationManager.prototype.creatOperation = function(key, options) {\r\n        var lineOperation = symbolUtil.createSymbol(options.iconPath, 0, 0, options.width || 15, options.height || 15, 0, options.color||'#aaaaac');\r\n        lineOperation.key = key;\r\n        lineOperation._width =  options.width || 15;  // path情况下无法计算\r\n        lineOperation._isLineOperationIcon = true;\r\n        lineOperation.hide();\r\n        options.lineNode.icons.push(lineOperation);\r\n        this.lineOperations.push(lineOperation);\r\n\r\n        //小图标 点击事件  如果有回调则调用回调，否则派发事件\r\n        lineOperation.on(\"click\", function(event) {\r\n            if (options.callback) {\r\n                event.data = options;\r\n                event.lineNode = options.lineNode;\r\n                options.callback(event);\r\n            } else {\r\n                var params = {};\r\n                params.event = event;\r\n                params.type = \"click\";\r\n                params.elementType = \"LineOperationIcon\";\r\n                this._api.trigger(params.type, params);\r\n            }\r\n        }.bind(this));\r\n        return lineOperation;\r\n    }\r\n\r\n    /**\r\n     * 计算小图标的位置，并显示\r\n     * @param  {[type]} connector [description]\r\n     * @return {[type]}           [description]\r\n     */\r\n    LineOperationManager.prototype.bindOperation = function(connector) {\r\n        function parentX(node) {\r\n            if (node.parent && node.parent.nodeType == \"SubProcess\") {\r\n                return node.position[0] + parentX(node.parent)\r\n            } else {\r\n                return node.position[0]\r\n            }\r\n        }\r\n    \r\n        function parentY(node) {\r\n            if (node.parent && node.parent.nodeType == \"SubProcess\") {\r\n                return node.position[1] + parentY(node.parent)\r\n            } else {\r\n                return node.position[1]\r\n            }\r\n        }\r\n\r\n        if (this.isEdit == false) {\r\n            return;\r\n        }\r\n        var pointPosition = connector.middle(), posX, posY;\r\n        if (connector.parent && connector.parent.nodeType == \"SubProcess\") {\r\n            posX = pointPosition[0] + parentX(connector.parent);\r\n            posY = pointPosition[1] + parentY(connector.parent);\r\n        } else {\r\n            posX = pointPosition[0];\r\n            posY = pointPosition[1];\r\n        }\r\n\r\n        var arrLength = zrUtil.map(connector.icons, function(icon) {\r\n            return icon._width;\r\n        });\r\n\r\n        var totalLength = zrUtil.reduce(arrLength, function(previousValue,currentValue) {\r\n            return previousValue + currentValue + 10;\r\n        }, 0 );\r\n\r\n        zrUtil.each(connector.icons, function(icon, index) {\r\n            var connectorPosition = 0;\r\n            for (var k = 0; k < index; k++) {\r\n                connectorPosition += arrLength[k] + 10;\r\n            }\r\n            icon.attr(\"position\", [posX + connectorPosition - totalLength / 2, posY + 5]);\r\n            icon.show();\r\n            icon.attachLine = connector;\r\n        })\r\n    }\r\n\r\n    LineOperationManager.prototype.hideAllLineOperation = function() {\r\n        zrUtil.each(this.lineOperations, function(lineOperation) {\r\n            lineOperation.hide();\r\n        });\r\n    }\r\n\r\n    LineOperationManager.prototype.addDeleteIcon = function(lineNode,options) {\r\n        var opts = zrUtil.defaults({\r\n            iconPath: 'path://' + icon.DEL_SVG,\r\n            width: 12,\r\n            height: 14,\r\n            lineNode: lineNode,\r\n            callback: function(e) {\r\n                this._api.remove(e.target.attachLine);//this.connectionManager.selConnector);\r\n            }.bind(this)\r\n        }, options,true);\r\n\r\n        this.addIcon(\"delete\", opts);\r\n    }\r\n\r\n    LineOperationManager.prototype.addChangeLineTypeIcon = function(lineNode,options) {\r\n        var opts = zrUtil.defaults({\r\n            iconPath: 'path://' + icon.CHANGE_LINE_TYPE_SVG,\r\n            width: 15,\r\n            height: 15,\r\n            lineNode: lineNode,\r\n            callback: function () {\r\n                this._api.changeSelectConnectorType();\r\n            }.bind(this)\r\n        }, options,true);\r\n\r\n        this.addIcon(\"change\", opts)\r\n    }\r\n\r\n    module.exports = LineOperationManager;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/manager/LineOperationManager.js\n// module id = 93\n// module chunks = 0","/**\r\n * Link静态方法类\r\n * @class fish.topo.FishTopoLink.Link\r\n */\r\n\r\n\r\n    var Constants = require(\"./util/LinkConstants.js\");\r\n    var Flow = {\r\n        FLOW_TYPE: \"elementType\",\r\n        LINK: \"connection\",\r\n        RECT: \"Rect\",\r\n        Group: 'Group',\r\n        IMAGE: 'Image',\r\n        TEXT: 'Text',\r\n        CIRCLE: 'Circle',\r\n        SECTOR: 'Sector',\r\n        RING: 'Ring',\r\n        POLYGON: 'Polygon',\r\n        POLYLINE: 'Polyline',\r\n        LINE: 'Line',\r\n        BEZIERCURVE: 'Beziercurve',\r\n        ARC: 'Arc',\r\n        SCENE:'scene',\r\n\r\n        /**\r\n         * @method setUserData\r\n         * 设置用户数据\r\n         * @param {Object} node 需要设置数据的节点\r\n         * @param {Object} obj 数据\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //设置自定义数据\r\n         *      this.fishTopo.Flow.setUserData(rect, { customObj: \"rect\" });\r\n         */\r\n        setUserData: function(node, obj) {\r\n            node.model.set(Constants.USERDATA, obj);\r\n        },\r\n        /**\r\n         * 获取设置的用户数据\r\n         * @param {Object} node 需要获取数据的节点\r\n         * @return {String}      数据\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //获取自定义数据\r\n         *      this.fishTopo.Flow.getUserData(rect);\r\n         */\r\n        getUserData: function(node) {\r\n            return node.model.get(Constants.USERDATA);\r\n        },\r\n        /**\r\n         * 判断是否是连线\r\n         * @param {Object} model 对象的model\r\n         * @return {Boolean}      是 否\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //判断是否是连线\r\n         *      var nodeModel = e.target.model;\r\n         *      if (this.fishTopo.Flow.isLink(nodeModel)) { return true;}\r\n         */\r\n        isLink: function(model) {\r\n            var elementType = model.get(Flow.FLOW_TYPE);\r\n            return elementType == Flow.LINK;\r\n        },\r\n        /**\r\n         * 获取节点的类型\r\n         * @param {Object} model 节点的model\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //获取节点类型\r\n         *      var nodeModel = e.target.model;\r\n         *      return this.fishTopo.Flow.getType(nodeModel);\r\n         */\r\n        getType: function(model) {\r\n            var elementType = model.get(Flow.FLOW_TYPE);\r\n            return elementType;\r\n        }\r\n    };\r\n\r\n    module.exports = Flow;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-link/lib/Link.js\n// module id = 94\n// module chunks = 0","/**\r\n * 工具类\r\n * @class fishTopoFlow.util\r\n */\r\n\r\n/**\r\n * @method initImagePool\r\n * 初始化图片池  用于对图片加载进行管理\r\n * @param {number} max 最大连接数。数值。\r\n * @returns {{load: Function, info: Function}}\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n        var imagepool = fishTopoFlow.util.initImagePool(100);\r\n        imagepool.load(grayArray, {\r\n            success: function(imgs) {\r\n            },\r\n            once: true\r\n        });\r\n */\r\n\r\n/**\r\n * @method inherits\r\n * 构造类继承关系\r\n *\r\n * @param {Function} clazz 源类\r\n * @param {Function} baseClazz 基类\r\n */\r\n\r\n\r\n    var emptyFn = function() {};\r\n    //初始默认配置\r\n    var config_default = {\r\n        //线程池\"线程\"数量\r\n        thread: 5,\r\n        //图片加载失败重试次数\r\n        //重试2次，加上原有的一次，总共是3次\r\n        \"tries\": 2\r\n    };\r\n    //工具\r\n    var _helpers = {\r\n        //设置dom属性\r\n        setAttr: (function() {\r\n            var img = new Image();\r\n            //判断浏览器是否支持HTML5 dataset\r\n            if (img.dataset) {\r\n                return function(dom, name, value) {\r\n                    dom.dataset[name] = value;\r\n                    return value;\r\n                };\r\n            } else {\r\n                return function(dom, name, value) {\r\n                    dom.setAttribute(\"data-\" + name, value);\r\n                    return value;\r\n                };\r\n            }\r\n        }()),\r\n        //获取dom属性\r\n        getAttr: (function() {\r\n            var img = new Image();\r\n            //判断浏览器是否支持HTML5 dataset\r\n            if (img.dataset) {\r\n                return function(dom, name) {\r\n                    if(!dom.dataset[name]){\r\n                        return dom.getAttribute(\"data-\" + name);\r\n                    }else{\r\n                        return dom.dataset[name];\r\n                    }\r\n                };\r\n            } else {\r\n                return function(dom, name) {\r\n                    return dom.getAttribute(\"data-\" + name);\r\n                };\r\n            }\r\n        }())\r\n    };\r\n    /**\r\n     * 构造方法\r\n     * @private\r\n     * @param max 最大连接数。数值。\r\n     */\r\n    function ImagePool(max) {\r\n        //最大并发数量\r\n        this.max = max || config_default.thread;\r\n        this.linkHead = null;\r\n        this.linkNode = null;\r\n        //加载池\r\n        //[{img: dom,free: true, node: node}]\r\n        //node\r\n        //{src: \"\", options: {success: \"fn\",error: \"fn\", once: true}, tries: 0}\r\n        this.pool = [];\r\n    }\r\n    /**\r\n     * 初始化\r\n     * @private\r\n     */\r\n    ImagePool.prototype.initPool = function() {\r\n        var i, img, obj, _s;\r\n        _s = this;\r\n        for (i = 0; i < this.max; i++) {\r\n            obj = {};\r\n            img = new Image();\r\n            _helpers.setAttr(img, \"id\", i);\r\n            img.onload = function() {\r\n                //回调\r\n                _s.notice(_s.getNode(this), \"success\", this);\r\n                //处理任务\r\n                _s.executeLink(this);\r\n            };\r\n            img.onerror = function() {\r\n                var node = _s.getNode(this);\r\n                //判断尝试次数\r\n                if (node.tries < config_default.tries) {\r\n                    node.tries = node.tries+1;\r\n                    //再次追加到任务链表末尾\r\n                    _s.appendNode(_s.createNode(node.src, node.options, node.notice, node.group, node.tries));\r\n                } else {\r\n                    //error回调\r\n                    //node.options.error.call(null, this.src);\r\n                    _s.notice(node, \"error\", this);\r\n                }\r\n                //处理任务\r\n                _s.executeLink(this);\r\n            };\r\n            obj.img = img;\r\n            obj.free = true;\r\n            this.pool.push(obj);\r\n        }\r\n    };\r\n    /**\r\n     * 回调封装\r\n     * @private\r\n     * @param node 节点。对象。\r\n     * @param status 状态。字符串。可选值：success(成功)|error(失败)\r\n     * @param img 图片。\r\n     */\r\n    ImagePool.prototype.notice = function(node, status, img) {\r\n        node.notice(status, img);\r\n    };\r\n    /**\r\n     * 处理链表任务\r\n     * @private\r\n     * @param dom 图像dom对象。对象。\r\n     */\r\n    ImagePool.prototype.executeLink = function(dom) {\r\n        //判断链表是否存在节点\r\n        if (this.linkHead) {\r\n            //加载下一个图片\r\n            this.setSrc(dom, this.linkHead);\r\n            //去除链表头\r\n            this.shiftNode();\r\n        } else {\r\n            //设置自身状态为空闲\r\n            this.status(dom, true);\r\n        }\r\n    };\r\n    /**\r\n     * 获取空闲\"线程\"\r\n     * @private\r\n     */\r\n    ImagePool.prototype.getFree = function() {\r\n        var length, i;\r\n        for (i = 0, length = this.pool.length; i < length; i++) {\r\n            if (this.pool[i].free) {\r\n                return this.pool[i];\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * 封装src属性设置\r\n     * 因为改变src属性相当于加载图片，所以把操作封装起来\r\n     * @private\r\n     * @param dom 图像dom对象。对象。\r\n     * @param node 节点。对象。\r\n     */\r\n    ImagePool.prototype.setSrc = function(dom, node) {\r\n        //设置池中的\"线程\"为非空闲状态\r\n        this.status(dom, false);\r\n        //关联节点\r\n        this.setNode(dom, node);\r\n        //加载图片\r\n        dom.src = node.src;\r\n    };\r\n    /**\r\n     * 更新池中的\"线程\"状态\r\n     * @private\r\n     * @param dom 图像dom对象。对象。\r\n     * @param status 状态。布尔。可选值：true(空闲)|false(非空闲)\r\n     */\r\n    ImagePool.prototype.status = function(dom, status) {\r\n        var id = _helpers.getAttr(dom, \"id\");\r\n        if(id){\r\n            this.pool[id].free = status;\r\n        }\r\n\r\n        //空闲状态，清除关联的节点\r\n        if (status) {\r\n            this.pool[id].node = null;\r\n        }\r\n    };\r\n    /**\r\n     * 更新池中的\"线程\"的关联节点\r\n     * @private\r\n     * @param dom 图像dom对象。对象。\r\n     * @param node 节点。对象。\r\n     */\r\n    ImagePool.prototype.setNode = function(dom, node) {\r\n        var id = _helpers.getAttr(dom, \"id\");\r\n        if(id){\r\n            this.pool[id].node = node;\r\n            return this.pool[id].node === node;\r\n        }\r\n\r\n    };\r\n    /**\r\n     * 获取池中的\"线程\"的关联节点\r\n     * @private\r\n     * @param dom 图像dom对象。对象。\r\n     */\r\n    ImagePool.prototype.getNode = function(dom) {\r\n        var id = _helpers.getAttr(dom, \"id\");\r\n        if(id){\r\n            return this.pool[id].node;\r\n        }\r\n\r\n    };\r\n    /**\r\n     * 对外接口，加载图片\r\n     * @private\r\n     * @param src 可以是src字符串，也可以是src字符串数组。\r\n     * @param options 用户自定义参数。包含：success回调、error回调、once标识。\r\n     */\r\n    ImagePool.prototype._load = function(src, options) {\r\n        var srcs = [],\r\n            free = null,\r\n            length = 0,\r\n            i = 0,\r\n            //只初始化一次回调策略\r\n            notice = (function() {\r\n                if (options.once) {\r\n                    return function(status, img) {\r\n                        var g = this.group,\r\n                            o = this.options;\r\n                        //记录\r\n                        g[status].push(img);\r\n                        //判断改组是否全部处理完成\r\n                        if (g.success.length + g.error.length === g.count) {\r\n                            //异步\r\n                            //实际上是作为另一个任务单独执行，防止回调函数执行时间过长影响图片加载速度\r\n                            setTimeout(function() {\r\n                                o.success.call(null, g.success, g.error, g.count);\r\n                            }, 1);\r\n                        }\r\n                    };\r\n                } else {\r\n                    return function(status, img) {\r\n                        var o = this.options;\r\n                        //直接回调\r\n                        setTimeout(function() {\r\n                            o[status].call(null, img);\r\n                        }, 1);\r\n                    };\r\n                }\r\n            }()),\r\n            group = {\r\n                count: 0,\r\n                success: [],\r\n                error: []\r\n            },\r\n            node = null;\r\n        options = options || {};\r\n        options.success = options.success || emptyFn;\r\n        options.error = options.error || emptyFn;\r\n        srcs = srcs.concat(src);\r\n        //设置组元素个数\r\n        group.count = srcs.length;\r\n        //遍历需要加载的图片\r\n        for (i = 0, length = srcs.length; i < length; i++) {\r\n            //创建节点\r\n            node = this.createNode(srcs[i], options, notice, group);\r\n            //判断线程池是否有空闲\r\n            free = this.getFree();\r\n            if (free) {\r\n                //有空闲，则立即加载图片\r\n                this.setSrc(free.img, node);\r\n            } else {\r\n                //没有空闲，将任务添加到链表\r\n                this.appendNode(node);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * 获取内部状态信息\r\n     * @private\r\n     * @returns {Object}\r\n     */\r\n    ImagePool.prototype._info = function() {\r\n        var info = {},\r\n            length = 0,\r\n            i = 0,\r\n            node = null;\r\n        //线程\r\n        info.thread = {};\r\n        //线程总数量\r\n        info.thread.count = this.pool.length;\r\n        //空闲线程数量\r\n        info.thread.free = 0;\r\n        //任务\r\n        info.task = {};\r\n        //待处理任务数量\r\n        info.task.count = 0;\r\n        //获取空闲\"线程\"数量\r\n        for (i = 0, length = this.pool.length; i < length; i++) {\r\n            if (this.pool[i].free) {\r\n                info.thread.free = info.thread.free + 1;\r\n            }\r\n        }\r\n        //获取任务数量(任务链长度)\r\n        node = this.linkHead;\r\n        if (node) {\r\n            info.task.count = info.task.count + 1;\r\n            while (node.next) {\r\n                info.task.count = info.task.count + 1;\r\n                node = node.next;\r\n            }\r\n        }\r\n        return info;\r\n    };\r\n\r\n    /**\r\n     * 创建节点\r\n     * @private\r\n     * @param src 图片路径。字符串。\r\n     * @param options 用户自定义参数。包含：success回调、error回调、once标识。\r\n     * @param notice 回调策略。 函数。\r\n     * @param group 组信息。对象。{count: 0, success: [], error: []}\r\n     * @param tr 出错重试次数。数值。默认为0。\r\n     * @returns {Object}\r\n     */\r\n    ImagePool.prototype.createNode = function(src, options, notice, group, tr) {\r\n        var node = {};\r\n        node.src = src;\r\n        node.options = options;\r\n        node.notice = notice;\r\n        node.group = group;\r\n        node.tries = tr || 0;\r\n        return node;\r\n    };\r\n    /**\r\n     * 向任务链表末尾追加节点\r\n     * @private\r\n     * @param node 节点。对象。\r\n     */\r\n    ImagePool.prototype.appendNode = function(node) {\r\n        //判断链表是否为空\r\n        if (!this.linkHead) {\r\n            this.linkHead = node;\r\n            this.linkNode = node;\r\n        } else {\r\n            this.linkNode.next = node;\r\n            this.linkNode = node;\r\n        }\r\n    };\r\n    /**\r\n     * 删除链表头\r\n     * @private\r\n     */\r\n    ImagePool.prototype.shiftNode = function() {\r\n        //判断链表是否存在节点\r\n        if (this.linkHead) {\r\n            //修改链表头\r\n            this.linkHead = this.linkHead.next || null;\r\n        }\r\n    };\r\n    /**\r\n     * 初始化图片池\r\n     * @param {number} max 最大连接数。数值。\r\n     * @returns {{load: Function, info: Function}}\r\n     */\r\n    var initImagePool = function(max) {\r\n        var instance = new ImagePool(max);\r\n        instance.initPool();\r\n        return {\r\n            /**\r\n             * 加载图片\r\n             * @param {string|Array} src 可以是src字符串，也可以是src字符串数组。\r\n             * @param {Object} options 用户自定义参数。包含：success回调、error回调、once标识。\r\n             * @param {Function} [options.success] success回调\r\n             * @param {Function} [options.error] error回调\r\n             * @param {boolean} [options.once] 是否全部加载完毕后，一次回调\r\n             */\r\n            load: function() {\r\n                instance._load.apply(instance, arguments);\r\n            },\r\n            /**\r\n             * 获取内部状态信息\r\n             * @returns {Object}\r\n             */\r\n            info: function() {\r\n                return instance._info.call(instance);\r\n            }\r\n        };\r\n    };\r\n\r\n    module.exports = { initImagePool: initImagePool }\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/ImagePool.js\n// module id = 95\n// module chunks = 0","\r\n    //polyfill bind\r\n    if (!Function.prototype.bind) {\r\n        Function.prototype.bind = function(oThis) {\r\n            if (typeof this !== \"function\") {\r\n                // closest thing possible to the ECMAScript 5 internal IsCallable function\r\n                throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\r\n            }\r\n\r\n            var aArgs = Array.prototype.slice.call(arguments, 1),\r\n                fToBind = this,\r\n                fNOP = function() {},\r\n                fBound = function() {\r\n                    return fToBind.apply(this instanceof fNOP && oThis ? this : oThis || window,\r\n                        aArgs.concat(Array.prototype.slice.call(arguments)));\r\n                };\r\n\r\n            fNOP.prototype = this.prototype;\r\n            fBound.prototype = new fNOP();\r\n\r\n            return fBound;\r\n        };\r\n    }\r\n\r\n    //polyfill remove\r\n    if (!('remove' in Element.prototype)) {\r\n        Element.prototype.remove = function() {\r\n            if (this.parentNode) {\r\n                this.parentNode.removeChild(this);\r\n            }\r\n        };\r\n    }\r\n\r\n    if (!String.prototype.endsWith) {\r\n    String.prototype.endsWith = function(searchString, position) {\r\n        var subjectString = this.toString();\r\n        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {\r\n            position = subjectString.length;\r\n        }\r\n        position -= searchString.length;\r\n        var lastIndex = subjectString.indexOf(searchString, position);\r\n        return lastIndex !== -1 && lastIndex === position;\r\n    };\r\n    }\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/polyfill.js\n// module id = 96\n// module chunks = 0","require(\"./graphic\");\n\nvar _zrender = require(\"../zrender\");\n\nvar registerPainter = _zrender.registerPainter;\n\nvar Painter = require(\"./Painter\");\n\nregisterPainter('vml', Painter);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/vml/vml.js\n// module id = 97\n// module chunks = 0","var env = require(\"../core/env\");\n\nvar _vector = require(\"../core/vector\");\n\nvar applyTransform = _vector.applyTransform;\n\nvar BoundingRect = require(\"../core/BoundingRect\");\n\nvar colorTool = require(\"../tool/color\");\n\nvar textContain = require(\"../contain/text\");\n\nvar textHelper = require(\"../graphic/helper/text\");\n\nvar RectText = require(\"../graphic/mixin/RectText\");\n\nvar Displayable = require(\"../graphic/Displayable\");\n\nvar ZImage = require(\"../graphic/Image\");\n\nvar Text = require(\"../graphic/Text\");\n\nvar Path = require(\"../graphic/Path\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar Gradient = require(\"../graphic/Gradient\");\n\nvar vmlCore = require(\"./core\");\n\n// http://www.w3.org/TR/NOTE-VML\n// TODO Use proxy like svg instead of overwrite brush methods\nvar CMD = PathProxy.CMD;\nvar round = Math.round;\nvar sqrt = Math.sqrt;\nvar abs = Math.abs;\nvar cos = Math.cos;\nvar sin = Math.sin;\nvar mathMax = Math.max;\n\nif (!env.canvasSupported) {\n  var comma = ',';\n  var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n  var Z = 21600;\n  var Z2 = Z / 2;\n  var ZLEVEL_BASE = 100000;\n  var Z_BASE = 1000;\n\n  var initRootElStyle = function (el) {\n    el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n    el.coordsize = Z + ',' + Z;\n    el.coordorigin = '0,0';\n  };\n\n  var encodeHtmlAttribute = function (s) {\n    return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n  };\n\n  var rgb2Str = function (r, g, b) {\n    return 'rgb(' + [r, g, b].join(',') + ')';\n  };\n\n  var append = function (parent, child) {\n    if (child && parent && child.parentNode !== parent) {\n      parent.appendChild(child);\n    }\n  };\n\n  var remove = function (parent, child) {\n    if (child && parent && child.parentNode === parent) {\n      parent.removeChild(child);\n    }\n  };\n\n  var getZIndex = function (zlevel, z, z2) {\n    // z 的取值范围为 [0, 1000]\n    return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n  };\n\n  var parsePercent = function (value, maxValue) {\n    if (typeof value === 'string') {\n      if (value.lastIndexOf('%') >= 0) {\n        return parseFloat(value) / 100 * maxValue;\n      }\n\n      return parseFloat(value);\n    }\n\n    return value;\n  };\n  /***************************************************\n   * PATH\n   **************************************************/\n\n\n  var setColorAndOpacity = function (el, color, opacity) {\n    var colorArr = colorTool.parse(color);\n    opacity = +opacity;\n\n    if (isNaN(opacity)) {\n      opacity = 1;\n    }\n\n    if (colorArr) {\n      el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n      el.opacity = opacity * colorArr[3];\n    }\n  };\n\n  var getColorAndAlpha = function (color) {\n    var colorArr = colorTool.parse(color);\n    return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];\n  };\n\n  var updateFillNode = function (el, style, zrEl) {\n    // TODO pattern\n    var fill = style.fill;\n\n    if (fill != null) {\n      // Modified from excanvas\n      if (fill instanceof Gradient) {\n        var gradientType;\n        var angle = 0;\n        var focus = [0, 0]; // additional offset\n\n        var shift = 0; // scale factor for offset\n\n        var expansion = 1;\n        var rect = zrEl.getBoundingRect();\n        var rectWidth = rect.width;\n        var rectHeight = rect.height;\n\n        if (fill.type === 'linear') {\n          gradientType = 'gradient';\n          var transform = zrEl.transform;\n          var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n          var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n\n          if (transform) {\n            applyTransform(p0, p0, transform);\n            applyTransform(p1, p1, transform);\n          }\n\n          var dx = p1[0] - p0[0];\n          var dy = p1[1] - p0[1];\n          angle = Math.atan2(dx, dy) * 180 / Math.PI; // The angle should be a non-negative number.\n\n          if (angle < 0) {\n            angle += 360;\n          } // Very small angles produce an unexpected result because they are\n          // converted to a scientific notation string.\n\n\n          if (angle < 1e-6) {\n            angle = 0;\n          }\n        } else {\n          gradientType = 'gradientradial';\n          var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n          var transform = zrEl.transform;\n          var scale = zrEl.scale;\n          var width = rectWidth;\n          var height = rectHeight;\n          focus = [// Percent in bounding rect\n          (p0[0] - rect.x) / width, (p0[1] - rect.y) / height];\n\n          if (transform) {\n            applyTransform(p0, p0, transform);\n          }\n\n          width /= scale[0] * Z;\n          height /= scale[1] * Z;\n          var dimension = mathMax(width, height);\n          shift = 2 * 0 / dimension;\n          expansion = 2 * fill.r / dimension - shift;\n        } // We need to sort the color stops in ascending order by offset,\n        // otherwise IE won't interpret it correctly.\n\n\n        var stops = fill.colorStops.slice();\n        stops.sort(function (cs1, cs2) {\n          return cs1.offset - cs2.offset;\n        });\n        var length = stops.length; // Color and alpha list of first and last stop\n\n        var colorAndAlphaList = [];\n        var colors = [];\n\n        for (var i = 0; i < length; i++) {\n          var stop = stops[i];\n          var colorAndAlpha = getColorAndAlpha(stop.color);\n          colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n\n          if (i === 0 || i === length - 1) {\n            colorAndAlphaList.push(colorAndAlpha);\n          }\n        }\n\n        if (length >= 2) {\n          var color1 = colorAndAlphaList[0][0];\n          var color2 = colorAndAlphaList[1][0];\n          var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n          var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n          el.type = gradientType;\n          el.method = 'none';\n          el.focus = '100%';\n          el.angle = angle;\n          el.color = color1;\n          el.color2 = color2;\n          el.colors = colors.join(','); // When colors attribute is used, the meanings of opacity and o:opacity2\n          // are reversed.\n\n          el.opacity = opacity2; // FIXME g_o_:opacity ?\n\n          el.opacity2 = opacity1;\n        }\n\n        if (gradientType === 'radial') {\n          el.focusposition = focus.join(',');\n        }\n      } else {\n        // FIXME Change from Gradient fill to color fill\n        setColorAndOpacity(el, fill, style.opacity);\n      }\n    }\n  };\n\n  var updateStrokeNode = function (el, style) {\n    // if (style.lineJoin != null) {\n    //     el.joinstyle = style.lineJoin;\n    // }\n    // if (style.miterLimit != null) {\n    //     el.miterlimit = style.miterLimit * Z;\n    // }\n    // if (style.lineCap != null) {\n    //     el.endcap = style.lineCap;\n    // }\n    if (style.lineDash != null) {\n      el.dashstyle = style.lineDash.join(' ');\n    }\n\n    if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n      setColorAndOpacity(el, style.stroke, style.opacity);\n    }\n  };\n\n  var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n    var isFill = type == 'fill';\n    var el = vmlEl.getElementsByTagName(type)[0]; // Stroke must have lineWidth\n\n    if (style[type] != null && style[type] !== 'none' && (isFill || !isFill && style.lineWidth)) {\n      vmlEl[isFill ? 'filled' : 'stroked'] = 'true'; // FIXME Remove before updating, or set `colors` will throw error\n\n      if (style[type] instanceof Gradient) {\n        remove(vmlEl, el);\n      }\n\n      if (!el) {\n        el = vmlCore.createNode(type);\n      }\n\n      isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n      append(vmlEl, el);\n    } else {\n      vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n      remove(vmlEl, el);\n    }\n  };\n\n  var points = [[], [], []];\n\n  var pathDataToString = function (path, m) {\n    var M = CMD.M;\n    var C = CMD.C;\n    var L = CMD.L;\n    var A = CMD.A;\n    var Q = CMD.Q;\n    var str = [];\n    var nPoint;\n    var cmdStr;\n    var cmd;\n    var i;\n    var xi;\n    var yi;\n    var data = path.data;\n    var dataLength = path.len();\n\n    for (i = 0; i < dataLength;) {\n      cmd = data[i++];\n      cmdStr = '';\n      nPoint = 0;\n\n      switch (cmd) {\n        case M:\n          cmdStr = ' m ';\n          nPoint = 1;\n          xi = data[i++];\n          yi = data[i++];\n          points[0][0] = xi;\n          points[0][1] = yi;\n          break;\n\n        case L:\n          cmdStr = ' l ';\n          nPoint = 1;\n          xi = data[i++];\n          yi = data[i++];\n          points[0][0] = xi;\n          points[0][1] = yi;\n          break;\n\n        case Q:\n        case C:\n          cmdStr = ' c ';\n          nPoint = 3;\n          var x1 = data[i++];\n          var y1 = data[i++];\n          var x2 = data[i++];\n          var y2 = data[i++];\n          var x3;\n          var y3;\n\n          if (cmd === Q) {\n            // Convert quadratic to cubic using degree elevation\n            x3 = x2;\n            y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (xi + 2 * x1) / 3;\n            y1 = (yi + 2 * y1) / 3;\n          } else {\n            x3 = data[i++];\n            y3 = data[i++];\n          }\n\n          points[0][0] = x1;\n          points[0][1] = y1;\n          points[1][0] = x2;\n          points[1][1] = y2;\n          points[2][0] = x3;\n          points[2][1] = y3;\n          xi = x3;\n          yi = y3;\n          break;\n\n        case A:\n          var x = 0;\n          var y = 0;\n          var sx = 1;\n          var sy = 1;\n          var angle = 0;\n\n          if (m) {\n            // Extract SRT from matrix\n            x = m[4];\n            y = m[5];\n            sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n            sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n            angle = Math.atan2(-m[1] / sy, m[0] / sx);\n          }\n\n          var cx = data[i++];\n          var cy = data[i++];\n          var rx = data[i++];\n          var ry = data[i++];\n          var startAngle = data[i++] + angle;\n          var endAngle = data[i++] + startAngle + angle; // FIXME\n          // var psi = data[i++];\n\n          i++;\n          var clockwise = data[i++];\n          var x0 = cx + cos(startAngle) * rx;\n          var y0 = cy + sin(startAngle) * ry;\n          var x1 = cx + cos(endAngle) * rx;\n          var y1 = cy + sin(endAngle) * ry;\n          var type = clockwise ? ' wa ' : ' at ';\n\n          if (Math.abs(x0 - x1) < 1e-4) {\n            // IE won't render arches drawn counter clockwise if x0 == x1.\n            if (Math.abs(endAngle - startAngle) > 1e-2) {\n              // Offset x0 by 1/80 of a pixel. Use something\n              // that can be represented in binary\n              if (clockwise) {\n                x0 += 270 / Z;\n              }\n            } else {\n              // Avoid case draw full circle\n              if (Math.abs(y0 - cy) < 1e-4) {\n                if (clockwise && x0 < cx || !clockwise && x0 > cx) {\n                  y1 -= 270 / Z;\n                } else {\n                  y1 += 270 / Z;\n                }\n              } else if (clockwise && y0 < cy || !clockwise && y0 > cy) {\n                x1 += 270 / Z;\n              } else {\n                x1 -= 270 / Z;\n              }\n            }\n          }\n\n          str.push(type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2));\n          xi = x1;\n          yi = y1;\n          break;\n\n        case CMD.R:\n          var p0 = points[0];\n          var p1 = points[1]; // x0, y0\n\n          p0[0] = data[i++];\n          p0[1] = data[i++]; // x1, y1\n\n          p1[0] = p0[0] + data[i++];\n          p1[1] = p0[1] + data[i++];\n\n          if (m) {\n            applyTransform(p0, p0, m);\n            applyTransform(p1, p1, m);\n          }\n\n          p0[0] = round(p0[0] * Z - Z2);\n          p1[0] = round(p1[0] * Z - Z2);\n          p0[1] = round(p0[1] * Z - Z2);\n          p1[1] = round(p1[1] * Z - Z2);\n          str.push( // x0, y0\n          ' m ', p0[0], comma, p0[1], // x1, y0\n          ' l ', p1[0], comma, p0[1], // x1, y1\n          ' l ', p1[0], comma, p1[1], // x0, y1\n          ' l ', p0[0], comma, p1[1]);\n          break;\n\n        case CMD.Z:\n          // FIXME Update xi, yi\n          str.push(' x ');\n      }\n\n      if (nPoint > 0) {\n        str.push(cmdStr);\n\n        for (var k = 0; k < nPoint; k++) {\n          var p = points[k];\n          m && applyTransform(p, p, m); // 不 round 会非常慢\n\n          str.push(round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k < nPoint - 1 ? comma : '');\n        }\n      }\n    }\n\n    return str.join('');\n  }; // Rewrite the original path method\n\n\n  Path.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n    var vmlEl = this._vmlEl;\n\n    if (!vmlEl) {\n      vmlEl = vmlCore.createNode('shape');\n      initRootElStyle(vmlEl);\n      this._vmlEl = vmlEl;\n    }\n\n    updateFillAndStroke(vmlEl, 'fill', style, this);\n    updateFillAndStroke(vmlEl, 'stroke', style, this);\n    var m = this.transform;\n    var needTransform = m != null;\n    var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n\n    if (strokeEl) {\n      var lineWidth = style.lineWidth; // Get the line scale.\n      // Determinant of this.m_ means how much the area is enlarged by the\n      // transformation. So its square root can be used as a scale factor\n      // for width.\n\n      if (needTransform && !style.strokeNoScale) {\n        var det = m[0] * m[3] - m[1] * m[2];\n        lineWidth *= sqrt(abs(det));\n      }\n\n      strokeEl.weight = lineWidth + 'px';\n    }\n\n    var path = this.path || (this.path = new PathProxy());\n\n    if (this.__dirtyPath) {\n      path.beginPath();\n      this.buildPath(path, this.shape);\n      path.toStatic();\n      this.__dirtyPath = false;\n    }\n\n    vmlEl.path = pathDataToString(path, this.transform);\n    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\n    append(vmlRoot, vmlEl); // Text\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, this.getBoundingRect());\n    } else {\n      this.removeRectText(vmlRoot);\n    }\n  };\n\n  Path.prototype.onRemove = function (vmlRoot) {\n    remove(vmlRoot, this._vmlEl);\n    this.removeRectText(vmlRoot);\n  };\n\n  Path.prototype.onAdd = function (vmlRoot) {\n    append(vmlRoot, this._vmlEl);\n    this.appendRectText(vmlRoot);\n  };\n  /***************************************************\n   * IMAGE\n   **************************************************/\n\n\n  var isImage = function (img) {\n    // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错\n    return typeof img === 'object' && img.tagName && img.tagName.toUpperCase() === 'IMG'; // return img instanceof Image;\n  }; // Rewrite the original path method\n\n\n  ZImage.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n    var image = style.image; // Image original width, height\n\n    var ow;\n    var oh;\n\n    if (isImage(image)) {\n      var src = image.src;\n\n      if (src === this._imageSrc) {\n        ow = this._imageWidth;\n        oh = this._imageHeight;\n      } else {\n        var imageRuntimeStyle = image.runtimeStyle;\n        var oldRuntimeWidth = imageRuntimeStyle.width;\n        var oldRuntimeHeight = imageRuntimeStyle.height;\n        imageRuntimeStyle.width = 'auto';\n        imageRuntimeStyle.height = 'auto'; // get the original size\n\n        ow = image.width;\n        oh = image.height; // and remove overides\n\n        imageRuntimeStyle.width = oldRuntimeWidth;\n        imageRuntimeStyle.height = oldRuntimeHeight; // Caching image original width, height and src\n\n        this._imageSrc = src;\n        this._imageWidth = ow;\n        this._imageHeight = oh;\n      }\n\n      image = src;\n    } else {\n      if (image === this._imageSrc) {\n        ow = this._imageWidth;\n        oh = this._imageHeight;\n      }\n    }\n\n    if (!image) {\n      return;\n    }\n\n    var x = style.x || 0;\n    var y = style.y || 0;\n    var dw = style.width;\n    var dh = style.height;\n    var sw = style.sWidth;\n    var sh = style.sHeight;\n    var sx = style.sx || 0;\n    var sy = style.sy || 0;\n    var hasCrop = sw && sh;\n    var vmlEl = this._vmlEl;\n\n    if (!vmlEl) {\n      // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。\n      // vmlEl = vmlCore.createNode('group');\n      vmlEl = vmlCore.doc.createElement('div');\n      initRootElStyle(vmlEl);\n      this._vmlEl = vmlEl;\n    }\n\n    var vmlElStyle = vmlEl.style;\n    var hasRotation = false;\n    var m;\n    var scaleX = 1;\n    var scaleY = 1;\n\n    if (this.transform) {\n      m = this.transform;\n      scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n      scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n      hasRotation = m[1] || m[2];\n    }\n\n    if (hasRotation) {\n      // If filters are necessary (rotation exists), create them\n      // filters are bog-slow, so only create them if abbsolutely necessary\n      // The following check doesn't account for skews (which don't exist\n      // in the canvas spec (yet) anyway.\n      // From excanvas\n      var p0 = [x, y];\n      var p1 = [x + dw, y];\n      var p2 = [x, y + dh];\n      var p3 = [x + dw, y + dh];\n      applyTransform(p0, p0, m);\n      applyTransform(p1, p1, m);\n      applyTransform(p2, p2, m);\n      applyTransform(p3, p3, m);\n      var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n      var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n      var transformFilter = [];\n      transformFilter.push('M11=', m[0] / scaleX, comma, 'M12=', m[2] / scaleY, comma, 'M21=', m[1] / scaleX, comma, 'M22=', m[3] / scaleY, comma, 'Dx=', round(x * scaleX + m[4]), comma, 'Dy=', round(y * scaleY + m[5]));\n      vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0'; // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用\n\n      vmlElStyle.filter = imageTransformPrefix + '.Matrix(' + transformFilter.join('') + ', SizingMethod=clip)';\n    } else {\n      if (m) {\n        x = x * scaleX + m[4];\n        y = y * scaleY + m[5];\n      }\n\n      vmlElStyle.filter = '';\n      vmlElStyle.left = round(x) + 'px';\n      vmlElStyle.top = round(y) + 'px';\n    }\n\n    var imageEl = this._imageEl;\n    var cropEl = this._cropEl;\n\n    if (!imageEl) {\n      imageEl = vmlCore.doc.createElement('div');\n      this._imageEl = imageEl;\n    }\n\n    var imageELStyle = imageEl.style;\n\n    if (hasCrop) {\n      // Needs know image original width and height\n      if (!(ow && oh)) {\n        var tmpImage = new Image();\n        var self = this;\n\n        tmpImage.onload = function () {\n          tmpImage.onload = null;\n          ow = tmpImage.width;\n          oh = tmpImage.height; // Adjust image width and height to fit the ratio destinationSize / sourceSize\n\n          imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n          imageELStyle.height = round(scaleY * oh * dh / sh) + 'px'; // Caching image original width, height and src\n\n          self._imageWidth = ow;\n          self._imageHeight = oh;\n          self._imageSrc = image;\n        };\n\n        tmpImage.src = image;\n      } else {\n        imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n        imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n      }\n\n      if (!cropEl) {\n        cropEl = vmlCore.doc.createElement('div');\n        cropEl.style.overflow = 'hidden';\n        this._cropEl = cropEl;\n      }\n\n      var cropElStyle = cropEl.style;\n      cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n      cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n      cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx=' + -sx * dw / sw * scaleX + ',Dy=' + -sy * dh / sh * scaleY + ')';\n\n      if (!cropEl.parentNode) {\n        vmlEl.appendChild(cropEl);\n      }\n\n      if (imageEl.parentNode != cropEl) {\n        cropEl.appendChild(imageEl);\n      }\n    } else {\n      imageELStyle.width = round(scaleX * dw) + 'px';\n      imageELStyle.height = round(scaleY * dh) + 'px';\n      vmlEl.appendChild(imageEl);\n\n      if (cropEl && cropEl.parentNode) {\n        vmlEl.removeChild(cropEl);\n        this._cropEl = null;\n      }\n    }\n\n    var filterStr = '';\n    var alpha = style.opacity;\n\n    if (alpha < 1) {\n      filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n    }\n\n    filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n    imageELStyle.filter = filterStr;\n    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\n    append(vmlRoot, vmlEl); // Text\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, this.getBoundingRect());\n    }\n  };\n\n  ZImage.prototype.onRemove = function (vmlRoot) {\n    remove(vmlRoot, this._vmlEl);\n    this._vmlEl = null;\n    this._cropEl = null;\n    this._imageEl = null;\n    this.removeRectText(vmlRoot);\n  };\n\n  ZImage.prototype.onAdd = function (vmlRoot) {\n    append(vmlRoot, this._vmlEl);\n    this.appendRectText(vmlRoot);\n  };\n  /***************************************************\n   * TEXT\n   **************************************************/\n\n\n  var DEFAULT_STYLE_NORMAL = 'normal';\n  var fontStyleCache = {};\n  var fontStyleCacheCount = 0;\n  var MAX_FONT_CACHE_SIZE = 100;\n  var fontEl = document.createElement('div');\n\n  var getFontStyle = function (fontString) {\n    var fontStyle = fontStyleCache[fontString];\n\n    if (!fontStyle) {\n      // Clear cache\n      if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n        fontStyleCacheCount = 0;\n        fontStyleCache = {};\n      }\n\n      var style = fontEl.style;\n      var fontFamily;\n\n      try {\n        style.font = fontString;\n        fontFamily = style.fontFamily.split(',')[0];\n      } catch (e) {}\n\n      fontStyle = {\n        style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n        variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n        weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n        size: parseFloat(style.fontSize || 12) | 0,\n        family: fontFamily || 'Microsoft YaHei'\n      };\n      fontStyleCache[fontString] = fontStyle;\n      fontStyleCacheCount++;\n    }\n\n    return fontStyle;\n  };\n\n  var textMeasureEl; // Overwrite measure text method\n\n  textContain.$override('measureText', function (text, textFont) {\n    var doc = vmlCore.doc;\n\n    if (!textMeasureEl) {\n      textMeasureEl = doc.createElement('div');\n      textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;' + 'padding:0;margin:0;border:none;white-space:pre;';\n      vmlCore.doc.body.appendChild(textMeasureEl);\n    }\n\n    try {\n      textMeasureEl.style.font = textFont;\n    } catch (ex) {// Ignore failures to set to invalid font.\n    }\n\n    textMeasureEl.innerHTML = ''; // Don't use innerHTML or innerText because they allow markup/whitespace.\n\n    textMeasureEl.appendChild(doc.createTextNode(text));\n    return {\n      width: textMeasureEl.offsetWidth\n    };\n  });\n  var tmpRect = new BoundingRect();\n\n  var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true);\n    var text = style.text; // Convert to string\n\n    text != null && (text += '');\n\n    if (!text) {\n      return;\n    } // Convert rich text to plain text. Rich text is not supported in\n    // IE8-, but tags in rich text template will be removed.\n\n\n    if (style.rich) {\n      var contentBlock = textContain.parseRichText(text, style);\n      text = [];\n\n      for (var i = 0; i < contentBlock.lines.length; i++) {\n        var tokens = contentBlock.lines[i].tokens;\n        var textLine = [];\n\n        for (var j = 0; j < tokens.length; j++) {\n          textLine.push(tokens[j].text);\n        }\n\n        text.push(textLine.join(''));\n      }\n\n      text = text.join('\\n');\n    }\n\n    var x;\n    var y;\n    var align = style.textAlign;\n    var verticalAlign = style.textVerticalAlign;\n    var fontStyle = getFontStyle(style.font); // FIXME encodeHtmlAttribute ?\n\n    var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' ' + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n    textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign); // Transform rect to view space\n\n    var m = this.transform; // Ignore transform for text in other element\n\n    if (m && !fromTextEl) {\n      tmpRect.copy(rect);\n      tmpRect.applyTransform(m);\n      rect = tmpRect;\n    }\n\n    if (!fromTextEl) {\n      var textPosition = style.textPosition;\n      var distance = style.textDistance; // Text position represented by coord\n\n      if (textPosition instanceof Array) {\n        x = rect.x + parsePercent(textPosition[0], rect.width);\n        y = rect.y + parsePercent(textPosition[1], rect.height);\n        align = align || 'left';\n      } else {\n        var res = textContain.adjustTextPositionOnRect(textPosition, rect, distance);\n        x = res.x;\n        y = res.y; // Default align and baseline when has textPosition\n\n        align = align || res.textAlign;\n        verticalAlign = verticalAlign || res.textVerticalAlign;\n      }\n    } else {\n      x = rect.x;\n      y = rect.y;\n    }\n\n    x = textContain.adjustTextX(x, textRect.width, align);\n    y = textContain.adjustTextY(y, textRect.height, verticalAlign); // Force baseline 'middle'\n\n    y += textRect.height / 2; // var fontSize = fontStyle.size;\n    // 1.75 is an arbitrary number, as there is no info about the text baseline\n    // switch (baseline) {\n    // case 'hanging':\n    // case 'top':\n    //     y += fontSize / 1.75;\n    //     break;\n    //     case 'middle':\n    //         break;\n    //     default:\n    //     // case null:\n    //     // case 'alphabetic':\n    //     // case 'ideographic':\n    //     // case 'bottom':\n    //         y -= fontSize / 2.25;\n    //         break;\n    // }\n    // switch (align) {\n    //     case 'left':\n    //         break;\n    //     case 'center':\n    //         x -= textRect.width / 2;\n    //         break;\n    //     case 'right':\n    //         x -= textRect.width;\n    //         break;\n    // case 'end':\n    // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n    // break;\n    // case 'start':\n    // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n    // break;\n    // default:\n    //     align = 'left';\n    // }\n\n    var createNode = vmlCore.createNode;\n    var textVmlEl = this._textVmlEl;\n    var pathEl;\n    var textPathEl;\n    var skewEl;\n\n    if (!textVmlEl) {\n      textVmlEl = createNode('line');\n      pathEl = createNode('path');\n      textPathEl = createNode('textpath');\n      skewEl = createNode('skew'); // FIXME Why here is not cammel case\n      // Align 'center' seems wrong\n\n      textPathEl.style['v-text-align'] = 'left';\n      initRootElStyle(textVmlEl);\n      pathEl.textpathok = true;\n      textPathEl.on = true;\n      textVmlEl.from = '0 0';\n      textVmlEl.to = '1000 0.05';\n      append(textVmlEl, skewEl);\n      append(textVmlEl, pathEl);\n      append(textVmlEl, textPathEl);\n      this._textVmlEl = textVmlEl;\n    } else {\n      // 这里是在前面 appendChild 保证顺序的前提下\n      skewEl = textVmlEl.firstChild;\n      pathEl = skewEl.nextSibling;\n      textPathEl = pathEl.nextSibling;\n    }\n\n    var coords = [x, y];\n    var textVmlElStyle = textVmlEl.style; // Ignore transform for text in other element\n\n    if (m && fromTextEl) {\n      applyTransform(coords, coords, m);\n      skewEl.on = true;\n      skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0'; // Text position\n\n      skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0); // Left top point as origin\n\n      skewEl.origin = '0 0';\n      textVmlElStyle.left = '0px';\n      textVmlElStyle.top = '0px';\n    } else {\n      skewEl.on = false;\n      textVmlElStyle.left = round(x) + 'px';\n      textVmlElStyle.top = round(y) + 'px';\n    }\n\n    textPathEl.string = encodeHtmlAttribute(text); // TODO\n\n    try {\n      textPathEl.style.font = font;\n    } // Error font format\n    catch (e) {}\n\n    updateFillAndStroke(textVmlEl, 'fill', {\n      fill: style.textFill,\n      opacity: style.opacity\n    }, this);\n    updateFillAndStroke(textVmlEl, 'stroke', {\n      stroke: style.textStroke,\n      opacity: style.opacity,\n      lineDash: style.lineDash\n    }, this);\n    textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Attached to root\n\n    append(vmlRoot, textVmlEl);\n  };\n\n  var removeRectText = function (vmlRoot) {\n    remove(vmlRoot, this._textVmlEl);\n    this._textVmlEl = null;\n  };\n\n  var appendRectText = function (vmlRoot) {\n    append(vmlRoot, this._textVmlEl);\n  };\n\n  var list = [RectText, Displayable, ZImage, Path, Text]; // In case Displayable has been mixed in RectText\n\n  for (var i = 0; i < list.length; i++) {\n    var proto = list[i].prototype;\n    proto.drawRectText = drawRectText;\n    proto.removeRectText = removeRectText;\n    proto.appendRectText = appendRectText;\n  }\n\n  Text.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, {\n        x: style.x || 0,\n        y: style.y || 0,\n        width: 0,\n        height: 0\n      }, this.getBoundingRect(), true);\n    } else {\n      this.removeRectText(vmlRoot);\n    }\n  };\n\n  Text.prototype.onRemove = function (vmlRoot) {\n    this.removeRectText(vmlRoot);\n  };\n\n  Text.prototype.onAdd = function (vmlRoot) {\n    this.appendRectText(vmlRoot);\n  };\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/vml/graphic.js\n// module id = 98\n// module chunks = 0","var env = require(\"../core/env\");\n\nvar urn = 'urn:schemas-microsoft-com:vml';\nvar win = typeof window === 'undefined' ? null : window;\nvar vmlInited = false;\nvar doc = win && win.document;\n\nfunction createNode(tagName) {\n  return doCreateNode(tagName);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nvar doCreateNode;\n\nif (doc && !env.canvasSupported) {\n  try {\n    !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);\n\n    doCreateNode = function (tagName) {\n      return doc.createElement('<zrvml:' + tagName + ' class=\"zrvml\">');\n    };\n  } catch (e) {\n    doCreateNode = function (tagName) {\n      return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"zrvml\">');\n    };\n  }\n} // From raphael\n\n\nfunction initVML() {\n  if (vmlInited || !doc) {\n    return;\n  }\n\n  vmlInited = true;\n  var styleSheets = doc.styleSheets;\n\n  if (styleSheets.length < 31) {\n    doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');\n  } else {\n    // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n    styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');\n  }\n}\n\nexports.doc = doc;\nexports.createNode = createNode;\nexports.initVML = initVML;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/vml/core.js\n// module id = 99\n// module chunks = 0","var zrLog = require(\"../core/log\");\n\nvar vmlCore = require(\"./core\");\n\nvar _util = require(\"../core/util\");\n\nvar each = _util.each;\n\n/**\n * VML Painter.\n *\n * @module zrender/vml/Painter\n */\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n/**\n * @alias module:zrender/vml/Painter\n */\n\n\nfunction VMLPainter(root, storage) {\n  vmlCore.initVML();\n  this.root = root;\n  this.storage = storage;\n  var vmlViewport = document.createElement('div');\n  var vmlRoot = document.createElement('div');\n  vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n  vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n  root.appendChild(vmlViewport);\n  this._vmlRoot = vmlRoot;\n  this._vmlViewport = vmlViewport;\n  this.resize(); // Modify storage\n\n  var oldDelFromStorage = storage.delFromStorage;\n  var oldAddToStorage = storage.addToStorage;\n\n  storage.delFromStorage = function (el) {\n    oldDelFromStorage.call(storage, el);\n\n    if (el) {\n      el.onRemove && el.onRemove(vmlRoot);\n    }\n  };\n\n  storage.addToStorage = function (el) {\n    // Displayable already has a vml node\n    el.onAdd && el.onAdd(vmlRoot);\n    oldAddToStorage.call(storage, el);\n  };\n\n  this._firstPaint = true;\n}\n\nVMLPainter.prototype = {\n  constructor: VMLPainter,\n  getType: function () {\n    return 'vml';\n  },\n\n  /**\n   * @return {HTMLDivElement}\n   */\n  getViewportRoot: function () {\n    return this._vmlViewport;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\n   * 刷新\n   */\n  refresh: function () {\n    var list = this.storage.getDisplayList(true, true);\n\n    this._paintList(list);\n  },\n  _paintList: function (list) {\n    var vmlRoot = this._vmlRoot;\n\n    for (var i = 0; i < list.length; i++) {\n      var el = list[i];\n\n      if (el.invisible || el.ignore) {\n        if (!el.__alreadyNotVisible) {\n          el.onRemove(vmlRoot);\n        } // Set as already invisible\n\n\n        el.__alreadyNotVisible = true;\n      } else {\n        if (el.__alreadyNotVisible) {\n          el.onAdd(vmlRoot);\n        }\n\n        el.__alreadyNotVisible = false;\n\n        if (el.__dirty) {\n          el.beforeBrush && el.beforeBrush();\n          (el.brushVML || el.brush).call(el, vmlRoot);\n          el.afterBrush && el.afterBrush();\n        }\n      }\n\n      el.__dirty = false;\n    }\n\n    if (this._firstPaint) {\n      // Detached from document at first time\n      // to avoid page refreshing too many times\n      // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变\n      this._vmlViewport.appendChild(vmlRoot);\n\n      this._firstPaint = false;\n    }\n  },\n  resize: function (width, height) {\n    var width = width == null ? this._getWidth() : width;\n    var height = height == null ? this._getHeight() : height;\n\n    if (this._width != width || this._height != height) {\n      this._width = width;\n      this._height = height;\n      var vmlViewportStyle = this._vmlViewport.style;\n      vmlViewportStyle.width = width + 'px';\n      vmlViewportStyle.height = height + 'px';\n    }\n  },\n  dispose: function () {\n    this.root.innerHTML = '';\n    this._vmlRoot = this._vmlViewport = this.storage = null;\n  },\n  getWidth: function () {\n    return this._width;\n  },\n  getHeight: function () {\n    return this._height;\n  },\n  clear: function () {\n    if (this._vmlViewport) {\n      this.root.removeChild(this._vmlViewport);\n    }\n  },\n  _getWidth: function () {\n    var root = this.root;\n    var stl = root.currentStyle;\n    return (root.clientWidth || parseInt10(stl.width)) - parseInt10(stl.paddingLeft) - parseInt10(stl.paddingRight) | 0;\n  },\n  _getHeight: function () {\n    var root = this.root;\n    var stl = root.currentStyle;\n    return (root.clientHeight || parseInt10(stl.height)) - parseInt10(stl.paddingTop) - parseInt10(stl.paddingBottom) | 0;\n  }\n}; // Not supported methods\n\nfunction createMethodNotSupport(method) {\n  return function () {\n    zrLog('In IE8.0 VML mode painter not support method \"' + method + '\"');\n  };\n} // Unsupported methods\n\n\neach(['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'], function (name) {\n  VMLPainter.prototype[name] = createMethodNotSupport(name);\n});\nvar _default = VMLPainter;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/vml/Painter.js\n// module id = 100\n// module chunks = 0"]}